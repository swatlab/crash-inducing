35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #ifndef dom_plugins_PluginModuleParent_h
35893: #define dom_plugins_PluginModuleParent_h 1
35740: 
35740: #include <cstring>
35740: 
35746: #include "base/basictypes.h"
35746: 
35740: #include "prlink.h"
35740: 
35740: #include "npapi.h"
35740: #include "npfunctions.h"
35740: 
35740: #include "base/string_util.h"
35740: 
36010: #include "mozilla/PluginLibrary.h"
35898: #include "mozilla/plugins/PPluginModuleParent.h"
35893: #include "mozilla/plugins/PluginInstanceParent.h"
35740: #include "mozilla/plugins/PluginProcessParent.h"
35740: 
35747: #include "nsAutoPtr.h"
35913: #include "nsTHashtable.h"
35913: #include "nsHashKeys.h"
37384: #include "nsIFileStreams.h"
35747: 
35740: namespace mozilla {
35740: namespace plugins {
35740: //-----------------------------------------------------------------------------
35740: 
36138: class BrowserStreamParent;
36138: 
35740: /**
35893:  * PluginModuleParent
35740:  *
35740:  * This class implements the NPP API from the perspective of the rest
35740:  * of Gecko, forwarding NPP calls along to the child process that is
35740:  * actually running the plugin.
35740:  *
35740:  * This class /also/ implements a version of the NPN API, because the
35740:  * child process needs to make these calls back into Gecko proper.
35740:  * This class is responsible for "actually" making those function calls.
35740:  */
36010: class PluginModuleParent : public PPluginModuleParent, PluginLibrary
35740: {
35740: private:
36010:     typedef mozilla::PluginLibrary PluginLibrary;
35746: 
35746: protected:
35898:     PPluginInstanceParent*
35943:     AllocPPluginInstance(const nsCString& aMimeType,
35746:                          const uint16_t& aMode,
35820:                          const nsTArray<nsCString>& aNames,
35820:                          const nsTArray<nsCString>& aValues,
35746:                          NPError* rv);
35746: 
35926:     virtual bool
36138:     DeallocPPluginInstance(PPluginInstanceParent* aActor);
35740: 
35740: public:
35893:     PluginModuleParent(const char* aFilePath);
36304:     virtual ~PluginModuleParent();
36173: 
36304:     NS_OVERRIDE virtual void SetPlugin(nsNPAPIPlugin* plugin)
36304:     {
36304:         mPlugin = plugin;
36304:     }
35740: 
36145:     NS_OVERRIDE virtual void ActorDestroy(ActorDestroyReason why);
36145: 
35740:     /**
35740:      * LoadModule
35740:      *
36010:      * This may or may not launch a plugin child process,
35740:      * and may or may not be very expensive.
35740:      */
36010:     static PluginLibrary* LoadModule(const char* aFilePath);
35740: 
38121:     const NPNetscapeFuncs* GetNetscapeFuncs() {
38121:         return mNPNIface;
38121:     }
38121: 
38123:     base::ProcessHandle ChildProcessHandle() { return mSubprocess->GetChildProcessHandle(); }
38123: 
38121:     bool EnsureValidNPIdentifier(NPIdentifier aIdentifier);
38121: 
39257:     bool OkToCleanup() const {
39257:         return !IsOnCxxStack();
39257:     }
39257: 
38121: protected:
38121:     NS_OVERRIDE
39265:     virtual mozilla::ipc::RPCChannel::RacyRPCPolicy
39265:     MediateRPCRace(const Message& parent, const Message& child)
39265:     {
39265:         return MediateRace(parent, child);
39265:     }
39265: 
39265:     NS_OVERRIDE
38121:     virtual bool ShouldContinueFromReplyTimeout();
38121: 
35968:     virtual bool
35968:     AnswerNPN_UserAgent(nsCString* userAgent);
35968: 
35835:     // NPRemoteIdentifier funcs
35926:     virtual bool
35835:     RecvNPN_GetStringIdentifier(const nsCString& aString,
35835:                                 NPRemoteIdentifier* aId);
35926:     virtual bool
35835:     RecvNPN_GetIntIdentifier(const int32_t& aInt,
35835:                              NPRemoteIdentifier* aId);
35926:     virtual bool
35835:     RecvNPN_UTF8FromIdentifier(const NPRemoteIdentifier& aId,
35927:                                NPError* err,
35835:                                nsCString* aString);
35926:     virtual bool
35835:     RecvNPN_IntFromIdentifier(const NPRemoteIdentifier& aId,
35927:                               NPError* err,
35835:                               int32_t* aInt);
35926:     virtual bool
35835:     RecvNPN_IdentifierIsString(const NPRemoteIdentifier& aId,
35835:                                bool* aIsString);
35926:     virtual bool
35913:     RecvNPN_GetStringIdentifiers(const nsTArray<nsCString>& aNames,
35835:                                  nsTArray<NPRemoteIdentifier>* aIds);
35835: 
36125:     virtual bool
36125:     AnswerNPN_GetValue_WithBoolReturn(const NPNVariable& aVariable,
36125:                                       NPError* aError,
36125:                                       bool* aBoolVal);
36125: 
38685:     NS_OVERRIDE
38685:     virtual bool AnswerProcessSomeEvents();
38685: 
38688:     virtual bool
38688:     RecvAppendNotesToCrashReport(const nsCString& aNotes);
38688: 
35945:     static PluginInstanceParent* InstCast(NPP instance);
35945:     static BrowserStreamParent* StreamCast(NPP instance, NPStream* s);
35945: 
35740: private:
35746:     void SetPluginFuncs(NPPluginFuncs* aFuncs);
35746: 
35740:     // Implement the module-level functions from NPAPI; these are
35740:     // normally resolved directly from the DSO.
35746: #ifdef OS_LINUX
35740:     NPError NP_Initialize(const NPNetscapeFuncs* npnIface,
35740:                           NPPluginFuncs* nppIface);
35746: #else
35746:     NPError NP_Initialize(const NPNetscapeFuncs* npnIface);
35746:     NPError NP_GetEntryPoints(NPPluginFuncs* nppIface);
35746: #endif
35740: 
35740:     // NPP-like API that Gecko calls are trampolined into.  These 
35740:     // messages then get forwarded along to the plugin instance,
35740:     // and then eventually the child process.
35740: 
35910:     static NPError NPP_Destroy(NPP instance, NPSavedData** save);
35740: 
35910:     static NPError NPP_SetWindow(NPP instance, NPWindow* window);
35910:     static NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream,
35910:                                  NPBool seekable, uint16_t* stype);
35890:     static NPError NPP_DestroyStream(NPP instance,
35890:                                      NPStream* stream, NPReason reason);
35890:     static int32_t NPP_WriteReady(NPP instance, NPStream* stream);
35890:     static int32_t NPP_Write(NPP instance, NPStream* stream,
35890:                              int32_t offset, int32_t len, void* buffer);
35890:     static void NPP_StreamAsFile(NPP instance,
35890:                                  NPStream* stream, const char* fname);
35910:     static void NPP_Print(NPP instance, NPPrint* platformPrint);
35910:     static int16_t NPP_HandleEvent(NPP instance, void* event);
35910:     static void NPP_URLNotify(NPP instance, const char* url,
35910:                               NPReason reason, void* notifyData);
35910:     static NPError NPP_GetValue(NPP instance,
35910:                                 NPPVariable variable, void *ret_value);
35910:     static NPError NPP_SetValue(NPP instance, NPNVariable variable,
35910:                                 void *value);
35740: 
35913:     NPIdentifier GetValidNPIdentifier(NPRemoteIdentifier aRemoteIdentifier);
35740: 
36010:     virtual bool HasRequiredFunctions();
36010: 
36010: #if defined(XP_UNIX) && !defined(XP_MACOSX)
36010:     virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs, NPError* error);
36010: #else
36010:     virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPError* error);
36010: #endif
36010:     virtual nsresult NP_Shutdown(NPError* error);
37635:     virtual nsresult NP_GetMIMEDescription(const char** mimeDesc);
36010:     virtual nsresult NP_GetValue(void *future, NPPVariable aVariable,
36010:                                  void *aValue, NPError* error);
36764: #if defined(XP_WIN) || defined(XP_MACOSX) || defined(XP_OS2)
36010:     virtual nsresult NP_GetEntryPoints(NPPluginFuncs* pFuncs, NPError* error);
36010: #endif
36010:     virtual nsresult NPP_New(NPMIMEType pluginType, NPP instance,
36010:                              uint16_t mode, int16_t argc, char* argn[],
36010:                              char* argv[], NPSavedData* saved,
36010:                              NPError* error);
35740: private:
37384:     void WriteExtraDataForMinidump(nsIFile* dumpFile);
37384:     void WriteExtraDataEntry(nsIFileOutputStream* stream,
37384:                              const char* key,
37384:                              const char* value);
38121:     void CleanupFromTimeout();
38121:     static int TimeoutChanged(const char* aPref, void* aModule);
39257:     void NotifyPluginCrashed();
38121: 
38688:     nsCString mCrashNotes;
36063:     PluginProcessParent* mSubprocess;
36145:     bool mShutdown;
35740:     const NPNetscapeFuncs* mNPNIface;
35913:     nsTHashtable<nsVoidPtrHashKey> mValidIdentifiers;
36304:     nsNPAPIPlugin* mPlugin;
37384:     time_t mProcessStartTime;
39257:     CancelableTask* mPluginCrashedTask;
39257:     nsString mDumpID;
35740: };
35740: 
35740: } // namespace plugins
35740: } // namespace mozilla
35740: 
35893: #endif  // ifndef dom_plugins_PluginModuleParent_h
