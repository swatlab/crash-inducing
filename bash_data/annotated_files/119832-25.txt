 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsNSSASN1Object.h"
     1: #include "nsIComponentManager.h"
     1: #include "secasn1.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsIMutableArray.h"
     1: #include "nsArrayUtils.h"
     1: #include "nsXPCOMCID.h"
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsNSSASN1Sequence, nsIASN1Sequence, 
     1:                                                  nsIASN1Object)
     1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsNSSASN1PrintableItem, nsIASN1PrintableItem,
     1:                                                       nsIASN1Object)
     1: 
     1: // This function is used to interpret an integer that
     1: // was encoded in a DER buffer. This function is used
     1: // when converting a DER buffer into a nsIASN1Object 
     1: // structure.  This interprets the buffer in data
     1: // as defined by the DER (Distinguised Encoding Rules) of
     1: // ASN1.
     1: static int
     1: getInteger256(unsigned char *data, unsigned int nb)
     1: {
     1:     int val;
     1: 
     1:     switch (nb) {
     1:       case 1:
     1:         val = data[0];
     1:         break;
     1:       case 2:
     1:         val = (data[0] << 8) | data[1];
     1:         break;
     1:       case 3:
     1:         val = (data[0] << 16) | (data[1] << 8) | data[2];
     1:         break;
     1:       case 4:
     1:         val = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
     1:         break;
     1:       default:
     1:         return -1;
     1:     }
     1: 
     1:     return val;
     1: }
     1: 
     1: // This function is used to retrieve the lenght of a DER encoded
     1: // item.  It looks to see if this a multibyte length and then
     1: // interprets the buffer accordingly to get the actual length value.
     1: // This funciton is used mostly while parsing the DER headers.
     1: // 
     1: // A DER encoded item has the following structure:
     1: //
     1: //  <tag><length<data consisting of lenght bytes>
108991: static int32_t
     1: getDERItemLength(unsigned char *data, unsigned char *end,
 79445:                  unsigned long *bytesUsed, bool *indefinite)
     1: {
     1:   unsigned char lbyte = *data++;
108991:   int32_t length = -1;
     1:   
 80486:   *indefinite = false;
     1:   if (lbyte >= 0x80) {
     1:     // Multibyte length
     1:     unsigned nb = (unsigned) (lbyte & 0x7f);
     1:     if (nb > 4) {
     1:       return -1;
     1:     }
     1:     if (nb > 0) {
     1:     
     1:       if ((data+nb) > end) {
     1:         return -1;
     1:       }
     1:       length = getInteger256(data, nb);
     1:       if (length < 0)
     1:         return -1;
     1:     } else {
 80486:       *indefinite = true;
     1:       length = 0;
     1:     }
     1:     *bytesUsed = nb+1;
     1:   } else {
     1:     length = lbyte;
     1:     *bytesUsed = 1; 
     1:   }
     1:   return length;
     1: }
     1: 
     1: static nsresult
     1: buildASN1ObjectFromDER(unsigned char *data,
     1:                        unsigned char *end,
     1:                        nsIASN1Sequence *parent)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIASN1Sequence> sequence;
     1:   nsCOMPtr<nsIASN1PrintableItem> printableItem;
     1:   nsCOMPtr<nsIASN1Object> asn1Obj;
     1:   nsCOMPtr<nsIMutableArray> parentObjects;
     1: 
     1:   NS_ENSURE_ARG_POINTER(parent);
     1:   if (data >= end)
     1:     return NS_OK;
     1: 
     1:   unsigned char code, tagnum;
     1: 
     1:   // A DER item has the form of |tag|len|data
     1:   // tag is one byte and describes the type of elment
     1:   //     we are dealing with.
     1:   // len is a DER encoded int telling us how long the data is
     1:   // data is a buffer that is len bytes long and has to be
     1:   //      interpreted according to its type.
     1:   unsigned long bytesUsed;
 79445:   bool indefinite;
108991:   int32_t len;
108991:   uint32_t type;
     1: 
     1:   rv = parent->GetASN1Objects(getter_AddRefs(parentObjects));
119832:   if (NS_FAILED(rv) || parentObjects == nullptr)
     1:     return NS_ERROR_FAILURE;
     1:   while (data < end) {
     1:     code = *data;
     1:     tagnum = code & SEC_ASN1_TAGNUM_MASK;
     1: 
     1:     /*
     1:      * NOTE: This code does not (yet) handle the high-tag-number form!
     1:      */
     1:     if (tagnum == SEC_ASN1_HIGH_TAG_NUMBER) {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     data++;
     1:     len = getDERItemLength(data, end, &bytesUsed, &indefinite);
     1:     data += bytesUsed;
     1:     if ((len < 0) || ((data+len) > end))
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     if (code & SEC_ASN1_CONSTRUCTED) {
     1:       if (len > 0 || indefinite) {
     1:         sequence = new nsNSSASN1Sequence();
     1:         switch (code & SEC_ASN1_CLASS_MASK) {
     1:         case SEC_ASN1_UNIVERSAL:
     1:           type = tagnum;
     1:           break;
     1:         case SEC_ASN1_APPLICATION:
     1:           type = nsIASN1Object::ASN1_APPLICATION;
     1:           break;
     1:         case SEC_ASN1_CONTEXT_SPECIFIC:
     1:           type = nsIASN1Object::ASN1_CONTEXT_SPECIFIC;
     1:           break;
     1:         case SEC_ASN1_PRIVATE:
     1:           type = nsIASN1Object::ASN1_PRIVATE;
     1:           break;
     1:         default:
 31561:           NS_ERROR("Bad DER");
     1:           return NS_ERROR_FAILURE;
     1:         }
     1:         sequence->SetTag(tagnum);
     1:         sequence->SetType(type);
     1:         rv = buildASN1ObjectFromDER(data, (len == 0) ? end : data + len, 
     1:                                     sequence);
     1:         asn1Obj = sequence;
     1:       }
     1:     } else {
     1:       printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:       asn1Obj = printableItem;
     1:       asn1Obj->SetType(tagnum);
     1:       asn1Obj->SetTag(tagnum); 
     1:       printableItem->SetData((char*)data, len);
     1:     }
     1:     data += len;
 80486:     parentObjects->AppendElement(asn1Obj, false);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: CreateFromDER(unsigned char *data,
     1:               unsigned int   len,
     1:               nsIASN1Object **retval)
     1: {
     1:   nsCOMPtr<nsIASN1Sequence> sequence = new nsNSSASN1Sequence;
106838:   *retval = nullptr;
     1:   
     1:   nsresult rv =  buildASN1ObjectFromDER(data, data+len, sequence);
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // The actual object will be the first element inserted
     1:     // into the sequence of the sequence variable we created.
     1:     nsCOMPtr<nsIMutableArray> elements;
     1: 
     1:     sequence->GetASN1Objects(getter_AddRefs(elements));
     1:     nsCOMPtr<nsIASN1Object> asn1Obj = do_QueryElementAt(elements, 0);
     1:     *retval = asn1Obj;
119832:     if (*retval == nullptr)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     NS_ADDREF(*retval);
     1:       
     1:   }
     1:   return rv; 
     1: }
     1: 
     1: nsNSSASN1Sequence::nsNSSASN1Sequence() : mType(0),
     1:                                          mTag(0),
 80486:                                          mIsValidContainer(true),
 80486:                                          mIsExpanded(true)
     1: {
     1:   /* member initializers and constructor code */
     1: }
     1: 
     1: nsNSSASN1Sequence::~nsNSSASN1Sequence()
     1: {
     1:   /* destructor code */
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1Sequence::GetASN1Objects(nsIMutableArray * *aASN1Objects)
     1: {
119832:   if (mASN1Objects == nullptr) {
     1:     mASN1Objects = do_CreateInstance(NS_ARRAY_CONTRACTID);
     1:   }
     1:   *aASN1Objects = mASN1Objects;
     1:   NS_IF_ADDREF(*aASN1Objects);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1Sequence::SetASN1Objects(nsIMutableArray * aASN1Objects)
     1: {
     1:   mASN1Objects = aASN1Objects;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1Sequence::GetTag(uint32_t *aTag)
     1: {
     1:   *aTag = mTag;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1Sequence::SetTag(uint32_t aTag)
     1: {
     1:   mTag = aTag;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1Sequence::GetType(uint32_t *aType)
     1: {
     1:   *aType = mType;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1Sequence::SetType(uint32_t aType)
     1: {
     1:   mType = aType;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1Sequence::GetDisplayName(nsAString &aDisplayName)
     1: {
     1:   aDisplayName = mDisplayName;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1Sequence::SetDisplayName(const nsAString &aDisplayName)
     1: {
     1:   mDisplayName = aDisplayName;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1Sequence::GetDisplayValue(nsAString &aDisplayValue)
     1: {
     1:   aDisplayValue = mDisplayValue;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1Sequence::SetDisplayValue(const nsAString &aDisplayValue)
     1: {
     1:   mDisplayValue = aDisplayValue;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsNSSASN1Sequence::GetIsValidContainer(bool *aIsValidContainer)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aIsValidContainer);
     1:   *aIsValidContainer = mIsValidContainer;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsNSSASN1Sequence::SetIsValidContainer(bool aIsValidContainer)
     1: {
     1:   mIsValidContainer = aIsValidContainer;
     1:   SetIsExpanded(mIsValidContainer);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsNSSASN1Sequence::GetIsExpanded(bool *aIsExpanded)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aIsExpanded);
     1:   *aIsExpanded = mIsExpanded;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
 79445: nsNSSASN1Sequence::SetIsExpanded(bool aIsExpanded)
     1: {
     1:   mIsExpanded = aIsExpanded;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsNSSASN1PrintableItem::nsNSSASN1PrintableItem() : mType(0),
     1:                                                    mTag(0),
106838:                                                    mData(nullptr),
     1:                                                    mLen(0)
     1: {
     1:   /* member initializers and constructor code */
     1: }
     1: 
     1: nsNSSASN1PrintableItem::~nsNSSASN1PrintableItem()
     1: {
     1:   /* destructor code */
     1:   if (mData)
     1:     nsMemory::Free(mData);
     1: }
     1: 
     1: /* readonly attribute wstring value; */
     1: NS_IMETHODIMP 
     1: nsNSSASN1PrintableItem::GetDisplayValue(nsAString &aValue)
     1: {
     1:   aValue = mValue;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1PrintableItem::SetDisplayValue(const nsAString &aValue)
     1: {
     1:   mValue = aValue;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1PrintableItem::GetTag(uint32_t *aTag)
     1: {
     1:   *aTag = mTag;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1PrintableItem::SetTag(uint32_t aTag)
     1: {
     1:   mTag = aTag;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1PrintableItem::GetType(uint32_t *aType)
     1: {
     1:   *aType = mType;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1PrintableItem::SetType(uint32_t aType)
     1: {
     1:   mType = aType;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsNSSASN1PrintableItem::SetData(char *data, uint32_t len)
     1: {
     1:   if (len > 0) {
     1:     if (mLen < len) {
     1:       unsigned char* newData = (unsigned char*)nsMemory::Realloc(mData, len);
     1:       if (!newData)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:       mData = newData;
     1:     }
     1: 
     1:     memcpy(mData, data, len);
     1:   } else if (len == 0) {
     1:     if (mData) {
     1:       nsMemory::Free(mData);
106838:       mData = nullptr;
     1:     }
     1:   }
     1:   mLen = len;
     1:   return NS_OK;  
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSASN1PrintableItem::GetData(char **outData, uint32_t *outLen)
     1: {
     1:   NS_ENSURE_ARG_POINTER(outData);
     1:   NS_ENSURE_ARG_POINTER(outLen);
     1: 
     1:   *outData = (char*)mData;
     1:   *outLen  = mLen;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute wstring displayName; */
     1: NS_IMETHODIMP 
     1: nsNSSASN1PrintableItem::GetDisplayName(nsAString &aDisplayName)
     1: {
     1:   aDisplayName = mDisplayName;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsNSSASN1PrintableItem::SetDisplayName(const nsAString &aDisplayName)
     1: {
     1:   mDisplayName = aDisplayName;
     1:   return NS_OK;
     1: }
     1: 
