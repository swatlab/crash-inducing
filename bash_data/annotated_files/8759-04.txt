   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /* factory functions for rendering object classes */
   1: 
   1: #ifndef nsHTMLParts_h___
   1: #define nsHTMLParts_h___
   1: 
   1: #include "nscore.h"
   1: #include "nsISupports.h"
   1: class nsIAtom;
   1: class nsNodeInfoManager;
   1: class nsIContent;
   1: class nsIContentIterator;
   1: class nsIDocument;
   1: class nsIFrame;
   1: class nsIHTMLContentSink;
   1: class nsIFragmentContentSink;
   1: class nsPresContext;
   1: class nsStyleContext;
   1: class nsIURI;
   1: class nsString;
   1: class nsIPresShell;
   1: class nsIChannel;
8151: class nsTableColFrame;
   1: 
   1: /**
   1:  * Additional frame-state bits used by nsBlockFrame
   1:  * See the meanings at http://www.mozilla.org/newlayout/doc/block-and-line.html
8759:  *
8759:  * NS_BLOCK_HAS_FIRST_LETTER_STYLE means that the block has first-letter style,
8759:  *  even if it has no actual first-letter frame among its descendants.
8759:  *
8759:  * NS_BLOCK_HAS_FIRST_LETTER_CHILD means that there is an inflow first-letter
8759:  *  frame among the block's descendants. If there is a floating first-letter
8759:  *  frame, or the block has first-letter style but has no first letter, this
8759:  *  bit is not set.
   1:  */
   1: #define NS_BLOCK_NO_AUTO_MARGINS            0x00200000
   1: #define NS_BLOCK_MARGIN_ROOT                0x00400000
   1: #define NS_BLOCK_SPACE_MGR                  0x00800000
   1: #define NS_BLOCK_HAS_FIRST_LETTER_STYLE     0x20000000
   1: #define NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET   0x40000000
8759: #define NS_BLOCK_HAS_FIRST_LETTER_CHILD     0x80000000
   1: // These are the bits that get inherited from a block frame to its
   1: // next-in-flows and are not private to blocks
5590: #define NS_BLOCK_FLAGS_MASK                 0xF0E00000 
   1: 
   1: // Factory methods for creating html layout objects
   1: 
   1: // These are variations on AreaFrame with slightly different layout
   1: // policies.
   1: 
   1: // Create a frame that supports "display: block" layout behavior
   1: nsIFrame*
   1: NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags = 0);
   1: 
   1: // Special Generated Content Frame
   1: nsresult
   1: NS_NewAttributeContent(nsNodeInfoManager *aNodeInfoManager,
   1:                        PRInt32 aNameSpaceID, nsIAtom* aAttrName,
   1:                        nsIContent** aResult);
   1: 
   1: // Create a basic area frame but the GetFrameForPoint is overridden to always
   1: // return the option frame 
   1: // By default, area frames will extend
   1: // their height to cover any children that "stick out".
   1: nsIFrame*
   1: NS_NewSelectsAreaFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
   1: 
   1: // Create a basic area frame.
   1: nsIFrame*
   1: NS_NewAreaFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
   1: 
   1: // These AreaFrame's shrink wrap around their contents
   1: inline nsIFrame*
   1: NS_NewTableCellInnerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   1:   return NS_NewBlockFrame(aPresShell, aContext);
   1: }
   1: 
   1: // This type of AreaFrame is the document root, a margin root, and the
   1: // initial containing block for absolutely positioned elements
   1: inline nsIFrame*
   1: NS_NewDocumentElementFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   1:   return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
   1: }
   1: 
   1: // This type of AreaFrame is a margin root, but does not shrink wrap
   1: inline nsIFrame*
   1: NS_NewAbsoluteItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   1:   return NS_NewAreaFrame(aPresShell, aContext, NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
   1: }
   1: 
   1: // This type of AreaFrame shrink wraps
   1: inline nsIFrame*
   1: NS_NewFloatingItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   1:   return NS_NewAreaFrame(aPresShell, aContext,
   1:     NS_BLOCK_SPACE_MGR|NS_BLOCK_MARGIN_ROOT);
   1: }
   1: 
   1: // This type of AreaFrame doesn't use its own space manager and
   1: // doesn't shrink wrap.
   1: inline nsIFrame*
7667: NS_NewRelativeItemWrapperFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags) {
7667:   return NS_NewAreaFrame(aPresShell, aContext, aFlags);
   1: }
   1: 
   1: nsIFrame*
   1: NS_NewBRFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewCommentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: // <frame> and <iframe> 
   1: nsIFrame*
   1: NS_NewSubDocumentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: // <frameset>
   1: nsIFrame*
   1: NS_NewHTMLFramesetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: nsIFrame*
   1: NS_NewViewportFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewCanvasFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewImageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewPositionedInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewSpacerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewEmptyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: inline nsIFrame*
   1: NS_NewWBRFrame(nsIPresShell* aPresShell, nsStyleContext* aContext) {
   1:   return NS_NewEmptyFrame(aPresShell, aContext);
   1: }
   1: 
   1: nsIFrame*
   1: NS_NewColumnSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aStateFlags);
   1: 
   1: nsIFrame*
   1: NS_NewSimplePageSequenceFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewPageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewPageContentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewPageBreakFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewFirstLetterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewFirstLineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: // forms
   1: nsIFrame*
   1: NS_NewGfxButtonControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewNativeButtonControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewImageControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewHTMLButtonControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewGfxCheckboxControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewNativeCheckboxControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewFieldSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewFileControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewLegendFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewNativeTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewGfxAutoTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewGfxRadioControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewNativeRadioControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewNativeSelectControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewListControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewComboboxControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
   1: nsIFrame*
   1: NS_NewIsIndexFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: 
   1: // Table frame factories
   1: nsIFrame*
   1: NS_NewTableOuterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTableFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTableCaptionFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
8151: nsTableColFrame*
   1: NS_NewTableColFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTableColGroupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTableRowFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTableRowGroupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
   1: nsIFrame*
   1: NS_NewTableCellFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsBorderCollapse);
   1: 
   1: nsresult
   1: NS_NewHTMLContentSink(nsIHTMLContentSink** aInstancePtrResult,
   1:                       nsIDocument* aDoc, nsIURI* aURL,
   1:                       nsISupports* aContainer, // e.g. docshell
   1:                       nsIChannel* aChannel);
   1: nsresult
   1: NS_NewHTMLFragmentContentSink(nsIFragmentContentSink** aInstancePtrResult);
   1: nsresult
   1: NS_NewHTMLFragmentContentSink2(nsIFragmentContentSink** aInstancePtrResult);
   1: 
   1: // This strips all but a whitelist of elements and attributes defined
   1: // in nsContentSink.h
   1: nsresult
   1: NS_NewHTMLParanoidFragmentSink(nsIFragmentContentSink** aInstancePtrResult);
   1: void
   1: NS_HTMLParanoidFragmentSinkShutdown();
   1: #endif /* nsHTMLParts_h___ */
