48026: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
47108:  * ***** BEGIN LICENSE BLOCK *****
47108:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47108:  *
47108:  * The contents of this file are subject to the Mozilla Public License Version
47108:  * 1.1 (the "License"); you may not use this file except in compliance with
47108:  * the License. You may obtain a copy of the License at
47108:  * http://www.mozilla.org/MPL/
47108:  *
47108:  * Software distributed under the License is distributed on an "AS IS" basis,
47108:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47108:  * for the specific language governing rights and limitations under the
47108:  * License.
47108:  *
47108:  * The Original Code is Mozilla Corporation code.
47108:  *
47108:  * The Initial Developer of the Original Code is Mozilla Foundation.
47108:  * Portions created by the Initial Developer are Copyright (C) 2010
47108:  * the Initial Developer. All Rights Reserved.
47108:  *
47108:  * Contributor(s):
47108:  *   Robert O'Callahan <robert@ocallahan.org>
47108:  *
47108:  * Alternatively, the contents of this file may be used under the terms of
47108:  * either the GNU General Public License Version 2 or later (the "GPL"), or
47108:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47108:  * in which case the provisions of the GPL or the LGPL are applicable instead
47108:  * of those above. If you wish to allow use of your version of this file only
47108:  * under the terms of either the GPL or the LGPL, and not to allow others to
47108:  * use your version of this file under the terms of the MPL, indicate your
47108:  * decision by deleting the provisions above and replace them with the notice
47108:  * and other provisions required by the GPL or the LGPL. If you do not delete
47108:  * the provisions above, a recipient may use your version of this file under
47108:  * the terms of any one of the MPL, the GPL or the LGPL.
47108:  *
47108:  * ***** END LICENSE BLOCK ***** */
47108: 
47108: #include "ThebesLayerBuffer.h"
47108: #include "Layers.h"
47108: #include "gfxContext.h"
47108: #include "gfxPlatform.h"
51956: #include "gfxUtils.h"
68667: #include "nsDeviceContext.h"
47108: 
47108: namespace mozilla {
47108: namespace layers {
47108: 
54083: static nsIntSize
54083: ScaledSize(const nsIntSize& aSize, float aXScale, float aYScale)
54083: {
54083:   if (aXScale == 1.0 && aYScale == 1.0) {
54083:     return aSize;
54083:   }
54083: 
54083:   gfxRect rect(0, 0, aSize.width, aSize.height);
54083:   rect.Scale(aXScale, aYScale);
54083:   rect.RoundOut();
68632:   return nsIntSize(rect.Width(), rect.Height());
54083: }
54083: 
47108: nsIntRect
47108: ThebesLayerBuffer::GetQuadrantRectangle(XSide aXSide, YSide aYSide)
47108: {
47108:   // quadrantTranslation is the amount we translate the top-left
47108:   // of the quadrant by to get coordinates relative to the layer
47108:   nsIntPoint quadrantTranslation = -mBufferRotation;
47108:   quadrantTranslation.x += aXSide == LEFT ? mBufferRect.width : 0;
47108:   quadrantTranslation.y += aYSide == TOP ? mBufferRect.height : 0;
47108:   return mBufferRect + quadrantTranslation;
47108: }
47108: 
47108: /**
47108:  * @param aXSide LEFT means we draw from the left side of the buffer (which
47108:  * is drawn on the right side of mBufferRect). RIGHT means we draw from
47108:  * the right side of the buffer (which is drawn on the left side of
47108:  * mBufferRect).
47108:  * @param aYSide TOP means we draw from the top side of the buffer (which
47108:  * is drawn on the bottom side of mBufferRect). BOTTOM means we draw from
47108:  * the bottom side of the buffer (which is drawn on the top side of
47108:  * mBufferRect).
47108:  */
47108: void
47108: ThebesLayerBuffer::DrawBufferQuadrant(gfxContext* aTarget,
54083:                                       XSide aXSide, YSide aYSide,
54083:                                       float aOpacity,
54083:                                       float aXRes, float aYRes)
47108: {
47108:   // The rectangle that we're going to fill. Basically we're going to
47108:   // render the buffer at mBufferRect + quadrantTranslation to get the
47108:   // pixels in the right place, but we're only going to paint within
47108:   // mBufferRect
47108:   nsIntRect quadrantRect = GetQuadrantRectangle(aXSide, aYSide);
47108:   nsIntRect fillRect;
47108:   if (!fillRect.IntersectRect(mBufferRect, quadrantRect))
47108:     return;
47108: 
47108:   aTarget->NewPath();
54083:   aTarget->Rectangle(gfxRect(fillRect.x, fillRect.y,
54083:                              fillRect.width, fillRect.height),
47108:                      PR_TRUE);
54083: 
54083:   gfxPoint quadrantTranslation(quadrantRect.x, quadrantRect.y);
54083:   nsRefPtr<gfxPattern> pattern = new gfxPattern(mBuffer);
54083: 
54090: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
54090:   gfxPattern::GraphicsFilter filter = gfxPattern::FILTER_NEAREST;
54090:   pattern->SetFilter(filter);
54090: #endif
54090: 
54550:   gfxContextMatrixAutoSaveRestore saveMatrix(aTarget);
54550: 
54083:   // Transform from user -> buffer space.
54083:   gfxMatrix transform;
54083:   transform.Scale(aXRes, aYRes);
54083:   transform.Translate(-quadrantTranslation);
54083: 
54550:   // in common cases the matrix after scaling by 1/aRes is close to 1.0,
54550:   // so we want to make it 1.0 in both cases
54550:   transform.Scale(1.0 / aXRes, 1.0 / aYRes);
54550:   transform.NudgeToIntegers();
54550: 
54550:   gfxMatrix ctxMatrix = aTarget->CurrentMatrix();
54550:   ctxMatrix.Scale(1.0 / aXRes, 1.0 / aYRes);
54550:   ctxMatrix.NudgeToIntegers();
54550:   aTarget->SetMatrix(ctxMatrix);
54550: 
54083:   pattern->SetMatrix(transform);
54083:   aTarget->SetPattern(pattern);
54083: 
47748:   if (aOpacity != 1.0) {
47748:     aTarget->Save();
47748:     aTarget->Clip();
47748:     aTarget->Paint(aOpacity);
47748:     aTarget->Restore();
47748:   } else {
47108:     aTarget->Fill();
47108:   }
47748: }
47108: 
47108: void
54083: ThebesLayerBuffer::DrawBufferWithRotation(gfxContext* aTarget, float aOpacity,
54083:                                           float aXRes, float aYRes)
47108: {
47108:   // Draw four quadrants. We could use REPEAT_, but it's probably better
47108:   // not to, to be performance-safe.
54083:   DrawBufferQuadrant(aTarget, LEFT, TOP, aOpacity, aXRes, aYRes);
54083:   DrawBufferQuadrant(aTarget, RIGHT, TOP, aOpacity, aXRes, aYRes);
54083:   DrawBufferQuadrant(aTarget, LEFT, BOTTOM, aOpacity, aXRes, aYRes);
54083:   DrawBufferQuadrant(aTarget, RIGHT, BOTTOM, aOpacity, aXRes, aYRes);
47108: }
47108: 
56902: already_AddRefed<gfxContext>
56902: ThebesLayerBuffer::GetContextForQuadrantUpdate(const nsIntRect& aBounds,
56902:                                                float aXResolution,
56902:                                                float aYResolution)
56902: {
56902:   nsRefPtr<gfxContext> ctx = new gfxContext(mBuffer);
56902: 
56902:   // Figure out which quadrant to draw in
56902:   PRInt32 xBoundary = mBufferRect.XMost() - mBufferRotation.x;
56902:   PRInt32 yBoundary = mBufferRect.YMost() - mBufferRotation.y;
56902:   XSide sideX = aBounds.XMost() <= xBoundary ? RIGHT : LEFT;
56902:   YSide sideY = aBounds.YMost() <= yBoundary ? BOTTOM : TOP;
56902:   nsIntRect quadrantRect = GetQuadrantRectangle(sideX, sideY);
56902:   NS_ASSERTION(quadrantRect.Contains(aBounds), "Messed up quadrants");
56902:   ctx->Scale(aXResolution, aYResolution);
56902:   ctx->Translate(-gfxPoint(quadrantRect.x, quadrantRect.y));
56902: 
56902:   return ctx.forget();
56902: }
56902: 
63371: // Move the pixels in aBuffer specified by |aSourceRect| to |aDest|.
63371: // |aSourceRect| and |aDest| are in the space of |aBuffer|, but
63371: // unscaled by the resolution.  This helper does the scaling.
63371: static void
63371: MovePixels(gfxASurface* aBuffer,
63371:            const nsIntRect& aSourceRect, const nsIntPoint& aDest,
63371:            float aXResolution, float aYResolution)
63371: {
63371:   gfxRect src(aSourceRect.x, aSourceRect.y, aSourceRect.width, aSourceRect.height);
63371:   gfxRect dest(aDest.x, aDest.y,  aSourceRect.width, aSourceRect.height);
63371:   src.Scale(aXResolution, aYResolution);
63371:   dest.Scale(aXResolution, aYResolution);
63371: 
63371: #ifdef DEBUG
63371:   // If we're doing a self-copy, enforce that the rects we're copying
63371:   // were computed in order to round to device pixels.  If the rects
63371:   // we're moving *weren't* computed to round, then glitches like
63371:   // seaming are likely.  Assume that the precision of these
63371:   // computations is 1 app unit, and toss in a fudge factor of 2.0.
63371:   static const gfxFloat kPrecision =
68667:     1.0 / gfxFloat(nsDeviceContext::AppUnitsPerCSSPixel());
63371:   // FIXME/bug 637852: we've decided to live with transient glitches
63371:   // during fast-panning for the time being.
63371:   NS_WARN_IF_FALSE(
63371:     src.WithinEpsilonOfIntegerPixels(2.0 * kPrecision * aXResolution) &&
63371:     dest.WithinEpsilonOfIntegerPixels(2.0 * kPrecision * aXResolution),
63371:     "Rects don't round to device pixels within precision; glitches likely to follow");
63371: #endif
63371: 
63371:   src.Round();
63371:   dest.Round();
63371: 
68632:   aBuffer->MovePixels(nsIntRect(src.X(), src.Y(),
68632:                                 src.Width(), src.Height()),
68632:                       nsIntPoint(dest.X(), dest.Y()));
63371: }
63371: 
47108: static void
47108: WrapRotationAxis(PRInt32* aRotationPoint, PRInt32 aSize)
47108: {
47108:   if (*aRotationPoint < 0) {
47108:     *aRotationPoint += aSize;
47108:   } else if (*aRotationPoint >= aSize) {
47108:     *aRotationPoint -= aSize;
47108:   }
47108: }
47108: 
47108: ThebesLayerBuffer::PaintState
54083: ThebesLayerBuffer::BeginPaint(ThebesLayer* aLayer, ContentType aContentType,
63213:                               float aXResolution, float aYResolution,
63213:                               PRUint32 aFlags)
47108: {
47108:   PaintState result;
63397:   result.mDidSelfCopy = PR_FALSE;
54083:   float curXRes = aLayer->GetXResolution();
54083:   float curYRes = aLayer->GetYResolution();
64538:   // If we have non-identity resolution then mBufferRotation might not fall
64538:   // on a buffer pixel boundary, in which case that row of pixels will contain
64538:   // a mix of two completely different rows of the layer, which would be
64538:   // a catastrophe. So disable rotation in that case.
64538:   // We also need to disable rotation if we're going to be resampled when
64538:   // drawing, because we might sample across the rotation boundary.
64538:   PRBool canHaveRotation =
64538:     !(aFlags & PAINT_WILL_RESAMPLE) && aXResolution == 1.0 && aYResolution == 1.0;
63213: 
63213:   nsIntRegion validRegion = aLayer->GetValidRegion();
63213: 
63213:   ContentType contentType;
63213:   nsIntRegion neededRegion;
63213:   nsIntSize destBufferDims;
63213:   PRBool canReuseBuffer;
63213:   nsIntRect destBufferRect;
63213: 
63213:   while (PR_TRUE) {
63213:     contentType = aContentType;
63213:     neededRegion = aLayer->GetVisibleRegion();
63213:     destBufferDims = ScaledSize(neededRegion.GetBounds().Size(),
63213:                                 aXResolution, aYResolution);
71022:     canReuseBuffer = mBuffer && BufferSizeOkFor(destBufferDims);
63213: 
63213:     if (canReuseBuffer) {
63213:       if (mBufferRect.Contains(neededRegion.GetBounds())) {
63213:         // We don't need to adjust mBufferRect.
63213:         destBufferRect = mBufferRect;
63367:       } else if (neededRegion.GetBounds().Size() <= mBufferRect.Size()) {
63213:         // The buffer's big enough but doesn't contain everything that's
63213:         // going to be visible. We'll move it.
63213:         destBufferRect = nsIntRect(neededRegion.GetBounds().TopLeft(), mBufferRect.Size());
63367:       } else {
63367:         destBufferRect = neededRegion.GetBounds();
63213:       }
63213:     } else {
63213:       destBufferRect = neededRegion.GetBounds();
63213:     }
63213: 
63213:     if ((aFlags & PAINT_WILL_RESAMPLE) &&
68638:         (!neededRegion.GetBounds().IsEqualInterior(destBufferRect) ||
63213:          neededRegion.GetNumRects() > 1)) {
63213:       // The area we add to neededRegion might not be painted opaquely
63213:       contentType = gfxASurface::CONTENT_COLOR_ALPHA;
63213: 
63213:       // We need to validate the entire buffer, to make sure that only valid
63213:       // pixels are sampled
63213:       neededRegion = destBufferRect;
63213:       destBufferDims = ScaledSize(neededRegion.GetBounds().Size(),
63213:                                   aXResolution, aYResolution);
63213:     }
63213: 
54083:     if (mBuffer &&
63213:         (contentType != mBuffer->GetContentType() ||
54083:          aXResolution != curXRes || aYResolution != curYRes)) {
47774:       // We're effectively clearing the valid region, so we need to draw
63213:       // the entire needed region now.
54083:       //
54083:       // XXX/cjones: a possibly worthwhile optimization to keep in mind
54083:       // is to re-use buffers when the resolution and visible region
54083:       // have changed in such a way that the buffer size stays the same.
54083:       // It might make even more sense to allocate buffers from a
54083:       // recyclable pool, so that we could keep this logic simple and
54083:       // still get back the same buffer.
47108:       result.mRegionToInvalidate = aLayer->GetValidRegion();
63213:       validRegion.SetEmpty();
47108:       Clear();
63213:       // Restart decision process with the cleared buffer. We can only go
63213:       // around the loop one more iteration, since mBuffer is null now.
63213:       continue;
47108:     }
47108: 
63213:     break;
63213:   }
63213: 
63367:   NS_ASSERTION(destBufferRect.Contains(neededRegion.GetBounds()),
63367:                "Destination rect doesn't contain what we need to paint");
63367: 
63213:   result.mRegionToDraw.Sub(neededRegion, validRegion);
47108:   if (result.mRegionToDraw.IsEmpty())
47108:     return result;
63213: 
47108:   nsIntRect drawBounds = result.mRegionToDraw.GetBounds();
47108:   nsRefPtr<gfxASurface> destBuffer;
54100:   PRBool bufferDimsChanged = PR_FALSE;
64538:   PRUint32 bufferFlags = canHaveRotation ? ALLOW_REPEAT : 0;
63213:   if (canReuseBuffer) {
54083:     NS_ASSERTION(curXRes == aXResolution && curYRes == aYResolution,
54083:                  "resolution changes must Clear()!");
54083: 
47108:     nsIntRect keepArea;
47108:     if (keepArea.IntersectRect(destBufferRect, mBufferRect)) {
47108:       // Set mBufferRotation so that the pixels currently in mBuffer
47108:       // will still be rendered in the right place when mBufferRect
47108:       // changes to destBufferRect.
47108:       nsIntPoint newRotation = mBufferRotation +
47108:         (destBufferRect.TopLeft() - mBufferRect.TopLeft());
47108:       WrapRotationAxis(&newRotation.x, mBufferRect.width);
47108:       WrapRotationAxis(&newRotation.y, mBufferRect.height);
47108:       NS_ASSERTION(nsIntRect(nsIntPoint(0,0), mBufferRect.Size()).Contains(newRotation),
47108:                    "newRotation out of bounds");
47108:       PRInt32 xBoundary = destBufferRect.XMost() - newRotation.x;
47108:       PRInt32 yBoundary = destBufferRect.YMost() - newRotation.y;
47108:       if ((drawBounds.x < xBoundary && xBoundary < drawBounds.XMost()) ||
63213:           (drawBounds.y < yBoundary && yBoundary < drawBounds.YMost()) ||
63213:           (newRotation != nsIntPoint(0,0) && !canHaveRotation)) {
47108:         // The stuff we need to redraw will wrap around an edge of the
63371:         // buffer, so move the pixels we can keep into a position that
63371:         // lets us redraw in just one quadrant.
63371:         if (mBufferRotation == nsIntPoint(0,0)) {
63371:           nsIntRect srcRect(nsIntPoint(0, 0), mBufferRect.Size());
63371:           nsIntPoint dest = mBufferRect.TopLeft() - destBufferRect.TopLeft();
63371:           MovePixels(mBuffer, srcRect, dest, curXRes, curYRes);
63397:           result.mDidSelfCopy = PR_TRUE;
63371:           // Don't set destBuffer; we special-case self-copies, and
63371:           // just did the necessary work above.
63371:           mBufferRect = destBufferRect;
47108:         } else {
47108:           // We can't do a real self-copy because the buffer is rotated.
47108:           // So allocate a new buffer for the destination.
67588:           destBufferRect = neededRegion.GetBounds();
54100:           bufferDimsChanged = PR_TRUE;
64538:           destBuffer = CreateBuffer(contentType, destBufferDims, bufferFlags);
47108:           if (!destBuffer)
47108:             return result;
47108:         }
47108:       } else {
47108:         mBufferRect = destBufferRect;
47108:         mBufferRotation = newRotation;
47108:       }
47108:     } else {
47108:       // No pixels are going to be kept. The whole visible region
47108:       // will be redrawn, so we don't need to copy anything, so we don't
47108:       // set destBuffer.
47108:       mBufferRect = destBufferRect;
47108:       mBufferRotation = nsIntPoint(0,0);
47108:     }
47108:   } else {
47108:     // The buffer's not big enough, so allocate a new one
54100:     bufferDimsChanged = PR_TRUE;
64538:     destBuffer = CreateBuffer(contentType, destBufferDims, bufferFlags);
47108:     if (!destBuffer)
47108:       return result;
47108:   }
63213:   NS_ASSERTION(!(aFlags & PAINT_WILL_RESAMPLE) || destBufferRect == neededRegion.GetBounds(),
63213:                "If we're resampling, we need to validate the entire buffer");
47108: 
47762:   // If we have no buffered data already, then destBuffer will be a fresh buffer
47762:   // and we do not need to clear it below.
47762:   PRBool isClear = mBuffer == nsnull;
47762: 
47108:   if (destBuffer) {
47108:     if (mBuffer) {
47108:       // Copy the bits
47108:       nsRefPtr<gfxContext> tmpCtx = new gfxContext(destBuffer);
47108:       nsIntPoint offset = -destBufferRect.TopLeft();
47108:       tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
54083:       tmpCtx->Scale(aXResolution, aYResolution);
47108:       tmpCtx->Translate(gfxPoint(offset.x, offset.y));
54083:       NS_ASSERTION(curXRes == aXResolution && curYRes == aYResolution,
54083:                    "resolution changes must Clear()!");
54083:       DrawBufferWithRotation(tmpCtx, 1.0, aXResolution, aYResolution);
47108:     }
47108: 
47108:     mBuffer = destBuffer.forget();
47108:     mBufferRect = destBufferRect;
47108:     mBufferRotation = nsIntPoint(0,0);
47108:   }
54100:   if (bufferDimsChanged) {
54100:     mBufferDims = destBufferDims;
54100:   }
63213:   NS_ASSERTION(canHaveRotation || mBufferRotation == nsIntPoint(0,0),
63213:                "Rotation disabled, but we have nonzero rotation?");
47108: 
47108:   nsIntRegion invalidate;
47108:   invalidate.Sub(aLayer->GetValidRegion(), destBufferRect);
47108:   result.mRegionToInvalidate.Or(result.mRegionToInvalidate, invalidate);
47108: 
56902:   result.mContext = GetContextForQuadrantUpdate(drawBounds,
56902:                                                 aXResolution, aYResolution);
47108: 
60124:   gfxUtils::ClipToRegionSnapped(result.mContext, result.mRegionToDraw);
63213:   if (contentType == gfxASurface::CONTENT_COLOR_ALPHA && !isClear) {
47108:     result.mContext->SetOperator(gfxContext::OPERATOR_CLEAR);
47108:     result.mContext->Paint();
47108:     result.mContext->SetOperator(gfxContext::OPERATOR_OVER);
47108:   }
47108:   return result;
47108: }
47108: 
47108: }
47108: }
47108: 
