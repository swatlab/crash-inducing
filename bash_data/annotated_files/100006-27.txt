 53840: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 56201:  * vim: set ts=4 sw=4 et tw=99:
 53840:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 53840: 
 53840: #ifndef jsinterpinlines_h__
 53840: #define jsinterpinlines_h__
 53840: 
 55711: #include "jsapi.h"
 55711: #include "jsbool.h"
 64363: #include "jscompartment.h"
 87809: #include "jsinfer.h"
 55711: #include "jsinterp.h"
 87809: #include "jslibmath.h"
 55711: #include "jsnum.h"
 55565: #include "jsprobes.h"
 55711: #include "jsstr.h"
 55565: #include "methodjit/MethodJIT.h"
 55565: 
 59941: #include "jsfuninlines.h"
 87809: #include "jsinferinlines.h"
 86855: #include "jspropertycacheinlines.h"
 86855: #include "jstypedarrayinlines.h"
 59941: 
 69223: #include "vm/Stack-inl.h"
 64365: 
 53840: namespace js {
 53840: 
 63096: /*
 63096:  * Compute the implicit |this| parameter for a call expression where the callee
 74134:  * funval was resolved from an unqualified name reference to a property on obj
 74134:  * (an object on the scope chain).
 63096:  *
 63096:  * We can avoid computing |this| eagerly and push the implicit callee-coerced
 74134:  * |this| value, undefined, if any of these conditions hold:
 63096:  *
 86855:  * 1. The nominal |this|, obj, is a global object.
 63096:  *
 86855:  * 2. The nominal |this|, obj, has one of Block, Call, or DeclEnv class (this
 63096:  *    is what IsCacheableNonGlobalScope tests). Such objects-as-scopes must be
 74134:  *    censored with undefined.
 63096:  *
 86855:  * Otherwise, we bind |this| to obj->thisObject(). Only names inside |with|
 86855:  * statements and embedding-specific scope objects fall into this category.
 63096:  *
 86855:  * If the callee is a strict mode function, then code implementing JSOP_THIS
 86855:  * in the interpreter and JITs will leave undefined as |this|. If funval is a
 86855:  * function not in strict mode, JSOP_THIS code replaces undefined with funval's
 86855:  * global.
 63096:  *
 63096:  * We set *vp to undefined early to reduce code size and bias this code for the
 63096:  * common and future-friendly cases.
 63096:  */
 63096: inline bool
 86855: ComputeImplicitThis(JSContext *cx, JSObject *obj, Value *vp)
 63096: {
 63096:     vp->setUndefined();
 63096: 
 74134:     if (obj->isGlobal())
 74134:         return true;
 74134: 
 63096:     if (IsCacheableNonGlobalScope(obj))
 63096:         return true;
 63096: 
 63096:     obj = obj->thisObject(cx);
 63096:     if (!obj)
 63096:         return false;
 63096: 
 63096:     vp->setObject(*obj);
 63096:     return true;
 63096: }
 63096: 
 68904: inline bool
 69223: ComputeThis(JSContext *cx, StackFrame *fp)
 55711: {
 68904:     Value &thisv = fp->thisValue();
 68904:     if (thisv.isObject())
 55711:         return true;
 68904:     if (fp->isFunctionFrame()) {
 68904:         if (fp->fun()->inStrictMode())
 68904:             return true;
 68904:         /*
 68904:          * Eval function frames have their own |this| slot, which is a copy of the function's
 68904:          * |this| slot. If we lazily wrap a primitive |this| in an eval function frame, the
 68904:          * eval's frame will get the wrapper, but the function's frame will not. To prevent
 68904:          * this, we always wrap a function's |this| before pushing an eval frame, and should
 68904:          * thus never see an unwrapped primitive in a non-strict eval function frame.
 68904:          */
 68904:         JS_ASSERT(!fp->isEvalFrame());
 55711:     }
 68904:     return BoxNonStrictThis(cx, fp->callReceiver());
 55711: }
 55711: 
 55713: /*
 55713:  * Return an object on which we should look for the properties of |value|.
 55713:  * This helps us implement the custom [[Get]] method that ES5's GetValue
 55713:  * algorithm uses for primitive values, without actually constructing the
 55713:  * temporary object that the specification does.
 55713:  *
 55713:  * For objects, return the object itself. For string, boolean, and number
 55713:  * primitive values, return the appropriate constructor's prototype. For
 55713:  * undefined and null, throw an error and return NULL, attributing the
 55713:  * problem to the value at |spindex| on the stack.
 55713:  */
 55713: JS_ALWAYS_INLINE JSObject *
 89843: ValuePropertyBearer(JSContext *cx, StackFrame *fp, const Value &v, int spindex)
 55713: {
 55713:     if (v.isObject())
 55713:         return &v.toObject();
 55713: 
 96793:     GlobalObject &global = fp->global();
 89843: 
 89843:     if (v.isString())
 89843:         return global.getOrCreateStringPrototype(cx);
 89843:     if (v.isNumber())
 89843:         return global.getOrCreateNumberPrototype(cx);
 89843:     if (v.isBoolean())
 89843:         return global.getOrCreateBooleanPrototype(cx);
 89843: 
 55713:     JS_ASSERT(v.isNull() || v.isUndefined());
 55713:     js_ReportIsNullOrUndefined(cx, spindex, v, NULL);
 55713:     return NULL;
 55713: }
 55713: 
 64363: inline bool
 91237: NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj, const Shape *shape, unsigned getHow, Value *vp)
 86855: {
 86855:     if (shape->isDataDescriptor() && shape->hasDefaultGetter()) {
 86855:         /* Fast path for Object instance properties. */
 86855:         JS_ASSERT(shape->hasSlot());
 86855:         *vp = pobj->nativeGetSlot(shape->slot());
 86855:     } else {
 86855:         if (!js_NativeGet(cx, obj, pobj, shape, getHow, vp))
 86855:             return false;
 86855:     }
 86855:     return true;
 86855: }
 86855: 
 95355: #if defined(DEBUG) && !defined(JS_THREADSAFE) && !defined(JSGC_ROOT_ANALYSIS)
 86855: extern void
 86855: AssertValidPropertyCacheHit(JSContext *cx, JSObject *start, JSObject *found,
 86855:                             PropertyCacheEntry *entry);
 86855: #else
 86855: inline void
 86855: AssertValidPropertyCacheHit(JSContext *cx, JSObject *start, JSObject *found,
 86855:                             PropertyCacheEntry *entry)
 86855: {}
 86855: #endif
 86855: 
 86855: inline bool
 98960: GetPropertyGenericMaybeCallXML(JSContext *cx, JSOp op, HandleObject obj, HandleId id, Value *vp)
 86855: {
 86855:     /*
 86855:      * Various XML properties behave differently when accessed in a
 86855:      * call vs. normal context, and getGeneric will not work right.
 86855:      */
 86855: #if JS_HAS_XML_SUPPORT
 86855:     if (op == JSOP_CALLPROP && obj->isXML())
 86855:         return js_GetXMLMethod(cx, obj, id, vp);
 86855: #endif
 86855: 
 86855:     return obj->getGeneric(cx, id, vp);
 86855: }
 86855: 
 86855: inline bool
 86855: GetPropertyOperation(JSContext *cx, jsbytecode *pc, const Value &lval, Value *vp)
 86855: {
 86855:     JS_ASSERT(vp != &lval);
 86855: 
 86855:     JSOp op = JSOp(*pc);
 86855: 
 86855:     if (op == JSOP_LENGTH) {
 86855:         /* Optimize length accesses on strings, arrays, and arguments. */
 86855:         if (lval.isString()) {
 86855:             *vp = Int32Value(lval.toString()->length());
 86855:             return true;
 86855:         }
 93250:         if (lval.isMagic(JS_OPTIMIZED_ARGUMENTS)) {
 86855:             *vp = Int32Value(cx->fp()->numActualArgs());
 86855:             return true;
 86855:         }
 86855:         if (lval.isObject()) {
 86855:             JSObject *obj = &lval.toObject();
 86855:             if (obj->isArray()) {
 91688:                 uint32_t length = obj->getArrayLength();
 86855:                 *vp = NumberValue(length);
 86855:                 return true;
 86855:             }
 86855: 
 86855:             if (obj->isArguments()) {
 86855:                 ArgumentsObject *argsobj = &obj->asArguments();
 86855:                 if (!argsobj->hasOverriddenLength()) {
 86855:                     uint32_t length = argsobj->initialLength();
 86855:                     JS_ASSERT(length < INT32_MAX);
 86855:                     *vp = Int32Value(int32_t(length));
 86855:                     return true;
 86855:                 }
 86855:             }
 86855: 
 95834:             if (obj->isTypedArray()) {
 97573:                 *vp = Int32Value(TypedArray::getLength(obj));
 86855:                 return true;
 86855:             }
 86855:         }
 86855:     }
 86855: 
 99421:     RootedObject obj(cx, ValueToObject(cx, lval));
 86855:     if (!obj)
 86855:         return false;
 86855: 
 86855:     PropertyCacheEntry *entry;
 86855:     JSObject *obj2;
 86855:     PropertyName *name;
 99364:     JS_PROPERTY_CACHE(cx).test(cx, pc, obj.reference(), obj2, entry, name);
 86855:     if (!name) {
 86855:         AssertValidPropertyCacheHit(cx, obj, obj2, entry);
 94227:         if (!NativeGet(cx, obj, obj2, entry->prop, JSGET_CACHE_RESULT, vp))
 86855:             return false;
 86855:         return true;
 86855:     }
 86855: 
 99421:     RootedId id(cx, NameToId(name));
 86855: 
 86855:     if (obj->getOps()->getProperty) {
 99364:         if (!GetPropertyGenericMaybeCallXML(cx, op, obj, id, vp))
 86855:             return false;
 86855:     } else {
 99364:         if (!GetPropertyHelper(cx, obj, id, JSGET_CACHE_RESULT, vp))
 86855:             return false;
 86855:     }
 86855: 
 86855: #if JS_HAS_NO_SUCH_METHOD
 86855:     if (op == JSOP_CALLPROP &&
 86855:         JS_UNLIKELY(vp->isPrimitive()) &&
 86855:         lval.isObject())
 86855:     {
 99364:         if (!OnUnknownMethod(cx, obj, IdToValue(id), vp))
 86855:             return false;
 86855:     }
 86855: #endif
 86855: 
 86855:     return true;
 86855: }
 86855: 
 86855: inline bool
 86855: SetPropertyOperation(JSContext *cx, jsbytecode *pc, const Value &lval, const Value &rval)
 86855: {
 99421:     RootedObject obj(cx, ValueToObject(cx, lval));
 86855:     if (!obj)
 86855:         return false;
 86855: 
 86855:     JS_ASSERT_IF(*pc == JSOP_SETNAME || *pc == JSOP_SETGNAME, lval.isObject());
 96793:     JS_ASSERT_IF(*pc == JSOP_SETGNAME, obj == &cx->fp()->global());
 86855: 
 86855:     PropertyCacheEntry *entry;
 86855:     JSObject *obj2;
 86855:     PropertyName *name;
 86855:     if (JS_PROPERTY_CACHE(cx).testForSet(cx, pc, obj, &entry, &obj2, &name)) {
 86855:         /*
 86855:          * Property cache hit, only partially confirmed by testForSet. We
 86855:          * know that the entry applies to regs.pc and that obj's shape
 86855:          * matches.
 86855:          *
 86855:          * The entry predicts a set either an existing "own" property, or
 86855:          * on a prototype property that has a setter.
 86855:          */
 86855:         const Shape *shape = entry->prop;
 86855:         JS_ASSERT_IF(shape->isDataDescriptor(), shape->writable());
 86855:         JS_ASSERT_IF(shape->hasSlot(), entry->isOwnPropertyHit());
 86855: 
 86855:         if (entry->isOwnPropertyHit() ||
 86855:             ((obj2 = obj->getProto()) && obj2->lastProperty() == entry->pshape)) {
 86855: #ifdef DEBUG
 86855:             if (entry->isOwnPropertyHit()) {
 95355:                 JS_ASSERT(obj->nativeLookupNoAllocation(cx, shape->propid()) == shape);
 86855:             } else {
 95355:                 JS_ASSERT(obj2->nativeLookupNoAllocation(cx, shape->propid()) == shape);
 86855:                 JS_ASSERT(entry->isPrototypePropertyHit());
 86855:                 JS_ASSERT(entry->kshape != entry->pshape);
 86855:                 JS_ASSERT(!shape->hasSlot());
 86855:             }
 86855: #endif
 86855: 
 94227:             if (shape->hasDefaultSetter() && shape->hasSlot()) {
 86855:                 /* Fast path for, e.g., plain Object instance properties. */
 86855:                 obj->nativeSetSlotWithType(cx, shape, rval);
 86855:             } else {
 86855:                 Value rref = rval;
 86855:                 bool strict = cx->stack.currentScript()->strictModeCode;
 86855:                 if (!js_NativeSet(cx, obj, shape, false, strict, &rref))
 86855:                     return false;
 86855:             }
 86855:             return true;
 86855:         }
 86855: 
 86855:         GET_NAME_FROM_BYTECODE(cx->stack.currentScript(), pc, 0, name);
 86855:     }
 86855: 
 86855:     bool strict = cx->stack.currentScript()->strictModeCode;
 99421:     RootedValue rref(cx, rval);
 86855: 
 86855:     JSOp op = JSOp(*pc);
 86855: 
 99421:     RootedId id(cx, NameToId(name));
 86855:     if (JS_LIKELY(!obj->getOps()->setProperty)) {
 94227:         unsigned defineHow = (op == JSOP_SETNAME)
 94227:                              ? DNP_CACHE_RESULT | DNP_UNQUALIFIED
 94227:                              : DNP_CACHE_RESULT;
 99364:         if (!baseops::SetPropertyHelper(cx, obj, id, defineHow, rref.address(), strict))
 86855:             return false;
 86855:     } else {
 95355:         if (!obj->setGeneric(cx, id, rref.address(), strict))
 86855:             return false;
 86855:     }
 86855: 
 86855:     return true;
 86855: }
 86855: 
 86855: inline bool
 86855: NameOperation(JSContext *cx, jsbytecode *pc, Value *vp)
 86855: {
 99421:     RootedObject obj(cx, cx->stack.currentScriptedScopeChain());
 86855: 
 87657:     /*
 87657:      * Skip along the scope chain to the enclosing global object. This is
 87657:      * used for GNAME opcodes where the bytecode emitter has determined a
 87657:      * name access must be on the global. It also insulates us from bugs
 87657:      * in the emitter: type inference will assume that GNAME opcodes are
 87657:      * accessing the global object, and the inferred behavior should match
 87657:      * the actual behavior even if the id could be found on the scope chain
 87657:      * before the global object.
 87657:      */
 87657:     if (js_CodeSpec[*pc].format & JOF_GNAME)
 86855:         obj = &obj->global();
 86855: 
 86855:     PropertyCacheEntry *entry;
 86855:     JSObject *obj2;
 99421:     RootedPropertyName name(cx);
 99364:     JS_PROPERTY_CACHE(cx).test(cx, pc, obj.reference(), obj2, entry, name.reference());
 86855:     if (!name) {
 86855:         AssertValidPropertyCacheHit(cx, obj, obj2, entry);
 94227:         if (!NativeGet(cx, obj, obj2, entry->prop, 0, vp))
 86855:             return false;
 86855:         return true;
 86855:     }
 86855: 
 86855:     JSProperty *prop;
 99364:     if (!FindPropertyHelper(cx, name, true, obj, obj.address(), &obj2, &prop))
 86855:         return false;
 86855:     if (!prop) {
 86855:         /* Kludge to allow (typeof foo == "undefined") tests. */
 86855:         JSOp op2 = JSOp(pc[JSOP_NAME_LENGTH]);
 86855:         if (op2 == JSOP_TYPEOF) {
 86855:             vp->setUndefined();
 86855:             return true;
 86855:         }
 86855:         JSAutoByteString printable;
 86855:         if (js_AtomToPrintableString(cx, name, &printable))
 86855:             js_ReportIsNotDefined(cx, printable.ptr());
 86855:         return false;
 86855:     }
 86855: 
 86855:     /* Take the slow path if prop was not found in a native object. */
 86855:     if (!obj->isNative() || !obj2->isNative()) {
 99421:         if (!obj->getGeneric(cx, RootedId(cx, NameToId(name)), vp))
 86855:             return false;
 86855:     } else {
 86855:         Shape *shape = (Shape *)prop;
 86855:         JSObject *normalized = obj;
 86855:         if (normalized->getClass() == &WithClass && !shape->hasDefaultGetter())
 86855:             normalized = &normalized->asWith().object();
 94227:         if (!NativeGet(cx, normalized, obj2, shape, 0, vp))
 86855:             return false;
 86855:     }
 86855: 
 86855:     return true;
 86855: }
 86855: 
 86855: inline bool
 95355: DefVarOrConstOperation(JSContext *cx, HandleObject varobj, PropertyName *dn, unsigned attrs)
 89817: {
 95355:     JS_ASSERT(varobj->isVarObj());
 98921:     JS_ASSERT(!varobj->getOps()->defineProperty || varobj->isDebugScope());
 89817: 
 89817:     JSProperty *prop;
 89817:     JSObject *obj2;
 95355:     if (!varobj->lookupProperty(cx, dn, &obj2, &prop))
 89817:         return false;
 89817: 
 89817:     /* Steps 8c, 8d. */
 95355:     if (!prop || (obj2 != varobj && varobj->isGlobal())) {
 98921:         if (!varobj->defineProperty(cx, dn, UndefinedValue(), JS_PropertyStub,
 98921:                                     JS_StrictPropertyStub, attrs)) {
 89817:             return false;
 89817:         }
 89817:     } else {
 89817:         /*
 89817:          * Extension: ordinarily we'd be done here -- but for |const|.  If we
 89817:          * see a redeclaration that's |const|, we consider it a conflict.
 89817:          */
 91237:         unsigned oldAttrs;
 95355:         if (!varobj->getPropertyAttributes(cx, dn, &oldAttrs))
 89817:             return false;
 89817:         if (attrs & JSPROP_READONLY) {
 89817:             JSAutoByteString bytes;
 89817:             if (js_AtomToPrintableString(cx, dn, &bytes)) {
 89817:                 JS_ALWAYS_FALSE(JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 89817:                                                              js_GetErrorMessage,
 89817:                                                              NULL, JSMSG_REDECLARED_VAR,
 89817:                                                              (oldAttrs & JSPROP_READONLY)
 89817:                                                              ? "const"
 89817:                                                              : "var",
 89817:                                                              bytes.ptr()));
 89817:             }
 89817:             return false;
 89817:         }
 89817:     }
 89817: 
 89817:     return true;
 89817: }
 89817: 
100006: inline bool
100006: FunctionNeedsPrologue(JSContext *cx, JSFunction *fun)
100006: {
100006:     /* Heavyweight functions need call objects created. */
100006:     if (fun->isHeavyweight())
100006:         return true;
100006: 
100006:     /* Outer and inner functions need to preserve nesting invariants. */
100006:     if (cx->typeInferenceEnabled() && fun->script()->nesting())
100006:         return true;
100006: 
100006:     return false;
100006: }
100006: 
100006: inline bool
100006: ScriptPrologue(JSContext *cx, StackFrame *fp, bool newType)
100006: {
100006:     JS_ASSERT_IF(fp->isNonEvalFunctionFrame() && fp->fun()->isHeavyweight(), fp->hasCallObj());
100006: 
100006:     if (fp->isConstructing()) {
100006:         JSObject *obj = js_CreateThisForFunction(cx, RootedObject(cx, &fp->callee()), newType);
100006:         if (!obj)
100006:             return false;
100006:         fp->functionThis().setObject(*obj);
100006:     }
100006: 
100006:     Probes::enterJSFun(cx, fp->maybeFun(), fp->script());
100006: 
100006:     return true;
100006: }
100006: 
100006: inline bool
100006: ScriptEpilogue(JSContext *cx, StackFrame *fp, bool ok)
100006: {
100006:     Probes::exitJSFun(cx, fp->maybeFun(), fp->script());
100006: 
100006:     /*
100006:      * If inline-constructing, replace primitive rval with the new object
100006:      * passed in via |this|, and instrument this constructor invocation.
100006:      */
100006:     if (fp->isConstructing() && ok) {
100006:         if (fp->returnValue().isPrimitive())
100006:             fp->setReturnValue(ObjectValue(fp->constructorThis()));
100006:     }
100006: 
100006:     return ok;
100006: }
100006: 
100006: inline bool
100006: ScriptPrologueOrGeneratorResume(JSContext *cx, StackFrame *fp, bool newType)
100006: {
100006:     if (!fp->isGeneratorFrame())
100006:         return ScriptPrologue(cx, fp, newType);
100006:     return true;
100006: }
100006: 
100006: inline bool
100006: ScriptEpilogueOrGeneratorYield(JSContext *cx, StackFrame *fp, bool ok)
100006: {
100006:     if (!fp->isYielding())
100006:         return ScriptEpilogue(cx, fp, ok);
100006:     return ok;
100006: }
100006: 
 79734: inline void
 79734: InterpreterFrames::enableInterruptsIfRunning(JSScript *script)
 79734: {
 79734:     if (script == regs->fp()->script())
 79734:         enabler.enableInterrupts();
 79734: }
 79734: 
100006: inline void
100006: AssertValidEvalFrameScopeChainAtExit(StackFrame *fp)
100006: {
100006: #ifdef DEBUG
100006:     JS_ASSERT(fp->isEvalFrame());
100006: 
100006:     JS_ASSERT(!fp->hasBlockChain());
100006:     JSObject &scope = *fp->scopeChain();
100006: 
100006:     if (fp->isStrictEvalFrame())
100006:         JS_ASSERT(scope.asCall().maybeStackFrame() == fp);
100006:     else if (fp->isDebuggerFrame())
100006:         JS_ASSERT(!scope.isScope());
100006:     else if (fp->isDirectEvalFrame())
100006:         JS_ASSERT(scope == *fp->prev()->scopeChain());
100006:     else
100006:         JS_ASSERT(scope.isGlobal());
100006: #endif
100006: }
100006: 
100006: inline void
100006: AssertValidFunctionScopeChainAtExit(StackFrame *fp)
100006: {
100006: #ifdef DEBUG
100006:     JS_ASSERT(fp->isFunctionFrame());
100006:     if (fp->isGeneratorFrame() || fp->isYielding())
100006:         return;
100006: 
100006:     if (fp->isEvalFrame()) {
100006:         AssertValidEvalFrameScopeChainAtExit(fp);
100006:         return;
100006:     }
100006: 
100006:     JS_ASSERT(!fp->hasBlockChain());
100006:     JSObject &scope = *fp->scopeChain();
100006: 
100006:     if (fp->fun()->isHeavyweight() && fp->hasCallObj())
100006:         JS_ASSERT(scope.asCall().maybeStackFrame() == fp);
100006:     else if (scope.isCall() || scope.isBlock())
100006:         JS_ASSERT(scope.asScope().maybeStackFrame() != fp);
100006: #endif
100006: }
100006: 
 87809: static JS_ALWAYS_INLINE bool
 87809: AddOperation(JSContext *cx, const Value &lhs, const Value &rhs, Value *res)
 87809: {
 95355:     if (lhs.isInt32() && rhs.isInt32()) {
 95355:         int32_t l = lhs.toInt32(), r = rhs.toInt32();
 87809:         int32_t sum = l + r;
 87809:         if (JS_UNLIKELY(bool((l ^ sum) & (r ^ sum) & 0x80000000))) {
 87809:             res->setDouble(double(l) + double(r));
 87809:             types::TypeScript::MonitorOverflow(cx);
 87809:         } else {
 87809:             res->setInt32(sum);
 87809:         }
 87809:     } else
 87809: #if JS_HAS_XML_SUPPORT
 95355:     if (IsXML(lhs) && IsXML(rhs)) {
 95355:         if (!js_ConcatenateXML(cx, &lhs.toObject(), &rhs.toObject(), res))
 87809:             return false;
 87809:         types::TypeScript::MonitorUnknown(cx);
 87809:     } else
 87809: #endif
 87809:     {
 99421:         RootedValue lval_(cx, lhs);
 99421:         RootedValue rval_(cx, rhs);
 95355:         Value &lval = lval_.reference();
 95355:         Value &rval = rval_.reference();
 95355: 
 87809:         /*
 87809:          * If either operand is an object, any non-integer result must be
 87809:          * reported to inference.
 87809:          */
 87809:         bool lIsObject = lval.isObject(), rIsObject = rval.isObject();
 87809: 
 87809:         if (!ToPrimitive(cx, &lval))
 87809:             return false;
 87809:         if (!ToPrimitive(cx, &rval))
 87809:             return false;
 87809:         bool lIsString, rIsString;
 87809:         if ((lIsString = lval.isString()) | (rIsString = rval.isString())) {
 99421:             RootedString lstr(cx), rstr(cx);
 87809:             if (lIsString) {
 95355:                 lstr = lval.toString();
 87809:             } else {
 95355:                 lstr = ToString(cx, lval);
 95355:                 if (!lstr)
 87809:                     return false;
 87809:             }
 87809:             if (rIsString) {
 95355:                 rstr = rval.toString();
 87809:             } else {
 95355:                 rstr = ToString(cx, rval);
 95355:                 if (!rstr)
 87809:                     return false;
 87809:             }
 95355:             JSString *str = js_ConcatStrings(cx, lstr, rstr);
 87809:             if (!str)
 87809:                 return false;
 87809:             if (lIsObject || rIsObject)
 87809:                 types::TypeScript::MonitorString(cx);
 87809:             res->setString(str);
 87809:         } else {
 87809:             double l, r;
 87809:             if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))
 87809:                 return false;
 87809:             l += r;
 87809:             if (!res->setNumber(l) &&
 87809:                 (lIsObject || rIsObject || (!lval.isDouble() && !rval.isDouble()))) {
 87809:                 types::TypeScript::MonitorOverflow(cx);
 87809:             }
 87809:         }
 87809:     }
 87809:     return true;
 87809: }
 87809: 
 87809: static JS_ALWAYS_INLINE bool
 97353: SubOperation(JSContext *cx, HandleValue lhs, HandleValue rhs, Value *res)
 87809: {
 87809:     double d1, d2;
 87809:     if (!ToNumber(cx, lhs, &d1) || !ToNumber(cx, rhs, &d2))
 87809:         return false;
 87809:     double d = d1 - d2;
 97353:     if (!res->setNumber(d) && !(lhs.value().isDouble() || rhs.value().isDouble()))
 87809:         types::TypeScript::MonitorOverflow(cx);
 87809:     return true;
 87809: }
 87809: 
 87809: static JS_ALWAYS_INLINE bool
 97353: MulOperation(JSContext *cx, HandleValue lhs, HandleValue rhs, Value *res)
 87809: {
 87809:     double d1, d2;
 87809:     if (!ToNumber(cx, lhs, &d1) || !ToNumber(cx, rhs, &d2))
 87809:         return false;
 87809:     double d = d1 * d2;
 97353:     if (!res->setNumber(d) && !(lhs.value().isDouble() || rhs.value().isDouble()))
 87809:         types::TypeScript::MonitorOverflow(cx);
 87809:     return true;
 87809: }
 87809: 
 87809: static JS_ALWAYS_INLINE bool
 97353: DivOperation(JSContext *cx, HandleValue lhs, HandleValue rhs, Value *res)
 87809: {
 87809:     double d1, d2;
 87809:     if (!ToNumber(cx, lhs, &d1) || !ToNumber(cx, rhs, &d2))
 87809:         return false;
 87809:     res->setNumber(NumberDiv(d1, d2));
 87809: 
 97353:     if (d2 == 0 || (res->isDouble() && !(lhs.value().isDouble() || rhs.value().isDouble())))
 87809:         types::TypeScript::MonitorOverflow(cx);
 87809:     return true;
 87809: }
 87809: 
 87809: static JS_ALWAYS_INLINE bool
 97353: ModOperation(JSContext *cx, HandleValue lhs, HandleValue rhs, Value *res)
 87809: {
 87809:     int32_t l, r;
 97353:     if (lhs.value().isInt32() && rhs.value().isInt32() &&
 97353:         (l = lhs.value().toInt32()) >= 0 && (r = rhs.value().toInt32()) > 0) {
 87809:         int32_t mod = l % r;
 87809:         res->setInt32(mod);
 87809:         return true;
 87809:     }
 87809: 
 87809:     double d1, d2;
 87809:     if (!ToNumber(cx, lhs, &d1) || !ToNumber(cx, rhs, &d2))
 87809:         return false;
 87809: 
 87809:     if (d2 == 0)
 87809:         res->setDouble(js_NaN);
 87809:     else
 87809:         res->setDouble(js_fmod(d1, d2));
 87809:     types::TypeScript::MonitorOverflow(cx);
 87809:     return true;
 87809: }
 87809: 
 88054: static inline bool
 98960: FetchElementId(JSContext *cx, JSObject *obj, const Value &idval, jsid *idp, Value *vp)
 88054: {
 88054:     int32_t i_;
 88054:     if (ValueFitsInInt32(idval, &i_) && INT_FITS_IN_JSID(i_)) {
 98960:         *idp = INT_TO_JSID(i_);
 88054:         return true;
 88054:     }
 98960:     return !!InternNonIntElementId(cx, obj, idval, idp, vp);
 88054: }
 88054: 
 88054: static JS_ALWAYS_INLINE bool
 90123: ToIdOperation(JSContext *cx, const Value &objval, const Value &idval, Value *res)
 90123: {
 90123:     if (idval.isInt32()) {
 90123:         *res = idval;
 90123:         return true;
 90123:     }
 90123: 
 90123:     JSObject *obj = ValueToObject(cx, objval);
 90123:     if (!obj)
 90123:         return false;
 90123: 
 90123:     jsid dummy;
 97828:     if (!InternNonIntElementId(cx, obj, idval, &dummy, res))
 90123:         return false;
 90123: 
 90123:     if (!res->isInt32())
 90123:         types::TypeScript::MonitorUnknown(cx);
 90123:     return true;
 90123: }
 90123: 
 90123: static JS_ALWAYS_INLINE bool
 95355: GetObjectElementOperation(JSContext *cx, JSOp op, HandleObject obj, const Value &rref, Value *res)
 88054: {
 91807: #if JS_HAS_XML_SUPPORT
 91807:     if (op == JSOP_CALLELEM && JS_UNLIKELY(obj->isXML())) {
 91807:         jsid id;
 98960:         if (!FetchElementId(cx, obj, rref, &id, res))
 91807:             return false;
 91807:         return js_GetXMLMethod(cx, obj, id, res);
 91807:     }
 91807: #endif
 91807: 
 88054:     uint32_t index;
 88054:     if (IsDefinitelyIndex(rref, &index)) {
 88054:         do {
 88054:             if (obj->isDenseArray()) {
 88054:                 if (index < obj->getDenseArrayInitializedLength()) {
 88054:                     *res = obj->getDenseArrayElement(index);
 88054:                     if (!res->isMagic())
 88054:                         break;
 88054:                 }
 88054:             } else if (obj->isArguments()) {
100006:                 if (obj->asArguments().getElement(index, res))
 88054:                     break;
 88054:             }
 88054:             if (!obj->getElement(cx, index, res))
 88054:                 return false;
 88054:         } while(0);
 88054:     } else {
 90694:         JSScript *script;
 90694:         jsbytecode *pc;
 90694:         types::TypeScript::GetPcScript(cx, &script, &pc);
 90694: 
 88054:         if (script->hasAnalysis())
 88054:             script->analysis()->getCode(pc).getStringElement = true;
 88054: 
 88054:         SpecialId special;
 88054:         *res = rref;
 88054:         if (ValueIsSpecial(obj, res, &special, cx)) {
 88054:             if (!obj->getSpecial(cx, obj, special, res))
 88054:                 return false;
 88054:         } else {
 88054:             JSAtom *name;
 88054:             if (!js_ValueToAtom(cx, *res, &name))
 88054:                 return false;
 88054: 
 88054:             if (name->isIndex(&index)) {
 88054:                 if (!obj->getElement(cx, index, res))
 88054:                     return false;
 88054:             } else {
 88054:                 if (!obj->getProperty(cx, name->asPropertyName(), res))
 88054:                     return false;
 88054:             }
 88054:         }
 88054:     }
 88054: 
 88054:     assertSameCompartment(cx, *res);
 88054:     return true;
 88054: }
 88054: 
 88054: static JS_ALWAYS_INLINE bool
 91807: GetElementOperation(JSContext *cx, JSOp op, const Value &lref, const Value &rref, Value *res)
 88054: {
 91807:     JS_ASSERT(op == JSOP_GETELEM || op == JSOP_CALLELEM);
 91807: 
 88054:     if (lref.isString() && rref.isInt32()) {
 88054:         JSString *str = lref.toString();
 88054:         int32_t i = rref.toInt32();
 88054:         if (size_t(i) < str->length()) {
 88054:             str = cx->runtime->staticStrings.getUnitStringForElement(cx, str, size_t(i));
 88054:             if (!str)
 88054:                 return false;
 88054:             res->setString(str);
 88054:             return true;
 88054:         }
 88054:     }
 88054: 
 93250:     if (lref.isMagic(JS_OPTIMIZED_ARGUMENTS))
 93250:         return NormalArgumentsObject::optimizedGetElem(cx, cx->fp(), rref, res);
 88054: 
 91807:     bool isObject = lref.isObject();
 99421:     RootedObject obj(cx, ValueToObject(cx, lref));
 88054:     if (!obj)
 88054:         return false;
 91807:     if (!GetObjectElementOperation(cx, op, obj, rref, res))
 91807:         return false;
 91807: 
 91807: #if JS_HAS_NO_SUCH_METHOD
 91807:     if (op == JSOP_CALLELEM && JS_UNLIKELY(res->isPrimitive()) && isObject) {
 91807:         if (!OnUnknownMethod(cx, obj, rref, res))
 91807:             return false;
 91807:     }
 91807: #endif
 91807:     return true;
 88054: }
 88054: 
 88054: static JS_ALWAYS_INLINE bool
 98960: SetObjectElementOperation(JSContext *cx, JSObject *obj, HandleId id, const Value &value, bool strict)
 88054: {
 91183:     types::TypeScript::MonitorAssign(cx, obj, id);
 88054: 
 88054:     do {
 88054:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
 91688:             uint32_t length = obj->getDenseArrayInitializedLength();
 91450:             int32_t i = JSID_TO_INT(id);
 91688:             if ((uint32_t)i < length) {
 88054:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
 88054:                     if (js_PrototypeHasIndexedProperties(cx, obj))
 88054:                         break;
 91688:                     if ((uint32_t)i >= obj->getArrayLength())
 88054:                         obj->setArrayLength(cx, i + 1);
 88054:                 }
 88054:                 obj->setDenseArrayElementWithType(cx, i, value);
 88054:                 return true;
 88054:             } else {
 91183:                 JSScript *script;
 91183:                 jsbytecode *pc;
 91183:                 types::TypeScript::GetPcScript(cx, &script, &pc);
 91183: 
 88054:                 if (script->hasAnalysis())
 88054:                     script->analysis()->getCode(pc).arrayWriteHole = true;
 88054:             }
 88054:         }
 88054:     } while (0);
 88054: 
 99421:     RootedValue tmp(cx, value);
 95355:     return obj->setGeneric(cx, id, tmp.address(), strict);
 88054: }
 88054: 
 88413: #define RELATIONAL_OP(OP)                                                     \
 88413:     JS_BEGIN_MACRO                                                            \
 99421:         RootedValue lvalRoot(cx, lhs), rvalRoot(cx, rhs);                     \
 99364:         Value &lval = lvalRoot.reference();                                   \
 99364:         Value &rval = rvalRoot.reference();                                   \
 88413:         /* Optimize for two int-tagged operands (typical loop control). */    \
 88413:         if (lval.isInt32() && rval.isInt32()) {                               \
 88413:             *res = lval.toInt32() OP rval.toInt32();                          \
 88413:         } else {                                                              \
 88413:             if (!ToPrimitive(cx, JSTYPE_NUMBER, &lval))                       \
 88413:                 return false;                                                 \
 88413:             if (!ToPrimitive(cx, JSTYPE_NUMBER, &rval))                       \
 88413:                 return false;                                                 \
 88413:             if (lval.isString() && rval.isString()) {                         \
 88413:                 JSString *l = lval.toString(), *r = rval.toString();          \
 88413:                 int32_t result;                                               \
 88413:                 if (!CompareStrings(cx, l, r, &result))                       \
 88413:                     return false;                                             \
 88413:                 *res = result OP 0;                                           \
 88413:             } else {                                                          \
 88413:                 double l, r;                                                  \
 88413:                 if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))       \
 88413:                     return false;;                                            \
 88413:                 *res = (l OP r);                                              \
 88413:             }                                                                 \
 88413:         }                                                                     \
 88413:         return true;                                                          \
 88413:     JS_END_MACRO
 88413: 
 88413: static JS_ALWAYS_INLINE bool
 88413: LessThanOperation(JSContext *cx, const Value &lhs, const Value &rhs, bool *res) {
 88413:     RELATIONAL_OP(<);
 88413: }
 88413: 
 88413: static JS_ALWAYS_INLINE bool
 88413: LessThanOrEqualOperation(JSContext *cx, const Value &lhs, const Value &rhs, bool *res) {
 88413:     RELATIONAL_OP(<=);
 88413: }
 88413: 
 88413: static JS_ALWAYS_INLINE bool
 88413: GreaterThanOperation(JSContext *cx, const Value &lhs, const Value &rhs, bool *res) {
 88413:     RELATIONAL_OP(>);
 88413: }
 88413: 
 88413: static JS_ALWAYS_INLINE bool
 88413: GreaterThanOrEqualOperation(JSContext *cx, const Value &lhs, const Value &rhs, bool *res) {
 88413:     RELATIONAL_OP(>=);
 88413: }
 88413: 
 88413: #undef RELATIONAL_OP
 88413: 
 95100: static inline bool
 95100: GuardFunApplySpeculation(JSContext *cx, FrameRegs &regs)
 95100: {
 95100:     if (regs.sp[-1].isMagic(JS_OPTIMIZED_ARGUMENTS)) {
 95100:         CallArgs args = CallArgsFromSp(GET_ARGC(regs.pc), regs.sp);
 95100:         if (!IsNativeFunction(args.calleev(), js_fun_apply)) {
 97353:             if (!JSScript::applySpeculationFailed(cx, regs.fp()->script()))
 95100:                 return false;
100006:             args[1] = ObjectValue(regs.fp()->argsObj());
 95100:         }
 95100:     }
 95100:     return true;
 95100: }
 95100: 
 69223: }  /* namespace js */
 53840: 
 53840: #endif /* jsinterpinlines_h__ */
