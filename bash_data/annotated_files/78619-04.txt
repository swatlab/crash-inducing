19675: /* vim:set ts=2 sw=2 sts=2 et cindent: */
19675: /* ***** BEGIN LICENSE BLOCK *****
19675:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19675:  *
19675:  * The contents of this file are subject to the Mozilla Public License Version
19675:  * 1.1 (the "License"); you may not use this file except in compliance with
19675:  * the License. You may obtain a copy of the License at
19675:  * http://www.mozilla.org/MPL/
19675:  *
19675:  * Software distributed under the License is distributed on an "AS IS" basis,
19675:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19675:  * for the specific language governing rights and limitations under the
19675:  * License.
19675:  *
19675:  * The Original Code is Mozilla code.
19675:  *
19675:  * The Initial Developer of the Original Code is the Mozilla Corporation.
19675:  * Portions created by the Initial Developer are Copyright (C) 2007
19675:  * the Initial Developer. All Rights Reserved.
19675:  *
19675:  * Contributor(s):
19675:  *  Chris Double <chris.double@double.co.nz>
19675:  *
19675:  * Alternatively, the contents of this file may be used under the terms of
19675:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19675:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19675:  * in which case the provisions of the GPL or the LGPL are applicable instead
19675:  * of those above. If you wish to allow use of your version of this file only
19675:  * under the terms of either the GPL or the LGPL, and not to allow others to
19675:  * use your version of this file under the terms of the MPL, indicate your
19675:  * decision by deleting the provisions above and replace them with the notice
19675:  * and other provisions required by the GPL or the LGPL. If you do not delete
19675:  * the provisions above, a recipient may use your version of this file under
19675:  * the terms of any one of the MPL, the GPL or the LGPL.
19675:  *
19675:  * ***** END LICENSE BLOCK ***** */
26836: 
19675: #if !defined(nsMediaStream_h_)
19675: #define nsMediaStream_h_
19675: 
64576: #include "mozilla/Mutex.h"
28510: #include "mozilla/XPCOM.h"
19675: #include "nsIChannel.h"
19675: #include "nsIPrincipal.h"
19675: #include "nsIURI.h"
24155: #include "nsIStreamListener.h"
28370: #include "nsIChannelEventSink.h"
28370: #include "nsIInterfaceRequestor.h"
26836: #include "nsMediaCache.h"
19675: 
23860: // For HTTP seeking, if number of bytes needing to be
23860: // seeked forward is less than this value then a read is
23860: // done rather than a byte range request.
78286: static const PRInt64 SEEK_VS_READ_THRESHOLD = 32*1024;
23860: 
78286: static const PRUint32 HTTP_REQUESTED_RANGE_NOT_SATISFIABLE_CODE = 416;
36217: 
19675: class nsMediaDecoder;
19675: 
26836: /**
26836:  * This class is useful for estimating rates of data passing through
26836:  * some channel. The idea is that activity on the channel "starts"
26836:  * and "stops" over time. At certain times data passes through the
26836:  * channel (usually while the channel is active; data passing through
26836:  * an inactive channel is ignored). The GetRate() function computes
26836:  * an estimate of the "current rate" of the channel, which is some
26836:  * kind of average of the data passing through over the time the
26836:  * channel is active.
26836:  * 
27222:  * All methods take "now" as a parameter so the user of this class can
27222:  * control the timeline used.
26836:  */
26836: class nsChannelStatistics {
26836: public:
27222:   typedef mozilla::TimeStamp TimeStamp;
27222:   typedef mozilla::TimeDuration TimeDuration;
27222: 
26836:   nsChannelStatistics() { Reset(); }
26836:   void Reset() {
27222:     mLastStartTime = TimeStamp();
27222:     mAccumulatedTime = TimeDuration(0);
26836:     mAccumulatedBytes = 0;
26836:     mIsStarted = PR_FALSE;
26836:   }
27222:   void Start(TimeStamp aNow) {
26836:     if (mIsStarted)
26836:       return;
26836:     mLastStartTime = aNow;
26836:     mIsStarted = PR_TRUE;
26836:   }
27222:   void Stop(TimeStamp aNow) {
26836:     if (!mIsStarted)
26836:       return;
26836:     mAccumulatedTime += aNow - mLastStartTime;
26836:     mIsStarted = PR_FALSE;
26836:   }
26836:   void AddBytes(PRInt64 aBytes) {
26836:     if (!mIsStarted) {
26836:       // ignore this data, it may be related to seeking or some other
26836:       // operation we don't care about
26836:       return;
26836:     }
26836:     mAccumulatedBytes += aBytes;
26836:   }
26836:   double GetRateAtLastStop(PRPackedBool* aReliable) {
27222:     double seconds = mAccumulatedTime.ToSeconds();
27222:     *aReliable = seconds >= 1.0;
27222:     if (seconds <= 0.0)
27222:       return 0.0;
68450:     return static_cast<double>(mAccumulatedBytes)/seconds;
26836:   }
27222:   double GetRate(TimeStamp aNow, PRPackedBool* aReliable) {
27222:     TimeDuration time = mAccumulatedTime;
26836:     if (mIsStarted) {
26836:       time += aNow - mLastStartTime;
26836:     }
27222:     double seconds = time.ToSeconds();
28567:     *aReliable = seconds >= 3.0;
27222:     if (seconds <= 0.0)
26836:       return 0.0;
68450:     return static_cast<double>(mAccumulatedBytes)/seconds;
26836:   }
26836: private:
26836:   PRInt64      mAccumulatedBytes;
27222:   TimeDuration mAccumulatedTime;
27222:   TimeStamp    mLastStartTime;
26836:   PRPackedBool mIsStarted;
26836: };
26836: 
63626: // Represents a section of contiguous media, with a start and end offset.
63626: // Used to denote ranges of data which are cached.
63626: class nsByteRange {
63626: public:
63626:   nsByteRange() : mStart(0), mEnd(0) {}
63626: 
63626:   nsByteRange(PRInt64 aStart, PRInt64 aEnd)
63626:     : mStart(aStart), mEnd(aEnd)
63626:   {
63626:     NS_ASSERTION(mStart < mEnd, "Range should end after start!");
63626:   }
63626: 
63626:   PRBool IsNull() const {
63626:     return mStart == 0 && mEnd == 0;
63626:   }
63626: 
63626:   PRInt64 mStart, mEnd;
63626: };
63626: 
26705: /*
26705:    Provides the ability to open, read and seek into a media stream
26705:    (audio, video). Handles the underlying machinery to do range
26705:    requests, etc as needed by the actual stream type. Instances of
26705:    this class must be created on the main thread. 
26705: 
26836:    Most methods must be called on the main thread only. Read, Seek and
48904:    Tell must only be called on non-main threads. In the case of the Ogg
48904:    Decoder they are called on the Decode thread for example. You must
48904:    ensure that no threads are calling these methods once Close is called.
26705: 
26705:    Instances of this class are explicitly managed. 'delete' it when done.
26705: */
26705: class nsMediaStream 
19675: {
19675: public:
26705:   virtual ~nsMediaStream()
26705:   {
26705:     MOZ_COUNT_DTOR(nsMediaStream);
26705:   }
26705: 
26836:   // The following can be called on the main thread only:
32898:   // Get the URI
32898:   nsIURI* URI() { return mURI; }
26705:   // Close the stream, stop any listeners, channels, etc.
26836:   // Cancels any currently blocking Read request and forces that request to
26836:   // return an error.
26705:   virtual nsresult Close() = 0;
26836:   // Suspend any downloads that are in progress.
28487:   // If aCloseImmediately is set, resources should be released immediately
28487:   // since we don't expect to resume again any time soon. Otherwise we
28487:   // may resume again soon so resources should be held for a little
28487:   // while.
28487:   virtual void Suspend(PRBool aCloseImmediately) = 0;
26836:   // Resume any downloads that have been suspended.
26836:   virtual void Resume() = 0;
28370:   // Get the current principal for the channel
28370:   virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal() = 0;
32901:   // Create a new stream of the same type that refers to the same URI
32901:   // with a new channel. Any cached data associated with the original
32901:   // stream should be accessible in the new stream too.
32901:   virtual nsMediaStream* CloneData(nsMediaDecoder* aDecoder) = 0;
26836: 
26836:   // These methods are called off the main thread.
26836:   // The mode is initially MODE_PLAYBACK.
26836:   virtual void SetReadMode(nsMediaCacheStream::ReadMode aMode) = 0;
26836:   // This is the client's estimate of the playback rate assuming
26836:   // the media plays continuously. The cache can't guess this itself
26836:   // because it doesn't know when the decoder was paused, buffering, etc.
26836:   virtual void SetPlaybackRate(PRUint32 aBytesPerSecond) = 0;
26705:   // Read up to aCount bytes from the stream. The buffer must have
26705:   // enough room for at least aCount bytes. Stores the number of
26836:   // actual bytes read in aBytes (0 on end of file).
26836:   // May read less than aCount bytes if the number of
26705:   // available bytes is less than aCount. Always check *aBytes after
26705:   // read, and call again if necessary.
26705:   virtual nsresult Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes) = 0;
26705:   // Seek to the given bytes offset in the stream. aWhence can be
26705:   // one of:
26705:   //   NS_SEEK_SET
26705:   //   NS_SEEK_CUR
26705:   //   NS_SEEK_END
26705:   //
26705:   // In the Http strategy case the cancel will cause the http
26705:   // channel's listener to close the pipe, forcing an i/o error on any
26705:   // blocked read. This will allow the decode thread to complete the
26705:   // event.
26705:   // 
26705:   // In the case of a seek in progress, the byte range request creates
26705:   // a new listener. This is done on the main thread via seek
26705:   // synchronously dispatching an event. This avoids the issue of us
26705:   // closing the listener but an outstanding byte range request
26705:   // creating a new one. They run on the same thread so no explicit
26705:   // synchronisation is required. The byte range request checks for
26705:   // the cancel flag and does not create a new channel or listener if
26705:   // we are cancelling.
26705:   //
26705:   // The default strategy does not do any seeking - the only issue is
26705:   // a blocked read which it handles by causing the listener to close
26705:   // the pipe, as per the http case.
26705:   //
26705:   // The file strategy doesn't block for any great length of time so
26705:   // is fine for a no-op cancel.
26705:   virtual nsresult Seek(PRInt32 aWhence, PRInt64 aOffset) = 0;
26705:   // Report the current offset in bytes from the start of the stream.
26705:   virtual PRInt64 Tell() = 0;
27217:   // Moves any existing channel loads into the background, so that they don't
27217:   // block the load event. Any new loads initiated (for example to seek)
27217:   // will also be in the background.
27217:   void MoveLoadsToBackground();
26705: 
26836:   // These can be called on any thread.
26836:   // Cached blocks associated with this stream will not be evicted
26836:   // while the stream is pinned.
26836:   virtual void Pin() = 0;
26836:   virtual void Unpin() = 0;
26836:   // Get the estimated download rate in bytes per second (assuming no
26836:   // pausing of the channel is requested by Gecko).
26836:   // *aIsReliable is set to true if we think the estimate is useful.
26836:   virtual double GetDownloadRate(PRPackedBool* aIsReliable) = 0;
26836:   // Get the length of the stream in bytes. Returns -1 if not known.
26836:   // This can change over time; after a seek operation, a misbehaving
26836:   // server may give us a resource of a different length to what it had
26836:   // reported previously --- or it may just lie in its Content-Length
26836:   // header and give us more or less data than it reported. We will adjust
26836:   // the result of GetLength to reflect the data that's actually arriving.
26836:   virtual PRInt64 GetLength() = 0;
28471:   // Returns the offset of the first byte of cached data at or after aOffset,
28471:   // or -1 if there is no such cached data.
28471:   virtual PRInt64 GetNextCachedData(PRInt64 aOffset) = 0;
26836:   // Returns the end of the bytes starting at the given offset
26836:   // which are in cache.
26836:   virtual PRInt64 GetCachedDataEnd(PRInt64 aOffset) = 0;
26836:   // Returns true if all the data from aOffset to the end of the stream
26836:   // is in cache. If the end of the stream is not known, we return false.
26836:   virtual PRBool IsDataCachedToEndOfStream(PRInt64 aOffset) = 0;
26836:   // Returns true if this stream is suspended by the cache because the
26836:   // cache is full. If true then the decoder should try to start consuming
26836:   // data, otherwise we may not be able to make progress.
26836:   // nsMediaDecoder::NotifySuspendedStatusChanged is called when this
26836:   // changes.
26836:   virtual PRBool IsSuspendedByCache() = 0;
50369:   // Returns true if this stream has been suspended.
50369:   virtual PRBool IsSuspended() = 0;
48904:   // Reads only data which is cached in the media cache. If you try to read
48904:   // any data which overlaps uncached data, or if aCount bytes otherwise can't
48904:   // be read, this function will return failure. This function be called from
48904:   // any thread, and it is the only read operation which is safe to call on
48904:   // the main thread, since it's guaranteed to be non blocking.
48904:   virtual nsresult ReadFromCache(char* aBuffer,
48904:                                  PRInt64 aOffset,
48904:                                  PRUint32 aCount) = 0;
26705: 
26705:   /**
32899:    * Create a stream, reading data from the media resource via the
32899:    * channel. Call on main thread only.
32899:    * The caller must follow up by calling aStream->Open.
26705:    */
32899:   static nsMediaStream* Create(nsMediaDecoder* aDecoder, nsIChannel* aChannel);
32899: 
32899:   /**
32899:    * Open the stream. This creates a stream listener and returns it in
32899:    * aStreamListener; this listener needs to be notified of incoming data.
32899:    */
32899:   virtual nsresult Open(nsIStreamListener** aStreamListener) = 0;
26705: 
63626:   /**
63626:    * Fills aRanges with ByteRanges representing the data which is cached
63626:    * in the media cache. Stream should be pinned during call and while
63626:    * aRanges is being used.
63626:    */
63626:   virtual nsresult GetCachedRanges(nsTArray<nsByteRange>& aRanges) = 0;
63626: 
26705: protected:
26705:   nsMediaStream(nsMediaDecoder* aDecoder, nsIChannel* aChannel, nsIURI* aURI) :
19675:     mDecoder(aDecoder),
19675:     mChannel(aChannel),
27217:     mURI(aURI),
27217:     mLoadInBackground(PR_FALSE)
19675:   {
26705:     MOZ_COUNT_CTOR(nsMediaStream);
19675:   }
19675: 
62568:   // Set the request's load flags to aFlags.  If the request is part of a
62568:   // load group, the request is removed from the group, the flags are set, and
62568:   // then the request is added back to the load group.
62568:   void ModifyLoadFlags(nsLoadFlags aFlags);
62568: 
19675:   // This is not an nsCOMPointer to prevent a circular reference
19675:   // between the decoder to the media stream object. The stream never
19675:   // outlives the lifetime of the decoder.
19675:   nsMediaDecoder* mDecoder;
19675: 
19675:   // Channel used to download the media data. Must be accessed
19675:   // from the main thread only.
19675:   nsCOMPtr<nsIChannel> mChannel;
19675: 
19675:   // URI in case the stream needs to be re-opened. Access from
19675:   // main thread only.
19675:   nsCOMPtr<nsIURI> mURI;
27217: 
27217:   // PR_TRUE if MoveLoadsToBackground() has been called, i.e. the load event
27217:   // has been fired, and all channel loads will be in the background.
27217:   PRPackedBool mLoadInBackground;
26836: };
19675: 
26836: /**
26836:  * This is the nsMediaStream implementation that wraps Necko channels.
26836:  * Much of its functionality is actually delegated to nsMediaCache via
26836:  * an underlying nsMediaCacheStream.
26836:  *
26836:  * All synchronization is performed by nsMediaCacheStream; all off-main-
26836:  * thread operations are delegated directly to that object.
26836:  */
26836: class nsMediaChannelStream : public nsMediaStream
26836: {
64576:   typedef mozilla::Mutex Mutex;
64576: 
26836: public:
26836:   nsMediaChannelStream(nsMediaDecoder* aDecoder, nsIChannel* aChannel, nsIURI* aURI);
26836:   ~nsMediaChannelStream();
26836: 
26836:   // These are called on the main thread by nsMediaCache. These must
34206:   // not block or grab locks, because the media cache is holding its lock.
32905:   // Notify that data is available from the cache. This can happen even
32905:   // if this stream didn't read any data, since another stream might have
32905:   // received data for the same resource.
32905:   void CacheClientNotifyDataReceived();
32905:   // Notify that we reached the end of the stream. This can happen even
32905:   // if this stream didn't read any data, since another stream might have
32905:   // received data for the same resource.
32905:   void CacheClientNotifyDataEnded(nsresult aStatus);
34206: 
34206:   // These are called on the main thread by nsMediaCache. These shouldn't block,
34206:   // but they may grab locks --- the media cache is not holding its lock
34206:   // when these are called.
26836:   // Start a new load at the given aOffset. The old load is cancelled
26836:   // and no more data from the old load will be notified via
26836:   // nsMediaCacheStream::NotifyDataReceived/Ended.
26836:   // This can fail.
28487:   nsresult CacheClientSeek(PRInt64 aOffset, PRBool aResume);
26836:   // Suspend the current load since data is currently not wanted
26836:   nsresult CacheClientSuspend();
26836:   // Resume the current load since data is wanted again
26836:   nsresult CacheClientResume();
26836: 
26836:   // Main thread
26836:   virtual nsresult Open(nsIStreamListener** aStreamListener);
26836:   virtual nsresult Close();
28487:   virtual void     Suspend(PRBool aCloseImmediately);
26836:   virtual void     Resume();
28370:   virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal();
26836:   // Return PR_TRUE if the stream has been closed.
26836:   PRBool IsClosed() const { return mCacheStream.IsClosed(); }
32901:   virtual nsMediaStream* CloneData(nsMediaDecoder* aDecoder);
48904:   virtual nsresult ReadFromCache(char* aBuffer, PRInt64 aOffset, PRUint32 aCount);
26836: 
26836:   // Other thread
26836:   virtual void     SetReadMode(nsMediaCacheStream::ReadMode aMode);
26836:   virtual void     SetPlaybackRate(PRUint32 aBytesPerSecond);
26836:   virtual nsresult Read(char* aBuffer, PRUint32 aCount, PRUint32* aBytes);
26836:   virtual nsresult Seek(PRInt32 aWhence, PRInt64 aOffset);
26836:   virtual PRInt64  Tell();
26836: 
26836:   // Any thread
26836:   virtual void    Pin();
26836:   virtual void    Unpin();
26836:   virtual double  GetDownloadRate(PRPackedBool* aIsReliable);
26836:   virtual PRInt64 GetLength();
28471:   virtual PRInt64 GetNextCachedData(PRInt64 aOffset);
26836:   virtual PRInt64 GetCachedDataEnd(PRInt64 aOffset);
26836:   virtual PRBool  IsDataCachedToEndOfStream(PRInt64 aOffset);
26836:   virtual PRBool  IsSuspendedByCache();
50369:   virtual PRBool  IsSuspended();
26836: 
28370:   class Listener : public nsIStreamListener,
28370:                    public nsIInterfaceRequestor,
28370:                    public nsIChannelEventSink
28370:   {
26836:   public:
26836:     Listener(nsMediaChannelStream* aStream) : mStream(aStream) {}
26836: 
26836:     NS_DECL_ISUPPORTS
26836:     NS_DECL_NSIREQUESTOBSERVER
26836:     NS_DECL_NSISTREAMLISTENER
28370:     NS_DECL_NSICHANNELEVENTSINK
28370:     NS_DECL_NSIINTERFACEREQUESTOR
26836: 
26836:     void Revoke() { mStream = nsnull; }
26836: 
26836:   private:
26836:     nsMediaChannelStream* mStream;
26836:   };
26836:   friend class Listener;
26836: 
63626:   nsresult GetCachedRanges(nsTArray<nsByteRange>& aRanges);
63626: 
32905: protected:
26836:   // These are called on the main thread by Listener.
26836:   nsresult OnStartRequest(nsIRequest* aRequest);
26836:   nsresult OnStopRequest(nsIRequest* aRequest, nsresult aStatus);
26836:   nsresult OnDataAvailable(nsIRequest* aRequest,
26836:                            nsIInputStream* aStream,
26836:                            PRUint32 aCount);
28370:   nsresult OnChannelRedirect(nsIChannel* aOld, nsIChannel* aNew, PRUint32 aFlags);
26836: 
28487:   // Opens the channel, using an HTTP byte range request to start at mOffset
26836:   // if possible. Main thread only.
28487:   nsresult OpenChannel(nsIStreamListener** aStreamListener);
32901:   nsresult RecreateChannel();
48349:   // Add headers to HTTP request. Main thread only.
28370:   void SetupChannelHeaders();
26836:   // Closes the channel. Main thread only.
26836:   void CloseChannel();
26836: 
32905:   void DoNotifyDataReceived();
32905: 
26836:   static NS_METHOD CopySegmentToCache(nsIInputStream *aInStream,
26836:                                       void *aClosure,
26836:                                       const char *aFromSegment,
26836:                                       PRUint32 aToOffset,
26836:                                       PRUint32 aCount,
26836:                                       PRUint32 *aWriteCount);
26836: 
67657:   // Suspend the channel only if the channels is currently downloading data.
67657:   // If it isn't we set a flag, mIgnoreResume, so that PossiblyResume knows
67657:   // whether to acutually resume or not.
67657:   void PossiblySuspend();
67657: 
67657:   // Resume from a suspend if we actually suspended (See PossiblySuspend).
67657:   void PossiblyResume();
67657: 
26836:   // Main thread access only
28487:   PRInt64            mOffset;
26836:   nsRefPtr<Listener> mListener;
32905:   // A data received event for the decoder that has been dispatched but has
32905:   // not yet been processed.
41359:   nsRevocableEventPtr<nsRunnableMethod<nsMediaChannelStream, void, false> > mDataReceivedEvent;
26836:   PRUint32           mSuspendCount;
28487:   // When this flag is set, if we get a network error we should silently
28487:   // reopen the stream.
28487:   PRPackedBool       mReopenOnError;
28487:   // When this flag is set, we should not report the next close of the
28487:   // channel.
28487:   PRPackedBool       mIgnoreClose;
26836: 
26836:   // Any thread access
26836:   nsMediaCacheStream mCacheStream;
26836: 
26836:   // This lock protects mChannelStatistics and mCacheSuspendCount
64576:   Mutex               mLock;
26836:   nsChannelStatistics mChannelStatistics;
26836:   PRUint32            mCacheSuspendCount;
67657: 
67657:   // PR_TRUE if we couldn't suspend the stream and we therefore don't want
67657:   // to resume later. This is usually due to the channel not being in the
67657:   // isPending state at the time of the suspend request.
67657:   PRPackedBool mIgnoreResume;
19675: };
19675: 
19675: #endif
