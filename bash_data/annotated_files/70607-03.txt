69223: /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
69223:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
69223:  *
69223:  * ***** BEGIN LICENSE BLOCK *****
69223:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69223:  *
69223:  * The contents of this file are subject to the Mozilla Public License Version
69223:  * 1.1 (the "License"); you may not use this file except in compliance with
69223:  * the License. You may obtain a copy of the License at
69223:  * http://www.mozilla.org/MPL/
69223:  *
69223:  * Software distributed under the License is distributed on an "AS IS" basis,
69223:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69223:  * for the specific language governing rights and limitations under the
69223:  * License.
69223:  *
69223:  * The Original Code is SpiderMonkey JavaScript engine.
69223:  *
69223:  * The Initial Developer of the Original Code is
69223:  * Mozilla Corporation.
69223:  * Portions created by the Initial Developer are Copyright (C) 2009
69223:  * the Initial Developer. All Rights Reserved.
69223:  *
69223:  * Contributor(s):
69223:  *   Luke Wagner <luke@mozilla.com>
69223:  *
69223:  * Alternatively, the contents of this file may be used under the terms of
69223:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69223:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69223:  * in which case the provisions of the GPL or the LGPL are applicable instead
69223:  * of those above. If you wish to allow use of your version of this file only
69223:  * under the terms of either the GPL or the LGPL, and not to allow others to
69223:  * use your version of this file under the terms of the MPL, indicate your
69223:  * decision by deleting the provisions above and replace them with the notice
69223:  * and other provisions required by the GPL or the LGPL. If you do not delete
69223:  * the provisions above, a recipient may use your version of this file under
69223:  * the terms of any one of the MPL, the GPL or the LGPL.
69223:  *
69223:  * ***** END LICENSE BLOCK ***** */
69223: 
69223: #ifndef Stack_inl_h__
69223: #define Stack_inl_h__
69223: 
70320: #include "jscntxt.h"
70321: #include "jscompartment.h"
70320: 
69223: #include "Stack.h"
69223: 
69827: #include "ArgumentsObject-inl.h"
69827: 
69223: namespace js {
69223: 
69223: /*****************************************************************************/
69223: 
69223: /* See VM stack layout comment in Stack.h. */
69223: class StackSegment
69223: {
69223:     /* The context to which this segment belongs. */
69223:     ContextStack        *stack_;
69223: 
69223:     /* Link for JSContext segment stack mentioned in big comment above. */
69223:     StackSegment        *previousInContext_;
69223: 
69223:     /* Link for StackSpace segment stack mentioned in StackSpace comment. */
69223:     StackSegment        *previousInMemory_;
69223: 
69223:     /* The first frame executed in this segment. null iff cx is null */
69223:     StackFrame          *initialFrame_;
69223: 
69223:     /* If this segment is suspended, |cx->regs| when it was suspended. */
69223:     FrameRegs           *suspendedRegs_;
69223: 
69223:     /* The varobj on entry to initialFrame. */
69223:     JSObject            *initialVarObj_;
69223: 
69223:     /* Whether this segment was suspended by JS_SaveFrameChain. */
69223:     bool                saved_;
69223: 
69223:     /* Align at 8 bytes on all platforms. */
69223: #if JS_BITS_PER_WORD == 32
69223:     void                *padding;
69223: #endif
69223: 
69223:     /*
69223:      * To make isActive a single null-ness check, this non-null constant is
69223:      * assigned to suspendedRegs when empty.
69223:      */
69223: #define NON_NULL_SUSPENDED_REGS ((FrameRegs *)0x1)
69223: 
69223:   public:
69223:     StackSegment()
69223:       : stack_(NULL), previousInContext_(NULL), previousInMemory_(NULL),
69223:         initialFrame_(NULL), suspendedRegs_(NON_NULL_SUSPENDED_REGS),
69223:         initialVarObj_(NULL), saved_(false)
69223:     {
69223:         JS_ASSERT(empty());
69223:     }
69223: 
69223:     /* Safe casts guaranteed by the contiguous-stack layout. */
69223: 
69223:     Value *valueRangeBegin() const {
69223:         return (Value *)(this + 1);
69223:     }
69223: 
69223:     /*
69223:      * The set of fields provided by a segment depend on its state. In addition
69223:      * to the "active" and "suspended" states described in Stack.h, segments
69223:      * have a third state: empty. An empty segment contains no frames and is
69223:      * pushed for the purpose of preparing the args to Invoke. Invoke args
69223:      * requires special handling because anything can happen between pushing
69223:      * Invoke args and calling Invoke. Since an empty segment contains no
69223:      * frames, it cannot become the "current segment" of a ContextStack (for
69223:      * various arcane and hopefully temporary reasons). Thus, an empty segment
69223:      * is pushed onto the StackSpace but only pushed onto a ContextStack when it
69223:      * gets its first frame pushed from js::Invoke.
69223:      *
69223:      * Finally, (to support JS_SaveFrameChain/JS_RestoreFrameChain) a suspended
69223:      * segment may or may not be "saved". Normally, when the active segment is
69223:      * popped, the previous segment (which is necessarily suspended) becomes
69223:      * active. If the previous segment was saved, however, then it stays
69223:      * suspended until it is made active by a call to JS_RestoreFrameChain. This
69223:      * is why a context may have a current segment, but not an active segment.
69223:      * Hopefully, this feature will be removed.
69223:      */
69223: 
69223:     bool empty() const {
69223:         JS_ASSERT(!!stack_ == !!initialFrame_);
69223:         JS_ASSERT_IF(!stack_, suspendedRegs_ == NON_NULL_SUSPENDED_REGS && !saved_);
69223:         return !stack_;
69223:     }
69223: 
69223:     bool isActive() const {
69223:         JS_ASSERT_IF(!suspendedRegs_, stack_ && !saved_);
69223:         JS_ASSERT_IF(!stack_, suspendedRegs_ == NON_NULL_SUSPENDED_REGS);
69223:         return !suspendedRegs_;
69223:     }
69223: 
69223:     bool isSuspended() const {
69223:         JS_ASSERT_IF(!stack_ || !suspendedRegs_, !saved_);
69223:         JS_ASSERT_IF(!stack_, suspendedRegs_ == NON_NULL_SUSPENDED_REGS);
69223:         return stack_ && suspendedRegs_;
69223:     }
69223: 
69223:     /* Substate of suspended, queryable in any state. */
69223: 
69223:     bool isSaved() const {
69223:         JS_ASSERT_IF(saved_, isSuspended());
69223:         return saved_;
69223:     }
69223: 
69223:     /* Transitioning between empty <--> isActive */
69223: 
69223:     void joinContext(ContextStack &stack, StackFrame &frame) {
69223:         JS_ASSERT(empty());
69223:         stack_ = &stack;
69223:         initialFrame_ = &frame;
69223:         suspendedRegs_ = NULL;
69223:         JS_ASSERT(isActive());
69223:     }
69223: 
69223:     void leaveContext() {
69223:         JS_ASSERT(isActive());
69223:         stack_ = NULL;
69223:         initialFrame_ = NULL;
69223:         suspendedRegs_ = NON_NULL_SUSPENDED_REGS;
69223:         JS_ASSERT(empty());
69223:     }
69223: 
69223:     ContextStack &stack() const {
69223:         JS_ASSERT(!empty());
69223:         return *stack_;
69223:     }
69223: 
69223:     ContextStack *maybeStack() const {
69223:         return stack_;
69223:     }
69223: 
69223: #undef NON_NULL_SUSPENDED_REGS
69223: 
69223:     /* Transitioning between isActive <--> isSuspended */
69223: 
69223:     void suspend(FrameRegs &regs) {
69223:         JS_ASSERT(isActive());
69223:         JS_ASSERT(contains(regs.fp()));
69223:         suspendedRegs_ = &regs;
69223:         JS_ASSERT(isSuspended());
69223:     }
69223: 
69223:     void resume() {
69223:         JS_ASSERT(isSuspended());
69223:         suspendedRegs_ = NULL;
69223:         JS_ASSERT(isActive());
69223:     }
69223: 
69223:     /* When isSuspended, transitioning isSaved <--> !isSaved */
69223: 
69223:     void save(FrameRegs &regs) {
69223:         JS_ASSERT(!isSuspended());
69223:         suspend(regs);
69223:         saved_ = true;
69223:         JS_ASSERT(isSaved());
69223:     }
69223: 
69223:     void restore() {
69223:         JS_ASSERT(isSaved());
69223:         saved_ = false;
69223:         resume();
69223:         JS_ASSERT(!isSuspended());
69223:     }
69223: 
69223:     /* Data available when !empty */
69223: 
69223:     StackFrame *initialFrame() const {
69223:         JS_ASSERT(!empty());
69223:         return initialFrame_;
69223:     }
69223: 
69223:     FrameRegs &currentRegs() const {
69223:         JS_ASSERT(!empty());
69223:         return isActive() ? stack_->regs() : suspendedRegs();
69223:     }
69223: 
69223:     StackFrame *currentFrame() const {
69223:         return currentRegs().fp();
69223:     }
69223: 
69223:     StackFrame *currentFrameOrNull() const {
69223:         return empty() ? NULL : currentFrame();
69223:     }
69223: 
69223:     /* Data available when isSuspended. */
69223: 
69223:     FrameRegs &suspendedRegs() const {
69223:         JS_ASSERT(isSuspended());
69223:         return *suspendedRegs_;
69223:     }
69223: 
69223:     StackFrame *suspendedFrame() const {
69223:         return suspendedRegs_->fp();
69223:     }
69223: 
69223:     /* JSContext / js::StackSpace bookkeeping. */
69223: 
69223:     void setPreviousInContext(StackSegment *seg) {
69223:         previousInContext_ = seg;
69223:     }
69223: 
69223:     StackSegment *previousInContext() const  {
69223:         return previousInContext_;
69223:     }
69223: 
69223:     void setPreviousInMemory(StackSegment *seg) {
69223:         previousInMemory_ = seg;
69223:     }
69223: 
69223:     StackSegment *previousInMemory() const  {
69223:         return previousInMemory_;
69223:     }
69223: 
69223:     void setInitialVarObj(JSObject *obj) {
69223:         JS_ASSERT(!empty());
69223:         initialVarObj_ = obj;
69223:     }
69223: 
69223:     bool hasInitialVarObj() {
69223:         JS_ASSERT(!empty());
69223:         return initialVarObj_ != NULL;
69223:     }
69223: 
69223:     JSObject &initialVarObj() const {
69223:         JS_ASSERT(!empty() && initialVarObj_);
69223:         return *initialVarObj_;
69223:     }
69223: 
69223:     bool contains(const StackFrame *fp) const;
69223: 
69223:     StackFrame *computeNextFrame(StackFrame *fp) const;
69223: };
69223: 
69223: static const size_t VALUES_PER_STACK_SEGMENT = sizeof(StackSegment) / sizeof(Value);
69223: JS_STATIC_ASSERT(sizeof(StackSegment) % sizeof(Value) == 0);
69223: 
69223: /*****************************************************************************/
69223: 
69223: inline void
69223: StackFrame::initPrev(JSContext *cx)
69223: {
69223:     JS_ASSERT(flags_ & HAS_PREVPC);
69223:     if (FrameRegs *regs = cx->maybeRegs()) {
69223:         prev_ = regs->fp();
69223:         prevpc_ = regs->pc;
69223:         JS_ASSERT_IF(!prev_->isDummyFrame() && !prev_->hasImacropc(),
69223:                      uint32(prevpc_ - prev_->script()->code) < prev_->script()->length);
69223:     } else {
69223:         prev_ = NULL;
69223: #ifdef DEBUG
69223:         prevpc_ = (jsbytecode *)0xbadc;
69223: #endif
69223:     }
69223: }
69223: 
69223: inline void
69223: StackFrame::resetGeneratorPrev(JSContext *cx)
69223: {
69223:     flags_ |= HAS_PREVPC;
69223:     initPrev(cx);
69223: }
69223: 
69223: inline void
69223: StackFrame::initCallFrame(JSContext *cx, JSObject &callee, JSFunction *fun,
69223:                           uint32 nactual, uint32 flagsArg)
69223: {
69223:     JS_ASSERT((flagsArg & ~(CONSTRUCTING |
69223:                             OVERFLOW_ARGS |
69223:                             UNDERFLOW_ARGS)) == 0);
69223:     JS_ASSERT(fun == callee.getFunctionPrivate());
69223: 
69223:     /* Initialize stack frame members. */
69223:     flags_ = FUNCTION | HAS_PREVPC | HAS_SCOPECHAIN | flagsArg;
69223:     exec.fun = fun;
69223:     args.nactual = nactual;  /* only need to write if over/under-flow */
69223:     scopeChain_ = callee.getParent();
69223:     initPrev(cx);
69223:     JS_ASSERT(!hasImacropc());
69223:     JS_ASSERT(!hasHookData());
69223:     JS_ASSERT(annotation() == NULL);
69223:     JS_ASSERT(!hasCallObj());
69223: }
69223: 
69223: inline void
69223: StackFrame::resetInvokeCallFrame()
69223: {
69223:     /* Undo changes to frame made during execution; see initCallFrame */
69223: 
69223:     putActivationObjects();
69223: 
69223:     JS_ASSERT(!(flags_ & ~(FUNCTION |
69223:                            OVERFLOW_ARGS |
69223:                            UNDERFLOW_ARGS |
69223:                            OVERRIDE_ARGS |
69223:                            HAS_PREVPC |
69223:                            HAS_RVAL |
69223:                            HAS_SCOPECHAIN |
69223:                            HAS_ANNOTATION |
69223:                            HAS_HOOK_DATA |
69223:                            HAS_CALL_OBJ |
69223:                            HAS_ARGS_OBJ |
69223:                            FINISHED_IN_INTERP)));
69223: 
69223:     /*
69223:      * Since the stack frame is usually popped after PutActivationObjects,
69223:      * these bits aren't cleared. The activation objects must have actually
69223:      * been put, though.
69223:      */
69223:     JS_ASSERT_IF(flags_ & HAS_CALL_OBJ, callObj().getPrivate() == NULL);
69223:     JS_ASSERT_IF(flags_ & HAS_ARGS_OBJ, argsObj().getPrivate() == NULL);
69223: 
69223:     flags_ &= FUNCTION |
69223:               OVERFLOW_ARGS |
69223:               HAS_PREVPC |
69223:               UNDERFLOW_ARGS;
69223: 
69223:     JS_ASSERT(exec.fun == callee().getFunctionPrivate());
69223:     scopeChain_ = callee().getParent();
69223: }
69223: 
69223: inline void
69223: StackFrame::initCallFrameCallerHalf(JSContext *cx, uint32 flagsArg,
69223:                                     void *ncode)
69223: {
69223:     JS_ASSERT((flagsArg & ~(CONSTRUCTING |
69223:                             FUNCTION |
69223:                             OVERFLOW_ARGS |
69223:                             UNDERFLOW_ARGS)) == 0);
69223: 
69223:     flags_ = FUNCTION | flagsArg;
69223:     prev_ = cx->fp();
69223:     ncode_ = ncode;
69223: }
69223: 
69223: /*
70607:  * The "early prologue" refers to either the fast path or arity check path up
70607:  * to the "late prologue".
69223:  */
69223: inline void
69223: StackFrame::initCallFrameEarlyPrologue(JSFunction *fun, uint32 nactual)
69223: {
69223:     exec.fun = fun;
69223:     if (flags_ & (OVERFLOW_ARGS | UNDERFLOW_ARGS))
69223:         args.nactual = nactual;
69223: }
69223: 
69223: /*
70607:  * The "late prologue" (in generatePrologue) extends from the join point of the
70607:  * fast path and arity check to where the call object is (possibly) created.
69223:  */
70607: inline bool
70607: StackFrame::initCallFrameLatePrologue(JSContext *cx, StackFrame *fp, Value **limit)
69223: {
70607:     uintN nvals = script()->nslots + VALUES_PER_STACK_FRAME;
70607:     Value *required = (Value *)this + nvals;
70607:     if (required >= *limit) {
70607:         ContextStack &stack = cx->stack;
70607:         if (!stack.space().bumpLimit(NULL, fp, slots(), nvals, limit)) {
70607:             stack.popFrameAfterOverflow();
70607:             js_ReportOverRecursed(cx);
70607:             return false;
70607:         }
70607:     }
70607: 
69223:     SetValueRangeToUndefined(slots(), script()->nfixed);
70607:     return true;
69223: }
69223: 
69223: inline void
69223: StackFrame::initEvalFrame(JSContext *cx, JSScript *script, StackFrame *prev, uint32 flagsArg)
69223: {
69223:     JS_ASSERT(flagsArg & EVAL);
69223:     JS_ASSERT((flagsArg & ~(EVAL | DEBUGGER)) == 0);
69223:     JS_ASSERT(prev->isScriptFrame());
69223: 
69223:     /* Copy (callee, thisv). */
69223:     Value *dstvp = (Value *)this - 2;
69223:     Value *srcvp = prev->hasArgs()
69223:                    ? prev->formalArgs() - 2
69223:                    : (Value *)prev - 2;
69223:     dstvp[0] = srcvp[0];
69223:     dstvp[1] = srcvp[1];
69223:     JS_ASSERT_IF(prev->isFunctionFrame(),
69223:                  dstvp[0].toObject().isFunction());
69223: 
69223:     /* Initialize stack frame members. */
69223:     flags_ = flagsArg | HAS_PREVPC | HAS_SCOPECHAIN |
69223:              (prev->flags_ & (FUNCTION | GLOBAL));
69223:     if (isFunctionFrame()) {
69223:         exec = prev->exec;
69223:         args.script = script;
69223:     } else {
69223:         exec.script = script;
69223:     }
69223: 
69223:     scopeChain_ = &prev->scopeChain();
69223:     prev_ = prev;
69223:     prevpc_ = prev->pc(cx);
69223:     JS_ASSERT(!hasImacropc());
69223:     JS_ASSERT(!hasHookData());
69223:     setAnnotation(prev->annotation());
69223: }
69223: 
69223: inline void
69704: StackFrame::initGlobalFrame(JSScript *script, JSObject &chain, StackFrame *prev, uint32 flagsArg)
69223: {
69223:     JS_ASSERT((flagsArg & ~(EVAL | DEBUGGER)) == 0);
69223: 
69223:     /* Initialize (callee, thisv). */
69223:     Value *vp = (Value *)this - 2;
69223:     vp[0].setUndefined();
69223:     vp[1].setUndefined();  /* Set after frame pushed using thisObject */
69223: 
69223:     /* Initialize stack frame members. */
69223:     flags_ = flagsArg | GLOBAL | HAS_PREVPC | HAS_SCOPECHAIN;
69223:     exec.script = script;
69223:     args.script = (JSScript *)0xbad;
69223:     scopeChain_ = &chain;
69704:     prev_ = prev;
69223:     JS_ASSERT(!hasImacropc());
69223:     JS_ASSERT(!hasHookData());
69223:     JS_ASSERT(annotation() == NULL);
69223: }
69223: 
69223: inline void
69223: StackFrame::initDummyFrame(JSContext *cx, JSObject &chain)
69223: {
69223:     PodZero(this);
69223:     flags_ = DUMMY | HAS_PREVPC | HAS_SCOPECHAIN;
69223:     initPrev(cx);
69223:     chain.isGlobal();
69223:     setScopeChainNoCallObj(chain);
69223: }
69223: 
69223: inline void
69223: StackFrame::stealFrameAndSlots(Value *vp, StackFrame *otherfp,
69223:                                Value *othervp, Value *othersp)
69223: {
69223:     JS_ASSERT(vp == (Value *)this - (otherfp->formalArgsEnd() - othervp));
69223:     JS_ASSERT(othervp == otherfp->actualArgs() - 2);
69223:     JS_ASSERT(othersp >= otherfp->slots());
69223:     JS_ASSERT(othersp <= otherfp->base() + otherfp->numSlots());
69223: 
69223:     PodCopy(vp, othervp, othersp - othervp);
69223:     JS_ASSERT(vp == this->actualArgs() - 2);
69223: 
69223:     /* Catch bad-touching of non-canonical args (e.g., generator_trace). */
69223:     if (otherfp->hasOverflowArgs())
69223:         Debug_SetValueRangeToCrashOnTouch(othervp, othervp + 2 + otherfp->numFormalArgs());
69223: 
69223:     /*
69223:      * Repoint Call, Arguments, Block and With objects to the new live frame.
69223:      * Call and Arguments are done directly because we have pointers to them.
69223:      * Block and With objects are done indirectly through 'liveFrame'. See
69223:      * js_LiveFrameToFloating comment in jsiter.h.
69223:      */
69223:     if (hasCallObj()) {
69223:         JSObject &obj = callObj();
69223:         obj.setPrivate(this);
69223:         otherfp->flags_ &= ~HAS_CALL_OBJ;
69223:         if (js_IsNamedLambda(fun())) {
69223:             JSObject *env = obj.getParent();
69223:             JS_ASSERT(env->getClass() == &js_DeclEnvClass);
69223:             env->setPrivate(this);
69223:         }
69223:     }
69223:     if (hasArgsObj()) {
69827:         ArgumentsObject &argsobj = argsObj();
69827:         if (argsobj.isNormalArguments())
69827:             argsobj.setPrivate(this);
69223:         else
69827:             JS_ASSERT(!argsobj.getPrivate());
69223:         otherfp->flags_ &= ~HAS_ARGS_OBJ;
69223:     }
69223: }
69223: 
69223: inline Value &
69223: StackFrame::canonicalActualArg(uintN i) const
69223: {
69223:     if (i < numFormalArgs())
69223:         return formalArg(i);
69223:     JS_ASSERT(i < numActualArgs());
69223:     return actualArgs()[i];
69223: }
69223: 
69223: template <class Op>
69223: inline bool
70319: StackFrame::forEachCanonicalActualArg(Op op, uintN start /* = 0 */, uintN count /* = uintN(-1) */)
69223: {
69223:     uintN nformal = fun()->nargs;
70319:     JS_ASSERT(start <= nformal);
70319: 
69223:     Value *formals = formalArgsEnd() - nformal;
69223:     uintN nactual = numActualArgs();
70319:     if (count == uintN(-1))
70319:         count = nactual - start;
70319: 
70319:     uintN end = start + count;
70319:     JS_ASSERT(end >= start);
70319:     JS_ASSERT(end <= nactual);
70319: 
70319:     if (end <= nformal) {
70319:         Value *p = formals + start;
70319:         for (; start < end; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
69223:     } else {
70319:         for (Value *p = formals + start; start < nformal; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
70319:         JS_ASSERT(start >= nformal);
70319:         Value *actuals = formals - (nactual + 2) + start;
70319:         for (Value *p = actuals; start < end; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
69223:     }
69223:     return true;
69223: }
69223: 
69223: template <class Op>
69223: inline bool
69223: StackFrame::forEachFormalArg(Op op)
69223: {
69223:     Value *formals = formalArgsEnd() - fun()->nargs;
69223:     Value *formalsEnd = formalArgsEnd();
69223:     uintN i = 0;
69223:     for (Value *p = formals; p != formalsEnd; ++p, ++i) {
69223:         if (!op(i, p))
69223:             return false;
69223:     }
69223:     return true;
69223: }
69223: 
69223: struct CopyTo
69223: {
69223:     Value *dst;
69223:     CopyTo(Value *dst) : dst(dst) {}
69223:     bool operator()(uintN, Value *src) {
69223:         *dst++ = *src;
69223:         return true;
69223:     }
69223: };
69223: 
69223: JS_ALWAYS_INLINE void
69223: StackFrame::clearMissingArgs()
69223: {
69223:     if (flags_ & UNDERFLOW_ARGS)
69223:         SetValueRangeToUndefined(formalArgs() + numActualArgs(), formalArgsEnd());
69223: }
69223: 
69223: inline uintN
69223: StackFrame::numActualArgs() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     if (JS_UNLIKELY(flags_ & (OVERFLOW_ARGS | UNDERFLOW_ARGS)))
69827:         return hasArgsObj() ? argsObj().initialLength() : args.nactual;
69223:     return numFormalArgs();
69223: }
69223: 
69223: inline Value *
69223: StackFrame::actualArgs() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     Value *argv = formalArgs();
69223:     if (JS_UNLIKELY(flags_ & OVERFLOW_ARGS)) {
69827:         uintN nactual = hasArgsObj() ? argsObj().initialLength() : args.nactual;
69223:         return argv - (2 + nactual);
69223:     }
69223:     return argv;
69223: }
69223: 
69223: inline Value *
69223: StackFrame::actualArgsEnd() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     if (JS_UNLIKELY(flags_ & OVERFLOW_ARGS))
69223:         return formalArgs() - 2;
69223:     return formalArgs() + numActualArgs();
69223: }
69223: 
69223: inline void
69827: StackFrame::setArgsObj(ArgumentsObject &obj)
69223: {
69223:     JS_ASSERT_IF(hasArgsObj(), &obj == args.obj);
69827:     JS_ASSERT_IF(!hasArgsObj(), numActualArgs() == obj.initialLength());
69223:     args.obj = &obj;
69223:     flags_ |= HAS_ARGS_OBJ;
69223: }
69223: 
69223: inline void
69223: StackFrame::setScopeChainNoCallObj(JSObject &obj)
69223: {
69223: #ifdef DEBUG
69223:     JS_ASSERT(&obj != NULL);
69223:     if (&obj != sInvalidScopeChain) {
69223:         if (hasCallObj()) {
69223:             JSObject *pobj = &obj;
69223:             while (pobj && pobj->getPrivate() != this)
69223:                 pobj = pobj->getParent();
69223:             JS_ASSERT(pobj);
69223:         } else {
69223:             for (JSObject *pobj = &obj; pobj; pobj = pobj->getParent())
69223:                 JS_ASSERT_IF(pobj->isCall(), pobj->getPrivate() != this);
69223:         }
69223:     }
69223: #endif
69223:     scopeChain_ = &obj;
69223:     flags_ |= HAS_SCOPECHAIN;
69223: }
69223: 
69223: inline void
69223: StackFrame::setScopeChainWithOwnCallObj(JSObject &obj)
69223: {
69223:     JS_ASSERT(&obj != NULL);
69223:     JS_ASSERT(!hasCallObj() && obj.isCall() && obj.getPrivate() == this);
69223:     scopeChain_ = &obj;
69223:     flags_ |= HAS_SCOPECHAIN | HAS_CALL_OBJ;
69223: }
69223: 
69223: inline JSObject &
69223: StackFrame::callObj() const
69223: {
69223:     JS_ASSERT_IF(isNonEvalFunctionFrame() || isStrictEvalFrame(), hasCallObj());
69223: 
69223:     JSObject *pobj = &scopeChain();
69223:     while (JS_UNLIKELY(pobj->getClass() != &js_CallClass)) {
69223:         JS_ASSERT(IsCacheableNonGlobalScope(pobj) || pobj->isWith());
69223:         pobj = pobj->getParent();
69223:     }
69223:     return *pobj;
69223: }
69223: 
69223: inline void
69223: StackFrame::putActivationObjects()
69223: {
69223:     if (flags_ & (HAS_ARGS_OBJ | HAS_CALL_OBJ)) {
69223:         /* NB: there is an ordering dependency here. */
69223:         if (hasCallObj())
69223:             js_PutCallObject(this);
69223:         else if (hasArgsObj())
69223:             js_PutArgsObject(this);
69223:     }
69223: }
69223: 
69223: inline void
69223: StackFrame::markActivationObjectsAsPut()
69223: {
69223:     if (flags_ & (HAS_ARGS_OBJ | HAS_CALL_OBJ)) {
69223:         if (hasArgsObj() && !argsObj().getPrivate()) {
69827:             args.nactual = args.obj->initialLength();
69223:             flags_ &= ~HAS_ARGS_OBJ;
69223:         }
69223:         if (hasCallObj() && !callObj().getPrivate()) {
69223:             /*
69223:              * For function frames, the call object may or may not have have an
69223:              * enclosing DeclEnv object, so we use the callee's parent, since
69223:              * it was the initial scope chain. For global (strict) eval frames,
69223:              * there is no calle, but the call object's parent is the initial
69223:              * scope chain.
69223:              */
69223:             scopeChain_ = isFunctionFrame()
69223:                           ? callee().getParent()
69223:                           : scopeChain_->getParent();
69223:             flags_ &= ~HAS_CALL_OBJ;
69223:         }
69223:     }
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: JS_ALWAYS_INLINE void
69223: StackSpace::pushOverride(Value *top, StackOverride *prev)
69223: {
69223:     *prev = override_;
69223: 
69223:     override_.top = top;
69223: #ifdef DEBUG
69223:     override_.seg = seg_;
69223:     override_.frame = seg_->currentFrameOrNull();
69223: #endif
69223: 
69223:     JS_ASSERT(prev->top < override_.top);
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: StackSpace::popOverride(const StackOverride &prev)
69223: {
69223:     JS_ASSERT(prev.top < override_.top);
69223: 
69223:     JS_ASSERT_IF(seg_->empty(), override_.frame == NULL);
69223:     JS_ASSERT_IF(!seg_->empty(), override_.frame == seg_->currentFrame());
69223:     JS_ASSERT(override_.seg == seg_);
69223: 
69223:     override_ = prev;
69223: }
69223: 
69223: JS_ALWAYS_INLINE Value *
69223: StackSpace::activeFirstUnused() const
69223: {
69223:     JS_ASSERT(seg_->isActive());
69223: 
69223:     Value *max = Max(seg_->stack().regs().sp, override_.top);
69223:     JS_ASSERT(max == firstUnused());
69223:     return max;
69223: }
69223: 
70320: #ifdef JS_TRACER
69223: JS_ALWAYS_INLINE bool
69223: StackSpace::ensureEnoughSpaceToEnterTrace()
69223: {
69223:     ptrdiff_t needed = TraceNativeStorage::MAX_NATIVE_STACK_SLOTS +
69223:                        TraceNativeStorage::MAX_CALL_STACK_ENTRIES * VALUES_PER_STACK_FRAME;
69223: #ifdef XP_WIN
69223:     return ensureSpace(NULL, firstUnused(), needed);
69223: #else
69223:     return end_ - firstUnused() > needed;
69223: #endif
69223: }
70320: #endif
69223: 
69223: STATIC_POSTCONDITION(!return || ubound(from) >= nvals)
69223: JS_ALWAYS_INLINE bool
69223: StackSpace::ensureSpace(JSContext *maybecx, Value *from, ptrdiff_t nvals) const
69223: {
69223:     JS_ASSERT(from >= firstUnused());
69223: #ifdef XP_WIN
69223:     JS_ASSERT(from <= commitEnd_);
69223:     if (commitEnd_ - from < nvals)
69223:         return bumpCommit(maybecx, from, nvals);
69223:     return true;
69223: #else
69223:     if (end_ - from < nvals) {
69223:         js_ReportOutOfScriptQuota(maybecx);
69223:         return false;
69223:     }
69223:     return true;
69223: #endif
69223: }
69223: 
69223: inline Value *
69223: StackSpace::getStackLimit(JSContext *cx)
69223: {
69223:     FrameRegs &regs = cx->regs();
69223:     uintN minSpace = regs.fp()->numSlots() + VALUES_PER_STACK_FRAME;
69223:     Value *sp = regs.sp;
69223:     Value *required = sp + minSpace;
69223:     Value *desired = sp + STACK_QUOTA;
69223: #ifdef XP_WIN
69223:     if (required <= commitEnd_)
69223:         return Min(commitEnd_, desired);
69223:     if (!bumpCommit(cx, sp, minSpace))
69223:         return NULL;
69223:     JS_ASSERT(commitEnd_ >= required);
69223:     return commitEnd_;
69223: #else
69223:     if (required <= end_)
69223:         return Min(end_, desired);
69223:     js_ReportOutOfScriptQuota(cx);
69223:     return NULL;
69223: #endif
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: JS_ALWAYS_INLINE bool
69223: ContextStack::isCurrentAndActive() const
69223: {
69223:     assertSegmentsInSync();
69223:     return seg_ && seg_->isActive() && seg_ == space().currentSegment();
69223: }
69223: 
69223: namespace detail {
69223: 
69223: struct OOMCheck
69223: {
69223:     JS_ALWAYS_INLINE bool
69223:     operator()(JSContext *cx, StackSpace &space, Value *from, uintN nvals)
69223:     {
69223:         return space.ensureSpace(cx, from, nvals);
69223:     }
69223: };
69223: 
69223: struct LimitCheck
69223: {
69223:     StackFrame *base;
69223:     Value **limit;
69223: 
69223:     LimitCheck(StackFrame *base, Value **limit) : base(base), limit(limit) {}
69223: 
69223:     JS_ALWAYS_INLINE bool
69223:     operator()(JSContext *cx, StackSpace &space, Value *from, uintN nvals)
69223:     {
69223:         /*
69223:          * Include an extra sizeof(StackFrame) to satisfy the method-jit
69223:          * stackLimit invariant.
69223:          */
69223:         nvals += VALUES_PER_STACK_FRAME;
69223: 
69223:         JS_ASSERT(from < *limit);
69223:         if (*limit - from >= ptrdiff_t(nvals))
69223:             return true;
69223:         return space.bumpLimitWithinQuota(cx, base, from, nvals, limit);
69223:     }
69223: };
69223: 
69223: }  /* namespace detail */
69223: 
69223: template <class Check>
69223: JS_ALWAYS_INLINE StackFrame *
69223: ContextStack::getCallFrame(JSContext *cx, Value *firstUnused, uintN nactual,
69223:                            JSFunction *fun, JSScript *script, uint32 *flags,
69223:                            Check check) const
69223: {
69223:     JS_ASSERT(fun->script() == script);
69223:     JS_ASSERT(space().firstUnused() == firstUnused);
69223: 
69223:     uintN nvals = VALUES_PER_STACK_FRAME + script->nslots;
69223:     uintN nformal = fun->nargs;
69223: 
69223:     /* Maintain layout invariant: &formalArgs[0] == ((Value *)fp) - nformal. */
69223: 
69223:     if (nactual == nformal) {
69223:         if (JS_UNLIKELY(!check(cx, space(), firstUnused, nvals)))
69223:             return NULL;
69223:         return reinterpret_cast<StackFrame *>(firstUnused);
69223:     }
69223: 
69223:     if (nactual < nformal) {
69223:         *flags |= StackFrame::UNDERFLOW_ARGS;
69223:         uintN nmissing = nformal - nactual;
69223:         if (JS_UNLIKELY(!check(cx, space(), firstUnused, nmissing + nvals)))
69223:             return NULL;
69223:         SetValueRangeToUndefined(firstUnused, nmissing);
69223:         return reinterpret_cast<StackFrame *>(firstUnused + nmissing);
69223:     }
69223: 
69223:     *flags |= StackFrame::OVERFLOW_ARGS;
69223:     uintN ncopy = 2 + nformal;
69223:     if (JS_UNLIKELY(!check(cx, space(), firstUnused, ncopy + nvals)))
69223:         return NULL;
69223: 
69223:     Value *dst = firstUnused;
69223:     Value *src = firstUnused - (2 + nactual);
69223:     PodCopy(dst, src, ncopy);
69223:     Debug_SetValueRangeToCrashOnTouch(src, ncopy);
69223:     return reinterpret_cast<StackFrame *>(firstUnused + ncopy);
69223: }
69223: 
69223: JS_ALWAYS_INLINE StackFrame *
69223: ContextStack::getInlineFrame(JSContext *cx, Value *sp, uintN nactual,
69223:                              JSFunction *fun, JSScript *script, uint32 *flags) const
69223: {
69223:     JS_ASSERT(isCurrentAndActive());
69223:     JS_ASSERT(cx->regs().sp == sp);
69223: 
69223:     return getCallFrame(cx, sp, nactual, fun, script, flags, detail::OOMCheck());
69223: }
69223: 
69223: JS_ALWAYS_INLINE StackFrame *
69223: ContextStack::getInlineFrameWithinLimit(JSContext *cx, Value *sp, uintN nactual,
69223:                                         JSFunction *fun, JSScript *script, uint32 *flags,
69223:                                         StackFrame *fp, Value **limit) const
69223: {
69223:     JS_ASSERT(isCurrentAndActive());
69223:     JS_ASSERT(cx->regs().sp == sp);
69223: 
69223:     return getCallFrame(cx, sp, nactual, fun, script, flags, detail::LimitCheck(fp, limit));
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: ContextStack::pushInlineFrame(JSScript *script, StackFrame *fp, FrameRegs &regs)
69223: {
69223:     JS_ASSERT(isCurrentAndActive());
69223:     JS_ASSERT(regs_ == &regs && script == fp->script());
69223: 
69223:     regs.prepareToRun(fp, script);
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: ContextStack::popInlineFrame()
69223: {
69223:     JS_ASSERT(isCurrentAndActive());
69223: 
69223:     StackFrame *fp = regs_->fp();
69223:     fp->putActivationObjects();
69223: 
69223:     Value *newsp = fp->actualArgs() - 1;
69223:     JS_ASSERT(newsp >= fp->prev()->base());
69223: 
69223:     newsp[-1] = fp->returnValue();
69223:     regs_->popFrame(newsp);
69223: }
69223: 
70607: inline void
70607: ContextStack::popFrameAfterOverflow()
70607: {
70607:     /* Restore the regs to what they were on entry to JSOP_CALL. */
70607:     regs_->popFrame(regs_->fp()->actualArgsEnd());
70607: }
70607: 
69223: JS_ALWAYS_INLINE bool
69223: ContextStack::pushInvokeArgs(JSContext *cx, uintN argc, InvokeArgsGuard *argsGuard)
69223: {
69223:     if (!isCurrentAndActive())
69223:         return pushInvokeArgsSlow(cx, argc, argsGuard);
69223: 
69223:     Value *start = space().activeFirstUnused();
69223:     uintN vplen = 2 + argc;
69223:     if (!space().ensureSpace(cx, start, vplen))
69223:         return false;
69223: 
69223:     Value *vp = start;
69223:     ImplicitCast<CallArgs>(*argsGuard) = CallArgsFromVp(argc, vp);
69223: 
69223:     /*
69223:      * Use stack override to root vp until the frame is pushed. Don't need to
69223:      * MakeRangeGCSafe: the VM stack is conservatively marked.
69223:      */
69223:     space().pushOverride(vp + vplen, &argsGuard->prevOverride_);
69223: 
69223:     argsGuard->stack_ = this;
69223:     return true;
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: ContextStack::popInvokeArgs(const InvokeArgsGuard &argsGuard)
69223: {
69223:     if (argsGuard.seg_) {
69223:         popInvokeArgsSlow(argsGuard);
69223:         return;
69223:     }
69223: 
69223:     JS_ASSERT(isCurrentAndActive());
69223:     space().popOverride(argsGuard.prevOverride_);
69223: }
69223: 
69223: JS_ALWAYS_INLINE
69223: InvokeArgsGuard::~InvokeArgsGuard()
69223: {
69223:     if (JS_UNLIKELY(!pushed()))
69223:         return;
69223:     stack_->popInvokeArgs(*this);
69223: }
69223: 
69223: JS_ALWAYS_INLINE StackFrame *
69223: ContextStack::getInvokeFrame(JSContext *cx, const CallArgs &args,
69223:                              JSFunction *fun, JSScript *script,
69223:                              uint32 *flags, InvokeFrameGuard *frameGuard) const
69223: {
69223:     uintN argc = args.argc();
69223:     Value *start = args.argv() + argc;
69223:     JS_ASSERT(start == space().firstUnused());
69223:     StackFrame *fp = getCallFrame(cx, start, argc, fun, script, flags, detail::OOMCheck());
69223:     if (!fp)
69223:         return NULL;
69223: 
69223:     frameGuard->regs_.prepareToRun(fp, script);
69223:     return fp;
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: ContextStack::pushInvokeFrame(const CallArgs &args, InvokeFrameGuard *frameGuard)
69223: {
69223:     JS_ASSERT(space().firstUnused() == args.argv() + args.argc());
69223: 
69223:     if (JS_UNLIKELY(space().seg_->empty())) {
69223:         pushInvokeFrameSlow(frameGuard);
69223:         return;
69223:     }
69223: 
69223:     frameGuard->prevRegs_ = regs_;
69223:     regs_ = &frameGuard->regs_;
69223:     JS_ASSERT(isCurrentAndActive());
69223: 
69223:     frameGuard->stack_ = this;
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: ContextStack::popInvokeFrame(const InvokeFrameGuard &frameGuard)
69223: {
69223:     JS_ASSERT(isCurrentAndActive());
69223:     JS_ASSERT(&frameGuard.regs_ == regs_);
69223: 
69223:     if (JS_UNLIKELY(seg_->initialFrame() == regs_->fp())) {
69223:         popInvokeFrameSlow(frameGuard);
69223:         return;
69223:     }
69223: 
69223:     regs_->fp()->putActivationObjects();
69223:     regs_ = frameGuard.prevRegs_;
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
69223: InvokeFrameGuard::pop()
69223: {
69223:     JS_ASSERT(pushed());
69223:     stack_->popInvokeFrame(*this);
69223:     stack_ = NULL;
69223: }
69223: 
69223: JS_ALWAYS_INLINE
69223: InvokeFrameGuard::~InvokeFrameGuard()
69223: {
69223:     if (pushed())
69223:         pop();
69223: }
69223: 
69223: JS_ALWAYS_INLINE JSObject &
69223: ContextStack::currentVarObj() const
69223: {
69223:     if (regs_->fp()->hasCallObj())
69223:         return regs_->fp()->callObj();
69223:     return seg_->initialVarObj();
69223: }
69223: 
69223: inline StackFrame *
69223: ContextStack::findFrameAtLevel(uintN targetLevel) const
69223: {
69223:     StackFrame *fp = regs_->fp();
69223:     while (true) {
69223:         JS_ASSERT(fp && fp->isScriptFrame());
69223:         if (fp->script()->staticLevel == targetLevel)
69223:             break;
69223:         fp = fp->prev();
69223:     }
69223:     return fp;
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: inline
69223: FrameRegsIter::FrameRegsIter(JSContext *cx)
69223:   : cx_(cx)
69223: {
69223:     seg_ = cx->stack.currentSegment();
69223:     if (JS_UNLIKELY(!seg_ || !seg_->isActive())) {
69223:         initSlow();
69223:         return;
69223:     }
69223:     fp_ = cx->fp();
69223:     sp_ = cx->regs().sp;
69223:     pc_ = cx->regs().pc;
69223:     return;
69223: }
69223: 
69223: inline FrameRegsIter &
69223: FrameRegsIter::operator++()
69223: {
69223:     StackFrame *oldfp = fp_;
69223:     fp_ = fp_->prev();
69223:     if (!fp_)
69223:         return *this;
69223: 
69223:     if (JS_UNLIKELY(oldfp == seg_->initialFrame())) {
69223:         incSlow(oldfp);
69223:         return *this;
69223:     }
69223: 
69223:     pc_ = oldfp->prevpc();
69223:     sp_ = oldfp->formalArgsEnd();
69223:     return *this;
69223: }
69223: 
70319: namespace detail {
70319: 
70319: struct STATIC_SKIP_INFERENCE CopyNonHoleArgsTo
70319: {
70319:     CopyNonHoleArgsTo(ArgumentsObject *argsobj, Value *dst) : argsobj(*argsobj), dst(dst) {}
70319:     ArgumentsObject &argsobj;
70319:     Value *dst;
70319:     bool operator()(uint32 argi, Value *src) {
70319:         if (argsobj.element(argi).isMagic(JS_ARGS_HOLE))
70319:             return false;
70319:         *dst++ = *src;
70319:         return true;
70319:     }
70319: };
70319: 
70319: } /* namespace detail */
70319: 
70319: inline bool
70319: ArgumentsObject::getElement(uint32 i, Value *vp)
70319: {
70319:     if (i >= initialLength())
70319:         return false;
70319: 
70319:     *vp = element(i);
70319: 
70319:     /*
70319:      * If the argument was overwritten, it could be in any object slot, so we
70319:      * can't optimize.
70319:      */
70319:     if (vp->isMagic(JS_ARGS_HOLE))
70319:         return false;
70319: 
70319:     /*
70319:      * If this arguments object was created on trace the actual argument value
70319:      * could be in a register or something, so we can't optimize.
70319:      */
70319:     StackFrame *fp = reinterpret_cast<StackFrame *>(getPrivate());
70319:     if (fp == JS_ARGUMENTS_OBJECT_ON_TRACE)
70319:         return false;
70319: 
70319:     /*
70319:      * If this arguments object has an associated stack frame, that contains
70319:      * the canonical argument value.  Note that strict arguments objects do not
70319:      * alias named arguments and never have a stack frame.
70319:      */
70319:     JS_ASSERT_IF(isStrictArguments(), !fp);
70319:     if (fp)
70319:         *vp = fp->canonicalActualArg(i);
70319:     return true;
70319: }
70319: 
70319: inline bool
70319: ArgumentsObject::getElements(uint32 start, uint32 count, Value *vp)
70319: {
70319:     JS_ASSERT(start + count >= start);
70319: 
70319:     uint32 length = initialLength();
70319:     if (start > length || start + count > length)
70319:         return false;
70319: 
70319:     StackFrame *fp = reinterpret_cast<StackFrame *>(getPrivate());
70319: 
70319:     /* If there's no stack frame for this, argument values are in elements(). */
70319:     if (!fp) {
70319:         Value *srcbeg = elements() + start;
70319:         Value *srcend = srcbeg + count;
70319:         for (Value *dst = vp, *src = srcbeg; src < srcend; ++dst, ++src) {
70319:             if (src->isMagic(JS_ARGS_HOLE))
70319:                 return false;
70319:             *dst = *src;
70319:         }
70319:         return true;
70319:     }
70319: 
70319:     /* If we're on trace, there's no canonical location for elements: fail. */
70319:     if (fp == JS_ARGUMENTS_OBJECT_ON_TRACE)
70319:         return false;
70319: 
70319:     /* Otherwise, element values are on the stack. */
70319:     JS_ASSERT(fp->numActualArgs() <= JS_ARGS_LENGTH_MAX);
70319:     return fp->forEachCanonicalActualArg(detail::CopyNonHoleArgsTo(this, vp), start, count);
70319: }
70319: 
69223: } /* namespace js */
69223: 
69223: #endif /* Stack_inl_h__ */
