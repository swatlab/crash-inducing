     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 94984: #include "nsAccessibilityService.h"
 80467: 
     1: // NOTE: alphabetically ordered
 95352: #include "Accessible-inl.h"
 96920: #include "ApplicationAccessibleWrap.h"
 94984: #include "ARIAGridAccessibleWrap.h"
 94984: #ifdef MOZ_ACCESSIBILITY_ATK
 94984: #include "AtkSocketAccessible.h"
 94984: #endif
100057: #include "DocAccessible-inl.h"
 94984: #include "FocusManager.h"
101261: #include "HTMLCanvasAccessible.h"
100129: #include "HTMLElementAccessibles.h"
101055: #include "HTMLImageMapAccessible.h"
101056: #include "HTMLLinkAccessible.h"
 97985: #include "HTMLListAccessible.h"
101260: #include "HTMLSelectAccessible.h"
101616: #include "HTMLTableAccessibleWrap.h"
 99901: #include "HyperTextAccessibleWrap.h"
 89309: #include "nsAccessiblePivot.h"
 20536: #include "nsAccUtils.h"
 94984: #include "nsARIAMap.h"
 94984: #include "nsIAccessibleProvider.h"
 94984: #include "nsXFormsFormControlsAccessible.h"
 94984: #include "nsXFormsWidgetsAccessible.h"
 94984: #include "OuterDocAccessible.h"
 87094: #include "Role.h"
 97643: #include "RootAccessibleWrap.h"
 67790: #include "States.h"
 76374: #include "Statistics.h"
 94984: #ifdef XP_WIN
 94984: #include "nsHTMLWin32ObjectAccessible.h"
 94984: #endif
103131: #include "TextLeafAccessibleWrap.h"
 40461: 
 99203: #ifdef DEBUG
 99203: #include "Logging.h"
 99203: #endif
 99203: 
105954: #ifdef MOZ_CRASHREPORTER
105954: #include "nsExceptionHandler.h"
105954: #endif
105954: 
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMHTMLObjectElement.h"
     1: #include "nsIDOMXULElement.h"
 69187: #include "nsImageFrame.h"
     1: #include "nsIObserverService.h"
 79788: #include "nsLayoutUtils.h"
 70007: #include "nsNPAPIPluginInstance.h"
     1: #include "nsObjectFrame.h"
 94984: #include "mozilla/FunctionTimer.h"
 94984: #include "mozilla/dom/Element.h"
102366: #include "mozilla/Preferences.h"
 41540: #include "mozilla/Services.h"
 94984: #include "mozilla/Util.h"
     1: 
     1: #ifdef MOZ_XUL
101616: #include "XULAlertAccessible.h"
101616: #include "XULColorPickerAccessible.h"
101616: #include "XULComboboxAccessible.h"
101616: #include "XULElementAccessibles.h"
101532: #include "XULFormControlAccessible.h"
101616: #include "XULListboxAccessibleWrap.h"
101616: #include "XULMenuAccessibleWrap.h"
101616: #include "XULSliderAccessible.h"
101616: #include "XULTabAccessible.h"
101616: #include "XULTreeGridAccessibleWrap.h"
     1: #endif
     1: 
 80467: using namespace mozilla;
 74618: using namespace mozilla::a11y;
 74618: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // nsAccessibilityService
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: 
     1: nsAccessibilityService *nsAccessibilityService::gAccessibilityService = nsnull;
 79445: bool nsAccessibilityService::gIsShutdown = true;
     1: 
 79384: nsAccessibilityService::nsAccessibilityService() :
 79384:   nsAccDocManager(), FocusManager()
     1: {
 42480:   NS_TIME_FUNCTION;
     1: }
     1: 
     1: nsAccessibilityService::~nsAccessibilityService()
     1: {
 30820:   NS_ASSERTION(gIsShutdown, "Accessibility wasn't shutdown!");
 30820:   gAccessibilityService = nsnull;
     1: }
     1: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsISupports
     1: 
 43310: NS_IMPL_ISUPPORTS_INHERITED3(nsAccessibilityService,
 43310:                              nsAccDocManager,
 43310:                              nsIAccessibilityService,
 43310:                              nsIAccessibleRetrieval,
 43310:                              nsIObserver)
 38359: 
 38359: ////////////////////////////////////////////////////////////////////////////////
     1: // nsIObserver
     1: 
     1: NS_IMETHODIMP
     1: nsAccessibilityService::Observe(nsISupports *aSubject, const char *aTopic,
     1:                          const PRUnichar *aData)
     1: {
 43310:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))
 43310:     Shutdown();
 30820: 
     1:   return NS_OK;
     1: }
     1: 
 38359: // nsIAccessibilityService
 41476: void
 61201: nsAccessibilityService::NotifyOfAnchorJumpTo(nsIContent* aTargetNode)
 34455: {
 61201:   nsIDocument* documentNode = aTargetNode->GetCurrentDoc();
 61201:   if (documentNode) {
 99568:     DocAccessible* document = GetDocAccessible(documentNode);
 61201:     if (document)
 80036:       document->SetAnchorJump(aTargetNode);
 61201:   }
 34455: }
 34455: 
 38359: // nsIAccessibilityService
 54519: void
 21255: nsAccessibilityService::FireAccessibleEvent(PRUint32 aEvent,
 99648:                                             Accessible* aTarget)
 21255: {
 54519:   nsEventShell::FireEvent(aEvent, aTarget);
 21255: }
 21255: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // nsIAccessibilityService
     1: 
 99648: Accessible*
 54519: nsAccessibilityService::GetRootDocumentAccessible(nsIPresShell* aPresShell,
 79445:                                                   bool aCanCreate)
 54519: {
 54519:   nsIDocument* documentNode = aPresShell->GetDocument();
 54519:   if (documentNode) {
 54519:     nsCOMPtr<nsISupports> container = documentNode->GetContainer();
 54519:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
 54519:     if (treeItem) {
 54519:       nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
 54519:       treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
 54519:       if (treeItem != rootTreeItem) {
 54519:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(rootTreeItem));
 54519:         nsCOMPtr<nsIPresShell> presShell;
 54519:         docShell->GetPresShell(getter_AddRefs(presShell));
 54519:         documentNode = presShell->GetDocument();
 54519:       }
 54519: 
 54519:       return aCanCreate ?
 54519:         GetDocAccessible(documentNode) : GetDocAccessibleFromCache(documentNode);
 54519:     }
 54519:   }
 54519:   return nsnull;
 54519: }
 54519: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateOuterDocAccessible(nsIContent* aContent,
 46338:                                                  nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
 95565:     new OuterDocAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLButtonAccessible(nsIContent* aContent,
 46338:                                                    nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
 95565:     new HTMLButtonAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLLIAccessible(nsIContent* aContent,
 55763:                                                nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
 97985:     new HTMLLIAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
 28316: }
 28316: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHyperTextAccessible(nsIContent* aContent,
 46338:                                                   nsIPresShell* aPresShell)
 46338: {
 99648:   Accessible* accessible =
 99901:     new HyperTextAccessibleWrap(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLCheckboxAccessible(nsIContent* aContent,
 46338:                                                      nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
 95565:     new HTMLCheckboxAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLComboboxAccessible(nsIContent* aContent,
 46338:                                                      nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
101260:     new HTMLComboboxAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 82770: nsAccessibilityService::CreateHTMLCanvasAccessible(nsIContent* aContent,
 82770:                                                    nsIPresShell* aPresShell)
 82770: {
 99648:   Accessible* accessible =
101261:     new HTMLCanvasAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 82770:   return accessible;
 82770: }
 82770: 
 99648: already_AddRefed<Accessible>
 83000: nsAccessibilityService::CreateHTMLFileInputAccessible(nsIContent* aContent,
 83000:                                                       nsIPresShell* aPresShell)
 83000: {
 99648:   Accessible* accessible =
 95565:     new HTMLFileInputAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 83000:   return accessible;
 83000: }
 83000: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLImageAccessible(nsIContent* aContent,
 46338:                                                   nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
100130:     new ImageAccessibleWrap(aContent, GetDocAccessible(aPresShell));
 93267:   NS_ADDREF(accessible);
 93267:   return accessible;
 71031: }
     1: 
 99648: already_AddRefed<Accessible>
 93267: nsAccessibilityService::CreateHTMLImageMapAccessible(nsIContent* aContent,
 93267:                                                      nsIPresShell* aPresShell)
 93267: {
 99648:   Accessible* accessible =
101055:     new HTMLImageMapAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLGroupboxAccessible(nsIContent* aContent,
 46338:                                                      nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
 95565:     new HTMLGroupboxAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLListboxAccessible(nsIContent* aContent,
 46338:                                                     nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
101260:     new HTMLSelectListAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLMediaAccessible(nsIContent* aContent,
 46338:                                                   nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
101054:     new EnumRoleAccessible(aContent, GetDocAccessible(aPresShell),
 87094:                            roles::GROUPING);
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLObjectFrameAccessible(nsObjectFrame* aFrame,
 46338:                                                         nsIContent* aContent,
 46338:                                                         nsIPresShell* aPresShell)
 27515: {
 46338:   // We can have several cases here:
 46338:   // 1) a text or html embedded document where the contentDocument variable in
 46338:   //    the object element holds the content;
 46338:   // 2) web content that uses a plugin, which means we will have to go to
 46338:   //    the plugin to get the accessible content;
 46338:   // 3) an image or imagemap, where the image frame points back to the object
 46338:   //    element DOMNode.
 27515: 
 46338:   if (aFrame->GetRect().IsEmpty())
 46338:     return nsnull;
 27515: 
 27515: 
     1:   // 1) for object elements containing either HTML or TXT documents
 46338:   nsCOMPtr<nsIDOMHTMLObjectElement> obj(do_QueryInterface(aContent));
 43504:   if (obj) {
     1:     nsCOMPtr<nsIDOMDocument> domDoc;
     1:     obj->GetContentDocument(getter_AddRefs(domDoc));
 46338:     if (domDoc)
 46338:       return CreateOuterDocAccessible(aContent, aPresShell);
 43504:   }
     1: 
 69027: #if defined(XP_WIN) || defined(MOZ_ACCESSIBILITY_ATK)
     1:   // 2) for plugins
 70007:   nsRefPtr<nsNPAPIPluginInstance> pluginInstance;
 70007:   if (NS_SUCCEEDED(aFrame->GetPluginInstance(getter_AddRefs(pluginInstance))) &&
 69027:       pluginInstance) {
 69027: #ifdef XP_WIN
 33872:     // Note: pluginPort will be null if windowless.
     1:     HWND pluginPort = nsnull;
     1:     aFrame->GetPluginPort(&pluginPort);
 33872: 
 99648:     Accessible* accessible =
 89799:       new nsHTMLWin32ObjectOwnerAccessible(aContent,
 95565:                                            GetDocAccessible(aPresShell),
 46338:                                            pluginPort);
 89799:     NS_ADDREF(accessible);
 46338:     return accessible;
 69027: 
 69027: #elif MOZ_ACCESSIBILITY_ATK
 69027:     if (!AtkSocketAccessible::gCanEmbed)
 69027:       return nsnull;
 69027: 
 69027:     nsCString plugId;
 69027:     nsresult rv = pluginInstance->GetValueFromPlugin(
 69027:       NPPVpluginNativeAccessibleAtkPlugId, &plugId);
 88338:     if (NS_SUCCEEDED(rv) && !plugId.IsEmpty()) {
 69027:       AtkSocketAccessible* socketAccessible =
 95565:         new AtkSocketAccessible(aContent, GetDocAccessible(aPresShell),
 89799:                                 plugId);
 69027: 
 89799:       NS_ADDREF(socketAccessible);
 69027:       return socketAccessible;
 69027:     }
 69027: #endif
     1:   }
     1: #endif
     1: 
     1:   // 3) for images and imagemaps, or anything else with a child frame
     1:   // we have the object frame, get the image frame
 77154:   nsIFrame* frame = aFrame->GetFirstPrincipalChild();
 46338:   return frame ? frame->CreateAccessible() : nsnull;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLRadioButtonAccessible(nsIContent* aContent,
 46338:                                                         nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
 95565:     new HTMLRadioButtonAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLTableAccessible(nsIContent* aContent,
 46338:                                                   nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
101616:     new HTMLTableAccessibleWrap(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
 43504: }
 43504: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLTableCellAccessible(nsIContent* aContent,
 46338:                                                       nsIPresShell* aPresShell)
 43504: {
 99648:   Accessible* accessible =
101616:     new HTMLTableCellAccessibleWrap(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
 43504: }
 43504: 
 99648: already_AddRefed<Accessible>
 96899: nsAccessibilityService::CreateHTMLTableRowAccessible(nsIContent* aContent,
 96899:                                                      nsIPresShell* aPresShell)
 96899: {
 99648:   Accessible* accessible =
101054:     new EnumRoleAccessible(aContent, GetDocAccessible(aPresShell), roles::ROW);
 96899:   NS_ADDREF(accessible);
 96899:   return accessible;
 96899: }
 96899: 
 99648: already_AddRefed<Accessible>
 99295: nsAccessibilityService::CreateTextLeafAccessible(nsIContent* aContent,
 46338:                                                  nsIPresShell* aPresShell)
 43504: {
 99648:   Accessible* accessible =
103131:     new TextLeafAccessibleWrap(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
 43504: }
 43504: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLTextFieldAccessible(nsIContent* aContent,
 46338:                                                       nsIPresShell* aPresShell)
 43504: {
 99648:   Accessible* accessible =
 95565:     new HTMLTextFieldAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLLabelAccessible(nsIContent* aContent,
 46338:                                                   nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
100129:     new HTMLLabelAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLHRAccessible(nsIContent* aContent,
 46338:                                                nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
100129:     new HTMLHRAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLBRAccessible(nsIContent* aContent,
 46338:                                                nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
100129:     new HTMLBRAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
     1: }
     1: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLCaptionAccessible(nsIContent* aContent,
 46338:                                                     nsIPresShell* aPresShell)
     1: {
 99648:   Accessible* accessible =
101616:     new HTMLCaptionAccessible(aContent, GetDocAccessible(aPresShell));
 89799:   NS_ADDREF(accessible);
 46338:   return accessible;
  3151: }
  3151: 
 43765: void
 56292: nsAccessibilityService::ContentRangeInserted(nsIPresShell* aPresShell,
 56292:                                              nsIContent* aContainer,
 56292:                                              nsIContent* aStartChild,
 56292:                                              nsIContent* aEndChild)
 56292: {
 99989: #ifdef DEBUG
 99989:   if (logging::IsEnabled(logging::eTree)) {
 99989:     logging::MsgBegin("TREE", "content inserted");
 99989:     logging::Node("container", aContainer);
 99989:     for (nsIContent* child = aStartChild; child != aEndChild;
 99989:          child = child->GetNextSibling()) {
 99989:       logging::Node("content", child);
 56987:     }
 99989:     logging::MsgEnd();
 99989:   }
 56292: #endif
 56292: 
 99568:   DocAccessible* docAccessible = GetDocAccessible(aPresShell);
 56292:   if (docAccessible)
 60746:     docAccessible->ContentInserted(aContainer, aStartChild, aEndChild);
 56292: }
 56292: 
 56292: void
 56292: nsAccessibilityService::ContentRemoved(nsIPresShell* aPresShell,
 56292:                                        nsIContent* aContainer,
 56292:                                        nsIContent* aChild)
 56292: {
 99989: #ifdef DEBUG
 99989:   if (logging::IsEnabled(logging::eTree)) {
 99989:     logging::MsgBegin("TREE", "content removed");
 99989:     logging::Node("container", aContainer);
 99989:     logging::Node("content", aChild);
 99989:     logging::MsgEnd();
 56987:   }
 56292: #endif
 56292: 
 99568:   DocAccessible* docAccessible = GetDocAccessible(aPresShell);
 56292:   if (docAccessible)
 60746:     docAccessible->ContentRemoved(aContainer, aChild);
 56292: }
 56292: 
 56292: void
 61516: nsAccessibilityService::UpdateText(nsIPresShell* aPresShell,
 61516:                                    nsIContent* aContent)
 61516: {
 99568:   DocAccessible* document = GetDocAccessible(aPresShell);
 61516:   if (document)
 61516:     document->UpdateText(aContent);
 61516: }
 61516: 
 61516: void
 94579: nsAccessibilityService::TreeViewChanged(nsIPresShell* aPresShell,
 94579:                                         nsIContent* aContent,
 94579:                                         nsITreeView* aView)
 94579: {
 99568:   DocAccessible* document = GetDocAccessible(aPresShell);
 94579:   if (document) {
 99648:     Accessible* accessible = document->GetAccessible(aContent);
 94579:     if (accessible) {
101616:       XULTreeAccessible* treeAcc = accessible->AsXULTree();
 94579:       if (treeAcc) 
 94579:         treeAcc->TreeViewChanged(aView);
 94579:     }
 94579:   }
 94579: }
 94579: 
 94579: void
 64006: nsAccessibilityService::UpdateListBullet(nsIPresShell* aPresShell,
 64006:                                          nsIContent* aHTMLListItemContent,
 64006:                                          bool aHasBullet)
 64006: {
 99568:   DocAccessible* document = GetDocAccessible(aPresShell);
 64006:   if (document) {
 99648:     Accessible* accessible = document->GetAccessible(aHTMLListItemContent);
 64006:     if (accessible) {
 97985:       HTMLLIAccessible* listItem = accessible->AsHTMLListItem();
 64006:       if (listItem)
 64006:         listItem->UpdateBullet(aHasBullet);
 64006:     }
 64006:   }
 64006: }
 64006: 
 64006: void
 93267: nsAccessibilityService::UpdateImageMap(nsImageFrame* aImageFrame)
 93267: {
 93267:   nsIPresShell* presShell = aImageFrame->PresContext()->PresShell();
 99568:   DocAccessible* document = GetDocAccessible(presShell);
 93267:   if (document) {
 99648:     Accessible* accessible =
 93267:       document->GetAccessible(aImageFrame->GetContent());
 93267:     if (accessible) {
101055:       HTMLImageMapAccessible* imageMap = accessible->AsImageMap();
 93267:       if (imageMap) {
 93267:         imageMap->UpdateChildAreas();
 93267:         return;
 93267:       }
 93267: 
 93267:       // If image map was initialized after we created an accessible (that'll
 93267:       // be an image accessible) then recreate it.
 93267:       RecreateAccessible(presShell, aImageFrame->GetContent());
 93267:     }
 93267:   }
 93267: }
 93267: 
 93267: void
106516: nsAccessibilityService::PresShellDestroyed(nsIPresShell *aPresShell)
106516: {
106516:   // Presshell destruction will automatically destroy shells for descendant
106516:   // documents, so no need to worry about those. Just shut down the accessible
106516:   // for this one document. That keeps us from having bad behavior in case of
106516:   // deep bushy subtrees.
106516:   // When document subtree containing iframe is hidden then we don't get
106516:   // pagehide event for the iframe's underlying document and its presshell is
106516:   // destroyed before we're notified styles were changed. Shutdown the document
106516:   // accessible early.
106516:   nsIDocument* doc = aPresShell->GetDocument();
106516:   if (!doc)
106516:     return;
106516: 
106516: #ifdef DEBUG
106516:   if (logging::IsEnabled(logging::eDocDestroy))
106516:     logging::DocDestroy("presshell destroyed", doc);
106516: #endif
106516: 
106516:   DocAccessible* docAccessible = GetDocAccessibleFromCache(doc);
106516:   if (docAccessible)
106516:     docAccessible->Shutdown();
106516: }
106516: 
106516: void
 63261: nsAccessibilityService::PresShellActivated(nsIPresShell* aPresShell)
 63261: {
 63261:   nsIDocument* DOMDoc = aPresShell->GetDocument();
 63261:   if (DOMDoc) {
 99568:     DocAccessible* document = GetDocAccessibleFromCache(DOMDoc);
 63261:     if (document) {
 97643:       RootAccessible* rootDocument = document->RootAccessible();
 63261:       NS_ASSERTION(rootDocument, "Entirely broken tree: no root document!");
 63261:       if (rootDocument)
 63261:         rootDocument->DocumentActivated(document);
 63261:     }
 63261:   }
 63261: }
 63261: 
 63261: void
 56292: nsAccessibilityService::RecreateAccessible(nsIPresShell* aPresShell,
 56292:                                            nsIContent* aContent)
 56292: {
 99568:   DocAccessible* document = GetDocAccessible(aPresShell);
 93850:   if (document)
 93850:     document->RecreateAccessible(aContent);
 56292: }
 56292: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // nsIAccessibleRetrieval
 38359: 
  2064: NS_IMETHODIMP
 39600: nsAccessibilityService::GetApplicationAccessible(nsIAccessible** aAccessibleApplication)
 39567: {
 39600:   NS_ENSURE_ARG_POINTER(aAccessibleApplication);
 39567: 
 39600:   NS_IF_ADDREF(*aAccessibleApplication = nsAccessNode::GetApplicationAccessible());
 39600:   return NS_OK;
 39567: }
 39567: 
 39567: NS_IMETHODIMP
 43504: nsAccessibilityService::GetAccessibleFor(nsIDOMNode *aNode,
 43504:                                          nsIAccessible **aAccessible)
 43504: {
 43504:   NS_ENSURE_ARG_POINTER(aAccessible);
 72710:   *aAccessible = nsnull;
 72710:   if (!aNode)
 72710:     return NS_OK;
 43504: 
 43504:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
 77682:   if (!node)
 77682:     return NS_ERROR_INVALID_ARG;
 77682: 
101298:   DocAccessible* document = GetDocAccessible(node->OwnerDoc());
101298:   if (document)
101298:     NS_IF_ADDREF(*aAccessible = document->GetAccessible(node));
101298: 
 43504:   return NS_OK;
 43504: }
 43504: 
 43504: NS_IMETHODIMP
  2064: nsAccessibilityService::GetStringRole(PRUint32 aRole, nsAString& aString)
  2064: {
106033: #define ROLE(geckoRole, stringRole, atkRole, \
106033:              macRole, msaaRole, ia2Role, nameRule) \
 97224:   case roles::geckoRole: \
 97224:     CopyUTF8toUTF16(stringRole, aString); \
 97224:     return NS_OK;
 97224: 
 97224:   switch (aRole) {
 97224: #include "RoleMap.h"
 97224:     default:
  2064:       aString.AssignLiteral("unknown");
  2064:       return NS_OK;
  2064:   }
  2064: 
 97224: #undef ROLE
  2064: }
  2064: 
  2064: NS_IMETHODIMP
 67790: nsAccessibilityService::GetStringStates(PRUint32 aState, PRUint32 aExtraState,
  2064:                                         nsIDOMDOMStringList **aStringStates)
  2064: {
  2064:   nsAccessibleDOMStringList* stringStates = new nsAccessibleDOMStringList();
  2064:   NS_ENSURE_TRUE(stringStates, NS_ERROR_OUT_OF_MEMORY);
  2064: 
 67790:   PRUint64 state = nsAccUtils::To64State(aState, aExtraState);
 67790: 
  2064:   // states
 67790:   if (state & states::UNAVAILABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("unavailable"));
 67790:   if (state & states::SELECTED)
  2064:     stringStates->Add(NS_LITERAL_STRING("selected"));
 67790:   if (state & states::FOCUSED)
  2064:     stringStates->Add(NS_LITERAL_STRING("focused"));
 67790:   if (state & states::PRESSED)
  2064:     stringStates->Add(NS_LITERAL_STRING("pressed"));
 67790:   if (state & states::CHECKED)
  2064:     stringStates->Add(NS_LITERAL_STRING("checked"));
 67790:   if (state & states::MIXED)
  2064:     stringStates->Add(NS_LITERAL_STRING("mixed"));
 67790:   if (state & states::READONLY)
  2064:     stringStates->Add(NS_LITERAL_STRING("readonly"));
 67790:   if (state & states::HOTTRACKED)
  2064:     stringStates->Add(NS_LITERAL_STRING("hottracked"));
 67790:   if (state & states::DEFAULT)
  2064:     stringStates->Add(NS_LITERAL_STRING("default"));
 67790:   if (state & states::EXPANDED)
  2064:     stringStates->Add(NS_LITERAL_STRING("expanded"));
 67790:   if (state & states::COLLAPSED)
  2064:     stringStates->Add(NS_LITERAL_STRING("collapsed"));
 67790:   if (state & states::BUSY)
  2064:     stringStates->Add(NS_LITERAL_STRING("busy"));
 67790:   if (state & states::FLOATING)
  2064:     stringStates->Add(NS_LITERAL_STRING("floating"));
 67790:   if (state & states::ANIMATED)
  2064:     stringStates->Add(NS_LITERAL_STRING("animated"));
 67790:   if (state & states::INVISIBLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("invisible"));
 67790:   if (state & states::OFFSCREEN)
  2064:     stringStates->Add(NS_LITERAL_STRING("offscreen"));
 67790:   if (state & states::SIZEABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("sizeable"));
 67790:   if (state & states::MOVEABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("moveable"));
 67790:   if (state & states::SELFVOICING)
  2064:     stringStates->Add(NS_LITERAL_STRING("selfvoicing"));
 67790:   if (state & states::FOCUSABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("focusable"));
 67790:   if (state & states::SELECTABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("selectable"));
 67790:   if (state & states::LINKED)
  2064:     stringStates->Add(NS_LITERAL_STRING("linked"));
 67790:   if (state & states::TRAVERSED)
  2064:     stringStates->Add(NS_LITERAL_STRING("traversed"));
 67790:   if (state & states::MULTISELECTABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("multiselectable"));
 67790:   if (state & states::EXTSELECTABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("extselectable"));
 67790:   if (state & states::PROTECTED)
  2064:     stringStates->Add(NS_LITERAL_STRING("protected"));
 67790:   if (state & states::HASPOPUP)
  2064:     stringStates->Add(NS_LITERAL_STRING("haspopup"));
 67790:   if (state & states::REQUIRED)
  2064:     stringStates->Add(NS_LITERAL_STRING("required"));
 67790:   if (state & states::ALERT)
 67790:     stringStates->Add(NS_LITERAL_STRING("alert"));
 67790:   if (state & states::INVALID)
  2064:     stringStates->Add(NS_LITERAL_STRING("invalid"));
 67790:   if (state & states::CHECKABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("checkable"));
  2064: 
  2064:   // extraStates
 67790:   if (state & states::SUPPORTS_AUTOCOMPLETION)
  3513:     stringStates->Add(NS_LITERAL_STRING("autocompletion"));
 67790:   if (state & states::DEFUNCT)
  3513:     stringStates->Add(NS_LITERAL_STRING("defunct"));
 67790:   if (state & states::SELECTABLE_TEXT)
  2064:     stringStates->Add(NS_LITERAL_STRING("selectable text"));
 67790:   if (state & states::EDITABLE)
  2064:     stringStates->Add(NS_LITERAL_STRING("editable"));
 67790:   if (state & states::ACTIVE)
  2064:     stringStates->Add(NS_LITERAL_STRING("active"));
 67790:   if (state & states::MODAL)
  2064:     stringStates->Add(NS_LITERAL_STRING("modal"));
 67790:   if (state & states::MULTI_LINE)
  2064:     stringStates->Add(NS_LITERAL_STRING("multi line"));
 67790:   if (state & states::HORIZONTAL)
  3513:     stringStates->Add(NS_LITERAL_STRING("horizontal"));
 67790:   if (state & states::OPAQUE1)
  3513:     stringStates->Add(NS_LITERAL_STRING("opaque"));
 67790:   if (state & states::SINGLE_LINE)
  2064:     stringStates->Add(NS_LITERAL_STRING("single line"));
 67790:   if (state & states::TRANSIENT)
  2064:     stringStates->Add(NS_LITERAL_STRING("transient"));
 67790:   if (state & states::VERTICAL)
  2064:     stringStates->Add(NS_LITERAL_STRING("vertical"));
 67790:   if (state & states::STALE)
  3513:     stringStates->Add(NS_LITERAL_STRING("stale"));
 67790:   if (state & states::ENABLED)
  3513:     stringStates->Add(NS_LITERAL_STRING("enabled"));
 67790:   if (state & states::SENSITIVE)
  3513:     stringStates->Add(NS_LITERAL_STRING("sensitive"));
 67790:   if (state & states::EXPANDABLE)
  3513:     stringStates->Add(NS_LITERAL_STRING("expandable"));
  2064: 
  2064:   //unknown states
  2064:   PRUint32 stringStatesLength = 0;
  2064:   stringStates->GetLength(&stringStatesLength);
  2064:   if (!stringStatesLength)
  2064:     stringStates->Add(NS_LITERAL_STRING("unknown"));
  2064: 
  2064:   NS_ADDREF(*aStringStates = stringStates);
  2064:   return NS_OK;
  2064: }
  2064: 
  5188: // nsIAccessibleRetrieval::getStringEventType()
  5188: NS_IMETHODIMP
  5188: nsAccessibilityService::GetStringEventType(PRUint32 aEventType,
  5188:                                            nsAString& aString)
  5188: {
 80467:   NS_ASSERTION(nsIAccessibleEvent::EVENT_LAST_ENTRY == ArrayLength(kEventTypeNames),
  6284:                "nsIAccessibleEvent constants are out of sync to kEventTypeNames");
  6284: 
 80467:   if (aEventType >= ArrayLength(kEventTypeNames)) {
  5188:     aString.AssignLiteral("unknown");
  5188:     return NS_OK;
  5188:   }
  5188: 
  5188:   CopyUTF8toUTF16(kEventTypeNames[aEventType], aString);
  5188:   return NS_OK;
  5188: }
  5188: 
  6812: // nsIAccessibleRetrieval::getStringRelationType()
  6812: NS_IMETHODIMP
  6812: nsAccessibilityService::GetStringRelationType(PRUint32 aRelationType,
  6812:                                               nsAString& aString)
  6812: {
 80467:   if (aRelationType >= ArrayLength(kRelationTypeNames)) {
  6812:     aString.AssignLiteral("unknown");
  6812:     return NS_OK;
  6812:   }
  6812: 
  6812:   CopyUTF8toUTF16(kRelationTypeNames[aRelationType], aString);
  6812:   return NS_OK;
  6812: }
  6812: 
 43764: NS_IMETHODIMP
 43764: nsAccessibilityService::GetAccessibleFromCache(nsIDOMNode* aNode,
 43764:                                                nsIAccessible** aAccessible)
 43764: {
 43764:   NS_ENSURE_ARG_POINTER(aAccessible);
 77682:   *aAccessible = nsnull;
 77682:   if (!aNode)
 77682:     return NS_OK;
 77682: 
 77682:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
 77682:   if (!node)
 77682:     return NS_ERROR_INVALID_ARG;
 43764: 
 43764:   // Search for an accessible in each of our per document accessible object
 43764:   // caches. If we don't find it, and the given node is itself a document, check
 43764:   // our cache of document accessibles (document cache). Note usually shutdown
 43764:   // document accessibles are not stored in the document cache, however an
 43764:   // "unofficially" shutdown document (i.e. not from nsAccDocManager) can still
 43764:   // exist in the document cache.
 99648:   Accessible* accessible = FindAccessibleInCache(node);
 43764:   if (!accessible) {
 43764:     nsCOMPtr<nsIDocument> document(do_QueryInterface(node));
 43764:     if (document)
 43764:       accessible = GetDocAccessibleFromCache(document);
 43764:   }
 43764: 
 43764:   NS_IF_ADDREF(*aAccessible = accessible);
 43764:   return NS_OK;
 43764: }
 43764: 
 89309: NS_IMETHODIMP
 89309: nsAccessibilityService::CreateAccessiblePivot(nsIAccessible* aRoot,
 89309:                                               nsIAccessiblePivot** aPivot)
 89309: {
 89309:   NS_ENSURE_ARG_POINTER(aPivot);
 89309:   NS_ENSURE_ARG(aRoot);
 89309:   *aPivot = nsnull;
 89309: 
 99648:   nsRefPtr<Accessible> accessibleRoot(do_QueryObject(aRoot));
 89309:   NS_ENSURE_TRUE(accessibleRoot, NS_ERROR_INVALID_ARG);
 89309: 
 89309:   nsAccessiblePivot* pivot = new nsAccessiblePivot(accessibleRoot);
 89309:   NS_ADDREF(*aPivot = pivot);
 89309: 
 89309:   return NS_OK;
 89309: }
 89309: 
 99203: NS_IMETHODIMP
 99203: nsAccessibilityService::SetLogging(const nsACString& aModules)
 99203: {
 99203: #ifdef DEBUG
 99203:   logging::Enable(PromiseFlatCString(aModules));
 99203: #endif
 99203:   return NS_OK;
 99203: }
 99203: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // nsAccessibilityService public
 38359: 
 79445: static bool HasRelatedContent(nsIContent *aContent)
 10515: {
 10515:   nsAutoString id;
 20521:   if (!aContent || !nsCoreUtils::GetID(aContent, id) || id.IsEmpty()) {
 80486:     return false;
 10515:   }
 10515: 
 57890:   // If the given ID is referred by relation attribute then create an accessible
 57890:   // for it. Take care of HTML elements only for now.
 87821:   return aContent->IsHTML() &&
 87821:     nsAccUtils::GetDocAccessibleFor(aContent)->IsDependentID(id);
 10515: }
 10515: 
 99648: Accessible*
 46469: nsAccessibilityService::GetOrCreateAccessible(nsINode* aNode,
 99568:                                               DocAccessible* aDoc,
 57448:                                               bool* aIsSubtreeHidden)
     1: {
 89801:   if (!aDoc || !aNode || gIsShutdown)
 38359:     return nsnull;
     1: 
 57448:   if (aIsSubtreeHidden)
 57448:     *aIsSubtreeHidden = false;
     1: 
 38062:   // Check to see if we already have an accessible for this node in the cache.
 99648:   Accessible* cachedAccessible = aDoc->GetAccessible(aNode);
 64506:   if (cachedAccessible)
 43538:     return cachedAccessible;
     1: 
 38359:   // No cache entry, so we must create the accessible.
 38359: 
 43504:   if (aNode->IsNodeOfType(nsINode::eDOCUMENT)) {
 43310:     // If it's document node then ask accessible document loader for
 43310:     // document accessible, otherwise return null.
 43310:     nsCOMPtr<nsIDocument> document(do_QueryInterface(aNode));
 64506:     return GetDocAccessible(document);
 43310:   }
     1: 
 38359:   // We have a content node.
 43504:   if (!aNode->IsInDoc()) {
 43310:     NS_WARNING("Creating accessible for node with no document");
 38359:     return nsnull;
     1:   }
     1: 
 89801:   if (aNode->OwnerDoc() != aDoc->GetDocumentNode()) {
 89801:     NS_ERROR("Creating accessible for wrong document");
 38359:     return nsnull;
 38359:   }
 34904: 
 43504:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
 43504:   if (!content)
 43504:     return nsnull;
 43504: 
 38359:   // Frames can be deallocated when we flush layout, or when we call into code
 38359:   // that can flush layout, either directly, or via DOM manipulation, or some
 38359:   // CSS styles like :hover. We use the weak frame checks to avoid calling
 38359:   // methods on a dead frame pointer.
 38359:   nsWeakFrame weakFrame = content->GetPrimaryFrame();
 38359: 
 57448:   // Check frame and its visibility. Note, hidden frame allows visible
 57448:   // elements in subtree.
 57448:   if (!weakFrame.GetFrame() || !weakFrame->GetStyleVisibility()->IsVisible()) {
 57448:     if (aIsSubtreeHidden && !weakFrame.GetFrame())
 57448:       *aIsSubtreeHidden = true;
 38359: 
 38359:     return nsnull;
     1:   }
 38359: 
 34904:   if (weakFrame.GetFrame()->GetContent() != content) {
 40575:     // Not the main content for this frame. This happens because <area>
 40575:     // elements return the image frame as their primary frame. The main content
 40575:     // for the image frame is the image content. If the frame is not an image
 40575:     // frame or the node is not an area element then null is returned.
 79733:     // This setup will change when bug 135040 is fixed. Make sure we don't
 79733:     // create area accessible here. Hopefully assertion below will handle that.
 79733: 
 79733: #ifdef DEBUG
 79733:   nsImageFrame* imageFrame = do_QueryFrame(weakFrame.GetFrame());
 79733:   NS_ASSERTION(imageFrame && content->IsHTML() && content->Tag() == nsGkAtoms::area,
 79733:                "Unknown case of not main content for the frame!");
 79733: #endif
 79733:     return nsnull;
     1:   }
     1: 
 79733: #ifdef DEBUG
 79733:   nsImageFrame* imageFrame = do_QueryFrame(weakFrame.GetFrame());
 79733:   NS_ASSERTION(!imageFrame || !content->IsHTML() || content->Tag() != nsGkAtoms::area,
 79733:                "Image map manages the area accessible creation!");
 79733: #endif
 79733: 
 99568:   DocAccessible* docAcc =
 80526:     GetAccService()->GetDocAccessible(aNode->OwnerDoc());
 57413:   if (!docAcc) {
 64506:     NS_NOTREACHED("Node has no host document accessible!");
 57413:     return nsnull;
 57413:   }
 57413: 
 38359:   // Attempt to create an accessible based on what we know.
 99648:   nsRefPtr<Accessible> newAcc;
 61649: 
 61649:   // Create accessible for visible text frames.
     1:   if (content->IsNodeOfType(nsINode::eTEXT)) {
 61649:     nsAutoString text;
 61649:     weakFrame->GetRenderedText(&text, nsnull, nsnull, 0, PR_UINT32_MAX);
 61649:     if (text.IsEmpty()) {
 57448:       if (aIsSubtreeHidden)
 57448:         *aIsSubtreeHidden = true;
 38359: 
 38359:       return nsnull;
     1:     }
 61649: 
 61649:     newAcc = weakFrame->CreateAccessible();
 61649:     if (docAcc->BindToDocument(newAcc, nsnull)) {
 61649:       newAcc->AsTextLeaf()->SetText(text);
 64506:       return newAcc;
 38359:     }
 35026: 
 38359:     return nsnull;
     1:   }
     1: 
 79445:   bool isHTML = content->IsHTML();
 78350:   if (isHTML && content->Tag() == nsGkAtoms::map) {
 15308:     // Create hyper text accessible for HTML map if it is used to group links
 15308:     // (see http://www.w3.org/TR/WCAG10-HTML-TECHS/#group-bypass). If the HTML
 79788:     // map rect is empty then it is used for links grouping. Otherwise it should
 79788:     // be used in conjunction with HTML image element and in this case we don't
 79788:     // create any accessible for it and don't walk into it. The accessibles for
101055:     // HTML area (HTMLAreaAccessible) the map contains are attached as
 79788:     // children of the appropriate accessible for HTML image
100130:     // (ImageAccessible).
 79788:     if (nsLayoutUtils::GetAllInFlowRectsUnion(weakFrame,
 79788:                                               weakFrame->GetParent()).IsEmpty()) {
 57448:       if (aIsSubtreeHidden)
 57448:         *aIsSubtreeHidden = true;
 38359: 
 38359:       return nsnull;
 15308:     }
 15308: 
 99901:     newAcc = new HyperTextAccessibleWrap(content, docAcc);
 95490:     if (docAcc->BindToDocument(newAcc, aria::GetRoleMap(aNode)))
 64506:       return newAcc;
 38359:     return nsnull;
 15308:   }
 15308: 
 95490:   nsRoleMapEntry* roleMapEntry = aria::GetRoleMap(aNode);
101616:   if (roleMapEntry && roleMapEntry->Is(nsGkAtoms::presentation)) {
 72715:     // Ignore presentation role if element is focusable (focus event shouldn't
 72715:     // be ever lost and should be sensible).
 72715:     if (content->IsFocusable())
 72715:       roleMapEntry = nsnull;
 72715:     else
 38359:       return nsnull;
     1:   }
     1: 
 34904:   if (weakFrame.IsAlive() && !newAcc && isHTML) {  // HTML accessibles
 79445:     bool tryTagNameOrFrame = true;
 13731: 
 34904:     nsIAtom *frameType = weakFrame.GetFrame()->GetType();
 28493: 
 79445:     bool partOfHTMLTable =
 78350:       frameType == nsGkAtoms::tableCaptionFrame ||
 78350:       frameType == nsGkAtoms::tableCellFrame ||
 78350:       frameType == nsGkAtoms::tableRowGroupFrame ||
 78350:       frameType == nsGkAtoms::tableRowFrame;
 28493: 
 32474:     if (partOfHTMLTable) {
 10869:       // Table-related frames don't get table-related roles
 10869:       // unless they are inside a table, but they may still get generic
 10869:       // accessibles
     1:       nsIContent *tableContent = content;
     1:       while ((tableContent = tableContent->GetParent()) != nsnull) {
 36654:         nsIFrame *tableFrame = tableContent->GetPrimaryFrame();
 10869:         if (!tableFrame)
 10869:           continue;
 32474: 
 78350:         if (tableFrame->GetType() == nsGkAtoms::tableOuterFrame) {
 99648:           Accessible* tableAccessible = aDoc->GetAccessible(tableContent);
 32474: 
 32474:           if (tableAccessible) {
 32479:             if (!roleMapEntry) {
 87094:               roles::Role role = tableAccessible->Role();
 32479:               // No ARIA role and not in table: override role. For example,
 32479:               // <table role="label"><td>content</td></table>
 87094:               if (role != roles::TABLE && role != roles::TREE_TABLE)
 32474:                 roleMapEntry = &nsARIAMap::gEmptyRoleMap;
 32474:             }
 32474: 
 32474:             break;
 32474:           }
 32474: 
 10869: #ifdef DEBUG
 95490:           nsRoleMapEntry* tableRoleMapEntry = aria::GetRoleMap(tableContent);
101616:           NS_ASSERTION(tableRoleMapEntry && tableRoleMapEntry->Is(nsGkAtoms::presentation),
 10869:                        "No accessible for parent table and it didn't have role of presentation");
 10869: #endif
 32474: 
 32474:           if (!roleMapEntry && !content->IsFocusable()) {
 32474:             // Table-related descendants of presentation table are also
 32474:             // presentation if they aren't focusable and have not explicit ARIA
 32474:             // role (don't create accessibles for them unless they need to fire
 32474:             // focus events).
 38359:             return nsnull;
 10869:           }
 32474: 
 32474:           // otherwise create ARIA based accessible.
 80486:           tryTagNameOrFrame = false;
  6090:           break;
  6090:         }
 32474: 
 78350:         if (tableContent->Tag() == nsGkAtoms::table) {
 10869:           // Stop before we are fooled by any additional table ancestors
 10869:           // This table cell frameis part of a separate ancestor table.
 80486:           tryTagNameOrFrame = false;
 10421:           break;
  6090:         }
  6090:       }
 13731: 
 13731:       if (!tableContent)
 80486:         tryTagNameOrFrame = false;
     1:     }
     1: 
 29271:     if (roleMapEntry) {
 29271:       // Create ARIA grid/treegrid accessibles if node is not of a child or
 29271:       // valid child of HTML table and is not a HTML table.
 29271:       if ((!partOfHTMLTable || !tryTagNameOrFrame) &&
 78350:           frameType != nsGkAtoms::tableOuterFrame) {
 29271: 
 87094:         if (roleMapEntry->role == roles::TABLE ||
 87094:             roleMapEntry->role == roles::TREE_TABLE) {
 94984:           newAcc = new ARIAGridAccessibleWrap(content, docAcc);
 29271: 
 87094:         } else if (roleMapEntry->role == roles::GRID_CELL ||
 87094:             roleMapEntry->role == roles::ROWHEADER ||
 87094:             roleMapEntry->role == roles::COLUMNHEADER) {
 94984:           newAcc = new ARIAGridCellAccessibleWrap(content, docAcc);
 28493:         }
 28493:       }
 29271:     }
 28493: 
 28493:     if (!newAcc && tryTagNameOrFrame) {
  6090:       // Prefer to use markup (mostly tag name, perhaps attributes) to
  6090:       // decide if and what kind of accessible to create.
  6090:       // The method creates accessibles for table related content too therefore
  6090:       // we do not call it if accessibles for table related content are
  6090:       // prevented above.
 46338:       newAcc = CreateHTMLAccessibleByMarkup(weakFrame.GetFrame(), content,
 89799:                                             docAcc);
     1: 
  6090:       if (!newAcc) {
  6090:         // Do not create accessible object subtrees for non-rendered table
  6090:         // captions. This could not be done in
  6090:         // nsTableCaptionFrame::GetAccessible() because the descendants of
  6090:         // the table caption would still be created. By setting
 57448:         // *aIsSubtreeHidden = true we ensure that no descendant accessibles
 57448:         // are created.
 34904:         nsIFrame* f = weakFrame.GetFrame();
 34904:         if (!f) {
 89801:           f = aDoc->PresShell()->GetRealPrimaryFrameFor(content);
 34904:         }
 78350:         if (f->GetType() == nsGkAtoms::tableCaptionFrame &&
 34904:            f->GetRect().IsEmpty()) {
  6090:           // XXX This is not the ideal place for this code, but right now there
  6090:           // is no better place:
 57448:           if (aIsSubtreeHidden)
 57448:             *aIsSubtreeHidden = true;
 38359: 
 38359:           return nsnull;
  3151:         }
 38359: 
 38359:         // Try using frame to do it.
 46338:         newAcc = f->CreateAccessible();
     1:       }
     1:     }
 13731:   }
     1: 
  1477:   if (!newAcc) {
 28493:     // Elements may implement nsIAccessibleProvider via XBL. This allows them to
 28493:     // say what kind of accessible to create.
 89799:     newAcc = CreateAccessibleByType(content, docAcc);
 28493:   }
 28493: 
 28493:   if (!newAcc) {
103750:     // xul:deck does not have XBL and nsIFrame::CreateAccessible() is only called 
103750:     // on HTML elements
103750:     nsIAtom* tag = content->Tag();
103750:     if ((tag == nsGkAtoms::deck) || (tag == nsGkAtoms::tabpanels)) {
103750:       newAcc = new XULDeckAccessible(content, docAcc);
103750:     } else if (content->IsSVG(nsGkAtoms::svg)) {
101054:       newAcc = new EnumRoleAccessible(content, docAcc, roles::DIAGRAM);
103750:     } else if (content->IsMathML(nsGkAtoms::math)) {
101054:       newAcc = new EnumRoleAccessible(content, docAcc, roles::EQUATION);
 28493:     }
 28493:   }
 28493: 
 28493:   if (!newAcc) {
 43504:     newAcc = CreateAccessibleForDeckChild(weakFrame.GetFrame(), content,
 89799:                                           docAcc);
  1477:   }
  1477: 
     1:   // If no accessible, see if we need to create a generic accessible because
     1:   // of some property that makes this object interesting
     1:   // We don't do this for <body>, <html>, <window>, <dialog> etc. which
     1:   // correspond to the doc accessible and will be created in any case
 78350:   if (!newAcc && content->Tag() != nsGkAtoms::body && content->GetParent() &&
 34904:       ((weakFrame.GetFrame() && weakFrame.GetFrame()->IsFocusable()) ||
 37859:        (isHTML && nsCoreUtils::HasClickListener(content)) ||
 39578:        HasUniversalAriaProperty(content) || roleMapEntry ||
 20521:        HasRelatedContent(content) || nsCoreUtils::IsXLink(content))) {
     1:     // This content is focusable or has an interesting dynamic content accessibility property.
     1:     // If it's interesting we need it in the accessibility hierarchy so that events or
     1:     // other accessibles can point to it, or so that it can hold a state, etc.
  1672:     if (isHTML) {
     1:       // Interesting HTML container which may have selectable text and/or embedded objects
 99901:       newAcc = new HyperTextAccessibleWrap(content, docAcc);
     1:     }
     1:     else {  // XUL, SVG, MathML etc.
     1:       // Interesting generic non-HTML container
 99648:       newAcc = new AccessibleWrap(content, docAcc);
     1:     }
     1:   }
     1: 
 64506:   return docAcc->BindToDocument(newAcc, roleMapEntry) ? newAcc : nsnull;
     1: }
     1: 
 43310: ////////////////////////////////////////////////////////////////////////////////
 43310: // nsAccessibilityService private
 43310: 
 79445: bool
 43310: nsAccessibilityService::Init()
 43310: {
 43310:   // Initialize accessible document manager.
 43310:   if (!nsAccDocManager::Init())
 80486:     return false;
 43310: 
 43310:   // Add observers.
 43310:   nsCOMPtr<nsIObserverService> observerService =
 43310:     mozilla::services::GetObserverService();
 43310:   if (!observerService)
 80486:     return false;
 43310: 
 80486:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);
 43310: 
 97849:   static const PRUnichar kInitIndicator[] = { '1', 0 };
 97849:   observerService->NotifyObservers(nsnull, "a11y-init-or-shutdown", kInitIndicator);
 97849: 
 99203: #ifdef DEBUG
 99203:   logging::CheckEnv();
 99203: #endif
 99203: 
 43310:   // Initialize accessibility.
 43310:   nsAccessNodeWrap::InitAccessibility();
 43310: 
105954: #ifdef MOZ_CRASHREPORTER
105954:   CrashReporter::
105954:     AnnotateCrashReport(NS_LITERAL_CSTRING("Accessibility"),
105954:                         NS_LITERAL_CSTRING("Active"));
105954: #endif
105954: 
 80486:   gIsShutdown = false;
 80486:   return true;
 43310: }
 43310: 
 43310: void
 43310: nsAccessibilityService::Shutdown()
 43310: {
 43310:   // Remove observers.
 43310:   nsCOMPtr<nsIObserverService> observerService =
 43310:       mozilla::services::GetObserverService();
 97849:   if (observerService) {
 43310:     observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
 43310: 
 97849:     static const PRUnichar kShutdownIndicator[] = { '0', 0 };
 97849:     observerService->NotifyObservers(nsnull, "a11y-init-or-shutdown", kShutdownIndicator);
 97849:   }
 97849: 
 43310:   // Stop accessible document loader.
 43310:   nsAccDocManager::Shutdown();
 43310: 
 43310:   // Application is going to be closed, shutdown accessibility and mark
 43310:   // accessibility service as shutdown to prevent calls of its methods.
 43310:   // Don't null accessibility service static member at this point to be safe
 43310:   // if someone will try to operate with it.
 43310: 
 43310:   NS_ASSERTION(!gIsShutdown, "Accessibility was shutdown already");
 43310: 
 80486:   gIsShutdown = true;
 43310: 
 43310:   nsAccessNodeWrap::ShutdownAccessibility();
 43310: }
 43310: 
 79445: bool
 39578: nsAccessibilityService::HasUniversalAriaProperty(nsIContent *aContent)
  6279: {
 39578:   // ARIA attributes that take token values (NMTOKEN, bool) are special cased
 39578:   // because of special value "undefined" (see HasDefinedARIAToken).
 78350:   return nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_atomic) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_busy) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_controls) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_describedby) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_disabled) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_dropeffect) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_flowto) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_grabbed) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_haspopup) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_hidden) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_invalid) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_label) ||
 78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_labelledby) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_live) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_owns) ||
 78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_relevant);
  6279: }
  6279: 
 99648: already_AddRefed<Accessible>
 43504: nsAccessibilityService::CreateAccessibleByType(nsIContent* aContent,
 99568:                                                DocAccessible* aDoc)
     1: {
 43504:   nsCOMPtr<nsIAccessibleProvider> accessibleProvider(do_QueryInterface(aContent));
  1477:   if (!accessibleProvider)
 38359:     return nsnull;
     1: 
     1:   PRInt32 type;
  1477:   nsresult rv = accessibleProvider->GetAccessibleType(&type);
 38359:   if (NS_FAILED(rv))
 38359:     return nsnull;
     1: 
 38359:   if (type == nsIAccessibleProvider::OuterDoc) {
 99648:     Accessible* accessible = new OuterDocAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 38359:   }
     1: 
 99648:   Accessible* accessible = nsnull;
     1:   switch (type)
     1:   {
     1: #ifdef MOZ_XUL
 10594:     case nsIAccessibleProvider::NoAccessible:
 38359:       return nsnull;
 38359: 
     1:     // XUL controls
     1:     case nsIAccessibleProvider::XULAlert:
101616:       accessible = new XULAlertAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULButton:
 95360:       accessible = new XULButtonAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULCheckbox:
 95360:       accessible = new XULCheckboxAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULColorPicker:
101616:       accessible = new XULColorPickerAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULColorPickerTile:
101616:       accessible = new XULColorPickerTileAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULCombobox:
101616:       accessible = new XULComboboxAccessible(aContent, aDoc);
     1:       break;
 46338: 
103750:     case nsIAccessibleProvider::XULDeck:
103750:       accessible = new XULDeckAccessible(aContent, aDoc);
103750:       break;
103750: 
     1:     case nsIAccessibleProvider::XULDropmarker:
 95360:       accessible = new XULDropmarkerAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULGroupbox:
 95360:       accessible = new XULGroupboxAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULImage:
     1:     {
 43504:       // Don't include nameless images in accessible tree.
 43504:       if (!aContent->HasAttr(kNameSpaceID_None,
 78350:                              nsGkAtoms::tooltiptext))
 38359:         return nsnull;
     1: 
100130:       accessible = new ImageAccessibleWrap(aContent, aDoc);
     1:       break;
 46338: 
     1:     }
     1:     case nsIAccessibleProvider::XULLink:
101616:       accessible = new XULLinkAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULListbox:
101616:       accessible = new XULListboxAccessibleWrap(aContent, aDoc);
     1:       break;
 46338: 
 11854:     case nsIAccessibleProvider::XULListCell:
101616:       accessible = new XULListCellAccessibleWrap(aContent, aDoc);
 11854:       break;
 46338: 
  6094:     case nsIAccessibleProvider::XULListHead:
101616:       accessible = new XULColumAccessible(aContent, aDoc);
  6094:       break;
 46338: 
  6094:     case nsIAccessibleProvider::XULListHeader:
101616:       accessible = new XULColumnItemAccessible(aContent, aDoc);
  6094:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULListitem:
101616:       accessible = new XULListitemAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULMenubar:
101616:       accessible = new XULMenubarAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULMenuitem:
101616:       accessible = new XULMenuitemAccessibleWrap(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULMenupopup:
     1:     {
     1: #ifdef MOZ_ACCESSIBILITY_ATK
     1:       // ATK considers this node to be redundant when within menubars, and it makes menu
     1:       // navigation with assistive technologies more difficult
     1:       // XXX In the future we will should this for consistency across the nsIAccessible
     1:       // implementations on each platform for a consistent scripting environment, but
 99648:       // then strip out redundant accessibles in the AccessibleWrap class for each platform.
 43504:       nsIContent *parent = aContent->GetParent();
 78350:       if (parent && parent->NodeInfo()->Equals(nsGkAtoms::menu,
 43504:                                                kNameSpaceID_XUL))
 38359:         return nsnull;
     1: #endif
101616:       accessible = new XULMenupopupAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     }
     1:     case nsIAccessibleProvider::XULMenuSeparator:
101616:       accessible = new XULMenuSeparatorAccessible(aContent, aDoc);
     1:       break;
 46338: 
 10594:     case nsIAccessibleProvider::XULPane:
101054:       accessible = new EnumRoleAccessible(aContent, aDoc, roles::PANE);
 10594:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULProgressMeter:
 89799:       accessible = new XULProgressMeterAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULStatusBar:
 95360:       accessible = new XULStatusBarAccessible(aContent, aDoc);
     1:       break;
 46338: 
  4274:     case nsIAccessibleProvider::XULScale:
101616:       accessible = new XULSliderAccessible(aContent, aDoc);
  4274:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULRadioButton:
 95360:       accessible = new XULRadioButtonAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULRadioGroup:
 95360:       accessible = new XULRadioGroupAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULTab:
101616:       accessible = new XULTabAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULTabs:
101616:       accessible = new XULTabsAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULText:
101616:       accessible = new XULLabelAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULTextBox:
 95360:       accessible = new XULTextFieldAccessible(aContent, aDoc);
     1:       break;
 46338: 
  4274:     case nsIAccessibleProvider::XULThumb:
101616:       accessible = new XULThumbAccessible(aContent, aDoc);
  4274:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULTree:
 89799:       return CreateAccessibleForXULTree(aContent, aDoc);
 38359: 
     1:     case nsIAccessibleProvider::XULTreeColumns:
101616:       accessible = new XULTreeColumAccessible(aContent, aDoc);
     1:       break;
 46338: 
  6094:     case nsIAccessibleProvider::XULTreeColumnItem:
101616:       accessible = new XULColumnItemAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULToolbar:
 95360:       accessible = new XULToolbarAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULToolbarSeparator:
 95360:       accessible = new XULToolbarSeparatorAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XULTooltip:
101616:       accessible = new XULTooltipAccessible(aContent, aDoc);
     1:       break;
 46338: 
  3325:     case nsIAccessibleProvider::XULToolbarButton:
 95360:       accessible = new XULToolbarButtonAccessible(aContent, aDoc);
  3325:       break;
 46338: 
     1: #endif // MOZ_XUL
     1: 
     1:     // XForms elements
     1:     case nsIAccessibleProvider::XFormsContainer:
 89799:       accessible = new nsXFormsContainerAccessible(aContent, aDoc);
     1:       break;
     1: 
     1:     case nsIAccessibleProvider::XFormsLabel:
 89799:       accessible = new nsXFormsLabelAccessible(aContent, aDoc);
     1:       break;
 46338: 
 42263:     case nsIAccessibleProvider::XFormsOutput:
 89799:       accessible = new nsXFormsOutputAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsTrigger:
 89799:       accessible = new nsXFormsTriggerAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsInput:
 89799:       accessible = new nsXFormsInputAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsInputBoolean:
 89799:       accessible = new nsXFormsInputBooleanAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsInputDate:
 89799:       accessible = new nsXFormsInputDateAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsSecret:
 89799:       accessible = new nsXFormsSecretAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsSliderRange:
 89799:       accessible = new nsXFormsRangeAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsSelect:
 89799:       accessible = new nsXFormsSelectAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsChoices:
 89799:       accessible = new nsXFormsChoicesAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsSelectFull:
 89799:       accessible = new nsXFormsSelectFullAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsItemCheckgroup:
 89799:       accessible = new nsXFormsItemCheckgroupAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsItemRadiogroup:
 89799:       accessible = new nsXFormsItemRadiogroupAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsSelectCombobox:
 89799:       accessible = new nsXFormsSelectComboboxAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsItemCombobox:
 89799:       accessible = new nsXFormsItemComboboxAccessible(aContent, aDoc);
     1:       break;
     1: 
     1:     case nsIAccessibleProvider::XFormsDropmarkerWidget:
 89799:       accessible = new nsXFormsDropmarkerWidgetAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsCalendarWidget:
 89799:       accessible = new nsXFormsCalendarWidgetAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     case nsIAccessibleProvider::XFormsComboboxPopupWidget:
 89799:       accessible = new nsXFormsComboboxPopupWidgetAccessible(aContent, aDoc);
     1:       break;
 46338: 
     1:     default:
 38359:       return nsnull;
     1:   }
     1: 
 46338:   NS_IF_ADDREF(accessible);
 46338:   return accessible;
 46338: }
 46338: 
 99648: already_AddRefed<Accessible>
 46338: nsAccessibilityService::CreateHTMLAccessibleByMarkup(nsIFrame* aFrame,
 46338:                                                      nsIContent* aContent,
 99568:                                                      DocAccessible* aDoc)
 46338: {
 46338:   // This method assumes we're in an HTML namespace.
 46338:   nsIAtom* tag = aContent->Tag();
 83419:   if (tag == nsGkAtoms::figcaption) {
 99648:     Accessible* accessible = new HTMLFigcaptionAccessible(aContent, aDoc);
 83419:     NS_IF_ADDREF(accessible);
 83419:     return accessible;
 83419:   }
 83419: 
 83419:   if (tag == nsGkAtoms::figure) {
 99648:     Accessible* accessible = new HTMLFigureAccessible(aContent, aDoc);
 83419:     NS_IF_ADDREF(accessible);
 83419:     return accessible;
 83419:   }
 83419: 
 78350:   if (tag == nsGkAtoms::legend) {
 99648:     Accessible* accessible = new HTMLLegendAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::option) {
101260:     Accessible* accessible = new HTMLSelectOptionAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::optgroup) {
101260:     Accessible* accessible = new HTMLSelectOptGroupAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::ul || tag == nsGkAtoms::ol ||
 78350:       tag == nsGkAtoms::dl) {
 99648:     Accessible* accessible = new HTMLListAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::a) {
101056:     // Only some roles truly enjoy life as HTMLLinkAccessibles, for details
 46338:     // see closed bug 494807.
 95490:     nsRoleMapEntry* roleMapEntry = aria::GetRoleMap(aContent);
 87094:     if (roleMapEntry && roleMapEntry->role != roles::NOTHING &&
 87094:         roleMapEntry->role != roles::LINK) {
 99901:       Accessible* accessible = new HyperTextAccessibleWrap(aContent, aDoc);
 46338:       NS_IF_ADDREF(accessible);
 46338:       return accessible;
 46338:     }
 46338: 
101056:     Accessible* accessible = new HTMLLinkAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::dt ||
 78350:       (tag == nsGkAtoms::li &&
 78350:        aFrame->GetType() != nsGkAtoms::blockFrame)) {
 46338:     // Normally for li, it is created by the list item frame (in nsBlockFrame)
 46338:     // which knows about the bullet frame; however, in this case the list item
 46338:     // must have been styled using display: foo
 99648:     Accessible* accessible = new HTMLLIAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::abbr ||
 78350:       tag == nsGkAtoms::acronym ||
 78350:       tag == nsGkAtoms::blockquote ||
 78350:       tag == nsGkAtoms::dd ||
 78350:       tag == nsGkAtoms::form ||
 78350:       tag == nsGkAtoms::h1 ||
 78350:       tag == nsGkAtoms::h2 ||
 78350:       tag == nsGkAtoms::h3 ||
 78350:       tag == nsGkAtoms::h4 ||
 78350:       tag == nsGkAtoms::h5 ||
 78350:       tag == nsGkAtoms::h6 ||
 78350:       tag == nsGkAtoms::q) {
 99901:     Accessible* accessible = new HyperTextAccessibleWrap(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 46338:   if (nsCoreUtils::IsHTMLTableHeader(aContent)) {
101616:     Accessible* accessible = new HTMLTableHeaderCellAccessibleWrap(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 78350:   if (tag == nsGkAtoms::output) {
100129:     Accessible* accessible = new HTMLOutputAccessible(aContent, aDoc);
 54466:     NS_IF_ADDREF(accessible);
 54466:     return accessible;
 54466:   }
 54466: 
 78350:   if (tag == nsGkAtoms::progress) {
 99648:     Accessible* accessible =
 89799:       new HTMLProgressMeterAccessible(aContent, aDoc);
 69737:     NS_IF_ADDREF(accessible);
 69737:     return accessible;
 69737:   }
 69737: 
 46338:   return nsnull;
 38359:  }
     1: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // nsIAccessibilityService (DON'T put methods here)
     1: 
 99648: Accessible*
 46207: nsAccessibilityService::AddNativeRootAccessible(void* aAtkAccessible)
     1: {
     1: #ifdef MOZ_ACCESSIBILITY_ATK
 96920:   ApplicationAccessible* applicationAcc =
  2063:     nsAccessNode::GetApplicationAccessible();
 46207:   if (!applicationAcc)
 46207:     return nsnull;
  2063: 
 97643:   nsRefPtr<NativeRootAccessibleWrap> nativeRootAcc =
 97643:     new NativeRootAccessibleWrap(static_cast<AtkObject*>(aAtkAccessible));
 46207:   if (!nativeRootAcc)
 46207:     return nsnull;
     1: 
 46207:   if (applicationAcc->AppendChild(nativeRootAcc))
 46207:     return nativeRootAcc;
     1: #endif
 46207: 
 46207:   return nsnull;
     1: }
     1: 
 46207: void
 99648: nsAccessibilityService::RemoveNativeRootAccessible(Accessible* aAccessible)
     1: {
     1: #ifdef MOZ_ACCESSIBILITY_ATK
 96920:   ApplicationAccessible* applicationAcc =
  2063:     nsAccessNode::GetApplicationAccessible();
  2063: 
 46207:   if (applicationAcc)
 46207:     applicationAcc->RemoveChild(aAccessible);
     1: #endif
     1: }
     1: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // NS_GetAccessibilityService
 38359: ////////////////////////////////////////////////////////////////////////////////
     1: 
 37808: /**
 37808:  * Return accessibility service; creating one if necessary.
 37808:  */
     1: nsresult
 37808: NS_GetAccessibilityService(nsIAccessibilityService** aResult)
     1: {
 30820:   NS_ENSURE_TRUE(aResult, NS_ERROR_NULL_POINTER);
 30820:   *aResult = nsnull;
     1:  
 43310:   if (nsAccessibilityService::gAccessibilityService) {
 43310:     NS_ADDREF(*aResult = nsAccessibilityService::gAccessibilityService);
 43310:     return NS_OK;
     1:   }
 30820: 
 43310:   nsRefPtr<nsAccessibilityService> service = new nsAccessibilityService();
 43310:   NS_ENSURE_TRUE(service, NS_ERROR_OUT_OF_MEMORY);
 43310: 
 43310:   if (!service->Init()) {
 43310:     service->Shutdown();
 43310:     return NS_ERROR_FAILURE;
 43310:   }
 43310: 
 76374:   statistics::A11yInitialized();
 76374: 
 43310:   nsAccessibilityService::gAccessibilityService = service;
 43310:   NS_ADDREF(*aResult = service);
 43310: 
 30820:   return NS_OK;
     1: }
 30820: 
 38359: ////////////////////////////////////////////////////////////////////////////////
 38359: // nsAccessibilityService private (DON'T put methods here)
 38359: 
 99648: already_AddRefed<Accessible>
 38359: nsAccessibilityService::CreateAccessibleForDeckChild(nsIFrame* aFrame,
 43504:                                                      nsIContent* aContent,
 99568:                                                      DocAccessible* aDoc)
  1477: {
 78350:   if (aFrame->GetType() == nsGkAtoms::boxFrame ||
 78350:       aFrame->GetType() == nsGkAtoms::scrollFrame) {
  1477: 
 38359:     nsIFrame* parentFrame = aFrame->GetParent();
 78350:     if (parentFrame && parentFrame->GetType() == nsGkAtoms::deckFrame) {
  7840:       // If deck frame is for xul:tabpanels element then the given node has
  7840:       // tabpanel accessible.
  7840:       nsCOMPtr<nsIContent> parentContent = parentFrame->GetContent();
 15855: #ifdef MOZ_XUL
 78350:       if (parentContent->NodeInfo()->Equals(nsGkAtoms::tabpanels,
  7840:                                             kNameSpaceID_XUL)) {
101616:         Accessible* accessible = new XULTabpanelAccessible(aContent, aDoc);
 46338:         NS_IF_ADDREF(accessible);
 46338:         return accessible;
 46338:       }
 15855: #endif
101054:       Accessible* accessible = new EnumRoleAccessible(aContent, aDoc,
 87094:                                                       roles::PROPERTYPAGE);
 46338:       NS_IF_ADDREF(accessible);
 46338:       return accessible;
  1477:     }
  1477:   }
  1477: 
 46338:   return nsnull;
  1477: }
 31673: 
 31673: #ifdef MOZ_XUL
 99648: already_AddRefed<Accessible>
 43504: nsAccessibilityService::CreateAccessibleForXULTree(nsIContent* aContent,
 99568:                                                    DocAccessible* aDoc)
 31673: {
 43504:   nsCOMPtr<nsITreeBoxObject> treeBoxObj = nsCoreUtils::GetTreeBoxObject(aContent);
 31673:   if (!treeBoxObj)
 38359:     return nsnull;
 31673: 
 31673:   nsCOMPtr<nsITreeColumns> treeColumns;
 31673:   treeBoxObj->GetColumns(getter_AddRefs(treeColumns));
 31673:   if (!treeColumns)
 38359:     return nsnull;
 38359: 
 31673:   PRInt32 count = 0;
 31673:   treeColumns->GetCount(&count);
 31673: 
 46338:   // Outline of list accessible.
 46338:   if (count == 1) {
101616:     Accessible* accessible = new XULTreeAccessible(aContent, aDoc);
 46338:     NS_IF_ADDREF(accessible);
 46338:     return accessible;
 46338:   }
 46338: 
 46338:   // Table or tree table accessible.
101616:   Accessible* accessible = new XULTreeGridAccessibleWrap(aContent, aDoc);
 46338:   NS_IF_ADDREF(accessible);
 46338:   return accessible;
 31673: }
 31673: #endif
 79384: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: // Services
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: 
102366: namespace mozilla {
102366: namespace a11y {
102366: 
102366: FocusManager*
102366: FocusMgr()
 79384: {
 79384:   return nsAccessibilityService::gAccessibilityService;
 79384: }
102366: 
102366: EPlatformDisabledState
102366: PlatformDisabledState()
102366: {
102366:   static int disabledState = 0xff;
102366: 
102366:   if (disabledState == 0xff) {
102366:     disabledState = Preferences::GetInt("accessibility.force_disabled", 0);
102366:     if (disabledState < ePlatformIsForceEnabled)
102366:       disabledState = ePlatformIsForceEnabled;
102366:     else if (disabledState > ePlatformIsDisabled)
102366:       disabledState = ePlatformIsDisabled;
102366:   }
102366: 
102366:   return (EPlatformDisabledState)disabledState;
102366: }
102366: 
102366: }
102366: }
