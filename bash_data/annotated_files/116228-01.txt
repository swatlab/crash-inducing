 74460: /* vim: set ts=8 sw=8 noexpandtab: */
 27035: //  qcms
 27035: //  Copyright (C) 2009 Mozilla Corporation
 27035: //  Copyright (C) 1998-2007 Marti Maria
 27035: //
 27035: // Permission is hereby granted, free of charge, to any person obtaining 
 27035: // a copy of this software and associated documentation files (the "Software"), 
 27035: // to deal in the Software without restriction, including without limitation 
 27035: // the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 27035: // and/or sell copies of the Software, and to permit persons to whom the Software 
 27035: // is furnished to do so, subject to the following conditions:
 27035: //
 27035: // The above copyright notice and this permission notice shall be included in 
 27035: // all copies or substantial portions of the Software.
 27035: //
 27035: // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 27035: // EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
 27035: // THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 27035: // NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
 27035: // LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
 27035: // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
 27035: // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 27035: 
 27035: #include <stdlib.h>
 27035: #include <math.h>
 27035: #include <assert.h>
 74460: #include <string.h> //memcpy
 27035: #include "qcmsint.h"
 74460: #include "chain.h"
 74460: #include "matrix.h"
 74460: #include "transform_util.h"
 27035: 
 35161: /* for MSVC, GCC, Intel, and Sun compilers */
 35161: #if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(_M_AMD64) || defined(__x86_64__) || defined(__x86_64)
 27035: #define X86
 35161: #endif /* _M_IX86 || __i386__ || __i386 || _M_AMD64 || __x86_64__ || __x86_64 */
 27035: 
 27035: // Build a White point, primary chromas transfer matrix from RGB to CIE XYZ
 27035: // This is just an approximation, I am not handling all the non-linear
 27035: // aspects of the RGB to XYZ process, and assumming that the gamma correction
 27035: // has transitive property in the tranformation chain.
 27035: //
 27035: // the alghoritm:
 27035: //
 27035: //            - First I build the absolute conversion matrix using
 27035: //              primaries in XYZ. This matrix is next inverted
 27035: //            - Then I eval the source white point across this matrix
 27035: //              obtaining the coeficients of the transformation
 27035: //            - Then, I apply these coeficients to the original matrix
 27035: static struct matrix build_RGB_to_XYZ_transfer_matrix(qcms_CIE_xyY white, qcms_CIE_xyYTRIPLE primrs)
 27035: {
 27035: 	struct matrix primaries;
 27035: 	struct matrix primaries_invert;
 27035: 	struct matrix result;
 27035: 	struct vector white_point;
 27035: 	struct vector coefs;
 27035: 
 27035: 	double xn, yn;
 27035: 	double xr, yr;
 27035: 	double xg, yg;
 27035: 	double xb, yb;
 27035: 
 27035: 	xn = white.x;
 27035: 	yn = white.y;
 27035: 
 27597: 	if (yn == 0.0)
 27597: 		return matrix_invalid();
 27597: 
 27035: 	xr = primrs.red.x;
 27035: 	yr = primrs.red.y;
 27035: 	xg = primrs.green.x;
 27035: 	yg = primrs.green.y;
 27035: 	xb = primrs.blue.x;
 27035: 	yb = primrs.blue.y;
 27035: 
 27035: 	primaries.m[0][0] = xr;
 27035: 	primaries.m[0][1] = xg;
 27035: 	primaries.m[0][2] = xb;
 27035: 
 27035: 	primaries.m[1][0] = yr;
 27035: 	primaries.m[1][1] = yg;
 27035: 	primaries.m[1][2] = yb;
 27035: 
 27035: 	primaries.m[2][0] = 1 - xr - yr;
 27035: 	primaries.m[2][1] = 1 - xg - yg;
 27035: 	primaries.m[2][2] = 1 - xb - yb;
 27035: 	primaries.invalid = false;
 27035: 
 27035: 	white_point.v[0] = xn/yn;
 27035: 	white_point.v[1] = 1.;
 27035: 	white_point.v[2] = (1.0-xn-yn)/yn;
 27035: 
 27035: 	primaries_invert = matrix_invert(primaries);
 27035: 
 27035: 	coefs = matrix_eval(primaries_invert, white_point);
 27035: 
 27035: 	result.m[0][0] = coefs.v[0]*xr;
 27035: 	result.m[0][1] = coefs.v[1]*xg;
 27035: 	result.m[0][2] = coefs.v[2]*xb;
 27035: 
 27035: 	result.m[1][0] = coefs.v[0]*yr;
 27035: 	result.m[1][1] = coefs.v[1]*yg;
 27035: 	result.m[1][2] = coefs.v[2]*yb;
 27035: 
 27035: 	result.m[2][0] = coefs.v[0]*(1.-xr-yr);
 27035: 	result.m[2][1] = coefs.v[1]*(1.-xg-yg);
 27035: 	result.m[2][2] = coefs.v[2]*(1.-xb-yb);
 27035: 	result.invalid = primaries_invert.invalid;
 27035: 
 27035: 	return result;
 27035: }
 27035: 
 27035: struct CIE_XYZ {
 27035: 	double X;
 27035: 	double Y;
 27035: 	double Z;
 27035: };
 27035: 
 27035: /* CIE Illuminant D50 */
 27035: static const struct CIE_XYZ D50_XYZ = {
 27035: 	0.9642,
 27035: 	1.0000,
 27035: 	0.8249
 27035: };
 27035: 
 27035: /* from lcms: xyY2XYZ()
 27035:  * corresponds to argyll: icmYxy2XYZ() */
 27035: static struct CIE_XYZ xyY2XYZ(qcms_CIE_xyY source)
 27035: {
 27035: 	struct CIE_XYZ dest;
 27035: 	dest.X = (source.x / source.y) * source.Y;
 27035: 	dest.Y = source.Y;
 27035: 	dest.Z = ((1 - source.x - source.y) / source.y) * source.Y;
 27035: 	return dest;
 27035: }
 27035: 
 27035: /* from lcms: ComputeChromaticAdaption */
 27035: // Compute chromatic adaption matrix using chad as cone matrix
 27035: static struct matrix
 27035: compute_chromatic_adaption(struct CIE_XYZ source_white_point,
 27035:                            struct CIE_XYZ dest_white_point,
 27035:                            struct matrix chad)
 27035: {
 27035: 	struct matrix chad_inv;
 27035: 	struct vector cone_source_XYZ, cone_source_rgb;
 27035: 	struct vector cone_dest_XYZ, cone_dest_rgb;
 27035: 	struct matrix cone, tmp;
 27035: 
 27035: 	tmp = chad;
 27035: 	chad_inv = matrix_invert(tmp);
 27035: 
 27035: 	cone_source_XYZ.v[0] = source_white_point.X;
 27035: 	cone_source_XYZ.v[1] = source_white_point.Y;
 27035: 	cone_source_XYZ.v[2] = source_white_point.Z;
 27035: 
 27035: 	cone_dest_XYZ.v[0] = dest_white_point.X;
 27035: 	cone_dest_XYZ.v[1] = dest_white_point.Y;
 27035: 	cone_dest_XYZ.v[2] = dest_white_point.Z;
 27035: 
 27035: 	cone_source_rgb = matrix_eval(chad, cone_source_XYZ);
 27035: 	cone_dest_rgb   = matrix_eval(chad, cone_dest_XYZ);
 27035: 
 27035: 	cone.m[0][0] = cone_dest_rgb.v[0]/cone_source_rgb.v[0];
 27035: 	cone.m[0][1] = 0;
 27035: 	cone.m[0][2] = 0;
 27035: 	cone.m[1][0] = 0;
 27035: 	cone.m[1][1] = cone_dest_rgb.v[1]/cone_source_rgb.v[1];
 27035: 	cone.m[1][2] = 0;
 27035: 	cone.m[2][0] = 0;
 27035: 	cone.m[2][1] = 0;
 27035: 	cone.m[2][2] = cone_dest_rgb.v[2]/cone_source_rgb.v[2];
 27035: 	cone.invalid = false;
 27035: 
 27035: 	// Normalize
 27035: 	return matrix_multiply(chad_inv, matrix_multiply(cone, chad));
 27035: }
 27035: 
 27035: /* from lcms: cmsAdaptionMatrix */
 27035: // Returns the final chrmatic adaptation from illuminant FromIll to Illuminant ToIll
 27035: // Bradford is assumed
 27035: static struct matrix
 27035: adaption_matrix(struct CIE_XYZ source_illumination, struct CIE_XYZ target_illumination)
 27035: {
 27035: 	struct matrix lam_rigg = {{ // Bradford matrix
 27035: 	                         {  0.8951,  0.2664, -0.1614 },
 27035: 	                         { -0.7502,  1.7135,  0.0367 },
 27035: 	                         {  0.0389, -0.0685,  1.0296 }
 27035: 	                         }};
 27035: 	return compute_chromatic_adaption(source_illumination, target_illumination, lam_rigg);
 27035: }
 27035: 
 27035: /* from lcms: cmsAdaptMatrixToD50 */
 27035: static struct matrix adapt_matrix_to_D50(struct matrix r, qcms_CIE_xyY source_white_pt)
 27035: {
 27035: 	struct CIE_XYZ Dn;
 27035: 	struct matrix Bradford;
 27597: 
 27597: 	if (source_white_pt.y == 0.0)
 27597: 		return matrix_invalid();
 27597: 
 27035: 	Dn = xyY2XYZ(source_white_pt);
 27035: 
 27035: 	Bradford = adaption_matrix(Dn, D50_XYZ);
 27035: 	return matrix_multiply(Bradford, r);
 27035: }
 27035: 
 27598: qcms_bool set_rgb_colorants(qcms_profile *profile, qcms_CIE_xyY white_point, qcms_CIE_xyYTRIPLE primaries)
 27035: {
 27035: 	struct matrix colorants;
 27035: 	colorants = build_RGB_to_XYZ_transfer_matrix(white_point, primaries);
 27035: 	colorants = adapt_matrix_to_D50(colorants, white_point);
 27035: 
 27598: 	if (colorants.invalid)
 27598: 		return false;
 27598: 
 27035: 	/* note: there's a transpose type of operation going on here */
 27035: 	profile->redColorant.X = double_to_s15Fixed16Number(colorants.m[0][0]);
 27035: 	profile->redColorant.Y = double_to_s15Fixed16Number(colorants.m[1][0]);
 27035: 	profile->redColorant.Z = double_to_s15Fixed16Number(colorants.m[2][0]);
 27035: 
 27035: 	profile->greenColorant.X = double_to_s15Fixed16Number(colorants.m[0][1]);
 27035: 	profile->greenColorant.Y = double_to_s15Fixed16Number(colorants.m[1][1]);
 27035: 	profile->greenColorant.Z = double_to_s15Fixed16Number(colorants.m[2][1]);
 27035: 
 27035: 	profile->blueColorant.X = double_to_s15Fixed16Number(colorants.m[0][2]);
 27035: 	profile->blueColorant.Y = double_to_s15Fixed16Number(colorants.m[1][2]);
 27035: 	profile->blueColorant.Z = double_to_s15Fixed16Number(colorants.m[2][2]);
 27598: 
 27598: 	return true;
 27035: }
 27035: 
 27035: #if 0
 27035: static void qcms_transform_data_rgb_out_pow(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 27035: 	int i;
 27035: 	float (*mat)[4] = transform->matrix;
 27035: 	for (i=0; i<length; i++) {
 27035: 		unsigned char device_r = *src++;
 27035: 		unsigned char device_g = *src++;
 27035: 		unsigned char device_b = *src++;
 27035: 
 27035: 		float linear_r = transform->input_gamma_table_r[device_r];
 27035: 		float linear_g = transform->input_gamma_table_g[device_g];
 27035: 		float linear_b = transform->input_gamma_table_b[device_b];
 27035: 
 27035: 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 27035: 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 27035: 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 27035: 
 27035: 		float out_device_r = pow(out_linear_r, transform->out_gamma_r);
 27035: 		float out_device_g = pow(out_linear_g, transform->out_gamma_g);
 27035: 		float out_device_b = pow(out_linear_b, transform->out_gamma_b);
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(255*out_device_r);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(255*out_device_g);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(255*out_device_b);
116034: 		dest += RGB_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: #endif
 27035: 
 27035: static void qcms_transform_data_gray_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		float out_device_r, out_device_g, out_device_b;
 27035: 		unsigned char device = *src++;
 27035: 
 27035: 		float linear = transform->input_gamma_table_gray[device];
 27035: 
 27035:                 out_device_r = lut_interp_linear(linear, transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 27035: 		out_device_g = lut_interp_linear(linear, transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 27035: 		out_device_b = lut_interp_linear(linear, transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
116034: 		dest += RGB_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 29150: /* Alpha is not corrected.
 29150:    A rationale for this is found in Alvy Ray's "Should Alpha Be Nonlinear If
 29150:    RGB Is?" Tech Memo 17 (December 14, 1998).
 29150: 	See: ftp://ftp.alvyray.com/Acrobat/17_Nonln.pdf
 29150: */
 29150: 
 27035: static void qcms_transform_data_graya_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		float out_device_r, out_device_g, out_device_b;
 27035: 		unsigned char device = *src++;
 27035: 		unsigned char alpha = *src++;
 27035: 
 27035: 		float linear = transform->input_gamma_table_gray[device];
 27035: 
 27035:                 out_device_r = lut_interp_linear(linear, transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 27035: 		out_device_g = lut_interp_linear(linear, transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 27035: 		out_device_b = lut_interp_linear(linear, transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
116034: 		dest[OUTPUT_A_INDEX] = alpha;
116034: 		dest += RGBA_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 27035: 
 27035: static void qcms_transform_data_gray_out_precache(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device = *src++;
 27035: 		uint16_t gray;
 27035: 
 27035: 		float linear = transform->input_gamma_table_gray[device];
 27035: 
 27035: 		/* we could round here... */
 43096: 		gray = linear * PRECACHE_OUTPUT_MAX;
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = transform->output_table_r->data[gray];
116034: 		dest[OUTPUT_G_INDEX] = transform->output_table_g->data[gray];
116034: 		dest[OUTPUT_B_INDEX] = transform->output_table_b->data[gray];
116034: 		dest += RGB_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 27035: static void qcms_transform_data_graya_out_precache(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device = *src++;
 27035: 		unsigned char alpha = *src++;
 27035: 		uint16_t gray;
 27035: 
 27035: 		float linear = transform->input_gamma_table_gray[device];
 27035: 
 27035: 		/* we could round here... */
 43096: 		gray = linear * PRECACHE_OUTPUT_MAX;
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = transform->output_table_r->data[gray];
116034: 		dest[OUTPUT_G_INDEX] = transform->output_table_g->data[gray];
116034: 		dest[OUTPUT_B_INDEX] = transform->output_table_b->data[gray];
116034: 		dest[OUTPUT_A_INDEX] = alpha;
116034: 		dest += RGBA_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 27035: static void qcms_transform_data_rgb_out_lut_precache(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	float (*mat)[4] = transform->matrix;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device_r = *src++;
 27035: 		unsigned char device_g = *src++;
 27035: 		unsigned char device_b = *src++;
 27035: 		uint16_t r, g, b;
 27035: 
 27035: 		float linear_r = transform->input_gamma_table_r[device_r];
 27035: 		float linear_g = transform->input_gamma_table_g[device_g];
 27035: 		float linear_b = transform->input_gamma_table_b[device_b];
 27035: 
 27035: 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 27035: 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 27035: 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 27035: 
 27035: 		out_linear_r = clamp_float(out_linear_r);
 27035: 		out_linear_g = clamp_float(out_linear_g);
 27035: 		out_linear_b = clamp_float(out_linear_b);
 27035: 
 27035: 		/* we could round here... */
 43096: 		r = out_linear_r * PRECACHE_OUTPUT_MAX;
 43096: 		g = out_linear_g * PRECACHE_OUTPUT_MAX;
 43096: 		b = out_linear_b * PRECACHE_OUTPUT_MAX;
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = transform->output_table_r->data[r];
116034: 		dest[OUTPUT_G_INDEX] = transform->output_table_g->data[g];
116228: 		dest[OUTPUT_B_INDEX] = transform->output_table_b->data[b];
116034: 		dest += RGB_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 27035: static void qcms_transform_data_rgba_out_lut_precache(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	float (*mat)[4] = transform->matrix;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device_r = *src++;
 27035: 		unsigned char device_g = *src++;
 27035: 		unsigned char device_b = *src++;
 27035: 		unsigned char alpha = *src++;
 27035: 		uint16_t r, g, b;
 27035: 
 27035: 		float linear_r = transform->input_gamma_table_r[device_r];
 27035: 		float linear_g = transform->input_gamma_table_g[device_g];
 27035: 		float linear_b = transform->input_gamma_table_b[device_b];
 27035: 
 27035: 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 27035: 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 27035: 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 27035: 
 27035: 		out_linear_r = clamp_float(out_linear_r);
 27035: 		out_linear_g = clamp_float(out_linear_g);
 27035: 		out_linear_b = clamp_float(out_linear_b);
 27035: 
 27035: 		/* we could round here... */
 43096: 		r = out_linear_r * PRECACHE_OUTPUT_MAX;
 43096: 		g = out_linear_g * PRECACHE_OUTPUT_MAX;
 43096: 		b = out_linear_b * PRECACHE_OUTPUT_MAX;
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = transform->output_table_r->data[r];
116034: 		dest[OUTPUT_G_INDEX] = transform->output_table_g->data[g];
116034: 		dest[OUTPUT_B_INDEX] = transform->output_table_b->data[b];
116034: 		dest[OUTPUT_A_INDEX] = alpha;
116034: 		dest += RGBA_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 74460: // Not used
 74460: /* 
 74460: static void qcms_transform_data_clut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
 74460: 	unsigned int i;
 74460: 	int xy_len = 1;
 74460: 	int x_len = transform->grid_size;
 74460: 	int len = x_len * x_len;
 74460: 	float* r_table = transform->r_clut;
 74460: 	float* g_table = transform->g_clut;
 74460: 	float* b_table = transform->b_clut;
 74460:   
 74460: 	for (i = 0; i < length; i++) {
 74460: 		unsigned char in_r = *src++;
 74460: 		unsigned char in_g = *src++;
 74460: 		unsigned char in_b = *src++;
 74460: 		float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
 74460: 
 74460: 		int x = floor(linear_r * (transform->grid_size-1));
 74460: 		int y = floor(linear_g * (transform->grid_size-1));
 74460: 		int z = floor(linear_b * (transform->grid_size-1));
 74460: 		int x_n = ceil(linear_r * (transform->grid_size-1));
 74460: 		int y_n = ceil(linear_g * (transform->grid_size-1));
 74460: 		int z_n = ceil(linear_b * (transform->grid_size-1));
 74460: 		float x_d = linear_r * (transform->grid_size-1) - x; 
 74460: 		float y_d = linear_g * (transform->grid_size-1) - y;
 74460: 		float z_d = linear_b * (transform->grid_size-1) - z; 
 74460: 
 74460: 		float r_x1 = lerp(CLU(r_table,x,y,z), CLU(r_table,x_n,y,z), x_d);
 74460: 		float r_x2 = lerp(CLU(r_table,x,y_n,z), CLU(r_table,x_n,y_n,z), x_d);
 74460: 		float r_y1 = lerp(r_x1, r_x2, y_d);
 74460: 		float r_x3 = lerp(CLU(r_table,x,y,z_n), CLU(r_table,x_n,y,z_n), x_d);
 74460: 		float r_x4 = lerp(CLU(r_table,x,y_n,z_n), CLU(r_table,x_n,y_n,z_n), x_d);
 74460: 		float r_y2 = lerp(r_x3, r_x4, y_d);
 74460: 		float clut_r = lerp(r_y1, r_y2, z_d);
 74460: 
 74460: 		float g_x1 = lerp(CLU(g_table,x,y,z), CLU(g_table,x_n,y,z), x_d);
 74460: 		float g_x2 = lerp(CLU(g_table,x,y_n,z), CLU(g_table,x_n,y_n,z), x_d);
 74460: 		float g_y1 = lerp(g_x1, g_x2, y_d);
 74460: 		float g_x3 = lerp(CLU(g_table,x,y,z_n), CLU(g_table,x_n,y,z_n), x_d);
 74460: 		float g_x4 = lerp(CLU(g_table,x,y_n,z_n), CLU(g_table,x_n,y_n,z_n), x_d);
 74460: 		float g_y2 = lerp(g_x3, g_x4, y_d);
 74460: 		float clut_g = lerp(g_y1, g_y2, z_d);
 74460: 
 74460: 		float b_x1 = lerp(CLU(b_table,x,y,z), CLU(b_table,x_n,y,z), x_d);
 74460: 		float b_x2 = lerp(CLU(b_table,x,y_n,z), CLU(b_table,x_n,y_n,z), x_d);
 74460: 		float b_y1 = lerp(b_x1, b_x2, y_d);
 74460: 		float b_x3 = lerp(CLU(b_table,x,y,z_n), CLU(b_table,x_n,y,z_n), x_d);
 74460: 		float b_x4 = lerp(CLU(b_table,x,y_n,z_n), CLU(b_table,x_n,y_n,z_n), x_d);
 74460: 		float b_y2 = lerp(b_x3, b_x4, y_d);
 74460: 		float clut_b = lerp(b_y1, b_y2, z_d);
 74460: 
 74460: 		*dest++ = clamp_u8(clut_r*255.0f);
 74460: 		*dest++ = clamp_u8(clut_g*255.0f);
 74460: 		*dest++ = clamp_u8(clut_b*255.0f);
 74460: 	}	
 74460: }
 74460: */
 74460: 
 74460: // Using lcms' tetra interpolation algorithm.
 74460: static void qcms_transform_data_tetra_clut_rgba(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
 74460: 	unsigned int i;
 74460: 	int xy_len = 1;
 74460: 	int x_len = transform->grid_size;
 74460: 	int len = x_len * x_len;
 74460: 	float* r_table = transform->r_clut;
 74460: 	float* g_table = transform->g_clut;
 74460: 	float* b_table = transform->b_clut;
 74460: 	float c0_r, c1_r, c2_r, c3_r;
 74460: 	float c0_g, c1_g, c2_g, c3_g;
 74460: 	float c0_b, c1_b, c2_b, c3_b;
 74460: 	float clut_r, clut_g, clut_b;
 74460: 	for (i = 0; i < length; i++) {
 74460: 		unsigned char in_r = *src++;
 74460: 		unsigned char in_g = *src++;
 74460: 		unsigned char in_b = *src++;
 74460: 		unsigned char in_a = *src++;
 74460: 		float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
 74460: 
 74460: 		int x = floor(linear_r * (transform->grid_size-1));
 74460: 		int y = floor(linear_g * (transform->grid_size-1));
 74460: 		int z = floor(linear_b * (transform->grid_size-1));
 74460: 		int x_n = ceil(linear_r * (transform->grid_size-1));
 74460: 		int y_n = ceil(linear_g * (transform->grid_size-1));
 74460: 		int z_n = ceil(linear_b * (transform->grid_size-1));
 74460: 		float rx = linear_r * (transform->grid_size-1) - x; 
 74460: 		float ry = linear_g * (transform->grid_size-1) - y;
 74460: 		float rz = linear_b * (transform->grid_size-1) - z; 
 74460: 
 74460: 		c0_r = CLU(r_table, x, y, z);
 74460: 		c0_g = CLU(g_table, x, y, z);
 74460: 		c0_b = CLU(b_table, x, y, z);
 74460: 
 74460: 		if( rx >= ry ) {
 74460: 			if (ry >= rz) { //rx >= ry && ry >= rz
 74460: 				c1_r = CLU(r_table, x_n, y, z) - c0_r;
 74460: 				c2_r = CLU(r_table, x_n, y_n, z) - CLU(r_table, x_n, y, z);
 74460: 				c3_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y_n, z);
 74460: 				c1_g = CLU(g_table, x_n, y, z) - c0_g;
 74460: 				c2_g = CLU(g_table, x_n, y_n, z) - CLU(g_table, x_n, y, z);
 74460: 				c3_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y_n, z);
 74460: 				c1_b = CLU(b_table, x_n, y, z) - c0_b;
 74460: 				c2_b = CLU(b_table, x_n, y_n, z) - CLU(b_table, x_n, y, z);
 74460: 				c3_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y_n, z);
 74460: 			} else { 
 74460: 				if (rx >= rz) { //rx >= rz && rz >= ry
 74460: 					c1_r = CLU(r_table, x_n, y, z) - c0_r;
 74460: 					c2_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y, z_n);
 74460: 					c3_r = CLU(r_table, x_n, y, z_n) - CLU(r_table, x_n, y, z);
 74460: 					c1_g = CLU(g_table, x_n, y, z) - c0_g;
 74460: 					c2_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y, z_n);
 74460: 					c3_g = CLU(g_table, x_n, y, z_n) - CLU(g_table, x_n, y, z);
 74460: 					c1_b = CLU(b_table, x_n, y, z) - c0_b;
 74460: 					c2_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y, z_n);
 74460: 					c3_b = CLU(b_table, x_n, y, z_n) - CLU(b_table, x_n, y, z);
 74460: 				} else { //rz > rx && rx >= ry
 74460: 					c1_r = CLU(r_table, x_n, y, z_n) - CLU(r_table, x, y, z_n);
 74460: 					c2_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y, z_n);
 74460: 					c3_r = CLU(r_table, x, y, z_n) - c0_r;
 74460: 					c1_g = CLU(g_table, x_n, y, z_n) - CLU(g_table, x, y, z_n);
 74460: 					c2_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y, z_n);
 74460: 					c3_g = CLU(g_table, x, y, z_n) - c0_g;
 74460: 					c1_b = CLU(b_table, x_n, y, z_n) - CLU(b_table, x, y, z_n);
 74460: 					c2_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y, z_n);
 74460: 					c3_b = CLU(b_table, x, y, z_n) - c0_b;
 74460: 				}
 74460: 			}
 74460: 		} else {
 74460: 			if (rx >= rz) { //ry > rx && rx >= rz
 74460: 				c1_r = CLU(r_table, x_n, y_n, z) - CLU(r_table, x, y_n, z);
 74460: 				c2_r = CLU(r_table, x, y_n, z) - c0_r;
 74460: 				c3_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y_n, z);
 74460: 				c1_g = CLU(g_table, x_n, y_n, z) - CLU(g_table, x, y_n, z);
 74460: 				c2_g = CLU(g_table, x, y_n, z) - c0_g;
 74460: 				c3_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y_n, z);
 74460: 				c1_b = CLU(b_table, x_n, y_n, z) - CLU(b_table, x, y_n, z);
 74460: 				c2_b = CLU(b_table, x, y_n, z) - c0_b;
 74460: 				c3_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y_n, z);
 74460: 			} else {
 74460: 				if (ry >= rz) { //ry >= rz && rz > rx 
 74460: 					c1_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x, y_n, z_n);
 74460: 					c2_r = CLU(r_table, x, y_n, z) - c0_r;
 74460: 					c3_r = CLU(r_table, x, y_n, z_n) - CLU(r_table, x, y_n, z);
 74460: 					c1_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x, y_n, z_n);
 74460: 					c2_g = CLU(g_table, x, y_n, z) - c0_g;
 74460: 					c3_g = CLU(g_table, x, y_n, z_n) - CLU(g_table, x, y_n, z);
 74460: 					c1_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x, y_n, z_n);
 74460: 					c2_b = CLU(b_table, x, y_n, z) - c0_b;
 74460: 					c3_b = CLU(b_table, x, y_n, z_n) - CLU(b_table, x, y_n, z);
 74460: 				} else { //rz > ry && ry > rx
 74460: 					c1_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x, y_n, z_n);
 74460: 					c2_r = CLU(r_table, x, y_n, z_n) - CLU(r_table, x, y, z_n);
 74460: 					c3_r = CLU(r_table, x, y, z_n) - c0_r;
 74460: 					c1_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x, y_n, z_n);
 74460: 					c2_g = CLU(g_table, x, y_n, z_n) - CLU(g_table, x, y, z_n);
 74460: 					c3_g = CLU(g_table, x, y, z_n) - c0_g;
 74460: 					c1_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x, y_n, z_n);
 74460: 					c2_b = CLU(b_table, x, y_n, z_n) - CLU(b_table, x, y, z_n);
 74460: 					c3_b = CLU(b_table, x, y, z_n) - c0_b;
 74460: 				}
 74460: 			}
 74460: 		}
 74460: 				
 74460: 		clut_r = c0_r + c1_r*rx + c2_r*ry + c3_r*rz;
 74460: 		clut_g = c0_g + c1_g*rx + c2_g*ry + c3_g*rz;
 74460: 		clut_b = c0_b + c1_b*rx + c2_b*ry + c3_b*rz;
 74460: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(clut_r*255.0f);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(clut_g*255.0f);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(clut_b*255.0f);
116034: 		dest[OUTPUT_A_INDEX] = in_a;
116034: 		dest += RGBA_OUTPUT_COMPONENTS;
 74460: 	}	
 74460: }
 74460: 
 74460: // Using lcms' tetra interpolation code.
 74460: static void qcms_transform_data_tetra_clut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length) {
 74460: 	unsigned int i;
 74460: 	int xy_len = 1;
 74460: 	int x_len = transform->grid_size;
 74460: 	int len = x_len * x_len;
 74460: 	float* r_table = transform->r_clut;
 74460: 	float* g_table = transform->g_clut;
 74460: 	float* b_table = transform->b_clut;
 74460: 	float c0_r, c1_r, c2_r, c3_r;
 74460: 	float c0_g, c1_g, c2_g, c3_g;
 74460: 	float c0_b, c1_b, c2_b, c3_b;
 74460: 	float clut_r, clut_g, clut_b;
 74460: 	for (i = 0; i < length; i++) {
 74460: 		unsigned char in_r = *src++;
 74460: 		unsigned char in_g = *src++;
 74460: 		unsigned char in_b = *src++;
 74460: 		float linear_r = in_r/255.0f, linear_g=in_g/255.0f, linear_b = in_b/255.0f;
 74460: 
 74460: 		int x = floor(linear_r * (transform->grid_size-1));
 74460: 		int y = floor(linear_g * (transform->grid_size-1));
 74460: 		int z = floor(linear_b * (transform->grid_size-1));
 74460: 		int x_n = ceil(linear_r * (transform->grid_size-1));
 74460: 		int y_n = ceil(linear_g * (transform->grid_size-1));
 74460: 		int z_n = ceil(linear_b * (transform->grid_size-1));
 74460: 		float rx = linear_r * (transform->grid_size-1) - x; 
 74460: 		float ry = linear_g * (transform->grid_size-1) - y;
 74460: 		float rz = linear_b * (transform->grid_size-1) - z; 
 74460: 
 74460: 		c0_r = CLU(r_table, x, y, z);
 74460: 		c0_g = CLU(g_table, x, y, z);
 74460: 		c0_b = CLU(b_table, x, y, z);
 74460: 
 74460: 		if( rx >= ry ) {
 74460: 			if (ry >= rz) { //rx >= ry && ry >= rz
 74460: 				c1_r = CLU(r_table, x_n, y, z) - c0_r;
 74460: 				c2_r = CLU(r_table, x_n, y_n, z) - CLU(r_table, x_n, y, z);
 74460: 				c3_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y_n, z);
 74460: 				c1_g = CLU(g_table, x_n, y, z) - c0_g;
 74460: 				c2_g = CLU(g_table, x_n, y_n, z) - CLU(g_table, x_n, y, z);
 74460: 				c3_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y_n, z);
 74460: 				c1_b = CLU(b_table, x_n, y, z) - c0_b;
 74460: 				c2_b = CLU(b_table, x_n, y_n, z) - CLU(b_table, x_n, y, z);
 74460: 				c3_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y_n, z);
 74460: 			} else { 
 74460: 				if (rx >= rz) { //rx >= rz && rz >= ry
 74460: 					c1_r = CLU(r_table, x_n, y, z) - c0_r;
 74460: 					c2_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y, z_n);
 74460: 					c3_r = CLU(r_table, x_n, y, z_n) - CLU(r_table, x_n, y, z);
 74460: 					c1_g = CLU(g_table, x_n, y, z) - c0_g;
 74460: 					c2_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y, z_n);
 74460: 					c3_g = CLU(g_table, x_n, y, z_n) - CLU(g_table, x_n, y, z);
 74460: 					c1_b = CLU(b_table, x_n, y, z) - c0_b;
 74460: 					c2_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y, z_n);
 74460: 					c3_b = CLU(b_table, x_n, y, z_n) - CLU(b_table, x_n, y, z);
 74460: 				} else { //rz > rx && rx >= ry
 74460: 					c1_r = CLU(r_table, x_n, y, z_n) - CLU(r_table, x, y, z_n);
 74460: 					c2_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y, z_n);
 74460: 					c3_r = CLU(r_table, x, y, z_n) - c0_r;
 74460: 					c1_g = CLU(g_table, x_n, y, z_n) - CLU(g_table, x, y, z_n);
 74460: 					c2_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y, z_n);
 74460: 					c3_g = CLU(g_table, x, y, z_n) - c0_g;
 74460: 					c1_b = CLU(b_table, x_n, y, z_n) - CLU(b_table, x, y, z_n);
 74460: 					c2_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y, z_n);
 74460: 					c3_b = CLU(b_table, x, y, z_n) - c0_b;
 74460: 				}
 74460: 			}
 74460: 		} else {
 74460: 			if (rx >= rz) { //ry > rx && rx >= rz
 74460: 				c1_r = CLU(r_table, x_n, y_n, z) - CLU(r_table, x, y_n, z);
 74460: 				c2_r = CLU(r_table, x, y_n, z) - c0_r;
 74460: 				c3_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x_n, y_n, z);
 74460: 				c1_g = CLU(g_table, x_n, y_n, z) - CLU(g_table, x, y_n, z);
 74460: 				c2_g = CLU(g_table, x, y_n, z) - c0_g;
 74460: 				c3_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x_n, y_n, z);
 74460: 				c1_b = CLU(b_table, x_n, y_n, z) - CLU(b_table, x, y_n, z);
 74460: 				c2_b = CLU(b_table, x, y_n, z) - c0_b;
 74460: 				c3_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x_n, y_n, z);
 74460: 			} else {
 74460: 				if (ry >= rz) { //ry >= rz && rz > rx 
 74460: 					c1_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x, y_n, z_n);
 74460: 					c2_r = CLU(r_table, x, y_n, z) - c0_r;
 74460: 					c3_r = CLU(r_table, x, y_n, z_n) - CLU(r_table, x, y_n, z);
 74460: 					c1_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x, y_n, z_n);
 74460: 					c2_g = CLU(g_table, x, y_n, z) - c0_g;
 74460: 					c3_g = CLU(g_table, x, y_n, z_n) - CLU(g_table, x, y_n, z);
 74460: 					c1_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x, y_n, z_n);
 74460: 					c2_b = CLU(b_table, x, y_n, z) - c0_b;
 74460: 					c3_b = CLU(b_table, x, y_n, z_n) - CLU(b_table, x, y_n, z);
 74460: 				} else { //rz > ry && ry > rx
 74460: 					c1_r = CLU(r_table, x_n, y_n, z_n) - CLU(r_table, x, y_n, z_n);
 74460: 					c2_r = CLU(r_table, x, y_n, z_n) - CLU(r_table, x, y, z_n);
 74460: 					c3_r = CLU(r_table, x, y, z_n) - c0_r;
 74460: 					c1_g = CLU(g_table, x_n, y_n, z_n) - CLU(g_table, x, y_n, z_n);
 74460: 					c2_g = CLU(g_table, x, y_n, z_n) - CLU(g_table, x, y, z_n);
 74460: 					c3_g = CLU(g_table, x, y, z_n) - c0_g;
 74460: 					c1_b = CLU(b_table, x_n, y_n, z_n) - CLU(b_table, x, y_n, z_n);
 74460: 					c2_b = CLU(b_table, x, y_n, z_n) - CLU(b_table, x, y, z_n);
 74460: 					c3_b = CLU(b_table, x, y, z_n) - c0_b;
 74460: 				}
 74460: 			}
 74460: 		}
 74460: 				
 74460: 		clut_r = c0_r + c1_r*rx + c2_r*ry + c3_r*rz;
 74460: 		clut_g = c0_g + c1_g*rx + c2_g*ry + c3_g*rz;
 74460: 		clut_b = c0_b + c1_b*rx + c2_b*ry + c3_b*rz;
 74460: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(clut_r*255.0f);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(clut_g*255.0f);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(clut_b*255.0f);
116034: 		dest += RGB_OUTPUT_COMPONENTS;
 74460: 	}	
 74460: }
 74460: 
 27035: static void qcms_transform_data_rgb_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	float (*mat)[4] = transform->matrix;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device_r = *src++;
 27035: 		unsigned char device_g = *src++;
 27035: 		unsigned char device_b = *src++;
 27035: 		float out_device_r, out_device_g, out_device_b;
 27035: 
 27035: 		float linear_r = transform->input_gamma_table_r[device_r];
 27035: 		float linear_g = transform->input_gamma_table_g[device_g];
 27035: 		float linear_b = transform->input_gamma_table_b[device_b];
 27035: 
 27035: 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 27035: 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 27035: 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 27035: 
 27035: 		out_linear_r = clamp_float(out_linear_r);
 27035: 		out_linear_g = clamp_float(out_linear_g);
 27035: 		out_linear_b = clamp_float(out_linear_b);
 27035: 
 74460: 		out_device_r = lut_interp_linear(out_linear_r, 
 74460: 				transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 74460: 		out_device_g = lut_interp_linear(out_linear_g, 
 74460: 				transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 74460: 		out_device_b = lut_interp_linear(out_linear_b, 
 74460: 				transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
116034: 		dest += RGB_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 27035: static void qcms_transform_data_rgba_out_lut(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 30578: 	unsigned int i;
 27035: 	float (*mat)[4] = transform->matrix;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device_r = *src++;
 27035: 		unsigned char device_g = *src++;
 27035: 		unsigned char device_b = *src++;
 27035: 		unsigned char alpha = *src++;
 27035: 		float out_device_r, out_device_g, out_device_b;
 27035: 
 27035: 		float linear_r = transform->input_gamma_table_r[device_r];
 27035: 		float linear_g = transform->input_gamma_table_g[device_g];
 27035: 		float linear_b = transform->input_gamma_table_b[device_b];
 27035: 
 27035: 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 27035: 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 27035: 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 27035: 
 27035: 		out_linear_r = clamp_float(out_linear_r);
 27035: 		out_linear_g = clamp_float(out_linear_g);
 27035: 		out_linear_b = clamp_float(out_linear_b);
 27035: 
 74460: 		out_device_r = lut_interp_linear(out_linear_r, 
 74460: 				transform->output_gamma_lut_r, transform->output_gamma_lut_r_length);
 74460: 		out_device_g = lut_interp_linear(out_linear_g, 
 74460: 				transform->output_gamma_lut_g, transform->output_gamma_lut_g_length);
 74460: 		out_device_b = lut_interp_linear(out_linear_b, 
 74460: 				transform->output_gamma_lut_b, transform->output_gamma_lut_b_length);
 27035: 
116034: 		dest[OUTPUT_R_INDEX] = clamp_u8(out_device_r*255);
116034: 		dest[OUTPUT_G_INDEX] = clamp_u8(out_device_g*255);
116034: 		dest[OUTPUT_B_INDEX] = clamp_u8(out_device_b*255);
116034: 		dest[OUTPUT_A_INDEX] = alpha;
116034: 		dest += RGBA_OUTPUT_COMPONENTS;
 27035: 	}
 27035: }
 27035: 
 27035: #if 0
 27035: static void qcms_transform_data_rgb_out_linear(qcms_transform *transform, unsigned char *src, unsigned char *dest, size_t length)
 27035: {
 27035: 	int i;
 27035: 	float (*mat)[4] = transform->matrix;
 27035: 	for (i = 0; i < length; i++) {
 27035: 		unsigned char device_r = *src++;
 27035: 		unsigned char device_g = *src++;
 27035: 		unsigned char device_b = *src++;
 27035: 
 27035: 		float linear_r = transform->input_gamma_table_r[device_r];
 27035: 		float linear_g = transform->input_gamma_table_g[device_g];
 27035: 		float linear_b = transform->input_gamma_table_b[device_b];
 27035: 
 27035: 		float out_linear_r = mat[0][0]*linear_r + mat[1][0]*linear_g + mat[2][0]*linear_b;
 27035: 		float out_linear_g = mat[0][1]*linear_r + mat[1][1]*linear_g + mat[2][1]*linear_b;
 27035: 		float out_linear_b = mat[0][2]*linear_r + mat[1][2]*linear_g + mat[2][2]*linear_b;
 27035: 
 27035: 		*dest++ = clamp_u8(out_linear_r*255);
 27035: 		*dest++ = clamp_u8(out_linear_g*255);
 27035: 		*dest++ = clamp_u8(out_linear_b*255);
 27035: 	}
 27035: }
 27035: #endif
 27035: 
 27035: static struct precache_output *precache_reference(struct precache_output *p)
 27035: {
 27035: 	p->ref_count++;
 27035: 	return p;
 27035: }
 27035: 
 27035: static struct precache_output *precache_create()
 27035: {
 27035: 	struct precache_output *p = malloc(sizeof(struct precache_output));
 27035: 	if (p)
 27035: 		p->ref_count = 1;
 27035: 	return p;
 27035: }
 27035: 
 27035: void precache_release(struct precache_output *p)
 27035: {
 27035: 	if (--p->ref_count == 0) {
 27035: 		free(p);
 27035: 	}
 27035: }
 27035: 
 27035: #ifdef HAS_POSIX_MEMALIGN
 27035: static qcms_transform *transform_alloc(void)
 27035: {
 27035: 	qcms_transform *t;
 27035: 	if (!posix_memalign(&t, 16, sizeof(*t))) {
 27035: 		return t;
 27035: 	} else {
 27035: 		return NULL;
 27035: 	}
 27035: }
 27035: static void transform_free(qcms_transform *t)
 27035: {
 27035: 	free(t);
 27035: }
 27035: #else
 27035: static qcms_transform *transform_alloc(void)
 27035: {
 27035: 	/* transform needs to be aligned on a 16byte boundrary */
 27035: 	char *original_block = calloc(sizeof(qcms_transform) + sizeof(void*) + 16, 1);
 27035: 	/* make room for a pointer to the block returned by calloc */
 27035: 	void *transform_start = original_block + sizeof(void*);
 27035: 	/* align transform_start */
 27035: 	qcms_transform *transform_aligned = (qcms_transform*)(((uintptr_t)transform_start + 15) & ~0xf);
 27035: 
 27035: 	/* store a pointer to the block returned by calloc so that we can free it later */
 27035: 	void **(original_block_ptr) = (void**)transform_aligned;
 27035: 	if (!original_block)
 27035: 		return NULL;
 27035: 	original_block_ptr--;
 27035: 	*original_block_ptr = original_block;
 27035: 
 27035: 	return transform_aligned;
 27035: }
 27035: static void transform_free(qcms_transform *t)
 27035: {
 27035: 	/* get at the pointer to the unaligned block returned by calloc */
 27035: 	void **p = (void**)t;
 27035: 	p--;
 27035: 	free(*p);
 27035: }
 27035: #endif
 27035: 
 27035: void qcms_transform_release(qcms_transform *t)
 27035: {
 27035: 	/* ensure we only free the gamma tables once even if there are
 27035: 	 * multiple references to the same data */
 27035: 
 27035: 	if (t->output_table_r)
 27035: 		precache_release(t->output_table_r);
 27035: 	if (t->output_table_g)
 27035: 		precache_release(t->output_table_g);
 27035: 	if (t->output_table_b)
 27035: 		precache_release(t->output_table_b);
 27035: 
 27035: 	free(t->input_gamma_table_r);
 27035: 	if (t->input_gamma_table_g != t->input_gamma_table_r)
 27035: 		free(t->input_gamma_table_g);
 27035: 	if (t->input_gamma_table_g != t->input_gamma_table_r &&
 27035: 	    t->input_gamma_table_g != t->input_gamma_table_b)
 27035: 		free(t->input_gamma_table_b);
 27035: 
 27035: 	free(t->input_gamma_table_gray);
 27035: 
 27035: 	free(t->output_gamma_lut_r);
 27035: 	free(t->output_gamma_lut_g);
 27035: 	free(t->output_gamma_lut_b);
 27035: 
 27035: 	transform_free(t);
 27035: }
 27035: 
 33346: #ifdef X86
 27035: // Determine if we can build with SSE2 (this was partly copied from jmorecfg.h in
 27035: // mozilla/jpeg)
 27035:  // -------------------------------------------------------------------------
 27035: #if defined(_M_IX86) && defined(_MSC_VER)
 27035: #define HAS_CPUID
 27035: /* Get us a CPUID function. Avoid clobbering EBX because sometimes it's the PIC
 27035:    register - I'm not sure if that ever happens on windows, but cpuid isn't
 27035:    on the critical path so we just preserve the register to be safe and to be
 27035:    consistent with the non-windows version. */
 27035: static void cpuid(uint32_t fxn, uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {
 27035:        uint32_t a_, b_, c_, d_;
 27035:        __asm {
 27035:               xchg   ebx, esi
 27035:               mov    eax, fxn
 27035:               cpuid
 27035:               mov    a_, eax
 27035:               mov    b_, ebx
 27035:               mov    c_, ecx
 27035:               mov    d_, edx
 27035:               xchg   ebx, esi
 27035:        }
 27035:        *a = a_;
 27035:        *b = b_;
 27035:        *c = c_;
 27035:        *d = d_;
 27035: }
 35161: #elif (defined(__GNUC__) || defined(__SUNPRO_C)) && (defined(__i386__) || defined(__i386))
 27035: #define HAS_CPUID
 27035: /* Get us a CPUID function. We can't use ebx because it's the PIC register on
 27035:    some platforms, so we use ESI instead and save ebx to avoid clobbering it. */
 27035: static void cpuid(uint32_t fxn, uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d) {
 27035: 
 27035: 	uint32_t a_, b_, c_, d_;
 27035:        __asm__ __volatile__ ("xchgl %%ebx, %%esi; cpuid; xchgl %%ebx, %%esi;" 
 27035:                              : "=a" (a_), "=S" (b_), "=c" (c_), "=d" (d_) : "a" (fxn));
 27035: 	   *a = a_;
 27035: 	   *b = b_;
 27035: 	   *c = c_;
 27035: 	   *d = d_;
 27035: }
 27035: #endif
 27035: 
 33346: // -------------------------Runtime SSEx Detection-----------------------------
 27035: 
 33346: /* MMX is always supported per
 33346:  *  Gecko v1.9.1 minimum CPU requirements */
 33346: #define SSE1_EDX_MASK (1UL << 25)
 27035: #define SSE2_EDX_MASK (1UL << 26)
 33346: #define SSE3_ECX_MASK (1UL <<  0)
 33346: 
 33346: static int sse_version_available(void)
 27035: {
 35161: #if defined(__x86_64__) || defined(__x86_64) || defined(_M_AMD64)
 33346: 	/* we know at build time that 64-bit CPUs always have SSE2
 33346: 	 * this tells the compiler that non-SSE2 branches will never be
 33346: 	 * taken (i.e. OK to optimze away the SSE1 and non-SIMD code */
 33346: 	return 2;
 27354: #elif defined(HAS_CPUID)
 33346: 	static int sse_version = -1;
 27035: 	uint32_t a, b, c, d;
 27035: 	uint32_t function = 0x00000001;
 27035: 
 33346: 	if (sse_version == -1) {
 33346: 		sse_version = 0;
 27035: 		cpuid(function, &a, &b, &c, &d);
 33346: 		if (c & SSE3_ECX_MASK)
 33346: 			sse_version = 3;
 33346: 		else if (d & SSE2_EDX_MASK)
 33346: 			sse_version = 2;
 33346: 		else if (d & SSE1_EDX_MASK)
 33346: 			sse_version = 1;
 27035: 	}
 27035: 
 33346: 	return sse_version;
 33346: #else
 33346: 	return 0;
 27035: #endif
 27035: }
 33346: #endif
 27035: 
 74460: static const struct matrix bradford_matrix = {{	{ 0.8951f, 0.2664f,-0.1614f},
 74460: 						{-0.7502f, 1.7135f, 0.0367f},
 74460: 						{ 0.0389f,-0.0685f, 1.0296f}}, 
 74460: 						false};
 29149: 
 74460: static const struct matrix bradford_matrix_inv = {{ { 0.9869929f,-0.1470543f, 0.1599627f},
 74460: 						    { 0.4323053f, 0.5183603f, 0.0492912f},
 74460: 						    {-0.0085287f, 0.0400428f, 0.9684867f}}, 
 74460: 						    false};
 27035: 
 74460: // See ICCv4 E.3
 74460: struct matrix compute_whitepoint_adaption(float X, float Y, float Z) {
 74460: 	float p = (0.96422f*bradford_matrix.m[0][0] + 1.000f*bradford_matrix.m[1][0] + 0.82521f*bradford_matrix.m[2][0]) /
 74460: 		  (X*bradford_matrix.m[0][0]      + Y*bradford_matrix.m[1][0]      + Z*bradford_matrix.m[2][0]     );
 74460: 	float y = (0.96422f*bradford_matrix.m[0][1] + 1.000f*bradford_matrix.m[1][1] + 0.82521f*bradford_matrix.m[2][1]) /
 74460: 		  (X*bradford_matrix.m[0][1]      + Y*bradford_matrix.m[1][1]      + Z*bradford_matrix.m[2][1]     );
 74460: 	float b = (0.96422f*bradford_matrix.m[0][2] + 1.000f*bradford_matrix.m[1][2] + 0.82521f*bradford_matrix.m[2][2]) /
 74460: 		  (X*bradford_matrix.m[0][2]      + Y*bradford_matrix.m[1][2]      + Z*bradford_matrix.m[2][2]     );
 74460: 	struct matrix white_adaption = {{ {p,0,0}, {0,y,0}, {0,0,b}}, false};
 74460: 	return matrix_multiply( bradford_matrix_inv, matrix_multiply(white_adaption, bradford_matrix) );
 27035: }
 27035: 
 27035: void qcms_profile_precache_output_transform(qcms_profile *profile)
 27035: {
 27035: 	/* we only support precaching on rgb profiles */
 27035: 	if (profile->color_space != RGB_SIGNATURE)
 27035: 		return;
 27035: 
 99114: 	if (qcms_supports_iccv4) {
 74460: 		/* don't precache since we will use the B2A LUT */
 74460: 		if (profile->B2A0)
 74460: 			return;
 74460: 
 74460: 		/* don't precache since we will use the mBA LUT */
 74460: 		if (profile->mBA)
 74460: 			return;
 99114: 	}
 74460: 
 74460: 	/* don't precache if we do not have the TRC curves */
 74460: 	if (!profile->redTRC || !profile->greenTRC || !profile->blueTRC)
 74460: 		return;
 74460: 
 27035: 	if (!profile->output_table_r) {
 27035: 		profile->output_table_r = precache_create();
 27035: 		if (profile->output_table_r &&
 27035: 				!compute_precache(profile->redTRC, profile->output_table_r->data)) {
 27035: 			precache_release(profile->output_table_r);
 27035: 			profile->output_table_r = NULL;
 27035: 		}
 27035: 	}
 27035: 	if (!profile->output_table_g) {
 27035: 		profile->output_table_g = precache_create();
 27035: 		if (profile->output_table_g &&
 27035: 				!compute_precache(profile->greenTRC, profile->output_table_g->data)) {
 27035: 			precache_release(profile->output_table_g);
 27035: 			profile->output_table_g = NULL;
 27035: 		}
 27035: 	}
 27035: 	if (!profile->output_table_b) {
 27035: 		profile->output_table_b = precache_create();
 27035: 		if (profile->output_table_b &&
 27035: 				!compute_precache(profile->blueTRC, profile->output_table_b->data)) {
 38283: 			precache_release(profile->output_table_b);
 38283: 			profile->output_table_b = NULL;
 27035: 		}
 27035: 	}
 27035: }
 27035: 
 74460: /* Replace the current transformation with a LUT transformation using a given number of sample points */
 74460: qcms_transform* qcms_transform_precacheLUT_float(qcms_transform *transform, qcms_profile *in, qcms_profile *out, 
 74460:                                                  int samples, qcms_data_type in_type)
 74460: {
 74460: 	/* The range between which 2 consecutive sample points can be used to interpolate */
 74460: 	uint16_t x,y,z;
 74460: 	uint32_t l;
 74460: 	uint32_t lutSize = 3 * samples * samples * samples;
 74460: 	float* src = NULL;
 74460: 	float* dest = NULL;
 74460: 	float* lut = NULL;
 74460: 
 74460: 	src = malloc(lutSize*sizeof(float));
 74460: 	dest = malloc(lutSize*sizeof(float));
 74460: 
 74460: 	if (src && dest) {
 74460: 		/* Prepare a list of points we want to sample */
 74460: 		l = 0;
 74460: 		for (x = 0; x < samples; x++) {
 74460: 			for (y = 0; y < samples; y++) {
 74460: 				for (z = 0; z < samples; z++) {
 74460: 					src[l++] = x / (float)(samples-1);
 74460: 					src[l++] = y / (float)(samples-1);
 74460: 					src[l++] = z / (float)(samples-1);
 74460: 				}
 74460: 			}
 74460: 		}
 74460: 
 74460: 		lut = qcms_chain_transform(in, out, src, dest, lutSize);
 74460: 		if (lut) {
 74460: 			transform->r_clut = &lut[0];
 74460: 			transform->g_clut = &lut[1];
 74460: 			transform->b_clut = &lut[2];
 74460: 			transform->grid_size = samples;
 74460: 			if (in_type == QCMS_DATA_RGBA_8) {
 74460: 				transform->transform_fn = qcms_transform_data_tetra_clut_rgba;
 74460: 			} else {
 74460: 				transform->transform_fn = qcms_transform_data_tetra_clut;
 74460: 			}
 74460: 		}
 74460: 	}
 74460: 
 74460: 
 74460: 	//XXX: qcms_modular_transform_data may return either the src or dest buffer. If so it must not be free-ed
 74460: 	if (src && lut != src) {
 74460: 		free(src);
 82321: 	}
 82321: 	if (dest && lut != dest) {
 74460: 		free(dest);
 74460: 	}
 74460: 
 74460: 	if (lut == NULL) {
 74460: 		return NULL;
 74460: 	}
 74460: 	return transform;
 74460: }
 74460: 
 27035: #define NO_MEM_TRANSFORM NULL
 27035: 
 27035: qcms_transform* qcms_transform_create(
 27035: 		qcms_profile *in, qcms_data_type in_type,
 27035: 		qcms_profile *out, qcms_data_type out_type,
 27035: 		qcms_intent intent)
 27035: {
 27035: 	bool precache = false;
 27035: 
 27035:         qcms_transform *transform = transform_alloc();
 27035:         if (!transform) {
 27035: 		return NULL;
 27035: 	}
 27035: 	if (out_type != QCMS_DATA_RGB_8 &&
 27035:                 out_type != QCMS_DATA_RGBA_8) {
 27035:             assert(0 && "output type");
 48175: 	    transform_free(transform);
 27035:             return NULL;
 27035:         }
 27035: 
 27035: 	if (out->output_table_r &&
 27035: 			out->output_table_g &&
 27035: 			out->output_table_b) {
 27035: 		precache = true;
 27035: 	}
 27035: 
 74460: 	if (qcms_supports_iccv4 && (in->A2B0 || out->B2A0 || in->mAB || out->mAB)) {
 74460: 		// Precache the transformation to a CLUT 33x33x33 in size.
 74460: 		// 33 is used by many profiles and works well in pratice. 
 74460: 		// This evenly divides 256 into blocks of 8x8x8.
 74460: 		// TODO For transforming small data sets of about 200x200 or less
 74460: 		// precaching should be avoided.
 74460: 		qcms_transform *result = qcms_transform_precacheLUT_float(transform, in, out, 33, in_type);
 74460: 		if (!result) {
 74460:             		assert(0 && "precacheLUT failed");
 74460: 			transform_free(transform);
 74460: 			return NULL;
 74460: 		}
 74460: 		return result;
 74460: 	}
 74460: 
 27035: 	if (precache) {
 27035: 		transform->output_table_r = precache_reference(out->output_table_r);
 27035: 		transform->output_table_g = precache_reference(out->output_table_g);
 27035: 		transform->output_table_b = precache_reference(out->output_table_b);
 27035: 	} else {
 74460: 		if (!out->redTRC || !out->greenTRC || !out->blueTRC) {
 74460: 			qcms_transform_release(transform);
 74460: 			return NO_MEM_TRANSFORM;
 74460: 		}
 27035: 		build_output_lut(out->redTRC, &transform->output_gamma_lut_r, &transform->output_gamma_lut_r_length);
 27035: 		build_output_lut(out->greenTRC, &transform->output_gamma_lut_g, &transform->output_gamma_lut_g_length);
 27035: 		build_output_lut(out->blueTRC, &transform->output_gamma_lut_b, &transform->output_gamma_lut_b_length);
 27035: 		if (!transform->output_gamma_lut_r || !transform->output_gamma_lut_g || !transform->output_gamma_lut_b) {
 27035: 			qcms_transform_release(transform);
 27035: 			return NO_MEM_TRANSFORM;
 27035: 		}
 27035: 	}
 27035: 
 27035:         if (in->color_space == RGB_SIGNATURE) {
 27035: 		struct matrix in_matrix, out_matrix, result;
 27035: 
 27035: 		if (in_type != QCMS_DATA_RGB_8 &&
 27035:                     in_type != QCMS_DATA_RGBA_8){
 27035:                 	assert(0 && "input type");
 48175: 			transform_free(transform);
 27035:                 	return NULL;
 27035:             	}
 27035: 		if (precache) {
 27035: #ifdef X86
 33346: 		    if (sse_version_available() >= 2) {
 27035: 			    if (in_type == QCMS_DATA_RGB_8)
 33346: 				    transform->transform_fn = qcms_transform_data_rgb_out_lut_sse2;
 27035: 			    else
 33346: 				    transform->transform_fn = qcms_transform_data_rgba_out_lut_sse2;
 33346: 
 37789: #if !(defined(_MSC_VER) && defined(_M_AMD64))
 37789:                     /* Microsoft Compiler for x64 doesn't support MMX.
 37789:                      * SSE code uses MMX so that we disable on x64 */
 33346: 		    } else
 33346: 		    if (sse_version_available() >= 1) {
 33346: 			    if (in_type == QCMS_DATA_RGB_8)
 33346: 				    transform->transform_fn = qcms_transform_data_rgb_out_lut_sse1;
 33346: 			    else
 33346: 				    transform->transform_fn = qcms_transform_data_rgba_out_lut_sse1;
 37789: #endif
 27035: 		    } else
 27035: #endif
 27035: 			{
 27035: 				if (in_type == QCMS_DATA_RGB_8)
 27035: 					transform->transform_fn = qcms_transform_data_rgb_out_lut_precache;
 27035: 				else
 27035: 					transform->transform_fn = qcms_transform_data_rgba_out_lut_precache;
 27035: 			}
 27035: 		} else {
 27035: 			if (in_type == QCMS_DATA_RGB_8)
 27035: 				transform->transform_fn = qcms_transform_data_rgb_out_lut;
 27035: 			else
 27035: 				transform->transform_fn = qcms_transform_data_rgba_out_lut;
 27035: 		}
 27035: 
 27035: 		//XXX: avoid duplicating tables if we can
 27035: 		transform->input_gamma_table_r = build_input_gamma_table(in->redTRC);
 27035: 		transform->input_gamma_table_g = build_input_gamma_table(in->greenTRC);
 27035: 		transform->input_gamma_table_b = build_input_gamma_table(in->blueTRC);
 27035: 		if (!transform->input_gamma_table_r || !transform->input_gamma_table_g || !transform->input_gamma_table_b) {
 27035: 			qcms_transform_release(transform);
 27035: 			return NO_MEM_TRANSFORM;
 27035: 		}
 27035: 
 74460: 
 27035: 		/* build combined colorant matrix */
 27035: 		in_matrix = build_colorant_matrix(in);
 27035: 		out_matrix = build_colorant_matrix(out);
 27035: 		out_matrix = matrix_invert(out_matrix);
 27035: 		if (out_matrix.invalid) {
 27035: 			qcms_transform_release(transform);
 27035: 			return NULL;
 27035: 		}
 27035: 		result = matrix_multiply(out_matrix, in_matrix);
 27035: 
 27035: 		/* store the results in column major mode
 27035: 		 * this makes doing the multiplication with sse easier */
 27035: 		transform->matrix[0][0] = result.m[0][0];
 27035: 		transform->matrix[1][0] = result.m[0][1];
 27035: 		transform->matrix[2][0] = result.m[0][2];
 27035: 		transform->matrix[0][1] = result.m[1][0];
 27035: 		transform->matrix[1][1] = result.m[1][1];
 27035: 		transform->matrix[2][1] = result.m[1][2];
 27035: 		transform->matrix[0][2] = result.m[2][0];
 27035: 		transform->matrix[1][2] = result.m[2][1];
 27035: 		transform->matrix[2][2] = result.m[2][2];
 27035: 
 27035: 	} else if (in->color_space == GRAY_SIGNATURE) {
 27035: 		if (in_type != QCMS_DATA_GRAY_8 &&
 27035: 				in_type != QCMS_DATA_GRAYA_8){
 27035: 			assert(0 && "input type");
 48175: 			transform_free(transform);
 27035: 			return NULL;
 27035: 		}
 27035: 
 27035: 		transform->input_gamma_table_gray = build_input_gamma_table(in->grayTRC);
 27035: 		if (!transform->input_gamma_table_gray) {
 27035: 			qcms_transform_release(transform);
 27035: 			return NO_MEM_TRANSFORM;
 27035: 		}
 27035: 
 27035: 		if (precache) {
 27035: 			if (in_type == QCMS_DATA_GRAY_8) {
 27035: 				transform->transform_fn = qcms_transform_data_gray_out_precache;
 27035: 			} else {
 27035: 				transform->transform_fn = qcms_transform_data_graya_out_precache;
 27035: 			}
 27035: 		} else {
 27035: 			if (in_type == QCMS_DATA_GRAY_8) {
 27035: 				transform->transform_fn = qcms_transform_data_gray_out_lut;
 27035: 			} else {
 27035: 				transform->transform_fn = qcms_transform_data_graya_out_lut;
 27035: 			}
 27035: 		}
 27035: 	} else {
 27035: 		assert(0 && "unexpected colorspace");
 74460: 		transform_free(transform);
 74460: 		return NULL;
 27035: 	}
 27035: 	return transform;
 27035: }
 27035: 
 33346: #if defined(__GNUC__) && !defined(__x86_64__) && !defined(__amd64__)
 33346: /* we need this to avoid crashes when gcc assumes the stack is 128bit aligned */
 33346: __attribute__((__force_align_arg_pointer__))
 33346: #endif
 27035: void qcms_transform_data(qcms_transform *transform, void *src, void *dest, size_t length)
 27035: {
 27035: 	transform->transform_fn(transform, src, dest, length);
 27035: }
 74460: 
 74460: qcms_bool qcms_supports_iccv4;
 74460: void qcms_enable_iccv4()
 74460: {
 74460: 	qcms_supports_iccv4 = true;
 74460: }
