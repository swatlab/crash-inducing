51350: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
51350: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Radha Kulkarni <radha@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80492: #ifdef DEBUG_bryner
80492: #define DEBUG_PAGE_CACHE
80492: #endif
80492: 
    1: // Local Includes
    1: #include "nsSHEntry.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIDocShellLoadInfo.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
80492: #include "nsAutoPtr.h"
80492: #include "nsThreadUtils.h"
80492: #include "nsIWebNavigation.h"
 6187: #include "nsISHistory.h"
 6187: #include "nsISHistoryInternal.h"
14631: #include "nsDocShellEditorData.h"
80492: #include "nsIDocShell.h"
    1: 
51350: namespace dom = mozilla::dom;
51350: 
80492: // Hardcode this to time out unused content viewers after 30 minutes
80492: #define CONTENT_VIEWER_TIMEOUT_SECONDS 30*60
80492: 
80492: typedef nsExpirationTracker<nsSHEntry,3> HistoryTrackerBase;
80492: class HistoryTracker : public HistoryTrackerBase {
80492: public:
80492:   // Expire cached contentviewers after 20-30 minutes in the cache.
80492:   HistoryTracker() : HistoryTrackerBase((CONTENT_VIEWER_TIMEOUT_SECONDS/2)*1000) {}
80492:   
80492: protected:
80492:   virtual void NotifyExpired(nsSHEntry* aObj) {
80492:     RemoveObject(aObj);
80492:     aObj->Expire();
80492:   }
80492: };
80492: 
80492: static HistoryTracker *gHistoryTracker = nsnull;
    1: static PRUint32 gEntryID = 0;
80492: static PRUint64 gEntryDocIdentifier = 0;
80492: 
80492: nsresult nsSHEntry::Startup()
80492: {
80492:   gHistoryTracker = new HistoryTracker();
80492:   return gHistoryTracker ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
80492: }
80492: 
80492: void nsSHEntry::Shutdown()
80492: {
80492:   delete gHistoryTracker;
80492:   gHistoryTracker = nsnull;
80492: }
80492: 
80492: static void StopTrackingEntry(nsSHEntry *aEntry)
80492: {
80492:   if (aEntry->GetExpirationState()->IsTracked()) {
80492:     gHistoryTracker->RemoveObject(aEntry);
80492:   }
80492: }
 6187: 
    1: //*****************************************************************************
    1: //***    nsSHEntry: Object Management
    1: //*****************************************************************************
    1: 
 6187: 
    1: nsSHEntry::nsSHEntry() 
    1:   : mLoadType(0)
    1:   , mID(gEntryID++)
80492:   , mDocIdentifier(gEntryDocIdentifier++)
    1:   , mScrollPositionX(0)
    1:   , mScrollPositionY(0)
80486:   , mURIWasModified(false)
80492:   , mIsFrameNavigation(false)
80492:   , mSaveLayoutState(true)
80492:   , mExpired(false)
80492:   , mSticky(true)
80492:   , mDynamicallyCreated(false)
80492:   , mParent(nsnull)
80492:   , mViewerBounds(0, 0, 0, 0)
80492:   , mDocShellID(0)
80492:   , mLastTouched(0)
    1: {
    1: }
    1: 
    1: nsSHEntry::nsSHEntry(const nsSHEntry &other)
80492:   : mURI(other.mURI)
    1:   , mReferrerURI(other.mReferrerURI)
80492:   // XXX why not copy mDocument?
    1:   , mTitle(other.mTitle)
    1:   , mPostData(other.mPostData)
80492:   , mLayoutHistoryState(other.mLayoutHistoryState)
    1:   , mLoadType(0)         // XXX why not copy?
    1:   , mID(other.mID)
80492:   , mDocIdentifier(other.mDocIdentifier)
    1:   , mScrollPositionX(0)  // XXX why not copy?
    1:   , mScrollPositionY(0)  // XXX why not copy?
73554:   , mURIWasModified(other.mURIWasModified)
80492:   , mIsFrameNavigation(other.mIsFrameNavigation)
80492:   , mSaveLayoutState(other.mSaveLayoutState)
80492:   , mExpired(other.mExpired)
80492:   , mSticky(true)
80492:   , mDynamicallyCreated(other.mDynamicallyCreated)
80492:   // XXX why not copy mContentType?
80492:   , mCacheKey(other.mCacheKey)
80492:   , mParent(other.mParent)
80492:   , mViewerBounds(0, 0, 0, 0)
80492:   , mOwner(other.mOwner)
80492:   , mDocShellID(other.mDocShellID)
61863:   , mStateData(other.mStateData)
    1: {
    1: }
    1: 
79445: static bool
    1: ClearParentPtr(nsISHEntry* aEntry, void* /* aData */)
    1: {
    1:   if (aEntry) {
    1:     aEntry->SetParent(nsnull);
    1:   }
80486:   return true;
    1: }
    1: 
    1: nsSHEntry::~nsSHEntry()
    1: {
80492:   StopTrackingEntry(this);
80492: 
80492:   // Since we never really remove kids from SHEntrys, we need to null
80492:   // out the mParent pointers on all our kids.
    1:   mChildren.EnumerateForwards(ClearParentPtr, nsnull);
80492:   mChildren.Clear();
80492: 
80492:   if (mContentViewer) {
80492:     // RemoveFromBFCacheSync is virtual, so call the nsSHEntry version
80492:     // explicitly
80492:     nsSHEntry::RemoveFromBFCacheSync();
80492:   }
80492: 
80492:   mEditorData = nsnull;
80492: 
80492: #ifdef DEBUG
80492:   // This is not happening as far as I can tell from breakpad as of early November 2007
80492:   nsExpirationTracker<nsSHEntry,3>::Iterator iterator(gHistoryTracker);
80492:   nsSHEntry* elem;
80492:   while ((elem = iterator.Next()) != nsnull) {
80492:     NS_ASSERTION(elem != this, "Found dead entry still in the tracker!");
80492:   }
80492: #endif
    1: }
    1: 
    1: //*****************************************************************************
    1: //    nsSHEntry: nsISupports
    1: //*****************************************************************************
    1: 
80492: NS_IMPL_ISUPPORTS5(nsSHEntry, nsISHContainer, nsISHEntry, nsIHistoryEntry,
80492:                    nsIMutationObserver, nsISHEntryInternal)
    1: 
    1: //*****************************************************************************
    1: //    nsSHEntry: nsISHEntry
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetScrollPosition(PRInt32 x, PRInt32 y)
    1: {
    1:   mScrollPositionX = x;
    1:   mScrollPositionY = y;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetScrollPosition(PRInt32 *x, PRInt32 *y)
    1: {
    1:   *x = mScrollPositionX;
    1:   *y = mScrollPositionY;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsSHEntry::GetURIWasModified(bool* aOut)
73554: {
73554:   *aOut = mURIWasModified;
73554:   return NS_OK;
73554: }
73554: 
79445: NS_IMETHODIMP nsSHEntry::SetURIWasModified(bool aIn)
73554: {
73554:   mURIWasModified = aIn;
73554:   return NS_OK;
73554: }
73554: 
    1: NS_IMETHODIMP nsSHEntry::GetURI(nsIURI** aURI)
    1: {
    1:   *aURI = mURI;
    1:   NS_IF_ADDREF(*aURI);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetURI(nsIURI* aURI)
    1: {
    1:   mURI = aURI;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetReferrerURI(nsIURI **aReferrerURI)
    1: {
    1:   *aReferrerURI = mReferrerURI;
    1:   NS_IF_ADDREF(*aReferrerURI);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetReferrerURI(nsIURI *aReferrerURI)
    1: {
    1:   mReferrerURI = aReferrerURI;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::SetContentViewer(nsIContentViewer *aViewer)
    1: {
80492:   NS_PRECONDITION(!aViewer || !mContentViewer, "SHEntry already contains viewer");
80492: 
80492:   if (mContentViewer || !aViewer) {
80492:     DropPresentationState();
80492:   }
80492: 
80492:   mContentViewer = aViewer;
80492: 
80492:   if (mContentViewer) {
80492:     gHistoryTracker->AddObject(this);
80492: 
80492:     nsCOMPtr<nsIDOMDocument> domDoc;
80492:     mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
80492:     // Store observed document in strong pointer in case it is removed from
80492:     // the contentviewer
80492:     mDocument = do_QueryInterface(domDoc);
80492:     if (mDocument) {
80492:       mDocument->SetBFCacheEntry(this);
80492:       mDocument->AddMutationObserver(this);
80492:     }
80492:   }
80492: 
80492:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetContentViewer(nsIContentViewer **aResult)
    1: {
80492:   *aResult = mContentViewer;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetAnyContentViewer(nsISHEntry **aOwnerEntry,
    1:                                nsIContentViewer **aResult)
    1: {
    1:   // Find a content viewer in the root node or any of its children,
    1:   // assuming that there is only one content viewer total in any one
    1:   // nsSHEntry tree
    1:   GetContentViewer(aResult);
    1:   if (*aResult) {
    1: #ifdef DEBUG_PAGE_CACHE 
    1:     printf("Found content viewer\n");
    1: #endif
    1:     *aOwnerEntry = this;
    1:     NS_ADDREF(*aOwnerEntry);
    1:     return NS_OK;
    1:   }
    1:   // The root SHEntry doesn't have a ContentViewer, so check child nodes
    1:   for (PRInt32 i = 0; i < mChildren.Count(); i++) {
    1:     nsISHEntry* child = mChildren[i];
    1:     if (child) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:       printf("Evaluating SHEntry child %d\n", i);
    1: #endif
    1:       child->GetAnyContentViewer(aOwnerEntry, aResult);
    1:       if (*aResult) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSHEntry::SetSticky(bool aSticky)
    1: {
80492:   mSticky = aSticky;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSHEntry::GetSticky(bool *aSticky)
    1: {
80492:   *aSticky = mSticky;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetTitle(PRUnichar** aTitle)
    1: {
    1:   // Check for empty title...
    1:   if (mTitle.IsEmpty() && mURI) {
    1:     // Default title is the URL.
    1:     nsCAutoString spec;
    1:     if (NS_SUCCEEDED(mURI->GetSpec(spec)))
    1:       AppendUTF8toUTF16(spec, mTitle);
    1:   }
    1: 
    1:   *aTitle = ToNewUnicode(mTitle);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetTitle(const nsAString &aTitle)
    1: {
    1:   mTitle = aTitle;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetPostData(nsIInputStream** aResult)
    1: {
    1:   *aResult = mPostData;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetPostData(nsIInputStream* aPostData)
    1: {
    1:   mPostData = aPostData;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetLayoutHistoryState(nsILayoutHistoryState** aResult)
    1: {
80492:   *aResult = mLayoutHistoryState;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetLayoutHistoryState(nsILayoutHistoryState* aState)
    1: {
80492:   mLayoutHistoryState = aState;
80492:   if (mLayoutHistoryState)
80492:     mLayoutHistoryState->SetScrollPositionOnly(!mSaveLayoutState);
22262: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetLoadType(PRUint32 * aResult)
    1: {
    1:   *aResult = mLoadType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetLoadType(PRUint32  aLoadType)
    1: {
    1:   mLoadType = aLoadType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetID(PRUint32 * aResult)
    1: {
    1:   *aResult = mID;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetID(PRUint32  aID)
    1: {
    1:   mID = aID;
    1:   return NS_OK;
    1: }
    1: 
80492: NS_IMETHODIMP nsSHEntry::GetDocIdentifier(PRUint64 * aResult)
37802: {
80492:   *aResult = mDocIdentifier;
80492:   return NS_OK;
80492: }
80492: 
80492: NS_IMETHODIMP nsSHEntry::SetDocIdentifier(PRUint64 aDocIdentifier)
80492: {
80492:   // This ensures that after a session restore, gEntryDocIdentifier is greater
80492:   // than all SHEntries' docIdentifiers, which ensures that we'll never repeat
80492:   // a doc identifier.
80492:   if (aDocIdentifier >= gEntryDocIdentifier)
80492:     gEntryDocIdentifier = aDocIdentifier + 1;
80492: 
80492:   mDocIdentifier = aDocIdentifier;
80492:   return NS_OK;
80492: }
80492: 
80492: NS_IMETHODIMP nsSHEntry::SetUniqueDocIdentifier()
80492: {
80492:   mDocIdentifier = gEntryDocIdentifier++;
80492:   return NS_OK;
37802: }
37802: 
79445: NS_IMETHODIMP nsSHEntry::GetIsSubFrame(bool * aFlag)
    1: {
80492:   *aFlag = mIsFrameNavigation;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsSHEntry::SetIsSubFrame(bool    aFlag)
    1: {
80492:   mIsFrameNavigation = aFlag;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetCacheKey(nsISupports** aResult)
    1: {
80492:   *aResult = mCacheKey;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetCacheKey(nsISupports* aCacheKey)
    1: {
80492:   mCacheKey = aCacheKey;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsSHEntry::GetSaveLayoutStateFlag(bool * aFlag)
    1: {
80492:   *aFlag = mSaveLayoutState;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsSHEntry::SetSaveLayoutStateFlag(bool    aFlag)
    1: {
80492:   mSaveLayoutState = aFlag;
80492:   if (mLayoutHistoryState)
80492:     mLayoutHistoryState->SetScrollPositionOnly(!aFlag);
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsSHEntry::GetExpirationStatus(bool * aFlag)
    1: {
80492:   *aFlag = mExpired;
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsSHEntry::SetExpirationStatus(bool    aFlag)
    1: {
80492:   mExpired = aFlag;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::GetContentType(nsACString& aContentType)
    1: {
80492:   aContentType = mContentType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSHEntry::SetContentType(const nsACString& aContentType)
    1: {
80492:   mContentType = aContentType;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::Create(nsIURI * aURI, const nsAString &aTitle,
    1:                   nsIInputStream * aInputStream,
    1:                   nsILayoutHistoryState * aLayoutHistoryState,
    1:                   nsISupports * aCacheKey, const nsACString& aContentType,
50721:                   nsISupports* aOwner,
79445:                   PRUint64 aDocShellID, bool aDynamicCreation)
    1: {
    1:   mURI = aURI;
    1:   mTitle = aTitle;
    1:   mPostData = aInputStream;
80492:   mCacheKey = aCacheKey;
80492:   mContentType = aContentType;
80492:   mOwner = aOwner;
80492:   mDocShellID = aDocShellID;
80492:   mDynamicallyCreated = aDynamicCreation;
    1: 
    1:   // Set the LoadType by default to loadHistory during creation
    1:   mLoadType = (PRUint32) nsIDocShellLoadInfo::loadHistory;
    1: 
    1:   // By default all entries are set false for subframe flag. 
    1:   // nsDocShell::CloneAndReplace() which creates entries for
    1:   // all subframe navigations, sets the flag to true.
80492:   mIsFrameNavigation = false;
    1: 
    1:   // By default we save LayoutHistoryState
80492:   mSaveLayoutState = true;
80492:   mLayoutHistoryState = aLayoutHistoryState;
    1: 
    1:   //By default the page is not expired
80492:   mExpired = false;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::Clone(nsISHEntry ** aResult)
    1: {
    1:   *aResult = new nsSHEntry(*this);
80492:   if (!*aResult)
80492:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetParent(nsISHEntry ** aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
80492:   *aResult = mParent;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::SetParent(nsISHEntry * aParent)
    1: {
    1:   /* parent not Addrefed on purpose to avoid cyclic reference
    1:    * Null parent is OK
    1:    *
    1:    * XXX this method should not be scriptable if this is the case!!
    1:    */
80492:   mParent = aParent;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::SetWindowState(nsISupports *aState)
    1: {
80492:   mWindowState = aState;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetWindowState(nsISupports **aState)
    1: {
80492:   NS_IF_ADDREF(*aState = mWindowState);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23738: nsSHEntry::SetViewerBounds(const nsIntRect &aBounds)
    1: {
80492:   mViewerBounds = aBounds;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23738: nsSHEntry::GetViewerBounds(nsIntRect &aBounds)
    1: {
80492:   aBounds = mViewerBounds;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetOwner(nsISupports **aOwner)
    1: {
80492:   NS_IF_ADDREF(*aOwner = mOwner);
    1:   return NS_OK;
    1: }
    1: 
 6007: NS_IMETHODIMP
 6007: nsSHEntry::SetOwner(nsISupports *aOwner)
 6007: {
80492:   mOwner = aOwner;
 6007:   return NS_OK;
 6007: }
 6007: 
    1: //*****************************************************************************
    1: //    nsSHEntry: nsISHContainer
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP 
    1: nsSHEntry::GetChildCount(PRInt32 * aCount)
    1: {
    1:   *aCount = mChildren.Count();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::AddChild(nsISHEntry * aChild, PRInt32 aOffset)
    1: {
50721:   if (aChild) {
50721:     NS_ENSURE_SUCCESS(aChild->SetParent(this), NS_ERROR_FAILURE);
50721:   }
    1: 
50721:   if (aOffset < 0) {
50721:     mChildren.AppendObject(aChild);
50721:     return NS_OK;
50721:   }
    1: 
    1:   //
    1:   // Bug 52670: Ensure children are added in order.
    1:   //
    1:   //  Later frames in the child list may load faster and get appended
    1:   //  before earlier frames, causing session history to be scrambled.
    1:   //  By growing the list here, they are added to the right position.
    1:   //
    1:   //  Assert that aOffset will not be so high as to grow us a lot.
    1:   //
    1:   NS_ASSERTION(aOffset < (mChildren.Count()+1023), "Large frames array!\n");
    1: 
79445:   bool newChildIsDyn = false;
63711:   if (aChild) {
63711:     aChild->IsDynamicallyAdded(&newChildIsDyn);
63711:   }
63711: 
63711:   // If the new child is dynamically added, try to add it to aOffset, but if
63711:   // there are non-dynamically added children, the child must be after those.
63711:   if (newChildIsDyn) {
63711:     PRInt32 lastNonDyn = aOffset - 1;
63711:     for (PRInt32 i = aOffset; i < mChildren.Count(); ++i) {
63711:       nsISHEntry* entry = mChildren[i];
63711:       if (entry) {
79445:         bool dyn = false;
63711:         entry->IsDynamicallyAdded(&dyn);
63711:         if (dyn) {
63711:           break;
63711:         } else {
63711:           lastNonDyn = i;
    1:         }
    1:       }
63711:     }
63137:     // InsertObjectAt allows only appending one object.
63137:     // If aOffset is larger than Count(), we must first manually
63137:     // set the capacity.
63137:     if (aOffset > mChildren.Count()) {
63137:       mChildren.SetCount(aOffset);
63137:     }
63711:     if (!mChildren.InsertObjectAt(aChild, lastNonDyn + 1)) {
51138:       NS_WARNING("Adding a child failed!");
51138:       aChild->SetParent(nsnull);
51138:       return NS_ERROR_FAILURE;
51138:     }
63711:   } else {
63711:     // If the new child isn't dynamically added, it should be set to aOffset.
63711:     // If there are dynamically added children before that, those must be
63711:     // moved to be after aOffset.
63711:     if (mChildren.Count() > 0) {
72496:       PRInt32 start = NS_MIN(mChildren.Count() - 1, aOffset);
63711:       PRInt32 dynEntryIndex = -1;
63711:       nsISHEntry* dynEntry = nsnull;
63711:       for (PRInt32 i = start; i >= 0; --i) {
63711:         nsISHEntry* entry = mChildren[i];
63711:         if (entry) {
79445:           bool dyn = false;
63711:           entry->IsDynamicallyAdded(&dyn);
63711:           if (dyn) {
63711:             dynEntryIndex = i;
63711:             dynEntry = entry;
63711:           } else {
63711:             break;
63711:           }
63711:         }
63711:       }
63711:   
63711:       if (dynEntry) {
63711:         nsCOMArray<nsISHEntry> tmp;
63711:         tmp.SetCount(aOffset - dynEntryIndex + 1);
63711:         mChildren.InsertObjectsAt(tmp, dynEntryIndex);
63711:         NS_ASSERTION(mChildren[aOffset + 1] == dynEntry, "Whaat?");
63711:       }
63711:     }
63711:     
63711: 
63711:     // Make sure there isn't anything at aOffset.
63711:     if (aOffset < mChildren.Count()) {
63711:       nsISHEntry* oldChild = mChildren[aOffset];
63711:       if (oldChild && oldChild != aChild) {
63711:         NS_ERROR("Adding a child where we already have a child? This may misbehave");
63711:         oldChild->SetParent(nsnull);
63711:       }
63711:     }
63711: 
63711:     if (!mChildren.ReplaceObjectAt(aChild, aOffset)) {
63711:       NS_WARNING("Adding a child failed!");
63711:       aChild->SetParent(nsnull);
63711:       return NS_ERROR_FAILURE;
63711:     }
63711:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::RemoveChild(nsISHEntry * aChild)
    1: {
    1:   NS_ENSURE_TRUE(aChild, NS_ERROR_FAILURE);
79445:   bool childRemoved = false;
79445:   bool dynamic = false;
50721:   aChild->IsDynamicallyAdded(&dynamic);
50721:   if (dynamic) {
50721:     childRemoved = mChildren.RemoveObject(aChild);
50721:   } else {
50721:     PRInt32 index = mChildren.IndexOfObject(aChild);
50721:     if (index >= 0) {
50721:       childRemoved = mChildren.ReplaceObjectAt(nsnull, index);
50721:     }
50721:   }
    1:   if (childRemoved)
    1:     aChild->SetParent(nsnull);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetChildAt(PRInt32 aIndex, nsISHEntry ** aResult)
    1: {
    1:   if (aIndex >= 0 && aIndex < mChildren.Count()) {
    1:     *aResult = mChildren[aIndex];
    1:     // yes, mChildren can have holes in it.  AddChild's offset parameter makes
    1:     // that possible.
    1:     NS_IF_ADDREF(*aResult);
    1:   } else {
    1:     *aResult = nsnull;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::AddChildShell(nsIDocShellTreeItem *aShell)
    1: {
    1:   NS_ASSERTION(aShell, "Null child shell added to history entry");
80492:   mChildShells.AppendObject(aShell);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::ChildShellAt(PRInt32 aIndex, nsIDocShellTreeItem **aShell)
    1: {
80492:   NS_IF_ADDREF(*aShell = mChildShells.SafeObjectAt(aIndex));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::ClearChildShells()
    1: {
80492:   mChildShells.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::GetRefreshURIList(nsISupportsArray **aList)
    1: {
80492:   NS_IF_ADDREF(*aList = mRefreshURIList);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::SetRefreshURIList(nsISupportsArray *aList)
    1: {
80492:   mRefreshURIList = aList;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHEntry::SyncPresentationState()
    1: {
80492:   if (mContentViewer && mWindowState) {
80492:     // If we have a content viewer and a window state, we should be ok.
80492:     return NS_OK;
    1:   }
    1: 
80492:   DropPresentationState();
80492: 
80492:   return NS_OK;
80492: }
80492: 
80492: void
80492: nsSHEntry::DropPresentationState()
80492: {
80492:   nsRefPtr<nsSHEntry> kungFuDeathGrip = this;
80492: 
80492:   if (mDocument) {
80492:     mDocument->SetBFCacheEntry(nsnull);
80492:     mDocument->RemoveMutationObserver(this);
80492:     mDocument = nsnull;
80492:   }
80492:   if (mContentViewer)
80492:     mContentViewer->ClearHistoryEntry();
80492: 
80492:   StopTrackingEntry(this);
80492:   mContentViewer = nsnull;
80492:   mSticky = true;
80492:   mWindowState = nsnull;
80492:   mViewerBounds.SetRect(0, 0, 0, 0);
80492:   mChildShells.Clear();
80492:   mRefreshURIList = nsnull;
80492:   mEditorData = nsnull;
80492: }
80492: 
80492: void
80492: nsSHEntry::Expire()
80492: {
80492:   // This entry has timed out. If we still have a content viewer, we need to
80492:   // get it evicted.
80492:   if (!mContentViewer)
80492:     return;
80492:   nsCOMPtr<nsISupports> container;
80492:   mContentViewer->GetContainer(getter_AddRefs(container));
80492:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(container);
80492:   if (!treeItem)
80492:     return;
80492:   // We need to find the root DocShell since only that object has an
80492:   // SHistory and we need the SHistory to evict content viewers
80492:   nsCOMPtr<nsIDocShellTreeItem> root;
80492:   treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
80492:   nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(root);
80492:   nsCOMPtr<nsISHistory> history;
80492:   webNav->GetSessionHistory(getter_AddRefs(history));
80492:   nsCOMPtr<nsISHistoryInternal> historyInt = do_QueryInterface(history);
80492:   if (!historyInt)
80492:     return;
80492:   historyInt->EvictExpiredContentViewerForEntry(this);
80492: }
80492: 
80492: //*****************************************************************************
80492: //    nsSHEntry: nsIMutationObserver
80492: //*****************************************************************************
80492: 
80492: void
80492: nsSHEntry::NodeWillBeDestroyed(const nsINode* aNode)
80492: {
80492:   NS_NOTREACHED("Document destroyed while we're holding a strong ref to it");
80492: }
80492: 
80492: void
80492: nsSHEntry::CharacterDataWillChange(nsIDocument* aDocument,
80492:                                    nsIContent* aContent,
80492:                                    CharacterDataChangeInfo* aInfo)
80492: {
80492: }
80492: 
80492: void
80492: nsSHEntry::CharacterDataChanged(nsIDocument* aDocument,
80492:                                 nsIContent* aContent,
80492:                                 CharacterDataChangeInfo* aInfo)
80492: {
80492:   RemoveFromBFCacheAsync();
80492: }
80492: 
80492: void
80492: nsSHEntry::AttributeWillChange(nsIDocument* aDocument,
80492:                                dom::Element* aContent,
80492:                                PRInt32 aNameSpaceID,
80492:                                nsIAtom* aAttribute,
80492:                                PRInt32 aModType)
80492: {
80492: }
80492: 
80492: void
80492: nsSHEntry::AttributeChanged(nsIDocument* aDocument,
80492:                             dom::Element* aElement,
80492:                             PRInt32 aNameSpaceID,
80492:                             nsIAtom* aAttribute,
80492:                             PRInt32 aModType)
80492: {
80492:   RemoveFromBFCacheAsync();
80492: }
80492: 
80492: void
80492: nsSHEntry::ContentAppended(nsIDocument* aDocument,
80492:                            nsIContent* aContainer,
80492:                            nsIContent* aFirstNewContent,
80492:                            PRInt32 /* unused */)
80492: {
80492:   RemoveFromBFCacheAsync();
80492: }
80492: 
80492: void
80492: nsSHEntry::ContentInserted(nsIDocument* aDocument,
80492:                            nsIContent* aContainer,
80492:                            nsIContent* aChild,
80492:                            PRInt32 /* unused */)
80492: {
80492:   RemoveFromBFCacheAsync();
80492: }
80492: 
80492: void
80492: nsSHEntry::ContentRemoved(nsIDocument* aDocument,
80492:                           nsIContent* aContainer,
80492:                           nsIContent* aChild,
80492:                           PRInt32 aIndexInContainer,
80492:                           nsIContent* aPreviousSibling)
80492: {
80492:   RemoveFromBFCacheAsync();
80492: }
80492: 
80492: void
80492: nsSHEntry::ParentChainChanged(nsIContent *aContent)
80492: {
80492: }
80492: 
80492: class DestroyViewerEvent : public nsRunnable
80492: {
80492: public:
80492:   DestroyViewerEvent(nsIContentViewer* aViewer, nsIDocument* aDocument)
80492:     : mViewer(aViewer),
80492:       mDocument(aDocument)
80492:   {}
80492: 
80492:   NS_IMETHOD Run()
80492:   {
80492:     if (mViewer)
80492:       mViewer->Destroy();
80492:     return NS_OK;
80492:   }
80492: 
80492:   nsCOMPtr<nsIContentViewer> mViewer;
80492:   nsCOMPtr<nsIDocument> mDocument;
80492: };
80492: 
    1: void
58185: nsSHEntry::RemoveFromBFCacheSync()
    1: {
80492:   NS_ASSERTION(mContentViewer && mDocument,
80492:                "we're not in the bfcache!");
80492: 
80492:   nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
80492:   DropPresentationState();
80492: 
80492:   // Warning! The call to DropPresentationState could have dropped the last
80492:   // reference to this nsSHEntry, so no accessing members beyond here.
80492: 
80492:   if (viewer) {
80492:     viewer->Destroy();
80492:   }
58185: }
58185: 
58185: void
58185: nsSHEntry::RemoveFromBFCacheAsync()
58185: {
80492:   NS_ASSERTION(mContentViewer && mDocument,
80492:                "we're not in the bfcache!");
80492: 
80492:   // Release the reference to the contentviewer asynchronously so that the
80492:   // document doesn't get nuked mid-mutation.
80492: 
80492:   nsCOMPtr<nsIRunnable> evt =
80492:       new DestroyViewerEvent(mContentViewer, mDocument);
80492:   nsresult rv = NS_DispatchToCurrentThread(evt);
80492:   if (NS_FAILED(rv)) {
80492:     NS_WARNING("failed to dispatch DestroyViewerEvent");
80492:   }
80492:   else {
80492:     // Drop presentation. Also ensures that we don't post more then one
80492:     // PLEvent. Only do this if we succeeded in posting the event since
80492:     // otherwise the document could be torn down mid mutation causing crashes.
80492:     DropPresentationState();
80492:   }
80492:   // Warning! The call to DropPresentationState could have dropped the last
80492:   // reference to this nsSHEntry, so no accessing members beyond here.
    1: }
14631: 
14631: nsDocShellEditorData*
14631: nsSHEntry::ForgetEditorData()
14631: {
80492:   return mEditorData.forget();
14631: }
14631: 
14631: void
14631: nsSHEntry::SetEditorData(nsDocShellEditorData* aData)
14631: {
80492:   NS_ASSERTION(!(aData && mEditorData),
14631:                "We're going to overwrite an owning ref!");
80492:   if (mEditorData != aData)
80492:     mEditorData = aData;
14631: }
14631: 
79445: bool
14631: nsSHEntry::HasDetachedEditor()
14631: {
80492:   return mEditorData != nsnull;
14631: }
14631: 
37802: NS_IMETHODIMP
69563: nsSHEntry::GetStateData(nsIStructuredCloneContainer **aContainer)
37802: {
69563:   NS_ENSURE_ARG_POINTER(aContainer);
69563:   NS_IF_ADDREF(*aContainer = mStateData);
37802:   return NS_OK;
37802: }
37802: 
37802: NS_IMETHODIMP
69563: nsSHEntry::SetStateData(nsIStructuredCloneContainer *aContainer)
37802: {
69563:   mStateData = aContainer;
37802:   return NS_OK;
37802: }
37802: 
50721: NS_IMETHODIMP
79445: nsSHEntry::IsDynamicallyAdded(bool* aAdded)
50721: {
80492:   *aAdded = mDynamicallyCreated;
50721:   return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
79445: nsSHEntry::HasDynamicallyAddedChild(bool* aAdded)
50721: {
80486:   *aAdded = false;
50721:   for (PRInt32 i = 0; i < mChildren.Count(); ++i) {
50721:     nsISHEntry* entry = mChildren[i];
50721:     if (entry) {
50721:       entry->IsDynamicallyAdded(aAdded);
50721:       if (*aAdded) {
50721:         break;
50721:       }
50721:     }
50721:   }
50721:   return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
50721: nsSHEntry::GetDocshellID(PRUint64* aID)
50721: {
80492:   *aID = mDocShellID;
50721:   return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
50721: nsSHEntry::SetDocshellID(PRUint64 aID)
50721: {
80492:   mDocShellID = aID;
50721:   return NS_OK;
50721: }
50721: 
60876: 
60876: NS_IMETHODIMP
61326: nsSHEntry::GetLastTouched(PRUint32 *aLastTouched)
60876: {
80492:   *aLastTouched = mLastTouched;
60876:   return NS_OK;
60876: }
60876: 
60876: NS_IMETHODIMP
61326: nsSHEntry::SetLastTouched(PRUint32 aLastTouched)
60876: {
80492:   mLastTouched = aLastTouched;
60876:   return NS_OK;
60876: }
80492: 
