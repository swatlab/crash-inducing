52336: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
52336: /* vim: set ts=2 et sw=2 tw=80: */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
52336: 
52336: #include "CheckPermissionsHelper.h"
52336: 
52336: #include "nsIDOMWindow.h"
52336: #include "nsIObserverService.h"
52336: #include "nsIPermissionManager.h"
52336: #include "nsIPrincipal.h"
52336: #include "nsIScriptObjectPrincipal.h"
52336: #include "nsIURI.h"
52336: 
52336: #include "nsContentUtils.h"
52336: #include "nsDOMStorage.h"
52336: #include "nsNetUtil.h"
52336: #include "nsThreadUtils.h"
52336: #include "mozilla/Services.h"
70840: #include "mozilla/Preferences.h"
52336: 
56109: #include "IndexedDatabaseManager.h"
56109: 
52336: #define PERMISSION_INDEXEDDB "indexedDB"
52336: #define PREF_INDEXEDDB_ENABLED "dom.indexedDB.enabled"
52336: #define TOPIC_PERMISSIONS_PROMPT "indexedDB-permissions-prompt"
52336: #define TOPIC_PERMISSIONS_RESPONSE "indexedDB-permissions-response"
52336: 
70840: using namespace mozilla;
52336: USING_INDEXEDDB_NAMESPACE
52336: using namespace mozilla::services;
52336: 
52336: namespace {
52336: 
52336: inline
52336: PRUint32
52336: GetIndexedDBPermissions(const nsACString& aASCIIOrigin,
52336:                         nsIDOMWindow* aWindow)
52336: {
52336:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
52336: 
70840:   if (!Preferences::GetBool(PREF_INDEXEDDB_ENABLED)) {
52336:     return nsIPermissionManager::DENY_ACTION;
52336:   }
52336: 
86555:   // No window here means chrome access
86555:   if (!aWindow) {
86555:     return nsIPermissionManager::ALLOW_ACTION;
86555:   }
86555: 
52336:   nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(aWindow));
52336:   NS_ENSURE_TRUE(sop, nsIPermissionManager::DENY_ACTION);
52336: 
52336:   if (nsContentUtils::IsSystemPrincipal(sop->GetPrincipal())) {
52336:     return nsIPermissionManager::ALLOW_ACTION;
52336:   }
52336: 
99466:   if (nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode()) {
52336:     // TODO Support private browsing indexedDB?
52336:     return nsIPermissionManager::DENY_ACTION;
52336:   }
52336: 
52336:   nsCOMPtr<nsIURI> uri;
52336:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aASCIIOrigin);
52336:   NS_ENSURE_SUCCESS(rv, nsIPermissionManager::DENY_ACTION);
52336: 
52336:   nsCOMPtr<nsIPermissionManager> permissionManager =
52336:     do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
52336:   NS_ENSURE_TRUE(permissionManager, nsIPermissionManager::DENY_ACTION);
52336: 
52336:   PRUint32 permission;
52336:   rv = permissionManager->TestPermission(uri, PERMISSION_INDEXEDDB,
52336:                                          &permission);
52336:   NS_ENSURE_SUCCESS(rv, nsIPermissionManager::DENY_ACTION);
52336: 
52336:   return permission;
52336: }
52336: 
52336: } // anonymous namespace
52336: 
52336: NS_IMPL_THREADSAFE_ISUPPORTS3(CheckPermissionsHelper, nsIRunnable,
52336:                                                       nsIInterfaceRequestor,
52336:                                                       nsIObserver)
52336: 
52336: NS_IMETHODIMP
52336: CheckPermissionsHelper::Run()
52336: {
52336:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
52336: 
52336:   PRUint32 permission = mHasPrompted ?
52336:                         mPromptResult :
52336:                         GetIndexedDBPermissions(mASCIIOrigin, mWindow);
52336: 
52336:   nsresult rv;
52336:   if (mHasPrompted) {
69152:     // Add permissions to the database, but only if we are in the parent
69152:     // process (if we are in the child process, we have already
69152:     // set the permission when the prompt was shown in the parent, as
69152:     // we cannot set the permission from the child).
69152:     if (permission != nsIPermissionManager::UNKNOWN_ACTION &&
69152:         XRE_GetProcessType() == GeckoProcessType_Default) {
52336:       nsCOMPtr<nsIURI> uri;
52336:       rv = NS_NewURI(getter_AddRefs(uri), mASCIIOrigin);
52336:       NS_ENSURE_SUCCESS(rv, rv);
52336:   
52336:       nsCOMPtr<nsIPermissionManager> permissionManager =
52336:         do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
52336:       NS_ENSURE_STATE(permissionManager);
52336:   
52336:       rv = permissionManager->Add(uri, PERMISSION_INDEXEDDB, permission,
52336:                                   nsIPermissionManager::EXPIRE_NEVER, 0);
52336:       NS_ENSURE_SUCCESS(rv, rv);
52336:     }
52336:   }
81572:   else if (permission == nsIPermissionManager::UNKNOWN_ACTION &&
81572:            mPromptAllowed) {
52336:     nsCOMPtr<nsIObserverService> obs = GetObserverService();
52336:     rv = obs->NotifyObservers(static_cast<nsIRunnable*>(this),
52336:                               TOPIC_PERMISSIONS_PROMPT, nsnull);
52336:     NS_ENSURE_SUCCESS(rv, rv);
52336: 
52336:     return NS_OK;
52336:   }
52336: 
80650:   nsRefPtr<OpenDatabaseHelper> helper;
52336:   helper.swap(mHelper);
52336: 
52336:   nsCOMPtr<nsIDOMWindow> window;
52336:   window.swap(mWindow);
52336: 
52336:   if (permission == nsIPermissionManager::ALLOW_ACTION) {
56110:     IndexedDatabaseManager* mgr = IndexedDatabaseManager::Get();
56110:     NS_ASSERTION(mgr, "This should never be null!");
56110: 
56110:     return helper->Dispatch(mgr->IOThread());
52336:   }
52336: 
52336:   NS_ASSERTION(permission == nsIPermissionManager::UNKNOWN_ACTION ||
52336:                permission == nsIPermissionManager::DENY_ACTION,
52336:                "Unknown permission!");
52336: 
57296:   helper->SetError(NS_ERROR_DOM_INDEXEDDB_NOT_ALLOWED_ERR);
80650: 
80650:   return helper->RunImmediately();
52336: }
52336: 
52336: NS_IMETHODIMP
52336: CheckPermissionsHelper::GetInterface(const nsIID& aIID,
52336:                                      void** aResult)
52336: {
52336:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
52336:   if (aIID.Equals(NS_GET_IID(nsIObserver))) {
52336:     return QueryInterface(aIID, aResult);
52336:   }
52336: 
52336:   if (aIID.Equals(NS_GET_IID(nsIDOMWindow))) {
52336:     return mWindow->QueryInterface(aIID, aResult);
52336:   }
52336: 
52336:   *aResult = nsnull;
52336:   return NS_ERROR_NOT_AVAILABLE;
52336: }
52336: 
52336: NS_IMETHODIMP
52336: CheckPermissionsHelper::Observe(nsISupports* aSubject,
52336:                                 const char* aTopic,
52336:                                 const PRUnichar* aData)
52336: {
52336:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
52336:   NS_ASSERTION(!strcmp(aTopic, TOPIC_PERMISSIONS_RESPONSE), "Bad topic!");
81572:   NS_ASSERTION(mPromptAllowed, "How did we get here?");
52336: 
80486:   mHasPrompted = true;
52336: 
52336:   nsresult rv;
52336:   mPromptResult = nsDependentString(aData).ToInteger(&rv);
52336:   NS_ENSURE_SUCCESS(rv, rv);
52336: 
81257:   rv = NS_DispatchToCurrentThread(this);
56109:   NS_ENSURE_SUCCESS(rv, rv);
56109: 
56109:   return NS_OK;
52336: }
