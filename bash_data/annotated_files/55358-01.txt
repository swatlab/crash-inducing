    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    8:  *   Robert O'Callahan <robert@ocallahan.org>
    1:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Prabhat Hegde <prabhat.hegde@sun.com>
    1:  *   Tomi Leppikangas <tomi.leppikangas@oulu.fi>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Neil Deakin <neil@mozdevgroup.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *   Uri Bernstein <uriber@gmail.com>
    1:  *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>
15339:  *   Michael Ventnor <m.ventnor@gmail.com>
22917:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for textual content of elements */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsCRT.h"
    1: #include "nsSplittableFrame.h"
    1: #include "nsLineLayout.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsStyleContext.h"
    1: #include "nsCoord.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsITimer.h"
24551: #include "nsTArray.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsCompatibility.h"
    1: #include "nsCSSColorUtils.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsFrame.h"
32107: #include "nsPlaceholderFrame.h"
    1: #include "nsTextFrameUtils.h"
    1: #include "nsTextRunTransformations.h"
   60: #include "nsFrameManager.h"
 1328: #include "nsTextFrameTextRunCache.h"
 1328: #include "nsExpirationTracker.h"
 6247: #include "nsTextFrame.h"
 5453: #include "nsIUGenCategory.h"
 5453: #include "nsUnicharUtilCIID.h"
    1: 
    1: #include "nsTextFragment.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsISelection.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsContentUtils.h"
    1: #include "nsLineBreaker.h"
 2319: #include "nsIWordBreaker.h"
29809: #include "nsGenericDOMDataNode.h"
    1: 
    1: #include "nsILineIterator.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsAutoPtr.h"
    1: 
    1: #include "nsBidiFrames.h"
    1: #include "nsBidiPresUtils.h"
    1: #include "nsBidiUtils.h"
    1: 
    1: #include "nsIThebesFontMetrics.h"
    1: #include "gfxFont.h"
    1: #include "gfxContext.h"
 2319: #include "gfxTextRunWordCache.h"
15339: #include "gfxImageSurface.h"
41930: #include "mozilla/dom/Element.h"
    1: 
    1: #ifdef NS_DEBUG
    1: #undef NOISY_BLINK
    1: #undef NOISY_REFLOW
    1: #undef NOISY_TRIM
    1: #else
    1: #undef NOISY_BLINK
    1: #undef NOISY_REFLOW
    1: #undef NOISY_TRIM
    1: #endif
    1: 
39965: using namespace mozilla;
41641: using namespace mozilla::dom;
39965: 
39965: static void DestroyTabWidth(void* aPropertyValue)
39965: {
39965:   delete static_cast<nsTArray<gfxFloat>*>(aPropertyValue);
39965: }
39965: 
39965: NS_DECLARE_FRAME_PROPERTY(TabWidthProperty, DestroyTabWidth)
39965: 
49293: NS_DECLARE_FRAME_PROPERTY(OffsetToFrameProperty, nsnull)
49293: 
    1: // The following flags are set during reflow
    1: 
    1: // This bit is set on the first frame in a continuation indicating
    1: // that it was chopped short because of :first-letter style.
43376: #define TEXT_FIRST_LETTER    NS_FRAME_STATE_BIT(20)
    1: // This bit is set on frames that are logically adjacent to the start of the
    1: // line (i.e. no prior frame on line with actual displayed in-flow content).
43376: #define TEXT_START_OF_LINE   NS_FRAME_STATE_BIT(21)
    1: // This bit is set on frames that are logically adjacent to the end of the
    1: // line (i.e. no following on line with actual displayed in-flow content).
43376: #define TEXT_END_OF_LINE     NS_FRAME_STATE_BIT(22)
    1: // This bit is set on frames that end with a hyphenated break.
43376: #define TEXT_HYPHEN_BREAK    NS_FRAME_STATE_BIT(23)
    8: // This bit is set on frames that trimmed trailing whitespace characters when
    8: // calculating their width during reflow.
43376: #define TEXT_TRIMMED_TRAILING_WHITESPACE NS_FRAME_STATE_BIT(24)
16575: // This bit is set on frames that have justification enabled. We record
16575: // this in a state bit because we don't always have the containing block
16575: // easily available to check text-align on.
43376: #define TEXT_JUSTIFICATION_ENABLED       NS_FRAME_STATE_BIT(25)
13714: // Set this bit if the textframe has overflow area for IME/spellcheck underline.
43376: #define TEXT_SELECTION_UNDERLINE_OVERFLOWED NS_FRAME_STATE_BIT(26)
    1: 
    1: #define TEXT_REFLOW_FLAGS    \
    8:   (TEXT_FIRST_LETTER|TEXT_START_OF_LINE|TEXT_END_OF_LINE|TEXT_HYPHEN_BREAK| \
16575:    TEXT_TRIMMED_TRAILING_WHITESPACE|TEXT_JUSTIFICATION_ENABLED| \
16575:    TEXT_HAS_NONCOLLAPSED_CHARACTERS|TEXT_SELECTION_UNDERLINE_OVERFLOWED)
    1: 
    1: // Cache bits for IsEmpty().
    1: // Set this bit if the textframe is known to be only collapsible whitespace.
43376: #define TEXT_IS_ONLY_WHITESPACE    NS_FRAME_STATE_BIT(27)
    1: // Set this bit if the textframe is known to be not only collapsible whitespace.
43376: #define TEXT_ISNOT_ONLY_WHITESPACE NS_FRAME_STATE_BIT(28)
43376: 
43376: #define TEXT_WHITESPACE_FLAGS      (TEXT_IS_ONLY_WHITESPACE | \
43376:                                     TEXT_ISNOT_ONLY_WHITESPACE)
35581: // This bit is set while the frame is registered as a blinking frame.
43376: #define TEXT_BLINK_ON              NS_FRAME_STATE_BIT(29)
16737: 
22875: // Set when this text frame is mentioned in the userdata for a textrun
43376: #define TEXT_IN_TEXTRUN_USER_DATA  NS_FRAME_STATE_BIT(30)
22875: 
16737: // nsTextFrame.h has
43376: // #define TEXT_HAS_NONCOLLAPSED_CHARACTERS NS_FRAME_STATE_BIT(31)
    1: 
49293: // Whether this frame is cached in the Offset Frame Cache (OffsetToFrameProperty)
49293: #define TEXT_IN_OFFSET_CACHE       NS_FRAME_STATE_BIT(63)
49293: 
    1: /*
    1:  * Some general notes
    1:  * 
    1:  * Text frames delegate work to gfxTextRun objects. The gfxTextRun object
    1:  * transforms text to positioned glyphs. It can report the geometry of the
    1:  * glyphs and paint them. Text frames configure gfxTextRuns by providing text,
    1:  * spacing, language, and other information.
    1:  * 
    1:  * A gfxTextRun can cover more than one DOM text node. This is necessary to
    1:  * get kerning, ligatures and shaping for text that spans multiple text nodes
    1:  * but is all the same font. The userdata for a gfxTextRun object is a
    1:  * TextRunUserData* or an nsIFrame*.
    1:  * 
    1:  * We go to considerable effort to make sure things work even if in-flow
    1:  * siblings have different style contexts (i.e., first-letter and first-line).
    1:  * 
    1:  * Our convention is that unsigned integer character offsets are offsets into
    1:  * the transformed string. Signed integer character offsets are offsets into
    1:  * the DOM string.
    1:  * 
    1:  * XXX currently we don't handle hyphenated breaks between text frames where the
    1:  * hyphen occurs at the end of the first text frame, e.g.
    1:  *   <b>Kit&shy;</b>ty
    1:  */
    1: 
    1: /**
    1:  * We use an array of these objects to record which text frames
    1:  * are associated with the textrun. mStartFrame is the start of a list of
    1:  * text frames. Some sequence of its continuations are covered by the textrun.
    1:  * A content textnode can have at most one TextRunMappedFlow associated with it
    1:  * for a given textrun.
    1:  * 
    1:  * mDOMOffsetToBeforeTransformOffset is added to DOM offsets for those frames to obtain
    1:  * the offset into the before-transformation text of the textrun. It can be
    1:  * positive (when a text node starts in the middle of a text run) or
 2344:  * negative (when a text run starts in the middle of a text node). Of course
 2344:  * it can also be zero.
    1:  */
    1: struct TextRunMappedFlow {
    1:   nsTextFrame* mStartFrame;
    1:   PRInt32      mDOMOffsetToBeforeTransformOffset;
    1:   // The text mapped starts at mStartFrame->GetContentOffset() and is this long
    1:   PRUint32     mContentLength;
    1: };
    1: 
    1: /**
 2344:  * This is our user data for the textrun, when textRun->GetFlags() does not
34012:  * have TEXT_IS_SIMPLE_FLOW set. When TEXT_IS_SIMPLE_FLOW is set, there is
34012:  * just one flow, the textrun's user data pointer is a pointer to mStartFrame
 2344:  * for that flow, mDOMOffsetToBeforeTransformOffset is zero, and mContentLength
 2344:  * is the length of the text node.
    1:  */
    1: struct TextRunUserData {
    1:   TextRunMappedFlow* mMappedFlows;
    1:   PRInt32            mMappedFlowCount;
    1: 
    1:   PRUint32           mLastFlowIndex;
    1: };
    1: 
    1: /**
    1:  * This helper object computes colors used for painting, and also IME
    1:  * underline information. The data is computed lazily and cached as necessary.
    1:  * These live for just the duration of one paint operation.
    1:  */
    1: class nsTextPaintStyle {
    1: public:
    1:   nsTextPaintStyle(nsTextFrame* aFrame);
    1: 
    1:   nscolor GetTextColor();
    1:   /**
    1:    * Compute the colors for normally-selected text. Returns false if
    1:    * the normal selection is not being displayed.
    1:    */
    1:   PRBool GetSelectionColors(nscolor* aForeColor,
    1:                             nscolor* aBackColor);
16313:   void GetHighlightColors(nscolor* aForeColor,
16313:                           nscolor* aBackColor);
    1:   void GetIMESelectionColors(PRInt32  aIndex,
    1:                              nscolor* aForeColor,
    1:                              nscolor* aBackColor);
    1:   // if this returns PR_FALSE, we don't need to draw underline.
26883:   PRBool GetSelectionUnderlineForPaint(PRInt32  aIndex,
26883:                                        nscolor* aLineColor,
26883:                                        float*   aRelativeSize,
26883:                                        PRUint8* aStyle);
26883: 
26883:   // if this returns PR_FALSE, we don't need to draw underline.
26883:   static PRBool GetSelectionUnderline(nsPresContext* aPresContext,
26883:                                       PRInt32 aIndex,
    1:                                       nscolor* aLineColor,
 4728:                                       float* aRelativeSize,
 4728:                                       PRUint8* aStyle);
    1: 
  280:   nsPresContext* PresContext() { return mPresContext; }
    1: 
    1:   enum {
    1:     eIndexRawInput = 0,
    1:     eIndexSelRawText,
    1:     eIndexConvText,
26883:     eIndexSelConvText,
26883:     eIndexSpellChecker
    1:   };
    1: 
26883:   static PRInt32 GetUnderlineStyleIndexForSelectionType(PRInt32 aSelectionType)
26883:   {
26883:     switch (aSelectionType) {
26883:       case nsISelectionController::SELECTION_IME_RAWINPUT:
26883:         return eIndexRawInput;
26883:       case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
26883:         return eIndexSelRawText;
26883:       case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
26883:         return eIndexConvText;
26883:       case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
26883:         return eIndexSelConvText;
26883:       case nsISelectionController::SELECTION_SPELLCHECK:
26883:         return eIndexSpellChecker;
26883:       default:
26883:         NS_WARNING("non-IME selection type");
26883:         return eIndexRawInput;
26883:     }
26883:   }
26883: 
    1: protected:
    1:   nsTextFrame*   mFrame;
    1:   nsPresContext* mPresContext;
    1:   PRPackedBool   mInitCommonColors;
    1:   PRPackedBool   mInitSelectionColors;
    1: 
    1:   // Selection data
    1: 
    1:   PRInt16      mSelectionStatus; // see nsIDocument.h SetDisplaySelection()
    1:   nscolor      mSelectionTextColor;
    1:   nscolor      mSelectionBGColor;
    1: 
    1:   // Common data
    1: 
    1:   PRInt32 mSufficientContrast;
    1:   nscolor mFrameBackgroundColor;
    1: 
26883:   // selection colors and underline info, the colors are resolved colors,
26883:   // i.e., the foreground color and background color are swapped if it's needed.
26883:   // And also line color will be resolved from them.
26883:   struct nsSelectionStyle {
    1:     PRBool mInit;
    1:     nscolor mTextColor;
    1:     nscolor mBGColor;
    1:     nscolor mUnderlineColor;
 4728:     PRUint8 mUnderlineStyle;
26883:     float   mUnderlineRelativeSize;
    1:   };
26883:   nsSelectionStyle mSelectionStyle[5];
    1: 
    1:   // Color initializations
    1:   void InitCommonColors();
    1:   PRBool InitSelectionColors();
    1: 
26883:   nsSelectionStyle* GetSelectionStyle(PRInt32 aIndex);
26883:   void InitSelectionStyle(PRInt32 aIndex);
    1: 
    1:   PRBool EnsureSufficientContrast(nscolor *aForeColor, nscolor *aBackColor);
    1: 
    1:   nscolor GetResolvedForeColor(nscolor aColor, nscolor aDefaultForeColor,
    1:                                nscolor aBackColor);
    1: };
    1: 
 1328: static void
 1328: DestroyUserData(void* aUserData)
 1328: {
 3233:   TextRunUserData* userData = static_cast<TextRunUserData*>(aUserData);
 1328:   if (userData) {
 1328:     nsMemory::Free(userData);
 1328:   }
 1328: }
 1328: 
 2344: // Remove the textrun from the frame continuation chain starting at aFrame,
 2344: // which should be marked as a textrun owner.
 1328: static void
 1328: ClearAllTextRunReferences(nsTextFrame* aFrame, gfxTextRun* aTextRun)
 1328: {
22875:   aFrame->RemoveStateBits(TEXT_IN_TEXTRUN_USER_DATA);
 1328:   while (aFrame) {
22875:     NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame,
22875:                  "Bad frame");
 1328:     if (aFrame->GetTextRun() != aTextRun)
 1328:       break;
 1328:     aFrame->SetTextRun(nsnull);
 3233:     aFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
 1328:   }
 1328: }
 1328: 
 2344: // Figure out which frames 
 1328: static void
 1328: UnhookTextRunFromFrames(gfxTextRun* aTextRun)
 1328: {
 1328:   if (!aTextRun->GetUserData())
 1328:     return;
 1328: 
 1328:   // Kill all references to the textrun. It could be referenced by any of its
 1328:   // owners, and all their in-flows.
 1328:   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
 3233:     nsIFrame* firstInFlow = static_cast<nsIFrame*>(aTextRun->GetUserData());
 3233:     ClearAllTextRunReferences(static_cast<nsTextFrame*>(firstInFlow), aTextRun);
 1328:   } else {
 1328:     TextRunUserData* userData =
 3233:       static_cast<TextRunUserData*>(aTextRun->GetUserData());
 1328:     PRInt32 i;
 1328:     for (i = 0; i < userData->mMappedFlowCount; ++i) {
 1328:       ClearAllTextRunReferences(userData->mMappedFlows[i].mStartFrame, aTextRun);
 1328:     }
 1328:     DestroyUserData(userData);
 1328:   }
 1328:   aTextRun->SetUserData(nsnull);  
 1328: }
 1328: 
 1328: class FrameTextRunCache;
 1328: 
 1328: static FrameTextRunCache *gTextRuns = nsnull;
 1328: 
 1328: /*
 1328:  * Cache textruns and expire them after 3*10 seconds of no use.
 1328:  */
 1328: class FrameTextRunCache : public nsExpirationTracker<gfxTextRun,3> {
 1328: public:
 1328:   enum { TIMEOUT_SECONDS = 10 };
 1328:   FrameTextRunCache()
 1328:       : nsExpirationTracker<gfxTextRun,3>(TIMEOUT_SECONDS*1000) {}
 1328:   ~FrameTextRunCache() {
 1328:     AgeAllGenerations();
 1328:   }
 1328: 
 1328:   void RemoveFromCache(gfxTextRun* aTextRun) {
 2319:     if (aTextRun->GetExpirationState()->IsTracked()) {
 1328:       RemoveObject(aTextRun);
 2319:     }
 3118:     if (aTextRun->GetFlags() & gfxTextRunWordCache::TEXT_IN_CACHE) {
 3118:       gfxTextRunWordCache::RemoveTextRun(aTextRun);
 1328:     }
 1328:   }
 1328: 
 1328:   // This gets called when the timeout has expired on a gfxTextRun
 1328:   virtual void NotifyExpired(gfxTextRun* aTextRun) {
 1328:     UnhookTextRunFromFrames(aTextRun);
 1328:     RemoveFromCache(aTextRun);
 1328:     delete aTextRun;
 1328:   }
 1328: };
 1328: 
 1328: static gfxTextRun *
 1328: MakeTextRun(const PRUnichar *aText, PRUint32 aLength,
 1328:             gfxFontGroup *aFontGroup, const gfxFontGroup::Parameters* aParams,
 1328:             PRUint32 aFlags)
 1328: {
 1328:     nsAutoPtr<gfxTextRun> textRun;
 1328:     if (aLength == 0) {
 3118:         textRun = aFontGroup->MakeEmptyTextRun(aParams, aFlags);
 1328:     } else if (aLength == 1 && aText[0] == ' ') {
 3118:         textRun = aFontGroup->MakeSpaceTextRun(aParams, aFlags);
 1328:     } else {
 3118:         textRun = gfxTextRunWordCache::MakeTextRun(aText, aLength, aFontGroup,
 3118:             aParams, aFlags);
 1328:     }
 1328:     if (!textRun)
 1328:         return nsnull;
 1328:     nsresult rv = gTextRuns->AddObject(textRun);
 2319:     if (NS_FAILED(rv)) {
 2319:         gTextRuns->RemoveFromCache(textRun);
 1328:         return nsnull;
 2319:     }
 1328:     return textRun.forget();
 1328: }
 1328: 
 1328: static gfxTextRun *
 1328: MakeTextRun(const PRUint8 *aText, PRUint32 aLength,
 1328:             gfxFontGroup *aFontGroup, const gfxFontGroup::Parameters* aParams,
 1328:             PRUint32 aFlags)
 1328: {
 1328:     nsAutoPtr<gfxTextRun> textRun;
 1328:     if (aLength == 0) {
 3118:         textRun = aFontGroup->MakeEmptyTextRun(aParams, aFlags);
 1328:     } else if (aLength == 1 && aText[0] == ' ') {
 3118:         textRun = aFontGroup->MakeSpaceTextRun(aParams, aFlags);
 1328:     } else {
 3118:         textRun = gfxTextRunWordCache::MakeTextRun(aText, aLength, aFontGroup,
 3118:             aParams, aFlags);
 1328:     }
 1328:     if (!textRun)
 1328:         return nsnull;
 1328:     nsresult rv = gTextRuns->AddObject(textRun);
 2319:     if (NS_FAILED(rv)) {
 2319:         gTextRuns->RemoveFromCache(textRun);
 1328:         return nsnull;
 2319:     }
 1328:     return textRun.forget();
 1328: }
 1328: 
 1328: nsresult
 1328: nsTextFrameTextRunCache::Init() {
 1328:     gTextRuns = new FrameTextRunCache();
 1328:     return gTextRuns ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 1328: }
 1328: 
 1328: void
 1328: nsTextFrameTextRunCache::Shutdown() {
 1328:     delete gTextRuns;
 1328:     gTextRuns = nsnull;
 1328: }
 1328: 
 4678: PRInt32 nsTextFrame::GetContentEnd() const {
 4678:   nsTextFrame* next = static_cast<nsTextFrame*>(GetNextContinuation());
35581:   return next ? next->GetContentOffset() : mContent->GetText()->GetLength();
 4678: }
 4678: 
    1: PRInt32 nsTextFrame::GetInFlowContentLength() {
    1: #ifdef IBMBIDI
    1:   nsTextFrame* nextBidi = nsnull;
    1:   PRInt32      start = -1, end;
    1: 
    1:   if (mState & NS_FRAME_IS_BIDI) {
 3233:     nextBidi = static_cast<nsTextFrame*>(GetLastInFlow()->GetNextContinuation());
    1:     if (nextBidi) {
    1:       nextBidi->GetOffsets(start, end);
    1:       return start - mContentOffset;
    1:     }
    1:   }
    1: #endif //IBMBIDI
35581:   return mContent->TextLength() - mContentOffset;
    1: }
    1: 
    1: // Smarter versions of XP_IS_SPACE.
    1: // Unicode is really annoying; sometimes a space character isn't whitespace ---
    1: // when it combines with another character
    1: // So we have several versions of IsSpace for use in different contexts.
    1: 
 2344: static PRBool IsSpaceCombiningSequenceTail(const nsTextFragment* aFrag, PRUint32 aPos)
 2344: {
 2344:   NS_ASSERTION(aPos <= aFrag->GetLength(), "Bad offset");
 2344:   if (!aFrag->Is2b())
 2344:     return PR_FALSE;
 2344:   return nsTextFrameUtils::IsSpaceCombiningSequenceTail(
 2344:     aFrag->Get2b() + aPos, aFrag->GetLength() - aPos);
 2344: }
 2344: 
 2344: // Check whether aPos is a space for CSS 'word-spacing' purposes
16575: static PRBool IsCSSWordSpacingSpace(const nsTextFragment* aFrag,
22494:                                     PRUint32 aPos, const nsStyleText* aStyleText)
    1: {
    1:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
16575: 
    1:   PRUnichar ch = aFrag->CharAt(aPos);
22494:   switch (ch) {
22494:   case ' ':
22494:   case CH_NBSP:
 2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
46149:   case '\r':
22494:   case '\t': return !aStyleText->WhiteSpaceIsSignificant();
22494:   case '\n': return !aStyleText->NewlineIsSignificant();
22494:   default: return PR_FALSE;
22494:   }
16575: }
16575: 
16575: // Check whether the string aChars/aLength starts with space that's
16575: // trimmable according to CSS 'white-space:normal/nowrap'. 
 2344: static PRBool IsTrimmableSpace(const PRUnichar* aChars, PRUint32 aLength)
    1: {
    1:   NS_ASSERTION(aLength > 0, "No text for IsSpace!");
16575: 
    1:   PRUnichar ch = *aChars;
 2344:   if (ch == ' ')
    1:     return !nsTextFrameUtils::IsSpaceCombiningSequenceTail(aChars + 1, aLength - 1);
46149:   return ch == '\t' || ch == '\f' || ch == '\n' || ch == '\r';
16575: }
16575: 
16575: // Check whether the character aCh is trimmable according to CSS
16575: // 'white-space:normal/nowrap'
 2344: static PRBool IsTrimmableSpace(char aCh)
    1: {
46149:   return aCh == ' ' || aCh == '\t' || aCh == '\f' || aCh == '\n' || aCh == '\r';
16575: }
16575: 
16575: static PRBool IsTrimmableSpace(const nsTextFragment* aFrag, PRUint32 aPos,
16575:                                const nsStyleText* aStyleText)
    1: {
    1:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
16575: 
16575:   switch (aFrag->CharAt(aPos)) {
16575:   case ' ': return !aStyleText->WhiteSpaceIsSignificant() &&
16575:                    !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
16575:   case '\n': return !aStyleText->NewlineIsSignificant();
16575:   case '\t':
46149:   case '\r':
16575:   case '\f': return !aStyleText->WhiteSpaceIsSignificant();
16575:   default: return PR_FALSE;
16575:   }
 6529: }
 6529: 
 2319: static PRBool IsSelectionSpace(const nsTextFragment* aFrag, PRUint32 aPos)
 2319: {
 2319:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
 2319:   PRUnichar ch = aFrag->CharAt(aPos);
 3049:   if (ch == ' ' || ch == CH_NBSP)
 2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
46149:   return ch == '\t' || ch == '\n' || ch == '\f' || ch == '\r';
 2319: }
 2344: 
16575: // Count the amount of trimmable whitespace (as per CSS
16575: // 'white-space:normal/nowrap') in a text fragment. The first
 2344: // character is at offset aStartOffset; the maximum number of characters
 2344: // to check is aLength. aDirection is -1 or 1 depending on whether we should
 2344: // progress backwards or forwards.
 2344: static PRUint32
16575: GetTrimmableWhitespaceCount(const nsTextFragment* aFrag,
16575:                             PRInt32 aStartOffset, PRInt32 aLength,
16575:                             PRInt32 aDirection)
    1: {
    1:   PRInt32 count = 0;
 2344:   if (aFrag->Is2b()) {
 2344:     const PRUnichar* str = aFrag->Get2b() + aStartOffset;
 2344:     PRInt32 fragLen = aFrag->GetLength() - aStartOffset;
    1:     for (; count < aLength; ++count) {
 2344:       if (!IsTrimmableSpace(str, fragLen))
    1:         break;
    1:       str += aDirection;
    1:       fragLen -= aDirection;
    1:     }
    1:   } else {
 2344:     const char* str = aFrag->Get1b() + aStartOffset;
    1:     for (; count < aLength; ++count) {
 2344:       if (!IsTrimmableSpace(*str))
    1:         break;
    1:       str += aDirection;
    1:     }
    1:   }
    1:   return count;
    1: }
    1: 
16575: static PRBool
16575: IsAllWhitespace(const nsTextFragment* aFrag, PRBool aAllowNewline)
16575: {
16575:   if (aFrag->Is2b())
16575:     return PR_FALSE;
16575:   PRInt32 len = aFrag->GetLength();
16575:   const char* str = aFrag->Get1b();
16575:   for (PRInt32 i = 0; i < len; ++i) {
16575:     char ch = str[i];
46149:     if (ch == ' ' || ch == '\t' || ch == '\r' || (ch == '\n' && aAllowNewline))
16575:       continue;
16575:     return PR_FALSE;
16575:   }
16575:   return PR_TRUE;
16575: }
16575: 
    1: /**
    1:  * This class accumulates state as we scan a paragraph of text. It detects
    1:  * textrun boundaries (changes from text to non-text, hard
    1:  * line breaks, and font changes) and builds a gfxTextRun at each boundary.
    1:  * It also detects linebreaker run boundaries (changes from text to non-text,
    1:  * and hard line breaks) and at each boundary runs the linebreaker to compute
    1:  * potential line breaks. It also records actual line breaks to store them in
    1:  * the textruns.
    1:  */
    1: class BuildTextRunsScanner {
    1: public:
 2319:   BuildTextRunsScanner(nsPresContext* aPresContext, gfxContext* aContext,
 2319:       nsIFrame* aLineContainer) :
 1817:     mCurrentFramesAllSameTextRun(nsnull),
 2319:     mContext(aContext),
 2319:     mLineContainer(aLineContainer),
 2319:     mBidiEnabled(aPresContext->BidiEnabled()),
22935:     mSkipIncompleteTextRuns(PR_FALSE),
22917:     mNextRunContextInfo(nsTextFrameUtils::INCOMING_NONE),
22935:     mCurrentRunContextInfo(nsTextFrameUtils::INCOMING_NONE) {
    1:     ResetRunInfo();
    1:   }
23491:   ~BuildTextRunsScanner() {
23491:     NS_ASSERTION(mBreakSinks.IsEmpty(), "Should have been cleared");
23491:     NS_ASSERTION(mTextRunsToDelete.IsEmpty(), "Should have been cleared");
23491:     NS_ASSERTION(mLineBreakBeforeFrames.IsEmpty(), "Should have been cleared");
23491:     NS_ASSERTION(mMappedFlows.IsEmpty(), "Should have been cleared");
23491:   }
    1: 
    1:   void SetAtStartOfLine() {
    1:     mStartOfLine = PR_TRUE;
 7722:     mCanStopOnThisLine = PR_FALSE;
    1:   }
 2319:   void SetSkipIncompleteTextRuns(PRBool aSkip) {
 2319:     mSkipIncompleteTextRuns = aSkip;
 2319:   }
    1:   void SetCommonAncestorWithLastFrame(nsIFrame* aFrame) {
    1:     mCommonAncestorWithLastFrame = aFrame;
    1:   }
 7722:   PRBool CanStopOnThisLine() {
 7722:     return mCanStopOnThisLine;
 7722:   }
    1:   nsIFrame* GetCommonAncestorWithLastFrame() {
    1:     return mCommonAncestorWithLastFrame;
    1:   }
    8:   void LiftCommonAncestorWithLastFrameToParent(nsIFrame* aFrame) {
    8:     if (mCommonAncestorWithLastFrame &&
    8:         mCommonAncestorWithLastFrame->GetParent() == aFrame) {
    8:       mCommonAncestorWithLastFrame = aFrame;
    8:     }
    8:   }
    1:   void ScanFrame(nsIFrame* aFrame);
 6033:   PRBool IsTextRunValidForMappedFlows(gfxTextRun* aTextRun);
 8857:   void FlushFrames(PRBool aFlushLineBreaks, PRBool aSuppressTrailingBreak);
23491:   void FlushLineBreaks(gfxTextRun* aTrailingTextRun);
    1:   void ResetRunInfo() {
    1:     mLastFrame = nsnull;
    1:     mMappedFlows.Clear();
    8:     mLineBreakBeforeFrames.Clear();
    1:     mMaxTextLength = 0;
    1:     mDoubleByteText = PR_FALSE;
    1:   }
    1:   void AccumulateRunInfo(nsTextFrame* aFrame);
 8573:   /**
 8573:    * @return null to indicate either textrun construction failed or
 8573:    * we constructed just a partial textrun to set up linebreaker and other
 8573:    * state for following textruns.
 8573:    */
 8573:   gfxTextRun* BuildTextRunForFrames(void* aTextBuffer);
    1:   void AssignTextRun(gfxTextRun* aTextRun);
    1:   nsTextFrame* GetNextBreakBeforeFrame(PRUint32* aIndex);
 2319:   void SetupBreakSinksForTextRun(gfxTextRun* aTextRun, PRBool aIsExistingTextRun,
 2319:                                  PRBool aSuppressSink);
 2319:   struct FindBoundaryState {
 2319:     nsIFrame*    mStopAtFrame;
 2319:     nsTextFrame* mFirstTextFrame;
 2319:     nsTextFrame* mLastTextFrame;
 2319:     PRPackedBool mSeenTextRunBoundaryOnLaterLine;
 2319:     PRPackedBool mSeenTextRunBoundaryOnThisLine;
 2319:     PRPackedBool mSeenSpaceForLineBreakingOnThisLine;
 2319:   };
 2319:   enum FindBoundaryResult {
 2319:     FB_CONTINUE,
 2319:     FB_STOPPED_AT_STOP_FRAME,
 2319:     FB_FOUND_VALID_TEXTRUN_BOUNDARY
 2319:   };
 2319:   FindBoundaryResult FindBoundaries(nsIFrame* aFrame, FindBoundaryState* aState);
    1: 
 3009:   PRBool ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2);
    1: 
    1:   // Like TextRunMappedFlow but with some differences. mStartFrame to mEndFrame
 6033:   // (exclusive) are a sequence of in-flow frames (if mEndFrame is null, then
 6033:   // continuations starting from mStartFrame are a sequence of in-flow frames).
    1:   struct MappedFlow {
    1:     nsTextFrame* mStartFrame;
    1:     nsTextFrame* mEndFrame;
 2013:     // When we consider breaking between elements, the nearest common
 2013:     // ancestor of the elements containing the characters is the one whose
    1:     // CSS 'white-space' property governs. So this records the nearest common
    1:     // ancestor of mStartFrame and the previous text frame, or null if there
    1:     // was no previous text frame on this line.
    1:     nsIFrame*    mAncestorControllingInitialBreak;
 6033:     
 6033:     PRInt32 GetContentEnd() {
 6033:       return mEndFrame ? mEndFrame->GetContentOffset()
35581:           : mStartFrame->GetContent()->GetText()->GetLength();
 6033:     }
    1:   };
    1: 
    1:   class BreakSink : public nsILineBreakSink {
    1:   public:
 2834:     BreakSink(gfxTextRun* aTextRun, gfxContext* aContext, PRUint32 aOffsetIntoTextRun,
    1:               PRBool aExistingTextRun) :
 2834:                 mTextRun(aTextRun), mContext(aContext),
 2834:                 mOffsetIntoTextRun(aOffsetIntoTextRun),
    1:                 mChangedBreaks(PR_FALSE), mExistingTextRun(aExistingTextRun) {}
    1: 
    1:     virtual void SetBreaks(PRUint32 aOffset, PRUint32 aLength,
    1:                            PRPackedBool* aBreakBefore) {
    1:       if (mTextRun->SetPotentialLineBreaks(aOffset + mOffsetIntoTextRun, aLength,
 2834:                                            aBreakBefore, mContext)) {
    1:         mChangedBreaks = PR_TRUE;
 7069:         // Be conservative and assume that some breaks have been set
 7069:         mTextRun->ClearFlagBits(nsTextFrameUtils::TEXT_NO_BREAKS);
    1:       }
    1:     }
    1:     
 7832:     virtual void SetCapitalization(PRUint32 aOffset, PRUint32 aLength,
 7832:                                    PRPackedBool* aCapitalize) {
 7832:       NS_ASSERTION(mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_TRANSFORMED,
 7832:                    "Text run should be transformed!");
 7832:       nsTransformedTextRun* transformedTextRun =
 7832:         static_cast<nsTransformedTextRun*>(mTextRun);
 7832:       transformedTextRun->SetCapitalization(aOffset + mOffsetIntoTextRun, aLength,
 7832:                                             aCapitalize, mContext);
 7832:     }
 7832: 
23491:     void Finish() {
23491:       NS_ASSERTION(!(mTextRun->GetFlags() &
23491:                      (gfxTextRunWordCache::TEXT_UNUSED_FLAGS |
23491:                       nsTextFrameUtils::TEXT_UNUSED_FLAG)),
23491:                    "Flag set that should never be set! (memory safety error?)");
23491:       if (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_TRANSFORMED) {
23491:         nsTransformedTextRun* transformedTextRun =
23491:           static_cast<nsTransformedTextRun*>(mTextRun);
23491:         transformedTextRun->FinishSettingProperties(mContext);
23491:       }
23491:     }
23491: 
    1:     gfxTextRun*  mTextRun;
 2834:     gfxContext*  mContext;
    1:     PRUint32     mOffsetIntoTextRun;
    1:     PRPackedBool mChangedBreaks;
    1:     PRPackedBool mExistingTextRun;
    1:   };
    1: 
    1: private:
    1:   nsAutoTArray<MappedFlow,10>   mMappedFlows;
    1:   nsAutoTArray<nsTextFrame*,50> mLineBreakBeforeFrames;
   60:   nsAutoTArray<nsAutoPtr<BreakSink>,10> mBreakSinks;
23491:   nsAutoTArray<gfxTextRun*,5>   mTextRunsToDelete;
    1:   nsLineBreaker                 mLineBreaker;
    1:   gfxTextRun*                   mCurrentFramesAllSameTextRun;
    1:   gfxContext*                   mContext;
 2319:   nsIFrame*                     mLineContainer;
    1:   nsTextFrame*                  mLastFrame;
 8573:   // The common ancestor of the current frame and the previous leaf frame
 8573:   // on the line, or null if there was no previous leaf frame.
    1:   nsIFrame*                     mCommonAncestorWithLastFrame;
    1:   // mMaxTextLength is an upper bound on the size of the text in all mapped frames
    1:   PRUint32                      mMaxTextLength;
    1:   PRPackedBool                  mDoubleByteText;
    1:   PRPackedBool                  mBidiEnabled;
    1:   PRPackedBool                  mStartOfLine;
 2319:   PRPackedBool                  mSkipIncompleteTextRuns;
 7722:   PRPackedBool                  mCanStopOnThisLine;
22917:   PRUint8                       mNextRunContextInfo;
22917:   PRUint8                       mCurrentRunContextInfo;
    1: };
    1: 
 1817: static nsIFrame*
 1817: FindLineContainer(nsIFrame* aFrame)
 1817: {
16292:   while (aFrame && aFrame->CanContinueTextRun()) {
 1817:     aFrame = aFrame->GetParent();
 1817:   }
 1817:   return aFrame;
 1817: }
 1817: 
 2319: static PRBool
32190: IsLineBreakingWhiteSpace(PRUnichar aChar)
32190: {
32190:   // 0x0A (\n) is not handled as white-space by the line breaker, since
32190:   // we break before it, if it isn't transformed to a normal space.
32190:   // (If we treat it as normal white-space then we'd only break after it.)
32190:   // However, it does induce a line break or is converted to a regular
32190:   // space, and either way it can be used to bound the region of text
32190:   // that needs to be analyzed for line breaking.
32190:   return nsLineBreaker::IsSpace(aChar) || aChar == 0x0A;
32190: }
32190: 
32190: static PRBool
 2319: TextContainsLineBreakerWhiteSpace(const void* aText, PRUint32 aLength,
 2319:                                   PRBool aIsDoubleByte)
 2319: {
 2319:   PRUint32 i;
 2319:   if (aIsDoubleByte) {
 3233:     const PRUnichar* chars = static_cast<const PRUnichar*>(aText);
 2319:     for (i = 0; i < aLength; ++i) {
32190:       if (IsLineBreakingWhiteSpace(chars[i]))
 2319:         return PR_TRUE;
 2319:     }
 2319:     return PR_FALSE;
 2319:   } else {
 3233:     const PRUint8* chars = static_cast<const PRUint8*>(aText);
 2319:     for (i = 0; i < aLength; ++i) {
32190:       if (IsLineBreakingWhiteSpace(chars[i]))
 2319:         return PR_TRUE;
 2319:     }
 2319:     return PR_FALSE;
 2319:   }
 2319: }
 2319: 
16292: struct FrameTextTraversal {
21988:   // These fields identify which frames should be recursively scanned
21988:   // The first normal frame to scan (or null, if no such frame should be scanned)
21988:   nsIFrame*    mFrameToScan;
21988:   // The first overflow frame to scan (or null, if no such frame should be scanned)
21988:   nsIFrame*    mOverflowFrameToScan;
21988:   // Whether to scan the siblings of mFrameToDescendInto/mOverflowFrameToDescendInto
21988:   PRPackedBool mScanSiblings;
21988: 
21988:   // These identify the boundaries of the context required for
21988:   // line breaking or textrun construction
16292:   PRPackedBool mLineBreakerCanCrossFrameBoundary;
16292:   PRPackedBool mTextRunCanCrossFrameBoundary;
21988: 
21988:   nsIFrame* NextFrameToScan() {
21988:     nsIFrame* f;
21988:     if (mFrameToScan) {
21988:       f = mFrameToScan;
21988:       mFrameToScan = mScanSiblings ? f->GetNextSibling() : nsnull;
21988:     } else if (mOverflowFrameToScan) {
21988:       f = mOverflowFrameToScan;
21988:       mOverflowFrameToScan = mScanSiblings ? f->GetNextSibling() : nsnull;
21988:     } else {
21988:       f = nsnull;
21988:     }
21988:     return f;
21988:   }
16292: };
16292: 
16292: static FrameTextTraversal
16292: CanTextCrossFrameBoundary(nsIFrame* aFrame, nsIAtom* aType)
16292: {
16292:   NS_ASSERTION(aType == aFrame->GetType(), "Wrong type");
16292: 
16292:   FrameTextTraversal result;
16292: 
16292:   PRBool continuesTextRun = aFrame->CanContinueTextRun();
16292:   if (aType == nsGkAtoms::placeholderFrame) {
 2742:     // placeholders are "invisible", so a text run should be able to span
16292:     // across one. But don't descend into the out-of-flow.
16292:     result.mLineBreakerCanCrossFrameBoundary = PR_TRUE;
21988:     result.mOverflowFrameToScan = nsnull;
16292:     if (continuesTextRun) {
16292:       // ... Except for first-letter floats, which are really in-flow
16292:       // from the point of view of capitalization etc, so we'd better
16292:       // descend into them. But we actually need to break the textrun for
16292:       // first-letter floats since things look bad if, say, we try to make a
16292:       // ligature across the float boundary.
21988:       result.mFrameToScan =
16292:         (static_cast<nsPlaceholderFrame*>(aFrame))->GetOutOfFlowFrame();
21988:       result.mScanSiblings = PR_FALSE;
16292:       result.mTextRunCanCrossFrameBoundary = PR_FALSE;
16292:     } else {
21988:       result.mFrameToScan = nsnull;
16292:       result.mTextRunCanCrossFrameBoundary = PR_TRUE;
16292:     }
16292:   } else {
16292:     if (continuesTextRun) {
21988:       result.mFrameToScan = aFrame->GetFirstChild(nsnull);
21988:       result.mOverflowFrameToScan = aFrame->GetFirstChild(nsGkAtoms::overflowList);
21988:       NS_WARN_IF_FALSE(!result.mOverflowFrameToScan,
21988:                        "Scanning overflow inline frames is something we should avoid");
21988:       result.mScanSiblings = PR_TRUE;
16292:       result.mTextRunCanCrossFrameBoundary = PR_TRUE;
16292:       result.mLineBreakerCanCrossFrameBoundary = PR_TRUE;
16292:     } else {
21988:       result.mFrameToScan = nsnull;
21988:       result.mOverflowFrameToScan = nsnull;
16292:       result.mTextRunCanCrossFrameBoundary = PR_FALSE;
16292:       result.mLineBreakerCanCrossFrameBoundary = PR_FALSE;
16292:     }
16292:   }    
16292:   return result;
 2742: }
 2742: 
 2319: BuildTextRunsScanner::FindBoundaryResult
 2319: BuildTextRunsScanner::FindBoundaries(nsIFrame* aFrame, FindBoundaryState* aState)
 2319: {
16292:   nsIAtom* frameType = aFrame->GetType();
16292:   nsTextFrame* textFrame = frameType == nsGkAtoms::textFrame
 3233:     ? static_cast<nsTextFrame*>(aFrame) : nsnull;
 2319:   if (textFrame) {
 2319:     if (aState->mLastTextFrame &&
 2319:         textFrame != aState->mLastTextFrame->GetNextInFlow() &&
 3009:         !ContinueTextRunAcrossFrames(aState->mLastTextFrame, textFrame)) {
 2319:       aState->mSeenTextRunBoundaryOnThisLine = PR_TRUE;
 2319:       if (aState->mSeenSpaceForLineBreakingOnThisLine)
 2319:         return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
 2319:     }
 2319:     if (!aState->mFirstTextFrame) {
 2319:       aState->mFirstTextFrame = textFrame;
 2319:     }
 2319:     aState->mLastTextFrame = textFrame;
 2319:   }
 2319:   
 2319:   if (aFrame == aState->mStopAtFrame)
 2319:     return FB_STOPPED_AT_STOP_FRAME;
 2319: 
 2319:   if (textFrame) {
 2319:     if (!aState->mSeenSpaceForLineBreakingOnThisLine) {
35581:       const nsTextFragment* frag = textFrame->GetContent()->GetText();
 2319:       PRUint32 start = textFrame->GetContentOffset();
 2319:       const void* text = frag->Is2b()
 3233:           ? static_cast<const void*>(frag->Get2b() + start)
 3233:           : static_cast<const void*>(frag->Get1b() + start);
 2319:       if (TextContainsLineBreakerWhiteSpace(text, textFrame->GetContentLength(),
 2319:                                             frag->Is2b())) {
 2319:         aState->mSeenSpaceForLineBreakingOnThisLine = PR_TRUE;
 2319:         if (aState->mSeenTextRunBoundaryOnLaterLine)
 2319:           return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
 2319:       }
 2319:     }
 2319:     return FB_CONTINUE; 
 2319:   }
 2319: 
16292:   FrameTextTraversal traversal =
16292:     CanTextCrossFrameBoundary(aFrame, frameType);
16292:   if (!traversal.mTextRunCanCrossFrameBoundary) {
 2319:     aState->mSeenTextRunBoundaryOnThisLine = PR_TRUE;
 2319:     if (aState->mSeenSpaceForLineBreakingOnThisLine)
 2319:       return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
 2319:   }
 2319:   
21988:   for (nsIFrame* f = traversal.NextFrameToScan(); f;
21988:        f = traversal.NextFrameToScan()) {
16292:     FindBoundaryResult result = FindBoundaries(f, aState);
 2319:     if (result != FB_CONTINUE)
 2319:       return result;
16292:   }
16292: 
16292:   if (!traversal.mTextRunCanCrossFrameBoundary) {
 2319:     aState->mSeenTextRunBoundaryOnThisLine = PR_TRUE;
 2319:     if (aState->mSeenSpaceForLineBreakingOnThisLine)
 2319:       return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
 2319:   }
 2319: 
 2319:   return FB_CONTINUE;
 2319: }
 2319: 
 7722: // build text runs for the 200 lines following aForFrame, and stop after that
 7722: // when we get a chance.
 7722: #define NUM_LINES_TO_BUILD_TEXT_RUNS 200
 7722: 
    1: /**
    1:  * General routine for building text runs. This is hairy because of the need
 2319:  * to build text runs that span content nodes.
    1:  * 
    1:  * @param aForFrameLine the line containing aForFrame; if null, we'll figure
    1:  * out the line (slowly)
24819:  * @param aLineContainer the line container containing aForFrame; if null,
24819:  * we'll walk the ancestors to find it.  It's required to be non-null when
24819:  * aForFrameLine is non-null.
    1:  */
    1: static void
 6862: BuildTextRuns(gfxContext* aContext, nsTextFrame* aForFrame,
24819:               nsIFrame* aLineContainer,
24819:               const nsLineList::iterator* aForFrameLine)
24819: {
24819:   NS_ASSERTION(aForFrame || aLineContainer,
24819:                "One of aForFrame or aLineContainer must be set!");
24819:   NS_ASSERTION(!aForFrameLine || aLineContainer,
24819:                "line but no line container");
24819:   
24819:   if (!aLineContainer) {
 1817:     aLineContainer = FindLineContainer(aForFrame);
 1817:   } else {
24819:     NS_ASSERTION(!aForFrame ||
24819:                  (aLineContainer == FindLineContainer(aForFrame) ||
24819:                   (aLineContainer->GetType() == nsGkAtoms::letterFrame &&
24819:                    aLineContainer->GetStyleDisplay()->IsFloating())),
24819:                  "Wrong line container hint");
 2319:   }
 2319: 
 2319:   nsPresContext* presContext = aLineContainer->PresContext();
 6862:   BuildTextRunsScanner scanner(presContext, aContext, aLineContainer);
 1817: 
15909:   nsBlockFrame* block = nsLayoutUtils::GetAsBlock(aLineContainer);
 1817: 
 1817:   if (!block) {
 5145:     NS_ASSERTION(!aLineContainer->GetPrevInFlow() && !aLineContainer->GetNextInFlow(),
 5145:                  "Breakable non-block line containers not supported");
 1817:     // Just loop through all the children of the linecontainer ... it's really
 1817:     // just one line
 2319:     scanner.SetAtStartOfLine();
 2319:     scanner.SetCommonAncestorWithLastFrame(nsnull);
 1817:     nsIFrame* child = aLineContainer->GetFirstChild(nsnull);
 1817:     while (child) {
 1817:       scanner.ScanFrame(child);
 1817:       child = child->GetNextSibling();
 1817:     }
 1817:     // Set mStartOfLine so FlushFrames knows its textrun ends a line
 1817:     scanner.SetAtStartOfLine();
 8857:     scanner.FlushFrames(PR_TRUE, PR_FALSE);
 1817:     return;
 1817:   }
    1: 
 2319:   // Find the line containing aForFrame
12355: 
12355:   PRBool isValid = PR_TRUE;
12355:   nsBlockInFlowLineIterator backIterator(block, &isValid);
    1:   if (aForFrameLine) {
12355:     backIterator = nsBlockInFlowLineIterator(block, *aForFrameLine, PR_FALSE);
    1:   } else {
12355:     backIterator = nsBlockInFlowLineIterator(block, aForFrame, &isValid);
12355:     NS_ASSERTION(isValid, "aForFrame not found in block, someone lied to us");
12355:     NS_ASSERTION(backIterator.GetContainer() == block,
12355:                  "Someone lied to us about the block");
12355:   }
12355:   nsBlockFrame::line_iterator startLine = backIterator.GetLine();
 2319: 
 2319:   // Find a line where we can start building text runs. We choose the last line
 2319:   // where:
 2319:   // -- there is a textrun boundary between the start of the line and the
 2319:   // start of aForFrame
 2319:   // -- there is a space between the start of the line and the textrun boundary
 2319:   // (this is so we can be sure the line breaks will be set properly
 2319:   // on the textruns we construct).
 2319:   // The possibly-partial text runs up to and including the first space
 2319:   // are not reconstructed. We construct partial text runs for that text ---
 2319:   // for the sake of simplifying the code and feeding the linebreaker ---
 2319:   // but we discard them instead of assigning them to frames.
 2319:   // This is a little awkward because we traverse lines in the reverse direction
 2319:   // but we traverse the frames in each line in the forward direction.
12355:   nsBlockInFlowLineIterator forwardIterator = backIterator;
 2319:   nsTextFrame* stopAtFrame = aForFrame;
 2319:   nsTextFrame* nextLineFirstTextFrame = nsnull;
 2319:   PRBool seenTextRunBoundaryOnLaterLine = PR_FALSE;
 2319:   PRBool mayBeginInTextRun = PR_TRUE;
 2319:   while (PR_TRUE) {
12355:     forwardIterator = backIterator;
12355:     nsBlockFrame::line_iterator line = backIterator.GetLine();
 5145:     if (!backIterator.Prev() || backIterator.GetLine()->IsBlock()) {
 2319:       mayBeginInTextRun = PR_FALSE;
    1:       break;
    1:     }
 2319: 
 2319:     BuildTextRunsScanner::FindBoundaryState state = { stopAtFrame, nsnull, nsnull,
41024:       PRPackedBool(seenTextRunBoundaryOnLaterLine), PR_FALSE, PR_FALSE };
 2319:     nsIFrame* child = line->mFirstChild;
 2319:     PRBool foundBoundary = PR_FALSE;
 2319:     PRInt32 i;
 2319:     for (i = line->GetChildCount() - 1; i >= 0; --i) {
 2319:       BuildTextRunsScanner::FindBoundaryResult result =
 2319:           scanner.FindBoundaries(child, &state);
 2319:       if (result == BuildTextRunsScanner::FB_FOUND_VALID_TEXTRUN_BOUNDARY) {
 2319:         foundBoundary = PR_TRUE;
 2319:         break;
 2319:       } else if (result == BuildTextRunsScanner::FB_STOPPED_AT_STOP_FRAME) {
 2319:         break;
 2319:       }
 2319:       child = child->GetNextSibling();
 2319:     }
 2319:     if (foundBoundary)
 2319:       break;
 2319:     if (!stopAtFrame && state.mLastTextFrame && nextLineFirstTextFrame &&
 3009:         !scanner.ContinueTextRunAcrossFrames(state.mLastTextFrame, nextLineFirstTextFrame)) {
 3009:       // Found a usable textrun boundary at the end of the line
 2319:       if (state.mSeenSpaceForLineBreakingOnThisLine)
 2319:         break;
 2319:       seenTextRunBoundaryOnLaterLine = PR_TRUE;
 2319:     } else if (state.mSeenTextRunBoundaryOnThisLine) {
 2319:       seenTextRunBoundaryOnLaterLine = PR_TRUE;
 2319:     }
 2319:     stopAtFrame = nsnull;
 2319:     if (state.mFirstTextFrame) {
 2319:       nextLineFirstTextFrame = state.mFirstTextFrame;
 2319:     }
 2319:   }
 2319:   scanner.SetSkipIncompleteTextRuns(mayBeginInTextRun);
    1: 
    1:   // Now iterate over all text frames starting from the current line. First-in-flow
    1:   // text frames will be accumulated into textRunFrames as we go. When a
    1:   // text run boundary is required we flush textRunFrames ((re)building their
    1:   // gfxTextRuns as necessary).
 7722:   PRBool seenStartLine = PR_FALSE;
 7722:   PRUint32 linesAfterStartLine = 0;
    1:   do {
12355:     nsBlockFrame::line_iterator line = forwardIterator.GetLine();
 5145:     if (line->IsBlock())
 5145:       break;
 6029:     line->SetInvalidateTextRuns(PR_FALSE);
    1:     scanner.SetAtStartOfLine();
    1:     scanner.SetCommonAncestorWithLastFrame(nsnull);
 5145:     nsIFrame* child = line->mFirstChild;
    1:     PRInt32 i;
    1:     for (i = line->GetChildCount() - 1; i >= 0; --i) {
    1:       scanner.ScanFrame(child);
    1:       child = child->GetNextSibling();
    1:     }
13056:     if (line.get() == startLine.get()) {
 7722:       seenStartLine = PR_TRUE;
 7722:     }
 7722:     if (seenStartLine) {
 7722:       ++linesAfterStartLine;
 7722:       if (linesAfterStartLine >= NUM_LINES_TO_BUILD_TEXT_RUNS && scanner.CanStopOnThisLine()) {
23491:         // Don't flush frames; we may be in the middle of a textrun
23491:         // that we can't end here. That's OK, we just won't build it.
 7722:         // Note that we must already have finished the textrun for aForFrame,
 7722:         // because we've seen the end of a textrun in a line after the line
 7722:         // containing aForFrame.
23491:         scanner.FlushLineBreaks(nsnull);
23491:         // This flushes out mMappedFlows and mLineBreakBeforeFrames, which
23491:         // silences assertions in the scanner destructor.
23491:         scanner.ResetRunInfo();
 7722:         return;
 7722:       }
 7722:     }
 5145:   } while (forwardIterator.Next());
    1: 
    1:   // Set mStartOfLine so FlushFrames knows its textrun ends a line
    1:   scanner.SetAtStartOfLine();
 8857:   scanner.FlushFrames(PR_TRUE, PR_FALSE);
    1: }
    1: 
    1: static PRUnichar*
    1: ExpandBuffer(PRUnichar* aDest, PRUint8* aSrc, PRUint32 aCount)
    1: {
    1:   while (aCount) {
    1:     *aDest = *aSrc;
    1:     ++aDest;
    1:     ++aSrc;
    1:     --aCount;
    1:   }
    1:   return aDest;
    1: }
    1: 
 6033: PRBool BuildTextRunsScanner::IsTextRunValidForMappedFlows(gfxTextRun* aTextRun)
 6033: {
 6033:   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW)
 6033:     return mMappedFlows.Length() == 1 &&
 6033:       mMappedFlows[0].mStartFrame == static_cast<nsTextFrame*>(aTextRun->GetUserData()) &&
 6033:       mMappedFlows[0].mEndFrame == nsnull;
 6033: 
 6033:   TextRunUserData* userData = static_cast<TextRunUserData*>(aTextRun->GetUserData());
 6033:   if (userData->mMappedFlowCount != PRInt32(mMappedFlows.Length()))
 6033:     return PR_FALSE;
 6033:   PRUint32 i;
 6033:   for (i = 0; i < mMappedFlows.Length(); ++i) {
 6033:     if (userData->mMappedFlows[i].mStartFrame != mMappedFlows[i].mStartFrame ||
 6033:         PRInt32(userData->mMappedFlows[i].mContentLength) !=
 6033:             mMappedFlows[i].GetContentEnd() - mMappedFlows[i].mStartFrame->GetContentOffset())
 6033:       return PR_FALSE;
 6033:   }
 6033:   return PR_TRUE;
 6033: }
 6033: 
    1: /**
    1:  * This gets called when we need to make a text run for the current list of
    1:  * frames.
    1:  */
 8857: void BuildTextRunsScanner::FlushFrames(PRBool aFlushLineBreaks, PRBool aSuppressTrailingBreak)
    1: {
23491:   gfxTextRun* textRun = nsnull;
23491:   if (!mMappedFlows.IsEmpty()) {
 2319:     if (!mSkipIncompleteTextRuns && mCurrentFramesAllSameTextRun &&
    1:         ((mCurrentFramesAllSameTextRun->GetFlags() & nsTextFrameUtils::TEXT_INCOMING_WHITESPACE) != 0) ==
22917:         ((mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_WHITESPACE) != 0) &&
23214:         ((mCurrentFramesAllSameTextRun->GetFlags() & gfxTextRunWordCache::TEXT_INCOMING_ARABICCHAR) != 0) ==
22917:         ((mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_ARABICCHAR) != 0) &&
 6033:         IsTextRunValidForMappedFlows(mCurrentFramesAllSameTextRun)) {
 2319:       // Optimization: We do not need to (re)build the textrun.
 8573:       textRun = mCurrentFramesAllSameTextRun;
    1: 
    1:       // Feed this run's text into the linebreaker to provide context. This also
22917:       // updates mNextRunContextInfo appropriately.
 8573:       SetupBreakSinksForTextRun(textRun, PR_TRUE, PR_FALSE);
22917:       mNextRunContextInfo = nsTextFrameUtils::INCOMING_NONE;
22917:       if (textRun->GetFlags() & nsTextFrameUtils::TEXT_TRAILING_WHITESPACE) {
22917:         mNextRunContextInfo |= nsTextFrameUtils::INCOMING_WHITESPACE;
22917:       }
23214:       if (textRun->GetFlags() & gfxTextRunWordCache::TEXT_TRAILING_ARABICCHAR) {
22917:         mNextRunContextInfo |= nsTextFrameUtils::INCOMING_ARABICCHAR;
22917:       }
    1:     } else {
    1:       nsAutoTArray<PRUint8,BIG_TEXT_NODE_SIZE> buffer;
    1:       if (!buffer.AppendElements(mMaxTextLength*(mDoubleByteText ? 2 : 1)))
    1:         return;
 8573:       textRun = BuildTextRunForFrames(buffer.Elements());
    1:     }
23491:   }
    1: 
    1:   if (aFlushLineBreaks) {
23491:     FlushLineBreaks(aSuppressTrailingBreak ? nsnull : textRun);
23491:   }
23491: 
23491:   mCanStopOnThisLine = PR_TRUE;
23491:   ResetRunInfo();
23491: }
23491: 
23491: void BuildTextRunsScanner::FlushLineBreaks(gfxTextRun* aTrailingTextRun)
23491: {
 8573:   PRBool trailingLineBreak;
 8573:   nsresult rv = mLineBreaker.Reset(&trailingLineBreak);
 8573:   // textRun may be null for various reasons, including because we constructed
 8573:   // a partial textrun just to get the linebreaker and other state set up
 8573:   // to build the next textrun.
23491:   if (NS_SUCCEEDED(rv) && trailingLineBreak && aTrailingTextRun) {
23491:     aTrailingTextRun->SetFlagBits(nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK);
23491:   }
23491: 
    1:   PRUint32 i;
    1:   for (i = 0; i < mBreakSinks.Length(); ++i) {
   60:     if (!mBreakSinks[i]->mExistingTextRun || mBreakSinks[i]->mChangedBreaks) {
    1:       // TODO cause frames associated with the textrun to be reflowed, if they
    1:       // aren't being reflowed already!
    1:     }
23491:     mBreakSinks[i]->Finish();
    1:   }
    1:   mBreakSinks.Clear();
23491: 
23491:   for (i = 0; i < mTextRunsToDelete.Length(); ++i) {
23491:     gfxTextRun* deleteTextRun = mTextRunsToDelete[i];
23491:     gTextRuns->RemoveFromCache(deleteTextRun);
23491:     delete deleteTextRun;
23491:   }
23491:   mTextRunsToDelete.Clear();
    1: }
    1: 
    1: void BuildTextRunsScanner::AccumulateRunInfo(nsTextFrame* aFrame)
    1: {
 9810:   NS_ASSERTION(mMaxTextLength <= mMaxTextLength + aFrame->GetContentLength(), "integer overflow");
    1:   mMaxTextLength += aFrame->GetContentLength();
35581:   mDoubleByteText |= aFrame->GetContent()->GetText()->Is2b();
    1:   mLastFrame = aFrame;
 8573:   mCommonAncestorWithLastFrame = aFrame->GetParent();
    1: 
 6033:   MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];
 6033:   NS_ASSERTION(mappedFlow->mStartFrame == aFrame ||
 6033:                mappedFlow->GetContentEnd() == aFrame->GetContentOffset(),
 6033:                "Overlapping or discontiguous frames => BAD");
 6033:   mappedFlow->mEndFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
 6033:   if (mCurrentFramesAllSameTextRun != aFrame->GetTextRun()) {
 6033:     mCurrentFramesAllSameTextRun = nsnull;
 6033:   }
 6033: 
    1:   if (mStartOfLine) {
    1:     mLineBreakBeforeFrames.AppendElement(aFrame);
    1:     mStartOfLine = PR_FALSE;
    1:   }
    1: }
    1: 
 2027: static nscoord StyleToCoord(const nsStyleCoord& aCoord)
 2027: {
 2027:   if (eStyleUnit_Coord == aCoord.GetUnit()) {
 2027:     return aCoord.GetCoordValue();
 2027:   } else {
 2027:     return 0;
 2027:   }
 2027: }
 2027: 
 2027: static PRBool
 3009: HasTerminalNewline(const nsTextFrame* aFrame)
 3009: {
 3009:   if (aFrame->GetContentLength() == 0)
 3009:     return PR_FALSE;
35581:   const nsTextFragment* frag = aFrame->GetContent()->GetText();
 3009:   return frag->CharAt(aFrame->GetContentEnd() - 1) == '\n';
 3009: }
 3009: 
    1: PRBool
 3009: BuildTextRunsScanner::ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2)
    1: {
    1:   if (mBidiEnabled &&
    1:       NS_GET_EMBEDDING_LEVEL(aFrame1) != NS_GET_EMBEDDING_LEVEL(aFrame2))
    1:     return PR_FALSE;
    1: 
    1:   nsStyleContext* sc1 = aFrame1->GetStyleContext();
 3009:   const nsStyleText* textStyle1 = sc1->GetStyleText();
 3009:   // If the first frame ends in a preformatted newline, then we end the textrun
 3009:   // here. This avoids creating giant textruns for an entire plain text file.
 3009:   // Note that we create a single text frame for a preformatted text node,
 3009:   // even if it has newlines in it, so typically we won't see trailing newlines
 3009:   // until after reflow has broken up the frame into one (or more) frames per
 3009:   // line. That's OK though.
16575:   if (textStyle1->NewlineIsSignificant() && HasTerminalNewline(aFrame1))
 3009:     return PR_FALSE;
 3009: 
42257:   if (aFrame1->GetContent() == aFrame2->GetContent() &&
42257:       aFrame1->GetNextInFlow() != aFrame2) {
42257:     // aFrame2 must be a non-fluid continuation of aFrame1. This can happen
42257:     // sometimes when the unicode-bidi property is used; the bidi resolver
42257:     // breaks text into different frames even though the text has the same
42257:     // direction. We can't allow these two frames to share the same textrun
42257:     // because that would violate our invariant that two flows in the same
42257:     // textrun have different content elements.
42257:     return PR_FALSE;
42257:   }
 7012: 
    1:   nsStyleContext* sc2 = aFrame2->GetStyleContext();
    1:   if (sc1 == sc2)
    1:     return PR_TRUE;
 4032:   const nsStyleFont* fontStyle1 = sc1->GetStyleFont();
 4032:   const nsStyleFont* fontStyle2 = sc2->GetStyleFont();
 4032:   const nsStyleText* textStyle2 = sc2->GetStyleText();
 4032:   return fontStyle1->mFont.BaseEquals(fontStyle2->mFont) &&
38492:     sc1->GetStyleVisibility()->mLanguage == sc2->GetStyleVisibility()->mLanguage &&
 4032:     nsLayoutUtils::GetTextRunFlagsForStyle(sc1, textStyle1, fontStyle1) ==
 4032:       nsLayoutUtils::GetTextRunFlagsForStyle(sc2, textStyle2, fontStyle2);
    1: }
    1: 
    1: void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)
    1: {
    1:   // First check if we can extend the current mapped frame block. This is common.
    1:   if (mMappedFlows.Length() > 0) {
    1:     MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];
 6033:     if (mappedFlow->mEndFrame == aFrame &&
 6033:         (aFrame->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION)) {
    1:       NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame,
    1:                    "Flow-sibling of a text frame is not a text frame?");
    1: 
 3009:       // Don't do this optimization if mLastFrame has a terminal newline...
 3009:       // it's quite likely preformatted and we might want to end the textrun here.
 3009:       // This is almost always true:
 3009:       if (mLastFrame->GetStyleContext() == aFrame->GetStyleContext() &&
 3009:           !HasTerminalNewline(mLastFrame)) {
 6033:         AccumulateRunInfo(static_cast<nsTextFrame*>(aFrame));
    1:         return;
    1:       }
    1:     }
    1:   }
    1: 
 8857:   nsIAtom* frameType = aFrame->GetType();
    1:   // Now see if we can add a new set of frames to the current textrun
 8857:   if (frameType == nsGkAtoms::textFrame) {
 3233:     nsTextFrame* frame = static_cast<nsTextFrame*>(aFrame);
    1: 
 6033:     if (mLastFrame) {
 6033:       if (!ContinueTextRunAcrossFrames(mLastFrame, frame)) {
 8857:         FlushFrames(PR_FALSE, PR_FALSE);
 6033:       } else {
 6033:         if (mLastFrame->GetContent() == frame->GetContent()) {
 6033:           AccumulateRunInfo(frame);
 6033:           return;
 6033:         }
 6033:       }
    1:     }
    1: 
    1:     MappedFlow* mappedFlow = mMappedFlows.AppendElement();
    1:     if (!mappedFlow)
    1:       return;
    1: 
    1:     mappedFlow->mStartFrame = frame;
    1:     mappedFlow->mAncestorControllingInitialBreak = mCommonAncestorWithLastFrame;
    1: 
    1:     AccumulateRunInfo(frame);
    1:     if (mMappedFlows.Length() == 1) {
    1:       mCurrentFramesAllSameTextRun = frame->GetTextRun();
22917:       mCurrentRunContextInfo = mNextRunContextInfo;
    1:     }
    1:     return;
    1:   }
    1: 
16292:   FrameTextTraversal traversal =
16292:     CanTextCrossFrameBoundary(aFrame, frameType);
 8857:   PRBool isBR = frameType == nsGkAtoms::brFrame;
16292:   if (!traversal.mLineBreakerCanCrossFrameBoundary) {
 8857:     // BR frames are special. We do not need or want to record a break opportunity
 8857:     // before a BR frame.
 8857:     FlushFrames(PR_TRUE, isBR);
 8573:     mCommonAncestorWithLastFrame = aFrame;
22917:     mNextRunContextInfo &= ~nsTextFrameUtils::INCOMING_WHITESPACE;
    1:     mStartOfLine = PR_FALSE;
16292:   } else if (!traversal.mTextRunCanCrossFrameBoundary) {
16292:     FlushFrames(PR_FALSE, PR_FALSE);
16292:   }
16292: 
21988:   for (nsIFrame* f = traversal.NextFrameToScan(); f;
21988:        f = traversal.NextFrameToScan()) {
    1:     ScanFrame(f);
16292:   }
16292: 
16292:   if (!traversal.mLineBreakerCanCrossFrameBoundary) {
 8857:     // Really if we're a BR frame this is unnecessary since descendInto will be
 8857:     // false. In fact this whole "if" statement should move into the descendInto.
 8857:     FlushFrames(PR_TRUE, isBR);
 8573:     mCommonAncestorWithLastFrame = aFrame;
22917:     mNextRunContextInfo &= ~nsTextFrameUtils::INCOMING_WHITESPACE;
16292:   } else if (!traversal.mTextRunCanCrossFrameBoundary) {
16292:     FlushFrames(PR_FALSE, PR_FALSE);
    1:   }
 2319: 
 2319:   LiftCommonAncestorWithLastFrameToParent(aFrame->GetParent());
    1: }
    1: 
    1: nsTextFrame*
    1: BuildTextRunsScanner::GetNextBreakBeforeFrame(PRUint32* aIndex)
    1: {
    1:   PRUint32 index = *aIndex;
    1:   if (index >= mLineBreakBeforeFrames.Length())
    1:     return nsnull;
    1:   *aIndex = index + 1;
 3233:   return static_cast<nsTextFrame*>(mLineBreakBeforeFrames.ElementAt(index));
    1: }
    1: 
    1: static PRUint32
23137: GetSpacingFlags(nscoord spacing)
23137: {
30879:   return spacing ? gfxTextRunFactory::TEXT_ENABLE_SPACING : 0;
    1: }
    1: 
    1: static gfxFontGroup*
13714: GetFontGroupForFrame(nsIFrame* aFrame,
13714:                      nsIFontMetrics** aOutFontMetrics = nsnull)
13714: {
13714:   if (aOutFontMetrics)
13714:     *aOutFontMetrics = nsnull;
13714: 
    1:   nsCOMPtr<nsIFontMetrics> metrics;
 4353:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(metrics));
 4353: 
    1:   if (!metrics)
    1:     return nsnull;
    1: 
    1:   nsIFontMetrics* metricsRaw = metrics;
13714:   if (aOutFontMetrics) {
13714:     *aOutFontMetrics = metricsRaw;
13714:     NS_ADDREF(*aOutFontMetrics);
13714:   }
 3233:   nsIThebesFontMetrics* fm = static_cast<nsIThebesFontMetrics*>(metricsRaw);
 6247:   // XXX this is a bit bogus, we're releasing 'metrics' so the returned font-group
 6247:   // might actually be torn down, although because of the way the device context
 6247:   // caches font metrics, this seems to not actually happen. But we should fix
 6247:   // this.
    1:   return fm->GetThebesFontGroup();
    1: }
    1: 
 6862: static already_AddRefed<gfxContext>
 6862: GetReferenceRenderingContext(nsTextFrame* aTextFrame, nsIRenderingContext* aRC)
 6862: {
 6862:   nsCOMPtr<nsIRenderingContext> tmp = aRC;
 6862:   if (!tmp) {
51038:     tmp = aTextFrame->PresContext()->PresShell()->GetReferenceRenderingContext();
51038:     if (!tmp)
 6862:       return nsnull;
 6862:   }
 6862: 
 9438:   gfxContext* ctx = tmp->ThebesContext();
 6862:   NS_ADDREF(ctx);
 6862:   return ctx;
 6862: }
 6862: 
 5724: /**
 5724:  * The returned textrun must be released via gfxTextRunCache::ReleaseTextRun
 5724:  * or gfxTextRunCache::AutoTextRun.
 5724:  */
    1: static gfxTextRun*
 6862: GetHyphenTextRun(gfxTextRun* aTextRun, gfxContext* aContext, nsTextFrame* aTextFrame)
 6862: {
 6862:   nsRefPtr<gfxContext> ctx = aContext;
 6862:   if (!ctx) {
 6862:     ctx = GetReferenceRenderingContext(aTextFrame, nsnull);
 6862:   }
 6862:   if (!ctx)
 1563:     return nsnull;
 6862: 
 1328:   gfxFontGroup* fontGroup = aTextRun->GetFontGroup();
 1328:   PRUint32 flags = gfxFontGroup::TEXT_IS_PERSISTENT;
 1328: 
24664:   // only use U+2010 if it is supported by the first font in the group;
24664:   // it's better to use ASCII '-' from the primary font than to fall back to U+2010
24664:   // from some other, possibly poorly-matching face
 1328:   static const PRUnichar unicodeHyphen = 0x2010;
24664:   gfxFont *font = fontGroup->GetFontAt(0);
24664:   if (font && font->HasCharacter(unicodeHyphen)) {
24664:     return gfxTextRunCache::MakeTextRun(&unicodeHyphen, 1, fontGroup, ctx,
 1328:                                         aTextRun->GetAppUnitsPerDevUnit(), flags);
24664:   }
 7729: 
 1328:   static const PRUint8 dash = '-';
 3118:   return gfxTextRunCache::MakeTextRun(&dash, 1, fontGroup, ctx,
 1328:                                       aTextRun->GetAppUnitsPerDevUnit(),
 1328:                                       flags);
    1: }
    1: 
    1: static gfxFont::Metrics
13714: GetFirstFontMetrics(gfxFontGroup* aFontGroup)
    1: {
    1:   if (!aFontGroup)
    1:     return gfxFont::Metrics();
    1:   gfxFont* font = aFontGroup->GetFontAt(0);
    1:   if (!font)
    1:     return gfxFont::Metrics();
    1:   return font->GetMetrics();
    1: }
    1: 
16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_NORMAL == 0);
16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_PRE == 1);
16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_NOWRAP == 2);
16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_PRE_WRAP == 3);
16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_PRE_LINE == 4);
16575: 
16575: static const nsTextFrameUtils::CompressionMode CSSWhitespaceToCompressionMode[] =
16575: {
16575:   nsTextFrameUtils::COMPRESS_WHITESPACE_NEWLINE, // normal
16575:   nsTextFrameUtils::COMPRESS_NONE,               // pre
16575:   nsTextFrameUtils::COMPRESS_WHITESPACE_NEWLINE, // nowrap
16575:   nsTextFrameUtils::COMPRESS_NONE,               // pre-wrap
16575:   nsTextFrameUtils::COMPRESS_WHITESPACE          // pre-line
16575: };
16575: 
 8573: gfxTextRun*
    1: BuildTextRunsScanner::BuildTextRunForFrames(void* aTextBuffer)
    1: {
    1:   gfxSkipCharsBuilder builder;
    1: 
    1:   const void* textPtr = aTextBuffer;
    1:   PRBool anySmallcapsStyle = PR_FALSE;
    1:   PRBool anyTextTransformStyle = PR_FALSE;
    1:   PRInt32 endOfLastContent = 0;
 6513:   PRUint32 textFlags = nsTextFrameUtils::TEXT_NO_BREAKS;
    8: 
22917:   if (mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_WHITESPACE) {
    8:     textFlags |= nsTextFrameUtils::TEXT_INCOMING_WHITESPACE;
    8:   }
22917:   if (mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_ARABICCHAR) {
23214:     textFlags |= gfxTextRunWordCache::TEXT_INCOMING_ARABICCHAR;
22917:   }
    1: 
 5800:   nsAutoTArray<PRInt32,50> textBreakPoints;
    1:   TextRunUserData dummyData;
    1:   TextRunMappedFlow dummyMappedFlow;
    1: 
    1:   TextRunUserData* userData;
23491:   TextRunUserData* userDataToDestroy;
    1:   // If the situation is particularly simple (and common) we don't need to
    1:   // allocate userData.
    1:   if (mMappedFlows.Length() == 1 && !mMappedFlows[0].mEndFrame &&
 6033:       mMappedFlows[0].mStartFrame->GetContentOffset() == 0) {
    1:     userData = &dummyData;
23491:     userDataToDestroy = nsnull;
    1:     dummyData.mMappedFlows = &dummyMappedFlow;
    1:   } else {
 3233:     userData = static_cast<TextRunUserData*>
 3233:       (nsMemory::Alloc(sizeof(TextRunUserData) + mMappedFlows.Length()*sizeof(TextRunMappedFlow)));
23491:     userDataToDestroy = userData;
 3233:     userData->mMappedFlows = reinterpret_cast<TextRunMappedFlow*>(userData + 1);
    1:   }
 6033:   userData->mMappedFlowCount = mMappedFlows.Length();
    1:   userData->mLastFlowIndex = 0;
    1: 
    1:   PRUint32 currentTransformedTextOffset = 0;
    1: 
    1:   PRUint32 nextBreakIndex = 0;
    1:   nsTextFrame* nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
16575:   PRBool enabledJustification = mLineContainer &&
16575:     mLineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY;
    1: 
    1:   PRUint32 i;
 4032:   const nsStyleText* textStyle = nsnull;
 4032:   const nsStyleFont* fontStyle = nsnull;
 4032:   nsStyleContext* lastStyleContext = nsnull;
    1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
    1:     MappedFlow* mappedFlow = &mMappedFlows[i];
    1:     nsTextFrame* f = mappedFlow->mStartFrame;
    1: 
 4032:     lastStyleContext = f->GetStyleContext();
    1:     // Detect use of text-transform or font-variant anywhere in the run
 4032:     textStyle = f->GetStyleText();
    1:     if (NS_STYLE_TEXT_TRANSFORM_NONE != textStyle->mTextTransform) {
    1:       anyTextTransformStyle = PR_TRUE;
    1:     }
23137:     textFlags |= GetSpacingFlags(StyleToCoord(textStyle->mLetterSpacing));
    1:     textFlags |= GetSpacingFlags(textStyle->mWordSpacing);
16575:     nsTextFrameUtils::CompressionMode compression =
16575:       CSSWhitespaceToCompressionMode[textStyle->mWhiteSpace];
16575:     if (enabledJustification && !textStyle->WhiteSpaceIsSignificant()) {
    1:       textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
    1:     }
 4032:     fontStyle = f->GetStyleFont();
    1:     if (NS_STYLE_FONT_VARIANT_SMALL_CAPS == fontStyle->mFont.variant) {
    1:       anySmallcapsStyle = PR_TRUE;
    1:     }
    1: 
    1:     // Figure out what content is included in this flow.
    1:     nsIContent* content = f->GetContent();
35581:     const nsTextFragment* frag = content->GetText();
 6033:     PRInt32 contentStart = mappedFlow->mStartFrame->GetContentOffset();
 6033:     PRInt32 contentEnd = mappedFlow->GetContentEnd();
    1:     PRInt32 contentLength = contentEnd - contentStart;
    1: 
 6033:     TextRunMappedFlow* newFlow = &userData->mMappedFlows[i];
    1:     newFlow->mStartFrame = mappedFlow->mStartFrame;
 6033:     newFlow->mDOMOffsetToBeforeTransformOffset = builder.GetCharCount() -
 6033:       mappedFlow->mStartFrame->GetContentOffset();
    1:     newFlow->mContentLength = contentLength;
    1: 
    1:     while (nextBreakBeforeFrame && nextBreakBeforeFrame->GetContent() == content) {
 5800:       textBreakPoints.AppendElement(
 5800:           nextBreakBeforeFrame->GetContentOffset() + newFlow->mDOMOffsetToBeforeTransformOffset);
    1:       nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
    1:     }
    1: 
    1:     PRUint32 analysisFlags;
    1:     if (frag->Is2b()) {
    1:       NS_ASSERTION(mDoubleByteText, "Wrong buffer char size!");
 3233:       PRUnichar* bufStart = static_cast<PRUnichar*>(aTextBuffer);
    1:       PRUnichar* bufEnd = nsTextFrameUtils::TransformText(
    1:           frag->Get2b() + contentStart, contentLength, bufStart,
22917:           compression, &mNextRunContextInfo, &builder, &analysisFlags);
    1:       aTextBuffer = bufEnd;
    1:     } else {
    1:       if (mDoubleByteText) {
    1:         // Need to expand the text. First transform it into a temporary buffer,
    1:         // then expand.
    1:         nsAutoTArray<PRUint8,BIG_TEXT_NODE_SIZE> tempBuf;
    1:         if (!tempBuf.AppendElements(contentLength)) {
23491:           DestroyUserData(userDataToDestroy);
 8573:           return nsnull;
    1:         }
    1:         PRUint8* bufStart = tempBuf.Elements();
    1:         PRUint8* end = nsTextFrameUtils::TransformText(
 3233:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
22917:             bufStart, compression, &mNextRunContextInfo, &builder, &analysisFlags);
 3233:         aTextBuffer = ExpandBuffer(static_cast<PRUnichar*>(aTextBuffer),
    1:                                    tempBuf.Elements(), end - tempBuf.Elements());
    1:       } else {
 3233:         PRUint8* bufStart = static_cast<PRUint8*>(aTextBuffer);
    1:         PRUint8* end = nsTextFrameUtils::TransformText(
 3233:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
22917:             bufStart, compression, &mNextRunContextInfo, &builder, &analysisFlags);
    1:         aTextBuffer = end;
    1:       }
    1:     }
    1:     textFlags |= analysisFlags;
    1: 
    1:     currentTransformedTextOffset =
 3233:       (static_cast<const PRUint8*>(aTextBuffer) - static_cast<const PRUint8*>(textPtr)) >> mDoubleByteText;
    1: 
    1:     endOfLastContent = contentEnd;
    1:   }
    1: 
    1:   // Check for out-of-memory in gfxSkipCharsBuilder
    1:   if (!builder.IsOK()) {
23491:     DestroyUserData(userDataToDestroy);
 8573:     return nsnull;
    1:   }
    1: 
    1:   void* finalUserData;
    1:   if (userData == &dummyData) {
    1:     textFlags |= nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW;
    1:     userData = nsnull;
    1:     finalUserData = mMappedFlows[0].mStartFrame;
    1:   } else {
    1:     finalUserData = userData;
    1:   }
    1: 
    1:   PRUint32 transformedLength = currentTransformedTextOffset;
    1: 
    1:   // Now build the textrun
    1:   nsTextFrame* firstFrame = mMappedFlows[0].mStartFrame;
    1:   gfxFontGroup* fontGroup = GetFontGroupForFrame(firstFrame);
    1:   if (!fontGroup) {
23491:     DestroyUserData(userDataToDestroy);
 8573:     return nsnull;
    1:   }
    1: 
    1:   if (textFlags & nsTextFrameUtils::TEXT_HAS_TAB) {
    1:     textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
    1:   }
    1:   if (textFlags & nsTextFrameUtils::TEXT_HAS_SHY) {
    1:     textFlags |= gfxTextRunFactory::TEXT_ENABLE_HYPHEN_BREAKS;
    1:   }
    1:   if (mBidiEnabled && (NS_GET_EMBEDDING_LEVEL(firstFrame) & 1)) {
    1:     textFlags |= gfxTextRunFactory::TEXT_IS_RTL;
    1:   }
22917:   if (mNextRunContextInfo & nsTextFrameUtils::INCOMING_WHITESPACE) {
 1328:     textFlags |= nsTextFrameUtils::TEXT_TRAILING_WHITESPACE;
 1328:   }
22917:   if (mNextRunContextInfo & nsTextFrameUtils::INCOMING_ARABICCHAR) {
23214:     textFlags |= gfxTextRunWordCache::TEXT_TRAILING_ARABICCHAR;
22917:   }
 4032:   // ContinueTextRunAcrossFrames guarantees that it doesn't matter which
 4032:   // frame's style is used, so use the last frame's
 4032:   textFlags |= nsLayoutUtils::GetTextRunFlagsForStyle(lastStyleContext,
 4032:       textStyle, fontStyle);
 6513:   // XXX this is a bit of a hack. For performance reasons, if we're favouring
 6513:   // performance over quality, don't try to get accurate glyph extents.
 6513:   if (!(textFlags & gfxTextRunFactory::TEXT_OPTIMIZE_SPEED)) {
 6513:     textFlags |= gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX;
 6513:   }
    1: 
    1:   gfxSkipChars skipChars;
    1:   skipChars.TakeFrom(&builder);
    1:   // Convert linebreak coordinates to transformed string offsets
    1:   NS_ASSERTION(nextBreakIndex == mLineBreakBeforeFrames.Length(),
    1:                "Didn't find all the frames to break-before...");
    1:   gfxSkipCharsIterator iter(skipChars);
 5800:   nsAutoTArray<PRUint32,50> textBreakPointsAfterTransform;
 5800:   for (i = 0; i < textBreakPoints.Length(); ++i) {
 8330:     nsTextFrameUtils::AppendLineBreakOffset(&textBreakPointsAfterTransform, 
 5800:             iter.ConvertOriginalToSkipped(textBreakPoints[i]));
    1:   }
    1:   if (mStartOfLine) {
 8330:     nsTextFrameUtils::AppendLineBreakOffset(&textBreakPointsAfterTransform,
 8330:                                             transformedLength);
    1:   }
    1: 
 7114:   // Setup factory chain
 7114:   nsAutoPtr<nsTransformingTextRunFactory> transformingFactory;
 7114:   if (anySmallcapsStyle) {
 7114:     transformingFactory = new nsFontVariantTextRunFactory();
 7114:   }
 7114:   if (anyTextTransformStyle) {
 7114:     transformingFactory =
 7114:       new nsCaseTransformTextRunFactory(transformingFactory.forget());
 7114:   }
 7114:   nsTArray<nsStyleContext*> styles;
 7114:   if (transformingFactory) {
 7114:     iter.SetOriginalOffset(0);
 7114:     for (i = 0; i < mMappedFlows.Length(); ++i) {
 7114:       MappedFlow* mappedFlow = &mMappedFlows[i];
 7673:       nsTextFrame* f;
 7673:       for (f = mappedFlow->mStartFrame; f != mappedFlow->mEndFrame;
 7695:            f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
 7114:         PRUint32 offset = iter.GetSkippedOffset();
 7673:         iter.AdvanceOriginal(f->GetContentLength());
 7114:         PRUint32 end = iter.GetSkippedOffset();
 7673:         nsStyleContext* sc = f->GetStyleContext();
 7114:         PRUint32 j;
 7114:         for (j = offset; j < end; ++j) {
 7114:           styles.AppendElement(sc);
 7114:         }
 7114:       }
 7114:     }
 7832:     textFlags |= nsTextFrameUtils::TEXT_IS_TRANSFORMED;
 7673:     NS_ASSERTION(iter.GetSkippedOffset() == transformedLength,
 7673:                  "We didn't cover all the characters in the text run!");
 7673:   }
 7114: 
 2319:   gfxTextRun* textRun;
    1:   gfxTextRunFactory::Parameters params =
 1328:       { mContext, finalUserData, &skipChars,
 5800:         textBreakPointsAfterTransform.Elements(), textBreakPointsAfterTransform.Length(),
 1328:         firstFrame->PresContext()->AppUnitsPerDevPixel() };
    1: 
    1:   if (mDoubleByteText) {
 3233:     const PRUnichar* text = static_cast<const PRUnichar*>(textPtr);
    8:     if (transformingFactory) {
    8:       textRun = transformingFactory->MakeTextRun(text, transformedLength, &params,
 1328:                                                  fontGroup, textFlags, styles.Elements());
    8:       if (textRun) {
 1435:         // ownership of the factory has passed to the textrun
    8:         transformingFactory.forget();
    8:       }
    8:     } else {
 1328:       textRun = MakeTextRun(text, transformedLength, fontGroup, &params, textFlags);
    8:     }
    1:   } else {
 3233:     const PRUint8* text = static_cast<const PRUint8*>(textPtr);
 1328:     textFlags |= gfxFontGroup::TEXT_IS_8BIT;
    8:     if (transformingFactory) {
    8:       textRun = transformingFactory->MakeTextRun(text, transformedLength, &params,
 1328:                                                  fontGroup, textFlags, styles.Elements());
    8:       if (textRun) {
 1435:         // ownership of the factory has passed to the textrun
    8:         transformingFactory.forget();
    8:       }
    8:     } else {
 1328:       textRun = MakeTextRun(text, transformedLength, fontGroup, &params, textFlags);
    8:     }
 2319:   }
    1:   if (!textRun) {
23491:     DestroyUserData(userDataToDestroy);
 8573:     return nsnull;
    1:   }
 2319: 
    1:   // We have to set these up after we've created the textrun, because
    1:   // the breaks may be stored in the textrun during this very call.
    1:   // This is a bit annoying because it requires another loop over the frames
    1:   // making up the textrun, but I don't see a way to avoid this.
 2319:   SetupBreakSinksForTextRun(textRun, PR_FALSE, mSkipIncompleteTextRuns);
 2319: 
 2319:   if (mSkipIncompleteTextRuns) {
 2319:     mSkipIncompleteTextRuns = !TextContainsLineBreakerWhiteSpace(textPtr,
 2319:         transformedLength, mDoubleByteText);
23491:     // Arrange for this textrun to be deleted the next time the linebreaker
23491:     // is flushed out
23491:     mTextRunsToDelete.AppendElement(textRun);
23491:     // Since we're doing to destroy the user data now, avoid a dangling
23491:     // pointer. Strictly speaking we don't need to do this since it should
23491:     // not be used (since this textrun will not be used and will be
23491:     // itself deleted soon), but it's always better to not have dangling
23491:     // pointers around.
23491:     textRun->SetUserData(nsnull);
23491:     DestroyUserData(userDataToDestroy);
 8573:     return nsnull;
 2319:   }
    1: 
    1:   // Actually wipe out the textruns associated with the mapped frames and associate
    1:   // those frames with this text run.
    1:   AssignTextRun(textRun);
 8573:   return textRun;
    1: }
    1: 
 2013: static PRBool
16575: HasCompressedLeadingWhitespace(nsTextFrame* aFrame, const nsStyleText* aStyleText,
16575:                                PRInt32 aContentEndOffset,
 3006:                                const gfxSkipCharsIterator& aIterator)
 3006: {
 3006:   if (!aIterator.IsOriginalCharSkipped())
 2013:     return PR_FALSE;
 2013: 
 3006:   gfxSkipCharsIterator iter = aIterator;
 2013:   PRInt32 frameContentOffset = aFrame->GetContentOffset();
35581:   const nsTextFragment* frag = aFrame->GetContent()->GetText();
 3006:   while (frameContentOffset < aContentEndOffset && iter.IsOriginalCharSkipped()) {
16575:     if (IsTrimmableSpace(frag, frameContentOffset, aStyleText))
 3006:       return PR_TRUE;
 2013:     ++frameContentOffset;
 3006:     iter.AdvanceOriginal(1);
 3006:   }
 3006:   return PR_FALSE;
 2013: }
 2013: 
    1: void
 1328: BuildTextRunsScanner::SetupBreakSinksForTextRun(gfxTextRun* aTextRun,
 2319:                                                 PRBool aIsExistingTextRun,
 2319:                                                 PRBool aSuppressSink)
    1: {
    1:   // textruns have uniform language
38492:   nsIAtom* language = mMappedFlows[0].mStartFrame->GetStyleVisibility()->mLanguage;
 2013:   // We keep this pointed at the skip-chars data for the current mappedFlow.
 2013:   // This lets us cheaply check whether the flow has compressed initial
 2013:   // whitespace...
 2013:   gfxSkipCharsIterator iter(aTextRun->GetSkipChars());
 2013: 
    1:   PRUint32 i;
    1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
    1:     MappedFlow* mappedFlow = &mMappedFlows[i];
 7114:     PRUint32 offset = iter.GetSkippedOffset();
 7114:     gfxSkipCharsIterator iterNext = iter;
 7114:     iterNext.AdvanceOriginal(mappedFlow->GetContentEnd() -
 7114:             mappedFlow->mStartFrame->GetContentOffset());
 7114: 
   60:     nsAutoPtr<BreakSink>* breakSink = mBreakSinks.AppendElement(
 7114:       new BreakSink(aTextRun, mContext, offset, aIsExistingTextRun));
   60:     if (!breakSink || !*breakSink)
    1:       return;
 7114: 
 7114:     PRUint32 length = iterNext.GetSkippedOffset() - offset;
    1:     PRUint32 flags = 0;
 2319:     nsIFrame* initialBreakController = mappedFlow->mAncestorControllingInitialBreak;
 2319:     if (!initialBreakController) {
 2319:       initialBreakController = mLineContainer;
 2319:     }
 7069:     if (!initialBreakController->GetStyleText()->WhiteSpaceCanWrap()) {
 7069:       flags |= nsLineBreaker::BREAK_SUPPRESS_INITIAL;
 7069:     }
 7069:     nsTextFrame* startFrame = mappedFlow->mStartFrame;
 2013:     const nsStyleText* textStyle = startFrame->GetStyleText();
 7069:     if (!textStyle->WhiteSpaceCanWrap()) {
 7069:       flags |= nsLineBreaker::BREAK_SUPPRESS_INSIDE;
 7069:     }
 7069:     if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_NO_BREAKS) {
 7069:       flags |= nsLineBreaker::BREAK_SKIP_SETTING_NO_BREAKS;
 7069:     }
 7832:     if (textStyle->mTextTransform == NS_STYLE_TEXT_TRANSFORM_CAPITALIZE) {
 7832:       flags |= nsLineBreaker::BREAK_NEED_CAPITALIZATION;
 7832:     }
 7069: 
16575:     if (HasCompressedLeadingWhitespace(startFrame, textStyle,
16575:                                        mappedFlow->GetContentEnd(), iter)) {
 7069:       mLineBreaker.AppendInvisibleWhitespace(flags);
 7069:     }
 7069: 
 7069:     if (length > 0) {
 7069:       BreakSink* sink = aSuppressSink ? nsnull : (*breakSink).get();
 1328:       if (aTextRun->GetFlags() & gfxFontGroup::TEXT_IS_8BIT) {
38492:         mLineBreaker.AppendText(language, aTextRun->GetText8Bit() + offset,
 2319:                                 length, flags, sink);
    1:       } else {
38492:         mLineBreaker.AppendText(language, aTextRun->GetTextUnicode() + offset,
 2319:                                 length, flags, sink);
    1:       }
    1:     }
 2013:     
 7114:     iter = iterNext;
 2013:   }
    1: }
    1: 
    1: void
    1: BuildTextRunsScanner::AssignTextRun(gfxTextRun* aTextRun)
    1: {
    1:   PRUint32 i;
    1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
    1:     MappedFlow* mappedFlow = &mMappedFlows[i];
    8:     nsTextFrame* startFrame = mappedFlow->mStartFrame;
    8:     nsTextFrame* endFrame = mappedFlow->mEndFrame;
    8:     nsTextFrame* f;
    8:     for (f = startFrame; f != endFrame;
 6033:          f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
 2828: #ifdef DEBUG_roc
    8:       if (f->GetTextRun()) {
    8:         gfxTextRun* textRun = f->GetTextRun();
    8:         if (textRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
 3233:           if (mMappedFlows[0].mStartFrame != static_cast<nsTextFrame*>(textRun->GetUserData())) {
    8:             NS_WARNING("REASSIGNING SIMPLE FLOW TEXT RUN!");
    8:           }
    8:         } else {
    8:           TextRunUserData* userData =
 3233:             static_cast<TextRunUserData*>(textRun->GetUserData());
    8:          
    8:           if (PRUint32(userData->mMappedFlowCount) >= mMappedFlows.Length() ||
    8:               userData->mMappedFlows[userData->mMappedFlowCount - 1].mStartFrame !=
    8:               mMappedFlows[userData->mMappedFlowCount - 1].mStartFrame) {
    8:             NS_WARNING("REASSIGNING MULTIFLOW TEXT RUN (not append)!");
    8:           }
    8:         }
    8:       }
    8: #endif
    1:       f->ClearTextRun();
    1:       f->SetTextRun(aTextRun);
    1:     }
25414:     // Set this bit now; we can't set it any earlier because
25414:     // f->ClearTextRun() might clear it out.
25414:     startFrame->AddStateBits(TEXT_IN_TEXTRUN_USER_DATA);
    1:   }
    1: }
    1: 
47926: // Find the flow corresponding to aContent in aUserData
47926: static inline TextRunMappedFlow*
47926: FindFlowForContent(TextRunUserData* aUserData, nsIContent* aContent)
47926: {
47926:   // Find the flow that contains us
47926:   PRInt32 i = aUserData->mLastFlowIndex;
47926:   PRInt32 delta = 1;
47926:   PRInt32 sign = 1;
47926:   // Search starting at the current position and examine close-by
47926:   // positions first, moving further and further away as we go.
47926:   while (i >= 0 && i < aUserData->mMappedFlowCount) {
47926:     TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
47926:     if (flow->mStartFrame->GetContent() == aContent) {
47926:       return flow;
47926:     }
47926: 
47926:     i += delta;
47926:     delta = -delta - sign;
47926:     sign = -sign;
47926:   }
47926: 
47926:   // We ran into an array edge.  Add |delta| to |i| once more to get
47926:   // back to the side where we still need to search, then step in
47926:   // the |sign| direction.
47926:   i += delta;
47926:   if (sign > 0) {
47926:     for (; i < aUserData->mMappedFlowCount; ++i) {
47926:       TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
47926:       if (flow->mStartFrame->GetContent() == aContent) {
47926:         return flow;
47926:       }
47926:     }
47926:   } else {
47926:     for (; i >= 0; --i) {
47926:       TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
47926:       if (flow->mStartFrame->GetContent() == aContent) {
47926:         return flow;
47926:       }
47926:     }
47926:   }
47926: 
47926:   return nsnull;
47926: }
47926: 
    1: gfxSkipCharsIterator
 6862: nsTextFrame::EnsureTextRun(gfxContext* aReferenceContext, nsIFrame* aLineContainer,
    1:                            const nsLineList::iterator* aLine,
 4672:                            PRUint32* aFlowEndInTextRun)
 4672: {
 6029:   if (mTextRun && (!aLine || !(*aLine)->GetInvalidateTextRuns())) {
 1328:     if (mTextRun->GetExpirationState()->IsTracked()) {
 1328:       gTextRuns->MarkUsed(mTextRun);
 1328:     }
 1328:   } else {
 6862:     nsRefPtr<gfxContext> ctx = aReferenceContext;
 6862:     if (!ctx) {
 6862:       ctx = GetReferenceRenderingContext(this, nsnull);
 6862:     }
 6862:     if (ctx) {
 6862:       BuildTextRuns(ctx, this, aLineContainer, aLine);
 1563:     }
    1:     if (!mTextRun) {
    1:       // A text run was not constructed for this frame. This is bad. The caller
    1:       // will check mTextRun.
    1:       static const gfxSkipChars emptySkipChars;
    1:       return gfxSkipCharsIterator(emptySkipChars, 0);
    1:     }
    1:   }
    1: 
    1:   if (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
    1:     if (aFlowEndInTextRun) {
    1:       *aFlowEndInTextRun = mTextRun->GetLength();
    1:     }
    1:     return gfxSkipCharsIterator(mTextRun->GetSkipChars(), 0, mContentOffset);
    1:   }
    1: 
 3233:   TextRunUserData* userData = static_cast<TextRunUserData*>(mTextRun->GetUserData());
47926:   TextRunMappedFlow* flow = FindFlowForContent(userData, mContent);
47926:   if (flow) {
 7012:     // Since textruns can only contain one flow for a given content element,
 7012:     // this must be our flow.
47926:     PRInt32 flowIndex = flow - userData->mMappedFlows;
47926:     userData->mLastFlowIndex = flowIndex;
    1:     gfxSkipCharsIterator iter(mTextRun->GetSkipChars(),
    1:                               flow->mDOMOffsetToBeforeTransformOffset, mContentOffset);
    1:     if (aFlowEndInTextRun) {
47926:       if (flowIndex + 1 < userData->mMappedFlowCount) {
    1:         gfxSkipCharsIterator end(mTextRun->GetSkipChars());
    1:         *aFlowEndInTextRun = end.ConvertOriginalToSkipped(
    1:               flow[1].mStartFrame->GetContentOffset() + flow[1].mDOMOffsetToBeforeTransformOffset);
    1:       } else {
    1:         *aFlowEndInTextRun = mTextRun->GetLength();
    1:       }
    1:     }
    1:     return iter;
    1:   }
47926: 
    1:   NS_ERROR("Can't find flow containing this frame???");
    1:   static const gfxSkipChars emptySkipChars;
    1:   return gfxSkipCharsIterator(emptySkipChars, 0);
    1: }
    1: 
    8: static PRUint32
16575: GetEndOfTrimmedText(const nsTextFragment* aFrag, const nsStyleText* aStyleText,
    8:                     PRUint32 aStart, PRUint32 aEnd,
    8:                     gfxSkipCharsIterator* aIterator)
    8: {
    8:   aIterator->SetSkippedOffset(aEnd);
    8:   while (aIterator->GetSkippedOffset() > aStart) {
    8:     aIterator->AdvanceSkipped(-1);
16575:     if (!IsTrimmableSpace(aFrag, aIterator->GetOriginalOffset(), aStyleText))
 2013:       return aIterator->GetSkippedOffset() + 1;
 2013:   }
 2013:   return aStart;
    8: }
    8: 
    8: nsTextFrame::TrimmedOffsets
    8: nsTextFrame::GetTrimmedOffsets(const nsTextFragment* aFrag,
    8:                                PRBool aTrimAfter)
    1: {
    1:   NS_ASSERTION(mTextRun, "Need textrun here");
16575:   // This should not be used during reflow. We need our TEXT_REFLOW_FLAGS
16575:   // to be set correctly.
16575:   NS_ASSERTION(!(GetStateBits() & NS_FRAME_FIRST_REFLOW),
16575:                "Can only call this on frames that have been reflowed");
16575:   NS_ASSERTION(!(GetStateBits() & NS_FRAME_IN_REFLOW),
16575:                "Can only call this on frames that are not being reflowed");
    1: 
 4678:   TrimmedOffsets offsets = { GetContentOffset(), GetContentLength() };
 1912:   const nsStyleText* textStyle = GetStyleText();
16575:   // Note that pre-line newlines should still allow us to trim spaces
16575:   // for display
 1912:   if (textStyle->WhiteSpaceIsSignificant())
    8:     return offsets;
    8: 
    8:   if (GetStateBits() & TEXT_START_OF_LINE) {
    8:     PRInt32 whitespaceCount =
16575:       GetTrimmableWhitespaceCount(aFrag,
16575:                                   offsets.mStart, offsets.mLength, 1);
    8:     offsets.mStart += whitespaceCount;
    8:     offsets.mLength -= whitespaceCount;
    8:   }
    8: 
 7069:   if (aTrimAfter && (GetStateBits() & TEXT_END_OF_LINE)) {
16575:     // This treats a trailing 'pre-line' newline as trimmable. That's fine,
16575:     // it's actually what we want since we want whitespace before it to
16575:     // be trimmed.
    8:     PRInt32 whitespaceCount =
16575:       GetTrimmableWhitespaceCount(aFrag,
16575:                                   offsets.GetEnd() - 1, offsets.mLength, -1);
    8:     offsets.mLength -= whitespaceCount;
    8:   }
    8:   return offsets;
    1: }
    1: 
    1: /*
    1:  * Currently only Unicode characters below 0x10000 have their spacing modified
    1:  * by justification. If characters above 0x10000 turn out to need
    1:  * justification spacing, that will require extra work. Currently,
    1:  * this function must not include 0xd800 to 0xdbff because these characters
    1:  * are surrogates.
    1:  */
    1: static PRBool IsJustifiableCharacter(const nsTextFragment* aFrag, PRInt32 aPos,
    1:                                      PRBool aLangIsCJ)
    1: {
    1:   PRUnichar ch = aFrag->CharAt(aPos);
46149:   if (ch == '\n' || ch == '\t' || ch == '\r')
  202:     return PR_TRUE;
37532:   if (ch == ' ' || ch == CH_NBSP) {
    1:     // Don't justify spaces that are combined with diacriticals
    1:     if (!aFrag->Is2b())
    1:       return PR_TRUE;
    1:     return !nsTextFrameUtils::IsSpaceCombiningSequenceTail(
    1:         aFrag->Get2b() + aPos + 1, aFrag->GetLength() - (aPos + 1));
    1:   }
    1:   if (ch < 0x2150u)
    1:     return PR_FALSE;
    1:   if (aLangIsCJ && (
    1:        (0x2150u <= ch && ch <= 0x22ffu) || // Number Forms, Arrows, Mathematical Operators
    1:        (0x2460u <= ch && ch <= 0x24ffu) || // Enclosed Alphanumerics
    1:        (0x2580u <= ch && ch <= 0x27bfu) || // Block Elements, Geometric Shapes, Miscellaneous Symbols, Dingbats
    1:        (0x27f0u <= ch && ch <= 0x2bffu) || // Supplemental Arrows-A, Braille Patterns, Supplemental Arrows-B,
    1:                                            // Miscellaneous Mathematical Symbols-B, Supplemental Mathematical Operators,
    1:                                            // Miscellaneous Symbols and Arrows
    1:        (0x2e80u <= ch && ch <= 0x312fu) || // CJK Radicals Supplement, CJK Radicals Supplement,
    1:                                            // Ideographic Description Characters, CJK Symbols and Punctuation,
    1:                                            // Hiragana, Katakana, Bopomofo
    1:        (0x3190u <= ch && ch <= 0xabffu) || // Kanbun, Bopomofo Extended, Katakana Phonetic Extensions,
    1:                                            // Enclosed CJK Letters and Months, CJK Compatibility,
    1:                                            // CJK Unified Ideographs Extension A, Yijing Hexagram Symbols,
    1:                                            // CJK Unified Ideographs, Yi Syllables, Yi Radicals
    1:        (0xf900u <= ch && ch <= 0xfaffu) || // CJK Compatibility Ideographs
    1:        (0xff5eu <= ch && ch <= 0xff9fu)    // Halfwidth and Fullwidth Forms(a part)
    1:      ))
    1:     return PR_TRUE;
    1:   return PR_FALSE;
    1: }
    1: 
    1: static void ClearMetrics(nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   aMetrics.width = 0;
    1:   aMetrics.height = 0;
    1:   aMetrics.ascent = 0;
    1: }
    1: 
    1: static PRInt32 FindChar(const nsTextFragment* frag,
    1:                         PRInt32 aOffset, PRInt32 aLength, PRUnichar ch)
    1: {
    1:   PRInt32 i = 0;
    1:   if (frag->Is2b()) {
    1:     const PRUnichar* str = frag->Get2b() + aOffset;
    1:     for (; i < aLength; ++i) {
    1:       if (*str == ch)
    1:         return i + aOffset;
    1:       ++str;
    1:     }
    1:   } else {
    1:     if (PRUint16(ch) <= 0xFF) {
    1:       const char* str = frag->Get1b() + aOffset;
 1344:       const void* p = memchr(str, ch, aLength);
    1:       if (p)
 3233:         return (static_cast<const char*>(p) - str) + aOffset;
    1:     }
    1:   }
    1:   return -1;
    1: }
    1: 
38492: static PRBool IsChineseOrJapanese(nsIFrame* aFrame)
38492: {
38492:   nsIAtom* language = aFrame->GetStyleVisibility()->mLanguage;
38492:   if (!language) {
38492:     return PR_FALSE;
38492:   }
39100:   const PRUnichar *lang = language->GetUTF16String();
39100:   return (!nsCRT::strncmp(lang, NS_LITERAL_STRING("ja").get(), 2) ||
39100:           !nsCRT::strncmp(lang, NS_LITERAL_STRING("zh").get(), 2)) &&
39100:          (language->GetLength() == 2 || lang[2] == '-');
    1: }
    1: 
    1: #ifdef DEBUG
    1: static PRBool IsInBounds(const gfxSkipCharsIterator& aStart, PRInt32 aContentLength,
    1:                          PRUint32 aOffset, PRUint32 aLength) {
    1:   if (aStart.GetSkippedOffset() > aOffset)
    1:     return PR_FALSE;
 8556:   if (aContentLength == PR_INT32_MAX)
 8556:     return PR_TRUE;
    1:   gfxSkipCharsIterator iter(aStart);
 1756:   iter.AdvanceOriginal(aContentLength);
 1756:   return iter.GetSkippedOffset() >= aOffset + aLength;
    1: }
    1: #endif
    1: 
15599: class NS_STACK_CLASS PropertyProvider : public gfxTextRun::PropertyProvider {
    1: public:
    1:   /**
    1:    * Use this constructor for reflow, when we don't know what text is
    1:    * really mapped by the frame and we have a lot of other data around.
 8556:    * 
 8556:    * @param aLength can be PR_INT32_MAX to indicate we cover all the text
 8556:    * associated with aFrame up to where its flow chain ends in the given
 8556:    * textrun. If PR_INT32_MAX is passed, justification and hyphen-related methods
 8556:    * cannot be called, nor can GetOriginalLength().
    1:    */
    1:   PropertyProvider(gfxTextRun* aTextRun, const nsStyleText* aTextStyle,
    1:                    const nsTextFragment* aFrag, nsTextFrame* aFrame,
 1732:                    const gfxSkipCharsIterator& aStart, PRInt32 aLength,
 1732:                    nsIFrame* aLineContainer,
 1732:                    nscoord aOffsetFromBlockOriginForTabs)
13714:     : mTextRun(aTextRun), mFontGroup(nsnull),
13714:       mTextStyle(aTextStyle), mFrag(aFrag),
 1732:       mLineContainer(aLineContainer),
 2013:       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
 2013:       mTabWidths(nsnull), mLength(aLength),
23137:       mWordSpacing(mTextStyle->mWordSpacing),
    1:       mLetterSpacing(StyleToCoord(mTextStyle->mLetterSpacing)),
    1:       mJustificationSpacing(0),
 1732:       mHyphenWidth(-1),
 1732:       mOffsetFromBlockOriginForTabs(aOffsetFromBlockOriginForTabs),
 1732:       mReflowing(PR_TRUE)
    1:   {
    1:     NS_ASSERTION(mStart.IsInitialized(), "Start not initialized?");
    1:   }
    1: 
    1:   /**
    1:    * Use this constructor after the frame has been reflowed and we don't
    1:    * have other data around. Gets everything from the frame. EnsureTextRun
    1:    * *must* be called before this!!!
    1:    */
    1:   PropertyProvider(nsTextFrame* aFrame, const gfxSkipCharsIterator& aStart)
 1732:     : mTextRun(aFrame->GetTextRun()), mFontGroup(nsnull),
 1732:       mTextStyle(aFrame->GetStyleText()),
35581:       mFrag(aFrame->GetContent()->GetText()),
 1732:       mLineContainer(nsnull),
 2013:       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
 2013:       mTabWidths(nsnull),
 1732:       mLength(aFrame->GetContentLength()),
23137:       mWordSpacing(mTextStyle->mWordSpacing),
    1:       mLetterSpacing(StyleToCoord(mTextStyle->mLetterSpacing)),
    1:       mJustificationSpacing(0),
 1732:       mHyphenWidth(-1),
 1732:       mOffsetFromBlockOriginForTabs(0),
 1732:       mReflowing(PR_FALSE)
    1:   {
    1:     NS_ASSERTION(mTextRun, "Textrun not initialized!");
    1:   }
    1: 
    1:   // Call this after construction if you're not going to reflow the text
    1:   void InitializeForDisplay(PRBool aTrimAfter);
    1: 
    1:   virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength, Spacing* aSpacing);
    1:   virtual gfxFloat GetHyphenWidth();
    1:   virtual void GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
    1:                                     PRPackedBool* aBreakBefore);
    1: 
 1732:   void GetSpacingInternal(PRUint32 aStart, PRUint32 aLength, Spacing* aSpacing,
 1732:                           PRBool aIgnoreTabs);
 1732: 
    1:   /**
    1:    * Count the number of justifiable characters in the given DOM range
    1:    */
    1:   PRUint32 ComputeJustifiableCharacters(PRInt32 aOffset, PRInt32 aLength);
 8514:   /**
 8514:    * Find the start and end of the justifiable characters. Does not depend on the
 8514:    * position of aStart or aEnd, although it's most efficient if they are near the
 8514:    * start and end of the text frame.
 8514:    */
 7076:   void FindJustificationRange(gfxSkipCharsIterator* aStart,
 7076:                               gfxSkipCharsIterator* aEnd);
    1: 
    8:   const nsStyleText* GetStyleText() { return mTextStyle; }
    1:   nsTextFrame* GetFrame() { return mFrame; }
    1:   // This may not be equal to the frame offset/length in because we may have
    1:   // adjusted for whitespace trimming according to the state bits set in the frame
    1:   // (for the static provider)
    1:   const gfxSkipCharsIterator& GetStart() { return mStart; }
 8474:   // May return PR_INT32_MAX if that was given to the constructor
 8556:   PRUint32 GetOriginalLength() {
 8556:     NS_ASSERTION(mLength != PR_INT32_MAX, "Length not known");
 8556:     return mLength;
 8556:   }
    1:   const nsTextFragment* GetFragment() { return mFrag; }
    1: 
    1:   gfxFontGroup* GetFontGroup() {
13714:     if (!mFontGroup)
13714:       InitFontGroupAndFontMetrics();
    1:     return mFontGroup;
    1:   }
    1: 
13714:   nsIFontMetrics* GetFontMetrics() {
13714:     if (!mFontMetrics)
13714:       InitFontGroupAndFontMetrics();
13714:     return mFontMetrics;
13714:   }
13714: 
 1732:   gfxFloat* GetTabWidths(PRUint32 aTransformedStart, PRUint32 aTransformedLength);
 1732: 
 2013:   const gfxSkipCharsIterator& GetEndHint() { return mTempIterator; }
 2013: 
    1: protected:
    1:   void SetupJustificationSpacing();
    1: 
13714:   void InitFontGroupAndFontMetrics() {
13714:     mFontGroup = GetFontGroupForFrame(mFrame, getter_AddRefs(mFontMetrics));
13714:   }
13714: 
    1:   gfxTextRun*           mTextRun;
    1:   gfxFontGroup*         mFontGroup;
13714:   nsCOMPtr<nsIFontMetrics> mFontMetrics;
    1:   const nsStyleText*    mTextStyle;
    1:   const nsTextFragment* mFrag;
 1732:   nsIFrame*             mLineContainer;
    1:   nsTextFrame*          mFrame;
    1:   gfxSkipCharsIterator  mStart;  // Offset in original and transformed string
 2013:   gfxSkipCharsIterator  mTempIterator;
12350:   
12350:   // Widths for each transformed string character, 0 for non-tab characters.
12350:   // Either null, or pointing to the frame's tabWidthProperty.
12350:   nsTArray<gfxFloat>*   mTabWidths;
12350: 
 8556:   PRInt32               mLength; // DOM string length, may be PR_INT32_MAX
    1:   gfxFloat              mWordSpacing;     // space for each whitespace char
    1:   gfxFloat              mLetterSpacing;   // space for each letter
    1:   gfxFloat              mJustificationSpacing;
    1:   gfxFloat              mHyphenWidth;
 1732:   gfxFloat              mOffsetFromBlockOriginForTabs;
 1732:   PRPackedBool          mReflowing;
    1: };
    1: 
    1: PRUint32
    1: PropertyProvider::ComputeJustifiableCharacters(PRInt32 aOffset, PRInt32 aLength)
    1: {
    1:   // Scan non-skipped characters and count justifiable chars.
    1:   nsSkipCharsRunIterator
    1:     run(mStart, nsSkipCharsRunIterator::LENGTH_INCLUDES_SKIPPED, aLength);
    1:   run.SetOriginalOffset(aOffset);
    1:   PRUint32 justifiableChars = 0;
38492:   PRBool isCJK = IsChineseOrJapanese(mFrame);
    1:   while (run.NextRun()) {
    1:     PRInt32 i;
    1:     for (i = 0; i < run.GetRunLength(); ++i) {
    1:       justifiableChars +=
    1:         IsJustifiableCharacter(mFrag, run.GetOriginalOffset() + i, isCJK);
    1:     }
    1:   }
    1:   return justifiableChars;
    1: }
    1: 
    1: /**
    1:  * Finds the offset of the first character of the cluster containing aPos
    1:  */
38653: static void FindClusterStart(gfxTextRun* aTextRun, PRInt32 aOriginalStart,
    1:                              gfxSkipCharsIterator* aPos)
    1: {
38653:   while (aPos->GetOriginalOffset() > aOriginalStart) {
    1:     if (aPos->IsOriginalCharSkipped() ||
    8:         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
    1:       break;
    1:     }
    1:     aPos->AdvanceOriginal(-1);
    1:   }
    1: }
    1: 
    1: /**
    1:  * Finds the offset of the last character of the cluster containing aPos
    1:  */
    1: static void FindClusterEnd(gfxTextRun* aTextRun, PRInt32 aOriginalEnd,
    1:                            gfxSkipCharsIterator* aPos)
    1: {
    1:   NS_PRECONDITION(aPos->GetOriginalOffset() < aOriginalEnd,
    1:                   "character outside string");
    1:   aPos->AdvanceOriginal(1);
    1:   while (aPos->GetOriginalOffset() < aOriginalEnd) {
    1:     if (aPos->IsOriginalCharSkipped() ||
    8:         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
    1:       break;
    1:     }
    1:     aPos->AdvanceOriginal(1);
    1:   }
    1:   aPos->AdvanceOriginal(-1);
    1: }
    1: 
    1: // aStart, aLength in transformed string offsets
    1: void
    1: PropertyProvider::GetSpacing(PRUint32 aStart, PRUint32 aLength,
    1:                              Spacing* aSpacing)
    1: {
 1732:   GetSpacingInternal(aStart, aLength, aSpacing,
 1732:                      (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) == 0);
 1732: }
 1732: 
 2027: static PRBool
 2027: CanAddSpacingAfter(gfxTextRun* aTextRun, PRUint32 aOffset)
 2027: {
 2027:   if (aOffset + 1 >= aTextRun->GetLength())
 2027:     return PR_TRUE;
 2027:   return aTextRun->IsClusterStart(aOffset + 1) &&
 7715:     aTextRun->IsLigatureGroupStart(aOffset + 1);
 2027: }
 2027: 
 1732: void
 1732: PropertyProvider::GetSpacingInternal(PRUint32 aStart, PRUint32 aLength,
 1732:                                      Spacing* aSpacing, PRBool aIgnoreTabs)
 1732: {
    1:   NS_PRECONDITION(IsInBounds(mStart, mLength, aStart, aLength), "Range out of bounds");
    1: 
    1:   PRUint32 index;
    1:   for (index = 0; index < aLength; ++index) {
    1:     aSpacing[index].mBefore = 0.0;
    1:     aSpacing[index].mAfter = 0.0;
    1:   }
    1: 
    1:   // Find our offset into the original+transformed string
    1:   gfxSkipCharsIterator start(mStart);
    1:   start.SetSkippedOffset(aStart);
    1: 
    1:   // First, compute the word and letter spacing
    1:   if (mWordSpacing || mLetterSpacing) {
    1:     // Iterate over non-skipped characters
    1:     nsSkipCharsRunIterator
    1:       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
    1:     while (run.NextRun()) {
    1:       PRUint32 runOffsetInSubstring = run.GetSkippedOffset() - aStart;
    1:       PRInt32 i;
    8:       gfxSkipCharsIterator iter = run.GetPos();
    1:       for (i = 0; i < run.GetRunLength(); ++i) {
 2027:         if (CanAddSpacingAfter(mTextRun, run.GetSkippedOffset() + i)) {
 2027:           // End of a cluster, not in a ligature: put letter-spacing after it
    1:           aSpacing[runOffsetInSubstring + i].mAfter += mLetterSpacing;
    1:         }
22494:         if (IsCSSWordSpacingSpace(mFrag, i + run.GetOriginalOffset(),
22494:                                   mTextStyle)) {
    1:           // It kinda sucks, but space characters can be part of clusters,
    1:           // and even still be whitespace (I think!)
    8:           iter.SetSkippedOffset(run.GetSkippedOffset() + i);
    8:           FindClusterEnd(mTextRun, run.GetOriginalOffset() + run.GetRunLength(),
    8:                          &iter);
    8:           aSpacing[iter.GetSkippedOffset() - aStart].mAfter += mWordSpacing;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
33208:   // Ignore tab spacing rather than computing it, if the tab size is 0
33208:   if (!aIgnoreTabs)
33208:     aIgnoreTabs = mFrame->GetStyleText()->mTabSize == 0;
33208: 
    1:   // Now add tab spacing, if there is any
 1732:   if (!aIgnoreTabs) {
 1732:     gfxFloat* tabs = GetTabWidths(aStart, aLength);
 1732:     if (tabs) {
    1:       for (index = 0; index < aLength; ++index) {
 1732:         aSpacing[index].mAfter += tabs[index];
 1732:       }
    1:     }
    1:   }
    1: 
    1:   // Now add in justification spacing
    1:   if (mJustificationSpacing) {
    1:     gfxFloat halfJustificationSpace = mJustificationSpacing/2;
    1:     // Scan non-skipped characters and adjust justifiable chars, adding
    1:     // justification space on either side of the cluster
38492:     PRBool isCJK = IsChineseOrJapanese(mFrame);
 7076:     gfxSkipCharsIterator justificationStart(mStart), justificationEnd(mStart);
 7076:     FindJustificationRange(&justificationStart, &justificationEnd);
    1: 
    1:     nsSkipCharsRunIterator
    1:       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
    1:     while (run.NextRun()) {
    1:       PRInt32 i;
    8:       gfxSkipCharsIterator iter = run.GetPos();
38653:       PRInt32 runOriginalOffset = run.GetOriginalOffset();
    1:       for (i = 0; i < run.GetRunLength(); ++i) {
38653:         PRInt32 iterOriginalOffset = runOriginalOffset + i;
38653:         if (IsJustifiableCharacter(mFrag, iterOriginalOffset, isCJK)) {
38653:           iter.SetOriginalOffset(iterOriginalOffset);
38653:           FindClusterStart(mTextRun, runOriginalOffset, &iter);
    8:           PRUint32 clusterFirstChar = iter.GetSkippedOffset();
38653:           FindClusterEnd(mTextRun, runOriginalOffset + run.GetRunLength(), &iter);
    8:           PRUint32 clusterLastChar = iter.GetSkippedOffset();
    1:           // Only apply justification to characters before justificationEnd
 7076:           if (clusterFirstChar >= justificationStart.GetSkippedOffset() &&
 7076:               clusterLastChar < justificationEnd.GetSkippedOffset()) {
    8:             aSpacing[clusterFirstChar - aStart].mBefore += halfJustificationSpace;
    8:             aSpacing[clusterLastChar - aStart].mAfter += halfJustificationSpace;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
16705: static gfxFloat
33208: ComputeTabWidthAppUnits(nsIFrame* aFrame, gfxTextRun* aTextRun)
33208: {
33208:   // Get the number of spaces from CSS -moz-tab-size
33208:   const nsStyleText* textStyle = aFrame->GetStyleText();
33208:   
16705:   // Round the space width when converting to appunits the same way
16705:   // textruns do
16705:   gfxFloat spaceWidthAppUnits =
16705:     NS_roundf(GetFirstFontMetrics(
33208:                 GetFontGroupForFrame(aFrame)).spaceWidth *
16705:               aTextRun->GetAppUnitsPerDevUnit());
33208:   return textStyle->mTabSize * spaceWidthAppUnits;
16705: }
16705: 
16705: // aX and the result are in whole appunits.
16705: static gfxFloat
33208: AdvanceToNextTab(gfxFloat aX, nsIFrame* aFrame,
16705:                  gfxTextRun* aTextRun, gfxFloat* aCachedTabWidth)
16705: {
16705:   if (*aCachedTabWidth < 0) {
33208:     *aCachedTabWidth = ComputeTabWidthAppUnits(aFrame, aTextRun);
16705:   }
16705: 
16705:   // Advance aX to the next multiple of *aCachedTabWidth. We must advance
16705:   // by at least 1 appunit.
16705:   // XXX should we make this 1 CSS pixel?
16705:   return NS_ceil((aX + 1)/(*aCachedTabWidth))*(*aCachedTabWidth);
16705: }
16705: 
 1732: gfxFloat*
 1732: PropertyProvider::GetTabWidths(PRUint32 aStart, PRUint32 aLength)
 1732: {
 1732:   if (!mTabWidths) {
 1732:     if (!mReflowing) {
 3233:       mTabWidths = static_cast<nsTArray<gfxFloat>*>
39965:         (mFrame->Properties().Get(TabWidthProperty()));
 1732:       if (!mTabWidths) {
 1732:         NS_WARNING("We need precomputed tab widths, but they're not here...");
 1732:         return nsnull;
 1732:       }
 1732:     } else {
12350:       if (!mLineContainer) {
16705:         // Intrinsic width computation does its own tab processing. We
16705:         // just don't do anything here.
12350:         return nsnull;
12350:       }
12350: 
 1732:       nsAutoPtr<nsTArray<gfxFloat> > tabs(new nsTArray<gfxFloat>());
 1732:       if (!tabs)
 1732:         return nsnull;
39965:       mFrame->Properties().Set(TabWidthProperty(), tabs);
 1732:       mTabWidths = tabs.forget();
 1732:     }
 1732:   }
 1732: 
 1732:   PRUint32 startOffset = mStart.GetSkippedOffset();
 1732:   PRUint32 tabsEnd = startOffset + mTabWidths->Length();
 1732:   if (tabsEnd < aStart + aLength) {
 1732:     if (!mReflowing) {
 1732:       NS_WARNING("We need precomputed tab widths, but we don't have enough...");
 1732:       return nsnull;
 1732:     }
 1732:     
 1732:     if (!mTabWidths->AppendElements(aStart + aLength - tabsEnd))
 1732:       return nsnull;
 1732:     
16705:     gfxFloat tabWidth = -1;
12350:     for (PRUint32 i = tabsEnd; i < aStart + aLength; ++i) {
 1732:       Spacing spacing;
 1732:       GetSpacingInternal(i, 1, &spacing, PR_TRUE);
 1732:       mOffsetFromBlockOriginForTabs += spacing.mBefore;
 1732: 
 1732:       if (mTextRun->GetChar(i) != '\t') {
 1732:         (*mTabWidths)[i - startOffset] = 0;
 1732:         if (mTextRun->IsClusterStart(i)) {
 1732:           PRUint32 clusterEnd = i + 1;
 1732:           while (clusterEnd < mTextRun->GetLength() &&
 1732:                  !mTextRun->IsClusterStart(clusterEnd)) {
 1732:             ++clusterEnd;
 1732:           }
 1732:           mOffsetFromBlockOriginForTabs +=
 1732:             mTextRun->GetAdvanceWidth(i, clusterEnd - i, nsnull);
 1732:         }
 1732:       } else {
16705:         double nextTab = AdvanceToNextTab(mOffsetFromBlockOriginForTabs,
33208:                 mFrame, mTextRun, &tabWidth);
 1732:         (*mTabWidths)[i - startOffset] = nextTab - mOffsetFromBlockOriginForTabs;
 1732:         mOffsetFromBlockOriginForTabs = nextTab;
 1732:       }
 1732: 
 1732:       mOffsetFromBlockOriginForTabs += spacing.mAfter;
 1732:     }
 1732:   }
 1732: 
 1732:   return mTabWidths->Elements() + aStart - startOffset;
    1: }
    1: 
    1: gfxFloat
    1: PropertyProvider::GetHyphenWidth()
    1: {
    1:   if (mHyphenWidth < 0) {
 6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, mFrame));
    1:     mHyphenWidth = mLetterSpacing;
 5724:     if (hyphenTextRun.get()) {
    1:       mHyphenWidth += hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
    1:     }
    1:   }
    1:   return mHyphenWidth;
    1: }
    1: 
    1: void
    1: PropertyProvider::GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
    1:                                        PRPackedBool* aBreakBefore)
    1: {
    1:   NS_PRECONDITION(IsInBounds(mStart, mLength, aStart, aLength), "Range out of bounds");
 8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
    1: 
    1:   if (!mTextStyle->WhiteSpaceCanWrap()) {
    1:     memset(aBreakBefore, PR_FALSE, aLength);
    1:     return;
    1:   }
    1: 
    1:   // Iterate through the original-string character runs
    1:   nsSkipCharsRunIterator
  202:     run(mStart, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
    1:   run.SetSkippedOffset(aStart);
    1:   // We need to visit skipped characters so that we can detect SHY
    1:   run.SetVisitSkipped();
    1: 
 5422:   PRInt32 prevTrailingCharOffset = run.GetPos().GetOriginalOffset() - 1;
    1:   PRBool allowHyphenBreakBeforeNextChar =
 5422:     prevTrailingCharOffset >= mStart.GetOriginalOffset() &&
 5422:     prevTrailingCharOffset < mStart.GetOriginalOffset() + mLength &&
 5422:     mFrag->CharAt(prevTrailingCharOffset) == CH_SHY;
    1: 
    1:   while (run.NextRun()) {
    1:     NS_ASSERTION(run.GetRunLength() > 0, "Shouldn't return zero-length runs");
    1:     if (run.IsSkipped()) {
    1:       // Check if there's a soft hyphen which would let us hyphenate before
    1:       // the next non-skipped character. Don't look at soft hyphens followed
    1:       // by other skipped characters, we won't use them.
    1:       allowHyphenBreakBeforeNextChar =
    1:         mFrag->CharAt(run.GetOriginalOffset() + run.GetRunLength() - 1) == CH_SHY;
    1:     } else {
    1:       PRInt32 runOffsetInSubstring = run.GetSkippedOffset() - aStart;
    1:       memset(aBreakBefore + runOffsetInSubstring, 0, run.GetRunLength());
 3006:       // Don't allow hyphen breaks at the start of the line
 3006:       aBreakBefore[runOffsetInSubstring] = allowHyphenBreakBeforeNextChar &&
 3006:           (!(mFrame->GetStateBits() & TEXT_START_OF_LINE) ||
 3006:            run.GetSkippedOffset() > mStart.GetSkippedOffset());
    1:       allowHyphenBreakBeforeNextChar = PR_FALSE;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: PropertyProvider::InitializeForDisplay(PRBool aTrimAfter)
    1: {
    8:   nsTextFrame::TrimmedOffsets trimmed =
    8:     mFrame->GetTrimmedOffsets(mFrag, aTrimAfter);
    8:   mStart.SetOriginalOffset(trimmed.mStart);
    8:   mLength = trimmed.mLength;
    1:   SetupJustificationSpacing();
    1: }
    1: 
    1: static PRUint32 GetSkippedDistance(const gfxSkipCharsIterator& aStart,
    1:                                    const gfxSkipCharsIterator& aEnd)
    1: {
    1:   return aEnd.GetSkippedOffset() - aStart.GetSkippedOffset();
    1: }
    1: 
    1: void
 7076: PropertyProvider::FindJustificationRange(gfxSkipCharsIterator* aStart,
 7076:                                          gfxSkipCharsIterator* aEnd)
 7076: {
 8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
 7076:   NS_ASSERTION(aStart && aEnd, "aStart or/and aEnd is null");
 8556: 
 7076:   aStart->SetOriginalOffset(mStart.GetOriginalOffset());
 7076:   aEnd->SetOriginalOffset(mStart.GetOriginalOffset() + mLength);
 7076: 
 7076:   // Ignore first cluster at start of line for justification purposes
 7076:   if (mFrame->GetStateBits() & TEXT_START_OF_LINE) {
 7076:     while (aStart->GetOriginalOffset() < aEnd->GetOriginalOffset()) {
 7076:       aStart->AdvanceOriginal(1);
 7076:       if (!aStart->IsOriginalCharSkipped() &&
 7076:           mTextRun->IsClusterStart(aStart->GetSkippedOffset()))
 7076:         break;
 7076:     }
 7076:   }
 7002: 
 7002:   // Ignore trailing cluster at end of line for justification purposes
 7076:   if (mFrame->GetStateBits() & TEXT_END_OF_LINE) {
 7076:     while (aEnd->GetOriginalOffset() > aStart->GetOriginalOffset()) {
 7076:       aEnd->AdvanceOriginal(-1);
 7076:       if (!aEnd->IsOriginalCharSkipped() &&
 7076:           mTextRun->IsClusterStart(aEnd->GetSkippedOffset()))
 6947:         break;
 6947:     }
 6947:   }
 7076: }
 1320: 
    1: void
    1: PropertyProvider::SetupJustificationSpacing()
    1: {
 8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
 8556: 
16575:   if (!(mFrame->GetStateBits() & TEXT_JUSTIFICATION_ENABLED))
    1:     return;
    1: 
 7076:   gfxSkipCharsIterator start(mStart), end(mStart);
32189:   // We can't just use our mLength here; when InitializeForDisplay is
32189:   // called with PR_FALSE for aTrimAfter, we still shouldn't be assigning
32189:   // justification space to any trailing whitespace.
32189:   nsTextFrame::TrimmedOffsets trimmed =
32189:     mFrame->GetTrimmedOffsets(mFrag, PR_TRUE);
32189:   end.AdvanceOriginal(trimmed.mLength);
    1:   gfxSkipCharsIterator realEnd(end);
 7076:   FindJustificationRange(&start, &end);
    1: 
    1:   PRInt32 justifiableCharacters =
 7076:     ComputeJustifiableCharacters(start.GetOriginalOffset(),
 7076:                                  end.GetOriginalOffset() - start.GetOriginalOffset());
    1:   if (justifiableCharacters == 0) {
    1:     // Nothing to do, nothing is justifiable and we shouldn't have any
    1:     // justification space assigned
    1:     return;
    1:   }
    1: 
    1:   gfxFloat naturalWidth =
    1:     mTextRun->GetAdvanceWidth(mStart.GetSkippedOffset(),
    1:                               GetSkippedDistance(mStart, realEnd), this);
  202:   if (mFrame->GetStateBits() & TEXT_HYPHEN_BREAK) {
 6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, mFrame));
 5724:     if (hyphenTextRun.get()) {
  202:       naturalWidth +=
 1328:         hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
  202:     }
  202:   }
    1:   gfxFloat totalJustificationSpace = mFrame->GetSize().width - naturalWidth;
    1:   if (totalJustificationSpace <= 0) {
    1:     // No space available
    1:     return;
    1:   }
    1:   
    1:   mJustificationSpacing = totalJustificationSpace/justifiableCharacters;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Helper class for managing blinking text
    1: 
    1: class nsBlinkTimer : public nsITimerCallback
    1: {
    1: public:
    1:   nsBlinkTimer();
    1:   virtual ~nsBlinkTimer();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   void AddFrame(nsPresContext* aPresContext, nsIFrame* aFrame);
    1: 
    1:   PRBool RemoveFrame(nsIFrame* aFrame);
    1: 
    1:   PRInt32 FrameCount();
    1: 
    1:   void Start();
    1: 
    1:   void Stop();
    1: 
    1:   NS_DECL_NSITIMERCALLBACK
    1: 
    1:   static nsresult AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame);
    1:   static nsresult RemoveBlinkFrame(nsIFrame* aFrame);
    1:   
    1:   static PRBool   GetBlinkIsOff() { return sState == 3; }
    1:   
    1: protected:
    1: 
    1:   struct FrameData {
    1:     nsPresContext* mPresContext;  // pres context associated with the frame
    1:     nsIFrame*       mFrame;
    1: 
    1: 
    1:     FrameData(nsPresContext* aPresContext,
    1:               nsIFrame*       aFrame)
    1:       : mPresContext(aPresContext), mFrame(aFrame) {}
    1:   };
    1: 
26081:   class FrameDataComparator {
26081:     public:
26081:       PRBool Equals(const FrameData& aTimer, nsIFrame* const& aFrame) const {
26081:         return aTimer.mFrame == aFrame;
26081:       }
26081:   };
26081: 
    1:   nsCOMPtr<nsITimer> mTimer;
26081:   nsTArray<FrameData> mFrames;
    1:   nsPresContext* mPresContext;
    1: 
    1: protected:
    1: 
    1:   static nsBlinkTimer* sTextBlinker;
    1:   static PRUint32      sState; // 0-2 == on; 3 == off
    1:   
    1: };
    1: 
    1: nsBlinkTimer* nsBlinkTimer::sTextBlinker = nsnull;
    1: PRUint32      nsBlinkTimer::sState = 0;
    1: 
    1: #ifdef NOISY_BLINK
    1: static PRTime gLastTick;
    1: #endif
    1: 
    1: nsBlinkTimer::nsBlinkTimer()
    1: {
    1: }
    1: 
    1: nsBlinkTimer::~nsBlinkTimer()
    1: {
    1:   Stop();
    1:   sTextBlinker = nsnull;
    1: }
    1: 
    1: void nsBlinkTimer::Start()
    1: {
    1:   nsresult rv;
    1:   mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    1:   if (NS_OK == rv) {
    1:     mTimer->InitWithCallback(this, 250, nsITimer::TYPE_REPEATING_PRECISE);
    1:   }
    1: }
    1: 
    1: void nsBlinkTimer::Stop()
    1: {
    1:   if (nsnull != mTimer) {
    1:     mTimer->Cancel();
 5854:     mTimer = nsnull;
    1:   }
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsBlinkTimer, nsITimerCallback)
    1: 
    1: void nsBlinkTimer::AddFrame(nsPresContext* aPresContext, nsIFrame* aFrame) {
26081:   mFrames.AppendElement(FrameData(aPresContext, aFrame));
24551:   if (1 == mFrames.Length()) {
    1:     Start();
    1:   }
    1: }
    1: 
    1: PRBool nsBlinkTimer::RemoveFrame(nsIFrame* aFrame) {
26081:   mFrames.RemoveElement(aFrame, FrameDataComparator());
26081:   
26081:   if (mFrames.IsEmpty()) {
    1:     Stop();
    1:   }
24551:   return PR_TRUE;
    1: }
    1: 
    1: PRInt32 nsBlinkTimer::FrameCount() {
24551:   return PRInt32(mFrames.Length());
    1: }
    1: 
    1: NS_IMETHODIMP nsBlinkTimer::Notify(nsITimer *timer)
    1: {
    1:   // Toggle blink state bit so that text code knows whether or not to
    1:   // render. All text code shares the same flag so that they all blink
    1:   // in unison.
    1:   sState = (sState + 1) % 4;
    1:   if (sState == 1 || sState == 2)
    1:     // States 0, 1, and 2 are all the same.
    1:     return NS_OK;
    1: 
    1: #ifdef NOISY_BLINK
    1:   PRTime now = PR_Now();
    1:   char buf[50];
    1:   PRTime delta;
    1:   LL_SUB(delta, now, gLastTick);
    1:   gLastTick = now;
    1:   PR_snprintf(buf, sizeof(buf), "%lldusec", delta);
    1:   printf("%s\n", buf);
    1: #endif
    1: 
24551:   PRUint32 i, n = mFrames.Length();
    1:   for (i = 0; i < n; i++) {
26081:     FrameData& frameData = mFrames.ElementAt(i);
    1: 
    1:     // Determine damaged area and tell view manager to redraw it
    1:     // blink doesn't blink outline ... I hope
26081:     nsRect bounds(nsPoint(0, 0), frameData.mFrame->GetSize());
26081:     frameData.mFrame->Invalidate(bounds);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // static
    1: nsresult nsBlinkTimer::AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
    1: {
    1:   if (!sTextBlinker)
    1:   {
    1:     sTextBlinker = new nsBlinkTimer;
    1:     if (!sTextBlinker) return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   
    1:   NS_ADDREF(sTextBlinker);
    1: 
    1:   sTextBlinker->AddFrame(aPresContext, aFrame);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // static
    1: nsresult nsBlinkTimer::RemoveBlinkFrame(nsIFrame* aFrame)
    1: {
    1:   NS_ASSERTION(sTextBlinker, "Should have blink timer here");
    1:   
    1:   nsBlinkTimer* blinkTimer = sTextBlinker;    // copy so we can call NS_RELEASE on it
    1:   if (!blinkTimer) return NS_OK;
    1:   
    1:   blinkTimer->RemoveFrame(aFrame);  
    1:   NS_RELEASE(blinkTimer);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: static nscolor
    1: EnsureDifferentColors(nscolor colorA, nscolor colorB)
    1: {
    1:   if (colorA == colorB) {
    1:     nscolor res;
    1:     res = NS_RGB(NS_GET_R(colorA) ^ 0xff,
    1:                  NS_GET_G(colorA) ^ 0xff,
    1:                  NS_GET_B(colorA) ^ 0xff);
    1:     return res;
    1:   }
    1:   return colorA;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: static nscolor
    1: DarkenColor(nscolor aColor)
    1: {
    1:   PRUint16  hue, sat, value;
20888:   PRUint8 alpha;
    1: 
    1:   // convert the RBG to HSV so we can get the lightness (which is the v)
20888:   NS_RGB2HSV(aColor, hue, sat, value, alpha);
    1: 
    1:   // The goal here is to send white to black while letting colored
    1:   // stuff stay colored... So we adopt the following approach.
    1:   // Something with sat = 0 should end up with value = 0.  Something
    1:   // with a high sat can end up with a high value and it's ok.... At
    1:   // the same time, we don't want to make things lighter.  Do
    1:   // something simple, since it seems to work.
    1:   if (value > sat) {
    1:     value = sat;
    1:     // convert this color back into the RGB color space.
20888:     NS_HSV2RGB(aColor, hue, sat, value, alpha);
    1:   }
    1:   return aColor;
    1: }
    1: 
    1: // Check whether we should darken text colors. We need to do this if
    1: // background images and colors are being suppressed, because that means
    1: // light text will not be visible against the (presumed light-colored) background.
    1: static PRBool
    1: ShouldDarkenColors(nsPresContext* aPresContext)
    1: {
    1:   return !aPresContext->GetBackgroundColorDraw() &&
    1:     !aPresContext->GetBackgroundImageDraw();
    1: }
    1: 
    1: nsTextPaintStyle::nsTextPaintStyle(nsTextFrame* aFrame)
    1:   : mFrame(aFrame),
  280:     mPresContext(aFrame->PresContext()),
    1:     mInitCommonColors(PR_FALSE),
    1:     mInitSelectionColors(PR_FALSE)
    1: {
26883:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mSelectionStyle); i++)
26883:     mSelectionStyle[i].mInit = PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsTextPaintStyle::EnsureSufficientContrast(nscolor *aForeColor, nscolor *aBackColor)
    1: {
    1:   InitCommonColors();
    1: 
    1:   // If the combination of selection background color and frame background color
    1:   // is sufficient contrast, don't exchange the selection colors.
    1:   PRInt32 backLuminosityDifference =
    1:             NS_LUMINOSITY_DIFFERENCE(*aBackColor, mFrameBackgroundColor);
    1:   if (backLuminosityDifference >= mSufficientContrast)
    1:     return PR_FALSE;
    1: 
    1:   // Otherwise, we should use the higher-contrast color for the selection
    1:   // background color.
    1:   PRInt32 foreLuminosityDifference =
    1:             NS_LUMINOSITY_DIFFERENCE(*aForeColor, mFrameBackgroundColor);
    1:   if (backLuminosityDifference < foreLuminosityDifference) {
    1:     nscolor tmpColor = *aForeColor;
    1:     *aForeColor = *aBackColor;
    1:     *aBackColor = tmpColor;
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: nscolor
    1: nsTextPaintStyle::GetTextColor()
    1: {
40176:   nscolor color = mFrame->GetVisitedDependentColor(eCSSProperty_color);
    1:   if (ShouldDarkenColors(mPresContext)) {
    1:     color = DarkenColor(color);
    1:   }
    1:   return color;
    1: }
    1: 
    1: PRBool
    1: nsTextPaintStyle::GetSelectionColors(nscolor* aForeColor,
    1:                                      nscolor* aBackColor)
    1: {
    1:   NS_ASSERTION(aForeColor, "aForeColor is null");
    1:   NS_ASSERTION(aBackColor, "aBackColor is null");
    1: 
    1:   if (!InitSelectionColors())
    1:     return PR_FALSE;
    1: 
    1:   *aForeColor = mSelectionTextColor;
    1:   *aBackColor = mSelectionBGColor;
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
16313: nsTextPaintStyle::GetHighlightColors(nscolor* aForeColor,
16313:                                      nscolor* aBackColor)
16313: {
16313:   NS_ASSERTION(aForeColor, "aForeColor is null");
16313:   NS_ASSERTION(aBackColor, "aBackColor is null");
16313:   
16313:   nsILookAndFeel* look = mPresContext->LookAndFeel();
16313:   nscolor foreColor, backColor;
16313:   look->GetColor(nsILookAndFeel::eColor_TextHighlightBackground,
16313:                  backColor);
18568:   look->GetColor(nsILookAndFeel::eColor_TextHighlightForeground,
16313:                  foreColor);
16313:   EnsureSufficientContrast(&foreColor, &backColor);
16313:   *aForeColor = foreColor;
16313:   *aBackColor = backColor;
16313: }
16313: 
16313: void
    1: nsTextPaintStyle::GetIMESelectionColors(PRInt32  aIndex,
    1:                                         nscolor* aForeColor,
    1:                                         nscolor* aBackColor)
    1: {
    1:   NS_ASSERTION(aForeColor, "aForeColor is null");
    1:   NS_ASSERTION(aBackColor, "aBackColor is null");
26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
26883: 
26883:   nsSelectionStyle* selectionStyle = GetSelectionStyle(aIndex);
26883:   *aForeColor = selectionStyle->mTextColor;
26883:   *aBackColor = selectionStyle->mBGColor;
    1: }
    1: 
    1: PRBool
26883: nsTextPaintStyle::GetSelectionUnderlineForPaint(PRInt32  aIndex,
    1:                                                 nscolor* aLineColor,
 4728:                                                 float*   aRelativeSize,
 4728:                                                 PRUint8* aStyle)
    1: {
    1:   NS_ASSERTION(aLineColor, "aLineColor is null");
    1:   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
26883: 
26883:   nsSelectionStyle* selectionStyle = GetSelectionStyle(aIndex);
26883:   if (selectionStyle->mUnderlineStyle == NS_STYLE_BORDER_STYLE_NONE ||
26883:       selectionStyle->mUnderlineColor == NS_TRANSPARENT ||
26883:       selectionStyle->mUnderlineRelativeSize <= 0.0f)
    1:     return PR_FALSE;
    1: 
26883:   *aLineColor = selectionStyle->mUnderlineColor;
26883:   *aRelativeSize = selectionStyle->mUnderlineRelativeSize;
26883:   *aStyle = selectionStyle->mUnderlineStyle;
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsTextPaintStyle::InitCommonColors()
    1: {
    1:   if (mInitCommonColors)
    1:     return;
    1: 
40588:   nsIFrame* bgFrame =
40588:     nsCSSRendering::FindNonTransparentBackgroundFrame(mFrame);
40588:   NS_ASSERTION(bgFrame, "Cannot find NonTransparentBackgroundFrame.");
40178:   nscolor bgColor =
40588:     bgFrame->GetVisitedDependentColor(eCSSProperty_background_color);
19436: 
19436:   nscolor defaultBgColor = mPresContext->DefaultBackgroundColor();
40178:   mFrameBackgroundColor = NS_ComposeColors(defaultBgColor, bgColor);
23494: 
40588:   if (bgFrame->IsThemed()) {
23494:     // Assume a native widget has sufficient contrast always
23494:     mSufficientContrast = 0;
23494:     mInitCommonColors = PR_TRUE;
23494:     return;
23494:   }
23494: 
19436:   NS_ASSERTION(NS_GET_A(defaultBgColor) == 255,
19436:                "default background color is not opaque");
19436: 
    1:   nsILookAndFeel* look = mPresContext->LookAndFeel();
    1:   nscolor defaultWindowBackgroundColor, selectionTextColor, selectionBGColor;
    1:   look->GetColor(nsILookAndFeel::eColor_TextSelectBackground,
    1:                  selectionBGColor);
    1:   look->GetColor(nsILookAndFeel::eColor_TextSelectForeground,
    1:                  selectionTextColor);
    1:   look->GetColor(nsILookAndFeel::eColor_WindowBackground,
    1:                  defaultWindowBackgroundColor);
    1: 
    1:   mSufficientContrast =
32531:     NS_MIN(NS_MIN(NS_SUFFICIENT_LUMINOSITY_DIFFERENCE,
    1:                   NS_LUMINOSITY_DIFFERENCE(selectionTextColor,
    1:                                            selectionBGColor)),
    1:                   NS_LUMINOSITY_DIFFERENCE(defaultWindowBackgroundColor,
    1:                                            selectionBGColor));
    1: 
    1:   mInitCommonColors = PR_TRUE;
    1: }
    1: 
41641: static Element*
40526: FindElementAncestorForMozSelection(nsIContent* aContent)
40526: {
40526:   NS_ENSURE_TRUE(aContent, nsnull);
40526:   while (aContent && aContent->IsInNativeAnonymousSubtree()) {
40526:     aContent = aContent->GetBindingParent();
40526:   }
40526:   NS_ASSERTION(aContent, "aContent isn't in non-anonymous tree?");
41641:   while (aContent && !aContent->IsElement()) {
40526:     aContent = aContent->GetParent();
40526:   }
41641:   return aContent ? aContent->AsElement() : nsnull;
    1: }
    1: 
    1: PRBool
    1: nsTextPaintStyle::InitSelectionColors()
    1: {
    1:   if (mInitSelectionColors)
    1:     return PR_TRUE;
    1: 
    1:   PRInt16 selectionFlags;
    1:   PRInt16 selectionStatus = mFrame->GetSelectionStatus(&selectionFlags);
    1:   if (!(selectionFlags & nsISelectionDisplay::DISPLAY_TEXT) ||
    1:       selectionStatus < nsISelectionController::SELECTION_ON) {
    1:     // Not displaying the normal selection.
    1:     // We're not caching this fact, so every call to GetSelectionColors
    1:     // will come through here. We could avoid this, but it's not really worth it.
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   mInitSelectionColors = PR_TRUE;
    1: 
21943:   nsIFrame* nonGeneratedAncestor = nsLayoutUtils::GetNonGeneratedAncestor(mFrame);
41641:   Element* selectionElement =
40526:     FindElementAncestorForMozSelection(nonGeneratedAncestor->GetContent());
    1: 
41641:   if (selectionElement &&
    1:       selectionStatus == nsISelectionController::SELECTION_ON) {
    1:     nsRefPtr<nsStyleContext> sc = nsnull;
    1:     sc = mPresContext->StyleSet()->
41641:       ProbePseudoElementStyle(selectionElement,
35554:                               nsCSSPseudoElements::ePseudo_mozSelection,
    1:                               mFrame->GetStyleContext());
    1:     // Use -moz-selection pseudo class.
    1:     if (sc) {
40178:       mSelectionBGColor =
40178:         sc->GetVisitedDependentColor(eCSSProperty_background_color);
40176:       mSelectionTextColor = sc->GetVisitedDependentColor(eCSSProperty_color);
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   nsILookAndFeel* look = mPresContext->LookAndFeel();
    1: 
    1:   nscolor selectionBGColor;
    1:   look->GetColor(nsILookAndFeel::eColor_TextSelectBackground,
    1:                  selectionBGColor);
    1: 
    1:   if (selectionStatus == nsISelectionController::SELECTION_ATTENTION) {
    1:     look->GetColor(nsILookAndFeel::eColor_TextSelectBackgroundAttention,
    1:                    mSelectionBGColor);
    1:     mSelectionBGColor  = EnsureDifferentColors(mSelectionBGColor,
    1:                                                selectionBGColor);
    1:   } else if (selectionStatus != nsISelectionController::SELECTION_ON) {
    1:     look->GetColor(nsILookAndFeel::eColor_TextSelectBackgroundDisabled,
    1:                    mSelectionBGColor);
    1:     mSelectionBGColor  = EnsureDifferentColors(mSelectionBGColor,
    1:                                                selectionBGColor);
    1:   } else {
    1:     mSelectionBGColor = selectionBGColor;
    1:   }
    1: 
    1:   look->GetColor(nsILookAndFeel::eColor_TextSelectForeground,
    1:                  mSelectionTextColor);
    1: 
    1:   // On MacOS X, we don't exchange text color and BG color.
    1:   if (mSelectionTextColor == NS_DONT_CHANGE_COLOR) {
40176:     nscoord frameColor = mFrame->GetVisitedDependentColor(eCSSProperty_color);
40176:     mSelectionTextColor = EnsureDifferentColors(frameColor, mSelectionBGColor);
    1:   } else {
    1:     EnsureSufficientContrast(&mSelectionTextColor, &mSelectionBGColor);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
26883: nsTextPaintStyle::nsSelectionStyle*
26883: nsTextPaintStyle::GetSelectionStyle(PRInt32 aIndex)
26883: {
26883:   InitSelectionStyle(aIndex);
26883:   return &mSelectionStyle[aIndex];
 4728: }
 4728: 
 4728: struct StyleIDs {
    1:   nsILookAndFeel::nsColorID mForeground, mBackground, mLine;
 4728:   nsILookAndFeel::nsMetricID mLineStyle;
26883:   nsILookAndFeel::nsMetricFloatID mLineRelativeSize;
    1: };
26883: static StyleIDs SelectionStyleIDs[] = {
    1:   { nsILookAndFeel::eColor_IMERawInputForeground,
    1:     nsILookAndFeel::eColor_IMERawInputBackground,
 4728:     nsILookAndFeel::eColor_IMERawInputUnderline,
26883:     nsILookAndFeel::eMetric_IMERawInputUnderlineStyle,
26883:     nsILookAndFeel::eMetricFloat_IMEUnderlineRelativeSize },
    1:   { nsILookAndFeel::eColor_IMESelectedRawTextForeground,
    1:     nsILookAndFeel::eColor_IMESelectedRawTextBackground,
 4728:     nsILookAndFeel::eColor_IMESelectedRawTextUnderline,
26883:     nsILookAndFeel::eMetric_IMESelectedRawTextUnderlineStyle,
26883:     nsILookAndFeel::eMetricFloat_IMEUnderlineRelativeSize },
    1:   { nsILookAndFeel::eColor_IMEConvertedTextForeground,
    1:     nsILookAndFeel::eColor_IMEConvertedTextBackground,
 4728:     nsILookAndFeel::eColor_IMEConvertedTextUnderline,
26883:     nsILookAndFeel::eMetric_IMEConvertedTextUnderlineStyle,
26883:     nsILookAndFeel::eMetricFloat_IMEUnderlineRelativeSize },
    1:   { nsILookAndFeel::eColor_IMESelectedConvertedTextForeground,
    1:     nsILookAndFeel::eColor_IMESelectedConvertedTextBackground,
 4728:     nsILookAndFeel::eColor_IMESelectedConvertedTextUnderline,
26883:     nsILookAndFeel::eMetric_IMESelectedConvertedTextUnderline,
26883:     nsILookAndFeel::eMetricFloat_IMEUnderlineRelativeSize },
26883:   { nsILookAndFeel::eColor_LAST_COLOR,
26883:     nsILookAndFeel::eColor_LAST_COLOR,
26883:     nsILookAndFeel::eColor_SpellCheckerUnderline,
26883:     nsILookAndFeel::eMetric_SpellCheckerUnderlineStyle,
26883:     nsILookAndFeel::eMetricFloat_SpellCheckerUnderlineRelativeSize }
    1: };
    1: 
 4728: static PRUint8 sUnderlineStyles[] = {
26883:   nsCSSRendering::DECORATION_STYLE_NONE,   // NS_UNDERLINE_STYLE_NONE   0
26883:   nsCSSRendering::DECORATION_STYLE_DOTTED, // NS_UNDERLINE_STYLE_DOTTED 1
26883:   nsCSSRendering::DECORATION_STYLE_DASHED, // NS_UNDERLINE_STYLE_DASHED 2
26883:   nsCSSRendering::DECORATION_STYLE_SOLID,  // NS_UNDERLINE_STYLE_SOLID  3
26883:   nsCSSRendering::DECORATION_STYLE_DOUBLE, // NS_UNDERLINE_STYLE_DOUBLE 4
26883:   nsCSSRendering::DECORATION_STYLE_WAVY    // NS_UNDERLINE_STYLE_WAVY   5
 4728: };
 4728: 
    1: void
26883: nsTextPaintStyle::InitSelectionStyle(PRInt32 aIndex)
26883: {
26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "aIndex is invalid");
26883:   nsSelectionStyle* selectionStyle = &mSelectionStyle[aIndex];
26883:   if (selectionStyle->mInit)
    1:     return;
    1: 
26883:   StyleIDs* styleIDs = &SelectionStyleIDs[aIndex];
    1: 
    1:   nsILookAndFeel* look = mPresContext->LookAndFeel();
26883:   nscolor foreColor, backColor;
26883:   if (styleIDs->mForeground == nsILookAndFeel::eColor_LAST_COLOR) {
26883:     foreColor = NS_SAME_AS_FOREGROUND_COLOR;
26883:   } else {
 4728:     look->GetColor(styleIDs->mForeground, foreColor);
26883:   }
26883:   if (styleIDs->mBackground == nsILookAndFeel::eColor_LAST_COLOR) {
26883:     backColor = NS_TRANSPARENT;
26883:   } else {
 4728:     look->GetColor(styleIDs->mBackground, backColor);
26883:   }
    1: 
    1:   // Convert special color to actual color
    1:   NS_ASSERTION(foreColor != NS_TRANSPARENT,
    1:                "foreColor cannot be NS_TRANSPARENT");
    1:   NS_ASSERTION(backColor != NS_SAME_AS_FOREGROUND_COLOR,
    1:                "backColor cannot be NS_SAME_AS_FOREGROUND_COLOR");
    1:   NS_ASSERTION(backColor != NS_40PERCENT_FOREGROUND_COLOR,
    1:                "backColor cannot be NS_40PERCENT_FOREGROUND_COLOR");
    1: 
    1:   foreColor = GetResolvedForeColor(foreColor, GetTextColor(), backColor);
    1: 
    1:   if (NS_GET_A(backColor) > 0)
    1:     EnsureSufficientContrast(&foreColor, &backColor);
    1: 
26883:   nscolor lineColor;
26883:   float relativeSize;
26883:   PRUint8 lineStyle;
26883:   GetSelectionUnderline(mPresContext, aIndex,
26883:                         &lineColor, &relativeSize, &lineStyle);
    1:   lineColor = GetResolvedForeColor(lineColor, foreColor, backColor);
    1: 
26883:   selectionStyle->mTextColor       = foreColor;
26883:   selectionStyle->mBGColor         = backColor;
26883:   selectionStyle->mUnderlineColor  = lineColor;
26883:   selectionStyle->mUnderlineStyle  = lineStyle;
26883:   selectionStyle->mUnderlineRelativeSize = relativeSize;
26883:   selectionStyle->mInit            = PR_TRUE;
26883: }
26883: 
26883: /* static */ PRBool
26883: nsTextPaintStyle::GetSelectionUnderline(nsPresContext* aPresContext,
26883:                                         PRInt32 aIndex,
26883:                                         nscolor* aLineColor,
26883:                                         float* aRelativeSize,
26883:                                         PRUint8* aStyle)
26883: {
26883:   NS_ASSERTION(aPresContext, "aPresContext is null");
26883:   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
26883:   NS_ASSERTION(aStyle, "aStyle is null");
26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
26883: 
26883:   nsILookAndFeel* look = aPresContext->LookAndFeel();
26883: 
26883:   StyleIDs& styleID = SelectionStyleIDs[aIndex];
26883:   nscolor color;
26883:   float size;
26883:   PRInt32 style;
26883: 
26883:   look->GetColor(styleID.mLine, color);
26883:   look->GetMetric(styleID.mLineStyle, style);
26883:   if (!NS_IS_VALID_UNDERLINE_STYLE(style)) {
26883:     NS_ERROR("Invalid underline style value is specified");
26883:     style = NS_UNDERLINE_STYLE_SOLID;
26883:   }
26883:   look->GetMetric(styleID.mLineRelativeSize, size);
26883: 
26883:   NS_ASSERTION(size, "selection underline relative size must be larger than 0");
26883: 
26883:   if (aLineColor) {
26883:     *aLineColor = color;
26883:   }
26883:   *aRelativeSize = size;
26883:   *aStyle = sUnderlineStyles[style];
26883: 
26883:   return sUnderlineStyles[style] != nsCSSRendering::DECORATION_STYLE_NONE &&
26883:          color != NS_TRANSPARENT &&
26883:          size > 0.0f;
    1: }
    1: 
    1: inline nscolor Get40PercentColor(nscolor aForeColor, nscolor aBackColor)
    1: {
    1:   nscolor foreColor = NS_RGBA(NS_GET_R(aForeColor),
    1:                               NS_GET_G(aForeColor),
    1:                               NS_GET_B(aForeColor),
    1:                               (PRUint8)(255 * 0.4f));
 4728:   // Don't use true alpha color for readability.
    1:   return NS_ComposeColors(aBackColor, foreColor);
    1: }
    1: 
    1: nscolor
    1: nsTextPaintStyle::GetResolvedForeColor(nscolor aColor,
    1:                                        nscolor aDefaultForeColor,
    1:                                        nscolor aBackColor)
    1: {
    1:   if (aColor == NS_SAME_AS_FOREGROUND_COLOR)
    1:     return aDefaultForeColor;
    1: 
    1:   if (aColor != NS_40PERCENT_FOREGROUND_COLOR)
    1:     return aColor;
    1: 
    1:   // Get actual background color
    1:   nscolor actualBGColor = aBackColor;
    1:   if (actualBGColor == NS_TRANSPARENT) {
    1:     InitCommonColors();
    1:     actualBGColor = mFrameBackgroundColor;
    1:   }
    1:   return Get40PercentColor(aDefaultForeColor, actualBGColor);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsTextFrame::CreateAccessible()
    1: {
 9480:   if (IsEmpty()) {
 9480:     nsAutoString renderedWhitespace;
 9480:     GetRenderedText(&renderedWhitespace, nsnull, nsnull, 0, 1);
 9480:     if (renderedWhitespace.IsEmpty()) {
46338:       return nsnull;
 9480:     }
 9480:   }
    1: 
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
46338:     return accService->CreateHTMLTextAccessible(mContent,
46338:                                                 PresContext()->PresShell());
46338:   }
46338:   return nsnull;
    1: }
    1: #endif
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsTextFrame::Init(nsIContent*      aContent,
    1:                   nsIFrame*        aParent,
    1:                   nsIFrame*        aPrevInFlow)
    1: {
    1:   NS_ASSERTION(!aPrevInFlow, "Can't be a continuation!");
    8:   NS_PRECONDITION(aContent->IsNodeOfType(nsINode::eTEXT),
    8:                   "Bogus content!");
36903: 
36903:   // Remove any NewlineOffsetProperty since it might be invalid
36903:   // if the content was modified while there was no frame
36903:   aContent->DeleteProperty(nsGkAtoms::newline);
36903: 
29809:   // Since our content has a frame now, this flag is no longer needed.
29809:   aContent->UnsetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE);
    1:   // We're not a continuing frame.
    1:   // mContentOffset = 0; not necessary since we get zeroed out at init
 4678:   return nsFrame::Init(aContent, aParent, aPrevInFlow);
    1: }
    1: 
    1: void
49293: nsTextFrame::ClearFrameOffsetCache()
49293: {
49293:   // See if we need to remove ourselves from the offset cache
49293:   if (GetStateBits() & TEXT_IN_OFFSET_CACHE) {
49293:     nsIFrame* primaryFrame = mContent->GetPrimaryFrame();
49293:     if (primaryFrame) {
49293:       // The primary frame might be null here.  For example, nsLineBox::DeleteLineList
49293:       // just destroys the frames in order, which means that the primary frame is already
49293:       // dead if we're a continuing text frame, in which case, all of its properties are
49293:       // gone, and we don't need to worry about deleting this property here.
49293:       primaryFrame->Properties().Delete(OffsetToFrameProperty());
49293:     }
49293:     RemoveStateBits(TEXT_IN_OFFSET_CACHE);
49293:   }
49293: }
49293: 
49293: void
36647: nsTextFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
49293:   ClearFrameOffsetCache();
49293: 
29809:   // We might want to clear NS_CREATE_FRAME_IF_NON_WHITESPACE or
29809:   // NS_REFRAME_IF_WHITESPACE on mContent here, since our parent frame
29809:   // type might be changing.  Not clear whether it's worth it.
 5728:   ClearTextRun();
    1:   if (mNextContinuation) {
    1:     mNextContinuation->SetPrevInFlow(nsnull);
    1:   }
    1:   // Let the base class destroy the frame
36647:   nsFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: class nsContinuingTextFrame : public nsTextFrame {
    1: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
32423: 
    1:   friend nsIFrame* NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1:   NS_IMETHOD Init(nsIContent*      aContent,
    1:                   nsIFrame*        aParent,
    1:                   nsIFrame*        aPrevInFlow);
    1: 
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
    1: 
    1:   virtual nsIFrame* GetPrevContinuation() const {
    1:     return mPrevContinuation;
    1:   }
    1:   NS_IMETHOD SetPrevContinuation(nsIFrame* aPrevContinuation) {
    1:     NS_ASSERTION (!aPrevContinuation || GetType() == aPrevContinuation->GetType(),
    1:                   "setting a prev continuation with incorrect type!");
    1:     NS_ASSERTION (!nsSplittableFrame::IsInPrevContinuationChain(aPrevContinuation, this),
    1:                   "creating a loop in continuation chain!");
    1:     mPrevContinuation = aPrevContinuation;
    1:     RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
    1:     return NS_OK;
    1:   }
    1:   virtual nsIFrame* GetPrevInFlowVirtual() const { return GetPrevInFlow(); }
    1:   nsIFrame* GetPrevInFlow() const {
    1:     return (GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? mPrevContinuation : nsnull;
    1:   }
    1:   NS_IMETHOD SetPrevInFlow(nsIFrame* aPrevInFlow) {
    1:     NS_ASSERTION (!aPrevInFlow || GetType() == aPrevInFlow->GetType(),
    1:                   "setting a prev in flow with incorrect type!");
    1:     NS_ASSERTION (!nsSplittableFrame::IsInPrevContinuationChain(aPrevInFlow, this),
    1:                   "creating a loop in continuation chain!");
    1:     mPrevContinuation = aPrevInFlow;
    1:     AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
    1:     return NS_OK;
    1:   }
    1:   virtual nsIFrame* GetFirstInFlow() const;
    1:   virtual nsIFrame* GetFirstContinuation() const;
    1: 
    1:   virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                  InlineMinWidthData *aData);
    1:   virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                   InlinePrefWidthData *aData);
    1:   
 4261:   virtual nsresult GetRenderedText(nsAString* aString = nsnull,
 4261:                                    gfxSkipChars* aSkipChars = nsnull,
 4261:                                    gfxSkipCharsIterator* aSkipIter = nsnull,
 4261:                                    PRUint32 aSkippedStartOffset = 0,
 4261:                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX)
 4261:   { return NS_ERROR_NOT_IMPLEMENTED; } // Call on a primary text frame only
 4261: 
    1: protected:
    1:   nsContinuingTextFrame(nsStyleContext* aContext) : nsTextFrame(aContext) {}
    1:   nsIFrame* mPrevContinuation;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsContinuingTextFrame::Init(nsIContent* aContent,
    1:                             nsIFrame*   aParent,
    1:                             nsIFrame*   aPrevInFlow)
    1: {
    1:   NS_ASSERTION(aPrevInFlow, "Must be a continuation!");
    1:   // NOTE: bypassing nsTextFrame::Init!!!
26295:   nsresult rv = nsFrame::Init(aContent, aParent, aPrevInFlow);
    1: 
 9810: #ifdef IBMBIDI
 9810:   nsTextFrame* nextContinuation =
 9810:     static_cast<nsTextFrame*>(aPrevInFlow->GetNextContinuation());
 9810: #endif // IBMBIDI
    1:   // Hook the frame into the flow
 4104:   SetPrevInFlow(aPrevInFlow);
 4104:   aPrevInFlow->SetNextInFlow(this);
 3233:   nsTextFrame* prev = static_cast<nsTextFrame*>(aPrevInFlow);
 4678:   mContentOffset = prev->GetContentOffset() + prev->GetContentLengthHint();
35581:   NS_ASSERTION(mContentOffset < PRInt32(aContent->GetText()->GetLength()),
 9001:                "Creating ContinuingTextFrame, but there is no more content");
 4678:   if (prev->GetStyleContext() != GetStyleContext()) {
 4678:     // We're taking part of prev's text, and its style may be different
 4678:     // so clear its textrun which may no longer be valid (and don't set ours)
 4678:     prev->ClearTextRun();
 4678:   } else {
    1:     mTextRun = prev->GetTextRun();
 4678:   }
    1: #ifdef IBMBIDI
 4104:   if (aPrevInFlow->GetStateBits() & NS_FRAME_IS_BIDI) {
39965:     FramePropertyTable *propTable = PresContext()->PropertyTable();
39965:     // Get all the properties from the prev-in-flow first to take
39965:     // advantage of the propTable's cache and simplify the assertion below
39965:     void* embeddingLevel = propTable->Get(aPrevInFlow, EmbeddingLevelProperty());
39965:     void* baseLevel = propTable->Get(aPrevInFlow, BaseLevelProperty());
39965:     propTable->Set(this, EmbeddingLevelProperty(), embeddingLevel);
39965:     propTable->Set(this, BaseLevelProperty(), baseLevel);
39965: 
    1:     if (nextContinuation) {
    1:       SetNextContinuation(nextContinuation);
    1:       nextContinuation->SetPrevContinuation(this);
 9810:       // Adjust next-continuations' content offset as needed.
 9810:       while (nextContinuation &&
 9810:              nextContinuation->GetContentOffset() < mContentOffset) {
 9810:         NS_ASSERTION(
39965:           embeddingLevel == propTable->Get(nextContinuation, EmbeddingLevelProperty()) &&
42116:           baseLevel == propTable->Get(nextContinuation, BaseLevelProperty()),
 9810:           "stealing text from different type of BIDI continuation");
 9810:         nextContinuation->mContentOffset = mContentOffset;
 9810:         nextContinuation = static_cast<nsTextFrame*>(nextContinuation->GetNextContinuation());
 9810:       }
    1:     }
    1:     mState |= NS_FRAME_IS_BIDI;
    1:   } // prev frame is bidi
    1: #endif // IBMBIDI
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
36647: nsContinuingTextFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
49293:   ClearFrameOffsetCache();
49293: 
22875:   // The text associated with this frame will become associated with our
22875:   // prev-continuation. If that means the text has changed style, then
22875:   // we need to wipe out the text run for the text.
22875:   // Note that mPrevContinuation can be null if we're destroying the whole
22875:   // frame chain from the start to the end.
22875:   // If this frame is mentioned in the userData for a textrun (say
22875:   // because there's a direction change at the start of this frame), then
22875:   // we have to clear the textrun because we're going away and the
22875:   // textrun had better not keep a dangling reference to us.
22875:   if ((GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA) ||
22875:       !mPrevContinuation ||
22875:       mPrevContinuation->GetStyleContext() != GetStyleContext()) {
 5728:     ClearTextRun();
27927:     // Clear the previous continuation's text run also, so that it can rebuild
27927:     // the text run to include our text.
27927:     if (mPrevContinuation) {
27927:       (static_cast<nsTextFrame*>(mPrevContinuation))->ClearTextRun();
27927:     }
22875:   }
    1:   nsSplittableFrame::RemoveFromFlow(this);
    1:   // Let the base class destroy the frame
36647:   nsFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: nsIFrame*
    1: nsContinuingTextFrame::GetFirstInFlow() const
    1: {
    1:   // Can't cast to |nsContinuingTextFrame*| because the first one isn't.
    1:   nsIFrame *firstInFlow,
 3233:            *previous = const_cast<nsIFrame*>
 3233:                                  (static_cast<const nsIFrame*>(this));
    1:   do {
    1:     firstInFlow = previous;
    1:     previous = firstInFlow->GetPrevInFlow();
    1:   } while (previous);
    1:   return firstInFlow;
    1: }
    1: 
    1: nsIFrame*
    1: nsContinuingTextFrame::GetFirstContinuation() const
    1: {
    1:   // Can't cast to |nsContinuingTextFrame*| because the first one isn't.
    1:   nsIFrame *firstContinuation,
 3233:   *previous = const_cast<nsIFrame*>
 3233:                         (static_cast<const nsIFrame*>(mPrevContinuation));
14508: 
14508:   NS_ASSERTION(previous, "How can an nsContinuingTextFrame be the first continuation?");
14508: 
    1:   do {
    1:     firstContinuation = previous;
    1:     previous = firstContinuation->GetPrevContinuation();
    1:   } while (previous);
    1:   return firstContinuation;
    1: }
    1: 
    1: // XXX Do we want to do all the work for the first-in-flow or do the
    1: // work for each part?  (Be careful of first-letter / first-line, though,
    1: // especially first-line!)  Doing all the work on the first-in-flow has
    1: // the advantage of avoiding the potential for incremental reflow bugs,
    1: // but depends on our maintining the frame tree in reasonable ways even
    1: // for edge cases (block-within-inline splits, nextBidi, etc.)
    1: 
    1: // XXX We really need to make :first-letter happen during frame
    1: // construction.
    1: 
    1: // Needed for text frames in XUL.
    1: /* virtual */ nscoord
    1: nsTextFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   return nsLayoutUtils::MinWidthFromInline(this, aRenderingContext);
    1: }
    1: 
    1: // Needed for text frames in XUL.
    1: /* virtual */ nscoord
    1: nsTextFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   return nsLayoutUtils::PrefWidthFromInline(this, aRenderingContext);
    1: }
    1: 
    1: /* virtual */ void
    1: nsContinuingTextFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                          InlineMinWidthData *aData)
    1: {
    1:   // Do nothing, since the first-in-flow accounts for everything.
    1:   return;
    1: }
    1: 
    1: /* virtual */ void
    1: nsContinuingTextFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                           InlinePrefWidthData *aData)
    1: {
    1:   // Do nothing, since the first-in-flow accounts for everything.
    1:   return;
    1: }
    1: 
    1: static void 
    1: DestroySelectionDetails(SelectionDetails* aDetails)
    1: {
    1:   while (aDetails) {
    1:     SelectionDetails* next = aDetails->mNext;
    1:     delete aDetails;
    1:     aDetails = next;
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #if defined(DEBUG_rbs) || defined(DEBUG_bzbarsky)
    1: static void
    1: VerifyNotDirty(nsFrameState state)
    1: {
    1:   PRBool isZero = state & NS_FRAME_FIRST_REFLOW;
    1:   PRBool isDirty = state & NS_FRAME_IS_DIRTY;
    1:   if (!isZero && isDirty)
    1:     NS_WARNING("internal offsets may be out-of-sync");
    1: }
    1: #define DEBUG_VERIFY_NOT_DIRTY(state) \
    1: VerifyNotDirty(state)
    1: #else
    1: #define DEBUG_VERIFY_NOT_DIRTY(state)
    1: #endif
    1: 
    1: nsIFrame*
    1: NS_NewTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTextFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTextFrame)
32423: 
    1: nsIFrame*
    1: NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsContinuingTextFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsContinuingTextFrame)
32423: 
    1: nsTextFrame::~nsTextFrame()
    1: {
35581:   if (0 != (mState & TEXT_BLINK_ON))
    1:   {
    1:     nsBlinkTimer::RemoveBlinkFrame(this);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextFrame::GetCursor(const nsPoint& aPoint,
    1:                        nsIFrame::Cursor& aCursor)
    1: {
    1:   FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);  
    1:   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
    1:     aCursor.mCursor = NS_STYLE_CURSOR_TEXT;
    1: 
    1:     // If tabindex >= 0, use default cursor to indicate it's not selectable
    1:     nsIFrame *ancestorFrame = this;
    1:     while ((ancestorFrame = ancestorFrame->GetParent()) != nsnull) {
    1:       nsIContent *ancestorContent = ancestorFrame->GetContent();
    1:       if (ancestorContent && ancestorContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
    1:         nsAutoString tabIndexStr;
    1:         ancestorContent->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
    1:         if (!tabIndexStr.IsEmpty()) {
    1:           PRInt32 rv, tabIndexVal = tabIndexStr.ToInteger(&rv);
    1:           if (NS_SUCCEEDED(rv) && tabIndexVal >= 0) {
    1:             aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame*
    1: nsTextFrame::GetLastInFlow() const
    1: {
 3233:   nsTextFrame* lastInFlow = const_cast<nsTextFrame*>(this);
    1:   while (lastInFlow->GetNextInFlow())  {
 3233:     lastInFlow = static_cast<nsTextFrame*>(lastInFlow->GetNextInFlow());
    1:   }
    1:   NS_POSTCONDITION(lastInFlow, "illegal state in flow chain.");
    1:   return lastInFlow;
    1: }
    1: nsIFrame*
    1: nsTextFrame::GetLastContinuation() const
    1: {
 3233:   nsTextFrame* lastInFlow = const_cast<nsTextFrame*>(this);
    1:   while (lastInFlow->mNextContinuation)  {
 3233:     lastInFlow = static_cast<nsTextFrame*>(lastInFlow->mNextContinuation);
    1:   }
    1:   NS_POSTCONDITION(lastInFlow, "illegal state in continuation chain.");
    1:   return lastInFlow;
    1: }
    1: 
    1: void
    1: nsTextFrame::ClearTextRun()
    1: {
    1:   // save textrun because ClearAllTextRunReferences will clear ours
    1:   gfxTextRun* textRun = mTextRun;
    1:   
 5728:   if (!textRun)
    1:     return;
    1: 
 1328:   UnhookTextRunFromFrames(textRun);
 2319:   // see comments in BuildTextRunForFrames...
 2319: //  if (textRun->GetFlags() & gfxFontGroup::TEXT_IS_PERSISTENT) {
 2319: //    NS_ERROR("Shouldn't reach here for now...");
 2319: //    // the textrun's text may be referencing a DOM node that has changed,
 2319: //    // so we'd better kill this textrun now.
 2319: //    if (textRun->GetExpirationState()->IsTracked()) {
 2319: //      gTextRuns->RemoveFromCache(textRun);
 2319: //    }
 2319: //    delete textRun;
 2319: //    return;
 2319: //  }
 2319: 
 3118:   if (!(textRun->GetFlags() & gfxTextRunWordCache::TEXT_IN_CACHE)) {
 2319:     // Remove it now because it's not doing anything useful
 1328:     gTextRuns->RemoveFromCache(textRun);
 1328:     delete textRun;
 1328:   }
    1: }
    1: 
    1: NS_IMETHODIMP
31131: nsTextFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
    1: {
36903:   mContent->DeleteProperty(nsGkAtoms::newline);
36903: 
34012:   // Find the first frame whose text has changed. Frames that are entirely
34012:   // before the text change are completely unaffected.
34012:   nsTextFrame* next;
34012:   nsTextFrame* textFrame = this;
34012:   while (PR_TRUE) {
34012:     next = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
34012:     if (!next || next->GetContentOffset() > PRInt32(aInfo->mChangeStart))
34012:       break;
34012:     textFrame = next;
34012:   }
34012: 
34012:   PRInt32 endOfChangedText = aInfo->mChangeStart + aInfo->mReplaceLength;
34012:   nsTextFrame* lastDirtiedFrame = nsnull;
34012: 
34012:   nsIPresShell* shell = PresContext()->GetPresShell();
34012:   do {
34012:     // textFrame contained deleted text (or the insertion point,
34012:     // if this was a pure insertion).
34012:     textFrame->mState &= ~TEXT_WHITESPACE_FLAGS;
34012:     textFrame->ClearTextRun();
34012:     if (!lastDirtiedFrame ||
34012:         lastDirtiedFrame->GetParent() != textFrame->GetParent()) {
34012:       // Ask the parent frame to reflow me.
34012:       shell->FrameNeedsReflow(textFrame, nsIPresShell::eStyleChange,
34012:                               NS_FRAME_IS_DIRTY);
34012:       lastDirtiedFrame = textFrame;
31144:     } else {
34012:       // if the parent is a block, we're cheating here because we should
34012:       // be marking our line dirty, but we're not. nsTextFrame::SetLength
34012:       // will do that when it gets called during reflow.
34012:       textFrame->AddStateBits(NS_FRAME_IS_DIRTY);
34012:     }
34012: 
34012:     // Below, frames that start after the deleted text will be adjusted so that
34012:     // their offsets move with the trailing unchanged text. If this change
34012:     // deletes more text than it inserts, those frame offsets will decrease.
34012:     // We need to maintain the invariant that mContentOffset is non-decreasing
34012:     // along the continuation chain. So we need to ensure that frames that
34012:     // started in the deleted text are all still starting before the
34012:     // unchanged text.
34012:     if (textFrame->mContentOffset > endOfChangedText) {
34012:       textFrame->mContentOffset = endOfChangedText;
34012:     }
34012: 
31144:     textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
34012:   } while (textFrame && textFrame->GetContentOffset() < PRInt32(aInfo->mChangeEnd));
34012: 
34012:   // This is how much the length of the string changed by --- i.e.,
34012:   // how much the trailing unchanged text moved.
34012:   PRInt32 sizeChange =
34012:     aInfo->mChangeStart + aInfo->mReplaceLength - aInfo->mChangeEnd;
34012: 
34012:   if (sizeChange) {
34012:     // Fix the offsets of the text frames that start in the trailing
34012:     // unchanged text.
34012:     while (textFrame) {
34012:       textFrame->mContentOffset += sizeChange;
34012:       // XXX we could rescue some text runs by adjusting their user data
34012:       // to reflect the change in DOM offsets
34012:       textFrame->ClearTextRun();
34012:       textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
34012:     }
34012:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
20441: /* virtual */ void
20836: nsTextFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
20836: {
20836:   nsFrame::DidSetStyleContext(aOldStyleContext);
    1:   ClearTextRun();
    1: } 
    1: 
    1: class nsDisplayText : public nsDisplayItem {
    1: public:
51260:   nsDisplayText(nsDisplayListBuilder* aBuilder, nsTextFrame* aFrame) :
51260:     nsDisplayItem(aBuilder, aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayText);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayText() {
    1:     MOZ_COUNT_DTOR(nsDisplayText);
    1:   }
    1: #endif
    1: 
    1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
55040:     return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
    1:   }
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
51261:     if (nsRect(ToReferenceFrame(), mFrame->GetSize()).Intersects(aRect)) {
40570:       aOutFrames->AppendElement(mFrame);
40570:     }
 6247:   }
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
33368:                      nsIRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("Text", TYPE_TEXT)
55291: 
55291:   virtual PRBool HasText() { return PR_TRUE; }
    1: };
    1: 
    1: void
    1: nsDisplayText::Paint(nsDisplayListBuilder* aBuilder,
33368:                      nsIRenderingContext* aCtx) {
33368:   // Add 1 pixel of dirty area around mVisibleRect to allow us to paint
33368:   // antialiased pixels beyond the measured text extents.
33368:   // This is temporary until we do this in the actual calculation of text extents.
33368:   nsRect extraVisible = mVisibleRect;
33368:   nscoord appUnitsPerDevPixel = mFrame->PresContext()->AppUnitsPerDevPixel();
33368:   extraVisible.Inflate(appUnitsPerDevPixel, appUnitsPerDevPixel);
 3233:   static_cast<nsTextFrame*>(mFrame)->
51261:     PaintText(aCtx, ToReferenceFrame(), extraVisible);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1:   
    1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsTextFrame");
    1: 
35581:   if ((0 != (mState & TEXT_BLINK_ON)) && nsBlinkTimer::GetBlinkIsOff() &&
29529:       PresContext()->IsDynamic() && !aBuilder->IsForEventDelivery())
    1:     return NS_OK;
    1:     
51260:   return aLists.Content()->AppendNewToTop(
51260:       new (aBuilder) nsDisplayText(aBuilder, this));
    1: }
    1: 
    8: static nsIFrame*
    8: GetGeneratedContentOwner(nsIFrame* aFrame, PRBool* aIsBefore)
    1: {
    8:   *aIsBefore = PR_FALSE;
    8:   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT)) {
34387:     if (aFrame->GetStyleContext()->GetPseudo() == nsCSSPseudoElements::before) {
    8:       *aIsBefore = PR_TRUE;
    8:     }
    8:     aFrame = aFrame->GetParent();
    8:   }
    8:   return aFrame;
    1: }
    1: 
    1: SelectionDetails*
    1: nsTextFrame::GetSelectionDetails()
    1: {
 8295:   const nsFrameSelection* frameSelection = GetConstFrameSelection();
    8:   if (!(GetStateBits() & NS_FRAME_GENERATED_CONTENT)) {
    8:     SelectionDetails* details =
 8295:       frameSelection->LookUpSelection(mContent, GetContentOffset(),
 4678:                                       GetContentLength(), PR_FALSE);
    8:     SelectionDetails* sd;
    8:     for (sd = details; sd; sd = sd->mNext) {
    8:       sd->mStart += mContentOffset;
    8:       sd->mEnd += mContentOffset;
    8:     }
    8:     return details;
    8:   }
    8: 
    8:   // Check if the beginning or end of the element is selected, depending on
    8:   // whether we're :before content or :after content.
    8:   PRBool isBefore;
    8:   nsIFrame* owner = GetGeneratedContentOwner(this, &isBefore);
    8:   if (!owner || !owner->GetContent())
    8:     return nsnull;
    8: 
    8:   SelectionDetails* details =
 8295:     frameSelection->LookUpSelection(owner->GetContent(),
    8:         isBefore ? 0 : owner->GetContent()->GetChildCount(), 0, PR_FALSE);
    8:   SelectionDetails* sd;
    8:   for (sd = details; sd; sd = sd->mNext) {
    8:     // The entire text is selected!
 3118:     sd->mStart = GetContentOffset();
 3118:     sd->mEnd = GetContentEnd();
    8:   }
    8:   return details;
    1: }
    1: 
    1: static void
    1: FillClippedRect(gfxContext* aCtx, nsPresContext* aPresContext,
    1:                 nscolor aColor, const gfxRect& aDirtyRect, const gfxRect& aRect)
    1: {
    1:   gfxRect r = aRect.Intersect(aDirtyRect);
    1:   // For now, we need to put this in pixel coordinates
 5147:   PRInt32 app = aPresContext->AppUnitsPerDevPixel();
    1:   aCtx->NewPath();
    1:   // pixel-snap
 5147:   aCtx->Rectangle(gfxRect(r.X() / app, r.Y() / app,
 5147:                           r.Width() / app, r.Height() / app), PR_TRUE);
    1:   aCtx->SetColor(gfxRGBA(aColor));
    1:   aCtx->Fill();
    1: }
    1: 
11780: nsTextFrame::TextDecorations
11780: nsTextFrame::GetTextDecorations(nsPresContext* aPresContext)
11780: {
11780:   TextDecorations decorations;
11780: 
    1:   // Quirks mode text decoration are rendered by children; see bug 1777
    1:   // In non-quirks mode, nsHTMLContainer::Paint and nsBlockFrame::Paint
    1:   // does the painting of text decorations.
11780:   if (eCompatibility_NavQuirks != aPresContext->CompatibilityMode())
11780:     return decorations;
    1: 
    1:   PRBool useOverride = PR_FALSE;
    1:   nscolor overrideColor;
    1: 
    1:   // A mask of all possible decorations.
    1:   PRUint8 decorMask = NS_STYLE_TEXT_DECORATION_UNDERLINE | 
    1:                       NS_STYLE_TEXT_DECORATION_OVERLINE |
    1:                       NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
11780: 
11780:   for (nsStyleContext* context = GetStyleContext();
11780:        decorMask && context && context->HasTextDecorations();
11780:        context = context->GetParent()) {
    1:     const nsStyleTextReset* styleText = context->GetStyleTextReset();
    1:     if (!useOverride && 
    1:         (NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL & styleText->mTextDecoration)) {
    1:       // This handles the <a href="blah.html"><font color="green">La 
    1:       // la la</font></a> case. The link underline should be green.
    1:       useOverride = PR_TRUE;
40176:       overrideColor = context->GetVisitedDependentColor(eCSSProperty_color);
    1:     }
    1: 
    1:     PRUint8 useDecorations = decorMask & styleText->mTextDecoration;
    1:     if (useDecorations) {// a decoration defined here
40176:       nscolor color = context->GetVisitedDependentColor(eCSSProperty_color);
    1: 
    1:       if (NS_STYLE_TEXT_DECORATION_UNDERLINE & useDecorations) {
11780:         decorations.mUnderColor = useOverride ? overrideColor : color;
    1:         decorMask &= ~NS_STYLE_TEXT_DECORATION_UNDERLINE;
11780:         decorations.mDecorations |= NS_STYLE_TEXT_DECORATION_UNDERLINE;
    1:       }
    1:       if (NS_STYLE_TEXT_DECORATION_OVERLINE & useDecorations) {
11780:         decorations.mOverColor = useOverride ? overrideColor : color;
    1:         decorMask &= ~NS_STYLE_TEXT_DECORATION_OVERLINE;
11780:         decorations.mDecorations |= NS_STYLE_TEXT_DECORATION_OVERLINE;
    1:       }
    1:       if (NS_STYLE_TEXT_DECORATION_LINE_THROUGH & useDecorations) {
11780:         decorations.mStrikeColor = useOverride ? overrideColor : color;
    1:         decorMask &= ~NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
11780:         decorations.mDecorations |= NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
11780:       }
11780:     }
11780:   }
11780: 
11780:   return decorations;
11780: }
11780: 
11780: void
13714: nsTextFrame::UnionTextDecorationOverflow(nsPresContext* aPresContext,
14210:                                          PropertyProvider& aProvider,
55028:                                          nsRect* aVisualOverflowRect)
11780: {
15339:   // Text-shadow overflows
55028:   nsRect shadowRect =
55028:     nsLayoutUtils::GetTextShadowRectsUnion(*aVisualOverflowRect, this);
55028:   aVisualOverflowRect->UnionRect(*aVisualOverflowRect, shadowRect);
15339: 
14210:   if (IsFloatingFirstLetterChild()) {
14210:     // The underline/overline drawable area must be contained in the overflow
14210:     // rect when this is in floating first letter frame at *both* modes.
14210:     nscoord fontAscent, fontHeight;
14210:     nsIFontMetrics* fm = aProvider.GetFontMetrics();
14210:     fm->GetMaxAscent(fontAscent);
14210:     fm->GetMaxHeight(fontHeight);
14210:     nsRect fontRect(0, mAscent - fontAscent, GetSize().width, fontHeight);
55028:     aVisualOverflowRect->UnionRect(*aVisualOverflowRect, fontRect);
14210:   }
14210: 
13714:   // When this frame is not selected, the text-decoration area must be in
13714:   // frame bounds.
26883:   nsRect decorationRect;
14533:   if (!(GetStateBits() & NS_FRAME_SELECTED_CONTENT) ||
55028:       !CombineSelectionUnderlineRect(aPresContext, *aVisualOverflowRect))
13714:     return;
13714:   AddStateBits(TEXT_SELECTION_UNDERLINE_OVERFLOWED);
11780: }
11780: 
11780: void 
11780: nsTextFrame::PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,
11780:                                   const gfxPoint& aFramePt,
11780:                                   const gfxPoint& aTextBaselinePt,
11780:                                   nsTextPaintStyle& aTextPaintStyle,
15339:                                   PropertyProvider& aProvider,
19961:                                   const nscolor* aOverrideColor)
11780: {
11780:   TextDecorations decorations =
11780:     GetTextDecorations(aTextPaintStyle.PresContext());
11780:   if (!decorations.HasDecorationlines())
    1:     return;
    1: 
12989:   gfxFont* firstFont = aProvider.GetFontGroup()->GetFontAt(0);
12989:   if (!firstFont)
12989:     return; // OOM
12989:   const gfxFont::Metrics& fontMetrics = firstFont->GetMetrics();
 6027:   gfxFloat app = aTextPaintStyle.PresContext()->AppUnitsPerDevPixel();
 4302: 
 4302:   // XXX aFramePt is in AppUnits, shouldn't it be nsFloatPoint?
 5601:   gfxPoint pt(aFramePt.x / app, (aTextBaselinePt.y - mAscent) / app);
 6121:   gfxSize size(GetRect().width / app, 0);
 6027:   gfxFloat ascent = gfxFloat(mAscent) / app;
    1: 
15339:   nscolor lineColor;
11780:   if (decorations.HasOverline()) {
19961:     lineColor = aOverrideColor ? *aOverrideColor : decorations.mOverColor;
 4302:     size.height = fontMetrics.underlineSize;
 4302:     nsCSSRendering::PaintDecorationLine(
15339:       aCtx, lineColor, pt, size, ascent, fontMetrics.maxAscent,
26883:       NS_STYLE_TEXT_DECORATION_OVERLINE,
26883:       nsCSSRendering::DECORATION_STYLE_SOLID);
    1:   }
11780:   if (decorations.HasUnderline()) {
19961:     lineColor = aOverrideColor ? *aOverrideColor : decorations.mUnderColor;
 4302:     size.height = fontMetrics.underlineSize;
12989:     gfxFloat offset = aProvider.GetFontGroup()->GetUnderlineOffset();
 4302:     nsCSSRendering::PaintDecorationLine(
15339:       aCtx, lineColor, pt, size, ascent, offset,
26883:       NS_STYLE_TEXT_DECORATION_UNDERLINE,
26883:       nsCSSRendering::DECORATION_STYLE_SOLID);
    1:   }
11780:   if (decorations.HasStrikeout()) {
19961:     lineColor = aOverrideColor ? *aOverrideColor : decorations.mStrikeColor;
 4302:     size.height = fontMetrics.strikeoutSize;
 4302:     gfxFloat offset = fontMetrics.strikeoutOffset;
 4302:     nsCSSRendering::PaintDecorationLine(
15339:       aCtx, lineColor, pt, size, ascent, offset,
26883:       NS_STYLE_TEXT_DECORATION_LINE_THROUGH,
26883:       nsCSSRendering::DECORATION_STYLE_SOLID);
    1:   }
    1: }
    1: 
29850: static gfxFloat
29850: ComputeDescentLimitForSelectionUnderline(nsPresContext* aPresContext,
29850:                                          nsTextFrame* aFrame,
29850:                                          const gfxFont::Metrics& aFontMetrics)
29850: {
29850:   gfxFloat app = aPresContext->AppUnitsPerDevPixel();
29850:   nscoord lineHeightApp =
29850:     nsHTMLReflowState::CalcLineHeight(aFrame->GetStyleContext(), NS_AUTOHEIGHT);
29850:   gfxFloat lineHeight = gfxFloat(lineHeightApp) / app;
29850:   if (lineHeight <= aFontMetrics.maxHeight) {
29850:     return aFontMetrics.maxDescent;
29850:   }
29850:   return aFontMetrics.maxDescent + (lineHeight - aFontMetrics.maxHeight) / 2;
29850: }
29850: 
29850: 
    1: // Make sure this stays in sync with DrawSelectionDecorations below
    1: static const SelectionType SelectionTypesWithDecorations =
    1:   nsISelectionController::SELECTION_SPELLCHECK |
    1:   nsISelectionController::SELECTION_IME_RAWINPUT |
    1:   nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT |
    1:   nsISelectionController::SELECTION_IME_CONVERTEDTEXT |
    1:   nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT;
    1: 
27654: static PRUint8
27654: GetTextDecorationStyle(const nsTextRangeStyle &aRangeStyle)
27654: {
27654:   NS_PRECONDITION(aRangeStyle.IsLineStyleDefined(),
27654:                   "aRangeStyle.mLineStyle have to be defined");
27654:   switch (aRangeStyle.mLineStyle) {
27654:     case nsTextRangeStyle::LINESTYLE_NONE:
27654:       return nsCSSRendering::DECORATION_STYLE_NONE;
27654:     case nsTextRangeStyle::LINESTYLE_SOLID:
27654:       return nsCSSRendering::DECORATION_STYLE_SOLID;
27654:     case nsTextRangeStyle::LINESTYLE_DOTTED:
27654:       return nsCSSRendering::DECORATION_STYLE_DOTTED;
27654:     case nsTextRangeStyle::LINESTYLE_DASHED:
27654:       return nsCSSRendering::DECORATION_STYLE_DASHED;
27654:     case nsTextRangeStyle::LINESTYLE_DOUBLE:
27654:       return nsCSSRendering::DECORATION_STYLE_DOUBLE;
27654:     case nsTextRangeStyle::LINESTYLE_WAVY:
27654:       return nsCSSRendering::DECORATION_STYLE_WAVY;
27654:     default:
27654:       NS_WARNING("Requested underline style is not valid");
27654:       return nsCSSRendering::DECORATION_STYLE_SOLID;
27654:   }
27654: }
27654: 
31685: static gfxFloat
31685: ComputeSelectionUnderlineHeight(nsPresContext* aPresContext,
31685:                                 const gfxFont::Metrics& aFontMetrics,
31685:                                 SelectionType aSelectionType)
31685: {
31685:   switch (aSelectionType) {
31685:     case nsISelectionController::SELECTION_IME_RAWINPUT:
31685:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
31685:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
31685:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
31685:       return aFontMetrics.underlineSize;
31685:     case nsISelectionController::SELECTION_SPELLCHECK: {
31685:       // The thickness of the spellchecker underline shouldn't honor the font
31685:       // metrics.  It should be constant pixels value which is decided from the
31685:       // default font size.  Note that if the actual font size is smaller than
31685:       // the default font size, we should use the actual font size because the
31685:       // computed value from the default font size can be too thick for the
31685:       // current font size.
31685:       PRInt32 defaultFontSize =
31685:         aPresContext->AppUnitsToDevPixels(nsStyleFont(aPresContext).mFont.size);
32531:       gfxFloat fontSize = NS_MIN(gfxFloat(defaultFontSize),
31685:                                  aFontMetrics.emHeight);
32531:       fontSize = NS_MAX(fontSize, 1.0);
31685:       return NS_ceil(fontSize / 20);
31685:     }
31685:     default:
31685:       NS_WARNING("Requested underline style is not valid");
31685:       return aFontMetrics.underlineSize;
31685:   }
31685: }
31685: 
    1: /**
    1:  * This, plus SelectionTypesWithDecorations, encapsulates all knowledge about
    1:  * drawing text decoration for selections.
    1:  */
    1: static void DrawSelectionDecorations(gfxContext* aContext, SelectionType aType,
29850:     nsTextFrame* aFrame,
27654:     nsTextPaintStyle& aTextPaintStyle,
27654:     const nsTextRangeStyle &aRangeStyle,
27654:     const gfxPoint& aPt, gfxFloat aWidth,
13955:     gfxFloat aAscent, const gfxFont::Metrics& aFontMetrics)
 4302: {
26883:   gfxPoint pt(aPt);
31685:   gfxSize size(aWidth,
31685:                ComputeSelectionUnderlineHeight(aTextPaintStyle.PresContext(),
31685:                                                aFontMetrics, aType));
29850:   gfxFloat descentLimit =
29850:     ComputeDescentLimitForSelectionUnderline(aTextPaintStyle.PresContext(),
29850:                                              aFrame, aFontMetrics);
    1: 
27654:   float relativeSize;
27654:   PRUint8 style;
27654:   nscolor color;
27654:   PRInt32 index =
27654:     nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(aType);
27654:   PRBool weDefineSelectionUnderline =
27654:     aTextPaintStyle.GetSelectionUnderlineForPaint(index, &color,
27654:                                                   &relativeSize, &style);
27654: 
    1:   switch (aType) {
26883:     case nsISelectionController::SELECTION_IME_RAWINPUT:
26883:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
26883:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
27654:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT: {
26883:       // IME decoration lines should not be drawn on the both ends, i.e., we
26883:       // need to cut both edges of the decoration lines.  Because same style
26883:       // IME selections can adjoin, but the users need to be able to know
26883:       // where are the boundaries of the selections.
26883:       //
26883:       //  X: underline
26883:       //
26883:       //     IME selection #1        IME selection #2      IME selection #3
26883:       //  |                     |                      |                    
26883:       //  | XXXXXXXXXXXXXXXXXXX | XXXXXXXXXXXXXXXXXXXX | XXXXXXXXXXXXXXXXXXX
26883:       //  +---------------------+----------------------+--------------------
26883:       //   ^                   ^ ^                    ^ ^
26883:       //  gap                  gap                    gap
26883:       pt.x += 1.0;
26883:       size.width -= 2.0;
27654:       if (aRangeStyle.IsDefined()) {
27654:         // If IME defines the style, that should override our definition.
27654:         if (aRangeStyle.IsLineStyleDefined()) {
27654:           if (aRangeStyle.mLineStyle == nsTextRangeStyle::LINESTYLE_NONE) {
27654:             return;
27654:           }
27654:           style = GetTextDecorationStyle(aRangeStyle);
27654:           relativeSize = aRangeStyle.mIsBoldLine ? 2.0f : 1.0f;
27654:         } else if (!weDefineSelectionUnderline) {
27654:           // There is no underline style definition.
27654:           return;
27654:         }
27654:         if (aRangeStyle.IsUnderlineColorDefined()) {
27654:           color = aRangeStyle.mUnderlineColor;
27654:         } else if (aRangeStyle.IsForegroundColorDefined()) {
27654:           color = aRangeStyle.mForegroundColor;
27654:         } else {
27654:           NS_ASSERTION(!aRangeStyle.IsBackgroundColorDefined(),
27654:                        "Only the background color is defined");
27654:           color = aTextPaintStyle.GetTextColor();
27654:         }
27654:       } else if (!weDefineSelectionUnderline) {
27654:         // IME doesn't specify the selection style and we don't define selection
27654:         // underline.
27654:         return;
27654:       }
27654:       break;
27654:     }
27654:     case nsISelectionController::SELECTION_SPELLCHECK:
27654:       if (!weDefineSelectionUnderline)
27654:         return;
27654:       break;
27654:     default:
27654:       NS_WARNING("Requested selection decorations when there aren't any");
27654:       return;
27654:   }
26883:   size.height *= relativeSize;
 4302:   nsCSSRendering::PaintDecorationLine(
26883:     aContext, color, pt, size, aAscent, aFontMetrics.underlineOffset,
26988:     NS_STYLE_TEXT_DECORATION_UNDERLINE, style, descentLimit);
26883: }
    1: 
    1: /**
    1:  * This function encapsulates all knowledge of how selections affect foreground
    1:  * and background colors.
    1:  * @return true if the selection affects colors, false otherwise
    1:  * @param aForeground the foreground color to use
    1:  * @param aBackground the background color to use, or RGBA(0,0,0,0) if no
    1:  * background should be painted
    1:  */
27654: static PRBool GetSelectionTextColors(SelectionType aType,
27654:                                      nsTextPaintStyle& aTextPaintStyle,
27654:                                      const nsTextRangeStyle &aRangeStyle,
    1:                                      nscolor* aForeground, nscolor* aBackground)
    1: {
    1:   switch (aType) {
    1:     case nsISelectionController::SELECTION_NORMAL:
    1:       return aTextPaintStyle.GetSelectionColors(aForeground, aBackground);
16313:     case nsISelectionController::SELECTION_FIND:
16313:       aTextPaintStyle.GetHighlightColors(aForeground, aBackground);
16313:       return PR_TRUE;
    1:     case nsISelectionController::SELECTION_IME_RAWINPUT:
    1:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
    1:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
    1:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
27654:       if (aRangeStyle.IsDefined()) {
27654:         *aForeground = aTextPaintStyle.GetTextColor();
27654:         *aBackground = NS_RGBA(0,0,0,0);
27654:         if (!aRangeStyle.IsForegroundColorDefined() &&
27654:             !aRangeStyle.IsBackgroundColorDefined()) {
27654:           return PR_FALSE;
27654:         }
27654:         if (aRangeStyle.IsForegroundColorDefined()) {
27654:           *aForeground = aRangeStyle.mForegroundColor;
27654:         }
27654:         if (aRangeStyle.IsBackgroundColorDefined()) {
27654:           *aBackground = aRangeStyle.mBackgroundColor;
27654:         }
27654:         return PR_TRUE;
27654:       }
26883:       aTextPaintStyle.GetIMESelectionColors(
26883:         nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(aType),
    1:         aForeground, aBackground);
    1:       return PR_TRUE;
    1:     default:
    1:       *aForeground = aTextPaintStyle.GetTextColor();
    1:       *aBackground = NS_RGBA(0,0,0,0);
    1:       return PR_FALSE;
    1:   }
    1: }
    1: 
    1: /**
    1:  * This class lets us iterate over chunks of text in a uniform selection state,
    1:  * observing cluster boundaries, in content order, maintaining the current
    1:  * x-offset as we go, and telling whether the text chunk has a hyphen after
    1:  * it or not. The caller is responsible for actually computing the advance
    1:  * width of each chunk.
    1:  */
    1: class SelectionIterator {
    1: public:
    1:   /**
27654:    * aStart and aLength are in the original string. aSelectionDetails is
    1:    * according to the original string.
    1:    */
27654:   SelectionIterator(SelectionDetails** aSelectionDetails,
27654:                     PRInt32 aStart, PRInt32 aLength,
27654:                     PropertyProvider& aProvider, gfxTextRun* aTextRun);
    1: 
    1:   /**
    1:    * Returns the next segment of uniformly selected (or not) text.
    1:    * @param aXOffset the offset from the origin of the frame to the start
    1:    * of the text (the left baseline origin for LTR, the right baseline origin
    1:    * for RTL)
    1:    * @param aOffset the transformed string offset of the text for this segment
    1:    * @param aLength the transformed string length of the text for this segment
    1:    * @param aHyphenWidth if a hyphen is to be rendered after the text, the
    1:    * width of the hyphen, otherwise zero
    1:    * @param aType the selection type for this segment
27654:    * @param aStyle the selection style for this segment
    1:    * @return false if there are no more segments
    1:    */
    1:   PRBool GetNextSegment(gfxFloat* aXOffset, PRUint32* aOffset, PRUint32* aLength,
27654:                         gfxFloat* aHyphenWidth, SelectionType* aType,
27654:                         nsTextRangeStyle* aStyle);
    1:   void UpdateWithAdvance(gfxFloat aAdvance) {
    1:     mXOffset += aAdvance*mTextRun->GetDirection();
    1:   }
    1: 
    1: private:
27654:   SelectionDetails**      mSelectionDetails;
    1:   PropertyProvider&       mProvider;
    1:   gfxTextRun*             mTextRun;
    1:   gfxSkipCharsIterator    mIterator;
    1:   PRInt32                 mOriginalStart;
    1:   PRInt32                 mOriginalEnd;
    1:   gfxFloat                mXOffset;
    1: };
    1: 
27654: SelectionIterator::SelectionIterator(SelectionDetails** aSelectionDetails,
    1:     PRInt32 aStart, PRInt32 aLength, PropertyProvider& aProvider,
    1:     gfxTextRun* aTextRun)
27654:   : mSelectionDetails(aSelectionDetails), mProvider(aProvider),
    1:     mTextRun(aTextRun), mIterator(aProvider.GetStart()),
    1:     mOriginalStart(aStart), mOriginalEnd(aStart + aLength),
    1:     mXOffset(mTextRun->IsRightToLeft() ? aProvider.GetFrame()->GetSize().width : 0)
    1: {
    1:   mIterator.SetOriginalOffset(aStart);
    1: }
    1: 
    1: PRBool SelectionIterator::GetNextSegment(gfxFloat* aXOffset,
27654:     PRUint32* aOffset, PRUint32* aLength, gfxFloat* aHyphenWidth,
27654:     SelectionType* aType, nsTextRangeStyle* aStyle)
    1: {
    1:   if (mIterator.GetOriginalOffset() >= mOriginalEnd)
    1:     return PR_FALSE;
    1:   
    1:   // save offset into transformed string now
    1:   PRUint32 runOffset = mIterator.GetSkippedOffset();
    1:   
    1:   PRInt32 index = mIterator.GetOriginalOffset() - mOriginalStart;
27654:   SelectionDetails* sdptr = mSelectionDetails[index];
27654:   SelectionType type =
27654:     sdptr ? sdptr->mType : nsISelectionController::SELECTION_NONE;
27654:   nsTextRangeStyle style;
27654:   if (sdptr) {
27654:     style = sdptr->mTextRangeStyle;
27654:   }
 1380:   for (++index; mOriginalStart + index < mOriginalEnd; ++index) {
27654:     if (sdptr != mSelectionDetails[index])
    1:       break;
 1380:   }
    1:   mIterator.SetOriginalOffset(index + mOriginalStart);
    1: 
    1:   // Advance to the next cluster boundary
    1:   while (mIterator.GetOriginalOffset() < mOriginalEnd &&
    1:          !mIterator.IsOriginalCharSkipped() &&
    8:          !mTextRun->IsClusterStart(mIterator.GetSkippedOffset())) {
    1:     mIterator.AdvanceOriginal(1);
    1:   }
    1: 
  202:   PRBool haveHyphenBreak =
  202:     (mProvider.GetFrame()->GetStateBits() & TEXT_HYPHEN_BREAK) != 0;
    1:   *aOffset = runOffset;
    1:   *aLength = mIterator.GetSkippedOffset() - runOffset;
    1:   *aXOffset = mXOffset;
    1:   *aHyphenWidth = 0;
  202:   if (mIterator.GetOriginalOffset() == mOriginalEnd && haveHyphenBreak) {
    1:     *aHyphenWidth = mProvider.GetHyphenWidth();
    1:   }
    1:   *aType = type;
27654:   *aStyle = style;
    1:   return PR_TRUE;
    1: }
    1: 
16706: static void
16706: AddHyphenToMetrics(nsTextFrame* aTextFrame, gfxTextRun* aBaseTextRun,
25417:                    gfxTextRun::Metrics* aMetrics,
25417:                    gfxFont::BoundingBoxType aBoundingBoxType,
16706:                    gfxContext* aContext)
16706: {
16706:   // Fix up metrics to include hyphen
16706:   gfxTextRunCache::AutoTextRun hyphenTextRun(
16706:     GetHyphenTextRun(aBaseTextRun, aContext, aTextFrame));
16706:   if (!hyphenTextRun.get())
16706:     return;
16706: 
16706:   gfxTextRun::Metrics hyphenMetrics =
25417:     hyphenTextRun->MeasureText(0, hyphenTextRun->GetLength(),
25417:                                aBoundingBoxType, aContext, nsnull);
16706:   aMetrics->CombineWith(hyphenMetrics, aBaseTextRun->IsRightToLeft());
16706: }
16706: 
15339: void
15339: nsTextFrame::PaintOneShadow(PRUint32 aOffset, PRUint32 aLength,
15699:                             nsCSSShadowItem* aShadowDetails,
32863:                             PropertyProvider* aProvider, const nsRect& aDirtyRect,
15339:                             const gfxPoint& aFramePt, const gfxPoint& aTextBaselinePt,
15339:                             gfxContext* aCtx, const nscolor& aForegroundColor)
15339: {
19207:   gfxPoint shadowOffset(aShadowDetails->mXOffset, aShadowDetails->mYOffset);
32531:   nscoord blurRadius = NS_MAX(aShadowDetails->mRadius, 0);
15339: 
15339:   gfxTextRun::Metrics shadowMetrics =
25417:     mTextRun->MeasureText(aOffset, aLength, gfxFont::LOOSE_INK_EXTENTS,
15339:                           nsnull, aProvider);
16706:   if (GetStateBits() & TEXT_HYPHEN_BREAK) {
25417:     AddHyphenToMetrics(this, mTextRun, &shadowMetrics, gfxFont::LOOSE_INK_EXTENTS, aCtx);
16706:   }
15339: 
15339:   // This rect is the box which is equivalent to where the shadow will be painted.
16706:   // The origin of mBoundingBox is the text baseline left, so we must translate it by
15339:   // that much in order to make the origin the top-left corner of the text bounding box.
32863:   gfxRect shadowGfxRect = shadowMetrics.mBoundingBox +
16706:      gfxPoint(aFramePt.x, aTextBaselinePt.y) + shadowOffset;
32863:   nsRect shadowRect(shadowGfxRect.X(), shadowGfxRect.Y(),
40965:                     shadowGfxRect.Width(), shadowGfxRect.Height());
15339: 
15339:   nsContextBoxBlur contextBoxBlur;
51264:   gfxContext* shadowContext = contextBoxBlur.Init(shadowRect, 0, blurRadius,
15339:                                                   PresContext()->AppUnitsPerDevPixel(),
40965:                                                   aCtx, aDirtyRect, nsnull);
15339:   if (!shadowContext)
15339:     return;
15339: 
15339:   nscolor shadowColor;
15339:   if (aShadowDetails->mHasColor)
15339:     shadowColor = aShadowDetails->mColor;
15339:   else
15339:     shadowColor = aForegroundColor;
15339: 
15339:   aCtx->Save();
15339:   aCtx->NewPath();
15339:   aCtx->SetColor(gfxRGBA(shadowColor));
15339: 
15339:   // Draw the text onto our alpha-only surface to capture the alpha values.
15339:   // Remember that the box blur context has a device offset on it, so we don't need to
15339:   // translate any coordinates to fit on the surface.
32863:   gfxRect dirtyGfxRect(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
16706:   gfxFloat advanceWidth;
15339:   DrawText(shadowContext,
16706:            aTextBaselinePt + shadowOffset,
32863:            aOffset, aLength, &dirtyGfxRect, aProvider, advanceWidth,
15339:            (GetStateBits() & TEXT_HYPHEN_BREAK) != 0);
15339: 
15339:   // This will only have an effect in quirks mode. Standards mode text-decoration shadow painting
15339:   // is handled in nsHTMLContainerFrame.cpp, so you must remember to consider that if you change
15339:   // any code behaviour here.
16706:   nsTextPaintStyle textPaintStyle(this);
32863:   PaintTextDecorations(shadowContext, dirtyGfxRect, aFramePt + shadowOffset,
16706:                        aTextBaselinePt + shadowOffset,
19961:                        textPaintStyle, *aProvider, &shadowColor);
15339: 
15339:   contextBoxBlur.DoPaint();
15339:   aCtx->Restore();
15339: }
15339: 
    1: // Paints selection backgrounds and text in the correct colors. Also computes
    1: // aAllTypes, the union of all selection types that are applying to this text.
    1: void
    1: nsTextFrame::PaintTextWithSelectionColors(gfxContext* aCtx,
    1:     const gfxPoint& aFramePt,
    1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
    1:     PropertyProvider& aProvider, nsTextPaintStyle& aTextPaintStyle,
    1:     SelectionDetails* aDetails, SelectionType* aAllTypes)
    1: {
    1:   PRInt32 contentOffset = aProvider.GetStart().GetOriginalOffset();
    1:   PRInt32 contentLength = aProvider.GetOriginalLength();
    1: 
    1:   // Figure out which selections control the colors to use for each character.
27654:   nsAutoTArray<SelectionDetails*,BIG_TEXT_NODE_SIZE> prevailingSelectionsBuffer;
    1:   if (!prevailingSelectionsBuffer.AppendElements(contentLength))
    1:     return;
27654:   SelectionDetails** prevailingSelections = prevailingSelectionsBuffer.Elements();
27654: 
    1:   PRInt32 i;
    1:   SelectionType allTypes = 0;
    1:   for (i = 0; i < contentLength; ++i) {
27654:     prevailingSelections[i] = nsnull;
    1:   }
    1: 
    1:   SelectionDetails *sdptr = aDetails;
    1:   PRBool anyBackgrounds = PR_FALSE;
    1:   while (sdptr) {
32531:     PRInt32 start = NS_MAX(0, sdptr->mStart - contentOffset);
32531:     PRInt32 end = NS_MIN(contentLength, sdptr->mEnd - contentOffset);
    1:     SelectionType type = sdptr->mType;
    1:     if (start < end) {
    1:       allTypes |= type;
    1:       // Ignore selections that don't set colors
    1:       nscolor foreground, background;
27654:       if (GetSelectionTextColors(type, aTextPaintStyle, sdptr->mTextRangeStyle,
27654:                                  &foreground, &background)) {
    1:         if (NS_GET_A(background) > 0) {
    1:           anyBackgrounds = PR_TRUE;
    1:         }
    1:         for (i = start; i < end; ++i) {
    1:           // Favour normal selection over IME selections
27654:           if (!prevailingSelections[i] ||
27654:               type < prevailingSelections[i]->mType) {
27654:             prevailingSelections[i] = sdptr;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     sdptr = sdptr->mNext;
    1:   }
    1:   *aAllTypes = allTypes;
    1: 
    1:   gfxFloat xOffset, hyphenWidth;
    1:   PRUint32 offset, length; // in transformed string
    1:   SelectionType type;
27654:   nsTextRangeStyle rangeStyle;
    1:   // Draw background colors
    1:   if (anyBackgrounds) {
    1:     SelectionIterator iterator(prevailingSelections, contentOffset, contentLength,
    1:                                aProvider, mTextRun);
27654:     while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
27654:                                    &type, &rangeStyle)) {
    1:       nscolor foreground, background;
27654:       GetSelectionTextColors(type, aTextPaintStyle, rangeStyle,
27654:                              &foreground, &background);
    1:       // Draw background color
    1:       gfxFloat advance = hyphenWidth +
    1:         mTextRun->GetAdvanceWidth(offset, length, &aProvider);
    1:       if (NS_GET_A(background) > 0) {
    1:         gfxFloat x = xOffset - (mTextRun->IsRightToLeft() ? advance : 0);
  280:         FillClippedRect(aCtx, aTextPaintStyle.PresContext(),
    1:                         background, aDirtyRect,
    1:                         gfxRect(aFramePt.x + x, aFramePt.y, advance, GetSize().height));
    1:       }
    1:       iterator.UpdateWithAdvance(advance);
    1:     }
    1:   }
    1:   
    1:   // Draw text
    1:   SelectionIterator iterator(prevailingSelections, contentOffset, contentLength,
    1:                              aProvider, mTextRun);
27654:   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
27654:                                  &type, &rangeStyle)) {
    1:     nscolor foreground, background;
27654:     GetSelectionTextColors(type, aTextPaintStyle, rangeStyle,
27654:                            &foreground, &background);
    1:     // Draw text segment
    1:     aCtx->SetColor(gfxRGBA(foreground));
    1:     gfxFloat advance;
15339: 
15339:     DrawText(aCtx, gfxPoint(aFramePt.x + xOffset, aTextBaselinePt.y),
15339:              offset, length, &aDirtyRect, &aProvider,
15339:              advance, hyphenWidth > 0);
    1:     if (hyphenWidth) {
    1:       advance += hyphenWidth;
    1:     }
    1:     iterator.UpdateWithAdvance(advance);
    1:   }
    1: }
    1: 
    1: void
    1: nsTextFrame::PaintTextSelectionDecorations(gfxContext* aCtx,
    1:     const gfxPoint& aFramePt,
    1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
    1:     PropertyProvider& aProvider, nsTextPaintStyle& aTextPaintStyle,
    1:     SelectionDetails* aDetails, SelectionType aSelectionType)
    1: {
    1:   PRInt32 contentOffset = aProvider.GetStart().GetOriginalOffset();
    1:   PRInt32 contentLength = aProvider.GetOriginalLength();
    1: 
27654:   // Figure out which characters will be decorated for this selection.
27654:   nsAutoTArray<SelectionDetails*, BIG_TEXT_NODE_SIZE> selectedCharsBuffer;
    1:   if (!selectedCharsBuffer.AppendElements(contentLength))
    1:     return;
27654:   SelectionDetails** selectedChars = selectedCharsBuffer.Elements();
    1:   PRInt32 i;
    1:   for (i = 0; i < contentLength; ++i) {
27654:     selectedChars[i] = nsnull;
    1:   }
    1: 
    1:   SelectionDetails *sdptr = aDetails;
    1:   while (sdptr) {
    1:     if (sdptr->mType == aSelectionType) {
32531:       PRInt32 start = NS_MAX(0, sdptr->mStart - contentOffset);
32531:       PRInt32 end = NS_MIN(contentLength, sdptr->mEnd - contentOffset);
    1:       for (i = start; i < end; ++i) {
27654:         selectedChars[i] = sdptr;
    1:       }
    1:     }
    1:     sdptr = sdptr->mNext;
    1:   }
    1: 
12989:   gfxFont* firstFont = aProvider.GetFontGroup()->GetFontAt(0);
12989:   if (!firstFont)
12989:     return; // OOM
12989:   gfxFont::Metrics decorationMetrics(firstFont->GetMetrics());
12989:   decorationMetrics.underlineOffset =
12989:     aProvider.GetFontGroup()->GetUnderlineOffset();
    1: 
    1:   SelectionIterator iterator(selectedChars, contentOffset, contentLength,
    1:                              aProvider, mTextRun);
    1:   gfxFloat xOffset, hyphenWidth;
    1:   PRUint32 offset, length;
 5601:   PRInt32 app = aTextPaintStyle.PresContext()->AppUnitsPerDevPixel();
 5601:   // XXX aTextBaselinePt is in AppUnits, shouldn't it be nsFloatPoint?
 5601:   gfxPoint pt(0.0, (aTextBaselinePt.y - mAscent) / app);
    1:   SelectionType type;
27654:   nsTextRangeStyle selectedStyle;
27654:   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
27654:                                  &type, &selectedStyle)) {
    1:     gfxFloat advance = hyphenWidth +
    1:       mTextRun->GetAdvanceWidth(offset, length, &aProvider);
    1:     if (type == aSelectionType) {
13955:       pt.x = (aFramePt.x + xOffset -
13955:              (mTextRun->IsRightToLeft() ? advance : 0)) / app;
 5147:       gfxFloat width = PR_ABS(advance) / app;
29850:       DrawSelectionDecorations(aCtx, aSelectionType, this, aTextPaintStyle,
27654:                                selectedStyle,
13955:                                pt, width, mAscent / app, decorationMetrics);
    1:     }
    1:     iterator.UpdateWithAdvance(advance);
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsTextFrame::PaintTextWithSelection(gfxContext* aCtx,
    1:     const gfxPoint& aFramePt,
    1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
    1:     PropertyProvider& aProvider, nsTextPaintStyle& aTextPaintStyle)
    1: {
    1:   SelectionDetails* details = GetSelectionDetails();
    1:   if (!details)
    1:     return PR_FALSE;
    1: 
    1:   SelectionType allTypes;
    1:   PaintTextWithSelectionColors(aCtx, aFramePt, aTextBaselinePt, aDirtyRect,
    1:                                aProvider, aTextPaintStyle, details, &allTypes);
 5601:   PaintTextDecorations(aCtx, aDirtyRect, aFramePt, aTextBaselinePt,
 5601:                        aTextPaintStyle, aProvider);
    1:   PRInt32 i;
    1:   // Iterate through just the selection types that paint decorations and
    1:   // paint decorations for any that actually occur in this frame. Paint
    1:   // higher-numbered selection types below lower-numered ones on the
    1:   // general principal that lower-numbered selections are higher priority.
    1:   allTypes &= SelectionTypesWithDecorations;
    1:   for (i = nsISelectionController::NUM_SELECTIONTYPES - 1; i >= 1; --i) {
    1:     SelectionType type = 1 << (i - 1);
    1:     if (allTypes & type) {
    1:       // There is some selection of this type. Try to paint its decorations
    1:       // (there might not be any for this type but that's OK,
    1:       // PaintTextSelectionDecorations will exit early).
    1:       PaintTextSelectionDecorations(aCtx, aFramePt, aTextBaselinePt, aDirtyRect,
    1:                                     aProvider, aTextPaintStyle, details, type);
    1:     }
    1:   }
    1: 
    1:   DestroySelectionDetails(details);
    1:   return PR_TRUE;
    1: }
    1: 
40078: nscolor
40078: nsTextFrame::GetCaretColorAt(PRInt32 aOffset)
40078: {
40078:   NS_PRECONDITION(aOffset >= 0, "aOffset must be positive");
40078: 
40078:   gfxSkipCharsIterator iter = EnsureTextRun();
40078:   PropertyProvider provider(this, iter);
40078:   PRInt32 contentOffset = provider.GetStart().GetOriginalOffset();
40078:   PRInt32 contentLength = provider.GetOriginalLength();
40078:   NS_PRECONDITION(aOffset >= contentOffset &&
40078:                   aOffset <= contentOffset + contentLength,
40078:                   "aOffset must be in the frame's range");
40078:   PRInt32 offsetInFrame = aOffset - contentOffset;
40078:   if (offsetInFrame < 0 || offsetInFrame >= contentLength) {
40078:     return nsFrame::GetCaretColorAt(aOffset);
40078:   }
40078: 
40078:   nsTextPaintStyle textPaintStyle(this);
40078:   SelectionDetails* details = GetSelectionDetails();
40078:   SelectionDetails* sdptr = details;
40078:   nscolor result = nsFrame::GetCaretColorAt(aOffset);
40078:   SelectionType type = 0;
40078:   while (sdptr) {
40078:     PRInt32 start = NS_MAX(0, sdptr->mStart - contentOffset);
40078:     PRInt32 end = NS_MIN(contentLength, sdptr->mEnd - contentOffset);
40078:     if (start <= offsetInFrame && offsetInFrame < end &&
40078:         (type == 0 || sdptr->mType < type)) {
40078:       nscolor foreground, background;
40078:       if (GetSelectionTextColors(sdptr->mType, textPaintStyle,
40078:                                  sdptr->mTextRangeStyle,
40078:                                  &foreground, &background)) {
40078:         result = foreground;
40078:         type = sdptr->mType;
40078:       }
40078:     }
40078:     sdptr = sdptr->mNext;
40078:   }
40078: 
40078:   DestroySelectionDetails(details);
40078:   return result;
40078: }
40078: 
    1: static PRUint32
    1: ComputeTransformedLength(PropertyProvider& aProvider)
    1: {
    1:   gfxSkipCharsIterator iter(aProvider.GetStart());
    1:   PRUint32 start = iter.GetSkippedOffset();
    1:   iter.AdvanceOriginal(aProvider.GetOriginalLength());
    1:   return iter.GetSkippedOffset() - start;
    1: }
    1: 
 1508: gfxFloat
 1508: nsTextFrame::GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY)
 1508: {
 1508:   gfxFloat appUnitsPerDevUnit = mTextRun->GetAppUnitsPerDevUnit();
 1508:   gfxFloat baseline = aY + mAscent;
 1508:   gfxRect putativeRect(0, baseline/appUnitsPerDevUnit, 1, 1);
 1508:   if (!aContext->UserToDevicePixelSnapped(putativeRect))
 1508:     return baseline;
 1508:   return aContext->DeviceToUser(putativeRect.pos).y*appUnitsPerDevUnit;
 1508: }
 1508: 
    1: void
    1: nsTextFrame::PaintText(nsIRenderingContext* aRenderingContext, nsPoint aPt,
    1:                        const nsRect& aDirtyRect)
    1: {
 6862:   // Don't pass in aRenderingContext here, because we need a *reference*
 6862:   // context and aRenderingContext might have some transform in it
    1:   // XXX get the block and line passed to us somehow! This is slow!
 6862:   gfxSkipCharsIterator iter = EnsureTextRun();
    1:   if (!mTextRun)
    1:     return;
    1: 
    1:   nsTextPaintStyle textPaintStyle(this);
    1:   PropertyProvider provider(this, iter);
    1:   // Trim trailing whitespace
    1:   provider.InitializeForDisplay(PR_TRUE);
    1: 
 9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
    1: 
    1:   gfxPoint framePt(aPt.x, aPt.y);
    1:   gfxPoint textBaselinePt(
    1:       mTextRun->IsRightToLeft() ? gfxFloat(aPt.x + GetSize().width) : framePt.x,
 1508:       GetSnappedBaselineY(ctx, aPt.y));
    1: 
    1:   gfxRect dirtyRect(aDirtyRect.x, aDirtyRect.y,
    1:                     aDirtyRect.width, aDirtyRect.height);
    1: 
15339:   gfxFloat advanceWidth;
15339:   gfxRGBA foregroundColor = gfxRGBA(textPaintStyle.GetTextColor());
15339: 
15339:   // Paint the text shadow before doing any foreground stuff
15339:   const nsStyleText* textStyle = GetStyleText();
15699:   if (textStyle->mTextShadow) {
15339:     // Text shadow happens with the last value being painted at the back,
15339:     // ie. it is painted first.
15699:     for (PRUint32 i = textStyle->mTextShadow->Length(); i > 0; --i) {
15339:       PaintOneShadow(provider.GetStart().GetSkippedOffset(),
15339:                      ComputeTransformedLength(provider),
15699:                      textStyle->mTextShadow->ShadowAt(i - 1), &provider,
32863:                      aDirtyRect, framePt, textBaselinePt, ctx,
15339:                      textPaintStyle.GetTextColor());
15339:     }
15339:   }
15339: 
    1:   // Fork off to the (slower) paint-with-selection path if necessary.
21943:   if (nsLayoutUtils::GetNonGeneratedAncestor(this)->GetStateBits() & NS_FRAME_SELECTED_CONTENT) {
    1:     if (PaintTextWithSelection(ctx, framePt, textBaselinePt,
    1:                                dirtyRect, provider, textPaintStyle))
    1:       return;
    1:   }
    1: 
15339:   ctx->SetColor(foregroundColor);
15339: 
15339:   DrawText(ctx, textBaselinePt, provider.GetStart().GetSkippedOffset(),
15339:            ComputeTransformedLength(provider), &dirtyRect,
15339:            &provider, advanceWidth,
15339:            (GetStateBits() & TEXT_HYPHEN_BREAK) != 0);
15339:   PaintTextDecorations(ctx, dirtyRect, framePt, textBaselinePt,
15339:                        textPaintStyle, provider);
15339: }
15339: 
15339: void
15339: nsTextFrame::DrawText(gfxContext* aCtx, const gfxPoint& aTextBaselinePt,
15339:                       PRUint32 aOffset, PRUint32 aLength,
15339:                       const gfxRect* aDirtyRect, PropertyProvider* aProvider,
15339:                       gfxFloat& aAdvanceWidth, PRBool aDrawSoftHyphen)
15339: {
15339:   // Paint the text and soft-hyphen (if any) onto the given graphics context
15339:   mTextRun->Draw(aCtx, aTextBaselinePt, aOffset, aLength,
15339:                  aDirtyRect, aProvider, &aAdvanceWidth);
15339: 
15339:   if (aDrawSoftHyphen) {
 6862:     // Don't use ctx as the context, because we need a reference context here,
 6862:     // ctx may be transformed.
 6862:     gfxTextRunCache::AutoTextRun hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, this));
 5724:     if (hyphenTextRun.get()) {
15965:       // For right-to-left text runs, the soft-hyphen is positioned at the left
15965:       // of the text, minus its own width
15965:       gfxFloat hyphenBaselineX = aTextBaselinePt.x + mTextRun->GetDirection() * aAdvanceWidth -
15965:         (mTextRun->IsRightToLeft() ? hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull) : 0);
15339:       hyphenTextRun->Draw(aCtx, gfxPoint(hyphenBaselineX, aTextBaselinePt.y),
15339:                           0, hyphenTextRun->GetLength(), aDirtyRect, nsnull, nsnull);
15339:     }
15339:   }
    1: }
    1: 
    1: PRInt16
    1: nsTextFrame::GetSelectionStatus(PRInt16* aSelectionFlags)
    1: {
    1:   // get the selection controller
    1:   nsCOMPtr<nsISelectionController> selectionController;
  280:   nsresult rv = GetSelectionController(PresContext(),
    1:                                        getter_AddRefs(selectionController));
    1:   if (NS_FAILED(rv) || !selectionController)
    1:     return nsISelectionController::SELECTION_OFF;
    1: 
    1:   selectionController->GetSelectionFlags(aSelectionFlags);
    1: 
    1:   PRInt16 selectionValue;
    1:   selectionController->GetDisplaySelection(&selectionValue);
    1: 
    1:   return selectionValue;
    1: }
    1: 
    1: PRBool
    1: nsTextFrame::IsVisibleInSelection(nsISelection* aSelection)
    1: {
    1:   // Check the quick way first
    1:   PRBool isSelected = (mState & NS_FRAME_SELECTED_CONTENT) == NS_FRAME_SELECTED_CONTENT;
    1:   if (!isSelected)
    1:     return PR_FALSE;
    1:     
    1:   SelectionDetails* details = GetSelectionDetails();
    1:   PRBool found = PR_FALSE;
    1:     
    1:   // where are the selection points "really"
    1:   SelectionDetails *sdptr = details;
    1:   while (sdptr) {
 3118:     if (sdptr->mEnd > GetContentOffset() &&
 3118:         sdptr->mStart < GetContentEnd() &&
    1:         sdptr->mType == nsISelectionController::SELECTION_NORMAL) {
    1:       found = PR_TRUE;
    1:       break;
    1:     }
    1:     sdptr = sdptr->mNext;
    1:   }
    1:   DestroySelectionDetails(details);
    1: 
    1:   return found;
    1: }
    1: 
 1443: /**
 1443:  * Compute the longest prefix of text whose width is <= aWidth. Return
 1443:  * the length of the prefix. Also returns the width of the prefix in aFitWidth.
 1443:  */
    1: static PRUint32
    1: CountCharsFit(gfxTextRun* aTextRun, PRUint32 aStart, PRUint32 aLength,
    8:               gfxFloat aWidth, PropertyProvider* aProvider,
    8:               gfxFloat* aFitWidth)
    1: {
    1:   PRUint32 last = 0;
 1443:   gfxFloat width = 0;
    1:   PRUint32 i;
    1:   for (i = 1; i <= aLength; ++i) {
    8:     if (i == aLength || aTextRun->IsClusterStart(aStart + i)) {
 1443:       gfxFloat nextWidth = width +
 1443:           aTextRun->GetAdvanceWidth(aStart + last, i - last, aProvider);
 1443:       if (nextWidth > aWidth)
 1443:         break;
 1443:       last = i;
 1443:       width = nextWidth;
 1443:     }
 1443:   }
 1443:   *aFitWidth = width;
    1:   return last;
    8: }
    1: 
    1: nsIFrame::ContentOffsets
28352: nsTextFrame::CalcContentOffsetsFromFramePoint(nsPoint aPoint)
28352: {
28352:   return GetCharacterOffsetAtFramePointInternal(aPoint, PR_TRUE);
28352: }
28352: 
28352: nsIFrame::ContentOffsets
28352: nsTextFrame::GetCharacterOffsetAtFramePoint(const nsPoint &aPoint)
28352: {
28352:   return GetCharacterOffsetAtFramePointInternal(aPoint, PR_FALSE);
28352: }
28352: 
28352: nsIFrame::ContentOffsets
28352: nsTextFrame::GetCharacterOffsetAtFramePointInternal(const nsPoint &aPoint,
28352:                                                     PRBool aForInsertionPoint)
28352: {
    1:   ContentOffsets offsets;
    1:   
    1:   gfxSkipCharsIterator iter = EnsureTextRun();
    1:   if (!mTextRun)
    1:     return offsets;
    1:   
    1:   PropertyProvider provider(this, iter);
    1:   // Trim leading but not trailing whitespace if possible
    1:   provider.InitializeForDisplay(PR_FALSE);
    1:   gfxFloat width = mTextRun->IsRightToLeft() ? mRect.width - aPoint.x : aPoint.x;
    8:   gfxFloat fitWidth;
    1:   PRUint32 skippedLength = ComputeTransformedLength(provider);
    1: 
    1:   PRUint32 charsFit = CountCharsFit(mTextRun,
    8:       provider.GetStart().GetSkippedOffset(), skippedLength, width, &provider, &fitWidth);
    1: 
    1:   PRInt32 selectedOffset;
    1:   if (charsFit < skippedLength) {
    1:     // charsFit characters fitted, but no more could fit. See if we're
    1:     // more than halfway through the cluster.. If we are, choose the next
    1:     // cluster.
    1:     gfxSkipCharsIterator extraCluster(provider.GetStart());
    1:     extraCluster.AdvanceSkipped(charsFit);
    1:     gfxSkipCharsIterator extraClusterLastChar(extraCluster);
    1:     FindClusterEnd(mTextRun,
    1:                    provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength(),
    1:                    &extraClusterLastChar);
    1:     gfxFloat charWidth =
    1:         mTextRun->GetAdvanceWidth(extraCluster.GetSkippedOffset(),
    1:                                   GetSkippedDistance(extraCluster, extraClusterLastChar) + 1,
    1:                                   &provider);
28352:     selectedOffset = !aForInsertionPoint || width <= fitWidth + charWidth/2
    1:         ? extraCluster.GetOriginalOffset()
    1:         : extraClusterLastChar.GetOriginalOffset() + 1;
    1:   } else {
    1:     // All characters fitted, we're at (or beyond) the end of the text.
    1:     // XXX This could be some pathological situation where negative spacing
    1:     // caused characters to move backwards. We can't really handle that
    1:     // in the current frame system because frames can't have negative
    1:     // intrinsic widths.
    1:     selectedOffset =
    1:         provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength();
53725:     // If we're at the end of a preformatted line which has a terminating
53725:     // linefeed, we want to reduce the offset by one to make sure that the
53725:     // selection is placed before the linefeed character.
53725:     if (GetStyleText()->NewlineIsSignificant() &&
53725:         HasTerminalNewline()) {
53725:       --selectedOffset;
53725:     }
    1:   }
    1: 
    1:   offsets.content = GetContent();
    1:   offsets.offset = offsets.secondaryOffset = selectedOffset;
    1:   offsets.associateWithNext = mContentOffset == offsets.offset;
    1:   return offsets;
    1: }
    1: 
13714: PRBool
26883: nsTextFrame::CombineSelectionUnderlineRect(nsPresContext* aPresContext,
26883:                                            nsRect& aRect)
26883: {
26883:   if (aRect.IsEmpty())
13714:     return PR_FALSE;
13714: 
26883:   nsRect givenRect = aRect;
26883: 
26883:   nsCOMPtr<nsIFontMetrics> fm;
26883:   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
26883:   nsIThebesFontMetrics* tfm = static_cast<nsIThebesFontMetrics*>(fm.get());
26883:   gfxFontGroup* fontGroup = tfm->GetThebesFontGroup();
26883:   gfxFont* firstFont = fontGroup->GetFontAt(0);
26883:   if (!firstFont)
26883:     return PR_FALSE; // OOM
26883:   const gfxFont::Metrics& metrics = firstFont->GetMetrics();
26883:   gfxFloat underlineOffset = fontGroup->GetUnderlineOffset();
26883:   gfxFloat ascent = aPresContext->AppUnitsToGfxUnits(mAscent);
29850:   gfxFloat descentLimit =
29850:     ComputeDescentLimitForSelectionUnderline(aPresContext, this, metrics);
26883: 
16640:   SelectionDetails *details = GetSelectionDetails();
16640:   for (SelectionDetails *sd = details; sd; sd = sd->mNext) {
26883:     if (sd->mStart == sd->mEnd || !(sd->mType & SelectionTypesWithDecorations))
26883:       continue;
26883: 
26883:     PRUint8 style;
26883:     float relativeSize;
26883:     PRInt32 index =
26883:       nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(sd->mType);
27654:     if (sd->mType == nsISelectionController::SELECTION_SPELLCHECK) {
26883:       if (!nsTextPaintStyle::GetSelectionUnderline(aPresContext, index, nsnull,
26883:                                                    &relativeSize, &style)) {
26883:         continue;
26883:       }
27654:     } else {
27654:       // IME selections
27654:       nsTextRangeStyle& rangeStyle = sd->mTextRangeStyle;
27654:       if (rangeStyle.IsDefined()) {
27654:         if (!rangeStyle.IsLineStyleDefined() ||
27654:             rangeStyle.mLineStyle == nsTextRangeStyle::LINESTYLE_NONE) {
27654:           continue;
27654:         }
27654:         style = GetTextDecorationStyle(rangeStyle);
27654:         relativeSize = rangeStyle.mIsBoldLine ? 2.0f : 1.0f;
27654:       } else if (!nsTextPaintStyle::GetSelectionUnderline(aPresContext, index,
27654:                                                           nsnull, &relativeSize,
27654:                                                           &style)) {
27654:         continue;
27654:       }
27654:     }
26883:     nsRect decorationArea;
26883:     gfxSize size(aPresContext->AppUnitsToGfxUnits(aRect.width),
31685:                  ComputeSelectionUnderlineHeight(aPresContext,
31685:                                                  metrics, sd->mType));
32531:     relativeSize = NS_MAX(relativeSize, 1.0f);
26883:     size.height *= relativeSize;
26883:     decorationArea =
26883:       nsCSSRendering::GetTextDecorationRect(aPresContext, size,
26883:                                             ascent, underlineOffset,
26883:                                             NS_STYLE_TEXT_DECORATION_UNDERLINE,
26988:                                             style, descentLimit);
26883:     aRect.UnionRect(aRect, decorationArea);
16640:   }
16640:   DestroySelectionDetails(details);
16640: 
26883:   return !aRect.IsEmpty() && !givenRect.Contains(aRect);
13714: }
13714: 
30695: void
30695: nsTextFrame::SetSelected(PRBool        aSelected,
30695:                          SelectionType aType)
30695: {
30695:   SetSelectedRange(0, mContent->GetText()->GetLength(), aSelected, aType);
30695: }
30695: 
30695: void
30695: nsTextFrame::SetSelectedRange(PRUint32 aStart,
30695:                               PRUint32 aEnd,
    1:                               PRBool aSelected,
18931:                               SelectionType aType)
    1: {
30695:   NS_ASSERTION(!GetPrevContinuation(), "Should only be called for primary frame");
    1:   DEBUG_VERIFY_NOT_DIRTY(mState);
30695: 
30695:   // Selection is collapsed, which can't affect text frame rendering
30695:   if (aStart == aEnd)
30695:     return;
30695: 
18931:   if (aType == nsISelectionController::SELECTION_NORMAL) {
    1:     // check whether style allows selection
    1:     PRBool selectable;
    1:     IsSelectable(&selectable, nsnull);
    1:     if (!selectable)
30695:       return;
30695:   }
30695: 
30695:   PRBool anySelected = PR_FALSE;
30695: 
30695:   nsTextFrame* f = this;
38653:   while (f && f->GetContentEnd() <= PRInt32(aStart)) {
30695:     if (f->GetStateBits() & NS_FRAME_SELECTED_CONTENT) {
30695:       anySelected = PR_TRUE;
30695:     }
30695:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
30695:   }
30695: 
30695:   nsPresContext* presContext = PresContext();
38653:   while (f && f->GetContentOffset() < PRInt32(aEnd)) {
30695:     if (aSelected) {
30695:       f->AddStateBits(NS_FRAME_SELECTED_CONTENT);
30695:       anySelected = PR_TRUE;
30695:     } else { // we need to see if any other selection is available.
30695:       SelectionDetails *details = f->GetSelectionDetails();
30695:       if (details) {
30695:         anySelected = PR_TRUE;
30695:         DestroySelectionDetails(details);
    1:       } else {
30695:         f->RemoveStateBits(NS_FRAME_SELECTED_CONTENT);
30695:       }
30695:     }
30695: 
30695:     // We may need to reflow to recompute the overflow area for
30695:     // spellchecking or IME underline if their underline is thicker than
30695:     // the normal decoration line.
40484:     if (aType & SelectionTypesWithDecorations) {
28372:       PRBool didHaveOverflowingSelection =
30695:         (f->GetStateBits() & TEXT_SELECTION_UNDERLINE_OVERFLOWED) != 0;
26883:       nsRect r(nsPoint(0, 0), GetSize());
28372:       PRBool willHaveOverflowingSelection =
30695:         aSelected && f->CombineSelectionUnderlineRect(presContext, r);
28372:       if (didHaveOverflowingSelection || willHaveOverflowingSelection) {
30695:         presContext->PresShell()->FrameNeedsReflow(f,
11780:                                                    nsIPresShell::eStyleChange,
11780:                                                    NS_FRAME_IS_DIRTY);
11780:       }
40484:     }
    1:     // Selection might change anything. Invalidate the overflow area.
30695:     f->InvalidateOverflowRect();
30695: 
30695:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
30695:   }
30695: 
30695:   // Scan remaining continuations to see if any are selected
30695:   while (f && !anySelected) {
30695:     if (f->GetStateBits() & NS_FRAME_SELECTED_CONTENT) {
30695:       anySelected = PR_TRUE;
30695:     }
30695:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
30695:   }
30695: 
30695:   if (anySelected) {
30695:     mContent->SetFlags(NS_TEXT_IN_SELECTION);
30695:   } else {
30695:     // This is only legal because there is only one presentation for the
30695:     // content with a selection
30695:     mContent->UnsetFlags(NS_TEXT_IN_SELECTION);
30695:   }
    1: }
    1: 
    1: NS_IMETHODIMP
 4741: nsTextFrame::GetPointFromOffset(PRInt32 inOffset,
    1:                                 nsPoint* outPoint)
    1: {
 4741:   if (!outPoint)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   outPoint->x = 0;
    1:   outPoint->y = 0;
    1: 
    1:   DEBUG_VERIFY_NOT_DIRTY(mState);
    1:   if (mState & NS_FRAME_IS_DIRTY)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
 4678:   if (GetContentLength() <= 0) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   gfxSkipCharsIterator iter = EnsureTextRun();
    1:   if (!mTextRun)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PropertyProvider properties(this, iter);
    1:   // Don't trim trailing whitespace, we want the caret to appear in the right
    1:   // place if it's positioned there
    1:   properties.InitializeForDisplay(PR_FALSE);  
    1: 
 3118:   if (inOffset < GetContentOffset()){
    1:     NS_WARNING("offset before this frame's content");
 3118:     inOffset = GetContentOffset();
 3118:   } else if (inOffset > GetContentEnd()) {
    1:     NS_WARNING("offset after this frame's content");
 3118:     inOffset = GetContentEnd();
    1:   }
    1:   PRInt32 trimmedOffset = properties.GetStart().GetOriginalOffset();
    1:   PRInt32 trimmedEnd = trimmedOffset + properties.GetOriginalLength();
32531:   inOffset = NS_MAX(inOffset, trimmedOffset);
32531:   inOffset = NS_MIN(inOffset, trimmedEnd);
    1: 
    1:   iter.SetOriginalOffset(inOffset);
    1: 
    1:   if (inOffset < trimmedEnd &&
    1:       !iter.IsOriginalCharSkipped() &&
    8:       !mTextRun->IsClusterStart(iter.GetSkippedOffset())) {
    1:     NS_WARNING("GetPointFromOffset called for non-cluster boundary");
38653:     FindClusterStart(mTextRun, trimmedOffset, &iter);
    1:   }
    1: 
    1:   gfxFloat advanceWidth =
    1:     mTextRun->GetAdvanceWidth(properties.GetStart().GetSkippedOffset(),
    1:                               GetSkippedDistance(properties.GetStart(), iter),
    1:                               &properties);
21989:   nscoord width = NSToCoordCeilClamped(advanceWidth);
    1: 
    1:   if (mTextRun->IsRightToLeft()) {
    1:     outPoint->x = mRect.width - width;
    1:   } else {
    1:     outPoint->x = width;
    1:   }
    1:   outPoint->y = 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1732: nsTextFrame::GetChildFrameContainingOffset(PRInt32   aContentOffset,
 1732:                                            PRBool    aHint,
 1732:                                            PRInt32*  aOutOffset,
 1732:                                            nsIFrame**aOutFrame)
    1: {
    1:   DEBUG_VERIFY_NOT_DIRTY(mState);
    1: #if 0 //XXXrbs disable due to bug 310227
    1:   if (mState & NS_FRAME_IS_DIRTY)
    1:     return NS_ERROR_UNEXPECTED;
    1: #endif
    1: 
 1732:   NS_ASSERTION(aOutOffset && aOutFrame, "Bad out parameters");
 1732:   NS_ASSERTION(aContentOffset >= 0, "Negative content offset, existing code was very broken!");
49293:   nsIFrame* primaryFrame = mContent->GetPrimaryFrame();
49293:   if (this != primaryFrame) {
49293:     // This call needs to happen on the primary frame
49293:     return primaryFrame->GetChildFrameContainingOffset(aContentOffset, aHint,
49293:                                                        aOutOffset, aOutFrame);
49293:   }
 1732: 
 1732:   nsTextFrame* f = this;
49293:   PRInt32 offset = mContentOffset;
49293: 
49293:   // Try to look up the offset to frame property
49293:   nsTextFrame* cachedFrame = static_cast<nsTextFrame*>
49293:     (Properties().Get(OffsetToFrameProperty()));
49293: 
49293:   if (cachedFrame) {
49293:     f = cachedFrame;
49293:     offset = f->GetContentOffset();
49293: 
49293:     f->RemoveStateBits(TEXT_IN_OFFSET_CACHE);
49293:   }
49293: 
49293:   if ((aContentOffset >= offset) &&
49293:       (aHint || aContentOffset != offset)) {
 1732:     while (PR_TRUE) {
 3233:       nsTextFrame* next = static_cast<nsTextFrame*>(f->GetNextContinuation());
 1732:       if (!next || aContentOffset < next->GetContentOffset())
 1732:         break;
 1732:       if (aContentOffset == next->GetContentOffset()) {
 1732:         if (aHint) {
 1732:           f = next;
 1732:         }
 1732:         break;
 1732:       }
 1732:       f = next;
 1732:     }
 1732:   } else {
 1732:     while (PR_TRUE) {
 3233:       nsTextFrame* prev = static_cast<nsTextFrame*>(f->GetPrevContinuation());
 1732:       if (!prev || aContentOffset > f->GetContentOffset())
 1732:         break;
 1732:       if (aContentOffset == f->GetContentOffset()) {
 1732:         if (!aHint) {
 1732:           f = prev;
 1732:         }
 1732:         break;
 1732:       }
 1732:       f = prev;
 1732:     }
 1732:   }
 1732:   
 1732:   *aOutOffset = aContentOffset - f->GetContentOffset();
 1732:   *aOutFrame = f;
49293: 
49293:   // cache the frame we found
49293:   Properties().Set(OffsetToFrameProperty(), f);
49293:   f->AddStateBits(TEXT_IN_OFFSET_CACHE);
49293: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsTextFrame::PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset)
    1: {
 4678:   NS_ASSERTION(aOffset && *aOffset <= GetContentLength(), "aOffset out of range");
    1: 
    1:   gfxSkipCharsIterator iter = EnsureTextRun();
    1:   if (!mTextRun)
    1:     return PR_FALSE;
    1: 
35581:   TrimmedOffsets trimmed = GetTrimmedOffsets(mContent->GetText(), PR_TRUE);
    1:   // Check whether there are nonskipped characters in the trimmmed range
 4261:   return iter.ConvertOriginalToSkipped(trimmed.GetEnd()) >
    8:          iter.ConvertOriginalToSkipped(trimmed.mStart);
    1: }
    1: 
 2319: /**
 2319:  * This class iterates through the clusters before or after the given
 2319:  * aPosition (which is a content offset). You can test each cluster
 2319:  * to see if it's whitespace (as far as selection/caret movement is concerned),
 2319:  * or punctuation, or if there is a word break before the cluster. ("Before"
 2319:  * is interpreted according to aDirection, so if aDirection is -1, "before"
 2319:  * means actually *after* the cluster content.)
 2319:  */
15599: class NS_STACK_CLASS ClusterIterator {
 2319: public:
 7679:   ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition, PRInt32 aDirection,
 7679:                   nsString& aContext);
 2319: 
 2319:   PRBool NextCluster();
 2319:   PRBool IsWhitespace();
 2319:   PRBool IsPunctuation();
 6802:   PRBool HaveWordBreakBefore() { return mHaveWordBreak; }
 2319:   PRInt32 GetAfterOffset();
 2319:   PRInt32 GetBeforeOffset();
 2319: 
 2319: private:
 5453:   nsCOMPtr<nsIUGenCategory>   mCategories;
 2319:   gfxSkipCharsIterator        mIterator;
 2319:   const nsTextFragment*       mFrag;
 2319:   nsTextFrame*                mTextFrame;
 2319:   PRInt32                     mDirection;
 2319:   PRInt32                     mCharIndex;
 2319:   nsTextFrame::TrimmedOffsets mTrimmed;
 2319:   nsTArray<PRPackedBool>      mWordBreaks;
 6802:   PRPackedBool                mHaveWordBreak;
 2319: };
 2319: 
 8085: static PRBool
 8085: IsAcceptableCaretPosition(const gfxSkipCharsIterator& aIter, gfxTextRun* aTextRun,
 8085:                           nsIFrame* aFrame)
 8085: {
 8085:   if (aIter.IsOriginalCharSkipped())
 8085:     return PR_FALSE;
 8085:   PRUint32 index = aIter.GetSkippedOffset();
 8085:   if (!aTextRun->IsClusterStart(index))
 8085:     return PR_FALSE;
53724:   return PR_TRUE;
 8085: }
 8085: 
    1: PRBool
    1: nsTextFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)
    1: {
 4678:   PRInt32 contentLength = GetContentLength();
 4678:   NS_ASSERTION(aOffset && *aOffset <= contentLength, "aOffset out of range");
    1: 
    1:   PRBool selectable;
    1:   PRUint8 selectStyle;  
    1:   IsSelectable(&selectable, &selectStyle);
    1:   if (selectStyle == NS_STYLE_USER_SELECT_ALL)
    1:     return PR_FALSE;
    1: 
    1:   gfxSkipCharsIterator iter = EnsureTextRun();
    1:   if (!mTextRun)
    1:     return PR_FALSE;
    1: 
35581:   TrimmedOffsets trimmed = GetTrimmedOffsets(mContent->GetText(), PR_FALSE);
    1: 
    1:   // A negative offset means "end of frame".
 4678:   PRInt32 startOffset = GetContentOffset() + (*aOffset < 0 ? contentLength : *aOffset);
    1: 
    1:   if (!aForward) {
53724:     // If at the beginning of the line, look at the previous continuation
53724:     for (PRInt32 i = NS_MIN(trimmed.GetEnd(), startOffset) - 1;
    8:          i >= trimmed.mStart; --i) {
    1:       iter.SetOriginalOffset(i);
 8085:       if (IsAcceptableCaretPosition(iter, mTextRun, this)) {
    1:         *aOffset = i - mContentOffset;
    1:         return PR_TRUE;
    1:       }
    1:     }
  202:     *aOffset = 0;
    1:   } else {
53724:     // If we're at the end of a line, look at the next continuation
53724:     iter.SetOriginalOffset(startOffset);
55231:     if (startOffset <= PRUint32(trimmed.GetEnd()) &&
55231:         !(startOffset < PRUint32(trimmed.GetEnd()) &&
53724:           GetStyleText()->NewlineIsSignificant() &&
54373:           iter.GetSkippedOffset() < mTextRun->GetLength() &&
53724:           mTextRun->GetChar(iter.GetSkippedOffset()) == '\n')) {
53724:       for (PRInt32 i = startOffset + 1; i <= trimmed.GetEnd(); ++i) {
    1:         iter.SetOriginalOffset(i);
 4261:         if (i == trimmed.GetEnd() ||
 8085:             IsAcceptableCaretPosition(iter, mTextRun, this)) {
    1:           *aOffset = i - mContentOffset;
    1:           return PR_TRUE;
    1:         }
    1:       }
53724:     }
 4678:     *aOffset = contentLength;
    1:   }
    1:   
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
 2319: ClusterIterator::IsWhitespace()
 2319: {
 2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
 2319:   return IsSelectionSpace(mFrag, mCharIndex);
 2319: }
 2319: 
 2319: PRBool
 2319: ClusterIterator::IsPunctuation()
 2319: {
 2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
 5453:   if (!mCategories)
 5453:     return PR_FALSE;
 5453:   nsIUGenCategory::nsUGenCategory c = mCategories->Get(mFrag->CharAt(mCharIndex));
 5453:   return c == nsIUGenCategory::kPunctuation || c == nsIUGenCategory::kSymbol;
 2319: }
 2319: 
 2319: PRInt32
 2319: ClusterIterator::GetBeforeOffset()
 2319: {
 2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
 2319:   return mCharIndex + (mDirection > 0 ? 0 : 1);
 2319: }
 2319: 
 2319: PRInt32
 2319: ClusterIterator::GetAfterOffset()
 2319: {
 2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
 2319:   return mCharIndex + (mDirection > 0 ? 1 : 0);
 2319: }
 2319: 
 2319: PRBool
 2319: ClusterIterator::NextCluster()
 2319: {
 2319:   if (!mDirection)
 2319:     return PR_FALSE;
 2319:   gfxTextRun* textRun = mTextFrame->GetTextRun();
 2319: 
 6802:   mHaveWordBreak = PR_FALSE;
 2319:   while (PR_TRUE) {
 6802:     PRBool keepGoing = PR_FALSE;
 2319:     if (mDirection > 0) {
 4261:       if (mIterator.GetOriginalOffset() >= mTrimmed.GetEnd())
 2319:         return PR_FALSE;
 6802:       keepGoing = mIterator.IsOriginalCharSkipped() ||
 2319:           mIterator.GetOriginalOffset() < mTrimmed.mStart ||
 6802:           !textRun->IsClusterStart(mIterator.GetSkippedOffset());
 2319:       mCharIndex = mIterator.GetOriginalOffset();
 2319:       mIterator.AdvanceOriginal(1);
 2319:     } else {
 2319:       if (mIterator.GetOriginalOffset() <= mTrimmed.mStart)
 2319:         return PR_FALSE;
 2319:       mIterator.AdvanceOriginal(-1);
 6802:       keepGoing = mIterator.IsOriginalCharSkipped() ||
 4261:           mIterator.GetOriginalOffset() >= mTrimmed.GetEnd() ||
 6802:           !textRun->IsClusterStart(mIterator.GetSkippedOffset());
 2319:       mCharIndex = mIterator.GetOriginalOffset();
 2319:     }
 2319: 
 6802:     if (mWordBreaks[GetBeforeOffset() - mTextFrame->GetContentOffset()]) {
 6802:       mHaveWordBreak = PR_TRUE;
 6802:     }
 6802:     if (!keepGoing)
 2319:       return PR_TRUE;
 2319:   }
 2319: }
 2319: 
 2319: ClusterIterator::ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition,
 7679:                                  PRInt32 aDirection, nsString& aContext)
 2319:   : mTextFrame(aTextFrame), mDirection(aDirection), mCharIndex(-1)
 2319: {
 2319:   mIterator = aTextFrame->EnsureTextRun();
 2319:   if (!aTextFrame->GetTextRun()) {
 2319:     mDirection = 0; // signal failure
 2319:     return;
 2319:   }
 2319:   mIterator.SetOriginalOffset(aPosition);
 2319: 
 5453:   mCategories = do_GetService(NS_UNICHARCATEGORY_CONTRACTID);
 5453:   
35581:   mFrag = aTextFrame->GetContent()->GetText();
 2319:   mTrimmed = aTextFrame->GetTrimmedOffsets(mFrag, PR_TRUE);
 2319: 
 6802:   PRInt32 textOffset = aTextFrame->GetContentOffset();
 3438:   PRInt32 textLen = aTextFrame->GetContentLength();
 5453:   if (!mWordBreaks.AppendElements(textLen + 1)) {
 2319:     mDirection = 0; // signal failure
 2319:     return;
 2319:   }
 5453:   memset(mWordBreaks.Elements(), PR_FALSE, textLen + 1);
 7679:   PRInt32 textStart;
 7679:   if (aDirection > 0) {
 7679:     if (aContext.IsEmpty()) {
 7679:       // No previous context, so it must be the start of a line or text run
 7679:       mWordBreaks[0] = PR_TRUE;
 7679:     }
 7679:     textStart = aContext.Length();
 7679:     mFrag->AppendTo(aContext, textOffset, textLen);
 7679:   } else {
 7679:     if (aContext.IsEmpty()) {
 7679:       // No following context, so it must be the end of a line or text run
 7679:       mWordBreaks[textLen] = PR_TRUE;
 7679:     }
 7679:     textStart = 0;
 7679:     nsAutoString str;
 7679:     mFrag->AppendTo(str, textOffset, textLen);
 7679:     aContext.Insert(str, 0);
 7679:   }
 2319:   nsIWordBreaker* wordBreaker = nsContentUtils::WordBreaker();
 7679:   PRInt32 i;
 7679:   for (i = 0; i <= textLen; ++i) {
 7679:     PRInt32 indexInText = i + textStart;
 7679:     mWordBreaks[i] |=
 7679:       wordBreaker->BreakInBetween(aContext.get(), indexInText,
 7679:                                   aContext.get() + indexInText,
 7679:                                   aContext.Length() - indexInText);
 6802:   }
 5453: }
 2319: 
 2319: PRBool
    1: nsTextFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
 5453:                             PRInt32* aOffset, PeekWordState* aState)
    1: {
 4678:   PRInt32 contentLength = GetContentLength();
 4678:   NS_ASSERTION (aOffset && *aOffset <= contentLength, "aOffset out of range");
    1: 
    1:   PRBool selectable;
    1:   PRUint8 selectStyle;
    1:   IsSelectable(&selectable, &selectStyle);
    1:   if (selectStyle == NS_STYLE_USER_SELECT_ALL)
    1:     return PR_FALSE;
    1: 
 4678:   PRInt32 offset = GetContentOffset() + (*aOffset < 0 ? contentLength : *aOffset);
 7679:   ClusterIterator cIter(this, offset, aForward ? 1 : -1, aState->mContext);
 2678: 
 2678:   if (!cIter.NextCluster())
 2678:     return PR_FALSE;
 2678: 
 2678:   do {
 5453:     PRBool isPunctuation = cIter.IsPunctuation();
12505:     PRBool isWhitespace = cIter.IsWhitespace();
15752:     PRBool isWordBreakBefore = cIter.HaveWordBreakBefore();
12505:     if (aWordSelectEatSpace == isWhitespace && !aState->mSawBeforeType) {
 5453:       aState->SetSawBeforeType();
12505:       aState->Update(isPunctuation, isWhitespace);
 2678:       continue;
 2678:     }
 5453:     // See if we can break before the current cluster
 5453:     if (!aState->mAtStart) {
15752:       PRBool canBreak;
15752:       if (isPunctuation != aState->mLastCharWasPunctuation) {
15752:         canBreak = BreakWordBetweenPunctuation(aState, aForward,
15752:                      isPunctuation, isWhitespace, aIsKeyboardSelect);
15752:       } else if (!aState->mLastCharWasWhitespace &&
15752:                  !isWhitespace && !isPunctuation && isWordBreakBefore) {
15752:         // if both the previous and the current character are not white
15752:         // space but this can be word break before, we don't need to eat
15752:         // a white space in this case. This case happens in some languages
15752:         // that their words are not separated by white spaces. E.g.,
15752:         // Japanese and Chinese.
15752:         canBreak = PR_TRUE;
15752:       } else {
15752:         canBreak = isWordBreakBefore && aState->mSawBeforeType;
15752:       }
 5453:       if (canBreak) {
 2319:         *aOffset = cIter.GetBeforeOffset() - mContentOffset;
 2319:         return PR_TRUE;
 2319:       }
 5453:     }
12505:     aState->Update(isPunctuation, isWhitespace);
 2678:   } while (cIter.NextCluster());
 2678: 
 2319:   *aOffset = cIter.GetAfterOffset() - mContentOffset;
    8:   return PR_FALSE;
    1: }
    1: 
    1:  // TODO this needs to be deCOMtaminated with the interface fixed in
    1: // nsIFrame.h, but we won't do that until the old textframe is gone.
    1: NS_IMETHODIMP
    1: nsTextFrame::CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex,
    1:     PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *aRetval)
    1: {
    1:   if (!aRetval)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Text in the range is visible if there is at least one character in the range
    1:   // that is not skipped and is mapped by this frame (which is the primary frame)
    1:   // or one of its continuations.
    1:   for (nsTextFrame* f = this; f;
 3233:        f = static_cast<nsTextFrame*>(GetNextContinuation())) {
    1:     if (f->PeekOffsetNoAmount(PR_TRUE, nsnull)) {
    1:       *aRetval = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   *aRetval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextFrame::GetOffsets(PRInt32 &start, PRInt32 &end) const
    1: {
 3118:   start = GetContentOffset();
 3118:   end = GetContentEnd();
    1:   return NS_OK;
    1: }
    1: 
15634: static PRInt32
15634: FindEndOfPunctuationRun(const nsTextFragment* aFrag,
15634:                         gfxTextRun* aTextRun,
15634:                         gfxSkipCharsIterator* aIter,
15634:                         PRInt32 aOffset,
15634:                         PRInt32 aStart,
15634:                         PRInt32 aEnd)
15634: {
15634:   PRInt32 i;
15634: 
15634:   for (i = aStart; i < aEnd - aOffset; ++i) {
15634:     if (nsContentUtils::IsPunctuationMarkAt(aFrag, aOffset + i)) {
15634:       aIter->SetOriginalOffset(aOffset + i);
15634:       FindClusterEnd(aTextRun, aEnd, aIter);
15634:       i = aIter->GetOriginalOffset() - aOffset;
15634:     } else {
15634:       break;
15634:     }
15634:   }
15634:   return i;
15634: }
15634: 
 3118: /**
 3118:  * Returns PR_TRUE if this text frame completes the first-letter, PR_FALSE
 3118:  * if it does not contain a true "letter".
 3118:  * If returns PR_TRUE, then it also updates aLength to cover just the first-letter
 3118:  * text.
 3118:  *
 3118:  * XXX :first-letter should be handled during frame construction
 3118:  * (and it has a good bit in common with nextBidi)
 3118:  * 
 3118:  * @param aLength an in/out parameter: on entry contains the maximum length to
 3118:  * return, on exit returns length of the first-letter fragment (which may
15634:  * include leading and trailing punctuation, for example)
 3118:  */
    1: static PRBool
    1: FindFirstLetterRange(const nsTextFragment* aFrag,
    1:                      gfxTextRun* aTextRun,
 3417:                      PRInt32 aOffset, const gfxSkipCharsIterator& aIter,
 3417:                      PRInt32* aLength)
    1: {
    1:   PRInt32 i;
    1:   PRInt32 length = *aLength;
15634:   PRInt32 endOffset = aOffset + length;
15634:   gfxSkipCharsIterator iter(aIter);
15634: 
15634:   // skip leading whitespace, then consume clusters that start with punctuation
15634:   i = FindEndOfPunctuationRun(aFrag, aTextRun, &iter, aOffset, 
15634:                               GetTrimmableWhitespaceCount(aFrag, aOffset, length, 1),
15634:                               endOffset);
    1:   if (i == length)
    1:     return PR_FALSE;
    1: 
15634:   // If the next character is not a letter or number, there is no first-letter.
15634:   // Return PR_TRUE so that we don't go on looking, but set aLength to 0.
15634:   if (!nsContentUtils::IsAlphanumericAt(aFrag, aOffset + i)) {
15634:     *aLength = 0;
15634:     return PR_TRUE;
15634:   }
15634: 
15634:   // consume another cluster (the actual first letter)
15634:   iter.SetOriginalOffset(aOffset + i);
15634:   FindClusterEnd(aTextRun, endOffset, &iter);
15634:   i = iter.GetOriginalOffset() - aOffset;
15634:   if (i + 1 == length)
15634:     return PR_TRUE;
15634: 
15634:   // consume clusters that start with punctuation
15634:   i = FindEndOfPunctuationRun(aFrag, aTextRun, &iter, aOffset, i + 1, endOffset);
15634:   if (i < length)
15634:     *aLength = i;
    1:   return PR_TRUE;
    1: }
    1: 
    1: static PRUint32
    8: FindStartAfterSkippingWhitespace(PropertyProvider* aProvider,
    8:                                  nsIFrame::InlineIntrinsicWidthData* aData,
16575:                                  const nsStyleText* aTextStyle,
    8:                                  gfxSkipCharsIterator* aIterator,
    8:                                  PRUint32 aFlowEndInTextRun)
    1: {
16575:   if (aData->skipWhitespace) {
    8:     while (aIterator->GetSkippedOffset() < aFlowEndInTextRun &&
16575:            IsTrimmableSpace(aProvider->GetFragment(), aIterator->GetOriginalOffset(), aTextStyle)) {
 2013:       aIterator->AdvanceOriginal(1);
    8:     }
    8:   }
    8:   return aIterator->GetSkippedOffset();
    1: }
    1: 
 1284: /* virtual */ 
 1284: void nsTextFrame::MarkIntrinsicWidthsDirty()
 1284: {
 1284:   ClearTextRun();
 1284:   nsFrame::MarkIntrinsicWidthsDirty();
 1284: }
 1284: 
    1: // XXX this doesn't handle characters shaped by line endings. We need to
    1: // temporarily override the "current line ending" settings.
    1: void
    1: nsTextFrame::AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,
    1:                                       nsIFrame::InlineMinWidthData *aData)
    1: {
    1:   PRUint32 flowEndInTextRun;
 9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
    1:   gfxSkipCharsIterator iter =
24819:     EnsureTextRun(ctx, aData->lineContainer, aData->line, &flowEndInTextRun);
    1:   if (!mTextRun)
    1:     return;
    1: 
 1732:   // Pass null for the line container. This will disable tab spacing, but that's
 1732:   // OK since we can't really handle tabs for intrinsic sizing anyway.
16575:   const nsStyleText* textStyle = GetStyleText();
35581:   const nsTextFragment* frag = mContent->GetText();
16575:   PropertyProvider provider(mTextRun, textStyle, frag, this,
 8556:                             iter, PR_INT32_MAX, nsnull, 0);
    8: 
16575:   PRBool collapseWhitespace = !textStyle->WhiteSpaceIsSignificant();
16575:   PRBool preformatNewlines = textStyle->NewlineIsSignificant();
16705:   PRBool preformatTabs = textStyle->WhiteSpaceIsSignificant();
16705:   gfxFloat tabWidth = -1;
    8:   PRUint32 start =
16575:     FindStartAfterSkippingWhitespace(&provider, aData, textStyle, &iter, flowEndInTextRun);
    8: 
    1:   // XXX Should we consider hyphenation here?
 2668:   for (PRUint32 i = start, wordStart = start; i <= flowEndInTextRun; ++i) {
 2668:     PRBool preformattedNewline = PR_FALSE;
16705:     PRBool preformattedTab = PR_FALSE;
 2668:     if (i < flowEndInTextRun) {
 2668:       // XXXldb Shouldn't we be including the newline as part of the
 2668:       // segment that it ends rather than part of the segment that it
 2668:       // starts?
16575:       preformattedNewline = preformatNewlines && mTextRun->GetChar(i) == '\n';
16705:       preformattedTab = preformatTabs && mTextRun->GetChar(i) == '\t';
16705:       if (!mTextRun->CanBreakLineBefore(i) && !preformattedNewline &&
16705:           !preformattedTab) {
 2668:         // we can't break here (and it's not the end of the flow)
    8:         continue;
 2347:       }
 2347:     }
    8: 
 2668:     if (i > wordStart) {
    8:       nscoord width =
21989:         NSToCoordCeilClamped(mTextRun->GetAdvanceWidth(wordStart, i - wordStart, &provider));
21989:       aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, width);
 2668:       aData->atStartOfLine = PR_FALSE;
    8: 
    8:       if (collapseWhitespace) {
16575:         PRUint32 trimStart = GetEndOfTrimmedText(frag, textStyle, wordStart, i, &iter);
 2013:         if (trimStart == start) {
 6529:           // This is *all* trimmable whitespace, so whatever trailingWhitespace
 6529:           // we saw previously is still trailing...
 6529:           aData->trailingWhitespace += width;
    8:         } else {
 6529:           // Some non-whitespace so the old trailingWhitespace is no longer trailing
 6529:           aData->trailingWhitespace =
21989:             NSToCoordCeilClamped(mTextRun->GetAdvanceWidth(trimStart, i - trimStart, &provider));
    8:         }
    8:       } else {
    1:         aData->trailingWhitespace = 0;
    8:       }
 2668:     }
 2668: 
16705:     if (preformattedTab) {
16705:       PropertyProvider::Spacing spacing;
16705:       provider.GetSpacing(i, 1, &spacing);
16705:       aData->currentLine += nscoord(spacing.mBefore);
16705:       gfxFloat afterTab =
33208:         AdvanceToNextTab(aData->currentLine, this,
16705:                          mTextRun, &tabWidth);
16705:       aData->currentLine = nscoord(afterTab + spacing.mAfter);
16705:       wordStart = i + 1;
16705:     } else if (i < flowEndInTextRun ||
 8803:         (i == mTextRun->GetLength() &&
 8803:          (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK))) {
 2668:       if (preformattedNewline) {
 2668:         aData->ForceBreak(aRenderingContext);
 2668:       } else {
 2668:         aData->OptionallyBreak(aRenderingContext);
 2668:       }
    1:       wordStart = i;
    1:     }
    1:   }
    1: 
21940:   if (start < flowEndInTextRun) {
 6529:     // Check if we have collapsible whitespace at the end
    8:     aData->skipWhitespace =
16575:       IsTrimmableSpace(provider.GetFragment(),
16575:                        iter.ConvertSkippedToOriginal(flowEndInTextRun - 1),
16575:                        textStyle);
    1:   }
21940: }
    1: 
    1: // XXX Need to do something here to avoid incremental reflow bugs due to
    1: // first-line and first-letter changing min-width
    1: /* virtual */ void
    1: nsTextFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                nsIFrame::InlineMinWidthData *aData)
    1: {
 2679:   nsTextFrame* f;
 2679:   gfxTextRun* lastTextRun = nsnull;
 2679:   // nsContinuingTextFrame does nothing for AddInlineMinWidth; all text frames
 2679:   // in the flow are handled right here.
 3233:   for (f = this; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
 2679:     // f->mTextRun could be null if we haven't set up textruns yet for f.
 2679:     // Except in OOM situations, lastTextRun will only be null for the first
 2679:     // text frame.
 2679:     if (f == this || f->mTextRun != lastTextRun) {
24819:       nsIFrame* lc;
24819:       if (aData->lineContainer &&
24819:           aData->lineContainer != (lc = FindLineContainer(f))) {
24819:         NS_ASSERTION(f != this, "wrong InlineMinWidthData container"
24819:                                 " for first continuation");
24819:         aData->line = nsnull;
24819:         aData->lineContainer = lc;
24819:       }
24819: 
 2679:       // This will process all the text frames that share the same textrun as f.
    1:       f->AddInlineMinWidthForFlow(aRenderingContext, aData);
 2679:       lastTextRun = f->mTextRun;
    1:     }
    1:   }
    1: }
    1: 
    1: // XXX this doesn't handle characters shaped by line endings. We need to
    1: // temporarily override the "current line ending" settings.
    1: void
    1: nsTextFrame::AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,
    1:                                        nsIFrame::InlinePrefWidthData *aData)
    1: {
    1:   PRUint32 flowEndInTextRun;
 9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
    1:   gfxSkipCharsIterator iter =
24819:     EnsureTextRun(ctx, aData->lineContainer, aData->line, &flowEndInTextRun);
    1:   if (!mTextRun)
    1:     return;
    1: 
 1732:   // Pass null for the line container. This will disable tab spacing, but that's
 1732:   // OK since we can't really handle tabs for intrinsic sizing anyway.
16575:   
16575:   const nsStyleText* textStyle = GetStyleText();
35581:   const nsTextFragment* frag = mContent->GetText();
16575:   PropertyProvider provider(mTextRun, textStyle, frag, this,
 8556:                             iter, PR_INT32_MAX, nsnull, 0);
    8: 
16575:   PRBool collapseWhitespace = !textStyle->WhiteSpaceIsSignificant();
16575:   PRBool preformatNewlines = textStyle->NewlineIsSignificant();
16705:   PRBool preformatTabs = textStyle->WhiteSpaceIsSignificant();
16705:   gfxFloat tabWidth = -1;
    8:   PRUint32 start =
16575:     FindStartAfterSkippingWhitespace(&provider, aData, textStyle, &iter, flowEndInTextRun);
    8: 
16575:   // XXX Should we consider hyphenation here?
16705:   // If newlines and tabs aren't preformatted, nothing to do inside
16705:   // the loop so make i skip to the end
16705:   PRUint32 loopStart = (preformatNewlines || preformatTabs) ? start : flowEndInTextRun;
16705:   for (PRUint32 i = loopStart, lineStart = start; i <= flowEndInTextRun; ++i) {
16575:     PRBool preformattedNewline = PR_FALSE;
16705:     PRBool preformattedTab = PR_FALSE;
16575:     if (i < flowEndInTextRun) {
16575:       // XXXldb Shouldn't we be including the newline as part of the
16575:       // segment that it ends rather than part of the segment that it
16575:       // starts?
16575:       NS_ASSERTION(preformatNewlines, "We can't be here unless newlines are hard breaks");
16705:       preformattedNewline = preformatNewlines && mTextRun->GetChar(i) == '\n';
16705:       preformattedTab = preformatTabs && mTextRun->GetChar(i) == '\t';
16705:       if (!preformattedNewline && !preformattedTab) {
16575:         // we needn't break here (and it's not the end of the flow)
16575:         continue;
16575:       }
16575:     }
16575: 
16575:     if (i > lineStart) {
16575:       nscoord width =
21989:         NSToCoordCeilClamped(mTextRun->GetAdvanceWidth(lineStart, i - lineStart, &provider));
16575:       aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, width);
16575: 
    8:       if (collapseWhitespace) {
16575:         PRUint32 trimStart = GetEndOfTrimmedText(frag, textStyle, lineStart, i, &iter);
 2013:         if (trimStart == start) {
    8:           // This is *all* trimmable whitespace, so whatever trailingWhitespace
    8:           // we saw previously is still trailing...
 6529:           aData->trailingWhitespace += width;
    1:         } else {
    8:           // Some non-whitespace so the old trailingWhitespace is no longer trailing
 6529:           aData->trailingWhitespace =
21989:             NSToCoordCeilClamped(mTextRun->GetAdvanceWidth(trimStart, i - trimStart, &provider));
    1:         }
    1:       } else {
 2742:         aData->trailingWhitespace = 0;
16575:       }
16575:     }
16575: 
16705:     if (preformattedTab) {
16705:       PropertyProvider::Spacing spacing;
16705:       provider.GetSpacing(i, 1, &spacing);
16705:       aData->currentLine += nscoord(spacing.mBefore);
16705:       gfxFloat afterTab =
33208:         AdvanceToNextTab(aData->currentLine, this,
16705:                          mTextRun, &tabWidth);
16705:       aData->currentLine = nscoord(afterTab + spacing.mAfter);
16705:       lineStart = i + 1;
16705:     } else if (preformattedNewline) {
 2668:       aData->ForceBreak(aRenderingContext);
16575:       lineStart = i;
 2742:     }
    8:   }
    8: 
 6529:   // Check if we have collapsible whitespace at the end
21940:   if (start < flowEndInTextRun) {
    8:     aData->skipWhitespace =
16575:       IsTrimmableSpace(provider.GetFragment(),
16575:                        iter.ConvertSkippedToOriginal(flowEndInTextRun - 1),
16575:                        textStyle);
    1:   }
21940: }
    1: 
    1: // XXX Need to do something here to avoid incremental reflow bugs due to
    1: // first-line and first-letter changing pref-width
    1: /* virtual */ void
    1: nsTextFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                 nsIFrame::InlinePrefWidthData *aData)
    1: {
 2679:   nsTextFrame* f;
 2679:   gfxTextRun* lastTextRun = nsnull;
 2679:   // nsContinuingTextFrame does nothing for AddInlineMinWidth; all text frames
 2679:   // in the flow are handled right here.
 3233:   for (f = this; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
 2679:     // f->mTextRun could be null if we haven't set up textruns yet for f.
 2679:     // Except in OOM situations, lastTextRun will only be null for the first
 2679:     // text frame.
 2679:     if (f == this || f->mTextRun != lastTextRun) {
24819:       nsIFrame* lc;
24819:       if (aData->lineContainer &&
24819:           aData->lineContainer != (lc = FindLineContainer(f))) {
24819:         NS_ASSERTION(f != this, "wrong InlinePrefWidthData container"
24819:                                 " for first continuation");
24819:         aData->line = nsnull;
24819:         aData->lineContainer = lc;
24819:       }
24819: 
 2679:       // This will process all the text frames that share the same textrun as f.
    1:       f->AddInlinePrefWidthForFlow(aRenderingContext, aData);
 2679:       lastTextRun = f->mTextRun;
    1:     }
    1:   }
    1: }
    1: 
    1: /* virtual */ nsSize
    1: nsTextFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                          nsSize aCBSize, nscoord aAvailableWidth,
    1:                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                          PRBool aShrinkWrap)
    1: {
    1:   // Inlines and text don't compute size before reflow.
    1:   return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: }
    1: 
 6862: static nsRect
 6862: RoundOut(const gfxRect& aRect)
 6862: {
 6862:   nsRect r;
 6862:   r.x = NSToCoordFloor(aRect.X());
 6862:   r.y = NSToCoordFloor(aRect.Y());
 6862:   r.width = NSToCoordCeil(aRect.XMost()) - r.x;
 6862:   r.height = NSToCoordCeil(aRect.YMost()) - r.y;
 6862:   return r;
 6862: }
 6862: 
 6862: nsRect
 6862: nsTextFrame::ComputeTightBounds(gfxContext* aContext) const
 6862: {
 6862:   if ((GetStyleContext()->HasTextDecorations() &&
 6862:        eCompatibility_NavQuirks == PresContext()->CompatibilityMode()) ||
 6862:       (GetStateBits() & TEXT_HYPHEN_BREAK)) {
 6862:     // This is conservative, but OK.
55035:     return GetVisualOverflowRect();
 6862:   }
 6862: 
 6862:   gfxSkipCharsIterator iter = const_cast<nsTextFrame*>(this)->EnsureTextRun();
 6862:   if (!mTextRun)
 6862:     return nsRect(0, 0, 0, 0);
 6862: 
 6862:   PropertyProvider provider(const_cast<nsTextFrame*>(this), iter);
 6862:   // Trim trailing whitespace
 6862:   provider.InitializeForDisplay(PR_TRUE);
 6862: 
 6862:   gfxTextRun::Metrics metrics =
 6862:         mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
25417:                               ComputeTransformedLength(provider),
25417:                               gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
 6862:                               aContext, &provider);
 6862:   // mAscent should be the same as metrics.mAscent, but it's what we use to
 6862:   // paint so that's the one we'll use.
 6862:   return RoundOut(metrics.mBoundingBox) + nsPoint(0, mAscent);
 6862: }
 6862: 
 3006: static PRBool
 3006: HasSoftHyphenBefore(const nsTextFragment* aFrag, gfxTextRun* aTextRun,
 3006:                     PRInt32 aStartOffset, const gfxSkipCharsIterator& aIter)
 3006: {
 3006:   if (!(aTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_SHY))
 3006:     return PR_FALSE;
 3006:   gfxSkipCharsIterator iter = aIter;
 3006:   while (iter.GetOriginalOffset() > aStartOffset) {
 3006:     iter.AdvanceOriginal(-1);
 3006:     if (!iter.IsOriginalCharSkipped())
 3006:       break;
 3006:     if (aFrag->CharAt(iter.GetOriginalOffset()) == CH_SHY)
 3006:       return PR_TRUE;
 3006:   }
 3006:   return PR_FALSE;
 3006: }
 3006: 
 4678: void
34012: nsTextFrame::SetLength(PRInt32 aLength, nsLineLayout* aLineLayout)
 4678: {
 4678:   mContentLengthHint = aLength;
 4678:   PRInt32 end = GetContentOffset() + aLength;
 9735:   nsTextFrame* f = static_cast<nsTextFrame*>(GetNextInFlow());
 9735:   if (!f)
 4678:     return;
34012: 
34012:   // If our end offset is moving, then even if frames are not being pushed or
34012:   // pulled, content is moving to or from the next line and the next line
34012:   // must be reflowed.
34012:   // If the next-continuation is dirty, then we should dirty the next line now
34012:   // because we may have skipped doing it if we dirtied it in
34012:   // CharacterDataChanged. This is ugly but teaching FrameNeedsReflow
34012:   // and ChildIsDirty to handle a range of frames would be worse.
34012:   if (aLineLayout &&
34012:       (end != f->mContentOffset || (f->GetStateBits() & NS_FRAME_IS_DIRTY))) {
34500:     aLineLayout->SetDirtyNextLine();
34012:   }
34012: 
 9735:   if (end < f->mContentOffset) {
 9735:     // Our frame is shrinking. Give the text to our next in flow.
 9735:     f->mContentOffset = end;
 9735:     if (f->GetTextRun() != mTextRun) {
 4678:       ClearTextRun();
 9735:       f->ClearTextRun();
 4678:     }
 4678:     return;
 4678:   }
34012:   // Our frame is growing. Take text from our in-flow(s).
34012:   // We can take text from frames in lines beyond just the next line.
34012:   // We don't dirty those lines. That's OK, because when we reflow
34012:   // our empty next-in-flow, it will take text from its next-in-flow and
34012:   // dirty that line.
 9735:   while (f && f->mContentOffset < end) {
 9735:     f->mContentOffset = end;
 9735:     if (f->GetTextRun() != mTextRun) {
 4678:       ClearTextRun();
 9735:       f->ClearTextRun();
 9735:     }
 9735:     f = static_cast<nsTextFrame*>(f->GetNextInFlow());
 9735:   }
34012: 
 9810: #ifdef DEBUG
30152:   f = this;
30152:   PRInt32 iterations = 0;
30152:   while (f && iterations < 10) {
 9810:     f->GetContentLength(); // Assert if negative length
 9810:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
30152:     ++iterations;
30152:   }
30152:   f = this;
30152:   iterations = 0;
30152:   while (f && iterations < 10) {
30152:     f->GetContentLength(); // Assert if negative length
30152:     f = static_cast<nsTextFrame*>(f->GetPrevContinuation());
30152:     ++iterations;
 9810:   }
 9810: #endif
 4678: }
 4678: 
14210: PRBool
14210: nsTextFrame::IsFloatingFirstLetterChild()
14210: {
31623:   if (!(GetStateBits() & TEXT_FIRST_LETTER))
14210:     return PR_FALSE;
14210:   nsIFrame* frame = GetParent();
14210:   if (!frame || frame->GetType() != nsGkAtoms::letterFrame)
14210:     return PR_FALSE;
14210:   return frame->GetStyleDisplay()->IsFloating();
14210: }
14210: 
36903: struct NewlineProperty {
36903:   PRInt32 mStartOffset;
36903:   // The offset of the first \n after mStartOffset, or -1 if there is none
36903:   PRInt32 mNewlineOffset;
36903: 
36903:   static void Destroy(void* aObject, nsIAtom* aPropertyName,
36903:                       void* aPropertyValue, void* aData)
36903:   {
36903:     delete static_cast<NewlineProperty*>(aPropertyValue);
36903:   }
36903: };
36903: 
    1: NS_IMETHODIMP
    1: nsTextFrame::Reflow(nsPresContext*           aPresContext,
    1:                     nsHTMLReflowMetrics&     aMetrics,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsTextFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
51483: 
51483:   // XXX If there's no line layout, we shouldn't even have created this
51483:   // frame. This may happen if, for example, this is text inside a table
51483:   // but not inside a cell. For now, just don't reflow.
51483:   if (!aReflowState.mLineLayout) {
51483:     ClearMetrics(aMetrics);
51483:     aStatus = NS_FRAME_COMPLETE;
51483:     return NS_OK;
51483:   }
51483: 
51483:   ReflowText(*aReflowState.mLineLayout, aReflowState.availableWidth,
51483:              aReflowState.rendContext, aReflowState.mFlags.mBlinks,
51483:              aMetrics, aStatus);
51483: 
51483:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
51483:   return NS_OK;
51483: }
51483: 
51483: void
51483: nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
51483:                         nsIRenderingContext* aRenderingContext,
51483:                         PRBool aShouldBlink,
51483:                         nsHTMLReflowMetrics& aMetrics,
51483:                         nsReflowStatus& aStatus)
51483: {
    1: #ifdef NOISY_REFLOW
    1:   ListTag(stdout);
51483:   printf(": BeginReflow: availableWidth=%d\n", aAvailableWidth);
    1: #endif
    1: 
51483:   nsPresContext* presContext = PresContext();
51483: 
    1:   /////////////////////////////////////////////////////////////////////
    1:   // Set up flags and clear out state
    1:   /////////////////////////////////////////////////////////////////////
    1: 
    1:   // Clear out the reflow state flags in mState (without destroying
35581:   // the TEXT_BLINK_ON bit). We also clear the whitespace flags because this
35581:   // can change whether the frame maps whitespace-only text or not.
    1:   RemoveStateBits(TEXT_REFLOW_FLAGS | TEXT_WHITESPACE_FLAGS);
    1: 
 4104:   // Temporarily map all possible content while we construct our new textrun.
 4104:   // so that when doing reflow our styles prevail over any part of the
 4104:   // textrun we look at. Note that next-in-flows may be mapping the same
 4104:   // content; gfxTextRun construction logic will ensure that we take priority.
    1:   PRInt32 maxContentLength = GetInFlowContentLength();
    1: 
51483:   // We don't need to reflow if there is no content.
51483:   if (!maxContentLength) {
    1:     ClearMetrics(aMetrics);
    1:     aStatus = NS_FRAME_COMPLETE;
51483:     return;
51483:   }
51483: 
51483:   if (aShouldBlink) {
35581:     if (0 == (mState & TEXT_BLINK_ON)) {
35581:       mState |= TEXT_BLINK_ON;
51483:       nsBlinkTimer::AddBlinkFrame(presContext, this);
    1:     }
    1:   }
    1:   else {
35581:     if (0 != (mState & TEXT_BLINK_ON)) {
35581:       mState &= ~TEXT_BLINK_ON;
    1:       nsBlinkTimer::RemoveBlinkFrame(this);
    1:     }
    1:   }
    1: 
    1:   const nsStyleText* textStyle = GetStyleText();
    1: 
51483:   PRBool atStartOfLine = aLineLayout.LineAtStart();
    1:   if (atStartOfLine) {
    1:     AddStateBits(TEXT_START_OF_LINE);
    1:   }
    1: 
16292:   PRUint32 flowEndInTextRun;
51483:   nsIFrame* lineContainer = aLineLayout.GetLineContainerFrame();
51483:   gfxContext* ctx = aRenderingContext->ThebesContext();
35581:   const nsTextFragment* frag = mContent->GetText();
16292: 
    1:   // DOM offsets of the text range we need to measure, after trimming
    1:   // whitespace, restricting to first-letter, and restricting preformatted text
    1:   // to nearest newline
 4678:   PRInt32 length = maxContentLength;
 4678:   PRInt32 offset = GetContentOffset();
    1: 
    1:   // Restrict preformatted text to the nearest newline
10775:   PRInt32 newLineOffset = -1; // this will be -1 or a content offset
36903:   // Pointer to the nsGkAtoms::newline set on this frame's element
37804:   NewlineProperty* cachedNewlineOffset = nsnull;
16575:   if (textStyle->NewlineIsSignificant()) {
36903:     cachedNewlineOffset =
36903:       static_cast<NewlineProperty*>(mContent->GetProperty(nsGkAtoms::newline));
36903:     if (cachedNewlineOffset && cachedNewlineOffset->mStartOffset <= offset &&
36903:         (cachedNewlineOffset->mNewlineOffset == -1 ||
36903:          cachedNewlineOffset->mNewlineOffset >= offset)) {
36903:       newLineOffset = cachedNewlineOffset->mNewlineOffset;
36903:     } else {
    1:       newLineOffset = FindChar(frag, offset, length, '\n');
36903:     }
    1:     if (newLineOffset >= 0) {
    1:       length = newLineOffset + 1 - offset;
    1:     }
16575:   }
16575:   if (atStartOfLine && !textStyle->WhiteSpaceIsSignificant()) {
16575:     // Skip leading whitespace. Make sure we don't skip a 'pre-line'
16575:     // newline if there is one.
16575:     PRInt32 skipLength = newLineOffset >= 0 ? length - 1 : length;
16575:     PRInt32 whitespaceCount =
16575:       GetTrimmableWhitespaceCount(frag, offset, skipLength, 1);
    8:     offset += whitespaceCount;
    8:     length -= whitespaceCount;
    8:   }
    1: 
16292:   PRBool completedFirstLetter = PR_FALSE;
16292:   // Layout dependent styles are a problem because we need to reconstruct
16292:   // the gfxTextRun based on our layout.
51483:   if (aLineLayout.GetInFirstLetter() || aLineLayout.GetInFirstLine()) {
51483:     SetLength(maxContentLength, &aLineLayout);
51483: 
51483:     if (aLineLayout.GetInFirstLetter()) {
16292:       // floating first-letter boundaries are significant in textrun
16292:       // construction, so clear the textrun out every time we hit a first-letter
16292:       // and have changed our length (which controls the first-letter boundary)
16292:       ClearTextRun();
16292:       // Find the length of the first-letter. We need a textrun for this.
16292:       gfxSkipCharsIterator iter =
51483:         EnsureTextRun(ctx, lineContainer, aLineLayout.GetLine(), &flowEndInTextRun);
16292: 
16292:       if (mTextRun) {
16575:         PRInt32 firstLetterLength = length;
51483:         if (aLineLayout.GetFirstLetterStyleOK()) {
16575:           completedFirstLetter =
16575:             FindFirstLetterRange(frag, mTextRun, offset, iter, &firstLetterLength);
16575:           if (newLineOffset >= 0) {
16575:             // Don't allow a preformatted newline to be part of a first-letter.
32531:             firstLetterLength = NS_MIN(firstLetterLength, length - 1);
16575:             if (length == 1) {
16575:               // There is no text to be consumed by the first-letter before the
16575:               // preformatted newline. Note that the first letter is therefore
16575:               // complete (FindFirstLetterRange will have returned false).
16575:               completedFirstLetter = PR_TRUE;
16575:             }
16575:           }
23308:         } else {
23308:           // We're in a first-letter frame's first in flow, so if there
23308:           // was a first-letter, we'd be it. However, for one reason
23308:           // or another (e.g., preformatted line break before this text),
23308:           // we're not actually supposed to have first-letter style. So
23308:           // just make a zero-length first-letter.
23308:           firstLetterLength = 0;
23308:           completedFirstLetter = PR_TRUE;
23308:         }
16575:         length = firstLetterLength;
16292:         if (length) {
16292:           AddStateBits(TEXT_FIRST_LETTER);
16292:         }
16292:         // Change this frame's length to the first-letter length right now
16292:         // so that when we rebuild the textrun it will be built with the
16292:         // right first-letter boundary
51483:         SetLength(offset + length - GetContentOffset(), &aLineLayout);
16292:         // Ensure that the textrun will be rebuilt
16292:         ClearTextRun();
16292:       }
16292:     } 
16292:   }
16292: 
 6779:   gfxSkipCharsIterator iter =
51483:     EnsureTextRun(ctx, lineContainer, aLineLayout.GetLine(), &flowEndInTextRun);
 6779: 
22876:   if (mTextRun && iter.GetOriginalEnd() < offset + length) {
 6779:     // The textrun does not map enough text for this frame. This can happen
 6779:     // when the textrun was ended in the middle of a text node because a
 6779:     // preformatted newline was encountered, and prev-in-flow frames have
 6779:     // consumed all the text of the textrun. We need a new textrun.
 6779:     ClearTextRun();
 6862:     iter = EnsureTextRun(ctx, lineContainer,
51483:                          aLineLayout.GetLine(), &flowEndInTextRun);
 6779:   }
 6779: 
 6779:   if (!mTextRun) {
 6779:     ClearMetrics(aMetrics);
 6779:     aStatus = NS_FRAME_COMPLETE;
51483:     return;
 6779:   }
 6779: 
 6779:   NS_ASSERTION(gfxSkipCharsIterator(iter).ConvertOriginalToSkipped(offset + length)
 6779:                     <= mTextRun->GetLength(),
 6779:                "Text run does not map enough text for our reflow");
 6779: 
    1:   /////////////////////////////////////////////////////////////////////
    1:   // See how much text should belong to this text frame, and measure it
    1:   /////////////////////////////////////////////////////////////////////
    1:   
    1:   iter.SetOriginalOffset(offset);
 1732:   nscoord xOffsetForTabs = (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) ?
51483:     (aLineLayout.GetCurrentFrameXDistanceFromBlock() -
15447:        lineContainer->GetUsedBorderAndPadding().left)
15447:     : -1;
 1732:   PropertyProvider provider(mTextRun, textStyle, frag, this, iter, length,
 1732:       lineContainer, xOffsetForTabs);
    1: 
    1:   PRUint32 transformedOffset = provider.GetStart().GetSkippedOffset();
    1: 
    1:   // The metrics for the text go in here
    1:   gfxTextRun::Metrics textMetrics;
25417:   gfxFont::BoundingBoxType boundingBoxType = IsFloatingFirstLetterChild() ?
25417:                                                gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS :
25417:                                                gfxFont::LOOSE_INK_EXTENTS;
    1: #ifdef MOZ_MATHML
 6862:   NS_ASSERTION(!(NS_REFLOW_CALC_BOUNDING_METRICS & aMetrics.mFlags),
 6862:                "We shouldn't be passed NS_REFLOW_CALC_BOUNDING_METRICS anymore");
    1: #endif
    1: 
    8:   PRInt32 limitLength = length;
51483:   PRInt32 forceBreak = aLineLayout.GetForcedBreakPosition(mContent);
 8780:   PRBool forceBreakAfter = PR_FALSE;
 3055:   if (forceBreak >= offset + length) {
 8780:     forceBreakAfter = forceBreak == offset + length;
 3055:     // The break is not within the text considered for this textframe.
 3055:     forceBreak = -1;
 3055:   }
    8:   if (forceBreak >= 0) {
    8:     limitLength = forceBreak - offset;
    8:     NS_ASSERTION(limitLength >= 0, "Weird break found!");
    8:   }
    1:   // This is the heart of text reflow right here! We don't know where
    1:   // to break, so we need to see how much text fits in the available width.
    1:   PRUint32 transformedLength;
    8:   if (offset + limitLength >= PRInt32(frag->GetLength())) {
    8:     NS_ASSERTION(offset + limitLength == PRInt32(frag->GetLength()),
    1:                  "Content offset/length out of bounds");
    1:     NS_ASSERTION(flowEndInTextRun >= transformedOffset,
    1:                  "Negative flow length?");
    1:     transformedLength = flowEndInTextRun - transformedOffset;
    1:   } else {
    1:     // we're not looking at all the content, so we need to compute the
    1:     // length of the transformed substring we're looking at
    1:     gfxSkipCharsIterator iter(provider.GetStart());
    8:     iter.SetOriginalOffset(offset + limitLength);
    1:     transformedLength = iter.GetSkippedOffset() - transformedOffset;
    1:   }
    1:   PRUint32 transformedLastBreak = 0;
    8:   PRBool usedHyphenation;
 1732:   gfxFloat trimmedWidth = 0;
51483:   gfxFloat availWidth = aAvailableWidth;
 7069:   PRBool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant();
16166:   PRInt32 unusedOffset;  
16166:   gfxBreakPriority breakPriority;
51483:   aLineLayout.GetLastOptionalBreakPosition(&unusedOffset, &breakPriority);
    1:   PRUint32 transformedCharsFit =
    1:     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,
    1:                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,
 1732:                                   availWidth,
51483:                                   &provider, !aLineLayout.LineIsBreakable(),
 1732:                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,
25417:                                   &textMetrics, boundingBoxType, ctx,
16166:                                   &usedHyphenation, &transformedLastBreak,
16166:                                   textStyle->WordCanWrap(), &breakPriority);
 2013:   // The "end" iterator points to the first character after the string mapped
 3006:   // by this frame. Basically, its original-string offset is offset+charsFit
 2013:   // after we've computed charsFit.
 2013:   gfxSkipCharsIterator end(provider.GetEndHint());
    1:   end.SetSkippedOffset(transformedOffset + transformedCharsFit);
    8:   PRInt32 charsFit = end.GetOriginalOffset() - offset;
10775:   if (offset + charsFit == newLineOffset) {
10775:     // We broke before a trailing preformatted '\n'. The newline should
10775:     // be assigned to this frame. Note that newLineOffset will be -1 if
10775:     // there was no preformatted newline, so we wouldn't get here in that
10775:     // case.
10775:     ++charsFit;
10775:   }
 1732:   // That might have taken us beyond our assigned content range (because
 1732:   // we might have advanced over some skipped chars that extend outside
 1732:   // this frame), so get back in.
    8:   PRInt32 lastBreak = -1;
    8:   if (charsFit >= limitLength) {
    8:     charsFit = limitLength;
    1:     if (transformedLastBreak != PR_UINT32_MAX) {
 3006:       // lastBreak is needed.
    1:       // This may set lastBreak greater than 'length', but that's OK
 3006:       lastBreak = end.ConvertSkippedToOriginal(transformedOffset + transformedLastBreak);
 3006:     }
    1:     end.SetOriginalOffset(offset + charsFit);
 3006:     // If we were forced to fit, and the break position is after a soft hyphen,
 3006:     // note that this is a hyphenation break.
16578:     if ((forceBreak >= 0 || forceBreakAfter) &&
16578:         HasSoftHyphenBefore(frag, mTextRun, offset, end)) {
 3006:       usedHyphenation = PR_TRUE;
    1:     }
    1:   }
    1:   if (usedHyphenation) {
    1:     // Fix up metrics to include hyphen
25417:     AddHyphenToMetrics(this, mTextRun, &textMetrics, boundingBoxType, ctx);
16578:     AddStateBits(TEXT_HYPHEN_BREAK | TEXT_HAS_NONCOLLAPSED_CHARACTERS);
    1:   }
    1: 
 7069:   gfxFloat trimmableWidth = 0;
 8083:   PRBool brokeText = forceBreak >= 0 || transformedCharsFit < transformedLength;
 7069:   if (canTrimTrailingWhitespace) {
 7069:     // Optimization: if we trimmed trailing whitespace, and we can be sure
 7069:     // this frame will be at the end of the line, then leave it trimmed off.
 7069:     // Otherwise we have to undo the trimming, in case we're not at the end of
 7069:     // the line. (If we actually do end up at the end of the line, we'll have
 7069:     // to trim it off again in TrimTrailingWhiteSpace, and we'd like to avoid
 7069:     // having to re-do it.)
 8083:     if (brokeText) {
 7069:       // We're definitely going to break so our trailing whitespace should
 7069:       // definitely be timmed. Record that we've already done it.
 7069:       AddStateBits(TEXT_TRIMMED_TRAILING_WHITESPACE);
 7069:     } else {
 7069:       // We might not be at the end of the line. (Note that even if this frame
 7069:       // ends in breakable whitespace, it might not be at the end of the line
 7069:       // because it might be followed by breakable, but preformatted, whitespace.)
 7069:       // Undo the trimming.
 1732:       textMetrics.mAdvanceWidth += trimmedWidth;
 7069:       trimmableWidth = trimmedWidth;
 1732:       if (mTextRun->IsRightToLeft()) {
 1732:         // Space comes before text, so the bounding box is moved to the
 1732:         // right by trimmdWidth
 1732:         textMetrics.mBoundingBox.MoveBy(gfxPoint(trimmedWidth, 0));
 1732:       }
 8083:     }
 8083:   }
 8083: 
 8083:   if (!brokeText && lastBreak >= 0) {
 7069:     // Since everything fit and no break was forced,
 7069:     // record the last break opportunity
51483:     NS_ASSERTION(textMetrics.mAdvanceWidth - trimmableWidth <= aAvailableWidth,
 8083:                  "If the text doesn't fit, and we have a break opportunity, why didn't MeasureText use it?");
51483:     aLineLayout.NotifyOptionalBreakPosition(mContent, lastBreak, PR_TRUE, breakPriority);
 8083:   }
 8083: 
 4678:   PRInt32 contentLength = offset + charsFit - GetContentOffset();
    1: 
    1:   /////////////////////////////////////////////////////////////////////
    1:   // Compute output metrics
    1:   /////////////////////////////////////////////////////////////////////
    1: 
    1:   // first-letter frames should use the tight bounding box metrics for ascent/descent
    1:   // for good drop-cap effects
    1:   if (GetStateBits() & TEXT_FIRST_LETTER) {
32531:     textMetrics.mAscent = NS_MAX(gfxFloat(0.0), -textMetrics.mBoundingBox.Y());
32531:     textMetrics.mDescent = NS_MAX(gfxFloat(0.0), textMetrics.mBoundingBox.YMost());
    1:   }
    1: 
    1:   // Setup metrics for caller
    1:   // Disallow negative widths
32531:   aMetrics.width = NSToCoordCeil(NS_MAX(gfxFloat(0.0), textMetrics.mAdvanceWidth));
13714: 
16578:   if (transformedCharsFit == 0 && !usedHyphenation) {
15647:     aMetrics.ascent = 0;
15647:     aMetrics.height = 0;
25417:   } else if (boundingBoxType != gfxFont::LOOSE_INK_EXTENTS) {
14210:     // Use actual text metrics for floating first letter frame.
14210:     aMetrics.ascent = NSToCoordCeil(textMetrics.mAscent);
14210:     aMetrics.height = aMetrics.ascent + NSToCoordCeil(textMetrics.mDescent);
14210:   } else {
14210:     // Otherwise, ascent should contain the overline drawable area.
14210:     // And also descent should contain the underline drawable area.
14210:     // nsIFontMetrics::GetMaxAscent/GetMaxDescent contains them.
14210:     nscoord fontAscent, fontDescent;
13714:     nsIFontMetrics* fm = provider.GetFontMetrics();
14210:     fm->GetMaxAscent(fontAscent);
14210:     fm->GetMaxDescent(fontDescent);
32531:     aMetrics.ascent = NS_MAX(NSToCoordCeil(textMetrics.mAscent), fontAscent);
32531:     nscoord descent = NS_MAX(NSToCoordCeil(textMetrics.mDescent), fontDescent);
13714:     aMetrics.height = aMetrics.ascent + descent;
14210:   }
14210: 
    1:   NS_ASSERTION(aMetrics.ascent >= 0, "Negative ascent???");
    1:   NS_ASSERTION(aMetrics.height - aMetrics.ascent >= 0, "Negative descent???");
    1: 
    1:   mAscent = aMetrics.ascent;
    1: 
    1:   // Handle text that runs outside its normal bounds.
13912:   nsRect boundingBox = RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent);
55028:   aMetrics.SetOverflowAreasToDesiredBounds();
55028:   aMetrics.VisualOverflow().UnionRect(aMetrics.VisualOverflow(), boundingBox);
55028: 
55028:   UnionTextDecorationOverflow(presContext, provider, &aMetrics.VisualOverflow());
11780: 
    1:   /////////////////////////////////////////////////////////////////////
    1:   // Clean up, update state
    1:   /////////////////////////////////////////////////////////////////////
    1: 
 7069:   // If all our characters are discarded or collapsed, then trimmable width
 7069:   // from the last textframe should be preserved. Otherwise the trimmable width
 7069:   // from this textframe overrides. (Currently in CSS trimmable width can be
 7069:   // at most one space so there's no way for trimmable width from a previous
 7069:   // frame to accumulate with trimmable width from this frame.)
 7069:   if (transformedCharsFit > 0) {
51483:     aLineLayout.SetTrimmableWidth(NSToCoordFloor(trimmableWidth));
11711:     AddStateBits(TEXT_HAS_NONCOLLAPSED_CHARACTERS);
 7069:   }
 7069:   if (charsFit > 0 && charsFit == length &&
 7069:       HasSoftHyphenBefore(frag, mTextRun, offset, end)) {
 3006:     // Record a potential break after final soft hyphen
51483:     aLineLayout.NotifyOptionalBreakPosition(mContent, offset + length,
16166:         textMetrics.mAdvanceWidth + provider.GetHyphenWidth() <= availWidth,
16166:                                            eNormalBreak);
 3006:   }
 8780:   PRBool breakAfter = forceBreakAfter;
23490:   // length == 0 means either the text is empty or it's all collapsed away
23490:   PRBool emptyTextAtStartOfLine = atStartOfLine && length == 0;
23490:   if (!breakAfter && charsFit == length && !emptyTextAtStartOfLine &&
 8780:       transformedOffset + transformedLength == mTextRun->GetLength() &&
 8780:       (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK)) {
 8780:     // We placed all the text in the textrun and we have a break opportunity at
 8780:     // the end of the textrun. We need to record it because the following
 8780:     // content may not care about nsLineBreaker.
 8780: 
 8573:     // Note that because we didn't break, we can be sure that (thanks to the
 8573:     // code up above) textMetrics.mAdvanceWidth includes the width of any
 8573:     // trailing whitespace. So we need to subtract trimmableWidth here
 8573:     // because if we did break at this point, that much width would be trimmed.
 8573:     if (textMetrics.mAdvanceWidth - trimmableWidth > availWidth) {
 8573:       breakAfter = PR_TRUE;
 8573:     } else {
51483:       aLineLayout.NotifyOptionalBreakPosition(mContent, offset + length,
51483:                                               PR_TRUE, eNormalBreak);
 8573:     }
 8573:   }
    1: 
    1:   // Compute reflow status
 4678:   aStatus = contentLength == maxContentLength
    1:     ? NS_FRAME_COMPLETE : NS_FRAME_NOT_COMPLETE;
    1: 
    1:   if (charsFit == 0 && length > 0) {
    1:     // Couldn't place any text
    1:     aStatus = NS_INLINE_LINE_BREAK_BEFORE();
10775:   } else if (contentLength > 0 && mContentOffset + contentLength - 1 == newLineOffset) {
    1:     // Ends in \n
    1:     aStatus = NS_INLINE_LINE_BREAK_AFTER(aStatus);
51483:     aLineLayout.SetLineEndsInBR(PR_TRUE);
 8573:   } else if (breakAfter) {
 8573:     aStatus = NS_INLINE_LINE_BREAK_AFTER(aStatus);
    1:   }
16409:   if (completedFirstLetter) {
51483:     aLineLayout.SetFirstLetterStyleOK(PR_FALSE);
16409:     aStatus |= NS_INLINE_BREAK_FIRST_LETTER_COMPLETE;
16409:   }
    1: 
36903:   // Updated the cached NewlineProperty, or delete it.
36903:   if (contentLength < maxContentLength &&
36903:       textStyle->NewlineIsSignificant() &&
36903:       (newLineOffset < 0 || mContentOffset + contentLength <= newLineOffset)) {
36903:     if (!cachedNewlineOffset) {
36903:       cachedNewlineOffset = new NewlineProperty;
36903:       if (cachedNewlineOffset) {
36903:         if (NS_FAILED(mContent->SetProperty(nsGkAtoms::newline, cachedNewlineOffset,
36903:                                             NewlineProperty::Destroy))) {
36903:           delete cachedNewlineOffset;
36903:           cachedNewlineOffset = nsnull;
36903:         }
36903:       }
36903:     }
36903:     if (cachedNewlineOffset) {
36903:       cachedNewlineOffset->mStartOffset = offset;
36903:       cachedNewlineOffset->mNewlineOffset = newLineOffset;
36903:     }
36903:   } else if (cachedNewlineOffset) {
36903:     mContent->DeleteProperty(nsGkAtoms::newline);
36903:   }
36903: 
    1:   // Compute space and letter counts for justification, if required
16575:   if (!textStyle->WhiteSpaceIsSignificant() &&
16575:       lineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY) {
16575:     AddStateBits(TEXT_JUSTIFICATION_ENABLED);    // This will include a space for trailing whitespace, if any is present.
    1:     // This is corrected for in nsLineLayout::TrimWhiteSpaceIn.
    1:     PRInt32 numJustifiableCharacters =
    1:       provider.ComputeJustifiableCharacters(offset, charsFit);
 1764: 
 4435:     NS_ASSERTION(numJustifiableCharacters <= charsFit,
 5618:                  "Bad justifiable character count");
51483:     aLineLayout.SetTextJustificationWeights(numJustifiableCharacters,
 4435:         charsFit - numJustifiableCharacters);
    1:   }
    1: 
51483:   SetLength(contentLength, &aLineLayout);
    1: 
30695:   if (mContent->HasFlag(NS_TEXT_IN_SELECTION)) {
30695:     SelectionDetails* details = GetSelectionDetails();
30695:     if (details) {
30695:       AddStateBits(NS_FRAME_SELECTED_CONTENT);
30695:       DestroySelectionDetails(details);
30695:     } else {
30695:       RemoveStateBits(NS_FRAME_SELECTED_CONTENT);
30695:     }
30695:   }
30695: 
55039:   Invalidate(aMetrics.VisualOverflow());
    1: 
    1: #ifdef NOISY_REFLOW
    1:   ListTag(stdout);
    1:   printf(": desiredSize=%d,%d(b=%d) status=%x\n",
    1:          aMetrics.width, aMetrics.height, aMetrics.ascent,
    1:          aStatus);
    1: #endif
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsTextFrame::CanContinueTextRun() const
    1: {
    1:   // We can continue a text run through a text frame
    1:   return PR_TRUE;
    1: }
    1: 
 8514: nsTextFrame::TrimOutput
 8514: nsTextFrame::TrimTrailingWhiteSpace(nsIRenderingContext* aRC)
 8514: {
 8514:   TrimOutput result;
 8514:   result.mChanged = PR_FALSE;
 8514:   result.mLastCharIsJustifiable = PR_FALSE;
 8514:   result.mDeltaWidth = 0;
    1: 
    1:   AddStateBits(TEXT_END_OF_LINE);
    1: 
 4678:   PRInt32 contentLength = GetContentLength();
 4678:   if (!contentLength)
 8514:     return result;
    1: 
 9438:   gfxContext* ctx = aRC->ThebesContext();
 6862:   gfxSkipCharsIterator start = EnsureTextRun(ctx);
 8514:   NS_ENSURE_TRUE(mTextRun, result);
 8514: 
 2319:   PRUint32 trimmedStart = start.GetSkippedOffset();
    1: 
35581:   const nsTextFragment* frag = mContent->GetText();
    8:   TrimmedOffsets trimmed = GetTrimmedOffsets(frag, PR_TRUE);
 8514:   gfxSkipCharsIterator trimmedEndIter = start;
    1:   const nsStyleText* textStyle = GetStyleText();
    1:   gfxFloat delta = 0;
 8514:   PRUint32 trimmedEnd = trimmedEndIter.ConvertOriginalToSkipped(trimmed.GetEnd());
    8:   
    8:   if (GetStateBits() & TEXT_TRIMMED_TRAILING_WHITESPACE) {
 8514:     // We pre-trimmed this frame, so the last character is justifiable
 8514:     result.mLastCharIsJustifiable = PR_TRUE;
 4261:   } else if (trimmed.GetEnd() < GetContentEnd()) {
 8514:     gfxSkipCharsIterator end = trimmedEndIter;
 4678:     PRUint32 endOffset = end.ConvertOriginalToSkipped(GetContentOffset() + contentLength);
    8:     if (trimmedEnd < endOffset) {
 1732:       // We can't be dealing with tabs here ... they wouldn't be trimmed. So it's
 1732:       // OK to pass null for the line container.
 4678:       PropertyProvider provider(mTextRun, textStyle, frag, this, start, contentLength,
 1732:                                 nsnull, 0);
    8:       delta = mTextRun->GetAdvanceWidth(trimmedEnd, endOffset - trimmedEnd, &provider);
    1:       // non-compressed whitespace being skipped at end of line -> justifiable
    1:       // XXX should we actually *count* justifiable characters that should be
    8:       // removed from the overall count? I think so...
 8514:       result.mLastCharIsJustifiable = PR_TRUE;
 8514:       result.mChanged = PR_TRUE;
 8514:     }
 8514:   }
 8514: 
 8514:   if (!result.mLastCharIsJustifiable &&
16575:       (GetStateBits() & TEXT_JUSTIFICATION_ENABLED)) {
    1:     // Check if any character in the last cluster is justifiable
 4678:     PropertyProvider provider(mTextRun, textStyle, frag, this, start, contentLength,
 1732:                               nsnull, 0);
38492:     PRBool isCJK = IsChineseOrJapanese(this);
 8514:     gfxSkipCharsIterator justificationStart(start), justificationEnd(trimmedEndIter);
 7076:     provider.FindJustificationRange(&justificationStart, &justificationEnd);
    1: 
    1:     PRInt32 i;
 4261:     for (i = justificationEnd.GetOriginalOffset(); i < trimmed.GetEnd(); ++i) {
    1:       if (IsJustifiableCharacter(frag, i, isCJK)) {
 8514:         result.mLastCharIsJustifiable = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   gfxFloat advanceDelta;
    1:   mTextRun->SetLineBreaks(trimmedStart, trimmedEnd - trimmedStart,
    1:                           (GetStateBits() & TEXT_START_OF_LINE) != 0, PR_TRUE,
 2834:                           &advanceDelta, ctx);
 8514:   if (advanceDelta != 0) {
 8514:     result.mChanged = PR_TRUE;
 8514:   }
    1: 
    1:   // aDeltaWidth is *subtracted* from our width.
    1:   // If advanceDelta is positive then setting the line break made us longer,
    1:   // so aDeltaWidth could go negative.
 8514:   result.mDeltaWidth = NSToCoordFloor(delta - advanceDelta);
 8514:   // If aDeltaWidth goes negative, that means this frame might not actually fit
 8514:   // anymore!!! We need higher level line layout to recover somehow.
 8514:   // If it's because the frame has a soft hyphen that is now being displayed,
 8514:   // this should actually be OK, because our reflow recorded the break
 8514:   // opportunity that allowed the soft hyphen to be used, and we wouldn't
 8514:   // have recorded the opportunity unless the hyphen fit (or was the first
 8514:   // opportunity on the line).
 8514:   // Otherwise this can/ really only happen when we have glyphs with special
 8514:   // shapes at the end of lines, I think. Breaking inside a kerning pair won't
 8514:   // do it because that would mean we broke inside this textrun, and
 8514:   // BreakAndMeasureText should make sure the resulting shaped substring fits.
 8514:   // Maybe if we passed a maxTextLength? But that only happens at direction
 8514:   // changes (so we wouldn't kern across the boundary) or for first-letter
 8514:   // (which always fits because it starts the line!).
16578:   NS_WARN_IF_FALSE(result.mDeltaWidth >= 0,
16578:                    "Negative deltawidth, something odd is happening");
    1: 
    1: #ifdef NOISY_TRIM
    1:   ListTag(stdout);
 8514:   printf(": trim => %d\n", result.mDeltaWidth);
    1: #endif
 8514:   return result;
    1: }
    1: 
55028: nsOverflowAreas
55028: nsTextFrame::RecomputeOverflow()
55028: {
55028:   nsRect bounds(nsPoint(0, 0), GetSize());
55028:   nsOverflowAreas result(bounds, bounds);
55028: 
 6247:   gfxSkipCharsIterator iter = EnsureTextRun();
 6247:   if (!mTextRun)
55028:     return result;
 6247: 
 6247:   PropertyProvider provider(this, iter);
 6247:   provider.InitializeForDisplay(PR_TRUE);
 6247: 
 6247:   gfxTextRun::Metrics textMetrics =
 6247:     mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
25417:                           ComputeTransformedLength(provider),
25417:                           gfxFont::LOOSE_INK_EXTENTS, nsnull,
 6247:                           &provider);
 6247: 
55028:   nsRect &vis = result.VisualOverflow();
55028:   vis.UnionRect(vis, RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent));
55028: 
55028:   UnionTextDecorationOverflow(PresContext(), provider, &vis);
55028: 
55028:   return result;
 6247: }
 6247: 
 4261: static PRUnichar TransformChar(const nsStyleText* aStyle, gfxTextRun* aTextRun,
 4261:                                PRUint32 aSkippedOffset, PRUnichar aChar)
 4261: {
16575:   if (aChar == '\n') {
16575:     return aStyle->NewlineIsSignificant() ? aChar : ' ';
 4261:   }
 4261:   switch (aStyle->mTextTransform) {
 4261:   case NS_STYLE_TEXT_TRANSFORM_LOWERCASE:
48377:     aChar = ToLowerCase(aChar);
 4261:     break;
 4261:   case NS_STYLE_TEXT_TRANSFORM_UPPERCASE:
48377:     aChar = ToUpperCase(aChar);
 4261:     break;
 4261:   case NS_STYLE_TEXT_TRANSFORM_CAPITALIZE:
 4261:     if (aTextRun->CanBreakLineBefore(aSkippedOffset)) {
48377:       aChar = ToTitleCase(aChar);
 4261:     }
 4261:     break;
 4261:   }
 4261: 
 4261:   return aChar;
 4261: }
 4261: 
 4261: nsresult nsTextFrame::GetRenderedText(nsAString* aAppendToString,
 4261:                                       gfxSkipChars* aSkipChars,
 4261:                                       gfxSkipCharsIterator* aSkipIter,
 4261:                                       PRUint32 aSkippedStartOffset,
 4261:                                       PRUint32 aSkippedMaxLength)
 4261: {
 4261:   // The handling of aSkippedStartOffset and aSkippedMaxLength could be more efficient...
 4261:   gfxSkipCharsBuilder skipCharsBuilder;
 4261:   nsTextFrame* textFrame;
35581:   const nsTextFragment* textFrag = mContent->GetText();
 4678:   PRUint32 keptCharsLength = 0;
 4678:   PRUint32 validCharsLength = 0;
 4261: 
 4261:   // Build skipChars and copy text, for each text frame in this continuation block
 4261:   for (textFrame = this; textFrame;
 4261:        textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation())) {
 4261:     // For each text frame continuation in this block ...
 4261: 
 4261:     // Ensure the text run and grab the gfxSkipCharsIterator for it
 4261:     gfxSkipCharsIterator iter = textFrame->EnsureTextRun();
 4261:     if (!textFrame->mTextRun)
 4261:       return NS_ERROR_FAILURE;
 4261: 
 4261:     // Skip to the start of the text run, past ignored chars at start of line
 4261:     // XXX In the future we may decide to trim extra spaces before a hard line
 4261:     // break, in which case we need to accurately detect those sitations and 
 4261:     // call GetTrimmedOffsets() with PR_TRUE to trim whitespace at the line's end
 4261:     TrimmedOffsets trimmedContentOffsets = textFrame->GetTrimmedOffsets(textFrag, PR_FALSE);
 4261:     PRInt32 startOfLineSkipChars = trimmedContentOffsets.mStart - textFrame->mContentOffset;
 4261:     if (startOfLineSkipChars > 0) {
 4261:       skipCharsBuilder.SkipChars(startOfLineSkipChars);
 4261:       iter.SetOriginalOffset(trimmedContentOffsets.mStart);
 4261:     }
 4261: 
 4261:     // Keep and copy the appropriate chars withing the caller's requested range
 4261:     const nsStyleText* textStyle = textFrame->GetStyleText();
 4261:     while (iter.GetOriginalOffset() < trimmedContentOffsets.GetEnd() &&
 4261:            keptCharsLength < aSkippedMaxLength) {
 4261:       // For each original char from content text
 4261:       if (iter.IsOriginalCharSkipped() || ++validCharsLength <= aSkippedStartOffset) {
 4261:         skipCharsBuilder.SkipChar();
 4261:       } else {
 4261:         ++keptCharsLength;
 4261:         skipCharsBuilder.KeepChar();
 4261:         if (aAppendToString) {
 4261:           aAppendToString->Append(
 4261:               TransformChar(textStyle, textFrame->mTextRun, iter.GetSkippedOffset(),
 4261:                             textFrag->CharAt(iter.GetOriginalOffset())));
 4261:         }
 4261:       }
 4261:       iter.AdvanceOriginal(1);
 4261:     }
 4261:     if (keptCharsLength >= aSkippedMaxLength) {
 4261:       break; // Already past the end, don't build string or gfxSkipCharsIter anymore
 4261:     }
 4261:   }
 4261:   
 4261:   if (aSkipChars) {
 4261:     aSkipChars->TakeFrom(&skipCharsBuilder); // Copy skipChars into aSkipChars
 4261:     if (aSkipIter) {
 4261:       // Caller must provide both pointers in order to retrieve a gfxSkipCharsIterator,
 4261:       // because the gfxSkipCharsIterator holds a weak pointer to the gfxSkipCars.
 4261:       *aSkipIter = gfxSkipCharsIterator(*aSkipChars, GetContentLength());
 4261:     }
 4261:   }
 4261: 
 4261:   return NS_OK;
 4261: }
 4261: 
    1: #ifdef DEBUG
    1: // Translate the mapped content into a string that's printable
    1: void
 8252: nsTextFrame::ToCString(nsCString& aBuf, PRInt32* aTotalContentLength) const
    1: {
    1:   // Get the frames text content
35581:   const nsTextFragment* frag = mContent->GetText();
    1:   if (!frag) {
    1:     return;
    1:   }
    1: 
    1:   // Compute the total length of the text content.
    1:   *aTotalContentLength = frag->GetLength();
    1: 
 4678:   PRInt32 contentLength = GetContentLength();
    1:   // Set current fragment and current fragment offset
 4678:   if (0 == contentLength) {
    1:     return;
    1:   }
 4678:   PRInt32 fragOffset = GetContentOffset();
 4678:   PRInt32 n = fragOffset + contentLength;
    1:   while (fragOffset < n) {
    1:     PRUnichar ch = frag->CharAt(fragOffset++);
    1:     if (ch == '\r') {
    1:       aBuf.AppendLiteral("\\r");
    1:     } else if (ch == '\n') {
    1:       aBuf.AppendLiteral("\\n");
    1:     } else if (ch == '\t') {
    1:       aBuf.AppendLiteral("\\t");
    1:     } else if ((ch < ' ') || (ch >= 127)) {
 8252:       aBuf.Append(nsPrintfCString("\\u%04x", ch));
    1:     } else {
    1:       aBuf.Append(ch);
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsTextFrame::GetType() const
    1: {
    1:   return nsGkAtoms::textFrame;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsTextFrame::IsEmpty()
    1: {
    1:   NS_ASSERTION(!(mState & TEXT_IS_ONLY_WHITESPACE) ||
    1:                !(mState & TEXT_ISNOT_ONLY_WHITESPACE),
    1:                "Invalid state");
    1:   
    1:   // XXXldb Should this check compatibility mode as well???
16575:   const nsStyleText* textStyle = GetStyleText();
16575:   if (textStyle->WhiteSpaceIsSignificant()) {
16575:     // XXX shouldn't we return true if the length is zero?
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (mState & TEXT_ISNOT_ONLY_WHITESPACE) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (mState & TEXT_IS_ONLY_WHITESPACE) {
    1:     return PR_TRUE;
    1:   }
    1:   
35581:   PRBool isEmpty = IsAllWhitespace(mContent->GetText(),
16575:           textStyle->mWhiteSpace != NS_STYLE_WHITESPACE_PRE_LINE);
    1:   mState |= (isEmpty ? TEXT_IS_ONLY_WHITESPACE : TEXT_ISNOT_ONLY_WHITESPACE);
    1:   return isEmpty;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsTextFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Text"), aResult);
    1: }
    1: 
    1: NS_IMETHODIMP_(nsFrameState)
    1: nsTextFrame::GetDebugStateBits() const
    1: {
    1:   // mask out our emptystate flags; those are just caches
    1:   return nsFrame::GetDebugStateBits() &
    1:     ~(TEXT_WHITESPACE_FLAGS | TEXT_REFLOW_FLAGS);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Output the tag
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
    1:   fprintf(out, " [parent=%p]", mParent);
    1: #endif
    1:   if (HasView()) {
 3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
    1:   }
    1: 
    1:   PRInt32 totalContentLength;
 8252:   nsCAutoString tmp;
    1:   ToCString(tmp, &totalContentLength);
    1: 
    1:   // Output the first/last content offset and prev/next in flow info
 3118:   PRBool isComplete = GetContentEnd() == totalContentLength;
    1:   fprintf(out, "[%d,%d,%c] ", 
 4678:           GetContentOffset(), GetContentLength(),
    1:           isComplete ? 'T':'F');
    1:   
32845:   if (GetNextSibling()) {
32845:     fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
    1:   }
    1:   nsIFrame* prevContinuation = GetPrevContinuation();
    1:   if (nsnull != prevContinuation) {
 3233:     fprintf(out, " prev-continuation=%p", static_cast<void*>(prevContinuation));
    1:   }
    1:   if (nsnull != mNextContinuation) {
 3233:     fprintf(out, " next-continuation=%p", static_cast<void*>(mNextContinuation));
    1:   }
    1: 
    1:   // Output the rect and state
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
    1:     if (mState & NS_FRAME_SELECTED_CONTENT) {
43479:       fprintf(out, " [state=%016llx] SELECTED", mState);
    1:     } else {
43479:       fprintf(out, " [state=%016llx]", mState);
    1:     }
    1:   }
 3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
55040:   if (HasOverflowAreas()) {
55040:     nsRect overflowArea = GetVisualOverflowRect();
55040:     fprintf(out, " [vis-overflow=%d,%d,%d,%d]",
55040:             overflowArea.x, overflowArea.y,
55040:             overflowArea.width, overflowArea.height);
55040:     overflowArea = GetScrollableOverflowRect();
55040:     fprintf(out, " [scr-overflow=%d,%d,%d,%d]",
55040:             overflowArea.x, overflowArea.y,
11909:             overflowArea.width, overflowArea.height);
 6247:   }
 3233:   fprintf(out, " sc=%p", static_cast<void*>(mStyleContext));
34387:   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
    1:   if (pseudoTag) {
    1:     nsAutoString atomString;
    1:     pseudoTag->ToString(atomString);
    1:     fprintf(out, " pst=%s",
    1:             NS_LossyConvertUTF16toASCII(atomString).get());
    1:   }
    1:   fputs("<\n", out);
    1: 
    1:   // Output the text
    1:   aIndent++;
    1: 
    1:   IndentBy(out, aIndent);
    1:   fputs("\"", out);
 8252:   fputs(tmp.get(), out);
    1:   fputs("\"\n", out);
    1: 
    1:   aIndent--;
    1:   IndentBy(out, aIndent);
    1:   fputs(">\n", out);
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: void
    1: nsTextFrame::AdjustOffsetsForBidi(PRInt32 aStart, PRInt32 aEnd)
    1: {
    1:   AddStateBits(NS_FRAME_IS_BIDI);
 4678: 
 5307:   /*
 5307:    * After Bidi resolution we may need to reassign text runs.
 5307:    * This is called during bidi resolution from the block container, so we
 5307:    * shouldn't be holding a local reference to a textrun anywhere.
 5307:    */
 5307:   ClearTextRun();
 5307: 
 6383:   nsTextFrame* prev = static_cast<nsTextFrame*>(GetPrevContinuation());
 4678:   if (prev) {
 4678:     // the bidi resolver can be very evil when columns/pages are involved. Don't
 4678:     // let it violate our invariants.
 4678:     PRInt32 prevOffset = prev->GetContentOffset();
32531:     aStart = NS_MAX(aStart, prevOffset);
32531:     aEnd = NS_MAX(aEnd, prevOffset);
 5307:     prev->ClearTextRun();
 4678:   }
 9810: 
 4678:   mContentOffset = aStart;
34012:   SetLength(aEnd - aStart, nsnull);
    1: }
    1: 
    1: /**
    1:  * @return PR_TRUE if this text frame ends with a newline character.  It should return
    1:  * PR_FALSE if it is not a text frame.
    1:  */
    1: PRBool
    1: nsTextFrame::HasTerminalNewline() const
    1: {
 3009:   return ::HasTerminalNewline(this);
 3009: }
 7677: 
 7677: PRBool
 7677: nsTextFrame::IsAtEndOfLine() const
 7677: {
 7677:   return (GetStateBits() & TEXT_END_OF_LINE) != 0;
 7677: }
53735: 
53735: PRBool
53735: nsTextFrame::HasAnyNoncollapsedCharacters()
53735: {
53735:   gfxSkipCharsIterator iter = EnsureTextRun();
53735:   PRInt32 offset = GetContentOffset(),
53735:           offsetEnd = GetContentEnd();
53735:   PRInt32 skippedOffset = iter.ConvertOriginalToSkipped(offset);
53735:   PRInt32 skippedOffsetEnd = iter.ConvertOriginalToSkipped(offsetEnd);
53735:   return skippedOffset != skippedOffsetEnd;
53735: }
