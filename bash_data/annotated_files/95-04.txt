 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is the Mozilla SVG project.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Crocodile Clips Ltd..
 1:  * Portions created by the Initial Developer are Copyright (C) 2001
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
 1:  *   Jonathan Watt <jonathan.watt@strath.ac.uk>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: 
 1: #include "nsGkAtoms.h"
 1: #include "nsSVGLength.h"
 1: #include "nsSVGAngle.h"
 1: #include "nsCOMPtr.h"
 1: #include "nsIPresShell.h"
 1: #include "nsIDocument.h"
 1: #include "nsPresContext.h"
 1: #include "nsSVGAnimatedRect.h"
 1: #include "nsSVGAnimatedPreserveAspectRatio.h"
 1: #include "nsSVGMatrix.h"
 1: #include "nsSVGPoint.h"
 1: #include "nsSVGTransform.h"
 1: #include "nsIDOMEventTarget.h"
 1: #include "nsBindingManager.h"
 1: #include "nsIFrame.h"
 1: #include "nsISVGSVGFrame.h" //XXX
 1: #include "nsSVGNumber.h"
 1: #include "nsSVGRect.h"
 1: #include "nsSVGPreserveAspectRatio.h"
 1: #include "nsISVGValueUtils.h"
 1: #include "nsDOMError.h"
 1: #include "nsSVGEnum.h"
 1: #include "nsISVGChildFrame.h"
 1: #include "nsGUIEvent.h"
 1: #include "nsSVGUtils.h"
 1: #include "nsSVGSVGElement.h"
 1: 
 1: nsSVGElement::LengthInfo nsSVGSVGElement::sLengthInfo[4] =
 1: {
 1:   { &nsGkAtoms::x, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::X },
 1:   { &nsGkAtoms::y, 0, nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER, nsSVGUtils::Y },
 1:   { &nsGkAtoms::width, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::X },
 1:   { &nsGkAtoms::height, 100, nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE, nsSVGUtils::Y },
 1: };
 1: 
 1: NS_IMPL_NS_NEW_SVG_ELEMENT(SVG)
 1: 
 1: //----------------------------------------------------------------------
 1: // nsISupports methods
 1: 
 1: NS_IMPL_ADDREF_INHERITED(nsSVGSVGElement,nsSVGSVGElementBase)
 1: NS_IMPL_RELEASE_INHERITED(nsSVGSVGElement,nsSVGSVGElementBase)
 1: 
 1: NS_INTERFACE_MAP_BEGIN(nsSVGSVGElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNode)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGSVGElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGFitToViewBox)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGLocatable)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGZoomAndPan)
 1:   NS_INTERFACE_MAP_ENTRY(nsISVGSVGElement)
 1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(SVGSVGElement)
 1: NS_INTERFACE_MAP_END_INHERITING(nsSVGSVGElementBase)
 1: 
 1: //----------------------------------------------------------------------
 1: // Implementation
 1: 
 1: nsSVGSVGElement::nsSVGSVGElement(nsINodeInfo* aNodeInfo)
 1:   : nsSVGSVGElementBase(aNodeInfo),
 1:     mCoordCtx(nsnull),
 1:     mCoordCtxMmPerPx(0),
 1:     mRedrawSuspendCount(0)
 1: {
 1: }
 1: 
 1: nsSVGSVGElement::~nsSVGSVGElement()
 1: {
 1:   if (mPreserveAspectRatio) {
 1:     NS_REMOVE_SVGVALUE_OBSERVER(mPreserveAspectRatio);
 1:   }
 1:   if (mViewBox) {
 1:     NS_REMOVE_SVGVALUE_OBSERVER(mViewBox);
 1:   }
 1: }
 1: 
 1:   
 1: nsresult
 1: nsSVGSVGElement::Init()
 1: {
 1:   nsresult rv = nsSVGSVGElementBase::Init();
 1:   NS_ENSURE_SUCCESS(rv,rv);
 1:   
 1:   // nsIDOMSVGFitToViewBox attributes ------:
 1:   
 1:   // DOM property: viewBox , #IMPLIED attrib: viewBox
 1:   {
 1:     nsCOMPtr<nsIDOMSVGRect> viewbox;
 1:     rv = NS_NewSVGRect(getter_AddRefs(viewbox));
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     rv = NS_NewSVGAnimatedRect(getter_AddRefs(mViewBox), viewbox);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     rv = AddMappedSVGValue(nsGkAtoms::viewBox, mViewBox);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:   }
 1: 
 1:   // DOM property: preserveAspectRatio , #IMPLIED attrib: preserveAspectRatio
 1:   {
 1:     nsCOMPtr<nsIDOMSVGPreserveAspectRatio> preserveAspectRatio;
 1:     rv = NS_NewSVGPreserveAspectRatio(getter_AddRefs(preserveAspectRatio));
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     rv = NS_NewSVGAnimatedPreserveAspectRatio(
 1:                                           getter_AddRefs(mPreserveAspectRatio),
 1:                                           preserveAspectRatio);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     rv = AddMappedSVGValue(nsGkAtoms::preserveAspectRatio,
 1:                            mPreserveAspectRatio);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:   }
 1:   
 1:   // nsIDOMSVGZoomAndPan attribute ------:
 1: 
 1:   // Define enumeration mappings
 1:   static struct nsSVGEnumMapping zoomMap[] = {
 1:         {&nsGkAtoms::disable, nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_DISABLE},
 1:         {&nsGkAtoms::magnify, nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY},
 1:         {nsnull, 0}
 1:   };
 1: 
 1:   // DOM property: zoomAndPan ,  #IMPLIED attrib: zoomAndPan
 1:   {
 1:     rv = NS_NewSVGEnum(getter_AddRefs(mZoomAndPan),
 1:                        nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY, zoomMap);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     rv = AddMappedSVGValue(nsGkAtoms::zoomAndPan, mZoomAndPan);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:   }
 1: 
 1:   // DOM property: currentScale
 1:   {
 1:     rv = NS_NewSVGNumber(getter_AddRefs(mCurrentScale), 1.0f);
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     NS_ADD_SVGVALUE_OBSERVER(mCurrentScale);
 1:   }
 1: 
 1:   // DOM property: currentTranslate
 1:   {
 1:     rv = NS_NewSVGPoint(getter_AddRefs(mCurrentTranslate));
 1:     NS_ENSURE_SUCCESS(rv,rv);
 1:     NS_ADD_SVGVALUE_OBSERVER(mCurrentTranslate);
 1:   }
 1: 
 1:   // initialise "Previous" values
 1:   RecordCurrentScaleTranslate();
 1:   mDispatchEvent = PR_TRUE;
 1: 
 1:   return rv;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMNode methods
 1: 
 1: 
 1: NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsSVGSVGElement)
 1: 
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMSVGSVGElement methods:
 1: 
 1: /* readonly attribute nsIDOMSVGAnimatedLength x; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetX(nsIDOMSVGAnimatedLength * *aX)
 1: {
 1:   return mLengthAttributes[X].ToDOMAnimatedLength(aX, this);
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGAnimatedLength y; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetY(nsIDOMSVGAnimatedLength * *aY)
 1: {
 1:   return mLengthAttributes[Y].ToDOMAnimatedLength(aY, this);
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGAnimatedLength width; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetWidth(nsIDOMSVGAnimatedLength * *aWidth)
 1: {
 1:   return mLengthAttributes[WIDTH].ToDOMAnimatedLength(aWidth, this);
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGAnimatedLength height; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetHeight(nsIDOMSVGAnimatedLength * *aHeight)
 1: {
 1:   return mLengthAttributes[HEIGHT].ToDOMAnimatedLength(aHeight, this);
 1: }
 1: 
 1: /* attribute DOMString contentScriptType; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetContentScriptType(nsAString & aContentScriptType)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetContentScriptType");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetContentScriptType(const nsAString & aContentScriptType)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetContentScriptType");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* attribute DOMString contentStyleType; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetContentStyleType(nsAString & aContentStyleType)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetContentStyleType");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetContentStyleType(const nsAString & aContentStyleType)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetContentStyleType");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGRect viewport; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetViewport(nsIDOMSVGRect * *aViewport)
 1: {
 1:   // XXX
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* readonly attribute float pixelUnitToMillimeterX; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetPixelUnitToMillimeterX(float *aPixelUnitToMillimeterX)
 1: {
 1:   // to correctly determine this, the caller would need to pass in the
 1:   // right PresContext...
 1: 
 1:   *aPixelUnitToMillimeterX = 0.28f; // 90dpi
 1: 
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc) return NS_OK;
 1:   // Get Presentation shell 0
 1:   nsIPresShell *presShell = doc->GetShellAt(0);
 1:   if (!presShell) return NS_OK;
 1:   
 1:   // Get the Presentation Context from the Shell
 1:   nsPresContext *context = presShell->GetPresContext();
 1:   if (!context) return NS_OK;
 1: 
 1:   *aPixelUnitToMillimeterX = 25.4f / nsPresContext::AppUnitsToIntCSSPixels(context->AppUnitsPerInch());
 1:   return NS_OK;
 1: }
 1: 
 1: /* readonly attribute float pixelUnitToMillimeterY; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetPixelUnitToMillimeterY(float *aPixelUnitToMillimeterY)
 1: {
 1:   return GetPixelUnitToMillimeterX(aPixelUnitToMillimeterY);
 1: }
 1: 
 1: /* readonly attribute float screenPixelToMillimeterX; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetScreenPixelToMillimeterX(float *aScreenPixelToMillimeterX)
 1: {
 1:   // to correctly determine this, the caller would need to pass in the
 1:   // right PresContext...
 1: 
 1:   *aScreenPixelToMillimeterX = 0.28f; // 90dpi
 1: 
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc) return NS_OK;
 1:     // Get Presentation shell 0
 1:   nsIPresShell *presShell = doc->GetShellAt(0);
 1:   if (!presShell) return NS_OK;
 1:   
 1:   // Get the Presentation Context from the Shell
 1:   nsPresContext *context = presShell->GetPresContext();
 1:   if (!context) return NS_OK;
 1: 
 1:   *aScreenPixelToMillimeterX = 25.4f / context->AppUnitsToDevPixels(context->AppUnitsPerInch());
 1:   return NS_OK;
 1: }
 1: 
 1: /* readonly attribute float screenPixelToMillimeterY; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetScreenPixelToMillimeterY(float *aScreenPixelToMillimeterY)
 1: {
 1:   return GetScreenPixelToMillimeterX(aScreenPixelToMillimeterY);
 1: }
 1: 
 1: /* attribute boolean useCurrentView; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetUseCurrentView(PRBool *aUseCurrentView)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetUseCurrentView");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetUseCurrentView(PRBool aUseCurrentView)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetUseCurrentView");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGViewSpec currentView; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetCurrentView(nsIDOMSVGViewSpec * *aCurrentView)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetCurrentView");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* attribute float currentScale; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetCurrentScale(float *aCurrentScale)
 1: {
 1:   return mCurrentScale->GetValue(aCurrentScale);
 1: }
 1: 
 1: #define CURRENT_SCALE_MAX 16.0f
 1: #define CURRENT_SCALE_MIN 0.0625f
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetCurrentScale(float aCurrentScale)
 1: {
 1:   // Prevent bizarre behaviour and maxing out of CPU and memory by clamping
 1:   if (aCurrentScale < CURRENT_SCALE_MIN)
 1:     aCurrentScale = CURRENT_SCALE_MIN;
 1:   else if (aCurrentScale > CURRENT_SCALE_MAX)
 1:     aCurrentScale = CURRENT_SCALE_MAX;
 1: 
 1:   return mCurrentScale->SetValue(aCurrentScale);
 1: 
 1:   // We have to dispatch the required SVGZoom event from DidModifySVGObservable
 1:   // since dispatching it here is too late (i.e. after repaint)
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGPoint currentTranslate; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetCurrentTranslate(nsIDOMSVGPoint * *aCurrentTranslate)
 1: {
 1:   *aCurrentTranslate = mCurrentTranslate;
 1:   NS_ADDREF(*aCurrentTranslate);
 1:   return NS_OK;
 1: }
 1: 
 1: /* unsigned long suspendRedraw (in unsigned long max_wait_milliseconds); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SuspendRedraw(PRUint32 max_wait_milliseconds, PRUint32 *_retval)
 1: {
 1:   *_retval = 1;
 1: 
 1:   if (++mRedrawSuspendCount > 1) 
 1:     return NS_OK;
 1: 
 1:   nsIFrame* frame = GetPrimaryFrame();
 1: #ifdef DEBUG
 1:   // XXX We sometimes hit this assertion when the svg:svg element is
 1:   // in a binding and svg children are inserted underneath it using
 1:   // <children/>. If the svg children then call suspendRedraw, the
 1:   // above function call fails although the svg:svg's frame has been
 1:   // build. Strange...
 1:   
 1:   NS_ASSERTION(frame, "suspending redraw w/o frame");
 1: #endif
 1:   if (frame) {
 1:     nsISVGSVGFrame* svgframe;
 1:     CallQueryInterface(frame, &svgframe);
 1:     NS_ASSERTION(svgframe, "wrong frame type");
 1:     if (svgframe) {
 1:       svgframe->SuspendRedraw();
 1:     }
 1:   }
 1:   
 1:   return NS_OK;
 1: }
 1: 
 1: /* void unsuspendRedraw (in unsigned long suspend_handle_id); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::UnsuspendRedraw(PRUint32 suspend_handle_id)
 1: {
 1:   if (mRedrawSuspendCount == 0) {
 1:     NS_ASSERTION(1==0, "unbalanced suspend/unsuspend calls");
 1:     return NS_ERROR_FAILURE;
 1:   }
 1:                  
 1:   if (mRedrawSuspendCount > 1) {
 1:     --mRedrawSuspendCount;
 1:     return NS_OK;
 1:   }
 1:   
 1:   return UnsuspendRedrawAll();
 1: }
 1: 
 1: /* void unsuspendRedrawAll (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::UnsuspendRedrawAll()
 1: {
 1:   mRedrawSuspendCount = 0;
 1: 
 1:   nsIFrame* frame = GetPrimaryFrame();
 1: #ifdef DEBUG
 1:   NS_ASSERTION(frame, "unsuspending redraw w/o frame");
 1: #endif
 1:   if (frame) {
 1:     nsISVGSVGFrame* svgframe;
 1:     CallQueryInterface(frame, &svgframe);
 1:     NS_ASSERTION(svgframe, "wrong frame type");
 1:     if (svgframe) {
 1:       svgframe->UnsuspendRedraw();
 1:     }
 1:   }  
 1:   return NS_OK;
 1: }
 1: 
 1: /* void forceRedraw (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::ForceRedraw()
 1: {
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc) return NS_ERROR_FAILURE;
 1: 
 1:   doc->FlushPendingNotifications(Flush_Display);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: /* void pauseAnimations (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::PauseAnimations()
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::PauseAnimations");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* void unpauseAnimations (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::UnpauseAnimations()
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::UnpauseAnimations");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* boolean animationsPaused (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::AnimationsPaused(PRBool *_retval)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::AnimationsPaused");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* float getCurrentTime (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetCurrentTime(float *_retval)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetCurrentTime");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* void setCurrentTime (in float seconds); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetCurrentTime(float seconds)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::SetCurrentTime");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* nsIDOMNodeList getIntersectionList (in nsIDOMSVGRect rect, in nsIDOMSVGElement referenceElement); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetIntersectionList(nsIDOMSVGRect *rect,
 1:                                      nsIDOMSVGElement *referenceElement,
 1:                                      nsIDOMNodeList **_retval)
 1: {
 1:   // null check when implementing - this method can be used by scripts!
 1:   // if (!rect || !referenceElement)
 1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 1: 
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetIntersectionList");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* nsIDOMNodeList getEnclosureList (in nsIDOMSVGRect rect, in nsIDOMSVGElement referenceElement); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetEnclosureList(nsIDOMSVGRect *rect,
 1:                                   nsIDOMSVGElement *referenceElement,
 1:                                   nsIDOMNodeList **_retval)
 1: {
 1:   // null check when implementing - this method can be used by scripts!
 1:   // if (!rect || !referenceElement)
 1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 1: 
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetEnclosureList");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* boolean checkIntersection (in nsIDOMSVGElement element, in nsIDOMSVGRect rect); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CheckIntersection(nsIDOMSVGElement *element,
 1:                                    nsIDOMSVGRect *rect,
 1:                                    PRBool *_retval)
 1: {
 1:   // null check when implementing - this method can be used by scripts!
 1:   // if (!element || !rect)
 1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 1: 
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::CheckIntersection");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* boolean checkEnclosure (in nsIDOMSVGElement element, in nsIDOMSVGRect rect); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CheckEnclosure(nsIDOMSVGElement *element,
 1:                                 nsIDOMSVGRect *rect,
 1:                                 PRBool *_retval)
 1: {
 1:   // null check when implementing - this method can be used by scripts!
 1:   // if (!element || !rect)
 1:   //   return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 1: 
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::CheckEnclosure");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* void deSelectAll (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::DeSelectAll()
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::DeSelectAll");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* nsIDOMSVGNumber createSVGNumber (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGNumber(nsIDOMSVGNumber **_retval)
 1: {
 1:   return NS_NewSVGNumber(_retval);
 1: }
 1: 
 1: /* nsIDOMSVGLength createSVGLength (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGLength(nsIDOMSVGLength **_retval)
 1: {
 1:   return NS_NewSVGLength(NS_REINTERPRET_CAST(nsISVGLength**, _retval));
 1: }
 1: 
 1: /* nsIDOMSVGAngle createSVGAngle (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGAngle(nsIDOMSVGAngle **_retval)
 1: {
 1:   return NS_NewSVGAngle(_retval);
 1: }
 1: 
 1: /* nsIDOMSVGPoint createSVGPoint (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGPoint(nsIDOMSVGPoint **_retval)
 1: {
 1:   return NS_NewSVGPoint(_retval);
 1: }
 1: 
 1: /* nsIDOMSVGMatrix createSVGMatrix (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGMatrix(nsIDOMSVGMatrix **_retval)
 1: {
 1:   return NS_NewSVGMatrix(_retval);
 1: }
 1: 
 1: /* nsIDOMSVGRect createSVGRect (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGRect(nsIDOMSVGRect **_retval)
 1: {
 1:   return NS_NewSVGRect(_retval);
 1: }
 1: 
 1: /* nsIDOMSVGTransform createSVGTransform (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGTransform(nsIDOMSVGTransform **_retval)
 1: {
 1:   return NS_NewSVGTransform(_retval);
 1: }
 1: 
 1: /* nsIDOMSVGTransform createSVGTransformFromMatrix (in nsIDOMSVGMatrix matrix); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGTransformFromMatrix(nsIDOMSVGMatrix *matrix, 
 1:                                               nsIDOMSVGTransform **_retval)
 1: {
 1:   if (!matrix)
 1:     return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 1: 
 1:   nsresult rv = NS_NewSVGTransform(_retval);
 1:   if (NS_FAILED(rv))
 1:     return rv;
 1: 
 1:   (*_retval)->SetMatrix(matrix);
 1:   return NS_OK;
 1: }
 1: 
 1: /* DOMString createSVGString (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::CreateSVGString(nsAString & _retval)
 1: {
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* nsIDOMElement getElementById (in DOMString elementId); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetElementById(const nsAString & elementId, nsIDOMElement **_retval)
 1: {
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMSVGFitToViewBox methods
 1: 
 1: /* readonly attribute nsIDOMSVGAnimatedRect viewBox; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetViewBox(nsIDOMSVGAnimatedRect * *aViewBox)
 1: {
 1:   *aViewBox = mViewBox;
 1:   NS_ADDREF(*aViewBox);
 1:   return NS_OK;
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGAnimatedPreserveAspectRatio preserveAspectRatio; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetPreserveAspectRatio(nsIDOMSVGAnimatedPreserveAspectRatio * *aPreserveAspectRatio)
 1: {
 1:   *aPreserveAspectRatio = mPreserveAspectRatio;
 1:   NS_ADDREF(*aPreserveAspectRatio);
 1:   return NS_OK;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMSVGLocatable methods
 1: 
 1: /* readonly attribute nsIDOMSVGElement nearestViewportElement; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetNearestViewportElement(nsIDOMSVGElement * *aNearestViewportElement)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetNearestViewportElement");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* readonly attribute nsIDOMSVGElement farthestViewportElement; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetFarthestViewportElement(nsIDOMSVGElement * *aFarthestViewportElement)
 1: {
 1:   NS_NOTYETIMPLEMENTED("nsSVGSVGElement::GetFarthestViewportElement");
 1:   return NS_ERROR_NOT_IMPLEMENTED;
 1: }
 1: 
 1: /* nsIDOMSVGRect getBBox (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetBBox(nsIDOMSVGRect **_retval)
 1: {
 1:   *_retval = nsnull;
 1: 
 1:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
 1: 
 1:   if (frame) {
 1:     nsISVGChildFrame* svgframe;
 1:     frame->QueryInterface(NS_GET_IID(nsISVGChildFrame),(void**)&svgframe);
 1:     if (svgframe) {
 1:       svgframe->SetMatrixPropagation(PR_FALSE);
 1:       svgframe->NotifyCanvasTMChanged(PR_TRUE);
 1:       nsresult rv = svgframe->GetBBox(_retval);
 1:       svgframe->SetMatrixPropagation(PR_TRUE);
 1:       svgframe->NotifyCanvasTMChanged(PR_TRUE);
 1:       return rv;
 1:     } else {
 1:       // XXX: outer svg
 1:       return NS_ERROR_NOT_IMPLEMENTED;
 1:     }
 1:   }
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: /* nsIDOMSVGMatrix getCTM (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetCTM(nsIDOMSVGMatrix **_retval)
 1: {
 1:   nsresult rv;
 1:   *_retval = nsnull;
 1: 
 1:   // first try to get the "screen" CTM of our nearest SVG ancestor
 1: 
 1:   nsBindingManager *bindingManager = nsnull;
 1:   // XXXbz I _think_ this is right.  We want to be using the binding manager
 1:   // that would have attached the bindings that gives us our anonymous
 1:   // ancestors. That's the binding manager for the document we actually belong
 1:   // to, which is our owner doc.
 1:   nsIDocument* ownerDoc = GetOwnerDoc();
 1:   if (ownerDoc) {
 1:     bindingManager = ownerDoc->BindingManager();
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> element = this;
 1:   nsCOMPtr<nsIContent> ancestor;
 1:   unsigned short ancestorCount = 0;
 1:   nsCOMPtr<nsIDOMSVGMatrix> ancestorCTM;
 1: 
 1:   while (1) {
 1:     ancestor = nsnull;
 1:     if (bindingManager) {
 1:       // check for an anonymous ancestor first
 1:       ancestor = bindingManager->GetInsertionParent(element);
 1:     }
 1:     if (!ancestor) {
 1:       // if we didn't find an anonymous ancestor, use the explicit one
 1:       ancestor = element->GetParent();
 1:     }
 1:     if (!ancestor) {
 1:       // reached the top of our parent chain without finding an SVG ancestor
 1:       break;
 1:     }
 1: 
 1:     nsSVGSVGElement *viewportElement = QI_TO_NSSVGSVGELEMENT(ancestor);
 1:     if (viewportElement) {
 1:       rv = viewportElement->GetViewboxToViewportTransform(getter_AddRefs(ancestorCTM));
 1:       if (NS_FAILED(rv)) return rv;
 1:       break;
 1:     }
 1: 
 1:     nsCOMPtr<nsIDOMSVGLocatable> locatableElement = do_QueryInterface(ancestor);
 1:     if (locatableElement) {
 1:       rv = locatableElement->GetCTM(getter_AddRefs(ancestorCTM));
 1:       if (NS_FAILED(rv)) return rv;
 1:       break;
 1:     }
 1: 
 1:     // ancestor was not SVG content. loop until we find an SVG ancestor
 1:     element = ancestor;
 1:     ancestorCount++;
 1:   }
 1: 
 1:   // now account for our offset
 1: 
 1:   if (!ancestorCTM) {
 1:     // we didn't find an SVG ancestor
 1:     float s=1, x=0, y=0;
 1:     if (ownerDoc &&
 1:         ownerDoc->GetRootContent() == NS_STATIC_CAST(nsIContent*, this)) {
 1:       // we're the root element. get our currentScale and currentTranslate vals
 1:       mCurrentScale->GetValue(&s);
 1:       mCurrentTranslate->GetX(&x);
 1:       mCurrentTranslate->GetY(&y);
 1:     }
 1:     else {
 1:       // we're inline in some non-SVG content. get our offset from the root
 1:       GetOffsetToAncestor(nsnull, x, y);
 1:     }
 1:     rv = NS_NewSVGMatrix(getter_AddRefs(ancestorCTM), s, 0, 0, s, x, y);
 1:     if (NS_FAILED(rv)) return rv;
 1:   }
 1:   else {
 1:     // we found an SVG ancestor
 1:     float x=0, y=0;
 1:     nsCOMPtr<nsIDOMSVGMatrix> tmp;
 1:     if (ancestorCount == 0) {
 1:       // our immediate parent is an SVG element. get our 'x' and 'y' attribs.
 1:       // cast to nsSVGElement so we get our ancestor coord context.
 1:       x = mLengthAttributes[X].GetAnimValue(NS_STATIC_CAST(nsSVGElement*,
 1:                                                            this));
 1:       y = mLengthAttributes[Y].GetAnimValue(NS_STATIC_CAST(nsSVGElement*,
 1:                                                            this));
 1:     }
 1:     else {
 1:       // We have an SVG ancestor, but with non-SVG content between us
 1: #if 0
 1:       nsCOMPtr<nsIDOMSVGForeignObjectElement> foreignObject
 1:                                               = do_QueryInterface(ancestor);
 1:       if (!foreignObject) {
 1:         NS_ERROR("the none-SVG content in the parent chain between us and our "
 1:                  "SVG ancestor isn't rooted in a foreignObject element");
 1:         return NS_ERROR_FAILURE;
 1:       }
 1: #endif
 1:       // XXXjwatt: this isn't quite right since foreignObject can transform its
 1:       // content, but it's close enough until we turn foreignObject back on
 1:       GetOffsetToAncestor(ancestor, x, y);
 1:     }
 1:     rv = ancestorCTM->Translate(x, y, getter_AddRefs(tmp));
 1:     if (NS_FAILED(rv)) return rv;
 1:     ancestorCTM.swap(tmp);
 1:   }
 1: 
 1:   // finally append our viewbox transform
 1: 
 1:   nsCOMPtr<nsIDOMSVGMatrix> tmp;
 1:   rv = GetViewboxToViewportTransform(getter_AddRefs(tmp));
 1:   if (NS_FAILED(rv)) return rv;
 1:   return ancestorCTM->Multiply(tmp, _retval);  // addrefs, so we don't
 1: }
 1: 
 1: /* nsIDOMSVGMatrix getScreenCTM (); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetScreenCTM(nsIDOMSVGMatrix **_retval)
 1: {
 1:   nsresult rv;
 1:   *_retval = nsnull;
 1: 
 1:   // first try to get the "screen" CTM of our nearest SVG ancestor
 1: 
 1:   nsBindingManager *bindingManager = nsnull;
 1:   // XXXbz I _think_ this is right.  We want to be using the binding manager
 1:   // that would have attached the bindings that gives us our anonymous
 1:   // ancestors. That's the binding manager for the document we actually belong
 1:   // to, which is our owner doc.
 1:   nsIDocument* ownerDoc = GetOwnerDoc();
 1:   if (ownerDoc) {
 1:     bindingManager = ownerDoc->BindingManager();
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> element = this;
 1:   nsCOMPtr<nsIContent> ancestor;
 1:   unsigned short ancestorCount = 0;
 1:   nsCOMPtr<nsIDOMSVGMatrix> ancestorScreenCTM;
 1: 
 1:   while (1) {
 1:     ancestor = nsnull;
 1:     if (bindingManager) {
 1:       // check for an anonymous ancestor first
 1:       ancestor = bindingManager->GetInsertionParent(element);
 1:     }
 1:     if (!ancestor) {
 1:       // if we didn't find an anonymous ancestor, use the explicit one
 1:       ancestor = element->GetParent();
 1:     }
 1:     if (!ancestor) {
 1:       // reached the top of our parent chain without finding an SVG ancestor
 1:       break;
 1:     }
 1: 
 1:     nsCOMPtr<nsIDOMSVGLocatable> locatableElement = do_QueryInterface(ancestor);
 1:     if (locatableElement) {
 1:       rv = locatableElement->GetScreenCTM(getter_AddRefs(ancestorScreenCTM));
 1:       if (NS_FAILED(rv)) return rv;
 1:       break;
 1:     }
 1: 
 1:     // ancestor was not SVG content. loop until we find an SVG ancestor
 1:     element = ancestor;
 1:     ancestorCount++;
 1:   }
 1: 
 1:   // now account for our offset
 1: 
 1:   if (!ancestorScreenCTM) {
 1:     // we didn't find an SVG ancestor
 1:     float s=1, x=0, y=0;
 1:     if (ownerDoc &&
 1:         ownerDoc->GetRootContent() == NS_STATIC_CAST(nsIContent*, this)) {
 1:       // we're the root element. get our currentScale and currentTranslate vals
 1:       mCurrentScale->GetValue(&s);
 1:       mCurrentTranslate->GetX(&x);
 1:       mCurrentTranslate->GetY(&y);
 1:     }
 1:     else {
 1:       // we're inline in some non-SVG content. get our offset from the root
 1:       GetOffsetToAncestor(nsnull, x, y);
 1:     }
 1:     rv = NS_NewSVGMatrix(getter_AddRefs(ancestorScreenCTM), s, 0, 0, s, x, y);
 1:     if (NS_FAILED(rv)) return rv;
 1:   }
 1:   else {
 1:     // we found an SVG ancestor
 1:     float x=0, y=0;
 1:     nsCOMPtr<nsIDOMSVGMatrix> tmp;
 1:     if (ancestorCount == 0) {
 1:       // our immediate parent is an SVG element. get our 'x' and 'y' attribs
 1:       // cast to nsSVGElement so we get our ancestor coord context.
 1:       x = mLengthAttributes[X].GetAnimValue(NS_STATIC_CAST(nsSVGElement*,
 1:                                                            this));
 1:       y = mLengthAttributes[Y].GetAnimValue(NS_STATIC_CAST(nsSVGElement*,
 1:                                                            this));
 1:     }
 1:     else {
 1:       // We have an SVG ancestor, but with non-SVG content between us
 1: #if 0
 1:       nsCOMPtr<nsIDOMSVGForeignObjectElement> foreignObject
 1:                                               = do_QueryInterface(ancestor);
 1:       if (!foreignObject) {
 1:         NS_ERROR("the none-SVG content in the parent chain between us and our "
 1:                  "SVG ancestor isn't rooted in a foreignObject element");
 1:         return NS_ERROR_FAILURE;
 1:       }
 1: #endif
 1:       // XXXjwatt: this isn't quite right since foreignObject can transform its
 1:       // content, but it's close enough until we turn foreignObject back on
 1:       GetOffsetToAncestor(ancestor, x, y);
 1:     }
 1:     rv = ancestorScreenCTM->Translate(x, y, getter_AddRefs(tmp));
 1:     if (NS_FAILED(rv)) return rv;
 1:     ancestorScreenCTM.swap(tmp);
 1:   }
 1: 
 1:   // finally append our viewbox transform
 1: 
 1:   nsCOMPtr<nsIDOMSVGMatrix> tmp;
 1:   rv = GetViewboxToViewportTransform(getter_AddRefs(tmp));
 1:   if (NS_FAILED(rv)) return rv;
 1:   return ancestorScreenCTM->Multiply(tmp, _retval);  // addrefs, so we don't
 1: }
 1: 
 1: /* nsIDOMSVGMatrix getTransformToElement (in nsIDOMSVGElement element); */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetTransformToElement(nsIDOMSVGElement *element,
 1:                                        nsIDOMSVGMatrix **_retval)
 1: {
 1:   if (!element)
 1:     return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
 1: 
 1:   nsresult rv;
 1:   *_retval = nsnull;
 1:   nsCOMPtr<nsIDOMSVGMatrix> ourScreenCTM;
 1:   nsCOMPtr<nsIDOMSVGMatrix> targetScreenCTM;
 1:   nsCOMPtr<nsIDOMSVGMatrix> tmp;
 1:   nsCOMPtr<nsIDOMSVGLocatable> target = do_QueryInterface(element, &rv);
 1:   if (NS_FAILED(rv)) return rv;
 1: 
 1:   // the easiest way to do this (if likely to increase rounding error):
 1:   rv = GetScreenCTM(getter_AddRefs(ourScreenCTM));
 1:   if (NS_FAILED(rv)) return rv;
 1:   rv = target->GetScreenCTM(getter_AddRefs(targetScreenCTM));
 1:   if (NS_FAILED(rv)) return rv;
 1:   rv = targetScreenCTM->Inverse(getter_AddRefs(tmp));
 1:   if (NS_FAILED(rv)) return rv;
 1:   return tmp->Multiply(ourScreenCTM, _retval);  // addrefs, so we don't
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMSVGZoomAndPan methods
 1: 
 1: /* attribute unsigned short zoomAndPan; */
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetZoomAndPan(PRUint16 *aZoomAndPan)
 1: {
 1:   return mZoomAndPan->GetIntegerValue(*aZoomAndPan);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetZoomAndPan(PRUint16 aZoomAndPan)
 1: {
 1:   if (aZoomAndPan == nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_DISABLE ||
 1:       aZoomAndPan == nsIDOMSVGZoomAndPan::SVG_ZOOMANDPAN_MAGNIFY)
 1:     return mZoomAndPan->SetIntegerValue(aZoomAndPan);
 1: 
 1:   return NS_ERROR_DOM_SVG_INVALID_VALUE_ERR;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsISVGSVGElement methods:
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetCurrentScaleNumber(nsIDOMSVGNumber **aResult)
 1: {
 1:   *aResult = mCurrentScale;
 1:   NS_ADDREF(*aResult);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::GetZoomAndPanEnum(nsISVGEnum **aResult)
 1: {
 1:   *aResult = mZoomAndPan;
 1:   NS_ADDREF(*aResult);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetCurrentScaleTranslate(float s, float x, float y)
 1: {
 1:   RecordCurrentScaleTranslate();
 1:   mDispatchEvent = PR_FALSE;
 1:   SetCurrentScale(s);  // clamps! don't call mCurrentScale->SetValue() directly
 1:   mCurrentTranslate->SetX(x);
 1:   mCurrentTranslate->SetY(y);
 1:   mDispatchEvent = PR_TRUE;
 1: 
 1:   // now dispatch an SVGZoom event if we are the root element
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (doc) {
95:     nsCOMPtr<nsIPresShell> presShell = doc->GetShellAt(0);
 1:     NS_ASSERTION(presShell, "no presShell");
 1:     if (presShell &&
 1:         doc->GetRootContent() == NS_STATIC_CAST(nsIContent*, this)) {
 1:       nsEventStatus status = nsEventStatus_eIgnore;
 1:       nsGUIEvent event(PR_TRUE, NS_SVG_ZOOM, 0);
 1:       event.eventStructType = NS_SVGZOOM_EVENT;
 1:       presShell->HandleDOMEventWithTarget(this, &event, &status);
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::SetCurrentTranslate(float x, float y)
 1: {
 1:   RecordCurrentScaleTranslate();
 1:   mDispatchEvent = PR_FALSE;
 1:   mCurrentTranslate->SetX(x);
 1:   mCurrentTranslate->SetY(y);
 1:   mDispatchEvent = PR_TRUE;
 1: 
 1:   // now dispatch an SVGScroll event if we are the root element
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (doc) {
95:     nsCOMPtr<nsIPresShell> presShell = doc->GetShellAt(0);
 1:     NS_ASSERTION(presShell, "no presShell");
 1:     if (presShell &&
 1:         doc->GetRootContent() == NS_STATIC_CAST(nsIContent*, this)) {
 1:       nsEventStatus status = nsEventStatus_eIgnore;
 1:       nsEvent event(PR_TRUE, NS_SVG_SCROLL);
 1:       event.eventStructType = NS_SVG_EVENT;
 1:       presShell->HandleDOMEventWithTarget(this, &event, &status);
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP_(void)
 1: nsSVGSVGElement::RecordCurrentScaleTranslate()
 1: {
 1:   // IMPORTANT: If either mCurrentTranslate *or* mCurrentScale is changed then
 1:   // mPreviousTranslate_x, mPreviousTranslate_y *and* mPreviousScale must all
 1:   // be updated otherwise SVGZoomEvents will end up with invalid data. I.e. an
 1:   // SVGZoomEvent's properties previousScale and previousTranslate must contain
 1:   // the state of currentScale and currentTranslate immediately before the
 1:   // change that caused the event's dispatch, which is *not* necessarily the
 1:   // same thing as the values of currentScale and currentTranslate prior to
 1:   // their own last change.
 1:   mCurrentScale->GetValue(&mPreviousScale);
 1:   mCurrentTranslate->GetX(&mPreviousTranslate_x);
 1:   mCurrentTranslate->GetY(&mPreviousTranslate_y);
 1: }
 1: 
 1: NS_IMETHODIMP_(float)
 1: nsSVGSVGElement::GetPreviousTranslate_x()
 1: {
 1:   return mPreviousTranslate_x;
 1: }
 1: 
 1: NS_IMETHODIMP_(float)
 1: nsSVGSVGElement::GetPreviousTranslate_y()
 1: {
 1:   return mPreviousTranslate_y;
 1: }
 1: 
 1: NS_IMETHODIMP_(float)
 1: nsSVGSVGElement::GetPreviousScale()
 1: {
 1:   return mPreviousScale;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIContent methods
 1: 
 1: NS_IMETHODIMP_(PRBool)
 1: nsSVGSVGElement::IsAttributeMapped(const nsIAtom* name) const
 1: {
 1:   static const MappedAttributeEntry* const map[] = {
 1:     sColorMap,
 1:     sFEFloodMap,
 1:     sFillStrokeMap,
 1:     sFiltersMap,
 1:     sFontSpecificationMap,
 1:     sGradientStopMap,
 1:     sGraphicsMap,
 1:     sMarkersMap,
 1:     sTextContentElementsMap,
 1:     sViewportsMap
 1:   };
 1: 
 1:   return FindAttributeDependence(name, map, NS_ARRAY_LENGTH(map)) ||
 1:     nsSVGSVGElementBase::IsAttributeMapped(name);
 1: }
 1: 
 1: nsresult
 1: nsSVGSVGElement::AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                               const nsAString* aValue, PRBool aNotify)
 1: {
 1:   nsSVGSVGElementBase::AfterSetAttr(aNameSpaceID, aName, aValue, aNotify);
 1: 
 1:   // We need to do this here because the calling
 1:   // InvalidateTransformNotifyFrame in DidModifySVGObservable would
 1:   // happen too early, before HasAttr(viewBox) returns true (important
 1:   // in the case of adding a viewBox)
 1:   if (aNameSpaceID == kNameSpaceID_None && aName == nsGkAtoms::viewBox) {
 1:     InvalidateTransformNotifyFrame();
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsSVGSVGElement::UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
 1:                            PRBool aNotify)
 1: {
 1:   nsSVGSVGElementBase::UnsetAttr(aNamespaceID, aName, aNotify);
 1: 
 1:   if (aNamespaceID == kNameSpaceID_None && aName == nsGkAtoms::viewBox) {
 1:     InvalidateTransformNotifyFrame();
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsISVGValueObserver methods:
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::WillModifySVGObservable(nsISVGValue* observable,
 1:                                          nsISVGValue::modificationType aModType)
 1: {
 1:   if (mDispatchEvent) {
 1:     // Modification isn't due to calling SetCurrent[Scale]Translate, so if
 1:     // currentScale or currentTranslate is about to change we must record their
 1:     // current values.
 1:     nsCOMPtr<nsIDOMSVGNumber> n = do_QueryInterface(observable);
 1:     if (n && n==mCurrentScale) {
 1:       RecordCurrentScaleTranslate();
 1:     }
 1:     else {
 1:       nsCOMPtr<nsIDOMSVGPoint> p = do_QueryInterface(observable);
 1:       if (p && p==mCurrentTranslate) {
 1:         RecordCurrentScaleTranslate();
 1:       }
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsSVGSVGElement::DidModifySVGObservable (nsISVGValue* observable,
 1:                                          nsISVGValue::modificationType aModType)
 1: {
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc) return NS_ERROR_FAILURE;
 1:   nsCOMPtr<nsIPresShell> presShell = doc->GetShellAt(0);
 1:   NS_ASSERTION(presShell, "no presShell");
 1:   if (!presShell) return NS_ERROR_FAILURE;
 1: 
 1:   // If currentScale or currentTranslate has changed, we are the root element,
 1:   // and the changes wasn't caused by SetCurrent[Scale]Translate then we must
 1:   // dispatch an SVGZoom or SVGScroll DOM event before repainting
 1:   nsCOMPtr<nsIDOMSVGNumber> n = do_QueryInterface(observable);
 1:   if (n && n==mCurrentScale) {
 1:     if (mDispatchEvent &&
 1:         doc->GetRootContent() == NS_STATIC_CAST(nsIContent*, this)) {
 1:       nsEventStatus status = nsEventStatus_eIgnore;
 1:       nsGUIEvent event(PR_TRUE, NS_SVG_ZOOM, 0);
 1:       event.eventStructType = NS_SVGZOOM_EVENT;
 1:       presShell->HandleDOMEventWithTarget(this, &event, &status);
 1:     }
 1:     else {
 1:       return NS_OK;  // we don't care about currentScale changes on non-root
 1:     }
 1:   }
 1:   else {
 1:     nsCOMPtr<nsIDOMSVGPoint> p = do_QueryInterface(observable);
 1:     if (p && p==mCurrentTranslate) {
 1:       if (mDispatchEvent &&
 1:           doc->GetRootContent() == NS_STATIC_CAST(nsIContent*, this)) {
 1:         nsEventStatus status = nsEventStatus_eIgnore;
 1:         nsEvent event(PR_TRUE, NS_SVG_SCROLL);
 1:         event.eventStructType = NS_SVG_EVENT;
 1:         presShell->HandleDOMEventWithTarget(this, &event, &status);
 1:       }
 1:       else {
 1:         return NS_OK;  // we don't care about currentScale changes on non-root
 1:       }
 1:     }
 1:   }
 1: 
 1:   // Deal with viewBox in AfterSetAttr (see comment there for reason)
 1:   nsCOMPtr<nsIDOMSVGAnimatedRect> r = do_QueryInterface(observable);
 1:   if (r != mViewBox) {
 1:     InvalidateTransformNotifyFrame();
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsSVGElement overrides
 1: 
 1: PRBool
 1: nsSVGSVGElement::IsEventName(nsIAtom* aName)
 1: {
 1:   return IsGraphicElementEventName(aName) ||
 1: 
 1:   /* The following are for events that are only applicable to outermost 'svg'
 1:      elements. We don't check if we're an outer 'svg' element in case we're not
 1:      inserted into the document yet, but since the target of the events in
 1:      question will always be the outermost 'svg' element, this shouldn't cause
 1:      any real problems.
 1:   */
 1:          aName == nsGkAtoms::onunload    ||
 1:          aName == nsGkAtoms::onscroll    ||
 1:          aName == nsGkAtoms::onzoom;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // public helpers:
 1: 
 1: nsresult
 1: nsSVGSVGElement::GetViewboxToViewportTransform(nsIDOMSVGMatrix **_retval)
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   float viewportWidth, viewportHeight;
 1:   nsSVGSVGElement *ctx = GetCtx();
 1:   if (!ctx) {
 1:     // outer svg
 1:     viewportWidth = mViewportWidth;
 1:     viewportHeight = mViewportHeight;
 1:   } else {
 1:     viewportWidth = mLengthAttributes[WIDTH].GetAnimValue(ctx);
 1:     viewportHeight = mLengthAttributes[HEIGHT].GetAnimValue(ctx);
 1:   }
 1: 
 1:   float viewboxX, viewboxY, viewboxWidth, viewboxHeight;
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::viewBox)) {
 1:     nsCOMPtr<nsIDOMSVGRect> vb;
 1:     mViewBox->GetAnimVal(getter_AddRefs(vb));
 1:     NS_ASSERTION(vb, "could not get viewbox");
 1:     vb->GetX(&viewboxX);
 1:     vb->GetY(&viewboxY);
 1:     vb->GetWidth(&viewboxWidth);
 1:     vb->GetHeight(&viewboxHeight);
 1:   } else {
 1:     viewboxX = viewboxY = 0.0f;
 1:     viewboxWidth = viewportWidth;
 1:     viewboxHeight = viewportHeight;
 1:   }
 1: 
 1:   if (viewboxWidth==0.0f || viewboxHeight==0.0f) {
 1:     NS_ERROR("XXX. We shouldn't get here. Viewbox width/height is set to 0. Need to disable display of element as per specs.");
 1:     viewboxWidth = 1.0f;
 1:     viewboxHeight = 1.0f;
 1:   }
 1: 
 1:   nsCOMPtr<nsIDOMSVGMatrix> xform =
 1:     nsSVGUtils::GetViewBoxTransform(viewportWidth, viewportHeight,
 1:                                     viewboxX, viewboxY,
 1:                                     viewboxWidth, viewboxHeight,
 1:                                     mPreserveAspectRatio);
 1:   xform.swap(*_retval);
 1: 
 1:   return rv;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // implementation helpers
 1: 
 1: // if an ancestor isn't specified, obtains offset from root frame
 1: void nsSVGSVGElement::GetOffsetToAncestor(nsIContent* ancestor,
 1:                                           float &x, float &y)
 1: {
 1:   x = 0.0f;
 1:   y = 0.0f;
 1: 
 1:   nsIDocument *document = GetCurrentDoc();
 1:   if (!document) return;
 1: 
 1:   // Flush all pending notifications so that our frames are uptodate
 1:   // Make sure to do this before we start grabbing layout objects like
 1:   // presshells.
 1:   document->FlushPendingNotifications(Flush_Layout);
 1:   
 1:   nsIPresShell *presShell = document->GetShellAt(0);
 1:   if (!presShell) {
 1:     return;
 1:   }
 1: 
 1:   nsPresContext *context = presShell->GetPresContext();
 1:   if (!context) {
 1:     return;
 1:   }
 1: 
 1:   nsIFrame* frame = presShell->GetPrimaryFrameFor(this);
 1:   nsIFrame* ancestorFrame = ancestor ?
 1:                             presShell->GetPrimaryFrameFor(ancestor) :
 1:                             presShell->GetRootFrame();
 1: 
 1:   if (frame && ancestorFrame) {
 1:     nsPoint point = frame->GetOffsetTo(ancestorFrame);
 1:     x = nsPresContext::AppUnitsToFloatCSSPixels(point.x);
 1:     y = nsPresContext::AppUnitsToFloatCSSPixels(point.y);
 1:   }
 1: }
 1: 
 1: void
 1: nsSVGSVGElement::InvalidateTransformNotifyFrame()
 1: {
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc) return;
 1:   nsIPresShell* presShell = doc->GetShellAt(0);
 1:   if (!presShell) return;
 1: 
 1:   nsIFrame* frame = presShell->GetPrimaryFrameFor(this);
 1:   if (frame) {
 1:     nsISVGSVGFrame* svgframe;
 1:     CallQueryInterface(frame, &svgframe);
 1:     if (svgframe) {
 1:       svgframe->NotifyViewportChange();
 1:     }
 1: #ifdef DEBUG
 1:     else {
 1:       // XXX we get here during nsSVGOuterSVGFrame::Init() since that
 1:       // function is called before the presshell association between us
 1:       // and our frame is established.
 1:       NS_WARNING("wrong frame type");
 1:     }
 1: #endif
 1:   }
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsSVGSVGElement
 1: 
 1: void
 1: nsSVGSVGElement::SetCoordCtxRect(nsIDOMSVGRect* aCtxRect)
 1: {
 1:   if (mLengthAttributes[WIDTH].GetSpecifiedUnitType() ==
 1:       nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE) {
 1:     aCtxRect->GetWidth(&mViewportWidth);
 1:     mViewportWidth *=
 1:       mLengthAttributes[WIDTH].GetAnimValInSpecifiedUnits() / 100.0f;
 1:   } else {
 1:     mViewportWidth = mLengthAttributes[WIDTH].GetAnimValue(this);
 1:   }
 1: 
 1:   if (mLengthAttributes[HEIGHT].GetSpecifiedUnitType() ==
 1:       nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE) {
 1:     aCtxRect->GetHeight(&mViewportHeight);
 1:     mViewportHeight *=
 1:       mLengthAttributes[HEIGHT].GetAnimValInSpecifiedUnits() / 100.0f;
 1:   } else {
 1:     mViewportHeight = mLengthAttributes[HEIGHT].GetAnimValue(this);
 1:   }
 1: }
 1: 
 1: already_AddRefed<nsIDOMSVGRect>
 1: nsSVGSVGElement::GetCtxRect() {
 1:   nsCOMPtr<nsIDOMSVGRect> vb;
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::viewBox)) {
 1:     mViewBox->GetAnimVal(getter_AddRefs(vb));
 1:   } else {
 1:     nsSVGSVGElement *ctx = GetCtx();
 1:     float w, h;
 1:     if (ctx) {
 1:       w = mLengthAttributes[WIDTH].GetAnimValue(ctx);
 1:       h = mLengthAttributes[HEIGHT].GetAnimValue(ctx);
 1:     } else {
 1:       w = mViewportWidth;
 1:       h = mViewportHeight;
 1:     }
 1:     NS_NewSVGRect(getter_AddRefs(vb), 0, 0, w, h);
 1:   }
 1: 
 1:   nsIDOMSVGRect *retval = nsnull;
 1:   vb.swap(retval);
 1:   return retval;
 1: }
 1: 
 1: float
 1: nsSVGSVGElement::GetLength(PRUint8 aCtxType) {
 1:   float h, w;
 1: 
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::viewBox)) {
 1:     nsCOMPtr<nsIDOMSVGRect> vb;
 1:     mViewBox->GetAnimVal(getter_AddRefs(vb));
 1:     vb->GetHeight(&h);
 1:     vb->GetWidth(&w);
 1:   } else {
 1:     nsSVGSVGElement *ctx = GetCtx();
 1:     if (ctx) {
 1:       w = mLengthAttributes[WIDTH].GetAnimValue(ctx);
 1:       h = mLengthAttributes[HEIGHT].GetAnimValue(ctx);
 1:     } else {
 1:       w = mViewportWidth;
 1:       h = mViewportHeight;
 1:     }
 1:   }
 1: 
 1:   switch (aCtxType) {
 1:   case nsSVGUtils::X:
 1:     return w;
 1:   case nsSVGUtils::Y:
 1:     return h;
 1:   case nsSVGUtils::XY:
 1:     return (float)sqrt((w*w+h*h)/2.0);
 1:   }
 1:   return 0;
 1: }
 1: 
 1: float
 1: nsSVGSVGElement::GetMMPerPx(PRUint8 aCtxType)
 1: {
 1:   if (mCoordCtxMmPerPx == 0.0f) {
 1:     GetScreenPixelToMillimeterX(&mCoordCtxMmPerPx);
 1:   }
 1:   return mCoordCtxMmPerPx;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsSVGElement methods
 1: 
 1: void
 1: nsSVGSVGElement::DidChangeLength(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 1: {
 1:   nsSVGSVGElementBase::DidChangeLength(aAttrEnum, aDoSetAttr);
 1: 
 1:   InvalidateTransformNotifyFrame();
 1: }
 1: 
 1: nsSVGElement::LengthAttributesInfo
 1: nsSVGSVGElement::GetLengthInfo()
 1: {
 1:   return LengthAttributesInfo(mLengthAttributes, sLengthInfo,
 1:                               NS_ARRAY_LENGTH(sLengthInfo));
 1: }
