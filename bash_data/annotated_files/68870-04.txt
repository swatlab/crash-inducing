    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessNodeWrap.h"
41384: 
41384: #include "AccessibleApplication.h"
    1: #include "ISimpleDOMNode_i.c"
41384: 
    1: #include "nsAccessibilityAtoms.h"
41384: #include "nsAccessibilityService.h"
41384: #include "nsApplicationAccessibleWrap.h"
41384: #include "nsCoreUtils.h"
41384: #include "nsRootAccessible.h"
54220: #include "nsWinUtils.h"
41384: 
 2074: #include "nsAttrName.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMNSHTMLElement.h"
68870: #include "nsIDOMViewCSS.h"
    1: #include "nsIFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: /// the accessible library and cached methods
    1: HINSTANCE nsAccessNodeWrap::gmAccLib = nsnull;
    1: HINSTANCE nsAccessNodeWrap::gmUserLib = nsnull;
    1: LPFNACCESSIBLEOBJECTFROMWINDOW nsAccessNodeWrap::gmAccessibleObjectFromWindow = nsnull;
54220: LPFNLRESULTFROMOBJECT nsAccessNodeWrap::gmLresultFromObject = NULL;
    1: LPFNNOTIFYWINEVENT nsAccessNodeWrap::gmNotifyWinEvent = nsnull;
    1: LPFNGETGUITHREADINFO nsAccessNodeWrap::gmGetGUIThreadInfo = nsnull;
    1: 
    1: PRBool nsAccessNodeWrap::gIsEnumVariantSupportDisabled = 0;
16515: // Used to determine whether an IAccessible2 compatible screen reader is loaded.
16515: PRBool nsAccessNodeWrap::gIsIA2Disabled = PR_FALSE;
    1: 
51377: AccTextChangeEvent* nsAccessNodeWrap::gTextEvent = nsnull;
 1392: 
18348: // Pref to disallow CtrlTab preview functionality if JAWS or Window-Eyes are
18348: // running.
18348: #define CTRLTAB_DISALLOW_FOR_SCREEN_READERS_PREF "browser.ctrlTab.disallowForScreenReaders"
18348: 
 2074: 
    1: /* For documentation of the accessibility architecture, 
    1:  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
    1:  */
    1: 
43504: ////////////////////////////////////////////////////////////////////////////////
43504: // nsAccessNodeWrap
43504: ////////////////////////////////////////////////////////////////////////////////
    1: 
43504: nsAccessNodeWrap::
43504:   nsAccessNodeWrap(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessNode(aContent, aShell)
    1: {
    1: }
    1: 
    1: nsAccessNodeWrap::~nsAccessNodeWrap()
    1: {
    1: }
    1: 
  966: //-----------------------------------------------------
  966: // nsISupports methods
  966: //-----------------------------------------------------
  966: 
  966: NS_IMPL_ISUPPORTS_INHERITED1(nsAccessNodeWrap, nsAccessNode, nsIWinAccessNode);
  966: 
  966: //-----------------------------------------------------
  966: // nsIWinAccessNode methods
  966: //-----------------------------------------------------
  966: 
  966: NS_IMETHODIMP
  966: nsAccessNodeWrap::QueryNativeInterface(REFIID aIID, void** aInstancePtr)
  966: {
 1000:   return QueryInterface(aIID, aInstancePtr);
  966: }
    1: 
    1: //-----------------------------------------------------
    1: // IUnknown interface methods - see iunknown.h for documentation
    1: //-----------------------------------------------------
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::QueryInterface(REFIID iid, void** ppv)
    1: {
    1:   *ppv = nsnull;
    1: 
    1:   if (IID_IUnknown == iid || IID_ISimpleDOMNode == iid)
 3233:     *ppv = static_cast<ISimpleDOMNode*>(this);
    1: 
    1:   if (nsnull == *ppv)
    1:     return E_NOINTERFACE;      //iid not supported.
    1:    
 3233:   (reinterpret_cast<IUnknown*>(*ppv))->AddRef(); 
    1:   return S_OK;
    1: }
    1: 
 5753: STDMETHODIMP
 5753: nsAccessNodeWrap::QueryService(REFGUID guidService, REFIID iid, void** ppv)
 5753: {
54665:   *ppv = nsnull;
54665: 
23797:   static const GUID IID_SimpleDOMDeprecated = {0x0c539790,0x12e4,0x11cf,0xb6,0x61,0x00,0xaa,0x00,0x4c,0xd6,0xd8};
54665: 
54665:   // Provide a special service ID for getting the accessible for the browser tab
54665:   // document that contains this accessible object. If this accessible object
54665:   // is not inside a browser tab then the service fails with E_NOINTERFACE.
54665:   // A use case for this is for screen readers that need to switch context or
54665:   // 'virtual buffer' when focus moves from one browser tab area to another.
54665:   static const GUID SID_IAccessibleContentDocument = {0xa5d8e1f3,0x3571,0x4d8f,0x95,0x21,0x07,0xed,0x28,0xfb,0x07,0x2e};
54665: 
23797:   if (guidService != IID_ISimpleDOMNode &&
23797:       guidService != IID_SimpleDOMDeprecated &&
23797:       guidService != IID_IAccessible &&  guidService != IID_IAccessible2 &&
54665:       guidService != IID_IAccessibleApplication &&
54665:       guidService != SID_IAccessibleContentDocument)
23797:     return E_INVALIDARG;
23797: 
54665:   if (guidService == SID_IAccessibleContentDocument) {
54665:     if (iid != IID_IAccessible)
54665:       return E_NOINTERFACE;
54665: 
54665:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem = 
54665:       nsCoreUtils::GetDocShellTreeItemFor(mContent);
54665:     if (!docShellTreeItem)
54665:       return E_UNEXPECTED;
54665: 
54665:     // Walk up the parent chain without crossing the boundary at which item
54665:     // types change, preventing us from walking up out of tab content.
54665:     nsCOMPtr<nsIDocShellTreeItem> root;
54665:     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
54665:     if (!root)
54665:       return E_UNEXPECTED;
54665: 
54665: 
54665:     // If the item type is typeContent, we assume we are in browser tab content.
54665:     // Note this includes content such as about:addons, for consistency.
54665:     PRInt32 itemType;
54665:     root->GetItemType(&itemType);
54665:     if (itemType != nsIDocShellTreeItem::typeContent)
54665:       return E_NOINTERFACE;
54665: 
54665:     // Make sure this is a document.
54665:     nsDocAccessible* docAcc = nsAccUtils::GetDocAccessibleFor(root);
54665:     if (!docAcc)
54665:       return E_UNEXPECTED;
54665: 
54665:     *ppv = static_cast<IAccessible*>(docAcc);
54665: 
54665:     (reinterpret_cast<IUnknown*>(*ppv))->AddRef();
54665:     return NS_OK;
54665:   }
54665: 
 5753:   // Can get to IAccessibleApplication from any node via QS
 5753:   if (iid == IID_IAccessibleApplication) {
39600:     nsApplicationAccessible *applicationAcc = GetApplicationAccessible();
39600:     if (!applicationAcc)
39600:       return E_NOINTERFACE;
39600: 
39600:     nsresult rv = applicationAcc->QueryNativeInterface(iid, ppv);
 5753:     return NS_SUCCEEDED(rv) ? S_OK : E_NOINTERFACE;
 5753:   }
 5753: 
 5753:   /**
 5753:    * To get an ISimpleDOMNode, ISimpleDOMDocument, ISimpleDOMText
 5753:    * or any IAccessible2 interface on should use IServiceProvider like this:
 5753:    * -----------------------------------------------------------------------
 5753:    * ISimpleDOMDocument *pAccDoc = NULL;
 5753:    * IServiceProvider *pServProv = NULL;
 5753:    * pAcc->QueryInterface(IID_IServiceProvider, (void**)&pServProv);
 5753:    * if (pServProv) {
 5753:    *   const GUID unused;
 5753:    *   pServProv->QueryService(unused, IID_ISimpleDOMDocument, (void**)&pAccDoc);
 5753:    *   pServProv->Release();
 5753:    * }
 5753:    */
 5753: 
 5753:   return QueryInterface(iid, ppv);
 5753: }
 5753: 
    1: //-----------------------------------------------------
    1: // ISimpleDOMNode methods
    1: //-----------------------------------------------------
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::get_nodeInfo( 
    1:     /* [out] */ BSTR __RPC_FAR *aNodeName,
    1:     /* [out] */ short __RPC_FAR *aNameSpaceID,
    1:     /* [out] */ BSTR __RPC_FAR *aNodeValue,
    1:     /* [out] */ unsigned int __RPC_FAR *aNumChildren,
    1:     /* [out] */ unsigned int __RPC_FAR *aUniqueID,
    1:     /* [out] */ unsigned short __RPC_FAR *aNodeType)
    1: {
11593: __try{
 2074:   *aNodeName = nsnull;
 2074:   *aNodeValue = nsnull;
 2074: 
43504:   if (IsDefunct())
    1:     return E_FAIL;
    1: 
43504:   nsCOMPtr<nsIDOMNode> DOMNode(do_QueryInterface(GetNode()));
    1: 
    1:   PRUint16 nodeType = 0;
43504:   DOMNode->GetNodeType(&nodeType);
 3233:   *aNodeType=static_cast<unsigned short>(nodeType);
    1: 
    1:   if (*aNodeType !=  NODETYPE_TEXT) {
    1:     nsAutoString nodeName;
43504:     DOMNode->GetNodeName(nodeName);
    1:     *aNodeName =   ::SysAllocString(nodeName.get());
    1:   }
    1: 
    1:   nsAutoString nodeValue;
    1: 
43504:   DOMNode->GetNodeValue(nodeValue);
    1:   *aNodeValue = ::SysAllocString(nodeValue.get());
43504: 
43504:   *aNameSpaceID = IsContent() ?
43504:     static_cast<short>(mContent->GetNameSpaceID()) : 0;
    1: 
    1:   // This is a unique ID for every content node.  The 3rd party
    1:   // accessibility application can compare this to the childID we
    1:   // return for events such as focus events, to correlate back to
    1:   // data nodes in their internal object model.
56292:   *aUniqueID = - NS_PTR_TO_INT32(UniqueID());
    1: 
43504:   *aNumChildren = GetNode()->GetChildCount();
    1: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: 
    1:        
    1: STDMETHODIMP nsAccessNodeWrap::get_attributes( 
    1:     /* [in] */ unsigned short aMaxAttribs,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aAttribNames,
    1:     /* [length_is][size_is][out] */ short __RPC_FAR *aNameSpaceIDs,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aAttribValues,
    1:     /* [out] */ unsigned short __RPC_FAR *aNumAttribs)
    1: {
11593: __try{
    1:   *aNumAttribs = 0;
    1: 
43504:   if (IsDefunct() || IsDocument())
    1:     return E_FAIL;
    1: 
43504:   PRUint32 numAttribs = mContent->GetAttrCount();
    1:   if (numAttribs > aMaxAttribs)
    1:     numAttribs = aMaxAttribs;
 3233:   *aNumAttribs = static_cast<unsigned short>(numAttribs);
    1: 
    1:   for (PRUint32 index = 0; index < numAttribs; index++) {
    1:     aNameSpaceIDs[index] = 0; aAttribValues[index] = aAttribNames[index] = nsnull;
    1:     nsAutoString attributeValue;
    1: 
43504:     const nsAttrName* name = mContent->GetAttrNameAt(index);
 3233:     aNameSpaceIDs[index] = static_cast<short>(name->NamespaceID());
39100:     aAttribNames[index] = ::SysAllocString(name->LocalName()->GetUTF16String());
43504:     mContent->GetAttr(name->NamespaceID(), name->LocalName(), attributeValue);
    1:     aAttribValues[index] = ::SysAllocString(attributeValue.get());
    1:   }
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK; 
    1: }
    1:         
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::get_attributesForNames( 
    1:     /* [in] */ unsigned short aNumAttribs,
    1:     /* [length_is][size_is][in] */ BSTR __RPC_FAR *aAttribNames,
    1:     /* [length_is][size_is][in] */ short __RPC_FAR *aNameSpaceID,
    1:     /* [length_is][size_is][retval] */ BSTR __RPC_FAR *aAttribValues)
    1: {
11593: __try {
64005:   if (IsDefunct() || !IsElement())
    1:     return E_FAIL;
    1: 
43504:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(mContent));
    1:   nsCOMPtr<nsINameSpaceManager> nameSpaceManager =
    1:     do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
    1: 
    1:   PRInt32 index;
    1: 
    1:   for (index = 0; index < aNumAttribs; index++) {
    1:     aAttribValues[index] = nsnull;
    1:     if (aAttribNames[index]) {
    1:       nsAutoString attributeValue, nameSpaceURI;
 3233:       nsAutoString attributeName(nsDependentString(static_cast<PRUnichar*>(aAttribNames[index])));
    1:       nsresult rv;
    1: 
    1:       if (aNameSpaceID[index]>0 && 
    1:         NS_SUCCEEDED(nameSpaceManager->GetNameSpaceURI(aNameSpaceID[index], nameSpaceURI)))
    1:           rv = domElement->GetAttributeNS(nameSpaceURI, attributeName, attributeValue);
    1:       else 
    1:         rv = domElement->GetAttribute(attributeName, attributeValue);
    1: 
    1:       if (NS_SUCCEEDED(rv))
    1:         aAttribValues[index] = ::SysAllocString(attributeValue.get());
    1:     }
    1:   }
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK; 
    1: }
    1: 
    1: /* To do: use media type if not null */
    1: STDMETHODIMP nsAccessNodeWrap::get_computedStyle( 
    1:     /* [in] */ unsigned short aMaxStyleProperties,
    1:     /* [in] */ boolean aUseAlternateView,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleProperties,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleValues,
    1:     /* [out] */ unsigned short __RPC_FAR *aNumStyleProperties)
    1: {
11593: __try{
19322:   *aNumStyleProperties = 0;
19322: 
43504:   if (IsDefunct() || IsDocument())
    1:     return E_FAIL;
    1: 
43504:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl =
43504:     nsCoreUtils::GetComputedStyleDeclaration(EmptyString(), mContent);
    1:   NS_ENSURE_TRUE(cssDecl, E_FAIL);
    1: 
    1:   PRUint32 length;
    1:   cssDecl->GetLength(&length);
    1: 
    1:   PRUint32 index, realIndex;
    1:   for (index = realIndex = 0; index < length && realIndex < aMaxStyleProperties; index ++) {
    1:     nsAutoString property, value;
    1:     if (NS_SUCCEEDED(cssDecl->Item(index, property)) && property.CharAt(0) != '-')  // Ignore -moz-* properties
    1:       cssDecl->GetPropertyValue(property, value);  // Get property value
    1:     if (!value.IsEmpty()) {
    1:       aStyleProperties[realIndex] =   ::SysAllocString(property.get());
    1:       aStyleValues[realIndex]     =   ::SysAllocString(value.get());
    1:       ++realIndex;
    1:     }
    1:   }
 3233:   *aNumStyleProperties = static_cast<unsigned short>(realIndex);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::get_computedStyleForProperties( 
    1:     /* [in] */ unsigned short aNumStyleProperties,
    1:     /* [in] */ boolean aUseAlternateView,
    1:     /* [length_is][size_is][in] */ BSTR __RPC_FAR *aStyleProperties,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleValues)
    1: {
11593: __try {
43504:   if (IsDefunct() || IsDocument())
    1:     return E_FAIL;
    1:  
43504:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl =
43504:     nsCoreUtils::GetComputedStyleDeclaration(EmptyString(), mContent);
    1:   NS_ENSURE_TRUE(cssDecl, E_FAIL);
    1: 
    1:   PRUint32 index;
    1:   for (index = 0; index < aNumStyleProperties; index ++) {
    1:     nsAutoString value;
    1:     if (aStyleProperties[index])
 3233:       cssDecl->GetPropertyValue(nsDependentString(static_cast<PRUnichar*>(aStyleProperties[index])), value);  // Get property value
    1:     aStyleValues[index] = ::SysAllocString(value.get());
    1:   }
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::scrollTo(/* [in] */ boolean aScrollTopLeft)
    1: {
11593: __try {
  497:   PRUint32 scrollType =
  497:     aScrollTopLeft ? nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT :
  497:                      nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT;
  497: 
  497:   nsresult rv = ScrollTo(scrollType);
    1:   if (NS_SUCCEEDED(rv))
    1:     return S_OK;
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return E_FAIL;
    1: }
    1: 
43504: ISimpleDOMNode*
43504: nsAccessNodeWrap::MakeAccessNode(nsINode *aNode)
20256: {
43504:   if (!aNode)
20256:     return NULL;
20256: 
20256:   nsAccessNodeWrap *newNode = NULL;
20256: 
20256:   ISimpleDOMNode *iNode = NULL;
42795:   nsAccessible *acc =
43504:     GetAccService()->GetAccessibleInWeakShell(aNode, mWeakShell);
41227:   if (acc) {
41227:     IAccessible *msaaAccessible = nsnull;
41227:     acc->GetNativeInterface((void**)&msaaAccessible); // addrefs
20256:     msaaAccessible->QueryInterface(IID_ISimpleDOMNode, (void**)&iNode); // addrefs
20256:     msaaAccessible->Release(); // Release IAccessible
20256:   }
20256:   else {
43504:     nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
43504:     if (!content) {
43504:       NS_NOTREACHED("The node is a document which is not accessible!");
43504:       return NULL;
43504:     }
43504: 
43504:     newNode = new nsAccessNodeWrap(content, mWeakShell);
20256:     if (!newNode)
20256:       return NULL;
20256: 
20256:     newNode->Init();
20256:     iNode = static_cast<ISimpleDOMNode*>(newNode);
20256:     iNode->AddRef();
20256:   }
20256: 
20256:   return iNode;
20256: }
20256: 
20256: 
20256: STDMETHODIMP nsAccessNodeWrap::get_parentNode(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
43504:   if (IsDefunct())
20256:     return E_FAIL;
    1: 
43504:   *aNode = MakeAccessNode(GetNode()->GetNodeParent());
43504: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_firstChild(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
43504:   if (IsDefunct())
20256:     return E_FAIL;
    1: 
43504:   *aNode = MakeAccessNode(GetNode()->GetFirstChild());
43504: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_lastChild(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
43504:   if (IsDefunct())
20256:     return E_FAIL;
    1: 
43504:   *aNode = MakeAccessNode(GetNode()->GetLastChild());
43504: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_previousSibling(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
43504:   if (IsDefunct())
20256:     return E_FAIL;
    1: 
43504:   *aNode = MakeAccessNode(GetNode()->GetPreviousSibling());
43504: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_nextSibling(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
43504:   if (IsDefunct())
20256:     return E_FAIL;
    1: 
43504:   *aNode = MakeAccessNode(GetNode()->GetNextSibling());
43504: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_childAt(unsigned aChildIndex,
    1:                               ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
20256:   *aNode = nsnull;
    1: 
43504:   if (IsDefunct())
43504:     return E_FAIL;
    1: 
43504:   *aNode = MakeAccessNode(GetNode()->GetChildAt(aChildIndex));
20256: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_innerHTML(BSTR __RPC_FAR *aInnerHTML)
    1: {
11593: __try {
    1:   *aInnerHTML = nsnull;
    1: 
43504:   nsCOMPtr<nsIDOMNSHTMLElement> domNSElement(do_QueryInterface(GetNode()));
    1:   if (!domNSElement)
    1:     return E_FAIL; // Node already shut down
    1: 
    1:   nsAutoString innerHTML;
    1:   domNSElement->GetInnerHTML(innerHTML);
13128:   if (innerHTML.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aInnerHTML = ::SysAllocStringLen(innerHTML.get(), innerHTML.Length());
13128:   if (!*aInnerHTML)
13128:     return E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_language(BSTR __RPC_FAR *aLanguage)
    1: {
11593: __try {
13128:   *aLanguage = NULL;
 2074: 
 1751:   nsAutoString language;
 1751:   if (NS_FAILED(GetLanguage(language))) {
    1:     return E_FAIL;
    1:   }
13128: 
13128:   if (language.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aLanguage = ::SysAllocStringLen(language.get(), language.Length());
13128:   if (!*aLanguage)
13128:     return E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_localInterface( 
    1:     /* [out] */ void __RPC_FAR *__RPC_FAR *localInterface)
    1: {
11593: __try {
 3233:   *localInterface = static_cast<nsIAccessNode*>(this);
    1:   NS_ADDREF_THIS();
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1:  
    1: void nsAccessNodeWrap::InitAccessibility()
    1: {
    1:   nsCOMPtr<nsIPrefBranch> prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   if (prefBranch) {
    1:     prefBranch->GetBoolPref("accessibility.disableenumvariant", &gIsEnumVariantSupportDisabled);
    1:   }
    1: 
    1:   if (!gmUserLib) {
18477:     gmUserLib =::LoadLibraryW(L"USER32.DLL");
    1:   }
    1: 
    1:   if (gmUserLib) {
    1:     if (!gmNotifyWinEvent)
    1:       gmNotifyWinEvent = (LPFNNOTIFYWINEVENT)GetProcAddress(gmUserLib,"NotifyWinEvent");
    1:     if (!gmGetGUIThreadInfo)
    1:       gmGetGUIThreadInfo = (LPFNGETGUITHREADINFO)GetProcAddress(gmUserLib,"GetGUIThreadInfo");
    1:   }
    1: 
16515:   DoATSpecificProcessing();
16515: 
64004:   nsWinUtils::MaybeStartWindowEmulation();
54220: 
    1:   nsAccessNode::InitXPAccessibility();
    1: }
    1: 
    1: void nsAccessNodeWrap::ShutdownAccessibility()
    1: {
 1392:   NS_IF_RELEASE(gTextEvent);
 2395:   ::DestroyCaret();
 1392: 
64004:   nsWinUtils::ShutdownWindowEmulation();
54220: 
    1:   nsAccessNode::ShutdownXPAccessibility();
    1: }
11440: 
11440: int nsAccessNodeWrap::FilterA11yExceptions(unsigned int aCode, EXCEPTION_POINTERS *aExceptionInfo)
11440: {
11440:   if (aCode == EXCEPTION_ACCESS_VIOLATION) {
11440: #ifdef MOZ_CRASHREPORTER
11440:     // MSAA swallows crashes (because it is COM-based)
11440:     // but we still need to learn about those crashes so we can fix them
11440:     // Make sure to pass them to the crash reporter
11440:     nsCOMPtr<nsICrashReporter> crashReporter =
11440:       do_GetService("@mozilla.org/toolkit/crash-reporter;1");
11440:     if (crashReporter) {
11440:       crashReporter->WriteMinidumpForException(aExceptionInfo);
11440:     }
11440: #endif
11440:   }
11440:   else {
11440:     NS_NOTREACHED("We should only be catching crash exceptions");
11440:   }
11440:   return EXCEPTION_CONTINUE_SEARCH;
11440: }
13730: 
13730: HRESULT
13730: GetHRESULT(nsresult aResult)
13730: {
13730:   switch (aResult) {
13730:     case NS_OK:
13730:       return S_OK;
13730: 
13730:     case NS_ERROR_INVALID_ARG: case NS_ERROR_INVALID_POINTER:
13730:       return E_INVALIDARG;
13730: 
13730:     case NS_ERROR_OUT_OF_MEMORY:
13730:       return E_OUTOFMEMORY;
13730: 
13730:     case NS_ERROR_NOT_IMPLEMENTED:
13730:       return E_NOTIMPL;
13730: 
13730:     default:
13730:       return E_FAIL;
13730:   }
13730: }
13730: 
16515: PRBool nsAccessNodeWrap::IsOnlyMsaaCompatibleJawsPresent()
16515: {
54220:   HMODULE jhookhandle = ::GetModuleHandleW(kJAWSModuleHandle);
16515:   if (!jhookhandle)
16515:     return PR_FALSE;  // No JAWS, or some other screen reader, use IA2
16515: 
16515:   PRUnichar fileName[MAX_PATH];
16515:   ::GetModuleFileNameW(jhookhandle, fileName, MAX_PATH);
16515: 
16515:   DWORD dummy;
16515:   DWORD length = ::GetFileVersionInfoSizeW(fileName, &dummy);
16515: 
16515:   LPBYTE versionInfo = new BYTE[length];
16515:   ::GetFileVersionInfoW(fileName, 0, length, versionInfo);
16515: 
16515:   UINT uLen;
16515:   VS_FIXEDFILEINFO *fixedFileInfo;
16515:   ::VerQueryValueW(versionInfo, L"\\", (LPVOID*)&fixedFileInfo, &uLen);
16515:   DWORD dwFileVersionMS = fixedFileInfo->dwFileVersionMS;
16515:   DWORD dwFileVersionLS = fixedFileInfo->dwFileVersionLS;
16515:   delete [] versionInfo;
16515: 
16515:   DWORD dwLeftMost = HIWORD(dwFileVersionMS);
16515: //  DWORD dwSecondLeft = LOWORD(dwFileVersionMS);
16515:   DWORD dwSecondRight = HIWORD(dwFileVersionLS);
16515: //  DWORD dwRightMost = LOWORD(dwFileVersionLS);
16515: 
16515:   return (dwLeftMost < 8
16515:           || (dwLeftMost == 8 && dwSecondRight < 2173));
16515: }
16515: 
18348: void nsAccessNodeWrap::TurnOffNewTabSwitchingForJawsAndWE()
18348: {
54220:   HMODULE srHandle = ::GetModuleHandleW(kJAWSModuleHandle);
18348:   if (!srHandle) {
18348:     // No JAWS, try Window-Eyes
54220:     srHandle = ::GetModuleHandleW(kWEModuleHandle);
18348:     if (!srHandle) {
18348:       // no screen reader we're interested in. Bail out.
18348:       return;
18348:     }
18348:   }
18348: 
18348:   // Check to see if the pref for disallowing CtrlTab is already set.
18348:   // If so, bail out.
18348:   // If not, set it.
18348:   nsCOMPtr<nsIPrefBranch> prefs (do_GetService(NS_PREFSERVICE_CONTRACTID));
18348:   if (prefs) {
18348:     PRBool hasDisallowNewCtrlTabPref = PR_FALSE;
18348:     nsresult rv = prefs->PrefHasUserValue(CTRLTAB_DISALLOW_FOR_SCREEN_READERS_PREF,
18348:              &hasDisallowNewCtrlTabPref);
18348:     if (NS_SUCCEEDED(rv) && hasDisallowNewCtrlTabPref) {
18348:       // This pref has been set before. There is no default for it.
18348:       // Do nothing further, respect the setting that's there.
18348:       // That way, if noone touches it, it'll stay on after toggled once.
18348:       // If someone decided to turn it off, we respect that, too.
18348:       return;
18348:     }
18348:     
18348:     // Value has never been set, set it.
18348:     prefs->SetBoolPref(CTRLTAB_DISALLOW_FOR_SCREEN_READERS_PREF, PR_TRUE);
18348:   }
18348: }
18348: 
16515: void nsAccessNodeWrap::DoATSpecificProcessing()
16515: {
16515:   if (IsOnlyMsaaCompatibleJawsPresent())
16515:     // All versions below 8.0.2173 are not compatible
16515:     gIsIA2Disabled  = PR_TRUE;
18348: 
18348:   TurnOffNewTabSwitchingForJawsAndWE();
16515: }
54220: 
54220: nsRefPtrHashtable<nsVoidPtrHashKey, nsDocAccessible> nsAccessNodeWrap::sHWNDCache;
54220: 
54220: LRESULT CALLBACK
54220: nsAccessNodeWrap::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
54220: {
54220:   switch (msg) {
54220:     case WM_GETOBJECT:
54220:     {
54220:       if (lParam == OBJID_CLIENT) {
54220:         nsDocAccessible* document = sHWNDCache.GetWeak(static_cast<void*>(hWnd));
54220:         if (document) {
54220:           IAccessible* msaaAccessible = NULL;
54220:           document->GetNativeInterface((void**)&msaaAccessible); // does an addref
54220:           if (msaaAccessible) {
54220:             LRESULT result = LresultFromObject(IID_IAccessible, wParam,
54220:                                                msaaAccessible); // does an addref
54220:             msaaAccessible->Release(); // release extra addref
54220:             return result;
54220:           }
54220:         }
54220:       }
54220:       return 0;
54220:     }
63261:     case WM_NCHITTEST:
63261:     {
63261:       LRESULT lRet = ::DefWindowProc(hWnd, msg, wParam, lParam);
63261:       if (HTCLIENT == lRet)
63261:         lRet = HTTRANSPARENT;
63261:       return lRet;
63261:     }
54220:   }
54220: 
54220:   return ::DefWindowProcW(hWnd, msg, wParam, lParam);
54220: }
54220: 
54220: STDMETHODIMP_(LRESULT)
54220: nsAccessNodeWrap::LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN pAcc)
54220: {
54220:   // open the dll dynamically
54220:   if (!gmAccLib)
54220:     gmAccLib =::LoadLibraryW(L"OLEACC.DLL");
54220: 
54220:   if (gmAccLib) {
54220:     if (!gmLresultFromObject)
54220:       gmLresultFromObject = (LPFNLRESULTFROMOBJECT)GetProcAddress(gmAccLib,"LresultFromObject");
54220: 
54220:     if (gmLresultFromObject)
54220:       return gmLresultFromObject(riid, wParam, pAcc);
54220:   }
54220: 
54220:   return 0;
54220: }
