43912: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
43912:  * vim: sw=2 ts=8 et :
43912:  */
43912: /* ***** BEGIN LICENSE BLOCK *****
43912:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43912:  *
43912:  * The contents of this file are subject to the Mozilla Public License Version
43912:  * 1.1 (the "License"); you may not use this file except in compliance with
43912:  * the License. You may obtain a copy of the License at:
43912:  * http://www.mozilla.org/MPL/
43912:  *
43912:  * Software distributed under the License is distributed on an "AS IS" basis,
43912:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43912:  * for the specific language governing rights and limitations under the
43912:  * License.
43912:  *
43912:  * The Original Code is Mozilla Code.
43912:  *
43912:  * The Initial Developer of the Original Code is
43912:  *   The Mozilla Foundation
43912:  * Portions created by the Initial Developer are Copyright (C) 2010
43912:  * the Initial Developer. All Rights Reserved.
43912:  *
43912:  * Contributor(s):
43912:  *
43912:  * Alternatively, the contents of this file may be used under the terms of
43912:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43912:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43912:  * in which case the provisions of the GPL or the LGPL are applicable instead
43912:  * of those above. If you wish to allow use of your version of this file only
43912:  * under the terms of either the GPL or the LGPL, and not to allow others to
43912:  * use your version of this file under the terms of the MPL, indicate your
43912:  * decision by deleting the provisions above and replace them with the notice
43912:  * and other provisions required by the GPL or the LGPL. If you do not delete
43912:  * the provisions above, a recipient may use your version of this file under
43912:  * the terms of any one of the MPL, the GPL or the LGPL.
43912:  *
43912:  * ***** END LICENSE BLOCK ***** */
43912: 
43912: #ifndef mozilla_X11Util_h
43912: #define mozilla_X11Util_h
43912: 
43912: // Utilities common to all X clients, regardless of UI toolkit.
43912: 
43912: #if defined(MOZ_WIDGET_GTK2)
43912: #  include <gdk/gdkx.h>
43912: #elif defined(MOZ_WIDGET_QT)
44143: // X11/X.h has #define CursorShape 0, but Qt's qnamespace.h defines
44143: //   enum CursorShape { ... }.  Good times!
44143: #undef CursorShape
43912: #  include <QX11Info>
58663: #  include <X11/Xlib.h>
43912: #else
43912: #  error Unknown toolkit
43912: #endif 
43912: 
58728: #include "gfxCore.h"
46140: #include "nsDebug.h"
46140: 
43912: namespace mozilla {
43912: 
43912: /**
43912:  * Return the default X Display created and used by the UI toolkit.
43912:  */
43912: inline Display*
43912: DefaultXDisplay()
43912: {
43912: #if defined(MOZ_WIDGET_GTK2)
43912:   return GDK_DISPLAY();
43912: #elif defined(MOZ_WIDGET_QT)
43912:   return QX11Info::display();
43912: #endif
43912: }
43912: 
43912: /**
87048:  * Sets *aVisual to point to aDisplay's Visual struct corresponding to
87048:  * aVisualID, and *aDepth to its depth.  When aVisualID is None, these are set
87048:  * to NULL and 0 respectively.  Both out-parameter pointers are assumed
87048:  * non-NULL.  Returns true in both of these situations, but false if aVisualID
87048:  * is not None and not found on the Display.
87048:  */
87048: bool
87048: XVisualIDToInfo(Display* aDisplay, VisualID aVisualID,
87048:                 Visual** aVisual, unsigned int* aDepth);
87048: 
87048: /**
43912:  * Invoke XFree() on a pointer to memory allocated by Xlib (if the
43912:  * pointer is nonnull) when this class goes out of scope.
43912:  */
43912: template<typename T>
43912: struct ScopedXFree
43912: {
46140:   ScopedXFree() : mPtr(NULL) {}
43912:   ScopedXFree(T* aPtr) : mPtr(aPtr) {}
43912: 
46140:   ~ScopedXFree() { Assign(NULL); }
46140: 
46140:   ScopedXFree& operator=(T* aPtr) { Assign(aPtr); return *this; }
43912: 
43912:   operator T*() const { return get(); }
43912:   T* operator->() const { return get(); }
43912:   T* get() const { return mPtr; }
43912: 
46140: private:
46140:   void Assign(T* aPtr)
46140:   {
46140:     NS_ASSERTION(!mPtr || mPtr != aPtr, "double-XFree() imminent");
43912: 
46140:     if (mPtr)
46140:       XFree(mPtr);
46140:     mPtr = aPtr;
46140:   }
46140: 
43912:   T* mPtr;
43912: 
43912:   // disable these
43912:   ScopedXFree(const ScopedXFree&);
43912:   ScopedXFree& operator=(const ScopedXFree&);
43912:   static void* operator new (size_t);
43912:   static void operator delete (void*);
43912: };
43912: 
58663: /**
58663:  * On construction, set a graceful X error handler that doesn't crash the application and records X errors.
58663:  * On destruction, restore the X error handler to what it was before construction.
58663:  * 
58663:  * The SyncAndGetError() method allows to know whether a X error occurred, optionally allows to get the full XErrorEvent,
58663:  * and resets the recorded X error state so that a single X error will be reported only once.
58663:  *
58663:  * Nesting is correctly handled: multiple nested ScopedXErrorHandler's don't interfere with each other's state. However,
58663:  * if SyncAndGetError is not called on the nested ScopedXErrorHandler, then any X errors caused by X calls made while the nested
58663:  * ScopedXErrorHandler was in place may then be caught by the other ScopedXErrorHandler. This is just a result of X being
58663:  * asynchronous and us not doing any implicit syncing: the only method in this class what causes syncing is SyncAndGetError().
58663:  *
58663:  * This class is not thread-safe at all. It is assumed that only one thread is using any ScopedXErrorHandler's. Given that it's
58663:  * not used on Mac, it should be easy to make it thread-safe by using thread-local storage with __thread.
58663:  */
58728: class NS_GFX ScopedXErrorHandler
58663: {
77099: public:
58663:     // trivial wrapper around XErrorEvent, just adding ctor initializing by zero.
58663:     struct ErrorEvent
58663:     {
58728:         XErrorEvent mError;
58663: 
58663:         ErrorEvent()
58663:         {
58663:             memset(this, 0, sizeof(ErrorEvent));
58663:         }
58663:     };
58663: 
77099: private:
77099: 
58663:     // this ScopedXErrorHandler's ErrorEvent object
58728:     ErrorEvent mXError;
58663: 
58663:     // static pointer for use by the error handler
58728:     static ErrorEvent* sXErrorPtr;
58663: 
58728:     // what to restore sXErrorPtr to on destruction
58728:     ErrorEvent* mOldXErrorPtr;
58663: 
58663:     // what to restore the error handler to on destruction
58728:     int (*mOldErrorHandler)(Display *, XErrorEvent *);
58663: 
58663: public:
58663: 
58663:     static int
58728:     ErrorHandler(Display *, XErrorEvent *ev);
58663: 
58728:     ScopedXErrorHandler();
58663: 
58728:     ~ScopedXErrorHandler();
58663: 
62482:     /** \returns true if a X error occurred since the last time this method was called on this ScopedXErrorHandler object,
62482:      *           or since the creation of this ScopedXErrorHandler object if this method was never called on it.
58663:      *
62482:      * \param ev this optional parameter, if set, will be filled with the XErrorEvent object. If multiple errors occurred,
62482:      *           the first one will be returned.
58663:      */
58728:     bool SyncAndGetError(Display *dpy, XErrorEvent *ev = nsnull);
62486: 
62486:     /** Like SyncAndGetError, but does not sync. Faster, but only reliably catches errors in synchronous calls.
62486:      *
62486:      * \param ev this optional parameter, if set, will be filled with the XErrorEvent object. If multiple errors occurred,
62486:      *           the first one will be returned.
62486:      */
62486:     bool GetError(XErrorEvent *ev = nsnull);
62449: };
62437: 
43912: } // namespace mozilla
43912: 
43912: #endif  // mozilla_X11Util_h
