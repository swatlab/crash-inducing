23126: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
23126:  * vim: set ts=8 sw=4 et tw=99:
23126:  *
23126:  * ***** BEGIN LICENSE BLOCK *****
23126:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23126:  *
23126:  * The contents of this file are subject to the Mozilla Public License Version
23126:  * 1.1 (the "License"); you may not use this file except in compliance with
23126:  * the License. You may obtain a copy of the License at
23126:  * http://www.mozilla.org/MPL/
23126:  *
23126:  * Software distributed under the License is distributed on an "AS IS" basis,
23126:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23126:  * for the specific language governing rights and limitations under the
23126:  * License.
23126:  *
23126:  * The Original Code is Mozilla Communicator client code, released
23126:  * March 31, 1998.
23126:  *
23126:  * The Initial Developer of the Original Code is
23126:  * Netscape Communications Corporation.
23126:  * Portions created by the Initial Developer are Copyright (C) 1998
23126:  * the Initial Developer. All Rights Reserved.
23126:  *
23126:  * Contributor(s):
23126:  *
23126:  * Alternatively, the contents of this file may be used under the terms of
23126:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23126:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23126:  * in which case the provisions of the GPL or the LGPL are applicable instead
23126:  * of those above. If you wish to allow use of your version of this file only
23126:  * under the terms of either the GPL or the LGPL, and not to allow others to
23126:  * use your version of this file under the terms of the MPL, indicate your
23126:  * decision by deleting the provisions above and replace them with the notice
23126:  * and other provisions required by the GPL or the LGPL. If you do not delete
23126:  * the provisions above, a recipient may use your version of this file under
23126:  * the terms of any one of the MPL, the GPL or the LGPL.
23126:  *
23126:  * ***** END LICENSE BLOCK ***** */
23126: 
48470: #define __STDC_LIMIT_MACROS
48470: 
23126: /*
23126:  * JS shell.
23126:  */
23126: #include <errno.h>
25472: #include <math.h>
23126: #include <stdio.h>
23126: #include <stdlib.h>
23126: #include <string.h>
25098: #include <signal.h>
23126: #include <locale.h>
23126: #include "jstypes.h"
40828: #include "jsstdint.h"
23126: #include "jsarena.h"
23126: #include "jsutil.h"
23126: #include "jsprf.h"
43264: #include "jswrapper.h"
23126: #include "jsapi.h"
23126: #include "jsarray.h"
23126: #include "jsatom.h"
23126: #include "jsbuiltins.h"
23126: #include "jscntxt.h"
25087: #include "jsdate.h"
23126: #include "jsdbgapi.h"
23126: #include "jsemit.h"
23126: #include "jsfun.h"
23126: #include "jsgc.h"
27012: #include "jsiter.h"
23126: #include "jslock.h"
23126: #include "jsnum.h"
23126: #include "jsobj.h"
23126: #include "jsparse.h"
51110: #include "jsreflect.h"
23126: #include "jsscope.h"
23126: #include "jsscript.h"
32748: #include "jstracer.h"
54863: #include "jstypedarray.h"
42742: #include "jsxml.h"
48637: #include "jsperf.h"
23126: 
25087: #include "prmjtime.h"
25087: 
23126: #ifdef JSDEBUGGER
23126: #include "jsdebug.h"
23126: #ifdef JSDEBUGGER_JAVA_UI
23126: #include "jsdjava.h"
23126: #endif /* JSDEBUGGER_JAVA_UI */
23126: #ifdef JSDEBUGGER_C_UI
23126: #include "jsdb.h"
23126: #endif /* JSDEBUGGER_C_UI */
23126: #endif /* JSDEBUGGER */
23126: 
40801: #include "jsworkers.h"
40801: 
53840: #include "jsinterpinlines.h"
42733: #include "jsobjinlines.h"
48470: #include "jsscriptinlines.h"
42733: 
23126: #ifdef XP_UNIX
23126: #include <unistd.h>
23126: #include <sys/types.h>
23126: #include <sys/wait.h>
23126: #endif
23126: 
23126: #if defined(XP_WIN) || defined(XP_OS2)
23126: #include <io.h>     /* for isatty() */
23126: #endif
23126: 
26053: #ifdef XP_WIN
52897: #include "jswin.h"
26053: #endif
26053: 
38585: using namespace js;
38585: 
23126: typedef enum JSShellExitCode {
23126:     EXITCODE_RUNTIME_ERROR      = 3,
23126:     EXITCODE_FILE_NOT_FOUND     = 4,
25472:     EXITCODE_OUT_OF_MEMORY      = 5,
25472:     EXITCODE_TIMEOUT            = 6
23126: } JSShellExitCode;
23126: 
23126: size_t gStackChunkSize = 8192;
23126: 
23126: /* Assume that we can not use more than 5e5 bytes of C stack by default. */
39974: #if defined(DEBUG) && defined(__SUNPRO_CC)
39974: /* Sun compiler uses larger stack space for js_Interpret() with debug
39974:    Use a bigger gMaxStackSize to make "make check" happy. */
42740: size_t gMaxStackSize = 5000000;
39974: #else
42740: size_t gMaxStackSize = 500000;
39974: #endif
39974: 
26673: 
26673: #ifdef JS_THREADSAFE
26673: static PRUintn gStackBaseThreadIndex;
26673: #else
23126: static jsuword gStackBase;
26673: #endif
23126: 
23126: static size_t gScriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;
23442: 
25472: /*
25472:  * Limit the timeout to 30 minutes to prevent an overflow on platfoms
25472:  * that represent the time internally in microseconds using 32-bit int.
25472:  */
25472: static jsdouble MAX_TIMEOUT_INTERVAL = 1800.0;
25472: static jsdouble gTimeoutInterval = -1.0;
25472: static volatile bool gCanceled = false;
25087: 
52557: static bool enableTraceJit = false;
52557: static bool enableMethodJit = false;
33747: 
56181: static bool printTiming = false;
56181: 
25087: static JSBool
25087: SetTimeoutValue(JSContext *cx, jsdouble t);
25087: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt);
25087: 
25087: static void
25472: KillWatchdog();
25472: 
25472: static bool
25472: ScheduleWatchdog(JSRuntime *rt, jsdouble t);
25472: 
25472: static void
25472: CancelExecution(JSRuntime *rt);
23126: 
23726: /*
23726:  * Watchdog thread state.
23726:  */
23726: #ifdef JS_THREADSAFE
25472: 
25472: static PRLock *gWatchdogLock = NULL;
25087: static PRCondVar *gWatchdogWakeup = NULL;
25087: static PRThread *gWatchdogThread = NULL;
25472: static bool gWatchdogHasTimeout = false;
25472: static PRIntervalTime gWatchdogTimeout = 0;
25472: 
25472: static PRCondVar *gSleepWakeup = NULL;
25087: 
25087: #else
25472: 
25087: static JSRuntime *gRuntime = NULL;
25087: 
23726: #endif
23726: 
23126: int gExitCode = 0;
23126: JSBool gQuitting = JS_FALSE;
23126: FILE *gErrFile = NULL;
23126: FILE *gOutFile = NULL;
40801: #ifdef JS_THREADSAFE
40801: JSObject *gWorkers = NULL;
55619: js::workers::ThreadPool *gWorkerThreadPool = NULL;
40801: #endif
23126: 
23126: static JSBool reportWarnings = JS_TRUE;
23126: static JSBool compileOnly = JS_FALSE;
23126: 
23126: typedef enum JSShellErrNum {
23126: #define MSG_DEF(name, number, count, exception, format) \
23126:     name = number,
23126: #include "jsshell.msg"
23126: #undef MSG_DEF
23126:     JSShellErr_Limit
23126: #undef MSGDEF
23126: } JSShellErrNum;
23126: 
40801: static JSContext *
40801: NewContext(JSRuntime *rt);
40801: 
40801: static void
40801: DestroyContext(JSContext *cx, bool withGC);
40801: 
23126: static const JSErrorFormatString *
23126: my_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
35108: 
23126: static JSObject *
35108: split_setup(JSContext *cx, JSBool evalcx);
23126: 
23126: #ifdef EDITLINE
23126: JS_BEGIN_EXTERN_C
23908: JS_EXTERN_API(char)    *readline(const char *prompt);
23908: JS_EXTERN_API(void)     add_history(char *line);
23126: JS_END_EXTERN_C
23126: #endif
23126: 
47498: static void
47498: ReportException(JSContext *cx)
47498: {
47498:     if (JS_IsExceptionPending(cx)) {
47498:         if (!JS_ReportPendingException(cx))
47498:             JS_ClearPendingException(cx);
47498:     }
47498: }
47498: 
31366: class ToString {
31366: public:
31366:     ToString(JSContext *aCx, jsval v, JSBool aThrow = JS_FALSE)
31366:     : cx(aCx)
31366:     , mThrow(aThrow)
31366:     {
31366:         mStr = JS_ValueToString(cx, v);
47498:         if (!aThrow && !mStr)
47498:             ReportException(cx);
47403:         JS_AddNamedStringRoot(cx, &mStr, "Value ToString helper");
31366:     }
31366:     ~ToString() {
47403:         JS_RemoveStringRoot(cx, &mStr);
31366:     }
31366:     JSBool threw() { return !mStr; }
31366:     jsval getJSVal() { return STRING_TO_JSVAL(mStr); }
31366:     const char *getBytes() {
31366:         return mStr ? JS_GetStringBytes(mStr) : "(error converting value)";
31366:     }
31366: private:
31366:     JSContext *cx;
31366:     JSString *mStr;
31366:     JSBool mThrow;
31366: };
31366: 
48470: class IdToString : public ToString {
48470: public:
48470:     IdToString(JSContext *cx, jsid id, JSBool aThrow = JS_FALSE)
48470:     : ToString(cx, IdToJsval(id), aThrow)
48470:     { }
48470: };
48470: 
23723: static char *
23723: GetLine(FILE *file, const char * prompt)
23723: {
23723:     size_t size;
23723:     char *buffer;
23126: #ifdef EDITLINE
23126:     /*
23126:      * Use readline only if file is stdin, because there's no way to specify
23126:      * another handle.  Are other filehandles interactive?
23126:      */
23126:     if (file == stdin) {
23126:         char *linep = readline(prompt);
23723:         /*
23723:          * We set it to zero to avoid complaining about inappropriate ioctl
23723:          * for device in the case of EOF. Looks like errno == 251 if line is
25486:          * finished with EOF and errno == 25 (EINVAL on Mac) if there is
25486:          * nothing left to read.
23723:          */
25486:         if (errno == 251 || errno == 25 || errno == EINVAL)
23723:             errno = 0;
23126:         if (!linep)
23723:             return NULL;
23126:         if (linep[0] != '\0')
23126:             add_history(linep);
23723:         return linep;
23723:     }
23126: #endif
23723:     size_t len = 0;
23723:     if (*prompt != '\0') {
25469:         fprintf(gOutFile, "%s", prompt);
23126:         fflush(gOutFile);
23723:     }
23723:     size = 80;
23723:     buffer = (char *) malloc(size);
23723:     if (!buffer)
23723:         return NULL;
23723:     char *current = buffer;
23723:     while (fgets(current, size - len, file)) {
23723:         len += strlen(current);
23723:         char *t = buffer + len - 1;
23723:         if (*t == '\n') {
23723:             /* Line was read. We remove '\n' and exit. */
23723:             *t = '\0';
23723:             return buffer;
23723:         }
23723:         if (len + 1 == size) {
23723:             size = size * 2;
23723:             char *tmp = (char *) realloc(buffer, size);
23723:             if (!tmp) {
23723:                 free(buffer);
23723:                 return NULL;
23723:             }
23723:             buffer = tmp;
23723:         }
23723:         current = buffer + len;
23723:     }
23723:     if (len && !ferror(file))
23723:         return buffer;
23723:     free(buffer);
23723:     return NULL;
23457: }
23457: 
23726: /*
23726:  * State to store as JSContext private.
23726:  *
25087:  * We declare such timestamp as volatile as they are updated in the operation
23726:  * callback without taking any locks. Any possible race can only lead to more
23726:  * frequent callback calls. This is safe as the callback does everything based
23726:  * on timing.
23726:  */
23457: struct JSShellContextData {
25087:     volatile JSIntervalTime startTime;
23457: };
23457: 
23457: static JSShellContextData *
23457: NewContextData()
23457: {
25472:     /* Prevent creation of new contexts after we have been canceled. */
25472:     if (gCanceled)
25472:         return NULL;
25472: 
23457:     JSShellContextData *data = (JSShellContextData *)
25087:                                calloc(sizeof(JSShellContextData), 1);
23457:     if (!data)
23457:         return NULL;
25087:     data->startTime = js_IntervalNow();
23457:     return data;
23457: }
23457: 
23457: static inline JSShellContextData *
23457: GetContextData(JSContext *cx)
23457: {
23457:     JSShellContextData *data = (JSShellContextData *) JS_GetContextPrivate(cx);
23457: 
23457:     JS_ASSERT(data);
23457:     return data;
23457: }
23457: 
23126: static JSBool
23457: ShellOperationCallback(JSContext *cx)
23126: {
25709:     if (!gCanceled)
25709:         return JS_TRUE;
25709: 
25709:     JS_ClearPendingException(cx);
25709:     return JS_FALSE;
23126: }
23126: 
23126: static void
26673: SetContextOptions(JSContext *cx)
26673: {
42740:     JS_SetNativeStackQuota(cx, gMaxStackSize);
23126:     JS_SetScriptStackQuota(cx, gScriptStackQuota);
25087:     JS_SetOperationCallback(cx, ShellOperationCallback);
23126: }
23126: 
37620: #ifdef WINCE
37620: int errno;
37620: #endif
37620: 
23126: static void
23126: Process(JSContext *cx, JSObject *obj, char *filename, JSBool forceTTY)
23126: {
23126:     JSBool ok, hitEOF;
23126:     JSScript *script;
23126:     jsval result;
23126:     JSString *str;
23723:     char *buffer;
24199:     size_t size;
23126:     int lineno;
23126:     int startline;
23126:     FILE *file;
23126:     uint32 oldopts;
23126: 
23126:     if (forceTTY || !filename || strcmp(filename, "-") == 0) {
23126:         file = stdin;
23126:     } else {
23126:         file = fopen(filename, "r");
23126:         if (!file) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_CANT_OPEN, filename, strerror(errno));
23126:             gExitCode = EXITCODE_FILE_NOT_FOUND;
23126:             return;
23126:         }
23126:     }
23126: 
23126:     SetContextOptions(cx);
23126: 
23126: #ifndef WINCE
23126:     /* windows mobile (and possibly other os's) does not have a TTY */
37620:     if (!forceTTY && !isatty(fileno(file)))
37620: #endif
37620:     {
23126:         /*
23126:          * It's not interactive - just execute it.
23126:          *
23126:          * Support the UNIX #! shell hack; gobble the first line if it starts
23126:          * with '#'.  TODO - this isn't quite compatible with sharp variables,
23126:          * as a legal js program (using sharp variables) might start with '#'.
23126:          * But that would require multi-character lookahead.
23126:          */
23126:         int ch = fgetc(file);
23126:         if (ch == '#') {
23126:             while((ch = fgetc(file)) != EOF) {
23126:                 if (ch == '\n' || ch == '\r')
23126:                     break;
23126:             }
23126:         }
23126:         ungetc(ch, file);
23126: 
56181:         int64 t1 = PRMJ_Now();
23126:         oldopts = JS_GetOptions(cx);
23126:         JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
23126:         script = JS_CompileFileHandle(cx, obj, filename, file);
23126:         JS_SetOptions(cx, oldopts);
23126:         if (script) {
56181:             if (!compileOnly) {
23126:                 (void)JS_ExecuteScript(cx, obj, script, NULL);
56181:                 int64 t2 = PRMJ_Now() - t1;
56181:                 if (printTiming)
56181:                     printf("runtime = %.3f ms\n", double(t2) / PRMJ_USEC_PER_MSEC);
56181:             }
23126:             JS_DestroyScript(cx, script);
23126:         }
23126: 
23126:         if (file != stdin)
23126:             fclose(file);
23126:         return;
23126:     }
23126: 
23126:     /* It's an interactive filehandle; drop into read-eval-print loop. */
23126:     lineno = 1;
23126:     hitEOF = JS_FALSE;
23723:     buffer = NULL;
24199:     size = 0;           /* assign here to avoid warnings */
23126:     do {
23126:         /*
23126:          * Accumulate lines until we get a 'compilable unit' - one that either
23126:          * generates an error (before running out of source) or that compiles
23126:          * cleanly.  This should be whenever we get a complete statement that
23126:          * coincides with the end of a line.
23126:          */
23126:         startline = lineno;
25472:         size_t len = 0; /* initialize to avoid warnings */
23126:         do {
25472:             ScheduleWatchdog(cx->runtime, -1);
25472:             gCanceled = false;
23723:             errno = 0;
40289: 
40289:             char *line;
40289:             {
40289:                 JSAutoSuspendRequest suspended(cx);
40289:                 line = GetLine(file, startline == lineno ? "js> " : "");
40289:             }
23723:             if (!line) {
23723:                 if (errno) {
23723:                     JS_ReportError(cx, strerror(errno));
23723:                     free(buffer);
23723:                     return;
23723:                 }
23126:                 hitEOF = JS_TRUE;
23126:                 break;
23126:             }
23723:             if (!buffer) {
23723:                 buffer = line;
23723:                 len = strlen(buffer);
23723:                 size = len + 1;
23723:             } else {
24198:                 /*
24198:                  * len + 1 is required to store '\n' in the end of line.
23723:                  */
23723:                 size_t newlen = strlen(line) + (len ? len + 1 : 0);
23723:                 if (newlen + 1 > size) {
23723:                     size = newlen + 1 > size * 2 ? newlen + 1 : size * 2;
23723:                     char *newBuf = (char *) realloc(buffer, size);
23723:                     if (!newBuf) {
23723:                         free(buffer);
23723:                         free(line);
23723:                         JS_ReportOutOfMemory(cx);
23723:                         return;
23723:                     }
23723:                     buffer = newBuf;
23723:                 }
23723:                 char *current = buffer + len;
23723:                 if (startline != lineno)
23723:                     *current++ = '\n';
23723:                 strcpy(current, line);
23723:                 len = newlen;
23723:                 free(line);
23723:             }
23126:             lineno++;
25472:             if (!ScheduleWatchdog(cx->runtime, gTimeoutInterval)) {
25472:                 hitEOF = JS_TRUE;
25472:                 break;
25472:             }
23723:         } while (!JS_BufferIsCompilableUnit(cx, obj, buffer, len));
23126: 
24239:         if (hitEOF && !buffer)
23733:             break;
23733: 
23126:         /* Clear any pending exception from previous failed compiles. */
23126:         JS_ClearPendingException(cx);
24148: 
24148:         /* Even though we're interactive, we have a compile-n-go opportunity. */
24148:         oldopts = JS_GetOptions(cx);
24148:         if (!compileOnly)
24148:             JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO);
23723:         script = JS_CompileScript(cx, obj, buffer, len, "typein",
23126:                                   startline);
24148:         if (!compileOnly)
24148:             JS_SetOptions(cx, oldopts);
24148: 
23126:         if (script) {
23126:             if (!compileOnly) {
23126:                 ok = JS_ExecuteScript(cx, obj, script, &result);
23126:                 if (ok && !JSVAL_IS_VOID(result)) {
32781:                     str = JS_ValueToSource(cx, result);
23126:                     if (str)
23126:                         fprintf(gOutFile, "%s\n", JS_GetStringBytes(str));
23126:                     else
23126:                         ok = JS_FALSE;
23126:                 }
23126:             }
23126:             JS_DestroyScript(cx, script);
23126:         }
23723:         *buffer = '\0';
24304:     } while (!hitEOF && !gQuitting);
23733: 
23723:     free(buffer);
23126:     fprintf(gOutFile, "\n");
23126:     if (file != stdin)
23126:         fclose(file);
23126:     return;
23126: }
23126: 
23126: static int
23126: usage(void)
23126: {
23126:     fprintf(gErrFile, "%s\n", JS_GetImplementationVersion());
56227:     fprintf(gErrFile, "usage: js [-zKPswWxCijmdb] [-t timeoutSeconds] [-c stackchunksize] [-o option] [-v version] [-f scriptfile] [-e script] [-S maxstacksize] [-g sleep-seconds-on-startup]"
23126: #ifdef JS_GC_ZEAL
23126: "[-Z gczeal] "
23126: #endif
29368: #ifdef MOZ_TRACEVIS
29368: "[-T TraceVisFileName] "
29368: #endif
23126: "[scriptfile] [scriptarg...]\n");
23126:     return 2;
23126: }
23126: 
23126: /*
23126:  * JSContext option name to flag map. The option names are in alphabetical
23126:  * order for better reporting.
23126:  */
23126: static const struct {
23126:     const char  *name;
23126:     uint32      flag;
23126: } js_options[] = {
23126:     {"anonfunfix",      JSOPTION_ANONFUNFIX},
23126:     {"atline",          JSOPTION_ATLINE},
52557:     {"tracejit",        JSOPTION_JIT},
52557:     {"methodjit",       JSOPTION_METHODJIT},
23126:     {"relimit",         JSOPTION_RELIMIT},
23126:     {"strict",          JSOPTION_STRICT},
23126:     {"werror",          JSOPTION_WERROR},
23126:     {"xml",             JSOPTION_XML},
23126: };
23126: 
23126: static uint32
23126: MapContextOptionNameToFlag(JSContext* cx, const char* name)
23126: {
23126:     for (size_t i = 0; i != JS_ARRAY_LENGTH(js_options); ++i) {
23126:         if (strcmp(name, js_options[i].name) == 0)
23126:             return js_options[i].flag;
23126:     }
23126: 
23126:     char* msg = JS_sprintf_append(NULL,
23126:                                   "unknown option name '%s'."
23126:                                   " The valid names are ", name);
23126:     for (size_t i = 0; i != JS_ARRAY_LENGTH(js_options); ++i) {
23126:         if (!msg)
23126:             break;
23126:         msg = JS_sprintf_append(msg, "%s%s", js_options[i].name,
23126:                                 (i + 2 < JS_ARRAY_LENGTH(js_options)
23126:                                  ? ", "
23126:                                  : i + 2 == JS_ARRAY_LENGTH(js_options)
23126:                                  ? " and "
23126:                                  : "."));
23126:     }
23126:     if (!msg) {
23126:         JS_ReportOutOfMemory(cx);
23126:     } else {
23126:         JS_ReportError(cx, msg);
23126:         free(msg);
23126:     }
23126:     return 0;
23126: }
23126: 
23126: extern JSClass global_class;
23126: 
37741: #if defined(JS_TRACER) && defined(DEBUG)
37741: namespace js {
37741:     extern struct JSClass jitstats_class;
37741:     void InitJITStatsClass(JSContext *cx, JSObject *glob);
37741: }
37741: #endif
37741: 
23126: static int
23126: ProcessArgs(JSContext *cx, JSObject *obj, char **argv, int argc)
23126: {
23126:     int i, j, length;
23126:     JSObject *argsObj;
23126:     char *filename = NULL;
23126:     JSBool isInteractive = JS_TRUE;
23126:     JSBool forceTTY = JS_FALSE;
23126: 
23126:     /*
23126:      * Scan past all optional arguments so we can create the arguments object
23126:      * before processing any -f options, which must interleave properly with
23126:      * -v and -w options.  This requires two passes, and without getopt, we'll
23126:      * have to keep the option logic here and in the second for loop in sync.
23126:      */
23126:     for (i = 0; i < argc; i++) {
23126:         if (argv[i][0] != '-' || argv[i][1] == '\0') {
23126:             ++i;
23126:             break;
23126:         }
23126:         switch (argv[i][1]) {
23126:           case 'c':
23126:           case 'f':
23126:           case 'e':
23126:           case 'v':
23126:           case 'S':
23457:           case 't':
23126: #ifdef JS_GC_ZEAL
23126:           case 'Z':
23126: #endif
29368: #ifdef MOZ_TRACEVIS
29368:           case 'T':
29368: #endif
55469:           case 'g':
23126:             ++i;
23126:             break;
23126:           default:;
23126:         }
23126:     }
23126: 
23126:     /*
23126:      * Create arguments early and define it to root it, so it's safe from any
23126:      * GC calls nested below, and so it is available to -f <file> arguments.
23126:      */
23126:     argsObj = JS_NewArrayObject(cx, 0, NULL);
23126:     if (!argsObj)
23126:         return 1;
23126:     if (!JS_DefineProperty(cx, obj, "arguments", OBJECT_TO_JSVAL(argsObj),
23126:                            NULL, NULL, 0)) {
23126:         return 1;
23126:     }
23126: 
23126:     length = argc - i;
23126:     for (j = 0; j < length; j++) {
23126:         JSString *str = JS_NewStringCopyZ(cx, argv[i++]);
23126:         if (!str)
23126:             return 1;
23126:         if (!JS_DefineElement(cx, argsObj, j, STRING_TO_JSVAL(str),
23126:                               NULL, NULL, JSPROP_ENUMERATE)) {
23126:             return 1;
23126:         }
23126:     }
23126: 
23126:     for (i = 0; i < argc; i++) {
23126:         if (argv[i][0] != '-' || argv[i][1] == '\0') {
23126:             filename = argv[i++];
23126:             isInteractive = JS_FALSE;
23126:             break;
23126:         }
23126: 
23126:         switch (argv[i][1]) {
23126:         case 'v':
23126:             if (++i == argc)
23126:                 return usage();
23126: 
23126:             JS_SetVersion(cx, (JSVersion) atoi(argv[i]));
23126:             break;
23126: 
23126: #ifdef JS_GC_ZEAL
23126:         case 'Z':
23126:             if (++i == argc)
23126:                 return usage();
41846:             JS_SetGCZeal(cx, !!(atoi(argv[i])));
23126:             break;
23126: #endif
23126: 
23126:         case 'w':
23126:             reportWarnings = JS_TRUE;
23126:             break;
23126: 
23126:         case 'W':
23126:             reportWarnings = JS_FALSE;
23126:             break;
23126: 
23126:         case 's':
23126:             JS_ToggleOptions(cx, JSOPTION_STRICT);
23126:             break;
23126: 
23126:         case 'E':
23126:             JS_ToggleOptions(cx, JSOPTION_RELIMIT);
23126:             break;
23126: 
23126:         case 'x':
23126:             JS_ToggleOptions(cx, JSOPTION_XML);
23126:             break;
23126: 
56181:         case 'b':
56181:             printTiming = true;
56181:             break;
56181:             
23126:         case 'j':
52557:             enableTraceJit = !enableTraceJit;
23126:             JS_ToggleOptions(cx, JSOPTION_JIT);
23126: #if defined(JS_TRACER) && defined(DEBUG)
37741:             js::InitJITStatsClass(cx, JS_GetGlobalObject(cx));
23126:             JS_DefineObject(cx, JS_GetGlobalObject(cx), "tracemonkey",
37741:                             &js::jitstats_class, NULL, 0);
23126: #endif
23126:             break;
23126: 
52557:         case 'm':
52557:             enableMethodJit = !enableMethodJit;
52557:             JS_ToggleOptions(cx, JSOPTION_METHODJIT);
52557:             break;
52557: 
23126:         case 'o':
23126:           {
23126:             if (++i == argc)
23126:                 return usage();
23126: 
23126:             uint32 flag = MapContextOptionNameToFlag(cx, argv[i]);
23126:             if (flag == 0)
23126:                 return gExitCode;
23126:             JS_ToggleOptions(cx, flag);
23126:             break;
23126:           }
23126:         case 'P':
23126:             if (JS_GET_CLASS(cx, JS_GetPrototype(cx, obj)) != &global_class) {
23126:                 JSObject *gobj;
23126: 
54563:                 if (!JS_DeepFreezeObject(cx, obj))
23126:                     return JS_FALSE;
43286:                 gobj = JS_NewGlobalObject(cx, &global_class);
23126:                 if (!gobj)
23126:                     return JS_FALSE;
23126:                 if (!JS_SetPrototype(cx, gobj, obj))
23126:                     return JS_FALSE;
23126:                 JS_SetParent(cx, gobj, NULL);
23126:                 JS_SetGlobalObject(cx, gobj);
23126:                 obj = gobj;
23126:             }
23126:             break;
23126: 
23457:         case 't':
23126:             if (++i == argc)
23126:                 return usage();
23126: 
25087:             if (!SetTimeoutValue(cx, atof(argv[i])))
23457:                 return JS_FALSE;
23457: 
23126:             break;
23126: 
23126:         case 'c':
23126:             /* set stack chunk size */
23126:             gStackChunkSize = atoi(argv[++i]);
23126:             break;
23126: 
23126:         case 'f':
23126:             if (++i == argc)
23126:                 return usage();
23126: 
23126:             Process(cx, obj, argv[i], JS_FALSE);
25472:             if (gExitCode != 0)
25472:                 return gExitCode;
23126: 
23126:             /*
23126:              * XXX: js -f foo.js should interpret foo.js and then
23126:              * drop into interactive mode, but that breaks the test
23126:              * harness. Just execute foo.js for now.
23126:              */
23126:             isInteractive = JS_FALSE;
23126:             break;
23126: 
23126:         case 'e':
23126:         {
23126:             jsval rval;
23126: 
23126:             if (++i == argc)
23126:                 return usage();
23126: 
23126:             /* Pass a filename of -e to imitate PERL */
23126:             JS_EvaluateScript(cx, obj, argv[i], strlen(argv[i]),
23126:                               "-e", 1, &rval);
23126: 
23126:             isInteractive = JS_FALSE;
23126:             break;
23126: 
23126:         }
23126:         case 'C':
23126:             compileOnly = JS_TRUE;
23126:             isInteractive = JS_FALSE;
23126:             break;
23126: 
23126:         case 'i':
23126:             isInteractive = forceTTY = JS_TRUE;
23126:             break;
23126: 
23126:         case 'S':
23126:             if (++i == argc)
23126:                 return usage();
23126: 
23126:             /* Set maximum stack size. */
23126:             gMaxStackSize = atoi(argv[i]);
23126:             break;
23126: 
54578:         case 'd':
54578:             js_SetDebugMode(cx, JS_TRUE);
54578:             break;
54578: 
23126:         case 'z':
35108:             obj = split_setup(cx, JS_FALSE);
23126:             if (!obj)
23126:                 return gExitCode;
23126:             break;
23126: #ifdef MOZ_SHARK
23126:         case 'k':
23126:             JS_ConnectShark();
23126:             break;
23126: #endif
29368: #ifdef MOZ_TRACEVIS
29368:         case 'T':
29368:             if (++i == argc)
29368:                 return usage();
29368: 
38585:             StartTraceVis(argv[i]);
29368:             break;
29368: #endif
55474: #ifdef JS_THREADSAFE
55469:         case 'g':
55469:             if (++i == argc)
55469:                 return usage();
55469: 
55469:             PR_Sleep(PR_SecondsToInterval(atoi(argv[i])));
55469:             break;
55474: #endif
55469: 
23126:         default:
23126:             return usage();
23126:         }
23126:     }
23126: 
23126:     if (filename || isInteractive)
23126:         Process(cx, obj, filename, forceTTY);
23126:     return gExitCode;
23126: }
23126: 
23126: static JSBool
53557: Version(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     if (argc > 0 && JSVAL_IS_INT(argv[0]))
53557:         *vp = INT_TO_JSVAL(JS_SetVersion(cx, (JSVersion) JSVAL_TO_INT(argv[0])));
23126:     else
53557:         *vp = INT_TO_JSVAL(JS_GetVersion(cx));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53848: RevertVersion(JSContext *cx, uintN argc, jsval *vp)
53848: {
53848:     js_RevertVersion(cx);
53848:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53848:     return JS_TRUE;
53848: }
53848: 
53848: static JSBool
53557: Options(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uint32 optset, flag;
23126:     JSString *str;
23126:     const char *opt;
23126:     char *names;
23126:     JSBool found;
23126: 
23126:     optset = 0;
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (uintN i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         argv[i] = STRING_TO_JSVAL(str);
23126:         opt = JS_GetStringBytes(str);
23126:         if (!opt)
23126:             return JS_FALSE;
23126:         flag = MapContextOptionNameToFlag(cx,  opt);
23126:         if (!flag)
23126:             return JS_FALSE;
23126:         optset |= flag;
23126:     }
23126:     optset = JS_ToggleOptions(cx, optset);
23126: 
23126:     names = NULL;
23126:     found = JS_FALSE;
23126:     for (size_t i = 0; i != JS_ARRAY_LENGTH(js_options); i++) {
23126:         if (js_options[i].flag & optset) {
23126:             found = JS_TRUE;
23126:             names = JS_sprintf_append(names, "%s%s",
23126:                                       names ? "," : "", js_options[i].name);
23126:             if (!names)
23126:                 break;
23126:         }
23126:     }
23126:     if (!found)
23126:         names = strdup("");
23126:     if (!names) {
23126:         JS_ReportOutOfMemory(cx);
23126:         return JS_FALSE;
23126:     }
23126:     str = JS_NewString(cx, names, strlen(names));
23126:     if (!str) {
23126:         free(names);
23126:         return JS_FALSE;
23126:     }
53557:     *vp = STRING_TO_JSVAL(str);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Load(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i;
23126:     JSString *str;
23126:     const char *filename;
23126:     JSScript *script;
23126:     JSBool ok;
23126:     uint32 oldopts;
23126: 
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557:     if (!thisobj)
53557:         return JS_FALSE;
53557: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         argv[i] = STRING_TO_JSVAL(str);
23126:         filename = JS_GetStringBytes(str);
23126:         errno = 0;
23126:         oldopts = JS_GetOptions(cx);
23126:         JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
53557:         script = JS_CompileFile(cx, thisobj, filename);
23126:         JS_SetOptions(cx, oldopts);
23126:         if (!script) {
23126:             ok = JS_FALSE;
23126:         } else {
23126:             ok = !compileOnly
53557:                  ? JS_ExecuteScript(cx, thisobj, script, NULL)
23126:                  : JS_TRUE;
23126:             JS_DestroyScript(cx, script);
23126:         }
23126:         if (!ok)
23126:             return JS_FALSE;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: /*
23126:  * function readline()
23126:  * Provides a hook for scripts to read a line from stdin.
23126:  */
23126: static JSBool
23126: ReadLine(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126: #define BUFSIZE 256
23126:     FILE *from;
23126:     char *buf, *tmp;
23126:     size_t bufsize, buflength, gotlength;
23126:     JSBool sawNewline;
23126:     JSString *str;
23126: 
23126:     from = stdin;
23126:     buflength = 0;
23126:     bufsize = BUFSIZE;
23126:     buf = (char *) JS_malloc(cx, bufsize);
23126:     if (!buf)
23126:         return JS_FALSE;
23126: 
23126:     sawNewline = JS_FALSE;
23126:     while ((gotlength =
23126:             js_fgets(buf + buflength, bufsize - buflength, from)) > 0) {
23126:         buflength += gotlength;
23126: 
23126:         /* Are we done? */
23126:         if (buf[buflength - 1] == '\n') {
23126:             buf[buflength - 1] = '\0';
23126:             sawNewline = JS_TRUE;
23126:             break;
23126:         } else if (buflength < bufsize - 1) {
23126:             break;
23126:         }
23126: 
23126:         /* Else, grow our buffer for another pass. */
23126:         bufsize *= 2;
23126:         if (bufsize > buflength) {
23126:             tmp = (char *) JS_realloc(cx, buf, bufsize);
23126:         } else {
23126:             JS_ReportOutOfMemory(cx);
23126:             tmp = NULL;
23126:         }
23126: 
23126:         if (!tmp) {
23126:             JS_free(cx, buf);
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         buf = tmp;
23126:     }
23126: 
23126:     /* Treat the empty string specially. */
23126:     if (buflength == 0) {
23126:         *vp = feof(from) ? JSVAL_NULL : JS_GetEmptyStringValue(cx);
23126:         JS_free(cx, buf);
23126:         return JS_TRUE;
23126:     }
23126: 
23126:     /* Shrink the buffer to the real size. */
23126:     tmp = (char *) JS_realloc(cx, buf, buflength);
23126:     if (!tmp) {
23126:         JS_free(cx, buf);
23126:         return JS_FALSE;
23126:     }
23126: 
23126:     buf = tmp;
23126: 
23126:     /*
23126:      * Turn buf into a JSString. Note that buflength includes the trailing null
23126:      * character.
23126:      */
23126:     str = JS_NewString(cx, buf, sawNewline ? buflength - 1 : buflength);
23126:     if (!str) {
23126:         JS_free(cx, buf);
23126:         return JS_FALSE;
23126:     }
23126: 
23126:     *vp = STRING_TO_JSVAL(str);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48808: PutStr(JSContext *cx, uintN argc, jsval *vp)
48808: {
48808:     jsval *argv;
48808:     JSString *str;
48808:     char *bytes;
48808: 
48808:     if (argc != 0) {
48808:         argv = JS_ARGV(cx, vp);
48808:         str = JS_ValueToString(cx, argv[0]);
48808:         if (!str)
48808:             return JS_FALSE;
48808:         bytes = JS_EncodeString(cx, str);
48808:         if (!bytes)
48808:             return JS_FALSE;
48808:         fputs(bytes, gOutFile);
48808:         JS_free(cx, bytes);
48808:         fflush(gOutFile);
48808:     }
48808: 
48808:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
48808:     return JS_TRUE;
48808: }
48808: 
48808: static JSBool
49114: Now(JSContext *cx, uintN argc, jsval *vp)
49114: {
49114:     jsdouble now = PRMJ_Now() / double(PRMJ_USEC_PER_MSEC);
49114:     JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(now));
49114:     return true;
49114: }
49114: 
49114: static JSBool
23126: Print(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     jsval *argv;
23126:     uintN i;
23126:     JSString *str;
23126:     char *bytes;
23126: 
23126:     argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         bytes = JS_EncodeString(cx, str);
23126:         if (!bytes)
23126:             return JS_FALSE;
23126:         fprintf(gOutFile, "%s%s", i ? " " : "", bytes);
23126:         JS_free(cx, bytes);
23126:     }
23126: 
23126:     fputc('\n', gOutFile);
23126:     fflush(gOutFile);
23126: 
23126:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Help(JSContext *cx, uintN argc, jsval *vp);
23126: 
23126: static JSBool
53557: Quit(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "/ i", &gExitCode);
23126: 
23126:     gQuitting = JS_TRUE;
40801: #ifdef JS_THREADSAFE
55619:     if (gWorkerThreadPool)
55619:         js::workers::terminateAll(JS_GetRuntime(cx), gWorkerThreadPool);
40801: #endif
23126:     return JS_FALSE;
23126: }
23126: 
25699: static const char *
25699: ToSource(JSContext *cx, jsval *vp)
25699: {
25699:     JSString *str = JS_ValueToSource(cx, *vp);
25699:     if (str) {
25699:         *vp = STRING_TO_JSVAL(str);
25699:         return JS_GetStringBytes(str);
25699:     }
25699:     JS_ClearPendingException(cx);
25699:     return "<<error converting value to string>>";
25699: }
25699: 
25699: static JSBool
25699: AssertEq(JSContext *cx, uintN argc, jsval *vp)
25699: {
32760:     if (!(argc == 2 || (argc == 3 && JSVAL_IS_STRING(JS_ARGV(cx, vp)[2])))) {
25699:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
32760:                              (argc < 2)
32760:                              ? JSSMSG_NOT_ENOUGH_ARGS
32760:                              : (argc == 3)
32760:                              ? JSSMSG_INVALID_ARGS
32760:                              : JSSMSG_TOO_MANY_ARGS,
25699:                              "assertEq");
25699:         return JS_FALSE;
25699:     }
25699: 
25699:     jsval *argv = JS_ARGV(cx, vp);
32760:     if (!JS_SameValue(cx, argv[0], argv[1])) {
25699:         const char *actual = ToSource(cx, &argv[0]);
25699:         const char *expected = ToSource(cx, &argv[1]);
32760:         if (argc == 2) {
25699:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_EQ_FAILED,
25699:                                  actual, expected);
32760:         } else {
32760:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_EQ_FAILED_MSG,
32760:                                  actual, expected, JS_GetStringBytes(JSVAL_TO_STRING(argv[2])));
32760:         }
25699:         return JS_FALSE;
25699:     }
25699:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
25699:     return JS_TRUE;
25699: }
25699: 
23126: static JSBool
53120: AssertJit(JSContext *cx, uintN argc, jsval *vp)
53120: {
53120: #ifdef JS_METHODJIT
53120:     if (JS_GetOptions(cx) & JSOPTION_METHODJIT) {
55503:         if (!cx->fp()->script()->getJIT(cx->fp()->isConstructing())) {
53120:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_JIT_FAILED);
53120:             return JS_FALSE;
53120:         }
53120:     }
53120: #endif
53120: 
53120:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53120:     return JS_TRUE;
53120: }
53120: 
53120: static JSBool
23126: GC(JSContext *cx, uintN argc, jsval *vp)
23126: {
36680:     size_t preBytes = cx->runtime->gcBytes;
23126:     JS_GC(cx);
23126: 
28179:     char buf[256];
28179:     JS_snprintf(buf, sizeof(buf), "before %lu, after %lu, break %08lx\n",
36680:                 (unsigned long)preBytes, (unsigned long)cx->runtime->gcBytes,
31119: #ifdef HAVE_SBRK
23126:                 (unsigned long)sbrk(0)
23126: #else
23126:                 0
23126: #endif
23126:                 );
36680:     *vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, buf));
36680:     return true;
36680: }
36680: 
23126: #ifdef JS_GCMETER
36680: static JSBool
36680: GCStats(JSContext *cx, uintN argc, jsval *vp)
36680: {
36680:     js_DumpGCStats(cx->runtime, stdout);
36680:     *vp = JSVAL_VOID;
36680:     return true;
36680: }
23126: #endif
23126: 
23126: static JSBool
23126: GCParameter(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
23126:     const char *paramName;
23126:     JSGCParamKey param;
23126:     uint32 value;
23126: 
23126:     if (argc == 0) {
23126:         str = JS_ValueToString(cx, JSVAL_VOID);
23126:         JS_ASSERT(str);
23126:     } else {
23126:         str = JS_ValueToString(cx, vp[2]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         vp[2] = STRING_TO_JSVAL(str);
23126:     }
23126:     paramName = JS_GetStringBytes(str);
23126:     if (!paramName)
23126:         return JS_FALSE;
23126:     if (strcmp(paramName, "maxBytes") == 0) {
23126:         param = JSGC_MAX_BYTES;
32553:     } else if (strcmp(paramName, "maxMallocBytes") == 0) {
32553:         param = JSGC_MAX_MALLOC_BYTES;
24313:     } else if (strcmp(paramName, "gcStackpoolLifespan") == 0) {
24313:         param = JSGC_STACKPOOL_LIFESPAN;
24313:     } else if (strcmp(paramName, "gcBytes") == 0) {
24313:         param = JSGC_BYTES;
24313:     } else if (strcmp(paramName, "gcNumber") == 0) {
24313:         param = JSGC_NUMBER;
32553:     } else if (strcmp(paramName, "gcTriggerFactor") == 0) {
32553:         param = JSGC_TRIGGER_FACTOR;
23126:     } else {
23126:         JS_ReportError(cx,
24313:                        "the first argument argument must be maxBytes, "
24313:                        "maxMallocBytes, gcStackpoolLifespan, gcBytes, "
24313:                        "gcNumber or gcTriggerFactor");
23126:         return JS_FALSE;
23126:     }
23126: 
24313:     if (argc == 1) {
24313:         value = JS_GetGCParameter(cx->runtime, param);
24313:         return JS_NewNumberValue(cx, value, &vp[0]);
24313:     }
24313: 
24313:     if (param == JSGC_NUMBER ||
24313:         param == JSGC_BYTES) {
24313:         JS_ReportError(cx, "Attempt to change read-only parameter %s",
24313:                        paramName);
23126:         return JS_FALSE;
24313:     }
24313: 
24313:     if (!JS_ValueToECMAUint32(cx, vp[3], &value)) {
23126:         JS_ReportError(cx,
24313:                        "the second argument must be convertable to uint32 "
24313:                        "with non-zero value");
24313:         return JS_FALSE;
24313:     }
32553:     if (param == JSGC_TRIGGER_FACTOR && value < 100) {
32553:         JS_ReportError(cx,
32553:                        "the gcTriggerFactor value must be >= 100");
32553:         return JS_FALSE;
32553:     }
23126:     JS_SetGCParameter(cx->runtime, param, value);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: 
23126: #ifdef JS_GC_ZEAL
23126: static JSBool
23126: GCZeal(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uint32 zeal;
23126: 
23126:     if (!JS_ValueToECMAUint32(cx, argc == 0 ? JSVAL_VOID : vp[2], &zeal))
23126:         return JS_FALSE;
23126:     JS_SetGCZeal(cx, (uint8)zeal);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: #endif /* JS_GC_ZEAL */
23126: 
23126: typedef struct JSCountHeapNode JSCountHeapNode;
23126: 
23126: struct JSCountHeapNode {
23126:     void                *thing;
23126:     int32               kind;
23126:     JSCountHeapNode     *next;
23126: };
23126: 
23126: typedef struct JSCountHeapTracer {
23126:     JSTracer            base;
23126:     JSDHashTable        visited;
23126:     JSBool              ok;
23126:     JSCountHeapNode     *traceList;
23126:     JSCountHeapNode     *recycleList;
23126: } JSCountHeapTracer;
23126: 
23126: static void
23126: CountHeapNotify(JSTracer *trc, void *thing, uint32 kind)
23126: {
23126:     JSCountHeapTracer *countTracer;
23126:     JSDHashEntryStub *entry;
23126:     JSCountHeapNode *node;
23126: 
23126:     JS_ASSERT(trc->callback == CountHeapNotify);
23126:     countTracer = (JSCountHeapTracer *)trc;
23126:     if (!countTracer->ok)
23126:         return;
23126: 
23126:     entry = (JSDHashEntryStub *)
23126:             JS_DHashTableOperate(&countTracer->visited, thing, JS_DHASH_ADD);
23126:     if (!entry) {
23126:         JS_ReportOutOfMemory(trc->context);
23126:         countTracer->ok = JS_FALSE;
23126:         return;
23126:     }
23126:     if (entry->key)
23126:         return;
23126:     entry->key = thing;
23126: 
23126:     node = countTracer->recycleList;
23126:     if (node) {
23126:         countTracer->recycleList = node->next;
23126:     } else {
23126:         node = (JSCountHeapNode *) JS_malloc(trc->context, sizeof *node);
23126:         if (!node) {
23126:             countTracer->ok = JS_FALSE;
23126:             return;
23126:         }
23126:     }
23126:     node->thing = thing;
23126:     node->kind = kind;
23126:     node->next = countTracer->traceList;
23126:     countTracer->traceList = node;
23126: }
23126: 
23126: static JSBool
23126: CountHeap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     void* startThing;
23126:     int32 startTraceKind;
23126:     jsval v;
23126:     int32 traceKind, i;
23126:     JSString *str;
23126:     char *bytes;
23126:     JSCountHeapTracer countTracer;
23126:     JSCountHeapNode *node;
23126:     size_t counter;
23126: 
23126:     static const struct {
23126:         const char       *name;
23126:         int32             kind;
23126:     } traceKindNames[] = {
23126:         { "all",        -1                  },
23126:         { "object",     JSTRACE_OBJECT      },
23126:         { "string",     JSTRACE_STRING      },
23126: #if JS_HAS_XML_SUPPORT
23126:         { "xml",        JSTRACE_XML         },
23126: #endif
23126:     };
23126: 
23126:     startThing = NULL;
23126:     startTraceKind = 0;
23126:     if (argc > 0) {
23126:         v = JS_ARGV(cx, vp)[0];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             startThing = JSVAL_TO_TRACEABLE(v);
23126:             startTraceKind = JSVAL_TRACE_KIND(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             JS_ReportError(cx,
23126:                            "the first argument is not null or a heap-allocated "
23126:                            "thing");
23126:             return JS_FALSE;
23126:         }
23126:     }
23126: 
23126:     traceKind = -1;
23126:     if (argc > 1) {
23126:         str = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         bytes = JS_GetStringBytes(str);
23126:         if (!bytes)
23126:             return JS_FALSE;
23126:         for (i = 0; ;) {
23126:             if (strcmp(bytes, traceKindNames[i].name) == 0) {
23126:                 traceKind = traceKindNames[i].kind;
23126:                 break;
23126:             }
23126:             if (++i == JS_ARRAY_LENGTH(traceKindNames)) {
23126:                 JS_ReportError(cx, "trace kind name '%s' is unknown", bytes);
23126:                 return JS_FALSE;
23126:             }
23126:         }
23126:     }
23126: 
23126:     JS_TRACER_INIT(&countTracer.base, cx, CountHeapNotify);
23126:     if (!JS_DHashTableInit(&countTracer.visited, JS_DHashGetStubOps(),
23126:                            NULL, sizeof(JSDHashEntryStub),
23126:                            JS_DHASH_DEFAULT_CAPACITY(100))) {
23126:         JS_ReportOutOfMemory(cx);
23126:         return JS_FALSE;
23126:     }
23126:     countTracer.ok = JS_TRUE;
23126:     countTracer.traceList = NULL;
23126:     countTracer.recycleList = NULL;
23126: 
23126:     if (!startThing) {
23126:         JS_TraceRuntime(&countTracer.base);
23126:     } else {
23126:         JS_SET_TRACING_NAME(&countTracer.base, "root");
23126:         JS_CallTracer(&countTracer.base, startThing, startTraceKind);
23126:     }
23126: 
23126:     counter = 0;
23126:     while ((node = countTracer.traceList) != NULL) {
23126:         if (traceKind == -1 || node->kind == traceKind)
23126:             counter++;
23126:         countTracer.traceList = node->next;
23126:         node->next = countTracer.recycleList;
23126:         countTracer.recycleList = node;
23126:         JS_TraceChildren(&countTracer.base, node->thing, node->kind);
23126:     }
23126:     while ((node = countTracer.recycleList) != NULL) {
23126:         countTracer.recycleList = node->next;
23126:         JS_free(cx, node);
23126:     }
23126:     JS_DHashTableFinish(&countTracer.visited);
23126: 
23126:     return countTracer.ok && JS_NewNumberValue(cx, (jsdouble) counter, vp);
23126: }
23126: 
54561: static jsrefcount finalizeCount = 0;
54561: 
54561: static void
54561: finalize_counter_finalize(JSContext *cx, JSObject *obj)
54561: {
54561:     JS_ATOMIC_INCREMENT(&finalizeCount);
54561: }
54561: 
54561: static JSClass FinalizeCounterClass = {
54561:     "FinalizeCounter", JSCLASS_IS_ANONYMOUS,
54561:     JS_PropertyStub,   /* addProperty */
54561:     JS_PropertyStub,   /* delProperty */
54561:     JS_PropertyStub,   /* getProperty */
54561:     JS_PropertyStub,   /* setProperty */
54561:     JS_EnumerateStub,
54561:     JS_ResolveStub,
54561:     JS_ConvertStub,
54561:     finalize_counter_finalize
54561: };
54561: 
54561: static JSBool
54561: MakeFinalizeObserver(JSContext *cx, uintN argc, jsval *vp)
54561: {
54561:     JSObject *obj = JS_NewObjectWithGivenProto(cx, &FinalizeCounterClass, NULL,
54561:                                                JS_GetGlobalObject(cx));
54561:     if (!obj)
54561:         return false;
54561:     *vp = OBJECT_TO_JSVAL(obj);
54561:     return true;
54561: }
54561: 
54561: static JSBool
54561: FinalizeCount(JSContext *cx, uintN argc, jsval *vp)
54561: {
54561:     *vp = INT_TO_JSVAL(finalizeCount);
54561:     return true;
54561: }
54561: 
23126: static JSScript *
23126: ValueToScript(JSContext *cx, jsval v)
23126: {
27012:     JSScript *script = NULL;
23126:     JSFunction *fun;
23126: 
27012:     if (!JSVAL_IS_PRIMITIVE(v)) {
27012:         JSObject *obj = JSVAL_TO_OBJECT(v);
27012:         JSClass *clasp = JS_GET_CLASS(cx, obj);
27012: 
48470:         if (clasp == Jsvalify(&js_ScriptClass)) {
27012:             script = (JSScript *) JS_GetPrivate(cx, obj);
48622:         } else if (clasp == Jsvalify(&js_GeneratorClass)) {
27012:             JSGenerator *gen = (JSGenerator *) JS_GetPrivate(cx, obj);
53840:             fun = gen->floatingFrame()->fun();
27012:             script = FUN_SCRIPT(fun);
27012:         }
27012:     }
27012: 
27012:     if (!script) {
23126:         fun = JS_ValueToFunction(cx, v);
23126:         if (!fun)
23126:             return NULL;
23126:         script = FUN_SCRIPT(fun);
23126:         if (!script) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_SCRIPTS_ONLY);
23126:         }
27012:     }
23126: 
23126:     return script;
23126: }
23126: 
23126: static JSBool
53557: SetDebug(JSContext *cx, uintN argc, jsval *vp)
53391: {
53557:     jsval *argv = JS_ARGV(cx, vp);
53391:     if (argc == 0 || !JSVAL_IS_BOOLEAN(argv[0])) {
53391:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53391:                              JSSMSG_NOT_ENOUGH_ARGS, "setDebug");
53391:         return JS_FALSE;
53391:     }
53391:     
53391:     js_SetDebugMode(cx, JSVAL_TO_BOOLEAN(argv[0]));
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53391:     return JS_TRUE;
53391: }
53391: 
53391: static JSBool
23126: GetTrapArgs(JSContext *cx, uintN argc, jsval *argv, JSScript **scriptp,
23126:             int32 *ip)
23126: {
23126:     jsval v;
23126:     uintN intarg;
23126:     JSScript *script;
23126: 
53840:     *scriptp = JS_GetScriptedCaller(cx, NULL)->script();
23126:     *ip = 0;
23126:     if (argc != 0) {
23126:         v = argv[0];
23126:         intarg = 0;
23126:         if (!JSVAL_IS_PRIMITIVE(v) &&
48470:             (JS_GET_CLASS(cx, JSVAL_TO_OBJECT(v)) == Jsvalify(&js_FunctionClass) ||
48470:              JS_GET_CLASS(cx, JSVAL_TO_OBJECT(v)) == Jsvalify(&js_ScriptClass))) {
23126:             script = ValueToScript(cx, v);
23126:             if (!script)
23126:                 return JS_FALSE;
23126:             *scriptp = script;
23126:             intarg++;
23126:         }
23126:         if (argc > intarg) {
23126:             if (!JS_ValueToInt32(cx, argv[intarg], ip))
23126:                 return JS_FALSE;
23126:         }
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSTrapStatus
23126: TrapHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
41863:             jsval closure)
23126: {
48582:     JSString *str = JSVAL_TO_STRING(closure);
48582:     JSStackFrame *caller = JS_GetScriptedCaller(cx, NULL);
39916:     if (!JS_EvaluateUCInStackFrame(cx, caller,
39916:                                    JS_GetStringChars(str), JS_GetStringLength(str),
53840:                                    caller->script()->filename,
53840:                                    caller->script()->lineno,
23126:                                    rval)) {
23126:         return JSTRAP_ERROR;
23126:     }
23126:     if (!JSVAL_IS_VOID(*rval))
23126:         return JSTRAP_RETURN;
23126:     return JSTRAP_CONTINUE;
23126: }
23126: 
23126: static JSBool
53557: Trap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
23126:     JSScript *script;
23126:     int32 i;
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     if (argc == 0) {
23126:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_TRAP_USAGE);
23126:         return JS_FALSE;
23126:     }
23126:     argc--;
23126:     str = JS_ValueToString(cx, argv[argc]);
23126:     if (!str)
23126:         return JS_FALSE;
23126:     argv[argc] = STRING_TO_JSVAL(str);
23126:     if (!GetTrapArgs(cx, argc, argv, &script, &i))
23126:         return JS_FALSE;
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
41863:     return JS_SetTrap(cx, script, script->code + i, TrapHandler, STRING_TO_JSVAL(str));
23126: }
23126: 
23126: static JSBool
53557: Untrap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126:     int32 i;
23126: 
53557:     if (!GetTrapArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     JS_ClearTrap(cx, script, script->code + i, NULL, NULL);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
53395: static JSTrapStatus
53410: DebuggerAndThrowHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
53395:                         void *closure)
53395: {
53395:     return TrapHandler(cx, script, pc, rval, STRING_TO_JSVAL((JSString *)closure));
53395: }
53395: 
53395: static JSBool
53557: SetDebuggerHandler(JSContext *cx, uintN argc, jsval *vp)
53395: {
53395:     JSString *str;
53395:     if (argc == 0) {
53395:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53395:                              JSSMSG_NOT_ENOUGH_ARGS, "setDebuggerHandler");
53395:         return JS_FALSE;
53395:     }
53395: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
53395:     if (!str)
53395:         return JS_FALSE;
53395: 
53410:     JS_SetDebuggerHandler(cx->runtime, DebuggerAndThrowHandler, str);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53410:     return JS_TRUE;
53410: }
53410: 
53410: static JSBool
53557: SetThrowHook(JSContext *cx, uintN argc, jsval *vp)
53410: {
53410:     JSString *str;
53410:     if (argc == 0) {
53410:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53410:                              JSSMSG_NOT_ENOUGH_ARGS, "setThrowHook");
53410:         return JS_FALSE;
53410:     }
53410: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
53410:     if (!str)
53410:         return JS_FALSE;
53410: 
53410:     JS_SetThrowHook(cx->runtime, DebuggerAndThrowHandler, str);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53395:     return JS_TRUE;
53395: }
53395: 
23126: static JSBool
53557: LineToPC(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126:     int32 i;
23126:     uintN lineno;
23126:     jsbytecode *pc;
23126: 
23126:     if (argc == 0) {
23126:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_LINE2PC_USAGE);
23126:         return JS_FALSE;
23126:     }
53840:     script = JS_GetScriptedCaller(cx, NULL)->script();
53557:     if (!GetTrapArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     lineno = (i == 0) ? script->lineno : (uintN)i;
23126:     pc = JS_LineNumberToPC(cx, script, lineno);
23126:     if (!pc)
23126:         return JS_FALSE;
53557:     *vp = INT_TO_JSVAL(pc - script->code);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: PCToLine(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126:     int32 i;
23126:     uintN lineno;
23126: 
53557:     if (!GetTrapArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     lineno = JS_PCToLineNumber(cx, script, script->code + i);
23126:     if (!lineno)
23126:         return JS_FALSE;
53557:     *vp = INT_TO_JSVAL(lineno);
23126:     return JS_TRUE;
23126: }
23126: 
23126: #ifdef DEBUG
23126: 
23126: static void
25216: UpdateSwitchTableBounds(JSContext *cx, JSScript *script, uintN offset,
23126:                         uintN *start, uintN *end)
23126: {
23126:     jsbytecode *pc;
23126:     JSOp op;
23126:     ptrdiff_t jmplen;
23126:     jsint low, high, n;
23126: 
23126:     pc = script->code + offset;
25216:     op = js_GetOpcode(cx, script, pc);
23126:     switch (op) {
23126:       case JSOP_TABLESWITCHX:
23126:         jmplen = JUMPX_OFFSET_LEN;
23126:         goto jump_table;
23126:       case JSOP_TABLESWITCH:
23126:         jmplen = JUMP_OFFSET_LEN;
23126:       jump_table:
23126:         pc += jmplen;
23126:         low = GET_JUMP_OFFSET(pc);
23126:         pc += JUMP_OFFSET_LEN;
23126:         high = GET_JUMP_OFFSET(pc);
23126:         pc += JUMP_OFFSET_LEN;
23126:         n = high - low + 1;
23126:         break;
23126: 
23126:       case JSOP_LOOKUPSWITCHX:
23126:         jmplen = JUMPX_OFFSET_LEN;
23126:         goto lookup_table;
23126:       case JSOP_LOOKUPSWITCH:
23126:         jmplen = JUMP_OFFSET_LEN;
23126:       lookup_table:
23126:         pc += jmplen;
23126:         n = GET_INDEX(pc);
23126:         pc += INDEX_LEN;
23126:         jmplen += JUMP_OFFSET_LEN;
23126:         break;
23126: 
23126:       default:
23126:         /* [condswitch] switch does not have any jump or lookup tables. */
23126:         JS_ASSERT(op == JSOP_CONDSWITCH);
23126:         return;
23126:     }
23126: 
23126:     *start = (uintN)(pc - script->code);
23126:     *end = *start + (uintN)(n * jmplen);
23126: }
23126: 
23126: static void
23126: SrcNotes(JSContext *cx, JSScript *script)
23126: {
23126:     uintN offset, delta, caseOff, switchTableStart, switchTableEnd;
23126:     jssrcnote *notes, *sn;
23126:     JSSrcNoteType type;
23126:     const char *name;
23126:     uint32 index;
23126:     JSAtom *atom;
23126:     JSString *str;
23126: 
23126:     fprintf(gOutFile, "\nSource notes:\n");
23126:     offset = 0;
32723:     notes = script->notes();
23126:     switchTableEnd = switchTableStart = 0;
23126:     for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
23126:         delta = SN_DELTA(sn);
23126:         offset += delta;
23126:         type = (JSSrcNoteType) SN_TYPE(sn);
23126:         name = js_SrcNoteSpec[type].name;
23126:         if (type == SRC_LABEL) {
23126:             /* Check if the source note is for a switch case. */
23126:             if (switchTableStart <= offset && offset < switchTableEnd) {
23126:                 name = "case";
23126:             } else {
25216:                 JS_ASSERT(js_GetOpcode(cx, script, script->code + offset) == JSOP_NOP);
23126:             }
23126:         }
23126:         fprintf(gOutFile, "%3u: %5u [%4u] %-8s",
25144:                 (uintN) (sn - notes), offset, delta, name);
23126:         switch (type) {
23126:           case SRC_SETLINE:
23126:             fprintf(gOutFile, " lineno %u", (uintN) js_GetSrcNoteOffset(sn, 0));
23126:             break;
23126:           case SRC_FOR:
23126:             fprintf(gOutFile, " cond %u update %u tail %u",
23126:                    (uintN) js_GetSrcNoteOffset(sn, 0),
23126:                    (uintN) js_GetSrcNoteOffset(sn, 1),
23126:                    (uintN) js_GetSrcNoteOffset(sn, 2));
23126:             break;
23126:           case SRC_IF_ELSE:
23126:             fprintf(gOutFile, " else %u elseif %u",
23126:                    (uintN) js_GetSrcNoteOffset(sn, 0),
23126:                    (uintN) js_GetSrcNoteOffset(sn, 1));
23126:             break;
23126:           case SRC_COND:
23126:           case SRC_WHILE:
23126:           case SRC_PCBASE:
23126:           case SRC_PCDELTA:
23126:           case SRC_DECL:
23126:           case SRC_BRACE:
23126:             fprintf(gOutFile, " offset %u", (uintN) js_GetSrcNoteOffset(sn, 0));
23126:             break;
23126:           case SRC_LABEL:
23126:           case SRC_LABELBRACE:
23126:           case SRC_BREAK2LABEL:
23126:           case SRC_CONT2LABEL:
23126:             index = js_GetSrcNoteOffset(sn, 0);
32673:             JS_GET_SCRIPT_ATOM(script, NULL, index, atom);
23126:             str = ATOM_TO_STRING(atom);
23126:             fprintf(gOutFile, " atom %u (", index);
23126:             js_FileEscapedString(gOutFile, str, 0);
23126:             putc(')', gOutFile);
23126:             break;
23126:           case SRC_FUNCDEF: {
23126:             const char *bytes;
23126:             JSObject *obj;
23126:             JSFunction *fun;
23126: 
23126:             index = js_GetSrcNoteOffset(sn, 0);
32723:             obj = script->getObject(index);
23126:             fun = (JSFunction *) JS_GetPrivate(cx, obj);
23126:             str = JS_DecompileFunction(cx, fun, JS_DONT_PRETTY_PRINT);
31366:             if (str) {
31366:               bytes = JS_GetStringBytes(str);
31366:             } else {
47498:               ReportException(cx);
31366:               bytes = "N/A";
31366:             }
23126:             fprintf(gOutFile, " function %u (%s)", index, bytes);
23126:             break;
23126:           }
23126:           case SRC_SWITCH:
23126:             fprintf(gOutFile, " length %u", (uintN) js_GetSrcNoteOffset(sn, 0));
23126:             caseOff = (uintN) js_GetSrcNoteOffset(sn, 1);
23126:             if (caseOff)
23126:                 fprintf(gOutFile, " first case offset %u", caseOff);
25216:             UpdateSwitchTableBounds(cx, script, offset,
23126:                                     &switchTableStart, &switchTableEnd);
23126:             break;
23126:           case SRC_CATCH:
23126:             delta = (uintN) js_GetSrcNoteOffset(sn, 0);
23126:             if (delta) {
23126:                 if (script->main[offset] == JSOP_LEAVEBLOCK)
23126:                     fprintf(gOutFile, " stack depth %u", delta);
23126:                 else
23126:                     fprintf(gOutFile, " guard delta %u", delta);
23126:             }
23126:             break;
23126:           default:;
23126:         }
23126:         fputc('\n', gOutFile);
23126:     }
23126: }
23126: 
23126: static JSBool
53557: Notes(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i;
23126:     JSScript *script;
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         script = ValueToScript(cx, argv[i]);
23126:         if (!script)
23126:             continue;
23126: 
23126:         SrcNotes(cx, script);
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: JS_STATIC_ASSERT(JSTRY_CATCH == 0);
23126: JS_STATIC_ASSERT(JSTRY_FINALLY == 1);
23126: JS_STATIC_ASSERT(JSTRY_ITER == 2);
23126: 
23126: static const char* const TryNoteNames[] = { "catch", "finally", "iter" };
23126: 
23126: static JSBool
23126: TryNotes(JSContext *cx, JSScript *script)
23126: {
23126:     JSTryNote *tn, *tnlimit;
23126: 
23126:     if (script->trynotesOffset == 0)
23126:         return JS_TRUE;
23126: 
32723:     tn = script->trynotes()->vector;
32723:     tnlimit = tn + script->trynotes()->length;
23126:     fprintf(gOutFile, "\nException table:\n"
23126:             "kind      stack    start      end\n");
23126:     do {
23126:         JS_ASSERT(tn->kind < JS_ARRAY_LENGTH(TryNoteNames));
23126:         fprintf(gOutFile, " %-7s %6u %8u %8u\n",
23126:                 TryNoteNames[tn->kind], tn->stackDepth,
23126:                 tn->start, tn->start + tn->length);
23126:     } while (++tn != tnlimit);
23126:     return JS_TRUE;
23126: }
23126: 
28924: static bool
28924: DisassembleValue(JSContext *cx, jsval v, bool lines, bool recursive)
23126: {
28924:     JSScript *script = ValueToScript(cx, v);
23126:     if (!script)
28924:         return false;
28924:     if (VALUE_IS_FUNCTION(cx, v)) {
28924:         JSFunction *fun = JS_ValueToFunction(cx, v);
27012:         if (fun && (fun->flags & ~7U)) {
23126:             uint16 flags = fun->flags;
23126:             fputs("flags:", stdout);
23126: 
23126: #define SHOW_FLAG(flag) if (flags & JSFUN_##flag) fputs(" " #flag, stdout);
23126: 
23126:             SHOW_FLAG(LAMBDA);
23126:             SHOW_FLAG(HEAVYWEIGHT);
55711:             SHOW_FLAG(PRIMITIVE_THIS);
23126:             SHOW_FLAG(EXPR_CLOSURE);
32669:             SHOW_FLAG(TRCINFO);
23126: 
23126: #undef SHOW_FLAG
27012: 
37014:             if (FUN_INTERPRETED(fun)) {
27012:                 if (FUN_NULL_CLOSURE(fun))
27012:                     fputs(" NULL_CLOSURE", stdout);
27012:                 else if (FUN_FLAT_CLOSURE(fun))
27012:                     fputs(" FLAT_CLOSURE", stdout);
37014: 
37014:                 if (fun->u.i.nupvars) {
37014:                     fputs("\nupvars: {\n", stdout);
37014: 
47609:                     void *mark = JS_ARENA_MARK(&cx->tempPool);
52503:                     jsuword *localNames = fun->getLocalNameArray(cx, &cx->tempPool);
37014:                     if (!localNames)
37014:                         return false;
37014: 
37014:                     JSUpvarArray *uva = fun->u.i.script->upvars();
37014:                     uintN upvar_base = fun->countArgsAndVars();
37014: 
37014:                     for (uint32 i = 0, n = uva->length; i < n; i++) {
37014:                         JSAtom *atom = JS_LOCAL_NAME_TO_ATOM(localNames[upvar_base + i]);
47573:                         UpvarCookie cookie = uva->vector[i];
37014: 
37014:                         printf("  %s: {skip:%u, slot:%u},\n",
47573:                                js_AtomToPrintableString(cx, atom), cookie.level(), cookie.slot());
37014:                     }
37014: 
47609:                     JS_ARENA_RELEASE(&cx->tempPool, mark);
37014:                     putchar('}');
37014:                 }
37014:             }
23126:             putchar('\n');
23126:         }
23126:     }
23126: 
23126:     if (!js_Disassemble(cx, script, lines, stdout))
28924:         return false;
23126:     SrcNotes(cx, script);
23126:     TryNotes(cx, script);
28924: 
28924:     if (recursive && script->objectsOffset != 0) {
32723:         JSObjectArray *objects = script->objects();
28924:         for (uintN i = 0; i != objects->length; ++i) {
28924:             JSObject *obj = objects->vector[i];
40430:             if (obj->isFunction()) {
28924:                 putchar('\n');
28924:                 if (!DisassembleValue(cx, OBJECT_TO_JSVAL(obj),
28924:                                       lines, recursive)) {
28924:                     return false;
28924:                 }
28924:             }
28924:         }
28924:     }
28924:     return true;
28924: }
28924: 
28924: static JSBool
53557: Disassemble(JSContext *cx, uintN argc, jsval *vp)
28924: {
28924:     bool lines = false, recursive = false;
28924: 
53557:     jsval *argv = JS_ARGV(cx, vp);
28924:     while (argc > 0 && JSVAL_IS_STRING(argv[0])) {
28924:         const char *bytes = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
28924:         lines = !strcmp(bytes, "-l");
28924:         recursive = !strcmp(bytes, "-r");
28924:         if (!lines && !recursive)
28924:             break;
28924:         argv++, argc--;
28924:     }
28924: 
28924:     for (uintN i = 0; i < argc; i++) {
28924:         if (!DisassembleValue(cx, argv[i], lines, recursive))
28924:             return false;
28924:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
28924:     return true;
23126: }
23126: 
23126: static JSBool
53557: DisassFile(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
23126:     const char *filename;
23126:     JSScript *script;
23126:     JSBool ok;
23126:     uint32 oldopts;
53637:     jsval *argv = JS_ARGV(cx, vp);
23126: 
53639:     if (!argc) {
53639:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:         return JS_TRUE;
53639:     }
23126: 
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557:     if (!thisobj)
53557:         return JS_FALSE;
53557: 
53637:     str = JS_ValueToString(cx, argv[0]);
23126:     if (!str)
23126:         return JS_FALSE;
23126: 
23126:     filename = JS_GetStringBytes(str);
23126:     oldopts = JS_GetOptions(cx);
23126:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
53557:     script = JS_CompileFile(cx, thisobj, filename);
23126:     JS_SetOptions(cx, oldopts);
23126:     if (!script)
23126:         return JS_FALSE;
23126: 
53639:     if (script->isEmpty()) {
53639:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
48470:         return JS_TRUE;
53639:     }
48470: 
53557:     JSObject *obj = JS_NewScriptObject(cx, script);
23126:     if (!obj)
23126:         return JS_FALSE;
23126: 
53637:     argv[0] = OBJECT_TO_JSVAL(obj); /* I like to root it, root it. */
53557:     ok = Disassemble(cx, 1, vp); /* gross, but works! */
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return ok;
23126: }
23126: 
23126: static JSBool
53557: DisassWithSrc(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126: #define LINE_BUF_LEN 512
23126:     uintN i, len, line1, line2, bupline;
23126:     JSScript *script;
23126:     FILE *file;
23126:     char linebuf[LINE_BUF_LEN];
23126:     jsbytecode *pc, *end;
23126:     JSBool ok;
23126:     static char sep[] = ";-------------------------";
23126: 
23126:     ok = JS_TRUE;
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; ok && i < argc; i++) {
23126:         script = ValueToScript(cx, argv[i]);
23126:         if (!script)
23126:            return JS_FALSE;
23126: 
23126:         if (!script->filename) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_FILE_SCRIPTS_ONLY);
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         file = fopen(script->filename, "r");
23126:         if (!file) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_CANT_OPEN, script->filename,
23126:                                  strerror(errno));
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         pc = script->code;
23126:         end = pc + script->length;
23126: 
23126:         /* burn the leading lines */
23126:         line2 = JS_PCToLineNumber(cx, script, pc);
40289:         for (line1 = 0; line1 < line2 - 1; line1++) {
40289:             char *tmp = fgets(linebuf, LINE_BUF_LEN, file);
40289:             if (!tmp) {
40289:                 JS_ReportError(cx, "failed to read %s fully",
40289:                                script->filename);
40289:                 ok = JS_FALSE;
40289:                 goto bail;
40289:             }
40289:         }
23126: 
23126:         bupline = 0;
23126:         while (pc < end) {
23126:             line2 = JS_PCToLineNumber(cx, script, pc);
23126: 
23126:             if (line2 < line1) {
23126:                 if (bupline != line2) {
23126:                     bupline = line2;
23126:                     fprintf(gOutFile, "%s %3u: BACKUP\n", sep, line2);
23126:                 }
23126:             } else {
23126:                 if (bupline && line1 == line2)
23126:                     fprintf(gOutFile, "%s %3u: RESTORE\n", sep, line2);
23126:                 bupline = 0;
23126:                 while (line1 < line2) {
23126:                     if (!fgets(linebuf, LINE_BUF_LEN, file)) {
23126:                         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                              JSSMSG_UNEXPECTED_EOF,
23126:                                              script->filename);
23126:                         ok = JS_FALSE;
23126:                         goto bail;
23126:                     }
23126:                     line1++;
23126:                     fprintf(gOutFile, "%s %3u: %s", sep, line1, linebuf);
23126:                 }
23126:             }
23126: 
23126:             len = js_Disassemble1(cx, script, pc,
25144:                                   pc - script->code,
23126:                                   JS_TRUE, stdout);
23126:             if (!len) {
23126:                 ok = JS_FALSE;
23126:                 goto bail;
23126:             }
23126:             pc += len;
23126:         }
23126: 
23126:       bail:
23126:         fclose(file);
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return ok;
23126: #undef LINE_BUF_LEN
23126: }
23126: 
23126: static JSBool
53557: Tracing(JSContext *cx, uintN argc, jsval *vp)
23126: {
26954:     FILE *file;
26954: 
23126:     if (argc == 0) {
53557:         *vp = BOOLEAN_TO_JSVAL(cx->tracefp != 0);
23126:         return JS_TRUE;
23126:     }
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     switch (JS_TypeOfValue(cx, argv[0])) {
23126:       case JSTYPE_NUMBER:
26954:       case JSTYPE_BOOLEAN: {
26954:         JSBool bval;
30581:         JS_ValueToBoolean(cx, argv[0], &bval);
26954:         file = bval ? stderr : NULL;
23126:         break;
26954:       }
26954:       case JSTYPE_STRING: {
26954:         char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
26954:         file = fopen(name, "w");
26954:         if (!file) {
26954:             JS_ReportError(cx, "tracing: couldn't open output file %s: %s", 
26954:                            name, strerror(errno));
26954:             return JS_FALSE;
26954:         }
23126:         break;
26954:       }
23126:       default:
26954:           goto bad_argument;
26954:     }
26954:     if (cx->tracefp && cx->tracefp != stderr)
26954:       fclose((FILE *)cx->tracefp);
26954:     cx->tracefp = file;
27233:     cx->tracePrevPc = NULL;
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
26954:     return JS_TRUE;
26954: 
26954:  bad_argument:
26954:     JSString *str = JS_ValueToString(cx, argv[0]);
23126:     if (!str)
23126:         return JS_FALSE;
23126:     JS_ReportError(cx, "tracing: illegal argument %s",
23126:                    JS_GetStringBytes(str));
23126:     return JS_FALSE;
23126: }
23126: 
23126: static void
23126: DumpScope(JSContext *cx, JSObject *obj, FILE *fp)
23126: {
38562:     uintN i = 0;
38562:     for (JSScopeProperty *sprop = NULL; JS_PropertyIterator(obj, &sprop);) {
38562:         fprintf(fp, "%3u %p ", i++, (void *) sprop);
52503:         ((Shape *) sprop)->dump(cx, fp);
23126:     }
23126: }
23126: 
23126: static JSBool
53557: DumpStats(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i;
23126:     JSString *str;
23126:     const char *bytes;
23126:     jsid id;
23126:     JSObject *obj2;
23126:     JSProperty *prop;
48470:     Value value;
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         argv[i] = STRING_TO_JSVAL(str);
23126:         bytes = JS_GetStringBytes(str);
23126:         if (strcmp(bytes, "arena") == 0) {
23126: #ifdef JS_ARENAMETER
23126:             JS_DumpArenaStats(stdout);
23126: #endif
23126:         } else if (strcmp(bytes, "atom") == 0) {
23126:             js_DumpAtoms(cx, gOutFile);
23126:         } else if (strcmp(bytes, "global") == 0) {
23126:             DumpScope(cx, cx->globalObject, stdout);
23126:         } else {
23126:             if (!JS_ValueToId(cx, STRING_TO_JSVAL(str), &id))
23126:                 return JS_FALSE;
53557:             JSObject *obj;
23126:             if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
23126:                 return JS_FALSE;
23126:             if (prop) {
31501:                 obj2->dropProperty(cx, prop);
31501:                 if (!obj->getProperty(cx, id, &value))
23126:                     return JS_FALSE;
23126:             }
48470:             if (!prop || !value.isObjectOrNull()) {
23126:                 fprintf(gErrFile, "js: invalid stats argument %s\n",
23126:                         bytes);
23126:                 continue;
23126:             }
48470:             obj = value.toObjectOrNull();
23126:             if (obj)
23126:                 DumpScope(cx, obj, stdout);
23126:         }
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: DumpHeap(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     char *fileName;
23126:     jsval v;
23126:     void* startThing;
23126:     uint32 startTraceKind;
23126:     const char *badTraceArg;
23126:     void *thingToFind;
23126:     size_t maxDepth;
23126:     void *thingToIgnore;
23126:     FILE *dumpFile;
23126:     JSBool ok;
23126: 
23126:     fileName = NULL;
23126:     if (argc > 0) {
23126:         v = JS_ARGV(cx, vp)[0];
48470:         if (!JSVAL_IS_NULL(v)) {
23126:             JSString *str;
23126: 
23126:             str = JS_ValueToString(cx, v);
23126:             if (!str)
23126:                 return JS_FALSE;
23126:             JS_ARGV(cx, vp)[0] = STRING_TO_JSVAL(str);
23126:             fileName = JS_GetStringBytes(str);
23126:         }
23126:     }
23126: 
23126:     startThing = NULL;
23126:     startTraceKind = 0;
23126:     if (argc > 1) {
23126:         v = JS_ARGV(cx, vp)[1];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             startThing = JSVAL_TO_TRACEABLE(v);
23126:             startTraceKind = JSVAL_TRACE_KIND(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "start";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     thingToFind = NULL;
23126:     if (argc > 2) {
23126:         v = JS_ARGV(cx, vp)[2];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             thingToFind = JSVAL_TO_TRACEABLE(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "toFind";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     maxDepth = (size_t)-1;
23126:     if (argc > 3) {
23126:         v = JS_ARGV(cx, vp)[3];
48470:         if (!JSVAL_IS_NULL(v)) {
23126:             uint32 depth;
23126: 
23126:             if (!JS_ValueToECMAUint32(cx, v, &depth))
23126:                 return JS_FALSE;
23126:             maxDepth = depth;
23126:         }
23126:     }
23126: 
23126:     thingToIgnore = NULL;
23126:     if (argc > 4) {
23126:         v = JS_ARGV(cx, vp)[4];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             thingToIgnore = JSVAL_TO_TRACEABLE(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "toIgnore";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     if (!fileName) {
23126:         dumpFile = stdout;
23126:     } else {
23126:         dumpFile = fopen(fileName, "w");
23126:         if (!dumpFile) {
23126:             JS_ReportError(cx, "can't open %s: %s", fileName, strerror(errno));
23126:             return JS_FALSE;
23126:         }
23126:     }
23126: 
23126:     ok = JS_DumpHeap(cx, dumpFile, startThing, startTraceKind, thingToFind,
23126:                      maxDepth, thingToIgnore);
23126:     if (dumpFile != stdout)
23126:         fclose(dumpFile);
23126:     return ok;
23126: 
23126:   not_traceable_arg:
23126:     JS_ReportError(cx, "argument '%s' is not null or a heap-allocated thing",
23126:                    badTraceArg);
23126:     return JS_FALSE;
23126: }
23126: 
49117: JSBool
53557: DumpObject(JSContext *cx, uintN argc, jsval *vp)
49117: {
49117:     JSObject *arg0 = NULL;
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "o", &arg0))
49117:         return JS_FALSE;
49117: 
49117:     js_DumpObject(arg0);
49117: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
49117:     return JS_TRUE;
49117: }
49117: 
23126: #endif /* DEBUG */
23126: 
23126: #ifdef TEST_CVTARGS
23126: #include <ctype.h>
23126: 
23126: static const char *
23126: EscapeWideString(jschar *w)
23126: {
23126:     static char enuf[80];
23126:     static char hex[] = "0123456789abcdef";
23126:     jschar u;
23126:     unsigned char b, c;
23126:     int i, j;
23126: 
23126:     if (!w)
23126:         return "";
23126:     for (i = j = 0; i < sizeof enuf - 1; i++, j++) {
23126:         u = w[j];
23126:         if (u == 0)
23126:             break;
23126:         b = (unsigned char)(u >> 8);
23126:         c = (unsigned char)(u);
23126:         if (b) {
23126:             if (i >= sizeof enuf - 6)
23126:                 break;
23126:             enuf[i++] = '\\';
23126:             enuf[i++] = 'u';
23126:             enuf[i++] = hex[b >> 4];
23126:             enuf[i++] = hex[b & 15];
23126:             enuf[i++] = hex[c >> 4];
23126:             enuf[i] = hex[c & 15];
23126:         } else if (!isprint(c)) {
23126:             if (i >= sizeof enuf - 4)
23126:                 break;
23126:             enuf[i++] = '\\';
23126:             enuf[i++] = 'x';
23126:             enuf[i++] = hex[c >> 4];
23126:             enuf[i] = hex[c & 15];
23126:         } else {
23126:             enuf[i] = (char)c;
23126:         }
23126:     }
23126:     enuf[i] = 0;
23126:     return enuf;
23126: }
23126: 
23126: #include <stdarg.h>
23126: 
23126: static JSBool
23126: ZZ_formatter(JSContext *cx, const char *format, JSBool fromJS, jsval **vpp,
23126:              va_list *app)
23126: {
23126:     jsval *vp;
23126:     va_list ap;
23126:     jsdouble re, im;
23126: 
23126:     printf("entering ZZ_formatter");
23126:     vp = *vpp;
23126:     ap = *app;
23126:     if (fromJS) {
23126:         if (!JS_ValueToNumber(cx, vp[0], &re))
23126:             return JS_FALSE;
23126:         if (!JS_ValueToNumber(cx, vp[1], &im))
23126:             return JS_FALSE;
23126:         *va_arg(ap, jsdouble *) = re;
23126:         *va_arg(ap, jsdouble *) = im;
23126:     } else {
23126:         re = va_arg(ap, jsdouble);
23126:         im = va_arg(ap, jsdouble);
23126:         if (!JS_NewNumberValue(cx, re, &vp[0]))
23126:             return JS_FALSE;
23126:         if (!JS_NewNumberValue(cx, im, &vp[1]))
23126:             return JS_FALSE;
23126:     }
23126:     *vpp = vp + 2;
23126:     *app = ap;
23126:     printf("leaving ZZ_formatter");
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: ConvertArgs(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSBool b = JS_FALSE;
23126:     jschar c = 0;
23126:     int32 i = 0, j = 0;
23126:     uint32 u = 0;
23126:     jsdouble d = 0, I = 0, re = 0, im = 0;
23126:     char *s = NULL;
23126:     JSString *str = NULL;
23126:     jschar *w = NULL;
23126:     JSObject *obj2 = NULL;
23126:     JSFunction *fun = NULL;
23126:     jsval v = JSVAL_VOID;
23126:     JSBool ok;
23126: 
23126:     if (!JS_AddArgumentFormatter(cx, "ZZ", ZZ_formatter))
31366:         return JS_FALSE;
53557:     ok = JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "b/ciujdIsSWofvZZ*",
23126:                              &b, &c, &i, &u, &j, &d, &I, &s, &str, &w, &obj2,
23126:                              &fun, &v, &re, &im);
23126:     JS_RemoveArgumentFormatter(cx, "ZZ");
23126:     if (!ok)
23126:         return JS_FALSE;
23126:     fprintf(gOutFile,
23126:             "b %u, c %x (%c), i %ld, u %lu, j %ld\n",
23126:             b, c, (char)c, i, u, j);
31366:     ToString obj2string(cx, obj2);
31366:     ToString valueString(cx, v);
31366:     JSString *tmpstr = JS_DecompileFunction(cx, fun, 4);
31366:     const char *func;
31366:     if (tmpstr) {
31366:         func = JS_GetStringBytes(tmpstr);
31366:     } else {
47498:         ReportException(cx);
31366:         func = "error decompiling fun";
31366:     }
23126:     fprintf(gOutFile,
23126:             "d %g, I %g, s %s, S %s, W %s, obj %s, fun %s\n"
23126:             "v %s, re %g, im %g\n",
23126:             d, I, s, str ? JS_GetStringBytes(str) : "", EscapeWideString(w),
31366:             obj2string.getBytes(),
31366:             fun ? func : "",
31366:             valueString.getBytes(), re, im);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: #endif
23126: 
23126: static JSBool
23126: BuildDate(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     char version[20] = "\n";
23126: #if JS_VERSION < 150
23126:     sprintf(version, " for version %d\n", JS_VERSION);
23126: #endif
23126:     fprintf(gOutFile, "built on %s at %s%s", __DATE__, __TIME__, version);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Clear(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     JSObject *obj;
53557:     if (argc != 0 && !JS_ValueToObject(cx, JS_ARGV(cx, vp)[0], &obj))
23126:         return JS_FALSE;
23126:     JS_ClearScope(cx, obj);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: Intern(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
23126: 
23126:     str = JS_ValueToString(cx, argc == 0 ? JSVAL_VOID : vp[2]);
23126:     if (!str)
23126:         return JS_FALSE;
23126:     if (!JS_InternUCStringN(cx, JS_GetStringChars(str),
23126:                                 JS_GetStringLength(str))) {
23126:         return JS_FALSE;
23126:     }
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
53557: Clone(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSObject *funobj, *parent, *clone;
23126: 
53557:     if (!argc)
53557:         return JS_FALSE;
53557: 
53557:     jsval *argv = JS_ARGV(cx, vp);
27012:     if (VALUE_IS_FUNCTION(cx, argv[0])) {
27012:         funobj = JSVAL_TO_OBJECT(argv[0]);
27012:     } else {
27012:         JSFunction *fun = JS_ValueToFunction(cx, argv[0]);
23126:         if (!fun)
23126:             return JS_FALSE;
23126:         funobj = JS_GetFunctionObject(fun);
27012:     }
23126:     if (argc > 1) {
23126:         if (!JS_ValueToObject(cx, argv[1], &parent))
23126:             return JS_FALSE;
23126:     } else {
23126:         parent = JS_GetParent(cx, funobj);
23126:     }
23126:     clone = JS_CloneFunctionObject(cx, funobj, parent);
23126:     if (!clone)
23126:         return JS_FALSE;
53557:     *vp = OBJECT_TO_JSVAL(clone);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: GetPDA(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSObject *vobj, *aobj, *pdobj;
23126:     JSBool ok;
23126:     JSPropertyDescArray pda;
23126:     JSPropertyDesc *pd;
23126:     uint32 i;
23126:     jsval v;
23126: 
23126:     if (!JS_ValueToObject(cx, argc == 0 ? JSVAL_VOID : vp[2], &vobj))
23126:         return JS_FALSE;
24303:     if (!vobj) {
24303:         *vp = JSVAL_VOID;
23126:         return JS_TRUE;
24303:     }
23126: 
23126:     aobj = JS_NewArrayObject(cx, 0, NULL);
23126:     if (!aobj)
23126:         return JS_FALSE;
23126:     *vp = OBJECT_TO_JSVAL(aobj);
23126: 
23126:     ok = JS_GetPropertyDescArray(cx, vobj, &pda);
23126:     if (!ok)
23126:         return JS_FALSE;
23126:     pd = pda.array;
24303:     for (i = 0; i < pda.length; i++, pd++) {
23126:         pdobj = JS_NewObject(cx, NULL, NULL, NULL);
23126:         if (!pdobj) {
23126:             ok = JS_FALSE;
23126:             break;
23126:         }
23126: 
23126:         /* Protect pdobj from GC by setting it as an element of aobj now */
23126:         v = OBJECT_TO_JSVAL(pdobj);
23126:         ok = JS_SetElement(cx, aobj, i, &v);
23126:         if (!ok)
23126:             break;
23126: 
23126:         ok = JS_SetProperty(cx, pdobj, "id", &pd->id) &&
23126:              JS_SetProperty(cx, pdobj, "value", &pd->value) &&
23126:              (v = INT_TO_JSVAL(pd->flags),
23126:               JS_SetProperty(cx, pdobj, "flags", &v)) &&
23126:              (v = INT_TO_JSVAL(pd->slot),
23126:               JS_SetProperty(cx, pdobj, "slot", &v)) &&
23126:              JS_SetProperty(cx, pdobj, "alias", &pd->alias);
23126:         if (!ok)
23126:             break;
23126:     }
23126:     JS_PutPropertyDescArray(cx, &pda);
23126:     return ok;
23126: }
23126: 
23126: static JSBool
23126: GetSLX(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126: 
23126:     script = ValueToScript(cx, argc == 0 ? JSVAL_VOID : vp[2]);
23126:     if (!script)
23126:         return JS_FALSE;
23126:     *vp = INT_TO_JSVAL(js_GetScriptLineExtent(script));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: ToInt32(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     int32 i;
23126: 
23126:     if (!JS_ValueToInt32(cx, argc == 0 ? JSVAL_VOID : vp[2], &i))
23126:         return JS_FALSE;
23126:     return JS_NewNumberValue(cx, i, vp);
23126: }
23126: 
23126: static JSBool
53557: StringsAreUTF8(JSContext *cx, uintN argc, jsval *vp)
23126: {
53557:     *vp = JS_CStringsAreUTF8() ? JSVAL_TRUE : JSVAL_FALSE;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: StackQuota(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uint32 n;
23126: 
23126:     if (argc == 0)
23126:         return JS_NewNumberValue(cx, (double) gScriptStackQuota, vp);
23126:     if (!JS_ValueToECMAUint32(cx, JS_ARGV(cx, vp)[0], &n))
23126:         return JS_FALSE;
23126:     gScriptStackQuota = n;
23126:     JS_SetScriptStackQuota(cx, gScriptStackQuota);
23126:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static const char* badUTF8 = "...\xC0...";
23126: static const char* bigUTF8 = "...\xFB\xBF\xBF\xBF\xBF...";
23126: static const jschar badSurrogate[] = { 'A', 'B', 'C', 0xDEEE, 'D', 'E', 0 };
23126: 
23126: static JSBool
53557: TestUTF8(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     int32 mode = 1;
23126:     jschar chars[20];
23126:     size_t charsLength = 5;
23126:     char bytes[20];
23126:     size_t bytesLength = 20;
53557:     if (argc && !JS_ValueToInt32(cx, *JS_ARGV(cx, vp), &mode))
23126:         return JS_FALSE;
23126: 
23126:     /* The following throw errors if compiled with UTF-8. */
23126:     switch (mode) {
23126:       /* mode 1: malformed UTF-8 string. */
23126:       case 1:
23126:         JS_NewStringCopyZ(cx, badUTF8);
23126:         break;
23126:       /* mode 2: big UTF-8 character. */
23126:       case 2:
23126:         JS_NewStringCopyZ(cx, bigUTF8);
23126:         break;
23126:       /* mode 3: bad surrogate character. */
23126:       case 3:
23126:         JS_EncodeCharacters(cx, badSurrogate, 6, bytes, &bytesLength);
23126:         break;
23126:       /* mode 4: use a too small buffer. */
23126:       case 4:
23126:         JS_DecodeBytes(cx, "1234567890", 10, chars, &charsLength);
23126:         break;
23126:       default:
23126:         JS_ReportError(cx, "invalid mode parameter");
23126:         return JS_FALSE;
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return !JS_IsExceptionPending (cx);
23126: }
23126: 
23126: static JSBool
53557: ThrowError(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JS_ReportError(cx, "This is an error");
23126:     return JS_FALSE;
23126: }
23126: 
23126: #define LAZY_STANDARD_CLASSES
23126: 
23126: /* A class for easily testing the inner/outer object callbacks. */
23126: typedef struct ComplexObject {
23126:     JSBool isInner;
23126:     JSBool frozen;
23126:     JSObject *inner;
23126:     JSObject *outer;
23126: } ComplexObject;
23126: 
23126: static JSObject *
23126: split_create_outer(JSContext *cx);
23126: 
23126: static JSObject *
23126: split_create_inner(JSContext *cx, JSObject *outer);
23126: 
23126: static ComplexObject *
23126: split_get_private(JSContext *cx, JSObject *obj);
23126: 
23126: static JSBool
48470: split_addProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
23126:         /* Make sure to define this property on the inner object. */
48470:         return JS_DefinePropertyById(cx, cpx->inner, id, *vp, NULL, NULL, JSPROP_ENUMERATE);
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: split_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
32785: 
48470:     if (JSID_IS_ATOM(id) &&
48470:         !strcmp(JS_GetStringBytes(JSID_TO_STRING(id)), "isInner")) {
32785:         *vp = BOOLEAN_TO_JSVAL(cpx->isInner);
32785:         return JS_TRUE;
32785:     }
32785: 
23126:     if (!cpx->isInner && cpx->inner) {
48470:         if (JSID_IS_ATOM(id)) {
23126:             JSString *str;
23126: 
48470:             str = JSID_TO_STRING(id);
23126:             return JS_GetUCProperty(cx, cpx->inner, JS_GetStringChars(str),
23126:                                     JS_GetStringLength(str), vp);
23126:         }
48470:         if (JSID_IS_INT(id))
48470:             return JS_GetElement(cx, cpx->inner, JSID_TO_INT(id), vp);
23126:         return JS_TRUE;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: split_setProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
48470:         if (JSID_IS_ATOM(id)) {
23126:             JSString *str;
23126: 
48470:             str = JSID_TO_STRING(id);
23126:             return JS_SetUCProperty(cx, cpx->inner, JS_GetStringChars(str),
23126:                                     JS_GetStringLength(str), vp);
23126:         }
48470:         if (JSID_IS_INT(id))
48470:             return JS_SetElement(cx, cpx->inner, JSID_TO_INT(id), vp);
23126:         return JS_TRUE;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: split_delProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126:     ComplexObject *cpx;
23126:     jsid asId;
23126: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
23126:         /* Make sure to define this property on the inner object. */
23126:         if (!JS_ValueToId(cx, *vp, &asId))
23126:             return JS_FALSE;
54169:         return cpx->inner->deleteProperty(cx, asId, Valueify(vp), true);
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: split_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
23126:                 jsval *statep, jsid *idp)
23126: {
23126:     ComplexObject *cpx;
23126:     JSObject *iterator;
23126: 
23126:     switch (enum_op) {
23126:       case JSENUMERATE_INIT:
47569:       case JSENUMERATE_INIT_ALL:
23126:         cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126: 
23126:         if (!cpx->isInner && cpx->inner)
23126:             obj = cpx->inner;
23126: 
23126:         iterator = JS_NewPropertyIterator(cx, obj);
23126:         if (!iterator)
23126:             return JS_FALSE;
23126: 
23126:         *statep = OBJECT_TO_JSVAL(iterator);
23126:         if (idp)
48470:             *idp = INT_TO_JSID(0);
23126:         break;
23126: 
23126:       case JSENUMERATE_NEXT:
23126:         iterator = (JSObject*)JSVAL_TO_OBJECT(*statep);
23126:         if (!JS_NextProperty(cx, iterator, idp))
23126:             return JS_FALSE;
23126: 
48470:         if (!JSID_IS_VOID(*idp))
23126:             break;
23126:         /* Fall through. */
23126: 
23126:       case JSENUMERATE_DESTROY:
23126:         /* Let GC at our iterator object. */
23126:         *statep = JSVAL_NULL;
23126:         break;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
51110: ResolveClass(JSContext *cx, JSObject *obj, jsid id, JSBool *resolved)
51110: {
51110:     if (!JS_ResolveStandardClass(cx, obj, id, resolved))
51110:         return JS_FALSE;
51110: 
51110:     if (!*resolved) {
51110:         if (JSID_IS_ATOM(id, CLASS_ATOM(cx, Reflect))) {
51110:             if (!js_InitReflectClass(cx, obj))
51110:                 return JS_FALSE;
51110:             *resolved = JS_TRUE;
51110:         }
51110:     }
51110: 
51110:     return JS_TRUE;
51110: }
51110: 
51110: static JSBool
48470: split_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp)
23126: {
23126:     ComplexObject *cpx;
23126: 
48470:     if (JSID_IS_ATOM(id) &&
48470:         !strcmp(JS_GetStringBytes(JSID_TO_STRING(id)), "isInner")) {
32785:         *objp = obj;
32785:         return JS_DefineProperty(cx, obj, "isInner", JSVAL_VOID, NULL, NULL,
32785:                                  JSPROP_SHARED);
32785:     }
32785: 
23126:     cpx = split_get_private(cx, obj);
23126:     if (!cpx)
23126:         return JS_TRUE;
23126:     if (!cpx->isInner && cpx->inner) {
23126:         JSProperty *prop;
23126: 
48470:         if (!cpx->inner->lookupProperty(cx, id, objp, &prop))
23126:             return JS_FALSE;
23126:         if (prop)
31501:             cpx->inner->dropProperty(cx, prop);
23126: 
23126:         return JS_TRUE;
23126:     }
23126: 
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     if (!(flags & JSRESOLVE_ASSIGNING)) {
23126:         JSBool resolved;
23126: 
51110:         if (!ResolveClass(cx, obj, id, &resolved))
23126:             return JS_FALSE;
23126: 
23126:         if (resolved) {
23126:             *objp = obj;
23126:             return JS_TRUE;
23126:         }
23126:     }
23126: #endif
23126: 
23126:     /* XXX For additional realism, let's resolve some random property here. */
23126:     return JS_TRUE;
23126: }
23126: 
23126: static void
23126: split_finalize(JSContext *cx, JSObject *obj)
23126: {
23126:     JS_free(cx, JS_GetPrivate(cx, obj));
23126: }
23126: 
23126: static uint32
23126: split_mark(JSContext *cx, JSObject *obj, void *arg)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126: 
23126:     if (!cpx->isInner && cpx->inner) {
23126:         /* Mark the inner object. */
48470:         JS_MarkGCThing(cx, OBJECT_TO_JSVAL(cpx->inner), "ComplexObject.inner", arg);
23126:     }
23126: 
23126:     return 0;
23126: }
23126: 
23126: static JSObject *
23126: split_outerObject(JSContext *cx, JSObject *obj)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126:     return cpx->isInner ? cpx->outer : obj;
23126: }
23126: 
32785: static JSObject *
42679: split_thisObject(JSContext *cx, JSObject *obj)
32785: {
32785:     OBJ_TO_OUTER_OBJECT(cx, obj);
32785:     if (!obj)
32785:         return NULL;
32785:     return obj;
32785: }
32785: 
32785: 
23126: static JSBool
48470: split_equality(JSContext *cx, JSObject *obj, const jsval *v, JSBool *bp);
23126: 
23126: static JSObject *
23126: split_innerObject(JSContext *cx, JSObject *obj)
23126: {
23126:     ComplexObject *cpx;
23126: 
23126:     cpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126:     if (cpx->frozen) {
23126:         JS_ASSERT(!cpx->isInner);
23126:         return obj;
23126:     }
23126:     return !cpx->isInner ? cpx->inner : obj;
23126: }
23126: 
48622: static Class split_global_class = {
48622:     "split_global",
48622:     JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_HAS_PRIVATE | JSCLASS_GLOBAL_FLAGS,
48622:     Valueify(split_addProperty),
48622:     Valueify(split_delProperty),
48622:     Valueify(split_getProperty),
48622:     Valueify(split_setProperty),
23126:     (JSEnumerateOp)split_enumerate,
23126:     (JSResolveOp)split_resolve,
48622:     ConvertStub,
48622:     split_finalize,
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
48622:     split_mark,
48622:     {
48622:         Valueify(split_equality),
48622:         split_outerObject,
48622:         split_innerObject,
48622:         NULL, /* iteratorObject */
48622:         NULL, /* wrappedObject  */
48622:     },
48622:     {
48622:         NULL, /* lookupProperty */
48622:         NULL, /* defineProperty */
48622:         NULL, /* getProperty    */
48622:         NULL, /* setProperty    */
48622:         NULL, /* getAttributes  */
48622:         NULL, /* setAttributes  */
48622:         NULL, /* deleteProperty */
48622:         NULL, /* enumerate      */
48622:         NULL, /* typeOf         */
48622:         NULL, /* trace          */
54563:         NULL, /* fix            */
48622:         split_thisObject,
48622:         NULL, /* clear          */
48622:     },
23126: };
23126: 
23126: static JSBool
48470: split_equality(JSContext *cx, JSObject *obj, const jsval *v, JSBool *bp)
23126: {
23126:     *bp = JS_FALSE;
48470:     if (JSVAL_IS_PRIMITIVE(*v))
23126:         return JS_TRUE;
23126: 
48470:     JSObject *obj2 = JSVAL_TO_OBJECT(*v);
48622:     if (obj2->getClass() != &split_global_class)
23126:         return JS_TRUE;
23126: 
23126:     ComplexObject *cpx = (ComplexObject *) JS_GetPrivate(cx, obj2);
23126:     JS_ASSERT(!cpx->isInner);
23126: 
23126:     ComplexObject *ourCpx = (ComplexObject *) JS_GetPrivate(cx, obj);
23126:     JS_ASSERT(!ourCpx->isInner);
23126: 
23126:     *bp = (cpx == ourCpx);
23126:     return JS_TRUE;
23126: }
23126: 
23126: JSObject *
23126: split_create_outer(JSContext *cx)
23126: {
23126:     ComplexObject *cpx;
23126:     JSObject *obj;
23126: 
23126:     cpx = (ComplexObject *) JS_malloc(cx, sizeof *obj);
23126:     if (!cpx)
23126:         return NULL;
23126:     cpx->isInner = JS_FALSE;
23126:     cpx->frozen = JS_TRUE;
23126:     cpx->inner = NULL;
23126:     cpx->outer = NULL;
23126: 
48622:     obj = JS_NewGlobalObject(cx, Jsvalify(&split_global_class));
50472:     if (!obj) {
23126:         JS_free(cx, cpx);
23126:         return NULL;
23126:     }
23126: 
23126:     if (!JS_SetPrivate(cx, obj, cpx)) {
23126:         JS_free(cx, cpx);
23126:         return NULL;
23126:     }
23126: 
23126:     return obj;
23126: }
23126: 
23126: static JSObject *
23126: split_create_inner(JSContext *cx, JSObject *outer)
23126: {
23126:     ComplexObject *cpx, *outercpx;
23126:     JSObject *obj;
23126: 
48622:     JS_ASSERT(outer->getClass() == &split_global_class);
23126: 
23126:     cpx = (ComplexObject *) JS_malloc(cx, sizeof *cpx);
23126:     if (!cpx)
23126:         return NULL;
23126:     cpx->isInner = JS_TRUE;
23126:     cpx->frozen = JS_FALSE;
23126:     cpx->inner = NULL;
23126:     cpx->outer = outer;
23126: 
48622:     obj = JS_NewGlobalObject(cx, Jsvalify(&split_global_class));
50486:     if (!obj || !JS_SetPrivate(cx, obj, cpx)) {
23126:         JS_free(cx, cpx);
23126:         return NULL;
23126:     }
23126: 
23126:     outercpx = (ComplexObject *) JS_GetPrivate(cx, outer);
23126:     outercpx->inner = obj;
23126:     outercpx->frozen = JS_FALSE;
23126: 
23126:     return obj;
23126: }
23126: 
23126: static ComplexObject *
23126: split_get_private(JSContext *cx, JSObject *obj)
23126: {
23126:     do {
48622:         if (obj->getClass() == &split_global_class)
23126:             return (ComplexObject *) JS_GetPrivate(cx, obj);
23126:         obj = JS_GetParent(cx, obj);
23126:     } while (obj);
23126: 
23126:     return NULL;
23126: }
23126: 
23126: static JSBool
23126: sandbox_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126:     jsval v;
23126:     JSBool b;
23126: 
30581:     if (!JS_GetProperty(cx, obj, "lazy", &v))
23126:         return JS_FALSE;
30581: 
30581:     JS_ValueToBoolean(cx, v, &b);
23126:     return !b || JS_EnumerateStandardClasses(cx, obj);
23126: }
23126: 
23126: static JSBool
48470: sandbox_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:                 JSObject **objp)
23126: {
23126:     jsval v;
23126:     JSBool b, resolved;
23126: 
30581:     if (!JS_GetProperty(cx, obj, "lazy", &v))
23126:         return JS_FALSE;
30581: 
30581:     JS_ValueToBoolean(cx, v, &b);
23126:     if (b && (flags & JSRESOLVE_ASSIGNING) == 0) {
51110:         if (!ResolveClass(cx, obj, id, &resolved))
23126:             return JS_FALSE;
23126:         if (resolved) {
23126:             *objp = obj;
23126:             return JS_TRUE;
23126:         }
23126:     }
23126:     *objp = NULL;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSClass sandbox_class = {
23126:     "sandbox",
38533:     JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS,
23126:     JS_PropertyStub,   JS_PropertyStub,
23126:     JS_PropertyStub,   JS_PropertyStub,
23126:     sandbox_enumerate, (JSResolveOp)sandbox_resolve,
30654:     JS_ConvertStub,    NULL,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
47498: static JSObject *
47498: NewSandbox(JSContext *cx, bool lazy, bool split)
47498: {
47516:     JSObject *obj = JS_NewCompartmentAndGlobalObject(cx, &sandbox_class, NULL);
47498:     if (!obj)
47498:         return NULL;
47498: 
47504:     {
54733:         JSAutoEnterCompartment ac;
47517:         if (!ac.enter(cx, obj))
47498:             return NULL;
47498: 
47498:         if (split) {
47498:             obj = split_setup(cx, JS_TRUE);
47504:             if (!obj)
47504:                 return NULL;
47504:         }
47504:         if (!lazy && !JS_InitStandardClasses(cx, obj))
47504:             return NULL;
47498: 
48470:         AutoValueRooter root(cx, BooleanValue(lazy));
48470:         if (!JS_SetProperty(cx, obj, "lazy", root.jsval_addr()))
47504:             return NULL;
47504: 
47504:         if (split)
47498:             obj = split_outerObject(cx, obj);
47504:     }
47498: 
47498:     AutoObjectRooter objroot(cx, obj);
47498:     if (!cx->compartment->wrap(cx, objroot.addr()))
47498:         return NULL;
47498:     return objroot.object();
47498: }
47498: 
23126: static JSBool
53557: EvalInContext(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSString *str;
47498:     JSObject *sobj = NULL;
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "S / o", &str, &sobj))
47498:         return false;
47498: 
47498:     const jschar *src = JS_GetStringChars(str);
47498:     size_t srclen = JS_GetStringLength(str);
47498:     bool split = false, lazy = false;
35108:     if (srclen == 4) {
35108:         if (src[0] == 'l' && src[1] == 'a' && src[2] == 'z' && src[3] == 'y') {
47498:             lazy = true;
23126:             srclen = 0;
23126:         }
35108:     } else if (srclen == 5) {
35108:         if (src[0] == 's' && src[1] == 'p' && src[2] == 'l' && src[3] == 'i' && src[4] == 't') {
47498:             split = lazy = true;
35108:             srclen = 0;
35108:         }
35108:     }
23126: 
23126:     if (!sobj) {
47498:         sobj = NewSandbox(cx, lazy, split);
47498:         if (!sobj)
47498:             return false;
47498:     }
47498: 
53557:     *vp = OBJECT_TO_JSVAL(sobj);
47498:     if (srclen == 0)
47498:         return true;
47498: 
47498:     JSStackFrame *fp = JS_GetScriptedCaller(cx, NULL);
47522:     {
54733:         JSAutoEnterCompartment ac;
47574:         if (JSCrossCompartmentWrapper::isCrossCompartmentWrapper(sobj)) {
47498:             sobj = sobj->unwrap();
47517:             if (!ac.enter(cx, sobj))
47498:                 return false;
47498:         }
47498: 
47498:         OBJ_TO_INNER_OBJECT(cx, sobj);
47517:         if (!sobj)
47517:             return false;
47517:         if (!(sobj->getClass()->flags & JSCLASS_IS_GLOBAL)) {
42742:             JS_ReportError(cx, "Invalid scope argument to evalcx");
47517:             return false;
47517:         }
47517:         if (!JS_EvaluateUCScript(cx, sobj, src, srclen,
53840:                                  fp->script()->filename,
53840:                                  JS_PCToLineNumber(cx, fp->script(), fp->pc(cx)),
53557:                                  vp)) {
47517:             return false;
47517:         }
47522:     }
53557:     return cx->compartment->wrap(cx, Valueify(vp));
23126: }
23126: 
23126: static JSBool
40276: EvalInFrame(JSContext *cx, uintN argc, jsval *vp)
40276: {
40276:     jsval *argv = JS_ARGV(cx, vp);
40276:     if (argc < 2 ||
40276:         !JSVAL_IS_INT(argv[0]) ||
40276:         !JSVAL_IS_STRING(argv[1])) {
40276:         JS_ReportError(cx, "Invalid arguments to evalInFrame");
40276:         return JS_FALSE;
40276:     }
40276: 
40276:     uint32 upCount = JSVAL_TO_INT(argv[0]);
40276:     JSString *str = JSVAL_TO_STRING(argv[1]);
40276: 
40279:     bool saveCurrent = (argc >= 3 && JSVAL_IS_BOOLEAN(argv[2]))
48470:                         ? !!(JSVAL_TO_BOOLEAN(argv[2]))
40276:                         : false;
40276: 
51446:     JS_ASSERT(cx->hasfp());
40276: 
42717:     FrameRegsIter fi(cx);
42717:     for (uint32 i = 0; i < upCount; ++i, ++fi) {
53840:         if (!fi.fp()->prev())
40276:             break;
42717:     }
42717: 
42717:     JSStackFrame *const fp = fi.fp();
53840:     if (!JS_IsScriptFrame(cx, fp)) {
40276:         JS_ReportError(cx, "cannot eval in non-script frame");
40276:         return JS_FALSE;
40276:     }
40276: 
40278:     JSStackFrame *oldfp = NULL;
40276:     if (saveCurrent)
40276:         oldfp = JS_SaveFrameChain(cx);
40276: 
40276:     JSBool ok = JS_EvaluateUCInStackFrame(cx, fp, str->chars(), str->length(),
53840:                                           fp->script()->filename,
53840:                                           JS_PCToLineNumber(cx, fp->script(),
42717:                                                             fi.pc()),
40276:                                           vp);
40276: 
40276:     if (saveCurrent)
40276:         JS_RestoreFrameChain(cx, oldfp);
40276: 
40276:     return ok;
40276: }
40276: 
40276: static JSBool
23126: ShapeOf(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     jsval v = JS_ARGV(cx, vp)[0];
23126:     if (!JSVAL_IS_OBJECT(v)) {
23126:         JS_ReportError(cx, "shapeOf: object expected");
23126:         return JS_FALSE;
23126:     }
27165:     JSObject *obj = JSVAL_TO_OBJECT(v);
27165:     if (!obj) {
27165:         *vp = JSVAL_ZERO;
27165:         return JS_TRUE;
27165:     }
40430:     if (!obj->isNative()) {
27165:         *vp = INT_TO_JSVAL(-1);
27165:         return JS_TRUE;
27165:     }
40847:     return JS_NewNumberValue(cx, obj->shape(), vp);
23126: }
23126: 
23126: #ifdef JS_THREADSAFE
23126: 
25472: /*
25472:  * Check that t1 comes strictly before t2. The function correctly deals with
25472:  * PRIntervalTime wrap-around between t2 and t1 assuming that t2 and t1 stays
25472:  * within INT32_MAX from each other. We use MAX_TIMEOUT_INTERVAL to enforce
25472:  * this restriction.
25472:  */
25472: static bool
25472: IsBefore(PRIntervalTime t1, PRIntervalTime t2)
25472: {
25472:     return int32(t1 - t2) < 0;
25472: }
25472: 
23126: static JSBool
23126: Sleep_fn(JSContext *cx, uintN argc, jsval *vp)
23126: {
25472:     PRIntervalTime t_ticks;
25472: 
25472:     if (argc == 0) {
25472:         t_ticks = 0;
25472:     } else {
23126:         jsdouble t_secs;
23126: 
23126:         if (!JS_ValueToNumber(cx, argc == 0 ? JSVAL_VOID : vp[2], &t_secs))
23126:             return JS_FALSE;
23126: 
25472:         /* NB: The next condition also filter out NaNs. */
25472:         if (!(t_secs <= MAX_TIMEOUT_INTERVAL)) {
25472:             JS_ReportError(cx, "Excessive sleep interval");
25472:             return JS_FALSE;
25472:         }
25472:         t_ticks = (t_secs <= 0.0)
25472:                   ? 0
25472:                   : PRIntervalTime(PR_TicksPerSecond() * t_secs);
25472:     }
25472:     if (t_ticks == 0) {
25472:         JS_YieldRequest(cx);
25472:     } else {
40289:         JSAutoSuspendRequest suspended(cx);
25472:         PR_Lock(gWatchdogLock);
25472:         PRIntervalTime to_wakeup = PR_IntervalNow() + t_ticks;
25472:         for (;;) {
25472:             PR_WaitCondVar(gSleepWakeup, t_ticks);
25472:             if (gCanceled)
25472:                 break;
25472:             PRIntervalTime now = PR_IntervalNow();
25472:             if (!IsBefore(now, to_wakeup))
25472:                 break;
25472:             t_ticks = to_wakeup - now;
25472:         }
25472:         PR_Unlock(gWatchdogLock);
25472:     }
25472:     return !gCanceled;
23126: }
23126: 
23126: typedef struct ScatterThreadData ScatterThreadData;
23126: typedef struct ScatterData ScatterData;
23126: 
23126: typedef enum ScatterStatus {
23126:     SCATTER_WAIT,
23126:     SCATTER_GO,
23126:     SCATTER_CANCEL
23126: } ScatterStatus;
23126: 
23126: struct ScatterData {
23126:     ScatterThreadData   *threads;
23126:     jsval               *results;
23126:     PRLock              *lock;
23126:     PRCondVar           *cvar;
23126:     ScatterStatus       status;
23126: };
23126: 
23126: struct ScatterThreadData {
23126:     jsint               index;
23126:     ScatterData         *shared;
23126:     PRThread            *thr;
23126:     JSContext           *cx;
23126:     jsval               fn;
23126: };
23126: 
23126: static void
23126: DoScatteredWork(JSContext *cx, ScatterThreadData *td)
23126: {
23126:     jsval *rval = &td->shared->results[td->index];
23126: 
25087:     if (!JS_CallFunctionValue(cx, NULL, td->fn, 0, NULL, rval)) {
23126:         *rval = JSVAL_VOID;
23126:         JS_GetPendingException(cx, rval);
23126:         JS_ClearPendingException(cx);
23126:     }
23126: }
23126: 
23126: static void
23126: RunScatterThread(void *arg)
23126: {
26673:     int stackDummy;
23126:     ScatterThreadData *td;
23126:     ScatterStatus st;
23126:     JSContext *cx;
23126: 
26673:     if (PR_FAILURE == PR_SetThreadPrivate(gStackBaseThreadIndex, &stackDummy))
26673:         return;
26673: 
23126:     td = (ScatterThreadData *)arg;
23126:     cx = td->cx;
23126: 
25087:     /* Wait for our signal. */
23126:     PR_Lock(td->shared->lock);
23126:     while ((st = td->shared->status) == SCATTER_WAIT)
23126:         PR_WaitCondVar(td->shared->cvar, PR_INTERVAL_NO_TIMEOUT);
23126:     PR_Unlock(td->shared->lock);
23126: 
23126:     if (st == SCATTER_CANCEL)
23126:         return;
23126: 
25087:     /* We are good to go. */
23126:     JS_SetContextThread(cx);
42740:     JS_SetNativeStackQuota(cx, gMaxStackSize);
23126:     JS_BeginRequest(cx);
23126:     DoScatteredWork(cx, td);
23126:     JS_EndRequest(cx);
23126:     JS_ClearContextThread(cx);
23126: }
23126: 
23126: /*
23126:  * scatter(fnArray) - Call each function in `fnArray` without arguments, each
23126:  * in a different thread. When all threads have finished, return an array: the
23126:  * return values. Errors are not propagated; if any of the function calls
23126:  * fails, the corresponding element in the results array gets the exception
23126:  * object, if any, else (undefined).
23126:  */
23126: static JSBool
23126: Scatter(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     jsuint i;
23126:     jsuint n;  /* number of threads */
23126:     JSObject *inArr;
23126:     JSObject *arr;
40289:     JSObject *global;
23126:     ScatterData sd;
23126:     JSBool ok;
23126: 
23126:     sd.lock = NULL;
23126:     sd.cvar = NULL;
23126:     sd.results = NULL;
23126:     sd.threads = NULL;
23126:     sd.status = SCATTER_WAIT;
23126: 
23126:     if (argc == 0 || JSVAL_IS_PRIMITIVE(JS_ARGV(cx, vp)[0])) {
23126:         JS_ReportError(cx, "the first argument must be an object");
23126:         goto fail;
23126:     }
23126: 
23126:     inArr = JSVAL_TO_OBJECT(JS_ARGV(cx, vp)[0]);
23126:     ok = JS_GetArrayLength(cx, inArr, &n);
23126:     if (!ok)
23126:         goto out;
23126:     if (n == 0)
23126:         goto success;
23126: 
23126:     sd.lock = PR_NewLock();
23126:     if (!sd.lock)
23126:         goto fail;
23126: 
23126:     sd.cvar = PR_NewCondVar(sd.lock);
23126:     if (!sd.cvar)
23126:         goto fail;
23126: 
23126:     sd.results = (jsval *) malloc(n * sizeof(jsval));
23126:     if (!sd.results)
23126:         goto fail;
23126:     for (i = 0; i < n; i++) {
23126:         sd.results[i] = JSVAL_VOID;
47403:         ok = JS_AddValueRoot(cx, &sd.results[i]);
23126:         if (!ok) {
23126:             while (i-- > 0)
47403:                 JS_RemoveValueRoot(cx, &sd.results[i]);
23126:             free(sd.results);
23126:             sd.results = NULL;
23126:             goto fail;
23126:         }
23126:     }
23126: 
23126:     sd.threads = (ScatterThreadData *) malloc(n * sizeof(ScatterThreadData));
23126:     if (!sd.threads)
23126:         goto fail;
23126:     for (i = 0; i < n; i++) {
23126:         sd.threads[i].index = i;
23126:         sd.threads[i].shared = &sd;
23126:         sd.threads[i].thr = NULL;
23126:         sd.threads[i].cx = NULL;
23126:         sd.threads[i].fn = JSVAL_NULL;
23126: 
47403:         ok = JS_AddValueRoot(cx, &sd.threads[i].fn);
23126:         if (ok && !JS_GetElement(cx, inArr, (jsint) i, &sd.threads[i].fn)) {
47403:             JS_RemoveValueRoot(cx, &sd.threads[i].fn);
23126:             ok = JS_FALSE;
23126:         }
23126:         if (!ok) {
23126:             while (i-- > 0)
47403:                 JS_RemoveValueRoot(cx, &sd.threads[i].fn);
23126:             free(sd.threads);
23126:             sd.threads = NULL;
23126:             goto fail;
23126:         }
23126:     }
23126: 
40289:     global = JS_GetGlobalObject(cx);
23126:     for (i = 1; i < n; i++) {
40801:         JSContext *newcx = NewContext(JS_GetRuntime(cx));
23126:         if (!newcx)
23126:             goto fail;
40289: 
40289:         {
48481:             JSAutoRequest req(newcx);
40289:             JS_SetGlobalObject(newcx, global);
40289:         }
23126:         JS_ClearContextThread(newcx);
23126:         sd.threads[i].cx = newcx;
23126:     }
23126: 
23126:     for (i = 1; i < n; i++) {
23126:         PRThread *t = PR_CreateThread(PR_USER_THREAD,
23126:                                       RunScatterThread,
23126:                                       &sd.threads[i],
23126:                                       PR_PRIORITY_NORMAL,
23126:                                       PR_GLOBAL_THREAD,
23126:                                       PR_JOINABLE_THREAD,
23126:                                       0);
23126:         if (!t) {
23126:             /* Failed to start thread. */
23126:             PR_Lock(sd.lock);
23126:             sd.status = SCATTER_CANCEL;
23126:             PR_NotifyAllCondVar(sd.cvar);
23126:             PR_Unlock(sd.lock);
23126:             while (i-- > 1)
23126:                 PR_JoinThread(sd.threads[i].thr);
23126:             goto fail;
23126:         }
23126: 
23126:         sd.threads[i].thr = t;
23126:     }
23126:     PR_Lock(sd.lock);
23126:     sd.status = SCATTER_GO;
23126:     PR_NotifyAllCondVar(sd.cvar);
23126:     PR_Unlock(sd.lock);
23126: 
23126:     DoScatteredWork(cx, &sd.threads[0]);
23126: 
40289:     {
40289:         JSAutoSuspendRequest suspended(cx);
23126:         for (i = 1; i < n; i++) {
23126:             PR_JoinThread(sd.threads[i].thr);
23126:         }
40289:     }
23126: 
23126: success:
23126:     arr = JS_NewArrayObject(cx, n, sd.results);
23126:     if (!arr)
23126:         goto fail;
23126:     *vp = OBJECT_TO_JSVAL(arr);
23126:     ok = JS_TRUE;
23126: 
23126: out:
23126:     if (sd.threads) {
23126:         JSContext *acx;
23126: 
23126:         for (i = 0; i < n; i++) {
47403:             JS_RemoveValueRoot(cx, &sd.threads[i].fn);
23126:             acx = sd.threads[i].cx;
23126:             if (acx) {
23126:                 JS_SetContextThread(acx);
40801:                 DestroyContext(acx, true);
23126:             }
23126:         }
23126:         free(sd.threads);
23126:     }
23126:     if (sd.results) {
23126:         for (i = 0; i < n; i++)
47403:             JS_RemoveValueRoot(cx, &sd.results[i]);
23126:         free(sd.results);
23126:     }
23126:     if (sd.cvar)
23126:         PR_DestroyCondVar(sd.cvar);
23126:     if (sd.lock)
23126:         PR_DestroyLock(sd.lock);
23126: 
23126:     return ok;
23126: 
23126: fail:
23126:     ok = JS_FALSE;
23126:     goto out;
23126: }
23726: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt)
25472: {
25472:     JS_ASSERT(!gWatchdogThread);
25472:     gWatchdogLock = PR_NewLock();
25472:     if (gWatchdogLock) {
25472:         gWatchdogWakeup = PR_NewCondVar(gWatchdogLock);
25472:         if (gWatchdogWakeup) {
25472:             gSleepWakeup = PR_NewCondVar(gWatchdogLock);
25472:             if (gSleepWakeup)
25472:                 return true;
25472:             PR_DestroyCondVar(gWatchdogWakeup);
25472:         }
25472:         PR_DestroyLock(gWatchdogLock);
25472:     }
25472:     return false;
25472: }
25472: 
25472: static void
25472: KillWatchdog()
25472: {
25472:     PRThread *thread;
25472: 
25472:     PR_Lock(gWatchdogLock);
25472:     thread = gWatchdogThread;
25472:     if (thread) {
25472:         /*
25472:          * The watchdog thread is running, tell it to terminate waking it up
25472:          * if necessary.
25472:          */
25472:         gWatchdogThread = NULL;
25472:         PR_NotifyCondVar(gWatchdogWakeup);
25472:     }
25472:     PR_Unlock(gWatchdogLock);
25472:     if (thread)
25472:         PR_JoinThread(thread);
25472:     PR_DestroyCondVar(gSleepWakeup);
25472:     PR_DestroyCondVar(gWatchdogWakeup);
25472:     PR_DestroyLock(gWatchdogLock);
25472: }
25472: 
23726: static void
23726: WatchdogMain(void *arg)
23726: {
23726:     JSRuntime *rt = (JSRuntime *) arg;
23726: 
25472:     PR_Lock(gWatchdogLock);
23726:     while (gWatchdogThread) {
25472:         PRIntervalTime now = PR_IntervalNow();
25472:          if (gWatchdogHasTimeout && !IsBefore(now, gWatchdogTimeout)) {
25472:             /*
25472:              * The timeout has just expired. Trigger the operation callback
25472:              * outside the lock.
25472:              */
25472:             gWatchdogHasTimeout = false;
25472:             PR_Unlock(gWatchdogLock);
25472:             CancelExecution(rt);
25472:             PR_Lock(gWatchdogLock);
25472: 
25472:             /* Wake up any threads doing sleep. */
25472:             PR_NotifyAllCondVar(gSleepWakeup);
25472:         } else {
25472:             PRIntervalTime sleepDuration = gWatchdogHasTimeout
25472:                                            ? gWatchdogTimeout - now
25472:                                            : PR_INTERVAL_NO_TIMEOUT;
23726: #ifdef DEBUG
23726:             PRStatus status =
23726: #endif
25472:                 PR_WaitCondVar(gWatchdogWakeup, sleepDuration);
23726:             JS_ASSERT(status == PR_SUCCESS);
23726:         }
25472:     }
25472:     PR_Unlock(gWatchdogLock);
25472: }
25472: 
25472: static bool
25472: ScheduleWatchdog(JSRuntime *rt, jsdouble t)
23726: {
25472:     if (t <= 0) {
25472:         PR_Lock(gWatchdogLock);
25472:         gWatchdogHasTimeout = false;
25472:         PR_Unlock(gWatchdogLock);
25472:         return true;
25472:     }
25472: 
25472:     PRIntervalTime interval = PRIntervalTime(ceil(t * PR_TicksPerSecond()));
25472:     PRIntervalTime timeout = PR_IntervalNow() + interval;
25472:     PR_Lock(gWatchdogLock);
25472:     if (!gWatchdogThread) {
25472:         JS_ASSERT(!gWatchdogHasTimeout);
23726:         gWatchdogThread = PR_CreateThread(PR_USER_THREAD,
23726:                                           WatchdogMain,
25087:                                           rt,
23726:                                           PR_PRIORITY_NORMAL,
23726:                                           PR_LOCAL_THREAD,
25472:                                           PR_JOINABLE_THREAD,
23726:                                           0);
23726:         if (!gWatchdogThread) {
25472:             PR_Unlock(gWatchdogLock);
25472:             return false;
25472:         }
25472:     } else if (!gWatchdogHasTimeout || IsBefore(timeout, gWatchdogTimeout)) {
25087:          PR_NotifyCondVar(gWatchdogWakeup);
25472:     }
25472:     gWatchdogHasTimeout = true;
25472:     gWatchdogTimeout = timeout;
25472:     PR_Unlock(gWatchdogLock);
25472:     return true;
25472: }
25472: 
25472: #else /* !JS_THREADSAFE */
25087: 
25087: #ifdef XP_WIN
25087: static HANDLE gTimerHandle = 0;
25087: 
25472: VOID CALLBACK
25472: TimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
25087: {
25479:     CancelExecution((JSRuntime *) lpParameter);
25472: }
25472: 
25472: #else
25472: 
25472: static void
25472: AlarmHandler(int sig)
25472: {
25472:     CancelExecution(gRuntime);
25472: }
25472: 
25087: #endif
25087: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt)
25087: {
25472:     gRuntime = rt;
25472:     return true;
25472: }
25472: 
25472: static void
25472: KillWatchdog()
25472: {
25472:     ScheduleWatchdog(gRuntime, -1);
25472: }
25472: 
25472: static bool
25472: ScheduleWatchdog(JSRuntime *rt, jsdouble t)
25472: {
25087: #ifdef XP_WIN
25472:     if (gTimerHandle) {
25472:         DeleteTimerQueueTimer(NULL, gTimerHandle, NULL);
25472:         gTimerHandle = 0;
25472:     }
25472:     if (t > 0 &&
25472:         !CreateTimerQueueTimer(&gTimerHandle,
25087:                                NULL,
25087:                                (WAITORTIMERCALLBACK)TimerCallback,
25472:                                rt,
25472:                                DWORD(ceil(t * 1000.0)),
25472:                                0,
25472:                                WT_EXECUTEINTIMERTHREAD | WT_EXECUTEONLYONCE)) {
25472:         gTimerHandle = 0;
25472:         return false;
25472:     }
25087: #else
25472:     /* FIXME: use setitimer when available for sub-second resolution. */
25472:     if (t <= 0) {
25087:         alarm(0);
25087:         signal(SIGALRM, NULL);
25472:     } else {
25472:         signal(SIGALRM, AlarmHandler); /* set the Alarm signal capture */
25472:         alarm(ceil(t));
25472:     }
25087: #endif
25472:     return true;
25472: }
25472: 
25472: #endif /* !JS_THREADSAFE */
25472: 
25472: static void
25472: CancelExecution(JSRuntime *rt)
25472: {
25472:     gCanceled = true;
25472:     if (gExitCode == 0)
25472:         gExitCode = EXITCODE_TIMEOUT;
40801: #ifdef JS_THREADSAFE
55619:     if (gWorkerThreadPool)
55619:         js::workers::terminateAll(rt, gWorkerThreadPool);
40801: #endif
25472:     JS_TriggerAllOperationCallbacks(rt);
25472: 
25472:     static const char msg[] = "Script runs for too long, terminating.\n";
25472: #if defined(XP_UNIX) && !defined(JS_THREADSAFE)
25472:     /* It is not safe to call fputs from signals. */
40249:     /* Dummy assignment avoids GCC warning on "attribute warn_unused_result" */
40249:     ssize_t dummy = write(2, msg, sizeof(msg) - 1);
40249:     (void)dummy;
25472: #else
25472:     fputs(msg, stderr);
25472: #endif
25472: }
23457: 
23457: static JSBool
23457: SetTimeoutValue(JSContext *cx, jsdouble t)
23457: {
23457:     /* NB: The next condition also filter out NaNs. */
25472:     if (!(t <= MAX_TIMEOUT_INTERVAL)) {
23726:         JS_ReportError(cx, "Excessive timeout value");
23457:         return JS_FALSE;
23457:     }
25472:     gTimeoutInterval = t;
25472:     if (!ScheduleWatchdog(cx->runtime, t)) {
25472:         JS_ReportError(cx, "Failed to create the watchdog");
23726:         return JS_FALSE;
23726:     }
23457:     return JS_TRUE;
23457: }
23457: 
23457: static JSBool
23457: Timeout(JSContext *cx, uintN argc, jsval *vp)
23457: {
25087:     if (argc == 0)
25472:         return JS_NewNumberValue(cx, gTimeoutInterval, vp);
23457: 
23457:     if (argc > 1) {
23457:         JS_ReportError(cx, "Wrong number of arguments");
23457:         return JS_FALSE;
23457:     }
23457: 
23457:     jsdouble t;
23457:     if (!JS_ValueToNumber(cx, JS_ARGV(cx, vp)[0], &t))
23457:         return JS_FALSE;
23457: 
23457:     *vp = JSVAL_VOID;
23457:     return SetTimeoutValue(cx, t);
23457: }
23126: 
25087: static JSBool
25087: Elapsed(JSContext *cx, uintN argc, jsval *vp)
25087: {
25087:     if (argc == 0) {
25087:         double d = 0.0;
25087:         JSShellContextData *data = GetContextData(cx);
25087:         if (data)
25087:             d = js_IntervalNow() - data->startTime;
25087:         return JS_NewNumberValue(cx, d, vp);
25087:     }
25087:     JS_ReportError(cx, "Wrong number of arguments");
25087:     return JS_FALSE;
25087: }
25087: 
41968: static JSBool
41968: Parent(JSContext *cx, uintN argc, jsval *vp)
41968: {
41968:     if (argc != 1) {
41968:         JS_ReportError(cx, "Wrong number of arguments");
41968:         return JS_FALSE;
41968:     }
41968: 
41968:     jsval v = JS_ARGV(cx, vp)[0];
41968:     if (JSVAL_IS_PRIMITIVE(v)) {
41968:         JS_ReportError(cx, "Only objects have parents!");
41968:         return JS_FALSE;
41968:     }
41968: 
41973:     JSObject *parent = JS_GetParent(cx, JSVAL_TO_OBJECT(v));
41974:     *vp = OBJECT_TO_JSVAL(parent);
41973: 
41973:     /* Outerize if necessary.  Embrace the ugliness! */
42728:     if (parent) {
48622:         if (JSObjectOp op = parent->getClass()->ext.outerObject)
48622:             *vp = OBJECT_TO_JSVAL(op(cx, parent));
42728:     }
41973: 
41968:     return JS_TRUE;
41968: }
41968: 
24148: #ifdef XP_UNIX
24148: 
24148: #include <fcntl.h>
24148: #include <sys/stat.h>
24148: 
24148: /*
24148:  * Returns a JS_malloc'd string (that the caller needs to JS_free)
24148:  * containing the directory (non-leaf) part of |from| prepended to |leaf|.
24148:  * If |from| is empty or a leaf, MakeAbsolutePathname returns a copy of leaf.
24148:  * Returns NULL to indicate an error.
24148:  */
24148: static char *
24148: MakeAbsolutePathname(JSContext *cx, const char *from, const char *leaf)
24148: {
24148:     size_t dirlen;
24148:     char *dir;
24148:     const char *slash = NULL, *cp;
24148: 
24148:     cp = from;
24148:     while (*cp) {
24148:         if (*cp == '/') {
24148:             slash = cp;
24148:         }
24148: 
24148:         ++cp;
24148:     }
24148: 
24148:     if (!slash) {
24148:         /* We were given a leaf or |from| was empty. */
24148:         return JS_strdup(cx, leaf);
24148:     }
24148: 
24148:     /* Else, we were given a real pathname, return that + the leaf. */
24148:     dirlen = slash - from + 1;
24148:     dir = (char*) JS_malloc(cx, dirlen + strlen(leaf) + 1);
24148:     if (!dir)
24148:         return NULL;
24148: 
24148:     strncpy(dir, from, dirlen);
24148:     strcpy(dir + dirlen, leaf); /* Note: we can't use strcat here. */
24148: 
24148:     return dir;
24148: }
24148: 
24148: #endif // XP_UNIX
24148: 
24148: static JSBool
39934: Compile(JSContext *cx, uintN argc, jsval *vp)
39934: {
39934:     if (argc < 1) {
39934:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
39934:                              "compile", "0", "s");
39934:         return JS_FALSE;
39934:     }
39934:     jsval arg0 = JS_ARGV(cx, vp)[0];
39934:     if (!JSVAL_IS_STRING(arg0)) {
39934:         const char *typeName = JS_GetTypeName(cx, JS_TypeOfValue(cx, arg0));
39934:         JS_ReportError(cx, "expected string to compile, got %s", typeName);
39934:         return JS_FALSE;
39934:     }
39934: 
39934:     JSString *scriptContents = JSVAL_TO_STRING(arg0);
39934:     JSScript *result = JS_CompileUCScript(cx, NULL, JS_GetStringCharsZ(cx, scriptContents),
39934:                                           JS_GetStringLength(scriptContents), "<string>", 0);
39934:     if (!result)
39934:         return JS_FALSE;
39934: 
39934:     JS_DestroyScript(cx, result);
39934:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
39934:     return JS_TRUE;
39934: }
39934: 
39934: static JSBool
41091: Parse(JSContext *cx, uintN argc, jsval *vp)
41091: {
41091:     if (argc < 1) {
41091:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
41091:                              "compile", "0", "s");
41091:         return JS_FALSE;
41091:     }
41091:     jsval arg0 = JS_ARGV(cx, vp)[0];
41091:     if (!JSVAL_IS_STRING(arg0)) {
41091:         const char *typeName = JS_GetTypeName(cx, JS_TypeOfValue(cx, arg0));
41091:         JS_ReportError(cx, "expected string to parse, got %s", typeName);
41091:         return JS_FALSE;
41091:     }
41091: 
41091:     JSString *scriptContents = JSVAL_TO_STRING(arg0);
41091:     js::Parser parser(cx);
41091:     parser.init(JS_GetStringCharsZ(cx, scriptContents), JS_GetStringLength(scriptContents),
41091:                 NULL, "<string>", 0);
41869:     if (!parser.parse(NULL))
41869:         return JS_FALSE;
41091:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
41091:     return JS_TRUE;
41091: }
41091: 
41091: static JSBool
53557: Snarf(JSContext *cx, uintN argc, jsval *vp)
24148: {
24148:     JSString *str;
24148:     const char *filename;
24148:     const char *pathname;
24148:     JSStackFrame *fp;
24148:     JSBool ok;
24148:     size_t cc, len;
24148:     char *buf;
24148:     FILE *file;
24148: 
53557:     if (!argc)
53557:         return JS_FALSE;
53557: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
24148:     if (!str)
24148:         return JS_FALSE;
24148:     filename = JS_GetStringBytes(str);
24148: 
24148:     /* Get the currently executing script's name. */
24148:     fp = JS_GetScriptedCaller(cx, NULL);
53840:     JS_ASSERT(fp && fp->script()->filename);
24148: #ifdef XP_UNIX
53840:     pathname = MakeAbsolutePathname(cx, fp->script()->filename, filename);
24148:     if (!pathname)
24148:         return JS_FALSE;
24148: #else
24148:     pathname = filename;
24148: #endif
24148: 
24148:     ok = JS_FALSE;
24148:     len = 0;
24148:     buf = NULL;
24148:     file = fopen(pathname, "rb");
24148:     if (!file) {
24148:         JS_ReportError(cx, "can't open %s: %s", pathname, strerror(errno));
24148:     } else {
24148:         if (fseek(file, 0, SEEK_END) == EOF) {
24148:             JS_ReportError(cx, "can't seek end of %s", pathname);
24148:         } else {
24148:             len = ftell(file);
24148:             if (fseek(file, 0, SEEK_SET) == EOF) {
24148:                 JS_ReportError(cx, "can't seek start of %s", pathname);
24148:             } else {
24148:                 buf = (char*) JS_malloc(cx, len + 1);
24148:                 if (buf) {
24148:                     cc = fread(buf, 1, len, file);
24148:                     if (cc != len) {
24148:                         JS_ReportError(cx, "can't read %s: %s", pathname,
24148:                                        (ptrdiff_t(cc) < 0) ? strerror(errno) : "short read");
24148:                     } else {
24148:                         len = (size_t)cc;
24148:                         ok = JS_TRUE;
24148:                     }
24148:                 }
24148:             }
24148:         }
24148:         fclose(file);
24148:     }
24148:     JS_free(cx, (void*)pathname);
24148:     if (!ok) {
24148:         JS_free(cx, buf);
24148:         return ok;
24148:     }
24148: 
24148:     buf[len] = '\0';
24148:     str = JS_NewString(cx, buf, len);
24148:     if (!str) {
24148:         JS_free(cx, buf);
24148:         return JS_FALSE;
24148:     }
53557:     *vp = STRING_TO_JSVAL(str);
24148:     return JS_TRUE;
24148: }
24148: 
42733: JSBool
42733: Wrap(JSContext *cx, uintN argc, jsval *vp)
42733: {
42733:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
42733:     if (JSVAL_IS_PRIMITIVE(v)) {
42733:         JS_SET_RVAL(cx, vp, v);
42733:         return true;
42733:     }
42733: 
47498:     JSObject *obj = JSVAL_TO_OBJECT(v);
47498:     JSObject *wrapped = JSWrapper::New(cx, obj, obj->getProto(), obj->getParent(),
47498:                                        &JSWrapper::singleton);
42733:     if (!wrapped)
42733:         return false;
42733: 
42733:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(wrapped));
42733:     return true;
42733: }
42733: 
54863: JSBool
54863: Serialize(JSContext *cx, uintN argc, jsval *vp)
54863: {
54863:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
54863:     uint64 *datap;
54863:     size_t nbytes;
54863:     if (!JS_WriteStructuredClone(cx, v, &datap, &nbytes))
54863:         return false;
54863: 
54863:     JSObject *arrayobj = js_CreateTypedArray(cx, TypedArray::TYPE_UINT8, nbytes);
54863:     if (!arrayobj) {
54863:         JS_free(cx, datap);
54863:         return false;
54863:     }
54863:     TypedArray *array = TypedArray::fromJSObject(arrayobj);
54863:     JS_ASSERT((uintptr_t(array->data) & 7) == 0);
54863:     memcpy(array->data, datap, nbytes);
54863:     JS_free(cx, datap);
54863:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(arrayobj));
54863:     return true;
54863: }
54863: 
54863: JSBool
54863: Deserialize(JSContext *cx, uintN argc, jsval *vp)
54863: {
54863:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
54863:     JSObject *obj;
54863:     if (!JSVAL_IS_OBJECT(v) || !js_IsTypedArray((obj = JSVAL_TO_OBJECT(v)))) {
54863:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "deserialize");
54863:         return false;
54863:     }
54863:     TypedArray *array = TypedArray::fromJSObject(obj);
54863:     if ((uintptr_t(array->data) & 7) != 0) {
54863:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_BAD_ALIGNMENT);
54863:         return false;
54863:     }
54863: 
54863:     if (!JS_ReadStructuredClone(cx, (uint64 *) array->data, array->byteLength, &v))
54863:         return false;
54863:     JS_SET_RVAL(cx, vp, v);
54863:     return true;
54863: }
54863: 
23126: /* We use a mix of JS_FS and JS_FN to test both kinds of natives. */
23126: static JSFunctionSpec shell_functions[] = {
53557:     JS_FN("version",        Version,        0,0),
53848:     JS_FN("revertVersion",  RevertVersion,  0,0),
53557:     JS_FN("options",        Options,        0,0),
53557:     JS_FN("load",           Load,           1,0),
23126:     JS_FN("readline",       ReadLine,       0,0),
27165:     JS_FN("print",          Print,          0,0),
48808:     JS_FN("putstr",         PutStr,         0,0),
50450:     JS_FN("dateNow",        Now,            0,0),
53557:     JS_FN("help",           Help,           0,0),
53557:     JS_FN("quit",           Quit,           0,0),
27165:     JS_FN("assertEq",       AssertEq,       2,0),
53120:     JS_FN("assertJit",      AssertJit,      0,0),
30450:     JS_FN("gc",             ::GC,           0,0),
36680: #ifdef JS_GCMETER
36680:     JS_FN("gcstats",        GCStats,        0,0),
36680: #endif
23126:     JS_FN("gcparam",        GCParameter,    2,0),
23126:     JS_FN("countHeap",      CountHeap,      0,0),
54561:     JS_FN("makeFinalizeObserver", MakeFinalizeObserver, 0,0),
54561:     JS_FN("finalizeCount",  FinalizeCount, 0,0),
23126: #ifdef JS_GC_ZEAL
23126:     JS_FN("gczeal",         GCZeal,         1,0),
23126: #endif
53557:     JS_FN("setDebug",       SetDebug,       1,0),
53557:     JS_FN("setDebuggerHandler", SetDebuggerHandler, 1,0),
53557:     JS_FN("setThrowHook",   SetThrowHook,   1,0),
53557:     JS_FN("trap",           Trap,           3,0),
53557:     JS_FN("untrap",         Untrap,         2,0),
53557:     JS_FN("line2pc",        LineToPC,       0,0),
53557:     JS_FN("pc2line",        PCToLine,       0,0),
23126:     JS_FN("stackQuota",     StackQuota,     0,0),
53557:     JS_FN("stringsAreUTF8", StringsAreUTF8, 0,0),
53557:     JS_FN("testUTF8",       TestUTF8,       1,0),
53557:     JS_FN("throwError",     ThrowError,     0,0),
23126: #ifdef DEBUG
53557:     JS_FN("dis",            Disassemble,    1,0),
53557:     JS_FN("disfile",        DisassFile,     1,0),
53557:     JS_FN("dissrc",         DisassWithSrc,  1,0),
23126:     JS_FN("dumpHeap",       DumpHeap,       0,0),
53557:     JS_FN("dumpObject",     DumpObject,     1,0),
53557:     JS_FN("notes",          Notes,          1,0),
53557:     JS_FN("tracing",        Tracing,        0,0),
53557:     JS_FN("stats",          DumpStats,      1,0),
23126: #endif
23126: #ifdef TEST_CVTARGS
53557:     JS_FN("cvtargs",        ConvertArgs,    0,0),
23126: #endif
23126:     JS_FN("build",          BuildDate,      0,0),
53557:     JS_FN("clear",          Clear,          0,0),
23126:     JS_FN("intern",         Intern,         1,0),
53557:     JS_FN("clone",          Clone,          1,0),
23126:     JS_FN("getpda",         GetPDA,         1,0),
23126:     JS_FN("getslx",         GetSLX,         1,0),
23126:     JS_FN("toint32",        ToInt32,        1,0),
53557:     JS_FN("evalcx",         EvalInContext,  1,0),
40276:     JS_FN("evalInFrame",    EvalInFrame,    2,0),
27165:     JS_FN("shapeOf",        ShapeOf,        1,0),
23126: #ifdef MOZ_SHARK
53557:     JS_FN("startShark",     js_StartShark,      0,0),
53557:     JS_FN("stopShark",      js_StopShark,       0,0),
53557:     JS_FN("connectShark",   js_ConnectShark,    0,0),
53557:     JS_FN("disconnectShark",js_DisconnectShark, 0,0),
23126: #endif
23126: #ifdef MOZ_CALLGRIND
53557:     JS_FN("startCallgrind", js_StartCallgrind,  0,0),
53557:     JS_FN("stopCallgrind",  js_StopCallgrind,   0,0),
53557:     JS_FN("dumpCallgrind",  js_DumpCallgrind,   1,0),
23126: #endif
23126: #ifdef MOZ_VTUNE
53557:     JS_FN("startVtune",     js_StartVtune,    1,0),
53557:     JS_FN("stopVtune",      js_StopVtune,     0,0),
53557:     JS_FN("pauseVtune",     js_PauseVtune,    0,0),
53557:     JS_FN("resumeVtune",    js_ResumeVtune,   0,0),
23126: #endif
29368: #ifdef MOZ_TRACEVIS
53557:     JS_FN("startTraceVis",  StartTraceVisNative, 1,0),
53557:     JS_FN("stopTraceVis",   StopTraceVisNative,  0,0),
29368: #endif
23126: #ifdef DEBUG_ARRAYS
53557:     JS_FN("arrayInfo",      js_ArrayInfo,   1,0),
23126: #endif
23126: #ifdef JS_THREADSAFE
23126:     JS_FN("sleep",          Sleep_fn,       1,0),
23126:     JS_FN("scatter",        Scatter,        1,0),
23126: #endif
53557:     JS_FN("snarf",          Snarf,          0,0),
53557:     JS_FN("read",           Snarf,          0,0),
39934:     JS_FN("compile",        Compile,        1,0),
41091:     JS_FN("parse",          Parse,          1,0),
23457:     JS_FN("timeout",        Timeout,        1,0),
25087:     JS_FN("elapsed",        Elapsed,        0,0),
41968:     JS_FN("parent",         Parent,         1,0),
42733:     JS_FN("wrap",           Wrap,           1,0),
54863:     JS_FN("serialize",      Serialize,      1,0),
54863:     JS_FN("deserialize",    Deserialize,    1,0),
23126:     JS_FS_END
23126: };
23126: 
23126: static const char shell_help_header[] =
23126: "Command                  Description\n"
23126: "=======                  ===========\n";
23126: 
23126: static const char *const shell_help_messages[] = {
53848: "version([number])        Get or force a script compilation version number",
53848: "revertVersion()          Revert previously set version number",
23126: "options([option ...])    Get or toggle JavaScript options",
23126: "load(['foo.js' ...])     Load files named by string arguments",
23126: "readline()               Read a single line from stdin",
23126: "print([exp ...])         Evaluate and print expressions",
48808: "putstr([exp])            Evaluate and print expression without newline",
50450: "dateNow()                    Return the current time with sub-ms precision",
23126: "help([name ...])         Display usage and help messages",
23126: "quit()                   Quit the shell",
32760: "assertEq(actual, expected[, msg])\n"
32760: "  Throw if the first two arguments are not the same (both +0 or both -0,\n"
32760: "  both NaN, or non-zero and ===)",
53120: "assertJit()              Throw if the calling function failed to JIT\n",
23126: "gc()                     Run the garbage collector",
36680: #ifdef JS_GCMETER
36680: "gcstats()                Print garbage collector statistics",
36680: #endif
23126: "gcparam(name, value)\n"
23126: "  Wrapper for JS_SetGCParameter. The name must be either 'maxBytes' or\n"
23126: "  'maxMallocBytes' and the value must be convertable to a positive uint32",
23126: "countHeap([start[, kind]])\n"
23126: "  Count the number of live GC things in the heap or things reachable from\n"
23126: "  start when it is given and is not null. kind is either 'all' (default) to\n"
23126: "  count all things or one of 'object', 'double', 'string', 'function',\n"
23126: "  'qname', 'namespace', 'xml' to count only things of that kind",
54561: "makeFinalizeObserver()\n"
54561: "  get a special object whose finalization increases the counter returned\n"
54561: "  by the finalizeCount function",
54561: "finalizeCount()\n"
54561: "  return the current value of the finalization counter that is incremented\n"
54561: "  each time an object returned by the makeFinalizeObserver is finalized",
23126: #ifdef JS_GC_ZEAL
23126: "gczeal(level)            How zealous the garbage collector should be",
23126: #endif
53391: "setDebug(debug)          Set debug mode",
53395: "setDebuggerHandler(f)    Set handler for debugger keyword to f",
53410: "setThrowHook(f)          Set throw hook to f",
23126: "trap([fun, [pc,]] exp)   Trap bytecode execution",
23126: "untrap(fun[, pc])        Remove a trap",
23126: "line2pc([fun,] line)     Map line number to PC",
23126: "pc2line(fun[, pc])       Map PC to line number",
23126: "stackQuota([number])     Query/set script stack quota",
23126: "stringsAreUTF8()         Check if strings are UTF-8 encoded",
23126: "testUTF8(mode)           Perform UTF-8 tests (modes are 1 to 4)",
23126: "throwError()             Throw an error from JS_ReportError",
23126: #ifdef DEBUG
47541: "dis([fun])               Disassemble functions into bytecodes\n"
47541: "dis('-r', fun)           Disassembles recursively",
23126: "disfile('foo.js')        Disassemble script file into bytecodes",
23126: "dissrc([fun])            Disassemble functions with source lines",
23126: "dumpHeap([fileName[, start[, toFind[, maxDepth[, toIgnore]]]]])\n"
23126: "  Interface to JS_DumpHeap with output sent to file",
49117: "dumpObject()             Dump an internal representation of an object",
23126: "notes([fun])             Show source notes for functions",
26954: "tracing([true|false|filename]) Turn bytecode execution tracing on/off.\n"
26954: "                         With filename, send to file.\n",
23126: "stats([string ...])      Dump 'arena', 'atom', 'global' stats",
23126: #endif
23126: #ifdef TEST_CVTARGS
23126: "cvtargs(arg1..., arg12)  Test argument formatter",
23126: #endif
23126: "build()                  Show build date and time",
23126: "clear([obj])             Clear properties of object",
23126: "intern(str)              Internalize str in the atom table",
23126: "clone(fun[, scope])      Clone function object",
23126: "getpda(obj)              Get the property descriptors for obj",
23126: "getslx(obj)              Get script line extent",
23126: "toint32(n)               Testing hook for JS_ValueToInt32",
23126: "evalcx(s[, o])\n"
23126: "  Evaluate s in optional sandbox object o\n"
23126: "  if (s == '' && !o) return new o with eager standard classes\n"
35108: "  if (s == 'lazy' && !o) return new o with lazy standard classes\n"
35108: "  if (s == 'split' && !o) return new split-object o with lazy standard classes",
40276: "evalInFrame(n,str,save)  Evaluate 'str' in the nth up frame.\n"
40276: "                         If 'save' (default false), save the frame chain",
23126: "shapeOf(obj)             Get the shape of obj (an implementation detail)",
23126: #ifdef MOZ_SHARK
23126: "startShark()             Start a Shark session.\n"
23457: "                         Shark must be running with programatic sampling",
23457: "stopShark()              Stop a running Shark session",
23126: "connectShark()           Connect to Shark.\n"
23457: "                         The -k switch does this automatically",
23457: "disconnectShark()        Disconnect from Shark",
23126: #endif
23126: #ifdef MOZ_CALLGRIND
23457: "startCallgrind()         Start callgrind instrumentation",
23457: "stopCallgrind()          Stop callgrind instrumentation",
23457: "dumpCallgrind([name])    Dump callgrind counters",
23126: #endif
23126: #ifdef MOZ_VTUNE
23457: "startVtune([filename])   Start vtune instrumentation",
23457: "stopVtune()              Stop vtune instrumentation",
23457: "pauseVtune()             Pause vtune collection",
23457: "resumeVtune()            Resume vtune collection",
23126: #endif
29368: #ifdef MOZ_TRACEVIS
29368: "startTraceVis(filename)  Start TraceVis recording (stops any current recording)",
29368: "stopTraceVis()           Stop TraceVis recording",
29368: #endif
23126: #ifdef DEBUG_ARRAYS
23457: "arrayInfo(a1, a2, ...)   Report statistics about arrays",
23126: #endif
23126: #ifdef JS_THREADSAFE
23126: "sleep(dt)                Sleep for dt seconds",
23126: "scatter(fns)             Call functions concurrently (ignoring errors)",
23126: #endif
24148: "snarf(filename)          Read filename into returned string",
50450: "read(filename)           Synonym for snarf",
41091: "compile(code)            Compiles a string to bytecode, potentially throwing",
41091: "parse(code)              Parses a string, potentially throwing",
23457: "timeout([seconds])\n"
23457: "  Get/Set the limit in seconds for the execution time for the current context.\n"
23457: "  A negative value (default) means that the execution time is unlimited.",
41968: "elapsed()                Execution time elapsed for the current context.",
41968: "parent(obj)              Returns the parent of obj.\n",
54863: "wrap(obj)                Wrap an object into a noop wrapper.\n",
54863: "serialize(sd)            Serialize sd using JS_WriteStructuredClone. Returns a TypedArray.\n",
54863: "deserialize(a)           Deserialize data generated by serialize.\n"
23126: };
23126: 
23126: /* Help messages must match shell functions. */
23126: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(shell_help_messages) + 1 ==
23126:                  JS_ARRAY_LENGTH(shell_functions));
23126: 
23126: #ifdef DEBUG
23126: static void
23126: CheckHelpMessages()
23126: {
23126:     const char *const *m;
23126:     const char *lp;
23126: 
23126:     /* Each message must begin with "function_name(" prefix. */
23126:     for (m = shell_help_messages; m != JS_ARRAY_END(shell_help_messages); ++m) {
23126:         lp = strchr(*m, '(');
23126:         JS_ASSERT(lp);
23126:         JS_ASSERT(memcmp(shell_functions[m - shell_help_messages].name,
23126:                          *m, lp - *m) == 0);
23126:     }
23126: }
23126: #else
23126: # define CheckHelpMessages() ((void) 0)
23126: #endif
23126: 
23126: static JSBool
53557: Help(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     uintN i, j;
23126:     int did_header, did_something;
23126:     JSType type;
23126:     JSFunction *fun;
23126:     JSString *str;
23126:     const char *bytes;
23126: 
23126:     fprintf(gOutFile, "%s\n", JS_GetImplementationVersion());
23126:     if (argc == 0) {
23126:         fputs(shell_help_header, gOutFile);
23126:         for (i = 0; shell_functions[i].name; i++)
23126:             fprintf(gOutFile, "%s\n", shell_help_messages[i]);
23126:     } else {
23126:         did_header = 0;
53557:         jsval *argv = JS_ARGV(cx, vp);
23126:         for (i = 0; i < argc; i++) {
23126:             did_something = 0;
23126:             type = JS_TypeOfValue(cx, argv[i]);
23126:             if (type == JSTYPE_FUNCTION) {
23126:                 fun = JS_ValueToFunction(cx, argv[i]);
23126:                 str = fun->atom ? ATOM_TO_STRING(fun->atom) : NULL;
23126:             } else if (type == JSTYPE_STRING) {
23126:                 str = JSVAL_TO_STRING(argv[i]);
23126:             } else {
23126:                 str = NULL;
23126:             }
23126:             if (str) {
23126:                 bytes = JS_GetStringBytes(str);
23126:                 for (j = 0; shell_functions[j].name; j++) {
23126:                     if (!strcmp(bytes, shell_functions[j].name)) {
23126:                         if (!did_header) {
23126:                             did_header = 1;
23126:                             fputs(shell_help_header, gOutFile);
23126:                         }
23126:                         did_something = 1;
23126:                         fprintf(gOutFile, "%s\n", shell_help_messages[j]);
23126:                         break;
23126:                     }
23126:                 }
23126:             }
23126:             if (!did_something) {
23126:                 str = JS_ValueToString(cx, argv[i]);
23126:                 if (!str)
23126:                     return JS_FALSE;
23126:                 fprintf(gErrFile, "Sorry, no help for %s\n",
23126:                         JS_GetStringBytes(str));
23126:             }
23126:         }
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSObject *
35108: split_setup(JSContext *cx, JSBool evalcx)
23126: {
23126:     JSObject *outer, *inner, *arguments;
23126: 
23126:     outer = split_create_outer(cx);
23126:     if (!outer)
23126:         return NULL;
47517:     AutoObjectRooter root(cx, outer);
47517:     if (!evalcx)
23126:         JS_SetGlobalObject(cx, outer);
23126: 
23126:     inner = split_create_inner(cx, outer);
23126:     if (!inner)
23126:         return NULL;
23126: 
35108:     if (!evalcx) {
23126:         if (!JS_DefineFunctions(cx, inner, shell_functions))
23126:             return NULL;
23126: 
23126:         /* Create a dummy arguments object. */
23126:         arguments = JS_NewArrayObject(cx, 0, NULL);
23126:         if (!arguments ||
23126:             !JS_DefineProperty(cx, inner, "arguments", OBJECT_TO_JSVAL(arguments),
23126:                                NULL, NULL, 0)) {
23126:             return NULL;
23126:         }
35108:     }
35108: 
35108:     JS_ClearScope(cx, outer);
23126: 
23126: #ifndef LAZY_STANDARD_CLASSES
23126:     if (!JS_InitStandardClasses(cx, inner))
23126:         return NULL;
23126: #endif
23126: 
23126:     return inner;
23126: }
23126: 
23126: /*
23126:  * Define a JS object called "it".  Give it class operations that printf why
23126:  * they're being called for tutorial purposes.
23126:  */
23126: enum its_tinyid {
26666:     ITS_COLOR, ITS_HEIGHT, ITS_WIDTH, ITS_FUNNY, ITS_ARRAY, ITS_RDONLY,
26666:     ITS_CUSTOM, ITS_CUSTOMRDONLY
23126: };
23126: 
26666: static JSBool
48470: its_getter(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
26666: {
26666:   jsval *val = (jsval *) JS_GetPrivate(cx, obj);
26666:   *vp = val ? *val : JSVAL_VOID;
26666:   return JS_TRUE;
26666: }
26666: 
26666: static JSBool
48470: its_setter(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
26666: {
26666:   jsval *val = (jsval *) JS_GetPrivate(cx, obj);
26666:   if (val) {
26666:       *val = *vp;
26666:       return JS_TRUE;
26666:   }
26666: 
26666:   val = new jsval;
26666:   if (!val) {
26666:       JS_ReportOutOfMemory(cx);
26666:       return JS_FALSE;
26666:   }
26666: 
47403:   if (!JS_AddValueRoot(cx, val)) {
26666:       delete val;
26666:       return JS_FALSE;
26666:   }
26666: 
26666:   if (!JS_SetPrivate(cx, obj, (void*)val)) {
47403:       JS_RemoveValueRoot(cx, val);
26666:       delete val;
26666:       return JS_FALSE;
26666:   }
26666: 
26666:   *val = *vp;
26666:   return JS_TRUE;
26666: }
26666: 
23126: static JSPropertySpec its_props[] = {
23126:     {"color",           ITS_COLOR,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"height",          ITS_HEIGHT,     JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"width",           ITS_WIDTH,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"funny",           ITS_FUNNY,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"array",           ITS_ARRAY,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"rdonly",          ITS_RDONLY,     JSPROP_READONLY,        NULL, NULL},
26666:     {"custom",          ITS_CUSTOM,     JSPROP_ENUMERATE,
26666:                         its_getter,     its_setter},
26666:     {"customRdOnly",    ITS_CUSTOMRDONLY, JSPROP_ENUMERATE | JSPROP_READONLY,
26666:                         its_getter,     its_setter},
23126:     {NULL,0,0,NULL,NULL}
23126: };
23126: 
23126: static JSBool
53557: its_bindMethod(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     char *name;
23126:     JSObject *method;
23126: 
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557: 
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "so", &name, &method))
23126:         return JS_FALSE;
23126: 
53557:     *vp = OBJECT_TO_JSVAL(method);
53557: 
53557:     if (JS_TypeOfValue(cx, *vp) != JSTYPE_FUNCTION) {
53557:         JSString *valstr = JS_ValueToString(cx, *vp);
23126:         if (valstr) {
23126:             JS_ReportError(cx, "can't bind method %s to non-callable object %s",
23126:                            name, JS_GetStringBytes(valstr));
23126:         }
23126:         return JS_FALSE;
23126:     }
23126: 
53557:     if (!JS_DefineProperty(cx, thisobj, name, *vp, NULL, NULL, JSPROP_ENUMERATE))
23126:         return JS_FALSE;
23126: 
53557:     return JS_SetParent(cx, method, thisobj);
23126: }
23126: 
23126: static JSFunctionSpec its_methods[] = {
53557:     {"bindMethod",      its_bindMethod, 2,0},
53557:     {NULL,NULL,0,0}
23126: };
23126: 
23126: #ifdef JSD_LOWLEVEL_SOURCE
23126: /*
23126:  * This facilitates sending source to JSD (the debugger system) in the shell
23126:  * where the source is loaded using the JSFILE hack in jsscan. The function
23126:  * below is used as a callback for the jsdbgapi JS_SetSourceHandler hook.
23126:  * A more normal embedding (e.g. mozilla) loads source itself and can send
23126:  * source directly to JSD without using this hook scheme.
23126:  */
23126: static void
23126: SendSourceToJSDebugger(const char *filename, uintN lineno,
23126:                        jschar *str, size_t length,
23126:                        void **listenerTSData, JSDContext* jsdc)
23126: {
23126:     JSDSourceText *jsdsrc = (JSDSourceText *) *listenerTSData;
23126: 
23126:     if (!jsdsrc) {
23126:         if (!filename)
23126:             filename = "typein";
23126:         if (1 == lineno) {
23126:             jsdsrc = JSD_NewSourceText(jsdc, filename);
23126:         } else {
23126:             jsdsrc = JSD_FindSourceForURL(jsdc, filename);
23126:             if (jsdsrc && JSD_SOURCE_PARTIAL !=
23126:                 JSD_GetSourceStatus(jsdc, jsdsrc)) {
23126:                 jsdsrc = NULL;
23126:             }
23126:         }
23126:     }
23126:     if (jsdsrc) {
23126:         jsdsrc = JSD_AppendUCSourceText(jsdc,jsdsrc, str, length,
23126:                                         JSD_SOURCE_PARTIAL);
23126:     }
23126:     *listenerTSData = jsdsrc;
23126: }
23126: #endif /* JSD_LOWLEVEL_SOURCE */
23126: 
23126: static JSBool its_noisy;    /* whether to be noisy when finalizing it */
23126: static JSBool its_enum_fail;/* whether to fail when enumerating it */
23126: 
23126: static JSBool
48470: its_addProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
48470:     IdToString idString(cx, id);
31366:     fprintf(gOutFile, "adding its property %s,", idString.getBytes());
31366:     ToString valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_delProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
48470:     IdToString idString(cx, id);
31366:     fprintf(gOutFile, "deleting its property %s,", idString.getBytes());
31366:     ToString valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
48470:     IdToString idString(cx, id);
31366:     fprintf(gOutFile, "getting its property %s,", idString.getBytes());
31366:     ToString valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_setProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
48470:     IdToString idString(cx, id);
23126:     if (its_noisy) {
31366:         fprintf(gOutFile, "setting its property %s,", idString.getBytes());
31366:         ToString valueString(cx, *vp);
31366:         fprintf(gOutFile, " new value %s\n", valueString.getBytes());
23126:     }
23126: 
48470:     if (!JSID_IS_ATOM(id))
23126:         return JS_TRUE;
23126: 
31366:     if (!strcmp(idString.getBytes(), "noisy"))
30581:         JS_ValueToBoolean(cx, *vp, &its_noisy);
31366:     else if (!strcmp(idString.getBytes(), "enum_fail"))
30581:         JS_ValueToBoolean(cx, *vp, &its_enum_fail);
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: /*
23126:  * Its enumerator, implemented using the "new" enumerate API,
23126:  * see class flags.
23126:  */
23126: static JSBool
23126: its_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
23126:               jsval *statep, jsid *idp)
23126: {
23126:     JSObject *iterator;
23126: 
23126:     switch (enum_op) {
23126:       case JSENUMERATE_INIT:
47569:       case JSENUMERATE_INIT_ALL:
23126:         if (its_noisy)
23126:             fprintf(gOutFile, "enumerate its properties\n");
23126: 
23126:         iterator = JS_NewPropertyIterator(cx, obj);
23126:         if (!iterator)
23126:             return JS_FALSE;
23126: 
23126:         *statep = OBJECT_TO_JSVAL(iterator);
23126:         if (idp)
48470:             *idp = INT_TO_JSID(0);
23126:         break;
23126: 
23126:       case JSENUMERATE_NEXT:
23126:         if (its_enum_fail) {
23126:             JS_ReportError(cx, "its enumeration failed");
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         iterator = (JSObject *) JSVAL_TO_OBJECT(*statep);
23126:         if (!JS_NextProperty(cx, iterator, idp))
23126:             return JS_FALSE;
23126: 
48470:         if (!JSID_IS_VOID(*idp))
23126:             break;
23126:         /* Fall through. */
23126: 
23126:       case JSENUMERATE_DESTROY:
23126:         /* Allow our iterator object to be GC'd. */
23126:         *statep = JSVAL_NULL;
23126:         break;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:             JSObject **objp)
23126: {
23126:     if (its_noisy) {
48470:         IdToString idString(cx, id);
23126:         fprintf(gOutFile, "resolving its property %s, flags {%s,%s,%s}\n",
31366:                idString.getBytes(),
23126:                (flags & JSRESOLVE_QUALIFIED) ? "qualified" : "",
23126:                (flags & JSRESOLVE_ASSIGNING) ? "assigning" : "",
23126:                (flags & JSRESOLVE_DETECTING) ? "detecting" : "");
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: its_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
23126: {
23126:     if (its_noisy)
23126:         fprintf(gOutFile, "converting it to %s type\n", JS_GetTypeName(cx, type));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static void
23126: its_finalize(JSContext *cx, JSObject *obj)
23126: {
26666:     jsval *rootedVal;
23126:     if (its_noisy)
23126:         fprintf(gOutFile, "finalizing it\n");
26666:     rootedVal = (jsval *) JS_GetPrivate(cx, obj);
26666:     if (rootedVal) {
47403:       JS_RemoveValueRoot(cx, rootedVal);
26666:       JS_SetPrivate(cx, obj, NULL);
26666:       delete rootedVal;
26666:     }
23126: }
23126: 
23126: static JSClass its_class = {
26666:     "It", JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_HAS_PRIVATE,
23126:     its_addProperty,  its_delProperty,  its_getProperty,  its_setProperty,
23126:     (JSEnumerateOp)its_enumerate, (JSResolveOp)its_resolve,
23126:     its_convert,      its_finalize,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
23126: JSErrorFormatString jsShell_ErrorFormatString[JSErr_Limit] = {
23126: #define MSG_DEF(name, number, count, exception, format) \
23126:     { format, count, JSEXN_ERR } ,
23126: #include "jsshell.msg"
23126: #undef MSG_DEF
23126: };
23126: 
23126: static const JSErrorFormatString *
23126: my_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber)
23126: {
23126:     if ((errorNumber > 0) && (errorNumber < JSShellErr_Limit))
23126:         return &jsShell_ErrorFormatString[errorNumber];
23126:     return NULL;
23126: }
23126: 
23126: static void
23126: my_ErrorReporter(JSContext *cx, const char *message, JSErrorReport *report)
23126: {
23126:     int i, j, k, n;
23126:     char *prefix, *tmp;
23126:     const char *ctmp;
23126: 
23126:     if (!report) {
23126:         fprintf(gErrFile, "%s\n", message);
23126:         return;
23126:     }
23126: 
23126:     /* Conditionally ignore reported warnings. */
23126:     if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
23126:         return;
23126: 
23126:     prefix = NULL;
23126:     if (report->filename)
23126:         prefix = JS_smprintf("%s:", report->filename);
23126:     if (report->lineno) {
23126:         tmp = prefix;
23126:         prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
23126:         JS_free(cx, tmp);
23126:     }
23126:     if (JSREPORT_IS_WARNING(report->flags)) {
23126:         tmp = prefix;
23126:         prefix = JS_smprintf("%s%swarning: ",
23126:                              tmp ? tmp : "",
23126:                              JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
23126:         JS_free(cx, tmp);
23126:     }
23126: 
23126:     /* embedded newlines -- argh! */
23126:     while ((ctmp = strchr(message, '\n')) != 0) {
23126:         ctmp++;
23126:         if (prefix)
23126:             fputs(prefix, gErrFile);
23126:         fwrite(message, 1, ctmp - message, gErrFile);
23126:         message = ctmp;
23126:     }
23126: 
23126:     /* If there were no filename or lineno, the prefix might be empty */
23126:     if (prefix)
23126:         fputs(prefix, gErrFile);
23126:     fputs(message, gErrFile);
23126: 
23126:     if (!report->linebuf) {
23126:         fputc('\n', gErrFile);
23126:         goto out;
23126:     }
23126: 
23126:     /* report->linebuf usually ends with a newline. */
23126:     n = strlen(report->linebuf);
23126:     fprintf(gErrFile, ":\n%s%s%s%s",
23126:             prefix,
23126:             report->linebuf,
23126:             (n > 0 && report->linebuf[n-1] == '\n') ? "" : "\n",
23126:             prefix);
25144:     n = report->tokenptr - report->linebuf;
23126:     for (i = j = 0; i < n; i++) {
23126:         if (report->linebuf[i] == '\t') {
23126:             for (k = (j + 8) & ~7; j < k; j++) {
23126:                 fputc('.', gErrFile);
23126:             }
23126:             continue;
23126:         }
23126:         fputc('.', gErrFile);
23126:         j++;
23126:     }
23126:     fputs("^\n", gErrFile);
23126:  out:
23126:     if (!JSREPORT_IS_WARNING(report->flags)) {
23126:         if (report->errorNumber == JSMSG_OUT_OF_MEMORY) {
23126:             gExitCode = EXITCODE_OUT_OF_MEMORY;
23126:         } else {
23126:             gExitCode = EXITCODE_RUNTIME_ERROR;
23126:         }
23126:     }
23126:     JS_free(cx, prefix);
23126: }
23126: 
23126: #if defined(SHELL_HACK) && defined(DEBUG) && defined(XP_UNIX)
23126: static JSBool
53557: Exec(JSContext *cx, uintN argc, jsval *vp)
23126: {
23126:     JSFunction *fun;
23126:     const char *name, **nargv;
23126:     uintN i, nargc;
23126:     JSString *str;
23126:     pid_t pid;
23126:     int status;
23126: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53557: 
53557:     fun = JS_ValueToFunction(cx, vp[0]);
23126:     if (!fun)
23126:         return JS_FALSE;
23126:     if (!fun->atom)
23126:         return JS_TRUE;
23126:     name = JS_GetStringBytes(ATOM_TO_STRING(fun->atom));
23126:     nargc = 1 + argc;
23126:     nargv = JS_malloc(cx, (nargc + 1) * sizeof(char *));
23126:     if (!nargv)
23126:         return JS_FALSE;
23126:     nargv[0] = name;
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 1; i < nargc; i++) {
23126:         str = JS_ValueToString(cx, argv[i-1]);
23126:         if (!str) {
23126:             JS_free(cx, nargv);
23126:             return JS_FALSE;
23126:         }
23126:         nargv[i] = JS_GetStringBytes(str);
23126:     }
23126:     nargv[nargc] = 0;
23126:     pid = fork();
23126:     switch (pid) {
23126:       case -1:
23126:         perror("js");
23126:         break;
23126:       case 0:
23126:         (void) execvp(name, (char **)nargv);
23126:         perror("js");
23126:         exit(127);
23126:       default:
23126:         while (waitpid(pid, &status, 0) < 0 && errno == EINTR)
23126:             continue;
23126:         break;
23126:     }
23126:     JS_free(cx, nargv);
23126:     return JS_TRUE;
23126: }
23126: #endif
23126: 
23126: static JSBool
23126: global_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     return JS_EnumerateStandardClasses(cx, obj);
23126: #else
23126:     return JS_TRUE;
23126: #endif
23126: }
23126: 
23126: static JSBool
48470: global_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:                JSObject **objp)
23126: {
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     JSBool resolved;
23126: 
51110:     if (!ResolveClass(cx, obj, id, &resolved))
23126:         return JS_FALSE;
23126:     if (resolved) {
23126:         *objp = obj;
23126:         return JS_TRUE;
23126:     }
23126: #endif
23126: 
23126: #if defined(SHELL_HACK) && defined(DEBUG) && defined(XP_UNIX)
43210:     if (!(flags & JSRESOLVE_QUALIFIED)) {
23126:         /*
23126:          * Do this expensive hack only for unoptimized Unix builds, which are
23126:          * not used for benchmarking.
23126:          */
23126:         char *path, *comp, *full;
23126:         const char *name;
23126:         JSBool ok, found;
23126:         JSFunction *fun;
23126: 
23126:         if (!JSVAL_IS_STRING(id))
23126:             return JS_TRUE;
23126:         path = getenv("PATH");
23126:         if (!path)
23126:             return JS_TRUE;
23126:         path = JS_strdup(cx, path);
23126:         if (!path)
23126:             return JS_FALSE;
23126:         name = JS_GetStringBytes(JSVAL_TO_STRING(id));
23126:         ok = JS_TRUE;
23126:         for (comp = strtok(path, ":"); comp; comp = strtok(NULL, ":")) {
23126:             if (*comp != '\0') {
23126:                 full = JS_smprintf("%s/%s", comp, name);
23126:                 if (!full) {
23126:                     JS_ReportOutOfMemory(cx);
23126:                     ok = JS_FALSE;
23126:                     break;
23126:                 }
23126:             } else {
23126:                 full = (char *)name;
23126:             }
23126:             found = (access(full, X_OK) == 0);
23126:             if (*comp != '\0')
23126:                 free(full);
23126:             if (found) {
23126:                 fun = JS_DefineFunction(cx, obj, name, Exec, 0,
23126:                                         JSPROP_ENUMERATE);
23126:                 ok = (fun != NULL);
23126:                 if (ok)
23126:                     *objp = obj;
23126:                 break;
23126:             }
23126:         }
23126:         JS_free(cx, path);
23126:         return ok;
23126:     }
23126: #else
23126:     return JS_TRUE;
23126: #endif
23126: }
23126: 
23126: JSClass global_class = {
26666:     "global", JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS | JSCLASS_HAS_PRIVATE,
23126:     JS_PropertyStub,  JS_PropertyStub,
23126:     JS_PropertyStub,  JS_PropertyStub,
23126:     global_enumerate, (JSResolveOp) global_resolve,
26666:     JS_ConvertStub,   its_finalize,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
23126: static JSBool
48470: env_setProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
23126: /* XXX porting may be easy, but these don't seem to supply setenv by default */
23126: #if !defined XP_BEOS && !defined XP_OS2 && !defined SOLARIS
23126:     int rv;
23126: 
48470:     IdToString idstr(cx, id, JS_TRUE);
31366:     if (idstr.threw())
23126:         return JS_FALSE;
31366:     ToString valstr(cx, *vp, JS_TRUE);
31366:     if (valstr.threw())
31366:         return JS_FALSE;
23126: #if defined XP_WIN || defined HPUX || defined OSF1 || defined IRIX
23126:     {
31366:         char *waste = JS_smprintf("%s=%s", idstr.getBytes(), valstr.getBytes());
23126:         if (!waste) {
23126:             JS_ReportOutOfMemory(cx);
23126:             return JS_FALSE;
23126:         }
23126:         rv = putenv(waste);
23126: #ifdef XP_WIN
23126:         /*
23126:          * HPUX9 at least still has the bad old non-copying putenv.
23126:          *
23126:          * Per mail from <s.shanmuganathan@digital.com>, OSF1 also has a putenv
23126:          * that will crash if you pass it an auto char array (so it must place
23126:          * its argument directly in the char *environ[] array).
23126:          */
31366:         JS_smprintf_free(waste);
23126: #endif
23126:     }
23126: #else
31366:     rv = setenv(idstr.getBytes(), valstr.getBytes(), 1);
23126: #endif
23126:     if (rv < 0) {
31366:         JS_ReportError(cx, "can't set env variable %s to %s", idstr.getBytes(), valstr.getBytes());
23126:         return JS_FALSE;
23126:     }
31366:     *vp = valstr.getJSVal();
23126: #endif /* !defined XP_BEOS && !defined XP_OS2 && !defined SOLARIS */
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: env_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126:     static JSBool reflected;
23126:     char **evp, *name, *value;
23126:     JSString *valstr;
23126:     JSBool ok;
23126: 
23126:     if (reflected)
23126:         return JS_TRUE;
23126: 
23126:     for (evp = (char **)JS_GetPrivate(cx, obj); (name = *evp) != NULL; evp++) {
23126:         value = strchr(name, '=');
23126:         if (!value)
23126:             continue;
23126:         *value++ = '\0';
23126:         valstr = JS_NewStringCopyZ(cx, value);
23126:         if (!valstr) {
23126:             ok = JS_FALSE;
23126:         } else {
23126:             ok = JS_DefineProperty(cx, obj, name, STRING_TO_JSVAL(valstr),
23126:                                    NULL, NULL, JSPROP_ENUMERATE);
23126:         }
23126:         value[-1] = '=';
23126:         if (!ok)
23126:             return JS_FALSE;
23126:     }
23126: 
23126:     reflected = JS_TRUE;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: env_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
23126:             JSObject **objp)
23126: {
31366:     JSString *valstr;
23126:     const char *name, *value;
23126: 
23126:     if (flags & JSRESOLVE_ASSIGNING)
23126:         return JS_TRUE;
23126: 
48470:     IdToString idstr(cx, id, JS_TRUE);
31366:     if (idstr.threw())
23126:         return JS_FALSE;
31366: 
31366:     name = idstr.getBytes();
23126:     value = getenv(name);
23126:     if (value) {
23126:         valstr = JS_NewStringCopyZ(cx, value);
23126:         if (!valstr)
23126:             return JS_FALSE;
23126:         if (!JS_DefineProperty(cx, obj, name, STRING_TO_JSVAL(valstr),
23126:                                NULL, NULL, JSPROP_ENUMERATE)) {
23126:             return JS_FALSE;
23126:         }
23126:         *objp = obj;
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSClass env_class = {
23126:     "environment", JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE,
23126:     JS_PropertyStub,  JS_PropertyStub,
23126:     JS_PropertyStub,  env_setProperty,
23126:     env_enumerate, (JSResolveOp) env_resolve,
30654:     JS_ConvertStub,   NULL,
23126:     JSCLASS_NO_OPTIONAL_MEMBERS
23126: };
23126: 
40801: /*
40801:  * Avoid a reentrancy hazard.
40801:  *
40801:  * The non-JS_THREADSAFE shell uses a signal handler to implement timeout().
40801:  * The JS engine is not really reentrant, but JS_TriggerAllOperationCallbacks
40801:  * is mostly safe--the only danger is that we might interrupt JS_NewContext or
40801:  * JS_DestroyContext while the context list is being modified. Therefore we
40801:  * disable the signal handler around calls to those functions.
40801:  */
40801: #ifdef JS_THREADSAFE
40801: # define WITH_SIGNALS_DISABLED(x)  x
40801: #else
40801: # define WITH_SIGNALS_DISABLED(x)                                               \
40801:     JS_BEGIN_MACRO                                                              \
40801:         ScheduleWatchdog(gRuntime, -1);                                         \
40801:         x;                                                                      \
40801:         ScheduleWatchdog(gRuntime, gTimeoutInterval);                           \
40801:     JS_END_MACRO
40801: #endif
40801: 
40801: static JSContext *
40801: NewContext(JSRuntime *rt)
23126: {
40801:     JSContext *cx;
40801:     WITH_SIGNALS_DISABLED(cx = JS_NewContext(rt, gStackChunkSize));
40801:     if (!cx)
40801:         return NULL;
40801: 
40801:     JSShellContextData *data = NewContextData();
40801:     if (!data) {
40801:         DestroyContext(cx, false);
40801:         return NULL;
40801:     }
40801: 
23457:     JS_SetContextPrivate(cx, data);
23126:     JS_SetErrorReporter(cx, my_ErrorReporter);
23126:     JS_SetVersion(cx, JSVERSION_LATEST);
23126:     SetContextOptions(cx);
52557:     if (enableTraceJit)
33747:         JS_ToggleOptions(cx, JSOPTION_JIT);
52557:     if (enableMethodJit)
52557:         JS_ToggleOptions(cx, JSOPTION_METHODJIT);
40801:     return cx;
40801: }
40801: 
40801: static void
40801: DestroyContext(JSContext *cx, bool withGC)
40801: {
40801:     JSShellContextData *data = GetContextData(cx);
23457:     JS_SetContextPrivate(cx, NULL);
23457:     free(data);
40801:     WITH_SIGNALS_DISABLED(withGC ? JS_DestroyContext(cx) : JS_DestroyContextNoGC(cx));
40801: }
40801: 
40801: static JSObject *
54733: NewGlobalObject(JSContext *cx)
40801: {
47517:     JSObject *glob = JS_NewCompartmentAndGlobalObject(cx, &global_class, NULL);
47498:     if (!glob)
47498:         return NULL;
54733: 
54733:     JSAutoEnterCompartment ac;
54733:     if (!ac.enter(cx, glob))
47498:         return NULL;
47498: 
40801: #ifdef LAZY_STANDARD_CLASSES
40801:     JS_SetGlobalObject(cx, glob);
40801: #else
40801:     if (!JS_InitStandardClasses(cx, glob))
47517:         return NULL;
40801: #endif
40801: #ifdef JS_HAS_CTYPES
40801:     if (!JS_InitCTypesClass(cx, glob))
47517:         return NULL;
40801: #endif
48637:     if (!JS::RegisterPerfMeasurement(cx, glob))
48637:         return NULL;
40801:     if (!JS_DefineFunctions(cx, glob, shell_functions))
47517:         return NULL;
47517: 
40801:     JSObject *it = JS_DefineObject(cx, glob, "it", &its_class, NULL, 0);
40801:     if (!it)
47517:         return NULL;
40801:     if (!JS_DefineProperties(cx, it, its_props))
47517:         return NULL;
40801:     if (!JS_DefineFunctions(cx, it, its_methods))
47517:         return NULL;
40801: 
40801:     if (!JS_DefineProperty(cx, glob, "custom", JSVAL_VOID, its_getter,
40801:                            its_setter, 0))
47517:         return NULL;
40801:     if (!JS_DefineProperty(cx, glob, "customRdOnly", JSVAL_VOID, its_getter,
40801:                            its_setter, JSPROP_READONLY))
47517:         return NULL;
40801: 
47498:     return glob;
40801: }
23126: 
23126: int
55710: Shell(JSContext *cx, int argc, char **argv, char **envp)
23126: {
47504:     JSAutoRequest ar(cx);
54733: 
54733:     JSObject *glob = NewGlobalObject(cx);
23126:     if (!glob)
23126:         return 1;
40801: 
54733:     JSAutoEnterCompartment ac;
54733:     if (!ac.enter(cx, glob))
54733:         return 1;
54733: 
40801:     JSObject *envobj = JS_DefineObject(cx, glob, "environment", &env_class, NULL, 0);
40801:     if (!envobj || !JS_SetPrivate(cx, envobj, envp))
47504:         return 1;
26666: 
23126: #ifdef JSDEBUGGER
23126:     /*
23126:     * XXX A command line option to enable debugging (or not) would be good
23126:     */
23126:     jsdc = JSD_DebuggerOnForUser(rt, NULL, NULL);
23126:     if (!jsdc)
47504:         return 1;
23126:     JSD_JSContextInUse(jsdc, cx);
23126: #ifdef JSD_LOWLEVEL_SOURCE
23126:     JS_SetSourceHandler(rt, SendSourceToJSDebugger, jsdc);
23126: #endif /* JSD_LOWLEVEL_SOURCE */
23126: #ifdef JSDEBUGGER_JAVA_UI
23126:     jsdjc = JSDJ_CreateContext();
23126:     if (! jsdjc)
47504:         return 1;
23126:     JSDJ_SetJSDContext(jsdjc, jsdc);
23126:     java_env = JSDJ_CreateJavaVMAndStartDebugger(jsdjc);
23126:     /*
23126:     * XXX This would be the place to wait for the debugger to start.
23126:     * Waiting would be nice in general, but especially when a js file
23126:     * is passed on the cmd line.
23126:     */
23126: #endif /* JSDEBUGGER_JAVA_UI */
23126: #ifdef JSDEBUGGER_C_UI
23126:     jsdbc = JSDB_InitDebugger(rt, jsdc, 0);
23126: #endif /* JSDEBUGGER_C_UI */
23126: #endif /* JSDEBUGGER */
23126: 
40801: #ifdef JS_THREADSAFE
40801:     class ShellWorkerHooks : public js::workers::WorkerHooks {
40801:     public:
47517:         JSObject *newGlobalObject(JSContext *cx) {
54733:             return NewGlobalObject(cx);
47517:         }
40801:     };
40801:     ShellWorkerHooks hooks;
47403:     if (!JS_AddNamedObjectRoot(cx, &gWorkers, "Workers") ||
55619:         (gWorkerThreadPool = js::workers::init(cx, &hooks, glob, &gWorkers)) == NULL) {
47504:         return 1;
23126:     }
23126: #endif
23126: 
47504:     int result = ProcessArgs(cx, glob, argv, argc);
23126: 
40801: #ifdef JS_THREADSAFE
55619:     js::workers::finish(cx, gWorkerThreadPool);
47403:     JS_RemoveObjectRoot(cx, &gWorkers);
40801:     if (result == 0)
40801:         result = gExitCode;
40801: #endif
40801: 
23126: #ifdef JSDEBUGGER
23126:     if (jsdc) {
23126: #ifdef JSDEBUGGER_C_UI
23126:         if (jsdbc)
23126:             JSDB_TermDebugger(jsdc);
23126: #endif /* JSDEBUGGER_C_UI */
23126:         JSD_DebuggerOff(jsdc);
23126:     }
23126: #endif  /* JSDEBUGGER */
23126: 
43286:     return result;
43286: }
43286: 
55469: static void
55469: MaybeOverrideOutFileFromEnv(const char* const envVar,
55469:                             FILE* defaultOut,
55469:                             FILE** outFile)
55469: {
55474:     const char* outPath = getenv(envVar);
55469:     if (!outPath || !*outPath || !(*outFile = fopen(outPath, "w"))) {
55469:         *outFile = defaultOut;
55469:     }
55469: }
55469: 
43286: int
43286: main(int argc, char **argv, char **envp)
43286: {
43286:     int stackDummy;
43286:     JSRuntime *rt;
43286:     JSContext *cx;
43286:     int result;
43286: #ifdef JSDEBUGGER
43286:     JSDContext *jsdc;
43286: #ifdef JSDEBUGGER_JAVA_UI
43286:     JNIEnv *java_env;
43286:     JSDJContext *jsdjc;
43286: #endif
43286: #ifdef JSDEBUGGER_C_UI
43286:     JSBool jsdbc;
43286: #endif /* JSDEBUGGER_C_UI */
43286: #endif /* JSDEBUGGER */
52897: #ifdef XP_WIN
53132:     {
53132:         const char *crash_option = getenv("XRE_NO_WINDOWS_CRASH_DIALOG");
53132:         if (crash_option && strncmp(crash_option, "1", 1)) {
52897:             DWORD oldmode = SetErrorMode(SEM_NOGPFAULTERRORBOX);
52897:             SetErrorMode(oldmode | SEM_NOGPFAULTERRORBOX);
53132:         }
53132:     }
52897: #endif
43286: 
43286:     CheckHelpMessages();
43286: #ifdef HAVE_SETLOCALE
43286:     setlocale(LC_ALL, "");
43286: #endif
43286: 
43286: #ifdef JS_THREADSAFE
43286:     if (PR_FAILURE == PR_NewThreadPrivateIndex(&gStackBaseThreadIndex, NULL) ||
43286:         PR_FAILURE == PR_SetThreadPrivate(gStackBaseThreadIndex, &stackDummy)) {
43286:         return 1;
43286:     }
43286: #else
43286:     gStackBase = (jsuword) &stackDummy;
43286: #endif
43286: 
43286: #ifdef XP_OS2
43286:    /* these streams are normally line buffered on OS/2 and need a \n, *
43286:     * so we need to unbuffer then to get a reasonable prompt          */
43286:     setbuf(stdout,0);
43286:     setbuf(stderr,0);
43286: #endif
43286: 
55469:     MaybeOverrideOutFileFromEnv("JS_STDERR", stderr, &gErrFile);
55469:     MaybeOverrideOutFileFromEnv("JS_STDOUT", stdout, &gOutFile);
43286: 
43286:     argc--;
43286:     argv++;
43286: 
43286: #ifdef XP_WIN
43286:     // Set the timer calibration delay count to 0 so we get high
43286:     // resolution right away, which we need for precise benchmarking.
43286:     extern int CALIBRATION_DELAY_COUNT;
43286:     CALIBRATION_DELAY_COUNT = 0;
43286: #endif
43286: 
55746:     rt = JS_NewRuntime(160L * 1024L * 1024L);
43286:     if (!rt)
43286:         return 1;
43286: 
43286:     if (!InitWatchdog(rt))
43286:         return 1;
43286: 
43286:     cx = NewContext(rt);
43286:     if (!cx)
43286:         return 1;
43286: 
56476:     JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_ANONFUNFIX | JSOPTION_ROPES);
43286:     JS_SetGCParameterForThread(cx, JSGC_MAX_CODE_CACHE_BYTES, 16 * 1024 * 1024);
43286: 
55710:     result = Shell(cx, argc, argv, envp);
43286: 
40801:     DestroyContext(cx, true);
25087: 
25472:     KillWatchdog();
23726: 
23126:     JS_DestroyRuntime(rt);
23126:     JS_ShutDown();
23126:     return result;
23126: }
