42474: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42474:  * ***** BEGIN LICENSE BLOCK *****
42474:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42474:  *
42474:  * The contents of this file are subject to the Mozilla Public License Version
42474:  * 1.1 (the "License"); you may not use this file except in compliance with
42474:  * the License. You may obtain a copy of the License at
42474:  * http://www.mozilla.org/MPL/
42474:  *
42474:  * Software distributed under the License is distributed on an "AS IS" basis,
42474:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42474:  * for the specific language governing rights and limitations under the
42474:  * License.
42474:  *
42474:  * The Initial Developer of the Original Code is Mozilla Foundation.
42474:  * Portions created by the Initial Developer are Copyright (C) 2010
42474:  * the Initial Developer. All Rights Reserved.
42474:  *
42474:  * Contributor(s):
42474:  *   Benoit Jacob <bjacob@mozilla.com>
42474:  *   Bas Schouten <bschouten@mozilla.com>
42474:  *   Vladimir Vukicevic <vladimir@pobox.com>
42474:  *
42474:  * Alternatively, the contents of this file may be used under the terms of
42474:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42474:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42474:  * in which case the provisions of the GPL or the LGPL are applicable instead
42474:  * of those above. If you wish to allow use of your version of this file only
42474:  * under the terms of either the GPL or the LGPL, and not to allow others to
42474:  * use your version of this file under the terms of the MPL, indicate your
42474:  * decision by deleting the provisions above and replace them with the notice
42474:  * and other provisions required by the GPL or the LGPL. If you do not delete
42474:  * the provisions above, a recipient may use your version of this file under
42474:  * the terms of any one of the MPL, the GPL or the LGPL.
42474:  *
42474:  * ***** END LICENSE BLOCK ***** */
42474: 
42474: #include "GLContextProvider.h"
42474: #include "GLContext.h"
93376: #include "GLLibraryLoader.h"
42474: #include "nsDebug.h"
42474: #include "nsString.h"
42474: #include "nsIWidget.h"
42474: #include "nsDirectoryServiceUtils.h"
42474: #include "nsAppDirectoryServiceDefs.h"
43595: #include "nsIConsoleService.h"
71640: #include "mozilla/Preferences.h"
42474: #include "gfxASurface.h"
42474: #include "gfxImageSurface.h"
42474: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
42474: // from GL/osmesa.h. We don't include that file so as to avoid having a build-time dependency on OSMesa.
42474: #define OSMESA_RGBA     GL_RGBA
42474: #define OSMESA_BGRA     0x1
42474: #define OSMESA_ARGB     0x2
42474: #define OSMESA_RGB      GL_RGB
42474: #define OSMESA_BGR      0x4
42474: #define OSMESA_RGB_565  0x5
42474: #define OSMESA_Y_UP     0x11
42474: 
42474: namespace mozilla {
42474: namespace gl {
42474: 
43595: static void LogMessage(const char *msg)
43595: {
43595:   nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
43595:   if (console) {
43595:     console->LogStringMessage(NS_ConvertUTF8toUTF16(nsDependentCString(msg)).get());
43595:     fprintf(stderr, "%s\n", msg);
43595:   }
43595: }
43595: 
42474: typedef void* PrivateOSMesaContext;
42474: 
42474: class OSMesaLibrary
42474: {
42474: public:
80486:     OSMesaLibrary() : mInitialized(false), mOSMesaLibrary(nsnull) {}
42474: 
42474:     typedef PrivateOSMesaContext (GLAPIENTRY * PFNOSMESACREATECONTEXTEXT) (GLenum, GLint, GLint, GLint, PrivateOSMesaContext);
42474:     typedef void (GLAPIENTRY * PFNOSMESADESTROYCONTEXT) (PrivateOSMesaContext);
42474:     typedef bool (GLAPIENTRY * PFNOSMESAMAKECURRENT) (PrivateOSMesaContext, void *, GLenum, GLsizei, GLsizei);
42474:     typedef PrivateOSMesaContext (GLAPIENTRY * PFNOSMESAGETCURRENTCONTEXT) (void);
42474:     typedef void (GLAPIENTRY * PFNOSMESAPIXELSTORE) (GLint, GLint);
42474:     typedef PRFuncPtr (GLAPIENTRY * PFNOSMESAGETPROCADDRESS) (const char*);
42474: 
42474:     PFNOSMESACREATECONTEXTEXT fCreateContextExt;
42474:     PFNOSMESADESTROYCONTEXT fDestroyContext;
42474:     PFNOSMESAMAKECURRENT fMakeCurrent;
42474:     PFNOSMESAGETCURRENTCONTEXT fGetCurrentContext;
42474:     PFNOSMESAPIXELSTORE fPixelStore;
42474:     PFNOSMESAGETPROCADDRESS fGetProcAddress;
42474: 
79445:     bool EnsureInitialized();
42474: 
42474: private:
79445:     bool mInitialized;
42474:     PRLibrary *mOSMesaLibrary;
42474: };
42474: 
42474: OSMesaLibrary sOSMesaLibrary;
42474: 
79445: bool
42474: OSMesaLibrary::EnsureInitialized()
42474: {
42474:     if (mInitialized)
80486:         return true;
42474: 
71640:     nsAdoptingCString osmesalib = Preferences::GetCString("webgl.osmesalib");
71640:     if (osmesalib.IsEmpty()) {
80486:         return false;
42474:     }
42474: 
42474:     mOSMesaLibrary = PR_LoadLibrary(osmesalib.get());
42474: 
42474:     if (!mOSMesaLibrary) {
43595:         LogMessage("Couldn't open OSMesa lib for software rendering -- webgl.osmesalib path is incorrect, or not a valid shared library");
80486:         return false;
42474:     }
42474: 
93376:     GLLibraryLoader::SymLoadStruct symbols[] = {
42474:         { (PRFuncPtr*) &fCreateContextExt, { "OSMesaCreateContextExt", NULL } },
42474:         { (PRFuncPtr*) &fMakeCurrent, { "OSMesaMakeCurrent", NULL } },
42474:         { (PRFuncPtr*) &fPixelStore, { "OSMesaPixelStore", NULL } },
42474:         { (PRFuncPtr*) &fDestroyContext, { "OSMesaDestroyContext", NULL } },
42474:         { (PRFuncPtr*) &fGetCurrentContext, { "OSMesaGetCurrentContext", NULL } },
42474:         { (PRFuncPtr*) &fMakeCurrent, { "OSMesaMakeCurrent", NULL } },
42474:         { (PRFuncPtr*) &fGetProcAddress, { "OSMesaGetProcAddress", NULL } },
42474:         { NULL, { NULL } }
42474:     };
42474: 
93376:     if (!GLLibraryLoader::LoadSymbols(mOSMesaLibrary, &symbols[0])) {
43595:         LogMessage("Couldn't find required entry points in OSMesa libary");
80486:         return false;
42474:     }
42474: 
80486:     mInitialized = true;
80486:     return true;
42474: }
42474: 
42474: class GLContextOSMesa : public GLContext
42474: {
42474: public:
47908:     GLContextOSMesa(const ContextFormat& aFormat)
80486:         : GLContext(aFormat, true, nsnull),
47908:           mThebesSurface(nsnull),
42474:           mContext(nsnull)
42474:     {
42474:     }
42474: 
42474:     ~GLContextOSMesa()
42474:     {
54505:         MarkDestroyed();
54505: 
42474:         if (mContext)
42474:             sOSMesaLibrary.fDestroyContext(mContext);
42474:     }
42474: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeOSMesa;
47908:     }
47908: 
79445:     bool Init(const gfxIntSize &aSize)
42474:     {
42474:         int osmesa_format = -1;
42474:         int gfxasurface_imageformat = -1;
79445:         bool format_accepted = false;
42474: 
47908:         if (mCreationFormat.red > 0 &&
47908:             mCreationFormat.green > 0 &&
47908:             mCreationFormat.blue > 0 &&
47908:             mCreationFormat.red <= 8 &&
47908:             mCreationFormat.green <= 8 &&
47908:             mCreationFormat.blue <= 8)
47908:         {
47908:             if (mCreationFormat.alpha == 0) {
42474:                 // we can't use OSMESA_BGR because it is packed 24 bits per pixel.
42474:                 // So we use OSMESA_BGRA and have to use ImageFormatRGB24
42474:                 // to make sure that the dummy alpha channel is ignored.
42474:                 osmesa_format = OSMESA_BGRA;
42474:                 gfxasurface_imageformat = gfxASurface::ImageFormatRGB24;
80486:                 format_accepted = true;
47908:             } else if (mCreationFormat.alpha <= 8) {
47908:                 osmesa_format = OSMESA_BGRA;
47908:                 gfxasurface_imageformat = gfxASurface::ImageFormatARGB32;
80486:                 format_accepted = true;
42474:             }
42474:         }
42474:         if (!format_accepted) {
42474:             NS_WARNING("Pixel format not supported with OSMesa.");
80486:             return false;
42474:         }
42474: 
42474:         mThebesSurface = new gfxImageSurface(aSize, gfxASurface::gfxImageFormat(gfxasurface_imageformat));
42474:         if (mThebesSurface->CairoStatus() != 0) {
42474:             NS_WARNING("image surface failed");
80486:             return false;
42474:         }
42474: 
47908:         mContext = sOSMesaLibrary.fCreateContextExt(osmesa_format, mCreationFormat.depth, mCreationFormat.stencil, 0, NULL);
42474:         if (!mContext) {
42474:             NS_WARNING("OSMesaCreateContextExt failed!");
80486:             return false;
42474:         }
42474: 
80486:         if (!MakeCurrent()) return false;
80486:         if (!SetupLookupFunction()) return false;
42586: 
42586:         // OSMesa's different from the other GL providers, it renders to an image surface, not to a pbuffer
42586:         sOSMesaLibrary.fPixelStore(OSMESA_Y_UP, 0);
42586: 
80486:         return InitWithPrefix("gl", true);
42474:     }
42474: 
98361:     bool MakeCurrentImpl(bool aForce = false)
42474:     {
79445:         bool succeeded
42474:           = sOSMesaLibrary.fMakeCurrent(mContext, mThebesSurface->Data(),
42474:                                         LOCAL_GL_UNSIGNED_BYTE,
42474:                                         mThebesSurface->Width(),
42474:                                         mThebesSurface->Height());
42474:         NS_ASSERTION(succeeded, "Failed to make OSMesa context current!");
42474: 
42474:         return succeeded;
42474:     }
42474: 
79445:     bool SetupLookupFunction()
42474:     {
42474:         mLookupFunc = (PlatformLookupFunction)sOSMesaLibrary.fGetProcAddress;
80486:         return true;
42474:     }
42474: 
42474:     void *GetNativeData(NativeDataType aType)
42474:     {
42474:         switch (aType) {
42474:         case NativeImageSurface:
42474:             return mThebesSurface.get();
42474:         default:
42474:             return nsnull;
42474:         }
42474:     }
42474: 
82479:     bool SupportsRobustness()
82479:     {
82479:         return false;
82479:     }
82479: 
42474: private:
42474:     nsRefPtr<gfxImageSurface> mThebesSurface;
42474:     PrivateOSMesaContext mContext;
42474: };
42474: 
42474: already_AddRefed<GLContext>
42474: GLContextProviderOSMesa::CreateForWindow(nsIWidget *aWidget)
42474: {
42474:     return nsnull;
42474: }
42474: 
42474: already_AddRefed<GLContext>
47908: GLContextProviderOSMesa::CreateOffscreen(const gfxIntSize& aSize,
93720:                                          const ContextFormat& aFormat,
93720:                                          const ContextFlags)
42474: {
42474:     if (!sOSMesaLibrary.EnsureInitialized()) {
42474:         return nsnull;
42474:     }
42474: 
80615:     ContextFormat actualFormat(aFormat);
80615:     actualFormat.samples = 0;
80615: 
80615:     nsRefPtr<GLContextOSMesa> glContext = new GLContextOSMesa(actualFormat);
42474: 
47908:     if (!glContext->Init(aSize))
47908:     {
42474:         return nsnull;
42474:     }
42474: 
47908:     return glContext.forget();
47908: }
47908: 
47908: GLContext *
47908: GLContextProviderOSMesa::GetGlobalContext()
47908: {
47908:     return nsnull;
42474: }
42474: 
47967: void
47967: GLContextProviderOSMesa::Shutdown()
47967: {
47967: }
47967: 
42474: } /* namespace gl */
42474: } /* namespace mozilla */
