 6224: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 6224: /* ***** BEGIN LICENSE BLOCK *****
 6224:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 6224:  *
 6224:  * The contents of this file are subject to the Mozilla Public License Version
 6224:  * 1.1 (the "License"); you may not use this file except in compliance with
 6224:  * the License. You may obtain a copy of the License at
 6224:  * http://www.mozilla.org/MPL/
 6224:  *
 6224:  * Software distributed under the License is distributed on an "AS IS" basis,
 6224:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 6224:  * for the specific language governing rights and limitations under the
 6224:  * License.
 6224:  *
 6224:  * The Original Code is mozilla.org code.
 6224:  *
 6224:  * The Initial Developer of the Original Code is
 6224:  * Netscape Communications Corporation.
 6224:  * Portions created by the Initial Developer are Copyright (C) 1998
 6224:  * the Initial Developer. All Rights Reserved.
 6224:  *
 6224:  * Contributor(s):
 6224:  *   Robert O'Callahan <robert@ocallahan.org>
 6224:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
 6224:  *   Pierre Phaneuf <pp@ludusdesign.com>
 6224:  *   Prabhat Hegde <prabhat.hegde@sun.com>
 6224:  *   Tomi Leppikangas <tomi.leppikangas@oulu.fi>
 6224:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
 6224:  *   Daniel Glazman <glazman@netscape.com>
 6224:  *   Neil Deakin <neil@mozdevgroup.com>
 6224:  *   Masayuki Nakano <masayuki@d-toybox.com>
55835:  *   Mats Palmgren <matspal@gmail.com>
 6224:  *   Uri Bernstein <uriber@gmail.com>
 6224:  *   Stephen Blackheath <entangled.mooched.stephen@blacksapphire.com>
 6224:  *
 6224:  * Alternatively, the contents of this file may be used under the terms of
 6224:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 6224:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 6224:  * in which case the provisions of the GPL or the LGPL are applicable instead
 6224:  * of those above. If you wish to allow use of your version of this file only
 6224:  * under the terms of either the GPL or the LGPL, and not to allow others to
 6224:  * use your version of this file under the terms of the MPL, indicate your
 6224:  * decision by deleting the provisions above and replace them with the notice
 6224:  * and other provisions required by the GPL or the LGPL. If you do not delete
 6224:  * the provisions above, a recipient may use your version of this file under
 6224:  * the terms of any one of the MPL, the GPL or the LGPL.
 6224:  *
 6224:  * ***** END LICENSE BLOCK ***** */
 6224: 
 6224: #ifndef nsTextFrame_h__
 6224: #define nsTextFrame_h__
 6224: 
 6224: #include "nsFrame.h"
32106: #include "nsSplittableFrame.h"
 6224: #include "nsLineBox.h"
 6224: #include "gfxFont.h"
 6224: #include "gfxSkipChars.h"
15339: #include "gfxContext.h"
 6224: 
 6224: class nsTextPaintStyle;
 6224: class PropertyProvider;
 6224: 
11711: // This state bit is set on frames that have some non-collapsed characters after
11711: // reflow
43376: #define TEXT_HAS_NONCOLLAPSED_CHARACTERS NS_FRAME_STATE_BIT(31)
11711: 
 6224: class nsTextFrame : public nsFrame {
 6224: public:
32423:   NS_DECL_FRAMEARENA_HELPERS
32423: 
 9810:   friend class nsContinuingTextFrame;
 9810: 
 6224:   nsTextFrame(nsStyleContext* aContext) : nsFrame(aContext)
 6224:   {
 6224:     NS_ASSERTION(mContentOffset == 0, "Bogus content offset");
 6224:   }
 6224:   
 6224:   // nsIFrame
 6224:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
 6224:                               const nsRect&           aDirtyRect,
 6224:                               const nsDisplayListSet& aLists);
 6224: 
 6224:   NS_IMETHOD Init(nsIContent*      aContent,
 6224:                   nsIFrame*        aParent,
 6224:                   nsIFrame*        aPrevInFlow);
 6224: 
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
 6224:   
 6224:   NS_IMETHOD GetCursor(const nsPoint& aPoint,
 6224:                        nsIFrame::Cursor& aCursor);
 6224:   
31131:   NS_IMETHOD CharacterDataChanged(CharacterDataChangeInfo* aInfo);
 6224:                                   
20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
 6224:   
 6224:   virtual nsIFrame* GetNextContinuation() const {
 6224:     return mNextContinuation;
 6224:   }
 6224:   NS_IMETHOD SetNextContinuation(nsIFrame* aNextContinuation) {
 6224:     NS_ASSERTION (!aNextContinuation || GetType() == aNextContinuation->GetType(),
 6224:                   "setting a next continuation with incorrect type!");
 6224:     NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextContinuation, this),
 6224:                   "creating a loop in continuation chain!");
 6224:     mNextContinuation = aNextContinuation;
 6224:     if (aNextContinuation)
 6224:       aNextContinuation->RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
 6224:     return NS_OK;
 6224:   }
 6224:   virtual nsIFrame* GetNextInFlowVirtual() const { return GetNextInFlow(); }
 6224:   nsIFrame* GetNextInFlow() const {
 6224:     return mNextContinuation && (mNextContinuation->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? 
 6224:       mNextContinuation : nsnull;
 6224:   }
 6224:   NS_IMETHOD SetNextInFlow(nsIFrame* aNextInFlow) {
 6224:     NS_ASSERTION (!aNextInFlow || GetType() == aNextInFlow->GetType(),
 6224:                   "setting a next in flow with incorrect type!");
 6224:     NS_ASSERTION (!nsSplittableFrame::IsInNextContinuationChain(aNextInFlow, this),
 6224:                   "creating a loop in continuation chain!");
 6224:     mNextContinuation = aNextInFlow;
 6224:     if (aNextInFlow)
 6224:       aNextInFlow->AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
 6224:     return NS_OK;
 6224:   }
 6224:   virtual nsIFrame* GetLastInFlow() const;
 6224:   virtual nsIFrame* GetLastContinuation() const;
 6224:   
 6224:   virtual nsSplittableType GetSplittableType() const {
 6224:     return NS_FRAME_SPLITTABLE;
 6224:   }
 6224:   
 6224:   /**
 6224:     * Get the "type" of the frame
 6224:    *
 6224:    * @see nsGkAtoms::textFrame
 6224:    */
 6224:   virtual nsIAtom* GetType() const;
 6224:   
 6224:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
 6224:   {
 6224:     // Set the frame state bit for text frames to mark them as replaced.
 6224:     // XXX kipp: temporary
 6224:     return nsFrame::IsFrameOfType(aFlags & ~(nsIFrame::eReplaced |
 6224:                                              nsIFrame::eLineParticipant));
 6224:   }
 6224: 
 6224: #ifdef DEBUG
 6224:   NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;
 6224:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
 6224:   NS_IMETHOD_(nsFrameState) GetDebugStateBits() const ;
 6224: #endif
 6224:   
 6224:   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
28352:   ContentOffsets GetCharacterOffsetAtFramePoint(const nsPoint &aPoint);
 6224: 
30695:   /**
30695:    * This is called only on the primary text frame. It indicates that
30695:    * the selection state of the given character range has changed.
30695:    * Text in the range is unconditionally invalidated
30695:    * (nsTypedSelection::Repaint depends on this).
30695:    * @param aSelected true if the selection has been added to the range,
30695:    * false otherwise
30695:    * @param aType the type of selection added or removed
30695:    */
30695:   virtual void SetSelected(PRBool        aSelected,
30695:                            SelectionType aType);
30695:   void SetSelectedRange(PRUint32 aStart,
30695:                         PRUint32 aEnd,
 6224:                         PRBool aSelected,
18931:                         SelectionType aType);
 6224: 
 6224:   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);
59604:   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset,
59604:                                      PRBool aRespectClusters = PR_TRUE);
 6224:   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
 6224:                                 PRInt32* aOffset, PeekWordState* aState);
 6224: 
 6224:   NS_IMETHOD CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);
 6224:   
62893:   // Flags for aSetLengthFlags
62893:   enum { ALLOW_FRAME_CREATION_AND_DESTRUCTION = 0x01 };
62893: 
 6224:   // Update offsets to account for new length. This may clear mTextRun.
62893:   void SetLength(PRInt32 aLength, nsLineLayout* aLineLayout,
62893:                  PRUint32 aSetLengthFlags = 0);
 6224:   
 6224:   NS_IMETHOD GetOffsets(PRInt32 &start, PRInt32 &end)const;
 6224:   
 6224:   virtual void AdjustOffsetsForBidi(PRInt32 start, PRInt32 end);
 6224:   
 6224:   NS_IMETHOD GetPointFromOffset(PRInt32                 inOffset,
 6224:                                 nsPoint*                outPoint);
 6224:   
 6224:   NS_IMETHOD  GetChildFrameContainingOffset(PRInt32     inContentOffset,
 6224:                                             PRBool                  inHint,
 6224:                                             PRInt32*                outFrameContentOffset,
 6224:                                             nsIFrame*               *outChildFrame);
 6224:   
 6224:   virtual PRBool IsVisibleInSelection(nsISelection* aSelection);
 6224:   
 6224:   virtual PRBool IsEmpty();
 6224:   virtual PRBool IsSelfEmpty() { return IsEmpty(); }
56866:   virtual nscoord GetBaseline() const;
 6224:   
 6224:   /**
 6224:    * @return PR_TRUE if this text frame ends with a newline character.  It
 6224:    * should return PR_FALSE if this is not a text frame.
 6224:    */
 6224:   virtual PRBool HasTerminalNewline() const;
 6224: 
 7677:   /**
 7677:    * Returns true if this text frame is logically adjacent to the end of the
 7677:    * line.
 7677:    */
 7677:   PRBool IsAtEndOfLine() const;
 7677:   
11711:   /**
11711:    * Call this only after reflow the frame. Returns true if non-collapsed
11711:    * characters are present.
11711:    */
11711:   PRBool HasNoncollapsedCharacters() const {
11711:     return (GetStateBits() & TEXT_HAS_NONCOLLAPSED_CHARACTERS) != 0;
11711:   }
11711:   
 6224: #ifdef ACCESSIBILITY
46338:   virtual already_AddRefed<nsAccessible> CreateAccessible();
 6224: #endif
 6224:   
 6224:   virtual void MarkIntrinsicWidthsDirty();
 6224:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
 6224:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
 6224:   virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
 6224:                                  InlineMinWidthData *aData);
 6224:   virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
 6224:                                   InlinePrefWidthData *aData);
 6224:   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
 6224:                              nsSize aCBSize, nscoord aAvailableWidth,
 6224:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
 6224:                              PRBool aShrinkWrap);
 6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
 6224:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
 6224:                     nsHTMLReflowMetrics& aMetrics,
 6224:                     const nsHTMLReflowState& aReflowState,
 6224:                     nsReflowStatus& aStatus);
 6224:   virtual PRBool CanContinueTextRun() const;
 8514:   // Method that is called for a text frame that is logically
 8514:   // adjacent to the end of the line (i.e. followed only by empty text frames,
 8514:   // placeholders or inlines containing such).
 8514:   struct TrimOutput {
 8514:     // true if we trimmed some space or changed metrics in some other way.
55028:     // In this case, we should call RecomputeOverflow on this frame.
 8514:     PRPackedBool mChanged;
 8514:     // true if the last character is not justifiable so should be subtracted
 8514:     // from the count of justifiable characters in the frame, since the last
 8514:     // character in a line is not justifiable.
 8514:     PRPackedBool mLastCharIsJustifiable;
 8514:     // an amount to *subtract* from the frame's width (zero if !mChanged)
 8514:     nscoord      mDeltaWidth;
 8514:   };
 8514:   TrimOutput TrimTrailingWhiteSpace(nsIRenderingContext* aRC);
 6224:   virtual nsresult GetRenderedText(nsAString* aString = nsnull,
 6224:                                    gfxSkipChars* aSkipChars = nsnull,
 6224:                                    gfxSkipCharsIterator* aSkipIter = nsnull,
 6224:                                    PRUint32 aSkippedStartOffset = 0,
 6224:                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX);
 6224: 
55028:   nsOverflowAreas RecomputeOverflow();
 6224: 
 6224:   void AddInlineMinWidthForFlow(nsIRenderingContext *aRenderingContext,
 6224:                                 nsIFrame::InlineMinWidthData *aData);
 6224:   void AddInlinePrefWidthForFlow(nsIRenderingContext *aRenderingContext,
 6224:                                  InlinePrefWidthData *aData);
 6224: 
 6224:   gfxFloat GetSnappedBaselineY(gfxContext* aContext, gfxFloat aY);
 6224: 
 6224:   // primary frame paint method called from nsDisplayText
15339:   // The private DrawText() is what applies the text to a graphics context
 6224:   void PaintText(nsIRenderingContext* aRenderingContext, nsPoint aPt,
 6224:                  const nsRect& aDirtyRect);
 6224:   // helper: paint quirks-mode CSS text decorations
 6224:   void PaintTextDecorations(gfxContext* aCtx, const gfxRect& aDirtyRect,
 6224:                             const gfxPoint& aFramePt,
 6224:                             const gfxPoint& aTextBaselinePt,
 6224:                             nsTextPaintStyle& aTextStyle,
15339:                             PropertyProvider& aProvider,
19961:                             const nscolor* aOverrideColor = nsnull);
 6224:   // helper: paint text frame when we're impacted by at least one selection.
 6224:   // Return PR_FALSE if the text was not painted and we should continue with
 6224:   // the fast path.
 6224:   PRBool PaintTextWithSelection(gfxContext* aCtx,
 6224:                                 const gfxPoint& aFramePt,
 6224:                                 const gfxPoint& aTextBaselinePt,
 6224:                                 const gfxRect& aDirtyRect,
 6224:                                 PropertyProvider& aProvider,
 6224:                                 nsTextPaintStyle& aTextPaintStyle);
 6224:   // helper: paint text with foreground and background colors determined
 6224:   // by selection(s). Also computes a mask of all selection types applying to
 6224:   // our text, returned in aAllTypes.
 6224:   void PaintTextWithSelectionColors(gfxContext* aCtx,
 6224:                                     const gfxPoint& aFramePt,
 6224:                                     const gfxPoint& aTextBaselinePt,
 6224:                                     const gfxRect& aDirtyRect,
 6224:                                     PropertyProvider& aProvider,
 6224:                                     nsTextPaintStyle& aTextPaintStyle,
 6224:                                     SelectionDetails* aDetails,
 6224:                                     SelectionType* aAllTypes);
 6224:   // helper: paint text decorations for text selected by aSelectionType
 6224:   void PaintTextSelectionDecorations(gfxContext* aCtx,
 6224:                                      const gfxPoint& aFramePt,
 6224:                                      const gfxPoint& aTextBaselinePt,
 6224:                                      const gfxRect& aDirtyRect,
 6224:                                      PropertyProvider& aProvider,
 6224:                                      nsTextPaintStyle& aTextPaintStyle,
 6224:                                      SelectionDetails* aDetails,
 6224:                                      SelectionType aSelectionType);
 6224: 
40078:   virtual nscolor GetCaretColorAt(PRInt32 aOffset);
40078: 
 6224:   PRInt16 GetSelectionStatus(PRInt16* aSelectionFlags);
 6224: 
 6224: #ifdef DEBUG
 8253:   void ToCString(nsCString& aBuf, PRInt32* aTotalContentLength) const;
 6224: #endif
 6224: 
 6224:   PRInt32 GetContentOffset() const { return mContentOffset; }
 9810:   PRInt32 GetContentLength() const
 9810:   {
 9810:     NS_ASSERTION(GetContentEnd() - mContentOffset >= 0, "negative length");
 9810:     return GetContentEnd() - mContentOffset;
 9810:   }
 6224:   PRInt32 GetContentEnd() const;
 6224:   // This returns the length the frame thinks it *should* have after it was
 6224:   // last reflowed (0 if it hasn't been reflowed yet). This should be used only
 6224:   // when setting up the text offsets for a new continuation frame.
 6224:   PRInt32 GetContentLengthHint() const { return mContentLengthHint; }
 6224: 
 6224:   // Compute the length of the content mapped by this frame
 6224:   // and all its in-flow siblings. Basically this means starting at mContentOffset
 6224:   // and going to the end of the text node or the next bidi continuation
 6224:   // boundary.
 6224:   PRInt32 GetInFlowContentLength();
 6224: 
 6224:   /**
 6224:    * Acquires the text run for this content, if necessary.
 6224:    * @param aRC the rendering context to use as a reference for creating
 6224:    * the textrun, if available (if not, we'll create one which will just be slower)
 6224:    * @param aBlock the block ancestor for this frame, or nsnull if unknown
 6224:    * @param aLine the line that this frame is on, if any, or nsnull if unknown
 6224:    * @param aFlowEndInTextRun if non-null, this returns the textrun offset of
 6224:    * end of the text associated with this frame and its in-flow siblings
 6224:    * @return a gfxSkipCharsIterator set up to map DOM offsets for this frame
 6224:    * to offsets into the textrun; its initial offset is set to this frame's
 6224:    * content offset
 6224:    */
 6862:   gfxSkipCharsIterator EnsureTextRun(gfxContext* aReferenceContext = nsnull,
 6224:                                      nsIFrame* aLineContainer = nsnull,
 6224:                                      const nsLineList::iterator* aLine = nsnull,
 6224:                                      PRUint32* aFlowEndInTextRun = nsnull);
 6224: 
 6224:   gfxTextRun* GetTextRun() { return mTextRun; }
 6224:   void SetTextRun(gfxTextRun* aTextRun) { mTextRun = aTextRun; }
55835:   /**
55835:    * Clears out |mTextRun| from all frames that hold a reference to it,
55835:    * starting at |aStartContinuation|, or if it's nsnull, starting at |this|.
55835:    * Deletes |mTextRun| if all references were cleared and it's not cached.
55835:    */
55835:   void ClearTextRun(nsTextFrame* aStartContinuation);
 6224: 
 6224:   // Get the DOM content range mapped by this frame after excluding
 6224:   // whitespace subject to start-of-line and end-of-line trimming.
 6224:   // The textrun must have been created before calling this.
 6224:   struct TrimmedOffsets {
 6224:     PRInt32 mStart;
 6224:     PRInt32 mLength;
 6224:     PRInt32 GetEnd() { return mStart + mLength; }
 6224:   };
 6224:   TrimmedOffsets GetTrimmedOffsets(const nsTextFragment* aFrag,
 6224:                                    PRBool aTrimAfter);
 6224: 
51483:   // Similar to Reflow(), but for use from nsLineLayout
51483:   void ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
51483:                   nsIRenderingContext* aRenderingContext, PRBool aShouldBlink,
51483:                   nsHTMLReflowMetrics& aMetrics, nsReflowStatus& aStatus);
51483: 
 6224: protected:
 6224:   virtual ~nsTextFrame();
 6224: 
 6224:   nsIFrame*   mNextContinuation;
 6224:   // The key invariant here is that mContentOffset never decreases along
 6224:   // a next-continuation chain. And of course mContentOffset is always <= the
 6224:   // the text node's content length, and the mContentOffset for the first frame
 6224:   // is always 0. Furthermore the text mapped by a frame is determined by
 6224:   // GetContentOffset() and GetContentLength()/GetContentEnd(), which get
 6224:   // the length from the difference between this frame's offset and the next
 6224:   // frame's offset, or the text length if there is no next frame. This means
 6224:   // the frames always map the text node without overlapping or leaving any gaps.
 6224:   PRInt32     mContentOffset;
 6224:   // This does *not* indicate the length of text currently mapped by the frame;
 6224:   // instead it's a hint saying that this frame *wants* to map this much text
 6224:   // so if we create a new continuation, this is where that continuation should
 6224:   // start.
 6224:   PRInt32     mContentLengthHint;
 6224:   nscoord     mAscent;
 6224:   gfxTextRun* mTextRun;
 6224: 
16640:   // The caller of this method must call DestroySelectionDetails() on the
16640:   // return value, if that return value is not null.  Calling
16640:   // DestroySelectionDetails() on a null value is still OK, just not necessary.
 6224:   SelectionDetails* GetSelectionDetails();
 6224:   
11780:   void UnionTextDecorationOverflow(nsPresContext* aPresContext,
14210:                                    PropertyProvider& aProvider,
55028:                                    nsRect* aVisualOverflowRect);
11780: 
15339:   void DrawText(gfxContext* aCtx,
15339:                 const gfxPoint& aTextBaselinePt,
15339:                 PRUint32 aOffset,
15339:                 PRUint32 aLength,
15339:                 const gfxRect* aDirtyRect,
15339:                 PropertyProvider* aProvider,
15339:                 gfxFloat& aAdvanceWidth,
15339:                 PRBool aDrawSoftHyphen);
15339: 
15339:   void PaintOneShadow(PRUint32 aOffset,
15339:                       PRUint32 aLength,
15699:                       nsCSSShadowItem* aShadowDetails,
15339:                       PropertyProvider* aProvider,
32863:                       const nsRect& aDirtyRect,
15339:                       const gfxPoint& aFramePt,
15339:                       const gfxPoint& aTextBaselinePt,
15339:                       gfxContext* aCtx,
15339:                       const nscolor& aForegroundColor);
15339: 
11780:   struct TextDecorations {
11780:     PRUint8 mDecorations;
11780:     nscolor mOverColor;
11780:     nscolor mUnderColor;
11780:     nscolor mStrikeColor;
11780: 
11780:     TextDecorations() :
11780:       mDecorations(0), mOverColor(NS_RGB(0, 0, 0)),
11780:       mUnderColor(NS_RGB(0, 0, 0)), mStrikeColor(NS_RGB(0, 0, 0))
11780:     { }
11780: 
11780:     PRBool HasDecorationlines() {
11780:       return !!(mDecorations & (NS_STYLE_TEXT_DECORATION_UNDERLINE |
11780:                                 NS_STYLE_TEXT_DECORATION_OVERLINE |
11780:                                 NS_STYLE_TEXT_DECORATION_LINE_THROUGH));
11780:     }
11780:     PRBool HasUnderline() {
11780:       return !!(mDecorations & NS_STYLE_TEXT_DECORATION_UNDERLINE);
11780:     }
11780:     PRBool HasOverline() {
11780:       return !!(mDecorations & NS_STYLE_TEXT_DECORATION_OVERLINE);
11780:     }
11780:     PRBool HasStrikeout() {
11780:       return !!(mDecorations & NS_STYLE_TEXT_DECORATION_LINE_THROUGH);
11780:     }
11780:   };
11780:   TextDecorations GetTextDecorations(nsPresContext* aPresContext);
13714: 
26883:   // Set non empty rect to aRect, it should be overflow rect or frame rect.
26883:   // If the result rect is larger than the given rect, this returns PR_TRUE.
26883:   PRBool CombineSelectionUnderlineRect(nsPresContext* aPresContext,
26883:                                        nsRect& aRect);
14210: 
14210:   PRBool IsFloatingFirstLetterChild();
28352: 
28352:   ContentOffsets GetCharacterOffsetAtFramePointInternal(const nsPoint &aPoint,
28352:                    PRBool aForInsertionPoint);
49293: 
49293:   void ClearFrameOffsetCache();
53735: 
53735:   virtual PRBool HasAnyNoncollapsedCharacters();
62671: 
62671:   void ClearMetrics(nsHTMLReflowMetrics& aMetrics);
 6224: };
 6224: 
 6224: #endif
