 80016: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 52557:  * vim: set ts=4 sw=4 et tw=99:
 52557:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 52557: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: 
 52557: #include "jscntxt.h"
 52557: #include "jsscope.h"
 52557: #include "jsobj.h"
 52557: #include "jslibmath.h"
 52557: #include "jsiter.h"
 52557: #include "jsnum.h"
 52557: #include "jsxml.h"
 52557: #include "jsbool.h"
 52557: #include "assembler/assembler/MacroAssemblerCodeRef.h"
 52557: #include "jstypes.h"
 97045: 
 97569: #include "gc/Marking.h"
 76244: #include "vm/Debugger.h"
 97045: #include "vm/NumericConversions.h"
 72107: #include "vm/String.h"
 53168: #include "methodjit/Compiler.h"
 52608: #include "methodjit/StubCalls.h"
 77343: #include "methodjit/Retcon.h"
 53840: 
 53840: #include "jsinterpinlines.h"
 52557: #include "jsscopeinlines.h"
 52557: #include "jsscriptinlines.h"
 72078: #include "jsnuminlines.h"
 52557: #include "jsobjinlines.h"
 52557: #include "jscntxtinlines.h"
 52696: #include "jsatominlines.h"
 52880: #include "StubCalls-inl.h"
 55713: #include "jsfuninlines.h"
 60585: #include "jstypedarray.h"
 55713: 
 79981: #include "vm/RegExpObject-inl.h"
 72107: #include "vm/String-inl.h"
 72107: 
 52897: #ifdef XP_WIN
 52897: # include "jswin.h"
 52897: #endif
 52557: 
 52557: #include "jsautooplen.h"
 52557: 
 52557: using namespace js;
 52557: using namespace js::mjit;
 77343: using namespace js::types;
 52557: using namespace JSC;
 52557: 
 52789: void JS_FASTCALL
 86855: stubs::BindName(VMFrame &f, PropertyName *name)
 56201: {
 97353:     JSObject *obj = FindIdentifierBase(f.cx, f.fp()->scopeChain(),
 99421:                                        RootedPropertyName(f.cx, name));
 56201:     if (!obj)
 56201:         THROW();
 56201:     f.regs.sp[0].setObject(*obj);
 56201: }
 56201: 
 52826: JSObject * JS_FASTCALL
 53473: stubs::BindGlobalName(VMFrame &f)
 52826: {
 96793:     return &f.fp()->global();
 52826: }
 52826: 
 54169: template<JSBool strict>
 52847: void JS_FASTCALL
 86855: stubs::SetName(VMFrame &f, PropertyName *name)
 52611: {
 52611:     JSContext *cx = f.cx;
 86855:     const Value &rval = f.regs.sp[-1];
 86855:     const Value &lval = f.regs.sp[-2];
 52611: 
 86855:     if (!SetPropertyOperation(cx, f.pc(), lval, rval))
 52611:         THROW();
 52611: 
 52611:     f.regs.sp[-2] = f.regs.sp[-1];
 52611: }
 52611: 
 86542: template void JS_FASTCALL stubs::SetName<true>(VMFrame &f, PropertyName *origName);
 86542: template void JS_FASTCALL stubs::SetName<false>(VMFrame &f, PropertyName *origName);
 54169: 
 54169: template<JSBool strict>
 52825: void JS_FASTCALL
 86542: stubs::SetGlobalName(VMFrame &f, PropertyName *name)
 52825: {
 86542:     SetName<strict>(f, name);
 52825: }
 52825: 
 86542: template void JS_FASTCALL stubs::SetGlobalName<true>(VMFrame &f, PropertyName *name);
 86542: template void JS_FASTCALL stubs::SetGlobalName<false>(VMFrame &f, PropertyName *name);
 54169: 
 52617: void JS_FASTCALL
 52819: stubs::Name(VMFrame &f)
 52644: {
 87871:     Value rval;
 87871:     if (!NameOperation(f.cx, f.pc(), &rval))
 52644:         THROW();
 87871:     f.regs.sp[0] = rval;
 52644: }
 52644: 
 52644: void JS_FASTCALL
 52693: stubs::GetElem(VMFrame &f)
 52693: {
 91807:     Value &lref = f.regs.sp[-2];
 91807:     Value &rref = f.regs.sp[-1];
 91807:     Value &rval = f.regs.sp[-2];
 52693: 
 91807:     if (!GetElementOperation(f.cx, JSOp(*f.pc()), lref, rref, &rval))
 52693:         THROW();
 52693: }
 52693: 
 54169: template<JSBool strict>
 52771: void JS_FASTCALL
 52693: stubs::SetElem(VMFrame &f)
 52693: {
 52693:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52693: 
 52693:     Value &objval = regs.sp[-3];
 52693:     Value &idval  = regs.sp[-2];
 59916:     Value rval    = regs.sp[-1];
 52693: 
 52693:     JSObject *obj;
 99421:     RootedId id(cx);
 52693: 
 86855:     obj = ValueToObject(cx, objval);
 52694:     if (!obj)
 52693:         THROW();
 52693: 
 98960:     if (!FetchElementId(f.cx, obj, idval, id.address(), &regs.sp[-2]))
 52693:         THROW();
 52693: 
 91183:     TypeScript::MonitorAssign(cx, obj, id);
 77343: 
 53161:     do {
 52693:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
 91688:             uint32_t length = obj->getDenseArrayInitializedLength();
 91450:             int32_t i = JSID_TO_INT(id);
 91688:             if ((uint32_t)i < length) {
 52693:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
 52693:                     if (js_PrototypeHasIndexedProperties(cx, obj))
 53161:                         break;
 91688:                     if ((uint32_t)i >= obj->getArrayLength())
 77343:                         obj->setArrayLength(cx, i + 1);
 52693:                 }
 77343:                 obj->setDenseArrayElementWithType(cx, i, rval);
 52693:                 goto end_setelem;
 77343:             } else {
 78455:                 if (f.script()->hasAnalysis())
 78454:                     f.script()->analysis()->getCode(f.pc()).arrayWriteHole = true;
 52693:             }
 52693:         }
 53161:     } while (0);
 80625:     if (!obj->setGeneric(cx, id, &rval, strict))
 52693:         THROW();
 52693:   end_setelem:
 52693:     /* :FIXME: Moving the assigned object into the lowest stack slot
 52693:      * is a temporary hack. What we actually want is an implementation
 52693:      * of popAfterSet() that allows popping more than one value;
 52693:      * this logic can then be handled in Compiler.cpp. */
 59916:     regs.sp[-3] = regs.sp[-1];
 52693: }
 52693: 
 54169: template void JS_FASTCALL stubs::SetElem<true>(VMFrame &f);
 54169: template void JS_FASTCALL stubs::SetElem<false>(VMFrame &f);
 54169: 
 52693: void JS_FASTCALL
 77357: stubs::ToId(VMFrame &f)
 77357: {
 77357:     Value &objval = f.regs.sp[-2];
 77357:     Value &idval  = f.regs.sp[-1];
 77357: 
 86855:     JSObject *obj = ValueToObject(f.cx, objval);
 77357:     if (!obj)
 77357:         THROW();
 77357: 
 99421:     RootedId id(f.cx);
 98960:     if (!FetchElementId(f.cx, obj, idval, id.address(), &idval))
 77357:         THROW();
 77357: 
 77386:     if (!idval.isInt32())
 77391:         TypeScript::MonitorUnknown(f.cx, f.script(), f.pc());
 77357: }
 77357: 
 77357: void JS_FASTCALL
 95355: stubs::ImplicitThis(VMFrame &f, PropertyName *name_)
 52644: {
 99421:     RootedObject scopeObj(f.cx, f.cx->stack.currentScriptedScopeChain());
 99421:     RootedPropertyName name(f.cx, name_);
 95355: 
 86855:     JSObject *obj, *obj2;
 86855:     JSProperty *prop;
 95355:     if (!FindPropertyHelper(f.cx, name, false, scopeObj, &obj, &obj2, &prop))
 52644:         THROW();
 52644: 
 86855:     if (!ComputeImplicitThis(f.cx, obj, &f.regs.sp[0]))
 86855:         THROW();
 63236: }
 63236: 
 52644: void JS_FASTCALL
 52721: stubs::BitOr(VMFrame &f)
 52617: {
 52617:     int32_t i, j;
 52617: 
 84161:     if (!ToInt32(f.cx, f.regs.sp[-2], &i) || !ToInt32(f.cx, f.regs.sp[-1], &j))
 52617:         THROW();
 84161: 
 52721:     i = i | j;
 52617:     f.regs.sp[-2].setInt32(i);
 52617: }
 52617: 
 52685: void JS_FASTCALL
 52718: stubs::BitXor(VMFrame &f)
 52718: {
 52718:     int32_t i, j;
 52718: 
 84161:     if (!ToInt32(f.cx, f.regs.sp[-2], &i) || !ToInt32(f.cx, f.regs.sp[-1], &j))
 52718:         THROW();
 84161: 
 52718:     i = i ^ j;
 52718:     f.regs.sp[-2].setInt32(i);
 52718: }
 52718: 
 52718: void JS_FASTCALL
 52721: stubs::BitAnd(VMFrame &f)
 52721: {
 52721:     int32_t i, j;
 52721: 
 84161:     if (!ToInt32(f.cx, f.regs.sp[-2], &i) || !ToInt32(f.cx, f.regs.sp[-1], &j))
 52721:         THROW();
 84161: 
 52721:     i = i & j;
 52721:     f.regs.sp[-2].setInt32(i);
 52721: }
 52721: 
 52721: void JS_FASTCALL
 52724: stubs::BitNot(VMFrame &f)
 52724: {
 52724:     int32_t i;
 52724: 
 84161:     if (!ToInt32(f.cx, f.regs.sp[-1], &i))
 52724:         THROW();
 52724:     i = ~i;
 52724:     f.regs.sp[-1].setInt32(i);
 52724: }
 52724: 
 52724: void JS_FASTCALL
 52685: stubs::Lsh(VMFrame &f)
 52685: {
 52685:     int32_t i, j;
 84161:     if (!ToInt32(f.cx, f.regs.sp[-2], &i))
 52685:         THROW();
 84161:     if (!ToInt32(f.cx, f.regs.sp[-1], &j))
 52685:         THROW();
 52685:     i = i << (j & 31);
 52685:     f.regs.sp[-2].setInt32(i);
 52685: }
 52685: 
 52685: void JS_FASTCALL
 52685: stubs::Rsh(VMFrame &f)
 52685: {
 52685:     int32_t i, j;
 84161:     if (!ToInt32(f.cx, f.regs.sp[-2], &i))
 52685:         THROW();
 84161:     if (!ToInt32(f.cx, f.regs.sp[-1], &j))
 52685:         THROW();
 52685:     i = i >> (j & 31);
 52685:     f.regs.sp[-2].setInt32(i);
 52685: }
 52685: 
 52725: void JS_FASTCALL
 52725: stubs::Ursh(VMFrame &f)
 52725: {
 52725:     uint32_t u;
 84161:     if (!ToUint32(f.cx, f.regs.sp[-2], &u))
 52725:         THROW();
 52725:     int32_t j;
 84161:     if (!ToInt32(f.cx, f.regs.sp[-1], &j))
 52725:         THROW();
 52725: 
 52725:     u >>= (j & 31);
 52725: 
 84755: 	if (!f.regs.sp[-2].setNumber(uint32_t(u)))
 77391:         TypeScript::MonitorOverflow(f.cx, f.script(), f.pc());
 52725: }
 52725: 
 54169: template<JSBool strict>
 53345: void JS_FASTCALL
 95355: stubs::DefFun(VMFrame &f, JSFunction *fun_)
 52647: {
 52647:     /*
 52647:      * A top-level function defined in Global or Eval code (see ECMA-262
 52647:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
 52647:      * a compound statement (not at the top statement level of global code, or
 52647:      * at the top level of a function body).
 52647:      */
 98921:     JSContext *cx = f.cx;
 98921:     StackFrame *fp = f.fp();
 99421:     RootedFunction fun(f.cx, fun_);
 52647: 
 52647:     /*
 52647:      * If static link is not current scope, clone fun's object to link to the
 52647:      * current scope via parent. We do this to enable sharing of compiled
 52647:      * functions among multiple equivalent scopes, amortizing the cost of
 52647:      * compilation over a number of executions.  Examples include XUL scripts
 52647:      * and event handlers shared among Firefox or other Mozilla app chrome
 52647:      * windows, and user-defined JS functions precompiled and then shared among
 52647:      * requests in server-side JS.
 52647:      */
 98921:     HandleObject scopeChain = f.fp()->scopeChain();
 98921:     if (fun->environment() != scopeChain) {
 98921:         fun = CloneFunctionObjectIfNotSingleton(cx, fun, scopeChain);
 98921:         if (!fun)
 52647:             THROW();
 98921:     } else {
 98921:         JS_ASSERT(f.script()->compileAndGo);
 98921:         JS_ASSERT(f.fp()->isGlobalFrame() || f.fp()->isEvalInFunction());
 52647:     }
 52647: 
 52647:     /*
 52647:      * ECMA requires functions defined when entering Eval code to be
 52647:      * impermanent.
 52647:      */
 91237:     unsigned attrs = fp->isEvalFrame()
 52647:                   ? JSPROP_ENUMERATE
 52647:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
 52647: 
 52647:     /*
 52647:      * We define the function as a property of the variable object and not the
 52647:      * current scope chain even for the case of function expression statements
 52647:      * and functions defined by eval inside let or with blocks.
 52647:      */
 71694:     JSObject *parent = &fp->varObj();
 52647: 
 61216:     /* ES5 10.5 (NB: with subsequent errata). */
 80442:     PropertyName *name = fun->atom->asPropertyName();
 53531:     JSProperty *prop = NULL;
 53531:     JSObject *pobj;
 80442:     if (!parent->lookupProperty(cx, name, &pobj, &prop))
 53840:         THROW();
 52647: 
 98921:     Value rval = ObjectValue(*fun);
 55563: 
 61216:     do {
 61216:         /* Steps 5d, 5f. */
 61216:         if (!prop || pobj != parent) {
 80624:             if (!parent->defineProperty(cx, name, rval,
 80624:                                         JS_PropertyStub, JS_StrictPropertyStub, attrs))
 80624:             {
 61216:                 THROW();
 80624:             }
 61216:             break;
 61216:         }
 55563: 
 61216:         /* Step 5e. */
 61216:         JS_ASSERT(parent->isNative());
 61216:         Shape *shape = reinterpret_cast<Shape *>(prop);
 61216:         if (parent->isGlobal()) {
 61216:             if (shape->configurable()) {
 80624:                 if (!parent->defineProperty(cx, name, rval,
 80624:                                             JS_PropertyStub, JS_StrictPropertyStub, attrs))
 80624:                 {
 61216:                     THROW();
 80624:                 }
 61216:                 break;
 61216:             }
 61216: 
 61216:             if (shape->isAccessorDescriptor() || !shape->writable() || !shape->enumerable()) {
 61216:                 JSAutoByteString bytes;
 86542:                 if (js_AtomToPrintableString(cx, name, &bytes)) {
 61216:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 86542:                                          JSMSG_CANT_REDEFINE_PROP, bytes.ptr());
 61216:                 }
 61216:                 THROW();
 61216:             }
 61216:         }
 55563: 
 52647:         /*
 61216:          * Non-global properties, and global properties which we aren't simply
 61216:          * redefining, must be set.  First, this preserves their attributes.
 61216:          * Second, this will produce warnings and/or errors as necessary if the
 61216:          * specified Call object property is not writable (const).
 52647:          */
 55563: 
 61216:         /* Step 5f. */
 80625:         if (!parent->setProperty(cx, name, &rval, strict))
 52647:             THROW();
 61216:     } while (false);
 52647: }
 52653: 
 54169: template void JS_FASTCALL stubs::DefFun<true>(VMFrame &f, JSFunction *fun);
 54169: template void JS_FASTCALL stubs::DefFun<false>(VMFrame &f, JSFunction *fun);
 54169: 
 52653: #define RELATIONAL(OP)                                                        \
 52653:     JS_BEGIN_MACRO                                                            \
 52653:         JSContext *cx = f.cx;                                                 \
 69223:         FrameRegs &regs = f.regs;                                             \
 72054:         Value &rval = regs.sp[-1];                                            \
 72054:         Value &lval = regs.sp[-2];                                            \
 52653:         bool cond;                                                            \
 72054:         if (!ToPrimitive(cx, JSTYPE_NUMBER, &lval))                           \
 72054:             THROWV(JS_FALSE);                                                 \
 72054:         if (!ToPrimitive(cx, JSTYPE_NUMBER, &rval))                           \
 72054:             THROWV(JS_FALSE);                                                 \
 52954:         if (lval.isString() && rval.isString()) {                             \
 53081:             JSString *l = lval.toString(), *r = rval.toString();              \
 84755:             int32_t cmp;                                                      \
 59890:             if (!CompareStrings(cx, l, r, &cmp))                              \
 59890:                 THROWV(JS_FALSE);                                             \
 59890:             cond = cmp OP 0;                                                  \
 52653:         } else {                                                              \
 52653:             double l, r;                                                      \
 73894:             if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))           \
 52653:                 THROWV(JS_FALSE);                                             \
 88220:             cond = (l OP r);                                                  \
 52653:         }                                                                     \
 52668:         regs.sp[-2].setBoolean(cond);                                         \
 52653:         return cond;                                                          \
 52653:     JS_END_MACRO
 52653: 
 52653: JSBool JS_FASTCALL
 52653: stubs::LessThan(VMFrame &f)
 52653: {
 52653:     RELATIONAL(<);
 52653: }
 52653: 
 52653: JSBool JS_FASTCALL
 52653: stubs::LessEqual(VMFrame &f)
 52653: {
 52653:     RELATIONAL(<=);
 52653: }
 52653: 
 52653: JSBool JS_FASTCALL
 52653: stubs::GreaterThan(VMFrame &f)
 52653: {
 52653:     RELATIONAL(>);
 52653: }
 52653: 
 52653: JSBool JS_FASTCALL
 52653: stubs::GreaterEqual(VMFrame &f)
 52653: {
 52653:     RELATIONAL(>=);
 52653: }
 52653: 
 52686: JSBool JS_FASTCALL
 52686: stubs::ValueToBoolean(VMFrame &f)
 52686: {
 52686:     return js_ValueToBoolean(f.regs.sp[-1]);
 52686: }
 52686: 
 52734: void JS_FASTCALL
 52734: stubs::Not(VMFrame &f)
 52734: {
 52734:     JSBool b = !js_ValueToBoolean(f.regs.sp[-1]);
 52734:     f.regs.sp[-1].setBoolean(b);
 52734: }
 52734: 
 88220: template <bool EQ>
 52679: static inline bool
 52954: StubEqualityOp(VMFrame &f)
 52679: {
 52679:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52679: 
 52679:     Value rval = regs.sp[-1];
 52679:     Value lval = regs.sp[-2];
 52679: 
 88099:     bool cond;
 52679: 
 53429:     /* The string==string case is easily the hottest;  try it first. */
 53429:     if (lval.isString() && rval.isString()) {
 53429:         JSString *l = lval.toString();
 53429:         JSString *r = rval.toString();
 88099:         bool equal;
 59890:         if (!EqualStrings(cx, l, r, &equal))
 59890:             return false;
 59890:         cond = equal == EQ;
 53429:     } else
 52679: #if JS_HAS_XML_SUPPORT
 53081:     if ((lval.isObject() && lval.toObject().isXML()) ||
 88099:         (rval.isObject() && rval.toObject().isXML()))
 88099:     {
 88099:         JSBool equal;
 88099:         if (!js_TestXMLEquality(cx, lval, rval, &equal))
 52954:             return false;
 88099:         cond = !!equal == EQ;
 52679:     } else
 52954: #endif
 52679: 
 53023:     if (SameType(lval, rval)) {
 53429:         JS_ASSERT(!lval.isString());    /* this case is handled above */
 53429:         if (lval.isDouble()) {
 53081:             double l = lval.toDouble();
 53081:             double r = rval.toDouble();
 52954:             if (EQ)
 88220:                 cond = (l == r);
 52954:             else
 88220:                 cond = (l != r);
 52954:         } else if (lval.isObject()) {
 53081:             JSObject *l = &lval.toObject(), *r = &rval.toObject();
 78614:             if (JSEqualityOp eq = l->getClass()->ext.equality) {
 88099:                 JSBool equal;
 99421:                 if (!eq(cx, RootedObject(cx, l), &rval, &equal))
 52954:                     return false;
 88099:                 cond = !!equal == EQ;
 52679:             } else {
 52954:                 cond = (l == r) == EQ;
 52679:             }
 53418:         } else if (lval.isNullOrUndefined()) {
 53418:             cond = EQ;
 52679:         } else {
 53081:             cond = (lval.payloadAsRawUint32() == rval.payloadAsRawUint32()) == EQ;
 52679:         }
 52679:     } else {
 52679:         if (lval.isNullOrUndefined()) {
 52954:             cond = rval.isNullOrUndefined() == EQ;
 52679:         } else if (rval.isNullOrUndefined()) {
 52954:             cond = !EQ;
 52679:         } else {
 72054:             if (!ToPrimitive(cx, &lval))
 52954:                 return false;
 72054:             if (!ToPrimitive(cx, &rval))
 52954:                 return false;
 52679: 
 53429:             /*
 72054:              * The string==string case is repeated because ToPrimitive can
 53429:              * convert lval/rval to strings.
 53429:              */
 52954:             if (lval.isString() && rval.isString()) {
 53081:                 JSString *l = lval.toString();
 53081:                 JSString *r = rval.toString();
 88099:                 bool equal;
 59890:                 if (!EqualStrings(cx, l, r, &equal))
 59890:                     return false;
 59890:                 cond = equal == EQ;
 52679:             } else {
 52679:                 double l, r;
 73894:                 if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))
 52954:                     return false;
 52679: 
 52954:                 if (EQ)
 88220:                     cond = (l == r);
 52679:                 else
 88220:                     cond = (l != r);
 52679:             }
 52679:         }
 52679:     }
 52679: 
 52680:     regs.sp[-2].setBoolean(cond);
 52954:     return true;
 52679: }
 52679: 
 52679: JSBool JS_FASTCALL
 52679: stubs::Equal(VMFrame &f)
 52679: {
 88220:     if (!StubEqualityOp<true>(f))
 52954:         THROWV(JS_FALSE);
 53081:     return f.regs.sp[-2].toBoolean();
 52679: }
 52679: 
 52679: JSBool JS_FASTCALL
 52679: stubs::NotEqual(VMFrame &f)
 52679: {
 88220:     if (!StubEqualityOp<false>(f))
 52954:         THROWV(JS_FALSE);
 53081:     return f.regs.sp[-2].toBoolean();
 52679: }
 52679: 
 52692: void JS_FASTCALL
 52692: stubs::Add(VMFrame &f)
 52692: {
 52692:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 77343:     Value rval = regs.sp[-1];
 77343:     Value lval = regs.sp[-2];
 52692: 
 53357:     /* The string + string case is easily the hottest;  try it first. */
 53357:     bool lIsString = lval.isString();
 53357:     bool rIsString = rval.isString();
 99421:     RootedString lstr(cx), rstr(cx);
 53357:     if (lIsString && rIsString) {
 53357:         lstr = lval.toString();
 53357:         rstr = rval.toString();
 53357:         goto string_concat;
 53357: 
 52692:     } else
 52692: #if JS_HAS_XML_SUPPORT
 53081:     if (lval.isObject() && lval.toObject().isXML() &&
 53081:         rval.isObject() && rval.toObject().isXML()) {
 53081:         if (!js_ConcatenateXML(cx, &lval.toObject(), &rval.toObject(), &rval))
 52692:             THROW();
 72054:         regs.sp[-2] = rval;
 52692:         regs.sp--;
 77391:         TypeScript::MonitorUnknown(cx, f.script(), f.pc());
 52692:     } else
 52692: #endif
 52692:     {
 77343:         bool lIsObject = lval.isObject(), rIsObject = rval.isObject();
 72054:         if (!ToPrimitive(f.cx, &lval))
 52692:             THROW();
 72054:         if (!ToPrimitive(f.cx, &rval))
 52692:             THROW();
 53357:         if ((lIsString = lval.isString()) || (rIsString = rval.isString())) {
 52692:             if (lIsString) {
 53081:                 lstr = lval.toString();
 52692:             } else {
 84160:                 lstr = ToString(cx, lval);
 52692:                 if (!lstr)
 52692:                     THROW();
 52692:                 regs.sp[-2].setString(lstr);
 52692:             }
 52692:             if (rIsString) {
 53081:                 rstr = rval.toString();
 52692:             } else {
 84160:                 rstr = ToString(cx, rval);
 52692:                 if (!rstr)
 52692:                     THROW();
 52692:                 regs.sp[-1].setString(rstr);
 52692:             }
 77343:             if (lIsObject || rIsObject)
 77391:                 TypeScript::MonitorString(cx, f.script(), f.pc());
 53357:             goto string_concat;
 53357: 
 52692:         } else {
 52692:             double l, r;
 73894:             if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))
 52692:                 THROW();
 52692:             l += r;
 77343:             if (!regs.sp[-2].setNumber(l) &&
 77343:                 (lIsObject || rIsObject || (!lval.isDouble() && !rval.isDouble()))) {
 77391:                 TypeScript::MonitorOverflow(cx, f.script(), f.pc());
 77343:             }
 52692:         }
 52692:     }
 53357:     return;
 53357: 
 53357:   string_concat:
 53357:     JSString *str = js_ConcatStrings(cx, lstr, rstr);
 53357:     if (!str)
 53357:         THROW();
 72054:     regs.sp[-2].setString(str);
 53357:     regs.sp--;
 52692: }
 52692: 
 52692: 
 52692: void JS_FASTCALL
 52692: stubs::Sub(VMFrame &f)
 52692: {
 52692:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52692:     double d1, d2;
 73894:     if (!ToNumber(cx, regs.sp[-2], &d1) || !ToNumber(cx, regs.sp[-1], &d2))
 52692:         THROW();
 52692:     double d = d1 - d2;
 77343:     if (!regs.sp[-2].setNumber(d))
 77391:         TypeScript::MonitorOverflow(cx, f.script(), f.pc());
 52692: }
 52692: 
 52692: void JS_FASTCALL
 52692: stubs::Mul(VMFrame &f)
 52692: {
 52692:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52692:     double d1, d2;
 73894:     if (!ToNumber(cx, regs.sp[-2], &d1) || !ToNumber(cx, regs.sp[-1], &d2))
 52692:         THROW();
 52692:     double d = d1 * d2;
 77343:     if (!regs.sp[-2].setNumber(d))
 77391:         TypeScript::MonitorOverflow(cx, f.script(), f.pc());
 52692: }
 52692: 
 52692: void JS_FASTCALL
 52692: stubs::Div(VMFrame &f)
 52692: {
 52692:     JSContext *cx = f.cx;
 52692:     JSRuntime *rt = cx->runtime;
 69223:     FrameRegs &regs = f.regs;
 52692: 
 52692:     double d1, d2;
 73894:     if (!ToNumber(cx, regs.sp[-2], &d1) || !ToNumber(cx, regs.sp[-1], &d2))
 52692:         THROW();
 52692:     if (d2 == 0) {
 52692:         const Value *vp;
 52692: #ifdef XP_WIN
 52692:         /* XXX MSVC miscompiles such that (NaN == 0) */
 95341:         if (MOZ_DOUBLE_IS_NaN(d2))
 52692:             vp = &rt->NaNValue;
 52692:         else
 52692: #endif
 95341:         if (d1 == 0 || MOZ_DOUBLE_IS_NaN(d1))
 52692:             vp = &rt->NaNValue;
 95341:         else if (MOZ_DOUBLE_IS_NEGATIVE(d1) != MOZ_DOUBLE_IS_NEGATIVE(d2))
 52692:             vp = &rt->negativeInfinityValue;
 52692:         else
 52692:             vp = &rt->positiveInfinityValue;
 52692:         regs.sp[-2] = *vp;
 77391:         TypeScript::MonitorOverflow(cx, f.script(), f.pc());
 52692:     } else {
 52692:         d1 /= d2;
 77343:         if (!regs.sp[-2].setNumber(d1))
 77391:             TypeScript::MonitorOverflow(cx, f.script(), f.pc());
 52692:     }
 52692: }
 52692: 
 52692: void JS_FASTCALL
 52692: stubs::Mod(VMFrame &f)
 52692: {
 52692:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52692: 
 52692:     Value &lref = regs.sp[-2];
 52692:     Value &rref = regs.sp[-1];
 52692:     int32_t l, r;
 52692:     if (lref.isInt32() && rref.isInt32() &&
 53081:         (l = lref.toInt32()) >= 0 && (r = rref.toInt32()) > 0) {
 52692:         int32_t mod = l % r;
 52692:         regs.sp[-2].setInt32(mod);
 52692:     } else {
 52692:         double d1, d2;
 73894:         if (!ToNumber(cx, regs.sp[-2], &d1) || !ToNumber(cx, regs.sp[-1], &d2))
 52692:             THROW();
 52692:         if (d2 == 0) {
 52692:             regs.sp[-2].setDouble(js_NaN);
 52692:         } else {
 52692:             d1 = js_fmod(d1, d2);
 52692:             regs.sp[-2].setDouble(d1);
 52692:         }
 77391:         TypeScript::MonitorOverflow(cx, f.script(), f.pc());
 52692:     }
 52692: }
 52692: 
 52704: void JS_FASTCALL
 75513: stubs::DebuggerStatement(VMFrame &f, jsbytecode *pc)
 53395: {
 91178:     JSDebuggerHandler handler = f.cx->runtime->debugHooks.debuggerHandler;
 75452:     if (handler || !f.cx->compartment->getDebuggees().empty()) {
 75402:         JSTrapStatus st = JSTRAP_CONTINUE;
 68904:         Value rval;
 78614:         if (handler)
 91178:             st = handler(f.cx, f.script(), pc, &rval, f.cx->runtime->debugHooks.debuggerHandlerData);
 75402:         if (st == JSTRAP_CONTINUE)
 75513:             st = Debugger::onDebuggerStatement(f.cx, &rval);
 75402: 
 75402:         switch (st) {
 53395:           case JSTRAP_THROW:
 60211:             f.cx->setPendingException(rval);
 53395:             THROW();
 53395: 
 53395:           case JSTRAP_RETURN:
 60211:             f.cx->clearPendingException();
 55483:             f.cx->fp()->setReturnValue(rval);
 97464:             *f.returnAddressLocation() = f.cx->jaegerRuntime().forceReturnFromFastCall();
 53395:             break;
 53395: 
 53395:           case JSTRAP_ERROR:
 60211:             f.cx->clearPendingException();
 53395:             THROW();
 53395: 
 53395:           default:
 53395:             break;
 53395:         }
 53395:     }
 53395: }
 53395: 
 53395: void JS_FASTCALL
 53168: stubs::Interrupt(VMFrame &f, jsbytecode *pc)
 52753: {
 90410:     gc::MaybeVerifyBarriers(f.cx);
 82130: 
 53168:     if (!js_HandleExecutionInterrupt(f.cx))
 52753:         THROW();
 52753: }
 53168: 
 53168: void JS_FASTCALL
 77343: stubs::RecompileForInline(VMFrame &f)
 77343: {
 77398:     ExpandInlineFrames(f.cx->compartment);
 98147:     Recompiler::clearStackReferences(f.cx->runtime->defaultFreeOp(), f.script());
 98147:     f.jit()->destroyChunk(f.cx->runtime->defaultFreeOp(), f.chunkIndex(), /* resetUses = */ false);
 77343: }
 77343: 
 77343: void JS_FASTCALL
 84755: stubs::Trap(VMFrame &f, uint32_t trapTypes)
 53168: {
 53168:     Value rval;
 53168: 
 59882:     /*
 59882:      * Trap may be called for a single-step interrupt trap and/or a
 59882:      * regular trap. Try the single-step first, and if it lets control
 59882:      * flow through or does not exist, do the regular trap.
 59882:      */
 59882:     JSTrapStatus result = JSTRAP_CONTINUE;
 59882:     if (trapTypes & JSTRAP_SINGLESTEP) {
 59882:         /*
 59882:          * single step mode may be paused without recompiling by
 59882:          * setting the interruptHook to NULL.
 59882:          */
 91178:         JSInterruptHook hook = f.cx->runtime->debugHooks.interruptHook;
 59882:         if (hook)
 91178:             result = hook(f.cx, f.script(), f.pc(), &rval, f.cx->runtime->debugHooks.interruptHookData);
 77171: 
 77171:         if (result == JSTRAP_CONTINUE)
 77171:             result = Debugger::onSingleStep(f.cx, &rval);
 59882:     }
 59882: 
 59882:     if (result == JSTRAP_CONTINUE && (trapTypes & JSTRAP_TRAP))
 75513:         result = Debugger::onTrap(f.cx, &rval);
 59882: 
 59882:     switch (result) {
 53168:       case JSTRAP_THROW:
 60211:         f.cx->setPendingException(rval);
 53168:         THROW();
 53168: 
 53168:       case JSTRAP_RETURN:
 60211:         f.cx->clearPendingException();
 55483:         f.cx->fp()->setReturnValue(rval);
 97464:         *f.returnAddressLocation() = f.cx->jaegerRuntime().forceReturnFromFastCall();
 53168:         break;
 53168: 
 53168:       case JSTRAP_ERROR:
 60211:         f.cx->clearPendingException();
 53168:         THROW();
 53168: 
 53168:       default:
 53168:         break;
 53168:     }
 52753: }
 52753: 
 52753: void JS_FASTCALL
 52704: stubs::This(VMFrame &f)
 52704: {
 77343:     /*
 77343:      * We can't yet inline scripts which need to compute their 'this' object
 77343:      * from a primitive; the frame we are computing 'this' for does not exist yet.
 77343:      */
 77343:     if (f.regs.inlined()) {
 77361:         f.script()->uninlineable = true;
 77391:         MarkTypeObjectFlags(f.cx, &f.fp()->callee(), OBJECT_FLAG_UNINLINEABLE);
 77343:     }
 77343: 
 68904:     if (!ComputeThis(f.cx, f.fp()))
 52704:         THROW();
 55713:     f.regs.sp[-1] = f.fp()->thisValue();
 53023: }
 53023: 
 53023: void JS_FASTCALL
 52713: stubs::Neg(VMFrame &f)
 52713: {
 52713:     double d;
 73894:     if (!ToNumber(f.cx, f.regs.sp[-1], &d))
 52713:         THROW();
 52713:     d = -d;
 77343:     if (!f.regs.sp[-1].setNumber(d))
 77391:         TypeScript::MonitorOverflow(f.cx, f.script(), f.pc());
 52713: }
 52713: 
 77413: void JS_FASTCALL
 84755: stubs::NewInitArray(VMFrame &f, uint32_t count)
 52719: {
 59234:     JSObject *obj = NewDenseAllocatedArray(f.cx, count);
 59234:     if (!obj)
 77413:         THROW();
 58056: 
 77343:     TypeObject *type = (TypeObject *) f.scratch;
 93664:     if (type) {
 77343:         obj->setType(type);
 93664:     } else {
 93664:         if (!SetInitializerObjectType(f.cx, f.script(), f.pc(), obj))
 93664:             THROW();
 93664:     }
 77343: 
 77413:     f.regs.sp[0].setObject(*obj);
 52719: }
 52719: 
 77413: void JS_FASTCALL
 58056: stubs::NewInitObject(VMFrame &f, JSObject *baseobj)
 52719: {
 52719:     JSContext *cx = f.cx;
 77343:     TypeObject *type = (TypeObject *) f.scratch;
 52719: 
 93664:     JSObject *obj;
 93664: 
 93664:     if (baseobj) {
 99421:         obj = CopyInitializerObject(cx, RootedObject(cx, baseobj));
 93664:     } else {
 83231:         gc::AllocKind kind = GuessObjectGCKind(0);
 93664:         obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
 58056:     }
 52719: 
 58056:     if (!obj)
 77413:         THROW();
 93664: 
 93664:     if (type) {
 93664:         obj->setType(type);
 93664:     } else {
 93664:         if (!SetInitializerObjectType(cx, f.script(), f.pc(), obj))
 93664:             THROW();
 93664:     }
 93664: 
 77413:     f.regs.sp[0].setObject(*obj);
 52719: }
 52719: 
 52719: void JS_FASTCALL
 84755: stubs::InitElem(VMFrame &f, uint32_t last)
 52723: {
 52723:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52723: 
 52723:     /* Pop the element's value into rval. */
100006:     JS_ASSERT(regs.sp - f.fp()->base() >= 3);
 52723:     const Value &rref = regs.sp[-1];
 52723: 
 52723:     /* Find the object being initialized at top of stack. */
 52723:     const Value &lref = regs.sp[-3];
 52723:     JS_ASSERT(lref.isObject());
 53081:     JSObject *obj = &lref.toObject();
 52723: 
 52723:     /* Fetch id now that we have obj. */
 99421:     RootedId id(cx);
 52723:     const Value &idval = regs.sp[-2];
 98960:     if (!FetchElementId(f.cx, obj, idval, id.address(), &regs.sp[-2]))
 52723:         THROW();
 52723: 
 52723:     /*
 52723:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
 52723:      * obj must be an array, so if the current op is the last element
 52723:      * initialiser, set the array length to one greater than id.
 52723:      */
 52723:     if (rref.isMagic(JS_ARRAY_HOLE)) {
 52723:         JS_ASSERT(obj->isArray());
 52723:         JS_ASSERT(JSID_IS_INT(id));
 91688:         JS_ASSERT(uint32_t(JSID_TO_INT(id)) < StackSpace::ARGS_LENGTH_MAX);
 91688:         if (last && !js_SetLengthProperty(cx, obj, (uint32_t) (JSID_TO_INT(id) + 1)))
 52723:             THROW();
 52723:     } else {
 80624:         if (!obj->defineGeneric(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
 52723:             THROW();
 52723:     }
 52723: }
 52723: 
 80271: void JS_FASTCALL
 52729: stubs::RegExp(VMFrame &f, JSObject *regex)
 52729: {
 52729:     /*
 52729:      * Push a regexp object cloned from the regexp literal object mapped by the
 80627:      * bytecode at pc.
 52729:      */
 96793:     JSObject *proto = f.fp()->global().getOrCreateRegExpPrototype(f.cx);
 80627:     if (!proto)
 80271:         THROW();
 52729:     JS_ASSERT(proto);
 89918:     JSObject *obj = CloneRegExpObject(f.cx, regex, proto);
 52729:     if (!obj)
 80271:         THROW();
 80271:     f.regs.sp[0].setObject(*obj);
 52729: }
 52729: 
 52730: JSObject * JS_FASTCALL
 95355: stubs::Lambda(VMFrame &f, JSFunction *fun_)
 52730: {
 99421:     RootedFunction fun(f.cx, fun_);
 98921:     fun = CloneFunctionObjectIfNotSingleton(f.cx, fun, f.fp()->scopeChain());
 98921:     if (!fun)
 52730:         THROWV(NULL);
 52730: 
 98921:     return fun;
 52730: }
 52730: 
 86855: void JS_FASTCALL
 86855: stubs::GetProp(VMFrame &f, PropertyName *name)
 52741: {
 52741:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52741: 
 52741:     Value rval;
 86855:     if (!GetPropertyOperation(cx, f.pc(), f.regs.sp[-1], &rval))
 86855:         THROW();
 52741: 
 52741:     regs.sp[-1] = rval;
 52761: }
 52761: 
 52761: void JS_FASTCALL
 86542: stubs::GetPropNoCache(VMFrame &f, PropertyName *name)
 56201: {
 56201:     JSContext *cx = f.cx;
 86855:     FrameRegs &regs = f.regs;
 86752: 
 86855:     const Value &lval = f.regs.sp[-1];
 86855: 
 86855:     // Uncached lookups are only used for .prototype accesses at the start of constructors.
 86855:     JS_ASSERT(lval.isObject());
 86855:     JS_ASSERT(name == cx->runtime->atomState.classPrototypeAtom);
 86855: 
 86855:     JSObject *obj = &lval.toObject();
 86855: 
 86855:     Value rval;
 86855:     if (!obj->getProperty(cx, name, &rval))
 86752:         THROW();
 86752: 
 86855:     regs.sp[-1] = rval;
 69659: }
 69659: 
 69659: void JS_FASTCALL
 84755: stubs::Iter(VMFrame &f, uint32_t flags)
 52733: {
 91160:     if (!ValueToIterator(f.cx, flags, &f.regs.sp[-1]))
 52733:         THROW();
 52733:     JS_ASSERT(!f.regs.sp[-1].isPrimitive());
 52733: }
 52733: 
 52735: static void
 86542: InitPropOrMethod(VMFrame &f, PropertyName *name, JSOp op)
 52735: {
 52735:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52735: 
 52735:     /* Load the property's initial value into rval. */
100006:     JS_ASSERT(regs.sp - f.fp()->base() >= 2);
 52735:     Value rval;
 52735:     rval = regs.sp[-1];
 52735: 
 52735:     /* Load the object being initialized into lval/obj. */
 99421:     RootedObject obj(cx, &regs.sp[-2].toObject());
 52735:     JS_ASSERT(obj->isNative());
 52735: 
 86855:     /* Get the immediate property name into id. */
 99421:     RootedId id(cx, NameToId(name));
 52735: 
 86542:     if (JS_UNLIKELY(name == cx->runtime->atomState.protoAtom)
 98960:         ? !baseops::SetPropertyHelper(cx, obj, id, 0, &rval, false)
 86855:         : !DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
 94227:                                 JSPROP_ENUMERATE, 0, 0, 0)) {
 52735:         THROW();
 52735:     }
 52735: }
 52735: 
 52735: void JS_FASTCALL
 86542: stubs::InitProp(VMFrame &f, PropertyName *name)
 52735: {
 86542:     InitPropOrMethod(f, name, JSOP_INITPROP);
 52735: }
 52735: 
 52737: void JS_FASTCALL
 84755: stubs::IterNext(VMFrame &f, int32_t offset)
 52737: {
100006:     JS_ASSERT(f.regs.sp - offset >= f.fp()->base());
 77824:     JS_ASSERT(f.regs.sp[-offset].isObject());
 52737: 
 77824:     JSObject *iterobj = &f.regs.sp[-offset].toObject();
 52737:     f.regs.sp[0].setNull();
 52737:     f.regs.sp++;
 52737:     if (!js_IteratorNext(f.cx, iterobj, &f.regs.sp[-1]))
 52737:         THROW();
 52737: }
 52737: 
 52737: JSBool JS_FASTCALL
 52737: stubs::IterMore(VMFrame &f)
 52737: {
100006:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
 52737:     JS_ASSERT(f.regs.sp[-1].isObject());
 52737: 
 52737:     Value v;
 53081:     JSObject *iterobj = &f.regs.sp[-1].toObject();
 99421:     if (!js_IteratorMore(f.cx, RootedObject(f.cx, iterobj), &v))
 52737:         THROWV(JS_FALSE);
 52737: 
 53081:     return v.toBoolean();
 52737: }
 52737: 
 52737: void JS_FASTCALL
 52737: stubs::EndIter(VMFrame &f)
 52737: {
100006:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
 91160:     if (!CloseIterator(f.cx, &f.regs.sp[-1].toObject()))
 52737:         THROW();
 52737: }
 52737: 
 52738: JSString * JS_FASTCALL
 52738: stubs::TypeOf(VMFrame &f)
 52738: {
 52738:     const Value &ref = f.regs.sp[-1];
 78614:     JSType type = JS_TypeOfValue(f.cx, ref);
 86542:     return f.cx->runtime->atomState.typeAtoms[type];
 52738: }
 52738: 
 53513: void JS_FASTCALL
 52739: stubs::StrictEq(VMFrame &f)
 52739: {
 52739:     const Value &rhs = f.regs.sp[-1];
 52739:     const Value &lhs = f.regs.sp[-2];
 88099:     bool equal;
 59890:     if (!StrictlyEqual(f.cx, lhs, rhs, &equal))
 59890:         THROW();
 53513:     f.regs.sp--;
 59908:     f.regs.sp[-1].setBoolean(equal == JS_TRUE);
 52739: }
 52739: 
 53513: void JS_FASTCALL
 52739: stubs::StrictNe(VMFrame &f)
 52739: {
 52739:     const Value &rhs = f.regs.sp[-1];
 52739:     const Value &lhs = f.regs.sp[-2];
 88099:     bool equal;
 59890:     if (!StrictlyEqual(f.cx, lhs, rhs, &equal))
 59890:         THROW();
 53513:     f.regs.sp--;
 59908:     f.regs.sp[-1].setBoolean(equal != JS_TRUE);
 52739: }
 52739: 
 52772: void JS_FASTCALL
 52772: stubs::Throw(VMFrame &f)
 52772: {
 52772:     JSContext *cx = f.cx;
 52772: 
 60211:     JS_ASSERT(!cx->isExceptionPending());
 60211:     cx->setPendingException(f.regs.sp[-1]);
 52772:     THROW();
 52772: }
 52772: 
 52778: void JS_FASTCALL
 52778: stubs::Arguments(VMFrame &f)
 52778: {
100006:     ArgumentsObject *obj = ArgumentsObject::create(f.cx, f.fp());
 95100:     if (!obj)
 93251:         THROW();
 95100:     f.regs.sp[0] = ObjectValue(*obj);
 52778: }
 52778: 
 52780: JSBool JS_FASTCALL
 52780: stubs::InstanceOf(VMFrame &f)
 52780: {
 52780:     JSContext *cx = f.cx;
 69223:     FrameRegs &regs = f.regs;
 52780: 
 52780:     const Value &rref = regs.sp[-1];
 53155:     if (rref.isPrimitive()) {
 52780:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
 52780:                             -1, rref, NULL);
 52780:         THROWV(JS_FALSE);
 52780:     }
 99421:     RootedObject obj(cx, &rref.toObject());
 52780:     const Value &lref = regs.sp[-2];
 52780:     JSBool cond = JS_FALSE;
 53161:     if (!HasInstance(cx, obj, &lref, &cond))
 52780:         THROWV(JS_FALSE);
 52894:     f.regs.sp[-2].setBoolean(cond);
 52780:     return cond;
 52780: }
 52780: 
 52911: void JS_FASTCALL
 52894: stubs::FastInstanceOf(VMFrame &f)
 52894: {
 52894:     const Value &lref = f.regs.sp[-1];
 52894: 
 52894:     if (lref.isPrimitive()) {
 52894:         /*
 52894:          * Throw a runtime error if instanceof is called on a function that
 52894:          * has a non-object as its .prototype value.
 52894:          */
 52894:         js_ReportValueError(f.cx, JSMSG_BAD_PROTOTYPE, -1, f.regs.sp[-2], NULL);
 52911:         THROW();
 52894:     }
 52894: 
 53081:     f.regs.sp[-3].setBoolean(js_IsDelegate(f.cx, &lref.toObject(), f.regs.sp[-3]));
 52894: }
 52781: 
 52781: void JS_FASTCALL
 52785: stubs::EnterBlock(VMFrame &f, JSObject *obj)
 52785: {
 69223:     FrameRegs &regs = f.regs;
100006:     StackFrame *fp = f.fp();
 98921:     JS_ASSERT(!f.regs.inlined());
 98921: 
 86483:     StaticBlockObject &blockObj = obj->asStaticBlock();
100006:     if (!fp->pushBlock(f.cx, blockObj))
100006:         THROW();
 86078: 
 86078:     if (*regs.pc == JSOP_ENTERBLOCK) {
100006:         JS_ASSERT(fp->base() + blockObj.stackDepth() == regs.sp);
 86483:         Value *vp = regs.sp + blockObj.slotCount();
100006:         JS_ASSERT(regs.sp < vp);
100006:         JS_ASSERT(vp <= fp->slots() + fp->script()->nslots);
 52785:         SetValueRangeToUndefined(regs.sp, vp);
 52785:         regs.sp = vp;
100006:     } else if (*regs.pc == JSOP_ENTERLET0) {
100006:         JS_ASSERT(regs.fp()->base() + blockObj.stackDepth() + blockObj.slotCount()
100006:                   == regs.sp);
100006:     } else if (*regs.pc == JSOP_ENTERLET1) {
100006:         JS_ASSERT(regs.fp()->base() + blockObj.stackDepth() + blockObj.slotCount()
100006:                   == regs.sp - 1);
 86078:     }
 52785: }
 52785: 
 52785: void JS_FASTCALL
 86077: stubs::LeaveBlock(VMFrame &f)
 52785: {
 98921:     f.fp()->popBlock(f.cx);
 52785: }
 52785: 
 87654: inline void *
 87654: FindNativeCode(VMFrame &f, jsbytecode *target)
 87654: {
 87654:     void* native = f.fp()->script()->nativeCodeForPC(f.fp()->isConstructing(), target);
 87654:     if (native)
 87654:         return native;
 87654: 
 87983:     uint32_t sourceOffset = f.pc() - f.script()->code;
 87983:     uint32_t targetOffset = target - f.script()->code;
 87654: 
 87983:     CrossChunkEdge *edges = f.jit()->edges();
 87983:     for (size_t i = 0; i < f.jit()->nedges; i++) {
 87983:         const CrossChunkEdge &edge = edges[i];
 87983:         if (edge.source == sourceOffset && edge.target == targetOffset)
 87983:             return edge.shimLabel;
 87983:     }
 87983: 
 87983:     JS_NOT_REACHED("Missing edge");
 87983:     return NULL;
 87654: }
 87654: 
 52793: void * JS_FASTCALL
 52793: stubs::LookupSwitch(VMFrame &f, jsbytecode *pc)
 52793: {
 52793:     jsbytecode *jpc = pc;
 53840:     JSScript *script = f.fp()->script();
 52793: 
 52793:     /* This is correct because the compiler adjusts the stack beforehand. */
 52793:     Value lval = f.regs.sp[-1];
 52793: 
 87654:     if (!lval.isPrimitive())
 87654:         return FindNativeCode(f, pc + GET_JUMP_OFFSET(pc));
 52793: 
 52793:     JS_ASSERT(pc[0] == JSOP_LOOKUPSWITCH);
 52793: 
 52793:     pc += JUMP_OFFSET_LEN;
 84755:     uint32_t npairs = GET_UINT16(pc);
 52793:     pc += UINT16_LEN;
 52793: 
 52793:     JS_ASSERT(npairs);
 52793: 
 52793:     if (lval.isString()) {
 59890:         JSLinearString *str = lval.toString()->ensureLinear(f.cx);
 59890:         if (!str)
 59890:             THROWV(NULL);
 84755:         for (uint32_t i = 1; i <= npairs; i++) {
 90965:             Value rval = script->getConst(GET_UINT32_INDEX(pc));
 90965:             pc += UINT32_INDEX_LEN;
 52793:             if (rval.isString()) {
 64345:                 JSLinearString *rhs = &rval.toString()->asLinear();
 87654:                 if (rhs == str || EqualStrings(str, rhs))
 87654:                     return FindNativeCode(f, jpc + GET_JUMP_OFFSET(pc));
 52793:             }
 52793:             pc += JUMP_OFFSET_LEN;
 52793:         }
 52793:     } else if (lval.isNumber()) {
 53081:         double d = lval.toNumber();
 84755:         for (uint32_t i = 1; i <= npairs; i++) {
 90965:             Value rval = script->getConst(GET_UINT32_INDEX(pc));
 90965:             pc += UINT32_INDEX_LEN;
 87654:             if (rval.isNumber() && d == rval.toNumber())
 87654:                 return FindNativeCode(f, jpc + GET_JUMP_OFFSET(pc));
 52793:             pc += JUMP_OFFSET_LEN;
 52793:         }
 52793:     } else {
 84755:         for (uint32_t i = 1; i <= npairs; i++) {
 90965:             Value rval = script->getConst(GET_UINT32_INDEX(pc));
 90965:             pc += UINT32_INDEX_LEN;
 87654:             if (lval == rval)
 87654:                 return FindNativeCode(f, jpc + GET_JUMP_OFFSET(pc));
 52793:             pc += JUMP_OFFSET_LEN;
 52793:         }
 52793:     }
 52793: 
 87654:     return FindNativeCode(f, jpc + GET_JUMP_OFFSET(jpc));
 52793: }
 52793: 
 52794: void * JS_FASTCALL
 52794: stubs::TableSwitch(VMFrame &f, jsbytecode *origPc)
 52794: {
 52794:     jsbytecode * const originalPC = origPc;
 77438: 
 87671:     DebugOnly<JSOp> op = JSOp(*originalPC);
 86877:     JS_ASSERT(op == JSOP_TABLESWITCH);
 77438: 
 86877:     uint32_t jumpOffset = GET_JUMP_OFFSET(originalPC);
 86877:     jsbytecode *pc = originalPC + JUMP_OFFSET_LEN;
 52794: 
 52794:     /* Note: compiler adjusts the stack beforehand. */
 52794:     Value rval = f.regs.sp[-1];
 52794: 
 90965:     int32_t tableIdx;
 52794:     if (rval.isInt32()) {
 53081:         tableIdx = rval.toInt32();
 52794:     } else if (rval.isDouble()) {
 53081:         double d = rval.toDouble();
 52794:         if (d == 0) {
 52794:             /* Treat -0 (double) as 0. */
 52794:             tableIdx = 0;
 95341:         } else if (!MOZ_DOUBLE_IS_INT32(d, &tableIdx)) {
 52794:             goto finally;
 52794:         }
 52794:     } else {
 52794:         goto finally;
 52794:     }
 52794: 
 52794:     {
 91450:         int32_t low = GET_JUMP_OFFSET(pc);
 52794:         pc += JUMP_OFFSET_LEN;
 91450:         int32_t high = GET_JUMP_OFFSET(pc);
 52794:         pc += JUMP_OFFSET_LEN;
 52794: 
 52794:         tableIdx -= low;
 91688:         if ((uint32_t) tableIdx < (uint32_t)(high - low + 1)) {
 86877:             pc += JUMP_OFFSET_LEN * tableIdx;
 86877:             if (uint32_t candidateOffset = GET_JUMP_OFFSET(pc))
 52794:                 jumpOffset = candidateOffset;
 52794:         }
 52794:     }
 52794: 
 52794: finally:
 58993:     /* Provide the native address. */
 87654:     return FindNativeCode(f, originalPC + jumpOffset);
 52794: }
 52794: 
 52874: void JS_FASTCALL
 52916: stubs::Pos(VMFrame &f)
 52916: {
 73894:     if (!ToNumber(f.cx, &f.regs.sp[-1]))
 52916:         THROW();
 77343:     if (!f.regs.sp[-1].isInt32())
 77391:         TypeScript::MonitorOverflow(f.cx, f.script(), f.pc());
 52916: }
 52916: 
 53037: void JS_FASTCALL
 95355: stubs::DelName(VMFrame &f, PropertyName *name_)
 54409: {
 99421:     RootedObject scopeObj(f.cx, f.cx->stack.currentScriptedScopeChain());
 99421:     RootedPropertyName name(f.cx, name_);
 95355: 
 54409:     JSObject *obj, *obj2;
 54409:     JSProperty *prop;
 95355:     if (!FindProperty(f.cx, name, scopeObj, &obj, &obj2, &prop))
 54409:         THROW();
 54409: 
 54409:     /* Strict mode code should never contain JSOP_DELNAME opcodes. */
 77343:     JS_ASSERT(!f.script()->strictModeCode);
 54409: 
 54409:     /* ECMA says to return true if name is undefined or inherited. */
 54409:     f.regs.sp++;
 54409:     f.regs.sp[-1] = BooleanValue(true);
 54409:     if (prop) {
 86542:         if (!obj->deleteProperty(f.cx, name, &f.regs.sp[-1], false))
 54409:             THROW();
 54409:     }
 54409: }
 54409: 
 54406: template<JSBool strict>
 54406: void JS_FASTCALL
 98960: stubs::DelProp(VMFrame &f, PropertyName *name_)
 54406: {
 54406:     JSContext *cx = f.cx;
 99421:     RootedPropertyName name(cx, name_);
 54406: 
 86855:     JSObject *obj = ValueToObject(cx, f.regs.sp[-1]);
 54406:     if (!obj)
 54406:         THROW();
 54406: 
 54406:     Value rval;
 86542:     if (!obj->deleteProperty(cx, name, &rval, strict))
 54406:         THROW();
 54406: 
 54406:     f.regs.sp[-1] = rval;
 54406: }
 54406: 
 86542: template void JS_FASTCALL stubs::DelProp<true>(VMFrame &f, PropertyName *name);
 86542: template void JS_FASTCALL stubs::DelProp<false>(VMFrame &f, PropertyName *name);
 54406: 
 54406: template<JSBool strict>
 54406: void JS_FASTCALL
 54406: stubs::DelElem(VMFrame &f)
 54406: {
 54406:     JSContext *cx = f.cx;
 54406: 
 86855:     JSObject *obj = ValueToObject(cx, f.regs.sp[-2]);
 54406:     if (!obj)
 54406:         THROW();
 54406: 
 86790:     const Value &propval = f.regs.sp[-1];
 86790:     Value &rval = f.regs.sp[-2];
 54406: 
 86790:     if (!obj->deleteByValue(cx, propval, &rval, strict))
 54406:         THROW();
 54406: }
 54406: 
 54408: void JS_FASTCALL
 89817: stubs::DefVarOrConst(VMFrame &f, PropertyName *dn)
 54408: {
 91237:     unsigned attrs = JSPROP_ENUMERATE;
 90230:     if (!f.fp()->isEvalFrame())
 90230:         attrs |= JSPROP_PERMANENT;
 90230:     if (JSOp(*f.regs.pc) == JSOP_DEFCONST)
 90230:         attrs |= JSPROP_READONLY;
 90230: 
 90230:     JSObject &obj = f.fp()->varObj();
 90230: 
 99421:     if (!DefVarOrConstOperation(f.cx, RootedObject(f.cx, &obj), dn, attrs))
 54408:         THROW();
 54408: }
 54408: 
 57795: void JS_FASTCALL
 86542: stubs::SetConst(VMFrame &f, PropertyName *name)
 57795: {
 57795:     JSContext *cx = f.cx;
 57795: 
 71694:     JSObject *obj = &f.fp()->varObj();
 57795:     const Value &ref = f.regs.sp[-1];
 77343: 
 86542:     if (!obj->defineProperty(cx, name, ref, JS_PropertyStub, JS_StrictPropertyStub,
 86542:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY))
 86542:     {
 57795:         THROW();
 57795:     }
 57795: }
 57795: 
 54413: JSBool JS_FASTCALL
 54413: stubs::In(VMFrame &f)
 54413: {
 54413:     JSContext *cx = f.cx;
 54413: 
 54413:     const Value &rref = f.regs.sp[-1];
 54413:     if (!rref.isObject()) {
 54413:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rref, NULL);
 54413:         THROWV(JS_FALSE);
 54413:     }
 54413: 
 54413:     JSObject *obj = &rref.toObject();
 99421:     RootedId id(cx);
 98960:     if (!FetchElementId(f.cx, obj, f.regs.sp[-2], id.address(), &f.regs.sp[-2]))
 54413:         THROWV(JS_FALSE);
 54413: 
 54413:     JSObject *obj2;
 54413:     JSProperty *prop;
 80442:     if (!obj->lookupGeneric(cx, id, &obj2, &prop))
 54413:         THROWV(JS_FALSE);
 54413: 
 56568:     return !!prop;
 54413: }
 54413: 
 54406: template void JS_FASTCALL stubs::DelElem<true>(VMFrame &f);
 54406: template void JS_FASTCALL stubs::DelElem<false>(VMFrame &f);
 54406: 
 60211: void JS_FASTCALL
 84755: stubs::TypeBarrierHelper(VMFrame &f, uint32_t which)
 77343: {
 77343:     JS_ASSERT(which == 0 || which == 1);
 77343: 
 77343:     /* The actual pushed value is at sp[0], fix up the stack. See finishBarrier. */
 77343:     Value &result = f.regs.sp[-1 - (int)which];
 77343:     result = f.regs.sp[0];
 77343: 
 77343:     /*
 77343:      * Break type barriers at this bytecode if we have added many objects to
 77343:      * the target already. This isn't needed if inference results for the
 77343:      * script have been destroyed, as we will reanalyze and prune type barriers
 77343:      * as they are regenerated.
 77343:      */
 77391:     if (f.script()->hasAnalysis() && f.script()->analysis()->ranInference()) {
 77343:         AutoEnterTypeInference enter(f.cx);
 77391:         f.script()->analysis()->breakTypeBarriers(f.cx, f.pc() - f.script()->code, false);
 77343:     }
 77343: 
 77391:     TypeScript::Monitor(f.cx, f.script(), f.pc(), result);
 77343: }
 77343: 
 78456: void JS_FASTCALL
 84755: stubs::StubTypeHelper(VMFrame &f, int32_t which)
 78456: {
 80962:     const Value &result = f.regs.sp[which];
 78456: 
 78456:     if (f.script()->hasAnalysis() && f.script()->analysis()->ranInference()) {
 78456:         AutoEnterTypeInference enter(f.cx);
 78456:         f.script()->analysis()->breakTypeBarriers(f.cx, f.pc() - f.script()->code, false);
 78456:     }
 78456: 
 78456:     TypeScript::Monitor(f.cx, f.script(), f.pc(), result);
 78456: }
 78456: 
 77343: /*
 77343:  * Variant of TypeBarrierHelper for checking types after making a native call.
 77343:  * The stack is already correct, and no fixup should be performed.
 77343:  */
 77343: void JS_FASTCALL
 77343: stubs::TypeBarrierReturn(VMFrame &f, Value *vp)
 77343: {
 77391:     TypeScript::Monitor(f.cx, f.script(), f.pc(), vp[0]);
 77343: }
 77343: 
 77343: void JS_FASTCALL
 77343: stubs::NegZeroHelper(VMFrame &f)
 77343: {
 77343:     f.regs.sp[-1].setDouble(-0.0);
 77391:     TypeScript::MonitorOverflow(f.cx, f.script(), f.pc());
 77343: }
 77343: 
 77343: void JS_FASTCALL
 77343: stubs::CheckArgumentTypes(VMFrame &f)
 77343: {
 77343:     StackFrame *fp = f.fp();
 77343:     JSFunction *fun = fp->fun();
 77343:     JSScript *script = fun->script();
 77343:     RecompilationMonitor monitor(f.cx);
 77343: 
 77343:     {
 77343:         /* Postpone recompilations until all args have been updated. */
 77343:         types::AutoEnterTypeInference enter(f.cx);
 77343: 
 77343:         if (!f.fp()->isConstructing())
 77391:             TypeScript::SetThis(f.cx, script, fp->thisValue());
 77343:         for (unsigned i = 0; i < fun->nargs; i++)
100006:             TypeScript::SetArgument(f.cx, script, i, fp->formalArg(i));
 77343:     }
 77343: 
 77343:     if (monitor.recompiled())
 77343:         return;
 77343: 
 77343: #ifdef JS_MONOIC
 77343:     ic::GenerateArgumentCheckStub(f);
 77343: #endif
 77343: }
 77343: 
 77343: #ifdef DEBUG
 77343: void JS_FASTCALL
 77343: stubs::AssertArgumentTypes(VMFrame &f)
 77343: {
 77343:     StackFrame *fp = f.fp();
 77343:     JSFunction *fun = fp->fun();
 77343:     JSScript *script = fun->script();
 77343: 
 77432:     /*
 77432:      * Don't check the type of 'this' for constructor frames, the 'this' value
 77432:      * has not been constructed yet.
 77432:      */
 77432:     if (!fp->isConstructing()) {
 77353:         Type type = GetValueType(f.cx, fp->thisValue());
 77391:         if (!TypeScript::ThisTypes(script)->hasType(type))
 77343:             TypeFailure(f.cx, "Missing type for this: %s", TypeString(type));
 77432:     }
 77343: 
 77343:     for (unsigned i = 0; i < fun->nargs; i++) {
100006:         Type type = GetValueType(f.cx, fp->formalArg(i));
 77391:         if (!TypeScript::ArgTypes(script, i)->hasType(type))
 77343:             TypeFailure(f.cx, "Missing type for arg %d: %s", i, TypeString(type));
 77343:     }
 77343: }
 77343: #endif
 77343: 
 77343: /*
 77343:  * These two are never actually called, they just give us a place to rejoin if
 77343:  * there is an invariant failure when initially entering a loop.
 77343:  */
 77343: void JS_FASTCALL stubs::MissedBoundsCheckEntry(VMFrame &f) {}
 77343: void JS_FASTCALL stubs::MissedBoundsCheckHead(VMFrame &f) {}
 77343: 
 77343: void * JS_FASTCALL
 77343: stubs::InvariantFailure(VMFrame &f, void *rval)
 77343: {
 77343:     /*
 77343:      * Patch this call to the return site of the call triggering the invariant
 77343:      * failure (or a MissedBoundsCheck* function if the failure occurred on
 77343:      * initial loop entry), and trigger a recompilation which will then
 77343:      * redirect to the rejoin point for that call. We want to make things look
 77343:      * to the recompiler like we are still inside that call, and that after
 77343:      * recompilation we will return to the call's rejoin point.
 77343:      */
 77343:     void *repatchCode = f.scratch;
 77343:     JS_ASSERT(repatchCode);
 77343:     void **frameAddr = f.returnAddressLocation();
 77343:     *frameAddr = repatchCode;
 77343: 
 77343:     /* Recompile the outermost script, and don't hoist any bounds checks. */
 77343:     JSScript *script = f.fp()->script();
 77343:     JS_ASSERT(!script->failedBoundsCheck);
 77343:     script->failedBoundsCheck = true;
 77343: 
 77398:     ExpandInlineFrames(f.cx->compartment);
 77343: 
 94740:     mjit::Recompiler::clearStackReferences(f.cx->runtime->defaultFreeOp(), script);
 94740:     mjit::ReleaseScriptCode(f.cx->runtime->defaultFreeOp(), script);
 77343: 
 77343:     /* Return the same value (if any) as the call triggering the invariant failure. */
 77343:     return rval;
 77343: }
 77343: 
 77343: void JS_FASTCALL
 60211: stubs::Exception(VMFrame &f)
 60211: {
 77360:     // Check the interrupt flag to allow interrupting deeply nested exception
 77360:     // handling.
 88135:     if (f.cx->runtime->interrupt && !js_HandleExecutionInterrupt(f.cx))
 77360:         THROW();
 77360: 
 60211:     f.regs.sp[0] = f.cx->getPendingException();
 60211:     f.cx->clearPendingException();
 60211: }
 77343: 
 77884: void JS_FASTCALL
100006: stubs::FunctionFramePrologue(VMFrame &f)
 77884: {
100006:     if (!f.fp()->functionPrologue(f.cx))
 77884:         THROW();
 77884: }
 77884: 
 77884: void JS_FASTCALL
100006: stubs::FunctionFrameEpilogue(VMFrame &f)
 77884: {
100006:     f.fp()->functionEpilogue(f.cx);
 77884: }
 77884: 
 77884: void JS_FASTCALL
 77884: stubs::AnyFrameEpilogue(VMFrame &f)
 77884: {
 83374:     /*
 84067:      * On the normal execution path, emitReturn calls ScriptDebugEpilogue
100006:      * and inlines ScriptEpilogue. This function implements forced early
 84067:      * returns, so it must have the same effect.
 83374:      */
 84067:     bool ok = true;
 84067:     if (f.cx->compartment->debugMode())
 84067:         ok = js::ScriptDebugEpilogue(f.cx, f.fp(), ok);
100006:     ok = ScriptEpilogue(f.cx, f.fp(), ok);
 84067:     if (!ok)
 83374:         THROW();
100006:     if (f.fp()->isNonEvalFunctionFrame())
100006:         f.fp()->functionEpilogue(f.cx);
 77884: }
 77884: 
 60164: template <bool Clamped>
 84755: int32_t JS_FASTCALL
 60164: stubs::ConvertToTypedInt(JSContext *cx, Value *vp)
 60164: {
 60164:     JS_ASSERT(!vp->isInt32());
 60164: 
 60164:     if (vp->isDouble()) {
 60164:         if (Clamped)
 95109:             return ClampDoubleToUint8(vp->toDouble());
 97045:         return ToInt32(vp->toDouble());
 60164:     }
 60164: 
 60164:     if (vp->isNull() || vp->isObject() || vp->isUndefined())
 60164:         return 0;
 60164: 
 60164:     if (vp->isBoolean())
 60164:         return vp->toBoolean() ? 1 : 0;
 60164: 
 60164:     JS_ASSERT(vp->isString());
 60164: 
 84755:     int32_t i32 = 0;
 60164: #ifdef DEBUG
 60164:     bool success =
 60164: #endif
 91450:         StringToNumberType<int32_t>(cx, vp->toString(), &i32);
 60164:     JS_ASSERT(success);
 60164: 
 60164:     return i32;
 60164: }
 60164: 
 84755: template int32_t JS_FASTCALL stubs::ConvertToTypedInt<true>(JSContext *, Value *);
 84755: template int32_t JS_FASTCALL stubs::ConvertToTypedInt<false>(JSContext *, Value *);
 60164: 
 60164: void JS_FASTCALL
 60164: stubs::ConvertToTypedFloat(JSContext *cx, Value *vp)
 60164: {
 60164:     JS_ASSERT(!vp->isDouble() && !vp->isInt32());
 60164: 
 60164:     if (vp->isNull()) {
 60164:         vp->setDouble(0);
 60164:     } else if (vp->isObject() || vp->isUndefined()) {
 60164:         vp->setDouble(js_NaN);
 60164:     } else if (vp->isBoolean()) {
 60164:         vp->setDouble(vp->toBoolean() ? 1 : 0);
 60164:     } else {
 60164:         JS_ASSERT(vp->isString());
 60546:         double d = 0;
 60164: #ifdef DEBUG
 60164:         bool success =
 60164: #endif
 60164:             StringToNumberType<double>(cx, vp->toString(), &d);
 60164:         JS_ASSERT(success);
 60164:         vp->setDouble(d);
 60164:     }
 60164: }
 82129: 
 82129: void JS_FASTCALL
 82129: stubs::WriteBarrier(VMFrame &f, Value *addr)
 82129: {
 90302:     gc::MarkValueUnbarriered(f.cx->compartment->barrierTracer(), addr, "write barrier");
 82129: }
 82129: 
 82129: void JS_FASTCALL
 82129: stubs::GCThingWriteBarrier(VMFrame &f, Value *addr)
 82129: {
 82129:     gc::Cell *cell = (gc::Cell *)addr->toGCThing();
 82129:     if (cell && !cell->isMarked())
 90302:         gc::MarkValueUnbarriered(f.cx->compartment->barrierTracer(), addr, "write barrier");
 82129: }
