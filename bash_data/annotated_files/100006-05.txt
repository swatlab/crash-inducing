 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 17755:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS bytecode generation.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: 
     1: #ifdef HAVE_MEMORY_H
     1: #include <memory.h>
     1: #endif
 27012: #include <new>
     1: #include <string.h>
 80468: 
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsatom.h"
  8817: #include "jsbool.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsfun.h"
     1: #include "jsnum.h"
     1: #include "jsopcode.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
 42774: #include "jsautooplen.h"        // generated headers last
 15453: 
 80506: #include "ds/LifoAlloc.h"
 80966: #include "frontend/BytecodeEmitter.h"
 80506: #include "frontend/Parser.h"
 80506: #include "frontend/TokenStream.h"
 80506: #include "vm/RegExpObject.h"
 80506: 
 59962: #include "jsatominlines.h"
 47497: #include "jsscopeinlines.h"
 59968: #include "jsscriptinlines.h"
 47497: 
 72579: #include "frontend/ParseMaps-inl.h"
 95100: #include "frontend/ParseNode-inl.h"
 98180: #include "frontend/TreeContext-inl.h"
 72579: 
     1: /* Allocation chunk counts, must be powers of two in general. */
 77950: #define BYTECODE_CHUNK_LENGTH  1024    /* initial bytecode chunk length */
 77950: #define SRCNOTE_CHUNK_LENGTH   1024    /* initial srcnote chunk length */
     1: 
     1: /* Macros to compute byte sizes from typed element counts. */
     1: #define BYTECODE_SIZE(n)        ((n) * sizeof(jsbytecode))
     1: #define SRCNOTE_SIZE(n)         ((n) * sizeof(jssrcnote))
     1: 
 40320: using namespace js;
 54707: using namespace js::gc;
 80632: using namespace js::frontend;
 80632: 
  3025: static JSBool
 91237: NewTryNote(JSContext *cx, BytecodeEmitter *bce, JSTryNoteKind kind, unsigned stackDepth,
 80631:            size_t start, size_t end);
  3025: 
 54855: static JSBool
 91237: SetSrcNoteOffset(JSContext *cx, BytecodeEmitter *bce, unsigned index, unsigned which, ptrdiff_t offset);
 80632: 
 98463: BytecodeEmitter::BytecodeEmitter(Parser *parser, SharedContext *sc, unsigned lineno,
 98463:                                  bool noScriptRval, bool needScriptGlobal)
 98445:   : sc(sc),
 98445:     parent(NULL),
 98181:     parser(parser),
 98445:     atomIndices(sc->context),
 27012:     stackDepth(0), maxStackDepth(0),
 27012:     ntrynotes(0), lastTryNode(NULL),
 27012:     arrayCompDepth(0),
 41867:     emitLevel(0),
 98445:     constMap(sc->context),
 98445:     constList(sc->context),
 80990:     globalScope(NULL),
 98445:     closedArgs(sc->context),
 98445:     closedVars(sc->context),
 98463:     typesetCount(0),
 98463:     noScriptRval(noScriptRval),
 98479:     needScriptGlobal(needScriptGlobal),
 98479:     hasSingletons(false)
     1: {
 27012:     memset(&prolog, 0, sizeof prolog);
 27012:     memset(&main, 0, sizeof main);
 27012:     current = &main;
 27012:     firstLine = prolog.currentLine = main.currentLine = lineno;
 27012: }
 27012: 
 72579: bool
 98445: BytecodeEmitter::init()
 41867: {
 98445:     return constMap.init() && atomIndices.ensureMap(sc->context);
 80631: }
 80631: 
 80966: BytecodeEmitter::~BytecodeEmitter()
     1: {
 98445:     JSContext *cx = sc->context;
 72579: 
 77950:     cx->free_(prolog.base);
 77950:     cx->free_(prolog.notes);
 77950:     cx->free_(main.base);
 77950:     cx->free_(main.notes);
     1: }
     1: 
     1: static ptrdiff_t
 80966: EmitCheck(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t delta)
 80966: {
 80966:     jsbytecode *base = bce->base();
 77950:     jsbytecode *newbase;
 80966:     jsbytecode *next = bce->next();
 80966:     jsbytecode *limit = bce->limit();
 77950:     ptrdiff_t offset = next - base;
 77950:     size_t minlength = offset + delta;
 77950: 
     1:     if (next + delta > limit) {
 77950:         size_t newlength;
     1:         if (!base) {
 77950:             JS_ASSERT(!next && !limit);
 77950:             newlength = BYTECODE_CHUNK_LENGTH;
 77950:             if (newlength < minlength)     /* make it bigger if necessary */
 77950:                 newlength = RoundUpPow2(minlength);
 77950:             newbase = (jsbytecode *) cx->malloc_(BYTECODE_SIZE(newlength));
     1:         } else {
 77950:             JS_ASSERT(base <= next && next <= limit);
 77950:             newlength = (limit - base) * 2;
 77950:             if (newlength < minlength)     /* make it bigger if necessary */
 77950:                 newlength = RoundUpPow2(minlength);
 77950:             newbase = (jsbytecode *) cx->realloc_(base, BYTECODE_SIZE(newlength));
 77950:         }
 77950:         if (!newbase) {
 71371:             js_ReportOutOfMemory(cx);
     1:             return -1;
     1:         }
 77950:         JS_ASSERT(newlength >= size_t(offset + delta));
 80966:         bce->current->base = newbase;
 80966:         bce->current->limit = newbase + newlength;
 80966:         bce->current->next = newbase + offset;
     1:     }
     1:     return offset;
     1: }
     1: 
 86483: static StaticBlockObject &
 98445: CurrentBlock(SharedContext *sc)
 98445: {
 98445:     JS_ASSERT(sc->topStmt->type == STMT_BLOCK || sc->topStmt->type == STMT_SWITCH);
 98445:     JS_ASSERT(sc->topStmt->blockObj->isStaticBlock());
 98445:     return *sc->topStmt->blockObj;
 86078: }
 86078: 
     1: static void
 80966: UpdateDepth(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t target)
     1: {
 86078:     jsbytecode *pc = bce->code(target);
 86078:     JSOp op = (JSOp) *pc;
 86078:     const JSCodeSpec *cs = &js_CodeSpec[op];
 86078: 
 86078: 
 86078:     if (cs->format & JOF_TMPSLOT_MASK) {
 86078:         /*
 86078:          * An opcode may temporarily consume stack space during execution.
 86078:          * Account for this in maxStackDepth separately from uses/defs here.
 86078:          */
 91237:         unsigned depth = (unsigned) bce->stackDepth +
 82644:                       ((cs->format & JOF_TMPSLOT_MASK) >> JOF_TMPSLOT_SHIFT);
 80966:         if (depth > bce->maxStackDepth)
 80966:             bce->maxStackDepth = depth;
  2126:     }
 23075: 
 86078:     /*
 86078:      * Specially handle any case that would call js_GetIndexFromBytecode since
 86078:      * it requires a well-formed script. This allows us to safely pass NULL as
 86078:      * the 'script' parameter.
 86078:      */
 91237:     int nuses, ndefs;
 86078:     if (op == JSOP_ENTERBLOCK) {
 86078:         nuses = 0;
 98445:         ndefs = CurrentBlock(bce->sc).slotCount();
 86078:     } else if (op == JSOP_ENTERLET0) {
 98445:         nuses = ndefs = CurrentBlock(bce->sc).slotCount();
 86078:     } else if (op == JSOP_ENTERLET1) {
 98445:         nuses = ndefs = CurrentBlock(bce->sc).slotCount() + 1;
 86078:     } else {
 86078:         nuses = StackUses(NULL, pc);
 86078:         ndefs = StackDefs(NULL, pc);
 86078:     }
 86078: 
 80966:     bce->stackDepth -= nuses;
 80966:     JS_ASSERT(bce->stackDepth >= 0);
 80966:     bce->stackDepth += ndefs;
 91237:     if ((unsigned)bce->stackDepth > bce->maxStackDepth)
 80966:         bce->maxStackDepth = bce->stackDepth;
     1: }
     1: 
 77357: static inline void
 91237: UpdateDecomposeLength(BytecodeEmitter *bce, unsigned start)
 91237: {
 91237:     unsigned end = bce->offset();
 91237:     JS_ASSERT(unsigned(end - start) < 256);
 80966:     bce->code(start)[-1] = end - start;
 77357: }
 77357: 
     1: ptrdiff_t
 80966: frontend::Emit1(JSContext *cx, BytecodeEmitter *bce, JSOp op)
 80966: {
 80966:     ptrdiff_t offset = EmitCheck(cx, bce, 1);
     1: 
     1:     if (offset >= 0) {
 80966:         *bce->current->next++ = (jsbytecode)op;
 80966:         UpdateDepth(cx, bce, offset);
     1:     }
     1:     return offset;
     1: }
     1: 
     1: ptrdiff_t
 80966: frontend::Emit2(JSContext *cx, BytecodeEmitter *bce, JSOp op, jsbytecode op1)
 80966: {
 80966:     ptrdiff_t offset = EmitCheck(cx, bce, 2);
     1: 
     1:     if (offset >= 0) {
 80966:         jsbytecode *next = bce->next();
     1:         next[0] = (jsbytecode)op;
     1:         next[1] = op1;
 80966:         bce->current->next = next + 2;
 80966:         UpdateDepth(cx, bce, offset);
     1:     }
     1:     return offset;
     1: }
     1: 
     1: ptrdiff_t
 80966: frontend::Emit3(JSContext *cx, BytecodeEmitter *bce, JSOp op, jsbytecode op1,
     1:                     jsbytecode op2)
     1: {
 95101:     /* These should filter through EmitVarOp. */
 95101:     JS_ASSERT(JOF_OPTYPE(op) != JOF_QARG);
 95101:     JS_ASSERT(JOF_OPTYPE(op) != JOF_LOCAL);
 95101: 
 80966:     ptrdiff_t offset = EmitCheck(cx, bce, 3);
     1: 
     1:     if (offset >= 0) {
 80966:         jsbytecode *next = bce->next();
     1:         next[0] = (jsbytecode)op;
     1:         next[1] = op1;
     1:         next[2] = op2;
 80966:         bce->current->next = next + 3;
 80966:         UpdateDepth(cx, bce, offset);
     1:     }
     1:     return offset;
     1: }
     1: 
     1: ptrdiff_t
 80966: frontend::EmitN(JSContext *cx, BytecodeEmitter *bce, JSOp op, size_t extra)
     1: {
     1:     ptrdiff_t length = 1 + (ptrdiff_t)extra;
 80966:     ptrdiff_t offset = EmitCheck(cx, bce, length);
     1: 
     1:     if (offset >= 0) {
 80966:         jsbytecode *next = bce->next();
     1:         *next = (jsbytecode)op;
     1:         memset(next + 1, 0, BYTECODE_SIZE(extra));
 80966:         bce->current->next = next + length;
 15279: 
 15279:         /*
 15279:          * Don't UpdateDepth if op's use-count comes from the immediate
 15279:          * operand yet to be stored in the extra bytes after op.
 15279:          */
 15279:         if (js_CodeSpec[op].nuses >= 0)
 80966:             UpdateDepth(cx, bce, offset);
     1:     }
     1:     return offset;
     1: }
     1: 
 86877: static ptrdiff_t
 86877: EmitJump(JSContext *cx, BytecodeEmitter *bce, JSOp op, ptrdiff_t off)
 86877: {
 86877:     ptrdiff_t offset = EmitCheck(cx, bce, 5);
 86877: 
 86877:     if (offset >= 0) {
 86877:         jsbytecode *next = bce->next();
 86877:         next[0] = (jsbytecode)op;
 86877:         SET_JUMP_OFFSET(next, off);
 86877:         bce->current->next = next + 5;
 86877:         UpdateDepth(cx, bce, offset);
 86877:     }
 86877:     return offset;
 86877: }
 86877: 
     1: /* XXX too many "... statement" L10N gaffes below -- fix via js.msg! */
     1: const char js_with_statement_str[] = "with statement";
     1: const char js_finally_block_str[]  = "finally block";
     1: const char js_script_str[]         = "script";
     1: 
     1: static const char *statementName[] = {
     1:     "label statement",       /* LABEL */
     1:     "if statement",          /* IF */
     1:     "else statement",        /* ELSE */
 11672:     "destructuring body",    /* BODY */
     1:     "switch statement",      /* SWITCH */
     1:     "block",                 /* BLOCK */
     1:     js_with_statement_str,   /* WITH */
     1:     "catch block",           /* CATCH */
     1:     "try block",             /* TRY */
     1:     js_finally_block_str,    /* FINALLY */
     1:     js_finally_block_str,    /* SUBROUTINE */
     1:     "do loop",               /* DO_LOOP */
     1:     "for loop",              /* FOR_LOOP */
     1:     "for/in loop",           /* FOR_IN_LOOP */
     1:     "while loop",            /* WHILE_LOOP */
     1: };
     1: 
 11672: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(statementName) == STMT_LIMIT);
 11672: 
     1: static const char *
 98445: StatementName(SharedContext *sc)
 98445: {
 98445:     if (!sc->topStmt)
     1:         return js_script_str;
 98445:     return statementName[sc->topStmt->type];
     1: }
     1: 
     1: static void
 98445: ReportStatementTooLarge(JSContext *cx, SharedContext *sc)
     1: {
     1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEED_DIET,
 98445:                          StatementName(sc));
     1: }
     1: 
     1: /*
     1:  * Emit a backpatch op with offset pointing to the previous jump of this type,
     1:  * so that we can walk back up the chain fixing up the op and jump offset.
     1:  */
     1: static ptrdiff_t
 80966: EmitBackPatchOp(JSContext *cx, BytecodeEmitter *bce, JSOp op, ptrdiff_t *lastp)
     1: {
     1:     ptrdiff_t offset, delta;
     1: 
 80966:     offset = bce->offset();
     1:     delta = offset - *lastp;
     1:     *lastp = offset;
     1:     JS_ASSERT(delta > 0);
 80966:     return EmitJump(cx, bce, op, delta);
     1: }
     1: 
 80632: /* A macro for inlining at the top of EmitTree (whence it came). */
 80966: #define UPDATE_LINE_NUMBER_NOTES(cx, bce, line)                               \
     1:     JS_BEGIN_MACRO                                                            \
 91237:         unsigned line_ = (line);                                                 \
 91237:         unsigned delta_ = line_ - bce->currentLine();                            \
     1:         if (delta_ != 0) {                                                    \
     1:             /*                                                                \
     1:              * Encode any change in the current source line number by using   \
     1:              * either several SRC_NEWLINE notes or just one SRC_SETLINE note, \
     1:              * whichever consumes less space.                                 \
     1:              *                                                                \
     1:              * NB: We handle backward line number deltas (possible with for   \
     1:              * loops where the update part is emitted after the body, but its \
     1:              * line number is <= any line number in the body) here by letting \
     1:              * unsigned delta_ wrap to a very large number, which triggers a  \
     1:              * SRC_SETLINE.                                                   \
     1:              */                                                               \
 80966:             bce->current->currentLine = line_;                                \
 91237:             if (delta_ >= (unsigned)(2 + ((line_ > SN_3BYTE_OFFSET_MASK)<<1))) { \
 80966:                 if (NewSrcNote2(cx, bce, SRC_SETLINE, (ptrdiff_t)line_) < 0)  \
     1:                     return JS_FALSE;                                          \
     1:             } else {                                                          \
     1:                 do {                                                          \
 80966:                     if (NewSrcNote(cx, bce, SRC_NEWLINE) < 0)                 \
     1:                         return JS_FALSE;                                      \
     1:                 } while (--delta_ != 0);                                      \
     1:             }                                                                 \
     1:         }                                                                     \
     1:     JS_END_MACRO
     1: 
     1: /* A function, so that we avoid macro-bloating all the other callsites. */
     1: static JSBool
 91237: UpdateLineNumberNotes(JSContext *cx, BytecodeEmitter *bce, unsigned line)
 80966: {
 80966:     UPDATE_LINE_NUMBER_NOTES(cx, bce, line);
     1:     return JS_TRUE;
     1: }
     1: 
 75502: static ptrdiff_t
 87961: EmitLoopHead(JSContext *cx, BytecodeEmitter *bce, ParseNode *nextpn)
 75502: {
 75502:     if (nextpn) {
 75502:         /*
 83115:          * Try to give the JSOP_LOOPHEAD the same line number as the next
 75502:          * instruction. nextpn is often a block, in which case the next
 75502:          * instruction typically comes from the first statement inside.
 75502:          */
 82873:         JS_ASSERT_IF(nextpn->isKind(PNK_STATEMENTLIST), nextpn->isArity(PN_LIST));
 82873:         if (nextpn->isKind(PNK_STATEMENTLIST) && nextpn->pn_head)
 75502:             nextpn = nextpn->pn_head;
 80966:         if (!UpdateLineNumberNotes(cx, bce, nextpn->pn_pos.begin.lineno))
 75502:             return -1;
 75502:     }
 75502: 
 83115:     return Emit1(cx, bce, JSOP_LOOPHEAD);
 75502: }
 75502: 
 87961: static bool
 87961: EmitLoopEntry(JSContext *cx, BytecodeEmitter *bce, ParseNode *nextpn)
 87961: {
 87961:     if (nextpn) {
 87961:         /* Update the line number, as for LOOPHEAD. */
 87961:         JS_ASSERT_IF(nextpn->isKind(PNK_STATEMENTLIST), nextpn->isArity(PN_LIST));
 87961:         if (nextpn->isKind(PNK_STATEMENTLIST) && nextpn->pn_head)
 87961:             nextpn = nextpn->pn_head;
 87961:         if (!UpdateLineNumberNotes(cx, bce, nextpn->pn_pos.begin.lineno))
 87961:             return false;
 87961:     }
 87961: 
 87961:     return Emit1(cx, bce, JSOP_LOOPENTRY) >= 0;
 87961: }
 87961: 
 75502: /*
 77434:  * If op is JOF_TYPESET (see the type barriers comment in jsinfer.h), reserve
 77434:  * a type set to store its result.
 77434:  */
 77434: static inline void
 80966: CheckTypeSet(JSContext *cx, BytecodeEmitter *bce, JSOp op)
 77434: {
 77434:     if (js_CodeSpec[op].format & JOF_TYPESET) {
 80966:         if (bce->typesetCount < UINT16_MAX)
 80966:             bce->typesetCount++;
 77434:     }
 77434: }
 77434: 
 77434: /*
 84755:  * Macro to emit a bytecode followed by a uint16_t immediate operand stored in
 75502:  * big-endian order, used for arg and var numbers as well as for atomIndexes.
 80966:  * NB: We use cx and bce from our caller's lexical environment, and return
 75502:  * false on error.
 75502:  */
 75502: #define EMIT_UINT16_IMM_OP(op, i)                                             \
 75502:     JS_BEGIN_MACRO                                                            \
 80966:         if (Emit3(cx, bce, op, UINT16_HI(i), UINT16_LO(i)) < 0)               \
 75502:             return JS_FALSE;                                                  \
 80966:         CheckTypeSet(cx, bce, op);                                            \
 75502:     JS_END_MACRO
 75502: 
 75502: #define EMIT_UINT16PAIR_IMM_OP(op, i, j)                                      \
 75502:     JS_BEGIN_MACRO                                                            \
 80966:         ptrdiff_t off_ = EmitN(cx, bce, op, 2 * UINT16_LEN);                  \
 75502:         if (off_ < 0)                                                         \
 75502:             return JS_FALSE;                                                  \
 80966:         jsbytecode *pc_ = bce->code(off_);                                    \
 75502:         SET_UINT16(pc_, i);                                                   \
 75502:         pc_ += UINT16_LEN;                                                    \
 75502:         SET_UINT16(pc_, j);                                                   \
 75502:     JS_END_MACRO
 75502: 
 75502: #define EMIT_UINT16_IN_PLACE(offset, op, i)                                   \
 75502:     JS_BEGIN_MACRO                                                            \
 80966:         bce->code(offset)[0] = op;                                            \
 80966:         bce->code(offset)[1] = UINT16_HI(i);                                  \
 80966:         bce->code(offset)[2] = UINT16_LO(i);                                  \
 75502:     JS_END_MACRO
 75502: 
 89253: #define EMIT_UINT32_IN_PLACE(offset, op, i)                                   \
 89253:     JS_BEGIN_MACRO                                                            \
 89253:         bce->code(offset)[0] = op;                                            \
 89253:         bce->code(offset)[1] = jsbytecode(i >> 24);                           \
 89253:         bce->code(offset)[2] = jsbytecode(i >> 16);                           \
 89253:         bce->code(offset)[3] = jsbytecode(i >> 8);                            \
 89253:         bce->code(offset)[4] = jsbytecode(i);                                 \
 89253:     JS_END_MACRO
 89253: 
 75502: static JSBool
 91237: FlushPops(JSContext *cx, BytecodeEmitter *bce, int *npops)
 75502: {
 75502:     JS_ASSERT(*npops != 0);
 80966:     if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 75502:         return JS_FALSE;
 75502:     EMIT_UINT16_IMM_OP(JSOP_POPN, *npops);
 75502:     *npops = 0;
 75502:     return JS_TRUE;
 75502: }
 75502: 
 86078: static bool
 86078: PopIterator(JSContext *cx, BytecodeEmitter *bce)
 86078: {
 86078:     if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 86078:         return false;
 86078:     if (Emit1(cx, bce, JSOP_ENDITER) < 0)
 86078:         return false;
 86078:     return true;
 86078: }
 86078: 
 75502: /*
 75502:  * Emit additional bytecode(s) for non-local jumps.
 75502:  */
 75502: static JSBool
 80966: EmitNonLocalJumpFixup(JSContext *cx, BytecodeEmitter *bce, StmtInfo *toStmt)
 80966: {
 80966:     /*
 80966:      * The non-local jump fixup we emit will unbalance bce->stackDepth, because
 75502:      * the fixup replicates balanced code such as JSOP_LEAVEWITH emitted at the
 80966:      * end of a with statement, so we save bce->stackDepth here and restore it
 75502:      * just before a successful return.
 75502:      */
 91237:     int depth = bce->stackDepth;
 91237:     int npops = 0;
 75502: 
 80966: #define FLUSH_POPS() if (npops && !FlushPops(cx, bce, &npops)) return JS_FALSE
 80966: 
 98445:     for (StmtInfo *stmt = bce->sc->topStmt; stmt != toStmt; stmt = stmt->down) {
 75502:         switch (stmt->type) {
 75502:           case STMT_FINALLY:
 75502:             FLUSH_POPS();
 80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:                 return JS_FALSE;
 80966:             if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
 75502:                 return JS_FALSE;
 75502:             break;
 75502: 
 75502:           case STMT_WITH:
 75502:             /* There's a With object on the stack that we need to pop. */
 75502:             FLUSH_POPS();
 80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:                 return JS_FALSE;
 80966:             if (Emit1(cx, bce, JSOP_LEAVEWITH) < 0)
 75502:                 return JS_FALSE;
 75502:             break;
 75502: 
 75502:           case STMT_FOR_IN_LOOP:
 75502:             FLUSH_POPS();
 86078:             if (!PopIterator(cx, bce))
 75502:                 return JS_FALSE;
 75502:             break;
 75502: 
 75502:           case STMT_SUBROUTINE:
 75502:             /*
 75502:              * There's a [exception or hole, retsub pc-index] pair on the
 75502:              * stack that we need to pop.
 75502:              */
 75502:             npops += 2;
 75502:             break;
 75502: 
 75502:           default:;
 75502:         }
 75502: 
 75502:         if (stmt->flags & SIF_SCOPE) {
 86078:             FLUSH_POPS();
 91237:             unsigned blockObjCount = stmt->blockObj->slotCount();
 86078:             if (stmt->flags & SIF_FOR_BLOCK) {
 86078:                 /*
 86078:                  * For a for-let-in statement, pushing/popping the block is
 86078:                  * interleaved with JSOP_(END)ITER. Just handle both together
 86078:                  * here and skip over the enclosing STMT_FOR_IN_LOOP.
 86078:                  */
 86078:                 JS_ASSERT(stmt->down->type == STMT_FOR_IN_LOOP);
 86078:                 stmt = stmt->down;
 86078:                 if (stmt == toStmt)
 86078:                     break;
 86078:                 if (Emit1(cx, bce, JSOP_LEAVEFORLETIN) < 0)
 86078:                     return JS_FALSE;
 86078:                 if (!PopIterator(cx, bce))
 86078:                     return JS_FALSE;
 86078:                 if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 86078:                     return JS_FALSE;
 86078:                 EMIT_UINT16_IMM_OP(JSOP_POPN, blockObjCount);
 86078:             } else {
 75502:                 /* There is a Block object with locals on the stack to pop. */
 80966:                 if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:                     return JS_FALSE;
 86078:                 EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, blockObjCount);
 86078:             }
 75502:         }
 75502:     }
 75502: 
 75502:     FLUSH_POPS();
 80966:     bce->stackDepth = depth;
 75502:     return JS_TRUE;
 75502: 
 75502: #undef FLUSH_POPS
 75502: }
 75502: 
 75510: static const jsatomid INVALID_ATOMID = -1;
 75510: 
 75502: static ptrdiff_t
 80966: EmitGoto(JSContext *cx, BytecodeEmitter *bce, StmtInfo *toStmt, ptrdiff_t *lastp,
 80631:          jsatomid labelIndex = INVALID_ATOMID, SrcNoteType noteType = SRC_NULL)
 75502: {
 91237:     int index;
 75502: 
 80966:     if (!EmitNonLocalJumpFixup(cx, bce, toStmt))
 75502:         return -1;
 75502: 
 75510:     if (labelIndex != INVALID_ATOMID)
 80966:         index = NewSrcNote2(cx, bce, noteType, ptrdiff_t(labelIndex));
 75502:     else if (noteType != SRC_NULL)
 80966:         index = NewSrcNote(cx, bce, noteType);
 75502:     else
 75502:         index = 0;
 75502:     if (index < 0)
 75502:         return -1;
 75502: 
 86077:     return EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, lastp);
 75502: }
 75502: 
 75502: static JSBool
 80966: BackPatch(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t last, jsbytecode *target, jsbytecode op)
 75502: {
 75502:     jsbytecode *pc, *stop;
 75502:     ptrdiff_t delta, span;
 75502: 
 80966:     pc = bce->code(last);
 80966:     stop = bce->code(-1);
 75502:     while (pc != stop) {
 86877:         delta = GET_JUMP_OFFSET(pc);
 75502:         span = target - pc;
 86877:         SET_JUMP_OFFSET(pc, span);
 75502:         *pc = op;
 75502:         pc -= delta;
 75502:     }
 75502:     return JS_TRUE;
 75502: }
 75502: 
 75502: JSBool
 80966: frontend::PopStatementBCE(JSContext *cx, BytecodeEmitter *bce)
 80966: {
 98445:     StmtInfo *stmt = bce->sc->topStmt;
 75502:     if (!STMT_IS_TRYING(stmt) &&
 80966:         (!BackPatch(cx, bce, stmt->breaks, bce->next(), JSOP_GOTO) ||
 86877:          !BackPatch(cx, bce, stmt->continues, bce->code(stmt->update), JSOP_GOTO)))
 86877:     {
 75502:         return JS_FALSE;
 75502:     }
 98445:     PopStatementSC(bce->sc);
 75502:     return JS_TRUE;
 75502: }
 75502: 
 75502: JSBool
 80966: frontend::DefineCompileTimeConstant(JSContext *cx, BytecodeEmitter *bce, JSAtom *atom, ParseNode *pn)
 75502: {
 75502:     /* XXX just do numbers for now */
 82024:     if (pn->isKind(PNK_NUMBER)) {
 80966:         if (!bce->constMap.put(atom, NumberValue(pn->pn_dval)))
 75502:             return JS_FALSE;
 75502:     }
 75502:     return JS_TRUE;
 75502: }
 75502: 
 75502: /*
 75502:  * The function sets vp to NO_CONSTANT when the atom does not corresponds to a
 75502:  * name defining a constant.
 75502:  */
 75502: static JSBool
 80966: LookupCompileTimeConstant(JSContext *cx, BytecodeEmitter *bce, JSAtom *atom, Value *constp)
 80966: {
 80966:     /*
 80966:      * Chase down the bce stack, but only until we reach the outermost bce.
 75502:      * This enables propagating consts from top-level into switch cases in a
 75502:      * function compiled along with the top-level script.
 75502:      */
 75502:     constp->setMagic(JS_NO_CONSTANT);
 75502:     do {
 98476:         if (bce->sc->inFunction || bce->parser->compileAndGo) {
 75502:             /* XXX this will need revising if 'const' becomes block-scoped. */
 98445:             StmtInfo *stmt = LexicalLookup(bce->sc, atom, NULL);
 75502:             if (stmt)
 75502:                 return JS_TRUE;
 75502: 
 80966:             if (BytecodeEmitter::ConstMap::Ptr p = bce->constMap.lookup(atom)) {
 75502:                 JS_ASSERT(!p->value.isMagic(JS_NO_CONSTANT));
 75502:                 *constp = p->value;
 75502:                 return JS_TRUE;
 75502:             }
 75502: 
 75502:             /*
 75502:              * Try looking in the variable object for a direct property that
 75502:              * is readonly and permanent.  We know such a property can't be
 75502:              * shadowed by another property on obj's prototype chain, or a
 75502:              * with object or catch variable; nor can prop's value be changed,
 75502:              * nor can prop be deleted.
 75502:              */
 98476:             if (bce->sc->inFunction) {
 98445:                 if (bce->sc->bindings.hasBinding(cx, atom))
 75502:                     break;
 75502:             } else {
 98464:                 JS_ASSERT(bce->parser->compileAndGo);
 98445:                 JSObject *obj = bce->sc->scopeChain();
 75502: 
 97828:                 const Shape *shape = obj->nativeLookup(cx, AtomToId(atom));
 75502:                 if (shape) {
 75502:                     /*
 75502:                      * We're compiling code that will be executed immediately,
 75502:                      * not re-executed against a different scope chain and/or
 75502:                      * variable object.  Therefore we can get constant values
 75502:                      * from our variable object here.
 75502:                      */
 75502:                     if (!shape->writable() && !shape->configurable() &&
 86009:                         shape->hasDefaultGetter() && shape->hasSlot()) {
 86009:                         *constp = obj->nativeGetSlot(shape->slot());
 75502:                     }
 75502:                 }
 75502: 
 75502:                 if (shape)
 75502:                     break;
 75502:             }
 75502:         }
 98445:         bce = bce->parent;
 98175:     } while (bce);
 98175: 
 75502:     return JS_TRUE;
 75502: }
 75502: 
 87976: static bool
 87976: EmitIndex32(JSContext *cx, JSOp op, uint32_t index, BytecodeEmitter *bce)
 87976: {
 87976:     const size_t len = 1 + UINT32_INDEX_LEN;
 90965:     JS_ASSERT(len == size_t(js_CodeSpec[op].length));
 87976:     ptrdiff_t offset = EmitCheck(cx, bce, len);
 87976:     if (offset < 0)
 87976:         return false;
 87976: 
 87976:     jsbytecode *next = bce->next();
 87976:     next[0] = jsbytecode(op);
 87976:     SET_UINT32_INDEX(next, index);
 87976:     bce->current->next = next + len;
 87976:     UpdateDepth(cx, bce, offset);
 87976:     CheckTypeSet(cx, bce, op);
 87976:     return true;
 87976: }
 87976: 
 87976: static bool
 90965: EmitIndexOp(JSContext *cx, JSOp op, uint32_t index, BytecodeEmitter *bce)
 90965: {
 90965:     const size_t len = js_CodeSpec[op].length;
 90965:     JS_ASSERT(len >= 1 + UINT32_INDEX_LEN);
 90965:     ptrdiff_t offset = EmitCheck(cx, bce, len);
 90965:     if (offset < 0)
 90965:         return false;
 90965: 
 90965:     jsbytecode *next = bce->next();
 90965:     next[0] = jsbytecode(op);
 90965:     SET_UINT32_INDEX(next, index);
 90965:     bce->current->next = next + len;
 90965:     UpdateDepth(cx, bce, offset);
 90965:     CheckTypeSet(cx, bce, op);
 90965:     return true;
 90965: }
 90965: 
 90965: static bool
 90965: EmitAtomOp(JSContext *cx, JSAtom *atom, JSOp op, BytecodeEmitter *bce)
 90965: {
 90965:     JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
 90965: 
 90965:     if (op == JSOP_GETPROP && atom == cx->runtime->atomState.lengthAtom) {
 90965:         /* Specialize length accesses for the interpreter. */
 90965:         op = JSOP_LENGTH;
 90965:     }
 90965: 
 90965:     jsatomid index;
 90965:     if (!bce->makeAtomIndex(atom, &index))
 90965:         return false;
 90965: 
 90965:     return EmitIndexOp(cx, op, index, bce);
 90965: }
 90965: 
 90965: static bool
 90965: EmitAtomOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 90965: {
 90965:     JS_ASSERT(pn->pn_atom != NULL);
 90965:     return EmitAtomOp(cx, pn->pn_atom, op, bce);
 90965: }
 90965: 
 90965: static bool
 90965: EmitAtomIncDec(JSContext *cx, JSAtom *atom, JSOp op, BytecodeEmitter *bce)
 90965: {
 90965:     JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
 90965:     JS_ASSERT(js_CodeSpec[op].format & (JOF_INC | JOF_DEC));
 90965: 
 90965:     jsatomid index;
 90965:     if (!bce->makeAtomIndex(atom, &index))
 90965:         return false;
 90965: 
 90965:     const size_t len = 1 + UINT32_INDEX_LEN + 1;
 90965:     JS_ASSERT(size_t(js_CodeSpec[op].length) == len);
 90965:     ptrdiff_t offset = EmitCheck(cx, bce, len);
 90965:     if (offset < 0)
 90965:         return false;
 90965: 
 90965:     jsbytecode *next = bce->next();
 90965:     next[0] = jsbytecode(op);
 90965:     SET_UINT32_INDEX(next, index);
 90965:     bce->current->next = next + len;
 90965:     UpdateDepth(cx, bce, offset);
 90965:     CheckTypeSet(cx, bce, op);
 90965:     return true;
 90965: }
 90965: 
 90965: static bool
 89253: EmitFunctionOp(JSContext *cx, JSOp op, uint32_t index, BytecodeEmitter *bce)
 89253: {
 89253:     return EmitIndex32(cx, op, index, bce);
 89253: }
 89253: 
 89253: static bool
 89253: EmitObjectOp(JSContext *cx, ObjectBox *objbox, JSOp op, BytecodeEmitter *bce)
 89253: {
 89253:     JS_ASSERT(JOF_OPTYPE(op) == JOF_OBJECT);
100006:     return EmitIndex32(cx, op, bce->objectList.index(objbox), bce);
 89253: }
 89253: 
 89253: static bool
 87976: EmitRegExp(JSContext *cx, uint32_t index, BytecodeEmitter *bce)
 87976: {
 87976:     return EmitIndex32(cx, JSOP_REGEXP, index, bce);
 87976: }
 87976: 
 95101: /*
 95101:  * To catch accidental misuse, EMIT_UINT16_IMM_OP/Emit3 assert that they are
 95101:  * not used to unconditionally emit JSOP_GETLOCAL. Variable access should
 95101:  * instead be emitted using EmitVarOp. In special cases, when the caller
 95101:  * definitely knows that a given local slot is unaliased, this function may be
 95101:  * used as a non-asserting version of EMIT_UINT16_IMM_OP.
 95101:  */
 95101: static bool
 95101: EmitUnaliasedVarOp(JSContext *cx, JSOp op, uint16_t slot, BytecodeEmitter *bce)
 95101: {
 95101:     JS_ASSERT(JOF_OPTYPE(op) != JOF_SCOPECOORD);
 95101:     ptrdiff_t off = EmitN(cx, bce, op, sizeof(uint16_t));
 95101:     if (off < 0)
 95101:         return false;
 95101:     SET_UINT16(bce->code(off), slot);
 95101:     return true;
 95101: }
 95101: 
 95101: static bool
100006: EmitAliasedVarOp(JSContext *cx, JSOp op, uint16_t binding, JSAtom *atom, BytecodeEmitter *bce)
 95101: {
 95101:     JS_ASSERT(JOF_OPTYPE(op) == JOF_SCOPECOORD);
 95101: 
100006:     /*
100006:      * XXX This is temporary: bug 659577 will need to compute the number of
100006:      * cloned block objects to hop over.
100006:      */
100006:     uint16_t hops = 0;
100006: 
100006:     jsatomid atomIndex;
100006:     if (!bce->makeAtomIndex(atom, &atomIndex))
100006:         return false;
 95101: 
 95101:     bool decomposed = js_CodeSpec[op].format & JOF_DECOMPOSE;
 99994:     unsigned n = 2 * sizeof(uint16_t) + sizeof(uint32_t) + (decomposed ? 1 : 0);
 95101: 
 95101:     ptrdiff_t off = EmitN(cx, bce, op, n);
 95101:     if (off < 0)
 95101:         return false;
 95101: 
 95101:     jsbytecode *pc = bce->code(off);
100006:     SET_UINT16(pc, hops);
 95101:     pc += sizeof(uint16_t);
100006:     SET_UINT16(pc, binding);
 95101:     pc += sizeof(uint16_t);
100006:     SET_UINT32_INDEX(pc, atomIndex);
 95101:     return true;
 95101: }
 95101: 
 95101: static bool
 95101: EmitAliasedVarOp(JSContext *cx, JSOp op, ParseNode *pn, BytecodeEmitter *bce)
 95101: {
100006:     uint16_t binding = JOF_OPTYPE(pn->getOp()) == JOF_QARG
100006:                        ? bce->sc->bindings.argToBinding(pn->pn_cookie.slot())
100006:                        : bce->sc->bindings.localToBinding(pn->pn_cookie.slot());
100006:     return EmitAliasedVarOp(cx, op, binding, pn->atom(), bce);
 95101: }
 95101: 
 95101: static bool
 95101: EmitVarOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 95101: {
 95101:     JS_ASSERT(pn->isKind(PNK_FUNCTION) || pn->isKind(PNK_NAME));
 95101:     JS_ASSERT_IF(pn->isKind(PNK_NAME), JOF_OPTYPE(op) == JOF_QARG || JOF_OPTYPE(op) == JOF_LOCAL);
 95101:     JS_ASSERT(!pn->pn_cookie.isFree());
 95101: 
 95101:     if (!bce->isAliasedName(pn))
 95101:         return EmitUnaliasedVarOp(cx, op, pn->pn_cookie.slot(), bce);
 95101: 
 95101:     switch (op) {
 95101:       case JSOP_GETARG: case JSOP_GETLOCAL: op = JSOP_GETALIASEDVAR; break;
 95101:       case JSOP_SETARG: case JSOP_SETLOCAL: op = JSOP_SETALIASEDVAR; break;
 95101:       case JSOP_CALLARG: case JSOP_CALLLOCAL: op = JSOP_CALLALIASEDVAR; break;
 95101:       default: JS_NOT_REACHED("unexpected var op");
 95101:     }
 95101: 
 95101:     return EmitAliasedVarOp(cx, op, pn, bce);
 95101: }
 95101: 
 95101: static bool
 95101: EmitVarIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 95101: {
 95101:     JS_ASSERT(pn->isKind(PNK_NAME));
 95101:     JS_ASSERT(JOF_OPTYPE(op) == JOF_QARG || JOF_OPTYPE(op) == JOF_LOCAL);
 95101:     JS_ASSERT(js_CodeSpec[op].format & (JOF_INC | JOF_DEC));
 95101:     JS_ASSERT(!pn->pn_cookie.isFree());
 95101: 
 95101:     if (!bce->isAliasedName(pn))
 95101:         return EmitUnaliasedVarOp(cx, op, pn->pn_cookie.slot(), bce);
 95101: 
 95101:     switch (op) {
 95101:       case JSOP_INCARG: case JSOP_INCLOCAL: op = JSOP_INCALIASEDVAR; break;
 95101:       case JSOP_ARGINC: case JSOP_LOCALINC: op = JSOP_ALIASEDVARINC; break;
 95101:       case JSOP_DECARG: case JSOP_DECLOCAL: op = JSOP_DECALIASEDVAR; break;
 95101:       case JSOP_ARGDEC: case JSOP_LOCALDEC: op = JSOP_ALIASEDVARDEC; break;
 95101:       default: JS_NOT_REACHED("unexpected var op");
 95101:     }
 95101: 
 95101:     if (!EmitAliasedVarOp(cx, op, pn, bce))
 95101:         return false;
 95101: 
 95101:     /* Remove the result to restore the stack depth before the INCALIASEDVAR. */
 95101:     bce->stackDepth--;
 95101: 
 95101:     int start = bce->offset();
 95101: 
 95101:     const JSCodeSpec &cs = js_CodeSpec[op];
 95101:     bool post = (cs.format & JOF_POST);
 95101:     JSOp binop = (cs.format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
 95101: 
 95101:     if (!EmitAliasedVarOp(cx, JSOP_GETALIASEDVAR, pn, bce))  // V
 95101:         return false;
 95101:     if (Emit1(cx, bce, JSOP_POS) < 0)                        // N
 95101:         return false;
 95101:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)                // N? N
 95101:         return false;
 95101:     if (Emit1(cx, bce, JSOP_ONE) < 0)                        // N? N 1
 95101:         return false;
 95101:     if (Emit1(cx, bce, binop) < 0)                           // N? N+1
 95101:         return false;
 95101:     if (!EmitAliasedVarOp(cx, JSOP_SETALIASEDVAR, pn, bce))  // N? N+1
 95101:         return false;
 95101:     if (post && Emit1(cx, bce, JSOP_POP) < 0)                // RESULT
 95101:         return false;
 95101: 
 95101:     UpdateDecomposeLength(bce, start);
 95101:     return true;
 95101: }
 95101: 
 95101: bool
 95101: BytecodeEmitter::isAliasedName(ParseNode *pn)
 95101: {
 98445:     return sc->bindingsAccessedDynamically() || shouldNoteClosedName(pn->resolve());
 95101: }
 95101: 
 75502: bool
 80966: BytecodeEmitter::shouldNoteClosedName(ParseNode *pn)
 75502: {
 98445:     return !sc->bindingsAccessedDynamically() && pn->isDefn() && pn->isClosed();
 75502: }
 75502: 
 95098: bool
 95098: BytecodeEmitter::noteClosedVar(ParseNode *pn)
 95098: {
 95098: #ifdef DEBUG
 95098:     JS_ASSERT(shouldNoteClosedName(pn));
 95098:     Definition *dn = (Definition *)pn;
 95098:     JS_ASSERT(dn->kind() == Definition::VAR || dn->kind() == Definition::CONST ||
 95098:               dn->kind() == Definition::FUNCTION);
 98445:     JS_ASSERT(pn->pn_cookie.slot() < sc->bindings.numVars());
 95098:     for (size_t i = 0; i < closedVars.length(); ++i)
 95098:         JS_ASSERT(closedVars[i] != pn->pn_cookie.slot());
 95098: #endif
 98687:     sc->setFunIsHeavyweight();
 95098:     return closedVars.append(pn->pn_cookie.slot());
 95098: }
 95098: 
 95098: bool
 95098: BytecodeEmitter::noteClosedArg(ParseNode *pn)
 95098: {
 95098: #ifdef DEBUG
 95098:     JS_ASSERT(shouldNoteClosedName(pn));
 95098:     Definition *dn = (Definition *)pn;
 95098:     JS_ASSERT(dn->kind() == Definition::ARG);
 98445:     JS_ASSERT(pn->pn_cookie.slot() < sc->bindings.numArgs());
 95098:     for (size_t i = 0; i < closedArgs.length(); ++i)
 95098:         JS_ASSERT(closedArgs[i] != pn->pn_cookie.slot());
 95098: #endif
 98687:     sc->setFunIsHeavyweight();
 95098:     return closedArgs.append(pn->pn_cookie.slot());
 95098: }
 95098: 
 75502: /*
 75502:  * Adjust the slot for a block local to account for the number of variables
 75502:  * that share the same index space with locals. Due to the incremental code
 75502:  * generation for top-level script, we do the adjustment via code patching in
 80991:  * js::frontend::CompileScript; see comments there.
 75502:  *
 75502:  * The function returns -1 on failures.
 75502:  */
 91450: static int
 91450: AdjustBlockSlot(JSContext *cx, BytecodeEmitter *bce, int slot)
 80966: {
 91612:     JS_ASSERT((unsigned) slot < bce->maxStackDepth);
 98476:     if (bce->sc->inFunction) {
 98445:         slot += bce->sc->bindings.numVars();
 91237:         if ((unsigned) slot >= SLOTNO_LIMIT) {
 80966:             ReportCompileErrorNumber(cx, bce->tokenStream(), NULL, JSREPORT_ERROR,
 80966:                                      JSMSG_TOO_MANY_LOCALS);
 75502:             slot = -1;
 75502:         }
 75502:     }
 75502:     return slot;
 75502: }
 75502: 
 75502: static bool
 86078: EmitEnterBlock(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSOp op)
 75502: {
 82024:     JS_ASSERT(pn->isKind(PNK_LEXICALSCOPE));
 86078:     if (!EmitObjectOp(cx, pn->pn_objbox, op, bce))
 75502:         return false;
 75502: 
 99421:     Rooted<StaticBlockObject*> blockObj(cx, &pn->pn_objbox->object->asStaticBlock());
 86078: 
 86078:     int depth = bce->stackDepth -
 97353:                 (blockObj->slotCount() + ((op == JSOP_ENTERLET1) ? 1 : 0));
 86078:     JS_ASSERT(depth >= 0);
 86483: 
 97353:     blockObj->setStackDepth(depth);
 86483: 
 86078:     int depthPlusFixed = AdjustBlockSlot(cx, bce, depth);
 86078:     if (depthPlusFixed < 0)
 75502:         return false;
 75502: 
 97353:     for (unsigned i = 0; i < blockObj->slotCount(); i++) {
 97353:         Definition *dn = blockObj->maybeDefinitionParseNode(i);
 75502: 
 75502:         /* Beware the empty destructuring dummy. */
 99994:         if (!dn) {
100006:             JS_ASSERT(i + 1 <= blockObj->slotCount());
 99461:             blockObj->setAliased(i, bce->sc->bindingsAccessedDynamically());
 75502:             continue;
 99994:         }
 75502: 
 78294:         JS_ASSERT(dn->isDefn());
 91237:         JS_ASSERT(unsigned(dn->frameSlot() + depthPlusFixed) < JS_BIT(16));
 86078:         dn->pn_cookie.set(dn->pn_cookie.level(), uint16_t(dn->frameSlot() + depthPlusFixed));
 75502: #ifdef DEBUG
 80631:         for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
 75502:             JS_ASSERT(pnu->pn_lexdef == dn);
 75502:             JS_ASSERT(!(pnu->pn_dflags & PND_BOUND));
 75502:             JS_ASSERT(pnu->pn_cookie.isFree());
 75502:         }
 75502: #endif
 95099: 
 98445:         bool aliased = bce->sc->bindingsAccessedDynamically() || bce->shouldNoteClosedName(dn);
 97353:         blockObj->setAliased(i, aliased);
 75502:     }
 75502: 
 75502:     /*
 80631:      * If clones of this block will have any extensible parents, then the
 80631:      * clones must get unique shapes; see the comments for
 80631:      * js::Bindings::extensibleParents.
 75502:      */
 98687:     if (bce->sc->funHasExtensibleScope() ||
 98445:         bce->sc->bindings.extensibleParents()) {
 97353:         Shape *newShape = Shape::setExtensibleParents(cx, blockObj->lastProperty());
 86437:         if (!newShape)
 86437:             return false;
 97353:         blockObj->setLastPropertyInfallible(newShape);
 83221:     }
 75502: 
 75502:     return true;
 75502: }
 75502: 
 75502: /*
 75502:  * Try to convert a *NAME op to a *GNAME op, which optimizes access to
 75502:  * undeclared globals. Return true if a conversion was made.
 75502:  *
 75502:  * This conversion is not made if we are in strict mode.  In eval code nested
 75502:  * within (strict mode) eval code, access to an undeclared "global" might
 75502:  * merely be to a binding local to that outer eval:
 75502:  *
 75502:  *   "use strict";
 75502:  *   var x = "global";
 75502:  *   eval('var x = "eval"; eval("x");'); // 'eval', not 'global'
 75502:  *
 75502:  * Outside eval code, access to an undeclared global is a strict mode error:
 75502:  *
 75502:  *   "use strict";
 75502:  *   function foo()
 75502:  *   {
 75502:  *     undeclared = 17; // throws ReferenceError
 75502:  *   }
 75502:  *   foo();
 75502:  */
 75502: static bool
 80966: TryConvertToGname(BytecodeEmitter *bce, ParseNode *pn, JSOp *op)
 80966: {
 98464:     if (bce->parser->compileAndGo &&
 80990:         bce->globalScope->globalObj &&
 98687:         !bce->sc->funMightAliasLocals() &&
 75502:         !pn->isDeoptimized() &&
 98687:         !bce->sc->inStrictMode()) {
 75502:         switch (*op) {
 75502:           case JSOP_NAME:     *op = JSOP_GETGNAME; break;
 75502:           case JSOP_SETNAME:  *op = JSOP_SETGNAME; break;
 75502:           case JSOP_INCNAME:  *op = JSOP_INCGNAME; break;
 75502:           case JSOP_NAMEINC:  *op = JSOP_GNAMEINC; break;
 75502:           case JSOP_DECNAME:  *op = JSOP_DECGNAME; break;
 75502:           case JSOP_NAMEDEC:  *op = JSOP_GNAMEDEC; break;
 75502:           case JSOP_SETCONST:
 75502:           case JSOP_DELNAME:
 75502:             /* Not supported. */
 75502:             return false;
 75502:           default: JS_NOT_REACHED("gname");
 75502:         }
 75502:         return true;
 75502:     }
 75502:     return false;
 75502: }
 75502: 
 75502: /*
 75502:  * BindNameToSlot attempts to optimize name gets and sets to stack slot loads
 82024:  * and stores, given the compile-time information in bce and a PNK_NAME node pn.
 75502:  * It returns false on error, true on success.
 75502:  *
 75502:  * The caller can inspect pn->pn_cookie for FREE_UPVAR_COOKIE to tell whether
 75502:  * optimization occurred, in which case BindNameToSlot also updated pn->pn_op.
 75502:  * If pn->pn_cookie is still FREE_UPVAR_COOKIE on return, pn->pn_op still may
 75502:  * have been optimized, e.g., from JSOP_NAME to JSOP_CALLEE.  Whether or not
 75502:  * pn->pn_op was modified, if this function finds an argument or local variable
 75502:  * name, PND_CONST will be set in pn_dflags for read-only properties after a
 75502:  * successful return.
 75502:  *
 75502:  * NB: if you add more opcodes specialized from JSOP_NAME, etc., don't forget
 82023:  * to update the special cases in EmitFor (for-in) and EmitAssignment (= and
 82023:  * op=, e.g. +=).
 75502:  */
 75502: static JSBool
 80966: BindNameToSlot(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 80631: {
 80631:     Definition *dn;
 75502:     JSOp op;
 80631:     Definition::Kind dn_kind;
 75502: 
 82024:     JS_ASSERT(pn->isKind(PNK_NAME));
 75502: 
 75502:     /* Idempotency tests come first, since we may be called more than once. */
 75502:     if (pn->pn_dflags & PND_BOUND)
 75502:         return JS_TRUE;
 75502: 
 95100:     /* No cookie initialized for callee; it is pre-bound by definition. */
 95100:     JS_ASSERT(!pn->isOp(JSOP_CALLEE));
 75502: 
 75502:     /*
 75502:      * The parser linked all uses (including forward references) to their
 75502:      * definitions, unless a with statement or direct eval intervened.
 75502:      */
 78294:     if (pn->isUsed()) {
 75502:         JS_ASSERT(pn->pn_cookie.isFree());
 75502:         dn = pn->pn_lexdef;
 78294:         JS_ASSERT(dn->isDefn());
 75502:         if (pn->isDeoptimized())
 75502:             return JS_TRUE;
 75502:         pn->pn_dflags |= (dn->pn_dflags & PND_CONST);
 75502:     } else {
 78294:         if (!pn->isDefn())
 75502:             return JS_TRUE;
 80631:         dn = (Definition *) pn;
 75502:     }
 75502: 
 78294:     op = pn->getOp();
 75502:     if (op == JSOP_NOP)
 75502:         return JS_TRUE;
 75502: 
 75502:     JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
 99421:     RootedAtom atom(cx, pn->pn_atom);
 75502:     UpvarCookie cookie = dn->pn_cookie;
 75502:     dn_kind = dn->kind();
 75502: 
 75502:     /*
 75502:      * Turn attempts to mutate const-declared bindings into get ops (for
 75502:      * pre-increment and pre-decrement ops, our caller will have to emit
 75502:      * JSOP_POS, JSOP_ONE, and JSOP_ADD as well).
 75502:      *
 75502:      * Turn JSOP_DELNAME into JSOP_FALSE if dn is known, as all declared
 75502:      * bindings visible to the compiler are permanent in JS unless the
 75502:      * declaration originates at top level in eval code.
 75502:      */
 75502:     switch (op) {
 75502:       case JSOP_NAME:
 75502:       case JSOP_SETCONST:
 75502:         break;
 75502:       case JSOP_DELNAME:
 80631:         if (dn_kind != Definition::UNKNOWN) {
 80966:             if (bce->parser->callerFrame && dn->isTopLevel())
 98464:                 JS_ASSERT(bce->parser->compileAndGo);
 75502:             else
 78294:                 pn->setOp(JSOP_FALSE);
 75502:             pn->pn_dflags |= PND_BOUND;
 75502:             return JS_TRUE;
 75502:         }
 75502:         break;
 75502:       default:
 75502:         if (pn->isConst()) {
 98445:             if (bce->sc->needStrictChecks()) {
 75502:                 JSAutoByteString name;
 75502:                 if (!js_AtomToPrintableString(cx, atom, &name) ||
 99779:                     !ReportStrictModeError(cx, bce->tokenStream(), pn, JSMSG_READ_ONLY, name.ptr()))
 99779:                 {
 75502:                     return JS_FALSE;
 75502:                 }
 75502:             }
 78294:             pn->setOp(op = JSOP_NAME);
 75502:         }
 75502:     }
 75502: 
 75502:     if (cookie.isFree()) {
 80966:         StackFrame *caller = bce->parser->callerFrame;
 75502:         if (caller) {
 98464:             JS_ASSERT(bce->parser->compileAndGo);
 75502: 
 75502:             /*
 75502:              * Don't generate upvars on the left side of a for loop. See
 75502:              * bug 470758.
 75502:              */
 98477:             if (bce->sc->inForInit)
 75502:                 return JS_TRUE;
 75502: 
 75502:             JS_ASSERT(caller->isScriptFrame());
 75502: 
 75502:             /*
 75502:              * If this is an eval in the global scope, then unbound variables
 75502:              * must be globals, so try to use GNAME ops.
 75502:              */
 80966:             if (caller->isGlobalFrame() && TryConvertToGname(bce, pn, &op)) {
 78294:                 pn->setOp(op);
 75502:                 pn->pn_dflags |= PND_BOUND;
 75502:                 return JS_TRUE;
 75502:             }
 75502: 
 75502:             /*
 75502:              * Out of tricks, so we must rely on PICs to optimize named
 75502:              * accesses from direct eval called from function code.
 75502:              */
 75502:             return JS_TRUE;
 75502:         }
 75502: 
 75502:         /* Optimize accesses to undeclared globals. */
 91456:         if (!TryConvertToGname(bce, pn, &op))
 75502:             return JS_TRUE;
 75502: 
 78294:         pn->setOp(op);
 75502:         pn->pn_dflags |= PND_BOUND;
 75502: 
 75502:         return JS_TRUE;
 75502:     }
 75502: 
 84755:     uint16_t level = cookie.level();
 98445:     JS_ASSERT(bce->sc->staticLevel >= level);
 98445: 
 98445:     const unsigned skip = bce->sc->staticLevel - level;
 93245:     if (skip != 0)
 75502:         return JS_TRUE;
 75502: 
 75502:     /*
 75502:      * We are compiling a function body and may be able to optimize name
 75502:      * to stack slot. Look for an argument or variable in the function and
 75502:      * rewrite pn_op and update pn accordingly.
 75502:      */
 75502:     switch (dn_kind) {
 80631:       case Definition::UNKNOWN:
 75502:         return JS_TRUE;
 75502: 
 80631:       case Definition::LET:
 75502:         switch (op) {
 75502:           case JSOP_NAME:     op = JSOP_GETLOCAL; break;
 75502:           case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
 75502:           case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
 75502:           case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
 75502:           case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
 75502:           case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
 75502:           default: JS_NOT_REACHED("let");
 75502:         }
 75502:         break;
 75502: 
 80631:       case Definition::ARG:
 75502:         switch (op) {
 75502:           case JSOP_NAME:     op = JSOP_GETARG; break;
 75502:           case JSOP_SETNAME:  op = JSOP_SETARG; break;
 75502:           case JSOP_INCNAME:  op = JSOP_INCARG; break;
 75502:           case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
 75502:           case JSOP_DECNAME:  op = JSOP_DECARG; break;
 75502:           case JSOP_NAMEDEC:  op = JSOP_ARGDEC; break;
 75502:           default: JS_NOT_REACHED("arg");
 75502:         }
 75502:         JS_ASSERT(!pn->isConst());
 75502:         break;
 75502: 
 80631:       case Definition::VAR:
 78294:         if (dn->isOp(JSOP_CALLEE)) {
 75502:             JS_ASSERT(op != JSOP_CALLEE);
 98445:             JS_ASSERT((bce->sc->fun()->flags & JSFUN_LAMBDA) && atom == bce->sc->fun()->atom);
 80966: 
 80966:             /*
 80966:              * Leave pn->isOp(JSOP_NAME) if bce->fun is heavyweight to
 75502:              * address two cases: a new binding introduced by eval, and
 75502:              * assignment to the name in strict mode.
 75502:              *
 75502:              *   var fun = (function f(s) { eval(s); return f; });
 75502:              *   assertEq(fun("var f = 42"), 42);
 75502:              *
 75502:              * ECMAScript specifies that a function expression's name is bound
 75502:              * in a lexical environment distinct from that used to bind its
 75502:              * named parameters, the arguments object, and its variables.  The
 75502:              * new binding for "var f = 42" shadows the binding for the
 75502:              * function itself, so the name of the function will not refer to
 75502:              * the function.
 75502:              *
 75502:              *    (function f() { "use strict"; f = 12; })();
 75502:              *
 75502:              * Outside strict mode, assignment to a function expression's name
 75502:              * has no effect.  But in strict mode, this attempt to mutate an
 75502:              * immutable binding must throw a TypeError.  We implement this by
 75502:              * not optimizing such assignments and by marking such functions as
 75502:              * heavyweight, ensuring that the function name is represented in
 75502:              * the scope chain so that assignment will throw a TypeError.
 75502:              */
 75502:             JS_ASSERT(op != JSOP_DELNAME);
 98687:             if (!bce->sc->funIsHeavyweight()) {
 75502:                 op = JSOP_CALLEE;
 75502:                 pn->pn_dflags |= PND_CONST;
 75502:             }
 75502: 
 78294:             pn->setOp(op);
 75502:             pn->pn_dflags |= PND_BOUND;
 75502:             return JS_TRUE;
 75502:         }
 75502:         /* FALL THROUGH */
 75502: 
 75502:       default:
 80631:         JS_ASSERT_IF(dn_kind != Definition::FUNCTION,
 80631:                      dn_kind == Definition::VAR ||
 80631:                      dn_kind == Definition::CONST);
 75502:         switch (op) {
 75502:           case JSOP_NAME:     op = JSOP_GETLOCAL; break;
 75502:           case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
 75502:           case JSOP_SETCONST: op = JSOP_SETLOCAL; break;
 75502:           case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
 75502:           case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
 75502:           case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
 75502:           case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
 75502:           default: JS_NOT_REACHED("local");
 75502:         }
 80631:         JS_ASSERT_IF(dn_kind == Definition::CONST, pn->pn_dflags & PND_CONST);
 75502:         break;
 75502:     }
 75502: 
 78294:     JS_ASSERT(!pn->isOp(op));
 78294:     pn->setOp(op);
 75502:     pn->pn_cookie.set(0, cookie.slot());
 75502:     pn->pn_dflags |= PND_BOUND;
 75502:     return JS_TRUE;
 75502: }
 75502: 
 75502: /*
 75502:  * If pn contains a useful expression, return true with *answer set to true.
 75502:  * If pn contains a useless expression, return true with *answer set to false.
 75502:  * Return false on error.
 75502:  *
 75502:  * The caller should initialize *answer to false and invoke this function on
 75502:  * an expression statement or similar subtree to decide whether the tree could
 75502:  * produce code that has any side effects.  For an expression statement, we
 75502:  * define useless code as code with no side effects, because the main effect,
 75502:  * the value left on the stack after the code executes, will be discarded by a
 75502:  * pop bytecode.
 75502:  */
 75502: static JSBool
 80966: CheckSideEffects(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSBool *answer)
 75502: {
 75502:     JSBool ok;
 80631:     ParseNode *pn2;
 75502: 
 75502:     ok = JS_TRUE;
 75502:     if (!pn || *answer)
 75502:         return ok;
 75502: 
 78294:     switch (pn->getArity()) {
 75502:       case PN_FUNC:
 75502:         /*
 75502:          * A named function, contrary to ES3, is no longer useful, because we
 75502:          * bind its name lexically (using JSOP_CALLEE) instead of creating an
 75502:          * Object instance and binding a readonly, permanent property in it
 75502:          * (the object and binding can be detected and hijacked or captured).
 75502:          * This is a bug fix to ES3; it is fixed in ES3.1 drafts.
 75502:          */
 75502:         *answer = JS_FALSE;
 75502:         break;
 75502: 
 75502:       case PN_LIST:
 78294:         if (pn->isOp(JSOP_NOP) || pn->isOp(JSOP_OR) || pn->isOp(JSOP_AND) ||
 78294:             pn->isOp(JSOP_STRICTEQ) || pn->isOp(JSOP_STRICTNE)) {
 75502:             /*
 75502:              * Non-operators along with ||, &&, ===, and !== never invoke
 75502:              * toString or valueOf.
 75502:              */
 75502:             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
 80966:                 ok &= CheckSideEffects(cx, bce, pn2, answer);
 75502:         } else {
 75502:             /*
 82024:              * All invocation operations (construct: PNK_NEW, call: PNK_LP)
 75502:              * are presumed to be useful, because they may have side effects
 75502:              * even if their main effect (their return value) is discarded.
 75502:              *
 82024:              * PNK_LB binary trees of 3 or more nodes are flattened into lists
 75502:              * to avoid too much recursion.  All such lists must be presumed
 95100:              * to be useful because each index operation could invoke a getter.
 75502:              *
 75502:              * Likewise, array and object initialisers may call prototype
 75502:              * setters (the __defineSetter__ built-in, and writable __proto__
 75502:              * on Array.prototype create this hazard). Initialiser list nodes
 75502:              * have JSOP_NEWINIT in their pn_op.
 75502:              */
 75502:             *answer = JS_TRUE;
 75502:         }
 75502:         break;
 75502: 
 75502:       case PN_TERNARY:
 80966:         ok = CheckSideEffects(cx, bce, pn->pn_kid1, answer) &&
 80966:              CheckSideEffects(cx, bce, pn->pn_kid2, answer) &&
 80966:              CheckSideEffects(cx, bce, pn->pn_kid3, answer);
 75502:         break;
 75502: 
 75502:       case PN_BINARY:
 82023:         if (pn->isAssignment()) {
 75502:             /*
 75502:              * Assignment is presumed to be useful, even if the next operation
 75502:              * is another assignment overwriting this one's ostensible effect,
 75502:              * because the left operand may be a property with a setter that
 75502:              * has side effects.
 75502:              *
 75502:              * The only exception is assignment of a useless value to a const
 75502:              * declared in the function currently being compiled.
 75502:              */
 75502:             pn2 = pn->pn_left;
 82024:             if (!pn2->isKind(PNK_NAME)) {
 75502:                 *answer = JS_TRUE;
 75502:             } else {
 80966:                 if (!BindNameToSlot(cx, bce, pn2))
 80966:                     return JS_FALSE;
 80966:                 if (!CheckSideEffects(cx, bce, pn->pn_right, answer))
 75502:                     return JS_FALSE;
 78294:                 if (!*answer && (!pn->isOp(JSOP_NOP) || !pn2->isConst()))
 75502:                     *answer = JS_TRUE;
 75502:             }
 75502:         } else {
 78294:             if (pn->isOp(JSOP_OR) || pn->isOp(JSOP_AND) || pn->isOp(JSOP_STRICTEQ) ||
 78294:                 pn->isOp(JSOP_STRICTNE)) {
 75502:                 /*
 75502:                  * ||, &&, ===, and !== do not convert their operands via
 75502:                  * toString or valueOf method calls.
 75502:                  */
 80966:                 ok = CheckSideEffects(cx, bce, pn->pn_left, answer) &&
 80966:                      CheckSideEffects(cx, bce, pn->pn_right, answer);
 75502:             } else {
 75502:                 /*
 75502:                  * We can't easily prove that neither operand ever denotes an
 75502:                  * object with a toString or valueOf method.
 75502:                  */
 75502:                 *answer = JS_TRUE;
 75502:             }
 75502:         }
 75502:         break;
 75502: 
 75502:       case PN_UNARY:
 78294:         switch (pn->getKind()) {
 82024:           case PNK_DELETE:
 75502:             pn2 = pn->pn_kid;
 78294:             switch (pn2->getKind()) {
 82024:               case PNK_NAME:
 80966:                 if (!BindNameToSlot(cx, bce, pn2))
 75502:                     return JS_FALSE;
 75502:                 if (pn2->isConst()) {
 75502:                     *answer = JS_FALSE;
 75502:                     break;
 75502:                 }
 75502:                 /* FALL THROUGH */
 82024:               case PNK_DOT:
 75502: #if JS_HAS_XML_SUPPORT
 82024:               case PNK_DBLDOT:
 98445:                 JS_ASSERT_IF(pn2->getKind() == PNK_DBLDOT, !bce->sc->inStrictMode());
 80780:                 /* FALL THROUGH */
 80780: 
 75502: #endif
 82024:               case PNK_LP:
 82024:               case PNK_LB:
 75502:                 /* All these delete addressing modes have effects too. */
 75502:                 *answer = JS_TRUE;
 75502:                 break;
 75502:               default:
 80966:                 ok = CheckSideEffects(cx, bce, pn2, answer);
 75502:                 break;
 75502:             }
 75502:             break;
 75502: 
 82024:           case PNK_TYPEOF:
 82024:           case PNK_VOID:
 82024:           case PNK_NOT:
 82024:           case PNK_BITNOT:
 78294:             if (pn->isOp(JSOP_NOT)) {
 75502:                 /* ! does not convert its operand via toString or valueOf. */
 80966:                 ok = CheckSideEffects(cx, bce, pn->pn_kid, answer);
 75502:                 break;
 75502:             }
 75502:             /* FALL THROUGH */
 75502: 
 75502:           default:
 75502:             /*
 88137:              * All of PNK_INC, PNK_DEC, PNK_THROW, and PNK_YIELD have direct
 88137:              * effects. Of the remaining unary-arity node types, we can't
 88137:              * easily prove that the operand never denotes an object with a
 88137:              * toString or valueOf method.
 75502:              */
 75502:             *answer = JS_TRUE;
 75502:             break;
 75502:         }
 75502:         break;
 75502: 
 75502:       case PN_NAME:
 75502:         /*
 75502:          * Take care to avoid trying to bind a label name (labels, both for
 75502:          * statements and property values in object initialisers, have pn_op
 75502:          * defaulted to JSOP_NOP).
 75502:          */
 82024:         if (pn->isKind(PNK_NAME) && !pn->isOp(JSOP_NOP)) {
 80966:             if (!BindNameToSlot(cx, bce, pn))
 75502:                 return JS_FALSE;
 95100:             if (!pn->isOp(JSOP_CALLEE) && pn->pn_cookie.isFree()) {
 95100:                 /*
 95100:                  * Not a use of an unshadowed named function expression's given
 95100:                  * name, so this expression could invoke a getter that has side
 95100:                  * effects.
 75502:                  */
 75502:                 *answer = JS_TRUE;
 75502:             }
 75502:         }
 82024:         if (pn->isKind(PNK_DOT)) {
 95100:             /* Dotted property references in general can call getters. */
 75502:             *answer = JS_TRUE;
 75502:         }
 95100:         ok = CheckSideEffects(cx, bce, pn->maybeExpr(), answer);
 75502:         break;
 75502: 
 75502:       case PN_NAMESET:
 80966:         ok = CheckSideEffects(cx, bce, pn->pn_tree, answer);
 75502:         break;
 75502: 
 75502:       case PN_NULLARY:
 82024:         if (pn->isKind(PNK_DEBUGGER))
 75502:             *answer = JS_TRUE;
 75502:         break;
 75502:     }
 75502:     return ok;
 75502: }
 75502: 
 86855: bool
 86855: BytecodeEmitter::needsImplicitThis()
 86855: {
 98464:     if (!parser->compileAndGo)
 86855:         return true;
 98476:     if (!sc->inFunction) {
 98445:         JSObject *scope = sc->scopeChain();
 86855:         while (scope) {
 86855:             if (scope->isWith())
 86855:                 return true;
 86855:             scope = scope->enclosingScope();
 86855:         }
 86855:     }
 98445:     for (const FunctionBox *funbox = this->sc->funbox; funbox; funbox = funbox->parent) {
 98478:         if (funbox->inWith)
 86855:             return true;
 86855:     }
 98445:     for (StmtInfo *stmt = sc->topStmt; stmt; stmt = stmt->down) {
 86855:         if (stmt->type == STMT_WITH)
 86855:             return true;
 86855:     }
 86855:     return false;
 86855: }
 86855: 
 75502: static JSBool
 80966: EmitNameOp(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, JSBool callContext)
 75502: {
 75502:     JSOp op;
 75502: 
 80966:     if (!BindNameToSlot(cx, bce, pn))
 75502:         return JS_FALSE;
 78294:     op = pn->getOp();
 75502: 
 75502:     if (callContext) {
 75502:         switch (op) {
 75502:           case JSOP_NAME:
 75502:             op = JSOP_CALLNAME;
 75502:             break;
 75502:           case JSOP_GETGNAME:
 75502:             op = JSOP_CALLGNAME;
 75502:             break;
 75502:           case JSOP_GETARG:
 75502:             op = JSOP_CALLARG;
 75502:             break;
 75502:           case JSOP_GETLOCAL:
 75502:             op = JSOP_CALLLOCAL;
 75502:             break;
 75502:           default:
 95100:             JS_ASSERT(op == JSOP_CALLEE);
 75502:             break;
 75502:         }
 75502:     }
 75502: 
 95100:     if (op == JSOP_CALLEE) {
 80966:         if (Emit1(cx, bce, op) < 0)
 95101:             return false;
 75502:     } else {
 75502:         if (!pn->pn_cookie.isFree()) {
 90965:             JS_ASSERT(JOF_OPTYPE(op) != JOF_ATOM);
 95101:             if (!EmitVarOp(cx, pn, op, bce))
 95101:                 return false;
 75502:         } else {
 80966:             if (!EmitAtomOp(cx, pn, op, bce))
 95101:                 return false;
 75502:         }
 75502:     }
 75502: 
 86855:     /* Need to provide |this| value for call */
 86855:     if (callContext) {
 86855:         if (op == JSOP_CALLNAME && bce->needsImplicitThis()) {
 86855:             if (!EmitAtomOp(cx, pn, JSOP_IMPLICITTHIS, bce))
 86855:                 return false;
 86855:         } else {
 86855:             if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 86855:                 return false;
 86855:         }
 86855:     }
 86855: 
 75502:     return JS_TRUE;
 75502: }
 75502: 
 75502: #if JS_HAS_XML_SUPPORT
 80632: static bool
 80966: EmitXMLName(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 80966: {
 98445:     JS_ASSERT(!bce->sc->inStrictMode());
 82114:     JS_ASSERT(pn->isKind(PNK_XMLUNARY));
 78294:     JS_ASSERT(pn->isOp(JSOP_XMLNAME));
 75502:     JS_ASSERT(op == JSOP_XMLNAME || op == JSOP_CALLXMLNAME);
 75502: 
 80632:     ParseNode *pn2 = pn->pn_kid;
 98477:     bool oldInForInit = bce->sc->inForInit;
 98477:     bce->sc->inForInit = false;
 80966:     if (!EmitTree(cx, bce, pn2))
 80966:         return false;
 98477:     bce->sc->inForInit = oldInForInit;
 80966:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pn2->pn_offset) < 0)
 80966:         return false;
 80966: 
 86855:     if (Emit1(cx, bce, op) < 0)
 86855:         return false;
 86855: 
 86855:     return true;
 75502: }
 75502: #endif
 75502: 
 77434: static inline bool
 80966: EmitElemOpBase(JSContext *cx, BytecodeEmitter *bce, JSOp op)
 80966: {
 80966:     if (Emit1(cx, bce, op) < 0)
 80966:         return false;
 80966:     CheckTypeSet(cx, bce, op);
 86855:     if (op == JSOP_CALLELEM)
 86855:         return Emit1(cx, bce, JSOP_SWAP) >= 0;
 77434:     return true;
 77434: }
 77434: 
 75510: static bool
 87822: EmitSpecialPropOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 87822: {
 87822:     /*
 87822:      * Special case for obj.__proto__ to deoptimize away from fast paths in the
 87822:      * interpreter and trace recorder, which skip dense array instances by
 87822:      * going up to Array.prototype before looking up the property name.
 87822:      */
 91479:     if (op == JSOP_CALLELEM && Emit1(cx, bce, JSOP_DUP) < 0)
 91479:         return false;
 91479: 
 87822:     jsatomid index;
 87822:     if (!bce->makeAtomIndex(pn->pn_atom, &index))
 87822:         return false;
 90965:     if (!EmitIndex32(cx, JSOP_QNAMEPART, index, bce))
 87822:         return false;
 87822: 
 91479:     return EmitElemOpBase(cx, bce, op);
 87822: }
 87822: 
 87822: static bool
 80966: EmitPropOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce,
 90965:            JSBool callContext)
 75502: {
 80631:     ParseNode *pn2, *pndot, *pnup, *pndown;
 75502:     ptrdiff_t top;
 75502: 
 78294:     JS_ASSERT(pn->isArity(PN_NAME));
 75502:     pn2 = pn->maybeExpr();
 75502: 
 87822:     /* Special case deoptimization for __proto__. */
 87822:     if ((op == JSOP_GETPROP || op == JSOP_CALLPROP) &&
 87822:         pn->pn_atom == cx->runtime->atomState.protoAtom) {
 87822:         if (pn2 && !EmitTree(cx, bce, pn2))
 87822:             return false;
 87822:         return EmitSpecialPropOp(cx, pn, callContext ? JSOP_CALLELEM : JSOP_GETELEM, bce);
 87822:     }
 87822: 
 75502:     if (callContext) {
 82024:         JS_ASSERT(pn->isKind(PNK_DOT));
 75502:         JS_ASSERT(op == JSOP_GETPROP);
 75502:         op = JSOP_CALLPROP;
 82024:     } else if (op == JSOP_GETPROP && pn->isKind(PNK_DOT)) {
 82024:         if (pn2->isKind(PNK_NAME)) {
 80966:             if (!BindNameToSlot(cx, bce, pn2))
 80632:                 return false;
 75502:         }
 75502:     }
 75502: 
 75502:     /*
 75502:      * If the object operand is also a dotted property reference, reverse the
 75502:      * list linked via pn_expr temporarily so we can iterate over it from the
 75502:      * bottom up (reversing again as we go), to avoid excessive recursion.
 75502:      */
 82024:     if (pn2->isKind(PNK_DOT)) {
 75502:         pndot = pn2;
 75502:         pnup = NULL;
 80966:         top = bce->offset();
 75502:         for (;;) {
 75502:             /* Reverse pndot->pn_expr to point up, not down. */
 75502:             pndot->pn_offset = top;
 78294:             JS_ASSERT(!pndot->isUsed());
 75502:             pndown = pndot->pn_expr;
 75502:             pndot->pn_expr = pnup;
 82024:             if (!pndown->isKind(PNK_DOT))
 75502:                 break;
 75502:             pnup = pndot;
 75502:             pndot = pndown;
 75502:         }
 75502: 
 75502:         /* pndown is a primary expression, not a dotted property reference. */
 80966:         if (!EmitTree(cx, bce, pndown))
 80632:             return false;
 75502: 
 75502:         do {
 75502:             /* Walk back up the list, emitting annotated name ops. */
 80966:             if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pndown->pn_offset) < 0)
 80632:                 return false;
 75502: 
 87822:             /* Special case deoptimization on __proto__, as above. */
 87822:             if (pndot->isArity(PN_NAME) && pndot->pn_atom == cx->runtime->atomState.protoAtom) {
 87822:                 if (!EmitSpecialPropOp(cx, pndot, JSOP_GETELEM, bce))
 87822:                     return false;
 87822:             } else if (!EmitAtomOp(cx, pndot, pndot->getOp(), bce)) {
 87822:                 return false;
 87822:             }
 75502: 
 75502:             /* Reverse the pn_expr link again. */
 75502:             pnup = pndot->pn_expr;
 75502:             pndot->pn_expr = pndown;
 75502:             pndown = pndot;
 75502:         } while ((pndot = pnup) != NULL);
 75502:     } else {
 80966:         if (!EmitTree(cx, bce, pn2))
 80966:             return false;
 80966:     }
 80966: 
 86855:     if (op == JSOP_CALLPROP && Emit1(cx, bce, JSOP_DUP) < 0)
 86855:         return false;
 86855: 
 80966:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pn2->pn_offset) < 0)
 80966:         return false;
 80966: 
 90965:     if (!EmitAtomOp(cx, pn, op, bce))
 86855:         return false;
 86855: 
 86855:     if (op == JSOP_CALLPROP && Emit1(cx, bce, JSOP_SWAP) < 0)
 86855:         return false;
 86855: 
 86855:     return true;
 75502: }
 75502: 
 77434: static bool
 80966: EmitPropIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 77434: {
 90965:     if (!EmitPropOp(cx, pn, op, bce, false))
 77434:         return false;
 77434: 
 77434:     /*
 77434:      * The stack is the same depth before/after INCPROP, so no balancing to do
 77434:      * before the decomposed version.
 77434:      */
 80966:     int start = bce->offset();
 80966: 
 77434:     const JSCodeSpec *cs = &js_CodeSpec[op];
 77434:     JS_ASSERT(cs->format & JOF_PROP);
 77434:     JS_ASSERT(cs->format & (JOF_INC | JOF_DEC));
 77434: 
 77434:     bool post = (cs->format & JOF_POST);
 77434:     JSOp binop = (cs->format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
 77434: 
 77434:                                                     // OBJ
 80966:     if (Emit1(cx, bce, JSOP_DUP) < 0)               // OBJ OBJ
 80966:         return false;
 80966:     if (!EmitAtomOp(cx, pn, JSOP_GETPROP, bce))     // OBJ V
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_POS) < 0)               // OBJ N
 80966:         return false;
 80966:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)       // OBJ N? N
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_ONE) < 0)               // OBJ N? N 1
 80966:         return false;
 80966:     if (Emit1(cx, bce, binop) < 0)                  // OBJ N? N+1
 77434:         return false;
 77434: 
 77434:     if (post) {
 80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)2) < 0)   // N? N+1 OBJ
 80966:             return false;
 80966:         if (Emit1(cx, bce, JSOP_SWAP) < 0)                  // N? OBJ N+1
 80966:             return false;
 80966:     }
 80966: 
 80966:     if (!EmitAtomOp(cx, pn, JSOP_SETPROP, bce))     // N? N+1
 80966:         return false;
 80966:     if (post && Emit1(cx, bce, JSOP_POP) < 0)       // RESULT
 80966:         return false;
 80966: 
 80966:     UpdateDecomposeLength(bce, start);
 80966: 
 77434:     return true;
 77434: }
 77434: 
 77434: static bool
 80966: EmitNameIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 77434: {
 90965:     /* Emit the composite op, including the slack byte at the end. */
 90965:     if (!EmitAtomIncDec(cx, pn->pn_atom, op, bce))
 77434:         return false;
 77434: 
 77434:     /* Remove the result to restore the stack depth before the INCNAME. */
 80966:     bce->stackDepth--;
 80966: 
 80966:     int start = bce->offset();
 80966: 
 77434:     const JSCodeSpec *cs = &js_CodeSpec[op];
 77434:     JS_ASSERT((cs->format & JOF_NAME) || (cs->format & JOF_GNAME));
 77434:     JS_ASSERT(cs->format & (JOF_INC | JOF_DEC));
 77434: 
 77434:     bool global = (cs->format & JOF_GNAME);
 77434:     bool post = (cs->format & JOF_POST);
 77434:     JSOp binop = (cs->format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
 77434: 
 80966:     if (!EmitAtomOp(cx, pn, global ? JSOP_BINDGNAME : JSOP_BINDNAME, bce))  // OBJ
 80966:         return false;
 80966:     if (!EmitAtomOp(cx, pn, global ? JSOP_GETGNAME : JSOP_NAME, bce))       // OBJ V
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_POS) < 0)               // OBJ N
 80966:         return false;
 80966:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)       // OBJ N? N
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_ONE) < 0)               // OBJ N? N 1
 80966:         return false;
 80966:     if (Emit1(cx, bce, binop) < 0)                  // OBJ N? N+1
 77434:         return false;
 77434: 
 77434:     if (post) {
 80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)2) < 0)   // N? N+1 OBJ
 80966:             return false;
 80966:         if (Emit1(cx, bce, JSOP_SWAP) < 0)                  // N? OBJ N+1
 80966:             return false;
 80966:     }
 80966: 
 80966:     if (!EmitAtomOp(cx, pn, global ? JSOP_SETGNAME : JSOP_SETNAME, bce))    // N? N+1
 80966:         return false;
 80966:     if (post && Emit1(cx, bce, JSOP_POP) < 0)       // RESULT
 80966:         return false;
 80966: 
 80966:     UpdateDecomposeLength(bce, start);
 80966: 
 77434:     return true;
 77434: }
 77434: 
 75502: static JSBool
 80966: EmitElemOp(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 75502: {
 81190:     ParseNode *left, *right;
 81190: 
 81190:     ptrdiff_t top = bce->offset();
 81190: 
 78294:     if (pn->isArity(PN_NAME)) {
 75502:         /*
 82024:          * Set left and right so pn appears to be a PNK_LB node, instead
 82024:          * of a PNK_DOT node.  See the PNK_FOR/IN case in EmitTree, and
 75502:          * EmitDestructuringOps nearer below.  In the destructuring case,
 75502:          * the base expression (pn_expr) of the name may be null, which
 75502:          * means we have to emit a JSOP_BINDNAME.
 75502:          */
 75502:         left = pn->maybeExpr();
 75502:         if (!left) {
 98181:             left = NullaryNode::create(PNK_STRING, bce->parser);
 80639:             if (!left)
 80639:                 return false;
 78294:             left->setOp(JSOP_BINDNAME);
 75502:             left->pn_pos = pn->pn_pos;
 75502:             left->pn_atom = pn->pn_atom;
 75502:         }
 98181:         right = NullaryNode::create(PNK_STRING, bce->parser);
 80639:         if (!right)
 80639:             return false;
 80633:         right->setOp(IsIdentifier(pn->pn_atom) ? JSOP_QNAMEPART : JSOP_STRING);
 75502:         right->pn_pos = pn->pn_pos;
 75502:         right->pn_atom = pn->pn_atom;
 75502:     } else {
 78294:         JS_ASSERT(pn->isArity(PN_BINARY));
 75502:         left = pn->pn_left;
 75502:         right = pn->pn_right;
 75502:     }
 75502: 
 82024:     if (op == JSOP_GETELEM && left->isKind(PNK_NAME) && right->isKind(PNK_NUMBER)) {
 80966:         if (!BindNameToSlot(cx, bce, left))
 80639:             return false;
 75502:     }
 75502: 
 80966:     if (!EmitTree(cx, bce, left))
 80639:         return false;
 75502: 
 86855:     if (op == JSOP_CALLELEM && Emit1(cx, bce, JSOP_DUP) < 0)
 86855:         return false;
 86855: 
 75502:     /* The right side of the descendant operator is implicitly quoted. */
 82024:     JS_ASSERT(op != JSOP_DESCENDANTS || !right->isKind(PNK_STRING) ||
 78294:               right->isOp(JSOP_QNAMEPART));
 80966:     if (!EmitTree(cx, bce, right))
 80966:         return false;
 80966:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
 80966:         return false;
 80966:     return EmitElemOpBase(cx, bce, op);
 77434: }
 77434: 
 77434: static bool
 80966: EmitElemIncDec(JSContext *cx, ParseNode *pn, JSOp op, BytecodeEmitter *bce)
 77434: {
 77434:     if (pn) {
 80966:         if (!EmitElemOp(cx, pn, op, bce))
 77434:             return false;
 77434:     } else {
 80966:         if (!EmitElemOpBase(cx, bce, op))
 80966:             return false;
 80966:     }
 80966:     if (Emit1(cx, bce, JSOP_NOP) < 0)
 77434:         return false;
 77434: 
 77434:     /* INCELEM pops two values and pushes one, so restore the initial depth. */
 80966:     bce->stackDepth++;
 80966: 
 80966:     int start = bce->offset();
 77434: 
 77434:     const JSCodeSpec *cs = &js_CodeSpec[op];
 77434:     JS_ASSERT(cs->format & JOF_ELEM);
 77434:     JS_ASSERT(cs->format & (JOF_INC | JOF_DEC));
 77434: 
 77434:     bool post = (cs->format & JOF_POST);
 77434:     JSOp binop = (cs->format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
 77434: 
 77434:     /*
 77434:      * We need to convert the key to an object id first, so that we do not do
 77434:      * it inside both the GETELEM and the SETELEM.
 77434:      */
 77434:                                                     // OBJ KEY*
 80966:     if (Emit1(cx, bce, JSOP_TOID) < 0)              // OBJ KEY
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_DUP2) < 0)              // OBJ KEY OBJ KEY
 80966:         return false;
 80966:     if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))     // OBJ KEY V
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_POS) < 0)               // OBJ KEY N
 80966:         return false;
 80966:     if (post && Emit1(cx, bce, JSOP_DUP) < 0)       // OBJ KEY N? N
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_ONE) < 0)               // OBJ KEY N? N 1
 80966:         return false;
 80966:     if (Emit1(cx, bce, binop) < 0)                  // OBJ KEY N? N+1
 77434:         return false;
 77434: 
 77434:     if (post) {
 80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)3) < 0)   // KEY N N+1 OBJ
 80966:             return false;
 80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)3) < 0)   // N N+1 OBJ KEY
 80966:             return false;
 80966:         if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)2) < 0)   // N OBJ KEY N+1
 80966:             return false;
 80966:     }
 80966: 
 80966:     if (!EmitElemOpBase(cx, bce, JSOP_SETELEM))     // N? N+1
 80966:         return false;
 80966:     if (post && Emit1(cx, bce, JSOP_POP) < 0)       // RESULT
 80966:         return false;
 80966: 
 80966:     UpdateDecomposeLength(bce, start);
 77434: 
 77434:     return true;
 75502: }
 75502: 
 75502: static JSBool
 90955: EmitNumberOp(JSContext *cx, double dval, BytecodeEmitter *bce)
 75502: {
 75502:     int32_t ival;
 84755:     uint32_t u;
 75502:     ptrdiff_t off;
 75502:     jsbytecode *pc;
 75502: 
 95341:     if (MOZ_DOUBLE_IS_INT32(dval, &ival)) {
 75502:         if (ival == 0)
 80966:             return Emit1(cx, bce, JSOP_ZERO) >= 0;
 75502:         if (ival == 1)
 80966:             return Emit1(cx, bce, JSOP_ONE) >= 0;
 91450:         if ((int)(int8_t)ival == ival)
 84755:             return Emit2(cx, bce, JSOP_INT8, (jsbytecode)(int8_t)ival) >= 0;
 84755: 
 84755:         u = (uint32_t)ival;
 75502:         if (u < JS_BIT(16)) {
 75502:             EMIT_UINT16_IMM_OP(JSOP_UINT16, u);
 75502:         } else if (u < JS_BIT(24)) {
 80966:             off = EmitN(cx, bce, JSOP_UINT24, 3);
 75502:             if (off < 0)
 75502:                 return JS_FALSE;
 80966:             pc = bce->code(off);
 75502:             SET_UINT24(pc, u);
 75502:         } else {
 80966:             off = EmitN(cx, bce, JSOP_INT32, 4);
 75502:             if (off < 0)
 75502:                 return JS_FALSE;
 80966:             pc = bce->code(off);
 75502:             SET_INT32(pc, ival);
 75502:         }
 75502:         return JS_TRUE;
 75502:     }
 75502: 
 80966:     if (!bce->constList.append(DoubleValue(dval)))
 80966:         return JS_FALSE;
 80966: 
 90965:     return EmitIndex32(cx, JSOP_DOUBLE, bce->constList.length() - 1, bce);
 75502: }
 75502: 
 75502: /*
 75502:  * To avoid bloating all parse nodes for the special case of switch, values are
 75502:  * allocated in the temp pool and pointed to by the parse node. These values
 75502:  * are not currently recycled (like parse nodes) and the temp pool is only
 75502:  * flushed at the end of compiling a script, so these values are technically
 75502:  * leaked. This would only be a problem for scripts containing a large number
 75502:  * of large switches, which seems unlikely.
 75502:  */
 75502: static Value *
 75502: AllocateSwitchConstant(JSContext *cx)
 75502: {
 79410:     return cx->tempLifoAlloc().new_<Value>();
 75502: }
 75502: 
 86877: static inline void
 86877: SetJumpOffsetAt(BytecodeEmitter *bce, ptrdiff_t off)
 86877: {
 86877:     SET_JUMP_OFFSET(bce->code(off), bce->offset() - off);
 86877: }
 86877: 
 91252: /*
 91252:  * Using MOZ_NEVER_INLINE in here is a workaround for llvm.org/pr12127.
 91252:  * LLVM is deciding to inline this function which uses a lot of stack space
 91252:  * into EmitTree which is recursive and uses relatively little stack space.
 91252:  */
 91253: MOZ_NEVER_INLINE static JSBool
 80966: EmitSwitch(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 75502: {
 75502:     JSOp switchOp;
 75502:     JSBool ok, hasDefault, constPropagated;
 75502:     ptrdiff_t top, off, defaultOffset;
 80631:     ParseNode *pn2, *pn3, *pn4;
 84755:     uint32_t caseCount, tableLength;
 80631:     ParseNode **table;
 75502:     int32_t i, low, high;
 91237:     int noteIndex;
 75502:     size_t switchSize, tableSize;
 75502:     jsbytecode *pc, *savepc;
 95355:     StmtInfo stmtInfo(cx);
 75502: 
 75502:     /* Try for most optimal, fall back if not dense ints, and per ECMAv2. */
 75502:     switchOp = JSOP_TABLESWITCH;
 75502:     ok = JS_TRUE;
 75502:     hasDefault = constPropagated = JS_FALSE;
 75502:     defaultOffset = -1;
 75502: 
 75502:     pn2 = pn->pn_right;
 75502: #if JS_HAS_BLOCK_SCOPE
 86078:     /*
 86078:      * If there are hoisted let declarations, their stack slots go under the
 86078:      * discriminant's value so push their slots now and enter the block later.
 86078:      */
 86483:     uint32_t blockObjCount = 0;
 82024:     if (pn2->isKind(PNK_LEXICALSCOPE)) {
 86483:         blockObjCount = pn2->pn_objbox->object->asStaticBlock().slotCount();
 86483:         for (uint32_t i = 0; i < blockObjCount; ++i) {
 86078:             if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 86078:                 return JS_FALSE;
 86078:         }
 86078:     }
 86078: #endif
 86078: 
 86078:     /* Push the discriminant. */
 86078:     if (!EmitTree(cx, bce, pn->pn_left))
 86078:         return JS_FALSE;
 86078: 
 86078: #if JS_HAS_BLOCK_SCOPE
 86078:     if (pn2->isKind(PNK_LEXICALSCOPE)) {
 98445:         PushBlockScope(bce->sc, &stmtInfo, pn2->pn_objbox->object->asStaticBlock(), -1);
 79378:         stmtInfo.type = STMT_SWITCH;
 86078:         if (!EmitEnterBlock(cx, bce, pn2, JSOP_ENTERLET1))
 86078:             return JS_FALSE;
 75502:     }
 75502: #endif
 75502: 
 75502:     /* Switch bytecodes run from here till end of final case. */
 80966:     top = bce->offset();
 75502: #if !JS_HAS_BLOCK_SCOPE
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_SWITCH, top);
 75502: #else
 82873:     if (pn2->isKind(PNK_STATEMENTLIST)) {
 98445:         PushStatement(bce->sc, &stmtInfo, STMT_SWITCH, top);
 75502:     } else {
 76232:         /*
 76232:          * Set the statement info record's idea of top. Reset top too, since
 76232:          * repushBlock emits code.
 76232:          */
 80966:         stmtInfo.update = top = bce->offset();
 75502: 
 75502:         /* Advance pn2 to refer to the switch case list. */
 75502:         pn2 = pn2->expr();
 75502:     }
 75502: #endif
 75502: 
 75502:     caseCount = pn2->pn_count;
 75502:     tableLength = 0;
 75502:     table = NULL;
 75502: 
 75502:     if (caseCount == 0 ||
 75502:         (caseCount == 1 &&
 82024:          (hasDefault = (pn2->pn_head->isKind(PNK_DEFAULT))))) {
 75502:         caseCount = 0;
 75502:         low = 0;
 75502:         high = -1;
 75502:     } else {
 75502: #define INTMAP_LENGTH   256
 75502:         jsbitmap intmap_space[INTMAP_LENGTH];
 75502:         jsbitmap *intmap = NULL;
 84755:         int32_t intmap_bitlen = 0;
 75502: 
 75502:         low  = JSVAL_INT_MAX;
 75502:         high = JSVAL_INT_MIN;
 75502: 
 75502:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
 82024:             if (pn3->isKind(PNK_DEFAULT)) {
 75502:                 hasDefault = JS_TRUE;
 75502:                 caseCount--;    /* one of the "cases" was the default */
 75502:                 continue;
 75502:             }
 75502: 
 82024:             JS_ASSERT(pn3->isKind(PNK_CASE));
 75502:             if (switchOp == JSOP_CONDSWITCH)
 75502:                 continue;
 75502: 
 75502:             pn4 = pn3->pn_left;
 82024:             while (pn4->isKind(PNK_RP))
 75502:                 pn4 = pn4->pn_kid;
 75502: 
 75502:             Value constVal;
 78294:             switch (pn4->getKind()) {
 82024:               case PNK_NUMBER:
 75502:                 constVal.setNumber(pn4->pn_dval);
 75502:                 break;
 82024:               case PNK_STRING:
 75502:                 constVal.setString(pn4->pn_atom);
 75502:                 break;
 82024:               case PNK_TRUE:
 82022:                 constVal.setBoolean(true);
 82022:                 break;
 82024:               case PNK_FALSE:
 82022:                 constVal.setBoolean(false);
 82022:                 break;
 82024:               case PNK_NULL:
 82022:                 constVal.setNull();
 82022:                 break;
 82024:               case PNK_NAME:
 75502:                 if (!pn4->maybeExpr()) {
 80966:                     ok = LookupCompileTimeConstant(cx, bce, pn4->pn_atom, &constVal);
 75502:                     if (!ok)
 75502:                         goto release;
 75502:                     if (!constVal.isMagic(JS_NO_CONSTANT)) {
 75502:                         if (constVal.isObject()) {
 75502:                             /*
 75502:                              * XXX JSOP_LOOKUPSWITCH does not support const-
 75502:                              * propagated object values, see bug 407186.
 75502:                              */
 75502:                             switchOp = JSOP_CONDSWITCH;
 75502:                             continue;
 75502:                         }
 97940:                         if (constVal.isString()) {
 97940:                             JSAtom *atom = js_AtomizeString(cx, constVal.toString());
 97940:                             if (!atom) {
 97940:                                 ok = JS_FALSE;
 97940:                                 goto release;
 97940:                             }
 97940:                             constVal.setString(atom);
 97940:                         }
 75502:                         constPropagated = JS_TRUE;
 75502:                         break;
 75502:                     }
 75502:                 }
 75502:                 /* FALL THROUGH */
 75502:               default:
 75502:                 switchOp = JSOP_CONDSWITCH;
 75502:                 continue;
 75502:             }
 75502:             JS_ASSERT(constVal.isPrimitive());
 75502: 
 75502:             pn3->pn_pval = AllocateSwitchConstant(cx);
 75502:             if (!pn3->pn_pval) {
 75502:                 ok = JS_FALSE;
 75502:                 goto release;
 75502:             }
 75502: 
 75502:             *pn3->pn_pval = constVal;
 75502: 
 75502:             if (switchOp != JSOP_TABLESWITCH)
 75502:                 continue;
 75502:             if (!pn3->pn_pval->isInt32()) {
 75502:                 switchOp = JSOP_LOOKUPSWITCH;
 75502:                 continue;
 75502:             }
 75502:             i = pn3->pn_pval->toInt32();
 91612:             if ((unsigned)(i + (int)JS_BIT(15)) >= (unsigned)JS_BIT(16)) {
 75502:                 switchOp = JSOP_LOOKUPSWITCH;
 75502:                 continue;
 75502:             }
 75502:             if (i < low)
 75502:                 low = i;
 75502:             if (high < i)
 75502:                 high = i;
 75502: 
 75502:             /*
 75502:              * Check for duplicates, which require a JSOP_LOOKUPSWITCH.
 75502:              * We bias i by 65536 if it's negative, and hope that's a rare
 75502:              * case (because it requires a malloc'd bitmap).
 75502:              */
 75502:             if (i < 0)
 75502:                 i += JS_BIT(16);
 75502:             if (i >= intmap_bitlen) {
 75502:                 if (!intmap &&
 75502:                     i < (INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2)) {
 75502:                     intmap = intmap_space;
 75502:                     intmap_bitlen = INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2;
 75502:                 } else {
 75502:                     /* Just grab 8K for the worst-case bitmap. */
 75502:                     intmap_bitlen = JS_BIT(16);
 75502:                     intmap = (jsbitmap *)
 75502:                         cx->malloc_((JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
 75502:                                    * sizeof(jsbitmap));
 75502:                     if (!intmap) {
 75502:                         JS_ReportOutOfMemory(cx);
 75502:                         return JS_FALSE;
 75502:                     }
 75502:                 }
 75502:                 memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
 75502:             }
 75502:             if (JS_TEST_BIT(intmap, i)) {
 75502:                 switchOp = JSOP_LOOKUPSWITCH;
 75502:                 continue;
 75502:             }
 75502:             JS_SET_BIT(intmap, i);
 75502:         }
 75502: 
 75502:       release:
 75502:         if (intmap && intmap != intmap_space)
 75502:             cx->free_(intmap);
 75502:         if (!ok)
 75502:             return JS_FALSE;
 75502: 
 75502:         /*
 75502:          * Compute table length and select lookup instead if overlarge or
 75502:          * more than half-sparse.
 75502:          */
 75502:         if (switchOp == JSOP_TABLESWITCH) {
 84755:             tableLength = (uint32_t)(high - low + 1);
 75502:             if (tableLength >= JS_BIT(16) || tableLength > 2 * caseCount)
 75502:                 switchOp = JSOP_LOOKUPSWITCH;
 75502:         } else if (switchOp == JSOP_LOOKUPSWITCH) {
 75502:             /*
 75502:              * Lookup switch supports only atom indexes below 64K limit.
 75502:              * Conservatively estimate the maximum possible index during
 75502:              * switch generation and use conditional switch if it exceeds
 75502:              * the limit.
 75502:              */
 80966:             if (caseCount + bce->constList.length() > JS_BIT(16))
 75502:                 switchOp = JSOP_CONDSWITCH;
 75502:         }
 75502:     }
 75502: 
 75502:     /*
 75502:      * Emit a note with two offsets: first tells total switch code length,
 75502:      * second tells offset to first JSOP_CASE if condswitch.
 75502:      */
 80966:     noteIndex = NewSrcNote3(cx, bce, SRC_SWITCH, 0, 0);
 75502:     if (noteIndex < 0)
 75502:         return JS_FALSE;
 75502: 
 75502:     if (switchOp == JSOP_CONDSWITCH) {
 75502:         /*
 75502:          * 0 bytes of immediate for unoptimized ECMAv2 switch.
 75502:          */
 75502:         switchSize = 0;
 75502:     } else if (switchOp == JSOP_TABLESWITCH) {
 75502:         /*
 75502:          * 3 offsets (len, low, high) before the table, 1 per entry.
 75502:          */
 75502:         switchSize = (size_t)(JUMP_OFFSET_LEN * (3 + tableLength));
 75502:     } else {
 75502:         /*
 75502:          * JSOP_LOOKUPSWITCH:
 75502:          * 1 offset (len) and 1 atom index (npairs) before the table,
 75502:          * 1 atom index and 1 jump offset per entry.
 75502:          */
 90965:         switchSize = (size_t)(JUMP_OFFSET_LEN + UINT16_LEN +
 90965:                               (UINT32_INDEX_LEN + JUMP_OFFSET_LEN) * caseCount);
 75502:     }
 75502: 
 86877:     /* Emit switchOp followed by switchSize bytes of jump or lookup table. */
 80966:     if (EmitN(cx, bce, switchOp, switchSize) < 0)
 75502:         return JS_FALSE;
 75502: 
 75502:     off = -1;
 75502:     if (switchOp == JSOP_CONDSWITCH) {
 91237:         int caseNoteIndex = -1;
 75502:         JSBool beforeCases = JS_TRUE;
 75502: 
 75502:         /* Emit code for evaluating cases and jumping to case statements. */
 75502:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
 75502:             pn4 = pn3->pn_left;
 80966:             if (pn4 && !EmitTree(cx, bce, pn4))
 75502:                 return JS_FALSE;
 75502:             if (caseNoteIndex >= 0) {
 75502:                 /* off is the previous JSOP_CASE's bytecode offset. */
 91237:                 if (!SetSrcNoteOffset(cx, bce, (unsigned)caseNoteIndex, 0, bce->offset() - off))
 80632:                     return JS_FALSE;
 75502:             }
 75502:             if (!pn4) {
 82024:                 JS_ASSERT(pn3->isKind(PNK_DEFAULT));
 75502:                 continue;
 75502:             }
 80966:             caseNoteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
 75502:             if (caseNoteIndex < 0)
 75502:                 return JS_FALSE;
 80966:             off = EmitJump(cx, bce, JSOP_CASE, 0);
 75502:             if (off < 0)
 75502:                 return JS_FALSE;
 75502:             pn3->pn_offset = off;
 75502:             if (beforeCases) {
 91237:                 unsigned noteCount, noteCountDelta;
 75502: 
 75502:                 /* Switch note's second offset is to first JSOP_CASE. */
 80966:                 noteCount = bce->noteCount();
 91237:                 if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 1, off - top))
 80966:                     return JS_FALSE;
 80966:                 noteCountDelta = bce->noteCount() - noteCount;
 75502:                 if (noteCountDelta != 0)
 75502:                     caseNoteIndex += noteCountDelta;
 75502:                 beforeCases = JS_FALSE;
 75502:             }
 75502:         }
 75502: 
 75502:         /*
 75502:          * If we didn't have an explicit default (which could fall in between
 80632:          * cases, preventing us from fusing this SetSrcNoteOffset with the call
 80632:          * in the loop above), link the last case to the implicit default for
 80632:          * the decompiler.
 75502:          */
 75502:         if (!hasDefault &&
 75502:             caseNoteIndex >= 0 &&
 91237:             !SetSrcNoteOffset(cx, bce, (unsigned)caseNoteIndex, 0, bce->offset() - off))
 80632:         {
 75502:             return JS_FALSE;
 75502:         }
 75502: 
 75502:         /* Emit default even if no explicit default statement. */
 80966:         defaultOffset = EmitJump(cx, bce, JSOP_DEFAULT, 0);
 75502:         if (defaultOffset < 0)
 75502:             return JS_FALSE;
 75502:     } else {
 80966:         pc = bce->code(top + JUMP_OFFSET_LEN);
 75502: 
 75502:         if (switchOp == JSOP_TABLESWITCH) {
 75502:             /* Fill in switch bounds, which we know fit in 16-bit offsets. */
 75502:             SET_JUMP_OFFSET(pc, low);
 75502:             pc += JUMP_OFFSET_LEN;
 75502:             SET_JUMP_OFFSET(pc, high);
 75502:             pc += JUMP_OFFSET_LEN;
 75502: 
 75502:             /*
 75502:              * Use malloc to avoid arena bloat for programs with many switches.
 75502:              * We free table if non-null at label out, so all control flow must
 75502:              * exit this function through goto out or goto bad.
 75502:              */
 75502:             if (tableLength != 0) {
 75502:                 tableSize = (size_t)tableLength * sizeof *table;
 80631:                 table = (ParseNode **) cx->malloc_(tableSize);
 75502:                 if (!table)
 75502:                     return JS_FALSE;
 75502:                 memset(table, 0, tableSize);
 75502:                 for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
 82024:                     if (pn3->isKind(PNK_DEFAULT))
 75502:                         continue;
 75502:                     i = pn3->pn_pval->toInt32();
 75502:                     i -= low;
 84755:                     JS_ASSERT((uint32_t)i < tableLength);
 75502:                     table[i] = pn3;
 75502:                 }
 75502:             }
 75502:         } else {
 75502:             JS_ASSERT(switchOp == JSOP_LOOKUPSWITCH);
 75502: 
 75502:             /* Fill in the number of cases. */
 90965:             SET_UINT16(pc, caseCount);
 90965:             pc += UINT16_LEN;
 75502:         }
 75502: 
 75502:         /*
 75502:          * After this point, all control flow involving JSOP_TABLESWITCH
 75502:          * must set ok and goto out to exit this function.  To keep things
 75502:          * simple, all switchOp cases exit that way.
 75502:          */
 75502:         MUST_FLOW_THROUGH("out");
 75502: 
 75502:         if (constPropagated) {
 75502:             /*
 75502:              * Skip switchOp, as we are not setting jump offsets in the two
 80966:              * for loops below.  We'll restore bce->next() from savepc after,
 75502:              * unless there was an error.
 75502:              */
 80966:             savepc = bce->next();
 80966:             bce->current->next = pc + 1;
 75502:             if (switchOp == JSOP_TABLESWITCH) {
 91450:                 for (i = 0; i < (int)tableLength; i++) {
 75502:                     pn3 = table[i];
 75502:                     if (pn3 &&
 75502:                         (pn4 = pn3->pn_left) != NULL &&
 82024:                         pn4->isKind(PNK_NAME))
 82024:                     {
 75502:                         /* Note a propagated constant with the const's name. */
 75502:                         JS_ASSERT(!pn4->maybeExpr());
 75510:                         jsatomid index;
 80966:                         if (!bce->makeAtomIndex(pn4->pn_atom, &index))
 75502:                             goto bad;
 80966:                         bce->current->next = pc;
 80966:                         if (NewSrcNote2(cx, bce, SRC_LABEL, ptrdiff_t(index)) < 0)
 75502:                             goto bad;
 75502:                     }
 75502:                     pc += JUMP_OFFSET_LEN;
 75502:                 }
 75502:             } else {
 75502:                 for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
 75502:                     pn4 = pn3->pn_left;
 82024:                     if (pn4 && pn4->isKind(PNK_NAME)) {
 75502:                         /* Note a propagated constant with the const's name. */
 75502:                         JS_ASSERT(!pn4->maybeExpr());
 75510:                         jsatomid index;
 80966:                         if (!bce->makeAtomIndex(pn4->pn_atom, &index))
 75502:                             goto bad;
 80966:                         bce->current->next = pc;
 80966:                         if (NewSrcNote2(cx, bce, SRC_LABEL, ptrdiff_t(index)) < 0)
 75502:                             goto bad;
 75502:                     }
 90965:                     pc += UINT32_INDEX_LEN + JUMP_OFFSET_LEN;
 75502:                 }
 75502:             }
 80966:             bce->current->next = savepc;
 75502:         }
 75502:     }
 75502: 
 75502:     /* Emit code for each case's statements, copying pn_offset up to pn3. */
 75502:     for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
 82024:         if (switchOp == JSOP_CONDSWITCH && !pn3->isKind(PNK_DEFAULT))
 86877:             SetJumpOffsetAt(bce, pn3->pn_offset);
 75502:         pn4 = pn3->pn_right;
 80966:         ok = EmitTree(cx, bce, pn4);
 75502:         if (!ok)
 75502:             goto out;
 75502:         pn3->pn_offset = pn4->pn_offset;
 82024:         if (pn3->isKind(PNK_DEFAULT))
 75502:             off = pn3->pn_offset - top;
 75502:     }
 75502: 
 75502:     if (!hasDefault) {
 75502:         /* If no default case, offset for default is to end of switch. */
 80966:         off = bce->offset() - top;
 75502:     }
 75502: 
 75502:     /* We better have set "off" by now. */
 75502:     JS_ASSERT(off != -1);
 75502: 
 75502:     /* Set the default offset (to end of switch if no default). */
 75502:     if (switchOp == JSOP_CONDSWITCH) {
 75502:         pc = NULL;
 75502:         JS_ASSERT(defaultOffset != -1);
 86877:         SET_JUMP_OFFSET(bce->code(defaultOffset), off - (defaultOffset - top));
 75502:     } else {
 80966:         pc = bce->code(top);
 86877:         SET_JUMP_OFFSET(pc, off);
 75502:         pc += JUMP_OFFSET_LEN;
 75502:     }
 75502: 
 75502:     /* Set the SRC_SWITCH note's offset operand to tell end of switch. */
 80966:     off = bce->offset() - top;
 91237:     ok = SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, off);
 75502:     if (!ok)
 75502:         goto out;
 75502: 
 75502:     if (switchOp == JSOP_TABLESWITCH) {
 75502:         /* Skip over the already-initialized switch bounds. */
 75502:         pc += 2 * JUMP_OFFSET_LEN;
 75502: 
 75502:         /* Fill in the jump table, if there is one. */
 91450:         for (i = 0; i < (int)tableLength; i++) {
 75502:             pn3 = table[i];
 75502:             off = pn3 ? pn3->pn_offset - top : 0;
 86877:             SET_JUMP_OFFSET(pc, off);
 75502:             pc += JUMP_OFFSET_LEN;
 75502:         }
 75502:     } else if (switchOp == JSOP_LOOKUPSWITCH) {
 75502:         /* Skip over the already-initialized number of cases. */
 90965:         pc += UINT16_LEN;
 75502: 
 75502:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
 82024:             if (pn3->isKind(PNK_DEFAULT))
 75502:                 continue;
 80966:             if (!bce->constList.append(*pn3->pn_pval))
 75502:                 goto bad;
 90965:             SET_UINT32_INDEX(pc, bce->constList.length() - 1);
 90965:             pc += UINT32_INDEX_LEN;
 75502: 
 75502:             off = pn3->pn_offset - top;
 86877:             SET_JUMP_OFFSET(pc, off);
 75502:             pc += JUMP_OFFSET_LEN;
 75502:         }
 75502:     }
 75502: 
 75502: out:
 75502:     if (table)
 75502:         cx->free_(table);
 75502:     if (ok) {
 80966:         ok = PopStatementBCE(cx, bce);
 75502: 
 75502: #if JS_HAS_BLOCK_SCOPE
 82024:         if (ok && pn->pn_right->isKind(PNK_LEXICALSCOPE))
 86483:             EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, blockObjCount);
 75502: #endif
 75502:     }
 75502:     return ok;
 75502: 
 75502: bad:
 75502:     ok = JS_FALSE;
 75502:     goto out;
 75502: }
 75502: 
 75502: JSBool
 80966: frontend::EmitFunctionScript(JSContext *cx, BytecodeEmitter *bce, ParseNode *body)
 75502: {
 75502:     /*
 75502:      * The decompiler has assumptions about what may occur immediately after
 75502:      * script->main (e.g., in the case of destructuring params). Thus, put the
 75502:      * following ops into the range [script->code, script->main). Note:
 75502:      * execution starts from script->code, so this has no semantic effect.
 75502:      */
 75502: 
 98687:     if (bce->sc->funArgumentsHasLocalBinding()) {
 95100:         JS_ASSERT(bce->next() == bce->base());  /* See JSScript::argumentsBytecode. */
 95100:         bce->switchToProlog();
 95100:         if (Emit1(cx, bce, JSOP_ARGUMENTS) < 0)
 95100:             return false;
 98445:         if (bce->sc->bindingsAccessedDynamically()) {
100006:             JSAtom *atom = cx->runtime->atomState.argumentsAtom;
100006:             uint16_t binding = bce->sc->bindings.localToBinding(bce->sc->argumentsLocalSlot());
100006:             if (!EmitAliasedVarOp(cx, JSOP_SETALIASEDVAR, binding, atom, bce))
 95101:                 return false;
 95101:         } else {
100006:             if (!EmitUnaliasedVarOp(cx, JSOP_SETLOCAL, bce->sc->argumentsLocalSlot(), bce))
 95101:                 return false;
 95101:         }
 95100:         if (Emit1(cx, bce, JSOP_POP) < 0)
 95100:             return false;
 95100:         bce->switchToMain();
 95100:     }
 95100: 
 98687:     if (bce->sc->funIsGenerator()) {
 80966:         bce->switchToProlog();
 80966:         if (Emit1(cx, bce, JSOP_GENERATOR) < 0)
 80966:             return false;
 80966:         bce->switchToMain();
 75502:     }
 75502: 
 80966:     return EmitTree(cx, bce, body) &&
 80966:            Emit1(cx, bce, JSOP_STOP) >= 0 &&
 80966:            JSScript::NewScriptFromEmitter(cx, bce);
 75502: }
 75502: 
 72579: static bool
 80966: MaybeEmitVarDecl(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn,
 80966:                  jsatomid *result)
     1: {
     1:     jsatomid atomIndex;
     1: 
 47573:     if (!pn->pn_cookie.isFree()) {
 72579:         atomIndex = pn->pn_cookie.slot();
     1:     } else {
 80966:         if (!bce->makeAtomIndex(pn->pn_atom, &atomIndex))
 72579:             return false;
     1:     }
     1: 
 78294:     if (JOF_OPTYPE(pn->getOp()) == JOF_ATOM &&
 98687:         (!bce->sc->inFunction || bce->sc->funIsHeavyweight()))
 52555:     {
 80966:         bce->switchToProlog();
 80966:         if (!UpdateLineNumberNotes(cx, bce, pn->pn_pos.begin.lineno))
 72579:             return false;
 90965:         if (!EmitIndexOp(cx, prologOp, atomIndex, bce))
 90965:             return false;
 80966:         bce->switchToMain();
 80966:     }
 80966: 
 98476:     if (bce->sc->inFunction &&
 78294:         JOF_OPTYPE(pn->getOp()) == JOF_LOCAL &&
 95098:         !pn->isLet() &&
 80966:         bce->shouldNoteClosedName(pn))
 80966:     {
 95098:         if (!bce->noteClosedVar(pn))
 72579:             return false;
 52878:     }
 52878: 
     1:     if (result)
     1:         *result = atomIndex;
 72579:     return true;
     1: }
     1: 
 86078: /*
 86078:  * This enum tells EmitVariables and the destructuring functions how emit the
 86078:  * given Parser::variables parse tree. In the base case, DefineVars, the caller
 86078:  * only wants variables to be defined in the prologue (if necessary). For
 86078:  * PushInitialValues, variable initializer expressions are evaluated and left
 86078:  * on the stack. For InitializeVars, the initializer expressions values are
 86078:  * assigned (to local variables) and popped.
 86078:  */
 86078: enum VarEmitOption
 86078: {
 86078:     DefineVars        = 0,
 86078:     PushInitialValues = 1,
 86078:     InitializeVars    = 2
 86078: };
 86078: 
     1: #if JS_HAS_DESTRUCTURING
     1: 
     1: typedef JSBool
 80966: (*DestructuringDeclEmitter)(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn);
     1: 
     1: static JSBool
 80966: EmitDestructuringDecl(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn)
     1: {
 82024:     JS_ASSERT(pn->isKind(PNK_NAME));
 80966:     if (!BindNameToSlot(cx, bce, pn))
  9604:         return JS_FALSE;
     1: 
 95100:     JS_ASSERT(!pn->isOp(JSOP_CALLEE));
 80966:     return MaybeEmitVarDecl(cx, bce, prologOp, pn, NULL);
     1: }
     1: 
     1: static JSBool
 80966: EmitDestructuringDecls(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn)
 80631: {
 80631:     ParseNode *pn2, *pn3;
     1:     DestructuringDeclEmitter emitter;
     1: 
 82024:     if (pn->isKind(PNK_RB)) {
     1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 82024:             if (pn2->isKind(PNK_COMMA))
     1:                 continue;
 82024:             emitter = (pn2->isKind(PNK_NAME))
     1:                       ? EmitDestructuringDecl
     1:                       : EmitDestructuringDecls;
 80966:             if (!emitter(cx, bce, prologOp, pn2))
     1:                 return JS_FALSE;
     1:         }
     1:     } else {
 82024:         JS_ASSERT(pn->isKind(PNK_RC));
     1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
     1:             pn3 = pn2->pn_right;
 82024:             emitter = pn3->isKind(PNK_NAME) ? EmitDestructuringDecl : EmitDestructuringDecls;
 80966:             if (!emitter(cx, bce, prologOp, pn3))
     1:                 return JS_FALSE;
     1:         }
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 86078: EmitDestructuringOpsHelper(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn,
 86078:                            VarEmitOption emitOption);
 86078: 
 86078: /*
 86078:  * EmitDestructuringLHS assumes the to-be-destructured value has been pushed on
 86078:  * the stack and emits code to destructure a single lhs expression (either a
 86078:  * name or a compound []/{} expression).
 86078:  *
 86078:  * If emitOption is InitializeVars, the to-be-destructured value is assigned to
 86078:  * locals and ultimately the initial slot is popped (-1 total depth change).
 86078:  *
 86078:  * If emitOption is PushInitialValues, the to-be-destructured value is replaced
 86078:  * with the initial values of the N (where 0 <= N) variables assigned in the
 86078:  * lhs expression. (Same post-condition as EmitDestructuringOpsHelper)
 86078:  */
     1: static JSBool
 86078: EmitDestructuringLHS(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, VarEmitOption emitOption)
 86078: {
 86078:     JS_ASSERT(emitOption != DefineVars);
 86078: 
     1:     /*
     1:      * Now emit the lvalue opcode sequence.  If the lvalue is a nested
     1:      * destructuring initialiser-form, call ourselves to handle it, then
     1:      * pop the matched value.  Otherwise emit an lvalue bytecode sequence
     1:      * ending with a JSOP_ENUMELEM or equivalent op.
     1:      */
 82024:     if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
 86078:         if (!EmitDestructuringOpsHelper(cx, bce, pn, emitOption))
 86078:             return JS_FALSE;
 86078:         if (emitOption == InitializeVars) {
 86078:             /*
 86078:              * Per its post-condition, EmitDestructuringOpsHelper has left the
 86078:              * to-be-destructured value on top of the stack.
 86078:              */
 80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
     1:                 return JS_FALSE;
 86078:         }
     1:     } else {
 86078:         if (emitOption == PushInitialValues) {
 86078:             /*
 86078:              * The lhs is a simple name so the to-be-destructured value is
 86078:              * its initial value and there is nothing to do.
 86078:              */
 86078:             JS_ASSERT(pn->getOp() == JSOP_SETLOCAL);
 86078:             JS_ASSERT(pn->pn_dflags & PND_BOUND);
 86078:             return JS_TRUE;
 86078:         }
 86078: 
 86078:         /* All paths below must pop after assigning to the lhs. */
 86078: 
 82024:         if (pn->isKind(PNK_NAME)) {
 80966:             if (!BindNameToSlot(cx, bce, pn))
 27012:                 return JS_FALSE;
 27012:             if (pn->isConst() && !pn->isInitialized())
 80966:                 return Emit1(cx, bce, JSOP_POP) >= 0;
 27012:         }
     1: 
 78294:         switch (pn->getOp()) {
     1:           case JSOP_SETNAME:
 52825:           case JSOP_SETGNAME:
     1:             /*
     1:              * NB: pn is a PN_NAME node, not a PN_BINARY.  Nevertheless,
     1:              * we want to emit JSOP_ENUMELEM, which has format JOF_ELEM.
     1:              * So here and for JSOP_ENUMCONSTELEM, we use EmitElemOp.
     1:              */
 80966:             if (!EmitElemOp(cx, pn, JSOP_ENUMELEM, bce))
     1:                 return JS_FALSE;
     1:             break;
     1: 
     1:           case JSOP_SETCONST:
 80966:             if (!EmitElemOp(cx, pn, JSOP_ENUMCONSTELEM, bce))
     1:                 return JS_FALSE;
     1:             break;
     1: 
     1:           case JSOP_SETLOCAL:
 95100:           case JSOP_SETARG:
 95101:             if (!EmitVarOp(cx, pn, pn->getOp(), bce))
 95101:                 return JS_FALSE;
 94278:             if (Emit1(cx, bce, JSOP_POP) < 0)
 94278:                 return JS_FALSE;
     1:             break;
     1: 
     1:           default:
     1:           {
     1:             ptrdiff_t top;
     1: 
 80966:             top = bce->offset();
 80966:             if (!EmitTree(cx, bce, pn))
 80966:                 return JS_FALSE;
 80966:             if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
 80966:                 return JS_FALSE;
 80966:             if (!EmitElemOpBase(cx, bce, JSOP_ENUMELEM))
     1:                 return JS_FALSE;
     1:             break;
     1:           }
 31815: 
     1:           case JSOP_ENUMELEM:
     1:             JS_ASSERT(0);
     1:         }
     1:     }
     1: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: /*
     1:  * Recursive helper for EmitDestructuringOps.
 86078:  * EmitDestructuringOpsHelper assumes the to-be-destructured value has been
 86078:  * pushed on the stack and emits code to destructure each part of a [] or {}
 86078:  * lhs expression.
     1:  *
 86078:  * If emitOption is InitializeVars, the initial to-be-destructured value is
 86078:  * left untouched on the stack and the overall depth is not changed.
 86078:  *
 86078:  * If emitOption is PushInitialValues, the to-be-destructured value is replaced
 86078:  * with the initial values of the N (where 0 <= N) variables assigned in the
 86078:  * lhs expression. (Same post-condition as EmitDestructuringLHS)
     1:  */
     1: static JSBool
 86078: EmitDestructuringOpsHelper(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn,
 86078:                            VarEmitOption emitOption)
 86078: {
 86078:     JS_ASSERT(emitOption != DefineVars);
 86078: 
 91612:     unsigned index;
 80631:     ParseNode *pn2, *pn3;
     1:     JSBool doElemOp;
     1: 
     1: #ifdef DEBUG
 91237:     int stackDepth = bce->stackDepth;
     1:     JS_ASSERT(stackDepth != 0);
 78294:     JS_ASSERT(pn->isArity(PN_LIST));
 82024:     JS_ASSERT(pn->isKind(PNK_RB) || pn->isKind(PNK_RC));
     1: #endif
     1: 
     1:     if (pn->pn_count == 0) {
     1:         /* Emit a DUP;POP sequence for the decompiler. */
 86078:         if (Emit1(cx, bce, JSOP_DUP) < 0 || Emit1(cx, bce, JSOP_POP) < 0)
 86078:             return JS_FALSE;
     1:     }
     1: 
     1:     index = 0;
     1:     for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
     1:         /*
     1:          * Duplicate the value being destructured to use as a reference base.
 26956:          * If dup is not the first one, annotate it for the decompiler.
 26956:          */
 80966:         if (pn2 != pn->pn_head && NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
 80966:             return JS_FALSE;
 80966:         if (Emit1(cx, bce, JSOP_DUP) < 0)
     1:             return JS_FALSE;
     1: 
     1:         /*
     1:          * Now push the property name currently being matched, which is either
     1:          * the array initialiser's current index, or the current property name
     1:          * "label" on the left of a colon in the object initialiser.  Set pn3
     1:          * to the lvalue node, which is in the value-initializing position.
     1:          */
     1:         doElemOp = JS_TRUE;
 82024:         if (pn->isKind(PNK_RB)) {
 80966:             if (!EmitNumberOp(cx, index, bce))
     1:                 return JS_FALSE;
     1:             pn3 = pn2;
     1:         } else {
 82024:             JS_ASSERT(pn->isKind(PNK_RC));
 82024:             JS_ASSERT(pn2->isKind(PNK_COLON));
     1:             pn3 = pn2->pn_left;
 82024:             if (pn3->isKind(PNK_NUMBER)) {
     1:                 /*
     1:                  * If we are emitting an object destructuring initialiser,
     1:                  * annotate the index op with SRC_INITPROP so we know we are
     1:                  * not decompiling an array initialiser.
     1:                  */
 80966:                 if (NewSrcNote(cx, bce, SRC_INITPROP) < 0)
 80966:                     return JS_FALSE;
 80966:                 if (!EmitNumberOp(cx, pn3->pn_dval, bce))
     1:                     return JS_FALSE;
     1:             } else {
 82024:                 JS_ASSERT(pn3->isKind(PNK_STRING) || pn3->isKind(PNK_NAME));
 80966:                 if (!EmitAtomOp(cx, pn3, JSOP_GETPROP, bce))
     1:                     return JS_FALSE;
     1:                 doElemOp = JS_FALSE;
     1:             }
     1:             pn3 = pn2->pn_right;
     1:         }
     1: 
     1:         if (doElemOp) {
     1:             /*
     1:              * Ok, get the value of the matching property name.  This leaves
     1:              * that value on top of the value being destructured, so the stack
     1:              * is one deeper than when we started.
     1:              */
 80966:             if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))
 80966:                 return JS_FALSE;
 86078:             JS_ASSERT(bce->stackDepth >= stackDepth + 1);
     1:         }
     1: 
     1:         /* Nullary comma node makes a hole in the array destructurer. */
 82024:         if (pn3->isKind(PNK_COMMA) && pn3->isArity(PN_NULLARY)) {
 82024:             JS_ASSERT(pn->isKind(PNK_RB));
     1:             JS_ASSERT(pn2 == pn3);
 80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
     1:                 return JS_FALSE;
     1:         } else {
 91237:             int depthBefore = bce->stackDepth;
 86078:             if (!EmitDestructuringLHS(cx, bce, pn3, emitOption))
 86078:                 return JS_FALSE;
 86078: 
 86078:             if (emitOption == PushInitialValues) {
 86078:                 /*
 86078:                  * After '[x,y]' in 'let ([[x,y], z] = o)', the stack is
 86078:                  *   | to-be-decompiled-value | x | y |
 86078:                  * The goal is:
 86078:                  *   | x | y | z |
 86078:                  * so emit a pick to produce the intermediate state
 86078:                  *   | x | y | to-be-decompiled-value |
 86078:                  * before destructuring z. This gives the loop invariant that
 86078:                  * the to-be-compiled-value is always on top of the stack.
 86078:                  */
 86078:                 JS_ASSERT((bce->stackDepth - bce->stackDepth) >= -1);
 91237:                 unsigned pickDistance = (unsigned)((bce->stackDepth + 1) - depthBefore);
 86078:                 if (pickDistance > 0) {
 87974:                     if (pickDistance > UINT8_MAX) {
 86078:                         ReportCompileErrorNumber(cx, bce->tokenStream(), pn3, JSREPORT_ERROR,
 86078:                                                  JSMSG_TOO_MANY_LOCALS);
 86078:                         return JS_FALSE;
 86078:                     }
 86078:                     if (Emit2(cx, bce, JSOP_PICK, (jsbytecode)pickDistance) < 0)
 86078:                         return false;
 86078:                 }
 86078:             }
 86078:         }
 86078: 
     1:         ++index;
     1:     }
     1: 
 86078:     if (emitOption == PushInitialValues) {
 86078:         /*
 86078:          * Per the above loop invariant, to-be-decompiled-value is at the top
 86078:          * of the stack. To achieve the post-condition, pop it.
 86078:          */
 86078:         if (Emit1(cx, bce, JSOP_POP) < 0)
 86078:             return JS_FALSE;
 86078:     }
 86078: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: static ptrdiff_t
     1: OpToDeclType(JSOp op)
     1: {
     1:     switch (op) {
     1:       case JSOP_NOP:
     1:         return SRC_DECL_LET;
     1:       case JSOP_DEFCONST:
     1:         return SRC_DECL_CONST;
     1:       case JSOP_DEFVAR:
     1:         return SRC_DECL_VAR;
     1:       default:
     1:         return SRC_DECL_NONE;
     1:     }
     1: }
     1: 
 86078: /*
 86078:  * This utility accumulates a set of SRC_DESTRUCTLET notes which need to be
 86078:  * backpatched with the offset from JSOP_DUP to JSOP_LET0.
 86078:  *
 86078:  * Also record whether the let head was a group assignment ([x,y] = [a,b])
 86078:  * (which implies no SRC_DESTRUCTLET notes).
 86078:  */
 86078: class LetNotes
 86078: {
 86078:     struct Pair {
 86078:         ptrdiff_t dup;
 91237:         unsigned index;
 91237:         Pair(ptrdiff_t dup, unsigned index) : dup(dup), index(index) {}
 86078:     };
 86078:     Vector<Pair> notes;
 86078:     bool groupAssign;
 86078:     DebugOnly<bool> updateCalled;
 86078: 
 86078:   public:
 86078:     LetNotes(JSContext *cx) : notes(cx), groupAssign(false), updateCalled(false) {}
 86078: 
 86078:     ~LetNotes() {
 86078:         JS_ASSERT_IF(!notes.allocPolicy().context()->isExceptionPending(), updateCalled);
 86078:     }
 86078: 
 86078:     void setGroupAssign() {
 86078:         JS_ASSERT(notes.empty());
 86078:         groupAssign = true;
 86078:     }
 86078: 
 86078:     bool isGroupAssign() const {
 86078:         return groupAssign;
 86078:     }
 86078: 
 91237:     bool append(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t dup, unsigned index) {
 86078:         JS_ASSERT(!groupAssign);
 86078:         JS_ASSERT(SN_TYPE(bce->notes() + index) == SRC_DESTRUCTLET);
 86078:         if (!notes.append(Pair(dup, index)))
 86078:             return false;
 86078: 
 86078:         /*
 86078:          * Pessimistically inflate each srcnote. That way, there is no danger
 86078:          * of inflation during update() (which would invalidate all indices).
 86078:          */
 86078:         if (!SetSrcNoteOffset(cx, bce, index, 0, SN_MAX_OFFSET))
 86078:             return false;
 86078:         JS_ASSERT(bce->notes()[index + 1] & SN_3BYTE_OFFSET_FLAG);
 86078:         return true;
 86078:     }
 86078: 
 86078:     /* This should be called exactly once, right before JSOP_ENTERLET0. */
 86078:     bool update(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t offset) {
 86078:         JS_ASSERT(!updateCalled);
 86078:         for (size_t i = 0; i < notes.length(); ++i) {
 86078:             JS_ASSERT(offset > notes[i].dup);
 86078:             JS_ASSERT(*bce->code(notes[i].dup) == JSOP_DUP);
 86078:             JS_ASSERT(bce->notes()[notes[i].index + 1] & SN_3BYTE_OFFSET_FLAG);
 86078:             if (!SetSrcNoteOffset(cx, bce, notes[i].index, 0, offset - notes[i].dup))
 86078:                 return false;
 86078:         }
 86078:         updateCalled = true;
 86078:         return true;
 86078:     }
 86078: };
 86078: 
     1: static JSBool
 86078: EmitDestructuringOps(JSContext *cx, BytecodeEmitter *bce, ptrdiff_t declType, ParseNode *pn,
 86078:                      LetNotes *letNotes = NULL)
     1: {
     1:     /*
     1:      * If we're called from a variable declaration, help the decompiler by
     1:      * annotating the first JSOP_DUP that EmitDestructuringOpsHelper emits.
     1:      * If the destructuring initialiser is empty, our helper will emit a
     1:      * JSOP_DUP followed by a JSOP_POP for the decompiler.
     1:      */
 86078:     if (letNotes) {
 86078:         ptrdiff_t index = NewSrcNote2(cx, bce, SRC_DESTRUCTLET, 0);
 91237:         if (index < 0 || !letNotes->append(cx, bce, bce->offset(), (unsigned)index))
 86078:             return JS_FALSE;
 86078:     } else {
 86078:         if (NewSrcNote2(cx, bce, SRC_DESTRUCT, declType) < 0)
 86078:             return JS_FALSE;
 86078:     }
     1: 
     1:     /*
     1:      * Call our recursive helper to emit the destructuring assignments and
     1:      * related stack manipulations.
     1:      */
 86078:     VarEmitOption emitOption = letNotes ? PushInitialValues : InitializeVars;
 86078:     return EmitDestructuringOpsHelper(cx, bce, pn, emitOption);
     1: }
     1: 
     1: static JSBool
 80966: EmitGroupAssignment(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp,
 80631:                     ParseNode *lhs, ParseNode *rhs)
     1: {
 91612:     unsigned depth, limit, i, nslots;
 80631:     ParseNode *pn;
     1: 
 91237:     depth = limit = (unsigned) bce->stackDepth;
     1:     for (pn = rhs->pn_head; pn; pn = pn->pn_next) {
     1:         if (limit == JS_BIT(16)) {
 80966:             ReportCompileErrorNumber(cx, bce->tokenStream(), rhs, JSREPORT_ERROR,
 80966:                                      JSMSG_ARRAY_INIT_TOO_BIG);
     1:             return JS_FALSE;
     1:         }
     1: 
 28123:         /* MaybeEmitGroupAssignment won't call us if rhs is holey. */
 82024:         JS_ASSERT(!(pn->isKind(PNK_COMMA) && pn->isArity(PN_NULLARY)));
 80966:         if (!EmitTree(cx, bce, pn))
     1:             return JS_FALSE;
     1:         ++limit;
     1:     }
     1: 
 80966:     if (NewSrcNote2(cx, bce, SRC_GROUPASSIGN, OpToDeclType(prologOp)) < 0)
     1:         return JS_FALSE;
     1: 
 16072:     i = depth;
 16072:     for (pn = lhs->pn_head; pn; pn = pn->pn_next, ++i) {
 28123:         /* MaybeEmitGroupAssignment requires lhs->pn_count <= rhs->pn_count. */
 28123:         JS_ASSERT(i < limit);
 91450:         int slot = AdjustBlockSlot(cx, bce, i);
 16072:         if (slot < 0)
 16072:             return JS_FALSE;
 95101: 
 95101:         if (!EmitUnaliasedVarOp(cx, JSOP_GETLOCAL, slot, bce))
 95101:             return JS_FALSE;
 28123: 
 82024:         if (pn->isKind(PNK_COMMA) && pn->isArity(PN_NULLARY)) {
 80966:             if (Emit1(cx, bce, JSOP_POP) < 0)
     1:                 return JS_FALSE;
     1:         } else {
 86078:             if (!EmitDestructuringLHS(cx, bce, pn, InitializeVars))
     1:                 return JS_FALSE;
     1:         }
     1:     }
     1: 
  1227:     nslots = limit - depth;
  1227:     EMIT_UINT16_IMM_OP(JSOP_POPN, nslots);
 91237:     bce->stackDepth = (unsigned) depth;
     1:     return JS_TRUE;
     1: }
     1: 
 95099: enum GroupOption { GroupIsDecl, GroupIsNotDecl };
 95099: 
     1: /*
     1:  * Helper called with pop out param initialized to a JSOP_POP* opcode.  If we
     1:  * can emit a group assignment sequence, which results in 0 stack depth delta,
     1:  * we set *pop to JSOP_NOP so callers can veto emitting pn followed by a pop.
     1:  */
 95099: static bool
 80966: MaybeEmitGroupAssignment(JSContext *cx, BytecodeEmitter *bce, JSOp prologOp, ParseNode *pn,
 95099:                          GroupOption groupOption, JSOp *pop)
 80631: {
 82024:     JS_ASSERT(pn->isKind(PNK_ASSIGN));
 82023:     JS_ASSERT(pn->isOp(JSOP_NOP));
     1:     JS_ASSERT(*pop == JSOP_POP || *pop == JSOP_POPV);
 82023: 
 82023:     ParseNode *lhs = pn->pn_left;
 82023:     ParseNode *rhs = pn->pn_right;
 82024:     if (lhs->isKind(PNK_RB) && rhs->isKind(PNK_RB) &&
 28123:         !(rhs->pn_xflags & PNX_HOLEY) &&
 95099:         lhs->pn_count <= rhs->pn_count)
 95099:     {
 95099:         if (groupOption == GroupIsDecl && !EmitDestructuringDecls(cx, bce, prologOp, lhs))
 95099:             return false;
 80966:         if (!EmitGroupAssignment(cx, bce, prologOp, lhs, rhs))
 95099:             return false;
     1:         *pop = JSOP_NOP;
     1:     }
     1:     return JS_TRUE;
     1: }
     1: 
 86078: /*
 86078:  * Like MaybeEmitGroupAssignment, but for 'let ([x,y] = [a,b]) ...'.
 86078:  *
 86078:  * Instead of issuing a sequence |dup|eval-rhs|set-lhs|pop| (which doesn't work
 86078:  * since the bound vars don't yet have slots), just eval/push each rhs element
 86078:  * just like what EmitLet would do for 'let (x = a, y = b) ...'. While shorter,
 86078:  * simpler and more efficient than MaybeEmitGroupAssignment, it is harder to
 86078:  * decompile so we restrict the ourselves to cases where the lhs and rhs are in
 86078:  * 1:1 correspondence and lhs elements are simple names.
 86078:  */
 86078: static bool
 86078: MaybeEmitLetGroupDecl(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn,
 86078:                       LetNotes *letNotes, JSOp *pop)
 86078: {
 86078:     JS_ASSERT(pn->isKind(PNK_ASSIGN));
 86078:     JS_ASSERT(pn->isOp(JSOP_NOP));
 86078:     JS_ASSERT(*pop == JSOP_POP || *pop == JSOP_POPV);
 86078: 
 86078:     ParseNode *lhs = pn->pn_left;
 86078:     ParseNode *rhs = pn->pn_right;
 86078:     if (lhs->isKind(PNK_RB) && rhs->isKind(PNK_RB) &&
 86078:         !(rhs->pn_xflags & PNX_HOLEY) &&
 86078:         !(lhs->pn_xflags & PNX_HOLEY) &&
 86078:         lhs->pn_count == rhs->pn_count)
 86078:     {
 86078:         for (ParseNode *l = lhs->pn_head; l; l = l->pn_next) {
 86078:             if (l->getOp() != JSOP_SETLOCAL)
 86078:                 return true;
 86078:         }
 86078: 
 86078:         for (ParseNode *r = rhs->pn_head; r; r = r->pn_next) {
 86078:             if (!EmitTree(cx, bce, r))
 86078:                 return false;
 86078:         }
 86078: 
 86078:         letNotes->setGroupAssign();
 86078:         *pop = JSOP_NOP;
 86078:     }
 86078:     return true;
 86078: }
 86078: 
     1: #endif /* JS_HAS_DESTRUCTURING */
     1: 
     1: static JSBool
 86078: EmitVariables(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, VarEmitOption emitOption,
 86078:               LetNotes *letNotes = NULL)
 86078: {
 86078:     JS_ASSERT(pn->isArity(PN_LIST));
 86078:     JS_ASSERT(!!letNotes == (emitOption == PushInitialValues));
 86078: 
 86078:     ptrdiff_t off = -1, noteIndex = -1;
 86078:     ParseNode *next;
 86078:     for (ParseNode *pn2 = pn->pn_head; ; pn2 = next) {
 86078:         bool first = pn2 == pn->pn_head;
 27012:         next = pn2->pn_next;
 27012: 
 86078:         ParseNode *pn3;
 82024:         if (!pn2->isKind(PNK_NAME)) {
 26970: #if JS_HAS_DESTRUCTURING
 82024:             if (pn2->isKind(PNK_RB) || pn2->isKind(PNK_RC)) {
     1:                 /*
 80634:                  * Emit variable binding ops, but not destructuring ops.  The
 80634:                  * parser (see Parser::variables) has ensured that our caller
 82871:                  * will be the PNK_FOR/PNK_FORIN case in EmitTree, and that
 82871:                  * case will emit the destructuring code only after emitting an
 80634:                  * enumerating opcode and a branch that tests whether the
 80634:                  * enumeration ended.
     1:                  */
 86078:                 JS_ASSERT(emitOption == DefineVars);
     1:                 JS_ASSERT(pn->pn_count == 1);
 80966:                 if (!EmitDestructuringDecls(cx, bce, pn->getOp(), pn2))
     1:                     return JS_FALSE;
     1:                 break;
     1:             }
 27012: #endif
     1: 
     1:             /*
 20413:              * A destructuring initialiser assignment preceded by var will
 20413:              * never occur to the left of 'in' in a for-in loop.  As with 'for
 20413:              * (var x = i in o)...', this will cause the entire 'var [a, b] =
 20413:              * i' to be hoisted out of the loop.
     1:              */
 82024:             JS_ASSERT(pn2->isKind(PNK_ASSIGN));
 82023:             JS_ASSERT(pn2->isOp(JSOP_NOP));
 86078:             JS_ASSERT(emitOption != DefineVars);
 27012: 
 27012:             /*
 27012:              * To allow the front end to rewrite var f = x; as f = x; when a
 27012:              * function f(){} precedes the var, detect simple name assignment
 27012:              * here and initialize the name.
 27012:              */
 27012: #if !JS_HAS_DESTRUCTURING
 82024:             JS_ASSERT(pn2->pn_left->isKind(PNK_NAME));
 27012: #else
 82024:             if (pn2->pn_left->isKind(PNK_NAME))
 27012: #endif
 27012:             {
 27012:                 pn3 = pn2->pn_right;
 27012:                 pn2 = pn2->pn_left;
 27012:                 goto do_name;
 27012:             }
 27012: 
 27012: #if JS_HAS_DESTRUCTURING
 86078:             ptrdiff_t stackDepthBefore = bce->stackDepth;
 86078:             JSOp op = JSOP_POP;
 20413:             if (pn->pn_count == 1) {
     1:                 /*
     1:                  * If this is the only destructuring assignment in the list,
     1:                  * try to optimize to a group assignment.  If we're in a let
     1:                  * head, pass JSOP_POP rather than the pseudo-prolog JSOP_NOP
     1:                  * in pn->pn_op, to suppress a second (and misplaced) 'let'.
     1:                  */
     1:                 JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
 86078:                 if (letNotes) {
 86078:                     if (!MaybeEmitLetGroupDecl(cx, bce, pn2, letNotes, &op))
 86078:                         return JS_FALSE;
 86078:                 } else {
 95099:                     if (!MaybeEmitGroupAssignment(cx, bce, pn->getOp(), pn2, GroupIsDecl, &op))
 86078:                         return JS_FALSE;
 86078:                 }
     1:             }
     1:             if (op == JSOP_NOP) {
 27012:                 pn->pn_xflags = (pn->pn_xflags & ~PNX_POPVAR) | PNX_GROUPINIT;
 86078:             } else {
     1:                 pn3 = pn2->pn_left;
 80966:                 if (!EmitDestructuringDecls(cx, bce, pn->getOp(), pn3))
 80966:                     return JS_FALSE;
 80966: 
 80966:                 if (!EmitTree(cx, bce, pn2->pn_right))
     1:                     return JS_FALSE;
     1: 
 86078:                 /* Only the first list element should print 'let' or 'var'. */
 86078:                 ptrdiff_t declType = pn2 == pn->pn_head
 86078:                                      ? OpToDeclType(pn->getOp())
 86078:                                      : SRC_DECL_NONE;
 86078: 
 86078:                 if (!EmitDestructuringOps(cx, bce, declType, pn3, letNotes))
 86078:                     return JS_FALSE;
 86078:             }
 86078:             ptrdiff_t stackDepthAfter = bce->stackDepth;
 86078: 
 86078:             /* Give let ([] = x) a slot (see CheckDestructuring). */
 86078:             JS_ASSERT(stackDepthBefore <= stackDepthAfter);
 86078:             if (letNotes && stackDepthBefore == stackDepthAfter) {
 86078:                 if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 86078:                     return JS_FALSE;
 86078:             }
 86078: 
 86078:             /* If we are not initializing, nothing to pop. */
 86078:             if (emitOption != InitializeVars) {
 86078:                 if (next)
 86078:                     continue;
 86078:                 break;
     1:             }
     1:             goto emit_note_pop;
     1: #endif
 27012:         }
 27012: 
 27012:         /*
 27012:          * Load initializer early to share code above that jumps to do_name.
 27012:          * NB: if this var redeclares an existing binding, then pn2 is linked
 27012:          * on its definition's use-chain and pn_expr has been overlayed with
 27012:          * pn_lexdef.
 27012:          */
 27012:         pn3 = pn2->maybeExpr();
 27012: 
 27012:      do_name:
 80966:         if (!BindNameToSlot(cx, bce, pn2))
     1:             return JS_FALSE;
     1: 
 95100: 
 86078:         JSOp op;
 78294:         op = pn2->getOp();
 27012:         JS_ASSERT(op != JSOP_CALLEE);
 86078:         JS_ASSERT(!pn2->pn_cookie.isFree() || !pn->isOp(JSOP_NOP));
 95100: 
 95100:         jsatomid atomIndex;
 80966:         if (!MaybeEmitVarDecl(cx, bce, pn->getOp(), pn2, &atomIndex))
     1:             return JS_FALSE;
     1: 
     1:         if (pn3) {
 86078:             JS_ASSERT(emitOption != DefineVars);
 86078:             JS_ASSERT_IF(emitOption == PushInitialValues, op == JSOP_SETLOCAL);
 90965:             if (op == JSOP_SETNAME || op == JSOP_SETGNAME) {
 90965:                 JSOp bindOp = (op == JSOP_SETNAME) ? JSOP_BINDNAME : JSOP_BINDGNAME;
 90965:                 if (!EmitIndex32(cx, bindOp, atomIndex, bce))
 90965:                     return false;
 90965:             }
 78294:             if (pn->isOp(JSOP_DEFCONST) &&
 80966:                 !DefineCompileTimeConstant(cx, bce, pn2->pn_atom, pn3))
 80966:             {
 80966:                 return JS_FALSE;
 80966:             }
 80966: 
 98477:             bool oldInForInit = bce->sc->inForInit;
 98477:             bce->sc->inForInit = false;
 80966:             if (!EmitTree(cx, bce, pn3))
 80966:                 return JS_FALSE;
 98477:             bce->sc->inForInit = oldInForInit;
 86078:         } else if (letNotes) {
 86078:             /* JSOP_ENTERLETx expects at least 1 slot to have been pushed. */
 86078:             if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 86078:                 return JS_FALSE;
 86078:         }
 86078: 
 86078:         /* If we are not initializing, nothing to pop. */
 86078:         if (emitOption != InitializeVars) {
 86078:             if (next)
 86078:                 continue;
 86078:             break;
 86078:         }
 86078: 
 78294:         JS_ASSERT_IF(pn2->isDefn(), pn3 == pn2->pn_expr);
 86078:         if (first && NewSrcNote2(cx, bce, SRC_DECL,
 78294:                                  (pn->isOp(JSOP_DEFCONST))
     1:                                  ? SRC_DECL_CONST
 78294:                                  : (pn->isOp(JSOP_DEFVAR))
     1:                                  ? SRC_DECL_VAR
 86078:                                  : SRC_DECL_LET) < 0) {
     1:             return JS_FALSE;
     1:         }
 95100:         if (!pn2->pn_cookie.isFree()) {
 95101:             if (!EmitVarOp(cx, pn2, op, bce))
 95101:                 return false;
     1:         } else {
 90965:             if (!EmitIndexOp(cx, op, atomIndex, bce))
 90965:                 return false;
     1:         }
     1: 
     1: #if JS_HAS_DESTRUCTURING
     1:     emit_note_pop:
     1: #endif
 86078:         ptrdiff_t tmp = bce->offset();
     1:         if (noteIndex >= 0) {
 91237:             if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, tmp-off))
     1:                 return JS_FALSE;
     1:         }
 27012:         if (!next)
     1:             break;
     1:         off = tmp;
 80966:         noteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
 80966:         if (noteIndex < 0 || Emit1(cx, bce, JSOP_POP) < 0)
     1:             return JS_FALSE;
     1:     }
     1: 
 86078:     if (pn->pn_xflags & PNX_POPVAR) {
 86078:         if (Emit1(cx, bce, JSOP_POP) < 0)
 86078:             return JS_FALSE;
 86078:     }
 86078: 
 86078:     return JS_TRUE;
 27012: }
 27012: 
 74052: static bool
 80966: EmitAssignment(JSContext *cx, BytecodeEmitter *bce, ParseNode *lhs, JSOp op, ParseNode *rhs)
 80966: {
 80966:     ptrdiff_t top = bce->offset();
 74052: 
 74052:     /*
 74052:      * Check left operand type and generate specialized code for it.
 74052:      * Specialize to avoid ECMA "reference type" values on the operand
 74052:      * stack, which impose pervasive runtime "GetValue" costs.
 74052:      */
 74052:     jsatomid atomIndex = (jsatomid) -1;              /* quell GCC overwarning */
 74052:     jsbytecode offset = 1;
 74052: 
 78294:     switch (lhs->getKind()) {
 82024:       case PNK_NAME:
 80966:         if (!BindNameToSlot(cx, bce, lhs))
 74052:             return false;
 74052:         if (!lhs->pn_cookie.isFree()) {
 91456:             JS_ASSERT(lhs->pn_cookie.level() == 0);
 91456:             atomIndex = lhs->pn_cookie.slot();
 74052:         } else {
 80966:             if (!bce->makeAtomIndex(lhs->pn_atom, &atomIndex))
 74052:                 return false;
 74052:             if (!lhs->isConst()) {
 78294:                 JSOp op = lhs->isOp(JSOP_SETGNAME) ? JSOP_BINDGNAME : JSOP_BINDNAME;
 90965:                 if (!EmitIndex32(cx, op, atomIndex, bce))
 90965:                     return false;
 74052:                 offset++;
 74052:             }
 74052:         }
 74052:         break;
 82024:       case PNK_DOT:
 80966:         if (!EmitTree(cx, bce, lhs->expr()))
 74052:             return false;
 74052:         offset++;
 80966:         if (!bce->makeAtomIndex(lhs->pn_atom, &atomIndex))
 74052:             return false;
 74052:         break;
 82024:       case PNK_LB:
 78294:         JS_ASSERT(lhs->isArity(PN_BINARY));
 80966:         if (!EmitTree(cx, bce, lhs->pn_left))
 80966:             return false;
 80966:         if (!EmitTree(cx, bce, lhs->pn_right))
 74052:             return false;
 74052:         offset += 2;
 74052:         break;
 74052: #if JS_HAS_DESTRUCTURING
 82024:       case PNK_RB:
 82024:       case PNK_RC:
 74052:         break;
 74052: #endif
 82024:       case PNK_LP:
 80966:         if (!EmitTree(cx, bce, lhs))
 74052:             return false;
 77824:         offset++;
 74052:         break;
 74052: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 78294:         JS_ASSERT(lhs->isOp(JSOP_SETXMLNAME));
 80966:         if (!EmitTree(cx, bce, lhs->pn_kid))
 80966:             return false;
 80966:         if (Emit1(cx, bce, JSOP_BINDXMLNAME) < 0)
 74052:             return false;
 74052:         offset++;
 74052:         break;
 74052: #endif
 74052:       default:
 74052:         JS_ASSERT(0);
 74052:     }
 74052: 
 74052:     if (op != JSOP_NOP) {
 74052:         JS_ASSERT(rhs);
 78294:         switch (lhs->getKind()) {
 82024:           case PNK_NAME:
 74052:             if (lhs->isConst()) {
 78294:                 if (lhs->isOp(JSOP_CALLEE)) {
 80966:                     if (Emit1(cx, bce, JSOP_CALLEE) < 0)
 74052:                         return false;
 91140:                 } else if (lhs->isOp(JSOP_NAME) || lhs->isOp(JSOP_GETGNAME)) {
 90965:                     if (!EmitIndex32(cx, lhs->getOp(), atomIndex, bce))
 90965:                         return false;
 74052:                 } else {
 90965:                     JS_ASSERT(JOF_OPTYPE(lhs->getOp()) != JOF_ATOM);
 95101:                     if (!EmitVarOp(cx, lhs, lhs->getOp(), bce))
 95101:                         return false;
 78294:                 }
 78294:             } else if (lhs->isOp(JSOP_SETNAME)) {
 80966:                 if (Emit1(cx, bce, JSOP_DUP) < 0)
 74052:                     return false;
 90965:                 if (!EmitIndex32(cx, JSOP_GETXPROP, atomIndex, bce))
 90965:                     return false;
 78294:             } else if (lhs->isOp(JSOP_SETGNAME)) {
 98173:                 JS_ASSERT(lhs->pn_cookie.isFree());
 90965:                 if (!EmitAtomOp(cx, lhs, JSOP_GETGNAME, bce))
 90965:                     return false;
 74052:             } else {
 95101:                 JSOp op = lhs->isOp(JSOP_SETARG) ? JSOP_GETARG : JSOP_GETLOCAL;
 95101:                 if (!EmitVarOp(cx, lhs, op, bce))
 95101:                     return false;
 74052:             }
 74052:             break;
 87822:           case PNK_DOT:
 80966:             if (Emit1(cx, bce, JSOP_DUP) < 0)
 74052:                 return false;
 87822:             if (lhs->pn_atom == cx->runtime->atomState.protoAtom) {
 90965:                 if (!EmitIndex32(cx, JSOP_QNAMEPART, atomIndex, bce))
 87822:                     return false;
 87822:                 if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))
 87822:                     return false;
 87822:             } else {
 77379:                 bool isLength = (lhs->pn_atom == cx->runtime->atomState.lengthAtom);
 90965:                 if (!EmitIndex32(cx, isLength ? JSOP_LENGTH : JSOP_GETPROP, atomIndex, bce))
 90965:                     return false;
 87822:             }
 74052:             break;
 82024:           case PNK_LB:
 82024:           case PNK_LP:
 74052: #if JS_HAS_XML_SUPPORT
 82114:           case PNK_XMLUNARY:
 74052: #endif
 80966:             if (Emit1(cx, bce, JSOP_DUP2) < 0)
 80966:                 return false;
 80966:             if (!EmitElemOpBase(cx, bce, JSOP_GETELEM))
 74052:                 return false;
 74052:             break;
 74052:           default:;
 74052:         }
 74052:     }
 74052: 
 74052:     /* Now emit the right operand (it may affect the namespace). */
 74052:     if (rhs) {
 80966:         if (!EmitTree(cx, bce, rhs))
 74052:             return false;
 74052:     } else {
 77824:         /* The value to assign is the next enumeration value in a for-in loop. */
 80966:         if (Emit2(cx, bce, JSOP_ITERNEXT, offset) < 0)
 74052:             return false;
 74052:     }
 74052: 
 74052:     /* If += etc., emit the binary operator with a decompiler note. */
 74052:     if (op != JSOP_NOP) {
 74052:         /*
 74052:          * Take care to avoid SRC_ASSIGNOP if the left-hand side is a const
 74052:          * declared in the current compilation unit, as in this case (just
 74052:          * a bit further below) we will avoid emitting the assignment op.
 74052:          */
 82024:         if (!lhs->isKind(PNK_NAME) || !lhs->isConst()) {
 80966:             if (NewSrcNote(cx, bce, SRC_ASSIGNOP) < 0)
 80966:                 return false;
 80966:         }
 80966:         if (Emit1(cx, bce, op) < 0)
 74052:             return false;
 74052:     }
 74052: 
 74052:     /* Left parts such as a.b.c and a[b].c need a decompiler note. */
 82024:     if (!lhs->isKind(PNK_NAME) &&
 74052: #if JS_HAS_DESTRUCTURING
 82024:         !lhs->isKind(PNK_RB) &&
 82024:         !lhs->isKind(PNK_RC) &&
 74052: #endif
 80966:         NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - top) < 0)
 80632:     {
 74052:         return false;
 74052:     }
 74052: 
 74052:     /* Finally, emit the specialized assignment bytecode. */
 78294:     switch (lhs->getKind()) {
 82024:       case PNK_NAME:
 74052:         if (lhs->isConst()) {
 74052:             if (!rhs) {
 80966:                 ReportCompileErrorNumber(cx, bce->tokenStream(), lhs, JSREPORT_ERROR,
 74052:                                          JSMSG_BAD_FOR_LEFTSIDE);
 74052:                 return false;
 74052:             }
 74052:             break;
 74052:         }
 90965:         if (lhs->isOp(JSOP_SETARG) || lhs->isOp(JSOP_SETLOCAL)) {
 95101:             if (!EmitVarOp(cx, lhs, lhs->getOp(), bce))
 95101:                 return false;
 90965:         } else {
 90965:             if (!EmitIndexOp(cx, lhs->getOp(), atomIndex, bce))
 90965:                 return false;
 90965:         }
 90965:         break;
 82024:       case PNK_DOT:
 90965:         if (!EmitIndexOp(cx, lhs->getOp(), atomIndex, bce))
 90965:             return false;
 74052:         break;
 82024:       case PNK_LB:
 82024:       case PNK_LP:
 80966:         if (Emit1(cx, bce, JSOP_SETELEM) < 0)
 74052:             return false;
 74052:         break;
 74052: #if JS_HAS_DESTRUCTURING
 82024:       case PNK_RB:
 82024:       case PNK_RC:
 86078:         if (!EmitDestructuringOps(cx, bce, SRC_DECL_NONE, lhs))
 74052:             return false;
 74052:         break;
 74052: #endif
 74052: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 80966:         if (Emit1(cx, bce, JSOP_SETXMLNAME) < 0)
 74052:             return false;
 74052:         break;
 74052: #endif
 74052:       default:
 74052:         JS_ASSERT(0);
 74052:     }
 74052:     return true;
 74052: }
 74052: 
 86078: #ifdef DEBUG
     1: static JSBool
 80966: GettableNoteForNextOp(BytecodeEmitter *bce)
     1: {
     1:     ptrdiff_t offset, target;
     1:     jssrcnote *sn, *end;
     1: 
     1:     offset = 0;
 80966:     target = bce->offset();
 80966:     for (sn = bce->notes(), end = sn + bce->noteCount(); sn < end;
     1:          sn = SN_NEXT(sn)) {
     1:         if (offset == target && SN_IS_GETTABLE(sn))
     1:             return JS_TRUE;
     1:         offset += SN_DELTA(sn);
     1:     }
     1:     return JS_FALSE;
     1: }
     1: #endif
     1: 
 10466: /* Top-level named functions need a nop for decompilation. */
 10466: static JSBool
 91237: EmitFunctionDefNop(JSContext *cx, BytecodeEmitter *bce, unsigned index)
 80966: {
 80966:     return NewSrcNote2(cx, bce, SRC_FUNCDEF, (ptrdiff_t)index) >= 0 &&
 80966:            Emit1(cx, bce, JSOP_NOP) >= 0;
 10466: }
 10466: 
 32729: static bool
 88137: EmitNewInit(JSContext *cx, BytecodeEmitter *bce, JSProtoKey key, ParseNode *pn)
 80966: {
 89253:     const size_t len = 1 + UINT32_INDEX_LEN;
 89253:     ptrdiff_t offset = EmitCheck(cx, bce, len);
 89253:     if (offset < 0)
 89253:         return false;
 89253: 
 89253:     jsbytecode *next = bce->next();
 89253:     next[0] = JSOP_NEWINIT;
 89253:     next[1] = jsbytecode(key);
 89253:     next[2] = 0;
 89253:     next[3] = 0;
 89253:     next[4] = 0;
 89253:     bce->current->next = next + len;
 89253:     UpdateDepth(cx, bce, offset);
 86704:     CheckTypeSet(cx, bce, JSOP_NEWINIT);
 32729:     return true;
 32729: }
 32729: 
 59962: bool
 80631: ParseNode::getConstantValue(JSContext *cx, bool strictChecks, Value *vp)
 59962: {
 78294:     switch (getKind()) {
 82024:       case PNK_NUMBER:
 59962:         vp->setNumber(pn_dval);
 59962:         return true;
 82024:       case PNK_STRING:
 64345:         vp->setString(pn_atom);
 59962:         return true;
 82024:       case PNK_TRUE:
 82022:         vp->setBoolean(true);
 82022:         return true;
 82024:       case PNK_FALSE:
 82022:         vp->setBoolean(false);
 82022:         return true;
 82024:       case PNK_NULL:
 59962:         vp->setNull();
 59962:         return true;
 82024:       case PNK_RB: {
 78294:         JS_ASSERT(isOp(JSOP_NEWINIT) && !(pn_xflags & PNX_NONCONST));
 59962: 
 99421:         RootedObject obj(cx, NewDenseAllocatedArray(cx, pn_count));
 77343:         if (!obj)
 59962:             return false;
 59962: 
 59962:         unsigned idx = 0;
 99421:         RootedId id(cx);
 80631:         for (ParseNode *pn = pn_head; pn; idx++, pn = pn->pn_next) {
 59962:             Value value;
 59962:             if (!pn->getConstantValue(cx, strictChecks, &value))
 59962:                 return false;
 98960:             id = INT_TO_JSID(idx);
 98960:             if (!obj->defineGeneric(cx, id, value, NULL, NULL, JSPROP_ENUMERATE))
 77343:                 return false;
 59962:         }
 59962:         JS_ASSERT(idx == pn_count);
 59962: 
 77343:         types::FixArrayType(cx, obj);
 59962:         vp->setObject(*obj);
 59962:         return true;
 59962:       }
 82024:       case PNK_RC: {
 78294:         JS_ASSERT(isOp(JSOP_NEWINIT) && !(pn_xflags & PNX_NONCONST));
 59962: 
 83231:         gc::AllocKind kind = GuessObjectGCKind(pn_count);
 99421:         RootedObject obj(cx, NewBuiltinClassInstance(cx, &ObjectClass, kind));
 59962:         if (!obj)
 59962:             return false;
 59962: 
 80631:         for (ParseNode *pn = pn_head; pn; pn = pn->pn_next) {
 59962:             Value value;
 59962:             if (!pn->pn_right->getConstantValue(cx, strictChecks, &value))
 59962:                 return false;
 59962: 
 80631:             ParseNode *pnid = pn->pn_left;
 82024:             if (pnid->isKind(PNK_NUMBER)) {
 59962:                 Value idvalue = NumberValue(pnid->pn_dval);
 99421:                 RootedId id(cx);
 59962:                 if (idvalue.isInt32() && INT_FITS_IN_JSID(idvalue.toInt32()))
 59962:                     id = INT_TO_JSID(idvalue.toInt32());
 98960:                 else if (!InternNonIntElementId(cx, obj, idvalue, id.address()))
 59962:                     return false;
 80624:                 if (!obj->defineGeneric(cx, id, value, NULL, NULL, JSPROP_ENUMERATE))
 59962:                     return false;
 59962:             } else {
 82024:                 JS_ASSERT(pnid->isKind(PNK_NAME) || pnid->isKind(PNK_STRING));
 77448:                 JS_ASSERT(pnid->pn_atom != cx->runtime->atomState.protoAtom);
 99421:                 RootedId id(cx, AtomToId(pnid->pn_atom));
 77448:                 if (!DefineNativeProperty(cx, obj, id, value, NULL, NULL,
 69855:                                           JSPROP_ENUMERATE, 0, 0)) {
 59962:                     return false;
 59962:                 }
 59962:             }
 59962:         }
 59962: 
 77343:         types::FixObjectType(cx, obj);
 59962:         vp->setObject(*obj);
 59962:         return true;
 59962:       }
 59962:       default:
 59962:         JS_NOT_REACHED("Unexpected node");
 59962:     }
 59962:     return false;
 59962: }
 59962: 
 59962: static bool
 80966: EmitSingletonInitialiser(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 59962: {
 59962:     Value value;
 98445:     if (!pn->getConstantValue(cx, bce->sc->needStrictChecks(), &value))
 59962:         return false;
 59962: 
 59962:     JS_ASSERT(value.isObject());
 80966:     ObjectBox *objbox = bce->parser->newObjectBox(&value.toObject());
 59962:     if (!objbox)
 59962:         return false;
 59962: 
 80966:     return EmitObjectOp(cx, objbox, JSOP_OBJECT, bce);
 59962: }
 59962: 
 21520: /* See the SRC_FOR source note offsetBias comments later in this file. */
 21520: JS_STATIC_ASSERT(JSOP_NOP_LENGTH == 1);
 21520: JS_STATIC_ASSERT(JSOP_POP_LENGTH == 1);
 21520: 
 55512: class EmitLevelManager
 55512: {
 80966:     BytecodeEmitter *bce;
 55512:   public:
 80966:     EmitLevelManager(BytecodeEmitter *bce) : bce(bce) { bce->emitLevel++; }
 80966:     ~EmitLevelManager() { bce->emitLevel--; }
 55512: };
 55512: 
 79378: static bool
 80966: EmitCatch(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 79378: {
 79378:     ptrdiff_t catchStart, guardJump;
 79378: 
 79378:     /*
 79378:      * Morph STMT_BLOCK to STMT_CATCH, note the block entry code offset,
 79378:      * and save the block object atom.
 79378:      */
 98445:     StmtInfo *stmt = bce->sc->topStmt;
 79378:     JS_ASSERT(stmt->type == STMT_BLOCK && (stmt->flags & SIF_SCOPE));
 79378:     stmt->type = STMT_CATCH;
 79378:     catchStart = stmt->update;
 79378: 
 79378:     /* Go up one statement info record to the TRY or FINALLY record. */
 79378:     stmt = stmt->down;
 79378:     JS_ASSERT(stmt->type == STMT_TRY || stmt->type == STMT_FINALLY);
 79378: 
 79378:     /* Pick up the pending exception and bind it to the catch variable. */
 80966:     if (Emit1(cx, bce, JSOP_EXCEPTION) < 0)
 79378:         return false;
 79378: 
 79378:     /*
 79378:      * Dup the exception object if there is a guard for rethrowing to use
 79378:      * it later when rethrowing or in other catches.
 79378:      */
 80966:     if (pn->pn_kid2 && Emit1(cx, bce, JSOP_DUP) < 0)
 79378:         return false;
 79378: 
 80631:     ParseNode *pn2 = pn->pn_kid1;
 79378:     switch (pn2->getKind()) {
 79378: #if JS_HAS_DESTRUCTURING
 82024:       case PNK_RB:
 82024:       case PNK_RC:
 86078:         if (!EmitDestructuringOps(cx, bce, SRC_DECL_NONE, pn2))
 80966:             return false;
 80966:         if (Emit1(cx, bce, JSOP_POP) < 0)
 79378:             return false;
 79378:         break;
 26959: #endif
 11139: 
 82024:       case PNK_NAME:
 79378:         /* Inline and specialize BindNameToSlot for pn2. */
 79378:         JS_ASSERT(!pn2->pn_cookie.isFree());
 95101:         if (!EmitVarOp(cx, pn2, JSOP_SETLOCAL, bce))
 95101:             return false;
 94278:         if (Emit1(cx, bce, JSOP_POP) < 0)
 94278:             return false;
 79378:         break;
 79378: 
 79378:       default:
 79378:         JS_ASSERT(0);
 79378:     }
 79378: 
 79378:     /* Emit the guard expression, if there is one. */
 79378:     if (pn->pn_kid2) {
 80966:         if (!EmitTree(cx, bce, pn->pn_kid2))
 80966:             return false;
 80966:         if (!SetSrcNoteOffset(cx, bce, CATCHNOTE(*stmt), 0, bce->offset() - catchStart))
 80632:             return false;
 79378:         /* ifeq <next block> */
 80966:         guardJump = EmitJump(cx, bce, JSOP_IFEQ, 0);
 79378:         if (guardJump < 0)
 79378:             return false;
 79378:         GUARDJUMP(*stmt) = guardJump;
 79378: 
 79378:         /* Pop duplicated exception object as we no longer need it. */
 80966:         if (Emit1(cx, bce, JSOP_POP) < 0)
 74052:             return false;
 79378:     }
 79378: 
 79378:     /* Emit the catch body. */
 80966:     if (!EmitTree(cx, bce, pn->pn_kid3))
 79378:         return false;
 79378: 
 79378:     /*
 79378:      * Annotate the JSOP_LEAVEBLOCK that will be emitted as we unwind via
 82024:      * our PNK_LEXICALSCOPE parent, so the decompiler knows to pop.
 79378:      */
 80966:     ptrdiff_t off = bce->stackDepth;
 80966:     if (NewSrcNote2(cx, bce, SRC_CATCH, off) < 0)
 79378:         return false;
 79378:     return true;
 79378: }
 79378: 
 91711: /*
 91711:  * Using MOZ_NEVER_INLINE in here is a workaround for llvm.org/pr12127. See
 91711:  * the comment on EmitSwitch.
 91711:  */
 91711: MOZ_NEVER_INLINE static bool
 80966: EmitTry(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 80631: {
 95355:     StmtInfo stmtInfo(cx);
 79378:     ptrdiff_t catchJump = -1;
     1: 
     1:     /*
     1:      * Push stmtInfo to track jumps-over-catches and gosubs-to-finally
     1:      * for later fixup.
     1:      *
 27012:      * When a finally block is active (STMT_FINALLY in our tree context),
     1:      * non-local jumps (including jumps-over-catches) result in a GOSUB
     1:      * being written into the bytecode stream and fixed-up later (c.f.
     1:      * EmitBackPatchOp and BackPatch).
     1:      */
 98445:     PushStatement(bce->sc, &stmtInfo, pn->pn_kid3 ? STMT_FINALLY : STMT_TRY, bce->offset());
     1: 
     1:     /*
  1825:      * Since an exception can be thrown at any place inside the try block,
  1825:      * we need to restore the stack and the scope chain before we transfer
  1825:      * the control to the exception handler.
     1:      *
  1825:      * For that we store in a try note associated with the catch or
  1825:      * finally block the stack depth upon the try entry. The interpreter
  1825:      * uses this depth to properly unwind the stack and the scope chain.
     1:      */
 91237:     int depth = bce->stackDepth;
     1: 
     1:     /* Mark try location for decompilation, then emit try block. */
 80966:     if (Emit1(cx, bce, JSOP_TRY) < 0)
 80966:         return false;
 80966:     ptrdiff_t tryStart = bce->offset();
 80966:     if (!EmitTree(cx, bce, pn->pn_kid1))
 80966:         return false;
 80966:     JS_ASSERT(depth == bce->stackDepth);
     1: 
     1:     /* GOSUB to finally, if present. */
     1:     if (pn->pn_kid3) {
 80966:         if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:             return false;
 80966:         if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &GOSUBS(stmtInfo)) < 0)
 79378:             return false;
     1:     }
     1: 
     1:     /* Emit (hidden) jump over catch and/or finally. */
 80966:     if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:         return false;
 80966:     if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &catchJump) < 0)
 80966:         return false;
 80966: 
 80966:     ptrdiff_t tryEnd = bce->offset();
     1: 
     1:     /* If this try has a catch block, emit it. */
 80631:     ParseNode *lastCatch = NULL;
 80631:     if (ParseNode *pn2 = pn->pn_kid2) {
 91237:         unsigned count = 0;    /* previous catch block's population */
     1: 
     1:         /*
     1:          * The emitted code for a catch block looks like:
     1:          *
     1:          * [throwing]                          only if 2nd+ catch block
     1:          * [leaveblock]                        only if 2nd+ catch block
     1:          * enterblock                          with SRC_CATCH
     1:          * exception
     1:          * [dup]                               only if catchguard
     1:          * setlocalpop <slot>                  or destructuring code
     1:          * [< catchguard code >]               if there's a catchguard
     1:          * [ifeq <offset to next catch block>]         " "
     1:          * [pop]                               only if catchguard
     1:          * < catch block contents >
     1:          * leaveblock
     1:          * goto <end of catch blocks>          non-local; finally applies
     1:          *
     1:          * If there's no catch block without a catchguard, the last
     1:          * <offset to next catch block> points to rethrow code.  This
     1:          * code will [gosub] to the finally code if appropriate, and is
     1:          * also used for the catch-all trynote for capturing exceptions
     1:          * thrown from catch{} blocks.
     1:          */
 80631:         for (ParseNode *pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
     1:             ptrdiff_t guardJump, catchNote;
     1: 
 80966:             JS_ASSERT(bce->stackDepth == depth);
     1:             guardJump = GUARDJUMP(stmtInfo);
  1825:             if (guardJump != -1) {
     1:                 /* Fix up and clean up previous catch block. */
 86877:                 SetJumpOffsetAt(bce, guardJump);
     1: 
     1:                 /*
 18567:                  * Account for JSOP_ENTERBLOCK (whose block object count
 18567:                  * is saved below) and pushed exception object that we
 18567:                  * still have after the jumping from the previous guard.
 18567:                  */
 80966:                 bce->stackDepth = depth + count + 1;
     1: 
     1:                 /*
     1:                  * Move exception back to cx->exception to prepare for
   190:                  * the next catch. We hide [throwing] from the decompiler
   190:                  * since it compensates for the hidden JSOP_DUP at the
   190:                  * start of the previous guarded catch.
   190:                  */
 80966:                 if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0 ||
 80966:                     Emit1(cx, bce, JSOP_THROWING) < 0) {
 80966:                     return false;
 80966:                 }
 80966:                 if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:                     return false;
 86077:                 EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, count);
 80966:                 JS_ASSERT(bce->stackDepth == depth);
     1:             }
     1: 
     1:             /*
     1:              * Annotate the JSOP_ENTERBLOCK that's about to be generated
 80632:              * by the call to EmitTree immediately below.  Save this
 82024:              * source note's index in stmtInfo for use by the PNK_CATCH:
     1:              * case, where the length of the catch guard is set as the
     1:              * note's offset.
     1:              */
 80966:             catchNote = NewSrcNote2(cx, bce, SRC_CATCH, 0);
     1:             if (catchNote < 0)
 79378:                 return false;
     1:             CATCHNOTE(stmtInfo) = catchNote;
     1: 
     1:             /*
     1:              * Emit the lexical scope and catch body.  Save the catch's
     1:              * block object population via count, for use when targeting
     1:              * guardJump at the next catch (the guard mismatch case).
     1:              */
 82024:             JS_ASSERT(pn3->isKind(PNK_LEXICALSCOPE));
 86483:             count = pn3->pn_objbox->object->asStaticBlock().slotCount();
 80966:             if (!EmitTree(cx, bce, pn3))
 79378:                 return false;
     1: 
     1:             /* gosub <finally>, if required */
     1:             if (pn->pn_kid3) {
 80966:                 if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &GOSUBS(stmtInfo)) < 0)
 80966:                     return false;
 80966:                 JS_ASSERT(bce->stackDepth == depth);
     1:             }
     1: 
     1:             /*
     1:              * Jump over the remaining catch blocks.  This will get fixed
     1:              * up to jump to after catch/finally.
     1:              */
 80966:             if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 80966:                 return false;
 80966:             if (EmitBackPatchOp(cx, bce, JSOP_BACKPATCH, &catchJump) < 0)
 79378:                 return false;
     1: 
     1:             /*
     1:              * Save a pointer to the last catch node to handle try-finally
     1:              * and try-catch(guard)-finally special cases.
     1:              */
 27012:             lastCatch = pn3->expr();
     1:         }
     1:     }
     1: 
     1:     /*
     1:      * Last catch guard jumps to the rethrow code sequence if none of the
     1:      * guards match. Target guardJump at the beginning of the rethrow
     1:      * sequence, just in case a guard expression throws and leaves the
     1:      * stack unbalanced.
     1:      */
     1:     if (lastCatch && lastCatch->pn_kid2) {
 86877:         SetJumpOffsetAt(bce, GUARDJUMP(stmtInfo));
     1: 
     1:         /* Sync the stack to take into account pushed exception. */
 80966:         JS_ASSERT(bce->stackDepth == depth);
 80966:         bce->stackDepth = depth + 1;
     1: 
     1:         /*
     1:          * Rethrow the exception, delegating executing of finally if any
     1:          * to the exception handler.
     1:          */
 80966:         if (NewSrcNote(cx, bce, SRC_HIDDEN) < 0 || Emit1(cx, bce, JSOP_THROW) < 0)
 80966:             return false;
 80966:     }
 80966: 
 80966:     JS_ASSERT(bce->stackDepth == depth);
     1: 
     1:     /* Emit finally handler if any. */
 79378:     ptrdiff_t finallyStart = 0;   /* to quell GCC uninitialized warnings */
     1:     if (pn->pn_kid3) {
     1:         /*
  1825:          * Fix up the gosubs that might have been emitted before non-local
  1825:          * jumps to the finally code.
  1825:          */
 80966:         if (!BackPatch(cx, bce, GOSUBS(stmtInfo), bce->next(), JSOP_GOSUB))
 80966:             return false;
 80966: 
 80966:         finallyStart = bce->offset();
  1825: 
 18567:         /* Indicate that we're emitting a subroutine body. */
     1:         stmtInfo.type = STMT_SUBROUTINE;
 80966:         if (!UpdateLineNumberNotes(cx, bce, pn->pn_kid3->pn_pos.begin.lineno))
 80966:             return false;
 80966:         if (Emit1(cx, bce, JSOP_FINALLY) < 0 ||
 80966:             !EmitTree(cx, bce, pn->pn_kid3) ||
 80966:             Emit1(cx, bce, JSOP_RETSUB) < 0)
 80966:         {
 80966:             return false;
 80966:         }
 80966:         JS_ASSERT(bce->stackDepth == depth);
 80966:     }
 80966:     if (!PopStatementBCE(cx, bce))
 80966:         return false;
 80966: 
 80966:     if (NewSrcNote(cx, bce, SRC_ENDBRACE) < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
 79378:         return false;
     1: 
     1:     /* Fix up the end-of-try/catch jumps to come here. */
 80966:     if (!BackPatch(cx, bce, catchJump, bce->next(), JSOP_GOTO))
 79378:         return false;
     1: 
     1:     /*
     1:      * Add the try note last, to let post-order give us the right ordering
     1:      * (first to last for a given nesting level, inner to outer by level).
     1:      */
 80966:     if (pn->pn_kid2 && !NewTryNote(cx, bce, JSTRY_CATCH, depth, tryStart, tryEnd))
 79378:         return false;
     1: 
     1:     /*
     1:      * If we've got a finally, mark try+catch region with additional
     1:      * trynote to catch exceptions (re)thrown from a catch block or
     1:      * for the try{}finally{} case.
     1:      */
 80966:     if (pn->pn_kid3 && !NewTryNote(cx, bce, JSTRY_FINALLY, depth, tryStart, finallyStart))
 79378:         return false;
 79378: 
 79378:     return true;
 79378: }
 79378: 
 79378: static bool
 80966: EmitIf(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 80631: {
 95355:     StmtInfo stmtInfo(cx);
 79378: 
 79378:     /* Initialize so we can detect else-if chains and avoid recursion. */
 79378:     stmtInfo.type = STMT_IF;
 79378:     ptrdiff_t beq = -1;
 79378:     ptrdiff_t jmp = -1;
 79378:     ptrdiff_t noteIndex = -1;
 79378: 
 79378:   if_again:
 79378:     /* Emit code for the condition before pushing stmtInfo. */
 80966:     if (!EmitTree(cx, bce, pn->pn_kid1))
 80966:         return JS_FALSE;
 80966:     ptrdiff_t top = bce->offset();
 79378:     if (stmtInfo.type == STMT_IF) {
 98445:         PushStatement(bce->sc, &stmtInfo, STMT_IF, top);
 79378:     } else {
 79378:         /*
 79378:          * We came here from the goto further below that detects else-if
 79378:          * chains, so we must mutate stmtInfo back into a STMT_IF record.
 79378:          * Also (see below for why) we need a note offset for SRC_IF_ELSE
 79378:          * to help the decompiler.  Actually, we need two offsets, one for
 79378:          * decompiling any else clause and the second for decompiling an
 79378:          * else-if chain without bracing, overindenting, or incorrectly
 79378:          * scoping let declarations.
 79378:          */
 79378:         JS_ASSERT(stmtInfo.type == STMT_ELSE);
 79378:         stmtInfo.type = STMT_IF;
 79378:         stmtInfo.update = top;
 80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, jmp - beq))
 80966:             return JS_FALSE;
 80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 1, top - beq))
 79378:             return JS_FALSE;
 79378:     }
 79378: 
 79378:     /* Emit an annotated branch-if-false around the then part. */
 80631:     ParseNode *pn3 = pn->pn_kid3;
 80966:     noteIndex = NewSrcNote(cx, bce, pn3 ? SRC_IF_ELSE : SRC_IF);
 79378:     if (noteIndex < 0)
 79378:         return JS_FALSE;
 80966:     beq = EmitJump(cx, bce, JSOP_IFEQ, 0);
 79378:     if (beq < 0)
 79378:         return JS_FALSE;
 79378: 
 79378:     /* Emit code for the then and optional else parts. */
 80966:     if (!EmitTree(cx, bce, pn->pn_kid2))
 79378:         return JS_FALSE;
 79378:     if (pn3) {
 79378:         /* Modify stmtInfo so we know we're in the else part. */
 79378:         stmtInfo.type = STMT_ELSE;
 79378: 
 79378:         /*
 79378:          * Emit a JSOP_BACKPATCH op to jump from the end of our then part
 80966:          * around the else part.  The PopStatementBCE call at the bottom of
 80966:          * this function will fix up the backpatch chain linked from
 79378:          * stmtInfo.breaks.
 79378:          */
 80966:         jmp = EmitGoto(cx, bce, &stmtInfo, &stmtInfo.breaks);
 79378:         if (jmp < 0)
 79378:             return JS_FALSE;
 79378: 
 79378:         /* Ensure the branch-if-false comes here, then emit the else. */
 86877:         SetJumpOffsetAt(bce, beq);
 82024:         if (pn3->isKind(PNK_IF)) {
 79378:             pn = pn3;
 79378:             goto if_again;
 79378:         }
 79378: 
 80966:         if (!EmitTree(cx, bce, pn3))
 79378:             return JS_FALSE;
 79378: 
 79378:         /*
 79378:          * Annotate SRC_IF_ELSE with the offset from branch to jump, for
 79378:          * the decompiler's benefit.  We can't just "back up" from the pc
 79378:          * of the else clause, because we don't know whether an extended
 79378:          * jump was required to leap from the end of the then clause over
 79378:          * the else clause.
 79378:          */
 80966:         if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, jmp - beq))
 79378:             return JS_FALSE;
 79378:     } else {
 79378:         /* No else part, fixup the branch-if-false to come here. */
 86877:         SetJumpOffsetAt(bce, beq);
 80966:     }
 80966:     return PopStatementBCE(cx, bce);
 79378: }
 79378: 
 79378: #if JS_HAS_BLOCK_SCOPE
 86078: /*
 86078:  * pnLet represents one of:
 86078:  *
 79378:  *   let-expression:   (let (x = y) EXPR)
 79378:  *   let-statement:    let (x = y) { ... }
 79378:  *
 86078:  * For a let-expression 'let (x = a, [y,z] = b) e', EmitLet produces:
 86078:  *
 86078:  *  bytecode          stackDepth  srcnotes
 86078:  *  evaluate a        +1
 86078:  *  evaluate b        +1
 86078:  *  dup               +1          SRC_DESTRUCTLET + offset to enterlet0
 86078:  *  destructure y
 86078:  *  pick 1
 86078:  *  dup               +1          SRC_DESTRUCTLET + offset to enterlet0
 86078:  *  pick
 86078:  *  destructure z
 86078:  *  pick 1
 86078:  *  pop               -1
 86078:  *  enterlet0                     SRC_DECL + offset to leaveblockexpr
 86078:  *  evaluate e        +1
 86078:  *  leaveblockexpr    -3          SRC_PCBASE + offset to evaluate a
 86078:  *
 86078:  * Note that, since enterlet0 simply changes fp->blockChain and does not
 86078:  * otherwise touch the stack, evaluation of the let-var initializers must leave
 86078:  * the initial value in the let-var's future slot.
 86078:  *
 86078:  * The SRC_DESTRUCTLET distinguish JSOP_DUP as the beginning of a destructuring
 86078:  * let initialization and the offset allows the decompiler to find the block
 86078:  * object from which to find let var names. These forward offsets require
 86078:  * backpatching, which is handled by LetNotes.
 86078:  *
 86078:  * The SRC_DECL offset allows recursive decompilation of 'e'.
 86078:  *
 86078:  * The SRC_PCBASE allows js_DecompileValueGenerator to walk backwards from
 86078:  * JSOP_LEAVEBLOCKEXPR to the beginning of the let and is only needed for
 86078:  * let-expressions.
 86078:  */
 91711: /*
 91711:  * Using MOZ_NEVER_INLINE in here is a workaround for llvm.org/pr12127. See
 91711:  * the comment on EmitSwitch.
 91711:  */
 91711: MOZ_NEVER_INLINE static bool
 86078: EmitLet(JSContext *cx, BytecodeEmitter *bce, ParseNode *pnLet)
 86078: {
 86078:     JS_ASSERT(pnLet->isArity(PN_BINARY));
 86078:     ParseNode *varList = pnLet->pn_left;
 86078:     JS_ASSERT(varList->isArity(PN_LIST));
 86078:     ParseNode *letBody = pnLet->pn_right;
 86078:     JS_ASSERT(letBody->isLet() && letBody->isKind(PNK_LEXICALSCOPE));
 99421:     Rooted<StaticBlockObject*> blockObj(cx, &letBody->pn_objbox->object->asStaticBlock());
 86078: 
 86078:     ptrdiff_t letHeadOffset = bce->offset();
 91237:     int letHeadDepth = bce->stackDepth;
 86078: 
 86078:     LetNotes letNotes(cx);
 86078:     if (!EmitVariables(cx, bce, varList, PushInitialValues, &letNotes))
 86078:         return false;
 86078: 
 86078:     /* Push storage for hoisted let decls (e.g. 'let (x) { let y }'). */
 91237:     uint32_t alreadyPushed = unsigned(bce->stackDepth - letHeadDepth);
 97353:     uint32_t blockObjCount = blockObj->slotCount();
 86078:     for (uint32_t i = alreadyPushed; i < blockObjCount; ++i) {
 86078:         /* Tell the decompiler not to print the decl in the let head. */
 86078:         if (NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
 86078:             return false;
 86078:         if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 86078:             return false;
 86078:     }
 86078: 
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushBlockScope(bce->sc, &stmtInfo, *blockObj, bce->offset());
 86078: 
 86078:     if (!letNotes.update(cx, bce, bce->offset()))
 86078:         return false;
 86078: 
 86078:     ptrdiff_t declNote = NewSrcNote(cx, bce, SRC_DECL);
 86078:     if (declNote < 0)
 86078:         return false;
 86078: 
 86078:     ptrdiff_t bodyBegin = bce->offset();
 86078:     if (!EmitEnterBlock(cx, bce, letBody, JSOP_ENTERLET0))
 86078:         return false;
 86078: 
 86078:     if (!EmitTree(cx, bce, letBody->pn_expr))
 86078:         return false;
 86078: 
 86078:     JSOp leaveOp = letBody->getOp();
 86078:     if (leaveOp == JSOP_LEAVEBLOCKEXPR) {
 86078:         if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - letHeadOffset) < 0)
 86078:             return false;
 86078:     }
 86078: 
 86078:     JS_ASSERT(leaveOp == JSOP_LEAVEBLOCK || leaveOp == JSOP_LEAVEBLOCKEXPR);
 97353:     EMIT_UINT16_IMM_OP(leaveOp, blockObj->slotCount());
 86078: 
 86078:     ptrdiff_t bodyEnd = bce->offset();
 86078:     JS_ASSERT(bodyEnd > bodyBegin);
 86078: 
 86078:     if (!PopStatementBCE(cx, bce))
 86078:         return false;
 86078: 
 86078:     ptrdiff_t o = PackLetData((bodyEnd - bodyBegin) -
 86078:                               (JSOP_ENTERLET0_LENGTH + JSOP_LEAVEBLOCK_LENGTH),
 86078:                               letNotes.isGroupAssign());
 86078:     return SetSrcNoteOffset(cx, bce, declNote, 0, o);
 79378: }
 79378: #endif
 79378: 
 79378: #if JS_HAS_XML_SUPPORT
 79378: static bool
 80966: EmitXMLTag(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 80966: {
 98445:     JS_ASSERT(!bce->sc->inStrictMode());
 80966: 
 80966:     if (Emit1(cx, bce, JSOP_STARTXML) < 0)
 79378:         return false;
 79378: 
 79378:     {
 79378:         jsatomid index;
 82024:         JSAtom *tagAtom = (pn->isKind(PNK_XMLETAGO))
 80780:                           ? cx->runtime->atomState.etagoAtom
 79378:                           : cx->runtime->atomState.stagoAtom;
 80966:         if (!bce->makeAtomIndex(tagAtom, &index))
 79378:             return false;
 90965:         if (!EmitIndex32(cx, JSOP_STRING, index, bce))
 90965:             return false;
 79378:     }
 79378: 
 79378:     JS_ASSERT(pn->pn_count != 0);
 80631:     ParseNode *pn2 = pn->pn_head;
 82873:     if (pn2->isKind(PNK_XMLCURLYEXPR) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
 80966:         return false;
 80966:     if (!EmitTree(cx, bce, pn2))
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_ADD) < 0)
 79378:         return false;
 79378: 
 84755:     uint32_t i;
 79378:     for (pn2 = pn2->pn_next, i = 0; pn2; pn2 = pn2->pn_next, i++) {
 82873:         if (pn2->isKind(PNK_XMLCURLYEXPR) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
 80966:             return false;
 80966:         if (!EmitTree(cx, bce, pn2))
 79378:             return false;
 82873:         if ((i & 1) && pn2->isKind(PNK_XMLCURLYEXPR)) {
 80966:             if (Emit1(cx, bce, JSOP_TOATTRVAL) < 0)
 80966:                 return false;
 80966:         }
 80966:         if (Emit1(cx, bce, (i & 1) ? JSOP_ADDATTRVAL : JSOP_ADDATTRNAME) < 0)
 80632:             return false;
 79378:     }
 79378: 
 79378:     {
 79378:         jsatomid index;
 82024:         JSAtom *tmp = (pn->isKind(PNK_XMLPTAGC)) ? cx->runtime->atomState.ptagcAtom
 79378:                                                  : cx->runtime->atomState.tagcAtom;
 80966:         if (!bce->makeAtomIndex(tmp, &index))
 79378:             return false;
 90965:         if (!EmitIndex32(cx, JSOP_STRING, index, bce))
 90965:             return false;
 79378:     }
 80966:     if (Emit1(cx, bce, JSOP_ADD) < 0)
 80966:         return false;
 80966: 
 80966:     if ((pn->pn_xflags & PNX_XMLROOT) && Emit1(cx, bce, pn->getOp()) < 0)
 79378:         return false;
 79378: 
 79378:     return true;
 79378: }
 79378: 
 79378: static bool
 86378: EmitXMLProcessingInstruction(JSContext *cx, BytecodeEmitter *bce, XMLProcessingInstruction &pi)
 80966: {
 98445:     JS_ASSERT(!bce->sc->inStrictMode());
 80780: 
 79378:     jsatomid index;
 86378:     if (!bce->makeAtomIndex(pi.data(), &index))
 80966:         return false;
 90965:     if (!EmitIndex32(cx, JSOP_QNAMEPART, index, bce))
 80966:         return false;
 86378:     if (!EmitAtomOp(cx, pi.target(), JSOP_XMLPI, bce))
 79378:         return false;
 79378:     return true;
 79378: }
 79378: #endif
 79378: 
 91711: /*
 91711:  * Using MOZ_NEVER_INLINE in here is a workaround for llvm.org/pr12127. See
 91711:  * the comment on EmitSwitch.
 91711:  */
 91711: MOZ_NEVER_INLINE static bool
 81588: EmitLexicalScope(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 80631: {
 86078:     JS_ASSERT(pn->isKind(PNK_LEXICALSCOPE));
 86078:     JS_ASSERT(pn->getOp() == JSOP_LEAVEBLOCK);
 86078: 
 95355:     StmtInfo stmtInfo(cx);
 80631:     ObjectBox *objbox = pn->pn_objbox;
 86483:     StaticBlockObject &blockObj = objbox->object->asStaticBlock();
 97353:     size_t slots = blockObj.slotCount();
 98445:     PushBlockScope(bce->sc, &stmtInfo, blockObj, bce->offset());
 86078: 
 86078:     /*
 86078:      * For compound statements (i.e. { stmt-list }), the decompiler does not
 86078:      * emit curlies by default. However, if this stmt-list contains a let
 86078:      * declaration, this is semantically invalid so we need to add a srcnote to
 86078:      * enterblock to tell the decompiler to add curlies. This condition
 86078:      * shouldn't be so complicated; try to find a simpler condition.
 79378:      */
 79378:     ptrdiff_t noteIndex = -1;
 86078:     if (pn->expr()->getKind() != PNK_FOR &&
 86078:         pn->expr()->getKind() != PNK_CATCH &&
 86078:         (stmtInfo.down
 86078:          ? stmtInfo.down->type == STMT_BLOCK &&
 86078:            (!stmtInfo.down->down || stmtInfo.down->down->type != STMT_FOR_IN_LOOP)
 98476:          : !bce->sc->inFunction))
 86078:     {
 79378:         /* There must be no source note already output for the next op. */
 80966:         JS_ASSERT(bce->noteCount() == 0 ||
 80966:                   bce->lastNoteOffset() != bce->offset() ||
 80966:                   !GettableNoteForNextOp(bce));
 80966:         noteIndex = NewSrcNote2(cx, bce, SRC_BRACE, 0);
 79378:         if (noteIndex < 0)
 79378:             return false;
 79378:     }
 79378: 
 86078:     ptrdiff_t bodyBegin = bce->offset();
 86078:     if (!EmitEnterBlock(cx, bce, pn, JSOP_ENTERBLOCK))
 80966:         return false;
 80966: 
 80966:     if (!EmitTree(cx, bce, pn->pn_expr))
 79378:         return false;
 79378: 
 86078:     if (noteIndex >= 0) {
 91237:         if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, bce->offset() - bodyBegin))
 86078:             return false;
 86078:     }
 86078: 
 97353:     EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, slots);
 80966: 
 81588:     return PopStatementBCE(cx, bce);
 79378: }
 79378: 
 79378: static bool
 81588: EmitWith(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 80631: {
 95355:     StmtInfo stmtInfo(cx);
 80966:     if (!EmitTree(cx, bce, pn->pn_left))
 80966:         return false;
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_WITH, bce->offset());
 80966:     if (Emit1(cx, bce, JSOP_ENTERWITH) < 0)
 79378:         return false;
 79378: 
 80966:     if (!EmitTree(cx, bce, pn->pn_right))
 80966:         return false;
 80966:     if (Emit1(cx, bce, JSOP_LEAVEWITH) < 0)
 80966:         return false;
 81588:     return PopStatementBCE(cx, bce);
 79378: }
 79378: 
 80735: static bool
 80966: EmitForIn(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 80735: {
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_FOR_IN_LOOP, top);
 80735: 
 80735:     ParseNode *forHead = pn->pn_left;
 80735:     ParseNode *forBody = pn->pn_right;
 80735: 
 86078:     ParseNode *pn1 = forHead->pn_kid1;
 86078:     bool letDecl = pn1 && pn1->isKind(PNK_LEXICALSCOPE);
 86078:     JS_ASSERT_IF(letDecl, pn1->isLet());
 86078: 
 99421:     Rooted<StaticBlockObject*> blockObj(cx, letDecl ? &pn1->pn_objbox->object->asStaticBlock() : NULL);
 86483:     uint32_t blockObjCount = blockObj ? blockObj->slotCount() : 0;
 86078: 
 86078:     if (letDecl) {
 86078:         /*
 86078:          * The let's slot(s) will be under the iterator, but the block must not
 86078:          * be entered (i.e. fp->blockChain set) until after evaluating the rhs.
 86078:          * Thus, push to reserve space and enterblock after. The same argument
 86078:          * applies when leaving the loop. Thus, a for-let-in loop looks like:
 86078:          *
 86078:          *   push x N
 86078:          *   eval rhs
 86078:          *   iter
 86078:          *   enterlet1
 86078:          *   goto
 86078:          *     ... loop body
 86078:          *   ifne
 86078:          *   leaveforinlet
 86078:          *   enditer
 86078:          *   popn(N)
 86078:          */
 86078:         for (uint32_t i = 0; i < blockObjCount; ++i) {
 86078:             if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 86078:                 return false;
 86078:         }
 86078:     }
 86078: 
 80735:     /*
 80735:      * If the left part is 'var x', emit code to define x if necessary
 86078:      * using a prolog opcode, but do not emit a pop. If the left part was
 86078:      * originally 'var x = i', the parser will have rewritten it; see
 86078:      * Parser::forStatement. 'for (let x = i in o)' is mercifully banned.
 86078:      */
 86078:     if (pn1) {
 86078:         ParseNode *decl = letDecl ? pn1->pn_expr : pn1;
 82024:         JS_ASSERT(decl->isKind(PNK_VAR) || decl->isKind(PNK_LET));
 98477:         bce->sc->inForInit = true;
 86078:         if (!EmitVariables(cx, bce, decl, DefineVars))
 80966:             return false;
 98477:         bce->sc->inForInit = false;
 80735:     }
 80735: 
 80735:     /* Compile the object expression to the right of 'in'. */
 80966:     if (!EmitTree(cx, bce, forHead->pn_kid3))
 86077:         return JS_FALSE;
 80735: 
 80735:     /*
 80735:      * Emit a bytecode to convert top of stack value to the iterator
 80735:      * object depending on the loop variant (for-in, for-each-in, or
 80735:      * destructuring for-in).
 80735:      */
 80735:     JS_ASSERT(pn->isOp(JSOP_ITER));
 84755:     if (Emit2(cx, bce, JSOP_ITER, (uint8_t) pn->pn_iflags) < 0)
 80735:         return false;
 80735: 
 86078:     /* Enter the block before the loop body, after evaluating the obj. */
 95355:     StmtInfo letStmt(cx);
 86078:     if (letDecl) {
 98445:         PushBlockScope(bce->sc, &letStmt, *blockObj, bce->offset());
 86078:         letStmt.flags |= SIF_FOR_BLOCK;
 86078:         if (!EmitEnterBlock(cx, bce, pn1, JSOP_ENTERLET1))
 86078:             return false;
 86078:     }
 86078: 
 80735:     /* Annotate so the decompiler can find the loop-closing jump. */
 91237:     int noteIndex = NewSrcNote(cx, bce, SRC_FOR_IN);
 80735:     if (noteIndex < 0)
 80735:         return false;
 80735: 
 80735:     /*
 80735:      * Jump down to the loop condition to minimize overhead assuming at
 80735:      * least one iteration, as the other loop forms do.
 80735:      */
 80966:     ptrdiff_t jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
 80735:     if (jmp < 0)
 80735:         return false;
 80735: 
 80966:     top = bce->offset();
 80735:     SET_STATEMENT_TOP(&stmtInfo, top);
 87961:     if (EmitLoopHead(cx, bce, NULL) < 0)
 80735:         return false;
 80735: 
 80735: #ifdef DEBUG
 91237:     int loopDepth = bce->stackDepth;
 80735: #endif
 80735: 
 80735:     /*
 80735:      * Emit code to get the next enumeration value and assign it to the
 80735:      * left hand side. The JSOP_POP after this assignment is annotated
 80735:      * so that the decompiler can distinguish 'for (x in y)' from
 80735:      * 'for (var x in y)'.
 80735:      */
 80966:     if (!EmitAssignment(cx, bce, forHead->pn_kid2, JSOP_NOP, NULL))
 80966:         return false;
 86078: 
 80966:     ptrdiff_t tmp2 = bce->offset();
 80966:     if (forHead->pn_kid1 && NewSrcNote2(cx, bce, SRC_DECL,
 80735:                                         (forHead->pn_kid1->isOp(JSOP_DEFVAR))
 80735:                                         ? SRC_DECL_VAR
 80735:                                         : SRC_DECL_LET) < 0) {
 80735:         return false;
 80735:     }
 80966:     if (Emit1(cx, bce, JSOP_POP) < 0)
 80735:         return false;
 80735: 
 80735:     /* The stack should be balanced around the assignment opcode sequence. */
 80966:     JS_ASSERT(bce->stackDepth == loopDepth);
 80735: 
 80735:     /* Emit code for the loop body. */
 80966:     if (!EmitTree(cx, bce, forBody))
 80735:         return false;
 80735: 
 80735:     /* Set loop and enclosing "update" offsets, for continue. */
 80735:     StmtInfo *stmt = &stmtInfo;
 80735:     do {
 80966:         stmt->update = bce->offset();
 80735:     } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
 80735: 
 80735:     /*
 80735:      * Fixup the goto that starts the loop to jump down to JSOP_MOREITER.
 80735:      */
 86877:     SetJumpOffsetAt(bce, jmp);
 87961:     if (!EmitLoopEntry(cx, bce, NULL))
 87961:         return false;
 80966:     if (Emit1(cx, bce, JSOP_MOREITER) < 0)
 80966:         return false;
 80966:     ptrdiff_t beq = EmitJump(cx, bce, JSOP_IFNE, top - bce->offset());
 80735:     if (beq < 0)
 80735:         return false;
 80735: 
 80735:     /* Set the first srcnote offset so we can find the start of the loop body. */
 91237:     if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, tmp2 - jmp))
 80735:         return false;
 80735:     /* Set the second srcnote offset so we can find the closing jump. */
 91237:     if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 1, beq - jmp))
 80735:         return false;
 80735: 
 86078:     /* Fixup breaks and continues before JSOP_ITER (and JSOP_LEAVEFORINLET). */
 80966:     if (!PopStatementBCE(cx, bce))
 80966:         return false;
 80966: 
 86078:     if (letDecl) {
 86078:         if (!PopStatementBCE(cx, bce))
 86078:             return false;
 86078:         if (Emit1(cx, bce, JSOP_LEAVEFORLETIN) < 0)
 86078:             return false;
 86078:     }
 86078: 
 80966:     if (!NewTryNote(cx, bce, JSTRY_ITER, bce->stackDepth, top, bce->offset()))
 80966:         return false;
 86078:     if (Emit1(cx, bce, JSOP_ENDITER) < 0)
 86078:         return false;
 86078: 
 86078:     if (letDecl) {
 86078:         /* Tell the decompiler to pop but not to print. */
 86078:         if (NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
 86078:             return false;
 86078:         EMIT_UINT16_IMM_OP(JSOP_POPN, blockObjCount);
 86078:     }
 86078: 
 86078:     return true;
 80735: }
 80735: 
 80735: static bool
 80966: EmitNormalFor(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 80735: {
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_FOR_LOOP, top);
 80735: 
 80735:     ParseNode *forHead = pn->pn_left;
 80735:     ParseNode *forBody = pn->pn_right;
 80735: 
 80735:     /* C-style for (init; cond; update) ... loop. */
 80735:     JSOp op = JSOP_POP;
 80735:     ParseNode *pn3 = forHead->pn_kid1;
 80735:     if (!pn3) {
 80735:         /* No initializer: emit an annotated nop for the decompiler. */
 80735:         op = JSOP_NOP;
 80735:     } else {
 98477:         bce->sc->inForInit = true;
 80735: #if JS_HAS_DESTRUCTURING
 82024:         if (pn3->isKind(PNK_ASSIGN)) {
 82023:             JS_ASSERT(pn3->isOp(JSOP_NOP));
 95099:             if (!MaybeEmitGroupAssignment(cx, bce, op, pn3, GroupIsNotDecl, &op))
 80735:                 return false;
 80735:         }
 80735: #endif
 80735:         if (op == JSOP_POP) {
 80966:             if (!EmitTree(cx, bce, pn3))
 80735:                 return false;
 82874:             if (pn3->isKind(PNK_VAR) || pn3->isKind(PNK_CONST) || pn3->isKind(PNK_LET)) {
 80735:                 /*
 80735:                  * Check whether a destructuring-initialized var decl
 80735:                  * was optimized to a group assignment.  If so, we do
 80735:                  * not need to emit a pop below, so switch to a nop,
 80735:                  * just for the decompiler.
 80735:                  */
 86078:                 JS_ASSERT(pn3->isArity(PN_LIST) || pn3->isArity(PN_BINARY));
 80735:                 if (pn3->pn_xflags & PNX_GROUPINIT)
 80735:                     op = JSOP_NOP;
 80735:             }
 80735:         }
 98477:         bce->sc->inForInit = false;
 80735:     }
 80735: 
 80735:     /*
 80735:      * NB: the SRC_FOR note has offsetBias 1 (JSOP_{NOP,POP}_LENGTH).
 80735:      * Use tmp to hold the biased srcnote "top" offset, which differs
 86877:      * from the top local variable by the length of the JSOP_GOTO
 80735:      * emitted in between tmp and top if this loop has a condition.
 80735:      */
 91237:     int noteIndex = NewSrcNote(cx, bce, SRC_FOR);
 80966:     if (noteIndex < 0 || Emit1(cx, bce, op) < 0)
 80966:         return false;
 80966:     ptrdiff_t tmp = bce->offset();
 80735: 
 80735:     ptrdiff_t jmp = -1;
 80735:     if (forHead->pn_kid2) {
 80735:         /* Goto the loop condition, which branches back to iterate. */
 80966:         jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
 80735:         if (jmp < 0)
 80735:             return false;
 91563:     } else {
 91563:         if (op != JSOP_NOP && Emit1(cx, bce, JSOP_NOP) < 0)
 91563:             return false;
 80735:     }
 80735: 
 80966:     top = bce->offset();
 80735:     SET_STATEMENT_TOP(&stmtInfo, top);
 80735: 
 80735:     /* Emit code for the loop body. */
 87961:     if (EmitLoopHead(cx, bce, forBody) < 0)
 87961:         return false;
 87961:     if (jmp == -1 && !EmitLoopEntry(cx, bce, forBody))
 80966:         return false;
 80966:     if (!EmitTree(cx, bce, forBody))
 80735:         return false;
 80735: 
 80735:     /* Set the second note offset so we can find the update part. */
 80735:     JS_ASSERT(noteIndex != -1);
 80966:     ptrdiff_t tmp2 = bce->offset();
 80735: 
 80735:     /* Set loop and enclosing "update" offsets, for continue. */
 80735:     StmtInfo *stmt = &stmtInfo;
 80735:     do {
 80966:         stmt->update = bce->offset();
 80735:     } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
 80735: 
 80735:     /* Check for update code to do before the condition (if any). */
 80735:     pn3 = forHead->pn_kid3;
 80735:     if (pn3) {
 80735:         op = JSOP_POP;
 80735: #if JS_HAS_DESTRUCTURING
 82024:         if (pn3->isKind(PNK_ASSIGN)) {
 82023:             JS_ASSERT(pn3->isOp(JSOP_NOP));
 95099:             if (!MaybeEmitGroupAssignment(cx, bce, op, pn3, GroupIsNotDecl, &op))
 80735:                 return false;
 80735:         }
 80735: #endif
 80966:         if (op == JSOP_POP && !EmitTree(cx, bce, pn3))
 80735:             return false;
 80735: 
 80735:         /* Always emit the POP or NOP, to help the decompiler. */
 80966:         if (Emit1(cx, bce, op) < 0)
 80735:             return false;
 80735: 
 80735:         /* Restore the absolute line number for source note readers. */
 80735:         ptrdiff_t lineno = pn->pn_pos.end.lineno;
 91237:         if (bce->currentLine() != (unsigned) lineno) {
 80966:             if (NewSrcNote2(cx, bce, SRC_SETLINE, lineno) < 0)
 80966:                 return false;
 91237:             bce->current->currentLine = (unsigned) lineno;
 80966:         }
 80966:     }
 80966: 
 80966:     ptrdiff_t tmp3 = bce->offset();
 80735: 
 80735:     if (forHead->pn_kid2) {
 80735:         /* Fix up the goto from top to target the loop condition. */
 80735:         JS_ASSERT(jmp >= 0);
 86877:         SetJumpOffsetAt(bce, jmp);
 87961:         if (!EmitLoopEntry(cx, bce, forHead->pn_kid2))
 87961:             return false;
 80966: 
 80966:         if (!EmitTree(cx, bce, forHead->pn_kid2))
 80735:             return false;
 80735:     }
 80735: 
 80735:     /* Set the first note offset so we can find the loop condition. */
 91237:     if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, tmp3 - tmp))
 91237:         return false;
 91237:     if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 1, tmp2 - tmp))
 80735:         return false;
 80735:     /* The third note offset helps us find the loop-closing jump. */
 91237:     if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 2, bce->offset() - tmp))
 80735:         return false;
 80735: 
 80735:     /* If no loop condition, just emit a loop-closing jump. */
 80735:     op = forHead->pn_kid2 ? JSOP_IFNE : JSOP_GOTO;
 80966:     if (EmitJump(cx, bce, op, top - bce->offset()) < 0)
 80735:         return false;
 80735: 
 80735:     /* Now fixup all breaks and continues. */
 80966:     return PopStatementBCE(cx, bce);
 80735: }
 80735: 
 80735: static inline bool
 80966: EmitFor(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 80735: {
 82871:     JS_ASSERT(pn->pn_left->isKind(PNK_FORIN) || pn->pn_left->isKind(PNK_FORHEAD));
 82871:     return pn->pn_left->isKind(PNK_FORIN)
 80966:            ? EmitForIn(cx, bce, pn, top)
 80966:            : EmitNormalFor(cx, bce, pn, top);
 80735: }
 80735: 
 94275: static JS_NEVER_INLINE bool
 84072: EmitFunc(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84071: {
 79378: #if JS_HAS_XML_SUPPORT
 84073:     if (pn->isArity(PN_NULLARY))
 84073:         return Emit1(cx, bce, JSOP_GETFUNNS) >= 0;
 79378: #endif
 79378: 
 99421:     RootedFunction fun(cx, pn->pn_funbox->function());
 79378:     JS_ASSERT(fun->isInterpreted());
 79378:     if (fun->script()) {
 79378:         /*
 79378:          * This second pass is needed to emit JSOP_NOP with a source note
 79378:          * for the already-emitted function definition prolog opcode. See
 95488:          * comments in EmitStatementList.
 79378:          */
 79378:         JS_ASSERT(pn->isOp(JSOP_NOP));
 98476:         JS_ASSERT(bce->sc->inFunction);
 84073:         return EmitFunctionDefNop(cx, bce, pn->pn_index);
 79378:     }
 79378: 
 98687:     JS_ASSERT_IF(pn->pn_funbox->funIsHeavyweight(),
 79378:                  fun->kind() == JSFUN_INTERPRETED);
 79378: 
 84073:     {
 98476:         SharedContext sc(cx, /* inFunction = */ true);
 98463:         BytecodeEmitter bce2(bce->parser, &sc, pn->pn_pos.begin.lineno,
 98463:                              /* noScriptRval = */ false, /* needsScriptGlobal = */ false);
 98445:         if (!bce2.init())
 98445:             return false;
 98445: 
 98687:         FunctionBox *funbox = pn->pn_funbox;
 98687:         bce2.sc->cxFlags = funbox->cxFlags;
 98687:         if (bce->sc->funMightAliasLocals())
 98687:             bce2.sc->setFunMightAliasLocals();  // inherit funMightAliasLocals from parent
 98687: 
 98687:         bce2.sc->bindings.transfer(cx, &funbox->bindings);
 98445:         bce2.sc->setFunction(fun);
 98687:         bce2.sc->funbox = funbox;
 94275:         bce2.parent = bce;
 94275:         bce2.globalScope = bce->globalScope;
 79378: 
 79378:         /*
 80634:          * js::frontend::SetStaticLevel limited static nesting depth to fit in
 80634:          * 16 bits and to reserve the all-ones value, thereby reserving the
 94275:          * magic FREE_UPVAR_COOKIE value. Note the bce2.staticLevel assignment
 80634:          * below.
 79378:          */
 98445:         JS_ASSERT(bce->sc->staticLevel < JS_BITMASK(16) - 1);
 98445:         bce2.sc->staticLevel = bce->sc->staticLevel + 1;
 79378: 
 79378:         /* We measured the max scope depth when we parsed the function. */
 94275:         if (!EmitFunctionScript(cx, &bce2, pn->pn_body))
 84073:             return false;
 84073:     }
 79378: 
 79378:     /* Make the function object a literal in the outer script's pool. */
100006:     unsigned index = bce->objectList.index(pn->pn_funbox);
 79378: 
 79378:     /* Emit a bytecode pointing to the closure object in its immediate. */
 84073:     if (pn->getOp() != JSOP_NOP) {
 98687:         if (pn->pn_funbox->inGenexpLambda && NewSrcNote(cx, bce, SRC_GENEXP) < 0)
 98481:             return false;
 89253: 
 89253:         return EmitFunctionOp(cx, pn->getOp(), index, bce);
 79378:     }
 79378: 
 79378:     /*
 79378:      * For a script we emit the code as we parse. Thus the bytecode for
 79378:      * top-level functions should go in the prolog to predefine their
 79378:      * names in the variable object before the already-generated main code
 79378:      * is executed. This extra work for top-level scripts is not necessary
 79378:      * when we emit the code for a function. It is fully parsed prior to
 80632:      * invocation of the emitter and calls to EmitTree for function
 79378:      * definitions can be scheduled before generating the rest of code.
 79378:      */
 98476:     if (!bce->sc->inFunction) {
 98445:         JS_ASSERT(!bce->sc->topStmt);
 98173:         JS_ASSERT(pn->pn_cookie.isFree());
 79378:         if (pn->pn_cookie.isFree()) {
 80966:             bce->switchToProlog();
 89818:             if (!EmitFunctionOp(cx, JSOP_DEFFUN, index, bce))
 89253:                 return false;
 91316:             if (!UpdateLineNumberNotes(cx, bce, pn->pn_pos.begin.lineno))
 91316:                 return false;
 80966:             bce->switchToMain();
 79378:         }
 79378: 
 79378:         /* Emit NOP for the decompiler. */
 80966:         if (!EmitFunctionDefNop(cx, bce, index))
 84073:             return false;
 79378:     } else {
 91237:         unsigned slot;
 98445:         DebugOnly<BindingKind> kind = bce->sc->bindings.lookup(cx, fun->atom, &slot);
 79378:         JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
 79378:         JS_ASSERT(index < JS_BIT(20));
 79378:         pn->pn_index = index;
 95098:         if (bce->shouldNoteClosedName(pn) && !bce->noteClosedVar(pn))
 95098:             return false;
 94152: 
 94152:         if (NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
 94152:             return false;
 94152:         if (!EmitIndexOp(cx, JSOP_LAMBDA, index, bce))
 94152:             return false;
 95101:         if (!EmitVarOp(cx, pn, JSOP_SETLOCAL, bce))
 95101:             return false;
 94152:         if (Emit1(cx, bce, JSOP_POP) < 0)
 94152:             return false;
 84071:     }
 84072: 
 84072:     return true;
 84072: }
 84072: 
 84074: static bool
 84074: EmitDo(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84074: {
 84074:     /* Emit an annotated nop so we know to decompile a 'do' keyword. */
 84074:     ptrdiff_t noteIndex = NewSrcNote(cx, bce, SRC_WHILE);
 84074:     if (noteIndex < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
 84075:         return false;
 84074: 
 84696:     ptrdiff_t noteIndex2 = NewSrcNote(cx, bce, SRC_WHILE);
 84074:     if (noteIndex2 < 0)
 84075:         return false;
 84074: 
 84074:     /* Compile the loop body. */
 87961:     ptrdiff_t top = EmitLoopHead(cx, bce, pn->pn_left);
 84074:     if (top < 0)
 84075:         return false;
 87961:     if (!EmitLoopEntry(cx, bce, NULL))
 87961:         return false;
 84075: 
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_DO_LOOP, top);
 84074:     if (!EmitTree(cx, bce, pn->pn_left))
 84075:         return false;
 84074: 
 84074:     /* Set loop and enclosing label update offsets, for continue. */
 84074:     ptrdiff_t off = bce->offset();
 84074:     StmtInfo *stmt = &stmtInfo;
 84074:     do {
 84074:         stmt->update = off;
 84074:     } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
 84074: 
 84074:     /* Compile the loop condition, now that continues know where to go. */
 84074:     if (!EmitTree(cx, bce, pn->pn_right))
 84075:         return false;
 84074: 
 84074:     /*
 84074:      * Since we use JSOP_IFNE for other purposes as well as for do-while
 84074:      * loops, we must store 1 + (beq - top) in the SRC_WHILE note offset,
 84074:      * and the decompiler must get that delta and decompile recursively.
 84074:      */
 84074:     ptrdiff_t beq = EmitJump(cx, bce, JSOP_IFNE, top - bce->offset());
 84074:     if (beq < 0)
 84075:         return false;
 84075: 
 84074:     /*
 84074:      * Be careful: We must set noteIndex2 before noteIndex in case the noteIndex
 84074:      * note gets bigger.
 84074:      */
 84074:     if (!SetSrcNoteOffset(cx, bce, noteIndex2, 0, beq - top))
 84075:         return false;
 84074:     if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, 1 + (off - top)))
 84075:         return false;
 84075: 
 84074:     return PopStatementBCE(cx, bce);
 84074: }
 84074: 
 84076: static bool
 84076: EmitWhile(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 84076: {
 79378:     /*
 79378:      * Minimize bytecodes issued for one or more iterations by jumping to
 79378:      * the condition below the body and closing the loop if the condition
 79378:      * is true with a backward branch. For iteration count i:
 79378:      *
 79378:      *  i    test at the top                 test at the bottom
 79378:      *  =    ===============                 ==================
 79378:      *  0    ifeq-pass                       goto; ifne-fail
 79378:      *  1    ifeq-fail; goto; ifne-pass      goto; ifne-pass; ifne-fail
 79378:      *  2    2*(ifeq-fail; goto); ifeq-pass  goto; 2*ifne-pass; ifne-fail
 79378:      *  . . .
 79378:      *  N    N*(ifeq-fail; goto); ifeq-pass  goto; N*ifne-pass; ifne-fail
 84071:      */
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_WHILE_LOOP, top);
 84077: 
 84076:     ptrdiff_t noteIndex = NewSrcNote(cx, bce, SRC_WHILE);
 79378:     if (noteIndex < 0)
 84077:         return false;
 84077: 
 84076:     ptrdiff_t jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
 79378:     if (jmp < 0)
 84077:         return false;
 84077: 
 87961:     top = EmitLoopHead(cx, bce, pn->pn_right);
 79378:     if (top < 0)
 84077:         return false;
 84077: 
 80966:     if (!EmitTree(cx, bce, pn->pn_right))
 84077:         return false;
 84077: 
 86877:     SetJumpOffsetAt(bce, jmp);
 87961:     if (!EmitLoopEntry(cx, bce, pn->pn_left))
 87961:         return false;
 80966:     if (!EmitTree(cx, bce, pn->pn_left))
 84077:         return false;
 84077: 
 84076:     ptrdiff_t beq = EmitJump(cx, bce, JSOP_IFNE, top - bce->offset());
 79378:     if (beq < 0)
 84077:         return false;
 84077: 
 80966:     if (!SetSrcNoteOffset(cx, bce, noteIndex, 0, beq - jmp))
 84077:         return false;
 84077: 
 84076:     return PopStatementBCE(cx, bce);
 84076: }
 84076: 
 84078: static bool
 84666: EmitBreak(JSContext *cx, BytecodeEmitter *bce, PropertyName *label)
 84078: {
 98445:     StmtInfo *stmt = bce->sc->topStmt;
 84078:     SrcNoteType noteType;
 84078:     jsatomid labelIndex;
 84666:     if (label) {
 84666:         if (!bce->makeAtomIndex(label, &labelIndex))
 84666:             return false;
 84666: 
 84666:         while (stmt->type != STMT_LABEL || stmt->label != label)
 84078:             stmt = stmt->down;
 84078:         noteType = SRC_BREAK2LABEL;
 84078:     } else {
 84078:         labelIndex = INVALID_ATOMID;
 84078:         while (!STMT_IS_LOOP(stmt) && stmt->type != STMT_SWITCH)
 84078:             stmt = stmt->down;
 84078:         noteType = (stmt->type == STMT_SWITCH) ? SRC_SWITCHBREAK : SRC_BREAK;
 84078:     }
 84078: 
 84079:     return EmitGoto(cx, bce, stmt, &stmt->breaks, labelIndex, noteType) >= 0;
 84078: }
 84078: 
 84080: static bool
 84666: EmitContinue(JSContext *cx, BytecodeEmitter *bce, PropertyName *label)
 84080: {
 98445:     StmtInfo *stmt = bce->sc->topStmt;
 84080:     SrcNoteType noteType;
 84080:     jsatomid labelIndex;
 84666:     if (label) {
 84666:         if (!bce->makeAtomIndex(label, &labelIndex))
 84081:             return false;
 84081: 
 84080:         /* Find the loop statement enclosed by the matching label. */
 84080:         StmtInfo *loop = NULL;
 84666:         while (stmt->type != STMT_LABEL || stmt->label != label) {
 84080:             if (STMT_IS_LOOP(stmt))
 84080:                 loop = stmt;
 84080:             stmt = stmt->down;
 84080:         }
 84080:         stmt = loop;
 84080:         noteType = SRC_CONT2LABEL;
 84080:     } else {
 84080:         labelIndex = INVALID_ATOMID;
 84080:         while (!STMT_IS_LOOP(stmt))
 84080:             stmt = stmt->down;
 84080:         noteType = SRC_CONTINUE;
 84080:     }
 84080: 
 84081:     return EmitGoto(cx, bce, stmt, &stmt->continues, labelIndex, noteType) >= 0;
 84080: }
 84080: 
 84082: static bool
 84082: EmitReturn(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84082: {
 84082:     /* Push a return value */
 84083:     if (ParseNode *pn2 = pn->pn_kid) {
 84082:         if (!EmitTree(cx, bce, pn2))
 84083:             return false;
 84082:     } else {
 84493:         /* No explicit return value provided */
 84493:         if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 84083:             return false;
 84082:     }
 84082: 
 84082:     /*
 84082:      * EmitNonLocalJumpFixup may add fixup bytecode to close open try
 84082:      * blocks having finally clauses and to exit intermingled let blocks.
 84082:      * We can't simply transfer control flow to our caller in that case,
 84082:      * because we must gosub to those finally clauses from inner to outer,
 84082:      * with the correct stack pointer (i.e., after popping any with,
 84082:      * for/in, etc., slots nested inside the finally's try).
 84082:      *
 84082:      * In this case we mutate JSOP_RETURN into JSOP_SETRVAL and add an
 84082:      * extra JSOP_RETRVAL after the fixups.
 84082:      */
 84082:     ptrdiff_t top = bce->offset();
 84083: 
 84082:     if (Emit1(cx, bce, JSOP_RETURN) < 0)
 84083:         return false;
 84082:     if (!EmitNonLocalJumpFixup(cx, bce, NULL))
 84083:         return false;
 84082:     if (top + JSOP_RETURN_LENGTH != bce->offset()) {
 84082:         bce->base()[top] = JSOP_SETRVAL;
 84082:         if (Emit1(cx, bce, JSOP_RETRVAL) < 0)
 84083:             return false;
 84083:     }
 84083: 
 84082:     return true;
 84082: }
 84082: 
 84084: static bool
 84084: EmitStatementList(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 84084: {
 84084:     JS_ASSERT(pn->isArity(PN_LIST));
 84084: 
 84084:     ptrdiff_t noteIndex = -1;
 84084:     ptrdiff_t tmp = bce->offset();
 84084:     if (pn->pn_xflags & PNX_NEEDBRACES) {
 84084:         noteIndex = NewSrcNote2(cx, bce, SRC_BRACE, 0);
 84084:         if (noteIndex < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
 84085:             return false;
 84084:     }
 84084: 
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_BLOCK, top);
 84084: 
 84084:     ParseNode *pnchild = pn->pn_head;
 99552: 
 99552:     // Destructuring is handled in args body for functions with default
 99552:     // arguments.
 99552:     if (pn->pn_xflags & PNX_DESTRUCT && bce->sc->fun()->hasDefaults())
 99552:         pnchild = pnchild->pn_next;
 84084:     if (pn->pn_xflags & PNX_FUNCDEFS) {
 84084:         /*
 84084:          * This block contains top-level function definitions. To ensure
 84084:          * that we emit the bytecode defining them before the rest of code
 84084:          * in the block we use a separate pass over functions. During the
 84084:          * main pass later the emitter will add JSOP_NOP with source notes
 84084:          * for the function to preserve the original functions position
 84084:          * when decompiling.
 84084:          *
 84084:          * Currently this is used only for functions, as compile-as-we go
 84084:          * mode for scripts does not allow separate emitter passes.
 84084:          */
 98476:         JS_ASSERT(bce->sc->inFunction);
 99552:         if (pn->pn_xflags & PNX_DESTRUCT && !bce->sc->fun()->hasDefaults()) {
 84084:             /*
 84084:              * Assign the destructuring arguments before defining any
 84084:              * functions, see bug 419662.
 84084:              */
 84084:             JS_ASSERT(pnchild->isKind(PNK_SEMI));
 84084:             JS_ASSERT(pnchild->pn_kid->isKind(PNK_VAR) || pnchild->pn_kid->isKind(PNK_CONST));
 84084:             if (!EmitTree(cx, bce, pnchild))
 84085:                 return false;
 84084:             pnchild = pnchild->pn_next;
 84084:         }
 84084: 
 84084:         for (ParseNode *pn2 = pnchild; pn2; pn2 = pn2->pn_next) {
 84084:             if (pn2->isKind(PNK_FUNCTION)) {
 84084:                 if (pn2->isOp(JSOP_NOP)) {
 84084:                     if (!EmitTree(cx, bce, pn2))
 84085:                         return false;
 84084:                 } else {
 84084:                     /*
 84084:                      * JSOP_DEFFUN in a top-level block with function
 84084:                      * definitions appears, for example, when "if (true)"
 84084:                      * is optimized away from "if (true) function x() {}".
 84084:                      * See bug 428424.
 84084:                      */
 84084:                     JS_ASSERT(pn2->isOp(JSOP_DEFFUN));
 84084:                 }
 84084:             }
 84084:         }
 84084:     }
 84085: 
 84084:     for (ParseNode *pn2 = pnchild; pn2; pn2 = pn2->pn_next) {
 84084:         if (!EmitTree(cx, bce, pn2))
 84085:             return false;
 84084:     }
 84084: 
 91237:     if (noteIndex >= 0 && !SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, bce->offset() - tmp))
 84085:         return false;
 84084: 
 84084:     return PopStatementBCE(cx, bce);
 84084: }
 84084: 
 84084: static bool
 84084: EmitStatement(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84084: {
 84084:     JS_ASSERT(pn->isKind(PNK_SEMI));
 84084: 
 84084:     ParseNode *pn2 = pn->pn_kid;
 84085:     if (!pn2)
 84085:         return true;
 84085: 
 84084:     /*
 84084:      * Top-level or called-from-a-native JS_Execute/EvaluateScript,
 84084:      * debugger, and eval frames may need the value of the ultimate
 84084:      * expression statement as the script's result, despite the fact
 84084:      * that it appears useless to the compiler.
 84084:      *
 84084:      * API users may also set the JSOPTION_NO_SCRIPT_RVAL option when
 84084:      * calling JS_Compile* to suppress JSOP_POPV.
 84084:      */
 98463:     bool wantval = false;
 98463:     JSBool useful = JS_FALSE;
 98476:     if (bce->sc->inFunction) {
 98463:         JS_ASSERT(!bce->noScriptRval);
 98463:     } else {
 98463:         useful = wantval = !bce->noScriptRval;
 98463:     }
 84084: 
 84084:     /* Don't eliminate expressions with side effects. */
 84084:     if (!useful) {
 84084:         if (!CheckSideEffects(cx, bce, pn2, &useful))
 84085:             return false;
 84084: 
 84084:         /*
 84084:          * Don't eliminate apparently useless expressions if they are
 84084:          * labeled expression statements.  The tc->topStmt->update test
 84084:          * catches the case where we are nesting in EmitTree for a labeled
 84084:          * compound statement.
 84084:          */
 98445:         if (bce->sc->topStmt &&
 98445:             bce->sc->topStmt->type == STMT_LABEL &&
 98445:             bce->sc->topStmt->update >= bce->offset())
 84085:         {
 84084:             useful = true;
 84084:         }
 84085:     }
 84085: 
 84085:     if (useful) {
 84084:         JSOp op = wantval ? JSOP_POPV : JSOP_POP;
 84084:         JS_ASSERT_IF(pn2->isKind(PNK_ASSIGN), pn2->isOp(JSOP_NOP));
 84084: #if JS_HAS_DESTRUCTURING
 84084:         if (!wantval &&
 84084:             pn2->isKind(PNK_ASSIGN) &&
 95099:             !MaybeEmitGroupAssignment(cx, bce, op, pn2, GroupIsNotDecl, &op))
 84085:         {
 84085:             return false;
 84084:         }
 84084: #endif
 84084:         if (op != JSOP_NOP) {
 84084:             if (!EmitTree(cx, bce, pn2))
 84085:                 return false;
 84084:             if (Emit1(cx, bce, op) < 0)
 84085:                 return false;
 84085:         }
 84085:     } else if (!pn->isDirectivePrologueMember()) {
 84085:         /* Don't complain about directive prologue members; just don't emit their code. */
 84085:         bce->current->currentLine = pn2->pn_pos.begin.lineno;
 84085:         if (!ReportCompileErrorNumber(cx, bce->tokenStream(), pn2,
 84085:                                       JSREPORT_WARNING | JSREPORT_STRICT, JSMSG_USELESS_EXPR))
 84085:         {
 84085:             return false;
 84085:         }
 84085:     }
 84085: 
 84084:     return true;
 84084: }
 84084: 
 84086: static bool
 84086: EmitDelete(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84086: {
 84086:     /*
 84086:      * Under ECMA 3, deleting a non-reference returns true -- but alas we
 84086:      * must evaluate the operand if it appears it might have side effects.
 84086:      */
 84086:     ParseNode *pn2 = pn->pn_kid;
 84086:     switch (pn2->getKind()) {
 84086:       case PNK_NAME:
 84086:       {
 84086:         if (!BindNameToSlot(cx, bce, pn2))
 84087:             return false;
 84086:         JSOp op = pn2->getOp();
 84086:         if (op == JSOP_FALSE) {
 84086:             if (Emit1(cx, bce, op) < 0)
 84087:                 return false;
 84086:         } else {
 84086:             if (!EmitAtomOp(cx, pn2, op, bce))
 84087:                 return false;
 84086:         }
 84086:         break;
 84086:       }
 84086:       case PNK_DOT:
 84087:         if (!EmitPropOp(cx, pn2, JSOP_DELPROP, bce, false))
 84087:             return false;
 84086:         break;
 84086: #if JS_HAS_XML_SUPPORT
 84086:       case PNK_DBLDOT:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 84086:         if (!EmitElemOp(cx, pn2, JSOP_DELDESC, bce))
 84087:             return false;
 84086:         break;
 84086: #endif
 84086:       case PNK_LB:
 84086:         if (!EmitElemOp(cx, pn2, JSOP_DELELEM, bce))
 84087:             return false;
 84086:         break;
 84086:       default:
 84086:       {
 84086:         /*
 84086:          * If useless, just emit JSOP_TRUE; otherwise convert delete foo()
 84086:          * to foo(), true (a comma expression, requiring SRC_PCDELTA).
 84086:          */
 84087:         JSBool useful = false;
 84086:         if (!CheckSideEffects(cx, bce, pn2, &useful))
 84087:             return false;
 84087: 
 84086:         ptrdiff_t off, noteIndex;
 84087:         if (useful) {
 84086:             JS_ASSERT_IF(pn2->isKind(PNK_LP), !(pn2->pn_xflags & PNX_SETCALL));
 84086:             if (!EmitTree(cx, bce, pn2))
 84087:                 return false;
 84086:             off = bce->offset();
 84086:             noteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
 84086:             if (noteIndex < 0 || Emit1(cx, bce, JSOP_POP) < 0)
 84087:                 return false;
 84087:         } else {
 84087:             off = noteIndex = -1;
 84087:         }
 84087: 
 84086:         if (Emit1(cx, bce, JSOP_TRUE) < 0)
 84087:             return false;
 84086:         if (noteIndex >= 0) {
 84086:             ptrdiff_t tmp = bce->offset();
 91237:             if (!SetSrcNoteOffset(cx, bce, unsigned(noteIndex), 0, tmp - off))
 84087:                 return false;
 84087:         }
 84087:       }
 84087:     }
 84087: 
 84086:     return true;
 84086: }
 84086: 
 84088: static bool
 84088: EmitCallOrNew(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 84088: {
 84088:     bool callop = pn->isKind(PNK_LP);
 84088: 
 84088:     /*
 84088:      * Emit callable invocation or operator new (constructor call) code.
 84088:      * First, emit code for the left operand to evaluate the callable or
 84088:      * constructable object expression.
 84088:      *
 84088:      * For operator new applied to other expressions than E4X ones, we emit
 84088:      * JSOP_GETPROP instead of JSOP_CALLPROP, etc. This is necessary to
 84088:      * interpose the lambda-initialized method read barrier -- see the code
 84088:      * in jsinterp.cpp for JSOP_LAMBDA followed by JSOP_{SET,INIT}PROP.
 84088:      *
 84088:      * Then (or in a call case that has no explicit reference-base
 84493:      * object) we emit JSOP_UNDEFINED to produce the undefined |this|
 84493:      * value required for calls (which non-strict mode functions
 84493:      * will box into the global object).
 84088:      */
 84088:     ParseNode *pn2 = pn->pn_head;
 84088:     switch (pn2->getKind()) {
 84088:       case PNK_NAME:
 84088:         if (!EmitNameOp(cx, bce, pn2, callop))
 84089:             return false;
 84088:         break;
 84088:       case PNK_DOT:
 84088:         if (!EmitPropOp(cx, pn2, pn2->getOp(), bce, callop))
 84089:             return false;
 84088:         break;
 84088:       case PNK_LB:
 84088:         JS_ASSERT(pn2->isOp(JSOP_GETELEM));
 84088:         if (!EmitElemOp(cx, pn2, callop ? JSOP_CALLELEM : JSOP_GETELEM, bce))
 84089:             return false;
 84088:         break;
 84088: #if JS_HAS_XML_SUPPORT
 84088:       case PNK_XMLUNARY:
 84088:         JS_ASSERT(pn2->isOp(JSOP_XMLNAME));
 84088:         if (!EmitXMLName(cx, pn2, JSOP_CALLXMLNAME, bce))
 84089:             return false;
 84493:         callop = true;          /* suppress JSOP_UNDEFINED after */
 84088:         break;
 84088: #endif
 84088:       default:
 84088:         if (!EmitTree(cx, bce, pn2))
 84089:             return false;
 84493:         callop = false;             /* trigger JSOP_UNDEFINED after */
 84493:         break;
 84493:     }
 84493:     if (!callop && Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 84089:         return false;
 84088: 
 84088:     /* Remember start of callable-object bytecode for decompilation hint. */
 84088:     ptrdiff_t off = top;
 84088: 
 84088:     /*
 84088:      * Emit code for each argument in order, then emit the JSOP_*CALL or
 84088:      * JSOP_NEW bytecode with a two-byte immediate telling how many args
 84088:      * were pushed on the operand stack.
 84088:      */
 98477:     bool oldInForInit = bce->sc->inForInit;
 98477:     bce->sc->inForInit = false;
 84088:     for (ParseNode *pn3 = pn2->pn_next; pn3; pn3 = pn3->pn_next) {
 84088:         if (!EmitTree(cx, bce, pn3))
 84089:             return false;
 84088:     }
 98477:     bce->sc->inForInit = oldInForInit;
 84088:     if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - off) < 0)
 84089:         return false;
 84088: 
 84755:     uint32_t argc = pn->pn_count - 1;
 84088:     if (Emit3(cx, bce, pn->getOp(), ARGC_HI(argc), ARGC_LO(argc)) < 0)
 84089:         return false;
 84088:     CheckTypeSet(cx, bce, pn->getOp());
 86077:     if (pn->isOp(JSOP_EVAL))
 84088:         EMIT_UINT16_IMM_OP(JSOP_LINENO, pn->pn_pos.begin.lineno);
 84088:     if (pn->pn_xflags & PNX_SETCALL) {
 84088:         if (Emit1(cx, bce, JSOP_SETCALL) < 0)
 84089:             return false;
 84088:     }
 84088:     return true;
 84088: }
 84088: 
 84090: static bool
 84090: EmitLogical(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84090: {
 84090:     /*
 84090:      * JSOP_OR converts the operand on the stack to boolean, leaves the original
 84090:      * value on the stack and jumps if true; otherwise it falls into the next
 84090:      * bytecode, which pops the left operand and then evaluates the right operand.
 84090:      * The jump goes around the right operand evaluation.
 84090:      *
 84090:      * JSOP_AND converts the operand on the stack to boolean and jumps if false;
 84090:      * otherwise it falls into the right operand's bytecode.
 84090:      */
 84091: 
 84090:     if (pn->isArity(PN_BINARY)) {
 84090:         if (!EmitTree(cx, bce, pn->pn_left))
 84091:             return false;
 84090:         ptrdiff_t top = EmitJump(cx, bce, JSOP_BACKPATCH, 0);
 84090:         if (top < 0)
 84091:             return false;
 84090:         if (Emit1(cx, bce, JSOP_POP) < 0)
 84091:             return false;
 84090:         if (!EmitTree(cx, bce, pn->pn_right))
 84091:             return false;
 84090:         ptrdiff_t off = bce->offset();
 84090:         jsbytecode *pc = bce->code(top);
 86877:         SET_JUMP_OFFSET(pc, off - top);
 84090:         *pc = pn->getOp();
 84091:         return true;
 84091:     }
 84091: 
 84090:     JS_ASSERT(pn->isArity(PN_LIST));
 84090:     JS_ASSERT(pn->pn_head->pn_next->pn_next);
 84090: 
 84090:     /* Left-associative operator chain: avoid too much recursion. */
 84090:     ParseNode *pn2 = pn->pn_head;
 84090:     if (!EmitTree(cx, bce, pn2))
 84091:         return false;
 84090:     ptrdiff_t top = EmitJump(cx, bce, JSOP_BACKPATCH, 0);
 84090:     if (top < 0)
 84091:         return false;
 84090:     if (Emit1(cx, bce, JSOP_POP) < 0)
 84091:         return false;
 84090: 
 84090:     /* Emit nodes between the head and the tail. */
 84090:     ptrdiff_t jmp = top;
 84090:     while ((pn2 = pn2->pn_next)->pn_next) {
 84090:         if (!EmitTree(cx, bce, pn2))
 84091:             return false;
 84090:         ptrdiff_t off = EmitJump(cx, bce, JSOP_BACKPATCH, 0);
 84090:         if (off < 0)
 84091:             return false;
 84090:         if (Emit1(cx, bce, JSOP_POP) < 0)
 84091:             return false;
 86877:         SET_JUMP_OFFSET(bce->code(jmp), off - jmp);
 84090:         jmp = off;
 84090:     }
 84090:     if (!EmitTree(cx, bce, pn2))
 84091:         return false;
 84090: 
 84090:     pn2 = pn->pn_head;
 84090:     ptrdiff_t off = bce->offset();
 84090:     do {
 84090:         jsbytecode *pc = bce->code(top);
 86877:         ptrdiff_t tmp = GET_JUMP_OFFSET(pc);
 86877:         SET_JUMP_OFFSET(pc, off - top);
 84090:         *pc = pn->getOp();
 84090:         top += tmp;
 84090:     } while ((pn2 = pn2->pn_next)->pn_next);
 84091: 
 84090:     return true;
 84090: }
 84090: 
 84092: static bool
 84092: EmitIncOrDec(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84092: {
 84092:     /* Emit lvalue-specialized code for ++/-- operators. */
 84092:     ParseNode *pn2 = pn->pn_kid;
 84092:     JS_ASSERT(!pn2->isKind(PNK_RP));
 84092:     JSOp op = pn->getOp();
 84092:     switch (pn2->getKind()) {
 84093:       case PNK_DOT:
 84093:         if (!EmitPropIncDec(cx, pn2, op, bce))
 84093:             return false;
 84093:         break;
 84093:       case PNK_LB:
 84093:         if (!EmitElemIncDec(cx, pn2, op, bce))
 84093:             return false;
 84093:         break;
 84093:       case PNK_LP:
 84093:         if (!EmitTree(cx, bce, pn2))
 84093:             return false;
 84093:         if (NewSrcNote2(cx, bce, SRC_PCBASE, bce->offset() - pn2->pn_offset) < 0)
 84093:             return false;
 84093:         if (Emit1(cx, bce, op) < 0)
 84093:             return false;
 84093:         /*
 84093:          * This is dead code for the decompiler, don't generate
 84093:          * a decomposed version of the opcode. We do need to balance
 84093:          * the stacks in the decomposed version.
 84093:          */
 84093:         JS_ASSERT(js_CodeSpec[op].format & JOF_DECOMPOSE);
 84093:         JS_ASSERT(js_CodeSpec[op].format & JOF_ELEM);
 84093:         if (Emit1(cx, bce, (JSOp)1) < 0)
 84093:             return false;
 84093:         if (Emit1(cx, bce, JSOP_POP) < 0)
 84093:             return false;
 84093:         break;
 84093: #if JS_HAS_XML_SUPPORT
 84093:       case PNK_XMLUNARY:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 84093:         JS_ASSERT(pn2->isOp(JSOP_SETXMLNAME));
 84093:         if (!EmitTree(cx, bce, pn2->pn_kid))
 84093:             return false;
 84093:         if (Emit1(cx, bce, JSOP_BINDXMLNAME) < 0)
 84093:             return false;
 84093:         if (!EmitElemIncDec(cx, NULL, op, bce))
 84093:             return false;
 84093:         break;
 84093: #endif
 84092:       default:
 84092:         JS_ASSERT(pn2->isKind(PNK_NAME));
 84092:         pn2->setOp(op);
 84092:         if (!BindNameToSlot(cx, bce, pn2))
 84093:             return false;
 84092:         op = pn2->getOp();
 84092:         if (op == JSOP_CALLEE) {
 84092:             if (Emit1(cx, bce, op) < 0)
 84093:                 return false;
 84092:         } else if (!pn2->pn_cookie.isFree()) {
 95101:             if (js_CodeSpec[op].format & (JOF_INC | JOF_DEC)) {
 95101:                 if (!EmitVarIncDec(cx, pn2, op, bce))
 95101:                     return false;
 95101:             } else {
 95101:                 if (!EmitVarOp(cx, pn2, op, bce))
 95101:                     return false;
 95101:             }
 84092:         } else {
 84092:             JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
 84092:             if (js_CodeSpec[op].format & (JOF_INC | JOF_DEC)) {
 84092:                 if (!EmitNameIncDec(cx, pn2, op, bce))
 84093:                     return false;
 84092:             } else {
 84092:                 if (!EmitAtomOp(cx, pn2, op, bce))
 84093:                     return false;
 84092:             }
 84092:             break;
 84092:         }
 84092:         if (pn2->isConst()) {
 84092:             if (Emit1(cx, bce, JSOP_POS) < 0)
 84093:                 return false;
 84092:             op = pn->getOp();
 84092:             if (!(js_CodeSpec[op].format & JOF_POST)) {
 84092:                 if (Emit1(cx, bce, JSOP_ONE) < 0)
 84093:                     return false;
 84092:                 op = (js_CodeSpec[op].format & JOF_INC) ? JSOP_ADD : JSOP_SUB;
 84092:                 if (Emit1(cx, bce, op) < 0)
 84093:                     return false;
 84093:             }
 84093:         }
 84092:     }
 84092:     return true;
 84092: }
 84092: 
 91711: /*
 91711:  * Using MOZ_NEVER_INLINE in here is a workaround for llvm.org/pr12127. See
 91711:  * the comment on EmitSwitch.
 91711:  */
 91711: MOZ_NEVER_INLINE static bool
 84094: EmitLabel(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84094: {
 84094:     /*
 84094:      * Emit a JSOP_LABEL instruction. The argument is the offset to the statement
 84094:      * following the labeled statement. This op has either a SRC_LABEL or
 84094:      * SRC_LABELBRACE source note for the decompiler.
 84094:      */
 84094:     JSAtom *atom = pn->pn_atom;
 84094: 
 84094:     jsatomid index;
 84094:     if (!bce->makeAtomIndex(atom, &index))
 84095:         return false;
 84094: 
 84094:     ParseNode *pn2 = pn->expr();
 84094:     SrcNoteType noteType = (pn2->isKind(PNK_STATEMENTLIST) ||
 84094:                             (pn2->isKind(PNK_LEXICALSCOPE) &&
 84094:                              pn2->expr()->isKind(PNK_STATEMENTLIST)))
 84094:                            ? SRC_LABELBRACE
 84094:                            : SRC_LABEL;
 84094:     ptrdiff_t noteIndex = NewSrcNote2(cx, bce, noteType, ptrdiff_t(index));
 84094:     if (noteIndex < 0)
 84095:         return false;
 84094: 
 84094:     ptrdiff_t top = EmitJump(cx, bce, JSOP_LABEL, 0);
 84094:     if (top < 0)
 84095:         return false;
 84094: 
 84094:     /* Emit code for the labeled statement. */
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_LABEL, bce->offset());
 84094:     stmtInfo.label = atom;
 84094:     if (!EmitTree(cx, bce, pn2))
 84095:         return false;
 84094:     if (!PopStatementBCE(cx, bce))
 84095:         return false;
 84094: 
 84094:     /* Patch the JSOP_LABEL offset. */
 86877:     SetJumpOffsetAt(bce, top);
 84094: 
 84094:     /* If the statement was compound, emit a note for the end brace. */
 84094:     if (noteType == SRC_LABELBRACE) {
 84095:         if (NewSrcNote(cx, bce, SRC_ENDBRACE) < 0 || Emit1(cx, bce, JSOP_NOP) < 0)
 84095:             return false;
 84094:     }
 84094: 
 84094:     return true;
 84094: }
 84094: 
 84096: static bool
 84096: EmitSyntheticStatements(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn, ptrdiff_t top)
 84096: {
 84096:     JS_ASSERT(pn->isArity(PN_LIST));
 95355:     StmtInfo stmtInfo(cx);
 98445:     PushStatement(bce->sc, &stmtInfo, STMT_SEQ, top);
 84096:     for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 84096:         if (!EmitTree(cx, bce, pn2))
 84096:             return false;
 84096:     }
 84096:     return PopStatementBCE(cx, bce);
 84096: }
 84096: 
 84097: static bool
 86379: EmitConditionalExpression(JSContext *cx, BytecodeEmitter *bce, ConditionalExpression &conditional)
 84097: {
 84097:     /* Emit the condition, then branch if false to the else part. */
 86379:     if (!EmitTree(cx, bce, &conditional.condition()))
 84098:         return false;
 84097:     ptrdiff_t noteIndex = NewSrcNote(cx, bce, SRC_COND);
 84097:     if (noteIndex < 0)
 84098:         return false;
 84097:     ptrdiff_t beq = EmitJump(cx, bce, JSOP_IFEQ, 0);
 86379:     if (beq < 0 || !EmitTree(cx, bce, &conditional.thenExpression()))
 84098:         return false;
 84097: 
 84097:     /* Jump around else, fixup the branch, emit else, fixup jump. */
 84097:     ptrdiff_t jmp = EmitJump(cx, bce, JSOP_GOTO, 0);
 84097:     if (jmp < 0)
 84098:         return false;
 86877:     SetJumpOffsetAt(bce, beq);
 84097: 
 84097:     /*
 84097:      * Because each branch pushes a single value, but our stack budgeting
 84097:      * analysis ignores branches, we now have to adjust bce->stackDepth to
 84097:      * ignore the value pushed by the first branch.  Execution will follow
 84097:      * only one path, so we must decrement bce->stackDepth.
 84097:      *
 84098:      * Failing to do this will foil code, such as let expression and block
 84098:      * code generation, which must use the stack depth to compute local
 84098:      * stack indexes correctly.
 84097:      */
 84097:     JS_ASSERT(bce->stackDepth > 0);
 84097:     bce->stackDepth--;
 86379:     if (!EmitTree(cx, bce, &conditional.elseExpression()))
 84098:         return false;
 86877:     SetJumpOffsetAt(bce, jmp);
 84098:     return SetSrcNoteOffset(cx, bce, noteIndex, 0, jmp - beq);
 84097: }
 84097: 
 84099: static bool
 88137: EmitObject(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84099: {
 84099: #if JS_HAS_DESTRUCTURING_SHORTHAND
 84099:     if (pn->pn_xflags & PNX_DESTRUCT) {
 84099:         ReportCompileErrorNumber(cx, bce->tokenStream(), pn, JSREPORT_ERROR,
 84099:                                  JSMSG_BAD_OBJECT_INIT);
 84100:         return false;
 84099:     }
 84099: #endif
 84099: 
 88137:     if (!(pn->pn_xflags & PNX_NONCONST) && pn->pn_head && bce->checkSingletonContext())
 84100:         return EmitSingletonInitialiser(cx, bce, pn);
 84099: 
 84099:     /*
 84099:      * Emit code for {p:a, '%q':b, 2:c} that is equivalent to constructing
 84099:      * a new object and in source order evaluating each property value and
 84099:      * adding the property to the object, without invoking latent setters.
 84099:      * We use the JSOP_NEWINIT and JSOP_INITELEM/JSOP_INITPROP bytecodes to
 84099:      * ignore setters and to avoid dup'ing and popping the object as each
 84099:      * property is added, as JSOP_SETELEM/JSOP_SETPROP would do.
 84099:      */
 84099:     ptrdiff_t offset = bce->next() - bce->base();
 88137:     if (!EmitNewInit(cx, bce, JSProto_Object, pn))
 84100:         return false;
 84099: 
 84099:     /*
 84099:      * Try to construct the shape of the object as we go, so we can emit a
 84099:      * JSOP_NEWOBJECT with the final shape instead.
 84099:      */
 99421:     RootedObject obj(cx);
 98464:     if (bce->parser->compileAndGo) {
 84099:         gc::AllocKind kind = GuessObjectGCKind(pn->pn_count);
 84099:         obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
 84099:         if (!obj)
 84100:             return false;
 84099:     }
 84099: 
 84099:     for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 84099:         /* Emit an index for t[2] for later consumption by JSOP_INITELEM. */
 84099:         ParseNode *pn3 = pn2->pn_left;
 84099:         if (pn3->isKind(PNK_NUMBER)) {
 84099:             if (!EmitNumberOp(cx, pn3->pn_dval, bce))
 84100:                 return false;
 84099:         }
 84099: 
 84099:         /* Emit code for the property initializer. */
 84099:         if (!EmitTree(cx, bce, pn2->pn_right))
 84100:             return false;
 84099: 
 84099:         JSOp op = pn2->getOp();
 84099:         if (op == JSOP_GETTER || op == JSOP_SETTER) {
 84099:             obj = NULL;
 84099:             if (Emit1(cx, bce, op) < 0)
 84100:                 return false;
 84099:         }
 84099: 
 84099:         /* Annotate JSOP_INITELEM so we decompile 2:c and not just c. */
 84099:         if (pn3->isKind(PNK_NUMBER)) {
 84099:             obj = NULL;
 84099:             if (NewSrcNote(cx, bce, SRC_INITPROP) < 0)
 84100:                 return false;
 84099:             if (Emit1(cx, bce, JSOP_INITELEM) < 0)
 84100:                 return false;
 84099:         } else {
 84099:             JS_ASSERT(pn3->isKind(PNK_NAME) || pn3->isKind(PNK_STRING));
 84099:             jsatomid index;
 84099:             if (!bce->makeAtomIndex(pn3->pn_atom, &index))
 84100:                 return false;
 84099: 
 84099:             /*
 84099:              * Disable NEWOBJECT on initializers that set __proto__, which has
 84099:              * a non-standard setter on objects.
 84099:              */
 84099:             if (pn3->pn_atom == cx->runtime->atomState.protoAtom)
 84099:                 obj = NULL;
 84099:             op = JSOP_INITPROP;
 84099: 
 84099:             if (obj) {
 84099:                 JS_ASSERT(!obj->inDictionaryMode());
 99421:                 if (!DefineNativeProperty(cx, obj, RootedId(cx, AtomToId(pn3->pn_atom)),
 84099:                                           UndefinedValue(), NULL, NULL,
 84100:                                           JSPROP_ENUMERATE, 0, 0))
 84100:                 {
 84099:                     return false;
 84099:                 }
 84099:                 if (obj->inDictionaryMode())
 84099:                     obj = NULL;
 84099:             }
 84099: 
 90965:             if (!EmitIndex32(cx, op, index, bce))
 90965:                 return false;
 84099:         }
 84099:     }
 84099: 
 88137:     if (Emit1(cx, bce, JSOP_ENDINIT) < 0)
 84100:         return false;
 84099: 
 84099:     if (obj) {
 84099:         /*
 90965:          * The object survived and has a predictable shape: update the original
 90965:          * bytecode.
 84099:          */
 84099:         ObjectBox *objbox = bce->parser->newObjectBox(obj);
 84099:         if (!objbox)
 84100:             return false;
100006:         unsigned index = bce->objectList.index(objbox);
 89253:         MOZ_STATIC_ASSERT(JSOP_NEWINIT_LENGTH == JSOP_NEWOBJECT_LENGTH,
 89253:                           "newinit and newobject must have equal length to edit in-place");
 89253:         EMIT_UINT32_IN_PLACE(offset, JSOP_NEWOBJECT, uint32_t(index));
 89253:     }
 84099: 
 84099:     return true;
 84099: }
 84099: 
 84101: static bool
 88137: EmitArray(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84101: {
 84101:     /*
 84101:      * Emit code for [a, b, c] that is equivalent to constructing a new
 84101:      * array and in source order evaluating each element value and adding
 84101:      * it to the array, without invoking latent setters.  We use the
 84101:      * JSOP_NEWINIT and JSOP_INITELEM bytecodes to ignore setters and to
 84101:      * avoid dup'ing and popping the array as each element is added, as
 84101:      * JSOP_SETELEM/JSOP_SETPROP would do.
 84101:      */
 84101: 
 84101: #if JS_HAS_GENERATORS
 84101:     if (pn->isKind(PNK_ARRAYCOMP)) {
 88137:         if (!EmitNewInit(cx, bce, JSProto_Array, pn))
 84102:             return false;
 84101: 
 84101:         /*
 84101:          * Pass the new array's stack index to the PNK_ARRAYPUSH case via
 84101:          * bce->arrayCompDepth, then simply traverse the PNK_FOR node and
 84101:          * its kids under pn2 to generate this comprehension.
 84101:          */
 84101:         JS_ASSERT(bce->stackDepth > 0);
 91237:         unsigned saveDepth = bce->arrayCompDepth;
 84755:         bce->arrayCompDepth = (uint32_t) (bce->stackDepth - 1);
 84101:         if (!EmitTree(cx, bce, pn->pn_head))
 84102:             return false;
 84101:         bce->arrayCompDepth = saveDepth;
 84101: 
 84101:         /* Emit the usual op needed for decompilation. */
 88137:         return Emit1(cx, bce, JSOP_ENDINIT) >= 0;
 84101:     }
 84101: #endif /* JS_HAS_GENERATORS */
 84101: 
 88137:     if (!(pn->pn_xflags & PNX_NONCONST) && pn->pn_head && bce->checkSingletonContext())
 84102:         return EmitSingletonInitialiser(cx, bce, pn);
 88137: 
 84101:     ptrdiff_t off = EmitN(cx, bce, JSOP_NEWARRAY, 3);
 84101:     if (off < 0)
 84102:         return false;
 86704:     CheckTypeSet(cx, bce, JSOP_NEWARRAY);
 84101:     jsbytecode *pc = bce->code(off);
 84101:     SET_UINT24(pc, pn->pn_count);
 84101: 
 84101:     ParseNode *pn2 = pn->pn_head;
 84101:     jsatomid atomIndex;
 84101:     for (atomIndex = 0; pn2; atomIndex++, pn2 = pn2->pn_next) {
 84101:         if (!EmitNumberOp(cx, atomIndex, bce))
 84102:             return false;
 84101:         if (pn2->isKind(PNK_COMMA) && pn2->isArity(PN_NULLARY)) {
 84101:             if (Emit1(cx, bce, JSOP_HOLE) < 0)
 84102:                 return false;
 84101:         } else {
 84101:             if (!EmitTree(cx, bce, pn2))
 84102:                 return false;
 84101:         }
 84101:         if (Emit1(cx, bce, JSOP_INITELEM) < 0)
 84102:             return false;
 84101:     }
 84101:     JS_ASSERT(atomIndex == pn->pn_count);
 84101: 
 84101:     if (pn->pn_xflags & PNX_ENDCOMMA) {
 84101:         /* Emit a source note so we know to decompile an extra comma. */
 84101:         if (NewSrcNote(cx, bce, SRC_CONTINUE) < 0)
 84102:             return false;
 84101:     }
 84101: 
 88137:     /* Emit an op to finish the array and aid in decompilation. */
 88137:     return Emit1(cx, bce, JSOP_ENDINIT) >= 0;
 84101: }
 84101: 
 84103: static bool
 84103: EmitUnary(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84103: {
 84103:     /* Unary op, including unary +/-. */
 84103:     JSOp op = pn->getOp();
 84103:     ParseNode *pn2 = pn->pn_kid;
 84103: 
 84103:     JS_ASSERT(op != JSOP_XMLNAME);
 84103:     if (op == JSOP_TYPEOF && !pn2->isKind(PNK_NAME))
 84103:         op = JSOP_TYPEOFEXPR;
 84103: 
 98477:     bool oldInForInit = bce->sc->inForInit;
 98477:     bce->sc->inForInit = false;
 84103:     if (!EmitTree(cx, bce, pn2))
 84104:         return false;
 84104: 
 98477:     bce->sc->inForInit = oldInForInit;
 84104:     return Emit1(cx, bce, op) >= 0;
 84103: }
 84103: 
 99552: static bool
 99552: EmitDefaults(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 99552: {
 99552:     JS_ASSERT(pn->isKind(PNK_ARGSBODY));
 99552:     ParseNode *pnlast = pn->last();
 99552:     unsigned ndefaults = 0;
 99552:     for (ParseNode *arg = pn->pn_head; arg != pnlast; arg = arg->pn_next) {
 99552:         if (arg->pn_expr)
 99552:             ndefaults++;
 99552:     }
 99552:     JSFunction *fun = bce->sc->fun();
 99552:     unsigned nformal = fun->nargs - fun->hasRest();
 99552:     EMIT_UINT16_IMM_OP(JSOP_ACTUALSFILLED, nformal - ndefaults);
 99552:     ptrdiff_t top = bce->offset();
 99552:     size_t tableSize = (size_t)(JUMP_OFFSET_LEN * (3 + ndefaults));
 99552:     if (EmitN(cx, bce, JSOP_TABLESWITCH, tableSize) < 0)
 99552:         return false;
 99552:     jsbytecode *pc = bce->code(top + JUMP_OFFSET_LEN);
 99552:     JS_ASSERT(nformal >= ndefaults);
 99552:     SET_JUMP_OFFSET(pc, nformal - ndefaults);
 99552:     pc += JUMP_OFFSET_LEN;
 99552:     SET_JUMP_OFFSET(pc, nformal - 1);
 99552:     pc += JUMP_OFFSET_LEN;
 99552: 
 99552:     // Fill body of switch, which sets defaults where needed.
 99552:     for (ParseNode *arg = pn->pn_head; arg != pnlast; arg = arg->pn_next) {
 99552:         if (!arg->pn_expr)
 99552:             continue;
 99552:         SET_JUMP_OFFSET(pc, bce->offset() - top);
 99552:         pc += JUMP_OFFSET_LEN;
 99552:         if (!EmitTree(cx, bce, arg->pn_expr))
 99552:             return false;
 99552:         if (!BindNameToSlot(cx, bce, arg))
 99552:             return false;
 99552:         if (!EmitVarOp(cx, arg, JSOP_SETARG, bce))
 99552:             return false;
 99552:         if (Emit1(cx, bce, JSOP_POP) < 0)
 99552:             return false;
 99552:     }
 99552:     JS_ASSERT(pc == bce->code(top + tableSize));
 99552:     SET_JUMP_OFFSET(bce->code(top), bce->offset() - top);
 99552:     return true;
 99552: }
 99552: 
 84076: JSBool
 84076: frontend::EmitTree(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn)
 84076: {
 86078:     JS_CHECK_RECURSION(cx, return JS_FALSE);
 86078: 
 84076:     EmitLevelManager elm(bce);
 84076: 
 84076:     JSBool ok = true;
 86078:     ptrdiff_t top = bce->offset();
 86078:     pn->pn_offset = top;
 84076: 
 84076:     /* Emit notes to tell the current bytecode's source line number. */
 84076:     UPDATE_LINE_NUMBER_NOTES(cx, bce, pn->pn_pos.begin.lineno);
 84076: 
 84076:     switch (pn->getKind()) {
 84076:       case PNK_FUNCTION:
 84076:         ok = EmitFunc(cx, bce, pn);
 84076:         break;
 84076: 
 84076:       case PNK_ARGSBODY:
 84076:       {
 99552:         JSFunction *fun = bce->sc->fun();
 84076:         ParseNode *pnlast = pn->last();
 99552:         if (fun->hasDefaults()) {
 99552:             if (pnlast->pn_xflags & PNX_DESTRUCT) {
 99552:                 JS_ASSERT(pnlast->pn_head->isKind(PNK_SEMI));
 99552: 
 99552:                 // Defaults must be able to access destructured arguments, so do
 99552:                 // that now.
 99552:                 if (!EmitTree(cx, bce, pnlast->pn_head))
 99552:                     return false;
 99552:             }
 99552: 
 99552:             ParseNode *rest = NULL;
 99552:             if (fun->hasRest()) {
 99552:                 JS_ASSERT(!bce->sc->funArgumentsHasLocalBinding());
 99552: 
 99552:                 // Defaults and rest also need special handling. The rest
 99552:                 // parameter needs to be undefined while defaults are being
 99552:                 // processed. To do this, we create the rest argument and let it
 99552:                 // sit on the stack while processing defaults. The rest
 99552:                 // parameter's slot is set to undefined for the course of
 99552:                 // default processing.
 99552:                 rest = pn->pn_head;
 99552:                 while (rest->pn_next != pnlast)
 99552:                     rest = rest->pn_next;
 99552:                 if (Emit1(cx, bce, JSOP_REST) < 0)
 99552:                     return false;
 99552:                 CheckTypeSet(cx, bce, JSOP_REST);
 99552:                 if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 99552:                     return false;
 99552:                 if (!EmitVarOp(cx, rest, JSOP_SETARG, bce))
 99552:                     return false;
 99552:                 if (Emit1(cx, bce, JSOP_POP) < 0)
 99552:                     return false;
 99552:             }
 99552:             if (!EmitDefaults(cx, bce, pn))
 99552:                 return false;
 99552:             if (fun->hasRest()) {
 99552:                 if (!EmitVarOp(cx, rest, JSOP_SETARG, bce))
 99552:                     return false;
 99552:                 if (Emit1(cx, bce, JSOP_POP) < 0)
 99552:                     return false;
 99552:             }
 99552:         }
 84076:         for (ParseNode *pn2 = pn->pn_head; pn2 != pnlast; pn2 = pn2->pn_next) {
 84076:             if (!pn2->isDefn())
 84076:                 continue;
 84076:             if (!BindNameToSlot(cx, bce, pn2))
 84076:                 return JS_FALSE;
 84076:             if (JOF_OPTYPE(pn2->getOp()) == JOF_QARG && bce->shouldNoteClosedName(pn2)) {
 95098:                 if (!bce->noteClosedArg(pn2))
 84076:                     return JS_FALSE;
 84076:             }
 99552:             if (pn2->pn_next == pnlast && fun->hasRest() && !fun->hasDefaults()) {
 99552: 
 99552:                 // Fill rest parameter. We handled the case with defaults above.
 99225:                 JS_ASSERT(!bce->sc->funArgumentsHasLocalBinding());
 99225:                 bce->switchToProlog();
 99225:                 if (Emit1(cx, bce, JSOP_REST) < 0)
 99225:                     return false;
 99225:                 CheckTypeSet(cx, bce, JSOP_REST);
 99225:                 if (!EmitVarOp(cx, pn2, JSOP_SETARG, bce))
 99225:                     return false;
 99225:                 if (Emit1(cx, bce, JSOP_POP) < 0)
 99225:                     return false;
 99225:                 bce->switchToMain();
 99225:             }
 84076:         }
 84076:         ok = EmitTree(cx, bce, pnlast);
 84076:         break;
 84076:       }
 84076: 
 84076:       case PNK_UPVARS:
 84076:         JS_ASSERT(pn->pn_names->count() != 0);
 84076:         ok = EmitTree(cx, bce, pn->pn_tree);
 84076:         pn->pn_names.releaseMap(cx);
 84076:         break;
 84076: 
 84076:       case PNK_IF:
 84076:         ok = EmitIf(cx, bce, pn);
 84076:         break;
 84076: 
 84076:       case PNK_SWITCH:
 84076:         ok = EmitSwitch(cx, bce, pn);
 84076:         break;
 84076: 
 84076:       case PNK_WHILE:
 84076:         ok = EmitWhile(cx, bce, pn, top);
 84071:         break;
 84071: 
 84071:       case PNK_DOWHILE:
 84074:         ok = EmitDo(cx, bce, pn);
 84071:         break;
 84071: 
 84071:       case PNK_FOR:
 84071:         ok = EmitFor(cx, bce, pn, top);
 84071:         break;
 84071: 
 84078:       case PNK_BREAK:
 84666:         ok = EmitBreak(cx, bce, pn->asBreakStatement().label());
 84078:         break;
 84071: 
 84080:       case PNK_CONTINUE:
 84666:         ok = EmitContinue(cx, bce, pn->asContinueStatement().label());
 84080:         break;
 84071: 
 84071:       case PNK_WITH:
 84071:         ok = EmitWith(cx, bce, pn);
 84071:         break;
 84071: 
 84071:       case PNK_TRY:
 84071:         if (!EmitTry(cx, bce, pn))
 84071:             return false;
 84071:         break;
 84071: 
 84071:       case PNK_CATCH:
 84071:         if (!EmitCatch(cx, bce, pn))
 84071:             return false;
 84071:         break;
 84071: 
 84071:       case PNK_VAR:
 84071:       case PNK_CONST:
 86078:         if (!EmitVariables(cx, bce, pn, InitializeVars))
 84071:             return JS_FALSE;
 84071:         break;
 84071: 
 84071:       case PNK_RETURN:
 84082:         ok = EmitReturn(cx, bce, pn);
 84071:         break;
 84071: 
 84071: #if JS_HAS_GENERATORS
 84071:       case PNK_YIELD:
 98476:         JS_ASSERT(bce->sc->inFunction);
 84071:         if (pn->pn_kid) {
 84071:             if (!EmitTree(cx, bce, pn->pn_kid))
 84071:                 return JS_FALSE;
 84071:         } else {
 84493:             if (Emit1(cx, bce, JSOP_UNDEFINED) < 0)
 84071:                 return JS_FALSE;
 84071:         }
 84071:         if (pn->pn_hidden && NewSrcNote(cx, bce, SRC_HIDDEN) < 0)
 84071:             return JS_FALSE;
 84071:         if (Emit1(cx, bce, JSOP_YIELD) < 0)
 84071:             return JS_FALSE;
 84071:         break;
 84071: #endif
 84071: 
 84071: #if JS_HAS_XML_SUPPORT
 84071:       case PNK_XMLCURLYEXPR:
 84071:         JS_ASSERT(pn->isArity(PN_UNARY));
 84071:         if (!EmitTree(cx, bce, pn->pn_kid))
 84071:             return JS_FALSE;
 84071:         if (Emit1(cx, bce, pn->getOp()) < 0)
 84071:             return JS_FALSE;
 84071:         break;
 84071: #endif
 84071: 
 84071:       case PNK_STATEMENTLIST:
 84084:         ok = EmitStatementList(cx, bce, pn, top);
 84084:         break;
 84071: 
 84071:       case PNK_SEQ:
 84096:         ok = EmitSyntheticStatements(cx, bce, pn, top);
 84071:         break;
 84071: 
 84071:       case PNK_SEMI:
 84084:         ok = EmitStatement(cx, bce, pn);
 84071:         break;
 84071: 
 84071:       case PNK_COLON:
 84094:         ok = EmitLabel(cx, bce, pn);
     1:         break;
     1: 
 82024:       case PNK_COMMA:
 86078:       {
     1:         /*
     1:          * Emit SRC_PCDELTA notes on each JSOP_POP between comma operands.
     1:          * These notes help the decompiler bracket the bytecodes generated
     1:          * from each sub-expression that follows a comma.
     1:          */
 86078:         ptrdiff_t off = -1, noteIndex = -1;
 86078:         for (ParseNode *pn2 = pn->pn_head; ; pn2 = pn2->pn_next) {
 80966:             if (!EmitTree(cx, bce, pn2))
 80966:                 return JS_FALSE;
 86078:             ptrdiff_t tmp = bce->offset();
     1:             if (noteIndex >= 0) {
 91237:                 if (!SetSrcNoteOffset(cx, bce, (unsigned)noteIndex, 0, tmp-off))
     1:                     return JS_FALSE;
     1:             }
     1:             if (!pn2->pn_next)
     1:                 break;
     1:             off = tmp;
 80966:             noteIndex = NewSrcNote2(cx, bce, SRC_PCDELTA, 0);
     1:             if (noteIndex < 0 ||
 80966:                 Emit1(cx, bce, JSOP_POP) < 0) {
     1:                 return JS_FALSE;
     1:             }
     1:         }
     1:         break;
 86078:       }
     1: 
 82024:       case PNK_ASSIGN:
 82024:       case PNK_ADDASSIGN:
 82024:       case PNK_SUBASSIGN:
 82024:       case PNK_BITORASSIGN:
 82024:       case PNK_BITXORASSIGN:
 82024:       case PNK_BITANDASSIGN:
 82024:       case PNK_LSHASSIGN:
 82024:       case PNK_RSHASSIGN:
 82024:       case PNK_URSHASSIGN:
 82024:       case PNK_MULASSIGN:
 82024:       case PNK_DIVASSIGN:
 82024:       case PNK_MODASSIGN:
 80966:         if (!EmitAssignment(cx, bce, pn->pn_left, pn->getOp(), pn->pn_right))
 74052:             return false;
     1:         break;
     1: 
 86379:       case PNK_CONDITIONAL:
 86379:         ok = EmitConditionalExpression(cx, bce, pn->asConditionalExpression());
     1:         break;
     1: 
 82024:       case PNK_OR:
 82024:       case PNK_AND:
 84090:         ok = EmitLogical(cx, bce, pn);
     1:         break;
     1: 
 82870:       case PNK_ADD:
 82870:       case PNK_SUB:
 82024:       case PNK_BITOR:
 82024:       case PNK_BITXOR:
 82024:       case PNK_BITAND:
 82024:       case PNK_STRICTEQ:
 82024:       case PNK_EQ:
 82024:       case PNK_STRICTNE:
 82024:       case PNK_NE:
 82024:       case PNK_LT:
 82024:       case PNK_LE:
 82024:       case PNK_GT:
 82024:       case PNK_GE:
 82024:       case PNK_IN:
 82024:       case PNK_INSTANCEOF:
 82024:       case PNK_LSH:
 82024:       case PNK_RSH:
 82024:       case PNK_URSH:
 82024:       case PNK_STAR:
 82024:       case PNK_DIV:
 82024:       case PNK_MOD:
 78294:         if (pn->isArity(PN_LIST)) {
     1:             /* Left-associative operator chain: avoid too much recursion. */
 86078:             ParseNode *pn2 = pn->pn_head;
 80966:             if (!EmitTree(cx, bce, pn2))
     1:                 return JS_FALSE;
 86078:             JSOp op = pn->getOp();
     1:             while ((pn2 = pn2->pn_next) != NULL) {
 80966:                 if (!EmitTree(cx, bce, pn2))
 80966:                     return JS_FALSE;
 80966:                 if (Emit1(cx, bce, op) < 0)
     1:                     return JS_FALSE;
     1:             }
     1:         } else {
     1: #if JS_HAS_XML_SUPPORT
     1: 
 82024:       case PNK_DBLCOLON:
 82114:             JS_ASSERT(pn->getOp() != JSOP_XMLNAME);
 78294:             if (pn->isArity(PN_NAME)) {
 80966:                 if (!EmitTree(cx, bce, pn->expr()))
 80966:                     return JS_FALSE;
 80966:                 if (!EmitAtomOp(cx, pn, pn->getOp(), bce))
     1:                     return JS_FALSE;
     1:                 break;
     1:             }
     1: 
     1:             /*
     1:              * Binary :: has a right operand that brackets arbitrary code,
     1:              * possibly including a let (a = b) ... expression.  We must clear
 98477:              * inForInit to avoid mis-compiling such beasts.
 98477:              */
 98477:             bool oldInForInit = bce->sc->inForInit;
 98477:             bce->sc->inForInit = false;
     1: #endif
     1: 
     1:             /* Binary operators that evaluate both operands unconditionally. */
 80966:             if (!EmitTree(cx, bce, pn->pn_left))
 80966:                 return JS_FALSE;
 80966:             if (!EmitTree(cx, bce, pn->pn_right))
     1:                 return JS_FALSE;
     1: #if JS_HAS_XML_SUPPORT
 98477:             bce->sc->inForInit = oldInForInit;
     1: #endif
 80966:             if (Emit1(cx, bce, pn->getOp()) < 0)
     1:                 return JS_FALSE;
     1:         }
     1:         break;
     1: 
 82114: #if JS_HAS_XML_SUPPORT
 82114:       case PNK_XMLUNARY:
 82114:         if (pn->getOp() == JSOP_XMLNAME) {
 82114:             if (!EmitXMLName(cx, pn, JSOP_XMLNAME, bce))
 82114:                 return false;
 82114:         } else {
 82114:             JSOp op = pn->getOp();
 82114:             JS_ASSERT(op == JSOP_BINDXMLNAME || op == JSOP_SETXMLNAME);
 98477:             bool oldInForInit = bce->sc->inForInit;
 98477:             bce->sc->inForInit = false;
 82114:             if (!EmitTree(cx, bce, pn->pn_kid))
 82114:                 return false;
 98477:             bce->sc->inForInit = oldInForInit;
 82114:             if (Emit1(cx, bce, op) < 0)
 82114:                 return false;
 82114:         }
 82114:         break;
 82114: #endif
 82114: 
 82024:       case PNK_THROW:
     1: #if JS_HAS_XML_SUPPORT
 82024:       case PNK_AT:
 82869:       case PNK_DEFXMLNS:
 78294:         JS_ASSERT(pn->isArity(PN_UNARY));
     1:         /* FALL THROUGH */
     1: #endif
 82024:       case PNK_TYPEOF:
 82024:       case PNK_VOID:
 82024:       case PNK_NOT:
 82024:       case PNK_BITNOT:
 82870:       case PNK_POS:
 82870:       case PNK_NEG:
 84103:         ok = EmitUnary(cx, bce, pn);
 84103:         break;
     1: 
 86266:       case PNK_PREINCREMENT:
 86266:       case PNK_PREDECREMENT:
 86266:       case PNK_POSTINCREMENT:
 86266:       case PNK_POSTDECREMENT:
 84092:         ok = EmitIncOrDec(cx, bce, pn);
     1:         break;
     1: 
 82024:       case PNK_DELETE:
 84086:         ok = EmitDelete(cx, bce, pn);
     1:         break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
 82024:       case PNK_FILTER:
 86078:       {
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 80966: 
 80966:         if (!EmitTree(cx, bce, pn->pn_left))
 80966:             return JS_FALSE;
 86078:         ptrdiff_t jmp = EmitJump(cx, bce, JSOP_FILTER, 0);
     1:         if (jmp < 0)
     1:             return JS_FALSE;
 87961:         top = EmitLoopHead(cx, bce, pn->pn_right);
 34286:         if (top < 0)
 25627:             return JS_FALSE;
 80966:         if (!EmitTree(cx, bce, pn->pn_right))
 80966:             return JS_FALSE;
 86877:         SetJumpOffsetAt(bce, jmp);
 87961:         if (!EmitLoopEntry(cx, bce, NULL))
 87961:             return false;
 80966:         if (EmitJump(cx, bce, JSOP_ENDFILTER, top - bce->offset()) < 0)
 11672:             return JS_FALSE;
     1:         break;
 86078:       }
     1: #endif
     1: 
 82024:       case PNK_DOT:
     1:         /*
     1:          * Pop a stack operand, convert it to object, get a property named by
     1:          * this bytecode's immediate-indexed atom operand, and push its value
     1:          * (not a reference to it).
     1:          */
 80966:         ok = EmitPropOp(cx, pn, pn->getOp(), bce, JS_FALSE);
     1:         break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
 82024:       case PNK_DBLDOT:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 80780:         /* FALL THROUGH */
     1: #endif
 82024:       case PNK_LB:
     1:         /*
     1:          * Pop two operands, convert the left one to object and the right one
     1:          * to property name (atom or tagged int), get the named property, and
     1:          * push its value.  Set the "obj" register to the result of ToObject
     1:          * on the left operand.
     1:          */
 80966:         ok = EmitElemOp(cx, pn, pn->getOp(), bce);
     1:         break;
     1: 
 82024:       case PNK_NEW:
 82024:       case PNK_LP:
 84088:         ok = EmitCallOrNew(cx, bce, pn, top);
 84088:         break;
     1: 
 82024:       case PNK_LEXICALSCOPE:
 81588:         ok = EmitLexicalScope(cx, bce, pn);
 79378:         break;
     1: 
     1: #if JS_HAS_BLOCK_SCOPE
 82024:       case PNK_LET:
 86078:         ok = pn->isArity(PN_BINARY)
 86078:              ? EmitLet(cx, bce, pn)
 86078:              : EmitVariables(cx, bce, pn, InitializeVars);
 79378:         break;
     1: #endif /* JS_HAS_BLOCK_SCOPE */
     1: #if JS_HAS_GENERATORS
 82024:       case PNK_ARRAYPUSH: {
 91450:         int slot;
 16072: 
 16072:         /*
 80966:          * The array object's stack index is in bce->arrayCompDepth. See below
     1:          * under the array initialiser code generator for array comprehension
 95101:          * special casing. Note that the array object is a pure stack value,
 95101:          * unaliased by blocks, so we can EmitUnaliasedVarOp.
     1:          */
 80966:         if (!EmitTree(cx, bce, pn->pn_kid))
 80966:             return JS_FALSE;
 80966:         slot = AdjustBlockSlot(cx, bce, bce->arrayCompDepth);
 16072:         if (slot < 0)
 16072:             return JS_FALSE;
 95101:         if (!EmitUnaliasedVarOp(cx, pn->getOp(), slot, bce))
 95101:             return false;
 16072:         break;
 16072:       }
     1: #endif
     1: 
 82024:       case PNK_RB:
     1: #if JS_HAS_GENERATORS
 82024:       case PNK_ARRAYCOMP:
     1: #endif
 88137:         ok = EmitArray(cx, bce, pn);
 84071:         break;
 84071: 
 84099:       case PNK_RC:
 88137:         ok = EmitObject(cx, bce, pn);
 84099:         break;
     1: 
 82024:       case PNK_NAME:
 27012:         /*
 27012:          * Cope with a left-over function definition that was replaced by a use
 27012:          * of a later function definition of the same name. See FunctionDef and
 80634:          * MakeDefIntoUse in Parser.cpp.
 27012:          */
 78294:         if (pn->isOp(JSOP_NOP))
 55512:             break;
 80966:         if (!EmitNameOp(cx, bce, pn, JS_FALSE))
     1:             return JS_FALSE;
     1:         break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
 82024:       case PNK_XMLATTR:
 82024:       case PNK_XMLSPACE:
 82024:       case PNK_XMLTEXT:
 82024:       case PNK_XMLCDATA:
 82024:       case PNK_XMLCOMMENT:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 80780:         /* FALL THROUGH */
     1: #endif
 82024:       case PNK_STRING:
 80966:         ok = EmitAtomOp(cx, pn, pn->getOp(), bce);
     1:         break;
     1: 
 82024:       case PNK_NUMBER:
 80966:         ok = EmitNumberOp(cx, pn->pn_dval, bce);
     1:         break;
     1: 
 82024:       case PNK_REGEXP:
 78294:         JS_ASSERT(pn->isOp(JSOP_REGEXP));
100006:         ok = EmitRegExp(cx, bce->regexpList.index(pn->pn_objbox), bce);
 79378:         break;
  3235: 
     1: #if JS_HAS_XML_SUPPORT
 82024:       case PNK_ANYNAME:
     1: #endif
 82024:       case PNK_TRUE:
 82024:       case PNK_FALSE:
 82024:       case PNK_THIS:
 82024:       case PNK_NULL:
 80966:         if (Emit1(cx, bce, pn->getOp()) < 0)
     1:             return JS_FALSE;
     1:         break;
     1: 
 82024:       case PNK_DEBUGGER:
 80966:         if (Emit1(cx, bce, JSOP_DEBUGGER) < 0)
     1:             return JS_FALSE;
     1:         break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
 82024:       case PNK_XMLELEM:
 82024:       case PNK_XMLLIST:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 82024:         JS_ASSERT(pn->isKind(PNK_XMLLIST) || pn->pn_count != 0);
 82024: 
 82024:         switch (pn->pn_head ? pn->pn_head->getKind() : PNK_XMLLIST) {
 82024:           case PNK_XMLETAGO:
     1:             JS_ASSERT(0);
     1:             /* FALL THROUGH */
 82024:           case PNK_XMLPTAGC:
 82024:           case PNK_XMLSTAGO:
     1:             break;
     1:           default:
 80966:             if (Emit1(cx, bce, JSOP_STARTXML) < 0)
     1:                 return JS_FALSE;
     1:         }
     1: 
 86078:         for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 82873:             if (pn2->isKind(PNK_XMLCURLYEXPR) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
 82024:                 return JS_FALSE;
 80966:             if (!EmitTree(cx, bce, pn2))
 80966:                 return JS_FALSE;
 80966:             if (pn2 != pn->pn_head && Emit1(cx, bce, JSOP_ADD) < 0)
     1:                 return JS_FALSE;
     1:         }
     1: 
 27012:         if (pn->pn_xflags & PNX_XMLROOT) {
     1:             if (pn->pn_count == 0) {
 82024:                 JS_ASSERT(pn->isKind(PNK_XMLLIST));
 86078:                 JSAtom *atom = cx->runtime->atomState.emptyAtom;
 72579:                 jsatomid index;
 80966:                 if (!bce->makeAtomIndex(atom, &index))
 72579:                     return JS_FALSE;
 90965:                 if (!EmitIndex32(cx, JSOP_STRING, index, bce))
 90965:                     return false;
     1:             }
 80966:             if (Emit1(cx, bce, pn->getOp()) < 0)
     1:                 return JS_FALSE;
     1:         }
     1: #ifdef DEBUG
     1:         else
     1:             JS_ASSERT(pn->pn_count != 0);
     1: #endif
     1:         break;
     1: 
 82024:       case PNK_XMLPTAGC:
 82024:       case PNK_XMLSTAGO:
 82024:       case PNK_XMLETAGO:
 80966:         if (!EmitXMLTag(cx, bce, pn))
 79378:             return false;
 79378:         break;
     1: 
 82024:       case PNK_XMLNAME:
 98445:         JS_ASSERT(!bce->sc->inStrictMode());
 80780: 
 78294:         if (pn->isArity(PN_LIST)) {
     1:             JS_ASSERT(pn->pn_count != 0);
 86078:             for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
 82873:                 if (pn2->isKind(PNK_XMLCURLYEXPR) && Emit1(cx, bce, JSOP_STARTXMLEXPR) < 0)
 82024:                     return JS_FALSE;
 80966:                 if (!EmitTree(cx, bce, pn2))
 80966:                     return JS_FALSE;
 80966:                 if (pn2 != pn->pn_head && Emit1(cx, bce, JSOP_ADD) < 0)
     1:                     return JS_FALSE;
     1:             }
     1:         } else {
 78294:             JS_ASSERT(pn->isArity(PN_NULLARY));
 78294:             ok = pn->isOp(JSOP_OBJECT)
 80966:                  ? EmitObjectOp(cx, pn->pn_objbox, pn->getOp(), bce)
 80966:                  : EmitAtomOp(cx, pn, pn->getOp(), bce);
     1:         }
     1:         break;
     1: 
 82024:       case PNK_XMLPI:
 86378:         if (!EmitXMLProcessingInstruction(cx, bce, pn->asXMLProcessingInstruction()))
 79378:             return false;
 79378:         break;
     1: #endif /* JS_HAS_XML_SUPPORT */
     1: 
     1:       default:
     1:         JS_ASSERT(0);
     1:     }
     1: 
 80966:     /* bce->emitLevel == 1 means we're last on the stack, so finish up. */
 80966:     if (ok && bce->emitLevel == 1) {
 80966:         if (!UpdateLineNumberNotes(cx, bce, pn->pn_pos.end.lineno))
 28739:             return JS_FALSE;
 28739:     }
     1: 
     1:     return ok;
     1: }
     1: 
 91237: static int
 80966: AllocSrcNote(JSContext *cx, BytecodeEmitter *bce)
 80966: {
 80966:     jssrcnote *notes = bce->notes();
 77950:     jssrcnote *newnotes;
 91237:     unsigned index = bce->noteCount();
 91237:     unsigned max = bce->noteLimit();
 77950: 
 77950:     if (index == max) {
 77950:         size_t newlength;
 77950:         if (!notes) {
 77950:             JS_ASSERT(!index && !max);
 77950:             newlength = SRCNOTE_CHUNK_LENGTH;
 77950:             newnotes = (jssrcnote *) cx->malloc_(SRCNOTE_SIZE(newlength));
     1:         } else {
 77950:             JS_ASSERT(index <= max);
 77950:             newlength = max * 2;
 77950:             newnotes = (jssrcnote *) cx->realloc_(notes, SRCNOTE_SIZE(newlength));
 77950:         }
 77950:         if (!newnotes) {
 71371:             js_ReportOutOfMemory(cx);
     1:             return -1;
     1:         }
 80966:         bce->current->notes = newnotes;
 80966:         bce->current->noteLimit = newlength;
 80966:     }
 80966: 
 80966:     bce->current->noteCount = index + 1;
 91237:     return (int)index;
 91237: }
 91237: 
 91237: int
 80966: frontend::NewSrcNote(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type)
     1: {
 91237:     int index, n;
     1:     jssrcnote *sn;
     1:     ptrdiff_t offset, delta, xdelta;
     1: 
     1:     /*
 80966:      * Claim a note slot in bce->notes() by growing it if necessary and then
 80966:      * incrementing bce->noteCount().
 80966:      */
 80966:     index = AllocSrcNote(cx, bce);
     1:     if (index < 0)
     1:         return -1;
 80966:     sn = &bce->notes()[index];
     1: 
     1:     /*
     1:      * Compute delta from the last annotated bytecode's offset.  If it's too
     1:      * big to fit in sn, allocate one or more xdelta notes and reset sn.
     1:      */
 80966:     offset = bce->offset();
 80966:     delta = offset - bce->lastNoteOffset();
 80966:     bce->current->lastNoteOffset = offset;
     1:     if (delta >= SN_DELTA_LIMIT) {
     1:         do {
     1:             xdelta = JS_MIN(delta, SN_XDELTA_MASK);
     1:             SN_MAKE_XDELTA(sn, xdelta);
     1:             delta -= xdelta;
 80966:             index = AllocSrcNote(cx, bce);
     1:             if (index < 0)
     1:                 return -1;
 80966:             sn = &bce->notes()[index];
     1:         } while (delta >= SN_DELTA_LIMIT);
     1:     }
     1: 
     1:     /*
     1:      * Initialize type and delta, then allocate the minimum number of notes
     1:      * needed for type's arity.  Usually, we won't need more, but if an offset
 80966:      * does take two bytes, SetSrcNoteOffset will grow bce->notes().
     1:      */
     1:     SN_MAKE_NOTE(sn, type, delta);
 91237:     for (n = (int)js_SrcNoteSpec[type].arity; n > 0; n--) {
 80966:         if (NewSrcNote(cx, bce, SRC_NULL) < 0)
     1:             return -1;
     1:     }
     1:     return index;
     1: }
     1: 
 91237: int
 80966: frontend::NewSrcNote2(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type, ptrdiff_t offset)
     1: {
 91237:     int index;
     1: 
 80966:     index = NewSrcNote(cx, bce, type);
     1:     if (index >= 0) {
 80966:         if (!SetSrcNoteOffset(cx, bce, index, 0, offset))
     1:             return -1;
     1:     }
     1:     return index;
     1: }
     1: 
 91237: int
 80966: frontend::NewSrcNote3(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type, ptrdiff_t offset1,
 80631:             ptrdiff_t offset2)
     1: {
 91237:     int index;
     1: 
 80966:     index = NewSrcNote(cx, bce, type);
     1:     if (index >= 0) {
 80966:         if (!SetSrcNoteOffset(cx, bce, index, 0, offset1))
     1:             return -1;
 80966:         if (!SetSrcNoteOffset(cx, bce, index, 1, offset2))
     1:             return -1;
     1:     }
     1:     return index;
     1: }
     1: 
     1: static JSBool
 80966: GrowSrcNotes(JSContext *cx, BytecodeEmitter *bce)
 80966: {
 80966:     size_t newlength = bce->noteLimit() * 2;
 80966:     jssrcnote *newnotes = (jssrcnote *) cx->realloc_(bce->notes(), newlength);
 77950:     if (!newnotes) {
 71371:         js_ReportOutOfMemory(cx);
     1:         return JS_FALSE;
     1:     }
 80966:     bce->current->notes = newnotes;
 80966:     bce->current->noteLimit = newlength;
     1:     return JS_TRUE;
     1: }
     1: 
     1: jssrcnote *
 80966: frontend::AddToSrcNoteDelta(JSContext *cx, BytecodeEmitter *bce, jssrcnote *sn, ptrdiff_t delta)
     1: {
     1:     ptrdiff_t base, limit, newdelta, diff;
 91237:     int index;
     1: 
     1:     /*
 80632:      * Called only from OptimizeSpanDeps and FinishTakingSrcNotes to add to
     1:      * main script note deltas, and only by a small positive amount.
     1:      */
 80966:     JS_ASSERT(bce->current == &bce->main);
     1:     JS_ASSERT((unsigned) delta < (unsigned) SN_XDELTA_LIMIT);
     1: 
     1:     base = SN_DELTA(sn);
     1:     limit = SN_IS_XDELTA(sn) ? SN_XDELTA_LIMIT : SN_DELTA_LIMIT;
     1:     newdelta = base + delta;
     1:     if (newdelta < limit) {
     1:         SN_SET_DELTA(sn, newdelta);
     1:     } else {
 80966:         index = sn - bce->main.notes;
 80966:         if (bce->main.noteCount == bce->main.noteLimit) {
 80966:             if (!GrowSrcNotes(cx, bce))
     1:                 return NULL;
 80966:             sn = bce->main.notes + index;
 80966:         }
 80966:         diff = bce->main.noteCount - index;
 80966:         bce->main.noteCount++;
     1:         memmove(sn + 1, sn, SRCNOTE_SIZE(diff));
     1:         SN_MAKE_XDELTA(sn, delta);
     1:         sn++;
     1:     }
     1:     return sn;
     1: }
     1: 
 80786: static JSBool
 91237: SetSrcNoteOffset(JSContext *cx, BytecodeEmitter *bce, unsigned index, unsigned which, ptrdiff_t offset)
     1: {
     1:     jssrcnote *sn;
     1:     ptrdiff_t diff;
     1: 
 86078:     if (size_t(offset) > SN_MAX_OFFSET) {
 98445:         ReportStatementTooLarge(cx, bce->sc);
     1:         return JS_FALSE;
     1:     }
     1: 
     1:     /* Find the offset numbered which (i.e., skip exactly which offsets). */
 80966:     sn = &bce->notes()[index];
     1:     JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
 91237:     JS_ASSERT((int) which < js_SrcNoteSpec[SN_TYPE(sn)].arity);
     1:     for (sn++; which; sn++, which--) {
     1:         if (*sn & SN_3BYTE_OFFSET_FLAG)
     1:             sn += 2;
     1:     }
     1: 
 86078:     /*
 86078:      * See if the new offset requires three bytes either by being too big or if
 86078:      * the offset has already been inflated (in which case, we need to stay big
 86078:      * to not break the srcnote encoding if this isn't the last srcnote).
 86078:      */
 86078:     if (offset > (ptrdiff_t)SN_3BYTE_OFFSET_MASK || (*sn & SN_3BYTE_OFFSET_FLAG)) {
     1:         /* Maybe this offset was already set to a three-byte value. */
     1:         if (!(*sn & SN_3BYTE_OFFSET_FLAG)) {
     1:             /* Losing, need to insert another two bytes for this offset. */
 80966:             index = sn - bce->notes();
     1: 
     1:             /*
 77949:              * Test to see if the source note array must grow to accommodate
 77949:              * either the first or second byte of additional storage required
 77949:              * by this 3-byte offset.
 77949:              */
 80966:             if (bce->noteCount() + 1 >= bce->noteLimit()) {
 80966:                 if (!GrowSrcNotes(cx, bce))
 80966:                     return JS_FALSE;
 80966:                 sn = bce->notes() + index;
 80966:             }
 80966:             bce->current->noteCount += 2;
 80966: 
 80966:             diff = bce->noteCount() - (index + 3);
     1:             JS_ASSERT(diff >= 0);
     1:             if (diff > 0)
     1:                 memmove(sn + 3, sn + 1, SRCNOTE_SIZE(diff));
     1:         }
     1:         *sn++ = (jssrcnote)(SN_3BYTE_OFFSET_FLAG | (offset >> 16));
     1:         *sn++ = (jssrcnote)(offset >> 8);
     1:     }
     1:     *sn = (jssrcnote)offset;
     1:     return JS_TRUE;
     1: }
     1: 
     1: #ifdef DEBUG_notme
     1: #define DEBUG_srcnotesize
     1: #endif
     1: 
     1: #ifdef DEBUG_srcnotesize
     1: #define NBINS 10
 84755: static uint32_t hist[NBINS];
     1: 
 80786: static void
 80786: DumpSrcNoteSizeHist()
     1: {
     1:     static FILE *fp;
     1:     int i, n;
     1: 
     1:     if (!fp) {
     1:         fp = fopen("/tmp/srcnotes.hist", "w");
     1:         if (!fp)
     1:             return;
     1:         setvbuf(fp, NULL, _IONBF, 0);
     1:     }
     1:     fprintf(fp, "SrcNote size histogram:\n");
     1:     for (i = 0; i < NBINS; i++) {
     1:         fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
     1:         for (n = (int) JS_HOWMANY(hist[i], 10); n > 0; --n)
     1:             fputc('*', fp);
     1:         fputc('\n', fp);
     1:     }
     1:     fputc('\n', fp);
     1: }
     1: #endif
     1: 
     1: /*
     1:  * Fill in the storage at notes with prolog and main srcnotes; the space at
 80966:  * notes was allocated using the BytecodeEmitter::countFinalSourceNotes()
 80966:  * method from BytecodeEmitter.h. SO DON'T CHANGE THIS FUNCTION WITHOUT AT
 80966:  * LEAST CHECKING WHETHER BytecodeEmitter::countFinalSourceNotes() NEEDS
 80634:  * CORRESPONDING CHANGES!
     1:  */
     1: JSBool
 80966: frontend::FinishTakingSrcNotes(JSContext *cx, BytecodeEmitter *bce, jssrcnote *notes)
     1: {
 91237:     unsigned prologCount, mainCount, totalCount;
     1:     ptrdiff_t offset, delta;
     1:     jssrcnote *sn;
     1: 
 80966:     JS_ASSERT(bce->current == &bce->main);
 80966: 
 80966:     prologCount = bce->prolog.noteCount;
 80966:     if (prologCount && bce->prolog.currentLine != bce->firstLine) {
 80966:         bce->switchToProlog();
 80966:         if (NewSrcNote2(cx, bce, SRC_SETLINE, (ptrdiff_t)bce->firstLine) < 0)
 80966:             return false;
 80966:         prologCount = bce->prolog.noteCount;
 80966:         bce->switchToMain();
     1:     } else {
     1:         /*
     1:          * Either no prolog srcnotes, or no line number change over prolog.
     1:          * We don't need a SRC_SETLINE, but we may need to adjust the offset
     1:          * of the first main note, by adding to its delta and possibly even
     1:          * prepending SRC_XDELTA notes to it to account for prolog bytecodes
     1:          * that came at and after the last annotated bytecode.
     1:          */
 80966:         offset = bce->prologOffset() - bce->prolog.lastNoteOffset;
     1:         JS_ASSERT(offset >= 0);
 80966:         if (offset > 0 && bce->main.noteCount != 0) {
     1:             /* NB: Use as much of the first main note's delta as we can. */
 80966:             sn = bce->main.notes;
     1:             delta = SN_IS_XDELTA(sn)
     1:                     ? SN_XDELTA_MASK - (*sn & SN_XDELTA_MASK)
     1:                     : SN_DELTA_MASK - (*sn & SN_DELTA_MASK);
     1:             if (offset < delta)
     1:                 delta = offset;
     1:             for (;;) {
 80966:                 if (!AddToSrcNoteDelta(cx, bce, sn, delta))
 80632:                     return false;
     1:                 offset -= delta;
     1:                 if (offset == 0)
     1:                     break;
     1:                 delta = JS_MIN(offset, SN_XDELTA_MASK);
 80966:                 sn = bce->main.notes;
 80966:             }
 80966:         }
 80966:     }
 80966: 
 80966:     mainCount = bce->main.noteCount;
     1:     totalCount = prologCount + mainCount;
     1:     if (prologCount)
 87623:         PodCopy(notes, bce->prolog.notes, prologCount);
 87623:     PodCopy(notes + prologCount, bce->main.notes, mainCount);
     1:     SN_MAKE_TERMINATOR(&notes[totalCount]);
     1: 
 80632:     return true;
     1: }
     1: 
  3025: static JSBool
 91237: NewTryNote(JSContext *cx, BytecodeEmitter *bce, JSTryNoteKind kind, unsigned stackDepth, size_t start,
 80631:            size_t end)
     1: {
 91237:     JS_ASSERT((unsigned)(uint16_t)stackDepth == stackDepth);
  1825:     JS_ASSERT(start <= end);
 84755:     JS_ASSERT((size_t)(uint32_t)start == start);
 84755:     JS_ASSERT((size_t)(uint32_t)end == end);
  3025: 
 80631:     TryNode *tryNode = cx->tempLifoAlloc().new_<TryNode>();
  8296:     if (!tryNode) {
 71371:         js_ReportOutOfMemory(cx);
  8296:         return JS_FALSE;
  8296:     }
  3025: 
  3025:     tryNode->note.kind = kind;
 84755:     tryNode->note.stackDepth = (uint16_t)stackDepth;
 84755:     tryNode->note.start = (uint32_t)start;
 84755:     tryNode->note.length = (uint32_t)(end - start);
 80966:     tryNode->prev = bce->lastTryNode;
 80966:     bce->lastTryNode = tryNode;
 80966:     bce->ntrynotes++;
  3025:     return JS_TRUE;
     1: }
     1: 
     1: void
 97362: frontend::FinishTakingTryNotes(BytecodeEmitter *bce, TryNoteArray *array)
 80631: {
 80631:     TryNode *tryNode;
  3025:     JSTryNote *tn;
  3025: 
 80966:     JS_ASSERT(array->length > 0 && array->length == bce->ntrynotes);
  3235:     tn = array->vector + array->length;
 80966:     tryNode = bce->lastTryNode;
  3025:     do {
  3025:         *--tn = tryNode->note;
  3025:     } while ((tryNode = tryNode->prev) != NULL);
  3235:     JS_ASSERT(tn == array->vector);
  3235: }
  3235: 
  3235: /*
  3235:  * Find the index of the given object for code generator.
  3235:  *
  3235:  * Since the emitter refers to each parsed object only once, for the index we
  3235:  * use the number of already indexes objects. We also add the object to a list
  3235:  * to convert the list to a fixed-size array when we complete code generation,
 80631:  * see js::CGObjectList::finish below.
  3235:  *
 80966:  * Most of the objects go to BytecodeEmitter::objectList but for regexp we use
 80966:  * a separated BytecodeEmitter::regexpList. In this way the emitted index can
 80966:  * be directly used to store and fetch a reference to a cloned RegExp object
 80966:  * that shares the same JSRegExp private data created for the object literal in
 80631:  * objbox. We need a cloned object to hold lastIndex and other direct
 80631:  * properties that should not be shared among threads sharing a precompiled
 80631:  * function or script.
  3235:  *
  3235:  * If the code being compiled is function code, allocate a reserved slot in
  3235:  * the cloned function object that shares its precompiled script with other
  3235:  * cloned function objects and with the compiler-created clone-parent. There
 32723:  * are nregexps = script->regexps()->length such reserved slots in each
 18308:  * function object cloned from fun->object. NB: during compilation, a funobj
 52503:  * slots element must never be allocated, because JSObject::allocSlot could
 52503:  * hand out one of the slots that should be given to a regexp clone.
  3235:  *
  3235:  * If the code being compiled is global code, the cloned regexp are stored in
 54477:  * fp->vars slot and to protect regexp slots from GC we set fp->nvars to
 54477:  * nregexps.
  3235:  *
  3235:  * The slots initially contain undefined or null. We populate them lazily when
  3235:  * JSOP_REGEXP is executed for the first time.
  3235:  *
  3235:  * Why clone regexp objects?  ECMA specifies that when a regular expression
  3235:  * literal is scanned, a RegExp object is created.  In the spec, compilation
  3235:  * and execution happen indivisibly, but in this implementation and many of
  3235:  * its embeddings, code is precompiled early and re-executed in multiple
  3235:  * threads, or using multiple global objects, or both, for efficiency.
  3235:  *
  3235:  * In such cases, naively following ECMA leads to wrongful sharing of RegExp
  3235:  * objects, which makes for collisions on the lastIndex property (especially
 41968:  * for global regexps) and on any ad-hoc properties.  Also, __proto__ refers to
 41968:  * the pre-compilation prototype, a pigeon-hole problem for instanceof tests.
  3235:  */
 91237: unsigned
100006: CGObjectList::index(ObjectBox *objbox)
  3235: {
 27012:     JS_ASSERT(!objbox->emitLink);
 27012:     objbox->emitLink = lastbox;
 27012:     lastbox = objbox;
 86077:     return length++;
  3235: }
  3235: 
  3235: void
 97362: CGObjectList::finish(ObjectArray *array)
 80631: {
 27012:     JS_ASSERT(length <= INDEX_LIMIT);
 27012:     JS_ASSERT(length == array->length);
  3235: 
 82129:     js::HeapPtrObject *cursor = array->vector + array->length;
 80631:     ObjectBox *objbox = lastbox;
  3235:     do {
  3235:         --cursor;
  3235:         JS_ASSERT(!*cursor);
 27012:         *cursor = objbox->object;
 27012:     } while ((objbox = objbox->emitLink) != NULL);
  3235:     JS_ASSERT(cursor == array->vector);
  3235: }
 48470: 
 48470: void
 97362: GCConstList::finish(ConstArray *array)
 48470: {
 48470:     JS_ASSERT(array->length == list.length());
 48470:     Value *src = list.begin(), *srcend = list.end();
 82129:     HeapValue *dst = array->vector;
 48470:     for (; src != srcend; ++src, ++dst)
 48470:         *dst = *src;
 48470: }
 80632: 
 80632: /*
 80632:  * We should try to get rid of offsetBias (always 0 or 1, where 1 is
 80632:  * JSOP_{NOP,POP}_LENGTH), which is used only by SRC_FOR and SRC_DECL.
 80632:  */
 80632: JS_FRIEND_DATA(JSSrcNoteSpec) js_SrcNoteSpec[] = {
 86877:     {"null",            0},
 86877:     {"if",              0},
 86877:     {"if-else",         2},
 86877:     {"for",             3},
 86877:     {"while",           1},
 86877:     {"continue",        0},
 86877:     {"decl",            1},
 86877:     {"pcdelta",         1},
 86877:     {"assignop",        0},
 86877:     {"cond",            1},
 86877:     {"brace",           1},
 86877:     {"hidden",          0},
 86877:     {"pcbase",          1},
 86877:     {"label",           1},
 86877:     {"labelbrace",      1},
 86877:     {"endbrace",        0},
 86877:     {"break2label",     1},
 86877:     {"cont2label",      1},
 86877:     {"switch",          2},
 86877:     {"funcdef",         1},
 86877:     {"catch",           1},
 86877:     {"unused",         -1},
 86877:     {"newline",         0},
 86877:     {"setline",         1},
 86877:     {"xdelta",          0},
 80632: };
 80632: 
 91237: JS_FRIEND_API(unsigned)
 80632: js_SrcNoteLength(jssrcnote *sn)
 80632: {
 91237:     unsigned arity;
 80632:     jssrcnote *base;
 80632: 
 91237:     arity = (int)js_SrcNoteSpec[SN_TYPE(sn)].arity;
 80632:     for (base = sn++; arity; sn++, arity--) {
 80632:         if (*sn & SN_3BYTE_OFFSET_FLAG)
 80632:             sn += 2;
 80632:     }
 80632:     return sn - base;
 80632: }
 80632: 
 80632: JS_FRIEND_API(ptrdiff_t)
 91237: js_GetSrcNoteOffset(jssrcnote *sn, unsigned which)
 80632: {
 80632:     /* Find the offset numbered which (i.e., skip exactly which offsets). */
 80632:     JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
 91237:     JS_ASSERT((int) which < js_SrcNoteSpec[SN_TYPE(sn)].arity);
 80632:     for (sn++; which; sn++, which--) {
 80632:         if (*sn & SN_3BYTE_OFFSET_FLAG)
 80632:             sn += 2;
 80632:     }
 80632:     if (*sn & SN_3BYTE_OFFSET_FLAG) {
 84755:         return (ptrdiff_t)(((uint32_t)(sn[0] & SN_3BYTE_OFFSET_MASK) << 16)
 80632:                            | (sn[1] << 8)
 80632:                            | sn[2]);
 80632:     }
 80632:     return (ptrdiff_t)*sn;
 80632: }
