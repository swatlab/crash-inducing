52560: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52560:  * vim: set ts=4 sw=4 et tw=99:
52560:  *
52560:  * ***** BEGIN LICENSE BLOCK *****
52560:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52560:  *
52560:  * The contents of this file are subject to the Mozilla Public License Version
52560:  * 1.1 (the "License"); you may not use this file except in compliance with
52560:  * the License. You may obtain a copy of the License at
52560:  * http://www.mozilla.org/MPL/
52560:  *
52560:  * Software distributed under the License is distributed on an "AS IS" basis,
52560:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52560:  * for the specific language governing rights and limitations under the
52560:  * License.
52560:  *
52560:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52560:  * May 28, 2008.
52560:  *
52560:  * The Initial Developer of the Original Code is
52560:  *   Brendan Eich <brendan@mozilla.org>
52560:  *
52560:  * Contributor(s):
52560:  *   David Anderson <danderson@mozilla.com>
52560:  *
52560:  * Alternatively, the contents of this file may be used under the terms of
52560:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52560:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52560:  * in which case the provisions of the GPL or the LGPL are applicable instead
52560:  * of those above. If you wish to allow use of your version of this file only
52560:  * under the terms of either the GPL or the LGPL, and not to allow others to
52560:  * use your version of this file under the terms of the MPL, indicate your
52560:  * decision by deleting the provisions above and replace them with the notice
52560:  * and other provisions required by the GPL or the LGPL. If you do not delete
52560:  * the provisions above, a recipient may use your version of this file under
52560:  * the terms of any one of the MPL, the GPL or the LGPL.
52560:  *
52560:  * ***** END LICENSE BLOCK ***** */
53269: 
52618: #if !defined jsjaeger_framestate_inl_h__ && defined JS_METHODJIT
52618: #define jsjaeger_framestate_inl_h__
52560: 
52618: namespace js {
52618: namespace mjit {
52560: 
52618: inline FrameEntry *
52617: FrameState::addToTracker(uint32 index)
52617: {
52617:     JS_ASSERT(!base[index]);
52705:     FrameEntry *fe = &entries[index];
52705:     base[index] = fe;
52708:     fe->track(tracker.nentries);
52705:     tracker.add(fe);
53272:     JS_ASSERT(tracker.nentries <= script->nslots);
52705:     return fe;
52617: }
52617: 
52618: inline FrameEntry *
52617: FrameState::peek(int32 depth)
52617: {
52617:     JS_ASSERT(depth < 0);
52617:     JS_ASSERT(sp + depth >= spBase);
52617:     FrameEntry *fe = sp[depth];
52617:     if (!fe) {
52617:         fe = addToTracker(indexOf(depth));
52617:         fe->resetSynced();
52617:     }
52617:     return fe;
52617: }
52617: 
52618: inline void
52617: FrameState::popn(uint32 n)
52617: {
52617:     for (uint32 i = 0; i < n; i++)
52617:         pop();
52617: }
52617: 
53115: inline bool
53115: FrameState::haveSameBacking(FrameEntry *lhs, FrameEntry *rhs)
53115: {
53240:     if (lhs->isCopy())
53240:         lhs = lhs->copyOf();
53240:     if (rhs->isCopy())
53240:         rhs = rhs->copyOf();
53240:     return lhs == rhs;
53115: }
53115: 
52618: inline JSC::MacroAssembler::RegisterID
52617: FrameState::allocReg()
52617: {
52827:     RegisterID reg;
52827:     if (!freeRegs.empty())
52827:         reg = freeRegs.takeAnyReg();
52827:     else
52846:         reg = evictSomeReg();
52827:     regstate[reg].fe = NULL;
52827:     return reg;
52617: }
52617: 
52618: inline JSC::MacroAssembler::RegisterID
52653: FrameState::allocReg(uint32 mask)
52653: {
52653:     RegisterID reg;
52653:     if (freeRegs.hasRegInMask(mask))
52653:         reg = freeRegs.takeRegInMask(mask);
52653:     else
52846:         reg = evictSomeReg(mask);
52653:     regstate[reg].fe = NULL;
52653:     return reg;
52653: }
52653: 
52653: inline JSC::MacroAssembler::RegisterID
53002: FrameState::allocReg(FrameEntry *fe, RematInfo::RematType type)
52617: {
52646:     RegisterID reg;
52646:     if (!freeRegs.empty())
52646:         reg = freeRegs.takeAnyReg();
52646:     else
52846:         reg = evictSomeReg();
53002:     regstate[reg] = RegisterState(fe, type);
52617:     return reg;
52617: }
52617: 
52618: inline void
52962: FrameState::emitLoadTypeTag(FrameEntry *fe, RegisterID reg) const
52962: {
52962:     emitLoadTypeTag(this->masm, fe, reg);
52962: }
52962: 
52962: inline void
52962: FrameState::emitLoadTypeTag(Assembler &masm, FrameEntry *fe, RegisterID reg) const
52962: {
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962:     masm.loadTypeTag(addressOf(fe), reg);
52962: }
52962: 
52962: inline void
52962: FrameState::convertInt32ToDouble(Assembler &masm, FrameEntry *fe, FPRegisterID fpreg) const
52962: {
52962:     JS_ASSERT(!fe->isConstant());
52962: 
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962:     
52962:     if (fe->data.inRegister())
52962:         masm.convertInt32ToDouble(fe->data.reg(), fpreg);
52962:     else
52962:         masm.convertInt32ToDouble(addressOf(fe), fpreg);
52962: }
52962: 
52962: inline bool
52962: FrameState::peekTypeInRegister(FrameEntry *fe) const
52962: {
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962:     return fe->type.inRegister();
52962: }
52962: 
52962: inline void
52617: FrameState::pop()
52578: {
52617:     JS_ASSERT(sp > spBase);
52578: 
52617:     FrameEntry *fe = *--sp;
52617:     if (!fe)
52617:         return;
52578: 
52846:     forgetAllRegs(fe);
52578: }
52578: 
52618: inline void
52617: FrameState::freeReg(RegisterID reg)
52599: {
52623:     JS_ASSERT(regstate[reg].fe == NULL);
52623:     freeRegs.putReg(reg);
52599: }
52617: 
52618: inline void
52617: FrameState::forgetReg(RegisterID reg)
52617: {
53181:     /*
53181:      * Important: Do not touch the fe here. We can peephole optimize away
53181:      * loads and stores by re-using the contents of old FEs.
53181:      */
53181:     JS_ASSERT_IF(regstate[reg].fe, !regstate[reg].fe->isCopy());
52617:     freeRegs.putReg(reg);
52599: }
52617: 
52618: inline void
52617: FrameState::forgetEverything(uint32 newStackDepth)
52617: {
52617:     forgetEverything();
52617:     sp = spBase + newStackDepth;
52617: }
52617: 
52618: inline FrameEntry *
52617: FrameState::rawPush()
52617: {
52909:     JS_ASSERT(unsigned(sp - base) < nargs + script->nslots);
52909: 
52617:     sp++;
52617: 
52617:     if (FrameEntry *fe = sp[-1])
52617:         return fe;
52617: 
52617:     return addToTracker(&sp[-1] - base);
52617: }
52617: 
52618: inline void
52617: FrameState::push(const Value &v)
52617: {
52617:     FrameEntry *fe = rawPush();
52617:     fe->setConstant(Jsvalify(v));
52617: }
52617: 
52618: inline void
52617: FrameState::pushSynced()
52617: {
52617:     sp++;
52617: 
52617:     if (FrameEntry *fe = sp[-1])
52617:         fe->resetSynced();
52617: }
52617: 
52618: inline void
53025: FrameState::pushSyncedType(JSValueType type)
52617: {
52617:     FrameEntry *fe = rawPush();
52617: 
52771:     fe->resetSynced();
53025:     fe->setType(type);
52611: }
52611: 
52618: inline void
53025: FrameState::pushSynced(JSValueType type, RegisterID reg)
52719: {
52719:     FrameEntry *fe = rawPush();
52719: 
52719:     fe->resetUnsynced();
52719:     fe->type.sync();
52719:     fe->data.sync();
53025:     fe->setType(type);
52719:     fe->data.setRegister(reg);
53002:     regstate[reg] = RegisterState(fe, RematInfo::DATA);
52719: }
52719: 
52719: inline void
52617: FrameState::push(Address address)
52611: {
52617:     FrameEntry *fe = rawPush();
52617: 
52617:     /* :XXX: X64 */
52617:     fe->resetUnsynced();
52617: 
52622:     /* Prevent us from clobbering this reg. */
52622:     bool free = freeRegs.hasReg(address.base);
52622:     if (free)
52622:         freeRegs.takeReg(address.base);
52622: 
53269:     RegisterID dreg = allocReg(fe, RematInfo::DATA);
53269:     masm.loadPayload(address, dreg);
53269:     fe->data.setRegister(dreg);
52617: 
52622:     /* Now it's safe to grab this register again. */
52622:     if (free)
52622:         freeRegs.putReg(address.base);
52622: 
53269:     RegisterID treg = allocReg(fe, RematInfo::TYPE);
53269:     masm.loadTypeTag(address, treg);
53269:     fe->type.setRegister(treg);
52599: }
52599: 
52618: inline void
52831: FrameState::pushRegs(RegisterID type, RegisterID data)
52831: {
52831:     JS_ASSERT(!freeRegs.hasReg(type) && !freeRegs.hasReg(data));
52831: 
52831:     FrameEntry *fe = rawPush();
52831: 
52831:     fe->resetUnsynced();
52831:     fe->type.setRegister(type);
52831:     fe->data.setRegister(data);
53002:     regstate[type] = RegisterState(fe, RematInfo::TYPE);
53002:     regstate[data] = RegisterState(fe, RematInfo::DATA);
52831: }
52831: 
52831: inline void
53025: FrameState::pushTypedPayload(JSValueType type, RegisterID payload)
52599: {
52617:     JS_ASSERT(!freeRegs.hasReg(payload));
52617: 
52617:     FrameEntry *fe = rawPush();
52617: 
52617:     fe->resetUnsynced();
53025:     fe->setType(type);
52617:     fe->data.setRegister(payload);
53002:     regstate[payload] = RegisterState(fe, RematInfo::DATA);
52599: }
52599: 
52623: inline void
53181: FrameState::pushNumber(MaybeRegisterID payload, bool asInt32)
53153: {
53153:     JS_ASSERT_IF(payload.isSet(), !freeRegs.hasReg(payload.reg()));
53153: 
53153:     FrameEntry *fe = rawPush();
53153:     fe->clear();
53153: 
53153:     JS_ASSERT(!fe->isNumber);
53153: 
53181:     if (asInt32) {
53181:         if (!fe->type.synced())
53181:             masm.storeTypeTag(ImmType(JSVAL_TYPE_INT32), addressOf(fe));
53153:         fe->type.setMemory();
53181:     } else {
53181:         fe->type.setMemory();
53181:     }
53181: 
53153:     fe->isNumber = true;
53153:     if (payload.isSet()) {
53153:         fe->data.unsync();
53153:         fe->data.setRegister(payload.reg());
53153:         regstate[payload.reg()] = RegisterState(fe, RematInfo::DATA);
53153:     } else {
53153:         fe->data.setMemory();
53153:     }
53153: }
53153: 
53153: inline void
53200: FrameState::pushInt32(RegisterID payload)
53200: {
53200:     FrameEntry *fe = rawPush();
53200:     fe->clear();
53200:     JS_ASSERT(!fe->isNumber);
53200: 
53200:     masm.storeTypeTag(ImmType(JSVAL_TYPE_INT32), addressOf(fe));
53200:     fe->type.setMemory();
53200: 
53200:     fe->isNumber = true;
53200:     fe->data.unsync();
53200:     fe->data.setRegister(payload);
53200:     regstate[payload] = RegisterState(fe, RematInfo::DATA);
53200: }
53200: 
53200: inline void
53181: FrameState::pushUntypedPayload(JSValueType type, RegisterID payload)
52623: {
52623:     JS_ASSERT(!freeRegs.hasReg(payload));
52623: 
52623:     FrameEntry *fe = rawPush();
52623: 
52960:     fe->clear();
52960: 
53025:     masm.storeTypeTag(ImmType(type), addressOf(fe));
52960: 
52623:     /* The forceful type sync will assert otherwise. */
52623: #ifdef DEBUG
52623:     fe->type.unsync();
52623: #endif
52803:     fe->type.setMemory();
52623:     fe->data.unsync();
52803:     fe->setNotCopied();
52803:     fe->setCopyOf(NULL);
52623:     fe->data.setRegister(payload);
53002:     regstate[payload] = RegisterState(fe, RematInfo::DATA);
52623: }
52623: 
52618: inline JSC::MacroAssembler::RegisterID
53137: FrameState::tempRegForType(FrameEntry *fe, RegisterID fallback)
53137: {
53137:     JS_ASSERT(regstate[fallback].fe == NULL);
53137:     if (fe->isCopy())
53137:         fe = fe->copyOf();
53137: 
53137:     JS_ASSERT(!fe->type.isConstant());
53137: 
53137:     if (fe->type.inRegister())
53137:         return fe->type.reg();
53137: 
53137:     /* :XXX: X86 */
53137: 
53137:     masm.loadTypeTag(addressOf(fe), fallback);
53137:     return fallback;
53137: }
53137: 
53137: 
53137: inline JSC::MacroAssembler::RegisterID
52962: FrameState::tempRegForType(FrameEntry *fe)
52962: {
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962: 
53014:     JS_ASSERT(!fe->type.isConstant());
53014: 
52962:     if (fe->type.inRegister())
52962:         return fe->type.reg();
52962: 
52962:     /* :XXX: X86 */
52962: 
53002:     RegisterID reg = allocReg(fe, RematInfo::TYPE);
52617:     masm.loadTypeTag(addressOf(fe), reg);
52624:     fe->type.setRegister(reg);
52617:     return reg;
52608: }
52608: 
52620: inline JSC::MacroAssembler::RegisterID
52620: FrameState::tempRegForData(FrameEntry *fe)
52620: {
52620:     JS_ASSERT(!fe->data.isConstant());
52620: 
52670:     if (fe->isCopy())
52705:         fe = fe->copyOf();
52670: 
52620:     if (fe->data.inRegister())
52620:         return fe->data.reg();
52620: 
53002:     RegisterID reg = allocReg(fe, RematInfo::DATA);
53144:     masm.loadPayload(addressOf(fe), reg);
52624:     fe->data.setRegister(reg);
52620:     return reg;
52620: }
52620: 
52685: inline JSC::MacroAssembler::RegisterID
53156: FrameState::tempRegInMaskForData(FrameEntry *fe, uint32 mask)
52685: {
52685:     JS_ASSERT(!fe->data.isConstant());
52685: 
52685:     if (fe->isCopy())
52705:         fe = fe->copyOf();
52685: 
53156:     RegisterID reg;
52685:     if (fe->data.inRegister()) {
52685:         RegisterID old = fe->data.reg();
53156:         if (Registers::maskReg(old) & mask)
53156:             return old;
52685: 
52685:         /* Keep the old register pinned. */
52685:         regstate[old].fe = NULL;
53156:         reg = allocReg(mask);
52685:         masm.move(old, reg);
52685:         freeReg(old);
52685:     } else {
53156:         reg = allocReg(mask);
53144:         masm.loadPayload(addressOf(fe), reg);
52685:     }
53002:     regstate[reg] = RegisterState(fe, RematInfo::DATA);
52685:     fe->data.setRegister(reg);
52685:     return reg;
52685: }
52685: 
53228: inline JSC::MacroAssembler::RegisterID
53228: FrameState::tempRegForData(FrameEntry *fe, RegisterID reg, Assembler &masm) const
53228: {
53228:     JS_ASSERT(!fe->data.isConstant());
53228: 
53228:     if (fe->isCopy())
53228:         fe = fe->copyOf();
53228: 
53228:     if (fe->data.inRegister()) {
53228:         JS_ASSERT(fe->data.reg() != reg);
53228:         return fe->data.reg();
53228:     } else {
53228:         masm.loadPayload(addressOf(fe), reg);
53228:         return reg;
53228:     }
53228: }
53228: 
52623: inline bool
52623: FrameState::shouldAvoidTypeRemat(FrameEntry *fe)
52620: {
52623:     return fe->type.inMemory();
52620: }
52620: 
52620: inline bool
52620: FrameState::shouldAvoidDataRemat(FrameEntry *fe)
52620: {
52620:     return fe->data.inMemory();
52620: }
52620: 
52618: inline void
52670: FrameState::syncType(const FrameEntry *fe, Address to, Assembler &masm) const
52608: {
52670:     JS_ASSERT_IF(fe->type.synced(),
52670:                  fe->isCopied() && addressOf(fe).offset != to.offset);
52617:     JS_ASSERT(fe->type.inRegister() || fe->type.isConstant());
52617: 
52617:     if (fe->type.isConstant()) {
52617:         JS_ASSERT(fe->isTypeKnown());
53144:         masm.storeTypeTag(ImmType(fe->getKnownType()), to);
52617:     } else {
52670:         masm.storeTypeTag(fe->type.reg(), to);
52617:     }
52608: }
52608: 
52618: inline void
52670: FrameState::syncData(const FrameEntry *fe, Address to, Assembler &masm) const
52608: {
52670:     JS_ASSERT_IF(addressOf(fe).base == to.base &&
52670:                  addressOf(fe).offset == to.offset,
52670:                  !fe->data.synced());
52617:     JS_ASSERT(fe->data.inRegister() || fe->data.isConstant());
52617: 
52617:     if (fe->data.isConstant()) {
52617:         if (!fe->type.synced())
52670:             masm.storeValue(fe->getValue(), to);
52617:         else
53224: #if defined JS_NUNBOX32
53144:             masm.storePayload(Imm32(fe->getPayload32()), to);
53224: #elif defined JS_PUNBOX64
53162:             masm.storePayload(Imm64(fe->getPayload64()), to);
53162: #endif
52614:     } else {
53144:         masm.storePayload(fe->data.reg(), to);
52608:     }
52614: }
52611: 
52619: inline void
52804: FrameState::forgetType(FrameEntry *fe)
52804: {
52804:     JS_ASSERT(fe->isTypeKnown() && !fe->type.synced());
52804:     syncType(fe, addressOf(fe), masm);
52804:     fe->type.setMemory();
52804: }
52804: 
52804: inline void
53025: FrameState::learnType(FrameEntry *fe, JSValueType type)
52619: {
52624:     if (fe->type.inRegister())
52624:         forgetReg(fe->type.reg());
53153: #ifdef DEBUG
53153:     fe->isNumber = false;
53153: #endif
53025:     fe->setType(type);
52619: }
52619: 
52620: inline JSC::MacroAssembler::Address
52620: FrameState::addressOf(const FrameEntry *fe) const
52620: {
52620:     uint32 index = (fe - entries);
52620:     JS_ASSERT(index >= nargs);
52656:     index -= nargs;
52829:     return Address(JSFrameReg, sizeof(JSStackFrame) + sizeof(Value) * index);
52620: }
52620: 
53497: inline JSC::MacroAssembler::Address
53497: FrameState::addressForDataRemat(const FrameEntry *fe) const
53497: {
53497:     if (fe->isCopy() && !fe->data.synced())
53497:         fe = fe->copyOf();
53497:     JS_ASSERT(fe->data.synced());
53497:     return addressOf(fe);
53497: }
53497: 
52623: inline JSC::MacroAssembler::Jump
53004: FrameState::testNull(Assembler::Condition cond, FrameEntry *fe)
53004: {
53004:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
53004:     if (shouldAvoidTypeRemat(fe))
53004:         return masm.testNull(cond, addressOf(fe));
53004:     return masm.testNull(cond, tempRegForType(fe));
53004: }
53004: 
53004: inline JSC::MacroAssembler::Jump
52623: FrameState::testInt32(Assembler::Condition cond, FrameEntry *fe)
52623: {
52823:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52623:     if (shouldAvoidTypeRemat(fe))
52623:         return masm.testInt32(cond, addressOf(fe));
52623:     return masm.testInt32(cond, tempRegForType(fe));
52623: }
52623: 
52734: inline JSC::MacroAssembler::Jump
52894: FrameState::testPrimitive(Assembler::Condition cond, FrameEntry *fe)
52894: {
52894:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52894:     if (shouldAvoidTypeRemat(fe))
52894:         return masm.testPrimitive(cond, addressOf(fe));
52894:     return masm.testPrimitive(cond, tempRegForType(fe));
52894: }
52894: 
52894: inline JSC::MacroAssembler::Jump
53023: FrameState::testObject(Assembler::Condition cond, FrameEntry *fe)
52838: {
52838:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52838:     if (shouldAvoidTypeRemat(fe))
53023:         return masm.testObject(cond, addressOf(fe));
53023:     return masm.testObject(cond, tempRegForType(fe));
52850: }
52850: 
52850: inline JSC::MacroAssembler::Jump
52823: FrameState::testDouble(Assembler::Condition cond, FrameEntry *fe)
52823: {
52823:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52823:     if (shouldAvoidTypeRemat(fe))
52823:         return masm.testDouble(cond, addressOf(fe));
52823:     return masm.testDouble(cond, tempRegForType(fe));
52823: }
52823: 
52823: inline JSC::MacroAssembler::Jump
52734: FrameState::testBoolean(Assembler::Condition cond, FrameEntry *fe)
52734: {
52823:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52734:     if (shouldAvoidTypeRemat(fe))
52734:         return masm.testBoolean(cond, addressOf(fe));
52734:     return masm.testBoolean(cond, tempRegForType(fe));
52734: }
52734: 
53137: inline JSC::MacroAssembler::Jump
53137: FrameState::testString(Assembler::Condition cond, FrameEntry *fe)
53137: {
53137:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
53137:     if (shouldAvoidTypeRemat(fe))
53137:         return masm.testString(cond, addressOf(fe));
53137:     return masm.testString(cond, tempRegForType(fe));
53137: }
53137: 
52670: inline FrameEntry *
52670: FrameState::getLocal(uint32 slot)
52670: {
52670:     uint32 index = nargs + slot;
52670:     if (FrameEntry *fe = base[index])
52670:         return fe;
52670:     FrameEntry *fe = addToTracker(index);
52670:     fe->resetSynced();
52670:     return fe;
52670: }
52670: 
52685: inline void
52685: FrameState::pinReg(RegisterID reg)
52685: {
52685:     JS_ASSERT(regstate[reg].fe);
52685:     regstate[reg].save = regstate[reg].fe;
52685:     regstate[reg].fe = NULL;
52685: }
52685: 
52685: inline void
52685: FrameState::unpinReg(RegisterID reg)
52685: {
52685:     JS_ASSERT(!regstate[reg].fe);
52685:     regstate[reg].fe = regstate[reg].save;
52685: }
52685: 
52691: inline void
52846: FrameState::forgetAllRegs(FrameEntry *fe)
52691: {
52691:     if (fe->type.inRegister())
52691:         forgetReg(fe->type.reg());
52691:     if (fe->data.inRegister())
52691:         forgetReg(fe->data.reg());
52691: }
52691: 
52705: inline FrameEntry *
52705: FrameState::tosFe() const
52705: {
52705:     return &entries[uint32(sp - base)];
52705: }
52705: 
52708: inline void
52708: FrameState::swapInTracker(FrameEntry *lhs, FrameEntry *rhs)
52708: {
52708:     uint32 li = lhs->trackerIndex();
52708:     uint32 ri = rhs->trackerIndex();
52708:     JS_ASSERT(tracker[li] == lhs);
52708:     JS_ASSERT(tracker[ri] == rhs);
52708:     tracker.entries[ri] = lhs;
52708:     tracker.entries[li] = rhs;
52708:     lhs->index_ = ri;
52708:     rhs->index_ = li;
52708: }
52708: 
52714: inline uint32
52714: FrameState::localIndex(uint32 n)
52714: {
52714:     return nargs + n;
52714: }
52714: 
52714: inline void
52714: FrameState::dup()
52714: {
52916:     dupAt(-1);
52714: }
52714: 
52714: inline void
52715: FrameState::dup2()
52715: {
52715:     FrameEntry *lhs = peek(-2);
52715:     FrameEntry *rhs = peek(-1);
52715:     pushCopyOf(indexOfFe(lhs));
52715:     pushCopyOf(indexOfFe(rhs));
52715: }
52715: 
52715: inline void
52916: FrameState::dupAt(int32 n)
52916: {
52916:     JS_ASSERT(n < 0);
52916:     FrameEntry *fe = peek(n);
52916:     pushCopyOf(indexOfFe(fe));
52916: }
52916: 
52916: inline void
52714: FrameState::pushLocal(uint32 n)
52714: {
52878:     if (!eval && !escaping[n]) {
52715:         pushCopyOf(indexOfFe(getLocal(n)));
52878:     } else {
53309: #ifdef DEBUG
53309:         /*
53309:          * We really want to assert on local variables, but in the presence of
53309:          * SETLOCAL equivocation of stack slots, and let expressions, just
53309:          * weakly assert on the fixed local vars.
53309:          */
53309:         FrameEntry *fe = base[localIndex(n)];
53309:         if (fe && n < script->nfixed) {
53309:             JS_ASSERT(fe->type.inMemory());
53309:             JS_ASSERT(fe->data.inMemory());
52973:         }
53309: #endif
52878:         push(Address(JSFrameReg, sizeof(JSStackFrame) + n * sizeof(Value)));
52878:     }
52714: }
52714: 
52785: inline void
52785: FrameState::leaveBlock(uint32 n)
52785: {
52785:     popn(n);
52785: }
52785: 
52785: inline void
52785: FrameState::enterBlock(uint32 n)
52785: {
52785:     /* expect that tracker has 0 entries, for now. */
52785:     JS_ASSERT(!tracker.nentries);
52785:     JS_ASSERT(uint32(sp + n - locals) <= script->nslots);
52785: 
52785:     sp += n;
52785: }
52785: 
52838: inline void
52838: FrameState::eviscerate(FrameEntry *fe)
52838: {
52846:     forgetAllRegs(fe);
52838:     fe->type.invalidate();
52838:     fe->data.invalidate();
52838:     fe->setNotCopied();
52838:     fe->setCopyOf(NULL);
52838: }
52838: 
53499: inline bool
52878: FrameState::addEscaping(uint32 local)
52878: {
53499:     if (!eval) {
53499:         uint32 already = escaping[local];
52878:         escaping[local] = 1;
53499:         return !already;
53499:     }
53499:     return false;
52878: }
52878: 
52880: inline StateRemat
52880: FrameState::dataRematInfo(const FrameEntry *fe) const
52880: {
52880:     if (fe->isCopy())
52880:         fe = fe->copyOf();
52880:     StateRemat remat;
52880:     if (fe->data.inRegister()) {
52880:         remat.reg = fe->data.reg();
52880:         remat.inReg = true;
52880:     } else {
52880:         JS_ASSERT(fe->data.synced());
52880:         remat.offset = addressOf(fe).offset;
52880:         remat.inReg = false;
52880:     }
52880:     return remat;
52880: }
52880: 
53052: inline void
53052: FrameState::giveOwnRegs(FrameEntry *fe)
53052: {
53052:     JS_ASSERT(!fe->isConstant());
53052:     JS_ASSERT(fe == peek(-1));
53052: 
53052:     if (!fe->isCopy())
53052:         return;
53052: 
53052:     RegisterID data = copyDataIntoReg(fe);
53052:     if (fe->isTypeKnown()) {
53052:         JSValueType type = fe->getKnownType();
53052:         pop();
53052:         pushTypedPayload(type, data);
53052:     } else {
53052:         RegisterID type = copyTypeIntoReg(fe);
53052:         pop();
53052:         pushRegs(type, data);
53052:     }
53052: }
53052: 
53152: inline void
53229: FrameState::loadDouble(RegisterID t, RegisterID d, FrameEntry *fe, FPRegisterID fpReg,
53229:                        Assembler &masm) const
53229: {
53229: #ifdef JS_CPU_X86
53229:     masm.fastLoadDouble(d, t, fpReg);
53229: #else
53229:     loadDouble(fe, fpReg, masm);
53229: #endif
53229: }
53229: 
53229: inline bool
53229: FrameState::tryFastDoubleLoad(FrameEntry *fe, FPRegisterID fpReg, Assembler &masm) const
53229: {
53229: #ifdef JS_CPU_X86
53229:     if (fe->type.inRegister() && fe->data.inRegister()) {
53229:         masm.fastLoadDouble(fe->data.reg(), fe->type.reg(), fpReg);
53229:         return true;
53229:     }
53229: #endif
53229:     return false;
53229: }
53229: 
53229: inline void
53152: FrameState::loadDouble(FrameEntry *fe, FPRegisterID fpReg, Assembler &masm) const
53152: {
53152:     if (fe->isCopy()) {
53152:         FrameEntry *backing = fe->copyOf();
53229:         if (tryFastDoubleLoad(fe, fpReg, masm))
53229:             return;
53153:         if (backing->isCachedNumber() || (backing->type.synced() && backing->data.synced())) {
53152:             masm.loadDouble(addressOf(backing), fpReg);
53152:             return;
53152:         }
53152:         fe = backing;
53152:     }
53152: 
53229:     if (tryFastDoubleLoad(fe, fpReg, masm))
53229:         return;
53229: 
53153:     if ((fe->type.synced() && fe->data.synced()) || fe->isCachedNumber()) {
53153:         masm.loadDouble(addressOf(fe), fpReg);
53153:         return;
53153:     }
53153: 
53152:     Address address = addressOf(fe);
53152:     do {
53152:         if (!fe->data.synced()) {
53152:             syncData(fe, address, masm);
53152:             if (fe->isConstant())
53152:                 break;
53152:         }
53152:         if (!fe->type.synced())
53152:             syncType(fe, address, masm);
53152:     } while (0);
53152: 
53152:     masm.loadDouble(address, fpReg);
53152: }
53152: 
52618: } /* namspace mjit */
52618: } /* namspace js */
52608: 
52618: #endif /* include */
52611: 
