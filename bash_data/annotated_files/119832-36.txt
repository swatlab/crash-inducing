 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef _INC_NSSShutDown_H
     1: #define _INC_NSSShutDown_H
     1: 
     1: #include "nscore.h"
     1: #include "nspr.h"
     1: #include "pldhash.h"
 64576: #include "mozilla/CondVar.h"
 64576: #include "mozilla/Mutex.h"
     1: 
     1: class nsNSSShutDownObject;
     1: class nsOnPK11LogoutCancelObject;
     1: 
     1: // Singleton, owner by nsNSSShutDownList
     1: class nsNSSActivityState
     1: {
     1: public:
     1:   nsNSSActivityState();
     1:   ~nsNSSActivityState();
     1: 
     1:   // Call enter/leave when PSM enters a scope during which
     1:   // shutting down NSS is prohibited.
     1:   void enter();
     1:   void leave();
     1:   
     1:   // Call enter/leave when PSM is about to show a UI
     1:   // while still holding resources.
     1:   void enterBlockingUIState();
     1:   void leaveBlockingUIState();
     1:   
     1:   // Is the activity aware of any blocking PSM UI currently shown?
 79445:   bool isBlockingUIActive();
     1: 
     1:   // Is it forbidden to bring up an UI while holding resources?
 79445:   bool isUIForbidden();
     1:   
     1:   // Check whether setting the current thread restriction is possible.
     1:   // If it is possible, and the "do_it_for_real" flag is used,
     1:   // the state tracking will have ensured that we will stay in this state.
     1:   // As of writing, this includes forbidding PSM UI.
     1:   enum RealOrTesting {test_only, do_it_for_real};
 79445:   bool ifPossibleDisallowUI(RealOrTesting rot);
     1: 
     1:   // Notify the state tracking that going to the restricted state is
     1:   // no longer planned.
     1:   // As of writing, this includes clearing the "PSM UI forbidden" flag.
     1:   void allowUI();
     1: 
     1:   // If currently no UI is shown, wait for all activity to stop,
     1:   // and block any other thread on entering relevant PSM code.
     1:   PRStatus restrictActivityToCurrentThread();
     1:   
     1:   // Go back to normal state.
     1:   void releaseCurrentThreadActivityRestriction();
     1: 
     1: private:
     1:   // The lock protecting all our member variables.
 64576:   mozilla::Mutex mNSSActivityStateLock;
     1: 
     1:   // The activity variable, bound to our lock,
     1:   // used either to signal the activity counter reaches zero,
     1:   // or a thread restriction has been released.
 64576:   mozilla::CondVar mNSSActivityChanged;
     1: 
     1:   // The number of active scopes holding resources.
     1:   int mNSSActivityCounter;
     1: 
     1:   // The number of scopes holding resources while blocked
     1:   // showing an UI.
     1:   int mBlockingUICounter;
     1: 
     1:   // Whether bringing up UI is currently forbidden
 79445:   bool mIsUIForbidden;
     1: 
106838:   // nullptr means "no restriction"
119832:   // if != nullptr, activity is only allowed on that thread
     1:   PRThread* mNSSRestrictedThread;
     1: };
     1: 
     1: // Helper class that automatically enters/leaves the global activity state
     1: class nsNSSShutDownPreventionLock
     1: {
     1: public:
     1:   nsNSSShutDownPreventionLock();
     1:   ~nsNSSShutDownPreventionLock();
     1: };
     1: 
     1: // Helper class that automatically enters/leaves the global UI tracking
     1: class nsPSMUITracker
     1: {
     1: public:
     1:   nsPSMUITracker();
     1:   ~nsPSMUITracker();
     1:   
 79445:   bool isUIForbidden();
     1: };
     1: 
     1: // Singleton, used by nsNSSComponent to track the list of PSM objects,
     1: // which hold NSS resources and support the "early cleanup mechanism".
     1: class nsNSSShutDownList
     1: {
     1: public:
     1:   ~nsNSSShutDownList();
     1: 
     1:   static nsNSSShutDownList *construct();
     1:   
     1:   // track instances that support early cleanup
     1:   static void remember(nsNSSShutDownObject *o);
     1:   static void forget(nsNSSShutDownObject *o);
     1: 
     1:   // track instances that would like notification when
     1:   // a PK11 logout operation is performed.
     1:   static void remember(nsOnPK11LogoutCancelObject *o);
     1:   static void forget(nsOnPK11LogoutCancelObject *o);
     1: 
     1:   // track the creation and destruction of SSL sockets
     1:   // performed by clients using PSM services
     1:   static void trackSSLSocketCreate();
     1:   static void trackSSLSocketClose();
 79445:   static bool areSSLSocketsActive();
     1:   
     1:   // Are we able to do the early cleanup?
     1:   // Returns failure if at the current time "early cleanup" is not possible.
 79445:   bool isUIActive();
     1: 
     1:   // If possible to do "early cleanup" at the current time, remember that we want to
     1:   // do it, and disallow actions that would change the possibility.
 79445:   bool ifPossibleDisallowUI();
     1: 
     1:   // Notify that it is no longer planned to do the "early cleanup".
     1:   void allowUI();
     1:   
     1:   // Do the "early cleanup", if possible.
     1:   nsresult evaporateAllNSSResources();
     1: 
     1:   // PSM has been asked to log out of a token.
     1:   // Notify all registered instances that want to react to that event.
     1:   nsresult doPK11Logout();
     1:   
     1:   static nsNSSActivityState *getActivityState()
     1:   {
106838:     return singleton ? &singleton->mActivityState : nullptr;
     1:   }
     1:   
     1: private:
     1:   nsNSSShutDownList();
115027:   static PLDHashOperator
     1:   evaporateAllNSSResourcesHelper(PLDHashTable *table, PLDHashEntryHdr *hdr,
108991:                                                         uint32_t number, void *arg);
     1: 
115027:   static PLDHashOperator
     1:   doPK11LogoutHelper(PLDHashTable *table, PLDHashEntryHdr *hdr,
108991:                                                     uint32_t number, void *arg);
     1: protected:
 64576:   mozilla::Mutex mListLock;
     1:   static nsNSSShutDownList *singleton;
     1:   PLDHashTable mObjects;
108991:   uint32_t mActiveSSLSockets;
     1:   PLDHashTable mPK11LogoutCancelObjects;
     1:   nsNSSActivityState mActivityState;
     1: };
     1: 
     1: /*
     1:   A class deriving from nsNSSShutDownObject will have its instances
     1:   automatically tracked in a list. However, it must follow some rules
     1:   to assure correct behaviour.
     1:   
     1:   The tricky part is that it is not possible to call virtual
     1:   functions from a destructor.
     1:   
     1:   The deriving class must override virtualDestroyNSSReference().
     1:   Within this function, it should clean up all resources held to NSS.
     1:   The function will be called by the global list, if it is time to
     1:   shut down NSS before all references have been freed.
     1: 
     1:   The same code that goes into virtualDestroyNSSReference must
     1:   also be called from the destructor of the deriving class,
     1:   which is the standard cleanup (not called from the tracking list).
     1: 
     1:   Because of that duplication, it is suggested to implement a
     1:   function destructorSafeDestroyNSSReference() in the deriving
     1:   class, and make the implementation of virtualDestroyNSSReference()
     1:   call destructorSafeDestroyNSSReference().
     1: 
     1:   The destructor of the derived class should call 
     1:   destructorSafeDestroyNSSReference() and afterwards call
     1:   shutdown(calledFromObject), in order to deregister with the
     1:   tracking list, to ensure no additional attempt to free the resources
     1:   will be made.
     1:   
     1:   Function destructorSafeDestroyNSSReference() must
     1:   also ensure, that NSS resources have not been freed already.
     1:   To achieve this, the deriving class should call 
     1:   isAlreadyShutDown() to check.
     1:   
     1:   It is important that you make your implementation
     1:   failsafe, and check whether the resources have already been freed,
     1:   in each function that requires the resources.
     1:   
     1:   class derivedClass : public nsISomeInterface,
     1:                        public nsNSSShutDownObject
     1:   {
     1:     virtual void virtualDestroyNSSReference()
     1:     {
     1:       destructorSafeDestroyNSSReference();
     1:     }
     1:     
     1:     void destructorSafeDestroyNSSReference()
     1:     {
     1:       if (isAlreadyShutDown())
     1:         return;
     1:       
     1:       // clean up all NSS resources here
     1:     }
     1: 
     1:     virtual ~derivedClass()
     1:     {
     1:       destructorSafeDestroyNSSReference();
     1:       shutdown(calledFromObject);
     1:     }
     1:     
     1:     NS_IMETHODIMP doSomething()
     1:     {
     1:       if (isAlreadyShutDown())
     1:         return NS_ERROR_NOT_AVAILABLE;
     1:       
     1:       // use the NSS resources and do something
     1:     }
     1:   };
     1: */
     1: 
     1: class nsNSSShutDownObject
     1: {
     1: public:
     1: 
     1:   enum CalledFromType {calledFromList, calledFromObject};
     1: 
     1:   nsNSSShutDownObject()
     1:   {
 80486:     mAlreadyShutDown = false;
     1:     nsNSSShutDownList::remember(this);
     1:   }
     1:   
     1:   virtual ~nsNSSShutDownObject()
     1:   {
     1:     // the derived class must call 
     1:     //   shutdown(calledFromObject);
     1:     // in its destructor
     1:   }
     1:   
     1:   void shutdown(CalledFromType calledFrom)
     1:   {
     1:     if (!mAlreadyShutDown) {
     1:       if (calledFromObject == calledFrom) {
     1:         nsNSSShutDownList::forget(this);
     1:       }
     1:       if (calledFromList == calledFrom) {
     1:         virtualDestroyNSSReference();
     1:       }
 80486:       mAlreadyShutDown = true;
     1:     }
     1:   }
     1:   
 79445:   bool isAlreadyShutDown() { return mAlreadyShutDown; }
     1: 
     1: protected:
     1:   virtual void virtualDestroyNSSReference() = 0;
     1: private:
 79445:   volatile bool mAlreadyShutDown;
     1: };
     1: 
     1: class nsOnPK11LogoutCancelObject
     1: {
     1: public:
     1:   nsOnPK11LogoutCancelObject()
 80486:   :mIsLoggedOut(false)
     1:   {
     1:     nsNSSShutDownList::remember(this);
     1:   }
     1:   
     1:   virtual ~nsOnPK11LogoutCancelObject()
     1:   {
     1:     nsNSSShutDownList::forget(this);
     1:   }
     1:   
     1:   void logout()
     1:   {
     1:     // We do not care for a race condition.
     1:     // Once the bool arrived at false,
     1:     // later calls to isPK11LoggedOut() will see it.
     1:     // This is a one-time change from 0 to 1.
     1:     
 80486:     mIsLoggedOut = true;
     1:   }
     1:   
 79445:   bool isPK11LoggedOut()
     1:   {
     1:     return mIsLoggedOut;
     1:   }
     1: 
     1: private:
 79445:   volatile bool mIsLoggedOut;
     1: };
     1: 
     1: #endif
