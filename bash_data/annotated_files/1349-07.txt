   1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
   1:  * ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Oracle Corporation code.
   1:  *
   1:  * The Initial Developer of the Original Code is Oracle Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 2005
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Stuart Parmenter <pavlov@pavlov.net>
   1:  *   Vladimir Vukicevic <vladimir@pobox.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "gfxXlibSurface.h"
   1: 
   1: #include "cairo.h"
   1: #include "cairo-xlib.h"
   1: #include "cairo-xlib-xrender.h"
   1: 
   1: static cairo_user_data_key_t pixmap_free_key;
   1: 
   1: typedef struct {
   1:     Display* dpy;
   1:     Pixmap pixmap;
   1: } pixmap_free_struct;
   1: 
   1: static void pixmap_free_func (void *);
   1: 
1349: #define XLIB_IMAGE_SIDE_SIZE_LIMIT 0xffff
1349: 
   1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual)
   1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mDrawable(drawable)
   1: {
   1:     DoSizeQuery();
   1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, drawable, visual, mSize.width, mSize.height);
   1:     Init(surf);
   1: }
   1: 
   1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual, const gfxIntSize& size)
   1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mDrawable(drawable), mSize(size)
   1: {
1349:     if (!CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT))
1349:         return;
1349: 
   1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, drawable, visual, mSize.width, mSize.height);
   1:     Init(surf);
   1: }
   1: 
   1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Visual *visual, const gfxIntSize& size)
   1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mSize(size)
   1: 
   1: {
1349:     if (!CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT))
1349:         return;
1349: 
   1:     mDrawable = (Drawable)XCreatePixmap(dpy,
   1:                                         RootWindow(dpy, DefaultScreen(dpy)),
   1:                                         mSize.width, mSize.height,
   1:                                         DefaultDepth(dpy, DefaultScreen(dpy)));
   1: 
   1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, mDrawable, visual, mSize.width, mSize.height);
   1: 
   1:     Init(surf);
   1:     TakePixmap();
   1: }
   1: 
   1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, XRenderPictFormat *format,
   1:                                const gfxIntSize& size)
   1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mDrawable(drawable), mSize(size)
   1: {
1349:     if (!CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT))
1349:         return;
1349: 
   1:     cairo_surface_t *surf = cairo_xlib_surface_create_with_xrender_format(dpy, drawable,
   1:                                                                           ScreenOfDisplay(dpy,DefaultScreen(dpy)),
   1:                                                                           format, mSize.width, mSize.height);
   1:     Init(surf);
   1: }
   1: 
   1: gfxXlibSurface::gfxXlibSurface(Display *dpy, XRenderPictFormat *format, const gfxIntSize& size)
   1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mSize(size)
   1: {
   1:     mDrawable = (Drawable)XCreatePixmap(dpy,
   1:                                         RootWindow(dpy, DefaultScreen(dpy)),
   1:                                         mSize.width, mSize.height,
   1:                                         format->depth);
   1: 
   1:     cairo_surface_t *surf = cairo_xlib_surface_create_with_xrender_format(dpy, mDrawable,
   1:                                                                           ScreenOfDisplay(dpy,DefaultScreen(dpy)),
   1:                                                                           format, mSize.width, mSize.height);
   1:     Init(surf);
   1:     TakePixmap();
   1: }
   1: 
   1: gfxXlibSurface::gfxXlibSurface(cairo_surface_t *csurf)
   1:     : mPixmapTaken(PR_FALSE), mSize(-1.0, -1.0)
   1: {
   1:     mDrawable = cairo_xlib_surface_get_drawable(csurf);
   1:     mDisplay = cairo_xlib_surface_get_display(csurf);
   1: 
   1:     Init(csurf, PR_TRUE);
   1: }
   1: 
   1: gfxXlibSurface::~gfxXlibSurface()
   1: {
   1: }
   1: 
   1: void
   1: gfxXlibSurface::DoSizeQuery()
   1: {
   1:     // figure out width/height/depth
   1:     Window root_ignore;
   1:     int x_ignore, y_ignore;
   1:     unsigned int bwidth_ignore, width, height, depth;
   1: 
   1:     XGetGeometry(mDisplay,
   1:                  mDrawable,
   1:                  &root_ignore, &x_ignore, &y_ignore,
   1:                  &width, &height,
   1:                  &bwidth_ignore, &depth);
   1: 
   1:     mSize.width = width;
   1:     mSize.height = height;
   1: }
   1: 
   1: XRenderPictFormat*
   1: gfxXlibSurface::FindRenderFormat(Display *dpy, gfxImageFormat format)
   1: {
   1:     switch (format) {
   1:         case ImageFormatARGB32:
   1:             return XRenderFindStandardFormat (dpy, PictStandardARGB32);
   1:             break;
   1:         case ImageFormatRGB24:
   1:             return XRenderFindStandardFormat (dpy, PictStandardRGB24);
   1:             break;
   1:         case ImageFormatA8:
   1:             return XRenderFindStandardFormat (dpy, PictStandardA8);
   1:             break;
   1:         case ImageFormatA1:
   1:             return XRenderFindStandardFormat (dpy, PictStandardA1);
   1:             break;
   1:         default:
   1:             return NULL;
   1:     }
   1: 
   1:     return (XRenderPictFormat*)NULL;
   1: }
   1: 
   1: void
   1: gfxXlibSurface::TakePixmap()
   1: {
   1:     if (mPixmapTaken)
   1:         return;
   1: 
   1:     pixmap_free_struct *pfs = new pixmap_free_struct;
   1:     pfs->dpy = mDisplay;
   1:     pfs->pixmap = mDrawable;
   1: 
   1:     cairo_surface_set_user_data (CairoSurface(),
   1:                                  &pixmap_free_key,
   1:                                  pfs,
   1:                                  pixmap_free_func);
   1: 
   1:     mPixmapTaken = PR_TRUE;
   1: }
   1: 
   1: void
   1: pixmap_free_func (void *data)
   1: {
   1:     pixmap_free_struct *pfs = (pixmap_free_struct*) data;
   1: 
   1:     XFreePixmap (pfs->dpy, pfs->pixmap);
   1: 
   1:     delete pfs;
   1: }
