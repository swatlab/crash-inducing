     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Base class for all our document implementations.
     1:  */
     1: 
     1: #ifndef nsDocument_h___
     1: #define nsDocument_h___
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsCRT.h"
     1: #include "nsIDocument.h"
     1: #include "nsWeakReference.h"
     1: #include "nsWeakPtr.h"
     1: #include "nsVoidArray.h"
 26413: #include "nsTArray.h"
     1: #include "nsIDOMXMLDocument.h"
     1: #include "nsIDOMDocumentXBL.h"
     1: #include "nsStubDocumentObserver.h"
     1: #include "nsIDOMStyleSheetList.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIDOMEventTarget.h"
     1: #include "nsIContent.h"
 72328: #include "nsEventListenerManager.h"
 16106: #include "nsIDOMNodeSelector.h"
     1: #include "nsIPrincipal.h"
     1: #include "nsIParser.h"
     1: #include "nsBindingManager.h"
 94340: #include "nsINodeInfo.h"
     1: #include "nsHashtable.h"
     1: #include "nsInterfaceHashtable.h"
     1: #include "nsIBoxObject.h"
     1: #include "nsPIBoxObject.h"
     1: #include "nsIScriptObjectPrincipal.h"
     1: #include "nsIURI.h"
     1: #include "nsScriptLoader.h"
     1: #include "nsIRadioGroupContainer.h"
     1: #include "nsILayoutHistoryState.h"
     1: #include "nsIRequest.h"
     1: #include "nsILoadGroup.h"
     1: #include "nsTObserverArray.h"
     1: #include "nsStubMutationObserver.h"
     1: #include "nsIChannel.h"
     1: #include "nsCycleCollectionParticipant.h"
 15474: #include "nsContentList.h"
 16977: #include "nsGkAtoms.h"
 18430: #include "nsIApplicationCache.h"
 18430: #include "nsIApplicationCacheContainer.h"
     1: #include "nsStyleSet.h"
     1: #include "pldhash.h"
     1: #include "nsAttrAndChildArray.h"
     1: #include "nsDOMAttributeMap.h"
 16977: #include "nsThreadUtils.h"
 80401: #include "nsIContentViewer.h"
 29215: #include "nsIDOMXPathNSResolver.h"
 20078: #include "nsIInterfaceRequestor.h"
 21877: #include "nsILoadContext.h"
 21877: #include "nsIProgressEventSink.h"
 21877: #include "nsISecurityEventSink.h"
 21877: #include "nsIChannelEventSink.h"
 30065: #include "imgIRequest.h"
 34007: #include "nsIDOMDOMImplementation.h"
 68879: #include "nsIDOMTouchEvent.h"
 77149: #include "nsIInlineEventHandlers.h"
 75263: #include "nsDataHashtable.h"
 78320: #include "mozilla/TimeStamp.h"
 72298: 
     1: #define XML_DECLARATION_BITS_DECLARATION_EXISTS   (1 << 0)
     1: #define XML_DECLARATION_BITS_ENCODING_EXISTS      (1 << 1)
     1: #define XML_DECLARATION_BITS_STANDALONE_EXISTS    (1 << 2)
     1: #define XML_DECLARATION_BITS_STANDALONE_YES       (1 << 3)
     1: 
     1: 
 72328: class nsEventListenerManager;
     1: class nsDOMStyleSheetList;
     1: class nsDOMStyleSheetSetList;
     1: class nsIOutputStream;
     1: class nsDocument;
     1: class nsIDTD;
     1: class nsIRadioVisitor;
     1: class nsIFormControl;
     1: struct nsRadioGroupStruct;
     1: class nsOnloadBlocker;
     1: class nsUnblockOnloadEvent;
     1: class nsChildContentList;
 42984: class nsXMLEventsManager;
 42984: class nsHTMLStyleSheet;
 42984: class nsHTMLCSSStyleSheet;
 72298: class nsDOMNavigationTiming;
 91403: class nsWindowSizes;
 94004: class nsHtml5TreeOpExecutor;
     1: 
 15474: /**
 15474:  * Right now our identifier map entries contain information for 'name'
 15474:  * and 'id' mappings of a given string. This is so that
 15474:  * nsHTMLDocument::ResolveName only has to do one hash lookup instead
 15474:  * of two. It's not clear whether this still matters for performance.
 15474:  * 
 15474:  * We also store the document.all result list here. This is mainly so that
 15474:  * when all elements with the given ID are removed and we remove
 15474:  * the ID's nsIdentifierMapEntry, the document.all result is released too.
 15474:  * Perhaps the document.all results should have their own hashtable
 15474:  * in nsHTMLDocument.
 15474:  */
 43946: class nsIdentifierMapEntry : public nsStringHashKey
 15474: {
 15474: public:
 42325:   typedef mozilla::dom::Element Element;
 42325:   
 43946:   nsIdentifierMapEntry(const nsAString& aKey) :
 43946:     nsStringHashKey(&aKey), mNameContentList(nsnull)
 43946:   {
 43946:   }
 43946:   nsIdentifierMapEntry(const nsAString *aKey) :
 43946:     nsStringHashKey(aKey), mNameContentList(nsnull)
 15474:   {
 15474:   }
 15474:   nsIdentifierMapEntry(const nsIdentifierMapEntry& aOther) :
 43946:     nsStringHashKey(&aOther.GetKey())
 15474:   {
 15474:     NS_ERROR("Should never be called");
 15474:   }
 15474:   ~nsIdentifierMapEntry();
 15474: 
 15474:   void SetInvalidName();
 79445:   bool IsInvalidName();
 69024:   void AddNameElement(nsIDocument* aDocument, Element* aElement);
 42325:   void RemoveNameElement(Element* aElement);
 79445:   bool IsEmpty();
 15474:   nsBaseContentList* GetNameContentList() {
 15474:     return mNameContentList;
 15474:   }
 15474: 
 15474:   /**
 15474:    * Returns the element if we know the element associated with this
 15474:    * id. Otherwise returns null.
 15474:    */
 42325:   Element* GetIdElement();
 26475:   /**
 81140:    * Returns the list of all elements associated with this id.
 81140:    */
 81140:   const nsSmallVoidArray* GetIdElements() const {
 81140:     return &mIdContentList;
 81140:   }
 81140:   /**
 50428:    * If this entry has a non-null image element set (using SetImageElement),
 50428:    * the image element will be returned, otherwise the same as GetIdElement().
 50428:    */
 50428:   Element* GetImageIdElement();
 50428:   /**
 26475:    * Append all the elements with this id to aElements
 26475:    */
 15475:   void AppendAllIdContent(nsCOMArray<nsIContent>* aElements);
 15515:   /**
 15515:    * This can fire ID change callbacks.
 15515:    * @return true if the content could be added, false if we failed due
 15515:    * to OOM.
 15515:    */
 79445:   bool AddIdElement(Element* aElement);
 15475:   /**
 15515:    * This can fire ID change callbacks.
 15475:    */
 50428:   void RemoveIdElement(Element* aElement);
 50428:   /**
 50428:    * Set the image element override for this ID. This will be returned by
 80486:    * GetIdElement(true) if non-null.
 50428:    */
 50428:   void SetImageElement(Element* aElement);
 15474: 
 79445:   bool HasContentChangeCallback() { return mChangeCallbacks != nsnull; }
 50428:   void AddContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
 79445:                                 void* aData, bool aForImage);
 50428:   void RemoveContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
 79445:                                 void* aData, bool aForImage);
 15515: 
 15474:   void Traverse(nsCycleCollectionTraversalCallback* aCallback);
 15474: 
 15474:   void SetDocAllList(nsContentList* aContentList) { mDocAllList = aContentList; }
 15474:   nsContentList* GetDocAllList() { return mDocAllList; }
 15474: 
 15515:   struct ChangeCallback {
 15515:     nsIDocument::IDTargetObserver mCallback;
 15515:     void* mData;
 79445:     bool mForImage;
 15515:   };
 15515: 
 15515:   struct ChangeCallbackEntry : public PLDHashEntryHdr {
 15515:     typedef const ChangeCallback KeyType;
 15515:     typedef const ChangeCallback* KeyTypePointer;
 15515: 
 15515:     ChangeCallbackEntry(const ChangeCallback* key) :
 15515:       mKey(*key) { }
 15515:     ChangeCallbackEntry(const ChangeCallbackEntry& toCopy) :
 15515:       mKey(toCopy.mKey) { }
 15515: 
 15515:     KeyType GetKey() const { return mKey; }
 79445:     bool KeyEquals(KeyTypePointer aKey) const {
 15515:       return aKey->mCallback == mKey.mCallback &&
 50428:              aKey->mData == mKey.mData &&
 50428:              aKey->mForImage == mKey.mForImage;
 15515:     }
 15515: 
 15515:     static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
 15515:     static PLDHashNumber HashKey(KeyTypePointer aKey)
 15515:     {
 92143:       return mozilla::HashGeneric(aKey->mCallback, aKey->mData);
 15515:     }
 80486:     enum { ALLOW_MEMMOVE = true };
 15515:     
 15515:     ChangeCallback mKey;
 15515:   };
 15515: 
 15474: private:
 50428:   void FireChangeCallbacks(Element* aOldElement, Element* aNewElement,
 79445:                            bool aImageOnly = false);
 15515: 
 41635:   // empty if there are no elements with this ID.
 51858:   // The elements are stored as weak pointers.
 15474:   nsSmallVoidArray mIdContentList;
 68823:   nsRefPtr<nsBaseContentList> mNameContentList;
 15474:   nsRefPtr<nsContentList> mDocAllList;
 15515:   nsAutoPtr<nsTHashtable<ChangeCallbackEntry> > mChangeCallbacks;
 51986:   nsRefPtr<Element> mImageElement;
 15474: };
     1: 
     1: class nsDocHeaderData
     1: {
     1: public:
     1:   nsDocHeaderData(nsIAtom* aField, const nsAString& aData)
     1:     : mField(aField), mData(aData), mNext(nsnull)
     1:   {
     1:   }
     1: 
     1:   ~nsDocHeaderData(void)
     1:   {
     1:     delete mNext;
     1:   }
     1: 
     1:   nsCOMPtr<nsIAtom> mField;
     1:   nsString          mData;
     1:   nsDocHeaderData*  mNext;
     1: };
     1: 
     1: class nsDOMStyleSheetList : public nsIDOMStyleSheetList,
     1:                             public nsStubDocumentObserver
     1: {
     1: public:
     1:   nsDOMStyleSheetList(nsIDocument *aDocument);
     1:   virtual ~nsDOMStyleSheetList();
     1: 
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   NS_DECL_NSIDOMSTYLESHEETLIST
     1: 
     1:   // nsIDocumentObserver
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETADDED
 56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETREMOVED
 56166: 
 56166:   // nsIMutationObserver
 56166:   NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
     1: 
 20752:   nsIStyleSheet* GetItemAt(PRUint32 aIndex);
 20752: 
 20752:   static nsDOMStyleSheetList* FromSupports(nsISupports* aSupports)
 20752:   {
 20752:     nsIDOMStyleSheetList* list = static_cast<nsIDOMStyleSheetList*>(aSupports);
 20752: #ifdef DEBUG
 20752:     {
 20752:       nsCOMPtr<nsIDOMStyleSheetList> list_qi = do_QueryInterface(aSupports);
 20752: 
 20752:       // If this assertion fires the QI implementation for the object in
 20752:       // question doesn't use the nsIDOMStyleSheetList pointer as the
 20752:       // nsISupports pointer. That must be fixed, or we'll crash...
 20752:       NS_ASSERTION(list_qi == list, "Uh, fix QI!");
 20752:     }
 20752: #endif
 20752:     return static_cast<nsDOMStyleSheetList*>(list);
 20752:   }
 20752: 
     1: protected:
     1:   PRInt32       mLength;
     1:   nsIDocument*  mDocument;
     1: };
     1: 
     1: class nsOnloadBlocker : public nsIRequest
     1: {
     1: public:
     1:   nsOnloadBlocker() {}
     1: 
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_NSIREQUEST
     1: 
     1: private:
     1:   ~nsOnloadBlocker() {}
     1: };
     1: 
 20078: class nsExternalResourceMap
 20078: {
 20078: public:
 20078:   typedef nsIDocument::ExternalResourceLoad ExternalResourceLoad;
 20078:   nsExternalResourceMap();
 20078: 
 20078:   /**
 20078:    * Request an external resource document.  This does exactly what
 20078:    * nsIDocument::RequestExternalResource is documented to do.
 20078:    */
 20078:   nsIDocument* RequestResource(nsIURI* aURI,
 20078:                                nsINode* aRequestingNode,
 20078:                                nsDocument* aDisplayDocument,
 20078:                                ExternalResourceLoad** aPendingLoad);
 20078: 
 20078:   /**
 20078:    * Enumerate the resource documents.  See
 20078:    * nsIDocument::EnumerateExternalResources.
 20078:    */
 20078:   void EnumerateResources(nsIDocument::nsSubDocEnumFunc aCallback, void* aData);
 20078: 
 20078:   /**
 20078:    * Traverse ourselves for cycle-collection
 20078:    */
 20078:   void Traverse(nsCycleCollectionTraversalCallback* aCallback) const;
 20078: 
 20078:   /**
 20078:    * Shut ourselves down (used for cycle-collection unlink), as well
 20078:    * as for document destruction.
 20078:    */
 20078:   void Shutdown()
 20078:   {
 20078:     mPendingLoads.Clear();
 20078:     mMap.Clear();
 80486:     mHaveShutDown = true;
 20078:   }
 20078: 
 79445:   bool HaveShutDown() const
 20078:   {
 20078:     return mHaveShutDown;
 20078:   }
 20078: 
 20078:   // Needs to be public so we can traverse them sanely
 20078:   struct ExternalResource
 20078:   {
 20078:     ~ExternalResource();
 20078:     nsCOMPtr<nsIDocument> mDocument;
 20078:     nsCOMPtr<nsIContentViewer> mViewer;
 20078:     nsCOMPtr<nsILoadGroup> mLoadGroup;
 20078:   };
 20078: 
 49570:   // Hide all our viewers
 49570:   void HideViewers();
 49570: 
 49570:   // Show all our viewers
 49570:   void ShowViewers();
 49570: 
 20078: protected:
 20078:   class PendingLoad : public ExternalResourceLoad,
 20078:                       public nsIStreamListener
 20078:   {
 20078:   public:
 20078:     PendingLoad(nsDocument* aDisplayDocument) :
 20078:       mDisplayDocument(aDisplayDocument)
 20078:     {}
 20078: 
 20078:     NS_DECL_ISUPPORTS
 20078:     NS_DECL_NSISTREAMLISTENER
 20078:     NS_DECL_NSIREQUESTOBSERVER
 20078: 
 20078:     /**
 20078:      * Start aURI loading.  This will perform the necessary security checks and
 20078:      * so forth.
 20078:      */
 20078:     nsresult StartLoad(nsIURI* aURI, nsINode* aRequestingNode);
 20078: 
 20078:     /**
 80401:      * Set up an nsIContentViewer based on aRequest.  This is guaranteed to
 20078:      * put null in *aViewer and *aLoadGroup on all failures.
 20078:      */
 80401:     nsresult SetupViewer(nsIRequest* aRequest, nsIContentViewer** aViewer,
 20078:                          nsILoadGroup** aLoadGroup);
 20078: 
 20078:   private:
 20078:     nsRefPtr<nsDocument> mDisplayDocument;
 20078:     nsCOMPtr<nsIStreamListener> mTargetListener;
 20078:     nsCOMPtr<nsIURI> mURI;
 20078:   };
 20078:   friend class PendingLoad;
 20078: 
 20078:   class LoadgroupCallbacks : public nsIInterfaceRequestor
 20078:   {
 20078:   public:
 20078:     LoadgroupCallbacks(nsIInterfaceRequestor* aOtherCallbacks)
 20078:       : mCallbacks(aOtherCallbacks)
 20078:     {}
 20078:     NS_DECL_ISUPPORTS
 20078:     NS_DECL_NSIINTERFACEREQUESTOR
 20078:   private:
 21877:     // The only reason it's safe to hold a strong ref here without leaking is
 21877:     // that the notificationCallbacks on a loadgroup aren't the docshell itself
 21877:     // but a shim that holds a weak reference to the docshell.
 20078:     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
 21877: 
 21877:     // Use shims for interfaces that docshell implements directly so that we
 21877:     // don't hand out references to the docshell.  The shims should all allow
 21877:     // getInterface back on us, but other than that each one should only
 21877:     // implement one interface.
 21877:     
 21877:     // XXXbz I wish we could just derive the _allcaps thing from _i
 21877: #define DECL_SHIM(_i, _allcaps)                                              \
 21877:     class _i##Shim : public nsIInterfaceRequestor,                           \
 21877:                      public _i                                               \
 21877:     {                                                                        \
 21877:     public:                                                                  \
 21877:       _i##Shim(nsIInterfaceRequestor* aIfreq, _i* aRealPtr)                  \
 21877:         : mIfReq(aIfreq), mRealPtr(aRealPtr)                                 \
 21877:       {                                                                      \
 21877:         NS_ASSERTION(mIfReq, "Expected non-null here");                      \
 21877:         NS_ASSERTION(mRealPtr, "Expected non-null here");                    \
 21877:       }                                                                      \
 21877:       NS_DECL_ISUPPORTS                                                      \
 21877:       NS_FORWARD_NSIINTERFACEREQUESTOR(mIfReq->);                            \
 21877:       NS_FORWARD_##_allcaps(mRealPtr->);                                     \
 21877:     private:                                                                 \
 21877:       nsCOMPtr<nsIInterfaceRequestor> mIfReq;                                \
 21877:       nsCOMPtr<_i> mRealPtr;                                                 \
 21877:     };
 21877: 
 21877:     DECL_SHIM(nsILoadContext, NSILOADCONTEXT)
 21877:     DECL_SHIM(nsIProgressEventSink, NSIPROGRESSEVENTSINK)
 21877:     DECL_SHIM(nsIChannelEventSink, NSICHANNELEVENTSINK)
 21877:     DECL_SHIM(nsISecurityEventSink, NSISECURITYEVENTSINK)
 21877:     DECL_SHIM(nsIApplicationCacheContainer, NSIAPPLICATIONCACHECONTAINER)
 21877: #undef DECL_SHIM
 20078:   };
 20078:   
 20078:   /**
 20078:    * Add an ExternalResource for aURI.  aViewer and aLoadGroup might be null
 20078:    * when this is called if the URI didn't result in an XML document.  This
 20078:    * function makes sure to remove the pending load for aURI, if any, from our
 20078:    * hashtable, and to notify its observers, if any.
 20078:    */
 80401:   nsresult AddExternalResource(nsIURI* aURI, nsIContentViewer* aViewer,
 20078:                                nsILoadGroup* aLoadGroup,
 20078:                                nsIDocument* aDisplayDocument);
 20078:   
 20078:   nsClassHashtable<nsURIHashKey, ExternalResource> mMap;
 20078:   nsRefPtrHashtable<nsURIHashKey, PendingLoad> mPendingLoads;
 79445:   bool mHaveShutDown;
 20078: };
 20078: 
     1: // Base class for our document implementations.
     1: //
     1: // Note that this class *implements* nsIDOMXMLDocument, but it's not
     1: // really an nsIDOMXMLDocument. The reason for implementing
     1: // nsIDOMXMLDocument on this class is to avoid having to duplicate all
     1: // its inherited methods on document classes that *are*
     1: // nsIDOMXMLDocument's. nsDocument's QI should *not* claim to support
     1: // nsIDOMXMLDocument unless someone writes a real implementation of
     1: // the interface.
     1: class nsDocument : public nsIDocument,
     1:                    public nsIDOMXMLDocument, // inherits nsIDOMDocument
     1:                    public nsIDOMDocumentXBL,
     1:                    public nsSupportsWeakReference,
     1:                    public nsIScriptObjectPrincipal,
 74019:                    public nsIRadioGroupContainer,
 18430:                    public nsIApplicationCacheContainer,
 68879:                    public nsStubMutationObserver,
 77149:                    public nsIDOMDocumentTouch,
 98051:                    public nsIInlineEventHandlers,
 98051:                    public nsIObserver
     1: {
     1: public:
 44178:   typedef mozilla::dom::Element Element;
 44178: 
     1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 91403: 
 91403:   NS_DECL_SIZEOF_EXCLUDING_THIS
     1: 
     1:   virtual void Reset(nsIChannel *aChannel, nsILoadGroup *aLoadGroup);
     1:   virtual void ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
     1:                           nsIPrincipal* aPrincipal);
     1: 
     1:   // StartDocumentLoad is pure virtual so that subclasses must override it.
     1:   // The nsDocument StartDocumentLoad does some setup, but does NOT set
     1:   // *aDocListener; this is the job of subclasses.
     1:   virtual nsresult StartDocumentLoad(const char* aCommand,
     1:                                      nsIChannel* aChannel,
     1:                                      nsILoadGroup* aLoadGroup,
     1:                                      nsISupports* aContainer,
     1:                                      nsIStreamListener **aDocListener,
 79445:                                      bool aReset = true,
     1:                                      nsIContentSink* aContentSink = nsnull) = 0;
     1: 
     1:   virtual void StopDocumentLoad();
     1: 
 79445:   virtual void NotifyPossibleTitleChange(bool aBoundTitleElement);
 16977: 
     1:   virtual void SetDocumentURI(nsIURI* aURI);
     1: 
     1:   /**
     1:    * Set the principal responsible for this document.
     1:    */
     1:   virtual void SetPrincipal(nsIPrincipal *aPrincipal);
     1: 
     1:   /**
     1:    * Get the Content-Type of this document.
     1:    */
     1:   // NS_IMETHOD GetContentType(nsAString& aContentType);
 70983:   // Already declared in nsIDOMDocument
     1: 
     1:   /**
     1:    * Set the Content-Type of this document.
     1:    */
     1:   virtual void SetContentType(const nsAString& aContentType);
     1: 
     1:   virtual nsresult SetBaseURI(nsIURI* aURI);
     1: 
     1:   /**
     1:    * Get/Set the base target of a link in a document.
     1:    */
 41221:   virtual void GetBaseTarget(nsAString &aBaseTarget);
     1: 
     1:   /**
     1:    * Return a standard name for the document's character set. This will
     1:    * trigger a startDocumentLoad if necessary to answer the question.
     1:    */
     1:   virtual void SetDocumentCharacterSet(const nsACString& aCharSetID);
     1: 
     1:   /**
     1:    * Add an observer that gets notified whenever the charset changes.
     1:    */
     1:   virtual nsresult AddCharSetObserver(nsIObserver* aObserver);
     1: 
     1:   /**
     1:    * Remove a charset observer.
     1:    */
     1:   virtual void RemoveCharSetObserver(nsIObserver* aObserver);
     1: 
 42325:   virtual Element* AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
 79445:                                        void* aData, bool aForImage);
 50428:   virtual void RemoveIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
 79445:                                       void* aData, bool aForImage);
 15515: 
     1:   /**
     1:    * Access HTTP header data (this may also get set from other sources, like
     1:    * HTML META tags).
     1:    */
     1:   virtual void GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const;
     1:   virtual void SetHeaderData(nsIAtom* aheaderField,
     1:                              const nsAString& aData);
     1: 
     1:   /**
     1:    * Create a new presentation shell that will use aContext for
 24112:    * its presentation context (presentation context's <b>must not</b> be
     1:    * shared among multiple presentation shell's).
     1:    */
     1:   virtual nsresult CreateShell(nsPresContext* aContext,
     1:                                nsIViewManager* aViewManager,
     1:                                nsStyleSet* aStyleSet,
     1:                                nsIPresShell** aInstancePtrResult);
 49570:   virtual void DeleteShell();
     1: 
 81062:   virtual nsresult SetSubDocumentFor(Element* aContent,
     1:                                      nsIDocument* aSubDoc);
     1:   virtual nsIDocument* GetSubDocumentFor(nsIContent* aContent) const;
 81062:   virtual Element* FindContentForSubDocument(nsIDocument *aDocument) const;
 42325:   virtual Element* GetRootElementInternal() const;
     1: 
     1:   /**
     1:    * Get the style sheets owned by this document.
     1:    * These are ordered, highest priority last
     1:    */
     1:   virtual PRInt32 GetNumberOfStyleSheets() const;
     1:   virtual nsIStyleSheet* GetStyleSheetAt(PRInt32 aIndex) const;
     1:   virtual PRInt32 GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const;
     1:   virtual void AddStyleSheet(nsIStyleSheet* aSheet);
     1:   virtual void RemoveStyleSheet(nsIStyleSheet* aSheet);
     1: 
     1:   virtual void UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
     1:                                  nsCOMArray<nsIStyleSheet>& aNewSheets);
     1:   virtual void AddStyleSheetToStyleSets(nsIStyleSheet* aSheet);
     1:   virtual void RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet);
     1: 
     1:   virtual void InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex);
     1:   virtual void SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
 79445:                                             bool aApplicable);
     1: 
     1:   virtual PRInt32 GetNumberOfCatalogStyleSheets() const;
     1:   virtual nsIStyleSheet* GetCatalogStyleSheetAt(PRInt32 aIndex) const;
     1:   virtual void AddCatalogStyleSheet(nsIStyleSheet* aSheet);
     1:   virtual void EnsureCatalogStyleSheet(const char *aStyleSheetURI);
     1: 
     1:   virtual nsIChannel* GetChannel() const {
     1:     return mChannel;
     1:   }
     1: 
     1:   /**
     1:    * Get this document's inline style sheet.  May return null if there
     1:    * isn't one
     1:    */
 36782:   virtual nsHTMLCSSStyleSheet* GetInlineStyleSheet() const {
     1:     return mStyleAttrStyleSheet;
     1:   }
     1:   
     1:   /**
     1:    * Set the object from which a document can get a script context.
     1:    * This is the context within which all scripts (during document
     1:    * creation and during event handling) will run.
     1:    */
     1:   virtual nsIScriptGlobalObject* GetScriptGlobalObject() const;
     1:   virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aGlobalObject);
     1: 
  6475:   virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject);
  6475: 
     1:   virtual nsIScriptGlobalObject* GetScopeObject();
     1: 
     1:   /**
     1:    * Get the script loader for this document
     1:    */
  2007:   virtual nsScriptLoader* ScriptLoader();
     1: 
     1:   /**
 43079:    * Add/Remove an element to the document's id and name hashes
 43079:    */
 50428:   virtual void AddToIdTable(Element* aElement, nsIAtom* aId);
 50428:   virtual void RemoveFromIdTable(Element* aElement, nsIAtom* aId);
 50428:   virtual void AddToNameTable(Element* aElement, nsIAtom* aName);
 50428:   virtual void RemoveFromNameTable(Element* aElement, nsIAtom* aName);
 43079: 
 43079:   /**
     1:    * Add a new observer of document change notifications. Whenever
     1:    * content is changed, appended, inserted or removed the observers are
     1:    * informed.
     1:    */
     1:   virtual void AddObserver(nsIDocumentObserver* aObserver);
     1: 
     1:   /**
     1:    * Remove an observer of document change notifications. This will
     1:    * return false if the observer cannot be found.
     1:    */
 79445:   virtual bool RemoveObserver(nsIDocumentObserver* aObserver);
     1: 
     1:   // Observation hooks used to propagate notifications to document
     1:   // observers.
     1:   virtual void BeginUpdate(nsUpdateType aUpdateType);
     1:   virtual void EndUpdate(nsUpdateType aUpdateType);
     1:   virtual void BeginLoad();
     1:   virtual void EndLoad();
 23639: 
 23639:   virtual void SetReadyStateInternal(ReadyState rs);
 29975:   virtual ReadyState GetReadyStateEnum();
 23639: 
 64120:   virtual void ContentStateChanged(nsIContent* aContent,
 56168:                                    nsEventStates aStateMask);
 56168:   virtual void DocumentStatesChanged(nsEventStates aStateMask);
     1: 
     1:   virtual void StyleRuleChanged(nsIStyleSheet* aStyleSheet,
     1:                                 nsIStyleRule* aOldStyleRule,
     1:                                 nsIStyleRule* aNewStyleRule);
     1:   virtual void StyleRuleAdded(nsIStyleSheet* aStyleSheet,
     1:                               nsIStyleRule* aStyleRule);
     1:   virtual void StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
     1:                                 nsIStyleRule* aStyleRule);
     1: 
     1:   virtual void FlushPendingNotifications(mozFlushType aType);
 40701:   virtual void FlushExternalResources(mozFlushType aType);
     1:   virtual void SetXMLDeclaration(const PRUnichar *aVersion,
     1:                                  const PRUnichar *aEncoding,
     1:                                  const PRInt32 aStandalone);
     1:   virtual void GetXMLDeclaration(nsAString& aVersion,
     1:                                  nsAString& aEncoding,
     1:                                  nsAString& Standalone);
 79445:   virtual bool IsScriptEnabled();
     1: 
 79445:   virtual void OnPageShow(bool aPersisted, nsIDOMEventTarget* aDispatchStartTarget);
 79445:   virtual void OnPageHide(bool aPersisted, nsIDOMEventTarget* aDispatchStartTarget);
     1:   
    62:   virtual void WillDispatchMutationEvent(nsINode* aTarget);
    62:   virtual void MutationEventDispatched(nsINode* aTarget);
    62: 
     1:   // nsINode
 79445:   virtual bool IsNodeOfType(PRUint32 aFlags) const;
 71768:   virtual PRUint16 NodeType();
 71768:   virtual void NodeName(nsAString& aNodeName);
     1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
 22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const;
     1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
     1:   virtual PRUint32 GetChildCount() const;
     1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
 79445:                                  bool aNotify);
 79445:   virtual nsresult AppendChildTo(nsIContent* aKid, bool aNotify);
 94359:   virtual void RemoveChildAt(PRUint32 aIndex, bool aNotify);
 94340:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
     1:   {
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1:   }
     1: 
     1:   // nsIRadioGroupContainer
     1:   NS_IMETHOD WalkRadioGroup(const nsAString& aName,
     1:                             nsIRadioVisitor* aVisitor,
 79445:                             bool aFlushContent);
     1:   NS_IMETHOD SetCurrentRadioButton(const nsAString& aName,
     1:                                    nsIDOMHTMLInputElement* aRadio);
     1:   NS_IMETHOD GetCurrentRadioButton(const nsAString& aName,
     1:                                    nsIDOMHTMLInputElement** aRadio);
     1:   NS_IMETHOD GetNextRadioButton(const nsAString& aName,
 79445:                                 const bool aPrevious,
     1:                                 nsIDOMHTMLInputElement*  aFocusedRadio,
     1:                                 nsIDOMHTMLInputElement** aRadioOut);
     1:   NS_IMETHOD AddToRadioGroup(const nsAString& aName,
     1:                              nsIFormControl* aRadio);
     1:   NS_IMETHOD RemoveFromRadioGroup(const nsAString& aName,
     1:                                   nsIFormControl* aRadio);
 63105:   virtual PRUint32 GetRequiredRadioCount(const nsAString& aName) const;
 63105:   virtual void RadioRequiredChanged(const nsAString& aName,
 63105:                                     nsIFormControl* aRadio);
 63107:   virtual bool GetValueMissingState(const nsAString& aName) const;
 63107:   virtual void SetValueMissingState(const nsAString& aName, bool aValue);
     1: 
     1:   // for radio group
 95441:   nsRadioGroupStruct* GetRadioGroup(const nsAString& aName);
     1: 
     1:   // nsIDOMNode
     1:   NS_DECL_NSIDOMNODE
     1: 
     1:   // nsIDOMDocument
     1:   NS_DECL_NSIDOMDOCUMENT
     1: 
     1:   // nsIDOMXMLDocument
     1:   NS_DECL_NSIDOMXMLDOCUMENT
     1: 
     1:   // nsIDOMDocumentXBL
     1:   NS_DECL_NSIDOMDOCUMENTXBL
     1: 
     1:   // nsIDOMEventTarget
 72324:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
 72328:   virtual nsEventListenerManager*
 79445:     GetListenerManager(bool aCreateIfNotFound);
     1: 
     1:   // nsIScriptObjectPrincipal
     1:   virtual nsIPrincipal* GetPrincipal();
     1: 
 18430:   // nsIApplicationCacheContainer
 18430:   NS_DECL_NSIAPPLICATIONCACHECONTAINER
 18430: 
 77145:   // nsITouchEventReceiver
 77145:   NS_DECL_NSITOUCHEVENTRECEIVER
 77145: 
 68879:   // nsIDOMDocumentTouch
 68879:   NS_DECL_NSIDOMDOCUMENTTOUCH
 68879: 
 77149:   // nsIInlineEventHandlers
 77149:   NS_DECL_NSIINLINEEVENTHANDLERS
 77149: 
 98051:   // nsIObserver
 98051:   NS_DECL_NSIOBSERVER
 98051: 
     1:   virtual nsresult Init();
     1:   
 72956:   virtual void AddXMLEventsContent(nsIContent * aXMLEventsElement);
     1: 
 48124:   virtual nsresult CreateElem(const nsAString& aName, nsIAtom *aPrefix,
     1:                               PRInt32 aNamespaceID,
     1:                               nsIContent **aResult);
     1: 
 48124:   nsresult CreateElement(const nsAString& aTagName,
 48124:                          nsIContent** aReturn);
 58484:   nsresult CreateElementNS(const nsAString& aNamespaceURI,
 58484:                            const nsAString& aQualifiedName,
 58484:                            nsIContent** aReturn);
 48124: 
 48124:   nsresult CreateTextNode(const nsAString& aData, nsIContent** aReturn);
 48124: 
     1:   virtual NS_HIDDEN_(nsresult) Sanitize();
     1: 
     1:   virtual NS_HIDDEN_(void) EnumerateSubDocuments(nsSubDocEnumFunc aCallback,
     1:                                                  void *aData);
     1: 
 79445:   virtual NS_HIDDEN_(bool) CanSavePresentation(nsIRequest *aNewRequest);
     1:   virtual NS_HIDDEN_(void) Destroy();
 14469:   virtual NS_HIDDEN_(void) RemovedFromDocShell();
     1:   virtual NS_HIDDEN_(already_AddRefed<nsILayoutHistoryState>) GetLayoutHistoryState() const;
     1: 
     1:   virtual NS_HIDDEN_(void) BlockOnload();
 79445:   virtual NS_HIDDEN_(void) UnblockOnload(bool aFireSync);
     1: 
 38488:   virtual NS_HIDDEN_(void) AddStyleRelevantLink(mozilla::dom::Link* aLink);
 38488:   virtual NS_HIDDEN_(void) ForgetLink(mozilla::dom::Link* aLink);
     1: 
     1:   NS_HIDDEN_(void) ClearBoxObjectFor(nsIContent* aContent);
 26701:   NS_IMETHOD GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult);
     1: 
     1:   virtual NS_HIDDEN_(nsresult) GetXBLChildNodesFor(nsIContent* aContent,
     1:                                                    nsIDOMNodeList** aResult);
     1:   virtual NS_HIDDEN_(nsresult) GetContentListFor(nsIContent* aContent,
     1:                                                  nsIDOMNodeList** aResult);
 99618:   virtual NS_HIDDEN_(nsIContent*)
 99618:     GetAnonymousElementByAttribute(nsIContent* aElement,
 99618:                                    nsIAtom* aAttrName,
 99618:                                    const nsAString& aAttrValue) const;
 21333: 
 40200:   virtual NS_HIDDEN_(nsresult) ElementFromPointHelper(float aX, float aY,
 79445:                                                       bool aIgnoreRootScrollFrame,
 79445:                                                       bool aFlushLayout,
 21333:                                                       nsIDOMElement** aReturn);
 21333: 
 40568:   virtual NS_HIDDEN_(nsresult) NodesFromRectHelper(float aX, float aY,
 40568:                                                    float aTopSize, float aRightSize,
 40568:                                                    float aBottomSize, float aLeftSize,
 79445:                                                    bool aIgnoreRootScrollFrame,
 79445:                                                    bool aFlushLayout,
 40568:                                                    nsIDOMNodeList** aReturn);
 40568: 
     1:   virtual NS_HIDDEN_(void) FlushSkinBindings();
     1: 
 13433:   virtual NS_HIDDEN_(nsresult) InitializeFrameLoader(nsFrameLoader* aLoader);
 12256:   virtual NS_HIDDEN_(nsresult) FinalizeFrameLoader(nsFrameLoader* aLoader);
 14660:   virtual NS_HIDDEN_(void) TryCancelFrameLoaderInitialization(nsIDocShell* aShell);
 79445:   virtual NS_HIDDEN_(bool) FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell);
 20078:   virtual NS_HIDDEN_(nsIDocument*)
 20078:     RequestExternalResource(nsIURI* aURI,
 20078:                             nsINode* aRequestingNode,
 20078:                             ExternalResourceLoad** aPendingLoad);
 20078:   virtual NS_HIDDEN_(void)
 20078:     EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData);
 12256: 
 38871:   nsTArray<nsCString> mFileDataUris;
 38871: 
 38869:   // Returns our (lazily-initialized) animation controller.
 38869:   // If HasAnimationController is true, this is guaranteed to return non-null.
 23697:   nsSMILAnimationController* GetAnimationController();
 23697: 
 79445:   void SetImagesNeedAnimating(bool aAnimating);
 57023: 
 25722:   virtual void SuppressEventHandling(PRUint32 aIncrease);
 25722: 
 79445:   virtual void UnsuppressEventHandlingAndFireEvents(bool aFireEvents);
 25722:   
 75000:   void DecreaseEventSuppression() {
 75000:     --mEventsSuppressed;
 75000:     MaybeRescheduleAnimationFrameNotifications();
 75000:   }
 25722: 
 88521:   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsDocument,
 30001:                                                                    nsIDocument)
     1: 
 16977:   void DoNotifyPossibleTitleChange();
 16977: 
 20078:   nsExternalResourceMap& ExternalResourceMap()
 20078:   {
 20078:     return mExternalResourceMap;
 20078:   }
 20078: 
 79445:   void SetLoadedAsData(bool aLoadedAsData) { mLoadedAsData = aLoadedAsData; }
 81367:   void SetLoadedAsInteractiveData(bool aLoadedAsInteractiveData)
 81367:   {
 81367:     mLoadedAsInteractiveData = aLoadedAsInteractiveData;
 81367:   }
 19384: 
 19384:   nsresult CloneDocHelper(nsDocument* clone) const;
 19384: 
 24482:   void MaybeInitializeFinalizeFrameLoaders();
 24482: 
 24482:   void MaybeEndOutermostXBLUpdate();
 30065: 
 74594:   virtual void MaybePreLoadImage(nsIURI* uri,
 74594:                                  const nsAString &aCrossOriginAttr);
 34394: 
 38850:   virtual void PreloadStyle(nsIURI* uri, const nsAString& charset);
 38850: 
 79445:   virtual nsresult LoadChromeSheetSync(nsIURI* uri, bool isAgentSheet,
 42163:                                        nsCSSStyleSheet** sheet);
 38850: 
 34394:   virtual nsISupports* GetCurrentContentSink();
 34394: 
 56168:   virtual nsEventStates GetDocumentState();
 39698: 
 53994:   virtual void RegisterFileDataUri(const nsACString& aUri);
 53994:   virtual void UnregisterFileDataUri(const nsACString& aUri);
 38871: 
 41406:   // Only BlockOnload should call this!
 41406:   void AsyncBlockOnload();
 41406: 
 69754:   virtual void SetScrollToRef(nsIURI *aDocumentURI);
 42357:   virtual void ScrollToRef();
 69754:   virtual void ResetScrolledToRefAlready();
 79445:   virtual void SetChangeScrollPosWhenScrollingToRef(bool aValue);
 42357: 
 42425:   already_AddRefed<nsContentList>
 63637:   GetElementsByTagName(const nsAString& aTagName) {
 63637:     return NS_GetContentList(this, kNameSpaceID_Unknown, aTagName);
 63637:   }
 42425:   already_AddRefed<nsContentList>
 42425:     GetElementsByTagNameNS(const nsAString& aNamespaceURI,
 42425:                            const nsAString& aLocalName);
 42425: 
 50428:   virtual Element *GetElementById(const nsAString& aElementId);
 81140:   virtual const nsSmallVoidArray* GetAllElementsForId(const nsAString& aElementId) const;
 50428: 
 50428:   virtual Element *LookupImageElement(const nsAString& aElementId);
 42425: 
 50815:   virtual NS_HIDDEN_(nsresult) AddImage(imgIRequest* aImage);
 50815:   virtual NS_HIDDEN_(nsresult) RemoveImage(imgIRequest* aImage);
 79445:   virtual NS_HIDDEN_(nsresult) SetImageLockingState(bool aLocked);
 50815: 
 94270:   // AddPlugin adds a plugin-related element to mPlugins when the element is
 94270:   // added to the tree.
 94270:   virtual nsresult AddPlugin(nsIObjectLoadingContent* aPlugin);
 94270:   // RemovePlugin removes a plugin-related element to mPlugins when the
 94270:   // element is removed from the tree.
 94270:   virtual void RemovePlugin(nsIObjectLoadingContent* aPlugin);
 94270:   // GetPlugins returns the plugin-related elements from
 94270:   // the frame and any subframes.
 94270:   virtual void GetPlugins(nsTArray<nsIObjectLoadingContent*>& aPlugins);
 94270: 
 69563:   virtual nsresult GetStateObject(nsIVariant** aResult);
 63882: 
 72298:   virtual nsDOMNavigationTiming* GetNavigationTiming() const;
 72298:   virtual nsresult SetNavigationTiming(nsDOMNavigationTiming* aTiming);
 72298: 
 71030:   virtual Element* FindImageMap(const nsAString& aNormalizedMapName);
 71030: 
 82604:   virtual void NotifyAudioAvailableListener();
 82604: 
 82604:   bool HasAudioAvailableListeners()
 82604:   {
 82604:     return mHasAudioAvailableListener;
 82604:   }
 82604: 
 77843:   virtual Element* GetFullScreenElement();
 81437:   virtual void AsyncRequestFullScreen(Element* aElement);
 84109:   virtual void RestorePreviousFullScreenState();
 79445:   virtual bool IsFullScreenDoc();
 99028:   virtual void SetApprovedForFullscreen(bool aIsApproved);
 99028: 
 84109:   static void ExitFullScreen();
 77843: 
 81437:   // This is called asynchronously by nsIDocument::AsyncRequestFullScreen()
 81437:   // to move document into full-screen mode if allowed. aWasCallerChrome
 81437:   // should be true when nsIDocument::AsyncRequestFullScreen() was called
 81437:   // by chrome code.
 81437:   void RequestFullScreen(Element* aElement, bool aWasCallerChrome);
 81437: 
 84109:   // Removes all elements from the full-screen stack, removing full-scren
 84109:   // styles from the top element in the stack.
 99028:   void CleanupFullscreenState();
 99028: 
 99028:   // Add/remove "fullscreen-approved" observer service notification listener.
 99028:   // Chrome sends us a notification when fullscreen is approved for a
 99028:   // document, with the notification subject as the document that was approved.
 99028:   // We maintain this listener while in fullscreen mode.
 99028:   nsresult AddFullscreenApprovedObserver();
 99028:   nsresult RemoveFullscreenApprovedObserver();
 84109: 
 84109:   // Pushes aElement onto the full-screen stack, and removes full-screen styles
 84109:   // from the former full-screen stack top, and its ancestors, and applies the
 84109:   // styles to aElement. aElement becomes the new "full-screen element".
 84109:   bool FullScreenStackPush(Element* aElement);
 84109: 
 84109:   // Remove the top element from the full-screen stack. Removes the full-screen
 84109:   // styles from the former top element, and applies them to the new top
 84109:   // element, if there is one.
 84109:   void FullScreenStackPop();
 84109: 
 84109:   // Returns the top element from the full-screen stack.
 84109:   Element* FullScreenStackTop();
 81144: 
 95203:   void RequestPointerLock(Element* aElement);
 95203:   bool ShouldLockPointer(Element* aElement);
 95203:   bool SetPointerLock(Element* aElement, int aCursorStyle);
 95203:   static void UnlockPointer();
 95203: 
 80229:   // This method may fire a DOM event; if it does so it will happen
 80229:   // synchronously.
 80229:   void UpdateVisibilityState();
 80229:   // Posts an event to call UpdateVisibilityState
 80229:   virtual void PostVisibilityUpdateEvent();
 80229: 
 91403:   virtual void DocSizeOfExcludingThis(nsWindowSizes* aWindowSizes) const;
 91403:   // DocSizeOfIncludingThis is inherited from nsIDocument.
 89203: 
 96919:   virtual nsIDOMNode* AsDOMNode() { return this; }
     1: protected:
 32360:   friend class nsNodeUtils;
 15474: 
 81437:   // Returns true if a request for DOM full-screen is currently enabled in
 81437:   // this document. This returns true if there are no windowed plugins in this
 81437:   // doc tree, and if the document is visible, and if the api is not
 81437:   // disabled by pref. aIsCallerChrome must contain the return value of
 81437:   // nsContentUtils::IsCallerChrome() from the context we're checking.
 82583:   // If aLogFailure is true, an appropriate warning message is logged to the
 82583:   // console, and a "mozfullscreenerror" event is dispatched to this document.
 82583:   bool IsFullScreenEnabled(bool aIsCallerChrome, bool aLogFailure);
 81437: 
     1:   /**
     1:    * Check that aId is not empty and log a message to the console
     1:    * service if it is.
 80486:    * @returns true if aId looks correct, false otherwise.
     1:    */
 79445:   inline bool CheckGetElementByIdArg(const nsAString& aId)
 43946:   {
 43946:     if (aId.IsEmpty()) {
 43946:       ReportEmptyGetElementByIdArg();
 80486:       return false;
 43946:     }
 80486:     return true;
 43946:   }
 43946: 
 59513:   void ReportEmptyGetElementByIdArg();
     1: 
 24144:   void DispatchContentLoadedEvents();
 24144: 
     1:   void RetrieveRelevantHeaders(nsIChannel *aChannel);
     1: 
 94004:   bool TryChannelCharset(nsIChannel *aChannel,
     1:                          PRInt32& aCharsetSource,
 94004:                          nsACString& aCharset,
 94004:                          nsHtml5TreeOpExecutor* aExecutor);
     1: 
     1:   // Call this before the document does something that will unbind all content.
 43079:   // That will stop us from doing a lot of work as each element is removed.
 43079:   void DestroyElementMaps();
     1: 
 33055:   // Refreshes the hrefs of all the links in the document.
 33055:   void RefreshLinkHrefs();
 33055: 
 33055:   nsIContent* GetFirstBaseNodeWithHref();
 33055:   nsresult SetFirstBaseNodeWithHref(nsIContent *node);
 33055: 
 16977:   // Get the first <title> element with the given IsNodeOfType type, or
 16977:   // return null if there isn't one
 16977:   nsIContent* GetTitleContent(PRUint32 aNodeType);
 16977:   // Find the first "title" element in the given IsNodeOfType type and
 16977:   // append the concatenation of its text node children to aTitle. Do
 16977:   // nothing if there is no such element.
 16977:   void GetTitleFromElement(PRUint32 aNodeType, nsAString& aTitle);
 16977: 
     1:   nsresult doCreateShell(nsPresContext* aContext,
     1:                          nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
     1:                          nsCompatibility aCompatMode,
     1:                          nsIPresShell** aInstancePtrResult);
     1: 
     1:   nsresult ResetStylesheetsToURI(nsIURI* aURI);
     1:   void FillStyleSet(nsStyleSet* aStyleSet);
     1: 
     1:   // Return whether all the presshells for this document are safe to flush
 79445:   bool IsSafeToFlush() const;
     1:   
 72326:   void DispatchPageTransition(nsIDOMEventTarget* aDispatchTarget,
 29539:                               const nsAString& aType,
 79445:                               bool aPersisted);
     1: 
 63954:   virtual nsPIDOMWindow *GetWindowInternal() const;
 40925:   virtual nsPIDOMWindow *GetInnerWindowInternal();
 42823:   virtual nsIScriptGlobalObject* GetScriptHandlingObjectInternal() const;
 79445:   virtual bool InternalAllowXULXBL();
 40925: 
     1: #define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                        \
 48006:   NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS(mObservers, nsIDocumentObserver, \
     1:                                            func_, params_);
     1:   
     1: #ifdef DEBUG
     1:   void VerifyRootContentState();
     1: #endif
     1: 
     1:   nsDocument(const char* aContentType);
     1:   virtual ~nsDocument();
     1: 
 40932:   void EnsureOnloadBlocker();
 40932: 
     1:   nsCString mReferrer;
     1:   nsString mLastModified;
     1: 
 26413:   nsTArray<nsIObserver*> mCharSetObservers;
     1: 
     1:   PLDHashTable *mSubDocuments;
     1: 
     1:   // Array of owning references to all children
     1:   nsAttrAndChildArray mChildren;
     1: 
     1:   // Pointer to our parser if we're currently in the process of being
     1:   // parsed into.
     1:   nsCOMPtr<nsIParser> mParser;
     1: 
  6170:   // Weak reference to our sink for in case we no longer have a parser.  This
  6170:   // will allow us to flush out any pending stuff from the sink even if
  6170:   // EndLoad() has already happened.
  6170:   nsWeakPtr mWeakSink;
  6170: 
     1:   nsCOMArray<nsIStyleSheet> mStyleSheets;
     1:   nsCOMArray<nsIStyleSheet> mCatalogSheets;
     1: 
     1:   // Array of observers
  9536:   nsTObserverArray<nsIDocumentObserver*> mObservers;
     1: 
  6475:   // If document is created for example using
  6475:   // document.implementation.createDocument(...), mScriptObject points to
  6475:   // the script global object of the original document.
  6475:   nsWeakPtr mScriptObject;
  6475: 
     1:   // Weak reference to the scope object (aka the script global object)
     1:   // that, unlike mScriptGlobalObject, is never unset once set. This
     1:   // is a weak reference to avoid leaks due to circular references.
     1:   nsWeakPtr mScopeObject;
     1: 
 81144:   // The document which requested (and was granted) full-screen. All ancestors
 81144:   // of this document will also be full-screen.
 81144:   static nsWeakPtr sFullScreenDoc;
 81144: 
 81397:   // The root document of the doctree containing the document which requested
 81397:   // full-screen. This root document will also be in full-screen state, as will
 81397:   // all the descendents down to the document which requested full-screen. This
 81397:   // reference allows us to reset full-screen state on all documents when a
 81397:   // document is hidden/navigation occurs.
 81397:   static nsWeakPtr sFullScreenRootDoc;
 81397: 
 98051:   // Weak reference to the document which owned the pending pointer lock
 98051:   // element, at the time it requested pointer lock.
 98051:   static nsWeakPtr sPendingPointerLockDoc;
 98051: 
 98051:   // Weak reference to the element which requested pointer lock. This request
 98051:   // is "pending", and will be processed once the element's document has had
 98051:   // the "fullscreen" permission granted.
 98051:   static nsWeakPtr sPendingPointerLockElement;
 98051: 
 84109:   // Stack of full-screen elements. When we request full-screen we push the
 84109:   // full-screen element onto this stack, and when we cancel full-screen we
 84109:   // pop one off this stack, restoring the previous full-screen state
 84109:   nsTArray<nsWeakPtr> mFullScreenStack;
 84109: 
 72328:   nsRefPtr<nsEventListenerManager> mListenerManager;
     1:   nsCOMPtr<nsIDOMStyleSheetList> mDOMStyleSheets;
     1:   nsRefPtr<nsDOMStyleSheetSetList> mStyleSheetSetList;
     1:   nsRefPtr<nsScriptLoader> mScriptLoader;
     1:   nsDocHeaderData* mHeaderData;
 15474:   /* mIdentifierMap works as follows for IDs:
 15474:    * 1) Attribute changes affect the table immediately (removing and adding
 15474:    *    entries as needed).
 15474:    * 2) Removals from the DOM affect the table immediately
 26475:    * 3) Additions to the DOM always update existing entries for names, and add
 26475:    *    new ones for IDs.
 15474:    */
 15474:   nsTHashtable<nsIdentifierMapEntry> mIdentifierMap;
     1: 
  6365:   nsClassHashtable<nsStringHashKey, nsRadioGroupStruct> mRadioGroups;
     1: 
 72298:   // Recorded time of change to 'loading' state.
 72298:   mozilla::TimeStamp mLoadingTimeStamp;
 72298: 
     1:   // True if the document has been detached from its content viewer.
 79445:   bool mIsGoingAway:1;
     1:   // True if the document is being destroyed.
 79445:   bool mInDestructor:1;
 31946: 
 16977:   // True if this document has ever had an HTML or SVG <title> element
 16977:   // bound to it
 79445:   bool mMayHaveTitleElement:1;
     1: 
 79445:   bool mHasWarnedAboutBoxObjects:1;
 11731: 
 79445:   bool mDelayFrameLoaderInitialization:1;
 14464: 
 79445:   bool mSynchronousDOMContentLoaded:1;
 24144: 
 16447:   // If true, we have an input encoding.  If this is false, then the
 16447:   // document was created entirely in memory
 79445:   bool mHaveInputEncoding:1;
 16447: 
 79445:   bool mInXBLUpdate:1;
 24482: 
 36884:   // This flag is only set in nsXMLDocument, for e.g. documents used in XBL. We
 36884:   // don't want animations to play in such documents, so we need to store the
 36884:   // flag here so that we can check it in nsDocument::GetAnimationController.
 79445:   bool mLoadedAsInteractiveData:1;
 36884: 
 50815:   // Whether we're currently holding a lock on all of our images.
 79445:   bool mLockingImages:1;
 50815: 
 52149:   // Whether we currently require our images to animate
 79445:   bool mAnimatingImages:1;
 52149: 
 82604:   // Whether some node in this document has a listener for the
 82604:   // "mozaudioavailable" event.
 82604:   bool mHasAudioAvailableListener:1;
 82604: 
 84597:   // Whether we're currently under a FlushPendingNotifications call to
 84597:   // our presshell.  This is used to handle flush reentry correctly.
 84597:   bool mInFlush:1;
 84597: 
 94237:   // Parser aborted. True if the parser of this document was forcibly
 94237:   // terminated instead of letting it finish at its own pace.
 94237:   bool mParserAborted:1;
 94237: 
 99028:   // Whether this document has been approved for fullscreen, either by explicit
 99028:   // approval via the fullscreen-approval UI, or because it received
 99028:   // approval because its document's host already had the "fullscreen"
 99028:   // permission granted when the document requested fullscreen.
 99028:   // 
 99028:   // Note if a document's principal doesn't have a host, the permission manager
 99028:   // can't store permissions for it, so we can only manage approval using this
 99028:   // flag.
 99028:   //
 99028:   // Note we must track this separately from the "fullscreen" permission,
 99028:   // so that pending pointer lock requests can determine whether documents
 99028:   // whose principal doesn't have a host (i.e. those which can't store
 99028:   // permissions in the permission manager) have been approved for fullscreen.
 99028:   bool mIsApprovedForFullscreen:1;
 99028: 
     1:   PRUint8 mXMLDeclarationBits;
     1: 
 93686:   nsInterfaceHashtable<nsPtrHashKey<nsIContent>, nsPIBoxObject> *mBoxObjectTable;
     1: 
     1:   // The channel that got passed to StartDocumentLoad(), if any
     1:   nsCOMPtr<nsIChannel> mChannel;
 36782:   nsRefPtr<nsHTMLCSSStyleSheet> mStyleAttrStyleSheet;
     1:   nsRefPtr<nsXMLEventsManager> mXMLEventsManager;
     1: 
  7199:   // Our update nesting level
  7199:   PRUint32 mUpdateNestLevel;
  7199: 
 18430:   // The application cache that this document is associated with, if
 18430:   // any.  This can change during the lifetime of the document.
 18430:   nsCOMPtr<nsIApplicationCache> mApplicationCache;
 18430: 
 33055:   nsCOMPtr<nsIContent> mFirstBaseNodeWithHref;
 33055: 
 56168:   nsEventStates mDocumentState;
 56168:   nsEventStates mGotDocumentState;
 39698: 
 72298:   nsRefPtr<nsDOMNavigationTiming> mTiming;
 12033: private:
     1:   friend class nsUnblockOnloadEvent;
 80229:   // This needs to stay in sync with the list in GetMozVisibilityState.
 80229:   enum VisibilityState {
 80229:     eHidden = 0,
 80229:     eVisible,
 80229:     eVisibilityStateCount
 80229:   };
 80229:   // Recomputes the visibility state but doesn't set the new value.
 80229:   VisibilityState GetVisibilityState() const;
     1: 
     1:   void PostUnblockOnloadEvent();
     1:   void DoUnblockOnload();
     1: 
 48017:   nsresult CheckFrameOptions();
 37418:   nsresult InitCSP();
 37418: 
 98051:   // Sets aElement to be the pending pointer lock element. Once this document's
 98051:   // node principal's URI is granted the "fullscreen" permission, the pointer
 98051:   // lock request will be processed. At any one time there can be only one
 98051:   // pending pointer lock request; calling this clears the previous pending
 98051:   // request.
 98051:   static nsresult SetPendingPointerLockRequest(Element* aElement);
 98051: 
 98051:   // Clears any pending pointer lock request.
 98051:   static void ClearPendingPointerLockRequest(bool aDispatchErrorEvents);
 98051: 
     1:   /**
101448:    * Find the (non-anonymous) element in this document that contains the
101448:    * content (possibly in a subdocument) associated with aFrame. Returns null
101448:    * if there is no such element.
     1:    */
101448:   nsIContent* GetContentInThisDocument(nsIFrame* aFrame) const;
     1: 
     1:   // Just like EnableStyleSheetsForSet, but doesn't check whether
     1:   // aSheetSet is null and allows the caller to control whether to set
     1:   // aSheetSet as the preferred set in the CSSLoader.
     1:   void EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
 79445:                                        bool aUpdateCSSLoader);
     1: 
 63939:   // Revoke any pending notifications due to mozRequestAnimationFrame calls
 63939:   void RevokeAnimationFrameNotifications();
 75000:   // Reschedule any notifications we need to handle
 75000:   // mozRequestAnimationFrame, if it's OK to do so.
 75000:   void MaybeRescheduleAnimationFrameNotifications();
 63939: 
     1:   // These are not implemented and not supported.
     1:   nsDocument(const nsDocument& aOther);
     1:   nsDocument& operator=(const nsDocument& aOther);
     1: 
     1:   nsCOMPtr<nsISupports> mXPathEvaluatorTearoff;
     1: 
     1:   // The layout history state that should be used by nodes in this
     1:   // document.  We only actually store a pointer to it when:
     1:   // 1)  We have no script global object.
     1:   // 2)  We haven't had Destroy() called on us yet.
     1:   nsCOMPtr<nsILayoutHistoryState> mLayoutHistoryState;
     1: 
 41406:   // Currently active onload blockers
     1:   PRUint32 mOnloadBlockCount;
 41406:   // Onload blockers which haven't been activated yet
 41406:   PRUint32 mAsyncOnloadBlockCount;
     1:   nsCOMPtr<nsIRequest> mOnloadBlocker;
 23639:   ReadyState mReadyState;
     1: 
 38488:   // A hashtable of styled links keyed by address pointer.
 38488:   nsTHashtable<nsPtrHashKey<mozilla::dom::Link> > mStyledLinks;
 38488: #ifdef DEBUG
 38488:   // Indicates whether mStyledLinks was cleared or not.  This is used to track
 38488:   // state so we can provide useful assertions to consumers of ForgetLink and
 38488:   // AddStyleRelevantLink.
 38488:   bool mStyledLinksCleared;
 38488: #endif
     1: 
     1:   // Member to store out last-selected stylesheet set.
     1:   nsString mLastStyleSheetSet;
 12256: 
 13433:   nsTArray<nsRefPtr<nsFrameLoader> > mInitializableFrameLoaders;
 12256:   nsTArray<nsRefPtr<nsFrameLoader> > mFinalizableFrameLoaders;
 24482:   nsRefPtr<nsRunnableMethod<nsDocument> > mFrameLoaderRunner;
 16977: 
 41359:   nsRevocableEventPtr<nsRunnableMethod<nsDocument, void, false> >
 28045:     mPendingTitleChangeEvent;
 20078: 
 20078:   nsExternalResourceMap mExternalResourceMap;
 23697: 
 30065:   // All images in process of being preloaded
 30065:   nsCOMArray<imgIRequest> mPreloadingImages;
 30065: 
 34007:   nsCOMPtr<nsIDOMDOMImplementation> mDOMImplementation;
 34007: 
 71030:   nsRefPtr<nsContentList> mImageMaps;
 71030: 
 69754:   nsCString mScrollToRef;
 69754:   PRUint8 mScrolledToRefAlready : 1;
 69754:   PRUint8 mChangeScrollPosWhenScrollingToRef : 1;
 69754: 
 50815:   // Tracking for images in the document.
 50815:   nsDataHashtable< nsPtrHashKey<imgIRequest>, PRUint32> mImageTracker;
 50815: 
 94270:   // Tracking for plugins in the document.
 94270:   nsTHashtable< nsPtrHashKey<nsIObjectLoadingContent> > mPlugins;
 94270: 
 80229:   VisibilityState mVisibilityState;
 80229: 
 31428: #ifdef DEBUG
 31428: protected:
 79445:   bool mWillReparent;
 31428: #endif
     1: };
     1: 
 21218: #define NS_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                             \
 21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
 21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocument, nsDocument)      \
 21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMEventTarget, nsDocument)   \
 64020:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNode, nsDocument)
 21218: 
     1: #endif /* nsDocument_h___ */
