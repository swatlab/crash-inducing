 9499: /* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
 7242:  *   Colin Barrett <cbarrett@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCocoaWindow.h"
    1: 
11978: #include "nsObjCExceptions.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRollupListener.h"
    1: #include "nsCocoaUtils.h"
    1: #include "nsChildView.h"
14885: #include "nsWindowMap.h"
26321: #include "nsAppShell.h"
    1: #include "nsIAppShell.h"
    1: #include "nsIAppShellService.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIXULWindow.h"
  235: #include "nsIPrefService.h"
  235: #include "nsIPrefBranch.h"
 7634: #include "nsToolkit.h"
 8590: #include "nsPrintfCString.h"
29018: #include "nsIServiceManager.h"
29018: #include "nsIDOMWindow.h"
29018: #include "nsPIDOMWindow.h"
29018: #include "nsIDOMElement.h"
11675: #include "nsThreadUtils.h"
13608: #include "nsMenuBarX.h"
15578: #include "nsMenuUtilsX.h"
20467: #include "nsStyleConsts.h"
20506: #include "nsNativeThemeColors.h"
27993: #include "nsChildView.h"
    1: 
14002: #include "gfxPlatform.h"
27035: #include "qcms.h"
14002: 
26321: // defined in nsAppShell.mm
26321: extern nsCocoaAppModalWindowList *gCocoaAppModalWindowList;
26321: 
 6111: PRInt32 gXULModalLevel = 0;
26321: 
13491: // In principle there should be only one app-modal window at any given time.
13491: // But sometimes, despite our best efforts, another window appears above the
13491: // current app-modal window.  So we need to keep a linked list of app-modal
13491: // windows.  (A non-sheet window that appears above an app-modal window is
13491: // also made app-modal.)  See nsCocoaWindow::SetModal().
26321: nsCocoaWindowList *gGeckoAppModalWindowList = NULL;
 6111: 
28346: PRBool gConsumeRollupEvent;
28346: 
    1: // defined in nsMenuBarX.mm
    1: extern NSMenu* sApplicationMenu; // Application menu shared by all menubars
    1: 
    1: // defined in nsChildView.mm
    1: extern nsIRollupListener * gRollupListener;
    1: extern nsIWidget         * gRollupWidget;
    1: extern BOOL                gSomeMenuBarPainted;
    1: 
    1: #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)
    1: 
 5900: // A note on testing to see if your object is a sheet...
 5900: // |mWindowType == eWindowType_sheet| is true if your gecko nsIWidget is a sheet
 5900: // widget - whether or not the sheet is showing. |[mWindow isSheet]| will return
 5900: // true *only when the sheet is actually showing*. Choose your test wisely.
 5900: 
 2314: // roll up any popup windows
 2314: static void RollUpPopups()
 2314: {
 2314:   if (gRollupListener && gRollupWidget)
29148:     gRollupListener->Rollup(nsnull, nsnull);
 2314: }
 2314: 
    1: nsCocoaWindow::nsCocoaWindow()
    1: : mParent(nsnull)
    1: , mWindow(nil)
    1: , mDelegate(nil)
    1: , mSheetWindowParent(nil)
    1: , mPopupContentView(nil)
    1: , mIsResizing(PR_FALSE)
    1: , mWindowMadeHere(PR_FALSE)
    1: , mSheetNeedsShow(PR_FALSE)
 6111: , mModal(PR_FALSE)
13491: , mNumModalDescendents(0)
    1: {
    1: 
    1: }
    1: 
25875: // Under unusual circumstances, an nsCocoaWindow object can be destroyed
25875: // before the nsChildView objects it contains are destroyed.  But this will
25875: // invalidate the (weak) mWindow variable in these nsChildView objects
25875: // before their own destructors have been called.  So we need to null-out
25875: // this variable in our nsChildView objects as we're destroyed.  This helps
25875: // resolve bmo bug 479749.
25875: static void TellNativeViewsGoodbye(NSView *aNativeView)
25875: {
25875:   if (!aNativeView)
25875:     return;
25875:   if ([aNativeView respondsToSelector:@selector(setNativeWindow:)])
25875:     [(NSView<mozView>*)aNativeView setNativeWindow:nil];
25875:   NSArray *immediateSubviews = [aNativeView subviews];
25875:   int count = [immediateSubviews count];
25875:   for (int i = 0; i < count; ++i)
25875:     TellNativeViewsGoodbye((NSView *)[immediateSubviews objectAtIndex:i]);
25875: }
25875: 
29540: void nsCocoaWindow::DestroyNativeWindow()
29540: {
29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
29540: 
29540:   // We want to unhook the delegate here because we don't want events
29540:   // sent to it after this object has been destroyed.
29540:   [mWindow setDelegate:nil];
29540:   [mWindow close];
29540:   [mDelegate autorelease];
29540: 
29540:   NS_OBJC_END_TRY_ABORT_BLOCK;
29540: }
29540: 
    1: nsCocoaWindow::~nsCocoaWindow()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
27679:   // Notify the children that we're gone.  Popup windows (e.g. tooltips) can
27679:   // have nsChildView children.  'kid' is an nsChildView object if and only if
30427:   // its 'type' is 'eWindowType_child'.  childView->ResetParent() can change
30427:   // our list of children while it's being iterated, so the way we iterate the
30427:   // list must allow for this.
30427:   for (nsIWidget* kid = mLastChild; kid;) {
27679:     nsWindowType kidType;
27679:     kid->GetWindowType(kidType);
27679:     if (kidType == eWindowType_child) {
27679:       nsChildView* childView = static_cast<nsChildView*>(kid);
30427:       kid = kid->GetPrevSibling();
27679:       childView->ResetParent();
27679:     } else {
 3233:       nsCocoaWindow* childWindow = static_cast<nsCocoaWindow*>(kid);
    1:       childWindow->mParent = nsnull;
30427:       kid = kid->GetPrevSibling();
    1:     }
27679:   }
    1: 
25875:   if (mWindow) {
25875:     TellNativeViewsGoodbye([mWindow contentView]);
25875:     if (mWindowMadeHere) {
29540:       DestroyNativeWindow();
    1:     }
25875:   }
    1: 
    1:   NS_IF_RELEASE(mPopupContentView);
 6111: 
 6111:   // Deal with the possiblity that we're being destroyed while running modal.
 6111:   NS_ASSERTION(!mModal, "Widget destroyed while running modal!");
 6111:   if (mModal) {
 6111:     --gXULModalLevel;
 6111:     NS_ASSERTION(gXULModalLevel >= 0, "Wierdness setting modality!");
 6111:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
 8590: // Very large windows work in Cocoa, but can take a long time to
 8590: // process (multiple minutes), during which time the system is
 8590: // unresponsive and seems hung. Although it's likely that windows
 8590: // much larger than screen size are bugs, be conservative and only
 8590: // intervene if the values are so large as to hog the cpu.
 8590: #define SIZE_LIMIT 100000
 8590: static bool WindowSizeAllowed(PRInt32 aWidth, PRInt32 aHeight)
 8590: {
 8590:   if (aWidth > SIZE_LIMIT) {
 8590:     NS_ERROR(nsPrintfCString(256, "Requested Cocoa window width of %d is too much, max allowed is %d\n",
 8590:                              aWidth, SIZE_LIMIT).get());
 8590:     return false;
 8590:   }
 8590:   if (aHeight > SIZE_LIMIT) {
 8590:     NS_ERROR(nsPrintfCString(256, "Requested Cocoa window height of %d is too much, max allowed is %d\n",
 8590:                              aHeight, SIZE_LIMIT).get());
 8590:     return false;
 8590:   }
 8590:   return true;
 8590: }
 8590: 
29540: // Some applications like Camino use native popup windows
29540: // (native context menus, native tooltips)
29540: static PRBool UseNativePopupWindows()
29540: {
29540:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
29540:   if (!prefs)
29540:     return PR_FALSE;
29540: 
29540:   PRBool useNativePopupWindows;
29540:   nsresult rv = prefs->GetBoolPref("ui.use_native_popup_windows", &useNativePopupWindows);
29540:   return (NS_SUCCEEDED(rv) && useNativePopupWindows);
29540: }
29540: 
    1: // Utility method for implementing both Create(nsIWidget ...) and
    1: // Create(nsNativeWidget...)
    1: nsresult nsCocoaWindow::StandardCreate(nsIWidget *aParent,
23738:                         const nsIntRect &aRect,
    1:                         EVENT_CALLBACK aHandleEventFunction,
    1:                         nsIDeviceContext *aContext,
    1:                         nsIAppShell *aAppShell,
    1:                         nsIToolkit *aToolkit,
    1:                         nsWidgetInitData *aInitData,
    1:                         nsNativeWidget aNativeWindow)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 8590:   if (!WindowSizeAllowed(aRect.width, aRect.height))
 8590:     return NS_ERROR_FAILURE;
 8590: 
    1:   Inherited::BaseCreate(aParent, aRect, aHandleEventFunction, aContext, aAppShell,
    1:                         aToolkit, aInitData);
    1: 
    1:   mParent = aParent;
29540:   SetWindowType(aInitData ? aInitData->mWindowType : eWindowType_toplevel);
29540:   SetBorderStyle(aInitData ? aInitData->mBorderStyle : eBorderStyle_default);
29540: 
29540:   // Create a window if we aren't given one, or if this should be a non-native popup.
29540:   if ((mWindowType == eWindowType_popup) ? !UseNativePopupWindows() : !aNativeWindow) {
29540:     nsresult rv = CreateNativeWindow(aRect, mBorderStyle);
29540:     NS_ENSURE_SUCCESS(rv, rv);
29540: 
29540:     if (mWindowType == eWindowType_popup) {
29540:       rv = CreatePopupContentView(aRect, aHandleEventFunction, aContext, aAppShell, aToolkit);
29540:       NS_ENSURE_SUCCESS(rv, rv);
29540:     }
29540:   } else {
29540:     mWindow = (NSWindow*)aNativeWindow;
29540:   }
29540: 
29540:   [[WindowDataMap sharedWindowDataMap] ensureDataForWindow:mWindow];
29540: 
29540:   return NS_OK;
29540: 
29540:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
29540: }
29540: 
29618: static unsigned int WindowMaskForBorderStyle(nsBorderStyle aBorderStyle)
29618: {
29618:   PRBool allOrDefault = (aBorderStyle == eBorderStyle_all ||
29618:                          aBorderStyle == eBorderStyle_default);
29618: 
29618:   /* Apple's docs on NSWindow styles say that "a window's style mask should
29618:    * include NSTitledWindowMask if it includes any of the others [besides
29618:    * NSBorderlessWindowMask]".  This implies that a borderless window
29618:    * shouldn't have any other styles than NSBorderlessWindowMask.
29618:    */
29618:   if (!allOrDefault && !(aBorderStyle & eBorderStyle_title))
29618:     return NSBorderlessWindowMask;
29618: 
29618:   unsigned int mask = NSTitledWindowMask | NSMiniaturizableWindowMask;
29618:   if (allOrDefault || aBorderStyle & eBorderStyle_close)
29618:     mask |= NSClosableWindowMask;
29618:   if (allOrDefault || aBorderStyle & eBorderStyle_resizeh)
29618:     mask |= NSResizableWindowMask;
29618: 
29618:   return mask;
29618: }
29618: 
29540: nsresult nsCocoaWindow::CreateNativeWindow(const nsIntRect &aRect,
29540:                                            nsBorderStyle aBorderStyle)
29540: {
29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
29540: 
29618:   // We default to NSBorderlessWindowMask, add features if needed.
    1:   unsigned int features = NSBorderlessWindowMask;
    1: 
29618:   // Configure the window we will create based on the window type.
    1:   switch (mWindowType)
    1:   {
    1:     case eWindowType_invisible:
    1:     case eWindowType_child:
29618:     case eWindowType_popup:
    1:       break;
29618:     case eWindowType_toplevel:
    1:     case eWindowType_dialog:
29618:       features = WindowMaskForBorderStyle(aBorderStyle);
    1:       break;
    1:     case eWindowType_sheet:
    1:       nsWindowType parentType;
29540:       mParent->GetWindowType(parentType);
    1:       if (parentType != eWindowType_invisible &&
29540:           aBorderStyle & eBorderStyle_resizeh) {
    1:         features = NSResizableWindowMask;
    1:       }
    1:       else {
    1:         features = NSMiniaturizableWindowMask;
    1:       }
    1:       features |= NSTitledWindowMask;
    1:       break;
    1:     default:
    1:       NS_ERROR("Unhandled window type!");
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   /* 
    1:    * We pass a content area rect to initialize the native Cocoa window. The
    1:    * content rect we give is the same size as the size we're given by gecko.
    1:    * The origin we're given for non-popup windows is moved down by the height
    1:    * of the menu bar so that an origin of (0,100) from gecko puts the window
    1:    * 100 pixels below the top of the available desktop area. We also move the
    1:    * origin down by the height of a title bar if it exists. This is so the
    1:    * origin that gecko gives us for the top-left of  the window turns out to
    1:    * be the top-left of the window we create. This is how it was done in
    1:    * Carbon. If it ought to be different we'll probably need to look at all
    1:    * the callers.
    1:    *
    1:    * Note: This means that if you put a secondary screen on top of your main
    1:    * screen and open a window in the top screen, it'll be incorrectly shifted
    1:    * down by the height of the menu bar. Same thing would happen in Carbon.
    1:    *
    1:    * Note: If you pass a rect with 0,0 for an origin, the window ends up in a
    1:    * weird place for some reason. This stops that without breaking popups.
    1:    */
 8779:   NSRect rect = nsCocoaUtils::GeckoRectToCocoaRect(aRect);
    1: 
    1:   // compensate for difference between frame and content area height (e.g. title bar)
    1:   NSRect newWindowFrame = [NSWindow frameRectForContentRect:rect styleMask:features];
    1: 
    1:   rect.origin.y -= (newWindowFrame.size.height - rect.size.height);
    1: 
    1:   if (mWindowType != eWindowType_popup)
    1:     rect.origin.y -= ::GetMBarHeight();
    1: 
    1:   // NSLog(@"Top-level window being created at Cocoa rect: %f, %f, %f, %f\n",
    1:   //       rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    1: 
 3574:   Class windowClass = [NSWindow class];
 8121:   // If we have a titlebar on a top-level window, we want to be able to control the 
 8121:   // titlebar color (for unified windows), so use the special ToolbarWindow class. 
29540:   // Note that we need to check the window type because we mark sheets as 
 8121:   // having titlebars.
 8121:   if (mWindowType == eWindowType_toplevel &&
 7242:       (features & NSTitledWindowMask))
 3574:     windowClass = [ToolbarWindow class];
 3574:   // If we're a popup window we need to use the PopupWindow class.
 3574:   else if (mWindowType == eWindowType_popup)
 3574:     windowClass = [PopupWindow class];
 7042:   // If we're a non-popup borderless window we need to use the
 7042:   // BorderlessWindow class.
 7042:   else if (features == NSBorderlessWindowMask)
 7042:     windowClass = [BorderlessWindow class];
 7242: 
 7242:   // Create the window
 2029:   mWindow = [[windowClass alloc] initWithContentRect:rect styleMask:features 
 9499:                                  backing:NSBackingStoreBuffered defer:YES];
    1: 
29540:   if (mWindowType == eWindowType_invisible) {
29540:     [mWindow setLevel:kCGDesktopWindowLevelKey];
29853:   } else if (mWindowType == eWindowType_popup) {
29853:     [mWindow setLevel:NSPopUpMenuWindowLevel];
29853:     [mWindow setHasShadow:YES];
29540:   }
29540: 
29540:   [mWindow setBackgroundColor:[NSColor whiteColor]];
29540:   [mWindow setContentMinSize:NSMakeSize(60, 60)];
29540: 
29540:   // setup our notification delegate. Note that setDelegate: does NOT retain.
29540:   mDelegate = [[WindowDelegate alloc] initWithGeckoWindow:this];
29540:   [mWindow setDelegate:mDelegate];
29540: 
29540:   mWindowMadeHere = PR_TRUE;
29540: 
29540:   return NS_OK;
29540: 
29540:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
29540: }
29540: 
29540: NS_IMETHODIMP nsCocoaWindow::CreatePopupContentView(const nsIntRect &aRect,
29540:                              EVENT_CALLBACK aHandleEventFunction,
29540:                              nsIDeviceContext *aContext,
29540:                              nsIAppShell *aAppShell,
29540:                              nsIToolkit *aToolkit)
29540: {
29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
29540: 
29540:   // We need to make our content view a ChildView.
    1:   mPopupContentView = new nsChildView();
29540:   if (!mPopupContentView)
29540:     return NS_ERROR_FAILURE;
29540: 
    1:   NS_ADDREF(mPopupContentView);
    1: 
 3233:   nsIWidget* thisAsWidget = static_cast<nsIWidget*>(this);
    1:   mPopupContentView->StandardCreate(thisAsWidget, aRect, aHandleEventFunction,
    1:                                     aContext, aAppShell, aToolkit, nsnull, nsnull);
    1: 
    1:   ChildView* newContentView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
    1:   [mWindow setContentView:newContentView];
29297: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // Create a nsCocoaWindow using a native window provided by the application
    1: NS_IMETHODIMP nsCocoaWindow::Create(nsNativeWidget aNativeWindow,
23738:                       const nsIntRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell,
    1:                       nsIToolkit *aToolkit,
    1:                       nsWidgetInitData *aInitData)
    1: {
    1:   return(StandardCreate(nsnull, aRect, aHandleEventFunction, aContext,
    1:                         aAppShell, aToolkit, aInitData, aNativeWindow));
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Create(nsIWidget* aParent,
23738:                       const nsIntRect &aRect,
    1:                       EVENT_CALLBACK aHandleEventFunction,
    1:                       nsIDeviceContext *aContext,
    1:                       nsIAppShell *aAppShell,
    1:                       nsIToolkit *aToolkit,
    1:                       nsWidgetInitData *aInitData)
    1: {
    1:   return(StandardCreate(aParent, aRect, aHandleEventFunction, aContext,
    1:                         aAppShell, aToolkit, aInitData, nsnull));
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Destroy()
    1: {
    1:   if (mPopupContentView)
    1:     mPopupContentView->Destroy();
    1: 
25875:   nsBaseWidget::Destroy();
    1:   nsBaseWidget::OnDestroy();
    1: 
    1:   return NS_OK;
    1: }
    1: 
14886: nsIWidget* nsCocoaWindow::GetSheetWindowParent(void)
14886: {
14886:   if (mWindowType != eWindowType_sheet)
14886:     return nsnull;
14886:   nsCocoaWindow *parent = static_cast<nsCocoaWindow*>(mParent);
14886:   while (parent && (parent->mWindowType == eWindowType_sheet))
14886:     parent = static_cast<nsCocoaWindow*>(parent->mParent);
14886:   return parent;
14886: }
14886: 
    1: void* nsCocoaWindow::GetNativeData(PRUint32 aDataType)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
11978: 
    1:   void* retVal = nsnull;
    1:   
    1:   switch (aDataType) {
    1:     // to emulate how windows works, we always have to return a NSView
    1:     // for NS_NATIVE_WIDGET
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_DISPLAY:
    1:       retVal = [mWindow contentView];
    1:       break;
    1:       
    1:     case NS_NATIVE_WINDOW:
    1:       retVal = mWindow;
    1:       break;
    1:       
    1:     case NS_NATIVE_GRAPHIC:
    1:       // There isn't anything that makes sense to return here,
    1:       // and it doesn't matter so just return nsnull.
    1:       NS_ASSERTION(0, "Requesting NS_NATIVE_GRAPHIC on a top-level window!");
    1:       break;
    1:   }
    1: 
    1:   return retVal;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::IsVisible(PRBool & aState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
11899:   aState = ([mWindow isVisible] || mSheetNeedsShow);
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
 6111: NS_IMETHODIMP nsCocoaWindow::SetModal(PRBool aState)
 6111: {
 6111:   mModal = aState;
13491:   nsCocoaWindow *aParent = static_cast<nsCocoaWindow*>(mParent);
 6111:   if (aState) {
 6111:     ++gXULModalLevel;
26321:     if (gCocoaAppModalWindowList)
26321:       gCocoaAppModalWindowList->PushGecko(mWindow, this);
14843:     // When a non-sheet window gets "set modal", make the window(s) that it
14843:     // appears over behave as they should.  We can't rely on native methods to
14843:     // do this, for the following reason:  The OS runs modal non-sheet windows
14843:     // in an event loop (using [NSApplication runModalForWindow:] or similar
14843:     // methods) that's incompatible with the modal event loop in nsXULWindow::
14843:     // ShowModal() (each of these event loops is "exclusive", and can't run at
14843:     // the same time as other (similar) event loops).
14843:     if (mWindowType != eWindowType_sheet) {
13491:       while (aParent) {
13491:         if (aParent->mNumModalDescendents++ == 0) {
13491:           NSWindow *aWindow = aParent->GetCocoaWindow();
13491:           if (aParent->mWindowType != eWindowType_invisible) {
13491:             [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:NO];
13491:             [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:NO];
13491:             [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:NO];
13491:           }
13491:         }
13491:         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
13491:       }
13491:       [mWindow setLevel:NSModalPanelWindowLevel];
13491:       nsCocoaWindowList *windowList = new nsCocoaWindowList;
13491:       if (windowList) {
13491:         windowList->window = this; // Don't ADDREF
26321:         windowList->prev = gGeckoAppModalWindowList;
26321:         gGeckoAppModalWindowList = windowList;
13491:       }
13491:     }
13491:   }
13491:   else {
 6111:     --gXULModalLevel;
 6111:     NS_ASSERTION(gXULModalLevel >= 0, "Mismatched call to nsCocoaWindow::SetModal(PR_FALSE)!");
26321:     if (gCocoaAppModalWindowList)
26321:       gCocoaAppModalWindowList->PopGecko(mWindow, this);
14843:     if (mWindowType != eWindowType_sheet) {
13491:       while (aParent) {
13491:         if (--aParent->mNumModalDescendents == 0) {
13491:           NSWindow *aWindow = aParent->GetCocoaWindow();
13491:           if (aParent->mWindowType != eWindowType_invisible) {
13491:             [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:YES];
13491:             [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:YES];
13491:             [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:YES];
13491:           }
13491:         }
13491:         NS_ASSERTION(aParent->mNumModalDescendents >= 0, "Widget hierarchy changed while modal!");
13491:         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
13491:       }
26321:       if (gGeckoAppModalWindowList) {
26321:         NS_ASSERTION(gGeckoAppModalWindowList->window == this, "Widget hierarchy changed while modal!");
26321:         nsCocoaWindowList *saved = gGeckoAppModalWindowList;
26321:         gGeckoAppModalWindowList = gGeckoAppModalWindowList->prev;
13491:         delete saved; // "window" not ADDREFed
13491:       }
13491:       if (mWindowType == eWindowType_popup)
13491:         [mWindow setLevel:NSPopUpMenuWindowLevel];
13491:       else
13491:         [mWindow setLevel:NSNormalWindowLevel];
13491:     }
 6111:   }
 6111:   return NS_OK;
 6111: }
 6111: 
    1: // Hide or show this window
    1: NS_IMETHODIMP nsCocoaWindow::Show(PRBool bState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
12278:   // We need to re-execute sometimes in order to bring already-visible
12278:   // windows forward.
12278:   if (!mSheetNeedsShow && !bState && ![mWindow isVisible])
11899:     return NS_OK;
11899: 
    1:   nsIWidget* parentWidget = mParent;
    1:   nsCOMPtr<nsPIWidgetCocoa> piParentWidget(do_QueryInterface(parentWidget));
    1:   NSWindow* nativeParentWindow = (parentWidget) ?
    1:     (NSWindow*)parentWidget->GetNativeData(NS_NATIVE_WINDOW) : nil;
    1: 
    1:   if (bState && !mBounds.IsEmpty()) {
    1:     if (mWindowType == eWindowType_sheet) {
    1:       // bail if no parent window (its basically what we do in Carbon)
    1:       if (!nativeParentWindow || !piParentWidget)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       NSWindow* topNonSheetWindow = nativeParentWindow;
    1:       
    1:       // If this sheet is the child of another sheet, hide the parent so that
    1:       // this sheet can be displayed. Leave the parent mSheetNeedsShow alone,
    1:       // that is only used to handle sibling sheet contention. The parent will
    1:       // return once there are no more child sheets.
    1:       PRBool parentIsSheet = PR_FALSE;
    1:       if (NS_SUCCEEDED(piParentWidget->GetIsSheet(&parentIsSheet)) &&
    1:           parentIsSheet) {
    1:         piParentWidget->GetSheetWindowParent(&topNonSheetWindow);
    1:         [NSApp endSheet:nativeParentWindow];
    1:         [nativeParentWindow setAcceptsMouseMovedEvents:NO];
    1:       }
    1: 
    1:       nsCocoaWindow* sheetShown = nsnull;
    1:       if (NS_SUCCEEDED(piParentWidget->GetChildSheet(PR_TRUE, &sheetShown)) &&
    1:           (!sheetShown || sheetShown == this)) {
    1:         // If this sheet is already the sheet actually being shown, don't
    1:         // tell it to show again. Otherwise the number of calls to
    1:         // [NSApp beginSheet...] won't match up with [NSApp endSheet...].
12066:         if (![mWindow isVisible]) {
    1:           mSheetNeedsShow = PR_FALSE;
    1:           mSheetWindowParent = topNonSheetWindow;
15026:           // Only set contextInfo if our parent isn't a sheet.
15026:           NSWindow* contextInfo = parentIsSheet ? nil : mSheetWindowParent;
14885:           [TopLevelWindowData deactivateInWindow:mSheetWindowParent];
    1:           [mWindow setAcceptsMouseMovedEvents:YES];
    1:           [NSApp beginSheet:mWindow
    1:              modalForWindow:mSheetWindowParent
    1:               modalDelegate:mDelegate
    1:              didEndSelector:@selector(didEndSheet:returnCode:contextInfo:)
15026:                 contextInfo:contextInfo];
14885:           [TopLevelWindowData activateInWindow:mWindow];
    1:           SendSetZLevelEvent();
    1:         }
    1:       }
    1:       else {
    1:         // A sibling of this sheet is active, don't show this sheet yet.
    1:         // When the active sheet hides, its brothers and sisters that have
    1:         // mSheetNeedsShow set will have their opportunities to display.
    1:         mSheetNeedsShow = PR_TRUE;
    1:       }
    1:     }
    1:     else if (mWindowType == eWindowType_popup) {
 3574:       // If a popup window is shown after being hidden, it needs to be "reset"
 3574:       // for it to receive any mouse events aside from mouse-moved events
 3574:       // (because it was removed from the "window cache" when it was hidden
 3574:       // -- see below).  Setting the window number to -1 and then back to its
 3574:       // original value seems to accomplish this.  The idea was "borrowed"
 3574:       // from the Java Embedding Plugin.
 3574:       int windowNumber = [mWindow windowNumber];
 3574:       [mWindow _setWindowNumber:-1];
 3574:       [mWindow _setWindowNumber:windowNumber];
    1:       [mWindow setAcceptsMouseMovedEvents:YES];
24417:       // For reasons that aren't yet clear, calls to [NSWindow orderFront:] or
24417:       // [NSWindow makeKeyAndOrderFront:] can sometimes trigger "Error (1000)
24417:       // creating CGSWindow", which in turn triggers an internal inconsistency
24417:       // NSException.  These errors shouldn't be fatal.  So we need to wrap
24417:       // calls to ...orderFront: in LOGONLY blocks.  See bmo bug 470864.
24417:       NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
    1:       [mWindow orderFront:nil];
24417:       NS_OBJC_END_TRY_LOGONLY_BLOCK;
    1:       SendSetZLevelEvent();
 3574:       // If our popup window is a non-native context menu, tell the OS (and
 3574:       // other programs) that a menu has opened.  This is how the OS knows to
 3574:       // close other programs' context menus when ours open.
 3574:       if ([mWindow isKindOfClass:[PopupWindow class]] &&
 3574:           [(PopupWindow*) mWindow isContextMenu]) {
 3574:         [[NSDistributedNotificationCenter defaultCenter]
 3574:           postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
 3574:                         object:@"org.mozilla.gecko.PopupWindow"];
 3574:       }
 8408: 
 8408:       // if a parent was supplied, set its child window. This will cause the
 8408:       // child window to appear above the parent and move when the parent
 8408:       // does. Setting this needs to happen after the _setWindowNumber calls
 8408:       // above, otherwise the window doesn't focus properly.
 8408:       if (nativeParentWindow)
 8408:         [nativeParentWindow addChildWindow:mWindow
 8408:                             ordered:NSWindowAbove];
    1:     }
    1:     else {
    1:       [mWindow setAcceptsMouseMovedEvents:YES];
24417:       NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
    1:       [mWindow makeKeyAndOrderFront:nil];
24417:       NS_OBJC_END_TRY_LOGONLY_BLOCK;
    1:       SendSetZLevelEvent();
    1:     }
    1:   }
    1:   else {
    1:     // roll up any popups if a top-level window is going away
 2314:     if (mWindowType == eWindowType_toplevel)
 2314:       RollUpPopups();
    1: 
    1:     // now get rid of the window/sheet
    1:     if (mWindowType == eWindowType_sheet) {
11899:       if (mSheetNeedsShow) {
11899:         // This is an attempt to hide a sheet that never had a chance to
11899:         // be shown. There's nothing to do other than make sure that it
11899:         // won't show.
11899:         mSheetNeedsShow = PR_FALSE;
11899:       }
11899:       else {
    1:         // get sheet's parent *before* hiding the sheet (which breaks the linkage)
    1:         NSWindow* sheetParent = mSheetWindowParent;
    1:         
    1:         // hide the sheet
    1:         [NSApp endSheet:mWindow];
    1:         
    1:         [mWindow setAcceptsMouseMovedEvents:NO];
    1: 
14885:         [TopLevelWindowData deactivateInWindow:mWindow];
    1: 
    1:         nsCocoaWindow* siblingSheetToShow = nsnull;
    1:         PRBool parentIsSheet = PR_FALSE;
    1: 
    1:         if (nativeParentWindow && piParentWidget &&
    1:             NS_SUCCEEDED(piParentWidget->GetChildSheet(PR_FALSE, &siblingSheetToShow)) &&
    1:             siblingSheetToShow) {
    1:           // First, give sibling sheets an opportunity to show.
    1:           siblingSheetToShow->Show(PR_TRUE);
    1:         }
    1:         else if (nativeParentWindow && piParentWidget &&
    1:                  NS_SUCCEEDED(piParentWidget->GetIsSheet(&parentIsSheet)) &&
    1:                  parentIsSheet) {
15026:           // Only set contextInfo if the parent of the parent sheet we're about
15026:           // to restore isn't itself a sheet.
15026:           NSWindow* contextInfo = sheetParent;
15026:           nsIWidget* grandparentWidget = nil;
15026:           if (NS_SUCCEEDED(piParentWidget->GetRealParent(&grandparentWidget)) && grandparentWidget) {
15026:             nsCOMPtr<nsPIWidgetCocoa> piGrandparentWidget(do_QueryInterface(grandparentWidget));
15026:             PRBool grandparentIsSheet = PR_FALSE;
15026:             if (piGrandparentWidget && NS_SUCCEEDED(piGrandparentWidget->GetIsSheet(&grandparentIsSheet)) &&
15026:                 grandparentIsSheet) {
15026:                 contextInfo = nil;
15026:             }
15026:           }
    1:           // If there are no sibling sheets, but the parent is a sheet, restore
    1:           // it.  It wasn't sent any deactivate events when it was hidden, so
    1:           // don't call through Show, just let the OS put it back up.
    1:           [nativeParentWindow setAcceptsMouseMovedEvents:YES];
    1:           [NSApp beginSheet:nativeParentWindow
    1:              modalForWindow:sheetParent
    1:               modalDelegate:[nativeParentWindow delegate]
    1:              didEndSelector:@selector(didEndSheet:returnCode:contextInfo:)
15026:                 contextInfo:contextInfo];
    1:         }
    1:         else {
    1:           // Sheet, that was hard.  No more siblings or parents, going back
    1:           // to a real window.
24417:           NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
    1:           [sheetParent makeKeyAndOrderFront:nil];
24417:           NS_OBJC_END_TRY_LOGONLY_BLOCK;
    1:           [sheetParent setAcceptsMouseMovedEvents:YES];
    1:         }
    1:         SendSetZLevelEvent();
    1:       }
    1:     }
    1:     else {
 8769:       // If the window is a popup window with a parent window we need to
 8769:       // unhook it here before ordering it out. When you order out the child
 8769:       // of a window it hides the parent window.
 8769:       if (mWindowType == eWindowType_popup && nativeParentWindow)
 8769:         [nativeParentWindow removeChildWindow:mWindow];
 8769: 
    1:       [mWindow orderOut:nil];
 3574:       // Unless it's explicitly removed from NSApp's "window cache", a popup
 3574:       // window will keep receiving mouse-moved events even after it's been
 3574:       // "ordered out" (instead of the browser window that was underneath it,
 3574:       // until you click on that window).  This is bmo bug 378645, but it's
 3574:       // surely an Apple bug.  The "window cache" is an undocumented subsystem,
 3574:       // all of whose methods are included in the NSWindowCache category of
 3574:       // the NSApplication class (in header files generated using class-dump).
 3574:       // This workaround was "borrowed" from the Java Embedding Plugin (which
 3574:       // uses it for a different purpose).
30470:       if (mWindowType == eWindowType_popup)
 3574:         [NSApp _removeWindowFromCache:mWindow];
 8408: 
    1:       // it's very important to turn off mouse moved events when hiding a window, otherwise
    1:       // the windows' tracking rects will interfere with each other. (bug 356528)
    1:       [mWindow setAcceptsMouseMovedEvents:NO];
11899: 
 3574:       // If our popup window is a non-native context menu, tell the OS (and
 3574:       // other programs) that a menu has closed.
 3574:       if ([mWindow isKindOfClass:[PopupWindow class]] &&
 3574:           [(PopupWindow*) mWindow isContextMenu]) {
 3574:         [[NSDistributedNotificationCenter defaultCenter]
 3574:           postNotificationName:@"com.apple.HIToolbox.endMenuTrackingNotification"
 3574:                         object:@"org.mozilla.gecko.PopupWindow"];
 3574:       }
    1:     }
    1:   }
    1:   
    1:   if (mPopupContentView)
    1:       mPopupContentView->Show(bState);
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
 9499: void nsCocoaWindow::MakeBackgroundTransparent(PRBool aTransparent)
 9499: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 9499:   BOOL currentTransparency = ![mWindow isOpaque];
 9499:   if (aTransparent != currentTransparency) {
 9499:     [mWindow setOpaque:!aTransparent];
 9499:     [mWindow setBackgroundColor:(aTransparent ? [NSColor clearColor] : [NSColor whiteColor])];
 9499:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 9499: }
 9499: 
16601: nsTransparencyMode nsCocoaWindow::GetTransparencyMode()
 9499: {
18401:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
16601: 
16601:   return [mWindow isOpaque] ? eTransparencyOpaque : eTransparencyTransparent;
16601: 
18401:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(eTransparencyOpaque);
 9499: }
 9499: 
 9499: // This is called from nsMenuPopupFrame when making a popup transparent.
16601: // For other window types, nsChildView::SetTransparencyMode is used.
16601: void nsCocoaWindow::SetTransparencyMode(nsTransparencyMode aMode)
 9499: {
16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
16601: 
16601:   BOOL isTransparent = aMode == eTransparencyTransparent;
11978: 
 9499:   BOOL currentTransparency = ![mWindow isOpaque];
16601:   if (isTransparent != currentTransparency) {
 9499:     // Take care of window transparency
16601:     MakeBackgroundTransparent(isTransparent);
 9499:     // Make sure our content view is also transparent
 9499:     if (mPopupContentView) {
 9499:       ChildView *childView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
 9499:       if (childView) {
16601:         [childView setTransparent:isTransparent];
 9499:       }
 9499:     }
 9499:   }
16601: 
16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
 9499: }
 9499: 
    1: NS_METHOD nsCocoaWindow::AddEventListener(nsIEventListener * aListener)
    1: {
    1:   nsBaseWidget::AddEventListener(aListener);
    1: 
    1:   if (mPopupContentView)
    1:     mPopupContentView->AddEventListener(aListener);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Enable(PRBool aState)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::IsEnabled(PRBool *aState)
    1: {
    1:   if (aState)
    1:     *aState = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::ConstrainPosition(PRBool aAllowSlop,
    1:                                                PRInt32 *aX, PRInt32 *aY)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
 7635:   if (!mWindow || (mBounds.x == aX && mBounds.y == aY))
 7635:     return NS_OK;
 7635: 
 7635:   // The point we have is in Gecko coordinates (origin top-left). Convert
    1:   // it to Cocoa ones (origin bottom-left).
 8779:   NSPoint coord = {aX, nsCocoaUtils::FlippedScreenY(aY)};
    1:   [mWindow setFrameTopLeftPoint:coord];
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Position the window behind the given window
    1: NS_METHOD nsCocoaWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
    1:                                      nsIWidget *aWidget, PRBool aActivate)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Note bug 278777, we need to update state when the window is unminimized
    1: // from the dock by users.
    1: NS_METHOD nsCocoaWindow::SetSizeMode(PRInt32 aMode)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   PRInt32 previousMode;
    1:   nsBaseWidget::GetSizeMode(&previousMode);
    1: 
    1:   nsresult rv = nsBaseWidget::SetSizeMode(aMode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aMode == nsSizeMode_Normal) {
19112:     if ([mWindow isMiniaturized])
19112:       [mWindow deminiaturize:nil];
19112:     else if (previousMode == nsSizeMode_Maximized && [mWindow isZoomed])
    1:       [mWindow zoom:nil];
    1:   }
    1:   else if (aMode == nsSizeMode_Minimized) {
    1:     if (![mWindow isMiniaturized])
    1:       [mWindow miniaturize:nil];
    1:   }
    1:   else if (aMode == nsSizeMode_Maximized) {
    1:     if ([mWindow isMiniaturized])
    1:       [mWindow deminiaturize:nil];
    1:     if (![mWindow isZoomed])
    1:       [mWindow zoom:nil];
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 8590:   if (!WindowSizeAllowed(aWidth, aHeight))
 8590:     return NS_ERROR_FAILURE;
 8590: 
23738:   nsIntRect windowBounds(nsCocoaUtils::CocoaRectToGeckoRect([mWindow frame]));
 8351:   BOOL isMoving = (windowBounds.x != aX || windowBounds.y != aY);
 8351:   BOOL isResizing = (windowBounds.width != aWidth || windowBounds.height != aHeight);
 7635: 
 7635:   if (IsResizing() || !mWindow || (!isMoving && !isResizing))
 7635:     return NS_OK;
 7635: 
23738:   nsIntRect geckoRect(aX, aY, aWidth, aHeight);
 8779:   NSRect newFrame = nsCocoaUtils::GeckoRectToCocoaRect(geckoRect);
 7635: 
 8351:   // We have to report the size event -first-, to make sure that content
 8351:   // repositions itself.  Cocoa views are anchored at the bottom left,
 8351:   // so if we don't do this our child view will end up being stuck in the
 8351:   // wrong place during a resize.
 8351:   if (isResizing)
 8351:     ReportSizeEvent(&newFrame);
 8351: 
 7635:   StartResizing();
 8351:   // We ignore aRepaint -- we have to call display:YES, otherwise the
 8351:   // title bar doesn't immediately get repainted and is displayed in
 8351:   // the wrong place, leading to a visual jump.
 8351:   [mWindow setFrame:newFrame display:YES];
 7635:   StopResizing();
 7635: 
 8351:   // now, check whether we got the frame that we wanted
 8351:   NSRect actualFrame = [mWindow frame];
 8351:   if (newFrame.size.width != actualFrame.size.width || newFrame.size.height != actualFrame.size.height) {
 8351:     // We didn't; the window must have been too big or otherwise invalid.
 8351:     // Report -another- resize in this case, to make sure things are in
 8351:     // the right place.  This will cause some visual jitter, but
 8351:     // shouldn't happen often.
 7635:     ReportSizeEvent();
 8351:   }
 7635: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 8590:   if (!WindowSizeAllowed(aWidth, aHeight))
 8590:     return NS_ERROR_FAILURE;
 8590: 
23738:   nsIntRect windowBounds(nsCocoaUtils::CocoaRectToGeckoRect([mWindow frame]));
 8351:   return Resize(windowBounds.x, windowBounds.y, aWidth, aHeight, aRepaint);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
23738: NS_IMETHODIMP nsCocoaWindow::GetScreenBounds(nsIntRect &aRect)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
23738:   aRect = nsCocoaUtils::CocoaRectToGeckoRect([mWindow frame]);
    1:   // printf("GetScreenBounds: output: %d,%d,%d,%d\n", aRect.x, aRect.y, aRect.width, aRect.height);
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: PRBool nsCocoaWindow::OnPaint(nsPaintEvent &event)
    1: {
    1:   return PR_TRUE; // don't dispatch the update event
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::SetTitle(const nsAString& aTitle)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   const nsString& strTitle = PromiseFlatString(aTitle);
    1:   NSString* title = [NSString stringWithCharacters:strTitle.get() length:strTitle.Length()];
    1:   [mWindow setTitle:title];
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
23738: NS_IMETHODIMP nsCocoaWindow::Invalidate(const nsIntRect & aRect, PRBool aIsSynchronous)
    1: {
    1:   if (mPopupContentView)
    1:     return mPopupContentView->Invalidate(aRect, aIsSynchronous);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Invalidate(PRBool aIsSynchronous)
    1: {
    1:   if (mPopupContentView)
    1:     return mPopupContentView->Invalidate(aIsSynchronous);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Update()
    1: {
    1:   if (mPopupContentView)
    1:     return mPopupContentView->Update();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Pass notification of some drag event to Gecko
    1: //
    1: // The drag manager has let us know that something related to a drag has
    1: // occurred in this window. It could be any number of things, ranging from 
    1: // a drop, to a drag enter/leave, or a drag over event. The actual event
    1: // is passed in |aMessage| and is passed along to our event hanlder so Gecko
    1: // knows about it.
    1: PRBool nsCocoaWindow::DragEvent(unsigned int aMessage, Point aMouseGlobal, UInt16 aKeyModifiers)
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::SendSetZLevelEvent()
    1: {
    1:   nsZLevelEvent event(PR_TRUE, NS_SETZLEVEL, this);
    1: 
    1:   event.refPoint.x = mBounds.x;
    1:   event.refPoint.y = mBounds.y;
    1:   event.time = PR_IntervalNow();
    1: 
    1:   event.mImmediate = PR_TRUE;
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   DispatchEvent(&event, status);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::GetChildSheet(PRBool aShown, nsCocoaWindow** _retval)
    1: {
    1:   nsIWidget* child = GetFirstChild();
    1: 
    1:   while (child) {
    1:     nsWindowType type;
11899:     if (NS_SUCCEEDED(child->GetWindowType(type)) && type == eWindowType_sheet) {
    1:       // if it's a sheet, it must be an nsCocoaWindow
11899:       nsCocoaWindow* cocoaWindow = static_cast<nsCocoaWindow*>(child);
11899:       if ((aShown && [cocoaWindow->mWindow isVisible]) ||
    1:           (!aShown && cocoaWindow->mSheetNeedsShow)) {
    1:         *_retval = cocoaWindow;
    1:         return NS_OK;
    1:       }
    1:     }
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   *_retval = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
15026: NS_IMETHODIMP nsCocoaWindow::GetRealParent(nsIWidget** parent)
15026: {
15026:   *parent = mParent;
15026:   return NS_OK;
15026: }
15026: 
    1: NS_IMETHODIMP nsCocoaWindow::GetIsSheet(PRBool* isSheet)
    1: {
    1:   mWindowType == eWindowType_sheet ? *isSheet = PR_TRUE : *isSheet = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::GetSheetWindowParent(NSWindow** sheetWindowParent)
    1: {
    1:   *sheetWindowParent = mSheetWindowParent;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::ResetInputState()
    1: {
    1:   return NS_OK;
    1: }
    1: 
 6118: // Invokes callback and ProcessEvent methods on Event Listener object
    1: NS_IMETHODIMP 
    1: nsCocoaWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
    1: {
    1:   aStatus = nsEventStatus_eIgnore;
    1: 
    1:   nsIWidget* aWidget = event->widget;
    1:   NS_IF_ADDREF(aWidget);
    1: 
    1:   if (mEventCallback)
    1:     aStatus = (*mEventCallback)(event);
    1: 
    1:   // Dispatch to event listener if event was not consumed
 6118:   if (mEventListener && aStatus != nsEventStatus_eConsumeNoDefault)
    1:     aStatus = mEventListener->ProcessEvent(*event);
    1: 
    1:   NS_IF_RELEASE(aWidget);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
19112: nsCocoaWindow::DispatchSizeModeEvent(nsSizeMode aSizeMode)
19112: {
19112:   nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
19112:   event.mSizeMode = aSizeMode;
19112:   event.time = PR_IntervalNow();
19112: 
19112:   nsEventStatus status = nsEventStatus_eIgnore;
19112:   DispatchEvent(&event, status);
19112: }
19112: 
19112: void
 8351: nsCocoaWindow::ReportSizeEvent(NSRect *r)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 8351:   NSRect windowFrame;
 8351:   if (r)
 8351:     windowFrame = [mWindow contentRectForFrameRect:(*r)];
 8351:   else
 8351:     windowFrame = [mWindow contentRectForFrameRect:[mWindow frame]];
 5945:   mBounds.width  = nscoord(windowFrame.size.width);
 5945:   mBounds.height = nscoord(windowFrame.size.height);
 5945: 
    1:   nsSizeEvent sizeEvent(PR_TRUE, NS_SIZE, this);
    1:   sizeEvent.time = PR_IntervalNow();
    1: 
    1:   sizeEvent.windowSize = &mBounds;
    1:   sizeEvent.mWinWidth  = mBounds.width;
    1:   sizeEvent.mWinHeight = mBounds.height;
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   DispatchEvent(&sizeEvent, status);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
27089: void nsCocoaWindow::SetMenuBar(nsMenuBarX *aMenuBar)
    1: {
    1:   if (mMenuBar)
    1:     mMenuBar->SetParent(nsnull);
27089:   mMenuBar = aMenuBar;
    1: 
29018:   // Only paint for active windows, or paint the hidden window menu bar if no
29018:   // other menu bar has been painted yet so that some reasonable menu bar is
29018:   // displayed when the app starts up.
29018:   id windowDelegate = [mWindow delegate];
29018:   if (mMenuBar &&
29018:       ((!gSomeMenuBarPainted && nsMenuUtilsX::GetHiddenWindowMenuBar() == mMenuBar) ||
29018:        (windowDelegate && [windowDelegate toplevelActiveState])))
    1:     mMenuBar->Paint();
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::SetFocus(PRBool aState)
    1: {
29018:   if (mPopupContentView) {
    1:     mPopupContentView->SetFocus(aState);
29018:   }
29273:   else if (aState && [mWindow isVisible]) {
29273:     // if the window is shown, move it to the front
29018:     [mWindow setAcceptsMouseMovedEvents:YES];
29018:     [mWindow makeKeyAndOrderFront:nil];
29018:     SendSetZLevelEvent();
29018:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
25183: nsIntPoint nsCocoaWindow::WidgetToScreenOffset()
    1: {
25183:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
23738:   nsIntRect r = nsCocoaUtils::CocoaRectToGeckoRect([mWindow contentRectForFrameRect:[mWindow frame]]);
    1: 
25183:   return r.TopLeft();
25183: 
25183:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0,0));
    1: }
    1: 
15578: nsMenuBarX* nsCocoaWindow::GetMenuBar()
    1: {
    1:   return mMenuBar;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::CaptureRollupEvents(nsIRollupListener * aListener, 
    1:                                                  PRBool aDoCapture, 
    1:                                                  PRBool aConsumeRollupEvent)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   NS_IF_RELEASE(gRollupListener);
    1:   NS_IF_RELEASE(gRollupWidget);
    1:   
    1:   if (aDoCapture) {
    1:     gRollupListener = aListener;
    1:     NS_ADDREF(aListener);
    1:     gRollupWidget = this;
    1:     NS_ADDREF(this);
28346: 
28346:     gConsumeRollupEvent = aConsumeRollupEvent;
28346: 
 6494:     // Sometimes more than one popup window can be visible at the same time
 6494:     // (e.g. nested non-native context menus, or the test case (attachment
 6494:     // 276885) for bmo bug 392389, which displays a non-native combo-box in
 6494:     // a non-native popup window).  In these cases the "active" popup window
 6494:     // (the one that corresponds to the current gRollupWidget) should be the
 6494:     // topmost -- the (nested) context menu the mouse is currently over, or
 6494:     // the combo-box's drop-down list (when it's displayed).  But (among
 6494:     // windows that have the same "level") OS X makes topmost the window that
 6494:     // last received a mouse-down event, which may be incorrect (in the combo-
 6494:     // box case, it makes topmost the window containing the combo-box).  So
 6494:     // here we fiddle with a non-native popup window's level to make sure the
 6494:     // "active" one is always above any other non-native popup windows that
 6494:     // may be visible.
 6494:     if (mWindow && (mWindowType == eWindowType_popup))
 6494:       [mWindow setLevel:NSPopUpMenuWindowLevel];
 6494:   } else {
 6494:     if (mWindow && (mWindowType == eWindowType_popup))
 6494:       [mWindow setLevel:NSModalPanelWindowLevel];
    1:   }
    1:   
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::GetAttention(PRInt32 aCycleCount)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   [NSApp requestUserAttention:NSInformationalRequest];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
27993: PRBool
27993: nsCocoaWindow::HasPendingInputEvent()
27993: {
27993:   return nsChildView::DoHasPendingInputEvent();
27993: }
    1: 
20467: NS_IMETHODIMP nsCocoaWindow::SetWindowShadowStyle(PRInt32 aStyle)
20467: {
20467:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
20467: 
20467:   if ([mWindow hasShadow] != (aStyle != NS_STYLE_WINDOW_SHADOW_NONE))
20467:     [mWindow setHasShadow:(aStyle != NS_STYLE_WINDOW_SHADOW_NONE)];
20467:   return NS_OK;
20467: 
20467:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
20467: }
20467: 
14886: NS_IMETHODIMP nsCocoaWindow::SetWindowTitlebarColor(nscolor aColor, PRBool aActive)
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 8469:   // If our cocoa window isn't a ToolbarWindow, something is wrong.
 7242:   if (![mWindow isKindOfClass:[ToolbarWindow class]]) {
 8469:     // Don't output a warning for the hidden window.
13608:     NS_WARN_IF_FALSE(SameCOMIdentity(nsCocoaUtils::GetHiddenWindowWidget(), (nsIWidget*)this),
 8469:                      "Calling SetWindowTitlebarColor on window that isn't of the ToolbarWindow class.");
 7242:     return NS_ERROR_FAILURE;
 7242:   }
 7242: 
 7242:   // If they pass a color with a complete transparent alpha component, use the
 7242:   // native titlebar appearance.
 7242:   if (NS_GET_A(aColor) == 0) {
14886:     [(ToolbarWindow*)mWindow setTitlebarColor:nil forActiveWindow:(BOOL)aActive]; 
 7242:   } else {
14002:     // Transform from sRGBA to monitor RGBA. This seems like it would make trying
14002:     // to match the system appearance lame, so probably we just shouldn't color 
14002:     // correct chrome.
19127:     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
27035:       qcms_transform *transform = gfxPlatform::GetCMSRGBATransform();
19127:       if (transform) {
19127:         PRUint8 color[3];
19127:         color[0] = NS_GET_R(aColor);
19127:         color[1] = NS_GET_G(aColor);
19127:         color[2] = NS_GET_B(aColor);
27035:         qcms_transform_data(transform, color, color, 1);
19127:         aColor = NS_RGB(color[0], color[1], color[2]);
19127:       }
19127:     }
14002: 
 7242:     [(ToolbarWindow*)mWindow setTitlebarColor:[NSColor colorWithDeviceRed:NS_GET_R(aColor)/255.0
 7242:                                                                     green:NS_GET_G(aColor)/255.0
 7242:                                                                      blue:NS_GET_B(aColor)/255.0
14886:                                                                     alpha:NS_GET_A(aColor)/255.0]
14886:                               forActiveWindow:(BOOL)aActive];
 7242:   }
 7242:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 7242: }
 7242: 
 4174: gfxASurface* nsCocoaWindow::GetThebesSurface()
 4174: {
 4174:   if (mPopupContentView)
 4174:     return mPopupContentView->GetThebesSurface();
 4174:   return nsnull;
 4174: }
 4174: 
 6348: NS_IMETHODIMP nsCocoaWindow::BeginSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::BeginSecureKeyboardInput();
 6348:   if (NS_SUCCEEDED(rv))
 6348:     ::EnableSecureEventInput();
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
 6348: NS_IMETHODIMP nsCocoaWindow::EndSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
 6348:   if (NS_SUCCEEDED(rv))
 6348:     ::DisableSecureEventInput();
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
20506: // Callback used by the default titlebar and toolbar shading.
20506: // *aIn == 0 at the top of the titlebar/toolbar, *aIn == 1 at the bottom
20506: /* static */ void
20506: nsCocoaWindow::UnifiedShading(void* aInfo, const float* aIn, float* aOut)
20506: {
20506:   UnifiedGradientInfo* info = (UnifiedGradientInfo*)aInfo;
20506:   // The gradient percentage at the bottom of the titlebar / top of the toolbar
20506:   float start = info->titlebarHeight / (info->titlebarHeight + info->toolbarHeight - 1);
20506:   const float startGrey = NativeGreyColorAsFloat(headerStartGrey, info->windowIsMain);
20506:   const float endGrey = NativeGreyColorAsFloat(headerEndGrey, info->windowIsMain);
20506:   // *aIn is the gradient percentage of the titlebar or toolbar gradient,
20506:   // a is the gradient percentage of the whole unified gradient.
20506:   float a = info->drawTitlebar ? *aIn * start : start + *aIn * (1 - start);
20506:   float result = (1.0f - a) * startGrey + a * endGrey;
20506:   aOut[0] = result;
20506:   aOut[1] = result;
20506:   aOut[2] = result;
20506:   aOut[3] = 1.0f;
20506: }
20506: 
    1: @implementation WindowDelegate
    1: 
    1: // We try to find a gecko menu bar to paint. If one does not exist, just paint
    1: // the application menu by itself so that a window doesn't have some other
    1: // window's menu bar.
    1: + (void)paintMenubarForWindow:(NSWindow*)aWindow
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // make sure we only act on windows that have this kind of
    1:   // object as a delegate
    1:   id windowDelegate = [aWindow delegate];
    1:   if ([windowDelegate class] != [self class])
    1:     return;
    1: 
    1:   nsCocoaWindow* geckoWidget = [windowDelegate geckoWidget];
    1:   NS_ASSERTION(geckoWidget, "Window delegate not returning a gecko widget!");
    1:   
15578:   nsMenuBarX* geckoMenuBar = geckoWidget->GetMenuBar();
    1:   if (geckoMenuBar) {
    1:     geckoMenuBar->Paint();
    1:   }
    1:   else {
    1:     // sometimes we don't have a native application menu early in launching
    1:     if (!sApplicationMenu)
    1:       return;
    1: 
 8087:     NSMenu* mainMenu = [NSApp mainMenu];
 8087:     NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
    1: 
14024:     // Create a new menu bar.
14024:     // We create a GeckoNSMenu because all menu bar NSMenu objects should use that subclass for
14024:     // key handling reasons.
14024:     GeckoNSMenu* newMenuBar = [[GeckoNSMenu alloc] initWithTitle:@"MainMenuBar"];
 8087: 
 8087:     // move the application menu from the existing menu bar to the new one
 8087:     NSMenuItem* firstMenuItem = [[mainMenu itemAtIndex:0] retain];
 8087:     [mainMenu removeItemAtIndex:0];
 8087:     [newMenuBar insertItem:firstMenuItem atIndex:0];
 8087:     [firstMenuItem release];
    1: 
    1:     // set our new menu bar as the main menu
    1:     [NSApp setMainMenu:newMenuBar];
    1:     [newMenuBar release];
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (id)initWithGeckoWindow:(nsCocoaWindow*)geckoWind
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   [super init];
    1:   mGeckoWindow = geckoWind;
14885:   mToplevelActiveState = PR_FALSE;
    1:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSSize)windowWillResize:(NSWindow *)sender toSize:(NSSize)proposedFrameSize
    1: {
 2314:   RollUpPopups();
    1:   
    1:   return proposedFrameSize;
    1: }
    1: 
    1: - (void)windowDidResize:(NSNotification *)aNotification
    1: {
 5945:   if (!mGeckoWindow || mGeckoWindow->IsResizing())
    1:     return;
    1: 
 5945:   mGeckoWindow->ReportSizeEvent();
    1: }
    1: 
    1: - (void)windowDidBecomeMain:(NSNotification *)aNotification
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2314:   RollUpPopups();
 1579: 
13608:   // [NSApp _isRunningAppModal] will return true if we're running an OS dialog
13608:   // app modally. If one of those is up then we want it to retain its menu bar.
13608:   if ([NSApp _isRunningAppModal])
13608:     return;
    1:   NSWindow* window = [aNotification object];
    1:   if (window)
    1:     [WindowDelegate paintMenubarForWindow:window];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)windowDidResignMain:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: 
13608:   // [NSApp _isRunningAppModal] will return true if we're running an OS dialog
13608:   // app modally. If one of those is up then we want it to retain its menu bar.
13608:   if ([NSApp _isRunningAppModal])
13608:     return;
15578:   nsRefPtr<nsMenuBarX> hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
    1:   if (hiddenWindowMenuBar) {
    1:     // printf("painting hidden window menu bar due to window losing main status\n");
    1:     hiddenWindowMenuBar->Paint();
    1:   }
    1: }
    1: 
    1: - (void)windowDidBecomeKey:(NSNotification *)aNotification
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   NSWindow* window = [aNotification object];
    1:   if ([window isSheet])
    1:     [WindowDelegate paintMenubarForWindow:window];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)windowDidResignKey:(NSNotification *)aNotification
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // If a sheet just resigned key then we should paint the menu bar
    1:   // for whatever window is now main.
    1:   NSWindow* window = [aNotification object];
    1:   if ([window isSheet])
    1:     [WindowDelegate paintMenubarForWindow:[NSApp mainWindow]];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)windowWillMove:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: }
    1: 
 1357: - (void)windowDidMove:(NSNotification *)aNotification
 1357: {
 1357:   // Dispatch the move event to Gecko
 1357:   nsGUIEvent guiEvent(PR_TRUE, NS_MOVE, mGeckoWindow);
23738:   nsIntRect rect;
 1357:   mGeckoWindow->GetScreenBounds(rect);
 1357:   guiEvent.refPoint.x = rect.x;
 1357:   guiEvent.refPoint.y = rect.y;
 1357:   guiEvent.time = PR_IntervalNow();
 1357:   nsEventStatus status = nsEventStatus_eIgnore;
 1357:   mGeckoWindow->DispatchEvent(&guiEvent, status);
 1357: }
    1: 
    1: - (BOOL)windowShouldClose:(id)sender
    1: {
    1:   // We only want to send NS_XUL_CLOSE and let gecko close the window
    1:   nsGUIEvent guiEvent(PR_TRUE, NS_XUL_CLOSE, mGeckoWindow);
    1:   guiEvent.time = PR_IntervalNow();
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   mGeckoWindow->DispatchEvent(&guiEvent, status);
    1:   return NO; // gecko will do it
    1: }
    1: 
    1: - (void)windowWillClose:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: }
    1: 
    1: - (void)windowWillMiniaturize:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: }
    1: 
19112: - (void)windowDidMiniaturize:(NSNotification *)aNotification
19112: {
19112:   if (mGeckoWindow)
19112:     mGeckoWindow->DispatchSizeModeEvent(nsSizeMode_Minimized);
19112: }
19112: 
19112: - (void)windowDidDeminiaturize:(NSNotification *)aNotification
19112: {
19112:   if (mGeckoWindow)
19112:     mGeckoWindow->DispatchSizeModeEvent(nsSizeMode_Normal);
19112: }
19112: 
 4208: - (void)sendFocusEvent:(PRUint32)eventType
    1: {
    1:   if (!mGeckoWindow)
    1:     return;
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
 4208:   nsGUIEvent focusGuiEvent(PR_TRUE, eventType, mGeckoWindow);
    1:   focusGuiEvent.time = PR_IntervalNow();
    1:   mGeckoWindow->DispatchEvent(&focusGuiEvent, status);
    1: }
    1: 
    1: - (void)didEndSheet:(NSWindow*)sheet returnCode:(int)returnCode contextInfo:(void*)contextInfo
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
15026:   // Note: 'contextInfo' (if it is set) is the window that is the parent of
15026:   // the sheet.  The value of contextInfo is determined in
15026:   // nsCocoaWindow::Show().  If it's set, 'contextInfo' is always the top-
15026:   // level window, not another sheet itself.  But 'contextInfo' is nil if
15026:   // our parent window is also a sheet -- in that case we shouldn't send
15026:   // the top-level window any activate events (because it's our parent
15026:   // window that needs to get these events, not the top-level window).
14885:   [TopLevelWindowData deactivateInWindow:sheet];
    1:   [sheet orderOut:self];
15026:   if (contextInfo)
14885:     [TopLevelWindowData activateInWindow:(NSWindow*)contextInfo];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
  604: - (nsCocoaWindow*)geckoWidget
    1: {
    1:   return mGeckoWindow;
    1: }
    1: 
14885: - (PRBool)toplevelActiveState
14885: {
14885:   return mToplevelActiveState;
14885: }
14885: 
14885: - (void)sendToplevelActivateEvents
14885: {
14885:   if (!mToplevelActiveState) {
14885:     [self sendFocusEvent:NS_ACTIVATE];
14885:     mToplevelActiveState = PR_TRUE;
14885:   }
14885: }
14885: 
14885: - (void)sendToplevelDeactivateEvents
14885: {
14885:   if (mToplevelActiveState) {
14885:     [self sendFocusEvent:NS_DEACTIVATE];
14885:     mToplevelActiveState = PR_FALSE;
14885:   }
14885: }
14885: 
    1: @end
 2029: 
 7242: // Category on NSWindow so callers can use the same method on both ToolbarWindows
 7242: // and NSWindows for accessing the background color.
 7242: @implementation NSWindow(ToolbarWindowCompat)
 7242: 
 7242: - (NSColor*)windowBackgroundColor
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7242:   return [self backgroundColor];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7242: }
 7242: 
 7242: @end
 7242: 
19295: @interface ToolbarWindow(Private)
19295: 
19295: - (void)redrawTitlebar;
19295: 
19295: @end
19295: 
 7242: // This class allows us to have a "unified toolbar" style window. It works like this:
 7242: // 1) We set the window's style to textured.
 7242: // 2) Because of this, the background color applies to the entire window, including
 7242: //     the titlebar area. For normal textured windows, the default pattern is a 
19295: //    "brushed metal" image on Tiger and a unified gradient on Leopard.
 7242: // 3) We set the background color to a custom NSColor subclass that knows how tall the window is.
 7242: //    When -set is called on it, it sets a pattern (with a draw callback) as the fill. In that callback,
19295: //    it paints the the titlebar and background colors in the correct areas of the context it's given,
 7242: //    which will fill the entire window (CG will tile it horizontally for us).
19295: // 4) Whenever the window's main state changes and when [window display] is called,
19295: //    Cocoa redraws the titlebar using the patternDraw callback function.
 7242: //
 7242: // This class also provides us with a pill button to show/hide the toolbar.
19295: //
19295: // Drawing the unified gradient in the titlebar and the toolbar works like this:
19295: // 1) In the style sheet we set the toolbar's -moz-appearance to -moz-mac-unified-toolbar.
19295: // 2) When the toolbar is drawn, Gecko calls nsNativeThemeCocoa::DrawWidgetBackground
19295: //    for the widget type NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR.
19295: // 3) This calls DrawUnifiedToolbar which finds the toolbar frame's ToolbarWindow
19295: //    and passes the toolbar frame's height to setUnifiedToolbarHeight.
19295: // 4) If the toolbar height has changed, a titlebar redraw is triggered by
19295: //    [self display] and the upper part of the unified gradient is drawn in the
19295: //    titlebar.
19295: // 5) DrawUnifiedToolbar draws the lower part of the unified gradient in the toolbar.
19295: //
19295: // Whenever the unified gradient is drawn in the titlebar or the toolbar, both
19295: // titlebar height and toolbar height must be known in order to construct the
19295: // correct gradient (which is a linear gradient with the length
19295: // titlebarHeight + toolbarHeight - 1). But you can only get from the toolbar frame
19295: // to the containing window - the other direction doesn't work. That's why the
19295: // toolbar height is cached in the ToolbarWindow but nsNativeThemeCocoa can simply
19295: // query the window for its titlebar height when drawing the toolbar.
 2029: @implementation ToolbarWindow
 2029: 
 7242: - (id)initWithContentRect:(NSRect)aContentRect styleMask:(unsigned int)aStyle backing:(NSBackingStoreType)aBufferingType defer:(BOOL)aFlag
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7242:   aStyle = aStyle | NSTexturedBackgroundWindowMask;
 7242:   if ((self = [super initWithContentRect:aContentRect styleMask:aStyle backing:aBufferingType defer:aFlag])) {
14886:     mColor = [[TitlebarAndBackgroundColor alloc] initWithActiveTitlebarColor:nil
14886:                                                        inactiveTitlebarColor:nil
14886:                                                              backgroundColor:[NSColor whiteColor]
 7242:                                                                    forWindow:self];
 7242:     // Call the superclass's implementation, to avoid our guard method below.
 7242:     [super setBackgroundColor:mColor];
 7242: 
19295:     mUnifiedToolbarHeight = 0.0f;
19295:     mSuppressPainting = NO;
19295: 
 7242:     // setBottomCornerRounded: is a private API call, so we check to make sure
 7242:     // we respond to it just in case.
 7242:     if ([self respondsToSelector:@selector(setBottomCornerRounded:)])
 7242:       [self setBottomCornerRounded:NO];
 7242:   }
 7242:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7242: }
 7242: 
 7242: - (void)dealloc
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   [mColor release];
 7242:   [super dealloc];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: // We don't provide our own implementation of -backgroundColor because NSWindow
 7242: // looks at it, apparently. This is here to keep someone from messing with our
 7242: // custom NSColor subclass.
 7242: - (void)setBackgroundColor:(NSColor*)aColor
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   [mColor setBackgroundColor:aColor];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: // If you need to get at the background color of the window (in the traditional
 7242: // sense) use this method instead.
 7242: - (NSColor*)windowBackgroundColor
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7242:   return [mColor backgroundColor];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7242: }
 7242: 
 7242: // Pass nil here to get the default appearance.
14886: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14886:   [mColor setTitlebarColor:aColor forActiveWindow:aActive];
26649:   [self redrawTitlebar];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
19295: // This is called by nsNativeThemeCocoa.mm's DrawUnifiedToolbar.
19295: // We need to know the toolbar's height in order to draw the correct
19295: // unified gradient in the titlebar.
19295: - (void)setUnifiedToolbarHeight:(float)aToolbarHeight
 7242: {
19295:   if (mUnifiedToolbarHeight == aToolbarHeight)
19295:     return;
19295:   mUnifiedToolbarHeight = aToolbarHeight;
19295:   [self redrawTitlebar];
14886: }
14886: 
19295: - (float)unifiedToolbarHeight
14886: {
19295:   return mUnifiedToolbarHeight;
 7242: }
 7242: 
19295: - (float)titlebarHeight
19295: {
19295:   NSRect frameRect = [self frame];
19295:   return frameRect.size.height - [self contentRectForFrameRect:frameRect].size.height;
19295: }
19295: 
19295: - (BOOL)isPaintingSuppressed
19295: {
19295:   return mSuppressPainting;
19295: }
 7242: 
 7242: // Always show the toolbar pill button.
 2029: - (BOOL)_hasToolbar
 2029: {
 2029:   return YES;
 2029: }
 2029: 
 7242: // Dispatch a toolbar pill button clicked message to Gecko.
 2029: - (void)_toolbarPillButtonClicked:(id)sender
 2029: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2029:   nsCocoaWindow *geckoWindow = [[self delegate] geckoWidget];
15025:   if (!geckoWindow)
15025:     return;
 2029:   nsEventStatus status = nsEventStatus_eIgnore;
 2029:   nsGUIEvent guiEvent(PR_TRUE, NS_OS_TOOLBAR, geckoWindow);
 2029:   guiEvent.time = PR_IntervalNow();
 2029:   geckoWindow->DispatchEvent(&guiEvent, status);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2029: }
 2029: 
 7106: // Retain and release "self" to avoid crashes when our widget (and its native
 7106: // window) is closed as a result of processing a key equivalent (e.g.
 7106: // Command+w or Command+q).  This workaround is only needed for a window
 7106: // that can become key.
 7106: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
 7106: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 7106:   NSWindow *nativeWindow = [self retain];
 7106:   BOOL retval = [super performKeyEquivalent:theEvent];
 7106:   [nativeWindow release];
 7106:   return retval;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 7106: }
 7106: 
13491: - (void)sendEvent:(NSEvent *)anEvent
13491: {
13491:   NSEventType type = [anEvent type];
13491:   
13491:   switch (type) {
13491:     case NSScrollWheel:
13491:     case NSLeftMouseDown:
13491:     case NSLeftMouseUp:
13491:     case NSRightMouseDown:
13491:     case NSRightMouseUp:
13491:     case NSOtherMouseDown:
13491:     case NSOtherMouseUp:
13491:     case NSMouseMoved:
13491:     case NSLeftMouseDragged:
13491:     case NSRightMouseDragged:
13491:     case NSOtherMouseDragged:
13520:     {
13491:       // Drop all mouse events if a modal window has appeared above us.
13491:       // This helps make us behave as if the OS were running a "real" modal
13491:       // event loop.
13491:       id delegate = [self delegate];
13491:       if (delegate && [delegate isKindOfClass:[WindowDelegate class]]) {
13491:         nsCocoaWindow *widget = [(WindowDelegate *)delegate geckoWidget];
13491:         if (widget) {
26321:           if (gGeckoAppModalWindowList && (widget != gGeckoAppModalWindowList->window))
13491:             return;
13491:           if (widget->HasModalDescendents())
13491:             return;
13491:         }
13491:       }
13491:       break;
13520:     }
13491:     default:
13491:       break;
13491:   }
13491: 
13491:   [super sendEvent:anEvent];
13491: }
13491: 
 2029: @end
 3574: 
19295: @implementation ToolbarWindow(Private)
19295: 
19295: // [self display] seems to be the only way to repaint a window's titlebar.
19295: // The bad thing about it is that it repaints all the window's subviews as well.
19295: // So we use a guard to prevent unnecessary redrawing.
19295: - (void)redrawTitlebar
19295: {
19295:   mSuppressPainting = YES;
19295:   [self display];
19295:   mSuppressPainting = NO;
19295: }
19295: 
19295: @end
 7242: 
 7242: // Custom NSColor subclass where most of the work takes place for drawing in
 7242: // the titlebar area.
 7242: @implementation TitlebarAndBackgroundColor
 7242: 
14886: - (id)initWithActiveTitlebarColor:(NSColor*)aActiveTitlebarColor
14886:             inactiveTitlebarColor:(NSColor*)aInactiveTitlebarColor
14886:                   backgroundColor:(NSColor*)aBackgroundColor
 7242:                         forWindow:(NSWindow*)aWindow
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7242:   if ((self = [super init])) {
14886:     mActiveTitlebarColor = [aActiveTitlebarColor retain];
14886:     mInactiveTitlebarColor = [aInactiveTitlebarColor retain];
 7242:     mBackgroundColor = [aBackgroundColor retain];
 8908:     mWindow = aWindow; // weak ref to avoid a cycle
 7242:   }
 7242:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7242: }
 7242: 
 7242: - (void)dealloc
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14886:   [mActiveTitlebarColor release];
14886:   [mInactiveTitlebarColor release];
 7242:   [mBackgroundColor release];
 7242:   [super dealloc];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: // Our pattern width is 1 pixel. CoreGraphics can cache and tile for us.
 7242: static const float sPatternWidth = 1.0f;
 7242: 
 7242: // Callback where all of the drawing for this color takes place.
 7242: void patternDraw(void* aInfo, CGContextRef aContext)
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   TitlebarAndBackgroundColor *color = (TitlebarAndBackgroundColor*)aInfo;
 7242:   NSColor *backgroundColor = [color backgroundColor];
19295:   ToolbarWindow *window = (ToolbarWindow*)[color window];
 8908:   BOOL isMain = [window isMainWindow];
14886:   NSColor *titlebarColor = isMain ? [color activeTitlebarColor] : [color inactiveTitlebarColor];
 7242: 
 7242:   // Remember: this context is NOT flipped, so the origin is in the bottom left.
19295:   float titlebarHeight = [window titlebarHeight];
 7242:   float titlebarOrigin = [window frame].size.height - titlebarHeight;
 7242: 
19295:   UnifiedGradientInfo info = { titlebarHeight, [window unifiedToolbarHeight], isMain, YES };
19295: 
 7242:   [NSGraphicsContext saveGraphicsState];
 7242:   [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:aContext flipped:NO]];
 7242: 
 7242:   // If the titlebar color is nil, draw the default titlebar shading.
 7242:   if (!titlebarColor) {
20506:     // Create and draw a CGShading that uses nsCocoaWindow::UnifiedShading() as its callback.
20506:     CGFunctionCallbacks callbacks = {0, nsCocoaWindow::UnifiedShading, NULL};
19295:     CGFunctionRef function = CGFunctionCreate(&info, 1, NULL, 4, NULL, &callbacks);
 7242:     CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
19295:     CGShadingRef shading = CGShadingCreateAxial(colorSpace,
 7242:                                                 CGPointMake(0.0f, titlebarOrigin + titlebarHeight),
19295:                                                 CGPointMake(0.0f, titlebarOrigin),
 7242:                                                 function, NO, NO);
 7242:     CGColorSpaceRelease(colorSpace);
 7242:     CGFunctionRelease(function);
 7242:     CGContextDrawShading(aContext, shading);
 7762:     CGShadingRelease(shading);
 7242: 
 7242:     // Draw the one pixel border at the bottom of the titlebar.
19295:     if ([window unifiedToolbarHeight] == 0) {
19320:       [NativeGreyColorAsNSColor(headerBorderGrey, isMain) set];
 7242:       NSRectFill(NSMakeRect(0.0f, titlebarOrigin, sPatternWidth, 1.0f));
19295:     }
 7242:   } else {
 7242:     // if the titlebar color is not nil, just set and draw it normally.
 7242:     [titlebarColor set];
 7242:     NSRectFill(NSMakeRect(0.0f, titlebarOrigin, sPatternWidth, titlebarHeight));
 7242:   }
 7242: 
 7242:   // Draw the background color of the window everywhere but where the titlebar is.
 7242:   [backgroundColor set];
 7242:   NSRectFill(NSMakeRect(0.0f, 0.0f, 1.0f, titlebarOrigin));
 7242: 
 7242:   [NSGraphicsContext restoreGraphicsState];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: - (void)setFill
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   CGContextRef context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
 7242: 
 7242:   // Set up the pattern to be as tall as our window, and one pixel wide.
 7242:   // CoreGraphics can cache and tile us quickly.
 7242:   CGPatternCallbacks callbacks = {0, &patternDraw, NULL};
 7242:   CGPatternRef pattern = CGPatternCreate(self, CGRectMake(0.0f, 0.0f, sPatternWidth, [mWindow frame].size.height), 
 7242:                                          CGAffineTransformIdentity, 1, [mWindow frame].size.height,
 7242:                                          kCGPatternTilingConstantSpacing, true, &callbacks);
 7242: 
 7242:   // Set the pattern as the fill, which is what we were asked to do. All our
 7242:   // drawing will take place in the patternDraw callback.
 7242:   CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);
 7242:   CGContextSetFillColorSpace(context, patternSpace);
 7242:   CGColorSpaceRelease(patternSpace);
 7242:   float component = 1.0f;
 7242:   CGContextSetFillPattern(context, pattern, &component);
 7242:   CGPatternRelease(pattern);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: // Pass nil here to get the default appearance.
14886: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
14886:   if (aActive) {
14886:     [mActiveTitlebarColor autorelease];
14886:     mActiveTitlebarColor = [aColor retain];
14886:   } else {
14886:     [mInactiveTitlebarColor autorelease];
14886:     mInactiveTitlebarColor = [aColor retain];
14886:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
14886: - (NSColor*)activeTitlebarColor
 7242: {
14886:   return mActiveTitlebarColor;
14886: }
14886: 
14886: - (NSColor*)inactiveTitlebarColor
14886: {
14886:   return mInactiveTitlebarColor;
 7242: }
 7242: 
 7242: - (void)setBackgroundColor:(NSColor*)aColor
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   [mBackgroundColor autorelease];
 7242:   mBackgroundColor = [aColor retain];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: - (NSColor*)backgroundColor
 7242: {
 7242:   return mBackgroundColor;
 7242: }
 7242: 
 7242: - (NSWindow*)window
 7242: {
 7242:   return mWindow;
 7242: }
 7242: 
 7242: - (NSString*)colorSpaceName
 7242: {
 7242:   return NSDeviceRGBColorSpace;
 7242: }
 7242: 
 7242: - (void)set
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   [self setFill];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
 7242: @end
 7242: 
 3574: @implementation PopupWindow
 3574: 
 3574: // The OS treats our custom popup windows very strangely -- many mouse events
 3574: // sent to them never reach their target NSView objects.  (That these windows
 3574: // are borderless and of level NSPopUpMenuWindowLevel may have something to do
 3574: // with it.)  The best solution is to pre-empt the OS, as follows.  (All
 3574: // events for a given NSWindow object go through its sendEvent: method.)
 3574: - (void)sendEvent:(NSEvent *)anEvent
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 9368:   NSView *target = nil;
 9368:   NSView *contentView = nil;
 3574:   NSEventType type = [anEvent type];
 6494:   NSPoint windowLocation = NSZeroPoint;
 3574:   switch (type) {
 3574:     case NSScrollWheel:
 3574:     case NSLeftMouseDown:
 3574:     case NSLeftMouseUp:
 3574:     case NSRightMouseDown:
 3574:     case NSRightMouseUp:
 3574:     case NSOtherMouseDown:
 3574:     case NSOtherMouseUp:
 3574:     case NSMouseMoved:
 3574:     case NSLeftMouseDragged:
 3574:     case NSRightMouseDragged:
 3574:     case NSOtherMouseDragged:
 9368:       if ((contentView = [self contentView])) {
 8779:         // Since [anEvent window] might not be us, we can't use [anEvent locationInWindow].
 8779:         windowLocation = nsCocoaUtils::EventLocationForWindow(anEvent, self);
 8779:         target = [contentView hitTest:[contentView convertPoint:windowLocation fromView:nil]];
 9368:         // If the hit test failed, the event is targeted here but is not over the window.
 9368:         // Target it at the first responder.
 9368:         if (!target)
 9368:           target = (NSView*)[self firstResponder];
 3574:       }
 3574:       break;
 3574:     default:
 3574:       break;
 3574:   }
 3574:   if (target) {
 3574:     switch (type) {
 3574:       case NSScrollWheel:
 3574:         [target scrollWheel:anEvent];
 3574:         break;
 3574:       case NSLeftMouseDown:
15573:         if ([NSApp isActive]) {
 3574:           [target mouseDown:anEvent];
15573:         } else if (mIsContextMenu) {
15573:           [target mouseDown:anEvent];
15573:           // If we're in a context menu and our NSApp isn't active (i.e. if
15573:           // we're in a context menu raised by a right mouse-down event), we
15573:           // don't want the OS to send the coming NSLeftMouseUp event to NSApp
15573:           // via the window server, but we do want our ChildView to receive an
15573:           // NSLeftMouseUp event (and to send a Gecko NS_MOUSE_BUTTON_UP event
15573:           // to the corresponding nsChildView object).  If our NSApp isn't
15573:           // active when it receives the coming NSLeftMouseUp via the window
15573:           // server, our app will (in effect) become partially activated,
15573:           // which has strange side effects:  For example, if another app's
15573:           // window had the focus, that window will lose the focus and the
 3574:           // other app's main menu will be completely disabled (though it will
 3574:           // continue to be displayed).
 9368:           // A side effect of not allowing the coming NSLeftMouseUp event to be
 3574:           // sent to NSApp via the window server is that our custom context
 3574:           // menus will roll up whenever the user left-clicks on them, whether
 3574:           // or not the left-click hit an active menu item.  This is how native
 3574:           // context menus behave, but wasn't how our custom context menus
 3574:           // behaved previously (on the trunk or e.g. in Firefox 2.0.0.4).
 3574:           // If our ChildView's corresponding nsChildView object doesn't
 3574:           // dispatch an NS_MOUSE_BUTTON_UP event, none of our active menu items
 9368:           // will "work" on an NSLeftMouseUp.
 3574:           NSEvent *newEvent = [NSEvent mouseEventWithType:NSLeftMouseUp
 6494:                                                  location:windowLocation
19704:                                             modifierFlags:nsCocoaUtils::GetCocoaEventModifierFlags(anEvent)
 3574:                                                 timestamp:GetCurrentEventTime()
 6494:                                              windowNumber:[self windowNumber]
 3574:                                                   context:nil
 3574:                                               eventNumber:0
 3574:                                                clickCount:1
 3574:                                                  pressure:0.0];
 3574:           [target mouseUp:newEvent];
 3574:           RollUpPopups();
15573:         } else {
15573:           // If our NSApp isn't active and we're not a context menu (i.e. if
15573:           // we're an ordinary popup window), activate us before sending the
15573:           // event to its target.  This prevents us from being used in the
15573:           // background, and resolves bmo bug 434097 (another app focus
15573:           // wierdness bug).
15573:           [NSApp activateIgnoringOtherApps:YES];
15573:           [target mouseDown:anEvent];
 3574:         }
 3574:         break;
 3574:       case NSLeftMouseUp:
 3574:         [target mouseUp:anEvent];
 3574:         break;
 3574:       case NSRightMouseDown:
 3574:         [target rightMouseDown:anEvent];
 3574:         break;
 3574:       case NSRightMouseUp:
 3574:         [target rightMouseUp:anEvent];
 3574:         break;
 3574:       case NSOtherMouseDown:
 3574:         [target otherMouseDown:anEvent];
 3574:         break;
 3574:       case NSOtherMouseUp:
 3574:         [target otherMouseUp:anEvent];
 3574:         break;
 3574:       case NSMouseMoved:
 3574:         [target mouseMoved:anEvent];
 3574:         break;
 3574:       case NSLeftMouseDragged:
 3574:         [target mouseDragged:anEvent];
 3574:         break;
 3574:       case NSRightMouseDragged:
 3574:         [target rightMouseDragged:anEvent];
 3574:         break;
 3574:       case NSOtherMouseDragged:
 3574:         [target otherMouseDragged:anEvent];
 3574:         break;
 3574:       default:
 3574:         [super sendEvent:anEvent];
 3574:         break;
 3574:     }
 3574:   } else {
 3574:     [super sendEvent:anEvent];
 3574:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 3574: }
 3574: 
 3574: - (id)initWithContentRect:(NSRect)contentRect styleMask:(unsigned int)styleMask
 3574:       backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 3574:   mIsContextMenu = false;
 3574:   return [super initWithContentRect:contentRect styleMask:styleMask
 3574:           backing:bufferingType defer:deferCreation];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 3574: }
 3574: 
 3574: - (BOOL)isContextMenu
 3574: {
 3574:   return mIsContextMenu;
 3574: }
 3574: 
 3574: - (void)setIsContextMenu:(BOOL)flag
 3574: {
 3574:   mIsContextMenu = flag;
 3574: }
 3574: 
 3574: @end
 7042: 
 7042: // According to Apple's docs on [NSWindow canBecomeKeyWindow] and [NSWindow
 7042: // canBecomeMainWindow], windows without a title bar or resize bar can't (by
 7042: // default) become key or main.  But if a window can't become key, it can't
 7042: // accept keyboard input (bmo bug 393250).  And it should also be possible for
 7042: // an otherwise "ordinary" window to become main.  We need to override these
 7042: // two methods to make this happen.
 7042: @implementation BorderlessWindow
 7042: 
 7042: - (BOOL)canBecomeKeyWindow
 7042: {
 7042:   return YES;
 7042: }
 7042: 
13491: - (void)sendEvent:(NSEvent *)anEvent
13491: {
13491:   NSEventType type = [anEvent type];
13491:   
13491:   switch (type) {
13491:     case NSScrollWheel:
13491:     case NSLeftMouseDown:
13491:     case NSLeftMouseUp:
13491:     case NSRightMouseDown:
13491:     case NSRightMouseUp:
13491:     case NSOtherMouseDown:
13491:     case NSOtherMouseUp:
13491:     case NSMouseMoved:
13491:     case NSLeftMouseDragged:
13491:     case NSRightMouseDragged:
13491:     case NSOtherMouseDragged:
13520:     {
13491:       // Drop all mouse events if a modal window has appeared above us.
13491:       // This helps make us behave as if the OS were running a "real" modal
13491:       // event loop.
13491:       id delegate = [self delegate];
13491:       if (delegate && [delegate isKindOfClass:[WindowDelegate class]]) {
13491:         nsCocoaWindow *widget = [(WindowDelegate *)delegate geckoWidget];
13491:         if (widget) {
26321:           if (gGeckoAppModalWindowList && (widget != gGeckoAppModalWindowList->window))
13491:             return;
13491:           if (widget->HasModalDescendents())
13491:             return;
13491:         }
13491:       }
13491:       break;
13520:     }
13491:     default:
13491:       break;
13491:   }
13491: 
13491:   [super sendEvent:anEvent];
13491: }
13491: 
 7042: // Apple's doc on this method says that the NSWindow class's default is not to
 7042: // become main if the window isn't "visible" -- so we should replicate that
 7042: // behavior here.  As best I can tell, the [NSWindow isVisible] method is an
 7042: // accurate test of what Apple means by "visibility".
 7042: - (BOOL)canBecomeMainWindow
 7042: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 7042:   if (![self isVisible])
 7042:     return NO;
 7042:   return YES;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 7042: }
 7042: 
 7106: // Retain and release "self" to avoid crashes when our widget (and its native
 7106: // window) is closed as a result of processing a key equivalent (e.g.
 7106: // Command+w or Command+q).  This workaround is only needed for a window
 7106: // that can become key.
 7106: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
 7106: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 7106:   NSWindow *nativeWindow = [self retain];
 7106:   BOOL retval = [super performKeyEquivalent:theEvent];
 7106:   [nativeWindow release];
 7106:   return retval;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 7106: }
 7106: 
 7042: @end
