71354: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
90129:  */
90129: /* This Source Code Form is subject to the terms of the Mozilla Public
90129:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
90129:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
68933: 
68933: #include "jsgcmark.h"
68933: #include "jsprf.h"
68933: #include "jsscope.h"
68933: #include "jsstr.h"
68933: 
68933: #include "jsobjinlines.h"
68933: #include "jsscopeinlines.h"
68933: 
72107: #include "vm/String-inl.h"
77659: #include "methodjit/MethodJIT.h"
72107: 
70288: /*
70288:  * There are two mostly separate mark paths. The first is a fast path used
70288:  * internally in the GC. The second is a slow path used for root marking and
84719:  * for API consumers like the cycle collector or Class::trace implementations.
70288:  *
70288:  * The fast path uses explicit stacks. The basic marking process during a GC is
70288:  * that all roots are pushed on to a mark stack, and then each item on the
70288:  * stack is scanned (possibly pushing more stuff) until the stack is empty.
70288:  *
70288:  * PushMarkStack pushes a GC thing onto the mark stack. In some cases (shapes
84719:  * or strings) it eagerly marks the object rather than pushing it. Popping and
84719:  * scanning is done by the processMarkStackTop method. For efficiency reasons
84719:  * like tail recursion elimination that method also implements the scanning of
84719:  * objects. For other GC things it uses helper methods.
70288:  *
70288:  * Most of the marking code outside jsgcmark uses functions like MarkObject,
70288:  * MarkString, etc. These functions check if an object is in the compartment
70288:  * currently being GCed. If it is, they call PushMarkStack. Roots are pushed
70288:  * this way as well as pointers traversed inside trace hooks (for things like
77817:  * IteratorClass). It it always valid to call a MarkX function instead of
70288:  * PushMarkStack, although it may be slower.
70288:  *
70288:  * The MarkX functions also handle non-GC object traversal. In this case, they
70288:  * call a callback for each object visited. This is a recursive process; the
70288:  * mark stacks are not involved. These callbacks may ask for the outgoing
70288:  * pointers to be visited. Eventually, this leads to the MarkChildren functions
70288:  * being called. These functions duplicate much of the functionality of
84719:  * scanning functions, but they don't push onto an explicit stack.
70288:  */
70288: 
68933: namespace js {
68933: namespace gc {
68933: 
68933: static inline void
68933: PushMarkStack(GCMarker *gcmarker, JSXML *thing);
68933: 
68933: static inline void
68933: PushMarkStack(GCMarker *gcmarker, JSObject *thing);
68933: 
68933: static inline void
68933: PushMarkStack(GCMarker *gcmarker, JSFunction *thing);
68933: 
68933: static inline void
77659: PushMarkStack(GCMarker *gcmarker, JSScript *thing);
77659: 
77659: static inline void
68933: PushMarkStack(GCMarker *gcmarker, const Shape *thing);
68933: 
68933: static inline void
68933: PushMarkStack(GCMarker *gcmarker, JSString *thing);
68933: 
77462: static inline void
77462: PushMarkStack(GCMarker *gcmarker, types::TypeObject *thing);
77462: 
90129: /*** Object Marking ***/
90129: 
76766: template<typename T>
77343: static inline void
77343: CheckMarkedThing(JSTracer *trc, T *thing)
76766: {
90129:     JS_ASSERT(trc);
76766:     JS_ASSERT(thing);
76766:     JS_ASSERT(trc->debugPrinter || trc->debugPrintArg);
82129:     JS_ASSERT_IF(trc->runtime->gcCurrentCompartment, IS_GC_MARKING_TRACER(trc));
76766: 
76766:     JS_ASSERT(thing->isAligned());
76766: 
77394:     JS_ASSERT(thing->compartment());
82129:     JS_ASSERT(thing->compartment()->rt == trc->runtime);
77343: }
77343: 
68933: template<typename T>
68933: void
90129: MarkInternal(JSTracer *trc, T *thing)
68933: {
77343:     CheckMarkedThing(trc, thing);
68933: 
82129:     JSRuntime *rt = trc->runtime;
68933: 
82602:     JS_ASSERT_IF(rt->gcCheckCompartment,
75365:                  thing->compartment() == rt->gcCheckCompartment ||
75365:                  thing->compartment() == rt->atomsCompartment);
73561: 
69246:     /*
69246:      * Don't mark things outside a compartment if we are in a per-compartment
69246:      * GC.
69246:      */
68933:     if (!rt->gcCurrentCompartment || thing->compartment() == rt->gcCurrentCompartment) {
90232:         if (IS_GC_MARKING_TRACER(trc)) {
68933:             PushMarkStack(static_cast<GCMarker *>(trc), thing);
90232:         } else {
90232:             void *tmp = (void *)thing;
90232:             trc->callback(trc, &tmp, GetGCThingTraceKind(thing));
90232:             JS_ASSERT(tmp == thing);
90232:         }
68933:     }
68933: 
68933: #ifdef DEBUG
68933:     trc->debugPrinter = NULL;
68933:     trc->debugPrintArg = NULL;
68933: #endif
68933: }
68933: 
90129: template <typename T>
90129: static void
90129: MarkUnbarriered(JSTracer *trc, T *thing, const char *name)
90129: {
90129:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkInternal(trc, thing);
90129: }
90129: 
90129: template <typename T>
90129: static void
90129: Mark(JSTracer *trc, const HeapPtr<T> &thing, const char *name)
90129: {
90129:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkInternal(trc, thing.get());
90129: }
90129: 
90129: template <typename T>
90129: static void
90129: MarkRoot(JSTracer *trc, T *thing, const char *name)
90129: {
90129:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkInternal(trc, thing);
90129: }
90129: 
90129: template <typename T>
90129: static void
90318: MarkRange(JSTracer *trc, size_t len, HeapPtr<T> *vec, const char *name)
90318: {
90129:     for (size_t i = 0; i < len; ++i) {
90129:         if (T *obj = vec[i]) {
90129:             JS_SET_TRACING_INDEX(trc, name, i);
90129:             MarkInternal(trc, obj);
90129:         }
90129:     }
90129: }
90129: 
90129: template <typename T>
90129: static void
90318: MarkRootRange(JSTracer *trc, size_t len, T **vec, const char *name)
90318: {
90129:     for (size_t i = 0; i < len; ++i) {
90129:         JS_SET_TRACING_INDEX(trc, name, i);
90129:         MarkInternal(trc, vec[i]);
90129:     }
90129: }
90129: 
90129: #define DeclMarkerImpl(base, type)                                                                \
90129: void                                                                                              \
90129: Mark##base(JSTracer *trc, const HeapPtr<type> &thing, const char *name)                           \
90129: {                                                                                                 \
90129:     Mark<type>(trc, thing, name);                                                                 \
90129: }                                                                                                 \
90129:                                                                                                   \
90129: void                                                                                              \
90129: Mark##base##Root(JSTracer *trc, type *thing, const char *name)                                    \
90129: {                                                                                                 \
90129:     MarkRoot<type>(trc, thing, name);                                                             \
90129: }                                                                                                 \
90129:                                                                                                   \
90129: void                                                                                              \
90129: Mark##base##Unbarriered(JSTracer *trc, type *thing, const char *name)                             \
90129: {                                                                                                 \
90129:     MarkUnbarriered<type>(trc, thing, name);                                                      \
90129: }                                                                                                 \
90129:                                                                                                   \
90129: void Mark##base##Range(JSTracer *trc, size_t len, HeapPtr<type> *vec, const char *name)           \
90129: {                                                                                                 \
90129:     MarkRange<type>(trc, len, vec, name);                                                         \
90129: }                                                                                                 \
90129:                                                                                                   \
90129: void Mark##base##RootRange(JSTracer *trc, size_t len, type **vec, const char *name)               \
90129: {                                                                                                 \
90129:     MarkRootRange<type>(trc, len, vec, name);                                                     \
90129: }                                                                                                 \
90129: 
90129: DeclMarkerImpl(BaseShape, BaseShape)
90129: DeclMarkerImpl(Object, ArgumentsObject)
90129: DeclMarkerImpl(Object, GlobalObject)
90129: DeclMarkerImpl(Object, JSObject)
90129: DeclMarkerImpl(Object, JSFunction)
90129: DeclMarkerImpl(Script, JSScript)
90129: DeclMarkerImpl(Shape, Shape)
90129: DeclMarkerImpl(String, JSAtom)
90129: DeclMarkerImpl(String, JSString)
90129: DeclMarkerImpl(String, JSFlatString)
90129: DeclMarkerImpl(String, JSLinearString)
90129: DeclMarkerImpl(TypeObject, types::TypeObject)
90129: #if JS_HAS_XML_SUPPORT
90129: DeclMarkerImpl(XML, JSXML)
90129: #endif
90129: 
90129: /*** Externally Typed Marking ***/
90129: 
68933: void
90129: MarkKind(JSTracer *trc, void *thing, JSGCTraceKind kind)
68933: {
90129:     JS_ASSERT(thing);
90129:     JS_ASSERT(kind == GetGCThingTraceKind(thing));
90129:     switch (kind) {
90129:       case JSTRACE_OBJECT:
90129:         MarkInternal(trc, reinterpret_cast<JSObject *>(thing));
90129:         break;
90129:       case JSTRACE_STRING:
90129:         MarkInternal(trc, reinterpret_cast<JSString *>(thing));
90129:         break;
90129:       case JSTRACE_SCRIPT:
90129:         MarkInternal(trc, static_cast<JSScript *>(thing));
90129:         break;
90129:       case JSTRACE_SHAPE:
90129:         MarkInternal(trc, reinterpret_cast<Shape *>(thing));
90129:         break;
90129:       case JSTRACE_BASE_SHAPE:
90129:         MarkInternal(trc, reinterpret_cast<BaseShape *>(thing));
90129:         break;
90129:       case JSTRACE_TYPE_OBJECT:
90129:         MarkInternal(trc, reinterpret_cast<types::TypeObject *>(thing));
90129:         break;
90129: #if JS_HAS_XML_SUPPORT
90129:       case JSTRACE_XML:
90129:         MarkInternal(trc, static_cast<JSXML *>(thing));
90129:         break;
90129: #endif
90129:     }
68933: }
68933: 
68933: void
90129: MarkGCThingRoot(JSTracer *trc, void *thing, const char *name)
68933: {
90129:     JS_SET_TRACING_NAME(trc, name);
90129:     if (!thing)
90129:         return;
90129:     MarkKind(trc, thing, GetGCThingTraceKind(thing));
90129: }
90129: 
90129: /*** ID Marking ***/
90129: 
90129: static inline void
90129: MarkIdInternal(JSTracer *trc, const jsid &id)
90129: {
90129:     if (JSID_IS_STRING(id))
90129:         MarkInternal(trc, JSID_TO_STRING(id));
90129:     else if (JS_UNLIKELY(JSID_IS_OBJECT(id)))
90129:         MarkInternal(trc, JSID_TO_OBJECT(id));
68933: }
68933: 
68933: void
90129: MarkId(JSTracer *trc, const HeapId &id, const char *name)
82129: {
82129:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkIdInternal(trc, id);
82129: }
82129: 
82129: void
90129: MarkIdRoot(JSTracer *trc, const jsid &id, const char *name)
82129: {
90129:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkIdInternal(trc, id);
82129: }
82129: 
82129: void
90129: MarkIdRange(JSTracer *trc, size_t len, HeapId *vec, const char *name)
77659: {
90129:     for (size_t i = 0; i < len; ++i) {
90129:         JS_SET_TRACING_INDEX(trc, name, i);
90129:         MarkIdInternal(trc, vec[i]);
90129:     }
77659: }
77659: 
77659: void
90129: MarkIdRootRange(JSTracer *trc, size_t len, jsid *vec, const char *name)
82129: {
90129:     for (size_t i = 0; i < len; ++i) {
90129:         JS_SET_TRACING_INDEX(trc, name, i);
90129:         MarkIdInternal(trc, vec[i]);
90129:     }
90129: }
90129: 
90129: /*** Value Marking ***/
90129: 
90129: static inline void
90302: MarkValueInternal(JSTracer *trc, Value *v)
90129: {
90302:     if (v->isMarkable()) {
90302:         JS_ASSERT(v->toGCThing());
90302:         return MarkKind(trc, v->toGCThing(), v->gcKind());
90129:     }
82129: }
82129: 
82129: void
90302: MarkValue(JSTracer *trc, HeapValue *v, const char *name)
90302: {
90302:     JS_SET_TRACING_NAME(trc, name);
90302:     MarkValueInternal(trc, v->unsafeGet());
90302: }
90302: 
90302: void
90302: MarkValueRoot(JSTracer *trc, Value *v, const char *name)
68933: {
68933:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkValueInternal(trc, v);
68933: }
68933: 
77462: void
90302: MarkValueRange(JSTracer *trc, size_t len, HeapValue *vec, const char *name)
82129: {
90302:     for (size_t i = 0; i < len; ++i) {
90302:         JS_SET_TRACING_INDEX(trc, name, i);
90302:         MarkValueInternal(trc, vec[i].unsafeGet());
90302:     }
82129: }
82129: 
82129: void
90302: MarkValueRootRange(JSTracer *trc, size_t len, Value *vec, const char *name)
83221: {
90129:     for (size_t i = 0; i < len; ++i) {
90129:         JS_SET_TRACING_INDEX(trc, name, i);
90302:         MarkValueInternal(trc, &vec[i]);
90129:     }
90129: }
90129: 
90129: /*** Special Marking ***/
90129: 
90129: /*
90129:  * The unioned HeapPtr stored in script->globalObj needs special treatment to
90129:  * typecheck correctly.
90129:  */
90129: static void
90129: MarkObject(JSTracer *trc, const HeapPtr<GlobalObject, JSScript *> &thing, const char *name)
90129: {
90129:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkInternal(trc, thing.get());
83301: }
83301: 
83301: void
90129: MarkShape(JSTracer *trc, const HeapPtr<const Shape> &thing, const char *name)
77462: {
77462:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkInternal(trc, const_cast<Shape *>(thing.get()));
77462: }
77462: 
82129: void
90302: MarkValueUnbarriered(JSTracer *trc, Value *v, const char *name)
82129: {
68933:     JS_SET_TRACING_NAME(trc, name);
90129:     MarkValueInternal(trc, v);
68933: }
82129: 
82129: void
90302: MarkCrossCompartmentValue(JSTracer *trc, HeapValue *v, const char *name)
82129: {
90302:     if (v->isMarkable()) {
90302:         Cell *cell = (Cell *)v->toGCThing();
90129:         JSRuntime *rt = trc->runtime;
90129:         if (rt->gcCurrentCompartment && cell->compartment() != rt->gcCurrentCompartment)
90129:             return;
90129: 
90129:         MarkValue(trc, v, name);
89847:     }
90129: }
89840: 
90129: /*** Push Mark Stack ***/
84456: 
82602: #define JS_COMPARTMENT_ASSERT(rt, thing)                                 \
82602:     JS_ASSERT_IF((rt)->gcCurrentCompartment,                             \
82602:                  (thing)->compartment() == (rt)->gcCurrentCompartment);
82602: 
82602: #define JS_COMPARTMENT_ASSERT_STR(rt, thing)                             \
82602:     JS_ASSERT_IF((rt)->gcCurrentCompartment,                             \
82602:                  (thing)->compartment() == (rt)->gcCurrentCompartment || \
82602:                  (thing)->compartment() == (rt)->atomsCompartment);
82602: 
90129: static void
68933: PushMarkStack(GCMarker *gcmarker, JSXML *thing)
68933: {
82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
68933: 
68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
68933:         gcmarker->pushXML(thing);
68933: }
68933: 
90129: static void
68933: PushMarkStack(GCMarker *gcmarker, JSObject *thing)
68933: {
82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
68933: 
68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
68933:         gcmarker->pushObject(thing);
68933: }
68933: 
90129: static void
68933: PushMarkStack(GCMarker *gcmarker, JSFunction *thing)
68933: {
82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
68933: 
68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
68933:         gcmarker->pushObject(thing);
68933: }
68933: 
90129: static void
77462: PushMarkStack(GCMarker *gcmarker, types::TypeObject *thing)
77462: {
82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
77462: 
77462:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
77462:         gcmarker->pushType(thing);
77462: }
77462: 
90129: static void
90129: MarkChildren(JSTracer *trc, JSScript *script);
90129: 
90129: static void
77659: PushMarkStack(GCMarker *gcmarker, JSScript *thing)
77659: {
82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
77659: 
77659:     /*
77659:      * We mark scripts directly rather than pushing on the stack as they can
77659:      * refer to other scripts only indirectly (like via nested functions) and
77659:      * we cannot get to deep recursion.
77659:      */
77659:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
77659:         MarkChildren(gcmarker, thing);
77659: }
77659: 
68933: static void
68933: ScanShape(GCMarker *gcmarker, const Shape *shape);
68933: 
90129: static void
68933: PushMarkStack(GCMarker *gcmarker, const Shape *thing)
68933: {
82602:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
68933: 
68933:     /* We mark shapes directly rather than pushing on the stack. */
68933:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
68933:         ScanShape(gcmarker, thing);
68933: }
68933: 
84456: static inline void
83221: ScanBaseShape(GCMarker *gcmarker, BaseShape *base);
83221: 
90129: static void
83221: PushMarkStack(GCMarker *gcmarker, BaseShape *thing)
83221: {
84456:     JS_COMPARTMENT_ASSERT(gcmarker->runtime, thing);
83221: 
83221:     /* We mark base shapes directly rather than pushing on the stack. */
83221:     if (thing->markIfUnmarked(gcmarker->getMarkColor()))
83221:         ScanBaseShape(gcmarker, thing);
83221: }
83221: 
83221: static void
68933: ScanShape(GCMarker *gcmarker, const Shape *shape)
68933: {
68933:   restart:
83221:     PushMarkStack(gcmarker, shape->base());
68933: 
83221:     jsid id = shape->maybePropid();
83221:     if (JSID_IS_STRING(id))
83221:         PushMarkStack(gcmarker, JSID_TO_STRING(id));
83221:     else if (JS_UNLIKELY(JSID_IS_OBJECT(id)))
83221:         PushMarkStack(gcmarker, JSID_TO_OBJECT(id));
68933: 
68933:     shape = shape->previous();
68933:     if (shape && shape->markIfUnmarked(gcmarker->getMarkColor()))
68933:         goto restart;
68933: }
68933: 
84456: static inline void
83221: ScanBaseShape(GCMarker *gcmarker, BaseShape *base)
83221: {
86163:     base->assertConsistency();
86163: 
83229:     if (base->hasGetterObject())
83229:         PushMarkStack(gcmarker, base->getterObject());
83221: 
83229:     if (base->hasSetterObject())
83229:         PushMarkStack(gcmarker, base->setterObject());
83221: 
83301:     if (JSObject *parent = base->getObjectParent())
83301:         PushMarkStack(gcmarker, parent);
84456: 
86163:     /*
86163:      * All children of the owned base shape are consistent with its
86163:      * unowned one, thus we do not need to trace through children of the
86163:      * unowned base shape.
86163:      */
84456:     if (base->isOwned()) {
84456:         UnownedBaseShape *unowned = base->baseUnowned();
90129:         JS_ASSERT(base->compartment() == unowned->compartment());
86163:         unowned->markIfUnmarked(gcmarker->getMarkColor());
84456:     }
83221: }
83221: 
68933: static inline void
83415: ScanLinearString(GCMarker *gcmarker, JSLinearString *str)
83415: {
83415:     JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, str);
83415:     JS_ASSERT(str->isMarked());
83415: 
83415:     /*
83415:      * Add extra asserts to confirm the static type to detect incorrect string
83415:      * mutations.
83415:      */
83415:     JS_ASSERT(str->JSString::isLinear());
83415:     while (str->isDependent()) {
83415:         str = str->asDependent().base();
83415:         JS_ASSERT(str->JSString::isLinear());
83415:         JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, str);
83415:         if (!str->markIfUnmarked())
83415:             break;
83415:     }
83415: }
83415: 
84455: /*
84455:  * The function tries to scan the whole rope tree using the marking stack as
84455:  * temporary storage. If that becomes full, the unscanned ropes are added to
84455:  * the delayed marking list. When the function returns, the marking stack is
84456:  * at the same depth as it was on entry. This way we avoid using tags when
84456:  * pushing ropes to the stack as ropes never leaks to other users of the
84456:  * stack. This also assumes that a rope can only point to other ropes or
84456:  * linear strings, it cannot refer to GC things of other types.
84455:  */
83415: static void
71345: ScanRope(GCMarker *gcmarker, JSRope *rope)
71345: {
84456:     uintptr_t *savedTos = gcmarker->stack.tos;
84455:     for (;;) {
84455:         JS_ASSERT(GetGCThingTraceKind(rope) == JSTRACE_STRING);
83415:         JS_ASSERT(rope->JSString::isRope());
82602:         JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, rope);
71345:         JS_ASSERT(rope->isMarked());
83415:         JSRope *next = NULL;
71345: 
83415:         JSString *right = rope->rightChild();
83415:         if (right->markIfUnmarked()) {
83415:             if (right->isLinear())
83415:                 ScanLinearString(gcmarker, &right->asLinear());
83415:             else
83415:                 next = &right->asRope();
83415:         }
71345: 
83415:         JSString *left = rope->leftChild();
83415:         if (left->markIfUnmarked()) {
83415:             if (left->isLinear()) {
83415:                 ScanLinearString(gcmarker, &left->asLinear());
71345:             } else {
83415:                 /*
84455:                  * When both children are ropes, set aside the right one to
84455:                  * scan it later.
83415:                  */
84456:                 if (next && !gcmarker->stack.push(reinterpret_cast<uintptr_t>(next)))
84455:                     gcmarker->delayMarkingChildren(next);
83415:                 next = &left->asRope();
71345:             }
71345:         }
84455:         if (next) {
83415:             rope = next;
84456:         } else if (savedTos != gcmarker->stack.tos) {
84456:             JS_ASSERT(savedTos < gcmarker->stack.tos);
84456:             rope = reinterpret_cast<JSRope *>(gcmarker->stack.pop());
84455:         } else {
84455:             break;
84455:         }
84455:     }
84456:     JS_ASSERT(savedTos == gcmarker->stack.tos);
84455:  }
84455: 
84455: static inline void
84455: ScanString(GCMarker *gcmarker, JSString *str)
84455: {
84455:     if (str->isLinear())
84455:         ScanLinearString(gcmarker, &str->asLinear());
84455:     else
84455:         ScanRope(gcmarker, &str->asRope());
71345: }
71345: 
71345: static inline void
68933: PushMarkStack(GCMarker *gcmarker, JSString *str)
68933: {
82602:     JS_COMPARTMENT_ASSERT_STR(gcmarker->runtime, str);
68933: 
83415:     /*
84455:      * As string can only refer to other strings we fully scan its GC graph
84455:      * using the explicit stack when navigating the rope tree to avoid
84455:      * dealing with strings on the stack in drainMarkStack.
83415:      */
84455:     if (str->markIfUnmarked())
84455:         ScanString(gcmarker, str);
68933: }
68933: 
84719: static inline void
84719: PushValueArray(GCMarker *gcmarker, JSObject* obj, HeapValue *start, HeapValue *end)
84456: {
84719:     JS_ASSERT(start <= end);
84719:     uintptr_t tagged = reinterpret_cast<uintptr_t>(obj) | GCMarker::ValueArrayTag;
84719:     uintptr_t startAddr = reinterpret_cast<uintptr_t>(start);
84719:     uintptr_t endAddr = reinterpret_cast<uintptr_t>(end);
84719: 
84719:     /* Push in the reverse order so obj will be on top. */
84719:     if (!gcmarker->stack.push(endAddr, startAddr, tagged)) {
84719:         /*
84719:          * If we cannot push the array, we trigger delay marking for the whole
84719:          * object.
84719:          */
84719:         gcmarker->delayMarkingChildren(obj);
84456:     }
68933: }
68933: 
68933: void
68933: MarkChildren(JSTracer *trc, JSObject *obj)
68933: {
77464:     MarkTypeObject(trc, obj->typeFromGC(), "type");
77361: 
83301:     Shape *shape = obj->lastProperty();
83301:     MarkShapeUnbarriered(trc, shape, "shape");
68933: 
83301:     Class *clasp = shape->getObjectClass();
68933:     if (clasp->trace)
68933:         clasp->trace(trc, obj);
68933: 
83301:     if (shape->isNative()) {
84755:         uint32_t nslots = obj->slotSpan();
84755:         for (uint32_t i = 0; i < nslots; i++) {
77343:             JS_SET_TRACING_DETAILS(trc, js_PrintObjectSlotName, obj, i);
90302:             MarkValueInternal(trc, obj->nativeGetSlotRef(i).unsafeGet());
77343:         }
68933:     }
68933: }
68933: 
90129: static void
68933: MarkChildren(JSTracer *trc, JSString *str)
68933: {
82129:     /*
82129:      * We use custom barriers in JSString, so it's safe to use unbarriered
82129:      * marking here.
82129:      */
68933:     if (str->isDependent()) {
82129:         MarkStringUnbarriered(trc, str->asDependent().base(), "base");
68933:     } else if (str->isRope()) {
68933:         JSRope &rope = str->asRope();
82129:         MarkStringUnbarriered(trc, rope.leftChild(), "left child");
82129:         MarkStringUnbarriered(trc, rope.rightChild(), "right child");
68933:     }
68933: }
68933: 
90129: static void
77659: MarkChildren(JSTracer *trc, JSScript *script)
77659: {
77659:     CheckScript(script, NULL);
77659: 
82602:     JS_ASSERT_IF(trc->runtime->gcCheckCompartment,
82602:                  script->compartment() == trc->runtime->gcCheckCompartment);
77659: 
90318:     for (uint32_t i = 0; i < script->natoms; ++i) {
90318:         if (JSAtom *p = script->atoms[i])
90318:             MarkStringUnbarriered(trc, p, "atom");
90318:     }
77659: 
77659:     if (JSScript::isValidOffset(script->objectsOffset)) {
77659:         JSObjectArray *objarray = script->objects();
77659:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
77659:     }
77659: 
77659:     if (JSScript::isValidOffset(script->regexpsOffset)) {
77659:         JSObjectArray *objarray = script->regexps();
77659:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
77659:     }
77659: 
77659:     if (JSScript::isValidOffset(script->constOffset)) {
77659:         JSConstArray *constarray = script->consts();
77659:         MarkValueRange(trc, constarray->length, constarray->vector, "consts");
77659:     }
77659: 
83283:     if (script->function())
83301:         MarkObjectUnbarriered(trc, script->function(), "function");
83256: 
82129:     if (!script->isCachedEval && script->globalObject)
82129:         MarkObject(trc, script->globalObject, "object");
77659: 
77659:     if (IS_GC_MARKING_TRACER(trc) && script->filename)
77659:         js_MarkScriptFilename(script->filename);
77659: 
77659:     script->bindings.trace(trc);
77659: 
77886:     if (script->types)
77886:         script->types->trace(trc);
84195: 
84195:     if (script->hasAnyBreakpointsOrStepMode())
84195:         script->markTrapClosures(trc);
77659: }
77659: 
90129: static void
68933: MarkChildren(JSTracer *trc, const Shape *shape)
68933: {
85055:     MarkBaseShapeUnbarriered(trc, shape->base(), "base");
90129:     MarkId(trc, shape->maybePropid(), "propid");
84173:     if (shape->previous())
84173:         MarkShape(trc, shape->previous(), "parent");
68933: }
68933: 
90129: static inline void
85055: MarkBaseShapeGetterSetter(JSTracer *trc, BaseShape *base)
85055: {
85055:     if (base->hasGetterObject())
85055:         MarkObjectUnbarriered(trc, base->getterObject(), "getter");
85055:     if (base->hasSetterObject())
85055:         MarkObjectUnbarriered(trc, base->setterObject(), "setter");
85055: }
85055: 
90129: static void
83221: MarkChildren(JSTracer *trc, BaseShape *base)
83221: {
85055:     MarkBaseShapeGetterSetter(trc, base);
83229:     if (base->isOwned())
83301:         MarkBaseShapeUnbarriered(trc, base->baseUnowned(), "base");
83301: 
83301:     if (JSObject *parent = base->getObjectParent())
83301:         MarkObjectUnbarriered(trc, parent, "parent");
83221: }
83221: 
85055: /*
85055:  * This function is used by the cycle collector to trace through the
85055:  * children of a BaseShape (and its baseUnowned(), if any). The cycle
85055:  * collector does not directly care about BaseShapes, so only the
85055:  * getter, setter, and parent are marked. Furthermore, the parent is
85055:  * marked only if it isn't the same as prevParent, which will be
85055:  * updated to the current shape's parent.
85055:  */
85055: inline void
85055: MarkCycleCollectorChildren(JSTracer *trc, BaseShape *base, JSObject **prevParent)
85055: {
85055:     JS_ASSERT(base);
85055: 
86163:     /*
86163:      * The cycle collector does not need to trace unowned base shapes,
86163:      * as they have the same getter, setter and parent as the original
86163:      * base shape.
86163:      */
86163:     base->assertConsistency();
86163: 
85055:     MarkBaseShapeGetterSetter(trc, base);
85055: 
85055:     JSObject *parent = base->getObjectParent();
85055:     if (parent && parent != *prevParent) {
85055:         MarkObjectUnbarriered(trc, parent, "parent");
85055:         *prevParent = parent;
85055:     }
85055: }
85055: 
85055: /*
85055:  * This function is used by the cycle collector to trace through a
85055:  * shape. The cycle collector does not care about shapes or base
85055:  * shapes, so those are not marked. Instead, any shapes or base shapes
85055:  * that are encountered have their children marked. Stack space is
85055:  * bounded. If two shapes in a row have the same parent pointer, the
85055:  * parent pointer will only be marked once.
85055:  */
85055: void
85055: MarkCycleCollectorChildren(JSTracer *trc, const Shape *shape)
85055: {
85055:     JSObject *prevParent = NULL;
85055:     do {
85055:         MarkCycleCollectorChildren(trc, shape->base(), &prevParent);
90129:         MarkId(trc, shape->maybePropid(), "propid");
85055:         shape = shape->previous();
85055:     } while (shape);
85055: }
85055: 
77462: static void
77462: ScanTypeObject(GCMarker *gcmarker, types::TypeObject *type)
77462: {
77462:     if (!type->singleton) {
77462:         unsigned count = type->getPropertyCount();
77462:         for (unsigned i = 0; i < count; i++) {
77462:             types::Property *prop = type->getProperty(i);
78537:             if (prop && JSID_IS_STRING(prop->id))
78537:                 PushMarkStack(gcmarker, JSID_TO_STRING(prop->id));
77462:         }
77462:     }
77462: 
77462:     if (type->proto)
77462:         PushMarkStack(gcmarker, type->proto);
77462: 
77462:     if (type->newScript) {
77884:         PushMarkStack(gcmarker, type->newScript->fun);
77462:         PushMarkStack(gcmarker, type->newScript->shape);
77462:     }
77462: 
83236:     if (type->interpretedFunction)
83236:         PushMarkStack(gcmarker, type->interpretedFunction);
83236: 
88134:     if (type->singleton && !type->lazy())
88134:         PushMarkStack(gcmarker, type->singleton);
88134: 
88134:     if (type->interpretedFunction)
88134:         PushMarkStack(gcmarker, type->interpretedFunction);
77462: }
77462: 
90129: static void
77462: MarkChildren(JSTracer *trc, types::TypeObject *type)
77462: {
77462:     if (!type->singleton) {
77462:         unsigned count = type->getPropertyCount();
77462:         for (unsigned i = 0; i < count; i++) {
77462:             types::Property *prop = type->getProperty(i);
77462:             if (prop)
77462:                 MarkId(trc, prop->id, "type_prop");
77462:         }
77462:     }
77462: 
77462:     if (type->proto)
82129:         MarkObject(trc, type->proto, "type_proto");
77462: 
83249:     if (type->singleton && !type->lazy())
82129:         MarkObject(trc, type->singleton, "type_singleton");
77462: 
77462:     if (type->newScript) {
82129:         MarkObject(trc, type->newScript->fun, "type_new_function");
77462:         MarkShape(trc, type->newScript->shape, "type_new_shape");
77462:     }
77462: 
77884:     if (type->interpretedFunction)
82129:         MarkObject(trc, type->interpretedFunction, "type_function");
77462: }
77462: 
68933: #ifdef JS_HAS_XML_SUPPORT
90129: static void
68933: MarkChildren(JSTracer *trc, JSXML *xml)
68933: {
68933:     js_TraceXML(trc, xml);
68933: }
68933: #endif
68933: 
68933: } /* namespace gc */
68933: 
90302: using namespace js::gc;
90302: 
84456: inline void
84456: GCMarker::processMarkStackTop()
84456: {
84456:     /*
84719:      * The function uses explicit goto and implements the scanning of the
84719:      * object directly. It allows to eliminate the tail recursion and
84719:      * significantly improve the marking performance, see bug 641025.
84456:      */
84456:     HeapValue *vp, *end;
84456:     JSObject *obj;
84456: 
84456:     uintptr_t addr = stack.pop();
84456:     uintptr_t tag = addr & StackTagMask;
84719:     addr &= ~StackTagMask;
84719: 
84456:     if (tag == ValueArrayTag) {
84456:         JS_STATIC_ASSERT(ValueArrayTag == 0);
84719:         JS_ASSERT(!(addr & Cell::CellMask));
84719:         obj = reinterpret_cast<JSObject *>(addr);
84456:         uintptr_t addr2 = stack.pop();
84719:         uintptr_t addr3 = stack.pop();
84719:         JS_ASSERT(addr2 <= addr3);
84719:         JS_ASSERT((addr3 - addr2) % sizeof(Value) == 0);
84719:         vp = reinterpret_cast<HeapValue *>(addr2);
84719:         end = reinterpret_cast<HeapValue *>(addr3);
84456:         goto scan_value_array;
84456:     }
84456: 
84456:     if (tag == ObjectTag) {
84456:         obj = reinterpret_cast<JSObject *>(addr);
84456:         goto scan_obj;
84719:     }
84719: 
84719:     if (tag == TypeTag) {
84456:         ScanTypeObject(this, reinterpret_cast<types::TypeObject *>(addr));
84456:     } else {
84456:         JS_ASSERT(tag == XmlTag);
84456:         MarkChildren(this, reinterpret_cast<JSXML *>(addr));
84456:     }
84456:     return;
84456: 
84456:   scan_value_array:
84719:     JS_ASSERT(vp <= end);
84719:     while (vp != end) {
84456:         const Value &v = *vp++;
84456:         if (v.isString()) {
84456:             JSString *str = v.toString();
84456:             if (str->markIfUnmarked())
84456:                 ScanString(this, str);
84456:         } else if (v.isObject()) {
84719:             JSObject *obj2 = &v.toObject();
84719:             if (obj2->markIfUnmarked(getMarkColor())) {
84719:                 PushValueArray(this, obj, vp, end);
84719:                 obj = obj2;
84456:                 goto scan_obj;
84456:             }
84456:         }
84719:     }
84456:     return;
84456: 
84456:   scan_obj:
84719:     {
84719:         types::TypeObject *type = obj->typeFromGC();
84719:         PushMarkStack(this, type);
84719: 
90302:         Shape *shape = obj->lastProperty();
84719:         PushMarkStack(this, shape);
84719: 
84719:         /* Call the trace hook if necessary. */
84719:         Class *clasp = shape->getObjectClass();
84719:         if (clasp->trace) {
84719:             if (clasp == &ArrayClass) {
84719:                 JS_ASSERT(!shape->isNative());
84719:                 vp = obj->getDenseArrayElements();
84719:                 end = vp + obj->getDenseArrayInitializedLength();
84719:                 goto scan_value_array;
84719:             }
84719:             clasp->trace(this, obj);
84719:         }
84719: 
84719:         if (!shape->isNative())
84719:             return;
84719: 
84456:         unsigned nslots = obj->slotSpan();
84456:         vp = obj->fixedSlots();
84456:         if (obj->slots) {
84456:             unsigned nfixed = obj->numFixedSlots();
84456:             if (nslots > nfixed) {
84719:                 PushValueArray(this, obj, vp, vp + nfixed);
84456:                 vp = obj->slots;
84456:                 end = vp + (nslots - nfixed);
84456:                 goto scan_value_array;
84456:             }
84456:         }
84719:         JS_ASSERT(nslots <= obj->numFixedSlots());
84456:         end = vp + nslots;
84456:         goto scan_value_array;
84456:     }
84456: }
84456: 
68933: void
68933: GCMarker::drainMarkStack()
68933: {
82129:     JSRuntime *rt = runtime;
73561:     rt->gcCheckCompartment = rt->gcCurrentCompartment;
73561: 
84456:     for (;;) {
84456:         while (!stack.isEmpty())
84456:             processMarkStackTop();
84456:         if (!hasDelayedChildren())
84456:             break;
68933: 
68933:         /*
84456:          * Mark children of things that caused too deep recursion during the
84456:          * above tracing. Don't do this until we're done with everything
84456:          * else.
68933:          */
68933:         markDelayedChildren();
68933:     }
73561: 
73561:     rt->gcCheckCompartment = NULL;
68933: }
68933: 
82129: void
82129: TraceChildren(JSTracer *trc, void *thing, JSGCTraceKind kind)
68933: {
68933:     switch (kind) {
77715:       case JSTRACE_OBJECT:
77659:         MarkChildren(trc, static_cast<JSObject *>(thing));
68933:         break;
68933: 
68933:       case JSTRACE_STRING:
77659:         MarkChildren(trc, static_cast<JSString *>(thing));
77659:         break;
77659: 
77659:       case JSTRACE_SCRIPT:
77659:         MarkChildren(trc, static_cast<JSScript *>(thing));
68933:         break;
68933: 
68933:       case JSTRACE_SHAPE:
77659:         MarkChildren(trc, static_cast<Shape *>(thing));
68933:         break;
68933: 
83221:       case JSTRACE_BASE_SHAPE:
83221:         MarkChildren(trc, static_cast<BaseShape *>(thing));
83221:         break;
83221: 
77462:       case JSTRACE_TYPE_OBJECT:
77462:         MarkChildren(trc, (types::TypeObject *)thing);
77462:         break;
77462: 
68933: #if JS_HAS_XML_SUPPORT
68933:       case JSTRACE_XML:
77659:         MarkChildren(trc, static_cast<JSXML *>(thing));
68933:         break;
68933: #endif
68933:     }
68933: }
77343: 
82129: void
82129: CallTracer(JSTracer *trc, void *thing, JSGCTraceKind kind)
82129: {
82129:     JS_ASSERT(thing);
82129:     MarkKind(trc, thing, kind);
82129: }
82129: 
82129: } /* namespace js */
