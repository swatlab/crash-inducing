57812: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
23126:  * vim: set ts=8 sw=4 et tw=99:
23126:  *
23126:  * ***** BEGIN LICENSE BLOCK *****
23126:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23126:  *
23126:  * The contents of this file are subject to the Mozilla Public License Version
23126:  * 1.1 (the "License"); you may not use this file except in compliance with
23126:  * the License. You may obtain a copy of the License at
23126:  * http://www.mozilla.org/MPL/
23126:  *
23126:  * Software distributed under the License is distributed on an "AS IS" basis,
23126:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23126:  * for the specific language governing rights and limitations under the
23126:  * License.
23126:  *
23126:  * The Original Code is Mozilla Communicator client code, released
23126:  * March 31, 1998.
23126:  *
23126:  * The Initial Developer of the Original Code is
23126:  * Netscape Communications Corporation.
23126:  * Portions created by the Initial Developer are Copyright (C) 1998
23126:  * the Initial Developer. All Rights Reserved.
23126:  *
23126:  * Contributor(s):
23126:  *
23126:  * Alternatively, the contents of this file may be used under the terms of
23126:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23126:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23126:  * in which case the provisions of the GPL or the LGPL are applicable instead
23126:  * of those above. If you wish to allow use of your version of this file only
23126:  * under the terms of either the GPL or the LGPL, and not to allow others to
23126:  * use your version of this file under the terms of the MPL, indicate your
23126:  * decision by deleting the provisions above and replace them with the notice
23126:  * and other provisions required by the GPL or the LGPL. If you do not delete
23126:  * the provisions above, a recipient may use your version of this file under
23126:  * the terms of any one of the MPL, the GPL or the LGPL.
23126:  *
23126:  * ***** END LICENSE BLOCK ***** */
23126: 
23126: /*
23126:  * JS shell.
23126:  */
23126: #include <errno.h>
25472: #include <math.h>
23126: #include <stdio.h>
23126: #include <stdlib.h>
23126: #include <string.h>
25098: #include <signal.h>
23126: #include <locale.h>
80468: 
80468: #include "mozilla/Util.h"
80468: 
23126: #include "jstypes.h"
23126: #include "jsutil.h"
23126: #include "jsprf.h"
43264: #include "jswrapper.h"
23126: #include "jsapi.h"
23126: #include "jsarray.h"
23126: #include "jsatom.h"
23126: #include "jscntxt.h"
25087: #include "jsdate.h"
23126: #include "jsdbgapi.h"
23126: #include "jsfun.h"
23126: #include "jsgc.h"
27012: #include "jsiter.h"
23126: #include "jslock.h"
23126: #include "jsnum.h"
23126: #include "jsobj.h"
67934: #include "json.h"
51110: #include "jsreflect.h"
23126: #include "jsscope.h"
23126: #include "jsscript.h"
54863: #include "jstypedarray.h"
74875: #include "jstypedarrayinlines.h"
42742: #include "jsxml.h"
48637: #include "jsperf.h"
23126: 
91659: #include "builtin/TestingFunctions.h"
80964: #include "frontend/BytecodeEmitter.h"
80506: #include "frontend/Parser.h"
80506: #include "methodjit/MethodJIT.h"
80506: 
25087: #include "prmjtime.h"
25087: 
23126: #ifdef JSDEBUGGER
23126: #include "jsdebug.h"
23126: #ifdef JSDEBUGGER_JAVA_UI
23126: #include "jsdjava.h"
23126: #endif /* JSDEBUGGER_JAVA_UI */
23126: #ifdef JSDEBUGGER_C_UI
23126: #include "jsdb.h"
23126: #endif /* JSDEBUGGER_C_UI */
23126: #endif /* JSDEBUGGER */
23126: 
74072: #include "jsoptparse.h"
40801: #include "jsworkers.h"
74837: #include "jsheaptools.h"
40801: 
77343: #include "jsinferinlines.h"
53840: #include "jsinterpinlines.h"
42733: #include "jsobjinlines.h"
48470: #include "jsscriptinlines.h"
42733: 
23126: #ifdef XP_UNIX
23126: #include <unistd.h>
23126: #include <sys/types.h>
23126: #include <sys/wait.h>
23126: #endif
23126: 
23126: #if defined(XP_WIN) || defined(XP_OS2)
23126: #include <io.h>     /* for isatty() */
23126: #endif
23126: 
26053: #ifdef XP_WIN
52897: #include "jswin.h"
26053: #endif
26053: 
80468: using namespace mozilla;
38585: using namespace js;
74072: using namespace js::cli;
38585: 
23126: typedef enum JSShellExitCode {
23126:     EXITCODE_RUNTIME_ERROR      = 3,
23126:     EXITCODE_FILE_NOT_FOUND     = 4,
25472:     EXITCODE_OUT_OF_MEMORY      = 5,
25472:     EXITCODE_TIMEOUT            = 6
23126: } JSShellExitCode;
23126: 
23126: size_t gStackChunkSize = 8192;
23126: 
23126: /* Assume that we can not use more than 5e5 bytes of C stack by default. */
57726: #if (defined(DEBUG) && defined(__SUNPRO_CC))  || defined(JS_CPU_SPARC)
39974: /* Sun compiler uses larger stack space for js_Interpret() with debug
39974:    Use a bigger gMaxStackSize to make "make check" happy. */
56544: #define DEFAULT_MAX_STACK_SIZE 5000000
39974: #else
56544: #define DEFAULT_MAX_STACK_SIZE 500000
39974: #endif
39974: 
56544: size_t gMaxStackSize = DEFAULT_MAX_STACK_SIZE;
56544: 
26673: 
26673: #ifdef JS_THREADSAFE
26673: static PRUintn gStackBaseThreadIndex;
26673: #else
86976: static uintptr_t gStackBase;
26673: #endif
23126: 
25472: /*
25472:  * Limit the timeout to 30 minutes to prevent an overflow on platfoms
25472:  * that represent the time internally in microseconds using 32-bit int.
25472:  */
90955: static double MAX_TIMEOUT_INTERVAL = 1800.0;
90955: static double gTimeoutInterval = -1.0;
25472: static volatile bool gCanceled = false;
25087: 
52557: static bool enableMethodJit = false;
77343: static bool enableTypeInference = false;
71701: static bool enableDisassemblyDumps = false;
33747: 
56181: static bool printTiming = false;
56181: 
25087: static JSBool
90955: SetTimeoutValue(JSContext *cx, double t);
25087: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt);
25087: 
25087: static void
25472: KillWatchdog();
25472: 
25472: static bool
90955: ScheduleWatchdog(JSRuntime *rt, double t);
25472: 
25472: static void
25472: CancelExecution(JSRuntime *rt);
23126: 
23726: /*
23726:  * Watchdog thread state.
23726:  */
23726: #ifdef JS_THREADSAFE
25472: 
25472: static PRLock *gWatchdogLock = NULL;
25087: static PRCondVar *gWatchdogWakeup = NULL;
25087: static PRThread *gWatchdogThread = NULL;
25472: static bool gWatchdogHasTimeout = false;
25472: static PRIntervalTime gWatchdogTimeout = 0;
25472: 
25472: static PRCondVar *gSleepWakeup = NULL;
25087: 
25087: #else
25472: 
25087: static JSRuntime *gRuntime = NULL;
25087: 
23726: #endif
23726: 
23126: int gExitCode = 0;
23126: JSBool gQuitting = JS_FALSE;
23126: FILE *gErrFile = NULL;
23126: FILE *gOutFile = NULL;
40801: #ifdef JS_THREADSAFE
40801: JSObject *gWorkers = NULL;
55619: js::workers::ThreadPool *gWorkerThreadPool = NULL;
40801: #endif
23126: 
23126: static JSBool reportWarnings = JS_TRUE;
23126: static JSBool compileOnly = JS_FALSE;
23126: 
64328: #ifdef DEBUG
64323: static JSBool OOM_printAllocationCount = JS_FALSE;
64328: #endif
64323: 
23126: typedef enum JSShellErrNum {
23126: #define MSG_DEF(name, number, count, exception, format) \
23126:     name = number,
23126: #include "jsshell.msg"
23126: #undef MSG_DEF
23126:     JSShellErr_Limit
23126: } JSShellErrNum;
23126: 
40801: static JSContext *
40801: NewContext(JSRuntime *rt);
40801: 
40801: static void
40801: DestroyContext(JSContext *cx, bool withGC);
40801: 
23126: static const JSErrorFormatString *
91237: my_GetErrorMessage(void *userRef, const char *locale, const unsigned errorNumber);
35108: 
23126: #ifdef EDITLINE
23126: JS_BEGIN_EXTERN_C
84931: extern JS_EXPORT_API(char *) readline(const char *prompt);
84931: extern JS_EXPORT_API(void)   add_history(char *line);
23126: JS_END_EXTERN_C
23126: #endif
23126: 
47498: static void
47498: ReportException(JSContext *cx)
47498: {
47498:     if (JS_IsExceptionPending(cx)) {
47498:         if (!JS_ReportPendingException(cx))
47498:             JS_ClearPendingException(cx);
47498:     }
47498: }
47498: 
84160: class ToStringHelper {
31366:   public:
84160:     ToStringHelper(JSContext *aCx, jsval v, JSBool aThrow = JS_FALSE)
57812:       : cx(aCx), mThrow(aThrow)
31366:     {
31366:         mStr = JS_ValueToString(cx, v);
47498:         if (!aThrow && !mStr)
47498:             ReportException(cx);
47403:         JS_AddNamedStringRoot(cx, &mStr, "Value ToString helper");
31366:     }
84160:     ~ToStringHelper() {
47403:         JS_RemoveStringRoot(cx, &mStr);
31366:     }
31366:     JSBool threw() { return !mStr; }
31366:     jsval getJSVal() { return STRING_TO_JSVAL(mStr); }
31366:     const char *getBytes() {
57812:         if (mStr && (mBytes.ptr() || mBytes.encode(cx, mStr)))
57812:             return mBytes.ptr();
57812:         return "(error converting value)";
31366:     }
31366:   private:
31366:     JSContext *cx;
31366:     JSString *mStr;
31366:     JSBool mThrow;
57812:     JSAutoByteString mBytes;
31366: };
31366: 
84160: class IdStringifier : public ToStringHelper {
48470: public:
67930:     IdStringifier(JSContext *cx, jsid id, JSBool aThrow = JS_FALSE)
84160:     : ToStringHelper(cx, IdToJsval(id), aThrow)
48470:     { }
48470: };
48470: 
23723: static char *
23723: GetLine(FILE *file, const char * prompt)
23723: {
23723:     size_t size;
23723:     char *buffer;
23126: #ifdef EDITLINE
23126:     /*
23126:      * Use readline only if file is stdin, because there's no way to specify
23126:      * another handle.  Are other filehandles interactive?
23126:      */
23126:     if (file == stdin) {
23126:         char *linep = readline(prompt);
23723:         /*
23723:          * We set it to zero to avoid complaining about inappropriate ioctl
23723:          * for device in the case of EOF. Looks like errno == 251 if line is
25486:          * finished with EOF and errno == 25 (EINVAL on Mac) if there is
25486:          * nothing left to read.
23723:          */
25486:         if (errno == 251 || errno == 25 || errno == EINVAL)
23723:             errno = 0;
23126:         if (!linep)
23723:             return NULL;
23126:         if (linep[0] != '\0')
23126:             add_history(linep);
23723:         return linep;
23723:     }
23126: #endif
23723:     size_t len = 0;
23723:     if (*prompt != '\0') {
25469:         fprintf(gOutFile, "%s", prompt);
23126:         fflush(gOutFile);
23723:     }
23723:     size = 80;
23723:     buffer = (char *) malloc(size);
23723:     if (!buffer)
23723:         return NULL;
23723:     char *current = buffer;
23723:     while (fgets(current, size - len, file)) {
23723:         len += strlen(current);
23723:         char *t = buffer + len - 1;
23723:         if (*t == '\n') {
23723:             /* Line was read. We remove '\n' and exit. */
23723:             *t = '\0';
23723:             return buffer;
23723:         }
23723:         if (len + 1 == size) {
23723:             size = size * 2;
23723:             char *tmp = (char *) realloc(buffer, size);
23723:             if (!tmp) {
23723:                 free(buffer);
23723:                 return NULL;
23723:             }
23723:             buffer = tmp;
23723:         }
23723:         current = buffer + len;
23723:     }
23723:     if (len && !ferror(file))
23723:         return buffer;
23723:     free(buffer);
23723:     return NULL;
23457: }
23457: 
23726: /*
23726:  * State to store as JSContext private.
23726:  *
25087:  * We declare such timestamp as volatile as they are updated in the operation
23726:  * callback without taking any locks. Any possible race can only lead to more
23726:  * frequent callback calls. This is safe as the callback does everything based
23726:  * on timing.
23726:  */
23457: struct JSShellContextData {
25087:     volatile JSIntervalTime startTime;
23457: };
23457: 
23457: static JSShellContextData *
23457: NewContextData()
23457: {
25472:     /* Prevent creation of new contexts after we have been canceled. */
25472:     if (gCanceled)
25472:         return NULL;
25472: 
23457:     JSShellContextData *data = (JSShellContextData *)
25087:                                calloc(sizeof(JSShellContextData), 1);
23457:     if (!data)
23457:         return NULL;
25087:     data->startTime = js_IntervalNow();
23457:     return data;
23457: }
23457: 
23457: static inline JSShellContextData *
23457: GetContextData(JSContext *cx)
23457: {
23457:     JSShellContextData *data = (JSShellContextData *) JS_GetContextPrivate(cx);
23457: 
23457:     JS_ASSERT(data);
23457:     return data;
23457: }
23457: 
23126: static JSBool
23457: ShellOperationCallback(JSContext *cx)
23126: {
25709:     if (!gCanceled)
25709:         return JS_TRUE;
25709: 
25709:     JS_ClearPendingException(cx);
25709:     return JS_FALSE;
23126: }
23126: 
23126: static void
26673: SetContextOptions(JSContext *cx)
26673: {
25087:     JS_SetOperationCallback(cx, ShellOperationCallback);
23126: }
23126: 
73992: /*
73992:  * Some UTF-8 files, notably those written using Notepad, have a Unicode
73992:  * Byte-Order-Mark (BOM) as their first character. This is useless (byte-order
73992:  * is meaningless for UTF-8) but causes a syntax error unless we skip it.
73992:  */
73992: static void
73993: SkipUTF8BOM(FILE* file)
73992: {
73992:     if (!js_CStringsAreUTF8)
73992:         return;
73992: 
73992:     int ch1 = fgetc(file);
73992:     int ch2 = fgetc(file);
73992:     int ch3 = fgetc(file);
73992: 
73992:     // Skip the BOM
73992:     if (ch1 == 0xEF && ch2 == 0xBB && ch3 == 0xBF)
73992:         return;
73992: 
73992:     // No BOM - revert
73992:     if (ch3 != EOF)
73992:         ungetc(ch3, file);
73992:     if (ch2 != EOF)
73992:         ungetc(ch2, file);
73992:     if (ch1 != EOF)
73992:         ungetc(ch1, file);
73992: }
73992: 
23126: static void
74072: Process(JSContext *cx, JSObject *obj, const char *filename, bool forceTTY)
23126: {
23126:     JSBool ok, hitEOF;
78492:     JSScript *script;
23126:     jsval result;
23126:     JSString *str;
23723:     char *buffer;
24199:     size_t size;
68907:     jschar *uc_buffer;
68907:     size_t uc_len;
23126:     int lineno;
23126:     int startline;
23126:     FILE *file;
84755:     uint32_t oldopts;
23126: 
86437:     RootObject root(cx, &obj);
86437: 
23126:     if (forceTTY || !filename || strcmp(filename, "-") == 0) {
23126:         file = stdin;
23126:     } else {
23126:         file = fopen(filename, "r");
23126:         if (!file) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_CANT_OPEN, filename, strerror(errno));
23126:             gExitCode = EXITCODE_FILE_NOT_FOUND;
23126:             return;
23126:         }
23126:     }
23126: 
23126:     SetContextOptions(cx);
23126: 
37620:     if (!forceTTY && !isatty(fileno(file)))
37620:     {
73993:         SkipUTF8BOM(file);
73992: 
23126:         /*
88137:          * It's not interactive - just execute it.  Support the UNIX #! shell
88137:          * hack, and gobble the first line if it starts with '#'.
23126:          */
23126:         int ch = fgetc(file);
23126:         if (ch == '#') {
23126:             while((ch = fgetc(file)) != EOF) {
23126:                 if (ch == '\n' || ch == '\r')
23126:                     break;
23126:             }
23126:         }
23126:         ungetc(ch, file);
23126: 
84755:         int64_t t1 = PRMJ_Now();
23126:         oldopts = JS_GetOptions(cx);
23126:         JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
84856:         script = JS_CompileUTF8FileHandle(cx, obj, filename, file);
23126:         JS_SetOptions(cx, oldopts);
78492:         if (script && !compileOnly) {
88497:             if (!JS_ExecuteScript(cx, obj, script, NULL)) {
88497:                 if (!gQuitting && !gCanceled)
88497:                     gExitCode = EXITCODE_RUNTIME_ERROR;
88497:             }
84755:             int64_t t2 = PRMJ_Now() - t1;
56181:             if (printTiming)
56181:                 printf("runtime = %.3f ms\n", double(t2) / PRMJ_USEC_PER_MSEC);
56181:         }
23126: 
58984:         goto cleanup;
23126:     }
23126: 
23126:     /* It's an interactive filehandle; drop into read-eval-print loop. */
23126:     lineno = 1;
23126:     hitEOF = JS_FALSE;
23723:     buffer = NULL;
24199:     size = 0;           /* assign here to avoid warnings */
23126:     do {
23126:         /*
23126:          * Accumulate lines until we get a 'compilable unit' - one that either
23126:          * generates an error (before running out of source) or that compiles
23126:          * cleanly.  This should be whenever we get a complete statement that
23126:          * coincides with the end of a line.
23126:          */
23126:         startline = lineno;
25472:         size_t len = 0; /* initialize to avoid warnings */
23126:         do {
25472:             ScheduleWatchdog(cx->runtime, -1);
25472:             gCanceled = false;
23723:             errno = 0;
40289: 
40289:             char *line;
40289:             {
40289:                 JSAutoSuspendRequest suspended(cx);
40289:                 line = GetLine(file, startline == lineno ? "js> " : "");
40289:             }
23723:             if (!line) {
23723:                 if (errno) {
23723:                     JS_ReportError(cx, strerror(errno));
23723:                     free(buffer);
58984:                     goto cleanup;
23723:                 }
23126:                 hitEOF = JS_TRUE;
23126:                 break;
23126:             }
23723:             if (!buffer) {
23723:                 buffer = line;
23723:                 len = strlen(buffer);
23723:                 size = len + 1;
23723:             } else {
24198:                 /*
24198:                  * len + 1 is required to store '\n' in the end of line.
23723:                  */
23723:                 size_t newlen = strlen(line) + (len ? len + 1 : 0);
23723:                 if (newlen + 1 > size) {
23723:                     size = newlen + 1 > size * 2 ? newlen + 1 : size * 2;
23723:                     char *newBuf = (char *) realloc(buffer, size);
23723:                     if (!newBuf) {
23723:                         free(buffer);
23723:                         free(line);
23723:                         JS_ReportOutOfMemory(cx);
58984:                         goto cleanup;
23723:                     }
23723:                     buffer = newBuf;
23723:                 }
23723:                 char *current = buffer + len;
23723:                 if (startline != lineno)
23723:                     *current++ = '\n';
23723:                 strcpy(current, line);
23723:                 len = newlen;
23723:                 free(line);
23723:             }
23126:             lineno++;
25472:             if (!ScheduleWatchdog(cx->runtime, gTimeoutInterval)) {
25472:                 hitEOF = JS_TRUE;
25472:                 break;
25472:             }
68907:         } while (!JS_BufferIsCompilableUnit(cx, JS_TRUE, obj, buffer, len));
23126: 
24239:         if (hitEOF && !buffer)
23733:             break;
23733: 
68907:         if (!JS_DecodeUTF8(cx, buffer, len, NULL, &uc_len)) {
68907:             JS_ReportError(cx, "Invalid UTF-8 in input");
68907:             gExitCode = EXITCODE_RUNTIME_ERROR;
68907:             return;
68907:         }
68907: 
68907:         uc_buffer = (jschar*)malloc(uc_len * sizeof(jschar));
68907:         JS_DecodeUTF8(cx, buffer, len, uc_buffer, &uc_len);
68907: 
23126:         /* Clear any pending exception from previous failed compiles. */
23126:         JS_ClearPendingException(cx);
24148: 
24148:         /* Even though we're interactive, we have a compile-n-go opportunity. */
24148:         oldopts = JS_GetOptions(cx);
24148:         if (!compileOnly)
24148:             JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO);
78492:         script = JS_CompileUCScript(cx, obj, uc_buffer, uc_len, "typein", startline);
24148:         if (!compileOnly)
24148:             JS_SetOptions(cx, oldopts);
24148: 
78492:         if (script && !compileOnly) {
78492:             ok = JS_ExecuteScript(cx, obj, script, &result);
23126:             if (ok && !JSVAL_IS_VOID(result)) {
32781:                 str = JS_ValueToSource(cx, result);
57812:                 ok = !!str;
57812:                 if (ok) {
57812:                     JSAutoByteString bytes(cx, str);
57812:                     ok = !!bytes;
57812:                     if (ok)
57812:                         fprintf(gOutFile, "%s\n", bytes.ptr());
57812:                 }
23126:             }
23126:         }
23723:         *buffer = '\0';
68907:         free(uc_buffer);
24304:     } while (!hitEOF && !gQuitting);
23733: 
23723:     free(buffer);
23126:     fprintf(gOutFile, "\n");
58984: cleanup:
23126:     if (file != stdin)
23126:         fclose(file);
23126:     return;
23126: }
23126: 
23126: /*
23126:  * JSContext option name to flag map. The option names are in alphabetical
23126:  * order for better reporting.
23126:  */
80468: static const struct JSOption {
23126:     const char  *name;
84755:     uint32_t    flag;
23126: } js_options[] = {
23126:     {"atline",          JSOPTION_ATLINE},
52557:     {"methodjit",       JSOPTION_METHODJIT},
62574:     {"methodjit_always",JSOPTION_METHODJIT_ALWAYS},
23126:     {"relimit",         JSOPTION_RELIMIT},
23126:     {"strict",          JSOPTION_STRICT},
77343:     {"typeinfer",       JSOPTION_TYPE_INFERENCE},
23126:     {"werror",          JSOPTION_WERROR},
23126:     {"xml",             JSOPTION_XML},
23126: };
23126: 
84755: static uint32_t
23126: MapContextOptionNameToFlag(JSContext* cx, const char* name)
23126: {
80468:     for (size_t i = 0; i < ArrayLength(js_options); ++i) {
23126:         if (strcmp(name, js_options[i].name) == 0)
23126:             return js_options[i].flag;
23126:     }
23126: 
23126:     char* msg = JS_sprintf_append(NULL,
23126:                                   "unknown option name '%s'."
23126:                                   " The valid names are ", name);
80468:     for (size_t i = 0; i < ArrayLength(js_options); ++i) {
23126:         if (!msg)
23126:             break;
23126:         msg = JS_sprintf_append(msg, "%s%s", js_options[i].name,
80468:                                 (i + 2 < ArrayLength(js_options)
23126:                                  ? ", "
80468:                                  : i + 2 == ArrayLength(js_options)
23126:                                  ? " and "
23126:                                  : "."));
23126:     }
23126:     if (!msg) {
23126:         JS_ReportOutOfMemory(cx);
23126:     } else {
23126:         JS_ReportError(cx, msg);
23126:         free(msg);
23126:     }
23126:     return 0;
23126: }
23126: 
23126: extern JSClass global_class;
23126: 
23126: static JSBool
91237: Version(JSContext *cx, unsigned argc, jsval *vp)
23126: {
53557:     jsval *argv = JS_ARGV(cx, vp);
75248:     if (argc == 0 || JSVAL_IS_VOID(argv[0])) {
75248:         /* Get version. */
53557:         *vp = INT_TO_JSVAL(JS_GetVersion(cx));
75248:     } else {
75248:         /* Set version. */
84755:         int32_t v = -1;
75248:         if (JSVAL_IS_INT(argv[0])) {
75248:             v = JSVAL_TO_INT(argv[0]);
75248:         } else if (JSVAL_IS_DOUBLE(argv[0])) {
90955:             double fv = JSVAL_TO_DOUBLE(argv[0]);
84755:             if (int32_t(fv) == fv)
84755:                 v = int32_t(fv);
75248:         }
75248:         if (v < 0 || v > JSVERSION_LATEST) {
75248:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "version");
75248:             return false;
75248:         }
75248:         *vp = INT_TO_JSVAL(JS_SetVersion(cx, JSVersion(v)));
75248:     }
75248:     return true;
23126: }
23126: 
23126: static JSBool
91237: RevertVersion(JSContext *cx, unsigned argc, jsval *vp)
53848: {
53848:     js_RevertVersion(cx);
53848:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53848:     return JS_TRUE;
53848: }
53848: 
53848: static JSBool
91237: Options(JSContext *cx, unsigned argc, jsval *vp)
23126: {
84755:     uint32_t optset, flag;
23126:     JSString *str;
23126:     char *names;
23126:     JSBool found;
23126: 
23126:     optset = 0;
53557:     jsval *argv = JS_ARGV(cx, vp);
91237:     for (unsigned i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         argv[i] = STRING_TO_JSVAL(str);
57812:         JSAutoByteString opt(cx, str);
23126:         if (!opt)
23126:             return JS_FALSE;
57812:         flag = MapContextOptionNameToFlag(cx, opt.ptr());
23126:         if (!flag)
23126:             return JS_FALSE;
23126:         optset |= flag;
23126:     }
23126:     optset = JS_ToggleOptions(cx, optset);
23126: 
23126:     names = NULL;
23126:     found = JS_FALSE;
80468:     for (size_t i = 0; i < ArrayLength(js_options); i++) {
23126:         if (js_options[i].flag & optset) {
23126:             found = JS_TRUE;
23126:             names = JS_sprintf_append(names, "%s%s",
23126:                                       names ? "," : "", js_options[i].name);
23126:             if (!names)
23126:                 break;
23126:         }
23126:     }
23126:     if (!found)
23126:         names = strdup("");
23126:     if (!names) {
23126:         JS_ReportOutOfMemory(cx);
23126:         return JS_FALSE;
23126:     }
59008:     str = JS_NewStringCopyZ(cx, names);
23126:     free(names);
59008:     if (!str)
23126:         return JS_FALSE;
53557:     *vp = STRING_TO_JSVAL(str);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: Load(JSContext *cx, unsigned argc, jsval *vp)
23126: {
97353:     RootedVarObject thisobj(cx, JS_THIS_OBJECT(cx, vp));
53557:     if (!thisobj)
53557:         return JS_FALSE;
53557: 
53557:     jsval *argv = JS_ARGV(cx, vp);
91237:     for (unsigned i = 0; i < argc; i++) {
64190:         JSString *str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
64190:             return false;
23126:         argv[i] = STRING_TO_JSVAL(str);
57812:         JSAutoByteString filename(cx, str);
57812:         if (!filename)
57812:             return JS_FALSE;
23126:         errno = 0;
84755:         uint32_t oldopts = JS_GetOptions(cx);
23126:         JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
84856:         JSScript *script = JS_CompileUTF8File(cx, thisobj, filename.ptr());
23126:         JS_SetOptions(cx, oldopts);
78492:         if (!script)
64190:             return false;
64190: 
78492:         if (!compileOnly && !JS_ExecuteScript(cx, thisobj, script, NULL))
64190:             return false;
64190:     }
64190: 
77343:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
64190:     return true;
23126: }
23126: 
61216: static JSBool
91237: EvaluateWithLocation(JSContext *cx, unsigned argc, jsval *vp)
88303: {
88303:     if (argc != 3) {
88303:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
88303:                              argc > 3 ? JSSMSG_TOO_MANY_ARGS : JSSMSG_NOT_ENOUGH_ARGS,
88303:                              "evalWithLocation");
88303:         return false;
88303:     }
88303: 
88303:     JSString *code = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
88303:     if (!code)
88303:         return false;
88303:     JS::Anchor<JSString *> a_code(code);
88303: 
88303:     size_t codeLength;
88303:     const jschar *codeChars = JS_GetStringCharsAndLength(cx, code, &codeLength);
88303:     if (!codeChars)
88303:         return false;
88303: 
88303:     JSString *filename = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);
88303:     if (!filename)
88303:         return false;
88303: 
88303:     uint32_t lineno;
88303:     if (!JS_ValueToECMAUint32(cx, JS_ARGV(cx, vp)[2], &lineno))
88303:         return false;
88303: 
88303:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
88303:     if (!thisobj)
88303:         return false;
88303: 
89430:     if ((JS_GetClass(thisobj)->flags & JSCLASS_IS_GLOBAL) != JSCLASS_IS_GLOBAL) {
88303:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
88303:                              "this-value passed to evalWithLocation()", "not a global object");
88303:         return false;
88303:     }
88303: 
88303:     char *filenameBytes = JS_EncodeString(cx, filename);
88303:     if (!filenameBytes)
88303:         return false;
88303: 
88303:     jsval rval;
88303:     bool ok = JS_EvaluateUCScript(cx, thisobj, codeChars, codeLength, filenameBytes, lineno, &rval);
88303:     JS_free(cx, filenameBytes);
88303: 
88303:     if (!ok)
88303:         return false;
88303: 
88303:     JS_SET_RVAL(cx, vp, rval);
88303:     return true;
88303: }
88303: 
88303: static JSBool
97693: EvaluateCommon(JSContext *cx, unsigned argc, jsval *vp, bool compileAndGo)
61216: {
61216:     if (argc != 1 || !JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
61216:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
61216:                              (argc != 1) ? JSSMSG_NOT_ENOUGH_ARGS : JSSMSG_INVALID_ARGS,
61216:                              "evaluate");
61216:         return false;
61216:     }
61216: 
61216:     JSString *code = JSVAL_TO_STRING(JS_ARGV(cx, vp)[0]);
61216: 
61216:     size_t codeLength;
61216:     const jschar *codeChars = JS_GetStringCharsAndLength(cx, code, &codeLength);
61216:     if (!codeChars)
61216:         return false;
61216: 
61216:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
61216:     if (!thisobj)
61216:         return false;
61216: 
89430:     if ((JS_GetClass(thisobj)->flags & JSCLASS_IS_GLOBAL) != JSCLASS_IS_GLOBAL) {
61216:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
61216:                              "this-value passed to evaluate()", "not a global object");
61216:         return false;
61216:     }
61216: 
97693:     if (compileAndGo) {
97693:         // JS_EvaluateUCScript always enables the compile-and-go option.
97693:         return JS_EvaluateUCScript(cx, thisobj, codeChars, codeLength, "@evaluate", 1, vp);
97693:     } else {
97693:         uint32_t saved = JS_GetOptions(cx);
97693: 
97693:         JS_SetOptions(cx, saved & ~JSOPTION_COMPILE_N_GO);
97693:         JSScript *script = JS_CompileUCScript(cx, thisobj, codeChars, codeLength, "@evaluate", 1);
97693:         JS_SetOptions(cx, saved);
97693: 
97693:         return script && JS_ExecuteScript(cx, thisobj, script, vp);
97693:     }
97693: }
97693: 
97693: static JSBool
97693: Evaluate(JSContext *cx, unsigned argc, jsval *vp)
97693: {
97693:     return EvaluateCommon(cx, argc, vp, true);
97693: }
97693: 
97693: static JSBool
97693: EvaluateNonCompileAndGo(JSContext *cx, unsigned argc, jsval *vp)
97693: {
97693:     return EvaluateCommon(cx, argc, vp, false);
61216: }
61216: 
62030: static JSString *
62030: FileAsString(JSContext *cx, const char *pathname)
62030: {
62030:     FILE *file;
62030:     JSString *str = NULL;
62030:     size_t len, cc;
62030:     char *buf;
62030: 
62030:     file = fopen(pathname, "rb");
62030:     if (!file) {
62030:         JS_ReportError(cx, "can't open %s: %s", pathname, strerror(errno));
62030:         return NULL;
62030:     }
62030: 
69649:     if (fseek(file, 0, SEEK_END) != 0) {
62030:         JS_ReportError(cx, "can't seek end of %s", pathname);
62030:     } else {
62030:         len = ftell(file);
69649:         if (fseek(file, 0, SEEK_SET) != 0) {
62030:             JS_ReportError(cx, "can't seek start of %s", pathname);
62030:         } else {
62030:             buf = (char*) JS_malloc(cx, len + 1);
62030:             if (buf) {
62030:                 cc = fread(buf, 1, len, file);
62030:                 if (cc != len) {
62030:                     JS_ReportError(cx, "can't read %s: %s", pathname,
62030:                                    (ptrdiff_t(cc) < 0) ? strerror(errno) : "short read");
62030:                 } else {
68907:                     jschar *ucbuf;
68907:                     size_t uclen;
68907: 
62030:                     len = (size_t)cc;
68907: 
68907:                     if (!JS_DecodeUTF8(cx, buf, len, NULL, &uclen)) {
68907:                         JS_ReportError(cx, "Invalid UTF-8 in file '%s'", pathname);
68907:                         gExitCode = EXITCODE_RUNTIME_ERROR;
68907:                         return NULL;
68907:                     }
68907: 
68907:                     ucbuf = (jschar*)malloc(uclen * sizeof(jschar));
68907:                     JS_DecodeUTF8(cx, buf, len, ucbuf, &uclen);
68907:                     str = JS_NewUCStringCopyN(cx, ucbuf, uclen);
68907:                     free(ucbuf);
62030:                 }
62030:                 JS_free(cx, buf);
62030:             }
62030:         }
62030:     }
62030:     fclose(file);
62030: 
62030:     return str;
62030: }
62030: 
69649: static JSObject *
69649: FileAsTypedArray(JSContext *cx, const char *pathname)
69649: {
69649:     FILE *file = fopen(pathname, "rb");
69649:     if (!file) {
69649:         JS_ReportError(cx, "can't open %s: %s", pathname, strerror(errno));
69649:         return NULL;
69649:     }
69649: 
69649:     JSObject *obj = NULL;
69649:     if (fseek(file, 0, SEEK_END) != 0) {
69649:         JS_ReportError(cx, "can't seek end of %s", pathname);
69649:     } else {
69649:         size_t len = ftell(file);
69649:         if (fseek(file, 0, SEEK_SET) != 0) {
69649:             JS_ReportError(cx, "can't seek start of %s", pathname);
69649:         } else {
95834:             obj = JS_NewUint8Array(cx, len);
69649:             if (!obj)
69649:                 return NULL;
95834:             char *buf = (char *) TypedArray::getDataOffset(obj);
69649:             size_t cc = fread(buf, 1, len, file);
69649:             if (cc != len) {
69649:                 JS_ReportError(cx, "can't read %s: %s", pathname,
69649:                                (ptrdiff_t(cc) < 0) ? strerror(errno) : "short read");
69649:                 obj = NULL;
69649:             }
69649:         }
69649:     }
69649:     fclose(file);
69649:     return obj;
69649: }
69649: 
62030: /*
62030:  * Function to run scripts and return compilation + execution time. Semantics
62030:  * are closely modelled after the equivalent function in WebKit, as this is used
62030:  * to produce benchmark timings by SunSpider.
62030:  */
62030: static JSBool
91237: Run(JSContext *cx, unsigned argc, jsval *vp)
62030: {
62030:     if (argc != 1) {
62030:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "run");
62030:         return false;
62030:     }
62030: 
62030:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
62030:     if (!thisobj)
62030:         return false;
62030: 
62030:     jsval *argv = JS_ARGV(cx, vp);
62030:     JSString *str = JS_ValueToString(cx, argv[0]);
62030:     if (!str)
62030:         return false;
62030:     argv[0] = STRING_TO_JSVAL(str);
62030:     JSAutoByteString filename(cx, str);
62030:     if (!filename)
62030:         return false;
62030: 
62030:     const jschar *ucbuf = NULL;
62030:     size_t buflen;
62030:     str = FileAsString(cx, filename.ptr());
62030:     if (str)
62030:         ucbuf = JS_GetStringCharsAndLength(cx, str, &buflen);
62030:     if (!ucbuf)
62030:         return false;
62030: 
62030:     JS::Anchor<JSString *> a_str(str);
84755:     uint32_t oldopts = JS_GetOptions(cx);
62030:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
62030: 
84755:     int64_t startClock = PRMJ_Now();
78492:     JSScript *script = JS_CompileUCScript(cx, thisobj, ucbuf, buflen, filename.ptr(), 1);
62030:     JS_SetOptions(cx, oldopts);
78492:     if (!script || !JS_ExecuteScript(cx, thisobj, script, NULL))
62030:         return false;
62030: 
84755:     int64_t endClock = PRMJ_Now();
62030:     JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL((endClock - startClock) / double(PRMJ_USEC_PER_MSEC)));
62030:     return true;
62030: }
62030: 
23126: /*
23126:  * function readline()
23126:  * Provides a hook for scripts to read a line from stdin.
23126:  */
23126: static JSBool
91237: ReadLine(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126: #define BUFSIZE 256
23126:     FILE *from;
23126:     char *buf, *tmp;
23126:     size_t bufsize, buflength, gotlength;
23126:     JSBool sawNewline;
23126:     JSString *str;
23126: 
23126:     from = stdin;
23126:     buflength = 0;
23126:     bufsize = BUFSIZE;
23126:     buf = (char *) JS_malloc(cx, bufsize);
23126:     if (!buf)
23126:         return JS_FALSE;
23126: 
23126:     sawNewline = JS_FALSE;
23126:     while ((gotlength =
23126:             js_fgets(buf + buflength, bufsize - buflength, from)) > 0) {
23126:         buflength += gotlength;
23126: 
23126:         /* Are we done? */
23126:         if (buf[buflength - 1] == '\n') {
23126:             buf[buflength - 1] = '\0';
23126:             sawNewline = JS_TRUE;
23126:             break;
23126:         } else if (buflength < bufsize - 1) {
23126:             break;
23126:         }
23126: 
23126:         /* Else, grow our buffer for another pass. */
23126:         bufsize *= 2;
23126:         if (bufsize > buflength) {
23126:             tmp = (char *) JS_realloc(cx, buf, bufsize);
23126:         } else {
23126:             JS_ReportOutOfMemory(cx);
23126:             tmp = NULL;
23126:         }
23126: 
23126:         if (!tmp) {
23126:             JS_free(cx, buf);
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         buf = tmp;
23126:     }
23126: 
23126:     /* Treat the empty string specially. */
23126:     if (buflength == 0) {
23126:         *vp = feof(from) ? JSVAL_NULL : JS_GetEmptyStringValue(cx);
23126:         JS_free(cx, buf);
23126:         return JS_TRUE;
23126:     }
23126: 
23126:     /* Shrink the buffer to the real size. */
23126:     tmp = (char *) JS_realloc(cx, buf, buflength);
23126:     if (!tmp) {
23126:         JS_free(cx, buf);
23126:         return JS_FALSE;
23126:     }
23126: 
23126:     buf = tmp;
23126: 
23126:     /*
23126:      * Turn buf into a JSString. Note that buflength includes the trailing null
23126:      * character.
23126:      */
59008:     str = JS_NewStringCopyN(cx, buf, sawNewline ? buflength - 1 : buflength);
23126:     JS_free(cx, buf);
59008:     if (!str)
23126:         return JS_FALSE;
23126: 
23126:     *vp = STRING_TO_JSVAL(str);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: PutStr(JSContext *cx, unsigned argc, jsval *vp)
48808: {
48808:     jsval *argv;
48808:     JSString *str;
48808:     char *bytes;
48808: 
48808:     if (argc != 0) {
48808:         argv = JS_ARGV(cx, vp);
48808:         str = JS_ValueToString(cx, argv[0]);
48808:         if (!str)
48808:             return JS_FALSE;
48808:         bytes = JS_EncodeString(cx, str);
48808:         if (!bytes)
48808:             return JS_FALSE;
48808:         fputs(bytes, gOutFile);
48808:         JS_free(cx, bytes);
48808:         fflush(gOutFile);
48808:     }
48808: 
48808:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
48808:     return JS_TRUE;
48808: }
48808: 
48808: static JSBool
91237: Now(JSContext *cx, unsigned argc, jsval *vp)
49114: {
90955:     double now = PRMJ_Now() / double(PRMJ_USEC_PER_MSEC);
49114:     JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(now));
49114:     return true;
49114: }
49114: 
49114: static JSBool
91237: PrintInternal(JSContext *cx, unsigned argc, jsval *vp, FILE *file)
23126: {
23126:     jsval *argv;
91237:     unsigned i;
23126:     JSString *str;
23126:     char *bytes;
23126: 
23126:     argv = JS_ARGV(cx, vp);
23126:     for (i = 0; i < argc; i++) {
23126:         str = JS_ValueToString(cx, argv[i]);
23126:         if (!str)
23126:             return JS_FALSE;
23126:         bytes = JS_EncodeString(cx, str);
23126:         if (!bytes)
23126:             return JS_FALSE;
82897:         fprintf(file, "%s%s", i ? " " : "", bytes);
23126:         JS_free(cx, bytes);
23126:     }
23126: 
82897:     fputc('\n', file);
82897:     fflush(file);
23126: 
23126:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: Print(JSContext *cx, unsigned argc, jsval *vp)
82897: {
82897:     return PrintInternal(cx, argc, vp, gOutFile);
82897: }
82897: 
82897: static JSBool
91237: PrintErr(JSContext *cx, unsigned argc, jsval *vp)
82897: {
82897:     return PrintInternal(cx, argc, vp, gErrFile);
82897: }
82897: 
82897: static JSBool
91237: Help(JSContext *cx, unsigned argc, jsval *vp);
23126: 
23126: static JSBool
91237: Quit(JSContext *cx, unsigned argc, jsval *vp)
23126: {
53557:     JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "/ i", &gExitCode);
23126: 
23126:     gQuitting = JS_TRUE;
40801: #ifdef JS_THREADSAFE
55619:     if (gWorkerThreadPool)
81562:         js::workers::terminateAll(gWorkerThreadPool);
40801: #endif
23126:     return JS_FALSE;
23126: }
23126: 
25699: static const char *
57812: ToSource(JSContext *cx, jsval *vp, JSAutoByteString *bytes)
25699: {
25699:     JSString *str = JS_ValueToSource(cx, *vp);
25699:     if (str) {
25699:         *vp = STRING_TO_JSVAL(str);
57812:         if (bytes->encode(cx, str))
57812:             return bytes->ptr();
25699:     }
25699:     JS_ClearPendingException(cx);
25699:     return "<<error converting value to string>>";
25699: }
25699: 
25699: static JSBool
91237: AssertEq(JSContext *cx, unsigned argc, jsval *vp)
25699: {
32760:     if (!(argc == 2 || (argc == 3 && JSVAL_IS_STRING(JS_ARGV(cx, vp)[2])))) {
25699:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
32760:                              (argc < 2)
32760:                              ? JSSMSG_NOT_ENOUGH_ARGS
32760:                              : (argc == 3)
32760:                              ? JSSMSG_INVALID_ARGS
32760:                              : JSSMSG_TOO_MANY_ARGS,
25699:                              "assertEq");
25699:         return JS_FALSE;
25699:     }
25699: 
25699:     jsval *argv = JS_ARGV(cx, vp);
59889:     JSBool same;
59889:     if (!JS_SameValue(cx, argv[0], argv[1], &same))
59889:         return JS_FALSE;
59889:     if (!same) {
57812:         JSAutoByteString bytes0, bytes1;
57812:         const char *actual = ToSource(cx, &argv[0], &bytes0);
57812:         const char *expected = ToSource(cx, &argv[1], &bytes1);
32760:         if (argc == 2) {
25699:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_EQ_FAILED,
25699:                                  actual, expected);
32760:         } else {
57812:             JSAutoByteString bytes2(cx, JSVAL_TO_STRING(argv[2]));
57812:             if (!bytes2)
57812:                 return JS_FALSE;
32760:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_EQ_FAILED_MSG,
57812:                                  actual, expected, bytes2.ptr());
32760:         }
25699:         return JS_FALSE;
25699:     }
25699:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
25699:     return JS_TRUE;
25699: }
25699: 
23126: static JSBool
91237: AssertJit(JSContext *cx, unsigned argc, jsval *vp)
53120: {
53120: #ifdef JS_METHODJIT
53120:     if (JS_GetOptions(cx) & JSOPTION_METHODJIT) {
77353:         /*
77353:          * :XXX: Ignore calls to this native when inference is enabled,
77353:          * with METHODJIT_ALWAYS recompilation can happen and discard the
77353:          * script's jitcode.
77353:          */
77353:         if (!cx->typeInferenceEnabled() &&
77353:             !cx->fp()->script()->getJIT(cx->fp()->isConstructing())) {
53120:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_ASSERT_JIT_FAILED);
53120:             return JS_FALSE;
53120:         }
53120:     }
53120: #endif
53120: 
53120:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53120:     return JS_TRUE;
53120: }
53120: 
23126: static JSScript *
78492: ValueToScript(JSContext *cx, jsval v, JSFunction **funp = NULL)
23126: {
27012:     JSScript *script = NULL;
78492:     JSFunction *fun = NULL;
23126: 
27012:     if (!JSVAL_IS_PRIMITIVE(v)) {
27012:         JSObject *obj = JSVAL_TO_OBJECT(v);
89430:         JSClass *clasp = JS_GetClass(obj);
27012: 
80803:         if (clasp == Jsvalify(&GeneratorClass)) {
89826:             if (JSGenerator *gen = (JSGenerator *) JS_GetPrivate(obj)) {
53840:                 fun = gen->floatingFrame()->fun();
76812:                 script = fun->script();
27012:             }
27012:         }
84694:     }
27012: 
27012:     if (!script) {
23126:         fun = JS_ValueToFunction(cx, v);
23126:         if (!fun)
23126:             return NULL;
76812:         script = fun->maybeScript();
23126:         if (!script) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_SCRIPTS_ONLY);
23126:         }
27012:     }
78492:     if (fun && funp)
78492:         *funp = fun;
23126: 
23126:     return script;
23126: }
23126: 
23126: static JSBool
91237: SetDebug(JSContext *cx, unsigned argc, jsval *vp)
53391: {
53557:     jsval *argv = JS_ARGV(cx, vp);
53391:     if (argc == 0 || !JSVAL_IS_BOOLEAN(argv[0])) {
53391:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53391:                              JSSMSG_NOT_ENOUGH_ARGS, "setDebug");
53391:         return JS_FALSE;
53391:     }
53391: 
62780:     /*
62780:      * Debug mode can only be set when there is no JS code executing on the
62780:      * stack. Unfortunately, that currently means that this call will fail
62780:      * unless debug mode is already set to what you're trying to set it to.
62780:      * In the future, this restriction may be lifted.
62780:      */
62780: 
75506:     JSBool ok = JS_SetDebugMode(cx, JSVAL_TO_BOOLEAN(argv[0]));
75506:     if (ok)
75506:         JS_SET_RVAL(cx, vp, JSVAL_TRUE);
75506:     return ok;
53391: }
53391: 
92133: static JSScript *
92133: GetTopScript(JSContext *cx)
92133: {
92133:     JSScript *script;
92133:     JS_DescribeScriptedCaller(cx, &script, NULL);
92133:     return script;
92133: }
92133: 
53391: static JSBool
91237: GetScriptAndPCArgs(JSContext *cx, unsigned argc, jsval *argv, JSScript **scriptp,
84755:                    int32_t *ip)
23126: {
92133:     JSScript *script = GetTopScript(cx);
23126:     *ip = 0;
23126:     if (argc != 0) {
82035:         jsval v = argv[0];
91237:         unsigned intarg = 0;
23126:         if (!JSVAL_IS_PRIMITIVE(v) &&
89430:             JS_GetClass(JSVAL_TO_OBJECT(v)) == Jsvalify(&FunctionClass)) {
23126:             script = ValueToScript(cx, v);
23126:             if (!script)
23126:                 return JS_FALSE;
23126:             intarg++;
23126:         }
23126:         if (argc > intarg) {
78952:             if (!JS_ValueToInt32(cx, argv[intarg], ip))
23126:                 return JS_FALSE;
84755:             if ((uint32_t)*ip >= script->length) {
82035:                 JS_ReportError(cx, "Invalid PC");
82035:                 return JS_FALSE;
82035:             }
82035:         }
82035:     }
82035: 
82035:     *scriptp = script;
82035: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSTrapStatus
69223: TrapHandler(JSContext *cx, JSScript *, jsbytecode *pc, jsval *rval,
41863:             jsval closure)
23126: {
48582:     JSString *str = JSVAL_TO_STRING(closure);
92133: 
97161:     ScriptFrameIter iter(cx);
92133:     JS_ASSERT(!iter.done());
92133: 
92133:     JSStackFrame *caller = Jsvalify(iter.fp());
92133:     JSScript *script = iter.script();
59889: 
59889:     size_t length;
59889:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:     if (!chars)
59889:         return JSTRAP_ERROR;
59889: 
59889:     if (!JS_EvaluateUCInStackFrame(cx, caller, chars, length,
69223:                                    script->filename,
69223:                                    script->lineno,
23126:                                    rval)) {
23126:         return JSTRAP_ERROR;
23126:     }
23126:     if (!JSVAL_IS_VOID(*rval))
23126:         return JSTRAP_RETURN;
23126:     return JSTRAP_CONTINUE;
23126: }
23126: 
23126: static JSBool
91237: Trap(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSString *str;
23126:     JSScript *script;
84755:     int32_t i;
23126: 
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     if (argc == 0) {
23126:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_TRAP_USAGE);
23126:         return JS_FALSE;
23126:     }
23126:     argc--;
23126:     str = JS_ValueToString(cx, argv[argc]);
23126:     if (!str)
23126:         return JS_FALSE;
23126:     argv[argc] = STRING_TO_JSVAL(str);
82035:     if (!GetScriptAndPCArgs(cx, argc, argv, &script, &i))
23126:         return JS_FALSE;
84755:     if (uint32_t(i) >= script->length) {
77343:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_TRAP_USAGE);
77343:         return JS_FALSE;
77343:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
41863:     return JS_SetTrap(cx, script, script->code + i, TrapHandler, STRING_TO_JSVAL(str));
23126: }
23126: 
23126: static JSBool
91237: Untrap(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSScript *script;
84755:     int32_t i;
78952: 
82035:     if (!GetScriptAndPCArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     JS_ClearTrap(cx, script, script->code + i, NULL, NULL);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: 
53395: static JSTrapStatus
53410: DebuggerAndThrowHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
53395:                         void *closure)
53395: {
53395:     return TrapHandler(cx, script, pc, rval, STRING_TO_JSVAL((JSString *)closure));
53395: }
53395: 
53395: static JSBool
91237: SetDebuggerHandler(JSContext *cx, unsigned argc, jsval *vp)
53395: {
53395:     JSString *str;
53395:     if (argc == 0) {
53395:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53395:                              JSSMSG_NOT_ENOUGH_ARGS, "setDebuggerHandler");
53395:         return JS_FALSE;
53395:     }
53395: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
53395:     if (!str)
53395:         return JS_FALSE;
53395: 
53410:     JS_SetDebuggerHandler(cx->runtime, DebuggerAndThrowHandler, str);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53410:     return JS_TRUE;
53410: }
53410: 
53410: static JSBool
91237: SetThrowHook(JSContext *cx, unsigned argc, jsval *vp)
53410: {
53410:     JSString *str;
53410:     if (argc == 0) {
53410:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
53410:                              JSSMSG_NOT_ENOUGH_ARGS, "setThrowHook");
53410:         return JS_FALSE;
53410:     }
53410: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
53410:     if (!str)
53410:         return JS_FALSE;
53410: 
53410:     JS_SetThrowHook(cx->runtime, DebuggerAndThrowHandler, str);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53395:     return JS_TRUE;
53395: }
53395: 
23126: static JSBool
91237: LineToPC(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSScript *script;
84755:     int32_t lineArg = 0;
84755:     uint32_t lineno;
23126:     jsbytecode *pc;
23126: 
23126:     if (argc == 0) {
23126:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_LINE2PC_USAGE);
23126:         return JS_FALSE;
23126:     }
92133:     script = GetTopScript(cx);
82035:     jsval v = JS_ARGV(cx, vp)[0];
82035:     if (!JSVAL_IS_PRIMITIVE(v) &&
89430:         JS_GetClass(JSVAL_TO_OBJECT(v)) == Jsvalify(&FunctionClass))
82035:     {
82035:         script = ValueToScript(cx, v);
82035:         if (!script)
23126:             return JS_FALSE;
82035:         lineArg++;
82035:     }
82035:     if (!JS_ValueToECMAUint32(cx, JS_ARGV(cx, vp)[lineArg], &lineno))
82035:         return JS_FALSE;
23126:     pc = JS_LineNumberToPC(cx, script, lineno);
23126:     if (!pc)
23126:         return JS_FALSE;
53557:     *vp = INT_TO_JSVAL(pc - script->code);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: PCToLine(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSScript *script;
84755:     int32_t i;
91237:     unsigned lineno;
23126: 
82035:     if (!GetScriptAndPCArgs(cx, argc, JS_ARGV(cx, vp), &script, &i))
23126:         return JS_FALSE;
23126:     lineno = JS_PCToLineNumber(cx, script, script->code + i);
23126:     if (!lineno)
23126:         return JS_FALSE;
53557:     *vp = INT_TO_JSVAL(lineno);
23126:     return JS_TRUE;
23126: }
23126: 
23126: #ifdef DEBUG
23126: 
23126: static void
91237: UpdateSwitchTableBounds(JSContext *cx, JSScript *script, unsigned offset,
91237:                         unsigned *start, unsigned *end)
23126: {
23126:     jsbytecode *pc;
23126:     JSOp op;
23126:     ptrdiff_t jmplen;
91450:     int32_t low, high, n;
23126: 
23126:     pc = script->code + offset;
84195:     op = JSOp(*pc);
23126:     switch (op) {
23126:       case JSOP_TABLESWITCH:
23126:         jmplen = JUMP_OFFSET_LEN;
23126:         pc += jmplen;
23126:         low = GET_JUMP_OFFSET(pc);
23126:         pc += JUMP_OFFSET_LEN;
23126:         high = GET_JUMP_OFFSET(pc);
23126:         pc += JUMP_OFFSET_LEN;
23126:         n = high - low + 1;
23126:         break;
23126: 
23126:       case JSOP_LOOKUPSWITCH:
23126:         jmplen = JUMP_OFFSET_LEN;
23126:         pc += jmplen;
90965:         n = GET_UINT16(pc);
90965:         pc += UINT16_LEN;
23126:         jmplen += JUMP_OFFSET_LEN;
23126:         break;
23126: 
23126:       default:
23126:         /* [condswitch] switch does not have any jump or lookup tables. */
23126:         JS_ASSERT(op == JSOP_CONDSWITCH);
23126:         return;
23126:     }
23126: 
91237:     *start = (unsigned)(pc - script->code);
91237:     *end = *start + (unsigned)(n * jmplen);
23126: }
23126: 
23126: static void
64374: SrcNotes(JSContext *cx, JSScript *script, Sprinter *sp)
23126: {
64374:     Sprint(sp, "\nSource notes:\n");
64374:     Sprint(sp, "%4s  %4s %5s %6s %-8s %s\n",
64196:            "ofs", "line", "pc", "delta", "desc", "args");
64374:     Sprint(sp, "---- ---- ----- ------ -------- ------\n");
91237:     unsigned offset = 0;
91237:     unsigned lineno = script->lineno;
80631:     jssrcnote *notes = script->notes();
91237:     unsigned switchTableEnd = 0, switchTableStart = 0;
80631:     for (jssrcnote *sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
91237:         unsigned delta = SN_DELTA(sn);
23126:         offset += delta;
80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
80631:         const char *name = js_SrcNoteSpec[type].name;
23126:         if (type == SRC_LABEL) {
23126:             /* Check if the source note is for a switch case. */
95101:             if (switchTableStart <= offset && offset < switchTableEnd)
23126:                 name = "case";
23126:         }
91237:         Sprint(sp, "%3u: %4u %5u [%4u] %-8s", unsigned(sn - notes), lineno, offset, delta, name);
23126:         switch (type) {
23126:           case SRC_SETLINE:
64196:             lineno = js_GetSrcNoteOffset(sn, 0);
64374:             Sprint(sp, " lineno %u", lineno);
64196:             break;
64196:           case SRC_NEWLINE:
64196:             ++lineno;
23126:             break;
23126:           case SRC_FOR:
64374:             Sprint(sp, " cond %u update %u tail %u",
91237:                    unsigned(js_GetSrcNoteOffset(sn, 0)),
91237:                    unsigned(js_GetSrcNoteOffset(sn, 1)),
91237:                    unsigned(js_GetSrcNoteOffset(sn, 2)));
23126:             break;
23126:           case SRC_IF_ELSE:
64374:             Sprint(sp, " else %u elseif %u",
91237:                    unsigned(js_GetSrcNoteOffset(sn, 0)),
91237:                    unsigned(js_GetSrcNoteOffset(sn, 1)));
23126:             break;
23126:           case SRC_COND:
23126:           case SRC_WHILE:
23126:           case SRC_PCBASE:
23126:           case SRC_PCDELTA:
23126:           case SRC_DECL:
23126:           case SRC_BRACE:
91237:             Sprint(sp, " offset %u", unsigned(js_GetSrcNoteOffset(sn, 0)));
23126:             break;
23126:           case SRC_LABEL:
23126:           case SRC_LABELBRACE:
23126:           case SRC_BREAK2LABEL:
80631:           case SRC_CONT2LABEL: {
84755:             uint32_t index = js_GetSrcNoteOffset(sn, 0);
80631:             JSAtom *atom = script->getAtom(index);
64374:             Sprint(sp, " atom %u (", index);
64374:             size_t len = PutEscapedString(NULL, 0, atom, '\0');
87952:             if (char *buf = sp->reserve(len)) {
95101:                 PutEscapedString(buf, len + 1, atom, 0);
87952:                 buf[len] = 0;
64374:             }
64374:             Sprint(sp, ")");
23126:             break;
80631:           }
23126:           case SRC_FUNCDEF: {
84755:             uint32_t index = js_GetSrcNoteOffset(sn, 0);
57812:             JSObject *obj = script->getObject(index);
83235:             JSFunction *fun = obj->toFunction();
80631:             JSString *str = JS_DecompileFunction(cx, fun, JS_DONT_PRETTY_PRINT);
57812:             JSAutoByteString bytes;
57812:             if (!str || !bytes.encode(cx, str))
47498:                 ReportException(cx);
64374:             Sprint(sp, " function %u (%s)", index, !!bytes ? bytes.ptr() : "N/A");
23126:             break;
23126:           }
74403:           case SRC_SWITCH: {
84195:             JSOp op = JSOp(script->code[offset]);
86877:             if (op == JSOP_GOTO)
73877:                 break;
91237:             Sprint(sp, " length %u", unsigned(js_GetSrcNoteOffset(sn, 0)));
91237:             unsigned caseOff = (unsigned) js_GetSrcNoteOffset(sn, 1);
23126:             if (caseOff)
64374:                 Sprint(sp, " first case offset %u", caseOff);
25216:             UpdateSwitchTableBounds(cx, script, offset,
23126:                                     &switchTableStart, &switchTableEnd);
23126:             break;
74403:           }
23126:           case SRC_CATCH:
91237:             delta = (unsigned) js_GetSrcNoteOffset(sn, 0);
23126:             if (delta) {
77659:                 if (script->main()[offset] == JSOP_LEAVEBLOCK)
64374:                     Sprint(sp, " stack depth %u", delta);
23126:                 else
64374:                     Sprint(sp, " guard delta %u", delta);
23126:             }
23126:             break;
23126:           default:;
23126:         }
64374:         Sprint(sp, "\n");
23126:     }
23126: }
23126: 
23126: static JSBool
91237: Notes(JSContext *cx, unsigned argc, jsval *vp)
23126: {
87952:     Sprinter sprinter(cx);
87952:     if (!sprinter.init())
87952:         return JS_FALSE;
64374: 
53557:     jsval *argv = JS_ARGV(cx, vp);
91237:     for (unsigned i = 0; i < argc; i++) {
79410:         JSScript *script = ValueToScript(cx, argv[i]);
23126:         if (!script)
23126:             continue;
23126: 
64374:         SrcNotes(cx, script, &sprinter);
64374:     }
64374: 
87952:     JSString *str = JS_NewStringCopyZ(cx, sprinter.string());
64374:     if (!str)
64374:         return JS_FALSE;
64374:     JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(str));
23126:     return JS_TRUE;
23126: }
23126: 
23126: JS_STATIC_ASSERT(JSTRY_CATCH == 0);
23126: JS_STATIC_ASSERT(JSTRY_FINALLY == 1);
23126: JS_STATIC_ASSERT(JSTRY_ITER == 2);
23126: 
23126: static const char* const TryNoteNames[] = { "catch", "finally", "iter" };
23126: 
23126: static JSBool
64374: TryNotes(JSContext *cx, JSScript *script, Sprinter *sp)
23126: {
23126:     JSTryNote *tn, *tnlimit;
23126: 
97361:     if (!script->hasTrynotes())
23126:         return JS_TRUE;
23126: 
32723:     tn = script->trynotes()->vector;
32723:     tnlimit = tn + script->trynotes()->length;
64374:     Sprint(sp, "\nException table:\nkind      stack    start      end\n");
23126:     do {
80468:         JS_ASSERT(tn->kind < ArrayLength(TryNoteNames));
64374:         Sprint(sp, " %-7s %6u %8u %8u\n",
23126:                TryNoteNames[tn->kind], tn->stackDepth,
23126:                tn->start, tn->start + tn->length);
23126:     } while (++tn != tnlimit);
23126:     return JS_TRUE;
23126: }
23126: 
28924: static bool
78492: DisassembleScript(JSContext *cx, JSScript *script, JSFunction *fun, bool lines, bool recursive,
78492:                   Sprinter *sp)
23126: {
27012:     if (fun && (fun->flags & ~7U)) {
84755:         uint16_t flags = fun->flags;
64374:         Sprint(sp, "flags:");
64374: 
64374: #define SHOW_FLAG(flag) if (flags & JSFUN_##flag) Sprint(sp, " " #flag);
23126: 
23126:         SHOW_FLAG(LAMBDA);
23126:         SHOW_FLAG(HEAVYWEIGHT);
23126:         SHOW_FLAG(EXPR_CLOSURE);
23126: 
23126: #undef SHOW_FLAG
27012: 
76812:         if (fun->isNullClosure())
64374:             Sprint(sp, " NULL_CLOSURE");
93245: 
64374:         Sprint(sp, "\n");
64374:     }
64374: 
97353:     Root<JSScript*> scriptRoot(cx, &script);
97353: 
64374:     if (!js_Disassemble(cx, script, lines, sp))
28924:         return false;
64374:     SrcNotes(cx, script, sp);
64374:     TryNotes(cx, script, sp);
28924: 
97361:     if (recursive && script->hasObjects()) {
97362:         ObjectArray *objects = script->objects();
91237:         for (unsigned i = 0; i != objects->length; ++i) {
28924:             JSObject *obj = objects->vector[i];
40430:             if (obj->isFunction()) {
64374:                 Sprint(sp, "\n");
83234:                 JSFunction *fun = obj->toFunction();
78492:                 JSScript *nested = fun->maybeScript();
78492:                 if (!DisassembleScript(cx, nested, fun, lines, recursive, sp))
28924:                     return false;
28924:             }
28924:         }
28924:     }
28924:     return true;
28924: }
28924: 
78492: namespace {
78492: 
78492: struct DisassembleOptionParser {
91237:     unsigned   argc;
78492:     jsval   *argv;
78492:     bool    lines;
78492:     bool    recursive;
78492: 
91237:     DisassembleOptionParser(unsigned argc, jsval *argv)
78492:       : argc(argc), argv(argv), lines(false), recursive(false) {}
78492: 
78492:     bool parse(JSContext *cx) {
58045:         /* Read options off early arguments */
28924:         while (argc > 0 && JSVAL_IS_STRING(argv[0])) {
57721:             JSString *str = JSVAL_TO_STRING(argv[0]);
59889:             JSFlatString *flatStr = JS_FlattenString(cx, str);
59889:             if (!flatStr)
78492:                 return false;
78492:             if (JS_FlatStringEqualsAscii(flatStr, "-l"))
78492:                 lines = true;
78492:             else if (JS_FlatStringEqualsAscii(flatStr, "-r"))
78492:                 recursive = true;
78492:             else
28924:                 break;
28924:             argv++, argc--;
28924:         }
78492:         return true;
78492:     }
78492: };
78492: 
78492: } /* anonymous namespace */
78492: 
78492: static JSBool
91237: DisassembleToString(JSContext *cx, unsigned argc, jsval *vp)
78492: {
78492:     DisassembleOptionParser p(argc, JS_ARGV(cx, vp));
78492:     if (!p.parse(cx))
78492:         return false;
28924: 
87952:     Sprinter sprinter(cx);
87952:     if (!sprinter.init())
87952:         return false;
64374: 
64374:     bool ok = true;
78492:     if (p.argc == 0) {
58720:         /* Without arguments, disassemble the current script. */
92133:         if (JSScript *script = GetTopScript(cx)) {
87952:             if (js_Disassemble(cx, script, p.lines, &sprinter)) {
87952:                 SrcNotes(cx, script, &sprinter);
87952:                 TryNotes(cx, script, &sprinter);
64374:             } else {
64374:                 ok = false;
64374:             }
64374:         }
64374:     } else {
91237:         for (unsigned i = 0; i < p.argc; i++) {
78492:             JSFunction *fun;
78492:             JSScript *script = ValueToScript(cx, p.argv[i], &fun);
87952:             ok = ok && script && DisassembleScript(cx, script, fun, p.lines, p.recursive, &sprinter);
87952:         }
87952:     }
87952: 
87952:     JSString *str = ok ? JS_NewStringCopyZ(cx, sprinter.string()) : NULL;
64374:     if (!str)
58720:         return false;
64374:     JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(str));
64374:     return true;
64374: }
64374: 
64374: static JSBool
91237: Disassemble(JSContext *cx, unsigned argc, jsval *vp)
64374: {
78492:     DisassembleOptionParser p(argc, JS_ARGV(cx, vp));
78492:     if (!p.parse(cx))
78492:         return false;
64374: 
87952:     Sprinter sprinter(cx);
87952:     if (!sprinter.init())
87952:         return false;
64374: 
64374:     bool ok = true;
78492:     if (p.argc == 0) {
64374:         /* Without arguments, disassemble the current script. */
92133:         if (JSScript *script = GetTopScript(cx)) {
87952:             if (js_Disassemble(cx, script, p.lines, &sprinter)) {
87952:                 SrcNotes(cx, script, &sprinter);
87952:                 TryNotes(cx, script, &sprinter);
58720:             } else {
64374:                 ok = false;
64374:             }
64374:         }
64374:     } else {
91237:         for (unsigned i = 0; i < p.argc; i++) {
78492:             JSFunction *fun;
78492:             JSScript *script = ValueToScript(cx, p.argv[i], &fun);
87952:             ok = ok && script && DisassembleScript(cx, script, fun, p.lines, p.recursive, &sprinter);
78492:         }
64374:     }
64374: 
64374:     if (ok)
87952:         fprintf(stdout, "%s\n", sprinter.string());
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
64374:     return ok;
23126: }
23126: 
23126: static JSBool
91237: DisassFile(JSContext *cx, unsigned argc, jsval *vp)
23126: {
78492:     /* Support extra options at the start, just like Dissassemble. */
78492:     DisassembleOptionParser p(argc, JS_ARGV(cx, vp));
78492:     if (!p.parse(cx))
78492:         return false;
78492: 
78492:     if (!p.argc) {
53639:         JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:         return JS_TRUE;
53639:     }
23126: 
53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
53557:     if (!thisobj)
53557:         return JS_FALSE;
53557: 
78492:     JSString *str = JS_ValueToString(cx, p.argv[0]);
23126:     if (!str)
23126:         return JS_FALSE;
57812:     JSAutoByteString filename(cx, str);
57812:     if (!filename)
57812:         return JS_FALSE;
57812: 
84755:     uint32_t oldopts = JS_GetOptions(cx);
23126:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
84856:     JSScript *script = JS_CompileUTF8File(cx, thisobj, filename.ptr());
23126:     JS_SetOptions(cx, oldopts);
78492:     if (!script)
64190:         return false;
64190: 
87952:     Sprinter sprinter(cx);
87952:     if (!sprinter.init())
87952:         return false;
78492:     bool ok = DisassembleScript(cx, script, NULL, p.lines, p.recursive, &sprinter);
78492:     if (ok)
87952:         fprintf(stdout, "%s\n", sprinter.string());
78492:     if (!ok)
78492:         return false;
78492: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
78492:     return true;
23126: }
23126: 
23126: static JSBool
91237: DisassWithSrc(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126: #define LINE_BUF_LEN 512
91237:     unsigned i, len, line1, line2, bupline;
23126:     JSScript *script;
23126:     FILE *file;
23126:     char linebuf[LINE_BUF_LEN];
23126:     jsbytecode *pc, *end;
23126:     JSBool ok;
23126:     static char sep[] = ";-------------------------";
23126: 
23126:     ok = JS_TRUE;
53557:     jsval *argv = JS_ARGV(cx, vp);
23126:     for (i = 0; ok && i < argc; i++) {
23126:         script = ValueToScript(cx, argv[i]);
23126:         if (!script)
23126:            return JS_FALSE;
23126: 
23126:         if (!script->filename) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_FILE_SCRIPTS_ONLY);
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         file = fopen(script->filename, "r");
23126:         if (!file) {
23126:             JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                  JSSMSG_CANT_OPEN, script->filename,
23126:                                  strerror(errno));
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         pc = script->code;
23126:         end = pc + script->length;
23126: 
87952:         Sprinter sprinter(cx);
87952:         if (!sprinter.init()) {
87952:             ok = JS_FALSE;
87952:             goto bail;
87952:         }
64374: 
23126:         /* burn the leading lines */
23126:         line2 = JS_PCToLineNumber(cx, script, pc);
40289:         for (line1 = 0; line1 < line2 - 1; line1++) {
40289:             char *tmp = fgets(linebuf, LINE_BUF_LEN, file);
40289:             if (!tmp) {
79410:                 JS_ReportError(cx, "failed to read %s fully", script->filename);
40289:                 ok = JS_FALSE;
40289:                 goto bail;
40289:             }
40289:         }
23126: 
23126:         bupline = 0;
23126:         while (pc < end) {
23126:             line2 = JS_PCToLineNumber(cx, script, pc);
23126: 
23126:             if (line2 < line1) {
23126:                 if (bupline != line2) {
23126:                     bupline = line2;
87952:                     Sprint(&sprinter, "%s %3u: BACKUP\n", sep, line2);
23126:                 }
23126:             } else {
23126:                 if (bupline && line1 == line2)
87952:                     Sprint(&sprinter, "%s %3u: RESTORE\n", sep, line2);
23126:                 bupline = 0;
23126:                 while (line1 < line2) {
23126:                     if (!fgets(linebuf, LINE_BUF_LEN, file)) {
23126:                         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL,
23126:                                              JSSMSG_UNEXPECTED_EOF,
23126:                                              script->filename);
23126:                         ok = JS_FALSE;
23126:                         goto bail;
23126:                     }
23126:                     line1++;
87952:                     Sprint(&sprinter, "%s %3u: %s", sep, line1, linebuf);
87952:                 }
87952:             }
87952: 
87952:             len = js_Disassemble1(cx, script, pc, pc - script->code, JS_TRUE, &sprinter);
23126:             if (!len) {
23126:                 ok = JS_FALSE;
23126:                 goto bail;
23126:             }
23126:             pc += len;
23126:         }
23126: 
23126:       bail:
23126:         fclose(file);
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return ok;
23126: #undef LINE_BUF_LEN
23126: }
23126: 
23126: static JSBool
91237: DumpHeap(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     jsval v;
23126:     void* startThing;
77715:     JSGCTraceKind startTraceKind;
23126:     const char *badTraceArg;
23126:     void *thingToFind;
23126:     size_t maxDepth;
23126:     void *thingToIgnore;
23126:     FILE *dumpFile;
23126:     JSBool ok;
23126: 
57812:     const char *fileName = NULL;
57812:     JSAutoByteString fileNameBytes;
23126:     if (argc > 0) {
23126:         v = JS_ARGV(cx, vp)[0];
48470:         if (!JSVAL_IS_NULL(v)) {
23126:             JSString *str;
23126: 
23126:             str = JS_ValueToString(cx, v);
23126:             if (!str)
23126:                 return JS_FALSE;
23126:             JS_ARGV(cx, vp)[0] = STRING_TO_JSVAL(str);
57812:             if (!fileNameBytes.encode(cx, str))
57812:                 return JS_FALSE;
57812:             fileName = fileNameBytes.ptr();
23126:         }
23126:     }
23126: 
23126:     startThing = NULL;
77715:     startTraceKind = JSTRACE_OBJECT;
23126:     if (argc > 1) {
23126:         v = JS_ARGV(cx, vp)[1];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             startThing = JSVAL_TO_TRACEABLE(v);
23126:             startTraceKind = JSVAL_TRACE_KIND(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "start";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     thingToFind = NULL;
23126:     if (argc > 2) {
23126:         v = JS_ARGV(cx, vp)[2];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             thingToFind = JSVAL_TO_TRACEABLE(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "toFind";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     maxDepth = (size_t)-1;
23126:     if (argc > 3) {
23126:         v = JS_ARGV(cx, vp)[3];
48470:         if (!JSVAL_IS_NULL(v)) {
84755:             uint32_t depth;
23126: 
23126:             if (!JS_ValueToECMAUint32(cx, v, &depth))
23126:                 return JS_FALSE;
23126:             maxDepth = depth;
23126:         }
23126:     }
23126: 
23126:     thingToIgnore = NULL;
23126:     if (argc > 4) {
23126:         v = JS_ARGV(cx, vp)[4];
23126:         if (JSVAL_IS_TRACEABLE(v)) {
23126:             thingToIgnore = JSVAL_TO_TRACEABLE(v);
48470:         } else if (!JSVAL_IS_NULL(v)) {
23126:             badTraceArg = "toIgnore";
23126:             goto not_traceable_arg;
23126:         }
23126:     }
23126: 
23126:     if (!fileName) {
23126:         dumpFile = stdout;
23126:     } else {
23126:         dumpFile = fopen(fileName, "w");
23126:         if (!dumpFile) {
23126:             JS_ReportError(cx, "can't open %s: %s", fileName, strerror(errno));
23126:             return JS_FALSE;
23126:         }
23126:     }
23126: 
91339:     ok = JS_DumpHeap(JS_GetRuntime(cx), dumpFile, startThing, startTraceKind, thingToFind,
23126:                      maxDepth, thingToIgnore);
23126:     if (dumpFile != stdout)
23126:         fclose(dumpFile);
91339:     if (!ok) {
91339:         JS_ReportOutOfMemory(cx);
91339:         return false;
91339:     }
77343:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
91339:     return true;
23126: 
23126:   not_traceable_arg:
23126:     JS_ReportError(cx, "argument '%s' is not null or a heap-allocated thing",
23126:                    badTraceArg);
23126:     return JS_FALSE;
23126: }
23126: 
49117: JSBool
91237: DumpObject(JSContext *cx, unsigned argc, jsval *vp)
49117: {
49117:     JSObject *arg0 = NULL;
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "o", &arg0))
49117:         return JS_FALSE;
49117: 
49117:     js_DumpObject(arg0);
49117: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
49117:     return JS_TRUE;
49117: }
49117: 
23126: #endif /* DEBUG */
23126: 
71697: /*
71697:  * This shell function is temporary (used by testStackIter.js) and should be
71697:  * removed once JSD2 lands wholly subsumes the functionality here.
71697:  */
71697: JSBool
91237: DumpStack(JSContext *cx, unsigned argc, Value *vp)
71697: {
97353:     RootedVarObject arr(cx, JS_NewArrayObject(cx, 0, NULL));
71697:     if (!arr)
71697:         return false;
71697: 
97353:     RootedVarString evalStr(cx, JS_NewStringCopyZ(cx, "eval-code"));
71697:     if (!evalStr)
71697:         return false;
71697: 
97353:     RootedVarString globalStr(cx, JS_NewStringCopyZ(cx, "global-code"));
71697:     if (!globalStr)
71697:         return false;
71697: 
71697:     StackIter iter(cx);
97160:     JS_ASSERT(iter.isNativeCall() && iter.callee()->native() == DumpStack);
71697:     ++iter;
71697: 
84755:     uint32_t index = 0;
71697:     for (; !iter.done(); ++index, ++iter) {
71697:         Value v;
95394:         if (iter.isNonEvalFunctionFrame() || iter.isNativeCall()) {
95385:             v = iter.calleev();
95385:         } else if (iter.isEvalFrame()) {
71697:             v = StringValue(evalStr);
71697:         } else {
71697:             v = StringValue(globalStr);
71697:         }
78614:         if (!JS_SetElement(cx, arr, index, &v))
71697:             return false;
71697:     }
71697: 
71697:     JS_SET_RVAL(cx, vp, ObjectValue(*arr));
71697:     return true;
71697: }
71697: 
23126: #ifdef TEST_CVTARGS
23126: #include <ctype.h>
23126: 
23126: static const char *
23126: EscapeWideString(jschar *w)
23126: {
23126:     static char enuf[80];
23126:     static char hex[] = "0123456789abcdef";
23126:     jschar u;
23126:     unsigned char b, c;
23126:     int i, j;
23126: 
23126:     if (!w)
23126:         return "";
23126:     for (i = j = 0; i < sizeof enuf - 1; i++, j++) {
23126:         u = w[j];
23126:         if (u == 0)
23126:             break;
23126:         b = (unsigned char)(u >> 8);
23126:         c = (unsigned char)(u);
23126:         if (b) {
23126:             if (i >= sizeof enuf - 6)
23126:                 break;
23126:             enuf[i++] = '\\';
23126:             enuf[i++] = 'u';
23126:             enuf[i++] = hex[b >> 4];
23126:             enuf[i++] = hex[b & 15];
23126:             enuf[i++] = hex[c >> 4];
23126:             enuf[i] = hex[c & 15];
23126:         } else if (!isprint(c)) {
23126:             if (i >= sizeof enuf - 4)
23126:                 break;
23126:             enuf[i++] = '\\';
23126:             enuf[i++] = 'x';
23126:             enuf[i++] = hex[c >> 4];
23126:             enuf[i] = hex[c & 15];
23126:         } else {
23126:             enuf[i] = (char)c;
23126:         }
23126:     }
23126:     enuf[i] = 0;
23126:     return enuf;
23126: }
23126: 
23126: #include <stdarg.h>
23126: 
23126: static JSBool
23126: ZZ_formatter(JSContext *cx, const char *format, JSBool fromJS, jsval **vpp,
23126:              va_list *app)
23126: {
23126:     jsval *vp;
23126:     va_list ap;
90955:     double re, im;
23126: 
23126:     printf("entering ZZ_formatter");
23126:     vp = *vpp;
23126:     ap = *app;
23126:     if (fromJS) {
23126:         if (!JS_ValueToNumber(cx, vp[0], &re))
23126:             return JS_FALSE;
23126:         if (!JS_ValueToNumber(cx, vp[1], &im))
23126:             return JS_FALSE;
90955:         *va_arg(ap, double *) = re;
90955:         *va_arg(ap, double *) = im;
23126:     } else {
90955:         re = va_arg(ap, double);
90955:         im = va_arg(ap, double);
23126:         if (!JS_NewNumberValue(cx, re, &vp[0]))
23126:             return JS_FALSE;
23126:         if (!JS_NewNumberValue(cx, im, &vp[1]))
23126:             return JS_FALSE;
23126:     }
23126:     *vpp = vp + 2;
23126:     *app = ap;
23126:     printf("leaving ZZ_formatter");
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: ConvertArgs(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSBool b = JS_FALSE;
23126:     jschar c = 0;
84755:     int32_t i = 0, j = 0;
84755:     uint32_t u = 0;
90955:     double d = 0, I = 0, re = 0, im = 0;
23126:     JSString *str = NULL;
23126:     jschar *w = NULL;
23126:     JSObject *obj2 = NULL;
23126:     JSFunction *fun = NULL;
23126:     jsval v = JSVAL_VOID;
23126:     JSBool ok;
23126: 
23126:     if (!JS_AddArgumentFormatter(cx, "ZZ", ZZ_formatter))
31366:         return JS_FALSE;
57812:     ok = JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "b/ciujdISWofvZZ*",
57812:                              &b, &c, &i, &u, &j, &d, &I, &str, &w, &obj2,
23126:                              &fun, &v, &re, &im);
23126:     JS_RemoveArgumentFormatter(cx, "ZZ");
23126:     if (!ok)
23126:         return JS_FALSE;
23126:     fprintf(gOutFile,
23126:             "b %u, c %x (%c), i %ld, u %lu, j %ld\n",
23126:             b, c, (char)c, i, u, j);
84160:     ToStringHelper obj2string(cx, obj2);
84160:     ToStringHelper valueString(cx, v);
57812:     JSAutoByteString strBytes;
57812:     if (str)
57812:         strBytes.encode(cx, str);
31366:     JSString *tmpstr = JS_DecompileFunction(cx, fun, 4);
57812:     JSAutoByteString func;
86046:     if (!tmpstr || !func.encode(cx, tmpstr))
47498:         ReportException(cx);
23126:     fprintf(gOutFile,
57812:             "d %g, I %g, S %s, W %s, obj %s, fun %s\n"
23126:             "v %s, re %g, im %g\n",
57812:             d, I, !!strBytes ? strBytes.ptr() : "", EscapeWideString(w),
31366:             obj2string.getBytes(),
57812:             fun ? (!!func ? func.ptr() : "error decompiling fun") : "",
31366:             valueString.getBytes(), re, im);
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return JS_TRUE;
23126: }
23126: #endif
23126: 
23126: static JSBool
91237: BuildDate(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     char version[20] = "\n";
23126: #if JS_VERSION < 150
23126:     sprintf(version, " for version %d\n", JS_VERSION);
23126: #endif
23126:     fprintf(gOutFile, "built on %s at %s%s", __DATE__, __TIME__, version);
23126:     *vp = JSVAL_VOID;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: Intern(JSContext *cx, unsigned argc, jsval *vp)
23126: {
59889:     JSString *str = JS_ValueToString(cx, argc == 0 ? JSVAL_VOID : vp[2]);
23126:     if (!str)
59889:         return false;
59889: 
59889:     size_t length;
59889:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:     if (!chars)
59889:         return false;
59889: 
59889:     if (!JS_InternUCStringN(cx, chars, length))
59889:         return false;
59889: 
59889:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
59889:     return true;
23126: }
23126: 
23126: static JSBool
91237: Clone(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSObject *funobj, *parent, *clone;
23126: 
75518:     if (!argc) {
75518:         JS_ReportError(cx, "Invalid arguments to clone");
53557:         return JS_FALSE;
75518:     }
53557: 
53557:     jsval *argv = JS_ARGV(cx, vp);
75518:     {
75518:         JSAutoEnterCompartment ac;
76252:         if (!JSVAL_IS_PRIMITIVE(argv[0]) &&
79734:             IsCrossCompartmentWrapper(JSVAL_TO_OBJECT(argv[0])))
76252:         {
79734:             JSObject *obj = UnwrapObject(JSVAL_TO_OBJECT(argv[0]));
75518:             if (!ac.enter(cx, obj))
75518:                 return JS_FALSE;
75518:             argv[0] = OBJECT_TO_JSVAL(obj);
75518:         }
76812:         if (!JSVAL_IS_PRIMITIVE(argv[0]) && JSVAL_TO_OBJECT(argv[0])->isFunction()) {
27012:             funobj = JSVAL_TO_OBJECT(argv[0]);
27012:         } else {
27012:             JSFunction *fun = JS_ValueToFunction(cx, argv[0]);
23126:             if (!fun)
23126:                 return JS_FALSE;
23126:             funobj = JS_GetFunctionObject(fun);
27012:         }
75518:     }
75518:     if (funobj->compartment() != cx->compartment) {
83234:         JSFunction *fun = funobj->toFunction();
79820:         if (fun->isInterpreted() && fun->script()->compileAndGo) {
75518:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
75518:                                  "function", "compile-and-go");
75518:             return JS_FALSE;
75518:         }
75518:     }
75518: 
23126:     if (argc > 1) {
23126:         if (!JS_ValueToObject(cx, argv[1], &parent))
23126:             return JS_FALSE;
23126:     } else {
89826:         parent = JS_GetParent(JSVAL_TO_OBJECT(JS_CALLEE(cx, vp)));
75518:     }
75518: 
23126:     clone = JS_CloneFunctionObject(cx, funobj, parent);
23126:     if (!clone)
23126:         return JS_FALSE;
53557:     *vp = OBJECT_TO_JSVAL(clone);
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: GetPDA(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSObject *vobj, *aobj, *pdobj;
23126:     JSBool ok;
23126:     JSPropertyDescArray pda;
23126:     JSPropertyDesc *pd;
23126:     jsval v;
23126: 
23126:     if (!JS_ValueToObject(cx, argc == 0 ? JSVAL_VOID : vp[2], &vobj))
23126:         return JS_FALSE;
24303:     if (!vobj) {
24303:         *vp = JSVAL_VOID;
23126:         return JS_TRUE;
24303:     }
23126: 
23126:     aobj = JS_NewArrayObject(cx, 0, NULL);
23126:     if (!aobj)
23126:         return JS_FALSE;
23126:     *vp = OBJECT_TO_JSVAL(aobj);
23126: 
23126:     ok = JS_GetPropertyDescArray(cx, vobj, &pda);
23126:     if (!ok)
23126:         return JS_FALSE;
23126:     pd = pda.array;
84755:     for (uint32_t i = 0; i < pda.length; i++, pd++) {
23126:         pdobj = JS_NewObject(cx, NULL, NULL, NULL);
23126:         if (!pdobj) {
23126:             ok = JS_FALSE;
23126:             break;
23126:         }
23126: 
23126:         /* Protect pdobj from GC by setting it as an element of aobj now */
23126:         v = OBJECT_TO_JSVAL(pdobj);
23126:         ok = JS_SetElement(cx, aobj, i, &v);
23126:         if (!ok)
23126:             break;
23126: 
23126:         ok = JS_SetProperty(cx, pdobj, "id", &pd->id) &&
23126:              JS_SetProperty(cx, pdobj, "value", &pd->value) &&
23126:              (v = INT_TO_JSVAL(pd->flags),
23126:               JS_SetProperty(cx, pdobj, "flags", &v)) &&
23126:              (v = INT_TO_JSVAL(pd->slot),
23126:               JS_SetProperty(cx, pdobj, "slot", &v)) &&
23126:              JS_SetProperty(cx, pdobj, "alias", &pd->alias);
23126:         if (!ok)
23126:             break;
23126:     }
23126:     JS_PutPropertyDescArray(cx, &pda);
23126:     return ok;
23126: }
23126: 
23126: static JSBool
91237: GetSLX(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSScript *script;
23126: 
23126:     script = ValueToScript(cx, argc == 0 ? JSVAL_VOID : vp[2]);
23126:     if (!script)
23126:         return JS_FALSE;
23126:     *vp = INT_TO_JSVAL(js_GetScriptLineExtent(script));
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: ToInt32(JSContext *cx, unsigned argc, jsval *vp)
23126: {
84755:     int32_t i;
23126: 
23126:     if (!JS_ValueToInt32(cx, argc == 0 ? JSVAL_VOID : vp[2], &i))
23126:         return JS_FALSE;
23126:     return JS_NewNumberValue(cx, i, vp);
23126: }
23126: 
23126: static JSBool
91237: StringsAreUTF8(JSContext *cx, unsigned argc, jsval *vp)
23126: {
53557:     *vp = JS_CStringsAreUTF8() ? JSVAL_TRUE : JSVAL_FALSE;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static const char* badUTF8 = "...\xC0...";
23126: static const char* bigUTF8 = "...\xFB\xBF\xBF\xBF\xBF...";
23126: static const jschar badSurrogate[] = { 'A', 'B', 'C', 0xDEEE, 'D', 'E', 0 };
23126: 
23126: static JSBool
91237: TestUTF8(JSContext *cx, unsigned argc, jsval *vp)
23126: {
84755:     int32_t mode = 1;
23126:     jschar chars[20];
23126:     size_t charsLength = 5;
23126:     char bytes[20];
23126:     size_t bytesLength = 20;
53557:     if (argc && !JS_ValueToInt32(cx, *JS_ARGV(cx, vp), &mode))
23126:         return JS_FALSE;
23126: 
23126:     /* The following throw errors if compiled with UTF-8. */
23126:     switch (mode) {
23126:       /* mode 1: malformed UTF-8 string. */
23126:       case 1:
23126:         JS_NewStringCopyZ(cx, badUTF8);
23126:         break;
23126:       /* mode 2: big UTF-8 character. */
23126:       case 2:
23126:         JS_NewStringCopyZ(cx, bigUTF8);
23126:         break;
23126:       /* mode 3: bad surrogate character. */
23126:       case 3:
23126:         JS_EncodeCharacters(cx, badSurrogate, 6, bytes, &bytesLength);
23126:         break;
23126:       /* mode 4: use a too small buffer. */
23126:       case 4:
23126:         JS_DecodeBytes(cx, "1234567890", 10, chars, &charsLength);
23126:         break;
23126:       default:
23126:         JS_ReportError(cx, "invalid mode parameter");
23126:         return JS_FALSE;
23126:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
23126:     return !JS_IsExceptionPending (cx);
23126: }
23126: 
23126: static JSBool
91237: ThrowError(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JS_ReportError(cx, "This is an error");
23126:     return JS_FALSE;
23126: }
23126: 
23126: #define LAZY_STANDARD_CLASSES
23126: 
23126: /* A class for easily testing the inner/outer object callbacks. */
23126: typedef struct ComplexObject {
23126:     JSBool isInner;
23126:     JSBool frozen;
23126:     JSObject *inner;
23126:     JSObject *outer;
23126: } ComplexObject;
23126: 
23126: static JSBool
97353: sandbox_enumerate(JSContext *cx, JSObject *obj_)
23126: {
97353:     RootedVarObject obj(cx, obj_);
97353: 
23126:     jsval v;
23126:     JSBool b;
23126: 
30581:     if (!JS_GetProperty(cx, obj, "lazy", &v))
23126:         return JS_FALSE;
30581: 
30581:     JS_ValueToBoolean(cx, v, &b);
23126:     return !b || JS_EnumerateStandardClasses(cx, obj);
23126: }
23126: 
23126: static JSBool
97353: sandbox_resolve(JSContext *cx, JSObject *obj_, jsid id_, unsigned flags,
23126:                 JSObject **objp)
23126: {
97353:     RootedVarObject obj(cx, obj_);
97353:     RootedVarId id(cx, id_);
97353: 
23126:     jsval v;
23126:     JSBool b, resolved;
23126: 
30581:     if (!JS_GetProperty(cx, obj, "lazy", &v))
23126:         return JS_FALSE;
30581: 
30581:     JS_ValueToBoolean(cx, v, &b);
23126:     if (b && (flags & JSRESOLVE_ASSIGNING) == 0) {
73063:         if (!JS_ResolveStandardClass(cx, obj, id, &resolved))
23126:             return JS_FALSE;
23126:         if (resolved) {
23126:             *objp = obj;
23126:             return JS_TRUE;
23126:         }
23126:     }
23126:     *objp = NULL;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSClass sandbox_class = {
23126:     "sandbox",
38533:     JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS,
23126:     JS_PropertyStub,   JS_PropertyStub,
62395:     JS_PropertyStub,   JS_StrictPropertyStub,
23126:     sandbox_enumerate, (JSResolveOp)sandbox_resolve,
93519:     JS_ConvertStub
23126: };
23126: 
47498: static JSObject *
75054: NewSandbox(JSContext *cx, bool lazy)
47498: {
97353:     RootedVarObject obj(cx, JS_NewCompartmentAndGlobalObject(cx, &sandbox_class, NULL));
47498:     if (!obj)
47498:         return NULL;
47498: 
47504:     {
54733:         JSAutoEnterCompartment ac;
47517:         if (!ac.enter(cx, obj))
47498:             return NULL;
47498: 
47504:         if (!lazy && !JS_InitStandardClasses(cx, obj))
47504:             return NULL;
47498: 
97353:         RootedVarValue value(cx, BooleanValue(lazy));
97353:         if (!JS_SetProperty(cx, obj, "lazy", value.address()))
47504:             return NULL;
47504:     }
47498: 
97353:     if (!cx->compartment->wrap(cx, obj.address()))
47498:         return NULL;
86437:     return obj;
47498: }
47498: 
23126: static JSBool
91237: EvalInContext(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSString *str;
47498:     JSObject *sobj = NULL;
53557:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "S / o", &str, &sobj))
47498:         return false;
47498: 
59889:     size_t srclen;
59889:     const jschar *src = JS_GetStringCharsAndLength(cx, str, &srclen);
59889:     if (!src)
59889:         return false;
59889: 
97353:     SkipRoot skip(cx, &src);
97353: 
75054:     bool lazy = false;
35108:     if (srclen == 4) {
35108:         if (src[0] == 'l' && src[1] == 'a' && src[2] == 'z' && src[3] == 'y') {
47498:             lazy = true;
23126:             srclen = 0;
23126:         }
35108:     }
23126: 
23126:     if (!sobj) {
75054:         sobj = NewSandbox(cx, lazy);
47498:         if (!sobj)
47498:             return false;
47498:     }
47498: 
73070:     if (srclen == 0) {
73070:         JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(sobj));
47498:         return true;
73070:     }
47498: 
92133:     JSScript *script;
92133:     unsigned lineno;
92133: 
92133:     JS_DescribeScriptedCaller(cx, &script, &lineno);
73070:     jsval rval;
47522:     {
54733:         JSAutoEnterCompartment ac;
91237:         unsigned flags;
89339:         JSObject *unwrapped = UnwrapObject(sobj, true, &flags);
79386:         if (flags & Wrapper::CROSS_COMPARTMENT) {
62594:             sobj = unwrapped;
47517:             if (!ac.enter(cx, sobj))
47498:                 return false;
47498:         }
47498: 
47498:         OBJ_TO_INNER_OBJECT(cx, sobj);
47517:         if (!sobj)
47517:             return false;
47517:         if (!(sobj->getClass()->flags & JSCLASS_IS_GLOBAL)) {
42742:             JS_ReportError(cx, "Invalid scope argument to evalcx");
47517:             return false;
47517:         }
47517:         if (!JS_EvaluateUCScript(cx, sobj, src, srclen,
69223:                                  script->filename,
92133:                                  lineno,
73070:                                  &rval)) {
47517:             return false;
47517:         }
47522:     }
73070: 
78614:     if (!cx->compartment->wrap(cx, &rval))
73070:         return false;
73070: 
73070:     JS_SET_RVAL(cx, vp, rval);
73070:     return true;
23126: }
23126: 
23126: static JSBool
91237: EvalInFrame(JSContext *cx, unsigned argc, jsval *vp)
40276: {
40276:     jsval *argv = JS_ARGV(cx, vp);
40276:     if (argc < 2 ||
40276:         !JSVAL_IS_INT(argv[0]) ||
40276:         !JSVAL_IS_STRING(argv[1])) {
40276:         JS_ReportError(cx, "Invalid arguments to evalInFrame");
40276:         return JS_FALSE;
40276:     }
40276: 
84755:     uint32_t upCount = JSVAL_TO_INT(argv[0]);
40276:     JSString *str = JSVAL_TO_STRING(argv[1]);
40276: 
40279:     bool saveCurrent = (argc >= 3 && JSVAL_IS_BOOLEAN(argv[2]))
48470:                         ? !!(JSVAL_TO_BOOLEAN(argv[2]))
40276:                         : false;
40276: 
71696:     JS_ASSERT(cx->hasfp());
40276: 
97161:     ScriptFrameIter fi(cx);
84755:     for (uint32_t i = 0; i < upCount; ++i, ++fi) {
53840:         if (!fi.fp()->prev())
40276:             break;
42717:     }
42717: 
69223:     StackFrame *const fp = fi.fp();
69223:     if (!fp->isScriptFrame()) {
40276:         JS_ReportError(cx, "cannot eval in non-script frame");
40276:         return JS_FALSE;
40276:     }
40276: 
71697:     JSBool saved = JS_FALSE;;
40276:     if (saveCurrent)
71697:         saved = JS_SaveFrameChain(cx);
40276: 
59890:     size_t length;
59890:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
59890:     if (!chars)
59890:         return JS_FALSE;
59890: 
69223:     JSBool ok = JS_EvaluateUCInStackFrame(cx, Jsvalify(fp), chars, length,
53840:                                           fp->script()->filename,
53840:                                           JS_PCToLineNumber(cx, fp->script(),
42717:                                                             fi.pc()),
40276:                                           vp);
40276: 
71697:     if (saved)
71697:         JS_RestoreFrameChain(cx);
40276: 
40276:     return ok;
40276: }
40276: 
40276: static JSBool
91237: ShapeOf(JSContext *cx, unsigned argc, jsval *vp)
23126: {
58981:     jsval v;
58981:     if (argc < 1 || !JSVAL_IS_OBJECT(v = JS_ARGV(cx, vp)[0])) {
23126:         JS_ReportError(cx, "shapeOf: object expected");
23126:         return JS_FALSE;
23126:     }
27165:     JSObject *obj = JSVAL_TO_OBJECT(v);
27165:     if (!obj) {
27165:         *vp = JSVAL_ZERO;
27165:         return JS_TRUE;
27165:     }
86976:     return JS_NewNumberValue(cx, (double) ((uintptr_t)obj->lastProperty() >> 3), vp);
23126: }
23126: 
62970: /*
62970:  * If referent has an own property named id, copy that property to obj[id].
62970:  * Since obj is native, this isn't totally transparent; properties of a
62970:  * non-native referent may be simplified to data properties.
62970:  */
62970: static JSBool
95355: CopyProperty(JSContext *cx, JSObject *obj_, JSObject *referent, jsid id,
91237:              unsigned lookupFlags, JSObject **objp)
62970: {
62970:     JSProperty *prop;
62970:     PropertyDescriptor desc;
91237:     unsigned propFlags = 0;
62970:     JSObject *obj2;
62970: 
95355:     RootedVarObject obj(cx, obj_);
95355: 
62970:     *objp = NULL;
62970:     if (referent->isNative()) {
69855:         if (!LookupPropertyWithFlags(cx, referent, id, lookupFlags, &obj2, &prop))
62970:             return false;
62970:         if (obj2 != referent)
62970:             return true;
62970: 
62970:         const Shape *shape = (Shape *) prop;
94227:         if (shape->hasSlot()) {
83221:             desc.value = referent->nativeGetSlot(shape->slot());
62970:         } else {
62970:             desc.value.setUndefined();
62970:         }
62970: 
62970:         desc.attrs = shape->attributes();
62970:         desc.getter = shape->getter();
62970:         if (!desc.getter && !(desc.attrs & JSPROP_GETTER))
78614:             desc.getter = JS_PropertyStub;
62970:         desc.setter = shape->setter();
62970:         if (!desc.setter && !(desc.attrs & JSPROP_SETTER))
78614:             desc.setter = JS_StrictPropertyStub;
83221:         desc.shortid = shape->shortid();
62970:         propFlags = shape->getFlags();
79734:    } else if (IsProxy(referent)) {
62970:         PropertyDescriptor desc;
79386:         if (!Proxy::getOwnPropertyDescriptor(cx, referent, id, false, &desc))
62970:             return false;
62970:         if (!desc.obj)
62970:             return true;
62970:     } else {
80442:         if (!referent->lookupGeneric(cx, id, objp, &prop))
62970:             return false;
62970:         if (*objp != referent)
62970:             return true;
78675:         if (!referent->getGeneric(cx, id, &desc.value) ||
80622:             !referent->getGenericAttributes(cx, id, &desc.attrs)) {
62970:             return false;
62970:         }
62970:         desc.attrs &= JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT;
78614:         desc.getter = JS_PropertyStub;
78614:         desc.setter = JS_StrictPropertyStub;
62970:         desc.shortid = 0;
62970:     }
62970: 
62970:     *objp = obj;
69855:     return !!DefineNativeProperty(cx, obj, id, desc.value, desc.getter, desc.setter,
69855:                                   desc.attrs, propFlags, desc.shortid);
62970: }
62970: 
62970: static JSBool
91237: resolver_resolve(JSContext *cx, JSObject *obj, jsid id, unsigned flags, JSObject **objp)
62970: {
89826:     jsval v = JS_GetReservedSlot(obj, 0);
62970:     return CopyProperty(cx, obj, JSVAL_TO_OBJECT(v), id, flags, objp);
62970: }
62970: 
62970: static JSBool
62970: resolver_enumerate(JSContext *cx, JSObject *obj)
62970: {
89826:     jsval v = JS_GetReservedSlot(obj, 0);
62970:     JSObject *referent = JSVAL_TO_OBJECT(v);
62970: 
62970:     AutoIdArray ida(cx, JS_Enumerate(cx, referent));
62970:     bool ok = !!ida;
62970:     JSObject *ignore;
62970:     for (size_t i = 0; ok && i < ida.length(); i++)
62970:         ok = CopyProperty(cx, obj, referent, ida[i], JSRESOLVE_QUALIFIED, &ignore);
62970:     return ok;
62970: }
62970: 
62970: static JSClass resolver_class = {
62970:     "resolver",
62970:     JSCLASS_NEW_RESOLVE | JSCLASS_HAS_RESERVED_SLOTS(1),
62970:     JS_PropertyStub,   JS_PropertyStub,
62970:     JS_PropertyStub,   JS_StrictPropertyStub,
62970:     resolver_enumerate, (JSResolveOp)resolver_resolve,
93519:     JS_ConvertStub
62970: };
62970: 
62970: 
62970: static JSBool
91237: Resolver(JSContext *cx, unsigned argc, jsval *vp)
62970: {
62970:     JSObject *referent, *proto = NULL;
62970:     if (!JS_ConvertArguments(cx, argc, JS_ARGV(cx, vp), "o/o", &referent, &proto))
62970:         return false;
62970: 
62970:     JSObject *result = (argc > 1
62970:                         ? JS_NewObjectWithGivenProto
89826:                         : JS_NewObject)(cx, &resolver_class, proto, JS_GetParent(referent));
62970:     if (!result)
62970:         return false;
62970: 
89826:     JS_SetReservedSlot(result, 0, OBJECT_TO_JSVAL(referent));
62970:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(result));
62970:     return true;
62970: }
62970: 
23126: #ifdef JS_THREADSAFE
23126: 
25472: /*
25472:  * Check that t1 comes strictly before t2. The function correctly deals with
25472:  * PRIntervalTime wrap-around between t2 and t1 assuming that t2 and t1 stays
25472:  * within INT32_MAX from each other. We use MAX_TIMEOUT_INTERVAL to enforce
25472:  * this restriction.
25472:  */
25472: static bool
25472: IsBefore(PRIntervalTime t1, PRIntervalTime t2)
25472: {
84755:     return int32_t(t1 - t2) < 0;
25472: }
25472: 
23126: static JSBool
91237: Sleep_fn(JSContext *cx, unsigned argc, jsval *vp)
23126: {
25472:     PRIntervalTime t_ticks;
25472: 
25472:     if (argc == 0) {
25472:         t_ticks = 0;
25472:     } else {
90955:         double t_secs;
23126: 
23126:         if (!JS_ValueToNumber(cx, argc == 0 ? JSVAL_VOID : vp[2], &t_secs))
23126:             return JS_FALSE;
23126: 
25472:         /* NB: The next condition also filter out NaNs. */
25472:         if (!(t_secs <= MAX_TIMEOUT_INTERVAL)) {
25472:             JS_ReportError(cx, "Excessive sleep interval");
25472:             return JS_FALSE;
25472:         }
25472:         t_ticks = (t_secs <= 0.0)
25472:                   ? 0
25472:                   : PRIntervalTime(PR_TicksPerSecond() * t_secs);
25472:     }
25472:     if (t_ticks == 0) {
25472:         JS_YieldRequest(cx);
25472:     } else {
40289:         JSAutoSuspendRequest suspended(cx);
25472:         PR_Lock(gWatchdogLock);
25472:         PRIntervalTime to_wakeup = PR_IntervalNow() + t_ticks;
25472:         for (;;) {
25472:             PR_WaitCondVar(gSleepWakeup, t_ticks);
25472:             if (gCanceled)
25472:                 break;
25472:             PRIntervalTime now = PR_IntervalNow();
25472:             if (!IsBefore(now, to_wakeup))
25472:                 break;
25472:             t_ticks = to_wakeup - now;
25472:         }
25472:         PR_Unlock(gWatchdogLock);
25472:     }
25472:     return !gCanceled;
23126: }
23126: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt)
25472: {
25472:     JS_ASSERT(!gWatchdogThread);
25472:     gWatchdogLock = PR_NewLock();
25472:     if (gWatchdogLock) {
25472:         gWatchdogWakeup = PR_NewCondVar(gWatchdogLock);
25472:         if (gWatchdogWakeup) {
25472:             gSleepWakeup = PR_NewCondVar(gWatchdogLock);
25472:             if (gSleepWakeup)
25472:                 return true;
25472:             PR_DestroyCondVar(gWatchdogWakeup);
25472:         }
25472:         PR_DestroyLock(gWatchdogLock);
25472:     }
25472:     return false;
25472: }
25472: 
25472: static void
25472: KillWatchdog()
25472: {
25472:     PRThread *thread;
25472: 
25472:     PR_Lock(gWatchdogLock);
25472:     thread = gWatchdogThread;
25472:     if (thread) {
25472:         /*
25472:          * The watchdog thread is running, tell it to terminate waking it up
25472:          * if necessary.
25472:          */
25472:         gWatchdogThread = NULL;
25472:         PR_NotifyCondVar(gWatchdogWakeup);
25472:     }
25472:     PR_Unlock(gWatchdogLock);
25472:     if (thread)
25472:         PR_JoinThread(thread);
25472:     PR_DestroyCondVar(gSleepWakeup);
25472:     PR_DestroyCondVar(gWatchdogWakeup);
25472:     PR_DestroyLock(gWatchdogLock);
25472: }
25472: 
23726: static void
23726: WatchdogMain(void *arg)
23726: {
23726:     JSRuntime *rt = (JSRuntime *) arg;
23726: 
25472:     PR_Lock(gWatchdogLock);
23726:     while (gWatchdogThread) {
25472:         PRIntervalTime now = PR_IntervalNow();
25472:          if (gWatchdogHasTimeout && !IsBefore(now, gWatchdogTimeout)) {
25472:             /*
25472:              * The timeout has just expired. Trigger the operation callback
25472:              * outside the lock.
25472:              */
25472:             gWatchdogHasTimeout = false;
25472:             PR_Unlock(gWatchdogLock);
25472:             CancelExecution(rt);
25472:             PR_Lock(gWatchdogLock);
25472: 
25472:             /* Wake up any threads doing sleep. */
25472:             PR_NotifyAllCondVar(gSleepWakeup);
25472:         } else {
25472:             PRIntervalTime sleepDuration = gWatchdogHasTimeout
25472:                                            ? gWatchdogTimeout - now
25472:                                            : PR_INTERVAL_NO_TIMEOUT;
68941:             DebugOnly<PRStatus> status =
25472:                 PR_WaitCondVar(gWatchdogWakeup, sleepDuration);
23726:             JS_ASSERT(status == PR_SUCCESS);
23726:         }
25472:     }
25472:     PR_Unlock(gWatchdogLock);
25472: }
25472: 
25472: static bool
90955: ScheduleWatchdog(JSRuntime *rt, double t)
23726: {
25472:     if (t <= 0) {
25472:         PR_Lock(gWatchdogLock);
25472:         gWatchdogHasTimeout = false;
25472:         PR_Unlock(gWatchdogLock);
25472:         return true;
25472:     }
25472: 
25472:     PRIntervalTime interval = PRIntervalTime(ceil(t * PR_TicksPerSecond()));
25472:     PRIntervalTime timeout = PR_IntervalNow() + interval;
25472:     PR_Lock(gWatchdogLock);
25472:     if (!gWatchdogThread) {
25472:         JS_ASSERT(!gWatchdogHasTimeout);
23726:         gWatchdogThread = PR_CreateThread(PR_USER_THREAD,
23726:                                           WatchdogMain,
25087:                                           rt,
23726:                                           PR_PRIORITY_NORMAL,
23726:                                           PR_LOCAL_THREAD,
25472:                                           PR_JOINABLE_THREAD,
23726:                                           0);
23726:         if (!gWatchdogThread) {
25472:             PR_Unlock(gWatchdogLock);
25472:             return false;
25472:         }
25472:     } else if (!gWatchdogHasTimeout || IsBefore(timeout, gWatchdogTimeout)) {
25087:          PR_NotifyCondVar(gWatchdogWakeup);
25472:     }
25472:     gWatchdogHasTimeout = true;
25472:     gWatchdogTimeout = timeout;
25472:     PR_Unlock(gWatchdogLock);
25472:     return true;
25472: }
25472: 
25472: #else /* !JS_THREADSAFE */
25087: 
25087: #ifdef XP_WIN
25087: static HANDLE gTimerHandle = 0;
25087: 
25472: VOID CALLBACK
25472: TimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
25087: {
25479:     CancelExecution((JSRuntime *) lpParameter);
25472: }
25472: 
25472: #else
25472: 
25472: static void
25472: AlarmHandler(int sig)
25472: {
25472:     CancelExecution(gRuntime);
25472: }
25472: 
25087: #endif
25087: 
25472: static bool
25472: InitWatchdog(JSRuntime *rt)
25087: {
25472:     gRuntime = rt;
25472:     return true;
25472: }
25472: 
25472: static void
25472: KillWatchdog()
25472: {
25472:     ScheduleWatchdog(gRuntime, -1);
25472: }
25472: 
25472: static bool
90955: ScheduleWatchdog(JSRuntime *rt, double t)
25472: {
25087: #ifdef XP_WIN
25472:     if (gTimerHandle) {
25472:         DeleteTimerQueueTimer(NULL, gTimerHandle, NULL);
25472:         gTimerHandle = 0;
25472:     }
25472:     if (t > 0 &&
25472:         !CreateTimerQueueTimer(&gTimerHandle,
25087:                                NULL,
25087:                                (WAITORTIMERCALLBACK)TimerCallback,
25472:                                rt,
25472:                                DWORD(ceil(t * 1000.0)),
25472:                                0,
25472:                                WT_EXECUTEINTIMERTHREAD | WT_EXECUTEONLYONCE)) {
25472:         gTimerHandle = 0;
25472:         return false;
25472:     }
25087: #else
25472:     /* FIXME: use setitimer when available for sub-second resolution. */
25472:     if (t <= 0) {
25087:         alarm(0);
25087:         signal(SIGALRM, NULL);
25472:     } else {
25472:         signal(SIGALRM, AlarmHandler); /* set the Alarm signal capture */
25472:         alarm(ceil(t));
25472:     }
25087: #endif
25472:     return true;
25472: }
25472: 
25472: #endif /* !JS_THREADSAFE */
25472: 
25472: static void
25472: CancelExecution(JSRuntime *rt)
25472: {
25472:     gCanceled = true;
25472:     if (gExitCode == 0)
25472:         gExitCode = EXITCODE_TIMEOUT;
40801: #ifdef JS_THREADSAFE
55619:     if (gWorkerThreadPool)
81562:         js::workers::terminateAll(gWorkerThreadPool);
40801: #endif
91846:     JS_TriggerOperationCallback(rt);
25472: 
25472:     static const char msg[] = "Script runs for too long, terminating.\n";
25472: #if defined(XP_UNIX) && !defined(JS_THREADSAFE)
25472:     /* It is not safe to call fputs from signals. */
40249:     /* Dummy assignment avoids GCC warning on "attribute warn_unused_result" */
40249:     ssize_t dummy = write(2, msg, sizeof(msg) - 1);
40249:     (void)dummy;
25472: #else
25472:     fputs(msg, stderr);
25472: #endif
25472: }
23457: 
23457: static JSBool
90955: SetTimeoutValue(JSContext *cx, double t)
23457: {
23457:     /* NB: The next condition also filter out NaNs. */
25472:     if (!(t <= MAX_TIMEOUT_INTERVAL)) {
23726:         JS_ReportError(cx, "Excessive timeout value");
23457:         return JS_FALSE;
23457:     }
25472:     gTimeoutInterval = t;
25472:     if (!ScheduleWatchdog(cx->runtime, t)) {
25472:         JS_ReportError(cx, "Failed to create the watchdog");
23726:         return JS_FALSE;
23726:     }
23457:     return JS_TRUE;
23457: }
23457: 
23457: static JSBool
91237: Timeout(JSContext *cx, unsigned argc, jsval *vp)
23457: {
25087:     if (argc == 0)
25472:         return JS_NewNumberValue(cx, gTimeoutInterval, vp);
23457: 
23457:     if (argc > 1) {
23457:         JS_ReportError(cx, "Wrong number of arguments");
23457:         return JS_FALSE;
23457:     }
23457: 
90955:     double t;
23457:     if (!JS_ValueToNumber(cx, JS_ARGV(cx, vp)[0], &t))
23457:         return JS_FALSE;
23457: 
23457:     *vp = JSVAL_VOID;
23457:     return SetTimeoutValue(cx, t);
23457: }
23126: 
25087: static JSBool
91237: Elapsed(JSContext *cx, unsigned argc, jsval *vp)
25087: {
25087:     if (argc == 0) {
25087:         double d = 0.0;
25087:         JSShellContextData *data = GetContextData(cx);
25087:         if (data)
25087:             d = js_IntervalNow() - data->startTime;
25087:         return JS_NewNumberValue(cx, d, vp);
25087:     }
25087:     JS_ReportError(cx, "Wrong number of arguments");
25087:     return JS_FALSE;
25087: }
25087: 
41968: static JSBool
91237: Parent(JSContext *cx, unsigned argc, jsval *vp)
41968: {
41968:     if (argc != 1) {
41968:         JS_ReportError(cx, "Wrong number of arguments");
41968:         return JS_FALSE;
41968:     }
41968: 
41968:     jsval v = JS_ARGV(cx, vp)[0];
41968:     if (JSVAL_IS_PRIMITIVE(v)) {
41968:         JS_ReportError(cx, "Only objects have parents!");
41968:         return JS_FALSE;
41968:     }
41968: 
89826:     JSObject *parent = JS_GetParent(JSVAL_TO_OBJECT(v));
41974:     *vp = OBJECT_TO_JSVAL(parent);
41973: 
41973:     /* Outerize if necessary.  Embrace the ugliness! */
42728:     if (parent) {
48622:         if (JSObjectOp op = parent->getClass()->ext.outerObject)
48622:             *vp = OBJECT_TO_JSVAL(op(cx, parent));
42728:     }
41973: 
41968:     return JS_TRUE;
41968: }
41968: 
24148: #ifdef XP_UNIX
24148: 
24148: #include <fcntl.h>
24148: #include <sys/stat.h>
24148: 
24148: /*
24148:  * Returns a JS_malloc'd string (that the caller needs to JS_free)
24148:  * containing the directory (non-leaf) part of |from| prepended to |leaf|.
24148:  * If |from| is empty or a leaf, MakeAbsolutePathname returns a copy of leaf.
24148:  * Returns NULL to indicate an error.
24148:  */
24148: static char *
24148: MakeAbsolutePathname(JSContext *cx, const char *from, const char *leaf)
24148: {
24148:     size_t dirlen;
24148:     char *dir;
24148:     const char *slash = NULL, *cp;
24148: 
77652:     if (*leaf == '/') {
77652:         /* We were given an absolute pathname. */
77652:         return JS_strdup(cx, leaf);
77652:     }
77652: 
24148:     cp = from;
24148:     while (*cp) {
24148:         if (*cp == '/') {
24148:             slash = cp;
24148:         }
24148: 
24148:         ++cp;
24148:     }
24148: 
24148:     if (!slash) {
24148:         /* We were given a leaf or |from| was empty. */
24148:         return JS_strdup(cx, leaf);
24148:     }
24148: 
24148:     /* Else, we were given a real pathname, return that + the leaf. */
24148:     dirlen = slash - from + 1;
24148:     dir = (char*) JS_malloc(cx, dirlen + strlen(leaf) + 1);
24148:     if (!dir)
24148:         return NULL;
24148: 
24148:     strncpy(dir, from, dirlen);
24148:     strcpy(dir + dirlen, leaf); /* Note: we can't use strcat here. */
24148: 
24148:     return dir;
24148: }
24148: 
24148: #endif // XP_UNIX
24148: 
24148: static JSBool
91237: Compile(JSContext *cx, unsigned argc, jsval *vp)
39934: {
39934:     if (argc < 1) {
39934:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
39934:                              "compile", "0", "s");
39934:         return JS_FALSE;
39934:     }
39934:     jsval arg0 = JS_ARGV(cx, vp)[0];
39934:     if (!JSVAL_IS_STRING(arg0)) {
39934:         const char *typeName = JS_GetTypeName(cx, JS_TypeOfValue(cx, arg0));
39934:         JS_ReportError(cx, "expected string to compile, got %s", typeName);
39934:         return JS_FALSE;
39934:     }
39934: 
71368:     static JSClass dummy_class = {
71368:         "jdummy",
71368:         JSCLASS_GLOBAL_FLAGS,
71368:         JS_PropertyStub,  JS_PropertyStub,
71368:         JS_PropertyStub,  JS_StrictPropertyStub,
71368:         JS_EnumerateStub, JS_ResolveStub,
93519:         JS_ConvertStub
71368:     };
71368: 
71368:     JSObject *fakeGlobal = JS_NewGlobalObject(cx, &dummy_class);
71368:     if (!fakeGlobal)
71368:         return JS_FALSE;
71368: 
39934:     JSString *scriptContents = JSVAL_TO_STRING(arg0);
71368: 
91237:     unsigned oldopts = JS_GetOptions(cx);
71368:     JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO | JSOPTION_NO_SCRIPT_RVAL);
71368:     bool ok = JS_CompileUCScript(cx, fakeGlobal, JS_GetStringCharsZ(cx, scriptContents),
71368:                                  JS_GetStringLength(scriptContents), "<string>", 0);
71368:     JS_SetOptions(cx, oldopts);
39934: 
39934:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
71368:     return ok;
39934: }
39934: 
39934: static JSBool
91237: Parse(JSContext *cx, unsigned argc, jsval *vp)
41091: {
41091:     if (argc < 1) {
41091:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
41091:                              "compile", "0", "s");
41091:         return JS_FALSE;
41091:     }
41091:     jsval arg0 = JS_ARGV(cx, vp)[0];
41091:     if (!JSVAL_IS_STRING(arg0)) {
41091:         const char *typeName = JS_GetTypeName(cx, JS_TypeOfValue(cx, arg0));
41091:         JS_ReportError(cx, "expected string to parse, got %s", typeName);
41091:         return JS_FALSE;
41091:     }
41091: 
41091:     JSString *scriptContents = JSVAL_TO_STRING(arg0);
41091:     js::Parser parser(cx);
41091:     parser.init(JS_GetStringCharsZ(cx, scriptContents), JS_GetStringLength(scriptContents),
61450:                 "<string>", 0, cx->findVersion());
89749:     ParseNode *pn = parser.parse(NULL);
89749:     if (!pn)
41869:         return JS_FALSE;
89749: #ifdef DEBUG
89749:     DumpParseTree(pn);
89749: #endif
41091:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
41091:     return JS_TRUE;
41091: }
41091: 
69649: struct FreeOnReturn {
69649:     JSContext *cx;
69649:     const char *ptr;
69649:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
69649: 
77659:     FreeOnReturn(JSContext *cx, const char *ptr = NULL JS_GUARD_OBJECT_NOTIFIER_PARAM)
69649:       : cx(cx), ptr(ptr) {
69649:         JS_GUARD_OBJECT_NOTIFIER_INIT;
69649:     }
69649: 
77659:     void init(const char *ptr) {
77659:         JS_ASSERT(!this->ptr);
77659:         this->ptr = ptr;
77659:     }
77659: 
69649:     ~FreeOnReturn() {
69649:         JS_free(cx, (void*)ptr);
69649:     }
69649: };
69649: 
41091: static JSBool
91237: Snarf(JSContext *cx, unsigned argc, jsval *vp)
24148: {
24148:     JSString *str;
24148: 
53557:     if (!argc)
53557:         return JS_FALSE;
53557: 
53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
24148:     if (!str)
24148:         return JS_FALSE;
57812:     JSAutoByteString filename(cx, str);
57812:     if (!filename)
57812:         return JS_FALSE;
24148: 
24148:     /* Get the currently executing script's name. */
92133:     JSScript *script = GetTopScript(cx);
92133:     JS_ASSERT(script->filename);
77659:     const char *pathname = filename.ptr();
24148: #ifdef XP_UNIX
77659:     FreeOnReturn pnGuard(cx);
77659:     if (pathname[0] != '/') {
77659:         pathname = MakeAbsolutePathname(cx, script->filename, pathname);
24148:         if (!pathname)
24148:             return JS_FALSE;
77659:         pnGuard.init(pathname);
77659:     }
24148: #endif
24148: 
69649:     if (argc > 1) {
69649:         JSString *opt = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);
69649:         if (!opt)
24148:             return JS_FALSE;
69649:         JSBool match;
69649:         if (!JS_StringEqualsAscii(cx, opt, "binary", &match))
69649:             return JS_FALSE;
69649:         if (match) {
69649:             JSObject *obj;
69649:             if (!(obj = FileAsTypedArray(cx, pathname)))
69649:                 return JS_FALSE;
69649:             *vp = OBJECT_TO_JSVAL(obj);
69649:             return JS_TRUE;
69649:         }
69649:     }
69649: 
69649:     if (!(str = FileAsString(cx, pathname)))
69649:         return JS_FALSE;
53557:     *vp = STRING_TO_JSVAL(str);
24148:     return JS_TRUE;
24148: }
24148: 
42733: JSBool
91237: Wrap(JSContext *cx, unsigned argc, jsval *vp)
42733: {
42733:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
42733:     if (JSVAL_IS_PRIMITIVE(v)) {
42733:         JS_SET_RVAL(cx, vp, v);
42733:         return true;
42733:     }
42733: 
47498:     JSObject *obj = JSVAL_TO_OBJECT(v);
86483:     JSObject *wrapped = Wrapper::New(cx, obj, obj->getProto(), &obj->global(),
79386:                                      &Wrapper::singleton);
42733:     if (!wrapped)
42733:         return false;
42733: 
42733:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(wrapped));
42733:     return true;
42733: }
42733: 
54863: JSBool
91237: Serialize(JSContext *cx, unsigned argc, jsval *vp)
54863: {
54863:     jsval v = argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID;
84755:     uint64_t *datap;
54863:     size_t nbytes;
60105:     if (!JS_WriteStructuredClone(cx, v, &datap, &nbytes, NULL, NULL))
54863:         return false;
54863: 
95834:     JSObject *array = JS_NewUint8Array(cx, nbytes);
95834:     if (!array) {
54863:         JS_free(cx, datap);
54863:         return false;
54863:     }
74875:     JS_ASSERT((uintptr_t(TypedArray::getDataOffset(array)) & 7) == 0);
87623:     js_memcpy(TypedArray::getDataOffset(array), datap, nbytes);
54863:     JS_free(cx, datap);
95834:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(array));
54863:     return true;
54863: }
54863: 
54863: JSBool
91237: Deserialize(JSContext *cx, unsigned argc, jsval *vp)
54863: {
97353:     RootedVar<jsval> v(cx, argc > 0 ? JS_ARGV(cx, vp)[0] : JSVAL_VOID);
54863:     JSObject *obj;
95834:     if (JSVAL_IS_PRIMITIVE(v) || !(obj = JSVAL_TO_OBJECT(v))->isTypedArray()) {
54863:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "deserialize");
54863:         return false;
54863:     }
97573:     if ((TypedArray::getByteLength(obj) & 7) != 0) {
60538:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "deserialize");
60538:         return false;
60538:     }
97573:     if ((uintptr_t(TypedArray::getDataOffset(obj)) & 7) != 0) {
54863:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_BAD_ALIGNMENT);
54863:         return false;
54863:     }
54863: 
97573:     if (!JS_ReadStructuredClone(cx, (uint64_t *) TypedArray::getDataOffset(obj), TypedArray::getByteLength(obj),
97353:                                 JS_STRUCTURED_CLONE_VERSION, v.address(), NULL, NULL)) {
54863:         return false;
58294:     }
54863:     JS_SET_RVAL(cx, vp, v);
54863:     return true;
54863: }
54863: 
63096: enum CompartmentKind { SAME_COMPARTMENT, NEW_COMPARTMENT };
63096: 
63096: static JSObject *
63096: NewGlobalObject(JSContext *cx, CompartmentKind compartment);
63096: 
63096: JSBool
91237: NewGlobal(JSContext *cx, unsigned argc, jsval *vp)
63096: {
63096:     if (argc != 1 || !JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
63096:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "newGlobal");
63096:         return false;
63096:     }
63096: 
63096:     JSString *str = JSVAL_TO_STRING(JS_ARGV(cx, vp)[0]);
63096: 
63096:     JSBool equalSame = JS_FALSE, equalNew = JS_FALSE;
63096:     if (!JS_StringEqualsAscii(cx, str, "same-compartment", &equalSame) ||
63096:         !JS_StringEqualsAscii(cx, str, "new-compartment", &equalNew)) {
63096:         return false;
63096:     }
63096: 
63096:     if (!equalSame && !equalNew) {
63096:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "newGlobal");
63096:         return false;
63096:     }
63096: 
63096:     JSObject *global = NewGlobalObject(cx, equalSame ? SAME_COMPARTMENT : NEW_COMPARTMENT);
63096:     if (!global)
63096:         return false;
63096: 
63096:     JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(global));
63096:     return true;
63096: }
63096: 
67934: static JSBool
91237: ParseLegacyJSON(JSContext *cx, unsigned argc, jsval *vp)
67934: {
67934:     if (argc != 1 || !JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
67934:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS, "parseLegacyJSON");
67934:         return false;
67934:     }
67934: 
67934:     JSString *str = JSVAL_TO_STRING(JS_ARGV(cx, vp)[0]);
67934: 
67934:     size_t length;
67934:     const jschar *chars = JS_GetStringCharsAndLength(cx, str, &length);
67934:     if (!chars)
67934:         return false;
78614:     return js::ParseJSONWithReviver(cx, chars, length, js::NullValue(), vp, LEGACY);
67934: }
67934: 
72074: static JSBool
91237: EnableStackWalkingAssertion(JSContext *cx, unsigned argc, jsval *vp)
72074: {
72074:     if (argc == 0 || !JSVAL_IS_BOOLEAN(JS_ARGV(cx, vp)[0])) {
72074:         JS_ReportErrorNumber(cx, my_GetErrorMessage, NULL, JSSMSG_INVALID_ARGS,
72074:                              "enableStackWalkingAssertion");
72074:         return false;
72074:     }
72074: 
72074: #ifdef DEBUG
72074:     cx->stackIterAssertionEnabled = JSVAL_TO_BOOLEAN(JS_ARGV(cx, vp)[0]);
72074: #endif
72074: 
72074:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
72074:     return true;
72074: }
72074: 
73495: static JSBool
91237: GetMaxArgs(JSContext *cx, unsigned arg, jsval *vp)
73495: {
73495:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(StackSpace::ARGS_LENGTH_MAX));
73495:     return JS_TRUE;
73495: }
73495: 
91659: static JSFunctionSpecWithHelp shell_functions[] = {
91659:     JS_FN_HELP("version", Version, 0, 0,
91659: "version([number])",
91659: "  Get or force a script compilation version number."),
91659: 
91659:     JS_FN_HELP("revertVersion", RevertVersion, 0, 0,
91659: "revertVersion()",
91659: "  Revert previously set version number."),
91659: 
91659:     JS_FN_HELP("options", Options, 0, 0,
91659: "options([option ...])",
91659: "  Get or toggle JavaScript options."),
91659: 
91659:     JS_FN_HELP("load", Load, 1, 0,
91659: "load(['foo.js' ...])",
91659: "  Load files named by string arguments."),
91659: 
91659:     JS_FN_HELP("evaluate", Evaluate, 1, 0,
91659: "evaluate(code)",
91659: "  Evaluate code as though it were the contents of a file."),
91659: 
97693:     JS_FN_HELP("evaluateNonCompileAndGo", EvaluateNonCompileAndGo, 1, 0,
97693: "evaluateNonCompileAndGo(code)",
97693: "  Evaluate code like evaluate() but with compile-and-go turned off."),
97693: 
91659:     JS_FN_HELP("evalWithLocation", EvaluateWithLocation, 3, 0,
91659: "evalWithLocation(code, filename, lineno)",
91659: "  Eval code as if loaded from the given filename and line number."),
91659: 
91659:     JS_FN_HELP("run", Run, 1, 0,
91659: "run('foo.js')",
91659: "  Run the file named by the first argument, returning the number of\n"
91659: "  of milliseconds spent compiling and executing it."),
91659: 
91659:     JS_FN_HELP("readline", ReadLine, 0, 0,
91659: "readline()",
91659: "  Read a single line from stdin."),
91659: 
91659:     JS_FN_HELP("print", Print, 0, 0,
91659: "print([exp ...])",
91659: "  Evaluate and print expressions to stdout."),
91659: 
91659:     JS_FN_HELP("printErr", PrintErr, 0, 0,
91659: "printErr([exp ...])",
91659: "  Evaluate and print expressions to stderr."),
91659: 
91659:     JS_FN_HELP("putstr", PutStr, 0, 0,
91659: "putstr([exp])",
91659: "  Evaluate and print expression without newline."),
91659: 
91659:     JS_FN_HELP("dateNow", Now, 0, 0,
91659: "dateNow()",
91659: "  Return the current time with sub-ms precision."),
91659: 
91659:     JS_FN_HELP("help", Help, 0, 0,
91659: "help([name ...])",
91659: "  Display usage and help messages."),
91659: 
91659:     JS_FN_HELP("quit", Quit, 0, 0,
91659: "quit()",
91659: "  Quit the shell."),
91659: 
91659:     JS_FN_HELP("assertEq", AssertEq, 2, 0,
91659: "assertEq(actual, expected[, msg])",
91659: "  Throw if the first two arguments are not the same (both +0 or both -0,\n"
91659: "  both NaN, or non-zero and ===)."),
91659: 
91659:     JS_FN_HELP("assertJit", AssertJit, 0, 0,
91659: "assertJit()",
91659: "  Throw if the calling function failed to JIT."),
91659: 
91659:     JS_FN_HELP("setDebug", SetDebug, 1, 0,
91659: "setDebug(debug)",
91659: "  Set debug mode."),
91659: 
91659:     JS_FN_HELP("setDebuggerHandler", SetDebuggerHandler, 1, 0,
91659: "setDebuggerHandler(f)",
91659: "  Set handler for debugger keyword to f."),
91659: 
91659:     JS_FN_HELP("setThrowHook", SetThrowHook, 1, 0,
91659: "setThrowHook(f)",
91659: "  Set throw hook to f."),
91659: 
91659:     JS_FN_HELP("trap", Trap, 3, 0,
91659: "trap([fun, [pc,]] exp)",
91659: "  Trap bytecode execution."),
91659: 
91659:     JS_FN_HELP("untrap", Untrap, 2, 0,
91659: "untrap(fun[, pc])",
91659: "  Remove a trap."),
91659: 
91659:     JS_FN_HELP("line2pc", LineToPC, 0, 0,
91659: "line2pc([fun,] line)",
91659: "  Map line number to PC."),
91659: 
91659:     JS_FN_HELP("pc2line", PCToLine, 0, 0,
91659: "pc2line(fun[, pc])",
91659: "  Map PC to line number."),
91659: 
91659:     JS_FN_HELP("stringsAreUTF8", StringsAreUTF8, 0, 0,
91659: "stringsAreUTF8()",
91659: "  Check if strings are UTF-8 encoded."),
91659: 
91659:     JS_FN_HELP("testUTF8", TestUTF8, 1, 0,
91659: "testUTF8(mode)",
91659: "  Perform UTF-8 tests (modes are 1 to 4)."),
91659: 
91659:     JS_FN_HELP("throwError", ThrowError, 0, 0,
91659: "throwError()",
91659: "  Throw an error from JS_ReportError."),
91659: 
23126: #ifdef DEBUG
91659:     JS_FN_HELP("disassemble", DisassembleToString, 1, 0,
91659: "disassemble([fun])",
91659: "  Return the disassembly for the given function."),
91659: 
91659:     JS_FN_HELP("dis", Disassemble, 1, 0,
91659: "dis([fun])",
91659: "  Disassemble functions into bytecodes."),
91659: 
91659:     JS_FN_HELP("disfile", DisassFile, 1, 0,
91659: "disfile('foo.js')",
91659: "  Disassemble script file into bytecodes.\n"
91659: "  dis and disfile take these options as preceeding string arguments:\n"
58045: "    \"-r\" (disassemble recursively)\n"
91659: "    \"-l\" (show line numbers)"),
91659: 
91659:     JS_FN_HELP("dissrc", DisassWithSrc, 1, 0,
91659: "dissrc([fun])",
91659: "  Disassemble functions with source lines."),
91659: 
91659:     JS_FN_HELP("dumpHeap", DumpHeap, 0, 0,
91659: "dumpHeap([fileName[, start[, toFind[, maxDepth[, toIgnore]]]]])",
91659: "  Interface to JS_DumpHeap with output sent to file."),
91659: 
91659:     JS_FN_HELP("dumpObject", DumpObject, 1, 0,
91659: "dumpObject()",
91659: "  Dump an internal representation of an object."),
91659: 
91659:     JS_FN_HELP("notes", Notes, 1, 0,
91659: "notes([fun])",
91659: "  Show source notes for functions."),
91659: 
91659:     JS_FN_HELP("findReferences", FindReferences, 1, 0,
91659: "findReferences(target)",
84318: "  Walk the entire heap, looking for references to |target|, and return a\n"
84318: "  \"references object\" describing what we found.\n"
84318: "\n"
84318: "  Each property of the references object describes one kind of reference. The\n"
84318: "  property's name is the label supplied to MarkObject, JS_CALL_TRACER, or what\n"
84318: "  have you, prefixed with \"edge: \" to avoid collisions with system properties\n"
84318: "  (like \"toString\" and \"__proto__\"). The property's value is an array of things\n"
84318: "  that refer to |thing| via that kind of reference. Ordinary references from\n"
84318: "  one object to another are named after the property name (with the \"edge: \"\n"
84318: "  prefix).\n"
84318: "\n"
84318: "  Garbage collection roots appear as references from 'null'. We use the name\n"
84318: "  given to the root (with the \"edge: \" prefix) as the name of the reference.\n"
84318: "\n"
84318: "  Note that the references object does record references from objects that are\n"
84318: "  only reachable via |thing| itself, not just the references reachable\n"
84318: "  themselves from roots that keep |thing| from being collected. (We could make\n"
84318: "  this distinction if it is useful.)\n"
84318: "\n"
84318: "  If any references are found by the conservative scanner, the references\n"
84318: "  object will have a property named \"edge: machine stack\"; the referrers will\n"
91659: "  be 'null', because they are roots."),
91659: 
23126: #endif
91659:     JS_FN_HELP("dumpStack", DumpStack, 1, 0,
91659: "dumpStack()",
91659: "  Dump the stack as an array of callees (youngest first)."),
91659: 
23126: #ifdef TEST_CVTARGS
91659:     JS_FN_HELP("cvtargs", ConvertArgs, 0, 0,
91659: "cvtargs(arg1..., arg12)",
91659: "  Test argument formatter."),
91659: 
23126: #endif
91659:     JS_FN_HELP("build", BuildDate, 0, 0,
91659: "build()",
91659: "  Show build date and time."),
91659: 
91659:     JS_FN_HELP("intern", Intern, 1, 0,
91659: "intern(str)",
91659: "  Internalize str in the atom table."),
91659: 
91659:     JS_FN_HELP("clone", Clone, 1, 0,
91659: "clone(fun[, scope])",
91659: "  Clone function object."),
91659: 
91659:     JS_FN_HELP("getpda", GetPDA, 1, 0,
91659: "getpda(obj)",
91659: "  Get the property descriptors for obj."),
91659: 
91659:     JS_FN_HELP("getslx", GetSLX, 1, 0,
91659: "getslx(obj)",
91659: "  Get script line extent."),
91659: 
91659:     JS_FN_HELP("toint32", ToInt32, 1, 0,
91659: "toint32(n)",
91659: "  Testing hook for JS_ValueToInt32."),
91659: 
91659:     JS_FN_HELP("evalcx", EvalInContext, 1, 0,
91659: "evalcx(s[, o])",
91659: "  Evaluate s in optional sandbox object o.\n"
23126: "  if (s == '' && !o) return new o with eager standard classes\n"
91659: "  if (s == 'lazy' && !o) return new o with lazy standard classes"),
91659: 
91659:     JS_FN_HELP("evalInFrame", EvalInFrame, 2, 0,
91659: "evalInFrame(n,str,save)",
91659: "  Evaluate 'str' in the nth up frame.\n"
91659: "  If 'save' (default false), save the frame chain."),
91659: 
91659:     JS_FN_HELP("shapeOf", ShapeOf, 1, 0,
91659: "shapeOf(obj)",
91659: "  Get the shape of obj (an implementation detail)."),
91659: 
91659:     JS_FN_HELP("resolver", Resolver, 1, 0,
91659: "resolver(src[, proto])",
91659: "  Create object with resolve hook that copies properties\n"
91659: "  from src. If proto is omitted, use Object.prototype."),
91659: 
59233: #ifdef DEBUG
91659:     JS_FN_HELP("arrayInfo", js_ArrayInfo, 1, 0,
91659: "arrayInfo(a1, a2, ...)",
91659: "  Report statistics about arrays."),
91659: 
23126: #endif
23126: #ifdef JS_THREADSAFE
91659:     JS_FN_HELP("sleep", Sleep_fn, 1, 0,
91659: "sleep(dt)",
91659: "  Sleep for dt seconds."),
91659: 
23126: #endif
91659:     JS_FN_HELP("snarf", Snarf, 0, 0,
91659: "snarf(filename)",
91659: "  Read filename into returned string."),
91659: 
91659:     JS_FN_HELP("read", Snarf, 0, 0,
91659: "read(filename)",
91659: "  Synonym for snarf."),
91659: 
91659:     JS_FN_HELP("compile", Compile, 1, 0,
91659: "compile(code)",
91659: "  Compiles a string to bytecode, potentially throwing."),
91659: 
91659:     JS_FN_HELP("parse", Parse, 1, 0,
91659: "parse(code)",
91659: "  Parses a string, potentially throwing."),
91659: 
91659:     JS_FN_HELP("timeout", Timeout, 1, 0,
91659: "timeout([seconds])",
23457: "  Get/Set the limit in seconds for the execution time for the current context.\n"
91659: "  A negative value (default) means that the execution time is unlimited."),
91659: 
91659:     JS_FN_HELP("elapsed", Elapsed, 0, 0,
91659: "elapsed()",
93423: "  Execution time elapsed for the current context."),
91659: 
91659:     JS_FN_HELP("parent", Parent, 1, 0,
91659: "parent(obj)",
93423: "  Returns the parent of obj."),
91659: 
91659:     JS_FN_HELP("wrap", Wrap, 1, 0,
91659: "wrap(obj)",
93423: "  Wrap an object into a noop wrapper."),
91659: 
91659:     JS_FN_HELP("serialize", Serialize, 1, 0,
91659: "serialize(sd)",
93423: "  Serialize sd using JS_WriteStructuredClone. Returns a TypedArray."),
91659: 
91659:     JS_FN_HELP("deserialize", Deserialize, 1, 0,
91659: "deserialize(a)",
93423: "  Deserialize data generated by serialize."),
91659: 
91659:     JS_FN_HELP("newGlobal", NewGlobal, 1, 0,
91659: "newGlobal(kind)",
91659: "  Return a new global object, in the current\n"
63096: "  compartment if kind === 'same-compartment' or in a\n"
91659: "  new compartment if kind === 'new-compartment'."),
91659: 
91659:     JS_FN_HELP("parseLegacyJSON", ParseLegacyJSON, 1, 0,
91659: "parseLegacyJSON(str)",
91659: "  Parse str as legacy JSON, returning the result if the\n"
91659: "  parse succeeded and throwing a SyntaxError if not."),
91659: 
91659:     JS_FN_HELP("enableStackWalkingAssertion", EnableStackWalkingAssertion, 1, 0,
91659: "enableStackWalkingAssertion(enabled)",
72074: "  Enables or disables a particularly expensive assertion in stack-walking\n"
72074: "  code.  If your test isn't ridiculously thorough, such that performing this\n"
72074: "  assertion increases test duration by an order of magnitude, you shouldn't\n"
91659: "  use this."),
91659: 
91659:     JS_FN_HELP("getMaxArgs", GetMaxArgs, 0, 0,
91659: "getMaxArgs()",
91659: "  Return the maximum number of supported args for a call."),
91659: 
91659:     JS_FS_END
23126: };
63096: #ifdef MOZ_PROFILING
76358: # define PROFILING_FUNCTION_COUNT 5
76358: # ifdef MOZ_CALLGRIND
76358: #  define CALLGRIND_FUNCTION_COUNT 3
63096: # else
76358: #  define CALLGRIND_FUNCTION_COUNT 0
63096: # endif
76358: # ifdef MOZ_VTUNE
76358: #  define VTUNE_FUNCTION_COUNT 4
76358: # else
76358: #  define VTUNE_FUNCTION_COUNT 0
76358: # endif
76358: # define EXTERNAL_FUNCTION_COUNT (PROFILING_FUNCTION_COUNT + CALLGRIND_FUNCTION_COUNT + VTUNE_FUNCTION_COUNT)
76358: #else
76358: # define EXTERNAL_FUNCTION_COUNT 0
76358: #endif
63096: 
64263: #undef PROFILING_FUNCTION_COUNT
76358: #undef CALLGRIND_FUNCTION_COUNT
76358: #undef VTUNE_FUNCTION_COUNT
76358: #undef EXTERNAL_FUNCTION_COUNT
64263: 
91659: static bool
91659: PrintHelpString(JSContext *cx, jsval v)
91659: {
91659:     JSString *str = JSVAL_TO_STRING(v);
91659:     JS::Anchor<JSString *> a_str(str);
91659:     const jschar *chars = JS_GetStringCharsZ(cx, str);
91659:     if (!chars)
91659:         return false;
91659: 
91659:     for (const jschar *p = chars; *p; p++)
91659:         fprintf(gOutFile, "%c", char(*p));
91659: 
91659:     fprintf(gOutFile, "\n");
91659: 
91659:     return true;
91659: }
91659: 
91659: static bool
91659: PrintHelp(JSContext *cx, JSObject *obj)
91659: {
91659:     jsval usage, help;
91659:     if (!JS_LookupProperty(cx, obj, "usage", &usage))
91659:         return false;
91659:     if (!JS_LookupProperty(cx, obj, "help", &help))
91659:         return false;
91659: 
91659:     if (JSVAL_IS_VOID(usage) || JSVAL_IS_VOID(help))
91659:         return true;
91659: 
91659:     return PrintHelpString(cx, usage) && PrintHelpString(cx, help);
91659: }
91659: 
23126: static JSBool
91237: Help(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     fprintf(gOutFile, "%s\n", JS_GetImplementationVersion());
91659: 
23126:     if (argc == 0) {
91659:         JSObject *global = JS_GetGlobalObject(cx);
91659:         AutoIdArray ida(cx, JS_Enumerate(cx, global));
91659:         if (!ida)
91659:             return false;
91659: 
91659:         for (size_t i = 0; i < ida.length(); i++) {
91659:             jsval v;
91659:             if (!JS_LookupPropertyById(cx, global, ida[i], &v))
91659:                 return false;
91659:             if (JSVAL_IS_OBJECT(v) && !PrintHelp(cx, JSVAL_TO_OBJECT(v)))
91659:                 return false;
91659:         }
23126:     } else {
53557:         jsval *argv = JS_ARGV(cx, vp);
91659:         for (unsigned i = 0; i < argc; i++) {
91659:             if (JSVAL_IS_OBJECT(argv[i]) && !PrintHelp(cx, JSVAL_TO_OBJECT(argv[i])))
91659:                 return false;
91659:         }
91659:     }
91659: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
91659:     return true;
23126: }
23126: 
23126: /*
23126:  * Define a JS object called "it".  Give it class operations that printf why
23126:  * they're being called for tutorial purposes.
23126:  */
23126: enum its_tinyid {
26666:     ITS_COLOR, ITS_HEIGHT, ITS_WIDTH, ITS_FUNNY, ITS_ARRAY, ITS_RDONLY,
26666:     ITS_CUSTOM, ITS_CUSTOMRDONLY
23126: };
23126: 
26666: static JSBool
82113: its_getter(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
26666: 
26666: static JSBool
82113: its_setter(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp);
26666: 
23126: static JSPropertySpec its_props[] = {
23126:     {"color",           ITS_COLOR,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"height",          ITS_HEIGHT,     JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"width",           ITS_WIDTH,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"funny",           ITS_FUNNY,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"array",           ITS_ARRAY,      JSPROP_ENUMERATE,       NULL, NULL},
23126:     {"rdonly",          ITS_RDONLY,     JSPROP_READONLY,        NULL, NULL},
26666:     {"custom",          ITS_CUSTOM,     JSPROP_ENUMERATE,
26666:                         its_getter,     its_setter},
26666:     {"customRdOnly",    ITS_CUSTOMRDONLY, JSPROP_ENUMERATE | JSPROP_READONLY,
26666:                         its_getter,     its_setter},
23126:     {NULL,0,0,NULL,NULL}
23126: };
23126: 
23126: static JSBool its_noisy;    /* whether to be noisy when finalizing it */
23126: static JSBool its_enum_fail;/* whether to fail when enumerating it */
23126: 
23126: static JSBool
48470: its_addProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
67930:     IdStringifier idString(cx, id);
31366:     fprintf(gOutFile, "adding its property %s,", idString.getBytes());
84160:     ToStringHelper valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_delProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
67930:     IdStringifier idString(cx, id);
31366:     fprintf(gOutFile, "deleting its property %s,", idString.getBytes());
84160:     ToStringHelper valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
48470: its_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
23126: {
31366:     if (!its_noisy)
31366:         return JS_TRUE;
31366: 
67930:     IdStringifier idString(cx, id);
31366:     fprintf(gOutFile, "getting its property %s,", idString.getBytes());
84160:     ToStringHelper valueString(cx, *vp);
31366:     fprintf(gOutFile, " initial value %s\n", valueString.getBytes());
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
62395: its_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
23126: {
67930:     IdStringifier idString(cx, id);
23126:     if (its_noisy) {
31366:         fprintf(gOutFile, "setting its property %s,", idString.getBytes());
84160:         ToStringHelper valueString(cx, *vp);
31366:         fprintf(gOutFile, " new value %s\n", valueString.getBytes());
23126:     }
23126: 
48470:     if (!JSID_IS_ATOM(id))
23126:         return JS_TRUE;
23126: 
31366:     if (!strcmp(idString.getBytes(), "noisy"))
30581:         JS_ValueToBoolean(cx, *vp, &its_noisy);
31366:     else if (!strcmp(idString.getBytes(), "enum_fail"))
30581:         JS_ValueToBoolean(cx, *vp, &its_enum_fail);
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: /*
23126:  * Its enumerator, implemented using the "new" enumerate API,
23126:  * see class flags.
23126:  */
23126: static JSBool
23126: its_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
23126:               jsval *statep, jsid *idp)
23126: {
23126:     JSObject *iterator;
23126: 
23126:     switch (enum_op) {
23126:       case JSENUMERATE_INIT:
47569:       case JSENUMERATE_INIT_ALL:
23126:         if (its_noisy)
23126:             fprintf(gOutFile, "enumerate its properties\n");
23126: 
23126:         iterator = JS_NewPropertyIterator(cx, obj);
23126:         if (!iterator)
23126:             return JS_FALSE;
23126: 
23126:         *statep = OBJECT_TO_JSVAL(iterator);
23126:         if (idp)
48470:             *idp = INT_TO_JSID(0);
23126:         break;
23126: 
23126:       case JSENUMERATE_NEXT:
23126:         if (its_enum_fail) {
23126:             JS_ReportError(cx, "its enumeration failed");
23126:             return JS_FALSE;
23126:         }
23126: 
23126:         iterator = (JSObject *) JSVAL_TO_OBJECT(*statep);
23126:         if (!JS_NextProperty(cx, iterator, idp))
23126:             return JS_FALSE;
23126: 
48470:         if (!JSID_IS_VOID(*idp))
23126:             break;
23126:         /* Fall through. */
23126: 
23126:       case JSENUMERATE_DESTROY:
23126:         /* Allow our iterator object to be GC'd. */
23126:         *statep = JSVAL_NULL;
23126:         break;
23126:     }
23126: 
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: its_resolve(JSContext *cx, JSObject *obj, jsid id, unsigned flags,
23126:             JSObject **objp)
23126: {
23126:     if (its_noisy) {
67930:         IdStringifier idString(cx, id);
23126:         fprintf(gOutFile, "resolving its property %s, flags {%s,%s,%s}\n",
31366:                idString.getBytes(),
23126:                (flags & JSRESOLVE_QUALIFIED) ? "qualified" : "",
23126:                (flags & JSRESOLVE_ASSIGNING) ? "assigning" : "",
23126:                (flags & JSRESOLVE_DETECTING) ? "detecting" : "");
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: its_convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
23126: {
23126:     if (its_noisy)
23126:         fprintf(gOutFile, "converting it to %s type\n", JS_GetTypeName(cx, type));
74435:     return JS_ConvertStub(cx, obj, type, vp);
23126: }
23126: 
23126: static void
94738: its_finalize(JSFreeOp *fop, JSObject *obj)
23126: {
26666:     jsval *rootedVal;
23126:     if (its_noisy)
23126:         fprintf(gOutFile, "finalizing it\n");
89826:     rootedVal = (jsval *) JS_GetPrivate(obj);
26666:     if (rootedVal) {
94739:         JS_RemoveValueRootRT(fop->runtime(), rootedVal);
89826:         JS_SetPrivate(obj, NULL);
26666:         delete rootedVal;
26666:     }
23126: }
23126: 
23126: static JSClass its_class = {
26666:     "It", JSCLASS_NEW_RESOLVE | JSCLASS_NEW_ENUMERATE | JSCLASS_HAS_PRIVATE,
23126:     its_addProperty,  its_delProperty,  its_getProperty,  its_setProperty,
23126:     (JSEnumerateOp)its_enumerate, (JSResolveOp)its_resolve,
93519:     its_convert,      its_finalize
23126: };
23126: 
82113: static JSBool
82113: its_getter(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
82113: {
89430:     if (JS_GetClass(obj) == &its_class) {
89826:         jsval *val = (jsval *) JS_GetPrivate(obj);
82113:         *vp = val ? *val : JSVAL_VOID;
82113:     } else {
82113:         *vp = JSVAL_VOID;
82113:     }
82113: 
82113:     return JS_TRUE;
82113: }
82113: 
82113: static JSBool
82113: its_setter(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
82113: {
89430:     if (JS_GetClass(obj) != &its_class)
82113:         return JS_TRUE;
82113: 
89826:     jsval *val = (jsval *) JS_GetPrivate(obj);
82113:     if (val) {
82113:         *val = *vp;
82113:         return JS_TRUE;
82113:     }
82113: 
82113:     val = new jsval;
82113:     if (!val) {
82113:         JS_ReportOutOfMemory(cx);
82113:         return JS_FALSE;
82113:     }
82113: 
82113:     if (!JS_AddValueRoot(cx, val)) {
82113:         delete val;
82113:         return JS_FALSE;
82113:     }
82113: 
89826:     JS_SetPrivate(obj, (void*)val);
82113: 
82113:     *val = *vp;
82113:     return JS_TRUE;
82113: }
82113: 
86225: JSErrorFormatString jsShell_ErrorFormatString[JSShellErr_Limit] = {
23126: #define MSG_DEF(name, number, count, exception, format) \
23126:     { format, count, JSEXN_ERR } ,
23126: #include "jsshell.msg"
23126: #undef MSG_DEF
23126: };
23126: 
23126: static const JSErrorFormatString *
91237: my_GetErrorMessage(void *userRef, const char *locale, const unsigned errorNumber)
23126: {
86225:     if (errorNumber == 0 || errorNumber >= JSShellErr_Limit)
86225:         return NULL;
86225: 
23126:     return &jsShell_ErrorFormatString[errorNumber];
23126: }
23126: 
23126: static void
23126: my_ErrorReporter(JSContext *cx, const char *message, JSErrorReport *report)
23126: {
23126:     int i, j, k, n;
23126:     char *prefix, *tmp;
23126:     const char *ctmp;
23126: 
23126:     if (!report) {
23126:         fprintf(gErrFile, "%s\n", message);
77854:         fflush(gErrFile);
23126:         return;
23126:     }
23126: 
23126:     /* Conditionally ignore reported warnings. */
23126:     if (JSREPORT_IS_WARNING(report->flags) && !reportWarnings)
23126:         return;
23126: 
23126:     prefix = NULL;
23126:     if (report->filename)
23126:         prefix = JS_smprintf("%s:", report->filename);
23126:     if (report->lineno) {
23126:         tmp = prefix;
23126:         prefix = JS_smprintf("%s%u: ", tmp ? tmp : "", report->lineno);
23126:         JS_free(cx, tmp);
23126:     }
23126:     if (JSREPORT_IS_WARNING(report->flags)) {
23126:         tmp = prefix;
23126:         prefix = JS_smprintf("%s%swarning: ",
23126:                              tmp ? tmp : "",
23126:                              JSREPORT_IS_STRICT(report->flags) ? "strict " : "");
23126:         JS_free(cx, tmp);
23126:     }
23126: 
23126:     /* embedded newlines -- argh! */
23126:     while ((ctmp = strchr(message, '\n')) != 0) {
23126:         ctmp++;
23126:         if (prefix)
23126:             fputs(prefix, gErrFile);
23126:         fwrite(message, 1, ctmp - message, gErrFile);
23126:         message = ctmp;
23126:     }
23126: 
23126:     /* If there were no filename or lineno, the prefix might be empty */
23126:     if (prefix)
23126:         fputs(prefix, gErrFile);
23126:     fputs(message, gErrFile);
23126: 
23126:     if (!report->linebuf) {
23126:         fputc('\n', gErrFile);
23126:         goto out;
23126:     }
23126: 
23126:     /* report->linebuf usually ends with a newline. */
23126:     n = strlen(report->linebuf);
23126:     fprintf(gErrFile, ":\n%s%s%s%s",
23126:             prefix,
23126:             report->linebuf,
23126:             (n > 0 && report->linebuf[n-1] == '\n') ? "" : "\n",
23126:             prefix);
25144:     n = report->tokenptr - report->linebuf;
23126:     for (i = j = 0; i < n; i++) {
23126:         if (report->linebuf[i] == '\t') {
23126:             for (k = (j + 8) & ~7; j < k; j++) {
23126:                 fputc('.', gErrFile);
23126:             }
23126:             continue;
23126:         }
23126:         fputc('.', gErrFile);
23126:         j++;
23126:     }
23126:     fputs("^\n", gErrFile);
23126:  out:
77854:     fflush(gErrFile);
23126:     if (!JSREPORT_IS_WARNING(report->flags)) {
23126:         if (report->errorNumber == JSMSG_OUT_OF_MEMORY) {
23126:             gExitCode = EXITCODE_OUT_OF_MEMORY;
23126:         } else {
23126:             gExitCode = EXITCODE_RUNTIME_ERROR;
23126:         }
23126:     }
23126:     JS_free(cx, prefix);
23126: }
23126: 
23126: #if defined(SHELL_HACK) && defined(DEBUG) && defined(XP_UNIX)
23126: static JSBool
91237: Exec(JSContext *cx, unsigned argc, jsval *vp)
23126: {
23126:     JSFunction *fun;
23126:     const char *name, **nargv;
91237:     unsigned i, nargc;
23126:     JSString *str;
57812:     bool ok;
23126:     pid_t pid;
23126:     int status;
23126: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
53557: 
53557:     fun = JS_ValueToFunction(cx, vp[0]);
23126:     if (!fun)
23126:         return JS_FALSE;
23126:     if (!fun->atom)
23126:         return JS_TRUE;
57812: 
23126:     nargc = 1 + argc;
57812: 
57812:     /* nargc + 1 accounts for the terminating NULL. */
57812:     nargv = new (char *)[nargc + 1];
23126:     if (!nargv)
23126:         return JS_FALSE;
57812:     memset(nargv, 0, sizeof(nargv[0]) * (nargc + 1));
23126:     nargv[0] = name;
53557:     jsval *argv = JS_ARGV(cx, vp);
57812:     for (i = 0; i < nargc; i++) {
64345:         str = (i == 0) ? fun->atom : JS_ValueToString(cx, argv[i-1]);
23126:         if (!str) {
57812:             ok = false;
57812:             goto done;
57812:         }
57812:         nargv[i] = JS_EncodeString(cx, str);
57812:         if (!nargv[i]) {
57812:             ok = false;
57812:             goto done;
57812:         }
57812:     }
23126:     pid = fork();
23126:     switch (pid) {
23126:       case -1:
23126:         perror("js");
23126:         break;
23126:       case 0:
23126:         (void) execvp(name, (char **)nargv);
23126:         perror("js");
23126:         exit(127);
23126:       default:
23126:         while (waitpid(pid, &status, 0) < 0 && errno == EINTR)
23126:             continue;
23126:         break;
23126:     }
57812:     ok = true;
57812: 
57812:   done:
57812:     for (i = 0; i < nargc; i++)
57812:         JS_free(cx, nargv[i]);
57812:     delete[] nargv;
57812:     return ok;
23126: }
23126: #endif
23126: 
23126: static JSBool
23126: global_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     return JS_EnumerateStandardClasses(cx, obj);
23126: #else
23126:     return JS_TRUE;
23126: #endif
23126: }
23126: 
23126: static JSBool
95355: global_resolve(JSContext *cx, JSObject *obj_, jsid id, unsigned flags,
23126:                JSObject **objp)
23126: {
95355:     RootedVarObject obj(cx, obj_);
95355: 
23126: #ifdef LAZY_STANDARD_CLASSES
23126:     JSBool resolved;
23126: 
73063:     if (!JS_ResolveStandardClass(cx, obj, id, &resolved))
23126:         return JS_FALSE;
23126:     if (resolved) {
23126:         *objp = obj;
23126:         return JS_TRUE;
23126:     }
23126: #endif
23126: 
23126: #if defined(SHELL_HACK) && defined(DEBUG) && defined(XP_UNIX)
43210:     if (!(flags & JSRESOLVE_QUALIFIED)) {
23126:         /*
23126:          * Do this expensive hack only for unoptimized Unix builds, which are
23126:          * not used for benchmarking.
23126:          */
23126:         char *path, *comp, *full;
23126:         const char *name;
23126:         JSBool ok, found;
23126:         JSFunction *fun;
23126: 
23126:         if (!JSVAL_IS_STRING(id))
23126:             return JS_TRUE;
23126:         path = getenv("PATH");
23126:         if (!path)
23126:             return JS_TRUE;
23126:         path = JS_strdup(cx, path);
23126:         if (!path)
23126:             return JS_FALSE;
57812:         JSAutoByteString name(cx, JSVAL_TO_STRING(id));
57812:         if (!name)
57812:             return JS_FALSE;
23126:         ok = JS_TRUE;
23126:         for (comp = strtok(path, ":"); comp; comp = strtok(NULL, ":")) {
23126:             if (*comp != '\0') {
57812:                 full = JS_smprintf("%s/%s", comp, name.ptr());
23126:                 if (!full) {
23126:                     JS_ReportOutOfMemory(cx);
23126:                     ok = JS_FALSE;
23126:                     break;
23126:                 }
23126:             } else {
23126:                 full = (char *)name;
23126:             }
23126:             found = (access(full, X_OK) == 0);
23126:             if (*comp != '\0')
23126:                 free(full);
23126:             if (found) {
23126:                 fun = JS_DefineFunction(cx, obj, name, Exec, 0,
23126:                                         JSPROP_ENUMERATE);
23126:                 ok = (fun != NULL);
23126:                 if (ok)
23126:                     *objp = obj;
23126:                 break;
23126:             }
23126:         }
23126:         JS_free(cx, path);
23126:         return ok;
23126:     }
23126: #else
23126:     return JS_TRUE;
23126: #endif
23126: }
23126: 
23126: JSClass global_class = {
97681:     "global", JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS,
23126:     JS_PropertyStub,  JS_PropertyStub,
62395:     JS_PropertyStub,  JS_StrictPropertyStub,
23126:     global_enumerate, (JSResolveOp) global_resolve,
97681:     JS_ConvertStub,   NULL
23126: };
23126: 
23126: static JSBool
62395: env_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
23126: {
23126: /* XXX porting may be easy, but these don't seem to supply setenv by default */
63458: #if !defined XP_OS2 && !defined SOLARIS
23126:     int rv;
23126: 
67930:     IdStringifier idstr(cx, id, JS_TRUE);
31366:     if (idstr.threw())
23126:         return JS_FALSE;
84160:     ToStringHelper valstr(cx, *vp, JS_TRUE);
31366:     if (valstr.threw())
31366:         return JS_FALSE;
77779: #if defined XP_WIN || defined HPUX || defined OSF1
23126:     {
31366:         char *waste = JS_smprintf("%s=%s", idstr.getBytes(), valstr.getBytes());
23126:         if (!waste) {
23126:             JS_ReportOutOfMemory(cx);
23126:             return JS_FALSE;
23126:         }
23126:         rv = putenv(waste);
23126: #ifdef XP_WIN
23126:         /*
23126:          * HPUX9 at least still has the bad old non-copying putenv.
23126:          *
23126:          * Per mail from <s.shanmuganathan@digital.com>, OSF1 also has a putenv
23126:          * that will crash if you pass it an auto char array (so it must place
23126:          * its argument directly in the char *environ[] array).
23126:          */
31366:         JS_smprintf_free(waste);
23126: #endif
23126:     }
23126: #else
31366:     rv = setenv(idstr.getBytes(), valstr.getBytes(), 1);
23126: #endif
23126:     if (rv < 0) {
31366:         JS_ReportError(cx, "can't set env variable %s to %s", idstr.getBytes(), valstr.getBytes());
23126:         return JS_FALSE;
23126:     }
31366:     *vp = valstr.getJSVal();
63458: #endif /* !defined XP_OS2 && !defined SOLARIS */
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
23126: env_enumerate(JSContext *cx, JSObject *obj)
23126: {
23126:     static JSBool reflected;
23126:     char **evp, *name, *value;
23126:     JSString *valstr;
23126:     JSBool ok;
23126: 
23126:     if (reflected)
23126:         return JS_TRUE;
23126: 
89826:     for (evp = (char **)JS_GetPrivate(obj); (name = *evp) != NULL; evp++) {
23126:         value = strchr(name, '=');
23126:         if (!value)
23126:             continue;
23126:         *value++ = '\0';
23126:         valstr = JS_NewStringCopyZ(cx, value);
23126:         if (!valstr) {
23126:             ok = JS_FALSE;
23126:         } else {
23126:             ok = JS_DefineProperty(cx, obj, name, STRING_TO_JSVAL(valstr),
23126:                                    NULL, NULL, JSPROP_ENUMERATE);
23126:         }
23126:         value[-1] = '=';
23126:         if (!ok)
23126:             return JS_FALSE;
23126:     }
23126: 
23126:     reflected = JS_TRUE;
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSBool
91237: env_resolve(JSContext *cx, JSObject *obj, jsid id, unsigned flags,
23126:             JSObject **objp)
23126: {
31366:     JSString *valstr;
23126:     const char *name, *value;
23126: 
23126:     if (flags & JSRESOLVE_ASSIGNING)
23126:         return JS_TRUE;
23126: 
67930:     IdStringifier idstr(cx, id, JS_TRUE);
31366:     if (idstr.threw())
23126:         return JS_FALSE;
31366: 
31366:     name = idstr.getBytes();
23126:     value = getenv(name);
23126:     if (value) {
23126:         valstr = JS_NewStringCopyZ(cx, value);
23126:         if (!valstr)
23126:             return JS_FALSE;
23126:         if (!JS_DefineProperty(cx, obj, name, STRING_TO_JSVAL(valstr),
23126:                                NULL, NULL, JSPROP_ENUMERATE)) {
23126:             return JS_FALSE;
23126:         }
23126:         *objp = obj;
23126:     }
23126:     return JS_TRUE;
23126: }
23126: 
23126: static JSClass env_class = {
23126:     "environment", JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE,
23126:     JS_PropertyStub,  JS_PropertyStub,
23126:     JS_PropertyStub,  env_setProperty,
23126:     env_enumerate, (JSResolveOp) env_resolve,
93519:     JS_ConvertStub
23126: };
23126: 
40801: /*
40801:  * Avoid a reentrancy hazard.
40801:  *
40801:  * The non-JS_THREADSAFE shell uses a signal handler to implement timeout().
40801:  * The JS engine is not really reentrant, but JS_TriggerAllOperationCallbacks
40801:  * is mostly safe--the only danger is that we might interrupt JS_NewContext or
40801:  * JS_DestroyContext while the context list is being modified. Therefore we
40801:  * disable the signal handler around calls to those functions.
40801:  */
40801: #ifdef JS_THREADSAFE
40801: # define WITH_SIGNALS_DISABLED(x)  x
40801: #else
40801: # define WITH_SIGNALS_DISABLED(x)                                               \
40801:     JS_BEGIN_MACRO                                                              \
40801:         ScheduleWatchdog(gRuntime, -1);                                         \
40801:         x;                                                                      \
40801:         ScheduleWatchdog(gRuntime, gTimeoutInterval);                           \
40801:     JS_END_MACRO
40801: #endif
40801: 
40801: static JSContext *
40801: NewContext(JSRuntime *rt)
23126: {
40801:     JSContext *cx;
40801:     WITH_SIGNALS_DISABLED(cx = JS_NewContext(rt, gStackChunkSize));
40801:     if (!cx)
40801:         return NULL;
40801: 
40801:     JSShellContextData *data = NewContextData();
40801:     if (!data) {
40801:         DestroyContext(cx, false);
40801:         return NULL;
40801:     }
40801: 
23457:     JS_SetContextPrivate(cx, data);
23126:     JS_SetErrorReporter(cx, my_ErrorReporter);
23126:     JS_SetVersion(cx, JSVERSION_LATEST);
23126:     SetContextOptions(cx);
52557:     if (enableMethodJit)
52557:         JS_ToggleOptions(cx, JSOPTION_METHODJIT);
77343:     if (enableTypeInference)
77343:         JS_ToggleOptions(cx, JSOPTION_TYPE_INFERENCE);
40801:     return cx;
40801: }
40801: 
40801: static void
40801: DestroyContext(JSContext *cx, bool withGC)
40801: {
40801:     JSShellContextData *data = GetContextData(cx);
23457:     JS_SetContextPrivate(cx, NULL);
23457:     free(data);
40801:     WITH_SIGNALS_DISABLED(withGC ? JS_DestroyContext(cx) : JS_DestroyContextNoGC(cx));
40801: }
40801: 
40801: static JSObject *
63096: NewGlobalObject(JSContext *cx, CompartmentKind compartment)
40801: {
86437:     RootedVarObject glob(cx);
86437: 
86437:     glob = (compartment == NEW_COMPARTMENT)
63096:            ? JS_NewCompartmentAndGlobalObject(cx, &global_class, NULL)
63096:            : JS_NewGlobalObject(cx, &global_class);
47498:     if (!glob)
47498:         return NULL;
54733: 
63096:     {
54733:         JSAutoEnterCompartment ac;
54733:         if (!ac.enter(cx, glob))
47498:             return NULL;
47498: 
63096: #ifndef LAZY_STANDARD_CLASSES
40801:         if (!JS_InitStandardClasses(cx, glob))
47517:             return NULL;
40801: #endif
63096: 
40801: #ifdef JS_HAS_CTYPES
40801:         if (!JS_InitCTypesClass(cx, glob))
47517:             return NULL;
40801: #endif
73063:         if (!JS_InitReflect(cx, glob))
73063:             return NULL;
75513:         if (!JS_DefineDebuggerObject(cx, glob))
75397:             return NULL;
48637:         if (!JS::RegisterPerfMeasurement(cx, glob))
48637:             return NULL;
91659:         if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions) ||
60787:             !JS_DefineProfilingFunctions(cx, glob)) {
47517:             return NULL;
60787:         }
91659:         if (!js::DefineTestingFunctions(cx, glob))
91659:             return NULL;
47517: 
40801:         JSObject *it = JS_DefineObject(cx, glob, "it", &its_class, NULL, 0);
40801:         if (!it)
47517:             return NULL;
40801:         if (!JS_DefineProperties(cx, it, its_props))
47517:             return NULL;
40801: 
40801:         if (!JS_DefineProperty(cx, glob, "custom", JSVAL_VOID, its_getter,
40801:                                its_setter, 0))
47517:             return NULL;
40801:         if (!JS_DefineProperty(cx, glob, "customRdOnly", JSVAL_VOID, its_getter,
40801:                                its_setter, JSPROP_READONLY))
47517:             return NULL;
63096:     }
63096: 
86437:     if (compartment == NEW_COMPARTMENT && !JS_WrapObject(cx, glob.address()))
63096:         return NULL;
40801: 
47498:     return glob;
40801: }
23126: 
74072: static bool
74072: BindScriptArgs(JSContext *cx, JSObject *obj, OptionParser *op)
74072: {
86437:     RootObject root(cx, &obj);
86437: 
74072:     MultiStringRange msr = op->getMultiStringArg("scriptArgs");
86437:     RootedVarObject scriptArgs(cx);
86437:     scriptArgs = JS_NewArrayObject(cx, 0, NULL);
74072:     if (!scriptArgs)
74072:         return false;
76346: 
76346:     /*
76346:      * Script arguments are bound as a normal |arguments| property on the
76346:      * global object. It has no special significance, like |arguments| in
76346:      * function scope does -- this identifier is used de-facto across shell
76346:      * implementations, see bug 675269.
76346:      */
76346:     if (!JS_DefineProperty(cx, obj, "arguments", OBJECT_TO_JSVAL(scriptArgs), NULL, NULL, 0))
74072:         return false;
74072: 
74072:     for (size_t i = 0; !msr.empty(); msr.popFront(), ++i) {
74072:         const char *scriptArg = msr.front();
74072:         JSString *str = JS_NewStringCopyZ(cx, scriptArg);
74072:         if (!str ||
74072:             !JS_DefineElement(cx, scriptArgs, i, STRING_TO_JSVAL(str), NULL, NULL,
74072:                               JSPROP_ENUMERATE)) {
74072:             return false;
74072:         }
74072:     }
74072: 
74072:     return true;
74072: }
74072: 
74072: static int
74072: ProcessArgs(JSContext *cx, JSObject *obj, OptionParser *op)
74072: {
86437:     RootObject root(cx, &obj);
86437: 
74072:     if (op->getBoolOption('a'))
74072:         JS_ToggleOptions(cx, JSOPTION_METHODJIT_ALWAYS);
74072: 
86758:     if (op->getBoolOption('c'))
86758:         compileOnly = true;
86758: 
74072:     if (op->getBoolOption('m')) {
74072:         enableMethodJit = true;
74072:         JS_ToggleOptions(cx, JSOPTION_METHODJIT);
74072:     }
74072: 
74072:     if (op->getBoolOption('d')) {
74072:         JS_SetRuntimeDebugMode(JS_GetRuntime(cx), true);
74072:         JS_SetDebugMode(cx, true);
74072:     }
74072: 
74072:     if (op->getBoolOption('b'))
74072:         printTiming = true;
74072: 
76750:     if (op->getBoolOption('D'))
74072:         enableDisassemblyDumps = true;
74072: 
74072:     /* |scriptArgs| gets bound on the global before any code is run. */
74072:     if (!BindScriptArgs(cx, obj, op))
74072:         return EXIT_FAILURE;
74072: 
74072:     MultiStringRange filePaths = op->getMultiStringOption('f');
74072:     MultiStringRange codeChunks = op->getMultiStringOption('e');
74072: 
74072:     if (filePaths.empty() && codeChunks.empty() && !op->getStringArg("script")) {
74072:         Process(cx, obj, NULL, true); /* Interactive. */
74072:         return gExitCode;
74072:     }
74072: 
74072:     while (!filePaths.empty() || !codeChunks.empty()) {
74072:         size_t fpArgno = filePaths.empty() ? -1 : filePaths.argno();
74072:         size_t ccArgno = codeChunks.empty() ? -1 : codeChunks.argno();
74072:         if (fpArgno < ccArgno) {
74072:             char *path = filePaths.front();
74072:             Process(cx, obj, path, false);
74072:             if (gExitCode)
74072:                 return gExitCode;
74072:             filePaths.popFront();
74072:         } else {
74072:             const char *code = codeChunks.front();
74072:             jsval rval;
74072:             if (!JS_EvaluateScript(cx, obj, code, strlen(code), "-e", 1, &rval))
74072:                 return EXIT_FAILURE;
74072:             codeChunks.popFront();
74072:         }
74072:     }
74072: 
74072:     /* The |script| argument is processed after all options. */
74072:     if (const char *path = op->getStringArg("script")) {
74072:         Process(cx, obj, path, false);
74072:         if (gExitCode)
74072:             return gExitCode;
74072:     }
74072: 
74072:     if (op->getBoolOption('i'))
74072:         Process(cx, obj, NULL, true);
74072: 
74072:     return gExitCode ? gExitCode : EXIT_SUCCESS;
74072: }
74072: 
23126: int
74072: Shell(JSContext *cx, OptionParser *op, char **envp)
23126: {
47504:     JSAutoRequest ar(cx);
54733: 
77343:     /*
77343:      * First check to see if type inference is enabled. This flag must be set
77343:      * on the compartment when it is constructed.
77343:      */
77363:     if (op->getBoolOption('n')) {
77343:         enableTypeInference = !enableTypeInference;
77343:         JS_ToggleOptions(cx, JSOPTION_TYPE_INFERENCE);
77343:     }
77343: 
86437:     RootedVarObject glob(cx);
86437:     glob = NewGlobalObject(cx, NEW_COMPARTMENT);
23126:     if (!glob)
23126:         return 1;
40801: 
54733:     JSAutoEnterCompartment ac;
54733:     if (!ac.enter(cx, glob))
54733:         return 1;
54733: 
63096:     JS_SetGlobalObject(cx, glob);
63096: 
40801:     JSObject *envobj = JS_DefineObject(cx, glob, "environment", &env_class, NULL, 0);
89826:     if (!envobj)
47504:         return 1;
89826:     JS_SetPrivate(envobj, envp);
26666: 
23126: #ifdef JSDEBUGGER
23126:     /*
23126:     * XXX A command line option to enable debugging (or not) would be good
23126:     */
23126:     jsdc = JSD_DebuggerOnForUser(rt, NULL, NULL);
23126:     if (!jsdc)
47504:         return 1;
23126:     JSD_JSContextInUse(jsdc, cx);
23126: #ifdef JSD_LOWLEVEL_SOURCE
23126:     JS_SetSourceHandler(rt, SendSourceToJSDebugger, jsdc);
23126: #endif /* JSD_LOWLEVEL_SOURCE */
23126: #ifdef JSDEBUGGER_JAVA_UI
23126:     jsdjc = JSDJ_CreateContext();
23126:     if (! jsdjc)
47504:         return 1;
23126:     JSDJ_SetJSDContext(jsdjc, jsdc);
23126:     java_env = JSDJ_CreateJavaVMAndStartDebugger(jsdjc);
23126:     /*
23126:     * XXX This would be the place to wait for the debugger to start.
23126:     * Waiting would be nice in general, but especially when a js file
23126:     * is passed on the cmd line.
23126:     */
23126: #endif /* JSDEBUGGER_JAVA_UI */
23126: #ifdef JSDEBUGGER_C_UI
23126:     jsdbc = JSDB_InitDebugger(rt, jsdc, 0);
23126: #endif /* JSDEBUGGER_C_UI */
23126: #endif /* JSDEBUGGER */
23126: 
40801: #ifdef JS_THREADSAFE
40801:     class ShellWorkerHooks : public js::workers::WorkerHooks {
40801:     public:
47517:         JSObject *newGlobalObject(JSContext *cx) {
63096:             return NewGlobalObject(cx, NEW_COMPARTMENT);
47517:         }
40801:     };
40801:     ShellWorkerHooks hooks;
47403:     if (!JS_AddNamedObjectRoot(cx, &gWorkers, "Workers") ||
55619:         (gWorkerThreadPool = js::workers::init(cx, &hooks, glob, &gWorkers)) == NULL) {
47504:         return 1;
23126:     }
23126: #endif
23126: 
74072:     int result = ProcessArgs(cx, glob, op);
23126: 
40801: #ifdef JS_THREADSAFE
55619:     js::workers::finish(cx, gWorkerThreadPool);
47403:     JS_RemoveObjectRoot(cx, &gWorkers);
40801:     if (result == 0)
40801:         result = gExitCode;
40801: #endif
40801: 
23126: #ifdef JSDEBUGGER
23126:     if (jsdc) {
23126: #ifdef JSDEBUGGER_C_UI
23126:         if (jsdbc)
23126:             JSDB_TermDebugger(jsdc);
23126: #endif /* JSDEBUGGER_C_UI */
23126:         JSD_DebuggerOff(jsdc);
23126:     }
23126: #endif  /* JSDEBUGGER */
23126: 
71701:     if (enableDisassemblyDumps)
82134:         JS_DumpCompartmentPCCounts(cx);
71701: 
43286:     return result;
43286: }
43286: 
55469: static void
55469: MaybeOverrideOutFileFromEnv(const char* const envVar,
55469:                             FILE* defaultOut,
55469:                             FILE** outFile)
55469: {
55474:     const char* outPath = getenv(envVar);
55469:     if (!outPath || !*outPath || !(*outFile = fopen(outPath, "w"))) {
55469:         *outFile = defaultOut;
55469:     }
55469: }
55469: 
91900: /* Set the initial counter to 1 so the principal will never be destroyed. */
91900: JSPrincipals shellTrustedPrincipals = { 1 };
91900: 
73495: JSBool
91900: CheckObjectAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode, jsval *vp)
74329: {
74329:     return true;
74329: }
74329: 
74329: JSSecurityCallbacks securityCallbacks = {
74329:     CheckObjectAccess,
74329:     NULL,
74329:     NULL,
74329:     NULL
74329: };
74329: 
43286: int
43286: main(int argc, char **argv, char **envp)
43286: {
43286:     int stackDummy;
43286:     JSRuntime *rt;
43286:     JSContext *cx;
43286:     int result;
43286: #ifdef JSDEBUGGER
43286:     JSDContext *jsdc;
43286: #ifdef JSDEBUGGER_JAVA_UI
43286:     JNIEnv *java_env;
43286:     JSDJContext *jsdjc;
43286: #endif
43286: #ifdef JSDEBUGGER_C_UI
43286:     JSBool jsdbc;
43286: #endif /* JSDEBUGGER_C_UI */
43286: #endif /* JSDEBUGGER */
52897: #ifdef XP_WIN
53132:     {
53132:         const char *crash_option = getenv("XRE_NO_WINDOWS_CRASH_DIALOG");
53132:         if (crash_option && strncmp(crash_option, "1", 1)) {
52897:             DWORD oldmode = SetErrorMode(SEM_NOGPFAULTERRORBOX);
52897:             SetErrorMode(oldmode | SEM_NOGPFAULTERRORBOX);
53132:         }
53132:     }
52897: #endif
43286: 
43286: #ifdef HAVE_SETLOCALE
43286:     setlocale(LC_ALL, "");
43286: #endif
43286: 
43286: #ifdef JS_THREADSAFE
43286:     if (PR_FAILURE == PR_NewThreadPrivateIndex(&gStackBaseThreadIndex, NULL) ||
43286:         PR_FAILURE == PR_SetThreadPrivate(gStackBaseThreadIndex, &stackDummy)) {
43286:         return 1;
43286:     }
43286: #else
86976:     gStackBase = (uintptr_t) &stackDummy;
43286: #endif
43286: 
43286: #ifdef XP_OS2
43286:    /* these streams are normally line buffered on OS/2 and need a \n, *
43286:     * so we need to unbuffer then to get a reasonable prompt          */
43286:     setbuf(stdout,0);
43286:     setbuf(stderr,0);
43286: #endif
43286: 
55469:     MaybeOverrideOutFileFromEnv("JS_STDERR", stderr, &gErrFile);
55469:     MaybeOverrideOutFileFromEnv("JS_STDOUT", stdout, &gOutFile);
43286: 
74072:     OptionParser op("Usage: {progname} [options] [[script] scriptArgs*]");
74072: 
74072:     op.setDescription("The SpiderMonkey shell provides a command line interface to the "
74072:         "JavaScript engine. Code and file options provided via the command line are "
74072:         "run left to right. If provided, the optional script argument is run after "
74072:         "all options have been processed. Just-In-Time compilation modes may be enabled via "
74072:         "command line options.");
74072:     op.setDescriptionWidth(72);
74072:     op.setHelpWidth(80);
74072:     op.setVersion(JS_GetImplementationVersion());
74072: 
74072:     if (!op.addMultiStringOption('f', "file", "PATH", "File path to run")
74072:         || !op.addMultiStringOption('e', "execute", "CODE", "Inline code to run")
74072:         || !op.addBoolOption('i', "shell", "Enter prompt after running code")
74072:         || !op.addBoolOption('m', "methodjit", "Enable the JaegerMonkey method JIT")
77363:         || !op.addBoolOption('n', "typeinfer", "Enable type inference")
86758:         || !op.addBoolOption('c', "compileonly", "Only compile, don't run (syntax checking mode)")
74072:         || !op.addBoolOption('d', "debugjit", "Enable runtime debug mode for method JIT code")
74072:         || !op.addBoolOption('a', "always-mjit",
82889:                              "Do not try to run in the interpreter before method jitting.")
74072:         || !op.addBoolOption('D', "dump-bytecode", "Dump bytecode with exec count for all scripts")
74072:         || !op.addBoolOption('b', "print-timing", "Print sub-ms runtime for each file that's run")
74072: #ifdef DEBUG
74072:         || !op.addIntOption('A', "oom-after", "COUNT", "Trigger OOM after COUNT allocations", -1)
74072:         || !op.addBoolOption('O', "print-alloc", "Print the number of allocations at exit")
74072: #endif
74072:         || !op.addBoolOption('U', "utf8", "C strings passed to the JSAPI are UTF-8 encoded")
74072: #ifdef JS_GC_ZEAL
74072:         || !op.addStringOption('Z', "gc-zeal", "N[,F[,C]]",
74072:                                "N indicates \"zealousness\":\n"
74072:                                "  0: no additional GCs\n"
74072:                                "  1: additional GCs at common danger points\n"
74072:                                "  2: GC every F allocations (default: 100)\n"
74072:                                "If C is 1, compartmental GCs are performed; otherwise, full")
74072: #endif
74072:         || !op.addOptionalStringArg("script", "A script to execute (after all options)")
74072:         || !op.addOptionalMultiStringArg("scriptArgs",
76346:                                          "String arguments to bind as |arguments| in the "
74072:                                          "shell's global")) {
74072:         return EXIT_FAILURE;
74072:     }
74072: 
77503:     op.setArgTerminatesOptions("script", true);
77503: 
74072:     switch (op.parseArgs(argc, argv)) {
74072:       case OptionParser::ParseHelp:
74072:         return EXIT_SUCCESS;
74072:       case OptionParser::ParseError:
74072:         op.printHelp(argv[0]);
74072:         return EXIT_FAILURE;
74072:       case OptionParser::Fail:
74072:         return EXIT_FAILURE;
74072:       case OptionParser::Okay:
74072:         break;
74072:     }
74072: 
74072:     if (op.getHelpOption())
74072:         return EXIT_SUCCESS;
74072: 
74072: #ifdef DEBUG
74072:     /*
74072:      * Process OOM options as early as possible so that we can observe as many
74072:      * allocations as possible.
74072:      */
74072:     if (op.getIntOption('A') >= 0)
74072:         OOM_maxAllocations = op.getIntOption('A');
74072:     if (op.getBoolOption('O'))
74072:         OOM_printAllocationCount = true;
74072: #endif
74072: 
74072:     /* Must be done before we create the JSRuntime. */
74072:     if (op.getBoolOption('U'))
68906:         JS_SetCStringsAreUTF8();
68906: 
43286: #ifdef XP_WIN
43286:     // Set the timer calibration delay count to 0 so we get high
43286:     // resolution right away, which we need for precise benchmarking.
43286:     extern int CALIBRATION_DELAY_COUNT;
43286:     CALIBRATION_DELAY_COUNT = 0;
43286: #endif
43286: 
78473:     /* Use the same parameters as the browser in xpcjsruntime.cpp. */
78473:     rt = JS_NewRuntime(32L * 1024L * 1024L);
43286:     if (!rt)
43286:         return 1;
43286: 
78473:     JS_SetGCParameter(rt, JSGC_MAX_BYTES, 0xffffffff);
78473: 
73495:     JS_SetTrustedPrincipals(rt, &shellTrustedPrincipals);
91900:     JS_SetSecurityCallbacks(rt, &securityCallbacks);
73495: 
89261:     JS_SetNativeStackQuota(rt, gMaxStackSize);
89261: 
43286:     if (!InitWatchdog(rt))
43286:         return 1;
43286: 
43286:     cx = NewContext(rt);
43286:     if (!cx)
43286:         return 1;
43286: 
90410:     JS_SetGCParameter(rt, JSGC_MODE, JSGC_MODE_INCREMENTAL);
43286:     JS_SetGCParameterForThread(cx, JSGC_MAX_CODE_CACHE_BYTES, 16 * 1024 * 1024);
43286: 
76750:     /* Must be done before creating the global object */
76750:     if (op.getBoolOption('D'))
76750:         JS_ToggleOptions(cx, JSOPTION_PCCOUNT);
76750: 
74072:     result = Shell(cx, &op, envp);
43286: 
64323: #ifdef DEBUG
64323:     if (OOM_printAllocationCount)
64323:         printf("OOM max count: %u\n", OOM_counter);
64323: #endif
64323: 
40801:     DestroyContext(cx, true);
25087: 
25472:     KillWatchdog();
23726: 
23126:     JS_DestroyRuntime(rt);
23126:     JS_ShutDown();
23126:     return result;
23126: }
