    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "jsapi.h"
    1: #include "nsDOMParser.h"
    1: #include "nsIURI.h"
    1: #include "nsIChannel.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsIInputStream.h"
    1: #include "nsNetUtil.h"
    1: #include "nsStringStream.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIDOMClassInfo.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCRT.h"
    1: #include "nsLoadListenerProxy.h"
    1: #include "nsStreamUtils.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNetCID.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsDOMError.h"
 8947: #include "nsIDOMWindow.h"
 8947: #include "nsPIDOMWindow.h"
54924: #include "mozilla/AutoRestore.h"
54924: 
54924: using namespace mozilla;
    1: 
    1: // nsIDOMEventListener
    1: nsresult
    1: nsDOMParser::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDOMLoadListener
    1: nsresult
    1: nsDOMParser::Load(nsIDOMEvent* aEvent)
    1: {
    1:   mLoopingForSyncLoad = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDOMParser::BeforeUnload(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDOMParser::Unload(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDOMParser::Abort(nsIDOMEvent* aEvent)
    1: {
    1:   mLoopingForSyncLoad = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDOMParser::Error(nsIDOMEvent* aEvent)
    1: {
    1:   mLoopingForSyncLoad = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsDOMParser::nsDOMParser()
    1:   : mLoopingForSyncLoad(PR_FALSE),
    1:     mAttemptedInit(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsDOMParser::~nsDOMParser()
    1: {
    1:   NS_ABORT_IF_FALSE(!mLoopingForSyncLoad, "we rather crash than hang");
    1:   mLoopingForSyncLoad = PR_FALSE;
    1: }
    1: 
40490: DOMCI_DATA(DOMParser, nsDOMParser)
    1: 
    1: // QueryInterface implementation for nsDOMParser
    1: NS_INTERFACE_MAP_BEGIN(nsDOMParser)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMParser)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMParser)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMParserJS)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMLoadListener)
13964:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMParser)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsDOMParser)
    1: NS_IMPL_RELEASE(nsDOMParser)
    1: 
    1: NS_IMETHODIMP 
    1: nsDOMParser::ParseFromString(const PRUnichar *str, 
    1:                              const char *contentType,
    1:                              nsIDOMDocument **aResult)
    1: {
    1:   NS_ENSURE_ARG(str);
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   NS_ConvertUTF16toUTF8 data(str);
    1: 
    1:   // The new stream holds a reference to the buffer
    1:   nsCOMPtr<nsIInputStream> stream;
    1:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream),
    1:                                       data.get(), data.Length(),
    1:                                       NS_ASSIGNMENT_DEPEND);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return ParseFromStream(stream, "UTF-8", data.Length(), contentType, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsDOMParser::ParseFromBuffer(const PRUint8 *buf,
    1:                              PRUint32 bufLen,
    1:                              const char *contentType,
    1:                              nsIDOMDocument **aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(buf);
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   // The new stream holds a reference to the buffer
    1:   nsCOMPtr<nsIInputStream> stream;
    1:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream),
 3233:                                       reinterpret_cast<const char *>(buf),
    1:                                       bufLen, NS_ASSIGNMENT_DEPEND);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return ParseFromStream(stream, nsnull, bufLen, contentType, aResult);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsDOMParser::ParseFromStream(nsIInputStream *stream, 
    1:                              const char *charset, 
    1:                              PRInt32 contentLength,
    1:                              const char *contentType,
    1:                              nsIDOMDocument **aResult)
    1: {
    1:   NS_ENSURE_ARG(stream);
    1:   NS_ENSURE_ARG(contentType);
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult = nsnull;
    1: 
    1:   // For now, we can only create XML documents.
    1:   if ((nsCRT::strcmp(contentType, "text/xml") != 0) &&
    1:       (nsCRT::strcmp(contentType, "application/xml") != 0) &&
    1:       (nsCRT::strcmp(contentType, "application/xhtml+xml") != 0))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
 6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 6475:     do_QueryReferent(mScriptHandlingObject);
    1:   nsresult rv;
    1:   if (!mPrincipal) {
    1:     NS_ENSURE_TRUE(!mAttemptedInit, NS_ERROR_NOT_INITIALIZED);
    1:     AttemptedInitMarker marker(&mAttemptedInit);
    1:     
    1:     nsCOMPtr<nsIPrincipal> prin =
    1:       do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
 6475:     rv = Init(prin, nsnull, nsnull, scriptHandlingObject);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   NS_ASSERTION(mPrincipal, "Must have principal by now");
    1:   NS_ASSERTION(mDocumentURI, "Must have document URI by now");
    1:   
    1:   // Put the nsCOMPtr out here so we hold a ref to the stream as needed
    1:   nsCOMPtr<nsIInputStream> bufferedStream;
    1:   if (!NS_InputStreamIsBuffered(stream)) {
    1:     rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream), stream,
    1:                                    4096);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     stream = bufferedStream;
    1:   }
    1: 
13653:   // Here we have to cheat a little bit...  Setting the base URI won't
13653:   // work if the document has a null principal, so use
13653:   // mOriginalPrincipal when creating the document, then reset the
13653:   // principal.
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   rv = nsContentUtils::CreateDocument(EmptyString(), EmptyString(), nsnull,
13653:                                       mDocumentURI, mBaseURI,
13653:                                       mOriginalPrincipal,
 6475:                                       scriptHandlingObject,
    1:                                       getter_AddRefs(domDocument));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Register as a load listener on the document
 1418:   nsCOMPtr<nsPIDOMEventTarget> target(do_QueryInterface(domDocument));
    1:   if (target) {
 3233:     nsWeakPtr requestWeak(do_GetWeakReference(static_cast<nsIDOMParser*>(this)));
    1:     nsLoadListenerProxy* proxy = new nsLoadListenerProxy(requestWeak);
    1:     if (!proxy) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // This will addref the proxy
 3233:     rv = target->AddEventListenerByIID(static_cast<nsIDOMEventListener*>(proxy), 
    1:                                        NS_GET_IID(nsIDOMLoadListener));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // Create a fake channel 
    1:   nsCOMPtr<nsIChannel> parserChannel;
    1:   NS_NewInputStreamChannel(getter_AddRefs(parserChannel), mDocumentURI, nsnull,
    1:                            nsDependentCString(contentType), nsnull);
    1:   NS_ENSURE_STATE(parserChannel);
    1: 
14668:   // More principal-faking here 
14668:   parserChannel->SetOwner(mOriginalPrincipal);
    1: 
    1:   if (charset) {
    1:     parserChannel->SetContentCharset(nsDependentCString(charset));
    1:   }
    1: 
    1:   // Tell the document to start loading
    1:   nsCOMPtr<nsIStreamListener> listener;
    1: 
54924:   AutoRestore<PRPackedBool> restoreSyncLoop(mLoopingForSyncLoad);
    1:   mLoopingForSyncLoad = PR_TRUE;
    1: 
    1:   // Have to pass PR_FALSE for reset here, else the reset will remove
    1:   // our event listener.  Should that listener addition move to later
    1:   // than this call?  Then we wouldn't need to mess around with
    1:   // SetPrincipal, etc, probably!
14668:   nsCOMPtr<nsIDocument> document(do_QueryInterface(domDocument));
14668:   if (!document) return NS_ERROR_FAILURE;
14668: 
51393:   if (nsContentUtils::IsSystemPrincipal(mOriginalPrincipal)) {
51393:     document->ForceEnableXULXBL();
51393:   }
51393: 
    1:   rv = document->StartDocumentLoad(kLoadAsData, parserChannel, 
    1:                                    nsnull, nsnull, 
    1:                                    getter_AddRefs(listener),
    1:                                    PR_FALSE);
    1: 
14668:   // Make sure to give this document the right base URI
14668:   document->SetBaseURI(mBaseURI);
14668: 
14668:   // And the right principal
    1:   document->SetPrincipal(mPrincipal);
    1: 
    1:   if (NS_FAILED(rv) || !listener) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Now start pumping data to the listener
    1:   nsresult status;
    1: 
    1:   rv = listener->OnStartRequest(parserChannel, nsnull);
    1:   if (NS_FAILED(rv))
    1:     parserChannel->Cancel(rv);
    1:   parserChannel->GetStatus(&status);
    1: 
    1:   if (NS_SUCCEEDED(rv) && NS_SUCCEEDED(status)) {
    1:     rv = listener->OnDataAvailable(parserChannel, nsnull, stream, 0,
    1:                                    contentLength);
    1:     if (NS_FAILED(rv))
    1:       parserChannel->Cancel(rv);
    1:     parserChannel->GetStatus(&status);
    1:   }
    1: 
    1:   rv = listener->OnStopRequest(parserChannel, nsnull, status);
    1:   // Failure returned from OnStopRequest does not affect the final status of
    1:   // the channel, so we do not need to call Cancel(rv) as we do above.
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Process events until we receive a load, abort, or error event for the
    1:   // document object.  That event may have already fired.
    1: 
    1:   nsIThread *thread = NS_GetCurrentThread();
    1:   while (mLoopingForSyncLoad) {
    1:     if (!NS_ProcessNextEvent(thread))
    1:       break;
    1:   }
    1: 
    1:   domDocument.swap(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMParser::Init(nsIPrincipal* principal, nsIURI* documentURI,
 6475:                   nsIURI* baseURI, nsIScriptGlobalObject* aScriptObject)
    1: {
    1:   NS_ENSURE_STATE(!mAttemptedInit);
    1:   mAttemptedInit = PR_TRUE;
    1:   
    1:   NS_ENSURE_ARG(principal || documentURI);
    1: 
    1:   mDocumentURI = documentURI;
50981:   
    1:   if (!mDocumentURI) {
    1:     principal->GetURI(getter_AddRefs(mDocumentURI));
50981:     // If we have the system principal, then we'll just use the null principals
50981:     // uri.
50981:     if (!mDocumentURI && !nsContentUtils::IsSystemPrincipal(principal)) {
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:   }
    1: 
 6475:   mScriptHandlingObject = do_GetWeakReference(aScriptObject);
    1:   mPrincipal = principal;
50981:   nsresult rv;
50981:   if (!mPrincipal) {
    1:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
    1:     NS_ENSURE_TRUE(secMan, NS_ERROR_NOT_AVAILABLE);
13653:     rv =
    1:       secMan->GetCodebasePrincipal(mDocumentURI, getter_AddRefs(mPrincipal));
50981:     NS_ENSURE_SUCCESS(rv, rv);
13653:     mOriginalPrincipal = mPrincipal;
13653:   } else {
50981:     mOriginalPrincipal = mPrincipal;
50981:     if (nsContentUtils::IsSystemPrincipal(mPrincipal)) {
13653:       // Don't give DOMParsers the system principal.  Use a null
13653:       // principal instead.
13653:       mPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
50981:       NS_ENSURE_SUCCESS(rv, rv);
50981: 
50981:       if (!mDocumentURI) {
50981:         rv = mPrincipal->GetURI(getter_AddRefs(mDocumentURI));
50981:         NS_ENSURE_SUCCESS(rv, rv);
13653:       }
13653:     }
50981:   }
    1:   
    1:   mBaseURI = baseURI;
    1:   // Note: if mBaseURI is null, fine.  Leave it like that; that will use the
    1:   // documentURI as the base.  Otherwise for null principals we'll get
    1:   // nsDocument::SetBaseURI giving errors.
    1: 
    1:   NS_POSTCONDITION(mPrincipal, "Must have principal");
13653:   NS_POSTCONDITION(mOriginalPrincipal, "Must have original principal");
    1:   NS_POSTCONDITION(mDocumentURI, "Must have document URI");
    1:   return NS_OK;
    1: }
    1:   
    1: static nsQueryInterface
    1: JSvalToInterface(JSContext* cx, jsval val, nsIXPConnect* xpc, PRBool* wasNull)
    1: {
    1:   if (val == JSVAL_NULL) {
    1:     *wasNull = PR_TRUE;
    1:     return nsQueryInterface(nsnull);
    1:   }
    1:   
    1:   *wasNull = PR_FALSE;
    1:   if (JSVAL_IS_OBJECT(val)) {
    1:     JSObject* arg = JSVAL_TO_OBJECT(val);
    1: 
    1:     nsCOMPtr<nsIXPConnectWrappedNative> native;
    1:     xpc->GetWrappedNativeOfJSObject(cx, arg, getter_AddRefs(native));
    1: 
    1:     // do_QueryWrappedNative is not null-safe
    1:     if (native) {
    1:       return do_QueryWrappedNative(native);
    1:     }
    1:   }
    1:   
    1:   return nsQueryInterface(nsnull);
    1: }
    1: 
    1: static nsresult
    1: GetInitArgs(JSContext *cx, PRUint32 argc, jsval *argv,
    1:             nsIPrincipal** aPrincipal, nsIURI** aDocumentURI,
    1:             nsIURI** aBaseURI)
    1: {
    1:   // Only proceed if the caller has UniversalXPConnect.
    1:   PRBool haveUniversalXPConnect;
    1:   nsresult rv = nsContentUtils::GetSecurityManager()->
    1:     IsCapabilityEnabled("UniversalXPConnect", &haveUniversalXPConnect);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!haveUniversalXPConnect) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1:   }    
    1:   
    1:   nsIXPConnect* xpc = nsContentUtils::XPConnect();
    1:   
    1:   // First arg is our principal.  If someone passes something that's
    1:   // not a principal and not null, die to prevent privilege escalation.
    1:   PRBool wasNull;
    1:   nsCOMPtr<nsIPrincipal> prin = JSvalToInterface(cx, argv[0], xpc, &wasNull);
    1:   if (!prin && !wasNull) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> documentURI;
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   if (argc > 1) {
    1:     // Grab our document URI too.  Again, if it's something unexpected bail
    1:     // out.
    1:     documentURI = JSvalToInterface(cx, argv[1], xpc, &wasNull);
    1:     if (!documentURI && !wasNull) {
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1: 
    1:     if (argc > 2) {
    1:       // Grab our base URI as well
    1:       baseURI = JSvalToInterface(cx, argv[2], xpc, &wasNull);
    1:       if (!baseURI && !wasNull) {
    1:         return NS_ERROR_INVALID_ARG;
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aPrincipal = prin);
    1:   NS_IF_ADDREF(*aDocumentURI = documentURI);
    1:   NS_IF_ADDREF(*aBaseURI = baseURI);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8947: nsDOMParser::Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
    1:                         PRUint32 argc, jsval *argv)
    1: {
    1:   AttemptedInitMarker marker(&mAttemptedInit);
    1:   nsCOMPtr<nsIPrincipal> prin;
    1:   nsCOMPtr<nsIURI> documentURI;
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   if (argc > 0) {
    1:     nsresult rv = GetInitArgs(cx, argc, argv, getter_AddRefs(prin),
    1:                               getter_AddRefs(documentURI),
    1:                               getter_AddRefs(baseURI));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     // No arguments; use the subject principal
    1:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
    1:     NS_ENSURE_TRUE(secMan, NS_ERROR_UNEXPECTED);
    1: 
    1:     secMan->GetSubjectPrincipal(getter_AddRefs(prin));
    1: 
    1:     // We're called from JS; there better be a subject principal, really.
    1:     NS_ENSURE_TRUE(prin, NS_ERROR_UNEXPECTED);
    1:   }
    1: 
    1:   NS_ASSERTION(prin, "Must have principal by now");
    1:   
    1:   if (!documentURI) {
    1:     // No explicit documentURI; grab document and base URIs off the window our
    1:     // constructor was called on. Error out if anything untoward happens.
    1: 
    1:     // Note that this is a behavior change as far as I can tell -- we're now
    1:     // using the base URI and document URI of the window off of which the
    1:     // DOMParser is created, not the window in which parse*() is called.
    1:     // Does that matter?
    1: 
    1:     // Also note that |cx| matches what GetDocumentFromContext() would return,
    1:     // while GetDocumentFromCaller() gives us the window that the DOMParser()
    1:     // call was made on.
    1: 
 8947:     nsCOMPtr<nsIDocument> doc;
 8947:     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aOwner);
 8947:     if (aOwner) {
 8947:       nsCOMPtr<nsIDOMDocument> domdoc = window->GetExtantDocument();
 8947:       doc = do_QueryInterface(domdoc);
 8947:     }
 8947: 
    1:     if (!doc) {
    1:       return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
41900:     baseURI = doc->GetDocBaseURI();
    1:     documentURI = doc->GetDocumentURI();
    1:   }
    1: 
 8947:   nsCOMPtr<nsIScriptGlobalObject> scriptglobal = do_QueryInterface(aOwner);
 8947:   return Init(prin, documentURI, baseURI, scriptglobal);
    1: }
    1: 
    1: NS_IMETHODIMP
50981: nsDOMParser::Init(nsIPrincipal *aPrincipal, nsIURI *aDocumentURI,
50981:                   nsIURI *aBaseURI)
    1: {
    1:   AttemptedInitMarker marker(&mAttemptedInit);
    1: 
18869:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
    1:   NS_ENSURE_TRUE(cx, NS_ERROR_UNEXPECTED);
    1: 
 6475:   nsIScriptContext* scriptContext = GetScriptContextFromJSContext(cx);
50981: 
50981:   nsCOMPtr<nsIPrincipal> principal = aPrincipal;
50981: 
50981:   if (!principal && !aDocumentURI) {
50981:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
50981:     NS_ENSURE_TRUE(secMan, NS_ERROR_UNEXPECTED);
50981: 
50981:     secMan->GetSubjectPrincipal(getter_AddRefs(principal));
50981: 
50981:     // We're called from JS; there better be a subject principal, really.
50981:     NS_ENSURE_TRUE(principal, NS_ERROR_UNEXPECTED);
50981:   }
50981: 
50981:   return Init(principal, aDocumentURI, aBaseURI,
 6475:               scriptContext ? scriptContext->GetGlobalObject() : nsnull);
    1: }
