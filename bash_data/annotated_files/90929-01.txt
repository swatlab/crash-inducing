    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Robert Churchill <rjc@netscape.com>
    1:  *   David Hyatt <hyatt@netscape.com>
    1:  *   Chris Waterson <waterson@netscape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Joe Hewitt <hewitt@netscape.com>
    1:  *   Neil Deakin <enndeakin@sympatico.ca>
 3675:  *   Laurent Jouanneau <laurent.jouanneau@disruptive-innovations.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1: 
    1:   Builds content from a datasource using the XUL <template> tag.
    1: 
    1:   TO DO
    1: 
    1:   . Fix ContentTagTest's location in the network construction
    1: 
    1:   To turn on logging for this module, set:
    1: 
    1:     NSPR_LOG_MODULES nsXULTemplateBuilder:5
    1: 
    1:  */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsCRT.h"
    1: #include "nsFixedSizeAllocator.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMDocument.h"
 2435: #include "nsIDOMXMLDocument.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsINameSpaceManager.h"
11693: #include "nsIObserverService.h"
    1: #include "nsIRDFCompositeDataSource.h"
    1: #include "nsIRDFInferDataSource.h"
    1: #include "nsIRDFContainerUtils.h"
    1: #include "nsIXULDocument.h"
    1: #include "nsIXULTemplateBuilder.h"
    1: #include "nsIXULBuilderListener.h"
    1: #include "nsIRDFRemoteDataSource.h"
    1: #include "nsIRDFService.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsISimpleEnumerator.h"
37799: #include "nsISupportsArray.h"
 3675: #include "nsIMutableArray.h"
    1: #include "nsIURL.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsContentCID.h"
    1: #include "nsRDFCID.h"
    1: #include "nsXULContentUtils.h"
    1: #include "nsString.h"
26413: #include "nsTArray.h"
    1: #include "nsXPIDLString.h"
22940: #include "nsWhitespaceTokenizer.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXULElement.h"
    1: #include "jsapi.h"
    1: #include "prlog.h"
    1: #include "rdf.h"
    1: #include "pldhash.h"
    1: #include "plhash.h"
80058: #include "nsDOMClassInfoID.h"
11693: #include "nsPIDOMWindow.h"
37799: #include "nsIConsoleService.h" 
    1: #include "nsNetUtil.h"
    1: #include "nsXULTemplateBuilder.h"
    1: #include "nsXULTemplateQueryProcessorRDF.h"
 2435: #include "nsXULTemplateQueryProcessorXML.h"
 7942: #include "nsXULTemplateQueryProcessorStorage.h"
75263: #include "nsContentUtils.h"
    1: 
51350: using namespace mozilla::dom;
51350: 
    1: //----------------------------------------------------------------------
    1: 
    1: static NS_DEFINE_CID(kRDFContainerUtilsCID,      NS_RDFCONTAINERUTILS_CID);
    1: static NS_DEFINE_CID(kRDFServiceCID,             NS_RDFSERVICE_CID);
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULTemplateBuilder
    1: //
    1: 
    1: nsrefcnt                  nsXULTemplateBuilder::gRefCnt = 0;
    1: nsIRDFService*            nsXULTemplateBuilder::gRDFService;
    1: nsIRDFContainerUtils*     nsXULTemplateBuilder::gRDFContainerUtils;
    1: nsIScriptSecurityManager* nsXULTemplateBuilder::gScriptSecurityManager;
    1: nsIPrincipal*             nsXULTemplateBuilder::gSystemPrincipal;
11693: nsIObserverService*       nsXULTemplateBuilder::gObserverService;
    1: 
    1: #ifdef PR_LOGGING
    1: PRLogModuleInfo* gXULTemplateLog;
    1: #endif
    1: 
    1: #define NS_QUERY_PROCESSOR_CONTRACTID_PREFIX "@mozilla.org/xul/xul-query-processor;1?name="
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULTemplateBuilder methods
    1: //
    1: 
    1: nsXULTemplateBuilder::nsXULTemplateBuilder(void)
80486:     : mQueriesCompiled(false),
    1:       mFlags(0),
11693:       mTop(nsnull),
11693:       mObservedDocument(nsnull)
    1: {
    1: }
    1: 
    1: static PLDHashOperator
49019: DestroyMatchList(nsISupports* aKey, nsTemplateMatch*& aMatch, void* aContext)
    1: {
 3233:     nsFixedSizeAllocator* pool = static_cast<nsFixedSizeAllocator *>(aContext);
    1: 
    1:     // delete all the matches in the list
    1:     while (aMatch) {
    1:         nsTemplateMatch* next = aMatch->mNext;
80486:         nsTemplateMatch::Destroy(*pool, aMatch, true);
    1:         aMatch = next;
    1:     }
    1: 
49019:     return PL_DHASH_REMOVE;
    1: }
    1: 
    1: nsXULTemplateBuilder::~nsXULTemplateBuilder(void)
    1: {
90929:     Uninit(true);
90929: 
    1:     if (--gRefCnt == 0) {
    1:         NS_IF_RELEASE(gRDFService);
    1:         NS_IF_RELEASE(gRDFContainerUtils);
    1:         NS_IF_RELEASE(gSystemPrincipal);
    1:         NS_IF_RELEASE(gScriptSecurityManager);
11693:         NS_IF_RELEASE(gObserverService);
    1:     }
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::InitGlobals()
    1: {
    1:     nsresult rv;
    1: 
    1:     if (gRefCnt++ == 0) {
    1:         // Initialize the global shared reference to the service
    1:         // manager and get some shared resource objects.
    1:         rv = CallGetService(kRDFServiceCID, &gRDFService);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = CallGetService(kRDFContainerUtilsCID, &gRDFContainerUtils);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID,
    1:                             &gScriptSecurityManager);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = gScriptSecurityManager->GetSystemPrincipal(&gSystemPrincipal);
    1:         if (NS_FAILED(rv))
    1:             return rv;
11693: 
11693:         rv = CallGetService(NS_OBSERVERSERVICE_CONTRACTID, &gObserverService);
11693:         if (NS_FAILED(rv))
11693:             return rv;
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1:     if (! gXULTemplateLog)
    1:         gXULTemplateLog = PR_NewLogModule("nsXULTemplateBuilder");
    1: #endif
    1: 
    1:     if (!mMatchMap.IsInitialized() && !mMatchMap.Init())
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     const size_t bucketsizes[] = { sizeof(nsTemplateMatch) };
    1:     return mPool.Init("nsXULTemplateBuilder", bucketsizes, 1, 256);
    1: }
    1: 
    1: 
    1: void
79445: nsXULTemplateBuilder::Uninit(bool aIsFinal)
    1: {
14009:     if (mObservedDocument && aIsFinal) {
11884:         gObserverService->RemoveObserver(this, DOM_WINDOW_DESTROYED_TOPIC);
78399:         gObserverService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
14009:         mObservedDocument->RemoveObserver(this);
11884:         mObservedDocument = nsnull;
11884:     }
11884: 
    1:     if (mQueryProcessor)
    1:         mQueryProcessor->Done();
    1: 
    1:     for (PRInt32 q = mQuerySets.Length() - 1; q >= 0; q--) {
    1:         nsTemplateQuerySet* qs = mQuerySets[q];
    1:         delete qs;
    1:     }
    1: 
    1:     mQuerySets.Clear();
    1: 
49019:     mMatchMap.Enumerate(DestroyMatchList, &mPool);
    1: 
    1:     mRootResult = nsnull;
    1:     mRefVariable = nsnull;
    1:     mMemberVariable = nsnull;
    1: 
80486:     mQueriesCompiled = false;
    1: }
    1: 
    1: static PLDHashOperator
    1: TraverseMatchList(nsISupports* aKey, nsTemplateMatch* aMatch, void* aContext)
    1: {
    1:     nsCycleCollectionTraversalCallback *cb =
 3233:         static_cast<nsCycleCollectionTraversalCallback*>(aContext);
    1: 
    1:     cb->NoteXPCOMChild(aKey);
    1:     nsTemplateMatch* match = aMatch;
    1:     while (match) {
    1:         cb->NoteXPCOMChild(match->GetContainer());
    1:         cb->NoteXPCOMChild(match->mResult);
    1:         match = match->mNext;
    1:     }
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULTemplateBuilder)
  456: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXULTemplateBuilder)
 2435:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDataSource)
  456:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDB)
  456:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCompDB)
49019:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRoot)
49019:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRootResult)
49019:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mListeners)
49019:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mQueryProcessor)
49019:     if (tmp->mMatchMap.IsInitialized()) {
49019:       tmp->mMatchMap.Enumerate(DestroyMatchList, &(tmp->mPool));
49019:     }
72851:     for (PRUint32 i = 0; i < tmp->mQuerySets.Length(); ++i) {
72851:         nsTemplateQuerySet* qs = tmp->mQuerySets[i];
72851:         delete qs;
72851:     }
72851:     tmp->mQuerySets.Clear();
  456: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXULTemplateBuilder)
 2435:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDataSource)
  456:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDB)
  456:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCompDB)
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRoot)
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRootResult)
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mListeners)
    1:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mQueryProcessor)
    1:     if (tmp->mMatchMap.IsInitialized())
    1:         tmp->mMatchMap.EnumerateRead(TraverseMatchList, &cb);
    1:     {
    1:       PRUint32 i, count = tmp->mQuerySets.Length();
    1:       for (i = 0; i < count; ++i) {
    1:         nsTemplateQuerySet *set = tmp->mQuerySets[i];
    1:         cb.NoteXPCOMChild(set->mQueryNode);
    1:         cb.NoteXPCOMChild(set->mCompiledQuery);
    1:         PRUint16 j, rulesCount = set->RuleCount();
    1:         for (j = 0; j < rulesCount; ++j) {
    1:           set->GetRuleAt(j)->Traverse(cb);
    1:         }
    1:       }
    1:     }
    1:     tmp->Traverse(cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXULTemplateBuilder)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXULTemplateBuilder)
    1: 
40490: DOMCI_DATA(XULTemplateBuilder, nsXULTemplateBuilder)
40490: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXULTemplateBuilder)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXULTemplateBuilder)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
11693:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXULTemplateBuilder)
25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XULTemplateBuilder)
    1: NS_INTERFACE_MAP_END
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIXULTemplateBuilder methods
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::GetRoot(nsIDOMElement** aResult)
    1: {
11838:     if (mRoot) {
    1:         return CallQueryInterface(mRoot, aResult);
    1:     }
11838:     *aResult = nsnull;
11838:     return NS_OK;
11838: }
    1: 
    1: NS_IMETHODIMP
11958: nsXULTemplateBuilder::GetDatasource(nsISupports** aResult)
11958: {
11958:     if (mCompDB)
11958:         NS_ADDREF(*aResult = mCompDB);
11958:     else
11958:         NS_IF_ADDREF(*aResult = mDataSource);
11958:     return NS_OK;
11958: }
11958: 
11958: NS_IMETHODIMP
11958: nsXULTemplateBuilder::SetDatasource(nsISupports* aResult)
11958: {
11958:     mDataSource = aResult;
11958:     mCompDB = do_QueryInterface(mDataSource);
11958: 
11958:     return Rebuild();
11958: }
11958: 
11958: NS_IMETHODIMP
    1: nsXULTemplateBuilder::GetDatabase(nsIRDFCompositeDataSource** aResult)
    1: {
 2435:     NS_IF_ADDREF(*aResult = mCompDB);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::GetQueryProcessor(nsIXULTemplateQueryProcessor** aResult)
    1: {
    1:     NS_IF_ADDREF(*aResult = mQueryProcessor.get());
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::AddRuleFilter(nsIDOMNode* aRule, nsIXULTemplateRuleFilter* aFilter)
    1: {
    1:     if (!aRule || !aFilter)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
    1:     // a custom rule filter may be added, one for each rule. If a new one is
    1:     // added, it replaces the old one. Look for the right rule and set its
    1:     // filter
    1: 
    1:     PRInt32 count = mQuerySets.Length();
    1:     for (PRInt32 q = 0; q < count; q++) {
    1:         nsTemplateQuerySet* queryset = mQuerySets[q];
    1: 
    1:         PRInt16 rulecount = queryset->RuleCount();
    1:         for (PRInt16 r = 0; r < rulecount; r++) {
    1:             nsTemplateRule* rule = queryset->GetRuleAt(r);
    1: 
    1:             nsCOMPtr<nsIDOMNode> rulenode;
    1:             rule->GetRuleNode(getter_AddRefs(rulenode));
    1:             if (aRule == rulenode) {
    1:                 rule->SetRuleFilter(aFilter);
    1:                 return NS_OK;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::Rebuild()
    1: {
    1:     PRInt32 i;
    1: 
    1:     for (i = mListeners.Count() - 1; i >= 0; --i) {
    1:         mListeners[i]->WillRebuild(this);
    1:     }
    1: 
    1:     nsresult rv = RebuildAll();
    1: 
    1:     for (i = mListeners.Count() - 1; i >= 0; --i) {
    1:         mListeners[i]->DidRebuild(this);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::Refresh()
    1: {
    1:     nsresult rv;
    1: 
 2435:     if (!mCompDB)
 2435:         return NS_ERROR_FAILURE;
 2435: 
    1:     nsCOMPtr<nsISimpleEnumerator> dslist;
    1:     rv = mCompDB->GetDataSources(getter_AddRefs(dslist));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:     bool hasMore;
    1:     nsCOMPtr<nsISupports> next;
    1:     nsCOMPtr<nsIRDFRemoteDataSource> rds;
    1: 
    1:     while(NS_SUCCEEDED(dslist->HasMoreElements(&hasMore)) && hasMore) {
    1:         dslist->GetNext(getter_AddRefs(next));
    1:         if (next && (rds = do_QueryInterface(next))) {
80486:             rds->Refresh(false);
    1:         }
    1:     }
    1: 
    1:     // XXXbsmedberg: it would be kinda nice to install an async nsIRDFXMLSink
    1:     // observer and call rebuild() once the load is complete. See bug 254600.
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::Init(nsIContent* aElement)
    1: {
11838:     NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
    1:     mRoot = aElement;
    1: 
    1:     nsCOMPtr<nsIDocument> doc = mRoot->GetDocument();
    1:     NS_ASSERTION(doc, "element has no document");
    1:     if (! doc)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
79445:     bool shouldDelay;
 2435:     nsresult rv = LoadDataSources(doc, &shouldDelay);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         // Add ourselves as a document observer
    1:         doc->AddObserver(this);
11693: 
11693:         mObservedDocument = doc;
78399:         gObserverService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID,
80486:                                       false);
11693:         gObserverService->AddObserver(this, DOM_WINDOW_DESTROYED_TOPIC,
80486:                                       false);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsXULTemplateBuilder::CreateContents(nsIContent* aElement, bool aForceCreation)
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::HasGeneratedContent(nsIRDFResource* aResource,
    1:                                           nsIAtom* aTag,
79445:                                           bool* aGenerated)
    1: {
80486:     *aGenerated = false;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::AddResult(nsIXULTemplateResult* aResult,
    1:                                 nsIDOMNode* aQueryNode)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1:     NS_ENSURE_ARG_POINTER(aQueryNode);
    1: 
    1:     return UpdateResult(nsnull, aResult, aQueryNode);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::RemoveResult(nsIXULTemplateResult* aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:     return UpdateResult(aResult, nsnull, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::ReplaceResult(nsIXULTemplateResult* aOldResult,
    1:                                     nsIXULTemplateResult* aNewResult,
    1:                                     nsIDOMNode* aQueryNode)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aOldResult);
    1:     NS_ENSURE_ARG_POINTER(aNewResult);
    1:     NS_ENSURE_ARG_POINTER(aQueryNode);
    1: 
    1:     // just remove the old result and then add a new result separately
    1: 
    1:     nsresult rv = UpdateResult(aOldResult, nsnull, nsnull);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return UpdateResult(nsnull, aNewResult, aQueryNode);
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::UpdateResult(nsIXULTemplateResult* aOldResult,
    1:                                    nsIXULTemplateResult* aNewResult,
    1:                                    nsIDOMNode* aQueryNode)
    1: {
    1:     PR_LOG(gXULTemplateLog, PR_LOG_ALWAYS,
    1:            ("nsXULTemplateBuilder::UpdateResult %p %p %p",
    1:            aOldResult, aNewResult, aQueryNode));
    1: 
54337:     if (!mRoot || !mQueriesCompiled)
54337:       return NS_OK;
54337: 
    1:     // get the containers where content may be inserted. If
    1:     // GetInsertionLocations returns false, no container has generated
    1:     // any content yet so new content should not be generated either. This
    1:     // will be false if the result applies to content that is in a closed menu
    1:     // or treeitem for example.
    1: 
    1:     nsAutoPtr<nsCOMArray<nsIContent> > insertionPoints;
79445:     bool mayReplace = GetInsertionLocations(aOldResult ? aOldResult : aNewResult,
    1:                                               getter_Transfers(insertionPoints));
    1:     if (! mayReplace)
    1:         return NS_OK;
    1: 
    1:     nsresult rv = NS_OK;
    1: 
    1:     nsCOMPtr<nsIRDFResource> oldId, newId;
    1:     nsTemplateQuerySet* queryset = nsnull;
    1: 
    1:     if (aOldResult) {
    1:         rv = GetResultResource(aOldResult, getter_AddRefs(oldId));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         // Ignore re-entrant builds for content that is currently in our
    1:         // activation stack.
    1:         if (IsActivated(oldId))
    1:             return NS_OK;
    1:     }
    1: 
    1:     if (aNewResult) {
    1:         rv = GetResultResource(aNewResult, getter_AddRefs(newId));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         // skip results that don't have ids
    1:         if (! newId)
    1:             return NS_OK;
    1: 
    1:         // Ignore re-entrant builds for content that is currently in our
    1:         // activation stack.
    1:         if (IsActivated(newId))
    1:             return NS_OK;
    1: 
    1:         // look for the queryset associated with the supplied query node
    1:         nsCOMPtr<nsIContent> querycontent = do_QueryInterface(aQueryNode);
    1: 
    1:         PRInt32 count = mQuerySets.Length();
    1:         for (PRInt32 q = 0; q < count; q++) {
    1:             nsTemplateQuerySet* qs = mQuerySets[q];
    1:             if (qs->mQueryNode == querycontent) {
    1:                 queryset = qs;
    1:                 break;
    1:             }
    1:         }
    1: 
    1:         if (! queryset)
    1:             return NS_OK;
    1:     }
    1: 
    1:     if (insertionPoints) {
    1:         // iterate over each insertion point and add or remove the result from
    1:         // that container
    1:         PRUint32 count = insertionPoints->Count();
    1:         for (PRUint32 t = 0; t < count; t++) {
    1:             nsCOMPtr<nsIContent> insertionPoint = insertionPoints->SafeObjectAt(t);
    1:             if (insertionPoint) {
    1:                 rv = UpdateResultInContainer(aOldResult, aNewResult, queryset,
    1:                                              oldId, newId, insertionPoint);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1:             }
    1:         }
    1:     }
    1:     else {
    1:         // The tree builder doesn't use insertion points, so no insertion
    1:         // points will be set. In this case, just update the one result.
    1:         rv = UpdateResultInContainer(aOldResult, aNewResult, queryset,
    1:                                      oldId, newId, nsnull);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::UpdateResultInContainer(nsIXULTemplateResult* aOldResult,
    1:                                               nsIXULTemplateResult* aNewResult,
    1:                                               nsTemplateQuerySet* aQuerySet,
    1:                                               nsIRDFResource* aOldId,
    1:                                               nsIRDFResource* aNewId,
    1:                                               nsIContent* aInsertionPoint)
    1: {
 2434:     // This method takes a result that no longer applies (aOldResult) and
 2434:     // replaces it with a new result (aNewResult). Either may be null
 2434:     // indicating to just remove a result or add a new one without replacing.
 2434:     //
 2434:     // Matches are stored in the hashtable mMatchMap, keyed by result id. If
 2434:     // there is more than one query, or the same id is found in different
 2434:     // containers, the values in the hashtable will be a linked list of all
 2434:     // the matches for that id. The matches are sorted according to the
 2434:     // queries they are associated with. Matches for earlier queries in the
 2434:     // template take priority over matches from later queries. The priority
 2434:     // for a match is determined from the match's QuerySetPriority method.
 2434:     // The first query has a priority 0, and higher numbers are for later
 2434:     // queries with successively higher priorities. Thus, a match takes
 2434:     // precedence if it has a lower priority than another. If there is only
 2434:     // one query or container, then the match doesn't have any linked items.
 2434:     //
 2434:     // Matches are nsTemplateMatch objects. They are wrappers around
 2434:     // nsIXULTemplateResult result objects and are created with
 2434:     // nsTemplateMatch::Create below. The aQuerySet argument specifies which
 2434:     // query the match is associated with.
 2434:     //
 2434:     // When a result id exists in multiple containers, the match's mContainer
 2434:     // field is set to the container it corresponds to. The aInsertionPoint
 2434:     // argument specifies which container is being updated. Even though they
 2434:     // are stored in the same linked list as other matches of the same id, the
 2434:     // matches for different containers are treated separately. They are only
 2434:     // stored in the same hashtable to avoid a more complex data structure, as
 2434:     // the use of the same id in multiple containers isn't a common occurance.
 2434:     //
 2434:     // Only one match with a given id per container is active at a time. When
 2434:     // a match is active, content is generated for it. When a match is
 2434:     // inactive, content is not generated for it. A match becomes active if
 2434:     // another match with the same id and container with a lower priority
 2434:     // isn't already active, and the match has a rule or conditions clause
 2434:     // which evaluates to true. The former is checked by comparing the value
 2434:     // of the QuerySetPriority method of the match with earlier matches. The
 2434:     // latter is checked with the DetermineMatchedRule method.
 2434:     //
 2434:     // Naturally, if a match with a lower priority is active, it overrides
 2434:     // the new match, so the new match is hooked up into the match linked
 2434:     // list as inactive, and no content is generated for it. If a match with a
 2434:     // higher priority is active, and the new match's conditions evaluate
 2434:     // to true, then this existing match with the higher priority needs to have
 2434:     // its generated content removed and replaced with the new match's
 2434:     // generated content.
 2434:     //
 2434:     // Similar situations apply when removing an existing match. If the match
 2434:     // is active, the existing generated content will need to be removed, and
 2434:     // a match of higher priority that is revealed may become active and need
 2434:     // to have content generated.
 2434:     //
 2434:     // Content removal and generation is done by the ReplaceMatch method which
 2434:     // is overridden for the content builder and tree builder to update the
 2434:     // generated output for each type.
 2434:     //
 2434:     // The code below handles all of the various cases and ensures that the
 2434:     // match lists are maintained properly.
 2434: 
    1:     nsresult rv = NS_OK;
    1:     PRInt16 ruleindex;
    1:     nsTemplateRule* matchedrule = nsnull;
 2434: 
 2434:     // Indicates that the old match was active and must have its content
 2434:     // removed
79445:     bool oldMatchWasActive = false;
 2434: 
 2434:     // acceptedmatch will be set to a new match that has to have new content
 2434:     // generated for it. If a new match doesn't need to have content
 2434:     // generated, (because for example, a match with a lower priority
 2434:     // already applies), then acceptedmatch will be null, but the match will
 2434:     // be still hooked up into the chain, since it may become active later
 2434:     // as other results are updated.
 2434:     nsTemplateMatch* acceptedmatch = nsnull;
 2434: 
 2434:     // When aOldResult is specified, removematch will be set to the
 2434:     // corresponding match. This match needs to be deleted as it no longer
 2434:     // applies. However, removedmatch will be null when aOldResult is null, or
 2434:     // when no match was found corresponding to aOldResult.
 2434:     nsTemplateMatch* removedmatch = nsnull;
 2434: 
 2434:     // These will be set when aNewResult is specified indicating to add a
 2434:     // result, but will end up replacing an existing match. The former
 2434:     // indicates a match being replaced that was active and had content
 2434:     // generated for it, while the latter indicates a match that wasn't active
 2434:     // and just needs to be deleted. Both may point to different matches. For
 2434:     // example, if the new match becomes active, replacing an inactive match,
 2434:     // the inactive match will need to be deleted. However, if another match
 2434:     // with a higher priority is active, the new match will override it, so
 2434:     // content will need to be generated for the new match and removed for
 2434:     // this existing active match.
 2434:     nsTemplateMatch* replacedmatch = nsnull, * replacedmatchtodelete = nsnull;
    1: 
    1:     if (aOldResult) {
    1:         nsTemplateMatch* firstmatch;
    1:         if (mMatchMap.Get(aOldId, &firstmatch)) {
    1:             nsTemplateMatch* oldmatch = firstmatch;
    1:             nsTemplateMatch* prevmatch = nsnull;
    1: 
    1:             // look for the right match if there was more than one
    1:             while (oldmatch && (oldmatch->mResult != aOldResult)) {
    1:                 prevmatch = oldmatch;
    1:                 oldmatch = oldmatch->mNext;
    1:             }
    1: 
    1:             if (oldmatch) {
    1:                 nsTemplateMatch* findmatch = oldmatch->mNext;
    1: 
 2434:                 // Keep a reference so that linked list can be hooked up at
 2434:                 // the end in case an error occurs.
    1:                 nsTemplateMatch* nextmatch = findmatch;
    1: 
    1:                 if (oldmatch->IsActive()) {
 2434:                     // Indicate that the old match was active so its content
 2434:                     // will be removed later.
80486:                     oldMatchWasActive = true;
 2434: 
 2434:                     // The match being removed is the active match, so scan
    1:                     // through the later matches to determine if one should
    1:                     // now become the active match.
    1:                     while (findmatch) {
    1:                         // only other matches with the same container should
    1:                         // now match, leave other containers alone
    1:                         if (findmatch->GetContainer() == aInsertionPoint) {
    1:                             nsTemplateQuerySet* qs =
    1:                                 mQuerySets[findmatch->QuerySetPriority()];
    1:                         
    1:                             DetermineMatchedRule(aInsertionPoint, findmatch->mResult,
    1:                                                  qs, &matchedrule, &ruleindex);
    1: 
    1:                             if (matchedrule) {
    1:                                 rv = findmatch->RuleMatched(qs,
    1:                                                             matchedrule, ruleindex,
    1:                                                             findmatch->mResult);
    1:                                 if (NS_FAILED(rv))
    1:                                     return rv;
    1: 
    1:                                 acceptedmatch = findmatch;
    1:                                 break;
    1:                             }
    1:                         }
    1: 
    1:                         findmatch = findmatch->mNext;
    1:                     }
    1:                 }
    1: 
    1:                 if (oldmatch == firstmatch) {
    1:                     // the match to remove is at the beginning
    1:                     if (oldmatch->mNext) {
    1:                         if (!mMatchMap.Put(aOldId, oldmatch->mNext))
    1:                             return NS_ERROR_OUT_OF_MEMORY;
    1:                     }
    1:                     else {
    1:                         mMatchMap.Remove(aOldId);
    1:                     }
    1:                 }
    1: 
    1:                 if (prevmatch)
    1:                     prevmatch->mNext = nextmatch;
    1: 
    1:                 removedmatch = oldmatch;
37799:                 if (mFlags & eLoggingEnabled)
80486:                     OutputMatchToLog(aOldId, removedmatch, false);
    1:             }
    1:         }
    1:     }
    1: 
37799:     nsTemplateMatch *newmatch = nsnull;
    1:     if (aNewResult) {
    1:         // only allow a result to be inserted into containers with a matching tag
    1:         nsIAtom* tag = aQuerySet->GetTag();
    1:         if (aInsertionPoint && tag && tag != aInsertionPoint->Tag())
    1:             return NS_OK;
    1: 
    1:         PRInt32 findpriority = aQuerySet->Priority();
    1: 
37799:         newmatch = nsTemplateMatch::Create(mPool, findpriority,
    1:                                            aNewResult, aInsertionPoint);
    1:         if (!newmatch)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         nsTemplateMatch* firstmatch;
    1:         if (mMatchMap.Get(aNewId, &firstmatch)) {
79445:             bool hasEarlierActiveMatch = false;
    1: 
 2434:             // Scan through the existing matches to find where the new one
    1:             // should be inserted. oldmatch will be set to the old match for
 2434:             // the same query and prevmatch will be set to the match before it.
    1:             nsTemplateMatch* prevmatch = nsnull;
    1:             nsTemplateMatch* oldmatch = firstmatch;
    1:             while (oldmatch) {
 2434:                 // Break out once we've reached a query in the list with a
 2434:                 // lower priority. The new match will be inserted at this
 2434:                 // location so that the match list is sorted by priority.
    1:                 PRInt32 priority = oldmatch->QuerySetPriority();
    1:                 if (priority > findpriority) {
    1:                     oldmatch = nsnull;
    1:                     break;
    1:                 }
    1: 
 2434:                 // look for matches that belong in the same container
    1:                 if (oldmatch->GetContainer() == aInsertionPoint) {
    1:                     if (priority == findpriority)
    1:                         break;
    1: 
 2434:                     // If a match with a lower priority is active, the new
 2434:                     // match can't replace it.
    1:                     if (oldmatch->IsActive())
80486:                         hasEarlierActiveMatch = true;
    1:                 }
    1: 
    1:                 prevmatch = oldmatch;
    1:                 oldmatch = oldmatch->mNext;
    1:             }
    1: 
 2434:             // At this point, oldmatch will either be null, or set to a match
 2434:             // with the same container and priority. If set, oldmatch will
 2434:             // need to be replaced by newmatch.
 2434: 
    1:             if (oldmatch)
    1:                 newmatch->mNext = oldmatch->mNext;
    1:             else if (prevmatch)
    1:                 newmatch->mNext = prevmatch->mNext;
    1:             else
    1:                 newmatch->mNext = firstmatch;
    1: 
 2434:             // hasEarlierActiveMatch will be set to true if a match with a
 2434:             // lower priority was found. The new match won't replace it in
 2434:             // this case. If hasEarlierActiveMatch is false, then the new match
 2434:             // may be become active if it matches one of the rules, and will
 2434:             // generate output. It's also possible however, that a match with
 2434:             // the same priority already exists, which means that the new match
 2434:             // will replace the old one. In this case, oldmatch will be set to
 2434:             // the old match. The content for the old match must be removed and
 2434:             // content for the new match generated in its place.
    1:             if (! hasEarlierActiveMatch) {
 2434:                 // If the old match was the active match, set replacedmatch to
 2434:                 // indicate that it needs its content removed.
 2434:                 if (oldmatch) {
 2434:                     if (oldmatch->IsActive())
 2434:                         replacedmatch = oldmatch;
 2434:                     replacedmatchtodelete = oldmatch;
 2434:                 }
 2434: 
    1:                 // check if the new result matches the rules
    1:                 rv = DetermineMatchedRule(aInsertionPoint, newmatch->mResult,
    1:                                           aQuerySet, &matchedrule, &ruleindex);
    1:                 if (NS_FAILED(rv)) {
80486:                     nsTemplateMatch::Destroy(mPool, newmatch, false);
    1:                     return rv;
    1:                 }
    1: 
    1:                 if (matchedrule) {
    1:                     rv = newmatch->RuleMatched(aQuerySet,
    1:                                                matchedrule, ruleindex,
    1:                                                newmatch->mResult);
    1:                     if (NS_FAILED(rv)) {
80486:                         nsTemplateMatch::Destroy(mPool, newmatch, false);
    1:                         return rv;
    1:                     }
    1: 
 2434:                     // acceptedmatch may have been set in the block handling
 2434:                     // aOldResult earlier. If so, we would only get here when
 2434:                     // that match has a higher priority than this new match.
 2434:                     // As only one match can have content generated for it, it
 2434:                     // is OK to set acceptedmatch here to the new match,
 2434:                     // ignoring the other one.
    1:                     acceptedmatch = newmatch;
    1: 
 2434:                     // Clear the matched state of the later results for the
 2434:                     // same container.
    1:                     nsTemplateMatch* clearmatch = newmatch->mNext;
    1:                     while (clearmatch) {
 2434:                         if (clearmatch->GetContainer() == aInsertionPoint &&
 2434:                             clearmatch->IsActive()) {
    1:                             clearmatch->SetInactive();
 2434:                             // Replacedmatch should be null here. If not, it
 2434:                             // means that two matches were active which isn't
 2434:                             // a valid state
 2434:                             NS_ASSERTION(!replacedmatch,
 2434:                                          "replaced match already set");
 2434:                             replacedmatch = clearmatch;
 2434:                             break;
 2434:                         }
    1:                         clearmatch = clearmatch->mNext;
    1:                     }
    1:                 }
    1:                 else if (oldmatch && oldmatch->IsActive()) {
 2434:                     // The result didn't match the rules, so look for a later
    1:                     // one. However, only do this if the old match was the
 2434:                     // active match.
    1:                     newmatch = newmatch->mNext;
    1:                     while (newmatch) {
    1:                         if (newmatch->GetContainer() == aInsertionPoint) {
    1:                             rv = DetermineMatchedRule(aInsertionPoint, newmatch->mResult,
    1:                                                       aQuerySet, &matchedrule, &ruleindex);
    1:                             if (NS_FAILED(rv)) {
 2434:                                 nsTemplateMatch::Destroy(mPool, newmatch,
80486:                                                          false);
    1:                                 return rv;
    1:                             }
    1: 
    1:                             if (matchedrule) {
    1:                                 rv = newmatch->RuleMatched(aQuerySet,
    1:                                                            matchedrule, ruleindex,
    1:                                                            newmatch->mResult);
    1:                                 if (NS_FAILED(rv)) {
 2434:                                     nsTemplateMatch::Destroy(mPool, newmatch,
80486:                                                              false);
    1:                                     return rv;
    1:                                 }
    1: 
    1:                                 acceptedmatch = newmatch;
    1:                                 break;
    1:                             }
    1:                         }
    1: 
    1:                         newmatch = newmatch->mNext;
    1:                     }
    1:                 }
    1: 
 2434:                 // put the match in the map if there isn't a previous match
    1:                 if (! prevmatch) {
    1:                     if (!mMatchMap.Put(aNewId, newmatch)) {
 2434:                         // The match may have already matched a rule above, so
 2434:                         // HasBeenRemoved should be called to indicate that it
 2434:                         // is being removed again.
80486:                         nsTemplateMatch::Destroy(mPool, newmatch, true);
    1:                         return rv;
    1:                     }
    1:                 }
    1:             }
    1: 
    1:             // hook up the match last in case an error occurs
    1:             if (prevmatch)
    1:                 prevmatch->mNext = newmatch;
    1:         }
    1:         else {
 2434:             // The id is not used in the hashtable yet so create a new match
 2434:             // and add it to the hashtable.
    1:             rv = DetermineMatchedRule(aInsertionPoint, aNewResult,
    1:                                       aQuerySet, &matchedrule, &ruleindex);
    1:             if (NS_FAILED(rv)) {
80486:                 nsTemplateMatch::Destroy(mPool, newmatch, false);
    1:                 return rv;
    1:             }
    1: 
    1:             if (matchedrule) {
    1:                 rv = newmatch->RuleMatched(aQuerySet, matchedrule,
    1:                                            ruleindex, aNewResult);
    1:                 if (NS_FAILED(rv)) {
80486:                     nsTemplateMatch::Destroy(mPool, newmatch, false);
    1:                     return rv;
    1:                 }
    1: 
    1:                 acceptedmatch = newmatch;
    1:             }
    1: 
    1:             if (!mMatchMap.Put(aNewId, newmatch)) {
80486:                 nsTemplateMatch::Destroy(mPool, newmatch, true);
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:             }
    1:         }
    1:     }
    1: 
 2434:     // The ReplaceMatch method is builder specific and removes the generated
 2434:     // content for a match.
 2434: 
 2434:     // Remove the content for a match that was active and needs to be replaced.
37799:     if (replacedmatch) {
 2434:         rv = ReplaceMatch(replacedmatch->mResult, nsnull, nsnull,
 2434:                           aInsertionPoint);
 2434: 
37799:         if (mFlags & eLoggingEnabled)
80486:             OutputMatchToLog(aNewId, replacedmatch, false);
37799:     }
37799:  
 2434:     // remove a match that needs to be deleted.
 2434:     if (replacedmatchtodelete)
80486:         nsTemplateMatch::Destroy(mPool, replacedmatchtodelete, true);
 2434: 
 2434:     // If the old match was active, the content for it needs to be removed.
 2434:     // If the old match was not active, it shouldn't have had any content,
 2434:     // so just pass null to ReplaceMatch. If acceptedmatch was set, then
 2434:     // content needs to be generated for a new match.
 2434:     if (oldMatchWasActive || acceptedmatch)
 2434:         rv = ReplaceMatch(oldMatchWasActive ? aOldResult : nsnull,
 2434:                           acceptedmatch, matchedrule, aInsertionPoint);
 2434: 
 2434:     // delete the old match that was replaced
 2434:     if (removedmatch)
80486:         nsTemplateMatch::Destroy(mPool, removedmatch, true);
    1: 
37799:     if (mFlags & eLoggingEnabled && newmatch)
80486:         OutputMatchToLog(aNewId, newmatch, true);
37799: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::ResultBindingChanged(nsIXULTemplateResult* aResult)
    1: {
    1:     // A binding update is used when only the values of the bindings have
    1:     // changed, so the same rule still applies. Just synchronize the content.
    1:     // The new result will have the new values.
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1: 
54337:     if (!mRoot || !mQueriesCompiled)
54337:       return NS_OK;
54337: 
    1:     return SynchronizeResult(aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::GetRootResult(nsIXULTemplateResult** aResult)
    1: {
    1:   *aResult = mRootResult;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::GetResultForId(const nsAString& aId,
    1:                                      nsIXULTemplateResult** aResult)
    1: {
    1:     if (aId.IsEmpty())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsCOMPtr<nsIRDFResource> resource;
    1:     gRDFService->GetUnicodeResource(aId, getter_AddRefs(resource));
    1: 
    1:     *aResult = nsnull;
    1: 
    1:     nsTemplateMatch* match;
    1:     if (mMatchMap.Get(resource, &match)) {
    1:         // find the active match
    1:         while (match) {
    1:             if (match->IsActive()) {
    1:                 *aResult = match->mResult;
    1:                 NS_IF_ADDREF(*aResult);
    1:                 break;
    1:             }
    1:             match = match->mNext;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::GetResultForContent(nsIDOMElement* aContent,
    1:                                           nsIXULTemplateResult** aResult)
    1: {
    1:     *aResult = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::AddListener(nsIXULBuilderListener* aListener)
    1: {
    1:     NS_ENSURE_ARG(aListener);
    1: 
    1:     if (!mListeners.AppendObject(aListener))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTemplateBuilder::RemoveListener(nsIXULBuilderListener* aListener)
    1: {
    1:     NS_ENSURE_ARG(aListener);
    1: 
    1:     mListeners.RemoveObject(aListener);
    1: 
    1:     return NS_OK;
    1: }
    1: 
11693: NS_IMETHODIMP
11693: nsXULTemplateBuilder::Observe(nsISupports* aSubject,
11693:                               const char* aTopic,
11693:                               const PRUnichar* aData)
11693: {
11693:     // Uuuuber hack to clean up circular references that the cycle collector
11693:     // doesn't know about. See bug 394514.
11693:     if (!strcmp(aTopic, DOM_WINDOW_DESTROYED_TOPIC)) {
11693:         nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aSubject);
11693:         if (window) {
11693:             nsCOMPtr<nsIDocument> doc =
11693:                 do_QueryInterface(window->GetExtantDocument());
11696:             if (doc && doc == mObservedDocument)
11693:                 NodeWillBeDestroyed(doc);
11693:         }
78399:     } else if (!strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
78399:         UninitTrue();
11693:     }
11693:     return NS_OK;
11693: }
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIDocumentOberver interface
    1: //
    1: 
    1: void
    1: nsXULTemplateBuilder::AttributeChanged(nsIDocument* aDocument,
51350:                                        Element*     aElement,
    1:                                        PRInt32      aNameSpaceID,
    1:                                        nsIAtom*     aAttribute,
35535:                                        PRInt32      aModType)
    1: {
51350:     if (aElement == mRoot && aNameSpaceID == kNameSpaceID_None) {
    1:         // Check for a change to the 'ref' attribute on an atom, in which
    1:         // case we may need to nuke and rebuild the entire content model
    1:         // beneath the element.
    1:         if (aAttribute == nsGkAtoms::ref)
29228:             nsContentUtils::AddScriptRunner(
41361:                 NS_NewRunnableMethod(this, &nsXULTemplateBuilder::RunnableRebuild));
    1: 
    1:         // Check for a change to the 'datasources' attribute. If so, setup
17107:         // mDB by parsing the new value and rebuild.
    1:         else if (aAttribute == nsGkAtoms::datasources) {
29228:             nsContentUtils::AddScriptRunner(
56502:                 NS_NewRunnableMethod(this, &nsXULTemplateBuilder::RunnableLoadAndRebuild));
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsXULTemplateBuilder::ContentRemoved(nsIDocument* aDocument,
    1:                                      nsIContent* aContainer,
    1:                                      nsIContent* aChild,
48038:                                      PRInt32 aIndexInContainer,
48038:                                      nsIContent* aPreviousSibling)
    1: {
    1:     if (mRoot && nsContentUtils::ContentIsDescendantOf(mRoot, aChild)) {
    1:         nsRefPtr<nsXULTemplateBuilder> kungFuDeathGrip(this);
    1: 
    1:         if (mQueryProcessor)
    1:             mQueryProcessor->Done();
    1: 
56502:         // Pass false to Uninit since content is going away anyway
56502:         nsContentUtils::AddScriptRunner(
56502:             NS_NewRunnableMethod(this, &nsXULTemplateBuilder::UninitFalse));
    1: 
    1:         aDocument->RemoveObserver(this);
    1: 
    1:         nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(aDocument);
    1:         if (xuldoc)
    1:             xuldoc->SetTemplateBuilderFor(mRoot, nsnull);
    1: 
20665:         // clear the template state when removing content so that template
20665:         // content will be regenerated again if the content is reinserted
    1:         nsXULElement *xulcontent = nsXULElement::FromContent(mRoot);
20665:         if (xulcontent)
20665:             xulcontent->ClearTemplateGenerated();
    1: 
    1:         mDB = nsnull;
    1:         mCompDB = nsnull;
 3675:         mDataSource = nsnull;
    1:     }
    1: }
    1: 
    1: void
    1: nsXULTemplateBuilder::NodeWillBeDestroyed(const nsINode* aNode)
    1: {
    1:     // The call to RemoveObserver could release the last reference to
    1:     // |this|, so hold another reference.
    1:     nsRefPtr<nsXULTemplateBuilder> kungFuDeathGrip(this);
    1: 
    1:     // Break circular references
    1:     if (mQueryProcessor)
    1:         mQueryProcessor->Done();
    1: 
 2435:     mDataSource = nsnull;
    1:     mDB = nsnull;
    1:     mCompDB = nsnull;
    1: 
56502:     nsContentUtils::AddScriptRunner(
56502:         NS_NewRunnableMethod(this, &nsXULTemplateBuilder::UninitTrue));
    1: }
    1: 
    1: 
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // Implementation methods
    1: //
    1: 
    1: nsresult
 2435: nsXULTemplateBuilder::LoadDataSources(nsIDocument* aDocument,
79445:                                       bool* aShouldDelayBuilding)
    1: {
    1:     NS_PRECONDITION(mRoot != nsnull, "not initialized");
    1: 
    1:     nsresult rv;
79445:     bool isRDFQuery = false;
 2435:   
 2435:     // we'll set these again later, after we create a new composite ds
    1:     mDB = nsnull;
 2435:     mCompDB = nsnull;
 2435:     mDataSource = nsnull;
 2435: 
80486:     *aShouldDelayBuilding = false;
 2435: 
 2435:     nsAutoString datasources;
 2435:     mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::datasources, datasources);
 2435: 
 2435:     nsAutoString querytype;
 2435:     mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::querytype, querytype);
 2435: 
 2435:     // create the query processor. The querytype attribute on the root element
 2435:     // may be used to create one of a specific type.
 2435:   
 2435:     // XXX should non-chrome be restricted to specific names?
 2435:     if (querytype.IsEmpty())
 2435:         querytype.AssignLiteral("rdf");
 2435: 
 2435:     if (querytype.EqualsLiteral("rdf")) {
80486:         isRDFQuery = true;
 2435:         mQueryProcessor = new nsXULTemplateQueryProcessorRDF();
 2435:         NS_ENSURE_TRUE(mQueryProcessor, NS_ERROR_OUT_OF_MEMORY);
 2435:     }
 2435:     else if (querytype.EqualsLiteral("xml")) {
 2435:         mQueryProcessor = new nsXULTemplateQueryProcessorXML();
 2435:         NS_ENSURE_TRUE(mQueryProcessor, NS_ERROR_OUT_OF_MEMORY);
 2435:     }
 7942:     else if (querytype.EqualsLiteral("storage")) {
 7942:         mQueryProcessor = new nsXULTemplateQueryProcessorStorage();
 7942:         NS_ENSURE_TRUE(mQueryProcessor, NS_ERROR_OUT_OF_MEMORY);
 7942:     }
 2435:     else {
 2435:         nsCAutoString cid(NS_QUERY_PROCESSOR_CONTRACTID_PREFIX);
 2435:         AppendUTF16toUTF8(querytype, cid);
 2435:         mQueryProcessor = do_CreateInstance(cid.get(), &rv);
37799: 
37799:         if (!mQueryProcessor) {
37799:             nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_INVALID_QUERYPROCESSOR);
37799:             return rv;
37799:         }
 2435:     }
 2435: 
 2435:     rv = LoadDataSourceUrls(aDocument, datasources,
 2435:                             isRDFQuery, aShouldDelayBuilding);
 2435:     NS_ENSURE_SUCCESS(rv, rv);
 2435: 
 2435:     // Now set the database on the element, so that script writers can
 2435:     // access it.
 2435:     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(aDocument);
 2435:     if (xuldoc)
 2435:         xuldoc->SetTemplateBuilderFor(mRoot, this);
 2435: 
33329:     if (!mRoot->IsXUL()) {
 2435:         // Hmm. This must be an HTML element. Try to set it as a
 2435:         // JS property "by hand".
 2435:         InitHTMLTemplateRoot();
 2435:     }
 2435:   
 2435:     return NS_OK;
 2435: }
 2435:   
 2435: nsresult
 2435: nsXULTemplateBuilder::LoadDataSourceUrls(nsIDocument* aDocument,
 2435:                                          const nsAString& aDataSources,
79445:                                          bool aIsRDFQuery,
79445:                                          bool* aShouldDelayBuilding)
 2435: {
 2435:     // Grab the doc's principal...
 2435:     nsIPrincipal *docPrincipal = aDocument->NodePrincipal();
 2435: 
 2435:     NS_ASSERTION(docPrincipal == mRoot->NodePrincipal(),
 2435:                  "Principal mismatch?  Which one to use?");
 2435: 
79445:     bool isTrusted = false;
 2435:     nsresult rv = IsSystemPrincipal(docPrincipal, &isTrusted);
 2435:     NS_ENSURE_SUCCESS(rv, rv);
 2435: 
    1:     // Parse datasources: they are assumed to be a whitespace
    1:     // separated list of URIs; e.g.,
    1:     //
    1:     //     rdf:bookmarks rdf:history http://foo.bar.com/blah.cgi?baz=9
    1:     //
 2435:     nsIURI *docurl = aDocument->GetDocumentURI();
 2435: 
 3675:     nsCOMPtr<nsIMutableArray> uriList = do_CreateInstance(NS_ARRAY_CONTRACTID);
 3675:     if (!uriList)
 3675:         return NS_ERROR_FAILURE;
 3675: 
 2435:     nsAutoString datasources(aDataSources);
    1:     PRUint32 first = 0;
    1:     while (1) {
    1:         while (first < datasources.Length() && nsCRT::IsAsciiSpace(datasources.CharAt(first)))
    1:             ++first;
    1: 
    1:         if (first >= datasources.Length())
    1:             break;
    1: 
    1:         PRUint32 last = first;
    1:         while (last < datasources.Length() && !nsCRT::IsAsciiSpace(datasources.CharAt(last)))
    1:             ++last;
    1: 
    1:         nsAutoString uriStr;
    1:         datasources.Mid(uriStr, first, last - first);
    1:         first = last + 1;
    1: 
    1:         // A special 'dummy' datasource
    1:         if (uriStr.EqualsLiteral("rdf:null"))
    1:             continue;
    1: 
 3675:         if (uriStr.CharAt(0) == '#') {
 3675:             // ok, the datasource is certainly a node of the current document
 3675:             nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(aDocument);
 3675:             nsCOMPtr<nsIDOMElement> dsnode;
 3675: 
 3675:             domdoc->GetElementById(Substring(uriStr, 1),
 3675:                                    getter_AddRefs(dsnode));
 3675: 
 3675:             if (dsnode)
80486:                 uriList->AppendElement(dsnode, false);
 3675:             continue;
 3675:         }
 3675: 
    1:         // N.B. that `failure' (e.g., because it's an unknown
    1:         // protocol) leaves uriStr unaltered.
    1:         NS_MakeAbsoluteURI(uriStr, uriStr, docurl);
    1: 
 3675:         nsCOMPtr<nsIURI> uri;
 3675:         rv = NS_NewURI(getter_AddRefs(uri), uriStr);
 3675:         if (NS_FAILED(rv) || !uri)
 3675:             continue; // Necko will barf if our URI is weird
 3675: 
28253:         // don't add the uri to the list if the document is not allowed to
28253:         // load it
80486:         if (!isTrusted && NS_FAILED(docPrincipal->CheckMayLoad(uri, true)))
    1:           continue;
    1: 
80486:         uriList->AppendElement(uri, false);
 3675:     }
 3675: 
 3675:     nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(mRoot);
 3675:     rv = mQueryProcessor->GetDatasource(uriList,
 3675:                                         rootNode,
 3675:                                         isTrusted,
 3675:                                         this,
 3675:                                         aShouldDelayBuilding,
 3675:                                         getter_AddRefs(mDataSource));
 3675:     NS_ENSURE_SUCCESS(rv, rv);
 3675: 
 3675:     if (aIsRDFQuery && mDataSource) {  
 3675:         // check if we were given an inference engine type
 3675:         nsCOMPtr<nsIRDFInferDataSource> inferDB = do_QueryInterface(mDataSource);
 3675:         if (inferDB) {
    1:             nsCOMPtr<nsIRDFDataSource> ds;
 3675:             inferDB->GetBaseDataSource(getter_AddRefs(ds));
 3675:             if (ds)
 3675:                 mCompDB = do_QueryInterface(ds);
    1:         }
    1: 
 3675:         if (!mCompDB)
 3675:             mCompDB = do_QueryInterface(mDataSource);
 3675: 
 3675:         mDB = do_QueryInterface(mDataSource);
    1:     }
 3675: 
 3675:     if (!mDB && isTrusted) {
 3675:         gRDFService->GetDataSource("rdf:local-store", getter_AddRefs(mDB));
 2435:     }
 2435: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::InitHTMLTemplateRoot()
    1: {
    1:     // Use XPConnect and the JS APIs to whack mDB and this as the
    1:     // 'database' and 'builder' properties onto aElement.
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIDocument> doc = mRoot->GetDocument();
    1:     NS_ASSERTION(doc, "no document");
    1:     if (! doc)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     nsIScriptGlobalObject *global = doc->GetScriptGlobalObject();
    1:     if (! global)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     JSObject *scope = global->GetGlobalJSObject();
    1: 
    1:     nsIScriptContext *context = global->GetContext();
    1:     if (! context)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
78415:     JSContext* jscontext = context->GetNativeContext();
    1:     NS_ASSERTION(context != nsnull, "no jscontext");
    1:     if (! jscontext)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
 6630:     JSAutoRequest ar(jscontext);
 6630: 
31981:     jsval v;
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
48171:     rv = nsContentUtils::WrapNative(jscontext, scope, mRoot, mRoot, &v,
    1:                                     getter_AddRefs(wrapper));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
31981:     JSObject* jselement = JSVAL_TO_OBJECT(v);
    1: 
 2435:     if (mDB) {
    1:         // database
31981:         jsval jsdatabase;
31981:         rv = nsContentUtils::WrapNative(jscontext, scope, mDB,
31981:                                         &NS_GET_IID(nsIRDFCompositeDataSource),
31981:                                         &jsdatabase, getter_AddRefs(wrapper));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:         bool ok;
    1:         ok = JS_SetProperty(jscontext, jselement, "database", &jsdatabase);
    1:         NS_ASSERTION(ok, "unable to set database property");
    1:         if (! ok)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     {
    1:         // builder
31981:         jsval jsbuilder;
    1:         nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
31981:         rv = nsContentUtils::WrapNative(jscontext, jselement,
 3233:                                         static_cast<nsIXULTemplateBuilder*>(this),
31981:                                         &NS_GET_IID(nsIXULTemplateBuilder),
31981:                                         &jsbuilder, getter_AddRefs(wrapper));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:         bool ok;
    1:         ok = JS_SetProperty(jscontext, jselement, "builder", &jsbuilder);
    1:         if (! ok)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::DetermineMatchedRule(nsIContent *aContainer,
    1:                                            nsIXULTemplateResult* aResult,
    1:                                            nsTemplateQuerySet* aQuerySet,
    1:                                            nsTemplateRule** aMatchedRule,
    1:                                            PRInt16 *aRuleIndex)
    1: {
    1:     // iterate through the rules and look for one that the result matches
    1:     PRInt16 count = aQuerySet->RuleCount();
    1:     for (PRInt16 r = 0; r < count; r++) {
    1:         nsTemplateRule* rule = aQuerySet->GetRuleAt(r);
    1:         // If a tag was specified, it must match the tag of the container
    1:         // where content is being inserted.
    1:         nsIAtom* tag = rule->GetTag();
    1:         if ((!aContainer || !tag || tag == aContainer->Tag()) &&
    1:             rule->CheckMatch(aResult)) {
    1:             *aMatchedRule = rule;
    1:             *aRuleIndex = r;
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     *aRuleIndex = -1;
    1:     *aMatchedRule = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsXULTemplateBuilder::ParseAttribute(const nsAString& aAttributeValue,
    1:                                      void (*aVariableCallback)(nsXULTemplateBuilder*, const nsAString&, void*),
    1:                                      void (*aTextCallback)(nsXULTemplateBuilder*, const nsAString&, void*),
    1:                                      void* aClosure)
    1: {
    1:     nsAString::const_iterator done_parsing;
    1:     aAttributeValue.EndReading(done_parsing);
    1: 
    1:     nsAString::const_iterator iter;
    1:     aAttributeValue.BeginReading(iter);
    1: 
    1:     nsAString::const_iterator mark(iter), backup(iter);
    1: 
    1:     for (; iter != done_parsing; backup = ++iter) {
    1:         // A variable is either prefixed with '?' (in the extended
    1:         // syntax) or "rdf:" (in the simple syntax).
79445:         bool isvar;
    1:         if (*iter == PRUnichar('?') && (++iter != done_parsing)) {
80486:             isvar = true;
    1:         }
    1:         else if ((*iter == PRUnichar('r') && (++iter != done_parsing)) &&
    1:                  (*iter == PRUnichar('d') && (++iter != done_parsing)) &&
    1:                  (*iter == PRUnichar('f') && (++iter != done_parsing)) &&
    1:                  (*iter == PRUnichar(':') && (++iter != done_parsing))) {
80486:             isvar = true;
    1:         }
    1:         else {
80486:             isvar = false;
    1:         }
    1: 
    1:         if (! isvar) {
    1:             // It's not a variable, or we ran off the end of the
    1:             // string after the initial variable prefix. Since we may
    1:             // have slurped down some characters before realizing that
    1:             // fact, back up to the point where we started.
    1:             iter = backup;
    1:             continue;
    1:         }
    1:         else if (backup != mark && aTextCallback) {
    1:             // Okay, we've found a variable, and there's some vanilla
    1:             // text that's been buffered up. Flush it.
    1:             (*aTextCallback)(this, Substring(mark, backup), aClosure);
    1:         }
    1: 
    1:         if (*iter == PRUnichar('?')) {
    1:             // Well, it was not really a variable, but "??". We use one
    1:             // question mark (the second one, actually) literally.
    1:             mark = iter;
    1:             continue;
    1:         }
    1: 
    1:         // Construct a substring that is the symbol we need to look up
    1:         // in the rule's symbol table. The symbol is terminated by a
    1:         // space character, a caret, or the end of the string,
    1:         // whichever comes first.
    1:         nsAString::const_iterator first(backup);
    1: 
    1:         PRUnichar c = 0;
    1:         while (iter != done_parsing) {
    1:             c = *iter;
    1:             if ((c == PRUnichar(' ')) || (c == PRUnichar('^')))
    1:                 break;
    1: 
    1:             ++iter;
    1:         }
    1: 
    1:         nsAString::const_iterator last(iter);
    1: 
    1:         // Back up so we don't consume the terminating character
    1:         // *unless* the terminating character was a caret: the caret
    1:         // means "concatenate with no space in between".
    1:         if (c != PRUnichar('^'))
    1:             --iter;
    1: 
    1:         (*aVariableCallback)(this, Substring(first, last), aClosure);
    1:         mark = iter;
    1:         ++mark;
    1:     }
    1: 
    1:     if (backup != mark && aTextCallback) {
    1:         // If there's any text left over, then fire the text callback
    1:         (*aTextCallback)(this, Substring(mark, backup), aClosure);
    1:     }
    1: }
    1: 
    1: 
15594: struct NS_STACK_CLASS SubstituteTextClosure {
    1:     SubstituteTextClosure(nsIXULTemplateResult* aResult, nsAString& aString)
    1:         : result(aResult), str(aString) {}
    1: 
    1:     // some datasources are lazily initialized or modified while values are
    1:     // being retrieved, causing results to be removed. Due to this, hold a
    1:     // strong reference to the result.
    1:     nsCOMPtr<nsIXULTemplateResult> result;
    1:     nsAString& str;
    1: };
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::SubstituteText(nsIXULTemplateResult* aResult,
    1:                                      const nsAString& aAttributeValue,
    1:                                      nsAString& aString)
    1: {
    1:     // See if it's the special value "..."
    1:     if (aAttributeValue.EqualsLiteral("...")) {
    1:         aResult->GetId(aString);
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Reasonable guess at how big it should be
    1:     aString.SetCapacity(aAttributeValue.Length());
    1: 
    1:     SubstituteTextClosure closure(aResult, aString);
    1:     ParseAttribute(aAttributeValue,
    1:                    SubstituteTextReplaceVariable,
    1:                    SubstituteTextAppendText,
    1:                    &closure);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsXULTemplateBuilder::SubstituteTextAppendText(nsXULTemplateBuilder* aThis,
    1:                                                const nsAString& aText,
    1:                                                void* aClosure)
    1: {
    1:     // Append aString to the closure's result
 3233:     SubstituteTextClosure* c = static_cast<SubstituteTextClosure*>(aClosure);
    1:     c->str.Append(aText);
    1: }
    1: 
    1: void
    1: nsXULTemplateBuilder::SubstituteTextReplaceVariable(nsXULTemplateBuilder* aThis,
    1:                                                     const nsAString& aVariable,
    1:                                                     void* aClosure)
    1: {
    1:     // Substitute the value for the variable and append to the
    1:     // closure's result.
 3233:     SubstituteTextClosure* c = static_cast<SubstituteTextClosure*>(aClosure);
    1: 
    1:     nsAutoString replacementText;
    1: 
    1:     // The symbol "rdf:*" is special, and means "this guy's URI"
    1:     if (aVariable.EqualsLiteral("rdf:*")){
    1:         c->result->GetId(replacementText);
    1:     }
    1:     else {
    1:         // Got a variable; get the value it's assigned to
    1:         nsCOMPtr<nsIAtom> var = do_GetAtom(aVariable);
    1:         c->result->GetBindingFor(var, replacementText);
    1:     }
    1: 
    1:     c->str += replacementText;
    1: }
    1: 
79445: bool
    1: nsXULTemplateBuilder::IsTemplateElement(nsIContent* aContent)
    1: {
    1:     return aContent->NodeInfo()->Equals(nsGkAtoms::_template,
    1:                                         kNameSpaceID_XUL);
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::GetTemplateRoot(nsIContent** aResult)
    1: {
    1:     NS_PRECONDITION(mRoot != nsnull, "not initialized");
    1:     if (! mRoot)
    1:         return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:     // First, check and see if the root has a template attribute. This
    1:     // allows a template to be specified "out of line"; e.g.,
    1:     //
    1:     //   <window>
    1:     //     <foo template="MyTemplate">...</foo>
    1:     //     <template id="MyTemplate">...</template>
    1:     //   </window>
    1:     //
    1:     nsAutoString templateID;
    1:     mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::_template, templateID);
    1: 
    1:     if (! templateID.IsEmpty()) {
    1:         nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(mRoot->GetDocument());
    1:         if (! domDoc)
    1:             return NS_OK;
    1: 
    1:         nsCOMPtr<nsIDOMElement> domElement;
    1:         domDoc->GetElementById(templateID, getter_AddRefs(domElement));
    1: 
31179:         if (domElement) {
31179:             nsCOMPtr<nsIContent> content = do_QueryInterface(domElement);
31179:             NS_ENSURE_STATE(content &&
31179:                             !nsContentUtils::ContentIsDescendantOf(mRoot,
31179:                                                                    content));
31179:             content.forget(aResult);
31179:             return NS_OK;
31179:         }
    1:     }
    1: 
    1: #if 1 // XXX hack to workaround bug with XBL insertion/removal?
    1:     {
    1:         // If root node has no template attribute, then look for a child
    1:         // node which is a template tag
78992:         for (nsIContent* child = mRoot->GetFirstChild();
78992:              child;
78992:              child = child->GetNextSibling()) {
    1: 
    1:             if (IsTemplateElement(child)) {
    1:                 NS_ADDREF(*aResult = child);
    1:                 return NS_OK;
    1:             }
    1:         }
    1:     }
    1: #endif
    1: 
    1:     // If we couldn't find a real child, look through the anonymous
    1:     // kids, too.
    1:     nsCOMPtr<nsIDocument> doc = mRoot->GetDocument();
    1:     if (! doc)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIDOMNodeList> kids;
    1:     doc->BindingManager()->GetXBLChildNodesFor(mRoot, getter_AddRefs(kids));
    1: 
    1:     if (kids) {
    1:         PRUint32 length;
    1:         kids->GetLength(&length);
    1: 
    1:         for (PRUint32 i = 0; i < length; ++i) {
    1:             nsCOMPtr<nsIDOMNode> node;
    1:             kids->Item(i, getter_AddRefs(node));
    1:             if (! node)
    1:                 continue;
    1: 
    1:             nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1: 
    1:             if (IsTemplateElement(child)) {
    1:                 NS_ADDREF(*aResult = child.get());
    1:                 return NS_OK;
    1:             }
    1:         }
    1:     }
    1: 
    1:     *aResult = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileQueries()
    1: {
    1:     nsCOMPtr<nsIContent> tmpl;
    1:     GetTemplateRoot(getter_AddRefs(tmpl));
    1:     if (! tmpl)
    1:         return NS_OK;
    1: 
    1:     if (! mRoot)
    1:         return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:     // Determine if there are any special settings we need to observe
    1:     mFlags = 0;
    1: 
    1:     nsAutoString flags;
    1:     mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::flags, flags);
    1: 
    1:     // if the dont-test-empty flag is set, containers should not be checked to
22940:     // see if they are empty. If dont-recurse is set, then don't process the
37799:     // template recursively and only show one level of results. The logging
37799:     // flag logs errors and results to the console, which is useful when
37799:     // debugging templates.
22940:     nsWhitespaceTokenizer tokenizer(flags);
22940:     while (tokenizer.hasMoreTokens()) {
22940:       const nsDependentSubstring& token(tokenizer.nextToken());
22940:       if (token.EqualsLiteral("dont-test-empty"))
    1:         mFlags |= eDontTestEmpty;
22940:       else if (token.EqualsLiteral("dont-recurse"))
    1:         mFlags |= eDontRecurse;
37799:       else if (token.EqualsLiteral("logging"))
37799:         mFlags |= eLoggingEnabled;
22940:     }
    1: 
37799: #ifdef PR_LOGGING
37799:     // always enable logging if the debug setting is used
37799:     if (PR_LOG_TEST(gXULTemplateLog, PR_LOG_DEBUG))
37799:         mFlags |= eLoggingEnabled;
37799: #endif
37799: 
    1:     nsCOMPtr<nsIDOMNode> rootnode = do_QueryInterface(mRoot);
 2435:     nsresult rv =
 2435:         mQueryProcessor->InitializeForBuilding(mDataSource, this, rootnode);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Set the "container" and "member" variables, if the user has specified
    1:     // them. The container variable may be specified with the container
    1:     // attribute on the <template> and the member variable may be specified
    1:     // using the member attribute or the value of the uri attribute inside the
    1:     // first action body in the template. If not specified, the container
    1:     // variable defaults to '?uri' and the member variable defaults to '?' or
    1:     // 'rdf:*' for simple queries.
    1: 
    1:     // For RDF queries, the container variable may also be set via the
    1:     // <content> tag.
    1: 
    1:     nsAutoString containervar;
    1:     tmpl->GetAttr(kNameSpaceID_None, nsGkAtoms::container, containervar);
    1: 
    1:     if (containervar.IsEmpty())
    1:         mRefVariable = do_GetAtom("?uri");
    1:     else
    1:         mRefVariable = do_GetAtom(containervar);
    1: 
    1:     nsAutoString membervar;
    1:     tmpl->GetAttr(kNameSpaceID_None, nsGkAtoms::member, membervar);
    1: 
    1:     if (membervar.IsEmpty())
    1:         mMemberVariable = nsnull;
    1:     else
    1:         mMemberVariable = do_GetAtom(membervar);
    1: 
    1:     nsTemplateQuerySet* queryset = new nsTemplateQuerySet(0);
    1:     if (!queryset)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (!mQuerySets.AppendElement(queryset)) {
    1:         delete queryset;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
79445:     bool canUseTemplate = false;
    1:     PRInt32 priority = 0;
80486:     rv = CompileTemplate(tmpl, queryset, false, &priority, &canUseTemplate);
    1: 
    1:     if (NS_FAILED(rv) || !canUseTemplate) {
    1:         for (PRInt32 q = mQuerySets.Length() - 1; q >= 0; q--) {
    1:             nsTemplateQuerySet* qs = mQuerySets[q];
    1:             delete qs;
    1:         }
    1:         mQuerySets.Clear();
    1:     }
    1: 
80486:     mQueriesCompiled = true;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileTemplate(nsIContent* aTemplate,
    1:                                       nsTemplateQuerySet* aQuerySet,
79445:                                       bool aIsQuerySet,
    1:                                       PRInt32* aPriority,
79445:                                       bool* aCanUseTemplate)
    1: {
    1:     NS_ASSERTION(aQuerySet, "No queryset supplied");
    1: 
    1:     nsresult rv = NS_OK;
    1: 
79445:     bool isQuerySetMode = false;
79445:     bool hasQuerySet = false, hasRule = false, hasQuery = false;
    1: 
78992:     for (nsIContent* rulenode = aTemplate->GetFirstChild();
78992:          rulenode;
78992:          rulenode = rulenode->GetNextSibling()) {
78992: 
    1:         nsINodeInfo *ni = rulenode->NodeInfo();
    1: 
    1:         // don't allow more queries than can be supported
    1:         if (*aPriority == PR_INT16_MAX)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         // XXXndeakin queryset isn't a good name for this tag since it only
    1:         //            ever contains one query
    1:         if (!aIsQuerySet && ni->Equals(nsGkAtoms::queryset, kNameSpaceID_XUL)) {
37799:             if (hasRule || hasQuery) {
37799:               nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_INVALID_QUERYSET);
    1:               continue;
37799:             }
    1: 
80486:             isQuerySetMode = true;
    1: 
    1:             // only create a queryset for those after the first since the
    1:             // first one is always created by CompileQueries
    1:             if (hasQuerySet) {
    1:                 aQuerySet = new nsTemplateQuerySet(++*aPriority);
    1:                 if (!aQuerySet)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                 // once the queryset is appended to the mQuerySets list, it
    1:                 // will be removed by CompileQueries if an error occurs
    1:                 if (!mQuerySets.AppendElement(aQuerySet)) {
    1:                     delete aQuerySet;
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 }
    1:             }
    1: 
80486:             hasQuerySet = true;
80486: 
80486:             rv = CompileTemplate(rulenode, aQuerySet, true, aPriority, aCanUseTemplate);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1: 
    1:         // once a queryset is used, everything must be a queryset
    1:         if (isQuerySetMode)
    1:             continue;
    1: 
    1:         if (ni->Equals(nsGkAtoms::rule, kNameSpaceID_XUL)) {
    1:             nsCOMPtr<nsIContent> action;
    1:             nsXULContentUtils::FindChildByTag(rulenode,
    1:                                               kNameSpaceID_XUL,
    1:                                               nsGkAtoms::action,
    1:                                               getter_AddRefs(action));
    1: 
    1:             if (action){
36212:                 nsCOMPtr<nsIAtom> memberVariable = mMemberVariable;
36212:                 if (!memberVariable) {
36212:                     memberVariable = DetermineMemberVariable(action);
37799:                     if (!memberVariable) {
37799:                         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_NO_MEMBERVAR);
37799:                         continue;
37799:                     }
36212:                 }
    1: 
    1:                 if (hasQuery) {
 3047:                     nsCOMPtr<nsIAtom> tag;
 3047:                     DetermineRDFQueryRef(aQuerySet->mQueryNode,
 3047:                                          getter_AddRefs(tag));
 3047:                     if (tag)
 3047:                         aQuerySet->SetTag(tag);
 3047: 
    1:                     if (! aQuerySet->mCompiledQuery) {
    1:                         nsCOMPtr<nsIDOMNode> query(do_QueryInterface(aQuerySet->mQueryNode));
    1: 
    1:                         rv = mQueryProcessor->CompileQuery(this, query,
    1:                                                            mRefVariable, memberVariable,
    1:                                                            getter_AddRefs(aQuerySet->mCompiledQuery));
    1:                         if (NS_FAILED(rv))
    1:                             return rv;
    1:                     }
    1: 
    1:                     if (aQuerySet->mCompiledQuery) {
    1:                         rv = CompileExtendedQuery(rulenode, action, memberVariable,
    1:                                                   aQuerySet);
    1:                         if (NS_FAILED(rv))
    1:                             return rv;
    1: 
80486:                         *aCanUseTemplate = true;
    1:                     }
    1:                 }
    1:                 else {
    1:                     // backwards-compatible RDF template syntax where there is
    1:                     // an <action> node but no <query> node. In this case,
    1:                     // use the conditions as if it was the query.
    1: 
    1:                     nsCOMPtr<nsIContent> conditions;
    1:                     nsXULContentUtils::FindChildByTag(rulenode,
    1:                                                       kNameSpaceID_XUL,
    1:                                                       nsGkAtoms::conditions,
    1:                                                       getter_AddRefs(conditions));
    1: 
    1:                     if (conditions) {
    1:                         // create a new queryset if one hasn't been created already
    1:                         if (hasQuerySet) {
    1:                             aQuerySet = new nsTemplateQuerySet(++*aPriority);
    1:                             if (! aQuerySet)
    1:                                 return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                             if (!mQuerySets.AppendElement(aQuerySet)) {
    1:                                 delete aQuerySet;
    1:                                 return NS_ERROR_OUT_OF_MEMORY;
    1:                             }
    1:                         }
    1: 
    1:                         nsCOMPtr<nsIAtom> tag;
    1:                         DetermineRDFQueryRef(conditions, getter_AddRefs(tag));
    1:                         if (tag)
    1:                             aQuerySet->SetTag(tag);
    1: 
80486:                         hasQuerySet = true;
    1: 
    1:                         nsCOMPtr<nsIDOMNode> conditionsnode(do_QueryInterface(conditions));
    1: 
    1:                         aQuerySet->mQueryNode = conditions;
    1:                         rv = mQueryProcessor->CompileQuery(this, conditionsnode,
    1:                                                            mRefVariable,
    1:                                                            memberVariable,
    1:                                                            getter_AddRefs(aQuerySet->mCompiledQuery));
    1:                         if (NS_FAILED(rv))
    1:                             return rv;
    1: 
    1:                         if (aQuerySet->mCompiledQuery) {
    1:                             rv = CompileExtendedQuery(rulenode, action, memberVariable,
    1:                                                       aQuerySet);
    1:                             if (NS_FAILED(rv))
    1:                                 return rv;
    1: 
80486:                             *aCanUseTemplate = true;
    1:                         }
    1:                     }
    1:                 }
    1:             }
    1:             else {
    1:                 if (hasQuery)
    1:                     continue;
    1: 
    1:                 // a new queryset must always be created in this case
    1:                 if (hasQuerySet) {
    1:                     aQuerySet = new nsTemplateQuerySet(++*aPriority);
    1:                     if (! aQuerySet)
    1:                         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                     if (!mQuerySets.AppendElement(aQuerySet)) {
    1:                         delete aQuerySet;
    1:                         return NS_ERROR_OUT_OF_MEMORY;
    1:                     }
    1:                 }
    1: 
80486:                 hasQuerySet = true;
    1: 
    1:                 rv = CompileSimpleQuery(rulenode, aQuerySet, aCanUseTemplate);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1:             }
    1: 
80486:             hasRule = true;
    1:         }
    1:         else if (ni->Equals(nsGkAtoms::query, kNameSpaceID_XUL)) {
    1:             if (hasQuery)
    1:               continue;
    1: 
    1:             aQuerySet->mQueryNode = rulenode;
80486:             hasQuery = true;
    1:         }
    1:         else if (ni->Equals(nsGkAtoms::action, kNameSpaceID_XUL)) {
    1:             // the query must appear before the action
    1:             if (! hasQuery)
    1:                 continue;
    1: 
    1:             nsCOMPtr<nsIAtom> tag;
    1:             DetermineRDFQueryRef(aQuerySet->mQueryNode, getter_AddRefs(tag));
    1:             if (tag)
    1:                 aQuerySet->SetTag(tag);
    1: 
36212:             nsCOMPtr<nsIAtom> memberVariable = mMemberVariable;
36212:             if (!memberVariable) {
36212:                 memberVariable = DetermineMemberVariable(rulenode);
37799:                 if (!memberVariable) {
37799:                     nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_NO_MEMBERVAR);
37799:                     continue;
37799:                 }
36212:             }
    1: 
    1:             nsCOMPtr<nsIDOMNode> query(do_QueryInterface(aQuerySet->mQueryNode));
    1: 
    1:             rv = mQueryProcessor->CompileQuery(this, query,
    1:                                                mRefVariable, memberVariable,
    1:                                                getter_AddRefs(aQuerySet->mCompiledQuery));
    1: 
    1:             if (aQuerySet->mCompiledQuery) {
26621:                 nsTemplateRule* rule = aQuerySet->NewRule(aTemplate, rulenode, aQuerySet);
    1:                 if (! rule)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                 rule->SetVars(mRefVariable, memberVariable);
    1: 
80486:                 *aCanUseTemplate = true;
    1: 
    1:                 return NS_OK;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (! hasRule && ! hasQuery && ! hasQuerySet) {
    1:         // if no rules are specified in the template, then the contents of the
    1:         // <template> tag are the one-and-only template.
    1:         rv = CompileSimpleQuery(aTemplate, aQuerySet, aCanUseTemplate);
    1:      }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileExtendedQuery(nsIContent* aRuleElement,
    1:                                            nsIContent* aActionElement,
    1:                                            nsIAtom* aMemberVariable,
    1:                                            nsTemplateQuerySet* aQuerySet)
    1: {
    1:     // Compile an "extended" <template> rule. An extended rule may have
    1:     // a <conditions> child, an <action> child, and a <bindings> child.
    1:     nsresult rv;
    1: 
26621:     nsTemplateRule* rule = aQuerySet->NewRule(aRuleElement, aActionElement, aQuerySet);
    1:     if (! rule)
    1:          return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsCOMPtr<nsIContent> conditions;
    1:     nsXULContentUtils::FindChildByTag(aRuleElement,
    1:                                       kNameSpaceID_XUL,
    1:                                       nsGkAtoms::conditions,
    1:                                       getter_AddRefs(conditions));
    1: 
 2435:     // allow the conditions to be placed directly inside the rule
 2435:     if (!conditions)
 2435:         conditions = aRuleElement;
 2435:   
    1:     rv = CompileConditions(rule, conditions);
    1:     // If the rule compilation failed, then we have to bail.
    1:     if (NS_FAILED(rv)) {
26621:         aQuerySet->RemoveRule(rule);
    1:         return rv;
    1:     }
    1: 
    1:     rule->SetVars(mRefVariable, aMemberVariable);
    1: 
    1:     // If we've got bindings, add 'em.
    1:     nsCOMPtr<nsIContent> bindings;
    1:     nsXULContentUtils::FindChildByTag(aRuleElement,
    1:                                       kNameSpaceID_XUL,
    1:                                       nsGkAtoms::bindings,
    1:                                       getter_AddRefs(bindings));
    1: 
 2435:     // allow bindings to be placed directly inside rule
 2435:     if (!bindings)
 2435:         bindings = aRuleElement;
 2435: 
    1:     rv = CompileBindings(rule, bindings);
 2435:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     return NS_OK;
    1: }
    1: 
36212: already_AddRefed<nsIAtom>
36212: nsXULTemplateBuilder::DetermineMemberVariable(nsIContent* aElement)
    1: {
36212:     // recursively iterate over the children looking for an element
36212:     // with uri="?..."
77283:     for (nsIContent* child = aElement->GetFirstChild();
77283:          child;
77283:          child = child->GetNextSibling()) {
36212:         nsAutoString uri;
36212:         child->GetAttr(kNameSpaceID_None, nsGkAtoms::uri, uri);
36212:         if (!uri.IsEmpty() && uri[0] == PRUnichar('?')) {
36212:             return NS_NewAtom(uri);
    1:         }
36212: 
36212:         nsCOMPtr<nsIAtom> result = DetermineMemberVariable(child);
36212:         if (result) {
36212:             return result.forget();
    1:         }
    1:     }
36212: 
36212:     return nsnull;
    1: }
    1: 
    1: void
    1: nsXULTemplateBuilder::DetermineRDFQueryRef(nsIContent* aQueryElement, nsIAtom** aTag)
    1: {
    1:     // check for a tag
    1:     nsCOMPtr<nsIContent> content;
    1:     nsXULContentUtils::FindChildByTag(aQueryElement,
    1:                                       kNameSpaceID_XUL,
    1:                                       nsGkAtoms::content,
    1:                                       getter_AddRefs(content));
    1: 
    1:     if (! content) {
    1:         // look for older treeitem syntax as well
    1:         nsXULContentUtils::FindChildByTag(aQueryElement,
    1:                                           kNameSpaceID_XUL,
    1:                                           nsGkAtoms::treeitem,
    1:                                           getter_AddRefs(content));
    1:     }
    1: 
    1:     if (content) {
    1:         nsAutoString uri;
    1:         content->GetAttr(kNameSpaceID_None, nsGkAtoms::uri, uri);
    1: 
    1:         if (!uri.IsEmpty())
    1:             mRefVariable = do_GetAtom(uri);
    1: 
    1:         nsAutoString tag;
    1:         content->GetAttr(kNameSpaceID_None, nsGkAtoms::tag, tag);
    1: 
    1:         if (!tag.IsEmpty())
    1:             *aTag = NS_NewAtom(tag);
    1:     }
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileSimpleQuery(nsIContent* aRuleElement,
    1:                                          nsTemplateQuerySet* aQuerySet,
79445:                                          bool* aCanUseTemplate)
    1: {
    1:     // compile a simple query, which is a query with no <query> or
    1:     // <conditions>. This means that a default query is used.
    1:     nsCOMPtr<nsIDOMNode> query(do_QueryInterface(aRuleElement));
    1: 
    1:     nsCOMPtr<nsIAtom> memberVariable;
    1:     if (mMemberVariable)
    1:         memberVariable = mMemberVariable;
    1:     else
    1:         memberVariable = do_GetAtom("rdf:*");
    1: 
    1:     // since there is no <query> node for a simple query, the query node will
    1:     // be either the <rule> node if multiple rules are used, or the <template> node.
    1:     aQuerySet->mQueryNode = aRuleElement;
    1:     nsresult rv = mQueryProcessor->CompileQuery(this, query,
    1:                                                 mRefVariable, memberVariable,
    1:                                                 getter_AddRefs(aQuerySet->mCompiledQuery));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (! aQuerySet->mCompiledQuery) {
80486:         *aCanUseTemplate = false;
    1:         return NS_OK;
    1:     }
    1: 
26621:     nsTemplateRule* rule = aQuerySet->NewRule(aRuleElement, aRuleElement, aQuerySet);
    1:     if (! rule)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     rule->SetVars(mRefVariable, memberVariable);
    1: 
    1:     nsAutoString tag;
    1:     aRuleElement->GetAttr(kNameSpaceID_None, nsGkAtoms::parent, tag);
    1: 
    1:     if (!tag.IsEmpty()) {
    1:         nsCOMPtr<nsIAtom> tagatom = do_GetAtom(tag);
    1:         aQuerySet->SetTag(tagatom);
    1:     }
    1: 
80486:     *aCanUseTemplate = true;
    1: 
    1:     return AddSimpleRuleBindings(rule, aRuleElement);
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileConditions(nsTemplateRule* aRule,
    1:                                         nsIContent* aCondition)
    1: {
    1:     nsAutoString tag;
    1:     aCondition->GetAttr(kNameSpaceID_None, nsGkAtoms::parent, tag);
    1: 
    1:     if (!tag.IsEmpty()) {
    1:         nsCOMPtr<nsIAtom> tagatom = do_GetAtom(tag);
    1:         aRule->SetTag(tagatom);
    1:     }
    1: 
    1:     nsTemplateCondition* currentCondition = nsnull;
    1: 
78992:     for (nsIContent* node = aCondition->GetFirstChild();
78992:          node;
78992:          node = node->GetNextSibling()) {
    1: 
    1:         if (node->NodeInfo()->Equals(nsGkAtoms::where, kNameSpaceID_XUL)) {
    1:             nsresult rv = CompileWhereCondition(aRule, node, &currentCondition);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileWhereCondition(nsTemplateRule* aRule,
    1:                                             nsIContent* aCondition,
    1:                                             nsTemplateCondition** aCurrentCondition)
    1: {
    1:     // Compile a <where> condition, which must be of the form:
    1:     //
    1:     //   <where subject="?var1|string" rel="relation" value="?var2|string" />
    1:     //
    1:     //    The value of rel may be:
    1:     //      equal - subject must be equal to object
    1:     //      notequal - subject must not be equal to object
    1:     //      less - subject must be less than object
    1:     //      greater - subject must be greater than object
    1:     //      startswith - subject must start with object
    1:     //      endswith - subject must end with object
    1:     //      contains - subject must contain object
    1:     //    Comparisons are done as strings unless the subject is an integer.
    1: 
    1:     // subject
    1:     nsAutoString subject;
    1:     aCondition->GetAttr(kNameSpaceID_None, nsGkAtoms::subject, subject);
37799:     if (subject.IsEmpty()) {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_WHERE_NO_SUBJECT);
    1:         return NS_OK;
37799:     }
    1: 
    1:     nsCOMPtr<nsIAtom> svar;
    1:     if (subject[0] == PRUnichar('?'))
    1:         svar = do_GetAtom(subject);
    1: 
    1:     nsAutoString relstring;
    1:     aCondition->GetAttr(kNameSpaceID_None, nsGkAtoms::rel, relstring);
37799:     if (relstring.IsEmpty()) {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_WHERE_NO_RELATION);
    1:         return NS_OK;
37799:     }
    1: 
    1:     // object
    1:     nsAutoString value;
    1:     aCondition->GetAttr(kNameSpaceID_None, nsGkAtoms::value, value);
37799:     if (value.IsEmpty()) {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_WHERE_NO_VALUE);
    1:         return NS_OK;
37799:     }
    1: 
    1:     // multiple
79445:     bool shouldMultiple =
    1:       aCondition->AttrValueIs(kNameSpaceID_None, nsGkAtoms::multiple,
    1:                               nsGkAtoms::_true, eCaseMatters);
    1: 
    1:     nsCOMPtr<nsIAtom> vvar;
    1:     if (!shouldMultiple && (value[0] == PRUnichar('?'))) {
    1:         vvar = do_GetAtom(value);
    1:     }
    1: 
    1:     // ignorecase
79445:     bool shouldIgnoreCase =
    1:       aCondition->AttrValueIs(kNameSpaceID_None, nsGkAtoms::ignorecase,
    1:                               nsGkAtoms::_true, eCaseMatters);
    1: 
    1:     // negate
79445:     bool shouldNegate =
    1:       aCondition->AttrValueIs(kNameSpaceID_None, nsGkAtoms::negate,
    1:                               nsGkAtoms::_true, eCaseMatters);
    1: 
    1:     nsTemplateCondition* condition;
    1: 
    1:     if (svar && vvar) {
    1:         condition = new nsTemplateCondition(svar, relstring, vvar,
    1:                                             shouldIgnoreCase, shouldNegate);
    1:     }
    1:     else if (svar && !value.IsEmpty()) {
    1:         condition = new nsTemplateCondition(svar, relstring, value,
    1:                                             shouldIgnoreCase, shouldNegate, shouldMultiple);
    1:     }
    1:     else if (vvar) {
    1:         condition = new nsTemplateCondition(subject, relstring, vvar,
    1:                                             shouldIgnoreCase, shouldNegate);
    1:     }
    1:     else {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_WHERE_NO_VAR);
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (! condition)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (*aCurrentCondition) {
    1:         (*aCurrentCondition)->SetNext(condition);
    1:     }
    1:     else {
    1:         aRule->SetCondition(condition);
    1:     }
    1: 
    1:     *aCurrentCondition = condition;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileBindings(nsTemplateRule* aRule, nsIContent* aBindings)
    1: {
    1:     // Add an extended rule's bindings.
    1:     nsresult rv;
    1: 
78992:     for (nsIContent* binding = aBindings->GetFirstChild();
78992:          binding;
78992:          binding = binding->GetNextSibling()) {
    1: 
    1:         if (binding->NodeInfo()->Equals(nsGkAtoms::binding,
    1:                                         kNameSpaceID_XUL)) {
    1:             rv = CompileBinding(aRule, binding);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
37799:     }
    1: 
    1:     aRule->AddBindingsToQueryProcessor(mQueryProcessor);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::CompileBinding(nsTemplateRule* aRule,
    1:                                      nsIContent* aBinding)
    1: {
    1:     // Compile a <binding> "condition", which must be of the form:
    1:     //
    1:     //   <binding subject="?var1"
    1:     //            predicate="resource"
    1:     //            object="?var2" />
    1:     //
    1:     // XXXwaterson Some day it would be cool to allow the 'predicate'
    1:     // to be bound to a variable.
    1: 
    1:     // subject
    1:     nsAutoString subject;
    1:     aBinding->GetAttr(kNameSpaceID_None, nsGkAtoms::subject, subject);
    1:     if (subject.IsEmpty()) {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_BINDING_BAD_SUBJECT);
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIAtom> svar;
    1:     if (subject[0] == PRUnichar('?')) {
    1:         svar = do_GetAtom(subject);
    1:     }
    1:     else {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_BINDING_BAD_SUBJECT);
    1:         return NS_OK;
    1:     }
    1: 
    1:     // predicate
    1:     nsAutoString predicate;
    1:     aBinding->GetAttr(kNameSpaceID_None, nsGkAtoms::predicate, predicate);
    1:     if (predicate.IsEmpty()) {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_BINDING_BAD_PREDICATE);
    1:         return NS_OK;
    1:     }
    1: 
    1:     // object
    1:     nsAutoString object;
    1:     aBinding->GetAttr(kNameSpaceID_None, nsGkAtoms::object, object);
    1: 
    1:     if (object.IsEmpty()) {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_BINDING_BAD_OBJECT);
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIAtom> ovar;
    1:     if (object[0] == PRUnichar('?')) {
    1:         ovar = do_GetAtom(object);
    1:     }
    1:     else {
37799:         nsXULContentUtils::LogTemplateError(ERROR_TEMPLATE_BINDING_BAD_OBJECT);
    1:         return NS_OK;
    1:     }
    1: 
    1:     return aRule->AddBinding(svar, predicate, ovar);
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::AddSimpleRuleBindings(nsTemplateRule* aRule,
    1:                                             nsIContent* aElement)
    1: {
    1:     // Crawl the content tree of a "simple" rule, adding a variable
    1:     // assignment for any attribute whose value is "rdf:".
    1: 
26413:     nsAutoTArray<nsIContent*, 8> elements;
26413: 
26413:     if (elements.AppendElement(aElement) == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
26413:     while (elements.Length()) {
    1:         // Pop the next element off the stack
26413:         PRUint32 i = elements.Length() - 1;
26413:         nsIContent* element = elements[i];
    1:         elements.RemoveElementAt(i);
    1: 
    1:         // Iterate through its attributes, looking for substitutions
    1:         // that we need to add as bindings.
    1:         PRUint32 count = element->GetAttrCount();
    1: 
    1:         for (i = 0; i < count; ++i) {
    1:             const nsAttrName* name = element->GetAttrNameAt(i);
    1: 
    1:             if (!name->Equals(nsGkAtoms::id, kNameSpaceID_None) &&
    1:                 !name->Equals(nsGkAtoms::uri, kNameSpaceID_None)) {
    1:                 nsAutoString value;
    1:                 element->GetAttr(name->NamespaceID(), name->LocalName(), value);
    1: 
    1:                 // Scan the attribute for variables, adding a binding for
    1:                 // each one.
    1:                 ParseAttribute(value, AddBindingsFor, nsnull, aRule);
    1:             }
    1:         }
    1: 
    1:         // Push kids onto the stack, and search them next.
78992:         for (nsIContent* child = element->GetLastChild();
78992:              child;
78992:              child = child->GetPreviousSibling()) {
78992: 
78992:             if (!elements.AppendElement(child))
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:     }
    1: 
    1:     aRule->AddBindingsToQueryProcessor(mQueryProcessor);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsXULTemplateBuilder::AddBindingsFor(nsXULTemplateBuilder* aThis,
    1:                                      const nsAString& aVariable,
    1:                                      void* aClosure)
    1: {
    1:     // We should *only* be recieving "rdf:"-style variables. Make
    1:     // sure...
    1:     if (!StringBeginsWith(aVariable, NS_LITERAL_STRING("rdf:")))
    1:         return;
    1: 
 3233:     nsTemplateRule* rule = static_cast<nsTemplateRule*>(aClosure);
    1: 
    1:     nsCOMPtr<nsIAtom> var = do_GetAtom(aVariable);
    1: 
    1:     // Strip it down to the raw RDF property by clobbering the "rdf:"
    1:     // prefix
    1:     nsAutoString property;
    1:     property.Assign(Substring(aVariable, PRUint32(4), aVariable.Length() - 4));
    1: 
    1:     if (! rule->HasBinding(rule->GetMemberVariable(), property, var))
    1:         // In the simple syntax, the binding is always from the
    1:         // member variable, through the property, to the target.
    1:         rule->AddBinding(rule->GetMemberVariable(), property, var);
    1: }
    1: 
    1: 
    1: nsresult
79445: nsXULTemplateBuilder::IsSystemPrincipal(nsIPrincipal *principal, bool *result)
    1: {
    1:   if (!gSystemPrincipal)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
    1:   *result = (principal == gSystemPrincipal);
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: nsXULTemplateBuilder::IsActivated(nsIRDFResource *aResource)
    1: {
    1:     for (ActivationEntry *entry = mTop;
    1:          entry != nsnull;
    1:          entry = entry->mPrevious) {
    1:         if (entry->mResource == aResource)
80486:             return true;
    1:     }
80486:     return false;
    1: }
    1: 
    1: nsresult
    1: nsXULTemplateBuilder::GetResultResource(nsIXULTemplateResult* aResult,
    1:                                         nsIRDFResource** aResource)
    1: {
    1:     // get the resource for a result by checking its resource property. If it
    1:     // is not set, check the id. This allows non-chrome implementations to
    1:     // avoid having to use RDF.
    1:     nsresult rv = aResult->GetResource(aResource);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (! *aResource) {
    1:         nsAutoString id;
    1:         rv = aResult->GetId(id);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         return gRDFService->GetUnicodeResource(id, aResource);
    1:     }
    1: 
    1:     return rv;
    1: }
37799: 
37799: 
37799: void
37799: nsXULTemplateBuilder::OutputMatchToLog(nsIRDFResource* aId,
37799:                                        nsTemplateMatch* aMatch,
79445:                                        bool aIsNew)
37799: {
37799:     PRInt32 priority = aMatch->QuerySetPriority() + 1;
37799:     PRInt32 activePriority = -1;
37799: 
37799:     nsAutoString msg;
37799: 
37799:     nsAutoString templateid;
37799:     mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::id, templateid);
37799:     msg.AppendLiteral("In template");
37799:     if (!templateid.IsEmpty()) {
37799:         msg.AppendLiteral(" with id ");
37799:         msg.Append(templateid);
37799:     }
37799: 
37799:     nsAutoString refstring;
37799:     aMatch->mResult->GetBindingFor(mRefVariable, refstring);
37799:     if (!refstring.IsEmpty()) {
37799:         msg.AppendLiteral(" using ref ");
37799:         msg.Append(refstring);
37799:     }
37799: 
37799:     msg.AppendLiteral("\n    ");
37799: 
37799:     nsTemplateMatch* match = nsnull;
37799:     if (mMatchMap.Get(aId, &match)){
37799:         while (match) {
37799:             if (match == aMatch)
37799:                 break;
37799:             if (match->IsActive() &&
37799:                 match->GetContainer() == aMatch->GetContainer()) {
37799:                 activePriority = match->QuerySetPriority() + 1;
37799:                 break;
37799:             }
37799:             match = match->mNext;
37799:         }
37799:     }
37799: 
37799:     if (aMatch->IsActive()) {
37799:         if (aIsNew) {
37799:             msg.AppendLiteral("New active result for query ");
37799:             msg.AppendInt(priority);
37799:             msg.AppendLiteral(" matching rule ");
37799:             msg.AppendInt(aMatch->RuleIndex() + 1);
37799:         }
37799:         else {
37799:             msg.AppendLiteral("Removed active result for query ");
37799:             msg.AppendInt(priority);
37799:             if (activePriority > 0) {
37799:                 msg.AppendLiteral(" (new active query is ");
37799:                 msg.AppendInt(activePriority);
37799:                 msg.Append(')');
37799:             }
37799:             else {
37799:                 msg.AppendLiteral(" (no new active query)");
37799:             }
37799:         }
37799:     }
37799:     else {
37799:         if (aIsNew) {
37799:             msg.AppendLiteral("New inactive result for query ");
37799:             msg.AppendInt(priority);
37799:             if (activePriority > 0) {
37799:                 msg.AppendLiteral(" (overridden by query ");
37799:                 msg.AppendInt(activePriority);
37799:                 msg.Append(')');
37799:             }
37799:             else {
37799:                 msg.AppendLiteral(" (didn't match a rule)");
37799:             }
37799:         }
37799:         else {
37799:             msg.AppendLiteral("Removed inactive result for query ");
37799:             msg.AppendInt(priority);
37799:             if (activePriority > 0) {
37799:                 msg.AppendLiteral(" (active query is ");
37799:                 msg.AppendInt(activePriority);
37799:                 msg.Append(')');
37799:             }
37799:             else {
37799:                 msg.AppendLiteral(" (no active query)");
37799:             }
37799:         }
37799:     }
37799: 
37799:     nsAutoString idstring;
37799:     nsXULContentUtils::GetTextForNode(aId, idstring);
37799:     msg.AppendLiteral(": ");
37799:     msg.Append(idstring);
37799: 
37799:     nsCOMPtr<nsIConsoleService> cs = do_GetService(NS_CONSOLESERVICE_CONTRACTID);
37799:     if (cs)
37799:       cs->LogStringMessage(msg.get());
37799: }
