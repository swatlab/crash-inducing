81151: /* ***** BEGIN LICENSE BLOCK *****
81151:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
81151:  *
81151:  * The contents of this file are subject to the Mozilla Public License Version
81151:  * 1.1 (the "License"); you may not use this file except in compliance with
81151:  * the License. You may obtain a copy of the License at
81151:  * http://www.mozilla.org/MPL/
81151:  *
81151:  * Software distributed under the License is distributed on an "AS IS" basis,
81151:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
81151:  * for the specific language governing rights and limitations under the
81151:  * License.
81151:  *
81151:  * The Original Code is HTML5 View Source code.
81151:  *
81151:  * The Initial Developer of the Original Code is
81151:  * Mozilla Foundation.
81151:  * Portions created by the Initial Developer are Copyright (C) 2010
81151:  * the Initial Developer. All Rights Reserved.
81151:  *
81151:  * Contributor(s):
81151:  *   Henri Sivonen <hsivonen@iki.fi>
81151:  *
81151:  * Alternatively, the contents of this file may be used under the terms of
81151:  * either the GNU General Public License Version 2 or later (the "GPL"), or
81151:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
81151:  * in which case the provisions of the GPL or the LGPL are applicable instead
81151:  * of those above. If you wish to allow use of your version of this file only
81151:  * under the terms of either the GPL or the LGPL, and not to allow others to
81151:  * use your version of this file under the terms of the MPL, indicate your
81151:  * decision by deleting the provisions above and replace them with the notice
81151:  * and other provisions required by the GPL or the LGPL. If you do not delete
81151:  * the provisions above, a recipient may use your version of this file under
81151:  * the terms of any one of the MPL, the GPL or the LGPL.
81151:  *
81151:  * ***** END LICENSE BLOCK ***** */
81151: 
81151: #include "nsHtml5Highlighter.h"
81151: #include "nsDebug.h"
81151: #include "nsHtml5Tokenizer.h"
81151: #include "nsHtml5AttributeName.h"
81151: #include "nsString.h"
81151: #include "nsThreadUtils.h"
83038: #include "nsHtml5ViewSourceUtils.h"
81151: #include "mozilla/Preferences.h"
81151: 
81151: using namespace mozilla;
81151: 
81158: // The old code had a limit of 16 tokens. 1300 is a number picked my measuring
81158: // the size of 16 tokens on cnn.com.
81158: #define NS_HTML5_HIGHLIGHTER_PRE_BREAK_THRESHOLD 1300
81158: 
81151: PRUnichar nsHtml5Highlighter::sComment[] =
81151:   { 'c', 'o', 'm', 'm', 'e', 'n', 't', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sCdata[] =
81151:   { 'c', 'd', 'a', 't', 'a', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sEntity[] =
81151:   { 'e', 'n', 't', 'i', 't', 'y', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sEndTag[] =
81151:   { 'e', 'n', 'd', '-', 't', 'a', 'g', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sStartTag[] =
81151:   { 's', 't', 'a', 'r', 't', '-', 't', 'a', 'g', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sAttributeName[] =
81151:   { 'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', '-', 'n', 'a', 'm', 'e', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sAttributeValue[] =
81151:   { 'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', '-',
81151:     'v', 'a', 'l', 'u', 'e', 0 };
81151: 
81151: PRUnichar nsHtml5Highlighter::sDoctype[] =
81151:   { 'd', 'o', 'c', 't', 'y', 'p', 'e', 0 };
81151: 
81154: PRUnichar nsHtml5Highlighter::sPi[] =
81154:   { 'p', 'i', 0 };
81154: 
81151: nsHtml5Highlighter::nsHtml5Highlighter(nsAHtml5TreeOpSink* aOpSink)
81151:  : mState(NS_HTML5TOKENIZER_DATA)
81151:  , mCStart(PR_INT32_MAX)
81151:  , mPos(0)
81157:  , mLineNumber(1)
81151:  , mInlinesOpen(0)
81153:  , mInCharacters(false)
81151:  , mBuffer(nsnull)
81151:  , mSyntaxHighlight(Preferences::GetBool("view_source.syntax_highlight",
81151:                                          true))
81151:  , mOpSink(aOpSink)
81153:  , mCurrentRun(nsnull)
81153:  , mAmpersand(nsnull)
81153:  , mSlash(nsnull)
81151:  , mHandles(new nsIContent*[NS_HTML5_HIGHLIGHTER_HANDLE_ARRAY_LENGTH])
81151:  , mHandlesUsed(0)
81151: {
81151:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
81151: }
81151: 
81151: nsHtml5Highlighter::~nsHtml5Highlighter()
81151: {
81151:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
81151: }
81151: 
81151: void
83037: nsHtml5Highlighter::Start(const nsAutoString& aTitle)
81151: {
81151:   // Doctype
81151:   mOpQueue.AppendElement()->Init(nsGkAtoms::html, EmptyString(), EmptyString());
81151: 
81151:   mOpQueue.AppendElement()->Init(STANDARDS_MODE);
81151: 
81151:   nsIContent** root = CreateElement(nsHtml5Atoms::html, nsnull);
81151:   mOpQueue.AppendElement()->Init(eTreeOpAppendToDocument, root);
81151:   mStack.AppendElement(root);
81151: 
81151:   Push(nsGkAtoms::head, nsnull);
81151: 
81151:   Push(nsGkAtoms::title, nsnull);
81151:   // XUL will add the "Source of: " prefix.
83037:   PRUint32 length = aTitle.Length();
83037:   if (length > PR_INT32_MAX) {
83037:     length = PR_INT32_MAX;
83037:   }
83037:   AppendCharacters(aTitle.get(), 0, (PRInt32)length);
81151:   Pop(); // title
81151: 
83038:   Push(nsGkAtoms::link, nsHtml5ViewSourceUtils::NewLinkAttributes());
81151: 
81151:   mOpQueue.AppendElement()->Init(eTreeOpUpdateStyleSheet, CurrentNode());
81151: 
81151:   Pop(); // link
81151: 
81151:   Pop(); // head
81151: 
83038:   Push(nsGkAtoms::body, nsHtml5ViewSourceUtils::NewBodyAttributes());
81151: 
81151:   nsHtml5HtmlAttributes* preAttrs = new nsHtml5HtmlAttributes(0);
81151:   nsString* preId = new nsString(NS_LITERAL_STRING("line1"));
81151:   preAttrs->addAttribute(nsHtml5AttributeName::ATTR_ID, preId);
81151:   Push(nsGkAtoms::pre, preAttrs);
81151: 
81153:   StartCharacters();
81153: 
81151:   mOpQueue.AppendElement()->Init(eTreeOpStartLayout);
81151: }
81151: 
81151: PRInt32
81151: nsHtml5Highlighter::Transition(PRInt32 aState, bool aReconsume, PRInt32 aPos)
81151: {
81151:   mPos = aPos;
81151:   switch (mState) {
81151:     case NS_HTML5TOKENIZER_SCRIPT_DATA:
81151:     case NS_HTML5TOKENIZER_RAWTEXT:
81151:     case NS_HTML5TOKENIZER_RCDATA:
81151:     case NS_HTML5TOKENIZER_DATA:
81151:       // We can transition on < and on &. Either way, we don't yet know the
81151:       // role of the token, so open a span without class.
81153:       if (aState == NS_HTML5TOKENIZER_CONSUME_CHARACTER_REFERENCE) {
81151:         StartSpan();
81152:         // Start another span for highlighting the ampersand
81152:         StartSpan();
81152:         mAmpersand = CurrentNode();
81152:       } else {
95593:         EndCharactersAndStartMarkupRun();
81152:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_TAG_OPEN:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_TAG_NAME:
81151:           StartSpan(sStartTag);
81151:           break;
81151:         case NS_HTML5TOKENIZER_DATA:
81153:           FinishTag(); // DATA
81151:           break;
81154:         case NS_HTML5TOKENIZER_PROCESSING_INSTRUCTION:
81154:           AddClass(sPi);
81154:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_TAG_NAME:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME:
81164:           EndSpanOrA(); // NS_HTML5TOKENIZER_TAG_NAME
81151:           break;
81151:         case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81164:           EndSpanOrA(); // NS_HTML5TOKENIZER_TAG_NAME
81151:           StartSpan(); // for highlighting the slash
81152:           mSlash = CurrentNode();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_ATTRIBUTE_NAME:
81151:           StartSpan(sAttributeName);
81151:           break;
81151:         case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81151:           StartSpan(); // for highlighting the slash
81152:           mSlash = CurrentNode();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_ATTRIBUTE_NAME:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_NAME:
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_VALUE:
81164:           EndSpanOrA(); // NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME
81151:           break;
81151:         case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81164:           EndSpanOrA(); // NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME
81151:           StartSpan(); // for highlighting the slash
81152:           mSlash = CurrentNode();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_VALUE:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_DOUBLE_QUOTED:
81151:         case NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_SINGLE_QUOTED:
81151:           FlushCurrent();
81151:           StartA();
81151:           break;
81151:         case NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_UNQUOTED:
81151:           StartA();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_DOUBLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_SINGLE_QUOTED:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_VALUE_QUOTED:
81164:           EndSpanOrA();
81151:           break;
81151:         case NS_HTML5TOKENIZER_CONSUME_CHARACTER_REFERENCE:
81151:           StartSpan();
81152:           StartSpan(); // for ampersand itself
81152:           mAmpersand = CurrentNode();
81151:           break;
81151:         default:
81151:           NS_NOTREACHED("Impossible transition.");
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_VALUE_QUOTED:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME:
81151:           break;
81151:         case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81151:           StartSpan(); // for highlighting the slash
81152:           mSlash = CurrentNode();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81164:       EndSpanOrA(); // end the slash highlight
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME:
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_ATTRIBUTE_VALUE_UNQUOTED:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME:
81164:           EndSpanOrA();
81151:           break;
81151:         case NS_HTML5TOKENIZER_CONSUME_CHARACTER_REFERENCE:
81151:           StartSpan();
81152:           StartSpan(); // for ampersand itself
81152:           mAmpersand = CurrentNode();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_AFTER_ATTRIBUTE_NAME:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81151:           StartSpan(); // for highlighting the slash
81152:           mSlash = CurrentNode();
81151:           break;
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_VALUE:
81151:           break;
81151:         case NS_HTML5TOKENIZER_ATTRIBUTE_NAME:
81151:           StartSpan(sAttributeName);
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:       // most comment states are omitted, because they don't matter to
81151:       // highlighting
82908:     case NS_HTML5TOKENIZER_COMMENT_START:
81151:     case NS_HTML5TOKENIZER_COMMENT_END:
81151:     case NS_HTML5TOKENIZER_COMMENT_END_BANG:
81151:     case NS_HTML5TOKENIZER_COMMENT_START_DASH:
81151:     case NS_HTML5TOKENIZER_BOGUS_COMMENT:
81151:     case NS_HTML5TOKENIZER_BOGUS_COMMENT_HYPHEN:
81151:       if (aState == NS_HTML5TOKENIZER_DATA) {
81151:         AddClass(sComment);
81151:         FinishTag();
81151:       }
81151:       break;
81151:       // most cdata states are omitted, because they don't matter to
81151:       // highlighting
81151:     case NS_HTML5TOKENIZER_CDATA_RSQB_RSQB:
81151:       if (aState == NS_HTML5TOKENIZER_DATA) {
81151:         AddClass(sCdata);
81151:         FinishTag();
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_CONSUME_CHARACTER_REFERENCE:
81164:       EndSpanOrA(); // the span for the ampersand
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_CONSUME_NCR:
81151:         case NS_HTML5TOKENIZER_CHARACTER_REFERENCE_HILO_LOOKUP:
81151:           break;
81151:         default:
81151:           // not actually a character reference
81164:           EndSpanOrA();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_CHARACTER_REFERENCE_HILO_LOOKUP:
81151:       if (aState == NS_HTML5TOKENIZER_CHARACTER_REFERENCE_TAIL) {
81151:         break;
81151:       }
81151:       // not actually a character reference
81164:       EndSpanOrA();
81151:       break;
81151:     case NS_HTML5TOKENIZER_CHARACTER_REFERENCE_TAIL:
81151:       if (!aReconsume) {
81151:         FlushCurrent();
81151:       }
81164:       EndSpanOrA();
81151:       break;
81151:     case NS_HTML5TOKENIZER_DECIMAL_NRC_LOOP:
81151:     case NS_HTML5TOKENIZER_HEX_NCR_LOOP:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_HANDLE_NCR_VALUE:
81151:           AddClass(sEntity);
81151:           FlushCurrent();
81151:           break;
81151:         case NS_HTML5TOKENIZER_HANDLE_NCR_VALUE_RECONSUME:
81151:           AddClass(sEntity);
81151:           break;
81151:       }
81164:       EndSpanOrA();
81151:       break;
81151:     case NS_HTML5TOKENIZER_CLOSE_TAG_OPEN:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_DATA:
81151:           FinishTag();
81151:           break;
81151:         case NS_HTML5TOKENIZER_TAG_NAME:
81151:           StartSpan(sEndTag);
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_RAWTEXT_RCDATA_LESS_THAN_SIGN:
81151:       if (aState == NS_HTML5TOKENIZER_NON_DATA_END_TAG_NAME) {
81151:         FlushCurrent();
81151:         StartSpan(); // don't know if it is "end-tag" yet :-(
81151:         break;
81151:       }
81164:       EndSpanOrA();
81153:       StartCharacters();
81151:       break;
81151:     case NS_HTML5TOKENIZER_NON_DATA_END_TAG_NAME:
81151:       switch (aState) {
81151:         case NS_HTML5TOKENIZER_BEFORE_ATTRIBUTE_NAME:
81151:           AddClass(sEndTag);
81164:           EndSpanOrA();
81151:           break;
81151:         case NS_HTML5TOKENIZER_SELF_CLOSING_START_TAG:
81151:           AddClass(sEndTag);
81164:           EndSpanOrA();
81151:           StartSpan(); // for highlighting the slash
81152:           mSlash = CurrentNode();
81151:           break;
81151:         case NS_HTML5TOKENIZER_DATA: // yes, as a result of emitting the token
81151:           AddClass(sEndTag);
81151:           FinishTag();
81151:           break;
81151:         default:
81151:           FinishTag();
81151:           break;
81151:       }
81151:       break;
81151:     case NS_HTML5TOKENIZER_SCRIPT_DATA_LESS_THAN_SIGN:
81151:     case NS_HTML5TOKENIZER_SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
81151:       if (aState == NS_HTML5TOKENIZER_NON_DATA_END_TAG_NAME) {
95593:         FlushCurrent();
95593:         StartSpan(); // don't know if it is "end-tag" yet :-(
81151:         break;
81151:       }
81151:       FinishTag();
81151:       break;
81151:     case NS_HTML5TOKENIZER_SCRIPT_DATA_ESCAPED_DASH_DASH:
81151:     case NS_HTML5TOKENIZER_SCRIPT_DATA_ESCAPED:
81151:     case NS_HTML5TOKENIZER_SCRIPT_DATA_ESCAPED_DASH:
81151:       if (aState == NS_HTML5TOKENIZER_SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN) {
95593:         EndCharactersAndStartMarkupRun();
81151:       }
81151:       break;
81151:       // Lots of double escape states omitted, because they don't highlight.
81151:       // Likewise, only doctype states that can emit the doctype are of
81151:       // interest. Otherwise, the transition out of bogus comment deals.
81151:     case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_NAME:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_NAME:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_NAME:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_PUBLIC_KEYWORD:
81151:     case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_BOGUS_DOCTYPE:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_SYSTEM_KEYWORD:
81151:     case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
81151:       if (aState == NS_HTML5TOKENIZER_DATA) {
81151:         AddClass(sDoctype);
81151:         FinishTag();
81151:       }
81151:       break;
81154:     case NS_HTML5TOKENIZER_PROCESSING_INSTRUCTION_QUESTION_MARK:
81154:       if (aState == NS_HTML5TOKENIZER_DATA) {
81154:         FinishTag();
81154:       }
81154:       break;
81151:     default:
81151:       break;
81151:   }
81151:   mState = aState;
81151:   return aState;
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::End()
81151: {
81151:   switch (mState) {
81151:     case NS_HTML5TOKENIZER_COMMENT_END:
81151:     case NS_HTML5TOKENIZER_COMMENT_END_BANG:
81151:     case NS_HTML5TOKENIZER_COMMENT_START_DASH:
81151:     case NS_HTML5TOKENIZER_BOGUS_COMMENT:
81151:     case NS_HTML5TOKENIZER_BOGUS_COMMENT_HYPHEN:
81151:       AddClass(sComment);
81151:       break;
81151:     case NS_HTML5TOKENIZER_CDATA_RSQB_RSQB:
81151:       AddClass(sCdata);
81151:       break;
81151:     case NS_HTML5TOKENIZER_DECIMAL_NRC_LOOP:
81151:     case NS_HTML5TOKENIZER_HEX_NCR_LOOP:
81151:       // XXX need tokenizer help here
81151:       break;
81151:     case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_NAME:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_NAME:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_NAME:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_PUBLIC_KEYWORD:
81151:     case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_BOGUS_DOCTYPE:
81151:     case NS_HTML5TOKENIZER_AFTER_DOCTYPE_SYSTEM_KEYWORD:
81151:     case NS_HTML5TOKENIZER_BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
81151:     case NS_HTML5TOKENIZER_DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
81151:       AddClass(sDoctype);
81151:       break;
81151:     default:
81151:       break;
81151:   }
81152:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81152:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81152:   treeOp->Init(eTreeOpStreamEnded);
81151:   FlushOps();
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::SetBuffer(nsHtml5UTF16Buffer* aBuffer)
81151: {
81151:   NS_PRECONDITION(!mBuffer, "Old buffer still here!");
81151:   mBuffer = aBuffer;
81151:   mCStart = aBuffer->getStart();
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::DropBuffer(PRInt32 aPos)
81151: {
81151:   NS_PRECONDITION(mBuffer, "No buffer to drop!");
81151:   mPos = aPos;
81151:   FlushChars();
81151:   mBuffer = nsnull;
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::StartSpan()
81151: {
81151:   FlushChars();
81151:   Push(nsGkAtoms::span, nsnull);
81151:   ++mInlinesOpen;
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::StartSpan(const PRUnichar* aClass)
81151: {
81151:   StartSpan();
81151:   AddClass(aClass);
81151: }
81151: 
81151: void
81164: nsHtml5Highlighter::EndSpanOrA()
81151: {
81151:   FlushChars();
81151:   Pop();
81151:   --mInlinesOpen;
81151: }
81151: 
81151: void
81153: nsHtml5Highlighter::StartCharacters()
81153: {
81153:   NS_PRECONDITION(!mInCharacters, "Already in characters!");
81153:   FlushChars();
81153:   Push(nsGkAtoms::span, nsnull);
81153:   mCurrentRun = CurrentNode();
81153:   mInCharacters = true;
81153: }
81153: 
81153: void
95593: nsHtml5Highlighter::EndCharactersAndStartMarkupRun()
81153: {
81153:   NS_PRECONDITION(mInCharacters, "Not in characters!");
81153:   FlushChars();
81153:   Pop();
81153:   mInCharacters = false;
95593:   // Now start markup run
95593:   StartSpan();
95593:   mCurrentRun = CurrentNode();
81153: }
81153: 
81153: void
81151: nsHtml5Highlighter::StartA()
81151: {
81151:   FlushChars();
81151:   Push(nsGkAtoms::a, nsnull);
81151:   AddClass(sAttributeValue);
81151:   ++mInlinesOpen;
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::FinishTag()
81151: {
81151:   while (mInlinesOpen > 1) {
81164:     EndSpanOrA();
81151:   }
81151:   FlushCurrent(); // >
81164:   EndSpanOrA(); // DATA
81151:   NS_ASSERTION(!mInlinesOpen, "mInlinesOpen got out of sync!");
81153:   StartCharacters();
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::FlushChars()
81151: {
81157:   if (mCStart < mPos) {
81157:     PRUnichar* buf = mBuffer->getBuffer();
81157:     PRInt32 i = mCStart;
81157:     while (i < mPos) {
81157:       PRUnichar c = buf[i];
81157:       switch (c) {
81157:         case '\r':
81157:           // The input this code sees has been normalized so that there are
81157:           // CR breaks and LF breaks but no CRLF breaks. Overwrite CR with LF
81157:           // to show consistent LF line breaks to layout. It is OK to mutate
81157:           // the input data, because there are no reparses in the View Source
81157:           // case, so we won't need the original data in the buffer anymore.
81157:           buf[i] = '\n';
81157:           // fall through
81157:         case '\n': {
81157:           ++i;
81157:           if (mCStart < i) {
81158:             PRInt32 len = i - mCStart;
81158:             AppendCharacters(buf, mCStart, len);
81157:             mCStart = i;
81157:           }
81157:           ++mLineNumber;
81157:           Push(nsGkAtoms::span, nsnull);
81157:           nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81157:           NS_ASSERTION(treeOp, "Tree op allocation failed.");
81157:           treeOp->InitAddLineNumberId(CurrentNode(), mLineNumber);
81157:           Pop();
81157:           break;
81157:         }
81157:         default:
81157:           ++i;
81157:           break;
81157:       }
81157:     }
81157:     if (mCStart < mPos) {
81158:       PRInt32 len = mPos - mCStart;
81158:       AppendCharacters(buf, mCStart, len);
81151:       mCStart = mPos;
81151:     }
81151:   }
81157: }
81151: 
81151: void
81151: nsHtml5Highlighter::FlushCurrent()
81151: {
81151:   mPos++;
81151:   FlushChars();
81151: }
81151: 
81151: bool
81151: nsHtml5Highlighter::FlushOps()
81151: {
81151:   bool hasOps = !mOpQueue.IsEmpty();
81151:   if (hasOps) {
81151:     mOpSink->MoveOpsFrom(mOpQueue);
81151:   }
81151:   return hasOps;
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::MaybeLinkifyAttributeValue(nsHtml5AttributeName* aName,
81151:                                                nsString* aValue)
81151: {
81164:   if (!(nsHtml5AttributeName::ATTR_HREF == aName ||
81164:         nsHtml5AttributeName::ATTR_SRC == aName ||
81164:         nsHtml5AttributeName::ATTR_ACTION == aName ||
81164:         nsHtml5AttributeName::ATTR_CITE == aName ||
81164:         nsHtml5AttributeName::ATTR_BACKGROUND == aName ||
81164:         nsHtml5AttributeName::ATTR_LONGDESC == aName ||
81164:         nsHtml5AttributeName::ATTR_XLINK_HREF == aName ||
81164:         nsHtml5AttributeName::ATTR_DEFINITIONURL == aName)) {
81151:     return;
81151:   }
81151:   AddViewSourceHref(*aValue);
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::CompletedNamedCharacterReference()
81151: {
81151:   AddClass(sEntity);
81151: }
81151: 
81151: nsIContent**
81151: nsHtml5Highlighter::AllocateContentHandle()
81151: {
81151:   if (mHandlesUsed == NS_HTML5_HIGHLIGHTER_HANDLE_ARRAY_LENGTH) {
81151:     mOldHandles.AppendElement(mHandles.forget());
81151:     mHandles = new nsIContent*[NS_HTML5_HIGHLIGHTER_HANDLE_ARRAY_LENGTH];
81151:     mHandlesUsed = 0;
81151:   }
81151: #ifdef DEBUG
81151:   mHandles[mHandlesUsed] = (nsIContent*)0xC0DEDBAD;
81151: #endif
81151:   return &mHandles[mHandlesUsed++];
81151: }
81151: 
81151: nsIContent**
81151: nsHtml5Highlighter::CreateElement(nsIAtom* aName,
81151:                                   nsHtml5HtmlAttributes* aAttributes)
81151: {
81151:   NS_PRECONDITION(aName, "Got null name.");
81151:   nsIContent** content = AllocateContentHandle();
81151:   mOpQueue.AppendElement()->Init(kNameSpaceID_XHTML,
81151:                                  aName,
81151:                                  aAttributes,
81151:                                  content,
81151:                                  true);
81151:   return content;
81151: }
81151: 
81151: nsIContent**
81151: nsHtml5Highlighter::CurrentNode()
81151: {
81151:   NS_PRECONDITION(mStack.Length() >= 1, "Must have something on stack.");
81151:   return mStack[mStack.Length() - 1];
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::Push(nsIAtom* aName,
81151:                          nsHtml5HtmlAttributes* aAttributes)
81151: {
81151:   NS_PRECONDITION(mStack.Length() >= 1, "Pushing without root.");
81151:   nsIContent** elt = CreateElement(aName, aAttributes); // Don't inline below!
81151:   mOpQueue.AppendElement()->Init(eTreeOpAppend, elt, CurrentNode());
81151:   mStack.AppendElement(elt);
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::Pop()
81151: {
81151:   NS_PRECONDITION(mStack.Length() >= 2, "Popping when stack too short.");
81151:   mStack.RemoveElementAt(mStack.Length() - 1);
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::AppendCharacters(const PRUnichar* aBuffer,
81151:                                      PRInt32 aStart,
81151:                                      PRInt32 aLength)
81151: {
81151:   NS_PRECONDITION(aBuffer, "Null buffer");
81151: 
81151:   PRUnichar* bufferCopy = new PRUnichar[aLength];
81151:   memcpy(bufferCopy, aBuffer + aStart, aLength * sizeof(PRUnichar));
81151: 
81151:   mOpQueue.AppendElement()->Init(eTreeOpAppendText,
81151:                                  bufferCopy,
81151:                                  aLength,
81151:                                  CurrentNode());
81151: }
81151: 
81151: 
81151: void
81151: nsHtml5Highlighter::AddClass(const PRUnichar* aClass)
81151: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81151:   mOpQueue.AppendElement()->InitAddClass(CurrentNode(), aClass);
81151: }
81151: 
81151: void
81151: nsHtml5Highlighter::AddViewSourceHref(const nsString& aValue)
81151: {
81151:   PRUnichar* bufferCopy = new PRUnichar[aValue.Length() + 1];
81151:   memcpy(bufferCopy, aValue.get(), aValue.Length() * sizeof(PRUnichar));
81151:   bufferCopy[aValue.Length()] = 0;
81151: 
81151:   mOpQueue.AppendElement()->Init(eTreeOpAddViewSourceHref,
81151:                                  bufferCopy,
81151:                                  aValue.Length(),
81151:                                  CurrentNode());
81151: }
81152: 
81152: void
81152: nsHtml5Highlighter::AddErrorToCurrentNode(const char* aMsgId)
81152: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81152:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81152:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81152:   treeOp->Init(CurrentNode(), aMsgId);
81152: }
81152: 
81152: void
81153: nsHtml5Highlighter::AddErrorToCurrentRun(const char* aMsgId)
81152: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81153:   NS_PRECONDITION(mCurrentRun, "Adding error to run without one!");
81152:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81152:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81153:   treeOp->Init(mCurrentRun, aMsgId);
81153: }
81153: 
81153: void
81153: nsHtml5Highlighter::AddErrorToCurrentRun(const char* aMsgId,
81153:                                          nsIAtom* aName)
81153: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81153:   NS_PRECONDITION(mCurrentRun, "Adding error to run without one!");
81153:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81153:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81160:   treeOp->Init(mCurrentRun, aMsgId, aName);
81153: }
81153: 
81153: void
81153: nsHtml5Highlighter::AddErrorToCurrentRun(const char* aMsgId,
81153:                                          nsIAtom* aName,
81153:                                          nsIAtom* aOther)
81153: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81153:   NS_PRECONDITION(mCurrentRun, "Adding error to run without one!");
81153:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81153:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81160:   treeOp->Init(mCurrentRun, aMsgId, aName, aOther);
81152: }
81152: 
81152: void
81152: nsHtml5Highlighter::AddErrorToCurrentAmpersand(const char* aMsgId)
81152: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81152:   NS_PRECONDITION(mAmpersand, "Adding error to ampersand without one!");
81152:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81152:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81152:   treeOp->Init(mAmpersand, aMsgId);
81152: }
81152: 
81152: void
81152: nsHtml5Highlighter::AddErrorToCurrentSlash(const char* aMsgId)
81152: {
81585:   if (!mSyntaxHighlight) {
81585:     return;
81585:   }
81152:   NS_PRECONDITION(mSlash, "Adding error to slash without one!");
81152:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
81152:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
81152:   treeOp->Init(mSlash, aMsgId);
81152: }
