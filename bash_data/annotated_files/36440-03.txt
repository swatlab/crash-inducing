    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jerry.Kirk@Nexwarecorp.com
    1:  *   Chris Seawood <cls@seawood.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * This module is supposed to abstract signal handling away from the other
    1:  * platforms that do not support it.
    1:  */
    1: 
36440: #include "nsSigHandlers.h"
36440: 
36440: #if !defined(XP_WIN) && !defined(XP_OS2)
36440: 
    1: #include <signal.h>
    1: #include <stdio.h>
 1781: #include <string.h>
    1: #include "prthread.h"
    1: #include "plstr.h"
    1: #include "prenv.h"
 1781: #include "nsDebug.h"
    1: 
    1: #if defined(LINUX)
    1: #include <sys/time.h>
    1: #include <sys/resource.h>
    1: #include <unistd.h>
    1: #include <stdlib.h> // atoi
36440: #include <ucontext.h>
    1: #endif
    1: 
    1: #if defined(SOLARIS)
    1: #include <sys/resource.h>
    1: #endif
    1: 
    1: #ifdef XP_BEOS
    1: #include <be/app/Application.h>
    1: #include <string.h>
    1: #include "nsCOMPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIAppStartup.h"
    1: #include "nsXPFEComponentsCID.h"
    1: #endif
    1: 
    1: #ifdef MOZ_WIDGET_PHOTON
    1: #include <photon/PhProto.h>
    1: #endif
    1: 
    1: static char _progname[1024] = "huh?";
    1: static unsigned int _gdb_sleep_duration = 300;
    1: 
    1: #if defined(LINUX) && defined(DEBUG) && \
    1:       (defined(__i386) || defined(__x86_64) || defined(PPC))
    1: #define CRAWL_STACK_ON_SIGSEGV
    1: #endif
    1: 
    1: #ifdef MOZ_WIDGET_PHOTON
    1: void abnormal_exit_handler(int signum)
    1: {
    1:   /* Free any shared memory that has been allocated */
    1:   PgShmemCleanup();
    1: 
    1: #if defined(DEBUG)
    1:   if (    (signum == SIGSEGV)
    1:        || (signum == SIGILL)
    1:        || (signum == SIGABRT)
    1:        || (signum == SIGFPE)
    1:      )
    1:   {
    1:     printf("prog = %s\npid = %d\nsignal = %s\n", 
    1:            _progname, getpid(), strsignal(signum));
    1: 
    1:     printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
    1:     printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
    1:            _progname, getpid());
    1: 
    1:     sleep(_gdb_sleep_duration);
    1: 
    1:     printf("Done sleeping...\n");
    1:   }
    1: #endif
    1: 
    1:   _exit(1);
    1: }
    1: #elif defined(CRAWL_STACK_ON_SIGSEGV)
    1: 
    1: #include <unistd.h>
    1: #include "nsISupportsUtils.h"
 4487: #include "nsStackWalk.h"
 4487: 
 4487: extern "C" {
 4487: 
20261: static void PrintStackFrame(void *aPC, void *aClosure)
 4487: {
 4488:   char buf[1024];
 4488:   nsCodeAddressDetails details;
 4488: 
 4488:   NS_DescribeCodeAddress(aPC, &details);
 4488:   NS_FormatCodeAddressDetails(aPC, &details, buf, sizeof(buf));
34013:   fputs(buf, stdout);
 4487: }
 4487: 
 4487: }
    1: 
    1: void
    1: ah_crap_handler(int signum)
    1: {
    1:   printf("\nProgram %s (pid = %d) received signal %d.\n",
    1:          _progname,
    1:          getpid(),
    1:          signum);
    1: 
    1:   printf("Stack:\n");
 4487:   NS_StackWalk(PrintStackFrame, 2, nsnull);
    1: 
    1:   printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
    1:   printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
    1:          _progname,
    1:          getpid());
    1: 
    1:   sleep(_gdb_sleep_duration);
    1: 
    1:   printf("Done sleeping...\n");
25537: 
25537:   _exit(signum);
    1: }
    1: #endif // CRAWL_STACK_ON_SIGSEGV
    1: 
    1: #ifdef XP_BEOS
    1: void beos_signal_handler(int signum) {
    1: #ifdef DEBUG
    1: 	fprintf(stderr, "beos_signal_handler: %d\n", signum);
    1: #endif
    1: 	nsresult rv;
    1: 	nsCOMPtr<nsIAppStartup> appStartup(do_GetService(NS_APPSTARTUP_CONTRACTID, &rv));
    1: 	if (NS_FAILED(rv)) {
    1: 		// Failed to get the appstartup service so shutdown the hard way
    1: #ifdef DEBUG
    1: 		fprintf(stderr, "beos_signal_handler: appShell->do_GetService() failed\n");
    1: #endif
    1: 		exit(13);
    1: 	}
    1: 
    1: 	// Exit the appshell so that the app can shutdown normally
    1: 	appStartup->Quit(nsIAppStartup::eAttemptQuit);
    1: }
    1: #endif
    1: 
 2299: #ifdef MOZ_WIDGET_GTK2
 2299: // Need this include for version test below.
 2299: #include <glib.h>
 2299: #endif
 2299: 
 1784: #if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
 1777: 
 1777: static GLogFunc orig_log_func = NULL;
 1777: 
 1777: extern "C" {
 1777: static void
 1777: my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
 1777:                  const gchar *message, gpointer user_data);
 1777: }
 1777: 
 1777: /* static */ void
 1777: my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
 1777:                  const gchar *message, gpointer user_data)
 1777: {
 9978:   if (log_level & (G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION)) {
 9978:     NS_DebugBreak(NS_DEBUG_ASSERTION, message, "glib assertion", __FILE__, __LINE__);
 9978:   } else if (log_level & (G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)) {
 9978:     NS_DebugBreak(NS_DEBUG_WARNING, message, "glib warning", __FILE__, __LINE__);
 9978:   }
 9978: 
 1777:   orig_log_func(log_domain, log_level, message, NULL);
 1777: }
 1777: 
 1777: #endif
 1777: 
36440: static void fpehandler(int signum, siginfo_t *si, void *context)
36440: {
36440: #ifdef XP_MACOSX
36440:   ucontext_t *uc = (ucontext_t *)context;
36440: 
36440: #if defined(__i386__) || defined(__amd64__)
36440:   _STRUCT_FP_CONTROL *ctrl = &uc->uc_mcontext->__fs.__fpu_fcw;
36440:   ctrl->__invalid = ctrl->__denorm = ctrl->__zdiv = ctrl->__ovrfl = ctrl->__undfl = ctrl->__precis = 1;
36440: 
36440:   _STRUCT_FP_STATUS *status = &uc->uc_mcontext->__fs.__fpu_fsw;
36440:   status->__invalid = status->__denorm = status->__zdiv = status->__ovrfl = status->__undfl =
36440:     status->__precis = status->__stkflt = status->__errsumm = 0;
36440: 
36440:   __uint32_t *mxcsr = &uc->uc_mcontext->__fs.__fpu_mxcsr;
36440:   *mxcsr |= SSE_EXCEPTION_MASK; /* disable all SSE exceptions */
36440:   *mxcsr &= ~SSE_STATUS_FLAGS; /* clear all pending SSE exceptions */
36440: #endif
36440: #endif
36440: #ifdef LINUX
36440:   ucontext_t *uc = (ucontext_t *)context;
36440: 
36440: #if defined(__i386__)
36440:   /*
36440:    * It seems that we have no access to mxcsr on Linux. libc
36440:    * seems to be translating cw/sw to mxcsr.
36440:    */
36440:   unsigned long int *cw = &uc->uc_mcontext.fpregs->cw;
36440:   *cw |= FPU_EXCEPTION_MASK;
36440: 
36440:   unsigned long int *sw = &uc->uc_mcontext.fpregs->sw;
36440:   *sw &= ~FPU_STATUS_FLAGS;
36440: #endif
36440: #if defined(__amd64__)
36440:   uint16_t *cw = &uc->uc_mcontext.fpregs->cwd;
36440:   *cwd |= FPU_EXCEPTION_MASK;
36440: 
36440:   uint16_t *sw = &uc->uc_mcontext.fpregs->swd;
36440:   *swd &= ~FPU_STATUS_FLAGS;
36440: 
36440:   __uint32_t *mxcsr = &uc->uc_mcontext->fpregs->mxcsr;
36440:   *mxcsr |= SSE_EXCEPTION_MASK; /* disable all SSE exceptions */
36440:   *mxcsr &= ~SSE_STATUS_FLAGS; /* clear all pending SSE exceptions */
36440: #endif
36440: #endif
36440: }
36440: 
36440: void InstallSignalHandlers(const char *ProgramName)
    1: {
    1:   PL_strncpy(_progname,ProgramName, (sizeof(_progname)-1) );
    1: 
    1:   const char *gdbSleep = PR_GetEnv("MOZ_GDB_SLEEP");
    1:   if (gdbSleep && *gdbSleep)
    1:   {
    1:     unsigned int s;
    1:     if (1 == sscanf(gdbSleep, "%u", &s)) {
    1:       _gdb_sleep_duration = s;
    1:     }
    1:   }
    1: 
    1: #if defined(MOZ_WIDGET_PHOTON)
    1:  /* Neutrino need this to free shared memory in case of a crash */
    1:   signal(SIGTERM, abnormal_exit_handler);
    1:   signal(SIGQUIT, abnormal_exit_handler);
    1:   signal(SIGINT,  abnormal_exit_handler);
    1:   signal(SIGHUP,  abnormal_exit_handler);
    1:   signal(SIGSEGV, abnormal_exit_handler);
    1:   signal(SIGILL,  abnormal_exit_handler);
    1:   signal(SIGABRT, abnormal_exit_handler);
    1: 
    1: #elif defined(CRAWL_STACK_ON_SIGSEGV)
    1:   signal(SIGSEGV, ah_crap_handler);
    1:   signal(SIGILL, ah_crap_handler);
    1:   signal(SIGABRT, ah_crap_handler);
    1: #endif // CRAWL_STACK_ON_SIGSEGV
    1: 
36440:   /* Install a handler for floating point exceptions and disable them if they occur. */
36440:   struct sigaction sa, osa;
36440:   sa.sa_flags = SA_ONSTACK | SA_RESTART | SA_SIGINFO;
36440:   sa.sa_sigaction = fpehandler;
36440:   sigaction(SIGFPE, &sa, &osa);
36440: 
    1: #if defined(DEBUG) && defined(LINUX)
    1:   const char *memLimit = PR_GetEnv("MOZ_MEM_LIMIT");
    1:   if (memLimit && *memLimit)
    1:   {
    1:     long m = atoi(memLimit);
    1:     m *= (1024*1024);
    1:     struct rlimit r;
    1:     r.rlim_cur = m;
    1:     r.rlim_max = m;
    1:     setrlimit(RLIMIT_AS, &r);
    1:   }
    1: #endif
    1: 
    1: #if defined(SOLARIS)
    1: #define NOFILES 512
    1: 
    1:     // Boost Solaris file descriptors
    1:     {
    1: 	struct rlimit rl;
    1: 	
    1: 	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
    1: 
    1: 	    if (rl.rlim_cur < NOFILES) {
    1: 		rl.rlim_cur = NOFILES;
    1: 
    1: 		if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
    1: 		    perror("setrlimit(RLIMIT_NOFILE)");
    1: 		    fprintf(stderr, "Cannot exceed hard limit for open files");
    1: 		}
    1: #if defined(DEBUG)
    1: 	    	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
    1: 		    printf("File descriptors set to %d\n", rl.rlim_cur);
    1: #endif //DEBUG
    1: 	    }
    1:     }
    1: #endif //SOLARIS
    1: 
    1: #ifdef XP_BEOS
    1: 	signal(SIGTERM, beos_signal_handler);
    1: #endif
 1777: 
 1784: #if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
 1777:   const char *assertString = PR_GetEnv("XPCOM_DEBUG_BREAK");
 1777:   if (assertString &&
 1777:       (!strcmp(assertString, "suspend") ||
 1777:        !strcmp(assertString, "stack") ||
 1777:        !strcmp(assertString, "abort") ||
 1777:        !strcmp(assertString, "trap") ||
 1777:        !strcmp(assertString, "break"))) {
 1777:     // Override the default glib logging function so we get stacks for it too.
 1777:     orig_log_func = g_log_set_default_handler(my_glib_log_func, NULL);
    1:   }
 1777: #endif
 1777: }
36440: 
36440: #else
36440: 
36440: #include <windows.h>
36440: 
36440: #ifdef _M_IX86
36440: 
36440: #if WINVER < 0x0601
36440: typedef struct DECLSPEC_ALIGN(16) _M128A {
36440:   ULONGLONG Low;
36440:   LONGLONG High;
36440: } M128A, *PM128A;
36440: #endif
36440: 
36440: /*
36440:  * The ExtendedRegisters field of the x86.32 CONTEXT structure uses this layout; however,
36440:  * this structure is only made available from winnt.h on x86.64
36440:  */
36440: typedef struct _XMM_SAVE_AREA32 {
36440:   WORD ControlWord;        /* 000 */
36440:   WORD StatusWord;         /* 002 */
36440:   BYTE TagWord;            /* 004 */
36440:   BYTE Reserved1;          /* 005 */
36440:   WORD ErrorOpcode;        /* 006 */
36440:   DWORD ErrorOffset;       /* 008 */
36440:   WORD ErrorSelector;      /* 00c */
36440:   WORD Reserved2;          /* 00e */
36440:   DWORD DataOffset;        /* 010 */
36440:   WORD DataSelector;       /* 014 */
36440:   WORD Reserved3;          /* 016 */
36440:   DWORD MxCsr;             /* 018 */
36440:   DWORD MxCsr_Mask;        /* 01c */
36440:   M128A FloatRegisters[8]; /* 020 */
36440:   M128A XmmRegisters[16];  /* 0a0 */
36440:   BYTE Reserved4[96];      /* 1a0 */
36440: } XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;
36440: 
36440: #define MXCSR(ctx) ((XMM_SAVE_AREA32*)((ctx)->ExtendedRegisters))->MxCsr
36440: #endif
36440: 
36440: #ifdef _M_X64
36440: #define MXCSR(ctx) (ctx)->MxCsr
36440: #endif
36440: 
36440: #if defined(_M_IA32) || define(_M_X64)
36440: 
36440: #define X87CW(ctx) (ctx)->FloatSave.ControlWord
36440: #define X87SW(ctx) (ctx)->FloatSave.StatusWord
36440: 
36440: /*
36440:  * SSE traps raise these exception codes, which are defined in internal NT headers
36440:  * but not winbase.h
36440:  */
36440: #define STATUS_FLOAT_MULTIPLE_FAULTS 0xC00002B4
36440: #define STATUS_FLOAT_MULTIPLE_TRAPS  0xC00002B5
36440: 
36440: LONG __stdcall FpeHandler(PEXCEPTION_POINTERS pe)
36440: {
36440:   PEXCEPTION_RECORD e = (PEXCEPTION_RECORD)pe->ExceptionRecord;
36440:   CONTEXT *c = (CONTEXT*)pe->ContextRecord;
36440: 
36440:   switch (e->ExceptionCode) {
36440:     case STATUS_FLOAT_DENORMAL_OPERAND:
36440:     case STATUS_FLOAT_DIVIDE_BY_ZERO:
36440:     case STATUS_FLOAT_INEXACT_RESULT:
36440:     case STATUS_FLOAT_INVALID_OPERATION:
36440:     case STATUS_FLOAT_OVERFLOW:
36440:     case STATUS_FLOAT_STACK_CHECK:
36440:     case STATUS_FLOAT_UNDERFLOW:
36440:     case STATUS_FLOAT_MULTIPLE_FAULTS:
36440:     case STATUS_FLOAT_MULTIPLE_TRAPS:
36440:       X87CW(c) |= FPU_EXCEPTION_MASK; /* disable all FPU exceptions */
36440:       X86SW(c) &= ~FPU_STATUS_FLAGS;  /* clear all pending FPU exceptions */
36440: #ifdef _M_IA32
36440:       if (c->ContextFlags & CONTEXT_EXTENDED_REGISTERS) {
36440: #endif
36440:         MXCSR(c) |= SSE_EXCEPTION_MASK; /* disable all SSE exceptions */
36440:         MXCSR(c) &= ~SSE_STATUS_FLAGS;  /* clear all pending SSE exceptions */
36440: #ifdef _M_IA32
36440:       }
36440: #endif
36440:       return EXCEPTION_CONTINUE_EXECUTION;
36440:   }
36440:   return EXCEPTION_CONTINUE_SEARCH;
36440: }
36440: 
36440: void InstallSignalHandlers(const char *ProgramName)
36440: {
36440:   SetUnhandledExceptionFilter(FpeHandler);
36440: }
36440: #else
36440: void InstallSignalHandlers(const char *ProgramName)
36440: {
36440: }
36440: #endif
36440: 
36440: #endif
36440: 
36440: 
