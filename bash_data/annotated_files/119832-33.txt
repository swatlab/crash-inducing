     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsNSSComponent.h"
 97317: #include "nsNSSIOLayer.h"
 97317: 
 97317: #include "prlog.h"
 97317: #include "prnetdb.h"
 97317: #include "nsIPrefService.h"
 97317: #include "nsIClientAuthDialogs.h"
 97317: #include "nsClientAuthRemember.h"
 97317: #include "nsISSLErrorListener.h"
 97317: 
 97317: #include "nsPrintfCString.h"
 97317: #include "SSLServerCertVerification.h"
     1: #include "nsNSSCertHelper.h"
     1: #include "nsNSSCleaner.h"
 97317: #include "nsIDocShell.h"
 97317: #include "nsIDocShellTreeItem.h"
 97317: #include "nsISecureBrowserUI.h"
 97317: #include "nsIInterfaceRequestorUtils.h"
 97317: #include "nsCharSeparatedTokenizer.h"
110523: #include "nsIConsoleService.h"
 79873: #include "PSMRunnable.h"
     1: 
 97317: #include "ssl.h"
     1: #include "secerr.h"
 97317: #include "sslerr.h"
 97317: #include "secder.h"
 97317: #include "keyhi.h"
 97317: 
 97317: using namespace mozilla;
 97317: using namespace mozilla::psm;
     1: 
     1: //#define DEBUG_SSL_VERBOSE //Enable this define to get minimal 
     1:                             //reports when doing SSL read/write
     1:                             
     1: //#define DUMP_BUFFER  //Enable this define along with
     1:                        //DEBUG_SSL_VERBOSE to dump SSL
     1:                        //read/write buffer to a log.
     1:                        //Uses PR_LOG except on Mac where
     1:                        //we always write out to our own
     1:                        //file.
     1: 
 97210: namespace {
 83083: 
     1: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
 97317: NSSCleanupAutoPtrClass(void, PR_FREEIF)
     1: 
 69383: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 69383: 
 97317: /* SSM_UserCertChoice: enum for cert choice info */
 97317: typedef enum {ASK, AUTO} SSM_UserCertChoice;
 97317: 
 97210: } // unnamed namespace
     1: 
 97317: #ifdef PR_LOGGING
 97317: extern PRLogModuleInfo* gPIPNSSLog;
 97317: #endif
     1: 
 97317: nsNSSSocketInfo::nsNSSSocketInfo()
106838:   : mFd(nullptr),
 97317:     mCertVerificationState(before_cert_verification),
 97317:     mForSTARTTLS(false),
 97317:     mSSL3Enabled(false),
 97317:     mTLSEnabled(false),
 97317:     mHandshakePending(true),
 97317:     mHasCleartextPhase(false),
 97317:     mHandshakeInProgress(false),
 97317:     mAllowTLSIntoleranceTimeout(true),
 97317:     mRememberClientAuthCertificate(false),
 97317:     mHandshakeStartTime(0),
 99619:     mFirstServerHelloReceived(false),
 97317:     mNPNCompleted(false),
 97317:     mHandshakeCompleted(false),
 97317:     mJoined(false),
 97317:     mSentClientCert(false)
     1: {
     1: }
     1: 
 97317: NS_IMPL_ISUPPORTS_INHERITED2(nsNSSSocketInfo, TransportSecurityInfo,
 97317:                              nsISSLSocketControl,
 97317:                              nsIClientAuthUserDecision)
     1: 
     1: nsresult
 97317: nsNSSSocketInfo::GetHandshakePending(bool *aHandshakePending)
     1: {
 97317:   *aHandshakePending = mHandshakePending;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 97317: nsNSSSocketInfo::SetHandshakePending(bool aHandshakePending)
     1: {
 97317:   mHandshakePending = aHandshakePending;
     1:   return NS_OK;
     1: }
     1: 
 97317: NS_IMETHODIMP nsNSSSocketInfo::GetRememberClientAuthCertificate(bool *aRememberClientAuthCertificate)
     1: {
 97317:   NS_ENSURE_ARG_POINTER(aRememberClientAuthCertificate);
 97317:   *aRememberClientAuthCertificate = mRememberClientAuthCertificate;
     1:   return NS_OK;
     1: }
     1: 
 97317: NS_IMETHODIMP nsNSSSocketInfo::SetRememberClientAuthCertificate(bool aRememberClientAuthCertificate)
     1: {
 97317:   mRememberClientAuthCertificate = aRememberClientAuthCertificate;
     1:   return NS_OK;
     1: }
     1: 
 97317: void nsNSSSocketInfo::SetHasCleartextPhase(bool aHasCleartextPhase)
     1: {
 97317:   mHasCleartextPhase = aHasCleartextPhase;
 83081: }
 83081: 
 97317: bool nsNSSSocketInfo::GetHasCleartextPhase()
     1: {
 97317:   return mHasCleartextPhase;
     1: }
     1: 
     1: NS_IMETHODIMP
 97317: nsNSSSocketInfo::GetNotificationCallbacks(nsIInterfaceRequestor** aCallbacks)
     1: {
 97317:   *aCallbacks = mCallbacks;
 97317:   NS_IF_ADDREF(*aCallbacks);
 14244:   return NS_OK;
 14244: }
 97210: 
 97210: NS_IMETHODIMP
 97317: nsNSSSocketInfo::SetNotificationCallbacks(nsIInterfaceRequestor* aCallbacks)
 14244: {
 97317:   if (!aCallbacks) {
106838:     mCallbacks = nullptr;
 14244:     return NS_OK;
 14244:   }
 97210: 
 97317:   mCallbacks = aCallbacks;
     1: 
     1:   return NS_OK;
     1: }
     1: 
  7879: static void
 97317: getSecureBrowserUI(nsIInterfaceRequestor * callbacks,
 97317:                    nsISecureBrowserUI ** result)
  6597: {
119832:   NS_ASSERTION(result != nullptr, "result parameter to getSecureBrowserUI is null");
106838:   *result = nullptr;
 97317: 
 97317:   NS_ASSERTION(NS_IsMainThread(),
 97317:                "getSecureBrowserUI called off the main thread");
 97317: 
 97317:   if (!callbacks)
 97317:     return;
 97317: 
 97317:   nsCOMPtr<nsISecureBrowserUI> secureUI = do_GetInterface(callbacks);
 97317:   if (secureUI) {
 97317:     secureUI.forget(result);
 97317:     return;
  7252:   }
  7252: 
 97317:   nsCOMPtr<nsIDocShellTreeItem> item = do_GetInterface(callbacks);
 97317:   if (item) {
 97317:     nsCOMPtr<nsIDocShellTreeItem> rootItem;
 97317:     (void) item->GetSameTypeRootTreeItem(getter_AddRefs(rootItem));
 97317:       
 97317:     nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(rootItem);
 97317:     if (docShell) {
 97317:       (void) docShell->GetSecurityUI(result);
 33205:     }
  7252:   }
  7252: }
  7252: 
 97317: void
108991: nsNSSSocketInfo::SetNegotiatedNPN(const char *value, uint32_t length)
  6597: {
 97317:   if (!value)
 97317:     mNegotiatedNPN.Truncate();
 97317:   else
 97317:     mNegotiatedNPN.Assign(value, length);
 97317:   mNPNCompleted = true;
  6597: }
  6597: 
 97317: NS_IMETHODIMP
 97317: nsNSSSocketInfo::GetNegotiatedNPN(nsACString &aNegotiatedNPN)
  6597: {
 97317:   if (!mNPNCompleted)
 97317:     return NS_ERROR_NOT_CONNECTED;
  7252: 
 97317:   aNegotiatedNPN = mNegotiatedNPN;
 97317:   return NS_OK;
  7252: }
  7252: 
 97317: NS_IMETHODIMP
 97317: nsNSSSocketInfo::JoinConnection(const nsACString & npnProtocol,
 97317:                                 const nsACString & hostname,
108991:                                 int32_t port,
106217:                                 bool *_retval)
 97317: {
 97317:   *_retval = false;
 31588: 
 97317:   // Different ports may not be joined together
 97317:   if (port != GetPort())
 97317:     return NS_OK;
 97317: 
 97317:   // Make sure NPN has been completed and matches requested npnProtocol
 97317:   if (!mNPNCompleted || !mNegotiatedNPN.Equals(npnProtocol))
 97317:     return NS_OK;
 97317: 
 97317:   // If this is the same hostname then the certicate status does not
 97317:   // need to be considered. They are joinable.
 97317:   if (GetHostName() && hostname.Equals(GetHostName())) {
 97317:     *_retval = true;
 97317:     return NS_OK;
  7252:   }
  7879: 
 97317:   // Before checking the server certificate we need to make sure the
 97317:   // handshake has completed.
 97317:   if (!mHandshakeCompleted || !SSLStatus() || !SSLStatus()->mServerCert)
 97317:     return NS_OK;
  7879: 
 97317:   // If the cert has error bits (e.g. it is untrusted) then do not join.
 97317:   // The value of mHaveCertErrorBits is only reliable because we know that
 97317:   // the handshake completed.
 97317:   if (SSLStatus()->mHaveCertErrorBits)
 97317:     return NS_OK;
  7879: 
 97317:   // If the connection is using client certificates then do not join
 97317:   // because the user decides on whether to send client certs to hosts on a
 97317:   // per-domain basis.
 97317:   if (mSentClientCert)
 97317:     return NS_OK;
 97317: 
 97317:   // Ensure that the server certificate covers the hostname that would
 97317:   // like to join this connection
 97317: 
106838:   CERTCertificate *nssCert = nullptr;
 97317:   CERTCertificateCleaner nsscertCleaner(nssCert);
 97317: 
 97317:   nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(SSLStatus()->mServerCert);
  7879:   if (cert2)
  7879:     nssCert = cert2->GetCert();
  7879: 
 97317:   if (!nssCert)
 97317:     return NS_OK;
 97317: 
 97317:   if (CERT_VerifyCertName(nssCert, PromiseFlatCString(hostname).get()) !=
 97317:       SECSuccess)
 97317:     return NS_OK;
 97317: 
 97317:   // All tests pass - this is joinable
 97317:   mJoined = true;
 97317:   *_retval = true;
 97317:   return NS_OK;
  7879: }
  7879: 
 97317: nsresult
 97317: nsNSSSocketInfo::GetForSTARTTLS(bool* aForSTARTTLS)
 97317: {
 97317:   *aForSTARTTLS = mForSTARTTLS;
 97317:   return NS_OK;
  7879: }
  7252: 
 97317: nsresult
 97317: nsNSSSocketInfo::SetForSTARTTLS(bool aForSTARTTLS)
 97317: {
 97317:   mForSTARTTLS = aForSTARTTLS;
 97317:   return NS_OK;
  7252: }
  6597: 
 97317: NS_IMETHODIMP
 97317: nsNSSSocketInfo::ProxyStartSSL()
  6597: {
 97317:   return ActivateSSL();
  6597: }
  6597: 
 97317: NS_IMETHODIMP
 97317: nsNSSSocketInfo::StartTLS()
 97317: {
 97317:   return ActivateSSL();
  7879: }
  7879: 
 97317: NS_IMETHODIMP
 97317: nsNSSSocketInfo::SetNPNList(nsTArray<nsCString> &protocolArray)
  7879: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (isAlreadyShutDown())
 97317:     return NS_ERROR_NOT_AVAILABLE;
 97317:   if (!mFd)
 97317:     return NS_ERROR_FAILURE;
 33222: 
 97317:   // the npn list is a concatenated list of 8 bit byte strings.
 97317:   nsCString npnList;
  7879: 
108991:   for (uint32_t index = 0; index < protocolArray.Length(); ++index) {
 97317:     if (protocolArray[index].IsEmpty() ||
 97317:         protocolArray[index].Length() > 255)
 97317:       return NS_ERROR_ILLEGAL_VALUE;
 97317: 
 97317:     npnList.Append(protocolArray[index].Length());
 97317:     npnList.Append(protocolArray[index]);
  6597:   }
  6597:   
 97317:   if (SSL_SetNextProtoNego(
 97317:         mFd,
 97317:         reinterpret_cast<const unsigned char *>(npnList.get()),
 97317:         npnList.Length()) != SECSuccess)
 97317:     return NS_ERROR_FAILURE;
 83081: 
 83081:   return NS_OK;
  6597: }
  6597: 
 97317: nsresult nsNSSSocketInfo::ActivateSSL()
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (isAlreadyShutDown())
 97317:     return NS_ERROR_NOT_AVAILABLE;
 79873: 
 97317:   if (SECSuccess != SSL_OptionSet(mFd, SSL_SECURITY, true))
 97317:     return NS_ERROR_FAILURE;		
 97317:   if (SECSuccess != SSL_ResetHandshake(mFd, false))
 97317:     return NS_ERROR_FAILURE;
     1: 
 97317:   mHandshakePending = true;
 28629: 
 28629:   return NS_OK;
 28629: }
 28629: 
 97317: nsresult nsNSSSocketInfo::GetFileDescPtr(PRFileDesc** aFilePtr)
 97317: {
 97317:   *aFilePtr = mFd;
 97317:   return NS_OK;
 97317: }
 97317: 
 97317: nsresult nsNSSSocketInfo::SetFileDescPtr(PRFileDesc* aFilePtr)
 97317: {
 97317:   mFd = aFilePtr;
 97317:   return NS_OK;
 97317: }
 97317: 
 97317: class PreviousCertRunnable : public SyncRunnableBase
 97317: {
 97317: public:
 97317:   PreviousCertRunnable(nsIInterfaceRequestor * callbacks)
 97317:     : mCallbacks(callbacks)
 97317:   {
 97317:   }
 97317: 
 97317:   virtual void RunOnTargetThread()
 97317:   {
 97317:     nsCOMPtr<nsISecureBrowserUI> secureUI;
 97317:     getSecureBrowserUI(mCallbacks, getter_AddRefs(secureUI));
 97317:     nsCOMPtr<nsISSLStatusProvider> statusProvider = do_QueryInterface(secureUI);
 97317:     if (statusProvider) {
 97317:       nsCOMPtr<nsISSLStatus> status;
 97317:       (void) statusProvider->GetSSLStatus(getter_AddRefs(status));
 97317:       if (status) {
 97317:         (void) status->GetServerCert(getter_AddRefs(mPreviousCert));
 97317:       }
 97317:     }
 97317:   }
 97317: 
 97317:   nsCOMPtr<nsIX509Cert> mPreviousCert; // out
 97317: private:
 97317:   nsCOMPtr<nsIInterfaceRequestor> mCallbacks; // in
 97317: };
 97317: 
 97317: void nsNSSSocketInfo::GetPreviousCert(nsIX509Cert** _result)
 97317: {
 97317:   NS_ASSERTION(_result, "_result parameter to GetPreviousCert is null");
106838:   *_result = nullptr;
 97317: 
119832:   nsRefPtr<PreviousCertRunnable> runnable = new PreviousCertRunnable(mCallbacks);
 97317:   nsresult rv = runnable->DispatchToMainThreadAndWait();
 97317:   NS_ASSERTION(NS_SUCCEEDED(rv), "runnable->DispatchToMainThreadAndWait() failed");
 97317:   runnable->mPreviousCert.forget(_result);
 97317: }
 97317: 
 28629: void
 97317: nsNSSSocketInfo::SetCertVerificationWaiting()
 28629: {
 97317:   // mCertVerificationState may be before_cert_verification for the first
 97317:   // handshake on the connection, or after_cert_verification for subsequent
 97317:   // renegotiation handshakes.
 97317:   NS_ASSERTION(mCertVerificationState != waiting_for_cert_verification,
 97317:                "Invalid state transition to waiting_for_cert_verification");
 97317:   mCertVerificationState = waiting_for_cert_verification;
 97317: }
 97317: 
 97317: // Be careful that SetCertVerificationResult does NOT get called while we are
 97317: // processing a SSL callback function, because SSL_AuthCertificateComplete will
 97317: // attempt to acquire locks that are already held by libssl when it calls
 97317: // callbacks.
 97317: void
 97317: nsNSSSocketInfo::SetCertVerificationResult(PRErrorCode errorCode,
 97317:                                            SSLErrorMessageType errorMessageType)
 97317: {
 97317:   NS_ASSERTION(mCertVerificationState == waiting_for_cert_verification,
 97317:                "Invalid state transition to cert_verification_finished");
 97317: 
 97317:   if (mFd) {
 97317:     SECStatus rv = SSL_AuthCertificateComplete(mFd, errorCode);
 97317:     // Only replace errorCode if there was originally no error
 97317:     if (rv != SECSuccess && errorCode == 0) {
 97317:       errorCode = PR_GetError();
 97317:       errorMessageType = PlainErrorMessage;
 97317:       if (errorCode == 0) {
 97317:         NS_ERROR("SSL_AuthCertificateComplete didn't set error code");
 97317:         errorCode = PR_INVALID_STATE_ERROR;
 97317:       }
 97317:     }
 97317:   }
 97317: 
 97317:   if (errorCode) {
 97317:     SetCanceled(errorCode, errorMessageType);
 97317:   }
 97317: 
 97317:   mCertVerificationState = after_cert_verification;
 97317: }
 97317: 
 97317: void nsNSSSocketInfo::SetHandshakeInProgress(bool aIsIn)
 97317: {
 97317:   mHandshakeInProgress = aIsIn;
 97317: 
 97317:   if (mHandshakeInProgress && !mHandshakeStartTime)
 97317:   {
 97317:     mHandshakeStartTime = PR_IntervalNow();
 97317:   }
 97317: }
 97317: 
 97317: void nsNSSSocketInfo::SetAllowTLSIntoleranceTimeout(bool aAllow)
 97317: {
 97317:   mAllowTLSIntoleranceTimeout = aAllow;
 97317: }
 97317: 
 97317: bool nsNSSSocketInfo::HandshakeTimeout()
 97317: {
 99619:   if (!mAllowTLSIntoleranceTimeout)
 97317:     return false;
 97317: 
 99619:   if (!mHandshakeInProgress)
 99619:     return false; // have not even sent client hello yet
 99619: 
 99619:   if (mFirstServerHelloReceived)
 99619:     return false;
 99619: 
 99619:   // Now we know we are in the first handshake, and haven't received the
 99619:   // ServerHello+Certificate sequence or the
 99619:   // ServerHello+ChangeCipherSpec+Finished sequence.
 99619:   //
 99619:   // XXX: Bug 754356 - waiting to receive the Certificate or Finished messages
 99619:   // may cause us to time out in cases where we shouldn't.
 99619: 
 99619:   static const PRIntervalTime handshakeTimeoutInterval
 99619:     = PR_SecondsToInterval(25);
 99619: 
 97317:   PRIntervalTime now = PR_IntervalNow();
 99619:   bool result = (now - mHandshakeStartTime) > handshakeTimeoutInterval;
 99619:   return result;
 97317: }
 97317: 
 97317: void nsSSLIOLayerHelpers::Cleanup()
 97317: {
 97317:   if (mTLSIntolerantSites) {
 97317:     delete mTLSIntolerantSites;
106838:     mTLSIntolerantSites = nullptr;
 97317:   }
 97317: 
 97317:   if (mTLSTolerantSites) {
 97317:     delete mTLSTolerantSites;
106838:     mTLSTolerantSites = nullptr;
 97317:   }
 97317: 
 97317:   if (mRenegoUnrestrictedSites) {
 97317:     delete mRenegoUnrestrictedSites;
106838:     mRenegoUnrestrictedSites = nullptr;
 97317:   }
 97317: 
 97317:   if (mutex) {
 97317:     delete mutex;
106838:     mutex = nullptr;
 97317:   }
 97317: }
 97317: 
 97317: static void
110523: nsHandleSSLError(nsNSSSocketInfo *socketInfo, 
110523:                  ::mozilla::psm::SSLErrorMessageType errtype, 
110523:                  PRErrorCode err)
 97317: {
 97317:   if (!NS_IsMainThread()) {
 97317:     NS_ERROR("nsHandleSSLError called off the main thread");
 97317:     return;
 97317:   }
 97317: 
 97317:   // SetCanceled is only called by the main thread or the socket transport
 97317:   // thread. Whenever this function is called on the main thread, the SSL
 97317:   // thread is blocked on it. So, no mutex is necessary for
 97317:   // SetCanceled()/GetError*().
 97317:   if (socketInfo->GetErrorCode()) {
 97317:     // If the socket has been flagged as canceled,
 97317:     // the code who did was responsible for setting the error code.
 97317:     return;
 97317:   }
 97317: 
 28629:   nsresult rv;
 97317:   NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
 97317:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
 28629:   if (NS_FAILED(rv))
 28629:     return;
 28629: 
 97317:   nsXPIDLCString hostName;
 97317:   socketInfo->GetHostName(getter_Copies(hostName));
 28629: 
108991:   int32_t port;
 97317:   socketInfo->GetPort(&port);
 28629: 
 97317:   // Try to get a nsISSLErrorListener implementation from the socket consumer.
 97317:   nsCOMPtr<nsIInterfaceRequestor> cb;
 97317:   socketInfo->GetNotificationCallbacks(getter_AddRefs(cb));
 97317:   if (cb) {
 97317:     nsCOMPtr<nsISSLErrorListener> sel = do_GetInterface(cb);
 97317:     if (sel) {
 97317:       nsIInterfaceRequestor *csi = static_cast<nsIInterfaceRequestor*>(socketInfo);
 97317:       nsCString hostWithPortString = hostName;
 97317:       hostWithPortString.AppendLiteral(":");
 97317:       hostWithPortString.AppendInt(port);
 97210:     
 97317:       bool suppressMessage = false; // obsolete, ignored
 97317:       rv = sel->NotifySSLError(csi, err, hostWithPortString, &suppressMessage);
 28629:     }
 28629:   }
 97317:   
110523:   // We must cancel first, which sets the error code.
 97317:   socketInfo->SetCanceled(err, PlainErrorMessage);
110523:   nsXPIDLString errorString;
110523:   socketInfo->GetErrorLogMessage(err, errtype, errorString);
110523:   
110523:   if (!errorString.IsEmpty()) {
110523:     nsCOMPtr<nsIConsoleService> console;
110523:     console = do_GetService(NS_CONSOLESERVICE_CONTRACTID);
110523:     if (console) {
110523:       console->LogStringMessage(errorString.get());
110523:     }
110523:   }
 97317: }
 97317: 
 97317: namespace {
 97317: 
 97317: enum Operation { reading, writing, not_reading_or_writing };
 97317: 
108991: int32_t checkHandshake(int32_t bytesTransfered, bool wasReading,
 97317:                        PRFileDesc* ssl_layer_fd,
 97317:                        nsNSSSocketInfo *socketInfo);
 97317: 
 97317: nsNSSSocketInfo *
 97317: getSocketInfoIfRunning(PRFileDesc * fd, Operation op,
 97317:                        const nsNSSShutDownPreventionLock & /*proofOfLock*/)
 97317: {
 97317:   if (!fd || !fd->lower || !fd->secret ||
 97317:       fd->identity != nsSSLIOLayerHelpers::nsSSLIOLayerIdentity) {
 97317:     NS_ERROR("bad file descriptor passed to getSocketInfoIfRunning");
 97317:     PR_SetError(PR_BAD_DESCRIPTOR_ERROR, 0);
106838:     return nullptr;
 97317:   }
 97317: 
 97317:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
 97317: 
 97317:   if (socketInfo->isAlreadyShutDown() || socketInfo->isPK11LoggedOut()) {
 97317:     PR_SetError(PR_SOCKET_SHUTDOWN_ERROR, 0);
106838:     return nullptr;
 97317:   }
 97317: 
 97317:   if (socketInfo->GetErrorCode()) {
 97317:     PRErrorCode err = socketInfo->GetErrorCode();
 97317:     PR_SetError(err, 0);
 97317:     if (op == reading || op == writing) {
 97317:       // We must do TLS intolerance checks for reads and writes, for timeouts
 97317:       // in particular.
 97317:       (void) checkHandshake(-1, op == reading, fd, socketInfo);
 97317:     }
 97317: 
 97317:     // If we get here, it is probably because cert verification failed and this
 97317:     // is the first I/O attempt since that failure.
106838:     return nullptr;
 97317:   }
 97317: 
 97317:   return socketInfo;
 97317: }
 97317: 
 97317: } // unnnamed namespace
 97317: 
115027: static PRStatus
 97317: nsSSLIOLayerConnect(PRFileDesc* fd, const PRNetAddr* addr,
 97317:                     PRIntervalTime timeout)
 97317: {
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] connecting SSL socket\n", (void*)fd));
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!getSocketInfoIfRunning(fd, not_reading_or_writing, locker))
 97317:     return PR_FAILURE;
 97317:   
 97317:   PRStatus status = fd->lower->methods->connect(fd->lower, addr, timeout);
 97317:   if (status != PR_SUCCESS) {
 97317:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("[%p] Lower layer connect error: %d\n",
 97317:                                       (void*)fd, PR_GetError()));
 97317:     return status;
 97317:   }
 97317: 
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Connect\n", (void*)fd));
 97317:   return status;
 28629: }
 28629: 
 28629: void
 97317: nsSSLIOLayerHelpers::getSiteKey(nsNSSSocketInfo *socketInfo, nsCSubstring &key)
 28629: {
108991:   int32_t port;
 97317:   socketInfo->GetPort(&port);
 28629: 
 97317:   nsXPIDLCString host;
 97317:   socketInfo->GetHostName(getter_Copies(host));
 28629: 
 97317:   key = host + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
 97210: }
 28629: 
 97317: // Call this function to report a site that is possibly TLS intolerant.
101865: // This function will return true, if the given socket is currently using TLS,
101865: // and it's allowed to retry. Retrying only makes sense if an older
101865: // protocol is enabled.
 97317: bool
 97317: nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(nsNSSSocketInfo *socketInfo)
 97317: {
110974:   nsAutoCString key;
 97317:   getSiteKey(socketInfo, key);
 97317: 
 97317:   if (!socketInfo->IsTLSEnabled()) {
 97317:     // We did not offer TLS but failed with an intolerant error using
 97317:     // a different protocol. To give TLS a try on next connection attempt again
 97317:     // drop this site from the list of intolerant sites. TLS failure might be 
 97317:     // caused only by a traffic congestion while the server is TLS tolerant.
 97317:     removeIntolerantSite(key);
 97317:     return false;
 97317:   }
 97317: 
 97317:   if (socketInfo->IsSSL3Enabled()) {
 97317:     // Add this site to the list of TLS intolerant sites.
 97317:     addIntolerantSite(key);
 97317:   }
101865:   else {
101865:     return false; // doesn't make sense to retry
101865:   }
 97317:   
 97317:   return socketInfo->IsTLSEnabled();
 28629: }
 28629: 
 30463: void
 97317: nsSSLIOLayerHelpers::rememberTolerantSite(nsNSSSocketInfo *socketInfo)
 83083: {
 97317:   if (!socketInfo->IsTLSEnabled())
 97317:     return;
 83083: 
110974:   nsAutoCString key;
 97317:   getSiteKey(socketInfo, key);
 83083: 
 97317:   MutexAutoLock lock(*mutex);
 97317:   nsSSLIOLayerHelpers::mTLSTolerantSites->PutEntry(key);
 83083: }
 83083: 
115027: static PRStatus
 97317: nsSSLIOLayerClose(PRFileDesc *fd)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!fd)
 97317:     return PR_FAILURE;
 97317: 
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Shutting down socket\n", (void*)fd));
 97317:   
 97317:   nsNSSSocketInfo *socketInfo = (nsNSSSocketInfo*)fd->secret;
 97317:   NS_ASSERTION(socketInfo,"nsNSSSocketInfo was null for an fd");
 97317: 
 97317:   return socketInfo->CloseSocketAndDestroy(locker);
 97317: }
 97317: 
 97317: PRStatus nsNSSSocketInfo::CloseSocketAndDestroy(
 97317:   const nsNSSShutDownPreventionLock & /*proofOfLock*/)
 97317: {
 97317:   nsNSSShutDownList::trackSSLSocketClose();
 97317: 
 97317:   PRFileDesc* popped = PR_PopIOLayer(mFd, PR_TOP_IO_LAYER);
 97317: 
 97317:   PRStatus status = mFd->methods->close(mFd);
 97317:   
 97317:   // the nsNSSSocketInfo instance can out-live the connection, so we need some
106838:   // indication that the connection has been closed. mFd == nullptr is that
 97317:   // indication. This is needed, for example, when the connection is closed
 97317:   // before we have finished validating the server's certificate.
106838:   mFd = nullptr;
 97317:   
 97317:   if (status != PR_SUCCESS) return status;
 97317: 
 97317:   popped->identity = PR_INVALID_IO_LAYER;
 97317:   NS_RELEASE_THIS();
 97317:   popped->dtor(popped);
 97317: 
 97317:   return PR_SUCCESS;
 97317: }
 97317: 
 97317: #if defined(DEBUG_SSL_VERBOSE) && defined(DUMP_BUFFER)
 97317: /* Dumps a (potentially binary) buffer using SSM_DEBUG. 
 97317:    (We could have used the version in ssltrace.c, but that's
 97317:    specifically tailored to SSLTRACE. Sigh. */
 97317: #define DUMPBUF_LINESIZE 24
 97317: static void
107846: nsDumpBuffer(unsigned char *buf, int len)
 97317: {
 97317:   char hexbuf[DUMPBUF_LINESIZE*3+1];
 97317:   char chrbuf[DUMPBUF_LINESIZE+1];
 97317:   static const char *hex = "0123456789abcdef";
107846:   int i = 0, l = 0;
 97317:   char ch, *c, *h;
 97317:   if (len == 0)
 97317:     return;
 97317:   hexbuf[DUMPBUF_LINESIZE*3] = '\0';
 97317:   chrbuf[DUMPBUF_LINESIZE] = '\0';
 97317:   (void) memset(hexbuf, 0x20, DUMPBUF_LINESIZE*3);
 97317:   (void) memset(chrbuf, 0x20, DUMPBUF_LINESIZE);
 97317:   h = hexbuf;
 97317:   c = chrbuf;
 97317: 
 97317:   while (i < len)
 97317:   {
 97317:     ch = buf[i];
 97317: 
 97317:     if (l == DUMPBUF_LINESIZE)
 97317:     {
 97317:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("%s%s\n", hexbuf, chrbuf));
 97317:       (void) memset(hexbuf, 0x20, DUMPBUF_LINESIZE*3);
 97317:       (void) memset(chrbuf, 0x20, DUMPBUF_LINESIZE);
 97317:       h = hexbuf;
 97317:       c = chrbuf;
 97317:       l = 0;
 97317:     }
 97317: 
 97317:     /* Convert a character to hex. */
 97317:     *h++ = hex[(ch >> 4) & 0xf];
 97317:     *h++ = hex[ch & 0xf];
 97317:     h++;
 97317:         
 97317:     /* Put the character (if it's printable) into the character buffer. */
 97317:     if ((ch >= 0x20) && (ch <= 0x7e))
 97317:       *c++ = ch;
 97317:     else
 97317:       *c++ = '.';
 97317:     i++; l++;
 97317:   }
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("%s%s\n", hexbuf, chrbuf));
 97317: }
 97317: 
 97317: #define DEBUG_DUMP_BUFFER(buf,len) nsDumpBuffer(buf,len)
 97317: #else
 97317: #define DEBUG_DUMP_BUFFER(buf,len)
 97317: #endif
 97317: 
 97317: static bool
108991: isNonSSLErrorThatWeAllowToRetry(int32_t err, bool withInitialCleartext)
 97317: {
 97317:   switch (err)
 97317:   {
 97317:     case PR_CONNECT_RESET_ERROR:
 97317:       if (!withInitialCleartext)
 97317:         return true;
 97317:       break;
 97317:     
 97317:     case PR_END_OF_FILE_ERROR:
 97317:       return true;
 97317:   }
 97317: 
 97317:   return false;
 97317: }
 97317: 
 97317: static bool
108991: isTLSIntoleranceError(int32_t err, bool withInitialCleartext)
 97317: {
 97317:   // This function is supposed to decide, which error codes should
 97317:   // be used to conclude server is TLS intolerant.
 97317:   // Note this only happens during the initial SSL handshake.
 97317:   // 
 97317:   // When not using a proxy we'll see a connection reset error.
 97317:   // When using a proxy, we'll see an end of file error.
 97317:   // In addition check for some error codes where it is reasonable
 97317:   // to retry without TLS.
 97317: 
 97317:   if (isNonSSLErrorThatWeAllowToRetry(err, withInitialCleartext))
 97317:     return true;
 97317: 
 97317:   switch (err)
 97317:   {
 97317:     case SSL_ERROR_BAD_MAC_ALERT:
 97317:     case SSL_ERROR_BAD_MAC_READ:
 97317:     case SSL_ERROR_HANDSHAKE_FAILURE_ALERT:
 97317:     case SSL_ERROR_HANDSHAKE_UNEXPECTED_ALERT:
 97317:     case SSL_ERROR_CLIENT_KEY_EXCHANGE_FAILURE:
 97317:     case SSL_ERROR_ILLEGAL_PARAMETER_ALERT:
 97317:     case SSL_ERROR_NO_CYPHER_OVERLAP:
 97317:     case SSL_ERROR_BAD_SERVER:
 97317:     case SSL_ERROR_BAD_BLOCK_PADDING:
 97317:     case SSL_ERROR_UNSUPPORTED_VERSION:
 97317:     case SSL_ERROR_PROTOCOL_VERSION_ALERT:
 97317:     case SSL_ERROR_RX_MALFORMED_FINISHED:
 97317:     case SSL_ERROR_BAD_HANDSHAKE_HASH_VALUE:
 97317:     case SSL_ERROR_DECODE_ERROR_ALERT:
 97317:     case SSL_ERROR_RX_UNKNOWN_ALERT:
 97317:       return true;
 97317:   }
 97317:   
 97317:   return false;
 97317: }
 97317: 
 97317: class SSLErrorRunnable : public SyncRunnableBase
 97317: {
 97317:  public:
110523:   SSLErrorRunnable(nsNSSSocketInfo * infoObject, 
110523:                    ::mozilla::psm::SSLErrorMessageType errtype, 
110523:                    PRErrorCode errorCode)
110523:     : mInfoObject(infoObject)
110523:     , mErrType(errtype)
110523:     , mErrorCode(errorCode)
 97317:   {
 97317:   }
 97317: 
 97317:   virtual void RunOnTargetThread()
 97317:   {
110523:     nsHandleSSLError(mInfoObject, mErrType, mErrorCode);
 97317:   }
 97317:   
119832:   nsRefPtr<nsNSSSocketInfo> mInfoObject;
110523:   ::mozilla::psm::SSLErrorMessageType mErrType;
 97317:   const PRErrorCode mErrorCode;
 97317: };
 97317: 
 97317: namespace {
 97317: 
108991: int32_t checkHandshake(int32_t bytesTransfered, bool wasReading,
 97317:                        PRFileDesc* ssl_layer_fd,
 97317:                        nsNSSSocketInfo *socketInfo)
 97317: {
 97317:   // This is where we work around all of those SSL servers that don't 
 97317:   // conform to the SSL spec and shutdown a connection when we request
 97317:   // SSL v3.1 (aka TLS).  The spec says the client says what version
 97317:   // of the protocol we're willing to perform, in our case SSL v3.1
 97317:   // In its response, the server says which version it wants to perform.
 97317:   // Many servers out there only know how to do v3.0.  Next, we're supposed
 97317:   // to send back the version of the protocol we requested (ie v3.1).  At
 97317:   // this point many servers's implementations are broken and they shut
 97317:   // down the connection when they don't see the version they sent back.
 97317:   // This is supposed to prevent a man in the middle from forcing one
 97317:   // side to dumb down to a lower level of the protocol.  Unfortunately,
 97317:   // there are enough broken servers out there that such a gross work-around
 97317:   // is necessary.  :(
 97317: 
 97317:   // Additional comment added in August 2006:
 97317:   // When we begun to use TLS hello extensions, we encountered a new class of
 97317:   // broken server, which simply stall for a very long time.
 97317:   // We would like to shorten the timeout, but limit this shorter timeout 
 97317:   // to the handshake phase.
 97317:   // When we arrive here for the first time (for a given socket),
 97317:   // we know the connection is established, and the application code
 97317:   // tried the first read or write. This triggers the beginning of the
 97317:   // SSL handshake phase at the SSL FD level.
 97317:   // We'll make a note of the current time,
 97317:   // and use this to measure the elapsed time since handshake begin.
 97317: 
 97317:   // Do NOT assume TLS intolerance on a closed connection after bad cert ui was shown.
 97317:   // Simply retry.
 97317:   // This depends on the fact that Cert UI will not be shown again,
 97317:   // should the user override the bad cert.
 97317: 
 97317:   bool handleHandshakeResultNow;
 97317:   socketInfo->GetHandshakePending(&handleHandshakeResultNow);
 97317: 
 97317:   bool wantRetry = false;
 97317: 
 97317:   if (0 > bytesTransfered) {
108991:     int32_t err = PR_GetError();
 97317: 
 97317:     if (handleHandshakeResultNow) {
 97317:       if (PR_WOULD_BLOCK_ERROR == err) {
 97317:         socketInfo->SetHandshakeInProgress(true);
 97317:         return bytesTransfered;
 97317:       }
 97317: 
 97317:       if (!wantRetry // no decision yet
 97317:           && isTLSIntoleranceError(err, socketInfo->GetHasCleartextPhase()))
 97317:       {
 97317:         wantRetry = nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(socketInfo);
 97317:       }
 97317:     }
 97317:     
 97317:     // This is the common place where we trigger non-cert-errors on a SSL
 97317:     // socket. This might be reached at any time of the connection.
 97317:     //
 97317:     // The socketInfo->GetErrorCode() check is here to ensure we don't try to
 97317:     // do the synchronous dispatch to the main thread unnecessarily after we've
 97317:     // already handled a certificate error. (SSLErrorRunnable calls
 97317:     // nsHandleSSLError, which has logic to avoid replacing the error message,
 97317:     // so without the !socketInfo->GetErrorCode(), it would just be an
 97317:     // expensive no-op.)
 97317:     if (!wantRetry && (IS_SSL_ERROR(err) || IS_SEC_ERROR(err)) &&
 97317:         !socketInfo->GetErrorCode()) {
119832:       nsRefPtr<SyncRunnableBase> runnable = new SSLErrorRunnable(socketInfo,
110523:                                                                  PlainErrorMessage,
119832:                                                                  err);
 97317:       (void) runnable->DispatchToMainThreadAndWait();
 97317:     }
 97317:   }
 97317:   else if (wasReading && 0 == bytesTransfered) // zero bytes on reading, socket closed
 97317:   {
 97317:     if (handleHandshakeResultNow)
 97317:     {
 97317:       if (!wantRetry // no decision yet
 97317:           && !socketInfo->GetHasCleartextPhase()) // mirror PR_CONNECT_RESET_ERROR treament
 97317:       {
 97317:         wantRetry = 
 97317:           nsSSLIOLayerHelpers::rememberPossibleTLSProblemSite(socketInfo);
 97317:       }
 97317:     }
 97317:   }
 97317: 
 97317:   if (wantRetry) {
 97317:     // We want to cause the network layer to retry the connection.
 97317:     PR_SetError(PR_CONNECT_RESET_ERROR, 0);
 97317:     if (wasReading)
 97317:       bytesTransfered = -1;
 97317:   }
 97317: 
 97317:   // TLS intolerant servers only cause the first transfer to fail, so let's 
 97317:   // set the HandshakePending attribute to false so that we don't try the logic
 97317:   // above again in a subsequent transfer.
 97317:   if (handleHandshakeResultNow) {
 97317:     socketInfo->SetHandshakePending(false);
 97317:     socketInfo->SetHandshakeInProgress(false);
 97317:   }
 97317:   
 97317:   return bytesTransfered;
 97317: }
 97317: 
 97317: }
 97317: 
115027: static int16_t
108991: nsSSLIOLayerPoll(PRFileDesc * fd, int16_t in_flags, int16_t *out_flags)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317: 
 97317:   if (!out_flags)
 97317:   {
 97317:     NS_WARNING("nsSSLIOLayerPoll called with null out_flags");
 97317:     return 0;
 97317:   }
 97317: 
 97317:   *out_flags = 0;
 97317: 
 97317:   nsNSSSocketInfo * socketInfo =
 97317:     getSocketInfoIfRunning(fd, not_reading_or_writing, locker);
 97317: 
 97317:   if (!socketInfo) {
 97317:     // If we get here, it is probably because certificate validation failed
 97317:     // and this is the first I/O operation after the failure. 
 97317:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
 97317:             ("[%p] polling SSL socket right after certificate verification failed "
 97317:                   "or NSS shutdown or SDR logout %d\n",
 97317:              fd, (int) in_flags));
 97317: 
 97317:     NS_ASSERTION(in_flags & PR_POLL_EXCEPT,
 97317:                  "caller did not poll for EXCEPT (canceled)");
 97317:     // Since this poll method cannot return errors, we want the caller to call
 97317:     // PR_Send/PR_Recv right away to get the error, so we tell that we are
 97317:     // ready for whatever I/O they are asking for. (See getSocketInfoIfRunning). 
 97317:     *out_flags = in_flags | PR_POLL_EXCEPT; // see also bug 480619 
 97317:     return in_flags;
 97317:   }
 97317: 
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
 97317:          (socketInfo->IsWaitingForCertVerification()
 97317:             ?  "[%p] polling SSL socket during certificate verification using lower %d\n"
 97317:             :  "[%p] poll SSL socket using lower %d\n",
 97317:          fd, (int) in_flags));
 97317: 
 97317:   // See comments in HandshakeTimeout before moving and/or changing this block
 97317:   if (socketInfo->HandshakeTimeout()) {
 97317:     NS_WARNING("SSL handshake timed out");
 97317:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] handshake timed out\n", fd));
 97317:     NS_ASSERTION(in_flags & PR_POLL_EXCEPT,
 97317:                  "caller did not poll for EXCEPT (handshake timeout)");
 97317:     *out_flags = in_flags | PR_POLL_EXCEPT;
 97317:     socketInfo->SetCanceled(PR_CONNECT_RESET_ERROR, PlainErrorMessage);
 97317:     return in_flags;
 97317:   }
 97317: 
 97317:   // We want the handshake to continue during certificate validation, so we
 97317:   // don't need to do anything special here. libssl automatically blocks when
 97317:   // it reaches any point that would be unsafe to send/receive something before
 97317:   // cert validation is complete.
108991:   int16_t result = fd->lower->methods->poll(fd->lower, in_flags, out_flags);
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] poll SSL socket returned %d\n",
 97317:                                     (void*)fd, (int) result));
 97317:   return result;
 97317: }
 97317: 
 97317: bool nsSSLIOLayerHelpers::nsSSLIOLayerInitialized = false;
 97317: PRDescIdentity nsSSLIOLayerHelpers::nsSSLIOLayerIdentity;
 97317: PRIOMethods nsSSLIOLayerHelpers::nsSSLIOLayerMethods;
106838: Mutex *nsSSLIOLayerHelpers::mutex = nullptr;
106838: nsTHashtable<nsCStringHashKey> *nsSSLIOLayerHelpers::mTLSIntolerantSites = nullptr;
106838: nsTHashtable<nsCStringHashKey> *nsSSLIOLayerHelpers::mTLSTolerantSites = nullptr;
106838: nsTHashtable<nsCStringHashKey> *nsSSLIOLayerHelpers::mRenegoUnrestrictedSites = nullptr;
 97317: bool nsSSLIOLayerHelpers::mTreatUnsafeNegotiationAsBroken = false;
108991: int32_t nsSSLIOLayerHelpers::mWarnLevelMissingRFC5746 = 1;
 97317: 
107846: static int _PSM_InvalidInt(void)
 97317: {
 97317:     PR_ASSERT(!"I/O method is invalid");
 97317:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
 97317:     return -1;
 97317: }
 97317: 
108991: static int64_t _PSM_InvalidInt64(void)
 97317: {
 97317:     PR_ASSERT(!"I/O method is invalid");
 97317:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
 97317:     return -1;
 97317: }
 97317: 
 97317: static PRStatus _PSM_InvalidStatus(void)
 97317: {
 97317:     PR_ASSERT(!"I/O method is invalid");
 97317:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
 97317:     return PR_FAILURE;
 97317: }
 97317: 
 97317: static PRFileDesc *_PSM_InvalidDesc(void)
 97317: {
 97317:     PR_ASSERT(!"I/O method is invalid");
 97317:     PR_SetError(PR_INVALID_METHOD_ERROR, 0);
119832:     return NULL;
 97317: }
 97317: 
115027: static PRStatus PSMGetsockname(PRFileDesc *fd, PRNetAddr *addr)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!getSocketInfoIfRunning(fd, not_reading_or_writing, locker))
 97317:     return PR_FAILURE;
 97317: 
 97317:   return fd->lower->methods->getsockname(fd->lower, addr);
 97317: }
 97317: 
115027: static PRStatus PSMGetpeername(PRFileDesc *fd, PRNetAddr *addr)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!getSocketInfoIfRunning(fd, not_reading_or_writing, locker))
 97317:     return PR_FAILURE;
 97317: 
 97317:   return fd->lower->methods->getpeername(fd->lower, addr);
 97317: }
 97317: 
115027: static PRStatus PSMGetsocketoption(PRFileDesc *fd, PRSocketOptionData *data)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!getSocketInfoIfRunning(fd, not_reading_or_writing, locker))
 97317:     return PR_FAILURE;
 97317: 
 97317:   return fd->lower->methods->getsocketoption(fd, data);
 97317: }
 97317: 
115027: static PRStatus PSMSetsocketoption(PRFileDesc *fd,
 97317:                                    const PRSocketOptionData *data)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!getSocketInfoIfRunning(fd, not_reading_or_writing, locker))
 97317:     return PR_FAILURE;
 97317: 
 97317:   return fd->lower->methods->setsocketoption(fd, data);
 97317: }
 97317: 
115027: static int32_t PSMRecv(PRFileDesc *fd, void *buf, int32_t amount,
107846:     int flags, PRIntervalTime timeout)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   nsNSSSocketInfo *socketInfo = getSocketInfoIfRunning(fd, reading, locker);
 97317:   if (!socketInfo)
 97317:     return -1;
 97317: 
 97317:   if (flags != PR_MSG_PEEK && flags != 0) {
 97317:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
 97317:     return -1;
 97317:   }
 97317: 
108991:   int32_t bytesRead = fd->lower->methods->recv(fd->lower, buf, amount, flags,
 97317:                                                timeout);
 97317: 
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] read %d bytes\n", (void*)fd, bytesRead));
 97317: 
 97317: #ifdef DEBUG_SSL_VERBOSE
 97317:   DEBUG_DUMP_BUFFER((unsigned char*)buf, bytesRead);
 97317: #endif
 97317: 
 97317:   return checkHandshake(bytesRead, true, fd, socketInfo);
 97317: }
 97317: 
115027: static int32_t PSMSend(PRFileDesc *fd, const void *buf, int32_t amount,
107846:     int flags, PRIntervalTime timeout)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   nsNSSSocketInfo *socketInfo = getSocketInfoIfRunning(fd, writing, locker);
 97317:   if (!socketInfo)
 97317:     return -1;
 97317: 
 97317:   if (flags != 0) {
 97317:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
 97317:     return -1;
 97317:   }
 97317: 
 97317: #ifdef DEBUG_SSL_VERBOSE
 97317:   DEBUG_DUMP_BUFFER((unsigned char*)buf, amount);
 97317: #endif
 97317: 
108991:   int32_t bytesWritten = fd->lower->methods->send(fd->lower, buf, amount,
 97317:                                                   flags, timeout);
 97317: 
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] wrote %d bytes\n",
 97317:          fd, bytesWritten));
 97317: 
 97317:   return checkHandshake(bytesWritten, false, fd, socketInfo);
 97317: }
 97317: 
115027: static int32_t
108991: nsSSLIOLayerRead(PRFileDesc* fd, void* buf, int32_t amount)
 97317: {
 97317:   return PSMRecv(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
 97317: }
 97317: 
115027: static int32_t
108991: nsSSLIOLayerWrite(PRFileDesc* fd, const void* buf, int32_t amount)
 97317: {
 97317:   return PSMSend(fd, buf, amount, 0, PR_INTERVAL_NO_TIMEOUT);
 97317: }
 97317: 
115027: static PRStatus PSMConnectcontinue(PRFileDesc *fd, int16_t out_flags)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (!getSocketInfoIfRunning(fd, not_reading_or_writing, locker)) {
 97317:     return PR_FAILURE;
 97317:   }
 97317: 
 97317:   return fd->lower->methods->connectcontinue(fd, out_flags);
 97317: }
 97317: 
107846: static int PSMAvailable(void)
 97317: {
 97317:   // This is called through PR_Available(), but is not implemented in PSM
 97317:   PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);
 97317:   return -1;
 97317: }
 97317: 
108991: static int64_t PSMAvailable64(void)
 97317: {
 97317:   // This is called through PR_Available(), but is not implemented in PSM
 97317:   PR_SetError(PR_NOT_IMPLEMENTED_ERROR, 0);
 97317:   return -1;
 97317: }
 97317: 
 97317: nsresult nsSSLIOLayerHelpers::Init()
 97317: {
 97317:   if (!nsSSLIOLayerInitialized) {
 97317:     nsSSLIOLayerInitialized = true;
 97317:     nsSSLIOLayerIdentity = PR_GetUniqueIdentity("NSS layer");
 97317:     nsSSLIOLayerMethods  = *PR_GetDefaultIOMethods();
 97317: 
 97317:     nsSSLIOLayerMethods.available = (PRAvailableFN)PSMAvailable;
 97317:     nsSSLIOLayerMethods.available64 = (PRAvailable64FN)PSMAvailable64;
 97317:     nsSSLIOLayerMethods.fsync = (PRFsyncFN)_PSM_InvalidStatus;
 97317:     nsSSLIOLayerMethods.seek = (PRSeekFN)_PSM_InvalidInt;
 97317:     nsSSLIOLayerMethods.seek64 = (PRSeek64FN)_PSM_InvalidInt64;
 97317:     nsSSLIOLayerMethods.fileInfo = (PRFileInfoFN)_PSM_InvalidStatus;
 97317:     nsSSLIOLayerMethods.fileInfo64 = (PRFileInfo64FN)_PSM_InvalidStatus;
 97317:     nsSSLIOLayerMethods.writev = (PRWritevFN)_PSM_InvalidInt;
 97317:     nsSSLIOLayerMethods.accept = (PRAcceptFN)_PSM_InvalidDesc;
 97317:     nsSSLIOLayerMethods.bind = (PRBindFN)_PSM_InvalidStatus;
 97317:     nsSSLIOLayerMethods.listen = (PRListenFN)_PSM_InvalidStatus;
 97317:     nsSSLIOLayerMethods.shutdown = (PRShutdownFN)_PSM_InvalidStatus;
 97317:     nsSSLIOLayerMethods.recvfrom = (PRRecvfromFN)_PSM_InvalidInt;
 97317:     nsSSLIOLayerMethods.sendto = (PRSendtoFN)_PSM_InvalidInt;
 97317:     nsSSLIOLayerMethods.acceptread = (PRAcceptreadFN)_PSM_InvalidInt;
 97317:     nsSSLIOLayerMethods.transmitfile = (PRTransmitfileFN)_PSM_InvalidInt;
 97317:     nsSSLIOLayerMethods.sendfile = (PRSendfileFN)_PSM_InvalidInt;
 97317: 
 97317:     nsSSLIOLayerMethods.getsockname = PSMGetsockname;
 97317:     nsSSLIOLayerMethods.getpeername = PSMGetpeername;
 97317:     nsSSLIOLayerMethods.getsocketoption = PSMGetsocketoption;
 97317:     nsSSLIOLayerMethods.setsocketoption = PSMSetsocketoption;
 97317:     nsSSLIOLayerMethods.recv = PSMRecv;
 97317:     nsSSLIOLayerMethods.send = PSMSend;
 97317:     nsSSLIOLayerMethods.connectcontinue = PSMConnectcontinue;
 97317: 
 97317:     nsSSLIOLayerMethods.connect = nsSSLIOLayerConnect;
 97317:     nsSSLIOLayerMethods.close = nsSSLIOLayerClose;
 97317:     nsSSLIOLayerMethods.write = nsSSLIOLayerWrite;
 97317:     nsSSLIOLayerMethods.read = nsSSLIOLayerRead;
 97317:     nsSSLIOLayerMethods.poll = nsSSLIOLayerPoll;
 97317:   }
 97317: 
 97317:   mutex = new Mutex("nsSSLIOLayerHelpers.mutex");
 97317: 
 97317:   mTLSIntolerantSites = new nsTHashtable<nsCStringHashKey>();
119832:   if (!mTLSIntolerantSites)
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832: 
 97317:   mTLSIntolerantSites->Init(1);
 97317: 
 97317:   mTLSTolerantSites = new nsTHashtable<nsCStringHashKey>();
119832:   if (!mTLSTolerantSites)
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832: 
 97317:   // Initialize the tolerant site hashtable to 16 items at the start seems
 97317:   // reasonable as most servers are TLS tolerant. We just want to lower 
 97317:   // the rate of hashtable array reallocation.
 97317:   mTLSTolerantSites->Init(16);
 97317: 
 97317:   mRenegoUnrestrictedSites = new nsTHashtable<nsCStringHashKey>();
119832:   if (!mRenegoUnrestrictedSites)
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832: 
 97317:   mRenegoUnrestrictedSites->Init(1);
 97317: 
 97317:   mTreatUnsafeNegotiationAsBroken = false;
 97317:   
 97317:   return NS_OK;
 97317: }
 97317: 
 97317: void nsSSLIOLayerHelpers::addIntolerantSite(const nsCString &str)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   // Remember intolerant site only if it is not known as tolerant
 97317:   if (!mTLSTolerantSites->Contains(str))
 97317:     nsSSLIOLayerHelpers::mTLSIntolerantSites->PutEntry(str);
 97317: }
 97317: 
 97317: void nsSSLIOLayerHelpers::removeIntolerantSite(const nsCString &str)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   nsSSLIOLayerHelpers::mTLSIntolerantSites->RemoveEntry(str);
 97317: }
 97317: 
 97317: bool nsSSLIOLayerHelpers::isKnownAsIntolerantSite(const nsCString &str)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   return mTLSIntolerantSites->Contains(str);
 97317: }
 97317: 
 97317: void nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(const nsCString &str)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   
 97317:   if (mRenegoUnrestrictedSites) {
 97317:     delete mRenegoUnrestrictedSites;
106838:     mRenegoUnrestrictedSites = nullptr;
 97317:   }
 97317: 
 97317:   mRenegoUnrestrictedSites = new nsTHashtable<nsCStringHashKey>();
 97317:   if (!mRenegoUnrestrictedSites)
 97317:     return;
 97317:   
 97317:   mRenegoUnrestrictedSites->Init(1);
 97317:   
 97317:   nsCCharSeparatedTokenizer toker(str, ',');
 97317: 
 97317:   while (toker.hasMoreTokens()) {
 97317:     const nsCSubstring &host = toker.nextToken();
 97317:     if (!host.IsEmpty()) {
 97317:       mRenegoUnrestrictedSites->PutEntry(host);
 97317:     }
 97317:   }
 97317: }
 97317: 
 97317: bool nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(const nsCString &str)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   return mRenegoUnrestrictedSites->Contains(str);
 97317: }
 97317: 
 97317: void nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(bool broken)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   mTreatUnsafeNegotiationAsBroken = broken;
 97317: }
 97317: 
 97317: bool nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   return mTreatUnsafeNegotiationAsBroken;
 97317: }
 97317: 
108991: void nsSSLIOLayerHelpers::setWarnLevelMissingRFC5746(int32_t level)
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   mWarnLevelMissingRFC5746 = level;
 97317: }
 97317: 
108991: int32_t nsSSLIOLayerHelpers::getWarnLevelMissingRFC5746()
 97317: {
 97317:   MutexAutoLock lock(*mutex);
 97317:   return mWarnLevelMissingRFC5746;
 97317: }
 97317: 
 97317: nsresult
108991: nsSSLIOLayerNewSocket(int32_t family,
 97317:                       const char *host,
108991:                       int32_t port,
 97317:                       const char *proxyHost,
108991:                       int32_t proxyPort,
 97317:                       PRFileDesc **fd,
 97317:                       nsISupports** info,
 97317:                       bool forSTARTTLS,
 97317:                       bool anonymousLoad)
 97317: {
 97317: 
 97317:   PRFileDesc* sock = PR_OpenTCPSocket(family);
 97317:   if (!sock) return NS_ERROR_OUT_OF_MEMORY;
 97317: 
 97317:   nsresult rv = nsSSLIOLayerAddToSocket(family, host, port, proxyHost, proxyPort,
 97317:                                         sock, info, forSTARTTLS, anonymousLoad);
 97317:   if (NS_FAILED(rv)) {
 97317:     PR_Close(sock);
 97317:     return rv;
 97317:   }
 97317: 
 97317:   *fd = sock;
 97317:   return NS_OK;
 97317: }
 97317: 
 97317: /*
 97317:  * Function: SECStatus nsConvertCANamesToStrings()
 97317:  * Purpose: creates CA names strings from (CERTDistNames* caNames)
 97317:  *
 97317:  * Arguments and return values
 97317:  * - arena: arena to allocate strings on
 97317:  * - caNameStrings: filled with CA names strings on return
 97317:  * - caNames: CERTDistNames to extract strings from
 97317:  * - return: SECSuccess if successful; error code otherwise
 97317:  *
 97317:  * Note: copied in its entirety from Nova code
 97317:  */
119200: SECStatus nsConvertCANamesToStrings(PLArenaPool* arena, char** caNameStrings,
 97317:                                       CERTDistNames* caNames)
 97317: {
 97317:     SECItem* dername;
 97317:     SECStatus rv;
 97317:     int headerlen;
108991:     uint32_t contentlen;
 97317:     SECItem newitem;
 97317:     int n;
 97317:     char* namestring;
 97317: 
 97317:     for (n = 0; n < caNames->nnames; n++) {
119832:         newitem.data = NULL;
 97317:         dername = &caNames->names[n];
 97317: 
 97317:         rv = DER_Lengths(dername, &headerlen, &contentlen);
 97317: 
 97317:         if (rv != SECSuccess) {
 97317:             goto loser;
 97317:         }
 97317: 
 97317:         if (headerlen + contentlen != dername->len) {
 97317:             /* This must be from an enterprise 2.x server, which sent
 97317:              * incorrectly formatted der without the outer wrapper of
 97317:              * type and length.  Fix it up by adding the top level
 97317:              * header.
 97317:              */
 97317:             if (dername->len <= 127) {
 97317:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 2);
119832:                 if (newitem.data == NULL) {
 97317:                     goto loser;
 97317:                 }
 97317:                 newitem.data[0] = (unsigned char)0x30;
 97317:                 newitem.data[1] = (unsigned char)dername->len;
 97317:                 (void)memcpy(&newitem.data[2], dername->data, dername->len);
 97317:             }
 97317:             else if (dername->len <= 255) {
 97317:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 3);
119832:                 if (newitem.data == NULL) {
 97317:                     goto loser;
 97317:                 }
 97317:                 newitem.data[0] = (unsigned char)0x30;
 97317:                 newitem.data[1] = (unsigned char)0x81;
 97317:                 newitem.data[2] = (unsigned char)dername->len;
 97317:                 (void)memcpy(&newitem.data[3], dername->data, dername->len);
 97317:             }
 97317:             else {
 97317:                 /* greater than 256, better be less than 64k */
 97317:                 newitem.data = (unsigned char *) PR_Malloc(dername->len + 4);
119832:                 if (newitem.data == NULL) {
 97317:                     goto loser;
 97317:                 }
 97317:                 newitem.data[0] = (unsigned char)0x30;
 97317:                 newitem.data[1] = (unsigned char)0x82;
 97317:                 newitem.data[2] = (unsigned char)((dername->len >> 8) & 0xff);
 97317:                 newitem.data[3] = (unsigned char)(dername->len & 0xff);
 97317:                 memcpy(&newitem.data[4], dername->data, dername->len);
 97317:             }
 97317:             dername = &newitem;
 97317:         }
 97317: 
 97317:         namestring = CERT_DerNameToAscii(dername);
119832:         if (namestring == NULL) {
 97317:             /* XXX - keep going until we fail to convert the name */
 97317:             caNameStrings[n] = const_cast<char*>("");
 97317:         }
 97317:         else {
 97317:             caNameStrings[n] = PORT_ArenaStrdup(arena, namestring);
 97317:             PR_Free(namestring);
119832:             if (caNameStrings[n] == NULL) {
 97317:                 goto loser;
 97317:             }
 97317:         }
 97317: 
119832:         if (newitem.data != NULL) {
 97317:             PR_Free(newitem.data);
 97317:         }
 97317:     }
 97317: 
 97317:     return SECSuccess;
 97317: loser:
119832:     if (newitem.data != NULL) {
 97317:         PR_Free(newitem.data);
 97317:     }
 97317:     return SECFailure;
 97317: }
 97317: 
 97317: /*
 97317:  * structs and ASN1 templates for the limited scope-of-use extension
 97317:  *
 97317:  * CertificateScopeEntry ::= SEQUENCE {
 97317:  *     name GeneralName, -- pattern, as for NameConstraints
 97317:  *     portNumber INTEGER OPTIONAL }
 97317:  *
 97317:  * CertificateScopeOfUse ::= SEQUENCE OF CertificateScopeEntry
 97317:  */
 97317: /*
 97317:  * CERTCertificateScopeEntry: struct for scope entry that can be consumed by
 97317:  *                            the code
 97317:  * certCertificateScopeOfUse: struct that represents the decoded extension data
 97317:  */
 97317: typedef struct {
 97317:     SECItem derConstraint;
 97317:     SECItem derPort;
 97317:     CERTGeneralName* constraint; /* decoded constraint */
107846:     int port; /* decoded port number */
 97317: } CERTCertificateScopeEntry;
 97317: 
 97317: typedef struct {
 97317:     CERTCertificateScopeEntry** entries;
 97317: } certCertificateScopeOfUse;
 97317: 
 97317: /* corresponding ASN1 templates */
 97317: static const SEC_ASN1Template cert_CertificateScopeEntryTemplate[] = {
 97317:     { SEC_ASN1_SEQUENCE, 
119832:       0, NULL, sizeof(CERTCertificateScopeEntry) },
 97317:     { SEC_ASN1_ANY,
 97317:       offsetof(CERTCertificateScopeEntry, derConstraint) },
 97317:     { SEC_ASN1_OPTIONAL | SEC_ASN1_INTEGER,
 97317:       offsetof(CERTCertificateScopeEntry, derPort) },
 97317:     { 0 }
 97317: };
 97317: 
 97317: static const SEC_ASN1Template cert_CertificateScopeOfUseTemplate[] = {
 97317:     { SEC_ASN1_SEQUENCE_OF, 0, cert_CertificateScopeEntryTemplate }
 97317: };
 97317: 
 97317: #if 0
 97317: /* 
 97317:  * decodes the extension data and create CERTCertificateScopeEntry that can
 97317:  * be consumed by the code
 97317:  */
 97317: static
 97317: SECStatus cert_DecodeScopeOfUseEntries(PRArenaPool* arena, SECItem* extData,
 97317:                                        CERTCertificateScopeEntry*** entries,
 97317:                                        int* numEntries)
 97317: {
119832:     certCertificateScopeOfUse* scope = NULL;
 97317:     SECStatus rv = SECSuccess;
 97317:     int i;
 97317: 
119832:     *entries = NULL; /* in case of failure */
 97317:     *numEntries = 0; /* ditto */
 97317: 
 97317:     scope = (certCertificateScopeOfUse*)
 97317:         PORT_ArenaZAlloc(arena, sizeof(certCertificateScopeOfUse));
119832:     if (scope == NULL) {
 97317:         goto loser;
 97317:     }
 97317: 
 97317:     rv = SEC_ASN1DecodeItem(arena, (void*)scope, 
 97317:                             cert_CertificateScopeOfUseTemplate, extData);
 97317:     if (rv != SECSuccess) {
 97317:         goto loser;
 97317:     }
 97317: 
 97317:     *entries = scope->entries;
119832:     PR_ASSERT(*entries != NULL);
 97317: 
 97317:     /* first, let's count 'em. */
119832:     for (i = 0; (*entries)[i] != NULL; i++) ;
 97317:     *numEntries = i;
 97317: 
 97317:     /* convert certCertificateScopeEntry sequence into what we can readily
 97317:      * use
 97317:      */
 97317:     for (i = 0; i < *numEntries; i++) {
 97317:         (*entries)[i]->constraint = 
 97317:             CERT_DecodeGeneralName(arena, &((*entries)[i]->derConstraint), 
119832:                                    NULL);
119832:         if ((*entries)[i]->derPort.data != NULL) {
 97317:             (*entries)[i]->port = 
 97317:                 (int)DER_GetInteger(&((*entries)[i]->derPort));
 97317:         }
 97317:         else {
 97317:             (*entries)[i]->port = 0;
 97317:         }
 97317:     }
 97317: 
 97317:     goto done;
 97317: loser:
 97317:     if (rv == SECSuccess) {
 97317:         rv = SECFailure;
 97317:     }
 97317: done:
 97317:     return rv;
 97317: }
 97317: 
 97317: static SECStatus cert_DecodeCertIPAddress(SECItem* genname, 
108991:                                           uint32_t* constraint, uint32_t* mask)
 97317: {
 97317:     /* in case of failure */
 97317:     *constraint = 0;
 97317:     *mask = 0;
 97317: 
119832:     PR_ASSERT(genname->data != NULL);
119832:     if (genname->data == NULL) {
 97317:         return SECFailure;
 97317:     }
 97317:     if (genname->len != 8) {
 97317:         /* the length must be 4 byte IP address with 4 byte subnet mask */
 97317:         return SECFailure;
 97317:     }
 97317: 
 97317:     /* get them in the right order */
108991:     *constraint = PR_ntohl((uint32_t)(*genname->data));
108991:     *mask = PR_ntohl((uint32_t)(*(genname->data + 4)));
 97317: 
 97317:     return SECSuccess;
 97317: }
 97317: 
 97317: static char* _str_to_lower(char* string)
 97317: {
 97317: #ifdef XP_WIN
 97317:     return _strlwr(string);
 97317: #else
 97317:     int i;
 97317:     for (i = 0; string[i] != '\0'; i++) {
 97317:         string[i] = tolower(string[i]);
 97317:     }
 97317:     return string;
 97317: #endif
 97317: }
 97317: 
 97317: /*
 97317:  * Sees if the client certificate has a restriction in presenting the cert
 97317:  * to the host: returns true if there is no restriction or if the hostname
 97317:  * (and the port) satisfies the restriction, or false if the hostname (and
 97317:  * the port) does not satisfy the restriction
 97317:  */
 97317: static bool CERT_MatchesScopeOfUse(CERTCertificate* cert, char* hostname,
107846:                                      char* hostIP, int port)
 97317: {
 97317:     bool rv = true; /* whether the cert can be presented */
 97317:     SECStatus srv;
 97317:     SECItem extData;
119832:     PLArenaPool* arena = NULL;
119832:     CERTCertificateScopeEntry** entries = NULL;
 97317:     /* arrays of decoded scope entries */
 97317:     int numEntries = 0;
 97317:     int i;
119832:     char* hostLower = NULL;
108991:     uint32_t hostIPAddr = 0;
 97317: 
119832:     PR_ASSERT((cert != NULL) && (hostname != NULL) && (hostIP != NULL));
 97317: 
 97317:     /* find cert extension */
 97317:     srv = CERT_FindCertExtension(cert, SEC_OID_NS_CERT_EXT_SCOPE_OF_USE,
 97317:                                  &extData);
 97317:     if (srv != SECSuccess) {
 97317:         /* most of the time, this means the extension was not found: also,
 97317:          * since this is not a critical extension (as of now) we may simply
 97317:          * return true
 97317:          */
 97317:         goto done;
 97317:     }
 97317: 
 97317:     arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
119832:     if (arena == NULL) {
 97317:         goto done;
 97317:     }
 97317: 
 97317:     /* decode the scope of use entries into pairs of GeneralNames and
 97317:      * an optional port numbers
 97317:      */
 97317:     srv = cert_DecodeScopeOfUseEntries(arena, &extData, &entries, &numEntries);
 97317:     if (srv != SECSuccess) {
 97317:         /* XXX What should we do when we failed to decode the extension?  This
 97317:          *     may mean either the extension was malformed or some (unlikely)
 97317:          *     fatal error on our part: my argument is that if the extension 
 97317:          *     was malformed the extension "disqualifies" as a valid 
 97317:          *     constraint and we may present the cert
 97317:          */
 97317:         goto done;
 97317:     }
 97317: 
 97317:     /* loop over these structures */
 97317:     for (i = 0; i < numEntries; i++) {
 97317:         /* determine whether the GeneralName is a DNS pattern, an IP address 
 97317:          * constraint, or else
 97317:          */
 97317:         CERTGeneralName* genname = entries[i]->constraint;
 97317: 
119832:         /* if constraint is NULL, don't bother looking */
119832:         if (genname == NULL) {
 97317:             /* this is not a failure: just continue */
 97317:             continue;
 97317:         }
 97317: 
 97317:         switch (genname->type) {
 97317:         case certDNSName: {
 97317:             /* we have a DNS name constraint; we should use only the host name
 97317:              * information
 97317:              */
119832:             char* pattern = NULL;
119832:             char* substring = NULL;
 97317: 
 97317:             /* null-terminate the string */
 97317:             genname->name.other.data[genname->name.other.len] = '\0';
 97317:             pattern = _str_to_lower((char*)genname->name.other.data);
 97317: 
119832:             if (hostLower == NULL) {
 97317:                 /* so that it's done only if necessary and only once */
 97317:                 hostLower = _str_to_lower(PL_strdup(hostname));
 97317:             }
 97317: 
 97317:             /* the hostname satisfies the constraint */
119832:             if (((substring = strstr(hostLower, pattern)) != NULL) &&
 97317:                 /* the hostname contains the pattern */
 97317:                 (strlen(substring) == strlen(pattern)) &&
 97317:                 /* the hostname ends with the pattern */
 97317:                 ((substring == hostLower) || (*(substring-1) == '.'))) {
 97317:                 /* the hostname either is identical to the pattern or
 97317:                  * belongs to a subdomain
 97317:                  */
 97317:                 rv = true;
 97317:             }
 97317:             else {
 97317:                 rv = false;
 97317:             }
 97317:             /* clean up strings if necessary */
 97317:             break;
 97317:         }
 97317:         case certIPAddress: {
108991:             uint32_t constraint;
108991:             uint32_t mask;
 97317:             PRNetAddr addr;
 97317:             
 97317:             if (hostIPAddr == 0) {
 97317:                 /* so that it's done only if necessary and only once */
 97317:                 PR_StringToNetAddr(hostIP, &addr);
 97317:                 hostIPAddr = addr.inet.ip;
 97317:             }
 97317: 
 97317:             if (cert_DecodeCertIPAddress(&(genname->name.other), &constraint, 
 97317:                                          &mask) != SECSuccess) {
 97317:                 continue;
 97317:             }
 97317:             if ((hostIPAddr & mask) == (constraint & mask)) {
 97317:                 rv = true;
 97317:             }
 97317:             else {
 97317:                 rv = false;
 97317:             }
 97317:             break;
 97317:         }
 97317:         default:
 97317:             /* ill-formed entry: abort */
 97317:             continue; /* go to the next entry */
 97317:         }
 97317: 
 97317:         if (!rv) {
 97317:             /* we do not need to check the port: go to the next entry */
 97317:             continue;
 97317:         }
 97317: 
 97317:         /* finally, check the optional port number */
 97317:         if ((entries[i]->port != 0) && (port != entries[i]->port)) {
 97317:             /* port number does not match */
 97317:             rv = false;
 97317:             continue;
 97317:         }
 97317: 
 97317:         /* we have a match */
 97317:         PR_ASSERT(rv);
 97317:         break;
 97317:     }
 97317: done:
 97317:     /* clean up entries */
119832:     if (arena != NULL) {
 97317:         PORT_FreeArena(arena, false);
 97317:     }
119832:     if (hostLower != NULL) {
 97317:         PR_Free(hostLower);
 97317:     }
 97317:     return rv;
 97317: }
 97317: #endif
 97317: 
 97317: /*
 97317:  * Function: SSMStatus SSM_SetUserCertChoice()
 97317: 
 97317:  * Purpose: sets certChoice by reading the preference
 97317:  *
 97317:  * Arguments and return values
 97317:  * - conn: SSMSSLDataConnection
 97317:  * - returns: SSM_SUCCESS if successful; SSM_FAILURE otherwise
 97317:  *
 97317:  * Note: If done properly, this function will read the identifier strings
 97317:  *		 for ASK and AUTO modes, read the selected strings from the
 97317:  *		 preference, compare the strings, and determine in which mode it is
 97317:  *		 in.
 97317:  *       We currently use ASK mode for UI apps and AUTO mode for UI-less
 97317:  *       apps without really asking for preferences.
 97317:  */
 97317: nsresult nsGetUserCertChoice(SSM_UserCertChoice* certChoice)
 97317: {
119832: 	char *mode=NULL;
 97317: 	nsresult ret;
 97317: 
 97317: 	NS_ENSURE_ARG_POINTER(certChoice);
 97317: 
 97317: 	nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
 97317: 
 97317: 	ret = pref->GetCharPref("security.default_personal_cert", &mode);
 97317: 	if (NS_FAILED(ret)) {
 97317: 		goto loser;
 97317: 	}
 97317: 
 97317:     if (PL_strcmp(mode, "Select Automatically") == 0) {
 97317: 		*certChoice = AUTO;
 97317: 	}
 97317:     else if (PL_strcmp(mode, "Ask Every Time") == 0) {
 97317:         *certChoice = ASK;
 97317:     }
 97317:     else {
 97317:       // Most likely we see a nickname from a migrated cert.
 97317:       // We do not currently support that, ask the user which cert to use.
 97317: 		  *certChoice = ASK;
 97317: 	}
 97317: 
 97317: loser:
 97317: 	if (mode) {
 97317: 		nsMemory::Free(mode);
 97317: 	}
 97317: 	return ret;
 97317: }
 97317: 
 97317: static bool hasExplicitKeyUsageNonRepudiation(CERTCertificate *cert)
 97317: {
 97317:   /* There is no extension, v1 or v2 certificate */
 97317:   if (!cert->extensions)
 97317:     return false;
 97317: 
 97317:   SECStatus srv;
 97317:   SECItem keyUsageItem;
119832:   keyUsageItem.data = NULL;
 97317: 
 97317:   srv = CERT_FindKeyUsageExtension(cert, &keyUsageItem);
 97317:   if (srv == SECFailure)
 97317:     return false;
 97317: 
 97317:   unsigned char keyUsage = keyUsageItem.data[0];
 97317:   PORT_Free (keyUsageItem.data);
 97317: 
 97317:   return !!(keyUsage & KU_NON_REPUDIATION);
 97317: }
 97317: 
 97317: class ClientAuthDataRunnable : public SyncRunnableBase
 97317: {
 97317: public:
 97317:   ClientAuthDataRunnable(CERTDistNames* caNames,
 97317:                          CERTCertificate** pRetCert,
 97317:                          SECKEYPrivateKey** pRetKey,
 97317:                          nsNSSSocketInfo * info,
 97317:                          CERTCertificate * serverCert) 
 97317:     : mRV(SECFailure)
 97317:     , mErrorCodeToReport(SEC_ERROR_NO_MEMORY)
 97317:     , mPRetCert(pRetCert)
 97317:     , mPRetKey(pRetKey)
 97317:     , mCANames(caNames)
 97317:     , mSocketInfo(info)
 97317:     , mServerCert(serverCert)
 97317:   {
 97317:   }
 97317: 
 97317:   SECStatus mRV;                        // out
 97317:   PRErrorCode mErrorCodeToReport;       // out
 97317:   CERTCertificate** const mPRetCert;    // in/out
 97317:   SECKEYPrivateKey** const mPRetKey;    // in/out
 97317: protected:
 97317:   virtual void RunOnTargetThread();
 97317: private:
 97317:   CERTDistNames* const mCANames;        // in
 97317:   nsNSSSocketInfo * const mSocketInfo;  // in
 97317:   CERTCertificate * const mServerCert;  // in
 97317: };
 97317: 
 97317: /*
 97317:  * Function: SECStatus SSM_SSLGetClientAuthData()
 97317:  * Purpose: this callback function is used to pull client certificate
 97317:  *			information upon server request
 97317:  *
 97317:  * Arguments and return values
 97317:  * - arg: SSL data connection
 97317:  * - socket: SSL socket we're dealing with
 97317:  * - caNames: list of CA names
 97317:  * - pRetCert: returns a pointer to a pointer to a valid certificate if
 97317:  *			   successful; otherwise NULL
 97317:  * - pRetKey: returns a pointer to a pointer to the corresponding key if
 97317:  *			  successful; otherwise NULL
 97317:  * - returns: SECSuccess if successful; error code otherwise
 97317:  */
 97317: SECStatus nsNSS_SSLGetClientAuthData(void* arg, PRFileDesc* socket,
 97317: 								   CERTDistNames* caNames,
 97317: 								   CERTCertificate** pRetCert,
 97317: 								   SECKEYPrivateKey** pRetKey)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317: 
 97317:   if (!socket || !caNames || !pRetCert || !pRetKey) {
 97317:     PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
 97317:     return SECFailure;
 97317:   }
 97317: 
119832:   nsRefPtr<nsNSSSocketInfo> info
119832:         = reinterpret_cast<nsNSSSocketInfo*>(socket->higher->secret);
 97317: 
 97317:   CERTCertificate* serverCert = SSL_PeerCertificate(socket);
 97317:   if (!serverCert) {
 97317:     NS_NOTREACHED("Missing server certificate should have been detected during "
 97317:                   "server cert authentication.");
 97317:     PR_SetError(SSL_ERROR_NO_CERTIFICATE, 0);
 97317:     return SECFailure;
 97317:   }
 97317: 
 97317:   if (info->GetJoined()) {
 97317:     // We refuse to send a client certificate when there are multiple hostnames
 97317:     // joined on this connection, because we only show the user one hostname
 97317:     // (mHostName) in the client certificate UI.
 97317: 
 97317:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
 97317:            ("[%p] Not returning client cert due to previous join\n", socket));
106838:     *pRetCert = nullptr;
106838:     *pRetKey = nullptr;
 97317:     return SECSuccess;
 97317:   }
 97317: 
 97317:   // XXX: This should be done asynchronously; see bug 696976
119832:   nsRefPtr<ClientAuthDataRunnable> runnable =
119832:     new ClientAuthDataRunnable(caNames, pRetCert, pRetKey, info, serverCert);
 97317:   nsresult rv = runnable->DispatchToMainThreadAndWait();
 97317:   if (NS_FAILED(rv)) {
 97317:     PR_SetError(SEC_ERROR_NO_MEMORY, 0);
 97317:     return SECFailure;
 97317:   }
 97317:   
 97317:   if (runnable->mRV != SECSuccess) {
 97317:     PR_SetError(runnable->mErrorCodeToReport, 0);
 97317:   } else if (*runnable->mPRetCert || *runnable->mPRetKey) {
 97317:     // Make joinConnection prohibit joining after we've sent a client cert
 97317:     info->SetSentClientCert();
 97317:   }
 97317: 
 97317:   return runnable->mRV;
 97317: }
 97317: 
 97317: void ClientAuthDataRunnable::RunOnTargetThread()
 97317: {
119832:   PLArenaPool* arena = NULL;
 97317:   char** caNameStrings;
119832:   CERTCertificate* cert = NULL;
119832:   SECKEYPrivateKey* privKey = NULL;
119832:   CERTCertList* certList = NULL;
 97317:   CERTCertListNode* node;
119832:   CERTCertNicknames* nicknames = NULL;
119832:   char* extracted = NULL;
107846:   int keyError = 0; /* used for private key retrieval error */
 97317:   SSM_UserCertChoice certChoice;
108991:   int32_t NumberOfCerts = 0;
 97317:   void * wincx = mSocketInfo;
 97317: 
 97317:   /* create caNameStrings */
 97317:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
119832:   if (arena == NULL) {
 97317:     goto loser;
 97317:   }
 97317: 
 97317:   caNameStrings = (char**)PORT_ArenaAlloc(arena, 
 97317:                                           sizeof(char*)*(mCANames->nnames));
119832:   if (caNameStrings == NULL) {
 97317:     goto loser;
 97317:   }
 97317: 
 97317:   mRV = nsConvertCANamesToStrings(arena, caNameStrings, mCANames);
 97317:   if (mRV != SECSuccess) {
 97317:     goto loser;
 97317:   }
 97317: 
 97317:   /* get the preference */
 97317:   if (NS_FAILED(nsGetUserCertChoice(&certChoice))) {
 97317:     goto loser;
 97317:   }
 97317: 
 97317:   /* find valid user cert and key pair */	
 97317:   if (certChoice == AUTO) {
 97317:     /* automatically find the right cert */
 97317: 
 97317:     /* find all user certs that are valid and for SSL */
 97317:     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
 97317:                                          certUsageSSLClient, false,
 97317:                                          true, wincx);
119832:     if (certList == NULL) {
 97317:       goto noCert;
 97317:     }
 97317: 
 97317:     /* filter the list to those issued by CAs supported by the server */
 97317:     mRV = CERT_FilterCertListByCANames(certList, mCANames->nnames,
 97317:                                        caNameStrings, certUsageSSLClient);
 97317:     if (mRV != SECSuccess) {
 97317:       goto noCert;
 97317:     }
 97317: 
 97317:     /* make sure the list is not empty */
 97317:     node = CERT_LIST_HEAD(certList);
 97317:     if (CERT_LIST_END(node, certList)) {
 97317:       goto noCert;
 97317:     }
 97317: 
119832:     CERTCertificate* low_prio_nonrep_cert = NULL;
 97317:     CERTCertificateCleaner low_prio_cleaner(low_prio_nonrep_cert);
 97317: 
 97317:     /* loop through the list until we find a cert with a key */
 97317:     while (!CERT_LIST_END(node, certList)) {
 97317:       /* if the certificate has restriction and we do not satisfy it
 97317:        * we do not use it
 97317:        */
 97317: #if 0		/* XXX This must be re-enabled */
 97317:       if (!CERT_MatchesScopeOfUse(node->cert, mSocketInfo->GetHostName,
 97317:                                   info->GetHostIP, info->GetHostPort)) {
 97317:           node = CERT_LIST_NEXT(node);
 97317:           continue;
 97317:       }
 97317: #endif
 97317: 
 97317:       privKey = PK11_FindKeyByAnyCert(node->cert, wincx);
119832:       if (privKey != NULL) {
 97317:         if (hasExplicitKeyUsageNonRepudiation(node->cert)) {
 97317:           SECKEY_DestroyPrivateKey(privKey);
119832:           privKey = NULL;
 97317:           // Not a prefered cert
 97317:           if (!low_prio_nonrep_cert) // did not yet find a low prio cert
 97317:             low_prio_nonrep_cert = CERT_DupCertificate(node->cert);
 97317:         }
 97317:         else {
 97317:           // this is a good cert to present
 97317:           cert = CERT_DupCertificate(node->cert);
 97317:           break;
 97317:         }
 97317:       }
 97317:       keyError = PR_GetError();
 97317:       if (keyError == SEC_ERROR_BAD_PASSWORD) {
 97317:           /* problem with password: bail */
 97317:           goto loser;
 97317:       }
 97317: 
 97317:       node = CERT_LIST_NEXT(node);
 97317:     }
 97317: 
 97317:     if (!cert && low_prio_nonrep_cert) {
 97317:       cert = low_prio_nonrep_cert;
119832:       low_prio_nonrep_cert = NULL; // take it away from the cleaner
 97317:       privKey = PK11_FindKeyByAnyCert(cert, wincx);
 97317:     }
 97317: 
119832:     if (cert == NULL) {
 97317:         goto noCert;
 97317:     }
 97317:   }
 97317:   else { // Not Auto => ask
 97317:     /* Get the SSL Certificate */
 97317: 
 97317:     nsXPIDLCString hostname;
 97317:     mSocketInfo->GetHostName(getter_Copies(hostname));
 97317: 
 97317:     nsresult rv;
 97317:     NS_DEFINE_CID(nssComponentCID, NS_NSSCOMPONENT_CID);
 97317:     nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(nssComponentCID, &rv));
119832:     nsRefPtr<nsClientAuthRememberService> cars;
 97317:     if (nssComponent) {
119832:       nssComponent->GetClientAuthRememberService(getter_AddRefs(cars));
 97317:     }
 97317: 
 97317:     bool hasRemembered = false;
 97317:     nsCString rememberedDBKey;
 97317:     if (cars) {
 97317:       bool found;
 97317:       nsresult rv = cars->HasRememberedDecision(hostname, mServerCert,
 97317:                                                 rememberedDBKey, &found);
 97317:       if (NS_SUCCEEDED(rv) && found) {
 97317:         hasRemembered = true;
 97317:       }
 97317:     }
 97317: 
 97317:     bool canceled = false;
 97317: 
 97317: if (hasRemembered)
 97317: {
 97317:     if (rememberedDBKey.IsEmpty())
 97317:     {
 97317:       canceled = true;
 97317:     }
 97317:     else
 97317:     {
 97317:       nsCOMPtr<nsIX509CertDB> certdb;
 97317:       certdb = do_GetService(NS_X509CERTDB_CONTRACTID);
 97317:       if (certdb)
 97317:       {
 97317:         nsCOMPtr<nsIX509Cert> found_cert;
 97317:         nsresult find_rv = 
106838:           certdb->FindCertByDBKey(rememberedDBKey.get(), nullptr,
 97317:                                   getter_AddRefs(found_cert));
 97317:         if (NS_SUCCEEDED(find_rv) && found_cert) {
 97317:           nsNSSCertificate *obj_cert = reinterpret_cast<nsNSSCertificate *>(found_cert.get());
 97317:           if (obj_cert) {
 97317:             cert = obj_cert->GetCert();
 97317: 
 97317: #ifdef DEBUG_kaie
 97317:             nsAutoString nick, nickWithSerial, details;
 97317:             if (NS_SUCCEEDED(obj_cert->FormatUIStrings(nick, 
 97317:                                                        nickWithSerial, 
 97317:                                                        details))) {
 97317:               NS_LossyConvertUTF16toASCII asc(nickWithSerial);
 97317:               fprintf(stderr, "====> remembered serial %s\n", asc.get());
 97317:             }
 97317: #endif
 97317: 
 97317:           }
 97317:         }
 97317:         
 97317:         if (!cert) {
 97317:           hasRemembered = false;
 97317:         }
 97317:       }
 97317:     }
 97317: }
 97317: 
 97317: if (!hasRemembered)
 97317: {
 97317:     /* user selects a cert to present */
119832:     nsIClientAuthDialogs *dialogs = NULL;
108991:     int32_t selectedIndex = -1;
119832:     PRUnichar **certNicknameList = NULL;
119832:     PRUnichar **certDetailsList = NULL;
 97317: 
 97317:     /* find all user certs that are for SSL */
 97317:     /* note that we are allowing expired certs in this list */
 97317:     certList = CERT_FindUserCertsByUsage(CERT_GetDefaultCertDB(), 
 97317:                                          certUsageSSLClient, false, 
 97317:                                          false, wincx);
119832:     if (certList == NULL) {
 97317:       goto noCert;
 97317:     }
 97317: 
 97317:     if (mCANames->nnames != 0) {
 97317:       /* filter the list to those issued by CAs supported by the 
 97317:        * server 
 97317:        */
 97317:       mRV = CERT_FilterCertListByCANames(certList, mCANames->nnames, 
 97317:                                         caNameStrings, 
 97317:                                         certUsageSSLClient);
 97317:       if (mRV != SECSuccess) {
 97317:         goto loser;
 97317:       }
 97317:     }
 97317: 
 97317:     if (CERT_LIST_END(CERT_LIST_HEAD(certList), certList)) {
 97317:       /* list is empty - no matching certs */
 97317:       goto noCert;
 97317:     }
 97317: 
 97317:     /* filter it further for hostname restriction */
 97317:     node = CERT_LIST_HEAD(certList);
 97317:     while (!CERT_LIST_END(node, certList)) {
 97317:       ++NumberOfCerts;
 97317: #if 0 /* XXX Fix this */
 97317:       if (!CERT_MatchesScopeOfUse(node->cert, conn->hostName,
 97317:                                   conn->hostIP, conn->port)) {
 97317:         CERTCertListNode* removed = node;
 97317:         node = CERT_LIST_NEXT(removed);
 97317:         CERT_RemoveCertListNode(removed);
 97317:       }
 97317:       else {
 97317:         node = CERT_LIST_NEXT(node);
 97317:       }
 97317: #endif
 97317:       node = CERT_LIST_NEXT(node);
 97317:     }
 97317:     if (CERT_LIST_END(CERT_LIST_HEAD(certList), certList)) {
 97317:       goto noCert;
 97317:     }
 97317: 
 97317:     nicknames = getNSSCertNicknamesFromCertList(certList);
 97317: 
119832:     if (nicknames == NULL) {
 97317:       goto loser;
 97317:     }
 97317: 
 97317:     NS_ASSERTION(nicknames->numnicknames == NumberOfCerts, "nicknames->numnicknames != NumberOfCerts");
 97317: 
 97317:     /* Get CN and O of the subject and O of the issuer */
 97317:     char *ccn = CERT_GetCommonName(&mServerCert->subject);
 97317:     void *v = ccn;
 97317:     voidCleaner ccnCleaner(v);
 97317:     NS_ConvertUTF8toUTF16 cn(ccn);
 97317: 
108991:     int32_t port;
 97317:     mSocketInfo->GetPort(&port);
 97317: 
 97317:     nsString cn_host_port;
 97317:     if (ccn && strcmp(ccn, hostname) == 0) {
 97317:       cn_host_port.Append(cn);
 97317:       cn_host_port.AppendLiteral(":");
 97317:       cn_host_port.AppendInt(port);
 97317:     }
 97317:     else {
 97317:       cn_host_port.Append(cn);
 97317:       cn_host_port.AppendLiteral(" (");
 97317:       cn_host_port.AppendLiteral(":");
 97317:       cn_host_port.AppendInt(port);
 97317:       cn_host_port.AppendLiteral(")");
 97317:     }
 97317: 
 97317:     char *corg = CERT_GetOrgName(&mServerCert->subject);
 97317:     NS_ConvertUTF8toUTF16 org(corg);
 97317:     if (corg) PORT_Free(corg);
 97317: 
 97317:     char *cissuer = CERT_GetOrgName(&mServerCert->issuer);
 97317:     NS_ConvertUTF8toUTF16 issuer(cissuer);
 97317:     if (cissuer) PORT_Free(cissuer);
 97317: 
 97317:     certNicknameList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
 97317:     if (!certNicknameList)
 97317:       goto loser;
 97317:     certDetailsList = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * nicknames->numnicknames);
 97317:     if (!certDetailsList) {
 97317:       nsMemory::Free(certNicknameList);
 97317:       goto loser;
 97317:     }
 97317: 
108991:     int32_t CertsToUse;
 97317:     for (CertsToUse = 0, node = CERT_LIST_HEAD(certList);
 97317:          !CERT_LIST_END(node, certList) && CertsToUse < nicknames->numnicknames;
 97317:          node = CERT_LIST_NEXT(node)
 97317:         )
 97317:     {
119832:       nsRefPtr<nsNSSCertificate> tempCert = nsNSSCertificate::Create(node->cert);
 97317: 
 97317:       if (!tempCert)
 97317:         continue;
 97317:       
 97317:       NS_ConvertUTF8toUTF16 i_nickname(nicknames->nicknames[CertsToUse]);
 97317:       nsAutoString nickWithSerial, details;
 97317:       
 97317:       if (NS_FAILED(tempCert->FormatUIStrings(i_nickname, nickWithSerial, details)))
 97317:         continue;
 97317: 
 97317:       certNicknameList[CertsToUse] = ToNewUnicode(nickWithSerial);
 97317:       if (!certNicknameList[CertsToUse])
 97317:         continue;
 97317:       certDetailsList[CertsToUse] = ToNewUnicode(details);
 97317:       if (!certDetailsList[CertsToUse]) {
 97317:         nsMemory::Free(certNicknameList[CertsToUse]);
 97317:         continue;
 97317:       }
 97317: 
 97317:       ++CertsToUse;
 97317:     }
 97317: 
 97317:     /* Throw up the client auth dialog and get back the index of the selected cert */
 97317:     rv = getNSSDialogs((void**)&dialogs, 
 97317:                        NS_GET_IID(nsIClientAuthDialogs),
 97317:                        NS_CLIENTAUTHDIALOGS_CONTRACTID);
 97317: 
 97317:     if (NS_FAILED(rv)) {
 97317:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
 97317:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
 97317:       goto loser;
 97317:     }
 97317: 
 97317:     {
 97317:       nsPSMUITracker tracker;
 97317:       if (tracker.isUIForbidden()) {
 97317:         rv = NS_ERROR_NOT_AVAILABLE;
 97317:       }
 97317:       else {
 97317:         rv = dialogs->ChooseCertificate(mSocketInfo, cn_host_port.get(),
 97317:                                         org.get(), issuer.get(), 
 97317:                                         (const PRUnichar**)certNicknameList,
 97317:                                         (const PRUnichar**)certDetailsList,
 97317:                                         CertsToUse, &selectedIndex, &canceled);
 97317:       }
 97317:     }
 97317: 
 97317:     NS_RELEASE(dialogs);
 97317:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certNicknameList);
 97317:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(CertsToUse, certDetailsList);
 97317:     
 97317:     if (NS_FAILED(rv)) goto loser;
 97317: 
 97317:     // even if the user has canceled, we want to remember that, to avoid repeating prompts
 97317:     bool wantRemember = false;
 97317:     mSocketInfo->GetRememberClientAuthCertificate(&wantRemember);
 97317: 
 97317:     int i;
 97317:     if (!canceled)
 97317:     for (i = 0, node = CERT_LIST_HEAD(certList);
 97317:          !CERT_LIST_END(node, certList);
 97317:          ++i, node = CERT_LIST_NEXT(node)) {
 97317: 
 97317:       if (i == selectedIndex) {
 97317:         cert = CERT_DupCertificate(node->cert);
 97317:         break;
 97317:       }
 97317:     }
 97317: 
 97317:     if (cars && wantRemember) {
 97317:       cars->RememberDecision(hostname, mServerCert, canceled ? 0 : cert);
 97317:     }
 97317: }
 97317: 
 97317:     if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
 97317: 
119832:     if (cert == NULL) {
 97317:       goto loser;
 97317:     }
 97317: 
 97317:     /* go get the private key */
 97317:     privKey = PK11_FindKeyByAnyCert(cert, wincx);
119832:     if (privKey == NULL) {
 97317:       keyError = PR_GetError();
 97317:       if (keyError == SEC_ERROR_BAD_PASSWORD) {
 97317:           /* problem with password: bail */
 97317:           goto loser;
 97317:       }
 97317:       else {
 97317:           goto noCert;
 97317:       }
 97317:     }
 97317:   }
 97317:   goto done;
 97317: 
 97317: noCert:
 97317: loser:
 97317:   if (mRV == SECSuccess) {
 97317:     mRV = SECFailure;
 97317:   }
119832:   if (cert != NULL) {
 97317:     CERT_DestroyCertificate(cert);
119832:     cert = NULL;
 97317:   }
 97317: done:
 97317:   int error = PR_GetError();
 97317: 
119832:   if (extracted != NULL) {
 97317:     PR_Free(extracted);
 97317:   }
119832:   if (nicknames != NULL) {
 97317:     CERT_FreeNicknames(nicknames);
 97317:   }
119832:   if (certList != NULL) {
 97317:     CERT_DestroyCertList(certList);
 97317:   }
119832:   if (arena != NULL) {
 97317:     PORT_FreeArena(arena, false);
 97317:   }
 97317: 
 97317:   *mPRetCert = cert;
 97317:   *mPRetKey = privKey;
 97317: 
 97317:   if (mRV == SECFailure) {
 97317:     mErrorCodeToReport = error;
 97317:   }
 97317: }
 97317: 
 97317: static PRFileDesc*
 97317: nsSSLIOLayerImportFD(PRFileDesc *fd,
 97317:                      nsNSSSocketInfo *infoObject,
 97317:                      const char *host,
 97317:                      bool anonymousLoad)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
106838:   PRFileDesc* sslSock = SSL_ImportFD(nullptr, fd);
 97317:   if (!sslSock) {
 97317:     NS_ASSERTION(false, "NSS: Error importing socket");
106838:     return nullptr;
 97317:   }
 97317:   SSL_SetPKCS11PinArg(sslSock, (nsIInterfaceRequestor*)infoObject);
 97317:   SSL_HandshakeCallback(sslSock, HandshakeCallback, infoObject);
 97317: 
 97317:   // Disable this hook if we connect anonymously. See bug 466080.
 97317:   if (anonymousLoad) {
119832:       SSL_GetClientAuthDataHook(sslSock, NULL, infoObject);
 97317:   } else {
 97317:       SSL_GetClientAuthDataHook(sslSock, 
 97317:                             (SSLGetClientAuthData)nsNSS_SSLGetClientAuthData,
 97317:                             infoObject);
 97317:   }
 97317:   if (SECSuccess != SSL_AuthCertificateHook(sslSock, AuthCertificateHook,
 97317:                                             infoObject)) {
 97317:     NS_NOTREACHED("failed to configure AuthCertificateHook");
 97317:     goto loser;
 97317:   }
 97317: 
 97317:   if (SECSuccess != SSL_SetURL(sslSock, host)) {
 97317:     NS_NOTREACHED("SSL_SetURL failed");
 97317:     goto loser;
 97317:   }
 97317:   return sslSock;
 97317: loser:
 97317:   if (sslSock) {
 97317:     PR_Close(sslSock);
 97317:   }
106838:   return nullptr;
 97317: }
 97317: 
 97317: static nsresult
 97317: nsSSLIOLayerSetOptions(PRFileDesc *fd, bool forSTARTTLS, 
108991:                        const char *proxyHost, const char *host, int32_t port,
 97317:                        bool anonymousLoad, nsNSSSocketInfo *infoObject)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
 97317:   if (forSTARTTLS || proxyHost) {
 97317:     if (SECSuccess != SSL_OptionSet(fd, SSL_SECURITY, false)) {
 97317:       return NS_ERROR_FAILURE;
 97317:     }
 97317:     infoObject->SetHasCleartextPhase(true);
 97317:   }
 97317: 
 97317:   // Let's see if we're trying to connect to a site we know is
 97317:   // TLS intolerant.
110974:   nsAutoCString key;
 97317:   key = nsDependentCString(host) + NS_LITERAL_CSTRING(":") + nsPrintfCString("%d", port);
 97317: 
 97317:   if (nsSSLIOLayerHelpers::isKnownAsIntolerantSite(key)) {
 97317:     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_TLS, false))
 97317:       return NS_ERROR_FAILURE;
 97317: 
 97317:     infoObject->SetAllowTLSIntoleranceTimeout(false);
 97317:       
 97317:     // We assume that protocols that use the STARTTLS mechanism should support
 97317:     // modern hellos. For other protocols, if we suspect a site 
 97317:     // does not support TLS, let's also use V2 hellos.
 97317:     // One advantage of this approach, if a site only supports the older
 97317:     // hellos, it is more likely that we will get a reasonable error code
 97317:     // on our single retry attempt.
 97317:   }
 97317: 
 97317:   PRBool enabled;
 97317:   if (SECSuccess != SSL_OptionGet(fd, SSL_ENABLE_SSL3, &enabled)) {
 97317:     return NS_ERROR_FAILURE;
 97317:   }
 97317:   infoObject->SetSSL3Enabled(enabled);
 97317:   if (SECSuccess != SSL_OptionGet(fd, SSL_ENABLE_TLS, &enabled)) {
 97317:     return NS_ERROR_FAILURE;
 97317:   }
 97317:   infoObject->SetTLSEnabled(enabled);
 97317: 
 97317:   if (SECSuccess != SSL_OptionSet(fd, SSL_HANDSHAKE_AS_CLIENT, true)) {
 97317:     return NS_ERROR_FAILURE;
 97317:   }
 97317:   
 97317:   if (nsSSLIOLayerHelpers::isRenegoUnrestrictedSite(nsDependentCString(host))) {
 97317:     if (SECSuccess != SSL_OptionSet(fd, SSL_REQUIRE_SAFE_NEGOTIATION, false)) {
 97317:       return NS_ERROR_FAILURE;
 97317:     }
 97317:     if (SECSuccess != SSL_OptionSet(fd, SSL_ENABLE_RENEGOTIATION, SSL_RENEGOTIATE_UNRESTRICTED)) {
 97317:       return NS_ERROR_FAILURE;
 97317:     }
 97317:   }
 97317: 
 97317:   // Set the Peer ID so that SSL proxy connections work properly.
 97317:   char *peerId;
 97317:   if (anonymousLoad) {  // See bug #466080. Separate the caches.
 97317:       peerId = PR_smprintf("anon:%s:%d", host, port);
 97317:   } else {
 97317:       peerId = PR_smprintf("%s:%d", host, port);
 97317:   }
 97317:   
 97317:   if (SECSuccess != SSL_SetSockPeerID(fd, peerId)) {
 97317:     PR_smprintf_free(peerId);
 97317:     return NS_ERROR_FAILURE;
 97317:   }
 97317: 
 97317:   PR_smprintf_free(peerId);
 97317:   return NS_OK;
 97317: }
 97317: 
 97317: nsresult
108991: nsSSLIOLayerAddToSocket(int32_t family,
 97317:                         const char* host,
108991:                         int32_t port,
 97317:                         const char* proxyHost,
108991:                         int32_t proxyPort,
 97317:                         PRFileDesc* fd,
 97317:                         nsISupports** info,
 97317:                         bool forSTARTTLS,
 97317:                         bool anonymousLoad)
 97317: {
 97317:   nsNSSShutDownPreventionLock locker;
106838:   PRFileDesc* layer = nullptr;
 97317:   nsresult rv;
106854:   PRStatus stat;
 97317: 
 97317:   nsNSSSocketInfo* infoObject = new nsNSSSocketInfo();
 97317:   if (!infoObject) return NS_ERROR_FAILURE;
 97317:   
 97317:   NS_ADDREF(infoObject);
 97317:   infoObject->SetForSTARTTLS(forSTARTTLS);
 97317:   infoObject->SetHostName(host);
 97317:   infoObject->SetPort(port);
 97317: 
 97317:   PRFileDesc *sslSock = nsSSLIOLayerImportFD(fd, infoObject, host, anonymousLoad);
 97317:   if (!sslSock) {
 97317:     NS_ASSERTION(false, "NSS: Error importing socket");
 97317:     goto loser;
 97317:   }
 97317: 
 97317:   infoObject->SetFileDescPtr(sslSock);
 97317: 
 97317:   rv = nsSSLIOLayerSetOptions(sslSock,
 97317:                               forSTARTTLS, proxyHost, host, port, anonymousLoad,
 97317:                               infoObject);
 97317: 
 97317:   if (NS_FAILED(rv))
 97317:     goto loser;
 97317: 
 97317:   /* Now, layer ourselves on top of the SSL socket... */
 97317:   layer = PR_CreateIOLayerStub(nsSSLIOLayerHelpers::nsSSLIOLayerIdentity,
 97317:                                &nsSSLIOLayerHelpers::nsSSLIOLayerMethods);
 97317:   if (!layer)
 97317:     goto loser;
 97317:   
 97317:   layer->secret = (PRFilePrivate*) infoObject;
106854:   stat = PR_PushIOLayer(sslSock, PR_GetLayersIdentity(sslSock), layer);
 97317:   
106854:   if (stat == PR_FAILURE) {
 97317:     goto loser;
 97317:   }
 97317:   
 97317:   nsNSSShutDownList::trackSSLSocketCreate();
 97317: 
 97317:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("[%p] Socket set up\n", (void*)sslSock));
 97317:   infoObject->QueryInterface(NS_GET_IID(nsISupports), (void**) (info));
 97317: 
 97317:   // We are going use a clear connection first //
 97317:   if (forSTARTTLS || proxyHost) {
 97317:     infoObject->SetHandshakePending(false);
 97317:   }
 97317: 
 97317:   return NS_OK;
 97317:  loser:
 97317:   NS_IF_RELEASE(infoObject);
 97317:   if (layer) {
 97317:     layer->dtor(layer);
 97317:   }
 97317:   return NS_ERROR_FAILURE;
 97317: }
