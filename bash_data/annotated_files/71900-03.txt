42410: /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
42410: /* ***** BEGIN LICENSE BLOCK *****
42410:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42410:  *
42410:  * The contents of this file are subject to the Mozilla Public License Version
42410:  * 1.1 (the "License"); you may not use this file except in compliance with
42410:  * the License. You may obtain a copy of the License at
42410:  * http://www.mozilla.org/MPL/
42410:  *
42410:  * Software distributed under the License is distributed on an "AS IS" basis,
42410:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42410:  * for the specific language governing rights and limitations under the
42410:  * License.
42410:  *
42410:  * The Original Code is mozilla.org code.
42410:  *
42410:  * The Initial Developer of the Original Code is
42410:  * Mozilla Corporation
42410:  * Portions created by the Initial Developer are Copyright (C) 2010
42410:  * the Initial Developer. All Rights Reserved.
42410:  *
42410:  * Contributor(s):
42410:  *
42410:  * Alternatively, the contents of this file may be used under the terms of
42410:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42410:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42410:  * in which case the provisions of the GPL or the LGPL are applicable instead
42410:  * of those above. If you wish to allow use of your version of this file only
42410:  * under the terms of either the GPL or the LGPL, and not to allow others to
42410:  * use your version of this file under the terms of the MPL, indicate your
42410:  * decision by deleting the provisions above and replace them with the notice
42410:  * and other provisions required by the GPL or the LGPL. If you do not delete
42410:  * the provisions above, a recipient may use your version of this file under
42410:  * the terms of any one of the MPL, the GPL or the LGPL.
42410:  *
42410:  * ***** END LICENSE BLOCK ***** */
42410: #ifndef nsFrameMessageManager_h__
42410: #define nsFrameMessageManager_h__
42410: 
42410: #include "nsIFrameMessageManager.h"
50684: #include "nsIObserver.h"
42410: #include "nsCOMPtr.h"
42410: #include "nsAutoPtr.h"
42410: #include "nsCOMArray.h"
42410: #include "nsTArray.h"
42410: #include "nsIAtom.h"
42410: #include "nsCycleCollectionParticipant.h"
42410: #include "nsTArray.h"
49304: #include "nsIPrincipal.h"
49304: #include "nsIXPConnect.h"
49304: #include "nsDataHashtable.h"
50684: #include "mozilla/Services.h"
50684: #include "nsIObserverService.h"
42410: 
42410: class nsAXPCNativeCallContext;
42410: struct JSContext;
42410: struct JSObject;
42410: 
42410: struct nsMessageListenerInfo
42410: {
42410:   nsCOMPtr<nsIFrameMessageListener> mListener;
42410:   nsCOMPtr<nsIAtom> mMessage;
42410: };
42410: 
42410: typedef bool (*nsLoadScriptCallback)(void* aCallbackData, const nsAString& aURL);
42410: typedef bool (*nsSyncMessageCallback)(void* aCallbackData,
42410:                                       const nsAString& aMessage,
42410:                                       const nsAString& aJSON,
57141:                                       InfallibleTArray<nsString>* aJSONRetVal);
42410: typedef bool (*nsAsyncMessageCallback)(void* aCallbackData,
42410:                                        const nsAString& aMessage,
42410:                                        const nsAString& aJSON);
42410: 
42410: class nsFrameMessageManager : public nsIContentFrameMessageManager,
42410:                               public nsIChromeFrameMessageManager
42410: {
42410: public:
42410:   nsFrameMessageManager(PRBool aChrome,
42410:                         nsSyncMessageCallback aSyncCallback,
42410:                         nsAsyncMessageCallback aAsyncCallback,
42410:                         nsLoadScriptCallback aLoadScriptCallback,
42410:                         void* aCallbackData,
42410:                         nsFrameMessageManager* aParentManager,
43461:                         JSContext* aContext,
51811:                         PRBool aGlobal = PR_FALSE,
51811:                         PRBool aProcessManager = PR_FALSE)
51811:   : mChrome(aChrome), mGlobal(aGlobal), mIsProcessManager(aProcessManager),
51811:     mParentManager(aParentManager),
42410:     mSyncCallback(aSyncCallback), mAsyncCallback(aAsyncCallback),
42410:     mLoadScriptCallback(aLoadScriptCallback), mCallbackData(aCallbackData),
42410:     mContext(aContext)
42410:   {
51811:     NS_ASSERTION(mContext || (aChrome && !aParentManager) || aProcessManager,
51811:                  "Should have mContext in non-global/non-process manager!");
42410:     NS_ASSERTION(aChrome || !aParentManager, "Should not set parent manager!");
43461:     // This is a bit hackish. When parent manager is global, we want
43461:     // to attach the window message manager to it immediately.
43461:     // Is it just the frame message manager which waits until the
43461:     // content process is running.
43461:     if (mParentManager && (mCallbackData || IsWindowLevel())) {
42410:       mParentManager->AddChildManager(this);
42410:     }
42410:   }
42410: 
42410:   ~nsFrameMessageManager()
42410:   {
42410:     for (PRInt32 i = mChildManagers.Count(); i > 0; --i) {
42410:       static_cast<nsFrameMessageManager*>(mChildManagers[i - 1])->
42410:         Disconnect(PR_FALSE);
42410:     }
51811:     if (mIsProcessManager) {
51811:       if (this == sParentProcessManager) {
51811:         sParentProcessManager = nsnull;
51811:       }
51811:       if (this == sChildProcessManager) {
51811:         sChildProcessManager = nsnull;
51811:       }
51811:     }
42410:   }
42410: 
42410:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
42410:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsFrameMessageManager,
42410:                                            nsIContentFrameMessageManager)
42410:   NS_DECL_NSIFRAMEMESSAGEMANAGER
51811:   NS_DECL_NSISYNCMESSAGESENDER
42410:   NS_DECL_NSICONTENTFRAMEMESSAGEMANAGER
42410:   NS_DECL_NSICHROMEFRAMEMESSAGEMANAGER
42410: 
42410:   nsresult ReceiveMessage(nsISupports* aTarget, const nsAString& aMessage,
42410:                           PRBool aSync, const nsAString& aJSON,
42410:                           JSObject* aObjectsArray,
57141:                           InfallibleTArray<nsString>* aJSONRetVal,
43461:                           JSContext* aContext = nsnull);
42410:   void AddChildManager(nsFrameMessageManager* aManager,
42410:                        PRBool aLoadScripts = PR_TRUE);
42410:   void RemoveChildManager(nsFrameMessageManager* aManager)
42410:   {
42410:     mChildManagers.RemoveObject(aManager);
42410:   }
42410: 
42410:   void Disconnect(PRBool aRemoveFromParent = PR_TRUE);
42410:   void SetCallbackData(void* aData, PRBool aLoadScripts = PR_TRUE);
42410:   nsresult GetParamsForMessage(nsAString& aMessageName, nsAString& aJSON);
42410:   nsresult SendAsyncMessageInternal(const nsAString& aMessage,
42410:                                     const nsAString& aJSON);
42410:   JSContext* GetJSContext() { return mContext; }
42410:   nsFrameMessageManager* GetParentManager() { return mParentManager; }
42410:   void SetParentManager(nsFrameMessageManager* aParent)
42410:   {
42410:     NS_ASSERTION(!mParentManager, "We have parent manager already!");
42410:     NS_ASSERTION(mChrome, "Should not set parent manager!");
42410:     mParentManager = aParent;
42410:   }
43461:   PRBool IsGlobal() { return mGlobal; }
43461:   PRBool IsWindowLevel() { return mParentManager && mParentManager->IsGlobal(); }
51811: 
51811:   static nsFrameMessageManager* GetParentProcessManager()
51811:   {
51811:     return sParentProcessManager;
51811:   }
51811:   static nsFrameMessageManager* GetChildProcessManager()
51811:   {
51811:     return sChildProcessManager;
51811:   }
42410: protected:
42410:   nsTArray<nsMessageListenerInfo> mListeners;
42410:   nsCOMArray<nsIContentFrameMessageManager> mChildManagers;
43461:   PRPackedBool mChrome;
43461:   PRPackedBool mGlobal;
51811:   PRPackedBool mIsProcessManager;
42410:   nsFrameMessageManager* mParentManager;
42410:   nsSyncMessageCallback mSyncCallback;
42410:   nsAsyncMessageCallback mAsyncCallback;
42410:   nsLoadScriptCallback mLoadScriptCallback;
42410:   void* mCallbackData;
42410:   JSContext* mContext;
42410:   nsTArray<nsString> mPendingScripts;
51811: public:
51811:   static nsFrameMessageManager* sParentProcessManager;
51811:   static nsFrameMessageManager* sChildProcessManager;
42410: };
42410: 
69796: void
69796: ContentScriptErrorReporter(JSContext* aCx,
69796:                            const char* aMessage,
69796:                            JSErrorReport* aReport);
69796: 
50684: class nsScriptCacheCleaner;
50684: 
49304: struct nsFrameScriptExecutorJSObjectHolder
49304: {
61117:   nsFrameScriptExecutorJSObjectHolder(JSObject* aObject) : mObject(aObject)
61117:   { MOZ_COUNT_CTOR(nsFrameScriptExecutorJSObjectHolder); }
61117:   ~nsFrameScriptExecutorJSObjectHolder()
61117:   { MOZ_COUNT_DTOR(nsFrameScriptExecutorJSObjectHolder); }
49304:   JSObject* mObject;
49304: };
49304: 
49304: class nsFrameScriptExecutor
49304: {
49304: public:
49304:   static void Shutdown();
49304: protected:
71900:   friend class nsFrameScriptCx;
71900:   nsFrameScriptExecutor() : mCx(nsnull), mCxStackRefCnt(0),
71900:                             mDelayedCxDestroy(PR_FALSE)
61117:   { MOZ_COUNT_CTOR(nsFrameScriptExecutor); }
61117:   ~nsFrameScriptExecutor()
61117:   { MOZ_COUNT_DTOR(nsFrameScriptExecutor); }
49304:   void DidCreateCx();
49304:   // Call this when you want to destroy mCx.
49304:   void DestroyCx();
49304:   void LoadFrameScriptInternal(const nsAString& aURL);
61808:   static void Traverse(nsFrameScriptExecutor *tmp,
61808:                        nsCycleCollectionTraversalCallback &cb);
49304:   nsCOMPtr<nsIXPConnectJSObjectHolder> mGlobal;
49304:   JSContext* mCx;
71900:   PRUint32 mCxStackRefCnt;
71900:   PRPackedBool mDelayedCxDestroy;
49304:   nsCOMPtr<nsIPrincipal> mPrincipal;
49304:   static nsDataHashtable<nsStringHashKey, nsFrameScriptExecutorJSObjectHolder*>* sCachedScripts;
50684:   static nsRefPtr<nsScriptCacheCleaner> sScriptCacheCleaner;
50684: };
50684: 
71900: class nsFrameScriptCx
71900: {
71900: public:
71900:   nsFrameScriptCx(nsISupports* aOwner, nsFrameScriptExecutor* aExec)
71900:   : mOwner(aOwner), mExec(aExec)
71900:   {
71900:     ++(mExec->mCxStackRefCnt);
71900:   }
71900:   ~nsFrameScriptCx()
71900:   {
71900:     if (--(mExec->mCxStackRefCnt) == 0 &&
71900:         mExec->mDelayedCxDestroy) {
71900:       mExec->DestroyCx();
71900:     }
71900:   }
71900:   nsCOMPtr<nsISupports> mOwner;
71900:   nsFrameScriptExecutor* mExec;
71900: };
71900: 
50684: class nsScriptCacheCleaner : public nsIObserver
50684: {
50684:   NS_DECL_ISUPPORTS
50684: 
50684:   nsScriptCacheCleaner()
50684:   {
50684:     nsCOMPtr<nsIObserverService> obsSvc = mozilla::services::GetObserverService();
50684:     if (obsSvc)
50684:       obsSvc->AddObserver(this, "xpcom-shutdown", PR_FALSE);
50684:   }
50684: 
50684:   NS_IMETHODIMP Observe(nsISupports *aSubject,
50684:                         const char *aTopic,
50684:                         const PRUnichar *aData)
50684:   {
50684:     nsFrameScriptExecutor::Shutdown();
50684:     return NS_OK;
50684:   }
49304: };
49304: 
42410: #endif
