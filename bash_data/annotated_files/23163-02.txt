    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
16226:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* a presentation of a document, part 1 */
    1: 
    1: #ifndef nsPresContext_h___
    1: #define nsPresContext_h___
    1: 
    1: #include "nsISupports.h"
    1: #include "nsColor.h"
    1: #include "nsCoord.h"
    1: #include "nsAString.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIPresShell.h"
    1: #include "nsRect.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsFont.h"
    1: #include "nsIWeakReference.h"
    1: #include "nsITheme.h"
    1: #include "nsILanguageAtomService.h"
    1: #include "nsIObserver.h"
    1: #include "nsITimer.h"
    1: #include "nsCRT.h"
    1: #include "nsIPrintSettings.h"
    1: #include "nsPropertyTable.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDocument.h"
21023: #include "nsInterfaceHashtable.h"
 4484: #include "nsCycleCollectionParticipant.h"
11409: #include "nsChangeHint.h"
15687: // This also pulls in gfxTypes.h, which we cannot include directly.
15687: #include "gfxRect.h"
19380: #include "nsRegion.h"
21925: #include "nsTArray.h"
21925: #include "nsAutoPtr.h"
19962: 
    1: class nsImageLoader;
    1: #ifdef IBMBIDI
    1: class nsBidiPresUtils;
    1: #endif // IBMBIDI
    1: 
    1: struct nsRect;
    1: 
    1: class imgIRequest;
    1: 
    1: class nsIContent;
    1: class nsIFontMetrics;
    1: class nsIFrame;
    1: class nsFrameManager;
    1: class nsIImage;
    1: class nsILinkHandler;
    1: class nsStyleContext;
    1: class nsIAtom;
    1: class nsIEventStateManager;
    1: class nsIURI;
    1: class nsILookAndFeel;
    1: class nsICSSPseudoComparator;
    1: class nsIAtom;
    1: struct nsStyleBackground;
    1: template <class T> class nsRunnableMethod;
    1: class nsIRunnable;
19962: class gfxUserFontSet;
21983: struct nsFontFaceRuleContainer;
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1: class nsIRenderingContext;
    1: #endif
    1: 
    1: enum nsWidgetType {
    1:   eWidgetType_Button  	= 1,
    1:   eWidgetType_Checkbox	= 2,
    1:   eWidgetType_Radio			= 3,
    1:   eWidgetType_Text			= 4
    1: };
    1: 
    1: enum nsLanguageSpecificTransformType {
    1:   eLanguageSpecificTransformType_Unknown = -1,
    1:   eLanguageSpecificTransformType_None = 0,
    1:   eLanguageSpecificTransformType_Japanese
    1: };
    1: 
    1: // supported values for cached bool types
    1: enum nsPresContext_CachedBoolPrefType {
    1:   kPresContext_UseDocumentColors = 1,
    1:   kPresContext_UseDocumentFonts,
    1:   kPresContext_UnderlineLinks
    1: };
    1: 
    1: // supported values for cached integer pref types
    1: enum nsPresContext_CachedIntPrefType {
    1:   kPresContext_MinimumFontSize = 1,
    1:   kPresContext_ScrollbarSide,
    1:   kPresContext_BidiDirection
    1: };
    1: 
    1: // IDs for the default variable and fixed fonts (not to be changed, see nsFont.h)
    1: // To be used for Get/SetDefaultFont(). The other IDs in nsFont.h are also supported.
    1: const PRUint8 kPresContext_DefaultVariableFont_ID = 0x00; // kGenericFont_moz_variable
    1: const PRUint8 kPresContext_DefaultFixedFont_ID    = 0x01; // kGenericFont_moz_fixed
    1: 
    1: #ifdef DEBUG
    1: struct nsAutoLayoutPhase;
    1: 
    1: enum nsLayoutPhase {
    1:   eLayoutPhase_Paint,
    1:   eLayoutPhase_Reflow,
    1:   eLayoutPhase_FrameC,
    1:   eLayoutPhase_COUNT
    1: };
    1: #endif
    1: 
14697: /* Used by nsPresContext::HasAuthorSpecifiedRules */
14697: #define NS_AUTHOR_SPECIFIED_BACKGROUND      (1 << 0)
14697: #define NS_AUTHOR_SPECIFIED_BORDER          (1 << 1)
14697: #define NS_AUTHOR_SPECIFIED_PADDING         (1 << 2)
14697: 
    1: // An interface for presentation contexts. Presentation contexts are
    1: // objects that provide an outer context for a presentation shell.
    1: 
    1: class nsPresContext : public nsIObserver {
    1: public:
 4484:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1:   NS_DECL_NSIOBSERVER
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
 4484:   NS_DECL_CYCLE_COLLECTION_CLASS(nsPresContext)
    1: 
    1:   enum nsPresContextType {
    1:     eContext_Galley,       // unpaginated screen presentation
    1:     eContext_PrintPreview, // paginated screen presentation
    1:     eContext_Print,        // paginated printer presentation
    1:     eContext_PageLayout    // paginated & editable.
    1:   };
    1: 
    1:   nsPresContext(nsIDocument* aDocument, nsPresContextType aType) NS_HIDDEN;
    1: 
    1:   /**
    1:    * Initialize the presentation context from a particular device.
    1:    */
    1:   NS_HIDDEN_(nsresult) Init(nsIDeviceContext* aDeviceContext);
    1: 
    1:   /**
    1:    * Set the presentation shell that this context is bound to.
    1:    * A presentation context may only be bound to a single shell.
    1:    */
    1:   NS_HIDDEN_(void) SetShell(nsIPresShell* aShell);
    1: 
    1: 
    1:   NS_HIDDEN_(nsPresContextType) Type() const { return mType; }
    1: 
    1:   /**
    1:    * Get the PresentationShell that this context is bound to.
    1:    */
    1:   nsIPresShell* PresShell() const
    1:   {
    1:     NS_ASSERTION(mShell, "Null pres shell");
    1:     return mShell;
    1:   }
    1: 
    1:   nsIPresShell* GetPresShell() const { return mShell; }
    1: 
    1:   // Find the prescontext for the root of the view manager hierarchy that contains
    1:   // this prescontext.
    1:   nsPresContext* RootPresContext();
    1: 
    1:   nsIDocument* Document() const
    1:   {
    1:       NS_ASSERTION(!mShell || !mShell->GetDocument() ||
    1:                    mShell->GetDocument() == mDocument,
    1:                    "nsPresContext doesn't have the same document as nsPresShell!");
    1:       return mDocument;
    1:   }
    1: 
    1:   nsIViewManager* GetViewManager() { return GetPresShell()->GetViewManager(); } 
    1: #ifdef _IMPL_NS_LAYOUT
    1:   nsStyleSet* StyleSet() { return GetPresShell()->StyleSet(); }
    1: 
    1:   nsFrameManager* FrameManager()
    1:     { return GetPresShell()->FrameManager(); } 
    1: #endif
    1: 
22339:   /**
22339:    * Rebuilds all style data by throwing out the old rule tree and
22339:    * building a new one, and additionally applying aExtraHint (which
22339:    * must not contain nsChangeHint_ReconstructFrame) to the root frame.
22339:    * Also rebuild the user font set.
22339:    */
11409:   void RebuildAllStyleData(nsChangeHint aExtraHint);
22339:   /**
22339:    * Just like RebuildAllStyleData, except (1) asynchronous and (2) it
22339:    * doesn't rebuild the user font set.
22339:    */
22339:   void PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint);
10073: 
16226:   void MediaFeatureValuesChanged(PRBool aCallerWillRebuildStyleData);
16226:   void PostMediaFeatureValuesChangedEvent();
16226:   NS_HIDDEN_(void) HandleMediaFeatureValuesChangedEvent();
16226:   void FlushPendingMediaFeatureValuesChanged() {
16226:     if (mPendingMediaFeatureValuesChanged)
16226:       MediaFeatureValuesChanged(PR_FALSE);
16226:   }
16226: 
    1:   /**
    1:    * Access compatibility mode for this context.  This is the same as
    1:    * our document's compatibility mode.
    1:    */
    1:   nsCompatibility CompatibilityMode() const {
    1:     return Document()->GetCompatibilityMode();
    1:   }
    1:   /**
    1:    * Notify the context that the document's compatibility mode has changed
    1:    */
    1:   NS_HIDDEN_(void) CompatibilityModeChanged();
    1: 
    1:   /**
    1:    * Access the image animation mode for this context
    1:    */
    1:   PRUint16     ImageAnimationMode() const { return mImageAnimationMode; }
12990:   void RestoreImageAnimationMode() { SetImageAnimationMode(mImageAnimationModePref); }
    1:   virtual NS_HIDDEN_(void) SetImageAnimationModeExternal(PRUint16 aMode);
    1:   NS_HIDDEN_(void) SetImageAnimationModeInternal(PRUint16 aMode);
    1: #ifdef _IMPL_NS_LAYOUT
    1:   void SetImageAnimationMode(PRUint16 aMode)
    1:   { SetImageAnimationModeInternal(aMode); }
    1: #else
    1:   void SetImageAnimationMode(PRUint16 aMode)
    1:   { SetImageAnimationModeExternal(aMode); }
    1: #endif
    1: 
    1:   /**
    1:    * Get cached look and feel service.  This is faster than obtaining it
    1:    * through the service manager.
    1:    */
    1:   nsILookAndFeel* LookAndFeel() { return mLookAndFeel; }
    1: 
    1:   /** 
    1:    * Get medium of presentation
    1:    */
    1:   nsIAtom* Medium() { return mMedium; }
    1: 
    1:   void* AllocateFromShell(size_t aSize)
    1:   {
    1:     if (mShell)
    1:       return mShell->AllocateFrame(aSize);
    1:     return nsnull;
    1:   }
    1: 
    1:   void FreeToShell(size_t aSize, void* aFreeChunk)
    1:   {
    1:     if (mShell)
    1:       mShell->FreeFrame(aSize, aFreeChunk);
    1:   }
    1: 
    1:   /**
    1:    * Get the font metrics for a given font.
    1:    */
    1:   NS_HIDDEN_(already_AddRefed<nsIFontMetrics>)
20218:   GetMetricsFor(const nsFont& aFont);
    1: 
    1:   /**
    1:    * Get the default font corresponding to the given ID.  This object is
    1:    * read-only, you must copy the font to modify it.
 3987:    * 
 3987:    * When aFontID is kPresContext_DefaultVariableFontID or
 3987:    * kPresContext_DefaultFixedFontID (which equals
 3987:    * kGenericFont_moz_fixed, which is used for the -moz-fixed generic),
 3987:    * the nsFont returned has its name as a CSS generic family (serif or
 3987:    * sans-serif for the former, monospace for the latter), and its size
 3987:    * as the default font size for variable or fixed fonts for the pres
 3987:    * context's language group.
 3987:    *
 3987:    * For aFontID corresponds to a CSS Generic, the nsFont returned has
 3987:    * its name as the name or names of the fonts in the user's
 3987:    * preferences for the given generic and the pres context's language
 3987:    * group, and its size set to the default variable font size.
    1:    */
20218:   NS_HIDDEN_(const nsFont*) GetDefaultFont(PRUint8 aFontID) const;
    1: 
    1:   /** Get a cached boolean pref, by its type */
    1:   // *  - initially created for bugs 31816, 20760, 22963
    1:   PRBool GetCachedBoolPref(nsPresContext_CachedBoolPrefType aPrefType) const
    1:   {
    1:     // If called with a constant parameter, the compiler should optimize
    1:     // this switch statement away.
    1:     switch (aPrefType) {
    1:     case kPresContext_UseDocumentFonts:
    1:       return mUseDocumentFonts;
    1:     case kPresContext_UseDocumentColors:
    1:       return mUseDocumentColors;
    1:     case kPresContext_UnderlineLinks:
    1:       return mUnderlineLinks;
    1:     default:
    1:       NS_ERROR("Invalid arg passed to GetCachedBoolPref");
    1:     }
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   /** Get a cached integer pref, by its type */
    1:   // *  - initially created for bugs 30910, 61883, 74186, 84398
    1:   PRInt32 GetCachedIntPref(nsPresContext_CachedIntPrefType aPrefType) const
    1:   {
    1:     // If called with a constant parameter, the compiler should optimize
    1:     // this switch statement away.
    1:     switch (aPrefType) {
    1:     case kPresContext_MinimumFontSize:
    1:       return mMinimumFontSize;
    1:     case kPresContext_ScrollbarSide:
    1:       return mPrefScrollbarSide;
    1:     case kPresContext_BidiDirection:
    1:       return mPrefBidiDirection;
    1:     default:
    1:       NS_ERROR("invalid arg passed to GetCachedIntPref");
    1:     }
    1: 
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   /**
    1:    * Access Nav's magic font scaler value
    1:    */
    1:   PRInt32 FontScaler() const { return mFontScaler; }
    1: 
    1:   /** 
    1:    * Get the default colors
    1:    */
    1:   const nscolor DefaultColor() const { return mDefaultColor; }
    1:   const nscolor DefaultBackgroundColor() const { return mBackgroundColor; }
    1:   const nscolor DefaultLinkColor() const { return mLinkColor; }
    1:   const nscolor DefaultActiveLinkColor() const { return mActiveLinkColor; }
    1:   const nscolor DefaultVisitedLinkColor() const { return mVisitedLinkColor; }
    1:   const nscolor FocusBackgroundColor() const { return mFocusBackgroundColor; }
    1:   const nscolor FocusTextColor() const { return mFocusTextColor; }
    1: 
    1:   PRBool GetUseFocusColors() const { return mUseFocusColors; }
    1:   PRUint8 FocusRingWidth() const { return mFocusRingWidth; }
    1:   PRBool GetFocusRingOnAnything() const { return mFocusRingOnAnything; }
20177:   PRUint8 GetFocusRingStyle() const { return mFocusRingStyle; }
    1: 
    1: 
    1:   /**
15992:    * Set up observers so that aTargetFrame will be invalidated when
15992:    * aImage loads, where aImage is its background image.  Only a single
15992:    * image will be tracked per frame.
    1:    */
21023:   NS_HIDDEN_(imgIRequest*) LoadImage(imgIRequest* aImage,
21023:                                      nsIFrame* aTargetFrame);
21023:   /**
21023:    * Set up observers so that aTargetFrame will be invalidated or
21023:    * reflowed (as appropriate) when aImage loads, where aImage is its
21023:    * *border* image.  Only a single image will be tracked per frame.
21023:    */
21023:   NS_HIDDEN_(imgIRequest*) LoadBorderImage(imgIRequest* aImage,
21023:                                            nsIFrame* aTargetFrame);
15992: 
21023: private:
21023:   typedef nsInterfaceHashtable<nsVoidPtrHashKey, nsImageLoader> ImageLoaderTable;
21023: 
21023:   NS_HIDDEN_(imgIRequest*) DoLoadImage(ImageLoaderTable& aTable,
21023:                                        imgIRequest* aImage,
21023:                                        nsIFrame* aTargetFrame,
21023:                                        PRBool aReflowOnLoad);
21023: 
21023:   NS_HIDDEN_(void) DoStopImageFor(ImageLoaderTable& aTable,
21023:                                   nsIFrame* aTargetFrame);
21023: public:
21023: 
21023:   NS_HIDDEN_(void) StopBackgroundImageFor(nsIFrame* aTargetFrame)
21023:   { DoStopImageFor(mImageLoaders, aTargetFrame); }
21023:   NS_HIDDEN_(void) StopBorderImageFor(nsIFrame* aTargetFrame)
21023:   { DoStopImageFor(mBorderImageLoaders, aTargetFrame); }
    1:   /**
    1:    * This method is called when a frame is being destroyed to
21023:    * ensure that the image load gets disassociated from the prescontext
    1:    */
    1:   NS_HIDDEN_(void) StopImagesFor(nsIFrame* aTargetFrame);
    1: 
    1:   NS_HIDDEN_(void) SetContainer(nsISupports* aContainer);
    1: 
 8088:   virtual NS_HIDDEN_(already_AddRefed<nsISupports>) GetContainerExternal() const;
 8088:   NS_HIDDEN_(already_AddRefed<nsISupports>) GetContainerInternal() const;
    1: #ifdef _IMPL_NS_LAYOUT
 8088:   already_AddRefed<nsISupports> GetContainer() const
    1:   { return GetContainerInternal(); }
    1: #else
 8088:   already_AddRefed<nsISupports> GetContainer() const
    1:   { return GetContainerExternal(); }
    1: #endif
    1: 
    1:   // XXX this are going to be replaced with set/get container
    1:   void SetLinkHandler(nsILinkHandler* aHandler) { mLinkHandler = aHandler; }
    1:   nsILinkHandler* GetLinkHandler() { return mLinkHandler; }
    1: 
    1:   /**
    1:    * Get the visible area associated with this presentation context.
22527:    * This is the size of the visible area that is used for
    1:    * presenting the document. The returned value is in the standard
    1:    * nscoord units (as scaled by the device context).
    1:    */
    1:   nsRect GetVisibleArea() { return mVisibleArea; }
    1: 
    1:   /**
    1:    * Set the currently visible area. The units for r are standard
    1:    * nscoord units (as scaled by the device context).
    1:    */
16226:   void SetVisibleArea(const nsRect& r) {
16226:     mVisibleArea = r;
23163:     if (HasCachedStyleData())
16226:       PostMediaFeatureValuesChangedEvent();
16226:   }
    1: 
    1:   /**
    1:    * Return true if this presentation context is a paginated
    1:    * context.
    1:    */
    1:   PRBool IsPaginated() const { return mPaginated; }
    1:   
    1:   PRBool GetRenderedPositionVaryingContent() const { return mRenderedPositionVaryingContent; }
    1:   void SetRenderedPositionVaryingContent() { mRenderedPositionVaryingContent = PR_TRUE; }
    1: 
    1:   /**
    1:    * Sets whether the presentation context can scroll for a paginated
    1:    * context.
    1:    */
    1:   NS_HIDDEN_(void) SetPaginatedScrolling(PRBool aResult);
    1: 
    1:   /**
    1:    * Return true if this presentation context can scroll for paginated
    1:    * context.
    1:    */
    1:   PRBool HasPaginatedScrolling() const { return mCanPaginatedScroll; }
    1: 
    1:   /**
    1:    * Get/set the size of a page
    1:    */
    1:   nsSize GetPageSize() { return mPageSize; }
    1:   void SetPageSize(nsSize aSize) { mPageSize = aSize; }
    1: 
    1:   /**
    1:    * Get/set whether this document should be treated as having real pages
    1:    * XXX This raises the obvious question of why a document that isn't a page
    1:    *     is paginated; there isn't a good reason except history
    1:    */
    1:   PRBool IsRootPaginatedDocument() { return mIsRootPaginatedDocument; }
    1:   void SetIsRootPaginatedDocument(PRBool aIsRootPaginatedDocument)
    1:     { mIsRootPaginatedDocument = aIsRootPaginatedDocument; }
    1: 
    1:   /**
    1:   * Get/set the print scaling level; used by nsPageFrame to scale up
    1:   * pages.  Set safe to call before reflow, get guaranteed to be set
    1:   * properly after reflow.
    1:   */
    1: 
    1:   float GetPageScale() { return mPageScale; }
    1:   void SetPageScale(float aScale) { mPageScale = aScale; }
    1: 
    1:   /**
    1:   * Get/set the scaling facor to use when rendering the pages for print preview.
    1:   * Only safe to get after print preview set up; safe to set anytime.
    1:   * This is a scaling factor for the display of the print preview.  It
    1:   * does not affect layout.  It only affects the size of the onscreen pages
    1:   * in print preview.
    1:   * XXX Temporary: see http://wiki.mozilla.org/Gecko:PrintPreview
    1:   */
    1:   float GetPrintPreviewScale() { return mPPScale; }
    1:   void SetPrintPreviewScale(float aScale) { mPPScale = aScale; }
    1: 
    1:   nsIDeviceContext* DeviceContext() { return mDeviceContext; }
    1:   nsIEventStateManager* EventStateManager() { return mEventManager; }
    1:   nsIAtom* GetLangGroup() { return mLangGroup; }
    1: 
    1:   float TextZoom() { return mTextZoom; }
 4003:   void SetTextZoom(float aZoom) {
    1:     mTextZoom = aZoom;
23163:     if (HasCachedStyleData())
11409:       RebuildAllStyleData(NS_STYLE_HINT_REFLOW);
    1:   }
 4003: 
 4359:   float GetFullZoom() { return mFullZoom; }
 4003:   void SetFullZoom(float aZoom);
    1: 
 4032:   nscoord GetAutoQualityMinFontSize() {
 4032:     return DevPixelsToAppUnits(mAutoQualityMinFontSizePixelsPref);
 4032:   }
 4032:   
    1:   static PRInt32 AppUnitsPerCSSPixel() { return nsIDeviceContext::AppUnitsPerCSSPixel(); }
    1:   PRInt32 AppUnitsPerDevPixel() const  { return mDeviceContext->AppUnitsPerDevPixel(); }
    1:   PRInt32 AppUnitsPerInch() const      { return mDeviceContext->AppUnitsPerInch(); }
    1: 
    1:   static nscoord CSSPixelsToAppUnits(PRInt32 aPixels)
    1:   { return NSIntPixelsToAppUnits(aPixels,
    1:                                  nsIDeviceContext::AppUnitsPerCSSPixel()); }
    1: 
    1:   static nscoord CSSPixelsToAppUnits(float aPixels)
    1:   { return NSFloatPixelsToAppUnits(aPixels,
20559:              float(nsIDeviceContext::AppUnitsPerCSSPixel())); }
    1: 
    1:   static PRInt32 AppUnitsToIntCSSPixels(nscoord aAppUnits)
    1:   { return NSAppUnitsToIntPixels(aAppUnits,
20559:              float(nsIDeviceContext::AppUnitsPerCSSPixel())); }
    1: 
    1:   static float AppUnitsToFloatCSSPixels(nscoord aAppUnits)
    1:   { return NSAppUnitsToFloatPixels(aAppUnits,
20559:              float(nsIDeviceContext::AppUnitsPerCSSPixel())); }
    1: 
    1:   nscoord DevPixelsToAppUnits(PRInt32 aPixels) const
    1:   { return NSIntPixelsToAppUnits(aPixels,
    1:                                  mDeviceContext->AppUnitsPerDevPixel()); }
    1: 
    1:   PRInt32 AppUnitsToDevPixels(nscoord aAppUnits) const
    1:   { return NSAppUnitsToIntPixels(aAppUnits,
20559:              float(mDeviceContext->AppUnitsPerDevPixel())); }
    1: 
11780:   // If there is a remainder, it is rounded to nearest app units.
11780:   nscoord GfxUnitsToAppUnits(gfxFloat aGfxUnits) const
11780:   { return mDeviceContext->GfxUnitsToAppUnits(aGfxUnits); }
11780: 
 5147:   gfxFloat AppUnitsToGfxUnits(nscoord aAppUnits) const
 5147:   { return mDeviceContext->AppUnitsToGfxUnits(aAppUnits); }
 5147: 
15687:   gfxRect AppUnitsToGfxUnits(const nsRect& aAppRect) const
15687:   { return gfxRect(AppUnitsToGfxUnits(aAppRect.x),
15687:                    AppUnitsToGfxUnits(aAppRect.y),
15687:                    AppUnitsToGfxUnits(aAppRect.width),
15687:                    AppUnitsToGfxUnits(aAppRect.height)); }
15687: 
    1:   nscoord TwipsToAppUnits(PRInt32 aTwips) const
    1:   { return NSToCoordRound(NS_TWIPS_TO_INCHES(aTwips) *
    1:                           mDeviceContext->AppUnitsPerInch()); }
    1: 
13309:   // Margin-specific version, since they often need TwipsToAppUnits
19835:   nsMargin TwipsToAppUnits(const nsMargin &marginInTwips) const
13309:   { return nsMargin(TwipsToAppUnits(marginInTwips.left), 
13309:                     TwipsToAppUnits(marginInTwips.top),
13309:                     TwipsToAppUnits(marginInTwips.right),
13309:                     TwipsToAppUnits(marginInTwips.bottom)); }
13309: 
    1:   nscoord PointsToAppUnits(float aPoints) const
    1:   { return NSToCoordRound(aPoints * mDeviceContext->AppUnitsPerInch() /
14015:                           POINTS_PER_INCH_FLOAT); }
    1: 
 4628:   nscoord RoundAppUnitsToNearestDevPixels(nscoord aAppUnits) const
 4628:   { return DevPixelsToAppUnits(AppUnitsToDevPixels(aAppUnits)); }
 4628: 
    1:   struct ScrollbarStyles {
    1:     // Always one of NS_STYLE_OVERFLOW_SCROLL, NS_STYLE_OVERFLOW_HIDDEN,
    1:     // or NS_STYLE_OVERFLOW_AUTO.
    1:     PRUint8 mHorizontal, mVertical;
    1:     ScrollbarStyles(PRUint8 h, PRUint8 v) : mHorizontal(h), mVertical(v) {}
    1:     ScrollbarStyles() {}
    1:   };
    1:   void SetViewportOverflowOverride(PRUint8 aX, PRUint8 aY)
    1:   {
    1:     mViewportStyleOverflow.mHorizontal = aX;
    1:     mViewportStyleOverflow.mVertical = aY;
    1:   }
    1:   ScrollbarStyles GetViewportOverflowOverride()
    1:   {
    1:     return mViewportStyleOverflow;
    1:   }
    1: 
    1:   /**
    1:    * Set and get methods for controlling the background drawing
    1:   */
    1:   PRBool GetBackgroundImageDraw() const { return mDrawImageBackground; }
    1:   void   SetBackgroundImageDraw(PRBool aCanDraw)
    1:   {
    1:     NS_ASSERTION(!(aCanDraw & ~1), "Value must be true or false");
    1:     mDrawImageBackground = aCanDraw;
    1:   }
    1: 
    1:   PRBool GetBackgroundColorDraw() const { return mDrawColorBackground; }
    1:   void   SetBackgroundColorDraw(PRBool aCanDraw)
    1:   {
    1:     NS_ASSERTION(!(aCanDraw & ~1), "Value must be true or false");
    1:     mDrawColorBackground = aCanDraw;
    1:   }
    1: 
    1: #ifdef IBMBIDI
    1:   /**
    1:    *  Check if bidi enabled (set depending on the presence of RTL
    1:    *  characters or when default directionality is RTL).
    1:    *  If enabled, we should apply the Unicode Bidi Algorithm
    1:    *
    1:    *  @lina 07/12/2000
    1:    */
    1:   virtual NS_HIDDEN_(PRBool) BidiEnabledExternal() const;
    1:   NS_HIDDEN_(PRBool) BidiEnabledInternal() const;
    1: #ifdef _IMPL_NS_LAYOUT
    1:   PRBool BidiEnabled() const { return BidiEnabledInternal(); }
    1: #else
    1:   PRBool BidiEnabled() const { return BidiEnabledExternal(); }
    1: #endif
    1: 
    1:   /**
    1:    *  Set bidi enabled. This means we should apply the Unicode Bidi Algorithm
    1:    *
    1:    *  @lina 07/12/2000
    1:    */
15376:   NS_HIDDEN_(void) SetBidiEnabled() const;
    1: 
    1:   /**
    1:    *  Set visual or implicit mode into the pres context.
    1:    *
    1:    *  Visual directionality is a presentation method that displays text
    1:    *  as if it were a uni-directional, according to the primary display
    1:    *  direction only. 
    1:    *
    1:    *  Implicit directionality is a presentation method in which the
    1:    *  direction is determined by the Bidi algorithm according to the
    1:    *  category of the characters and the category of the adjacent
    1:    *  characters, and according to their primary direction.
    1:    *
    1:    *  @lina 05/02/2000
    1:    */
    1:   void SetVisualMode(PRBool aIsVisual)
    1:   {
    1:     NS_ASSERTION(!(aIsVisual & ~1), "Value must be true or false");
    1:     mIsVisual = aIsVisual;
    1:   }
    1: 
    1:   /**
    1:    *  Check whether the content should be treated as visual.
    1:    *
    1:    *  @lina 05/02/2000
    1:    */
    1:   PRBool IsVisualMode() const { return mIsVisual; }
    1: 
    1: //Mohamed
    1: 
    1:   /**
    1:    * Get a Bidi presentation utilities object
    1:    */
    1:   NS_HIDDEN_(nsBidiPresUtils*) GetBidiUtils();
    1: 
    1:   /**
    1:    * Set the Bidi options for the presentation context
    1:    */  
    1:   NS_HIDDEN_(void) SetBidi(PRUint32 aBidiOptions,
10073:                            PRBool aForceRestyle = PR_FALSE);
    1: 
    1:   /**
    1:    * Get the Bidi options for the presentation context
    1:    * Not inline so consumers of nsPresContext are not forced to
    1:    * include nsIDocument.
    1:    */  
    1:   NS_HIDDEN_(PRUint32) GetBidi() const;
    1: #endif // IBMBIDI
    1: 
    1:   /**
    1:    * Render only Selection
    1:    */
    1:   void SetIsRenderingOnlySelection(PRBool aResult)
    1:   {
    1:     NS_ASSERTION(!(aResult & ~1), "Value must be true or false");
    1:     mIsRenderingOnlySelection = aResult;
    1:   }
    1: 
    1:   PRBool IsRenderingOnlySelection() const { return mIsRenderingOnlySelection; }
    1: 
    1:   /*
    1:    * Obtain a native them for rendering our widgets (both form controls and html)
    1:    */
    1:   NS_HIDDEN_(nsITheme*) GetTheme();
    1: 
    1:   /*
    1:    * Notify the pres context that the theme has changed.  An internal switch
    1:    * means it's one of our Mozilla themes that changed (e.g., Modern to Classic).
    1:    * Otherwise, the OS is telling us that the native theme for the platform
    1:    * has changed.
    1:    */
    1:   NS_HIDDEN_(void) ThemeChanged();
    1: 
    1:   /*
    1:    * Notify the pres context that a system color has changed
    1:    */
    1:   NS_HIDDEN_(void) SysColorChanged();
    1: 
    1:   /** Printing methods below should only be used for Medium() == print **/
    1:   NS_HIDDEN_(void) SetPrintSettings(nsIPrintSettings *aPrintSettings);
    1: 
    1:   nsIPrintSettings* GetPrintSettings() { return mPrintSettings; }
    1: 
    1:   /* Accessor for table of frame properties */
    1:   nsPropertyTable* PropertyTable() { return &mPropertyTable; }
    1: 
    1:   /* Helper function that ensures that this prescontext is shown in its
    1:      docshell if it's the most recent prescontext for the docshell.  Returns
    1:      whether the prescontext is now being shown.
    1: 
    1:      @param aUnsuppressFocus If this is false, then focus will not be
    1:      unsuppressed when PR_TRUE is returned.  It's the caller's responsibility
    1:      to unsuppress focus in that case.
    1:   */
    1:   NS_HIDDEN_(PRBool) EnsureVisible(PRBool aUnsuppressFocus);
    1:   
    1: #ifdef MOZ_REFLOW_PERF
    1:   NS_HIDDEN_(void) CountReflows(const char * aName,
    1:                                 nsIFrame * aFrame);
    1: #endif
    1: 
    1:   /**
    1:    * This table maps border-width enums 'thin', 'medium', 'thick'
    1:    * to actual nscoord values.
    1:    */
    1:   const nscoord* GetBorderWidthTable() { return mBorderWidthTable; }
    1: 
  731:   PRBool IsDynamic() { return (mType == eContext_PageLayout || mType == eContext_Galley); }
    1:   PRBool IsScreen() { return (mMedium == nsGkAtoms::screen ||
    1:                               mType == eContext_PageLayout ||
  731:                               mType == eContext_PrintPreview); }
    1: 
 1540:   // Is this presentation in a chrome docshell?
 8088:   PRBool IsChrome() const;
 1540: 
 6734:   // Public API for native theme code to get style internals.
14697:   virtual PRBool HasAuthorSpecifiedRules(nsIFrame *aFrame, PRUint32 ruleTypeMask) const;
 6734: 
 8088:   // Is it OK to let the page specify colors and backgrounds?
 8088:   PRBool UseDocumentColors() const {
 8088:     return GetCachedBoolPref(kPresContext_UseDocumentColors) || IsChrome();
 8088:   }
 8088: 
10872:   PRBool           SupressingResizeReflow() const { return mSupressResizeReflow; }
10872:   
22335:   virtual NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetExternal();
22335:   NS_HIDDEN_(gfxUserFontSet*) GetUserFontSetInternal();
22335: #ifdef _IMPL_NS_LAYOUT
22335:   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetInternal(); }
22335: #else
22335:   gfxUserFontSet* GetUserFontSet() { return GetUserFontSetExternal(); }
22335: #endif
22335: 
21925:   void FlushUserFontSet();
21925:   void RebuildUserFontSet(); // asynchronously
19962: 
22507:   // Should be called whenever the set of fonts available in the user
22507:   // font set changes (e.g., because a new font loads, or because the
22507:   // user font set is changed and fonts become unavailable).
22507:   void UserFontSetUpdated();
22507: 
19380:   void NotifyInvalidation(const nsRect& aRect, PRBool aIsCrossDoc);
19380:   void FireDOMPaintEvent();
19380: 
    1: protected:
    1:   friend class nsRunnableMethod<nsPresContext>;
    1:   NS_HIDDEN_(void) ThemeChangedInternal();
    1:   NS_HIDDEN_(void) SysColorChangedInternal();
    1: 
    1:   NS_HIDDEN_(void) SetImgAnimations(nsIContent *aParent, PRUint16 aMode);
    1:   NS_HIDDEN_(void) GetDocumentColorPreferences();
    1: 
    1:   NS_HIDDEN_(void) PreferenceChanged(const char* aPrefName);
20261:   static NS_HIDDEN_(int) PrefChangedCallback(const char*, void*);
    1: 
    1:   NS_HIDDEN_(void) UpdateAfterPreferencesChanged();
20261:   static NS_HIDDEN_(void) PrefChangedUpdateTimerCallback(nsITimer *aTimer, void *aClosure);
    1: 
    1:   NS_HIDDEN_(void) GetUserPreferences();
    1:   NS_HIDDEN_(void) GetFontPreferences();
    1: 
    1:   NS_HIDDEN_(void) UpdateCharSet(const nsAFlatCString& aCharSet);
    1: 
21925:   void HandleRebuildUserFontSet() {
21925:     mPostedFlushUserFontSet = PR_FALSE;
21925:     FlushUserFontSet();
21925:   }
21925: 
23163:   // Can't be inline because we can't include nsStyleSet.h.
23163:   PRBool HasCachedStyleData();
23163: 
    1:   // IMPORTANT: The ownership implicit in the following member variables
    1:   // has been explicitly checked.  If you add any members to this class,
    1:   // please make the ownership explicit (pinkerton, scc).
    1:   
    1:   nsPresContextType     mType;
    1:   nsIPresShell*         mShell;         // [WEAK]
    1:   nsCOMPtr<nsIDocument> mDocument;
    1:   nsIDeviceContext*     mDeviceContext; // [STRONG] could be weak, but
    1:                                         // better safe than sorry.
    1:                                         // Cannot reintroduce cycles
    1:                                         // since there is no dependency
    1:                                         // from gfx back to layout.
    1:   nsIEventStateManager* mEventManager;  // [STRONG]
    1:   nsILookAndFeel*       mLookAndFeel;   // [STRONG]
    1:   nsIAtom*              mMedium;        // initialized by subclass ctors;
    1:                                         // weak pointer to static atom
    1: 
    1:   nsILinkHandler*       mLinkHandler;   // [WEAK]
    1:   nsIAtom*              mLangGroup;     // [STRONG]
    1: 
21023:   ImageLoaderTable      mImageLoaders;
21023:   ImageLoaderTable      mBorderImageLoaders;
    1:   nsWeakPtr             mContainer;
    1: 
    1:   float                 mTextZoom;      // Text zoom, defaults to 1.0
 4359:   float                 mFullZoom;      // Page zoom, defaults to 1.0
10872: 
 5249:   PRInt32               mCurAppUnitsPerDevPixel;
 4032:   PRInt32               mAutoQualityMinFontSizePixelsPref;
    1: 
    1: #ifdef IBMBIDI
    1:   nsBidiPresUtils*      mBidiUtils;
    1: #endif
    1: 
    1:   nsCOMPtr<nsITheme> mTheme;
    1:   nsCOMPtr<nsILanguageAtomService> mLangService;
    1:   nsCOMPtr<nsIPrintSettings> mPrintSettings;
    1:   nsCOMPtr<nsITimer>    mPrefChangedTimer;
    1: 
    1:   nsPropertyTable       mPropertyTable;
    1: 
19380:   nsRegion              mSameDocDirtyRegion;
19380:   nsRegion              mCrossDocDirtyRegion;
19380: 
19962:   // container for per-context fonts (downloadable, SVG, etc.)
19962:   gfxUserFontSet* mUserFontSet;
21925:   // The list of @font-face rules that we put into mUserFontSet
21983:   nsTArray<nsFontFaceRuleContainer> mFontFaceRules;
19962:   
    1:   PRInt32               mFontScaler;
    1:   nscoord               mMinimumFontSize;
    1: 
    1:   nsRect                mVisibleArea;
    1:   nsSize                mPageSize;
    1:   float                 mPageScale;
    1:   float                 mPPScale;
    1: 
    1:   nscolor               mDefaultColor;
    1:   nscolor               mBackgroundColor;
    1: 
    1:   nscolor               mLinkColor;
    1:   nscolor               mActiveLinkColor;
    1:   nscolor               mVisitedLinkColor;
    1: 
    1:   nscolor               mFocusBackgroundColor;
    1:   nscolor               mFocusTextColor;
    1: 
    1:   ScrollbarStyles       mViewportStyleOverflow;
    1:   PRUint8               mFocusRingWidth;
    1: 
    1:   PRUint16              mImageAnimationMode;
    1:   PRUint16              mImageAnimationModePref;
    1: 
    1:   nsFont                mDefaultVariableFont;
    1:   nsFont                mDefaultFixedFont;
    1:   nsFont                mDefaultSerifFont;
    1:   nsFont                mDefaultSansSerifFont;
    1:   nsFont                mDefaultMonospaceFont;
    1:   nsFont                mDefaultCursiveFont;
    1:   nsFont                mDefaultFantasyFont;
    1: 
    1:   nscoord               mBorderWidthTable[3];
    1: 
    1:   unsigned              mUseDocumentFonts : 1;
    1:   unsigned              mUseDocumentColors : 1;
    1:   unsigned              mUnderlineLinks : 1;
    1:   unsigned              mUseFocusColors : 1;
    1:   unsigned              mFocusRingOnAnything : 1;
20177:   unsigned              mFocusRingStyle : 1;
    1:   unsigned              mDrawImageBackground : 1;
    1:   unsigned              mDrawColorBackground : 1;
    1:   unsigned              mNeverAnimate : 1;
    1:   unsigned              mIsRenderingOnlySelection : 1;
    1:   unsigned              mNoTheme : 1;
    1:   unsigned              mPaginated : 1;
    1:   unsigned              mCanPaginatedScroll : 1;
    1:   unsigned              mDoScaledTwips : 1;
    1:   unsigned              mEnableJapaneseTransform : 1;
    1:   unsigned              mIsRootPaginatedDocument : 1;
    1:   unsigned              mPrefBidiDirection : 1;
    1:   unsigned              mPrefScrollbarSide : 2;
    1:   unsigned              mPendingSysColorChanged : 1;
    1:   unsigned              mPendingThemeChanged : 1;
16226:   unsigned              mPendingMediaFeatureValuesChanged : 1;
11409:   unsigned              mPrefChangePendingNeedsReflow : 1;
    1:   unsigned              mRenderedPositionVaryingContent : 1;
21925: 
21925:   // Is the current mUserFontSet valid?
21924:   unsigned              mUserFontSetDirty : 1;
21925:   // Has GetUserFontSet() been called?
21925:   unsigned              mGetUserFontSetCalled : 1;
21925:   // Do we currently have an event posted to call FlushUserFontSet?
21925:   unsigned              mPostedFlushUserFontSet : 1;
    1: 
10872:   // resize reflow is supressed when the only change has been to zoom
10872:   // the document rather than to change the document's dimensions
10872:   unsigned              mSupressResizeReflow : 1;
10872: 
    1: #ifdef IBMBIDI
    1:   unsigned              mIsVisual : 1;
    1: 
    1: #endif
    1: #ifdef DEBUG
    1:   PRBool                mInitialized;
    1: #endif
    1: 
    1: 
    1: protected:
    1: 
    1:   ~nsPresContext() NS_HIDDEN;
    1: 
    1:   // these are private, use the list in nsFont.h if you want a public list
    1:   enum {
    1:     eDefaultFont_Variable,
    1:     eDefaultFont_Fixed,
    1:     eDefaultFont_Serif,
    1:     eDefaultFont_SansSerif,
    1:     eDefaultFont_Monospace,
    1:     eDefaultFont_Cursive,
    1:     eDefaultFont_Fantasy,
    1:     eDefaultFont_COUNT
    1:   };
    1: 
    1: #ifdef DEBUG
    1: private:
    1:   friend struct nsAutoLayoutPhase;
    1:   PRUint32 mLayoutPhaseCount[eLayoutPhase_COUNT];
    1: public:
    1:   PRUint32 LayoutPhaseCount(nsLayoutPhase aPhase) {
    1:     return mLayoutPhaseCount[aPhase];
    1:   }
    1: #endif
    1: 
    1: };
    1: 
    1: #ifdef DEBUG
    1: 
    1: struct nsAutoLayoutPhase {
    1:   nsAutoLayoutPhase(nsPresContext* aPresContext, nsLayoutPhase aPhase)
    1:     : mPresContext(aPresContext), mPhase(aPhase), mCount(0)
    1:   {
    1:     Enter();
    1:   }
    1: 
    1:   ~nsAutoLayoutPhase()
    1:   {
    1:     Exit();
    1:     NS_ASSERTION(mCount == 0, "imbalanced");
    1:   }
    1: 
    1:   void Enter()
    1:   {
    1:     switch (mPhase) {
    1:       case eLayoutPhase_Paint:
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Paint] == 0,
    1:                      "recurring into paint");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Reflow] == 0,
    1:                      "painting in the middle of reflow");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_FrameC] == 0,
    1:                      "painting in the middle of frame construction");
    1:         break;
    1:       case eLayoutPhase_Reflow:
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Paint] == 0,
    1:                      "reflowing in the middle of a paint");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Reflow] == 0,
    1:                      "recurring into reflow");
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_FrameC] == 0,
    1:                      "reflowing in the middle of frame construction");
    1:         break;
    1:       case eLayoutPhase_FrameC:
    1:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Paint] == 0,
    1:                      "constructing frames in the middle of a paint");
 3138:         NS_ASSERTION(mPresContext->mLayoutPhaseCount[eLayoutPhase_Reflow] == 0,
    1:                      "constructing frames in the middle of reflow");
    1:         // The nsXBLService::LoadBindings call in ConstructFrameInternal
    1:         // makes us hit this one too often to be an NS_ASSERTION,
    1:         // despite how scary it is.
    1:         NS_WARN_IF_FALSE(mPresContext->mLayoutPhaseCount[eLayoutPhase_FrameC] == 0,
    1:                          "recurring into frame construction");
    1:         break;
    1:       default:
    1:         break;
    1:     }
    1:     ++(mPresContext->mLayoutPhaseCount[mPhase]);
    1:     ++mCount;
    1:   }
    1: 
    1:   void Exit()
    1:   {
    1:     NS_ASSERTION(mCount > 0 && mPresContext->mLayoutPhaseCount[mPhase] > 0,
    1:                  "imbalanced");
    1:     --(mPresContext->mLayoutPhaseCount[mPhase]);
    1:     --mCount;
    1:   }
    1: 
    1: private:
    1:   nsPresContext *mPresContext;
    1:   nsLayoutPhase mPhase;
    1:   PRUint32 mCount;
    1: };
    1: 
    1: #define AUTO_LAYOUT_PHASE_ENTRY_POINT(pc_, phase_) \
    1:   nsAutoLayoutPhase autoLayoutPhase((pc_), (eLayoutPhase_##phase_))
    1: #define LAYOUT_PHASE_TEMP_EXIT() \
    1:   PR_BEGIN_MACRO \
    1:     autoLayoutPhase.Exit(); \
    1:   PR_END_MACRO
    1: #define LAYOUT_PHASE_TEMP_REENTER() \
    1:   PR_BEGIN_MACRO \
    1:     autoLayoutPhase.Enter(); \
    1:   PR_END_MACRO
    1: 
    1: #else
    1: 
    1: #define AUTO_LAYOUT_PHASE_ENTRY_POINT(pc_, phase_) \
    1:   PR_BEGIN_MACRO PR_END_MACRO
    1: #define LAYOUT_PHASE_TEMP_EXIT() \
    1:   PR_BEGIN_MACRO PR_END_MACRO
    1: #define LAYOUT_PHASE_TEMP_REENTER() \
    1:   PR_BEGIN_MACRO PR_END_MACRO
    1: 
    1: #endif
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1: 
    1: #define DO_GLOBAL_REFLOW_COUNT(_name) \
    1:   aPresContext->CountReflows((_name), (nsIFrame*)this); 
    1: #else
    1: #define DO_GLOBAL_REFLOW_COUNT(_name)
    1: #endif // MOZ_REFLOW_PERF
    1: 
    1: #endif /* nsPresContext_h___ */
