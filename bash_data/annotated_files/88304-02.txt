82129: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35117:  * vim: set ts=8 sw=4 et tw=99:
35117:  *
35117:  * ***** BEGIN LICENSE BLOCK *****
35117:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35117:  *
35117:  * The contents of this file are subject to the Mozilla Public License Version
35117:  * 1.1 (the "License"); you may not use this file except in compliance with
35117:  * the License. You may obtain a copy of the License at
35117:  * http://www.mozilla.org/MPL/
35117:  *
35117:  * Software distributed under the License is distributed on an "AS IS" basis,
35117:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35117:  * for the specific language governing rights and limitations under the
35117:  * License.
35117:  *
35117:  * The Original Code is Mozilla Communicator client code, released
35117:  * March 31, 1998.
35117:  *
35117:  * The Initial Developer of the Original Code is
35117:  * Netscape Communications Corporation.
35117:  * Portions created by the Initial Developer are Copyright (C) 1998
35117:  * the Initial Developer. All Rights Reserved.
35117:  *
35117:  * Contributor(s):
35117:  *
35117:  * Alternatively, the contents of this file may be used under the terms of
35117:  * either of the GNU General Public License Version 2 or later (the "GPL"),
35117:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35117:  * in which case the provisions of the GPL or the LGPL are applicable instead
35117:  * of those above. If you wish to allow use of your version of this file only
35117:  * under the terms of either the GPL or the LGPL, and not to allow others to
35117:  * use your version of this file under the terms of the MPL, indicate your
35117:  * decision by deleting the provisions above and replace them with the notice
35117:  * and other provisions required by the GPL or the LGPL. If you do not delete
35117:  * the provisions above, a recipient may use your version of this file under
35117:  * the terms of any one of the MPL, the GPL or the LGPL.
35117:  *
35117:  * ***** END LICENSE BLOCK ***** */
35117: 
35117: #ifndef jsobjinlines_h___
35117: #define jsobjinlines_h___
35117: 
52503: #include <new>
82129: 
86988: #include "jsapi.h"
77343: #include "jsarray.h"
86483: #include "jsbool.h"
86483: #include "jscntxt.h"
40901: #include "jsdate.h"
52503: #include "jsfun.h"
82129: #include "jsgcmark.h"
40901: #include "jsiter.h"
52503: #include "jslock.h"
86483: #include "jsnum.h"
40900: #include "jsobj.h"
53555: #include "jsprobes.h"
52503: #include "jspropertytree.h"
63085: #include "jsproxy.h"
35117: #include "jsscope.h"
86483: #include "jsstr.h"
68896: #include "jstypedarray.h"
42693: #include "jsxml.h"
79734: #include "jswrapper.h"
42693: 
82129: #include "gc/Barrier.h"
82129: #include "js/TemplateLib.h"
69639: #include "vm/GlobalObject.h"
69639: 
78329: #include "jsatominlines.h"
63085: #include "jsfuninlines.h"
54707: #include "jsgcinlines.h"
86483: #include "jsinferinlines.h"
64345: #include "jsscopeinlines.h"
86483: #include "jsscriptinlines.h"
54707: 
82129: #include "gc/Barrier-inl.h"
82129: #include "vm/String-inl.h"
82129: 
54563: inline bool
83233: JSObject::hasPrivate() const
52503: {
83275:     return getClass()->hasPrivate();
54563: }
54563: 
83233: inline void *&
84755: JSObject::privateRef(uint32_t nfixed) const
83233: {
83233:     /*
83233:      * The private pointer of an object can hold any word sized value.
83233:      * Private pointers are stored immediately after the last fixed slot of
83233:      * the object.
83233:      */
83233:     JS_ASSERT(nfixed == numFixedSlots());
83275:     JS_ASSERT(hasPrivate());
83301:     js::HeapValue *end = &fixedSlots()[nfixed];
83233:     return *reinterpret_cast<void**>(end);
83233: }
54563: 
83227: inline void *
83282: JSObject::getPrivate() const { return privateRef(numFixedSlots()); }
83233: 
83233: inline void *
83282: JSObject::getPrivate(size_t nfixed) const { return privateRef(nfixed); }
83227: 
83227: inline void
83227: JSObject::setPrivate(void *data)
83227: {
83301:     void **pprivate = &privateRef(numFixedSlots());
83301: 
83301:     privateWriteBarrierPre(pprivate);
83301:     *pprivate = data;
83301:     privateWriteBarrierPost(pprivate);
52503: }
52503: 
52503: inline bool
83227: JSObject::enumerate(JSContext *cx, JSIterateOp iterop, js::Value *statep, jsid *idp)
52503: {
83227:     JSNewEnumerateOp op = getOps()->enumerate;
83227:     return (op ? op : JS_EnumerateState)(cx, this, iterop, statep, idp);
52503: }
52503: 
52503: inline bool
83227: JSObject::defaultValue(JSContext *cx, JSType hint, js::Value *vp)
52503: {
83227:     JSConvertOp op = getClass()->convert;
83227:     bool ok = (op == JS_ConvertStub ? js::DefaultValue : op)(cx, this, hint, vp);
83227:     JS_ASSERT_IF(ok, vp->isPrimitive());
83227:     return ok;
59227: }
83227: 
83227: inline JSType
83227: JSObject::typeOf(JSContext *cx)
83227: {
83227:     js::TypeOfOp op = getOps()->typeOf;
83227:     return (op ? op : js_TypeOf)(cx, this);
83227: }
83227: 
83227: inline JSObject *
83227: JSObject::thisObject(JSContext *cx)
83227: {
83227:     JSObjectOp op = getOps()->thisObject;
83227:     return op ? op(cx, this) : this;
52503: }
52503: 
77343: inline JSBool
80625: JSObject::setGeneric(JSContext *cx, jsid id, js::Value *vp, JSBool strict)
80625: {
80625:     if (getOps()->setGeneric)
80625:         return nonNativeSetProperty(cx, id, vp, strict);
80625:     return js_SetPropertyHelper(cx, this, id, 0, vp, strict);
80625: }
80625: 
80625: inline JSBool
80625: JSObject::setProperty(JSContext *cx, js::PropertyName *name, js::Value *vp, JSBool strict)
80625: {
80625:     return setGeneric(cx, ATOM_TO_JSID(name), vp, strict);
80625: }
80625: 
80625: inline JSBool
84755: JSObject::setElement(JSContext *cx, uint32_t index, js::Value *vp, JSBool strict)
80625: {
80625:     if (getOps()->setElement)
80625:         return nonNativeSetElement(cx, index, vp, strict);
80625:     return js_SetElementHelper(cx, this, index, 0, vp, strict);
80625: }
80625: 
80625: inline JSBool
80625: JSObject::setSpecial(JSContext *cx, js::SpecialId sid, js::Value *vp, JSBool strict)
80625: {
80625:     return setGeneric(cx, SPECIALID_TO_JSID(sid), vp, strict);
80625: }
80625: 
80625: inline JSBool
80622: JSObject::setGenericAttributes(JSContext *cx, jsid id, uintN *attrsp)
77343: {
77353:     js::types::MarkTypePropertyConfigured(cx, this, id);
80622:     js::GenericAttributesOp op = getOps()->setGenericAttributes;
77343:     return (op ? op : js_SetAttributes)(cx, this, id, attrsp);
77343: }
77343: 
77343: inline JSBool
80622: JSObject::setPropertyAttributes(JSContext *cx, js::PropertyName *name, uintN *attrsp)
80622: {
80622:     return setGenericAttributes(cx, ATOM_TO_JSID(name), attrsp);
80622: }
80622: 
80622: inline JSBool
84755: JSObject::setElementAttributes(JSContext *cx, uint32_t index, uintN *attrsp)
80622: {
80622:     js::ElementAttributesOp op = getOps()->setElementAttributes;
80622:     return (op ? op : js_SetElementAttributes)(cx, this, index, attrsp);
80622: }
80622: 
80622: inline JSBool
80622: JSObject::setSpecialAttributes(JSContext *cx, js::SpecialId sid, uintN *attrsp)
80622: {
80622:     return setGenericAttributes(cx, SPECIALID_TO_JSID(sid), attrsp);
80622: }
80622: 
80622: inline JSBool
78675: JSObject::getGeneric(JSContext *cx, JSObject *receiver, jsid id, js::Value *vp)
77343: {
78675:     js::GenericIdOp op = getOps()->getGeneric;
77343:     if (op) {
77343:         if (!op(cx, this, receiver, id, vp))
77343:             return false;
77343:     } else {
77343:         if (!js_GetProperty(cx, this, receiver, id, vp))
77343:             return false;
77343:     }
77343:     return true;
77343: }
77343: 
77343: inline JSBool
78675: JSObject::getProperty(JSContext *cx, JSObject *receiver, js::PropertyName *name, js::Value *vp)
77343: {
78675:     return getGeneric(cx, receiver, ATOM_TO_JSID(name), vp);
78675: }
78675: 
78675: inline JSBool
78675: JSObject::getGeneric(JSContext *cx, jsid id, js::Value *vp)
78675: {
78675:     return getGeneric(cx, this, id, vp);
78675: }
78675: 
78675: inline JSBool
78675: JSObject::getProperty(JSContext *cx, js::PropertyName *name, js::Value *vp)
78675: {
78675:     return getGeneric(cx, ATOM_TO_JSID(name), vp);
77343: }
77343: 
86790: inline bool
86790: JSObject::deleteProperty(JSContext *cx, js::PropertyName *name, js::Value *rval, bool strict)
77343: {
86790:     jsid id = js_CheckForStringIndex(ATOM_TO_JSID(name));
86790:     js::types::AddTypePropertyId(cx, this, id, js::types::Type::UndefinedType());
77353:     js::types::MarkTypePropertyConfigured(cx, this, id);
86790:     js::DeletePropertyOp op = getOps()->deleteProperty;
86790:     return (op ? op : js_DeleteProperty)(cx, this, name, rval, strict);
77343: }
77343: 
86790: inline bool
86790: JSObject::deleteElement(JSContext *cx, uint32_t index, js::Value *rval, bool strict)
80623: {
80623:     jsid id;
80623:     if (!js::IndexToId(cx, index, &id))
80623:         return false;
86790:     js::types::AddTypePropertyId(cx, this, id, js::types::Type::UndefinedType());
86790:     js::types::MarkTypePropertyConfigured(cx, this, id);
86790:     js::DeleteElementOp op = getOps()->deleteElement;
86790:     return (op ? op : js_DeleteElement)(cx, this, index, rval, strict);
80623: }
80623: 
86790: inline bool
86790: JSObject::deleteSpecial(JSContext *cx, js::SpecialId sid, js::Value *rval, bool strict)
80623: {
86790:     jsid id = SPECIALID_TO_JSID(sid);
86790:     js::types::AddTypePropertyId(cx, this, id, js::types::Type::UndefinedType());
86790:     js::types::MarkTypePropertyConfigured(cx, this, id);
86790:     js::DeleteSpecialOp op = getOps()->deleteSpecial;
86790:     return (op ? op : js_DeleteSpecial)(cx, this, sid, rval, strict);
80623: }
80623: 
54707: inline void
83223: JSObject::finalize(JSContext *cx, bool background)
57806: {
73746:     js::Probes::finalizeObject(this);
73746: 
83223:     if (!background) {
83223:         /*
83223:          * Finalize obj first, in case it needs map and slots. Objects with
83229:          * finalize hooks are not finalized in the background, as the class is
83229:          * stored in the object's shape, which may have already been destroyed.
83223:          */
54707:         js::Class *clasp = getClass();
54707:         if (clasp->finalize)
54707:             clasp->finalize(cx, this);
83223:     }
54707: 
54707:     finish(cx);
54707: }
54707: 
83239: inline JSObject *
83239: JSObject::getParent() const
64296: {
83245:     return lastProperty()->getObjectParent();
64296: }
64296: 
86483: inline JSObject *
86483: JSObject::enclosingScope()
64296: {
86483:     return isScope() ? &asScope().enclosingScope() : getParent();
64296: }
64296: 
64296: /*
52503:  * Property read barrier for deferred cloning of compiler-created function
52503:  * objects optimized as typically non-escaping, ad-hoc methods in obj.
52503:  */
83297: inline js::Shape *
52503: JSObject::methodReadBarrier(JSContext *cx, const js::Shape &shape, js::Value *vp)
52503: {
78194:     JS_ASSERT(nativeContains(cx, shape));
52503:     JS_ASSERT(shape.isMethod());
83221:     JS_ASSERT(shape.hasSlot());
74472:     JS_ASSERT(shape.hasDefaultSetter());
62588:     JS_ASSERT(!isGlobal());  /* i.e. we are not changing the global shape */
52503: 
83234:     JSFunction *fun = vp->toObject().toFunction();
83234:     JS_ASSERT(!fun->isClonedMethod());
76812:     JS_ASSERT(fun->isNullClosure());
52503: 
83239:     fun = js::CloneFunctionObject(cx, fun);
83234:     if (!fun)
62790:         return NULL;
83234:     fun->setMethodObj(*this);
52503: 
62588:     /*
62588:      * Replace the method property with an ordinary data property. This is
62588:      * equivalent to this->setProperty(cx, shape.id, vp) except that any
62588:      * watchpoint on the property is not triggered.
62588:      */
84755:     uint32_t slot = shape.slot();
83297:     js::Shape *newshape = methodShapeChange(cx, shape);
62588:     if (!newshape)
62588:         return NULL;
62588:     JS_ASSERT(!newshape->isMethod());
83221:     JS_ASSERT(newshape->slot() == slot);
83234:     vp->setObject(*fun);
62588:     nativeSetSlot(slot, *vp);
62790:     return newshape;
52503: }
52503: 
83221: inline bool
83221: JSObject::canHaveMethodBarrier() const
52503: {
83221:     return isObject() || isFunction() || isPrimitive() || isDate();
77343: }
77343: 
77343: inline bool
77343: JSObject::isFixedSlot(size_t slot)
77343: {
77343:     JS_ASSERT(!isDenseArray());
77343:     return slot < numFixedSlots();
77343: }
77343: 
77343: inline size_t
77343: JSObject::dynamicSlotIndex(size_t slot)
77343: {
77343:     JS_ASSERT(!isDenseArray() && slot >= numFixedSlots());
77343:     return slot - numFixedSlots();
77343: }
77343: 
83231: /*static*/ inline size_t
83231: JSObject::dynamicSlotsCount(size_t nfixed, size_t span)
79734: {
83231:     if (span <= nfixed)
83231:         return 0;
83231:     span -= nfixed;
83231:     if (span <= SLOT_CAPACITY_MIN)
83231:         return SLOT_CAPACITY_MIN;
83231: 
83281:     size_t slots = js::RoundUpPow2(span);
83231:     JS_ASSERT(slots >= span);
83231:     return slots;
83231: }
83231: 
83231: inline size_t
83231: JSObject::numDynamicSlots() const
83231: {
83231:     return dynamicSlotsCount(numFixedSlots(), slotSpan());
83231: }
83231: 
83231: inline void
83231: JSObject::setLastPropertyInfallible(const js::Shape *shape)
83231: {
83231:     JS_ASSERT(!shape->inDictionary());
83231:     JS_ASSERT(shape->compartment() == compartment());
83231:     JS_ASSERT(!inDictionaryMode());
83231:     JS_ASSERT(slotSpan() == shape->slotSpan());
83247:     JS_ASSERT(numFixedSlots() == shape->numFixedSlots());
83231: 
83231:     shape_ = const_cast<js::Shape *>(shape);
79734: }
79734: 
83245: inline void
83245: JSObject::removeLastProperty(JSContext *cx)
83245: {
83245:     JS_ASSERT(canRemoveLastProperty());
83245:     JS_ALWAYS_TRUE(setLastProperty(cx, lastProperty()->previous()));
83245: }
83245: 
52503: inline bool
83245: JSObject::canRemoveLastProperty()
52503: {
83245:     /*
83287:      * Check that the information about the object stored in the last
83287:      * property's base shape is consistent with that stored in the previous
83287:      * shape. If not consistent, then the last property cannot be removed as it
83287:      * will induce a change in the object itself, and the object must be
83287:      * converted to dictionary mode instead. See BaseShape comment in jsscope.h
83245:      */
83245:     JS_ASSERT(!inDictionaryMode());
83245:     const js::Shape *previous = lastProperty()->previous();
83248:     return previous->getObjectParent() == lastProperty()->getObjectParent()
83248:         && previous->getObjectFlags() == lastProperty()->getObjectFlags();
81417: }
81417: 
83301: inline const js::HeapValue *
83301: JSObject::getRawSlots()
83301: {
83301:     JS_ASSERT(isGlobal());
83301:     return slots;
52503: }
52503: 
86483: inline const js::Value &
47404: JSObject::getReservedSlot(uintN index) const
47404: {
83231:     JS_ASSERT(index < JSSLOT_FREE(getClass()));
83231:     return getSlot(index);
47404: }
47404: 
82129: inline js::HeapValue &
82129: JSObject::getReservedSlotRef(uintN index)
82129: {
83301:     JS_ASSERT(index < JSSLOT_FREE(getClass()));
82129:     return getSlotRef(index);
82129: }
82129: 
75413: inline void
75413: JSObject::setReservedSlot(uintN index, const js::Value &v)
75413: {
76240:     JS_ASSERT(index < JSSLOT_FREE(getClass()));
75413:     setSlot(index, v);
75413: }
75413: 
48470: inline const js::Value &
40901: JSObject::getPrimitiveThis() const
40901: {
40901:     JS_ASSERT(isPrimitive());
77343:     return getFixedSlot(JSSLOT_PRIMITIVE_THIS);
40901: }
40901: 
40901: inline void
48470: JSObject::setPrimitiveThis(const js::Value &pthis)
40901: {
40901:     JS_ASSERT(isPrimitive());
77343:     setFixedSlot(JSSLOT_PRIMITIVE_THIS, pthis);
40901: }
40901: 
77343: inline bool
77884: JSObject::hasContiguousSlots(size_t start, size_t count) const
77884: {
77884:     /*
77884:      * Check that the range [start, start+count) is either all inline or all
77884:      * out of line.
77884:      */
83281:     JS_ASSERT(slotInRange(start + count, SENTINEL_ALLOWED));
77884:     return (start + count <= numFixedSlots()) || (start >= numFixedSlots());
77884: }
77884: 
82129: inline void
82129: JSObject::prepareSlotRangeForOverwrite(size_t start, size_t end)
82129: {
82129:     for (size_t i = start; i < end; i++)
83304:         getSlotAddressUnchecked(i)->js::HeapValue::~HeapValue();
82129: }
82129: 
83301: inline void
83301: JSObject::prepareElementRangeForOverwrite(size_t start, size_t end)
55746: {
83301:     JS_ASSERT(isDenseArray());
83301:     JS_ASSERT(end <= getDenseArrayInitializedLength());
83301:     for (size_t i = start; i < end; i++)
83301:         elements[i].js::HeapValue::~HeapValue();
40797: }
40797: 
84755: inline uint32_t
40796: JSObject::getArrayLength() const
40796: {
40796:     JS_ASSERT(isArray());
83231:     return getElementsHeader()->length;
40796: }
40796: 
40901: inline void
84755: JSObject::setArrayLength(JSContext *cx, uint32_t length)
40901: {
48537:     JS_ASSERT(isArray());
77343: 
77343:     if (length > INT32_MAX) {
77343:         /*
77343:          * Mark the type of this object as possibly not a dense array, per the
77343:          * requirements of OBJECT_FLAG_NON_DENSE_ARRAY.
77343:          */
77353:         js::types::MarkTypeObjectFlags(cx, this,
77343:                                        js::types::OBJECT_FLAG_NON_PACKED_ARRAY |
77343:                                        js::types::OBJECT_FLAG_NON_DENSE_ARRAY);
77343:         jsid lengthId = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
77353:         js::types::AddTypePropertyId(cx, this, lengthId,
77353:                                      js::types::Type::DoubleType());
77343:     }
77343: 
83231:     getElementsHeader()->length = length;
77343: }
77343: 
77343: inline void
84755: JSObject::setDenseArrayLength(uint32_t length)
77343: {
77343:     /* Variant of setArrayLength for use on dense arrays where the length cannot overflow int32. */
77343:     JS_ASSERT(isDenseArray());
77343:     JS_ASSERT(length <= INT32_MAX);
83231:     getElementsHeader()->length = length;
80557: }
80557: 
84755: inline uint32_t
83263: JSObject::getDenseArrayInitializedLength()
83263: {
83263:     JS_ASSERT(isDenseArray());
83263:     return getElementsHeader()->initializedLength;
83263: }
83263: 
83263: inline void
84755: JSObject::setDenseArrayInitializedLength(uint32_t length)
83263: {
83263:     JS_ASSERT(isDenseArray());
83263:     JS_ASSERT(length <= getDenseArrayCapacity());
84112:     prepareElementRangeForOverwrite(length, getElementsHeader()->initializedLength);
83263:     getElementsHeader()->initializedLength = length;
41850: }
41850: 
84755: inline uint32_t
55746: JSObject::getDenseArrayCapacity()
41782: {
41782:     JS_ASSERT(isDenseArray());
83231:     return getElementsHeader()->capacity;
83231: }
83231: 
83231: inline bool
84755: JSObject::ensureElements(JSContext *cx, uint32_t capacity)
83231: {
83231:     if (capacity > getDenseArrayCapacity())
83231:         return growElements(cx, capacity);
83231:     return true;
55746: }
55746: 
82129: inline js::HeapValueArray
55746: JSObject::getDenseArrayElements()
55746: {
55746:     JS_ASSERT(isDenseArray());
83301:     return js::HeapValueArray(elements);
55746: }
55746: 
55746: inline const js::Value &
55746: JSObject::getDenseArrayElement(uintN idx)
55746: {
77343:     JS_ASSERT(isDenseArray() && idx < getDenseArrayInitializedLength());
83231:     return elements[idx];
55746: }
55746: 
54426: inline void
55746: JSObject::setDenseArrayElement(uintN idx, const js::Value &val)
54426: {
77343:     JS_ASSERT(isDenseArray() && idx < getDenseArrayInitializedLength());
83231:     elements[idx] = val;
77343: }
77343: 
77343: inline void
82129: JSObject::initDenseArrayElement(uintN idx, const js::Value &val)
82129: {
82129:     JS_ASSERT(isDenseArray() && idx < getDenseArrayInitializedLength());
83301:     elements[idx].init(val);
82129: }
82129: 
82129: inline void
77343: JSObject::setDenseArrayElementWithType(JSContext *cx, uintN idx, const js::Value &val)
77343: {
77353:     js::types::AddTypePropertyId(cx, this, JSID_VOID, val);
77343:     setDenseArrayElement(idx, val);
54426: }
54426: 
54426: inline void
82129: JSObject::initDenseArrayElementWithType(JSContext *cx, uintN idx, const js::Value &val)
82129: {
82129:     js::types::AddTypePropertyId(cx, this, JSID_VOID, val);
82129:     initDenseArrayElement(idx, val);
82129: }
82129: 
82129: inline void
74457: JSObject::copyDenseArrayElements(uintN dstStart, const js::Value *src, uintN count)
74457: {
83231:     JS_ASSERT(dstStart + count <= getDenseArrayCapacity());
86295:     JSCompartment *comp = compartment();
84712:     for (unsigned i = 0; i < count; ++i)
86295:         elements[dstStart + i].set(comp, src[i]);
82129: }
82129: 
82129: inline void
82129: JSObject::initDenseArrayElements(uintN dstStart, const js::Value *src, uintN count)
82129: {
83301:     JS_ASSERT(dstStart + count <= getDenseArrayCapacity());
86295:     JSCompartment *comp = compartment();
84712:     for (unsigned i = 0; i < count; ++i)
86295:         elements[dstStart + i].init(comp, src[i]);
74457: }
74457: 
74457: inline void
74457: JSObject::moveDenseArrayElements(uintN dstStart, uintN srcStart, uintN count)
74457: {
83231:     JS_ASSERT(dstStart + count <= getDenseArrayCapacity());
83231:     JS_ASSERT(srcStart + count <= getDenseArrayCapacity());
82129: 
82129:     /*
82129:      * Use a custom write barrier here since it's performance sensitive. We
83301:      * only want to barrier the elements that are being overwritten.
82129:      */
82129:     uintN markStart, markEnd;
82129:     if (dstStart > srcStart) {
82129:         markStart = js::Max(srcStart + count, dstStart);
82129:         markEnd = dstStart + count;
82129:     } else {
82129:         markStart = dstStart;
82129:         markEnd = js::Min(dstStart + count, srcStart);
82129:     }
83301:     prepareElementRangeForOverwrite(markStart, markEnd);
82129: 
83231:     memmove(elements + dstStart, elements + srcStart, count * sizeof(js::Value));
40796: }
40796: 
60243: inline bool
77343: JSObject::denseArrayHasInlineSlots() const
77343: {
83231:     JS_ASSERT(isDenseArray());
83231:     return elements == fixedElements();
77343: }
77343: 
77884: namespace js {
77884: 
86855: inline JSObject *
86855: ValueToObjectOrPrototype(JSContext *cx, const Value &v)
86855: {
86855:     if (v.isObject())
86855:         return &v.toObject();
86855:     GlobalObject *global = &cx->fp()->scopeChain().global();
86855:     if (v.isString())
86855:         return global->getOrCreateStringPrototype(cx);
86855:     if (v.isNumber())
86855:         return global->getOrCreateNumberPrototype(cx);
86855:     if (v.isBoolean())
86855:         return global->getOrCreateBooleanPrototype(cx);
86855:     JS_ASSERT(v.isNull() || v.isUndefined());
86855:     js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
86855:     return NULL;
86855: }
86855: 
77884: /*
77884:  * Any name atom for a function which will be added as a DeclEnv object to the
77884:  * scope chain above call objects for fun.
77884:  */
77884: static inline JSAtom *
77884: CallObjectLambdaName(JSFunction *fun)
77884: {
77884:     return (fun->flags & JSFUN_LAMBDA) ? fun->atom : NULL;
77884: }
77884: 
77884: } /* namespace js */
77884: 
59969: inline const js::Value &
40901: JSObject::getDateUTCTime() const
40901: {
40901:     JS_ASSERT(isDate());
77343:     return getFixedSlot(JSSLOT_DATE_UTC_TIME);
40901: }
40901: 
40901: inline void 
48470: JSObject::setDateUTCTime(const js::Value &time)
40901: {
40901:     JS_ASSERT(isDate());
77343:     setFixedSlot(JSSLOT_DATE_UTC_TIME, time);
40901: }
40901: 
55632: inline js::NativeIterator *
42641: JSObject::getNativeIterator() const
42641: {
55632:     return (js::NativeIterator *) getPrivate();
42641: }
42641: 
42641: inline void
55632: JSObject::setNativeIterator(js::NativeIterator *ni)
42641: {
42641:     setPrivate(ni);
42641: }
42641: 
59890: inline JSLinearString *
59890: JSObject::getNamePrefix() const
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     const js::Value &v = getSlot(JSSLOT_NAME_PREFIX);
64345:     return !v.isUndefined() ? &v.toString()->asLinear() : NULL;
59890: }
59890: 
42693: inline jsval
59890: JSObject::getNamePrefixVal() const
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
78614:     return getSlot(JSSLOT_NAME_PREFIX);
42693: }
42693: 
42693: inline void
59890: JSObject::setNamePrefix(JSLinearString *prefix)
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_PREFIX, prefix ? js::StringValue(prefix) : js::UndefinedValue());
59890: }
59890: 
59890: inline void
59890: JSObject::clearNamePrefix()
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_PREFIX, js::UndefinedValue());
59890: }
59890: 
59890: inline JSLinearString *
59890: JSObject::getNameURI() const
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     const js::Value &v = getSlot(JSSLOT_NAME_URI);
64345:     return !v.isUndefined() ? &v.toString()->asLinear() : NULL;
42693: }
42693: 
42693: inline jsval
59890: JSObject::getNameURIVal() const
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
78614:     return getSlot(JSSLOT_NAME_URI);
42693: }
42693: 
42693: inline void
59890: JSObject::setNameURI(JSLinearString *uri)
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_URI, uri ? js::StringValue(uri) : js::UndefinedValue());
42693: }
42693: 
42693: inline jsval
42693: JSObject::getNamespaceDeclared() const
42693: {
42693:     JS_ASSERT(isNamespace());
78614:     return getSlot(JSSLOT_NAMESPACE_DECLARED);
42693: }
42693: 
42693: inline void
42693: JSObject::setNamespaceDeclared(jsval decl)
42693: {
42693:     JS_ASSERT(isNamespace());
78614:     setSlot(JSSLOT_NAMESPACE_DECLARED, decl);
42693: }
42693: 
76344: inline JSAtom *
59890: JSObject::getQNameLocalName() const
59890: {
59890:     JS_ASSERT(isQName());
59890:     const js::Value &v = getSlot(JSSLOT_QNAME_LOCAL_NAME);
76344:     return !v.isUndefined() ? &v.toString()->asAtom() : NULL;
59890: }
59890: 
42693: inline jsval
59890: JSObject::getQNameLocalNameVal() const
42693: {
42693:     JS_ASSERT(isQName());
78614:     return getSlot(JSSLOT_QNAME_LOCAL_NAME);
42693: }
42693: 
42693: inline void
76344: JSObject::setQNameLocalName(JSAtom *name)
42693: {
42693:     JS_ASSERT(isQName());
59890:     setSlot(JSSLOT_QNAME_LOCAL_NAME, name ? js::StringValue(name) : js::UndefinedValue());
42693: }
42693: 
77353: inline bool
77353: JSObject::setSingletonType(JSContext *cx)
77353: {
77353:     if (!cx->typeInferenceEnabled())
77353:         return true;
77353: 
83231:     JS_ASSERT(!lastProperty()->previous());
77353:     JS_ASSERT(!hasLazyType());
77353:     JS_ASSERT_IF(getProto(), type() == getProto()->getNewType(cx, NULL));
77353: 
83249:     js::types::TypeObject *type = cx->compartment->getLazyType(cx, getProto());
83249:     if (!type)
83249:         return false;
77353: 
83249:     type_ = type;
77353:     return true;
77353: }
77353: 
77343: inline js::types::TypeObject *
77353: JSObject::getType(JSContext *cx)
77353: {
77353:     if (hasLazyType())
77353:         makeLazyType(cx);
77353:     return type_;
77353: }
77353: 
83230: inline bool
83230: JSObject::clearType(JSContext *cx)
77343: {
77353:     JS_ASSERT(!hasSingletonType());
83230: 
83230:     js::types::TypeObject *type = cx->compartment->getEmptyType(cx);
83230:     if (!type)
83230:         return false;
83230: 
83230:     type_ = type;
83230:     return true;
73904: }
73904: 
73904: inline void
77343: JSObject::setType(js::types::TypeObject *newType)
77343: {
77343: #ifdef DEBUG
77343:     JS_ASSERT(newType);
77343:     for (JSObject *obj = newType->proto; obj; obj = obj->getProto())
77343:         JS_ASSERT(obj != this);
77343: #endif
83275:     JS_ASSERT_IF(hasSpecialEquality(),
83248:                  newType->hasAnyFlags(js::types::OBJECT_FLAG_SPECIAL_EQUALITY));
77353:     JS_ASSERT(!hasSingletonType());
77353:     type_ = newType;
77343: }
77343: 
83307: inline bool JSObject::setIteratedSingleton(JSContext *cx)
83307: {
83248:     return setFlag(cx, js::BaseShape::ITERATED_SINGLETON);
81417: }
81417: 
83307: inline bool JSObject::isSystem() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::SYSTEM);
83307: }
83307: 
83307: inline bool JSObject::setSystem(JSContext *cx)
83307: {
83248:     return setFlag(cx, js::BaseShape::SYSTEM);
83248: }
81417: 
83307: inline bool JSObject::isDelegate() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::DELEGATE);
83307: }
83307: 
83307: inline bool JSObject::setDelegate(JSContext *cx)
83307: {
83248:     return setFlag(cx, js::BaseShape::DELEGATE, GENERATE_SHAPE);
83248: }
83248: 
83307: inline bool JSObject::isVarObj() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::VAROBJ);
83307: }
83307: 
83307: inline bool JSObject::setVarObj(JSContext *cx)
83307: {
83248:     return setFlag(cx, js::BaseShape::VAROBJ);
83248: }
83248: 
83307: inline bool JSObject::setWatched(JSContext *cx)
83307: {
83248:     return setFlag(cx, js::BaseShape::WATCHED, GENERATE_SHAPE);
83248: }
83248: 
83307: inline bool JSObject::hasUncacheableProto() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::UNCACHEABLE_PROTO);
83307: }
83248: 
83334: inline bool JSObject::setUncacheableProto(JSContext *cx)
83334: {
83334:     return setFlag(cx, js::BaseShape::UNCACHEABLE_PROTO, GENERATE_SHAPE);
83334: }
83334: 
83307: inline bool JSObject::isExtensible() const
83307: {
83307:     return !lastProperty()->hasObjectFlag(js::BaseShape::NOT_EXTENSIBLE);
83307: }
83307: 
83307: inline bool JSObject::isBoundFunction() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::BOUND_FUNCTION);
83307: }
83307: 
83307: inline bool JSObject::isIndexed() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::INDEXED);
83307: }
83307: 
83307: inline bool JSObject::watched() const
83307: {
83307:     return lastProperty()->hasObjectFlag(js::BaseShape::WATCHED);
83307: }
83307: 
83307: inline bool JSObject::hasSpecialEquality() const
83307: {
83248:     return !!getClass()->ext.equality;
83248: }
83248: 
83227: inline bool JSObject::isArguments() const { return isNormalArguments() || isStrictArguments(); }
83227: inline bool JSObject::isArrayBuffer() const { return hasClass(&js::ArrayBufferClass); }
86483: inline bool JSObject::isBlock() const { return hasClass(&js::BlockClass); }
83227: inline bool JSObject::isBoolean() const { return hasClass(&js::BooleanClass); }
86483: inline bool JSObject::isCall() const { return hasClass(&js::CallClass); }
86483: inline bool JSObject::isClonedBlock() const { return isBlock() && !!getProto(); }
83227: inline bool JSObject::isDate() const { return hasClass(&js::DateClass); }
86483: inline bool JSObject::isDeclEnv() const { return hasClass(&js::DeclEnvClass); }
86483: inline bool JSObject::isError() const { return hasClass(&js::ErrorClass); }
83227: inline bool JSObject::isFunction() const { return hasClass(&js::FunctionClass); }
86483: inline bool JSObject::isFunctionProxy() const { return hasClass(&js::FunctionProxyClass); }
83227: inline bool JSObject::isGenerator() const { return hasClass(&js::GeneratorClass); }
83227: inline bool JSObject::isIterator() const { return hasClass(&js::IteratorClass); }
86483: inline bool JSObject::isNamespace() const { return hasClass(&js::NamespaceClass); }
86483: inline bool JSObject::isNestedScope() const { return isBlock() || isWith(); }
86483: inline bool JSObject::isNormalArguments() const { return hasClass(&js::NormalArgumentsObjectClass); }
86483: inline bool JSObject::isNumber() const { return hasClass(&js::NumberClass); }
86483: inline bool JSObject::isObject() const { return hasClass(&js::ObjectClass); }
86483: inline bool JSObject::isPrimitive() const { return isNumber() || isString() || isBoolean(); }
86483: inline bool JSObject::isRegExp() const { return hasClass(&js::RegExpClass); }
86483: inline bool JSObject::isScope() const { return isCall() || isDeclEnv() || isNestedScope(); }
86483: inline bool JSObject::isStaticBlock() const { return isBlock() && !getProto(); }
83227: inline bool JSObject::isStopIteration() const { return hasClass(&js::StopIterationClass); }
86483: inline bool JSObject::isStrictArguments() const { return hasClass(&js::StrictArgumentsObjectClass); }
86483: inline bool JSObject::isString() const { return hasClass(&js::StringClass); }
86483: inline bool JSObject::isWeakMap() const { return hasClass(&js::WeakMapClass); }
86483: inline bool JSObject::isWith() const { return hasClass(&js::WithClass); }
83227: inline bool JSObject::isXML() const { return hasClass(&js::XMLClass); }
83227: 
83231: inline bool JSObject::isArray() const
82129: {
83231:     return isSlowArray() || isDenseArray();
83231: }
82129: 
83231: inline bool JSObject::isDenseArray() const
83231: {
83231:     bool result = hasClass(&js::ArrayClass);
83231:     JS_ASSERT_IF(result, elements != js::emptyObjectElements);
83231:     return result;
83231: }
83231: 
83231: inline bool JSObject::isSlowArray() const
83231: {
83231:     bool result = hasClass(&js::SlowArrayClass);
83231:     JS_ASSERT_IF(result, elements != js::emptyObjectElements);
83231:     return result;
83231: }
83231: 
83227: inline bool
83227: JSObject::isXMLId() const
83227: {
83227:     return hasClass(&js::QNameClass)
83227:         || hasClass(&js::AttributeNameClass)
83227:         || hasClass(&js::AnyNameClass);
83227: }
83227: 
83227: inline bool
83227: JSObject::isQName() const
83227: {
83227:     return hasClass(&js::QNameClass)
83227:         || hasClass(&js::AttributeNameClass)
83227:         || hasClass(&js::AnyNameClass);
82129: }
82129: 
82129: inline void
83301: JSObject::initializeSlotRange(size_t start, size_t length)
82129: {
83304:     /*
83304:      * No bounds check, as this is used when the object's shape does not
83304:      * reflect its allocated slots (updateSlotsForSpan).
83304:      */
83275:     JS_ASSERT(!isDenseArray());
83275:     size_t fixed = numFixedSlots();
83275:     if (start < fixed) {
83275:         if (start + length < fixed) {
83302:             js::InitValueRange(fixedSlots() + start, length, false);
83275:         } else {
83275:             size_t localClear = fixed - start;
83302:             js::InitValueRange(fixedSlots() + start, localClear, false);
83302:             js::InitValueRange(slots, length - localClear, false);
83275:         }
83275:     } else {
83302:         js::InitValueRange(slots + start - fixed, length, false);
83275:     }
82129: }
82129: 
83314: /* static */ inline JSObject *
83314: JSObject::create(JSContext *cx, js::gc::AllocKind kind,
86437:                  js::HandleShape shape, js::HandleTypeObject type, js::HeapValue *slots)
35117: {
83275:     /*
83275:      * Callers must use dynamicSlotsCount to size the initial slot array of the
83275:      * object. We can't check the allocated capacity of the dynamic slots, but
83275:      * make sure their presence is consistent with the shape.
83275:      */
83275:     JS_ASSERT(shape && type);
83275:     JS_ASSERT(!!dynamicSlotsCount(shape->numFixedSlots(), shape->slotSpan()) == !!slots);
83314:     JS_ASSERT(js::gc::GetGCKindSlots(kind, shape->getObjectClass()) == shape->numFixedSlots());
77343: 
83314:     JSObject *obj = js_NewGCObject(cx, kind);
83314:     if (!obj)
83314:         return NULL;
83314: 
83314:     obj->shape_.init(shape);
83314:     obj->type_.init(type);
83314:     obj->slots = slots;
83314:     obj->elements = js::emptyObjectElements;
52503: 
83275:     if (shape->getObjectClass()->hasPrivate())
83326:         obj->privateRef(shape->numFixedSlots()) = NULL;
52503: 
83314:     if (size_t span = shape->slotSpan())
83314:         obj->initializeSlotRange(0, span);
83314: 
83314:     return obj;
77343: }
52503: 
83314: /* static */ inline JSObject *
83314: JSObject::createDenseArray(JSContext *cx, js::gc::AllocKind kind,
86437:                            js::HandleShape shape, js::HandleTypeObject type,
86437:                            uint32_t length)
83275: {
83275:     JS_ASSERT(shape && type);
83275:     JS_ASSERT(shape->getObjectClass() == &js::ArrayClass);
83247: 
83321:     /*
83321:      * Dense arrays are non-native, and never have properties to store.
83321:      * The number of fixed slots in the shape of such objects is zero.
83321:      */
83321:     JS_ASSERT(shape->numFixedSlots() == 0);
83321: 
83321:     /*
83321:      * The array initially stores its elements inline, there must be enough
83321:      * space for an elements header.
83321:      */
83321:     JS_ASSERT(js::gc::GetGCKindSlots(kind) >= js::ObjectElements::VALUES_PER_HEADER);
83321: 
84755:     uint32_t capacity = js::gc::GetGCKindSlots(kind) - js::ObjectElements::VALUES_PER_HEADER;
83247: 
83314:     JSObject *obj = js_NewGCObject(cx, kind);
83314:     if (!obj)
83314:         return NULL;
83314: 
83314:     obj->shape_.init(shape);
83314:     obj->type_.init(type);
83314:     obj->slots = NULL;
83314:     obj->setFixedElements();
83321:     new (obj->getElementsHeader()) js::ObjectElements(capacity, length);
83314: 
83314:     return obj;
53638: }
53638: 
53638: inline void
52503: JSObject::finish(JSContext *cx)
52503: {
83231:     if (hasDynamicSlots())
77343:         cx->free_(slots);
83231:     if (hasDynamicElements())
83231:         cx->free_(getElementsHeader());
53638: }
53638: 
37685: inline bool
52503: JSObject::hasProperty(JSContext *cx, jsid id, bool *foundp, uintN flags)
37685: {
52503:     JSObject *pobj;
52503:     JSProperty *prop;
52503:     JSAutoResolveFlags rf(cx, flags);
80442:     if (!lookupGeneric(cx, id, &pobj, &prop))
37685:         return false;
52503:     *foundp = !!prop;
52503:     return true;
37685: }
52503: 
52503: inline bool
52503: JSObject::isCallable()
52503: {
52503:     return isFunction() || getClass()->call;
37685: }
52503: 
68894: inline JSPrincipals *
68894: JSObject::principals(JSContext *cx)
68894: {
69647:     JSSecurityCallbacks *cb = JS_GetSecurityCallbacks(cx);
69647:     if (JSObjectPrincipalsFinder finder = cb ? cb->findObjectPrincipals : NULL)
69647:         return finder(cx, this);
74280:     return cx->compartment ? cx->compartment->principals : NULL;
68894: }
68894: 
84755: inline uint32_t
68935: JSObject::slotSpan() const
68935: {
83229:     if (inDictionaryMode())
83231:         return lastProperty()->base()->slotSpan();
83231:     return lastProperty()->slotSpan();
68935: }
68935: 
82129: inline js::HeapValue &
68935: JSObject::nativeGetSlotRef(uintN slot)
68935: {
68935:     JS_ASSERT(isNative());
86009:     JS_ASSERT(slot < slotSpan());
68935:     return getSlotRef(slot);
68935: }
68935: 
68935: inline const js::Value &
68935: JSObject::nativeGetSlot(uintN slot) const
68935: {
68935:     JS_ASSERT(isNative());
86009:     JS_ASSERT(slot < slotSpan());
68935:     return getSlot(slot);
68935: }
68935: 
83221: inline JSFunction *
83221: JSObject::nativeGetMethod(const js::Shape *shape) const
83221: {
83221:     /*
83221:      * For method shapes, this object must have an uncloned function object in
83221:      * the shape's slot.
83221:      */
83221:     JS_ASSERT(shape->isMethod());
83221: #ifdef DEBUG
83221:     JSObject *obj = &nativeGetSlot(shape->slot()).toObject();
83234:     JS_ASSERT(obj->isFunction() && !obj->toFunction()->isClonedMethod());
83221: #endif
83221: 
83229:     return static_cast<JSFunction *>(&nativeGetSlot(shape->slot()).toObject());
83221: }
83221: 
68935: inline void
68935: JSObject::nativeSetSlot(uintN slot, const js::Value &value)
68935: {
68935:     JS_ASSERT(isNative());
86009:     JS_ASSERT(slot < slotSpan());
68935:     return setSlot(slot, value);
68935: }
68935: 
77343: inline void
77343: JSObject::nativeSetSlotWithType(JSContext *cx, const js::Shape *shape, const js::Value &value)
77343: {
83221:     nativeSetSlot(shape->slot(), value);
83221:     js::types::AddTypePropertyId(cx, this, shape->propid(), value);
77343: }
77343: 
68935: inline bool
68935: JSObject::isNative() const
68935: {
83231:     return lastProperty()->isNative();
68935: }
68935: 
68935: inline bool
78194: JSObject::nativeContains(JSContext *cx, jsid id)
68935: {
78194:     return nativeLookup(cx, id) != NULL;
68935: }
68935: 
68935: inline bool
78194: JSObject::nativeContains(JSContext *cx, const js::Shape &shape)
68935: {
83221:     return nativeLookup(cx, shape.propid()) == &shape;
68935: }
68935: 
68935: inline bool
68935: JSObject::nativeEmpty() const
68935: {
68935:     return lastProperty()->isEmptyShape();
68935: }
68935: 
68935: inline bool
68935: JSObject::inDictionaryMode() const
68935: {
68935:     return lastProperty()->inDictionary();
68935: }
68935: 
84755: inline uint32_t
68935: JSObject::propertyCount() const
68935: {
68935:     return lastProperty()->entryCount();
68935: }
68935: 
68935: inline bool
68935: JSObject::hasPropertyTable() const
68935: {
68935:     return lastProperty()->hasTable();
68935: }
68935: 
83231: inline size_t
88142: JSObject::sizeOfThis() const
68935: {
83321:     return arenaHeader()->getThingSize();
68935: }
68935: 
83231: inline size_t
88142: JSObject::computedSizeOfIncludingThis() const
68935: {
88142:     size_t slotsSize, elementsSize;
88142:     sizeOfExcludingThis(NULL, &slotsSize, &elementsSize);
88142:     return sizeOfThis() + slotsSize + elementsSize;
83322: }
83322: 
88142: inline void
88142: JSObject::sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf,
88142:                               size_t *slotsSize, size_t *elementsSize) const
83322: {
83322:     if (hasDynamicSlots()) {
88142:         size_t computedSize = numDynamicSlots() * sizeof(js::Value);
88300:         *slotsSize = mallocSizeOf ? mallocSizeOf(slots) : computedSize;
88142:     } else {
88142:         *slotsSize = 0;
83322:     }
83322:     if (hasDynamicElements()) {
88142:         size_t computedSize =
83336:             (js::ObjectElements::VALUES_PER_HEADER +
83336:              getElementsHeader()->capacity) * sizeof(js::Value);
88142:         *elementsSize =
88300:             mallocSizeOf ? mallocSizeOf(getElementsHeader()) : computedSize;
88142:     } else {
88142:         *elementsSize = 0;
83322:     }
68935: }
68935: 
78329: inline JSBool
80442: JSObject::lookupGeneric(JSContext *cx, jsid id, JSObject **objp, JSProperty **propp)
80442: {
80442:     js::LookupGenericOp op = getOps()->lookupGeneric;
80442:     return (op ? op : js_LookupProperty)(cx, this, id, objp, propp);
80442: }
80442: 
80442: inline JSBool
80442: JSObject::lookupProperty(JSContext *cx, js::PropertyName *name, JSObject **objp, JSProperty **propp)
80442: {
80442:     return lookupGeneric(cx, ATOM_TO_JSID(name), objp, propp);
80442: }
80442: 
80442: inline JSBool
80624: JSObject::defineGeneric(JSContext *cx, jsid id, const js::Value &value,
80624:                         JSPropertyOp getter /* = JS_PropertyStub */,
80624:                         JSStrictPropertyOp setter /* = JS_StrictPropertyStub */,
80624:                         uintN attrs /* = JSPROP_ENUMERATE */)
80624: {
80624:     js::DefineGenericOp op = getOps()->defineGeneric;
80624:     return (op ? op : js_DefineProperty)(cx, this, id, &value, getter, setter, attrs);
80624: }
80624: 
80624: inline JSBool
80624: JSObject::defineProperty(JSContext *cx, js::PropertyName *name, const js::Value &value,
80624:                         JSPropertyOp getter /* = JS_PropertyStub */,
80624:                         JSStrictPropertyOp setter /* = JS_StrictPropertyStub */,
80624:                         uintN attrs /* = JSPROP_ENUMERATE */)
80624: {
80624:     return defineGeneric(cx, ATOM_TO_JSID(name), value, getter, setter, attrs);
80624: }
80624: 
80624: inline JSBool
84755: JSObject::defineElement(JSContext *cx, uint32_t index, const js::Value &value,
80624:                         JSPropertyOp getter /* = JS_PropertyStub */,
80624:                         JSStrictPropertyOp setter /* = JS_StrictPropertyStub */,
80624:                         uintN attrs /* = JSPROP_ENUMERATE */)
80624: {
80624:     js::DefineElementOp op = getOps()->defineElement;
80624:     return (op ? op : js_DefineElement)(cx, this, index, &value, getter, setter, attrs);
80624: }
80624: 
80624: inline JSBool
80624: JSObject::defineSpecial(JSContext *cx, js::SpecialId sid, const js::Value &value,
80624:                         JSPropertyOp getter /* = JS_PropertyStub */,
80624:                         JSStrictPropertyOp setter /* = JS_StrictPropertyStub */,
80624:                         uintN attrs /* = JSPROP_ENUMERATE */)
80624: {
80624:     return defineGeneric(cx, SPECIALID_TO_JSID(sid), value, getter, setter, attrs);
80624: }
80624: 
80624: inline JSBool
84755: JSObject::lookupElement(JSContext *cx, uint32_t index, JSObject **objp, JSProperty **propp)
78329: {
78330:     js::LookupElementOp op = getOps()->lookupElement;
78330:     return (op ? op : js_LookupElement)(cx, this, index, objp, propp);
78329: }
78329: 
78329: inline JSBool
80442: JSObject::lookupSpecial(JSContext *cx, js::SpecialId sid, JSObject **objp, JSProperty **propp)
80442: {
80442:     return lookupGeneric(cx, SPECIALID_TO_JSID(sid), objp, propp);
80442: }
80442: 
80442: inline JSBool
84755: JSObject::getElement(JSContext *cx, JSObject *receiver, uint32_t index, js::Value *vp)
78329: {
81391:     js::ElementIdOp op = getOps()->getElement;
81391:     if (op)
81391:         return op(cx, this, receiver, index, vp);
81391: 
78329:     jsid id;
78329:     if (!js::IndexToId(cx, index, &id))
78329:         return false;
78675:     return getGeneric(cx, receiver, id, vp);
78329: }
78329: 
78329: inline JSBool
84755: JSObject::getElement(JSContext *cx, uint32_t index, js::Value *vp)
78329: {
81391:     return getElement(cx, this, index, vp);
78329: }
78329: 
78329: inline JSBool
84755: JSObject::getElementIfPresent(JSContext *cx, JSObject *receiver, uint32_t index, js::Value *vp,
81416:                               bool *present)
81416: {
81417:     js::ElementIfPresentOp op = getOps()->getElementIfPresent;
81417:     if (op)
81417:         return op(cx, this, receiver, index, vp, present);
81417: 
81416:     /* For now, do the index-to-id conversion just once, then use
81416:      * lookupGeneric/getGeneric.  Once lookupElement and getElement stop both
81416:      * doing index-to-id conversions, we can use those here.
81416:      */
81416:     jsid id;
81416:     if (!js::IndexToId(cx, index, &id))
81416:         return false;
81416: 
81416:     JSObject *obj2;
81416:     JSProperty *prop;
81416:     if (!lookupGeneric(cx, id, &obj2, &prop))
81416:         return false;
81416: 
81416:     if (!prop) {
81416:         *present = false;
81416:         js::Debug_SetValueRangeToCrashOnTouch(vp, 1);
81416:         return true;
81416:     }
81416: 
81416:     *present = true;
81416:     return getGeneric(cx, receiver, id, vp);
81416: }
81416: 
81416: inline JSBool
86536: JSObject::getSpecial(JSContext *cx, JSObject *receiver, js::SpecialId sid, js::Value *vp)
78672: {
86536:     return getGeneric(cx, receiver, SPECIALID_TO_JSID(sid), vp);
78672: }
78672: 
80622: inline JSBool
80622: JSObject::getGenericAttributes(JSContext *cx, jsid id, uintN *attrsp)
80622: {
80622:     js::GenericAttributesOp op = getOps()->getGenericAttributes;
80622:     return (op ? op : js_GetAttributes)(cx, this, id, attrsp);    
80622: }
80622: 
80622: inline JSBool
80622: JSObject::getPropertyAttributes(JSContext *cx, js::PropertyName *name, uintN *attrsp)
80622: {
80622:     return getGenericAttributes(cx, ATOM_TO_JSID(name), attrsp);
80622: }
80622: 
80622: inline JSBool
84755: JSObject::getElementAttributes(JSContext *cx, uint32_t index, uintN *attrsp)
80622: {
80622:     jsid id;
80622:     if (!js::IndexToId(cx, index, &id))
80622:         return false;
80622:     return getGenericAttributes(cx, id, attrsp);
80622: }
80622: 
80622: inline JSBool
80622: JSObject::getSpecialAttributes(JSContext *cx, js::SpecialId sid, uintN *attrsp)
80622: {
80622:     return getGenericAttributes(cx, SPECIALID_TO_JSID(sid), attrsp);
80622: }
80622: 
79734: inline bool
79734: JSObject::isProxy() const
79734: {
79734:     return js::IsProxy(this);
79734: }
79734: 
79734: inline bool
79734: JSObject::isCrossCompartmentWrapper() const
79734: {
79734:     return js::IsCrossCompartmentWrapper(this);
79734: }
79734: 
79734: inline bool
79734: JSObject::isWrapper() const
79734: {
79734:     return js::IsWrapper(this);
79734: }
79734: 
86483: inline js::GlobalObject &
86483: JSObject::global() const
83276: {
83276:     JSObject *obj = const_cast<JSObject *>(this);
83287:     while (JSObject *parent = obj->getParent())
83276:         obj = parent;
83276:     return obj->asGlobal();
83276: }
83276: 
52503: static inline bool
52503: js_IsCallable(const js::Value &v)
52503: {
52503:     return v.isObject() && v.toObject().isCallable();
37685: }
37685: 
40388: namespace js {
40388: 
83227: inline void
83227: OBJ_TO_INNER_OBJECT(JSContext *cx, JSObject *&obj)
83227: {
83227:     if (JSObjectOp op = obj->getClass()->ext.innerObject)
83227:         obj = op(cx, obj);
83227: }
83227: 
83227: inline void
83227: OBJ_TO_OUTER_OBJECT(JSContext *cx, JSObject *&obj)
83227: {
83227:     if (JSObjectOp op = obj->getClass()->ext.outerObject)
83227:         obj = op(cx, obj);
83227: }
83227: 
83227: /*
83227:  * Methods to test whether an object or a value is of type "xml" (per typeof).
83227:  */
83227: 
83227: #define VALUE_IS_XML(v)      (!JSVAL_IS_PRIMITIVE(v) && JSVAL_TO_OBJECT(v)->isXML())
83227: 
83227: static inline bool
83227: IsXML(const js::Value &v)
83227: {
83227:     return v.isObject() && v.toObject().isXML();
83227: }
83227: 
83227: static inline bool
83227: IsStopIteration(const js::Value &v)
83227: {
83227:     return v.isObject() && v.toObject().isStopIteration();
83227: }
83227: 
83227: /* ES5 9.1 ToPrimitive(input). */
83227: static JS_ALWAYS_INLINE bool
83227: ToPrimitive(JSContext *cx, Value *vp)
83227: {
83227:     if (vp->isPrimitive())
83227:         return true;
83227:     return vp->toObject().defaultValue(cx, JSTYPE_VOID, vp);
83227: }
83227: 
83227: /* ES5 9.1 ToPrimitive(input, PreferredType). */
83227: static JS_ALWAYS_INLINE bool
83227: ToPrimitive(JSContext *cx, JSType preferredType, Value *vp)
83227: {
83227:     JS_ASSERT(preferredType != JSTYPE_VOID); /* Use the other ToPrimitive! */
83227:     if (vp->isPrimitive())
83227:         return true;
83227:     return vp->toObject().defaultValue(cx, preferredType, vp);
83227: }
83227: 
83227: /*
83227:  * Return true if this is a compiler-created internal function accessed by
83227:  * its own object. Such a function object must not be accessible to script
83227:  * or embedding code.
83227:  */
83227: inline bool
83227: IsInternalFunctionObject(JSObject *funobj)
83227: {
83234:     JSFunction *fun = funobj->toFunction();
83234:     return (fun->flags & JSFUN_LAMBDA) && !funobj->getParent();
83227: }
83227: 
48470: class AutoPropDescArrayRooter : private AutoGCRooter
40388: {
40388:   public:
48470:     AutoPropDescArrayRooter(JSContext *cx)
80748:       : AutoGCRooter(cx, DESCRIPTORS), descriptors(cx)
40388:     { }
40388: 
48470:     PropDesc *append() {
48470:         if (!descriptors.append(PropDesc()))
40388:             return NULL;
40388:         return &descriptors.back();
40388:     }
40388: 
48470:     PropDesc& operator[](size_t i) {
40388:         JS_ASSERT(i < descriptors.length());
40388:         return descriptors[i];
40388:     }
40388: 
80748:     friend void AutoGCRooter::trace(JSTracer *trc);
80748: 
80744:   private:
48470:     PropDescArray descriptors;
40388: };
40388: 
48470: class AutoPropertyDescriptorRooter : private AutoGCRooter, public PropertyDescriptor
42733: {
42733:   public:
80748:     AutoPropertyDescriptorRooter(JSContext *cx) : AutoGCRooter(cx, DESCRIPTOR) {
42733:         obj = NULL;
42733:         attrs = 0;
62395:         getter = (PropertyOp) NULL;
62395:         setter = (StrictPropertyOp) NULL;
48470:         value.setUndefined();
42733:     }
42733: 
52503:     AutoPropertyDescriptorRooter(JSContext *cx, PropertyDescriptor *desc)
80748:       : AutoGCRooter(cx, DESCRIPTOR)
52503:     {
47498:         obj = desc->obj;
47498:         attrs = desc->attrs;
47498:         getter = desc->getter;
47498:         setter = desc->setter;
47498:         value = desc->value;
47498:     }
47498: 
80748:     friend void AutoGCRooter::trace(JSTracer *trc);
42733: };
42733: 
83313: inline bool
83313: NewObjectCache::lookup(Class *clasp, gc::Cell *key, gc::AllocKind kind, EntryIndex *pentry)
83313: {
86976:     uintptr_t hash = (uintptr_t(clasp) ^ uintptr_t(key)) + kind;
83313:     *pentry = hash % js::ArrayLength(entries);
83313: 
83313:     Entry *entry = &entries[*pentry];
83313: 
83313:     /* N.B. Lookups with the same clasp/key but different kinds map to different entries. */
83313:     return (entry->clasp == clasp && entry->key == key);
83313: }
83313: 
83313: inline bool
83313: NewObjectCache::lookupProto(Class *clasp, JSObject *proto, gc::AllocKind kind, EntryIndex *pentry)
83313: {
83313:     JS_ASSERT(!proto->isGlobal());
83313:     return lookup(clasp, proto, kind, pentry);
83313: }
83313: 
83313: inline bool
83313: NewObjectCache::lookupGlobal(Class *clasp, js::GlobalObject *global, gc::AllocKind kind, EntryIndex *pentry)
83313: {
83313:     return lookup(clasp, global, kind, pentry);
83313: }
83313: 
83313: inline bool
83313: NewObjectCache::lookupType(Class *clasp, js::types::TypeObject *type, gc::AllocKind kind, EntryIndex *pentry)
83313: {
83313:     return lookup(clasp, type, kind, pentry);
83313: }
83313: 
83276: inline void
83313: NewObjectCache::fill(EntryIndex entry_, Class *clasp, gc::Cell *key, gc::AllocKind kind, JSObject *obj)
40858: {
83313:     JS_ASSERT(unsigned(entry_) < ArrayLength(entries));
83313:     Entry *entry = &entries[entry_];
83313: 
83276:     JS_ASSERT(!obj->hasDynamicSlots() && !obj->hasDynamicElements());
40858: 
83313:     entry->clasp = clasp;
83313:     entry->key = key;
83313:     entry->kind = kind;
40858: 
88142:     entry->nbytes = obj->sizeOfThis();
87623:     js_memcpy(&entry->templateObject, obj, entry->nbytes);
83313: }
83313: 
83313: inline void
83313: NewObjectCache::fillProto(EntryIndex entry, Class *clasp, JSObject *proto, gc::AllocKind kind, JSObject *obj)
83313: {
83313:     JS_ASSERT(!proto->isGlobal());
83313:     JS_ASSERT(obj->getProto() == proto);
83313:     return fill(entry, clasp, proto, kind, obj);
83313: }
83313: 
83313: inline void
83313: NewObjectCache::fillGlobal(EntryIndex entry, Class *clasp, js::GlobalObject *global, gc::AllocKind kind, JSObject *obj)
83313: {
83318:     //JS_ASSERT(global == obj->getGlobal());
83313:     return fill(entry, clasp, global, kind, obj);
83313: }
83313: 
83313: inline void
83313: NewObjectCache::fillType(EntryIndex entry, Class *clasp, js::types::TypeObject *type, gc::AllocKind kind, JSObject *obj)
83313: {
83313:     JS_ASSERT(obj->type() == type);
83313:     return fill(entry, clasp, type, kind, obj);
83276: }
40858: 
83276: inline JSObject *
83313: NewObjectCache::newObjectFromHit(JSContext *cx, EntryIndex entry_)
83276: {
83313:     JS_ASSERT(unsigned(entry_) < ArrayLength(entries));
83313:     Entry *entry = &entries[entry_];
83313: 
83276:     JSObject *obj = js_TryNewGCObject(cx, entry->kind);
83276:     if (obj) {
87623:         js_memcpy(obj, &entry->templateObject, entry->nbytes);
83276:         Probes::createObject(cx, obj);
83276:         return obj;
83276:     }
40858: 
83276:     /* Copy the entry to the stack first in case it is purged by a GC. */
83276:     size_t nbytes = entry->nbytes;
86437:     char stackObject[sizeof(JSObject_Slots16)];
86437:     JS_ASSERT(nbytes <= sizeof(stackObject));
87623:     js_memcpy(&stackObject, &entry->templateObject, nbytes);
40858: 
86437:     JSObject *baseobj = (JSObject *) stackObject;
86437:     RootShape shapeRoot(cx, (Shape **) baseobj->addressOfShape());
86437:     RootTypeObject typeRoot(cx, (types::TypeObject **) baseobj->addressOfType());
86437: 
83276:     obj = js_NewGCObject(cx, entry->kind);
83276:     if (obj) {
87623:         js_memcpy(obj, baseobj, nbytes);
83276:         Probes::createObject(cx, obj);
83276:         return obj;
83276:     }
83276: 
82129:     return NULL;
40858: }
40858: 
68896: static inline bool
77775: CanBeFinalizedInBackground(gc::AllocKind kind, Class *clasp)
68896: {
69651: #ifdef JS_THREADSAFE
82138:     JS_ASSERT(kind <= gc::FINALIZE_OBJECT_LAST);
68896:     /* If the class has no finalizer or a finalizer that is safe to call on
68896:      * a different thread, we change the finalize kind. For example,
68896:      * FINALIZE_OBJECT0 calls the finalizer on the main thread,
68896:      * FINALIZE_OBJECT0_BACKGROUND calls the finalizer on the gcHelperThread.
77775:      * IsBackgroundAllocKind is called to prevent recursively incrementing
77343:      * the finalize kind; kind may already be a background finalize kind.
68896:      */
83223:     if (!gc::IsBackgroundAllocKind(kind) && !clasp->finalize)
68896:         return true;
69651: #endif
68896:     return false;
68896: }
68896: 
47497: /*
83275:  * Make an object with the specified prototype. If parent is null, it will
83275:  * default to the prototype's global if the prototype is non-null.
47497:  */
83275: JSObject *
83275: NewObjectWithGivenProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
83275:                         gc::AllocKind kind);
83275: 
83275: inline JSObject *
83275: NewObjectWithGivenProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent)
47497: {
83275:     gc::AllocKind kind = gc::GetGCObjectKind(clasp);
83275:     return NewObjectWithGivenProto(cx, clasp, proto, parent, kind);
83275: }
47497: 
83275: inline JSProtoKey
83275: GetClassProtoKey(js::Class *clasp)
83275: {
83275:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
83275:     if (key != JSProto_Null)
83275:         return key;
83275:     if (clasp->flags & JSCLASS_IS_ANONYMOUS)
83275:         return JSProto_Object;
83275:     return JSProto_Null;
83275: }
83275: 
83275: inline bool
86437: FindProto(JSContext *cx, js::Class *clasp, HandleObject parent, JSObject **proto)
83275: {
83275:     JSProtoKey protoKey = GetClassProtoKey(clasp);
83275:     if (!js_GetClassPrototype(cx, parent, protoKey, proto, clasp))
83275:         return false;
83275:     if (!(*proto) && !js_GetClassPrototype(cx, parent, JSProto_Object, proto))
83275:         return false;
83275:     return true;
83275: }
77343: 
47497: /*
83275:  * Make an object with the prototype set according to the specified prototype or class:
83275:  *
83275:  * if proto is non-null:
83275:  *   use the specified proto
83275:  * for a built-in class:
83275:  *   use the memoized original value of the class constructor .prototype
83275:  *   property object
83275:  * else if available
83275:  *   the current value of .prototype
83275:  * else
83275:  *   Object.prototype.
83275:  *
83275:  * The class prototype will be fetched from the parent's global. If global is
83275:  * null, the context's active global will be used, and the resulting object's
83275:  * parent will be that global.
47497:  */
83276: JSObject *
83275: NewObjectWithClassProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
83276:                         gc::AllocKind kind);
68896: 
83275: inline JSObject *
83275: NewObjectWithClassProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent)
83275: {
83275:     gc::AllocKind kind = gc::GetGCObjectKind(clasp);
83275:     return NewObjectWithClassProto(cx, clasp, proto, parent, kind);
47497: }
47497: 
80557: /*
83275:  * Create a native instance of the given class with parent and proto set
83275:  * according to the context's active global.
80557:  */
83275: inline JSObject *
83275: NewBuiltinClassInstance(JSContext *cx, Class *clasp, gc::AllocKind kind)
83275: {
83275:     return NewObjectWithClassProto(cx, clasp, NULL, NULL, kind);
47497: }
47497: 
83275: inline JSObject *
83275: NewBuiltinClassInstance(JSContext *cx, Class *clasp)
55746: {
83233:     gc::AllocKind kind = gc::GetGCObjectKind(clasp);
83275:     return NewBuiltinClassInstance(cx, clasp, kind);
55746: }
55746: 
80803: inline GlobalObject *
80803: GetCurrentGlobal(JSContext *cx)
80803: {
80803:     JSObject *scopeChain = (cx->hasfp()) ? &cx->fp()->scopeChain() : cx->globalObject;
86483:     return scopeChain ? &scopeChain->global() : NULL;
80803: }
80803: 
47497: bool
47497: FindClassPrototype(JSContext *cx, JSObject *scope, JSProtoKey protoKey, JSObject **protop,
48470:                    Class *clasp);
47497: 
47497: /*
77343:  * Create a plain object with the specified type. This bypasses getNewType to
77343:  * avoid losing creation site information for objects made by scripted 'new'.
77343:  */
83275: JSObject *
83275: NewObjectWithType(JSContext *cx, types::TypeObject *type, JSObject *parent, gc::AllocKind kind);
83275: 
83275: /* Make an object with pregenerated shape from a NEWOBJECT bytecode. */
80557: static inline JSObject *
83275: CopyInitializerObject(JSContext *cx, JSObject *baseobj, types::TypeObject *type)
77343: {
83275:     JS_ASSERT(baseobj->getClass() == &ObjectClass);
83275:     JS_ASSERT(!baseobj->inDictionaryMode());
77392: 
83275:     gc::AllocKind kind = gc::GetGCObjectFixedSlotsKind(baseobj->numFixedSlots());
83275: #ifdef JS_THREADSAFE
83275:     kind = gc::GetBackgroundAllocKind(kind);
83275: #endif
83275:     JS_ASSERT(kind == baseobj->getAllocKind());
83275:     JSObject *obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
77428: 
77343:     if (!obj)
80557:         return NULL;
77343: 
83275:     obj->setType(type);
77343: 
83275:     if (!obj->setLastProperty(cx, baseobj->lastProperty()))
83275:         return NULL;
77343: 
77343:     return obj;
77343: }
77343: 
83275: JSObject *
77392: NewReshapedObject(JSContext *cx, js::types::TypeObject *type, JSObject *parent,
77775:                   gc::AllocKind kind, const Shape *shape);
77343: 
77343: /*
61705:  * As for gc::GetGCObjectKind, where numSlots is a guess at the final size of
77343:  * the object, zero if the final size is unknown. This should only be used for
77343:  * objects that do not require any fixed slots.
55746:  */
77775: static inline gc::AllocKind
83231: GuessObjectGCKind(size_t numSlots)
55746: {
55746:     if (numSlots)
83231:         return gc::GetGCObjectKind(numSlots);
83231:     return gc::FINALIZE_OBJECT4;
83231: }
83231: 
83231: static inline gc::AllocKind
83231: GuessArrayGCKind(size_t numSlots)
83231: {
83231:     if (numSlots)
83231:         return gc::GetGCArrayKind(numSlots);
83231:     return gc::FINALIZE_OBJECT8;
55746: }
55746: 
55746: /*
55746:  * Get the GC kind to use for scripted 'new' on the given class.
55746:  * FIXME bug 547327: estimate the size from the allocation site.
55746:  */
77775: static inline gc::AllocKind
55746: NewObjectGCKind(JSContext *cx, js::Class *clasp)
55746: {
77817:     if (clasp == &ArrayClass || clasp == &SlowArrayClass)
55746:         return gc::FINALIZE_OBJECT8;
77817:     if (clasp == &FunctionClass)
55746:         return gc::FINALIZE_OBJECT2;
55746:     return gc::FINALIZE_OBJECT4;
40858: }
40858: 
83275: /*
83275:  * Fill slots with the initial slot array to use for a newborn object which
83314:  * may or may not need dynamic slots.
83275:  */
83275: inline bool
83314: PreallocateObjectDynamicSlots(JSContext *cx, Shape *shape, HeapValue **slots)
69242: {
83314:     if (size_t count = JSObject::dynamicSlotsCount(shape->numFixedSlots(), shape->slotSpan())) {
83301:         *slots = (HeapValue *) cx->malloc_(count * sizeof(HeapValue));
83275:         if (!*slots)
83275:             return false;
83275:         Debug_SetValueRangeToCrashOnTouch(*slots, count);
83275:         return true;
69242:     }
83275:     *slots = NULL;
83275:     return true;
58056: }
58056: 
64377: inline bool
73996: DefineConstructorAndPrototype(JSContext *cx, GlobalObject *global,
75063:                               JSProtoKey key, JSObject *ctor, JSObject *proto)
64377: {
64377:     JS_ASSERT(!global->nativeEmpty()); /* reserved slots already allocated */
64377:     JS_ASSERT(ctor);
64377:     JS_ASSERT(proto);
64377: 
64377:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
78194:     JS_ASSERT(!global->nativeLookup(cx, id));
64377: 
77343:     /* Set these first in case AddTypePropertyId looks for this class. */
69237:     global->setSlot(key, ObjectValue(*ctor));
69237:     global->setSlot(key + JSProto_LIMIT, ObjectValue(*proto));
86437:     global->setSlot(key + JSProto_LIMIT * 2, ObjectValue(*ctor));
77343: 
77353:     types::AddTypePropertyId(cx, global, id, ObjectValue(*ctor));
77343:     if (!global->addDataProperty(cx, id, key + JSProto_LIMIT * 2, 0)) {
77343:         global->setSlot(key, UndefinedValue());
77343:         global->setSlot(key + JSProto_LIMIT, UndefinedValue());
86437:         global->setSlot(key + JSProto_LIMIT * 2, UndefinedValue());
77343:         return false;
77343:     }
77343: 
64377:     return true;
64377: }
64377: 
76240: bool
76240: PropDesc::checkGetter(JSContext *cx)
76240: {
76223:     if (hasGet && !js_IsCallable(get) && !get.isUndefined()) {
76223:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
76223:                              js_getter_str);
76223:         return false;
76223:     }
76223:     return true;
76223: }
76223: 
76240: bool
76240: PropDesc::checkSetter(JSContext *cx)
76240: {
76223:     if (hasSet && !js_IsCallable(set) && !set.isUndefined()) {
76223:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
76223:                              js_setter_str);
76223:         return false;
76223:     }
76223:     return true;
76223: }
76223: 
79389: namespace detail {
79389: 
79389: template<typename T> class PrimitiveBehavior { };
79389: 
79389: template<>
79389: class PrimitiveBehavior<JSString *> {
79389:   public:
79389:     static inline bool isType(const Value &v) { return v.isString(); }
79389:     static inline JSString *extract(const Value &v) { return v.toString(); }
79389:     static inline Class *getClass() { return &StringClass; }
79389: };
79389: 
79389: template<>
79389: class PrimitiveBehavior<bool> {
79389:   public:
79389:     static inline bool isType(const Value &v) { return v.isBoolean(); }
79389:     static inline bool extract(const Value &v) { return v.toBoolean(); }
79389:     static inline Class *getClass() { return &BooleanClass; }
79389: };
79389: 
79389: template<>
79389: class PrimitiveBehavior<double> {
79389:   public:
79389:     static inline bool isType(const Value &v) { return v.isNumber(); }
79389:     static inline double extract(const Value &v) { return v.toNumber(); }
79389:     static inline Class *getClass() { return &NumberClass; }
79389: };
79389: 
79389: } /* namespace detail */
79389: 
79389: inline JSObject *
79779: NonGenericMethodGuard(JSContext *cx, CallArgs args, Native native, Class *clasp, bool *ok)
79389: {
79389:     const Value &thisv = args.thisv();
79389:     if (thisv.isObject()) {
79389:         JSObject &obj = thisv.toObject();
79391:         if (obj.getClass() == clasp) {
79391:             *ok = true;  /* quell gcc overwarning */
79389:             return &obj;
79389:         }
79391:     }
79389: 
79779:     *ok = HandleNonGenericMethodClassMismatch(cx, args, native, clasp);
79389:     return NULL;
79389: }
79389: 
79389: template <typename T>
79389: inline bool
79779: BoxedPrimitiveMethodGuard(JSContext *cx, CallArgs args, Native native, T *v, bool *ok)
79389: {
79389:     typedef detail::PrimitiveBehavior<T> Behavior;
79389: 
79389:     const Value &thisv = args.thisv();
79389:     if (Behavior::isType(thisv)) {
79389:         *v = Behavior::extract(thisv);
79389:         return true;
79389:     }
79389: 
79779:     if (!NonGenericMethodGuard(cx, args, native, Behavior::getClass(), ok))
79389:         return false;
79389: 
79389:     *v = Behavior::extract(thisv.toObject().getPrimitiveThis());
79389:     return true;
79389: }
79389: 
79390: inline bool
79390: ObjectClassIs(JSObject &obj, ESClassValue classValue, JSContext *cx)
79390: {
79390:     if (JS_UNLIKELY(obj.isProxy()))
79418:         return Proxy::objectClassIs(&obj, classValue, cx);
79390: 
79390:     switch (classValue) {
79390:       case ESClass_Array: return obj.isArray();
79390:       case ESClass_Number: return obj.isNumber();
79390:       case ESClass_String: return obj.isString();
79390:       case ESClass_Boolean: return obj.isBoolean();
79390:     }
79390:     JS_NOT_REACHED("bad classValue");
79390:     return false;
79390: }
79390: 
79816: static JS_ALWAYS_INLINE bool
79816: ValueIsSpecial(JSObject *obj, Value *propval, SpecialId *sidp, JSContext *cx)
79816: {
79816:     if (!propval->isObject())
79816:         return false;
79816: 
79816: #if JS_HAS_XML_SUPPORT
79816:     if (obj->isXML()) {
79816:         *sidp = SpecialId(propval->toObject());
79816:         return true;
79816:     }
79816: 
79816:     JSObject &propobj = propval->toObject();
79816:     JSAtom *name;
79816:     if (propobj.isQName() && GetLocalNameFromFunctionQName(&propobj, &name, cx)) {
79816:         propval->setString(name);
79816:         return false;
79816:     }
79816: #endif
79816: 
79816:     return false;
79816: }
79816: 
83262: JSObject *
86437: DefineConstructorAndPrototype(JSContext *cx, HandleObject obj, JSProtoKey key, HandleAtom atom,
83262:                               JSObject *protoProto, Class *clasp,
83262:                               Native constructor, uintN nargs,
83262:                               JSPropertySpec *ps, JSFunctionSpec *fs,
83262:                               JSPropertySpec *static_ps, JSFunctionSpec *static_fs,
83262:                               JSObject **ctorp = NULL,
83262:                               gc::AllocKind ctorKind = JSFunction::FinalizeKind);
83262: 
47497: } /* namespace js */
40388: 
83262: extern JSObject *
86437: js_InitClass(JSContext *cx, js::HandleObject obj, JSObject *parent_proto,
83262:              js::Class *clasp, JSNative constructor, uintN nargs,
83262:              JSPropertySpec *ps, JSFunctionSpec *fs,
83262:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs,
83262:              JSObject **ctorp = NULL,
83262:              js::gc::AllocKind ctorKind = JSFunction::FinalizeKind);
83262: 
87822: inline JSObject *
87822: js_GetProtoIfDenseArray(JSObject *obj)
87822: {
87822:     return obj->isDenseArray() ? obj->getProto() : obj;
87822: }
87822: 
83248: /*
83248:  * js_PurgeScopeChain does nothing if obj is not itself a prototype or parent
83248:  * scope, else it reshapes the scope and prototype chains it links. It calls
83248:  * js_PurgeScopeChainHelper, which asserts that obj is flagged as a delegate
83248:  * (i.e., obj has ever been on a prototype or parent chain).
83248:  */
83248: extern bool
83248: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id);
83248: 
83248: inline bool
83248: js_PurgeScopeChain(JSContext *cx, JSObject *obj, jsid id)
83248: {
83248:     if (obj->isDelegate())
83248:         return js_PurgeScopeChainHelper(cx, obj, id);
83248:     return true;
83248: }
83248: 
82129: inline void
82129: JSObject::setSlot(uintN slot, const js::Value &value)
82129: {
83301:     JS_ASSERT(slotInRange(slot));
82129:     getSlotRef(slot).set(compartment(), value);
82129: }
82129: 
82129: inline void
82129: JSObject::initSlot(uintN slot, const js::Value &value)
82129: {
82129:     JS_ASSERT(getSlot(slot).isUndefined() || getSlot(slot).isMagic(JS_ARRAY_HOLE));
83304:     JS_ASSERT(slotInRange(slot));
82129:     initSlotUnchecked(slot, value);
82129: }
82129: 
82129: inline void
82129: JSObject::initSlotUnchecked(uintN slot, const js::Value &value)
82129: {
83304:     getSlotAddressUnchecked(slot)->init(value);
82129: }
82129: 
82129: inline void
82129: JSObject::setFixedSlot(uintN slot, const js::Value &value)
82129: {
82129:     JS_ASSERT(slot < numFixedSlots());
82129:     fixedSlots()[slot] = value;
82129: }
82129: 
82129: inline void
82129: JSObject::initFixedSlot(uintN slot, const js::Value &value)
82129: {
82129:     JS_ASSERT(slot < numFixedSlots());
82129:     fixedSlots()[slot].init(value);
82129: }
82129: 
82129: inline void
82129: JSObject::privateWriteBarrierPre(void **old)
82129: {
82129: #ifdef JSGC_INCREMENTAL
82129:     JSCompartment *comp = compartment();
82129:     if (comp->needsBarrier()) {
83302:         if (*old && getClass()->trace)
83302:             getClass()->trace(comp->barrierTracer(), this);
82129:     }
82129: #endif
82129: }
82129: 
82129: inline void
82129: JSObject::privateWriteBarrierPost(void **old)
82129: {
82129: }
82129: 
82129: inline void
82129: JSObject::writeBarrierPre(JSObject *obj)
82129: {
82129: #ifdef JSGC_INCREMENTAL
82129:     /*
82129:      * This would normally be a null test, but TypeScript::global uses 0x1 as a
82129:      * special value.
82129:      */
82129:     if (uintptr_t(obj) < 32)
82129:         return;
82129: 
82129:     JSCompartment *comp = obj->compartment();
82129:     if (comp->needsBarrier()) {
82129:         JS_ASSERT(!comp->rt->gcRunning);
82129:         MarkObjectUnbarriered(comp->barrierTracer(), obj, "write barrier");
82129:     }
82129: #endif
82129: }
82129: 
82129: inline void
82129: JSObject::writeBarrierPost(JSObject *obj, void *addr)
82129: {
82129: }
82129: 
35117: #endif /* jsobjinlines_h___ */
