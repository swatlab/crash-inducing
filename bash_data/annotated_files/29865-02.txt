29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
25100:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS object implementation.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsbit.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jshash.h" /* Added by JSIFY */
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
25215: #include "jsdbgapi.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: #include "jsiter.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058: #include "jsdtracef.h"
 7058: #endif
 7058: 
15453: #include "jsautooplen.h"
15453: 
    1: #ifdef JS_THREADSAFE
    1: #define NATIVE_DROP_PROPERTY js_DropProperty
    1: 
    1: extern void
    1: js_DropProperty(JSContext *cx, JSObject *obj, JSProperty *prop);
    1: #else
    1: #define NATIVE_DROP_PROPERTY NULL
    1: #endif
    1: 
    1: JS_FRIEND_DATA(JSObjectOps) js_ObjectOps = {
28353:     NULL,
    1:     js_LookupProperty,      js_DefineProperty,
    1:     js_GetProperty,         js_SetProperty,
    1:     js_GetAttributes,       js_SetAttributes,
    1:     js_DeleteProperty,      js_DefaultValue,
    1:     js_Enumerate,           js_CheckAccess,
    1:     NULL,                   NATIVE_DROP_PROPERTY,
    1:     js_Call,                js_Construct,
26828:     js_HasInstance,         js_TraceObject,
26828:     js_Clear,               js_GetRequiredSlot,
26828:     js_SetRequiredSlot
    1: };
    1: 
    1: JSClass js_ObjectClass = {
    1:     js_Object_str,
    1:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
    1:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   JS_FinalizeStub,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
    1: #if JS_HAS_OBJ_PROTO_PROP
    1: 
    1: static JSBool
    1: obj_getSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSBool
    1: obj_setSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSBool
    1: obj_getCount(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSPropertySpec object_props[] = {
    1:     /* These two must come first; see object_props[slot].name usage below. */
    1:     {js_proto_str, JSSLOT_PROTO, JSPROP_PERMANENT|JSPROP_SHARED,
    1:                                                   obj_getSlot,  obj_setSlot},
    1:     {js_parent_str,JSSLOT_PARENT,JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED,
    1:                                                   obj_getSlot,  obj_setSlot},
18669:     {js_count_str, 0,            JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED,
18669:                                                   obj_getCount, NULL},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: /* NB: JSSLOT_PROTO and JSSLOT_PARENT are already indexes into object_props. */
    1: #define JSSLOT_COUNT 2
    1: 
    1: static JSBool
    1: ReportStrictSlot(JSContext *cx, uint32 slot)
    1: {
    1:     if (slot == JSSLOT_PROTO)
    1:         return JS_TRUE;
    1:     return JS_ReportErrorFlagsAndNumber(cx,
    1:                                         JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                         js_GetErrorMessage, NULL,
    1:                                         JSMSG_DEPRECATED_USAGE,
    1:                                         object_props[slot].name);
    1: }
    1: 
    1: static JSBool
    1: obj_getSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     uint32 slot;
    1:     jsid propid;
    1:     JSAccessMode mode;
    1:     uintN attrs;
    1:     JSObject *pobj;
    1:     JSClass *clasp;
    1: 
    1:     slot = (uint32) JSVAL_TO_INT(id);
    1:     if (id == INT_TO_JSVAL(JSSLOT_PROTO)) {
    1:         propid = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
    1:         mode = JSACC_PROTO;
    1:     } else {
    1:         propid = ATOM_TO_JSID(cx->runtime->atomState.parentAtom);
    1:         mode = JSACC_PARENT;
    1:     }
    1: 
    1:     /* Let OBJ_CHECK_ACCESS get the slot's value, based on the access mode. */
    1:     if (!OBJ_CHECK_ACCESS(cx, obj, propid, mode, vp, &attrs))
    1:         return JS_FALSE;
    1: 
    1:     pobj = JSVAL_TO_OBJECT(*vp);
    1:     if (pobj) {
    1:         clasp = OBJ_GET_CLASS(cx, pobj);
    1:         if (clasp == &js_CallClass || clasp == &js_BlockClass) {
    1:             /* Censor activations and lexical scopes per ECMA-262. */
    1:             *vp = JSVAL_NULL;
27539:         } else {
27539:             /*
27539:              * DeclEnv only exists as a parent for a Call object which we
27539:              * censor. So it cannot escape to scripts.
27539:              */
27539:             JS_ASSERT(clasp != &js_DeclEnvClass);
27539:             if (pobj->map->ops->thisObject) {
25521:                 pobj = pobj->map->ops->thisObject(cx, pobj);
    1:                 if (!pobj)
    1:                     return JS_FALSE;
    1:                 *vp = OBJECT_TO_JSVAL(pobj);
    1:             }
    1:         }
27539:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: obj_setSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSObject *pobj;
    1:     uint32 slot;
    1:     jsid propid;
    1:     uintN attrs;
    1: 
    1:     if (!JSVAL_IS_OBJECT(*vp))
    1:         return JS_TRUE;
    1:     pobj = JSVAL_TO_OBJECT(*vp);
    1: 
    1:     if (pobj) {
    1:         /*
    1:          * Innerize pobj here to avoid sticking unwanted properties on the
    1:          * outer object. This ensures that any with statements only grant
    1:          * access to the inner object.
    1:          */
    1:         OBJ_TO_INNER_OBJECT(cx, pobj);
    1:         if (!pobj)
    1:             return JS_FALSE;
    1:     }
    1:     slot = (uint32) JSVAL_TO_INT(id);
    1:     if (JS_HAS_STRICT_OPTION(cx) && !ReportStrictSlot(cx, slot))
    1:         return JS_FALSE;
    1: 
    1:     /* __parent__ is readonly and permanent, only __proto__ may be set. */
    1:     propid = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
 3164:     if (!OBJ_CHECK_ACCESS(cx, obj, propid,
 3164:                           (JSAccessMode)(JSACC_PROTO|JSACC_WRITE), vp,
 3164:                           &attrs)) {
    1:         return JS_FALSE;
 3164:     }
    1: 
28003:     return js_SetProtoOrParent(cx, obj, slot, pobj, JS_TRUE);
    1: }
    1: 
    1: static JSBool
    1: obj_getCount(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsval iter_state;
    1:     jsid num_properties;
    1:     JSBool ok;
    1: 
    1:     if (JS_HAS_STRICT_OPTION(cx) && !ReportStrictSlot(cx, JSSLOT_COUNT))
    1:         return JS_FALSE;
    1: 
    1:     /* Get the number of properties to enumerate. */
    1:     iter_state = JSVAL_NULL;
    1:     ok = OBJ_ENUMERATE(cx, obj, JSENUMERATE_INIT, &iter_state, &num_properties);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     if (!JSVAL_IS_INT(num_properties)) {
    1:         JS_ASSERT(0);
    1:         *vp = JSVAL_ZERO;
    1:         goto out;
    1:     }
    1:     *vp = num_properties;
    1: 
    1: out:
    1:     if (iter_state != JSVAL_NULL)
    1:         ok = OBJ_ENUMERATE(cx, obj, JSENUMERATE_DESTROY, &iter_state, 0);
    1:     return ok;
    1: }
    1: 
    1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: #define object_props NULL
    1: 
    1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: JSBool
28003: js_SetProtoOrParent(JSContext *cx, JSObject *obj, uint32 slot, JSObject *pobj,
28003:                     JSBool checkForCycles)
    1: {
28003:     JS_ASSERT(slot == JSSLOT_PARENT || slot == JSSLOT_PROTO);
28005:     JS_ASSERT_IF(!checkForCycles, obj != pobj);
28003: 
28003:     if (slot == JSSLOT_PROTO) {
28831:         if (OBJ_IS_NATIVE(obj)) {
28310:             JS_LOCK_OBJ(cx, obj);
28003:             bool ok = !!js_GetMutableScope(cx, obj);
28003:             JS_UNLOCK_OBJ(cx, obj);
28003:             if (!ok)
28003:                 return JS_FALSE;
28831:         }
28003: 
28003:         /*
28003:          * Regenerate property cache shape ids for all of the scopes along the
28003:          * old prototype chain to invalidate their property cache entries, in
28003:          * case any entries were filled by looking up starting from obj.
28003:          */
28935:         JSObject *oldproto = obj;
28003:         while (oldproto && OBJ_IS_NATIVE(oldproto)) {
28003:             JS_LOCK_OBJ(cx, oldproto);
28003:             JSScope *scope = OBJ_SCOPE(oldproto);
28003:             js_MakeScopeShapeUnique(cx, scope);
28003:             JSObject *tmp = STOBJ_GET_PROTO(scope->object);
28003:             JS_UNLOCK_OBJ(cx, oldproto);
28003:             oldproto = tmp;
28003:         }
28003:     }
28003: 
28003:     if (!pobj || !checkForCycles) {
28003:         if (slot == JSSLOT_PROTO)
28003:             STOBJ_SET_PROTO(obj, pobj);
28003:         else
28003:             STOBJ_SET_PARENT(obj, pobj);
28003:     } else {
28003:         /*
28003:          * Use the GC machinery to serialize access to all objects on the
28003:          * prototype or parent chain.
28003:          */
11041:         JSSetSlotRequest ssr;
11041:         ssr.obj = obj;
11041:         ssr.pobj = pobj;
11041:         ssr.slot = (uint16) slot;
28003:         ssr.cycle = false;
28003: 
28003:         JSRuntime *rt = cx->runtime;
11041:         JS_LOCK_GC(rt);
11041:         ssr.next = rt->setSlotRequests;
11041:         rt->setSlotRequests = &ssr;
16099:         for (;;) {
11041:             js_GC(cx, GC_SET_SLOT_REQUEST);
11041:             JS_UNLOCK_GC(rt);
16099:             if (!rt->setSlotRequests)
16099:                 break;
16099:             JS_LOCK_GC(rt);
16099:         }
11041: 
28003:         if (ssr.cycle) {
28003:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28003:                                  JSMSG_CYCLIC_VALUE,
    1: #if JS_HAS_OBJ_PROTO_PROP
    1:                                  object_props[slot].name
    1: #else
    1:                                  (slot == JSSLOT_PROTO) ? js_proto_str
    1:                                                         : js_parent_str
    1: #endif
    1:                                  );
    1:             return JS_FALSE;
    1:         }
28003:     }
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSHashNumber
    1: js_hash_object(const void *key)
    1: {
    1:     return (JSHashNumber)JS_PTR_TO_UINT32(key) >> JSVAL_TAGBITS;
    1: }
    1: 
    1: static JSHashEntry *
    1: MarkSharpObjects(JSContext *cx, JSObject *obj, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSHashNumber hash;
    1:     JSHashEntry **hep, *he;
    1:     jsatomid sharpid;
    1:     JSIdArray *ida;
    1:     JSBool ok;
    1:     jsint i, length;
    1:     jsid id;
    1: #if JS_HAS_GETTER_SETTER
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1: #endif
    1:     jsval val;
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     map = &cx->sharpObjectMap;
23915:     JS_ASSERT(map->depth >= 1);
    1:     table = map->table;
    1:     hash = js_hash_object(obj);
    1:     hep = JS_HashTableRawLookup(table, hash, obj);
    1:     he = *hep;
    1:     if (!he) {
    1:         sharpid = 0;
    1:         he = JS_HashTableRawAdd(table, hep, hash, obj,
    1:                                 JS_UINT32_TO_PTR(sharpid));
    1:         if (!he) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1: 
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         ok = JS_TRUE;
    1:         for (i = 0, length = ida->length; i < length; i++) {
    1:             id = ida->vector[i];
    1: #if JS_HAS_GETTER_SETTER
    1:             ok = OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!prop)
    1:                 continue;
    1:             ok = OBJ_GET_ATTRIBUTES(cx, obj2, id, prop, &attrs);
    1:             if (ok) {
    1:                 if (OBJ_IS_NATIVE(obj2) &&
    1:                     (attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
25218:                     JSScopeProperty *sprop = (JSScopeProperty *) prop;
    1:                     val = JSVAL_NULL;
    1:                     if (attrs & JSPROP_GETTER)
25218:                         val = js_CastAsObjectJSVal(sprop->getter);
    1:                     if (attrs & JSPROP_SETTER) {
    1:                         if (val != JSVAL_NULL) {
    1:                             /* Mark the getter, then set val to setter. */
    1:                             ok = (MarkSharpObjects(cx, JSVAL_TO_OBJECT(val),
    1:                                                    NULL)
    1:                                   != NULL);
    1:                         }
25218:                         val = js_CastAsObjectJSVal(sprop->setter);
    1:                     }
    1:                 } else {
    1:                     ok = OBJ_GET_PROPERTY(cx, obj, id, &val);
    1:                 }
    1:             }
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1: #else
    1:             ok = OBJ_GET_PROPERTY(cx, obj, id, &val);
    1: #endif
    1:             if (!ok)
    1:                 break;
    1:             if (!JSVAL_IS_PRIMITIVE(val) &&
    1:                 !MarkSharpObjects(cx, JSVAL_TO_OBJECT(val), NULL)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:         if (!ok || !idap)
    1:             JS_DestroyIdArray(cx, ida);
    1:         if (!ok)
    1:             return NULL;
    1:     } else {
    1:         sharpid = JS_PTR_TO_UINT32(he->value);
    1:         if (sharpid == 0) {
    1:             sharpid = ++map->sharpgen << SHARP_ID_SHIFT;
    1:             he->value = JS_UINT32_TO_PTR(sharpid);
    1:         }
    1:         ida = NULL;
    1:     }
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: }
    1: 
    1: JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSIdArray *ida;
    1:     JSHashNumber hash;
    1:     JSHashEntry *he, **hep;
    1:     jsatomid sharpid;
    1:     char buf[20];
    1:     size_t len;
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return NULL;
    1: 
    1:     /* Set to null in case we return an early error. */
    1:     *sp = NULL;
    1:     map = &cx->sharpObjectMap;
    1:     table = map->table;
    1:     if (!table) {
    1:         table = JS_NewHashTable(8, js_hash_object, JS_CompareValues,
    1:                                 JS_CompareValues, NULL, NULL);
    1:         if (!table) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         map->table = table;
    1:         JS_KEEP_ATOMS(cx->runtime);
    1:     }
    1: 
    1:     /* From this point the control must flow either through out: or bad:. */
    1:     ida = NULL;
    1:     if (map->depth == 0) {
23915:         /*
23915:          * Although MarkSharpObjects tries to avoid invoking getters,
23915:          * it ends up doing so anyway under some circumstances; for
23915:          * example, if a wrapped object has getters, the wrapper will
23915:          * prevent MarkSharpObjects from recognizing them as such.
23915:          * This could lead to js_LeaveSharpObject being called while
23915:          * MarkSharpObjects is still working.
23915:          *
23915:          * Increment map->depth while we call MarkSharpObjects, to
23915:          * ensure that such a call doesn't free the hash table we're
23915:          * still using.
23915:          */
23915:         ++map->depth;
    1:         he = MarkSharpObjects(cx, obj, &ida);
23915:         --map->depth;
    1:         if (!he)
    1:             goto bad;
    1:         JS_ASSERT((JS_PTR_TO_UINT32(he->value) & SHARP_BIT) == 0);
    1:         if (!idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             ida = NULL;
    1:         }
    1:     } else {
    1:         hash = js_hash_object(obj);
    1:         hep = JS_HashTableRawLookup(table, hash, obj);
    1:         he = *hep;
    1: 
    1:         /*
    1:          * It's possible that the value of a property has changed from the
    1:          * first time the object's properties are traversed (when the property
    1:          * ids are entered into the hash table) to the second (when they are
    1:          * converted to strings), i.e., the OBJ_GET_PROPERTY() call is not
    1:          * idempotent.
    1:          */
    1:         if (!he) {
    1:             he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
    1:             if (!he) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 goto bad;
    1:             }
    1:             sharpid = 0;
    1:             goto out;
    1:         }
    1:     }
    1: 
    1:     sharpid = JS_PTR_TO_UINT32(he->value);
    1:     if (sharpid != 0) {
    1:         len = JS_snprintf(buf, sizeof buf, "#%u%c",
    1:                           sharpid >> SHARP_ID_SHIFT,
    1:                           (sharpid & SHARP_BIT) ? '#' : '=');
    1:         *sp = js_InflateString(cx, buf, &len);
    1:         if (!*sp) {
    1:             if (ida)
    1:                 JS_DestroyIdArray(cx, ida);
    1:             goto bad;
    1:         }
    1:     }
    1: 
    1: out:
    1:     JS_ASSERT(he);
    1:     if ((sharpid & SHARP_BIT) == 0) {
    1:         if (idap && !ida) {
    1:             ida = JS_Enumerate(cx, obj);
    1:             if (!ida) {
    1:                 if (*sp) {
    1:                     JS_free(cx, *sp);
    1:                     *sp = NULL;
    1:                 }
    1:                 goto bad;
    1:             }
    1:         }
    1:         map->depth++;
    1:     }
    1: 
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: 
    1: bad:
    1:     /* Clean up the sharpObjectMap table on outermost error. */
    1:     if (map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSIdArray *ida;
    1: 
    1:     map = &cx->sharpObjectMap;
    1:     JS_ASSERT(map->depth > 0);
    1:     if (--map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     if (idap) {
    1:         ida = *idap;
    1:         if (ida) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             *idap = NULL;
    1:         }
    1:     }
    1: }
    1: 
18907: static intN
    1: gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
    1: {
  583:     JS_CALL_OBJECT_TRACER((JSTracer *)arg, (JSObject *)he->key,
  583:                           "sharp table entry");
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
    1: {
    1:     JS_ASSERT(map->depth > 0);
    1:     JS_ASSERT(map->table);
    1: 
    1:     /*
    1:      * During recursive calls to MarkSharpObjects a non-native object or
    1:      * object with a custom getProperty method can potentially return an
    1:      * unrooted value or even cut from the object graph an argument of one of
    1:      * MarkSharpObjects recursive invocations. So we must protect map->table
    1:      * entries against GC.
    1:      *
    1:      * We can not simply use JSTempValueRooter to mark the obj argument of
    1:      * MarkSharpObjects during recursion as we have to protect *all* entries
    1:      * in JSSharpObjectMap including those that contains otherwise unreachable
    1:      * objects just allocated through custom getProperty. Otherwise newer
    1:      * allocations can re-use the address of an object stored in the hashtable
    1:      * confusing js_EnterSharpObject. So to address the problem we simply
    1:      * mark all objects from map->table.
    1:      *
    1:      * An alternative "proper" solution is to use JSTempValueRooter in
    1:      * MarkSharpObjects with code to remove during finalization entries
    1:      * with otherwise unreachable objects. But this is way too complex
    1:      * to justify spending efforts.
    1:      */
  583:     JS_HashTableEnumerateEntries(map->table, gc_sharp_table_entry_marker, trc);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
 4127: static JSBool
 4127: obj_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSBool ok, outermost;
 4127:     JSObject *obj;
    1:     JSHashEntry *he;
    1:     JSIdArray *ida;
    1:     jschar *chars, *ochars, *vsharp;
    1:     const jschar *idstrchars, *vchars;
    1:     size_t nchars, idstrlength, gsoplength, vlength, vsharplength, curlen;
16069:     const char *comma;
    1:     jsint i, j, length, valcnt;
    1:     jsid id;
    1: #if JS_HAS_GETTER_SETTER
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1: #endif
    1:     jsval *val;
 6917:     jsval localroot[4] = {JSVAL_NULL, JSVAL_NULL, JSVAL_NULL, JSVAL_NULL};
 6917:     JSTempValueRooter tvr;
 1490:     JSString *gsopold[2];
    1:     JSString *gsop[2];
    1:     JSString *idstr, *valstr, *str;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
18989:     MUST_FLOW_THROUGH("out");
 6917:     JS_PUSH_TEMP_ROOT(cx, 4, localroot, &tvr);
    1: 
    1:     /* If outermost, we need parentheses to be an expression, not a block. */
    1:     outermost = (cx->sharpObjectMap.depth == 0);
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !(he = js_EnterSharpObject(cx, obj, &ida, &chars))) {
 6917:         ok = JS_FALSE;
 6917:         goto out;
 6917:     }
    1:     if (IS_SHARP(he)) {
    1:         /*
    1:          * We didn't enter -- obj is already "sharp", meaning we've visited it
    1:          * already in our depth first search, and therefore chars contains a
    1:          * string of the form "#n#".
    1:          */
    1:         JS_ASSERT(!ida);
    1: #if JS_HAS_SHARP_VARS
    1:         nchars = js_strlen(chars);
    1: #else
    1:         chars[0] = '{';
    1:         chars[1] = '}';
    1:         chars[2] = 0;
    1:         nchars = 2;
    1: #endif
    1:         goto make_string;
    1:     }
    1:     JS_ASSERT(ida);
    1:     ok = JS_TRUE;
    1: 
    1:     if (!chars) {
    1:         /* If outermost, allocate 4 + 1 for "({})" and the terminator. */
    1:         chars = (jschar *) malloc(((outermost ? 4 : 2) + 1) * sizeof(jschar));
    1:         nchars = 0;
    1:         if (!chars)
    1:             goto error;
    1:         if (outermost)
    1:             chars[nchars++] = '(';
    1:     } else {
    1:         /* js_EnterSharpObject returned a string of the form "#n=" in chars. */
    1:         MAKE_SHARP(he);
    1:         nchars = js_strlen(chars);
    1:         chars = (jschar *)
    1:             realloc((ochars = chars), (nchars + 2 + 1) * sizeof(jschar));
    1:         if (!chars) {
    1:             free(ochars);
    1:             goto error;
    1:         }
    1:         if (outermost) {
    1:             /*
    1:              * No need for parentheses around the whole shebang, because #n=
    1:              * unambiguously begins an object initializer, and never a block
    1:              * statement.
    1:              */
    1:             outermost = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '{';
    1: 
    1:     comma = NULL;
    1: 
    1:     /*
    1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
 6917:      * "localroot + 2" out of the loop using the val local, which refers to
 6917:      * the raw (unconverted, "uncooked") values.
    1:      */
 6917:     val = localroot + 2;
    1: 
    1:     for (i = 0, length = ida->length; i < length; i++) {
  969:         JSBool idIsLexicalIdentifier, needOldStyleGetterSetter;
  969: 
 4127:         /* Get strings for id and value and GC-root them via vp. */
    1:         id = ida->vector[i];
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:         ok = OBJ_LOOKUP_PROPERTY(cx, obj, id, &obj2, &prop);
    1:         if (!ok)
    1:             goto error;
  969: #endif
  969: 
  969:         /*
  969:          * Convert id to a jsval and then to a string.  Decide early whether we
  969:          * prefer get/set or old getter/setter syntax.
  969:          */
  969:         idstr = js_ValueToString(cx, ID_TO_VALUE(id));
  969:         if (!idstr) {
  969:             ok = JS_FALSE;
  969:             OBJ_DROP_PROPERTY(cx, obj2, prop);
  969:             goto error;
  969:         }
 4127:         *vp = STRING_TO_JSVAL(idstr);                   /* local root */
  969:         idIsLexicalIdentifier = js_IsIdentifier(idstr);
  969:         needOldStyleGetterSetter =
  969:             !idIsLexicalIdentifier ||
29366:             js_CheckKeyword(idstr->chars(), idstr->length()) != TOK_EOF;
  969: 
  969: #if JS_HAS_GETTER_SETTER
  969: 
    1:         valcnt = 0;
    1:         if (prop) {
    1:             ok = OBJ_GET_ATTRIBUTES(cx, obj2, id, prop, &attrs);
    1:             if (!ok) {
    1:                 OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:                 goto error;
    1:             }
    1:             if (OBJ_IS_NATIVE(obj2) &&
    1:                 (attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
25218:                 JSScopeProperty *sprop = (JSScopeProperty *) prop;
    1:                 if (attrs & JSPROP_GETTER) {
25218:                     val[valcnt] = js_CastAsObjectJSVal(sprop->getter);
 1490:                     gsopold[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.getterAtom);
    1:                     gsop[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.getAtom);
 1677: 
 1677:                     valcnt++;
    1:                 }
    1:                 if (attrs & JSPROP_SETTER) {
25218:                     val[valcnt] = js_CastAsObjectJSVal(sprop->setter);
 1490:                     gsopold[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.setterAtom);
    1:                     gsop[valcnt] =
 1490:                         ATOM_TO_STRING(cx->runtime->atomState.setAtom);
 1677: 
    1:                     valcnt++;
 1677:                 }
    1:             } else {
    1:                 valcnt = 1;
    1:                 gsop[0] = NULL;
 1490:                 gsopold[0] = NULL;
    1:                 ok = OBJ_GET_PROPERTY(cx, obj, id, &val[0]);
    1:             }
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         }
    1: 
    1: #else  /* !JS_HAS_GETTER_SETTER */
    1: 
  969:         /*
  969:          * We simplify the source code at the price of minor dead code bloat in
18863:          * the ECMA version (for testing only, see jsversion.h).  The null
  969:          * default values in gsop[j] suffice to disable non-ECMA getter and
  969:          * setter code.
  969:          */
    1:         valcnt = 1;
    1:         gsop[0] = NULL;
 1490:         gsopold[0] = NULL;
    1:         ok = OBJ_GET_PROPERTY(cx, obj, id, &val[0]);
    1: 
    1: #endif /* !JS_HAS_GETTER_SETTER */
    1: 
    1:         if (!ok)
    1:             goto error;
    1: 
    1:         /*
    1:          * If id is a string that's not an identifier, then it needs to be
    1:          * quoted.  Also, negative integer ids must be quoted.
    1:          */
 4529:         if (JSID_IS_ATOM(id)
  969:             ? !idIsLexicalIdentifier
 4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
    1:             idstr = js_QuoteString(cx, idstr, (jschar)'\'');
    1:             if (!idstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
 4127:             *vp = STRING_TO_JSVAL(idstr);               /* local root */
    1:         }
29366:         idstr->getCharsAndLength(idstrchars, idstrlength);
    1: 
    1:         for (j = 0; j < valcnt; j++) {
    1:             /* Convert val[j] to its canonical source form. */
    1:             valstr = js_ValueToSource(cx, val[j]);
    1:             if (!valstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
 6917:             localroot[j] = STRING_TO_JSVAL(valstr);     /* local root */
29366:             valstr->getCharsAndLength(vchars, vlength);
    1: 
 1490:             if (vchars[0] == '#')
 1490:                 needOldStyleGetterSetter = JS_TRUE;
 1490: 
 1490:             if (needOldStyleGetterSetter)
 1490:                 gsop[j] = gsopold[j];
 1490: 
    1:             /* If val[j] is a non-sharp object, consider sharpening it. */
    1:             vsharp = NULL;
    1:             vsharplength = 0;
    1: #if JS_HAS_SHARP_VARS
    1:             if (!JSVAL_IS_PRIMITIVE(val[j]) && vchars[0] != '#') {
    1:                 he = js_EnterSharpObject(cx, JSVAL_TO_OBJECT(val[j]), NULL,
    1:                                          &vsharp);
    1:                 if (!he) {
    1:                     ok = JS_FALSE;
    1:                     goto error;
    1:                 }
    1:                 if (IS_SHARP(he)) {
    1:                     vchars = vsharp;
    1:                     vlength = js_strlen(vchars);
 1490:                     needOldStyleGetterSetter = JS_TRUE;
 1490:                     gsop[j] = gsopold[j];
    1:                 } else {
    1:                     if (vsharp) {
    1:                         vsharplength = js_strlen(vsharp);
    1:                         MAKE_SHARP(he);
 1490:                         needOldStyleGetterSetter = JS_TRUE;
 1490:                         gsop[j] = gsopold[j];
    1:                     }
    1:                     js_LeaveSharpObject(cx, NULL);
    1:                 }
    1:             }
    1: #endif
    1: 
 2149: #ifndef OLD_GETTER_SETTER
 2149:             /*
 2149:              * Remove '(function ' from the beginning of valstr and ')' from the
 2149:              * end so that we can put "get" in front of the function definition.
 2149:              */
 2149:             if (gsop[j] && VALUE_IS_FUNCTION(cx, val[j]) &&
 2149:                 !needOldStyleGetterSetter) {
 2149:                 JSFunction *fun = JS_ValueToFunction(cx, val[j]);
 2149:                 const jschar *start = vchars;
 2149:                 const jschar *end = vchars + vlength;
 2149: 
 2149:                 uint8 parenChomp = 0;
 2149:                 if (vchars[0] == '(') {
 2149:                     vchars++;
 2149:                     parenChomp = 1;
 2149:                 }
 2149: 
 2149:                 /*
 2149:                  * Try to jump "getter" or "setter" keywords, if we suspect
 2149:                  * they might appear here.  This code can be confused by people
 2149:                  * defining Function.prototype.toString, so let's be cautious.
 2149:                  */
 2149:                 if (JSFUN_GETTER_TEST(fun->flags) ||
 2149:                     JSFUN_SETTER_TEST(fun->flags)) { /* skip "getter/setter" */
 2326:                     const jschar *tmp = js_strchr_limit(vchars, ' ', end);
 2326:                     if (tmp)
 2326:                         vchars = tmp + 1;
 2149:                 }
 2149: 
 2149:                 /* Try to jump "function" keyword. */
 2149:                 if (vchars)
 2149:                     vchars = js_strchr_limit(vchars, ' ', end);
 2149: 
 2149:                 if (vchars) {
 2149:                     if (*vchars == ' ')
 2149:                         vchars++;
 2149:                     vlength = end - vchars - parenChomp;
 2149:                 } else {
 2149:                     gsop[j] = NULL;
 2149:                     vchars = start;
 2149:                 }
 2149:             }
 2149: #else
 2149:             needOldStyleGetterSetter = JS_TRUE;
 2149:             gsop[j] = gsopold[j];
 2149: #endif
 2149: 
    1: #define SAFE_ADD(n)                                                          \
    1:     JS_BEGIN_MACRO                                                           \
    1:         size_t n_ = (n);                                                     \
    1:         curlen += n_;                                                        \
    1:         if (curlen < n_)                                                     \
    1:             goto overflow;                                                   \
    1:     JS_END_MACRO
    1: 
    1:             curlen = nchars;
    1:             if (comma)
    1:                 SAFE_ADD(2);
    1:             SAFE_ADD(idstrlength + 1);
    1:             if (gsop[j])
29366:                 SAFE_ADD(gsop[j]->length() + 1);
    1:             SAFE_ADD(vsharplength);
    1:             SAFE_ADD(vlength);
    1:             /* Account for the trailing null. */
    1:             SAFE_ADD((outermost ? 2 : 1) + 1);
    1: #undef SAFE_ADD
    1: 
    1:             if (curlen > (size_t)-1 / sizeof(jschar))
    1:                 goto overflow;
    1: 
    1:             /* Allocate 1 + 1 at end for closing brace and terminating 0. */
    1:             chars = (jschar *)
    1:                 realloc((ochars = chars), curlen * sizeof(jschar));
    1:             if (!chars) {
    1:                 /* Save code space on error: let JS_free ignore null vsharp. */
    1:                 JS_free(cx, vsharp);
    1:                 free(ochars);
    1:                 goto error;
    1:             }
    1: 
    1:             if (comma) {
    1:                 chars[nchars++] = comma[0];
    1:                 chars[nchars++] = comma[1];
    1:             }
    1:             comma = ", ";
    1: 
  969:             if (needOldStyleGetterSetter) {
  969:                 js_strncpy(&chars[nchars], idstrchars, idstrlength);
  969:                 nchars += idstrlength;
  969:                 if (gsop[j]) {
  969:                     chars[nchars++] = ' ';
29366:                     gsoplength = gsop[j]->length();
29366:                     js_strncpy(&chars[nchars], gsop[j]->chars(),
  969:                                gsoplength);
  969:                     nchars += gsoplength;
  969:                 }
  969:                 chars[nchars++] = ':';
  969:             } else {  /* New style "decompilation" */
    1:                 if (gsop[j]) {
29366:                     gsoplength = gsop[j]->length();
29366:                     js_strncpy(&chars[nchars], gsop[j]->chars(),
  969:                                gsoplength);
    1:                     nchars += gsoplength;
    1:                     chars[nchars++] = ' ';
    1:                 }
    1:                 js_strncpy(&chars[nchars], idstrchars, idstrlength);
    1:                 nchars += idstrlength;
  969:                 /* Extraneous space after id here will be extracted later */
    1:                 chars[nchars++] = gsop[j] ? ' ' : ':';
  969:             }
 1490: 
    1:             if (vsharplength) {
    1:                 js_strncpy(&chars[nchars], vsharp, vsharplength);
    1:                 nchars += vsharplength;
    1:             }
    1:             js_strncpy(&chars[nchars], vchars, vlength);
    1:             nchars += vlength;
    1: 
    1:             if (vsharp)
    1:                 JS_free(cx, vsharp);
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '}';
    1:     if (outermost)
    1:         chars[nchars++] = ')';
    1:     chars[nchars] = 0;
    1: 
    1:   error:
    1:     js_LeaveSharpObject(cx, &ida);
    1: 
    1:     if (!ok) {
    1:         if (chars)
    1:             free(chars);
 6917:         goto out;
    1:     }
    1: 
    1:     if (!chars) {
    1:         JS_ReportOutOfMemory(cx);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
    1:   make_string:
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
    1:         free(chars);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
 6917:     ok = JS_TRUE;
 6917:   out:
 6917:     JS_POP_TEMP_ROOT(cx, &tvr);
 6917:     return ok;
    1: 
    1:   overflow:
    1:     JS_free(cx, vsharp);
    1:     free(chars);
    1:     chars = NULL;
    1:     goto error;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
 4127: static JSBool
 4127: obj_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     JSObject *obj;
    1:     jschar *chars;
    1:     size_t nchars;
    1:     const char *clazz, *prefix;
    1:     JSString *str;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
11809:         return JS_FALSE;
12674:     obj = js_GetWrappedObject(cx, obj);
    1:     clazz = OBJ_GET_CLASS(cx, obj)->name;
    1:     nchars = 9 + strlen(clazz);         /* 9 for "[object ]" */
    1:     chars = (jschar *) JS_malloc(cx, (nchars + 1) * sizeof(jschar));
    1:     if (!chars)
    1:         return JS_FALSE;
    1: 
    1:     prefix = "[object ";
    1:     nchars = 0;
    1:     while ((chars[nchars] = (jschar)*prefix) != 0)
    1:         nchars++, prefix++;
    1:     while ((chars[nchars] = (jschar)*clazz) != 0)
    1:         nchars++, clazz++;
    1:     chars[nchars++] = ']';
    1:     chars[nchars] = 0;
    1: 
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
    1:         JS_free(cx, chars);
    1:         return JS_FALSE;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_toLocaleString(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     jsval thisv;
    1:     JSString *str;
    1: 
11809:     thisv = JS_THIS(cx, vp);
11809:     if (JSVAL_IS_NULL(thisv))
11809:         return JS_FALSE;
11809: 
11809:     str = js_ValueToString(cx, thisv);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_valueOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     *vp = JS_THIS(cx, vp);
11809:     return !JSVAL_IS_NULL(*vp);
    1: }
    1: 
23075: #ifdef JS_TRACER
23075: static jsval FASTCALL
23075: Object_p_valueOf(JSContext* cx, JSObject* obj, JSString *hint)
23075: {
23075:     return OBJECT_TO_JSVAL(obj);
23075: }
23075: #endif
23075: 
    1: /*
    1:  * Check whether principals subsumes scopeobj's principals, and return true
    1:  * if so (or if scopeobj has no principals, for backward compatibility with
    1:  * the JS API, which does not require principals), and false otherwise.
    1:  */
    1: JSBool
    1: js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
    1:                          JSPrincipals *principals, JSAtom *caller)
    1: {
18870:     JSSecurityCallbacks *callbacks;
    1:     JSPrincipals *scopePrincipals;
    1:     const char *callerstr;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
18870:         scopePrincipals = callbacks->findObjectPrincipals(cx, scopeobj);
    1:         if (!principals || !scopePrincipals ||
    1:             !principals->subsume(principals, scopePrincipals)) {
    1:             callerstr = js_AtomToPrintableString(cx, caller);
    1:             if (!callerstr)
    1:                 return JS_FALSE;
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_INDIRECT_CALL, callerstr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_CheckScopeChainValidity(JSContext *cx, JSObject *scopeobj, const char *caller)
    1: {
    1:     JSClass *clasp;
    1:     JSExtendedClass *xclasp;
    1:     JSObject *inner;
    1: 
    1:     if (!scopeobj)
    1:         goto bad;
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, scopeobj);
    1:     if (!scopeobj)
    1:         return NULL;
    1: 
    1:     inner = scopeobj;
    1: 
    1:     /* XXX This is an awful gross hack. */
    1:     while (scopeobj) {
    1:         clasp = OBJ_GET_CLASS(cx, scopeobj);
    1:         if (clasp->flags & JSCLASS_IS_EXTENDED) {
    1:             xclasp = (JSExtendedClass*)clasp;
    1:             if (xclasp->innerObject &&
    1:                 xclasp->innerObject(cx, scopeobj) != scopeobj) {
    1:                 goto bad;
    1:             }
    1:         }
    1: 
    1:         scopeobj = OBJ_GET_PARENT(cx, scopeobj);
    1:     }
    1: 
    1:     return inner;
    1: 
    1: bad:
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                          JSMSG_BAD_INDIRECT_CALL, caller);
    1:     return NULL;
    1: }
    1: 
12690: const char *
12690: js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
12690:                    JSPrincipals *principals, uintN *linenop)
12690: {
12690:     uint32 flags;
18870: #ifdef DEBUG
18870:     JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
18870: #endif
18870: 
18870:     JS_ASSERT(principals || !(callbacks  && callbacks->findObjectPrincipals));
12690:     flags = JS_GetScriptFilenameFlags(caller->script);
12690:     if ((flags & JSFILENAME_PROTECTED) &&
18472:         principals &&
12690:         strcmp(principals->codebase, "[System Principal]")) {
12690:         *linenop = 0;
12690:         return principals->codebase;
12690:     }
12690: 
25215:     jsbytecode *pc = caller->regs->pc;
25215:     if (caller->regs && js_GetOpcode(cx, caller->script, pc) == JSOP_EVAL) {
25215:         JS_ASSERT(js_GetOpcode(cx, caller->script, pc + JSOP_EVAL_LENGTH) == JSOP_LINENO);
25215:         *linenop = GET_UINT16(pc + JSOP_EVAL_LENGTH);
13504:     } else {
21685:         *linenop = js_FramePCToLineNumber(cx, caller);
13504:     }
12690:     return caller->script->filename;
12690: }
12690: 
24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
24375: # define EVAL_CACHE_CHAIN_LIMIT 4
24375: #endif
24375: 
24375: static inline JSScript **
24375: EvalCacheHash(JSContext *cx, JSString *str)
24375: {
24375:     const jschar *s;
24375:     size_t n;
24375:     uint32 h;
24375: 
29366:     str->getCharsAndLength(s, n);
24375:     if (n > 100)
24375:         n = 100;
24375:     for (h = 0; n; s++, n--)
24375:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
24375: 
24375:     h *= JS_GOLDEN_RATIO;
24375:     h >>= 32 - JS_EVAL_CACHE_SHIFT;
24375:     return &JS_SCRIPTS_TO_GC(cx)[h];
24375: }
24375: 
20408: static JSBool
20408: obj_eval(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSStackFrame *fp, *caller;
    1:     JSBool indirectCall;
24375:     uint32 tcflags;
24375:     JSPrincipals *principals;
    1:     const char *file;
    1:     uintN line;
24375:     JSString *str;
    1:     JSScript *script;
    1:     JSBool ok;
24375:     JSScript **bucket = NULL;   /* avoid GCC warning with early decl&init */
 6766: #if JS_HAS_EVAL_THIS_SCOPE
 6766:     JSObject *callerScopeChain = NULL, *callerVarObj = NULL;
 6766:     JSObject *setCallerScopeChain = NULL;
 6766:     JSBool setCallerVarObj = JS_FALSE;
 6766: #endif
    1: 
22652:     fp = js_GetTopStackFrame(cx);
22652:     caller = js_GetScriptedCaller(cx, fp);
14990:     indirectCall = (caller && caller->regs && *caller->regs->pc != JSOP_EVAL);
    1: 
 2112:     /*
25744:      * This call to js_GetWrappedObject is safe because of the security checks
25744:      * we do below. However, the control flow below is confusing, so we double
25744:      * check. There are two cases:
25744:      * - Direct call: This object is never used. So unwrapping can't hurt.
25744:      * - Indirect call: If this object isn't already the scope chain (which
25744:      *   we're guaranteed to be allowed to access) then we do a security
25744:      *   check.
25744:      */
25744:     obj = js_GetWrappedObject(cx, obj);
25744: 
25744:     /*
 2112:      * Ban all indirect uses of eval (global.foo = eval; global.foo(...)) and
 2112:      * calls that attempt to use a non-global object as the "with" object in
 2112:      * the former indirect case.
 2112:      */
25744:     {
25744:         JSObject *parent = OBJ_GET_PARENT(cx, obj);
25744:         if (indirectCall || parent) {
25744:             uintN flags = parent
 2157:                           ? JSREPORT_ERROR
 2157:                           : JSREPORT_STRICT | JSREPORT_WARNING;
 2157:             if (!JS_ReportErrorFlagsAndNumber(cx, flags, js_GetErrorMessage, NULL,
 2157:                                               JSMSG_BAD_INDIRECT_CALL,
 2157:                                               js_eval_str)) {
    1:                 return JS_FALSE;
    1:             }
 2157:         }
25744:     }
    1: 
    1:     if (!JSVAL_IS_STRING(argv[0])) {
    1:         *rval = argv[0];
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * If the caller is a lightweight function and doesn't have a variables
    1:      * object, then we need to provide one for the compiler to stick any
    1:      * declared (var) variables into.
    1:      */
25217:     if (caller && !caller->varobj && !js_GetCallObject(cx, caller))
    1:         return JS_FALSE;
    1: 
23064:     /* Accept an optional trailing argument that overrides the scope object. */
25744:     JSObject *scopeobj = NULL;
23064:     if (argc >= 2) {
23064:         if (!js_ValueToObject(cx, argv[1], &scopeobj))
    1:             return JS_FALSE;
23064:         argv[1] = OBJECT_TO_JSVAL(scopeobj);
    1:     }
    1: 
11437:     /* From here on, control must exit through label out with ok set. */
18989:     MUST_FLOW_THROUGH("out");
    1:     if (!scopeobj) {
 6766: #if JS_HAS_EVAL_THIS_SCOPE
 6766:         /* If obj.eval(str), emulate 'with (obj) eval(str)' in the caller. */
 6766:         if (indirectCall) {
 6766:             callerScopeChain = js_GetScopeChain(cx, caller);
11437:             if (!callerScopeChain) {
11437:                 ok = JS_FALSE;
11437:                 goto out;
11437:             }
 6766:             OBJ_TO_INNER_OBJECT(cx, obj);
11437:             if (!obj) {
11437:                 ok = JS_FALSE;
11437:                 goto out;
11437:             }
 6766:             if (obj != callerScopeChain) {
11437:                 ok = js_CheckPrincipalsAccess(cx, obj,
22962:                                               JS_StackFramePrincipals(cx, caller),
11437:                                               cx->runtime->atomState.evalAtom);
11437:                 if (!ok)
11437:                     goto out;
 6766: 
 6766:                 scopeobj = js_NewWithObject(cx, obj, callerScopeChain, -1);
11437:                 if (!scopeobj) {
11437:                     ok = JS_FALSE;
11437:                     goto out;
11437:                 }
 6766: 
 6766:                 /* Set fp->scopeChain too, for the compiler. */
 6766:                 caller->scopeChain = fp->scopeChain = scopeobj;
 6766: 
 6766:                 /* Remember scopeobj so we can null its private when done. */
 6766:                 setCallerScopeChain = scopeobj;
 6766:             }
 6766: 
 6766:             callerVarObj = caller->varobj;
 6766:             if (obj != callerVarObj) {
 6766:                 /* Set fp->varobj too, for the compiler. */
 6766:                 caller->varobj = fp->varobj = obj;
 6766:                 setCallerVarObj = JS_TRUE;
 6766:             }
 6766:         }
 6766: #endif
 6766: 
 2112:         /*
 2112:          * Compile using caller's current scope object.
 2112:          *
 2112:          * NB: This means that native callers (who reach this point through
 2112:          * the C API) must use the two parameter form.
 2112:          */
 2112:         if (caller) {
 2112:             scopeobj = js_GetScopeChain(cx, caller);
 6766:             if (!scopeobj) {
 6766:                 ok = JS_FALSE;
 6766:                 goto out;
 6766:             }
    1:         }
23064:     } else {
25744:         scopeobj = js_GetWrappedObject(cx, scopeobj);
25744:         OBJ_TO_INNER_OBJECT(cx, scopeobj);
25744:         if (!scopeobj) {
25744:             ok = JS_FALSE;
25744:             goto out;
25744:         }
23064:         ok = js_CheckPrincipalsAccess(cx, scopeobj,
23064:                                       JS_StackFramePrincipals(cx, caller),
23064:                                       cx->runtime->atomState.evalAtom);
23064:         if (!ok)
23064:             goto out;
23064: 
23064:         scopeobj = js_NewWithObject(cx, scopeobj,
23064:                                     JS_GetGlobalForObject(cx, scopeobj), -1);
23064:         if (!scopeobj) {
23064:             ok = JS_FALSE;
23064:             goto out;
23064:         }
23070:         argv[1] = OBJECT_TO_JSVAL(scopeobj);
    1:     }
    1: 
    1:     /* Ensure we compile this eval with the right object in the scope chain. */
    1:     scopeobj = js_CheckScopeChainValidity(cx, scopeobj, js_eval_str);
 6766:     if (!scopeobj) {
 6766:         ok = JS_FALSE;
 6766:         goto out;
 6766:     }
    1: 
24375:     tcflags = TCF_COMPILE_N_GO;
    1:     if (caller) {
27012:         tcflags |= TCF_PUT_STATIC_LEVEL(caller->script->staticLevel + 1);
 2452:         principals = JS_EvalFramePrincipals(cx, fp, caller);
12690:         file = js_ComputeFilename(cx, caller, principals, &line);
    1:     } else {
24375:         principals = NULL;
    1:         file = NULL;
    1:         line = 0;
24375:     }
24375: 
24375:     str = JSVAL_TO_STRING(argv[0]);
24375:     script = NULL;
24375: 
24375:     /* Cache local eval scripts indexed by source qualified by scope. */
24375:     bucket = EvalCacheHash(cx, str);
24375:     if (caller->fun) {
24375:         uintN count = 0;
24375:         JSScript **scriptp = bucket;
24375: 
24375:         EVAL_CACHE_METER(probe);
24375:         while ((script = *scriptp) != NULL) {
24375:             if ((script->flags & JSSF_SAVED_CALLER_FUN) &&
24375:                 script->version == cx->version &&
24375:                 (script->principals == principals ||
24375:                  (principals->subsume(principals, script->principals) &&
24375:                   script->principals->subsume(script->principals, principals)))) {
24375:                 /*
24375:                  * Get the prior (cache-filling) eval's saved caller function.
27012:                  * See JSCompiler::compileScript in jsparse.cpp.
24375:                  */
24375:                 JSFunction *fun;
24375:                 JS_GET_SCRIPT_FUNCTION(script, 0, fun);
24375: 
24375:                 if (fun == caller->fun) {
24375:                     /*
24375:                      * Get the source string passed for safekeeping in the
27012:                      * atom map by the prior eval to JSCompiler::compileScript.
24375:                      */
24375:                     JSString *src = ATOM_TO_STRING(script->atomMap.vector[0]);
24375: 
24375:                     if (src == str || js_EqualStrings(src, str)) {
24375:                         /*
24375:                          * Source matches, qualify by comparing scopeobj to the
24375:                          * COMPILE_N_GO-memoized parent of the first literal
24375:                          * function or regexp object if any. If none, then this
24375:                          * script has no compiled-in dependencies on the prior
24375:                          * eval's scopeobj.
24375:                          */
24375:                         JSObjectArray *objarray = JS_SCRIPT_OBJECTS(script);
24375:                         int i = 1;
24375:                         if (objarray->length == 1) {
24375:                             if (script->regexpsOffset != 0) {
24375:                                 objarray = JS_SCRIPT_REGEXPS(script);
24375:                                 i = 0;
24375:                             } else {
24375:                                 EVAL_CACHE_METER(noscope);
24375:                                 i = -1;
24375:                             }
24375:                         }
24375:                         if (i < 0 ||
24375:                             STOBJ_GET_PARENT(objarray->vector[i]) == scopeobj) {
24375:                             EVAL_CACHE_METER(hit);
24375:                             *scriptp = script->u.nextToGC;
24375:                             script->u.nextToGC = NULL;
24375:                             break;
24375:                         }
24375:                     }
24375:                 }
24375:             }
24375: 
24375:             if (++count == EVAL_CACHE_CHAIN_LIMIT) {
24375:                 script = NULL;
24375:                 break;
24375:             }
24375:             EVAL_CACHE_METER(step);
24375:             scriptp = &script->u.nextToGC;
24375:         }
24375:     }
24375: 
24375:     if (!script) {
27012:         script = JSCompiler::compileScript(cx, scopeobj, caller, principals, tcflags,
29366:                                            str->chars(), str->length(),
24375:                                            NULL, file, line, str);
 6766:         if (!script) {
 6766:             ok = JS_FALSE;
 6766:             goto out;
 6766:         }
24375:     }
    1: 
    1:     if (argc < 2) {
    1:         /* Execute using caller's new scope object (might be a Call object). */
    1:         if (caller)
    1:             scopeobj = caller->scopeChain;
    1:     }
    1: 
    1:     /*
    1:      * Belt-and-braces: check that the lesser of eval's principals and the
    1:      * caller's principals has access to scopeobj.
    1:      */
    1:     ok = js_CheckPrincipalsAccess(cx, scopeobj, principals,
    1:                                   cx->runtime->atomState.evalAtom);
    1:     if (ok)
    1:         ok = js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
    1: 
24375:     script->u.nextToGC = *bucket;
24375:     *bucket = script;
18316: #ifdef CHECK_SCRIPT_OWNER
18316:     script->owner = NULL;
18316: #endif
 6766: 
 6766: out:
 6766: #if JS_HAS_EVAL_THIS_SCOPE
 6766:     /* Restore OBJ_GET_PARENT(scopeobj) not callerScopeChain in case of Call. */
 6766:     if (setCallerScopeChain) {
 6766:         caller->scopeChain = callerScopeChain;
 6766:         JS_ASSERT(OBJ_GET_CLASS(cx, setCallerScopeChain) == &js_WithClass);
 6766:         JS_SetPrivate(cx, setCallerScopeChain, NULL);
 6766:     }
 6766:     if (setCallerVarObj)
 6766:         caller->varobj = callerVarObj;
 6766: #endif
    1:     return ok;
    1: }
    1: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: 
    1: static JSBool
    1: obj_watch_handler(JSContext *cx, JSObject *obj, jsval id, jsval old, jsval *nvp,
    1:                   void *closure)
    1: {
    1:     JSObject *callable;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSStackFrame *caller;
    1:     JSPrincipals *subject, *watcher;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
    1:     jsval argv[3];
    1:     JSBool ok;
    1: 
    1:     callable = (JSObject *) closure;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
    1:         /* Skip over any obj_watch_* frames between us and the real subject. */
22652:         caller = js_GetScriptedCaller(cx, NULL);
    1:         if (caller) {
    1:             /*
    1:              * Only call the watch handler if the watcher is allowed to watch
    1:              * the currently executing script.
    1:              */
18870:             watcher = callbacks->findObjectPrincipals(cx, callable);
    1:             subject = JS_StackFramePrincipals(cx, caller);
    1: 
    1:             if (watcher && subject && !watcher->subsume(watcher, subject)) {
    1:                 /* Silently don't call the watch handler. */
    1:                 return JS_TRUE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Avoid recursion on (obj, id) already being watched on cx. */
    1:     key.obj = obj;
    1:     key.id = id;
    1:     if (!js_StartResolving(cx, &key, JSRESFLAG_WATCH, &entry))
    1:         return JS_FALSE;
    1:     if (!entry)
    1:         return JS_TRUE;
    1:     generation = cx->resolvingTable->generation;
    1: 
    1:     argv[0] = id;
    1:     argv[1] = old;
    1:     argv[2] = *nvp;
    1:     ok = js_InternalCall(cx, obj, OBJECT_TO_JSVAL(callable), 3, argv, nvp);
    1:     js_StopResolving(cx, &key, JSRESFLAG_WATCH, entry, generation);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: obj_watch(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSObject *callable;
    1:     jsval userid, value;
    1:     jsid propid;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1) {
16519:         js_ReportMissingArg(cx, vp, 1);
16519:         return JS_FALSE;
16519:     }
16519: 
 4127:     callable = js_ValueToCallableObject(cx, &vp[3], 0);
    1:     if (!callable)
    1:         return JS_FALSE;
    1: 
    1:     /* Compute the unique int/atom symbol id needed by js_LookupProperty. */
 4127:     userid = vp[2];
    1:     if (!JS_ValueToId(cx, userid, &propid))
    1:         return JS_FALSE;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !OBJ_CHECK_ACCESS(cx, obj, propid, JSACC_WATCH, &value, &attrs))
    1:         return JS_FALSE;
    1:     if (attrs & JSPROP_READONLY)
    1:         return JS_TRUE;
 4127:     *vp = JSVAL_VOID;
15602: 
15602:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_MakeArraySlow(cx, obj))
15602:         return JS_FALSE;
    1:     return JS_SetWatchPoint(cx, obj, userid, obj_watch_handler, callable);
    1: }
    1: 
    1: static JSBool
 4127: obj_unwatch(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     JSObject *obj;
11809: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
11809:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
16519:     return JS_ClearWatchPoint(cx, obj, argc != 0 ? vp[2] : JSVAL_VOID,
16519:                               NULL, NULL);
    1: }
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /*
    1:  * Prototype and property query methods, to complement the 'in' and
    1:  * 'instanceof' operators.
    1:  */
    1: 
    1: /* Proposed ECMA 15.2.4.5. */
20408: static JSBool
20408: obj_hasOwnProperty(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     return obj &&
16519:            js_HasOwnPropertyHelper(cx, obj->map->ops->lookupProperty, argc, vp);
    1: }
    1: 
    1: JSBool
16519: js_HasOwnPropertyHelper(JSContext *cx, JSLookupPropOp lookup, uintN argc,
16519:                         jsval *vp)
    1: {
    1:     jsid id;
18062:     JSObject *obj;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
18062:     return obj && js_HasOwnProperty(cx, lookup, obj, id, vp);
18062: }
18062: 
18062: JSBool
18062: js_HasOwnProperty(JSContext *cx, JSLookupPropOp lookup, JSObject *obj, jsid id,
18062:                   jsval *vp)
18062: {
18062:     JSObject *obj2;
18062:     JSProperty *prop;
18062:     JSScopeProperty *sprop;
18062: 
18062:     if (!lookup(cx, obj, id, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
 4127:         *vp = JSVAL_FALSE;
    1:     } else if (obj2 == obj) {
 4127:         *vp = JSVAL_TRUE;
    1:     } else {
    1:         JSClass *clasp;
    1:         JSExtendedClass *xclasp;
 4780:         JSObject *outer;
 4780: 
 4780:         clasp = OBJ_GET_CLASS(cx, obj2);
 4780:         if (!(clasp->flags & JSCLASS_IS_EXTENDED) ||
 4780:             !(xclasp = (JSExtendedClass *) clasp)->outerObject) {
 4780:             outer = NULL;
 4780:         } else {
 4780:             outer = xclasp->outerObject(cx, obj2);
 4780:             if (!outer)
 4780:                 return JS_FALSE;
 4780:         }
 4780:         if (outer == obj) {
 4127:             *vp = JSVAL_TRUE;
 4843:         } else if (OBJ_IS_NATIVE(obj2) && OBJ_GET_CLASS(cx, obj) == clasp) {
    1:             /*
    1:              * The combination of JSPROP_SHARED and JSPROP_PERMANENT in a
    1:              * delegated property makes that property appear to be direct in
    1:              * all delegating instances of the same native class.  This hack
    1:              * avoids bloating every function instance with its own 'length'
    1:              * (AKA 'arity') property.  But it must not extend across class
    1:              * boundaries, to avoid making hasOwnProperty lie (bug 320854).
    1:              *
    1:              * It's not really a hack, of course: a permanent property can't
    1:              * be deleted, and JSPROP_SHARED means "don't allocate a slot in
    1:              * any instance, prototype or delegating".  Without a slot, and
    1:              * without the ability to remove and recreate (with differences)
    1:              * the property, there is no way to tell whether it is directly
    1:              * owned, or indirectly delegated.
    1:              */
    1:             sprop = (JSScopeProperty *)prop;
 4127:             *vp = BOOLEAN_TO_JSVAL(SPROP_IS_SHARED_PERMANENT(sprop));
    1:         } else {
 4127:             *vp = JSVAL_FALSE;
    1:         }
    1:     }
    1:     if (prop)
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
26395: static JSBool FASTCALL
20915: Object_p_hasOwnProperty(JSContext* cx, JSObject* obj, JSString *str)
20408: {
20927:     jsid id;
20408:     jsval v;
20927: 
24614:     if (!js_ValueToStringId(cx, STRING_TO_JSVAL(str), &id) ||
24614:         !js_HasOwnProperty(cx, obj->map->ops->lookupProperty, obj, id, &v)) {
27166:         js_SetBuiltinError(cx);
20927:         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
24614:     }
24614: 
20408:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
20408:     return JSVAL_TO_BOOLEAN(v);
20408: }
20408: #endif
20408: 
    1: /* Proposed ECMA 15.2.4.6. */
    1: static JSBool
 4127: obj_isPrototypeOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSBool b;
    1: 
16519:     if (!js_IsDelegate(cx, JS_THIS_OBJECT(cx, vp),
16519:                        argc != 0 ? vp[2] : JSVAL_VOID, &b)) {
    1:         return JS_FALSE;
16519:     }
 4127:     *vp = BOOLEAN_TO_JSVAL(b);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* Proposed ECMA 15.2.4.7. */
20408: static JSBool
20408: obj_propertyIsEnumerable(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
18062:     JSObject *obj;
18062: 
18062:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
18062:         return JS_FALSE;
18062: 
18062:     obj = JS_THIS_OBJECT(cx, vp);
18062:     return obj && js_PropertyIsEnumerable(cx, obj, id, vp);
18062: }
18062: 
20408: #ifdef JS_TRACER
26395: static JSBool FASTCALL
20915: Object_p_propertyIsEnumerable(JSContext* cx, JSObject* obj, JSString *str)
20408: {
20408:     jsid id = ATOM_TO_JSID(STRING_TO_JSVAL(str));
20408:     jsval v;
24614: 
24614:     if (!js_PropertyIsEnumerable(cx, obj, id, &v)) {
27166:         js_SetBuiltinError(cx);
20408:         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
24614:     }
24614: 
20408:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
20408:     return JSVAL_TO_BOOLEAN(v);
20408: }
20408: #endif
20408: 
18062: JSBool
18062: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
18062: {
18062:     JSObject *pobj;
    1:     uintN attrs;
    1:     JSProperty *prop;
    1:     JSBool ok;
    1: 
18062:     if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
    1:         return JS_FALSE;
    1: 
    1:     if (!prop) {
 4127:         *vp = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * XXX ECMA spec error compatible: return false unless hasOwnProperty.
    1:      * The ECMA spec really should be fixed so propertyIsEnumerable and the
    1:      * for..in loop agree on whether prototype properties are enumerable,
    1:      * obviously by fixing this method (not by breaking the for..in loop!).
    1:      *
    1:      * We check here for shared permanent prototype properties, which should
    1:      * be treated as if they are local to obj.  They are an implementation
    1:      * technique used to satisfy ECMA requirements; users should not be able
    1:      * to distinguish a shared permanent proto-property from a local one.
    1:      */
 4127:     if (pobj != obj &&
 4127:         !(OBJ_IS_NATIVE(pobj) &&
    1:           SPROP_IS_SHARED_PERMANENT((JSScopeProperty *)prop))) {
 4127:         OBJ_DROP_PROPERTY(cx, pobj, prop);
 4127:         *vp = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
 4127:     ok = OBJ_GET_ATTRIBUTES(cx, pobj, id, prop, &attrs);
 4127:     OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:     if (ok)
 4127:         *vp = BOOLEAN_TO_JSVAL((attrs & JSPROP_ENUMERATE) != 0);
    1:     return ok;
    1: }
    1: 
    1: #if JS_HAS_GETTER_SETTER
24145: JS_FRIEND_API(JSBool)
24145: js_obj_defineGetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fval, junk;
    1:     jsid id;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1 || JS_TypeOfValue(cx, vp[3]) != JSTYPE_FUNCTION) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_getter_str);
    1:         return JS_FALSE;
    1:     }
16519:     fval = vp[3];
    1: 
 4127:     if (!JS_ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_CheckRedeclaration(cx, obj, id, JSPROP_GETTER, NULL, NULL))
    1:         return JS_FALSE;
    1:     /*
    1:      * Getters and setters are just like watchpoints from an access
    1:      * control point of view.
    1:      */
    1:     if (!OBJ_CHECK_ACCESS(cx, obj, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     return OBJ_DEFINE_PROPERTY(cx, obj, id, JSVAL_VOID,
25218:                                js_CastAsPropertyOp(JSVAL_TO_OBJECT(fval)),
11819:                                JS_PropertyStub,
    1:                                JSPROP_ENUMERATE | JSPROP_GETTER | JSPROP_SHARED,
    1:                                NULL);
    1: }
    1: 
24145: JS_FRIEND_API(JSBool)
24145: js_obj_defineSetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fval, junk;
    1:     jsid id;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1 || JS_TypeOfValue(cx, vp[3]) != JSTYPE_FUNCTION) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_setter_str);
    1:         return JS_FALSE;
    1:     }
16519:     fval = vp[3];
    1: 
 4127:     if (!JS_ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_CheckRedeclaration(cx, obj, id, JSPROP_SETTER, NULL, NULL))
    1:         return JS_FALSE;
    1:     /*
    1:      * Getters and setters are just like watchpoints from an access
    1:      * control point of view.
    1:      */
    1:     if (!OBJ_CHECK_ACCESS(cx, obj, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     return OBJ_DEFINE_PROPERTY(cx, obj, id, JSVAL_VOID,
11819:                                JS_PropertyStub,
25218:                                js_CastAsPropertyOp(JSVAL_TO_OBJECT(fval)),
    1:                                JSPROP_ENUMERATE | JSPROP_SETTER | JSPROP_SHARED,
    1:                                NULL);
    1: }
    1: 
    1: static JSBool
 4127: obj_lookupGetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
11809:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     if (prop) {
    1:         if (OBJ_IS_NATIVE(pobj)) {
    1:             sprop = (JSScopeProperty *) prop;
    1:             if (sprop->attrs & JSPROP_GETTER)
25218:                 *vp = js_CastAsObjectJSVal(sprop->getter);
    1:         }
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_lookupSetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
11809:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     if (prop) {
    1:         if (OBJ_IS_NATIVE(pobj)) {
    1:             sprop = (JSScopeProperty *) prop;
    1:             if (sprop->attrs & JSPROP_SETTER)
25218:                 *vp = js_CastAsObjectJSVal(sprop->setter);
    1:         }
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_GETTER_SETTER */
    1: 
16380: JSBool
16380: obj_getPrototypeOf(JSContext *cx, uintN argc, jsval *vp)
16380: {
16380:     JSObject *obj;
16380:     uintN attrs;
16380: 
16519:     if (argc == 0) {
16519:         js_ReportMissingArg(cx, vp, 0);
16519:         return JS_FALSE;
16519:     }
16519: 
16380:     obj = js_ValueToNonNullObject(cx, vp[2]);
16380:     if (!obj)
16380:         return JS_FALSE;
16380:     vp[2] = OBJECT_TO_JSVAL(obj);
16380: 
16519:     return OBJ_CHECK_ACCESS(cx, obj,
16380:                             ATOM_TO_JSID(cx->runtime->atomState.protoAtom),
16380:                             JSACC_PROTO, vp, &attrs);
16380: }
16380: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: const char js_watch_str[] = "watch";
    1: const char js_unwatch_str[] = "unwatch";
    1: #endif
    1: const char js_hasOwnProperty_str[] = "hasOwnProperty";
    1: const char js_isPrototypeOf_str[] = "isPrototypeOf";
    1: const char js_propertyIsEnumerable_str[] = "propertyIsEnumerable";
    1: #if JS_HAS_GETTER_SETTER
    1: const char js_defineGetter_str[] = "__defineGetter__";
    1: const char js_defineSetter_str[] = "__defineSetter__";
    1: const char js_lookupGetter_str[] = "__lookupGetter__";
    1: const char js_lookupSetter_str[] = "__lookupSetter__";
    1: #endif
    1: 
23075: JS_DEFINE_TRCINFO_1(obj_valueOf,
23075:     (3, (static, JSVAL,     Object_p_valueOf,               CONTEXT, THIS, STRING,  0, 0)))
20930: JS_DEFINE_TRCINFO_1(obj_hasOwnProperty,
24614:     (3, (static, BOOL_FAIL, Object_p_hasOwnProperty,        CONTEXT, THIS, STRING,  0, 0)))
20930: JS_DEFINE_TRCINFO_1(obj_propertyIsEnumerable,
24614:     (3, (static, BOOL_FAIL, Object_p_propertyIsEnumerable,  CONTEXT, THIS, STRING,  0, 0)))
20408: 
    1: static JSFunctionSpec object_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
    1: #endif
16519:     JS_FN(js_toString_str,             obj_toString,                0,0),
16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
23075:     JS_TN(js_valueOf_str,              obj_valueOf,                 0,0,
23075:           obj_valueOf_trcinfo),
    1: #if JS_HAS_OBJ_WATCHPOINT
16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
    1: #endif
20408:     JS_TN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0,
20408:           obj_hasOwnProperty_trcinfo),
16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
20408:     JS_TN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0,
20408:           obj_propertyIsEnumerable_trcinfo),
    1: #if JS_HAS_GETTER_SETTER
24145:     JS_FN(js_defineGetter_str,         js_obj_defineGetter,         2,0),
24145:     JS_FN(js_defineSetter_str,         js_obj_defineSetter,         2,0),
16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
16380: static JSFunctionSpec object_static_methods[] = {
16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
16380:     JS_FS_END
16380: };
16380: 
18712: JSBool
18712: js_Object(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     if (argc == 0) {
    1:         /* Trigger logic below to construct a blank object. */
    1:         obj = NULL;
    1:     } else {
    1:         /* If argv[0] is null or undefined, obj comes back null. */
    1:         if (!js_ValueToObject(cx, argv[0], &obj))
    1:             return JS_FALSE;
    1:     }
    1:     if (!obj) {
    1:         JS_ASSERT(!argc || JSVAL_IS_NULL(argv[0]) || JSVAL_IS_VOID(argv[0]));
22652:         if (JS_IsConstructing(cx))
    1:             return JS_TRUE;
13427:         obj = js_NewObject(cx, &js_ObjectClass, NULL, NULL, 0);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:     }
    1:     *rval = OBJECT_TO_JSVAL(obj);
    1:     return JS_TRUE;
    1: }
    1: 
26822: static inline bool
28353: InitScopeForObject(JSContext* cx, JSObject* obj, JSObject* proto,
28353:                    JSObjectOps* ops)
26822: {
28353:     JS_ASSERT(OPS_IS_NATIVE(ops));
28353:     JS_ASSERT(proto == OBJ_GET_PROTO(cx, obj));
28353: 
26822:     JSClass* protoclasp;
26822:     JSClass* clasp = OBJ_GET_CLASS(cx, obj);
26822: 
26822:     /*
26822:      * Share proto's map only if it has the same JSObjectOps, and only if
26822:      * proto's class has the same private and reserved slots as obj's map
26822:      * and class have.  We assume that if prototype and object are of the
26822:      * same class, they always have the same number of computed reserved
26822:      * slots (returned via clasp->reserveSlots); otherwise, prototype and
26822:      * object classes must have the same (null or not) reserveSlots hook.
26822:      */
26822:     if (proto &&
28353:         proto->map->ops == ops &&
26822:         ((protoclasp = OBJ_GET_CLASS(cx, proto)) == clasp ||
26822:          (!((protoclasp->flags ^ clasp->flags) &
26822:             (JSCLASS_HAS_PRIVATE |
26822:              (JSCLASS_RESERVED_SLOTS_MASK << JSCLASS_RESERVED_SLOTS_SHIFT))) &&
28353:           protoclasp->reserveSlots == clasp->reserveSlots)))
26822:     {
28353:         js_HoldScope(OBJ_SCOPE(proto));
28353:         obj->map = proto->map;
26822:         return true;
26822:     }
26822: 
28353:     JSScope *scope = js_NewScope(cx, ops, clasp, obj);
28353:     if (!scope)
28353:         goto bad;
28353: 
28353:     /* Let js_NewScope set freeslot so as to reserve slots. */
28353:     JS_ASSERT(scope->freeslot >= JSSLOT_PRIVATE);
28353:     if (scope->freeslot > JS_INITIAL_NSLOTS &&
28353:         !js_ReallocSlots(cx, obj, scope->freeslot, JS_TRUE)) {
28353:         js_DestroyScope(cx, scope);
28353:         goto bad;
28353:     }
28353:     obj->map = &scope->map;
28353:     return true;
28353: 
28353:   bad:
28353:     /* Ensure that the map field is initialized for GC. */
28353:     obj->map = NULL;
26822:     return false;
26822: }
26822: 
25887: #ifdef JS_TRACER
25887: 
25887: static inline JSObject*
28086: NewNativeObject(JSContext* cx, JSClass* clasp, JSObject* proto, JSObject *parent)
25887: {
25887:     JS_ASSERT(JS_ON_TRACE(cx));
25887:     JSObject* obj = (JSObject*) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));
25887:     if (!obj)
25887:         return NULL;
25887: 
28086:     obj->classword = jsuword(clasp);
25887:     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
25887:     obj->fslots[JSSLOT_PARENT] = OBJECT_TO_JSVAL(parent);
25897:     for (unsigned i = JSSLOT_PRIVATE; i < JS_INITIAL_NSLOTS; ++i)
25887:         obj->fslots[i] = JSVAL_VOID;
25887: 
26824:     obj->dslots = NULL;
28353:     return InitScopeForObject(cx, obj, proto, &js_ObjectOps) ? obj : NULL;
25887: }
25887: 
25887: JSObject* FASTCALL
25887: js_Object_tn(JSContext* cx, JSObject* proto)
25887: {
28086:     return NewNativeObject(cx, &js_ObjectClass, proto, JSVAL_TO_OBJECT(proto->fslots[JSSLOT_PARENT]));
25887: }
25887: 
25887: JS_DEFINE_TRCINFO_1(js_Object,
25887:     (2, (extern, CONSTRUCTOR_RETRY, js_Object_tn, CONTEXT, CALLEE_PROTOTYPE, 0, 0)))
25887: 
25887: JSObject* FASTCALL
28086: js_NewInstance(JSContext *cx, JSClass *clasp, JSObject *ctor)
25887: {
25887:     JS_ASSERT(HAS_FUNCTION_CLASS(ctor));
25887: 
25887:     JSAtom *atom = cx->runtime->atomState.classPrototypeAtom;
25887: 
25887:     JSScope *scope = OBJ_SCOPE(ctor);
27893: #ifdef JS_THREADSAFE
27893:     if (scope->title.ownercx != cx)
27893:         return NULL;
27893: #endif
25887:     if (scope->object != ctor) {
25887:         scope = js_GetMutableScope(cx, ctor);
25887:         if (!scope)
25887:             return NULL;
25887:     }
25887: 
25887:     JSScopeProperty *sprop = SCOPE_GET_PROPERTY(scope, ATOM_TO_JSID(atom));
27893:     jsval pval = sprop ? STOBJ_GET_SLOT(ctor, sprop->slot) : JSVAL_HOLE;
25887: 
25887:     JSObject *proto;
25887:     if (!JSVAL_IS_PRIMITIVE(pval)) {
25887:         /* An object in ctor.prototype, let's use it as the new instance's proto. */
25887:         proto = JSVAL_TO_OBJECT(pval);
25887:     } else if (pval == JSVAL_HOLE) {
25887:         /* No ctor.prototype yet, inline and optimize fun_resolve's prototype code. */
28086:         proto = js_NewObject(cx, clasp, NULL, OBJ_GET_PARENT(cx, ctor), 0);
25887:         if (!proto)
25887:             return NULL;
25887:         if (!js_SetClassPrototype(cx, ctor, proto, JSPROP_ENUMERATE | JSPROP_PERMANENT))
25887:             return NULL;
25887:     } else {
25887:         /* Primitive value in .prototype means we use Object.prototype for proto. */
25887:         if (!js_GetClassPrototype(cx, JSVAL_TO_OBJECT(ctor->fslots[JSSLOT_PARENT]),
25887:                                   INT_TO_JSID(JSProto_Object), &proto)) {
25887:             return NULL;
25887:         }
25887:     }
25887: 
28086:     return NewNativeObject(cx, clasp, proto, JSVAL_TO_OBJECT(ctor->fslots[JSSLOT_PARENT]));
28086: }
28086: 
28086: JS_DEFINE_CALLINFO_3(extern, CONSTRUCTOR_RETRY, js_NewInstance, CONTEXT, CLASS, OBJECT, 0, 0)
25887: 
25889: #else  /* !JS_TRACER */
25889: 
25889: # define js_Object_trcinfo NULL
25889: 
25889: #endif /* !JS_TRACER */
25887: 
    1: /*
23435:  * Given pc pointing after a property accessing bytecode, return true if the
23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
23435:  * checking whether document.all is defined.
23435:  */
23435: static JS_REQUIRES_STACK JSBool
23435: Detecting(JSContext *cx, jsbytecode *pc)
23435: {
23435:     JSScript *script;
25474:     jsbytecode *endpc;
23435:     JSOp op;
23435:     JSAtom *atom;
23435: 
23435:     script = cx->fp->script;
25474:     endpc = script->code + script->length;
25215:     for (;; pc += js_CodeSpec[op].length) {
25474:         JS_ASSERT(pc < endpc);
25474: 
23435:         /* General case: a branch or equality op follows the access. */
25215:         op = js_GetOpcode(cx, script, pc);
23435:         if (js_CodeSpec[op].format & JOF_DETECTING)
23435:             return JS_TRUE;
23435: 
23435:         switch (op) {
23435:           case JSOP_NULL:
23435:             /*
23435:              * Special case #1: handle (document.all == null).  Don't sweat
23435:              * about JS1.2's revision of the equality operators here.
23435:              */
25474:             if (++pc < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
25474:                 return *pc == JSOP_EQ || *pc == JSOP_NE;
25474:             }
25474:             return JS_FALSE;
23435: 
23435:           case JSOP_NAME:
23435:             /*
23435:              * Special case #2: handle (document.all == undefined).  Don't
23435:              * worry about someone redefining undefined, which was added by
23435:              * Edition 3, so is read/write for backward compatibility.
23435:              */
23435:             GET_ATOM_FROM_BYTECODE(script, pc, 0, atom);
25474:             if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
25474:                 (pc += js_CodeSpec[op].length) < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
23435:                 return op == JSOP_EQ || op == JSOP_NE ||
23435:                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
23435:             }
23435:             return JS_FALSE;
23435: 
23435:           default:
23435:             /*
23435:              * At this point, anything but an extended atom index prefix means
23435:              * we're not detecting.
23435:              */
23435:             if (!(js_CodeSpec[op].format & JOF_INDEXBASE))
23435:                 return JS_FALSE;
23435:             break;
23435:         }
23435:     }
23435: }
23435: 
23435: /*
23435:  * Infer lookup flags from the currently executing bytecode. This does
23435:  * not attempt to infer JSRESOLVE_WITH, because the current bytecode
23435:  * does not indicate whether we are in a with statement. Return defaultFlags
23435:  * if a currently executing bytecode cannot be determined.
23435:  */
23435: static uintN
23435: InferFlags(JSContext *cx, uintN defaultFlags)
23435: {
23435:     JSStackFrame *fp;
23435:     jsbytecode *pc;
23435:     const JSCodeSpec *cs;
23435:     uint32 format;
23435:     uintN flags = 0;
23435: 
23435:     fp = js_GetTopStackFrame(cx);
23435:     if (!fp || !fp->regs)
23435:         return defaultFlags;
23435:     pc = fp->regs->pc;
25215:     cs = &js_CodeSpec[js_GetOpcode(cx, fp->script, pc)];
23435:     format = cs->format;
23435:     if (JOF_MODE(format) != JOF_NAME)
23435:         flags |= JSRESOLVE_QUALIFIED;
23435:     if ((format & (JOF_SET | JOF_FOR)) ||
23435:         (fp->flags & JSFRAME_ASSIGNING)) {
23435:         flags |= JSRESOLVE_ASSIGNING;
23435:     } else {
23435:         pc += cs->length;
25474:         if (pc < cx->fp->script->code + cx->fp->script->length && Detecting(cx, pc))
23435:             flags |= JSRESOLVE_DETECTING;
23435:     }
23435:     if (format & JOF_DECLARING)
23435:         flags |= JSRESOLVE_DECLARING;
23435:     return flags;
23435: }
23435: 
23435: /*
    1:  * ObjectOps and Class for with-statement stack objects.
    1:  */
    1: static JSBool
    1: with_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                     JSProperty **propp)
    1: {
23435:     /* Fixes bug 463997 */
23435:     uintN flags = cx->resolveFlags;
23435:     if (flags == JSRESOLVE_INFER)
23435:         flags = InferFlags(cx, flags);
23435:     flags |= JSRESOLVE_WITH;
23435:     JSAutoResolveFlags rf(cx, flags);
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_LookupProperty(cx, obj, id, objp, propp);
    1:     return OBJ_LOOKUP_PROPERTY(cx, proto, id, objp, propp);
    1: }
    1: 
    1: static JSBool
    1: with_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_GetProperty(cx, obj, id, vp);
    1:     return OBJ_GET_PROPERTY(cx, proto, id, vp);
    1: }
    1: 
    1: static JSBool
    1: with_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_SetProperty(cx, obj, id, vp);
    1:     return OBJ_SET_PROPERTY(cx, proto, id, vp);
    1: }
    1: 
    1: static JSBool
    1: with_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                    uintN *attrsp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_GetAttributes(cx, obj, id, prop, attrsp);
    1:     return OBJ_GET_ATTRIBUTES(cx, proto, id, prop, attrsp);
    1: }
    1: 
    1: static JSBool
    1: with_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                    uintN *attrsp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_SetAttributes(cx, obj, id, prop, attrsp);
    1:     return OBJ_SET_ATTRIBUTES(cx, proto, id, prop, attrsp);
    1: }
    1: 
    1: static JSBool
    1: with_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_DeleteProperty(cx, obj, id, rval);
    1:     return OBJ_DELETE_PROPERTY(cx, proto, id, rval);
    1: }
    1: 
    1: static JSBool
    1: with_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_DefaultValue(cx, obj, hint, vp);
    1:     return OBJ_DEFAULT_VALUE(cx, proto, hint, vp);
    1: }
    1: 
    1: static JSBool
    1: with_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:                jsval *statep, jsid *idp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_Enumerate(cx, obj, enum_op, statep, idp);
    1:     return OBJ_ENUMERATE(cx, proto, enum_op, statep, idp);
    1: }
    1: 
    1: static JSBool
    1: with_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                  jsval *vp, uintN *attrsp)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return js_CheckAccess(cx, obj, id, mode, vp, attrsp);
    1:     return OBJ_CHECK_ACCESS(cx, proto, id, mode, vp, attrsp);
    1: }
    1: 
    1: static JSObject *
    1: with_ThisObject(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto = OBJ_GET_PROTO(cx, obj);
    1:     if (!proto)
    1:         return obj;
    1:     return OBJ_THIS_OBJECT(cx, proto);
    1: }
    1: 
    1: JS_FRIEND_DATA(JSObjectOps) js_WithObjectOps = {
28353:     NULL,
    1:     with_LookupProperty,    js_DefineProperty,
    1:     with_GetProperty,       with_SetProperty,
    1:     with_GetAttributes,     with_SetAttributes,
    1:     with_DeleteProperty,    with_DefaultValue,
    1:     with_Enumerate,         with_CheckAccess,
    1:     with_ThisObject,        NATIVE_DROP_PROPERTY,
    1:     NULL,                   NULL,
26828:     NULL,                   js_TraceObject,
26828:     js_Clear,               NULL,
26828:     NULL
    1: };
    1: 
    1: static JSObjectOps *
    1: with_getObjectOps(JSContext *cx, JSClass *clasp)
    1: {
    1:     return &js_WithObjectOps;
    1: }
    1: 
    1: JSClass js_WithClass = {
    1:     "With",
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
    1:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   JS_FinalizeStub,
    1:     with_getObjectOps,
    1:     0,0,0,0,0,0,0
    1: };
    1: 
22652: JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth)
    1: {
    1:     JSObject *obj;
    1: 
13427:     obj = js_NewObject(cx, &js_WithClass, proto, parent, 0);
    1:     if (!obj)
    1:         return NULL;
    1:     STOBJ_SET_SLOT(obj, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(cx->fp));
    1:     OBJ_SET_BLOCK_DEPTH(cx, obj, depth);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_NewBlockObject(JSContext *cx)
    1: {
    1:     /*
    1:      * Null obj's proto slot so that Object.prototype.* does not pollute block
28093:      * scopes and to give the block object its own scope.
    1:      */
28093:     JSObject *blockObj = js_NewObjectWithGivenProto(cx, &js_BlockClass,
28093:                                                     NULL, NULL, 0);
28093:     JS_ASSERT_IF(blockObj, !OBJ_IS_CLONED_BLOCK(blockObj));
28093:     return blockObj;
    1: }
    1: 
    1: JSObject *
    1: js_CloneBlockObject(JSContext *cx, JSObject *proto, JSObject *parent,
    1:                     JSStackFrame *fp)
    1: {
    1:     JSObject *clone;
    1: 
14860:     JS_ASSERT(STOBJ_GET_CLASS(proto) == &js_BlockClass);
14860:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(proto));
13427:     clone = js_NewObject(cx, &js_BlockClass, proto, parent, 0);
    1:     if (!clone)
    1:         return NULL;
    1:     STOBJ_SET_SLOT(clone, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(fp));
    1:     STOBJ_SET_SLOT(clone, JSSLOT_BLOCK_DEPTH,
    1:                    OBJ_GET_SLOT(cx, proto, JSSLOT_BLOCK_DEPTH));
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(clone));
28093:     JS_ASSERT(OBJ_SCOPE(clone)->object == proto);
    1:     return clone;
    1: }
    1: 
22652: JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind)
    1: {
 3457:     JSStackFrame *fp;
11859:     JSObject *obj;
14860:     uintN depth, count;
14860: 
14860:     /* Blocks have one fixed slot available for the first local.*/
14860:     JS_STATIC_ASSERT(JS_INITIAL_NSLOTS == JSSLOT_BLOCK_DEPTH + 2);
 3457: 
11859:     fp = cx->fp;
11859:     obj = fp->scopeChain;
11859:     JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_BlockClass);
11859:     JS_ASSERT(OBJ_GET_PRIVATE(cx, obj) == cx->fp);
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
14860: 
14860:     /*
14860:      * Block objects should never be exposed to scripts. Thus the clone should
14860:      * not own the property map and rather always share it with the prototype
28353:      * object. This allows us to skip updating OBJ_SCOPE(obj)->freeslot after
14860:      * we copy the stack slots into reserved slots.
14860:      */
14860:     JS_ASSERT(OBJ_SCOPE(obj)->object != obj);
14860: 
14860:     /* Block objects should not have reserved slots before they are put. */
14860:     JS_ASSERT(STOBJ_NSLOTS(obj) == JS_INITIAL_NSLOTS);
14860: 
14860:     /* The block and its locals must be on the current stack for GC safety. */
 3457:     depth = OBJ_BLOCK_DEPTH(cx, obj);
14860:     count = OBJ_BLOCK_COUNT(cx, obj);
16072:     JS_ASSERT(depth <= (size_t) (fp->regs->sp - StackBase(fp)));
16072:     JS_ASSERT(count <= (size_t) (fp->regs->sp - StackBase(fp) - depth));
14860: 
14860:     /* See comments in CheckDestructuring from jsparse.c. */
14860:     JS_ASSERT(count >= 1);
14860: 
16072:     depth += fp->script->nfixed;
16072:     obj->fslots[JSSLOT_BLOCK_DEPTH + 1] = fp->slots[depth];
14860:     if (normalUnwind && count > 1) {
14860:         --count;
14860:         JS_LOCK_OBJ(cx, obj);
14860:         if (!js_ReallocSlots(cx, obj, JS_INITIAL_NSLOTS + count, JS_TRUE))
11758:             normalUnwind = JS_FALSE;
14860:         else
16072:             memcpy(obj->dslots, fp->slots + depth + 1, count * sizeof(jsval));
14860:         JS_UNLOCK_OBJ(cx, obj);
14860:     }
14860: 
11758:     /* We must clear the private slot even with errors. */
    1:     JS_SetPrivate(cx, obj, NULL);
11859:     fp->scopeChain = OBJ_GET_PARENT(cx, obj);
11758:     return normalUnwind;
    1: }
    1: 
    1: static JSBool
    1: block_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
14860:     uintN index;
    1:     JSStackFrame *fp;
14860: 
14860:     JS_ASSERT(JS_InstanceOf(cx, obj, &js_BlockClass, NULL));
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
14860:     if (!JSVAL_IS_INT(id))
14860:         return JS_TRUE;
14860: 
14860:     index = (uint16) JSVAL_TO_INT(id);
14860:     fp = (JSStackFrame *) JS_GetPrivate(cx, obj);
14860:     if (fp) {
16072:         index += fp->script->nfixed + OBJ_BLOCK_DEPTH(cx, obj);
16072:         JS_ASSERT(index < fp->script->nslots);
16072:         *vp = fp->slots[index];
14860:         return JS_TRUE;
14860:     }
14860: 
14860:     /* Reserve slots start with the first slot after the private. */
14860:     index += JSSLOT_BLOCK_DEPTH - JSSLOT_PRIVATE;
14860:     return JS_GetReservedSlot(cx, obj, index, vp);
14860: }
14860: 
14860: static JSBool
14860: block_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
14860: {
14860:     uintN index;
14860:     JSStackFrame *fp;
    1: 
    1:     JS_ASSERT(JS_InstanceOf(cx, obj, &js_BlockClass, NULL));
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1: 
14860:     index = (uint16) JSVAL_TO_INT(id);
    1:     fp = (JSStackFrame *) JS_GetPrivate(cx, obj);
14860:     if (fp) {
16072:         index += fp->script->nfixed + OBJ_BLOCK_DEPTH(cx, obj);
16072:         JS_ASSERT(index < fp->script->nslots);
16072:         fp->slots[index] = *vp;
    1:         return JS_TRUE;
14860:     }
14860: 
14860:     /* Reserve slots start with the first slot after the private. */
14860:     index += JSSLOT_BLOCK_DEPTH - JSSLOT_PRIVATE;
14860:     return JS_SetReservedSlot(cx, obj, index, *vp);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
 3235: #define NO_PARENT_INDEX ((uint32)-1)
 3235: 
 3235: uint32
 3235: FindObjectIndex(JSObjectArray *array, JSObject *obj)
    1: {
    1:     size_t i;
 3235: 
 3235:     if (array) {
 3235:         i = array->length;
 3235:         do {
 3235: 
 3235:             if (array->vector[--i] == obj)
    1:                 return i;
 3235:         } while (i != 0);
    1:     }
    1: 
    1:     return NO_PARENT_INDEX;
    1: }
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
 3235:     uint32 parentId;
    1:     JSObject *obj, *parent;
    1:     uint16 depth, count, i;
    1:     uint32 tmp;
    1:     JSTempValueRooter tvr;
    1:     JSScopeProperty *sprop;
    1:     jsid propid;
    1:     JSAtom *atom;
    1:     int16 shortid;
    1:     JSBool ok;
    1: 
    1:     cx = xdr->cx;
    1: #ifdef __GNUC__
    1:     obj = NULL;         /* quell GCC overwarning */
    1: #endif
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         obj = *objp;
    1:         parent = OBJ_GET_PARENT(cx, obj);
 3235:         parentId = (xdr->script->objectsOffset == 0)
 3235:                    ? NO_PARENT_INDEX
 3235:                    : FindObjectIndex(JS_SCRIPT_OBJECTS(xdr->script), parent);
 2531:         depth = (uint16)OBJ_BLOCK_DEPTH(cx, obj);
 2531:         count = (uint16)OBJ_BLOCK_COUNT(cx, obj);
    1:         tmp = (uint32)(depth << 16) | count;
    1:     }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     else count = 0;
    1: #endif
    1: 
    1:     /* First, XDR the parent atomid. */
    1:     if (!JS_XDRUint32(xdr, &parentId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         obj = js_NewBlockObject(cx);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *objp = obj;
    1: 
    1:         /*
    1:          * If there's a parent id, then get the parent out of our script's
 3235:          * object array. We know that we XDR block object in outer-to-inner
 3235:          * order, which means that getting the parent now will work.
    1:          */
 3235:         if (parentId == NO_PARENT_INDEX)
    1:             parent = NULL;
 3235:         else
 3235:             JS_GET_SCRIPT_OBJECT(xdr->script, parentId, parent);
    1:         STOBJ_SET_PARENT(obj, parent);
    1:     }
    1: 
    1:     JS_PUSH_SINGLE_TEMP_ROOT(cx, OBJECT_TO_JSVAL(obj), &tvr);
    1: 
    1:     if (!JS_XDRUint32(xdr, &tmp)) {
    1:         JS_POP_TEMP_ROOT(cx, &tvr);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         depth = (uint16)(tmp >> 16);
    1:         count = (uint16)tmp;
    1:         STOBJ_SET_SLOT(obj, JSSLOT_BLOCK_DEPTH, INT_TO_JSVAL(depth));
    1:     }
    1: 
    1:     /*
    1:      * XDR the block object's properties. We know that there are 'count'
    1:      * properties to XDR, stored as id/shortid pairs. We do not XDR any
    1:      * non-native properties, only those that the compiler created.
    1:      */
    1:     sprop = NULL;
    1:     ok = JS_TRUE;
    1:     for (i = 0; i < count; i++) {
    1:         if (xdr->mode == JSXDR_ENCODE) {
    1:             /* Find a property to XDR. */
    1:             do {
    1:                 /* If sprop is NULL, this is the first property. */
    1:                 sprop = sprop ? sprop->parent : OBJ_SCOPE(obj)->lastProp;
    1:             } while (!(sprop->flags & SPROP_HAS_SHORTID));
    1: 
    1:             JS_ASSERT(sprop->getter == js_BlockClass.getProperty);
    1:             propid = sprop->id;
    1:             JS_ASSERT(JSID_IS_ATOM(propid));
    1:             atom = JSID_TO_ATOM(propid);
    1:             shortid = sprop->shortid;
    1:             JS_ASSERT(shortid >= 0);
    1:         }
    1: 
    1:         /* XDR the real id, then the shortid. */
    1:         if (!js_XDRStringAtom(xdr, &atom) ||
    1:             !JS_XDRUint16(xdr, (uint16 *)&shortid)) {
    1:             ok = JS_FALSE;
    1:             break;
    1:         }
    1: 
    1:         if (xdr->mode == JSXDR_DECODE) {
    1:             if (!js_DefineNativeProperty(cx, obj, ATOM_TO_JSID(atom),
    1:                                          JSVAL_VOID, NULL, NULL,
    1:                                          JSPROP_ENUMERATE | JSPROP_PERMANENT,
    1:                                          SPROP_HAS_SHORTID, shortid, NULL)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return ok;
    1: }
    1: 
    1: #endif
    1: 
14860: static uint32
14860: block_reserveSlots(JSContext *cx, JSObject *obj)
14860: {
14860:     return OBJ_IS_CLONED_BLOCK(obj) ? OBJ_BLOCK_COUNT(cx, obj) : 0;
14860: }
14860: 
    1: JSClass js_BlockClass = {
    1:     "Block",
28093:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
    1:     JS_PropertyStub,  JS_PropertyStub,  block_getProperty, block_setProperty,
    1:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,    JS_FinalizeStub,
28093:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, block_reserveSlots
    1: };
    1: 
    1: JSObject *
14322: js_InitEval(JSContext *cx, JSObject *obj)
    1: {
 2112:     /* ECMA (15.1.2.1) says 'eval' is a property of the global object. */
 2112:     if (!js_DefineFunction(cx, obj, cx->runtime->atomState.evalAtom,
20408:                            obj_eval, 1, 0)) {
    1:         return NULL;
    1:     }
    1: 
14322:     return obj;
14322: }
14322: 
14322: JSObject *
14322: js_InitObjectClass(JSContext *cx, JSObject *obj)
14322: {
25897:     return js_InitClass(cx, obj, NULL, &js_ObjectClass, js_Object, 1,
28086:                         object_props, object_methods, NULL, object_static_methods);
    1: }
    1: 
25897: JSObject *
25897: js_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
25897:              JSClass *clasp, JSNative constructor, uintN nargs,
25897:              JSPropertySpec *ps, JSFunctionSpec *fs,
28086:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
25897: {
25897:     JSAtom *atom;
25897:     JSProtoKey key;
25897:     JSObject *proto, *ctor;
25897:     JSTempValueRooter tvr;
25897:     jsval cval, rval;
25897:     JSBool named;
25897:     JSFunction *fun;
25897: 
25897:     atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
25897:     if (!atom)
25897:         return NULL;
25897: 
25897:     /*
25897:      * When initializing a standard class, if no parent_proto (grand-proto of
25897:      * instances of the class, parent-proto of the class's prototype object)
25897:      * is given, we must use Object.prototype if it is available.  Otherwise,
25897:      * we could look up the wrong binding for a class name in obj.  Example:
25897:      *
25897:      *   String = Array;
25897:      *   print("hi there".join);
25897:      *
25897:      * should print undefined, not Array.prototype.join.  This is required by
25897:      * ECMA-262, alas.  It might have been better to make String readonly and
25897:      * permanent in the global object, instead -- but that's too big a change
25897:      * to swallow at this point.
25897:      */
25897:     key = JSCLASS_CACHED_PROTO_KEY(clasp);
25897:     if (key != JSProto_Null &&
25897:         !parent_proto &&
25897:         !js_GetClassPrototype(cx, obj, INT_TO_JSID(JSProto_Object),
25897:                               &parent_proto)) {
25897:         return NULL;
25897:     }
25897: 
25897:     /* Create a prototype object for this class. */
25897:     proto = js_NewObject(cx, clasp, parent_proto, obj, 0);
25897:     if (!proto)
25897:         return NULL;
25897: 
25897:     /* After this point, control must exit via label bad or out. */
25897:     JS_PUSH_TEMP_ROOT_OBJECT(cx, proto, &tvr);
25897: 
25897:     if (!constructor) {
25897:         /*
25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
25897:          * of obj (the global object) is has a reserved slot indexed by key;
25897:          * and (c) key is not the null key.
25897:          */
25897:         if ((clasp->flags & JSCLASS_IS_ANONYMOUS) &&
25897:             (OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL) &&
25897:             key != JSProto_Null) {
25897:             named = JS_FALSE;
25897:         } else {
25897:             named = OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom),
25897:                                         OBJECT_TO_JSVAL(proto),
25897:                                         JS_PropertyStub, JS_PropertyStub,
25897:                                         (clasp->flags & JSCLASS_IS_ANONYMOUS)
25897:                                         ? JSPROP_READONLY | JSPROP_PERMANENT
25897:                                         : 0,
25897:                                         NULL);
25897:             if (!named)
25897:                 goto bad;
25897:         }
25897: 
25897:         ctor = proto;
25897:     } else {
25897:         /* Define the constructor function in obj's scope. */
25897:         fun = js_DefineFunction(cx, obj, atom, constructor, nargs,
25897:                                 JSFUN_STUB_GSOPS);
25897:         named = (fun != NULL);
25897:         if (!fun)
25897:             goto bad;
25897: 
25897:         /*
25897:          * Remember the class this function is a constructor for so that
25897:          * we know to create an object of this class when we call the
25897:          * constructor.
25897:          */
25897:         FUN_CLASP(fun) = clasp;
25897: 
25897:         /*
25897:          * Optionally construct the prototype object, before the class has
25897:          * been fully initialized.  Allow the ctor to replace proto with a
25897:          * different object, as is done for operator new -- and as at least
25897:          * XML support requires.
25897:          */
25897:         ctor = FUN_OBJECT(fun);
25897:         if (clasp->flags & JSCLASS_CONSTRUCT_PROTOTYPE) {
25897:             cval = OBJECT_TO_JSVAL(ctor);
25897:             if (!js_InternalConstruct(cx, proto, cval, 0, NULL, &rval))
25897:                 goto bad;
25897:             if (!JSVAL_IS_PRIMITIVE(rval) && JSVAL_TO_OBJECT(rval) != proto)
25897:                 proto = JSVAL_TO_OBJECT(rval);
25897:         }
25897: 
25897:         /* Connect constructor and prototype by named properties. */
25897:         if (!js_SetClassPrototype(cx, ctor, proto,
25897:                                   JSPROP_READONLY | JSPROP_PERMANENT)) {
25897:             goto bad;
25897:         }
25897: 
25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
25897:         if (OBJ_GET_CLASS(cx, ctor) == clasp)
25897:             OBJ_SET_PROTO(cx, ctor, proto);
25897:     }
25897: 
25897:     /* Add properties and methods to the prototype and the constructor. */
25897:     if ((ps && !JS_DefineProperties(cx, proto, ps)) ||
25897:         (fs && !JS_DefineFunctions(cx, proto, fs)) ||
25897:         (static_ps && !JS_DefineProperties(cx, ctor, static_ps)) ||
25897:         (static_fs && !JS_DefineFunctions(cx, ctor, static_fs))) {
25897:         goto bad;
25897:     }
25897: 
25897:     /* If this is a standard class, cache its prototype. */
25897:     if (key != JSProto_Null && !js_SetClassObject(cx, obj, key, ctor))
25897:         goto bad;
25897: 
25897: out:
25897:     JS_POP_TEMP_ROOT(cx, &tvr);
25897:     return proto;
25897: 
25897: bad:
25897:     if (named)
25897:         (void) OBJ_DELETE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &rval);
25897:     proto = NULL;
25897:     goto out;
25897: }
25897: 
    1: static void
    1: FreeSlots(JSContext *cx, JSObject *obj)
    1: {
    1:     if (obj->dslots) {
    1:         JS_ASSERT((uint32)obj->dslots[-1] > JS_INITIAL_NSLOTS);
    1:         JS_free(cx, obj->dslots - 1);
    1:         obj->dslots = NULL;
    1:     }
    1: }
    1: 
    1: #define SLOTS_TO_DYNAMIC_WORDS(nslots)                                        \
    1:   (JS_ASSERT((nslots) > JS_INITIAL_NSLOTS), (nslots) + 1 - JS_INITIAL_NSLOTS)
    1: 
    1: #define DYNAMIC_WORDS_TO_SLOTS(words)                                         \
    1:   (JS_ASSERT((words) > 1), (words) - 1 + JS_INITIAL_NSLOTS)
    1: 
15588: JSBool
14860: js_ReallocSlots(JSContext *cx, JSObject *obj, uint32 nslots,
    1:                 JSBool exactAllocation)
    1: {
    1:     jsval *old, *slots;
    1:     uint32 oslots, nwords, owords, log, i;
    1: 
    1:     /*
    1:      * Minimal number of dynamic slots to allocate.
    1:      */
    1: #define MIN_DYNAMIC_WORDS 4
    1: 
    1:     /*
    1:      * The limit to switch to linear allocation strategy from the power of 2
    1:      * growth no to waste too much memory.
    1:      */
    1: #define LINEAR_GROWTH_STEP JS_BIT(16)
    1: 
    1:     old = obj->dslots;
    1:     if (nslots <= JS_INITIAL_NSLOTS) {
    1:         if (old &&
    1:             (exactAllocation ||
    1:              SLOTS_TO_DYNAMIC_WORDS((uint32)old[-1]) != MIN_DYNAMIC_WORDS ||
    1:              nslots <= (JS_INITIAL_NSLOTS +
    1:                         JSSLOT_FREE(STOBJ_GET_CLASS(obj))) / 2)) {
    1:             /*
    1:              * We do not want to free dynamic slots when allocation is a hint,
    1:              * we reached minimal allocation and almost all fixed slots are
    1:              * used. It avoids allocating dynamic slots again when properties
    1:              * are added to the object.
    1:              *
    1:              * If there were no private or reserved slots, the condition to
    1:              * free the slots would be
    1:              *
    1:              *   nslots <= JS_INITIAL_NSLOTS / 2
    1:              *
    1:              * but to account for never removed slots before JSSLOT_FREE(class)
    1:              * we need to subtract it from the slot counts which gives
    1:              *
    1:              *   nslots - JSSLOT_FREE <= (JS_INITIAL_NSLOTS - JSSLOT_FREE) / 2
    1:              *
    1:              * or
    1:              *
    1:              *   nslots <= (JS_INITIAL_NSLOTS + JSSLOT_FREE) / 2
    1:              */
    1:             FreeSlots(cx, obj);
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     oslots = (old) ? (uint32)*--old : JS_INITIAL_NSLOTS;
    1:     nwords = SLOTS_TO_DYNAMIC_WORDS(nslots);
    1: 
    1:     if (nslots > oslots) {
    1:         if (!exactAllocation) {
    1:             /*
    1:              * Round up nslots so the number of bytes in dslots array is power
    1:              * of 2 to ensure exponential grouth.
    1:              */
    1:             if (nwords <= MIN_DYNAMIC_WORDS) {
    1:                 nwords = MIN_DYNAMIC_WORDS;
    1:             } else if (nwords < LINEAR_GROWTH_STEP) {
    1:                 JS_CEILING_LOG2(log, nwords);
    1:                 nwords = JS_BIT(log);
    1:             } else {
    1:                 nwords = JS_ROUNDUP(nwords, LINEAR_GROWTH_STEP);
    1:             }
    1:         }
    1:         slots = (jsval *)JS_realloc(cx, old, nwords * sizeof(jsval));
    1:         if (!slots)
    1:             return JS_FALSE;
    1:     } else {
    1:         JS_ASSERT(nslots < oslots);
    1:         if (!exactAllocation) {
    1:             owords = DYNAMIC_WORDS_TO_SLOTS(oslots);
    1:             if (owords <= MIN_DYNAMIC_WORDS)
    1:                 return JS_TRUE;
    1:             if (owords < LINEAR_GROWTH_STEP * 2) {
    1:                 /*
    1:                  * Shrink only if 1/4 of slots are left and we need to grow
    1:                  * the array at least twice to reach the current capacity. It
    1:                  * prevents frequent capacity growth/shrinking when slots are
    1:                  * often removed and added.
    1:                  */
    1:                 if (nwords > owords / 4)
    1:                     return JS_TRUE;
    1:                 JS_CEILING_LOG2(log, nwords);
    1:                 nwords = JS_BIT(log);
    1:                 if (nwords < MIN_DYNAMIC_WORDS)
    1:                     nwords = MIN_DYNAMIC_WORDS;
    1:             } else {
    1:                 /*
    1:                  * Shrink only if we free at least 2 linear allocation
    1:                  * segments, to prevent growth/shrinking resonance.
    1:                  */
    1:                 if (nwords > owords - LINEAR_GROWTH_STEP * 2)
    1:                     return JS_TRUE;
    1:                 nwords = JS_ROUNDUP(nwords, LINEAR_GROWTH_STEP);
    1:             }
    1:         }
    1: 
    1:         /* We avoid JS_realloc not to report a failed shrink attempt. */
    1:         slots = (jsval *)realloc(old, nwords * sizeof(jsval));
    1:         if (!slots)
    1:             slots = old;
    1:     }
    1: 
    1:     nslots = DYNAMIC_WORDS_TO_SLOTS(nwords);
    1:     *slots++ = (jsval)nslots;
    1:     obj->dslots = slots;
    1: 
    1:     /* If we're extending an allocation, initialize free slots. */
    1:     for (i = oslots; i < nslots; i++)
    1:         slots[i - JS_INITIAL_NSLOTS] = JSVAL_VOID;
    1: 
    1:     return JS_TRUE;
    1: 
    1: #undef LINEAR_GROWTH_STEP
    1: #undef MIN_DYNAMIC_WORDS
    1: }
    1: 
    1: extern JSBool
    1: js_GetClassId(JSContext *cx, JSClass *clasp, jsid *idp)
    1: {
    1:     JSProtoKey key;
    1:     JSAtom *atom;
    1: 
    1:     key = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:     if (key != JSProto_Null) {
    1:         *idp = INT_TO_JSID(key);
    1:     } else if (clasp->flags & JSCLASS_IS_ANONYMOUS) {
    1:         *idp = INT_TO_JSID(JSProto_Object);
    1:     } else {
    1:         atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
    1:         if (!atom)
    1:             return JS_FALSE;
    1:         *idp = ATOM_TO_JSID(atom);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
13427: js_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent,
13824:              uintN objectSize)
    1: {
    1:     jsid id;
    1: 
    1:     /* Bootstrap the ur-object, and make it the default prototype object. */
    1:     if (!proto) {
    1:         if (!js_GetClassId(cx, clasp, &id))
    1:             return NULL;
    1:         if (!js_GetClassPrototype(cx, parent, id, &proto))
    1:             return NULL;
    1:         if (!proto &&
    1:             !js_GetClassPrototype(cx, parent, INT_TO_JSID(JSProto_Object),
    1:                                   &proto)) {
    1:             return NULL;
    1:         }
    1:     }
    1: 
13824:     return js_NewObjectWithGivenProto(cx, clasp, proto, parent, objectSize);
11700: }
11700: 
11700: JSObject *
11700: js_NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
13824:                            JSObject *parent, uintN objectSize)
11700: {
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_OBJECT_CREATE_START_ENABLED())
 7058:         jsdtrace_object_create_start(cx->fp, clasp);
 7058: #endif
 7058: 
13824:     /* Currently only functions can have non-standard allocation size. */
13824:     if (clasp == &js_FunctionClass) {
13824:         if (objectSize == 0)
13824:             objectSize = sizeof(JSFunction);
13824:         else
13824:             JS_ASSERT(objectSize == sizeof(JSObject));
13824:     } else {
13824:         JS_ASSERT(objectSize == 0);
13824:         objectSize = sizeof(JSObject);
13824:     }
    1: 
22077:     /* Assert that the class is a proper class. */
22077:     JS_ASSERT_IF(clasp->flags & JSCLASS_IS_EXTENDED,
22077:                  ((JSExtendedClass *)clasp)->equality);
22077: 
28353:     /* Always call the class's getObjectOps hook if it has one. */
28353:     JSObjectOps *ops = clasp->getObjectOps
28353:                        ? clasp->getObjectOps(cx, clasp)
28353:                        : &js_ObjectOps;
28353: 
    1:     /*
13824:      * Allocate an object from the GC heap and initialize all its fields before
13824:      * doing any operation that can potentially trigger GC.
    1:      */
28353:     JSObject *obj = (JSObject *) js_NewGCThing(cx, GCX_OBJECT, objectSize);
    1:     if (!obj)
28353:         goto out;
    1: 
19020:     /*
19020:      * Set the class slot with the initial value of the system and delegate
19020:      * flags set to false.
19020:      */
19020:     JS_ASSERT(((jsuword) clasp & 3) == 0);
19020:     obj->classword = jsuword(clasp);
19020:     JS_ASSERT(!STOBJ_IS_DELEGATE(obj));
19020:     JS_ASSERT(!STOBJ_IS_SYSTEM(obj));
19020: 
28353:     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
28353: 
28353:     /*
28353:      * Default parent to the parent of the prototype, which was set from
28353:      * the parent of the prototype's constructor.
28353:      */
28353:     obj->fslots[JSSLOT_PARENT] = OBJECT_TO_JSVAL((!parent && proto)
28353:                                                  ? OBJ_GET_PARENT(cx, proto)
28353:                                                  : parent);
 6488: 
 5172:     /* Initialize the remaining fixed slots. */
28353:     for (uint32 i = JSSLOT_PRIVATE; i < JS_INITIAL_NSLOTS; ++i)
 5172:         obj->fslots[i] = JSVAL_VOID;
 5172: 
28353:     obj->dslots = NULL;
28353: 
28353:     if (OPS_IS_NATIVE(ops)) {
28353:         if (!InitScopeForObject(cx, obj, proto, ops)) {
28353:             obj = NULL;
28353:             goto out;
28353:         }
28353:     } else {
28353:         JS_ASSERT(ops->objectMap->ops == ops);
28353:         obj->map = const_cast<JSObjectMap *>(ops->objectMap);
28353:     }
28353: 
13824: #ifdef DEBUG
13824:     memset((uint8 *) obj + sizeof(JSObject), JS_FREE_PATTERN,
13824:            objectSize - sizeof(JSObject));
13824: #endif
13482: 
28353:     /* Check that the newborn root still holds the object. */
28353:     JS_ASSERT_IF(!cx->localRootStack, cx->weakRoots.newborn[GCX_OBJECT] == obj);
    1: 
26203:     /*
26203:      * Do not call debug hooks on trace, because we might be in a non-_FAIL
26203:      * builtin. See bug 481444.
26203:      */
26203:     if (cx->debugHooks->objectHook && !JS_ON_TRACE(cx)) {
28353:         JSAutoTempValueRooter tvr(cx, obj);
    1:         JS_KEEP_ATOMS(cx->runtime);
 2433:         cx->debugHooks->objectHook(cx, obj, JS_TRUE,
 2433:                                    cx->debugHooks->objectHookData);
    1:         JS_UNKEEP_ATOMS(cx->runtime);
28353:         cx->weakRoots.newborn[GCX_OBJECT] = obj;
    1:     }
    1: 
    1: out:
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_OBJECT_CREATE_ENABLED())
 7058:         jsdtrace_object_create(cx, clasp, obj);
 7058:     if (JAVASCRIPT_OBJECT_CREATE_DONE_ENABLED())
 7058:         jsdtrace_object_create_done(cx->fp, clasp);
 7058: #endif
    1:     return obj;
    1: }
    1: 
25897: JSObject*
25897: js_NewNativeObject(JSContext *cx, JSClass *clasp, JSObject *proto, uint32 slot)
25897: {
28353:     JS_ASSERT(!clasp->getObjectOps);
28353:     JS_ASSERT(proto->map->ops == &js_ObjectOps);
28353:     JS_ASSERT(OBJ_GET_CLASS(cx, proto) == clasp);
28353: 
25897:     JSObject* obj = (JSObject*) js_NewGCThing(cx, GCX_OBJECT, sizeof(JSObject));
25897:     if (!obj)
25897:         return NULL;
25897: 
28353:     js_HoldScope(OBJ_SCOPE(proto));
28353:     obj->map = proto->map;
25897:     obj->classword = jsuword(clasp);
25897:     obj->fslots[JSSLOT_PROTO] = OBJECT_TO_JSVAL(proto);
25897:     obj->fslots[JSSLOT_PARENT] = proto->fslots[JSSLOT_PARENT];
25897: 
25897:     JS_ASSERT(slot > JSSLOT_PARENT);
25897:     while (slot < JS_INITIAL_NSLOTS)
25897:         obj->fslots[slot++] = JSVAL_VOID;
25897: 
25897:     obj->dslots = NULL;
25897:     return obj;
25897: }
25897: 
 3164: JS_BEGIN_EXTERN_C
 3164: 
18907: static JSObject *
    1: js_InitNullClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: static JSObjectOp lazy_prototype_init[JSProto_LIMIT] = {
    1: #define JS_PROTO(name,code,init) init,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: };
    1: 
 3164: JS_END_EXTERN_C
 3164: 
    1: JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
    1:     JSBool ok;
    1:     JSObject *tmp, *cobj;
    1:     JSResolvingKey rkey;
    1:     JSResolvingEntry *rentry;
    1:     uint32 generation;
    1:     JSObjectOp init;
    1:     jsval v;
    1: 
    1:     while ((tmp = OBJ_GET_PARENT(cx, obj)) != NULL)
    1:         obj = tmp;
    1:     if (!(OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL)) {
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     ok = JS_GetReservedSlot(cx, obj, key, &v);
    1:     if (!ok)
    1:         return JS_FALSE;
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         *objp = JSVAL_TO_OBJECT(v);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     rkey.obj = obj;
    1:     rkey.id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
    1:     if (!js_StartResolving(cx, &rkey, JSRESFLAG_LOOKUP, &rentry))
    1:         return JS_FALSE;
    1:     if (!rentry) {
    1:         /* Already caching key in obj -- suppress recursion. */
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     generation = cx->resolvingTable->generation;
    1: 
    1:     cobj = NULL;
    1:     init = lazy_prototype_init[key];
    1:     if (init) {
    1:         if (!init(cx, obj)) {
    1:             ok = JS_FALSE;
    1:         } else {
    1:             ok = JS_GetReservedSlot(cx, obj, key, &v);
    1:             if (ok && !JSVAL_IS_PRIMITIVE(v))
    1:                 cobj = JSVAL_TO_OBJECT(v);
    1:         }
    1:     }
    1: 
    1:     js_StopResolving(cx, &rkey, JSRESFLAG_LOOKUP, rentry, generation);
    1:     *objp = cobj;
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj)
    1: {
    1:     JS_ASSERT(!OBJ_GET_PARENT(cx, obj));
    1:     if (!(OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL))
    1:         return JS_TRUE;
    1: 
    1:     return JS_SetReservedSlot(cx, obj, key, OBJECT_TO_JSVAL(cobj));
    1: }
    1: 
    1: JSBool
    1: js_FindClassObject(JSContext *cx, JSObject *start, jsid id, jsval *vp)
    1: {
22652:     JSStackFrame *fp;
    1:     JSObject *obj, *cobj, *pobj;
    1:     JSProtoKey key;
    1:     JSProperty *prop;
 8893:     jsval v;
    1:     JSScopeProperty *sprop;
    1: 
22652:     /*
22652:      * Find the global object. Use cx->fp directly to avoid falling off
22652:      * trace; all JIT-elided stack frames have the same global object as
22652:      * cx->fp.
22652:      */
22652:     VOUCH_DOES_NOT_REQUIRE_STACK();
22652:     if (!start && (fp = cx->fp) != NULL)
22652:         start = fp->scopeChain;
22652: 
22652:     if (start) {
    1:         /* Find the topmost object in the scope chain. */
    1:         do {
    1:             obj = start;
    1:             start = OBJ_GET_PARENT(cx, obj);
    1:         } while (start);
    1:     } else {
    1:         obj = cx->globalObject;
    1:         if (!obj) {
    1:             *vp = JSVAL_VOID;
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, obj);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
    1:     if (JSID_IS_INT(id)) {
 3164:         key = (JSProtoKey) JSID_TO_INT(id);
    1:         JS_ASSERT(key != JSProto_Null);
    1:         if (!js_GetClassObject(cx, obj, key, &cobj))
    1:             return JS_FALSE;
    1:         if (cobj) {
    1:             *vp = OBJECT_TO_JSVAL(cobj);
    1:             return JS_TRUE;
    1:         }
    1:         id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
    1:     }
    1: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
10217:     if (js_LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_CLASSNAME,
10217:                                    &pobj, &prop) < 0) {
    1:         return JS_FALSE;
    1:     }
 8893:     v = JSVAL_VOID;
 8893:     if (prop)  {
 8893:         if (OBJ_IS_NATIVE(pobj)) {
    1:             sprop = (JSScopeProperty *) prop;
 8893:             if (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(pobj))) {
 8893:                 v = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
 8893:                 if (JSVAL_IS_PRIMITIVE(v))
 8893:                     v = JSVAL_VOID;
 8893:             }
 8893:         }
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
 8893:     }
 8893:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_ConstructObject(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                    JSObject *parent, uintN argc, jsval *argv)
    1: {
    1:     jsid id;
    1:     jsval cval, rval;
    1:     JSTempValueRooter argtvr, tvr;
    1:     JSObject *obj, *ctor;
    1: 
    1:     JS_PUSH_TEMP_ROOT(cx, argc, argv, &argtvr);
    1: 
    1:     if (!js_GetClassId(cx, clasp, &id) ||
    1:         !js_FindClassObject(cx, parent, id, &cval)) {
    1:         JS_POP_TEMP_ROOT(cx, &argtvr);
    1:         return NULL;
    1:     }
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(cval)) {
    1:         js_ReportIsNotFunction(cx, &cval, JSV2F_CONSTRUCT | JSV2F_SEARCH_STACK);
    1:         JS_POP_TEMP_ROOT(cx, &argtvr);
    1:         return NULL;
    1:     }
    1: 
    1:     /*
    1:      * Protect cval in case a crazy getter for .prototype uproots it.  After
    1:      * this point, all control flow must exit through label out with obj set.
    1:      */
    1:     JS_PUSH_SINGLE_TEMP_ROOT(cx, cval, &tvr);
18989:     MUST_FLOW_THROUGH("out");
    1: 
    1:     /*
    1:      * If proto or parent are NULL, set them to Constructor.prototype and/or
    1:      * Constructor.__parent__, just like JSOP_NEW does.
    1:      */
    1:     ctor = JSVAL_TO_OBJECT(cval);
    1:     if (!parent)
    1:         parent = OBJ_GET_PARENT(cx, ctor);
    1:     if (!proto) {
    1:         if (!OBJ_GET_PROPERTY(cx, ctor,
    1:                               ATOM_TO_JSID(cx->runtime->atomState
    1:                                            .classPrototypeAtom),
    1:                               &rval)) {
    1:             obj = NULL;
    1:             goto out;
    1:         }
    1:         if (JSVAL_IS_OBJECT(rval))
    1:             proto = JSVAL_TO_OBJECT(rval);
    1:     }
    1: 
13427:     obj = js_NewObject(cx, clasp, proto, parent, 0);
    1:     if (!obj)
    1:         goto out;
    1: 
    1:     if (!js_InternalConstruct(cx, obj, cval, argc, argv, &rval))
    1:         goto bad;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(rval))
    1:         goto out;
    1:     obj = JSVAL_TO_OBJECT(rval);
    1: 
    1:     /*
    1:      * If the instance's class differs from what was requested, throw a type
    1:      * error.  If the given class has both the JSCLASS_HAS_PRIVATE and the
    1:      * JSCLASS_CONSTRUCT_PROTOTYPE flags, and the instance does not have its
    1:      * private data set at this point, then the constructor was replaced and
    1:      * we should throw a type error.
    1:      */
    1:     if (OBJ_GET_CLASS(cx, obj) != clasp ||
    1:         (!(~clasp->flags & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_CONSTRUCT_PROTOTYPE)) &&
    1:          !JS_GetPrivate(cx, obj))) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_WRONG_CONSTRUCTOR, clasp->name);
    1:         goto bad;
    1:     }
    1: 
    1: out:
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     JS_POP_TEMP_ROOT(cx, &argtvr);
    1:     return obj;
    1: 
    1: bad:
    1:     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:     obj = NULL;
    1:     goto out;
    1: }
    1: 
    1: void
    1: js_FinalizeObject(JSContext *cx, JSObject *obj)
    1: {
    1:     /* Cope with stillborn objects that have no map. */
28353:     if (!obj->map)
    1:         return;
    1: 
 2433:     if (cx->debugHooks->objectHook) {
 2433:         cx->debugHooks->objectHook(cx, obj, JS_FALSE,
 2433:                                    cx->debugHooks->objectHookData);
 2433:     }
    1: 
    1:     /* Finalize obj first, in case it needs map and slots. */
10592:     STOBJ_GET_CLASS(obj)->finalize(cx, obj);
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058:     if (JAVASCRIPT_OBJECT_FINALIZE_ENABLED())
 7058:         jsdtrace_object_finalize(obj);
 7058: #endif
    1: 
28353:     if (OBJ_IS_NATIVE(obj))
28353:         js_DropScope(cx, OBJ_SCOPE(obj), obj);
    1:     FreeSlots(cx, obj);
    1: }
    1: 
    1: /* XXXbe if one adds props, deletes earlier props, adds more, the last added
    1:          won't recycle the deleted props' slots. */
    1: JSBool
    1: js_AllocSlot(JSContext *cx, JSObject *obj, uint32 *slotp)
    1: {
28353:     JS_ASSERT(OBJ_IS_NATIVE(obj));
28353: 
28353:     JSScope *scope = OBJ_SCOPE(obj);
28353:     JSClass *clasp = LOCKED_OBJ_GET_CLASS(obj);
28353:     if (scope->freeslot == JSSLOT_FREE(clasp) && clasp->reserveSlots) {
28353:         /* Adjust scope->freeslot to include computed reserved slots, if any. */
28353:         scope->freeslot += clasp->reserveSlots(cx, obj);
28353:     }
28353: 
28353:     if (scope->freeslot >= STOBJ_NSLOTS(obj) &&
28353:         !js_ReallocSlots(cx, obj, scope->freeslot + 1, JS_FALSE)) {
    1:         return JS_FALSE;
    1:     }
    1: 
14860:     /* js_ReallocSlots or js_FreeSlot should set the free slots to void. */
28353:     JS_ASSERT(JSVAL_IS_VOID(STOBJ_GET_SLOT(obj, scope->freeslot)));
28353:     *slotp = scope->freeslot++;
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_FreeSlot(JSContext *cx, JSObject *obj, uint32 slot)
    1: {
28353:     JS_ASSERT(OBJ_IS_NATIVE(obj));
28353: 
28353:     JSScope *scope = OBJ_SCOPE(obj);
    1:     LOCKED_OBJ_SET_SLOT(obj, slot, JSVAL_VOID);
28353:     if (scope->freeslot == slot + 1) {
28353:         scope->freeslot = slot;
 8434: 
14860:         /* When shrinking, js_ReallocSlots always returns true. */
14860:         js_ReallocSlots(cx, obj, slot, JS_FALSE);
    1:     }
    1: }
    1: 
11524: jsid
11524: js_CheckForStringIndex(jsid id, const jschar *cp, const jschar *end,
    1:                        JSBool negative)
    1: {
    1:     jsuint index = JS7_UNDEC(*cp++);
    1:     jsuint oldIndex = 0;
    1:     jsuint c = 0;
    1: 
    1:     if (index != 0) {
    1:         while (JS7_ISDEC(*cp)) {
    1:             oldIndex = index;
    1:             c = JS7_UNDEC(*cp);
    1:             index = 10 * index + c;
    1:             cp++;
    1:         }
    1:     }
22608: 
22608:     /*
22608:      * Non-integer indexes can't be represented as integers.  Also, distinguish
22608:      * index "-0" from "0", because JSVAL_INT cannot.
22608:      */
22608:     if (cp != end || (negative && index == 0))
22608:         return id;
22608:     if (oldIndex < JSVAL_INT_MAX / 10 ||
22608:         (oldIndex == JSVAL_INT_MAX / 10 && c <= (JSVAL_INT_MAX % 10))) {
    1:         if (negative)
    1:             index = 0 - index;
    1:         id = INT_TO_JSID((jsint)index);
    1:     }
    1:     return id;
    1: }
    1: 
    1: static JSBool
11377: PurgeProtoChain(JSContext *cx, JSObject *obj, jsid id)
    1: {
11377:     JSScope *scope;
11377:     JSScopeProperty *sprop;
11377: 
11377:     while (obj) {
11377:         if (!OBJ_IS_NATIVE(obj)) {
11377:             obj = OBJ_GET_PROTO(cx, obj);
11377:             continue;
11377:         }
11377:         JS_LOCK_OBJ(cx, obj);
11377:         scope = OBJ_SCOPE(obj);
11377:         sprop = SCOPE_GET_PROPERTY(scope, id);
11377:         if (sprop) {
18308:             PCMETER(JS_PROPERTY_CACHE(cx).pcpurges++);
27894:             js_MakeScopeShapeUnique(cx, scope);
11377:             JS_UNLOCK_SCOPE(cx, scope);
27019: 
27019:             if (!STOBJ_GET_PARENT(scope->object)) {
27019:                 /*
27019:                  * All scope chains end in a global object, so this will change
27019:                  * the global shape. jstracer.cpp assumes that the global shape
27019:                  * never changes on trace, so we must deep-bail here.
27019:                  */
27019:                 js_LeaveTrace(cx);
27019:             }
11377:             return JS_TRUE;
11377:         }
11377:         obj = LOCKED_OBJ_GET_PROTO(scope->object);
11377:         JS_UNLOCK_SCOPE(cx, scope);
11377:     }
    1:     return JS_FALSE;
11377: }
11377: 
25936: void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id)
    1: {
25936:     JS_ASSERT(OBJ_IS_DELEGATE(cx, obj));
11377:     PurgeProtoChain(cx, OBJ_GET_PROTO(cx, obj), id);
28397: 
28397:     /*
28397:      * We must purge the scope chain only for Call objects as they are the only
28397:      * kind of cacheable non-global object that can gain properties after outer
28397:      * properties with the same names have been cached or traced. Call objects
28397:      * may gain such properties via eval introducing new vars; see bug 490364.
28397:      */
28397:     if (STOBJ_GET_CLASS(obj) == &js_CallClass) {
11377:         while ((obj = OBJ_GET_PARENT(cx, obj)) != NULL) {
11377:             if (PurgeProtoChain(cx, obj, id))
28397:                 break;
28397:         }
11377:     }
    1: }
    1: 
    1: JSScopeProperty *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
    1:                      JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid)
    1: {
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1: 
11377:     /*
11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
11377:      * this optimistically (assuming no failure below) before locking obj, so
11377:      * we can lock the shadowed scope.
11377:      */
25936:     js_PurgeScopeChain(cx, obj, id);
11377: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope) {
    1:         sprop = NULL;
    1:     } else {
11377:         /* Convert string indices to integers if appropriate. */
    1:         CHECK_FOR_STRING_INDEX(id);
    1:         sprop = js_AddScopeProperty(cx, scope, id, getter, setter, slot, attrs,
27490:                                     flags, shortid);
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return sprop;
    1: }
    1: 
    1: JSScopeProperty *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
    1:                              JSScopeProperty *sprop, uintN attrs, uintN mask,
    1:                              JSPropertyOp getter, JSPropertyOp setter)
    1: {
    1:     JSScope *scope;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope) {
    1:         sprop = NULL;
    1:     } else {
    1:         sprop = js_ChangeScopePropertyAttrs(cx, scope, sprop, attrs, mask,
    1:                                             getter, setter);
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return sprop;
    1: }
    1: 
    1: JSBool
    1: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
    1:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
    1:                   JSProperty **propp)
    1: {
27932:     return js_DefineNativeProperty(cx, obj, id, value, getter, setter, attrs,
    1:                                    0, 0, propp);
    1: }
    1: 
    1: /*
    1:  * Backward compatibility requires allowing addProperty hooks to mutate the
    1:  * nominal initial value of a slot-full property, while GC safety wants that
    1:  * value to be stored before the call-out through the hook.  Optimize to do
    1:  * both while saving cycles for classes that stub their addProperty hook.
24625:  *
24625:  * As in js_SetProtoOrParent (see above), we maintain the "any Array prototype
24625:  * has indexed properties hazard" flag by conservatively setting it.
    1:  */
    1: #define ADD_PROPERTY_HELPER(cx,clasp,obj,scope,sprop,vp,cleanup)              \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if ((clasp)->addProperty != JS_PropertyStub) {                        \
    1:             jsval nominal_ = *(vp);                                           \
    1:             if (!(clasp)->addProperty(cx, obj, SPROP_USERID(sprop), vp)) {    \
    1:                 cleanup;                                                      \
    1:             }                                                                 \
    1:             if (*(vp) != nominal_) {                                          \
    1:                 if (SPROP_HAS_VALID_SLOT(sprop, scope))                       \
11698:                     LOCKED_OBJ_WRITE_BARRIER(cx, obj, (sprop)->slot, *(vp));  \
    1:             }                                                                 \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
27932: JSBool
    1: js_DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
    1:                         JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
24852:                         uintN flags, intN shortid, JSProperty **propp,
28397:                         uintN defineHow /* = 0 */)
    1: {
    1:     JSClass *clasp;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
27930:     bool added;
    1: 
28397:     JS_ASSERT((defineHow & ~(JSDNP_CACHE_RESULT | JSDNP_DONT_PURGE)) == 0);
27492:     js_LeaveTraceIfGlobalObject(cx, obj);
27492: 
11377:     /* Convert string indices to integers if appropriate. */
    1:     CHECK_FOR_STRING_INDEX(id);
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:     /*
    1:      * If defining a getter or setter, we must check for its counterpart and
    1:      * update the attributes and property ops.  A getter or setter is really
    1:      * only half of a property.
    1:      */
14646:     sprop = NULL;
    1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         JSObject *pobj;
    1:         JSProperty *prop;
    1: 
    1:         /*
    1:          * If JS_THREADSAFE and id is found, js_LookupProperty returns with
    1:          * sprop non-null and pobj locked.  If pobj == obj, the property is
    1:          * already in obj and obj has its own (mutable) scope.  So if we are
    1:          * defining a getter whose setter was already defined, or vice versa,
    1:          * finish the job via js_ChangeScopePropertyAttributes, and refresh
    1:          * the property cache line for (obj, id) to map sprop.
    1:          */
    1:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
27932:             return JS_FALSE;
    1:         sprop = (JSScopeProperty *) prop;
    1:         if (sprop &&
    1:             pobj == obj &&
    1:             (sprop->attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
    1:             sprop = js_ChangeScopePropertyAttrs(cx, OBJ_SCOPE(obj), sprop,
    1:                                                 attrs, sprop->attrs,
    1:                                                 (attrs & JSPROP_GETTER)
    1:                                                 ? getter
    1:                                                 : sprop->getter,
    1:                                                 (attrs & JSPROP_SETTER)
    1:                                                 ? setter
    1:                                                 : sprop->setter);
    1: 
    1:             /* NB: obj == pobj, so we can share unlock code at the bottom. */
    1:             if (!sprop)
27934:                 goto error;
14646:         } else if (prop) {
    1:             /* NB: call OBJ_DROP_PROPERTY, as pobj might not be native. */
    1:             OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:             prop = NULL;
14646:             sprop = NULL;
    1:         }
    1:     }
    1: #endif /* JS_HAS_GETTER_SETTER */
    1: 
11377:     /*
28397:      * Purge the property cache of any properties named by id that are about
28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
28397:      * is not possible. We do this before locking obj to avoid nesting locks.
28312:      */
28397:     if (!(defineHow & JSDNP_DONT_PURGE))
28312:         js_PurgeScopeChain(cx, obj, id);
28312: 
28312:     /*
28312:      * Check whether a readonly property or setter is being defined on a known
28312:      * prototype object. See the comment in jscntxt.h before protoHazardShape's
28312:      * member declaration.
11377:      */
28168:     if (OBJ_IS_DELEGATE(cx, obj) && (attrs & (JSPROP_READONLY | JSPROP_SETTER)))
28312:         cx->runtime->protoHazardShape = js_GenerateShape(cx, false);
11377: 
    1:     /* Lock if object locking is required by this implementation. */
    1:     JS_LOCK_OBJ(cx, obj);
    1: 
    1:     /* Use the object's class getter and setter by default. */
    1:     clasp = LOCKED_OBJ_GET_CLASS(obj);
    1:     if (!getter)
    1:         getter = clasp->getProperty;
    1:     if (!setter)
    1:         setter = clasp->setProperty;
    1: 
    1:     /* Get obj's own scope if it has one, or create a new one for obj. */
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope)
27934:         goto error;
    1: 
27930:     added = false;
14646:     if (!sprop) {
18750:         /* Add a new property, or replace an existing one of the same id. */
    1:         if (clasp->flags & JSCLASS_SHARE_ALL_PROPERTIES)
    1:             attrs |= JSPROP_SHARED;
    1:         sprop = js_AddScopeProperty(cx, scope, id, getter, setter,
14646:                                     SPROP_INVALID_SLOT, attrs, flags,
27490:                                     shortid);
    1:         if (!sprop)
27934:             goto error;
27930:         added = true;
14646:     }
    1: 
    1:     /* Store value before calling addProperty, in case the latter GC's. */
    1:     if (SPROP_HAS_VALID_SLOT(sprop, scope))
11698:         LOCKED_OBJ_WRITE_BARRIER(cx, obj, sprop->slot, value);
    1: 
    1:     /* XXXbe called with lock held */
    1:     ADD_PROPERTY_HELPER(cx, clasp, obj, scope, sprop, &value,
    1:                         js_RemoveScopeProperty(cx, scope, id);
27934:                         goto error);
    1: 
28397:     if (defineHow & JSDNP_CACHE_RESULT) {
24852:         JS_ASSERT_NOT_ON_TRACE(cx);
27932:         JSPropCacheEntry *entry;
27930:         entry = js_FillPropertyCache(cx, obj, 0, 0, obj, sprop, added);
27932:         TRACE_2(SetPropHit, entry, sprop);
24852:     }
    1:     if (propp)
    1:         *propp = (JSProperty *) sprop;
    1:     else
    1:         JS_UNLOCK_OBJ(cx, obj);
27932:     return JS_TRUE;
    1: 
27934: error: // TRACE_2 jumps here on error, as well.
    1:     JS_UNLOCK_OBJ(cx, obj);
27932:     return JS_FALSE;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                   JSProperty **propp)
    1: {
19712:     return js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                       objp, propp) >= 0;
10217: }
10217: 
16072: #define SCOPE_DEPTH_ACCUM(bs,val)                                             \
16072:     JS_SCOPE_DEPTH_METERING(JS_BASIC_STATS_ACCUM(bs, val))
10217: 
10217: int
    1: js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                            JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *start, *obj2, *proto;
10217:     int protoIndex;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1:     JSClass *clasp;
    1:     JSResolveOp resolve;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
    1:     JSNewResolveOp newresolve;
    1:     JSBool ok;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
    1:     CHECK_FOR_STRING_INDEX(id);
11377: 
    1:     /* Search scopes starting with obj and following the prototype link. */
    1:     start = obj;
10217:     for (protoIndex = 0; ; protoIndex++) {
    1:         JS_LOCK_OBJ(cx, obj);
    1:         scope = OBJ_SCOPE(obj);
    1:         if (scope->object == obj) {
    1:             sprop = SCOPE_GET_PROPERTY(scope, id);
    1:         } else {
    1:             /* Shared prototype scope: try resolve before lookup. */
    1:             sprop = NULL;
    1:         }
    1: 
    1:         /* Try obj's class resolve hook if id was not found in obj's scope. */
    1:         if (!sprop) {
    1:             clasp = LOCKED_OBJ_GET_CLASS(obj);
    1:             resolve = clasp->resolve;
    1:             if (resolve != JS_ResolveStub) {
    1:                 /* Avoid recursion on (obj, id) already being resolved on cx. */
    1:                 key.obj = obj;
    1:                 key.id = id;
    1: 
    1:                 /*
    1:                  * Once we have successfully added an entry for (obj, key) to
    1:                  * cx->resolvingTable, control must go through cleanup: before
    1:                  * returning.  But note that JS_DHASH_ADD may find an existing
    1:                  * entry, in which case we bail to suppress runaway recursion.
    1:                  */
    1:                 if (!js_StartResolving(cx, &key, JSRESFLAG_LOOKUP, &entry)) {
    1:                     JS_UNLOCK_OBJ(cx, obj);
10217:                     return -1;
    1:                 }
    1:                 if (!entry) {
    1:                     /* Already resolving id in obj -- suppress recursion. */
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1:                     goto out;
    1:                 }
    1:                 generation = cx->resolvingTable->generation;
    1: 
    1:                 /* Null *propp here so we can test it at cleanup: safely. */
    1:                 *propp = NULL;
    1: 
    1:                 if (clasp->flags & JSCLASS_NEW_RESOLVE) {
    1:                     newresolve = (JSNewResolveOp)resolve;
23435:                     if (flags == JSRESOLVE_INFER)
23435:                         flags = InferFlags(cx, flags);
    1:                     obj2 = (clasp->flags & JSCLASS_NEW_RESOLVE_GETS_START)
    1:                            ? start
    1:                            : NULL;
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1: 
    1:                     /* Protect id and all atoms from a GC nested in resolve. */
    1:                     JS_KEEP_ATOMS(cx->runtime);
    1:                     ok = newresolve(cx, obj, ID_TO_VALUE(id), flags, &obj2);
    1:                     JS_UNKEEP_ATOMS(cx->runtime);
    1:                     if (!ok)
    1:                         goto cleanup;
    1: 
    1:                     JS_LOCK_OBJ(cx, obj);
    1:                     if (obj2) {
    1:                         /* Resolved: juggle locks and lookup id again. */
    1:                         if (obj2 != obj) {
    1:                             JS_UNLOCK_OBJ(cx, obj);
15525:                             if (OBJ_IS_NATIVE(obj2))
    1:                                 JS_LOCK_OBJ(cx, obj2);
    1:                         }
11377:                         protoIndex = 0;
11377:                         for (proto = start; proto && proto != obj2;
11377:                              proto = OBJ_GET_PROTO(cx, proto)) {
11377:                             protoIndex++;
11377:                         }
28353:                         if (!OBJ_IS_NATIVE(obj2)) {
    1:                             /* Whoops, newresolve handed back a foreign obj2. */
    1:                             JS_ASSERT(obj2 != obj);
    1:                             ok = OBJ_LOOKUP_PROPERTY(cx, obj2, id, objp, propp);
    1:                             if (!ok || *propp)
    1:                                 goto cleanup;
    1:                             JS_LOCK_OBJ(cx, obj2);
    1:                         } else {
    1:                             /*
    1:                              * Require that obj2 have its own scope now, as we
    1:                              * do for old-style resolve.  If it doesn't, then
    1:                              * id was not truly resolved, and we'll find it in
    1:                              * the proto chain, or miss it if obj2's proto is
    1:                              * not on obj's proto chain.  That last case is a
    1:                              * "too bad!" case.
    1:                              */
28353:                             scope = OBJ_SCOPE(obj2);
    1:                             if (scope->object == obj2)
    1:                                 sprop = SCOPE_GET_PROPERTY(scope, id);
    1:                         }
    1:                         if (sprop) {
    1:                             JS_ASSERT(obj2 == scope->object);
    1:                             obj = obj2;
    1:                         } else if (obj2 != obj) {
15525:                             if (OBJ_IS_NATIVE(obj2))
    1:                                 JS_UNLOCK_OBJ(cx, obj2);
    1:                             JS_LOCK_OBJ(cx, obj);
    1:                         }
    1:                     }
    1:                 } else {
    1:                     /*
    1:                      * Old resolve always requires id re-lookup if obj owns
    1:                      * its scope after resolve returns.
    1:                      */
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1:                     ok = resolve(cx, obj, ID_TO_VALUE(id));
    1:                     if (!ok)
    1:                         goto cleanup;
    1:                     JS_LOCK_OBJ(cx, obj);
28353:                     JS_ASSERT(OBJ_IS_NATIVE(obj));
    1:                     scope = OBJ_SCOPE(obj);
    1:                     if (scope->object == obj)
    1:                         sprop = SCOPE_GET_PROPERTY(scope, id);
    1:                 }
    1: 
    1:             cleanup:
    1:                 js_StopResolving(cx, &key, JSRESFLAG_LOOKUP, entry, generation);
10217:                 if (!ok)
10217:                     return -1;
10217:                 if (*propp)
10217:                     return protoIndex;
    1:             }
    1:         }
    1: 
    1:         if (sprop) {
10217:             SCOPE_DEPTH_ACCUM(&cx->runtime->protoLookupDepthStats, protoIndex);
    1:             JS_ASSERT(OBJ_SCOPE(obj) == scope);
    1:             *objp = scope->object;      /* XXXbe hide in jsscope.[ch] */
    1: 
    1:             *propp = (JSProperty *) sprop;
10217:             return protoIndex;
    1:         }
    1: 
    1:         proto = LOCKED_OBJ_GET_PROTO(obj);
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         if (!proto)
    1:             break;
10217:         if (!OBJ_IS_NATIVE(proto)) {
10217:             if (!OBJ_LOOKUP_PROPERTY(cx, proto, id, objp, propp))
10217:                 return -1;
12495:             return protoIndex + 1;
10217:         }
    1:         obj = proto;
    1:     }
    1: 
    1: out:
    1:     *objp = NULL;
    1:     *propp = NULL;
10217:     return protoIndex;
10217: }
10217: 
27539: /*
27539:  * We cache name lookup results only for the global object or for native
27539:  * non-global objects without prototype or with prototype that never mutates,
27539:  * see bug 462734 and bug 487039.
27539:  */
27539: static inline bool
27539: IsCacheableNonGlobalScope(JSObject *obj)
27539: {
27539:     JS_ASSERT(STOBJ_GET_PARENT(obj));
27539: 
27539:     JSClass *clasp = STOBJ_GET_CLASS(obj);
27539:     bool cacheable = (clasp == &js_CallClass ||
27539:                       clasp == &js_BlockClass ||
27539:                       clasp == &js_DeclEnvClass);
27539: 
27539:     JS_ASSERT_IF(cacheable, obj->map->ops->lookupProperty == js_LookupProperty);
27539:     return cacheable;
27539: }
27539: 
27575: JSPropCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp)
    1: {
27539:     JSObject *scopeChain, *obj, *parent, *pobj;
27575:     JSPropCacheEntry *entry;
11377:     int scopeIndex, protoIndex;
    1:     JSProperty *prop;
27575: 
27575:     JS_ASSERT_IF(cacheResult, !JS_ON_TRACE(cx));
27539:     scopeChain = js_GetTopStackFrame(cx)->scopeChain;
27539: 
27539:     /* Scan entries on the scope chain that we can cache across. */
27575:     entry = JS_NO_PROP_CACHE_FILL;
27539:     obj = scopeChain;
27539:     parent = OBJ_GET_PARENT(cx, obj);
27539:     for (scopeIndex = 0;
27539:          parent
27539:          ? IsCacheableNonGlobalScope(obj)
27539:          : obj->map->ops->lookupProperty == js_LookupProperty;
27539:          ++scopeIndex) {
11377:         protoIndex =
19712:             js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                        &pobj, &prop);
21979:         if (protoIndex < 0)
27575:             return NULL;
27539: 
27539:         if (prop) {
27539: #ifdef DEBUG
27539:             if (parent) {
27539:                 JSClass *clasp = OBJ_GET_CLASS(cx, obj);
27539:                 JS_ASSERT(OBJ_IS_NATIVE(pobj));
27539:                 JS_ASSERT(OBJ_GET_CLASS(cx, pobj) == clasp);
27539:                 if (clasp == &js_BlockClass) {
27539:                     /*
27539:                      * Block instances on the scope chain are immutable and
27539:                      * always share their scope with compile-time prototypes.
27539:                      */
27539:                     JS_ASSERT(pobj == OBJ_GET_PROTO(cx, obj));
27539:                     JS_ASSERT(OBJ_SCOPE(obj)->object == pobj);
27539:                     JS_ASSERT(protoIndex == 1);
11377:                 } else {
27539:                     /* Call and DeclEnvClass objects have no prototypes. */
27539:                     JS_ASSERT(!OBJ_GET_PROTO(cx, obj));
27539:                     JS_ASSERT(protoIndex == 0);
27539:                 }
27539:             }
27539: #endif
27575:             if (cacheResult) {
27930:                 entry = js_FillPropertyCache(cx, scopeChain,
27575:                                              scopeIndex, protoIndex, pobj,
27930:                                              (JSScopeProperty *) prop, false);
27539:             }
27539:             SCOPE_DEPTH_ACCUM(&rt->scopeSearchDepthStats, scopeIndex);
27539:             goto out;
27539:         }
27539: 
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             goto out;
27539:         }
27539:         obj = parent;
27539:         parent = OBJ_GET_PARENT(cx, obj);
27539:     }
27539: 
27539:     for (;;) {
27539:         if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
27575:             return NULL;
27539:         if (prop) {
11377:             PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
27539:             goto out;
27539:         }
27539: 
27539:         /*
27539:          * We conservatively assume that a resolve hook could mutate the scope
27539:          * chain during OBJ_LOOKUP_PROPERTY. So we read parent here again.
27539:          */
27539:         parent = OBJ_GET_PARENT(cx, obj);
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             break;
27539:         }
27539:         obj = parent;
27539:     }
27539: 
27539:   out:
27539:     JS_ASSERT(!!pobj == !!prop);
    1:     *objp = obj;
    1:     *pobjp = pobj;
    1:     *propp = prop;
27575:     return entry;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp)
    1: {
27575:     return !!js_FindPropertyHelper(cx, id, false, objp, pobjp, propp);
    1: }
    1: 
27319: JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id)
    1: {
27237:     /*
27237:      * This function should not be called for a global object or from the
27237:      * trace and should have a valid cache entry for native scopeChain.
27237:      */
27319:     JS_ASSERT(OBJ_GET_PARENT(cx, scopeChain));
27237:     JS_ASSERT(!JS_ON_TRACE(cx));
27237: 
27319:     JSObject *obj = scopeChain;
27319: 
27237:     /*
27319:      * Loop over cacheable objects on the scope chain until we find a
27319:      * property. We also stop when we reach the global object skipping any
27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
27319:      * js_Interpret.
27237:      */
27319:     for (int scopeIndex = 0; IsCacheableNonGlobalScope(obj); scopeIndex++) {
27237:         JSObject *pobj;
27236:         JSProperty *prop;
27319:         int protoIndex = js_LookupPropertyWithFlags(cx, obj, id,
27319:                                                     cx->resolveFlags,
27237:                                                     &pobj, &prop);
27237:         if (protoIndex < 0)
27237:             return NULL;
27237:         if (prop) {
27237:             JS_ASSERT(OBJ_IS_NATIVE(pobj));
27319:             JS_ASSERT(OBJ_GET_CLASS(cx, pobj) == OBJ_GET_CLASS(cx, obj));
27575: #ifdef DEBUG
27575:             JSPropCacheEntry *entry =
27575: #endif
27930:             js_FillPropertyCache(cx, scopeChain,
27490:                                  scopeIndex, protoIndex, pobj,
27930:                                  (JSScopeProperty *) prop, false);
27575:             JS_ASSERT(entry);
27237:             JS_UNLOCK_OBJ(cx, pobj);
27237:             return obj;
27237:         }
27237: 
27319:         /* Call and other cacheable objects always have a parent. */
27319:         obj = OBJ_GET_PARENT(cx, obj);
27319:         if (!OBJ_GET_PARENT(cx, obj))
27237:             return obj;
27237:     }
27319: 
27319:     /* Loop until we find a property or reach the global object. */
27237:     do {
27237:         JSObject *pobj;
27237:         JSProperty *prop;
27237:         if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
    1:             return NULL;
    1:         if (prop) {
    1:             OBJ_DROP_PROPERTY(cx, pobj, prop);
27237:             break;
27237:         }
27319: 
27319:         /*
27319:          * We conservatively assume that a resolve hook could mutate the scope
27319:          * chain during OBJ_LOOKUP_PROPERTY. So we must check if parent is not
27319:          * null here even if it wasn't before the lookup.
27319:          */
27319:         JSObject *parent = OBJ_GET_PARENT(cx, obj);
27319:         if (!parent)
27319:             break;
27237:         obj = parent;
27319:     } while (OBJ_GET_PARENT(cx, obj));
    1:     return obj;
    1: }
    1: 
    1: JSBool
    1: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj,
    1:              JSScopeProperty *sprop, jsval *vp)
    1: {
27490:     js_LeaveTraceIfGlobalObject(cx, pobj);
27490: 
27490:     JSScope *scope;
27490:     uint32 slot;
27490:     int32 sample;
27538:     JSTempValueRooter tvr, tvr2;
27490:     JSBool ok;
27490: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(pobj));
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, pobj));
27490:     scope = OBJ_SCOPE(pobj);
27490:     JS_ASSERT(scope->object == pobj);
27490: 
27490:     slot = sprop->slot;
27490:     *vp = (slot != SPROP_INVALID_SLOT)
27490:           ? LOCKED_OBJ_GET_SLOT(pobj, slot)
27490:           : JSVAL_VOID;
27490:     if (SPROP_HAS_STUB_GETTER(sprop))
27490:         return JS_TRUE;
27490: 
27490:     sample = cx->runtime->propertyRemovals;
    1:     JS_UNLOCK_SCOPE(cx, scope);
    1:     JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
27538:     JS_PUSH_TEMP_ROOT_OBJECT(cx, pobj, &tvr2);
25628:     ok = js_GetSprop(cx, sprop, obj, vp);
27538:     JS_POP_TEMP_ROOT(cx, &tvr2);
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     if (!ok)
    1:         return JS_FALSE;
    1: 
    1:     JS_LOCK_SCOPE(cx, scope);
    1:     JS_ASSERT(scope->object == pobj);
    1:     if (SLOT_IN_SCOPE(slot, scope) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
    1:          SCOPE_GET_PROPERTY(scope, sprop->id) == sprop)) {
    1:         LOCKED_OBJ_SET_SLOT(pobj, slot, *vp);
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, jsval *vp)
    1: {
27490:     js_LeaveTraceIfGlobalObject(cx, obj);
27490: 
27490:     JSScope *scope;
27490:     uint32 slot;
27490:     int32 sample;
27490:     JSTempValueRooter tvr;
27490:     JSBool ok;
27490: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
27490:     scope = OBJ_SCOPE(obj);
28093:     JS_ASSERT(scope->object == obj || (sprop->attrs & JSPROP_SHARED));
27490: 
27490:     slot = sprop->slot;
27490:     if (slot != SPROP_INVALID_SLOT) {
27490:         OBJ_CHECK_SLOT(obj, slot);
27490: 
27490:         /* If sprop has a stub setter, keep scope locked and just store *vp. */
27490:         if (SPROP_HAS_STUB_SETTER(sprop))
27490:             goto set_slot;
27490:     } else {
    1:         /*
    1:          * Allow API consumers to create shared properties with stub setters.
    1:          * Such properties lack value storage, so setting them is like writing
    1:          * to /dev/null.
25100:          *
25100:          * But we can't short-circuit if there's a scripted getter or setter
25100:          * since we might need to throw. In that case, we let SPROP_SET
25100:          * decide whether to throw an exception. See bug 478047.
    1:          */
25100:         if (!(sprop->attrs & JSPROP_GETTER) && SPROP_HAS_STUB_SETTER(sprop)) {
25100:             JS_ASSERT(!(sprop->attrs & JSPROP_SETTER));
    1:             return JS_TRUE;
    1:         }
27490:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
    1:     JS_UNLOCK_SCOPE(cx, scope);
    1:     JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
25628:     ok = js_SetSprop(cx, sprop, obj, vp);
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     if (!ok)
    1:         return JS_FALSE;
    1: 
    1:     JS_LOCK_SCOPE(cx, scope);
28093:     JS_ASSERT(scope->object == obj || (sprop->attrs & JSPROP_SHARED));
    1:     if (SLOT_IN_SCOPE(slot, scope) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
    1:          SCOPE_GET_PROPERTY(scope, sprop->id) == sprop)) {
27490:   set_slot:
11377:         LOCKED_OBJ_WRITE_BARRIER(cx, obj, slot, *vp);
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
27575: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, JSBool cacheResult,
27575:                      jsval *vp)
    1: {
25942:     JSObject *aobj, *obj2;
11377:     int protoIndex;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
27575:     JS_ASSERT_IF(cacheResult, !JS_ON_TRACE(cx));
11377:     /* Convert string indices to integers if appropriate. */
    1:     CHECK_FOR_STRING_INDEX(id);
11377: 
25942:     aobj = js_GetProtoIfDenseArray(cx, obj);
25942:     protoIndex = js_LookupPropertyWithFlags(cx, aobj, id, cx->resolveFlags,
19712:                                             &obj2, &prop);
11377:     if (protoIndex < 0)
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         *vp = JSVAL_VOID;
    1: 
    1:         if (!OBJ_GET_CLASS(cx, obj)->getProperty(cx, obj, ID_TO_VALUE(id), vp))
    1:             return JS_FALSE;
    1: 
27575:         PCMETER(cacheResult && JS_PROPERTY_CACHE(cx).nofills++);
11377: 
    1:         /*
    1:          * Give a strict warning if foo.bar is evaluated by a script for an
    1:          * object foo with no property named 'bar'.
    1:          */
24598:         jsbytecode *pc;
24598:         if (JSVAL_IS_VOID(*vp) && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
    1:             JSOp op;
    1:             uintN flags;
    1: 
 3164:             op = (JSOp) *pc;
25215:             if (op == JSOP_TRAP) {
25215:                 JS_ASSERT_NOT_ON_TRACE(cx);
25215:                 op = JS_GetTrapOpcode(cx, cx->fp->script, pc);
25215:             }
    1:             if (op == JSOP_GETXPROP) {
    1:                 flags = JSREPORT_ERROR;
    1:             } else {
    1:                 if (!JS_HAS_STRICT_OPTION(cx) ||
    1:                     (op != JSOP_GETPROP && op != JSOP_GETELEM)) {
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 /*
    1:                  * XXX do not warn about missing __iterator__ as the function
    1:                  * may be called from JS_GetMethodById. See bug 355145.
    1:                  */
    1:                 if (id == ATOM_TO_JSID(cx->runtime->atomState.iteratorAtom))
    1:                     return JS_TRUE;
    1: 
25213:                 /* Do not warn about tests like (obj[prop] == undefined). */
25213:                 if (cx->resolveFlags == JSRESOLVE_INFER) {
25213:                     js_LeaveTrace(cx);
    1:                     pc += js_CodeSpec[op].length;
    1:                     if (Detecting(cx, pc))
    1:                         return JS_TRUE;
25213:                 } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
25213:                     return JS_TRUE;
25213:                 }
    1: 
    1:                 flags = JSREPORT_WARNING | JSREPORT_STRICT;
    1:             }
    1: 
    1:             /* Ok, bad undefined property reference: whine about it. */
    1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
    1:                                           JSDVG_IGNORE_STACK, ID_TO_VALUE(id),
    1:                                           NULL, NULL, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if (!OBJ_IS_NATIVE(obj2)) {
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         return OBJ_GET_PROPERTY(cx, obj2, id, vp);
    1:     }
    1: 
    1:     sprop = (JSScopeProperty *) prop;
27490: 
27575:     if (cacheResult) {
24499:         JS_ASSERT_NOT_ON_TRACE(cx);
27930:         js_FillPropertyCache(cx, aobj, 0, protoIndex, obj2, sprop, false);
27490:     }
27932: 
27932:     if (!js_NativeGet(cx, obj, obj2, sprop, vp))
27932:         return JS_FALSE;
27932: 
27490:     JS_UNLOCK_OBJ(cx, obj2);
27490:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
11377: js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
27575:     return js_GetPropertyHelper(cx, obj, id, false, vp);
11377: }
11377: 
11377: JSBool
27575: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, JSBool cacheResult,
27575:              jsval *vp)
26187: {
26187:     if (obj->map->ops == &js_ObjectOps ||
26187:         obj->map->ops->getProperty == js_GetProperty) {
27575:         return js_GetPropertyHelper(cx, obj, id, cacheResult, vp);
27575:     }
27575:     JS_ASSERT_IF(cacheResult, OBJ_IS_DENSE_ARRAY(cx, obj));
26187: #if JS_HAS_XML_SUPPORT
26187:     if (OBJECT_IS_XML(cx, obj))
26187:         return js_GetXMLMethod(cx, obj, id, vp);
26187: #endif
26187:     return OBJ_GET_PROPERTY(cx, obj, id, vp);
26187: }
26187: 
27372: JS_FRIEND_API(JSBool)
27372: js_CheckUndeclaredVarAssignment(JSContext *cx)
27372: {
27372:     JSStackFrame *fp;
27372:     if (!JS_HAS_STRICT_OPTION(cx) ||
27372:         !(fp = js_GetTopStackFrame(cx)) ||
27372:         !fp->regs ||
27372:         js_GetOpcode(cx, fp->script, fp->regs->pc) != JSOP_SETNAME) {
27372:         return JS_TRUE;
27372:     }
27372: 
27372:     JSAtom *atom;
27372:     GET_ATOM_FROM_BYTECODE(fp->script, fp->regs->pc, 0, atom);
27372: 
27372:     const char *bytes = js_AtomToPrintableString(cx, atom);
27372:     return bytes &&
27372:            JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING | JSREPORT_STRICT,
27372:                                         js_GetErrorMessage, NULL,
27372:                                         JSMSG_UNDECLARED_VAR, bytes);
27372: }
27372: 
27932: /*
27932:  * Note: all non-error exits in this function must notify the tracer using
27932:  * SetPropHit when called from the interpreter loop (cacheResult is true).
27932:  */
27932: JSBool
27575: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, JSBool cacheResult,
27575:                      jsval *vp)
11377: {
11377:     int protoIndex;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1:     uintN attrs, flags;
    1:     intN shortid;
    1:     JSClass *clasp;
    1:     JSPropertyOp getter, setter;
27930:     bool added;
    1: 
28398:     if (cacheResult)
28398:         JS_ASSERT_NOT_ON_TRACE(cx);
28398: 
11377:     /* Convert string indices to integers if appropriate. */
    1:     CHECK_FOR_STRING_INDEX(id);
11377: 
22452:     /*
22452:      * We peek at OBJ_SCOPE(obj) without locking obj. Any race means a failure
22452:      * to seal before sharing, which is inherently ambiguous.
22452:      */
22452:     if (SCOPE_IS_SEALED(OBJ_SCOPE(obj)) && OBJ_SCOPE(obj)->object == obj) {
22452:         flags = JSREPORT_ERROR;
22452:         goto read_only_error;
22452:     }
22452: 
19712:     protoIndex = js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                             &pobj, &prop);
11377:     if (protoIndex < 0)
27932:         return JS_FALSE;
27237:     if (prop) {
27237:         if (!OBJ_IS_NATIVE(pobj)) {
    1:             OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:             prop = NULL;
    1:         }
27237:     } else {
27237:         /* We should never add properties to lexical blocks.  */
27237:         JS_ASSERT(OBJ_GET_CLASS(cx, obj) != &js_BlockClass);
27237: 
27372:         if (!OBJ_GET_PARENT(cx, obj) && !js_CheckUndeclaredVarAssignment(cx))
27932:             return JS_FALSE;
27237:     }
    1:     sprop = (JSScopeProperty *) prop;
    1: 
    1:     /*
    1:      * Now either sprop is null, meaning id was not found in obj or one of its
    1:      * prototypes; or sprop is non-null, meaning id was found in pobj's scope.
    1:      * If JS_THREADSAFE and sprop is non-null, then scope is locked, and sprop
    1:      * is held: we must OBJ_DROP_PROPERTY or JS_UNLOCK_SCOPE before we return
    1:      * (the two are equivalent for native objects, but we use JS_UNLOCK_SCOPE
    1:      * because it is cheaper).
    1:      */
    1:     attrs = JSPROP_ENUMERATE;
    1:     flags = 0;
    1:     shortid = 0;
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     getter = clasp->getProperty;
    1:     setter = clasp->setProperty;
    1: 
    1:     if (sprop) {
    1:         /*
    1:          * Set scope for use below.  It was locked by js_LookupProperty, and
    1:          * we know pobj owns it (i.e., scope->object == pobj).  Therefore we
    1:          * optimize JS_UNLOCK_OBJ(cx, pobj) into JS_UNLOCK_SCOPE(cx, scope).
    1:          */
    1:         scope = OBJ_SCOPE(pobj);
    1: 
    1:         attrs = sprop->attrs;
    1:         if ((attrs & JSPROP_READONLY) ||
22452:             (SCOPE_IS_SEALED(scope) && (attrs & JSPROP_SHARED))) {
    1:             JS_UNLOCK_SCOPE(cx, scope);
    1: 
    1:             /*
    1:              * Here, we'll either return true or goto read_only_error, which
    1:              * reports a strict warning or throws an error.  So we redefine
    1:              * the |flags| local variable to be JSREPORT_* flags to pass to
    1:              * JS_ReportErrorFlagsAndNumberUC at label read_only_error.  We
    1:              * must likewise re-task flags further below for the other 'goto
    1:              * read_only_error;' case.
    1:              */
    1:             flags = JSREPORT_ERROR;
    1:             if (attrs & JSPROP_READONLY) {
    1:                 if (!JS_HAS_STRICT_OPTION(cx)) {
    1:                     /* Just return true per ECMA if not in strict mode. */
27575:                     PCMETER(cacheResult && JS_PROPERTY_CACHE(cx).rofills++);
27932:                     if (cacheResult)
27932:                         TRACE_2(SetPropHit, JS_NO_PROP_CACHE_FILL, sprop);
27932:                     return JS_TRUE;
27934:                 error: // TRACE_2 jumps here in case of error.
27934:                     return JS_FALSE;
    1:                 }
    1: 
    1:                 /* Strict mode: report a read-only strict warning. */
    1:                 flags = JSREPORT_STRICT | JSREPORT_WARNING;
    1:             }
    1:             goto read_only_error;
    1:         }
    1: 
    1:         if (pobj != obj) {
    1:             /*
    1:              * We found id in a prototype object: prepare to share or shadow.
11377:              *
    1:              * NB: Thanks to the immutable, garbage-collected property tree
    1:              * maintained by jsscope.c in cx->runtime, we needn't worry about
    1:              * sprop going away behind our back after we've unlocked scope.
    1:              */
    1:             JS_UNLOCK_SCOPE(cx, scope);
    1: 
27932:             /* Don't clone a shared prototype property. */
    1:             if (attrs & JSPROP_SHARED) {
27932:                 if (cacheResult) {
27932:                     JSPropCacheEntry *entry;
27932:                     entry = js_FillPropertyCache(cx, obj, 0, protoIndex, pobj, sprop, false);
27932:                     TRACE_2(SetPropHit, entry, sprop);
27932:                 }
27932: 
    1:                 if (SPROP_HAS_STUB_SETTER(sprop) &&
    1:                     !(sprop->attrs & JSPROP_GETTER)) {
27932:                     return JS_TRUE;
27932:                 }
27932: 
27932:                 return js_SetSprop(cx, sprop, obj, vp);
    1:             }
    1: 
    1:             /* Restore attrs to the ECMA default for new properties. */
    1:             attrs = JSPROP_ENUMERATE;
    1: 
    1:             /*
    1:              * Preserve the shortid, getter, and setter when shadowing any
    1:              * property that has a shortid.  An old API convention requires
    1:              * that the property's getter and setter functions receive the
    1:              * shortid, not id, when they are called on the shadow we are
    1:              * about to create in obj's scope.
    1:              */
    1:             if (sprop->flags & SPROP_HAS_SHORTID) {
    1:                 flags = SPROP_HAS_SHORTID;
    1:                 shortid = sprop->shortid;
    1:                 getter = sprop->getter;
    1:                 setter = sprop->setter;
    1:             }
    1: 
    1:             /*
    1:              * Forget we found the proto-property now that we've copied any
    1:              * needed member values.
    1:              */
    1:             sprop = NULL;
    1:         }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     } else {
    1:         scope = NULL;
    1: #endif
    1:     }
    1: 
27930:     added = false;
    1:     if (!sprop) {
11377:         /*
11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
11377:          * Do this early, before locking obj to avoid nesting locks.
11377:          */
25936:         js_PurgeScopeChain(cx, obj, id);
11377: 
    1:         /* Find or make a property descriptor with the right heritage. */
    1:         JS_LOCK_OBJ(cx, obj);
    1:         scope = js_GetMutableScope(cx, obj);
    1:         if (!scope) {
    1:             JS_UNLOCK_OBJ(cx, obj);
27932:             return JS_FALSE;
    1:         }
    1:         if (clasp->flags & JSCLASS_SHARE_ALL_PROPERTIES)
    1:             attrs |= JSPROP_SHARED;
    1:         sprop = js_AddScopeProperty(cx, scope, id, getter, setter,
27490:                                     SPROP_INVALID_SLOT, attrs, flags, shortid);
    1:         if (!sprop) {
    1:             JS_UNLOCK_SCOPE(cx, scope);
27932:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Initialize the new property value (passed to setter) to undefined.
    1:          * Note that we store before calling addProperty, to match the order
    1:          * in js_DefineNativeProperty.
    1:          */
    1:         if (SPROP_HAS_VALID_SLOT(sprop, scope))
    1:             LOCKED_OBJ_SET_SLOT(obj, sprop->slot, JSVAL_VOID);
    1: 
    1:         /* XXXbe called with obj locked */
    1:         ADD_PROPERTY_HELPER(cx, clasp, obj, scope, sprop, vp,
    1:                             js_RemoveScopeProperty(cx, scope, id);
    1:                             JS_UNLOCK_SCOPE(cx, scope);
27932:                             return JS_FALSE);
27930:         added = true;
    1:     }
    1: 
27932:     if (cacheResult) {
27932:         JSPropCacheEntry *entry;
27932:         entry = js_FillPropertyCache(cx, obj, 0, 0, obj, sprop, added);
27932:         TRACE_2(SetPropHit, entry, sprop);
27932:     }
27932: 
27490:     if (!js_NativeSet(cx, obj, sprop, vp))
27575:         return NULL;
27575: 
27490:     JS_UNLOCK_SCOPE(cx, scope);
27932:     return JS_TRUE;
    1: 
    1:   read_only_error:
    1:     return js_ReportValueErrorFlags(cx, flags, JSMSG_READ_ONLY,
    1:                                     JSDVG_IGNORE_STACK, ID_TO_VALUE(id), NULL,
27932:                                     NULL, NULL);
    1: }
    1: 
    1: JSBool
11377: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
11377: {
27932:     return js_SetPropertyHelper(cx, obj, id, false, vp);
11377: }
11377: 
11377: JSBool
    1: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp)
    1: {
    1:     JSBool noprop, ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     noprop = !prop;
    1:     if (noprop) {
    1:         if (!js_LookupProperty(cx, obj, id, &obj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             *attrsp = 0;
    1:             return JS_TRUE;
    1:         }
    1:         if (!OBJ_IS_NATIVE(obj)) {
    1:             ok = OBJ_GET_ATTRIBUTES(cx, obj, id, prop, attrsp);
    1:             OBJ_DROP_PROPERTY(cx, obj, prop);
    1:             return ok;
    1:         }
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
    1:     *attrsp = sprop->attrs;
    1:     if (noprop)
    1:         OBJ_DROP_PROPERTY(cx, obj, prop);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp)
    1: {
    1:     JSBool noprop, ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     noprop = !prop;
    1:     if (noprop) {
    1:         if (!js_LookupProperty(cx, obj, id, &obj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop)
    1:             return JS_TRUE;
    1:         if (!OBJ_IS_NATIVE(obj)) {
    1:             ok = OBJ_SET_ATTRIBUTES(cx, obj, id, prop, attrsp);
    1:             OBJ_DROP_PROPERTY(cx, obj, prop);
    1:             return ok;
    1:         }
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
    1:     sprop = js_ChangeNativePropertyAttrs(cx, obj, sprop, *attrsp, 0,
    1:                                          sprop->getter, sprop->setter);
    1:     if (noprop)
    1:         OBJ_DROP_PROPERTY(cx, obj, prop);
    1:     return (sprop != NULL);
    1: }
    1: 
    1: JSBool
    1: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
    1: {
    1:     JSObject *proto;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1:     JSBool ok;
    1: 
    1:     *rval = JSVAL_TRUE;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
    1:     CHECK_FOR_STRING_INDEX(id);
11377: 
    1:     if (!js_LookupProperty(cx, obj, id, &proto, &prop))
    1:         return JS_FALSE;
    1:     if (!prop || proto != obj) {
    1:         /*
    1:          * If the property was found in a native prototype, check whether it's
    1:          * shared and permanent.  Such a property stands for direct properties
    1:          * in all delegating objects, matching ECMA semantics without bloating
    1:          * each delegating object.
    1:          */
    1:         if (prop) {
    1:             if (OBJ_IS_NATIVE(proto)) {
    1:                 sprop = (JSScopeProperty *)prop;
    1:                 if (SPROP_IS_SHARED_PERMANENT(sprop))
    1:                     *rval = JSVAL_FALSE;
    1:             }
    1:             OBJ_DROP_PROPERTY(cx, proto, prop);
    1:             if (*rval == JSVAL_FALSE)
    1:                 return JS_TRUE;
    1:         }
    1: 
    1:         /*
    1:          * If no property, or the property comes unshared or impermanent from
    1:          * a prototype, call the class's delProperty hook, passing rval as the
    1:          * result parameter.
    1:          */
    1:         return OBJ_GET_CLASS(cx, obj)->delProperty(cx, obj, ID_TO_VALUE(id),
    1:                                                    rval);
    1:     }
    1: 
    1:     sprop = (JSScopeProperty *)prop;
    1:     if (sprop->attrs & JSPROP_PERMANENT) {
    1:         OBJ_DROP_PROPERTY(cx, obj, prop);
    1:         *rval = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /* XXXbe called with obj locked */
    1:     if (!LOCKED_OBJ_GET_CLASS(obj)->delProperty(cx, obj, SPROP_USERID(sprop),
    1:                                                 rval)) {
    1:         OBJ_DROP_PROPERTY(cx, obj, prop);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     scope = OBJ_SCOPE(obj);
    1:     if (SPROP_HAS_VALID_SLOT(sprop, scope))
    1:         GC_POKE(cx, LOCKED_OBJ_GET_SLOT(obj, sprop->slot));
    1: 
    1:     ok = js_RemoveScopeProperty(cx, scope, id);
    1:     OBJ_DROP_PROPERTY(cx, obj, prop);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
    1: {
    1:     jsval v, save;
    1:     JSString *str;
    1: 
    1:     v = save = OBJECT_TO_JSVAL(obj);
    1:     switch (hint) {
    1:       case JSTYPE_STRING:
    1:         /*
    1:          * Propagate the exception if js_TryMethod finds an appropriate
    1:          * method, and calling that method returned failure.
    1:          */
    1:         if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0, NULL,
    1:                           &v)) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             if (!OBJ_GET_CLASS(cx, obj)->convert(cx, obj, hint, &v))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       default:
    1:         if (!OBJ_GET_CLASS(cx, obj)->convert(cx, obj, hint, &v))
    1:             return JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             JSType type = JS_TypeOfValue(cx, v);
    1:             if (type == hint ||
    1:                 (type == JSTYPE_FUNCTION && hint == JSTYPE_OBJECT)) {
    1:                 goto out;
    1:             }
    1:             if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0,
    1:                               NULL, &v)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         /* Avoid recursive death when decompiling in js_ReportValueError. */
    1:         if (hint == JSTYPE_STRING) {
    1:             str = JS_InternString(cx, OBJ_GET_CLASS(cx, obj)->name);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:         } else {
    1:             str = NULL;
    1:         }
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO,
    1:                              JSDVG_SEARCH_STACK, save, str,
    1:                              (hint == JSTYPE_VOID)
    1:                              ? "primitive type"
 4342:                              : JS_TYPE_STR(hint));
    1:         return JS_FALSE;
    1:     }
    1: out:
    1:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
15677: /*
17049:  * Private type used to enumerate properties of a native JS object. It is
17049:  * allocated as necessary from JSENUMERATE_INIT and is freed when running the
17049:  * GC. The structure is not allocated when there are no enumerable properties
17049:  * in the object. Instead for the empty enumerator the code uses JSVAL_ZERO as
17049:  * the enumeration state.
17049:  *
17049:  * JSRuntime.nativeEnumCache caches the enumerators using scope's shape to
17049:  * avoid repeated scanning of scopes for enumerable properties. The cache
17049:  * entry is either JSNativeEnumerator* or, for the empty enumerator, the shape
17049:  * value itself. The latter is stored as (shape << 1) | 1 to ensure that it is
17049:  * always different from JSNativeEnumerator* values.
15677:  */
15677: struct JSNativeEnumerator {
17049:     /*
17049:      * The index into the ids array. It runs from the length down to 1 when
17049:      * the enumerator is running. It is 0 when the enumerator is finished and
17049:      * can be reused on a cache hit. Its type is jsword, not uint32, for
17049:      * compatibility with js_CompareAndSwap.
17049:      */
17049:     jsword                  cursor;
17049: 
15677:     uint32                  length;     /* length of ids array */
17049:     uint32                  shape;      /* "shape" number -- see jsscope.h */
17049:     JSNativeEnumerator      *next;      /* list linking */
15677:     jsid                    ids[1];     /* enumeration id array */
15677: };
    1: 
17049: /* The tagging of shape values requires one bit. */
17049: JS_STATIC_ASSERT((jsuword) SHAPE_OVERFLOW_BIT <=
17049:                  ((jsuword) 1 << (JS_BITS_PER_WORD - 1)));
17049: 
17049: static inline size_t
17049: NativeEnumeratorSize(uint32 length)
17049: {
17049:     JS_ASSERT(length != 0);
17049:     return offsetof(JSNativeEnumerator, ids) + (size_t) length * sizeof(jsid);
17049: }
17049: 
    1: /*
    1:  * This function is used to enumerate the properties of native JSObjects
    1:  * and those host objects that do not define a JSNewEnumerateOp-style iterator
    1:  * function.
    1:  */
    1: JSBool
    1: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:              jsval *statep, jsid *idp)
    1: {
    1:     JSClass *clasp;
    1:     JSEnumerateOp enumerate;
15677:     JSNativeEnumerator *ne;
17049:     uint32 length, shape;
17049:     size_t allocated;
    1:     JSScope *scope;
17049:     jsuword *cachep, oldcache;
15677:     JSScopeProperty *sprop;
15677:     jsid *ids;
17049:     jsword newcursor;
15677: 
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     enumerate = clasp->enumerate;
11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
    1:         return ((JSNewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
11835:     }
    1: 
    1:     switch (enum_op) {
    1:       case JSENUMERATE_INIT:
    1:         if (!enumerate(cx, obj))
    1:             return JS_FALSE;
15677: 
15677:         /*
15677:          * The set of all property ids is pre-computed when the iterator is
15677:          * initialized to avoid problems caused by properties being deleted
15677:          * during the iteration.
15677:          *
15677:          * Use a do-while(0) loop to avoid too many nested ifs. If ne is null
17049:          * after the loop, it indicates an empty enumerator. If allocated is
17049:          * not zero after the loop, we add the newly allocated ne to the cache
17049:          * and runtime->nativeEnumerators list.
15677:          */
15677:         ne = NULL;
    1:         length = 0;
17049:         allocated = (size_t) 0;
    1:         JS_LOCK_OBJ(cx, obj);
    1:         scope = OBJ_SCOPE(obj);
15677:         do {
    1:             /*
15677:              * If this object shares a scope with its prototype, don't
15677:              * enumerate its properties. Otherwise they will be enumerated
15677:              * a second time when the prototype object is enumerated.
    1:              */
17049:             if (scope->object != obj) {
17049: #ifdef __GNUC__
17049:                 cachep = NULL;  /* suppress bogus gcc warnings */
17049: #endif
15677:                 break;
17049:             }
17049: 
17049:             ENUM_CACHE_METER(nativeEnumProbes);
17049:             shape = scope->shape;
17049:             JS_ASSERT(shape < SHAPE_OVERFLOW_BIT);
17049:             cachep = &cx->runtime->
17049:                      nativeEnumCache[NATIVE_ENUM_CACHE_HASH(shape)];
17049:             oldcache = *cachep;
17049:             if (oldcache & (jsuword) 1) {
17049:                 if ((uint32) (oldcache >> 1) == shape) {
17049:                     /* scope has a shape with no enumerable properties. */
17049:                     break;
17049:                 }
17049:             } else if (oldcache != (jsuword) 0) {
17049:                 /*
17049:                  * We can safely read ne->shape without taking the GC lock as
17049:                  * ne is deleted only when running the GC and ne->shape is
17049:                  * read-only after initialization.
17049:                  */
17049:                 ne = (JSNativeEnumerator *) *cachep;
17049:                 JS_ASSERT(ne->length >= 1);
17049:                 if (ne->shape == shape) {
17049:                     /*
17049:                      * Check that ne is not running with another enumerator
17049:                      * and, if so, reuse and mark it as running from now.
17049:                      */
17049:                     length = ne->length;
17049:                     if (js_CompareAndSwap(&ne->cursor, 0, length))
17049:                         break;
17049:                     length = 0;
17049:                 }
17049:                 ne = NULL;
17049:             }
17049:             ENUM_CACHE_METER(nativeEnumMisses);
15677: 
15677:             /* Count all enumerable properties in object's scope. */
17049:             JS_ASSERT(length == 0);
15677:             for (sprop = SCOPE_LAST_PROP(scope); sprop; sprop = sprop->parent) {
 9090:                 if ((sprop->attrs & JSPROP_ENUMERATE) &&
    1:                     !(sprop->flags & SPROP_IS_ALIAS) &&
    1:                     (!SCOPE_HAD_MIDDLE_DELETE(scope) ||
    1:                      SCOPE_HAS_PROPERTY(scope, sprop))) {
    1:                     length++;
    1:                 }
    1:             }
17049:             if (length == 0) {
17049:                 /* cache the scope without enumerable properties. */
17049:                 *cachep = ((jsuword) shape << 1) | (jsuword) 1;
15677:                 break;
17049:             }
17049: 
17049:             allocated = NativeEnumeratorSize(length);
17049:             ne = (JSNativeEnumerator *) JS_malloc(cx, allocated);
15677:             if (!ne) {
15677:                 JS_UNLOCK_SCOPE(cx, scope);
    1:                 return JS_FALSE;
    1:             }
15677:             ne->cursor = length;
15677:             ne->length = length;
17049:             ne->shape = shape;
15677:             ids = ne->ids;
15677:             for (sprop = SCOPE_LAST_PROP(scope); sprop; sprop = sprop->parent) {
 9090:                 if ((sprop->attrs & JSPROP_ENUMERATE) &&
    1:                     !(sprop->flags & SPROP_IS_ALIAS) &&
    1:                     (!SCOPE_HAD_MIDDLE_DELETE(scope) ||
    1:                      SCOPE_HAS_PROPERTY(scope, sprop))) {
15677:                     JS_ASSERT(ids < ne->ids + length);
15677:                     *ids++ = sprop->id;
15677:                 }
15677:             }
15677:             JS_ASSERT(ids == ne->ids + length);
15677:         } while (0);
15677:         JS_UNLOCK_SCOPE(cx, scope);
15677: 
15677:         if (!ne) {
15677:             JS_ASSERT(length == 0);
17049:             JS_ASSERT(allocated == 0);
15677:             *statep = JSVAL_ZERO;
15677:         } else {
15677:             JS_ASSERT(length != 0);
18316:             JS_ASSERT(ne->cursor == (jsword) length);
17049:             if (allocated != 0) {
15677:                 JS_LOCK_GC(cx->runtime);
17049:                 if (!js_AddAsGCBytes(cx, allocated)) {
17049:                     /* js_AddAsGCBytes releases the GC lock on failures. */
17049:                     JS_free(cx, ne);
17049:                     return JS_FALSE;
17049:                 }
15677:                 ne->next = cx->runtime->nativeEnumerators;
17049:                 cx->runtime->nativeEnumerators = ne;
17049:                 JS_ASSERT(((jsuword) ne & (jsuword) 1) == (jsuword) 0);
17049:                 *cachep = (jsuword) ne;
15677:                 JS_UNLOCK_GC(cx->runtime);
17049:             }
15677:             *statep = PRIVATE_TO_JSVAL(ne);
15677:         }
17049:         if (idp)
17049:             *idp = INT_TO_JSVAL(length);
    1:         break;
    1: 
    1:       case JSENUMERATE_NEXT:
15677:       case JSENUMERATE_DESTROY:
17049:         if (*statep == JSVAL_ZERO) {
17049:             *statep = JSVAL_NULL;
17049:             break;
17049:         }
15677:         ne = (JSNativeEnumerator *) JSVAL_TO_PRIVATE(*statep);
15677:         JS_ASSERT(ne->length >= 1);
17049:         JS_ASSERT(ne->cursor >= 1);
17049: 
17049:         /*
17049:          * We must not access ne->cursor when we set it to zero as it means
17049:          * that ne is free and another thread can grab it from the cache. So
17049:          * we set the state to JSVAL_ZERO in the NEXT case to avoid touching
17049:          * ne->length again in the DESTROY case.
17049:          */
17049:         if (enum_op == JSENUMERATE_NEXT) {
17049:             newcursor = ne->cursor - 1;
17049:             *idp = ne->ids[newcursor];
17049:             ne->cursor = newcursor;
17049:             if (newcursor == 0)
17049:                 *statep = JSVAL_ZERO;
17049:         } else {
17049:             /* The enumerator has not iterated over all ids. */
29865:             JS_ASSERT(enum_op == JSENUMERATE_DESTROY);
17049:             ne->cursor = 0;
29865: 
29865:             /*
29865:              * Force on shutdown an extra GC cycle so all native enumerators
29865:              * on the rt->nativeEnumerators list will be removed when the GC
29865:              * calls js_TraceNativeEnumerators. See bug 499570.
29865:              */
29865:             if (cx->runtime->state == JSRTS_LANDING)
29865:                 cx->runtime->gcPoke = true;
17049:         }
    1:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
15613: js_TraceNativeEnumerators(JSTracer *trc)
    1: {
17049:     JSRuntime *rt;
17049:     JSNativeEnumerator **nep, *ne;
15677:     jsid *cursor, *end;
15677: 
17049:     /*
17049:      * Purge native enumerators cached by shape id, which we are about to
17049:      * re-number completely when tracing is done for the GC.
17049:      */
17049:     rt = trc->context->runtime;
17049:     if (IS_GC_MARKING_TRACER(trc)) {
17049:         memset(&rt->nativeEnumCache, 0, sizeof rt->nativeEnumCache);
17049: #ifdef JS_DUMP_ENUM_CACHE_STATS
17049:         printf("nativeEnumCache hit rate %g%%\n",
17049:                100.0 * (rt->nativeEnumProbes - rt->nativeEnumMisses) /
17049:                rt->nativeEnumProbes);
17049: #endif
17049:     }
17049: 
17049:     nep = &rt->nativeEnumerators;
17049:     while ((ne = *nep) != NULL) {
17049:         JS_ASSERT(ne->length != 0);
17049:         if (ne->cursor != 0) {
17049:             /* Trace ids of the running enumerator. */
17049:             cursor = ne->ids;
17049:             end = cursor + ne->length;
17049:             do {
15677:                 TRACE_ID(trc, *cursor);
17049:             } while (++cursor != end);
17049:         } else if (IS_GC_MARKING_TRACER(trc)) {
17049:             js_RemoveAsGCBytes(rt, NativeEnumeratorSize(ne->length));
17049:             *nep = ne->next;
17049:             JS_free(trc->context, ne);
17049:             continue;
17049:         }
17049:         nep = &ne->next;
15677:     }
    1: }
    1: 
    1: JSBool
    1: js_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp)
    1: {
    1:     JSBool writing;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSClass *clasp;
    1:     JSScopeProperty *sprop;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSCheckAccessOp check;
    1: 
    1:     writing = (mode & JSACC_WRITE) != 0;
    1:     switch (mode & JSACC_TYPEMASK) {
    1:       case JSACC_PROTO:
    1:         pobj = obj;
    1:         if (!writing)
    1:             *vp = OBJECT_TO_JSVAL(OBJ_GET_PROTO(cx, obj));
    1:         *attrsp = JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       case JSACC_PARENT:
    1:         JS_ASSERT(!writing);
    1:         pobj = obj;
    1:         *vp = OBJECT_TO_JSVAL(OBJ_GET_PARENT(cx, obj));
    1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       default:
11842:         if (!OBJ_LOOKUP_PROPERTY(cx, obj, id, &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             if (!writing)
    1:                 *vp = JSVAL_VOID;
    1:             *attrsp = 0;
11842:             pobj = obj;
11842:             break;
11842:         }
11842: 
    1:         if (!OBJ_IS_NATIVE(pobj)) {
    1:             OBJ_DROP_PROPERTY(cx, pobj, prop);
11842: 
11842:             /* Avoid diverging for non-natives that reuse js_CheckAccess. */
11961:             if (pobj->map->ops->checkAccess == js_CheckAccess) {
16403:                 if (!writing) {
11961:                     *vp = JSVAL_VOID;
16403:                     *attrsp = 0;
16403:                 }
11842:                 break;
11961:             }
    1:             return OBJ_CHECK_ACCESS(cx, pobj, id, mode, vp, attrsp);
    1:         }
    1: 
    1:         sprop = (JSScopeProperty *)prop;
    1:         *attrsp = sprop->attrs;
    1:         if (!writing) {
    1:             *vp = (SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(pobj)))
    1:                   ? LOCKED_OBJ_GET_SLOT(pobj, sprop->slot)
    1:                   : JSVAL_VOID;
    1:         }
    1:         OBJ_DROP_PROPERTY(cx, pobj, prop);
    1:     }
    1: 
    1:     /*
    1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
    1:      * checkObjectAccess callback, if configured.
    1:      *
    1:      * We don't want to require all classes to supply a checkAccess hook; we
    1:      * need that hook only for certain classes used when precompiling scripts
    1:      * and functions ("brutal sharing").  But for general safety of built-in
    1:      * magic properties such as __proto__ and __parent__, we route all access
    1:      * checks, even for classes that stub out checkAccess, through the global
    1:      * checkObjectAccess hook.  This covers precompilation-based sharing and
    1:      * (possibly unintended) runtime sharing across trust boundaries.
    1:      */
    1:     clasp = OBJ_GET_CLASS(cx, pobj);
    1:     check = clasp->checkAccess;
18870:     if (!check) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
18870:         check = callbacks ? callbacks->checkObjectAccess : NULL;
18870:     }
    1:     return !check || check(cx, pobj, ID_TO_VALUE(id), mode, vp);
    1: }
    1: 
    1: #ifdef JS_THREADSAFE
    1: void
    1: js_DropProperty(JSContext *cx, JSObject *obj, JSProperty *prop)
    1: {
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: #endif
    1: 
    1: #ifdef NARCISSUS
    1: static JSBool
    1: GetCurrentExecutionContext(JSContext *cx, JSObject *obj, jsval *rval)
    1: {
    1:     JSObject *tmp;
    1:     jsval xcval;
    1: 
    1:     while ((tmp = OBJ_GET_PARENT(cx, obj)) != NULL)
    1:         obj = tmp;
    1:     if (!OBJ_GET_PROPERTY(cx, obj,
    1:                           ATOM_TO_JSID(cx->runtime->atomState
    1:                                        .ExecutionContextAtom),
    1:                           &xcval)) {
    1:         return JS_FALSE;
    1:     }
    1:     if (JSVAL_IS_PRIMITIVE(xcval)) {
    1:         JS_ReportError(cx, "invalid ExecutionContext in global object");
    1:         return JS_FALSE;
    1:     }
    1:     if (!OBJ_GET_PROPERTY(cx, JSVAL_TO_OBJECT(xcval),
    1:                           ATOM_TO_JSID(cx->runtime->atomState.currentAtom),
    1:                           rval)) {
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: JSBool
    1: js_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(argv[-2]));
    1:     if (!clasp->call) {
    1: #ifdef NARCISSUS
    1:         JSObject *callee, *args;
    1:         jsval fval, nargv[3];
    1:         JSBool ok;
    1: 
    1:         callee = JSVAL_TO_OBJECT(argv[-2]);
    1:         if (!OBJ_GET_PROPERTY(cx, callee,
21471:                               ATOM_TO_JSID(cx->runtime->atomState.__call__Atom),
    1:                               &fval)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (VALUE_IS_FUNCTION(cx, fval)) {
    1:             if (!GetCurrentExecutionContext(cx, obj, &nargv[2]))
    1:                 return JS_FALSE;
22652:             args = js_GetArgsObject(cx, js_GetTopStackFrame(cx));
    1:             if (!args)
    1:                 return JS_FALSE;
    1:             nargv[0] = OBJECT_TO_JSVAL(obj);
    1:             nargv[1] = OBJECT_TO_JSVAL(args);
    1:             return js_InternalCall(cx, callee, fval, 3, nargv, rval);
    1:         }
    1:         if (JSVAL_IS_OBJECT(fval) && JSVAL_TO_OBJECT(fval) != callee) {
    1:             argv[-2] = fval;
    1:             ok = js_Call(cx, obj, argc, argv, rval);
    1:             argv[-2] = OBJECT_TO_JSVAL(callee);
    1:             return ok;
    1:         }
    1: #endif
22652:         js_ReportIsNotFunction(cx, &argv[-2], js_GetTopStackFrame(cx)->flags & JSFRAME_ITERATOR);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->call(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:              jsval *rval)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(argv[-2]));
    1:     if (!clasp->construct) {
    1: #ifdef NARCISSUS
    1:         JSObject *callee, *args;
    1:         jsval cval, nargv[2];
    1:         JSBool ok;
    1: 
    1:         callee = JSVAL_TO_OBJECT(argv[-2]);
    1:         if (!OBJ_GET_PROPERTY(cx, callee,
    1:                               ATOM_TO_JSID(cx->runtime->atomState
21471:                                            .__construct__Atom),
    1:                               &cval)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (VALUE_IS_FUNCTION(cx, cval)) {
    1:             if (!GetCurrentExecutionContext(cx, obj, &nargv[1]))
    1:                 return JS_FALSE;
22652:             args = js_GetArgsObject(cx, js_GetTopStackFrame(cx));
    1:             if (!args)
    1:                 return JS_FALSE;
    1:             nargv[0] = OBJECT_TO_JSVAL(args);
    1:             return js_InternalCall(cx, callee, cval, 2, nargv, rval);
    1:         }
    1:         if (JSVAL_IS_OBJECT(cval) && JSVAL_TO_OBJECT(cval) != callee) {
    1:             argv[-2] = cval;
    1:             ok = js_Call(cx, obj, argc, argv, rval);
    1:             argv[-2] = OBJECT_TO_JSVAL(callee);
    1:             return ok;
    1:         }
    1: #endif
 4521:         js_ReportIsNotFunction(cx, &argv[-2], JSV2F_CONSTRUCT);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->construct(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     JSClass *clasp;
    1: 
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     if (clasp->hasInstance)
    1:         return clasp->hasInstance(cx, obj, v, bp);
    1: #ifdef NARCISSUS
    1:     {
    1:         jsval fval, rval;
    1: 
    1:         if (!OBJ_GET_PROPERTY(cx, obj,
    1:                               ATOM_TO_JSID(cx->runtime->atomState
21471:                                            .__hasInstance__Atom),
    1:                               &fval)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (VALUE_IS_FUNCTION(cx, fval)) {
10525:             if (!js_InternalCall(cx, obj, fval, 1, &v, &rval))
10525:                 return JS_FALSE;
10525:             *bp = js_ValueToBoolean(rval);
10525:             return JS_TRUE;
    1:         }
    1:     }
    1: #endif
    1:     js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
    1:                         JSDVG_SEARCH_STACK, OBJECT_TO_JSVAL(obj), NULL);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_IsDelegate(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     JSObject *obj2;
    1: 
    1:     *bp = JS_FALSE;
    1:     if (JSVAL_IS_PRIMITIVE(v))
    1:         return JS_TRUE;
    1:     obj2 = JSVAL_TO_OBJECT(v);
    1:     while ((obj2 = OBJ_GET_PROTO(cx, obj2)) != NULL) {
    1:         if (obj2 == obj) {
    1:             *bp = JS_TRUE;
    1:             break;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_GetClassPrototype(JSContext *cx, JSObject *scope, jsid id,
    1:                      JSObject **protop)
    1: {
    1:     jsval v;
    1:     JSObject *ctor;
    1: 
    1:     if (!js_FindClassObject(cx, scope, id, &v))
    1:         return JS_FALSE;
    1:     if (VALUE_IS_FUNCTION(cx, v)) {
    1:         ctor = JSVAL_TO_OBJECT(v);
    1:         if (!OBJ_GET_PROPERTY(cx, ctor,
    1:                               ATOM_TO_JSID(cx->runtime->atomState
    1:                                            .classPrototypeAtom),
    1:                               &v)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             /*
    1:              * Set the newborn root in case v is otherwise unreferenced.
    1:              * It's ok to overwrite newborn roots here, since the getter
    1:              * called just above could have.  Unlike the common GC rooting
    1:              * model, our callers do not have to protect protop thanks to
    1:              * this newborn root, since they all immediately create a new
    1:              * instance that delegates to this object, or just query the
    1:              * prototype for its class.
    1:              */
 5917:             cx->weakRoots.newborn[GCX_OBJECT] = JSVAL_TO_GCTHING(v);
    1:         }
    1:     }
    1:     *protop = JSVAL_IS_OBJECT(v) ? JSVAL_TO_OBJECT(v) : NULL;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * For shared precompilation of function objects, we support cloning on entry
    1:  * to an execution context in which the function declaration or expression
    1:  * should be processed as if it were not precompiled, where the precompiled
    1:  * function's scope chain does not match the execution context's.  The cloned
    1:  * function object carries its execution-context scope in its parent slot; it
    1:  * links to the precompiled function (the "clone-parent") via its proto slot.
    1:  *
    1:  * Note that this prototype-based delegation leaves an unchecked access path
    1:  * from the clone to the clone-parent's 'constructor' property.  If the clone
    1:  * lives in a less privileged or shared scope than the clone-parent, this is
    1:  * a security hole, a sharing hazard, or both.  Therefore we check all such
    1:  * accesses with the following getter/setter pair, which we use when defining
    1:  * 'constructor' in f.prototype for all function objects f.
    1:  */
    1: static JSBool
    1: CheckCtorGetAccess(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1:     uintN attrs;
    1: 
    1:     atom = cx->runtime->atomState.constructorAtom;
 4529:     JS_ASSERT(id == ATOM_TO_JSID(atom));
    1:     return OBJ_CHECK_ACCESS(cx, obj, ATOM_TO_JSID(atom), JSACC_READ,
    1:                             vp, &attrs);
    1: }
    1: 
    1: static JSBool
    1: CheckCtorSetAccess(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1:     uintN attrs;
    1: 
    1:     atom = cx->runtime->atomState.constructorAtom;
 4529:     JS_ASSERT(id == ATOM_TO_JSID(atom));
    1:     return OBJ_CHECK_ACCESS(cx, obj, ATOM_TO_JSID(atom), JSACC_WRITE,
    1:                             vp, &attrs);
    1: }
    1: 
    1: JSBool
    1: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto,
    1:                      uintN attrs)
    1: {
    1:     /*
    1:      * Use the given attributes for the prototype property of the constructor,
    1:      * as user-defined constructors have a DontDelete prototype (which may be
    1:      * reset), while native or "system" constructors have DontEnum | ReadOnly |
    1:      * DontDelete.
    1:      */
    1:     if (!OBJ_DEFINE_PROPERTY(cx, ctor,
    1:                              ATOM_TO_JSID(cx->runtime->atomState
    1:                                           .classPrototypeAtom),
    1:                              OBJECT_TO_JSVAL(proto),
    1:                              JS_PropertyStub, JS_PropertyStub,
    1:                              attrs, NULL)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * ECMA says that Object.prototype.constructor, or f.prototype.constructor
    1:      * for a user-defined function f, is DontEnum.
    1:      */
    1:     return OBJ_DEFINE_PROPERTY(cx, proto,
    1:                                ATOM_TO_JSID(cx->runtime->atomState
    1:                                             .constructorAtom),
    1:                                OBJECT_TO_JSVAL(ctor),
    1:                                CheckCtorGetAccess, CheckCtorSetAccess,
    1:                                0, NULL);
    1: }
    1: 
    1: JSBool
 2383: js_PrimitiveToObject(JSContext *cx, jsval *vp)
 2383: {
 2383:     JSClass *clasp;
 2383:     JSObject *obj;
 2383: 
 2383:     /* Table to map primitive value's tag into the corresponding class. */
 2383:     JS_STATIC_ASSERT(JSVAL_INT == 1);
 2383:     JS_STATIC_ASSERT(JSVAL_DOUBLE == 2);
 2383:     JS_STATIC_ASSERT(JSVAL_STRING == 4);
 2383:     JS_STATIC_ASSERT(JSVAL_BOOLEAN == 6);
 2383:     static JSClass *const PrimitiveClasses[] = {
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_NumberClass,    /* DOUBLE  */
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_StringClass,    /* STRING  */
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_BooleanClass,   /* BOOLEAN */
 2383:         &js_NumberClass     /* INT     */
 2383:     };
 2383: 
 2383:     JS_ASSERT(!JSVAL_IS_OBJECT(*vp));
15521:     JS_ASSERT(!JSVAL_IS_VOID(*vp));
 2383:     clasp = PrimitiveClasses[JSVAL_TAG(*vp) - 1];
13427:     obj = js_NewObject(cx, clasp, NULL, NULL, 0);
 2383:     if (!obj)
 2383:         return JS_FALSE;
11377:     STOBJ_SET_SLOT(obj, JSSLOT_PRIVATE, *vp);
 2383:     *vp = OBJECT_TO_JSVAL(obj);
 2383:     return JS_TRUE;
 2383: }
 2383: 
 2383: JSBool
    1: js_ValueToObject(JSContext *cx, jsval v, JSObject **objp)
    1: {
    1:     JSObject *obj;
    1: 
    1:     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v)) {
    1:         obj = NULL;
    1:     } else if (JSVAL_IS_OBJECT(v)) {
    1:         obj = JSVAL_TO_OBJECT(v);
    1:         if (!OBJ_DEFAULT_VALUE(cx, obj, JSTYPE_OBJECT, &v))
    1:             return JS_FALSE;
26017:         if (!JSVAL_IS_PRIMITIVE(v))
    1:             obj = JSVAL_TO_OBJECT(v);
    1:     } else {
 2383:         if (!js_PrimitiveToObject(cx, &v))
    1:             return JS_FALSE;
 2383:         obj = JSVAL_TO_OBJECT(v);
    1:     }
    1:     *objp = obj;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_ValueToNonNullObject(JSContext *cx, jsval v)
    1: {
    1:     JSObject *obj;
    1: 
    1:     if (!js_ValueToObject(cx, v, &obj))
    1:         return NULL;
 7897:     if (!obj)
 7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
    1:     return obj;
    1: }
    1: 
    1: JSBool
    1: js_TryValueOf(JSContext *cx, JSObject *obj, JSType type, jsval *rval)
    1: {
    1:     jsval argv[1];
    1: 
    1:     argv[0] = ATOM_KEY(cx->runtime->atomState.typeAtoms[type]);
    1:     return js_TryMethod(cx, obj, cx->runtime->atomState.valueOfAtom, 1, argv,
    1:                         rval);
    1: }
    1: 
    1: JSBool
    1: js_TryMethod(JSContext *cx, JSObject *obj, JSAtom *atom,
    1:              uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSErrorReporter older;
    1:     jsid id;
    1:     jsval fval;
    1:     JSBool ok;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     /*
    1:      * Report failure only if an appropriate method was found, and calling it
    1:      * returned failure.  We propagate failure in this case to make exceptions
    1:      * behave properly.
    1:      */
    1:     older = JS_SetErrorReporter(cx, NULL);
    1:     id = ATOM_TO_JSID(atom);
    1:     fval = JSVAL_VOID;
27575:     ok = js_GetMethod(cx, obj, id, false, &fval);
    1:     if (!ok)
    1:         JS_ClearPendingException(cx);
    1:     JS_SetErrorReporter(cx, older);
    1: 
24499:     if (JSVAL_IS_PRIMITIVE(fval))
24499:         return JS_TRUE;
24499:     return js_InternalCall(cx, obj, fval, argc, argv, rval);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSAtom *atom;
    1:     JSClass *clasp;
    1:     uint32 classId, classDef;
    1:     JSProtoKey protoKey;
    1:     jsid classKey;
    1:     JSObject *proto;
    1: 
    1:     cx = xdr->cx;
    1:     atom = NULL;
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         clasp = OBJ_GET_CLASS(cx, *objp);
    1:         classId = JS_XDRFindClassIdByName(xdr, clasp->name);
    1:         classDef = !classId;
    1:         if (classDef) {
    1:             if (!JS_XDRRegisterClass(xdr, clasp, &classId))
    1:                 return JS_FALSE;
    1:             protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:             if (protoKey != JSProto_Null) {
    1:                 classDef |= (protoKey << 1);
    1:             } else {
    1:                 atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         clasp = NULL;           /* quell GCC overwarning */
    1:         classDef = 0;
    1:     }
    1: 
    1:     /*
    1:      * XDR a flag word, which could be 0 for a class use, in which case no
    1:      * name follows, only the id in xdr's class registry; 1 for a class def,
    1:      * in which case the flag word is followed by the class name transferred
    1:      * from or to atom; or a value greater than 1, an odd number that when
    1:      * divided by two yields the JSProtoKey for class.  In the last case, as
    1:      * in the 0 classDef case, no name is transferred via atom.
    1:      */
    1:     if (!JS_XDRUint32(xdr, &classDef))
    1:         return JS_FALSE;
 4875:     if (classDef == 1 && !js_XDRStringAtom(xdr, &atom))
    1:         return JS_FALSE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &classId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         if (classDef) {
    1:             /* NB: we know that JSProto_Null is 0 here, for backward compat. */
 3164:             protoKey = (JSProtoKey) (classDef >> 1);
    1:             classKey = (protoKey != JSProto_Null)
    1:                        ? INT_TO_JSID(protoKey)
    1:                        : ATOM_TO_JSID(atom);
    1:             if (!js_GetClassPrototype(cx, NULL, classKey, &proto))
    1:                 return JS_FALSE;
    1:             clasp = OBJ_GET_CLASS(cx, proto);
    1:             if (!JS_XDRRegisterClass(xdr, clasp, &classId))
    1:                 return JS_FALSE;
    1:         } else {
    1:             clasp = JS_XDRFindClassById(xdr, classId);
    1:             if (!clasp) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)classId);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_FIND_CLASS, numBuf);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!clasp->xdrObject) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_XDR_CLASS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->xdrObject(xdr, objp);
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
10217: #ifdef JS_DUMP_SCOPE_METERS
    1: 
    1: #include <stdio.h>
10217: 
10217: JSBasicStats js_entry_count_bs = JS_INIT_STATIC_BASIC_STATS;
    1: 
    1: static void
    1: MeterEntryCount(uintN count)
    1: {
10217:     JS_BASIC_STATS_ACCUM(&js_entry_count_bs, count);
10217: }
10217: 
    1: void
    1: js_DumpScopeMeters(JSRuntime *rt)
    1: {
    1:     static FILE *logfp;
    1:     if (!logfp)
    1:         logfp = fopen("/tmp/scope.stats", "a");
    1: 
    1:     {
10217:         double mean, sigma;
10217: 
10217:         mean = JS_MeanAndStdDevBS(&js_entry_count_bs, &sigma);
10217: 
10217:         fprintf(logfp, "scopes %u entries %g mean %g sigma %g max %u",
10217:                 js_entry_count_bs.num, js_entry_count_bs.sum, mean, sigma,
10217:                 js_entry_count_bs.max);
10217:     }
10217: 
10217:     JS_DumpHistogram(&js_entry_count_bs, logfp);
10217:     JS_BASIC_STATS_INIT(&js_entry_count_bs);
    1:     fflush(logfp);
    1: }
    1: #endif
    1: 
  583: #ifdef DEBUG
11835: void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
  583: {
  583:     JSObject *obj;
  583:     uint32 slot;
  583:     JSScope *scope;
  583:     jsval nval;
  583:     JSScopeProperty *sprop;
  583:     JSClass *clasp;
  583:     uint32 key;
  583:     const char *slotname;
  583: 
11835:     JS_ASSERT(trc->debugPrinter == js_PrintObjectSlotName);
  583:     obj = (JSObject *)trc->debugPrintArg;
  583:     slot = (uint32)trc->debugPrintIndex;
  583: 
11835:     if (OBJ_IS_NATIVE(obj)) {
  583:         scope = OBJ_SCOPE(obj);
  583:         sprop = SCOPE_LAST_PROP(scope);
  583:         while (sprop && sprop->slot != slot)
  583:             sprop = sprop->parent;
11835:     } else {
11835:         sprop = NULL;
11835:     }
  583: 
  583:     if (!sprop) {
  583:         switch (slot) {
  583:           case JSSLOT_PROTO:
  583:             JS_snprintf(buf, bufsize, "__proto__");
  583:             break;
  583:           case JSSLOT_PARENT:
  583:             JS_snprintf(buf, bufsize, "__parent__");
  583:             break;
  583:           default:
  583:             slotname = NULL;
  583:             clasp = LOCKED_OBJ_GET_CLASS(obj);
  583:             if (clasp->flags & JSCLASS_IS_GLOBAL) {
  583:                 key = slot - JSSLOT_START(clasp);
  583: #define JS_PROTO(name,code,init) \
  583:     if ((code) == key) { slotname = js_##name##_str; goto found; }
  583: #include "jsproto.tbl"
  583: #undef JS_PROTO
  583:             }
  583:           found:
  583:             if (slotname)
  583:                 JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
  583:             else
  583:                 JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
  583:             break;
  583:         }
  583:     } else {
  583:         nval = ID_TO_VALUE(sprop->id);
  583:         if (JSVAL_IS_INT(nval)) {
  583:             JS_snprintf(buf, bufsize, "%ld", (long)JSVAL_TO_INT(nval));
  583:         } else if (JSVAL_IS_STRING(nval)) {
  583:             js_PutEscapedString(buf, bufsize, JSVAL_TO_STRING(nval), 0);
  583:         } else {
  583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
  583:         }
  583:     }
  583: }
  583: #endif
  583: 
  583: void
  583: js_TraceObject(JSTracer *trc, JSObject *obj)
    1: {
11377:     JSContext *cx;
    1:     JSScope *scope;
11377:     JSBool traceScope;
    1:     JSScopeProperty *sprop;
    1:     JSClass *clasp;
  583:     size_t nslots, i;
  583:     jsval v;
    1: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
11377:     cx = trc->context;
    1:     scope = OBJ_SCOPE(obj);
11377: 
11377:     traceScope = (scope->object == obj);
11377:     if (!traceScope) {
11377:         JSObject *pobj = obj;
11377: 
11377:         /*
11377:          * Because obj does not own scope, we should be able to assert that an
11377:          * object on obj's prototype chain does -- or scope's properties might
11377:          * go untraced. It indeed turns out that you can disconnect an object
11377:          * from the prototype object whose scope it shares, so we may have to
11377:          * mark scope even though scope->object != obj.
11377:          */
11377:         while ((pobj = LOCKED_OBJ_GET_PROTO(pobj)) != NULL) {
11377:             if (pobj == scope->object)
11377:                 break;
11377:         }
11377:         JS_ASSERT_IF(pobj, OBJ_SCOPE(pobj) == scope);
11377:         traceScope = !pobj;
11377:     }
11377: 
11377:     if (traceScope) {
10217: #ifdef JS_DUMP_SCOPE_METERS
    1:         MeterEntryCount(scope->entryCount);
    1: #endif
    1: 
11377:         sprop = SCOPE_LAST_PROP(scope);
11377:         if (sprop) {
11377:             JS_ASSERT(SCOPE_HAS_PROPERTY(scope, sprop));
11377: 
11377:             /* Regenerate property cache shape ids if GC'ing. */
11377:             if (IS_GC_MARKING_TRACER(trc)) {
11377:                 uint32 shape, oldshape;
11377: 
27546:                 shape = js_RegenerateShapeForGC(cx);
11377:                 if (!(sprop->flags & SPROP_MARK)) {
11377:                     oldshape = sprop->shape;
11377:                     sprop->shape = shape;
11377:                     sprop->flags |= SPROP_FLAG_SHAPE_REGEN;
27546:                     if (scope->shape != oldshape)
27546:                         shape = js_RegenerateShapeForGC(cx);
11377:                 }
11377: 
11377:                 scope->shape = shape;
11377:             }
11377: 
11377:             /* Trace scope's property tree ancestor line. */
11377:             do {
11377:                 if (SCOPE_HAD_MIDDLE_DELETE(scope) &&
11377:                     !SCOPE_HAS_PROPERTY(scope, sprop)) {
    1:                     continue;
11377:                 }
  583:                 TRACE_SCOPE_PROPERTY(trc, sprop);
11377:             } while ((sprop = sprop->parent) != NULL);
11377:         }
    1:     }
    1: 
 5816:     if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList))
 5816:         js_TraceWatchPoints(trc, obj);
    1: 
    1:     /* No one runs while the GC is running, so we can use LOCKED_... here. */
    1:     clasp = LOCKED_OBJ_GET_CLASS(obj);
  583:     if (clasp->mark) {
  583:         if (clasp->flags & JSCLASS_MARK_IS_TRACE)
11377:             ((JSTraceOp) clasp->mark)(trc, obj);
  583:         else if (IS_GC_MARKING_TRACER(trc))
  583:             (void) clasp->mark(cx, obj, trc);
  583:     }
    1: 
    1:     /*
11377:      * An unmutated object that shares a prototype object's scope. We can't
11377:      * tell how many slots are in use in obj by looking at its scope, so we
11377:      * use STOBJ_NSLOTS(obj).
11377:      *
11377:      * NB: In case clasp->mark mutates something, leave this code here --
11377:      * don't move it up and unify it with the |if (!traceScope)| section
11377:      * above.
    1:      */
  583:     nslots = STOBJ_NSLOTS(obj);
28353:     if (scope->object == obj && scope->freeslot < nslots)
28353:         nslots = scope->freeslot;
  583: 
  583:     for (i = 0; i != nslots; ++i) {
  583:         v = STOBJ_GET_SLOT(obj, i);
  583:         if (JSVAL_IS_TRACEABLE(v)) {
11835:             JS_SET_TRACING_DETAILS(trc, js_PrintObjectSlotName, obj, i);
  583:             JS_CallTracer(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
  583:         }
  583:     }
    1: }
    1: 
    1: void
    1: js_Clear(JSContext *cx, JSObject *obj)
    1: {
    1:     JSScope *scope;
    1:     uint32 i, n;
    1: 
    1:     /*
    1:      * Clear our scope and the property cache of all obj's properties only if
    1:      * obj owns the scope (i.e., not if obj is unmutated and therefore sharing
    1:      * its prototype's scope).  NB: we do not clear any reserved slots lying
    1:      * below JSSLOT_FREE(clasp).
    1:      */
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = OBJ_SCOPE(obj);
    1:     if (scope->object == obj) {
    1:         /* Now that we're done using scope->lastProp/table, clear scope. */
    1:         js_ClearScope(cx, scope);
    1: 
    1:         /* Clear slot values and reset freeslot so we're consistent. */
    1:         i = STOBJ_NSLOTS(obj);
    1:         n = JSSLOT_FREE(LOCKED_OBJ_GET_CLASS(obj));
    1:         while (--i >= n)
    1:             STOBJ_SET_SLOT(obj, i, JSVAL_VOID);
28353:         scope->freeslot = n;
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: 
    1: jsval
    1: js_GetRequiredSlot(JSContext *cx, JSObject *obj, uint32 slot)
    1: {
    1:     jsval v;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     v = (slot < STOBJ_NSLOTS(obj)) ? STOBJ_GET_SLOT(obj, slot) : JSVAL_VOID;
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return v;
    1: }
    1: 
    1: JSBool
    1: js_SetRequiredSlot(JSContext *cx, JSObject *obj, uint32 slot, jsval v)
    1: {
    1:     JSScope *scope;
    1:     uint32 nslots;
    1:     JSClass *clasp;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = OBJ_SCOPE(obj);
    1:     if (slot >= JS_INITIAL_NSLOTS && !obj->dslots) {
    1:         /*
    1:          * At this point, obj may or may not own scope.  If some path calls
    1:          * js_GetMutableScope but does not add a slot-owning property, then
    1:          * scope->object == obj but obj->dslots will be null. If obj shares a
    1:          * prototype's scope, then we cannot update scope->map here. Instead
    1:          * we rely on STOBJ_NSLOTS(obj) to get the number of available slots
    1:          * in obj after we allocate dynamic slots.
    1:          *
  583:          * See js_TraceObject, before the slot tracing, where we make a special
  583:          * case for unmutated (scope->object != obj) objects.
    1:          */
    1:         clasp = LOCKED_OBJ_GET_CLASS(obj);
    1:         nslots = JSSLOT_FREE(clasp);
    1:         if (clasp->reserveSlots)
    1:             nslots += clasp->reserveSlots(cx, obj);
    1:         JS_ASSERT(slot < nslots);
14860:         if (!js_ReallocSlots(cx, obj, nslots, JS_TRUE)) {
    1:             JS_UNLOCK_SCOPE(cx, scope);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     /* Whether or not we grew nslots, we may need to advance freeslot. */
28353:     if (scope->object == obj && slot >= scope->freeslot)
28353:         scope->freeslot = slot + 1;
    1: 
    1:     STOBJ_SET_SLOT(obj, slot, v);
25939:     GC_POKE(cx, JS_NULL);
    1:     JS_UNLOCK_SCOPE(cx, scope);
    1:     return JS_TRUE;
    1: }
    1: 
12674: JSObject *
12674: js_GetWrappedObject(JSContext *cx, JSObject *obj)
12674: {
12674:     JSClass *clasp;
12674: 
12674:     clasp = OBJ_GET_CLASS(cx, obj);
12674:     if (clasp->flags & JSCLASS_IS_EXTENDED) {
12674:         JSExtendedClass *xclasp;
12674:         JSObject *obj2;
12674: 
12674:         xclasp = (JSExtendedClass *)clasp;
12674:         if (xclasp->wrappedObject && (obj2 = xclasp->wrappedObject(cx, obj)))
12674:             return obj2;
12674:     }
12674:     return obj;
12674: }
12674: 
26059: JSBool
26059: js_IsCallable(JSObject *obj, JSContext *cx)
26059: {
26059:     if (!OBJ_IS_NATIVE(obj))
26059:         return obj->map->ops->call != NULL;
26059: 
26059:     JS_LOCK_OBJ(cx, obj);
26059:     JSBool callable = (obj->map->ops == &js_ObjectOps)
26059:                       ? HAS_FUNCTION_CLASS(obj) || STOBJ_GET_CLASS(obj)->call
26059:                       : obj->map->ops->call != NULL;
26059:     JS_UNLOCK_OBJ(cx, obj);
26059:     return callable;
26059: }
26059: 
27641: void
27641: js_ReportGetterOnlyAssignment(JSContext *cx)
27641: {
27641:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
27641:                          JSMSG_GETTER_ONLY, NULL);
27641: }
27641: 
27641: 
27641: JS_FRIEND_API(JSBool)
27641: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27641: {
27641:     js_ReportGetterOnlyAssignment(cx);
27641:     return JS_FALSE;
27641: }
27641: 
24294: #ifdef DEBUG
19714: 
19714: /*
19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
19714:  * into other code.
19714:  */
19714: 
19714: void
19714: dumpChars(const jschar *s, size_t n)
19714: {
19714:     size_t i;
19714: 
19714:     if (n == (size_t) -1) {
19714:         while (s[++n]) ;
19714:     }
19714: 
    1:     fputc('"', stderr);
19714:     for (i = 0; i < n; i++) {
19714:         if (s[i] == '\n')
19714:             fprintf(stderr, "\\n");
19714:         else if (s[i] == '\t')
19714:             fprintf(stderr, "\\t");
19714:         else if (s[i] >= 32 && s[i] < 127)
19714:             fputc(s[i], stderr);
19714:         else if (s[i] <= 255)
19714:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
19714:         else
19714:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
19714:     }
19714:     fputc('"', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpChars(const jschar *s, size_t n)
19714: {
19714:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
19714:     dumpChars(s, n);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: void
19714: dumpString(JSString *str)
19714: {
29366:     dumpChars(str->chars(), str->length());
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpString(JSString *str)
19714: {
19714:     fprintf(stderr, "JSString* (%p) = jschar * (%p) = ",
29366:             (void *) str, (void *) str->chars());
19714:     dumpString(str);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: JS_FRIEND_API(void)
19714: js_DumpAtom(JSAtom *atom)
19714: {
19714:     fprintf(stderr, "JSAtom* (%p) = ", (void *) atom);
19714:     js_DumpValue(ATOM_KEY(atom));
19714: }
19714: 
19714: void
19714: dumpValue(jsval val)
19714: {
19714:     if (JSVAL_IS_NULL(val)) {
19714:         fprintf(stderr, "null");
19714:     } else if (JSVAL_IS_VOID(val)) {
19714:         fprintf(stderr, "undefined");
26674:     } else if (JSVAL_IS_OBJECT(val) &&
26674:                HAS_FUNCTION_CLASS(JSVAL_TO_OBJECT(val))) {
26674:         JSObject *funobj = JSVAL_TO_OBJECT(val);
26674:         JSFunction *fun = (JSFunction *) STOBJ_GET_PRIVATE(funobj);
26674:         fprintf(stderr, "<%s %s at %p (JSFunction at %p)>",
26674:                 fun->atom ? "function" : "unnamed",
26674:                 fun->atom ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom)) : "function",
26674:                 (void *) funobj,
26674:                 (void *) fun);
19714:     } else if (JSVAL_IS_OBJECT(val)) {
19714:         JSObject *obj = JSVAL_TO_OBJECT(val);
19714:         JSClass *cls = STOBJ_GET_CLASS(obj);
19714:         fprintf(stderr, "<%s%s at %p>",
19714:                 cls->name,
19714:                 cls == &js_ObjectClass ? "" : " object",
25218:                 (void *) obj);
19714:     } else if (JSVAL_IS_INT(val)) {
19714:         fprintf(stderr, "%d", JSVAL_TO_INT(val));
19714:     } else if (JSVAL_IS_STRING(val)) {
19714:         dumpString(JSVAL_TO_STRING(val));
19714:     } else if (JSVAL_IS_DOUBLE(val)) {
19714:         fprintf(stderr, "%g", *JSVAL_TO_DOUBLE(val));
19714:     } else if (val == JSVAL_TRUE) {
19714:         fprintf(stderr, "true");
19714:     } else if (val == JSVAL_FALSE) {
19714:         fprintf(stderr, "false");
19714:     } else if (val == JSVAL_HOLE) {
19714:         fprintf(stderr, "hole");
19714:     } else {
19714:         /* jsvals are pointer-sized, and %p is portable */
19714:         fprintf(stderr, "unrecognized jsval %p", (void *) val);
19714:     }
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpValue(jsval val)
19714: {
28665:     fprintf(stderr, "jsval %p = ", (void *) val);
19714:     dumpValue(val);
19714:     fputc('\n', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpId(jsid id)
19714: {
28665:     fprintf(stderr, "jsid %p = ", (void *) id);
19714:     dumpValue(ID_TO_VALUE(id));
19714:     fputc('\n', stderr);
19714: }
19714: 
20208: static void
19714: dumpScopeProp(JSScopeProperty *sprop)
19714: {
19714:     jsid id = sprop->id;
19714:     uint8 attrs = sprop->attrs;
19714: 
19714:     fprintf(stderr, "    ");
19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
19714:     if (attrs & JSPROP_GETTER) fprintf(stderr, "getter ");
19714:     if (attrs & JSPROP_SETTER) fprintf(stderr, "setter ");
19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
19714:     if (sprop->flags & SPROP_IS_ALIAS) fprintf(stderr, "alias ");
19714:     if (JSID_IS_ATOM(id))
19714:         dumpString(JSVAL_TO_STRING(ID_TO_VALUE(id)));
19714:     else if (JSID_IS_INT(id))
19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
19714:     else
19714:         fprintf(stderr, "unknown jsid %p", (void *) id);
19714:     fprintf(stderr, ": slot %d", sprop->slot);
19714:     fprintf(stderr, "\n");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpObject(JSObject *obj)
19714: {
19714:     uint32 i, slots;
    1:     JSClass *clasp;
19714:     jsuint reservedEnd;
28353:     bool sharesScope = false;
    1: 
13437:     fprintf(stderr, "object %p\n", (void *) obj);
19714:     clasp = STOBJ_GET_CLASS(obj);
    1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
19714: 
19714:     /* OBJ_IS_DENSE_ARRAY ignores the cx argument. */
19714:     if (OBJ_IS_DENSE_ARRAY(BOGUS_CX, obj)) {
13437:         slots = JS_MIN((jsuint) obj->fslots[JSSLOT_ARRAY_LENGTH],
25475:                        js_DenseArrayCapacity(obj));
19714:         fprintf(stderr, "elements\n");
13437:         for (i = 0; i < slots; i++) {
19714:             fprintf(stderr, " %3d: ", i);
19714:             dumpValue(obj->dslots[i]);
19714:             fprintf(stderr, "\n");
19714:             fflush(stderr);
19714:         }
13437:         return;
13437:     }
13437: 
19714:     if (OBJ_IS_NATIVE(obj)) {
19714:         JSScope *scope = OBJ_SCOPE(obj);
19714:         JSObject *proto = STOBJ_GET_PROTO(obj);
19714: 
19714:         if (SCOPE_IS_SEALED(scope))
19714:             fprintf(stderr, "sealed\n");
19714: 
20208:         sharesScope = (scope->object != obj);
20208:         if (sharesScope) {
24294:             if (proto) {
20208:                 fprintf(stderr, "no own properties - see proto (%s at %p)\n",
25218:                         STOBJ_GET_CLASS(proto)->name, (void *) proto);
20208:             } else {
24294:                 fprintf(stderr, "no own properties - null proto\n");
24294:             }
24294:         } else {
19714:             fprintf(stderr, "properties:\n");
19714:             for (JSScopeProperty *sprop = SCOPE_LAST_PROP(scope); sprop;
19714:                  sprop = sprop->parent) {
19714:                 if (!SCOPE_HAD_MIDDLE_DELETE(scope) ||
19714:                     SCOPE_HAS_PROPERTY(scope, sprop)) {
19714:                     dumpScopeProp(sprop);
19714:                 }
19714:             }
20208:         }
19714:     } else {
19714:         if (!OBJ_IS_NATIVE(obj))
19714:             fprintf(stderr, "not native\n");
19714:     }
19714: 
19714:     fprintf(stderr, "slots:\n");
19714:     reservedEnd = JSSLOT_PRIVATE;
19714:     if (clasp->flags & JSCLASS_HAS_PRIVATE)
19714:         reservedEnd++;
19714:     reservedEnd += JSCLASS_RESERVED_SLOTS(clasp);
28353:     slots = (OBJ_IS_NATIVE(obj) && !sharesScope)
28353:             ? OBJ_SCOPE(obj)->freeslot
28353:             : STOBJ_NSLOTS(obj);
13437:     for (i = 0; i < slots; i++) {
19714:         fprintf(stderr, " %3d ", i);
19714:         if (i == JSSLOT_PRIVATE && (clasp->flags & JSCLASS_HAS_PRIVATE)) {
20208:             fprintf(stderr, "(private) = %p\n",
19714:                     JSVAL_TO_PRIVATE(STOBJ_GET_SLOT(obj, i)));
19714:             continue;
19714:         }
19714:         if (i == JSSLOT_PROTO)
19714:             fprintf(stderr, "(proto) ");
19714:         else if (i == JSSLOT_PARENT)
19714:             fprintf(stderr, "(parent) ");
19714:         else if (i < reservedEnd)
19714:             fprintf(stderr, "(reserved) ");
19714:         fprintf(stderr, "= ");
19714:         dumpValue(STOBJ_GET_SLOT(obj, i));
19714:         fputc('\n', stderr);
19714:     }
19714:     fputc('\n', stderr);
    1: }
    1: 
28665: static void
28665: MaybeDumpObject(const char *name, JSObject *obj)
28665: {
28665:     if (obj) {
28665:         fprintf(stderr, "  %s: ", name);
28665:         dumpValue(OBJECT_TO_JSVAL(obj));
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
28665: JS_FRIEND_API(void)
28665: js_DumpStackFrame(JSStackFrame *fp)
28665: {
28665:     jsval *sp = NULL;
28665: 
28665:     for (; fp; fp = fp->down) {
28665:         fprintf(stderr, "JSStackFrame at %p\n", (void *) fp);
28665:         if (fp->callee)
28665:             dumpValue(OBJECT_TO_JSVAL(fp->callee));
28665:         else
28665:             fprintf(stderr, "global frame, no callee");
28665:         fputc('\n', stderr);
28665: 
28665:         if (fp->script)
28665:             fprintf(stderr, "file %s line %u\n", fp->script->filename, (unsigned) fp->script->lineno);
28665: 
28665:         if (fp->regs) {
28665:             if (!fp->regs->pc) {
28665:                 fprintf(stderr, "*** regs && !regs->pc, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             if (!fp->script) {
28665:                 fprintf(stderr, "*** regs && !script, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             jsbytecode *pc = fp->regs->pc;
28665:             sp = fp->regs->sp;
28665:             if (fp->imacpc) {
28665:                 fprintf(stderr, "  pc in imacro at %p\n  called from ", pc);
28665:                 pc = fp->imacpc;
28665:             } else {
28665:                 fprintf(stderr, "  ");
28665:             }
28665:             fprintf(stderr, "pc = %p\n", pc);
28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
28665:         }
28665:         if (sp && fp->slots) {
28690:             fprintf(stderr, "  slots: %p\n", (void *) fp->slots);
28690:             fprintf(stderr, "  sp:    %p = slots + %u\n", (void *) sp, (unsigned) (sp - fp->slots));
28665:             if (sp - fp->slots < 10000) { // sanity
28665:                 for (jsval *p = fp->slots; p < sp; p++) {
28665:                     fprintf(stderr, "    %p: ", (void *) p);
28665:                     dumpValue(*p);
28665:                     fputc('\n', stderr);
28665:                 }
28665:             }
28665:         } else {
28665:             fprintf(stderr, "  sp:    %p\n", (void *) sp);
28665:             fprintf(stderr, "  slots: %p\n", (void *) fp->slots);
28665:         }
28690:         fprintf(stderr, "  argv:  %p (argc: %u)\n", (void *) fp->argv, (unsigned) fp->argc);
28665:         MaybeDumpObject("callobj", fp->callobj);
28665:         MaybeDumpObject("argsobj", fp->argsobj);
28665:         MaybeDumpObject("varobj", fp->varobj);
28665:         MaybeDumpObject("this", fp->thisp);
28665:         fprintf(stderr, "  rval: ");
28665:         dumpValue(fp->rval);
28665:         fputc('\n', stderr);
28665: 
28665:         fprintf(stderr, "  flags:");
28665:         if (fp->flags == 0)
28665:             fprintf(stderr, " none");
28665:         if (fp->flags & JSFRAME_CONSTRUCTING)
28665:             fprintf(stderr, " constructing");
28665:         if (fp->flags & JSFRAME_COMPUTED_THIS)
28665:             fprintf(stderr, " computed_this");
28665:         if (fp->flags & JSFRAME_ASSIGNING)
28665:             fprintf(stderr, " assigning");
28665:         if (fp->flags & JSFRAME_DEBUGGER)
28665:             fprintf(stderr, " debugger");
28665:         if (fp->flags & JSFRAME_EVAL)
28665:             fprintf(stderr, " eval");
28665:         if (fp->flags & JSFRAME_ROOTED_ARGV)
28665:             fprintf(stderr, " rooted_argv");
28665:         if (fp->flags & JSFRAME_YIELDING)
28665:             fprintf(stderr, " yielding");
28665:         if (fp->flags & JSFRAME_ITERATOR)
28665:             fprintf(stderr, " iterator");
28665:         if (fp->flags & JSFRAME_GENERATOR)
28665:             fprintf(stderr, " generator");
28665:         if ((fp->flags >> JSFRAME_OVERRIDE_SHIFT) & JS_BITMASK(JSFRAME_OVERRIDE_BITS))
28665:             fprintf(stderr, " override_bits(0x%x)", (fp->flags >> JSFRAME_OVERRIDE_SHIFT) & JS_BITMASK(JSFRAME_OVERRIDE_BITS));
28665:         fputc('\n', stderr);
28665: 
28665:         if (fp->scopeChain)
28665:             fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) fp->scopeChain);
28665:         if (fp->blockChain)
28665:             fprintf(stderr, "  blockChain: (JSObject *) %p\n", (void *) fp->blockChain);
28665: 
28665:         if (fp->sharpDepth)
28665:             fprintf(stderr, "  sharpDepth: %u\n", (unsigned) fp->sharpDepth);
28665:         if (fp->xmlNamespace)
28690:             fprintf(stderr, "  xmlNamespace: (JSObject *) %p\n", (void *) fp->xmlNamespace);
28665: 
28665:         if (fp->dormantNext)
28690:             fprintf(stderr, "  dormantNext: (JSStackFrame *) %p\n", (void *) fp->dormantNext);
28665:         if (fp->displaySave)
28690:             fprintf(stderr, "  displaySave: (JSStackFrame *) %p\n", (void *) fp->displaySave);
28665: 
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
    1: #endif
