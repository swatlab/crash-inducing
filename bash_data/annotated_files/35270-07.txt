    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* DOM object for element.style */
    1: 
    1: #include "nsDOMCSSAttrDeclaration.h"
    1: #include "nsCSSDeclaration.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsICSSParser.h"
    1: #include "nsIURI.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIContent.h"
 1036: #include "nsIPrincipal.h"
    1: 
32193: nsDOMCSSAttributeDeclaration::nsDOMCSSAttributeDeclaration(nsIContent *aContent
32193: #ifdef MOZ_SMIL
32193:                                                            , PRBool aIsSMILOverride
32193: #endif // MOZ_SMIL
32193:                                                            )
30385:   : mContent(aContent)
32193: #ifdef MOZ_SMIL
32193:   , mIsSMILOverride(aIsSMILOverride)
32193: #endif // MOZ_SMIL
    1: {
    1:   MOZ_COUNT_CTOR(nsDOMCSSAttributeDeclaration);
    1: 
    1:   NS_ASSERTION(aContent && aContent->IsNodeOfType(nsINode::eELEMENT),
    1:                "Inline style for non-element content?");
    1: }
    1: 
    1: nsDOMCSSAttributeDeclaration::~nsDOMCSSAttributeDeclaration()
    1: {
    1:   MOZ_COUNT_DTOR(nsDOMCSSAttributeDeclaration);
    1: }
    1: 
35270: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMCSSAttributeDeclaration)
35270: 
35270: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsDOMCSSAttributeDeclaration)
35270:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
35270: NS_IMPL_CYCLE_COLLECTION_ROOT_END
35270: 
35270: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDOMCSSAttributeDeclaration)
35270:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContent)
35270: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
35270: 
35270: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsDOMCSSAttributeDeclaration)
35270:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
35270: NS_IMPL_CYCLE_COLLECTION_TRACE_END
35270: 
35270: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDOMCSSAttributeDeclaration)
35270:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
35270:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContent)
35270: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
30385: 
30385: NS_INTERFACE_MAP_BEGIN(nsDOMCSSAttributeDeclaration)
30385:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
30385:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMCSSAttributeDeclaration)
30385: NS_IMPL_QUERY_TAIL_INHERITING(nsDOMCSSDeclaration)
30385: 
30385: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDOMCSSAttributeDeclaration)
30385: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDOMCSSAttributeDeclaration)
    1: 
    1: nsresult
    1: nsDOMCSSAttributeDeclaration::DeclarationChanged()
    1: {
    1:   NS_ASSERTION(mContent, "Must have content node to set the decl!");
32193:   nsICSSStyleRule* oldRule =
32193: #ifdef MOZ_SMIL
32193:     mIsSMILOverride ? mContent->GetSMILOverrideStyleRule() :
32193: #endif // MOZ_SMIL
32193:     mContent->GetInlineStyleRule();
    1:   NS_ASSERTION(oldRule, "content must have rule");
    1: 
    1:   nsCOMPtr<nsICSSStyleRule> newRule = oldRule->DeclarationChanged(PR_FALSE);
    1:   if (!newRule) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:     
32193:   return
32193: #ifdef MOZ_SMIL
32193:     mIsSMILOverride ? mContent->SetSMILOverrideStyleRule(newRule, PR_TRUE) :
32193: #endif // MOZ_SMIL
32193:     mContent->SetInlineStyleRule(newRule, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsDOMCSSAttributeDeclaration::GetCSSDeclaration(nsCSSDeclaration **aDecl,
    1:                                                 PRBool aAllocate)
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   *aDecl = nsnull;
    1:   if (mContent) {
32193:     nsICSSStyleRule* cssRule =
32193: #ifdef MOZ_SMIL
32193:       mIsSMILOverride ? mContent->GetSMILOverrideStyleRule() :
32193: #endif // MOZ_SMIL
32193:       mContent->GetInlineStyleRule();
    1:     if (cssRule) {
    1:       *aDecl = cssRule->GetDeclaration();
    1:     }
    1:     else if (aAllocate) {
    1:       nsCSSDeclaration *decl = new nsCSSDeclaration();
    1:       if (!decl)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       if (!decl->InitializeEmpty()) {
    1:         decl->RuleAbort();
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       
    1:       nsCOMPtr<nsICSSStyleRule> newRule;
    1:       result = NS_NewCSSStyleRule(getter_AddRefs(newRule), nsnull, decl);
    1:       if (NS_FAILED(result)) {
    1:         decl->RuleAbort();
    1:         return result;
    1:       }
    1:         
32193:       result =
32193: #ifdef MOZ_SMIL
32193:         mIsSMILOverride ?
32193:           mContent->SetSMILOverrideStyleRule(newRule, PR_FALSE) :
32193: #endif // MOZ_SMIL
32193:           mContent->SetInlineStyleRule(newRule, PR_FALSE);
    1:       if (NS_SUCCEEDED(result)) {
    1:         *aDecl = decl;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: /*
    1:  * This is a utility function.  It will only fail if it can't get a
    1:  * parser.  This means it can return NS_OK without aURI or aCSSLoader
    1:  * being initialized.
    1:  */
    1: nsresult
    1: nsDOMCSSAttributeDeclaration::GetCSSParsingEnvironment(nsIURI** aSheetURI,
    1:                                                        nsIURI** aBaseURI,
 1036:                                                        nsIPrincipal** aSheetPrincipal,
    1:                                                        nsICSSLoader** aCSSLoader,
    1:                                                        nsICSSParser** aCSSParser)
    1: {
    1:   NS_ASSERTION(mContent, "Something is severely broken -- there should be an nsIContent here!");
    1:   // null out the out params since some of them may not get initialized below
    1:   *aSheetURI = nsnull;
    1:   *aBaseURI = nsnull;
 1036:   *aSheetPrincipal = nsnull;
    1:   *aCSSLoader = nsnull;
    1:   *aCSSParser = nsnull;
    1: 
    1:   nsIDocument* doc = mContent->GetOwnerDoc();
    1:   if (!doc) {
    1:     // document has been destroyed
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1:   nsCOMPtr<nsIURI> sheetURI = doc->GetDocumentURI();
    1: 
    1:   NS_ADDREF(*aCSSLoader = doc->CSSLoader());
    1:   
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Note: parsers coming from a CSSLoader for a document already have
    1:   // the right case-sensitivity, quirkiness, etc.
    1:   rv = (*aCSSLoader)->GetParserFor(nsnull, aCSSParser);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   
    1:   baseURI.swap(*aBaseURI);
    1:   sheetURI.swap(*aSheetURI);
 1036:   NS_ADDREF(*aSheetPrincipal = mContent->NodePrincipal());
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMCSSAttributeDeclaration::GetParentRule(nsIDOMCSSRule **aParent)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParent);
    1: 
    1:   *aParent = nsnull;
    1:   return NS_OK;
    1: }
    1: 
