    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsCOMPtr.h"
    1: #include "nsIForm.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIFormSubmission.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsIDOMNSHTMLFormElement.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMNSHTMLFormControlList.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsEventStateManager.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIFrame.h"
    1: #include "nsIFormControlFrame.h"
    1: #include "nsDOMError.h"
    1: #include "nsContentUtils.h"
    1: #include "nsInterfaceHashtable.h"
    1: #include "nsContentList.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsCOMArray.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsTArray.h"
    1: 
    1: // form submission
    1: #include "nsIFormSubmitObserver.h"
    1: #include "nsIURI.h"
    1: #include "nsIObserverService.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsCategoryManagerUtils.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsRange.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIWebProgressListener.h"
    1: 
    1: // radio buttons
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIRadioControlElement.h"
    1: #include "nsIRadioVisitor.h"
    1: #include "nsIRadioGroupContainer.h"
    1: 
    1: #include "nsLayoutUtils.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: #include "nsEventDispatcher.h"
    1: 
14228: #include "mozAutoDocUpdate.h"
20752: #include "nsIHTMLCollection.h"
14228: 
    1: static const int NS_FORM_CONTROL_LIST_HASHTABLE_SIZE = 16;
    1: 
    1: class nsFormControlList;
    1: 
    1: /**
    1:  * hashkey wrapper using nsAString KeyType
    1:  *
    1:  * @see nsTHashtable::EntryType for specification
    1:  */
    1: class nsStringCaseInsensitiveHashKey : public PLDHashEntryHdr
    1: {
    1: public:
    1:   typedef const nsAString& KeyType;
    1:   typedef const nsAString* KeyTypePointer;
    1:   nsStringCaseInsensitiveHashKey(KeyTypePointer aStr) : mStr(*aStr) { } //take it easy just deal HashKey 
    1:   nsStringCaseInsensitiveHashKey(const nsStringCaseInsensitiveHashKey& toCopy) : mStr(toCopy.mStr) { }
    1:   ~nsStringCaseInsensitiveHashKey() { }
    1: 
    1:   KeyType GetKey() const { return mStr; }
    1:   PRBool KeyEquals(const KeyTypePointer aKey) const
    1:   {
    1:     return mStr.Equals(*aKey,nsCaseInsensitiveStringComparator());
    1:   }
    1: 
    1:   static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
    1:   static PLDHashNumber HashKey(const KeyTypePointer aKey)
    1:   {
    1:       nsAutoString tmKey(*aKey);
    1:       ToLowerCase(tmKey);
    1:       return HashString(tmKey);
    1:   }
    1:   enum { ALLOW_MEMMOVE = PR_TRUE };
    1: 
    1: private:
    1:   const nsString mStr;
    1: };
    1: 
    1: 
    1: // nsHTMLFormElement
    1: 
    1: class nsHTMLFormElement : public nsGenericHTMLElement,
    1:                           public nsIDOMHTMLFormElement,
    1:                           public nsIDOMNSHTMLFormElement,
    1:                           public nsIWebProgressListener,
    1:                           public nsIForm,
    1:                           public nsIRadioGroupContainer
    1: {
    1: public:
    1:   nsHTMLFormElement(nsINodeInfo *aNodeInfo);
    1:   virtual ~nsHTMLFormElement();
    1: 
    1:   nsresult Init();
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIDOMNode
    1:   NS_FORWARD_NSIDOMNODE(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMElement
    1:   NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMHTMLElement
    1:   NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMHTMLFormElement
    1:   NS_DECL_NSIDOMHTMLFORMELEMENT
    1: 
    1:   // nsIDOMNSHTMLFormElement
    1:   NS_DECL_NSIDOMNSHTMLFORMELEMENT  
    1: 
    1:   // nsIWebProgressListener
    1:   NS_DECL_NSIWEBPROGRESSLISTENER
    1: 
    1:   // nsIForm
    1:   NS_IMETHOD AddElement(nsIFormControl* aElement,
    1:                         PRBool aNotify);
    1:   NS_IMETHOD AddElementToTable(nsIFormControl* aChild,
    1:                                const nsAString& aName);
    1:   NS_IMETHOD GetElementAt(PRInt32 aIndex, nsIFormControl** aElement) const;
20237:   NS_IMETHOD_(PRUint32) GetElementCount() const;
    1:   NS_IMETHOD RemoveElement(nsIFormControl* aElement,
    1:                            PRBool aNotify);
    1:   NS_IMETHOD RemoveElementFromTable(nsIFormControl* aElement,
    1:                                     const nsAString& aName);
20237:   NS_IMETHOD_(already_AddRefed<nsISupports>) ResolveName(const nsAString& aName);
20237:   NS_IMETHOD_(PRInt32) IndexOfControl(nsIFormControl* aControl);
    1:   NS_IMETHOD OnSubmitClickBegin();
    1:   NS_IMETHOD OnSubmitClickEnd();
    1:   NS_IMETHOD FlushPendingSubmission();
    1:   NS_IMETHOD ForgetPendingSubmission();
    1:   NS_IMETHOD GetActionURL(nsIURI** aActionURL);
    1:   NS_IMETHOD GetSortedControls(nsTArray<nsIFormControl*>& aControls) const;
    1:   NS_IMETHOD_(nsIFormControl*) GetDefaultSubmitElement() const;
32864:   NS_IMETHOD_(PRBool) IsDefaultSubmitElement(const nsIFormControl* aControl) const;
    1:   NS_IMETHOD_(PRBool) HasSingleTextControl() const;
    1: 
    1:   // nsIRadioGroupContainer
    1:   NS_IMETHOD SetCurrentRadioButton(const nsAString& aName,
    1:                                    nsIDOMHTMLInputElement* aRadio);
    1:   NS_IMETHOD GetCurrentRadioButton(const nsAString& aName,
    1:                                    nsIDOMHTMLInputElement** aRadio);
    1:   NS_IMETHOD GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
    1:                                 PRInt32 *aPositionIndex,
    1:                                 PRInt32 *aItemsInGroup);
    1:   NS_IMETHOD GetNextRadioButton(const nsAString& aName,
    1:                                 const PRBool aPrevious,
    1:                                 nsIDOMHTMLInputElement*  aFocusedRadio,
    1:                                 nsIDOMHTMLInputElement** aRadioOut);
    1:   NS_IMETHOD WalkRadioGroup(const nsAString& aName, nsIRadioVisitor* aVisitor,
    1:                             PRBool aFlushContent);
    1:   NS_IMETHOD AddToRadioGroup(const nsAString& aName,
    1:                              nsIFormControl* aRadio);
    1:   NS_IMETHOD RemoveFromRadioGroup(const nsAString& aName,
    1:                                   nsIFormControl* aRadio);
    1: 
    1:   // nsIContent
    1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAttribute,
    1:                                 const nsAString& aValue,
    1:                                 nsAttrValue& aResult);
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
14434:   virtual nsresult WillHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1: 
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify);
    1: 
    1:   /**
    1:    * Forget all information about the current submission (and the fact that we
    1:    * are currently submitting at all).
    1:    */
    1:   void ForgetCurrentSubmission();
    1: 
    1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsHTMLFormElement,
    1:                                                      nsGenericHTMLElement)
    1: 
    1: protected:
32319:   class RemoveElementRunnable;
32319:   friend class RemoveElementRunnable;
32319: 
32319:   class RemoveElementRunnable : public nsRunnable {
32319:   public:
32319:     RemoveElementRunnable(nsHTMLFormElement* aForm, PRBool aNotify):
32319:       mForm(aForm), mNotify(aNotify)
32319:     {}
32319: 
32319:     NS_IMETHOD Run() {
32319:       mForm->HandleDefaultSubmitRemoval(mNotify);
32319:       return NS_OK;
32319:     }
32319: 
32319:   private:
32319:     nsRefPtr<nsHTMLFormElement> mForm;
32319:     PRBool mNotify;
32319:   };
32319: 
    1:   nsresult DoSubmitOrReset(nsEvent* aEvent,
    1:                            PRInt32 aMessage);
    1:   nsresult DoReset();
    1: 
32319:   // Async callback to handle removal of our default submit
32319:   void HandleDefaultSubmitRemoval(PRBool aNotify);
32319: 
    1:   //
    1:   // Submit Helpers
    1:   //
    1:   //
    1:   /**
    1:    * Attempt to submit (submission might be deferred) 
    1:    * (called by DoSubmitOrReset)
    1:    *
    1:    * @param aPresContext the presentation context
    1:    * @param aEvent the DOM event that was passed to us for the submit
    1:    */
    1:   nsresult DoSubmit(nsEvent* aEvent);
    1: 
    1:   /**
    1:    * Prepare the submission object (called by DoSubmit)
    1:    *
    1:    * @param aFormSubmission the submission object
    1:    * @param aEvent the DOM event that was passed to us for the submit
    1:    */
    1:   nsresult BuildSubmission(nsCOMPtr<nsIFormSubmission>& aFormSubmission, 
    1:                            nsEvent* aEvent);
    1:   /**
    1:    * Perform the submission (called by DoSubmit and FlushPendingSubmission)
    1:    *
    1:    * @param aFormSubmission the submission object
    1:    */
    1:   nsresult SubmitSubmission(nsIFormSubmission* aFormSubmission);
    1:   /**
    1:    * Walk over the form elements and call SubmitNamesValues() on them to get
    1:    * their data pumped into the FormSubmitter.
    1:    *
    1:    * @param aFormSubmission the form submission object
    1:    * @param aSubmitElement the element that was clicked on (nsnull if none)
    1:    */
    1:   nsresult WalkFormElements(nsIFormSubmission* aFormSubmission,
    1:                             nsIContent* aSubmitElement);
    1: 
    1:   /**
    1:    * Notify any submit observers of the submit.
    1:    *
    1:    * @param aActionURL the URL being submitted to
    1:    * @param aCancelSubmit out param where submit observers can specify that the
    1:    *        submit should be cancelled.
    1:    */
    1:   nsresult NotifySubmitObservers(nsIURI* aActionURL, PRBool* aCancelSubmit,
    1:                                  PRBool aEarlyNotify);
    1: 
    1:   /**
    1:    * Just like ResolveName(), but takes an arg for whether to flush
    1:    */
20237:   already_AddRefed<nsISupports> DoResolveName(const nsAString& aName, PRBool aFlushContent);
    1: 
    1:   //
    1:   // Data members
    1:   //
    1:   /** The list of controls (form.elements as well as stuff not in elements) */
    1:   nsRefPtr<nsFormControlList> mControls;
    1:   /** The currently selected radio button of each group */
    1:   nsInterfaceHashtable<nsStringCaseInsensitiveHashKey,nsIDOMHTMLInputElement> mSelectedRadioButtons;
    1:   /** Whether we are currently processing a submit event or not */
    1:   PRPackedBool mGeneratingSubmit;
    1:   /** Whether we are currently processing a reset event or not */
    1:   PRPackedBool mGeneratingReset;
    1:   /** Whether we are submitting currently */
    1:   PRPackedBool mIsSubmitting;
    1:   /** Whether the submission is to be deferred in case a script triggers it */
    1:   PRPackedBool mDeferSubmission;
    1:   /** Whether we notified NS_FORMSUBMIT_SUBJECT listeners already */
    1:   PRPackedBool mNotifiedObservers;
    1:   /** If we notified the listeners early, what was the result? */
    1:   PRPackedBool mNotifiedObserversResult;
    1:   /** Keep track of what the popup state was when the submit was initiated */
    1:   PopupControlState mSubmitPopupState;
    1:   /** Keep track of whether a submission was user-initiated or not */
    1:   PRBool mSubmitInitiatedFromUserInput;
    1: 
    1:   /** The pending submission object */
    1:   nsCOMPtr<nsIFormSubmission> mPendingSubmission;
    1:   /** The request currently being submitted */
    1:   nsCOMPtr<nsIRequest> mSubmittingRequest;
    1:   /** The web progress object we are currently listening to */
 8462:   nsWeakPtr mWebProgress;
    1: 
    1:   /** The default submit element -- WEAK */
    1:   nsIFormControl* mDefaultSubmitElement;
    1: 
 4336:   /** The first submit element in mElements -- WEAK */
 4336:   nsIFormControl* mFirstSubmitInElements;
 4336: 
 4336:   /** The first submit element in mNotInElements -- WEAK */
 4336:   nsIFormControl* mFirstSubmitNotInElements;
 4336: 
    1: protected:
    1:   /** Detection of first form to notify observers */
    1:   static PRBool gFirstFormSubmitted;
    1:   /** Detection of first password input to initialize the password manager */
    1:   static PRBool gPasswordManagerInitialized;
    1: };
    1: 
    1: PRBool nsHTMLFormElement::gFirstFormSubmitted = PR_FALSE;
    1: PRBool nsHTMLFormElement::gPasswordManagerInitialized = PR_FALSE;
    1: 
    1: 
    1: // nsFormControlList
    1: class nsFormControlList : public nsIDOMNSHTMLFormControlList,
20752:                           public nsIHTMLCollection
    1: {
    1: public:
    1:   nsFormControlList(nsHTMLFormElement* aForm);
    1:   virtual ~nsFormControlList();
    1: 
    1:   nsresult Init();
    1: 
    1:   void DropFormReference();
    1: 
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsIDOMHTMLCollection interface
    1:   NS_DECL_NSIDOMHTMLCOLLECTION
    1: 
    1:   // nsIDOMNSHTMLFormControlList interface
    1:   NS_DECL_NSIDOMNSHTMLFORMCONTROLLIST
    1: 
20752:   virtual nsISupports* GetNodeAt(PRUint32 aIndex, nsresult* aResult)
20752:   {
20752:     FlushPendingNotifications();
20752: 
20752:     *aResult = NS_OK;
20752: 
20752:     return mElements.SafeElementAt(aIndex, nsnull);
20752:   }
21159:   virtual nsISupports* GetNamedItem(const nsAString& aName, nsresult* aResult)
21159:   {
21159:     *aResult = NS_OK;
21159: 
21159:     return NamedItemInternal(aName, PR_TRUE);
21159:   }
20752: 
    1:   nsresult AddElementToTable(nsIFormControl* aChild,
    1:                              const nsAString& aName);
    1:   nsresult RemoveElementFromTable(nsIFormControl* aChild,
    1:                                   const nsAString& aName);
    1:   nsresult IndexOfControl(nsIFormControl* aControl,
    1:                           PRInt32* aIndex);
    1: 
21159:   nsISupports* NamedItemInternal(const nsAString& aName, PRBool aFlushContent);
    1:   
    1:   /**
    1:    * Create a sorted list of form control elements. This list is sorted
    1:    * in document order and contains the controls in the mElements and
    1:    * mNotInElements list. This function does not add references to the
    1:    * elements.
    1:    *
    1:    * @param aControls The list of sorted controls[out].
    1:    * @return NS_OK or NS_ERROR_OUT_OF_MEMORY.
    1:    */
    1:   nsresult GetSortedControls(nsTArray<nsIFormControl*>& aControls) const;
    1: 
    1:   nsHTMLFormElement* mForm;  // WEAK - the form owns me
    1: 
    1:   nsTArray<nsIFormControl*> mElements;  // Holds WEAK references - bug 36639
    1: 
    1:   // This array holds on to all form controls that are not contained
    1:   // in mElements (form.elements in JS, see ShouldBeInFormControl()).
    1:   // This is needed to properly clean up the bi-directional references
    1:   // (both weak and strong) between the form and its form controls.
    1: 
    1:   nsTArray<nsIFormControl*> mNotInElements; // Holds WEAK references
    1: 
20752:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsFormControlList, nsIHTMLCollection)
    1: 
    1: protected:
    1:   // Drop all our references to the form elements
    1:   void Clear();
    1: 
    1:   // Flush out the content model so it's up to date.
    1:   void FlushPendingNotifications();
    1:   
    1:   // A map from an ID or NAME attribute to the form control(s), this
    1:   // hash holds strong references either to the named form control, or
    1:   // to a list of named form controls, in the case where this hash
    1:   // holds on to a list of named form controls the list has weak
    1:   // references to the form control.
    1: 
    1:   nsInterfaceHashtable<nsStringHashKey,nsISupports> mNameLookupTable;
    1: };
    1: 
    1: static PRBool
    1: ShouldBeInElements(nsIFormControl* aFormControl)
    1: {
    1:   // For backwards compatibility (with 4.x and IE) we must not add
    1:   // <input type=image> elements to the list of form controls in a
    1:   // form.
    1: 
    1:   switch (aFormControl->GetType()) {
    1:   case NS_FORM_BUTTON_BUTTON :
    1:   case NS_FORM_BUTTON_RESET :
    1:   case NS_FORM_BUTTON_SUBMIT :
    1:   case NS_FORM_INPUT_BUTTON :
    1:   case NS_FORM_INPUT_CHECKBOX :
    1:   case NS_FORM_INPUT_FILE :
    1:   case NS_FORM_INPUT_HIDDEN :
    1:   case NS_FORM_INPUT_RESET :
    1:   case NS_FORM_INPUT_PASSWORD :
    1:   case NS_FORM_INPUT_RADIO :
    1:   case NS_FORM_INPUT_SUBMIT :
    1:   case NS_FORM_INPUT_TEXT :
    1:   case NS_FORM_SELECT :
    1:   case NS_FORM_TEXTAREA :
    1:   case NS_FORM_FIELDSET :
    1:   case NS_FORM_OBJECT :
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // These form control types are not supposed to end up in the
    1:   // form.elements array
    1:   //
    1:   // NS_FORM_INPUT_IMAGE
    1:   // NS_FORM_LABEL
    1:   // NS_FORM_OPTION
    1:   // NS_FORM_OPTGROUP
    1:   // NS_FORM_LEGEND
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // nsHTMLFormElement implementation
    1: 
    1: // construction, destruction
    1: nsGenericHTMLElement*
    1: NS_NewHTMLFormElement(nsINodeInfo *aNodeInfo, PRBool aFromParser)
    1: {
11169:   nsHTMLFormElement* it = new nsHTMLFormElement(aNodeInfo);
    1:   if (!it) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsresult rv = it->Init();
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     delete it;
    1:     return nsnull;
    1:   }
    1: 
    1:   return it;
    1: }
    1: 
    1: nsHTMLFormElement::nsHTMLFormElement(nsINodeInfo *aNodeInfo)
    1:   : nsGenericHTMLElement(aNodeInfo),
    1:     mGeneratingSubmit(PR_FALSE),
    1:     mGeneratingReset(PR_FALSE),
    1:     mIsSubmitting(PR_FALSE),
    1:     mDeferSubmission(PR_FALSE),
    1:     mNotifiedObservers(PR_FALSE),
    1:     mNotifiedObserversResult(PR_FALSE),
    1:     mSubmitPopupState(openAbused),
    1:     mSubmitInitiatedFromUserInput(PR_FALSE),
    1:     mPendingSubmission(nsnull),
    1:     mSubmittingRequest(nsnull),
 4336:     mDefaultSubmitElement(nsnull),
 4336:     mFirstSubmitInElements(nsnull),
 4336:     mFirstSubmitNotInElements(nsnull)
    1: {
    1: }
    1: 
    1: nsHTMLFormElement::~nsHTMLFormElement()
    1: {
    1:   if (mControls) {
    1:     mControls->DropFormReference();
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::Init()
    1: {
    1:   mControls = new nsFormControlList(this);
    1:   if (!mControls) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   nsresult rv = mControls->Init();
    1:   
    1:   if (NS_FAILED(rv))
    1:   {
    1:     mControls = nsnull;
    1:     return rv;
    1:   }
    1:   
    1:   NS_ENSURE_TRUE(mSelectedRadioButtons.Init(4),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsISupports
    1: 
20261: static PLDHashOperator
    1: ElementTraverser(const nsAString& key, nsIDOMHTMLInputElement* element,
    1:                  void* userArg)
    1: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
    1:  
    1:   cb->NoteXPCOMChild(element);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLFormElement)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLFormElement,
    1:                                                   nsGenericHTMLElement)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mControls,
    1:                                                        nsIDOMHTMLCollection)
    1:   tmp->mSelectedRadioButtons.EnumerateRead(ElementTraverser, &cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLFormElement, nsGenericElement) 
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLFormElement, nsGenericElement) 
    1: 
    1: 
    1: // QueryInterface implementation for nsHTMLFormElement
21218: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLFormElement)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE5(nsHTMLFormElement,
 4838:                                    nsIDOMHTMLFormElement,
 4838:                                    nsIDOMNSHTMLFormElement,
 4838:                                    nsIForm,
 4838:                                    nsIWebProgressListener,
 4838:                                    nsIRadioGroupContainer)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLFormElement,
21218:                                                nsGenericHTMLElement)
 4838: NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLFormElement)
    1: 
    1: 
    1: // nsIDOMHTMLFormElement
    1: 
    1: NS_IMPL_ELEMENT_CLONE_WITH_INIT(nsHTMLFormElement)
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetElements(nsIDOMHTMLCollection** aElements)
    1: {
    1:   *aElements = mControls;
    1:   NS_ADDREF(*aElements);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify)
    1: {
    1:   if ((aName == nsGkAtoms::action || aName == nsGkAtoms::target) &&
    1:       aNameSpaceID == kNameSpaceID_None) {
    1:     if (mPendingSubmission) {
    1:       // aha, there is a pending submission that means we're in
    1:       // the script and we need to flush it. let's tell it
    1:       // that the event was ignored to force the flush.
    1:       // the second argument is not playing a role at all.
    1:       FlushPendingSubmission();
    1:     }
    1:     // Don't forget we've notified the password manager already if the
    1:     // page sets the action/target in the during submit. (bug 343182)
    1:     PRBool notifiedObservers = mNotifiedObservers;
    1:     ForgetCurrentSubmission();
    1:     mNotifiedObservers = notifiedObservers;
    1:   }
    1:   return nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
    1:                                        aNotify);
    1: }
    1: 
    1: NS_IMPL_STRING_ATTR(nsHTMLFormElement, AcceptCharset, acceptcharset)
    1: NS_IMPL_STRING_ATTR(nsHTMLFormElement, Enctype, enctype)
    1: NS_IMPL_STRING_ATTR(nsHTMLFormElement, Method, method)
    1: NS_IMPL_STRING_ATTR(nsHTMLFormElement, Name, name)
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetAction(nsAString& aValue)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::action, aValue);
    1:   if (aValue.IsEmpty()) {
    1:     // Avoid resolving action="" to the base uri, bug 297761.
    1:     return NS_OK;
    1:   }
    1:   return GetURIAttr(nsGkAtoms::action, nsnull, aValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::SetAction(const nsAString& aValue)
    1: {
    1:   return SetAttr(kNameSpaceID_None, nsGkAtoms::action, aValue, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetTarget(nsAString& aValue)
    1: {
    1:   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::target, aValue)) {
    1:     GetBaseTarget(aValue);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::SetTarget(const nsAString& aValue)
    1: {
    1:   return SetAttr(kNameSpaceID_None, nsGkAtoms::target, aValue, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::Submit()
    1: {
    1:   // Send the submit event
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsPresContext> presContext = GetPresContext();
    1:   if (mPendingSubmission) {
    1:     // aha, we have a pending submission that was not flushed
    1:     // (this happens when form.submit() is called twice)
    1:     // we have to delete it and build a new one since values
    1:     // might have changed inbetween (we emulate IE here, that's all)
    1:     mPendingSubmission = nsnull;
    1:   }
    1: 
    1:   rv = DoSubmitOrReset(nsnull, NS_FORM_SUBMIT);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::Reset()
    1: {
    1:   nsFormEvent event(PR_TRUE, NS_FORM_RESET);
 3233:   nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this), nsnull,
    1:                               &event);
    1:   return NS_OK;
    1: }
    1: 
    1: static const nsAttrValue::EnumTable kFormMethodTable[] = {
    1:   { "get", NS_FORM_METHOD_GET },
    1:   { "post", NS_FORM_METHOD_POST },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kFormEnctypeTable[] = {
    1:   { "multipart/form-data", NS_FORM_ENCTYPE_MULTIPART },
    1:   { "application/x-www-form-urlencoded", NS_FORM_ENCTYPE_URLENCODED },
    1:   { "text/plain", NS_FORM_ENCTYPE_TEXTPLAIN },
    1:   { 0 }
    1: };
    1: 
    1: PRBool
    1: nsHTMLFormElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                   nsIAtom* aAttribute,
    1:                                   const nsAString& aValue,
    1:                                   nsAttrValue& aResult)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     if (aAttribute == nsGkAtoms::method) {
    1:       return aResult.ParseEnumValue(aValue, kFormMethodTable);
    1:     }
    1:     if (aAttribute == nsGkAtoms::enctype) {
    1:       return aResult.ParseEnumValue(aValue, kFormEnctypeTable);
    1:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                               aResult);
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIHTMLDocument> htmlDoc(do_QueryInterface(aDocument));
    1:   if (htmlDoc) {
    1:     htmlDoc->AddedForm();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 7654: static void
 7654: MarkOrphans(const nsTArray<nsIFormControl*> aArray)
 7654: {
 7654:   PRUint32 length = aArray.Length();
 7654:   for (PRUint32 i = 0; i < length; ++i) {
 7654:     nsCOMPtr<nsINode> node = do_QueryInterface(aArray[i]);
 7654:     NS_ASSERTION(node, "Form control must be nsINode");
 7654:     node->SetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
 7654:   }
 7654: }
 7654: 
 7654: static void
 7654: CollectOrphans(nsINode* aRemovalRoot, nsTArray<nsIFormControl*> aArray
 7654: #ifdef DEBUG
 7654:                , nsIDOMHTMLFormElement* aThisForm
 7654: #endif
 7654:                )
 7654: {
 7654:   // Walk backwards so that if we remove elements we can just keep iterating
 7654:   PRUint32 length = aArray.Length();
 7654:   for (PRUint32 i = length; i > 0; --i) {
 7654:     nsIFormControl* control = aArray[i-1];
 7654:     nsCOMPtr<nsINode> node = do_QueryInterface(control);
 7654:     NS_ASSERTION(node, "Form control must be nsINode");
 7654: 
 7654:     // Now if MAYBE_ORPHAN_FORM_ELEMENT is not set, that would mean that the
 7654:     // node is in fact a descendant of the form and hence should stay in the
 7654:     // form.  If it _is_ set, then we need to check whether the node is a
 7654:     // descendant of aRemovalRoot.  If it is, we leave it in the form.  See
 7654:     // also the code in nsGenericHTMLFormElement::FindForm.
 7654: #ifdef DEBUG
 7654:     PRBool removed = PR_FALSE;
 7654: #endif
 7654:     if (node->HasFlag(MAYBE_ORPHAN_FORM_ELEMENT)) {
 7654:       node->UnsetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
 7654:       if (!nsContentUtils::ContentIsDescendantOf(node, aRemovalRoot)) {
19131:         control->ClearForm(PR_TRUE, PR_TRUE);
 7654: #ifdef DEBUG
 7654:         removed = PR_TRUE;
 7654: #endif
 7654:       }
 7654:     }
 7654: 
 7654: #ifdef DEBUG
 7654:     if (!removed) {
 7654:       nsCOMPtr<nsIDOMHTMLFormElement> form;
 7654:       control->GetForm(getter_AddRefs(form));
 7654:       NS_ASSERTION(form == aThisForm, "How did that happen?");
 7654:     }
 7654: #endif /* DEBUG */
 7654:   }
 7654: }
 7654: 
    1: void
    1: nsHTMLFormElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
    1:   nsCOMPtr<nsIHTMLDocument> oldDocument = do_QueryInterface(GetCurrentDoc());
    1: 
 7654:   // Mark all of our controls as maybe being orphans
 7654:   MarkOrphans(mControls->mElements);
 7654:   MarkOrphans(mControls->mNotInElements);
 7654: 
    1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
    1: 
 7654:   nsINode* ancestor = this;
 7654:   nsINode* cur;
 7654:   do {
 7654:     cur = ancestor->GetNodeParent();
 7654:     if (!cur) {
 7654:       break;
 7654:     }
 7654:     ancestor = cur;
 7654:   } while (1);
 7654:   
 7654:   CollectOrphans(ancestor, mControls->mElements
 7654: #ifdef DEBUG
 7654:                  , this
 7654: #endif                 
 7654:                  );
 7654:   CollectOrphans(ancestor, mControls->mNotInElements
 7654: #ifdef DEBUG
 7654:                  , this
 7654: #endif                 
 7654:                  );
 7654: 
    1:   if (oldDocument) {
    1:     oldDocument->RemovedForm();
    1:   }     
    1:   ForgetCurrentSubmission();
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
20135:   aVisitor.mWantsWillHandleEvent = PR_TRUE;
 3233:   if (aVisitor.mEvent->originalTarget == static_cast<nsIContent*>(this)) {
    1:     PRUint32 msg = aVisitor.mEvent->message;
    1:     if (msg == NS_FORM_SUBMIT) {
    1:       if (mGeneratingSubmit) {
    1:         aVisitor.mCanHandle = PR_FALSE;
    1:         return NS_OK;
    1:       }
    1:       mGeneratingSubmit = PR_TRUE;
    1: 
    1:       // let the form know that it needs to defer the submission,
    1:       // that means that if there are scripted submissions, the
    1:       // latest one will be deferred until after the exit point of the handler.
    1:       mDeferSubmission = PR_TRUE;
    1:     }
    1:     else if (msg == NS_FORM_RESET) {
    1:       if (mGeneratingReset) {
    1:         aVisitor.mCanHandle = PR_FALSE;
    1:         return NS_OK;
    1:       }
    1:       mGeneratingReset = PR_TRUE;
    1:     }
    1:   }
    1:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
    1: }
    1: 
    1: nsresult
14434: nsHTMLFormElement::WillHandleEvent(nsEventChainPostVisitor& aVisitor)
14434: {
14434:   // If this is the bubble stage and there is a nested form below us which
14434:   // received a submit event we do *not* want to handle the submit event
14434:   // for this form too.
14434:   if ((aVisitor.mEvent->message == NS_FORM_SUBMIT ||
14434:        aVisitor.mEvent->message == NS_FORM_RESET) &&
14434:       aVisitor.mEvent->flags & NS_EVENT_FLAG_BUBBLE &&
14434:       aVisitor.mEvent->originalTarget != static_cast<nsIContent*>(this)) {
14434:     aVisitor.mEvent->flags |= NS_EVENT_FLAG_STOP_DISPATCH;
14434:   }
14434:   return NS_OK;
14434: }
14434: 
14434: nsresult
    1: nsHTMLFormElement::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
    1: {
 3233:   if (aVisitor.mEvent->originalTarget == static_cast<nsIContent*>(this)) {
    1:     PRUint32 msg = aVisitor.mEvent->message;
    1:     if (msg == NS_FORM_SUBMIT) {
    1:       // let the form know not to defer subsequent submissions
    1:       mDeferSubmission = PR_FALSE;
    1:     }
    1: 
    1:     if (aVisitor.mEventStatus == nsEventStatus_eIgnore) {
    1:       switch (msg) {
    1:         case NS_FORM_RESET:
    1:         case NS_FORM_SUBMIT:
    1:         {
    1:           if (mPendingSubmission && msg == NS_FORM_SUBMIT) {
    1:             // tell the form to forget a possible pending submission.
    1:             // the reason is that the script returned true (the event was
    1:             // ignored) so if there is a stored submission, it will miss
    1:             // the name/value of the submitting element, thus we need
    1:             // to forget it and the form element will build a new one
    1:             ForgetPendingSubmission();
    1:           }
    1:           DoSubmitOrReset(aVisitor.mEvent, msg);
    1:         }
    1:         break;
    1:       }
    1:     } else {
    1:       if (msg == NS_FORM_SUBMIT) {
    1:         // tell the form to flush a possible pending submission.
    1:         // the reason is that the script returned false (the event was
    1:         // not ignored) so if there is a stored submission, it needs to
    1:         // be submitted immediatelly.
    1:         FlushPendingSubmission();
    1:       }
    1:     }
    1: 
    1:     if (msg == NS_FORM_SUBMIT) {
    1:       mGeneratingSubmit = PR_FALSE;
    1:     }
    1:     else if (msg == NS_FORM_RESET) {
    1:       mGeneratingReset = PR_FALSE;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::DoSubmitOrReset(nsEvent* aEvent,
    1:                                    PRInt32 aMessage)
    1: {
    1:   // Make sure the presentation is up-to-date
    1:   nsIDocument* doc = GetCurrentDoc();
    1:   if (doc) {
    1:     doc->FlushPendingNotifications(Flush_ContentAndNotify);
    1:   }
    1: 
    1:   // JBK Don't get form frames anymore - bug 34297
    1: 
    1:   // Submit or Reset the form
    1:   nsresult rv = NS_OK;
    1:   if (NS_FORM_RESET == aMessage) {
    1:     rv = DoReset();
    1:   }
    1:   else if (NS_FORM_SUBMIT == aMessage) {
    1:     // Don't submit if we're not in a document.
    1:     if (doc) {
    1:       rv = DoSubmit(aEvent);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::DoReset()
    1: {
    1:   // JBK walk the elements[] array instead of form frame controls - bug 34297
20237:   PRUint32 numElements = GetElementCount();
    1:   for (PRUint32 elementX = 0; (elementX < numElements); elementX++) {
    1:     nsCOMPtr<nsIFormControl> controlNode;
    1:     GetElementAt(elementX, getter_AddRefs(controlNode));
    1:     if (controlNode) {
    1:       controlNode->Reset();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #define NS_ENSURE_SUBMIT_SUCCESS(rv)                                          \
    1:   if (NS_FAILED(rv)) {                                                        \
    1:     ForgetCurrentSubmission();                                                \
    1:     return rv;                                                                \
    1:   }
    1: 
    1: nsresult
    1: nsHTMLFormElement::DoSubmit(nsEvent* aEvent)
    1: {
    1:   NS_ASSERTION(GetCurrentDoc(), "Should never get here without a current doc");
 7626: 
    1:   if (mIsSubmitting) {
 7626:     NS_WARNING("Preventing double form submission");
    1:     // XXX Should this return an error?
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Mark us as submitting so that we don't try to submit again
    1:   mIsSubmitting = PR_TRUE;
    1:   NS_ASSERTION(!mWebProgress && !mSubmittingRequest, "Web progress / submitting request should not exist here!");
    1: 
    1:   nsCOMPtr<nsIFormSubmission> submission;
    1:    
    1:   //
    1:   // prepare the submission object
    1:   //
    1:   BuildSubmission(submission, aEvent); 
    1: 
    1:   // XXXbz if the script global is that for an sXBL/XBL2 doc, it won't
    1:   // be a window...
    1:   nsPIDOMWindow *window = GetOwnerDoc()->GetWindow();
    1: 
    1:   if (window) {
    1:     mSubmitPopupState = window->GetPopupControlState();
    1:   } else {
    1:     mSubmitPopupState = openAbused;
    1:   }
    1: 
    1:   mSubmitInitiatedFromUserInput = nsEventStateManager::IsHandlingUserInput();
    1: 
    1:   if(mDeferSubmission) { 
    1:     // we are in an event handler, JS submitted so we have to
    1:     // defer this submission. let's remember it and return
    1:     // without submitting
    1:     mPendingSubmission = submission;
    1:     // ensure reentrancy
    1:     mIsSubmitting = PR_FALSE;
    1:     return NS_OK; 
    1:   } 
    1:   
    1:   // 
    1:   // perform the submission
    1:   //
    1:   return SubmitSubmission(submission); 
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::BuildSubmission(nsCOMPtr<nsIFormSubmission>& aFormSubmission, 
    1:                                    nsEvent* aEvent)
    1: {
    1:   NS_ASSERTION(!mPendingSubmission, "tried to build two submissions!");
    1: 
    1:   // Get the originating frame (failure is non-fatal)
    1:   nsIContent *originatingElement = nsnull;
    1:   if (aEvent) {
    1:     if (NS_FORM_EVENT == aEvent->eventStructType) {
    1:       originatingElement = ((nsFormEvent *)aEvent)->originator;
    1:     }
    1:   }
    1: 
    1:   nsresult rv;
    1: 
    1:   //
    1:   // Get the submission object
    1:   //
    1:   rv = GetSubmissionFromForm(this, getter_AddRefs(aFormSubmission));
    1:   NS_ENSURE_SUBMIT_SUCCESS(rv);
    1: 
    1:   //
    1:   // Dump the data into the submission object
    1:   //
    1:   rv = WalkFormElements(aFormSubmission, originatingElement);
    1:   NS_ENSURE_SUBMIT_SUCCESS(rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::SubmitSubmission(nsIFormSubmission* aFormSubmission)
    1: {
    1:   nsresult rv;
    1:   //
    1:   // Get the action and target
    1:   //
    1:   nsCOMPtr<nsIURI> actionURI;
    1:   rv = GetActionURL(getter_AddRefs(actionURI));
    1:   NS_ENSURE_SUBMIT_SUCCESS(rv);
    1: 
    1:   if (!actionURI) {
    1:     mIsSubmitting = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If there is no link handler, then we won't actually be able to submit.
    1:   nsIDocument* doc = GetCurrentDoc();
    1:   nsCOMPtr<nsISupports> container = doc ? doc->GetContainer() : nsnull;
    1:   nsCOMPtr<nsILinkHandler> linkHandler(do_QueryInterface(container));
 3333:   if (!linkHandler || IsEditable()) {
    1:     mIsSubmitting = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // javascript URIs are not really submissions; they just call a function.
    1:   // Also, they may synchronously call submit(), and we want them to be able to
    1:   // do so while still disallowing other double submissions. (Bug 139798)
    1:   // Note that any other URI types that are of equivalent type should also be
    1:   // added here.
    1:   // XXXbz this is a mess.  The real issue here is that nsJSChannel sets the
    1:   // LOAD_BACKGROUND flag, so doesn't notify us, compounded by the fact that
    1:   // the JS executes before we forget the submission in OnStateChange on
    1:   // STATE_STOP.  As a result, we have to make sure that we simply pretend
    1:   // we're not submitting when submitting to a JS URL.  That's kinda bogus, but
    1:   // there we are.
    1:   PRBool schemeIsJavaScript = PR_FALSE;
    1:   if (NS_SUCCEEDED(actionURI->SchemeIs("javascript", &schemeIsJavaScript)) &&
    1:       schemeIsJavaScript) {
    1:     mIsSubmitting = PR_FALSE;
    1:   }
    1: 
    1:   nsAutoString target;
    1:   rv = GetTarget(target);
    1:   NS_ENSURE_SUBMIT_SUCCESS(rv);
    1: 
    1:   //
    1:   // Notify observers of submit
    1:   //
    1:   PRBool cancelSubmit = PR_FALSE;
    1:   if (mNotifiedObservers) {
    1:     cancelSubmit = mNotifiedObserversResult;
    1:   } else {
    1:     rv = NotifySubmitObservers(actionURI, &cancelSubmit, PR_TRUE);
    1:     NS_ENSURE_SUBMIT_SUCCESS(rv);
    1:   }
    1: 
    1:   if (cancelSubmit) {
    1:     mIsSubmitting = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   cancelSubmit = PR_FALSE;
    1:   rv = NotifySubmitObservers(actionURI, &cancelSubmit, PR_FALSE);
    1:   NS_ENSURE_SUBMIT_SUCCESS(rv);
    1: 
    1:   if (cancelSubmit) {
    1:     mIsSubmitting = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   //
    1:   // Submit
    1:   //
    1:   nsCOMPtr<nsIDocShell> docShell;
    1: 
    1:   {
    1:     nsAutoPopupStatePusher popupStatePusher(mSubmitPopupState);
    1: 
32435:     nsAutoHandlingUserInputStatePusher userInpStatePusher(mSubmitInitiatedFromUserInput, PR_FALSE);
    1: 
    1:     rv = aFormSubmission->SubmitTo(actionURI, target, this, linkHandler,
    1:                                    getter_AddRefs(docShell),
    1:                                    getter_AddRefs(mSubmittingRequest));
    1:   }
    1: 
    1:   NS_ENSURE_SUBMIT_SUCCESS(rv);
    1: 
    1:   // Even if the submit succeeds, it's possible for there to be no docshell
    1:   // or request; for example, if it's to a named anchor within the same page
    1:   // the submit will not really do anything.
    1:   if (docShell) {
    1:     // If the channel is pending, we have to listen for web progress.
    1:     PRBool pending = PR_FALSE;
    1:     mSubmittingRequest->IsPending(&pending);
    1:     if (pending && !schemeIsJavaScript) {
 8462:       nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
 8462:       NS_ASSERTION(webProgress, "nsIDocShell not converted to nsIWebProgress!");
 8462:       rv = webProgress->AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_ALL);
    1:       NS_ENSURE_SUBMIT_SUCCESS(rv);
 8462:       mWebProgress = do_GetWeakReference(webProgress);
 8462:       NS_ASSERTION(mWebProgress, "can't hold weak ref to webprogress!");
    1:     } else {
    1:       ForgetCurrentSubmission();
    1:     }
    1:   } else {
    1:     ForgetCurrentSubmission();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsHTMLFormElement::NotifySubmitObservers(nsIURI* aActionURL,
    1:                                          PRBool* aCancelSubmit,
    1:                                          PRBool  aEarlyNotify)
    1: {
    1:   // If this is the first form, bring alive the first form submit
    1:   // category observers
    1:   if (!gFirstFormSubmitted) {
    1:     gFirstFormSubmitted = PR_TRUE;
    1:     NS_CreateServicesFromCategory(NS_FIRST_FORMSUBMIT_CATEGORY,
    1:                                   nsnull,
    1:                                   NS_FIRST_FORMSUBMIT_CATEGORY);
    1:   }
    1: 
    1:   // Notify observers that the form is being submitted.
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIObserverService> service =
    1:     do_GetService("@mozilla.org/observer-service;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> theEnum;
    1:   rv = service->EnumerateObservers(aEarlyNotify ?
    1:                                    NS_EARLYFORMSUBMIT_SUBJECT :
    1:                                    NS_FORMSUBMIT_SUBJECT,
    1:                                    getter_AddRefs(theEnum));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (theEnum) {
    1:     nsCOMPtr<nsISupports> inst;
    1:     *aCancelSubmit = PR_FALSE;
    1: 
    1:     // XXXbz what do the submit observers actually want?  The window
    1:     // of the document this is shown in?  Or something else?
    1:     // sXBL/XBL2 issue
    1:     nsCOMPtr<nsPIDOMWindow> window = GetOwnerDoc()->GetWindow();
    1: 
    1:     PRBool loop = PR_TRUE;
    1:     while (NS_SUCCEEDED(theEnum->HasMoreElements(&loop)) && loop) {
    1:       theEnum->GetNext(getter_AddRefs(inst));
    1: 
    1:       nsCOMPtr<nsIFormSubmitObserver> formSubmitObserver(
    1:                       do_QueryInterface(inst));
    1:       if (formSubmitObserver) {
    1:         rv = formSubmitObserver->Notify(this,
    1:                                         window,
    1:                                         aActionURL,
    1:                                         aCancelSubmit);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:       if (*aCancelSubmit) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLFormElement::WalkFormElements(nsIFormSubmission* aFormSubmission,
    1:                                     nsIContent* aSubmitElement)
    1: {
    1:   nsTArray<nsIFormControl*> sortedControls;
    1:   nsresult rv = mControls->GetSortedControls(sortedControls);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   //
    1:   // Walk the list of nodes and call SubmitNamesValues() on the controls
    1:   //
    1:   PRUint32 len = sortedControls.Length();
    1:   for (PRUint32 i = 0; i < len; ++i) {
    1:     // Tell the control to submit its name/value pairs to the submission
    1:     sortedControls[i]->SubmitNamesValues(aFormSubmission, aSubmitElement);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIForm
    1: 
20237: NS_IMETHODIMP_(PRUint32)
20237: nsHTMLFormElement::GetElementCount() const 
    1: {
20237:   PRUint32 count = nsnull;
20237:   mControls->GetLength(&count); 
20237:   return count;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLFormElement::GetElementAt(PRInt32 aIndex,
    1:                                 nsIFormControl** aFormControl) const 
    1: {
    1:   // Converting to unsigned int will handle negative indices.
    1:   if (PRUint32(aIndex) >= mControls->mElements.Length()) {
    1:     *aFormControl = nsnull;
    1:   } else {
    1:     *aFormControl = mControls->mElements[aIndex];
    1:     NS_ADDREF(*aFormControl);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 4014: /**
 4014:  * Compares the position of aControl1 and aControl2 in the document
 4014:  * @param aControl1 First control to compare.
 4014:  * @param aControl2 Second control to compare.
 4014:  * @param aForm Parent form of the controls.
 4014:  * @return < 0 if aControl1 is before aControl2,
 4014:  *         > 0 if aControl1 is after aControl2,
 4014:  *         0 otherwise
 4014:  */
 4014: static PRInt32 CompareFormControlPosition(nsIFormControl *aControl1,
 4014:                                           nsIFormControl *aControl2,
32864:                                           const nsIContent* aForm)
    1: {
 4014:   NS_ASSERTION(aControl1 != aControl2, "Comparing a form control to itself");
    1: 
 4014:   nsCOMPtr<nsIContent> content1 = do_QueryInterface(aControl1);
 4014:   nsCOMPtr<nsIContent> content2 = do_QueryInterface(aControl2);
    1: 
 4014:   NS_ASSERTION(content1 && content2,
 4014:                "We should be able to QI to nsIContent here!");
 4014:   NS_ASSERTION(content1->GetParent() && content2->GetParent(),
 4014:                "Form controls should always have parents");
    1:  
 4014:   return nsLayoutUtils::CompareTreePosition(content1, content2, aForm);
    1: }
    1:  
 4014: #ifdef DEBUG
 4014: /**
 4014:  * Checks that all form elements are in document order. Asserts if any pair of
 4014:  * consecutive elements are not in increasing document order.
 4014:  *
 4014:  * @param aControls List of form controls to check.
 4014:  * @param aForm Parent form of the controls.
 4014:  */
 4014: static void
 4014: AssertDocumentOrder(const nsTArray<nsIFormControl*>& aControls,
 4014:                     nsIContent* aForm)
 4014: {
 4014:   // Only iterate if aControls is not empty, since otherwise
 4014:   // |aControls.Length() - 1| will be a very large unsigned number... not what
 4014:   // we want here.
 4014:   if (!aControls.IsEmpty()) {
 4014:     for (PRUint32 i = 0; i < aControls.Length() - 1; ++i) {
 4014:       NS_ASSERTION(CompareFormControlPosition(aControls[i], aControls[i + 1],
 4014:                                               aForm) < 0,
 4014:                    "Form controls not ordered correctly");
 4014:     }
 4014:   }
 4014: }
 4014: #endif
 4014: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::AddElement(nsIFormControl* aChild,
    1:                               PRBool aNotify)
    1: {
 4014: #ifdef DEBUG
 4014:   {
 4014:     nsCOMPtr<nsIContent> content = do_QueryInterface(aChild);
 4014:     NS_ASSERTION(content->GetParent(),
 4014:                  "Form control should have a parent");
 4014:   }
 4014: #endif
 4014: 
    1:   // Determine whether to add the new element to the elements or
    1:   // the not-in-elements list.
    1:   PRBool childInElements = ShouldBeInElements(aChild);
    1:   nsTArray<nsIFormControl*>& controlList = childInElements ?
    1:       mControls->mElements : mControls->mNotInElements;
    1:   
 4014:   NS_ASSERTION(controlList.IndexOf(aChild) == controlList.NoIndex,
 4014:                "Form control already in form");
 4014: 
    1:   PRUint32 count = controlList.Length();
    1:   nsCOMPtr<nsIFormControl> element;
    1:   
    1:   // Optimize most common case where we insert at the end.
    1:   PRBool lastElement = PR_FALSE;
    1:   PRInt32 position = -1;
    1:   if (count > 0) {
    1:     element = controlList[count - 1];
 4014:     position = CompareFormControlPosition(aChild, element, this);
    1:   }
    1: 
    1:   // If this item comes after the last element, or the elements array is
    1:   // empty, we append to the end. Otherwise, we do a binary search to
    1:   // determine where the element should go.
    1:   if (position >= 0 || count == 0) {
    1:     // WEAK - don't addref
    1:     controlList.AppendElement(aChild);
    1:     lastElement = PR_TRUE;
    1:   }
    1:   else {
    1:     PRInt32 low = 0, mid, high;
    1:     high = count - 1;
    1:       
    1:     while (low <= high) {
    1:       mid = (low + high) / 2;
    1:         
    1:       element = controlList[mid];
 4014:       position = CompareFormControlPosition(aChild, element, this);
    1:       if (position >= 0)
    1:         low = mid + 1;
    1:       else
    1:         high = mid - 1;
    1:     }
    1:       
    1:     // WEAK - don't addref
    1:     controlList.InsertElementAt(low, aChild);
    1:   }
    1: 
 4014: #ifdef DEBUG
 4014:   AssertDocumentOrder(controlList, this);
 4014: #endif
 4014:   
    1:   //
    1:   // Notify the radio button it's been added to a group
    1:   //
    1:   PRInt32 type = aChild->GetType();
    1:   if (type == NS_FORM_INPUT_RADIO) {
    1:     nsCOMPtr<nsIRadioControlElement> radio = do_QueryInterface(aChild);
    1:     nsresult rv = radio->AddedToRadioGroup();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   //
    1:   // If it is a password control, and the password manager has not yet been
    1:   // initialized, initialize the password manager
    1:   //
    1:   if (!gPasswordManagerInitialized && type == NS_FORM_INPUT_PASSWORD) {
    1:     // Initialize the password manager category
    1:     gPasswordManagerInitialized = PR_TRUE;
 1532:     NS_CreateServicesFromCategory(NS_PASSWORDMANAGER_CATEGORY,
 1532:                                   nsnull,
 1532:                                   NS_PASSWORDMANAGER_CATEGORY);
    1:   }
    1:  
    1:   // Default submit element handling
    1:   if (aChild->IsSubmitControl()) {
 4336:     // Update mDefaultSubmitElement, mFirstSubmitInElements,
 4336:     // mFirstSubmitNotInElements.
 4336: 
 4336:     nsIFormControl** firstSubmitSlot =
 4336:       childInElements ? &mFirstSubmitInElements : &mFirstSubmitNotInElements;
 4336:     
 4336:     // The new child is the new first submit in its list if the firstSubmitSlot
 4336:     // is currently empty or if the child is before what's currently in the
 4336:     // slot.  Note that if we already have a control in firstSubmitSlot and
 4336:     // we're appending this element can't possibly replace what's currently in
 4336:     // the slot.  Also note that aChild can't become the mDefaultSubmitElement
 4336:     // unless it replaces what's in the slot.  If it _does_ replace what's in
 4336:     // the slot, it becomes the default submit if either the default submit is
 4336:     // what's in the slot or the child is earlier than the default submit.
 4336:     nsIFormControl* oldDefaultSubmit = mDefaultSubmitElement;
 4336:     if (!*firstSubmitSlot ||
 4336:         (!lastElement &&
 4336:          CompareFormControlPosition(aChild, *firstSubmitSlot, this) < 0)) {
32865:       // Update mDefaultSubmitElement if it's currently in a valid state.
32865:       // Valid state means either non-null or null because there are in fact
32865:       // no submit elements around.
32865:       if ((mDefaultSubmitElement ||
32865:            (!mFirstSubmitInElements && !mFirstSubmitNotInElements)) &&
32865:           (*firstSubmitSlot == mDefaultSubmitElement ||
 4336:            CompareFormControlPosition(aChild,
32865:                                       mDefaultSubmitElement, this) < 0)) {
    1:         mDefaultSubmitElement = aChild;
    1:       }
 4336:       *firstSubmitSlot = aChild;
 4336:     }
 4336:     NS_POSTCONDITION(mDefaultSubmitElement == mFirstSubmitInElements ||
32865:                      mDefaultSubmitElement == mFirstSubmitNotInElements ||
32865:                      !mDefaultSubmitElement,
 4336:                      "What happened here?");
    1: 
    1:     // Notify that the state of the previous default submit element has changed
    1:     // if the element which is the default submit element has changed.  The new
    1:     // default submit element is responsible for its own ContentStatesChanged
    1:     // call.
 4336:     if (aNotify && oldDefaultSubmit &&
 4336:         oldDefaultSubmit != mDefaultSubmitElement) {
    1:       nsIDocument* document = GetCurrentDoc();
    1:       if (document) {
    1:         MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, PR_TRUE);
 4336:         nsCOMPtr<nsIContent> oldElement(do_QueryInterface(oldDefaultSubmit));
    1:         document->ContentStatesChanged(oldElement, nsnull,
    1:                                        NS_EVENT_STATE_DEFAULT);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::AddElementToTable(nsIFormControl* aChild,
    1:                                      const nsAString& aName)
    1: {
    1:   return mControls->AddElementToTable(aChild, aName);  
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLFormElement::RemoveElement(nsIFormControl* aChild,
    1:                                  PRBool aNotify) 
    1: {
    1:   //
    1:   // Remove it from the radio group if it's a radio button
    1:   //
    1:   nsresult rv = NS_OK;
    1:   if (aChild->GetType() == NS_FORM_INPUT_RADIO) {
    1:     nsCOMPtr<nsIRadioControlElement> radio = do_QueryInterface(aChild);
    1:     rv = radio->WillRemoveFromRadioGroup();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // Determine whether to remove the child from the elements list
    1:   // or the not in elements list.
    1:   PRBool childInElements = ShouldBeInElements(aChild);
    1:   nsTArray<nsIFormControl*>& controls = childInElements ?
    1:       mControls->mElements :  mControls->mNotInElements;
    1:   
    1:   // Find the index of the child. This will be used later if necessary
    1:   // to find the default submit.
    1:   PRUint32 index = controls.IndexOf(aChild);
22221:   NS_ENSURE_STATE(index != controls.NoIndex);
    1: 
    1:   controls.RemoveElementAt(index);
    1: 
 4336:   // Update our mFirstSubmit* values.
 4336:   nsIFormControl** firstSubmitSlot =
 4336:     childInElements ? &mFirstSubmitInElements : &mFirstSubmitNotInElements;
 4336:   if (aChild == *firstSubmitSlot) {
 4336:     *firstSubmitSlot = nsnull;
 4336: 
 4336:     // We are removing the first submit in this list, find the new first submit
 4336:     PRUint32 length = controls.Length();
 4336:     for (PRUint32 i = index; i < length; ++i) {
 4336:       nsIFormControl* currentControl = controls[i];
 4336:       if (currentControl->IsSubmitControl()) {
 4336:         *firstSubmitSlot = currentControl;
 4336:         break;
 4336:       }
 4336:     }
    1:   }
    1: 
 4336:   if (aChild == mDefaultSubmitElement) {
32319:     // Need to reset mDefaultSubmitElement.  Do this asynchronously so
32319:     // that we're not doing it while the DOM is in flux.
32319:     mDefaultSubmitElement = nsnull;
32319:     nsContentUtils::AddScriptRunner(new RemoveElementRunnable(this, aNotify));
32319: 
32319:     // Note that we don't need to notify on the old default submit (which is
32319:     // being removed) because it's either being removed from the DOM or
32319:     // changing attributes in a way that makes it responsible for sending its
32319:     // own notifications.
32319:   }
32319: 
32319:   return rv;
32319: }
32319: 
32319: void
32319: nsHTMLFormElement::HandleDefaultSubmitRemoval(PRBool aNotify)
32319: {
32319:   if (mDefaultSubmitElement) {
32319:     // Already got reset somehow; nothing else to do here
32319:     return;
32319:   }
32319: 
 4336:   if (!mFirstSubmitNotInElements) {
 4336:     mDefaultSubmitElement = mFirstSubmitInElements;
 4336:   } else if (!mFirstSubmitInElements) {
 4336:     mDefaultSubmitElement = mFirstSubmitNotInElements;
 4336:   } else {
 4336:     NS_ASSERTION(mFirstSubmitInElements != mFirstSubmitNotInElements,
 4336:                  "How did that happen?");
 4336:     // Have both; use the earlier one
 4336:     mDefaultSubmitElement =
 4336:       CompareFormControlPosition(mFirstSubmitInElements,
 4336:                                  mFirstSubmitNotInElements, this) < 0 ?
 4336:       mFirstSubmitInElements : mFirstSubmitNotInElements;
    1:   }
    1: 
 4336:   NS_POSTCONDITION(mDefaultSubmitElement == mFirstSubmitInElements ||
 4336:                    mDefaultSubmitElement == mFirstSubmitNotInElements,
 4336:                    "What happened here?");
    1: 
32319:   // Notify about change if needed.
 4336:   if (aNotify && mDefaultSubmitElement) {
    1:     nsIDocument* document = GetCurrentDoc();
    1:     if (document) {
    1:       MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, PR_TRUE);
    1:       nsCOMPtr<nsIContent> newElement(do_QueryInterface(mDefaultSubmitElement));
    1:       document->ContentStatesChanged(newElement, nsnull,
    1:                                      NS_EVENT_STATE_DEFAULT);
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::RemoveElementFromTable(nsIFormControl* aElement,
    1:                                           const nsAString& aName)
    1: {
    1:   return mControls->RemoveElementFromTable(aElement, aName);
    1: }
    1: 
20237: NS_IMETHODIMP_(already_AddRefed<nsISupports>)
20237: nsHTMLFormElement::ResolveName(const nsAString& aName)
    1: {
20237:   return DoResolveName(aName, PR_TRUE);
    1: }
    1: 
20237: already_AddRefed<nsISupports>
    1: nsHTMLFormElement::DoResolveName(const nsAString& aName,
20237:                                  PRBool aFlushContent)
    1: {
21159:   nsISupports *result;
21159:   NS_IF_ADDREF(result = mControls->NamedItemInternal(aName, aFlushContent));
20237:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnSubmitClickBegin()
    1: {
    1:   mDeferSubmission = PR_TRUE;
    1: 
    1:   // Prepare to run NotifySubmitObservers early before the
    1:   // scripts on the page get to modify the form data, possibly
    1:   // throwing off any password manager. (bug 257781)
    1:   nsCOMPtr<nsIURI> actionURI;
    1:   nsresult rv;
    1: 
    1:   rv = GetActionURL(getter_AddRefs(actionURI));
    1:   if (NS_FAILED(rv) || !actionURI)
    1:     return NS_OK;
    1: 
    1:   //
    1:   // Notify observers of submit
    1:   //
    1:   PRBool cancelSubmit = PR_FALSE;
    1:   rv = NotifySubmitObservers(actionURI, &cancelSubmit, PR_TRUE);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     mNotifiedObservers = PR_TRUE;
    1:     mNotifiedObserversResult = cancelSubmit;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnSubmitClickEnd()
    1: {
    1:   mDeferSubmission = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::FlushPendingSubmission()
    1: {
    1:   nsCOMPtr<nsIFormSubmission> kunkFuDeathGrip(mPendingSubmission);
    1: 
    1:   if (!mPendingSubmission) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   //
    1:   // perform the submission with the stored pending submission
    1:   //
    1:   SubmitSubmission(mPendingSubmission);
    1: 
    1:   // now delete the pending submission object
    1:   mPendingSubmission = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::ForgetPendingSubmission()
    1: {
    1:   // just delete the pending submission
    1:   mPendingSubmission = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetActionURL(nsIURI** aActionURL)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   *aActionURL = nsnull;
    1: 
    1:   //
    1:   // Grab the URL string
    1:   //
    1:   nsAutoString action;
    1:   GetAction(action);
    1: 
    1:   //
    1:   // Form the full action URL
    1:   //
    1: 
    1:   // Get the document to form the URL.
    1:   // We'll also need it later to get the DOM window when notifying form submit
    1:   // observers (bug 33203)
    1:   if (!IsInDoc()) {
    1:     return NS_OK; // No doc means don't submit, see Bug 28988
    1:   }
    1: 
    1:   // Get base URL
    1:   nsIDocument *document = GetOwnerDoc();
    1:   nsIURI *docURI = document->GetDocumentURI();
    1:   NS_ENSURE_TRUE(docURI, NS_ERROR_UNEXPECTED);
    1: 
    1:   // If an action is not specified and we are inside
    1:   // a HTML document then reload the URL. This makes us
    1:   // compatible with 4.x browsers.
    1:   // If we are in some other type of document such as XML or
    1:   // XUL, do nothing. This prevents undesirable reloading of
    1:   // a document inside XUL.
    1: 
    1:   nsCOMPtr<nsIURI> actionURL;
    1:   if (action.IsEmpty()) {
    1:     nsCOMPtr<nsIHTMLDocument> htmlDoc(do_QueryInterface(document));
    1:     if (!htmlDoc) {
    1:       // Must be a XML, XUL or other non-HTML document type
    1:       // so do nothing.
    1:       return NS_OK;
    1:     }
    1: 
    1:     rv = docURI->Clone(getter_AddRefs(actionURL));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     nsCOMPtr<nsIURI> baseURL = GetBaseURI();
    1:     NS_ASSERTION(baseURL, "No Base URL found in Form Submit!\n");
    1:     if (!baseURL) {
    1:       return NS_OK; // No base URL -> exit early, see Bug 30721
    1:     }
    1:     rv = NS_NewURI(getter_AddRefs(actionURL), action, nsnull, baseURL);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   //
    1:   // Verify the URL should be reached
    1:   //
    1:   // Get security manager, check to see if access to action URI is allowed.
    1:   //
    1:   nsIScriptSecurityManager *securityManager =
    1:       nsContentUtils::GetSecurityManager();
    1:   rv = securityManager->
    1:     CheckLoadURIWithPrincipal(NodePrincipal(), actionURL,
    1:                               nsIScriptSecurityManager::STANDARD);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   //
    1:   // Assign to the output
    1:   //
    1:   *aActionURL = actionURL;
    1:   NS_ADDREF(*aActionURL);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetSortedControls(nsTArray<nsIFormControl*>& aControls) const
    1: {
    1:   return mControls->GetSortedControls(aControls);
    1: }
    1: 
    1: NS_IMETHODIMP_(nsIFormControl*)
    1: nsHTMLFormElement::GetDefaultSubmitElement() const
    1: {
 4336:   NS_PRECONDITION(mDefaultSubmitElement == mFirstSubmitInElements ||
 4336:                   mDefaultSubmitElement == mFirstSubmitNotInElements,
 4336:                   "What happened here?");
 4336:   
    1:   return mDefaultSubmitElement;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
32864: nsHTMLFormElement::IsDefaultSubmitElement(const nsIFormControl* aControl) const
32864: {
32864:   NS_PRECONDITION(aControl, "Unexpected call");
32864: 
32864:   if (aControl == mDefaultSubmitElement) {
32864:     // Yes, it is
32864:     return PR_TRUE;
32864:   }
32864: 
32864:   if (mDefaultSubmitElement ||
32864:       (aControl != mFirstSubmitInElements &&
32864:        aControl != mFirstSubmitNotInElements)) {
32864:     // It isn't
32864:     return PR_FALSE;
32864:   }
32864: 
32864:   // mDefaultSubmitElement is null, but we have a non-null submit around
32864:   // (aControl, in fact).  figure out whether it's in fact the default submit
32864:   // and just hasn't been set that way yet.  Note that we can't just call
32864:   // HandleDefaultSubmitRemoval because we might need to notify to handle that
32864:   // correctly and we don't know whether that's safe right here.
32864:   if (!mFirstSubmitInElements || !mFirstSubmitNotInElements) {
32864:     // We only have one first submit; aControl has to be it
32864:     return PR_TRUE;
32864:   }
32864: 
32864:   // We have both kinds of submits.  Check which comes first.
32864:   nsIFormControl* defaultSubmit =
32864:     CompareFormControlPosition(mFirstSubmitInElements,
32864:                                mFirstSubmitNotInElements, this) < 0 ?
32864:       mFirstSubmitInElements : mFirstSubmitNotInElements;
32864:   return aControl == defaultSubmit;
32864: }
32864: 
32864: NS_IMETHODIMP_(PRBool)
    1: nsHTMLFormElement::HasSingleTextControl() const
    1: {
    1:   // Input text controls are always in the elements list.
    1:   PRUint32 numTextControlsFound = 0;
    1:   PRUint32 length = mControls->mElements.Length();
    1:   for (PRUint32 i = 0; i < length && numTextControlsFound < 2; ++i) {
    1:     PRInt32 type = mControls->mElements[i]->GetType();
    1:     if (type == NS_FORM_INPUT_TEXT || type == NS_FORM_INPUT_PASSWORD) {
    1:         numTextControlsFound++;
    1:     }
    1:   }
    1:   return numTextControlsFound == 1;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetEncoding(nsAString& aEncoding)
    1: {
    1:   return GetEnctype(aEncoding);
    1: }
    1:  
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::SetEncoding(const nsAString& aEncoding)
    1: {
    1:   return SetEnctype(aEncoding);
    1: }
    1:  
    1: NS_IMETHODIMP    
    1: nsHTMLFormElement::GetLength(PRInt32* aLength)
    1: {
    1:   PRUint32 length;
    1:   nsresult rv = mControls->GetLength(&length);
    1:   *aLength = length;
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsHTMLFormElement::ForgetCurrentSubmission()
    1: {
    1:   mNotifiedObservers = PR_FALSE;
    1:   mIsSubmitting = PR_FALSE;
    1:   mSubmittingRequest = nsnull;
 8462:   nsCOMPtr<nsIWebProgress> webProgress = do_QueryReferent(mWebProgress);
 8462:   if (webProgress) {
 8462:     webProgress->RemoveProgressListener(this);
 8462:   }
 8443:   mWebProgress = nsnull;
 8440: }
    1: 
    1: // nsIWebProgressListener
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnStateChange(nsIWebProgress* aWebProgress,
    1:                                  nsIRequest* aRequest,
    1:                                  PRUint32 aStateFlags,
    1:                                  PRUint32 aStatus)
    1: {
    1:   // If STATE_STOP is never fired for any reason (redirect?  Failed state
    1:   // change?) the form element will leak.  It will be kept around by the
    1:   // nsIWebProgressListener (assuming it keeps a strong pointer).  We will
    1:   // consequently leak the request.
    1:   if (aRequest == mSubmittingRequest &&
    1:       aStateFlags & nsIWebProgressListener::STATE_STOP) {
    1:     ForgetCurrentSubmission();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnProgressChange(nsIWebProgress* aWebProgress,
    1:                                     nsIRequest* aRequest,
    1:                                     PRInt32 aCurSelfProgress,
    1:                                     PRInt32 aMaxSelfProgress,
    1:                                     PRInt32 aCurTotalProgress,
    1:                                     PRInt32 aMaxTotalProgress)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnLocationChange(nsIWebProgress* aWebProgress,
    1:                                     nsIRequest* aRequest,
    1:                                     nsIURI* location)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnStatusChange(nsIWebProgress* aWebProgress,
    1:                                   nsIRequest* aRequest,
    1:                                   nsresult aStatus,
    1:                                   const PRUnichar* aMessage)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::OnSecurityChange(nsIWebProgress* aWebProgress,
    1:                                     nsIRequest* aRequest,
    1:                                     PRUint32 state)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1:  
20237: NS_IMETHODIMP_(PRInt32)
20237: nsHTMLFormElement::IndexOfControl(nsIFormControl* aControl)
    1: {
20237:   PRInt32 index = nsnull;
20237:   return mControls->IndexOfControl(aControl, &index) == NS_OK ? index : nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::SetCurrentRadioButton(const nsAString& aName,
    1:                                          nsIDOMHTMLInputElement* aRadio)
    1: {
    1:   NS_ENSURE_TRUE(mSelectedRadioButtons.Put(aName, aRadio),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetCurrentRadioButton(const nsAString& aName,
    1:                                          nsIDOMHTMLInputElement** aRadio)
    1: {
    1:   mSelectedRadioButtons.Get(aName, aRadio);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
    1:                                       PRInt32 *aPositionIndex,
    1:                                       PRInt32 *aItemsInGroup)
    1: {
    1:   *aPositionIndex = 0;
    1:   *aItemsInGroup = 1;
    1: 
    1:   nsAutoString name;
    1:   aRadio->GetName(name);
    1:   if (name.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupports> itemWithName;
20237:   itemWithName = ResolveName(name);
20237:   NS_ENSURE_TRUE(itemWithName, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsIDOMNodeList> radioNodeList(do_QueryInterface(itemWithName));
    1: 
    1:   // XXX If ResolveName could return an nsContentList instead then we 
    1:   //     could get an nsContentList instead of using this hacky upcast
    1:   nsBaseContentList *radioGroup =
 3233:     static_cast<nsBaseContentList *>((nsIDOMNodeList *)radioNodeList);
    1:   NS_ASSERTION(radioGroup, "No such radio group in this container");
    1:   if (!radioGroup) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> currentRadioNode(do_QueryInterface(aRadio));
    1:   NS_ASSERTION(currentRadioNode, "No nsIContent for current radio button");
    1:   *aPositionIndex = radioGroup->IndexOf(currentRadioNode, PR_TRUE);
    1:   NS_ASSERTION(*aPositionIndex >= 0, "Radio button not found in its own group");
    1:   PRUint32 itemsInGroup;
    1:   radioGroup->GetLength(&itemsInGroup);
    1:   *aItemsInGroup = itemsInGroup;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::GetNextRadioButton(const nsAString& aName,
    1:                                       const PRBool aPrevious,
    1:                                       nsIDOMHTMLInputElement*  aFocusedRadio,
    1:                                       nsIDOMHTMLInputElement** aRadioOut)
    1: {
    1:   // Return the radio button relative to the focused radio button.
    1:   // If no radio is focused, get the radio relative to the selected one.
    1:   *aRadioOut = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
    1:   if (aFocusedRadio) {
    1:     currentRadio = aFocusedRadio;
    1:   }
    1:   else {
    1:     mSelectedRadioButtons.Get(aName, getter_AddRefs(currentRadio));
    1:   }
    1: 
20237:   nsCOMPtr<nsISupports> itemWithName = ResolveName(aName);
    1:   nsCOMPtr<nsIDOMNodeList> radioNodeList(do_QueryInterface(itemWithName));
    1: 
    1:   // XXX If ResolveName could return an nsContentList instead then we 
    1:   //     could get an nsContentList instead of using this hacky upcast
    1: 
    1:   nsBaseContentList *radioGroup =
 3233:     static_cast<nsBaseContentList *>((nsIDOMNodeList *)radioNodeList);
    1:   if (!radioGroup) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> currentRadioNode(do_QueryInterface(currentRadio));
    1:   NS_ASSERTION(currentRadioNode, "No nsIContent for current radio button");
    1:   PRInt32 index = radioGroup->IndexOf(currentRadioNode, PR_TRUE);
    1:   if (index < 0) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PRUint32 numRadios;
    1:   radioGroup->GetLength(&numRadios);
    1:   PRBool disabled = PR_TRUE;
    1:   nsCOMPtr<nsIDOMHTMLInputElement> radio;
    1:   nsCOMPtr<nsIDOMNode> radioDOMNode;
    1:   nsCOMPtr<nsIFormControl> formControl;
    1: 
    1:   do {
    1:     if (aPrevious) {
    1:       if (--index < 0) {
    1:         index = numRadios -1;
    1:       }
    1:     }
    1:     else if (++index >= (PRInt32)numRadios) {
    1:       index = 0;
    1:     }
    1:     radioGroup->Item(index, getter_AddRefs(radioDOMNode));
    1:     radio = do_QueryInterface(radioDOMNode);
    1:     if (!radio)
    1:       continue;
    1: 
    1:     formControl = do_QueryInterface(radio);
    1:     if (!formControl || formControl->GetType() != NS_FORM_INPUT_RADIO)
    1:       continue;
    1: 
    1:     radio->GetDisabled(&disabled);
    1:   } while (disabled && radio != currentRadio);
    1: 
    1:   NS_IF_ADDREF(*aRadioOut = radio);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::WalkRadioGroup(const nsAString& aName,
    1:                                   nsIRadioVisitor* aVisitor,
    1:                                   PRBool aFlushContent)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   PRBool stopIterating = PR_FALSE;
    1: 
    1:   if (aName.IsEmpty()) {
    1:     //
    1:     // XXX If the name is empty, it's not stored in the control list.  There
    1:     // *must* be a more efficient way to do this.
    1:     //
    1:     nsCOMPtr<nsIFormControl> control;
20237:     PRUint32 len = GetElementCount();
    1:     for (PRUint32 i=0; i<len; i++) {
    1:       GetElementAt(i, getter_AddRefs(control));
    1:       if (control->GetType() == NS_FORM_INPUT_RADIO) {
    1:         nsCOMPtr<nsIContent> controlContent(do_QueryInterface(control));
    1:         if (controlContent) {
    1:           if (controlContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
    1:                                           EmptyString(), eCaseMatters)) {
    1:             aVisitor->Visit(control, &stopIterating);
    1:             if (stopIterating) {
    1:               break;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   } else {
    1:     //
    1:     // Get the control / list of controls from the form using form["name"]
    1:     //
    1:     nsCOMPtr<nsISupports> item;
20237:     item = DoResolveName(aName, aFlushContent);
20237:     rv = item ? NS_OK : NS_ERROR_FAILURE;
    1: 
    1:     if (item) {
    1:       //
    1:       // If it's just a lone radio button, then select it.
    1:       //
    1:       nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(item));
    1:       if (formControl) {
    1:         if (formControl->GetType() == NS_FORM_INPUT_RADIO) {
    1:           aVisitor->Visit(formControl, &stopIterating);
    1:         }
    1:       } else {
    1:         nsCOMPtr<nsIDOMNodeList> nodeList(do_QueryInterface(item));
    1:         if (nodeList) {
    1:           PRUint32 length = 0;
    1:           nodeList->GetLength(&length);
    1:           for (PRUint32 i=0; i<length; i++) {
    1:             nsCOMPtr<nsIDOMNode> node;
    1:             nodeList->Item(i, getter_AddRefs(node));
    1:             nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(node));
    1:             if (formControl) {
    1:               if (formControl->GetType() == NS_FORM_INPUT_RADIO) {
    1:                 aVisitor->Visit(formControl, &stopIterating);
    1:                 if (stopIterating) {
    1:                   break;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::AddToRadioGroup(const nsAString& aName,
    1:                                    nsIFormControl* aRadio)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLFormElement::RemoveFromRadioGroup(const nsAString& aName,
    1:                                         nsIFormControl* aRadio)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsFormControlList implementation, this could go away if there were
    1: // a lightweight collection implementation somewhere
    1: 
    1: nsFormControlList::nsFormControlList(nsHTMLFormElement* aForm) :
    1:   mForm(aForm),
    1:   // Initialize the elements list to have an initial capacity
    1:   // of 8 to reduce allocations on small forms.
    1:   mElements(8)
    1: {
    1: }
    1: 
    1: nsFormControlList::~nsFormControlList()
    1: {
    1:   mForm = nsnull;
    1:   Clear();
    1: }
    1: 
    1: nsresult nsFormControlList::Init()
    1: {
    1:   NS_ENSURE_TRUE(
    1:     mNameLookupTable.Init(NS_FORM_CONTROL_LIST_HASHTABLE_SIZE),
    1:     NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFormControlList::DropFormReference()
    1: {
    1:   mForm = nsnull;
    1:   Clear();
    1: }
    1: 
    1: void
    1: nsFormControlList::Clear()
    1: {
    1:   // Null out childrens' pointer to me.  No refcounting here
    1:   PRInt32 i;
    1:   for (i = mElements.Length()-1; i >= 0; i--) {
19131:     mElements[i]->ClearForm(PR_FALSE, PR_TRUE);
    1:   }
    1:   mElements.Clear();
    1: 
    1:   for (i = mNotInElements.Length()-1; i >= 0; i--) {
19131:     mNotInElements[i]->ClearForm(PR_FALSE, PR_TRUE);
    1:   }
    1:   mNotInElements.Clear();
    1: 
    1:   mNameLookupTable.Clear();
    1: }
    1: 
    1: void
    1: nsFormControlList::FlushPendingNotifications()
    1: {
    1:   if (mForm) {
    1:     nsIDocument* doc = mForm->GetCurrentDoc();
    1:     if (doc) {
    1:       doc->FlushPendingNotifications(Flush_Content);
    1:     }
    1:   }
    1: }
    1: 
20261: static PLDHashOperator
    1: ControlTraverser(const nsAString& key, nsISupports* control, void* userArg)
    1: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
    1:  
    1:   cb->NoteXPCOMChild(control);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsFormControlList)
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFormControlList)
    1:   tmp->Clear();
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFormControlList)
    1:   tmp->mNameLookupTable.EnumerateRead(ControlTraverser, &cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: // XPConnect interface list for nsFormControlList
 4838: NS_INTERFACE_TABLE_HEAD(nsFormControlList)
20752:   NS_INTERFACE_TABLE3(nsFormControlList,
20752:                       nsIHTMLCollection,
 4838:                       nsIDOMHTMLCollection,
 4838:                       nsIDOMNSHTMLFormControlList)
 4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsFormControlList)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLFormControlCollection)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
20752: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsFormControlList, nsIHTMLCollection)
20752: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsFormControlList, nsIHTMLCollection)
    1: 
    1: 
    1: // nsIDOMHTMLCollection interface
    1: 
    1: NS_IMETHODIMP    
    1: nsFormControlList::GetLength(PRUint32* aLength)
    1: {
    1:   FlushPendingNotifications();
    1:   *aLength = mElements.Length();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormControlList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
    1: {
20752:   nsresult rv;
20752:   nsISupports* item = GetNodeAt(aIndex, &rv);
20752:   if (!item) {
20752:     *aReturn = nsnull;
19144: 
20752:     return rv;
19144:   }
19144: 
20752:   return CallQueryInterface(item, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsFormControlList::NamedItem(const nsAString& aName,
    1:                              nsIDOMNode** aReturn)
    1: {
    1:   FlushPendingNotifications();
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCOMPtr<nsISupports> supports;
    1:   
    1:   if (!mNameLookupTable.Get(aName, getter_AddRefs(supports))) // key not found
    1:      return rv;
    1: 
    1:   if (supports) {
    1:     // We found something, check if it's a node
    1:     CallQueryInterface(supports, aReturn);
    1: 
    1:     if (!*aReturn) {
    1:       // If not, we check if it's a node list.
    1:       nsCOMPtr<nsIDOMNodeList> nodeList(do_QueryInterface(supports));
    1:       NS_ASSERTION(nodeList, "Huh, what's going one here?");
    1: 
    1:       if (nodeList) {
    1:         // And since we're only asking for one node here, we return the first
    1:         // one from the list.
    1:         rv = nodeList->Item(0, aReturn);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFormControlList::NamedItem(const nsAString& aName,
    1:                              nsISupports** aReturn)
    1: {
21159:   NS_IF_ADDREF(*aReturn = NamedItemInternal(aName, PR_TRUE));
    1:   return NS_OK;
    1: }
    1: 
21159: nsISupports*
    1: nsFormControlList::NamedItemInternal(const nsAString& aName,
21159:                                      PRBool aFlushContent)
    1: {
    1:   if (aFlushContent) {
    1:     FlushPendingNotifications();
    1:   }
    1: 
21159:   return mNameLookupTable.GetWeak(aName);
    1: }
    1: 
    1: nsresult
    1: nsFormControlList::AddElementToTable(nsIFormControl* aChild,
    1:                                      const nsAString& aName)
    1: {
    1:   if (!ShouldBeInElements(aChild)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupports> supports;
    1:   mNameLookupTable.Get(aName, getter_AddRefs(supports));
    1: 
    1:   if (!supports) {
    1:     // No entry found, add the form control
    1:     nsCOMPtr<nsISupports> child(do_QueryInterface(aChild));
    1: 
    1:     NS_ENSURE_TRUE( mNameLookupTable.Put(aName, child), NS_ERROR_FAILURE );
    1:   } else {
    1:     // Found something in the hash, check its type
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(supports));
    1:     nsCOMPtr<nsIContent> newChild(do_QueryInterface(aChild));
    1: 
    1:     if (content) {
    1:       // Check if the new content is the same as the one we found in the
    1:       // hash, if it is then we leave it in the hash as it is, this will
    1:       // happen if a form control has both a name and an id with the same
    1:       // value
    1:       if (content == newChild) {
    1:         return NS_OK;
    1:       }
    1: 
    1:       // Found an element, create a list, add the element to the list and put
    1:       // the list in the hash
    1:       nsBaseContentList *list = new nsBaseContentList();
    1:       NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
30639:       NS_ASSERTION(content->GetParent(), "Item in list without parent");
    1: 
30639:       // Determine the ordering between the new and old element.
30639:       PRBool newFirst = nsContentUtils::PositionIsBefore(newChild, content);
30639: 
30639:       list->AppendElement(newFirst ? newChild : content);
30639:       list->AppendElement(newFirst ? content : newChild);
30639: 
    1: 
19145:       nsCOMPtr<nsISupports> listSupports =
19146:         do_QueryInterface(static_cast<nsIDOMNodeList*>(list));
    1: 
    1:       // Replace the element with the list.
    1:       NS_ENSURE_TRUE(mNameLookupTable.Put(aName, listSupports),
    1:                      NS_ERROR_FAILURE);
    1:     } else {
    1:       // There's already a list in the hash, add the child to the list
    1:       nsCOMPtr<nsIDOMNodeList> nodeList(do_QueryInterface(supports));
    1:       NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1: 
    1:       // Upcast, uggly, but it works!
 3233:       nsBaseContentList *list = static_cast<nsBaseContentList *>
 3233:                                            ((nsIDOMNodeList *)nodeList.get());
    1: 
30639:       NS_ASSERTION(list->Length() > 1,
30639:                    "List should have been converted back to a single element");
    1:       
30639:       if(nsContentUtils::PositionIsBefore(list->GetNodeAt(list->Length() - 1), newChild)) {
    1:           list->AppendElement(newChild);
30639:           return NS_OK;
    1:       }
30639:       
30639:       // first is the first possible insertion index, last is the last possible
30639:       // insertion index
30639:       PRUint32 first = 0;
30639:       PRUint32 last = list->Length() - 1;
30639:       PRUint32 mid;
30639:       
30639:       //Stop when there is only one index in our range
30639:       while (last != first) {
30639:           mid = (first + last) / 2;
30639:           
30639:           if (nsContentUtils::PositionIsBefore(newChild, list->GetNodeAt(mid)))
30639:             last = mid;
30639:           else
30639:             first = mid + 1;
30639:         }
30639: 
30639:       list->InsertElementAt(newChild, first);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFormControlList::IndexOfControl(nsIFormControl* aControl,
    1:                                   PRInt32* aIndex)
    1: {
    1:   // Note -- not a DOM method; callers should handle flushing themselves
    1:   
    1:   NS_ENSURE_ARG_POINTER(aIndex);
    1: 
    1:   *aIndex = mElements.IndexOf(aControl);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFormControlList::RemoveElementFromTable(nsIFormControl* aChild,
    1:                                           const nsAString& aName)
    1: {
    1:   if (!ShouldBeInElements(aChild)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aChild);  
    1:   if (!content) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsISupports> supports;
    1: 
    1:   if (!mNameLookupTable.Get(aName, getter_AddRefs(supports)))
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIFormControl> fctrl(do_QueryInterface(supports));
    1: 
    1:   if (fctrl) {
    1:     // Single element in the hash, just remove it if it's the one
    1:     // we're trying to remove...
    1:     if (fctrl == aChild) {
    1:       mNameLookupTable.Remove(aName);
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList(do_QueryInterface(supports));
    1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1: 
    1:   // Upcast, uggly, but it works!
 3233:   nsBaseContentList *list = static_cast<nsBaseContentList *>
 3233:                                        ((nsIDOMNodeList *)nodeList.get());
    1: 
    1:   list->RemoveElement(content);
    1: 
    1:   PRUint32 length = 0;
    1:   list->GetLength(&length);
    1: 
    1:   if (!length) {
    1:     // If the list is empty we remove if from our hash, this shouldn't
    1:     // happen tho
    1:     mNameLookupTable.Remove(aName);
    1:   } else if (length == 1) {
    1:     // Only one element left, replace the list in the hash with the
    1:     // single element.
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     list->Item(0, getter_AddRefs(node));
    1: 
    1:     if (node) {
    1:       nsCOMPtr<nsISupports> tmp(do_QueryInterface(node));
    1:       NS_ENSURE_TRUE(mNameLookupTable.Put(aName, tmp),NS_ERROR_FAILURE);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsFormControlList::GetSortedControls(nsTArray<nsIFormControl*>& aControls) const
    1: {
 4014: #ifdef DEBUG
 4014:   AssertDocumentOrder(mElements, mForm);
 4014:   AssertDocumentOrder(mNotInElements, mForm);
 4014: #endif
 4014: 
    1:   aControls.Clear();
    1: 
    1:   // Merge the elements list and the not in elements list. Both lists are
    1:   // already sorted.
    1:   PRUint32 elementsLen = mElements.Length();
    1:   PRUint32 notInElementsLen = mNotInElements.Length();
    1:   aControls.SetCapacity(elementsLen + notInElementsLen);
    1: 
    1:   PRUint32 elementsIdx = 0;
    1:   PRUint32 notInElementsIdx = 0;
    1: 
    1:   while (elementsIdx < elementsLen || notInElementsIdx < notInElementsLen) {
    1:     // Check whether we're done with mElements
    1:     if (elementsIdx == elementsLen) {
    1:       NS_ASSERTION(notInElementsIdx < notInElementsLen,
    1:                    "Should have remaining not-in-elements");
    1:       // Append the remaining mNotInElements elements
    1:       if (!aControls.AppendElements(mNotInElements.Elements() +
    1:                                       notInElementsIdx,
    1:                                     notInElementsLen -
    1:                                       notInElementsIdx)) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       break;
    1:     }
    1:     // Check whether we're done with mNotInElements
    1:     if (notInElementsIdx == notInElementsLen) {
    1:       NS_ASSERTION(elementsIdx < elementsLen,
    1:                    "Should have remaining in-elements");
    1:       // Append the remaining mElements elements
    1:       if (!aControls.AppendElements(mElements.Elements() +
    1:                                       elementsIdx,
    1:                                     elementsLen -
    1:                                       elementsIdx)) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       break;
    1:     }
    1:     // Both lists have elements left.
    1:     NS_ASSERTION(mElements[elementsIdx] &&
    1:                  mNotInElements[notInElementsIdx],
    1:                  "Should have remaining elements");
    1:     // Determine which of the two elements should be ordered
    1:     // first and add it to the end of the list.
    1:     nsIFormControl* elementToAdd;
    1:     if (CompareFormControlPosition(mElements[elementsIdx],
 4014:                                    mNotInElements[notInElementsIdx],
 4014:                                    mForm) < 0) {
    1:       elementToAdd = mElements[elementsIdx];
    1:       ++elementsIdx;
    1:     } else {
    1:       elementToAdd = mNotInElements[notInElementsIdx];
    1:       ++notInElementsIdx;
    1:     }
    1:     // Add the first element to the list.
    1:     if (!aControls.AppendElement(elementToAdd)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ASSERTION(aControls.Length() == elementsLen + notInElementsLen,
    1:                "Not all form controls were added to the sorted list");
    1: #ifdef DEBUG
 4014:   AssertDocumentOrder(aControls, mForm);
    1: #endif
 4014: 
    1:   return NS_OK;
    1: }
