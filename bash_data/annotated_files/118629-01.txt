 37880: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 33649: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 33649: 
 33649: /*
 33649:  * Code to notify things that animate before a refresh, at an appropriate
 33649:  * refresh rate.  (Perhaps temporary, until replaced by compositor.)
118629:  *
118629:  * Chrome and each tab have their own RefreshDriver, which in turn
118629:  * hooks into one of a few global timer based on RefreshDriverTimer,
118629:  * defined below.  There are two main global timers -- one for active
118629:  * animations, and one for inactive ones.  These are implemented as
118629:  * subclasses of RefreshDriverTimer; see below for a description of
118629:  * their implementations.  In the future, additional timer types may
118629:  * implement things like blocking on vsync.
 33649:  */
 33649: 
118629: #ifdef XP_WIN
118629: #include <windows.h>
118629: // mmsystem isn't part of WIN32_LEAN_AND_MEAN, so we have
118629: // to manually include it
118629: #include <mmsystem.h>
118629: #endif
118629: 
 80467: #include "mozilla/Util.h"
 80467: 
 33649: #include "nsRefreshDriver.h"
118629: #include "nsITimer.h"
 33649: #include "nsPresContext.h"
 33649: #include "nsComponentManagerUtils.h"
 33649: #include "prlog.h"
 36617: #include "nsAutoPtr.h"
 50365: #include "nsCSSFrameConstructor.h"
 50368: #include "nsIDocument.h"
 50368: #include "nsGUIEvent.h"
 50368: #include "nsEventDispatcher.h"
 50368: #include "jsapi.h"
 51267: #include "nsContentUtils.h"
 70842: #include "mozilla/Preferences.h"
 87344: #include "nsIViewManager.h"
107400: #include "sampler.h"
 51267: 
 51267: using mozilla::TimeStamp;
 67983: using mozilla::TimeDuration;
 33649: 
 70842: using namespace mozilla;
 70842: 
118629: #ifdef PR_LOGGING
118629: static PRLogModuleInfo *gLog = nullptr;
118629: #define LOG(...) PR_LOG(gLog, PR_LOG_NOTICE, (__VA_ARGS__))
118629: #else
118629: #define LOG(...) do { } while(0)
118629: #endif
118629: 
 51267: #define DEFAULT_FRAME_RATE 60
 51546: #define DEFAULT_THROTTLED_FRAME_RATE 1
118629: // after 10 minutes, stop firing off inactive timers
118629: #define DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS 600
 33649: 
118629: namespace mozilla {
118629: 
118629: /*
118629:  * The base class for all global refresh driver timers.  It takes care
118629:  * of managing the list of refresh drivers attached to them and
118629:  * provides interfaces for querying/setting the rate and actually
118629:  * running a timer 'Tick'.  Subclasses must implement StartTimer(),
118629:  * StopTimer(), and ScheduleNextTick() -- the first two just
118629:  * start/stop whatever timer mechanism is in use, and ScheduleNextTick
118629:  * is called at the start of the Tick() implementation to set a time
118629:  * for the next tick.
118629:  */
118629: class RefreshDriverTimer {
118629: public:
118629:   /*
118629:    * aRate -- the delay, in milliseconds, requested between timer firings
118629:    */
118629:   RefreshDriverTimer(double aRate)
118629:   {
118629:     SetRate(aRate);
118629:   }
118629: 
118629:   virtual ~RefreshDriverTimer()
118629:   {
118629:     NS_ASSERTION(mRefreshDrivers.Length() == 0, "Should have removed all refresh drivers from here by now!");
118629:   }
118629: 
118629:   virtual void AddRefreshDriver(nsRefreshDriver* aDriver)
118629:   {
118629:     LOG("[%p] AddRefreshDriver %p", this, aDriver);
118629: 
118629:     NS_ASSERTION(!mRefreshDrivers.Contains(aDriver), "AddRefreshDriver for a refresh driver that's already in the list!");
118629:     mRefreshDrivers.AppendElement(aDriver);
118629: 
118629:     if (mRefreshDrivers.Length() == 1) {
118629:       StartTimer();
118629:     }
118629:   }
118629: 
118629:   virtual void RemoveRefreshDriver(nsRefreshDriver* aDriver)
118629:   {
118629:     LOG("[%p] RemoveRefreshDriver %p", this, aDriver);
118629: 
118629:     NS_ASSERTION(mRefreshDrivers.Contains(aDriver), "RemoveRefreshDriver for a refresh driver that's not in the list!");
118629:     mRefreshDrivers.RemoveElement(aDriver);
118629: 
118629:     if (mRefreshDrivers.Length() == 0) {
118629:       StopTimer();
118629:     }
118629:   }
118629: 
118629:   double GetRate() const
118629:   {
118629:     return mRateMilliseconds;
118629:   }
118629: 
118629:   // will take effect at next timer tick
118629:   virtual void SetRate(double aNewRate)
118629:   {
118629:     mRateMilliseconds = aNewRate;
118629:     mRateDuration = TimeDuration::FromMilliseconds(mRateMilliseconds);
118629:   }
118629: 
118629:   TimeStamp MostRecentRefresh() const { return mLastFireTime; }
118629:   int64_t MostRecentRefreshEpochTime() const { return mLastFireEpoch; }
118629: 
118629: protected:
118629:   virtual void StartTimer() = 0;
118629:   virtual void StopTimer() = 0;
118629:   virtual void ScheduleNextTick(TimeStamp aNowTime) = 0;
118629: 
118629:   /*
118629:    * Actually runs a tick, poking all the attached RefreshDrivers.
118629:    * Grabs the "now" time via JS_Now and TimeStamp::Now().
118629:    */
118629:   void Tick()
118629:   {
118629:     int64_t jsnow = JS_Now();
118629:     TimeStamp now = TimeStamp::Now();
118629: 
118629:     ScheduleNextTick(now);
118629: 
118629:     mLastFireEpoch = jsnow;
118629:     mLastFireTime = now;
118629: 
118629:     LOG("[%p] ticking drivers...", this);
118629:     nsTArray<nsRefPtr<nsRefreshDriver> > drivers(mRefreshDrivers);
118629:     for (size_t i = 0; i < drivers.Length(); ++i) {
118629:       // don't poke this driver if it's in test mode
118629:       if (drivers[i]->IsTestControllingRefreshesEnabled()) {
118629:         continue;
118629:       }
118629: 
118629:       TickDriver(drivers[i], jsnow, now);
118629:     }
118629:     LOG("[%p] done.", this);
118629:   }
118629: 
118629:   static void TickDriver(nsRefreshDriver* driver, int64_t jsnow, TimeStamp now)
118629:   {
118629:     LOG(">> TickDriver: %p (jsnow: %lld)", driver, jsnow);
118629:     driver->Tick(jsnow, now);
118629:   }
118629: 
118629:   double mRateMilliseconds;
118629:   TimeDuration mRateDuration;
118629: 
118629:   int64_t mLastFireEpoch;
118629:   TimeStamp mLastFireTime;
118629:   TimeStamp mTargetTime;
118629: 
118629:   nsTArray<nsRefPtr<nsRefreshDriver> > mRefreshDrivers;
118629: 
118629:   // useful callback for nsITimer-based derived classes, here
118629:   // bacause of c++ protected shenanigans
118629:   static void TimerTick(nsITimer* aTimer, void* aClosure)
118629:   {
118629:     RefreshDriverTimer *timer = static_cast<RefreshDriverTimer*>(aClosure);
118629:     timer->Tick();
118629:   }
118629: };
118629: 
118629: /*
118629:  * A RefreshDriverTimer that uses a nsITimer as the underlying timer.  Note that
118629:  * this is a ONE_SHOT timer, not a repeating one!  Subclasses are expected to
118629:  * implement ScheduleNextTick and intelligently calculate the next time to tick,
118629:  * and to reset mTimer.  Using a repeating nsITimer gets us into a lot of pain
118629:  * with its attempt at intelligent slack removal and such, so we don't do it.
118629:  */
118629: class SimpleTimerBasedRefreshDriverTimer :
118629:     public RefreshDriverTimer
118629: {
118629: public:
118629:   SimpleTimerBasedRefreshDriverTimer(double aRate)
118629:     : RefreshDriverTimer(aRate)
118629:   {
118629:     mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
118629:   }
118629: 
118629:   virtual ~SimpleTimerBasedRefreshDriverTimer()
118629:   {
118629:     StopTimer();
118629:   }
118629: 
118629: protected:
118629: 
118629:   virtual void StartTimer()
118629:   {
118629:     mLastFireTime = TimeStamp::Now();
118629:     mTargetTime = mLastFireTime;
118629: 
118629:     mTimer->InitWithFuncCallback(TimerTick, this, 0, nsITimer::TYPE_ONE_SHOT);
118629:   }
118629: 
118629:   virtual void StopTimer()
118629:   {
118629:     mTimer->Cancel();
118629:   }
118629: 
118629:   nsRefPtr<nsITimer> mTimer;
118629: };
118629: 
118629: /*
118629:  * PreciseRefreshDriverTimer schedules ticks based on the current time
118629:  * and when the next tick -should- be sent if we were hitting our
118629:  * rate.  It always schedules ticks on multiples of aRate -- meaning that
118629:  * if some execution takes longer than an alloted slot, the next tick
118629:  * will be delayed instead of triggering instantly.  This might not be
118629:  * desired -- there's an #if 0'd block below that we could put behind
118629:  * a pref to control this behaviour.
118629:  */
118629: class PreciseRefreshDriverTimer :
118629:     public SimpleTimerBasedRefreshDriverTimer
118629: {
118629: public:
118629:   PreciseRefreshDriverTimer(double aRate)
118629:     : SimpleTimerBasedRefreshDriverTimer(aRate)
118629:   {
118629:   }
118629: 
118629: protected:
118629:   virtual void ScheduleNextTick(TimeStamp aNowTime)
118629:   {
118629:     // The number of (whole) elapsed intervals between the last target
118629:     // time and the actual time.  We want to truncate the double down
118629:     // to an int number of intervals.
118629:     int numElapsedIntervals = static_cast<int>((aNowTime - mTargetTime) / mRateDuration);
118629: 
118629:     // the last "tick" that may or may not have been actually sent was
118629:     // at this time.  For example, if the rate is 15ms, the target
118629:     // time is 200ms, and it's now 225ms, the last effective tick
118629:     // would have been at 215ms.  The next one should then be
118629:     // scheduled for 5 ms from now.
118629:     //
118629:     // We then add another mRateDuration to find the next tick target.
118629:     TimeStamp newTarget = mTargetTime + mRateDuration * (numElapsedIntervals + 1);
118629: 
118629:     // the amount of (integer) ms until the next time we should tick
118629:     uint32_t delay = static_cast<uint32_t>((newTarget - aNowTime).ToMilliseconds());
118629: 
118629:     // Without this block, we'll always schedule on interval ticks;
118629:     // with it, we'll schedule immediately if we missed our tick target
118629:     // last time.
118629: #if 0
118629:     if (numElapsedIntervals > 0) {
118629:       // we're late, so reset
118629:       newTarget = aNowTime;
118629:       delay = 0;
118629:     }
118629: #endif
118629: 
118629:     // log info & lateness
118629:     LOG("[%p] precise timer last tick late by %f ms, next tick in %d ms",
118629:         this,
118629:         (aNowTime - mTargetTime).ToMilliseconds(),
118629:         delay);
118629: 
118629:     // then schedule the timer
118629:     mTimer->InitWithFuncCallback(TimerTick, this, delay, nsITimer::TYPE_ONE_SHOT);
118629: 
118629:     mTargetTime = newTarget;
118629:   }
118629: };
118629: 
118629: /*
118629:  * A RefreshDriverTimer for inactive documents.  When a new refresh driver is
118629:  * added, the rate is reset to the base (normally 1s/1fps).  Every time
118629:  * it ticks, a single refresh driver is poked.  Once they have all been poked,
118629:  * the duration between ticks doubles, up to mDisableAfterMilliseconds.  At that point,
118629:  * the timer is quiet and doesn't tick (until something is added to it again).
118629:  *
118629:  * When a timer is removed, there is a possibility of another timer
118629:  * being skipped for one cycle.  We could avoid this by adjusting
118629:  * mNextDriverIndex in RemoveRefreshDriver, but there's little need to
118629:  * add that complexity.  All we want is for inactive drivers to tick
118629:  * at some point, but we don't care too much about how often.
118629:  */
118629: class InactiveRefreshDriverTimer :
118629:     public RefreshDriverTimer
118629: {
118629: public:
118629:   InactiveRefreshDriverTimer(double aRate)
118629:     : RefreshDriverTimer(aRate),
118629:       mNextTickDuration(aRate),
118629:       mDisableAfterMilliseconds(-1.0),
118629:       mNextDriverIndex(0)
118629:   {
118629:     mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
118629:   }
118629: 
118629:   InactiveRefreshDriverTimer(double aRate, double aDisableAfterMilliseconds)
118629:     : RefreshDriverTimer(aRate),
118629:       mNextTickDuration(aRate),
118629:       mDisableAfterMilliseconds(aDisableAfterMilliseconds),
118629:       mNextDriverIndex(0)
118629:   {
118629:     mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
118629:   }
118629: 
118629:   virtual void AddRefreshDriver(nsRefreshDriver* aDriver)
118629:   {
118629:     RefreshDriverTimer::AddRefreshDriver(aDriver);
118629: 
118629:     LOG("[%p] inactive timer got new refresh driver %p, resetting rate",
118629:         this, aDriver);
118629: 
118629:     // reset the timer, and start with the newly added one next time.
118629:     mNextTickDuration = mRateMilliseconds;
118629: 
118629:     // we don't really have to start with the newly added one, but we may as well
118629:     // not tick the old ones at the fastest rate any more than we need to.
118629:     mNextDriverIndex = mRefreshDrivers.Length() - 1;
118629: 
118629:     StopTimer();
118629:     StartTimer();
118629:   }
118629: 
118629: protected:
118629:   virtual void StartTimer()
118629:   {
118629:     mLastFireTime = TimeStamp::Now();
118629:     mTargetTime = mLastFireTime;
118629: 
118629:     mTimer->InitWithFuncCallback(TimerTickOne, this, 0, nsITimer::TYPE_ONE_SHOT);
118629:   }
118629: 
118629:   virtual void StopTimer()
118629:   {
118629:     mTimer->Cancel();
118629:   }
118629: 
118629:   virtual void ScheduleNextTick(TimeStamp aNowTime)
118629:   {
118629:     if (mDisableAfterMilliseconds > 0.0 &&
118629:         mNextTickDuration > mDisableAfterMilliseconds)
118629:     {
118629:       // We hit the time after which we should disable
118629:       // inactive window refreshes; don't schedule anything
118629:       // until we get kicked by an AddRefreshDriver call.
118629:       return;
118629:     }
118629: 
118629:     // double the next tick time if we've already gone through all of them once
118629:     if (mNextDriverIndex >= mRefreshDrivers.Length()) {
118629:       mNextTickDuration *= 2.0;
118629:       mNextDriverIndex = 0;
118629:     }
118629: 
118629:     // this doesn't need to be precise; do a simple schedule
118629:     uint32_t delay = static_cast<uint32_t>(mNextTickDuration);
118629:     mTimer->InitWithFuncCallback(TimerTickOne, this, delay, nsITimer::TYPE_ONE_SHOT);
118629: 
118629:     LOG("[%p] inactive timer next tick in %f ms [index %d/%d]", this, mNextTickDuration,
118629:         mNextDriverIndex, mRefreshDrivers.Length());
118629:   }
118629: 
118629:   /* Runs just one driver's tick. */
118629:   void TickOne()
118629:   {
118629:     int64_t jsnow = JS_Now();
118629:     TimeStamp now = TimeStamp::Now();
118629: 
118629:     ScheduleNextTick(now);
118629: 
118629:     mLastFireEpoch = jsnow;
118629:     mLastFireTime = now;
118629: 
118629:     nsTArray<nsRefPtr<nsRefreshDriver> > drivers(mRefreshDrivers);
118629:     if (mNextDriverIndex < drivers.Length() &&
118629:         !drivers[mNextDriverIndex]->IsTestControllingRefreshesEnabled())
118629:     {
118629:       TickDriver(drivers[mNextDriverIndex], jsnow, now);
118629:     }
118629: 
118629:     mNextDriverIndex++;
118629:   }
118629: 
118629:   static void TimerTickOne(nsITimer* aTimer, void* aClosure)
118629:   {
118629:     InactiveRefreshDriverTimer *timer = static_cast<InactiveRefreshDriverTimer*>(aClosure);
118629:     timer->TickOne();
118629:   }
118629: 
118629:   nsRefPtr<nsITimer> mTimer;
118629:   double mNextTickDuration;
118629:   double mDisableAfterMilliseconds;
118629:   uint32_t mNextDriverIndex;
118629: };
118629: 
118629: } // namespace mozilla
118629: 
118629: static PreciseRefreshDriverTimer *sRegularRateTimer = nullptr;
118629: static InactiveRefreshDriverTimer *sThrottledRateTimer = nullptr;
118629: 
118629: static int32_t sHighPrecisionTimerRequests = 0;
 63688: 
 63688: /* static */ void
 63688: nsRefreshDriver::InitializeStatics()
 63688: {
118629: #ifdef PR_LOGGING
118629:   if (!gLog) {
118629:     gLog = PR_NewLogModule("nsRefreshDriver");
118629:   }
118629: #endif
118629: }
118629: 
118629: /* static */ void
118629: nsRefreshDriver::Shutdown()
118629: {
118629:   // clean up our timers
118629:   delete sRegularRateTimer;
118629:   delete sThrottledRateTimer;
118629: 
118629:   sRegularRateTimer = nullptr;
118629:   sThrottledRateTimer = nullptr;
 63688: }
 87356: 
108991: /* static */ int32_t
 87356: nsRefreshDriver::DefaultInterval()
 87356: {
 87356:   return NSToIntRound(1000.0 / DEFAULT_FRAME_RATE);
 87356: }
 87356: 
 51267: // Compute the interval to use for the refresh driver timer, in
 51267: // milliseconds
118629: double
118629: nsRefreshDriver::GetRegularTimerInterval() const
118629: {
118629:   int32_t rate = Preferences::GetInt("layout.frame_rate", -1);
118629:   if (rate <= 0) {
118629:     // TODO: get the rate from the platform
118629:     rate = DEFAULT_FRAME_RATE;
118629:   }
118629:   return 1000.0 / rate;
118629: }
118629: 
118629: double
118629: nsRefreshDriver::GetThrottledTimerInterval() const
118629: {
118629:   int32_t rate = Preferences::GetInt("layout.throttled_frame_rate", -1);
118629:   if (rate <= 0) {
118629:     rate = DEFAULT_THROTTLED_FRAME_RATE;
118629:   }
118629:   return 1000.0 / rate;
118629: }
118629: 
118629: double
116501: nsRefreshDriver::GetRefreshTimerInterval() const
116267: {
118629:   return mThrottled ? GetThrottledTimerInterval() : GetRegularTimerInterval();
116267: }
116267: 
118629: RefreshDriverTimer*
118629: nsRefreshDriver::ChooseTimer() const
 51267: {
 63574:   if (mThrottled) {
118629:     if (!sThrottledRateTimer) 
118629:       sThrottledRateTimer = new InactiveRefreshDriverTimer(GetThrottledTimerInterval(),
118629:                                                            DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS * 1000.0);
118629:     return sThrottledRateTimer;
 63574:   }
118629: 
118629:   if (!sRegularRateTimer)
118629:     sRegularRateTimer = new PreciseRefreshDriverTimer(GetRegularTimerInterval());
118629:   return sRegularRateTimer;
 51267: }
 33649: 
 36615: nsRefreshDriver::nsRefreshDriver(nsPresContext* aPresContext)
 37880:   : mPresContext(aPresContext),
118629:     mActiveTimer(nullptr),
 51546:     mFrozen(false),
 63688:     mThrottled(false),
 67983:     mTestControllingRefreshes(false),
 87344:     mViewManagerFlushIsPending(false),
118629:     mRequestedHighPrecision(false)
 33649: {
118629:   mMostRecentRefreshEpochTime = JS_Now();
118629:   mMostRecentRefresh = TimeStamp::Now();
118629: 
 82097:   mRequests.Init();
 33649: }
 33649: 
 33649: nsRefreshDriver::~nsRefreshDriver()
 33649: {
 33649:   NS_ABORT_IF_FALSE(ObserverCount() == 0,
 33649:                     "observers should have unregistered");
118629:   NS_ABORT_IF_FALSE(!mActiveTimer, "timer should be gone");
115319:   
115319:   for (uint32_t i = 0; i < mPresShellsToInvalidateIfHidden.Length(); i++) {
115319:     mPresShellsToInvalidateIfHidden[i]->InvalidatePresShellIfHidden();
115319:   }
115319:   mPresShellsToInvalidateIfHidden.Clear();
 33649: }
 33649: 
 67983: // Method for testing.  See nsIDOMWindowUtils.advanceTimeAndRefresh
 67983: // for description.
 67983: void
108991: nsRefreshDriver::AdvanceTimeAndRefresh(int64_t aMilliseconds)
 67983: {
118629:   // ensure that we're removed from our driver
118629:   StopTimer();
118629: 
118629:   if (!mTestControllingRefreshes) {
118629:     mMostRecentRefreshEpochTime = JS_Now();
118629:     mMostRecentRefresh = TimeStamp::Now();
118629: 
 67983:     mTestControllingRefreshes = true;
118629:   }
118629: 
 67983:   mMostRecentRefreshEpochTime += aMilliseconds * 1000;
118629:   mMostRecentRefresh += TimeDuration::FromMilliseconds((double) aMilliseconds);
118629: 
 69357:   nsCxPusher pusher;
 69357:   if (pusher.PushNull()) {
118629:     DoTick();
 69357:     pusher.Pop();
 69357:   }
 67983: }
 67983: 
 67983: void
 67983: nsRefreshDriver::RestoreNormalRefresh()
 67983: {
 67983:   mTestControllingRefreshes = false;
118629:   EnsureTimerStarted(false);
 67983: }
 67983: 
 33649: TimeStamp
 33649: nsRefreshDriver::MostRecentRefresh() const
 33649: {
 33649:   return mMostRecentRefresh;
 33649: }
 33649: 
108991: int64_t
 50368: nsRefreshDriver::MostRecentRefreshEpochTime() const
 50368: {
 50368:   return mMostRecentRefreshEpochTime;
 50368: }
 50368: 
 79445: bool
 33649: nsRefreshDriver::AddRefreshObserver(nsARefreshObserver* aObserver,
 33649:                                     mozFlushType aFlushType)
 33649: {
 33649:   ObserverArray& array = ArrayFor(aFlushType);
106838:   bool success = array.AppendElement(aObserver) != nullptr;
 33649: 
 68771:   EnsureTimerStarted(false);
 33649: 
 33649:   return success;
 33649: }
 33649: 
 79445: bool
 33649: nsRefreshDriver::RemoveRefreshObserver(nsARefreshObserver* aObserver,
 33649:                                        mozFlushType aFlushType)
 33649: {
 33649:   ObserverArray& array = ArrayFor(aFlushType);
 36795:   return array.RemoveElement(aObserver);
 33649: }
 33649: 
 82097: bool
 82097: nsRefreshDriver::AddImageRequest(imgIRequest* aRequest)
 82097: {
 82097:   if (!mRequests.PutEntry(aRequest)) {
 82097:     return false;
 82097:   }
 82097: 
 82097:   EnsureTimerStarted(false);
 82097: 
 82097:   return true;
 82097: }
 82097: 
 82097: void
 82097: nsRefreshDriver::RemoveImageRequest(imgIRequest* aRequest)
 82097: {
 82097:   mRequests.RemoveEntry(aRequest);
 82097: }
 82097: 
 82097: void nsRefreshDriver::ClearAllImageRequests()
 82097: {
 82097:   mRequests.Clear();
 82097: }
 82097: 
 33649: void
 68771: nsRefreshDriver::EnsureTimerStarted(bool aAdjustingTimer)
 33649: {
118629:   if (mTestControllingRefreshes)
118629:     return;
118629: 
118629:   // if the only change that's needed is that we need high precision,
118629:   // then just set that
118629:   if (!mThrottled && !mRequestedHighPrecision && mFrameRequestCallbackDocs.Length() > 0) {
118629:     SetHighPrecisionTimersEnabled(true);
118629:   } else if (mRequestedHighPrecision) {
118629:     SetHighPrecisionTimersEnabled(false);
118629:   }
118629: 
118629:   // will it already fire, and no other changes needed?
118629:   if (mActiveTimer && !aAdjustingTimer)
118629:     return;
118629: 
118629:   if (mFrozen || !mPresContext) {
118629:     // If we don't want to start it now, or we've been disconnected.
118629:     StopTimer();
 33649:     return;
 33649:   }
 33649: 
118629:   // we got here because we're either adjusting the time *or* we're
118629:   // starting it for the first time; make sure it's stopped.
118629:   StopTimer();
 33649: 
118629:   mActiveTimer = ChooseTimer();
118629:   mActiveTimer->AddRefreshDriver(this);
 33649: }
 33649: 
 33649: void
 33649: nsRefreshDriver::StopTimer()
 33649: {
118629:   if (!mActiveTimer)
 33649:     return;
118629: 
118629:   mActiveTimer->RemoveRefreshDriver(this);
118629:   mActiveTimer = nullptr;
118629: 
118629:   if (mRequestedHighPrecision) {
118629:     SetHighPrecisionTimersEnabled(false);
118629:   }
 33649: }
 33649: 
118629: void
118629: nsRefreshDriver::SetHighPrecisionTimersEnabled(bool aEnable)
118629: {
118629:   if (aEnable) {
118629:     NS_ASSERTION(!mRequestedHighPrecision, "SetHighPrecisionTimersEnabled(true) called when already requested!");
118629: #ifdef XP_WIN
118629:     if (++sHighPrecisionTimerRequests == 1)
118629:       timeBeginPeriod(1);
118629: #endif
118629:     mRequestedHighPrecision = true;
118629:   } else {
118629:     NS_ASSERTION(mRequestedHighPrecision, "SetHighPrecisionTimersEnabled(false) called when not requested!");
118629: #ifdef XP_WIN
118629:     if (--sHighPrecisionTimerRequests == 0)
118629:       timeEndPeriod(1);
118629: #endif
118629:     mRequestedHighPrecision = false;
118629:   }
 33649: }
 33649: 
108991: uint32_t
 33649: nsRefreshDriver::ObserverCount() const
 33649: {
108991:   uint32_t sum = 0;
108991:   for (uint32_t i = 0; i < ArrayLength(mObservers); ++i) {
 33649:     sum += mObservers[i].Length();
 33649:   }
 82097: 
 51546:   // Even while throttled, we need to process layout and style changes.  Style
 51546:   // changes can trigger transitions which fire events when they complete, and
 51546:   // layout changes can affect media queries on child documents, triggering
 51546:   // style changes, etc.
 50365:   sum += mStyleFlushObservers.Length();
 50365:   sum += mLayoutFlushObservers.Length();
 82857:   sum += mFrameRequestCallbackDocs.Length();
 87344:   sum += mViewManagerFlushIsPending;
 33649:   return sum;
 33649: }
 33649: 
108991: uint32_t
 82097: nsRefreshDriver::ImageRequestCount() const
 82097: {
 82097:   return mRequests.Count();
 82097: }
 82097: 
 33649: nsRefreshDriver::ObserverArray&
 33649: nsRefreshDriver::ArrayFor(mozFlushType aFlushType)
 33649: {
 33649:   switch (aFlushType) {
 33649:     case Flush_Style:
 33649:       return mObservers[0];
 33649:     case Flush_Layout:
 33649:       return mObservers[1];
 33649:     case Flush_Display:
 33649:       return mObservers[2];
 33649:     default:
 80486:       NS_ABORT_IF_FALSE(false, "bad flush type");
106838:       return *static_cast<ObserverArray*>(nullptr);
 33649:   }
 33649: }
 33649: 
 33649: /*
 33649:  * nsISupports implementation
 33649:  */
 33649: 
118629: NS_IMPL_ISUPPORTS1(nsRefreshDriver, nsISupports)
 33649: 
 33649: /*
 33649:  * nsITimerCallback implementation
 33649:  */
 33649: 
118629: void
118629: nsRefreshDriver::DoTick()
 33649: {
 37880:   NS_PRECONDITION(!mFrozen, "Why are we notified while frozen?");
 37880:   NS_PRECONDITION(mPresContext, "Why are we notified after disconnection?");
 69357:   NS_PRECONDITION(!nsContentUtils::GetCurrentJSContext(),
 69357:                   "Shouldn't have a JSContext on the stack");
 37880: 
118629:   if (mTestControllingRefreshes) {
118629:     Tick(mMostRecentRefreshEpochTime, mMostRecentRefresh);
118629:   } else {
118629:     Tick(JS_Now(), TimeStamp::Now());
118629:   }
 67983: }
 67983: 
118629: void
118629: nsRefreshDriver::Tick(int64_t aNowEpoch, TimeStamp aNowTime)
118629: {
118629:   NS_PRECONDITION(!nsContentUtils::GetCurrentJSContext(),
118629:                   "Shouldn't have a JSContext on the stack");
118629: 
118629:   SAMPLE_LABEL("nsRefreshDriver", "Tick");
118629: 
118629:   // We're either frozen or we were disconnected (likely in the middle
118629:   // of a tick iteration).  Just do nothing here, since our
118629:   // prescontext went away.
118629:   if (mFrozen || !mPresContext) {
118629:     return;
118629:   }
118629: 
118629:   mMostRecentRefresh = aNowTime;
118629:   mMostRecentRefreshEpochTime = aNowEpoch;
 33649: 
 36615:   nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
 82097:   if (!presShell || (ObserverCount() == 0 && ImageRequestCount() == 0)) {
 36795:     // Things are being destroyed, or we no longer have any observers.
 36795:     // We don't want to stop the timer when observers are initially
 36795:     // removed, because sometimes observers can be added and removed
 36795:     // often depending on what other things are going on and in that
 36795:     // situation we don't want to thrash our timer.  So instead we
 36795:     // wait until we get a Notify() call when we have no observers
 36795:     // before stopping the timer.
 33649:     StopTimer();
118629:     return;
 33649:   }
 33649: 
 36617:   /*
 36617:    * The timer holds a reference to |this| while calling |Notify|.
 36617:    * However, implementations of |WillRefresh| are permitted to destroy
 36617:    * the pres context, which will cause our |mPresContext| to become
 36617:    * null.  If this happens, we must stop notifying observers.
 36617:    */
108991:   for (uint32_t i = 0; i < ArrayLength(mObservers); ++i) {
 33649:     ObserverArray::EndLimitedIterator etor(mObservers[i]);
 33649:     while (etor.HasMore()) {
 36617:       nsRefPtr<nsARefreshObserver> obs = etor.GetNext();
118629:       obs->WillRefresh(aNowTime);
 36617:       
 36617:       if (!mPresContext || !mPresContext->GetPresShell()) {
 36617:         StopTimer();
118629:         return;
 36617:       }
 33649:     }
 82097: 
 33649:     if (i == 0) {
 82859:       // Grab all of our frame request callbacks up front.
 82857:       nsIDocument::FrameRequestCallbackList frameRequestCallbacks;
108991:       for (uint32_t i = 0; i < mFrameRequestCallbackDocs.Length(); ++i) {
 82857:         mFrameRequestCallbackDocs[i]->
 82857:           TakeFrameRequestCallbacks(frameRequestCallbacks);
 52255:       }
 82857:       // OK, now reset mFrameRequestCallbackDocs so they can be
 52255:       // readded as needed.
 82857:       mFrameRequestCallbackDocs.Clear();
 52255: 
118629:       int64_t eventTime = aNowEpoch / PR_USEC_PER_MSEC;
108991:       for (uint32_t i = 0; i < frameRequestCallbacks.Length(); ++i) {
 94465:         nsAutoMicroTask mt;
 82857:         frameRequestCallbacks[i]->Sample(eventTime);
 52255:       }
 52255: 
 33649:       // This is the Flush_Style case.
 60882:       if (mPresContext && mPresContext->GetPresShell()) {
 60882:         nsAutoTArray<nsIPresShell*, 16> observers;
 60882:         observers.AppendElements(mStyleFlushObservers);
108991:         for (uint32_t j = observers.Length();
 60882:              j && mPresContext && mPresContext->GetPresShell(); --j) {
 60882:           // Make sure to not process observers which might have been removed
 60882:           // during previous iterations.
 60882:           nsIPresShell* shell = observers[j - 1];
 60882:           if (!mStyleFlushObservers.Contains(shell))
 60882:             continue;
 60882:           NS_ADDREF(shell);
 60882:           mStyleFlushObservers.RemoveElement(shell);
 80486:           shell->FrameConstructor()->mObservingRefreshDriver = false;
 50365:           shell->FlushPendingNotifications(Flush_Style);
 60882:           NS_RELEASE(shell);
 60882:         }
 50365:       }
 38310:     } else if  (i == 1) {
 38310:       // This is the Flush_Layout case.
 60882:       if (mPresContext && mPresContext->GetPresShell()) {
 60882:         nsAutoTArray<nsIPresShell*, 16> observers;
 60882:         observers.AppendElements(mLayoutFlushObservers);
108991:         for (uint32_t j = observers.Length();
 60882:              j && mPresContext && mPresContext->GetPresShell(); --j) {
 60882:           // Make sure to not process observers which might have been removed
 60882:           // during previous iterations.
 60882:           nsIPresShell* shell = observers[j - 1];
 60882:           if (!mLayoutFlushObservers.Contains(shell))
 60882:             continue;
 60882:           NS_ADDREF(shell);
 60882:           mLayoutFlushObservers.RemoveElement(shell);
 80486:           shell->mReflowScheduled = false;
 80486:           shell->mSuppressInterruptibleReflows = false;
 50365:           shell->FlushPendingNotifications(Flush_InterruptibleLayout);
 60882:           NS_RELEASE(shell);
 60882:         }
 50365:       }
 33649:     }
 33649:   }
 33649: 
 82097:   /*
 82097:    * Perform notification to imgIRequests subscribed to listen
 82097:    * for refresh events.
 82097:    */
 82097: 
118629:   ImageRequestParameters parms = {aNowTime};
 82097:   if (mRequests.Count()) {
 82097:     mRequests.EnumerateEntries(nsRefreshDriver::ImageRequestEnumerator, &parms);
 82097:   }
 82097:     
115319:   for (uint32_t i = 0; i < mPresShellsToInvalidateIfHidden.Length(); i++) {
115319:     mPresShellsToInvalidateIfHidden[i]->InvalidatePresShellIfHidden();
115319:   }
115319:   mPresShellsToInvalidateIfHidden.Clear();
115319: 
 87344:   if (mViewManagerFlushIsPending) {
108188: #ifdef DEBUG_INVALIDATIONS
108188:     printf("Starting ProcessPendingUpdates\n");
108188: #endif
 87344:     mViewManagerFlushIsPending = false;
103519:     mPresContext->GetPresShell()->GetViewManager()->ProcessPendingUpdates();
108188: #ifdef DEBUG_INVALIDATIONS
108188:     printf("Ending ProcessPendingUpdates\n");
108188: #endif
 87344:   }
 33649: }
 37880: 
 82097: PLDHashOperator
 82097: nsRefreshDriver::ImageRequestEnumerator(nsISupportsHashKey* aEntry,
 82097:                                         void* aUserArg)
 82097: {
 82097:   ImageRequestParameters* parms =
 82097:     static_cast<ImageRequestParameters*> (aUserArg);
 82097:   mozilla::TimeStamp mostRecentRefresh = parms->ts;
 82097:   imgIRequest* req = static_cast<imgIRequest*>(aEntry->GetKey());
 82097:   NS_ABORT_IF_FALSE(req, "Unable to retrieve the image request");
 82097:   nsCOMPtr<imgIContainer> image;
 82097:   req->GetImage(getter_AddRefs(image));
 82097:   if (image) {
 82097:     image->RequestRefresh(mostRecentRefresh);
 82097:   }
 82097: 
 82097:   return PL_DHASH_NEXT;
 82097: }
 82097: 
 37880: void
 37880: nsRefreshDriver::Freeze()
 37880: {
 37880:   NS_ASSERTION(!mFrozen, "Freeze called on already-frozen refresh driver");
 37880:   StopTimer();
 51546:   mFrozen = true;
 37880: }
 37880: 
 37880: void
 37880: nsRefreshDriver::Thaw()
 37880: {
 37880:   NS_ASSERTION(mFrozen, "Thaw called on an unfrozen refresh driver");
 51546:   mFrozen = false;
 82097:   if (ObserverCount() || ImageRequestCount()) {
 68771:     // FIXME: This isn't quite right, since our EnsureTimerStarted call
 68771:     // updates our mMostRecentRefresh, but the DoRefresh call won't run
 68771:     // and notify our observers until we get back to the event loop.
 68771:     // Thus MostRecentRefresh() will lie between now and the DoRefresh.
 41361:     NS_DispatchToCurrentThread(NS_NewRunnableMethod(this, &nsRefreshDriver::DoRefresh));
 68771:     EnsureTimerStarted(false);
 37880:   }
 37880: }
 37880: 
 37880: void
 51546: nsRefreshDriver::SetThrottled(bool aThrottled)
 51546: {
 51546:   if (aThrottled != mThrottled) {
 51546:     mThrottled = aThrottled;
118629:     if (mActiveTimer) {
 63574:       // We want to switch our timer type here, so just stop and
 63574:       // restart the timer.
 68771:       EnsureTimerStarted(true);
 51546:     }
 51546:   }
 51546: }
 51546: 
 51546: void
 37880: nsRefreshDriver::DoRefresh()
 37880: {
 37880:   // Don't do a refresh unless we're in a state where we should be refreshing.
118629:   if (!mFrozen && mPresContext && mActiveTimer) {
118629:     DoTick();
 37880:   }
 37880: }
 38310: 
 38310: #ifdef DEBUG
 79445: bool
 38310: nsRefreshDriver::IsRefreshObserver(nsARefreshObserver* aObserver,
 38310:                                    mozFlushType aFlushType)
 38310: {
 38310:   ObserverArray& array = ArrayFor(aFlushType);
 38310:   return array.Contains(aObserver);
 38310: }
 38310: #endif
 50368: 
 50368: void
114466: nsRefreshDriver::ScheduleViewManagerFlush()
114466: {
114466:   NS_ASSERTION(mPresContext->IsRoot(),
114466:                "Should only schedule view manager flush on root prescontexts");
114466:   mViewManagerFlushIsPending = true;
114466:   EnsureTimerStarted(false);
114466: }
114466: 
114466: void
 82857: nsRefreshDriver::ScheduleFrameRequestCallbacks(nsIDocument* aDocument)
 52255: {
 82857:   NS_ASSERTION(mFrameRequestCallbackDocs.IndexOf(aDocument) ==
 82857:                mFrameRequestCallbackDocs.NoIndex,
 52255:                "Don't schedule the same document multiple times");
 82857:   mFrameRequestCallbackDocs.AppendElement(aDocument);
118629: 
118629:   // make sure that the timer is running
 68771:   EnsureTimerStarted(false);
 52255: }
 52255: 
 52255: void
 82857: nsRefreshDriver::RevokeFrameRequestCallbacks(nsIDocument* aDocument)
 52255: {
 82857:   mFrameRequestCallbackDocs.RemoveElement(aDocument);
 63688:   // No need to worry about restarting our timer in slack mode if it's already
 63688:   // running; that will happen automatically when it fires.
 52255: }
