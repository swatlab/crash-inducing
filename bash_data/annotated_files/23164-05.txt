    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
 5147:  *   HÃ¥kan Waara <hwaara@chello.se>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date         Modified by     Description of modification
    1:  * 05/03/2000   IBM Corp.       Observer events for reflow states
    1:  */ 
    1: 
    1: /* a presentation of a document, part 2 */
    1: 
    1: #define PL_ARENA_CONST_ALIGN_MASK 3
    1: 
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsStubDocumentObserver.h"
    1: #include "nsStyleSet.h"
    1: #include "nsICSSStyleSheet.h" // XXX for UA sheet loading hack, can this go away please?
    1: #include "nsIDOMCSSStyleSheet.h"  // for Pref-related rule management (bugs 22963,20760,31816)
    1: #include "nsINameSpaceManager.h"  // for Pref-related rule management (bugs 22963,20760,31816)
    1: #include "nsIServiceManager.h"
    1: #include "nsFrame.h"
    1: #include "nsIViewManager.h"
    1: #include "nsCRT.h"
    1: #include "nsCRTGlue.h"
    1: #include "prlog.h"
    1: #include "prmem.h"
    1: #include "prprf.h"
    1: #include "prinrval.h"
    1: #include "nsVoidArray.h"
    1: #include "nsCOMArray.h"
    1: #include "nsHashtable.h"
    1: #include "nsIViewObserver.h"
    1: #include "nsContainerFrame.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsEventStateManager.h"
    1: #include "nsDOMEvent.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsContentUtils.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionController.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsRange.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsWeakReference.h"
    1: #include "nsIPageSequenceFrame.h"
15969: #include "nsCaret.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIXPointer.h"
    1: #include "nsIDOMXMLDocument.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIParser.h"
    1: #include "nsParserCIID.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsIDOMNSHTMLInputElement.h" //optimization for ::DoXXX commands
    1: #include "nsIDOMNSHTMLTextAreaElement.h"
    1: #include "nsViewsCID.h"
    1: #include "nsFrameManager.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsILineIterator.h" // for ScrollContentIntoView
    1: #include "nsTimer.h"
    1: #include "nsWeakPtr.h"
    1: #include "plarena.h"
    1: #include "pldhash.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIObserver.h"
    1: #include "nsIDocShell.h"        // for reflow observation
    1: #include "nsIBaseWindow.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsCSSRendering.h"
    1: #ifdef NS_DEBUG
    1: #include "nsIFrameDebug.h"
    1: #endif
    1:   // for |#ifdef DEBUG| code
    1: #include "nsSpaceManager.h"
    1: #include "prenv.h"
    1: #include "nsIAttribute.h"
    1: #include "nsIGlobalHistory2.h"
    1: #include "nsDisplayList.h"
    1: #include "nsIRegion.h"
    1: #include "nsRegion.h"
    1: 
    1: #ifdef MOZ_REFLOW_PERF_DSP
    1: #include "nsIRenderingContext.h"
    1: #include "nsIFontMetrics.h"
    1: #endif
    1: 
    1: #include "nsIReflowCallback.h"
    1: 
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIFocusController.h"
    1: #include "nsIPluginInstance.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsNetUtil.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsStyleSheetService.h"
    1: #include "gfxImageSurface.h"
    1: #include "gfxContext.h"
15753: #ifdef MOZ_MEDIA
21006: #include "nsHTMLMediaElement.h"
15753: #endif
    1: 
    1: // Drag & Drop, Clipboard
    1: #include "nsWidgetsCID.h"
    1: #include "nsIClipboard.h"
    1: #include "nsIClipboardHelper.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIURI.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "prtime.h"
    1: #include "prlong.h"
    1: #include "nsIDragService.h"
    1: #include "nsCopySupport.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLinkElement.h"
    1: #include "nsITimer.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessible.h"
    1: #include "nsIAccessibleEvent.h"
    1: #endif
    1: 
    1: // For style data reconstruction
    1: #include "nsStyleChangeList.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #ifdef MOZ_XUL
 3129: #include "nsMenuFrame.h"
20988: #include "nsTreeBodyFrame.h"
    1: #endif
    1: #include "nsPlaceholderFrame.h"
    1: 
    1: // Content viewer interfaces
    1: #include "nsIContentViewer.h"
 1735: #include "imgIEncoder.h"
 1735: #include "gfxPlatform.h"
    1: 
    1: #include "nsContentCID.h"
    1: static NS_DEFINE_CID(kCSSStyleSheetCID, NS_CSS_STYLESHEET_CID);
    1: static NS_DEFINE_IID(kRangeCID,     NS_RANGE_CID);
    1: 
 1071: PRBool nsIPresShell::gIsAccessibilityActive = PR_FALSE;
 1071: 
    1: // convert a color value to a string, in the CSS format #RRGGBB
    1: // *  - initially created for bugs 31816, 20760, 22963
    1: static void ColorToString(nscolor aColor, nsAutoString &aString);
    1: 
    1: // Class ID's
    1: static NS_DEFINE_CID(kFrameSelectionCID, NS_FRAMESELECTION_CID);
    1: 
    1: // RangePaintInfo is used to paint ranges to offscreen buffers
    1: struct RangePaintInfo {
    1:   nsCOMPtr<nsIRange> mRange;
    1:   nsDisplayListBuilder mBuilder;
    1:   nsDisplayList mList;
    1: 
    1:   // offset of builder's reference frame to the root frame
    1:   nsPoint mRootOffset;
    1: 
    1:   RangePaintInfo(nsIRange* aRange, nsIFrame* aFrame)
    1:     : mRange(aRange), mBuilder(aFrame, PR_FALSE, PR_FALSE)
    1:   {
    1:   }
    1: 
    1:   ~RangePaintInfo()
    1:   {
    1:     mList.DeleteAll();
    1:   }
    1: };
    1: 
    1: #undef NOISY
    1: 
    1: // ----------------------------------------------------------------------
    1: 
    1: #ifdef NS_DEBUG
    1: // Set the environment variable GECKO_VERIFY_REFLOW_FLAGS to one or
    1: // more of the following flags (comma separated) for handy debug
    1: // output.
    1: static PRUint32 gVerifyReflowFlags;
    1: 
    1: struct VerifyReflowFlags {
    1:   const char*    name;
    1:   PRUint32 bit;
    1: };
    1: 
    1: static const VerifyReflowFlags gFlags[] = {
    1:   { "verify",                VERIFY_REFLOW_ON },
    1:   { "reflow",                VERIFY_REFLOW_NOISY },
    1:   { "all",                   VERIFY_REFLOW_ALL },
    1:   { "list-commands",         VERIFY_REFLOW_DUMP_COMMANDS },
    1:   { "noisy-commands",        VERIFY_REFLOW_NOISY_RC },
    1:   { "really-noisy-commands", VERIFY_REFLOW_REALLY_NOISY_RC },
    1:   { "space-manager",         VERIFY_REFLOW_INCLUDE_SPACE_MANAGER },
    1:   { "resize",                VERIFY_REFLOW_DURING_RESIZE_REFLOW },
    1: };
    1: 
    1: #define NUM_VERIFY_REFLOW_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
    1: 
    1: static void
    1: ShowVerifyReflowFlags()
    1: {
    1:   printf("Here are the available GECKO_VERIFY_REFLOW_FLAGS:\n");
    1:   const VerifyReflowFlags* flag = gFlags;
    1:   const VerifyReflowFlags* limit = gFlags + NUM_VERIFY_REFLOW_FLAGS;
    1:   while (flag < limit) {
    1:     printf("  %s\n", flag->name);
    1:     ++flag;
    1:   }
    1:   printf("Note: GECKO_VERIFY_REFLOW_FLAGS is a comma separated list of flag\n");
    1:   printf("names (no whitespace)\n");
    1: }
    1: #endif
    1: 
    1: //========================================================================
    1: //========================================================================
    1: //========================================================================
    1: #ifdef MOZ_REFLOW_PERF
    1: class ReflowCountMgr;
    1: 
    1: static const char kGrandTotalsStr[] = "Grand Totals";
    1: 
    1: // Counting Class
    1: class ReflowCounter {
    1: public:
    1:   ReflowCounter(ReflowCountMgr * aMgr = nsnull);
    1:   ~ReflowCounter();
    1: 
    1:   void ClearTotals();
    1:   void DisplayTotals(const char * aStr);
    1:   void DisplayDiffTotals(const char * aStr);
    1:   void DisplayHTMLTotals(const char * aStr);
    1: 
    1:   void Add()                { mTotal++;         }
    1:   void Add(PRUint32 aTotal) { mTotal += aTotal; }
    1: 
    1:   void CalcDiffInTotals();
    1:   void SetTotalsCache();
    1: 
    1:   void SetMgr(ReflowCountMgr * aMgr) { mMgr = aMgr; }
    1: 
    1:   PRUint32 GetTotal() { return mTotal; }
    1:   
    1: protected:
    1:   void DisplayTotals(PRUint32 aTotal, const char * aTitle);
    1:   void DisplayHTMLTotals(PRUint32 aTotal, const char * aTitle);
    1: 
    1:   PRUint32 mTotal;
    1:   PRUint32 mCacheTotal;
    1: 
    1:   ReflowCountMgr * mMgr; // weak reference (don't delete)
    1: };
    1: 
    1: // Counting Class
    1: class IndiReflowCounter {
    1: public:
    1:   IndiReflowCounter(ReflowCountMgr * aMgr = nsnull)
    1:     : mFrame(nsnull),
    1:       mCount(0),
    1:       mMgr(aMgr),
    1:       mCounter(aMgr),
    1:       mHasBeenOutput(PR_FALSE)
    1:     {}
    1:   virtual ~IndiReflowCounter() {}
    1: 
    1:   nsAutoString mName;
    1:   nsIFrame *   mFrame;   // weak reference (don't delete)
    1:   PRInt32      mCount;
    1: 
    1:   ReflowCountMgr * mMgr; // weak reference (don't delete)
    1: 
    1:   ReflowCounter mCounter;
    1:   PRBool        mHasBeenOutput;
    1: 
    1: };
    1: 
    1: //--------------------
    1: // Manager Class
    1: //--------------------
    1: class ReflowCountMgr {
    1: public:
    1:   ReflowCountMgr();
    1:   virtual ~ReflowCountMgr();
    1: 
    1:   void ClearTotals();
    1:   void ClearGrandTotals();
    1:   void DisplayTotals(const char * aStr);
    1:   void DisplayHTMLTotals(const char * aStr);
    1:   void DisplayDiffsInTotals(const char * aStr);
    1: 
    1:   void Add(const char * aName, nsIFrame * aFrame);
    1:   ReflowCounter * LookUp(const char * aName);
    1: 
    1:   void PaintCount(const char * aName, nsIRenderingContext* aRenderingContext, nsPresContext* aPresContext, nsIFrame * aFrame, PRUint32 aColor);
    1: 
    1:   FILE * GetOutFile() { return mFD; }
    1: 
    1:   PLHashTable * GetIndiFrameHT() { return mIndiFrameCounts; }
    1: 
    1:   void SetPresContext(nsPresContext * aPresContext) { mPresContext = aPresContext; } // weak reference
    1:   void SetPresShell(nsIPresShell* aPresShell) { mPresShell= aPresShell; } // weak reference
    1: 
    1:   void SetDumpFrameCounts(PRBool aVal)         { mDumpFrameCounts = aVal; }
    1:   void SetDumpFrameByFrameCounts(PRBool aVal)  { mDumpFrameByFrameCounts = aVal; }
    1:   void SetPaintFrameCounts(PRBool aVal)        { mPaintFrameByFrameCounts = aVal; }
    1: 
    1: protected:
    1:   void DisplayTotals(PRUint32 aTotal, PRUint32 * aDupArray, char * aTitle);
    1:   void DisplayHTMLTotals(PRUint32 aTotal, PRUint32 * aDupArray, char * aTitle);
    1: 
20261:   static PRIntn RemoveItems(PLHashEntry *he, PRIntn i, void *arg);
20261:   static PRIntn RemoveIndiItems(PLHashEntry *he, PRIntn i, void *arg);
    1:   void CleanUp();
    1: 
    1:   // stdout Output Methods
20261:   static PRIntn DoSingleTotal(PLHashEntry *he, PRIntn i, void *arg);
20261:   static PRIntn DoSingleIndi(PLHashEntry *he, PRIntn i, void *arg);
    1: 
    1:   void DoGrandTotals();
    1:   void DoIndiTotalsTree();
    1: 
    1:   // HTML Output Methods
20261:   static PRIntn DoSingleHTMLTotal(PLHashEntry *he, PRIntn i, void *arg);
    1:   void DoGrandHTMLTotals();
    1: 
    1:   // Zero Out the Totals
20261:   static PRIntn DoClearTotals(PLHashEntry *he, PRIntn i, void *arg);
    1: 
    1:   // Displays the Diff Totals
20261:   static PRIntn DoDisplayDiffTotals(PLHashEntry *he, PRIntn i, void *arg);
    1: 
    1:   PLHashTable * mCounts;
    1:   PLHashTable * mIndiFrameCounts;
    1:   FILE * mFD;
    1:   
    1:   PRBool mDumpFrameCounts;
    1:   PRBool mDumpFrameByFrameCounts;
    1:   PRBool mPaintFrameByFrameCounts;
    1: 
    1:   PRBool mCycledOnce;
    1: 
    1:   // Root Frame for Individual Tracking
    1:   nsPresContext * mPresContext;
    1:   nsIPresShell*    mPresShell;
    1: 
    1:   // ReflowCountMgr gReflowCountMgr;
    1: };
    1: #endif
    1: //========================================================================
    1: 
    1: // comment out to hide caret
    1: #define SHOW_CARET
    1: 
    1: // The upper bound on the amount of time to spend reflowing, in
    1: // microseconds.  When this bound is exceeded and reflow commands are
    1: // still queued up, a reflow event is posted.  The idea is for reflow
    1: // to not hog the processor beyond the time specifed in
    1: // gMaxRCProcessingTime.  This data member is initialized from the
    1: // layout.reflow.timeslice pref.
    1: #define NS_MAX_REFLOW_TIME    1000000
    1: static PRInt32 gMaxRCProcessingTime = -1;
    1: 
    1: // Largest chunk size we recycle
    1: static const size_t gMaxRecycledSize = 400;
    1: 
    1: #define MARK_INCREMENT 50
    1: #define BLOCK_INCREMENT 4044 /* a bit under 4096, for malloc overhead */
    1: 
    1: /**A block of memory that the stack will 
    1:  * chop up and hand out
    1:  */
    1: struct StackBlock {
    1:    
    1:    // a block of memory.  Note that this must be first so that it will
    1:    // be aligned.
    1:    char mBlock[BLOCK_INCREMENT];
    1: 
    1:    // another block of memory that would only be created
    1:    // if our stack overflowed. Yes we have the ability
    1:    // to grow on a stack overflow
    1:    StackBlock* mNext;
    1: 
    1:    StackBlock() : mNext(nsnull) { }
    1:    ~StackBlock() { }
    1: };
    1: 
    1: /* we hold an array of marks. A push pushes a mark on the stack
    1:  * a pop pops it off.
    1:  */
    1: struct StackMark {
    1:    // the block of memory we are currently handing out chunks of
    1:    StackBlock* mBlock;
    1:    
    1:    // our current position in the memory
    1:    size_t mPos;
    1: };
    1: 
    1: 
    1: /* A stack arena allows a stack based interface to a block of memory.
    1:  * It should be used when you need to allocate some temporary memory that
    1:  * you will immediately return.
    1:  */
    1: class StackArena {
    1: public:
    1:   StackArena();
    1:   ~StackArena();
    1: 
    1:   nsresult Init() { return mBlocks ? NS_OK : NS_ERROR_OUT_OF_MEMORY; }
    1: 
    1:   // Memory management functions
    1:   void* Allocate(size_t aSize);
    1:   void Push();
    1:   void Pop();
    1: 
    1: private:
    1:   // our current position in memory
    1:   size_t mPos;
    1: 
    1:   // a list of memory block. Usually there is only one
    1:   // but if we overrun our stack size we can get more memory.
    1:   StackBlock* mBlocks;
    1: 
    1:   // the current block of memory we are passing our chucks of
    1:   StackBlock* mCurBlock;
    1: 
    1:   // our stack of mark where push has been called
    1:   StackMark* mMarks;
    1: 
    1:   // the current top of the mark list
    1:   PRUint32 mStackTop;
    1: 
    1:   // the size of the mark array
    1:   PRUint32 mMarkLength;
    1: };
    1: 
    1: 
    1: 
    1: StackArena::StackArena()
    1: {
    1:   mMarkLength = 0;
    1:   mMarks = nsnull;
    1: 
    1:   // allocate our stack memory
    1:   mBlocks = new StackBlock();
    1:   mCurBlock = mBlocks;
    1: 
    1:   mStackTop = 0;
    1:   mPos = 0;
    1: }
    1: 
    1: StackArena::~StackArena()
    1: {
    1:   // free up our data
    1:   delete[] mMarks;
    1:   while(mBlocks)
    1:   {
    1:     StackBlock* toDelete = mBlocks;
    1:     mBlocks = mBlocks->mNext;
    1:     delete toDelete;
    1:   }
    1: } 
    1: 
    1: void
    1: StackArena::Push()
    1: {
    1:   // Resize the mark array if we overrun it.  Failure to allocate the
    1:   // mark array is not fatal; we just won't free to that mark.  This
    1:   // allows callers not to worry about error checking.
    1:   if (mStackTop >= mMarkLength)
    1:   {
    1:     PRUint32 newLength = mStackTop + MARK_INCREMENT;
    1:     StackMark* newMarks = new StackMark[newLength];
    1:     if (newMarks) {
    1:       if (mMarkLength)
    1:         memcpy(newMarks, mMarks, sizeof(StackMark)*mMarkLength);
    1:       // Fill in any marks that we couldn't allocate during a prior call
    1:       // to Push().
    1:       for (; mMarkLength < mStackTop; ++mMarkLength) {
    1:         NS_NOTREACHED("should only hit this on out-of-memory");
    1:         newMarks[mMarkLength].mBlock = mCurBlock;
    1:         newMarks[mMarkLength].mPos = mPos;
    1:       }
    1:       delete [] mMarks;
    1:       mMarks = newMarks;
    1:       mMarkLength = newLength;
    1:     }
    1:   }
    1: 
    1:   // set a mark at the top (if we can)
    1:   NS_ASSERTION(mStackTop < mMarkLength, "out of memory");
    1:   if (mStackTop < mMarkLength) {
    1:     mMarks[mStackTop].mBlock = mCurBlock;
    1:     mMarks[mStackTop].mPos = mPos;
    1:   }
    1: 
    1:   mStackTop++;
    1: }
    1: 
    1: void*
    1: StackArena::Allocate(size_t aSize)
    1: {
    1:   NS_ASSERTION(mStackTop > 0, "Allocate called without Push");
    1: 
    1:   // make sure we are aligned. Beard said 8 was safer then 4. 
    1:   // Round size to multiple of 8
    1:   aSize = PR_ROUNDUP(aSize, 8);
    1: 
    1:   // if the size makes the stack overflow. Grab another block for the stack
    1:   if (mPos + aSize >= BLOCK_INCREMENT)
    1:   {
    1:     NS_ASSERTION(aSize <= BLOCK_INCREMENT,"Requested memory is greater that our block size!!");
    1:     if (mCurBlock->mNext == nsnull)
    1:       mCurBlock->mNext = new StackBlock();
    1: 
    1:     mCurBlock =  mCurBlock->mNext;
    1:     mPos = 0;
    1:   }
    1: 
    1:   // return the chunk they need.
    1:   void *result = mCurBlock->mBlock + mPos;
    1:   mPos += aSize;
    1: 
    1:   return result;
    1: }
    1: 
    1: void
    1: StackArena::Pop()
    1: {
    1:   // pop off the mark
    1:   NS_ASSERTION(mStackTop > 0, "unmatched pop");
    1:   mStackTop--;
    1: 
    1:   if (mStackTop >= mMarkLength) {
    1:     // We couldn't allocate the marks array at the time of the push, so
    1:     // we don't know where we're freeing to.
    1:     NS_NOTREACHED("out of memory");
    1:     if (mStackTop == 0) {
    1:       // But we do know if we've completely pushed the stack.
    1:       mCurBlock = mBlocks;
    1:       mPos = 0;
    1:     }
    1:     return;
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   // Mark the "freed" memory with 0xdd to help with debugging of memory
    1:   // allocation problems.
    1:   {
    1:     StackBlock *block = mMarks[mStackTop].mBlock, *block_end = mCurBlock;
    1:     size_t pos = mMarks[mStackTop].mPos;
    1:     for (; block != block_end; block = block->mNext, pos = 0) {
    1:       memset(block->mBlock + pos, 0xdd, sizeof(block->mBlock) - pos);
    1:     }
    1:     memset(block->mBlock + pos, 0xdd, mPos - pos);
    1:   }
    1: #endif
    1: 
    1:   mCurBlock = mMarks[mStackTop].mBlock;
    1:   mPos      = mMarks[mStackTop].mPos;
    1: }
    1: 
    1: // Uncomment this to disable the frame arena.
    1: //#define DEBUG_TRACEMALLOC_FRAMEARENA 1
    1: 
    1: // Memory is allocated 4-byte aligned. We have recyclers for chunks up to
    1: // 200 bytes
    1: class FrameArena {
    1: public:
    1:   FrameArena(PRUint32 aArenaSize = 4096);
    1:   ~FrameArena();
    1: 
    1:   // Memory management functions
    1:   NS_HIDDEN_(void*) AllocateFrame(size_t aSize);
    1:   NS_HIDDEN_(void)  FreeFrame(size_t aSize, void* aPtr);
    1: 
    1: private:
    1: #ifdef DEBUG
    1:   // Number of frames in the pool
    1:   PRUint32 mFrameCount;
    1: #endif
    1: 
    1: #if !defined(DEBUG_TRACEMALLOC_FRAMEARENA)
    1:   // Underlying arena pool
    1:   PLArenaPool mPool;
    1: 
    1:   // The recycler array is sparse with the indices being multiples of 4,
    1:   // i.e., 0, 4, 8, 12, 16, 20, ...
    1:   void*       mRecyclers[gMaxRecycledSize >> 2];
    1: #endif
    1: };
    1: 
    1: FrameArena::FrameArena(PRUint32 aArenaSize)
    1: #ifdef DEBUG
    1:   : mFrameCount(0)
    1: #endif
    1: {
    1: #if !defined(DEBUG_TRACEMALLOC_FRAMEARENA)
    1:   // Initialize the arena pool
    1:   PL_INIT_ARENA_POOL(&mPool, "FrameArena", aArenaSize);
    1: 
    1:   // Zero out the recyclers array
    1:   memset(mRecyclers, 0, sizeof(mRecyclers));
    1: #endif
    1: }
    1: 
    1: FrameArena::~FrameArena()
    1: {
 3107:   NS_ASSERTION(mFrameCount == 0,
 3107:                "Some objects allocated with AllocateFrame were not freed");
    1:  
    1: #if !defined(DEBUG_TRACEMALLOC_FRAMEARENA)
    1:   // Free the arena in the pool and finish using it
    1:   PL_FinishArenaPool(&mPool);
    1: #endif
    1: } 
    1: 
    1: void*
    1: FrameArena::AllocateFrame(size_t aSize)
    1: {
    1:   void* result = nsnull;
    1: 
    1: #if defined(DEBUG_TRACEMALLOC_FRAMEARENA)
    1: 
    1:   result = PR_Malloc(aSize);
    1: 
    1: #else
    1: 
    1:   // Ensure we have correct alignment for pointers.  Important for Tru64
    1:   aSize = PR_ROUNDUP(aSize, sizeof(void*));
    1: 
    1:   // Check recyclers first
    1:   if (aSize < gMaxRecycledSize) {
    1:     const int   index = aSize >> 2;
    1: 
    1:     result = mRecyclers[index];
    1:     if (result) {
    1:       // Need to move to the next object
    1:       void* next = *((void**)result);
    1:       mRecyclers[index] = next;
    1:     }
    1:   }
    1: 
    1:   if (!result) {
    1:     // Allocate a new chunk from the arena
    1:     PL_ARENA_ALLOCATE(result, &mPool, aSize);
    1:   }
    1: 
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   if (result != nsnull)
    1:     ++mFrameCount;
    1: #endif
    1: 
    1:   return result;
    1: }
    1: 
    1: void
    1: FrameArena::FreeFrame(size_t aSize, void* aPtr)
    1: {
    1: #ifdef DEBUG
    1:   --mFrameCount;
    1: 
    1:   // Mark the memory with 0xdd in DEBUG builds so that there will be
    1:   // problems if someone tries to access memory that they've freed.
    1:   memset(aPtr, 0xdd, aSize);
    1: #endif
    1: #if defined(DEBUG_TRACEMALLOC_FRAMEARENA)
    1:   PR_Free(aPtr);
    1: #else
    1:   // Ensure we have correct alignment for pointers.  Important for Tru64
    1:   aSize = PR_ROUNDUP(aSize, sizeof(void*));
    1: 
    1:   // See if it's a size that we recycle
    1:   if (aSize < gMaxRecycledSize) {
    1:     const int   index = aSize >> 2;
    1:     void*       currentTop = mRecyclers[index];
    1:     mRecyclers[index] = aPtr;
    1:     *((void**)aPtr) = currentTop;
    1:   }
    1: #ifdef DEBUG_dbaron
    1:   else {
    1:     fprintf(stderr,
    1:             "WARNING: FrameArena::FreeFrame leaking chunk of %d bytes.\n",
    1:             aSize);
    1:   }
    1: #endif
    1: #endif
    1: }
    1: 
    1: struct nsCallbackEventRequest
    1: {
    1:   nsIReflowCallback* callback;
    1:   nsCallbackEventRequest* next;
    1: };
    1: 
    1: // ----------------------------------------------------------------------------
    1: class nsPresShellEventCB;
    1: 
    1: class PresShell : public nsIPresShell, public nsIViewObserver,
    1:                   public nsStubDocumentObserver,
    1:                   public nsISelectionController, public nsIObserver,
    1:                   public nsSupportsWeakReference
    1: {
    1: public:
    1:   PresShell();
    1: 
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIPresShell
    1:   NS_IMETHOD Init(nsIDocument* aDocument,
    1:                   nsPresContext* aPresContext,
    1:                   nsIViewManager* aViewManager,
    1:                   nsStyleSet* aStyleSet,
    1:                   nsCompatibility aCompatMode);
    1:   NS_IMETHOD Destroy();
    1: 
    1:   virtual NS_HIDDEN_(void*) AllocateFrame(size_t aSize);
    1:   virtual NS_HIDDEN_(void)  FreeFrame(size_t aSize, void* aFreeChunk);
    1: 
    1:   // Dynamic stack memory allocation
    1:   virtual NS_HIDDEN_(void) PushStackMemory();
    1:   virtual NS_HIDDEN_(void) PopStackMemory();
    1:   virtual NS_HIDDEN_(void*) AllocateStackMemory(size_t aSize);
    1: 
    1:   NS_IMETHOD SetPreferenceStyleRules(PRBool aForceReflow);
    1:   
    1:   NS_IMETHOD GetSelection(SelectionType aType, nsISelection** aSelection);
    1:   virtual nsISelection* GetCurrentSelection(SelectionType aType);
    1: 
    1:   NS_IMETHOD SetDisplaySelection(PRInt16 aToggle);
    1:   NS_IMETHOD GetDisplaySelection(PRInt16 *aToggle);
    1:   NS_IMETHOD ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion, PRBool aIsSynchronous);
    1:   NS_IMETHOD RepaintSelection(SelectionType aType);
    1: 
    1:   NS_IMETHOD BeginObservingDocument();
    1:   NS_IMETHOD EndObservingDocument();
    1:   NS_IMETHOD InitialReflow(nscoord aWidth, nscoord aHeight);
    1:   NS_IMETHOD ResizeReflow(nscoord aWidth, nscoord aHeight);
    1:   NS_IMETHOD StyleChangeReflow();
    1:   NS_IMETHOD GetPageSequenceFrame(nsIPageSequenceFrame** aResult) const;
    1:   virtual NS_HIDDEN_(nsIFrame*) GetPrimaryFrameFor(nsIContent* aContent) const;
10998:   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const;
    1: 
    1:   NS_IMETHOD GetPlaceholderFrameFor(nsIFrame*  aFrame,
    1:                                     nsIFrame** aPlaceholderFrame) const;
 1158:   NS_IMETHOD FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
 1161:                               nsFrameState aBitToAdd);
    1:   NS_IMETHOD CancelAllPendingReflows();
    1:   NS_IMETHOD IsSafeToFlush(PRBool& aIsSafeToFlush);
    1:   NS_IMETHOD FlushPendingNotifications(mozFlushType aType);
    1: 
    1:   /**
    1:    * Recreates the frames for a node
    1:    */
    1:   NS_IMETHOD RecreateFramesFor(nsIContent* aContent);
    1: 
    1:   /**
    1:    * Post a callback that should be handled after reflow has finished.
    1:    */
    1:   NS_IMETHOD PostReflowCallback(nsIReflowCallback* aCallback);
    1:   NS_IMETHOD CancelReflowCallback(nsIReflowCallback* aCallback);
    1: 
    1:   NS_IMETHOD ClearFrameRefs(nsIFrame* aFrame);
    1:   NS_IMETHOD CreateRenderingContext(nsIFrame *aFrame,
    1:                                     nsIRenderingContext** aContext);
    1:   NS_IMETHOD GoToAnchor(const nsAString& aAnchorName, PRBool aScroll);
12356:   NS_IMETHOD ScrollToAnchor();
    1: 
    1:   NS_IMETHOD ScrollContentIntoView(nsIContent* aContent,
    1:                                    PRIntn      aVPercent,
    1:                                    PRIntn      aHPercent) const;
    1: 
    1:   NS_IMETHOD SetIgnoreFrameDestruction(PRBool aIgnore);
    1:   NS_IMETHOD NotifyDestroyingFrame(nsIFrame* aFrame);
    1:   
    1:   NS_IMETHOD DoCopy();
    1:   NS_IMETHOD GetSelectionForCopy(nsISelection** outSelection);
    1: 
    1:   NS_IMETHOD GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocationString);
    1:   NS_IMETHOD DoGetContents(const nsACString& aMimeType, PRUint32 aFlags, PRBool aSelectionOnly, nsAString& outValue);
    1: 
    1:   NS_IMETHOD CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState, PRBool aLeavingPage);
    1: 
    1:   NS_IMETHOD IsPaintingSuppressed(PRBool* aResult);
    1:   NS_IMETHOD UnsuppressPainting();
    1:   
    1:   NS_IMETHOD DisableThemeSupport();
    1:   virtual PRBool IsThemeSupportEnabled();
    1: 
    1:   virtual nsresult GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets);
    1:   virtual nsresult SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets);
    1: 
    1:   virtual nsresult AddOverrideStyleSheet(nsIStyleSheet *aSheet);
    1:   virtual nsresult RemoveOverrideStyleSheet(nsIStyleSheet *aSheet);
    1: 
    1:   NS_IMETHOD HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
    1:                                    nsIContent* aContent,
    1:                                    nsEventStatus* aStatus);
    1:   NS_IMETHOD GetEventTargetFrame(nsIFrame** aFrame);
    1:   NS_IMETHOD GetEventTargetContent(nsEvent* aEvent, nsIContent** aContent);
    1: 
    1:   NS_IMETHOD IsReflowLocked(PRBool* aIsLocked);  
    1: 
    1:   virtual nsresult ReconstructFrames(void);
    1:   virtual void Freeze();
    1:   virtual void Thaw();
    1: 
 5680:   virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt);
 5680: 
22950:   NS_IMETHOD RenderDocument(const nsRect& aRect, PRUint32 aFlags,
    1:                             nscolor aBackgroundColor,
 1735:                             gfxContext* aThebesContext);
    1: 
    1:   virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
    1:                                                    nsIRegion* aRegion,
19835:                                                    nsPoint& aPoint,
19835:                                                    nsRect* aScreenRect);
    1: 
    1:   virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
19835:                                                         nsPoint& aPoint,
19835:                                                         nsRect* aScreenRect);
    1: 
    1:   //nsIViewObserver interface
    1: 
    1:   NS_IMETHOD Paint(nsIView *aView,
    1:                    nsIRenderingContext* aRenderingContext,
    1:                    const nsRegion& aDirtyRegion);
    1:   NS_IMETHOD ComputeRepaintRegionForCopy(nsIView*      aRootView,
    1:                                          nsIView*      aMovingView,
    1:                                          nsPoint       aDelta,
    1:                                          const nsRect& aCopyRect,
    1:                                          nsRegion*     aRepaintRegion);
    1:   NS_IMETHOD HandleEvent(nsIView*        aView,
    1:                          nsGUIEvent*     aEvent,
    1:                          nsEventStatus*  aEventStatus);
    1:   NS_IMETHOD HandleDOMEventWithTarget(nsIContent* aTargetContent,
    1:                                       nsEvent* aEvent,
    1:                                       nsEventStatus* aStatus);
    1:   NS_IMETHOD ResizeReflow(nsIView *aView, nscoord aWidth, nscoord aHeight);
    1:   NS_IMETHOD_(PRBool) IsVisible();
    1:   NS_IMETHOD_(void) WillPaint();
19214:   NS_IMETHOD_(void) InvalidateFrameForView(nsIView *view);
22471:   NS_IMETHOD_(void) DispatchSynthMouseMove(nsGUIEvent *aEvent,
22471:                                            PRBool aFlushOnHoverChange);
    1: 
    1:   // caret handling
15969:   NS_IMETHOD GetCaret(nsCaret **aOutCaret);
    1:   NS_IMETHOD_(void) MaybeInvalidateCaretPosition();
    1:   NS_IMETHOD SetCaretEnabled(PRBool aInEnable);
    1:   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
    1:   NS_IMETHOD GetCaretEnabled(PRBool *aOutEnabled);
    1:   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
14068:   NS_IMETHOD GetCaretVisible(PRBool *_retval);
15969:   virtual void SetCaret(nsCaret *aNewCaret);
 6232:   virtual void RestoreCaret();
    1: 
    1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
    1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
    1: 
    1:   // nsISelectionController
    1: 
    1:   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
20532:   NS_IMETHOD CharacterExtendForDelete();
    1:   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD WordExtendForDelete(PRBool aForward);
    1:   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD ScrollPage(PRBool aForward);
    1:   NS_IMETHOD ScrollLine(PRBool aForward);
    1:   NS_IMETHOD ScrollHorizontal(PRBool aLeft);
    1:   NS_IMETHOD CompleteScroll(PRBool aForward);
    1:   NS_IMETHOD CompleteMove(PRBool aForward, PRBool aExtend);
    1:   NS_IMETHOD SelectAll();
    1:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval);
    1: 
    1:   // nsIDocumentObserver
    1:   virtual void BeginUpdate(nsIDocument* aDocument, nsUpdateType aUpdateType);
    1:   virtual void EndUpdate(nsIDocument* aDocument, nsUpdateType aUpdateType);
    1:   virtual void BeginLoad(nsIDocument* aDocument);
    1:   virtual void EndLoad(nsIDocument* aDocument);
    1:   virtual void ContentStatesChanged(nsIDocument* aDocument,
    1:                                     nsIContent* aContent1,
    1:                                     nsIContent* aContent2,
    1:                                     PRInt32 aStateMask);
    1:   virtual void StyleSheetAdded(nsIDocument* aDocument,
    1:                                nsIStyleSheet* aStyleSheet,
    1:                                PRBool aDocumentSheet);
    1:   virtual void StyleSheetRemoved(nsIDocument* aDocument,
    1:                                  nsIStyleSheet* aStyleSheet,
    1:                                  PRBool aDocumentSheet);
    1:   virtual void StyleSheetApplicableStateChanged(nsIDocument* aDocument,
    1:                                                 nsIStyleSheet* aStyleSheet,
    1:                                                 PRBool aApplicable);
    1:   virtual void StyleRuleChanged(nsIDocument* aDocument,
    1:                                 nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aOldStyleRule,
    1:                                 nsIStyleRule* aNewStyleRule);
    1:   virtual void StyleRuleAdded(nsIDocument* aDocument,
    1:                               nsIStyleSheet* aStyleSheet,
    1:                               nsIStyleRule* aStyleRule);
    1:   virtual void StyleRuleRemoved(nsIDocument* aDocument,
    1:                                 nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aStyleRule);
    1: 
 3410:   // nsIMutationObserver
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
 3410: 
    1:   NS_DECL_NSIOBSERVER
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1:   NS_IMETHOD DumpReflows();
    1:   NS_IMETHOD CountReflows(const char * aName, nsIFrame * aFrame);
    1:   NS_IMETHOD PaintCount(const char * aName, nsIRenderingContext* aRenderingContext, nsPresContext* aPresContext, nsIFrame * aFrame, PRUint32 aColor);
    1: 
    1:   NS_IMETHOD SetPaintFrameCount(PRBool aOn);
    1:   
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   virtual void ListStyleContexts(nsIFrame *aRootFrame, FILE *out,
    1:                                  PRInt32 aIndent = 0);
    1: 
    1:   virtual void ListStyleSheets(FILE *out, PRInt32 aIndent = 0);
    1:   virtual void VerifyStyleTree();
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   static PRLogModuleInfo* gLog;
    1: #endif
    1: 
    1: protected:
    1:   virtual ~PresShell();
    1: 
    1:   void HandlePostedReflowCallbacks();
 8509:   void CancelPostedReflowCallbacks();
    1: 
    1:   void UnsuppressAndInvalidate();
    1: 
    1:   void     WillDoReflow();
    1:   void     DidDoReflow();
    1:   nsresult ProcessReflowCommands(PRBool aInterruptible);
    1:   void     ClearReflowEventStatus();
    1:   void     PostReflowEvent();
    1:   
  790:   void DoReflow(nsIFrame* aFrame);
  790: #ifdef DEBUG
  790:   void DoVerifyReflow();
  926:   void VerifyHasDirtyRootAncestor(nsIFrame* aFrame);
  790: #endif
  790: 
    1:   friend class nsPresShellEventCB;
    1: 
    1:   class ReflowEvent;
    1:   friend class ReflowEvent;
    1: 
    1:   class ReflowEvent : public nsRunnable {
    1:   public:
    1:     NS_DECL_NSIRUNNABLE
    1:     ReflowEvent(PresShell *aPresShell) : mPresShell(aPresShell) {
    1:       NS_ASSERTION(aPresShell, "Null parameters!");
    1:     }
    1:     void Revoke() { mPresShell = nsnull; }
    1:   private:  
    1:     PresShell *mPresShell;
    1:   };
    1: 
    1:   // Utility to find which view to scroll.
    1:   nsIScrollableView* GetViewToScroll(nsLayoutUtils::Direction aDirection);
    1: 
    1:   PRBool mCaretEnabled;
    1: #ifdef NS_DEBUG
    1:   nsresult CloneStyleSet(nsStyleSet* aSet, nsStyleSet** aResult);
    1:   PRBool VerifyIncrementalReflow();
    1:   PRBool mInVerifyReflow;
    1:   void ShowEventTargetDebug();
    1: #endif
    1: 
    1:     /**
    1:     * methods that manage rules that are used to implement the associated preferences
    1:     *  - initially created for bugs 31816, 20760, 22963
    1:     */
    1:   nsresult ClearPreferenceStyleRules(void);
    1:   nsresult CreatePreferenceStyleSheet(void);
    1:   nsresult SetPrefLinkRules(void);
    1:   nsresult SetPrefFocusRules(void);
    1:   nsresult SetPrefNoScriptRule();
    1:   nsresult SetPrefNoFramesRule(void);
    1: 
    1:   // methods for painting a range to an offscreen buffer
    1: 
    1:   // given a display list, clip the items within the list to
    1:   // the range
    1:   nsRect ClipListToRange(nsDisplayListBuilder *aBuilder,
    1:                          nsDisplayList* aList,
 4741:                          nsIRange* aRange);
    1: 
    1:   // create a RangePaintInfo for the range aRange containing the
    1:   // display list needed to paint the range to a surface
    1:   RangePaintInfo* CreateRangePaintInfo(nsIDOMRange* aRange,
    1:                                        nsRect& aSurfaceRect);
    1: 
    1:   /*
    1:    * Paint the items to a new surface and return it.
    1:    *
    1:    * aSelection - selection being painted, if any
    1:    * aRegion - clip region, if any
    1:    * aArea - area that the surface occupies, relative to the root frame
    1:    * aPoint - reference point, typically the mouse position
    1:    * aScreenRect - [out] set to the area of the screen the painted area should
    1:    *               be displayed at
    1:    */
    1:   already_AddRefed<gfxASurface>
    1:   PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
    1:                       nsISelection* aSelection,
    1:                       nsIRegion* aRegion,
    1:                       nsRect aArea,
19835:                       nsPoint& aPoint,
19835:                       nsRect* aScreenRect);
    1: 
    1:   /**
    1:    * Methods to handle changes to user and UA sheet lists that we get
    1:    * notified about.
    1:    */
    1:   void AddUserSheet(nsISupports* aSheet);
    1:   void AddAgentSheet(nsISupports* aSheet);
    1:   void RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet);
    1: 
  677:   // Hide a view if it is a popup
  677:   void HideViewIfPopup(nsIView* aView);
  677: 
  824:   // Utility method to restore the root scrollframe state
  824:   void RestoreRootScrollPosition();
  824: 
 4886:   // Method to handle actually flushing.  This allows the caller to control
 4886:   // whether the reflow flush (if any) should be interruptible.
 4886:   nsresult DoFlushPendingNotifications(mozFlushType aType,
 4886:                                        PRBool aInterruptibleReflow);
 4886: 
10382:   nsCOMPtr<nsICSSStyleSheet> mPrefStyleSheet; // mStyleSet owns it but we
10382:                                               // maintain a ref, may be null
    1: #ifdef DEBUG
    1:   PRUint32                  mUpdateCount;
    1: #endif
    1:   // reflow roots that need to be reflowed, as both a queue and a hashtable
    1:   nsVoidArray mDirtyRoots;
    1: 
    1:   PRPackedBool mDocumentLoading;
    1:   PRPackedBool mIsReflowing;
    1: 
    1:   PRPackedBool mIgnoreFrameDestruction;
    1:   PRPackedBool mHaveShutDown;
    1:   
    1:   nsIFrame*   mCurrentEventFrame;
    1:   nsCOMPtr<nsIContent> mCurrentEventContent;
    1:   nsVoidArray mCurrentEventFrameStack;
    1:   nsCOMArray<nsIContent> mCurrentEventContentStack;
    1: 
12356:   nsCOMPtr<nsIContent>          mLastAnchorScrolledTo;
12356:   nscoord                       mLastAnchorScrollPositionY;
15969:   nsRefPtr<nsCaret>             mCaret;
15969:   nsRefPtr<nsCaret>             mOriginalCaret;
    1:   PRInt16                       mSelectionFlags;
    1:   FrameArena                    mFrameArena;
    1:   StackArena                    mStackArena;
    1:   nsCOMPtr<nsIDragService>      mDragService;
    1:   
    1:   nsRevocableEventPtr<ReflowEvent> mReflowEvent;
    1: 
    1:   nsCallbackEventRequest* mFirstCallbackEventRequest;
    1:   nsCallbackEventRequest* mLastCallbackEventRequest;
    1: 
    1:   PRPackedBool      mIsThemeSupportDisabled;  // Whether or not form controls should use nsITheme in this shell.
    1: 
    1:   PRPackedBool      mIsDocumentGone;      // We've been disconnected from the document.
    1:   PRPackedBool      mPaintingSuppressed;  // For all documents we initially lock down painting.
    1:                                           // We will refuse to paint the document until either
    1:                                           // (a) our timer fires or (b) all frames are constructed.
    1:   PRPackedBool      mShouldUnsuppressPainting;  // Indicates that it is safe to unlock painting once all pending
    1:                                                 // reflows have been processed.
    1:   nsCOMPtr<nsITimer> mPaintSuppressionTimer; // This timer controls painting suppression.  Until it fires
    1:                                              // or all frames are constructed, we won't paint anything but
    1:                                              // our <body> background and scrollbars.
    1: #define PAINTLOCK_EVENT_DELAY 250 // 250ms.  This is actually
    1:                                   // pref-controlled, but we use this
    1:                                   // value if we fail to get the pref
    1:                                   // for any reason.
    1: 
    1:   static void sPaintSuppressionCallback(nsITimer* aTimer, void* aPresShell); // A callback for the timer.
    1: 
    1:   MOZ_TIMER_DECLARE(mReflowWatch)  // Used for measuring time spent in reflow
    1:   MOZ_TIMER_DECLARE(mFrameCreationWatch)  // Used for measuring time spent in frame creation 
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1:   ReflowCountMgr * mReflowCountMgr;
    1: #endif
    1: 
    1: private:
    1: 
    1:   PRBool InZombieDocument(nsIContent *aContent);
    1:   nsresult RetargetEventToParent(nsGUIEvent* aEvent,
    1:                                  nsEventStatus*  aEventStatus);
    1: 
    1:   //helper funcs for event handling
    1: protected:
    1:   //protected because nsPresShellEventCB needs this.
    1:   nsIFrame* GetCurrentEventFrame();
    1: private:
    1:   void PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent);
    1:   void PopCurrentEventInfo();
    1:   nsresult HandleEventInternal(nsEvent* aEvent, nsIView* aView,
    1:                                nsEventStatus *aStatus);
    1:   nsresult HandlePositionedEvent(nsIView*       aView,
    1:                                  nsIFrame*      aTargetFrame,
    1:                                  nsGUIEvent*    aEvent,
    1:                                  nsEventStatus* aEventStatus);
    1: 
    1:   //help funcs for resize events
    1:   void CreateResizeEventTimer();
    1:   void KillResizeEventTimer();
    1:   void FireResizeEvent();
    1:   static void sResizeEventCallback(nsITimer* aTimer, void* aPresShell) ;
    1:   nsCOMPtr<nsITimer> mResizeEventTimer;
    1: 
    1:   typedef void (*nsPluginEnumCallback)(PresShell*, nsIContent*);
    1:   void EnumeratePlugins(nsIDOMDocument *aDocument,
    1:                         const nsString &aPluginTag,
    1:                         nsPluginEnumCallback aCallback);
    1: };
    1: 
15594: class NS_STACK_CLASS nsPresShellEventCB : public nsDispatchingCallback
    1: {
    1: public:
    1:   nsPresShellEventCB(PresShell* aPresShell) : mPresShell(aPresShell) {}
    1: 
    1:   virtual void HandleEvent(nsEventChainPostVisitor& aVisitor)
    1:   {
    1:     if (aVisitor.mPresContext && aVisitor.mEvent->eventStructType != NS_EVENT) {
    1:       nsIFrame* frame = mPresShell->GetCurrentEventFrame();
    1:       if (frame) {
    1:         frame->HandleEvent(aVisitor.mPresContext,
    1:                            (nsGUIEvent*) aVisitor.mEvent,
    1:                            &aVisitor.mEventStatus);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsRefPtr<PresShell> mPresShell;
    1: };
    1: 
    1: #ifdef PR_LOGGING
    1: PRLogModuleInfo* PresShell::gLog;
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1: static void
    1: VerifyStyleTree(nsPresContext* aPresContext, nsFrameManager* aFrameManager)
    1: {
    1:   if (nsIFrameDebug::GetVerifyStyleTreeEnable()) {
    1:     nsIFrame* rootFrame = aFrameManager->GetRootFrame();
    1:     aFrameManager->DebugVerifyStyleTree(rootFrame);
    1:   }
    1: }
    1: #define VERIFY_STYLE_TREE ::VerifyStyleTree(mPresContext, FrameManager())
    1: #else
    1: #define VERIFY_STYLE_TREE
    1: #endif
    1: 
    1: static PRBool gVerifyReflowEnabled;
    1: 
    1: PRBool
    1: nsIPresShell::GetVerifyReflowEnable()
    1: {
    1: #ifdef NS_DEBUG
    1:   static PRBool firstTime = PR_TRUE;
    1:   if (firstTime) {
    1:     firstTime = PR_FALSE;
    1:     char* flags = PR_GetEnv("GECKO_VERIFY_REFLOW_FLAGS");
    1:     if (flags) {
    1:       PRBool error = PR_FALSE;
    1: 
    1:       for (;;) {
    1:         char* comma = PL_strchr(flags, ',');
    1:         if (comma)
    1:           *comma = '\0';
    1: 
    1:         PRBool found = PR_FALSE;
    1:         const VerifyReflowFlags* flag = gFlags;
    1:         const VerifyReflowFlags* limit = gFlags + NUM_VERIFY_REFLOW_FLAGS;
    1:         while (flag < limit) {
    1:           if (PL_strcasecmp(flag->name, flags) == 0) {
    1:             gVerifyReflowFlags |= flag->bit;
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:           ++flag;
    1:         }
    1: 
    1:         if (! found)
    1:           error = PR_TRUE;
    1: 
    1:         if (! comma)
    1:           break;
    1: 
    1:         *comma = ',';
    1:         flags = comma + 1;
    1:       }
    1: 
    1:       if (error)
    1:         ShowVerifyReflowFlags();
    1:     }
    1: 
    1:     if (VERIFY_REFLOW_ON & gVerifyReflowFlags) {
    1:       gVerifyReflowEnabled = PR_TRUE;
 3232: 
 3232:       printf("Note: verifyreflow is enabled");
    1:       if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:         printf(" (noisy)");
    1:       }
    1:       if (VERIFY_REFLOW_ALL & gVerifyReflowFlags) {
    1:         printf(" (all)");
    1:       }
    1:       if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
    1:         printf(" (show reflow commands)");
    1:       }
    1:       if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:         printf(" (noisy reflow commands)");
    1:         if (VERIFY_REFLOW_REALLY_NOISY_RC & gVerifyReflowFlags) {
    1:           printf(" (REALLY noisy reflow commands)");
    1:         }
    1:       }
    1:       printf("\n");
    1:     }
 3232:   }
    1: #endif
    1:   return gVerifyReflowEnabled;
    1: }
    1: 
    1: void
    1: nsIPresShell::SetVerifyReflowEnable(PRBool aEnabled)
    1: {
    1:   gVerifyReflowEnabled = aEnabled;
    1: }
    1: 
    1: PRInt32
    1: nsIPresShell::GetVerifyReflowFlags()
    1: {
    1: #ifdef NS_DEBUG
    1:   return gVerifyReflowFlags;
    1: #else
    1:   return 0;
    1: #endif
    1: }
    1: 
    1: void
    1: nsIPresShell::AddWeakFrame(nsWeakFrame* aWeakFrame)
    1: {
    1:   if (aWeakFrame->GetFrame()) {
    1:     aWeakFrame->GetFrame()->AddStateBits(NS_FRAME_EXTERNAL_REFERENCE);
    1:   }
    1:   aWeakFrame->SetPreviousWeakFrame(mWeakFrames);
    1:   mWeakFrames = aWeakFrame;
    1: }
    1: 
    1: void
    1: nsIPresShell::RemoveWeakFrame(nsWeakFrame* aWeakFrame)
    1: {
    1:   if (mWeakFrames == aWeakFrame) {
    1:     mWeakFrames = aWeakFrame->GetPreviousWeakFrame();
    1:     return;
    1:   }
    1:   nsWeakFrame* nextWeak = mWeakFrames;
    1:   while (nextWeak && nextWeak->GetPreviousWeakFrame() != aWeakFrame) {
    1:     nextWeak = nextWeak->GetPreviousWeakFrame();
    1:   }
    1:   if (nextWeak) {
    1:     nextWeak->SetPreviousWeakFrame(aWeakFrame->GetPreviousWeakFrame());
    1:   }
    1: }
    1: 
 8295: already_AddRefed<nsFrameSelection>
 8295: nsIPresShell::FrameSelection()
 8295: {
 8295:   NS_IF_ADDREF(mSelection);
 8295:   return mSelection;
 8295: }
 8295: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: NS_NewPresShell(nsIPresShell** aInstancePtrResult)
    1: {
    1:   NS_PRECONDITION(nsnull != aInstancePtrResult, "null ptr");
    1:   if (nsnull == aInstancePtrResult) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   PresShell* it = new PresShell();
    1:   if (nsnull == it) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   return it->QueryInterface(NS_GET_IID(nsIPresShell),
    1:                             (void **) aInstancePtrResult);
    1: }
    1: 
    1: PresShell::PresShell()
    1: {
    1:   mSelection = nsnull;
    1: #ifdef MOZ_REFLOW_PERF
    1:   mReflowCountMgr = new ReflowCountMgr();
    1:   mReflowCountMgr->SetPresContext(mPresContext);
    1:   mReflowCountMgr->SetPresShell(this);
    1: #endif
    1: #ifdef PR_LOGGING
    1:   if (! gLog)
    1:     gLog = PR_NewLogModule("PresShell");
    1: #endif
    1:   mSelectionFlags = nsISelectionDisplay::DISPLAY_TEXT | nsISelectionDisplay::DISPLAY_IMAGES;
    1:   mIsThemeSupportDisabled = PR_FALSE;
    1: 
    1:   new (this) nsFrameManager();
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS8(PresShell, nsIPresShell, nsIDocumentObserver,
    1:                    nsIViewObserver, nsISelectionController,
    1:                    nsISelectionDisplay, nsIObserver, nsISupportsWeakReference,
    1:                    nsIMutationObserver)
    1: 
    1: PresShell::~PresShell()
    1: {
    1:   if (!mHaveShutDown) {
    1:     NS_NOTREACHED("Someone did not call nsIPresShell::destroy");
    1:     Destroy();
    1:   }
    1: 
    1:   NS_ASSERTION(mCurrentEventContentStack.Count() == 0,
    1:                "Huh, event content left on the stack in pres shell dtor!");
    1:   NS_ASSERTION(mFirstCallbackEventRequest == nsnull &&
    1:                mLastCallbackEventRequest == nsnull,
    1:                "post-reflow queues not empty.  This means we're leaking");
    1:  
    1:   delete mStyleSet;
    1:   delete mFrameConstructor;
    1: 
    1:   mCurrentEventContent = nsnull;
    1: 
    1:   NS_IF_RELEASE(mPresContext);
    1:   NS_IF_RELEASE(mDocument);
13846:   NS_IF_RELEASE(mSelection);
    1: }
    1: 
    1: /**
    1:  * Initialize the presentation shell. Create view manager and style
    1:  * manager.
    1:  */
    1: NS_IMETHODIMP
    1: PresShell::Init(nsIDocument* aDocument,
    1:                 nsPresContext* aPresContext,
    1:                 nsIViewManager* aViewManager,
    1:                 nsStyleSet* aStyleSet,
    1:                 nsCompatibility aCompatMode)
    1: {
    1:   NS_PRECONDITION(nsnull != aDocument, "null ptr");
    1:   NS_PRECONDITION(nsnull != aPresContext, "null ptr");
    1:   NS_PRECONDITION(nsnull != aViewManager, "null ptr");
    1:   nsresult result;
    1: 
    1:   if ((nsnull == aDocument) || (nsnull == aPresContext) ||
    1:       (nsnull == aViewManager)) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   if (mDocument) {
    1:     NS_WARNING("PresShell double init'ed");
    1:     return NS_ERROR_ALREADY_INITIALIZED;
    1:   }
    1:   result = mStackArena.Init();
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   mDocument = aDocument;
    1:   NS_ADDREF(mDocument);
    1:   mViewManager = aViewManager;
    1: 
    1:   // Create our frame constructor.
    1:   mFrameConstructor = new nsCSSFrameConstructor(mDocument, this);
    1:   NS_ENSURE_TRUE(mFrameConstructor, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // The document viewer owns both view manager and pres shell.
    1:   mViewManager->SetViewObserver(this);
    1: 
    1:   // Bind the context to the presentation shell.
    1:   mPresContext = aPresContext;
    1:   NS_ADDREF(mPresContext);
    1:   aPresContext->SetShell(this);
    1: 
    1:   // Now we can initialize the style set.
    1:   result = aStyleSet->Init(aPresContext);
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   // From this point on, any time we return an error we need to make
    1:   // sure to null out mStyleSet first, since an error return from this
    1:   // method will cause the caller to delete the style set, so we don't
    1:   // want to delete it in our destructor.
    1:   mStyleSet = aStyleSet;
    1: 
    1:   // Notify our prescontext that it now has a compatibility mode.  Note that
    1:   // this MUST happen after we set up our style set but before we create any
    1:   // frames.
    1:   mPresContext->CompatibilityModeChanged();
    1: 
    1:   // setup the preference style rules (no forced reflow), and do it
    1:   // before creating any frames.
    1:   SetPreferenceStyleRules(PR_FALSE);
    1: 
    1:   result = CallCreateInstance(kFrameSelectionCID, &mSelection);
    1:   if (NS_FAILED(result)) {
    1:     mStyleSet = nsnull;
    1:     return result;
    1:   }
    1: 
    1:   // Create and initialize the frame manager
    1:   result = FrameManager()->Init(this, mStyleSet);
    1:   if (NS_FAILED(result)) {
    1:     NS_WARNING("Frame manager initialization failed");
    1:     mStyleSet = nsnull;
    1:     return result;
    1:   }
    1: 
    1:   mSelection->Init(this, nsnull);
    1: 
    1:   // Important: this has to happen after the selection has been set up
    1: #ifdef SHOW_CARET
    1:   // make the caret
    1:   nsresult  err = NS_NewCaret(getter_AddRefs(mCaret));
    1:   if (NS_SUCCEEDED(err))
    1:   {
    1:     mCaret->Init(this);
 6232:     mOriginalCaret = mCaret;
    1:   }
    1: 
    1:   //SetCaretEnabled(PR_TRUE);       // make it show in browser windows
    1: #endif  
    1:   //set up selection to be displayed in document
    1:   // Don't enable selection for print media
    1:   nsPresContext::nsPresContextType type = aPresContext->Type();
    1:   if (type != nsPresContext::eContext_PrintPreview &&
    1:       type != nsPresContext::eContext_Print)
    1:     SetDisplaySelection(nsISelectionController::SELECTION_DISABLED);
    1:   
    1:   if (gMaxRCProcessingTime == -1) {
    1:     gMaxRCProcessingTime =
    1:       nsContentUtils::GetIntPref("layout.reflow.timeslice",
    1:                                  NS_MAX_REFLOW_TIME);
    1:   }
    1: 
    1:   {
    1:     nsCOMPtr<nsIObserverService> os =
    1:       do_GetService("@mozilla.org/observer-service;1", &result);
    1:     if (os) {
    1:       os->AddObserver(this, NS_LINK_VISITED_EVENT_TOPIC, PR_FALSE);
    1:       os->AddObserver(this, "agent-sheet-added", PR_FALSE);
    1:       os->AddObserver(this, "user-sheet-added", PR_FALSE);
    1:       os->AddObserver(this, "agent-sheet-removed", PR_FALSE);
    1:       os->AddObserver(this, "user-sheet-removed", PR_FALSE);
    1: #ifdef MOZ_XUL
    1:       os->AddObserver(this, "chrome-flush-skin-caches", PR_FALSE);
    1: #endif
 1071: #ifdef ACCESSIBILITY
 1071:       os->AddObserver(this, "a11y-init-or-shutdown", PR_FALSE);
 1071: #endif
    1:     }
    1:   }
    1: 
    1:   // cache the drag service so we can check it during reflows
    1:   mDragService = do_GetService("@mozilla.org/widget/dragservice;1");
    1: 
    1: #ifdef MOZ_REFLOW_PERF
    1:     if (mReflowCountMgr) {
    1:       PRBool paintFrameCounts =
    1:         nsContentUtils::GetBoolPref("layout.reflow.showframecounts");
    1: 
    1:       PRBool dumpFrameCounts =
    1:         nsContentUtils::GetBoolPref("layout.reflow.dumpframecounts");
    1: 
    1:       PRBool dumpFrameByFrameCounts =
    1:         nsContentUtils::GetBoolPref("layout.reflow.dumpframebyframecounts");
    1: 
    1:       mReflowCountMgr->SetDumpFrameCounts(dumpFrameCounts);
    1:       mReflowCountMgr->SetDumpFrameByFrameCounts(dumpFrameByFrameCounts);
    1:       mReflowCountMgr->SetPaintFrameCounts(paintFrameCounts);
    1:     }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::Destroy()
    1: {
    1: #ifdef MOZ_REFLOW_PERF
    1:   DumpReflows();
    1:   if (mReflowCountMgr) {
    1:     delete mReflowCountMgr;
    1:     mReflowCountMgr = nsnull;
    1:   }
    1: #endif
    1: 
    1:   if (mHaveShutDown)
    1:     return NS_OK;
    1: 
    1:   if (mPresContext) {
    1:     // We need to notify the destroying the nsPresContext to ESM for
    1:     // suppressing to use from ESM.
    1:     mPresContext->EventStateManager()->NotifyDestroyPresContext(mPresContext);
    1:   }
    1: 
    1:   {
    1:     nsCOMPtr<nsIObserverService> os =
    1:       do_GetService("@mozilla.org/observer-service;1");
    1:     if (os) {
    1:       os->RemoveObserver(this, NS_LINK_VISITED_EVENT_TOPIC);
    1:       os->RemoveObserver(this, "agent-sheet-added");
    1:       os->RemoveObserver(this, "user-sheet-added");
    1:       os->RemoveObserver(this, "agent-sheet-removed");
    1:       os->RemoveObserver(this, "user-sheet-removed");
    1: #ifdef MOZ_XUL
    1:       os->RemoveObserver(this, "chrome-flush-skin-caches");
    1: #endif
 1090: #ifdef ACCESSIBILITY
 1090:       os->RemoveObserver(this, "a11y-init-or-shutdown");
 1090: #endif
    1:     }
    1:   }
    1: 
    1:   // If our paint suppression timer is still active, kill it.
    1:   if (mPaintSuppressionTimer) {
    1:     mPaintSuppressionTimer->Cancel();
    1:     mPaintSuppressionTimer = nsnull;
    1:   }
    1: 
    1:   if (mCaret) {
    1:     mCaret->Terminate();
    1:     mCaret = nsnull;
    1:   }
    1:   
13846:   if (mSelection) {
13846:     mSelection->DisconnectFromPresShell();
13846:   }
13846: 
    1:   // release our pref style sheet, if we have one still
    1:   ClearPreferenceStyleRules();
    1: 
    1:   mIsDestroying = PR_TRUE;
    1: 
    1:   // We can't release all the event content in
    1:   // mCurrentEventContentStack here since there might be code on the
    1:   // stack that will release the event content too. Double release
    1:   // bad!
    1: 
    1:   // The frames will be torn down, so remove them from the current
    1:   // event frame stack (since they'd be dangling references if we'd
    1:   // leave them in) and null out the mCurrentEventFrame pointer as
    1:   // well.
    1: 
    1:   mCurrentEventFrame = nsnull;
    1: 
    1:   PRInt32 i, count = mCurrentEventFrameStack.Count();
    1:   for (i = 0; i < count; i++) {
    1:     mCurrentEventFrameStack.ReplaceElementAt(nsnull, i);
    1:   }
    1: 
    1:   if (mViewManager) {
    1:     // Clear the view manager's weak pointer back to |this| in case it
    1:     // was leaked.
    1:     mViewManager->SetViewObserver(nsnull);
    1:     mViewManager = nsnull;
    1:   }
    1: 
    1:   mStyleSet->BeginShutdown(mPresContext);
    1: 
    1:   // This shell must be removed from the document before the frame
    1:   // hierarchy is torn down to avoid finding deleted frames through
    1:   // this presshell while the frames are being torn down
    1:   if (mDocument) {
    1:     mDocument->DeleteShell(this);
    1:   }
    1: 
    1:   // Revoke any pending reflow event.  We need to do this and cancel
    1:   // pending reflows before we destroy the frame manager, since
    1:   // apparently frame destruction sometimes spins the event queue when
    1:   // plug-ins are involved(!).
    1:   mReflowEvent.Revoke();
    1: 
    1:   CancelAllPendingReflows();
 8509:   CancelPostedReflowCallbacks();
    1: 
    1:   // Destroy the frame manager. This will destroy the frame hierarchy
22769:   mFrameConstructor->WillDestroyFrameTree(PR_TRUE);
    1:   FrameManager()->Destroy();
    1: 
    1:   NS_WARN_IF_FALSE(!mWeakFrames, "Weak frames alive after destroying FrameManager");
    1:   while (mWeakFrames) {
    1:     mWeakFrames->Clear(this);
    1:   }
    1: 
    1:   // Let the style set do its cleanup.
    1:   mStyleSet->Shutdown(mPresContext);
    1: 
    1:   if (mPresContext) {
    1:     // Clear out the prescontext's property table -- since our frame tree is
    1:     // now dead, we shouldn't be looking up any more properties in that table.
    1:     // We want to do this before we call SetShell() on the prescontext, so
    1:     // property destructors can usefully call GetPresShell() on the
    1:     // prescontext.
    1:     mPresContext->PropertyTable()->DeleteAllProperties();
    1: 
    1:     // We hold a reference to the pres context, and it holds a weak link back
    1:     // to us. To avoid the pres context having a dangling reference, set its 
    1:     // pres shell to NULL
    1:     mPresContext->SetShell(nsnull);
    1: 
    1:     // Clear the link handler (weak reference) as well
    1:     mPresContext->SetLinkHandler(nsnull);
    1:   }
    1: 
    1:   KillResizeEventTimer();
    1: 
    1:   mHaveShutDown = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1:                   // Dynamic stack memory allocation
    1: /* virtual */ void
    1: PresShell::PushStackMemory()
    1: {
    1:   mStackArena.Push();
    1: }
    1: 
    1: /* virtual */ void
    1: PresShell::PopStackMemory()
    1: {
    1:   mStackArena.Pop();
    1: }
    1: 
    1: /* virtual */ void*
    1: PresShell::AllocateStackMemory(size_t aSize)
    1: {
    1:   return mStackArena.Allocate(aSize);
    1: }
    1: 
    1: void
    1: PresShell::FreeFrame(size_t aSize, void* aPtr)
    1: {
    1:   mFrameArena.FreeFrame(aSize, aPtr);
    1: }
    1: 
    1: void*
    1: PresShell::AllocateFrame(size_t aSize)
    1: {
    1:   return mFrameArena.AllocateFrame(aSize);
    1: }
    1: 
    1: void
    1: nsIPresShell::SetAuthorStyleDisabled(PRBool aStyleDisabled)
    1: {
    1:   if (aStyleDisabled != mStyleSet->GetAuthorStyleDisabled()) {
    1:     mStyleSet->SetAuthorStyleDisabled(aStyleDisabled);
    1:     ReconstructStyleData();
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsIPresShell::GetAuthorStyleDisabled()
    1: {
    1:   return mStyleSet->GetAuthorStyleDisabled();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::SetPreferenceStyleRules(PRBool aForceReflow)
    1: {
    1:   if (!mDocument) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   nsPIDOMWindow *window = mDocument->GetWindow();
    1: 
    1:   // If the document doesn't have a window there's no need to notify
    1:   // its presshell about changes to preferences since the document is
    1:   // in a state where it doesn't matter any more (see
    1:   // DocumentViewerImpl::Close()).
    1: 
    1:   if (!window) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   } 
    1: 
    1:   NS_PRECONDITION(mPresContext, "presContext cannot be null");
    1:   if (mPresContext) {
    1:     // first, make sure this is not a chrome shell 
19869:     if (nsContentUtils::IsInChromeDocshell(mDocument)) {
    1:       return NS_OK;
    1:     }
    1: 
    1: #ifdef DEBUG_attinasi
    1:     printf("Setting Preference Style Rules:\n");
    1: #endif
    1:     // if here, we need to create rules for the prefs
    1:     // - this includes the background-color, the text-color,
    1:     //   the link color, the visited link color and the link-underlining
    1:     
    1:     // first clear any exising rules
19869:     nsresult result = ClearPreferenceStyleRules();
    1:       
    1:     // now the link rules (must come after the color rules, or links will not be correct color!)
    1:     // XXX - when there is both an override and agent pref stylesheet this won't matter,
    1:     //       as the color rules will be overrides and the links rules will be agent
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefLinkRules();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefFocusRules();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefNoScriptRule();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = SetPrefNoFramesRule();
    1:     }
    1: #ifdef DEBUG_attinasi
    1:     printf( "Preference Style Rules set: error=%ld\n", (long)result);
    1: #endif
    1: 
 3959:     // Note that this method never needs to force any calculation; the caller
 3959:     // will recalculate style if needed
    1: 
    1:     return result;
    1:   }
    1: 
    1:   return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: nsresult PresShell::ClearPreferenceStyleRules(void)
    1: {
    1:   nsresult result = NS_OK;
    1:   if (mPrefStyleSheet) {
    1:     NS_ASSERTION(mStyleSet, "null styleset entirely unexpected!");
    1:     if (mStyleSet) {
    1:       // remove the sheet from the styleset: 
    1:       // - note that we have to check for success by comparing the count before and after...
    1: #ifdef NS_DEBUG
    1:       PRInt32 numBefore = mStyleSet->SheetCount(nsStyleSet::eUserSheet);
    1:       NS_ASSERTION(numBefore > 0, "no user stylesheets in styleset, but we have one!");
    1: #endif
    1:       mStyleSet->RemoveStyleSheet(nsStyleSet::eUserSheet, mPrefStyleSheet);
    1: 
    1: #ifdef DEBUG_attinasi
    1:       NS_ASSERTION((numBefore - 1) == mStyleSet->GetNumberOfUserStyleSheets(),
    1:                    "Pref stylesheet was not removed");
    1:       printf("PrefStyleSheet removed\n");
    1: #endif
    1:       // clear the sheet pointer: it is strictly historical now
10382:       mPrefStyleSheet = nsnull;
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult PresShell::CreatePreferenceStyleSheet(void)
    1: {
    1:   NS_ASSERTION(!mPrefStyleSheet, "prefStyleSheet already exists");
10382:   nsresult result;
10382:   mPrefStyleSheet = do_CreateInstance(kCSSStyleSheetCID, &result);
    1:   if (NS_SUCCEEDED(result)) {
    1:     NS_ASSERTION(mPrefStyleSheet, "null but no error");
    1:     nsCOMPtr<nsIURI> uri;
    1:     result = NS_NewURI(getter_AddRefs(uri), "about:PreferenceStyleSheet", nsnull);
    1:     if (NS_SUCCEEDED(result)) {
    1:       NS_ASSERTION(uri, "null but no error");
11683:       result = mPrefStyleSheet->SetURIs(uri, uri, uri);
    1:       if (NS_SUCCEEDED(result)) {
    1:         mPrefStyleSheet->SetComplete();
    1:         PRUint32 index;
10382:         result =
10382:           mPrefStyleSheet->InsertRuleInternal(NS_LITERAL_STRING("@namespace url(http://www.w3.org/1999/xhtml);"),
    1:                                               0, &index);
10382:         if (NS_SUCCEEDED(result)) {
    1:           mStyleSet->AppendStyleSheet(nsStyleSet::eUserSheet, mPrefStyleSheet);
    1:         }
    1:       }
10382:     }
    1:   }
    1: 
    1: #ifdef DEBUG_attinasi
    1:   printf("CreatePrefStyleSheet completed: error=%ld\n",(long)result);
    1: #endif
    1: 
10382:   if (NS_FAILED(result)) {
10382:     mPrefStyleSheet = nsnull;
10382:   }
10382: 
    1:   return result;
    1: }
    1: 
    1: // XXX We want these after the @namespace rule.  Does order matter
    1: // for these rules, or can we call nsICSSStyleRule::StyleRuleCount()
    1: // and just "append"?
    1: static PRUint32 sInsertPrefSheetRulesAt = 1;
    1: 
    1: nsresult
    1: PresShell::SetPrefNoScriptRule()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // also handle the case where print is done from print preview
    1:   // see bug #342439 for more details
    1:   PRBool scriptEnabled = mDocument->IsScriptEnabled() ||
    1:     ((mPresContext->Type() == nsPresContext::eContext_PrintPreview || 
    1:       mPresContext->Type() == nsPresContext::eContext_Print) &&
    1:      NS_PTR_TO_INT32(mDocument->GetProperty(
14347:                        nsGkAtoms::scriptEnabledBeforePrintPreview)));
    1: 
    1:   if (scriptEnabled) {
    1:     if (!mPrefStyleSheet) {
    1:       rv = CreatePreferenceStyleSheet();
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
10382: 
    1:     PRUint32 index = 0;
10382:     mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("noscript{display:none!important}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult PresShell::SetPrefNoFramesRule(void)
    1: {
    1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
    1:   if (!mPresContext) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (!mPrefStyleSheet) {
    1:     rv = CreatePreferenceStyleSheet();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
    1:   
    1:   PRBool allowSubframes = PR_TRUE;
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();     
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
    1:   if (docShell) {
    1:     docShell->GetAllowSubframes(&allowSubframes);
    1:   }
    1:   if (!allowSubframes) {
    1:     PRUint32 index = 0;
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("noframes{display:block}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:     NS_ENSURE_SUCCESS(rv, rv);
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("frame, frameset, iframe {display:none!important}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   }
    1:   return rv;
    1: }
    1:   
    1: nsresult PresShell::SetPrefLinkRules(void)
    1: {
    1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
    1:   if (!mPresContext) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (!mPrefStyleSheet) {
    1:     rv = CreatePreferenceStyleSheet();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
    1:   
    1:   // support default link colors: 
    1:   //   this means the link colors need to be overridable, 
    1:   //   which they are if we put them in the agent stylesheet,
    1:   //   though if using an override sheet this will cause authors grief still
    1:   //   In the agent stylesheet, they are !important when we are ignoring document colors
    1:   
    1:   nscolor linkColor(mPresContext->DefaultLinkColor());
    1:   nscolor activeColor(mPresContext->DefaultActiveLinkColor());
    1:   nscolor visitedColor(mPresContext->DefaultVisitedLinkColor());
    1:   
 1540:   NS_NAMED_LITERAL_STRING(ruleClose, "}");
    1:   PRUint32 index = 0;
    1:   nsAutoString strColor;
    1: 
    1:   // insert a rule to color links: '*|*:link {color: #RRGGBB [!important];}'
    1:   ColorToString(linkColor, strColor);
10382:   rv = mPrefStyleSheet->
10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:link{color:") +
    1:                        strColor + ruleClose,
    1:                        sInsertPrefSheetRulesAt, &index);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // - visited links: '*|*:visited {color: #RRGGBB [!important];}'
    1:   ColorToString(visitedColor, strColor);
10382:   rv = mPrefStyleSheet->
10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:visited{color:") +
    1:                        strColor + ruleClose,
    1:                        sInsertPrefSheetRulesAt, &index);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // - active links: '*|*:-moz-any-link:active {color: #RRGGBB [!important];}'
    1:   ColorToString(activeColor, strColor);
10382:   rv = mPrefStyleSheet->
10382:     InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link:active{color:") +
    1:                        strColor + ruleClose,
    1:                        sInsertPrefSheetRulesAt, &index);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool underlineLinks =
    1:     mPresContext->GetCachedBoolPref(kPresContext_UnderlineLinks);
    1: 
    1:   if (underlineLinks) {
    1:     // create a rule to make underlining happen
    1:     //  '*|*:-moz-any-link {text-decoration:[underline|none];}'
    1:     // no need for important, we want these to be overridable
    1:     // NOTE: these must go in the agent stylesheet or they cannot be
    1:     //       overridden by authors
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link{text-decoration:underline}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   } else {
10382:     rv = mPrefStyleSheet->
10382:       InsertRuleInternal(NS_LITERAL_STRING("*|*:-moz-any-link{text-decoration:none}"),
    1:                          sInsertPrefSheetRulesAt, &index);
    1:   }
    1: 
    1:   return rv;          
    1: }
    1: 
    1: nsresult PresShell::SetPrefFocusRules(void)
    1: {
    1:   NS_ASSERTION(mPresContext,"null prescontext not allowed");
    1:   nsresult result = NS_OK;
    1: 
    1:   if (!mPresContext)
    1:     result = NS_ERROR_FAILURE;
    1: 
    1:   if (NS_SUCCEEDED(result) && !mPrefStyleSheet)
    1:     result = CreatePreferenceStyleSheet();
    1: 
    1:   if (NS_SUCCEEDED(result)) {
    1:     NS_ASSERTION(mPrefStyleSheet, "prefstylesheet should not be null");
    1: 
    1:     if (mPresContext->GetUseFocusColors()) {
    1:       nscolor focusBackground(mPresContext->FocusBackgroundColor());
    1:       nscolor focusText(mPresContext->FocusTextColor());
    1: 
    1:       // insert a rule to make focus the preferred color
    1:       PRUint32 index = 0;
    1:       nsAutoString strRule, strColor;
    1: 
    1:       ///////////////////////////////////////////////////////////////
    1:       // - focus: '*:focus
    1:       ColorToString(focusText,strColor);
    1:       strRule.AppendLiteral("*:focus,*:focus>font {color: ");
    1:       strRule.Append(strColor);
    1:       strRule.AppendLiteral(" !important; background-color: ");
    1:       ColorToString(focusBackground,strColor);
    1:       strRule.Append(strColor);
    1:       strRule.AppendLiteral(" !important; } ");
    1:       // insert the rules
10382:       result = mPrefStyleSheet->
10382:         InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:     }
    1:     PRUint8 focusRingWidth = mPresContext->FocusRingWidth();
    1:     PRBool focusRingOnAnything = mPresContext->GetFocusRingOnAnything();
20177:     PRUint8 focusRingStyle = mPresContext->GetFocusRingStyle();
    1: 
    1:     if ((NS_SUCCEEDED(result) && focusRingWidth != 1 && focusRingWidth <= 4 ) || focusRingOnAnything) {
    1:       PRUint32 index = 0;
    1:       nsAutoString strRule;
    1:       if (!focusRingOnAnything)
    1:         strRule.AppendLiteral("*|*:link:focus, *|*:visited");    // If we only want focus rings on the normal things like links
    1:       strRule.AppendLiteral(":focus {outline: ");     // For example 3px dotted WindowText (maximum 4)
    1:       strRule.AppendInt(focusRingWidth);
20177:       if (focusRingStyle == 0) // solid
21040:         strRule.AppendLiteral("px solid -moz-mac-focusring !important; -moz-outline-radius: 3px; outline-offset: 1px; } ");
20177:       else // dotted
20177:         strRule.AppendLiteral("px dotted WindowText !important; } ");
    1:       // insert the rules
10382:       result = mPrefStyleSheet->
10382:         InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:       NS_ENSURE_SUCCESS(result, result);
    1:       if (focusRingWidth != 1) {
    1:         // If the focus ring width is different from the default, fix buttons with rings
    1:         strRule.AssignLiteral("button::-moz-focus-inner, input[type=\"reset\"]::-moz-focus-inner,");
    1:         strRule.AppendLiteral("input[type=\"button\"]::-moz-focus-inner, ");
    1:         strRule.AppendLiteral("input[type=\"submit\"]::-moz-focus-inner { padding: 1px 2px 1px 2px; border: ");
    1:         strRule.AppendInt(focusRingWidth);
20177:         if (focusRingStyle == 0) // solid
20177:           strRule.AppendLiteral("px solid transparent !important; } ");
20177:         else
    1:           strRule.AppendLiteral("px dotted transparent !important; } ");
10382:         result = mPrefStyleSheet->
10382:           InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:         NS_ENSURE_SUCCESS(result, result);
    1:           
    1:         strRule.AssignLiteral("button:focus::-moz-focus-inner, input[type=\"reset\"]:focus::-moz-focus-inner,");
    1:         strRule.AppendLiteral("input[type=\"button\"]:focus::-moz-focus-inner, input[type=\"submit\"]:focus::-moz-focus-inner {");
    1:         strRule.AppendLiteral("border-color: ButtonText !important; }");
10382:         result = mPrefStyleSheet->
10382:           InsertRuleInternal(strRule, sInsertPrefSheetRulesAt, &index);
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: void
    1: PresShell::AddUserSheet(nsISupports* aSheet)
    1: {
    1:   // Make sure this does what DocumentViewerImpl::CreateStyleSet does wrt
    1:   // ordering. We want this new sheet to come after all the existing stylesheet
    1:   // service sheets, but before other user sheets; see nsIStyleSheetService.idl
    1:   // for the ordering.  Just remove and readd all the nsStyleSheetService
    1:   // sheets.
    1:   nsCOMPtr<nsIStyleSheetService> dummy =
    1:     do_GetService(NS_STYLESHEETSERVICE_CONTRACTID);
    1: 
    1:   mStyleSet->BeginUpdate();
    1:   
    1:   nsStyleSheetService *sheetService = nsStyleSheetService::gInstance;
    1:   nsCOMArray<nsIStyleSheet> & userSheets = *sheetService->UserStyleSheets();
    1:   PRInt32 i;
    1:   // Iterate forwards when removing so the searches for RemoveStyleSheet are as
    1:   // short as possible.
    1:   for (i = 0; i < userSheets.Count(); ++i) {
    1:     mStyleSet->RemoveStyleSheet(nsStyleSet::eUserSheet, userSheets[i]);
    1:   }
    1: 
    1:   // Now iterate backwards, so that the order of userSheets will be the same as
    1:   // the order of sheets from it in the style set.
    1:   for (i = userSheets.Count() - 1; i >= 0; --i) {
    1:     mStyleSet->PrependStyleSheet(nsStyleSet::eUserSheet, userSheets[i]);
    1:   }
    1: 
    1:   mStyleSet->EndUpdate();
    1: 
    1:   ReconstructStyleData();
    1: }
    1: 
    1: void
    1: PresShell::AddAgentSheet(nsISupports* aSheet)
    1: {
    1:   // Make sure this does what DocumentViewerImpl::CreateStyleSet does
    1:   // wrt ordering.
    1:   nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
    1:   if (!sheet) {
    1:     return;
    1:   }
    1: 
    1:   mStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:   ReconstructStyleData();
    1: }
    1: 
    1: void
    1: PresShell::RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet)
    1: {
    1:   nsCOMPtr<nsIStyleSheet> sheet = do_QueryInterface(aSheet);
    1:   if (!sheet) {
    1:     return;
    1:   }
    1: 
    1:   mStyleSet->RemoveStyleSheet(aType, sheet);
    1:   ReconstructStyleData();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::SetDisplaySelection(PRInt16 aToggle)
    1: {
    1:   mSelection->SetDisplaySelection(aToggle);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetDisplaySelection(PRInt16 *aToggle)
    1: {
    1:   *aToggle = mSelection->GetDisplaySelection();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetSelection(SelectionType aType, nsISelection **aSelection)
    1: {
    1:   if (!aSelection || !mSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aSelection = mSelection->GetSelection(aType);
    1: 
    1:   if (!(*aSelection))
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   NS_ADDREF(*aSelection);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsISelection*
    1: PresShell::GetCurrentSelection(SelectionType aType)
    1: {
    1:   if (!mSelection)
    1:     return nsnull;
    1: 
    1:   return mSelection->GetSelection(aType);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion, PRBool aIsSynchronous)
    1: {
    1:   if (!mSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   return mSelection->ScrollSelectionIntoView(aType, aRegion, aIsSynchronous);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::RepaintSelection(SelectionType aType)
    1: {
    1:   if (!mSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   return mSelection->RepaintSelection(aType);
    1: }
    1: 
    1: // Make shell be a document observer
    1: NS_IMETHODIMP
    1: PresShell::BeginObservingDocument()
    1: {
 1416:   if (mDocument && !mIsDestroying) {
    1:     mDocument->AddObserver(this);
    1:     if (mIsDocumentGone) {
    1:       NS_WARNING("Adding a presshell that was disconnected from the document "
    1:                  "as a document observer?  Sounds wrong...");
    1:       mIsDocumentGone = PR_FALSE;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Make shell stop being a document observer
    1: NS_IMETHODIMP
    1: PresShell::EndObservingDocument()
    1: {
    1:   // XXXbz do we need to tell the frame constructor that the document
    1:   // is gone, perhaps?  Except for printing it's NOT gone, sometimes.
    1:   mIsDocumentGone = PR_TRUE;
    1:   if (mDocument) {
    1:     mDocument->RemoveObserver(this);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG_kipp
    1: char* nsPresShell_ReflowStackPointerTop;
    1: #endif
    1: 
    1: static void CheckForFocus(nsPIDOMWindow* aOurWindow,
    1:                           nsIFocusController* aFocusController,
    1:                           nsIDocument* aDocument)
    1: {
    1:   NS_ASSERTION(aOurWindow->IsOuterWindow(),
    1:                "Uh, our window has to be an outer window!");
    1: 
    1:   // Now that we have a root frame, we can set focus on the presshell.
    1:   // We do this only if our DOM window is currently focused or is an
    1:   // an ancestor of a previously focused window.
    1: 
    1:   if (!aFocusController)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> focusedWindow;
    1:   aFocusController->GetFocusedWindow(getter_AddRefs(focusedWindow));
    1:   if (!focusedWindow) {
20244:     // This happens if the window has not been shown yet. We don't need to
20244:     // focus anything now because showing the window will set the focus.
20244:     return;
    1:   }
    1: 
    1:   // Walk up the document chain, starting with focusedWindow's document.
    1:   // We stop walking when we find a document that has a null DOMWindow
20244:   // (meaning that the DOMWindow has a new document now) or find aOurWindow
    1:   // as the document's window.  We also stop if we hit aDocument, since
    1:   // that means there is a child document which loaded before us that's
    1:   // already been given focus.
    1: 
    1:   nsCOMPtr<nsIDOMDocument> focusedDOMDoc;
    1:   focusedWindow->GetDocument(getter_AddRefs(focusedDOMDoc));
    1: 
    1:   nsCOMPtr<nsIDocument> curDoc = do_QueryInterface(focusedDOMDoc);
    1:   if (!curDoc) {
    1:     // This can happen if the previously focused DOM window has been
    1:     // unhooked from its document during document teardown.  We don't
    1:     // really have any other information to help us determine where
    1:     // focusedWindow fits into the DOM window hierarchy.  For now, we'll
    1:     // go ahead and allow this window to take focus, so that something
    1:     // ends up focused.
    1: 
    1:     curDoc = aDocument;
    1:   }
    1: 
    1:   while (curDoc) {
    1:     nsPIDOMWindow *curWin = curDoc->GetWindow();
    1: 
20244:     if (!curWin || curWin == aOurWindow)
    1:       break;
    1: 
    1:     curDoc = curDoc->GetParentDocument();
    1:     if (curDoc == aDocument)
    1:       return;
    1:   }
    1: 
    1:   if (!curDoc) {
20244:     // We reached the top of the document chain, and did not encounter
20244:     // aOurWindow or a windowless document. So, focus should be unaffected
20244:     // by this document load.
    1:     return;
    1:   }
    1: 
    1:   PRBool active;
    1:   aFocusController->GetActive(&active);
    1:   if (active)
20244:     aOurWindow->Focus();
    1: 
    1:   // We need to ensure that the focus controller is updated, since it may be
    1:   // suppressed when this function is called.
20244:   aFocusController->SetFocusedWindow(aOurWindow);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::InitialReflow(nscoord aWidth, nscoord aHeight)
    1: {
  967:   if (mIsDestroying) {
  967:     return NS_OK;
  967:   }
  967: 
20272:   NS_ASSERTION(!mDidInitialReflow, "Why are we being called?");
20272: 
    1:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
    1:   mDidInitialReflow = PR_TRUE;
    1: 
    1: #ifdef NS_DEBUG
    1:   if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:     if (mDocument) {
    1:       nsIURI *uri = mDocument->GetDocumentURI();
    1:       if (uri) {
    1:         nsCAutoString url;
    1:         uri->GetSpec(url);
    1:         printf("*** PresShell::InitialReflow (this=%p, url='%s')\n", (void*)this, url.get());
    1:       }
    1:     }
    1:   }
    1: #endif
    1: 
    1:   if (mCaret)
    1:     mCaret->EraseCaret();
    1: 
    1:   // XXX Do a full invalidate at the beginning so that invalidates along
    1:   // the way don't have region accumulation issues?
    1: 
  967:   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
    1: 
    1:   nsIContent *root = mDocument ? mDocument->GetRootContent() : nsnull;
    1: 
    1:   // Get the root frame from the frame manager
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   
    1:   if (root) {
    1:     MOZ_TIMER_DEBUGLOG(("Reset and start: Frame Creation: PresShell::InitialReflow(), this=%p\n",
    1:                         (void*)this));
    1:     MOZ_TIMER_RESET(mFrameCreationWatch);
    1:     MOZ_TIMER_START(mFrameCreationWatch);
    1: 
13098:     {
22979:       nsAutoScriptBlocker scriptBlocker;
 6518:       mFrameConstructor->BeginUpdate();
 6518: 
    1:       if (!rootFrame) {
    1:         // Have style sheet processor construct a frame for the
    1:         // precursors to the root content object's frame
    1:         mFrameConstructor->ConstructRootFrame(root, &rootFrame);
    1:         FrameManager()->SetRootFrame(rootFrame);
    1:       }
    1: 
    1:       // Have the style sheet processor construct frame for the root
    1:       // content object down
 4696:       mFrameConstructor->ContentInserted(nsnull, root, 0, nsnull);
    1:       VERIFY_STYLE_TREE;
    1:       MOZ_TIMER_DEBUGLOG(("Stop: Frame Creation: PresShell::InitialReflow(), this=%p\n",
    1:                           (void*)this));
    1:       MOZ_TIMER_STOP(mFrameCreationWatch);
    1: 
    1:       // Something in mFrameConstructor->ContentInserted may have caused
    1:       // Destroy() to get called, bug 337586.
    1:       NS_ENSURE_STATE(!mHaveShutDown);
 1416: 
 6518:       mFrameConstructor->EndUpdate();
13098:     }
13098: 
13098:     // DidCauseReflow may have killed us too
13098:     NS_ENSURE_STATE(!mHaveShutDown);
 6518: 
 1416:     // Run the XBL binding constructors for any new frames we've constructed
 1416:     mDocument->BindingManager()->ProcessAttachedQueue();
 1416: 
 1416:     // Constructors may have killed us too
 1416:     NS_ENSURE_STATE(!mHaveShutDown);
 1416: 
 1416:     // Now flush out pending restyles before we actually reflow, in
 1416:     // case XBL constructors changed styles somewhere.
 1416:     mFrameConstructor->ProcessPendingRestyles();
 1416: 
 1416:     // And that might have run _more_ XBL constructors
 1416:     NS_ENSURE_STATE(!mHaveShutDown);
 1416: 
 1416:     // Now reget the root frame, since all that script might have affected it
 1416:     // somehow.  Currently that can't happen, as long as mHaveShutDown is
 1416:     // false, but let's not rely on that.
 1416:     rootFrame = FrameManager()->GetRootFrame();
    1:   }
    1: 
    1:   if (rootFrame) {
 1158:     // Note: Because the frame just got created, it has the NS_FRAME_IS_DIRTY
 1158:     // bit set.  Unset it so that FrameNeedsReflow() will work right.
 1158:     NS_ASSERTION(mDirtyRoots.IndexOf(rootFrame) == -1,
 1158:                  "Why is the root in mDirtyRoots already?");
 1158: 
 1158:     rootFrame->RemoveStateBits(NS_FRAME_IS_DIRTY |
 1158:                                NS_FRAME_HAS_DIRTY_CHILDREN);
 1158:     FrameNeedsReflow(rootFrame, eResize, NS_FRAME_IS_DIRTY);
 1158: 
 1158:     NS_ASSERTION(mDirtyRoots.IndexOf(rootFrame) != -1,
 1158:                  "Should be in mDirtyRoots now");
 1158:     NS_ASSERTION(mReflowEvent.IsPending(), "Why no reflow event pending?");
  967:   }
  752: 
  824:   // Restore our root scroll position now if we're getting here after EndLoad
  967:   // got called, since this is our one chance to do it.  Note that we need not
  967:   // have reflowed for this to work; when the scrollframe is finally reflowed
  967:   // it'll puick up the position we store in it here.
  824:   if (!mDocumentLoading) {
  824:     RestoreRootScrollPosition();
  824:   }
  824: 
    1:   // For printing, we just immediately unsuppress.
    1:   if (!mPresContext->IsPaginated()) {
    1:     // Kick off a one-shot timer based off our pref value.  When this timer
    1:     // fires, if painting is still locked down, then we will go ahead and
    1:     // trigger a full invalidate and allow painting to proceed normally.
    1:     mPaintingSuppressed = PR_TRUE;
    1:     mPaintSuppressionTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     if (!mPaintSuppressionTimer)
    1:       // Uh-oh.  We must be out of memory.  No point in keeping painting locked down.
    1:       mPaintingSuppressed = PR_FALSE;
    1:     else {
    1:       // Initialize the timer.
    1: 
    1:       // Default to PAINTLOCK_EVENT_DELAY if we can't get the pref value.
    1:       PRInt32 delay =
    1:         nsContentUtils::GetIntPref("nglayout.initialpaint.delay",
    1:                                    PAINTLOCK_EVENT_DELAY);
    1: 
    1:       mPaintSuppressionTimer->InitWithFuncCallback(sPaintSuppressionCallback,
    1:                                                    this, delay, 
    1:                                                    nsITimer::TYPE_ONE_SHOT);
    1:     }
    1:   }
    1: 
    1:   return NS_OK; //XXX this needs to be real. MMP
    1: }
    1: 
    1: void
    1: PresShell::sPaintSuppressionCallback(nsITimer *aTimer, void* aPresShell)
    1: {
 3233:   PresShell* self = static_cast<PresShell*>(aPresShell);
    1:   if (self)
    1:     self->UnsuppressPainting();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ResizeReflow(nscoord aWidth, nscoord aHeight)
    1: {
 1503:   NS_PRECONDITION(!mIsReflowing, "Shouldn't be in reflow here!");
12971:   NS_PRECONDITION(aWidth != NS_UNCONSTRAINEDSIZE,
12971:                   "shouldn't use unconstrained widths anymore");
 1503:   
    1:   // If we don't have a root frame yet, that means we haven't had our initial
    1:   // reflow... If that's the case, and aWidth or aHeight is unconstrained,
    1:   // ignore them altogether.
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1: 
12971:   if (!rootFrame && aHeight == NS_UNCONSTRAINEDSIZE) {
12971:     // We can't do the work needed for SizeToContent without a root
12971:     // frame, and we want to return before setting the visible area.
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
  790:   mPresContext->SetVisibleArea(nsRect(0, 0, aWidth, aHeight));
  790: 
  790:   // There isn't anything useful we can do if the initial reflow hasn't happened
  790:   if (!rootFrame)
  790:     return NS_OK;
  790: 
10872:   if (!GetPresContext()->SupressingResizeReflow())
10872:   {
  821:     NS_ASSERTION(mViewManager, "Must have view manager");
10730:     nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
10730:     nsIViewManager::UpdateViewBatch batch(mViewManager);
 6162: 
 6162:     // Take this ref after viewManager so it'll make sure to go away first
 6162:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
 6162: 
 6162:     // Make sure style is up to date
 6162:     mFrameConstructor->ProcessPendingRestyles();
10872: 
 6162:     if (!mIsDestroying) {
  821:       // XXX Do a full invalidate at the beginning so that invalidates along
  821:       // the way don't have region accumulation issues?
  821: 
13098:       {
22979:         nsAutoScriptBlocker scriptBlocker;
  821:         WillDoReflow();
  821: 
    1:         // Kick off a top-down reflow
    1:         AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
 1503:         mIsReflowing = PR_TRUE;
    1: 
  816:         mDirtyRoots.RemoveElement(rootFrame);
  790:         DoReflow(rootFrame);
 1503:         mIsReflowing = PR_FALSE;
  790:       }
  790: 
    1:       DidDoReflow();
 6162:     }
 6162: 
10730:     batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
10872:   }
 6162: 
12971:   if (aHeight == NS_UNCONSTRAINEDSIZE) {
12971:     mPresContext->SetVisibleArea(
12971:       nsRect(0, 0, aWidth, rootFrame->GetRect().height));
12971:   }
12971: 
 6162:   if (!mIsDestroying) {
    1:     CreateResizeEventTimer();
 6162:   }
    1: 
    1:   return NS_OK; //XXX this needs to be real. MMP
    1: }
    1: 
    1: #define RESIZE_EVENT_DELAY 200
    1: 
    1: void
    1: PresShell::CreateResizeEventTimer ()
    1: {
20069:   // if we already have a timer set, ignore this call
20069:   if (mResizeEventTimer)
20069:     return;
    1: 
    1:   if (mIsDocumentGone)
    1:     return;
    1: 
    1:   mResizeEventTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:   if (mResizeEventTimer) {
    1:     mResizeEventTimer->InitWithFuncCallback(sResizeEventCallback, this, RESIZE_EVENT_DELAY, 
    1:                                             nsITimer::TYPE_ONE_SHOT);
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::KillResizeEventTimer()
    1: {
    1:   if (mResizeEventTimer) {
    1:     mResizeEventTimer->Cancel();
    1:     mResizeEventTimer = nsnull;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::sResizeEventCallback(nsITimer *aTimer, void* aPresShell)
    1: {
 3233:   PresShell* self = static_cast<PresShell*>(aPresShell);
    1:   if (self) {
    1:     self->FireResizeEvent();  
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::FireResizeEvent()
    1: {
    1:   if (mIsDocumentGone)
    1:     return;
    1: 
20069:   // allow a new timer to be set
20069:   mResizeEventTimer = nsnull;
20069: 
    1:   //Send resize event from here.
    1:   nsEvent event(PR_TRUE, NS_RESIZE_EVENT);
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1: 
    1:   nsPIDOMWindow *window = mDocument->GetWindow();
    1:   if (window) {
    1:     nsEventDispatcher::Dispatch(window, mPresContext, &event, nsnull, &status);
21202:     // |this| may now be destroyed
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::SetIgnoreFrameDestruction(PRBool aIgnore)
    1: {
    1:   mIgnoreFrameDestruction = aIgnore;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::NotifyDestroyingFrame(nsIFrame* aFrame)
    1: {
    1:   if (!mIgnoreFrameDestruction) {
    1:     mFrameConstructor->NotifyDestroyingFrame(aFrame);
    1: 
 1503:     for (PRInt32 idx = mDirtyRoots.Count(); idx; ) {
 1503:       --idx;
 1503:       if (mDirtyRoots[idx] == aFrame) {
 1503:         mDirtyRoots.RemoveElementAt(idx);
 1503:       }
 1503:     }
    1: 
    1:     // Notify the frame manager
    1:     FrameManager()->NotifyDestroyingFrame(aFrame);
    1: 
    1:     // Remove frame properties
    1:     mPresContext->PropertyTable()->DeleteAllPropertiesFor(aFrame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // note that this can return a null caret, but NS_OK
15969: NS_IMETHODIMP PresShell::GetCaret(nsCaret **outCaret)
    1: {
    1:   NS_ENSURE_ARG_POINTER(outCaret);
    1:   
    1:   *outCaret = mCaret;
    1:   NS_IF_ADDREF(*outCaret);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(void) PresShell::MaybeInvalidateCaretPosition()
    1: {
    1:   if (mCaret) {
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
    1: }
    1: 
15969: void PresShell::SetCaret(nsCaret *aNewCaret)
 6232: {
    1:   mCaret = aNewCaret;
 6232: }
 6232: 
 6232: void PresShell::RestoreCaret()
 6232: {
 6232:   mCaret = mOriginalCaret;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::SetCaretEnabled(PRBool aInEnable)
    1: {
    1:   PRBool oldEnabled = mCaretEnabled;
    1: 
    1:   mCaretEnabled = aInEnable;
    1: 
    1:   if (mCaret && (mCaretEnabled != oldEnabled))
    1:   {
    1: /*  Don't change the caret's selection here! This was an evil side-effect of SetCaretEnabled()
    1:     nsCOMPtr<nsIDOMSelection> domSel;
    1:     if (NS_SUCCEEDED(GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel))) && domSel)
    1:       mCaret->SetCaretDOMSelection(domSel);
    1: */
15969:     mCaret->SetCaretVisible(mCaretEnabled);
15969:   }
15969: 
15969:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::SetCaretReadOnly(PRBool aReadOnly)
    1: {
    1:   if (mCaret)
    1:     mCaret->SetCaretReadOnly(aReadOnly);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::GetCaretEnabled(PRBool *aOutEnabled)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOutEnabled);
    1:   *aOutEnabled = mCaretEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::SetCaretVisibilityDuringSelection(PRBool aVisibility)
    1: {
    1:   if (mCaret)
    1:     mCaret->SetVisibilityDuringSelection(aVisibility);
    1:   return NS_OK;
    1: }
    1: 
14068: NS_IMETHODIMP PresShell::GetCaretVisible(PRBool *aOutIsVisible)
14068: {
14068:   *aOutIsVisible = PR_FALSE;
14068:   if (mCaret) {
14068:     nsresult rv = mCaret->GetCaretVisible(aOutIsVisible);
14068:     NS_ENSURE_SUCCESS(rv,rv);
14068:   }
14068:   return NS_OK;
14068: }
14068: 
    1: NS_IMETHODIMP PresShell::SetSelectionFlags(PRInt16 aInEnable)
    1: {
    1:   mSelectionFlags = aInEnable;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP PresShell::GetSelectionFlags(PRInt16 *aOutEnable)
    1: {
    1:   if (!aOutEnable)
    1:     return NS_ERROR_INVALID_ARG;
    1:   *aOutEnable = mSelectionFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: //implementation of nsISelectionController
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::CharacterMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   return mSelection->CharacterMove(aForward, aExtend);  
    1: }
    1: 
    1: NS_IMETHODIMP
20532: PresShell::CharacterExtendForDelete()
20532: {
20532:   return mSelection->CharacterExtendForDelete();
20532: }
20532: 
20532: NS_IMETHODIMP 
    1: PresShell::WordMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   return mSelection->WordMove(aForward, aExtend);  
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::WordExtendForDelete(PRBool aForward)
    1: {
    1:   return mSelection->WordExtendForDelete(aForward);  
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::LineMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   nsresult result = mSelection->LineMove(aForward, aExtend);  
    1: // if we can't go down/up any more we must then move caret completely to 
    1: // end/beginning respectively.
    1:   if (NS_FAILED(result)) 
    1:     result = CompleteMove(aForward,aExtend);
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::IntraLineMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   return mSelection->IntraLineMove(aForward, aExtend);  
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::PageMove(PRBool aForward, PRBool aExtend)
    1: {
    1:   nsresult result;
    1:   nsIViewManager* viewManager = GetViewManager();
    1:   nsIScrollableView *scrollableView;
    1:   if (!viewManager) 
    1:     return NS_ERROR_UNEXPECTED;
    1:   result = viewManager->GetRootScrollableView(&scrollableView);
    1:   if (NS_FAILED(result)) 
    1:     return result;
    1:   if (!scrollableView) 
    1:     return NS_ERROR_UNEXPECTED;
    1:   nsIView *scrolledView;
    1:   result = scrollableView->GetScrolledView(scrolledView);
    1:   mSelection->CommonPageMove(aForward, aExtend, scrollableView);
12392:   // After ScrollSelectionIntoView(), the pending notifications might be
12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
    1:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, nsISelectionController::SELECTION_FOCUS_REGION, PR_TRUE);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::ScrollPage(PRBool aForward)
    1: {
    1:   nsIScrollableView* scrollView = GetViewToScroll(nsLayoutUtils::eVertical);
    1:   if (scrollView) {
22316:     scrollView->ScrollByPages(0, aForward ? 1 : -1, NS_VMREFRESH_SMOOTHSCROLL);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ScrollLine(PRBool aForward)
    1: {
    1:   nsIScrollableView* scrollView = GetViewToScroll(nsLayoutUtils::eVertical);
    1:   if (scrollView) {
    1: #ifdef MOZ_WIDGET_COCOA
    1:     // Emulate the Mac IE behavior of scrolling a minimum of 2 lines
    1:     // rather than 1.  This vastly improves scrolling speed.
22316:     scrollView->ScrollByLines(0, aForward ? 2 : -2, NS_VMREFRESH_SMOOTHSCROLL);
    1: #else
22316:     scrollView->ScrollByLines(0, aForward ? 1 : -1, NS_VMREFRESH_SMOOTHSCROLL);
    1: #endif
    1:       
    1: //NEW FOR LINES    
    1:     // force the update to happen now, otherwise multiple scrolls can
    1:     // occur before the update is processed. (bug #7354)
    1: 
    1:   // I'd use Composite here, but it doesn't always work.
    1:     // vm->Composite();
    1:     nsIViewManager* viewManager = GetViewManager();
    1:     if (viewManager) {
    1:       viewManager->ForceUpdate();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ScrollHorizontal(PRBool aLeft)
    1: {
    1:   nsIScrollableView* scrollView = GetViewToScroll(nsLayoutUtils::eHorizontal);
    1:   if (scrollView) {
22316:     scrollView->ScrollByLines(aLeft ? -1 : 1, 0, NS_VMREFRESH_SMOOTHSCROLL);
    1: //NEW FOR LINES    
    1:     // force the update to happen now, otherwise multiple scrolls can
    1:     // occur before the update is processed. (bug #7354)
    1: 
    1:   // I'd use Composite here, but it doesn't always work.
    1:     // vm->Composite();
    1:     nsIViewManager* viewManager = GetViewManager();
    1:     if (viewManager) {
    1:       viewManager->ForceUpdate();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CompleteScroll(PRBool aForward)
    1: {
    1:   nsIScrollableView* scrollView = GetViewToScroll(nsLayoutUtils::eVertical);
    1:   if (scrollView) {
    1:     scrollView->ScrollByWhole(!aForward);//TRUE = top, aForward TRUE=bottom
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CompleteMove(PRBool aForward, PRBool aExtend)
    1: {
12392:   // Beware! This may flush notifications via synchronous
12392:   // ScrollSelectionIntoView.
14558: 
 3674:   nsIContent* root = mSelection->GetAncestorLimiter();
 7855:   nsIDocument* doc;
 7855:   if (root && (doc = root->GetOwnerDoc()) && doc->GetRootContent() != root) {
 7855:     // Make the caret be either at the very beginning (0) or the very end of
 7855:     // root. Only do this when not moving to the beginning or end of the
 7855:     // document (root is null or root is the documentElement), that's handled
 7855:     // below by moving to beginning or end of the scrollable view.
 3674:     nsIContent* node = root;
 3674:     PRInt32 offset = 0;
 3674:     nsFrameSelection::HINT hint = nsFrameSelection::HINTLEFT;
 3674:     if (aForward) {
 3674:       nsIContent* next = node;
 3674:       PRUint32 count;
 3674:       while ((count = next->GetChildCount()) > 0) {
 3674:         node = next;
 3674:         offset = count;
 3674:         next = next->GetChildAt(count - 1);
 3674:       }
 3674: 
 3674:       if (offset > 0 && node->GetChildAt(offset - 1)->Tag() == nsGkAtoms::br) {
 3674:         --offset;
 3674:         hint = nsFrameSelection::HINTRIGHT; // for bug 106855
 3674:       }
 3674:     }
 3674: 
 3674:     mSelection->HandleClick(node, offset, offset, aExtend, PR_FALSE, hint);
 3674: 
 3674:     // HandleClick resets ancestorLimiter, so set it again.
 3674:     mSelection->SetAncestorLimiter(root);
 3674: 
12392:     // After ScrollSelectionIntoView(), the pending notifications might be
12392:     // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
 3674:     return
 3674:       ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, 
 3674:                               nsISelectionController::SELECTION_FOCUS_REGION,
 3674:                               PR_TRUE);
 3674:   }
 3674: 
19355:   nsIFrame *frame = FrameConstructor()->GetRootElementFrame();
    1:   if (!frame)
    1:     return NS_ERROR_FAILURE;
    1:   nsPeekOffsetStruct pos = frame->GetExtremeCaretPosition(!aForward);
    1: 
    1:   mSelection->HandleClick(pos.mResultContent ,pos.mContentOffset ,pos.mContentOffset/*End*/ ,aExtend, PR_FALSE, aForward);
  533: 
12392:   // After ScrollSelectionIntoView(), the pending notifications might be
12392:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
14558:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, 
14558:                                  nsISelectionController::SELECTION_FOCUS_REGION,
14558:                                  PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::SelectAll()
    1: {
    1:   return mSelection->SelectAll();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval)
    1: {
    1:   if (!node || startOffset>EndOffset || !_retval || startOffset<0 || EndOffset<0)
    1:     return NS_ERROR_INVALID_ARG;
    1:   *_retval = PR_FALSE; //initialize return parameter
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
    1:   if (!content)
    1:     return NS_ERROR_FAILURE;
    1:   nsIFrame *frame = GetPrimaryFrameFor(content);
    1:   if (!frame) //no frame to look at so it must not be visible
    1:     return NS_OK;  
    1:   //start process now to go through all frames to find startOffset. then check chars after that to see 
    1:   //if anything until EndOffset is visible.
    1:   PRBool finished = PR_FALSE;
    1:   frame->CheckVisibility(mPresContext,startOffset,EndOffset,PR_TRUE,&finished, _retval);
    1:   return NS_OK;//dont worry about other return val
    1: }
    1: 
    1: //end implementations nsISelectionController
    1: 
    1: 
    1: NS_IMETHODIMP
    1: PresShell::StyleChangeReflow()
    1: {
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
  790:   // At the moment at least, we don't have a root frame before the initial
  790:   // reflow; it's safe to just ignore the request in that case
  790:   if (!rootFrame)
  790:     return NS_OK;
  790: 
 1158:   return FrameNeedsReflow(rootFrame, eStyleChange, NS_FRAME_IS_DIRTY);
    1: }
    1: 
    1: nsIFrame*
    1: nsIPresShell::GetRootFrame() const
    1: {
    1:   return FrameManager()->GetRootFrame();
    1: }
    1: 
    1: nsIFrame*
    1: nsIPresShell::GetRootScrollFrame() const
    1: {
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   // Ensure root frame is a viewport frame
    1:   if (!rootFrame || nsGkAtoms::viewportFrame != rootFrame->GetType())
    1:     return nsnull;
    1:   nsIFrame* theFrame = rootFrame->GetFirstChild(nsnull);
    1:   if (!theFrame || nsGkAtoms::scrollFrame != theFrame->GetType())
    1:     return nsnull;
    1:   return theFrame;
    1: }
    1: 
    1: nsIScrollableFrame*
    1: nsIPresShell::GetRootScrollFrameAsScrollable() const
    1: {
    1:   nsIFrame* frame = GetRootScrollFrame();
    1:   if (!frame)
    1:     return nsnull;
    1:   nsIScrollableFrame* scrollableFrame = nsnull;
    1:   CallQueryInterface(frame, &scrollableFrame);
 1735:   NS_ASSERTION(scrollableFrame,
 1735:                "All scroll frames must implement nsIScrollableFrame");
    1:   return scrollableFrame;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetPageSequenceFrame(nsIPageSequenceFrame** aResult) const
    1: {
    1:   NS_PRECONDITION(nsnull != aResult, "null ptr");
    1:   if (nsnull == aResult) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   *aResult = nsnull;
    1:   nsIFrame* frame = mFrameConstructor->GetPageSequenceFrame();
    1:   if (frame) {
    1:     CallQueryInterface(frame, aResult);
    1:   }
    1:   return *aResult ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
 5680: nsIFrame*
 5680: PresShell::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt)
 5680: {
 5680:   return nsLayoutUtils::GetFrameForPoint(aFrame, aPt);
 5680: }
 5680: 
    1: void
    1: PresShell::BeginUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
    1: {
    1: #ifdef DEBUG
    1:   mUpdateCount++;
    1: #endif
    1:   mFrameConstructor->BeginUpdate();
    1: 
    1:   if (aUpdateType & UPDATE_STYLE)
    1:     mStyleSet->BeginUpdate();
    1: }
    1: 
    1: void
    1: PresShell::EndUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
    1: {
    1: #ifdef DEBUG
    1:   NS_PRECONDITION(0 != mUpdateCount, "too many EndUpdate's");
    1:   --mUpdateCount;
    1: #endif
    1: 
    1:   if (aUpdateType & UPDATE_STYLE) {
    1:     mStyleSet->EndUpdate();
    1:     if (mStylesHaveChanged)
    1:       ReconstructStyleData();
    1:   }
    1: 
    1:   mFrameConstructor->EndUpdate();
    1: }
    1: 
    1: void
  824: PresShell::RestoreRootScrollPosition()
  824: {
    1:   // Restore frame state for the root scroll frame
    1:   nsCOMPtr<nsILayoutHistoryState> historyState =
  824:     mDocument->GetLayoutHistoryState();
    1:   // Make sure we don't reenter reflow via the sync paint that happens while
    1:   // we're scrolling to our restored position.  Entering reflow for the
    1:   // scrollable frame will cause it to reenter ScrollToRestoredPosition(), and
    1:   // it'll get all confused.
13098:   nsAutoScriptBlocker scriptBlocker;
    1: 
    1:   if (historyState) {
    1:     nsIFrame* scrollFrame = GetRootScrollFrame();
    1:     if (scrollFrame) {
    1:       nsIScrollableFrame* scrollableFrame;
    1:       CallQueryInterface(scrollFrame, &scrollableFrame);
    1:       if (scrollableFrame) {
    1:         FrameManager()->RestoreFrameStateFor(scrollFrame, historyState,
    1:                                              nsIStatefulFrame::eDocumentScrollState);
    1:         scrollableFrame->ScrollToRestoredPosition();
    1:       }
    1:     }
    1:   }
  824: }
  824: 
  824: void
  824: PresShell::BeginLoad(nsIDocument *aDocument)
  824: {  
  824: #ifdef MOZ_PERF_METRICS
  824:   // Reset style resolution stopwatch maintained by style set
  824:   MOZ_TIMER_DEBUGLOG(("Reset: Style Resolution: PresShell::BeginLoad(), this=%p\n", (void*)this));
  824: #endif  
  824:   mDocumentLoading = PR_TRUE;
  824: }
  824: 
  824: void
  824: PresShell::EndLoad(nsIDocument *aDocument)
  824: {
  824:   NS_PRECONDITION(aDocument == mDocument, "Wrong document");
  824:   
  824:   RestoreRootScrollPosition();
    1:   
    1: #ifdef MOZ_PERF_METRICS
    1:   // Dump reflow, style resolution and frame construction times here.
    1:   MOZ_TIMER_DEBUGLOG(("Stop: Reflow: PresShell::EndLoad(), this=%p\n", this));
    1:   MOZ_TIMER_STOP(mReflowWatch);
    1:   MOZ_TIMER_LOG(("Reflow time (this=%p): ", this));
    1:   MOZ_TIMER_PRINT(mReflowWatch);  
    1: 
    1:   MOZ_TIMER_DEBUGLOG(("Stop: Frame Creation: PresShell::EndLoad(), this=%p\n", this));
    1:   MOZ_TIMER_STOP(mFrameCreationWatch);
    1:   MOZ_TIMER_LOG(("Frame construction plus style resolution time (this=%p): ", this));
    1:   MOZ_TIMER_PRINT(mFrameCreationWatch);
    1: 
    1:   // Print style resolution stopwatch maintained by style set
    1:   MOZ_TIMER_DEBUGLOG(("Stop: Style Resolution: PresShell::EndLoad(), this=%p\n", this));
    1: #endif  
    1:   mDocumentLoading = PR_FALSE;
    1: }
    1: 
  925: #ifdef DEBUG
  925: void
  925: PresShell::VerifyHasDirtyRootAncestor(nsIFrame* aFrame)
  925: {
  925:   // XXXbz due to bug 372769, can't actually assert anything here...
  925:   return;
  925:   
  925:   // XXXbz shouldn't need this part; remove it once FrameNeedsReflow
  925:   // handles the root frame correctly.
  925:   if (!aFrame->GetParent()) {
  925:     return;
  925:   }
  925:         
  925:   // Make sure that there is a reflow root ancestor of |aFrame| that's
  925:   // in mDirtyRoots already.
  925:   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)) {
  925:     if (((aFrame->GetStateBits() & NS_FRAME_REFLOW_ROOT) ||
  925:          !aFrame->GetParent()) &&
  925:         mDirtyRoots.IndexOf(aFrame) != -1) {
  925:       return;
  925:     }
  925: 
  925:     aFrame = aFrame->GetParent();
  925:   }
  925:   NS_NOTREACHED("Frame has dirty bits set but isn't scheduled to be "
  925:                 "reflowed?");
  925: }
  925: #endif
  925: 
    1: NS_IMETHODIMP
 1158: PresShell::FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
 1161:                             nsFrameState aBitToAdd)
 1161: {
 1161:   NS_PRECONDITION(aBitToAdd == NS_FRAME_IS_DIRTY ||
 1161:                   aBitToAdd == NS_FRAME_HAS_DIRTY_CHILDREN,
 1158:                   "Unexpected bits being added");
    1: 
 1503:   NS_ASSERTION(!mIsReflowing, "can't mark frame dirty during reflow");
    1: 
    1:   // If we've not yet done the initial reflow, then don't bother
    1:   // enqueuing a reflow command yet.
    1:   if (! mDidInitialReflow)
    1:     return NS_OK;
    1: 
    1:   // If we're already destroying, don't bother with this either.
    1:   if (mIsDestroying)
    1:     return NS_OK;
    1: 
    1: #ifdef DEBUG
    1:   //printf("gShellCounter: %d\n", gShellCounter++);
    1:   if (mInVerifyReflow) {
    1:     return NS_OK;
    1:   }
 1735: 
    1:   if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:     printf("\nPresShell@%p: frame %p needs reflow\n", (void*)this, (void*)aFrame);
    1:     if (VERIFY_REFLOW_REALLY_NOISY_RC & gVerifyReflowFlags) {
    1:       printf("Current content model:\n");
    1:       nsIContent *rootContent = mDocument->GetRootContent();
    1:       if (rootContent) {
    1:         rootContent->List(stdout, 0);
    1:       }
    1:     }
    1:   }  
    1: #endif
    1: 
 2472:   // Grab |wasDirty| now so we can go ahead and update the bits on aFrame.
 1158:   PRBool wasDirty = NS_SUBTREE_DIRTY(aFrame);
 1161:   aFrame->AddStateBits(aBitToAdd);
 2472: 
 2472:   // Now if aFrame is a reflow root we can cut off this reflow at it if the bit
 2472:   // being added is NS_FRAME_HAS_DIRTY_CHILDREN.
 2472:   PRBool targetFrameDirty = (aBitToAdd == NS_FRAME_IS_DIRTY);
 2472: 
 1158: #define FRAME_IS_REFLOW_ROOT(_f)                   \
 1158:   ((_f->GetStateBits() & NS_FRAME_REFLOW_ROOT) &&  \
 1158:    (_f != aFrame || !targetFrameDirty))
 1158: 
 1158: 
    1:   // Mark the intrinsic widths as dirty on the frame, all of its ancestors,
    1:   // and all of its descendants, if needed:
    1: 
    1:   if (aIntrinsicDirty != eResize) {
 1158:     // Mark argument and all ancestors dirty. (Unless we hit a reflow root that
 1158:     // should contain the reflow.  That root could be aFrame itself if it's not
 1158:     // dirty, or it could be some ancestor of aFrame.)
    1:     for (nsIFrame *a = aFrame;
 1158:          a && !FRAME_IS_REFLOW_ROOT(a);
    1:          a = a->GetParent())
    1:       a->MarkIntrinsicWidthsDirty();
    1:   }
    1: 
    1:   if (aIntrinsicDirty == eStyleChange) {
    1:     // Mark all descendants dirty (using an nsVoidArray stack rather than
    1:     // recursion).
    1:     nsVoidArray stack;
    1:     stack.AppendElement(aFrame);
    1: 
    1:     while (stack.Count() != 0) {
    1:       nsIFrame *f =
 3233:         static_cast<nsIFrame*>(stack.FastElementAt(stack.Count() - 1));
    1:       stack.RemoveElementAt(stack.Count() - 1);
    1: 
    1:       PRInt32 childListIndex = 0;
    1:       nsIAtom *childListName;
    1:       do {
    1:         childListName = f->GetAdditionalChildListName(childListIndex++);
    1:         for (nsIFrame *kid = f->GetFirstChild(childListName); kid;
    1:              kid = kid->GetNextSibling()) {
    1:           kid->MarkIntrinsicWidthsDirty();
    1:           stack.AppendElement(kid);
    1:         }
    1:       } while (childListName);
    1:     }
    1:   }
    1: 
    1:   // Set NS_FRAME_HAS_DIRTY_CHILDREN bits (via nsIFrame::ChildIsDirty) up the
    1:   // tree until we reach either a frame that's already dirty or a reflow root.
    1:   nsIFrame *f = aFrame;
    1:   for (;;) {
 1158:     if (FRAME_IS_REFLOW_ROOT(f) || !f->GetParent()) {
    1:       // we've hit a reflow root or the root frame
    1:       if (!wasDirty) {
    1:         mDirtyRoots.AppendElement(f);
    1:       }
  925: #ifdef DEBUG
  925:       else {
  925:         VerifyHasDirtyRootAncestor(f);
  925:       }
  925: #endif
  925:       
    1:       break;
    1:     }
    1: 
    1:     nsIFrame *child = f;
    1:     f = f->GetParent();
 1158:     wasDirty = NS_SUBTREE_DIRTY(f);
    1:     f->ChildIsDirty(child);
    1:     NS_ASSERTION(f->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN,
    1:                  "ChildIsDirty didn't do its job");
    1:     if (wasDirty) {
    1:       // This frame was already marked dirty.
  925: #ifdef DEBUG
  925:       VerifyHasDirtyRootAncestor(f);
  925: #endif
    1:       break;
    1:     }
    1:   }
    1: 
    1:   PostReflowEvent();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIScrollableView*
    1: PresShell::GetViewToScroll(nsLayoutUtils::Direction aDirection)
    1: {
    1:   nsCOMPtr<nsIEventStateManager> esm = mPresContext->EventStateManager();
    1:   nsIScrollableView* scrollView = nsnull;
    1:   nsCOMPtr<nsIContent> focusedContent;
    1:   esm->GetFocusedContent(getter_AddRefs(focusedContent));
    1:   if (!focusedContent && mSelection) {
    1:     nsISelection* domSelection = mSelection->
    1:       GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:     if (domSelection) {
    1:       nsCOMPtr<nsIDOMNode> focusedNode;
    1:       domSelection->GetFocusNode(getter_AddRefs(focusedNode));
    1:       focusedContent = do_QueryInterface(focusedNode);
    1:     }
    1:   }
    1:   if (focusedContent) {
    1:     nsIFrame* startFrame = GetPrimaryFrameFor(focusedContent);
    1:     if (startFrame) {
 2706:       nsIScrollableViewProvider* svp;
 2706:       CallQueryInterface(startFrame, &svp);
    1:       // If this very frame provides a scroll view, start there instead of frame's
    1:       // closest view, because the scroll view may be inside a child frame.
    1:       // For example, this happens in the case of overflow:scroll.
    1:       // In that case we still use GetNearestScrollingView() because
    1:       // we need a scrolling view that matches aDirection.
    1:       nsIScrollableView* sv;
    1:       nsIView* startView = svp && (sv = svp->GetScrollableView()) ? sv->View() : startFrame->GetClosestView();
    1:       NS_ASSERTION(startView, "No view to start searching for scrollable view from");
    1:       scrollView = nsLayoutUtils::GetNearestScrollingView(startView, aDirection);
    1:     }
    1:   }
    1:   if (!scrollView) {
    1:     nsIViewManager* viewManager = GetViewManager();
    1:     if (viewManager) {
    1:       viewManager->GetRootScrollableView(&scrollView);
    1:     }
    1:   }
    1:   return scrollView;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CancelAllPendingReflows()
    1: {
    1:   mDirtyRoots.Clear();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef ACCESSIBILITY
    1: void nsIPresShell::InvalidateAccessibleSubtree(nsIContent *aContent)
    1: {
 1071:   if (gIsAccessibilityActive) {
    1:     nsCOMPtr<nsIAccessibilityService> accService = 
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
    1:       accService->InvalidateSubtreeFor(this, aContent,
 4516:                                        nsIAccessibleEvent::EVENT_ASYNCH_SIGNIFICANT_CHANGE);
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: PresShell::RecreateFramesFor(nsIContent* aContent)
    1: {
    1:   NS_ENSURE_TRUE(mPresContext, NS_ERROR_FAILURE);
 1271:   if (!mDidInitialReflow) {
 1271:     // Nothing to do here.  In fact, if we proceed and aContent is the
 1271:     // root we will crash.
 1271:     return NS_OK;
 1271:   }
    1: 
    1:   // Don't call RecreateFramesForContent since that is not exported and we want
    1:   // to keep the number of entrypoints down.
    1: 
    1:   NS_ASSERTION(mViewManager, "Should have view manager");
10730:   nsIViewManager::UpdateViewBatch batch(mViewManager);
    1: 
    1:   // Have to make sure that the content notifications are flushed before we
    1:   // start messing with the frame model; otherwise we can get content doubling.
    1:   mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
    1: 
13098:   nsAutoScriptBlocker scriptBlocker;
13098: 
    1:   nsStyleChangeList changeList;
    1:   changeList.AppendChange(nsnull, aContent, nsChangeHint_ReconstructFrame);
    1: 
    1:   nsresult rv = mFrameConstructor->ProcessRestyledFrames(changeList);
 7017:   
10730:   batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1: #ifdef ACCESSIBILITY
    1:   InvalidateAccessibleSubtree(aContent);
    1: #endif
    1:   return rv;
    1: }
    1: 
15538: void
15538: nsIPresShell::PostRecreateFramesFor(nsIContent* aContent)
15538: {
15538:   FrameConstructor()->PostRestyleEvent(aContent, eReStyle_Self,
15538:           nsChangeHint_ReconstructFrame);
15538: }
15538: 
    1: NS_IMETHODIMP
    1: PresShell::ClearFrameRefs(nsIFrame* aFrame)
    1: {
    1:   mPresContext->EventStateManager()->ClearFrameRefs(aFrame);
    1:   
    1:   if (aFrame == mCurrentEventFrame) {
    1:     mCurrentEventContent = aFrame->GetContent();
    1:     mCurrentEventFrame = nsnull;
    1:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   if (aFrame == mDrawEventTargetFrame) {
    1:     mDrawEventTargetFrame = nsnull;
    1:   }
    1: #endif
    1: 
    1:   for (int i=0; i<mCurrentEventFrameStack.Count(); i++) {
    1:     if (aFrame == (nsIFrame*)mCurrentEventFrameStack.ElementAt(i)) {
    1:       //One of our stack frames was deleted.  Get its content so that when we
    1:       //pop it we can still get its new frame from its content
    1:       nsIContent *currentEventContent = aFrame->GetContent();
    1:       mCurrentEventContentStack.ReplaceObjectAt(currentEventContent, i);
    1:       mCurrentEventFrameStack.ReplaceElementAt(nsnull, i);
    1:     }
    1:   }
    1: 
    1:   nsWeakFrame* weakFrame = mWeakFrames;
    1:   while (weakFrame) {
    1:     nsWeakFrame* prev = weakFrame->GetPreviousWeakFrame();
    1:     if (weakFrame->GetFrame() == aFrame) {
    1:       // This removes weakFrame from mWeakFrames.
    1:       weakFrame->Clear(this);
    1:     }
    1:     weakFrame = prev;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CreateRenderingContext(nsIFrame *aFrame,
    1:                                   nsIRenderingContext** aResult)
    1: {
    1:   NS_PRECONDITION(nsnull != aResult, "null ptr");
    1:   if (nsnull == aResult) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   nsIWidget* widget = nsnull;
    1:   nsPoint offset(0,0);
    1:   if (mPresContext->IsScreen()) {
    1:     // Get the widget to create the rendering context for and calculate
    1:     // the offset from the frame to it.  (Calculating the offset is important
    1:     // if the frame isn't the root frame.)
    1:     nsPoint viewOffset;
    1:     nsIView* view = aFrame->GetClosestView(&viewOffset);
    1:     nsPoint widgetOffset;
    1:     widget = view->GetNearestWidget(&widgetOffset);
    1:     offset = viewOffset + widgetOffset;
    1:   } else {
    1:     nsIFrame* pageFrame = nsLayoutUtils::GetPageFrame(aFrame);
    1:     // This might not always come up with a frame, i.e. during reflow;
    1:     // that's fine, because the translation doesn't matter during reflow.
    1:     if (pageFrame)
    1:       offset = aFrame->GetOffsetTo(pageFrame);
    1:   }
    1: 
    1:   nsresult rv;
    1:   nsIRenderingContext* result = nsnull;
    1:   nsIDeviceContext *deviceContext = mPresContext->DeviceContext();
    1:   if (widget) {
    1:     rv = deviceContext->CreateRenderingContext(widget, result);
    1:   }
    1:   else {
    1:     rv = deviceContext->CreateRenderingContext(result);
    1:   }
    1:   *aResult = result;
    1: 
 1390:   if (NS_SUCCEEDED(rv)) {
    1:     result->Translate(offset.x, offset.y);
 1390:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GoToAnchor(const nsAString& aAnchorName, PRBool aScroll)
    1: {
    1:   if (!mDocument) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
    1:   // Hold a reference to the ESM in case event dispatch tears us down.
    1:   nsCOMPtr<nsIEventStateManager> esm = mPresContext->EventStateManager();
    1: 
    1:   if (aAnchorName.IsEmpty()) {
    1:     NS_ASSERTION(!aScroll, "can't scroll to empty anchor name");
    1:     esm->SetContentState(nsnull, NS_EVENT_STATE_URLTARGET);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(mDocument);
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIContent> content;
    1: 
    1:   // Search for an element with a matching "id" attribute
    1:   if (doc) {    
    1:     nsCOMPtr<nsIDOMElement> element;
    1:     rv = doc->GetElementById(aAnchorName, getter_AddRefs(element));
    1:     if (NS_SUCCEEDED(rv) && element) {
    1:       // Get the nsIContent interface, because that's what we need to
    1:       // get the primary frame
    1:       content = do_QueryInterface(element);
    1:     }
    1:   }
    1: 
    1:   // Search for an anchor element with a matching "name" attribute
    1:   if (!content && htmlDoc) {
    1:     nsCOMPtr<nsIDOMNodeList> list;
    1:     // Find a matching list of named nodes
    1:     rv = htmlDoc->GetElementsByName(aAnchorName, getter_AddRefs(list));
    1:     if (NS_SUCCEEDED(rv) && list) {
    1:       PRUint32 i;
    1:       // Loop through the named nodes looking for the first anchor
    1:       for (i = 0; PR_TRUE; i++) {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         rv = list->Item(i, getter_AddRefs(node));
    1:         if (!node) {  // End of list
    1:           break;
    1:         }
    1:         // Ensure it's an anchor element
    1:         content = do_QueryInterface(node);
    1:         if (content) {
    1:           if (content->Tag() == nsGkAtoms::a &&
    1:               content->IsNodeOfType(nsINode::eHTML)) {
    1:             break;
    1:           }
    1:           content = nsnull;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Search for anchor in the HTML namespace with a matching name
    1:   if (!content && !htmlDoc)
    1:   {
    1:     nsCOMPtr<nsIDOMNodeList> list;
    1:     NS_NAMED_LITERAL_STRING(nameSpace, "http://www.w3.org/1999/xhtml");
    1:     // Get the list of anchor elements
    1:     rv = doc->GetElementsByTagNameNS(nameSpace, NS_LITERAL_STRING("a"), getter_AddRefs(list));
    1:     if (NS_SUCCEEDED(rv) && list) {
    1:       PRUint32 i;
    1:       // Loop through the named nodes looking for the first anchor
    1:       for (i = 0; PR_TRUE; i++) {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         rv = list->Item(i, getter_AddRefs(node));
    1:         if (!node) { // End of list
    1:           break;
    1:         }
    1:         // Compare the name attribute
    1:         nsCOMPtr<nsIDOMElement> element = do_QueryInterface(node);
    1:         nsAutoString value;
    1:         if (element && NS_SUCCEEDED(element->GetAttribute(NS_LITERAL_STRING("name"), value))) {
    1:           if (value.Equals(aAnchorName)) {
    1:             content = do_QueryInterface(element);
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMRange> jumpToRange;
    1:   nsCOMPtr<nsIXPointerResult> xpointerResult;
    1:   if (!content) {
    1:     nsCOMPtr<nsIDOMXMLDocument> xmldoc = do_QueryInterface(mDocument);
    1:     if (xmldoc) {
    1:       // Try XPointer
    1:       xmldoc->EvaluateXPointer(aAnchorName, getter_AddRefs(xpointerResult));
    1:       if (xpointerResult) {
    1:         xpointerResult->Item(0, getter_AddRefs(jumpToRange));
    1:         if (!jumpToRange) {
    1:           // We know it was an XPointer, so there is no point in
    1:           // trying any other pointer types, let's just return
    1:           // an error.
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:       }
    1: 
    1:       // Finally try FIXptr
    1:       if (!jumpToRange) {
    1:         xmldoc->EvaluateFIXptr(aAnchorName,getter_AddRefs(jumpToRange));
    1:       }
    1: 
    1:       if (jumpToRange) {
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         jumpToRange->GetStartContainer(getter_AddRefs(node));
    1:         if (node) {
    1:           PRUint16 nodeType;
    1:           node->GetNodeType(&nodeType);
    1:           PRInt32 offset = -1;
    1:           jumpToRange->GetStartOffset(&offset);
    1:           switch (nodeType) {
    1:             case nsIDOMNode::ATTRIBUTE_NODE:
    1:             {
    1:               // XXX Assuming jumping to the ownerElement is the sanest action.
    1:               nsCOMPtr<nsIAttribute> attr = do_QueryInterface(node);
    1:               content = attr->GetContent();
    1:               break;
    1:             }
    1:             case nsIDOMNode::DOCUMENT_NODE:
    1:             {
    1:               if (offset >= 0) {
    1:                 nsCOMPtr<nsIDocument> document = do_QueryInterface(node);
    1:                 content = document->GetChildAt(offset);
    1:               }
    1:               break;
    1:             }
    1:             case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:             case nsIDOMNode::ELEMENT_NODE:
    1:             case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:             {
    1:               if (offset >= 0) {
    1:                 nsCOMPtr<nsIContent> parent = do_QueryInterface(node);
    1:                 content = parent->GetChildAt(offset);
    1:               }
    1:               break;
    1:             }
    1:             case nsIDOMNode::CDATA_SECTION_NODE:
    1:             case nsIDOMNode::COMMENT_NODE:
    1:             case nsIDOMNode::TEXT_NODE:
    1:             case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:             {
    1:               // XXX This should scroll to a specific position in the text.
    1:               content = do_QueryInterface(node);
    1:               break;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   esm->SetContentState(content, NS_EVENT_STATE_URLTARGET);
    1: 
    1:   if (content) {
    1:     if (aScroll) {
    1:       rv = ScrollContentIntoView(content, NS_PRESSHELL_SCROLL_TOP,
    1:                                  NS_PRESSHELL_SCROLL_ANYWHERE);
    1:       NS_ENSURE_SUCCESS(rv, rv);
12356: 
12356:       nsIScrollableFrame* rootScroll = GetRootScrollFrameAsScrollable();
12356:       if (rootScroll) {
12356:         mLastAnchorScrolledTo = content;
12356:         mLastAnchorScrollPositionY = rootScroll->GetScrollPosition().y;
12356:       }
    1:     }
    1: 
    1:     // Should we select the target? This action is controlled by a
    1:     // preference: the default is to not select.
    1:     PRBool selectAnchor = nsContentUtils::GetBoolPref("layout.selectanchor");
    1: 
    1:     // Even if select anchor pref is false, we must still move the
    1:     // caret there. That way tabbing will start from the new
    1:     // location
    1:     if (!jumpToRange) {
    1:       jumpToRange = do_CreateInstance(kRangeCID);
    1:       if (jumpToRange) {
    1:         while (content && content->GetChildCount() > 0) {
    1:           content = content->GetChildAt(0);
    1:         }
    1:         nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));
    1:         NS_ASSERTION(node, "No nsIDOMNode for descendant of anchor");
    1:         jumpToRange->SelectNodeContents(node);
    1:       }
    1:     }
    1:     if (jumpToRange) {
    1:       // Select the anchor
    1:       nsISelection* sel = mSelection->
    1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:       if (sel) {
    1:         sel->RemoveAllRanges();
    1:         sel->AddRange(jumpToRange);
    1:         if (!selectAnchor) {
    1:           // Use a caret (collapsed selection) at the start of the anchor
    1:           sel->CollapseToStart();
    1:         }
    1:       }  
    1: 
    1:       if (selectAnchor && xpointerResult) {
    1:         // Select the rest (if any) of the ranges in XPointerResult
    1:         PRUint32 count, i;
    1:         xpointerResult->GetLength(&count);
    1:         for (i = 1; i < count; i++) { // jumpToRange is i = 0
    1:           nsCOMPtr<nsIDOMRange> range;
    1:           xpointerResult->Item(i, getter_AddRefs(range));
    1:           sel->AddRange(range);
    1:         }
    1:       }
    1:       // Selection is at anchor.
    1:       // Now focus the document itself if focus is on an element within it.
    1:       nsPIDOMWindow *win = mDocument->GetWindow();
    1: 
    1:       if (win) {
    1:         nsCOMPtr<nsIFocusController> focusController = win->GetRootFocusController();
    1:         if (focusController) {
    1:           nsCOMPtr<nsIDOMWindowInternal> focusedWin;
    1:           focusController->GetFocusedWindow(getter_AddRefs(focusedWin));
    1:           if (SameCOMIdentity(win, focusedWin)) {
    1:             esm->ChangeFocusWith(nsnull, nsIEventStateManager::eEventFocusedByApplication);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   } else {
    1:     rv = NS_ERROR_FAILURE; //changed to NS_OK in quirks mode if ScrollTo is called
    1:     
    1:     // Scroll to the top/left if the anchor can not be
    1:     // found and it is labelled top (quirks mode only). @see bug 80784
    1:     if ((NS_LossyConvertUTF16toASCII(aAnchorName).LowerCaseEqualsLiteral("top")) &&
    1:         (mPresContext->CompatibilityMode() == eCompatibility_NavQuirks)) {
    1:       rv = NS_OK;
    1:       // Check |aScroll| after setting |rv| so we set |rv| to the same
    1:       // thing whether or not |aScroll| is true.
    1:       if (aScroll && mViewManager) {
    1:         // Get the viewport scroller
    1:         nsIScrollableView* scrollingView;
    1:         mViewManager->GetRootScrollableView(&scrollingView);
    1:         if (scrollingView) {
    1:           // Scroll to the top of the page
21290:           scrollingView->ScrollTo(0, 0, 0);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
12356: NS_IMETHODIMP
12356: PresShell::ScrollToAnchor()
12356: {
12356:   if (!mLastAnchorScrolledTo)
12356:     return NS_OK;
12356: 
12356:   nsIScrollableFrame* rootScroll = GetRootScrollFrameAsScrollable();
12356:   if (!rootScroll ||
12356:       mLastAnchorScrollPositionY != rootScroll->GetScrollPosition().y)
12356:     return NS_OK;
12356: 
12356:   nsresult rv = ScrollContentIntoView(mLastAnchorScrolledTo, NS_PRESSHELL_SCROLL_TOP,
12356:                                       NS_PRESSHELL_SCROLL_ANYWHERE);
12356:   mLastAnchorScrolledTo = nsnull;
12356:   return rv;
12356: }
12356: 
 3508: /*
 3508:  * Helper (per-continuation) for ScrollContentIntoView.
 3508:  *
 3508:  * @param aFrame [in] Frame whose bounds should be unioned
 3508:  * @param aVPercent [in] same as for ScrollContentIntoView
 3508:  * @param aRect [inout] rect into which its bounds should be unioned
 3510:  * @param aHaveRect [inout] whether aRect contains data yet
 3508:  * @param aClosestScrolledView [inout] the view to which aRect is relative.
 3508:  *   If null, should be filled in appropriately.  If non-null, the function
 3508:  *   will no-op if the closest scrolling view doesn't match.
 3508:  */
 3508: static void
 3508: UnionRectForClosestScrolledView(nsIFrame* aFrame,
 3508:                                 PRIntn aVPercent,
 3508:                                 nsRect& aRect,
 3510:                                 PRBool& aHaveRect,
 3508:                                 nsIView*& aClosestScrolledView)
 3508: {
 3508:   nsRect  frameBounds = aFrame->GetRect();
 3508:   nsPoint offset;
 3508:   nsIView* closestView;
 3508:   aFrame->GetOffsetFromView(offset, &closestView);
 3508:   frameBounds.MoveTo(offset);
 3508: 
 3508:   // If this is an inline frame and either the bounds height is 0 (quirks
 3508:   // layout model) or aVPercent is not NS_PRESSHELL_SCROLL_ANYWHERE, we need to
 3508:   // change the top of the bounds to include the whole line.
 3508:   if (frameBounds.height == 0 || aVPercent != NS_PRESSHELL_SCROLL_ANYWHERE) {
 3508:     nsIAtom* frameType = NULL;
 3508:     nsIFrame *prevFrame = aFrame;
 3508:     nsIFrame *f = aFrame;
 3508: 
 3508:     while (f &&
 3508:            (frameType = f->GetType()) == nsGkAtoms::inlineFrame) {
 3508:       prevFrame = f;
 3508:       f = prevFrame->GetParent();
 3508:     }
 3508: 
 3508:     if (f != aFrame &&
 3508:         f &&
 3508:         frameType == nsGkAtoms::blockFrame) {
 3508:       // find the line containing aFrame and increase the top of |offset|.
21112:       nsAutoLineIterator lines = f->GetLineIterator();
 3508:       if (lines) {
21112:         PRInt32 index = lines->FindLineContaining(prevFrame);
 3508:         if (index >= 0) {
 3508:           nsIFrame *trash1;
 3508:           PRInt32 trash2;
 3508:           nsRect lineBounds;
 3508:           PRUint32 trash3;
 3508: 
 3508:           if (NS_SUCCEEDED(lines->GetLine(index, &trash1, &trash2,
 3508:                                           lineBounds, &trash3))) {
 3508:             nsPoint blockOffset;
 3508:             nsIView* blockView;
 3508:             f->GetOffsetFromView(blockOffset, &blockView);
 3508: 
 3508:             if (blockView == closestView) {
 3508:               // XXX If views not equal, this is hard.  Do we want to bother?
 3508:               nscoord newoffset = lineBounds.y + blockOffset.y;
 3508: 
 3508:               if (newoffset < frameBounds.y)
 3508:                 frameBounds.y = newoffset;
 3508:             }
 3508:           }
 3508:         }
 3508:       }
 3508:     }
 3508:   }
 3508: 
 3508:   NS_ASSERTION(closestView && !closestView->ToScrollableView(),
 3508:                "What happened to the scrolled view?  "
 3508:                "The frame should not be directly in the scrolling view!");
 3508:   
 3508:   // Walk up the view hierarchy.  Make sure to add the view's position
 3508:   // _after_ we get the parent and see whether it's scrollable.  We want to
 3508:   // make sure to get the scrolled view's position after it has been scrolled.
 3508:   while (closestView) {
 3508:     nsIView* parent = closestView->GetParent();
 3508:     if (parent && parent->ToScrollableView())
 3508:       break;
 3508:     frameBounds += closestView->GetPosition();
 3508:     closestView = parent;
 3508:   }
 3508: 
 3508:   if (!aClosestScrolledView)
 3508:     aClosestScrolledView = closestView;
 3508: 
 3508:   if (aClosestScrolledView == closestView) {
 3510:     if (aHaveRect) {
 3510:       // We can't use nsRect::UnionRect since it drops empty rects on
 3510:       // the floor, and we need to include them.  (Thus we need
 3510:       // aHaveRect to know when to drop the initial value on the floor.)
12354:       aRect.UnionRectIncludeEmpty(aRect, frameBounds);
 3510:     } else {
 3510:       aHaveRect = PR_TRUE;
 3510:       aRect = frameBounds;
 3510:     }
 3508:   }
 3508: }
 3508: 
    1: /**
    1:  * This function takes a scrolling view, a rect, and a scroll position and
    1:  * attempts to scroll that rect to that position in that view.  The rect
    1:  * should be in the coordinate system of the _scrolled_ view.
    1:  */
    1: static void ScrollViewToShowRect(nsIScrollableView* aScrollingView,
    1:                                  nsRect &           aRect,
    1:                                  PRIntn             aVPercent,
    1:                                  PRIntn             aHPercent)
    1: {
    1:   // Determine the visible rect in the scrolling view's coordinate space.
    1:   // The size of the visible area is the clip view size
    1:   nsRect visibleRect = aScrollingView->View()->GetBounds(); // get width and height
    1:   aScrollingView->GetScrollPosition(visibleRect.x, visibleRect.y);
    1: 
    1:   // The actual scroll offsets
    1:   nscoord scrollOffsetX = visibleRect.x;
    1:   nscoord scrollOffsetY = visibleRect.y;
    1: 
    1:   nscoord lineHeight;
    1:   aScrollingView->GetLineHeight(&lineHeight);
    1:   
    1:   // See how the rect should be positioned vertically
    1:   if (NS_PRESSHELL_SCROLL_ANYWHERE == aVPercent ||
    1:       (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aVPercent &&
    1:        aRect.height < lineHeight)) {
    1:     // The caller doesn't care where the frame is positioned vertically,
    1:     // so long as it's fully visible
    1:     if (aRect.y < visibleRect.y) {
    1:       // Scroll up so the frame's top edge is visible
    1:       scrollOffsetY = aRect.y;
    1:     } else if (aRect.YMost() > visibleRect.YMost()) {
    1:       // Scroll down so the frame's bottom edge is visible. Make sure the
    1:       // frame's top edge is still visible
    1:       scrollOffsetY += aRect.YMost() - visibleRect.YMost();
    1:       if (scrollOffsetY > aRect.y) {
    1:         scrollOffsetY = aRect.y;
    1:       }
    1:     }
    1:   } else if (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aVPercent) {
    1:     // Scroll only if no part of the frame is visible in this view
    1:     if (aRect.YMost() - lineHeight < visibleRect.y) {
    1:       // Scroll up so the frame's top edge is visible
    1:       scrollOffsetY = aRect.y;
    1:     }  else if (aRect.y + lineHeight > visibleRect.YMost()) {
    1:       // Scroll down so the frame's bottom edge is visible. Make sure the
    1:       // frame's top edge is still visible
    1:       scrollOffsetY += aRect.YMost() - visibleRect.YMost();
    1:       if (scrollOffsetY > aRect.y) {
    1:         scrollOffsetY = aRect.y;
    1:       }
    1:     }
    1:   } else {
    1:     // Align the frame edge according to the specified percentage
    1:     nscoord frameAlignY =
    1:       NSToCoordRound(aRect.y + aRect.height * (aVPercent / 100.0f));
    1:     scrollOffsetY =
    1:       NSToCoordRound(frameAlignY - visibleRect.height * (aVPercent / 100.0f));
    1:   }
    1: 
    1:   // See how the frame should be positioned horizontally
    1:   if (NS_PRESSHELL_SCROLL_ANYWHERE == aHPercent ||
    1:       (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aHPercent &&
    1:        aRect.width < lineHeight)) {
    1:     // The caller doesn't care where the frame is positioned horizontally,
    1:     // so long as it's fully visible
    1:     if (aRect.x < visibleRect.x) {
    1:       // Scroll left so the frame's left edge is visible
    1:       scrollOffsetX = aRect.x;
    1:     } else if (aRect.XMost() > visibleRect.XMost()) {
    1:       // Scroll right so the frame's right edge is visible. Make sure the
    1:       // frame's left edge is still visible
    1:       scrollOffsetX += aRect.XMost() - visibleRect.XMost();
    1:       if (scrollOffsetX > aRect.x) {
    1:         scrollOffsetX = aRect.x;
    1:       }
    1:     }
    1:   } else if (NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE == aHPercent) {
    1:     // Scroll only if no part of the frame is visible in this view
    1:     // XXXbz using the line height here is odd, but there are no
    1:     // natural dimensions to use here, really....
    1:     if (aRect.XMost() - lineHeight < visibleRect.x) {
    1:       // Scroll left so the frame's left edge is visible
    1:       scrollOffsetX = aRect.x;
    1:     }  else if (aRect.x + lineHeight > visibleRect.XMost()) {
    1:       // Scroll right so the frame's right edge is visible. Make sure the
    1:       // frame's left edge is still visible
    1:       scrollOffsetX += aRect.XMost() - visibleRect.XMost();
    1:       if (scrollOffsetX > aRect.x) {
    1:         scrollOffsetX = aRect.x;
    1:       }
    1:     }
    1:   } else {
    1:     // Align the frame edge according to the specified percentage
    1:     nscoord frameAlignX =
    1:       NSToCoordRound(aRect.x + (aRect.width) * (aHPercent / 100.0f));
    1:     scrollOffsetX =
    1:       NSToCoordRound(frameAlignX - visibleRect.width * (aHPercent / 100.0f));
    1:   }
    1: 
21290:   aScrollingView->ScrollTo(scrollOffsetX, scrollOffsetY, 0);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ScrollContentIntoView(nsIContent* aContent,
    1:                                  PRIntn      aVPercent,
    1:                                  PRIntn      aHPercent) const
    1: {
    1:   nsCOMPtr<nsIContent> content = aContent; // Keep content alive while flushing.
    1:   NS_ENSURE_TRUE(content, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDocument> currentDoc = content->GetCurrentDoc();
    1:   NS_ENSURE_STATE(currentDoc);
    1:   currentDoc->FlushPendingNotifications(Flush_Layout);
    1:   nsIFrame* frame = GetPrimaryFrameFor(content);
    1:   if (!frame) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   // Before we scroll the frame into view, ask the command dispatcher
    1:   // if we're resetting focus because a window just got an activate
    1:   // event. If we are, we do not want to scroll the frame into view.
    1:   // Example: The user clicks on an anchor, and then deactivates the 
    1:   // window. When they reactivate the window, the expected behavior
    1:   // is not for the anchor link to scroll back into view. That is what
    1:   // this check is preventing.
    1:   // XXX: The dependency on the command dispatcher needs to be fixed.
    1:   nsPIDOMWindow* ourWindow = currentDoc->GetWindow();
    1:   if (ourWindow) {
    1:     nsIFocusController *focusController = ourWindow->GetRootFocusController();
    1:     if (focusController) {
    1:       PRBool dontScroll = PR_FALSE;
    1:       focusController->GetSuppressFocusScroll(&dontScroll);
    1:       if (dontScroll) {
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // This is a two-step process.
    1:   // Step 1: Find the bounds of the rect we want to scroll into view.  For
    1:   //         example, for an inline frame we may want to scroll in the whole
    1:   //         line.
    1:   // Step 2: Walk the views that are parents of the frame and scroll them
    1:   //         appropriately.
    1:   
 3508:   nsIView *closestView = nsnull;
 3508:   nsRect frameBounds;
 3510:   PRBool haveRect = PR_FALSE;
 3508:   do {
 3510:     UnionRectForClosestScrolledView(frame, aVPercent, frameBounds, haveRect,
 3510:                                     closestView);
 3508:   } while ((frame = frame->GetNextContinuation()));
    1: 
    1:   // Walk up the view hierarchy.  Make sure to add the view's position
    1:   // _after_ we get the parent and see whether it's scrollable.  We want to
    1:   // make sure to get the scrolled view's position after it has been scrolled.
    1:   nsIScrollableView* scrollingView = nsnull;
    1:   while (closestView) {
    1:     nsIView* parent = closestView->GetParent();
    1:     if (parent) {
    1:       scrollingView = parent->ToScrollableView();
    1:       if (scrollingView) {
    1:         ScrollViewToShowRect(scrollingView, frameBounds, aVPercent, aHPercent);
    1:       }
    1:     }
 3421:     frameBounds += closestView->GetPosition();
    1:     closestView = parent;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // GetLinkLocation: copy link location to clipboard
    1: NS_IMETHODIMP PresShell::GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocationString)
    1: {
    1: #ifdef DEBUG_dr
    1:   printf("dr :: PresShell::GetLinkLocation\n");
    1: #endif
    1: 
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1:   nsresult rv;
    1:   nsAutoString anchorText;
    1:   static char strippedChars[] = {'\t','\r','\n'};
    1: 
    1:   // are we an anchor?
    1:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(aNode));
    1:   nsCOMPtr<nsIDOMHTMLAreaElement> area;
    1:   nsCOMPtr<nsIDOMHTMLLinkElement> link;
    1:   nsAutoString xlinkType;
    1:   if (anchor) {
    1:     rv = anchor->GetHref(anchorText);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     // area?
    1:     area = do_QueryInterface(aNode);
    1:     if (area) {
    1:       rv = area->GetHref(anchorText);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     } else {
    1:       // link?
    1:       link = do_QueryInterface(aNode);
    1:       if (link) {
    1:         rv = link->GetHref(anchorText);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       } else {
    1:         // Xlink?
    1:         nsCOMPtr<nsIDOMElement> element(do_QueryInterface(aNode));
    1:         if (element) {
    1:           NS_NAMED_LITERAL_STRING(xlinkNS,"http://www.w3.org/1999/xlink");
    1:           element->GetAttributeNS(xlinkNS,NS_LITERAL_STRING("type"),xlinkType);
    1:           if (xlinkType.EqualsLiteral("simple")) {
    1:             element->GetAttributeNS(xlinkNS,NS_LITERAL_STRING("href"),anchorText);
    1:             if (!anchorText.IsEmpty()) {
    1:               // Resolve the full URI using baseURI property
    1: 
    1:               nsAutoString base;
    1:               nsCOMPtr<nsIDOM3Node> node(do_QueryInterface(aNode,&rv));
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1:               node->GetBaseURI(base);
    1: 
    1:               nsCOMPtr<nsIIOService>
    1:                 ios(do_GetService("@mozilla.org/network/io-service;1", &rv));
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:               nsCOMPtr<nsIURI> baseURI;
    1:               rv = ios->NewURI(NS_ConvertUTF16toUTF8(base),nsnull,nsnull,getter_AddRefs(baseURI));
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:               nsCAutoString spec;
    1:               rv = baseURI->Resolve(NS_ConvertUTF16toUTF8(anchorText),spec);
    1:               NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:               CopyUTF8toUTF16(spec, anchorText);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (anchor || area || link || xlinkType.EqualsLiteral("simple")) {
    1:     //Remove all the '\t', '\r' and '\n' from 'anchorText'
    1:     anchorText.StripChars(strippedChars);
    1: 
    1:     aLocationString = anchorText;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if no link, fail.
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetSelectionForCopy(nsISelection** outSelection)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   *outSelection = nsnull;
    1: 
    1:   if (!mDocument) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   nsPIDOMWindow *ourWindow = mDocument->GetWindow();
    1:   if (ourWindow) {
    1:     nsIFocusController *focusController = ourWindow->GetRootFocusController();
    1:     if (focusController) {
    1:       nsCOMPtr<nsIDOMElement> focusedElement;
    1:       focusController->GetFocusedElement(getter_AddRefs(focusedElement));
    1:       content = do_QueryInterface(focusedElement);
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsISelection> sel;
    1:   if (content)
    1:   {
    1:     //check to see if we need to get selection from frame
    1:     //optimization that MAY need to be expanded as more things implement their own "selection"
    1:     nsCOMPtr<nsIDOMNSHTMLInputElement>    htmlInputElement(do_QueryInterface(content));
    1:     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> htmlTextAreaElement(do_QueryInterface(content));
    1:     if (htmlInputElement || htmlTextAreaElement)
    1:     {
    1:       nsIFrame *htmlInputFrame = GetPrimaryFrameFor(content);
    1:       if (!htmlInputFrame) return NS_ERROR_FAILURE;
    1: 
    1:       nsCOMPtr<nsISelectionController> selCon;
    1:       rv = htmlInputFrame->
    1:         GetSelectionController(mPresContext,getter_AddRefs(selCon));
    1:       if (NS_FAILED(rv)) return rv;
    1:       if (!selCon) return NS_ERROR_FAILURE;
    1: 
    1:       rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                                 getter_AddRefs(sel));
    1:     }
    1:   }
    1:   if (!sel) {
    1:     sel = mSelection->GetSelection(nsISelectionController::SELECTION_NORMAL);
    1:     rv = NS_OK;
    1:   }
    1: 
    1:   *outSelection = sel;
    1:   NS_IF_ADDREF(*outSelection);
    1:   return rv;
    1: }
    1: 
19214: /* Just hook this call into InvalidateOverflowRect */
19214: void
19214: PresShell::InvalidateFrameForView(nsIView *aView)
19214: {
19214:   nsIFrame* frame = nsLayoutUtils::GetFrameFor(aView);
19214:   if (frame)
19214:     frame->InvalidateOverflowRect();
19214: }
    1: 
22471: NS_IMETHODIMP_(void)
22471: PresShell::DispatchSynthMouseMove(nsGUIEvent *aEvent,
22471:                                   PRBool aFlushOnHoverChange)
22471: {
22471:   PRUint32 hoverGenerationBefore = mFrameConstructor->GetHoverGeneration();
22471:   nsEventStatus status;
22471:   mViewManager->DispatchEvent(aEvent, &status);
22471:   if (aFlushOnHoverChange &&
22471:       hoverGenerationBefore != mFrameConstructor->GetHoverGeneration()) {
22471:     // Flush so that the resulting reflow happens now so that our caller
22471:     // can suppress any synthesized mouse moves caused by that reflow.
22471:     FlushPendingNotifications(Flush_Layout);
22471:   }
22471: }
22471: 
    1: NS_IMETHODIMP
    1: PresShell::DoGetContents(const nsACString& aMimeType, PRUint32 aFlags, PRBool aSelectionOnly, nsAString& aOutValue)
    1: {
    1:   aOutValue.Truncate();
    1:   
    1:   if (!mDocument) return NS_ERROR_FAILURE;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsISelection> sel;
    1: 
    1:   // Now we have the selection.  Make sure it's nonzero:
    1:   if (aSelectionOnly)
    1:   {
    1:     rv = GetSelectionForCopy(getter_AddRefs(sel));
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (!sel) return NS_ERROR_FAILURE;
    1:   
    1:     PRBool isCollapsed;
    1:     sel->GetIsCollapsed(&isCollapsed);
    1:     if (isCollapsed)
    1:       return NS_OK;
    1:   }
    1:   
    1:   // call the copy code
    1:   return nsCopySupport::GetContents(aMimeType, aFlags, sel,
    1:                                     mDocument, aOutValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::DoCopy()
    1: {
    1:   if (!mDocument) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsISelection> sel;
    1:   nsresult rv = GetSelectionForCopy(getter_AddRefs(sel));
    1:   if (NS_FAILED(rv)) 
    1:     return rv;
    1:   if (!sel) 
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Now we have the selection.  Make sure it's nonzero:
    1:   PRBool isCollapsed;
    1:   sel->GetIsCollapsed(&isCollapsed);
    1:   if (isCollapsed)
    1:     return NS_OK;
    1: 
    1:   // call the copy code
    1:   rv = nsCopySupport::HTMLCopy(sel, mDocument, nsIClipboard::kGlobalClipboard);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // Now that we have copied, update the Paste menu item
    1:   nsPIDOMWindow *domWindow = mDocument->GetWindow();
    1:   if (domWindow)
    1:   {
    1:     domWindow->UpdateCommands(NS_LITERAL_STRING("clipboard"));
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CaptureHistoryState(nsILayoutHistoryState** aState, PRBool aLeavingPage)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   NS_PRECONDITION(nsnull != aState, "null state pointer");
    1: 
    1:   // We actually have to mess with the docshell here, since we want to
    1:   // store the state back in it.
    1:   // XXXbz this isn't really right, since this is being called in the
    1:   // content viewer's Hide() method...  by that point the docshell's
    1:   // state could be wrong.  We should sort out a better ownership
    1:   // model for the layout history state.
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   if (!container)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
    1:   if (!docShell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsILayoutHistoryState> historyState;
    1:   docShell->GetLayoutHistoryState(getter_AddRefs(historyState));
    1:   if (!historyState) {
    1:     // Create the document state object
    1:     rv = NS_NewLayoutHistoryState(getter_AddRefs(historyState));
    1:   
    1:     if (NS_FAILED(rv)) { 
    1:       *aState = nsnull;
    1:       return rv;
    1:     }    
    1: 
    1:     docShell->SetLayoutHistoryState(historyState);
    1:   }
    1: 
    1:   *aState = historyState;
    1:   NS_IF_ADDREF(*aState);
    1:   
    1:   // Capture frame state for the entire frame hierarchy
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   if (!rootFrame) return NS_OK;
    1:   // Capture frame state for the root scroll frame
    1:   // Don't capture state when first creating doc element hierarchy
    1:   // As the scroll position is 0 and this will cause us to loose
    1:   // our previously saved place!
    1:   if (aLeavingPage) {
    1:     nsIFrame* scrollFrame = GetRootScrollFrame();
    1:     if (scrollFrame) {
    1:       FrameManager()->CaptureFrameStateFor(scrollFrame, historyState,
    1:                                            nsIStatefulFrame::eDocumentScrollState);
    1:     }
    1:   }
    1: 
    1:   FrameManager()->CaptureFrameState(rootFrame, historyState);  
    1:  
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::IsPaintingSuppressed(PRBool* aResult)
    1: {
    1:   *aResult = mPaintingSuppressed;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: PresShell::UnsuppressAndInvalidate()
    1: {
    1:   if (!mPresContext->EnsureVisible(PR_FALSE)) {
    1:     // No point; we're about to be torn down anyway.
    1:     return;
    1:   }
    1:   
    1:   mPaintingSuppressed = PR_FALSE;
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:   if (rootFrame) {
    1:     // let's assume that outline on a root frame is not supported
    1:     nsRect rect(nsPoint(0, 0), rootFrame->GetSize());
19380:     rootFrame->Invalidate(rect);
    1:   }
    1: 
    1:   // This makes sure to get the same thing that nsPresContext::EnsureVisible()
    1:   // got.
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   nsCOMPtr<nsPIDOMWindow> ourWindow = do_GetInterface(container);
    1:   nsCOMPtr<nsIFocusController> focusController =
    1:     ourWindow ? ourWindow->GetRootFocusController() : nsnull;
    1: 
    1:   if (ourWindow)
    1:     CheckForFocus(ourWindow, focusController, mDocument);
    1: 
    1:   if (focusController) // Unsuppress now that we've shown the new window and focused it.
    1:     focusController->SetSuppressFocus(PR_FALSE, "PresShell suppression on Web page loads");
    1: 
    1:   if (mViewManager)
    1:     mViewManager->SynthesizeMouseMove(PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::UnsuppressPainting()
    1: {
    1:   if (mPaintSuppressionTimer) {
    1:     mPaintSuppressionTimer->Cancel();
    1:     mPaintSuppressionTimer = nsnull;
    1:   }
    1: 
    1:   if (mIsDocumentGone || !mPaintingSuppressed)
    1:     return NS_OK;
    1: 
    1:   // If we have reflows pending, just wait until we process
    1:   // the reflows and get all the frames where we want them
    1:   // before actually unlocking the painting.  Otherwise
    1:   // go ahead and unlock now.
    1:   if (mDirtyRoots.Count() > 0)
    1:     mShouldUnsuppressPainting = PR_TRUE;
    1:   else
    1:     UnsuppressAndInvalidate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::DisableThemeSupport()
    1: {
    1:   // Doesn't have to be dynamic.  Just set the bool.
    1:   mIsThemeSupportDisabled = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool 
    1: PresShell::IsThemeSupportEnabled()
    1: {
    1:   return !mIsThemeSupportDisabled;
    1: }
    1: 
    1: // Post a request to handle an arbitrary callback after reflow has finished.
    1: NS_IMETHODIMP
    1: PresShell::PostReflowCallback(nsIReflowCallback* aCallback)
    1: {
    1:   void* result = AllocateFrame(sizeof(nsCallbackEventRequest));
    1:   if (NS_UNLIKELY(!result)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   nsCallbackEventRequest* request = (nsCallbackEventRequest*)result;
    1: 
    1:   request->callback = aCallback;
    1:   request->next = nsnull;
    1: 
    1:   if (mLastCallbackEventRequest) {
    1:     mLastCallbackEventRequest = mLastCallbackEventRequest->next = request;
    1:   } else {
    1:     mFirstCallbackEventRequest = request;
    1:     mLastCallbackEventRequest = request;
    1:   }
    1:  
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::CancelReflowCallback(nsIReflowCallback* aCallback)
    1: {
    1:    nsCallbackEventRequest* before = nsnull;
    1:    nsCallbackEventRequest* node = mFirstCallbackEventRequest;
    1:    while(node)
    1:    {
    1:       nsIReflowCallback* callback = node->callback;
    1: 
    1:       if (callback == aCallback) 
    1:       {
    1:         nsCallbackEventRequest* toFree = node;
    1:         if (node == mFirstCallbackEventRequest) {
    1:           node = node->next;
    1:           mFirstCallbackEventRequest = node;
    1:           NS_ASSERTION(before == nsnull, "impossible");
    1:         } else {
    1:           node = node->next;
    1:           before->next = node;
    1:         }
    1: 
    1:         if (toFree == mLastCallbackEventRequest) {
    1:           mLastCallbackEventRequest = before;
    1:         }
    1: 
    1:         FreeFrame(sizeof(nsCallbackEventRequest), toFree);
    1:       } else {
    1:         before = node;
    1:         node = node->next;
    1:       }
    1:    }
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: void
 8509: PresShell::CancelPostedReflowCallbacks()
 8509: {
 8509:   while (mFirstCallbackEventRequest) {
 8509:     nsCallbackEventRequest* node = mFirstCallbackEventRequest;
 8509:     mFirstCallbackEventRequest = node->next;
 8509:     if (!mFirstCallbackEventRequest) {
 8509:       mLastCallbackEventRequest = nsnull;
 8509:     }
 8509:     nsIReflowCallback* callback = node->callback;
 8509:     FreeFrame(sizeof(nsCallbackEventRequest), node);
 8509:     if (callback) {
 8509:       callback->ReflowCallbackCanceled();
 8509:     }
 8509:   }
 8509: }
 8509: 
 8509: void
    1: PresShell::HandlePostedReflowCallbacks()
    1: {
    1:    PRBool shouldFlush = PR_FALSE;
    1: 
    1:    while (mFirstCallbackEventRequest) {
    1:      nsCallbackEventRequest* node = mFirstCallbackEventRequest;
    1:      mFirstCallbackEventRequest = node->next;
    1:      if (!mFirstCallbackEventRequest) {
    1:        mLastCallbackEventRequest = nsnull;
    1:      }
    1:      nsIReflowCallback* callback = node->callback;
    1:      FreeFrame(sizeof(nsCallbackEventRequest), node);
    1:      if (callback) {
    1:        if (callback->ReflowFinished()) {
    1:          shouldFlush = PR_TRUE;
    1:        }
    1:      }
    1:    }
    1: 
    1:    if (shouldFlush)
    1:      FlushPendingNotifications(Flush_Layout);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::IsSafeToFlush(PRBool& aIsSafeToFlush)
    1: {
22979:   aIsSafeToFlush = nsContentUtils::IsSafeToRunScript();
22979: #ifdef DEBUG
    1:   // Not safe if we are reflowing or in the middle of frame construction
22979:   PRBool isSafeToFlush = !mIsReflowing;
    1:   // Not safe if we are painting
    1:   nsIViewManager* viewManager = GetViewManager();
    1:   if (viewManager) {
    1:     PRBool isPainting = PR_FALSE;
    1:     viewManager->IsPainting(isPainting);
    1:     if (isPainting) {
22979:       isSafeToFlush = PR_FALSE;
22979:     }
22979:   }
22979:   NS_ASSERTION(!aIsSafeToFlush || isSafeToFlush, "Missing a script blocker!");
22979: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: PresShell::FlushPendingNotifications(mozFlushType aType)
    1: {
 4886:   return DoFlushPendingNotifications(aType, PR_FALSE);
 4886: }
 4886: 
 4888: nsresult
 4886: PresShell::DoFlushPendingNotifications(mozFlushType aType,
 4886:                                        PRBool aInterruptibleReflow)
 4886: {
 4886:   NS_ASSERTION(aType >= Flush_Frames, "Why did we get called?");
    1:   
    1:   PRBool isSafeToFlush;
    1:   IsSafeToFlush(isSafeToFlush);
    1: 
    1:   NS_ASSERTION(!isSafeToFlush || mViewManager, "Must have view manager");
 4876:   // Make sure the view manager stays alive while batching view updates.
10730:   nsCOMPtr<nsIViewManager> viewManagerDeathGrip = mViewManager;
10730:   if (isSafeToFlush && mViewManager) {
  721:     // Processing pending notifications can kill us, and some callers only
  721:     // hold weak refs when calling FlushPendingNotifications().  :(
  721:     nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
  721: 
    1:     // Style reresolves not in conjunction with reflows can't cause
    1:     // painting or geometry changes, so don't bother with view update
    1:     // batching if we only have style reresolve
10730:     nsIViewManager::UpdateViewBatch batch(mViewManager);
    1: 
 5623:     // Force flushing of any pending content notifications that might have
 5623:     // queued up while our event was pending.  That will ensure that we don't
 5623:     // construct frames for content right now that's still waiting to be
 5623:     // notified on,
 5623:     mDocument->FlushPendingNotifications(Flush_ContentAndNotify);
 6023: 
 6023:     // Process pending restyles, since any flush of the presshell wants
 6023:     // up-to-date style data.
 5623:     if (!mIsDestroying) {
16226:       mPresContext->FlushPendingMediaFeatureValuesChanged();
16226: 
22507:       // Flush any pending update of the user font set, since that could
22507:       // cause style changes (for updating ex/ch units, and to cause a
22507:       // reflow).
22507:       mPresContext->FlushUserFontSet();
22507: 
    1:       mFrameConstructor->ProcessPendingRestyles();
 5623:     }
 4886: 
 6023:     // Process whatever XBL constructors those restyles queued up.  This
 6023:     // ensures that onload doesn't fire too early and that we won't do extra
 6023:     // reflows after those constructors run.
 5872:     if (!mIsDestroying) {
 5872:       mDocument->BindingManager()->ProcessAttachedQueue();
 5872:     }
 5872: 
 6023:     // Now those constructors might have posted restyle events.  At the same
 6023:     // time, we still need up-to-date style data.  In particular, reflow
 6023:     // depends on style being completely up to date.  If it's not, then style
 6023:     // context reparenting, which can happen during reflow, might suddenly pick
 6023:     // up the new rules and we'll end up with frames whose style doesn't match
 6023:     // the frame type.
 6023:     if (!mIsDestroying) {
 6023:       mFrameConstructor->ProcessPendingRestyles();
 6023:     }
 6023: 
21925: 
 6023:     // There might be more pending constructors now, but we're not going to
 6023:     // worry about them.  They can't be triggered during reflow, so we should
 6023:     // be good.
 6023:     
 4886:     if (aType >= Flush_Layout && !mIsDestroying) {
  550:       mFrameConstructor->RecalcQuotesAndCounters();
19013:       mViewManager->FlushDelayedResize();
 4886:       ProcessReflowCommands(aInterruptibleReflow);
    1:     }
    1: 
    1:     PRUint32 updateFlags = NS_VMREFRESH_NO_SYNC;
 4886:     if (aType >= Flush_Display) {
    1:       // Flushing paints, so perform the invalidates and drawing
    1:       // immediately
    1:       updateFlags = NS_VMREFRESH_IMMEDIATE;
    1:     }
 4886:     else if (aType < Flush_Layout) {
    1:       // Not flushing reflows, so do deferred invalidates.  This will keep us
    1:       // from possibly flushing out reflows due to invalidates being processed
    1:       // at the end of this view batch.
    1:       updateFlags = NS_VMREFRESH_DEFERRED;
    1:     }
10730:     batch.EndUpdateViewBatch(updateFlags);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::IsReflowLocked(PRBool* aIsReflowLocked) 
    1: {
    1:   *aIsReflowLocked = mIsReflowing;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: PresShell::CharacterDataChanged(nsIDocument *aDocument,
    1:                                 nsIContent*  aContent,
    1:                                 CharacterDataChangeInfo* aInfo)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected CharacterDataChanged");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
22979:   nsAutoScriptBlocker scriptBlocker;
13098: 
    1:   if (mCaret) {
    1:     // Invalidate the caret's current location before we call into the frame
    1:     // constructor. It is important to do this now, and not wait until the
    1:     // resulting reflow, because this call causes continuation frames of the
    1:     // text frame the caret is in to forget what part of the content they
    1:     // refer to, making it hard for them to return the correct continuation
    1:     // frame to the caret.
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
11845: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
11845:   nsIContent *container = aContent->GetParent();
11845:   PRUint32 selectorFlags =
11845:     container ? (container->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
16128:   if (selectorFlags != 0 && !aContent->IsRootOfAnonymousSubtree()) {
11845:     PRUint32 index;
11845:     if (aInfo->mAppend &&
11845:         container->GetChildAt((index = container->GetChildCount() - 1)) ==
11845:           aContent)
11845:       mFrameConstructor->RestyleForAppend(container, index);
11845:     else
11845:       mFrameConstructor->RestyleForInsertOrChange(container, aContent);
11845:   }
11845: 
    1:   mFrameConstructor->CharacterDataChanged(aContent, aInfo->mAppend);
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: void
    1: PresShell::ContentStatesChanged(nsIDocument* aDocument,
    1:                                 nsIContent* aContent1,
    1:                                 nsIContent* aContent2,
    1:                                 PRInt32 aStateMask)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentStatesChanged");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
 3410:   if (mDidInitialReflow) {
22979:     nsAutoScriptBlocker scriptBlocker;
    1:     mFrameConstructor->ContentStatesChanged(aContent1, aContent2, aStateMask);
    1:     VERIFY_STYLE_TREE;
    1:   }
 3410: }
    1: 
    1: 
    1: void
    1: PresShell::AttributeChanged(nsIDocument* aDocument,
    1:                             nsIContent*  aContent,
    1:                             PRInt32      aNameSpaceID,
    1:                             nsIAtom*     aAttribute,
 3410:                             PRInt32      aModType,
 3410:                             PRUint32     aStateMask)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected AttributeChanged");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
    1:   // XXXwaterson it might be more elegant to wait until after the
    1:   // initial reflow to begin observing the document. That would
    1:   // squelch any other inappropriate notifications as well.
    1:   if (mDidInitialReflow) {
22979:     nsAutoScriptBlocker scriptBlocker;
    1:     mFrameConstructor->AttributeChanged(aContent, aNameSpaceID,
 3410:                                         aAttribute, aModType, aStateMask);
    1:     VERIFY_STYLE_TREE;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::ContentAppended(nsIDocument *aDocument,
    1:                            nsIContent* aContainer,
    1:                            PRInt32     aNewIndexInContainer)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentAppended");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
11845:   NS_PRECONDITION(aContainer, "must have container");
    1:   
    1:   if (!mDidInitialReflow) {
    1:     return;
    1:   }
    1:   
22979:   nsAutoScriptBlocker scriptBlocker;
    1:   MOZ_TIMER_DEBUGLOG(("Start: Frame Creation: PresShell::ContentAppended(), this=%p\n", this));
    1:   MOZ_TIMER_START(mFrameCreationWatch);
    1: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
11845:   mFrameConstructor->RestyleForAppend(aContainer, aNewIndexInContainer);
11845: 
    1:   mFrameConstructor->ContentAppended(aContainer, aNewIndexInContainer);
    1:   VERIFY_STYLE_TREE;
    1: 
    1:   MOZ_TIMER_DEBUGLOG(("Stop: Frame Creation: PresShell::ContentAppended(), this=%p\n", this));
    1:   MOZ_TIMER_STOP(mFrameCreationWatch);
    1: }
    1: 
    1: void
    1: PresShell::ContentInserted(nsIDocument* aDocument,
    1:                            nsIContent*  aContainer,
    1:                            nsIContent*  aChild,
    1:                            PRInt32      aIndexInContainer)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentInserted");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
    1:   if (!mDidInitialReflow) {
    1:     return;
    1:   }
    1:   
22979:   nsAutoScriptBlocker scriptBlocker;
11845: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
11845:   if (aContainer)
11845:     mFrameConstructor->RestyleForInsertOrChange(aContainer, aChild);
11845: 
    1:   mFrameConstructor->ContentInserted(aContainer, aChild,
 4696:                                      aIndexInContainer, nsnull);
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: void
    1: PresShell::ContentRemoved(nsIDocument *aDocument,
    1:                           nsIContent* aContainer,
    1:                           nsIContent* aChild,
    1:                           PRInt32     aIndexInContainer)
    1: {
    1:   NS_PRECONDITION(!mIsDocumentGone, "Unexpected ContentRemoved");
    1:   NS_PRECONDITION(aDocument == mDocument, "Unexpected aDocument");
    1: 
    1:   // Make sure that the caret doesn't leave a turd where the child used to be.
    1:   if (mCaret) {
    1:     mCaret->InvalidateOutsideCaret();
    1:   }
    1: 
    1:   // Notify the ESM that the content has been removed, so that
    1:   // it can clean up any state related to the content.
    1:   mPresContext->EventStateManager()->ContentRemoved(aChild);
    1: 
22979:   nsAutoScriptBlocker scriptBlocker;
11845: 
11845:   // Call this here so it only happens for real content mutations and
11845:   // not cases when the frame constructor calls its own methods to force
11845:   // frame reconstruction.
11845:   if (aContainer)
11845:     mFrameConstructor->RestyleForRemove(aContainer, aChild, aIndexInContainer);
11845: 
 7681:   PRBool didReconstruct;
    1:   mFrameConstructor->ContentRemoved(aContainer, aChild,
 7681:                                     aIndexInContainer, &didReconstruct);
    1: 
    1:   VERIFY_STYLE_TREE;
    1: }
    1: 
    1: nsresult
    1: PresShell::ReconstructFrames(void)
    1: {
22979:   nsAutoScriptBlocker scriptBlocker;
15817:   mFrameConstructor->BeginUpdate();
13098:   nsresult rv = mFrameConstructor->ReconstructDocElementHierarchy();
    1:   VERIFY_STYLE_TREE;
15817:   mFrameConstructor->EndUpdate();
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsIPresShell::ReconstructStyleDataInternal()
    1: {
    1:   mStylesHaveChanged = PR_FALSE;
    1: 
21925:   if (mIsDestroying) {
21925:     // We don't want to mess with restyles at this point
21925:     return;
21925:   }
21925: 
21925:   if (mPresContext) {
21925:     mPresContext->RebuildUserFontSet();
21925:   }
21925: 
21925:   nsIContent* root = mDocument->GetRootContent();
21920:   if (!mDidInitialReflow) {
21920:     // Nothing to do here, since we have no frames yet
21920:     return;
21920:   }
21920: 
    1:   if (!root) {
    1:     // No content to restyle
    1:     return;
    1:   }
    1:   
    1:   mFrameConstructor->PostRestyleEvent(root, eReStyle_Self, NS_STYLE_HINT_NONE);
    1: 
    1: #ifdef ACCESSIBILITY
    1:   InvalidateAccessibleSubtree(nsnull);
    1: #endif
    1: }
    1: 
    1: void
    1: nsIPresShell::ReconstructStyleDataExternal()
    1: {
    1:   ReconstructStyleDataInternal();
    1: }
    1: 
    1: void
    1: PresShell::StyleSheetAdded(nsIDocument *aDocument,
    1:                            nsIStyleSheet* aStyleSheet,
    1:                            PRBool aDocumentSheet)
    1: {
    1:   // We only care when enabled sheets are added
    1:   NS_PRECONDITION(aStyleSheet, "Must have a style sheet!");
    1:   PRBool applicable;
    1:   aStyleSheet->GetApplicable(applicable);
    1: 
    1:   if (applicable && aStyleSheet->HasRules()) {
    1:     mStylesHaveChanged = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void 
    1: PresShell::StyleSheetRemoved(nsIDocument *aDocument,
    1:                              nsIStyleSheet* aStyleSheet,
    1:                              PRBool aDocumentSheet)
    1: {
    1:   // We only care when enabled sheets are removed
    1:   NS_PRECONDITION(aStyleSheet, "Must have a style sheet!");
    1:   PRBool applicable;
    1:   aStyleSheet->GetApplicable(applicable);
    1:   if (applicable && aStyleSheet->HasRules()) {
    1:     mStylesHaveChanged = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::StyleSheetApplicableStateChanged(nsIDocument *aDocument,
    1:                                             nsIStyleSheet* aStyleSheet,
    1:                                             PRBool aApplicable)
    1: {
    1:   if (aStyleSheet->HasRules()) {
    1:     mStylesHaveChanged = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::StyleRuleChanged(nsIDocument *aDocument,
    1:                             nsIStyleSheet* aStyleSheet,
    1:                             nsIStyleRule* aOldStyleRule,
    1:                             nsIStyleRule* aNewStyleRule)
    1: {
    1:   mStylesHaveChanged = PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::StyleRuleAdded(nsIDocument *aDocument,
    1:                           nsIStyleSheet* aStyleSheet,
    1:                           nsIStyleRule* aStyleRule) 
    1: {
    1:   mStylesHaveChanged = PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::StyleRuleRemoved(nsIDocument *aDocument,
    1:                             nsIStyleSheet* aStyleSheet,
    1:                             nsIStyleRule* aStyleRule) 
    1: {
    1:   mStylesHaveChanged = PR_TRUE;
    1: }
    1: 
    1: nsIFrame*
    1: PresShell::GetPrimaryFrameFor(nsIContent* aContent) const
    1: {
    1:   return FrameManager()->GetPrimaryFrameFor(aContent, -1);
    1: }
    1: 
10998: nsIFrame*
10998: PresShell::GetRealPrimaryFrameFor(nsIContent* aContent) const
10998: {
10998:   nsIFrame *primaryFrame = FrameManager()->GetPrimaryFrameFor(aContent, -1);
10998:   if (!primaryFrame)
10998:     return nsnull;
10998:   return nsPlaceholderFrame::GetRealFrameFor(primaryFrame);
10998: }
10998: 
    1: NS_IMETHODIMP
    1: PresShell::GetPlaceholderFrameFor(nsIFrame*  aFrame,
    1:                                   nsIFrame** aResult) const
    1: {
    1:   *aResult = FrameManager()->GetPlaceholderFrameFor(aFrame);
    1:   return NS_OK;
    1: }
    1: 
    1: //nsIViewObserver
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ComputeRepaintRegionForCopy(nsIView*      aRootView,
    1:                                        nsIView*      aMovingView,
    1:                                        nsPoint       aDelta,
    1:                                        const nsRect& aCopyRect,
    1:                                        nsRegion*     aRepaintRegion)
    1: {
    1:   return nsLayoutUtils::ComputeRepaintRegionForCopy(
 3233:       static_cast<nsIFrame*>(aRootView->GetClientData()),
 3233:       static_cast<nsIFrame*>(aMovingView->GetClientData()),
    1:       aDelta, aCopyRect, aRepaintRegion);
    1: }
    1: 
    1: NS_IMETHODIMP
22950: PresShell::RenderDocument(const nsRect& aRect, PRUint32 aFlags,
    1:                           nscolor aBackgroundColor,
 1735:                           gfxContext* aThebesContext)
 1735: {
22950:   NS_ENSURE_TRUE(!(aFlags & RENDER_IS_UNTRUSTED), NS_ERROR_NOT_IMPLEMENTED);
 1735: 
 7683:   gfxRect r(0, 0,
 7683:             nsPresContext::AppUnitsToFloatCSSPixels(aRect.width),
 7683:             nsPresContext::AppUnitsToFloatCSSPixels(aRect.height));
 7683:   aThebesContext->Save();
20226: 
20226:   aThebesContext->NewPath();
20282: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
20226:   aThebesContext->Rectangle(r, PR_TRUE);
20226: #else
20226:   aThebesContext->Rectangle(r);
20226: #endif
20226:   aThebesContext->Clip();
20226: 
20226:   // we can avoid using a temporary surface if we're using OPERATOR_OVER
20226:   // and our background color has no alpha (so we'll be compositing on top
20226:   // of a fully opaque solid color region)
20226:   PRBool needsGroup = PR_TRUE;
20226:   if (aThebesContext->CurrentOperator() == gfxContext::OPERATOR_OVER &&
20226:       NS_GET_A(aBackgroundColor) == 0xff)
20226:     needsGroup = PR_FALSE;
20226: 
20226:   if (needsGroup) {
 1735:     aThebesContext->PushGroup(NS_GET_A(aBackgroundColor) == 0xff ?
 1735:                               gfxASurface::CONTENT_COLOR :
 1735:                               gfxASurface::CONTENT_COLOR_ALPHA);
 1735: 
 1735:     aThebesContext->Save();
20226:   }
 1735: 
 1735:   // draw background color
 1735:   if (NS_GET_A(aBackgroundColor) > 0) {
 1735:     aThebesContext->SetColor(gfxRGBA(aBackgroundColor));
 1735:     aThebesContext->SetOperator(gfxContext::OPERATOR_SOURCE);
 1735:     aThebesContext->Paint();
 1735:   }
 1735: 
 1735:   // we want the window to be composited as a single image using
20226:   // whatever operator was set; set OPERATOR_OVER here, which is
20226:   // either already the case, or overrides the operator in a group.
20226:   // the original operator will be present when we PopGroup.
 1735:   aThebesContext->SetOperator(gfxContext::OPERATOR_OVER);
    1: 
    1:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
 1735:   if (rootFrame) {
22950:     nsDisplayListBuilder builder(rootFrame, PR_FALSE,
22950:         (aFlags & RENDER_CARET) != 0);
    1:     nsDisplayList list;
 1735: 
 1735:     nsRect rect(aRect);
 1735:     nsIFrame* rootScrollFrame = GetRootScrollFrame();
22950:     if ((aFlags & RENDER_IGNORE_VIEWPORT_SCROLLING) && rootScrollFrame) {
 1735:       nsPoint pos = GetRootScrollFrameAsScrollable()->GetScrollPosition();
 1735:       rect.MoveBy(-pos);
 1735:       builder.SetIgnoreScrollFrame(rootScrollFrame);
 1735:     }
 1735: 
17008:     builder.SetBackgroundOnly(PR_FALSE);
 1735:     builder.EnterPresShell(rootFrame, rect);
 1735: 
 1735:     nsresult rv = rootFrame->BuildDisplayListForStackingContext(&builder, rect, &list);   
 1735: 
 1735:     builder.LeavePresShell(rootFrame, rect);
 1735: 
 1735:     if (NS_SUCCEEDED(rv)) {
 1735:       // Ensure that r.x,r.y gets drawn at (0,0)
 1735:       aThebesContext->Save();
 7683:       aThebesContext->Translate(gfxPoint(-nsPresContext::AppUnitsToFloatCSSPixels(rect.x),
 7683:                                          -nsPresContext::AppUnitsToFloatCSSPixels(rect.y)));
 1735: 
 1735:       nsIDeviceContext* devCtx = mPresContext->DeviceContext();
 7683:       gfxFloat scale = gfxFloat(devCtx->AppUnitsPerDevPixel())/nsPresContext::AppUnitsPerCSSPixel();
 7683:       aThebesContext->Scale(scale, scale);
 7683:       
 1735:       nsCOMPtr<nsIRenderingContext> rc;
 1735:       devCtx->CreateRenderingContextInstance(*getter_AddRefs(rc));
 1735:       rc->Init(devCtx, aThebesContext);
 1735: 
 1735:       nsRegion region(rect);
    1:       list.OptimizeVisibility(&builder, &region);
 1735:       list.Paint(&builder, rc, rect);
    1:       // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
    1:       list.DeleteAll();
    1: 
 1735:       aThebesContext->Restore();
 1735:     }
 1735:   }
 1735: 
20226:   // if we had to use a group, paint it to the destination now
20226:   if (needsGroup) {
 1735:     aThebesContext->Restore();
 1735:     aThebesContext->PopGroupToSource();
 1735:     aThebesContext->Paint();
20226:   }
 1735: 
 7683:   aThebesContext->Restore();
 7683: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Clip the display list aList to a range. Returns the clipped
    1:  * rectangle surrounding the range.
    1:  */
    1: nsRect
    1: PresShell::ClipListToRange(nsDisplayListBuilder *aBuilder,
    1:                            nsDisplayList* aList,
 4741:                            nsIRange* aRange)
    1: {
    1:   // iterate though the display items and add up the bounding boxes of each.
    1:   // This will allow the total area of the frames within the range to be
    1:   // determined. To do this, remove an item from the bottom of the list, check
    1:   // whether it should be part of the range, and if so, append it to the top
    1:   // of the temporary list tmpList. If the item is a text frame at the end of
    1:   // the selection range, wrap it in an nsDisplayClip to clip the display to
    1:   // the portion of the text frame that is part of the selection. Then, append
    1:   // the wrapper to the top of the list. Otherwise, just delete the item and
    1:   // don't append it.
    1:   nsRect surfaceRect;
    1:   nsDisplayList tmpList;
    1: 
    1:   nsDisplayItem* i;
    1:   while ((i = aList->RemoveBottom())) {
    1:     // itemToInsert indiciates the item that should be inserted into the
    1:     // temporary list. If null, no item should be inserted.
    1:     nsDisplayItem* itemToInsert = nsnull;
    1:     nsIFrame* frame = i->GetUnderlyingFrame();
    1:     if (frame) {
    1:       nsIContent* content = frame->GetContent();
    1:       if (content) {
    1:         PRBool atStart = (content == aRange->GetStartParent());
    1:         PRBool atEnd = (content == aRange->GetEndParent());
    1:         if ((atStart || atEnd) && frame->GetType() == nsGkAtoms::textFrame) {
    1:           PRInt32 frameStartOffset, frameEndOffset;
    1:           frame->GetOffsets(frameStartOffset, frameEndOffset);
    1: 
    1:           PRInt32 hilightStart =
    1:             atStart ? PR_MAX(aRange->StartOffset(), frameStartOffset) : frameStartOffset;
    1:           PRInt32 hilightEnd =
    1:             atEnd ? PR_MIN(aRange->EndOffset(), frameEndOffset) : frameEndOffset;
    1:           if (hilightStart < hilightEnd) {
    1:             // determine the location of the start and end edges of the range.
    1:             nsPoint startPoint, endPoint;
 4741:             frame->GetPointFromOffset(hilightStart, &startPoint);
 4741:             frame->GetPointFromOffset(hilightEnd, &endPoint);
    1: 
    1:             // the clip rectangle is determined by taking the the start and
    1:             // end points of the range, offset from the reference frame.
    1:             // Because of rtl, the end point may be to the left of the
    1:             // start point, so x is set to the lowest value
    1:             nsRect textRect(aBuilder->ToReferenceFrame(frame), frame->GetSize());
    1:             nscoord x = PR_MIN(startPoint.x, endPoint.x);
    1:             textRect.x += x;
    1:             textRect.width = PR_MAX(startPoint.x, endPoint.x) - x;
    1:             surfaceRect.UnionRect(surfaceRect, textRect);
    1: 
    1:             // wrap the item in an nsDisplayClip so that it can be clipped to
    1:             // the selection. If the allocation fails, fall through and delete
    1:             // the item below.
14466:             itemToInsert = new (aBuilder)nsDisplayClip(frame, frame, i, textRect);
    1:           }
    1:         }
    1:         else {
    1:           // if the node is within the range, append it to the temporary list
    1:           PRBool before, after;
    1:           nsRange::CompareNodeToRange(content, aRange, &before, &after);
    1:           if (!before && !after) {
    1:             itemToInsert = i;
    1:             surfaceRect.UnionRect(surfaceRect, i->GetBounds(aBuilder));
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     // insert the item into the list if necessary. If the item has a child
    1:     // list, insert that as well
    1:     nsDisplayList* sublist = i->GetList();
    1:     if (itemToInsert || sublist) {
    1:       tmpList.AppendToTop(itemToInsert ? itemToInsert : i);
    1:       // if the item is a list, iterate over it as well
    1:       if (sublist)
    1:         surfaceRect.UnionRect(surfaceRect,
 4741:           ClipListToRange(aBuilder, sublist, aRange));
    1:     }
    1:     else {
    1:       // otherwise, just delete the item and don't readd it to the list
    1:       i->~nsDisplayItem();
    1:     }
    1:   }
    1: 
    1:   // now add all the items back onto the original list again
    1:   aList->AppendToTop(&tmpList);
    1: 
    1:   return surfaceRect;
    1: }
    1: 
    1: RangePaintInfo*
    1: PresShell::CreateRangePaintInfo(nsIDOMRange* aRange,
    1:                                 nsRect& aSurfaceRect)
    1: {
    1:   RangePaintInfo* info = nsnull;
    1: 
    1:   nsCOMPtr<nsIRange> range = do_QueryInterface(aRange);
    1:   if (!range)
    1:     return nsnull;
    1: 
  219:   nsIFrame* ancestorFrame;
  219:   nsIFrame* rootFrame = GetRootFrame();
  219: 
  219:   // If the start or end of the range is the document, just use the root
  219:   // frame, otherwise get the common ancestor of the two endpoints of the
  219:   // range.
  219:   nsINode* startParent = range->GetStartParent();
  219:   nsINode* endParent = range->GetEndParent();
  219:   nsIDocument* doc = startParent->GetCurrentDoc();
  219:   if (startParent == doc || endParent == doc) {
  219:     ancestorFrame = rootFrame;
  219:   }
  219:   else {
  219:     nsINode* ancestor = nsContentUtils::GetCommonAncestor(startParent, endParent);
    1:     NS_ASSERTION(!ancestor || ancestor->IsNodeOfType(nsINode::eCONTENT),
    1:                  "common ancestor is not content");
    1:     if (!ancestor || !ancestor->IsNodeOfType(nsINode::eCONTENT))
    1:       return nsnull;
    1: 
 3233:     nsIContent* ancestorContent = static_cast<nsIContent*>(ancestor);
  219:     ancestorFrame = GetPrimaryFrameFor(ancestorContent);
    1: 
    1:     // use the nearest ancestor frame that includes all continuations as the
    1:     // root for building the display list
   94:     while (ancestorFrame &&
   94:            nsLayoutUtils::GetNextContinuationOrSpecialSibling(ancestorFrame))
    1:       ancestorFrame = ancestorFrame->GetParent();
  219:   }
    1: 
    1:   if (!ancestorFrame)
    1:     return nsnull;
    1: 
    1:   info = new RangePaintInfo(range, ancestorFrame);
    1:   if (!info)
    1:     return nsnull;
    1: 
    1:   nsRect ancestorRect = ancestorFrame->GetOverflowRect();
    1: 
    1:   // get a display list containing the range
    1:   info->mBuilder.SetPaintAllFrames();
    1:   info->mBuilder.EnterPresShell(ancestorFrame, ancestorRect);
    1:   ancestorFrame->BuildDisplayListForStackingContext(&info->mBuilder,
    1:                                                     ancestorRect, &info->mList);
    1:   info->mBuilder.LeavePresShell(ancestorFrame, ancestorRect);
    1: 
 4741:   nsRect rangeRect = ClipListToRange(&info->mBuilder, &info->mList, range);
    1: 
    1:   // determine the offset of the reference frame for the display list
    1:   // to the root frame. This will allow the coordinates used when painting
    1:   // to all be offset from the same point
  219:   info->mRootOffset = ancestorFrame->GetOffsetTo(rootFrame);
    1:   rangeRect.MoveBy(info->mRootOffset);
    1:   aSurfaceRect.UnionRect(aSurfaceRect, rangeRect);
    1: 
    1:   return info;
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: PresShell::PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
    1:                                nsISelection* aSelection,
    1:                                nsIRegion* aRegion,
    1:                                nsRect aArea,
19835:                                nsPoint& aPoint,
19835:                                nsRect* aScreenRect)
    1: {
    1:   nsPresContext* pc = GetPresContext();
 1562:   if (!pc || aArea.width == 0 || aArea.height == 0)
    1:     return nsnull;
    1: 
    1:   nsIDeviceContext* deviceContext = pc->DeviceContext();
    1: 
    1:   // use the rectangle to create the surface
19835:   nsRect pixelArea = aArea;
19835:   pixelArea.ScaleRoundOut(1.0 / pc->AppUnitsPerDevPixel());
    1: 
    1:   // if the area of the image is larger than the maximum area, scale it down
    1:   float scale = 0.0;
    1:   nsIntRect rootScreenRect = GetRootFrame()->GetScreenRect();
    1: 
    1:   // if the image is larger in one or both directions than half the size of
    1:   // the available screen area, scale the image down to that size.
    1:   nsRect maxSize;
    1:   deviceContext->GetClientRect(maxSize);
    1:   nscoord maxWidth = pc->AppUnitsToDevPixels(maxSize.width >> 1);
    1:   nscoord maxHeight = pc->AppUnitsToDevPixels(maxSize.height >> 1);
    1:   PRBool resize = (pixelArea.width > maxWidth || pixelArea.height > maxHeight);
    1:   if (resize) {
    1:     scale = 1.0;
    1:     // divide the maximum size by the image size in both directions. Whichever
    1:     // direction produces the smallest result determines how much should be
    1:     // scaled.
    1:     if (pixelArea.width > maxWidth)
    1:       scale = PR_MIN(scale, float(maxWidth) / pixelArea.width);
    1:     if (pixelArea.height > maxHeight)
    1:       scale = PR_MIN(scale, float(maxHeight) / pixelArea.height);
    1: 
    1:     pixelArea.width = NSToIntFloor(float(pixelArea.width) * scale);
    1:     pixelArea.height = NSToIntFloor(float(pixelArea.height) * scale);
    1: 
    1:     // adjust the screen position based on the rescaled size
    1:     nscoord left = rootScreenRect.x + pixelArea.x;
    1:     nscoord top = rootScreenRect.y + pixelArea.y;
    1:     aScreenRect->x = NSToIntFloor(aPoint.x - float(aPoint.x - left) * scale);
    1:     aScreenRect->y = NSToIntFloor(aPoint.y - float(aPoint.y - top) * scale);
    1:   }
    1:   else {
    1:     // move aScreenRect to the position of the surface in screen coordinates
    1:     aScreenRect->MoveTo(rootScreenRect.x + pixelArea.x, rootScreenRect.y + pixelArea.y);
    1:   }
    1:   aScreenRect->width = pixelArea.width;
    1:   aScreenRect->height = pixelArea.height;
    1: 
    1:   gfxImageSurface* surface =
    1:     new gfxImageSurface(gfxIntSize(pixelArea.width, pixelArea.height),
    1:                         gfxImageSurface::ImageFormatARGB32);
 1562:   if (!surface || surface->CairoStatus()) {
 1562:     delete surface;
    1:     return nsnull;
 1562:   }
    1: 
    1:   // clear the image
    1:   gfxContext context(surface);
    1:   context.SetOperator(gfxContext::OPERATOR_CLEAR);
    1:   context.Rectangle(gfxRect(0, 0, pixelArea.width, pixelArea.height));
    1:   context.Fill();
    1: 
    1:   nsCOMPtr<nsIRenderingContext> rc;
    1:   deviceContext->CreateRenderingContextInstance(*getter_AddRefs(rc));
    1:   rc->Init(deviceContext, surface);
    1: 
    1:   if (aRegion)
    1:     rc->SetClipRegion(*aRegion, nsClipCombine_kReplace);
    1: 
    1:   if (resize)
    1:     rc->Scale(scale, scale);
    1: 
    1:   // translate so that points are relative to the surface area
    1:   rc->Translate(-aArea.x, -aArea.y);
    1: 
    1:   // temporarily hide the selection so that text is drawn normally. If a
    1:   // selection is being rendered, use that, otherwise use the presshell's
    1:   // selection.
    1:   nsCOMPtr<nsFrameSelection> frameSelection;
    1:   if (aSelection) {
    1:     nsCOMPtr<nsISelectionPrivate> selpriv = do_QueryInterface(aSelection);
    1:     selpriv->GetFrameSelection(getter_AddRefs(frameSelection));
    1:   }
    1:   else {
    1:     frameSelection = FrameSelection();
    1:   }
    1:   PRInt16 oldDisplaySelection = frameSelection->GetDisplaySelection();
    1:   frameSelection->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
    1: 
    1:   // next, paint each range in the selection
    1:   PRInt32 count = aItems->Length();
    1:   for (PRInt32 i = 0; i < count; i++) {
    1:     RangePaintInfo* rangeInfo = (*aItems)[i];
    1:     // the display lists paint relative to the offset from the reference
    1:     // frame, so translate the rendering context
    1:     nsIRenderingContext::AutoPushTranslation
    1:       translate(rc, rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
    1: 
    1:     aArea.MoveBy(-rangeInfo->mRootOffset.x, -rangeInfo->mRootOffset.y);
    1:     rangeInfo->mList.Paint(&rangeInfo->mBuilder, rc, aArea);
    1:     aArea.MoveBy(rangeInfo->mRootOffset.x, rangeInfo->mRootOffset.y);
    1:   }
    1: 
    1:   // restore the old selection display state
    1:   frameSelection->SetDisplaySelection(oldDisplaySelection);
    1: 
    1:   NS_ADDREF(surface);
    1:   return surface;
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: PresShell::RenderNode(nsIDOMNode* aNode,
    1:                       nsIRegion* aRegion,
19835:                       nsPoint& aPoint,
19835:                       nsRect* aScreenRect)
    1: {
    1:   // area will hold the size of the surface needed to draw the node, measured
    1:   // from the root frame.
    1:   nsRect area;
    1:   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
    1: 
18448:   // nothing to draw if the node isn't in a document
18448:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
18448:   if (!node->IsInDoc())
18448:     return nsnull;
18448:   
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   NS_NewRange(getter_AddRefs(range));
20084:   if (NS_FAILED(range->SelectNode(aNode)))
20084:     return nsnull;
    1: 
 4741:   RangePaintInfo* info = CreateRangePaintInfo(range, area);
    1:   if (info && !rangeItems.AppendElement(info)) {
    1:     delete info;
    1:     return nsnull;
    1:   }
    1: 
    1:   if (aRegion) {
    1:     // combine the area with the supplied region
19835:     nsRect rrectPixels;
    1:     aRegion->GetBoundingBox(&rrectPixels.x, &rrectPixels.y,
    1:                             &rrectPixels.width, &rrectPixels.height);
    1: 
19835:     nsRect rrect = rrectPixels;
19835:     rrect.ScaleRoundOut(nsPresContext::AppUnitsPerCSSPixel());
    1:     area.IntersectRect(area, rrect);
    1:     
    1:     nsPresContext* pc = GetPresContext();
    1:     if (!pc)
    1:       return nsnull;
    1: 
    1:     // move the region so that it is offset from the topleft corner of the surface
    1:     aRegion->Offset(-rrectPixels.x + (rrectPixels.x - pc->AppUnitsToDevPixels(area.x)),
    1:                     -rrectPixels.y + (rrectPixels.y - pc->AppUnitsToDevPixels(area.y)));
    1:   }
    1: 
    1:   return PaintRangePaintInfo(&rangeItems, nsnull, aRegion, area, aPoint,
    1:                              aScreenRect);
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: PresShell::RenderSelection(nsISelection* aSelection,
19835:                            nsPoint& aPoint,
19835:                            nsRect* aScreenRect)
    1: {
    1:   // area will hold the size of the surface needed to draw the selection,
    1:   // measured from the root frame.
    1:   nsRect area;
    1:   nsTArray<nsAutoPtr<RangePaintInfo> > rangeItems;
    1: 
    1:   // iterate over each range and collect them into the rangeItems array.
    1:   // This is done so that the size of selection can be determined so as
    1:   // to allocate a surface area
    1:   PRInt32 numRanges;
    1:   aSelection->GetRangeCount(&numRanges);
 1562:   NS_ASSERTION(numRanges > 0, "RenderSelection called with no selection");
 1562: 
    1:   for (PRInt32 r = 0; r < numRanges; r++)
    1:   {
    1:     nsCOMPtr<nsIDOMRange> range;
    1:     aSelection->GetRangeAt(r, getter_AddRefs(range));
    1: 
 4741:     RangePaintInfo* info = CreateRangePaintInfo(range, area);
    1:     if (info && !rangeItems.AppendElement(info)) {
    1:       delete info;
    1:       return nsnull;
    1:     }
    1:   }
    1: 
    1:   return PaintRangePaintInfo(&rangeItems, aSelection, nsnull, area, aPoint,
    1:                              aScreenRect);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::Paint(nsIView*             aView,
    1:                  nsIRenderingContext* aRenderingContext,
    1:                  const nsRegion&      aDirtyRegion)
    1: {
    1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Paint);
22764: 
22764:   NS_ASSERTION(!mIsDestroying, "painting a destroyed PresShell");
22764:   NS_ASSERTION(aView, "null view");
22764: 
22764:   // Compute the backstop color for the view.  This color must be
22764:   // totally transparent if the view is within a glass or transparent
22764:   // widget; otherwise, we compose all the view managers' default
22764:   // background colors in order to get something completely opaque.
22764:   // Nested view managers might not have an opaque default, but the
22764:   // root view manager must.  See bug 467459.
22764: 
22764:   PRBool needTransparency = PR_FALSE;
22764:   nsIViewManager *lastMgr = mViewManager;
    1:   nscolor backgroundColor;
22764:   lastMgr->GetDefaultBackgroundColor(&backgroundColor);
22764: 
    1:   for (nsIView *view = aView; view; view = view->GetParent()) {
22764:     if (view->HasWidget() &&
22764:         view->GetWidget()->GetTransparencyMode() != eTransparencyOpaque) {
    1:       backgroundColor = NS_RGBA(0,0,0,0);
22764:       needTransparency = PR_TRUE;
    1:       break;
    1:     }
22764:     if (NS_GET_A(backgroundColor) < 255) {
22764:       nsIViewManager *thisMgr = view->GetViewManager();
22764:       NS_ASSERTION(thisMgr, "view without view manager");
22764:       if (lastMgr != thisMgr) {
22764:         nscolor underColor;
22764:         thisMgr->GetDefaultBackgroundColor(&underColor);
22764:         backgroundColor = NS_ComposeColors(underColor, backgroundColor);
22764:         lastMgr = thisMgr;
22764:       }
22764:     }
22764:   }
22764: 
22764:   NS_ASSERTION(needTransparency || NS_GET_A(backgroundColor) == 255,
22764:                "root view manager's default background isn't opaque");
22764:   
22764:   nsIFrame* frame = static_cast<nsIFrame*>(aView->GetClientData());
22764:   if (frame) {
22764:     nsLayoutUtils::PaintFrame(aRenderingContext, frame, aDirtyRegion,
22764:                               backgroundColor);
22764:   } else if (NS_GET_A(backgroundColor) > 0) {
    1:     aRenderingContext->SetColor(backgroundColor);
    1:     aRenderingContext->FillRect(aDirtyRegion.GetBounds());
    1:   }
22764: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame*
    1: PresShell::GetCurrentEventFrame()
    1: {
22472:   if (NS_UNLIKELY(mIsDestroying)) {
22472:     return nsnull;
22472:   }
22472:     
    1:   if (!mCurrentEventFrame && mCurrentEventContent) {
    1:     // Make sure the content still has a document reference. If not,
    1:     // then we assume it is no longer in the content tree and the
    1:     // frame shouldn't get an event, nor should we even assume its
    1:     // safe to try and find the frame.
    1:     if (mCurrentEventContent->GetDocument()) {
    1:       mCurrentEventFrame = GetPrimaryFrameFor(mCurrentEventContent);
    1:     }
    1:   }
    1: 
    1:   return mCurrentEventFrame;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetEventTargetFrame(nsIFrame** aFrame)
    1: {
    1:   *aFrame = GetCurrentEventFrame();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::GetEventTargetContent(nsEvent* aEvent, nsIContent** aContent)
    1: {
    1:   if (mCurrentEventContent) {
    1:     *aContent = mCurrentEventContent;
    1:     NS_IF_ADDREF(*aContent);
    1:   } else {
    1:     nsIFrame* currentEventFrame = GetCurrentEventFrame();
    1:     if (currentEventFrame) {
    1:       currentEventFrame->GetContentForEvent(mPresContext, aEvent, aContent);
    1:     } else {
    1:       *aContent = nsnull;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: PresShell::PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent)
    1: {
    1:   if (mCurrentEventFrame || mCurrentEventContent) {
    1:     mCurrentEventFrameStack.InsertElementAt((void*)mCurrentEventFrame, 0);
    1:     mCurrentEventContentStack.InsertObjectAt(mCurrentEventContent, 0);
    1:   }
    1:   mCurrentEventFrame = aFrame;
    1:   mCurrentEventContent = aContent;
    1: }
    1: 
    1: void
    1: PresShell::PopCurrentEventInfo()
    1: {
    1:   mCurrentEventFrame = nsnull;
    1:   mCurrentEventContent = nsnull;
    1: 
    1:   if (0 != mCurrentEventFrameStack.Count()) {
    1:     mCurrentEventFrame = (nsIFrame*)mCurrentEventFrameStack.ElementAt(0);
    1:     mCurrentEventFrameStack.RemoveElementAt(0);
    1:     mCurrentEventContent = mCurrentEventContentStack.ObjectAt(0);
    1:     mCurrentEventContentStack.RemoveObjectAt(0);
    1:   }
    1: }
    1: 
    1: PRBool PresShell::InZombieDocument(nsIContent *aContent)
    1: {
    1:   // If a content node points to a null document, or the document is not
    1:   // attached to a window, then it is possibly in a zombie document,
    1:   // about to be replaced by a newly loading document.
    1:   // Such documents cannot handle DOM events.
    1:   // It might actually be in a node not attached to any document,
    1:   // in which case there is not parent presshell to retarget it to.
    1:   nsIDocument *doc = aContent->GetDocument();
    1:   return !doc || !doc->GetWindow();
    1: }
    1: 
    1: nsresult PresShell::RetargetEventToParent(nsGUIEvent*     aEvent,
    1:                                           nsEventStatus*  aEventStatus)
    1: {
    1:   // Send this events straight up to the parent pres shell.
    1:   // We do this for keystroke events in zombie documents or if either a frame
    1:   // or a root content is not present.
    1:   // That way at least the UI key bindings can work.
    1: 
    1:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(this);
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   if (!container)
    1:     container = do_QueryReferent(mForwardingContainer);
    1: 
    1:   // Now, find the parent pres shell and send the event there
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem = 
    1:     do_QueryInterface(container);
19869:   if (!treeItem) {
19869:     // Might have gone away, or never been around to start with
19869:     return NS_ERROR_FAILURE;
19869:   }
19869:   
    1:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
    1:   treeItem->GetParent(getter_AddRefs(parentTreeItem));
    1:   nsCOMPtr<nsIDocShell> parentDocShell = 
    1:     do_QueryInterface(parentTreeItem);
    1:   if (!parentDocShell || treeItem == parentTreeItem) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPresShell> parentPresShell;
    1:   parentDocShell->GetPresShell(getter_AddRefs(parentPresShell));
    1:   nsCOMPtr<nsIViewObserver> parentViewObserver = 
    1:     do_QueryInterface(parentPresShell);
    1:   if (!parentViewObserver) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Fake the event as though it'ss from the parent pres shell's root view.
    1:   nsIView *parentRootView;
    1:   parentPresShell->GetViewManager()->GetRootView(parentRootView);
    1:   
    1:   return parentViewObserver->HandleEvent(parentRootView, aEvent, 
    1:                                          aEventStatus);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::HandleEvent(nsIView         *aView,
    1:                        nsGUIEvent*     aEvent,
    1:                        nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ASSERTION(aView, "null view");
    1: 
22979:   if (mIsDestroying || !nsContentUtils::IsSafeToRunScript()) {
    1:     return NS_OK;
    1:   }
    1: 
    1: #ifdef ACCESSIBILITY
    1:   if (aEvent->eventStructType == NS_ACCESSIBLE_EVENT) {
13287:     // Accessibility events come through OS requests and not from scripts,
13287:     // so it is safe to handle here
    1:     return HandleEventInternal(aEvent, aView, aEventStatus);
    1:   }
    1: #endif
14479: 
    1:   // Check for a theme change up front, since the frame type is irrelevant
    1:   if (aEvent->message == NS_THEMECHANGED && mPresContext) {
    1:     mPresContext->ThemeChanged();
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Check for a system color change up front, since the frame type is
    1:   // irrelevant
    1:   if ((aEvent->message == NS_SYSCOLORCHANGED) && mPresContext) {
    1:     nsIViewManager* vm = GetViewManager();
    1:     if (vm) {
    1:       // Only dispatch system color change when the message originates from
    1:       // from the root views widget. This is necessary to prevent us from 
    1:       // dispatching the SysColorChanged notification for each child window 
    1:       // which may be redundant.
    1:       nsIView *view;
    1:       vm->GetRootView(view);
    1:       if (view == aView) {
    1:         *aEventStatus = nsEventStatus_eConsumeDoDefault;
    1:         mPresContext->SysColorChanged();
    1:         return NS_OK;
    1:       }
    1:     }
    1:     return NS_OK;
    1:   }
    1:   
 3233:   nsIFrame* frame = static_cast<nsIFrame*>(aView->GetClientData());
    1: 
    1:   PRBool dispatchUsingCoordinates =
    1:       !NS_IS_KEY_EVENT(aEvent) && !NS_IS_IME_EVENT(aEvent) &&
22788:       !NS_IS_CONTEXT_MENU_KEY(aEvent) && !NS_IS_FOCUS_EVENT(aEvent) &&
22788:       !NS_IS_PLUGIN_EVENT(aEvent);
    1: 
    1:   // if this event has no frame, we need to retarget it at a parent
    1:   // view that has a frame.
    1:   if (!frame &&
    1:       (dispatchUsingCoordinates || NS_IS_KEY_EVENT(aEvent) ||
    1:        NS_IS_IME_EVENT(aEvent))) {
    1:     nsIView* targetView = aView;
    1:     while (targetView && !targetView->GetClientData()) {
    1:       targetView = targetView->GetParent();
    1:     }
    1:     
    1:     if (targetView) {
    1:       aView = targetView;
 3233:       frame = static_cast<nsIFrame*>(aView->GetClientData());
    1:     }
    1:   }
    1: 
    1:   if (dispatchUsingCoordinates) {
    1:     NS_ASSERTION(frame, "Nothing to handle this event!");
    1:     if (!frame)
    1:       return NS_OK;
    1: 
  238:     nsPresContext* framePresContext = frame->PresContext();
    1:     nsPresContext* rootPresContext = framePresContext->RootPresContext();
 4215:     NS_ASSERTION(rootPresContext == mPresContext->RootPresContext(),
    1:                  "How did we end up outside the connected prescontext/viewmanager hierarchy?"); 
    1:     // If we aren't starting our event dispatch from the root frame of the root prescontext,
    1:     // then someone must be capturing the mouse. In that case we don't want to search the popup
    1:     // list.
    1:     if (framePresContext == rootPresContext &&
    1:         frame == FrameManager()->GetRootFrame()) {
 3516: 
 3799: #ifdef MOZ_XUL
 3516:       nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3516:       if (pm) {
 3516:         nsTArray<nsIFrame*> popups = pm->GetOpenPopups();
 8509:         PRUint32 i;
    1:         // Search from top to bottom
 3516:         for (i = 0; i < popups.Length(); i++) {
    1:           nsIFrame* popup = popups[i];
    1:           if (popup->GetOverflowRect().Contains(
    1:               nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, popup))) {
    1:             // The event should target the popup
    1:             frame = popup;
    1:             break;
    1:           }
    1:         }
    1:       }
 3799: #endif
 3516:     }
    1: 
    1:     nsPoint eventPoint
    1:         = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, frame);
11016:     nsIFrame* targetFrame;
11016:     {
11016:       nsAutoDisableGetUsedXAssertions disableAssert;
22095:       PRBool ignoreRootScrollFrame = PR_FALSE;
20863:       if (aEvent->eventStructType == NS_MOUSE_EVENT) {
22095:         ignoreRootScrollFrame = static_cast<nsMouseEvent*>(aEvent)->ignoreRootScrollFrame;
20863:       }
20863:       targetFrame = nsLayoutUtils::GetFrameForPoint(frame, eventPoint,
22095:                                                     PR_FALSE, ignoreRootScrollFrame);
11016:     }
11016: 
    1:     if (targetFrame) {
    1:       PresShell* shell =
 3233:           static_cast<PresShell*>(targetFrame->PresContext()->PresShell());
    1:       if (shell != this) {
    1:         // Handle the event in the correct shell.
    1:         // Prevent deletion until we're done with event handling (bug 336582).
 2706:         nsCOMPtr<nsIPresShell> kungFuDeathGrip(shell);
    1:         nsIView* subshellRootView;
    1:         shell->GetViewManager()->GetRootView(subshellRootView);
    1:         // We pass the subshell's root view as the view to start from. This is
    1:         // the only correct alternative; if the event was captured then it
    1:         // must have been captured by us or some ancestor shell and we
    1:         // now ask the subshell to dispatch it normally.
    1:         return shell->HandlePositionedEvent(subshellRootView, targetFrame,
    1:                                             aEvent, aEventStatus);
    1:       }
    1:     }
    1:     
    1:     if (!targetFrame) {
    1:       targetFrame = frame;
    1:     }
    1:     return HandlePositionedEvent(aView, targetFrame, aEvent, aEventStatus);
    1:   }
    1:   
    1:   nsresult rv = NS_OK;
    1:   
    1:   if (frame) {
    1:     PushCurrentEventInfo(nsnull, nsnull);
    1: 
    1:     // key and IME events go to the focused frame
    1:     nsIEventStateManager *esm = mPresContext->EventStateManager();
    1: 
    1:     if (NS_IS_KEY_EVENT(aEvent) || NS_IS_IME_EVENT(aEvent) ||
22788:         NS_IS_CONTEXT_MENU_KEY(aEvent) || NS_IS_PLUGIN_EVENT(aEvent)) {
    1:       esm->GetFocusedFrame(&mCurrentEventFrame);
    1:       if (mCurrentEventFrame) {
    1:         esm->GetFocusedContent(getter_AddRefs(mCurrentEventContent));
    1:       } else {
11910:         if (NS_TargetUnfocusedEventToLastFocusedContent(aEvent)) {
    1:           nsPIDOMWindow *ourWindow = mDocument->GetWindow();
    1:           if (ourWindow) {
    1:             nsIFocusController *focusController =
    1:               ourWindow->GetRootFocusController();
    1:             if (focusController) {
    1:               PRBool active = PR_FALSE;
    1:               // check input focus is in Mozilla
    1:               focusController->GetActive(&active);
    1:               if (!active) {
    1:                 // if not, search for pre-focused element
    1:                 nsCOMPtr<nsIDOMElement> focusedElement;
    1:                 focusController->GetFocusedElement(getter_AddRefs(focusedElement));
    1:                 if (focusedElement) {
    1:                   // get mCurrentEventContent from focusedElement
    1:                   mCurrentEventContent = do_QueryInterface(focusedElement);
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1:         if (!mCurrentEventContent) {
    1:           mCurrentEventContent = mDocument->GetRootContent();
    1:         }
    1:         mCurrentEventFrame = nsnull; // XXXldb Isn't it already?
    1:       }
    1:       if (!mCurrentEventContent || InZombieDocument(mCurrentEventContent)) {
    1:         rv = RetargetEventToParent(aEvent, aEventStatus);
    1:         PopCurrentEventInfo();
    1:         return rv;
    1:       }
    1:     } else {
    1:       mCurrentEventFrame = frame;
    1:     }
    1:     if (GetCurrentEventFrame()) {
    1:       rv = HandleEventInternal(aEvent, aView, aEventStatus);
    1:     }
    1:   
    1: #ifdef NS_DEBUG
    1:     ShowEventTargetDebug();
    1: #endif
    1:     PopCurrentEventInfo();
    1:   } else {
    1:     // Focus events need to be dispatched even if no frame was found, since
    1:     // we don't want the focus controller to be out of sync.
    1: 
    1:     if (!NS_EVENT_NEEDS_FRAME(aEvent)) {
    1:       mCurrentEventFrame = nsnull;
    1:       return HandleEventInternal(aEvent, aView, aEventStatus);
    1:     }
    1:     else if (NS_IS_KEY_EVENT(aEvent)) {
    1:       // Keypress events in new blank tabs should not be completely thrown away.
    1:       // Retarget them -- the parent chrome shell might make use of them.
    1:       return RetargetEventToParent(aEvent, aEventStatus);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: void
    1: PresShell::ShowEventTargetDebug()
    1: {
    1:   if (nsIFrameDebug::GetShowEventTargetFrameBorder() &&
    1:       GetCurrentEventFrame()) {
    1:     if (mDrawEventTargetFrame) {
    1:       mDrawEventTargetFrame->Invalidate(
    1:           nsRect(nsPoint(0, 0), mDrawEventTargetFrame->GetSize()));
    1:     }
    1: 
    1:     mDrawEventTargetFrame = mCurrentEventFrame;
    1:     mDrawEventTargetFrame->Invalidate(
    1:         nsRect(nsPoint(0, 0), mDrawEventTargetFrame->GetSize()));
    1:   }
    1: }
    1: #endif
    1: 
    1: nsresult
    1: PresShell::HandlePositionedEvent(nsIView*       aView,
    1:                                  nsIFrame*      aTargetFrame,
    1:                                  nsGUIEvent*    aEvent,
    1:                                  nsEventStatus* aEventStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1:   
    1:   PushCurrentEventInfo(nsnull, nsnull);
    1:   
    1:   mCurrentEventFrame = aTargetFrame;
    1: 
    1:   if (mCurrentEventFrame) {
    1:     nsCOMPtr<nsIContent> targetElement;
    1:     mCurrentEventFrame->GetContentForEvent(mPresContext, aEvent,
    1:                                            getter_AddRefs(targetElement));
    1: 
    1:     // If there is no content for this frame, target it anyway.  Some
    1:     // frames can be targeted but do not have content, particularly
    1:     // windows with scrolling off.
    1:     if (targetElement) {
    1:       // Bug 103055, bug 185889: mouse events apply to *elements*, not all
    1:       // nodes.  Thus we get the nearest element parent here.
    1:       // XXX we leave the frame the same even if we find an element
    1:       // parent, so that the text frame will receive the event (selection
    1:       // and friends are the ones who care about that anyway)
    1:       //
    1:       // We use weak pointers because during this tight loop, the node
    1:       // will *not* go away.  And this happens on every mousemove.
    1:       while (targetElement &&
    1:              !targetElement->IsNodeOfType(nsINode::eELEMENT)) {
    1:         targetElement = targetElement->GetParent();
    1:       }
    1: 
    1:       // If we found an element, target it.  Otherwise, target *nothing*.
    1:       if (!targetElement) {
    1:         mCurrentEventContent = nsnull;
    1:         mCurrentEventFrame = nsnull;
    1:       } else if (targetElement != mCurrentEventContent) {
    1:         mCurrentEventContent = targetElement;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (GetCurrentEventFrame()) {
    1:     rv = HandleEventInternal(aEvent, aView, aEventStatus);
    1:   }
    1: 
    1: #ifdef NS_DEBUG
    1:   ShowEventTargetDebug();
    1: #endif
    1:   PopCurrentEventInfo();
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
    1:                                  nsIContent* aContent, nsEventStatus* aStatus)
    1: {
    1:   nsresult ret;
    1: 
    1:   PushCurrentEventInfo(aFrame, aContent);
    1:   ret = HandleEventInternal(aEvent, nsnull, aStatus);
    1:   PopCurrentEventInfo();
    1:   return NS_OK;
    1: }
    1: 
    1: inline PRBool
    1: IsSynthesizedMouseMove(nsEvent* aEvent)
    1: {
    1:   return aEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:          static_cast<nsMouseEvent*>(aEvent)->reason != nsMouseEvent::eReal;
    1: }
    1: 
    1: nsresult
    1: PresShell::HandleEventInternal(nsEvent* aEvent, nsIView *aView,
    1:                                nsEventStatus* aStatus)
    1: {
    1: #ifdef ACCESSIBILITY
    1:   if (aEvent->eventStructType == NS_ACCESSIBLE_EVENT)
    1:   {
 3233:     static_cast<nsAccessibleEvent*>(aEvent)->accessible = nsnull;
    1:     nsCOMPtr<nsIAccessibilityService> accService = 
    1:       do_GetService("@mozilla.org/accessibilityService;1");
    1:     if (accService) {
    1:       nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:       if (!container) {
    1:         // This presshell is not active. This often happens when a
    1:         // preshell is being held onto for fastback.
    1:         return NS_OK;
    1:       }
    1:       nsIAccessible* acc;
    1:       nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(mDocument));
    1:       NS_ASSERTION(domNode, "No dom node for doc");
    1:       accService->GetAccessibleInShell(domNode, this, &acc);
    1:       // Addref this - it's not a COM Ptr
    1:       // We'll make sure the right number of Addref's occur before
    1:       // handing this back to the accessibility client
 3233:       static_cast<nsAccessibleEvent*>(aEvent)->accessible = acc;
 1090:       // Ensure this is set in case a11y was activated before any
 1090:       // nsPresShells existed to observe "a11y-init-or-shutdown" topic
 1090:       gIsAccessibilityActive = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsCOMPtr<nsIEventStateManager> manager = mPresContext->EventStateManager();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!NS_EVENT_NEEDS_FRAME(aEvent) || GetCurrentEventFrame()) {
    1:     PRBool isHandlingUserInput = PR_FALSE;
    1: 
    1:     if (NS_IS_TRUSTED_EVENT(aEvent)) {
    1:       switch (aEvent->message) {
    1:       case NS_GOTFOCUS:
    1:       case NS_LOSTFOCUS:
    1:       case NS_ACTIVATE:
    1:       case NS_DEACTIVATE:
    1:         // Treat focus/blur events as user input if they happen while
    1:         // executing trusted script, or no script at all. If they
    1:         // happen during execution of non-trusted script, then they
    1:         // should not be considered user input.
    1:         if (!nsContentUtils::IsCallerChrome()) {
    1:           break;
    1:         }
    1:       case NS_MOUSE_BUTTON_DOWN:
    1:       case NS_MOUSE_BUTTON_UP:
    1:       case NS_KEY_PRESS:
    1:       case NS_KEY_DOWN:
    1:       case NS_KEY_UP:
    1:         isHandlingUserInput = PR_TRUE;
    1:       }
    1:     }
    1: 
    1:     nsAutoHandlingUserInputStatePusher userInpStatePusher(isHandlingUserInput);
    1: 
    1:     nsAutoPopupStatePusher popupStatePusher(nsDOMEvent::GetEventPopupControlState(aEvent));
    1: 
    1:     // FIXME. If the event was reused, we need to clear the old target,
    1:     // bug 329430
    1:     aEvent->target = nsnull;
    1: 
 8292:     nsWeakView weakView(aView);
    1:     // 1. Give event to event manager for pre event state changes and
    1:     //    generation of synthetic events.
    1:     rv = manager->PreHandleEvent(mPresContext, aEvent, mCurrentEventFrame,
    1:                                  aStatus, aView);
    1: 
    1:     // 2. Give event to the DOM for third party and JS use.
22729:     if (GetCurrentEventFrame() && NS_SUCCEEDED(rv)) {
    1:       // We want synthesized mouse moves to cause mouseover and mouseout
    1:       // DOM events (PreHandleEvent above), but not mousemove DOM events.
    1:       if (!IsSynthesizedMouseMove(aEvent)) {
    1:         nsPresShellEventCB eventCB(this);
    1:         if (mCurrentEventContent) {
    1:           nsEventDispatcher::Dispatch(mCurrentEventContent, mPresContext,
    1:                                       aEvent, nsnull, aStatus, &eventCB);
    1:         }
    1:         else {
    1:           nsCOMPtr<nsIContent> targetContent;
    1:           rv = mCurrentEventFrame->GetContentForEvent(mPresContext, aEvent,
    1:                                                       getter_AddRefs(targetContent));
    1:           if (NS_SUCCEEDED(rv) && targetContent) {
    1:             nsEventDispatcher::Dispatch(targetContent, mPresContext, aEvent,
    1:                                         nsnull, aStatus, &eventCB);
    1:           } else if (mDocument) {
    1:             nsEventDispatcher::Dispatch(mDocument, mPresContext, aEvent,
    1:                                         nsnull, aStatus, nsnull);
    1:           }
    1:         }
    1:       }
    1: 
    1:       // 3. Give event to event manager for post event state changes and
    1:       //    generation of synthetic events.
22729:       if (!mIsDestroying && NS_SUCCEEDED(rv)) {
 8236:         rv = manager->PostHandleEvent(mPresContext, aEvent,
 8292:                                       GetCurrentEventFrame(), aStatus,
 8292:                                       weakView.GetView());
    1:       }
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: // Dispatch event to content only (NOT full processing)
    1: // See also HandleEventWithTarget which does full event processing.
    1: NS_IMETHODIMP
    1: PresShell::HandleDOMEventWithTarget(nsIContent* aTargetContent, nsEvent* aEvent,
    1:                                     nsEventStatus* aStatus)
    1: {
    1:   PushCurrentEventInfo(nsnull, aTargetContent);
    1: 
    1:   // Bug 41013: Check if the event should be dispatched to content.
    1:   // It's possible that we are in the middle of destroying the window
    1:   // and the js context is out of date. This check detects the case
    1:   // that caused a crash in bug 41013, but there may be a better way
    1:   // to handle this situation!
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   if (container) {
    1: 
    1:     // Dispatch event to content
    1:     nsEventDispatcher::Dispatch(aTargetContent, mPresContext, aEvent, nsnull,
    1:                                 aStatus);
    1:   }
    1: 
    1:   PopCurrentEventInfo();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ResizeReflow(nsIView *aView, nscoord aWidth, nscoord aHeight)
    1: {
    1:   return ResizeReflow(aWidth, aHeight);
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: PresShell::IsVisible()
    1: {
    1:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:   nsCOMPtr<nsIBaseWindow> bw = do_QueryInterface(container);
    1:   if (!bw)
    1:     return PR_FALSE;
    1:   PRBool res = PR_TRUE;
    1:   bw->GetVisibility(&res);
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP_(void)
    1: PresShell::WillPaint()
    1: {
22979:   // Don't bother reflowing if some viewmanager in our tree is painting while
    1:   // we still have painting suppressed.
22979:   if (mPaintingSuppressed) {
    1:     return;
    1:   }
    1:   
    1:   // Process reflows, if we have them, to reduce flicker due to invalidates and
    1:   // reflow being interspersed.  Note that we _do_ allow this to be
    1:   // interruptible; if we can't do all the reflows it's better to flicker a bit
    1:   // than to freeze up.
 4886:   DoFlushPendingNotifications(Flush_Layout, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: PresShell::GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets)
    1: {
    1:   aSheets.Clear();
    1:   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eAgentSheet);
    1: 
    1:   for (PRInt32 i = 0; i < sheetCount; ++i) {
    1:     nsIStyleSheet *sheet = mStyleSet->StyleSheetAt(nsStyleSet::eAgentSheet, i);
    1:     if (!aSheets.AppendObject(sheet))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: PresShell::SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets)
    1: {
    1:   return mStyleSet->ReplaceSheets(nsStyleSet::eAgentSheet, aSheets);
    1: }
    1: 
    1: nsresult
    1: PresShell::AddOverrideStyleSheet(nsIStyleSheet *aSheet)
    1: {
    1:   return mStyleSet->PrependStyleSheet(nsStyleSet::eOverrideSheet, aSheet);
    1: }
    1: 
    1: nsresult
    1: PresShell::RemoveOverrideStyleSheet(nsIStyleSheet *aSheet)
    1: {
    1:   return mStyleSet->RemoveStyleSheet(nsStyleSet::eOverrideSheet, aSheet);
    1: }
    1: 
    1: static void
    1: StopPluginInstance(PresShell *aShell, nsIContent *aContent)
    1: {
    1:   nsIFrame *frame = aShell->FrameManager()->GetPrimaryFrameFor(aContent, -1);
    1: 
    1:   nsIObjectFrame *objectFrame = nsnull;
    1:   if (frame)
    1:     CallQueryInterface(frame, &objectFrame);
    1:   if (!objectFrame)
    1:     return;
    1: 
    1:   objectFrame->StopPlugin();
    1: }
    1: 
21006: #ifdef MOZ_MEDIA
15751: static void
21006: StopMediaInstance(PresShell *aShell, nsIContent *aContent)
21006: {
22312:   nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aContent));
22312:   if (!domMediaElem)
22312:     return;
22312: 
22312:   nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aContent);
22312:   mediaElem->Freeze();
15751: }
15753: #endif
15751: 
20261: static PRBool
    1: FreezeSubDocument(nsIDocument *aDocument, void *aData)
    1: {
  981:   nsIPresShell *shell = aDocument->GetPrimaryShell();
    1:   if (shell)
    1:     shell->Freeze();
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::Freeze()
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(mDocument);
    1:   if (domDoc) {
    1:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"), StopPluginInstance);
    1:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("applet"), StopPluginInstance);
    1:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"), StopPluginInstance);
21006: #ifdef MOZ_MEDIA
21006:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("video"), StopMediaInstance);
21006:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("audio"), StopMediaInstance);
21006: #endif
    1:   }
    1: 
    1:   if (mCaret)
    1:     mCaret->SetCaretVisible(PR_FALSE);
    1: 
    1:   mPaintingSuppressed = PR_TRUE;
    1: 
    1:   if (mDocument)
    1:     mDocument->EnumerateSubDocuments(FreezeSubDocument, nsnull);
    1: }
    1: 
    1: static void
    1: StartPluginInstance(PresShell *aShell, nsIContent *aContent)
    1: {
    1:   nsCOMPtr<nsIObjectLoadingContent> objlc(do_QueryInterface(aContent));
    1:   if (!objlc)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIPluginInstance> inst;
    1:   objlc->EnsureInstantiation(getter_AddRefs(inst));
    1: }
    1: 
21006: #ifdef MOZ_MEDIA
15751: static void
21006: StartMediaInstance(PresShell *aShell, nsIContent *aContent)
21006: {
22312:   nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aContent));
22312:   if (!domMediaElem)
22312:     return;
22312: 
22312:   nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aContent);
22312:   mediaElem->Thaw();
15751: }
15753: #endif
15751: 
20261: static PRBool
    1: ThawSubDocument(nsIDocument *aDocument, void *aData)
    1: {
  981:   nsIPresShell *shell = aDocument->GetPrimaryShell();
    1:   if (shell)
    1:     shell->Thaw();
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: PresShell::Thaw()
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(mDocument);
    1:   if (domDoc) {
    1:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("object"), StartPluginInstance);
    1:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("applet"), StartPluginInstance);
    1:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("embed"), StartPluginInstance);
21006: #ifdef MOZ_MEDIA
21006:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("video"), StartMediaInstance);
21006:     EnumeratePlugins(domDoc, NS_LITERAL_STRING("audio"), StartMediaInstance);
21006: #endif
    1:   }
    1: 
    1:   if (mDocument)
    1:     mDocument->EnumerateSubDocuments(ThawSubDocument, nsnull);
    1: 
    1:   UnsuppressPainting();
    1: }
    1: 
    1: //--------------------------------------------------------
    1: // Start of protected and private methods on the PresShell
    1: //--------------------------------------------------------
    1: 
    1: //-------------- Begin Reflow Event Definition ------------------------
    1: 
    1: NS_IMETHODIMP
    1: PresShell::ReflowEvent::Run() {    
    1:   // Take an owning reference to the PresShell during this call to ensure
    1:   // that it doesn't get killed off prematurely.
    1:   nsRefPtr<PresShell> ps = mPresShell;
    1:   if (ps) {
    1: #ifdef DEBUG
    1:     if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:        printf("\n*** Handling reflow event: PresShell=%p, event=%p\n", (void*)ps, (void*)this);
    1:     }
    1: #endif
    1:     // NOTE: the ReflowEvent class is a friend of the PresShell class
    1:     ps->ClearReflowEventStatus();
    1:     // Set a kung fu death grip on the view manager associated with the pres shell
    1:     // before processing that pres shell's reflow commands.  Fixes bug 54868.
    1:     nsCOMPtr<nsIViewManager> viewManager = ps->GetViewManager();
 4886: 
 4886:     ps->DoFlushPendingNotifications(Flush_Layout, PR_TRUE);
    1: 
    1:     // Now, explicitly release the pres shell before the view manager
    1:     ps = nsnull;
    1:     viewManager = nsnull;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------- End Reflow Event Definition ---------------------------
    1: 
    1: void
    1: PresShell::PostReflowEvent()
    1: {
    1:   if (mReflowEvent.IsPending() || mIsDestroying || mIsReflowing ||
    1:       mDirtyRoots.Count() == 0)
    1:     return;
    1: 
    1:   nsRefPtr<ReflowEvent> ev = new ReflowEvent(this);
    1:   if (NS_FAILED(NS_DispatchToCurrentThread(ev))) {
    1:     NS_WARNING("failed to dispatch reflow event");
    1:   } else {
    1:     mReflowEvent = ev;
    1: #ifdef DEBUG
    1:     if (VERIFY_REFLOW_NOISY_RC & gVerifyReflowFlags) {
    1:       printf("\n*** PresShell::PostReflowEvent(), this=%p, event=%p\n", (void*)this, (void*)ev);
    1:     }
    1: #endif    
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::WillDoReflow()
    1: {
    1:   // We just reflowed, tell the caret that its frame might have moved.
 6518:   // XXXbz that comment makes no sense
    1:   if (mCaret) {
    1:     mCaret->InvalidateOutsideCaret();
    1:     mCaret->UpdateCaretPosition();
    1:   }
 6518: 
21925:   mPresContext->FlushUserFontSet();
21925: 
 6518:   mFrameConstructor->BeginUpdate();
    1: }
    1: 
    1: void
    1: PresShell::DidDoReflow()
    1: {
 6518:   mFrameConstructor->EndUpdate();
 6518:   
    1:   HandlePostedReflowCallbacks();
    1:   // Null-check mViewManager in case this happens during Destroy.  See
    1:   // bugs 244435 and 238546.
    1:   if (!mPaintingSuppressed && mViewManager)
    1:     mViewManager->SynthesizeMouseMove(PR_FALSE);
    1:   if (mCaret) {
    1:     // Update the caret's position now to account for any changes created by
    1:     // the reflow.
    1:     mCaret->InvalidateOutsideCaret();
    1:     mCaret->UpdateCaretPosition();
    1:   }
    1: }
    1: 
  790: void
  790: PresShell::DoReflow(nsIFrame* target)
  790: {
  790:   nsIFrame* rootFrame = FrameManager()->GetRootFrame();
  790: 
    1:   nsCOMPtr<nsIRenderingContext> rcx;
  790:   // Always create the rendering context relative to the root frame during
  790:   // reflow; otherwise, it crashes on the mac (I'm not quite sure why)
  782:   nsresult rv = CreateRenderingContext(rootFrame, getter_AddRefs(rcx));
  790:   if (NS_FAILED(rv)) {
  790:    NS_NOTREACHED("CreateRenderingContext failure");
  790:    return;
  790:  }
    1: 
    1:   target->WillReflow(mPresContext);
    1: 
    1:   // If the target frame is the root of the frame hierarchy, then
    1:   // use all the available space. If it's simply a `reflow root',
    1:   // then use the target frame's size as the available space.
    1:   nsSize size;
  790:   if (target == rootFrame)
  790:      size = mPresContext->GetVisibleArea().Size();
    1:   else
    1:      size = target->GetSize();
    1: 
    1:   NS_ASSERTION(!target->GetNextInFlow() && !target->GetPrevInFlow(),
    1:                "reflow roots should never split");
    1: 
    1:   // Don't pass size directly to the reflow state, since a
    1:   // constrained height implies page/column breaking.
  790:   // Exception: the root frame always uses a constrained reflow
  790:   nsSize reflowSize;
  790:   if (target != rootFrame)
  790:     reflowSize = nsSize(size.width, NS_UNCONSTRAINEDSIZE);
  790:   else
  790:     reflowSize = size;
  790:   nsHTMLReflowState reflowState(mPresContext, target, rcx, reflowSize);
    1: 
    1:   // fix the computed height
    1:   NS_ASSERTION(reflowState.mComputedMargin == nsMargin(0, 0, 0, 0),
    1:                "reflow state should not set margin for reflow roots");
  967:   if (size.height != NS_UNCONSTRAINEDSIZE) {
 4166:     nscoord computedHeight =
    1:       size.height - reflowState.mComputedBorderPadding.TopBottom();
 4166:     computedHeight = PR_MAX(computedHeight, 0);
 4166:     reflowState.SetComputedHeight(computedHeight);
  967:   }
    1:   NS_ASSERTION(reflowState.ComputedWidth() ==
    1:                  size.width -
    1:                    reflowState.mComputedBorderPadding.LeftRight(),
    1:                "reflow state computed incorrect width");
    1: 
    1:   nsReflowStatus status;
  790:   nsHTMLReflowMetrics desiredSize;
    1:   target->Reflow(mPresContext, desiredSize, reflowState, status);
    1: 
    1:   // If an incremental reflow is initiated at a frame other than the
  967:   // root frame, then its desired size had better not change!  If it's
  967:   // initiated at the root, then the size better not change unless its
  967:   // height was unconstrained to start with.
  967:   NS_ASSERTION((target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) ||
    1:                (desiredSize.width == size.width &&
    1:                 desiredSize.height == size.height),
    1:                "non-root frame's desired size changed during an "
    1:                "incremental reflow");
    1:   NS_ASSERTION(desiredSize.mOverflowArea ==
    1:                  nsRect(nsPoint(0, 0),
    1:                         nsSize(desiredSize.width, desiredSize.height)),
    1:                "reflow roots must not have visible overflow");
    1:   NS_ASSERTION(status == NS_FRAME_COMPLETE,
    1:                "reflow roots should never split");
    1: 
    1:   target->SetSize(nsSize(desiredSize.width, desiredSize.height));
    1: 
    1:   nsContainerFrame::SyncFrameViewAfterReflow(mPresContext, target,
    1:                                              target->GetView(),
    1:                                              &desiredSize.mOverflowArea);
    1: 
    1:   target->DidReflow(mPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
  967:   if (target == rootFrame && size.height == NS_UNCONSTRAINEDSIZE) {
  967:     mPresContext->SetVisibleArea(nsRect(0, 0, desiredSize.width,
  967:                                         desiredSize.height));
  967:   }
  790: }
    1: 
    1: #ifdef DEBUG
  790: void
  790: PresShell::DoVerifyReflow()
  790: {
    1:   if (nsIFrameDebug::GetVerifyTreeEnable()) {
    1:     nsIFrameDebug*  frameDebug;
  790:     nsIFrame* rootFrame = FrameManager()->GetRootFrame();
    1:     if (NS_SUCCEEDED(rootFrame->QueryInterface(NS_GET_IID(nsIFrameDebug),
    1:                                                (void**)&frameDebug))) {
    1:       frameDebug->VerifyTree();
    1:     }
    1:   }
    1:   if (GetVerifyReflowEnable()) {
    1:     // First synchronously render what we have so far so that we can
    1:     // see it.
    1:     nsIView* rootView;
    1:     mViewManager->GetRootView(rootView);
    1:     mViewManager->UpdateView(rootView, NS_VMREFRESH_IMMEDIATE);
    1: 
  790:     FlushPendingNotifications(Flush_Layout);
    1:     mInVerifyReflow = PR_TRUE;
    1:     PRBool ok = VerifyIncrementalReflow();
    1:     mInVerifyReflow = PR_FALSE;
    1:     if (VERIFY_REFLOW_ALL & gVerifyReflowFlags) {
    1:       printf("ProcessReflowCommands: finished (%s)\n",
    1:              ok ? "ok" : "failed");
    1:     }
    1: 
    1:     if (0 != mDirtyRoots.Count()) {
    1:       printf("XXX yikes! reflow commands queued during verify-reflow\n");
    1:     }
    1:   }
  790: }
    1: #endif
    1: 
  790: nsresult
  790: PresShell::ProcessReflowCommands(PRBool aInterruptible)
  790: {
  790:   MOZ_TIMER_DEBUGLOG(("Start: Reflow: PresShell::ProcessReflowCommands(), this=%p\n", this));
  790:   MOZ_TIMER_START(mReflowWatch);  
  790: 
  790:   if (0 != mDirtyRoots.Count()) {
  790: 
  790: #ifdef DEBUG
  790:     if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
  790:       printf("ProcessReflowCommands: begin incremental reflow\n");
  790:     }
  790: #endif
  790: 
  790:     WillDoReflow();
  790: 
  790:     // If reflow is interruptible, then make a note of our deadline.
  790:     const PRIntervalTime deadline = aInterruptible
  790:         ? PR_IntervalNow() + PR_MicrosecondsToInterval(gMaxRCProcessingTime)
  790:         : (PRIntervalTime)0;
  790: 
 6171:     // Scope for the reflow entry point
 6171:     {
13098:       nsAutoScriptBlocker scriptBlocker;
  790:       AUTO_LAYOUT_PHASE_ENTRY_POINT(GetPresContext(), Reflow);
  790:       mIsReflowing = PR_TRUE;
  790: 
  790:       do {
  790:         // Send an incremental reflow notification to the target frame.
  790:         PRInt32 idx = mDirtyRoots.Count() - 1;
 3233:         nsIFrame *target = static_cast<nsIFrame*>(mDirtyRoots[idx]);
  790:         mDirtyRoots.RemoveElementAt(idx);
  790: 
 1158:         if (!NS_SUBTREE_DIRTY(target)) {
  790:           // It's not dirty anymore, which probably means the notification
  790:           // was posted in the middle of a reflow (perhaps with a reflow
  790:           // root in the middle).  Don't do anything.
  790:           continue;
  790:         }
  790: 
  790:         DoReflow(target);
  790: 
  790:         // Keep going until we're out of reflow commands, or we've run
  790:         // past our deadline.
  790:       } while (mDirtyRoots.Count() &&
  790:                (!aInterruptible || PR_IntervalNow() < deadline));
  790: 
  790:       // XXXwaterson for interruptible reflow, examine the tree and
  790:       // re-enqueue any unflowed reflow targets.
  790: 
  790:       mIsReflowing = PR_FALSE;
  790:     }
  790: 
13098:     // Exiting the scriptblocker might have killed us
13098:     if (!mIsDestroying) {
    1:       DidDoReflow();
13098:     }
    1: 
 6162:     // DidDoReflow might have killed us
 6162:     if (!mIsDestroying) {
  790: #ifdef DEBUG
  790:       if (VERIFY_REFLOW_DUMP_COMMANDS & gVerifyReflowFlags) {
 6162:         printf("\nPresShell::ProcessReflowCommands() finished: this=%p\n",
 6162:                (void*)this);
  790:       }
  790:       DoVerifyReflow();
  790: #endif
  790: 
  921:       // If any new reflow commands were enqueued during the reflow, schedule
  921:       // another reflow event to process them.  Note that we want to do this
  921:       // after DidDoReflow(), since that method can change whether there are
 6162:       // dirty roots around by flushing, and there's no point in posting a
 6162:       // reflow event just to have the flush revoke it.
  921:       if (mDirtyRoots.Count())
  921:         PostReflowEvent();
    1:     }
 6162:   }
    1:   
    1:   MOZ_TIMER_DEBUGLOG(("Stop: Reflow: PresShell::ProcessReflowCommands(), this=%p\n", this));
    1:   MOZ_TIMER_STOP(mReflowWatch);  
    1: 
 6162:   if (!mIsDestroying && mShouldUnsuppressPainting &&
 6162:       mDirtyRoots.Count() == 0) {
    1:     // We only unlock if we're out of reflows.  It's pointless
    1:     // to unlock if reflows are still pending, since reflows
    1:     // are just going to thrash the frames around some more.  By
    1:     // waiting we avoid an overeager "jitter" effect.
    1:     mShouldUnsuppressPainting = PR_FALSE;
    1:     UnsuppressAndInvalidate();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: PresShell::ClearReflowEventStatus()
    1: {
    1:   mReflowEvent.Forget();
    1: }
    1: 
    1: #ifdef MOZ_XUL
    1: /*
    1:  * It's better to add stuff to the |DidSetStyleContext| method of the
    1:  * relevant frames than adding it here.  These methods should (ideally,
    1:  * anyway) go away.
    1:  */
    1: 
    1: // Return value says whether to walk children.
20261: typedef PRBool (* frameWalkerFn)(nsIFrame *aFrame, void *aClosure);
20261:    
20261: static PRBool
    1: ReResolveMenusAndTrees(nsIFrame *aFrame, void *aClosure)
    1: {
    1:   // Trees have a special style cache that needs to be flushed when
    1:   // the theme changes.
20988:   nsTreeBodyFrame *treeBody = nsnull;
20988:   CallQueryInterface(aFrame, &treeBody);
20988:   if (treeBody)
20988:     treeBody->ClearStyleAndImageCaches();
    1: 
    1:   // We deliberately don't re-resolve style on a menu's popup
    1:   // sub-content, since doing so slows menus to a crawl.  That means we
    1:   // have to special-case them on a skin switch, and ensure that the
    1:   // popup frames just get destroyed completely.
 3129:   if (aFrame && aFrame->GetType() == nsGkAtoms::menuFrame)
 3233:     (static_cast<nsMenuFrame *>(aFrame))->CloseMenu(PR_TRUE);
    1:   return PR_TRUE;
    1: }
    1: 
20261: static PRBool
    1: ReframeImageBoxes(nsIFrame *aFrame, void *aClosure)
    1: {
 3233:   nsStyleChangeList *list = static_cast<nsStyleChangeList*>(aClosure);
    1:   if (aFrame->GetType() == nsGkAtoms::imageBoxFrame) {
    1:     list->AppendChange(aFrame, aFrame->GetContent(),
    1:                        NS_STYLE_HINT_FRAMECHANGE);
    1:     return PR_FALSE; // don't walk descendants
    1:   }
    1:   return PR_TRUE; // walk descendants
    1: }
    1: 
    1: static void
    1: WalkFramesThroughPlaceholders(nsPresContext *aPresContext, nsIFrame *aFrame,
    1:                               frameWalkerFn aFunc, void *aClosure)
    1: {
    1:   PRBool walkChildren = (*aFunc)(aFrame, aClosure);
    1:   if (!walkChildren)
    1:     return;
    1: 
    1:   PRInt32 listIndex = 0;
    1:   nsIAtom* childList = nsnull;
    1: 
    1:   do {
    1:     nsIFrame *child = aFrame->GetFirstChild(childList);
    1:     while (child) {
    1:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
    1:         // only do frames that are in flow, and recur through the
    1:         // out-of-flows of placeholders.
    1:         WalkFramesThroughPlaceholders(aPresContext,
    1:                                       nsPlaceholderFrame::GetRealFrameFor(child),
    1:                                       aFunc, aClosure);
    1:       }
    1:       child = child->GetNextSibling();
    1:     }
    1: 
    1:     childList = aFrame->GetAdditionalChildListName(listIndex++);
    1:   } while (childList);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: PresShell::Observe(nsISupports* aSubject, 
    1:                    const char* aTopic,
    1:                    const PRUnichar* aData)
    1: {
    1: #ifdef MOZ_XUL
    1:   if (!nsCRT::strcmp(aTopic, "chrome-flush-skin-caches")) {
    1:     nsIFrame *rootFrame = FrameManager()->GetRootFrame();
    1:     // Need to null-check because "chrome-flush-skin-caches" can happen
    1:     // at interesting times during startup.
    1:     if (rootFrame) {
    1:       NS_ASSERTION(mViewManager, "View manager must exist");
10730:       nsIViewManager::UpdateViewBatch batch(mViewManager);
    1: 
    1:       WalkFramesThroughPlaceholders(mPresContext, rootFrame,
    1:                                     &ReResolveMenusAndTrees, nsnull);
    1: 
    1:       // Because "chrome:" URL equality is messy, reframe image box
    1:       // frames (hack!).
    1:       nsStyleChangeList changeList;
    1:       WalkFramesThroughPlaceholders(mPresContext, rootFrame,
    1:                                     ReframeImageBoxes, &changeList);
 7017:       // Mark ourselves as not safe to flush while we're doing frame
 7017:       // construction.
13098:       {
13098:         nsAutoScriptBlocker scriptBlocker;
    1:         mFrameConstructor->ProcessRestyledFrames(changeList);
13098:       }
    1: 
10730:       batch.EndUpdateViewBatch(NS_VMREFRESH_NO_SYNC);
    1: #ifdef ACCESSIBILITY
    1:       InvalidateAccessibleSubtree(nsnull);
    1: #endif
    1:     }
    1:     return NS_OK;
    1:   }
    1: #endif
    1: 
    1:   if (!nsCRT::strcmp(aTopic, NS_LINK_VISITED_EVENT_TOPIC)) {
    1:     nsCOMPtr<nsIURI> uri = do_QueryInterface(aSubject);
    1:     if (uri && mDocument) {
    1:       mDocument->NotifyURIVisitednessChanged(uri);
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "agent-sheet-added") && mStyleSet) {
    1:     AddAgentSheet(aSubject);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "user-sheet-added") && mStyleSet) {
    1:     AddUserSheet(aSubject);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "agent-sheet-removed") && mStyleSet) {
    1:     RemoveSheet(nsStyleSet::eAgentSheet, aSubject);
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!nsCRT::strcmp(aTopic, "user-sheet-removed") && mStyleSet) {
    1:     RemoveSheet(nsStyleSet::eUserSheet, aSubject);
    1:     return NS_OK;
    1:   }
    1: 
 1071: #ifdef ACCESSIBILITY
 1071:   if (!nsCRT::strcmp(aTopic, "a11y-init-or-shutdown")) {
 1071:     gIsAccessibilityActive = aData && *aData == '1';
 1071:   }
 1071: #endif
    1:   NS_WARNING("unrecognized topic in PresShell::Observe");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: void
    1: PresShell::EnumeratePlugins(nsIDOMDocument *aDocument,
    1:                             const nsString &aPluginTag,
    1:                             nsPluginEnumCallback aCallback)
    1: {
    1:   nsCOMPtr<nsIDOMNodeList> nodes;
    1:   aDocument->GetElementsByTagName(aPluginTag, getter_AddRefs(nodes));
    1:   if (!nodes)
    1:     return;
    1: 
    1:   PRUint32 length;
    1:   nodes->GetLength(&length);
    1: 
    1:   for (PRUint32 i = 0; i < length; ++i) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nodes->Item(i, getter_AddRefs(node));
    1: 
    1:     nsCOMPtr<nsIContent> content = do_QueryInterface(node);
    1:     if (content)
    1:       aCallback(this, content);
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------
    1: // End of protected and private methods on the PresShell
    1: //------------------------------------------------------
    1: 
    1: // Start of DEBUG only code
    1: 
    1: #ifdef NS_DEBUG
    1: #include "nsViewsCID.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIURL.h"
    1: #include "nsILinkHandler.h"
    1: 
    1: static NS_DEFINE_CID(kViewManagerCID, NS_VIEW_MANAGER_CID);
    1: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
    1: 
    1: static void
    1: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg)
    1: {
    1:   printf("verifyreflow: ");
    1:   nsAutoString name;
    1:   if (nsnull != k1) {
    1:     nsIFrameDebug*  frameDebug;
    1: 
    1:     if (NS_SUCCEEDED(k1->QueryInterface(NS_GET_IID(nsIFrameDebug),
    1:                                         (void**)&frameDebug))) {
    1:      frameDebug->GetFrameName(name);
    1:     }
    1:   }
    1:   else {
    1:     name.Assign(NS_LITERAL_STRING("(null)"));
    1:   }
    1:   fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
    1: 
  790:   fprintf(stdout, " %p ", (void*)k1);
  790: 
    1:   printf(" != ");
    1: 
    1:   if (nsnull != k2) {
    1:     nsIFrameDebug*  frameDebug;
    1: 
    1:     if (NS_SUCCEEDED(k2->QueryInterface(NS_GET_IID(nsIFrameDebug),
    1:                                         (void**)&frameDebug))) {
    1:       frameDebug->GetFrameName(name);
    1:     }
    1:   }
    1:   else {
    1:     name.Assign(NS_LITERAL_STRING("(null)"));
    1:   }
    1:   fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
    1: 
  790:   fprintf(stdout, " %p ", (void*)k2);
  790: 
    1:   printf(" %s", aMsg);
    1: }
    1: 
    1: static void
    1: LogVerifyMessage(nsIFrame* k1, nsIFrame* k2, const char* aMsg,
    1:                  const nsRect& r1, const nsRect& r2)
    1: {
    1:   printf("VerifyReflow Error:\n");
    1:   nsAutoString name;
    1:   nsIFrameDebug*  frameDebug;
    1: 
    1:   if (NS_SUCCEEDED(k1->QueryInterface(NS_GET_IID(nsIFrameDebug),
    1:                                       (void**)&frameDebug))) {
    1:     fprintf(stdout, "  ");
    1:     frameDebug->GetFrameName(name);
    1:     fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
    1:     fprintf(stdout, " %p ", (void*)k1);
    1:   }
    1:   printf("{%d, %d, %d, %d}", r1.x, r1.y, r1.width, r1.height);
    1: 
    1:   printf(" != \n");
    1: 
    1:   if (NS_SUCCEEDED(k2->QueryInterface(NS_GET_IID(nsIFrameDebug),
    1:                                       (void**)&frameDebug))) {
    1:     fprintf(stdout, "  ");
    1:     frameDebug->GetFrameName(name);
    1:     fputs(NS_LossyConvertUTF16toASCII(name).get(), stdout);
    1:     fprintf(stdout, " %p ", (void*)k2);
    1:   }
    1:   printf("{%d, %d, %d, %d}\n", r2.x, r2.y, r2.width, r2.height);
    1: 
    1:   printf("  %s\n", aMsg);
    1: }
    1: 
    1: static PRBool
    1: CompareTrees(nsPresContext* aFirstPresContext, nsIFrame* aFirstFrame, 
    1:              nsPresContext* aSecondPresContext, nsIFrame* aSecondFrame)
    1: {
    1:   if (!aFirstPresContext || !aFirstFrame || !aSecondPresContext || !aSecondFrame)
    1:     return PR_TRUE;
 1735:   // XXX Evil hack to reduce false positives; I can't seem to figure
 1735:   // out how to flush scrollbar changes correctly
 1735:   //if (aFirstFrame->GetType() == nsGkAtoms::scrollbarFrame)
 1735:   //  return PR_TRUE;
    1:   PRBool ok = PR_TRUE;
    1:   nsIAtom* listName = nsnull;
    1:   PRInt32 listIndex = 0;
    1:   do {
    1:     nsIFrame* k1 = aFirstFrame->GetFirstChild(listName);
    1:     nsIFrame* k2 = aSecondFrame->GetFirstChild(listName);
    1:     PRInt32 l1 = nsContainerFrame::LengthOf(k1);
    1:     PRInt32 l2 = nsContainerFrame::LengthOf(k2);
    1:     if (l1 != l2) {
    1:       ok = PR_FALSE;
    1:       LogVerifyMessage(k1, k2, "child counts don't match: ");
    1:       printf("%d != %d\n", l1, l2);
    1:       if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
    1:         break;
    1:       }
    1:     }
    1: 
19835:     nsRect r1, r2;
    1:     nsIView* v1, *v2;
    1:     for (;;) {
    1:       if (((nsnull == k1) && (nsnull != k2)) ||
    1:           ((nsnull != k1) && (nsnull == k2))) {
    1:         ok = PR_FALSE;
    1:         LogVerifyMessage(k1, k2, "child lists are different\n");
    1:         break;
    1:       }
    1:       else if (nsnull != k1) {
    1:         // Verify that the frames are the same size
    1:         if (k1->GetRect() != k2->GetRect()) {
    1:           ok = PR_FALSE;
    1:           LogVerifyMessage(k1, k2, "(frame rects)", k1->GetRect(), k2->GetRect());
    1:         }
    1: 
    1:         // Make sure either both have views or neither have views; if they
    1:         // do have views, make sure the views are the same size. If the
    1:         // views have widgets, make sure they both do or neither does. If
    1:         // they do, make sure the widgets are the same size.
    1:         v1 = k1->GetView();
    1:         v2 = k2->GetView();
    1:         if (((nsnull == v1) && (nsnull != v2)) ||
    1:             ((nsnull != v1) && (nsnull == v2))) {
    1:           ok = PR_FALSE;
    1:           LogVerifyMessage(k1, k2, "child views are not matched\n");
    1:         }
    1:         else if (nsnull != v1) {
    1:           if (v1->GetBounds() != v2->GetBounds()) {
    1:             LogVerifyMessage(k1, k2, "(view rects)", v1->GetBounds(), v2->GetBounds());
    1:           }
    1: 
    1:           nsIWidget* w1 = v1->GetWidget();
    1:           nsIWidget* w2 = v2->GetWidget();
    1:           if (((nsnull == w1) && (nsnull != w2)) ||
    1:               ((nsnull != w1) && (nsnull == w2))) {
    1:             ok = PR_FALSE;
    1:             LogVerifyMessage(k1, k2, "child widgets are not matched\n");
    1:           }
    1:           else if (nsnull != w1) {
    1:             w1->GetBounds(r1);
    1:             w2->GetBounds(r2);
    1:             if (r1 != r2) {
    1:               LogVerifyMessage(k1, k2, "(widget rects)", r1, r2);
    1:             }
    1:           }
    1:         }
    1:         if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
    1:           break;
    1:         }
    1: 
    1:         // verify that neither frame has a space manager,
    1:         // or they both do and the space managers are equivalent
 3233:         nsSpaceManager *sm1 = static_cast<nsSpaceManager*>
 3233:                                          (k1->GetProperty(nsGkAtoms::spaceManagerProperty));
    1: 
    1:         // look at the test frame
 3233:         nsSpaceManager *sm2 = static_cast<nsSpaceManager*>
 3233:                                          (k2->GetProperty(nsGkAtoms::spaceManagerProperty));
    1: 
    1:         // now compare the space managers
    1:         if (((nsnull == sm1) && (nsnull != sm2)) ||
    1:             ((nsnull != sm1) && (nsnull == sm2))) {   // one is null, and the other is not
    1:           ok = PR_FALSE;
    1:           LogVerifyMessage(k1, k2, "space managers are not matched\n");
    1:         }
    1:         else if (sm1 && sm2) {  // both are not null, compare them
    1:           // first, compare yMost
    1:           nscoord yMost1, yMost2;
    1:           nsresult smresult = sm1->YMost(yMost1);
    1:           if (NS_ERROR_ABORT != smresult)
    1:           {
    1:             NS_ASSERTION(NS_SUCCEEDED(smresult), "bad result");
    1:             smresult = sm2->YMost(yMost2);
    1:             NS_ASSERTION(NS_SUCCEEDED(smresult), "bad result");
    1:             if (yMost1 != yMost2) {
    1:               LogVerifyMessage(k1, k2, "yMost of space managers differs\n");
    1:             }
    1:             // now compare bands by sampling
    1:             PRInt32 yIncrement = yMost1/100;
    1:             if (0==yIncrement) {
    1:               yIncrement = 1;   // guarantee we make progress in the loop below
    1:             }
    1:             nscoord yOffset = 0;
    1:             for ( ; ok && yOffset < yMost1; yOffset += yIncrement)
    1:             {
    1:               nscoord small=5, large=100;
    1:               nsBandData band1, band2;
    1:               nsBandTrapezoid trap1[20], trap2[20];
    1:               band1.mSize = band2.mSize = 20;
    1:               band1.mTrapezoids = trap1;  
    1:               band2.mTrapezoids = trap2;
    1:               sm1->GetBandData(yOffset, nsSize(small,small), band1);
    1:               sm2->GetBandData(yOffset, nsSize(small,small), band2);
    1:               if (band1.mCount != band2.mCount) 
    1:               { // count mismatch, stop comparing
    1:                 LogVerifyMessage(k1, k2, "band.mCount of space managers differs\n");
    1:                 printf("count1= %d, count2=%d, yOffset = %d, size=%d\n",
    1:                         band1.mCount, band2.mCount, yOffset, small);
    1:                 ok = PR_FALSE;
    1:                       
    1:               }
    1:               else   // band counts match, compare individual traps
    1:               { 
    1:                 PRInt32 trapIndex=0;
    1:                 for ( ;trapIndex<band1.mCount; trapIndex++)
    1:                 {
    1:                   PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && 
 5461:                     ((trap1[trapIndex].mFrames!=nsnull) == (trap2[trapIndex].mFrames!=nsnull));
    1:                   if (!match)
    1:                   {
    1:                     LogVerifyMessage(k1, k2, "band.mTrapezoids of space managers differs\n");
    1:                     printf ("index %d\n", trapIndex);
    1:                   }
    1:                 }
    1:               }
    1:               // test the larger maxSize
    1:               sm1->GetBandData(yOffset, nsSize(large,large), band1);
    1:               sm2->GetBandData(yOffset, nsSize(large,large), band2);
    1:               if (band1.mCount != band2.mCount) 
    1:               { // count mismatch, stop comparing
    1:                 LogVerifyMessage(k1, k2, "band.mCount of space managers differs\n");
    1:                 printf("count1= %d, count2=%d, yOffset = %d, size=%d\n",
    1:                         band1.mCount, band2.mCount, yOffset, small);
    1:                 ok = PR_FALSE;
    1:                       
    1:               }
    1:               else   // band counts match, compare individual traps
    1:               { 
    1:                 PRInt32 trapIndex=0;
    1:                 for ( ; trapIndex<band1.mCount; trapIndex++)
    1:                 {
    1:                   PRBool match = (trap1[trapIndex].EqualGeometry(trap2[trapIndex])) && 
 5461:                     ((trap1[trapIndex].mFrames!=nsnull) == (trap2[trapIndex].mFrames!=nsnull));
    1:                   if (!match)
    1:                   {
    1:                     LogVerifyMessage(k1, k2, "band.mTrapezoids of space managers differs\n");
    1:                     printf ("index %d\n", trapIndex);
    1:                   }
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1: 
    1: 
    1: 
    1: 
    1:         // Compare the sub-trees too
    1:         if (!CompareTrees(aFirstPresContext, k1, aSecondPresContext, k2)) {
    1:           ok = PR_FALSE;
    1:           if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
    1:             break;
    1:           }
    1:         }
    1: 
    1:         // Advance to next sibling
    1:         k1 = k1->GetNextSibling();
    1:         k2 = k2->GetNextSibling();
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1:     if (!ok && (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags))) {
    1:       break;
    1:     }
    1: 
    1:     nsIAtom* listName1 = aFirstFrame->GetAdditionalChildListName(listIndex);
    1:     nsIAtom* listName2 = aSecondFrame->GetAdditionalChildListName(listIndex);
    1:     listIndex++;
    1:     if (listName1 != listName2) {
    1:       if (0 == (VERIFY_REFLOW_ALL & gVerifyReflowFlags)) {
    1:         ok = PR_FALSE;
    1:       }
    1:       LogVerifyMessage(k1, k2, "child list names are not matched: ");
    1:       nsAutoString tmp;
    1:       if (nsnull != listName1) {
    1:         listName1->ToString(tmp);
    1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), stdout);
    1:       }
    1:       else
    1:         fputs("(null)", stdout);
    1:       printf(" != ");
    1:       if (nsnull != listName2) {
    1:         listName2->ToString(tmp);
    1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), stdout);
    1:       }
    1:       else
    1:         fputs("(null)", stdout);
    1:       printf("\n");
    1:       break;
    1:     }
    1:     listName = listName1;
    1:   } while (ok && (listName != nsnull));
    1: 
    1:   return ok;
    1: }
    1: #endif
    1: 
    1: #if 0
    1: static nsIFrame*
    1: FindTopFrame(nsIFrame* aRoot)
    1: {
    1:   if (aRoot) {
    1:     nsIContent* content = aRoot->GetContent();
    1:     if (content) {
    1:       nsIAtom* tag;
    1:       content->GetTag(tag);
    1:       if (nsnull != tag) {
    1:         NS_RELEASE(tag);
    1:         return aRoot;
    1:       }
    1:     }
    1: 
    1:     // Try one of the children
    1:     nsIFrame* kid = aRoot->GetFirstChild(nsnull);
    1:     while (nsnull != kid) {
    1:       nsIFrame* result = FindTopFrame(kid);
    1:       if (nsnull != result) {
    1:         return result;
    1:       }
    1:       kid = kid->GetNextSibling();
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: #endif
    1: 
    1: 
    1: #ifdef DEBUG
    1: 
    1: nsresult
    1: PresShell::CloneStyleSet(nsStyleSet* aSet, nsStyleSet** aResult)
    1: {
    1:   nsStyleSet *clone = new nsStyleSet();
    1:   if (!clone) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   PRInt32 i, n = aSet->SheetCount(nsStyleSet::eOverrideSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eOverrideSheet, i);
    1:     if (ss)
    1:       clone->AppendStyleSheet(nsStyleSet::eOverrideSheet, ss);
    1:   }
    1: 
 1735:   // The document expects to insert document stylesheets itself
 1735: #if 0
    1:   n = aSet->SheetCount(nsStyleSet::eDocSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eDocSheet, i);
    1:     if (ss)
    1:       clone->AddDocStyleSheet(ss, mDocument);
    1:   }
 1735: #endif
 1735: 
    1:   n = aSet->SheetCount(nsStyleSet::eUserSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eUserSheet, i);
    1:     if (ss)
    1:       clone->AppendStyleSheet(nsStyleSet::eUserSheet, ss);
    1:   }
    1: 
    1:   n = aSet->SheetCount(nsStyleSet::eAgentSheet);
    1:   for (i = 0; i < n; i++) {
    1:     nsIStyleSheet* ss = aSet->StyleSheetAt(nsStyleSet::eAgentSheet, i);
    1:     if (ss)
    1:       clone->AppendStyleSheet(nsStyleSet::eAgentSheet, ss);
    1:   }
    1:   *aResult = clone;
    1:   return NS_OK;
    1: }
    1: 
 1735: #ifdef DEBUG_Eli
 1735: static nsresult
 1735: DumpToPNG(nsIPresShell* shell, nsAString& name) {
 1735:   PRInt32 width=1000, height=1000;
 1735:   nsRect r(0, 0, shell->GetPresContext()->DevPixelsToAppUnits(width),
 1735:                  shell->GetPresContext()->DevPixelsToAppUnits(height));
 1735: 
 1735:   nsRefPtr<gfxImageSurface> imgSurface =
 1735:      new gfxImageSurface(gfxIntSize(width, height),
 1735:                          gfxImageSurface::ImageFormatARGB32);
 1735:   NS_ENSURE_TRUE(imgSurface, NS_ERROR_OUT_OF_MEMORY);
 1735: 
 1735:   nsRefPtr<gfxContext> imgContext = new gfxContext(imgSurface);
 1735: 
 1735:   nsRefPtr<gfxASurface> surface = 
 1735:     gfxPlatform::GetPlatform()->
 1735:     CreateOffscreenSurface(gfxIntSize(width, height),
 1735:       gfxASurface::ImageFormatARGB32);
 1735:   NS_ENSURE_TRUE(surface, NS_ERROR_OUT_OF_MEMORY);
 1735: 
 1735:   nsRefPtr<gfxContext> context = new gfxContext(surface);
 1735:   NS_ENSURE_TRUE(context, NS_ERROR_OUT_OF_MEMORY);
 1735: 
22950:   nsresult rv = shell->RenderDocument(r, 0, NS_RGB(255, 255, 0), context);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   imgContext->DrawSurface(surface, gfxSize(width, height));
 1735: 
 1735:   nsCOMPtr<imgIEncoder> encoder = do_CreateInstance("@mozilla.org/image/encoder;2?type=image/png");
 1735:   NS_ENSURE_TRUE(encoder, NS_ERROR_FAILURE);
 1735:   encoder->InitFromData(imgSurface->Data(), imgSurface->Stride() * height,
 1735:                         width, height, imgSurface->Stride(),
 1735:                         imgIEncoder::INPUT_FORMAT_HOSTARGB, EmptyString());
 1735: 
 1735:   // XXX not sure if this is the right way to write to a file
 1735:   nsCOMPtr<nsILocalFile> file = do_CreateInstance("@mozilla.org/file/local;1");
 1735:   NS_ENSURE_TRUE(file, NS_ERROR_FAILURE);
 1735:   rv = file->InitWithPath(name);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   PRUint32 length;
 1735:   encoder->Available(&length);
 1735: 
 1735:   nsCOMPtr<nsIOutputStream> outputStream;
 1735:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(outputStream), file);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   nsCOMPtr<nsIOutputStream> bufferedOutputStream;
 1735:   rv = NS_NewBufferedOutputStream(getter_AddRefs(bufferedOutputStream),
 1735:                                   outputStream, length);
 1735: 
 1735:   PRUint32 numWritten;
 1735:   rv = bufferedOutputStream->WriteFrom(encoder, length, &numWritten);
 1735:   NS_ENSURE_SUCCESS(rv, rv);
 1735: 
 1735:   return NS_OK;
 1735: }
 1735: #endif
 1735: 
    1: // After an incremental reflow, we verify the correctness by doing a
    1: // full reflow into a fresh frame tree.
    1: PRBool
    1: PresShell::VerifyIncrementalReflow()
    1: {
    1:    if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:      printf("Building Verification Tree...\n");
    1:    }
    1: 
    1:   // Create a presentation context to view the new frame tree
  790:   nsCOMPtr<nsPresContext> cx =
  790:        new nsPresContext(mDocument, mPresContext->IsPaginated() ?
    1:                                         nsPresContext::eContext_PrintPreview :
  790:                                         nsPresContext::eContext_Galley);
  790:   NS_ENSURE_TRUE(cx, PR_FALSE);
    1: 
    1:   nsIDeviceContext *dc = mPresContext->DeviceContext();
    1:   nsresult rv = cx->Init(dc);
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   // Get our scrolling preference
    1:   nsIView* rootView;
    1:   mViewManager->GetRootView(rootView);
    1:   void* nativeParentWidget = rootView->GetWidget()->GetNativeData(NS_NATIVE_WIDGET);
    1: 
    1:   // Create a new view manager.
  790:   nsCOMPtr<nsIViewManager> vm = do_CreateInstance(kViewManagerCID);
  790:   NS_ENSURE_TRUE(vm, PR_FALSE);
    1:   rv = vm->Init(dc);
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   // Create a child window of the parent that is our "root view/window"
    1:   // Create a view
    1:   nsRect tbounds = mPresContext->GetVisibleArea();
    1:   nsIView* view = vm->CreateView(tbounds, nsnull);
  790:   NS_ENSURE_TRUE(view, PR_FALSE);
    1: 
    1:   //now create the widget for the view
    1:   rv = view->CreateWidget(kWidgetCID, nsnull, nativeParentWidget, PR_TRUE);
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:   // Setup hierarchical relationship in view manager
    1:   vm->SetRootView(view);
    1: 
    1:   // Make the new presentation context the same size as our
    1:   // presentation context.
    1:   nsRect r = mPresContext->GetVisibleArea();
    1:   cx->SetVisibleArea(r);
    1: 
    1:   // Create a new presentation shell to view the document. Use the
    1:   // exact same style information that this document has.
    1:   nsAutoPtr<nsStyleSet> newSet;
    1:   rv = CloneStyleSet(mStyleSet, getter_Transfers(newSet));
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
  790:   nsCOMPtr<nsIPresShell> sh;
  790:   rv = mDocument->CreateShell(cx, vm, newSet, getter_AddRefs(sh));
  790:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
  790:   newSet.forget();
  790:   // Note that after we create the shell, we must make sure to destroy it
    1:   sh->SetVerifyReflowEnable(PR_FALSE); // turn off verify reflow while we're reflowing the test frame tree
  790:   vm->SetViewObserver((nsIViewObserver *)((PresShell*)sh.get()));
22979:   {
22979:     nsAutoScriptBlocker scriptBlocker;
  790:     sh->InitialReflow(r.width, r.height);
22979:   }
  790:   mDocument->BindingManager()->ProcessAttachedQueue();
  790:   sh->FlushPendingNotifications(Flush_Layout);
    1:   sh->SetVerifyReflowEnable(PR_TRUE);  // turn on verify reflow again now that we're done reflowing the test frame tree
 1735:   // Force the non-primary presshell to unsuppress; it doesn't want to normally
 1735:   // because it thinks it's hidden
 1735:   ((PresShell*)sh.get())->mPaintingSuppressed = PR_FALSE;
    1:   if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:      printf("Verification Tree built, comparing...\n");
    1:   }
    1: 
    1:   // Now that the document has been reflowed, use its frame tree to
    1:   // compare against our frame tree.
    1:   nsIFrame* root1 = FrameManager()->GetRootFrame();
    1:   nsIFrame* root2 = sh->FrameManager()->GetRootFrame();
    1:   PRBool ok = CompareTrees(mPresContext, root1, cx, root2);
    1:   if (!ok && (VERIFY_REFLOW_NOISY & gVerifyReflowFlags)) {
    1:     printf("Verify reflow failed, primary tree:\n");
    1:     nsIFrameDebug*  frameDebug;
    1: 
  790:     if (NS_SUCCEEDED(CallQueryInterface(root1, &frameDebug))) {
    1:       frameDebug->List(stdout, 0);
    1:     }
    1:     printf("Verification tree:\n");
  790:     if (NS_SUCCEEDED(CallQueryInterface(root2, &frameDebug))) {
    1:       frameDebug->List(stdout, 0);
    1:     }
    1:   }
    1: 
 1735: #ifdef DEBUG_Eli
 1735:   // Sample code for dumping page to png
 1735:   // XXX Needs to be made more flexible
 1735:   if (!ok) {
 1735:     nsString stra;
 1735:     static int num = 0;
 1735:     stra.AppendLiteral("C:\\mozilla\\mozilla\\debug\\filea");
 1735:     stra.AppendInt(num);
 1735:     stra.AppendLiteral(".png");
 1735:     DumpToPNG(sh, stra);
 1735:     nsString strb;
 1735:     strb.AppendLiteral("C:\\mozilla\\mozilla\\debug\\fileb");
 1735:     strb.AppendInt(num);
 1735:     strb.AppendLiteral(".png");
 1735:     DumpToPNG(this, strb);
 1735:     ++num;
 1735:   }
 1735: #endif
 1735: 
    1:   sh->EndObservingDocument();
  790:   sh->Destroy();
    1:   if (VERIFY_REFLOW_NOISY & gVerifyReflowFlags) {
    1:     printf("Finished Verifying Reflow...\n");
    1:   }
    1: 
    1:   return ok;
    1: }
    1: 
    1: // Layout debugging hooks
    1: void
    1: PresShell::ListStyleContexts(nsIFrame *aRootFrame, FILE *out, PRInt32 aIndent)
    1: {
    1:   nsStyleContext *sc = aRootFrame->GetStyleContext();
    1:   if (sc)
    1:     sc->List(out, aIndent);
    1: }
    1: 
    1: void
    1: PresShell::ListStyleSheets(FILE *out, PRInt32 aIndent)
    1: {
    1:   PRInt32 sheetCount = mStyleSet->SheetCount(nsStyleSet::eDocSheet);
    1:   for (PRInt32 i = 0; i < sheetCount; ++i) {
    1:     mStyleSet->StyleSheetAt(nsStyleSet::eDocSheet, i)->List(out, aIndent);
    1:     fputs("\n", out);
    1:   }
    1: }
    1: 
    1: void
    1: PresShell::VerifyStyleTree()
    1: {
    1:   VERIFY_STYLE_TREE;
    1: }
    1: #endif
    1: 
    1: //=============================================================
    1: //=============================================================
    1: //-- Debug Reflow Counts
    1: //=============================================================
    1: //=============================================================
    1: #ifdef MOZ_REFLOW_PERF
    1: //-------------------------------------------------------------
    1: NS_IMETHODIMP
    1: PresShell::DumpReflows()
    1: {
    1:   if (mReflowCountMgr) {
    1:     nsCAutoString uriStr;
    1:     if (mDocument) {
    1:       nsIURI *uri = mDocument->GetDocumentURI();
    1:       if (uri) {
    1:         uri->GetPath(uriStr);
    1:       }
    1:     }
    1:     mReflowCountMgr->DisplayTotals(uriStr.get());
    1:     mReflowCountMgr->DisplayHTMLTotals(uriStr.get());
    1:     mReflowCountMgr->DisplayDiffsInTotals("Differences");
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------
    1: NS_IMETHODIMP
    1: PresShell::CountReflows(const char * aName, nsIFrame * aFrame)
    1: {
    1:   if (mReflowCountMgr) {
    1:     mReflowCountMgr->Add(aName, aFrame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------
    1: NS_IMETHODIMP
    1: PresShell::PaintCount(const char * aName, nsIRenderingContext* aRenderingContext, nsPresContext* aPresContext, nsIFrame * aFrame, PRUint32 aColor)
    1: {
    1:   if (mReflowCountMgr) {
    1:     mReflowCountMgr->PaintCount(aName, aRenderingContext, aPresContext, aFrame, aColor);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------------
    1: NS_IMETHODIMP
    1: PresShell::SetPaintFrameCount(PRBool aPaintFrameCounts)
    1: { 
    1:   if (mReflowCountMgr) {
    1:     mReflowCountMgr->SetPaintFrameCounts(aPaintFrameCounts);
    1:   }
    1:   return NS_OK; 
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: //-- Reflow Counter Classes Impls
    1: //------------------------------------------------------------------
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCounter::ReflowCounter(ReflowCountMgr * aMgr) :
    1:   mMgr(aMgr)
    1: {
    1:   ClearTotals();
    1:   SetTotalsCache();
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCounter::~ReflowCounter()
    1: {
    1:   
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::ClearTotals()
    1: {
    1:   mTotal = 0;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::SetTotalsCache()
    1: {
    1:   mCacheTotal = mTotal;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::CalcDiffInTotals()
    1: {
    1:   mCacheTotal = mTotal - mCacheTotal;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayTotals(const char * aStr)
    1: {
    1:   DisplayTotals(mTotal, aStr?aStr:"Totals");
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayDiffTotals(const char * aStr)
    1: {
    1:   DisplayTotals(mCacheTotal, aStr?aStr:"Diff Totals");
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayHTMLTotals(const char * aStr)
    1: {
    1:   DisplayHTMLTotals(mTotal, aStr?aStr:"Totals");
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayTotals(PRUint32 aTotal, const char * aTitle)
    1: {
    1:   // figure total
    1:   if (aTotal == 0) {
    1:     return;
    1:   }
    1:   ReflowCounter * gTots = (ReflowCounter *)mMgr->LookUp(kGrandTotalsStr);
    1: 
    1:   printf("%25s\t", aTitle);
    1:   printf("%d\t", aTotal);
    1:   if (gTots != this && aTotal > 0) {
    1:     gTots->Add(aTotal);
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCounter::DisplayHTMLTotals(PRUint32 aTotal, const char * aTitle)
    1: {
    1:   if (aTotal == 0) {
    1:     return;
    1:   }
    1: 
    1:   ReflowCounter * gTots = (ReflowCounter *)mMgr->LookUp(kGrandTotalsStr);
    1:   FILE * fd = mMgr->GetOutFile();
    1:   if (!fd) {
    1:     return;
    1:   }
    1: 
    1:   fprintf(fd, "<tr><td><center>%s</center></td>", aTitle);
    1:   fprintf(fd, "<td><center>%d</center></td></tr>\n", aTotal);
    1: 
    1:   if (gTots != this && aTotal > 0) {
    1:     gTots->Add(aTotal);
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: //-- ReflowCountMgr
    1: //------------------------------------------------------------------
    1: ReflowCountMgr::ReflowCountMgr()
    1: {
    1:   mCounts = PL_NewHashTable(10, PL_HashString, PL_CompareStrings, 
    1:                                 PL_CompareValues, nsnull, nsnull);
    1:   mIndiFrameCounts = PL_NewHashTable(10, PL_HashString, PL_CompareStrings, 
    1:                                      PL_CompareValues, nsnull, nsnull);
    1:   mCycledOnce              = PR_FALSE;
    1:   mDumpFrameCounts         = PR_FALSE;
    1:   mDumpFrameByFrameCounts  = PR_FALSE;
    1:   mPaintFrameByFrameCounts = PR_FALSE;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCountMgr::~ReflowCountMgr()
    1: {
    1:   CleanUp();
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: ReflowCounter * ReflowCountMgr::LookUp(const char * aName)
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * counter = (ReflowCounter *)PL_HashTableLookup(mCounts, aName);
    1:     return counter;
    1:   }
    1:   return nsnull;
    1: 
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::Add(const char * aName, nsIFrame * aFrame)
    1: {
    1:   NS_ASSERTION(aName != nsnull, "Name shouldn't be null!");
    1: 
    1:   if (mDumpFrameCounts && nsnull != mCounts) {
    1:     ReflowCounter * counter = (ReflowCounter *)PL_HashTableLookup(mCounts, aName);
    1:     if (counter == nsnull) {
    1:       counter = new ReflowCounter(this);
    1:       NS_ASSERTION(counter != nsnull, "null ptr");
    1:       char * name = NS_strdup(aName);
    1:       NS_ASSERTION(name != nsnull, "null ptr");
    1:       PL_HashTableAdd(mCounts, name, counter);
    1:     }
    1:     counter->Add();
    1:   }
    1: 
    1:   if ((mDumpFrameByFrameCounts || mPaintFrameByFrameCounts) && 
    1:       nsnull != mIndiFrameCounts && 
    1:       aFrame != nsnull) {
    1:     char * key = new char[16];
    1:     sprintf(key, "%p", (void*)aFrame);
    1:     IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(mIndiFrameCounts, key);
    1:     if (counter == nsnull) {
    1:       counter = new IndiReflowCounter(this);
    1:       NS_ASSERTION(counter != nsnull, "null ptr");
    1:       counter->mFrame = aFrame;
    1:       counter->mName.AssignASCII(aName);
    1:       PL_HashTableAdd(mIndiFrameCounts, key, counter);
    1:     }
    1:     // this eliminates extra counts from super classes
    1:     if (counter != nsnull && counter->mName.EqualsASCII(aName)) {
    1:       counter->mCount++;
    1:       counter->mCounter.Add(1);
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::PaintCount(const char *    aName, 
    1:                                 nsIRenderingContext* aRenderingContext, 
    1:                                 nsPresContext* aPresContext, 
    1:                                 nsIFrame*       aFrame, 
    1:                                 PRUint32        aColor)
    1: {
    1:   if (mPaintFrameByFrameCounts && 
    1:       nsnull != mIndiFrameCounts && 
    1:       aFrame != nsnull) {
    1:     char * key = new char[16];
    1:     sprintf(key, "%p", (void*)aFrame);
    1:     IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(mIndiFrameCounts, key);
    1:     if (counter != nsnull && counter->mName.EqualsASCII(aName)) {
    1:       aRenderingContext->PushState();
    1:       nsFont font("Times", NS_FONT_STYLE_NORMAL, NS_FONT_VARIANT_NORMAL,
    1:                   NS_FONT_WEIGHT_NORMAL, 0,
    1:                   nsPresContext::CSSPixelsToAppUnits(11));
    1: 
    1:       nsCOMPtr<nsIFontMetrics> fm = aPresContext->GetMetricsFor(font);
    1:       aRenderingContext->SetFont(fm);
    1:       char buf[16];
    1:       sprintf(buf, "%d", counter->mCount);
    1:       nscoord x = 0, y;
    1:       nscoord width, height;
    1:       aRenderingContext->SetTextRunRTL(PR_FALSE);
    1:       aRenderingContext->GetWidth((char*)buf, width);
    1:       fm->GetHeight(height);
    1:       fm->GetMaxAscent(y);
    1: 
    1:       PRUint32 color;
    1:       PRUint32 color2;
    1:       if (aColor != 0) {
    1:         color  = aColor;
    1:         color2 = NS_RGB(0,0,0);
    1:       } else {
    1:         PRUint8 rc = 0, gc = 0, bc = 0;
    1:         if (counter->mCount < 5) {
    1:           rc = 255;
    1:           gc = 255;
    1:         } else if ( counter->mCount < 11) {
    1:           gc = 255;
    1:         } else {
    1:           rc = 255;
    1:         }
    1:         color  = NS_RGB(rc,gc,bc);
    1:         color2 = NS_RGB(rc/2,gc/2,bc/2);
    1:       }
    1: 
    1:       nsRect rect(0,0, width+15, height+15);
    1:       aRenderingContext->SetColor(NS_RGB(0,0,0));
    1:       aRenderingContext->FillRect(rect);
    1:       aRenderingContext->SetColor(color2);
    1:       aRenderingContext->DrawString(buf, strlen(buf), x+15,y+15);
    1:       aRenderingContext->SetColor(color);
    1:       aRenderingContext->DrawString(buf, strlen(buf), x,y);
    1: 
    1:       aRenderingContext->PopState();
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::RemoveItems(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1:   delete counter;
    1:   NS_Free(str);
    1: 
    1:   return HT_ENUMERATE_REMOVE;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::RemoveIndiItems(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
    1:   delete counter;
    1:   NS_Free(str);
    1: 
    1:   return HT_ENUMERATE_REMOVE;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::CleanUp()
    1: {
    1:   if (nsnull != mCounts) {
    1:     PL_HashTableEnumerateEntries(mCounts, RemoveItems, nsnull);
    1:     PL_HashTableDestroy(mCounts);
    1:     mCounts = nsnull;
    1:   }
    1: 
    1:   if (nsnull != mIndiFrameCounts) {
    1:     PL_HashTableEnumerateEntries(mIndiFrameCounts, RemoveIndiItems, nsnull);
    1:     PL_HashTableDestroy(mIndiFrameCounts);
    1:     mIndiFrameCounts = nsnull;
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoSingleTotal(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1: 
    1:   counter->DisplayTotals(str);
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DoGrandTotals()
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
    1:     if (gTots == nsnull) {
    1:       gTots = new ReflowCounter(this);
    1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
    1:     } else {
    1:       gTots->ClearTotals();
    1:     }
    1: 
    1:     printf("\t\t\t\tTotal\n");
    1:     for (PRUint32 i=0;i<78;i++) {
    1:       printf("-");
    1:     }
    1:     printf("\n");
    1:     PL_HashTableEnumerateEntries(mCounts, DoSingleTotal, this);
    1:   }
    1: }
    1: 
    1: static void RecurseIndiTotals(nsPresContext* aPresContext, 
    1:                               PLHashTable *   aHT, 
    1:                               nsIFrame *      aParentFrame,
    1:                               PRInt32         aLevel)
    1: {
    1:   if (aParentFrame == nsnull) {
    1:     return;
    1:   }
    1: 
    1:   char key[16];
    1:   sprintf(key, "%p", (void*)aParentFrame);
    1:   IndiReflowCounter * counter = (IndiReflowCounter *)PL_HashTableLookup(aHT, key);
    1:   if (counter) {
    1:     counter->mHasBeenOutput = PR_TRUE;
    1:     char * name = ToNewCString(counter->mName);
    1:     for (PRInt32 i=0;i<aLevel;i++) printf(" ");
    1:     printf("%s - %p   [%d][", name, (void*)aParentFrame, counter->mCount);
    1:     printf("%d", counter->mCounter.GetTotal());
    1:     printf("]\n");
    1:     nsMemory::Free(name);
    1:   }
    1: 
    1:   nsIFrame* child = aParentFrame->GetFirstChild(nsnull);
    1:   while (child) {
    1:     RecurseIndiTotals(aPresContext, aHT, child, aLevel+1);
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoSingleIndi(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
    1:   if (counter && !counter->mHasBeenOutput) {
    1:     char * name = ToNewCString(counter->mName);
    1:     printf("%s - %p   [%d][", name, (void*)counter->mFrame, counter->mCount);
    1:     printf("%d", counter->mCounter.GetTotal());
    1:     printf("]\n");
    1:     nsMemory::Free(name);
    1:   }
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DoIndiTotalsTree()
    1: {
    1:   if (nsnull != mCounts) {
    1:     printf("\n------------------------------------------------\n");
    1:     printf("-- Individual Frame Counts\n");
    1:     printf("------------------------------------------------\n");
    1: 
    1:     if (mPresShell) {
    1:       nsIFrame * rootFrame = mPresShell->FrameManager()->GetRootFrame();
    1:       RecurseIndiTotals(mPresContext, mIndiFrameCounts, rootFrame, 0);
    1:       printf("------------------------------------------------\n");
    1:       printf("-- Individual Counts of Frames not in Root Tree\n");
    1:       printf("------------------------------------------------\n");
    1:       PL_HashTableEnumerateEntries(mIndiFrameCounts, DoSingleIndi, this);
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoSingleHTMLTotal(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1: 
    1:   counter->DisplayHTMLTotals(str);
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DoGrandHTMLTotals()
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
    1:     if (gTots == nsnull) {
    1:       gTots = new ReflowCounter(this);
    1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
    1:     } else {
    1:       gTots->ClearTotals();
    1:     }
    1: 
    1:     static const char * title[] = {"Class", "Reflows"};
    1:     fprintf(mFD, "<tr>");
    1:     for (PRUint32 i=0; i < NS_ARRAY_LENGTH(title); i++) {
    1:       fprintf(mFD, "<td><center><b>%s<b></center></td>", title[i]);
    1:     }
    1:     fprintf(mFD, "</tr>\n");
    1:     PL_HashTableEnumerateEntries(mCounts, DoSingleHTMLTotal, this);
    1:   }
    1: }
    1: 
    1: //------------------------------------
    1: void ReflowCountMgr::DisplayTotals(const char * aStr)
    1: {
    1: #ifdef DEBUG_rods
    1:   printf("%s\n", aStr?aStr:"No name");
    1: #endif
    1:   if (mDumpFrameCounts) {
    1:     DoGrandTotals();
    1:   }
    1:   if (mDumpFrameByFrameCounts) {
    1:     DoIndiTotalsTree();
    1:   }
    1: 
    1: }
    1: //------------------------------------
    1: void ReflowCountMgr::DisplayHTMLTotals(const char * aStr)
    1: {
    1: #ifdef WIN32x // XXX NOT XP!
    1:   char name[1024];
    1:   
    1:   char * sptr = strrchr(aStr, '/');
    1:   if (sptr) {
    1:     sptr++;
    1:     strcpy(name, sptr);
    1:     char * eptr = strrchr(name, '.');
    1:     if (eptr) {
    1:       *eptr = 0;
    1:     }
    1:     strcat(name, "_stats.html");
    1:   }
    1:   mFD = fopen(name, "w");
    1:   if (mFD) {
    1:     fprintf(mFD, "<html><head><title>Reflow Stats</title></head><body>\n");
    1:     const char * title = aStr?aStr:"No name";
    1:     fprintf(mFD, "<center><b>%s</b><br><table border=1 style=\"background-color:#e0e0e0\">", title);
    1:     DoGrandHTMLTotals();
    1:     fprintf(mFD, "</center></table>\n");
    1:     fprintf(mFD, "</body></html>\n");
    1:     fclose(mFD);
    1:     mFD = nsnull;
    1:   }
    1: #endif // not XP!
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoClearTotals(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1:   counter->ClearTotals();
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::ClearTotals()
    1: {
    1:   PL_HashTableEnumerateEntries(mCounts, DoClearTotals, this);
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::ClearGrandTotals()
    1: {
    1:   if (nsnull != mCounts) {
    1:     ReflowCounter * gTots = (ReflowCounter *)PL_HashTableLookup(mCounts, kGrandTotalsStr);
    1:     if (gTots == nsnull) {
    1:       gTots = new ReflowCounter(this);
    1:       PL_HashTableAdd(mCounts, NS_strdup(kGrandTotalsStr), gTots);
    1:     } else {
    1:       gTots->ClearTotals();
    1:       gTots->SetTotalsCache();
    1:     }
    1:   }
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: PRIntn ReflowCountMgr::DoDisplayDiffTotals(PLHashEntry *he, PRIntn i, void *arg)
    1: {
    1:   PRBool cycledOnce = (arg != 0);
    1: 
    1:   char *str = (char *)he->key;
    1:   ReflowCounter * counter = (ReflowCounter *)he->value;
    1: 
    1:   if (cycledOnce) {
    1:     counter->CalcDiffInTotals();
    1:     counter->DisplayDiffTotals(str);
    1:   }
    1:   counter->SetTotalsCache();
    1: 
    1:   return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: //------------------------------------------------------------------
    1: void ReflowCountMgr::DisplayDiffsInTotals(const char * aStr)
    1: {
    1:   if (mCycledOnce) {
    1:     printf("Differences\n");
    1:     for (PRInt32 i=0;i<78;i++) {
    1:       printf("-");
    1:     }
    1:     printf("\n");
    1:     ClearGrandTotals();
    1:   }
    1:   PL_HashTableEnumerateEntries(mCounts, DoDisplayDiffTotals, (void *)mCycledOnce);
    1: 
    1:   mCycledOnce = PR_TRUE;
    1: }
    1: 
    1: #endif // MOZ_REFLOW_PERF
    1: 
    1: // make a color string like #RRGGBB
    1: void ColorToString(nscolor aColor, nsAutoString &aString)
    1: {
    1:   char buf[8];
    1: 
    1:   PR_snprintf(buf, sizeof(buf), "#%02x%02x%02x",
    1:               NS_GET_R(aColor), NS_GET_G(aColor), NS_GET_B(aColor));
    1:   CopyASCIItoUTF16(buf, aString);
    1: }
10522: 
10522: nsIFrame* nsIPresShell::GetAbsoluteContainingBlock(nsIFrame *aFrame)
10522: {
10522:   return FrameConstructor()->GetAbsoluteContainingBlock(aFrame);
10522: }
