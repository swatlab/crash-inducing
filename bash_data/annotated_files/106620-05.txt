     1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "gfxPlatformMac.h"
     1: 
     1: #include "gfxImageSurface.h"
     1: #include "gfxQuartzSurface.h"
 11244: #include "gfxQuartzImageSurface.h"
 81280: #include "mozilla/gfx/2D.h"
     1: 
 31590: #include "gfxMacPlatformFontList.h"
 39206: #include "gfxMacFont.h"
 39206: #include "gfxCoreTextShaper.h"
 19962: #include "gfxUserFontSet.h"
 26688: 
 11086: #include "nsCRT.h"
 23904: #include "nsTArray.h"
 26688: #include "nsUnicodeRange.h"
 11086: 
 71640: #include "mozilla/Preferences.h"
 71640: 
 27035: #include "qcms.h"
  3787: 
 69665: #include <dlfcn.h>
 69665: 
 71640: using namespace mozilla;
 81280: using namespace mozilla::gfx;
 71640: 
 69665: // cribbed from CTFontManager.h
 69665: enum {
 69665:    kAutoActivationDisabled = 1
 69665: };
 69665: typedef uint32_t AutoActivationSetting;
 69665: 
 69665: // bug 567552 - disable auto-activation of fonts
 69665: 
 69665: static void 
 69665: DisableFontActivation()
 69665: {
 69665:     // get the main bundle identifier
 69665:     CFBundleRef mainBundle = ::CFBundleGetMainBundle();
 69665:     CFStringRef mainBundleID = NULL;
 69665: 
 69665:     if (mainBundle) {
 69665:         mainBundleID = ::CFBundleGetIdentifier(mainBundle);
 69665:     }
 69665: 
 69665:     // if possible, fetch CTFontManagerSetAutoActivationSetting
 69665:     void (*CTFontManagerSetAutoActivationSettingPtr)
 69665:             (CFStringRef, AutoActivationSetting);
 69665:     CTFontManagerSetAutoActivationSettingPtr =
 69665:         (void (*)(CFStringRef, AutoActivationSetting))
 69665:         dlsym(RTLD_DEFAULT, "CTFontManagerSetAutoActivationSetting");
 69665: 
 69665:     // bug 567552 - disable auto-activation of fonts
 69665:     if (CTFontManagerSetAutoActivationSettingPtr) {
 69665:         CTFontManagerSetAutoActivationSettingPtr(mainBundleID,
 69665:                                                  kAutoActivationDisabled);
 69665:     }
 70427: }
 69665: 
     1: gfxPlatformMac::gfxPlatformMac()
     1: {
 14465:     mOSXVersion = 0;
 69665:     OSXVersion();
 69665:     if (mOSXVersion >= MAC_OS_X_VERSION_10_6_HEX) {
 69665:         DisableFontActivation();
 69665:     }
 14836:     mFontAntiAliasingThreshold = ReadAntiAliasingThreshold();
106616: 
106616:     PRUint32 backendMask = (1 << BACKEND_CAIRO) | (1 << BACKEND_SKIA) | (1 << BACKEND_COREGRAPHICS);
106616:     InitCanvasBackend(backendMask);
 26688: }
 26688: 
 26688: gfxPlatformMac::~gfxPlatformMac()
 26688: {
 39206:     gfxCoreTextShaper::Shutdown();
     1: }
     1: 
 31590: gfxPlatformFontList*
 31590: gfxPlatformMac::CreatePlatformFontList()
 31590: {
 57104:     gfxPlatformFontList* list = new gfxMacPlatformFontList();
 57104:     if (NS_SUCCEEDED(list->InitFontList())) {
 57104:         return list;
 57104:     }
 57104:     gfxPlatformFontList::Shutdown();
 57104:     return nsnull;
 31590: }
 31590: 
     1: already_AddRefed<gfxASurface>
     1: gfxPlatformMac::CreateOffscreenSurface(const gfxIntSize& size,
 54253:                                        gfxASurface::gfxContentType contentType)
     1: {
     1:     gfxASurface *newSurface = nsnull;
     1: 
 99511:     newSurface = new gfxQuartzSurface(size, OptimalFormatForContent(contentType));
     1: 
     1:     NS_IF_ADDREF(newSurface);
     1:     return newSurface;
     1: }
     1: 
 11244: already_AddRefed<gfxASurface>
102921: gfxPlatformMac::CreateOffscreenImageSurface(const gfxIntSize& aSize,
102921:                                             gfxASurface::gfxContentType aContentType)
102921: {
102921:     nsRefPtr<gfxASurface> surface = CreateOffscreenSurface(aSize, aContentType);
102921: #ifdef DEBUG
102921:     nsRefPtr<gfxImageSurface> imageSurface = surface->GetAsImageSurface();
102921:     NS_ASSERTION(imageSurface, "Surface cannot be converted to a gfxImageSurface");
102921: #endif
102921:     return surface.forget();
102921: }
102921: 
102921: 
102921: already_AddRefed<gfxASurface>
 11244: gfxPlatformMac::OptimizeImage(gfxImageSurface *aSurface,
 11244:                               gfxASurface::gfxImageFormat format)
 11244: {
 11244:     const gfxIntSize& surfaceSize = aSurface->GetSize();
 11244:     nsRefPtr<gfxImageSurface> isurf = aSurface;
 11244: 
 11244:     if (format != aSurface->Format()) {
 11244:         isurf = new gfxImageSurface (surfaceSize, format);
 11244:         if (!isurf->CopyFrom (aSurface)) {
 11244:             // don't even bother doing anything more
 11244:             NS_ADDREF(aSurface);
 11244:             return aSurface;
 11244:         }
 11244:     }
 11244: 
 11244:     nsRefPtr<gfxASurface> ret = new gfxQuartzImageSurface(isurf);
 11244:     return ret.forget();
 11244: }
 11244: 
 81281: RefPtr<ScaledFont>
106598: gfxPlatformMac::GetScaledFontForFont(DrawTarget* aTarget, gfxFont *aFont)
 81281: {
 81281:     gfxMacFont *font = static_cast<gfxMacFont*>(aFont);
 82423:     return font->GetScaledFont();
 81281: }
 81281: 
     1: nsresult
     1: gfxPlatformMac::ResolveFontName(const nsAString& aFontName,
     1:                                 FontResolverCallback aCallback,
 79445:                                 void *aClosure, bool& aAborted)
     1: {
     1:     nsAutoString resolvedName;
 31590:     if (!gfxPlatformFontList::PlatformFontList()->
     1:              ResolveFontName(aFontName, resolvedName)) {
 80486:         aAborted = false;
     1:         return NS_OK;
     1:     }
     1:     aAborted = !(*aCallback)(resolvedName, aClosure);
     1:     return NS_OK;
     1: }
     1: 
 13003: nsresult
 13003: gfxPlatformMac::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
 13003: {
 31590:     gfxPlatformFontList::PlatformFontList()->GetStandardFamilyName(aFontName, aFamilyName);
 13003:     return NS_OK;
 13003: }
 13003: 
   270: gfxFontGroup *
   270: gfxPlatformMac::CreateFontGroup(const nsAString &aFamilies,
 19962:                                 const gfxFontStyle *aStyle,
 19962:                                 gfxUserFontSet *aUserFontSet)
   270: {
 37211:     return new gfxFontGroup(aFamilies, aStyle, aUserFontSet);
 19962: }
 19962: 
 31590: // these will move to gfxPlatform once all platforms support the fontlist
 19962: gfxFontEntry* 
 23273: gfxPlatformMac::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
 23273:                                 const nsAString& aFontName)
 19962: {
 31590:     return gfxPlatformFontList::PlatformFontList()->LookupLocalFont(aProxyEntry, 
 24932:                                                                     aFontName);
 19962: }
 19962: 
 19962: gfxFontEntry* 
 22397: gfxPlatformMac::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
 22397:                                  const PRUint8 *aFontData, PRUint32 aLength)
 19962: {
 36949:     // Ownership of aFontData is received here, and passed on to
 36949:     // gfxPlatformFontList::MakePlatformFont(), which must ensure the data
 36949:     // is released with NS_Free when no longer needed
 36949:     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aProxyEntry,
 32808:                                                                      aFontData,
 32808:                                                                      aLength);
 19962: }
 19962: 
 79445: bool
 19962: gfxPlatformMac::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
 19962: {
 23576:     // check for strange format flags
 23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
 23576:                  "strange font format hint set");
 23576: 
 23576:     // accept supported formats
 32809:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_WOFF     |
 32809:                         gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
 23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE | 
 23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE_AAT)) {
 80486:         return true;
 23576:     }
 23576: 
 23576:     // reject all other formats, known and unknown
 23576:     if (aFormatFlags != 0) {
 80486:         return false;
 19962:     }
 19962: 
 23576:     // no format hint set, need to look at data
 80486:     return true;
   270: }
   270: 
 31590: // these will also move to gfxPlatform once all platforms support the fontlist
     1: nsresult
 38493: gfxPlatformMac::GetFontList(nsIAtom *aLangGroup,
     1:                             const nsACString& aGenericFamily,
 23904:                             nsTArray<nsString>& aListOfFonts)
     1: {
 31590:     gfxPlatformFontList::PlatformFontList()->GetFontList(aLangGroup, aGenericFamily, aListOfFonts);
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: gfxPlatformMac::UpdateFontList()
     1: {
 31590:     gfxPlatformFontList::PlatformFontList()->UpdateFontList();
     1:     return NS_OK;
     1: }
  3787: 
 91870: static const char kFontArialUnicodeMS[] = "Arial Unicode MS";
 91870: static const char kFontAppleBraille[] = "Apple Braille";
 91870: static const char kFontAppleSymbols[] = "Apple Symbols";
 91870: static const char kFontAppleMyungjo[] = "AppleMyungjo";
 91870: static const char kFontGeneva[] = "Geneva";
 91870: static const char kFontGeezaPro[] = "Geeza Pro";
 91870: static const char kFontHiraginoKakuGothic[] = "Hiragino Kaku Gothic ProN";
 91870: static const char kFontLucidaGrande[] = "Lucida Grande";
 91870: static const char kFontMenlo[] = "Menlo";
 91870: static const char kFontPlantagenetCherokee[] = "Plantagenet Cherokee";
 91870: static const char kFontSTHeiti[] = "STHeiti";
 91870: 
 91870: void
 91870: gfxPlatformMac::GetCommonFallbackFonts(const PRUint32 aCh,
 91870:                                        PRInt32 aRunScript,
 91870:                                        nsTArray<const char*>& aFontList)
 91870: {
 91870:     aFontList.AppendElement(kFontLucidaGrande);
 91870: 
 91870:     if (!IS_IN_BMP(aCh)) {
 91870:         PRUint32 p = aCh >> 16;
 91870:         if (p == 1) {
 91870:             aFontList.AppendElement(kFontAppleSymbols);
 91870:             aFontList.AppendElement(kFontGeneva);
 91870:         }
 91870:     } else {
 91870:         PRUint32 b = (aCh >> 8) & 0xff;
 91870: 
 91870:         switch (b) {
 91870:         case 0x03:
 91870:         case 0x05:
 91870:             aFontList.AppendElement(kFontGeneva);
 91870:             break;
 91870:         case 0x07:
 91870:             aFontList.AppendElement(kFontGeezaPro);
 91870:             break;
 91870:         case 0x10:
 91870:             aFontList.AppendElement(kFontMenlo);
 91870:             break;
 91870:         case 0x13:  // Cherokee
 91870:             aFontList.AppendElement(kFontPlantagenetCherokee);
 91870:             break;
 91870:         case 0x18:  // Mongolian
 91870:             aFontList.AppendElement(kFontSTHeiti);
 91870:             break;
 91870:         case 0x1d:
 91870:         case 0x1e:
 91870:             aFontList.AppendElement(kFontGeneva);
 91870:             break;
 91870:         case 0x20:  // Symbol ranges
 91870:         case 0x21:
 91870:         case 0x22:
 91870:         case 0x23:
 91870:         case 0x24:
 91870:         case 0x25:
 91870:         case 0x26:
 91870:         case 0x27:
 91870:         case 0x29:
 91870:         case 0x2a:
 91870:         case 0x2b:
 91870:         case 0x2e:
 91870:             aFontList.AppendElement(kFontAppleSymbols);
 91870:             aFontList.AppendElement(kFontMenlo);
 91870:             aFontList.AppendElement(kFontGeneva);
 91870:             aFontList.AppendElement(kFontHiraginoKakuGothic);
 91870:             break;
 91870:         case 0x2c:
 91870:         case 0x2d:
 91870:             aFontList.AppendElement(kFontGeneva);
 91870:             break;
 91870:         case 0x28:  // Braille
 91870:             aFontList.AppendElement(kFontAppleBraille);
 91870:             break;
 91870:         case 0x4d:
 91870:             aFontList.AppendElement(kFontAppleSymbols);
 91870:             break;
 91870:         case 0xa0:  // Yi
 91870:         case 0xa1:
 91870:         case 0xa2:
 91870:         case 0xa3:
 91870:         case 0xa4:
 91870:             aFontList.AppendElement(kFontSTHeiti);
 91870:             break;
 91870:         case 0xa6:
 91870:         case 0xa7:
 91870:             aFontList.AppendElement(kFontGeneva);
 91870:             aFontList.AppendElement(kFontAppleSymbols);
 91870:             break;
 91870:         case 0xfc:
 91870:         case 0xff:
 91870:             aFontList.AppendElement(kFontAppleSymbols);
 91870:             break;
 91870:         default:
 91870:             break;
 91870:         }
 91870:     }
 91870: 
 91870:     // Arial Unicode MS has lots of glyphs for obscure, use it as a last resort
 91870:     aFontList.AppendElement(kFontArialUnicodeMS);
 91870: }
 91870: 
 91870: 
 14465: PRInt32 
 14465: gfxPlatformMac::OSXVersion()
 14465: {
 14465:     if (!mOSXVersion) {
 14465:         // minor version is not accurate, use gestaltSystemVersionMajor, gestaltSystemVersionMinor, gestaltSystemVersionBugFix for these
 31590:         OSErr err = ::Gestalt(gestaltSystemVersion, reinterpret_cast<SInt32*>(&mOSXVersion));
 14465:         if (err != noErr) {
 14465:             //This should probably be changed when our minimum version changes
 14465:             NS_ERROR("Couldn't determine OS X version, assuming 10.4");
 14465:             mOSXVersion = MAC_OS_X_VERSION_10_4_HEX;
 14465:         }
 14465:     }
 14465:     return mOSXVersion;
 14465: }
 14465: 
 14836: PRUint32
 14836: gfxPlatformMac::ReadAntiAliasingThreshold()
 14836: {
 14836:     PRUint32 threshold = 0;  // default == no threshold
 14836:     
 14836:     // first read prefs flag to determine whether to use the setting or not
 79445:     bool useAntiAliasingThreshold = Preferences::GetBool("gfx.use_text_smoothing_setting", false);
 14836: 
 14836:     // if the pref setting is disabled, return 0 which effectively disables this feature
 14836:     if (!useAntiAliasingThreshold)
 14836:         return threshold;
 14836:         
 14836:     // value set via Appearance pref panel, "Turn off text smoothing for font sizes xxx and smaller"
 14836:     CFNumberRef prefValue = (CFNumberRef)CFPreferencesCopyAppValue(CFSTR("AppleAntiAliasingThreshold"), kCFPreferencesCurrentApplication);
 14836: 
 14836:     if (prefValue) {
 14836:         if (!CFNumberGetValue(prefValue, kCFNumberIntType, &threshold)) {
 14836:             threshold = 0;
 14836:         }
 14836:         CFRelease(prefValue);
 14836:     }
 14836: 
 14836:     return threshold;
 14836: }
 11086: 
 87511: already_AddRefed<gfxASurface>
 87511: gfxPlatformMac::GetThebesSurfaceForDrawTarget(DrawTarget *aTarget)
 87511: {
 87511:   if (aTarget->GetType() == BACKEND_COREGRAPHICS) {
 87511:     CGContextRef cg = static_cast<CGContextRef>(aTarget->GetNativeSurface(NATIVE_SURFACE_CGCONTEXT));
 87511: 
 87511:     //XXX: it would be nice to have an implicit conversion from IntSize to gfxIntSize
 87511:     IntSize intSize = aTarget->GetSize();
 87511:     gfxIntSize size(intSize.width, intSize.height);
 87511: 
 87511:     nsRefPtr<gfxASurface> surf =
 87511:       new gfxQuartzSurface(cg, size);
 87511: 
 87511:     return surf.forget();
 87511:   }
 87511: 
 87511:   return gfxPlatform::GetThebesSurfaceForDrawTarget(aTarget);
 87511: }
 87511: 
 87511: 
 27035: qcms_profile *
  3787: gfxPlatformMac::GetPlatformCMSOutputProfile()
  3787: {
 33428:     qcms_profile *profile = nsnull;
 33428:     CMProfileRef cmProfile;
 33428:     CMProfileLocation *location;
 33428:     UInt32 locationSize;
 33428: 
 33428:     /* There a number of different ways that we could try to get a color
 33428:        profile to use.  On 10.5 all of these methods seem to give the same
 33428:        results. On 10.6, the results are different and the following method,
 33428:        using CGMainDisplayID() seems to best match what we are looking for.
 33428:        Currently, both Google Chrome and Qt4 use a similar method.
 33428: 
 33428:        CMTypes.h describes CMDisplayIDType:
 33428:        "Data type for ColorSync DisplayID reference
 33428:         On 8 & 9 this is a AVIDType
 33428: 	On X this is a CGSDisplayID"
 33428: 
 33428:        CGMainDisplayID gives us a CGDirectDisplayID which presumeably
 33428:        corresponds directly to a CGSDisplayID */
 33428:     CGDirectDisplayID displayID = CGMainDisplayID();
 33428: 
 33428:     CMError err = CMGetProfileByAVID(static_cast<CMDisplayIDType>(displayID), &cmProfile);
  3787:     if (err != noErr)
  3787:         return nsnull;
  3787: 
 33428:     // get the size of location
 33428:     err = NCMGetProfileLocation(cmProfile, NULL, &locationSize);
 33428:     if (err != noErr)
 33428:         return nsnull;
 33428: 
 33428:     // allocate enough room for location
 33428:     location = static_cast<CMProfileLocation*>(malloc(locationSize));
 33428:     if (!location)
 33428:         goto fail_close;
 33428: 
 33428:     err = NCMGetProfileLocation(cmProfile, location, &locationSize);
 33428:     if (err != noErr)
 33428:         goto fail_location;
 33428: 
 33428:     switch (location->locType) {
 27622: #ifndef __LP64__
  3787:     case cmFileBasedProfile: {
  3787:         FSRef fsRef;
 33428:         if (!FSpMakeFSRef(&location->u.fileLoc.spec, &fsRef)) {
  3787:             char path[512];
 31590:             if (!FSRefMakePath(&fsRef, reinterpret_cast<UInt8*>(path), sizeof(path))) {
 27035:                 profile = qcms_profile_from_path(path);
  3787: #ifdef DEBUG_tor
  3787:                 if (profile)
  3787:                     fprintf(stderr,
  3787:                             "ICM profile read from %s fileLoc successfully\n", path);
  3787: #endif
  3787:             }
  3787:         }
  3787:         break;
  3787:     }
 27622: #endif
  3787:     case cmPathBasedProfile:
 33428:         profile = qcms_profile_from_path(location->u.pathLoc.path);
  3787: #ifdef DEBUG_tor
  3787:         if (profile)
  3787:             fprintf(stderr,
  3787:                     "ICM profile read from %s pathLoc successfully\n",
  3787:                     device.u.pathLoc.path);
  3787: #endif
  3787:         break;
  3787:     default:
  3787: #ifdef DEBUG_tor
  3787:         fprintf(stderr, "Unhandled ColorSync profile location\n");
  3787: #endif
  3787:         break;
  3787:     }
  3787: 
 33428: fail_location:
 33428:     free(location);
 33428: fail_close:
 33428:     CMCloseProfile(cmProfile);
  3787:     return profile;
  3787: }
