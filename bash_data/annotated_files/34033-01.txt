    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
27664: /* vim: set ts=2 sw=2 et tw=79: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all element classes; this provides an implementation
    1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
    1:  * utility methods for subclasses, and so forth.
    1:  */
    1: 
    1: #include "nsGenericElement.h"
    1: 
    1: #include "nsDOMAttribute.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsIAtom.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIEventListenerManager.h"
29018: #include "nsFocusManager.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIFrame.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
32193: #include "nsCSSDeclaration.h"
    1: #include "nsDOMCSSDeclaration.h"
32193: #include "nsDOMCSSAttrDeclaration.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsContentList.h"
31383: #include "nsDOMTokenList.h"
    1: #include "nsDOMError.h"
    1: #include "nsDOMString.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsDocument.h"
 3244: #ifdef MOZ_XUL
 1498: #include "nsXULElement.h"
 3244: #endif /* MOZ_XUL */
 6186: #include "nsFrameManager.h"
11914: #include "nsFrameSelection.h"
    1: 
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIDOMViewCSS.h"
    1: #include "nsIXBLService.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIBoxObject.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSElement.h"
12913: #include "nsClientRect.h"
 2014: #ifdef MOZ_SVG
 2014: #include "nsSVGUtils.h"
 2014: #endif
 2014: #include "nsLayoutUtils.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIJSContextStack.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMEventListener.h"
    1: 
    1: #include "nsIWebNavigation.h"
    1: #include "nsIBaseWindow.h"
    1: 
    1: #include "jsapi.h"
    1: 
    1: #include "nsNodeInfoManager.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsIDOMNSFeatureFactory.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsIDOMUserDataHandler.h"
24836: #include "nsGenericHTMLElement.h"
11914: #include "nsIEditor.h"
11914: #include "nsIEditorDocShell.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIControllers.h"
16722: #include "nsLayoutUtils.h"
16722: #include "nsIView.h"
16722: #include "nsIViewManager.h"
16722: #include "nsIScrollableFrame.h"
16722: #include "nsIScrollableView.h"
16722: #include "nsIScrollableViewProvider.h"
 1685: #include "nsXBLInsertionPoint.h"
16106: #include "nsICSSStyleRule.h" /* For nsCSSSelectorList */
16106: #include "nsCSSRuleProcessor.h"
30988: #include "nsRuleProcessorData.h"
16106: 
 3244: #ifdef MOZ_XUL
 1839: #include "nsIXULDocument.h"
 3244: #endif /* MOZ_XUL */
    1: 
 5395: #ifdef ACCESSIBILITY
 5395: #include "nsIAccessibilityService.h"
 5395: #include "nsIAccessibleEvent.h"
 5395: #endif /* ACCESSIBILITY */
 5395: 
    1: #include "nsCycleCollectionParticipant.h"
 1353: #include "nsCCUncollectableMarker.h"
    1: 
14228: #include "mozAutoDocUpdate.h"
14228: 
18845: #include "nsICSSParser.h"
18845: 
    1: #ifdef MOZ_SVG
28081: #include "nsSVGFeatures.h"
    1: #endif /* MOZ_SVG */
    1: 
    1: #ifdef DEBUG_waterson
    1: 
    1: /**
    1:  * List a content tree to stdout. Meant to be called from gdb.
    1:  */
    1: void
    1: DebugListContentTree(nsIContent* aElement)
    1: {
    1:   aElement->List(stdout, 0);
    1:   printf("\n");
    1: }
    1: 
    1: #endif
    1: 
21218: NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
21218: 
    1: PRInt32 nsIContent::sTabFocusModel = eTabFocus_any;
    1: PRBool nsIContent::sTabFocusModelAppliesToXUL = PR_FALSE;
27150: PRUint32 nsMutationGuard::sMutationCount = 0;
27150: 
    1: nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsINode::nsSlots::~nsSlots()
    1: {
    1:   if (mChildNodes) {
    1:     mChildNodes->DropReference();
    1:     NS_RELEASE(mChildNodes);
    1:   }
    1: 
    1:   if (mWeakReference) {
    1:     mWeakReference->NoticeNodeDestruction();
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsINode::~nsINode()
    1: {
    1:   NS_ASSERTION(!HasSlots(), "nsNodeUtils::LastRelease was not called?");
    1: }
    1: 
    1: void*
    1: nsINode::GetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
    1:                      nsresult *aStatus) const
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return nsnull;
    1: 
    1:   return doc->PropertyTable()->GetProperty(this, aCategory, aPropertyName,
    1:                                            aStatus);
    1: }
    1: 
    1: nsresult
    1: nsINode::SetProperty(PRUint16 aCategory, nsIAtom *aPropertyName, void *aValue,
    1:                      NSPropertyDtorFunc aDtor, PRBool aTransfer,
    1:                      void **aOldValue)
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsresult rv = doc->PropertyTable()->SetProperty(this, aCategory,
    1:                                                   aPropertyName, aValue, aDtor,
    1:                                                   nsnull, aTransfer, aOldValue);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     SetFlags(NODE_HAS_PROPERTIES);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsINode::DeleteProperty(PRUint16 aCategory, nsIAtom *aPropertyName)
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return nsnull;
    1: 
    1:   return doc->PropertyTable()->DeleteProperty(this, aCategory, aPropertyName);
    1: }
    1: 
    1: void*
    1: nsINode::UnsetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
    1:                        nsresult *aStatus)
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return nsnull;
    1: 
    1:   return doc->PropertyTable()->UnsetProperty(this, aCategory, aPropertyName,
    1:                                              aStatus);
    1: }
    1: 
29474: nsIEventListenerManager*
29474: nsGenericElement::GetListenerManager(PRBool aCreateIfNotFound)
29474: {
29474:   return nsContentUtils::GetListenerManager(this, aCreateIfNotFound);
    1: }
    1: 
 1418: nsresult
 1418: nsGenericElement::AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                        const nsIID& aIID)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(elm);
 1418:   return elm->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
 1418: }
 1418: 
 1418: nsresult
 1418: nsGenericElement::RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                            const nsIID& aIID)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_FALSE);
29474:   return elm ?
29474:     elm->RemoveEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE) :
29474:     NS_OK;
 1418: }
 1418: 
 1418: nsresult
 1418: nsGenericElement::GetSystemEventGroup(nsIDOMEventGroup** aGroup)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(elm);
 1418:   return elm->GetSystemEventGroupLM(aGroup);
 1418: }
 1418: 
    1: nsINode::nsSlots*
    1: nsINode::CreateSlots()
    1: {
11169:   return new nsSlots(mFlagsOrSlots);
    1: }
    1: 
    1: void
    1: nsINode::AddMutationObserver(nsIMutationObserver* aMutationObserver)
    1: {
    1:   nsSlots* slots = GetSlots();
    1:   if (slots) {
 9536:     slots->mMutationObservers.AppendElementUnlessExists(aMutationObserver);
    1:   }
    1: }
    1: 
    1: void
    1: nsINode::RemoveMutationObserver(nsIMutationObserver* aMutationObserver)
    1: {
    1:   nsSlots* slots = GetExistingSlots();
    1:   if (slots) {
 9536:     slots->mMutationObservers.RemoveElement(aMutationObserver);
    1:   }
    1: }
    1: 
 3333: PRBool
 3333: nsINode::IsEditableInternal() const
 3333: {
 3333:   if (HasFlag(NODE_IS_EDITABLE)) {
 3333:     // The node is in an editable contentEditable subtree.
 3333:     return PR_TRUE;
 3333:   }
 3333: 
 3333:   nsIDocument *doc = GetCurrentDoc();
 3333: 
 3333:   // Check if the node is in a document and the document is in designMode.
 3333:   return doc && doc->HasFlag(NODE_IS_EDITABLE);
 3333: }
 3333: 
11914: static nsIContent* GetEditorRootContent(nsIEditor* aEditor)
11914: {
11914:   nsCOMPtr<nsIDOMElement> rootElement;
11914:   aEditor->GetRootElement(getter_AddRefs(rootElement));
11914:   nsCOMPtr<nsIContent> rootContent(do_QueryInterface(rootElement));
11914:   return rootContent;
11914: }
11914: 
11914: nsIContent*
11914: nsINode::GetTextEditorRootContent(nsIEditor** aEditor)
11914: {
11914:   if (aEditor)
11914:     *aEditor = nsnull;
11914:   for (nsINode* node = this; node; node = node->GetNodeParent()) {
33329:     if (!node->IsNodeOfType(eELEMENT) ||
33329:         !static_cast<nsIContent*>(node)->IsHTML())
11914:       continue;
11914: 
11914:     nsCOMPtr<nsIEditor> editor;
24836:     static_cast<nsGenericHTMLElement*>(node)->
24836:         GetEditorInternal(getter_AddRefs(editor));
24836:     if (!editor)
24836:       continue;
24836: 
11914:     nsIContent* rootContent = GetEditorRootContent(editor);
11914:     if (aEditor)
11914:       editor.swap(*aEditor);
11914:     return rootContent;
11914:   }
11914:   return nsnull;
11914: }
11914: 
11914: static nsIEditor* GetHTMLEditor(nsPresContext* aPresContext)
11914: {
11914:   nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
11914:   nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(container));
11914:   PRBool isEditable;
11914:   if (!editorDocShell ||
11914:       NS_FAILED(editorDocShell->GetEditable(&isEditable)) || !isEditable)
11914:     return nsnull;
11914: 
11914:   nsCOMPtr<nsIEditor> editor;
11914:   editorDocShell->GetEditor(getter_AddRefs(editor));
11914:   return editor;
11914: }
11914: 
11914: nsIContent*
11914: nsINode::GetSelectionRootContent(nsIPresShell* aPresShell)
11914: {
11914:   NS_ENSURE_TRUE(aPresShell, nsnull);
11914: 
11914:   if (IsNodeOfType(eDOCUMENT))
11914:     return static_cast<nsIDocument*>(this)->GetRootContent();
11914:   if (!IsNodeOfType(eCONTENT))
11914:     return nsnull;
11914: 
11914:   nsIFrame* frame =
11914:     aPresShell->GetPrimaryFrameFor(static_cast<nsIContent*>(this));
11914:   if (frame && frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION) {
11914:     // This node should be a descendant of input/textarea editor.
11914:     nsIContent* content = GetTextEditorRootContent();
11914:     if (content)
11914:       return content;
11914:   }
11914: 
11914:   nsPresContext* presContext = aPresShell->GetPresContext();
11914:   if (presContext) {
11914:     nsIEditor* editor = GetHTMLEditor(presContext);
11914:     if (editor) {
11914:       // This node is in HTML editor.
11914:       nsIDocument* doc = GetCurrentDoc();
11914:       if (!doc || doc->HasFlag(NODE_IS_EDITABLE) || !HasFlag(NODE_IS_EDITABLE))
11914:         return GetEditorRootContent(editor);
11914:       // If the current document is not editable, but current content is
11914:       // editable, we should assume that the child of the nearest non-editable
11914:       // ancestor is selection root.
11914:       nsIContent* content = static_cast<nsIContent*>(this);
11914:       for (nsIContent* parent = GetParent();
11914:            parent && parent->HasFlag(NODE_IS_EDITABLE);
11914:            parent = content->GetParent())
11914:         content = parent;
11914:       return content;
11914:     }
11914:   }
11914: 
11914:   nsCOMPtr<nsFrameSelection> fs = aPresShell->FrameSelection();
11914:   nsIContent* content = fs->GetLimiter();
11914:   if (content)
11914:     return content;
11914:   content = fs->GetAncestorLimiter();
11914:   if (content)
11914:     return content;
11914:   nsIDocument* doc = aPresShell->GetDocument();
11914:   NS_ENSURE_TRUE(doc, nsnull);
11914:   return doc->GetRootContent();
11914: }
11914: 
24403: nsINodeList*
23258: nsINode::GetChildNodesList()
23258: {
23258:   nsSlots *slots = GetSlots();
23258:   if (!slots) {
23258:     return nsnull;
23258:   }
23258: 
23258:   if (!slots->mChildNodes) {
23258:     slots->mChildNodes = new nsChildContentList(this);
23258:     if (slots->mChildNodes) {
23258:       NS_ADDREF(slots->mChildNodes);
23258:     }
23258:   }
23258: 
23258:   return slots->mChildNodes;
23258: }
23258: 
27664: #ifdef DEBUG
27664: void
27664: nsINode::CheckNotNativeAnonymous() const
27664: {
27664:   if (!IsNodeOfType(eCONTENT))
27664:     return;
27664:   nsIContent* content = static_cast<const nsIContent *>(this)->GetBindingParent();
27664:   while (content) {
27664:     if (content->IsRootOfNativeAnonymousSubtree()) {
27664:       NS_ERROR("Element not marked to be in native anonymous subtree!");
27664:       break;
27664:     }
27664:     content = content->GetBindingParent();
27664:   }
27664: }
27664: #endif
27664: 
23258: nsresult
23258: nsINode::GetParentNode(nsIDOMNode** aParentNode)
23258: {
23258:   *aParentNode = nsnull;
23258: 
23258:   nsINode *parent = GetNodeParent();
23258: 
23258:   return parent ? CallQueryInterface(parent, aParentNode) : NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetChildNodes(nsIDOMNodeList** aChildNodes)
23258: {
23258:   *aChildNodes = GetChildNodesList();
23258:   if (!*aChildNodes) {
23258:     return NS_ERROR_OUT_OF_MEMORY;
23258:   }
23258: 
23258:   NS_ADDREF(*aChildNodes);
23258: 
23258:   return NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetFirstChild(nsIDOMNode** aNode)
23258: {
23258:   nsIContent* child = GetChildAt(0);
23258:   if (child) {
23258:     return CallQueryInterface(child, aNode);
23258:   }
23258: 
23258:   *aNode = nsnull;
23258: 
23258:   return NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetLastChild(nsIDOMNode** aNode)
23258: {
23258:   nsIContent* child = GetLastChild();
23258:   if (child) {
23258:     return CallQueryInterface(child, aNode);
23258:   }
23258: 
23258:   *aNode = nsnull;
23258: 
23258:   return NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetPreviousSibling(nsIDOMNode** aPrevSibling)
23258: {
23258:   *aPrevSibling = nsnull;
23258: 
23258:   nsIContent *sibling = GetSibling(-1);
23258: 
23258:   return sibling ? CallQueryInterface(sibling, aPrevSibling) : NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetNextSibling(nsIDOMNode** aNextSibling)
23258: {
23258:   *aNextSibling = nsnull;
23258: 
23258:   nsIContent *sibling = GetSibling(1);
23258: 
23258:   return sibling ? CallQueryInterface(sibling, aNextSibling) : NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
23258: {
23258:   *aOwnerDocument = nsnull;
23258: 
23258:   nsIDocument *ownerDoc = GetOwnerDocument();
23258: 
23258:   return ownerDoc ? CallQueryInterface(ownerDoc, aOwnerDocument) : NS_OK;
23258: }
23258: 
    1: //----------------------------------------------------------------------
    1: 
 2896: PRInt32
 2896: nsIContent::IntrinsicState() const
 2896: {
 3333:   return IsEditable() ? NS_EVENT_STATE_MOZ_READWRITE :
 3333:                         NS_EVENT_STATE_MOZ_READONLY;
 2896: }
 2896: 
 2896: void
 2896: nsIContent::UpdateEditableState()
 2896: {
 2896:   nsIContent *parent = GetParent();
 2896: 
 2896:   SetEditableFlag(parent && parent->HasFlag(NODE_IS_EDITABLE));
 2896: }
 2896: 
12250: nsIContent*
12250: nsIContent::FindFirstNonNativeAnonymous() const
12250: {
12250:   // This handles also nested native anonymous content.
16126:   for (const nsIContent *content = this; content;
16126:        content = content->GetBindingParent()) {
16126:     if (!content->IsInNativeAnonymousSubtree()) {
16126:       // Oops, this function signature allows casting const to
16126:       // non-const.  (Then again, so does GetChildAt(0)->GetParent().)
16126:       return const_cast<nsIContent*>(content);
16126:     }
16126:   }
16126:   return nsnull;
12250: }
12250: 
    1: //----------------------------------------------------------------------
    1: 
20752: NS_IMPL_ADDREF(nsChildContentList)
20752: NS_IMPL_RELEASE(nsChildContentList)
20752: 
21218: NS_INTERFACE_TABLE_HEAD(nsChildContentList)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21218:   NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsChildContentList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsINodeList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsIDOMNodeList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
20752:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
20752: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMETHODIMP
    1: nsChildContentList::GetLength(PRUint32* aLength)
    1: {
    1:   *aLength = mNode ? mNode->GetChildCount() : 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: NS_IMETHODIMP
20752: nsChildContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
20752: {
20752:   nsINode* node = GetNodeAt(aIndex);
20752:   if (!node) {
20752:     *aReturn = nsnull;
20752: 
20752:     return NS_OK;
20752:   }
20752: 
20752:   return CallQueryInterface(node, aReturn);
20752: }
20752: 
24403: nsIContent*
19130: nsChildContentList::GetNodeAt(PRUint32 aIndex)
    1: {
    1:   if (mNode) {
19130:     return mNode->GetChildAt(aIndex);
19130:   }
19130: 
19130:   return nsnull;
    1: }
    1: 
24403: PRInt32
24403: nsChildContentList::IndexOf(nsIContent* aContent)
24403: {
24403:   if (mNode) {
24403:     return mNode->IndexOf(aContent);
24403:   }
24403: 
24403:   return -1;
24403: }
24403: 
    1: //----------------------------------------------------------------------
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_1(nsNode3Tearoff, mContent)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNode3Tearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3Node)
29215:   NS_INTERFACE_MAP_ENTRY(nsIDOMXPathNSResolver)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNode3Tearoff)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNode3Tearoff)
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetBaseURI(nsAString& aURI)
    1: {
    1:   nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1:   nsCAutoString spec;
    1: 
    1:   if (baseURI) {
    1:     baseURI->GetSpec(spec);
    1:   }
    1: 
    1:   CopyUTF8toUTF16(spec, aURI);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetTextContent(nsAString &aTextContent)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
    1:   NS_ASSERTION(node, "We have an nsIContent which doesn't support nsIDOMNode");
    1: 
    1:   PRUint16 nodeType;
    1:   node->GetNodeType(&nodeType);
    1:   if (nodeType == nsIDOMNode::DOCUMENT_TYPE_NODE ||
    1:       nodeType == nsIDOMNode::NOTATION_NODE) {
    1:     SetDOMStringToNull(aTextContent);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (nodeType == nsIDOMNode::TEXT_NODE ||
    1:       nodeType == nsIDOMNode::CDATA_SECTION_NODE ||
    1:       nodeType == nsIDOMNode::COMMENT_NODE ||
    1:       nodeType == nsIDOMNode::PROCESSING_INSTRUCTION_NODE) {
    1:     return node->GetNodeValue(aTextContent);
    1:   }
    1: 
    1:   nsContentUtils::GetNodeTextContent(mContent, PR_TRUE, aTextContent);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::SetTextContent(const nsAString &aTextContent)
    1: {
   62:   // Batch possible DOMSubtreeModified events.
   62:   mozAutoSubtreeModified subtree(mContent->GetOwnerDoc(), nsnull);
   62: 
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
    1:   NS_ASSERTION(node, "We have an nsIContent which doesn't support nsIDOMNode");
    1: 
    1:   PRUint16 nodeType;
    1:   node->GetNodeType(&nodeType);
    1:   if (nodeType == nsIDOMNode::DOCUMENT_TYPE_NODE ||
    1:       nodeType == nsIDOMNode::NOTATION_NODE) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (nodeType == nsIDOMNode::TEXT_NODE ||
    1:       nodeType == nsIDOMNode::CDATA_SECTION_NODE ||
    1:       nodeType == nsIDOMNode::COMMENT_NODE ||
    1:       nodeType == nsIDOMNode::PROCESSING_INSTRUCTION_NODE) {
    1:     return node->SetNodeValue(aTextContent);
    1:   }
    1: 
    1:   return nsContentUtils::SetNodeTextContent(mContent, aTextContent, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::CompareDocumentPosition(nsIDOMNode* aOther,
    1:                                         PRUint16* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOther);
    1: 
    1:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
    1:   NS_ENSURE_TRUE(other, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
    1: 
    1:   *aReturn = nsContentUtils::ComparePosition(other, mContent);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::IsSameNode(nsIDOMNode* aOther,
    1:                            PRBool* aReturn)
    1: {
    1:   nsCOMPtr<nsIContent> other(do_QueryInterface(aOther));
    1:   *aReturn = mContent == other;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsNode3Tearoff::AreNodesEqual(nsIContent* aContent1,
    1:                               nsIContent* aContent2)
    1: {
    1:   // We use nsIContent instead of nsINode for the attributes of elements.
    1: 
    1:   NS_PRECONDITION(aContent1 && aContent2, "Who called AreNodesEqual?");
    1: 
    1:   nsAutoString string1, string2;
    1: 
    1:   // Prefix, namespace URI, local name, node name check.
    1:   if (!aContent1->NodeInfo()->Equals(aContent2->NodeInfo())) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   if (aContent1->Tag() == nsGkAtoms::documentTypeNodeName) {
    1:     nsCOMPtr<nsIDOMDocumentType> docType1 = do_QueryInterface(aContent1);
    1:     nsCOMPtr<nsIDOMDocumentType> docType2 = do_QueryInterface(aContent2);
    1: 
    1:     NS_ASSERTION(docType1 && docType2, "Why don't we have a document type node?");
    1: 
    1:     // Public ID
    1:     docType1->GetPublicId(string1);
    1:     docType2->GetPublicId(string2);
    1: 
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // System ID
    1:     docType1->GetSystemId(string1);
    1:     docType2->GetSystemId(string2);
    1: 
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // Internal subset
    1:     docType1->GetInternalSubset(string1);
    1:     docType2->GetInternalSubset(string2);
    1: 
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   if (aContent1->IsNodeOfType(nsINode::eELEMENT)) {
    1:     // aContent1 is an element.  Do the check on attributes.
    1:     PRUint32 attrCount = aContent1->GetAttrCount();
    1:     if (attrCount != aContent2->GetAttrCount()) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // Iterate over attributes.
    1:     for (PRUint32 i = 0; i < attrCount; ++i) {
    1:       const nsAttrName* attrName1 = aContent1->GetAttrNameAt(i);
    1: #ifdef DEBUG
    1:       PRBool hasAttr =
    1: #endif
    1:       aContent1->GetAttr(attrName1->NamespaceID(),
    1:                          attrName1->LocalName(),
    1:                          string1);
    1:       NS_ASSERTION(hasAttr, "Why don't we have an attr?");
    1: 
    1:       if (!aContent2->AttrValueIs(attrName1->NamespaceID(),
    1:                                   attrName1->LocalName(),
    1:                                   string1,
    1:                                   eCaseMatters)) {
    1:         return PR_FALSE;
    1:       }
    1:     }
    1:   } else {
    1:     // aContent1 is not an element.  Node value check.
    1:     nsCOMPtr<nsIDOMNode> domNode1 = do_QueryInterface(aContent1);
    1:     nsCOMPtr<nsIDOMNode> domNode2 = do_QueryInterface(aContent2);
    1:     NS_ASSERTION(domNode1 && domNode2, "How'd we get nsIContent without nsIDOMNode?");
    1:     domNode1->GetNodeValue(string1);
    1:     domNode2->GetNodeValue(string2);
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   // Child nodes count.
    1:   PRUint32 childCount = aContent1->GetChildCount();
    1:   if (childCount != aContent2->GetChildCount()) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // Iterate over child nodes.
    1:   for (PRUint32 i = 0; i < childCount; ++i) {
    1:     nsIContent* child1 = aContent1->GetChildAt(i);
    1:     nsIContent* child2 = aContent2->GetChildAt(i);
    1:     if (!AreNodesEqual(child1, child2)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::IsEqualNode(nsIDOMNode* aOther, PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOther);
    1: 
    1:   *aReturn = PR_FALSE;
    1: 
    1:   // Since we implement nsIContent, aOther must as well.
    1:   nsCOMPtr<nsIContent> aOtherContent = do_QueryInterface(aOther);
    1:   // Documents and attributes don't implement nsIContent.
    1:   if (!aOtherContent) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aReturn = nsNode3Tearoff::AreNodesEqual(mContent, aOtherContent);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetFeature(const nsAString& aFeature,
    1:                            const nsAString& aVersion,
    1:                            nsISupports** aReturn)
    1: {
29215:   return nsGenericElement::InternalGetFeature(static_cast<nsIDOM3Node*>(this),
29215:                                               aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::SetUserData(const nsAString& aKey,
    1:                             nsIVariant* aData,
    1:                             nsIDOMUserDataHandler* aHandler,
    1:                             nsIVariant** aResult)
    1: {
 1391:   return nsNodeUtils::SetUserData(mContent, aKey, aData, aHandler, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetUserData(const nsAString& aKey,
    1:                             nsIVariant** aResult)
    1: {
 1391:   return nsNodeUtils::GetUserData(mContent, aKey, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::LookupPrefix(const nsAString& aNamespaceURI,
    1:                              nsAString& aPrefix)
    1: {
    1:   SetDOMStringToNull(aPrefix);
    1: 
    1:   // XXX Waiting for DOM spec to list error codes.
    1: 
    1:   // Trace up the content parent chain looking for the namespace
    1:   // declaration that defines the aNamespaceURI namespace. Once found,
    1:   // return the prefix (i.e. the attribute localName).
    1:   for (nsIContent* content = mContent; content;
    1:        content = content->GetParent()) {
    1:     PRUint32 attrCount = content->GetAttrCount();
    1: 
    1:     for (PRUint32 i = 0; i < attrCount; ++i) {
    1:       const nsAttrName* name = content->GetAttrNameAt(i);
    1: 
    1:       if (name->NamespaceEquals(kNameSpaceID_XMLNS) &&
    1:           content->AttrValueIs(kNameSpaceID_XMLNS, name->LocalName(),
    1:                                aNamespaceURI, eCaseMatters)) {
    1:         // If the localName is "xmlns", the prefix we output should be
    1:         // null.
    1:         if (name->LocalName() != nsGkAtoms::xmlns) {
    1:           name->LocalName()->ToString(aPrefix);
    1:         }
    1: 
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::LookupNamespaceURI(const nsAString& aNamespacePrefix,
    1:                                    nsAString& aNamespaceURI)
    1: {
    1:   if (NS_FAILED(nsContentUtils::LookupNamespaceURI(mContent,
    1:                                                    aNamespacePrefix,
    1:                                                    aNamespaceURI))) {
    1:     SetDOMStringToNull(aNamespaceURI);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::IsDefaultNamespace(const nsAString& aNamespaceURI,
    1:                                    PRBool* aReturn)
    1: {
    1:   nsAutoString defaultNamespace;
    1:   LookupNamespaceURI(EmptyString(), defaultNamespace);
    1:   *aReturn = aNamespaceURI.Equals(defaultNamespace);
    1:   return NS_OK;
    1: }
    1: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetFirstElementChild(nsIDOMElement** aResult)
17074: {
17074:   *aResult = nsnull;
17074: 
17074:   nsAttrAndChildArray& children = mContent->mAttrsAndChildren;
17074:   PRUint32 i, count = children.ChildCount();
17074:   for (i = 0; i < count; ++i) {
17074:     nsIContent* child = children.ChildAt(i);
17074:     if (child->IsNodeOfType(nsINode::eELEMENT)) {
17074:       return CallQueryInterface(child, aResult);
17074:     }
17074:   }
17074:   
17074:   return NS_OK;
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetLastElementChild(nsIDOMElement** aResult)
17074: {
17074:   *aResult = nsnull;
17074: 
17074:   nsAttrAndChildArray& children = mContent->mAttrsAndChildren;
17074:   PRUint32 i = children.ChildCount();
17074:   while (i > 0) {
17074:     nsIContent* child = children.ChildAt(--i);
17074:     if (child->IsNodeOfType(nsINode::eELEMENT)) {
17074:       return CallQueryInterface(child, aResult);
17074:     }
17074:   }
17074:   
17074:   return NS_OK;
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetPreviousElementSibling(nsIDOMElement** aResult)
17074: {
17074:   *aResult = nsnull;
17074: 
17074:   nsIContent* parent = mContent->GetParent();
17074:   if (!parent) {
17074:     return NS_OK;
17074:   }
17074: 
17074:   NS_ASSERTION(parent->IsNodeOfType(nsINode::eELEMENT) ||
17074:                parent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT),
17074:                "Parent content must be an element or a doc fragment");
17074: 
17074:   nsAttrAndChildArray& children =
17074:     static_cast<nsGenericElement*>(parent)->mAttrsAndChildren;
17074:   PRInt32 index = children.IndexOfChild(mContent);
17074:   if (index < 0) {
17074:     return NS_OK;
17074:   }
17074: 
17074:   PRUint32 i = index;
17074:   while (i > 0) {
17074:     nsIContent* child = children.ChildAt((PRUint32)--i);
17074:     if (child->IsNodeOfType(nsINode::eELEMENT)) {
17074:       return CallQueryInterface(child, aResult);
17074:     }
17074:   }
17074:   
17074:   return NS_OK;
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetNextElementSibling(nsIDOMElement** aResult)
17074: {
17074:   *aResult = nsnull;
17074: 
17074:   nsIContent* parent = mContent->GetParent();
17074:   if (!parent) {
17074:     return NS_OK;
17074:   }
17074: 
17074:   NS_ASSERTION(parent->IsNodeOfType(nsINode::eELEMENT) ||
17074:                parent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT),
17074:                "Parent content must be an element or a doc fragment");
17074: 
17074:   nsAttrAndChildArray& children =
17074:     static_cast<nsGenericElement*>(parent)->mAttrsAndChildren;
17074:   PRInt32 index = children.IndexOfChild(mContent);
17074:   if (index < 0) {
17074:     return NS_OK;
17074:   }
17074: 
17074:   PRUint32 i, count = children.ChildCount();
17074:   for (i = (PRUint32)index + 1; i < count; ++i) {
17074:     nsIContent* child = children.ChildAt(i);
17074:     if (child->IsNodeOfType(nsINode::eELEMENT)) {
17074:       return CallQueryInterface(child, aResult);
17074:     }
17074:   }
17074:   
17074:   return NS_OK;
17074: }
17074: 
17074: nsContentList*
17074: nsNSElementTearoff::GetChildrenList()
17074: {
17074:   nsGenericElement::nsDOMSlots *slots = mContent->GetDOMSlots();
17074:   NS_ENSURE_TRUE(slots, nsnull);
17074: 
17074:   if (!slots->mChildrenList) {
17074:     slots->mChildrenList = new nsContentList(mContent, nsGkAtoms::_asterix,
17074:                                              kNameSpaceID_Wildcard, PR_FALSE);
17074:   }
17074: 
17074:   return slots->mChildrenList;
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetChildElementCount(PRUint32* aResult)
17074: {
17074:   *aResult = 0;
17074: 
17074:   nsContentList* list = GetChildrenList();
17074:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
17074: 
17074:   *aResult = list->Length(PR_TRUE);
17074: 
17074:   return NS_OK;
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetChildren(nsIDOMNodeList** aResult)
17074: {
17074:   *aResult = nsnull;
17074: 
17074:   nsContentList* list = GetChildrenList();
17074:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
17074: 
17074:   NS_ADDREF(*aResult = list);
17074: 
17074:   return NS_OK;
17074: }
17074: 
31383: NS_IMETHODIMP
31383: nsNSElementTearoff::GetClassList(nsIDOMDOMTokenList** aResult)
31383: {
31383:   nsGenericElement::nsDOMSlots *slots = mContent->GetDOMSlots();
31383:   NS_ENSURE_TRUE(slots, nsnull);
31383: 
31383:   if (!slots->mClassList) {
31383:     nsCOMPtr<nsIAtom> classAttr = mContent->GetClassAttributeName();
31383:     NS_ENSURE_TRUE(classAttr, NS_OK);
31383:     slots->mClassList = new nsDOMTokenList(mContent, classAttr);
31383:     NS_ENSURE_TRUE(slots->mClassList, NS_ERROR_OUT_OF_MEMORY);
31383:   }
31383: 
31383:   NS_ADDREF(*aResult = slots->mClassList);
31383: 
31383:   return NS_OK;
31383: }
31383: 
32435: NS_IMETHODIMP
32435: nsNSElementTearoff::SetCapture(PRBool aRetargetToElement)
32435: {
32435:   // If there is already an active capture, ignore this request. This would
32435:   // occur if a splitter, frame resizer, etc had already captured and we don't
32435:   // want to override those.
32435:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(nsIPresShell::GetCapturingContent());
32435:   if (node)
32435:     return NS_OK;
32435: 
32435:   nsIPresShell::SetCapturingContent(mContent, aRetargetToElement ? CAPTURE_RETARGETTOELEMENT : 0);
32435:   return NS_OK;
32435: }
32435: 
32435: NS_IMETHODIMP
32435: nsNSElementTearoff::ReleaseCapture()
32435: {
32435:   if (nsIPresShell::GetCapturingContent() == mContent) {
32435:     nsIPresShell::SetCapturingContent(nsnull, 0);
32435:   }
32435:   return NS_OK;
32435: }
32435: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
 5545: NS_IMPL_CYCLE_COLLECTION_1(nsNSElementTearoff, mContent)
 5545: 
    1: NS_INTERFACE_MAP_BEGIN(nsNSElementTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSElement)
 5545:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsNSElementTearoff)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
    1: 
 5545: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNSElementTearoff)
 5545: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNSElementTearoff)
    1: 
    1: NS_IMETHODIMP
    1: nsNSElementTearoff::GetElementsByClassName(const nsAString& aClasses,
    1:                                            nsIDOMNodeList** aReturn)
    1: {
    1:   return nsDocument::GetElementsByClassNameHelper(mContent, aClasses, aReturn);
    1: }
    1: 
16722: nsIFrame*
16722: nsGenericElement::GetStyledFrame()
16722: {
16722:   nsIFrame *frame = GetPrimaryFrame(Flush_Layout);
16722: 
16722:   return (frame && frame->GetType() == nsGkAtoms::tableOuterFrame) ?
16722:     frame->GetFirstChild(nsnull) : frame;
16722: }
16722: 
16722: void
16722: nsGenericElement::GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent)
16722: {
16722:   *aOffsetParent = nsnull;
16722:   aRect = nsRect();
16722: 
16722:   nsIFrame* frame = GetStyledFrame();
16722:   if (!frame) {
16722:     return;
16722:   }
16722: 
16722:   nsPoint origin = frame->GetPosition();
16722:   aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
16722:   aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
16722: 
16722:   // Get the union of all rectangles in this and continuation frames.
16722:   // It doesn't really matter what we use as aRelativeTo here, since
16722:   // we only care about the size. Using 'parent' might make things
16722:   // a bit faster by speeding up the internal GetOffsetTo operations.
18884:   nsIFrame* parent = frame->GetParent() ? frame->GetParent() : frame;
18884:   nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, parent);
16722:   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
16722:   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
16722: }
16722: 
16722: void
16722: nsNSElementTearoff::GetScrollInfo(nsIScrollableView **aScrollableView,
16722:                                   nsIFrame **aFrame)
16722: {
16722:   *aScrollableView = nsnull;
16722: 
16722:   // it isn't clear what to return for SVG nodes, so just return nothing
33329:   if (mContent->IsSVG()) {
16722:     if (aFrame)
16722:       *aFrame = nsnull;
16722:     return;
16722:   }
16722: 
16722:   nsIFrame* frame =
16722:     (static_cast<nsGenericElement*>(mContent))->GetStyledFrame();
16722: 
16722:   if (aFrame) {
16722:     *aFrame = frame;
16722:   }
16722:   if (!frame) {
16722:     return;
16722:   }
16722: 
16722:   // Get the scrollable frame
23554:   nsIScrollableFrame *scrollFrame = do_QueryFrame(frame);
16722:   if (!scrollFrame) {
23554:     nsIScrollableViewProvider *scrollProvider = do_QueryFrame(frame);
16722:     // menu frames implement nsIScrollableViewProvider but we don't want
16722:     // to use it here.
16722:     if (scrollProvider && frame->GetType() != nsGkAtoms::menuFrame) {
16722:       *aScrollableView = scrollProvider->GetScrollableView();
16722:       if (*aScrollableView) {
16722:         return;
16722:       }
16722:     }
16722: 
16722:     nsIDocument* doc = mContent->GetCurrentDoc();
16722:     PRBool quirksMode = doc &&
16722:                         doc->GetCompatibilityMode() == eCompatibility_NavQuirks;
16722:     if ((quirksMode && mContent->NodeInfo()->Equals(nsGkAtoms::body)) ||
16722:         (!quirksMode && mContent->NodeInfo()->Equals(nsGkAtoms::html))) {
16722:       // In quirks mode, the scroll info for the body element should map to the
16722:       // scroll info for the nearest scrollable frame above the body element
16722:       // (i.e. the root scrollable frame).  This is what IE6 does in quirks
16722:       // mode.  In strict mode the root scrollable frame corresponds to the
16722:       // html element in IE6, so we map the scroll info for the html element to
16722:       // the root scrollable frame.
16722: 
16722:       do {
16722:         frame = frame->GetParent();
16722: 
16722:         if (!frame) {
16722:           break;
16722:         }
16722: 
23554:         scrollFrame = do_QueryFrame(frame);
16722:       } while (!scrollFrame);
16722:     }
16722: 
16722:     if (!scrollFrame) {
16722:       return;
16722:     }
16722:   }
16722: 
16722:   // Get the scrollable view
16722:   *aScrollableView = scrollFrame->GetScrollableView();
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetScrollTop(PRInt32* aScrollTop)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aScrollTop);
16722:   *aScrollTop = 0;
16722: 
16722:   nsIScrollableView *view;
16722:   nsresult rv = NS_OK;
16722: 
16722:   GetScrollInfo(&view);
16722: 
16722:   if (view) {
16722:     nscoord xPos, yPos;
16722:     rv = view->GetScrollPosition(xPos, yPos);
16722: 
16722:     *aScrollTop = nsPresContext::AppUnitsToIntCSSPixels(yPos);
16722:   }
16722: 
16722:   return rv;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::SetScrollTop(PRInt32 aScrollTop)
16722: {
16722:   nsIScrollableView *view;
16722:   nsresult rv = NS_OK;
16722: 
16722:   GetScrollInfo(&view);
16722: 
16722:   if (view) {
16722:     nscoord xPos, yPos;
16722: 
16722:     rv = view->GetScrollPosition(xPos, yPos);
16722: 
16722:     if (NS_SUCCEEDED(rv)) {
16722:       rv = view->ScrollTo(xPos, nsPresContext::CSSPixelsToAppUnits(aScrollTop),
21290:                           0);
16722:     }
16722:   }
16722: 
16722:   return rv;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetScrollLeft(PRInt32* aScrollLeft)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aScrollLeft);
16722:   *aScrollLeft = 0;
16722: 
16722:   nsIScrollableView *view;
16722:   nsresult rv = NS_OK;
16722: 
16722:   GetScrollInfo(&view);
16722: 
16722:   if (view) {
16722:     nscoord xPos, yPos;
16722:     rv = view->GetScrollPosition(xPos, yPos);
16722: 
16722:     *aScrollLeft = nsPresContext::AppUnitsToIntCSSPixels(xPos);
16722:   }
16722: 
16722:   return rv;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::SetScrollLeft(PRInt32 aScrollLeft)
16722: {
16722:   nsIScrollableView *view;
16722:   nsresult rv = NS_OK;
16722: 
16722:   GetScrollInfo(&view);
16722: 
16722:   if (view) {
16722:     nscoord xPos, yPos;
16722:     rv = view->GetScrollPosition(xPos, yPos);
16722: 
16722:     if (NS_SUCCEEDED(rv)) {
16722:       rv = view->ScrollTo(nsPresContext::CSSPixelsToAppUnits(aScrollLeft),
21290:                           yPos, 0);
16722:     }
16722:   }
16722: 
16722:   return rv;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetScrollHeight(PRInt32* aScrollHeight)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aScrollHeight);
16722:   *aScrollHeight = 0;
16722: 
33329:   if (mContent->IsSVG())
16722:     return NS_OK;
16722: 
16722:   nsIScrollableView *scrollView;
16722:   nsresult rv = NS_OK;
16722: 
16722:   GetScrollInfo(&scrollView);
16722: 
16722:   if (!scrollView) {
16722:     nsRect rcFrame;
16722:     nsCOMPtr<nsIContent> parent;
16722:     (static_cast<nsGenericElement *>(mContent))->GetOffsetRect(rcFrame, getter_AddRefs(parent));
16722:     *aScrollHeight = rcFrame.height;
16722:     return NS_OK;
16722:   }
16722: 
16722:   // xMax and yMax is the total length of our container
16722:   nscoord xMax, yMax;
16722:   rv = scrollView->GetContainerSize(&xMax, &yMax);
16722: 
16722:   *aScrollHeight = nsPresContext::AppUnitsToIntCSSPixels(yMax);
16722: 
16722:   return rv;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetScrollWidth(PRInt32* aScrollWidth)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aScrollWidth);
16722:   *aScrollWidth = 0;
16722: 
33329:   if (mContent->IsSVG())
16722:     return NS_OK;
16722: 
16722:   nsIScrollableView *scrollView;
16722:   nsresult rv = NS_OK;
16722: 
16722:   GetScrollInfo(&scrollView);
16722: 
16722:   if (!scrollView) {
16722:     nsRect rcFrame;
16722:     nsCOMPtr<nsIContent> parent;
16722:     (static_cast<nsGenericElement *>(mContent))->GetOffsetRect(rcFrame, getter_AddRefs(parent));
16722:     *aScrollWidth = rcFrame.width;
16722:     return NS_OK;
16722:   }
16722: 
16722:   nscoord xMax, yMax;
16722:   rv = scrollView->GetContainerSize(&xMax, &yMax);
16722: 
16722:   *aScrollWidth = nsPresContext::AppUnitsToIntCSSPixels(xMax);
16722: 
16722:   return rv;
16722: }
16722: 
16722: nsRect
16722: nsNSElementTearoff::GetClientAreaRect()
16722: {
16722:   nsIScrollableView *scrollView;
16722:   nsIFrame *frame;
16722: 
16722:   // it isn't clear what to return for SVG nodes, so just return 0
33329:   if (mContent->IsSVG())
16722:     return nsRect(0, 0, 0, 0);
16722: 
16722:   GetScrollInfo(&scrollView, &frame);
16722: 
16722:   if (scrollView) {
16722:     return scrollView->View()->GetBounds();
16722:   }
16722: 
16722:   if (frame &&
16722:       (frame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE ||
16722:        frame->IsFrameOfType(nsIFrame::eReplaced))) {
16722:     // Special case code to make client area work even when there isn't
16722:     // a scroll view, see bug 180552, bug 227567.
16722:     return frame->GetPaddingRect() - frame->GetPositionIgnoringScrolling();
16722:   }
16722: 
16722:   return nsRect(0, 0, 0, 0);
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetClientTop(PRInt32* aLength)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aLength);
16722:   *aLength = nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().y);
16722:   return NS_OK;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetClientLeft(PRInt32* aLength)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aLength);
16722:   *aLength = nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().x);
16722:   return NS_OK;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetClientHeight(PRInt32* aLength)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aLength);
16722:   *aLength = nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().height);
16722:   return NS_OK;
16722: }
16722: 
16722: nsresult
16722: nsNSElementTearoff::GetClientWidth(PRInt32* aLength)
16722: {
16722:   NS_ENSURE_ARG_POINTER(aLength);
16722:   *aLength = nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().width);
16722:   return NS_OK;
16722: }
16722: 
 2014: NS_IMETHODIMP
12913: nsNSElementTearoff::GetBoundingClientRect(nsIDOMClientRect** aResult)
 2014: {
 2014:   // Weak ref, since we addref it below
12913:   nsClientRect* rect = new nsClientRect();
 2014:   if (!rect)
 2014:     return NS_ERROR_OUT_OF_MEMORY;
 2014: 
 2014:   NS_ADDREF(*aResult = rect);
 2014:   
 2014:   nsIFrame* frame = mContent->GetPrimaryFrame(Flush_Layout);
 2014:   if (!frame) {
 2014:     // display:none, perhaps? Return the empty rect
 2014:     return NS_OK;
 2014:   }
12349: 
12349:   nsRect r = nsLayoutUtils::GetAllInFlowRectsUnion(frame,
33027:           nsLayoutUtils::GetContainingBlockForClientRect(frame));
32894:   rect->SetLayoutRect(r);
 2014:   return NS_OK;
 2014: }
 2014: 
10833: NS_IMETHODIMP
12913: nsNSElementTearoff::GetClientRects(nsIDOMClientRectList** aResult)
10833: {
10833:   *aResult = nsnull;
10833: 
12913:   nsRefPtr<nsClientRectList> rectList = new nsClientRectList();
10833:   if (!rectList)
10833:     return NS_ERROR_OUT_OF_MEMORY;
10833: 
10833:   nsIFrame* frame = mContent->GetPrimaryFrame(Flush_Layout);
10833:   if (!frame) {
10833:     // display:none, perhaps? Return an empty list
10833:     *aResult = rectList.forget().get();
10833:     return NS_OK;
10833:   }
10833: 
33027:   nsLayoutUtils::RectListBuilder builder(rectList);
12349:   nsLayoutUtils::GetAllInFlowRects(frame,
33027:           nsLayoutUtils::GetContainingBlockForClientRect(frame), &builder);
12349:   if (NS_FAILED(builder.mRV))
12349:     return builder.mRV;
10833:   *aResult = rectList.forget().get();
 2014:   return NS_OK;
 2014: }
 2014: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
    1: NS_IMPL_ISUPPORTS1(nsNodeWeakReference,
    1:                    nsIWeakReference)
    1: 
    1: nsNodeWeakReference::~nsNodeWeakReference()
    1: {
    1:   if (mNode) {
    1:     NS_ASSERTION(mNode->GetSlots() &&
    1:                  mNode->GetSlots()->mWeakReference == this,
    1:                  "Weak reference has wrong value");
    1:     mNode->GetSlots()->mWeakReference = nsnull;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNodeWeakReference::QueryReferent(const nsIID& aIID, void** aInstancePtr)
    1: {
    1:   return mNode ? mNode->QueryInterface(aIID, aInstancePtr) :
    1:                  NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSupportsWeakRefTearoff, mNode)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSupportsWeakRefTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSupportsWeakRefTearoff)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSupportsWeakRefTearoff)
    1: 
    1: NS_IMETHODIMP
    1: nsNodeSupportsWeakRefTearoff::GetWeakReference(nsIWeakReference** aInstancePtr)
    1: {
    1:   nsINode::nsSlots* slots = mNode->GetSlots();
    1:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (!slots->mWeakReference) {
    1:     slots->mWeakReference = new nsNodeWeakReference(mNode);
    1:     NS_ENSURE_TRUE(slots->mWeakReference, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   NS_ADDREF(*aInstancePtr = slots->mWeakReference);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsDOMEventRTTearoff *
    1: nsDOMEventRTTearoff::mCachedEventTearoff[NS_EVENT_TEAROFF_CACHE_SIZE];
    1: 
    1: PRUint32 nsDOMEventRTTearoff::mCachedEventTearoffCount = 0;
    1: 
    1: 
28073: nsDOMEventRTTearoff::nsDOMEventRTTearoff(nsINode *aNode)
28073:   : mNode(aNode)
    1: {
    1: }
    1: 
    1: nsDOMEventRTTearoff::~nsDOMEventRTTearoff()
    1: {
    1: }
    1: 
28073: NS_IMPL_CYCLE_COLLECTION_1(nsDOMEventRTTearoff, mNode)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMEventRTTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3EventTarget)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEventTarget)
28073: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsDOMEventRTTearoff,
    1:                                           nsIDOMEventTarget)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsDOMEventRTTearoff,
    1:                                                         nsIDOMEventTarget,
    1:                                                         LastRelease())
    1: 
    1: nsDOMEventRTTearoff *
28073: nsDOMEventRTTearoff::Create(nsINode *aNode)
    1: {
    1:   if (mCachedEventTearoffCount) {
    1:     // We have cached unused instances of this class, return a cached
    1:     // instance in stead of always creating a new one.
    1:     nsDOMEventRTTearoff *tearoff =
    1:       mCachedEventTearoff[--mCachedEventTearoffCount];
    1: 
    1:     // Set the back pointer to the content object
28073:     tearoff->mNode = aNode;
    1: 
    1:     return tearoff;
    1:   }
    1: 
    1:   // The cache is empty, this means we haveto create a new instance.
28073:   return new nsDOMEventRTTearoff(aNode);
    1: }
    1: 
    1: // static
    1: void
    1: nsDOMEventRTTearoff::Shutdown()
    1: {
    1:   // Clear our cache.
    1:   while (mCachedEventTearoffCount) {
    1:     delete mCachedEventTearoff[--mCachedEventTearoffCount];
    1:   }
    1: }
    1: 
    1: void
    1: nsDOMEventRTTearoff::LastRelease()
    1: {
    1:   if (mCachedEventTearoffCount < NS_EVENT_TEAROFF_CACHE_SIZE) {
    1:     // There's still space in the cache for one more instance, put
    1:     // this instance in the cache in stead of deleting it.
    1:     mCachedEventTearoff[mCachedEventTearoffCount++] = this;
    1: 
    1:     // Don't set mContent to null directly since setting mContent to null
    1:     // could result in code that grabs a tearoff from the cache and we don't
    1:     // want to get reused while still being torn down.
    1:     // See bug 330526.
28073:     nsCOMPtr<nsINode> kungFuDeathGrip;
28073:     kungFuDeathGrip.swap(mNode);
    1: 
    1:     // The refcount balancing and destructor re-entrancy protection
    1:     // code in Release() sets mRefCnt to 1 so we have to set it to 0
    1:     // here to prevent leaks
    1:     mRefCnt = 0;
    1: 
    1:     return;
    1:   }
    1: 
    1:   delete this;
    1: }
    1: 
    1: nsresult
    1: nsDOMEventRTTearoff::GetDOM3EventTarget(nsIDOM3EventTarget **aTarget)
    1: {
29474:   nsIEventListenerManager* listener_manager =
29474:     mNode->GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(listener_manager);
    1:   return CallQueryInterface(listener_manager, aTarget);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::GetScriptTypeID(PRUint32 *aLang)
    1: {
28073:   *aLang = mNode->GetScriptTypeID();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::SetScriptTypeID(PRUint32 aLang)
    1: {
28073:   return mNode->SetScriptTypeID(aLang);
    1: }
    1: 
    1: 
    1: // nsIDOMEventTarget
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::AddEventListener(const nsAString& aType,
    1:                                       nsIDOMEventListener *aListener,
    1:                                       PRBool useCapture)
    1: {
    1:   return
    1:     AddEventListener(aType, aListener, useCapture,
28073:                      !nsContentUtils::IsChromeDoc(mNode->GetOwnerDoc()));
    1: }
    1: 
    1: NS_IMETHODIMP
 1418: nsDOMEventRTTearoff::RemoveEventListener(const nsAString& aType,
 1418:                                          nsIDOMEventListener* aListener,
 1418:                                          PRBool aUseCapture)
    1: {
 1418:   return RemoveGroupedEventListener(aType, aListener, aUseCapture, nsnull);
 1418: }
 1418: 
 1418: NS_IMETHODIMP
 1418: nsDOMEventRTTearoff::DispatchEvent(nsIDOMEvent *aEvt, PRBool* _retval)
 1418: {
29474:   nsCOMPtr<nsIDOMEventTarget> target =
29474:     do_QueryInterface(mNode->GetListenerManager(PR_TRUE));
 1418:   NS_ENSURE_STATE(target);
 1418:   return target->DispatchEvent(aEvt, _retval);
    1: }
    1: 
    1: // nsIDOM3EventTarget
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::AddGroupedEventListener(const nsAString& aType,
    1:                                              nsIDOMEventListener *aListener,
    1:                                              PRBool aUseCapture,
    1:                                              nsIDOMEventGroup *aEvtGrp)
    1: {
    1:   nsCOMPtr<nsIDOM3EventTarget> event_target;
    1:   nsresult rv = GetDOM3EventTarget(getter_AddRefs(event_target));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return event_target->AddGroupedEventListener(aType, aListener, aUseCapture,
    1:                                                aEvtGrp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::RemoveGroupedEventListener(const nsAString& aType,
    1:                                                 nsIDOMEventListener *aListener,
    1:                                                 PRBool aUseCapture,
    1:                                                 nsIDOMEventGroup *aEvtGrp)
    1: {
    1:   nsCOMPtr<nsIDOM3EventTarget> event_target;
    1:   nsresult rv = GetDOM3EventTarget(getter_AddRefs(event_target));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return event_target->RemoveGroupedEventListener(aType, aListener,
    1:                                                   aUseCapture, aEvtGrp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::CanTrigger(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::IsRegisteredHere(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: // nsIDOMNSEventTarget
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::AddEventListener(const nsAString& aType,
    1:                                       nsIDOMEventListener *aListener,
    1:                                       PRBool aUseCapture,
    1:                                       PRBool aWantsUntrusted)
    1: {
29474:   nsIEventListenerManager* listener_manager =
29474:     mNode->GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(listener_manager);
    1: 
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
    1:   if (aWantsUntrusted) {
    1:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1:   }
    1: 
    1:   return listener_manager->AddEventListenerByType(aListener, aType, flags,
    1:                                                   nsnull);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
16106: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSelectorTearoff, mContent)
16106: 
16106: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSelectorTearoff)
16106:   NS_INTERFACE_MAP_ENTRY(nsIDOMNodeSelector)
16106: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
16106: 
16106: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSelectorTearoff)
16106: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSelectorTearoff)
16106: 
16106: NS_IMETHODIMP
16106: nsNodeSelectorTearoff::QuerySelector(const nsAString& aSelector,
16106:                                      nsIDOMElement **aReturn)
16106: {
16106:   return nsGenericElement::doQuerySelector(mContent, aSelector, aReturn);
16106: }
16106: 
16106: NS_IMETHODIMP
16106: nsNodeSelectorTearoff::QuerySelectorAll(const nsAString& aSelector,
16106:                                         nsIDOMNodeList **aReturn)
16106: {
16106:   return nsGenericElement::doQuerySelectorAll(mContent, aSelector, aReturn);
16106: }
16106: 
16106: //----------------------------------------------------------------------
    1: nsGenericElement::nsDOMSlots::nsDOMSlots(PtrBits aFlags)
    1:   : nsINode::nsSlots(aFlags),
    1:     mBindingParent(nsnull)
    1: {
    1: }
    1: 
    1: nsGenericElement::nsDOMSlots::~nsDOMSlots()
    1: {
    1:   if (mAttributeMap) {
    1:     mAttributeMap->DropReference();
    1:   }
31383: 
31383:   if (mClassList) {
31383:     mClassList->DropReference();
31383:   }
    1: }
    1: 
    1: nsGenericElement::nsGenericElement(nsINodeInfo *aNodeInfo)
11169:   : nsIContent(aNodeInfo)
    1: {
    1:   // Set the default scriptID to JS - but skip SetScriptTypeID as it
    1:   // does extra work we know isn't necessary here...
    1:   SetFlags(nsIProgrammingLanguage::JAVASCRIPT << NODE_SCRIPT_TYPE_OFFSET);
    1: }
    1: 
    1: nsGenericElement::~nsGenericElement()
    1: {
    1:   NS_PRECONDITION(!IsInDoc(),
    1:                   "Please remove this from the document properly");
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNodeName(nsAString& aNodeName)
    1: {
    1:   mNodeInfo->GetQualifiedName(aNodeName);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetLocalName(nsAString& aLocalName)
    1: {
    1:   mNodeInfo->GetLocalName(aLocalName);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   SetDOMStringToNull(aNodeValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   // The DOM spec says that when nodeValue is defined to be null "setting it
    1:   // has no effect", so we don't throw an exception.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNodeType(PRUint16* aNodeType)
    1: {
    1:   *aNodeType = (PRUint16)nsIDOMNode::ELEMENT_NODE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNamespaceURI(nsAString& aNamespaceURI)
    1: {
    1:   return mNodeInfo->GetNamespaceURI(aNamespaceURI);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetPrefix(nsAString& aPrefix)
    1: {
    1:   mNodeInfo->GetPrefix(aPrefix);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::SetPrefix(const nsAString& aPrefix)
    1: {
    1:   // XXX: Validate the prefix string!
    1: 
    1:   nsCOMPtr<nsIAtom> prefix;
    1: 
    1:   if (!aPrefix.IsEmpty()) {
    1:     prefix = do_GetAtom(aPrefix);
    1:     NS_ENSURE_TRUE(prefix, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   if (!nsContentUtils::IsValidNodeName(mNodeInfo->NameAtom(), prefix,
    1:                                        mNodeInfo->NamespaceID())) {
    1:     return NS_ERROR_DOM_NAMESPACE_ERR;
    1:   }
    1: 
    1:   nsCOMPtr<nsINodeInfo> newNodeInfo;
    1:   nsresult rv = nsContentUtils::PrefixChanged(mNodeInfo, prefix,
    1:                                               getter_AddRefs(newNodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mNodeInfo = newNodeInfo;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::InternalIsSupported(nsISupports* aObject,
    1:                                       const nsAString& aFeature,
    1:                                       const nsAString& aVersion,
    1:                                       PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = PR_FALSE;
    1: 
    1:   // Convert the incoming UTF16 strings to raw char*'s to save us some
    1:   // code when doing all those string compares.
    1:   NS_ConvertUTF16toUTF8 feature(aFeature);
    1:   NS_ConvertUTF16toUTF8 version(aVersion);
    1: 
    1:   const char *f = feature.get();
    1:   const char *v = version.get();
    1: 
    1:   if (PL_strcasecmp(f, "XML") == 0 ||
    1:       PL_strcasecmp(f, "HTML") == 0) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "1.0") == 0 ||
    1:         PL_strcmp(v, "2.0") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   } else if (PL_strcasecmp(f, "Views") == 0 ||
    1:              PL_strcasecmp(f, "StyleSheets") == 0 ||
    1:              PL_strcasecmp(f, "Core") == 0 ||
    1:              PL_strcasecmp(f, "CSS") == 0 ||
    1:              PL_strcasecmp(f, "CSS2") == 0 ||
    1:              PL_strcasecmp(f, "Events") == 0 ||
    1:              PL_strcasecmp(f, "UIEvents") == 0 ||
    1:              PL_strcasecmp(f, "MouseEvents") == 0 ||
    1:              // Non-standard!
    1:              PL_strcasecmp(f, "MouseScrollEvents") == 0 ||
    1:              PL_strcasecmp(f, "HTMLEvents") == 0 ||
    1:              PL_strcasecmp(f, "Range") == 0 ||
    1:              PL_strcasecmp(f, "XHTML") == 0) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "2.0") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   } else if (PL_strcasecmp(f, "XPath") == 0) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "3.0") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   }
    1: #ifdef MOZ_SVG
    1:   else if (PL_strcasecmp(f, "SVGEvents") == 0 ||
    1:            PL_strcasecmp(f, "SVGZoomEvents") == 0 ||
28081:            nsSVGFeatures::HaveFeature(aFeature)) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "1.0") == 0 ||
    1:         PL_strcmp(v, "1.1") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   }
    1: #endif /* MOZ_SVG */
23697: #ifdef MOZ_SMIL
25961:   else if (NS_SMILEnabled() && PL_strcasecmp(f, "TimeControl") == 0) {
23697:     if (aVersion.IsEmpty() || PL_strcmp(v, "1.0") == 0) {
23697:       *aReturn = PR_TRUE;
23697:     }
23697:   }
23697: #endif /* MOZ_SMIL */
    1:   else {
    1:     nsCOMPtr<nsIDOMNSFeatureFactory> factory =
    1:       GetDOMFeatureFactory(aFeature, aVersion);
    1: 
    1:     if (factory) {
    1:       factory->HasFeature(aObject, aFeature, aVersion, aReturn);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::InternalGetFeature(nsISupports* aObject,
    1:                                     const nsAString& aFeature,
    1:                                     const nsAString& aVersion,
    1:                                     nsISupports** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1:   nsCOMPtr<nsIDOMNSFeatureFactory> factory =
    1:     GetDOMFeatureFactory(aFeature, aVersion);
    1: 
    1:   if (factory) {
    1:     factory->GetFeature(aObject, aFeature, aVersion, aReturn);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: already_AddRefed<nsIDOMNSFeatureFactory>
    1: nsGenericElement::GetDOMFeatureFactory(const nsAString& aFeature,
    1:                                        const nsAString& aVersion)
    1: {
    1:   nsIDOMNSFeatureFactory *factory = nsnull;
    1:   nsCOMPtr<nsICategoryManager> categoryManager =
    1:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
    1:   if (categoryManager) {
    1:     nsCAutoString featureCategory(NS_DOMNS_FEATURE_PREFIX);
    1:     AppendUTF16toUTF8(aFeature, featureCategory);
    1:     nsXPIDLCString contractID;
    1:     nsresult rv = categoryManager->GetCategoryEntry(featureCategory.get(),
    1:                                                     NS_ConvertUTF16toUTF8(aVersion).get(),
    1:                                                     getter_Copies(contractID));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       CallGetService(contractID.get(), &factory);  // addrefs
    1:     }
    1:   }
    1:   return factory;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::IsSupported(const nsAString& aFeature,
    1:                               const nsAString& aVersion,
    1:                               PRBool* aReturn)
    1: {
    1:   return InternalIsSupported(this, aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::HasAttributes(PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   *aReturn = GetAttrCount() > 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAttributes);
    1:   nsDOMSlots *slots = GetDOMSlots();
    1: 
    1:   if (!slots) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (!slots->mAttributeMap) {
    1:     slots->mAttributeMap = new nsDOMAttributeMap(this);
    1:     if (!slots->mAttributeMap) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     if (!slots->mAttributeMap->Init()) {
    1:       slots->mAttributeMap = nsnull;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aAttributes = slots->mAttributeMap);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::HasChildNodes(PRBool* aReturn)
    1: {
    1:   *aReturn = mAttrsAndChildren.ChildCount() > 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetTagName(nsAString& aTagName)
    1: {
    1:   mNodeInfo->GetQualifiedName(aTagName);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttribute(const nsAString& aName,
    1:                                nsAString& aReturn)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     if (mNodeInfo->NamespaceID() == kNameSpaceID_XUL) {
    1:       // XXX should be SetDOMStringToNull(aReturn);
    1:       // See bug 232598
    1:       aReturn.Truncate();
    1:     }
    1:     else {
    1:       SetDOMStringToNull(aReturn);
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   GetAttr(name->NamespaceID(), name->LocalName(), aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttribute(const nsAString& aName,
    1:                                const nsAString& aValue)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aName);
    1:     NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return SetAttr(kNameSpaceID_None, nameAtom, aValue, PR_TRUE);
    1:   }
    1: 
    1:   return SetAttr(name->NamespaceID(), name->LocalName(), name->GetPrefix(),
    1:                  aValue, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::RemoveAttribute(const nsAString& aName)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Hold a strong reference here so that the atom or nodeinfo doesn't go
    1:   // away during UnsetAttr. If it did UnsetAttr would be left with a
    1:   // dangling pointer as argument without knowing it.
    1:   nsAttrName tmp(*name);
    1: 
    1:   return UnsetAttr(name->NamespaceID(), name->LocalName(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttributeNode(const nsAString& aName,
    1:                                    nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   rv = map->GetNamedItem(aName, getter_AddRefs(node));
    1: 
    1:   if (NS_SUCCEEDED(rv) && node) {
    1:     rv = CallQueryInterface(node, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttributeNode(nsIDOMAttr* aAttribute,
    1:                                    nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   NS_ENSURE_ARG_POINTER(aAttribute);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> returnNode;
    1:   rv = map->SetNamedItem(aAttribute, getter_AddRefs(returnNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (returnNode) {
    1:     rv = CallQueryInterface(returnNode, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::RemoveAttributeNode(nsIDOMAttr* aAttribute,
    1:                                       nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   NS_ENSURE_ARG_POINTER(aAttribute);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString name;
    1: 
    1:   rv = aAttribute->GetName(name);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     rv = map->RemoveNamedItem(name, getter_AddRefs(node));
    1: 
    1:     if (NS_SUCCEEDED(rv) && node) {
    1:       rv = CallQueryInterface(node, aReturn);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetElementsByTagName(const nsAString& aTagname,
    1:                                        nsIDOMNodeList** aReturn)
    1: {
    1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aTagname);
    1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsContentList *list = NS_GetContentList(this, nameAtom,
    1:                                           kNameSpaceID_Unknown).get();
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
    1:   *aReturn = list;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttributeNS(const nsAString& aNamespaceURI,
    1:                                  const nsAString& aLocalName,
    1:                                  nsAString& aReturn)
    1: {
    1:   PRInt32 nsid =
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
    1: 
    1:   if (nsid == kNameSpaceID_Unknown) {
    1:     // Unknown namespace means no attr...
    1: 
    1:     aReturn.Truncate();
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
    1:   GetAttr(nsid, name, aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttributeNS(const nsAString& aNamespaceURI,
    1:                                  const nsAString& aQualifiedName,
    1:                                  const nsAString& aValue)
    1: {
    1:   nsCOMPtr<nsINodeInfo> ni;
    1:   nsresult rv =
    1:     nsContentUtils::GetNodeInfoFromQName(aNamespaceURI, aQualifiedName,
    1:                                          mNodeInfo->NodeInfoManager(),
    1:                                          getter_AddRefs(ni));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return SetAttr(ni->NamespaceID(), ni->NameAtom(), ni->GetPrefixAtom(),
    1:                  aValue, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::RemoveAttributeNS(const nsAString& aNamespaceURI,
    1:                                     const nsAString& aLocalName)
    1: {
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
    1:   PRInt32 nsid =
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
    1: 
    1:   if (nsid == kNameSpaceID_Unknown) {
    1:     // Unknown namespace means no attr...
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoString tmp;
    1:   UnsetAttr(nsid, name, PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttributeNodeNS(const nsAString& aNamespaceURI,
    1:                                      const nsAString& aLocalName,
    1:                                      nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   rv = map->GetNamedItemNS(aNamespaceURI, aLocalName, getter_AddRefs(node));
    1: 
    1:   if (NS_SUCCEEDED(rv) && node) {
    1:     rv = CallQueryInterface(node, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttributeNodeNS(nsIDOMAttr* aNewAttr,
    1:                                      nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   NS_ENSURE_ARG_POINTER(aNewAttr);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> returnNode;
    1:   rv = map->SetNamedItemNS(aNewAttr, getter_AddRefs(returnNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (returnNode) {
    1:     rv = CallQueryInterface(returnNode, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
    1:                                          const nsAString& aLocalName,
    1:                                          nsIDOMNodeList** aReturn)
    1: {
    1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
    1: 
    1:   if (!aNamespaceURI.EqualsLiteral("*")) {
    1:     nsresult rv =
    1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
    1:                                                             nameSpaceId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aLocalName);
    1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsContentList *list = NS_GetContentList(this, nameAtom, nameSpaceId).get();
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
    1:   *aReturn = list;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::HasAttribute(const nsAString& aName, PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1:   *aReturn = (name != nsnull);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::HasAttributeNS(const nsAString& aNamespaceURI,
    1:                                  const nsAString& aLocalName,
    1:                                  PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   PRInt32 nsid =
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
    1: 
    1:   if (nsid == kNameSpaceID_Unknown) {
    1:     // Unknown namespace means no attr...
    1: 
    1:     *aReturn = PR_FALSE;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
    1:   *aReturn = HasAttr(nsid, name);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::JoinTextNodes(nsIContent* aFirst,
    1:                                 nsIContent* aSecond)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIDOMText> firstText(do_QueryInterface(aFirst, &rv));
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDOMText> secondText(do_QueryInterface(aSecond, &rv));
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsAutoString str;
    1: 
    1:       rv = secondText->GetData(str);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         rv = firstText->AppendData(str);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::Normalize()
    1: {
   62:   // Batch possible DOMSubtreeModified events.
   62:   mozAutoSubtreeModified subtree(GetOwnerDoc(), nsnull);
   62: 
    1:   nsresult result = NS_OK;
    1:   PRUint32 index, count = GetChildCount();
    1: 
    1:   for (index = 0; (index < count) && (NS_OK == result); index++) {
    1:     nsIContent *child = GetChildAt(index);
    1: 
    1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(child);
    1:     if (node) {
    1:       PRUint16 nodeType;
    1:       node->GetNodeType(&nodeType);
    1: 
    1:       switch (nodeType) {
    1:         case nsIDOMNode::TEXT_NODE:
    1: 
    1:           // ensure that if the text node is empty, it is removed
    1:           if (0 == child->TextLength()) {
    1:             result = RemoveChildAt(index, PR_TRUE);
    1:             if (NS_FAILED(result)) {
    1:               return result;
    1:             }
    1: 
    1:             count--;
    1:             index--;
    1:             break;
    1:           }
    1:  
    1:           if (index+1 < count) {
    1:             // Get the sibling. If it's also a text node, then
    1:             // remove it from the tree and join the two text
    1:             // nodes.
    1:             nsIContent *sibling = GetChildAt(index + 1);
    1: 
    1:             nsCOMPtr<nsIDOMNode> siblingNode = do_QueryInterface(sibling);
    1: 
    1:             if (siblingNode) {
    1:               PRUint16 siblingNodeType;
    1:               siblingNode->GetNodeType(&siblingNodeType);
    1: 
    1:               if (siblingNodeType == nsIDOMNode::TEXT_NODE) {
    1:                 result = RemoveChildAt(index+1, PR_TRUE);
    1:                 if (NS_FAILED(result)) {
    1:                   return result;
    1:                 }
    1: 
    1:                 result = JoinTextNodes(child, sibling);
    1:                 if (NS_FAILED(result)) {
    1:                   return result;
    1:                 }
    1:                 count--;
    1:                 index--;
    1:               }
    1:             }
    1:           }
    1:           break;
    1: 
    1:         case nsIDOMNode::ELEMENT_NODE:
    1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(child);
    1: 
    1:           if (element) {
    1:             result = element->Normalize();
    1:           }
    1:           break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
 1685: static nsXBLBinding*
 1685: GetFirstBindingWithContent(nsBindingManager* aBmgr, nsIContent* aBoundElem)
 1685: {
 1685:   nsXBLBinding* binding = aBmgr->GetBinding(aBoundElem);
 1685:   while (binding) {
 1685:     if (binding->GetAnonymousContent()) {
 1685:       return binding;
 1685:     }
 1685:     binding = binding->GetBaseBinding();
 1685:   }
 1685:   
 1685:   return nsnull;
 1685: }
 1685: 
 1728: static nsresult
 1728: BindNodesInInsertPoints(nsXBLBinding* aBinding, nsIContent* aInsertParent,
 1728:                         nsIDocument* aDocument)
 1728: {
 1728:   NS_PRECONDITION(aBinding && aInsertParent, "Missing arguments");
 1728: 
 1728:   nsresult rv;
 1728:   // These should be refcounted or otherwise protectable.
 1728:   nsInsertionPointList* inserts =
 1728:     aBinding->GetExistingInsertionPointsFor(aInsertParent);
 1728:   if (inserts) {
 1728:     PRBool allowScripts = aBinding->AllowScripts();
 3244: #ifdef MOZ_XUL
 1839:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(aDocument);
 3244: #endif
 1728:     PRUint32 i;
 1728:     for (i = 0; i < inserts->Length(); ++i) {
 1728:       nsCOMPtr<nsIContent> insertRoot =
 1728:         inserts->ElementAt(i)->GetDefaultContent();
 1728:       if (insertRoot) {
 1728:         PRUint32 j;
 1728:         for (j = 0; j < insertRoot->GetChildCount(); ++j) {
 1728:           nsCOMPtr<nsIContent> child = insertRoot->GetChildAt(j);
 1728:           rv = child->BindToTree(aDocument, aInsertParent,
 1728:                                  aBinding->GetBoundElement(), allowScripts);
 1728:           NS_ENSURE_SUCCESS(rv, rv);
 1839: 
 3244: #ifdef MOZ_XUL
 1839:           if (xulDoc) {
 1839:             xulDoc->AddSubtreeToDocument(child);
 1839:           }
 3244: #endif
 1728:         }
 1728:       }
 1728:     }
 1728:   }
 1728: 
 1728:   return NS_OK;
 1728: }
 1728: 
    1: nsresult
    1: nsGenericElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                              nsIContent* aBindingParent,
    1:                              PRBool aCompileEventHandlers)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(HasSameOwnerDoc(NODE_FROM(aParent, aDocument)),
    1:                   "Must have the same owner document");
 1498:   NS_PRECONDITION(!aParent || aDocument == aParent->GetCurrentDoc(),
    1:                   "aDocument must be current doc of aParent");
    1:   NS_PRECONDITION(!GetCurrentDoc(), "Already have a document.  Unbind first!");
    1:   // Note that as we recurse into the kids, they'll have a non-null parent.  So
    1:   // only assert if our parent is _changing_ while we have a parent.
    1:   NS_PRECONDITION(!GetParent() || aParent == GetParent(),
    1:                   "Already have a parent.  Unbind first!");
    1:   NS_PRECONDITION(!GetBindingParent() ||
    1:                   aBindingParent == GetBindingParent() ||
    1:                   (!aBindingParent && aParent &&
    1:                    aParent->GetBindingParent() == GetBindingParent()),
    1:                   "Already have a binding parent.  Unbind first!");
 1685:   NS_PRECONDITION(!aParent || !aDocument ||
 1685:                   !aParent->HasFlag(NODE_FORCE_XBL_BINDINGS),
 1685:                   "Parent in document but flagged as forcing XBL");
16126:   NS_PRECONDITION(aBindingParent != this,
16126:                   "Content must not be its own binding parent");
16126:   NS_PRECONDITION(!IsRootOfNativeAnonymousSubtree() ||
16126:                   aBindingParent == aParent,
16126:                   "Native anonymous content must have its parent as its "
12250:                   "own binding parent");
    1: 
    1:   if (!aBindingParent && aParent) {
    1:     aBindingParent = aParent->GetBindingParent();
    1:   }
    1: 
 3244: #ifdef MOZ_XUL
    1:   // First set the binding parent
 1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
 1498:   if (xulElem) {
 1498:     xulElem->SetXULBindingParent(aBindingParent);
 1498:   }
 3244:   else 
 3244: #endif
 3244:   {
    1:     if (aBindingParent) {
    1:       nsDOMSlots *slots = GetDOMSlots();
    1: 
    1:       if (!slots) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
    1:     }
 1498:   }
16126:   NS_ASSERTION(!aBindingParent || IsRootOfNativeAnonymousSubtree() ||
14239:                !HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE) ||
22217:                (aParent && aParent->IsInNativeAnonymousSubtree()),
14239:                "Trying to re-bind content from native anonymous subtree to "
14239:                "non-native anonymous parent!");
25511:   if (aParent && aParent->IsInNativeAnonymousSubtree()) {
14239:     SetFlags(NODE_IS_IN_ANONYMOUS_SUBTREE);
14239:   }
 1498: 
 1685:   PRBool hadForceXBL = HasFlag(NODE_FORCE_XBL_BINDINGS);
 1685: 
 1498:   // Now set the parent and set the "Force attach xbl" flag if needed.
    1:   if (aParent) {
 3233:     mParentPtrBits = reinterpret_cast<PtrBits>(aParent) | PARENT_BIT_PARENT_IS_CONTENT;
 1498: 
 1498:     if (aParent->HasFlag(NODE_FORCE_XBL_BINDINGS)) {
 1498:       SetFlags(NODE_FORCE_XBL_BINDINGS);
 1498:     }
    1:   }
    1:   else {
 3233:     mParentPtrBits = reinterpret_cast<PtrBits>(aDocument);
    1:   }
    1: 
    1:   // XXXbz sXBL/XBL2 issue!
    1: 
    1:   // Finally, set the document
    1:   if (aDocument) {
    1:     // Notify XBL- & nsIAnonymousContentCreator-generated
    1:     // anonymous content that the document is changing.
    1:     // XXXbz ordering issues here?  Probably not, since ChangeDocumentFor is
    1:     // just pretty broken anyway....  Need to get it working.
    1:     // XXXbz XBL doesn't handle this (asserts), and we don't really want
    1:     // to be doing this during parsing anyway... sort this out.    
    1:     //    aDocument->BindingManager()->ChangeDocumentFor(this, nsnull,
    1:     //                                                   aDocument);
    1: 
    1:     // Being added to a document.
    1:     mParentPtrBits |= PARENT_BIT_INDOCUMENT;
 1498: 
 1498:     // Unset this flag since we now really are in a document.
 1498:     UnsetFlags(NODE_FORCE_XBL_BINDINGS);
    1:   }
    1: 
 1685:   // If NODE_FORCE_XBL_BINDINGS was set we might have anonymous children
 1685:   // that also need to be told that they are moving.
 1685:   nsresult rv;
 1685:   if (hadForceXBL) {
 1685:     nsIDocument* ownerDoc = GetOwnerDoc();
 1685:     if (ownerDoc) {
 1685:       nsBindingManager* bmgr = ownerDoc->BindingManager();
 1685: 
 1685:       // First check if we have a binding...
 1685:       nsXBLBinding* contBinding =
 1685:         GetFirstBindingWithContent(bmgr, this);
 1685:       if (contBinding) {
 1685:         nsCOMPtr<nsIContent> anonRoot = contBinding->GetAnonymousContent();
 1685:         PRBool allowScripts = contBinding->AllowScripts();
 1685:         PRUint32 i;
 1685:         for (i = 0; i < anonRoot->GetChildCount(); ++i) {
 1685:           nsCOMPtr<nsIContent> child = anonRoot->GetChildAt(i);
 1685:           rv = child->BindToTree(aDocument, this, this, allowScripts);
 1685:           NS_ENSURE_SUCCESS(rv, rv);
 1685:         }
 1728: 
 1728:         // ...then check if we have content in insertion points that are
 1728:         // direct children of the <content>
 1728:         rv = BindNodesInInsertPoints(contBinding, this, aDocument);
 1728:         NS_ENSURE_SUCCESS(rv, rv);
 1728:       }
 1728: 
 1728:       // ...and finally check if we're in a binding where we have content in
 1728:       // insertion points.
 1685:       if (aBindingParent) {
 1685:         nsXBLBinding* binding = bmgr->GetBinding(aBindingParent);
 1685:         if (binding) {
 1728:           rv = BindNodesInInsertPoints(binding, this, aDocument);
 1685:           NS_ENSURE_SUCCESS(rv, rv);
 1685:         }
 1685:       }
 1685:     }
 1685:   }
 1685: 
 2896:   UpdateEditableState();
 2896: 
    1:   // Now recurse into our kids
    1:   PRUint32 i;
 1498:   // Don't call GetChildCount() here since that'll make XUL generate
 1498:   // template children, which we're not in a consistent enough state for.
 1498:   // Additionally, there's not really a need to generate the children here.
 1498:   for (i = 0; i < mAttrsAndChildren.ChildCount(); ++i) {
    1:     // The child can remove itself from the parent in BindToTree.
    1:     nsCOMPtr<nsIContent> child = mAttrsAndChildren.ChildAt(i);
    1:     rv = child->BindToTree(aDocument, this, aBindingParent,
    1:                            aCompileEventHandlers);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: 
    1:   // XXXbz script execution during binding can trigger some of these
    1:   // postcondition asserts....  But we do want that, since things will
    1:   // generally be quite broken when that happens.
    1:   NS_POSTCONDITION(aDocument == GetCurrentDoc(), "Bound to wrong document");
    1:   NS_POSTCONDITION(aParent == GetParent(), "Bound to wrong parent");
    1:   NS_POSTCONDITION(aBindingParent == GetBindingParent(),
    1:                    "Bound to wrong binding parent");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGenericElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
    1:   NS_PRECONDITION(aDeep || (!GetCurrentDoc() && !GetBindingParent()),
    1:                   "Shallow unbind won't clear document and binding parent on "
    1:                   "kids!");
    1:   // Make sure to unbind this node before doing the kids
 6167:   nsIDocument *document =
 6167:     HasFlag(NODE_FORCE_XBL_BINDINGS) ? GetOwnerDoc() : GetCurrentDoc();
24671: 
24671:   mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~PARENT_BIT_INDOCUMENT;
24671: 
    1:   if (document) {
    1:     // Notify XBL- & nsIAnonymousContentCreator-generated
    1:     // anonymous content that the document is changing.
    1:     document->BindingManager()->ChangeDocumentFor(this, document, nsnull);
    1: 
33251:     if (HasAttr(kNameSpaceID_XLink, nsGkAtoms::href)) {
33251:       document->ForgetLink(this);
33251:     }
33251: 
11838:     document->ClearBoxObjectFor(this);
    1:   }
    1: 
33649:   // Ensure that CSS transitions don't continue on an element at a
33649:   // different place in the tree (even if reinserted before next
33649:   // animation refresh).
33896:   // FIXME (Bug 522599): Need a test for this.
33649:   if (HasFlag(NODE_HAS_PROPERTIES)) {
33649:     DeleteProperty(nsGkAtoms::transitionsOfBeforeProperty);
33649:     DeleteProperty(nsGkAtoms::transitionsOfAfterProperty);
33649:     DeleteProperty(nsGkAtoms::transitionsProperty);
33649:   }
33649: 
 1498:   // Unset this since that's what the old code effectively did.
 1498:   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
 1498:   
 3244: #ifdef MOZ_XUL
 1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
 1498:   if (xulElem) {
 1498:     xulElem->SetXULBindingParent(nsnull);
 1498:   }
 3244:   else
 3244: #endif
 3244:   {
    1:     nsDOMSlots *slots = GetExistingDOMSlots();
    1:     if (slots) {
    1:       slots->mBindingParent = nsnull;
    1:     }
 1498:   }
    1: 
    1:   if (aDeep) {
 1498:     // Do the kids. Don't call GetChildCount() here since that'll force
 1498:     // XUL to generate template children, which there is no need for since
 1498:     // all we're going to do is unbind them anyway.
 1498:     PRUint32 i, n = mAttrsAndChildren.ChildCount();
    1: 
    1:     for (i = 0; i < n; ++i) {
    1:       // Note that we pass PR_FALSE for aNullParent here, since we don't want
    1:       // the kids to forget us.  We _do_ want them to forget their binding
    1:       // parent, though, since this only walks non-anonymous kids.
    1:       mAttrsAndChildren.ChildAt(i)->UnbindFromTree(PR_TRUE, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   return nsGenericElement::doPreHandleEvent(this, aVisitor);
    1: }
    1: 
12925: static nsIContent*
15478: FindNativeAnonymousSubtreeOwner(nsIContent* aContent)
12925: {
15478:   if (aContent->IsInNativeAnonymousSubtree()) {
15478:     PRBool isNativeAnon = PR_FALSE;
15478:     while (aContent && !isNativeAnon) {
16126:       isNativeAnon = aContent->IsRootOfNativeAnonymousSubtree();
12925:       aContent = aContent->GetParent();
12925:     }
15478:   }
12925:   return aContent;
12925: }
12925: 
    1: nsresult
    1: nsGenericElement::doPreHandleEvent(nsIContent* aContent,
    1:                                    nsEventChainPreVisitor& aVisitor)
    1: {
    1:   //FIXME! Document how this event retargeting works, Bug 329124.
    1:   aVisitor.mCanHandle = PR_TRUE;
 1401: 
 1401:   // Don't propagate mouseover and mouseout events when mouse is moving
 1401:   // inside native anonymous content.
16126:   PRBool isAnonForEvents = aContent->IsRootOfNativeAnonymousSubtree();
15478:   if ((aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH ||
15478:        aVisitor.mEvent->message == NS_MOUSE_EXIT_SYNTH) &&
18444:       // Check if we should stop event propagation when event has just been
18444:       // dispatched or when we're about to propagate from
18444:       // native anonymous subtree.
18444:       ((static_cast<nsISupports*>(aContent) == aVisitor.mEvent->originalTarget &&
18444:         !aContent->IsInNativeAnonymousSubtree()) || isAnonForEvents)) {
 1401:      nsCOMPtr<nsIContent> relatedTarget =
 3233:        do_QueryInterface(static_cast<nsMouseEvent*>
 3233:                                     (aVisitor.mEvent)->relatedTarget);
 1401:     if (relatedTarget &&
 1401:         relatedTarget->GetOwnerDoc() == aContent->GetOwnerDoc()) {
 1401: 
 1401:       // If current target is anonymous for events or we know that related
 1401:       // target is descendant of an element which is anonymous for events,
 1401:       // we may want to stop event propagation.
 1401:       // If aContent is the original target, aVisitor.mRelatedTargetIsInAnon
 1401:       // must be updated.
 1401:       if (isAnonForEvents || aVisitor.mRelatedTargetIsInAnon ||
 1401:           (aVisitor.mEvent->originalTarget == aContent &&
12250:            (aVisitor.mRelatedTargetIsInAnon =
12250:             relatedTarget->IsInNativeAnonymousSubtree()))) {
15478:         nsIContent* anonOwner = FindNativeAnonymousSubtreeOwner(aContent);
15478:         if (anonOwner) {
15478:           nsIContent* anonOwnerRelated =
15478:             FindNativeAnonymousSubtreeOwner(relatedTarget);
15478:           if (anonOwnerRelated) {
15478:             // Note, anonOwnerRelated may still be inside some other
15478:             // native anonymous subtree. The case where anonOwner is still
15478:             // inside native anonymous subtree will be handled when event
15478:             // propagates up in the DOM tree.
15478:             while (anonOwner != anonOwnerRelated &&
15478:                    anonOwnerRelated->IsInNativeAnonymousSubtree()) {
15478:               anonOwnerRelated = FindNativeAnonymousSubtreeOwner(anonOwnerRelated);
15478:             }
15478:             if (anonOwner == anonOwnerRelated) {
18444: #ifdef DEBUG_smaug
18444:               nsCOMPtr<nsIContent> originalTarget =
15478:                 do_QueryInterface(aVisitor.mEvent->originalTarget);
18444:               nsAutoString ot, ct, rt;
18444:               if (originalTarget) {
18444:                 originalTarget->Tag()->ToString(ot);
18444:               }
18444:               aContent->Tag()->ToString(ct);
18444:               relatedTarget->Tag()->ToString(rt);
18444:               printf("Stopping %s propagation:"
18444:                      "\n\toriginalTarget=%s \n\tcurrentTarget=%s %s"
18444:                      "\n\trelatedTarget=%s %s \n%s",
18444:                      (aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH)
18444:                        ? "mouseover" : "mouseout",
18444:                      NS_ConvertUTF16toUTF8(ot).get(),
18444:                      NS_ConvertUTF16toUTF8(ct).get(),
18444:                      isAnonForEvents
18444:                        ? "(is native anonymous)"
18444:                        : (aContent->IsInNativeAnonymousSubtree()
18444:                            ? "(is in native anonymous subtree)" : ""),
18444:                      NS_ConvertUTF16toUTF8(rt).get(),
18444:                      relatedTarget->IsInNativeAnonymousSubtree()
18444:                        ? "(is in native anonymous subtree)" : "",
18444:                      (originalTarget && relatedTarget->FindFirstNonNativeAnonymous() ==
18444:                        originalTarget->FindFirstNonNativeAnonymous())
18444:                        ? "" : "Wrong event propagation!?!\n");
18444: #endif
 1401:               aVisitor.mParentTarget = nsnull;
 1401:               // Event should not propagate to non-anon content.
 1401:               aVisitor.mCanHandle = isAnonForEvents;
 1401:               return NS_OK;
 1401:             }
 1401:           }
 1401:         }
 1401:       }
 1593:     }
 1593:   }
 1401: 
22211:   nsIContent* parent = aContent->GetParent();
22211:   // Event may need to be retargeted if aContent is the root of a native
22211:   // anonymous content subtree or event is dispatched somewhere inside XBL.
 1401:   if (isAnonForEvents) {
14239:     // If a DOM event is explicitly dispatched using node.dispatchEvent(), then
14239:     // all the events are allowed even in the native anonymous content..
14239:     NS_ASSERTION(aVisitor.mEvent->eventStructType != NS_MUTATION_EVENT ||
14239:                  aVisitor.mDOMEvent,
14239:                  "Mutation event dispatched in native anonymous content!?!");
    1:     aVisitor.mEventTargetAtParent = parent;
22211:   } else if (parent && aVisitor.mOriginalTargetIsInAnon) {
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(aVisitor.mEvent->target));
    1:     if (content && content->GetBindingParent() == parent) {
    1:       aVisitor.mEventTargetAtParent = parent;
    1:     }
    1:   }
    1: 
    1:   // check for an anonymous parent
    1:   // XXX XBL2/sXBL issue
    1:   nsIDocument* ownerDoc = aContent->GetOwnerDoc();
    1:   if (ownerDoc) {
    1:     nsIContent* insertionParent = ownerDoc->BindingManager()->
    1:       GetInsertionParent(aContent);
    1:     NS_ASSERTION(!(aVisitor.mEventTargetAtParent && insertionParent &&
    1:                    aVisitor.mEventTargetAtParent != insertionParent),
    1:                  "Retargeting and having insertion parent!");
    1:     if (insertionParent) {
    1:       parent = insertionParent;
    1:     }
    1:   }
    1: 
    1:   if (parent) {
    1:     aVisitor.mParentTarget = parent;
    1:   } else {
    1:     aVisitor.mParentTarget = aContent->GetCurrentDoc();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::PostHandleEvent(nsEventChainPostVisitor& /*aVisitor*/)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::DispatchDOMEvent(nsEvent* aEvent,
    1:                                    nsIDOMEvent* aDOMEvent,
    1:                                    nsPresContext* aPresContext,
    1:                                    nsEventStatus* aEventStatus)
    1: {
 3233:   return nsEventDispatcher::DispatchDOMEvent(static_cast<nsIContent*>(this),
    1:                                              aEvent, aDOMEvent,
    1:                                              aPresContext, aEventStatus);
    1: }
    1: 
    1: nsIAtom*
    1: nsGenericElement::GetID() const
    1: {
 6041:   if (!HasFlag(NODE_MAY_HAVE_ID)) {
 6041:     return nsnull;
 6041:   }
 6041: 
 4036:   nsIAtom* IDName = GetIDAttributeName();
    1:   if (IDName) {
 4036:     const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(IDName);
    1:     if (attrVal){
    1:       if (attrVal->Type() == nsAttrValue::eAtom) {
    1:         return attrVal->GetAtomValue();
    1:       }
    1:       if(attrVal->IsEmptyString()){
    1:         return nsnull;
    1:       }
    1:       // Check if the ID has been stored as a string.
    1:       // This would occur if the ID attribute name changed after 
    1:       // the ID was parsed. 
    1:       if (attrVal->Type() == nsAttrValue::eString) {
    1:         nsAutoString idVal(attrVal->GetStringValue());
    1: 
    1:         // Create an atom from the value and set it into the attribute list. 
 3233:         const_cast<nsAttrValue*>(attrVal)->ParseAtom(idVal);
    1:         return attrVal->GetAtomValue();
    1:       }
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: const nsAttrValue*
19132: nsGenericElement::DoGetClasses() const
19132: {
19132:   NS_NOTREACHED("Shouldn't ever be called");
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1:   return NS_OK;
    1: }
    1: 
32193: #ifdef MOZ_SMIL
32193: nsresult
32193: nsGenericElement::GetSMILOverrideStyle(nsIDOMCSSStyleDeclaration** aStyle)
32193: {
32193:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
32193:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
32193: 
32193:   if (!slots->mSMILOverrideStyle) {
32193:     slots->mSMILOverrideStyle = new nsDOMCSSAttributeDeclaration(this, PR_TRUE);
32193:     NS_ENSURE_TRUE(slots->mSMILOverrideStyle, NS_ERROR_OUT_OF_MEMORY);
32193:   }
32193: 
32193:   // Why bother with QI?
32193:   NS_ADDREF(*aStyle = slots->mSMILOverrideStyle);
32193:   return NS_OK;
32193: }
32193: 
32193: nsICSSStyleRule*
32193: nsGenericElement::GetSMILOverrideStyleRule()
32193: {
32193:   nsGenericElement::nsDOMSlots *slots = GetExistingDOMSlots();
33018:   return slots ? slots->mSMILOverrideStyleRule.get() : nsnull;
32193: }
32193: 
32193: nsresult
32193: nsGenericElement::SetSMILOverrideStyleRule(nsICSSStyleRule* aStyleRule,
32193:                                            PRBool aNotify)
32193: {
32193:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
32193:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
32193: 
32193:   slots->mSMILOverrideStyleRule = aStyleRule;
32193: 
32193:   if (aNotify) {
32193:     nsIDocument* doc = GetCurrentDoc();
34033:     // Only need to notify PresContexts if we're in a document.  (We might not
34033:     // be in a document, if we're clearing animation effects on a target node
34033:     // that's been detached since the previous animation sample.)
34033:     if (doc) {
32193:       nsPresShellIterator iter(doc);
32193:       nsCOMPtr<nsIPresShell> shell;
32193:       while (shell = iter.GetNextShell()) {
32193:         nsPresContext* presContext = shell->GetPresContext();
32193:         presContext->SMILOverrideStyleChanged(this);
32193:       }
32193:     }
34033:   }
32193: 
32193:   return NS_OK;
32193: }
32193: #endif // MOZ_SMIL
32193: 
    1: nsICSSStyleRule*
    1: nsGenericElement::GetInlineStyleRule()
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule,
    1:                                      PRBool aNotify)
    1: {
    1:   NS_NOTYETIMPLEMENTED("nsGenericElement::SetInlineStyleRule");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsGenericElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsChangeHint
    1: nsGenericElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                          PRInt32 aModType) const
    1: {
    1:   return nsChangeHint(0);
    1: }
    1: 
    1: nsIAtom *
 4036: nsGenericElement::GetIDAttributeName() const
    1: {
 4036:   return mNodeInfo->GetIDAttributeAtom();
    1: }
    1: 
    1: nsIAtom *
    1: nsGenericElement::GetClassAttributeName() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::FindAttributeDependence(const nsIAtom* aAttribute,
    1:                                           const MappedAttributeEntry* const aMaps[],
    1:                                           PRUint32 aMapCount)
    1: {
    1:   for (PRUint32 mapindex = 0; mapindex < aMapCount; ++mapindex) {
    1:     for (const MappedAttributeEntry* map = aMaps[mapindex];
    1:          map->attribute; ++map) {
    1:       if (aAttribute == *map->attribute) {
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: already_AddRefed<nsINodeInfo>
    1: nsGenericElement::GetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aStr);
    1:   if (!name) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsINodeInfo* nodeInfo;
    1:   if (name->IsAtom()) {
19197:     nodeInfo = mNodeInfo->NodeInfoManager()->GetNodeInfo(name->Atom(), nsnull,
19197:                                                          kNameSpaceID_None).get();
    1:   }
    1:   else {
    1:     NS_ADDREF(nodeInfo = name->NodeInfo());
    1:   }
    1: 
    1:   return nodeInfo;
    1: }
    1: 
    1: already_AddRefed<nsIURI>
    1: nsGenericElement::GetBaseURI() const
    1: {
    1:   nsIDocument* doc = GetOwnerDoc();
    1:   if (!doc) {
    1:     // We won't be able to do security checks, etc.  So don't go any
    1:     // further.  That said, this really shouldn't happen...
    1:     NS_ERROR("Element without owner document");
    1:     return nsnull;
    1:   }
    1: 
    1:   // Our base URL depends on whether we have an xml:base attribute, as
    1:   // well as on whether any of our ancestors do.
    1:   nsCOMPtr<nsIURI> parentBase;
    1: 
    1:   nsIContent *parent = GetParent();
    1:   if (parent) {
    1:     parentBase = parent->GetBaseURI();
    1:   } else {
    1:     // No parent, so just use the document (we must be the root or not in the
    1:     // tree).
    1:     parentBase = doc->GetBaseURI();
    1:   }
    1:   
    1:   // Now check for an xml:base attr 
    1:   nsAutoString value;
    1:   GetAttr(kNameSpaceID_XML, nsGkAtoms::base, value);
    1:   if (value.IsEmpty()) {
    1:     // No xml:base, so we just use the parent's base URL
    1:     nsIURI *base = nsnull;
    1:     parentBase.swap(base);
    1: 
    1:     return base;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> ourBase;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(ourBase), value,
    1:                           doc->GetDocumentCharacterSet().get(), parentBase);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // do a security check, almost the same as nsDocument::SetBaseURL()
    1:     rv = nsContentUtils::GetSecurityManager()->
    1:       CheckLoadURIWithPrincipal(NodePrincipal(), ourBase,
    1:                                 nsIScriptSecurityManager::STANDARD);
    1:   }
    1: 
    1:   nsIURI *base;
    1:   if (NS_FAILED(rv)) {
    1:     base = parentBase;
    1:   } else {
    1:     base = ourBase;
    1:   }
    1: 
    1:   NS_IF_ADDREF(base);
    1: 
    1:   return base;    
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::IsLink(nsIURI** aURI) const
    1: {
    1:   *aURI = nsnull;
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsGenericElement::ShouldBlur(nsIContent *aContent)
    1: {
    1:   // Determine if the current element is focused, if it is not focused
    1:   // then we should not try to blur
    1:   nsIDocument *document = aContent->GetDocument();
29018:   if (!document)
29018:     return PR_FALSE;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(document->GetWindow());
29018:   if (!window)
29018:     return PR_FALSE;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> focusedFrame;
29018:   nsIContent* contentToBlur =
29018:     nsFocusManager::GetFocusedDescendant(window, PR_FALSE, getter_AddRefs(focusedFrame));
29018:   if (contentToBlur == aContent)
29018:     return PR_TRUE;
29018: 
29018:   // if focus on this element would get redirected, then check the redirected
29018:   // content as well when blurring.
29018:   return (contentToBlur && nsFocusManager::GetRedirectedFocus(aContent) == contentToBlur);
    1: }
    1: 
    1: nsIContent*
    1: nsGenericElement::GetBindingParent() const
    1: {
    1:   nsDOMSlots *slots = GetExistingDOMSlots();
    1: 
    1:   if (slots) {
    1:     return slots->mBindingParent;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:   return !(aFlags & ~(eCONTENT | eELEMENT));
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // virtual
    1: void
    1: nsGenericElement::SetMayHaveFrame(PRBool aMayHaveFrame)
    1: {
    1:   if (aMayHaveFrame) {
    1:     SetFlags(NODE_MAY_HAVE_FRAME);
    1:   } else {
    1:     UnsetFlags(NODE_MAY_HAVE_FRAME);
    1:   }
    1: }
    1: 
    1: // virtual
    1: PRBool
    1: nsGenericElement::MayHaveFrame() const
    1: {
    1:   return HasFlag(NODE_MAY_HAVE_FRAME);
    1: }
    1: 
    1: PRUint32
    1: nsGenericElement::GetScriptTypeID() const
    1: {
    1:     PtrBits flags = GetFlags();
    1: 
    1:     /* 4 bits reserved for script-type ID. */
    1:     return (flags >> NODE_SCRIPT_TYPE_OFFSET) & 0x000F;
    1: }
    1: 
28073: NS_IMETHODIMP
    1: nsGenericElement::SetScriptTypeID(PRUint32 aLang)
    1: {
    1:     if ((aLang & 0x000F) != aLang) {
    1:         NS_ERROR("script ID too large!");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     /* SetFlags will just mask in the specific flags set, leaving existing
    1:        ones alone.  So we must clear all the bits first */
    1:     UnsetFlags(0x000FU << NODE_SCRIPT_TYPE_OFFSET);
    1:     SetFlags(aLang << NODE_SCRIPT_TYPE_OFFSET);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::InsertChildAt(nsIContent* aKid,
    1:                                 PRUint32 aIndex,
    1:                                 PRBool aNotify)
    1: {
    1:   NS_PRECONDITION(aKid, "null ptr");
    1: 
    1:   return doInsertChildAt(aKid, aIndex, aNotify, this, GetCurrentDoc(),
    1:                          mAttrsAndChildren);
    1: }
    1: 
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::doInsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                   PRBool aNotify, nsIContent* aParent,
    1:                                   nsIDocument* aDocument,
    1:                                   nsAttrAndChildArray& aChildArray)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
    1:                   "Incorrect aDocument");
    1: 
    1:   nsresult rv;
    1:   nsINode* container = NODE_FROM(aParent, aDocument);
12068: 
    1:   if (!container->HasSameOwnerDoc(aKid)) {
    1:     nsCOMPtr<nsIDOMNode> kid = do_QueryInterface(aKid, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:  
    1:     PRUint16 nodeType = 0;
    1:     rv = kid->GetNodeType(&nodeType);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
12068:     nsCOMPtr<nsIDOM3Document> domDoc =
12068:       do_QueryInterface(container->GetOwnerDoc());
12068: 
12068:     // DocumentType nodes are the only nodes that can have a null
12068:     // ownerDocument according to the DOM spec, and we need to allow
12068:     // inserting them w/o calling AdoptNode().
12068: 
12068:     if (domDoc && (nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE ||
12068:                    aKid->GetOwnerDoc())) {
12068:       nsCOMPtr<nsIDOMNode> adoptedKid;
12068:       rv = domDoc->AdoptNode(kid, getter_AddRefs(adoptedKid));
12068:       NS_ENSURE_SUCCESS(rv, rv);
12068: 
12068:       NS_ASSERTION(adoptedKid == kid, "Uh, adopt node changed nodes?");
    1:     }
    1:   }
    1: 
    1:   PRUint32 childCount = aChildArray.ChildCount();
    1:   NS_ENSURE_TRUE(aIndex <= childCount, NS_ERROR_ILLEGAL_VALUE);
    1: 
    1:   nsMutationGuard::DidMutate();
    1: 
    1:   PRBool isAppend = (aIndex == childCount);
    1: 
    1:   mozAutoDocUpdate updateBatch(aDocument, UPDATE_CONTENT_MODEL, aNotify);
    1: 
    1:   rv = aChildArray.InsertChildAt(aKid, aIndex);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = aKid->BindToTree(aDocument, aParent, nsnull, PR_TRUE);
    1:   if (NS_FAILED(rv)) {
    1:     aChildArray.RemoveChildAt(aIndex);
    1:     aKid->UnbindFromTree();
    1:     return rv;
    1:   }
    1: 
30896:   NS_ASSERTION(aKid->GetNodeParent() == container,
30896:                "Did we run script inappropriately?");
30896: 
30896:   if (aNotify) {
    1:     // Note that we always want to call ContentInserted when things are added
    1:     // as kids to documents
    1:     if (aParent && isAppend) {
    1:       nsNodeUtils::ContentAppended(aParent, aIndex);
    1:     } else {
    1:       nsNodeUtils::ContentInserted(container, aKid, aIndex);
    1:     }
    1: 
    1:     if (nsContentUtils::HasMutationListeners(aKid,
 3137:           NS_EVENT_BITS_MUTATION_NODEINSERTED, container)) {
14319:       mozAutoRemovableBlockerRemover blockerRemover;
14319:       
    1:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEINSERTED);
    1:       mutation.mRelatedNode = do_QueryInterface(container);
13098: 
   62:       mozAutoSubtreeModified subtree(container->GetOwnerDoc(), container);
    1:       nsEventDispatcher::Dispatch(aKid, nsnull, &mutation);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
29805: nsGenericElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent)
    1: {
    1:   nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
    1:   NS_ASSERTION(oldKid == GetChildAt(aIndex), "Unexpected child in RemoveChildAt");
    1: 
    1:   if (oldKid) {
    1:     return doRemoveChildAt(aIndex, aNotify, oldKid, this, GetCurrentDoc(),
29805:                            mAttrsAndChildren, aMutationEvent);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::doRemoveChildAt(PRUint32 aIndex, PRBool aNotify,
    1:                                   nsIContent* aKid, nsIContent* aParent,
    1:                                   nsIDocument* aDocument,
29805:                                   nsAttrAndChildArray& aChildArray,
29805:                                   PRBool aMutationEvent)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
    1:                   "Incorrect aDocument");
    1: 
 5395: #ifdef ACCESSIBILITY
 5395:   // A11y needs to be notified of content removals first, so accessibility
 5395:   // events can be fired before any changes occur
 5395:   if (aNotify && aDocument) {
 5395:     nsIPresShell *presShell = aDocument->GetPrimaryShell();
 5395:     if (presShell && presShell->IsAccessibilityActive()) {
 5395:       nsCOMPtr<nsIAccessibilityService> accService = 
 5395:         do_GetService("@mozilla.org/accessibilityService;1");
 5395:       if (accService) {
 5395:         accService->InvalidateSubtreeFor(presShell, aKid,
32336:                                          nsIAccessibilityService::NODE_REMOVE);
 5395:       }
 5395:     }
 5395:   }
 5395: #endif
 5395: 
    1:   nsMutationGuard::DidMutate();
    1: 
    1:   nsINode* container = NODE_FROM(aParent, aDocument);
    1:   
    1:   NS_PRECONDITION(aKid && aKid->GetParent() == aParent &&
    1:                   aKid == container->GetChildAt(aIndex) &&
    1:                   container->IndexOf(aKid) == (PRInt32)aIndex, "Bogus aKid");
    1: 
    1:   mozAutoDocUpdate updateBatch(aDocument, UPDATE_CONTENT_MODEL, aNotify);
    1: 
    1:   nsMutationGuard guard;
    1: 
   62:   mozAutoSubtreeModified subtree(nsnull, nsnull);
    1:   if (aNotify &&
29805:       aMutationEvent &&
    1:       nsContentUtils::HasMutationListeners(aKid,
 3137:         NS_EVENT_BITS_MUTATION_NODEREMOVED, container)) {
14319:     mozAutoRemovableBlockerRemover blockerRemover;
14319: 
    1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEREMOVED);
    1:     mutation.mRelatedNode = do_QueryInterface(container);
13098: 
   62:     subtree.UpdateTarget(container->GetOwnerDoc(), container);
    1:     nsEventDispatcher::Dispatch(aKid, nsnull, &mutation);
    1:   }
    1: 
    1:   // Someone may have removed the kid or any of its siblings while that event
    1:   // was processing.
    1:   if (guard.Mutated(0)) {
    1:     aIndex = container->IndexOf(aKid);
 3233:     if (static_cast<PRInt32>(aIndex) < 0) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   aChildArray.RemoveChildAt(aIndex);
    1: 
    1:   if (aNotify) {
    1:     nsNodeUtils::ContentRemoved(container, aKid, aIndex);
    1:   }
    1: 
    1:   aKid->UnbindFromTree();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::DispatchEvent(nsPresContext* aPresContext,
    1:                                 nsEvent* aEvent,
    1:                                 nsIContent* aTarget,
    1:                                 PRBool aFullDispatch,
    1:                                 nsEventStatus* aStatus)
    1: {
    1:   NS_PRECONDITION(aTarget, "Must have target");
    1:   NS_PRECONDITION(aEvent, "Must have source event");
    1:   NS_PRECONDITION(aStatus, "Null out param?");
    1: 
    1:   if (!aPresContext) {
    1:     return NS_OK;
    1:   }
    1: 
   95:   nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
    1:   if (!shell) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (aFullDispatch) {
    1:     return shell->HandleEventWithTarget(aEvent, nsnull, aTarget, aStatus);
    1:   }
    1: 
    1:   return shell->HandleDOMEventWithTarget(aTarget, aEvent, aStatus);
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::DispatchClickEvent(nsPresContext* aPresContext,
    1:                                      nsInputEvent* aSourceEvent,
    1:                                      nsIContent* aTarget,
    1:                                      PRBool aFullDispatch,
    1:                                      nsEventStatus* aStatus)
    1: {
    1:   NS_PRECONDITION(aTarget, "Must have target");
    1:   NS_PRECONDITION(aSourceEvent, "Must have source event");
    1:   NS_PRECONDITION(aStatus, "Null out param?");
    1: 
    1:   nsMouseEvent event(NS_IS_TRUSTED_EVENT(aSourceEvent), NS_MOUSE_CLICK,
    1:                      aSourceEvent->widget, nsMouseEvent::eReal);
    1:   event.refPoint = aSourceEvent->refPoint;
    1:   PRUint32 clickCount = 1;
22684:   float pressure = 0;
    1:   if (aSourceEvent->eventStructType == NS_MOUSE_EVENT) {
 3233:     clickCount = static_cast<nsMouseEvent*>(aSourceEvent)->clickCount;
22684:     pressure = static_cast<nsMouseEvent*>(aSourceEvent)->pressure;
22684:   }
22684:   event.pressure = pressure;
    1:   event.clickCount = clickCount;
    1:   event.isShift = aSourceEvent->isShift;
    1:   event.isControl = aSourceEvent->isControl;
    1:   event.isAlt = aSourceEvent->isAlt;
    1:   event.isMeta = aSourceEvent->isMeta;
    1: 
    1:   return DispatchEvent(aPresContext, &event, aTarget, aFullDispatch, aStatus);
    1: }
    1: 
    1: nsIFrame*
    1: nsGenericElement::GetPrimaryFrame()
    1: {
    1:   nsIDocument* doc = GetCurrentDoc();
    1:   if (!doc) {
    1:     return nsnull;
    1:   }
    1: 
    1:   return GetPrimaryFrameFor(this, doc);
    1: }
    1: 
    1: nsIFrame*
    1: nsGenericElement::GetPrimaryFrame(mozFlushType aType)
    1: {
    1:   nsIDocument* doc = GetCurrentDoc();
    1:   if (!doc) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // Cause a flush, so we get up-to-date frame
    1:   // information
    1:   doc->FlushPendingNotifications(aType);
    1: 
    1:   return GetPrimaryFrameFor(this, doc);
    1: }
    1: 
    1: /* static */
    1: nsIFrame*
    1: nsGenericElement::GetPrimaryFrameFor(nsIContent* aContent,
    1:                                      nsIDocument* aDocument)
    1: {
    1:   // Get presentation shell 0
  981:   nsIPresShell *presShell = aDocument->GetPrimaryShell();
    1:   if (!presShell) {
    1:     return nsnull;
    1:   }
    1: 
    1:   return presShell->GetPrimaryFrameFor(aContent);
    1: }
    1: 
 8462: void
 8462: nsGenericElement::DestroyContent()
 8462: {
 8462:   nsIDocument *document = GetOwnerDoc();
 8462:   if (document) {
 8462:     document->BindingManager()->ChangeDocumentFor(this, document, nsnull);
11838:     document->ClearBoxObjectFor(this);
 8462:   }
 8462: 
21618:   // XXX We really should let cycle collection do this, but that currently still
21618:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
30001:   nsContentUtils::ReleaseWrapper(this, this);
21618: 
 8462:   PRUint32 i, count = mAttrsAndChildren.ChildCount();
 8462:   for (i = 0; i < count; ++i) {
 8462:     // The child can remove itself from the parent in BindToTree.
 8462:     mAttrsAndChildren.ChildAt(i)->DestroyContent();
 8462:   }
 8462: }
 8462: 
14188: void
14188: nsGenericElement::SaveSubtreeState()
14188: {
14188:   PRUint32 i, count = mAttrsAndChildren.ChildCount();
14188:   for (i = 0; i < count; ++i) {
14188:     mAttrsAndChildren.ChildAt(i)->SaveSubtreeState();
14188:   }
14188: }
14188: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Generic DOMNode implementations
    1: 
    1: /*
    1:  * This helper function checks if aChild is the same as aNode or if
    1:  * aChild is one of aNode's ancestors. -- jst@citec.fi
    1:  */
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::InsertBefore(nsIDOMNode *aNewChild, nsIDOMNode *aRefChild,
    1:                                nsIDOMNode **aReturn)
    1: {
    1:   return doReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, this, GetCurrentDoc(),
    1:                                  aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
    1:                                nsIDOMNode** aReturn)
    1: {
    1:   return doReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, this, GetCurrentDoc(),
    1:                                  aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::RemoveChild(nsIDOMNode *aOldChild, nsIDOMNode **aReturn)
    1: {
    1:   return doRemoveChild(aOldChild, this, GetCurrentDoc(),
    1:                        aReturn);
    1: }
    1: 
    1: // When replacing, aRefContent is the content being replaced; when
    1: // inserting it's the content before which we're inserting.  In the
    1: // latter case it may be null.
    1: static
    1: PRBool IsAllowedAsChild(nsIContent* aNewChild, PRUint16 aNewNodeType,
    1:                         nsIContent* aParent, nsIDocument* aDocument,
    1:                         PRBool aIsReplace, nsIContent* aRefContent)
    1: {
    1:   NS_PRECONDITION(aNewChild, "Must have new child");
    1:   NS_PRECONDITION(!aIsReplace || aRefContent,
    1:                   "Must have ref content for replace");
    1: #ifdef DEBUG
    1:   PRUint16 debugNodeType = 0;
    1:   nsCOMPtr<nsIDOMNode> debugNode(do_QueryInterface(aNewChild));
    1:   nsresult debugRv = debugNode->GetNodeType(&debugNodeType);
    1: 
    1:   NS_PRECONDITION(NS_SUCCEEDED(debugRv) && debugNodeType == aNewNodeType,
    1:                   "Bogus node type passed");
    1: #endif
    1: 
    1:   if (aParent && nsContentUtils::ContentIsDescendantOf(aParent, aNewChild)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // The allowed child nodes differ for documents and elements
    1:   switch (aNewNodeType) {
    1:   case nsIDOMNode::COMMENT_NODE :
    1:   case nsIDOMNode::PROCESSING_INSTRUCTION_NODE :
    1:     // OK in both cases
    1:     return PR_TRUE;
    1:   case nsIDOMNode::TEXT_NODE :
    1:   case nsIDOMNode::CDATA_SECTION_NODE :
    1:   case nsIDOMNode::ENTITY_REFERENCE_NODE :
    1:     // Only allowed under elements
    1:     return aParent != nsnull;
    1:   case nsIDOMNode::ELEMENT_NODE :
    1:     {
    1:       if (aParent) {
    1:         // Always ok to have elements under other elements
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       nsIContent* rootContent = aDocument->GetRootContent();
    1:       if (rootContent) {
    1:         // Already have a documentElement, so this is only OK if we're
    1:         // replacing it.
    1:         return aIsReplace && rootContent == aRefContent;
    1:       }
    1: 
    1:       // We don't have a documentElement yet.  Our one remaining constraint is
    1:       // that the documentElement must come after the doctype.
    1:       if (!aRefContent) {
    1:         // Appending is just fine.
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       // Now grovel for a doctype
    1:       nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aDocument);
    1:       NS_ASSERTION(doc, "Shouldn't happen");
    1:       nsCOMPtr<nsIDOMDocumentType> docType;
    1:       doc->GetDoctype(getter_AddRefs(docType));
    1:       nsCOMPtr<nsIContent> docTypeContent = do_QueryInterface(docType);
    1:       
    1:       if (!docTypeContent) {
    1:         // It's all good.
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       PRInt32 doctypeIndex = aDocument->IndexOf(docTypeContent);
    1:       PRInt32 insertIndex = aDocument->IndexOf(aRefContent);
    1: 
    1:       // Now we're OK in the following two cases only:
    1:       // 1) We're replacing something that's not before the doctype
    1:       // 2) We're inserting before something that comes after the doctype 
    1:       return aIsReplace ? (insertIndex >= doctypeIndex) :
    1:         insertIndex > doctypeIndex;
    1:     }
    1:   case nsIDOMNode::DOCUMENT_TYPE_NODE :
    1:     {
    1:       if (aParent) {
    1:         // no doctypes allowed under elements
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aDocument);
    1:       NS_ASSERTION(doc, "Shouldn't happen");
    1:       nsCOMPtr<nsIDOMDocumentType> docType;
    1:       doc->GetDoctype(getter_AddRefs(docType));
    1:       nsCOMPtr<nsIContent> docTypeContent = do_QueryInterface(docType);
    1:       if (docTypeContent) {
    1:         // Already have a doctype, so this is only OK if we're replacing it
    1:         return aIsReplace && docTypeContent == aRefContent;
    1:       }
    1: 
    1:       // We don't have a doctype yet.  Our one remaining constraint is
    1:       // that the doctype must come before the documentElement.
    1:       nsIContent* rootContent = aDocument->GetRootContent();
    1:       if (!rootContent) {
    1:         // It's all good
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       if (!aRefContent) {
    1:         // Trying to append a doctype, but have a documentElement
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       PRInt32 rootIndex = aDocument->IndexOf(rootContent);
    1:       PRInt32 insertIndex = aDocument->IndexOf(aRefContent);
    1: 
    1:       // Now we're OK if and only if insertIndex <= rootIndex.  Indeed, either
    1:       // we end up replacing aRefContent or we end up before it.  Either one is
    1:       // ok as long as aRefContent is not after rootContent.
    1:       return insertIndex <= rootIndex;
    1:     }
    1:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE :
    1:     {
    1:       // Note that for now we only allow nodes inside document fragments if
    1:       // they're allowed inside elements.  If we ever change this to allow
    1:       // doctype nodes in document fragments, we'll need to update this code
    1:       if (aParent) {
    1:         // All good here
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       PRBool sawElement = PR_FALSE;
    1:       PRUint32 count = aNewChild->GetChildCount();
    1:       for (PRUint32 index = 0; index < count; ++index) {
    1:         nsIContent* childContent = aNewChild->GetChildAt(index);
    1:         NS_ASSERTION(childContent, "Something went wrong");
    1:         if (childContent->IsNodeOfType(nsINode::eELEMENT)) {
    1:           if (sawElement) {
    1:             // Can't put two elements into a document
    1:             return PR_FALSE;
    1:           }
    1:           sawElement = PR_TRUE;
    1:         }
    1:         // If we can put this content at the the right place, we might be ok;
    1:         // if not, we bail out.
    1:         nsCOMPtr<nsIDOMNode> childNode(do_QueryInterface(childContent));
    1:         PRUint16 type;
    1:         childNode->GetNodeType(&type);
    1:         if (!IsAllowedAsChild(childContent, type, aParent, aDocument,
    1:                               aIsReplace, aRefContent)) {
    1:           return PR_FALSE;
    1:         }
    1:       }
    1: 
    1:       // Everything in the fragment checked out ok, so we can stick it in here
    1:       return PR_TRUE;
    1:     }
    1:   default:
    1:     /*
    1:      * aNewChild is of invalid type.
    1:      */
    1:     break;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::doReplaceOrInsertBefore(PRBool aReplace,
    1:                                           nsIDOMNode* aNewChild,
    1:                                           nsIDOMNode* aRefChild,
    1:                                           nsIContent* aParent,
    1:                                           nsIDocument* aDocument,
    1:                                           nsIDOMNode** aReturn)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
    1:                   "Incorrect aDocument");
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   if (!aNewChild || (aReplace && !aRefChild)) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   // Keep a strong reference to the node that we'll return to ensure it
    1:   // doesn't go away.
    1:   nsCOMPtr<nsIDOMNode> returnVal = aReplace ? aRefChild : aNewChild;
    1: 
    1:   nsCOMPtr<nsIContent> refContent;
    1:   nsresult res = NS_OK;
    1:   PRInt32 insPos;
    1: 
    1:   nsINode* container = NODE_FROM(aParent, aDocument);
    1: 
    1:   // Figure out which index to insert at
    1:   if (aRefChild) {
    1:     refContent = do_QueryInterface(aRefChild);
    1:     insPos = container->IndexOf(refContent);
    1:     if (insPos < 0) {
    1:       return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:     }
    1: 
    1:     if (aRefChild == aNewChild) {
    1:       NS_ADDREF(*aReturn = aNewChild);
    1: 
    1:       return NS_OK;
    1:     }
    1:   } else {
    1:     insPos = container->GetChildCount();
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> newContent = do_QueryInterface(aNewChild);
    1:   if (!newContent) {
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
    1:   PRUint16 nodeType = 0;
    1:   res = aNewChild->GetNodeType(&nodeType);
    1:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // Make sure that the inserted node is allowed as a child of its new parent.
    1:   if (!IsAllowedAsChild(newContent, nodeType, aParent, aDocument, aReplace,
    1:                         refContent)) {
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
12068:   // DocumentType nodes are the only nodes that can have a null
12068:   // ownerDocument according to the DOM spec, and we need to allow
12068:   // inserting them w/o calling AdoptNode().
12068:   if (!container->HasSameOwnerDoc(newContent) &&
12068:       (nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE ||
12068:        newContent->GetOwnerDoc())) {
12068:     nsCOMPtr<nsIDOM3Document> domDoc = do_QueryInterface(aDocument);
12068: 
12068:     if (domDoc) {
12068:       nsCOMPtr<nsIDOMNode> adoptedKid;
12068:       nsresult rv = domDoc->AdoptNode(aNewChild, getter_AddRefs(adoptedKid));
12068:       NS_ENSURE_SUCCESS(rv, rv);
12068: 
12068:       NS_ASSERTION(adoptedKid == aNewChild, "Uh, adopt node changed nodes?");
    1:     }
    1:   }
    1: 
    1:   // We want an update batch when we expect several mutations to be performed,
    1:   // which is when we're replacing a node, or when we're inserting a fragment.
30896:   mozAutoDocConditionalContentUpdateBatch batch(aDocument,
    1:     aReplace || nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE);
    1: 
    1:   // If we're replacing
    1:   if (aReplace) {
    1:     // Getting (and addrefing) the following child here is sort of wasteful
    1:     // in the common case, but really, it's not that expensive. Get over it.
    1:     refContent = container->GetChildAt(insPos + 1);
    1: 
    1:     nsMutationGuard guard;
    1: 
    1:     res = container->RemoveChildAt(insPos, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     if (guard.Mutated(1)) {
    1:       insPos = refContent ? container->IndexOf(refContent) :
    1:                             container->GetChildCount();
    1:       if (insPos < 0) {
    1:         return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:       }
    1: 
    1:       // Passing PR_FALSE for aIsReplace since we now have removed the node
    1:       // to be replaced.
    1:       if (!IsAllowedAsChild(newContent, nodeType, aParent, aDocument,
    1:                             PR_FALSE, refContent)) {
    1:         return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:       }
    1:     }
    1:   }
    1: 
    1:   /*
    1:    * Check if we're inserting a document fragment. If we are, we need
    1:    * to remove the children of the document fragment and add them
    1:    * individually (i.e. we don't add the actual document fragment).
    1:    */
    1:   if (nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
    1:     PRUint32 count = newContent->GetChildCount();
    1: 
30896:     if (!count) {
30896:       returnVal.swap(*aReturn);
30896: 
30896:       return NS_OK;
30896:     }
30896: 
    1:     // Copy the children into a separate array to avoid having to deal with
    1:     // mutations to the fragment while we're inserting.
    1:     nsCOMArray<nsIContent> fragChildren;
    1:     if (!fragChildren.SetCapacity(count)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     PRUint32 i;
    1:     for (i = 0; i < count; i++) {
    1:       nsIContent* child = newContent->GetChildAt(i);
    1:       NS_ASSERTION(child->GetCurrentDoc() == nsnull,
    1:                    "How did we get a child with a current doc?");
    1:       fragChildren.AppendObject(child);
    1:     }
    1: 
    1:     // Remove the children from the fragment and flag for possible mutations.
    1:     PRBool mutated = PR_FALSE;
    1:     for (i = count; i > 0;) {
    1:       // We don't need to update i if someone mutates the DOM. The only thing
    1:       // that'd happen is that the resulting child list might be unexpected,
    1:       // but we should never crash since RemoveChildAt is out-of-bounds safe.
    1:       nsMutationGuard guard;
    1:       newContent->RemoveChildAt(--i, PR_TRUE);
    1:       mutated = mutated || guard.Mutated(1);
    1:     }
    1: 
30896:     // If we've had any unexpeted mutations so far we need to recheck that
30896:     // the child can still be inserted.
30896:     if (mutated) {
    1:       for (i = 0; i < count; ++i) {
    1:         // Get the n:th child from the array.
    1:         nsIContent* childContent = fragChildren[i];
    1: 
30896:         nsCOMPtr<nsIDOMNode> tmpNode = do_QueryInterface(childContent);
30896:         PRUint16 tmpType = 0;
30896:         tmpNode->GetNodeType(&tmpType);
30896: 
30896:         if (childContent->GetNodeParent() ||
30896:             !IsAllowedAsChild(childContent, tmpType, aParent, aDocument, PR_FALSE,
30896:                               refContent)) {
30896:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
30896:         }
30896:       }
30896: 
    1:       insPos = refContent ? container->IndexOf(refContent) :
    1:                             container->GetChildCount();
    1:       if (insPos < 0) {
    1:         // Someone seriously messed up the childlist. We have no idea
    1:         // where to insert the remaining children, so just bail.
    1:         return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:       }
30896:     }
30896: 
30896:     PRBool appending = aParent && (insPos == container->GetChildCount());
30896:     PRBool firstInsPos = insPos;
30896: 
30896:     // Iterate through the fragment's children, and insert them in the new
30896:     // parent
30896:     for (i = 0; i < count; ++i, ++insPos) {
30896:       nsIContent* childContent = fragChildren[i];
    1: 
    1:       // XXXbz how come no reparenting here?  That seems odd...
    1:       // Insert the child.
30896:       res = container->InsertChildAt(childContent, insPos, PR_FALSE);
30896:       if (NS_FAILED(res)) {
30896:         // Make sure to notify on any children that we did succeed to insert
30896:         if (appending && i != 0) {
30896:           nsNodeUtils::ContentAppended(aParent, firstInsPos);
30896:         }
30896:         return res;
30896:       }
30896: 
30896:       if (!appending) {
30896:         nsNodeUtils::ContentInserted(container, childContent, insPos);
30896:       }
30896:     }
30896: 
30896:     // Notify
30896:     if (appending) {
30896:       nsNodeUtils::ContentAppended(aParent, firstInsPos);
30896:     }
30896: 
30896:     // Fire mutation events. Optimize for the case when there are no listeners
30896:     nsIDocument* doc = container->GetOwnerDoc();
30896:     nsPIDOMWindow* window = nsnull;
30896:     if (doc && (window = doc->GetInnerWindow()) &&
30896:         window->HasMutationListeners(NS_EVENT_BITS_MUTATION_NODEINSERTED)) {
30896: 
30896:       for (i = 0; i < count; ++i, ++insPos) {
30896:         nsIContent* childContent = fragChildren[i];
30896: 
30896:         if (nsContentUtils::HasMutationListeners(childContent,
30896:               NS_EVENT_BITS_MUTATION_NODEINSERTED, container)) {
30896:           mozAutoRemovableBlockerRemover blockerRemover;
30896: 
30896:           nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEINSERTED);
30896:           mutation.mRelatedNode = do_QueryInterface(container);
30896: 
30896:           mozAutoSubtreeModified subtree(container->GetOwnerDoc(), container);
30896:           nsEventDispatcher::Dispatch(childContent, nsnull, &mutation);
30896:         }
30896:       }
    1:     }
    1:   }
    1:   else {
    1:     // Not inserting a fragment but rather a single node.
    1: 
25511:     if (newContent->IsRootOfAnonymousSubtree()) {
25511:       // This is anonymous content.  Don't allow its insertion
25511:       // anywhere, since it might have UnbindFromTree calls coming
25511:       // its way.
25511:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
25511:     }
25511: 
    1:     // Remove the element from the old parent if one exists
    1:     nsINode* oldParent = newContent->GetNodeParent();
    1: 
    1:     if (oldParent) {
    1:       PRInt32 removeIndex = oldParent->IndexOf(newContent);
    1: 
 4232:       if (removeIndex < 0) {
 4232:         // newContent is anonymous.  We can't deal with this, so just bail
25511:         NS_ERROR("How come our flags didn't catch this?");
    1:         return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:       }
    1:       
    1:       NS_ASSERTION(!(oldParent == container && removeIndex == insPos),
    1:                    "invalid removeIndex");
    1: 
    1:       nsMutationGuard guard;
    1: 
    1:       res = oldParent->RemoveChildAt(removeIndex, PR_TRUE);
    1:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // Adjust insert index if the node we ripped out was a sibling
    1:       // of the node we're inserting before
    1:       if (oldParent == container && removeIndex < insPos) {
    1:         --insPos;
    1:       }
    1: 
    1:       if (guard.Mutated(1)) {
    1:         insPos = refContent ? container->IndexOf(refContent) :
    1:                               container->GetChildCount();
    1:         if (insPos < 0) {
    1:           // Someone seriously messed up the childlist. We have no idea
    1:           // where to insert the new child, so just bail.
    1:           return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:         }
    1: 
    1:         if (newContent->GetNodeParent() ||
    1:             !IsAllowedAsChild(newContent, nodeType, aParent, aDocument,
    1:                               PR_FALSE, refContent)) {
    1:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:         }
    1:       }
    1:     }
    1: 
33329:     if (!newContent->IsXUL()) {
    1:       nsContentUtils::ReparentContentWrapper(newContent, aParent,
    1:                                              container->GetOwnerDoc(),
    1:                                              container->GetOwnerDoc());
    1:     }
    1: 
    1:     res = container->InsertChildAt(newContent, insPos, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   returnVal.swap(*aReturn);
    1: 
    1:   return res;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::doRemoveChild(nsIDOMNode* aOldChild, nsIContent* aParent,
    1:                                 nsIDocument* aDocument, nsIDOMNode** aReturn)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(!aParent || aParent->GetCurrentDoc() == aDocument,
    1:                   "Incorrect aDocument");
    1: 
    1:   *aReturn = nsnull;
    1:   NS_ENSURE_TRUE(aOldChild, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsINode* container = NODE_FROM(aParent, aDocument);
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aOldChild);
    1:   // fix children to be a passed argument
    1:   PRInt32 index = container->IndexOf(content);
    1:   if (index == -1) {
    1:     // aOldChild isn't one of our children.
    1:     return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:   }
    1: 
    1:   nsresult rv = container->RemoveChildAt(index, PR_TRUE);
    1: 
    1:   *aReturn = aOldChild;
    1:   NS_ADDREF(aOldChild);
    1: 
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // nsISupports implementation
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericElement)
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsGenericElement)
30001:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_END
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericElement)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
 1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
    1: 
33329:   if (tmp->HasProperties() && tmp->IsXUL()) {
 9153:     tmp->DeleteProperty(nsGkAtoms::contextmenulistener);
 9153:     tmp->DeleteProperty(nsGkAtoms::popuplistener);
 9153:   }
 9153: 
    1:   // Unlink child content (and unbind our subtree).
    1:   {
14228:     PRUint32 childCount = tmp->mAttrsAndChildren.ChildCount();
14228:     if (childCount) {
14228:       // Don't allow script to run while we're unbinding everything.
14228:       nsAutoScriptBlocker scriptBlocker;
14228:       while (childCount-- > 0) {
14228:         // Once we have XPCOMGC we shouldn't need to call UnbindFromTree.
 8462:         // We could probably do a non-deep unbind here when IsInDoc is false
 8462:         // for better performance.
14228:         tmp->mAttrsAndChildren.ChildAt(childCount)->UnbindFromTree();
14228:         tmp->mAttrsAndChildren.RemoveChildAt(childCount);
14228:       }
    1:     }
    1:   }  
    1: 
    1:   // Unlink any DOM slots of interest.
    1:   {
    1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
 8462:     if (slots) {
31394:       slots->mStyle = nsnull;
32193: #ifdef MOZ_SMIL
32193:       slots->mSMILOverrideStyle = nsnull;
32193: #endif // MOZ_SMIL
11538:       if (slots->mAttributeMap) {
11538:         slots->mAttributeMap->DropReference();
    1:         slots->mAttributeMap = nsnull;
11538:       }
33329:       if (tmp->IsXUL())
 8462:         NS_IF_RELEASE(slots->mControllers);
17074:       slots->mChildrenList = nsnull;
 8462:     }
    1:   }
30000: 
30000:   {
30000:     nsIDocument *doc;
30000:     if (!tmp->GetNodeParent() && (doc = tmp->GetOwnerDoc()) &&
30000:         tmp->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
30000:       doc->BindingManager()->ChangeDocumentFor(tmp, doc, nsnull);
30000:     }
30000:   }
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGenericElement)
30001:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericElement)
30001:   // Always need to traverse script objects, so do that before we check
30001:   // if we're uncollectable.
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
30001: 
 1353:   nsIDocument* currentDoc = tmp->GetCurrentDoc();
 1498:   if (currentDoc && nsCCUncollectableMarker::InGeneration(
30096:                       cb, currentDoc->GetMarkedCCGeneration())) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 1353:   }
 1353: 
    1:   nsIDocument* ownerDoc = tmp->GetOwnerDoc();
    1:   if (ownerDoc) {
    1:     ownerDoc->BindingManager()->Traverse(tmp, cb);
    1:   }
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER
 1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
    1: 
33329:   if (tmp->HasProperties() && tmp->IsXUL()) {
    1:     nsISupports* property =
 3233:       static_cast<nsISupports*>
 3233:                  (tmp->GetProperty(nsGkAtoms::contextmenulistener));
    1:     cb.NoteXPCOMChild(property);
 3233:     property = static_cast<nsISupports*>
 3233:                           (tmp->GetProperty(nsGkAtoms::popuplistener));
    1:     cb.NoteXPCOMChild(property);
    1:   }
    1: 
13669:   // Traverse attribute names and child content.
    1:   {
    1:     PRUint32 i;
13669:     PRUint32 attrs = tmp->mAttrsAndChildren.AttrCount();
13669:     for (i = 0; i < attrs; i++) {
13669:       const nsAttrName* name = tmp->mAttrsAndChildren.AttrNameAt(i);
22064:       if (!name->IsAtom()) {
22064:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
22064:                                            "mAttrsAndChildren[i]->NodeInfo()");
13669:         cb.NoteXPCOMChild(name->NodeInfo());
13669:       }
22064:     }
13669: 
    1:     PRUint32 kids = tmp->mAttrsAndChildren.ChildCount();
13202:     for (i = 0; i < kids; i++) {
13202:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mAttrsAndChildren[i]");
    1:       cb.NoteXPCOMChild(tmp->mAttrsAndChildren.GetSafeChildAt(i));
    1:     }
13202:   }
    1: 
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
13669: 
    1:   // Traverse any DOM slots of interest.
    1:   {
    1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
    1:     if (slots) {
30385:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "slots mStyle");
30385:       cb.NoteXPCOMChild(slots->mStyle.get());
30385: 
32193: #ifdef MOZ_SMIL
32193:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "slots mSMILOverrideStyle");
32193:       cb.NoteXPCOMChild(slots->mSMILOverrideStyle.get());
32193: #endif // MOZ_SMIL
32193: 
30385:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "slots mAttributeMap");
    1:       cb.NoteXPCOMChild(slots->mAttributeMap.get());
30385: 
33329:       if (tmp->IsXUL())
    1:         cb.NoteXPCOMChild(slots->mControllers);
17074:       cb.NoteXPCOMChild(
17074:         static_cast<nsIDOMNodeList*>(slots->mChildrenList.get()));
    1:     }
    1:   }
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
12033: 
21618: NS_INTERFACE_MAP_BEGIN(nsGenericElement)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21618:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsGenericElement)
12033:   NS_INTERFACE_MAP_ENTRY(nsIContent)
12033:   NS_INTERFACE_MAP_ENTRY(nsINode)
12033:   NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Node, new nsNode3Tearoff(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSElement, new nsNSElementTearoff(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMEventTarget,
12033:                                  nsDOMEventRTTearoff::Create(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3EventTarget,
12033:                                  nsDOMEventRTTearoff::Create(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSEventTarget,
12033:                                  nsDOMEventRTTearoff::Create(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
12033:                                  new nsNodeSupportsWeakRefTearoff(this))
16106:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNodeSelector,
16106:                                  new nsNodeSelectorTearoff(this))
29215:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
29215:                                  new nsNode3Tearoff(this))
12033:   // nsNodeSH::PreCreate() depends on the identity pointer being the
12033:   // same as nsINode (which nsIContent inherits), so if you change the
12033:   // below line, make sure nsNodeSH::PreCreate() still does the right
12033:   // thing!
12033:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)
12033: NS_INTERFACE_MAP_END
12033: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGenericElement, nsIContent)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsGenericElement,
    1:                                                         nsIContent,
 1391:                                                         nsNodeUtils::LastRelease(this))
    1: 
    1: nsresult
    1: nsGenericElement::PostQueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   nsIDocument *document = GetOwnerDoc();
    1:   if (document) {
    1:     return document->BindingManager()->GetBindingImplementation(this, aIID,
    1:                                                                 aInstancePtr);
    1:   }
    1: 
 3114:   *aInstancePtr = nsnull;
 3114:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: nsresult
    1: nsGenericElement::LeaveLink(nsPresContext* aPresContext)
    1: {
    1:   nsILinkHandler *handler = aPresContext->GetLinkHandler();
    1:   if (!handler) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return handler->OnLeaveLink();
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::AddScriptEventListener(nsIAtom* aEventName,
    1:                                          const nsAString& aValue,
    1:                                          PRBool aDefer)
    1: {
 4064:   nsIDocument *ownerDoc = GetOwnerDoc();
 4064:   if (!ownerDoc || ownerDoc->IsLoadedAsData()) {
 4064:     // Make this a no-op rather than throwing an error to avoid
 4064:     // the error causing problems setting the attribute.
 4064:     return NS_OK;
 4064:   }
 4064: 
    1:   NS_PRECONDITION(aEventName, "Must have event name!");
    1:   nsCOMPtr<nsISupports> target;
    1:   PRBool defer = PR_TRUE;
    1:   nsCOMPtr<nsIEventListenerManager> manager;
    1: 
29474:   GetEventListenerManagerForAttr(getter_AddRefs(manager),
    1:                                  getter_AddRefs(target),
    1:                                  &defer);
32526:   if (!manager) {
32526:     return NS_OK;
32526:   }
29474: 
    1:   defer = defer && aDefer; // only defer if everyone agrees...
    1:   PRUint32 lang = GetScriptTypeID();
29474:   return
    1:     manager->AddScriptEventListener(target, aEventName, aValue, lang, defer,
    1:                                     !nsContentUtils::IsChromeDoc(ownerDoc));
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: const nsAttrName*
    1: nsGenericElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
    1:   return mAttrsAndChildren.GetExistingAttrNameFromQName(
    1:     NS_ConvertUTF16toUTF8(aStr));
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::CopyInnerTo(nsGenericElement* aDst) const
    1: {
    1:   PRUint32 i, count = mAttrsAndChildren.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);
    1:     const nsAttrValue* value = mAttrsAndChildren.AttrAt(i);
    1:     nsAutoString valStr;
    1:     value->ToString(valStr);
    1:     nsresult rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
    1:                                 name->GetPrefix(), valStr, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                           nsIAtom* aPrefix, const nsAString& aValue,
    1:                           PRBool aNotify)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aName);
    1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
    1:                "Don't call SetAttr with unknown namespace");
    1: 
33251:   nsIDocument* doc = GetCurrentDoc();
33251:   if (kNameSpaceID_XLink == aNamespaceID && nsGkAtoms::href == aName) {
33251:     // XLink URI(s) might be changing. Drop the link from the map. If it
33251:     // is still style relevant it will be re-added by
33251:     // nsStyleUtil::IsLink. Make sure to keep the style system
33251:     // consistent so this remains true! In particular if the style system
33251:     // were to get smarter and not restyling an XLink element if the href
33251:     // doesn't change in a "significant" way, we'd need to do the same
33251:     // significance check here.
33251:     if (doc) {
33251:       doc->ForgetLink(this);
33251:     }
33251:   }
33251: 
    1:   nsAutoString oldValue;
    1:   PRBool modification = PR_FALSE;
    1:   PRBool hasListeners = aNotify &&
    1:     nsContentUtils::HasMutationListeners(this,
 3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 3137:                                          this);
    1:   
    1:   // If we have no listeners and aNotify is false, we are almost certainly
    1:   // coming from the content sink and will almost certainly have no previous
    1:   // value.  Even if we do, setting the value is cheap when we have no
    1:   // listeners and don't plan to notify.  The check for aNotify here is an
    1:   // optimization, the check for haveListeners is a correctness issue.
    1:   if (hasListeners || aNotify) {
    1:     nsAttrInfo info(GetAttrInfo(aNamespaceID, aName));
    1:     if (info.mValue) {
    1:       // Check whether the old value is the same as the new one.  Note that we
    1:       // only need to actually _get_ the old value if we have listeners.
    1:       PRBool valueMatches;
    1:       if (hasListeners) {
    1:         // Need to store the old value
    1:         info.mValue->ToString(oldValue);
    1:         valueMatches = aValue.Equals(oldValue);
    1:       } else if (aNotify) {
    1:         valueMatches = info.mValue->Equals(aValue, eCaseMatters);
    1:       }
    1:       if (valueMatches && aPrefix == info.mName->GetPrefix()) {
    1:         return NS_OK;
    1:       }
    1:       modification = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   nsresult rv = BeforeSetAttr(aNamespaceID, aName, &aValue, aNotify);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsAttrValue attrValue;
    1:   if (!ParseAttribute(aNamespaceID, aName, aValue, attrValue)) {
    1:     attrValue.SetTo(aValue);
    1:   }
    1: 
22222:   return SetAttrAndNotify(aNamespaceID, aName, aPrefix, oldValue,
22222:                           attrValue, modification, hasListeners, aNotify,
22222:                           &aValue);
    1: }
    1:   
    1: nsresult
    1: nsGenericElement::SetAttrAndNotify(PRInt32 aNamespaceID,
    1:                                    nsIAtom* aName,
    1:                                    nsIAtom* aPrefix,
    1:                                    const nsAString& aOldValue,
    1:                                    nsAttrValue& aParsedValue,
    1:                                    PRBool aModification,
    1:                                    PRBool aFireMutation,
22222:                                    PRBool aNotify,
22222:                                    const nsAString* aValueForAfterSetAttr)
    1: {
    1:   nsresult rv;
    1:   PRUint8 modType = aModification ?
 3233:     static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION) :
 3233:     static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
    1: 
    1:   nsIDocument* document = GetCurrentDoc();
    1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
 3410: 
 3410:   // When notifying, make sure to keep track of states whose value
 3410:   // depends solely on the value of an attribute.
 3410:   PRUint32 stateMask;
 3410:   if (aNotify) {
 3410:     stateMask = PRUint32(IntrinsicState());
 3410:     
29833:     nsNodeUtils::AttributeWillChange(this, aNamespaceID, aName, modType);
 3410:   }
    1: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // XXXbz Perhaps we should push up the attribute mapping function
    1:     // stuff to nsGenericElement?
    1:     if (!IsAttributeMapped(aName) ||
    1:         !SetMappedAttribute(document, aName, aParsedValue, &rv)) {
    1:       rv = mAttrsAndChildren.SetAndTakeAttr(aName, aParsedValue);
    1:     }
    1:   }
    1:   else {
    1:     nsCOMPtr<nsINodeInfo> ni;
19197:     ni = mNodeInfo->NodeInfoManager()->GetNodeInfo(aName, aPrefix,
19197:                                                    aNamespaceID);
19747:     NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mAttrsAndChildren.SetAndTakeAttr(ni, aParsedValue);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
12522:   if (document || HasFlag(NODE_FORCE_XBL_BINDINGS)) {
12522:     nsIDocument* ownerDoc = GetOwnerDoc();
12522:     if (ownerDoc) {
 2528:       nsRefPtr<nsXBLBinding> binding =
12522:         ownerDoc->BindingManager()->GetBinding(this);
    1:       if (binding) {
    1:         binding->AttributeChanged(aName, aNamespaceID, PR_FALSE, aNotify);
    1:       }
    1:     }
12522:   }
    1: 
 3311:   if (aNotify) {
 3410:     stateMask = stateMask ^ PRUint32(IntrinsicState());
 3410:     if (stateMask && document) {
 3410:       MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, aNotify);
 3410:       document->ContentStatesChanged(this, nsnull, stateMask);
 3410:     }
 3410:     nsNodeUtils::AttributeChanged(this, aNamespaceID, aName, modType,
 3410:                                   stateMask);
 3311:   }
 3311: 
22222:   if (aNamespaceID == kNameSpaceID_XMLEvents && 
22222:       aName == nsGkAtoms::event && mNodeInfo->GetDocument()) {
22222:     mNodeInfo->GetDocument()->AddXMLEventsContent(this);
22222:   }
22222:   if (aValueForAfterSetAttr) {
22222:     rv = AfterSetAttr(aNamespaceID, aName, aValueForAfterSetAttr, aNotify);
22222:     NS_ENSURE_SUCCESS(rv, rv);
22222:   }
22222: 
    1:   if (aFireMutation) {
14319:     mozAutoRemovableBlockerRemover blockerRemover;
14319:     
    1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
    1: 
    1:     nsAutoString attrName;
    1:     aName->ToString(attrName);
    1:     nsCOMPtr<nsIDOMAttr> attrNode;
    1:     nsAutoString ns;
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNamespaceID, ns);
    1:     GetAttributeNodeNS(ns, attrName, getter_AddRefs(attrNode));
    1:     mutation.mRelatedNode = attrNode;
    1: 
    1:     mutation.mAttrName = aName;
    1:     nsAutoString newValue;
    1:     GetAttr(aNamespaceID, aName, newValue);
    1:     if (!newValue.IsEmpty()) {
    1:       mutation.mNewAttrValue = do_GetAtom(newValue);
    1:     }
    1:     if (!aOldValue.IsEmpty()) {
    1:       mutation.mPrevAttrValue = do_GetAtom(aOldValue);
    1:     }
    1:     mutation.mAttrChange = modType;
13098: 
   62:     mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
    1:     nsEventDispatcher::Dispatch(this, nsnull, &mutation);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                  nsIAtom* aAttribute,
    1:                                  const nsAString& aValue,
    1:                                  nsAttrValue& aResult)
    1: {
 4036:   if (aNamespaceID == kNameSpaceID_None &&
 4036:       aAttribute == GetIDAttributeName() && !aValue.IsEmpty()) {
 6041:     SetFlags(NODE_MAY_HAVE_ID);
    1:     // Store id as an atom.  id="" means that the element has no id,
    1:     // not that it has an emptystring as the id.
    1:     aResult.ParseAtom(aValue);
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::SetMappedAttribute(nsIDocument* aDocument,
    1:                                      nsIAtom* aName,
    1:                                      nsAttrValue& aValue,
    1:                                      nsresult* aRetval)
    1: {
    1:   *aRetval = NS_OK;
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                                  nsISupports** aTarget,
    1:                                                  PRBool* aDefer)
    1: {
29474:   *aManager = GetListenerManager(PR_TRUE);
29474:   *aDefer = PR_TRUE;
29474:   NS_ENSURE_STATE(*aManager);
29474:   NS_ADDREF(*aManager);
 3233:   NS_ADDREF(*aTarget = static_cast<nsIContent*>(this));
29474:   return NS_OK;
    1: }
    1: 
    1: nsGenericElement::nsAttrInfo
    1: nsGenericElement::GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
    1:                "must have a real namespace ID!");
    1: 
    1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNamespaceID);
    1:   if (index >= 0) {
    1:     return nsAttrInfo(mAttrsAndChildren.AttrNameAt(index),
    1:                       mAttrsAndChildren.AttrAt(index));
    1:   }
    1: 
    1:   return nsAttrInfo(nsnull, nsnull);
    1: }
    1:   
    1: 
    1: PRBool
    1: nsGenericElement::GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                           nsAString& aResult) const
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
    1:                "must have a real namespace ID!");
    1: 
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   if (!val) {
    1:     // Since we are returning a success code we'd better do
    1:     // something about the out parameters (someone may have
    1:     // given us a non-empty string).
    1:     aResult.Truncate();
    1:     
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   val->ToString(aResult);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
    1:                "must have a real namespace ID!");
    1: 
    1:   return mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID) >= 0;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
    1:                               nsIAtom* aName,
    1:                               const nsAString& aValue,
    1:                               nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1: 
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   return val && val->Equals(aValue, aCaseSensitive);
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
    1:                               nsIAtom* aName,
    1:                               nsIAtom* aValue,
    1:                               nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1:   NS_ASSERTION(aValue, "Null value atom");
    1: 
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   return val && val->Equals(aValue, aCaseSensitive);
    1: }
    1: 
    1: PRInt32
    1: nsGenericElement::FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aName,
    1:                                   AttrValuesArray* aValues,
    1:                                   nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1:   NS_ASSERTION(aValues, "Null value array");
    1:   
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   if (val) {
    1:     for (PRInt32 i = 0; aValues[i]; ++i) {
    1:       if (val->Equals(*aValues[i], aCaseSensitive)) {
    1:         return i;
    1:       }
    1:     }
    1:     return ATTR_VALUE_NO_MATCH;
    1:   }
    1:   return ATTR_MISSING;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                             PRBool aNotify)
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1: 
    1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID);
    1:   if (index < 0) {
    1:     return NS_OK;
    1:   }
    1: 
 8668:   nsresult rv = BeforeSetAttr(aNameSpaceID, aName, nsnull, aNotify);
 8668:   NS_ENSURE_SUCCESS(rv, rv);
 8668:   
    1:   nsIDocument *document = GetCurrentDoc();    
    1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
29833: 
29833:   if (aNotify) {
29833:     nsNodeUtils::AttributeWillChange(this, aNameSpaceID, aName,
29833:                                      nsIDOMMutationEvent::REMOVAL);
29833:   }
29833: 
33251:   if (document && kNameSpaceID_XLink == aNameSpaceID &&
33251:       nsGkAtoms::href == aName) {
33251:     // XLink URI might be changing.
33251:     document->ForgetLink(this);
33251:   }
33251: 
 3410:   // When notifying, make sure to keep track of states whose value
 3410:   // depends solely on the value of an attribute.
 3410:   PRUint32 stateMask;
 3410:   if (aNotify) {
 3410:     stateMask = PRUint32(IntrinsicState());
 3410:   }    
 3410: 
    1:   PRBool hasMutationListeners = aNotify &&
    1:     nsContentUtils::HasMutationListeners(this,
 3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 3137:                                          this);
    1: 
    1:   // Grab the attr node if needed before we remove it from the attr map
    1:   nsCOMPtr<nsIDOMAttr> attrNode;
    1:   if (hasMutationListeners) {
    1:     nsAutoString attrName;
    1:     aName->ToString(attrName);
    1:     nsAutoString ns;
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
    1:     GetAttributeNodeNS(ns, attrName, getter_AddRefs(attrNode));
    1:   }
    1: 
    1:   // Clear binding to nsIDOMNamedNodeMap
    1:   nsDOMSlots *slots = GetExistingDOMSlots();
    1:   if (slots && slots->mAttributeMap) {
    1:     slots->mAttributeMap->DropAttribute(aNameSpaceID, aName);
    1:   }
    1: 
    1:   nsAttrValue oldValue;
 8668:   rv = mAttrsAndChildren.RemoveAttrAt(index, oldValue);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
12522:   if (document || HasFlag(NODE_FORCE_XBL_BINDINGS)) {
12522:     nsIDocument* ownerDoc = GetOwnerDoc();
12522:     if (ownerDoc) {
 6674:       nsRefPtr<nsXBLBinding> binding =
12522:         ownerDoc->BindingManager()->GetBinding(this);
12522:       if (binding) {
    1:         binding->AttributeChanged(aName, aNameSpaceID, PR_TRUE, aNotify);
    1:       }
12522:     }
12522:   }
    1: 
    1:   if (aNotify) {
 3410:     stateMask = stateMask ^ PRUint32(IntrinsicState());
 3410:     if (stateMask && document) {
 3410:       MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, aNotify);
 3410:       document->ContentStatesChanged(this, nsnull, stateMask);
 3410:     }
    1:     nsNodeUtils::AttributeChanged(this, aNameSpaceID, aName,
 3410:                                   nsIDOMMutationEvent::REMOVAL,
 3410:                                   stateMask);
    1:   }
    1: 
22222:   rv = AfterSetAttr(aNameSpaceID, aName, nsnull, aNotify);
22222:   NS_ENSURE_SUCCESS(rv, rv);
22222: 
    1:   if (hasMutationListeners) {
14319:     mozAutoRemovableBlockerRemover blockerRemover;
14319: 
    1:     nsCOMPtr<nsIDOMEventTarget> node =
 3233:       do_QueryInterface(static_cast<nsIContent *>(this));
    1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
    1: 
    1:     mutation.mRelatedNode = attrNode;
    1:     mutation.mAttrName = aName;
    1: 
    1:     nsAutoString value;
    1:     oldValue.ToString(value);
    1:     if (!value.IsEmpty())
    1:       mutation.mPrevAttrValue = do_GetAtom(value);
    1:     mutation.mAttrChange = nsIDOMMutationEvent::REMOVAL;
    1: 
   62:     mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
    1:     nsEventDispatcher::Dispatch(this, nsnull, &mutation);
    1:   }
    1: 
22222:   return NS_OK;
    1: }
    1: 
    1: const nsAttrName*
    1: nsGenericElement::GetAttrNameAt(PRUint32 aIndex) const
    1: {
    1:   return mAttrsAndChildren.GetSafeAttrNameAt(aIndex);
    1: }
    1: 
    1: PRUint32
    1: nsGenericElement::GetAttrCount() const
    1: {
    1:   return mAttrsAndChildren.AttrCount();
    1: }
    1: 
    1: const nsTextFragment*
    1: nsGenericElement::GetText()
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRUint32
    1: nsGenericElement::TextLength()
    1: {
    1:   // We can remove this assertion if it turns out to be useful to be able
    1:   // to depend on this returning 0
    1:   NS_NOTREACHED("called nsGenericElement::TextLength");
    1: 
    1:   return 0;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                           PRBool aNotify)
    1: {
    1:   NS_ERROR("called nsGenericElement::SetText");
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                              PRBool aNotify)
    1: {
    1:   NS_ERROR("called nsGenericElement::AppendText");
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::TextIsOnlyWhitespace()
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsGenericElement::AppendTextTo(nsAString& aResult)
    1: {
    1:   // We can remove this assertion if it turns out to be useful to be able
    1:   // to depend on this appending nothing.
    1:   NS_NOTREACHED("called nsGenericElement::TextLength");
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsGenericElement::ListAttributes(FILE* out) const
    1: {
    1:   PRUint32 index, count = mAttrsAndChildren.AttrCount();
    1:   for (index = 0; index < count; index++) {
    1:     nsAutoString buffer;
    1: 
    1:     // name
    1:     mAttrsAndChildren.AttrNameAt(index)->GetQualifiedName(buffer);
    1: 
    1:     // value
    1:     buffer.AppendLiteral("=\"");
    1:     nsAutoString value;
    1:     mAttrsAndChildren.AttrAt(index)->ToString(value);
    1:     for (int i = value.Length(); i >= 0; --i) {
    1:       if (value[i] == PRUnichar('"'))
    1:         value.Insert(PRUnichar('\\'), PRUint32(i));
    1:     }
    1:     buffer.Append(value);
    1:     buffer.AppendLiteral("\"");
    1: 
    1:     fputs(" ", out);
    1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericElement::List(FILE* out, PRInt32 aIndent,
    1:                        const nsCString& aPrefix) const
    1: {
    1:   PRInt32 indent;
    1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   fputs(aPrefix.get(), out);
    1: 
    1:   nsAutoString buf;
    1:   mNodeInfo->GetQualifiedName(buf);
    1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
    1: 
    1:   fprintf(out, "@%p", (void *)this);
    1: 
    1:   ListAttributes(out);
    1: 
    1:   fprintf(out, " intrinsicstate=[%08x]", IntrinsicState());
    1:   fprintf(out, " refcount=%d<", mRefCnt.get());
    1: 
    1:   PRUint32 i, length = GetChildCount();
    1:   if (length > 0) {
    1:     fputs("\n", out);
    1: 
    1:     for (i = 0; i < length; ++i) {
    1:       nsIContent *kid = GetChildAt(i);
    1:       kid->List(out, aIndent + 1);
    1:     }
    1: 
    1:     for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:   }
    1: 
    1:   fputs(">\n", out);
    1:   
 3233:   nsGenericElement* nonConstThis = const_cast<nsGenericElement*>(this);
    1: 
    1:   // XXX sXBL/XBL2 issue! Owner or current document?
    1:   nsIDocument *document = GetOwnerDoc();
    1:   if (document) {
    1:     // Note: not listing nsIAnonymousContentCreator-created content...
    1: 
    1:     nsBindingManager* bindingManager = document->BindingManager();
    1:     nsCOMPtr<nsIDOMNodeList> anonymousChildren;
    1:     bindingManager->GetAnonymousNodesFor(nonConstThis,
    1:                                          getter_AddRefs(anonymousChildren));
    1: 
    1:     if (anonymousChildren) {
    1:       anonymousChildren->GetLength(&length);
    1:       if (length > 0) {
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs("anonymous-children<\n", out);
    1: 
    1:         for (i = 0; i < length; ++i) {
    1:           nsCOMPtr<nsIDOMNode> node;
    1:           anonymousChildren->Item(i, getter_AddRefs(node));
    1:           nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1:           child->List(out, aIndent + 1);
    1:         }
    1: 
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs(">\n", out);
    1:       }
    1:     }
    1: 
    1:     if (bindingManager->HasContentListFor(nonConstThis)) {
    1:       nsCOMPtr<nsIDOMNodeList> contentList;
    1:       bindingManager->GetContentListFor(nonConstThis,
    1:                                         getter_AddRefs(contentList));
    1: 
    1:       NS_ASSERTION(contentList != nsnull, "oops, binding manager lied");
    1: 
    1:       contentList->GetLength(&length);
    1:       if (length > 0) {
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs("content-list<\n", out);
    1: 
    1:         for (i = 0; i < length; ++i) {
    1:           nsCOMPtr<nsIDOMNode> node;
    1:           contentList->Item(i, getter_AddRefs(node));
    1:           nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1:           child->List(out, aIndent + 1);
    1:         }
    1: 
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs(">\n", out);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericElement::DumpContent(FILE* out, PRInt32 aIndent,
    1:                               PRBool aDumpAll) const
    1: {
    1:   PRInt32 indent;
    1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString buf;
    1:   mNodeInfo->GetQualifiedName(buf);
    1:   fputs("<", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
    1: 
    1:   if(aDumpAll) ListAttributes(out);
    1: 
    1:   fputs(">", out);
    1: 
    1:   if(aIndent) fputs("\n", out);
    1: 
    1:   PRInt32 index, kids = GetChildCount();
    1:   for (index = 0; index < kids; index++) {
    1:     nsIContent *kid = GetChildAt(index);
    1:     PRInt32 indent = aIndent ? aIndent + 1 : 0;
    1:     kid->DumpContent(out, indent, aDumpAll);
    1:   }
    1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:   fputs("</", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
    1:   fputs(">", out);
    1: 
    1:   if(aIndent) fputs("\n", out);
    1: }
    1: #endif
    1: 
    1: PRUint32
    1: nsGenericElement::GetChildCount() const
    1: {
    1:   return mAttrsAndChildren.ChildCount();
    1: }
    1: 
    1: nsIContent *
    1: nsGenericElement::GetChildAt(PRUint32 aIndex) const
    1: {
    1:   return mAttrsAndChildren.GetSafeChildAt(aIndex);
    1: }
    1: 
15810: nsIContent * const *
22251: nsGenericElement::GetChildArray(PRUint32* aChildCount) const
22251: {
22251:   return mAttrsAndChildren.GetChildArray(aChildCount);
15810: }
15810: 
    1: PRInt32
    1: nsGenericElement::IndexOf(nsINode* aPossibleChild) const
    1: {
    1:   return mAttrsAndChildren.IndexOfChild(aPossibleChild);
    1: }
    1: 
    1: nsINode::nsSlots*
    1: nsGenericElement::CreateSlots()
    1: {
11169:   return new nsDOMSlots(mFlagsOrSlots);
    1: }
    1: 
  723: PRBool
  723: nsGenericElement::CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
  723:                                                        nsIURI** aURI) const
  723: {
  723:   if (aVisitor.mEventStatus == nsEventStatus_eConsumeNoDefault ||
  723:       !NS_IS_TRUSTED_EVENT(aVisitor.mEvent) ||
  723:       !aVisitor.mPresContext) {
  723:     return PR_FALSE;
  723:   }
  723: 
  723:   // Make sure we actually are a link
  723:   return IsLink(aURI);
  723: }
  723: 
  723: nsresult
  723: nsGenericElement::PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor)
  723: {
  723:   // Optimisation: return early if this event doesn't interest us.
  723:   // IMPORTANT: this switch and the switch below it must be kept in sync!
  723:   switch (aVisitor.mEvent->message) {
  723:   case NS_MOUSE_ENTER_SYNTH:
  723:   case NS_FOCUS_CONTENT:
  723:   case NS_MOUSE_EXIT_SYNTH:
  723:   case NS_BLUR_CONTENT:
  723:     break;
  723:   default:
  723:     return NS_OK;
  723:   }
  723: 
  723:   // Make sure we meet the preconditions before continuing
  723:   nsCOMPtr<nsIURI> absURI;
  723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
  723:     return NS_OK;
  723:   }
  723: 
  723:   nsresult rv = NS_OK;
  723: 
  723:   // We do the status bar updates in PreHandleEvent so that the status bar gets
  723:   // updated even if the event is consumed before we have a chance to set it.
  723:   switch (aVisitor.mEvent->message) {
  723:   // Set the status bar the same for focus and mouseover
  723:   case NS_MOUSE_ENTER_SYNTH:
  723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
  723:     // FALL THROUGH
  723:   case NS_FOCUS_CONTENT:
  723:     {
  723:       nsAutoString target;
  723:       GetLinkTarget(target);
 3333:       nsContentUtils::TriggerLink(this, aVisitor.mPresContext, absURI, target,
 3333:                                   PR_FALSE, PR_TRUE);
  723:     }
  723:     break;
  723: 
  723:   case NS_MOUSE_EXIT_SYNTH:
  723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
  723:     // FALL THROUGH
  723:   case NS_BLUR_CONTENT:
  723:     rv = LeaveLink(aVisitor.mPresContext);
  723:     break;
  723: 
  723:   default:
  723:     // switch not in sync with the optimization switch earlier in this function
  723:     NS_NOTREACHED("switch statements not in sync");
  723:     return NS_ERROR_UNEXPECTED;
  723:   }
  723: 
  723:   return rv;
  723: }
  723: 
    1: nsresult
    1: nsGenericElement::PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor)
    1: {
    1:   // Optimisation: return early if this event doesn't interest us.
    1:   // IMPORTANT: this switch and the switch below it must be kept in sync!
    1:   switch (aVisitor.mEvent->message) {
    1:   case NS_MOUSE_BUTTON_DOWN:
    1:   case NS_MOUSE_CLICK:
    1:   case NS_UI_ACTIVATE:
    1:   case NS_KEY_PRESS:
    1:     break;
    1:   default:
    1:     return NS_OK;
    1:   }
    1: 
  723:   // Make sure we meet the preconditions before continuing
    1:   nsCOMPtr<nsIURI> absURI;
  723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   switch (aVisitor.mEvent->message) {
    1:   case NS_MOUSE_BUTTON_DOWN:
    1:     {
    1:       if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:           static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
    1:           nsMouseEvent::eLeftButton) {
    1:         // don't make the link grab the focus if there is no link handler
    1:         nsILinkHandler *handler = aVisitor.mPresContext->GetLinkHandler();
    1:         nsIDocument *document = GetCurrentDoc();
29018:         if (handler && document) {
29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:           if (fm) {
29018:             nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
32919:             fm->SetFocus(elem, nsIFocusManager::FLAG_BYMOUSE |
32919:                                nsIFocusManager::FLAG_NOSCROLL);
    1:           }
    1: 
    1:           aVisitor.mPresContext->EventStateManager()->
29018:             SetContentState(this, NS_EVENT_STATE_ACTIVE);
    1:         }
    1:       }
    1:     }
    1:     break;
    1: 
    1:   case NS_MOUSE_CLICK:
    1:     if (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
33800:       nsInputEvent* inputEvent = static_cast<nsInputEvent*>(aVisitor.mEvent);
33800:       if (inputEvent->isControl || inputEvent->isMeta ||
33800:           inputEvent->isAlt ||inputEvent->isShift) {
33800:         break;
33800:       }
33800: 
    1:       // The default action is simply to dispatch DOMActivate
   95:       nsCOMPtr<nsIPresShell> shell = aVisitor.mPresContext->GetPresShell();
    1:       if (shell) {
    1:         // single-click
    1:         nsEventStatus status = nsEventStatus_eIgnore;
    1:         nsUIEvent actEvent(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
    1:                            NS_UI_ACTIVATE, 1);
    1: 
    1:         rv = shell->HandleDOMEventWithTarget(this, &actEvent, &status);
    1:       }
    1:     }
    1:     break;
    1: 
    1:   case NS_UI_ACTIVATE:
    1:     {
    1:       nsAutoString target;
    1:       GetLinkTarget(target);
 3333:       nsContentUtils::TriggerLink(this, aVisitor.mPresContext, absURI, target,
 3333:                                   PR_TRUE, PR_TRUE);
    1:     }
    1:     break;
    1: 
    1:   case NS_KEY_PRESS:
    1:     {
    1:       if (aVisitor.mEvent->eventStructType == NS_KEY_EVENT) {
 3233:         nsKeyEvent* keyEvent = static_cast<nsKeyEvent*>(aVisitor.mEvent);
    1:         if (keyEvent->keyCode == NS_VK_RETURN) {
    1:           nsEventStatus status = nsEventStatus_eIgnore;
    1:           rv = DispatchClickEvent(aVisitor.mPresContext, keyEvent, this,
    1:                                   PR_FALSE, &status);
    1:           if (NS_SUCCEEDED(rv)) {
    1:             aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     break;
    1: 
    1:   default:
    1:     // switch not in sync with the optimization switch earlier in this function
    1:     NS_NOTREACHED("switch statements not in sync");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsGenericElement::GetLinkTarget(nsAString& aTarget)
    1: {
    1:   aTarget.Truncate();
    1: }
    1: 
16106: // NOTE: The aPresContext pointer is NOT addrefed.
16106: static nsresult
16106: ParseSelectorList(nsINode* aNode,
16106:                   const nsAString& aSelectorString,
16106:                   nsCSSSelectorList** aSelectorList,
16106:                   nsPresContext** aPresContext)
16106: {
16106:   NS_ENSURE_ARG(aNode);
16106: 
16106:   nsIDocument* doc = aNode->GetOwnerDoc();
16106:   NS_ENSURE_STATE(doc);
16106: 
16106:   nsCOMPtr<nsICSSParser> parser;
16106:   nsresult rv = doc->CSSLoader()->GetParserFor(nsnull, getter_AddRefs(parser));
16106:   NS_ENSURE_SUCCESS(rv, rv);
16106: 
16106:   rv = parser->ParseSelectorString(aSelectorString,
16106:                                    doc->GetDocumentURI(),
16106:                                    0, // XXXbz get the right line number!
16106:                                    aSelectorList);
16106:   doc->CSSLoader()->RecycleParser(parser);
16106:   NS_ENSURE_SUCCESS(rv, rv);
16106: 
16106:   // It's not strictly necessary to have a prescontext here, but it's
16106:   // a bit of an optimization for various stuff.
16106:   *aPresContext = nsnull;
16106:   nsIPresShell* shell = doc->GetPrimaryShell();
16106:   if (shell) {
16106:     *aPresContext = shell->GetPresContext();
16106:   }
16106: 
16106:   return NS_OK;
16106: }
16106: 
16106: /*
16106:  * Callback to be called as we iterate over the tree and match elements.  If
16106:  * the callbacks returns false, the iteration should be stopped.
16106:  */
16106: typedef PRBool
20261: (* ElementMatchedCallback)(nsIContent* aMatchingElement, void* aClosure);
16106: 
16106: // returning false means stop iteration
16106: static PRBool
16106: TryMatchingElementsInSubtree(nsINode* aRoot,
16106:                              RuleProcessorData* aParentData,
16106:                              nsPresContext* aPresContext,
16106:                              nsCSSSelectorList* aSelectorList,
16106:                              ElementMatchedCallback aCallback,
16106:                              void* aClosure)
16106: {
16106:   /* To improve the performance of '+' and '~' combinators and the :nth-*
16106:    * selectors, we keep track of the immediately previous sibling data.  That's
16106:    * cheaper than heap-allocating all the datas and keeping track of them all,
16106:    * and helps a good bit in the common cases.  We also keep track of the whole
16106:    * parent data chain, since we have those Around anyway */
16106:   char databuf[2 * sizeof(RuleProcessorData)];
16106:   RuleProcessorData* prevSibling = nsnull;
16106:   RuleProcessorData* data = reinterpret_cast<RuleProcessorData*>(databuf);
18854: 
16106:   PRBool continueIteration = PR_TRUE;
27150:   for (nsINode::ChildIterator iter(aRoot); !iter.IsDone(); iter.Next()) {
27150:     nsIContent* kid = iter;
16106:     if (!kid->IsNodeOfType(nsINode::eELEMENT)) {
16106:       continue;
16106:     }
16106:     /* See whether we match */
16106:     new (data) RuleProcessorData(aPresContext, kid, nsnull);
16106:     NS_ASSERTION(!data->mParentData, "Shouldn't happen");
16106:     NS_ASSERTION(!data->mPreviousSiblingData, "Shouldn't happen");
16106:     data->mParentData = aParentData;
16106:     data->mPreviousSiblingData = prevSibling;
16106: 
16106:     if (nsCSSRuleProcessor::SelectorListMatches(*data, aSelectorList)) {
16106:       continueIteration = (*aCallback)(kid, aClosure);
16106:     }
16106: 
16106:     if (continueIteration) {
16106:       continueIteration =
16106:         TryMatchingElementsInSubtree(kid, data, aPresContext, aSelectorList,
16106:                                      aCallback, aClosure);
16106:     }
16106:     
16106:     /* Clear out the parent and previous sibling data if we set them, so that
16106:      * ~RuleProcessorData won't try to delete a placement-new'd object. Make
16106:      * sure this happens before our possible early break.  Note that we can
16106:      * have null aParentData but non-null data->mParentData if we're scoped to
16106:      * an element.  However, prevSibling and data->mPreviousSiblingData must
16106:      * always match.
16106:      */
16106:     NS_ASSERTION(!aParentData || data->mParentData == aParentData,
16106:                  "Unexpected parent");
16106:     NS_ASSERTION(data->mPreviousSiblingData == prevSibling,
16106:                  "Unexpected prev sibling");
16106:     data->mPreviousSiblingData = nsnull;
16106:     if (prevSibling) {
16106:       if (aParentData) {
16106:         prevSibling->mParentData = nsnull;
16106:       }
16106:       prevSibling->~RuleProcessorData();
16106:     } else {
16106:       /* This is the first time through, so point |prevSibling| to the location
16106:          we want to have |data| end up pointing to. */
16106:       prevSibling = data + 1;
16106:     }
16106: 
16106:     /* Now swap |prevSibling| and |data|.  Again, before the early break */
16106:     RuleProcessorData* temp = prevSibling;
16106:     prevSibling = data;
16106:     data = temp;
16106:     if (!continueIteration) {
16106:       break;
16106:     }
16106:   }
16106:   if (prevSibling) {
16106:     if (aParentData) {
16106:       prevSibling->mParentData = nsnull;
16106:     }
16106:     /* Make sure to clean this up */
16106:     prevSibling->~RuleProcessorData();
16106:   }
18854: 
16106:   return continueIteration;
16106: }
16106: 
20261: static PRBool
16106: FindFirstMatchingElement(nsIContent* aMatchingElement,
16106:                          void* aClosure)
16106: {
16106:   NS_PRECONDITION(aMatchingElement && aClosure, "How did that happen?");
16106:   nsIContent** slot = static_cast<nsIContent**>(aClosure);
16106:   *slot = aMatchingElement;
16106:   return PR_FALSE;
16106: }
16106: 
16106: /* static */
16106: nsresult
16106: nsGenericElement::doQuerySelector(nsINode* aRoot, const nsAString& aSelector,
16106:                                   nsIDOMElement **aReturn)
16106: {
16106:   NS_PRECONDITION(aReturn, "Null out param?");
16106: 
16106:   nsAutoPtr<nsCSSSelectorList> selectorList;
16106:   nsPresContext* presContext;
16106:   nsresult rv = ParseSelectorList(aRoot, aSelector,
16106:                                   getter_Transfers(selectorList),
16106:                                   &presContext);
16106:   NS_ENSURE_SUCCESS(rv, rv);
16106: 
16106:   nsIContent* foundElement = nsnull;
16106:   TryMatchingElementsInSubtree(aRoot, nsnull, presContext, selectorList,
16106:                                FindFirstMatchingElement, &foundElement);
16106: 
16106:   if (foundElement) {
16106:     return CallQueryInterface(foundElement, aReturn);
16106:   }
16106: 
16106:   *aReturn = nsnull;
16106:   return NS_OK;
16106: }
16106: 
20261: static PRBool
16106: AppendAllMatchingElements(nsIContent* aMatchingElement,
16106:                           void* aClosure)
16106: {
16106:   NS_PRECONDITION(aMatchingElement && aClosure, "How did that happen?");
19130:   static_cast<nsBaseContentList*>(aClosure)->AppendElement(aMatchingElement);
16106:   return PR_TRUE;
16106: }
16106: 
16106: /* static */
16106: nsresult
16106: nsGenericElement::doQuerySelectorAll(nsINode* aRoot,
16106:                                      const nsAString& aSelector,
16106:                                      nsIDOMNodeList **aReturn)
16106: {
16106:   NS_PRECONDITION(aReturn, "Null out param?");
16106: 
19130:   nsBaseContentList* contentList = new nsBaseContentList();
16106:   NS_ENSURE_TRUE(contentList, NS_ERROR_OUT_OF_MEMORY);
16106:   NS_ADDREF(*aReturn = contentList);
16106:   
16106:   nsAutoPtr<nsCSSSelectorList> selectorList;
16106:   nsPresContext* presContext;
16106:   nsresult rv = ParseSelectorList(aRoot, aSelector,
16106:                                   getter_Transfers(selectorList),
16106:                                   &presContext);
16106:   NS_ENSURE_SUCCESS(rv, rv);
16106: 
16106:   TryMatchingElementsInSubtree(aRoot, nsnull, presContext, selectorList,
16106:                                AppendAllMatchingElements, contentList);
16106:   return NS_OK;
16106: }
33351: 
33351: NS_IMETHODIMP
33351: nsNSElementTearoff::MozMatchesSelector(const nsAString& aSelector, PRBool* aReturn)
33351: {
33351:   NS_PRECONDITION(aReturn, "Null out param?");
33351:   *aReturn = nsGenericElement::doMatchesSelector(mContent, aSelector);
33351:   return NS_OK;
33351: }
33351: 
33351: /* static */
33351: PRBool
33351: nsGenericElement::doMatchesSelector(nsIContent* aNode, const nsAString& aSelector)
33351: {
33351:   nsAutoPtr<nsCSSSelectorList> selectorList;
33351:   nsPresContext* presContext;
33351:   PRBool matches = PR_FALSE;
33351: 
33351:   if (NS_SUCCEEDED(ParseSelectorList(aNode, aSelector,
33351:                                      getter_Transfers(selectorList),
33351:                                      &presContext)))
33351:   {
33351:     RuleProcessorData data(presContext, aNode, nsnull);
33351:     matches = nsCSSRuleProcessor::SelectorListMatches(data, selectorList);
33351:   }
33351: 
33351:   return matches;
33351: }
