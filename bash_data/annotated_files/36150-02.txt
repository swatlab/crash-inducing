19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
19246: #ifndef nsNPAPIPlugin_h_
19246: #define nsNPAPIPlugin_h_
19246: 
19246: #include "nsIPlugin.h"
19246: #include "prlink.h"
20125: #include "npfunctions.h"
29956: #include "nsPluginHost.h"
19246: 
36010: #include "mozilla/PluginLibrary.h"
35740: 
19246: /*
19246:  * Use this macro before each exported function
19246:  * (between the return address and the function
19246:  * itself), to ensure that the function has the
27301:  * right calling conventions on OS/2.
19246:  */
19246: #ifdef XP_OS2
19246: #define NP_CALLBACK _System
19246: #else
19246: #define NP_CALLBACK
19246: #endif
27301: 
19246: #if defined(XP_WIN)
19246: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
19246: #elif defined(XP_OS2)
19246: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (_System * _name)
19246: #else
19246: #define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (* _name)
19246: #endif
19246: 
19246: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_GETENTRYPOINTS) (NPPluginFuncs* pCallbacks);
19246: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGININIT) (const NPNetscapeFuncs* pCallbacks);
19246: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINUNIXINIT) (const NPNetscapeFuncs* pCallbacks, NPPluginFuncs* fCallbacks);
19246: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINSHUTDOWN) (void);
19246: #ifdef XP_MACOSX
20125: typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_MAIN) (NPNetscapeFuncs* nCallbacks, NPPluginFuncs* pCallbacks, NPP_ShutdownProcPtr* unloadProcPtr);
19246: #endif
19246: 
19246: class nsNPAPIPlugin : public nsIPlugin
19246: {
35740: private:
36010:   typedef mozilla::PluginLibrary PluginLibrary;
35740: 
19246: public:
35740:   nsNPAPIPlugin(NPPluginFuncs* callbacks,
36039:                 PluginLibrary* aLibrary /*assume ownership*/);
30212:   virtual ~nsNPAPIPlugin();
19246: 
19246:   NS_DECL_ISUPPORTS
19246:   NS_DECL_NSIPLUGIN
19246: 
29020:   // Constructs and initializes an nsNPAPIPlugin object. A NULL file path
29020:   // will prevent this from calling NP_Initialize.
29020:   static nsresult CreatePlugin(const char* aFilePath, PRLibrary* aLibrary,
19246:                                nsIPlugin** aResult);
19246: #ifdef XP_MACOSX
19246:   void SetPluginRefNum(short aRefNum);
19246: #endif
19246: 
19246: protected:
36150:   friend class nsNPAPIPluginInstance;
36150:   friend class nsNPAPIPluginStreamListener;
36150: 
19246:   // Ensures that the static CALLBACKS is properly initialized
19246:   static void CheckClassInitialized(void);
19246: 
22811: #ifdef XP_MACOSX
22811:   short fPluginRefNum;
22811: #endif
22811: 
19246:   // The plugin-side callbacks that the browser calls. One set of
19246:   // plugin callbacks for each plugin.
19246:   NPPluginFuncs fCallbacks;
36010:   PluginLibrary* fLibrary;
35740:   PRLibrary* fPRLibrary;
19246: 
30212:   // Browser-side callbacks that the plugin calls.
19246:   static NPNetscapeFuncs CALLBACKS;
19246: };
19246: 
36125: namespace mozilla {
36125: namespace plugins {
36125: namespace parent {
19246: 
19246: NPObject* NP_CALLBACK
19246: _getwindowobject(NPP npp);
19246: 
19246: NPObject* NP_CALLBACK
19246: _getpluginelement(NPP npp);
19246: 
19246: NPIdentifier NP_CALLBACK
19246: _getstringidentifier(const NPUTF8* name);
19246: 
19246: void NP_CALLBACK
19246: _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
19246:                       NPIdentifier *identifiers);
19246: 
19246: bool NP_CALLBACK
19246: _identifierisstring(NPIdentifier identifiers);
19246: 
19246: NPIdentifier NP_CALLBACK
19246: _getintidentifier(int32_t intid);
19246: 
19246: NPUTF8* NP_CALLBACK
19246: _utf8fromidentifier(NPIdentifier identifier);
19246: 
19246: int32_t NP_CALLBACK
19246: _intfromidentifier(NPIdentifier identifier);
19246: 
19246: NPObject* NP_CALLBACK
19246: _createobject(NPP npp, NPClass* aClass);
19246: 
19246: NPObject* NP_CALLBACK
19246: _retainobject(NPObject* npobj);
19246: 
19246: void NP_CALLBACK
19246: _releaseobject(NPObject* npobj);
19246: 
19246: bool NP_CALLBACK
19246: _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
19246:         uint32_t argCount, NPVariant *result);
19246: 
19246: bool NP_CALLBACK
19246: _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
19246:                uint32_t argCount, NPVariant *result);
19246: 
19246: bool NP_CALLBACK
19246: _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result);
19246: 
19246: bool NP_CALLBACK
19246: _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
19246:              NPVariant *result);
19246: 
19246: bool NP_CALLBACK
19246: _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
19246:              const NPVariant *value);
19246: 
19246: bool NP_CALLBACK
19246: _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property);
19246: 
19246: bool NP_CALLBACK
19246: _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
19246: 
19246: bool NP_CALLBACK
19246: _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
19246: 
19246: bool NP_CALLBACK
19246: _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
19246:            uint32_t *count);
19246: 
19246: bool NP_CALLBACK
19246: _construct(NPP npp, NPObject* npobj, const NPVariant *args,
19246:            uint32_t argCount, NPVariant *result);
19246: 
19246: void NP_CALLBACK
19246: _releasevariantvalue(NPVariant *variant);
19246: 
19246: void NP_CALLBACK
19246: _setexception(NPObject* npobj, const NPUTF8 *message);
19246: 
23571: void NP_CALLBACK
23571: _pushpopupsenabledstate(NPP npp, NPBool enabled);
23571: 
23571: void NP_CALLBACK
23571: _poppopupsenabledstate(NPP npp);
23571: 
23571: typedef void(*PluginThreadCallback)(void *);
36125: 
23571: void NP_CALLBACK
23571: _pluginthreadasynccall(NPP instance, PluginThreadCallback func,
23571:                        void *userData);
23571: 
23571: NPError NP_CALLBACK
23571: _getvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
23571:                 char **value, uint32_t *len);
36125: 
23571: NPError NP_CALLBACK
23571: _setvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
23571:                 const char *value, uint32_t len);
23571: 
23571: NPError NP_CALLBACK
23571: _getauthenticationinfo(NPP instance, const char *protocol, const char *host,
23571:                        int32_t port, const char *scheme, const char *realm,
23571:                        char **username, uint32_t *ulen, char **password,
23571:                        uint32_t *plen);
23571: 
36125: typedef void(*PluginTimerFunc)(NPP npp, uint32_t timerID);
36125: 
29937: uint32_t NP_CALLBACK
36125: _scheduletimer(NPP instance, uint32_t interval, NPBool repeat, PluginTimerFunc timerFunc);
29937: 
29937: void NP_CALLBACK
29937: _unscheduletimer(NPP instance, uint32_t timerID);
29937: 
32019: NPError NP_CALLBACK
32019: _popupcontextmenu(NPP instance, NPMenu* menu);
32019: 
32019: NPBool NP_CALLBACK
32019: _convertpoint(NPP instance, double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace);
32019: 
36125: NPError NP_CALLBACK
36125: _requestread(NPStream *pstream, NPByteRange *rangeList);
36125: 
36125: NPError NP_CALLBACK
36125: _geturlnotify(NPP npp, const char* relativeURL, const char* target,
36125:               void* notifyData);
36125: 
36125: NPError NP_CALLBACK
36125: _getvalue(NPP npp, NPNVariable variable, void *r_value);
36125: 
36125: NPError NP_CALLBACK
36125: _setvalue(NPP npp, NPPVariable variable, void *r_value);
36125: 
36125: NPError NP_CALLBACK
36125: _geturl(NPP npp, const char* relativeURL, const char* target);
36125: 
36125: NPError NP_CALLBACK
36125: _posturlnotify(NPP npp, const char* relativeURL, const char *target,
36125:                uint32_t len, const char *buf, NPBool file, void* notifyData);
36125: 
36125: NPError NP_CALLBACK
36125: _posturl(NPP npp, const char* relativeURL, const char *target, uint32_t len,
36125:             const char *buf, NPBool file);
36125: 
36125: NPError NP_CALLBACK
36125: _newstream(NPP npp, NPMIMEType type, const char* window, NPStream** pstream);
36125: 
36125: int32_t NP_CALLBACK
36125: _write(NPP npp, NPStream *pstream, int32_t len, void *buffer);
36125: 
36125: NPError NP_CALLBACK
36125: _destroystream(NPP npp, NPStream *pstream, NPError reason);
36125: 
36125: void NP_CALLBACK
36125: _status(NPP npp, const char *message);
36125: 
36125: void NP_CALLBACK
36125: _memfree (void *ptr);
36125: 
36125: uint32_t NP_CALLBACK
36125: _memflush(uint32_t size);
36125: 
36125: void NP_CALLBACK
36125: _reloadplugins(NPBool reloadPages);
36125: 
36125: void NP_CALLBACK
36125: _invalidaterect(NPP npp, NPRect *invalidRect);
36125: 
36125: void NP_CALLBACK
36125: _invalidateregion(NPP npp, NPRegion invalidRegion);
36125: 
36125: void NP_CALLBACK
36125: _forceredraw(NPP npp);
36125: 
36125: const char* NP_CALLBACK
36125: _useragent(NPP npp);
36125: 
36125: void* NP_CALLBACK
36125: _memalloc (uint32_t size);
36125: 
36125: // Deprecated entry points for the old Java plugin.
36125: void* NP_CALLBACK /* OJI type: JRIEnv* */
36125: _getJavaEnv(void);
36125: 
36125: void* NP_CALLBACK /* OJI type: jref */
36125: _getJavaPeer(NPP npp);
36125: 
36125: } /* namespace parent */
36125: } /* namespace plugins */
36125: } /* namespace mozilla */
36125: 
19246: const char *
19246: PeekException();
19246: 
19246: void
19246: PopException();
19246: 
19246: void
19246: OnPluginDestroy(NPP instance);
19246: 
19246: void
19246: OnShutdown();
19246: 
19246: void
19246: EnterAsyncPluginThreadCallLock();
19246: void
19246: ExitAsyncPluginThreadCallLock();
19246: 
19246: class NPPStack
19246: {
19246: public:
19246:   static NPP Peek()
19246:   {
19246:     return sCurrentNPP;
19246:   }
19246: 
19246: protected:
19246:   static NPP sCurrentNPP;
19246: };
19246: 
19246: // XXXjst: The NPPAutoPusher stack is a bit redundant now that
19246: // PluginDestructionGuard exists, and could thus be replaced by code
19246: // that uses the PluginDestructionGuard list of plugins on the
19246: // stack. But they're not identical, and to minimize code changes
19246: // we're keeping both for the moment, and making NPPAutoPusher inherit
19246: // the PluginDestructionGuard class to avoid having to keep two
19246: // separate objects on the stack since we always want a
19246: // PluginDestructionGuard where we use an NPPAutoPusher.
19246: 
19246: class NPPAutoPusher : public NPPStack,
19246:                       protected PluginDestructionGuard
19246: {
19246: public:
19246:   NPPAutoPusher(NPP npp)
19246:     : PluginDestructionGuard(npp),
19246:       mOldNPP(sCurrentNPP)
19246:   {
19246:     NS_ASSERTION(npp, "Uh, null npp passed to NPPAutoPusher!");
19246: 
19246:     sCurrentNPP = npp;
19246:   }
19246: 
19246:   ~NPPAutoPusher()
19246:   {
19246:     sCurrentNPP = mOldNPP;
19246:   }
19246: 
19246: private:
19246:   NPP mOldNPP;
19246: };
19246: 
19246: class NPPExceptionAutoHolder
19246: {
19246: public:
19246:   NPPExceptionAutoHolder();
19246:   ~NPPExceptionAutoHolder();
19246: 
19246: protected:
19246:   char *mOldException;
19246: };
19246: 
19246: #endif // nsNPAPIPlugin_h_
