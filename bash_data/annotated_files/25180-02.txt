    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set ts=2 sw=2 sts=2 cin et: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDocShell.h"
    1: #include "nsWebShell.h"
    1: #include "nsIWebBrowserChrome2.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIClipboardCommands.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIPrompt.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIRefreshURI.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsPresContext.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsCRT.h"
    1: #include "nsVoidArray.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "prprf.h"
    1: #include "nsIPluginHost.h"
    1: #include "nsplugin.h"
    1: #include "nsIPluginManager.h"
    1: #include "nsCDefaultURIFixup.h"
    1: #include "nsIContent.h"
    1: #include "prlog.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIWebShellServices.h"
    1: #include "nsIGlobalHistory.h"
    1: #include "prmem.h"
    1: #include "prthread.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsDOMError.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIURIContentListener.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsCURILoader.h"
 5528: #include "nsURILoader.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsEscape.h"
    1: #include "nsIPlatformCharset.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsISocketTransportService.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsPICommandUpdater.h"
    1: #include "nsIController.h"
    1: #include "nsIFocusController.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsISHistoryInternal.h"
    1: 
    1: #include "nsIHttpChannel.h"
    1: #include "nsIHttpChannelInternal.h"
    1: #include "nsIUploadChannel.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsStreamUtils.h"
    1: #include "nsThreadUtils.h"
    1: 
    1: #include "nsILocaleService.h"
    1: #include "nsIStringBundle.h"
    1: 
    1: #include "nsICachingChannel.h"
    1: 
    1: #include "nsIDocument.h"
    1: #include "nsITextToSubURI.h"
    1: 
    1: #include "nsIExternalProtocolService.h"
    1: #include "nsCExternalHandlerService.h"
    1: 
    1: #include "nsIIDNService.h"
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsITimer.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsContentPolicyUtils.h"
    1: 
 5528: #include "nsIURIClassifier.h"
 5528: 
    1: #ifdef NS_DEBUG
    1: /**
    1:  * Note: the log module is created during initialization which
    1:  * means that you cannot perform logging before then.
    1:  */
    1: static PRLogModuleInfo* gLogModule = PR_NewLogModule("webshell");
    1: #endif
    1: 
    1: #define WEB_TRACE_CALLS        0x1
    1: #define WEB_TRACE_HISTORY      0x2
    1: 
    1: #define WEB_LOG_TEST(_lm,_bit) (PRIntn((_lm)->level) & (_bit))
    1: 
    1: #ifdef NS_DEBUG
    1: #define WEB_TRACE(_bit,_args)            \
    1:   PR_BEGIN_MACRO                         \
    1:     if (WEB_LOG_TEST(gLogModule,_bit)) { \
    1:       PR_LogPrint _args;                 \
    1:     }                                    \
    1:   PR_END_MACRO
    1: #else
    1: #define WEB_TRACE(_bit,_args)
    1: #endif
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: #define PREF_PINGS_ENABLED           "browser.send_pings"
    1: #define PREF_PINGS_MAX_PER_LINK      "browser.send_pings.max_per_link"
    1: #define PREF_PINGS_REQUIRE_SAME_HOST "browser.send_pings.require_same_host"
    1: 
    1: // Check prefs to see if pings are enabled and if so what restrictions might
    1: // be applied.
    1: //
    1: // @param maxPerLink
    1: //   This parameter returns the number of pings that are allowed per link click
    1: //
    1: // @param requireSameHost
    1: //   This parameter returns PR_TRUE if pings are restricted to the same host as
    1: //   the document in which the click occurs.  If the same host restriction is
    1: //   imposed, then we still allow for pings to cross over to different
    1: //   protocols and ports for flexibility and because it is not possible to send
    1: //   a ping via FTP.
    1: //
    1: // @returns
    1: //   PR_TRUE if pings are enabled and PR_FALSE otherwise.
    1: //
    1: static PRBool
    1: PingsEnabled(PRInt32 *maxPerLink, PRBool *requireSameHost)
    1: {
    1:   PRBool allow = PR_FALSE;
    1: 
    1:   *maxPerLink = 1;
    1:   *requireSameHost = PR_TRUE;
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefs =
    1:       do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (prefs) {
    1:     PRBool val;
    1:     if (NS_SUCCEEDED(prefs->GetBoolPref(PREF_PINGS_ENABLED, &val)))
    1:       allow = val;
    1:     if (allow) {
    1:       prefs->GetIntPref(PREF_PINGS_MAX_PER_LINK, maxPerLink);
    1:       prefs->GetBoolPref(PREF_PINGS_REQUIRE_SAME_HOST, requireSameHost);
    1:     }
    1:   }
    1: 
    1:   return allow;
    1: }
    1: 
    1: static PRBool
    1: CheckPingURI(nsIURI* uri, nsIContent* content)
    1: {
    1:   if (!uri)
    1:     return PR_FALSE;
    1: 
    1:   // Check with nsIScriptSecurityManager
    1:   nsCOMPtr<nsIScriptSecurityManager> ssmgr =
    1:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
    1:   NS_ENSURE_TRUE(ssmgr, PR_FALSE);
    1: 
    1:   nsresult rv =
    1:     ssmgr->CheckLoadURIWithPrincipal(content->NodePrincipal(), uri,
    1:                                      nsIScriptSecurityManager::STANDARD);
    1:   if (NS_FAILED(rv)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // Ignore non-HTTP(S)
    1:   PRBool match;
    1:   if ((NS_FAILED(uri->SchemeIs("http", &match)) || !match) &&
    1:       (NS_FAILED(uri->SchemeIs("https", &match)) || !match)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // Check with contentpolicy
    1:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_PING,
    1:                                  uri,
 4367:                                  content->NodePrincipal(),
    1:                                  content,
    1:                                  EmptyCString(), // mime hint
    1:                                  nsnull, //extra
    1:                                  &shouldLoad);
    1:   return NS_SUCCEEDED(rv) && NS_CP_ACCEPTED(shouldLoad);
    1: }
    1: 
    1: typedef void (* ForEachPingCallback)(void *closure, nsIContent *content,
    1:                                      nsIURI *uri, nsIIOService *ios);
    1: 
    1: static void
    1: ForEachPing(nsIContent *content, ForEachPingCallback callback, void *closure)
    1: {
    1:   // NOTE: Using nsIDOMNSHTMLAnchorElement2::GetPing isn't really worth it here
    1:   //       since we'd still need to parse the resulting string.  Instead, we
    1:   //       just parse the raw attribute.  It might be nice if the content node
    1:   //       implemented an interface that exposed an enumeration of nsIURIs.
    1: 
    1:   // Make sure we are dealing with either an <A> or <AREA> element in the HTML
    1:   // or XHTML namespace.
    1:   if (!content->IsNodeOfType(nsINode::eHTML))
    1:     return;
    1:   nsIAtom *nameAtom = content->Tag();
    1:   if (!nameAtom->EqualsUTF8(NS_LITERAL_CSTRING("a")) &&
    1:       !nameAtom->EqualsUTF8(NS_LITERAL_CSTRING("area")))
    1:     return;
    1: 
    1:   nsCOMPtr<nsIAtom> pingAtom = do_GetAtom("ping");
    1:   if (!pingAtom)
    1:     return;
    1: 
    1:   nsAutoString value;
    1:   content->GetAttr(kNameSpaceID_None, pingAtom, value);
    1:   if (value.IsEmpty())
    1:     return;
    1: 
    1:   nsCOMPtr<nsIIOService> ios = do_GetIOService();
    1:   if (!ios)
    1:     return;
    1: 
    1:   nsIDocument *doc = content->GetOwnerDoc();
    1:   if (!doc)
    1:     return;
    1: 
    1:   // value contains relative URIs split on spaces (U+0020)
    1:   const PRUnichar *start = value.BeginReading();
    1:   const PRUnichar *end   = value.EndReading();
    1:   const PRUnichar *iter  = start;
    1:   for (;;) {
    1:     if (iter < end && *iter != ' ') {
    1:       ++iter;
    1:     } else {  // iter is pointing at either end or a space
    1:       while (*start == ' ' && start < iter)
    1:         ++start;
    1:       if (iter != start) {
    1:         nsCOMPtr<nsIURI> uri, baseURI = content->GetBaseURI();
    1:         ios->NewURI(NS_ConvertUTF16toUTF8(Substring(start, iter)),
    1:                     doc->GetDocumentCharacterSet().get(),
    1:                     baseURI, getter_AddRefs(uri));
    1:         if (CheckPingURI(uri, content)) {
    1:           callback(closure, content, uri, ios);
    1:         }
    1:       }
    1:       start = iter = iter + 1;
    1:       if (iter >= end)
    1:         break;
    1:     }
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // We wait this many milliseconds before killing the ping channel...
    1: #define PING_TIMEOUT 10000
    1: 
    1: static void
    1: OnPingTimeout(nsITimer *timer, void *closure)
    1: {
 3233:   nsILoadGroup *loadGroup = static_cast<nsILoadGroup *>(closure);
    1:   loadGroup->Cancel(NS_ERROR_ABORT);
    1:   loadGroup->Release();
    1: }
    1: 
    1: // Check to see if two URIs have the same host or not
    1: static PRBool
    1: IsSameHost(nsIURI *uri1, nsIURI *uri2)
    1: {
    1:   nsCAutoString host1, host2;
    1:   uri1->GetAsciiHost(host1);
    1:   uri2->GetAsciiHost(host2);
    1:   return host1.Equals(host2);
    1: }
    1: 
    1: class nsPingListener : public nsIStreamListener
    1:                      , public nsIInterfaceRequestor
    1:                      , public nsIChannelEventSink
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIREQUESTOBSERVER
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIINTERFACEREQUESTOR
    1:   NS_DECL_NSICHANNELEVENTSINK
    1: 
    1:   nsPingListener(PRBool requireSameHost, nsIContent* content)
    1:     : mRequireSameHost(requireSameHost),
    1:       mContent(content)
    1:   {}
    1: 
    1: private:
    1:   PRBool mRequireSameHost;
    1:   nsCOMPtr<nsIContent> mContent;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS4(nsPingListener, nsIStreamListener, nsIRequestObserver,
    1:                    nsIInterfaceRequestor, nsIChannelEventSink)
    1: 
    1: NS_IMETHODIMP
    1: nsPingListener::OnStartRequest(nsIRequest *request, nsISupports *context)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPingListener::OnDataAvailable(nsIRequest *request, nsISupports *context,
    1:                                 nsIInputStream *stream, PRUint32 offset,
    1:                                 PRUint32 count)
    1: {
    1:   PRUint32 result;
    1:   return stream->ReadSegments(NS_DiscardSegment, nsnull, count, &result);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPingListener::OnStopRequest(nsIRequest *request, nsISupports *context,
    1:                               nsresult status)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPingListener::GetInterface(const nsIID &iid, void **result)
    1: {
    1:   if (iid.Equals(NS_GET_IID(nsIChannelEventSink))) {
    1:     NS_ADDREF_THIS();
    1:     *result = (nsIChannelEventSink *) this;
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPingListener::OnChannelRedirect(nsIChannel *oldChan, nsIChannel *newChan,
    1:                                   PRUint32 flags)
    1: {
    1:   nsCOMPtr<nsIURI> newURI;
    1:   newChan->GetURI(getter_AddRefs(newURI));
    1: 
    1:   if (!CheckPingURI(newURI, mContent))
    1:     return NS_ERROR_ABORT;
    1: 
    1:   if (!mRequireSameHost)
    1:     return NS_OK;
    1: 
21937:   // XXXbz should this be using something more like the nsContentUtils
21937:   // same-origin checker?
    1:   nsCOMPtr<nsIURI> oldURI;
    1:   oldChan->GetURI(getter_AddRefs(oldURI));
    1:   NS_ENSURE_STATE(oldURI && newURI);
    1: 
    1:   if (!IsSameHost(oldURI, newURI))
    1:     return NS_ERROR_ABORT;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: struct SendPingInfo {
    1:   PRInt32 numPings;
    1:   PRInt32 maxPings;
    1:   PRBool  requireSameHost;
    1:   nsIURI *referrer;
    1: };
    1: 
    1: static void
    1: SendPing(void *closure, nsIContent *content, nsIURI *uri, nsIIOService *ios)
    1: {
 3233:   SendPingInfo *info = static_cast<SendPingInfo *>(closure);
    1:   if (info->numPings >= info->maxPings)
    1:     return;
    1: 
    1:   if (info->requireSameHost) {
    1:     // Make sure the referrer and the given uri share the same origin.  We
    1:     // only require the same hostname.  The scheme and port may differ.
    1:     if (!IsSameHost(uri, info->referrer))
    1:       return;
    1:   }
    1: 
    1:   nsIDocument *doc = content->GetOwnerDoc();
    1:   if (!doc)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIChannel> chan;
    1:   ios->NewChannelFromURI(uri, getter_AddRefs(chan));
    1:   if (!chan)
    1:     return;
    1: 
    1:   // Don't bother caching the result of this URI load.
    1:   chan->SetLoadFlags(nsIRequest::INHIBIT_CACHING);
    1: 
    1:   nsCOMPtr<nsIHttpChannel> httpChan = do_QueryInterface(chan);
    1:   if (!httpChan)
    1:     return;
    1: 
    1:   // This is needed in order for 3rd-party cookie blocking to work.
    1:   nsCOMPtr<nsIHttpChannelInternal> httpInternal = do_QueryInterface(httpChan);
    1:   if (httpInternal)
    1:     httpInternal->SetDocumentURI(doc->GetDocumentURI());
    1: 
    1:   if (info->referrer)
    1:     httpChan->SetReferrer(info->referrer);
    1: 
    1:   httpChan->SetRequestMethod(NS_LITERAL_CSTRING("POST"));
    1: 
    1:   // Remove extraneous request headers (to reduce request size)
    1:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept"),
    1:                              EmptyCString(), PR_FALSE);
    1:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-language"),
    1:                              EmptyCString(), PR_FALSE);
    1:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-charset"),
    1:                              EmptyCString(), PR_FALSE);
    1:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-encoding"),
    1:                              EmptyCString(), PR_FALSE);
    1: 
    1:   nsCOMPtr<nsIUploadChannel> uploadChan = do_QueryInterface(httpChan);
    1:   if (!uploadChan)
    1:     return;
    1: 
    1:   // To avoid sending an unnecessary Content-Type header, we encode the
    1:   // closing portion of the headers in the POST body.
    1:   NS_NAMED_LITERAL_CSTRING(uploadData, "Content-Length: 0\r\n\r\n");
    1: 
    1:   nsCOMPtr<nsIInputStream> uploadStream;
    1:   NS_NewPostDataStream(getter_AddRefs(uploadStream), PR_FALSE,
    1:                        uploadData, 0);
    1:   if (!uploadStream)
    1:     return;
    1: 
    1:   uploadChan->SetUploadStream(uploadStream, EmptyCString(), -1);
    1: 
    1:   // The channel needs to have a loadgroup associated with it, so that we can
    1:   // cancel the channel and any redirected channels it may create.
    1:   nsCOMPtr<nsILoadGroup> loadGroup =
    1:       do_CreateInstance(NS_LOADGROUP_CONTRACTID);
    1:   if (!loadGroup)
    1:     return;
    1:   chan->SetLoadGroup(loadGroup);
    1: 
    1:   // Construct a listener that merely discards any response.  If successful at
    1:   // opening the channel, then it is not necessary to hold a reference to the
    1:   // channel.  The networking subsystem will take care of that for us.
    1:   nsCOMPtr<nsIStreamListener> listener =
    1:       new nsPingListener(info->requireSameHost, content);
    1:   if (!listener)
    1:     return;
    1: 
    1:   // Observe redirects as well:
    1:   nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryInterface(listener);
    1:   NS_ASSERTION(callbacks, "oops");
    1:   loadGroup->SetNotificationCallbacks(callbacks);
    1: 
    1:   chan->AsyncOpen(listener, nsnull);
    1: 
    1:   // Even if AsyncOpen failed, we still count this as a successful ping.  It's
    1:   // possible that AsyncOpen may have failed after triggering some background
    1:   // process that may have written something to the network.
    1:   info->numPings++;
    1: 
    1:   // Prevent ping requests from stalling and never being garbage collected...
    1:   nsCOMPtr<nsITimer> timer =
    1:       do_CreateInstance(NS_TIMER_CONTRACTID);
    1:   if (timer) {
    1:     nsresult rv = timer->InitWithFuncCallback(OnPingTimeout, loadGroup,
    1:                                               PING_TIMEOUT,
    1:                                               nsITimer::TYPE_ONE_SHOT);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       // When the timer expires, the callback function will release this
    1:       // reference to the loadgroup.
 3233:       static_cast<nsILoadGroup *>(loadGroup.get())->AddRef();
    1:       loadGroup = 0;
    1:     }
    1:   }
    1:   
    1:   // If we failed to setup the timer, then we should just cancel the channel
    1:   // because we won't be able to ensure that it goes away in a timely manner.
    1:   if (loadGroup)
    1:     chan->Cancel(NS_ERROR_ABORT);
    1: }
    1: 
    1: // Spec: http://whatwg.org/specs/web-apps/current-work/#ping
    1: static void
    1: DispatchPings(nsIContent *content, nsIURI *referrer)
    1: {
    1:   SendPingInfo info;
    1: 
    1:   if (!PingsEnabled(&info.maxPings, &info.requireSameHost))
    1:     return;
    1:   if (info.maxPings == 0)
    1:     return;
    1: 
    1:   info.numPings = 0;
    1:   info.referrer = referrer;
    1: 
    1:   ForEachPing(content, SendPing, &info);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Note: operator new zeros our memory
    1: nsWebShell::nsWebShell() : nsDocShell()
    1: {
    1: #ifdef DEBUG
    1:   // We're counting the number of |nsWebShells| to help find leaks
    1:   ++gNumberOfWebShells;
    1: #endif
    1: #ifdef DEBUG
    1:     printf("++WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
    1: #endif
    1: 
    1:   InitFrameData();
    1:   mItemType = typeContent;
    1:   mCharsetReloadState = eCharsetReloadInit;
    1: }
    1: 
    1: nsWebShell::~nsWebShell()
    1: {
    1:    Destroy();
    1: 
    1:   ++mRefCnt; // following releases can cause this destructor to be called
    1:              // recursively if the refcount is allowed to remain 0
    1: 
    1:   mContentViewer=nsnull;
    1: 
    1:   InitFrameData();
    1: 
    1: #ifdef DEBUG
    1:   // We're counting the number of |nsWebShells| to help find leaks
    1:   --gNumberOfWebShells;
    1: #endif
    1: #ifdef DEBUG
    1:   printf("--WEBSHELL %p == %ld\n", (void*) this, gNumberOfWebShells);
    1: #endif
    1: }
    1: 
    1: void nsWebShell::InitFrameData()
    1: {
    1:   SetMarginWidth(-1);    
    1:   SetMarginHeight(-1);
    1: }
    1: 
    1: nsresult
    1: nsWebShell::EnsureCommandHandler()
    1: {
    1:   if (!mCommandManager)
    1:   {
25180:     nsCOMPtr<nsPICommandUpdater> commandUpdater =
25180:       do_CreateInstance("@mozilla.org/embedcomp/command-manager;1");
25180:     if (!commandUpdater) return NS_ERROR_OUT_OF_MEMORY;
    1:     
25180:     nsCOMPtr<nsIDOMWindow> domWindow =
25180:       do_GetInterface(static_cast<nsIInterfaceRequestor *>(this));
    1: 
25180:     nsresult rv = commandUpdater->Init(domWindow);
25180:     if (NS_SUCCEEDED(rv))
25180:       mCommandManager = do_QueryInterface(commandUpdater);
    1:   }
    1:   
    1:   return mCommandManager ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsWebShell, nsDocShell)
    1: NS_IMPL_RELEASE_INHERITED(nsWebShell, nsDocShell)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsWebShell)
    1:    NS_INTERFACE_MAP_ENTRY(nsIWebShellServices)
    1:    NS_INTERFACE_MAP_ENTRY(nsILinkHandler)
    1:    NS_INTERFACE_MAP_ENTRY(nsIClipboardCommands)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDocShell)
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::GetInterface(const nsIID &aIID, void** aInstancePtr)
    1: {
    1:    NS_PRECONDITION(aInstancePtr, "null out param");
    1: 
    1:    *aInstancePtr = nsnull;
    1: 
    1:    if(aIID.Equals(NS_GET_IID(nsICommandManager)))
    1:       {
    1:       NS_ENSURE_SUCCESS(EnsureCommandHandler(), NS_ERROR_FAILURE);
    1:       *aInstancePtr = mCommandManager;
    1:       NS_ADDREF((nsISupports*) *aInstancePtr);
    1:       return NS_OK;
    1:       }
    1: 
    1:    return nsDocShell::GetInterface(aIID, aInstancePtr);
    1: }
    1: 
20261: nsEventStatus
    1: nsWebShell::HandleEvent(nsGUIEvent *aEvent)
    1: {
    1:   return nsEventStatus_eIgnore;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // Web Shell Services API
    1: 
    1: //This functions is only called when a new charset is detected in loading a document. 
    1: //Its name should be changed to "CharsetReloadDocument"
    1: NS_IMETHODIMP
    1: nsWebShell::ReloadDocument(const char* aCharset,
    1:                            PRInt32 aSource)
    1: {
    1: 
    1:   // XXX hack. kee the aCharset and aSource wait to pick it up
    1:   nsCOMPtr<nsIContentViewer> cv;
    1:   NS_ENSURE_SUCCESS(GetContentViewer(getter_AddRefs(cv)), NS_ERROR_FAILURE);
    1:   if (cv)
    1:   {
    1:     nsCOMPtr<nsIMarkupDocumentViewer> muDV = do_QueryInterface(cv);  
    1:     if (muDV)
    1:     {
    1:       PRInt32 hint;
    1:       muDV->GetHintCharacterSetSource(&hint);
    1:       if( aSource > hint ) 
    1:       {
    1:          muDV->SetHintCharacterSet(nsDependentCString(aCharset));
    1:          muDV->SetHintCharacterSetSource(aSource);
    1:          if(eCharsetReloadRequested != mCharsetReloadState) 
    1:          {
    1:             mCharsetReloadState = eCharsetReloadRequested;
    1:             return Reload(LOAD_FLAGS_CHARSET_CHANGE);
    1:          }
    1:       }
    1:     }
    1:   }
    1:   //return failer if this request is not accepted due to mCharsetReloadState
    1:   return NS_ERROR_WEBSHELL_REQUEST_REJECTED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::StopDocumentLoad(void)
    1: {
    1:   if(eCharsetReloadRequested != mCharsetReloadState) 
    1:   {
    1:     Stop(nsIWebNavigation::STOP_ALL);
    1:     return NS_OK;
    1:   }
    1:   //return failer if this request is not accepted due to mCharsetReloadState
    1:   return NS_ERROR_WEBSHELL_REQUEST_REJECTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::SetRendering(PRBool aRender)
    1: {
    1:   if(eCharsetReloadRequested != mCharsetReloadState) 
    1:   {
    1:     if (mContentViewer) {
    1:        mContentViewer->SetEnableRendering(aRender);
    1:        return NS_OK;
    1:     }
    1:   }
    1:   //return failer if this request is not accepted due to mCharsetReloadState
    1:   return NS_ERROR_WEBSHELL_REQUEST_REJECTED;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // WebShell link handling
    1: 
    1: class OnLinkClickEvent : public nsRunnable {
    1: public:
    1:   OnLinkClickEvent(nsWebShell* aHandler, nsIContent* aContent,
    1:                    nsIURI* aURI,
    1:                    const PRUnichar* aTargetSpec,
    1:                    nsIInputStream* aPostDataStream = 0, 
    1:                    nsIInputStream* aHeadersDataStream = 0);
    1: 
    1:   NS_IMETHOD Run() {
    1:     nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mHandler->mScriptGlobal));
    1:     nsAutoPopupStatePusher popupStatePusher(window, mPopupState);
    1: 
    1:     mHandler->OnLinkClickSync(mContent, mURI,
    1:                               mTargetSpec.get(), mPostDataStream,
    1:                               mHeadersDataStream,
    1:                               nsnull, nsnull);
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsRefPtr<nsWebShell>     mHandler;
    1:   nsCOMPtr<nsIURI>         mURI;
    1:   nsString                 mTargetSpec;
    1:   nsCOMPtr<nsIInputStream> mPostDataStream;
    1:   nsCOMPtr<nsIInputStream> mHeadersDataStream;
    1:   nsCOMPtr<nsIContent>     mContent;
    1:   PopupControlState        mPopupState;
    1: };
    1: 
    1: OnLinkClickEvent::OnLinkClickEvent(nsWebShell* aHandler,
    1:                                    nsIContent *aContent,
    1:                                    nsIURI* aURI,
    1:                                    const PRUnichar* aTargetSpec,
    1:                                    nsIInputStream* aPostDataStream,
    1:                                    nsIInputStream* aHeadersDataStream)
    1:   : mHandler(aHandler)
    1:   , mURI(aURI)
    1:   , mTargetSpec(aTargetSpec)
    1:   , mPostDataStream(aPostDataStream)
    1:   , mHeadersDataStream(aHeadersDataStream)
    1:   , mContent(aContent)
    1: {
    1:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mHandler->mScriptGlobal));
    1: 
    1:   mPopupState = window->GetPopupControlState();
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::OnLinkClick(nsIContent* aContent,
    1:                         nsIURI* aURI,
    1:                         const PRUnichar* aTargetSpec,
    1:                         nsIInputStream* aPostDataStream,
    1:                         nsIInputStream* aHeadersDataStream)
    1: {
    1:   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
 2400: 
10676:   if (!IsOKToLoadURI(aURI)) {
 2400:     return NS_OK;
 2400:   }
 2400: 
 3333:   if (aContent->IsEditable()) {
 2896:     return NS_OK;
 2896:   }
 2896: 
    1:   nsCOMPtr<nsIRunnable> ev =
    1:       new OnLinkClickEvent(this, aContent, aURI, aTargetSpec,
    1:                            aPostDataStream, aHeadersDataStream);
    1:   return NS_DispatchToCurrentThread(ev);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::OnLinkClickSync(nsIContent *aContent,
    1:                             nsIURI* aURI,
    1:                             const PRUnichar* aTargetSpec,
    1:                             nsIInputStream* aPostDataStream,
    1:                             nsIInputStream* aHeadersDataStream,
    1:                             nsIDocShell** aDocShell,
    1:                             nsIRequest** aRequest)
    1: {
    1:   // Initialize the DocShell / Request
    1:   if (aDocShell) {
    1:     *aDocShell = nsnull;
    1:   }
    1:   if (aRequest) {
    1:     *aRequest = nsnull;
    1:   }
    1: 
10676:   if (!IsOKToLoadURI(aURI)) {
 2400:     return NS_OK;
 2400:   }
 2400: 
 3333:   if (aContent->IsEditable()) {
 2896:     return NS_OK;
 2896:   }
 2896: 
    1:   {
    1:     // defer to an external protocol handler if necessary...
    1:     nsCOMPtr<nsIExternalProtocolService> extProtService = do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID);
    1:     if (extProtService) {
    1:       nsCAutoString scheme;
    1:       aURI->GetScheme(scheme);
    1:       if (!scheme.IsEmpty()) {
    1:         // if the URL scheme does not correspond to an exposed protocol, then we
    1:         // need to hand this link click over to the external protocol handler.
    1:         PRBool isExposed;
    1:         nsresult rv = extProtService->IsExposedProtocol(scheme.get(), &isExposed);
    1:         if (NS_SUCCEEDED(rv) && !isExposed) {
 5588:           return extProtService->LoadURI(aURI, this); 
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aContent));
    1:   NS_ENSURE_TRUE(node, NS_ERROR_UNEXPECTED);
    1: 
    1:   PRBool inherit;
    1:   nsresult rv = URIInheritsSecurityContext(aURI, &inherit);
    1:   if (NS_FAILED(rv) || inherit) {
    1:     nsCOMPtr<nsIDocument> sourceDoc = aContent->GetDocument();
    1: 
    1:     if (!sourceDoc) {
    1:       // The source is in a 'zombie' document, or not part of a
    1:       // document any more. Don't let it perform loads in this docshell.
    1:       // XXXbz why only for the inherit case?
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     GetPresShell(getter_AddRefs(presShell));
    1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:     if (presShell->GetDocument() != sourceDoc) {
    1:       // The source is not in the current document, don't let it load anything
    1:       // that would inherit the principals of the current document.
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   // Get the owner document of the link that was clicked, this will be
    1:   // the document that the link is in, or the last document that the
    1:   // link was in. From that document, we'll get the URI to use as the
    1:   // referer, since the current URI in this webshell/docshell may be a
    1:   // new document that we're in the process of loading.
    1:   nsCOMPtr<nsIDOMDocument> refererOwnerDoc;
    1:   node->GetOwnerDocument(getter_AddRefs(refererOwnerDoc));
    1: 
    1:   nsCOMPtr<nsIDocument> refererDoc(do_QueryInterface(refererOwnerDoc));
    1:   NS_ENSURE_TRUE(refererDoc, NS_ERROR_UNEXPECTED);
    1: 
 3468:   nsCOMPtr<nsIURI> referer = refererDoc->GetDocumentURI();
    1: 
    1:   // referer could be null here in some odd cases, but that's ok,
    1:   // we'll just load the link w/o sending a referer in those cases.
    1: 
    1:   nsAutoString target(aTargetSpec);
    1: 
    1:   // If this is an anchor element, grab its type property to use as a hint
    1:   nsAutoString typeHint;
    1:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(aContent));
    1:   if (anchor) {
    1:     anchor->GetType(typeHint);
    1:   }
    1:   
    1:   rv = InternalLoad(aURI,               // New URI
    1:                     referer,            // Referer URI
    1:                     nsnull,             // No onwer
    1:                     INTERNAL_LOAD_FLAGS_INHERIT_OWNER, // Inherit owner from document
    1:                     target.get(),       // Window target
    1:                     NS_LossyConvertUTF16toASCII(typeHint).get(),
    1:                     aPostDataStream,    // Post data stream
    1:                     aHeadersDataStream, // Headers stream
    1:                     LOAD_LINK,          // Load type
    1:                     nsnull,             // No SHEntry
    1:                     PR_TRUE,            // first party site
    1:                     aDocShell,          // DocShell out-param
    1:                     aRequest);          // Request out-param
    1:   if (NS_SUCCEEDED(rv)) {
    1:     DispatchPings(aContent, referer);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::OnOverLink(nsIContent* aContent,
    1:                        nsIURI* aURI,
    1:                        const PRUnichar* aTargetSpec)
    1: {
 3333:   if (aContent->IsEditable()) {
 2896:     return NS_OK;
 2896:   }
 2896: 
    1:   nsCOMPtr<nsIWebBrowserChrome2> browserChrome2 = do_GetInterface(mTreeOwner);
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:   if (!browserChrome2) {
    1:     browserChrome = do_GetInterface(mTreeOwner);
    1:     if (!browserChrome)
    1:       return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsITextToSubURI> textToSubURI =
    1:       do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // use url origin charset to unescape the URL
    1:   nsCAutoString charset;
    1:   rv = aURI->GetOriginCharset(charset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCAutoString spec;
    1:   rv = aURI->GetSpec(spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString uStr;
    1:   rv = textToSubURI->UnEscapeURIForUI(charset, spec, uStr);    
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (browserChrome2) {
    1:     nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aContent);
    1:     rv = browserChrome2->SetStatusWithContext(nsIWebBrowserChrome::STATUS_LINK,
    1:                                               uStr, element);
    1:   } else {
    1:     rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_LINK, uStr.get());
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::OnLeaveLink()
    1: {
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(mTreeOwner));
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   if (browserChrome)  {
    1:       rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_LINK,
    1:                                     EmptyString().get());
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::GetLinkState(nsIURI* aLinkURI, nsLinkState& aState)
    1: {
    1:   if (!aLinkURI) {
    1:     // No uri means not a link
    1:     aState = eLinkState_NotLink;
    1:     return NS_OK;
    1:   }
    1:     
    1:   aState = eLinkState_Unvisited;
    1: 
    1:   // no history, leave state unchanged
    1:   if (!mGlobalHistory)
    1:     return NS_OK;
    1: 
    1:   PRBool isVisited;
    1:   NS_ENSURE_SUCCESS(mGlobalHistory->IsVisited(aLinkURI, &isVisited),
    1:                     NS_ERROR_FAILURE);
    1:   if (isVisited)
    1:     aState = eLinkState_Visited;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: nsresult nsWebShell::EndPageLoad(nsIWebProgress *aProgress,
    1:                                  nsIChannel* channel,
    1:                                  nsresult aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if(!channel)
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   nsCOMPtr<nsIURI> url;
    1:   rv = channel->GetURI(getter_AddRefs(url));
    1:   if (NS_FAILED(rv)) return rv;
    1:   
    1:   // clean up reload state for meta charset
    1:   if(eCharsetReloadRequested == mCharsetReloadState)
    1:     mCharsetReloadState = eCharsetReloadStopOrigional;
    1:   else 
    1:     mCharsetReloadState = eCharsetReloadInit;
    1: 
    1:   // Save a pointer to the currently-loading history entry.
    1:   // nsDocShell::EndPageLoad will clear mLSHE, but we may need this history
    1:   // entry further down in this method.
    1:   nsCOMPtr<nsISHEntry> loadingSHE = mLSHE;
    1:   
    1:   //
    1:   // one of many safeguards that prevent death and destruction if
    1:   // someone is so very very rude as to bring this window down
    1:   // during this load handler.
    1:   //
    1:   nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
    1:   nsDocShell::EndPageLoad(aProgress, channel, aStatus);
    1: 
    1:   // Test if this is the top frame or a subframe
    1:   PRBool isTopFrame = PR_TRUE;
    1:   nsCOMPtr<nsIDocShellTreeItem> targetParentTreeItem;
    1:   rv = GetSameTypeParent(getter_AddRefs(targetParentTreeItem));
    1:   if (NS_SUCCEEDED(rv) && targetParentTreeItem) 
    1:   {
    1:     isTopFrame = PR_FALSE;
    1:   }
    1: 
    1:   //
    1:   // If the page load failed, then deal with the error condition...
    1:   // Errors are handled as follows:
    1:   //   1. Check to see if it's a file not found error or bad content
    1:   //      encoding error.
    1:   //   2. Send the URI to a keyword server (if enabled)
    1:   //   3. If the error was DNS failure, then add www and .com to the URI
    1:   //      (if appropriate).
    1:   //   4. Throw an error dialog box...
    1:   //
    1: 
    1:   if (url && NS_FAILED(aStatus))
    1:   {
    1:     if (aStatus == NS_ERROR_FILE_NOT_FOUND ||
    1:         aStatus == NS_ERROR_INVALID_CONTENT_ENCODING)
    1:     {
    1:       DisplayLoadError(aStatus, url, nsnull, channel);
    1:       return NS_OK;
    1:     }
    1: 
    1:     if (sURIFixup)
    1:     {
    1:       //
    1:       // Try and make an alternative URI from the old one
    1:       //
    1:       nsCOMPtr<nsIURI> newURI;
    1: 
    1:       nsCAutoString oldSpec;
    1:       url->GetSpec(oldSpec);
    1:       
    1:       //
    1:       // First try keyword fixup
    1:       //
    1:       if (aStatus == NS_ERROR_UNKNOWN_HOST && mAllowKeywordFixup)
    1:       {
    1:         PRBool keywordsEnabled = PR_FALSE;
    1: 
    1:         if (mPrefs && NS_FAILED(mPrefs->GetBoolPref("keyword.enabled", &keywordsEnabled)))
    1:             keywordsEnabled = PR_FALSE;
    1: 
    1:         nsCAutoString host;
    1:         url->GetHost(host);
    1: 
    1:         nsCAutoString scheme;
    1:         url->GetScheme(scheme);
    1: 
    1:         PRInt32 dotLoc = host.FindChar('.');
    1: 
    1:         // we should only perform a keyword search under the following conditions:
    1:         // (0) Pref keyword.enabled is true
    1:         // (1) the url scheme is http (or https)
    1:         // (2) the url does not have a protocol scheme
    1:         // If we don't enforce such a policy, then we end up doing keyword searchs on urls
    1:         // we don't intend like imap, file, mailbox, etc. This could lead to a security
    1:         // problem where we send data to the keyword server that we shouldn't be. 
    1:         // Someone needs to clean up keywords in general so we can determine on a per url basis
    1:         // if we want keywords enabled...this is just a bandaid...
    1:         if (keywordsEnabled && !scheme.IsEmpty() &&
    1:            (scheme.Find("http") != 0)) {
    1:             keywordsEnabled = PR_FALSE;
    1:         }
    1: 
    1:         if(keywordsEnabled && (kNotFound == dotLoc)) {
    1:           // only send non-qualified hosts to the keyword server
    1:           //
    1:           // If this string was passed through nsStandardURL by chance, then it
    1:           // may have been converted from UTF-8 to ACE, which would result in a
    1:           // completely bogus keyword query.  Here we try to recover the
    1:           // original Unicode value, but this is not 100% correct since the
    1:           // value may have been normalized per the IDN normalization rules.
    1:           //
    1:           // Since we don't have access to the exact original string that was
    1:           // entered by the user, this will just have to do.
    1:           //
    1:           PRBool isACE;
    1:           nsCAutoString utf8Host;
    1:           nsCOMPtr<nsIIDNService> idnSrv =
    1:               do_GetService(NS_IDNSERVICE_CONTRACTID);
    1:           if (idnSrv &&
    1:               NS_SUCCEEDED(idnSrv->IsACE(host, &isACE)) && isACE &&
    1:               NS_SUCCEEDED(idnSrv->ConvertACEtoUTF8(host, utf8Host)))
    1:             sURIFixup->KeywordToURI(utf8Host, getter_AddRefs(newURI));
    1:           else
    1:             sURIFixup->KeywordToURI(host, getter_AddRefs(newURI));
    1:         } // end keywordsEnabled
    1:       }
    1: 
    1:       //
    1:       // Now try change the address, e.g. turn http://foo into http://www.foo.com
    1:       //
    1:       if (aStatus == NS_ERROR_UNKNOWN_HOST ||
    1:           aStatus == NS_ERROR_NET_RESET)
    1:       {
    1:         PRBool doCreateAlternate = PR_TRUE;
    1:         
    1:         // Skip fixup for anything except a normal document load operation on
    1:         // the topframe.
    1:         
    1:         if (mLoadType != LOAD_NORMAL || !isTopFrame)
    1:         {
    1:           doCreateAlternate = PR_FALSE;
    1:         }
    1:         else
    1:         {
    1:           // Test if keyword lookup produced a new URI or not
    1:           if (newURI)
    1:           {
    1:             PRBool sameURI = PR_FALSE;
    1:             url->Equals(newURI, &sameURI);
    1:             if (!sameURI)
    1:             {
    1:               // Keyword lookup made a new URI so no need to try an
    1:               // alternate one.
    1:               doCreateAlternate = PR_FALSE;
    1:             }
    1:           }
    1:         }
    1:         if (doCreateAlternate)
    1:         {
    1:           newURI = nsnull;
    1:           sURIFixup->CreateFixupURI(oldSpec,
    1:               nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI, getter_AddRefs(newURI));
    1:         }
    1:       }
    1: 
    1:       //
    1:       // Did we make a new URI that is different to the old one? If so load it.
    1:       //
    1:       if (newURI)
    1:       {
    1:         // Make sure the new URI is different from the old one, otherwise
    1:         // there's little point trying to load it again.
    1:         PRBool sameURI = PR_FALSE;
    1:         url->Equals(newURI, &sameURI);
    1:         if (!sameURI)
    1:         {
    1:           nsCAutoString newSpec;
    1:           newURI->GetSpec(newSpec);
    1:           NS_ConvertUTF8toUTF16 newSpecW(newSpec);
    1: 
    1:           return LoadURI(newSpecW.get(),      // URI string
    1:                          LOAD_FLAGS_NONE, // Load flags
    1:                          nsnull,          // Referring URI
    1:                          nsnull,          // Post data stream
    1:                          nsnull);         // Headers stream
    1:         }
    1:       }
    1:     }
    1: 
    1:     //
    1:     // Well, fixup didn't work :-(
    1:     // It is time to throw an error dialog box, and be done with it...
    1:     //
    1: 
    1:     // Errors to be shown only on top-level frames
    1:     if ((aStatus == NS_ERROR_UNKNOWN_HOST || 
    1:          aStatus == NS_ERROR_CONNECTION_REFUSED ||
    1:          aStatus == NS_ERROR_UNKNOWN_PROXY_HOST || 
    1:          aStatus == NS_ERROR_PROXY_CONNECTION_REFUSED) &&
    1:             (isTopFrame || mUseErrorPages)) {
    1:       DisplayLoadError(aStatus, url, nsnull, channel);
    1:     }
    1:     // Errors to be shown for any frame
    1:     else if (aStatus == NS_ERROR_NET_TIMEOUT ||
    1:              aStatus == NS_ERROR_REDIRECT_LOOP ||
    1:              aStatus == NS_ERROR_UNKNOWN_SOCKET_TYPE ||
    1:              aStatus == NS_ERROR_NET_INTERRUPT ||
    1:              aStatus == NS_ERROR_NET_RESET ||
 5528:              aStatus == NS_ERROR_MALWARE_URI ||
 7236:              aStatus == NS_ERROR_PHISHING_URI ||
 8363:              aStatus == NS_ERROR_UNSAFE_CONTENT_TYPE ||
    1:              NS_ERROR_GET_MODULE(aStatus) == NS_ERROR_MODULE_SECURITY) {
    1:       DisplayLoadError(aStatus, url, nsnull, channel);
    1:     }
    1:     else if (aStatus == NS_ERROR_DOCUMENT_NOT_CACHED) {
    1:       /* A document that was requested to be fetched *only* from
    1:        * the cache is not in cache. May be this is one of those 
    1:        * postdata results. Throw a  dialog to the user,
    1:        * saying that the page has expired from cache and ask if 
    1:        * they wish to refetch the page from the net. Do this only
    1:        * if the request is a form post.
    1:        */
    1:       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:       nsCAutoString method;
    1:       if (httpChannel)
    1:         httpChannel->GetRequestMethod(method);
    1:       if (method.Equals("POST") && !NS_IsOffline()) {
    1:         PRBool repost;
    1:         rv = ConfirmRepost(&repost);
    1:         if (NS_FAILED(rv)) return rv;
    1:         // If the user pressed cancel in the dialog, return. Don't try to load
    1:         // the page without the post data.
    1:         if (!repost)
    1:           return NS_OK;
    1: 
    1:         // The user wants to repost the data to the server.
    1:         // If the page was loaded due to a back/forward/go
    1:         // operation, update the session history index.
    1:         // This is similar to the updating done in
    1:         // nsDocShell::OnNewURI() for regular pages
    1:         nsCOMPtr<nsISHistory> rootSH=mSessionHistory;
    1:         if (!mSessionHistory) {
    1:           nsCOMPtr<nsIDocShellTreeItem> root;
    1:           //Get the root docshell
    1:           GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:           if (root) {
    1:             // QI root to nsIWebNavigation
    1:             nsCOMPtr<nsIWebNavigation> rootAsWebnav(do_QueryInterface(root));
    1:             if (rootAsWebnav) {
    1:             // Get the handle to SH from the root docshell
    1:             rootAsWebnav->GetSessionHistory(getter_AddRefs(rootSH));
    1:             }
    1:           }
    1:         }  // mSessionHistory
    1: 
    1:         if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
    1:           nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
    1:           if (shInternal) {
19870:             rootSH->GetIndex(&mPreviousTransIndex);
    1:             shInternal->UpdateIndex();
19870:             rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:             printf("Previous index: %d, Loaded index: %d\n\n",
19870:                   mPreviousTransIndex, mLoadedTransIndex);
19870: #endif
    1:           }
    1:         }
    1: 
    1:         // Make it look like we really did honestly finish loading the
    1:         // history page we were loading, since the "reload" load we're
    1:         // about to kick off will reload our current history entry.  This
    1:         // is a bit of a hack, and if the force-load fails I think we'll
    1:         // end up being confused about what page we're on... but we would
    1:         // anyway, since we've updated the session history index above.
    1:         SetHistoryEntry(&mOSHE, loadingSHE);
    1: 
    1:         // The user does want to repost the data to the server.
    1:         // Initiate a new load again.
    1: 
    1:         // Get the postdata if any from the channel.
    1:         nsCOMPtr<nsIInputStream> inputStream;
    1:         nsCOMPtr<nsIURI> referrer;
    1:         if (channel) {
    1:           nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1: 
    1:           if(httpChannel) {
    1:             httpChannel->GetReferrer(getter_AddRefs(referrer));
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(channel));
    1:             if (uploadChannel) {
    1:               uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
    1:             }
    1:           }
    1:         }
    1:         nsCOMPtr<nsISeekableStream> postDataSeekable(do_QueryInterface(inputStream));
    1:         if (postDataSeekable)
    1:         {
    1:           postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1:         }
    1:         InternalLoad(url,                               // URI
    1:                     referrer,                          // Referring URI
    1:                     nsnull,                            // Owner
    1:                     INTERNAL_LOAD_FLAGS_INHERIT_OWNER, // Inherit owner
    1:                     nsnull,                            // No window target
    1:                     nsnull,                            // No type hint
    1:                     inputStream,                       // Post data stream
    1:                     nsnull,                            // No headers stream
    1:                     LOAD_RELOAD_BYPASS_PROXY_AND_CACHE,// Load type
    1:                     nsnull,                            // No SHEntry
    1:                     PR_TRUE,                           // first party site
    1:                     nsnull,                            // No nsIDocShell
    1:                     nsnull);                           // No nsIRequest
    1:       }
    1:       else {
    1:         DisplayLoadError(aStatus, url, nsnull, channel);
    1:       }
    1:     }
    1:   } // if we have a host
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //
    1: // Routines for selection and clipboard
    1: //
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: nsresult
    1: nsWebShell::GetControllerForCommand ( const char * inCommand, nsIController** outController )
    1: {
    1:   NS_ENSURE_ARG_POINTER(outController);
    1:   *outController = nsnull;
    1:   
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   
    1:   nsCOMPtr<nsPIDOMWindow> window ( do_QueryInterface(mScriptGlobal) );
    1:   if ( window ) {
    1:     nsIFocusController *focusController = window->GetRootFocusController();
    1:     if ( focusController )
    1:       rv = focusController->GetControllerForCommand ( inCommand, outController );
    1:   } // if window
    1: 
    1:   return rv;
    1:   
    1: } // GetControllerForCommand
    1: 
    1: 
    1: nsresult
    1: nsWebShell::IsCommandEnabled ( const char * inCommand, PRBool* outEnabled )
    1: {
    1:   NS_ENSURE_ARG_POINTER(outEnabled);
    1:   *outEnabled = PR_FALSE;
    1: 
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   
    1:   nsCOMPtr<nsIController> controller;
    1:   rv = GetControllerForCommand ( inCommand, getter_AddRefs(controller) );
    1:   if ( controller )
    1:     rv = controller->IsCommandEnabled(inCommand, outEnabled);
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsWebShell::DoCommand ( const char * inCommand )
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   
    1:   nsCOMPtr<nsIController> controller;
    1:   rv = GetControllerForCommand ( inCommand, getter_AddRefs(controller) );
    1:   if ( controller )
    1:     rv = controller->DoCommand(inCommand);
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CanCutSelection(PRBool* aResult)
    1: {
    1:   return IsCommandEnabled ( "cmd_cut", aResult );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CanCopySelection(PRBool* aResult)
    1: {
    1:   return IsCommandEnabled ( "cmd_copy", aResult );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CanCopyLinkLocation(PRBool* aResult)
    1: {
    1:   return IsCommandEnabled ( "cmd_copyLink", aResult );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CanCopyImageLocation(PRBool* aResult)
    1: {
    1:   return IsCommandEnabled ( "cmd_copyImageLocation",
    1:                             aResult );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CanCopyImageContents(PRBool* aResult)
    1: {
    1:   return IsCommandEnabled ( "cmd_copyImageContents",
    1:                             aResult );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CanPaste(PRBool* aResult)
    1: {
    1:   return IsCommandEnabled ( "cmd_paste", aResult );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CutSelection(void)
    1: {
    1:   return DoCommand ( "cmd_cut" );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CopySelection(void)
    1: {
    1:   return DoCommand ( "cmd_copy" );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CopyLinkLocation(void)
    1: {
    1:   return DoCommand ( "cmd_copyLink" );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CopyImageLocation(void)
    1: {
    1:   return DoCommand ( "cmd_copyImageLocation" );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::CopyImageContents(void)
    1: {
    1:   return DoCommand ( "cmd_copyImageContents" );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::Paste(void)
    1: {
    1:   return DoCommand ( "cmd_paste" );
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWebShell::SelectAll(void)
    1: {
    1:   return DoCommand ( "cmd_selectAll" );
    1: }
    1: 
    1: 
    1: //
    1: // SelectNone
    1: //
    1: // Collapses the current selection, insertion point ends up at beginning
    1: // of previous selection.
    1: //
    1: NS_IMETHODIMP
    1: nsWebShell::SelectNone(void)
    1: {
    1:   return DoCommand ( "cmd_selectNone" );
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #endif
    1: 
    1: //*****************************************************************************
    1: // nsWebShell::nsIBaseWindow
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsWebShell::Create()
    1: {
    1:   if (mPrefs) {
    1:     // We've already been created
    1:     return NS_OK;
    1:   }
    1:   
    1:   WEB_TRACE(WEB_TRACE_CALLS,
    1:             ("nsWebShell::Init: this=%p", this));
    1: 
    1:   return nsDocShell::Create();
    1: }
    1: 
    1: #ifdef DEBUG
    1: unsigned long nsWebShell::gNumberOfWebShells = 0;
    1: #endif
