    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/I
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* interface for all rendering objects */
    1: 
    1: #ifndef nsIFrame_h___
    1: #define nsIFrame_h___
    1: 
    1: /* nsIFrame is in the process of being deCOMtaminated, i.e., this file is eventually
    1:    going to be eliminated, and all callers will use nsFrame instead.  At the moment
    1:    we're midway through this process, so you will see inlined functions and member
    1:    variables in this file.  -dwh */
    1: 
    1: #include <stdio.h>
23554: #include "nsQueryFrame.h"
    1: #include "nsEvent.h"
    1: #include "nsStyleStruct.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIContent.h"
    1: #include "nsHTMLReflowMetrics.h"
19214: #include "gfxMatrix.h"
    1: 
    1: /**
    1:  * New rules of reflow:
    1:  * 1. you get a WillReflow() followed by a Reflow() followed by a DidReflow() in order
    1:  *    (no separate pass over the tree)
    1:  * 2. it's the parent frame's responsibility to size/position the child's view (not
    1:  *    the child frame's responsibility as it is today) during reflow (and before
    1:  *    sending the DidReflow() notification)
    1:  * 3. positioning of child frames (and their views) is done on the way down the tree,
    1:  *    and sizing of child frames (and their views) on the way back up
    1:  * 4. if you move a frame (outside of the reflow process, or after reflowing it),
    1:  *    then you must make sure that its view (or its child frame's views) are re-positioned
    1:  *    as well. It's reasonable to not position the view until after all reflowing the
    1:  *    entire line, for example, but the frame should still be positioned and sized (and
    1:  *    the view sized) during the reflow (i.e., before sending the DidReflow() notification)
    1:  * 5. the view system handles moving of widgets, i.e., it's not our problem
    1:  */
    1: 
    1: struct nsHTMLReflowState;
    1: class nsHTMLReflowCommand;
    1: 
    1: class nsIAtom;
    1: class nsPresContext;
    1: class nsIPresShell;
    1: class nsIRenderingContext;
    1: class nsIView;
    1: class nsIWidget;
    1: class nsIDOMRange;
    1: class nsISelectionController;
    1: class nsBoxLayoutState;
    1: class nsIBoxLayout;
21112: class nsILineIterator;
    1: #ifdef ACCESSIBILITY
    1: class nsIAccessible;
    1: #endif
    1: class nsDisplayListBuilder;
    1: class nsDisplayListSet;
    1: class nsDisplayList;
 4261: class gfxSkipChars;
 4261: class gfxSkipCharsIterator;
 6862: class gfxContext;
 6029: class nsLineList_iterator;
    1: 
    1: struct nsPeekOffsetStruct;
    1: struct nsPoint;
    1: struct nsRect;
    1: struct nsSize;
    1: struct nsMargin;
    1: 
    1: typedef class nsIFrame nsIBox;
    1: 
    1: // IID for the nsIFrame interface
20840: // 7b437d20-a34e-11dd-ad8b-0800200c9a66
    1: #define NS_IFRAME_IID \
20840:   { 0x7b437d20, 0xa34e, 0x11dd, \
20840:     { 0xad, 0x8b, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 } }
    1: 
    1: /**
    1:  * Indication of how the frame can be split. This is used when doing runaround
    1:  * of floats, and when pulling up child frames from a next-in-flow.
    1:  *
    1:  * The choices are splittable, not splittable at all, and splittable in
    1:  * a non-rectangular fashion. This last type only applies to block-level
    1:  * elements, and indicates whether splitting can be used when doing runaround.
    1:  * If you can split across page boundaries, but you expect each continuing
    1:  * frame to be the same width then return frSplittable and not
    1:  * frSplittableNonRectangular.
    1:  *
    1:  * @see #GetSplittableType()
    1:  */
    1: typedef PRUint32 nsSplittableType;
    1: 
    1: #define NS_FRAME_NOT_SPLITTABLE             0   // Note: not a bit!
    1: #define NS_FRAME_SPLITTABLE                 0x1
    1: #define NS_FRAME_SPLITTABLE_NON_RECTANGULAR 0x3
    1: 
    1: #define NS_FRAME_IS_SPLITTABLE(type)\
    1:   (0 != ((type) & NS_FRAME_SPLITTABLE))
    1: 
    1: #define NS_FRAME_IS_NOT_SPLITTABLE(type)\
    1:   (0 == ((type) & NS_FRAME_SPLITTABLE))
    1: 
    1: #define NS_INTRINSIC_WIDTH_UNKNOWN nscoord_MIN
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * Frame state bits. Any bits not listed here are reserved for future
    1:  * extensions, but must be stored by the frames.
    1:  */
    1: typedef PRUint32 nsFrameState;
    1: 
 2596: enum {
 2596:   NS_FRAME_IN_REFLOW =                          0x00000001,
 2596: 
    1:   // This is only set during painting
 2596:   NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO =    0x00000001,
    1: 
    1:   // This bit is set when a frame is created. After it has been reflowed
    1:   // once (during the DidReflow with a finished state) the bit is
    1:   // cleared.
 2596:   NS_FRAME_FIRST_REFLOW =                       0x00000002,
    1: 
    1:   // For a continuation frame, if this bit is set, then this a "fluid" 
    1:   // continuation, i.e., across a line boundary. Otherwise it's a "hard"
    1:   // continuation, e.g. a bidi continuation.
 2596:   NS_FRAME_IS_FLUID_CONTINUATION =              0x00000004,
    1: 
26950: /*
26950:  * This bit is obsolete, replaced by HasOverflowRect().
26950:  * The definition is left here as a placeholder for now, to remind us
26950:  * that this bit is now free to allocate for other purposes.
26950:  * // This bit is set when the frame's overflow rect is
26950:  * // different from its border rect (i.e. GetOverflowRect() != GetRect())
26950:  * NS_FRAME_OUTSIDE_CHILDREN =                   0x00000008,
26950:  */
    1: 
    1:   // If this bit is set, then a reference to the frame is being held
    1:   // elsewhere.  The frame may want to send a notification when it is
    1:   // destroyed to allow these references to be cleared.
 2596:   NS_FRAME_EXTERNAL_REFERENCE =                 0x00000010,
    1: 
    1:   // If this bit is set, this frame or one of its descendants has a
    1:   // percentage height that depends on an ancestor of this frame.
    1:   // (Or it did at one point in the past, since we don't necessarily clear
    1:   // the bit when it's no longer needed; it's an optimization.)
 2596:   NS_FRAME_CONTAINS_RELATIVE_HEIGHT =           0x00000020,
    1: 
    1:   // If this bit is set, then the frame corresponds to generated content
 3793:   // Such frames store an nsCOMArray<nsIContent> of their generated content
 3793:   // in the nsGkAtoms::generatedContent frame property, except for continuation
 3793:   // frames.
 2596:   NS_FRAME_GENERATED_CONTENT =                  0x00000040,
    1: 
 4006:   // If this bit is set the frame is a continuation that is holding overflow,
 4006:   // i.e. it is a next-in-flow created to hold overflow after the box's
 4006:   // height has ended. This means the frame should be a) at the top of the
 4006:   // page and b) invisible: no borders, zero height, ignored in margin
 4006:   // collapsing, etc. See nsContainerFrame.h
 4006:   NS_FRAME_IS_OVERFLOW_CONTAINER =              0x00000080,
 4006: 
    1:   // If this bit is set, then the frame has been moved out of the flow,
    1:   // e.g., it is absolutely positioned or floated
 2596:   NS_FRAME_OUT_OF_FLOW =                        0x00000100,
    1: 
    1:   // If this bit is set, then the frame reflects content that may be selected
 2596:   NS_FRAME_SELECTED_CONTENT =                   0x00000200,
    1: 
    1:   // If this bit is set, then the frame is dirty and needs to be reflowed.
    1:   // This bit is set when the frame is first created.
    1:   // This bit is cleared by DidReflow after the required call to Reflow has
    1:   // finished.
 1158:   // Do not set this bit yourself if you plan to pass the frame to
 1158:   // nsIPresShell::FrameNeedsReflow.  Pass the right arguments instead.
 2596:   NS_FRAME_IS_DIRTY =                           0x00000400,
    1: 
 3724:   // If this bit is set then the frame is too deep in the frame tree, and
 3724:   // we'll stop updating it and its children, to prevent stack overflow
 3724:   // and the like.
 3724:   NS_FRAME_TOO_DEEP_IN_FRAME_TREE =             0x00000800,
    1: 
    1:   // If this bit is set, either:
    1:   //  1. the frame has children that have either NS_FRAME_IS_DIRTY or
    1:   //     NS_FRAME_HAS_DIRTY_CHILDREN, or
    1:   //  2. the frame has had descendants removed.
    1:   // It means that Reflow needs to be called, but that Reflow will not
    1:   // do as much work as it would if NS_FRAME_IS_DIRTY were set.
    1:   // This bit is cleared by DidReflow after the required call to Reflow has
    1:   // finished.
 1158:   // Do not set this bit yourself if you plan to pass the frame to
 1158:   // nsIPresShell::FrameNeedsReflow.  Pass the right arguments instead.
 2596:   NS_FRAME_HAS_DIRTY_CHILDREN =                 0x00001000,
    1: 
    1:   // If this bit is set, the frame has an associated view
 2596:   NS_FRAME_HAS_VIEW =                           0x00002000,
    1: 
    1:   // If this bit is set, the frame was created from anonymous content.
 2596:   NS_FRAME_INDEPENDENT_SELECTION =              0x00004000,
    1: 
    1:   // If this bit is set, the frame is "special" (lame term, I know),
    1:   // which means that it is part of the mangled frame hierarchy that
    1:   // results when an inline has been split because of a nested block.
 2596:   NS_FRAME_IS_SPECIAL =                         0x00008000,
    1: 
19214:   // If this bit is set, the frame may have a transform that it applies
19214:   // to its coordinate system (e.g. CSS transform, SVG foreignObject).
19214:   // This is used primarily in GetTransformMatrix to optimize for the
19214:   // common case.
19948:   // ALSO, if this bit is set, the frame's first-continuation may
19948:   // have an associated nsSVGRenderingObserverList.
19948:   NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS = 0x00010000,
    1: 
    1: #ifdef IBMBIDI
    1:   // If this bit is set, the frame itself is a bidi continuation,
    1:   // or is incomplete (its next sibling is a bidi continuation)
 2596:   NS_FRAME_IS_BIDI =                            0x00020000,
    1: #endif
    1: 
    1:   // If this bit is set the frame has descendant with a view
 2596:   NS_FRAME_HAS_CHILD_WITH_VIEW =                0x00040000,
    1: 
    1:   // If this bit is set, then reflow may be dispatched from the current
    1:   // frame instead of the root frame.
 2596:   NS_FRAME_REFLOW_ROOT =                        0x00080000,
    1: 
    1:   // The lower 20 bits of the frame state word are reserved by this API.
 2596:   NS_FRAME_RESERVED =                           0x000FFFFF,
    1: 
    1:   // The upper 12 bits of the frame state word are reserved for frame
    1:   // implementations.
 2596:   NS_FRAME_IMPL_RESERVED =                      0xFFF00000,
    1: 
    1:   // Box layout bits
 2596:   NS_STATE_IS_HORIZONTAL =                      0x00400000,
 2599:   NS_STATE_IS_DIRECTION_NORMAL =                0x80000000
 2596: };
    1: 
 1158: // Helper macros
 1158: #define NS_SUBTREE_DIRTY(_frame)  \
 1158:   (((_frame)->GetStateBits() &      \
 1158:     (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN)) != 0)
 1158: 
    1: //----------------------------------------------------------------------
    1: 
    1: enum nsSelectionAmount {
    1:   eSelectCharacter = 0,
    1:   eSelectWord      = 1,
    1:   eSelectLine      = 2,  //previous drawn line in flow.
    1:   eSelectBeginLine = 3,
    1:   eSelectEndLine   = 4,
    1:   eSelectNoAmount  = 5,   //just bounce back current offset.
    1:   eSelectParagraph = 6    //select a "paragraph"
    1: };
    1: 
    1: enum nsDirection {
    1:   eDirNext    = 0,
    1:   eDirPrevious= 1
    1: };
    1: 
    1: enum nsSpread {
    1:   eSpreadNone   = 0,
    1:   eSpreadAcross = 1,
    1:   eSpreadDown   = 2
    1: };
    1: 
    1: // Carried out margin flags
    1: #define NS_CARRIED_TOP_MARGIN_IS_AUTO    0x1
    1: #define NS_CARRIED_BOTTOM_MARGIN_IS_AUTO 0x2
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
 4006:  * Reflow status returned by the reflow methods. There are three
 4006:  * completion statuses, represented by two bit flags.
 4006:  *
 4006:  * NS_FRAME_COMPLETE means the frame is fully complete.
    1:  *
    1:  * NS_FRAME_NOT_COMPLETE bit flag means the frame does not map all its
    1:  * content, and that the parent frame should create a continuing frame.
    1:  * If this bit isn't set it means the frame does map all its content.
 4006:  * This bit is mutually exclusive with NS_FRAME_OVERFLOW_INCOMPLETE.
 4006:  *
 4006:  * NS_FRAME_OVERFLOW_INCOMPLETE bit flag means that the frame has
 4006:  * overflow that is not complete, but its own box is complete.
 4006:  * (This happens when content overflows a fixed-height box.)
 4006:  * The reflower should place and size the frame and continue its reflow,
 4006:  * but needs to create an overflow container as a continuation for this
 4006:  * frame. See nsContainerFrame.h for more information.
 4006:  * This bit is mutually exclusive with NS_FRAME_NOT_COMPLETE.
 4006:  * 
15183:  * Please use the SET macro for handling
 4006:  * NS_FRAME_NOT_COMPLETE and NS_FRAME_OVERFLOW_INCOMPLETE.
    1:  *
    1:  * NS_FRAME_REFLOW_NEXTINFLOW bit flag means that the next-in-flow is
    1:  * dirty, and also needs to be reflowed. This status only makes sense
    1:  * for a frame that is not complete, i.e. you wouldn't set both
 4006:  * NS_FRAME_COMPLETE and NS_FRAME_REFLOW_NEXTINFLOW.
    1:  *
    1:  * The low 8 bits of the nsReflowStatus are reserved for future extensions;
    1:  * the remaining 24 bits are zero (and available for extensions; however
    1:  * API's that accept/return nsReflowStatus must not receive/return any
    1:  * extension bits).
    1:  *
    1:  * @see #Reflow()
    1:  */
    1: typedef PRUint32 nsReflowStatus;
    1: 
    1: #define NS_FRAME_COMPLETE             0       // Note: not a bit!
    1: #define NS_FRAME_NOT_COMPLETE         0x1
    1: #define NS_FRAME_REFLOW_NEXTINFLOW    0x2
 4006: #define NS_FRAME_OVERFLOW_INCOMPLETE  0x4
    1: 
    1: #define NS_FRAME_IS_COMPLETE(status) \
    1:   (0 == ((status) & NS_FRAME_NOT_COMPLETE))
    1: 
    1: #define NS_FRAME_IS_NOT_COMPLETE(status) \
    1:   (0 != ((status) & NS_FRAME_NOT_COMPLETE))
    1: 
 4006: #define NS_FRAME_OVERFLOW_IS_INCOMPLETE(status) \
 4006:   (0 != ((status) & NS_FRAME_OVERFLOW_INCOMPLETE))
 4006: 
 4006: #define NS_FRAME_IS_FULLY_COMPLETE(status) \
 4006:   (NS_FRAME_IS_COMPLETE(status) && !NS_FRAME_OVERFLOW_IS_INCOMPLETE(status))
 4006: 
 4006: // These macros set or switch incompete statuses without touching th
 4006: // NS_FRAME_REFLOW_NEXTINFLOW bit.
 4006: #define NS_FRAME_SET_INCOMPLETE(status) \
19264:   status = (status & ~NS_FRAME_OVERFLOW_INCOMPLETE) | NS_FRAME_NOT_COMPLETE
 4006: 
 4006: #define NS_FRAME_SET_OVERFLOW_INCOMPLETE(status) \
19264:   status = (status & ~NS_FRAME_NOT_COMPLETE) | NS_FRAME_OVERFLOW_INCOMPLETE
 4006: 
    1: // This macro tests to see if an nsReflowStatus is an error value
    1: // or just a regular return value
    1: #define NS_IS_REFLOW_ERROR(_status) (PRInt32(_status) < 0)
    1: 
    1: /**
    1:  * Extensions to the reflow status bits defined by nsIFrameReflow
    1:  */
    1: 
    1: // This bit is set, when a break is requested. This bit is orthogonal
    1: // to the nsIFrame::nsReflowStatus completion bits.
    1: #define NS_INLINE_BREAK              0x0100
    1: 
    1: // When a break is requested, this bit when set indicates that the
    1: // break should occur after the frame just reflowed; when the bit is
    1: // clear the break should occur before the frame just reflowed.
    1: #define NS_INLINE_BREAK_BEFORE       0x0000
    1: #define NS_INLINE_BREAK_AFTER        0x0200
    1: 
    1: // The type of break requested can be found in these bits.
    1: #define NS_INLINE_BREAK_TYPE_MASK    0xF000
    1: 
16409: // Set when a break was induced by completion of a first-letter
16409: #define NS_INLINE_BREAK_FIRST_LETTER_COMPLETE 0x10000
16409: 
    1: //----------------------------------------
    1: // Macros that use those bits
    1: 
    1: #define NS_INLINE_IS_BREAK(_status) \
    1:   (0 != ((_status) & NS_INLINE_BREAK))
    1: 
    1: #define NS_INLINE_IS_BREAK_AFTER(_status) \
    1:   (0 != ((_status) & NS_INLINE_BREAK_AFTER))
    1: 
    1: #define NS_INLINE_IS_BREAK_BEFORE(_status) \
    1:   (NS_INLINE_BREAK == ((_status) & (NS_INLINE_BREAK|NS_INLINE_BREAK_AFTER)))
    1: 
    1: #define NS_INLINE_GET_BREAK_TYPE(_status) (((_status) >> 12) & 0xF)
    1: 
    1: #define NS_INLINE_MAKE_BREAK_TYPE(_type)  ((_type) << 12)
    1: 
    1: // Construct a line-break-before status. Note that there is no
    1: // completion status for a line-break before because we *know* that
    1: // the frame will be reflowed later and hence it's current completion
    1: // status doesn't matter.
    1: #define NS_INLINE_LINE_BREAK_BEFORE()                                   \
    1:   (NS_INLINE_BREAK | NS_INLINE_BREAK_BEFORE |                           \
    1:    NS_INLINE_MAKE_BREAK_TYPE(NS_STYLE_CLEAR_LINE))
    1: 
    1: // Take a completion status and add to it the desire to have a
    1: // line-break after. For this macro we do need the completion status
    1: // because the user of the status will need to know whether to
    1: // continue the frame or not.
    1: #define NS_INLINE_LINE_BREAK_AFTER(_completionStatus)                   \
    1:   ((_completionStatus) | NS_INLINE_BREAK | NS_INLINE_BREAK_AFTER |      \
    1:    NS_INLINE_MAKE_BREAK_TYPE(NS_STYLE_CLEAR_LINE))
    1: 
    1: // The frame (not counting a continuation) did not fit in the available height and 
    1: // wasn't at the top of a page. If it was at the top of a page, then it is not 
    1: // possible to reflow it again with more height, so we don't set it in that case.
    1: #define NS_FRAME_TRUNCATED  0x0010
    1: #define NS_FRAME_IS_TRUNCATED(status) \
    1:   (0 != ((status) & NS_FRAME_TRUNCATED))
    1: #define NS_FRAME_SET_TRUNCATION(status, aReflowState, aMetrics) \
    1:   aReflowState.SetTruncated(aMetrics, &status);
    1: 
15183: // Merge the incompleteness, truncation and NS_FRAME_REFLOW_NEXTINFLOW
15183: // status from aSecondary into aPrimary.
15183: void NS_MergeReflowStatusInto(nsReflowStatus* aPrimary,
15183:                               nsReflowStatus aSecondary);
15183: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * DidReflow status values.
    1:  */
    1: typedef PRBool nsDidReflowStatus;
    1: 
    1: #define NS_FRAME_REFLOW_NOT_FINISHED PR_FALSE
    1: #define NS_FRAME_REFLOW_FINISHED     PR_TRUE
    1: 
26950: /**
26950:  * The overflow rect may be stored as four 1-byte deltas each strictly
26950:  * LESS THAN 0xff, for the four edges of the rectangle, or the four bytes
26950:  * may be read as a single 32-bit "overflow-rect type" value including
26950:  * at least one 0xff byte as an indicator that the value does NOT
26950:  * represent four deltas.
26950:  * If all four deltas are zero, this means that no overflow rect has
26950:  * actually been set (this is the initial state of newly-created frames).
26950:  */
26950: #define NS_FRAME_OVERFLOW_DELTA_MAX     0xfe // max delta we can store
26950: 
26950: #define NS_FRAME_OVERFLOW_NONE    0x00000000 // there is no overflow rect;
26950:                                              // code relies on this being
26950:                                              // the all-zero value
26950: 
26950: #define NS_FRAME_OVERFLOW_LARGE   0x000000ff // overflow is stored as a
26950:                                              // separate rect property
26950: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * A frame in the layout model. This interface is supported by all frame
    1:  * objects.
    1:  *
    1:  * Frames can have multiple child lists: the default unnamed child list
    1:  * (referred to as the <i>principal</i> child list, and additional named
    1:  * child lists. There is an ordering of frames within a child list, but
    1:  * there is no order defined between frames in different child lists of
    1:  * the same parent frame.
    1:  *
    1:  * Frames are NOT reference counted. Use the Destroy() member function
    1:  * to destroy a frame. The lifetime of the frame hierarchy is bounded by the
    1:  * lifetime of the presentation shell which owns the frames.
    1:  *
    1:  * nsIFrame is a private Gecko interface. If you are not Gecko then you
    1:  * should not use it. If you're not in layout, then you won't be able to
    1:  * link to many of the functions defined here. Too bad.
    1:  *
    1:  * If you're not in layout but you must call functions in here, at least
    1:  * restrict yourself to calling virtual methods, which won't hurt you as badly.
    1:  */
23554: class nsIFrame : public nsQueryFrame
    1: {
    1: public:
23554:   NS_DECLARE_FRAME_ACCESSOR(nsIFrame)
    1: 
  238:   nsPresContext* PresContext() const {
    1:     return GetStyleContext()->GetRuleNode()->GetPresContext();
    1:   }
    1: 
    1:   /**
    1:    * Called to initialize the frame. This is called immediately after creating
    1:    * the frame.
    1:    *
    1:    * If the frame is a continuing frame, then aPrevInFlow indicates the previous
 3707:    * frame (the frame that was split).
    1:    *
    1:    * If you want a view associated with your frame, you should create the view
    1:    * now.
    1:    *
    1:    * @param   aContent the content object associated with the frame
    1:    * @param   aGeometricParent  the geometric parent frame
    1:    * @param   aContentParent  the content parent frame
    1:    * @param   aContext the style context associated with the frame
    1:    * @param   aPrevInFlow the prev-in-flow frame
    1:    */
    1:   NS_IMETHOD  Init(nsIContent*      aContent,
    1:                    nsIFrame*        aParent,
    1:                    nsIFrame*        aPrevInFlow) = 0;
    1: 
    1:   /**
    1:    * Destroys this frame and each of its child frames (recursively calls
    1:    * Destroy() for each child)
    1:    */
    1:   virtual void Destroy() = 0;
    1: 
    1:   /*
    1:    * Notify the frame that it has been removed as the primary frame for its content
    1:    */
    1:   virtual void RemovedAsPrimaryFrame() {}
    1: 
    1:   /**
    1:    * Called to set the initial list of frames. This happens after the frame
    1:    * has been initialized.
    1:    *
    1:    * This is only called once for a given child list, and won't be called
    1:    * at all for child lists with no initial list of frames.
    1:    *
    1:    * @param   aListName the name of the child list. A NULL pointer for the atom
    1:    *            name means the unnamed principal child list
    1:    * @param   aChildList list of child frames. Each of the frames has its
    1:    *            NS_FRAME_IS_DIRTY bit set
    1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
    1:    *            name,
    1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame or if the
    1:    *            initial list of frames has already been set for that child list,
    1:    *          NS_OK otherwise
    1:    * @see     #Init()
    1:    */
    1:   NS_IMETHOD  SetInitialChildList(nsIAtom*        aListName,
    1:                                   nsIFrame*       aChildList) = 0;
    1: 
    1:   /**
    1:    * This method is responsible for appending frames to the frame
    1:    * list.  The implementation should append the frames to the specified
    1:    * child list and then generate a reflow command.
    1:    *
    1:    * @param   aListName the name of the child list. A NULL pointer for the atom
    1:    *            name means the unnamed principal child list
    1:    * @param   aFrameList list of child frames to append. Each of the frames has
    1:    *            its NS_FRAME_IS_DIRTY bit set
    1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
    1:    *            name,
    1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame,
    1:    *          NS_OK otherwise
    1:    */
    1:   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
    1:                           nsIFrame*       aFrameList) = 0;
    1: 
    1:   /**
    1:    * This method is responsible for inserting frames into the frame
    1:    * list.  The implementation should insert the new frames into the specified
    1:    * child list and then generate a reflow command.
    1:    *
    1:    * @param   aListName the name of the child list. A NULL pointer for the atom
    1:    *            name means the unnamed principal child list
    1:    * @param   aPrevFrame the frame to insert frames <b>after</b>
    1:    * @param   aFrameList list of child frames to insert <b>after</b> aPrevFrame.
    1:    *            Each of the frames has its NS_FRAME_IS_DIRTY bit set
    1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
    1:    *            name,
    1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame,
    1:    *          NS_OK otherwise
    1:    */
    1:   NS_IMETHOD InsertFrames(nsIAtom*        aListName,
    1:                           nsIFrame*       aPrevFrame,
    1:                           nsIFrame*       aFrameList) = 0;
    1: 
    1:   /**
    1:    * This method is responsible for removing a frame in the frame
    1:    * list.  The implementation should do something with the removed frame
    1:    * and then generate a reflow command. The implementation is responsible
    1:    * for destroying aOldFrame (the caller mustn't destroy aOldFrame).
    1:    *
    1:    * @param   aListName the name of the child list. A NULL pointer for the atom
    1:    *            name means the unnamed principal child list
    1:    * @param   aOldFrame the frame to remove
    1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
    1:    *            name,
    1:    *          NS_ERROR_FAILURE if the child frame is not in the specified
    1:    *            child list,
    1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame,
    1:    *          NS_OK otherwise
    1:    */
    1:   NS_IMETHOD RemoveFrame(nsIAtom*        aListName,
    1:                          nsIFrame*       aOldFrame) = 0;
    1: 
    1:   /**
    1:    * Get the content object associated with this frame. Does not add a reference.
    1:    */
    1:   nsIContent* GetContent() const { return mContent; }
    1: 
    1:   /**
    1:    * Get the frame that should be the parent for the frames of child elements
12165:    * May return nsnull during reflow
    1:    */
    1:   virtual nsIFrame* GetContentInsertionFrame() { return this; }
    1: 
    1:   /**
    1:    * Get the offsets of the frame. most will be 0,0
    1:    *
    1:    */
    1:   NS_IMETHOD GetOffsets(PRInt32 &start, PRInt32 &end) const = 0;
    1: 
    1:   /**
    1:    * Reset the offsets when splitting frames during Bidi reordering
    1:    *
    1:    */
    1:   virtual void AdjustOffsetsForBidi(PRInt32 aStart, PRInt32 aEnd) {}
    1: 
    1:   /**
    1:    * Get the style context associated with this frame.
    1:    *
    1:    */
    1:   nsStyleContext* GetStyleContext() const { return mStyleContext; }
    1:   void SetStyleContext(nsStyleContext* aContext)
    1:   { 
    1:     if (aContext != mStyleContext) {
20836:       nsStyleContext* oldStyleContext = mStyleContext;
    1:       mStyleContext = aContext;
    1:       if (aContext) {
    1:         aContext->AddRef();
20836:         DidSetStyleContext(oldStyleContext);
    1:       }
20836:       if (oldStyleContext)
20836:         oldStyleContext->Release();
    1:     }
    1:   }
    1:   
    1:   void SetStyleContextWithoutNotification(nsStyleContext* aContext)
    1:   {
    1:     if (aContext != mStyleContext) {
    1:       if (mStyleContext)
    1:         mStyleContext->Release();
    1:       mStyleContext = aContext;
    1:       if (aContext) {
    1:         aContext->AddRef();
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Style post processing hook
20836:   // Attention: the old style context is the one we're forgetting,
20836:   // and hence possibly completely bogus for GetStyle* purposes.
20836:   // Use PeekStyleData instead.
20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext) = 0;
    1: 
    1:   /**
    1:    * Get the style data associated with this frame.  This returns a
    1:    * const style struct pointer that should never be modified.  See
    1:    * |nsIStyleContext::GetStyleData| for more information.
    1:    *
    1:    * The use of the typesafe functions below is preferred to direct use
    1:    * of this function.
    1:    */
10152:   virtual const void* GetStyleDataExternal(nsStyleStructID aSID) const = 0;
    1: 
    1:   /**
    1:    * Define typesafe getter functions for each style struct by
    1:    * preprocessing the list of style structs.  These functions are the
    1:    * preferred way to get style data.  The macro creates functions like:
    1:    *   const nsStyleBorder* GetStyleBorder();
    1:    *   const nsStyleColor* GetStyleColor();
    1:    */
    1: 
    1: #ifdef _IMPL_NS_LAYOUT
    1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
    1:     const nsStyle##name_ * GetStyle##name_ () const {                         \
    1:       NS_ASSERTION(mStyleContext, "No style context found!");                 \
    1:       return mStyleContext->GetStyle##name_ ();                               \
    1:     }
    1: #else
    1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
    1:     const nsStyle##name_ * GetStyle##name_ () const {                         \
 3233:       return static_cast<const nsStyle##name_*>(                              \
    1:                             GetStyleDataExternal(eStyleStruct_##name_));      \
    1:     }
    1: #endif
    1:   #include "nsStyleStructList.h"
    1:   #undef STYLE_STRUCT
    1: 
    1:   /**
    1:    * These methods are to access any additional style contexts that
    1:    * the frame may be holding. These are contexts that are children
    1:    * of the frame's primary context and are NOT used as style contexts
    1:    * for any child frames. These contexts also MUST NOT have any child 
    1:    * contexts whatsoever. If you need to insert style contexts into the
    1:    * style tree, then you should create pseudo element frames to own them
    1:    * The indicies must be consecutive and implementations MUST return an 
    1:    * NS_ERROR_INVALID_ARG if asked for an index that is out of range.
    1:    */
    1:   virtual nsStyleContext* GetAdditionalStyleContext(PRInt32 aIndex) const = 0;
    1: 
    1:   virtual void SetAdditionalStyleContext(PRInt32 aIndex,
    1:                                          nsStyleContext* aStyleContext) = 0;
    1: 
26940:   // returns GetStyleBorder()->mBoxShadow unless this frame is using
26940:   // -moz-appearance and is not chrome
26940:   nsCSSShadowArray* GetEffectiveBoxShadows();
26940: 
    1:   /**
    1:    * Accessor functions for geometric parent
    1:    */
    1:   nsIFrame* GetParent() const { return mParent; }
    1:   NS_IMETHOD SetParent(const nsIFrame* aParent) { mParent = (nsIFrame*)aParent; return NS_OK; }
    1: 
    1:   /**
21841:    * Bounding rect of the frame. The values are in app units, and the origin is
    1:    * relative to the upper-left of the geometric parent. The size includes the
    1:    * content area, borders, and padding.
    1:    *
    1:    * Note: moving or sizing the frame does not affect the view's size or
    1:    * position.
    1:    */
    1:   nsRect GetRect() const { return mRect; }
    1:   nsPoint GetPosition() const { return nsPoint(mRect.x, mRect.y); }
    1:   nsSize GetSize() const { return nsSize(mRect.width, mRect.height); }
26950: 
26950:   /**
26950:    * When we change the size of the frame's border-box rect, we may need to
26950:    * reset the overflow rect if it was previously stored as deltas.
26950:    * (If it is currently a "large" overflow and could be re-packed as deltas,
26950:    * we don't bother as the cost of the allocation has already been paid.)
26950:    */
26950:   void SetRect(const nsRect& aRect) {
26950:     if (HasOverflowRect() && mOverflow.mType != NS_FRAME_OVERFLOW_LARGE) {
26950:       nsRect r = GetOverflowRect();
26950:       mRect = aRect;
26950:       SetOverflowRect(r);
26950:     } else {
26950:       mRect = aRect;
26950:     }
26950:   }
26950:   void SetSize(const nsSize& aSize) {
26950:     if (HasOverflowRect() && mOverflow.mType != NS_FRAME_OVERFLOW_LARGE) {
26950:       nsRect r = GetOverflowRect();
26950:       mRect.SizeTo(aSize);
26950:       SetOverflowRect(r);
26950:     } else {
26950:       mRect.SizeTo(aSize);
26950:     }
26950:   }
    1:   void SetPosition(const nsPoint& aPt) { mRect.MoveTo(aPt); }
    1: 
14460:   /**
14460:    * Return frame's computed offset due to relative positioning
14460:    */
14460:   nsPoint GetRelativeOffset(const nsStyleDisplay* aDisplay = nsnull) const;
14460: 
    1:   virtual nsPoint GetPositionOfChildIgnoringScrolling(nsIFrame* aChild)
    1:   { return aChild->GetPosition(); }
    1:   
    1:   nsPoint GetPositionIgnoringScrolling() {
    1:     return mParent ? mParent->GetPositionOfChildIgnoringScrolling(this)
    1:       : GetPosition();
    1:   }
    1: 
    1:   /**
    1:    * Return the distance between the border edge of the frame and the
    1:    * margin edge of the frame.  Can only be called after Reflow for the
    1:    * frame has at least *started*.
    1:    *
    1:    * This doesn't include any margin collapsing that may have occurred.
12310:    *
12310:    * It also treats 'auto' margins as zero, and treats any margins that
12310:    * should have been turned into 'auto' because of overconstraint as
12310:    * having their original values.
    1:    */
    1:   virtual nsMargin GetUsedMargin() const;
    1: 
    1:   /**
    1:    * Return the distance between the border edge of the frame (which is
    1:    * its rect) and the padding edge of the frame.  Can only be called
    1:    * after Reflow for the frame has at least *started*.
    1:    *
    1:    * Note that this differs from GetStyleBorder()->GetBorder() in that
    1:    * this describes region of the frame's box, and
    1:    * GetStyleBorder()->GetBorder() describes a border.  They differ only
    1:    * for tables, particularly border-collapse tables.
    1:    */
    1:   virtual nsMargin GetUsedBorder() const;
    1: 
    1:   /**
    1:    * Return the distance between the padding edge of the frame and the
    1:    * content edge of the frame.  Can only be called after Reflow for the
    1:    * frame has at least *started*.
    1:    */
    1:   virtual nsMargin GetUsedPadding() const;
    1: 
    1:   nsMargin GetUsedBorderAndPadding() const {
    1:     return GetUsedBorder() + GetUsedPadding();
    1:   }
    1: 
    1:   /**
    1:    * Apply the result of GetSkipSides() on this frame to an nsMargin by
    1:    * setting to zero any sides that are skipped.
    1:    */
    1:   void ApplySkipSides(nsMargin& aMargin) const;
    1: 
    1:   /**
    1:    * Like the frame's rect (see |GetRect|), which is the border rect,
21841:    * other rectangles of the frame, in app units, relative to the parent.
12310:    *
12310:    * Note that GetMarginRect is not meaningful for blocks (anything with
12310:    * 'display:block', whether block frame or not) because of both the
12310:    * collapsing and 'auto' issues with GetUsedMargin (on which it
12310:    * depends).
    1:    */
    1:   nsRect GetMarginRect() const;
    1:   nsRect GetPaddingRect() const;
    1:   nsRect GetContentRect() const;
    1: 
    1:   /**
    1:    * Get the position of the frame's baseline, relative to the top of
    1:    * the frame (its top border edge).  Only valid when Reflow is not
    1:    * needed and when the frame returned nsHTMLReflowMetrics::
    1:    * ASK_FOR_ASCENT as ascent in its reflow metrics.
    1:    */
    1:   virtual nscoord GetBaseline() const = 0;
    1: 
    1:   /**
    1:    * Used to iterate the list of additional child list names. Returns the atom
    1:    * name for the additional child list at the specified 0-based index, or a
    1:    * NULL pointer if there are no more named child lists.
    1:    *
    1:    * Note that the list is only the additional named child lists and does not
    1:    * include the unnamed principal child list.
    1:    */
    1:   virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const = 0;
    1: 
    1:   /**
    1:    * Get the first child frame from the specified child list.
    1:    *
    1:    * @param   aListName the name of the child list. A NULL pointer for the atom
    1:    *            name means the unnamed principal child list
    1:    * @return  the child frame, or NULL if there is no such child
    1:    * @see     #GetAdditionalListName()
    1:    */
    1:   virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const = 0;
    1: 
    1:   /**
    1:    * Child frames are linked together in a singly-linked list
    1:    */
    1:   nsIFrame* GetNextSibling() const { return mNextSibling; }
    1:   void SetNextSibling(nsIFrame* aNextSibling) {
    1:     NS_ASSERTION(this != aNextSibling, "Creating a circular frame list, this is very bad."); 
    1:     mNextSibling = aNextSibling;
    1:   }
    1: 
    1:   /**
    1:    * Builds the display lists for the content represented by this frame
    1:    * and its descendants. The background+borders of this element must
    1:    * be added first, before any other content.
    1:    * 
    1:    * This should only be called by methods in nsFrame. Instead of calling this
    1:    * directly, call either BuildDisplayListForStackingContext or
    1:    * BuildDisplayListForChild.
    1:    * 
    1:    * See nsDisplayList.h for more information about display lists.
    1:    * 
    1:    * @param aDirtyRect content outside this rectangle can be ignored; the
    1:    * rectangle is in frame coordinates
    1:    */
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists) { return NS_OK; }
    1:   /**
    1:    * Displays the caret onto the given display list builder. The caret is
    1:    * painted on top of the rest of the display list items.
    1:    *
    1:    * @param aDirtyRect is the dirty rectangle that we're repainting.
    1:    */
    1:   nsresult DisplayCaret(nsDisplayListBuilder*       aBuilder,
    1:                         const nsRect&               aDirtyRect,
    1:                         const nsDisplayListSet&     aLists);
    1: 
22675:   PRBool IsThemed(nsTransparencyMode* aTransparencyMode = nsnull) {
22675:     return IsThemed(GetStyleDisplay(), aTransparencyMode);
    1:   }
22675:   PRBool IsThemed(const nsStyleDisplay* aDisp,
22675:                   nsTransparencyMode* aTransparencyMode = nsnull) {
    1:     if (!aDisp->mAppearance)
    1:       return PR_FALSE;
  238:     nsPresContext* pc = PresContext();
    1:     nsITheme *theme = pc->GetTheme();
22675:     if(!theme || !theme->ThemeSupportsWidget(pc, this, aDisp->mAppearance))
22675:       return PR_FALSE;
22803:     if (aTransparencyMode) {
22675:       *aTransparencyMode = theme->GetWidgetTransparency(aDisp->mAppearance);
22803:     }
22675:     return PR_TRUE;
    1:   }
    1:   
    1:   /**
    1:    * Builds a display list for the content represented by this frame,
    1:    * treating this frame as the root of a stacking context.
    1:    * @param aDirtyRect content outside this rectangle can be ignored; the
    1:    * rectangle is in frame coordinates
    1:    */
    1:   nsresult BuildDisplayListForStackingContext(nsDisplayListBuilder* aBuilder,
    1:                                               const nsRect&         aDirtyRect,
    1:                                               nsDisplayList*        aList);
    1: 
    1:   /**
    1:    * Clips the display items of aFromSet, putting the results in aToSet.
    1:    * Only items corresponding to frames which are descendants of this frame
    1:    * are clipped. In other words, descendant elements whose CSS boxes do not
    1:    * have this frame as a container are not clipped. Also,
    1:    * border/background/outline items for this frame are not clipped,
    1:    * unless aClipBorderBackground is set to PR_TRUE. (We need this because
    1:    * a scrollframe must overflow-clip its scrolled child's background/borders.)
    1:    */
    1:   nsresult OverflowClip(nsDisplayListBuilder*   aBuilder,
    1:                         const nsDisplayListSet& aFromSet,
    1:                         const nsDisplayListSet& aToSet,
    1:                         const nsRect&           aClipRect,
    1:                         PRBool                  aClipBorderBackground = PR_FALSE,
    1:                         PRBool                  aClipAll = PR_FALSE);
    1: 
    1:   /**
    1:    * Clips the display items of aFromSet, putting the results in aToSet.
    1:    * All items are clipped.
    1:    */
    1:   nsresult Clip(nsDisplayListBuilder* aBuilder,
    1:                 const nsDisplayListSet& aFromSet,
    1:                 const nsDisplayListSet& aToSet,
    1:                 const nsRect& aClipRect);
    1: 
    1:   enum {
    1:     DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT = 0x01,
    1:     DISPLAY_CHILD_FORCE_STACKING_CONTEXT = 0x02,
    1:     DISPLAY_CHILD_INLINE = 0x04
    1:   };
    1:   /**
    1:    * Adjusts aDirtyRect for the child's offset, checks that the dirty rect
    1:    * actually intersects the child (or its descendants), calls BuildDisplayList
    1:    * on the child if necessary, and puts things in the right lists if the child
    1:    * is positioned.
    1:    *
    1:    * @param aFlags combination of DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT,
    1:    *    DISPLAY_CHILD_FORCE_STACKING_CONTEXT and DISPLAY_CHILD_INLINE
    1:    */
    1:   nsresult BuildDisplayListForChild(nsDisplayListBuilder*   aBuilder,
    1:                                     nsIFrame*               aChild,
    1:                                     const nsRect&           aDirtyRect,
    1:                                     const nsDisplayListSet& aLists,
    1:                                     PRUint32                aFlags = 0);
    1: 
    1:   /**
    1:    * Does this frame type always need a view?
    1:    */
    1:   virtual PRBool NeedsView() { return PR_FALSE; }
    1: 
    1:   /**
19214:    * Returns whether this frame has a transform matrix applied to it.  This is true
19214:    * if we have the -moz-transform property or if we're an SVGForeignObjectFrame.
19214:    */
19214:   virtual PRBool IsTransformed() const;
19214: 
19214:   /**
    1:    * This frame needs a view with a widget (e.g. because it's fixed
    1:    * positioned), so we call this to create the widget. If widgets for
    1:    * this frame type need to be of a certain type or require special
    1:    * initialization, that can be done here.
    1:    */
    1:   virtual nsresult CreateWidgetForView(nsIView* aView);
    1: 
    1:   /**
    1:    * Event handling of GUI events.
    1:    *
    1:    * @param   aEvent event structure describing the type of event and rge widget
    1:    *            where the event originated
    1:    *          The |point| member of this is in the coordinate system of the
    1:    *          view returned by GetOffsetFromView.
    1:    * @param   aEventStatus a return value indicating whether the event was handled
    1:    *            and whether default processing should be done
    1:    *
    1:    * XXX From a frame's perspective it's unclear what the effect of the event status
    1:    * is. Does it cause the event to continue propagating through the frame hierarchy
    1:    * or is it just returned to the widgets?
    1:    *
    1:    * @see     nsGUIEvent
    1:    * @see     nsEventStatus
    1:    */
    1:   NS_IMETHOD  HandleEvent(nsPresContext* aPresContext,
    1:                           nsGUIEvent*     aEvent,
    1:                           nsEventStatus*  aEventStatus) = 0;
    1: 
    1:   NS_IMETHOD  GetContentForEvent(nsPresContext* aPresContext,
    1:                                  nsEvent* aEvent,
    1:                                  nsIContent** aContent) = 0;
    1: 
    1:   // This structure keeps track of the content node and offsets associated with
    1:   // a point; there is a primary and a secondary offset associated with any
    1:   // point.  The primary and secondary offsets differ when the point is over a
    1:   // non-text object.  The primary offset is the expected position of the
    1:   // cursor calculated from a point; the secondary offset, when it is different,
    1:   // indicates that the point is in the boundaries of some selectable object.
    1:   // Note that the primary offset can be after the secondary offset; for places
    1:   // that need the beginning and end of the object, the StartOffset and 
    1:   // EndOffset helpers can be used.
15599:   struct NS_STACK_CLASS ContentOffsets {
    1:     nsCOMPtr<nsIContent> content;
    1:     PRBool IsNull() { return !content; }
    1:     PRInt32 offset;
    1:     PRInt32 secondaryOffset;
    1:     // Helpers for places that need the ends of the offsets and expect them in
    1:     // numerical order, as opposed to wanting the primary and secondary offsets
    1:     PRInt32 StartOffset() { return PR_MIN(offset, secondaryOffset); }
    1:     PRInt32 EndOffset() { return PR_MAX(offset, secondaryOffset); }
    1:     // This boolean indicates whether the associated content is before or after
    1:     // the offset; the most visible use is to allow the caret to know which line
    1:     // to display on.
    1:     PRBool associateWithNext;
    1:   };
    1:   /**
    1:    * This function calculates the content offsets for selection relative to
    1:    * a point.  Note that this should generally only be callled on the event
    1:    * frame associated with an event because this function does not account
    1:    * for frame lists other than the primary one.
    1:    * @param aPoint point relative to this frame
    1:    */
    1:   ContentOffsets GetContentOffsetsFromPoint(nsPoint aPoint,
    1:                                             PRBool aIgnoreSelectionStyle = PR_FALSE);
    1: 
    1:   virtual ContentOffsets GetContentOffsetsFromPointExternal(nsPoint aPoint,
    1:                                                             PRBool aIgnoreSelectionStyle = PR_FALSE)
    1:   { return GetContentOffsetsFromPoint(aPoint, aIgnoreSelectionStyle); }
    1: 
    1:   /**
    1:    * This structure holds information about a cursor. mContainer represents a
    1:    * loaded image that should be preferred. If it is not possible to use it, or
    1:    * if it is null, mCursor should be used.
    1:    */
15599:   struct NS_STACK_CLASS Cursor {
    1:     nsCOMPtr<imgIContainer> mContainer;
    1:     PRInt32                 mCursor;
    1:     PRBool                  mHaveHotspot;
    1:     float                   mHotspotX, mHotspotY;
    1:   };
    1:   /**
    1:    * Get the cursor for a given frame.
    1:    */
    1:   NS_IMETHOD  GetCursor(const nsPoint&  aPoint,
    1:                         Cursor&         aCursor) = 0;
    1: 
    1:   /**
    1:    * Get a point (in the frame's coordinate space) given an offset into
    1:    * the content. This point should be on the baseline of text with
    1:    * the correct horizontal offset
    1:    */
 4741:   NS_IMETHOD  GetPointFromOffset(PRInt32                  inOffset,
    1:                                  nsPoint*                 outPoint) = 0;
    1:   
    1:   /**
    1:    * Get the child frame of this frame which contains the given
    1:    * content offset. outChildFrame may be this frame, or nsnull on return.
    1:    * outContentOffset returns the content offset relative to the start
    1:    * of the returned node. You can also pass a hint which tells the method
    1:    * to stick to the end of the first found frame or the beginning of the 
    1:    * next in case the offset falls on a boundary.
    1:    */
    1:   NS_IMETHOD  GetChildFrameContainingOffset(PRInt32       inContentOffset,
    1:                                  PRBool                   inHint,//false stick left
    1:                                  PRInt32*                 outFrameContentOffset,
    1:                                  nsIFrame*                *outChildFrame) = 0;
    1: 
    1:  /**
    1:    * Get the current frame-state value for this frame. aResult is
    1:    * filled in with the state bits. 
    1:    */
    1:   nsFrameState GetStateBits() const { return mState; }
    1: 
    1:   /**
    1:    * Update the current frame-state value for this frame. 
    1:    */
    1:   void AddStateBits(nsFrameState aBits) { mState |= aBits; }
    1:   void RemoveStateBits(nsFrameState aBits) { mState &= ~aBits; }
    1: 
    1:   /**
    1:    * This call is invoked when content is changed in the content tree.
    1:    * The first frame that maps that content is asked to deal with the
    1:    * change by generating an incremental reflow command.
    1:    *
    1:    * @param aPresContext the presentation context
    1:    * @param aContent     the content node that was changed
    1:    * @param aAppend      a hint to the frame about the change
    1:    */
    1:   NS_IMETHOD  CharacterDataChanged(nsPresContext* aPresContext,
    1:                                    nsIContent*     aChild,
    1:                                    PRBool          aAppend) = 0;
    1: 
    1:   /**
    1:    * This call is invoked when the value of a content objects's attribute
    1:    * is changed. 
    1:    * The first frame that maps that content is asked to deal
    1:    * with the change by doing whatever is appropriate.
    1:    *
    1:    * @param aNameSpaceID the namespace of the attribute
    1:    * @param aAttribute the atom name of the attribute
    1:    * @param aModType Whether or not the attribute was added, changed, or removed.
    1:    *   The constants are defined in nsIDOMMutationEvent.h.
    1:    */
    1:   NS_IMETHOD  AttributeChanged(PRInt32         aNameSpaceID,
    1:                                nsIAtom*        aAttribute,
    1:                                PRInt32         aModType) = 0;
    1: 
    1:   /**
    1:    * Return how your frame can be split.
    1:    */
    1:   virtual nsSplittableType GetSplittableType() const = 0;
    1: 
    1:   /**
    1:    * Continuation member functions
    1:    */
    1:   virtual nsIFrame* GetPrevContinuation() const = 0;
    1:   NS_IMETHOD SetPrevContinuation(nsIFrame*) = 0;
    1:   virtual nsIFrame* GetNextContinuation() const = 0;
    1:   NS_IMETHOD SetNextContinuation(nsIFrame*) = 0;
    1:   virtual nsIFrame* GetFirstContinuation() const {
 3233:     return const_cast<nsIFrame*>(this);
    1:   }
    1:   virtual nsIFrame* GetLastContinuation() const {
 3233:     return const_cast<nsIFrame*>(this);
    1:   }
    1: 
    1:   /**
10780:    * GetTailContinuation gets the last non-overflow-container continuation
10780:    * in the continuation chain, i.e. where the next sibling element
10780:    * should attach).
10780:    */
10780:   nsIFrame* GetTailContinuation();
10780: 
10780:   /**
    1:    * Flow member functions
    1:    */
    1:   virtual nsIFrame* GetPrevInFlowVirtual() const = 0;
    1:   nsIFrame* GetPrevInFlow() const { return GetPrevInFlowVirtual(); }
    1:   NS_IMETHOD SetPrevInFlow(nsIFrame*) = 0;
    1: 
    1:   virtual nsIFrame* GetNextInFlowVirtual() const = 0;
    1:   nsIFrame* GetNextInFlow() const { return GetNextInFlowVirtual(); }
    1:   NS_IMETHOD SetNextInFlow(nsIFrame*) = 0;
    1: 
    1:   /**
    1:    * Return the first frame in our current flow. 
    1:    */
    1:   virtual nsIFrame* GetFirstInFlow() const {
 3233:     return const_cast<nsIFrame*>(this);
    1:   }
    1: 
    1:   /**
    1:    * Return the last frame in our current flow.
    1:    */
    1:   virtual nsIFrame* GetLastInFlow() const {
 3233:     return const_cast<nsIFrame*>(this);
    1:   }
    1: 
    1: 
    1:   /**
    1:    * Mark any stored intrinsic width information as dirty (requiring
    1:    * re-calculation).  Note that this should generally not be called
    1:    * directly; nsPresShell::FrameNeedsReflow will call it instead.
    1:    */
    1:   virtual void MarkIntrinsicWidthsDirty() = 0;
    1: 
    1:   /**
    1:    * Get the intrinsic minimum width of the frame.  This must be less
    1:    * than or equal to the intrinsic width.
    1:    *
    1:    * This is *not* affected by the CSS 'min-width', 'width', and
    1:    * 'max-width' properties on this frame, but it is affected by the
    1:    * values of those properties on this frame's descendants.  (It may be
    1:    * called during computation of the values of those properties, so it
    1:    * cannot depend on any values in the nsStylePosition for this frame.)
    1:    *
    1:    * The value returned should **NOT** include the space required for
    1:    * padding and border.
    1:    *
    1:    * Note that many frames will cache the result of this function call
    1:    * unless MarkIntrinsicWidthsDirty is called.
    1:    *
    1:    * It is not acceptable for a frame to mark itself dirty when this
    1:    * method is called.
16269:    *
16269:    * This method must not return a negative value.
    1:    */
    1:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext) = 0;
    1: 
    1:   /**
    1:    * Get the intrinsic width of the frame.  This must be greater than or
    1:    * equal to the intrinsic minimum width.
    1:    *
    1:    * Otherwise, all the comments for |GetMinWidth| above apply.
    1:    */
    1:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext) = 0;
    1: 
    1:   /**
    1:    * |InlineIntrinsicWidth| represents the intrinsic width information
    1:    * in inline layout.  Code that determines the intrinsic width of a
    1:    * region of inline layout accumulates the result into this structure.
    1:    * This pattern is needed because we need to maintain state
    1:    * information about whitespace (for both collapsing and trimming).
    1:    */
    1:   struct InlineIntrinsicWidthData {
    1:     InlineIntrinsicWidthData()
 6029:       : line(nsnull)
24819:       , lineContainer(nsnull)
 6029:       , prevLines(0)
    1:       , currentLine(0)
    1:       , skipWhitespace(PR_TRUE)
    1:       , trailingWhitespace(0)
    1:     {}
    1: 
10113:     // The line. This may be null if the inlines are not associated with
10113:     // a block or if we just don't know the line.
 6029:     const nsLineList_iterator* line;
 6029: 
24819:     // The line container.
24819:     nsIFrame* lineContainer;
24819: 
    1:     // The maximum intrinsic width for all previous lines.
    1:     nscoord prevLines;
    1: 
    1:     // The maximum intrinsic width for the current line.  At a line
    1:     // break (mandatory for preferred width; allowed for minimum width),
    1:     // the caller should call |Break()|.
    1:     nscoord currentLine;
    1: 
    1:     // True if initial collapsable whitespace should be skipped.  This
 8930:     // should be true at the beginning of a block, after hard breaks
 8930:     // and when the last text ended with whitespace.
    1:     PRBool skipWhitespace;
    1: 
    1:     // This contains the width of the trimmable whitespace at the end of
    1:     // |currentLine|; it is zero if there is no such whitespace.
    1:     nscoord trailingWhitespace;
    1: 
    1:     // Floats encountered in the lines.
24551:     nsTArray<nsIFrame*> floats;
    1:   };
    1: 
    1:   struct InlineMinWidthData : public InlineIntrinsicWidthData {
    1:     InlineMinWidthData()
    1:       : trailingTextFrame(nsnull)
 2668:       , atStartOfLine(PR_TRUE)
    1:     {}
    1: 
 2668:     // We need to distinguish forced and optional breaks for cases where the
 2668:     // current line total is negative.  When it is, we need to ignore
 2668:     // optional breaks to prevent min-width from ending up bigger than
 2668:     // pref-width.
 2668:     void ForceBreak(nsIRenderingContext *aRenderingContext);
 2668:     void OptionallyBreak(nsIRenderingContext *aRenderingContext);
    1: 
    1:     // The last text frame processed so far in the current line, when
    1:     // the last characters in that text frame are relevant for line
    1:     // break opportunities.
    1:     nsIFrame *trailingTextFrame;
 2668: 
 2668:     // Whether we're currently at the start of the line.  If we are, we
 2668:     // can't break (for example, between the text-indent and the first
 2668:     // word).
 2668:     PRBool atStartOfLine;
    1:   };
    1: 
    1:   struct InlinePrefWidthData : public InlineIntrinsicWidthData {
 2668:     void ForceBreak(nsIRenderingContext *aRenderingContext);
    1:   };
    1: 
    1:   /**
    1:    * Add the intrinsic minimum width of a frame in a way suitable for
    1:    * use in inline layout to an |InlineIntrinsicWidthData| object that
    1:    * represents the intrinsic width information of all the previous
    1:    * frames in the inline layout region.
    1:    *
    1:    * All *allowed* breakpoints within the frame determine what counts as
    1:    * a line for the |InlineIntrinsicWidthData|.  This means that
    1:    * |aData->trailingWhitespace| will always be zero (unlike for
    1:    * AddInlinePrefWidth).
    1:    *
    1:    * All the comments for |GetMinWidth| apply, except that this function
    1:    * is responsible for adding padding, border, and margin and for
    1:    * considering the effects of 'width', 'min-width', and 'max-width'.
    1:    *
    1:    * This may be called on any frame.  Frames that do not participate in
    1:    * line breaking can inherit the default implementation on nsFrame,
    1:    * which calls |GetMinWidth|.
    1:    */
    1:   virtual void
    1:   AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                     InlineMinWidthData *aData) = 0;
    1: 
    1:   /**
    1:    * Add the intrinsic preferred width of a frame in a way suitable for
    1:    * use in inline layout to an |InlineIntrinsicWidthData| object that
    1:    * represents the intrinsic width information of all the previous
    1:    * frames in the inline layout region.
    1:    *
    1:    * All the comments for |AddInlineMinWidth| and |GetPrefWidth| apply,
    1:    * except that this fills in an |InlineIntrinsicWidthData| structure
    1:    * based on using all *mandatory* breakpoints within the frame.
    1:    */
    1:   virtual void
    1:   AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                      InlinePrefWidthData *aData) = 0;
    1: 
    1:   /**
    1:    * Return the horizontal components of padding, border, and margin
    1:    * that contribute to the intrinsic width that applies to the parent.
    1:    */
    1:   struct IntrinsicWidthOffsetData {
    1:     nscoord hPadding, hBorder, hMargin;
    1:     float hPctPadding, hPctMargin;
    1: 
    1:     IntrinsicWidthOffsetData()
    1:       : hPadding(0), hBorder(0), hMargin(0)
    1:       , hPctPadding(0.0f), hPctMargin(0.0f)
    1:     {}
    1:   };
    1:   virtual IntrinsicWidthOffsetData
    1:     IntrinsicWidthOffsets(nsIRenderingContext* aRenderingContext) = 0;
    1: 
 2301:   /*
 8142:    * For replaced elements only. Gets the intrinsic dimensions of this element.
 8142:    * The dimensions may only be one of the following three types:
 8142:    *
 8142:    *   eStyleUnit_Coord   - a length in app units
 8142:    *   eStyleUnit_Percent - a percentage of the available space
 8142:    *   eStyleUnit_None    - the element has no intrinsic size in this dimension
 8142:    */
 8142:   struct IntrinsicSize {
 8142:     nsStyleCoord width, height;
 8142: 
 8142:     IntrinsicSize()
 8142:       : width(eStyleUnit_None), height(eStyleUnit_None)
 8142:     {}
 8142:     IntrinsicSize(const IntrinsicSize& rhs)
 8142:       : width(rhs.width), height(rhs.height)
 8142:     {}
 8142:     IntrinsicSize& operator=(const IntrinsicSize& rhs) {
 8142:       width = rhs.width; height = rhs.height; return *this;
 8142:     }
 8142:   };
 8142:   virtual IntrinsicSize GetIntrinsicSize() = 0;
 8142: 
 8142:   /*
 2301:    * Get the intrinsic ratio of this element, or nsSize(0,0) if it has
 2301:    * no intrinsic ratio.  The intrinsic ratio is the ratio of the
 2301:    * height/width of a box with an intrinsic size or the intrinsic
 2301:    * aspect ratio of a scalable vector image without an intrinsic size.
 2301:    *
 2301:    * Either one of the sides may be zero, indicating a zero or infinite
 2301:    * ratio.
 2301:    */
 2301:   virtual nsSize GetIntrinsicRatio() = 0;
 2301: 
    1:   /**
    1:    * Compute the size that a frame will occupy.  Called while
    1:    * constructing the nsHTMLReflowState to be used to Reflow the frame,
    1:    * in order to fill its mComputedWidth and mComputedHeight member
    1:    * variables.
    1:    *
    1:    * The |height| member of the return value may be
    1:    * NS_UNCONSTRAINEDSIZE, but the |width| member must not be.
    1:    *
    1:    * Note that the reason that border and padding need to be passed
    1:    * separately is so that the 'box-sizing' property can be handled.
    1:    * Thus aMargin includes absolute positioning offsets as well.
    1:    *
    1:    * @param aCBSize  The size of the element's containing block.  (Well,
    1:    *                 the |height| component isn't really.)
    1:    * @param aAvailableWidth  The available width for 'auto' widths.
    1:    *                         This is usually the same as aCBSize.width,
    1:    *                         but differs in cases such as block
    1:    *                         formatting context roots next to floats, or
    1:    *                         in some cases of float reflow in quirks
    1:    *                         mode.
    1:    * @param aMargin  The sum of the vertical / horizontal margins
    1:    *                 ***AND*** absolute positioning offsets (top, right,
    1:    *                 bottom, left) of the frame, including actual values
    1:    *                 resulting from percentages and from the
    1:    *                 "hypothetical box" for absolute positioning, but
    1:    *                 not including actual values resulting from 'auto'
    1:    *                 margins or ignored 'auto' values in absolute
    1:    *                 positioning.
    1:    * @param aBorder  The sum of the vertical / horizontal border widths
    1:    *                 of the frame.
    1:    * @param aPadding  The sum of the vertical / horizontal margins of
    1:    *                  the frame, including actual values resulting from
    1:    *                  percentages.
    1:    * @param aShrinkWrap  Whether the frame is in a context where
    1:    *                     non-replaced blocks should shrink-wrap (e.g.,
    1:    *                     it's floating, absolutely positioned, or
    1:    *                     inline-block).
    1:    */
    1:   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                              nsSize aCBSize, nscoord aAvailableWidth,
    1:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                              PRBool aShrinkWrap) = 0;
    1: 
    1:   /**
 6862:    * Compute a tight bounding rectangle for the frame. This is a rectangle
 6862:    * that encloses the pixels that are actually drawn. We're allowed to be
 6862:    * conservative and currently we don't try very hard. The rectangle is
 6862:    * in appunits and relative to the origin of this frame.
 6862:    * @param aContext a rendering context that can be used if we need
 6862:    * to do measurement
 6862:    */
 6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
 6862: 
 6862:   /**
    1:    * Pre-reflow hook. Before a frame is reflowed this method will be called.
    1:    * This call will always be invoked at least once before a subsequent Reflow
    1:    * and DidReflow call. It may be called more than once, In general you will
    1:    * receive on WillReflow notification before each Reflow request.
    1:    *
    1:    * XXX Is this really the semantics we want? Because we have the NS_FRAME_IN_REFLOW
    1:    * bit we can ensure we don't call it more than once...
    1:    */
    1:   NS_IMETHOD  WillReflow(nsPresContext* aPresContext) = 0;
    1: 
    1:   /**
    1:    * The frame is given an available size and asked for its desired
    1:    * size.  This is the frame's opportunity to reflow its children.
    1:    *
    1:    * If the frame has the NS_FRAME_IS_DIRTY bit set then it is
    1:    * responsible for completely reflowing itself and all of its
    1:    * descendants.
    1:    *
    1:    * Otherwise, if the frame has the NS_FRAME_HAS_DIRTY_CHILDREN bit
    1:    * set, then it is responsible for reflowing at least those
    1:    * children that have NS_FRAME_HAS_DIRTY_CHILDREN or NS_FRAME_IS_DIRTY
    1:    * set.
    1:    *
    1:    * If a difference in available size from the previous reflow causes
    1:    * the frame's size to change, it should reflow descendants as needed.
    1:    *
    1:    * @param aReflowMetrics <i>out</i> parameter where you should return the
    1:    *          desired size and ascent/descent info. You should include any
    1:    *          space you want for border/padding in the desired size you return.
    1:    *
    1:    *          It's okay to return a desired size that exceeds the avail
    1:    *          size if that's the smallest you can be, i.e. it's your
    1:    *          minimum size.
    1:    *
    1:    *          For an incremental reflow you are responsible for invalidating
    1:    *          any area within your frame that needs repainting (including
    1:    *          borders). If your new desired size is different than your current
    1:    *          size, then your parent frame is responsible for making sure that
    1:    *          the difference between the two rects is repainted
    1:    *
    1:    * @param aReflowState information about your reflow including the reason
    1:    *          for the reflow and the available space in which to lay out. Each
    1:    *          dimension of the available space can either be constrained or
    1:    *          unconstrained (a value of NS_UNCONSTRAINEDSIZE).
    1:    *
    1:    *          Note that the available space can be negative. In this case you
    1:    *          still must return an accurate desired size. If you're a container
    1:    *          you must <b>always</b> reflow at least one frame regardless of the
    1:    *          available space
    1:    *
    1:    * @param aStatus a return value indicating whether the frame is complete
    1:    *          and whether the next-in-flow is dirty and needs to be reflowed
    1:    */
    1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
    1:                     nsHTMLReflowMetrics&     aReflowMetrics,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus) = 0;
    1: 
    1:   /**
    1:    * Post-reflow hook. After a frame is reflowed this method will be called
    1:    * informing the frame that this reflow process is complete, and telling the
    1:    * frame the status returned by the Reflow member function.
    1:    *
    1:    * This call may be invoked many times, while NS_FRAME_IN_REFLOW is set, before
    1:    * it is finally called once with a NS_FRAME_REFLOW_COMPLETE value. When called
    1:    * with a NS_FRAME_REFLOW_COMPLETE value the NS_FRAME_IN_REFLOW bit in the
    1:    * frame state will be cleared.
    1:    *
    1:    * XXX This doesn't make sense. If the frame is reflowed but not complete, then
    1:    * the status should be NS_FRAME_NOT_COMPLETE and not NS_FRAME_COMPLETE
    1:    * XXX Don't we want the semantics to dictate that we only call this once for
    1:    * a given reflow?
    1:    */
    1:   NS_IMETHOD  DidReflow(nsPresContext*           aPresContext,
    1:                         const nsHTMLReflowState*  aReflowState,
    1:                         nsDidReflowStatus         aStatus) = 0;
    1: 
    1:   // XXX Maybe these three should be a separate interface?
    1: 
    1:   /**
    1:    * Helper method used by block reflow to identify runs of text so
    1:    * that proper word-breaking can be done.
    1:    *
    1:    * @return 
    1:    *    PR_TRUE if we can continue a "text run" through the frame. A
    1:    *    text run is text that should be treated contiguously for line
    1:    *    and word breaking.
    1:    */
    1:   virtual PRBool CanContinueTextRun() const = 0;
    1: 
    1:   /**
 4261:    * Append the rendered text to the passed-in string.
 4261:    * The appended text will often not contain all the whitespace from source,
 4261:    * depending on whether the CSS rule "white-space: pre" is active for this frame.
 4261:    * if aStartOffset + aLength goes past end, or if aLength is not specified
 4261:    * then use the text up to the string's end.
 4261:    * Call this on the primary frame for a text node.
 4261:    * @param aAppendToString   String to append text to, or null if text should not be returned
 4261:    * @param aSkipChars         if aSkipIter is non-null, this must also be non-null.
 4261:    * This gets used as backing data for the iterator so it should outlive the iterator.
 4261:    * @param aSkipIter         Where to fill in the gfxSkipCharsIterator info, or null if not needed by caller
 4261:    * @param aStartOffset       Skipped (rendered text) start offset
 4261:    * @param aSkippedMaxLength  Maximum number of characters to return
 4261:    * The iterator can be used to map content offsets to offsets in the returned string, or vice versa.
 4261:    */
 4261:   virtual nsresult GetRenderedText(nsAString* aAppendToString = nsnull,
 4261:                                    gfxSkipChars* aSkipChars = nsnull,
 4261:                                    gfxSkipCharsIterator* aSkipIter = nsnull,
 4261:                                    PRUint32 aSkippedStartOffset = 0,
 4261:                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX)
 4261:   { return NS_ERROR_NOT_IMPLEMENTED; }
 4261: 
 4261:   /**
    1:    * Accessor functions to get/set the associated view object
    1:    *
    1:    * GetView returns non-null if and only if |HasView| returns true.
    1:    */
 6770:   PRBool HasView() const { return !!(mState & NS_FRAME_HAS_VIEW); }
    1:   nsIView* GetView() const;
    1:   virtual nsIView* GetViewExternal() const;
    1:   nsresult SetView(nsIView* aView);
    1: 
    1:   /**
    1:    * This view will be used to parent the views of any children.
    1:    * This allows us to insert an anonymous inner view to parent
    1:    * some children.
    1:    */
    1:   virtual nsIView* GetParentViewForChildFrame(nsIFrame* aFrame) const;
    1: 
    1:   /**
    1:    * Find the closest view (on |this| or an ancestor).
    1:    * If aOffset is non-null, it will be set to the offset of |this|
    1:    * from the returned view.
    1:    */
    1:   nsIView* GetClosestView(nsPoint* aOffset = nsnull) const;
    1: 
    1:   /**
    1:    * Find the closest ancestor (excluding |this| !) that has a view
    1:    */
    1:   nsIFrame* GetAncestorWithView() const;
    1:   virtual nsIFrame* GetAncestorWithViewExternal() const;
    1: 
    1:   /**
    1:    * Get the offset between the coordinate systems of |this| and aOther.
    1:    * Adding the return value to a point in the coordinate system of |this|
    1:    * will transform the point to the coordinate system of aOther.
    1:    *
    1:    * aOther must be non-null.
    1:    * 
    1:    * This function is fastest when aOther is an ancestor of |this|.
    1:    *
30522:    * This function works across document boundaries.
30522:    *
    1:    * NOTE: this actually returns the offset from aOther to |this|, but
    1:    * that offset is added to transform _coordinates_ from |this| to
    1:    * aOther.
    1:    */
    1:   nsPoint GetOffsetTo(const nsIFrame* aOther) const;
    1:   virtual nsPoint GetOffsetToExternal(const nsIFrame* aOther) const;
    1: 
    1:   /**
15364:    * Get the screen rect of the frame in pixels.
    1:    * @return the pixel rect of the frame in screen coordinates.
    1:    */
    1:   nsIntRect GetScreenRect() const;
    1:   virtual nsIntRect GetScreenRectExternal() const;
    1: 
    1:   /**
15364:    * Get the screen rect of the frame in app units.
15364:    * @return the app unit rect of the frame in screen coordinates.
15364:    */
15364:   nsRect GetScreenRectInAppUnits() const;
15364:   virtual nsRect GetScreenRectInAppUnitsExternal() const;
15364: 
15364:   /**
    1:    * Returns the offset from this frame to the closest geometric parent that
    1:    * has a view. Also returns the containing view or null in case of error
    1:    */
    1:   NS_IMETHOD  GetOffsetFromView(nsPoint&  aOffset,
    1:                                 nsIView** aView) const = 0;
    1: 
    1:   /**
    1:    * Returns true if and only if all views, from |GetClosestView| up to
    1:    * the top of the view hierarchy are visible.
    1:    */
    1:   virtual PRBool AreAncestorViewsVisible() const;
    1: 
    1:   /**
    1:    * Returns the window that contains this frame. If this frame has a
    1:    * view and the view has a window, then this frames window is
    1:    * returned, otherwise this frame's geometric parent is checked
    1:    * recursively upwards.
    1:    * XXX virtual because gfx callers use it! (themes)
    1:    */
    1:   virtual nsIWidget* GetWindow() const;
    1: 
    1:   /**
    1:    * Get the "type" of the frame. May return a NULL atom pointer
    1:    *
    1:    * @see nsGkAtoms
    1:    */
    1:   virtual nsIAtom* GetType() const = 0;
    1: 
19214:   /**
19214:    * Returns a transformation matrix that converts points in this frame's coordinate space
19214:    * to points in some ancestor frame's coordinate space.  The frame decides which ancestor
19214:    * it will use as a reference point.  If this frame has no ancestor, aOutAncestor will be
19214:    * set to null.
19214:    *
19214:    * @param aOutAncestor [out] The ancestor frame the frame has chosen.  If this frame has no
19214:    *        ancestor, aOutAncestor will be nsnull.
19214:    * @return A gfxMatrix that converts points in this frame's coordinate space into
19214:    *         points in aOutAncestor's coordinate space.
19214:    */
19214:   virtual gfxMatrix GetTransformMatrix(nsIFrame **aOutAncestor);
    1: 
    1:   /**
    1:    * Bit-flags to pass to IsFrameOfType()
    1:    */
    1:   enum {
    1:     eMathML =                           1 << 0,
    1:     eSVG =                              1 << 1,
    1:     eSVGForeignObject =                 1 << 2,
19948:     eSVGContainer =                     1 << 3,
19948:     eBidiInlineContainer =              1 << 4,
    1:     // the frame is for a replaced element, such as an image
19948:     eReplaced =                         1 << 5,
    1:     // Frame that contains a block but looks like a replaced element
    1:     // from the outside
19948:     eReplacedContainsBlock =            1 << 6,
 1588:     // A frame that participates in inline reflow, i.e., one that
 1588:     // requires nsHTMLReflowState::mLineLayout.
19948:     eLineParticipant =                  1 << 7,
19948:     eXULBox =                           1 << 8,
19948:     eCanContainOverflowContainers =     1 << 9,
19948:     eBlockFrame =                       1 << 10,
15913:     // If this bit is set, the frame doesn't allow ignorable whitespace as
15913:     // children. For example, the whitespace between <table>\n<tr>\n<td>
15913:     // will be excluded during the construction of children. 
19948:     eExcludesIgnorableWhitespace =      1 << 11,
    1: 
    1:     // These are to allow nsFrame::Init to assert that IsFrameOfType
    1:     // implementations all call the base class method.  They are only
    1:     // meaningful in DEBUG builds.
    1:     eDEBUGAllFrames =                   1 << 30,
    1:     eDEBUGNoFrames =                    1 << 31
    1:   };
    1: 
    1:   /**
    1:    * API for doing a quick check if a frame is of a given
    1:    * type. Returns true if the frame matches ALL flags passed in.
    1:    *
    1:    * Implementations should always override with inline virtual
    1:    * functions that call the base class's IsFrameOfType method.
    1:    */
    1:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
    1:   {
    1: #ifdef DEBUG
    1:     return !(aFlags & ~(nsIFrame::eDEBUGAllFrames));
    1: #else
    1:     return !aFlags;
    1: #endif
    1:   }
    1: 
    1:   /**
    1:    * Is this frame a containing block for non-positioned elements?
    1:    */
    1:   virtual PRBool IsContainingBlock() const = 0;
    1: 
    1:   /**
    1:    * Is this frame a containing block for floating elements?
    1:    * Note that very few frames are, so default to false.
    1:    */
    1:   virtual PRBool IsFloatContainingBlock() const { return PR_FALSE; }
    1: 
    1:   /**
    1:    * Is this a leaf frame?  Frames that want the frame constructor to be able
    1:    * to construct kids for them should return false, all others should return
    1:    * true.  Note that returning true here does not mean that the frame _can't_
    1:    * have kids.  It could still have kids created via
    1:    * nsIAnonymousContentCreator.  Returning true indicates that "normal"
    1:    * (non-anonymous, XBL-bound, CSS generated content, etc) children should not
    1:    * be constructed.
    1:    */
    1:   virtual PRBool IsLeaf() const;
    1: 
    1:   /**
    1:    * Does this frame want to capture the mouse when the user clicks in
    1:    * it or its children? If so, return the view which should be
    1:    * targeted for mouse capture. The view need not be this frame's view,
    1:    * it could be the view on a child.
    1:    */
    1:   virtual nsIView* GetMouseCapturer() const { return nsnull; }
    1: 
    1:   /**
19380:    * @param aFlags see InvalidateInternal below
19380:    */
19380:   void InvalidateWithFlags(const nsRect& aDamageRect, PRUint32 aFlags);
19380: 
19380:   /**
    1:    * Invalidate part of the frame by asking the view manager to repaint.
    1:    * aDamageRect is allowed to extend outside the frame's bounds. We'll do the right
    1:    * thing.
    1:    * We deliberately don't have an Invalidate() method that defaults to the frame's bounds.
    1:    * We want all callers to *think* about what has changed in the frame and what area might
    1:    * need to be repainted.
    1:    *
    1:    * @param aDamageRect is in the frame's local coordinate space
    1:    */
19380:   void Invalidate(const nsRect& aDamageRect)
19380:   { return InvalidateWithFlags(aDamageRect, 0); }
    1: 
    1:   /**
    1:    * Helper function that can be overridden by frame classes. The rectangle
    1:    * (plus aOffsetX/aOffsetY) is relative to this frame.
    1:    * 
    1:    * The offset is given as two coords rather than as an nsPoint because
    1:    * gcc optimizes it better that way, in particular in the default
    1:    * implementation that passes the area to the parent frame becomes a tail
    1:    * call.
    1:    *
    1:    * The default implementation will crash if the frame has no parent so
    1:    * frames without parents MUST* override.
    1:    * 
    1:    * @param aForChild if the invalidation is coming from a child frame, this
    1:    * is the frame; otherwise, this is null.
19380:    * @param aFlags INVALIDATE_IMMEDIATE: repaint now if true, repaint later if false.
 7786:    *   In case it's true, pending notifications will be flushed which
 7786:    *   could cause frames to be deleted (including |this|).
19380:    * @param aFlags INVALIDATE_CROSS_DOC: true if the invalidation
19380:    *   originated in a subdocument
30507:    * @param aFlags INVALIDATE_NOTIFY_ONLY: set when this invalidation should
30507:    * cause MozAfterPaint listeners to be notified, but should not actually
30507:    * invalidate anything. This is used to notify about scrolling, where the
30507:    * screen has already been updated.
    1:    */
19380:   enum {
19380:   	INVALIDATE_IMMEDIATE = 0x1,
19380:   	INVALIDATE_CROSS_DOC = 0x2,
19380:   	INVALIDATE_NOTIFY_ONLY = 0x4
19380:   };
    1:   virtual void InvalidateInternal(const nsRect& aDamageRect,
    1:                                   nscoord aOffsetX, nscoord aOffsetY,
19380:                                   nsIFrame* aForChild, PRUint32 aFlags);
    1: 
    1:   /**
19214:    * Helper function that funnels an InvalidateInternal request up to the
19214:    * parent.  This function is used so that if MOZ_SVG is not defined, we still
19214:    * have unified control paths in the InvalidateInternal chain.
19214:    *
19214:    * @param aDamageRect The rect to invalidate.
19214:    * @param aX The x offset from the origin of this frame to the rectangle.
19214:    * @param aY The y offset from the origin of this frame to the rectangle.
19214:    * @param aImmediate Whether to redraw immediately.
19214:    * @return None, though this funnels the request up to the parent frame.
19214:    */
19214:   void InvalidateInternalAfterResize(const nsRect& aDamageRect, nscoord aX,
19380:                                      nscoord aY, PRUint32 aFlags);
19214: 
19214:   /**
11384:    * Take two rectangles in the coordinate system of this frame which
11384:    * have the same origin and invalidate the difference between them.
11384:    * This is a helper method to be used when a frame is being resized.
11384:    *
11384:    * @param aR1 the first rectangle
11384:    * @param aR2 the second rectangle
11384:    */
11384:   void InvalidateRectDifference(const nsRect& aR1, const nsRect& aR2);
11384: 
11384:   /**
11384:    * Invalidate the overflow rect of this frame
11384:    */
11384:   void InvalidateOverflowRect();
11384:   
11384:   /**
  134:    * Computes a rect that encompasses everything that might be painted by
  134:    * this frame.  This includes this frame, all its descendent frames, this
  134:    * frame's outline, and descentant frames' outline, but does not include
  134:    * areas clipped out by the CSS "overflow" and "clip" properties.
    1:    *
26950:    * HasOverflowRect() (below) will return PR_TRUE when this overflow rect
26950:    * has been explicitly set, even if it matches mRect.
11909:    * XXX Note: because of a space optimization using the formula above,
11909:    * during reflow this function does not give accurate data if
11909:    * FinishAndStoreOverflow has been called but mRect hasn't yet been
11909:    * updated yet.
11909:    *
19284:    * @return the rect relative to this frame's origin, but after
19284:    * CSS transforms have been applied (i.e. not really this frame's coordinate
19284:    * system, and may not contain the frame's border-box, e.g. if there
19284:    * is a CSS transform scaling it down)
    1:    */
    1:   nsRect GetOverflowRect() const;
    1: 
    1:   /**
19284:    * Computes a rect that encompasses everything that might be painted by
19284:    * this frame.  This includes this frame, all its descendent frames, this
19284:    * frame's outline, and descentant frames' outline, but does not include
19284:    * areas clipped out by the CSS "overflow" and "clip" properties.
19284:    *
26950:    * HasOverflowRect() (below) will return PR_TRUE when this overflow rect
19284:    * is different from nsRect(0, 0, GetRect().width, GetRect().height).
19284:    * XXX Note: because of a space optimization using the formula above,
19284:    * during reflow this function does not give accurate data if
19284:    * FinishAndStoreOverflow has been called but mRect hasn't yet been
19284:    * updated yet.
19284:    *
19284:    * @return the rect relative to the parent frame, in the parent frame's
19284:    * coordinate system
19284:    */
19284:   nsRect GetOverflowRectRelativeToParent() const;
19284: 
19284:   /**
19284:    * Computes a rect that encompasses everything that might be painted by
19284:    * this frame.  This includes this frame, all its descendent frames, this
19284:    * frame's outline, and descentant frames' outline, but does not include
19284:    * areas clipped out by the CSS "overflow" and "clip" properties.
19284:    *
19284:    * @return the rect relative to this frame, before any CSS transforms have
19284:    * been applied, i.e. in this frame's coordinate system
19284:    */
19284:   nsRect GetOverflowRectRelativeToSelf() const;
19284: 
19284:   /**
26950:    * Store the overflow area in the frame's mOverflow.mDeltas fields or
    1:    * as a frame property in the frame manager so that it can be retrieved
    1:    * later without reflowing the frame.
    1:    */
    1:   void FinishAndStoreOverflow(nsRect* aOverflowArea, nsSize aNewSize);
    1: 
    1:   void FinishAndStoreOverflow(nsHTMLReflowMetrics* aMetrics) {
    1:     FinishAndStoreOverflow(&aMetrics->mOverflowArea, nsSize(aMetrics->width, aMetrics->height));
    1:   }
    1: 
    1:   /**
26950:    * Returns whether the frame has an overflow rect that is different from
26950:    * its border-box.
26950:    */
26950:   PRBool HasOverflowRect() const {
26950:     return mOverflow.mType != NS_FRAME_OVERFLOW_NONE;
26950:   }
26950: 
26950:   /**
26950:    * Removes any stored overflow rect from the frame.
26950:    */
26950:   void ClearOverflowRect() {
26950:     DeleteProperty(nsGkAtoms::overflowAreaProperty);
26950:     mOverflow.mType = NS_FRAME_OVERFLOW_NONE;
26950:   }
26950: 
26950:   /**
    1:    * Determine whether borders should not be painted on certain sides of the
    1:    * frame.
    1:    */
    1:   virtual PRIntn GetSkipSides() const { return 0; }
    1: 
    1:   /** Selection related calls
    1:    */
    1:   /** 
    1:    *  Called to set the selection of the frame based on frame offsets.  you can FORCE the frame
    1:    *  to redraw event if aSelected == the frame selection with the last parameter.
    1:    *  data in struct may be changed when passed in.
    1:    *  @param aRange is the range that will dictate if the frames need to be redrawn null means the whole content needs to be redrawn
    1:    *  @param aSelected is it selected?
    1:    *  @param aSpread should it spread the selection to flow elements around it? or go down to its children?
18931:    *  @param aType the selection type of the selection that you are setting on the frame
    1:    */
    1:   NS_IMETHOD  SetSelected(nsPresContext* aPresContext,
    1:                           nsIDOMRange*    aRange,
    1:                           PRBool          aSelected,
18931:                           nsSpread        aSpread,
18931:                           SelectionType   aType) = 0;
    1: 
    1:   NS_IMETHOD  GetSelected(PRBool *aSelected) const = 0;
    1: 
    1:   /**
    1:    *  called to discover where this frame, or a parent frame has user-select style
    1:    *  applied, which affects that way that it is selected.
    1:    *    
    1:    *  @param aIsSelectable out param. Set to true if the frame can be selected
    1:    *                       (i.e. is not affected by user-select: none)
    1:    *  @param aSelectStyle  out param. Returns the type of selection style found
    1:    *                        (using values defined in nsStyleConsts.h).
    1:    */
    1:   NS_IMETHOD  IsSelectable(PRBool* aIsSelectable, PRUint8* aSelectStyle) const = 0;
    1: 
    1:   /** 
    1:    *  Called to retrieve the SelectionController associated with the frame.
    1:    *  @param aSelCon will contain the selection controller associated with
    1:    *  the frame.
    1:    */
    1:   NS_IMETHOD  GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon) = 0;
    1: 
    1:   /**
 8295:    *  Call to get nsFrameSelection for this frame.
    1:    */
 8295:   already_AddRefed<nsFrameSelection> GetFrameSelection();
 8295: 
 8295:   /**
 8295:    * GetConstFrameSelection returns an object which methods are safe to use for
 8295:    * example in nsIFrame code.
 8295:    */
 8295:   const nsFrameSelection* GetConstFrameSelection();
    1: 
    1:   /** EndSelection related calls
    1:    */
    1: 
    1:   /**
    1:    *  Call to turn on/off mouseCapture at the view level. Needed by the ESM so
    1:    *  it must be in the public interface.
    1:    *  @param aPresContext presContext associated with the frame
    1:    *  @param aGrabMouseEvents PR_TRUE to enable capture, PR_FALSE to disable
    1:    */
    1:   NS_IMETHOD CaptureMouse(nsPresContext* aPresContext, PRBool aGrabMouseEvents) = 0;
    1: 
    1:   /**
    1:    *  called to find the previous/next character, word, or line  returns the actual 
    1:    *  nsIFrame and the frame offset.  THIS DOES NOT CHANGE SELECTION STATE
    1:    *  uses frame's begin selection state to start. if no selection on this frame will 
    1:    *  return NS_ERROR_FAILURE
    1:    *  @param aPOS is defined in nsFrameSelection
    1:    */
    1:   NS_IMETHOD PeekOffset(nsPeekOffsetStruct *aPos);
    1: 
    1:   /**
    1:    *  called to find the previous/next selectable leaf frame.
    1:    *  @param aDirection [in] the direction to move in (eDirPrevious or eDirNext)
    1:    *  @param aVisual [in] whether bidi caret behavior is visual (PR_TRUE) or logical (PR_FALSE)
    1:    *  @param aJumpLines [in] whether to allow jumping across line boundaries
    1:    *  @param aScrollViewStop [in] whether to stop when reaching a scroll frame boundary
    1:    *  @param aOutFrame [out] the previous/next selectable leaf frame
    1:    *  @param aOutOffset [out] 0 indicates that we arrived at the beginning of the output frame;
    1:    *                          -1 indicates that we arrived at its end.
    1:    *  @param aOutJumpedLine [out] whether this frame and the returned frame are on different lines
    1:    */
    1:   nsresult GetFrameFromDirection(nsDirection aDirection, PRBool aVisual,
    1:                                  PRBool aJumpLines, PRBool aScrollViewStop, 
    1:                                  nsIFrame** aOutFrame, PRInt32* aOutOffset, PRBool* aOutJumpedLine);
    1: 
    1:   /**
    1:    *  called to see if the children of the frame are visible from indexstart to index end.
    1:    *  this does not change any state. returns PR_TRUE only if the indexes are valid and any of
    1:    *  the children are visible.  for textframes this index is the character index.
    1:    *  if aStart = aEnd result will be PR_FALSE
    1:    *  @param aStart start index of first child from 0-N (number of children)
    1:    *  @param aEnd   end index of last child from 0-N
    1:    *  @param aRecurse should this frame talk to siblings to get to the contents other children?
    1:    *  @param aFinished did this frame have the aEndIndex? or is there more work to do
    1:    *  @param _retval  return value true or false. false = range is not rendered.
    1:    */
    1:   NS_IMETHOD CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval)=0;
    1: 
    1:   /**
    1:    * Called to tell a frame that one of its child frames is dirty (i.e.,
    1:    * has the NS_FRAME_IS_DIRTY *or* NS_FRAME_HAS_DIRTY_CHILDREN bit
    1:    * set).  This should always set the NS_FRAME_HAS_DIRTY_CHILDREN on
    1:    * the frame, and may do other work.
    1:    */
    1:   virtual void ChildIsDirty(nsIFrame* aChild) = 0;
    1: 
    1:   /**
    1:    * Called to retrieve this frame's accessible.
    1:    * If this frame implements Accessibility return a valid accessible
    1:    * If not return NS_ERROR_NOT_IMPLEMENTED.
    1:    * Note: nsAccessible must be refcountable. Do not implement directly on your frame
    1:    * Use a mediatior of some kind.
    1:    */
    1: #ifdef ACCESSIBILITY
    1:   NS_IMETHOD GetAccessible(nsIAccessible** aAccessible) = 0;
    1: #endif
    1: 
    1:   /**
    1:    * Get the frame whose style context should be the parent of this
    1:    * frame's style context (i.e., provide the parent style context).
    1:    * This frame must either be an ancestor of this frame or a child.  If
    1:    * this frame returns a child frame, then the child frame must be sure
    1:    * to return a grandparent or higher!
    1:    *
    1:    * @param aPresContext:   PresContext
    1:    * @param aProviderFrame: The frame whose style context should be the
    1:    *                        parent of this frame's style context.  Null
    1:    *                        is permitted, and means that this frame's
    1:    *                        style context should be the root of the
    1:    *                        style context tree.
    1:    * @param aIsChild:       True if |aProviderFrame| is set to a child
    1:    *                        of this frame; false if it is an ancestor or
    1:    *                        null.
    1:    */
    1:   NS_IMETHOD GetParentStyleContextFrame(nsPresContext* aPresContext,
    1:                                         nsIFrame**      aProviderFrame,
    1:                                         PRBool*         aIsChild) = 0;
    1: 
    1:   /**
    1:    * Determines whether a frame is visible for painting;
    1:    * taking into account whether it is painting a selection or printing.
    1:    */
    1:   PRBool IsVisibleForPainting(nsDisplayListBuilder* aBuilder);
    1:   /**
    1:    * Determines whether a frame is visible for painting or collapsed;
    1:    * taking into account whether it is painting a selection or printing,
    1:    */
    1:   PRBool IsVisibleOrCollapsedForPainting(nsDisplayListBuilder* aBuilder);
    1:   /**
    1:    * As above, but slower because we have to recompute some stuff that
    1:    * aBuilder already has.
    1:    */
    1:   PRBool IsVisibleForPainting();
    1:   /**
    1:    * Check whether this frame is visible in the current selection. Returns
    1:    * PR_TRUE if there is no current selection.
    1:    */
    1:   PRBool IsVisibleInSelection(nsDisplayListBuilder* aBuilder);
    1: 
    1:   /**
    1:    * Overridable function to determine whether this frame should be considered
    1:    * "in" the given non-null aSelection for visibility purposes.
    1:    */  
    1:   virtual PRBool IsVisibleInSelection(nsISelection* aSelection);
    1: 
    1:   /**
    1:    * Determines whether this frame is a pseudo stacking context, looking
    1:    * only as style --- i.e., assuming that it's in-flow and not a replaced
    1:    * element.
    1:    */
    1:   PRBool IsPseudoStackingContextFromStyle() {
    1:     const nsStyleDisplay* disp = GetStyleDisplay();
    1:     return disp->mOpacity != 1.0f || disp->IsPositioned();
    1:   }
    1:   
    1:   virtual PRBool HonorPrintBackgroundSettings() { return PR_TRUE; }
    1: 
    1:   /**
    1:    * Determine whether the frame is logically empty, which is roughly
    1:    * whether the layout would be the same whether or not the frame is
    1:    * present.  Placeholder frames should return true.  Block frames
    1:    * should be considered empty whenever margins collapse through them,
    1:    * even though those margins are relevant.  Text frames containing
    1:    * only whitespace that does not contribute to the height of the line
    1:    * should return true.
    1:    */
    1:   virtual PRBool IsEmpty() = 0;
    1:   /**
    1:    * Return the same as IsEmpty(). This may only be called after the frame
    1:    * has been reflowed and before any further style or content changes.
    1:    */
    1:   virtual PRBool CachedIsEmpty();
    1:   /**
    1:    * Determine whether the frame is logically empty, assuming that all
    1:    * its children are empty.
    1:    */
    1:   virtual PRBool IsSelfEmpty() = 0;
    1: 
    1:   /**
    1:    * IsGeneratedContentFrame returns whether a frame corresponds to
    1:    * generated content
    1:    *
    1:    * @return whether the frame correspods to generated content
    1:    */
    1:   PRBool IsGeneratedContentFrame() {
    1:     return (mState & NS_FRAME_GENERATED_CONTENT) != 0;
    1:   }
    1: 
    1:   /**
    1:    * IsPseudoFrame returns whether a frame is a pseudo frame (eg an
    1:    * anonymous table-row frame created for a CSS table-cell without an
    1:    * enclosing table-row.
    1:    *
    1:    * @param aParentContent the content node corresponding to the parent frame
    1:    * @return whether the frame is a pseudo frame
    1:    */   
    1:   PRBool IsPseudoFrame(nsIContent* aParentContent) {
    1:     return mContent == aParentContent;
    1:   }
    1: 
    1: 
    1:   NS_HIDDEN_(void*) GetProperty(nsIAtom* aPropertyName,
    1:                                 nsresult* aStatus = nsnull) const;
    1:   virtual NS_HIDDEN_(void*) GetPropertyExternal(nsIAtom*  aPropertyName,
    1:                                                 nsresult* aStatus) const;
    1:   NS_HIDDEN_(nsresult) SetProperty(nsIAtom*           aPropertyName,
    1:                                    void*              aValue,
    1:                                    NSPropertyDtorFunc aDestructor = nsnull,
    1:                                    void*              aDtorData = nsnull);
    1:   NS_HIDDEN_(nsresult) DeleteProperty(nsIAtom* aPropertyName) const;
    1:   NS_HIDDEN_(void*) UnsetProperty(nsIAtom* aPropertyName,
    1:                                   nsresult* aStatus = nsnull) const;
    1: 
    1: #define NS_GET_BASE_LEVEL(frame) \
    1: NS_PTR_TO_INT32(frame->GetProperty(nsGkAtoms::baseLevel))
    1: 
    1: #define NS_GET_EMBEDDING_LEVEL(frame) \
    1: NS_PTR_TO_INT32(frame->GetProperty(nsGkAtoms::embeddingLevel))
    1: 
    1:   /**
    1:    * Return PR_TRUE if and only if this frame obeys visibility:hidden.
    1:    * if it does not, then nsContainerFrame will hide its view even though
    1:    * this means children can't be made visible again.
    1:    */
    1:   virtual PRBool SupportsVisibilityHidden() { return PR_TRUE; }
    1: 
    1:   /**
    1:    * Returns PR_TRUE if the frame is absolutely positioned and has a clip
    1:    * rect set via the 'clip' property. If true, then we also set aRect
    1:    * to the computed clip rect coordinates relative to this frame's origin.
    1:    * aRect must not be null!
    1:    */
  462:   PRBool GetAbsPosClipRect(const nsStyleDisplay* aDisp, nsRect* aRect,
  462:                            const nsSize& aSize);
    1: 
    1:   /**
    1:    * Check if this frame is focusable and in the current tab order.
    1:    * Tabbable is indicated by a nonnegative tabindex & is a subset of focusable.
    1:    * For example, only the selected radio button in a group is in the 
    1:    * tab order, unless the radio group has no selection in which case
    1:    * all of the visible, non-disabled radio buttons in the group are 
    1:    * in the tab order. On the other hand, all of the visible, non-disabled 
    1:    * radio buttons are always focusable via clicking or script.
    1:    * Also, depending on the pref accessibility.tabfocus some widgets may be 
    1:    * focusable but removed from the tab order. This is the default on
    1:    * Mac OS X, where fewer items are focusable.
    1:    * @param  [in, optional] aTabIndex the computed tab index
    1:    *         < 0 if not tabbable
    1:    *         == 0 if in normal tab order
    1:    *         > 0 can be tabbed to in the order specified by this value
    1:    * @param  [in, optional] aWithMouse, is this focus query for mouse clicking
    1:    * @return whether the frame is focusable via mouse, kbd or script.
    1:    */
    1:   virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull, PRBool aWithMouse = PR_FALSE);
    1: 
    1:   // BOX LAYOUT METHODS
    1:   // These methods have been migrated from nsIBox and are in the process of
    1:   // being refactored. DO NOT USE OUTSIDE OF XUL.
 3103:   PRBool IsBoxFrame() const
 3103:   {
 3103:     return IsFrameOfType(nsIFrame::eXULBox);
 3103:   }
    1:   PRBool IsBoxWrapped() const
    1:   { return (!IsBoxFrame() && mParent && mParent->IsBoxFrame()); }
    1: 
    1:   enum Halignment {
    1:     hAlign_Left,
    1:     hAlign_Right,
    1:     hAlign_Center
    1:   };
    1: 
    1:   enum Valignment {
    1:     vAlign_Top,
    1:     vAlign_Middle,
    1:     vAlign_BaseLine,
    1:     vAlign_Bottom
    1:   };
    1: 
    1:   /**
    1:    * This calculates the minimum size required for a box based on its state
    1:    * @param[in] aBoxLayoutState The desired state to calculate for
    1:    * @return The minimum size
    1:    */
    1:   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) = 0;
    1: 
    1:   /**
    1:    * This calculates the preferred size of a box based on its state
    1:    * @param[in] aBoxLayoutState The desired state to calculate for
    1:    * @return The preferred size
    1:    */
    1:   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) = 0;
    1: 
    1:   /**
    1:    * This calculates the maximum size for a box based on its state
    1:    * @param[in] aBoxLayoutState The desired state to calculate for
    1:    * @return The maximum size
    1:    */    
    1:   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) = 0;
    1: 
    1:   /**
    1:    * This returns the minimum size for the scroll area if this frame is
    1:    * being scrolled. Usually it's (0,0).
    1:    */
    1:   virtual nsSize GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) = 0;
    1: 
    1:   // Implemented in nsBox, used in nsBoxFrame
    1:   PRUint32 GetOrdinal(nsBoxLayoutState& aBoxLayoutState);
    1: 
    1:   virtual nscoord GetFlex(nsBoxLayoutState& aBoxLayoutState) = 0;
    1:   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
    1:   virtual PRBool IsCollapsed(nsBoxLayoutState& aBoxLayoutState) = 0;
    1:   // This does not alter the overflow area. If the caller is changing
    1:   // the box size, the caller is responsible for updating the overflow
    1:   // area. It's enough to just call Layout or SyncLayout on the
    1:   // box. You can pass PR_TRUE to aRemoveOverflowArea as a
    1:   // convenience.
    1:   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
    1:                          PRBool aRemoveOverflowArea = PR_FALSE)=0;
    1:   NS_HIDDEN_(nsresult) Layout(nsBoxLayoutState& aBoxLayoutState);
    1:   nsIBox* GetChildBox() const
    1:   {
    1:     // box layout ends at box-wrapped frames, so don't allow these frames
    1:     // to report child boxes.
    1:     return IsBoxFrame() ? GetFirstChild(nsnull) : nsnull;
    1:   }
    1:   nsIBox* GetNextBox() const
    1:   {
    1:     return (mParent && mParent->IsBoxFrame()) ? mNextSibling : nsnull;
    1:   }
    1:   nsIBox* GetParentBox() const
    1:   {
    1:     return (mParent && mParent->IsBoxFrame()) ? mParent : nsnull;
    1:   }
    1:   // Box methods.  Note that these do NOT just get the CSS border, padding,
    1:   // etc.  They also talk to nsITheme.
    1:   NS_IMETHOD GetBorderAndPadding(nsMargin& aBorderAndPadding);
    1:   NS_IMETHOD GetBorder(nsMargin& aBorder)=0;
    1:   NS_IMETHOD GetPadding(nsMargin& aBorderAndPadding)=0;
    1:   NS_IMETHOD GetMargin(nsMargin& aMargin)=0;
    1:   NS_IMETHOD SetLayoutManager(nsIBoxLayout* aLayout)=0;
    1:   NS_IMETHOD GetLayoutManager(nsIBoxLayout** aLayout)=0;
    1:   NS_HIDDEN_(nsresult) GetClientRect(nsRect& aContentRect);
    1: 
    1:   // For nsSprocketLayout
    1:   virtual Valignment GetVAlign() const = 0;
    1:   virtual Halignment GetHAlign() const = 0;
    1: 
    1:   PRBool IsHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
    1:   PRBool IsNormalDirection() const { return (mState & NS_STATE_IS_DIRECTION_NORMAL) != 0; }
    1: 
    1:   NS_HIDDEN_(nsresult) Redraw(nsBoxLayoutState& aState, const nsRect* aRect = nsnull, PRBool aImmediate = PR_FALSE);
    1:   NS_IMETHOD RelayoutChildAtOrdinal(nsBoxLayoutState& aState, nsIBox* aChild)=0;
    1:   virtual PRBool GetMouseThrough() const = 0;
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   NS_IMETHOD SetDebug(nsBoxLayoutState& aState, PRBool aDebug)=0;
    1:   NS_IMETHOD GetDebug(PRBool& aDebug)=0;
    1: 
    1:   NS_IMETHOD DumpBox(FILE* out)=0;
    1: #endif
    1: 
    1:   // Only nsDeckFrame requires that all its children have widgets
    1:   virtual PRBool ChildrenMustHaveWidgets() const { return PR_FALSE; }
    1: 
    1:   /**
    1:    * @return PR_TRUE if this text frame ends with a newline character.  It
    1:    * should return PR_FALSE if this is not a text frame.
    1:    */
    1:   virtual PRBool HasTerminalNewline() const;
    1: 
    1:   static PRBool AddCSSPrefSize(nsBoxLayoutState& aState, nsIBox* aBox, nsSize& aSize);
    1:   static PRBool AddCSSMinSize(nsBoxLayoutState& aState, nsIBox* aBox, nsSize& aSize);
    1:   static PRBool AddCSSMaxSize(nsBoxLayoutState& aState, nsIBox* aBox, nsSize& aSize);
    1:   static PRBool AddCSSFlex(nsBoxLayoutState& aState, nsIBox* aBox, nscoord& aFlex);
    1:   static PRBool AddCSSCollapsed(nsBoxLayoutState& aState, nsIBox* aBox, PRBool& aCollapsed);
    1:   static PRBool AddCSSOrdinal(nsBoxLayoutState& aState, nsIBox* aBox, PRUint32& aOrdinal);
    1: 
    1:   // END OF BOX LAYOUT METHODS
    1:   // The above methods have been migrated from nsIBox and are in the process of
    1:   // being refactored. DO NOT USE OUTSIDE OF XUL.
    1: 
    1:   /**
    1:    * gets the first or last possible caret position within the frame
    1:    *
    1:    * @param  [in] aStart
    1:    *         true  for getting the first possible caret position
    1:    *         false for getting the last possible caret position
    1:    * @return The caret position in an nsPeekOffsetStruct (the
    1:    *         fields set are mResultContent and mContentOffset;
    1:    *         the returned value is a 'best effort' in case errors
    1:    *         are encountered rummaging through the frame.
    1:    */
    1:   nsPeekOffsetStruct GetExtremeCaretPosition(PRBool aStart);
    1: 
17140:   /**
17140:    * Same thing as nsFrame::CheckInvalidateSizeChange, but more flexible.  The
17140:    * implementation of this method must not depend on the mRect or
17140:    * GetOverflowRect() of the frame!  Note that it's safe to assume in this
17140:    * method that the frame origin didn't change.  If it did, whoever moved the
17140:    * frame will invalidate as needed anyway.
17140:    */
17140:   void CheckInvalidateSizeChange(const nsRect& aOldRect,
17140:                                  const nsRect& aOldOverflowRect,
20711:                                  const nsSize& aNewDesiredSize);
17140: 
21112:   /**
21112:    * Get a line iterator for this frame, if supported.
21112:    *
21112:    * @return nsnull if no line iterator is supported.
21112:    * @note dispose the line iterator using nsILineIterator::DisposeLineIterator
21112:    */
21112:   virtual nsILineIterator* GetLineIterator() = 0;
21112: 
30638:   /**
30638:    * If this frame is a next-in-flow, and its prev-in-flow has something on its
30638:    * overflow list, pull those frames into the child list of this one.
30638:    */
30638:   virtual void PullOverflowsFromPrevInFlow() {}
30638: 
    1: protected:
    1:   // Members
    1:   nsRect           mRect;
    1:   nsIContent*      mContent;
    1:   nsStyleContext*  mStyleContext;
    1:   nsIFrame*        mParent;
    1:   nsIFrame*        mNextSibling;  // singly-linked list of frames
    1:   nsFrameState     mState;
    1: 
26950:   // When there is an overflow area only slightly larger than mRect,
26950:   // we store a set of four 1-byte deltas from the edges of mRect
26950:   // rather than allocating a whole separate rectangle property.
26950:   // Note that these are unsigned values, all measured "outwards"
26950:   // from the edges of mRect, so /mLeft/ and /mTop/ are reversed from
26950:   // our normal coordinate system.
26950:   // If mOverflow.mType == NS_FRAME_OVERFLOW_LARGE, then the
26950:   // delta values are not meaningful and the overflow area is stored
26950:   // as a separate rect property.
26950:   union {
26950:     PRUint32  mType;
26950:     struct {
26950:       PRUint8 mLeft;
26950:       PRUint8 mTop;
26950:       PRUint8 mRight;
26950:       PRUint8 mBottom;
26950:     } mDeltas;
26950:   } mOverflow;
26950:   
    1:   // Helpers
    1:   /**
    1:    * For frames that have top-level windows (top-level viewports,
    1:    * comboboxes, menupoups) this function will invalidate the window.
    1:    */
19380:   void InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags);
    1: 
    1:   /**
15700:    * Gets the overflow area for any properties that are common to all types of frames
15700:    * e.g. outlines.
15700:    */
20711:   nsRect GetAdditionalOverflow(const nsRect& aOverflowArea, const nsSize& aNewSize,
20711:                                PRBool* aHasOutlineOrEffects);
15700: 
15700:   /**
    1:    * Can we stop inside this frame when we're skipping non-rendered whitespace?
    1:    * @param  aForward [in] Are we moving forward (or backward) in content order.
    1:    * @param  aOffset [in/out] At what offset into the frame to start looking.
    1:    *         on output - what offset was reached (whether or not we found a place to stop).
    1:    * @return PR_TRUE: An appropriate offset was found within this frame,
    1:    *         and is given by aOffset.
    1:    *         PR_FALSE: Not found within this frame, need to try the next frame.
    1:    */
    1:   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset) = 0;
    1:   
    1:   /**
    1:    * Search the frame for the next character
    1:    * @param  aForward [in] Are we moving forward (or backward) in content order.
    1:    * @param  aOffset [in/out] At what offset into the frame to start looking.
    1:    *         on output - what offset was reached (whether or not we found a place to stop).
    1:    * @return PR_TRUE: An appropriate offset was found within this frame,
    1:    *         and is given by aOffset.
    1:    *         PR_FALSE: Not found within this frame, need to try the next frame.
    1:    */
    1:   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset) = 0;
    1:   
    1:   /**
    1:    * Search the frame for the next word boundary
    1:    * @param  aForward [in] Are we moving forward (or backward) in content order.
    1:    * @param  aWordSelectEatSpace [in] PR_TRUE: look for non-whitespace following
    1:    *         whitespace (in the direction of movement).
    1:    *         PR_FALSE: look for whitespace following non-whitespace (in the
    1:    *         direction  of movement).
    1:    * @param  aIsKeyboardSelect [in] Was the action initiated by a keyboard operation?
    1:    *         If PR_TRUE, punctuation immediately following a word is considered part
    1:    *         of that word. Otherwise, a sequence of punctuation is always considered
    1:    *         as a word on its own.
    1:    * @param  aOffset [in/out] At what offset into the frame to start looking.
    1:    *         on output - what offset was reached (whether or not we found a place to stop).
 5453:    * @param  aState [in/out] the state that is carried from frame to frame
    1:    * @return PR_TRUE: An appropriate offset was found within this frame,
    1:    *         and is given by aOffset.
    1:    *         PR_FALSE: Not found within this frame, need to try the next frame.
    1:    */
 5453:   struct PeekWordState {
 5453:     // true when we're still at the start of the search, i.e., we can't return
 5453:     // this point as a valid offset!
 5453:     PRPackedBool mAtStart;
 5453:     // true when we've encountered at least one character of the pre-boundary type
 5453:     // (whitespace if aWordSelectEatSpace is true, non-whitespace otherwise)
 5453:     PRPackedBool mSawBeforeType;
 5453:     // true when the last character encountered was punctuation
 5453:     PRPackedBool mLastCharWasPunctuation;
12505:     // true when the last character encountered was whitespace
12505:     PRPackedBool mLastCharWasWhitespace;
12505:     // true when we've seen non-punctuation since the last whitespace
12505:     PRPackedBool mSeenNonPunctuationSinceWhitespace;
 7679:     // text that's *before* the current frame when aForward is true, *after*
12505:     // the current frame when aForward is false. Only includes the text
12505:     // on the current line.
 7679:     nsAutoString mContext;
 5453: 
 5453:     PeekWordState() : mAtStart(PR_TRUE), mSawBeforeType(PR_FALSE),
12505:         mLastCharWasPunctuation(PR_FALSE), mLastCharWasWhitespace(PR_FALSE),
12505:         mSeenNonPunctuationSinceWhitespace(PR_FALSE) {}
 5453:     void SetSawBeforeType() { mSawBeforeType = PR_TRUE; }
12505:     void Update(PRBool aAfterPunctuation, PRBool aAfterWhitespace) {
 5453:       mLastCharWasPunctuation = aAfterPunctuation;
12505:       mLastCharWasWhitespace = aAfterWhitespace;
12505:       if (aAfterWhitespace) {
12505:         mSeenNonPunctuationSinceWhitespace = PR_FALSE;
12505:       } else if (!aAfterPunctuation) {
12505:         mSeenNonPunctuationSinceWhitespace = PR_TRUE;
12505:       }
 5453:       mAtStart = PR_FALSE;
 5453:     }
 5453:   };
    1:   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
 5453:                                 PRInt32* aOffset, PeekWordState* aState) = 0;
    1: 
    1:   /**
    1:    * Search for the first paragraph boundary before or after the given position
    1:    * @param  aPos See description in nsFrameSelection.h. The following fields are
    1:    *              used by this method: 
    1:    *              Input: mDirection
    1:    *              Output: mResultContent, mContentOffset
    1:    */
    1:    nsresult PeekOffsetParagraph(nsPeekOffsetStruct *aPos);
    1: 
    1: private:
11909:   nsRect* GetOverflowAreaProperty(PRBool aCreateIfNecessary = PR_FALSE);
26950:   void SetOverflowRect(const nsRect& aRect);
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * nsWeakFrame can be used to keep a reference to a nsIFrame in a safe way.
    1:  * Whenever an nsIFrame object is deleted, the nsWeakFrames pointing
    1:  * to it will be cleared.
    1:  *
    1:  * Create nsWeakFrame object when it is sure that nsIFrame object
    1:  * is alive and after some operations which may destroy the nsIFrame
    1:  * (for example any DOM modifications) use IsAlive() or GetFrame() methods to
    1:  * check whether it is safe to continue to use the nsIFrame object.
    1:  *
    1:  * @note The usage of this class should be kept to a minimum.
    1:  */
    1: 
    1: class nsWeakFrame {
    1: public:
 8127:   nsWeakFrame() : mPrev(nsnull), mFrame(nsnull) { }
 8127: 
    1:   nsWeakFrame(nsIFrame* aFrame) : mPrev(nsnull), mFrame(nsnull)
    1:   {
    1:     Init(aFrame);
    1:   }
    1: 
    1:   nsWeakFrame& operator=(nsWeakFrame& aOther) {
    1:     Init(aOther.GetFrame());
    1:     return *this;
    1:   }
    1: 
    1:   nsWeakFrame& operator=(nsIFrame* aFrame) {
    1:     Init(aFrame);
    1:     return *this;
    1:   }
    1: 
    1:   nsIFrame* operator->()
    1:   {
    1:     return mFrame;
    1:   }
    1: 
    1:   operator nsIFrame*()
    1:   {
    1:     return mFrame;
    1:   }
    1: 
    1:   void Clear(nsIPresShell* aShell) {
    1:     if (aShell) {
    1:       aShell->RemoveWeakFrame(this);
    1:     }
    1:     mFrame = nsnull;
    1:     mPrev = nsnull;
    1:   }
    1: 
    1:   PRBool IsAlive() { return !!mFrame; }
    1: 
    1:   nsIFrame* GetFrame() { return mFrame; }
    1: 
    1:   nsWeakFrame* GetPreviousWeakFrame() { return mPrev; }
    1: 
    1:   void SetPreviousWeakFrame(nsWeakFrame* aPrev) { mPrev = aPrev; }
    1: 
    1:   ~nsWeakFrame()
    1:   {
  238:     Clear(mFrame ? mFrame->PresContext()->GetPresShell() : nsnull);
    1:   }
    1: private:
    1:   void Init(nsIFrame* aFrame);
    1: 
    1:   nsWeakFrame*  mPrev;
    1:   nsIFrame*     mFrame;
    1: };
    1: 
    1: #endif /* nsIFrame_h___ */
