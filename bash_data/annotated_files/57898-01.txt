    1: //* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Url Classifier code
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Tony Chang <tony@ponderer.org> (original author)
    1:  *   Brett Wilson <brettw@gmail.com>
 4024:  *   Dave Camp <dcamp@mozilla.com>
38022:  *   David Dahl <ddahl@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
 5528: #include "nsAutoPtr.h"
 4024: #include "nsCOMPtr.h"
    1: #include "mozIStorageService.h"
    1: #include "mozIStorageConnection.h"
    1: #include "mozIStorageStatement.h"
 4024: #include "mozStorageHelper.h"
    1: #include "mozStorageCID.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsAutoLock.h"
    1: #include "nsCRT.h"
14354: #include "nsDataHashtable.h"
 4024: #include "nsICryptoHash.h"
12346: #include "nsICryptoHMAC.h"
    1: #include "nsIDirectoryService.h"
13256: #include "nsIKeyModule.h"
    1: #include "nsIObserverService.h"
 5528: #include "nsIPrefBranch.h"
 5528: #include "nsIPrefBranch2.h"
 5528: #include "nsIPrefService.h"
    1: #include "nsIProperties.h"
    1: #include "nsIProxyObjectManager.h"
    1: #include "nsToolkitCompsCID.h"
 4024: #include "nsIUrlClassifierUtils.h"
    1: #include "nsUrlClassifierDBService.h"
12346: #include "nsUrlClassifierUtils.h"
 5528: #include "nsURILoader.h"
    1: #include "nsString.h"
24031: #include "nsReadableUtils.h"
    1: #include "nsTArray.h"
 4024: #include "nsNetUtil.h"
 4024: #include "nsNetCID.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsXPCOMStrings.h"
    1: #include "prlog.h"
 4024: #include "prlock.h"
    1: #include "prprf.h"
10941: #include "prnetdb.h"
 4024: #include "zlib.h"
 4024: 
16701: // Needed to interpert mozIStorageConnection::GetLastError
16701: #include <sqlite3.h>
16701: 
 4024: /**
 4024:  * The DBServices stores a set of Fragments.  A fragment is one URL
 4024:  * fragment containing two or more domain components and some number
 4024:  * of path components.
 4024:  *
 4024:  * Fragment examples:
 4024:  *   example.com/
 4024:  *   www.example.com/foo/bar
 4024:  *   www.mail.example.com/mail
 4024:  *
 4024:  * Fragments are described in "Simplified Regular Expression Lookup"
 4024:  * section of the protocol document at
 4024:  * http://code.google.com/p/google-safe-browsing/wiki/Protocolv2Spec
 4024:  *
10941:  * A fragment is associated with a domain.  The domain for a given
10941:  * fragment is the three-host-component domain of the fragment (two
10941:  * host components for URLs with only two components) with a trailing
10941:  * slash.  So for the fragments listed above, the domains are
10941:  * example.com/, www.example.com/ and mail.example.com/.
 4024:  *
 4024:  * Fragments and domains are hashed in the database.  The hash is described
 4024:  * in the protocol document, but it's basically a truncated SHA256 hash.
10941:  *
10941:  * A (table, chunk id, domain key, fragment) tuple is referred to as
10941:  * an Entry.
 4024:  */
    1: 
    1: // NSPR_LOG_MODULES=UrlClassifierDbService:5
    1: #if defined(PR_LOGGING)
    1: static const PRLogModuleInfo *gUrlClassifierDbServiceLog = nsnull;
    1: #define LOG(args) PR_LOG(gUrlClassifierDbServiceLog, PR_LOG_DEBUG, args)
 4024: #define LOG_ENABLED() PR_LOG_TEST(gUrlClassifierDbServiceLog, 4)
    1: #else
    1: #define LOG(args)
 4024: #define LOG_ENABLED() (PR_FALSE)
    1: #endif
    1: 
 8732: // Schema versioning:  note that we don't bother to migrate between different
 8732: // versions of the schema, we just start fetching the data freshly with each
 8732: // migration.
 8732: 
 8732: // The database filename is updated when there is an incompatible
 8732: // schema change and we expect both implementations to continue
 8732: // accessing the same database (such as between stable versions of the
 8732: // platform).
 4024: #define DATABASE_FILENAME "urlclassifier3.sqlite"
 4024: 
 8732: // The implementation version is updated during development when we
 8732: // want to change schema, or to recover from updating bugs.  When an
 8732: // implementation version change is detected, the database is scrapped
 8732: // and we start over.
38022: #define IMPLEMENTATION_VERSION 7
 8732: 
 4024: #define MAX_HOST_COMPONENTS 5
 4024: #define MAX_PATH_COMPONENTS 4
 4024: 
 4024: // Updates will fail if fed chunks larger than this
 4024: #define MAX_CHUNK_SIZE (1024 * 1024)
 4024: 
 5528: // Prefs for implementing nsIURIClassifier to block page loads
 5528: #define CHECK_MALWARE_PREF      "browser.safebrowsing.malware.enabled"
 5528: #define CHECK_MALWARE_DEFAULT   PR_FALSE
 5528: 
 8643: #define CHECK_PHISHING_PREF     "browser.safebrowsing.enabled"
 8643: #define CHECK_PHISHING_DEFAULT  PR_FALSE
 8643: 
12334: #define GETHASH_NOISE_PREF      "urlclassifier.gethashnoise"
12334: #define GETHASH_NOISE_DEFAULT   4
12334: 
14354: #define GETHASH_TABLES_PREF     "urlclassifier.gethashtables"
14354: 
14354: #define CONFIRM_AGE_PREF        "urlclassifier.confirm-age"
14354: #define CONFIRM_AGE_DEFAULT_SEC (45 * 60)
14354: 
14883: #define UPDATE_CACHE_SIZE_PREF    "urlclassifier.updatecachemax"
14883: #define UPDATE_CACHE_SIZE_DEFAULT -1
14883: 
20648: // MRU cache sizes for remembering clean lookups
20648: #define CLEAN_HOST_KEYS_SIZE 16
20648: #define CLEAN_FRAGMENTS_SIZE 32
20648: 
15023: // Amount of time to spend updating before committing and delaying, in
15023: // seconds.  This is checked after each update stream, so the actual
15023: // time spent can be higher than this, depending on update stream size.
15023: #define UPDATE_WORKING_TIME         "urlclassifier.workingtime"
15023: #define UPDATE_WORKING_TIME_DEFAULT 5
15023: 
15023: // The amount of time to delay after hitting UPDATE_WORKING_TIME, in
15023: // seconds.
15023: #define UPDATE_DELAY_TIME           "urlclassifier.updatetime"
15023: #define UPDATE_DELAY_TIME_DEFAULT   60
15023: 
10212: class nsUrlClassifierDBServiceWorker;
10212: 
    1: // Singleton instance.
    1: static nsUrlClassifierDBService* sUrlClassifierDBService;
    1: 
    1: // Thread that we do the updates on.
    1: static nsIThread* gDbBackgroundThread = nsnull;
    1: 
  762: // Once we've committed to shutting down, don't do work in the background
  762: // thread.
  762: static PRBool gShuttingDownThread = PR_FALSE;
  762: 
14354: static PRInt32 gFreshnessGuarantee = CONFIRM_AGE_DEFAULT_SEC;
14354: 
14883: static PRInt32 gUpdateCacheSize = UPDATE_CACHE_SIZE_DEFAULT;
14883: 
15023: static PRInt32 gWorkingTimeThreshold = UPDATE_WORKING_TIME_DEFAULT;
15023: static PRInt32 gDelayTime = UPDATE_DELAY_TIME_DEFAULT;
15023: 
14354: static void
14354: SplitTables(const nsACString& str, nsTArray<nsCString>& tables)
14354: {
14354:   tables.Clear();
14354: 
14354:   nsACString::const_iterator begin, iter, end;
14354:   str.BeginReading(begin);
14354:   str.EndReading(end);
14354:   while (begin != end) {
14354:     iter = begin;
14354:     FindCharInReadable(',', iter, end);
14354:     tables.AppendElement(Substring(begin, iter));
14354:     begin = iter;
14354:     if (begin != end)
14354:       begin++;
14354:   }
14354: }
14354: 
 4024: // -------------------------------------------------------------------------
 4024: // Hash class implementation
 4024: 
10941: // A convenience wrapper around the potentially-truncated hash for a
10941: // domain or fragment.
10941: 
10941: template <PRUint32 S>
 4024: struct nsUrlClassifierHash
    1: {
10941:   static const PRUint32 sHashSize = S;
10941:   typedef nsUrlClassifierHash<S> self_type;
10941:   PRUint8 buf[S];
10941: 
10941:   nsresult FromPlaintext(const nsACString& plainText, nsICryptoHash *hash) {
 4024:     // From the protocol doc:
 4024:     // Each entry in the chunk is composed of the 128 most significant bits
 4024:     // of the SHA 256 hash of a suffix/prefix expression.
 4024: 
 4024:     nsresult rv = hash->Init(nsICryptoHash::SHA256);
 4024:     NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:     rv = hash->Update
 4024:       (reinterpret_cast<const PRUint8*>(plainText.BeginReading()),
 4024:        plainText.Length());
 4024:     NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:     nsCAutoString hashed;
 4024:     rv = hash->Finish(PR_FALSE, hashed);
 4024:     NS_ENSURE_SUCCESS(rv, rv);
 4024: 
10941:     NS_ASSERTION(hashed.Length() >= sHashSize,
 4024:                  "not enough characters in the hash");
 4024: 
10941:     memcpy(buf, hashed.BeginReading(), sHashSize);
 4024: 
 4024:     return NS_OK;
    1:   }
    1: 
10941:   void Assign(const nsACString& str) {
10941:     NS_ASSERTION(str.Length() >= sHashSize,
10941:                  "string must be at least sHashSize characters long");
10941:     memcpy(buf, str.BeginReading(), sHashSize);
 4024:   }
 4024: 
14354:   void Clear() {
14354:     memset(buf, 0, sizeof(buf));
14354:   }
14354: 
10941:   const PRBool operator==(const self_type& hash) const {
10941:     return (memcmp(buf, hash.buf, sizeof(buf)) == 0);
10941:   }
10941:   const PRBool operator!=(const self_type& hash) const {
10941:     return !(*this == hash);
10941:   }
10941:   const PRBool operator<(const self_type& hash) const {
10941:     return memcmp(buf, hash.buf, sizeof(self_type)) < 0;
10941:   }
10941:   const PRBool StartsWith(const nsUrlClassifierHash<PARTIAL_LENGTH>& hash) const {
10941:     NS_ASSERTION(sHashSize >= PARTIAL_LENGTH, "nsUrlClassifierHash must be at least PARTIAL_LENGTH bytes long");
10941:     return memcmp(buf, hash.buf, PARTIAL_LENGTH) == 0;
10941:   }
10941: };
10941: 
10941: typedef nsUrlClassifierHash<DOMAIN_LENGTH> nsUrlClassifierDomainHash;
10941: typedef nsUrlClassifierHash<PARTIAL_LENGTH> nsUrlClassifierPartialHash;
10941: typedef nsUrlClassifierHash<COMPLETE_LENGTH> nsUrlClassifierCompleteHash;
10941: 
10941: 
 4024: // -------------------------------------------------------------------------
 4024: // Entry class implementation
 4024: 
10941: // This class represents one entry in the classifier database.  It consists
10941: // of a table id, a chunk id, a domain hash, and a partial or complete hash.
 4024: class nsUrlClassifierEntry
 4024: {
 4024: public:
10941:   nsUrlClassifierEntry()
12334:     : mId(-1)
10941:     , mHavePartial(PR_FALSE)
10941:     , mHaveComplete(PR_FALSE)
10941:     , mTableId(0)
10941:     , mChunkId(0)
10941:     , mAddChunkId(0)
10941:     {}
 4024:   ~nsUrlClassifierEntry() {}
 4024: 
10941:   // Check that this entry could potentially match the complete hash.
10941:   PRBool Match(const nsUrlClassifierCompleteHash &hash);
10941: 
10941:   // Check that the sub entry should apply to this entry.
10941:   PRBool SubMatch(const nsUrlClassifierEntry& sub);
 4024: 
 4024:   // Clear out the entry structure
 4024:   void Clear();
 4024: 
10941:   // Set the partial hash for this domain.
10941:   void SetHash(const nsUrlClassifierPartialHash &partialHash) {
10941:     mPartialHash = partialHash;
10941:     mHavePartial = PR_TRUE;
10941:   }
10941: 
10941:   // Set the complete hash for this domain.
10941:   void SetHash(const nsUrlClassifierCompleteHash &completeHash) {
10941:     mCompleteHash = completeHash;
10941:     mHaveComplete = PR_TRUE;
10941:   }
10941: 
10941:   PRBool operator== (const nsUrlClassifierEntry& entry) const {
10941:     return ! (mTableId != entry.mTableId ||
10941:               mChunkId != entry.mChunkId ||
10941:               mHavePartial != entry.mHavePartial ||
10941:               (mHavePartial && mPartialHash != entry.mPartialHash) ||
10941:               mHaveComplete != entry.mHaveComplete ||
10941:               (mHaveComplete && mCompleteHash != entry.mCompleteHash));
10941:   }
10941: 
10941:   PRBool operator< (const nsUrlClassifierEntry& entry) const {
10941:     return (mTableId < entry.mTableId ||
10941:             mChunkId < entry.mChunkId ||
10941:             mHavePartial && !entry.mHavePartial ||
10941:             (mHavePartial && mPartialHash < entry.mPartialHash) ||
10941:             mHaveComplete && !entry.mHaveComplete ||
10941:             (mHaveComplete && mCompleteHash < entry.mCompleteHash));
10941:   }
10941: 
12334:   PRInt64 mId;
10941: 
10941:   nsUrlClassifierDomainHash mKey;
10941: 
10941:   PRBool mHavePartial;
10941:   nsUrlClassifierPartialHash mPartialHash;
10941: 
10941:   PRBool mHaveComplete;
10941:   nsUrlClassifierCompleteHash mCompleteHash;
10941: 
10865:   PRUint32 mTableId;
10941:   PRUint32 mChunkId;
10941:   PRUint32 mAddChunkId;
10941: };
10941: 
10941: PRBool
10941: nsUrlClassifierEntry::Match(const nsUrlClassifierCompleteHash &hash)
10941: {
10941:   if (mHaveComplete)
10941:     return mCompleteHash == hash;
10941: 
10941:   if (mHavePartial)
10941:     return hash.StartsWith(mPartialHash);
10941: 
10941:   return PR_FALSE;
10854: }
10854: 
10865: PRBool
10941: nsUrlClassifierEntry::SubMatch(const nsUrlClassifierEntry &subEntry)
10865: {
10941:   if ((mTableId != subEntry.mTableId) || (mChunkId != subEntry.mAddChunkId))
10865:     return PR_FALSE;
10941: 
10941:   if (subEntry.mHaveComplete)
10941:     return mHaveComplete && mCompleteHash == subEntry.mCompleteHash;
10941: 
10941:   if (subEntry.mHavePartial)
10941:     return mHavePartial && mPartialHash == subEntry.mPartialHash;
 4024: 
 4024:   return PR_FALSE;
 4024: }
 4024: 
 4024: void
 4024: nsUrlClassifierEntry::Clear()
 4024: {
12334:   mId = -1;
10941:   mHavePartial = PR_FALSE;
10941:   mHaveComplete = PR_FALSE;
 4024: }
    1: 
    1: // -------------------------------------------------------------------------
10941: // Lookup result class implementation
10941: 
10941: // This helper class wraps a nsUrlClassifierEntry found during a lookup.
10941: class nsUrlClassifierLookupResult
10941: {
10941: public:
14354:   nsUrlClassifierLookupResult() : mConfirmed(PR_FALSE), mNoise(PR_FALSE) {
14354:     mLookupFragment.Clear();
14354:   }
10941:   ~nsUrlClassifierLookupResult() {}
10941: 
10941:   PRBool operator==(const nsUrlClassifierLookupResult &result) const {
10941:     // Don't need to compare table name, it's contained by id in the entry.
10941:     return (mLookupFragment == result.mLookupFragment &&
10941:             mConfirmed == result.mConfirmed &&
10941:             mEntry == result.mEntry);
10941:   }
10941: 
10941:   PRBool operator<(const nsUrlClassifierLookupResult &result) const {
10941:     // Don't need to compare table name, it's contained by id in the entry.
10941:     return (mLookupFragment < result.mLookupFragment ||
10941:             mConfirmed < result.mConfirmed ||
10941:             mEntry < result.mEntry);
10941:   }
10941: 
10941:   // The hash that matched this entry.
10941:   nsUrlClassifierCompleteHash mLookupFragment;
10941: 
10941:   // The entry that was found during the lookup.
10941:   nsUrlClassifierEntry mEntry;
10941: 
10941:   // TRUE if the lookup matched a complete hash (not just a partial
10941:   // one).
10941:   PRPackedBool mConfirmed;
10941: 
12334:   // TRUE if this lookup is gethash noise.  Does not represent an actual
12334:   // result.
12334:   PRPackedBool mNoise;
12334: 
10941:   // The table name associated with mEntry.mTableId.
10941:   nsCString mTableName;
10941: };
10941: 
10941: // -------------------------------------------------------------------------
10212: // Store class implementation
10212: 
10212: // This class mediates access to the classifier and chunk entry tables.
10212: class nsUrlClassifierStore
10212: {
10212: public:
10212:   nsUrlClassifierStore() {}
10941:   virtual ~nsUrlClassifierStore() {}
10212: 
10212:   // Initialize the statements for the store.
10212:   nsresult Init(nsUrlClassifierDBServiceWorker *worker,
10212:                 mozIStorageConnection *connection,
10941:                 const nsACString& entriesTableName);
10212:   // Shut down the store.
10212:   void Close();
10212: 
10941:   // Read an entry from a database statement
10941:   virtual PRBool ReadStatement(mozIStorageStatement* statement,
10941:                                nsUrlClassifierEntry& entry);
10941: 
10941:   // Prepare a statement to write this entry to the database
10941:   virtual nsresult BindStatement(const nsUrlClassifierEntry& entry,
10941:                                  mozIStorageStatement* statement);
10941: 
10212:   // Read the entry with a given ID from the database
12334:   nsresult ReadEntry(PRInt64 id, nsUrlClassifierEntry& entry, PRBool *exists);
10212: 
10212:   // Remove an entry from the database
10212:   nsresult DeleteEntry(nsUrlClassifierEntry& entry);
10212: 
10212:   // Write an entry to the database
10212:   nsresult WriteEntry(nsUrlClassifierEntry& entry);
10212: 
10988:   // Update an entry in the database.  The entry must already exist in the
10988:   // database or this method will fail.
10988:   nsresult UpdateEntry(nsUrlClassifierEntry& entry);
10988: 
10212:   // Remove all entries for a given table/chunk pair from the database.
10212:   nsresult Expire(PRUint32 tableId,
10212:                   PRUint32 chunkNum);
10212: 
12334:   // Read a certain number of rows adjacent to the requested rowid that
12334:   // don't have complete hash data.
12334:   nsresult ReadNoiseEntries(PRInt64 rowID,
12334:                             PRUint32 numRequested,
12334:                             PRBool before,
12334:                             nsTArray<nsUrlClassifierEntry> &entries);
12334: 
12334:   // Ask the db for a random number.  This is temporary, and should be
12334:   // replaced with nsIRandomGenerator when 419739 is fixed.
12334:   nsresult RandomNumber(PRInt64 *randomNum);
12334: 
10941: protected:
10941:   nsresult ReadEntries(mozIStorageStatement *statement,
10941:                        nsTArray<nsUrlClassifierEntry>& entries);
10212:   nsUrlClassifierDBServiceWorker *mWorker;
10212:   nsCOMPtr<mozIStorageConnection> mConnection;
10212: 
10212:   nsCOMPtr<mozIStorageStatement> mLookupWithIDStatement;
10212: 
10988:   nsCOMPtr<mozIStorageStatement> mInsertStatement;
10212:   nsCOMPtr<mozIStorageStatement> mUpdateStatement;
10212:   nsCOMPtr<mozIStorageStatement> mDeleteStatement;
10941:   nsCOMPtr<mozIStorageStatement> mExpireStatement;
12334: 
12334:   nsCOMPtr<mozIStorageStatement> mPartialEntriesStatement;
12334:   nsCOMPtr<mozIStorageStatement> mPartialEntriesAfterStatement;
12334:   nsCOMPtr<mozIStorageStatement> mLastPartialEntriesStatement;
12334:   nsCOMPtr<mozIStorageStatement> mPartialEntriesBeforeStatement;
12334: 
12334:   nsCOMPtr<mozIStorageStatement> mRandomStatement;
10212: };
10212: 
10212: nsresult
10212: nsUrlClassifierStore::Init(nsUrlClassifierDBServiceWorker *worker,
10212:                            mozIStorageConnection *connection,
10941:                            const nsACString& entriesName)
10212: {
10212:   mWorker = worker;
10212:   mConnection = connection;
10212: 
10212:   nsresult rv = mConnection->CreateStatement
10212:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesName +
10212:      NS_LITERAL_CSTRING(" WHERE id=?1"),
10212:      getter_AddRefs(mLookupWithIDStatement));
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10212:   rv = mConnection->CreateStatement
10212:     (NS_LITERAL_CSTRING("DELETE FROM ") + entriesName +
10212:      NS_LITERAL_CSTRING(" WHERE id=?1"),
10212:      getter_AddRefs(mDeleteStatement));
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10212:   rv = mConnection->CreateStatement
10941:     (NS_LITERAL_CSTRING("DELETE FROM ") + entriesName +
10212:      NS_LITERAL_CSTRING(" WHERE table_id=?1 AND chunk_id=?2"),
10941:      getter_AddRefs(mExpireStatement));
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   rv = mConnection->CreateStatement
12334:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesName +
12334:      NS_LITERAL_CSTRING(" WHERE complete_data ISNULL"
12334:                         " LIMIT ?1"),
12334:      getter_AddRefs(mPartialEntriesStatement));
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   rv = mConnection->CreateStatement
12334:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesName +
12334:      NS_LITERAL_CSTRING(" WHERE id > ?1 AND complete_data ISNULL"
12334:                         " LIMIT ?2"),
12334:      getter_AddRefs(mPartialEntriesAfterStatement));
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   rv = mConnection->CreateStatement
12334:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesName +
12334:      NS_LITERAL_CSTRING(" WHERE complete_data ISNULL"
12334:                         " ORDER BY id DESC LIMIT ?1"),
12334:      getter_AddRefs(mLastPartialEntriesStatement));
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   rv = mConnection->CreateStatement
12334:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesName +
12334:      NS_LITERAL_CSTRING(" WHERE id < ?1 AND complete_data ISNULL"
12334:                         " ORDER BY id DESC LIMIT ?2"),
12334:      getter_AddRefs(mPartialEntriesBeforeStatement));
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   rv = mConnection->CreateStatement
12334:     (NS_LITERAL_CSTRING("SELECT abs(random())"),
12334:      getter_AddRefs(mRandomStatement));
12334:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10212:   return NS_OK;
10212: }
10212: 
10212: void
10212: nsUrlClassifierStore::Close()
10212: {
10212:   mLookupWithIDStatement = nsnull;
10212: 
10988:   mInsertStatement = nsnull;
10212:   mUpdateStatement = nsnull;
10212:   mDeleteStatement = nsnull;
10941:   mExpireStatement = nsnull;
10212: 
12334:   mPartialEntriesStatement = nsnull;
12334:   mPartialEntriesAfterStatement = nsnull;
12334:   mPartialEntriesBeforeStatement = nsnull;
12334:   mLastPartialEntriesStatement = nsnull;
12337:   mRandomStatement = nsnull;
12337: 
10212:   mConnection = nsnull;
10212: }
10212: 
10941: 
10941: PRBool
10941: nsUrlClassifierStore::ReadStatement(mozIStorageStatement* statement,
10941:                                     nsUrlClassifierEntry& entry)
10941: {
12334:   entry.mId = statement->AsInt64(0);
10941: 
10941:   PRUint32 size;
10941:   const PRUint8* blob = statement->AsSharedBlob(1, &size);
10941:   if (!blob || (size != DOMAIN_LENGTH))
10941:     return PR_FALSE;
10941:   memcpy(entry.mKey.buf, blob, DOMAIN_LENGTH);
10941: 
10941:   blob = statement->AsSharedBlob(2, &size);
10941:   if (!blob || size == 0) {
10941:     entry.mHavePartial = PR_FALSE;
10941:   } else {
10941:     if (size != PARTIAL_LENGTH)
10941:       return PR_FALSE;
10941:     entry.mHavePartial = PR_TRUE;
10941:     memcpy(entry.mPartialHash.buf, blob, PARTIAL_LENGTH);
10941:   }
10941: 
10941:   blob = statement->AsSharedBlob(3, &size);
10941:   if (!blob || size == 0) {
10941:     entry.mHaveComplete = PR_FALSE;
10941:   } else {
10941:     if (size != COMPLETE_LENGTH)
10941:       return PR_FALSE;
10941:     entry.mHaveComplete = PR_TRUE;
10941:     memcpy(entry.mCompleteHash.buf, blob, COMPLETE_LENGTH);
10941:   }
10941: 
10941:   // If we only have a partial entry, and that partial entry matches the
10941:   // domain, we don't save the extra copy to the database.
10941:   if (!(entry.mHavePartial || entry.mHaveComplete)) {
10941:     entry.SetHash(entry.mKey);
10941:   }
10941: 
10941:   entry.mChunkId = statement->AsInt32(4);
10941:   entry.mTableId = statement->AsInt32(5);
10941: 
10941:   return PR_TRUE;
10941: }
10941: 
10865: nsresult
10941: nsUrlClassifierStore::BindStatement(const nsUrlClassifierEntry &entry,
10941:                                     mozIStorageStatement* statement)
10854: {
10941:   nsresult rv;
10941: 
12334:   if (entry.mId == -1)
10941:     rv = statement->BindNullParameter(0);
10941:   else
12334:     rv = statement->BindInt64Parameter(0, entry.mId);
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10941:   rv = statement->BindBlobParameter(1, entry.mKey.buf, DOMAIN_LENGTH);
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10941:   if (entry.mHavePartial) {
10941:     // If we only have a partial entry and that entry matches the domain,
10941:     // we'll save some space by only storing the domain hash.
10941:     if (!entry.mHaveComplete && entry.mKey == entry.mPartialHash) {
10941:       rv = statement->BindNullParameter(2);
10941:     } else {
10941:       rv = statement->BindBlobParameter(2, entry.mPartialHash.buf,
10941:                                         PARTIAL_LENGTH);
10941:     }
10941:   } else {
10941:     rv = statement->BindNullParameter(2);
10941:   }
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10941:   if (entry.mHaveComplete) {
10941:     rv = statement->BindBlobParameter(3, entry.mCompleteHash.buf, COMPLETE_LENGTH);
10941:   } else {
10941:     rv = statement->BindNullParameter(3);
10941:   }
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   rv = statement->BindInt32Parameter(4, entry.mChunkId);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   rv = statement->BindInt32Parameter(5, entry.mTableId);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   return PR_TRUE;
10941: }
10941: 
10941: nsresult
10941: nsUrlClassifierStore::ReadEntries(mozIStorageStatement *statement,
10941:                                   nsTArray<nsUrlClassifierEntry>& entries)
10941: {
10941:   PRBool exists;
10941:   nsresult rv = statement->ExecuteStep(&exists);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   while (exists) {
10941:     nsUrlClassifierEntry *entry = entries.AppendElement();
10941:     if (!entry) {
10941:       return NS_ERROR_OUT_OF_MEMORY;
10941:     }
10941: 
10941:     if (!ReadStatement(statement, *entry))
10941:       return NS_ERROR_FAILURE;
10941: 
10941:     statement->ExecuteStep(&exists);
10941:   }
10941: 
10212:   return NS_OK;
10212: }
10212: 
10941: nsresult
12334: nsUrlClassifierStore::ReadEntry(PRInt64 id,
10941:                                 nsUrlClassifierEntry& entry,
10941:                                 PRBool *exists)
10941: {
10941:   entry.Clear();
10941: 
10941:   mozStorageStatementScoper scoper(mLookupWithIDStatement);
10941: 
12334:   nsresult rv = mLookupWithIDStatement->BindInt64Parameter(0, id);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   rv = mLookupWithIDStatement->ExecuteStep(exists);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   if (*exists) {
10941:     if (ReadStatement(mLookupWithIDStatement, entry))
10941:       return NS_ERROR_FAILURE;
10941:   }
10941: 
10941:   return NS_OK;
10941: }
10941: 
12334: nsresult
12334: nsUrlClassifierStore::ReadNoiseEntries(PRInt64 rowID,
12334:                                        PRUint32 numRequested,
12334:                                        PRBool before,
12334:                                        nsTArray<nsUrlClassifierEntry> &entries)
12334: {
12334:   if (numRequested == 0) {
12334:     return NS_OK;
12334:   }
12334: 
12334:   mozIStorageStatement *statement =
12334:     before ? mPartialEntriesBeforeStatement : mPartialEntriesAfterStatement;
12334:   mozStorageStatementScoper scoper(statement);
12334: 
12334:   nsresult rv = statement->BindInt64Parameter(0, rowID);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   statement->BindInt32Parameter(1, numRequested);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   PRUint32 length = entries.Length();
12334:   rv = ReadEntries(statement, entries);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   PRUint32 numRead = entries.Length() - length;
12334: 
12334:   if (numRead >= numRequested)
12334:     return NS_OK;
12334: 
12334:   // If we didn't get enough entries, we need the search to wrap around from
12334:   // beginning to end (or vice-versa)
12334: 
12334:   mozIStorageStatement *wraparoundStatement =
12334:     before ? mPartialEntriesStatement : mLastPartialEntriesStatement;
12334:   mozStorageStatementScoper wraparoundScoper(wraparoundStatement);
12334: 
12334:   rv = wraparoundStatement->BindInt32Parameter(0, numRequested - numRead);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   return ReadEntries(wraparoundStatement, entries);
12334: }
12334: 
12334: nsresult
12334: nsUrlClassifierStore::RandomNumber(PRInt64 *randomNum)
12334: {
12334:   mozStorageStatementScoper randScoper(mRandomStatement);
12334:   PRBool exists;
12334:   nsresult rv = mRandomStatement->ExecuteStep(&exists);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334:   if (!exists)
12334:     return NS_ERROR_NOT_AVAILABLE;
12334: 
12334:   *randomNum = mRandomStatement->AsInt64(0);
12334: 
12334:   return NS_OK;
12334: }
12334: 
10941: // -------------------------------------------------------------------------
10941: // nsUrlClassifierAddStore class implementation
10941: 
10941: // This class accesses the moz_classifier table.
10941: class nsUrlClassifierAddStore: public nsUrlClassifierStore
10941: {
10941: public:
10941:   nsUrlClassifierAddStore() {};
10941:   virtual ~nsUrlClassifierAddStore() {};
10941: 
10941:   nsresult Init(nsUrlClassifierDBServiceWorker *worker,
10941:                 mozIStorageConnection *connection,
10941:                 const nsACString& entriesTableName);
20649: 
20649:   void Close();
20649: 
20649:   // Read the entries for a given key/table/chunk from the database
20649:   nsresult ReadAddEntries(const nsUrlClassifierDomainHash& key,
20649:                           PRUint32 tableId,
20649:                           PRUint32 chunkId,
20649:                           nsTArray<nsUrlClassifierEntry>& entry);
20649: 
20649:   // Read the entries for a given host key from the database.
20649:   nsresult ReadAddEntries(const nsUrlClassifierDomainHash& key,
20649:                           nsTArray<nsUrlClassifierEntry>& entry);
20649: 
20649: protected:
20649:   nsCOMPtr<mozIStorageStatement> mLookupStatement;
20649:   nsCOMPtr<mozIStorageStatement> mLookupWithChunkStatement;
10941: };
10941: 
10941: nsresult
10941: nsUrlClassifierAddStore::Init(nsUrlClassifierDBServiceWorker *worker,
10941:                               mozIStorageConnection *connection,
10941:                               const nsACString &entriesTableName)
10941: {
10941:   nsresult rv = nsUrlClassifierStore::Init(worker, connection,
10941:                                            entriesTableName);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   rv = mConnection->CreateStatement
10941:     (NS_LITERAL_CSTRING("INSERT OR REPLACE INTO ") + entriesTableName +
10941:      NS_LITERAL_CSTRING(" VALUES (?1, ?2, ?3, ?4, ?5, ?6)"),
10988:      getter_AddRefs(mInsertStatement));
10988:   NS_ENSURE_SUCCESS(rv, rv);
10988: 
10988:   rv = mConnection->CreateStatement
10988:     (NS_LITERAL_CSTRING("UPDATE ") + entriesTableName +
10988:      NS_LITERAL_CSTRING(" SET domain=?2, partial_data=?3, "
10988:                         " complete_data=?4, chunk_id=?5, table_id=?6"
10988:                         " WHERE id=?1"),
10941:      getter_AddRefs(mUpdateStatement));
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
20649:   rv = mConnection->CreateStatement
20649:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesTableName +
20649:      NS_LITERAL_CSTRING(" WHERE domain=?1"),
20649:      getter_AddRefs(mLookupStatement));
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
20649:   rv = mConnection->CreateStatement
20649:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesTableName +
20649:      NS_LITERAL_CSTRING(" WHERE domain=?1 AND table_id=?2 AND chunk_id=?3"),
20649:      getter_AddRefs(mLookupWithChunkStatement));
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
10941:   return NS_OK;
10941: }
10941: 
20649: void
20649: nsUrlClassifierAddStore::Close()
20649: {
20649:   nsUrlClassifierStore::Close();
20649: 
20649:   mLookupStatement = nsnull;
20649:   mLookupWithChunkStatement = nsnull;
20649: }
20649: 
20649: nsresult
20649: nsUrlClassifierAddStore::ReadAddEntries(const nsUrlClassifierDomainHash& hash,
20649:                                         PRUint32 tableId,
20649:                                         PRUint32 chunkId,
20649:                                         nsTArray<nsUrlClassifierEntry>& entries)
20649: {
20649:   mozStorageStatementScoper scoper(mLookupWithChunkStatement);
20649: 
20649:   nsresult rv = mLookupWithChunkStatement->BindBlobParameter
20649:                   (0, hash.buf, DOMAIN_LENGTH);
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
20649:   rv = mLookupWithChunkStatement->BindInt32Parameter(1, tableId);
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649:   rv = mLookupWithChunkStatement->BindInt32Parameter(2, chunkId);
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
20649:   return ReadEntries(mLookupWithChunkStatement, entries);
20649: }
20649: 
20649: nsresult
20649: nsUrlClassifierAddStore::ReadAddEntries(const nsUrlClassifierDomainHash& hash,
20649:                                         nsTArray<nsUrlClassifierEntry>& entries)
20649: {
20649:   mozStorageStatementScoper scoper(mLookupStatement);
20649: 
20649:   nsresult rv = mLookupStatement->BindBlobParameter
20649:                   (0, hash.buf, DOMAIN_LENGTH);
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
20649:   return ReadEntries(mLookupStatement, entries);
20649: }
20649: 
10941: // -------------------------------------------------------------------------
10941: // nsUrlClassifierSubStore class implementation
10941: 
10941: // This class accesses the moz_subs table.
10941: class nsUrlClassifierSubStore : public nsUrlClassifierStore
10941: {
10941: public:
10941:   nsUrlClassifierSubStore() {};
10941:   virtual ~nsUrlClassifierSubStore() {};
10941: 
10941:   nsresult Init(nsUrlClassifierDBServiceWorker *worker,
10941:                 mozIStorageConnection *connection,
10941:                 const nsACString& entriesTableName);
10941: 
10941:   void Close();
10941: 
10941:   // Read an entry from a database statement
10941:   virtual PRBool ReadStatement(mozIStorageStatement* statement,
10941:                                nsUrlClassifierEntry& entry);
10941: 
10941:   // Prepare a statement to write this entry to the database
10941:   virtual nsresult BindStatement(const nsUrlClassifierEntry& entry,
10941:                                  mozIStorageStatement* statement);
10941: 
20649:   // Read sub entries for a given add chunk
20649:   nsresult ReadSubEntries(PRUint32 tableId, PRUint32 chunkId,
10941:                           nsTArray<nsUrlClassifierEntry> &subEntry);
10941: 
20649:   // Expire sub entries for a given add chunk
20649:   nsresult ExpireAddChunk(PRUint32 tableId, PRUint32 chunkId);
20649: 
10941: protected:
10941:   nsCOMPtr<mozIStorageStatement> mLookupWithAddChunkStatement;
20649:   nsCOMPtr<mozIStorageStatement> mExpireAddChunkStatement;
10941: };
10941: 
10941: nsresult
10941: nsUrlClassifierSubStore::Init(nsUrlClassifierDBServiceWorker *worker,
10941:                               mozIStorageConnection *connection,
10941:                               const nsACString &entriesTableName)
10941: {
10941:   nsresult rv = nsUrlClassifierStore::Init(worker, connection,
10941:                                            entriesTableName);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   rv = mConnection->CreateStatement
10941:     (NS_LITERAL_CSTRING("INSERT OR REPLACE INTO ") + entriesTableName +
10941:      NS_LITERAL_CSTRING(" VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)"),
10988:      getter_AddRefs(mInsertStatement));
10988:   NS_ENSURE_SUCCESS(rv, rv);
10988: 
10988:   rv = mConnection->CreateStatement
10988:     (NS_LITERAL_CSTRING("UPDATE ") + entriesTableName +
10988:      NS_LITERAL_CSTRING(" SET domain=?2, partial_data=?3, complete_data=?4,"
10988:                         " chunk_id=?5, table_id=?6, add_chunk_id=?7"
10988:                         " WHERE id=?1"),
10941:      getter_AddRefs(mUpdateStatement));
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   rv = mConnection->CreateStatement
10941:     (NS_LITERAL_CSTRING("SELECT * FROM ") + entriesTableName +
20649:      NS_LITERAL_CSTRING(" WHERE table_id=?1 AND add_chunk_id=?2"),
10941:      getter_AddRefs(mLookupWithAddChunkStatement));
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
20649:   rv = mConnection->CreateStatement
20649:     (NS_LITERAL_CSTRING("DELETE FROM ") + entriesTableName +
20649:      NS_LITERAL_CSTRING(" WHERE table_id=?1 AND add_chunk_id=?2"),
20649:      getter_AddRefs(mExpireAddChunkStatement));
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
10941:   return NS_OK;
10941: }
10941: 
10941: PRBool
10941: nsUrlClassifierSubStore::ReadStatement(mozIStorageStatement* statement,
10941:                                        nsUrlClassifierEntry& entry)
10941: {
10941:   if (!nsUrlClassifierStore::ReadStatement(statement, entry))
10941:     return PR_FALSE;
10941: 
10941:   entry.mAddChunkId = statement->AsInt32(6);
10941:   return PR_TRUE;
10941: }
10941: 
10941: nsresult
10941: nsUrlClassifierSubStore::BindStatement(const nsUrlClassifierEntry& entry,
10941:                                        mozIStorageStatement* statement)
10941: {
10941:   nsresult rv = nsUrlClassifierStore::BindStatement(entry, statement);
10941:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
10941:   return statement->BindInt32Parameter(6, entry.mAddChunkId);
10941: }
10941: 
10941: nsresult
20649: nsUrlClassifierSubStore::ReadSubEntries(PRUint32 tableId, PRUint32 addChunkId,
10941:                                         nsTArray<nsUrlClassifierEntry>& entries)
10941: {
10941:   mozStorageStatementScoper scoper(mLookupWithAddChunkStatement);
10941: 
20649:   nsresult rv = mLookupWithAddChunkStatement->BindInt32Parameter(0, tableId);
10941:   NS_ENSURE_SUCCESS(rv, rv);
20649:   rv = mLookupWithAddChunkStatement->BindInt32Parameter(1, addChunkId);
10941:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
20649:   return ReadEntries(mLookupWithAddChunkStatement, entries);
20649: }
20649: 
20649: nsresult
20649: nsUrlClassifierSubStore::ExpireAddChunk(PRUint32 tableId, PRUint32 addChunkId)
20649: {
20649:   mozStorageStatementScoper scoper(mExpireAddChunkStatement);
20649: 
20649:   nsresult rv = mExpireAddChunkStatement->BindInt32Parameter(0, tableId);
10941:   NS_ENSURE_SUCCESS(rv, rv);
20649:   rv = mExpireAddChunkStatement->BindInt32Parameter(1, addChunkId);
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
20649:   return mExpireAddChunkStatement->Execute();
10941: }
10941: 
10941: void
10941: nsUrlClassifierSubStore::Close()
10941: {
10941:   nsUrlClassifierStore::Close();
10941:   mLookupWithAddChunkStatement = nsnull;
20649:   mExpireAddChunkStatement = nsnull;
10941: }
10941: 
10212: // -------------------------------------------------------------------------
    1: // Actual worker implemenatation
    1: class nsUrlClassifierDBServiceWorker : public nsIUrlClassifierDBServiceWorker
    1: {
    1: public:
    1:   nsUrlClassifierDBServiceWorker();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIURLCLASSIFIERDBSERVICE
    1:   NS_DECL_NSIURLCLASSIFIERDBSERVICEWORKER
    1: 
 4024:   // Initialize, called in the main thread
12334:   nsresult Init(PRInt32 gethashNoise);
 4024: 
 4024:   // Queue a lookup for the worker to perform, called in the main thread.
 4024:   nsresult QueueLookup(const nsACString& lookupKey,
10941:                        nsIUrlClassifierLookupCallback* callback);
 4024: 
20648:   // Check if the key is on a known-clean host.
20648:   nsresult CheckCleanHost(const nsACString &lookupKey,
20648:                           PRBool *clean);
20648: 
10212:   // Handle any queued-up lookups.  We call this function during long-running
10212:   // update operations to prevent lookups from blocking for too long.
10212:   nsresult HandlePendingLookups();
10212: 
    1: private:
    1:   // No subclassing
    1:   ~nsUrlClassifierDBServiceWorker();
    1: 
    1:   // Disallow copy constructor
    1:   nsUrlClassifierDBServiceWorker(nsUrlClassifierDBServiceWorker&);
    1: 
    1:   // Try to open the db, DATABASE_FILENAME.
    1:   nsresult OpenDb();
    1: 
 4024:   // Create table in the db if they don't exist.
 4024:   nsresult MaybeCreateTables(mozIStorageConnection* connection);
 4024: 
 4024:   nsresult GetTableName(PRUint32 tableId, nsACString& table);
 4024:   nsresult GetTableId(const nsACString& table, PRUint32* tableId);
 4024: 
 4024:   // Decompress a zlib'ed chunk (used for -exp tables)
 4024:   nsresult InflateChunk(nsACString& chunk);
 4024: 
10941:   // Expand shavar chunk into its individual entries
10941:   nsresult GetShaEntries(PRUint32 tableId,
10941:                          PRUint32 chunkType,
10941:                          PRUint32 chunkNum,
10941:                          PRUint32 domainSize,
10941:                          PRUint32 hashSize,
10941:                          nsACString& chunk,
10941:                          nsTArray<nsUrlClassifierEntry>& entries);
10941: 
 4024:   // Expand a chunk into its individual entries
 4024:   nsresult GetChunkEntries(const nsACString& table,
 4024:                            PRUint32 tableId,
10941:                            PRUint32 chunkType,
 4024:                            PRUint32 chunkNum,
10941:                            PRUint32 hashSize,
 4024:                            nsACString& chunk,
 4024:                            nsTArray<nsUrlClassifierEntry>& entries);
 4024: 
11769:   // Parse one stringified range of chunks of the form "n" or "n-m" from a
11769:   // comma-separated list of chunks.  Upon return, 'begin' will point to the
11769:   // next range of chunks in the list of chunks.
11769:   PRBool ParseChunkRange(nsACString::const_iterator &begin,
11769:                          const nsACString::const_iterator &end,
 8707:                          PRUint32 *first, PRUint32 *last);
 8707: 
 4024:   // Expand a stringified chunk list into an array of ints.
 4024:   nsresult ParseChunkList(const nsACString& chunkStr,
 4024:                           nsTArray<PRUint32>& chunks);
 4024: 
 4024:   // Join an array of ints into a stringified chunk list.
 4024:   nsresult JoinChunkList(nsTArray<PRUint32>& chunks, nsCString& chunkStr);
 4024: 
 4024:   // List the add/subtract chunks that have been applied to a table
 4024:   nsresult GetChunkLists(PRUint32 tableId,
 4024:                          nsACString& addChunks,
 4024:                          nsACString& subChunks);
 4024: 
 4024:   // Set the list of add/subtract chunks that have been applied to a table
 4024:   nsresult SetChunkLists(PRUint32 tableId,
 4024:                          const nsACString& addChunks,
 4024:                          const nsACString& subChunks);
 4024: 
 8642:   // Cache the list of add/subtract chunks applied to the table, optionally
 8642:   // parsing the add or sub lists.  These lists are cached while updating
 8642:   // tables to avoid excessive database reads/writes and parsing.
 8642:   nsresult CacheChunkLists(PRUint32 tableId,
 8642:                            PRBool parseAdds,
 8642:                            PRBool parseSubs);
10941: 
10941:   // Clear the cached list of add/subtract chunks.
10941:   void ClearCachedChunkLists();
10941: 
 8642:   // Flush the cached add/subtract lists to the database.
 8642:   nsresult FlushChunkLists();
 8642: 
14994:   // Inserts a chunk id into the list, sorted.  Returns TRUE if the
14994:   // number was successfully added, FALSE if the chunk already exists.
14994:   PRBool InsertChunkId(nsTArray<PRUint32>& chunks, PRUint32 chunkNum);
14994: 
 4024:   // Add a list of entries to the database, merging with
 4024:   // existing entries as necessary
 4024:   nsresult AddChunk(PRUint32 tableId, PRUint32 chunkNum,
 4024:                     nsTArray<nsUrlClassifierEntry>& entries);
 4024: 
 4024:   // Expire an add chunk
 4024:   nsresult ExpireAdd(PRUint32 tableId, PRUint32 chunkNum);
 4024: 
 4024:   // Subtract a list of entries from the database
 4024:   nsresult SubChunk(PRUint32 tableId, PRUint32 chunkNum,
 4024:                     nsTArray<nsUrlClassifierEntry>& entries);
 4024: 
 4024:   // Expire a subtract chunk
 4024:   nsresult ExpireSub(PRUint32 tableId, PRUint32 chunkNum);
 4024: 
 4024:   // Handle line-oriented control information from a stream update
 4024:   nsresult ProcessResponseLines(PRBool* done);
 4024:   // Handle chunk data from a stream update
 4024:   nsresult ProcessChunk(PRBool* done);
 4024: 
15023:   // Sets up a transaction and begins counting update time.
15023:   nsresult SetupUpdate();
15023: 
15023:   // Applies the current transaction and resets the update/working times.
15023:   nsresult ApplyUpdate();
15023: 
10213:   // Reset the in-progress update stream
10213:   void ResetStream();
10213: 
10213:   // Reset the in-progress update
 4024:   void ResetUpdate();
 4024: 
20648:   // Reset the set of clean host keys and cached lookups.
20648:   void ResetLookupCache();
20648: 
 4024:   // take a lookup string (www.hostname.com/path/to/resource.html) and
 4024:   // expand it into the set of fragments that should be searched for in an
 4024:   // entry
 4024:   nsresult GetLookupFragments(const nsCSubstring& spec,
20648:                               nsTArray<nsCString>& fragments);
 4024: 
 6507:   // Check for a canonicalized IP address.
 6507:   PRBool IsCanonicalizedIP(const nsACString& host);
 6507: 
 4024:   // Get the database key for a given URI.  This is the top three
 4024:   // domain components if they exist, otherwise the top two.
 6507:   //  hostname.com/foo/bar -> hostname.com
 4024:   //  mail.hostname.com/foo/bar -> mail.hostname.com
 4024:   //  www.mail.hostname.com/foo/bar -> mail.hostname.com
10941:   nsresult GetKey(const nsACString& spec, nsUrlClassifierDomainHash& hash);
 4024: 
20648:   // Similar to GetKey(), but if the domain contains three or more components,
20648:   // two keys will be returned:
20648:   //  hostname.com/foo/bar -> [hostname.com]
20648:   //  mail.hostname.com/foo/bar -> [hostname.com, mail.hostname.com]
20648:   //  www.mail.hostname.com/foo/bar -> [hostname.com, mail.hostname.com]
20648:   nsresult GetHostKeys(const nsACString &spec,
20648:                        nsTArray<nsCString> &hostKeys);
20648: 
24807: // Read all relevant entries for the given URI into mCachedEntries.
24807:   nsresult CacheEntries(const nsCSubstring& spec);
24807: 
 4024:   // Look for a given lookup string (www.hostname.com/path/to/resource.html)
24807:   // Returns a list of entries that match.
24807:   nsresult Check(const nsCSubstring& spec,
10941:                  nsTArray<nsUrlClassifierLookupResult>& results);
 4024: 
 4024:   // Perform a classifier lookup for a given url.
10941:   nsresult DoLookup(const nsACString& spec, nsIUrlClassifierLookupCallback* c);
 4024: 
12334:   // Add entries to the results.
12334:   nsresult AddNoise(PRInt64 nearID,
12334:                     PRInt32 count,
12334:                     nsTArray<nsUrlClassifierLookupResult>& results);
12334: 
 4024:   nsCOMPtr<nsIFile> mDBFile;
 4024: 
 4024:   nsCOMPtr<nsICryptoHash> mCryptoHash;
    1: 
    1:   // Holds a connection to the Db.  We lazily initialize this because it has
    1:   // to be created in the background thread (currently mozStorageConnection
    1:   // isn't thread safe).
 4024:   nsCOMPtr<mozIStorageConnection> mConnection;
 4024: 
10212:   // The main collection of entries.  This is the store that will be checked
10212:   // when classifying a URL.
10941:   nsUrlClassifierAddStore mMainStore;
10212: 
10212:   // The collection of subs waiting for their accompanying add.
10941:   nsUrlClassifierSubStore mPendingSubStore;
 4024: 
 4024:   nsCOMPtr<mozIStorageStatement> mGetChunkListsStatement;
 4024:   nsCOMPtr<mozIStorageStatement> mSetChunkListsStatement;
 4024: 
 4024:   nsCOMPtr<mozIStorageStatement> mGetTablesStatement;
 4024:   nsCOMPtr<mozIStorageStatement> mGetTableIdStatement;
 4024:   nsCOMPtr<mozIStorageStatement> mGetTableNameStatement;
 4024:   nsCOMPtr<mozIStorageStatement> mInsertTableIdStatement;
46994:   nsCOMPtr<mozIStorageStatement> mGetPageSizeStatement;
    1: 
14354:   // Stores the last time a given table was updated.
14354:   nsDataHashtable<nsCStringHashKey, PRInt64> mTableFreshness;
14354: 
    1:   // We receive data in small chunks that may be broken in the middle of
    1:   // a line.  So we save the last partial line here.
    1:   nsCString mPendingStreamUpdate;
 4024: 
 4024:   PRInt32 mUpdateWait;
 4024: 
12453:   PRBool mResetRequested;
14883:   PRBool mGrewCache;
12453: 
 4024:   enum {
 4024:     STATE_LINE,
 4024:     STATE_CHUNK
 4024:   } mState;
 4024: 
 4024:   enum {
 4024:     CHUNK_ADD,
 4024:     CHUNK_SUB
 4024:   } mChunkType;
 4024: 
 4024:   PRUint32 mChunkNum;
10941:   PRUint32 mHashSize;
 4024:   PRUint32 mChunkLen;
 4024: 
14354:   // List of tables included in this update.
14354:   nsTArray<nsCString> mUpdateTables;
14354: 
 4024:   nsCString mUpdateTable;
 4024:   PRUint32 mUpdateTableId;
 4024: 
 4024:   nsresult mUpdateStatus;
 4024: 
10213:   nsCOMPtr<nsIUrlClassifierUpdateObserver> mUpdateObserver;
10213:   PRBool mInStream;
10213:   PRBool mPrimaryStream;
10213: 
 8642:   PRBool mHaveCachedLists;
 8642:   PRUint32 mCachedListsTable;
 8642:   nsCAutoString mCachedSubsStr;
 8642:   nsCAutoString mCachedAddsStr;
 8642: 
 8642:   PRBool mHaveCachedAddChunks;
 8642:   nsTArray<PRUint32> mCachedAddChunks;
 8642: 
 8642:   PRBool mHaveCachedSubChunks;
 8642:   nsTArray<PRUint32> mCachedSubChunks;
 8642: 
12346:   // The client key with which the data from the server will be MAC'ed.
12346:   nsCString mUpdateClientKey;
12346: 
12346:   // The MAC stated by the server.
12346:   nsCString mServerMAC;
12346: 
15023:   // Start time of the current update interval.  This will be reset
15023:   // every time we apply the update.
15023:   PRIntervalTime mUpdateStartTime;
15023: 
12346:   nsCOMPtr<nsICryptoHMAC> mHMAC;
12334:   // The number of noise entries to add to the set of lookup results.
12334:   PRInt32 mGethashNoise;
 8642: 
20648:   // We maintain an MRU cache of clean host keys (host keys with no
20648:   // entry in the db).
20648:   nsUrlClassifierFragmentSet mCleanHostKeys;
20648: 
20648:   // The clean-host-key cache is updated in the worker thread, but
20648:   // checked in the main thread (to avoid posting lookup requests if
20648:   // not necessary).
20648:   PRLock* mCleanHostKeysLock;
20648: 
20648:   // We maintain an MRU cache of clean fragments (fragments with no
20648:   // entry in the db).
20648:   nsUrlClassifierFragmentSet mCleanFragments;
20648: 
20648:   // The host keys from the last host to be checked for malware are
20648:   // cached for quicker lookup next time through.
20648:   nsCString mCachedHostKey;
20648:   nsTArray<nsUrlClassifierEntry> mCachedEntries;
20648: 
 4024:   // Pending lookups are stored in a queue for processing.  The queue
 4024:   // is protected by mPendingLookupLock.
 4024:   PRLock* mPendingLookupLock;
 4024: 
 4024:   class PendingLookup {
 4024:   public:
 4024:     nsCString mKey;
10941:     nsCOMPtr<nsIUrlClassifierLookupCallback> mCallback;
 4024:   };
 4024: 
 4024:   // list of pending lookups
 4024:   nsTArray<PendingLookup> mPendingLookups;
    1: };
    1: 
14031: NS_IMPL_THREADSAFE_ISUPPORTS2(nsUrlClassifierDBServiceWorker,
14031:                               nsIUrlClassifierDBServiceWorker,
14031:                               nsIUrlClassifierDBService)
    1: 
    1: nsUrlClassifierDBServiceWorker::nsUrlClassifierDBServiceWorker()
10941:   : mUpdateWait(0)
12453:   , mResetRequested(PR_FALSE)
14883:   , mGrewCache(PR_FALSE)
10941:   , mState(STATE_LINE)
10941:   , mChunkType(CHUNK_ADD)
10941:   , mChunkNum(0)
10941:   , mHashSize(0)
10941:   , mChunkLen(0)
10941:   , mUpdateTableId(0)
10941:   , mUpdateStatus(NS_OK)
10213:   , mInStream(PR_FALSE)
10213:   , mPrimaryStream(PR_FALSE)
 8642:   , mHaveCachedLists(PR_FALSE)
 8642:   , mCachedListsTable(PR_UINT32_MAX)
 8968:   , mHaveCachedAddChunks(PR_FALSE)
 8968:   , mHaveCachedSubChunks(PR_FALSE)
15023:   , mUpdateStartTime(0)
12334:   , mGethashNoise(0)
20648:   , mCleanHostKeysLock(nsnull)
 4024:   , mPendingLookupLock(nsnull)
    1: {
    1: }
 4024: 
    1: nsUrlClassifierDBServiceWorker::~nsUrlClassifierDBServiceWorker()
    1: {
 4024:   NS_ASSERTION(!mConnection,
    1:                "Db connection not closed, leaking memory!  Call CloseDb "
    1:                "to close the connection.");
20648: 
20648:   if (mCleanHostKeysLock)
20648:     PR_DestroyLock(mCleanHostKeysLock);
20648: 
 4024:   if (mPendingLookupLock)
 4024:     PR_DestroyLock(mPendingLookupLock);
    1: }
    1: 
 4024: nsresult
12334: nsUrlClassifierDBServiceWorker::Init(PRInt32 gethashNoise)
 4024: {
12334:   mGethashNoise = gethashNoise;
12334: 
 4024:   // Compute database filename
 4024: 
 4024:   // Because we dump raw integers into the database, this database isn't
 4024:   // portable between machine types, so store it in the local profile dir.
 4024:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
 4024:                                        getter_AddRefs(mDBFile));
 9868: 
 9868:   if (NS_FAILED(rv)) {
 9868:     rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
 9868:                                 getter_AddRefs(mDBFile));
 9868:   }
 9868: 
 9868:   if (NS_FAILED(rv)) return NS_ERROR_NOT_AVAILABLE;
 4024: 
 4024:   rv = mDBFile->Append(NS_LITERAL_STRING(DATABASE_FILENAME));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
20648:   mCleanHostKeysLock = PR_NewLock();
20648:   if (!mCleanHostKeysLock)
20648:     return NS_ERROR_OUT_OF_MEMORY;
20648: 
20648:   if (!mCleanHostKeys.Init(CLEAN_HOST_KEYS_SIZE))
20648:     return NS_ERROR_OUT_OF_MEMORY;
20648: 
20648:   if (!mCleanFragments.Init(CLEAN_FRAGMENTS_SIZE))
20648:     return NS_ERROR_OUT_OF_MEMORY;
20648: 
 4024:   mPendingLookupLock = PR_NewLock();
 4024:   if (!mPendingLookupLock)
 4024:     return NS_ERROR_OUT_OF_MEMORY;
 4024: 
 4024:   ResetUpdate();
 4024: 
14354:   mTableFreshness.Init();
14354: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::QueueLookup(const nsACString& spec,
10941:                                             nsIUrlClassifierLookupCallback* callback)
 4024: {
 4024:   nsAutoLock lock(mPendingLookupLock);
 4024: 
 4024:   PendingLookup* lookup = mPendingLookups.AppendElement();
 4024:   if (!lookup) return NS_ERROR_OUT_OF_MEMORY;
 4024: 
 4024:   lookup->mKey = spec;
 4024:   lookup->mCallback = callback;
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
20648: nsUrlClassifierDBServiceWorker::CheckCleanHost(const nsACString &spec,
20648:                                                PRBool *clean)
20648: {
20648:   nsAutoTArray<nsCString, 2> lookupHosts;
20648:   nsresult rv = GetHostKeys(spec, lookupHosts);
20648:   NS_ENSURE_SUCCESS(rv, rv);
20648: 
20648:   nsAutoLock lock(mCleanHostKeysLock);
20648: 
20648:   for (PRUint32 i = 0; i < lookupHosts.Length(); i++) {
20648:     if (!mCleanHostKeys.Has(lookupHosts[i])) {
20648:       *clean = PR_FALSE;
20648:       return NS_OK;
20648:     }
20648:   }
20648: 
20648:   *clean = PR_TRUE;
20648:   return NS_OK;
20648: }
20648: 
20648: nsresult
 4024: nsUrlClassifierDBServiceWorker::GetLookupFragments(const nsACString& spec,
20648:                                                    nsTArray<nsCString>& fragments)
 4024: {
 4024:   fragments.Clear();
 4024: 
 4024:   nsACString::const_iterator begin, end, iter;
 4024:   spec.BeginReading(begin);
 4024:   spec.EndReading(end);
 4024: 
 4024:   iter = begin;
 4024:   if (!FindCharInReadable('/', iter, end)) {
 4024:     return NS_OK;
 4024:   }
 4024: 
 4024:   const nsCSubstring& host = Substring(begin, iter++);
 6503:   nsCAutoString path;
 6503:   path.Assign(Substring(iter, end));
 4024: 
 4024:   /**
 4024:    * From the protocol doc:
 4024:    * For the hostname, the client will try at most 5 different strings.  They
 4024:    * are:
 4024:    * a) The exact hostname of the url
 4024:    * b) The 4 hostnames formed by starting with the last 5 components and
 4024:    *    successivly removing the leading component.  The top-level component
 4024:    *    can be skipped.
 4024:    */
24031:   nsTArray<nsCString> hosts;
24031:   hosts.AppendElement(host);
 4024: 
 4024:   host.BeginReading(begin);
 4024:   host.EndReading(end);
 4024:   int numComponents = 0;
 4024:   while (RFindInReadable(NS_LITERAL_CSTRING("."), begin, end) &&
 4024:          numComponents < MAX_HOST_COMPONENTS) {
 4024:     // don't bother checking toplevel domains
 4024:     if (++numComponents >= 2) {
 4024:       host.EndReading(iter);
24031:       hosts.AppendElement(Substring(end, iter));
 4024:     }
 4024:     end = begin;
 4024:     host.BeginReading(begin);
 4024:   }
 4024: 
 4024:   /**
 4024:    * From the protocol doc:
 6503:    * For the path, the client will also try at most 6 different strings.
 4024:    * They are:
 6503:    * a) the exact path of the url, including query parameters
 6503:    * b) the exact path of the url, without query parameters
 6503:    * c) the 4 paths formed by starting at the root (/) and
 4024:    *    successively appending path components, including a trailing
 4024:    *    slash.  This behavior should only extend up to the next-to-last
 4024:    *    path component, that is, a trailing slash should never be
 4024:    *    appended that was not present in the original url.
 4024:    */
24031:   nsTArray<nsCString> paths;
24031:   paths.AppendElement(path);
 4024: 
 6503:   path.BeginReading(iter);
 6503:   path.EndReading(end);
 6503:   if (FindCharInReadable('?', iter, end)) {
 6503:     path.BeginReading(begin);
 6503:     path = Substring(begin, iter);
24031:     paths.AppendElement(path);
 6503:   }
 6503: 
 7343:   // Check an empty path (for whole-domain blacklist entries)
24031:   paths.AppendElement(EmptyCString());
 7343: 
 7343:   numComponents = 1;
 4024:   path.BeginReading(begin);
 4024:   path.EndReading(end);
 4024:   iter = begin;
 4024:   while (FindCharInReadable('/', iter, end) &&
 4024:          numComponents < MAX_PATH_COMPONENTS) {
 4024:     iter++;
24031:     paths.AppendElement(Substring(begin, iter));
 4024:     numComponents++;
 4024:   }
 4024: 
24031:   for (PRUint32 hostIndex = 0; hostIndex < hosts.Length(); hostIndex++) {
24031:     for (PRUint32 pathIndex = 0; pathIndex < paths.Length(); pathIndex++) {
20648:       nsCString key;
24031:       key.Assign(hosts[hostIndex]);
 4024:       key.Append('/');
24031:       key.Append(paths[pathIndex]);
 4024:       LOG(("Chking %s", key.get()));
 4024: 
20648:       fragments.AppendElement(key);
 4024:     }
 4024:   }
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
24807: nsUrlClassifierDBServiceWorker::CacheEntries(const nsACString& spec)
24807: {
24807:   nsAutoTArray<nsCString, 2> lookupHosts;
24807:   nsresult rv = GetHostKeys(spec, lookupHosts);
24807:   NS_ENSURE_SUCCESS(rv, rv);
24807: 
24807:   // Build a unique string for this set of lookup hosts.
24807:   nsCAutoString hostKey;
24807:   for (PRUint32 i = 0; i < lookupHosts.Length(); i++) {
24807:     hostKey.Append(lookupHosts[i]);
24807:     hostKey.Append("|");
24807:   }
24807: 
24807:   if (hostKey == mCachedHostKey) {
24807:     // mCachedHostKeys is valid for this set of lookup hosts.
24807:     return NS_OK;
24807:   }
24807: 
24807:   mCachedEntries.Clear();
24807:   mCachedHostKey.Truncate();
24807: 
24807:   PRUint32 prevLength = 0;
24807:   for (PRUint32 i = 0; i < lookupHosts.Length(); i++) {
24807:     // First, if this key has been checked since our last update and
24807:     // had no entries, we don't need to check the DB here.  We also do
24807:     // this check before posting the lookup to this thread, but in
24807:     // case multiple lookups are queued at the same time, it's worth
24807:     // checking again here.
24807:     {
24807:       nsAutoLock lock(mCleanHostKeysLock);
24807:       if (mCleanHostKeys.Has(lookupHosts[i]))
24807:         continue;
24807:     }
24807: 
24807:     // Read the entries for this lookup houst
24807:     nsUrlClassifierDomainHash hostKeyHash;
24807:     hostKeyHash.FromPlaintext(lookupHosts[i], mCryptoHash);
24807:     mMainStore.ReadAddEntries(hostKeyHash, mCachedEntries);
24807: 
24807:     if (mCachedEntries.Length() == prevLength) {
24807:       // There were no entries in the db for this host key.  Go
24807:       // ahead and mark the host key as clean to help short-circuit
24807:       // future lookups.
24807:       nsAutoLock lock(mCleanHostKeysLock);
24807:       mCleanHostKeys.Put(lookupHosts[i]);
24807:     } else {
24807:       prevLength = mCachedEntries.Length();
24807:     }
24807:   }
24807: 
24807:   mCachedHostKey = hostKey;
24807: 
24807:   return NS_OK;
24807: }
24807: 
24807: nsresult
24807: nsUrlClassifierDBServiceWorker::Check(const nsACString& spec,
10941:                                       nsTArray<nsUrlClassifierLookupResult>& results)
 4024: {
24807:   // Read any entries that might apply to this URI into mCachedEntries
24807:   nsresult  rv = CacheEntries(spec);
24807:   NS_ENSURE_SUCCESS(rv, rv);
20648: 
20648:   if (mCachedEntries.Length() == 0) {
20648:     return NS_OK;
20648:   }
20648: 
20648:   // Now get the set of fragments to look up.
20648:   nsTArray<nsCString> fragments;
24807:   rv = GetLookupFragments(spec, fragments);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
14354:   PRInt64 now = (PR_Now() / PR_USEC_PER_SEC);
14354: 
20648:   // Now check each lookup fragment against the entries in the DB.
 4024:   for (PRUint32 i = 0; i < fragments.Length(); i++) {
20648:     // If this fragment has been previously checked, ignore it.
20648:     if (mCleanFragments.Has(fragments[i]))
20648:       continue;
20648: 
20648:     nsUrlClassifierCompleteHash lookupHash;
20648:     lookupHash.FromPlaintext(fragments[i], mCryptoHash);
20648: 
20648:     PRBool foundMatch = PR_FALSE;
20648:     for (PRUint32 j = 0; j < mCachedEntries.Length(); j++) {
20648:       nsUrlClassifierEntry &entry = mCachedEntries[j];
20648:       if (entry.Match(lookupHash)) {
10941:         // If the entry doesn't contain a complete hash, we need to
10941:         // save it here so that it can be compared against the
10941:         // complete hash.  However, we don't set entry.mHaveComplete
10941:         // because it isn't a verified part of the entry yet.
10941:         nsUrlClassifierLookupResult *result = results.AppendElement();
10941:         if (!result)
10941:           return NS_ERROR_OUT_OF_MEMORY;
10941: 
20648:         result->mLookupFragment = lookupHash;
10941:         result->mEntry = entry;
10941: 
10941:         // Fill in the table name.
10941:         GetTableName(entry.mTableId, result->mTableName);
14354: 
14354:         PRBool fresh;
14354:         PRInt64 tableUpdateTime;
14354:         if (mTableFreshness.Get(result->mTableName, &tableUpdateTime)) {
14354:           LOG(("tableUpdateTime: %lld, now: %lld, freshnessGuarantee: %d\n",
14354:                tableUpdateTime, now, gFreshnessGuarantee));
14354:           fresh = ((now - tableUpdateTime) <= gFreshnessGuarantee);
14354:         } else {
14354:           LOG(("No expiration time for this table.\n"));
14354:           fresh = PR_FALSE;
14354:         }
14354: 
14354:         // This is a confirmed result if we match a complete fragment in
14354:         // an up-to-date table.
14354:         result->mConfirmed = entry.mHaveComplete && fresh;
14354: 
20648:         foundMatch = PR_TRUE;
14354:         LOG(("Found a result.  complete=%d, fresh=%d",
14354:              entry.mHaveComplete, fresh));
20648:       }
20648:     }
20648: 
20648:     if (!foundMatch) {
20648:       // This fragment is clean, we don't need to bother checking it
20648:       // again until the next update.
20648:       mCleanFragments.Put(fragments[i]);
20648:     }
 4024:   }
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: /**
 4024:  * Lookup up a key in the database is a two step process:
 4024:  *
 4024:  * a) First we look for any Entries in the database that might apply to this
 4024:  *    url.  For each URL there are one or two possible domain names to check:
 4024:  *    the two-part domain name (example.com) and the three-part name
 4024:  *    (www.example.com).  We check the database for both of these.
 4024:  * b) If we find any entries, we check the list of fragments for that entry
 4024:  *    against the possible subfragments of the URL as described in the
 4024:  *    "Simplified Regular Expression Lookup" section of the protocol doc.
 4024:  */
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::DoLookup(const nsACString& spec,
10941:                                          nsIUrlClassifierLookupCallback* c)
 4024: {
 4024:   if (gShuttingDownThread) {
10941:     c->LookupComplete(nsnull);
 4024:     return NS_ERROR_NOT_INITIALIZED;
 4024:   }
 4024: 
 4024:   nsresult rv = OpenDb();
 4024:   if (NS_FAILED(rv)) {
10941:     c->LookupComplete(nsnull);
 4024:     return NS_ERROR_FAILURE;
 4024:   }
 4024: 
 4024: #if defined(PR_LOGGING)
 4024:   PRIntervalTime clockStart = 0;
 4024:   if (LOG_ENABLED()) {
 4024:     clockStart = PR_IntervalNow();
 4024:   }
 4024: #endif
 4024: 
10941:   nsAutoPtr<nsTArray<nsUrlClassifierLookupResult> > results;
10941:   results = new nsTArray<nsUrlClassifierLookupResult>();
10941:   if (!results) {
10941:     c->LookupComplete(nsnull);
10941:     return NS_ERROR_OUT_OF_MEMORY;
10941:   }
10941: 
24807:   // we ignore failures from Check because we'd rather return the
24807:   // results that were found than fail.
24807:   Check(spec, *results);
 4024: 
 4024: #if defined(PR_LOGGING)
 4024:   if (LOG_ENABLED()) {
 4024:     PRIntervalTime clockEnd = PR_IntervalNow();
 4024:     LOG(("query took %dms\n",
 4024:          PR_IntervalToMilliseconds(clockEnd - clockStart)));
 4024:   }
 4024: #endif
 4024: 
12334:   for (PRUint32 i = 0; i < results->Length(); i++) {
12334:     if (!results->ElementAt(i).mConfirmed) {
12334:       // We're going to be doing a gethash request, add some extra entries.
12334:       AddNoise(results->ElementAt(i).mEntry.mId, mGethashNoise, *results);
12334:       break;
12334:     }
12334:   }
12334: 
10941:   // At this point ownership of 'results' is handed to the callback.
10941:   c->LookupComplete(results.forget());
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::HandlePendingLookups()
 4024: {
 4024:   nsAutoLock lock(mPendingLookupLock);
 4024:   while (mPendingLookups.Length() > 0) {
 4024:     PendingLookup lookup = mPendingLookups[0];
 4024:     mPendingLookups.RemoveElementAt(0);
 4024:     lock.unlock();
 4024: 
 4024:     DoLookup(lookup.mKey, lookup.mCallback);
 4024: 
 4024:     lock.lock();
 4024:   }
 4024: 
 4024:   return NS_OK;
 4024: }
    1: 
12334: nsresult
12334: nsUrlClassifierDBServiceWorker::AddNoise(PRInt64 nearID,
12334:                                          PRInt32 count,
12334:                                          nsTArray<nsUrlClassifierLookupResult>& results)
12334: {
12334:   if (count < 1) {
12334:     return NS_OK;
12334:   }
12334: 
12334:   PRInt64 randomNum;
12334:   nsresult rv = mMainStore.RandomNumber(&randomNum);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   PRInt32 numBefore = randomNum % count;
12334: 
12334:   nsTArray<nsUrlClassifierEntry> noiseEntries;
12334:   rv = mMainStore.ReadNoiseEntries(nearID, numBefore, PR_TRUE, noiseEntries);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   rv = mMainStore.ReadNoiseEntries(nearID, count - numBefore, PR_FALSE, noiseEntries);
12334:   NS_ENSURE_SUCCESS(rv, rv);
12334: 
12334:   for (PRUint32 i = 0; i < noiseEntries.Length(); i++) {
12334:     nsUrlClassifierLookupResult *result = results.AppendElement();
12334:     if (!result)
12334:       return NS_ERROR_OUT_OF_MEMORY;
12334: 
12334:     result->mEntry = noiseEntries[i];
12334:     result->mConfirmed = PR_FALSE;
12334:     result->mNoise = PR_TRUE;
12334: 
12334:     // Fill in the table name.
12334:     GetTableName(noiseEntries[i].mTableId, result->mTableName);
12334:   }
12334: 
12334:   return NS_OK;
12334: }
12334: 
12334: 
    1: // Lookup a key in the db.
    1: NS_IMETHODIMP
 4024: nsUrlClassifierDBServiceWorker::Lookup(const nsACString& spec,
10941:                                        nsIUrlClassifierCallback* c)
 4024: {
 4024:   return HandlePendingLookups();
 4024: }
 4024: 
 4024: NS_IMETHODIMP
 4024: nsUrlClassifierDBServiceWorker::GetTables(nsIUrlClassifierCallback* c)
    1: {
  762:   if (gShuttingDownThread)
  762:     return NS_ERROR_NOT_INITIALIZED;
  762: 
    1:   nsresult rv = OpenDb();
    1:   if (NS_FAILED(rv)) {
    1:     NS_ERROR("Unable to open database");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 4024:   mozStorageStatementScoper scoper(mGetTablesStatement);
 4024: 
 4024:   nsCAutoString response;
 4024:   PRBool hasMore;
 4024:   while (NS_SUCCEEDED(rv = mGetTablesStatement->ExecuteStep(&hasMore)) &&
 4024:          hasMore) {
 4024:     nsCAutoString val;
 4024:     mGetTablesStatement->GetUTF8String(0, val);
 4024: 
 4024:     if (val.IsEmpty()) {
 4024:       continue;
 4024:     }
 4024: 
 4024:     response.Append(val);
 4024:     response.Append(';');
 4024: 
 4024:     mGetTablesStatement->GetUTF8String(1, val);
 4024: 
 6852:     PRBool haveAdds = PR_FALSE;
 4024:     if (!val.IsEmpty()) {
 4024:       response.Append("a:");
 4024:       response.Append(val);
 6852:       haveAdds = PR_TRUE;
 4024:     }
 4024: 
 4024:     mGetTablesStatement->GetUTF8String(2, val);
 4024:     if (!val.IsEmpty()) {
 6852:       if (haveAdds)
 6852:         response.Append(":");
 6852: 
 4024:       response.Append("s:");
 4024:       response.Append(val);
 4024:     }
 4024: 
 4024:     response.Append('\n');
 4024:   }
 4024: 
 4024:   if (NS_FAILED(rv)) {
 4024:     response.Truncate();
 4024:   }
 4024: 
 4024:   c->HandleEvent(response);
 4024: 
 4024:   return rv;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::GetTableId(const nsACString& table,
 4024:                                            PRUint32* tableId)
 4024: {
 4024:   mozStorageStatementScoper findScoper(mGetTableIdStatement);
 4024: 
 4024:   nsresult rv = mGetTableIdStatement->BindUTF8StringParameter(0, table);
 4001:   NS_ENSURE_SUCCESS(rv, rv);
 4001: 
 4024:   PRBool exists;
 4024:   rv = mGetTableIdStatement->ExecuteStep(&exists);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024:   if (exists) {
 4024:     *tableId = mGetTableIdStatement->AsInt32(0);
    1:     return NS_OK;
    1:   }
    1: 
 4024:   mozStorageStatementScoper insertScoper(mInsertTableIdStatement);
 4024:   rv = mInsertTableIdStatement->BindUTF8StringParameter(0, table);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = mInsertTableIdStatement->Execute();
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   PRInt64 rowId;
 4024:   rv = mConnection->GetLastInsertRowID(&rowId);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   if (rowId > PR_UINT32_MAX)
 4024:     return NS_ERROR_FAILURE;
 4024: 
 4024:   *tableId = rowId;
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::GetTableName(PRUint32 tableId,
 4024:                                              nsACString& tableName)
 4024: {
 4024:   mozStorageStatementScoper findScoper(mGetTableNameStatement);
 4024:   nsresult rv = mGetTableNameStatement->BindInt32Parameter(0, tableId);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   PRBool exists;
 4024:   rv = mGetTableNameStatement->ExecuteStep(&exists);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024:   if (!exists) return NS_ERROR_FAILURE;
 4024: 
 4024:   return mGetTableNameStatement->GetUTF8String(0, tableName);
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::InflateChunk(nsACString& chunk)
 4024: {
 4024:   nsCAutoString inflated;
 4024:   char buf[4096];
 4024: 
 4024:   const nsPromiseFlatCString& flat = PromiseFlatCString(chunk);
 4024: 
 4024:   z_stream stream;
 4024:   memset(&stream, 0, sizeof(stream));
 4024:   stream.next_in = (Bytef*)flat.get();
 4024:   stream.avail_in = flat.Length();
 4024: 
 4024:   if (inflateInit(&stream) != Z_OK) {
 4024:     return NS_ERROR_FAILURE;
 4024:   }
 4024: 
 4024:   int code;
 4024:   do {
 4024:     stream.next_out = (Bytef*)buf;
 4024:     stream.avail_out = sizeof(buf);
 4024: 
 4024:     code = inflate(&stream, Z_NO_FLUSH);
 4024:     PRUint32 numRead = sizeof(buf) - stream.avail_out;
 4024: 
 4024:     if (code == Z_OK || code == Z_STREAM_END) {
 4024:       inflated.Append(buf, numRead);
 4024:     }
 4024:   } while (code == Z_OK);
 4024: 
 4024:   inflateEnd(&stream);
 4024: 
 4024:   if (code != Z_STREAM_END) {
 4024:     return NS_ERROR_FAILURE;
 4024:   }
 4024: 
 4024:   chunk = inflated;
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
10212: nsUrlClassifierStore::DeleteEntry(nsUrlClassifierEntry& entry)
 4024: {
12334:   if (entry.mId == -1) {
 4024:     return NS_OK;
 4024:   }
 4024: 
 4024:   mozStorageStatementScoper scoper(mDeleteStatement);
12334:   mDeleteStatement->BindInt64Parameter(0, entry.mId);
 4024:   nsresult rv = mDeleteStatement->Execute();
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
12334:   entry.mId = -1;
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
10212: nsUrlClassifierStore::WriteEntry(nsUrlClassifierEntry& entry)
 4024: {
23818:   if (entry.mId != -1) {
23818:     // existing entry, just ignore it
23818:     return NS_OK;
23818:   }
23818: 
10988:   mozStorageStatementScoper scoper(mInsertStatement);
 4024: 
23818:   nsresult rv = BindStatement(entry, mInsertStatement);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
10988:   rv = mInsertStatement->Execute();
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   PRInt64 rowId;
 4024:   rv = mConnection->GetLastInsertRowID(&rowId);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   if (rowId > PR_UINT32_MAX) {
 4024:     return NS_ERROR_FAILURE;
 4024:   }
 4024: 
 4024:   entry.mId = rowId;
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
10988: nsresult
10988: nsUrlClassifierStore::UpdateEntry(nsUrlClassifierEntry& entry)
10988: {
10988:   mozStorageStatementScoper scoper(mUpdateStatement);
10988: 
12334:   NS_ENSURE_ARG(entry.mId != -1);
10988: 
10988:   nsresult rv = BindStatement(entry, mUpdateStatement);
10988:   NS_ENSURE_SUCCESS(rv, rv);
10988: 
10988:   rv = mUpdateStatement->Execute();
10988:   NS_ENSURE_SUCCESS(rv, rv);
10988: 
10988:   return NS_OK;
10988: }
10988: 
 6507: PRBool
 6507: nsUrlClassifierDBServiceWorker::IsCanonicalizedIP(const nsACString& host)
 6507: {
 6507:   // The canonicalization process will have left IP addresses in dotted
 6507:   // decimal with no surprises.
 6507:   PRUint32 i1, i2, i3, i4;
 6507:   char c;
 6507:   if (PR_sscanf(PromiseFlatCString(host).get(), "%u.%u.%u.%u%c",
 6507:                 &i1, &i2, &i3, &i4, &c) == 4) {
17096:     return (i1 <= 0xFF && i2 <= 0xFF && i3 <= 0xFF && i4 <= 0xFF);
 6507:   }
 6507: 
 6507:   return PR_FALSE;
 6507: }
 6507: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::GetKey(const nsACString& spec,
10941:                                        nsUrlClassifierDomainHash& hash)
 4024: {
 4024:   nsACString::const_iterator begin, end, iter;
 4024:   spec.BeginReading(begin);
 4024:   spec.EndReading(end);
 4024: 
 4024:   iter = begin;
 4024:   if (!FindCharInReadable('/', iter, end)) {
 4024:     return NS_OK;
 4024:   }
 4024: 
 6507:   const nsCSubstring& host = Substring(begin, iter);
 6507: 
 6507:   if (IsCanonicalizedIP(host)) {
10941:     nsCAutoString key;
10941:     key.Assign(host);
10941:     key.Append("/");
10941:     return hash.FromPlaintext(key, mCryptoHash);
 6507:   }
 6507: 
24031:   nsTArray<nsCString> hostComponents;
24031:   ParseString(PromiseFlatCString(host), '.', hostComponents);
24031: 
24031:   if (hostComponents.Length() < 2)
 4024:     return NS_ERROR_FAILURE;
 4024: 
24031:   PRInt32 last = PRInt32(hostComponents.Length()) - 1;
 4024:   nsCAutoString lookupHost;
 4024: 
24031:   if (hostComponents.Length() > 2) {
24031:     lookupHost.Append(hostComponents[last - 2]);
 4024:     lookupHost.Append(".");
 4024:   }
 4024: 
24031:   lookupHost.Append(hostComponents[last - 1]);
 4024:   lookupHost.Append(".");
24031:   lookupHost.Append(hostComponents[last]);
 4024:   lookupHost.Append("/");
 4024: 
 4024:   return hash.FromPlaintext(lookupHost, mCryptoHash);
 4024: }
 4024: 
 4024: nsresult
20648: nsUrlClassifierDBServiceWorker::GetHostKeys(const nsACString &spec,
20648:                                             nsTArray<nsCString> &hostKeys)
20648: {
20648:   nsACString::const_iterator begin, end, iter;
20648:   spec.BeginReading(begin);
20648:   spec.EndReading(end);
20648: 
20648:   iter = begin;
20648:   if (!FindCharInReadable('/', iter, end)) {
20648:     return NS_OK;
20648:   }
20648: 
20648:   const nsCSubstring& host = Substring(begin, iter);
20648: 
20648:   if (IsCanonicalizedIP(host)) {
20648:     nsCString *key = hostKeys.AppendElement();
20648:     if (!key)
20648:       return NS_ERROR_OUT_OF_MEMORY;
20648: 
20648:     key->Assign(host);
20648:     key->Append("/");
20648:     return NS_OK;
20648:   }
20648: 
24031:   nsTArray<nsCString> hostComponents;
24031:   ParseString(PromiseFlatCString(host), '.', hostComponents);
24031: 
24031:   if (hostComponents.Length() < 2) {
20648:     // no host or toplevel host, this won't match anything in the db
20648:     return NS_OK;
20648:   }
20648: 
20648:   // First check with two domain components
24031:   PRInt32 last = PRInt32(hostComponents.Length()) - 1;
20648:   nsCString *lookupHost = hostKeys.AppendElement();
20648:   if (!lookupHost)
20648:     return NS_ERROR_OUT_OF_MEMORY;
20648: 
24031:   lookupHost->Assign(hostComponents[last - 1]);
20648:   lookupHost->Append(".");
24031:   lookupHost->Append(hostComponents[last]);
20648:   lookupHost->Append("/");
20648: 
20648:   // Now check with three domain components
24031:   if (hostComponents.Length() > 2) {
20648:     nsCString *lookupHost2 = hostKeys.AppendElement();
20648:     if (!lookupHost2)
20648:       return NS_ERROR_OUT_OF_MEMORY;
24031:     lookupHost2->Assign(hostComponents[last - 2]);
20648:     lookupHost2->Append(".");
20648:     lookupHost2->Append(*lookupHost);
20648:   }
20648: 
20648:   return NS_OK;
20648: }
20648: 
20648: nsresult
10941: nsUrlClassifierDBServiceWorker::GetShaEntries(PRUint32 tableId,
10941:                                               PRUint32 chunkType,
10941:                                               PRUint32 chunkNum,
10941:                                               PRUint32 domainSize,
10941:                                               PRUint32 fragmentSize,
10941:                                               nsACString& chunk,
10941:                                               nsTArray<nsUrlClassifierEntry>& entries)
10941: {
10941:   PRUint32 start = 0;
10941:   while (start + domainSize + 1 <= chunk.Length()) {
10941:     nsUrlClassifierDomainHash domain;
10941:     domain.Assign(Substring(chunk, start, DOMAIN_LENGTH));
10941:     start += domainSize;
10941: 
10941:     // then there is a one-byte count of fragments
10941:     PRUint8 numEntries = static_cast<PRUint8>(chunk[start]);
10941:     start++;
10941: 
10941:     if (numEntries == 0) {
10941:       // if there are no fragments, the domain itself is treated as a
10941:       // fragment.  This will only work if domainHashSize == hashSize
10941:       if (domainSize != fragmentSize) {
10941:         NS_WARNING("Received 0-fragment entry where domainSize != fragmentSize");
10941:         return NS_ERROR_FAILURE;
10941:       }
10941: 
10941:       nsUrlClassifierEntry* entry = entries.AppendElement();
10941:       if (!entry) return NS_ERROR_OUT_OF_MEMORY;
10941: 
10941:       entry->mKey = domain;
10941:       entry->mTableId = tableId;
10941:       entry->mChunkId = chunkNum;
10941:       entry->SetHash(domain);
10941: 
10941:       if (chunkType == CHUNK_SUB) {
10941:         if (start + 4 > chunk.Length()) {
10941:           // there isn't as much data as there should be.
10941:           NS_WARNING("Received a zero-entry sub chunk without an associated add.");
10941:           return NS_ERROR_FAILURE;
10941:         }
10941:         const nsCSubstring& str = Substring(chunk, start, 4);
24899:         PRUint32 p;
24899:         memcpy(&p, str.BeginReading(), 4);
24899:         entry->mAddChunkId = PR_ntohl(p);
10941:         if (entry->mAddChunkId == 0) {
10941:           NS_WARNING("Received invalid chunk number.");
10941:           return NS_ERROR_FAILURE;
10941:         }
10941:         start += 4;
10941:       }
10941:     } else {
10941:       PRUint32 entrySize = fragmentSize;
10941:       if (chunkType == CHUNK_SUB) {
10941:         entrySize += 4;
10941:       }
10941:       if (start + (numEntries * entrySize) > chunk.Length()) {
10941:         // there isn't as much data as they said there would be.
10941:         NS_WARNING("Received a chunk without enough data");
10941:         return NS_ERROR_FAILURE;
10941:       }
10941: 
10941:       for (PRUint8 i = 0; i < numEntries; i++) {
10941:         nsUrlClassifierEntry* entry = entries.AppendElement();
10941:         if (!entry) return NS_ERROR_OUT_OF_MEMORY;
10941: 
10941:         entry->mKey = domain;
10941:         entry->mTableId = tableId;
10941:         entry->mChunkId = chunkNum;
10941: 
10941:         if (chunkType == CHUNK_SUB) {
10941:           const nsCSubstring& str = Substring(chunk, start, 4);
24899:           PRUint32 p;
24899:           memcpy(&p, str.BeginReading(), 4);
24899:           entry->mAddChunkId = PR_ntohl(p);
10941:           if (entry->mAddChunkId == 0) {
10941:             NS_WARNING("Received invalid chunk number.");
10941:             return NS_ERROR_FAILURE;
10941:           }
10941:           start += 4;
10941:         }
10941: 
10941:         if (fragmentSize == PARTIAL_LENGTH) {
10941:           nsUrlClassifierPartialHash hash;
10941:           hash.Assign(Substring(chunk, start, PARTIAL_LENGTH));
10941:           entry->SetHash(hash);
10941:         } else if (fragmentSize == COMPLETE_LENGTH) {
10941:           nsUrlClassifierCompleteHash hash;
10941:           hash.Assign(Substring(chunk, start, COMPLETE_LENGTH));
10941:           entry->SetHash(hash);
10941:         } else {
10941:           NS_ASSERTION(PR_FALSE, "Invalid fragment size!");
10941:           return NS_ERROR_FAILURE;
10941:         }
10941: 
10941:         start += fragmentSize;
10941:       }
10941:     }
10941:   }
10941: 
10941:   return NS_OK;
10941: }
10941: 
10941: nsresult
 4024: nsUrlClassifierDBServiceWorker::GetChunkEntries(const nsACString& table,
 4024:                                                 PRUint32 tableId,
10941:                                                 PRUint32 chunkType,
 4024:                                                 PRUint32 chunkNum,
10941:                                                 PRUint32 hashSize,
 4024:                                                 nsACString& chunk,
 4024:                                                 nsTArray<nsUrlClassifierEntry>& entries)
 4024: {
 4024:   nsresult rv;
 4024:   if (StringEndsWith(table, NS_LITERAL_CSTRING("-exp"))) {
 4024:     // regexp tables need to be ungzipped
 4024:     rv = InflateChunk(chunk);
 4024:     NS_ENSURE_SUCCESS(rv, rv);
 4024:   }
 4024: 
10941:   if (StringEndsWith(table, NS_LITERAL_CSTRING("-shavar"))) {
10941:     rv = GetShaEntries(tableId, chunkType, chunkNum, DOMAIN_LENGTH, hashSize,
10941:                        chunk, entries);
10941:     NS_ENSURE_SUCCESS(rv, rv);
 4024:   } else {
24031:     nsTArray<nsCString> lines;
24031:     ParseString(PromiseFlatCString(chunk), '\n', lines);
 7994: 
 7994:     // non-hashed tables need to be hashed
24031:     for (PRInt32 i = 0; i < PRInt32(lines.Length()); i++) {
10941:       nsUrlClassifierEntry *entry = entries.AppendElement();
10941:       if (!entry)
10941:         return NS_ERROR_OUT_OF_MEMORY;
10941: 
10941:       nsCAutoString entryStr;
10941:       if (chunkType == CHUNK_SUB) {
10941:         nsCString::const_iterator begin, iter, end;
24031:         lines[i].BeginReading(begin);
24031:         lines[i].EndReading(end);
10941:         iter = begin;
10941:         if (!FindCharInReadable(':', iter, end) ||
24031:             PR_sscanf(lines[i].get(), "%d:", &entry->mAddChunkId) != 1) {
10941:           NS_WARNING("Received sub chunk without associated add chunk.");
10941:           return NS_ERROR_FAILURE;
10941:         }
10941:         iter++;
10941:         entryStr = Substring(iter, end);
10941:       } else {
24031:         entryStr = lines[i];
10941:       }
10941: 
10941:       rv = GetKey(entryStr, entry->mKey);
10865:       NS_ENSURE_SUCCESS(rv, rv);
10865: 
10941:       entry->mTableId = tableId;
10941:       entry->mChunkId = chunkNum;
10941:       if (hashSize == PARTIAL_LENGTH) {
10941:         nsUrlClassifierPartialHash hash;
10941:         hash.FromPlaintext(entryStr, mCryptoHash);
10941:         entry->SetHash(hash);
10941:       } else if (hashSize == COMPLETE_LENGTH) {
10941:         nsUrlClassifierCompleteHash hash;
10941:         hash.FromPlaintext(entryStr, mCryptoHash);
10941:         entry->SetHash(hash);
10941:       } else {
10941:         NS_ASSERTION(PR_FALSE, "Invalid fragment size!");
10941:         return NS_ERROR_FAILURE;
10854:       }
 7994:     }
 4024:   }
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 8707: PRBool
11769: nsUrlClassifierDBServiceWorker::ParseChunkRange(nsACString::const_iterator &begin,
11769:                                                 const nsACString::const_iterator &end,
 8707:                                                 PRUint32 *first,
 8707:                                                 PRUint32 *last)
 8707: {
11769:   nsACString::const_iterator iter = begin;
11769:   FindCharInReadable(',', iter, end);
11769: 
11769:   nsCAutoString element(Substring(begin, iter));
11769:   begin = iter;
11769:   if (begin != end)
11769:     begin++;
11769: 
11769:   PRUint32 numRead = PR_sscanf(element.get(), "%u-%u", first, last);
 8707:   if (numRead == 2) {
 8707:     if (*first > *last) {
 8707:       PRUint32 tmp = *first;
 8707:       *first = *last;
 8707:       *last = tmp;
 8707:     }
 8707:     return PR_TRUE;
 8707:   }
 8707: 
 8707:   if (numRead == 1) {
 8707:     *last = *first;
 8707:     return PR_TRUE;
 8707:   }
 8707: 
 8707:   return PR_FALSE;
 8707: }
 8707: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::ParseChunkList(const nsACString& chunkStr,
 4024:                                                nsTArray<PRUint32>& chunks)
 4024: {
 4024:   LOG(("Parsing %s", PromiseFlatCString(chunkStr).get()));
 4024: 
11769:   nsACString::const_iterator begin, end;
11769:   chunkStr.BeginReading(begin);
11769:   chunkStr.EndReading(end);
11769:   while (begin != end) {
11769:     PRUint32 first, last;
11769:     if (ParseChunkRange(begin, end, &first, &last)) {
 4024:       for (PRUint32 num = first; num <= last; num++) {
 4024:         chunks.AppendElement(num);
 4024:       }
 4024:     }
 7994:   }
 4024: 
 4024:   LOG(("Got %d elements.", chunks.Length()));
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::JoinChunkList(nsTArray<PRUint32>& chunks,
 4024:                                               nsCString& chunkStr)
 4024: {
 4024:   chunkStr.Truncate();
 4024:   chunks.Sort();
 4024: 
 4024:   PRUint32 i = 0;
 4024:   while (i < chunks.Length()) {
 4024:     if (i != 0) {
 4024:       chunkStr.Append(',');
 4024:     }
 4024:     chunkStr.AppendInt(chunks[i]);
 4024: 
 4024:     PRUint32 first = i;
 4024:     PRUint32 last = first;
 4024:     i++;
14883:     while (i < chunks.Length() && (chunks[i] == chunks[i - 1] + 1 || chunks[i] == chunks[i - 1])) {
14883:       last = i++;
 4024:     }
 4024: 
 4024:     if (last != first) {
 4024:       chunkStr.Append('-');
14883:       chunkStr.AppendInt(chunks[last]);
 4024:     }
 4024:   }
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::GetChunkLists(PRUint32 tableId,
 4024:                                               nsACString& addChunks,
 4024:                                               nsACString& subChunks)
 4024: {
 4024:   addChunks.Truncate();
 4024:   subChunks.Truncate();
 4024: 
 4024:   mozStorageStatementScoper scoper(mGetChunkListsStatement);
 4024: 
 4024:   nsresult rv = mGetChunkListsStatement->BindInt32Parameter(0, tableId);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   PRBool hasMore = PR_FALSE;
 4024:   rv = mGetChunkListsStatement->ExecuteStep(&hasMore);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   if (!hasMore) {
 4024:     LOG(("Getting chunks for %d, found nothing", tableId));
 4024:     return NS_OK;
 4024:   }
 4024: 
 4024:   rv = mGetChunkListsStatement->GetUTF8String(0, addChunks);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = mGetChunkListsStatement->GetUTF8String(1, subChunks);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
20649:   LOG(("Getting chunks for %d, got %s/%s",
 4024:        tableId,
 4024:        PromiseFlatCString(addChunks).get(),
 4024:        PromiseFlatCString(subChunks).get()));
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::SetChunkLists(PRUint32 tableId,
 4024:                                               const nsACString& addChunks,
 4024:                                               const nsACString& subChunks)
 4024: {
 4024:   mozStorageStatementScoper scoper(mSetChunkListsStatement);
 4024: 
 4024:   mSetChunkListsStatement->BindUTF8StringParameter(0, addChunks);
 4024:   mSetChunkListsStatement->BindUTF8StringParameter(1, subChunks);
 4024:   mSetChunkListsStatement->BindInt32Parameter(2, tableId);
 4024:   nsresult rv = mSetChunkListsStatement->Execute();
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 8642: nsUrlClassifierDBServiceWorker::CacheChunkLists(PRUint32 tableId,
 8642:                                                 PRBool parseAdds,
 8642:                                                 PRBool parseSubs)
 8642: {
 8642:   nsresult rv;
 8642: 
 8642:   if (mHaveCachedLists && mCachedListsTable != tableId) {
 8642:     rv = FlushChunkLists();
 8642:     NS_ENSURE_SUCCESS(rv, rv);
 8642:   }
 8642: 
 8642:   if (!mHaveCachedLists) {
 8642:     rv = GetChunkLists(tableId, mCachedAddsStr, mCachedSubsStr);
 8642:     NS_ENSURE_SUCCESS(rv, rv);
 8642: 
 8642:     mHaveCachedLists = PR_TRUE;
 8642:     mCachedListsTable = tableId;
 8642:   }
 8642: 
 8642:   if (parseAdds && !mHaveCachedAddChunks) {
 8642:     ParseChunkList(mCachedAddsStr, mCachedAddChunks);
 8642:     mHaveCachedAddChunks = PR_TRUE;
 8642:   }
 8642: 
 8642:   if (parseSubs && !mHaveCachedSubChunks) {
 8642:     ParseChunkList(mCachedSubsStr, mCachedSubChunks);
 8642:     mHaveCachedSubChunks = PR_TRUE;
 8642:   }
 8642: 
 8642:   return NS_OK;
 8642: }
 8642: 
 8642: nsresult
 8642: nsUrlClassifierDBServiceWorker::FlushChunkLists()
 8642: {
 8642:   if (!mHaveCachedLists) {
 8642:     return NS_OK;
 8642:   }
 8642: 
 8642:   if (mHaveCachedAddChunks) {
 8642:     JoinChunkList(mCachedAddChunks, mCachedAddsStr);
 8642:   }
 8642: 
 8642:   if (mHaveCachedSubChunks) {
 8642:     JoinChunkList(mCachedSubChunks, mCachedSubsStr);
 8642:   }
 8642: 
 8642:   nsresult rv = SetChunkLists(mCachedListsTable,
 8642:                               mCachedAddsStr, mCachedSubsStr);
10941: 
 8642:   // clear out the cache before checking/returning the error here.
10941:   ClearCachedChunkLists();
10941: 
10941:   return rv;
10941: }
10941: 
10941: void
10941: nsUrlClassifierDBServiceWorker::ClearCachedChunkLists()
10941: {
 8642:   mCachedAddsStr.Truncate();
 8642:   mCachedSubsStr.Truncate();
 8642:   mCachedListsTable = PR_UINT32_MAX;
 8642:   mHaveCachedLists = PR_FALSE;
 8642: 
 8642:   mCachedAddChunks.Clear();
 8642:   mHaveCachedAddChunks = PR_FALSE;
 8642: 
 8642:   mCachedSubChunks.Clear();
 8642:   mHaveCachedSubChunks = PR_FALSE;
 8642: }
 8642: 
14994: PRBool
14994: nsUrlClassifierDBServiceWorker::InsertChunkId(nsTArray<PRUint32> &chunks,
14994:                                               PRUint32 chunkNum)
14994: {
14994:   PRUint32 low = 0, high = chunks.Length();
14994:   while (high > low) {
14994:     PRUint32 mid = (high + low) >> 1;
14994:     if (chunks[mid] == chunkNum)
14994:       return PR_FALSE;
14994:     if (chunks[mid] < chunkNum)
14994:       low = mid + 1;
14994:     else
14994:       high = mid;
14994:   }
14994: 
14994:   PRUint32 *item = chunks.InsertElementAt(low, chunkNum);
14994:   return (item != nsnull);
14994: }
14994: 
 8642: nsresult
 4024: nsUrlClassifierDBServiceWorker::AddChunk(PRUint32 tableId,
 4024:                                          PRUint32 chunkNum,
 4024:                                          nsTArray<nsUrlClassifierEntry>& entries)
 4024: {
 4024: #if defined(PR_LOGGING)
 4024:   PRIntervalTime clockStart = 0;
 4024:   if (LOG_ENABLED()) {
 4024:     clockStart = PR_IntervalNow();
 4024:   }
 4024: #endif
 4024: 
 8642:   nsresult rv = CacheChunkLists(tableId, PR_TRUE, PR_FALSE);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
14994: 
14994:   if (!InsertChunkId(mCachedAddChunks, chunkNum)) {
14994:     LOG(("Ignoring duplicate add chunk %d in table %d", chunkNum, tableId));
14994:     return NS_OK;
14994:   }
14994: 
14994:   LOG(("Adding %d entries to chunk %d in table %d", entries.Length(), chunkNum, tableId));
 4024: 
 4024:   nsTArray<PRUint32> entryIDs;
 4024: 
10941:   nsAutoTArray<nsUrlClassifierEntry, 5> subEntries;
20649:   rv = mPendingSubStore.ReadSubEntries(tableId, chunkNum, subEntries);
20649:   NS_ENSURE_SUCCESS(rv, rv);
10941: 
 4024:   for (PRUint32 i = 0; i < entries.Length(); i++) {
 4024:     nsUrlClassifierEntry& thisEntry = entries[i];
 4024: 
 4024:     HandlePendingLookups();
 4024: 
10941:     PRBool writeEntry = PR_TRUE;
10941:     for (PRUint32 j = 0; j < subEntries.Length(); j++) {
10941:       if (thisEntry.SubMatch(subEntries[j])) {
10941:         subEntries.RemoveElementAt(j);
10941: 
10941:         writeEntry = PR_FALSE;
10941:         break;
10854:       }
10865:     }
10865: 
10941:     HandlePendingLookups();
10941: 
10941:     if (writeEntry) {
10941:       rv = mMainStore.WriteEntry(thisEntry);
10212:       NS_ENSURE_SUCCESS(rv, rv);
10212:     }
10941:   }
 4024: 
20649:   rv = mPendingSubStore.ExpireAddChunk(tableId, chunkNum);
20649:   NS_ENSURE_SUCCESS(rv, rv);
20649: 
 4024: #if defined(PR_LOGGING)
 4024:   if (LOG_ENABLED()) {
 4024:     PRIntervalTime clockEnd = PR_IntervalNow();
10941:     LOG(("adding chunk %d took %dms\n", chunkNum,
10941:          PR_IntervalToMilliseconds(clockEnd - clockStart)));
 4024:   }
 4024: #endif
 4024: 
 4024:   return rv;
 4024: }
 4024: 
 4024: nsresult
10941: nsUrlClassifierStore::Expire(PRUint32 tableId, PRUint32 chunkNum)
 4024: {
 4024:   LOG(("Expiring chunk %d\n", chunkNum));
 4024: 
10941:   mozStorageStatementScoper expireScoper(mExpireStatement);
10941: 
10941:   nsresult rv = mExpireStatement->BindInt32Parameter(0, tableId);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
10941:   rv = mExpireStatement->BindInt32Parameter(1, chunkNum);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
10212:   mWorker->HandlePendingLookups();
 4024: 
10941:   rv = mExpireStatement->Execute();
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 8639:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
10212: nsUrlClassifierDBServiceWorker::ExpireAdd(PRUint32 tableId,
10212:                                           PRUint32 chunkNum)
10212: {
10212:   nsresult rv = CacheChunkLists(tableId, PR_TRUE, PR_FALSE);
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212:   mCachedAddChunks.RemoveElement(chunkNum);
10212: 
10212:   return mMainStore.Expire(tableId, chunkNum);
10212: }
10212: 
10212: nsresult
 4024: nsUrlClassifierDBServiceWorker::SubChunk(PRUint32 tableId,
 4024:                                          PRUint32 chunkNum,
 4024:                                          nsTArray<nsUrlClassifierEntry>& entries)
 4024: {
20649:   nsresult rv = CacheChunkLists(tableId, PR_TRUE, PR_TRUE);
14994: 
14994:   if (!InsertChunkId(mCachedSubChunks, chunkNum)) {
14994:     LOG(("Ignoring duplicate sub chunk %d in table %d", chunkNum, tableId));
14994:     return NS_OK;
14994:   }
14994: 
14994:   LOG(("Subbing %d entries in chunk %d in table %d", entries.Length(), chunkNum, tableId));
 4024: 
38022:   for (PRUint32 i = 0; i < entries.Length(); i++) {
10941:     nsAutoTArray<nsUrlClassifierEntry, 5> existingEntries;
 4024:     nsUrlClassifierEntry& thisEntry = entries[i];
 4024: 
 4024:     HandlePendingLookups();
 4024: 
20649:     // Check if we have the add chunk associated with the sub.
20649:     PRBool haveAdds = (mCachedAddChunks.BinaryIndexOf(thisEntry.mAddChunkId) !=
20649:                        mCachedAddChunks.NoIndex);
20649: 
20649:     if (haveAdds) {
20649:       rv = mMainStore.ReadAddEntries(thisEntry.mKey, thisEntry.mTableId,
10941:                                      thisEntry.mAddChunkId, existingEntries);
 4024:       NS_ENSURE_SUCCESS(rv, rv);
20649:     }
20649: 
10941:     for (PRUint32 j = 0; j < existingEntries.Length(); j++) {
10941:       if (existingEntries[j].SubMatch(thisEntry)) {
10941:         rv = mMainStore.DeleteEntry(existingEntries[j]);
10941:         NS_ENSURE_SUCCESS(rv, rv);
10941:         existingEntries.RemoveElementAt(j);
10941:         break;
10941:       }
10941:     }
10941: 
20649:     if (!haveAdds) {
10941:       // Save this entry in the pending subtraction store.
10941:       rv = mPendingSubStore.WriteEntry(thisEntry);
10212:       NS_ENSURE_SUCCESS(rv, rv);
10212:     }
 4024:   }
 4024: 
 8639:   return NS_OK;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::ExpireSub(PRUint32 tableId, PRUint32 chunkNum)
 4024: {
 8642:   nsresult rv = CacheChunkLists(tableId, PR_FALSE, PR_TRUE);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 8642:   mCachedSubChunks.RemoveElement(chunkNum);
 4024: 
10212:   return mPendingSubStore.Expire(tableId, chunkNum);
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::ProcessChunk(PRBool* done)
 4024: {
10941:   // wait until the chunk has been read
10941:   if (mPendingStreamUpdate.Length() < static_cast<PRUint32>(mChunkLen)) {
 4024:     *done = PR_TRUE;
 4024:     return NS_OK;
 4024:   }
 4024: 
 4024:   nsCAutoString chunk;
 4024:   chunk.Assign(Substring(mPendingStreamUpdate, 0, mChunkLen));
 4024:   mPendingStreamUpdate = Substring(mPendingStreamUpdate, mChunkLen);
 4024: 
 4024:   LOG(("Handling a chunk sized %d", chunk.Length()));
 4024: 
 4024:   nsTArray<nsUrlClassifierEntry> entries;
10941:   nsresult rv = GetChunkEntries(mUpdateTable, mUpdateTableId, mChunkType,
10941:                                 mChunkNum, mHashSize, chunk, entries);
 8645:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   if (mChunkType == CHUNK_ADD) {
 4024:     rv = AddChunk(mUpdateTableId, mChunkNum, entries);
 4024:   } else {
 4024:     rv = SubChunk(mUpdateTableId, mChunkNum, entries);
 4024:   }
 4024: 
 4024:   mState = STATE_LINE;
 4024:   *done = PR_FALSE;
 4024: 
 4024:   return rv;
 4024: }
 4024: 
 4024: nsresult
 4024: nsUrlClassifierDBServiceWorker::ProcessResponseLines(PRBool* done)
 4024: {
 4024:   PRUint32 cur = 0;
 4024:   PRInt32 next;
 4024: 
 4024:   nsresult rv;
 4024:   // We will run to completion unless we find a chunk line
 4024:   *done = PR_TRUE;
 4024: 
 4024:   nsACString& updateString = mPendingStreamUpdate;
 4024: 
 4024:   while(cur < updateString.Length() &&
 4024:         (next = updateString.FindChar('\n', cur)) != kNotFound) {
 4024:     const nsCSubstring& line = Substring(updateString, cur, next - cur);
 4024:     cur = next + 1;
 4024: 
 4024:     LOG(("Processing %s\n", PromiseFlatCString(line).get()));
 4024: 
12346:     if (mHMAC && mServerMAC.IsEmpty()) {
12346:       // If we did not receive a server MAC during BeginStream(), we
12346:       // require the first line of the update to be either a MAC or
12346:       // a request to rekey.
12346:       if (StringBeginsWith(line, NS_LITERAL_CSTRING("m:"))) {
12346:         mServerMAC = Substring(line, 2);
12346:         nsUrlClassifierUtils::UnUrlsafeBase64(mServerMAC);
12346: 
12346:         // The remainder of the pending update needs to be digested.
12346:         const nsCSubstring &toDigest = Substring(updateString, cur);
12346:         rv = mHMAC->Update(reinterpret_cast<const PRUint8*>(toDigest.BeginReading()),
12346:                            toDigest.Length());
12346:         NS_ENSURE_SUCCESS(rv, rv);
12346:       } else if (line.EqualsLiteral("e:pleaserekey")) {
12346:         mUpdateObserver->RekeyRequested();
12346:       } else {
12346:         LOG(("No MAC specified!"));
12346:         return NS_ERROR_FAILURE;
12346:       }
12346:     } else if (StringBeginsWith(line, NS_LITERAL_CSTRING("n:"))) {
 4024:       if (PR_sscanf(PromiseFlatCString(line).get(), "n:%d",
 4024:                     &mUpdateWait) != 1) {
 4024:         LOG(("Error parsing n: field: %s", PromiseFlatCString(line).get()));
 4024:         mUpdateWait = 0;
 4024:       }
12453:     } else if (line.EqualsLiteral("r:pleasereset")) {
12453:       mResetRequested = PR_TRUE;
12346:     } else if (line.EqualsLiteral("e:pleaserekey")) {
12346:       mUpdateObserver->RekeyRequested();
 4024:     } else if (StringBeginsWith(line, NS_LITERAL_CSTRING("i:"))) {
12346:       mUpdateTable.Assign(Substring(line, 2));
 4024:       GetTableId(mUpdateTable, &mUpdateTableId);
 4024:       LOG(("update table: '%s' (%d)", mUpdateTable.get(), mUpdateTableId));
10213:     } else if (StringBeginsWith(line, NS_LITERAL_CSTRING("u:"))) {
10213:       if (!mPrimaryStream) {
10213:         LOG(("Forwarded update tried to add its own forwarded update."));
10213:         return NS_ERROR_FAILURE;
10213:       }
10213: 
10213:       const nsCSubstring& data = Substring(line, 2);
12346:       if (mHMAC) {
12346:         // We're expecting MACs alongside any url forwards.
12346:         nsCSubstring::const_iterator begin, end, sepBegin, sepEnd;
12346:         data.BeginReading(begin);
12346:         sepBegin = begin;
12346: 
12346:         data.EndReading(end);
12346:         sepEnd = end;
12346: 
12346:         if (!RFindInReadable(NS_LITERAL_CSTRING(","), sepBegin, sepEnd)) {
12346:           NS_WARNING("No MAC specified for a redirect in a request that expects a MAC");
12346:           return NS_ERROR_FAILURE;
12346:         }
12346: 
12346:         nsCString serverMAC(Substring(sepEnd, end));
12346:         nsUrlClassifierUtils::UnUrlsafeBase64(serverMAC);
12346:         mUpdateObserver->UpdateUrlRequested(Substring(begin, sepBegin),
12346:                                             mUpdateTable,
12346:                                             serverMAC);
10213:       } else {
12346:         // We didn't ask for a MAC, none should have been specified.
12346:         mUpdateObserver->UpdateUrlRequested(data, mUpdateTable,
12346:                                             NS_LITERAL_CSTRING(""));
10213:       }
 4024:     } else if (StringBeginsWith(line, NS_LITERAL_CSTRING("a:")) ||
 4024:                StringBeginsWith(line, NS_LITERAL_CSTRING("s:"))) {
 4024:       mState = STATE_CHUNK;
 4024:       char command;
 4024:       if (PR_sscanf(PromiseFlatCString(line).get(),
10941:                     "%c:%d:%d:%d", &command, &mChunkNum, &mHashSize, &mChunkLen) != 4) {
 4024:         return NS_ERROR_FAILURE;
 4024:       }
10941: 
10941:       if (mChunkLen > MAX_CHUNK_SIZE) {
10941:         return NS_ERROR_FAILURE;
10941:       }
10941: 
10941:       if (!(mHashSize == PARTIAL_LENGTH || mHashSize == COMPLETE_LENGTH)) {
10941:         NS_WARNING("Invalid hash size specified in update.");
10941:         return NS_ERROR_FAILURE;
10941:       }
10941: 
 4024:       mChunkType = (command == 'a') ? CHUNK_ADD : CHUNK_SUB;
 4024: 
 4024:       // Done parsing lines, move to chunk state now
 4024:       *done = PR_FALSE;
 4024:       break;
 4024:     } else if (StringBeginsWith(line, NS_LITERAL_CSTRING("ad:"))) {
11769:       const nsCSubstring &list = Substring(line, 3);
11769:       nsACString::const_iterator begin, end;
11769:       list.BeginReading(begin);
11769:       list.EndReading(end);
11769:       while (begin != end) {
11769:         PRUint32 first, last;
11769:         if (ParseChunkRange(begin, end, &first, &last)) {
11769:           for (PRUint32 num = first; num <= last; num++) {
11769:             rv = ExpireAdd(mUpdateTableId, num);
11769:             NS_ENSURE_SUCCESS(rv, rv);
11769:           }
11769:         } else {
 4024:           return NS_ERROR_FAILURE;
 4024:         }
11769:       }
11769:     } else if (StringBeginsWith(line, NS_LITERAL_CSTRING("sd:"))) {
11769:       const nsCSubstring &list = Substring(line, 3);
11769:       nsACString::const_iterator begin, end;
11769:       list.BeginReading(begin);
11769:       list.EndReading(end);
11769:       while (begin != end) {
11769:         PRUint32 first, last;
11769:         if (ParseChunkRange(begin, end, &first, &last)) {
11769:           for (PRUint32 num = first; num <= last; num++) {
11769:             rv = ExpireSub(mUpdateTableId, num);
 4024:             NS_ENSURE_SUCCESS(rv, rv);
 8707:           }
11769:         } else {
 4024:           return NS_ERROR_FAILURE;
 4024:         }
 8707:       }
 4024:     } else {
 4024:       LOG(("ignoring unknown line: '%s'", PromiseFlatCString(line).get()));
 4024:     }
 4024:   }
 4024: 
 4024:   mPendingStreamUpdate = Substring(updateString, cur);
 4024: 
 4024:   return NS_OK;
 4024: }
 4024: 
 4024: void
10213: nsUrlClassifierDBServiceWorker::ResetStream()
10213: {
10213:   mState = STATE_LINE;
10213:   mChunkNum = 0;
10941:   mHashSize = 0;
10213:   mChunkLen = 0;
10213:   mInStream = PR_FALSE;
10213:   mPrimaryStream = PR_FALSE;
10213:   mUpdateTable.Truncate();
10213:   mPendingStreamUpdate.Truncate();
12346:   mServerMAC.Truncate();
12346:   mHMAC = nsnull;
10213: }
10213: 
10213: void
 4024: nsUrlClassifierDBServiceWorker::ResetUpdate()
 4024: {
 4024:   mUpdateWait = 0;
 4024:   mUpdateStatus = NS_OK;
10213:   mUpdateObserver = nsnull;
12346:   mUpdateClientKey.Truncate();
12453:   mResetRequested = PR_FALSE;
14354:   mUpdateTables.Clear();
10213: }
10213: 
20648: void
20648: nsUrlClassifierDBServiceWorker::ResetLookupCache()
20648: {
20648:     mCachedHostKey.Truncate();
20648:     mCachedEntries.Clear();
20648: 
20648:     mCleanFragments.Clear();
20648: 
20648:     nsAutoLock lock(mCleanHostKeysLock);
20648:     mCleanHostKeys.Clear();
20648: }
20648: 
10213: NS_IMETHODIMP
10941: nsUrlClassifierDBServiceWorker::SetHashCompleter(const nsACString &tableName,
10941:                                                  nsIUrlClassifierHashCompleter *completer)
10941: {
10941:   return NS_ERROR_NOT_IMPLEMENTED;
10941: }
10941: 
10941: NS_IMETHODIMP
12346: nsUrlClassifierDBServiceWorker::BeginUpdate(nsIUrlClassifierUpdateObserver *observer,
14354:                                             const nsACString &tables,
12346:                                             const nsACString &clientKey)
10213: {
10337:   if (gShuttingDownThread)
10337:     return NS_ERROR_NOT_INITIALIZED;
10337: 
10213:   NS_ENSURE_STATE(!mUpdateObserver);
10213: 
10213:   nsresult rv = OpenDb();
10213:   if (NS_FAILED(rv)) {
10213:     NS_ERROR("Unable to open database");
10213:     return NS_ERROR_FAILURE;
10213:   }
10213: 
10213:   PRBool transaction;
10213:   rv = mConnection->GetTransactionInProgress(&transaction);
10213:   if (NS_FAILED(rv)) {
10213:     mUpdateStatus = rv;
10213:     return rv;
10213:   }
10213: 
10213:   if (transaction) {
10213:     NS_WARNING("Transaction already in progress in nsUrlClassifierDBServiceWorker::BeginUpdate.  Cancelling update.");
10213:     mUpdateStatus = NS_ERROR_FAILURE;
10213:     return rv;
10213:   }
10213: 
15023:   rv = SetupUpdate();
10213:   if (NS_FAILED(rv)) {
10213:     mUpdateStatus = rv;
10213:     return rv;
10213:   }
10213: 
10213:   mUpdateObserver = observer;
10213: 
12346:   if (!clientKey.IsEmpty()) {
12346:     rv = nsUrlClassifierUtils::DecodeClientKey(clientKey, mUpdateClientKey);
12346:     NS_ENSURE_SUCCESS(rv, rv);
12346:   }
12346: 
10213:   // The first stream in an update is the only stream that may request
10213:   // forwarded updates.
10213:   mPrimaryStream = PR_TRUE;
10213: 
14354:   SplitTables(tables, mUpdateTables);
14354: 
10213:   return NS_OK;
10213: }
10213: 
10213: NS_IMETHODIMP
12346: nsUrlClassifierDBServiceWorker::BeginStream(const nsACString &table,
12346:                                             const nsACString &serverMAC)
10213: {
10337:   if (gShuttingDownThread)
10337:     return NS_ERROR_NOT_INITIALIZED;
10337: 
10213:   NS_ENSURE_STATE(mUpdateObserver);
10213:   NS_ENSURE_STATE(!mInStream);
10213: 
15023:   // We may have committed the update in FinishStream, if so set it up
15023:   // again here.
15023:   nsresult rv = SetupUpdate();
15023:   if (NS_FAILED(rv)) {
15023:     mUpdateStatus = rv;
15023:     return rv;
15023:   }
15023: 
10213:   mInStream = PR_TRUE;
10213: 
12346:   // If we're expecting a MAC, create the nsICryptoHMAC component now.
12346:   if (!mUpdateClientKey.IsEmpty()) {
13256:     nsCOMPtr<nsIKeyObjectFactory> keyObjectFactory(do_GetService(
13256:         "@mozilla.org/security/keyobjectfactory;1", &rv));
13256:     if (NS_FAILED(rv)) {
13256:       NS_WARNING("Failed to get nsIKeyObjectFactory service");
13256:       mUpdateStatus = rv;
13256:       return mUpdateStatus;
13256:     }
13256: 
13256:     nsCOMPtr<nsIKeyObject> keyObject;
13256:     rv = keyObjectFactory->KeyFromString(nsIKeyObject::HMAC, mUpdateClientKey, 
13256:         getter_AddRefs(keyObject));
13256:     if (NS_FAILED(rv)) {
13256:       NS_WARNING("Failed to create key object, maybe not FIPS compliant?");
13256:       mUpdateStatus = rv;
13256:       return mUpdateStatus;
13256:     }
13256: 
12346:     mHMAC = do_CreateInstance(NS_CRYPTO_HMAC_CONTRACTID, &rv);
12346:     if (NS_FAILED(rv)) {
12346:       NS_WARNING("Failed to create nsICryptoHMAC instance");
12346:       mUpdateStatus = rv;
12346:       return mUpdateStatus;
12346:     }
13256: 
13256:     rv = mHMAC->Init(nsICryptoHMAC::SHA1, keyObject);
12346:     if (NS_FAILED(rv)) {
12346:       NS_WARNING("Failed to initialize nsICryptoHMAC instance");
12346:       mUpdateStatus = rv;
12346:       return mUpdateStatus;
12346:     }
12346:   }
12346: 
12346:   mServerMAC = serverMAC;
12346: 
10941:   if (!table.IsEmpty()) {
10941:     mUpdateTable = table;
10941:     GetTableId(mUpdateTable, &mUpdateTableId);
10941:     LOG(("update table: '%s' (%d)", mUpdateTable.get(), mUpdateTableId));
10941:   }
10941: 
10213:   return NS_OK;
 4024: }
 4024: 
 4024: /**
 4024:  * Updating the database:
 4024:  *
42263:  * The Update() method takes a series of chunks separated with control data,
 4024:  * as described in
 4024:  * http://code.google.com/p/google-safe-browsing/wiki/Protocolv2Spec
 4024:  *
 4024:  * It will iterate through the control data until it reaches a chunk.  By
 4024:  * the time it reaches a chunk, it should have received
 4024:  * a) the table to which this chunk applies
 4024:  * b) the type of chunk (add, delete, expire add, expire delete).
 4024:  * c) the chunk ID
 4024:  * d) the length of the chunk.
 4024:  *
 4024:  * For add and subtract chunks, it needs to read the chunk data (expires
 4024:  * don't have any data).  Chunk data is a list of URI fragments whose
 4024:  * encoding depends on the type of table (which is indicated by the end
 4024:  * of the table name):
 4024:  * a) tables ending with -exp are a zlib-compressed list of URI fragments
 4024:  *    separated by newlines.
 4024:  * b) tables ending with -sha128 have the form
 4024:  *    [domain][N][frag0]...[fragN]
 4024:  *       16    1   16        16
 4024:  *    If N is 0, the domain is reused as a fragment.
 4024:  * c) any other tables are assumed to be a plaintext list of URI fragments
 4024:  *    separated by newlines.
 4024:  *
 4024:  * Update() can be fed partial data;  It will accumulate data until there is
 4024:  * enough to act on.  Finish() should be called when there will be no more
 4024:  * data.
 4024:  */
    1: NS_IMETHODIMP
10213: nsUrlClassifierDBServiceWorker::UpdateStream(const nsACString& chunk)
    1: {
  762:   if (gShuttingDownThread)
  762:     return NS_ERROR_NOT_INITIALIZED;
  762: 
10213:   NS_ENSURE_STATE(mInStream);
10213: 
 4024:   HandlePendingLookups();
 4024: 
    1:   LOG(("Update from Stream."));
    1:   nsresult rv = OpenDb();
    1:   if (NS_FAILED(rv)) {
    1:     NS_ERROR("Unable to open database");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 4024:   // if something has gone wrong during this update, just throw it away
 4024:   if (NS_FAILED(mUpdateStatus)) {
 4024:     return mUpdateStatus;
 4024:   }
 4024: 
12346:   if (mHMAC && !mServerMAC.IsEmpty()) {
12346:     rv = mHMAC->Update(reinterpret_cast<const PRUint8*>(chunk.BeginReading()),
12346:                        chunk.Length());
12346:     if (NS_FAILED(rv)) {
12346:       mUpdateStatus = rv;
12346:       return mUpdateStatus;
12346:     }
12346:   }
12346: 
 4024:   LOG(("Got %s\n", PromiseFlatCString(chunk).get()));
 4024: 
 4024:   mPendingStreamUpdate.Append(chunk);
 4024: 
 4024:   PRBool done = PR_FALSE;
 4024:   while (!done) {
 4024:     if (mState == STATE_CHUNK) {
 4024:       rv = ProcessChunk(&done);
 4001:     } else {
 4024:       rv = ProcessResponseLines(&done);
 4001:     }
 4024:     if (NS_FAILED(rv)) {
 4024:       mUpdateStatus = rv;
 4024:       return rv;
 3997:     }
 4001:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
10213: nsUrlClassifierDBServiceWorker::FinishStream()
    1: {
10337:   if (gShuttingDownThread)
10337:     return NS_ERROR_NOT_INITIALIZED;
10337: 
10213:   NS_ENSURE_STATE(mInStream);
10213:   NS_ENSURE_STATE(mUpdateObserver);
10213: 
15023:   PRInt32 nextStreamDelay = 0;
15023: 
12346:   if (NS_SUCCEEDED(mUpdateStatus) && mHMAC) {
12346:     nsCAutoString clientMAC;
12346:     mHMAC->Finish(PR_TRUE, clientMAC);
12346: 
12346:     if (clientMAC != mServerMAC) {
12346:       NS_WARNING("Invalid update MAC!");
12346:       LOG(("Invalid update MAC: expected %s, got %s",
12346:            mServerMAC.get(), clientMAC.get()));
12346:       mUpdateStatus = NS_ERROR_FAILURE;
12346:     }
15023:     PRIntervalTime updateTime = PR_IntervalNow() - mUpdateStartTime;
15023:     if (PR_IntervalToSeconds(updateTime) >=
15023:         static_cast<PRUint32>(gWorkingTimeThreshold)) {
15023:       // We've spent long enough working that we should commit what we
15023:       // have and hold off for a bit.
15023:       ApplyUpdate();
15023: 
15023:       nextStreamDelay = gDelayTime * 1000;
15023:     }
15023:   }
15023: 
15023:   mUpdateObserver->StreamFinished(mUpdateStatus,
15023:                                   static_cast<PRUint32>(nextStreamDelay));
10213: 
10213:   ResetStream();
10213: 
10213:   return NS_OK;
10213: }
10213: 
15023: nsresult
15023: nsUrlClassifierDBServiceWorker::SetupUpdate()
15023: {
15023:   LOG(("nsUrlClassifierDBServiceWorker::SetupUpdate"));
15023:   PRBool inProgress;
15023:   nsresult rv = mConnection->GetTransactionInProgress(&inProgress);
15023:   if (inProgress) {
15023:     return NS_OK;
15023:   }
15023: 
15023:   mUpdateStartTime = PR_IntervalNow();
15023: 
15023:   rv = mConnection->BeginTransaction();
15023:   NS_ENSURE_SUCCESS(rv, rv);
15023: 
15023:   if (gUpdateCacheSize > 0) {
46994:     PRBool hasResult;
46994:     rv = mGetPageSizeStatement->ExecuteStep(&hasResult);
46994:     NS_ENSURE_SUCCESS(rv, rv);
46994: 
46994:     NS_ASSERTION(hasResult, "Should always be able to get page size from sqlite");
46994:     PRUint32 pageSize = mGetPageSizeStatement->AsInt32(0);
46994:     PRUint32 cachePages = gUpdateCacheSize / pageSize;
15023:     nsCAutoString cacheSizePragma("PRAGMA cache_size=");
15023:     cacheSizePragma.AppendInt(cachePages);
15023:     rv = mConnection->ExecuteSimpleSQL(cacheSizePragma);
15023:     NS_ENSURE_SUCCESS(rv, rv);
15023:     mGrewCache = PR_TRUE;
15023:   }
15023: 
15023:   return NS_OK;
15023: }
15023: 
15023: nsresult
15023: nsUrlClassifierDBServiceWorker::ApplyUpdate()
15023: {
15023:   LOG(("nsUrlClassifierDBServiceWorker::ApplyUpdate"));
15023: 
57898:   if (mConnection) {
15023:     if (NS_FAILED(mUpdateStatus)) {
15023:       mConnection->RollbackTransaction();
15023:     } else {
15023:       mUpdateStatus = FlushChunkLists();
15023:       if (NS_SUCCEEDED(mUpdateStatus)) {
15023:         mUpdateStatus = mConnection->CommitTransaction();
15023:       }
15023:     }
57898:   }
15023: 
20648:   if (NS_SUCCEEDED(mUpdateStatus)) {
20648:     // We have modified the db, we can't trust the set of clean
20648:     // fragments or domains anymore.
20648:     ResetLookupCache();
20648:   }
20648: 
15023:   if (mGrewCache) {
15023:     // During the update we increased the page cache to bigger than we
15023:     // want to keep around.  At the moment, the only reliable way to make
15023:     // sure that the page cache is freed is to reopen the connection.
15023:     mGrewCache = PR_FALSE;
15023:     CloseDb();
15023:     OpenDb();
15023:   }
15023: 
15023:   mUpdateStartTime = 0;
15023: 
15023:   return NS_OK;
15023: }
15023: 
15016: NS_IMETHODIMP
15016: nsUrlClassifierDBServiceWorker::FinishUpdate()
15006: {
15023:   LOG(("nsUrlClassifierDBServiceWorker::FinishUpdate()"));
15016:   if (gShuttingDownThread)
15016:     return NS_ERROR_NOT_INITIALIZED;
15016: 
15016:   NS_ENSURE_STATE(!mInStream);
15016:   NS_ENSURE_STATE(mUpdateObserver);
15016: 
16701:   // We need to get the error code before ApplyUpdate, because it might
16701:   // close/open the connection.
16701:   PRInt32 errcode = SQLITE_OK;
57898:   if (mConnection)
16701:     mConnection->GetLastError(&errcode);
16701: 
15023:   ApplyUpdate();
15016: 
15016:   if (NS_SUCCEEDED(mUpdateStatus)) {
15016:     mUpdateObserver->UpdateSuccess(mUpdateWait);
15016:   } else {
15016:     mUpdateObserver->UpdateError(mUpdateStatus);
15016:   }
15016: 
16701:   // It's important that we only reset the database on an update
16701:   // command if the update was successful, otherwise unauthenticated
16701:   // updates could cause a database reset.
16701:   PRBool resetDB = (NS_SUCCEEDED(mUpdateStatus) && mResetRequested) ||
16701:                     errcode == SQLITE_CORRUPT;
16701: 
16701:   if (!resetDB) {
15016:     if (NS_SUCCEEDED(mUpdateStatus)) {
15016:       PRInt64 now = (PR_Now() / PR_USEC_PER_SEC);
15016:       for (PRUint32 i = 0; i < mUpdateTables.Length(); i++) {
15016:         LOG(("Successfully updated %s", mUpdateTables[i].get()));
15016:         mTableFreshness.Put(mUpdateTables[i], now);
15016:       }
15016:     } else {
15016:       for (PRUint32 i = 0; i < mUpdateTables.Length(); i++) {
15016:         LOG(("Failed updating %s", mUpdateTables[i].get()));
15016:         mTableFreshness.Remove(mUpdateTables[i]);
15016:       }
15016:     }
15016:   }
15016: 
15016:   ResetUpdate();
15016: 
16701:   if (resetDB) {
15016:     ResetDatabase();
15006:   }
15006: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
10212: nsUrlClassifierDBServiceWorker::ResetDatabase()
10212: {
12453:   LOG(("nsUrlClassifierDBServiceWorker::ResetDatabase [%p]", this));
10941:   ClearCachedChunkLists();
10941: 
14354:   mTableFreshness.Clear();
20648:   ResetLookupCache();
14354: 
10212:   nsresult rv = CloseDb();
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10212:   mDBFile->Remove(PR_FALSE);
10212: 
10212:   return NS_OK;
10212: }
10212: 
10212: NS_IMETHODIMP
10213: nsUrlClassifierDBServiceWorker::CancelUpdate()
    1: {
10213:   LOG(("CancelUpdate"));
10213: 
10262:   if (mUpdateObserver) {
10213:     mUpdateStatus = NS_BINDING_ABORTED;
10213: 
10941:     ClearCachedChunkLists();
10213:     mConnection->RollbackTransaction();
10213:     mUpdateObserver->UpdateError(mUpdateStatus);
10213: 
14354:     for (PRUint32 i = 0; i < mUpdateTables.Length(); i++) {
14354:       LOG(("Failed updating %s", mUpdateTables[i].get()));
14354:       mTableFreshness.Remove(mUpdateTables[i]);
14354:     }
14354: 
10213:     ResetStream();
 4024:     ResetUpdate();
10262:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Allows the main thread to delete the connection which may be in
    1: // a background thread.
    1: // XXX This could be turned into a single shutdown event so the logic
    1: // is simpler in nsUrlClassifierDBService::Shutdown.
    1: NS_IMETHODIMP
    1: nsUrlClassifierDBServiceWorker::CloseDb()
    1: {
 4024:   if (mConnection) {
10212:     mMainStore.Close();
10212:     mPendingSubStore.Close();
 4024: 
 4024:     mGetChunkListsStatement = nsnull;
 4024:     mSetChunkListsStatement = nsnull;
 4024: 
 4024:     mGetTablesStatement = nsnull;
 4024:     mGetTableIdStatement = nsnull;
 4024:     mGetTableNameStatement = nsnull;
 4024:     mInsertTableIdStatement = nsnull;
46994:     mGetPageSizeStatement = nsnull;
 4024: 
 4024:     mConnection = nsnull;
    1:     LOG(("urlclassifier db closed\n"));
    1:   }
 4024: 
 4024:   mCryptoHash = nsnull;
 4024: 
    1:   return NS_OK;
    1: }
    1: 
10988: NS_IMETHODIMP
10988: nsUrlClassifierDBServiceWorker::CacheCompletions(nsTArray<nsUrlClassifierLookupResult> *results)
10988: {
10988:   LOG(("nsUrlClassifierDBServiceWorker::CacheCompletions [%p]", this));
10988: 
10988:   nsAutoPtr<nsTArray<nsUrlClassifierLookupResult> > resultsPtr(results);
10988: 
10988:   // Start a new transaction.  If a transaction is open for an update
10988:   // this will be a noop, and this cache will be included in the
10988:   // update's transaction.
10988:   mozStorageTransaction trans(mConnection, PR_TRUE);
10988: 
10988:   for (PRUint32 i = 0; i < results->Length(); i++) {
10988:     nsUrlClassifierLookupResult& result = results->ElementAt(i);
10988:     // Failing to update here shouldn't be fatal (and might be common,
10988:     // if we're updating entries that were removed since they were
10988:     // returned after a lookup).
10988:     mMainStore.UpdateEntry(result.mEntry);
10988:   }
10988: 
20648:   // Completions change entries in the DB, the cached set of entries is
20648:   // no longer valid.
20648:   mCachedHostKey.Truncate();
20648:   mCachedEntries.Clear();
20648: 
10988:   return NS_OK;
10988: }
10988: 
    1: nsresult
 4001: nsUrlClassifierDBServiceWorker::OpenDb()
 4001: {
 4001:   // Connection already open, don't do anything.
 4024:   if (mConnection)
 4001:     return NS_OK;
 4001: 
 4001:   LOG(("Opening db\n"));
 4024: 
 4024:   nsresult rv;
 4001:   // open the connection
 4001:   nsCOMPtr<mozIStorageService> storageService =
 4001:     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
 4001:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 8732:   PRBool exists;
 8732:   rv = mDBFile->Exists(&exists);
 8732:   NS_ENSURE_SUCCESS(rv, rv);
 8732:   PRBool newDB = !exists;
 8732: 
 4024:   nsCOMPtr<mozIStorageConnection> connection;
 4024:   rv = storageService->OpenDatabase(mDBFile, getter_AddRefs(connection));
13508:   if (rv == NS_ERROR_FILE_CORRUPTED) {
 4001:     // delete the db and try opening again
 4024:     rv = mDBFile->Remove(PR_FALSE);
 4001:     NS_ENSURE_SUCCESS(rv, rv);
 8732: 
 8732:     newDB = PR_TRUE;
 8732: 
 4024:     rv = storageService->OpenDatabase(mDBFile, getter_AddRefs(connection));
13508:   }
12208:   NS_ENSURE_SUCCESS(rv, rv);
 3997: 
 8732:   if (!newDB) {
 8732:     PRInt32 databaseVersion;
 8732:     rv = connection->GetSchemaVersion(&databaseVersion);
 8732:     NS_ENSURE_SUCCESS(rv, rv);
 8732: 
 8732:     if (databaseVersion != IMPLEMENTATION_VERSION) {
 8732:       LOG(("Incompatible database, removing."));
 8732: 
 8732:       rv = connection->Close();
 8732:       NS_ENSURE_SUCCESS(rv, rv);
 8732: 
 8732:       rv = mDBFile->Remove(PR_FALSE);
 8732:       NS_ENSURE_SUCCESS(rv, rv);
 8732: 
 8732:       newDB = PR_TRUE;
 8732: 
 8732:       rv = storageService->OpenDatabase(mDBFile, getter_AddRefs(connection));
 8732:       NS_ENSURE_SUCCESS(rv, rv);
 8732:     }
 8732:   }
 8732: 
51868:   connection->SetGrowthIncrement(5 * 1024 * 1024, EmptyCString());
14883:   rv = connection->ExecuteSimpleSQL(NS_LITERAL_CSTRING("PRAGMA synchronous=OFF"));
14883:   NS_ENSURE_SUCCESS(rv, rv);
14883: 
 8732:   if (newDB) {
 8732:     rv = connection->SetSchemaVersion(IMPLEMENTATION_VERSION);
 8732:     NS_ENSURE_SUCCESS(rv, rv);
 8732:   }
 8732: 
 4024:   // Create the table
 4024:   rv = MaybeCreateTables(connection);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
10212:   rv = mMainStore.Init(this, connection,
10941:                        NS_LITERAL_CSTRING("moz_classifier"));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
10212:   rv = mPendingSubStore.Init(this, connection,
10941:                              NS_LITERAL_CSTRING("moz_subs"));
10988:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->CreateStatement
 4024:          (NS_LITERAL_CSTRING("SELECT add_chunks, sub_chunks FROM moz_tables"
 4024:                              " WHERE id=?1"),
 4024:           getter_AddRefs(mGetChunkListsStatement));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->CreateStatement
 4024:          (NS_LITERAL_CSTRING("UPDATE moz_tables"
 4024:                              " SET add_chunks=?1, sub_chunks=?2"
 4024:                              " WHERE id=?3"),
 4024:           getter_AddRefs(mSetChunkListsStatement));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->CreateStatement
 4024:          (NS_LITERAL_CSTRING("SELECT name, add_chunks, sub_chunks"
 4024:                              " FROM moz_tables"),
 4024:           getter_AddRefs(mGetTablesStatement));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->CreateStatement
 4024:     (NS_LITERAL_CSTRING("SELECT id FROM moz_tables"
 4024:                         " WHERE name = ?1"),
 4024:      getter_AddRefs(mGetTableIdStatement));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->CreateStatement
 4024:     (NS_LITERAL_CSTRING("SELECT name FROM moz_tables"
 4024:                         " WHERE id = ?1"),
 4024:      getter_AddRefs(mGetTableNameStatement));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->CreateStatement
 4024:     (NS_LITERAL_CSTRING("INSERT INTO moz_tables(id, name, add_chunks, sub_chunks)"
 4024:                         " VALUES (null, ?1, null, null)"),
 4024:      getter_AddRefs(mInsertTableIdStatement));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
46994:   rv = connection->CreateStatement
46994:     (NS_LITERAL_CSTRING("PRAGMA page_size"),
46994:      getter_AddRefs(mGetPageSizeStatement));
46994:   NS_ENSURE_SUCCESS(rv, rv);
46994: 
 4024:   mConnection = connection;
 4024: 
 4024:   mCryptoHash = do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4001: 
 4001:   return NS_OK;
 4001: }
 4001: 
 4001: nsresult
 4024: nsUrlClassifierDBServiceWorker::MaybeCreateTables(mozIStorageConnection* connection)
 4001: {
 4024:   LOG(("MaybeCreateTables\n"));
 4024: 
 4024:   nsresult rv = connection->ExecuteSimpleSQL(
 4024:     NS_LITERAL_CSTRING("CREATE TABLE IF NOT EXISTS moz_classifier"
 4024:                        " (id INTEGER PRIMARY KEY,"
 4024:                        "  domain BLOB,"
10941:                        "  partial_data BLOB,"
10941:                        "  complete_data BLOB,"
10941:                        "  chunk_id INTEGER,"
 4024:                        "  table_id INTEGER)"));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->ExecuteSimpleSQL(
10941:     NS_LITERAL_CSTRING("CREATE INDEX IF NOT EXISTS"
 4024:                        " moz_classifier_domain_index"
10941:                        " ON moz_classifier(domain)"));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   rv = connection->ExecuteSimpleSQL(
10941:     NS_LITERAL_CSTRING("CREATE INDEX IF NOT EXISTS"
10941:                        " moz_classifier_chunk_index"
10941:                        " ON moz_classifier(chunk_id)"));
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10212:   rv = connection->ExecuteSimpleSQL(
10212:     NS_LITERAL_CSTRING("CREATE TABLE IF NOT EXISTS moz_subs"
10212:                        " (id INTEGER PRIMARY KEY,"
10212:                        "  domain BLOB,"
10941:                        "  partial_data BLOB,"
10941:                        "  complete_data BLOB,"
10941:                        "  chunk_id INTEGER,"
10941:                        "  table_id INTEGER,"
10941:                        "  add_chunk_id INTEGER)"));
10865:   NS_ENSURE_SUCCESS(rv, rv);
10865: 
10865:   rv = connection->ExecuteSimpleSQL(
10941:     NS_LITERAL_CSTRING("CREATE INDEX IF NOT EXISTS"
20649:                        " moz_subs_addchunk_index"
20649:                        " ON moz_subs(add_chunk_id)"));
10865:   NS_ENSURE_SUCCESS(rv, rv);
10865: 
10865:   rv = connection->ExecuteSimpleSQL(
10941:     NS_LITERAL_CSTRING("CREATE INDEX IF NOT EXISTS"
10941:                        " moz_subs_chunk_index"
10941:                        " ON moz_subs(chunk_id)"));
10212:   NS_ENSURE_SUCCESS(rv, rv);
10212: 
10212:   rv = connection->ExecuteSimpleSQL(
 4024:     NS_LITERAL_CSTRING("CREATE TABLE IF NOT EXISTS moz_tables"
 4024:                        " (id INTEGER PRIMARY KEY,"
 4024:                        "  name TEXT,"
 4024:                        "  add_chunks TEXT,"
 4024:                        "  sub_chunks TEXT);"));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   return rv;
    1: }
    1: 
    1: // -------------------------------------------------------------------------
10941: // nsUrlClassifierLookupCallback
10941: //
10941: // This class takes the results of a lookup found on the worker thread
10941: // and handles any necessary partial hash expansions before calling
10941: // the client callback.
10941: 
10941: class nsUrlClassifierLookupCallback : public nsIUrlClassifierLookupCallback
10941:                                     , public nsIUrlClassifierHashCompleterCallback
10941: {
10941: public:
10941:   NS_DECL_ISUPPORTS
10941:   NS_DECL_NSIURLCLASSIFIERLOOKUPCALLBACK
10941:   NS_DECL_NSIURLCLASSIFIERHASHCOMPLETERCALLBACK
10941: 
10941:   nsUrlClassifierLookupCallback(nsUrlClassifierDBService *dbservice,
10941:                                 nsIUrlClassifierCallback *c)
10941:     : mDBService(dbservice)
10941:     , mResults(nsnull)
10941:     , mPendingCompletions(0)
10941:     , mCallback(c)
10941:     {}
10941: 
10941: private:
10941:   nsresult HandleResults();
10941: 
10941:   nsRefPtr<nsUrlClassifierDBService> mDBService;
10941:   nsAutoPtr<nsTArray<nsUrlClassifierLookupResult> > mResults;
10988: 
10988:   // Completed results to send back to the worker for caching.
10988:   nsAutoPtr<nsTArray<nsUrlClassifierLookupResult> > mCacheResults;
10988: 
10941:   PRUint32 mPendingCompletions;
10941:   nsCOMPtr<nsIUrlClassifierCallback> mCallback;
10941: };
10941: 
10941: NS_IMPL_THREADSAFE_ISUPPORTS2(nsUrlClassifierLookupCallback,
10941:                               nsIUrlClassifierLookupCallback,
10941:                               nsIUrlClassifierHashCompleterCallback)
10941: 
10941: NS_IMETHODIMP
10941: nsUrlClassifierLookupCallback::LookupComplete(nsTArray<nsUrlClassifierLookupResult>* results)
10941: {
10941:   NS_ASSERTION(mResults == nsnull,
10941:                "Should only get one set of results per nsUrlClassifierLookupCallback!");
10941: 
10941:   if (!results) {
10941:     HandleResults();
10941:     return NS_OK;
10941:   }
10941: 
10941:   mResults = results;
12334:   mResults->Sort();
10941: 
14354:   // Check the results entries that need to be completed.
10941:   for (PRUint32 i = 0; i < results->Length(); i++) {
10941:     nsUrlClassifierLookupResult& result = results->ElementAt(i);
14354: 
14354:     // We will complete partial matches and matches that are stale.
10941:     if (!result.mConfirmed) {
10941:       nsCOMPtr<nsIUrlClassifierHashCompleter> completer;
10941:       if (mDBService->GetCompleter(result.mTableName,
10941:                                    getter_AddRefs(completer))) {
10941:         nsCAutoString partialHash;
14354:         PRUint8 *buf =
14354:           result.mEntry.mHavePartial ? result.mEntry.mPartialHash.buf
14354:                                      : result.mEntry.mCompleteHash.buf;
14354:         partialHash.Assign(reinterpret_cast<char*>(buf), PARTIAL_LENGTH);
10941: 
10941:         nsresult rv = completer->Complete(partialHash, this);
10941:         if (NS_SUCCEEDED(rv)) {
10941:           mPendingCompletions++;
10941:         }
10941:       } else {
14354:         // For tables with no hash completer, a complete hash match is
14354:         // good enough, it doesn't need to be fresh. (we need the
14354:         // mLookupFragment comparison to weed out noise entries, which
14354:         // should never be confirmed).
14354:         if (result.mEntry.mHaveComplete
14354:             && (result.mLookupFragment == result.mEntry.mCompleteHash)) {
14354:           result.mConfirmed = PR_TRUE;
14354:         } else {
10941:           NS_WARNING("Partial match in a table without a valid completer, ignoring partial match.");
10941:         }
10941:       }
10941:     }
14354:   }
10941: 
10941:   if (mPendingCompletions == 0) {
10941:     // All results were complete, we're ready!
10941:     HandleResults();
10941:   }
10941: 
10941:   return NS_OK;
10941: }
10941: 
10941: NS_IMETHODIMP
10941: nsUrlClassifierLookupCallback::CompletionFinished(nsresult status)
10941: {
10941:   LOG(("nsUrlClassifierLookupCallback::CompletionFinished [%p, %08x]",
10941:        this, status));
10941:   if (NS_FAILED(status)) {
10941:     NS_WARNING("gethash response failed.");
10941:   }
10941: 
10941:   mPendingCompletions--;
10941:   if (mPendingCompletions == 0) {
10941:     HandleResults();
10988: 
10988:     if (mCacheResults) {
10988:       // This hands ownership of the cache results array back to the worker
10988:       // thread.
10988:       mDBService->CacheCompletions(mCacheResults.forget());
10988:     }
10941:   }
10941: 
10941:   return NS_OK;
10941: }
10941: 
10941: NS_IMETHODIMP
10941: nsUrlClassifierLookupCallback::Completion(const nsACString& completeHash,
10941:                                           const nsACString& tableName,
12346:                                           PRUint32 chunkId,
12346:                                           PRBool verified)
10941: {
14354:   LOG(("nsUrlClassifierLookupCallback::Completion [%p, %s, %d, %d]",
14354:        this, PromiseFlatCString(tableName).get(), chunkId, verified));
10941:   nsUrlClassifierCompleteHash hash;
10941:   hash.Assign(completeHash);
10941: 
10941:   for (PRUint32 i = 0; i < mResults->Length(); i++) {
10941:     nsUrlClassifierLookupResult& result = mResults->ElementAt(i);
10941: 
14354:     // First, see if this result can be used to update an entry.
14354:     if (verified &&
14354:         !result.mEntry.mHaveComplete &&
10941:         hash.StartsWith(result.mEntry.mPartialHash) &&
10941:         result.mTableName == tableName &&
10941:         result.mEntry.mChunkId == chunkId) {
10941:       // We have a completion for this entry.  Fill it in...
10941:       result.mEntry.SetHash(hash);
10941: 
10988:       if (!mCacheResults) {
10988:         mCacheResults = new nsTArray<nsUrlClassifierLookupResult>();
10988:         if (!mCacheResults)
10988:           return NS_ERROR_OUT_OF_MEMORY;
10988:       }
10988: 
10988:       mCacheResults->AppendElement(result);
10941:     }
14354: 
14354:     // Now, see if it verifies a lookup
14354:     if (result.mLookupFragment == hash) {
14354:       result.mConfirmed = PR_TRUE;
14354: 
14354:       if (result.mTableName != tableName ||
14354:           result.mEntry.mChunkId != chunkId) {
12580:         // The hash we got for this completion matches the hash we
12580:         // looked up, but doesn't match the table/chunk id.  This could
12580:         // happen in rare cases where a given URL was moved between
12580:         // lists or added/removed/re-added to the list in the time since
12580:         // we've updated.
12580:         //
12580:         // Update the lookup result, but don't update the entry or try
14354:         // cache the results of this completion, as it might confuse
12580:         // things.
12580:         result.mTableName = tableName;
12580:         NS_WARNING("Accepting a gethash with an invalid table name or chunk id");
10941:       }
12346:     }
14354:   }
10941: 
10941:   return NS_OK;
10941: }
10941: 
10941: nsresult
10941: nsUrlClassifierLookupCallback::HandleResults()
10941: {
10941:   if (!mResults) {
10941:     // No results, this URI is clean.
10941:     return mCallback->HandleEvent(NS_LITERAL_CSTRING(""));
10941:   }
10941: 
10941:   // Build a stringified list of result tables.
10941:   mResults->Sort();
10941:   PRUint32 lastTableId = 0;
10941:   nsCAutoString tables;
10941:   for (PRUint32 i = 0; i < mResults->Length(); i++) {
10941:     nsUrlClassifierLookupResult& result = mResults->ElementAt(i);
10941:     // Leave out results that weren't confirmed, as their existence on
12334:     // the list can't be verified.  Also leave out randomly-generated
12334:     // noise.
12334:     if (!result.mConfirmed || result.mNoise)
10941:       continue;
10941: 
10941:     if (tables.Length() > 0) {
10941:       if (lastTableId == result.mEntry.mTableId)
10941:         continue;
10941:       tables.Append(",");
10941:     }
10941: 
10941:     tables.Append(result.mTableName);
10941:     lastTableId = result.mEntry.mTableId;
10941:   }
10941: 
10941:   return mCallback->HandleEvent(tables);
10941: }
10941: 
10941: 
10941: // -------------------------------------------------------------------------
 5528: // Helper class for nsIURIClassifier implementation, translates table names
 5528: // to nsIURIClassifier enums.
 5528: 
 5528: class nsUrlClassifierClassifyCallback : public nsIUrlClassifierCallback
 5528: {
 5528: public:
 5528:   NS_DECL_ISUPPORTS
 5528:   NS_DECL_NSIURLCLASSIFIERCALLBACK
 5528: 
 8643:   nsUrlClassifierClassifyCallback(nsIURIClassifierCallback *c,
 8643:                                   PRBool checkMalware,
 8643:                                   PRBool checkPhishing)
 5528:     : mCallback(c)
 8643:     , mCheckMalware(checkMalware)
 8643:     , mCheckPhishing(checkPhishing)
 5528:     {}
 5528: 
 5528: private:
 5528:   nsCOMPtr<nsIURIClassifierCallback> mCallback;
 8643:   PRPackedBool mCheckMalware;
 8643:   PRPackedBool mCheckPhishing;
 5528: };
 5528: 
 5528: NS_IMPL_THREADSAFE_ISUPPORTS1(nsUrlClassifierClassifyCallback,
 5530:                               nsIUrlClassifierCallback)
 5528: 
 5528: NS_IMETHODIMP
 5528: nsUrlClassifierClassifyCallback::HandleEvent(const nsACString& tables)
 5528: {
 5528:   // XXX: we should probably have the wardens tell the service which table
 5528:   // names match with which classification.  For now the table names give
 5528:   // enough information.
 5528:   nsresult response = NS_OK;
 5528: 
 5528:   nsACString::const_iterator begin, end;
 5528: 
 5528:   tables.BeginReading(begin);
 5528:   tables.EndReading(end);
 8643:   if (mCheckMalware &&
 8643:       FindInReadable(NS_LITERAL_CSTRING("-malware-"), begin, end)) {
 5528:     response = NS_ERROR_MALWARE_URI;
 7236:   } else {
 7236:     // Reset begin before checking phishing table
 7236:     tables.BeginReading(begin);
 7236: 
 8643:     if (mCheckPhishing &&
 8643:         FindInReadable(NS_LITERAL_CSTRING("-phish-"), begin, end)) {
 7236:       response = NS_ERROR_PHISHING_URI;
 7236:     }
 5528:   }
 5528: 
 5528:   mCallback->OnClassifyComplete(response);
 5528: 
 5528:   return NS_OK;
 5528: }
 5528: 
 5528: 
 5528: // -------------------------------------------------------------------------
    1: // Proxy class implementation
    1: 
 5528: NS_IMPL_THREADSAFE_ISUPPORTS3(nsUrlClassifierDBService,
    1:                               nsIUrlClassifierDBService,
 5528:                               nsIURIClassifier,
    1:                               nsIObserver)
    1: 
    1: /* static */ nsUrlClassifierDBService*
 9868: nsUrlClassifierDBService::GetInstance(nsresult *result)
    1: {
 9868:   *result = NS_OK;
    1:   if (!sUrlClassifierDBService) {
    1:     sUrlClassifierDBService = new nsUrlClassifierDBService();
 9868:     if (!sUrlClassifierDBService) {
 9868:       *result = NS_ERROR_OUT_OF_MEMORY;
    1:       return nsnull;
 9868:     }
    1: 
    1:     NS_ADDREF(sUrlClassifierDBService);   // addref the global
    1: 
 9868:     *result = sUrlClassifierDBService->Init();
 9868:     if (NS_FAILED(*result)) {
    1:       NS_RELEASE(sUrlClassifierDBService);
    1:       return nsnull;
    1:     }
    1:   } else {
    1:     // Already exists, just add a ref
    1:     NS_ADDREF(sUrlClassifierDBService);   // addref the return result
    1:   }
    1:   return sUrlClassifierDBService;
    1: }
    1: 
    1: 
    1: nsUrlClassifierDBService::nsUrlClassifierDBService()
 5528:  : mCheckMalware(CHECK_MALWARE_DEFAULT)
 8643:  , mCheckPhishing(CHECK_PHISHING_DEFAULT)
10582:  , mInUpdate(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsUrlClassifierDBService::~nsUrlClassifierDBService()
    1: {
    1:   sUrlClassifierDBService = nsnull;
    1: }
    1: 
    1: nsresult
    1: nsUrlClassifierDBService::Init()
    1: {
    1: #if defined(PR_LOGGING)
    1:   if (!gUrlClassifierDbServiceLog)
    1:     gUrlClassifierDbServiceLog = PR_NewLogModule("UrlClassifierDbService");
    1: #endif
    1: 
    1:   // Force the storage service to be created on the main thread.
    1:   nsresult rv;
    1:   nsCOMPtr<mozIStorageService> storageService =
    1:     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4432:   // Force PSM to be loaded on the main thread.
 4432:   nsCOMPtr<nsICryptoHash> hash =
 4432:     do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
 4432:   NS_ENSURE_SUCCESS(rv, rv);
 4432: 
 5528:   // Should we check document loads for malware URIs?
 5528:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
 5528: 
12334:   PRInt32 gethashNoise = 0;
 5528:   if (prefs) {
 5528:     PRBool tmpbool;
 5528:     rv = prefs->GetBoolPref(CHECK_MALWARE_PREF, &tmpbool);
 5528:     mCheckMalware = NS_SUCCEEDED(rv) ? tmpbool : CHECK_MALWARE_DEFAULT;
 5528: 
 5528:     prefs->AddObserver(CHECK_MALWARE_PREF, this, PR_FALSE);
 8643: 
 8643:     rv = prefs->GetBoolPref(CHECK_PHISHING_PREF, &tmpbool);
 8643:     mCheckPhishing = NS_SUCCEEDED(rv) ? tmpbool : CHECK_PHISHING_DEFAULT;
 8643: 
 8643:     prefs->AddObserver(CHECK_PHISHING_PREF, this, PR_FALSE);
12334: 
12334:     if (NS_FAILED(prefs->GetIntPref(GETHASH_NOISE_PREF, &gethashNoise))) {
12334:       gethashNoise = GETHASH_NOISE_DEFAULT;
12334:     }
14354: 
14354:     nsXPIDLCString tmpstr;
14354:     if (NS_SUCCEEDED(prefs->GetCharPref(GETHASH_TABLES_PREF, getter_Copies(tmpstr)))) {
14354:       SplitTables(tmpstr, mGethashWhitelist);
14354:     }
14354: 
14354:     prefs->AddObserver(GETHASH_TABLES_PREF, this, PR_FALSE);
14354: 
14354:     PRInt32 tmpint;
14354:     rv = prefs->GetIntPref(CONFIRM_AGE_PREF, &tmpint);
14354:     PR_AtomicSet(&gFreshnessGuarantee, NS_SUCCEEDED(rv) ? tmpint : CONFIRM_AGE_DEFAULT_SEC);
14354: 
14354:     prefs->AddObserver(CONFIRM_AGE_PREF, this, PR_FALSE);
14354: 
14883:     rv = prefs->GetIntPref(UPDATE_CACHE_SIZE_PREF, &tmpint);
14883:     PR_AtomicSet(&gUpdateCacheSize, NS_SUCCEEDED(rv) ? tmpint : UPDATE_CACHE_SIZE_DEFAULT);
15023: 
15023:     rv = prefs->GetIntPref(UPDATE_WORKING_TIME, &tmpint);
15023:     PR_AtomicSet(&gWorkingTimeThreshold,
15023:                  NS_SUCCEEDED(rv) ? tmpint : UPDATE_WORKING_TIME_DEFAULT);
15023: 
15023:     rv = prefs->GetIntPref(UPDATE_DELAY_TIME, &tmpint);
15023:     PR_AtomicSet(&gDelayTime,
15023:                  NS_SUCCEEDED(rv) ? tmpint : UPDATE_DELAY_TIME_DEFAULT);
 5528:   }
 5528: 
    1:   // Start the background thread.
    1:   rv = NS_NewThread(&gDbBackgroundThread);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   mWorker = new nsUrlClassifierDBServiceWorker();
    1:   if (!mWorker)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
12334:   rv = mWorker->Init(gethashNoise);
 4024:   if (NS_FAILED(rv)) {
 4024:     mWorker = nsnull;
 4024:     return rv;
 4024:   }
 4024: 
10213:   // Proxy for calling the worker on the background thread
10213:   rv = NS_GetProxyForObject(gDbBackgroundThread,
10213:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
10213:                             mWorker,
10213:                             NS_PROXY_ASYNC,
10213:                             getter_AddRefs(mWorkerProxy));
10213:   NS_ENSURE_SUCCESS(rv, rv);
10213: 
10941:   mCompleters.Init();
10941: 
    1:   // Add an observer for shutdown
    1:   nsCOMPtr<nsIObserverService> observerService =
41540:       mozilla::services::GetObserverService();
    1:   if (!observerService)
    1:     return NS_ERROR_FAILURE;
    1: 
 3338:   observerService->AddObserver(this, "profile-before-change", PR_FALSE);
 3338:   observerService->AddObserver(this, "xpcom-shutdown-threads", PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 5528: NS_IMETHODIMP
 5528: nsUrlClassifierDBService::Classify(nsIURI *uri,
 5528:                                    nsIURIClassifierCallback* c,
 5528:                                    PRBool* result)
 5528: {
 5528:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
 5528: 
 8643:   if (!(mCheckMalware || mCheckPhishing)) {
 5528:     *result = PR_FALSE;
 5528:     return NS_OK;
 5528:   }
 5528: 
 5528:   nsRefPtr<nsUrlClassifierClassifyCallback> callback =
 8643:     new nsUrlClassifierClassifyCallback(c, mCheckMalware, mCheckPhishing);
 5528:   if (!callback) return NS_ERROR_OUT_OF_MEMORY;
 5528: 
20648:   nsresult rv = LookupURI(uri, callback, PR_FALSE, result);
 8378:   if (rv == NS_ERROR_MALFORMED_URI) {
20648:     *result = PR_FALSE;
19928:     // The URI had no hostname, don't try to classify it.
 8378:     return NS_OK;
 8378:   }
12006:   NS_ENSURE_SUCCESS(rv, rv);
 8378: 
 8378:   return NS_OK;
 5528: }
 5528: 
 5528: NS_IMETHODIMP
 4024: nsUrlClassifierDBService::Lookup(const nsACString& spec,
10941:                                  nsIUrlClassifierCallback* c)
 4024: {
 4024:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
 4024: 
 4024:   nsCOMPtr<nsIURI> uri;
 4024: 
 4024:   nsresult rv = NS_NewURI(getter_AddRefs(uri), spec);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   uri = NS_GetInnermostURI(uri);
 4024:   if (!uri) {
 4024:     return NS_ERROR_FAILURE;
 4024:   }
 4024: 
20648:   PRBool didLookup;
20648:   return LookupURI(uri, c, PR_TRUE, &didLookup);
 5528: }
 5528: 
 5528: nsresult
 5528: nsUrlClassifierDBService::LookupURI(nsIURI* uri,
20648:                                     nsIUrlClassifierCallback* c,
20648:                                     PRBool forceLookup,
20648:                                     PRBool *didLookup)
 5528: {
 5528:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
 5528: 
 4024:   nsCAutoString key;
 4024:   // Canonicalize the url
 4024:   nsCOMPtr<nsIUrlClassifierUtils> utilsService =
 4024:     do_GetService(NS_URLCLASSIFIERUTILS_CONTRACTID);
 5528:   nsresult rv = utilsService->GetKeyForURI(uri, key);
12006:   if (NS_FAILED(rv))
12006:     return rv;
 4024: 
20648:   if (forceLookup) {
20648:     *didLookup = PR_TRUE;
20648:   } else {
20648:     // Check if the URI is on a clean host.  If so, we don't need to
20648:     // bother queueing up a lookup, we can just return.
20648:     PRBool clean;
20648:     rv = mWorker->CheckCleanHost(key, &clean);
20648:     NS_ENSURE_SUCCESS(rv, rv);
20648: 
20648:     *didLookup = !clean;
20648:     if (clean) {
20648:       return NS_OK;
20648:     }
20648:   }
20648: 
10941:   // Create an nsUrlClassifierLookupCallback object.  This object will
10941:   // take care of confirming partial hash matches if necessary before
10941:   // calling the client's callback.
10941:   nsCOMPtr<nsIUrlClassifierLookupCallback> callback =
10941:     new nsUrlClassifierLookupCallback(this, c);
10941:   if (!callback)
10941:     return NS_ERROR_OUT_OF_MEMORY;
10941: 
10941:   nsCOMPtr<nsIUrlClassifierLookupCallback> proxyCallback;
 4024:   // The proxy callback uses the current thread.
 4024:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
10941:                             NS_GET_IID(nsIUrlClassifierLookupCallback),
10941:                             callback,
 4024:                             NS_PROXY_ASYNC,
 4024:                             getter_AddRefs(proxyCallback));
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
 4024:   // Queue this lookup and call the lookup function to flush the queue if
 4024:   // necessary.
 4024:   rv = mWorker->QueueLookup(key, proxyCallback);
 4024:   NS_ENSURE_SUCCESS(rv, rv);
 4024: 
10941:   return mWorkerProxy->Lookup(EmptyCString(), nsnull);
 4024: }
 4024: 
    1: NS_IMETHODIMP
 4024: nsUrlClassifierDBService::GetTables(nsIUrlClassifierCallback* c)
    1: {
    1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv;
    1:   // The proxy callback uses the current thread.
    1:   nsCOMPtr<nsIUrlClassifierCallback> proxyCallback;
    1:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
    1:                             NS_GET_IID(nsIUrlClassifierCallback),
    1:                             c,
    1:                             NS_PROXY_ASYNC,
    1:                             getter_AddRefs(proxyCallback));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10213:   return mWorkerProxy->GetTables(proxyCallback);
 4001: }
 4001: 
 4001: NS_IMETHODIMP
10941: nsUrlClassifierDBService::SetHashCompleter(const nsACString &tableName,
10941:                                            nsIUrlClassifierHashCompleter *completer)
10941: {
10941:   if (completer) {
10941:     if (!mCompleters.Put(tableName, completer)) {
10941:       return NS_ERROR_OUT_OF_MEMORY;
10941:     }
10941:   } else {
10941:     mCompleters.Remove(tableName);
10941:   }
10941: 
10941:   return NS_OK;
10941: }
10941: 
10941: NS_IMETHODIMP
12346: nsUrlClassifierDBService::BeginUpdate(nsIUrlClassifierUpdateObserver *observer,
14354:                                       const nsACString &updateTables,
12346:                                       const nsACString &clientKey)
 4001: {
 4001:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
 4001: 
10582:   if (mInUpdate)
10582:     return NS_ERROR_NOT_AVAILABLE;
10582: 
10582:   mInUpdate = PR_TRUE;
10582: 
 4001:   nsresult rv;
 4001: 
10213:   // The proxy observer uses the current thread
10213:   nsCOMPtr<nsIUrlClassifierUpdateObserver> proxyObserver;
10213:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
10213:                             NS_GET_IID(nsIUrlClassifierUpdateObserver),
10213:                             observer,
 4001:                             NS_PROXY_ASYNC,
10213:                             getter_AddRefs(proxyObserver));
 4001:   NS_ENSURE_SUCCESS(rv, rv);
 4001: 
14354:   return mWorkerProxy->BeginUpdate(proxyObserver, updateTables, clientKey);
 4001: }
 4001: 
 4001: NS_IMETHODIMP
12346: nsUrlClassifierDBService::BeginStream(const nsACString &table,
12346:                                       const nsACString &serverMAC)
 4001: {
 4001:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
 4001: 
12346:   return mWorkerProxy->BeginStream(table, serverMAC);
 4024: }
 4024: 
10213: NS_IMETHODIMP
10213: nsUrlClassifierDBService::UpdateStream(const nsACString& aUpdateChunk)
10213: {
10213:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
10213: 
10213:   return mWorkerProxy->UpdateStream(aUpdateChunk);
 4024: }
 4001: 
10213: NS_IMETHODIMP
10213: nsUrlClassifierDBService::FinishStream()
10213: {
10213:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
10213: 
10213:   return mWorkerProxy->FinishStream();
10213: }
10213: 
10213: NS_IMETHODIMP
10213: nsUrlClassifierDBService::FinishUpdate()
10213: {
10213:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
10213: 
10582:   mInUpdate = PR_FALSE;
10582: 
10213:   return mWorkerProxy->FinishUpdate();
10213: }
10213: 
10213: 
10213: NS_IMETHODIMP
10213: nsUrlClassifierDBService::CancelUpdate()
10213: {
10213:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
10213: 
10582:   mInUpdate = PR_FALSE;
10582: 
10213:   return mWorkerProxy->CancelUpdate();
    1: }
    1: 
    1: NS_IMETHODIMP
10212: nsUrlClassifierDBService::ResetDatabase()
10212: {
    1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
    1: 
10213:   return mWorkerProxy->ResetDatabase();
    1: }
    1: 
10995: nsresult
10988: nsUrlClassifierDBService::CacheCompletions(nsTArray<nsUrlClassifierLookupResult> *results)
10988: {
10988:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
10988: 
10988:   return mWorkerProxy->CacheCompletions(results);
10988: }
10988: 
12571: PRBool
12571: nsUrlClassifierDBService::GetCompleter(const nsACString &tableName,
12571:                                        nsIUrlClassifierHashCompleter **completer)
12571: {
12571:   if (mCompleters.Get(tableName, completer)) {
12571:     return PR_TRUE;
12571:   }
12571: 
14354:   if (!mGethashWhitelist.Contains(tableName)) {
14354:     return PR_FALSE;
14354:   }
14354: 
12571:   return NS_SUCCEEDED(CallGetService(NS_URLCLASSIFIERHASHCOMPLETER_CONTRACTID,
12571:                                      completer));
12571: }
12571: 
10988: NS_IMETHODIMP
    1: nsUrlClassifierDBService::Observe(nsISupports *aSubject, const char *aTopic,
    1:                                   const PRUnichar *aData)
    1: {
 5528:   if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
 5528:     nsresult rv;
 5528:     nsCOMPtr<nsIPrefBranch> prefs(do_QueryInterface(aSubject, &rv));
 5528:     NS_ENSURE_SUCCESS(rv, rv);
 5528:     if (NS_LITERAL_STRING(CHECK_MALWARE_PREF).Equals(aData)) {
 5528:       PRBool tmpbool;
 5528:       rv = prefs->GetBoolPref(CHECK_MALWARE_PREF, &tmpbool);
 5528:       mCheckMalware = NS_SUCCEEDED(rv) ? tmpbool : CHECK_MALWARE_DEFAULT;
 8643:     } else if (NS_LITERAL_STRING(CHECK_PHISHING_PREF).Equals(aData)) {
 8643:       PRBool tmpbool;
 8643:       rv = prefs->GetBoolPref(CHECK_PHISHING_PREF, &tmpbool);
 8643:       mCheckPhishing = NS_SUCCEEDED(rv) ? tmpbool : CHECK_PHISHING_DEFAULT;
14354:     } else if (NS_LITERAL_STRING(GETHASH_TABLES_PREF).Equals(aData)) {
14354:       mGethashWhitelist.Clear();
14354:       nsXPIDLCString val;
14354:       if (NS_SUCCEEDED(prefs->GetCharPref(GETHASH_TABLES_PREF, getter_Copies(val)))) {
14354:         SplitTables(val, mGethashWhitelist);
14354:       }
14354:     } else if (NS_LITERAL_STRING(CONFIRM_AGE_PREF).Equals(aData)) {
14354:       PRInt32 tmpint;
14354:       rv = prefs->GetIntPref(CONFIRM_AGE_PREF, &tmpint);
14354:       PR_AtomicSet(&gFreshnessGuarantee, NS_SUCCEEDED(rv) ? tmpint : CONFIRM_AGE_DEFAULT_SEC);
14883:     } else if (NS_LITERAL_STRING(UPDATE_CACHE_SIZE_PREF).Equals(aData)) {
14883:       PRInt32 tmpint;
14883:       rv = prefs->GetIntPref(UPDATE_CACHE_SIZE_PREF, &tmpint);
14883:       PR_AtomicSet(&gUpdateCacheSize, NS_SUCCEEDED(rv) ? tmpint : UPDATE_CACHE_SIZE_DEFAULT);
15023:     } else if (NS_LITERAL_STRING(UPDATE_WORKING_TIME).Equals(aData)) {
15023:       PRInt32 tmpint;
15023:       rv = prefs->GetIntPref(UPDATE_WORKING_TIME, &tmpint);
15023:       PR_AtomicSet(&gWorkingTimeThreshold,
15023:                    NS_SUCCEEDED(rv) ? tmpint : UPDATE_WORKING_TIME_DEFAULT);
15023:     } else if (NS_LITERAL_STRING(UPDATE_DELAY_TIME).Equals(aData)) {
15023:       PRInt32 tmpint;
15023:       rv = prefs->GetIntPref(UPDATE_DELAY_TIME, &tmpint);
15023:       PR_AtomicSet(&gDelayTime,
15023:                  NS_SUCCEEDED(rv) ? tmpint : UPDATE_DELAY_TIME_DEFAULT);
 5528:     }
 5528:   } else if (!strcmp(aTopic, "profile-before-change") ||
 5528:              !strcmp(aTopic, "xpcom-shutdown-threads")) {
    1:     Shutdown();
 5528:   } else {
 5528:     return NS_ERROR_UNEXPECTED;
 5528:   }
 3338: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Join the background thread if it exists.
    1: nsresult
    1: nsUrlClassifierDBService::Shutdown()
    1: {
 3338:   LOG(("shutting down db service\n"));
 3338: 
    1:   if (!gDbBackgroundThread)
    1:     return NS_OK;
    1: 
10941:   mCompleters.Clear();
10941: 
 5528:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
 5528:   if (prefs) {
 5528:     prefs->RemoveObserver(CHECK_MALWARE_PREF, this);
 8643:     prefs->RemoveObserver(CHECK_PHISHING_PREF, this);
14354:     prefs->RemoveObserver(GETHASH_TABLES_PREF, this);
14354:     prefs->RemoveObserver(CONFIRM_AGE_PREF, this);
 5528:   }
 5528: 
    1:   nsresult rv;
    1:   // First close the db connection.
    1:   if (mWorker) {
15023:     rv = mWorkerProxy->CancelUpdate();
29285:     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to post cancel update event");
10213:     rv = mWorkerProxy->CloseDb();
  762:     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to post close db event");
  762:   }
10213: 
10213:   mWorkerProxy = nsnull;
10213: 
    1:   LOG(("joining background thread"));
    1: 
  762:   gShuttingDownThread = PR_TRUE;
10337: 
10337:   nsIThread *backgroundThread = gDbBackgroundThread;
10337:   gDbBackgroundThread = nsnull;
10337:   backgroundThread->Shutdown();
10337:   NS_RELEASE(backgroundThread);
    1: 
    1:   return NS_OK;
    1: }
