115294: /* This Source Code Form is subject to the terms of the Mozilla Public
115294:  * License, v. 2.0. If a copy of the MPL was not distributed with this
115294:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
115294: 
115294: #include "mozilla/dom/TextEncoder.h"
115294: #include "mozilla/dom/EncodingUtils.h"
115294: #include "nsContentUtils.h"
115294: #include "nsICharsetConverterManager.h"
115294: #include "nsServiceManagerUtils.h"
115294: 
115294: namespace mozilla {
115294: namespace dom {
115294: 
115294: void
115294: TextEncoder::Init(const Optional<nsAString>& aEncoding,
115294:                   ErrorResult& aRv)
115294: {
115294:   // If the constructor is called with no arguments, let label be the "utf-8".
115294:   // Otherwise, let label be the value of the encoding argument.
115294:   nsAutoString label;
115294:   if (!aEncoding.WasPassed()) {
115294:     label.AssignLiteral("utf-8");
115294:   } else {
115294:     label.Assign(aEncoding.Value());
115294:     EncodingUtils::TrimSpaceCharacters(label);
115294:   }
115294: 
115294:   // Run the steps to get an encoding from Encoding.
115294:   if (!EncodingUtils::FindEncodingForLabel(label, mEncoding)) {
115294:     // If the steps result in failure,
115294:     // throw an "EncodingError" exception and terminate these steps.
115294:     aRv.Throw(NS_ERROR_DOM_ENCODING_NOT_SUPPORTED_ERR);
115294:     return;
115294:   }
115294: 
115294:   // Otherwise, if the Name of the returned encoding is not one of
115294:   // "utf-8", "utf-16", or "utf-16be" throw an "EncodingError" exception
115294:   // and terminate these steps.
115294:   if (PL_strcasecmp(mEncoding, "utf-8") &&
115294:       PL_strcasecmp(mEncoding, "utf-16le") &&
115294:       PL_strcasecmp(mEncoding, "utf-16be")) {
115294:     aRv.Throw(NS_ERROR_DOM_ENCODING_NOT_UTF_ERR);
115294:     return;
115294:   }
115294: 
115294:   // Create an encoder object for mEncoding.
115294:   nsCOMPtr<nsICharsetConverterManager> ccm =
115294:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID);
115294:   if (!ccm) {
115294:     aRv.Throw(NS_ERROR_UNEXPECTED);
115294:     return;
115294:   }
115294: 
115294:   ccm->GetUnicodeEncoder(mEncoding, getter_AddRefs(mEncoder));
115294:   if (!mEncoder) {
115294:     aRv.Throw(NS_ERROR_UNEXPECTED);
115294:     return;
115294:   }
115294: }
115294: 
115294: JSObject*
115294: TextEncoder::Encode(JSContext* aCx,
115294:                     const nsAString& aString,
115294:                     const TextEncodeOptions& aOptions,
115294:                     ErrorResult& aRv)
115294: {
115294:   // Run the steps of the encoding algorithm.
115294:   int32_t srcLen = aString.Length();
115294:   int32_t maxLen;
115294:   const PRUnichar* data = PromiseFlatString(aString).get();
115294:   nsresult rv = mEncoder->GetMaxLength(data, srcLen, &maxLen);
115294:   if (NS_FAILED(rv)) {
115294:     aRv.Throw(rv);
115294:     return nullptr;
115294:   }
115294:   // Need a fallible allocator because the caller may be a content
115294:   // and the content can specify the length of the string.
115294:   static const fallible_t fallible = fallible_t();
115294:   nsAutoArrayPtr<char> buf(new (fallible) char[maxLen + 1]);
115294:   if (!buf) {
115294:     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
115294:     return nullptr;
115294:   }
115294: 
115294:   int32_t dstLen = maxLen;
115294:   rv = mEncoder->Convert(data, &srcLen, buf, &dstLen);
115294: 
115294:   // If the internal streaming flag is not set, then reset
115294:   // the encoding algorithm state to the default values for encoding.
115294:   if (!aOptions.stream) {
115294:     int32_t finishLen = maxLen - dstLen;
115294:     rv = mEncoder->Finish(buf + dstLen, &finishLen);
115294:     if (NS_SUCCEEDED(rv)) {
115294:       dstLen += finishLen;
115294:     }
115294:   }
115294: 
115294:   JSObject* outView = nullptr;
115294:   if (NS_SUCCEEDED(rv)) {
115294:     buf[dstLen] = '\0';
115294:     outView = Uint8Array::Create(aCx, this, dstLen,
115294:                                  reinterpret_cast<uint8_t*>(buf.get()));
118166:     if (!outView) {
118166:       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
118166:       return nullptr;
118166:     }
115294:   }
115294: 
115294:   if (NS_FAILED(rv)) {
115294:     aRv.Throw(rv);
115294:   }
115294:   return outView;
115294: }
115294: 
115294: void
115294: TextEncoder::GetEncoding(nsAString& aEncoding)
115294: {
115294:   // Our utf-16 converter does not comply with the Encoding Standard.
115294:   // As a result the utf-16le converter is used for the encoding label
115294:   // "utf-16".
115294:   // This workaround should not be exposed to the public API and so "utf-16"
115294:   // is returned by GetEncoding() if the internal encoding name is "utf-16le".
115294:   if (!strcmp(mEncoding, "utf-16le")) {
115294:     aEncoding.AssignLiteral("utf-16");
115294:     return;
115294:   }
115294:   aEncoding.AssignASCII(mEncoding);
115294: }
115294: 
115294: NS_IMPL_CYCLE_COLLECTING_ADDREF(TextEncoder)
115294: NS_IMPL_CYCLE_COLLECTING_RELEASE(TextEncoder)
115294: 
115294: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TextEncoder)
115294:   NS_INTERFACE_MAP_ENTRY(nsISupports)
115294: NS_INTERFACE_MAP_END
115294: 
115294: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_1(TextEncoder, mGlobal)
115294: 
115294: } // dom
115294: } // mozilla
