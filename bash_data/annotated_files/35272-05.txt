    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Boris Zbarsky <bzbarsky@mit.edu>
    1:  *   Christopher A. Aillon <christopher@aillon.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *   Christian Biesinger <cbiesinger@web.de>
15268:  *   Michael Ventnor <m.ventnor@gmail.com>
31702:  *   Jonathon Jongsma <jonathon.jongsma@collabora.co.uk>, Collabora Ltd.
31702:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* DOM object returned from element.getComputedStyle() */
    1: 
    1: #include "nsComputedDOMStyle.h"
    1: 
    1: #include "nsDOMError.h"
    1: #include "nsDOMString.h"
31702: #include "nsPrintfCString.h"
23828: #include "nsIDOMNSCSS2Properties.h"
    1: #include "nsIDOMElement.h"
19214: #include "nsIDOMCSSPrimitiveValue.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsContentUtils.h"
    1: #include "prprf.h"
    1: 
    1: #include "nsCSSProps.h"
    1: #include "nsCSSKeywords.h"
    1: #include "nsDOMCSSRect.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsHTMLReflowState.h"
    1: #include "nsThemeConstants.h"
    1: #include "nsStyleUtil.h"
15992: #include "nsStyleStructInlines.h"
    1: 
    1: #include "nsPresContext.h"
    1: #include "nsIDocument.h"
    1: 
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsStyleSet.h"
    1: #include "imgIRequest.h"
 1105: #include "nsLayoutUtils.h"
 1105: #include "nsFrameManager.h"
24408: #include "prlog.h"
19214: #include "nsCSSKeywords.h"
19214: #include "nsStyleCoord.h"
19214: #include "nsDisplayList.h"
30385: #include "nsDOMCSSDeclaration.h"
    1: 
    1: #if defined(DEBUG_bzbarsky) || defined(DEBUG_caillon)
    1: #define DEBUG_ComputedDOMStyle
    1: #endif
    1: 
    1: /*
    1:  * This is the implementation of the readonly CSSStyleDeclaration that is
    1:  * returned by the getComputedStyle() function.
    1:  */
    1: 
    1: static nsComputedDOMStyle *sCachedComputedDOMStyle;
    1: 
    1: nsresult
30385: NS_NewComputedDOMStyle(nsIDOMElement *aElement, const nsAString &aPseudoElt,
30385:                        nsIPresShell *aPresShell,
30385:                        nsComputedDOMStyle **aComputedStyle)
    1: {
30385:   nsRefPtr<nsComputedDOMStyle> computedStyle;
    1:   if (sCachedComputedDOMStyle) {
    1:     // There's an unused nsComputedDOMStyle cached, use it.
    1:     // But before we use it, re-initialize the object.
    1: 
    1:     // Oh yeah baby, placement new!
30385:     computedStyle = new (sCachedComputedDOMStyle) nsComputedDOMStyle();
    1: 
    1:     sCachedComputedDOMStyle = nsnull;
    1:   } else {
    1:     // No nsComputedDOMStyle cached, create a new one.
    1: 
30385:     computedStyle = new nsComputedDOMStyle();
30385:     NS_ENSURE_TRUE(computedStyle, NS_ERROR_OUT_OF_MEMORY);
30385:   }
30385: 
30385:   nsresult rv = computedStyle->Init(aElement, aPseudoElt, aPresShell);
30385:   NS_ENSURE_SUCCESS(rv, rv);
30385: 
30385:   *aComputedStyle = nsnull;
30385:   computedStyle.swap(*aComputedStyle);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: static nsIFrame*
    1: GetContainingBlockFor(nsIFrame* aFrame) {
    1:   if (!aFrame) {
    1:     return nsnull;
    1:   }
    1:   return nsHTMLReflowState::GetContainingBlockFor(aFrame);
    1: }
    1: 
    1: nsComputedDOMStyle::nsComputedDOMStyle()
32849:   : mDocumentWeak(nsnull), mOuterFrame(nsnull),
10950:     mInnerFrame(nsnull), mPresShell(nsnull), mAppUnitsPerInch(0)
    1: {
    1: }
    1: 
    1: 
    1: nsComputedDOMStyle::~nsComputedDOMStyle()
    1: {
    1: }
    1: 
    1: void
    1: nsComputedDOMStyle::Shutdown()
    1: {
    1:   // We want to de-allocate without calling the dtor since we
    1:   // already did that manually in doDestroyComputedDOMStyle(),
    1:   // so cast our cached object to something that doesn't know
    1:   // about our dtor.
 3233:   delete reinterpret_cast<char*>(sCachedComputedDOMStyle);
    1:   sCachedComputedDOMStyle = nsnull;
    1: }
    1: 
    1: 
35272: NS_IMPL_CYCLE_COLLECTION_1(nsComputedDOMStyle, mContent)
22063: 
    1: // QueryInterface implementation for nsComputedDOMStyle
30385: NS_INTERFACE_TABLE_HEAD(nsComputedDOMStyle)
30385:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
30385:   NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsComputedDOMStyle)
30385:     NS_INTERFACE_TABLE_ENTRY(nsComputedDOMStyle, nsICSSDeclaration)
30385:     NS_INTERFACE_TABLE_ENTRY(nsComputedDOMStyle,
30385:                              nsIDOMCSSStyleDeclaration)
30385:     NS_INTERFACE_TABLE_ENTRY(nsComputedDOMStyle, nsISupports)
30385:   NS_OFFSET_AND_INTERFACE_TABLE_END
30385:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
30385:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsComputedDOMStyle)
32849:   NS_INTERFACE_MAP_ENTRY_AGGREGATED(nsIDOMCSS2Properties,
32849:                                     new CSS2PropertiesTearoff(this))
32849:   NS_INTERFACE_MAP_ENTRY_AGGREGATED(nsIDOMNSCSS2Properties,
32849:                                     new CSS2PropertiesTearoff(this))
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(ComputedCSSStyleDeclaration)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: static void doDestroyComputedDOMStyle(nsComputedDOMStyle *aComputedStyle)
    1: {
    1:   if (!sCachedComputedDOMStyle) {
    1:     // The cache is empty, store aComputedStyle in the cache.
    1: 
    1:     sCachedComputedDOMStyle = aComputedStyle;
    1:     sCachedComputedDOMStyle->~nsComputedDOMStyle();
    1:   } else {
    1:     // The cache is full, delete aComputedStyle
    1: 
    1:     delete aComputedStyle;
    1:   }
    1: }
    1: 
22063: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsComputedDOMStyle)
22063: NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_DESTROY(nsComputedDOMStyle,
    1:                                               doDestroyComputedDOMStyle(this))
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::Init(nsIDOMElement *aElement,
    1:                          const nsAString& aPseudoElt,
    1:                          nsIPresShell *aPresShell)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aElement);
    1:   NS_ENSURE_ARG_POINTER(aPresShell);
    1: 
    1:   mDocumentWeak = do_GetWeakReference(aPresShell->GetDocument());
    1: 
    1:   mContent = do_QueryInterface(aElement);
    1:   if (!mContent) {
    1:     // This should not happen, all our elements support nsIContent!
    1: 
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (!DOMStringIsNull(aPseudoElt) && !aPseudoElt.IsEmpty() &&
    1:       aPseudoElt.First() == PRUnichar(':')) {
    1:     // deal with two-colon forms of aPseudoElt
    1:     nsAString::const_iterator start, end;
    1:     aPseudoElt.BeginReading(start);
    1:     aPseudoElt.EndReading(end);
    1:     NS_ASSERTION(start != end, "aPseudoElt is not empty!");
    1:     ++start;
    1:     PRBool haveTwoColons = PR_TRUE;
    1:     if (start == end || *start != PRUnichar(':')) {
    1:       --start;
    1:       haveTwoColons = PR_FALSE;
    1:     }
    1:     mPseudo = do_GetAtom(Substring(start, end));
    1:     NS_ENSURE_TRUE(mPseudo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // There aren't any non-CSS2 pseudo-elements with a single ':'
    1:     if (!haveTwoColons &&
    1:         !nsCSSPseudoElements::IsCSS2PseudoElement(mPseudo)) {
    1:       // XXXbz I'd really rather we threw an exception or something, but
    1:       // the DOM spec sucks.
    1:       mPseudo = nsnull;
    1:     }
    1:   }
    1: 
    1:   nsPresContext *presCtx = aPresShell->GetPresContext();
    1:   NS_ENSURE_TRUE(presCtx, NS_ERROR_FAILURE);
    1: 
    1:   mAppUnitsPerInch = presCtx->AppUnitsPerInch();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetPropertyValue(const nsCSSProperty aPropID,
    1:                                      nsAString& aValue)
    1: {
    1:   // This is mostly to avoid code duplication with GetPropertyCSSValue(); if
    1:   // perf ever becomes an issue here (doubtful), we can look into changing
    1:   // this.
    1:   return GetPropertyValue(
    1:     NS_ConvertASCIItoUTF16(nsCSSProps::GetStringValue(aPropID)),
    1:     aValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::SetPropertyValue(const nsCSSProperty aPropID,
    1:                                      const nsAString& aValue)
    1: {
    1:   return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.Truncate();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetLength(PRUint32* aLength)
    1: {
    1:   NS_PRECONDITION(aLength, "Null aLength!  Prepare to die!");
    1: 
    1:   (void)GetQueryablePropertyMap(aLength);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   *aParentRule = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetPropertyValue(const nsAString& aPropertyName,
    1:                                      nsAString& aReturn)
    1: {
    1:   nsCOMPtr<nsIDOMCSSValue> val;
    1: 
    1:   aReturn.Truncate();
    1: 
24627:   nsresult rv = GetPropertyCSSValue(aPropertyName, getter_AddRefs(val));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (val) {
    1:     rv = val->GetCssText(aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
31311: static nsStyleContext*
31311: GetStyleContextForFrame(nsIFrame* aFrame)
31311: {
31311:   nsStyleContext* styleContext = aFrame->GetStyleContext();
31311: 
31311:   /* For tables the primary frame is the "outer frame" but the style
31311:    * rules are applied to the "inner frame".  Luckily, the "outer
31311:    * frame" actually inherits style from the "inner frame" so we can
31311:    * just move one level up in the style context hierarchy....
31311:    */
31311:   if (aFrame->GetType() == nsGkAtoms::tableOuterFrame)
31311:     return styleContext->GetParent();
31311: 
31311:   return styleContext;
31311: }    
31311: 
31311: /* static */
31311: already_AddRefed<nsStyleContext>
31311: nsComputedDOMStyle::GetStyleContextForContent(nsIContent* aContent,
31311:                                               nsIAtom* aPseudo,
31311:                                               nsIPresShell* aPresShell)
31311: {
31542:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
31542:                "aContent must be an element");
31311:   if (!aPseudo) {
31707:     // If there's no pres shell, get it from the content
31707:     if (!aPresShell) {
31707:       aPresShell = GetPresShellForContent(aContent);
31707:       if (!aPresShell)
31707:         return nsnull;
31707:     }
31707: 
31311:     aPresShell->FlushPendingNotifications(Flush_Style);
31707:   }
31707: 
31707:   return GetStyleContextForContentNoFlush(aContent, aPseudo, aPresShell);
31707: }
31707: 
31707: /* static */
31707: already_AddRefed<nsStyleContext>
31707: nsComputedDOMStyle::GetStyleContextForContentNoFlush(nsIContent* aContent,
31707:                                                      nsIAtom* aPseudo,
31707:                                                      nsIPresShell* aPresShell)
31707: {
31707:   NS_ABORT_IF_FALSE(aContent, "NULL content node");
31707: 
31707:   // If there's no pres shell, get it from the content
31707:   if (!aPresShell) {
31707:     aPresShell = GetPresShellForContent(aContent);
31707:     if (!aPresShell)
31707:       return nsnull;
31707:   }
31707: 
31707:   if (!aPseudo) {
31311:     nsIFrame* frame = aPresShell->GetPrimaryFrameFor(aContent);
31311:     if (frame) {
31311:       nsStyleContext* result = GetStyleContextForFrame(frame);
31311:       // Don't use the style context if it was influenced by
31311:       // pseudo-elements, since then it's not the primary style
31311:       // for this element.
31311:       if (!result->HasPseudoElementData()) {
31311:         // this function returns an addrefed style context
31311:         result->AddRef();
31311:         return result;
31311:       }
31311:     }
31311:   }
31311: 
31311:   // No frame has been created or we have a pseudo, so resolve the
31311:   // style ourselves
31311:   nsRefPtr<nsStyleContext> parentContext;
31311:   nsIContent* parent = aPseudo ? aContent : aContent->GetParent();
31542:   // Don't resolve parent context for document fragments.
31542:   if (parent && parent->IsNodeOfType(nsINode::eELEMENT))
31311:     parentContext = GetStyleContextForContent(parent, nsnull, aPresShell);
31311: 
31311:   nsPresContext *presContext = aPresShell->GetPresContext();
31311:   if (!presContext)
31311:     return nsnull;
31311: 
31311:   nsStyleSet *styleSet = aPresShell->StyleSet();
31311: 
31311:   if (aPseudo) {
31311:     return styleSet->ResolvePseudoStyleFor(aContent, aPseudo, parentContext);
31311:   }
31311: 
31311:   return styleSet->ResolveStyleFor(aContent, parentContext);
31311: }
    1: 
31707: /* static */
31707: nsIPresShell*
31707: nsComputedDOMStyle::GetPresShellForContent(nsIContent* aContent)
31707: {
31707:   nsIDocument* currentDoc = aContent->GetCurrentDoc();
31707:   if (!currentDoc)
31707:     return nsnull;
31707: 
31707:   return currentDoc->GetPrimaryShell();
31707: }
31707: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetPropertyCSSValue(const nsAString& aPropertyName,
    1:                                         nsIDOMCSSValue** aReturn)
    1: {
31308:   NS_ASSERTION(!mStyleContextHolder, "bad state");
31308: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocument> document = do_QueryReferent(mDocumentWeak);
    1:   NS_ENSURE_TRUE(document, NS_ERROR_NOT_AVAILABLE);
    1: 
25450:   nsCSSProperty prop = nsCSSProps::LookupProperty(aPropertyName);
25450: 
25450:   const ComputedStyleMapEntry* propEntry = nsnull;
25450:   {
25450:     PRUint32 length = 0;
25450:     const ComputedStyleMapEntry* propMap = GetQueryablePropertyMap(&length);
25450:     for (PRUint32 i = 0; i < length; ++i) {
25450:       if (prop == propMap[i].mProperty) {
25450:         propEntry = &propMap[i];
25450:         break;
25450:       }
25450:     }
25450:   }
25450:   if (!propEntry) {
25450: #ifdef DEBUG_ComputedDOMStyle
25450:     NS_WARNING(PromiseFlatCString(NS_ConvertUTF16toUTF8(aPropertyName) + 
25450:                                   NS_LITERAL_CSTRING(" is not queryable!")).get());
25450: #endif
25450: 
25450:     // NOTE:  For branches, we should flush here for compatibility!
25450:     return NS_OK;
25450:   }
25450: 
    1:   // Flush _before_ getting the presshell, since that could create a new
    1:   // presshell.  Also note that we want to flush the style on the document
    1:   // we're computing style in, not on the document mContent is in -- the two
    1:   // may be different.
25450:   document->FlushPendingNotifications(
25450:     propEntry->mNeedsLayoutFlush ? Flush_Layout : Flush_Style);
25450: #ifdef DEBUG
25450:   mFlushedPendingReflows = propEntry->mNeedsLayoutFlush;
25450: #endif
    1: 
 1102:   mPresShell = document->GetPrimaryShell();
 1102:   NS_ENSURE_TRUE(mPresShell && mPresShell->GetPresContext(),
 1102:                  NS_ERROR_NOT_AVAILABLE);
 1102: 
10950:   mOuterFrame = mPresShell->GetPrimaryFrameFor(mContent);
10950:   mInnerFrame = mOuterFrame;
31308:   if (mOuterFrame && !mPseudo) {
10950:     nsIAtom* type = mOuterFrame->GetType();
 1102:     if (type == nsGkAtoms::tableOuterFrame) {
 1102:       // If the frame is an outer table frame then we should get the style
 1102:       // from the inner table frame.
10950:       mInnerFrame = mOuterFrame->GetFirstChild(nsnull);
10950:       NS_ASSERTION(mInnerFrame, "Outer table must have an inner");
10950:       NS_ASSERTION(!mInnerFrame->GetNextSibling(),
 1102:                    "Outer table frames should have just one child, the inner "
 1102:                    "table");
 1102:     }
 1102: 
10950:     mStyleContextHolder = mInnerFrame->GetStyleContext();
 1102:     NS_ASSERTION(mStyleContextHolder, "Frame without style context?");
    1:   }
    1: 
31308:   if (!mStyleContextHolder || mStyleContextHolder->HasPseudoElementData()) {
31308: #ifdef DEBUG
31308:     if (mStyleContextHolder) {
31308:       // We want to check that going through this path because of
31308:       // HasPseudoElementData is rare, because it slows us down a good
31308:       // bit.  So check that we're really inside something associated
31308:       // with a pseudo-element that contains elements.
31308:       nsStyleContext *topWithPseudoElementData = mStyleContextHolder;
31308:       while (topWithPseudoElementData->GetParent()->HasPseudoElementData()) {
31308:         topWithPseudoElementData = topWithPseudoElementData->GetParent();
31308:       }
31308:       NS_ASSERTION(nsCSSPseudoElements::PseudoElementContainsElements(
34387:                      topWithPseudoElementData->GetPseudo()),
31308:                    "we should be in a pseudo-element that is expected to "
31308:                    "contain elements");
31308:     }
31308: #endif
31308:     // Need to resolve a style context
31308:     mStyleContextHolder =
31311:       nsComputedDOMStyle::GetStyleContextForContent(mContent,
31308:                                                     mPseudo,
31308:                                                     mPresShell);
31308:     NS_ENSURE_TRUE(mStyleContextHolder, NS_ERROR_OUT_OF_MEMORY);
31308:     NS_ASSERTION(mPseudo || !mStyleContextHolder->HasPseudoElementData(),
31308:                  "should not have pseudo-element data");
31308:   }
31308: 
    1:   // Call our pointer-to-member-function.
25450:   nsresult rv = (this->*(propEntry->mGetter))(aReturn);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     *aReturn = nsnull;
    1:   }
    1: 
10950:   mOuterFrame = nsnull;
10950:   mInnerFrame = nsnull;
 1102:   mPresShell = nsnull;
    1: 
    1:   // Release the current style context for it should be re-resolved
    1:   // whenever a frame is not available.
    1:   mStyleContextHolder = nsnull;
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::RemoveProperty(const nsAString& aPropertyName,
    1:                                    nsAString& aReturn)
    1: {
    1:   return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::GetPropertyPriority(const nsAString& aPropertyName,
    1:                                         nsAString& aReturn)
    1: {
    1:   aReturn.Truncate();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::SetProperty(const nsAString& aPropertyName,
    1:                                 const nsAString& aValue,
    1:                                 const nsAString& aPriority)
    1: {
    1:   return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsComputedDOMStyle::Item(PRUint32 aIndex, nsAString& aReturn)
    1: {
    1:   aReturn.Truncate();
    1: 
    1:   PRUint32 length = 0;
    1:   const ComputedStyleMapEntry* propMap = GetQueryablePropertyMap(&length);
    1:   if (aIndex < length) {
    1:     CopyASCIItoUTF16(nsCSSProps::GetStringValue(propMap[aIndex].mProperty),
    1:                     aReturn);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // Property getters...
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBinding(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleDisplay* display = GetStyleDisplay();
    1: 
    1:   if (display->mBinding) {
 3645:     val->SetURI(display->mBinding->mURI);
    1:   } else {
24090:     val->SetIdent(eCSSKeyword_none);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetClear(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34082:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mBreakType,
24090:                                                nsCSSProps::kClearKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetCssFloat(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34082:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mFloats,
24090:                                                nsCSSProps::kFloatKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBottom(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetOffsetWidthFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: 
    1: nsresult
15260: nsComputedDOMStyle::GetStackSizing(nsIDOMCSSValue** aValue)
15260: {
15260:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
15260:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
15260: 
24090:   val->SetIdent(GetStyleXUL()->mStretchStack ? eCSSKeyword_stretch_to_fit :
24090:                 eCSSKeyword_ignore);
15260: 
15260:   return CallQueryInterface(val, aValue);
15260: }
15260: 
15260: nsresult
    1: nsComputedDOMStyle::SetToRGBAColor(nsROCSSPrimitiveValue* aValue,
    1:                                    nscolor aColor)
    1: {
    1:   if (NS_GET_A(aColor) == 0) {
24090:     aValue->SetIdent(eCSSKeyword_transparent);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsROCSSPrimitiveValue *red   = GetROCSSPrimitiveValue();
    1:   nsROCSSPrimitiveValue *green = GetROCSSPrimitiveValue();
    1:   nsROCSSPrimitiveValue *blue  = GetROCSSPrimitiveValue();
    1:   nsROCSSPrimitiveValue *alpha  = GetROCSSPrimitiveValue();
    1: 
    1:   if (red && green && blue && alpha) {
    1:     PRUint8 a = NS_GET_A(aColor);
    1:     nsDOMCSSRGBColor *rgbColor =
    1:       new nsDOMCSSRGBColor(red, green, blue, alpha, a < 255);
    1: 
    1:     if (rgbColor) {
    1:       red->SetNumber(NS_GET_R(aColor));
    1:       green->SetNumber(NS_GET_G(aColor));
    1:       blue->SetNumber(NS_GET_B(aColor));
    1:       alpha->SetNumber(nsStyleUtil::ColorComponentToFloat(a));
    1: 
    1:       aValue->SetColor(rgbColor);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   delete red;
    1:   delete green;
    1:   delete blue;
    1:   delete alpha;
    1: 
    1:   return NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetColor(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleColor* color = GetStyleColor();
    1: 
    1:   nsresult rv = SetToRGBAColor(val, color->mColor);
    1:   if (NS_FAILED(rv)) {
    1:     delete val;
    1:     return rv;
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOpacity(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   val->SetNumber(GetStyleDisplay()->mOpacity);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetColumnCount(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleColumn* column = GetStyleColumn();
    1: 
    1:   if (column->mColumnCount == NS_STYLE_COLUMN_COUNT_AUTO) {
24090:     val->SetIdent(eCSSKeyword_auto);
    1:   } else {
    1:     val->SetNumber(column->mColumnCount);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetColumnWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // XXX fix the auto case. When we actually have a column frame, I think
    1:   // we should return the computed column width.
    1:   SetValueToCoord(val, GetStyleColumn()->mColumnWidth);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetColumnGap(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleColumn* column = GetStyleColumn();
    1:   if (column->mColumnGap.GetUnit() == eStyleUnit_Normal) {
    1:     val->SetAppUnits(GetStyleFont()->mFont.size);
    1:   } else {
 3696:     SetValueToCoord(val, GetStyleColumn()->mColumnGap);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
16055: nsComputedDOMStyle::GetColumnRuleWidth(nsIDOMCSSValue** aValue)
16055: {
16055:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
16055:   if (!val)
16055:     return NS_ERROR_OUT_OF_MEMORY;
16055: 
33820:   val->SetAppUnits(GetStyleColumn()->GetComputedColumnRuleWidth());
16055:   return CallQueryInterface(val, aValue);
16055: }
16055: 
16055: nsresult
16055: nsComputedDOMStyle::GetColumnRuleStyle(nsIDOMCSSValue** aValue)
16055: {
16055:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
16055:   if (!val)
16055:     return NS_ERROR_OUT_OF_MEMORY;
16055:   
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleColumn()->mColumnRuleStyle,
24090:                                    nsCSSProps::kBorderStyleKTable));
34082: 
16055:   return CallQueryInterface(val, aValue);
16055: }
16055: 
16055: nsresult
16055: nsComputedDOMStyle::GetColumnRuleColor(nsIDOMCSSValue** aValue)
16055: {
16055:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
16055:   if (!val)
16055:     return NS_ERROR_OUT_OF_MEMORY;
16055: 
16055:   const nsStyleColumn* column = GetStyleColumn();
16055:   nscolor ruleColor;
16055:   if (column->mColumnRuleColorIsForeground) {
16055:     ruleColor = GetStyleColor()->mColor;
16055:   } else {
16055:     ruleColor = column->mColumnRuleColor;
16055:   }
16055: 
16055:   SetToRGBAColor(val, ruleColor);
16055:   return CallQueryInterface(val, aValue);
16055: }
16055: 
16055: nsresult
 3750: nsComputedDOMStyle::GetContent(nsIDOMCSSValue** aValue)
 3750: {
 3750:   const nsStyleContent *content = GetStyleContent();
 3750: 
 3750:   if (content->ContentCount() == 0) {
 3750:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3750:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
24090:     val->SetIdent(eCSSKeyword_none);
 3750:     return CallQueryInterface(val, aValue);
 3750:   }
 3750: 
 3750:   if (content->ContentCount() == 1 &&
 3750:       content->ContentAt(0).mType == eStyleContentType_AltContent) {
 3750:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3750:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3750:     val->SetIdent(eCSSKeyword__moz_alt_content);
 3750:     return CallQueryInterface(val, aValue);
 3750:   }
 3750: 
 3750:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
 3750:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
 3750: 
 3750:   for (PRUint32 i = 0, i_end = content->ContentCount(); i < i_end; ++i) {
 3750:     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3750:     if (!val || !valueList->AppendCSSValue(val)) {
 3750:       delete valueList;
 3750:       delete val;
 3750:       return NS_ERROR_OUT_OF_MEMORY;
 3750:     }
 3750: 
 3750:     const nsStyleContentData &data = content->ContentAt(i);
 3750:     switch (data.mType) {
 3750:       case eStyleContentType_String:
 3750:         {
 3750:           nsString str;
25793:           nsStyleUtil::AppendEscapedCSSString(
25793:             nsDependentString(data.mContent.mString), str);
 3750:           val->SetString(str);
 3750:         }
 3750:         break;
 3750:       case eStyleContentType_Image:
 3750:         {
 3750:           nsCOMPtr<nsIURI> uri;
 3750:           if (data.mContent.mImage) {
 3750:             data.mContent.mImage->GetURI(getter_AddRefs(uri));
 3750:           }
 3750:           val->SetURI(uri);
 3750:         }
 3750:         break;
 3750:       case eStyleContentType_Attr:
 3750:         val->SetString(nsDependentString(data.mContent.mString),
 3750:                        nsIDOMCSSPrimitiveValue::CSS_ATTR);
 3750:         break;
 3750:       case eStyleContentType_Counter:
 3750:       case eStyleContentType_Counters:
 3750:         {
 3750:           /* FIXME: counters should really use an object */
 3750:           nsAutoString str;
 3750:           if (data.mType == eStyleContentType_Counter) {
 3750:             str.AppendLiteral("counter(");
 3750:           }
 3750:           else {
 3750:             str.AppendLiteral("counters(");
 3750:           }
 3750:           // WRITE ME
 3750:           nsCSSValue::Array *a = data.mContent.mCounters;
 3750: 
 3750:           str.Append(a->Item(0).GetStringBufferValue());
 3750:           PRInt32 typeItem = 1;
 3750:           if (data.mType == eStyleContentType_Counters) {
 3750:             typeItem = 2;
25793:             str.AppendLiteral(", ");
25793:             nsStyleUtil::AppendEscapedCSSString(
25793:               nsDependentString(a->Item(1).GetStringBufferValue()), str);
 3750:           }
34082:           NS_ABORT_IF_FALSE(eCSSUnit_None != a->Item(typeItem).GetUnit(),
34082:                             "'none' should be handled  as enumerated value");
 3750:           PRInt32 type = a->Item(typeItem).GetIntValue();
 3750:           if (type != NS_STYLE_LIST_STYLE_DECIMAL) {
 3750:             str.AppendLiteral(", ");
25797:             AppendASCIItoUTF16(
25797:               nsCSSProps::ValueToKeyword(type, nsCSSProps::kListStyleKTable),
25797:               str);
25797:           }
 3750: 
 3750:           str.Append(PRUnichar(')'));
 3750:           val->SetString(str, nsIDOMCSSPrimitiveValue::CSS_COUNTER);
 3750:         }
 3750:         break;
 3750:       case eStyleContentType_OpenQuote:
 3750:         val->SetIdent(eCSSKeyword_open_quote);
 3750:         break;
 3750:       case eStyleContentType_CloseQuote:
 3750:         val->SetIdent(eCSSKeyword_close_quote);
 3750:         break;
 3750:       case eStyleContentType_NoOpenQuote:
 3750:         val->SetIdent(eCSSKeyword_no_open_quote);
 3750:         break;
 3750:       case eStyleContentType_NoCloseQuote:
 3750:         val->SetIdent(eCSSKeyword_no_close_quote);
 3750:         break;
 3750:       case eStyleContentType_AltContent:
 3750:       default:
 3750:         NS_NOTREACHED("unexpected type");
 3750:         break;
 3750:     }
 3750:   }
 3750: 
 3750:   return CallQueryInterface(valueList, aValue);
 3750: }
 3750: 
 3750: nsresult
    1: nsComputedDOMStyle::GetCounterIncrement(nsIDOMCSSValue** aValue)
    1: {
    1:   const nsStyleContent *content = GetStyleContent();
    1: 
    1:   if (content->CounterIncrementCount() == 0) {
    1:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
24090:     val->SetIdent(eCSSKeyword_none);
    1:     return CallQueryInterface(val, aValue);
    1:   }
    1: 
    1:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
    1:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   for (PRUint32 i = 0, i_end = content->CounterIncrementCount(); i < i_end; ++i) {
    1:     nsROCSSPrimitiveValue* name = GetROCSSPrimitiveValue();
 3750:     if (!name || !valueList->AppendCSSValue(name)) {
    1:       delete valueList;
    1:       delete name;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     
    1:     nsROCSSPrimitiveValue* value = GetROCSSPrimitiveValue();
 3750:     if (!value || !valueList->AppendCSSValue(value)) {
    1:       delete valueList;
    1:       delete value;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     const nsStyleCounterData *data = content->GetCounterIncrementAt(i);
    1:     name->SetString(data->mCounter);
    1:     value->SetNumber(data->mValue); // XXX This should really be integer
    1:   }
    1: 
    1:   return CallQueryInterface(valueList, aValue);
    1: }
    1: 
19214: /* Convert the stored representation into a list of two values and then hand
19214:  * it back.
19214:  */
19214: nsresult nsComputedDOMStyle::GetMozTransformOrigin(nsIDOMCSSValue **aValue)
19214: {
19214:   /* We need to build up a list of two values.  We'll call them
19214:    * width and height.
19214:    */
19214:   nsAutoPtr<nsROCSSPrimitiveValue> width(GetROCSSPrimitiveValue());
19214:   nsAutoPtr<nsROCSSPrimitiveValue> height(GetROCSSPrimitiveValue());
19214:   if (!width || !height)
19214:     return NS_ERROR_OUT_OF_MEMORY;
19214: 
19214:   /* Now, get the values. */
19214:   const nsStyleDisplay* display = GetStyleDisplay();
19214:   SetValueToCoord(width, display->mTransformOrigin[0],
19214:                   &nsComputedDOMStyle::GetFrameBoundsWidthForTransform);
19214:   SetValueToCoord(height, display->mTransformOrigin[1],
19214:                   &nsComputedDOMStyle::GetFrameBoundsHeightForTransform);
19214: 
19214:   /* Store things as a value list, fail if we can't get one. */
19214:   nsAutoPtr<nsDOMCSSValueList> valueList(GetROCSSValueList(PR_FALSE));
19214:   if (!valueList)
19214:     return NS_ERROR_OUT_OF_MEMORY;
19214: 
19214:   /* Chain on width and height, fail if we can't. */
19214:   if (!valueList->AppendCSSValue(width))
19214:     return NS_ERROR_OUT_OF_MEMORY;
19214:   width.forget();
19214:   if (!valueList->AppendCSSValue(height))
19214:     return NS_ERROR_OUT_OF_MEMORY;
19214:   height.forget();
19214: 
19214:   /* Release the pointer and call query interface!  We're done. */
19214:   return CallQueryInterface(valueList.forget(), aValue);
19214: }
19214: 
19214: /* If the property is "none", hand back "none" wrapped in a value.
19214:  * Otherwise, compute the aggregate transform matrix and hands it back in a
19214:  * "matrix" wrapper.
19214:  */
19214: nsresult nsComputedDOMStyle::GetMozTransform(nsIDOMCSSValue **aValue)
19214: {
19214:   static const PRInt32 NUM_FLOATS = 4;
19214:   
19214:   /* First, get the display data.  We'll need it. */
19214:   const nsStyleDisplay* display = GetStyleDisplay();
19214:   
19214:   /* If the "no transforms" flag is set, then we should construct a
19214:    * single-element entry and hand it back.
19214:    */
19214:   if (!display->mTransformPresent) {
19214:     nsROCSSPrimitiveValue *val(GetROCSSPrimitiveValue());
19214:     if (!val)
19214:       return NS_ERROR_OUT_OF_MEMORY;
19214:     
19214:     /* Set it to "none." */
19214:     val->SetIdent(eCSSKeyword_none);
19214:     return CallQueryInterface(val, aValue);
19214:   }
19214:   
19214:   /* Otherwise, we need to compute the current value of the transform matrix,
19214:    * store it in a string, and hand it back to the caller.
19214:    */
19214:   nsAutoString resultString(NS_LITERAL_STRING("matrix("));
19214:   
19214:   /* Now, we need to convert the matrix into a string.  We'll start by taking
19214:    * the first four entries and converting them directly to floating-point
19214:    * values.
19214:    */
19214:   for (PRInt32 index = 0; index < NUM_FLOATS; ++index) {
19214:     resultString.AppendFloat(display->mTransform.GetMainMatrixEntry(index));
19214:     resultString.Append(NS_LITERAL_STRING(", "));
19214:   }
19214: 
19214:   /* Use the inner frame for width and height.  If we fail, assume zero.
19214:    * TODO: There is no good way for us to represent the case where there's no
19214:    * frame, which is problematic.  The reason is that when we have percentage
19214:    * transforms, there are a total of four stored matrix entries that influence
19214:    * the transform based on the size of the element.  However, this poses a
19214:    * problem, because only two of these values can be explicitly referenced
19214:    * using the named transforms.  Until a real solution is found, we'll just
19214:    * use this approach.
19214:    */
19214:   nsRect bounds =
19214:     (mInnerFrame ? nsDisplayTransform::GetFrameBoundsForTransform(mInnerFrame) :
19214:      nsRect(0, 0, 0, 0));
19214: 
19214:   /* Now, compute the dX and dY components by adding the stored coord value
19214:    * (in CSS pixels) to the translate values.
19214:    */
19214:   
19214:   float deltaX = nsPresContext::AppUnitsToFloatCSSPixels
19214:     (display->mTransform.GetXTranslation(bounds));
19214:   float deltaY = nsPresContext::AppUnitsToFloatCSSPixels
19214:     (display->mTransform.GetYTranslation(bounds));
19214:      
19214: 
19214:   /* Append these values! */
19214:   resultString.AppendFloat(deltaX);
19214:   resultString.Append(NS_LITERAL_STRING("px, "));
19214:   resultString.AppendFloat(deltaY);
19214:   resultString.Append(NS_LITERAL_STRING("px)"));
19214: 
19214:   /* Create a value to hold our result. */
19214:   nsROCSSPrimitiveValue* rv(GetROCSSPrimitiveValue());
19214: 
19214:   if (!rv)
19214:     return NS_ERROR_OUT_OF_MEMORY;
19214: 
19214:   rv->SetString(resultString);
19214:   return CallQueryInterface(rv, aValue);
19214: }
19214: 
    1: nsresult
    1: nsComputedDOMStyle::GetCounterReset(nsIDOMCSSValue** aValue)
    1: {
    1:   const nsStyleContent *content = GetStyleContent();
    1: 
    1:   if (content->CounterResetCount() == 0) {
    1:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
24090:     val->SetIdent(eCSSKeyword_none);
    1:     return CallQueryInterface(val, aValue);
    1:   }
    1: 
    1:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
    1:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   for (PRUint32 i = 0, i_end = content->CounterResetCount(); i < i_end; ++i) {
    1:     nsROCSSPrimitiveValue* name = GetROCSSPrimitiveValue();
 3750:     if (!name || !valueList->AppendCSSValue(name)) {
    1:       delete valueList;
    1:       delete name;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     
    1:     nsROCSSPrimitiveValue* value = GetROCSSPrimitiveValue();
 3750:     if (!value || !valueList->AppendCSSValue(value)) {
    1:       delete valueList;
    1:       delete value;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     const nsStyleCounterData *data = content->GetCounterResetAt(i);
    1:     name->SetString(data->mCounter);
    1:     value->SetNumber(data->mValue); // XXX This should really be integer
    1:   }
    1: 
    1:   return CallQueryInterface(valueList, aValue);
    1: }
    1: 
    1: nsresult
 3750: nsComputedDOMStyle::GetQuotes(nsIDOMCSSValue** aValue)
 3750: {
 3750:   const nsStyleQuotes *quotes = GetStyleQuotes();
 3750: 
 3750:   if (quotes->QuotesCount() == 0) {
 3750:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3750:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
24090:     val->SetIdent(eCSSKeyword_none);
 3750:     return CallQueryInterface(val, aValue);
 3750:   }
 3750: 
 3750:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
 3750:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
 3750: 
 3750:   for (PRUint32 i = 0, i_end = quotes->QuotesCount(); i < i_end; ++i) {
 3750:     nsROCSSPrimitiveValue* openVal = GetROCSSPrimitiveValue();
 3750:     if (!openVal || !valueList->AppendCSSValue(openVal)) {
 3750:       delete valueList;
 3750:       delete openVal;
 3750:       return NS_ERROR_OUT_OF_MEMORY;
 3750:     }
 3750:     
 3750:     nsROCSSPrimitiveValue* closeVal = GetROCSSPrimitiveValue();
 3750:     if (!closeVal || !valueList->AppendCSSValue(closeVal)) {
 3750:       delete valueList;
 3750:       delete closeVal;
 3750:       return NS_ERROR_OUT_OF_MEMORY;
 3750:     }
 3750: 
 3750:     nsString s;
25793:     nsStyleUtil::AppendEscapedCSSString(*quotes->OpenQuoteAt(i), s);
 3750:     openVal->SetString(s);
25793:     s.Truncate();
25793:     nsStyleUtil::AppendEscapedCSSString(*quotes->CloseQuoteAt(i), s);
 3750:     closeVal->SetString(s);
 3750:   }
 3750: 
 3750:   return CallQueryInterface(valueList, aValue);
 3750: }
 3750: 
 3750: nsresult
    1: nsComputedDOMStyle::GetFontFamily(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleFont* font = GetStyleFont();
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocumentWeak);
    1:   NS_ASSERTION(doc, "document is required");
  981:   nsIPresShell* presShell = doc->GetPrimaryShell();
    1:   NS_ASSERTION(presShell, "pres shell is required");
    1:   nsPresContext *presContext = presShell->GetPresContext();
    1:   NS_ASSERTION(presContext, "pres context is required");
    1: 
    1:   const nsString& fontName = font->mFont.name;
20260:   if (font->mGenericID == kGenericFont_NONE && !font->mFont.systemFont) { 
    1:     const nsFont* defaultFont =
    1:       presContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID);
    1: 
    1:     PRInt32 lendiff = fontName.Length() - defaultFont->name.Length();
    1:     if (lendiff > 0) {
    1:       val->SetString(Substring(fontName, 0, lendiff-1)); // -1 removes comma
    1:     } else {
    1:       val->SetString(fontName);
    1:     }
    1:   } else {
    1:     val->SetString(fontName);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetFontSize(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Note: GetStyleFont()->mSize is the 'computed size';
    1:   // GetStyleFont()->mFont.size is the 'actual size'
    1:   val->SetAppUnits(GetStyleFont()->mSize);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetFontSizeAdjust(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleFont *font = GetStyleFont();
    1: 
    1:   if (font->mFont.sizeAdjust) {
    1:     val->SetNumber(font->mFont.sizeAdjust);
    1:   } else {
24090:     val->SetIdent(eCSSKeyword_none);
24089:   }
24089: 
24089:   return CallQueryInterface(val, aValue);
24089: }
24089: 
24089: nsresult
24408: nsComputedDOMStyle::GetFontStretch(nsIDOMCSSValue** aValue)
24408: {
24408:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
24408:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
24408: 
24408:   const nsStyleFont* font = GetStyleFont();
24408: 
24408:   // The computed value space isn't actually representable in string
24408:   // form, so just represent anything with widers or narrowers in it as
24408:   // 'wider' or 'narrower'.
24408:   PR_STATIC_ASSERT(NS_FONT_STRETCH_NARROWER % 2 == 0);
24408:   PR_STATIC_ASSERT(NS_FONT_STRETCH_WIDER % 2 == 0);
24408:   PR_STATIC_ASSERT(NS_FONT_STRETCH_NARROWER + NS_FONT_STRETCH_WIDER == 0);
24408:   PR_STATIC_ASSERT(NS_FONT_STRETCH_NARROWER < 0);
24408:   PRInt16 stretch = font->mFont.stretch;
34871:   if (stretch <= NS_FONT_STRETCH_NARROWER / 2) {
24408:     val->SetIdent(eCSSKeyword_narrower);
24408:   } else if (stretch >= NS_FONT_STRETCH_WIDER / 2) {
24408:     val->SetIdent(eCSSKeyword_wider);
24408:   } else {
24408:     val->SetIdent(
24408:       nsCSSProps::ValueToKeywordEnum(stretch, nsCSSProps::kFontStretchKTable));
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetFontStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34081:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleFont()->mFont.style,
24090:                                                nsCSSProps::kFontStyleKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetFontWeight(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleFont* font = GetStyleFont();
    1: 
34872:   PRUint16 weight = font->mFont.weight;
34872:   if (weight % 100 == 0) {
34872:     val->SetNumber(font->mFont.weight);
34872:   } else if (weight % 100 > 50) {
34872:     // FIXME: This doesn't represent the full range of computed values,
34872:     // but at least it's legal CSS.
34872:     val->SetIdent(eCSSKeyword_lighter);
    1:   } else {
34872:     // FIXME: This doesn't represent the full range of computed values,
34872:     // but at least it's legal CSS.
34872:     val->SetIdent(eCSSKeyword_bolder);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetFontVariant(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34081:     nsCSSProps::ValueToKeywordEnum(GetStyleFont()->mFont.variant,
24090:                                    nsCSSProps::kFontVariantKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
25276: nsComputedDOMStyle::GetBackgroundList(PRUint8 nsStyleBackground::Layer::* aMember,
25276:                                       PRUint32 nsStyleBackground::* aCount,
25276:                                       const PRInt32 aTable[],
25276:                                       nsIDOMCSSValue** aResult)
25276: {
25276:   const nsStyleBackground* bg = GetStyleBackground();
25276: 
25276:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
25276:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
25276: 
25276:   for (PRUint32 i = 0, i_end = bg->*aCount; i < i_end; ++i) {
25276:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
25276:     if (!val || !valueList->AppendCSSValue(val)) {
25276:       delete val;
25276:       delete valueList;
25276:       return NS_ERROR_OUT_OF_MEMORY;
25276:     }
25276:     val->SetIdent(nsCSSProps::ValueToKeywordEnum(bg->mLayers[i].*aMember,
25276:                                                  aTable));
25276:   }
25276: 
25276:   return CallQueryInterface(valueList, aResult);
25276: }
25276: 
25276: nsresult
    1: nsComputedDOMStyle::GetBackgroundAttachment(nsIDOMCSSValue** aValue)
    1: {
25276:   return GetBackgroundList(&nsStyleBackground::Layer::mAttachment,
25276:                            &nsStyleBackground::mAttachmentCount,
25276:                            nsCSSProps::kBackgroundAttachmentKTable,
25276:                            aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBackgroundClip(nsIDOMCSSValue** aValue)
    1: {
25276:   return GetBackgroundList(&nsStyleBackground::Layer::mClip,
25276:                            &nsStyleBackground::mClipCount,
25276:                            nsCSSProps::kBackgroundClipKTable,
25276:                            aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBackgroundColor(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
29266:   const nsStyleBackground* color = GetStyleBackground();
29266:   nsresult rv = SetToRGBAColor(val, color->mBackgroundColor);
    1:   if (NS_FAILED(rv)) {
    1:     delete val;
    1:     return rv;
    1:   }
29266: 
29266:   return CallQueryInterface(val, aValue);
    1: }
    1: 
30993: static void
30993: AppendCSSGradientLength(const nsStyleCoord& aValue,
30993:                         nsROCSSPrimitiveValue* aPrimitive,
30993:                         nsAString& aString)
30993: {
30993:   nsAutoString tokenString;
30993:   if (aValue.GetUnit() == eStyleUnit_Coord)
30993:     aPrimitive->SetAppUnits(aValue.GetCoordValue());
30993:   else
30993:     aPrimitive->SetPercent(aValue.GetPercentValue());
30993:   aPrimitive->GetCssText(tokenString);
30993:   aString.Append(tokenString);
30993: }
30993: 
30993: nsresult
30993: nsComputedDOMStyle::GetCSSGradientString(const nsStyleGradient* aGradient,
30993:                                          nsAString& aString)
30993: {
34475:   if (aGradient->mRepeating) {
34475:     if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR)
34475:       aString.AssignLiteral("-moz-repeating-linear-gradient(");
34475:     else
34475:       aString.AssignLiteral("-moz-repeating-radial-gradient(");
34475:   } else {
34475:     if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR)
34475:       aString.AssignLiteral("-moz-linear-gradient(");
34475:     else
30993:       aString.AssignLiteral("-moz-radial-gradient(");
34475:   }
34475: 
34475:   PRBool needSep = PR_FALSE;
34475:   nsAutoString tokenString;
30993:   nsROCSSPrimitiveValue *tmpVal = GetROCSSPrimitiveValue();
30993:   if (!tmpVal)
30993:     return NS_ERROR_OUT_OF_MEMORY;
30993: 
34475:   if (aGradient->mBgPosX.mUnit != eStyleUnit_None) {
34475:     AppendCSSGradientLength(aGradient->mBgPosX, tmpVal, aString);
34475:     needSep = PR_TRUE;
34475:   }
34475:   if (aGradient->mBgPosY.mUnit != eStyleUnit_None) {
34475:     if (needSep) {
30993:       aString.AppendLiteral(" ");
34475:     }
34475:     AppendCSSGradientLength(aGradient->mBgPosY, tmpVal, aString);
34475:     needSep = PR_TRUE;
34475:   }
34475:   if (aGradient->mAngle.mUnit != eStyleUnit_None) {
34475:     if (needSep) {
34475:       aString.AppendLiteral(" ");
34475:     }
34475:     tmpVal->SetNumber(aGradient->mAngle.GetAngleValue());
34475:     tmpVal->GetCssText(tokenString);
34475:     aString.Append(tokenString);
34475:     switch (aGradient->mAngle.mUnit) {
34475:     case eStyleUnit_Degree: aString.AppendLiteral("deg"); break;
34475:     case eStyleUnit_Grad: aString.AppendLiteral("grad"); break;
34475:     case eStyleUnit_Radian: aString.AppendLiteral("rad"); break;
34475:     default: NS_NOTREACHED("unrecognized angle unit");
34475:     }
34475:     needSep = PR_TRUE;
34475:   }
34475: 
34475:   if (aGradient->mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR) {
34475:     if (needSep) {
30993:       aString.AppendLiteral(", ");
34475:     }
34475:     AppendASCIItoUTF16(nsCSSProps::
34475:                        ValueToKeyword(aGradient->mShape,
34475:                                       nsCSSProps::kRadialGradientShapeKTable),
34475:                        aString);
34475:     if (aGradient->mSize != NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER) {
30993:       aString.AppendLiteral(" ");
34475:       AppendASCIItoUTF16(nsCSSProps::
34475:                          ValueToKeyword(aGradient->mSize,
34475:                                         nsCSSProps::kRadialGradientSizeKTable),
34475:                          aString);
34475:     }
34475:     needSep = PR_TRUE;
34475:   }
34475: 
30993: 
30993:   // color stops
30993:   for (PRUint32 i = 0; i < aGradient->mStops.Length(); ++i) {
34475:     if (needSep) {
30993:       aString.AppendLiteral(", ");
34475:     }
30993:     nsresult rv = SetToRGBAColor(tmpVal, aGradient->mStops[i].mColor);
30993:     if (NS_FAILED(rv)) {
30993:       delete tmpVal;
30993:       return NS_ERROR_OUT_OF_MEMORY;
30993:     }
30993:     tmpVal->GetCssText(tokenString);
30993:     aString.Append(tokenString);
34475: 
34475:     if (aGradient->mStops[i].mLocation.mUnit != eStyleUnit_None) {
34475:       aString.AppendLiteral(" ");
34475:       AppendCSSGradientLength(aGradient->mStops[i].mLocation, tmpVal, aString);
34475:     }
34475:     needSep = PR_TRUE;
30993:   }
30993: 
30993:   delete tmpVal;
30993:   aString.AppendLiteral(")");
30993:   return NS_OK;
30993: }
30993: 
31749: // -moz-image-rect(<uri>, <top>, <right>, <bottom>, <left>)
31749: nsresult
31749: nsComputedDOMStyle::GetImageRectString(nsIURI* aURI,
31749:                                        const nsStyleSides& aCropRect,
31749:                                        nsString& aString)
31749: {
31749:   nsDOMCSSValueList* valueList = GetROCSSValueList(PR_TRUE);
31749:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
31749: 
31749:   // <uri>
31749:   nsROCSSPrimitiveValue *valURI = GetROCSSPrimitiveValue();
31749:   if (!valURI || !valueList->AppendCSSValue(valURI)) {
31749:     delete valURI;
31749:     delete valueList;
31749:     return NS_ERROR_OUT_OF_MEMORY;
31749:   }
31749:   valURI->SetURI(aURI);
31749: 
31749:   // <top>, <right>, <bottom>, <left>
31749:   NS_FOR_CSS_SIDES(side) {
31749:     nsROCSSPrimitiveValue *valSide = GetROCSSPrimitiveValue();
31749:     if (!valSide || !valueList->AppendCSSValue(valSide)) {
31749:       delete valSide;
31749:       delete valueList;
31749:       return NS_ERROR_OUT_OF_MEMORY;
31749:     }
31749:     SetValueToCoord(valSide, aCropRect.Get(side));
31749:   }
31749: 
31749:   nsAutoString argumentString;
31749:   valueList->GetCssText(argumentString);
31749:   delete valueList;
31749: 
31749:   aString = NS_LITERAL_STRING("-moz-image-rect(") +
31749:             argumentString +
31749:             NS_LITERAL_STRING(")");
31749:   return NS_OK;
31749: }
31749: 
31749: nsresult
31749: nsComputedDOMStyle::SetValueToStyleImage(const nsStyleImage& aStyleImage,
31749:                                          nsROCSSPrimitiveValue* aValue)
31749: {
31749:   switch (aStyleImage.GetType()) {
31749:     case eStyleImageType_Image:
31749:     {
31749:       imgIRequest *req = aStyleImage.GetImageData();
31749:       nsCOMPtr<nsIURI> uri;
31749:       req->GetURI(getter_AddRefs(uri));
31749: 
31749:       const nsStyleSides* cropRect = aStyleImage.GetCropRect();
31749:       if (cropRect) {
31749:         nsAutoString imageRectString;
31749:         nsresult rv = GetImageRectString(uri, *cropRect, imageRectString);
31749:         NS_ENSURE_SUCCESS(rv, rv);
31749:         aValue->SetString(imageRectString);
31749:       } else {
31749:         aValue->SetURI(uri);
31749:       }
31749:       break;
31749:     }
31749:     case eStyleImageType_Gradient:
31749:     {
31749:       nsAutoString gradientString;
31749:       nsresult rv = GetCSSGradientString(aStyleImage.GetGradientData(),
31749:                                          gradientString);
31749:       NS_ENSURE_SUCCESS(rv, rv);
31749:       aValue->SetString(gradientString);
31749:       break;
31749:     }
31749:     case eStyleImageType_Null:
31749:       aValue->SetIdent(eCSSKeyword_none);
31749:       break;
31749:     default:
31749:       NS_NOTREACHED("unexpected image type");
31749:       return NS_ERROR_UNEXPECTED;
31749:   }
31749: 
31749:   return NS_OK;
31749: }
31749: 
    1: nsresult
    1: nsComputedDOMStyle::GetBackgroundImage(nsIDOMCSSValue** aValue)
    1: {
25276:   const nsStyleBackground* bg = GetStyleBackground();
25276: 
25276:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
25276:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
25276: 
25276:   for (PRUint32 i = 0, i_end = bg->mImageCount; i < i_end; ++i) {
    1:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
25276:     if (!val || !valueList->AppendCSSValue(val)) {
25276:       delete val;
25276:       delete valueList;
25276:       return NS_ERROR_OUT_OF_MEMORY;
25276:     }
25276: 
31749:     const nsStyleImage& image = bg->mLayers[i].mImage;
31749:     nsresult rv = SetValueToStyleImage(image, val);
30993:     if (NS_FAILED(rv)) {
30993:       delete valueList;
30993:       return rv;
30993:     }
25276:   }
25276: 
25276:   return CallQueryInterface(valueList, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBackgroundInlinePolicy(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(
24090:                   GetStyleBackground()->mBackgroundInlinePolicy,
24090:                   nsCSSProps::kBackgroundInlinePolicyKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);  
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBackgroundOrigin(nsIDOMCSSValue** aValue)
    1: {
25276:   return GetBackgroundList(&nsStyleBackground::Layer::mOrigin,
25276:                            &nsStyleBackground::mOriginCount,
25276:                            nsCSSProps::kBackgroundOriginKTable,
25276:                            aValue);
    1: }
    1: 
    1: nsresult
 3750: nsComputedDOMStyle::GetBackgroundPosition(nsIDOMCSSValue** aValue)
 3750: {
25276:   const nsStyleBackground* bg = GetStyleBackground();
25276: 
25276:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
 3750:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
 3750: 
25276:   for (PRUint32 i = 0, i_end = bg->mPositionCount; i < i_end; ++i) {
25276:     nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
25276:     if (!itemList || !valueList->AppendCSSValue(itemList)) {
25276:       delete valueList;
25276:       delete itemList;
25276:       return NS_ERROR_OUT_OF_MEMORY;
25276:     }
25276: 
 3750:     nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
25276:     if (!valX || !itemList->AppendCSSValue(valX)) {
 3750:       delete valueList;
 3750:       delete valX;
 3750:       return NS_ERROR_OUT_OF_MEMORY;
 3750:     }
 3750: 
 3750:     nsROCSSPrimitiveValue *valY = GetROCSSPrimitiveValue();
25276:     if (!valY || !itemList->AppendCSSValue(valY)) {
 3750:       delete valueList;
 3750:       delete valY;
 3750:       return NS_ERROR_OUT_OF_MEMORY;
 3750:     }
 3750: 
25276:     const nsStyleBackground::Position &pos = bg->mLayers[i].mPosition;
25276: 
25276:     if (pos.mXIsPercent) {
25276:       valX->SetPercent(pos.mXPosition.mFloat);
25276:     } else {
25276:       valX->SetAppUnits(pos.mXPosition.mCoord);
25276:     }
25276: 
25276:     if (pos.mYIsPercent) {
25276:       valY->SetPercent(pos.mYPosition.mFloat);
25276:     } else {
25276:       valY->SetAppUnits(pos.mYPosition.mCoord);
25276:     }
 3750:   }
 3750: 
 3750:   return CallQueryInterface(valueList, aValue);  
 3750: }
 3750: 
 3750: nsresult
    1: nsComputedDOMStyle::GetBackgroundRepeat(nsIDOMCSSValue** aValue)
    1: {
25276:   return GetBackgroundList(&nsStyleBackground::Layer::mRepeat,
25276:                            &nsStyleBackground::mRepeatCount,
25276:                            nsCSSProps::kBackgroundRepeatKTable,
25276:                            aValue);
    1: }
    1: 
    1: nsresult
30894: nsComputedDOMStyle::GetMozBackgroundSize(nsIDOMCSSValue** aValue)
30894: {
30894:   const nsStyleBackground* bg = GetStyleBackground();
30894: 
30894:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
30894:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
30894: 
30894:   for (PRUint32 i = 0, i_end = bg->mSizeCount; i < i_end; ++i) {
30894:     const nsStyleBackground::Size &size = bg->mLayers[i].mSize;
30894: 
30894:     switch (size.mWidthType) {
30894:       case nsStyleBackground::Size::eContain:
30894:       case nsStyleBackground::Size::eCover: {
30894:         NS_ABORT_IF_FALSE(size.mWidthType == size.mHeightType,
30894:                           "unsynced types");
30894:         nsCSSKeyword keyword = size.mWidthType == nsStyleBackground::Size::eContain
30894:                              ? eCSSKeyword_contain
30894:                              : eCSSKeyword_cover;
30894:         nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
30894:         if (!val || !valueList->AppendCSSValue(val)) {
30894:           delete valueList;
30894:           delete val;
30894:           return NS_ERROR_OUT_OF_MEMORY;
30894:         }
30894:         val->SetIdent(keyword);
30894:         break;
30894:       }
30894:       default: {
30894:         nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
30894:         if (!itemList || !valueList->AppendCSSValue(itemList)) {
30894:           delete valueList;
30894:           delete itemList;
30894:           return NS_ERROR_OUT_OF_MEMORY;
30894:         }
30894: 
30894:         nsROCSSPrimitiveValue* valX = GetROCSSPrimitiveValue();
30894:         nsROCSSPrimitiveValue* valY = GetROCSSPrimitiveValue();
30894:         if (!valX || !itemList->AppendCSSValue(valX)) {
30894:           delete valueList;
30894:           delete valX;
30894:           return NS_ERROR_OUT_OF_MEMORY;
30894:         }
30894:         if (!valY || !itemList->AppendCSSValue(valY)) {
30894:           delete valueList;
30894:           delete valY;
30894:           return NS_ERROR_OUT_OF_MEMORY;
30894:         }
30894: 
30894:         if (size.mWidthType == nsStyleBackground::Size::eAuto) {
30894:           valX->SetIdent(eCSSKeyword_auto);
30894:         } else if (size.mWidthType == nsStyleBackground::Size::ePercentage) {
30894:           valX->SetPercent(size.mWidth.mFloat);
30894:         } else {
30894:           NS_ABORT_IF_FALSE(size.mWidthType == nsStyleBackground::Size::eLength,
30894:                             "bad mWidthType");
30894:           valX->SetAppUnits(size.mWidth.mCoord);
30894:         }
30894: 
30894:         if (size.mHeightType == nsStyleBackground::Size::eAuto) {
30894:           valY->SetIdent(eCSSKeyword_auto);
30894:         } else if (size.mHeightType == nsStyleBackground::Size::ePercentage) {
30894:           valY->SetPercent(size.mHeight.mFloat);
30894:         } else {
30894:           NS_ABORT_IF_FALSE(size.mHeightType == nsStyleBackground::Size::eLength,
30894:                             "bad mHeightType");
30894:           valY->SetAppUnits(size.mHeight.mCoord);
30894:         }
30894:         break;
30894:       }
30894:     }
30894:   }
30894: 
30894:   return CallQueryInterface(valueList, aValue);
30894: }
30894: 
30894: nsresult
    1: nsComputedDOMStyle::GetPadding(nsIDOMCSSValue** aValue)
    1: {
    1:   // return null per spec.
25451:   *aValue = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetPaddingTop(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetPaddingWidthFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetPaddingBottom(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetPaddingWidthFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetPaddingLeft(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetPaddingWidthFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetPaddingRight(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetPaddingWidthFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderCollapse(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleTableBorder()->mBorderCollapse,
24090:                                    nsCSSProps::kBorderCollapseKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderSpacing(nsIDOMCSSValue** aValue)
    1: {
    1:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
    1:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsROCSSPrimitiveValue* xSpacing = GetROCSSPrimitiveValue();
    1:   if (!xSpacing) {
    1:     delete valueList;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   if (!valueList->AppendCSSValue(xSpacing)) {
    1:     delete valueList;
    1:     delete xSpacing;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:     
    1:   nsROCSSPrimitiveValue* ySpacing = GetROCSSPrimitiveValue();
    1:   if (!ySpacing) {
    1:     delete valueList;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   if (!valueList->AppendCSSValue(ySpacing)) {
    1:     delete valueList;
    1:     delete ySpacing;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   const nsStyleTableBorder *border = GetStyleTableBorder();
19206:   xSpacing->SetAppUnits(border->mBorderSpacingX);
19206:   ySpacing->SetAppUnits(border->mBorderSpacingY);
    1: 
    1:   return CallQueryInterface(valueList, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetCaptionSide(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleTableBorder()->mCaptionSide,
24090:                                    nsCSSProps::kCaptionSideKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetEmptyCells(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleTableBorder()->mEmptyCells,
24090:                                    nsCSSProps::kEmptyCellsKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetTableLayout(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleTable()->mLayoutStrategy,
24090:                                    nsCSSProps::kTableLayoutKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   // return null per spec.
25451:   *aValue = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderTopStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderStyleFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderBottomStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderStyleFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: nsresult
    1: nsComputedDOMStyle::GetBorderLeftStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderStyleFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRightStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderStyleFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderBottomColors(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorsFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderLeftColors(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorsFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRightColors(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorsFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderTopColors(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorsFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRadiusBottomLeft(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
20039:                          NS_CORNER_BOTTOM_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRadiusBottomRight(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
20039:                          NS_CORNER_BOTTOM_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRadiusTopLeft(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
20039:                          NS_CORNER_TOP_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRadiusTopRight(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleBorder()->mBorderRadius,
20039:                          NS_CORNER_TOP_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   // return null per spec.
25451:   *aValue = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderTopWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderWidthFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderBottomWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderWidthFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderLeftWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderWidthFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRightWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderWidthFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderTopColor(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderBottomColor(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderLeftColor(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderRightColor(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetBorderColorFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarginWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   // return null per spec.
25451:   *aValue = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarginTopWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetMarginWidthFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarginBottomWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetMarginWidthFor(NS_SIDE_BOTTOM, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarginLeftWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetMarginWidthFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarginRightWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetMarginWidthFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarkerOffset(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStyleContent()->mMarkerOffset);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutline(nsIDOMCSSValue** aValue)
    1: {
    1:   // return null per spec.
25451:   *aValue = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleOutline* outline = GetStyleOutline();
    1: 
24086:   nscoord width;
24086:   if (outline->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE) {
24086:     NS_ASSERTION(outline->GetOutlineWidth(width) && width == 0,
24086:                  "unexpected width");
24086:     width = 0;
    1:   } else {
24086: #ifdef DEBUG
24086:     PRBool res =
24086: #endif
24086:       outline->GetOutlineWidth(width);
24086:     NS_ASSERTION(res, "percent outline doesn't exist");
24086:   }
24086:   val->SetAppUnits(width);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineStyle(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleOutline()->GetOutlineStyle(),
24090:                                    nsCSSProps::kOutlineStyleKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineOffset(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
19205:   val->SetAppUnits(GetStyleOutline()->mOutlineOffset);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineRadiusBottomLeft(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
20039:                          NS_CORNER_BOTTOM_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineRadiusBottomRight(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
20039:                          NS_CORNER_BOTTOM_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineRadiusTopLeft(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
20039:                          NS_CORNER_TOP_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineRadiusTopRight(nsIDOMCSSValue** aValue)
    1: {
20039:   return GetEllipseRadii(GetStyleOutline()->mOutlineRadius,
20039:                          NS_CORNER_TOP_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOutlineColor(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nscolor color;
    1: #ifdef GFX_HAS_INVERT
    1:   GetStyleOutline()->GetOutlineColor(color);
    1: #else
    1:   if (!GetStyleOutline()->GetOutlineColor(color))
    1:     color = GetStyleColor()->mColor;
    1: #endif
    1: 
    1:   nsresult rv = SetToRGBAColor(val, color);
    1:   if (NS_FAILED(rv)) {
    1:     delete val;
    1:     return rv;
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
20039: nsComputedDOMStyle::GetEllipseRadii(const nsStyleCorners& aRadius,
20039:                                     PRUint8 aFullCorner,
20039:                                     nsIDOMCSSValue** aValue)
    1: {
20039:   const nsStyleCoord& radiusX
20039:     = aRadius.Get(NS_FULL_TO_HALF_CORNER(aFullCorner, PR_FALSE));
20039:   const nsStyleCoord& radiusY
20039:     = aRadius.Get(NS_FULL_TO_HALF_CORNER(aFullCorner, PR_TRUE));
20039:   
20039:   // for compatibility, return a single value if X and Y are equal
20039:   if (radiusX == radiusY) {
    1:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
20039:     SetValueToCoord(val, radiusX,
    1:                     &nsComputedDOMStyle::GetFrameBorderRectWidth);
    1: 
    1:     return CallQueryInterface(val, aValue);
20039:   } else {
20039:     nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
20039:     NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
20039: 
20039:     nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
20039:     if (!valX || !valueList->AppendCSSValue(valX)) {
20039:       delete valX;
20039:       delete valueList;
20039:       return NS_ERROR_OUT_OF_MEMORY;
20039:     }
20039: 
20039:     nsROCSSPrimitiveValue *valY = GetROCSSPrimitiveValue();
20039:     if (!valY || !valueList->AppendCSSValue(valY)) {
20039:       delete valY;
20039:       // valX deleted by valueList destructor
20039:       delete valueList;
20039:       return NS_ERROR_OUT_OF_MEMORY;
20039:     }
20039: 
20039:     SetValueToCoord(valX, radiusX,
20039:                     &nsComputedDOMStyle::GetFrameBorderRectWidth);
20039:     SetValueToCoord(valY, radiusY,
20039:                     &nsComputedDOMStyle::GetFrameBorderRectWidth);
20039: 
20039:     return CallQueryInterface(valueList, aValue);
20039:   }
    1: }
    1: 
    1: nsresult
15699: nsComputedDOMStyle::GetCSSShadowArray(nsCSSShadowArray* aArray,
15699:                                       const nscolor& aDefaultColor,
24818:                                       PRBool aIsBoxShadow,
15699:                                       nsIDOMCSSValue** aValue)
15699: {
15699:   if (!aArray) {
15699:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
24090:     val->SetIdent(eCSSKeyword_none);
15699:     return CallQueryInterface(val, aValue);
15699:   }
15699: 
19207:   static nscoord nsCSSShadowItem::* const shadowValuesNoSpread[] = {
15699:     &nsCSSShadowItem::mXOffset,
15699:     &nsCSSShadowItem::mYOffset,
15699:     &nsCSSShadowItem::mRadius
15699:   };
15699: 
19207:   static nscoord nsCSSShadowItem::* const shadowValuesWithSpread[] = {
15699:     &nsCSSShadowItem::mXOffset,
15699:     &nsCSSShadowItem::mYOffset,
15699:     &nsCSSShadowItem::mRadius,
15699:     &nsCSSShadowItem::mSpread
15699:   };
15699: 
19207:   nscoord nsCSSShadowItem::* const * shadowValues;
15699:   PRUint32 shadowValuesLength;
24818:   if (aIsBoxShadow) {
15699:     shadowValues = shadowValuesWithSpread;
15699:     shadowValuesLength = NS_ARRAY_LENGTH(shadowValuesWithSpread);
15699:   } else {
15699:     shadowValues = shadowValuesNoSpread;
15699:     shadowValuesLength = NS_ARRAY_LENGTH(shadowValuesNoSpread);
15699:   }
15699: 
15699:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
15699:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
15699: 
15699:   for (nsCSSShadowItem *item = aArray->ShadowAt(0),
15699:                    *item_end = item + aArray->Length();
15699:        item < item_end; ++item) {
15699:     nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
15699:     if (!itemList || !valueList->AppendCSSValue(itemList)) {
15699:       delete itemList;
15699:       delete valueList;
15699:       return NS_ERROR_OUT_OF_MEMORY;
15699:     }
15699: 
15699:     // Color is either the specified shadow color or the foreground color
15699:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
15699:     if (!val || !itemList->AppendCSSValue(val)) {
15699:       delete val;
15699:       delete valueList;
15699:       return NS_ERROR_OUT_OF_MEMORY;
15699:     }
15699:     nscolor shadowColor;
15699:     if (item->mHasColor) {
15699:       shadowColor = item->mColor;
15699:     } else {
15699:       shadowColor = aDefaultColor;
15699:     }
15699:     SetToRGBAColor(val, shadowColor);
15699: 
15699:     // Set the offsets, blur radius, and spread if available
15699:     for (PRUint32 i = 0; i < shadowValuesLength; ++i) {
15699:       val = GetROCSSPrimitiveValue();
15699:       if (!val || !itemList->AppendCSSValue(val)) {
15699:         delete val;
15699:         delete valueList;
15699:         return NS_ERROR_OUT_OF_MEMORY;
15699:       }
19207:       val->SetAppUnits(item->*(shadowValues[i]));
15699:     }
24818: 
24818:     if (item->mInset && aIsBoxShadow) {
24818:       // This is an inset box-shadow
24818:       val = GetROCSSPrimitiveValue();
24818:       if (!val || !itemList->AppendCSSValue(val)) {
24818:         delete val;
24818:         delete valueList;
24818:         return NS_ERROR_OUT_OF_MEMORY;
24818:       }
24818:       val->SetIdent(
24818:         nsCSSProps::ValueToKeywordEnum(NS_STYLE_BOX_SHADOW_INSET,
24818:                                        nsCSSProps::kBoxShadowTypeKTable));
24818:     }
15699:   }
15699: 
15699:   return CallQueryInterface(valueList, aValue);
15699: }
15699: 
15699: nsresult
15699: nsComputedDOMStyle::GetBoxShadow(nsIDOMCSSValue** aValue)
15699: {
15699:   return GetCSSShadowArray(GetStyleBorder()->mBoxShadow,
15699:                            GetStyleColor()->mColor,
15699:                            PR_TRUE, aValue);
15699: }
15699: 
15699: nsresult
    1: nsComputedDOMStyle::GetZIndex(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStylePosition()->mZIndex);
    1:     
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetListStyleImage(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleList* list = GetStyleList();
    1: 
    1:   if (!list->mListStyleImage) {
24090:     val->SetIdent(eCSSKeyword_none);
    1:   } else {
    1:     nsCOMPtr<nsIURI> uri;
    1:     if (list->mListStyleImage) {
    1:       list->mListStyleImage->GetURI(getter_AddRefs(uri));
    1:     }
    1:     val->SetURI(uri);
    1:   }
    1:     
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetListStylePosition(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleList()->mListStylePosition,
24090:                                    nsCSSProps::kListStylePositionKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetListStyleType(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleList()->mListStyleType,
24090:                                    nsCSSProps::kListStyleKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetImageRegion(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleList* list = GetStyleList();
    1: 
    1:   nsresult rv = NS_OK;
    1:   nsROCSSPrimitiveValue *topVal = nsnull;
    1:   nsROCSSPrimitiveValue *rightVal = nsnull;
    1:   nsROCSSPrimitiveValue *bottomVal = nsnull;
    1:   nsROCSSPrimitiveValue *leftVal = nsnull;
    1:   if (list->mImageRegion.width <= 0 || list->mImageRegion.height <= 0) {
24090:     val->SetIdent(eCSSKeyword_auto);
    1:   } else {
    1:     // create the cssvalues for the sides, stick them in the rect object
    1:     topVal = GetROCSSPrimitiveValue();
    1:     rightVal = GetROCSSPrimitiveValue();
    1:     bottomVal = GetROCSSPrimitiveValue();
    1:     leftVal = GetROCSSPrimitiveValue();
    1:     if (topVal && rightVal && bottomVal && leftVal) {
    1:       nsDOMCSSRect * domRect = new nsDOMCSSRect(topVal, rightVal,
    1:                                                 bottomVal, leftVal);
    1:       if (domRect) {
    1:         topVal->SetAppUnits(list->mImageRegion.y);
    1:         rightVal->SetAppUnits(list->mImageRegion.width + list->mImageRegion.x);
    1:         bottomVal->SetAppUnits(list->mImageRegion.height + list->mImageRegion.y);
    1:         leftVal->SetAppUnits(list->mImageRegion.x);
    1:         val->SetRect(domRect);
    1:       } else {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     } else {
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     delete topVal;
    1:     delete rightVal;
    1:     delete bottomVal;
    1:     delete leftVal;
    1:     delete val;
    1: 
    1:     return rv;
    1:   }
    1:   
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetLineHeight(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nscoord lineHeight;
28519:   if (GetLineHeightCoord(lineHeight)) {
    1:     val->SetAppUnits(lineHeight);
28519:   } else {
28519:     SetValueToCoord(val, GetStyleText()->mLineHeight,
28519:                     nsnull, nsCSSProps::kLineHeightKTable);
28519:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetVerticalAlign(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStyleTextReset()->mVerticalAlign,
    1:                   &nsComputedDOMStyle::GetLineHeightCoord,
    1:                   nsCSSProps::kVerticalAlignKTable);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetTextAlign(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleText()->mTextAlign,
24090:                                    nsCSSProps::kTextAlignKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetTextDecoration(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34080:   PRInt32 intValue = GetStyleTextReset()->mTextDecoration;
34080: 
34080:   if (NS_STYLE_TEXT_DECORATION_NONE == intValue) {
24090:     val->SetIdent(eCSSKeyword_none);
    1:   } else {
    1:     nsAutoString decorationString;
34163:     // Clear the -moz-anchor-decoration bit and the OVERRIDE_ALL bits -- we
34163:     // don't want these to appear in the computed style.
34163:     intValue &= ~(NS_STYLE_TEXT_DECORATION_PREF_ANCHORS |
34163:                   NS_STYLE_TEXT_DECORATION_OVERRIDE_ALL);
34080:     nsStyleUtil::AppendBitmaskCSSValue(eCSSProperty_text_decoration, intValue,
34080:                                        NS_STYLE_TEXT_DECORATION_UNDERLINE,
34080:                                        NS_STYLE_TEXT_DECORATION_BLINK,
34080:                                        decorationString);
    1:     val->SetString(decorationString);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetTextIndent(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStyleText()->mTextIndent,
    1:                   &nsComputedDOMStyle::GetCBContentWidth);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
15268: nsComputedDOMStyle::GetTextShadow(nsIDOMCSSValue** aValue)
15268: {
15699:   return GetCSSShadowArray(GetStyleText()->mTextShadow,
15699:                            GetStyleColor()->mColor,
15699:                            PR_FALSE, aValue);
15268: }
15268: 
15268: nsresult
    1: nsComputedDOMStyle::GetTextTransform(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleText()->mTextTransform,
24090:                                    nsCSSProps::kTextTransformKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
33208: nsComputedDOMStyle::GetMozTabSize(nsIDOMCSSValue** aValue)
33208: {
33208:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
33208:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
33208: 
33208:   val->SetNumber(GetStyleText()->mTabSize);
33208:     
33208:   return CallQueryInterface(val, aValue);
33208: }
33208: 
33208: nsresult
    1: nsComputedDOMStyle::GetLetterSpacing(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStyleText()->mLetterSpacing);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetWordSpacing(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
23137:   val->SetAppUnits(GetStyleText()->mWordSpacing);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetWhiteSpace(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleText()->mWhiteSpace,
24090:                                    nsCSSProps::kWhitespaceKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
20464: nsComputedDOMStyle::GetWindowShadow(nsIDOMCSSValue** aValue)
20464: {
20464:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
20464:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
20464: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleUIReset()->mWindowShadow,
24090:                                    nsCSSProps::kWindowShadowKTable));
20464: 
20464:   return CallQueryInterface(val, aValue);
20464: }
20464: 
20464: 
20464: nsresult
16166: nsComputedDOMStyle::GetWordWrap(nsIDOMCSSValue** aValue)
16166: {
16166:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
16166:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
16166: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleText()->mWordWrap,
24090:                                    nsCSSProps::kWordwrapKTable));
16166: 
16166:   return CallQueryInterface(val, aValue);
16166: }
16166: 
16166: nsresult
32021: nsComputedDOMStyle::GetPointerEvents(nsIDOMCSSValue** aValue)
32021: {
32021:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
32021:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
32021:   
34080:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleVisibility()->mPointerEvents,
32021:                                    nsCSSProps::kPointerEventsKTable));
32021:   return CallQueryInterface(val, aValue);
32021: }
32021: 
32021: nsresult
    1: nsComputedDOMStyle::GetVisibility(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleVisibility()->mVisible,
24090:                                                nsCSSProps::kVisibilityKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetDirection(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleVisibility()->mDirection,
24090:                                    nsCSSProps::kDirectionKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetUnicodeBidi(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleTextReset()->mUnicodeBidi,
24090:                                    nsCSSProps::kUnicodeBidiKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetCursor(nsIDOMCSSValue** aValue)
    1: {
    1:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
    1:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleUserInterface *ui = GetStyleUserInterface();
    1: 
    1:   for (nsCursorImage *item = ui->mCursorArray,
    1:          *item_end = ui->mCursorArray + ui->mCursorArrayLength;
    1:        item < item_end; ++item) {
    1:     nsDOMCSSValueList *itemList = GetROCSSValueList(PR_FALSE);
    1:     if (!itemList || !valueList->AppendCSSValue(itemList)) {
    1:       delete itemList;
    1:       delete valueList;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     item->mImage->GetURI(getter_AddRefs(uri));
    1: 
    1:     nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:     if (!val || !itemList->AppendCSSValue(val)) {
    1:       delete val;
    1:       delete valueList;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     val->SetURI(uri);
    1: 
    1:     if (item->mHaveHotspot) {
    1:       nsROCSSPrimitiveValue *valX = GetROCSSPrimitiveValue();
    1:       if (!valX || !itemList->AppendCSSValue(valX)) {
    1:         delete valX;
    1:         delete valueList;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:       nsROCSSPrimitiveValue *valY = GetROCSSPrimitiveValue();
    1:       if (!valY || !itemList->AppendCSSValue(valY)) {
    1:         delete valY;
    1:         delete valueList;
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       valX->SetNumber(item->mHotspotX);
    1:       valY->SetNumber(item->mHotspotY);
    1:     }
    1:   }
    1: 
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   if (!val) {
    1:     delete valueList;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
34082:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(ui->mCursor,
24090:                                                nsCSSProps::kCursorKTable));
    1:   if (!valueList->AppendCSSValue(val)) {
    1:     delete valueList;
    1:     delete val;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return CallQueryInterface(valueList, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetAppearance(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mAppearance,
24090:                                                nsCSSProps::kAppearanceKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxAlign(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxAlign,
24090:                                                nsCSSProps::kBoxAlignKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxDirection(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxDirection,
24090:                                    nsCSSProps::kBoxDirectionKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxFlex(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   val->SetNumber(GetStyleXUL()->mBoxFlex);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxOrdinalGroup(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   val->SetNumber(GetStyleXUL()->mBoxOrdinal);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxOrient(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxOrient,
24090:                                    nsCSSProps::kBoxOrientKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxPack(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleXUL()->mBoxPack,
24090:                                                nsCSSProps::kBoxPackKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBoxSizing(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStylePosition()->mBoxSizing,
24090:                                    nsCSSProps::kBoxSizingKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
15992: nsComputedDOMStyle::GetBorderImage(nsIDOMCSSValue** aValue)
15992: {
15992:   const nsStyleBorder* border = GetStyleBorder();
15992:   
15992:   // none
15992:   if (!border->GetBorderImage()) {
15992:     nsROCSSPrimitiveValue *valNone = GetROCSSPrimitiveValue();
15992:     NS_ENSURE_TRUE(valNone, NS_ERROR_OUT_OF_MEMORY);
24090:     valNone->SetIdent(eCSSKeyword_none);
15992:     return CallQueryInterface(valNone, aValue);
15992:   }
15992:   
15992:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
15992:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
15992:   
15992:   // uri
15992:   nsROCSSPrimitiveValue *valURI = GetROCSSPrimitiveValue();
15992:   if (!valURI || !valueList->AppendCSSValue(valURI)) {
15992:     delete valURI;
15992:     delete valueList;
15992:     return NS_ERROR_OUT_OF_MEMORY;
15992:   }
15992:   nsCOMPtr<nsIURI> uri;
15992:   border->GetBorderImage()->GetURI(getter_AddRefs(uri));
15992:   valURI->SetURI(uri);
15992:   
15992:   // four split numbers
15992:   NS_FOR_CSS_SIDES(side) {
15992:     nsROCSSPrimitiveValue *valSplit = GetROCSSPrimitiveValue();
15992:     if (!valSplit || !valueList->AppendCSSValue(valSplit)) {
15992:       delete valSplit;
15992:       delete valueList;
15992:       return NS_ERROR_OUT_OF_MEMORY;
15992:     }
15992:     SetValueToCoord(valSplit, border->mBorderImageSplit.Get(side), nsnull,
15992:                     nsnull);
15992:   }
15992:   
15992:   // copy of border-width
15992:   if (border->mHaveBorderImageWidth) {
15992:     nsROCSSPrimitiveValue *slash = GetROCSSPrimitiveValue();
15992:     if (!slash || !valueList->AppendCSSValue(slash)) {
15992:       delete slash;
15992:       delete valueList;
15992:       return NS_ERROR_OUT_OF_MEMORY;
15992:     }
15992:     slash->SetString(NS_LITERAL_STRING("/"));
15992:     NS_FOR_CSS_SIDES(side) {
15992:       nsROCSSPrimitiveValue *borderWidth = GetROCSSPrimitiveValue();
15992:       if (!borderWidth || !valueList->AppendCSSValue(borderWidth)) {
15992:         delete borderWidth;
15992:         delete valueList;
15992:         return NS_ERROR_OUT_OF_MEMORY;
15992:       }
15992:       nscoord width = GetStyleBorder()->mBorderImageWidth.side(side);
15992:       borderWidth->SetAppUnits(width);
15992:     }
15992:   }
15992:   
15992:   // first keyword
15992:   nsROCSSPrimitiveValue *keyword = GetROCSSPrimitiveValue();
15992:   if (!keyword || !valueList->AppendCSSValue(keyword)) {
15992:     delete keyword;
15992:     delete valueList;
15992:     return NS_ERROR_OUT_OF_MEMORY;
15992:   }
24090:   keyword->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->mBorderImageHFill,
24090:                                    nsCSSProps::kBorderImageKTable));
15992:   
15992:   // second keyword
15992:   nsROCSSPrimitiveValue *keyword2 = GetROCSSPrimitiveValue();
15992:   if (!keyword2 || !valueList->AppendCSSValue(keyword2)) {
15992:     delete keyword2;
15992:     delete valueList;
15992:     return NS_ERROR_OUT_OF_MEMORY;
15992:   }
24090:   keyword2->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->mBorderImageVFill,
24090:                                    nsCSSProps::kBorderImageKTable));
15992:   
15992:   return CallQueryInterface(valueList, aValue);
15992: }
15992: 
15992: nsresult
    1: nsComputedDOMStyle::GetFloatEdge(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->mFloatEdge,
24090:                                    nsCSSProps::kFloatEdgeKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
 1520: nsresult
 3750: nsComputedDOMStyle::GetForceBrokenImageIcon(nsIDOMCSSValue** aValue)
 3750: {
 3750:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3750:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3750: 
 3750:   val->SetNumber(GetStyleUIReset()->mForceBrokenImageIcon);
 3750: 
 3750:   return CallQueryInterface(val, aValue);
 3750: }
 3750: 
 3750: nsresult
 1520: nsComputedDOMStyle::GetIMEMode(nsIDOMCSSValue** aValue)
 1520: {
 1520:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 1520:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 1520: 
34082:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleUIReset()->mIMEMode,
34082:                                    nsCSSProps::kIMEModeKTable));
 1520: 
 1520:   return CallQueryInterface(val, aValue);
 1520: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetUserFocus(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleUserInterface()->mUserFocus,
24090:                                    nsCSSProps::kUserFocusKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetUserInput(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleUserInterface()->mUserInput,
24090:                                    nsCSSProps::kUserInputKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetUserModify(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleUserInterface()->mUserModify,
24090:                                    nsCSSProps::kUserModifyKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetUserSelect(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleUIReset()->mUserSelect,
24090:                                    nsCSSProps::kUserSelectKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetDisplay(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34080:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mDisplay,
24090:                                                nsCSSProps::kDisplayKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetPosition(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mPosition,
24090:                                                nsCSSProps::kPositionKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetClip(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStyleDisplay* display = GetStyleDisplay();
    1: 
    1:   nsresult rv = NS_OK;
    1:   nsROCSSPrimitiveValue *topVal = nsnull;
    1:   nsROCSSPrimitiveValue *rightVal = nsnull;
    1:   nsROCSSPrimitiveValue *bottomVal = nsnull;
    1:   nsROCSSPrimitiveValue *leftVal = nsnull;
23173:   if (display->mClipFlags == NS_STYLE_CLIP_AUTO) {
24090:     val->SetIdent(eCSSKeyword_auto);
    1:   } else {
    1:     // create the cssvalues for the sides, stick them in the rect object
    1:     topVal = GetROCSSPrimitiveValue();
    1:     rightVal = GetROCSSPrimitiveValue();
    1:     bottomVal = GetROCSSPrimitiveValue();
    1:     leftVal = GetROCSSPrimitiveValue();
    1:     if (topVal && rightVal && bottomVal && leftVal) {
    1:       nsDOMCSSRect * domRect = new nsDOMCSSRect(topVal, rightVal,
    1:                                                 bottomVal, leftVal);
    1:       if (domRect) {
    1:         if (display->mClipFlags & NS_STYLE_CLIP_TOP_AUTO) {
24090:           topVal->SetIdent(eCSSKeyword_auto);
    1:         } else {
    1:           topVal->SetAppUnits(display->mClip.y);
    1:         }
    1:         
    1:         if (display->mClipFlags & NS_STYLE_CLIP_RIGHT_AUTO) {
24090:           rightVal->SetIdent(eCSSKeyword_auto);
    1:         } else {
    1:           rightVal->SetAppUnits(display->mClip.width + display->mClip.x);
    1:         }
    1:         
    1:         if (display->mClipFlags & NS_STYLE_CLIP_BOTTOM_AUTO) {
24090:           bottomVal->SetIdent(eCSSKeyword_auto);
    1:         } else {
    1:           bottomVal->SetAppUnits(display->mClip.height + display->mClip.y);
    1:         }
    1:         
    1:         if (display->mClipFlags & NS_STYLE_CLIP_LEFT_AUTO) {
24090:           leftVal->SetIdent(eCSSKeyword_auto);
    1:         } else {
    1:           leftVal->SetAppUnits(display->mClip.x);
    1:         }
    1: 
    1:         val->SetRect(domRect);
    1:       } else {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     } else {
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     delete topVal;
    1:     delete rightVal;
    1:     delete bottomVal;
    1:     delete leftVal;
    1:     delete val;
    1: 
    1:     return rv;
    1:   }
    1:   
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOverflow(nsIDOMCSSValue** aValue)
    1: {
    1:   const nsStyleDisplay* display = GetStyleDisplay();
    1: 
    1:   if (display->mOverflowX != display->mOverflowY) {
    1:     // No value to return.  We can't express this combination of
    1:     // values as a shorthand.
    1:     *aValue = nsnull;
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(display->mOverflowX,
24090:                                                nsCSSProps::kOverflowKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOverflowX(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34081:   val->SetIdent(
34081:     nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mOverflowX,
34081:                                    nsCSSProps::kOverflowSubKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOverflowY(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34081:   val->SetIdent(
34081:     nsCSSProps::ValueToKeywordEnum(GetStyleDisplay()->mOverflowY,
34081:                                    nsCSSProps::kOverflowSubKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
 3750: nsComputedDOMStyle::GetPageBreakAfter(nsIDOMCSSValue** aValue)
 3750: {
 3750:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3750:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3750: 
 3750:   const nsStyleDisplay *display = GetStyleDisplay();
 3750: 
 3750:   if (display->mBreakAfter) {
24090:     val->SetIdent(eCSSKeyword_always);
 3750:   } else {
24090:     val->SetIdent(eCSSKeyword_auto);
 3750:   }
 3750: 
 3750:   return CallQueryInterface(val, aValue);
 3750: }
 3750: 
 3750: nsresult
 3750: nsComputedDOMStyle::GetPageBreakBefore(nsIDOMCSSValue** aValue)
 3750: {
 3750:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3750:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3750: 
 3750:   const nsStyleDisplay *display = GetStyleDisplay();
 3750: 
 3750:   if (display->mBreakBefore) {
24090:     val->SetIdent(eCSSKeyword_always);
 3750:   } else {
24090:     val->SetIdent(eCSSKeyword_auto);
 3750:   }
 3750: 
 3750:   return CallQueryInterface(val, aValue);
 3750: }
 3750: 
 3750: nsresult
    1: nsComputedDOMStyle::GetHeight(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   PRBool calcHeight = PR_FALSE;
    1:   
10950:   if (mInnerFrame) {
    1:     calcHeight = PR_TRUE;
    1: 
    1:     const nsStyleDisplay* displayData = GetStyleDisplay();
    1:     if (displayData->mDisplay == NS_STYLE_DISPLAY_INLINE &&
10950:         !(mInnerFrame->IsFrameOfType(nsIFrame::eReplaced))) {
    1:       calcHeight = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   if (calcHeight) {
25450:     AssertFlushedPendingReflows();
    1:   
10950:     val->SetAppUnits(mInnerFrame->GetContentRect().height);
    1:   } else {
  722:     const nsStylePosition *positionData = GetStylePosition();
  722: 
  722:     nscoord minHeight =
  722:       StyleCoordToNSCoord(positionData->mMinHeight,
  722:                           &nsComputedDOMStyle::GetCBContentHeight, 0);
  722: 
  722:     nscoord maxHeight =
  722:       StyleCoordToNSCoord(positionData->mMaxHeight,
  722:                           &nsComputedDOMStyle::GetCBContentHeight,
  722:                           nscoord_MAX);
  722:     
  722:     SetValueToCoord(val, positionData->mHeight, nsnull, nsnull,
  722:                     minHeight, maxHeight);
    1:   }
    1:   
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   PRBool calcWidth = PR_FALSE;
    1: 
10950:   if (mInnerFrame) {
    1:     calcWidth = PR_TRUE;
    1: 
    1:     const nsStyleDisplay *displayData = GetStyleDisplay();
    1:     if (displayData->mDisplay == NS_STYLE_DISPLAY_INLINE &&
10950:         !(mInnerFrame->IsFrameOfType(nsIFrame::eReplaced))) {
    1:       calcWidth = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   if (calcWidth) {
25450:     AssertFlushedPendingReflows();
    1: 
10950:     val->SetAppUnits(mInnerFrame->GetContentRect().width);
    1:   } else {
  722:     const nsStylePosition *positionData = GetStylePosition();
  722: 
  722:     nscoord minWidth =
  722:       StyleCoordToNSCoord(positionData->mMinWidth,
  722:                           &nsComputedDOMStyle::GetCBContentWidth, 0);
  722: 
  722:     nscoord maxWidth =
  722:       StyleCoordToNSCoord(positionData->mMaxWidth,
  722:                           &nsComputedDOMStyle::GetCBContentWidth,
  722:                           nscoord_MAX);
  722:     
 1068:     SetValueToCoord(val, positionData->mWidth, nsnull,
 1068:                     nsCSSProps::kWidthKTable, minWidth, maxWidth);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMaxHeight(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
  722:   SetValueToCoord(val, GetStylePosition()->mMaxHeight,
    1:                   &nsComputedDOMStyle::GetCBContentHeight);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMaxWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
  722:   SetValueToCoord(val, GetStylePosition()->mMaxWidth,
 1068:                   &nsComputedDOMStyle::GetCBContentWidth,
 1068:                   nsCSSProps::kWidthKTable);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMinHeight(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStylePosition()->mMinHeight,
    1:                   &nsComputedDOMStyle::GetCBContentHeight);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMinWidth(nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   SetValueToCoord(val, GetStylePosition()->mMinWidth,
 1068:                   &nsComputedDOMStyle::GetCBContentWidth,
 1068:                   nsCSSProps::kWidthKTable);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetLeft(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetOffsetWidthFor(NS_SIDE_LEFT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetRight(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetOffsetWidthFor(NS_SIDE_RIGHT, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetTop(nsIDOMCSSValue** aValue)
    1: {
    1:   return GetOffsetWidthFor(NS_SIDE_TOP, aValue);
    1: }
    1: 
    1: nsROCSSPrimitiveValue*
    1: nsComputedDOMStyle::GetROCSSPrimitiveValue()
    1: {
    1:   nsROCSSPrimitiveValue *primitiveValue = new nsROCSSPrimitiveValue(mAppUnitsPerInch);
    1: 
    1:   NS_ASSERTION(primitiveValue != 0, "ran out of memory");
    1: 
    1:   return primitiveValue;
    1: }
    1: 
    1: nsDOMCSSValueList*
    1: nsComputedDOMStyle::GetROCSSValueList(PRBool aCommaDelimited)
    1: {
    1:   nsDOMCSSValueList *valueList = new nsDOMCSSValueList(aCommaDelimited,
    1:                                                        PR_TRUE);
    1:   NS_ASSERTION(valueList != 0, "ran out of memory");
    1: 
    1:   return valueList;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetOffsetWidthFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   const nsStyleDisplay* display = GetStyleDisplay();
    1: 
25450:   AssertFlushedPendingReflows();
    1: 
    1:   nsresult rv = NS_OK;
    1:   switch (display->mPosition) {
    1:     case NS_STYLE_POSITION_STATIC:
    1:       rv = GetStaticOffset(aSide, aValue);
    1:       break;
    1:     case NS_STYLE_POSITION_RELATIVE:
    1:       rv = GetRelativeOffset(aSide, aValue);
    1:       break;
    1:     case NS_STYLE_POSITION_ABSOLUTE:
    1:     case NS_STYLE_POSITION_FIXED:
    1:       rv = GetAbsoluteOffset(aSide, aValue);
    1:       break;
    1:     default:
    1:       NS_ERROR("Invalid position");
    1:       break;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetAbsoluteOffset(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
10950:   nsIFrame* container = GetContainingBlockFor(mOuterFrame);
    1:   if (container) {
10950:     nsMargin margin = mOuterFrame->GetUsedMargin();
    1:     nsMargin border = container->GetUsedBorder();
    1:     nsMargin scrollbarSizes(0, 0, 0, 0);
10950:     nsRect rect = mOuterFrame->GetRect();
    1:     nsRect containerRect = container->GetRect();
    1:       
    1:     if (container->GetType() == nsGkAtoms::viewportFrame) {
    1:       // For absolutely positioned frames scrollbars are taken into
    1:       // account by virtue of getting a containing block that does
    1:       // _not_ include the scrollbars.  For fixed positioned frames,
    1:       // the containing block is the viewport, which _does_ include
    1:       // scrollbars.  We have to do some extra work.
    1:       // the first child in the default frame list is what we want
    1:       nsIFrame* scrollingChild = container->GetFirstChild(nsnull);
23554:       nsIScrollableFrame *scrollFrame = do_QueryFrame(scrollingChild);
    1:       if (scrollFrame) {
    1:         scrollbarSizes = scrollFrame->GetActualScrollbarSizes();
    1:       }
    1:     }
    1: 
    1:     nscoord offset = 0;
    1:     switch (aSide) {
    1:       case NS_SIDE_TOP:
    1:         offset = rect.y - margin.top - border.top - scrollbarSizes.top;
    1: 
    1:         break;
    1:       case NS_SIDE_RIGHT:
    1:         offset = containerRect.width - rect.width -
    1:           rect.x - margin.right - border.right - scrollbarSizes.right;
    1: 
    1:         break;
    1:       case NS_SIDE_BOTTOM:
    1:         offset = containerRect.height - rect.height -
    1:           rect.y - margin.bottom - border.bottom - scrollbarSizes.bottom;
    1: 
    1:         break;
    1:       case NS_SIDE_LEFT:
    1:         offset = rect.x - margin.left - border.left - scrollbarSizes.left;
    1: 
    1:         break;
    1:       default:
    1:         NS_ERROR("Invalid side");
    1:         break;
    1:     }
    1:     val->SetAppUnits(offset);
    1:   } else {
    1:     // XXX no frame.  This property makes no sense
    1:     val->SetAppUnits(0);
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: 
    1: #if (NS_SIDE_TOP == 0) && (NS_SIDE_RIGHT == 1) && (NS_SIDE_BOTTOM == 2) && (NS_SIDE_LEFT == 3)
    1: #define NS_OPPOSITE_SIDE(s_) (((s_) + 2) & 3)
    1: #else
    1: #error "Somebody changed the side constants."
    1: #endif
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetRelativeOffset(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   const nsStylePosition* positionData = GetStylePosition();
    1:   PRInt32 sign = 1;
12630:   nsStyleCoord coord = positionData->mOffset.Get(aSide);
 4739: 
 4739:   NS_ASSERTION(coord.GetUnit() == eStyleUnit_Coord ||
 4739:                coord.GetUnit() == eStyleUnit_Percent ||
 4739:                coord.GetUnit() == eStyleUnit_Auto,
 4739:                "Unexpected unit");
 4739:   
 4739:   if (coord.GetUnit() == eStyleUnit_Auto) {
12630:     coord = positionData->mOffset.Get(NS_OPPOSITE_SIDE(aSide));
    1:     sign = -1;
    1:   }
 4739:   PercentageBaseGetter baseGetter;
    1:   if (aSide == NS_SIDE_LEFT || aSide == NS_SIDE_RIGHT) {
 4739:     baseGetter = &nsComputedDOMStyle::GetCBContentWidth;
    1:   } else {
 4739:     baseGetter = &nsComputedDOMStyle::GetCBContentHeight;
 4739:   }
 4739: 
 4739:   val->SetAppUnits(sign * StyleCoordToNSCoord(coord, baseGetter, 0));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetStaticOffset(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: 
    1: {
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
12630:   SetValueToCoord(val, GetStylePosition()->mOffset.Get(aSide));
    1:   
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetPaddingWidthFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
10950:   if (!mInnerFrame) {
12630:     SetValueToCoord(val, GetStylePadding()->mPadding.Get(aSide));
    1:   } else {
25450:     AssertFlushedPendingReflows();
    1:   
10950:     val->SetAppUnits(mInnerFrame->GetUsedPadding().side(aSide));
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: PRBool
    1: nsComputedDOMStyle::GetLineHeightCoord(nscoord& aCoord)
    1: {
28519:   AssertFlushedPendingReflows();
28519: 
28519:   nscoord blockHeight = NS_AUTOHEIGHT;
28519:   if (GetStyleText()->mLineHeight.GetUnit() == eStyleUnit_Enumerated) {
28519:     if (!mInnerFrame)
28519:       return PR_FALSE;
28519: 
28519:     if (mInnerFrame->IsContainingBlock()) {
28519:       blockHeight = mInnerFrame->GetContentRect().height;
28519:     } else {
28519:       GetCBContentHeight(blockHeight);
28519:     }
28519:   }
28519: 
28519:   aCoord = nsHTMLReflowState::CalcLineHeight(mStyleContextHolder,
28519:                                              blockHeight);
 5256:   
 1102:   // CalcLineHeight uses font->mFont.size, but we want to use
 1102:   // font->mSize as the font size.  Adjust for that.  Also adjust for
 1102:   // the text zoom, if any.
    1:   const nsStyleFont* font = GetStyleFont();
 1102:   aCoord = NSToCoordRound((float(aCoord) *
 1102:                            (float(font->mSize) / float(font->mFont.size))) /
 1102:                           mPresShell->GetPresContext()->TextZoom());
 1102:   
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderColorsFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   const nsStyleBorder *border = GetStyleBorder();
    1: 
    1:   if (border->mBorderColors) {
    1:     nsBorderColors* borderColors = border->mBorderColors[aSide];
    1:     if (borderColors) {
    1:       nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
    1:       NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       do {
    1:         nsROCSSPrimitiveValue *primitive = GetROCSSPrimitiveValue();
    1:         if (!primitive) {
    1:           delete valueList;
    1: 
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:         nsresult rv = SetToRGBAColor(primitive, borderColors->mColor);
    1:         if (NS_FAILED(rv)) {
    1:           delete valueList;
    1:           delete primitive;
    1:           return rv;
    1:         }
    1: 
    1:         PRBool success = valueList->AppendCSSValue(primitive);
    1:         if (!success) {
    1:           delete valueList;
    1:           delete primitive;
    1: 
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:         borderColors = borderColors->mNext;
    1:       } while (borderColors);
    1: 
    1:       return CallQueryInterface(valueList, aValue);
    1:     }
    1:   }
    1: 
    1:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
24090:   val->SetIdent(eCSSKeyword_none);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderWidthFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nscoord width;
10950:   if (mInnerFrame) {
25450:     AssertFlushedPendingReflows();
10950:     width = mInnerFrame->GetUsedBorder().side(aSide);
    1:   } else {
15992:     width = GetStyleBorder()->GetActualBorderWidth(aSide);
    1:   }
    1:   val->SetAppUnits(width);
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderColorFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nscolor color; 
    1:   PRBool foreground;
19182:   GetStyleBorder()->GetBorderColor(aSide, color, foreground);
    1:   if (foreground) {
19182:     color = GetStyleColor()->mColor;
19182:   }
    1: 
    1:   nsresult rv = SetToRGBAColor(val, color);
    1:   if (NS_FAILED(rv)) {
    1:     delete val;
    1:     return rv;
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetMarginWidthFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
10950:   if (!mInnerFrame) {
12630:     SetValueToCoord(val, GetStyleMargin()->mMargin.Get(aSide));
    1:   } else {
25450:     AssertFlushedPendingReflows();
    1: 
10950:     val->SetAppUnits(mInnerFrame->GetUsedMargin().side(aSide));
    1:   }
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: nsresult
    1: nsComputedDOMStyle::GetBorderStyleFor(PRUint8 aSide, nsIDOMCSSValue** aValue)
    1: {
    1:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
    1:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
    1: 
34082:   val->SetIdent(
34082:     nsCSSProps::ValueToKeywordEnum(GetStyleBorder()->GetBorderStyle(aSide),
34082:                                    nsCSSProps::kBorderStyleKTable));
    1: 
    1:   return CallQueryInterface(val, aValue);
    1: }
    1: 
    1: void
    1: nsComputedDOMStyle::SetValueToCoord(nsROCSSPrimitiveValue* aValue,
  722:                                     const nsStyleCoord& aCoord,
    1:                                     PercentageBaseGetter aPercentageBaseGetter,
    1:                                     const PRInt32 aTable[],
  722:                                     nscoord aMinAppUnits,
  722:                                     nscoord aMaxAppUnits)
    1: {
    1:   NS_PRECONDITION(aValue, "Must have a value to work with");
    1:   
    1:   switch (aCoord.GetUnit()) {
    1:     case eStyleUnit_Normal:
24090:       aValue->SetIdent(eCSSKeyword_normal);
    1:       break;
    1:       
    1:     case eStyleUnit_Auto:
24090:       aValue->SetIdent(eCSSKeyword_auto);
    1:       break;
    1:       
    1:     case eStyleUnit_Percent:
    1:       {
    1:         nscoord percentageBase;
    1:         if (aPercentageBaseGetter &&
    1:             (this->*aPercentageBaseGetter)(percentageBase)) {
    1:           nscoord val = nscoord(aCoord.GetPercentValue() * percentageBase);
32531:           aValue->SetAppUnits(NS_MAX(aMinAppUnits, NS_MIN(val, aMaxAppUnits)));
    1:         } else {
    1:           aValue->SetPercent(aCoord.GetPercentValue());
    1:         }
    1:       }
    1:       break;
    1:       
    1:     case eStyleUnit_Factor:
    1:       aValue->SetNumber(aCoord.GetFactorValue());
    1:       break;
    1:       
    1:     case eStyleUnit_Coord:
    1:       {
    1:         nscoord val = aCoord.GetCoordValue();
32531:         aValue->SetAppUnits(NS_MAX(aMinAppUnits, NS_MIN(val, aMaxAppUnits)));
    1:       }
    1:       break;
    1:       
    1:     case eStyleUnit_Integer:
23032:       aValue->SetNumber(aCoord.GetIntValue());
    1:       break;
    1:       
    1:     case eStyleUnit_Enumerated:
    1:       NS_ASSERTION(aTable, "Must have table to handle this case");
24090:       aValue->SetIdent(nsCSSProps::ValueToKeywordEnum(aCoord.GetIntValue(),
    1:                                                       aTable));
    1:       break;
    1:       
 1363:     case eStyleUnit_None:
24090:       aValue->SetIdent(eCSSKeyword_none);
    1:       break;
    1:       
    1:     default:
    1:       NS_ERROR("Can't handle this unit");
    1:       break;
    1:   }
    1: }
    1: 
    1: nscoord
  722: nsComputedDOMStyle::StyleCoordToNSCoord(const nsStyleCoord& aCoord,
  722:                                         PercentageBaseGetter aPercentageBaseGetter,
  722:                                         nscoord aDefaultValue)
    1: {
    1:   NS_PRECONDITION(aPercentageBaseGetter, "Must have a percentage base getter");
    1:   switch (aCoord.GetUnit()) {
    1:     case eStyleUnit_Coord:
    1:       return aCoord.GetCoordValue();
    1:     case eStyleUnit_Percent:
    1:       {
    1:         nscoord percentageBase;
    1:         if ((this->*aPercentageBaseGetter)(percentageBase)) {
    1:           return nscoord(aCoord.GetPercentValue() * percentageBase);
    1:         }
    1:       }
  722:       // Fall through to returning aDefaultValue if we have no percentage base.
    1:     default:
    1:       break;
    1:   }
    1:       
  722:   return aDefaultValue;
    1: }
    1: 
    1: PRBool
    1: nsComputedDOMStyle::GetCBContentWidth(nscoord& aWidth)
    1: {
10950:   if (!mOuterFrame) {
    1:     return PR_FALSE;
    1:   }
    1: 
10950:   nsIFrame* container = GetContainingBlockFor(mOuterFrame);
    1:   if (!container) {
    1:     return PR_FALSE;
    1:   }
    1: 
25450:   AssertFlushedPendingReflows();
    1: 
    1:   aWidth = container->GetContentRect().width;
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsComputedDOMStyle::GetCBContentHeight(nscoord& aHeight)
    1: {
10950:   if (!mOuterFrame) {
    1:     return PR_FALSE;
    1:   }
    1: 
10950:   nsIFrame* container = GetContainingBlockFor(mOuterFrame);
    1:   if (!container) {
    1:     return PR_FALSE;
    1:   }
    1: 
25450:   AssertFlushedPendingReflows();
    1: 
    1:   aHeight = container->GetContentRect().height;
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsComputedDOMStyle::GetFrameBorderRectWidth(nscoord& aWidth)
    1: {
10950:   if (!mInnerFrame) {
    1:     return PR_FALSE;
    1:   }
    1: 
25450:   AssertFlushedPendingReflows();
    1: 
10950:   aWidth = mInnerFrame->GetSize().width;
    1:   return PR_TRUE;
    1: }
    1: 
19214: PRBool
19214: nsComputedDOMStyle::GetFrameBoundsWidthForTransform(nscoord& aWidth)
19214: {
19214:   // We need a frame to work with.
19214:   if (!mInnerFrame) {
19214:     return PR_FALSE;
19214:   }
19214: 
25450:   AssertFlushedPendingReflows();
19214: 
19214:   // Check to see that we're transformed.
19214:   if (!mInnerFrame->GetStyleDisplay()->HasTransform())
19214:     return PR_FALSE;
19214: 
19214:   aWidth = nsDisplayTransform::GetFrameBoundsForTransform(mInnerFrame).width;
19214:   return PR_TRUE;
19214: }
19214: 
19214: PRBool
19214: nsComputedDOMStyle::GetFrameBoundsHeightForTransform(nscoord& aHeight)
19214: {
19214:   // We need a frame to work with.
19214:   if (!mInnerFrame) {
19214:     return PR_FALSE;
19214:   }
19214: 
25450:   AssertFlushedPendingReflows();
19214: 
19214:   // Check to see that we're transformed.
19214:   if (!mInnerFrame->GetStyleDisplay()->HasTransform())
19214:     return PR_FALSE;
19214: 
19214:   aHeight = nsDisplayTransform::GetFrameBoundsForTransform(mInnerFrame).height;
19214:   return PR_TRUE;
19214: }
19214: 
 3735: #ifdef MOZ_SVG
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetSVGPaintFor(PRBool aFill,
 3735:                                    nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVG* svg = GetStyleSVG();
 3735:   const nsStyleSVGPaint* paint = nsnull;
 3735: 
 3735:   if (aFill)
 3735:     paint = &svg->mFill;
 3735:   else
 3735:     paint = &svg->mStroke;
 3735: 
 3735:   nsAutoString paintString;
 3735: 
 3735:   switch (paint->mType) {
 3735:   case eStyleSVGPaintType_None:
 3735:   {
24090:     val->SetIdent(eCSSKeyword_none);
 3735:     break;
 3735:   }
 3735:   case eStyleSVGPaintType_Color:
 3735:   {
 3735:     nsresult rv = SetToRGBAColor(val, paint->mPaint.mColor);
 3735:     if (NS_FAILED(rv)) {
 3735:       delete val;
 3735:       return rv;
 3735:     }
 3735:     break;
 3735:   }
 3735:   case eStyleSVGPaintType_Server:
 3735:   {
 3735:     nsDOMCSSValueList *valueList = GetROCSSValueList(PR_FALSE);
 3735:     NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:     if (!valueList->AppendCSSValue(val)) {
 3735:       delete valueList;
 3735:       delete val;
 3735:       return NS_ERROR_OUT_OF_MEMORY;
 3735:     }
 3735: 
 3735:     nsROCSSPrimitiveValue* fallback = GetROCSSPrimitiveValue();
 3735:     if (!fallback || !valueList->AppendCSSValue(fallback)) {
 3735:       delete valueList;
 3735:       delete fallback;
 3735:       return NS_ERROR_OUT_OF_MEMORY;
 3735:     }
 3735: 
 3735:     val->SetURI(paint->mPaint.mPaintServer);
 3735:     nsresult rv = SetToRGBAColor(fallback, paint->mFallbackColor);
 3735:     if (NS_FAILED(rv)) {
 3735:       delete valueList;
 3735:       return rv;
 3735:     }
 3735: 
 3735:     return CallQueryInterface(valueList, aValue);
 3735:   }
 3735:   }
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetFill(nsIDOMCSSValue** aValue)
 3735: {
 3735:   return GetSVGPaintFor(PR_TRUE, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStroke(nsIDOMCSSValue** aValue)
 3735: {
 3735:   return GetSVGPaintFor(PR_FALSE, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetMarkerEnd(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVG* svg = GetStyleSVG();
 3735: 
 3735:   if (svg->mMarkerEnd)
 3735:     val->SetURI(svg->mMarkerEnd);
 3735:   else
24090:     val->SetIdent(eCSSKeyword_none);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetMarkerMid(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVG* svg = GetStyleSVG();
 3735: 
 3735:   if (svg->mMarkerMid)
 3735:     val->SetURI(svg->mMarkerMid);
 3735:   else
24090:     val->SetIdent(eCSSKeyword_none);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetMarkerStart(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVG* svg = GetStyleSVG();
 3735: 
 3735:   if (svg->mMarkerStart)
 3735:     val->SetURI(svg->mMarkerStart);
 3735:   else
24090:     val->SetIdent(eCSSKeyword_none);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeDasharray(nsIDOMCSSValue** aValue)
 3735: {
 3735:   const nsStyleSVG* svg = GetStyleSVG();
 3735: 
 3735:   if (!svg->mStrokeDasharrayLength || !svg->mStrokeDasharray) {
 3735:     nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:     NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
24090:     val->SetIdent(eCSSKeyword_none);
 3735:     return CallQueryInterface(val, aValue);
 3735:   }
 3735: 
 3735:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
 3735:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   for (PRUint32 i = 0; i < svg->mStrokeDasharrayLength; i++) {
 3735:     nsROCSSPrimitiveValue* dash = GetROCSSPrimitiveValue();
 3735:     if (!dash || !valueList->AppendCSSValue(dash)) {
 3735:       delete valueList;
 3735:       delete dash;
 3735:       return NS_ERROR_OUT_OF_MEMORY;
 3735:     }
 3735: 
 3735:     SetValueToCoord(dash, svg->mStrokeDasharray[i]);
 3735:   }
 3735: 
 3735:   return CallQueryInterface(valueList, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeDashoffset(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   SetValueToCoord(val, GetStyleSVG()->mStrokeDashoffset);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeWidth(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   SetValueToCoord(val, GetStyleSVG()->mStrokeWidth);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetFillOpacity(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   val->SetNumber(GetStyleSVG()->mFillOpacity);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetFloodOpacity(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   val->SetNumber(GetStyleSVGReset()->mFloodOpacity);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStopOpacity(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   val->SetNumber(GetStyleSVGReset()->mStopOpacity);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeMiterlimit(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   val->SetNumber(GetStyleSVG()->mStrokeMiterlimit);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeOpacity(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   val->SetNumber(GetStyleSVG()->mStrokeOpacity);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetClipRule(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(
24090:                   GetStyleSVG()->mClipRule, nsCSSProps::kFillRuleKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetFillRule(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(nsCSSProps::ValueToKeywordEnum(
24090:                   GetStyleSVG()->mFillRule, nsCSSProps::kFillRuleKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeLinecap(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mStrokeLinecap,
24090:                                    nsCSSProps::kStrokeLinecapKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetStrokeLinejoin(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mStrokeLinejoin,
24090:                                    nsCSSProps::kStrokeLinejoinKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetTextAnchor(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(
24090:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mTextAnchor,
24090:                                    nsCSSProps::kTextAnchorKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetColorInterpolation(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mColorInterpolation,
24090:                                    nsCSSProps::kColorInterpolationKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetColorInterpolationFilters(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mColorInterpolationFilters,
24090:                                    nsCSSProps::kColorInterpolationKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetDominantBaseline(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
24090:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleSVGReset()->mDominantBaseline,
24090:                                    nsCSSProps::kDominantBaselineKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
26449: nsComputedDOMStyle::GetImageRendering(nsIDOMCSSValue** aValue)
26449: {
26449:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
26449:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
26449: 
34080:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mImageRendering,
34080:                                    nsCSSProps::kImageRenderingKTable));
26449: 
26449:   return CallQueryInterface(val, aValue);
26449: }
26449: 
26449: nsresult
 3735: nsComputedDOMStyle::GetShapeRendering(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
34080:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mShapeRendering,
34080:                                    nsCSSProps::kShapeRenderingKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetTextRendering(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
34080:   val->SetIdent(
34080:     nsCSSProps::ValueToKeywordEnum(GetStyleSVG()->mTextRendering,
34080:                                    nsCSSProps::kTextRenderingKTable));
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 4029: nsComputedDOMStyle::GetFloodColor(nsIDOMCSSValue** aValue)
 4029: {
 4029:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 4029:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 4029: 
 4029:   nsresult rv = SetToRGBAColor(val, GetStyleSVGReset()->mFloodColor);
 4029:   if (NS_FAILED(rv)) {
 4029:     delete val;
 4029:     return rv;
 4029:   }
 4029: 
 4029:   return CallQueryInterface(val, aValue);
 4029: }
 4029: 
 4029: nsresult
 4029: nsComputedDOMStyle::GetLightingColor(nsIDOMCSSValue** aValue)
 4029: {
 4029:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 4029:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 4029: 
 4029:   nsresult rv = SetToRGBAColor(val, GetStyleSVGReset()->mLightingColor);
 4029:   if (NS_FAILED(rv)) {
 4029:     delete val;
 4029:     return rv;
 4029:   }
 4029: 
 4029:   return CallQueryInterface(val, aValue);
 4029: }
 4029: 
 4029: nsresult
 3735: nsComputedDOMStyle::GetStopColor(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue *val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   nsresult rv = SetToRGBAColor(val, GetStyleSVGReset()->mStopColor);
 3735:   if (NS_FAILED(rv)) {
 3735:     delete val;
 3735:     return rv;
 3735:   }
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetClipPath(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVGReset* svg = GetStyleSVGReset();
 3735: 
 3735:   if (svg->mClipPath)
 3735:     val->SetURI(svg->mClipPath);
 3735:   else
24090:     val->SetIdent(eCSSKeyword_none);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetFilter(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVGReset* svg = GetStyleSVGReset();
 3735: 
 3735:   if (svg->mFilter)
 3735:     val->SetURI(svg->mFilter);
 3735:   else
24090:     val->SetIdent(eCSSKeyword_none);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: nsresult
 3735: nsComputedDOMStyle::GetMask(nsIDOMCSSValue** aValue)
 3735: {
 3735:   nsROCSSPrimitiveValue* val = GetROCSSPrimitiveValue();
 3735:   NS_ENSURE_TRUE(val, NS_ERROR_OUT_OF_MEMORY);
 3735: 
 3735:   const nsStyleSVGReset* svg = GetStyleSVGReset();
 3735: 
 3735:   if (svg->mMask)
 3735:     val->SetURI(svg->mMask);
 3735:   else
24090:     val->SetIdent(eCSSKeyword_none);
 3735: 
 3735:   return CallQueryInterface(val, aValue);
 3735: }
 3735: 
 3735: #endif // MOZ_SVG
 3735: 
31702: nsresult
31702: nsComputedDOMStyle::GetTransitionDelay(nsIDOMCSSValue** aValue)
31702: {
31702:   const nsStyleDisplay* display = GetStyleDisplay();
31702: 
31702:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
31702:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
31702: 
31702:   NS_ABORT_IF_FALSE(display->mTransitionDelayCount > 0,
31702:                     "first item must be explicit");
31702:   PRUint32 i = 0;
31702:   do {
31702:     const nsTransition *transition = &display->mTransitions[i];
31702:     nsROCSSPrimitiveValue* delay = GetROCSSPrimitiveValue();
31702:     if (!delay || !valueList->AppendCSSValue(delay)) {
31702:       delete valueList;
31702:       delete delay;
31702:       return NS_ERROR_OUT_OF_MEMORY;
31702:     }
31702:     delay->SetTime((float)transition->GetDelay() / (float)PR_MSEC_PER_SEC);
31702:   } while (++i < display->mTransitionDelayCount);
31702: 
31702:   return CallQueryInterface(valueList, aValue);
31702: }
31702: 
31702: nsresult
31702: nsComputedDOMStyle::GetTransitionDuration(nsIDOMCSSValue** aValue)
31702: {
31702:   const nsStyleDisplay* display = GetStyleDisplay();
31702: 
31702:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
31702:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
31702: 
31702:   NS_ABORT_IF_FALSE(display->mTransitionDurationCount > 0,
31702:                     "first item must be explicit");
31702:   PRUint32 i = 0;
31702:   do {
31702:     const nsTransition *transition = &display->mTransitions[i];
31702:     nsROCSSPrimitiveValue* duration = GetROCSSPrimitiveValue();
31702:     if (!duration || !valueList->AppendCSSValue(duration)) {
31702:       delete valueList;
31702:       delete duration;
31702:       return NS_ERROR_OUT_OF_MEMORY;
31702:     }
31702: 
31702:     duration->SetTime((float)transition->GetDuration() / (float)PR_MSEC_PER_SEC);
31702:   } while (++i < display->mTransitionDurationCount);
31702: 
31702:   return CallQueryInterface(valueList, aValue);
31702: }
31702: 
31702: nsresult
31702: nsComputedDOMStyle::GetTransitionProperty(nsIDOMCSSValue** aValue)
31702: {
31702:   const nsStyleDisplay* display = GetStyleDisplay();
31702: 
31702:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
31702:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
31702: 
31702:   NS_ABORT_IF_FALSE(display->mTransitionPropertyCount > 0,
31702:                     "first item must be explicit");
31702:   PRUint32 i = 0;
31702:   do {
31702:     const nsTransition *transition = &display->mTransitions[i];
31702:     nsROCSSPrimitiveValue* property = GetROCSSPrimitiveValue();
31702:     if (!property || !valueList->AppendCSSValue(property)) {
31702:       delete valueList;
31702:       delete property;
31702:       return NS_ERROR_OUT_OF_MEMORY;
31702:     }
31702:     nsCSSProperty cssprop = transition->GetProperty();
31702:     if (cssprop == eCSSPropertyExtra_all_properties)
31702:       property->SetIdent(eCSSKeyword_all);
31702:     else if (cssprop == eCSSPropertyExtra_no_properties)
31702:       property->SetIdent(eCSSKeyword_none);
31702:     else if (cssprop == eCSSProperty_UNKNOWN)
31702:     {
31702:       const char *str;
31702:       transition->GetUnknownProperty()->GetUTF8String(&str);
31702:       property->SetString(nsDependentCString(str)); // really want SetIdent
31702:     }
31702:     else
31702:       property->SetString(nsCSSProps::GetStringValue(cssprop));
31702:   } while (++i < display->mTransitionPropertyCount);
31702: 
31702:   return CallQueryInterface(valueList, aValue);
31702: }
31702: 
31702: nsresult
31702: nsComputedDOMStyle::GetTransitionTimingFunction(nsIDOMCSSValue** aValue)
31702: {
31702:   const nsStyleDisplay* display = GetStyleDisplay();
31702: 
31702:   nsDOMCSSValueList *valueList = GetROCSSValueList(PR_TRUE);
31702:   NS_ENSURE_TRUE(valueList, NS_ERROR_OUT_OF_MEMORY);
31702: 
31702:   NS_ABORT_IF_FALSE(display->mTransitionTimingFunctionCount > 0,
31702:                     "first item must be explicit");
31702:   PRUint32 i = 0;
31702:   do {
31702:     const nsTransition *transition = &display->mTransitions[i];
31702:     nsROCSSPrimitiveValue* timingFunction = GetROCSSPrimitiveValue();
31702:     if (!timingFunction || !valueList->AppendCSSValue(timingFunction)) {
31702:       delete valueList;
31702:       delete timingFunction;
31702:       return NS_ERROR_OUT_OF_MEMORY;
31702:     }
31702: 
31702:     // set the value from the cubic-bezier control points
31702:     // (We could try to regenerate the keywords if we want.)
31702:     const nsTimingFunction& tf = transition->GetTimingFunction();
31702:     timingFunction->SetString(
31702:       nsPrintfCString(64, "cubic-bezier(%f, %f, %f, %f)",
31702:                           tf.mX1, tf.mY1, tf.mX2, tf.mY2));
31702:   } while (++i < display->mTransitionTimingFunctionCount);
31702: 
31702:   return CallQueryInterface(valueList, aValue);
31702: }
 3735: 
    1: #define COMPUTED_STYLE_MAP_ENTRY(_prop, _method)              \
25450:   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_FALSE }
25450: #define COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_prop, _method)       \
25450:   { eCSSProperty_##_prop, &nsComputedDOMStyle::Get##_method, PR_TRUE }
    1: 
    1: const nsComputedDOMStyle::ComputedStyleMapEntry*
    1: nsComputedDOMStyle::GetQueryablePropertyMap(PRUint32* aLength)
    1: {
    1:   /* ******************************************************************* *\
    1:    * Properties below are listed in alphabetical order.                  *
    1:    * Please keep them that way.                                          *
    1:    *                                                                     *
    1:    * Properties commented out with // are not yet implemented            *
    1:    * Properties commented out with //// are shorthands and not queryable *
    1:   \* ******************************************************************* */
    1:   static
    1: #ifndef XP_MACOSX
    1:     // XXX If this actually fixes the bustage, replace this with an
    1:     // autoconf test.
    1:   const
    1: #endif
    1:   ComputedStyleMapEntry map[] = {
    1:     /* ****************************** *\
    1:      * Implementations of CSS2 styles *
    1:     \* ****************************** */
    1: 
    1:     // COMPUTED_STYLE_MAP_ENTRY(azimuth,                    Azimuth),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(background,               Background),
    1:     COMPUTED_STYLE_MAP_ENTRY(background_attachment,         BackgroundAttachment),
    1:     COMPUTED_STYLE_MAP_ENTRY(background_color,              BackgroundColor),
    1:     COMPUTED_STYLE_MAP_ENTRY(background_image,              BackgroundImage),
 3750:     COMPUTED_STYLE_MAP_ENTRY(background_position,           BackgroundPosition),
    1:     COMPUTED_STYLE_MAP_ENTRY(background_repeat,             BackgroundRepeat),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border,                   Border),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_bottom,            BorderBottom),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_bottom_color,           BorderBottomColor),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_bottom_style,           BorderBottomStyle),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(border_bottom_width,    BorderBottomWidth),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_collapse,               BorderCollapse),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_color,             BorderColor),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_left,              BorderLeft),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_left_color,             BorderLeftColor),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_left_style,             BorderLeftStyle),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(border_left_width,      BorderLeftWidth),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_right,             BorderRight),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_right_color,            BorderRightColor),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_right_style,            BorderRightStyle),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(border_right_width,     BorderRightWidth),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_spacing,                BorderSpacing),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_style,             BorderStyle),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_top,               BorderTop),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_top_color,              BorderTopColor),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_top_style,              BorderTopStyle),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(border_top_width,       BorderTopWidth),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(border_width,             BorderWidth),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(bottom,                 Bottom),
    1:     COMPUTED_STYLE_MAP_ENTRY(caption_side,                  CaptionSide),
    1:     COMPUTED_STYLE_MAP_ENTRY(clear,                         Clear),
    1:     COMPUTED_STYLE_MAP_ENTRY(clip,                          Clip),
    1:     COMPUTED_STYLE_MAP_ENTRY(color,                         Color),
 3750:     COMPUTED_STYLE_MAP_ENTRY(content,                       Content),
    1:     COMPUTED_STYLE_MAP_ENTRY(counter_increment,             CounterIncrement),
    1:     COMPUTED_STYLE_MAP_ENTRY(counter_reset,                 CounterReset),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(cue,                      Cue),
    1:     // COMPUTED_STYLE_MAP_ENTRY(cue_after,                  CueAfter),
    1:     // COMPUTED_STYLE_MAP_ENTRY(cue_before,                 CueBefore),
    1:     COMPUTED_STYLE_MAP_ENTRY(cursor,                        Cursor),
    1:     COMPUTED_STYLE_MAP_ENTRY(direction,                     Direction),
    1:     COMPUTED_STYLE_MAP_ENTRY(display,                       Display),
    1:     // COMPUTED_STYLE_MAP_ENTRY(elevation,                  Elevation),
    1:     COMPUTED_STYLE_MAP_ENTRY(empty_cells,                   EmptyCells),
    1:     COMPUTED_STYLE_MAP_ENTRY(float,                         CssFloat),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(font,                     Font),
    1:     COMPUTED_STYLE_MAP_ENTRY(font_family,                   FontFamily),
    1:     COMPUTED_STYLE_MAP_ENTRY(font_size,                     FontSize),
    1:     COMPUTED_STYLE_MAP_ENTRY(font_size_adjust,              FontSizeAdjust),
24408:     COMPUTED_STYLE_MAP_ENTRY(font_stretch,                  FontStretch),
    1:     COMPUTED_STYLE_MAP_ENTRY(font_style,                    FontStyle),
    1:     COMPUTED_STYLE_MAP_ENTRY(font_variant,                  FontVariant),
    1:     COMPUTED_STYLE_MAP_ENTRY(font_weight,                   FontWeight),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(height,                 Height),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(left,                   Left),
    1:     COMPUTED_STYLE_MAP_ENTRY(letter_spacing,                LetterSpacing),
28519:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(line_height,            LineHeight),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(list_style,               ListStyle),
    1:     COMPUTED_STYLE_MAP_ENTRY(list_style_image,              ListStyleImage),
    1:     COMPUTED_STYLE_MAP_ENTRY(list_style_position,           ListStylePosition),
    1:     COMPUTED_STYLE_MAP_ENTRY(list_style_type,               ListStyleType),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(margin,                   Margin),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(margin_bottom,          MarginBottomWidth),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(margin_left,            MarginLeftWidth),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(margin_right,           MarginRightWidth),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(margin_top,             MarginTopWidth),
    1:     COMPUTED_STYLE_MAP_ENTRY(marker_offset,                 MarkerOffset),
    1:     // COMPUTED_STYLE_MAP_ENTRY(marks,                      Marks),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(max_height,             MaxHeight),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(max_width,              MaxWidth),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(min_height,             MinHeight),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(min_width,              MinWidth),
 1520:     COMPUTED_STYLE_MAP_ENTRY(ime_mode,                      IMEMode),
    1:     COMPUTED_STYLE_MAP_ENTRY(opacity,                       Opacity),
    1:     // COMPUTED_STYLE_MAP_ENTRY(orphans,                    Orphans),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(outline,                  Outline),
    1:     COMPUTED_STYLE_MAP_ENTRY(outline_color,                 OutlineColor),
    1:     COMPUTED_STYLE_MAP_ENTRY(outline_style,                 OutlineStyle),
    1:     COMPUTED_STYLE_MAP_ENTRY(outline_width,                 OutlineWidth),
    1:     COMPUTED_STYLE_MAP_ENTRY(outline_offset,                OutlineOffset),
    1:     COMPUTED_STYLE_MAP_ENTRY(overflow,                      Overflow),
    1:     COMPUTED_STYLE_MAP_ENTRY(overflow_x,                    OverflowX),
    1:     COMPUTED_STYLE_MAP_ENTRY(overflow_y,                    OverflowY),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(padding,                  Padding),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(padding_bottom,         PaddingBottom),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(padding_left,           PaddingLeft),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(padding_right,          PaddingRight),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(padding_top,            PaddingTop),
    1:     // COMPUTED_STYLE_MAP_ENTRY(page,                       Page),
 3750:     COMPUTED_STYLE_MAP_ENTRY(page_break_after,              PageBreakAfter),
 3750:     COMPUTED_STYLE_MAP_ENTRY(page_break_before,             PageBreakBefore),
    1:     // COMPUTED_STYLE_MAP_ENTRY(page_break_inside,          PageBreakInside),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(pause,                    Pause),
    1:     // COMPUTED_STYLE_MAP_ENTRY(pause_after,                PauseAfter),
    1:     // COMPUTED_STYLE_MAP_ENTRY(pause_before,               PauseBefore),
    1:     // COMPUTED_STYLE_MAP_ENTRY(pitch,                      Pitch),
    1:     // COMPUTED_STYLE_MAP_ENTRY(pitch_range,                PitchRange),
32021:     COMPUTED_STYLE_MAP_ENTRY(pointer_events,                PointerEvents),
    1:     COMPUTED_STYLE_MAP_ENTRY(position,                      Position),
 3750:     COMPUTED_STYLE_MAP_ENTRY(quotes,                        Quotes),
    1:     // COMPUTED_STYLE_MAP_ENTRY(richness,                   Richness),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(right,                  Right),
    1:     //// COMPUTED_STYLE_MAP_ENTRY(size,                     Size),
    1:     // COMPUTED_STYLE_MAP_ENTRY(speak,                      Speak),
    1:     // COMPUTED_STYLE_MAP_ENTRY(speak_header,               SpeakHeader),
    1:     // COMPUTED_STYLE_MAP_ENTRY(speak_numeral,              SpeakNumeral),
    1:     // COMPUTED_STYLE_MAP_ENTRY(speak_punctuation,          SpeakPunctuation),
    1:     // COMPUTED_STYLE_MAP_ENTRY(speech_rate,                SpeechRate),
    1:     // COMPUTED_STYLE_MAP_ENTRY(stress,                     Stress),
    1:     COMPUTED_STYLE_MAP_ENTRY(table_layout,                  TableLayout),
    1:     COMPUTED_STYLE_MAP_ENTRY(text_align,                    TextAlign),
    1:     COMPUTED_STYLE_MAP_ENTRY(text_decoration,               TextDecoration),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(text_indent,            TextIndent),
15268:     COMPUTED_STYLE_MAP_ENTRY(text_shadow,                   TextShadow),
    1:     COMPUTED_STYLE_MAP_ENTRY(text_transform,                TextTransform),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(top,                    Top),
    1:     COMPUTED_STYLE_MAP_ENTRY(unicode_bidi,                  UnicodeBidi),
28519:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(vertical_align,         VerticalAlign),
    1:     COMPUTED_STYLE_MAP_ENTRY(visibility,                    Visibility),
    1:     // COMPUTED_STYLE_MAP_ENTRY(voice_family,               VoiceFamily),
    1:     // COMPUTED_STYLE_MAP_ENTRY(volume,                     Volume),
    1:     COMPUTED_STYLE_MAP_ENTRY(white_space,                   WhiteSpace),
    1:     // COMPUTED_STYLE_MAP_ENTRY(widows,                     Widows),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(width,                  Width),
    1:     COMPUTED_STYLE_MAP_ENTRY(word_spacing,                  WordSpacing),
    1:     COMPUTED_STYLE_MAP_ENTRY(z_index,                       ZIndex),
    1: 
    1:     /* ******************************* *\
    1:      * Implementations of -moz- styles *
    1:     \* ******************************* */
    1: 
    1:     COMPUTED_STYLE_MAP_ENTRY(appearance,                    Appearance),
    1:     COMPUTED_STYLE_MAP_ENTRY(_moz_background_clip,          BackgroundClip),
    1:     COMPUTED_STYLE_MAP_ENTRY(_moz_background_inline_policy, BackgroundInlinePolicy),
    1:     COMPUTED_STYLE_MAP_ENTRY(_moz_background_origin,        BackgroundOrigin),
30894:     COMPUTED_STYLE_MAP_ENTRY(_moz_background_size,          MozBackgroundSize),
    1:     COMPUTED_STYLE_MAP_ENTRY(binding,                       Binding),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_bottom_colors,          BorderBottomColors),
15992:     COMPUTED_STYLE_MAP_ENTRY(border_image,                  BorderImage),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_left_colors,            BorderLeftColors),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_right_colors,           BorderRightColors),
    1:     COMPUTED_STYLE_MAP_ENTRY(border_top_colors,             BorderTopColors),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_border_radius_bottomLeft, BorderRadiusBottomLeft),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_border_radius_bottomRight,BorderRadiusBottomRight),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_border_radius_topLeft,    BorderRadiusTopLeft),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_border_radius_topRight,   BorderRadiusTopRight),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_align,                     BoxAlign),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_direction,                 BoxDirection),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_flex,                      BoxFlex),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_ordinal_group,             BoxOrdinalGroup),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_orient,                    BoxOrient),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_pack,                      BoxPack),
15699:     COMPUTED_STYLE_MAP_ENTRY(box_shadow,                    BoxShadow),
    1:     COMPUTED_STYLE_MAP_ENTRY(box_sizing,                    BoxSizing),
    1:     COMPUTED_STYLE_MAP_ENTRY(_moz_column_count,             ColumnCount),
    1:     COMPUTED_STYLE_MAP_ENTRY(_moz_column_width,             ColumnWidth),
    1:     COMPUTED_STYLE_MAP_ENTRY(_moz_column_gap,               ColumnGap),
16055:     //// COMPUTED_STYLE_MAP_ENTRY(_moz_column_rule,         ColumnRule),
16055:     COMPUTED_STYLE_MAP_ENTRY(_moz_column_rule_color,        ColumnRuleColor),
16055:     COMPUTED_STYLE_MAP_ENTRY(_moz_column_rule_width,        ColumnRuleWidth),
16055:     COMPUTED_STYLE_MAP_ENTRY(_moz_column_rule_style,        ColumnRuleStyle),
    1:     COMPUTED_STYLE_MAP_ENTRY(float_edge,                    FloatEdge),
 3750:     COMPUTED_STYLE_MAP_ENTRY(force_broken_image_icon,  ForceBrokenImageIcon),
    1:     COMPUTED_STYLE_MAP_ENTRY(image_region,                  ImageRegion),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_bottomLeft, OutlineRadiusBottomLeft),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_bottomRight,OutlineRadiusBottomRight),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_topLeft,    OutlineRadiusTopLeft),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_outline_radius_topRight,   OutlineRadiusTopRight),
15260:     COMPUTED_STYLE_MAP_ENTRY(stack_sizing,                  StackSizing),
33208:     COMPUTED_STYLE_MAP_ENTRY(_moz_tab_size,                 MozTabSize),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform,         MozTransform),
25450:     COMPUTED_STYLE_MAP_ENTRY_LAYOUT(_moz_transform_origin,  MozTransformOrigin),
    1:     COMPUTED_STYLE_MAP_ENTRY(user_focus,                    UserFocus),
    1:     COMPUTED_STYLE_MAP_ENTRY(user_input,                    UserInput),
    1:     COMPUTED_STYLE_MAP_ENTRY(user_modify,                   UserModify),
16166:     COMPUTED_STYLE_MAP_ENTRY(user_select,                   UserSelect),
31702:     COMPUTED_STYLE_MAP_ENTRY(transition_delay,              TransitionDelay),
31702:     COMPUTED_STYLE_MAP_ENTRY(transition_duration,           TransitionDuration),
31702:     COMPUTED_STYLE_MAP_ENTRY(transition_property,           TransitionProperty),
31702:     COMPUTED_STYLE_MAP_ENTRY(transition_timing_function,    TransitionTimingFunction),
20464:     COMPUTED_STYLE_MAP_ENTRY(_moz_window_shadow,            WindowShadow),
16166:     COMPUTED_STYLE_MAP_ENTRY(word_wrap,                     WordWrap)
 3735: 
 3735: #ifdef MOZ_SVG
 3735:     ,
 3735:     COMPUTED_STYLE_MAP_ENTRY(clip_path,                     ClipPath),
 3735:     COMPUTED_STYLE_MAP_ENTRY(clip_rule,                     ClipRule),
 3735:     COMPUTED_STYLE_MAP_ENTRY(color_interpolation,           ColorInterpolation),
 3735:     COMPUTED_STYLE_MAP_ENTRY(color_interpolation_filters,   ColorInterpolationFilters),
 3735:     COMPUTED_STYLE_MAP_ENTRY(dominant_baseline,             DominantBaseline),
 3735:     COMPUTED_STYLE_MAP_ENTRY(fill,                          Fill),
 3735:     COMPUTED_STYLE_MAP_ENTRY(fill_opacity,                  FillOpacity),
 3735:     COMPUTED_STYLE_MAP_ENTRY(fill_rule,                     FillRule),
 3735:     COMPUTED_STYLE_MAP_ENTRY(filter,                        Filter),
 3735:     COMPUTED_STYLE_MAP_ENTRY(flood_color,                   FloodColor),
 3735:     COMPUTED_STYLE_MAP_ENTRY(flood_opacity,                 FloodOpacity),
 4029:     COMPUTED_STYLE_MAP_ENTRY(lighting_color,                LightingColor),
26449:     COMPUTED_STYLE_MAP_ENTRY(image_rendering,               ImageRendering),
 3735:     COMPUTED_STYLE_MAP_ENTRY(mask,                          Mask),
 3735:     COMPUTED_STYLE_MAP_ENTRY(marker_end,                    MarkerEnd),
 3735:     COMPUTED_STYLE_MAP_ENTRY(marker_mid,                    MarkerMid),
 3735:     COMPUTED_STYLE_MAP_ENTRY(marker_start,                  MarkerStart),
 3735:     COMPUTED_STYLE_MAP_ENTRY(shape_rendering,               ShapeRendering),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stop_color,                    StopColor),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stop_opacity,                  StopOpacity),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke,                        Stroke),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_dasharray,              StrokeDasharray),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_dashoffset,             StrokeDashoffset),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_linecap,                StrokeLinecap),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_linejoin,               StrokeLinejoin),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_miterlimit,             StrokeMiterlimit),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_opacity,                StrokeOpacity),
 3735:     COMPUTED_STYLE_MAP_ENTRY(stroke_width,                  StrokeWidth),
 3735:     COMPUTED_STYLE_MAP_ENTRY(text_anchor,                   TextAnchor),
 3735:     COMPUTED_STYLE_MAP_ENTRY(text_rendering,                TextRendering)
 3735: #endif
 3735: 
    1:   };
    1: 
    1:   *aLength = NS_ARRAY_LENGTH(map);
    1: 
    1:   return map;
    1: }
    1: 
