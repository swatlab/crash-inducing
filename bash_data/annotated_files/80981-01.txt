71095: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
71095: // vim:set ts=2 sts=2 sw=2 et cin:
71095: /* ***** BEGIN LICENSE BLOCK *****
71095:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
71095:  *
71095:  * The contents of this file are subject to the Mozilla Public License Version
71095:  * 1.1 (the "License"); you may not use this file except in compliance with
71095:  * the License. You may obtain a copy of the License at
71095:  * http://www.mozilla.org/MPL/
71095:  *
71095:  * Software distributed under the License is distributed on an "AS IS" basis,
71095:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
71095:  * for the specific language governing rights and limitations under the
71095:  * License.
71095:  *
71095:  * The Original Code is Mozilla Communicator client code.
71095:  *
71095:  * The Initial Developer of the Original Code is
71095:  * Netscape Communications Corporation.
71095:  * Portions created by the Initial Developer are Copyright (C) 1998
71095:  * the Initial Developer. All Rights Reserved.
71095:  *
71095:  * Contributor(s):
71095:  *   Pierre Phaneuf <pp@ludusdesign.com>
71095:  *   Jacek Piskozub <piskozub@iopan.gda.pl>
71095:  *   Leon Sha <leon.sha@sun.com>
71095:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
71095:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
71095:  *   Christian Biesinger <cbiesinger@web.de>
71095:  *   Josh Aas <josh@mozilla.com>
71095:  *   Mats Palmgren <matspal@gmail.com>
71095:  *
71095:  * Alternatively, the contents of this file may be used under the terms of
71095:  * either of the GNU General Public License Version 2 or later (the "GPL"),
71095:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
71095:  * in which case the provisions of the GPL or the LGPL are applicable instead
71095:  * of those above. If you wish to allow use of your version of this file only
71095:  * under the terms of either the GPL or the LGPL, and not to allow others to
71095:  * use your version of this file under the terms of the MPL, indicate your
71095:  * decision by deleting the provisions above and replace them with the notice
71095:  * and other provisions required by the GPL or the LGPL. If you do not delete
71095:  * the provisions above, a recipient may use your version of this file under
71095:  * the terms of any one of the MPL, the GPL or the LGPL.
71095:  *
71095:  * ***** END LICENSE BLOCK ***** */
71095: 
71095: #ifndef nsPluginInstanceOwner_h_
71095: #define nsPluginInstanceOwner_h_
71095: 
71095: #include "prtypes.h"
71095: #include "npapi.h"
71095: #include "nsCOMPtr.h"
71095: #include "nsIPluginInstanceOwner.h"
71095: #include "nsIPluginTagInfo.h"
75043: #include "nsIDOMEventListener.h"
71095: #include "nsIScrollPositionListener.h"
71095: #include "nsPluginHost.h"
71095: #include "nsPluginNativeWindow.h"
71095: #include "gfxRect.h"
71095: 
75043: // X.h defines KeyPress
75043: #ifdef KeyPress
75043: #undef KeyPress
75043: #endif
75043: 
71095: #ifdef XP_MACOSX
71095: #include "nsCoreAnimationSupport.h"
71095: #include <ApplicationServices/ApplicationServices.h>
71095: #endif
71095: 
71095: class nsIInputStream;
77539: struct nsIntRect;
71095: class nsPluginDOMContextMenuListener;
71095: class nsObjectFrame;
71095: class nsDisplayListBuilder;
71095: 
71095: #ifdef MOZ_X11
71095: class gfxXlibSurface;
71095: #endif
71095: 
71095: #ifdef MOZ_WIDGET_GTK2
71095: #include "gfxXlibNativeRenderer.h"
71095: #endif
71095: 
71095: #ifdef MOZ_WIDGET_QT
77137: #ifdef MOZ_X11
71095: #include "gfxQtNativeRenderer.h"
71095: #endif
77137: #endif
71095: 
74305: #ifdef XP_OS2
74305: #define INCL_PM
74305: #define INCL_GPI
74305: #include <os2.h>
74305: #endif
74305: 
75043: // X.h defines KeyPress
75043: #ifdef KeyPress
75043: #undef KeyPress
75043: #endif
75043: 
71095: class nsPluginInstanceOwner : public nsIPluginInstanceOwner,
71095:                               public nsIPluginTagInfo,
75043:                               public nsIDOMEventListener,
71095:                               public nsIScrollPositionListener
71095: {
71095: public:
71095:   nsPluginInstanceOwner();
71095:   virtual ~nsPluginInstanceOwner();
71095:   
71095:   NS_DECL_ISUPPORTS
71095:   NS_DECL_NSIPLUGININSTANCEOWNER
71095:   
71095:   NS_IMETHOD GetURL(const char *aURL, const char *aTarget,
71095:                     nsIInputStream *aPostStream, 
71095:                     void *aHeadersData, PRUint32 aHeadersDataLen);
71095:   
71095:   NS_IMETHOD ShowStatus(const PRUnichar *aStatusMsg);
71095:   
71095:   NPError    ShowNativeContextMenu(NPMenu* menu, void* event);
71095:   
71095:   NPBool     ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
71095:                           double *destX, double *destY, NPCoordinateSpace destSpace);
71095:   
71095:   //nsIPluginTagInfo interface
71095:   NS_DECL_NSIPLUGINTAGINFO
71095:   
75043:   // nsIDOMEventListener interfaces 
75043:   NS_DECL_NSIDOMEVENTLISTENER
71095:   
75043:   nsresult MouseDown(nsIDOMEvent* aKeyEvent);
75043:   nsresult KeyPress(nsIDOMEvent* aKeyEvent);
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498:   nsresult Text(nsIDOMEvent* aTextEvent);
77498: #endif
71095: 
71095:   nsresult Destroy();  
71095:   
79445:   void PrepareToStop(bool aDelayedStop);
71095:   
71095: #ifdef XP_WIN
71095:   void Paint(const RECT& aDirty, HDC aDC);
71095: #elif defined(XP_MACOSX)
71095:   void Paint(const gfxRect& aDirtyRect, CGContextRef cgContext);  
71095:   void RenderCoreAnimation(CGContextRef aCGContext, int aWidth, int aHeight);
71095:   void DoCocoaEventDrawRect(const gfxRect& aDrawRect, CGContextRef cgContext);
78424: #elif defined(MOZ_X11) || defined(ANDROID)
71095:   void Paint(gfxContext* aContext,
71095:              const gfxRect& aFrameRect,
71095:              const gfxRect& aDirtyRect);
71095: #elif defined(XP_OS2)
71095:   void Paint(const nsRect& aDirtyRect, HPS aHPS);
71095: #endif
71095:   
71095: #ifdef MAC_CARBON_PLUGINS
71095:   void CancelTimer();
79445:   void StartTimer(bool isVisible);
71095: #endif
71095:   void SendIdleEvent();
71095:   
71095:   // nsIScrollPositionListener interface
71095:   virtual void ScrollPositionWillChange(nscoord aX, nscoord aY);
71095:   virtual void ScrollPositionDidChange(nscoord aX, nscoord aY);
71095:   
71095:   //locals
71095:   
71095:   nsresult Init(nsPresContext* aPresContext, nsObjectFrame* aFrame,
71095:                 nsIContent* aContent);
71095:   
71095:   void* GetPluginPortFromWidget();
71095:   void ReleasePluginPort(void* pluginPort);
71095:   
71095:   void SetPluginHost(nsIPluginHost* aHost);
71095:   
71095:   nsEventStatus ProcessEvent(const nsGUIEvent & anEvent);
71095:   
71095: #ifdef XP_MACOSX
71095:   enum { ePluginPaintEnable, ePluginPaintDisable };
71095:   
71095:   NPDrawingModel GetDrawingModel();
79445:   bool IsRemoteDrawingCoreAnimation();
71095:   NPEventModel GetEventModel();
71095:   static void CARefresh(nsITimer *aTimer, void *aClosure);
71095:   static void AddToCARefreshTimer(nsPluginInstanceOwner *aPluginInstance);
71095:   static void RemoveFromCARefreshTimer(nsPluginInstanceOwner *aPluginInstance);
71095:   void SetupCARefresh();
80981:   // This calls into the plugin (NPP_SetWindow) and can run script.
71095:   void* FixUpPluginWindow(PRInt32 inPaintState);
71095:   void HidePluginWindow();
71095:   // Set a flag that (if true) indicates the plugin port info has changed and
71095:   // SetWindow() needs to be called.
79445:   void SetPluginPortChanged(bool aState) { mPluginPortChanged = aState; }
71095:   // Return a pointer to the internal nsPluginPort structure that's used to
71095:   // store a copy of plugin port info and to detect when it's been changed.
71095:   void* GetPluginPortCopy();
71095:   // Set plugin port info in the plugin (in the 'window' member of the
71095:   // NPWindow structure passed to the plugin by SetWindow()) and set a
71095:   // flag (mPluginPortChanged) to indicate whether or not this info has
71095:   // changed, and SetWindow() needs to be called again.
71095:   void* SetPluginPortAndDetectChange();
71095:   // Flag when we've set up a Thebes (and CoreGraphics) context in
71095:   // nsObjectFrame::PaintPlugin().  We need to know this in
71095:   // FixUpPluginWindow() (i.e. we need to know when FixUpPluginWindow() has
71095:   // been called from nsObjectFrame::PaintPlugin() when we're using the
71095:   // CoreGraphics drawing model).
71095:   void BeginCGPaint();
71095:   void EndCGPaint();
71095: #else // XP_MACOSX
79445:   void UpdateWindowPositionAndClipRect(bool aSetWindow);
79445:   void UpdateWindowVisibility(bool aVisible);
79445:   void UpdateDocumentActiveState(bool aIsActive);
71095: #endif // XP_MACOSX
71284:   void CallSetWindow();
71095:   
71095:   void SetOwner(nsObjectFrame *aOwner)
71095:   {
71095:     mObjectFrame = aOwner;
71095:   }
71095:   nsObjectFrame* GetOwner() {
71095:     return mObjectFrame;
71095:   }
71095:   
71095:   PRUint32 GetLastEventloopNestingLevel() const {
71095:     return mLastEventloopNestingLevel; 
71095:   }
71095:   
71095:   static PRUint32 GetEventloopNestingLevel();
71095:   
71095:   void ConsiderNewEventloopNestingLevel() {
71095:     PRUint32 currentLevel = GetEventloopNestingLevel();
71095:     
71095:     if (currentLevel < mLastEventloopNestingLevel) {
71095:       mLastEventloopNestingLevel = currentLevel;
71095:     }
71095:   }
71095:   
71095:   const char* GetPluginName()
71095:   {
71095:     if (mInstance && mPluginHost) {
71095:       const char* name = NULL;
71095:       if (NS_SUCCEEDED(mPluginHost->GetPluginName(mInstance, &name)) && name)
71095:         return name;
71095:     }
71095:     return "";
71095:   }
71095:   
71095: #ifdef MOZ_X11
71095:   void GetPluginDescription(nsACString& aDescription)
71095:   {
71095:     aDescription.Truncate();
71095:     if (mInstance && mPluginHost) {
71095:       nsCOMPtr<nsIPluginTag> pluginTag;
71095:       
71095:       mPluginHost->GetPluginTagForInstance(mInstance,
71095:                                            getter_AddRefs(pluginTag));
71095:       if (pluginTag) {
71095:         pluginTag->GetDescription(aDescription);
71095:       }
71095:     }
71095:   }
71095: #endif
71095:   
79445:   bool SendNativeEvents()
71095:   {
71095: #ifdef XP_WIN
71095:     // XXX we should remove the plugin name check
71095:     return mPluginWindow->type == NPWindowTypeDrawable &&
71095:     (MatchPluginName("Shockwave Flash") ||
71095:      MatchPluginName("Test Plug-in"));
71095: #elif defined(MOZ_X11) || defined(XP_MACOSX)
79533:     return true;
71095: #else
79533:     return false;
71095: #endif
71095:   }
71095:   
79445:   bool MatchPluginName(const char *aPluginName)
71095:   {
71095:     return strncmp(GetPluginName(), aPluginName, strlen(aPluginName)) == 0;
71095:   }
71095:   
71095:   void NotifyPaintWaiter(nsDisplayListBuilder* aBuilder);
71095:   // Return true if we set image with valid surface
79445:   bool SetCurrentImage(ImageContainer* aContainer);
71095:   /**
71095:    * Returns the bounds of the current async-rendered surface. This can only
71095:    * change in response to messages received by the event loop (i.e. not during
71095:    * painting).
71095:    */
71095:   nsIntSize GetCurrentImageSize();
71095:   
71095:   // Methods to update the background image we send to async plugins.
71095:   // The eventual target of these operations is PluginInstanceParent,
71095:   // but it takes several hops to get there.
71095:   void SetBackgroundUnknown();
71095:   already_AddRefed<gfxContext> BeginUpdateBackground(const nsIntRect& aRect);
71095:   void EndUpdateBackground(gfxContext* aContext, const nsIntRect& aRect);
71095:   
79445:   bool UseAsyncRendering();
71095:   
71095: private:
71095:   
71095:   // return FALSE if LayerSurface dirty (newly created and don't have valid plugin content yet)
79445:   bool IsUpToDate()
71095:   {
71095:     nsIntSize size;
71095:     return NS_SUCCEEDED(mInstance->GetImageSize(&size)) &&
71095:     size == nsIntSize(mPluginWindow->width, mPluginWindow->height);
71095:   }
71095:   
71095:   void FixUpURLS(const nsString &name, nsAString &value);
78424: #ifdef ANDROID
80592:   void AddPluginView(const gfxRect& aRect);
78424:   void RemovePluginView();
78424: #endif 
71095:  
71095:   nsPluginNativeWindow       *mPluginWindow;
71095:   nsRefPtr<nsNPAPIPluginInstance> mInstance;
71095:   nsObjectFrame              *mObjectFrame; // owns nsPluginInstanceOwner
71095:   nsCOMPtr<nsIContent>        mContent;
71095:   nsCString                   mDocumentBase;
71095:   char                       *mTagText;
71095:   nsCOMPtr<nsIWidget>         mWidget;
71095:   nsRefPtr<nsPluginHost>      mPluginHost;
71095:   
71095: #ifdef XP_MACOSX
71095:   NP_CGContext                              mCGPluginPortCopy;
71095: #ifndef NP_NO_QUICKDRAW
71095:   NP_Port                                   mQDPluginPortCopy;
71095: #endif
71095:   PRInt32                                   mInCGPaintLevel;
73761:   nsRefPtr<nsIOSurface>                     mIOSurface;
71095:   nsCARenderer                              mCARenderer;
71095:   CGColorSpaceRef                           mColorProfile;
71095:   static nsCOMPtr<nsITimer>                *sCATimer;
71095:   static nsTArray<nsPluginInstanceOwner*>  *sCARefreshListeners;
79445:   bool                                      mSentInitialTopLevelWindowEvent;
71095: #endif
71284:   // We need to know if async hide window is required since we
71284:   // can not check UseAsyncRendering when executing StopPlugin
79445:   bool                                      mAsyncHidePluginWindow;
71095:   
71095:   // Initially, the event loop nesting level we were created on, it's updated
71095:   // if we detect the appshell is on a lower level as long as we're not stopped.
71095:   // We delay DoStopPlugin() until the appshell reaches this level or lower.
71095:   PRUint32                    mLastEventloopNestingLevel;
79445:   bool                        mContentFocused;
79445:   bool                        mWidgetVisible;    // used on Mac to store our widget's visible state
71095: #ifdef XP_MACOSX
79445:   bool                        mPluginPortChanged;
71095: #endif
71095: #ifdef MOZ_X11
71095:   // Used with windowless plugins only, initialized in CreateWidget().
79445:   bool                        mFlash10Quirks;
71095: #endif
79445:   bool                        mPluginWindowVisible;
79445:   bool                        mPluginDocumentActiveState;
71095:   
71095:   // If true, destroy the widget on destruction. Used when plugin stop
71095:   // is being delayed to a safer point in time.
79445:   bool                        mDestroyWidget;
71095:   PRUint16          mNumCachedAttrs;
71095:   PRUint16          mNumCachedParams;
71095:   char              **mCachedAttrParamNames;
71095:   char              **mCachedAttrParamValues;
71095:   
71095: #ifdef XP_MACOSX
71095:   NPEventModel mEventModel;
71095: #endif
71095:   
71095:   // pointer to wrapper for nsIDOMContextMenuListener
71095:   nsRefPtr<nsPluginDOMContextMenuListener> mCXMenuListener;
71095:   
71095:   nsresult DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent);
71095:   nsresult DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent);
71095:   nsresult DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent);
71095:   
71095:   nsresult EnsureCachedAttrParamArrays();
71095:   
71095: #ifdef MOZ_X11
71095:   class Renderer
71095: #if defined(MOZ_WIDGET_GTK2)
71095:   : public gfxXlibNativeRenderer
71095: #elif defined(MOZ_WIDGET_QT)
71095:   : public gfxQtNativeRenderer
71095: #endif
71095:   {
71095:   public:
71095:     Renderer(NPWindow* aWindow, nsPluginInstanceOwner* aInstanceOwner,
71095:              const nsIntSize& aPluginSize, const nsIntRect& aDirtyRect)
71095:     : mWindow(aWindow), mInstanceOwner(aInstanceOwner),
71095:     mPluginSize(aPluginSize), mDirtyRect(aDirtyRect)
71095:     {}
71095:     virtual nsresult DrawWithXlib(gfxXlibSurface* surface, nsIntPoint offset, 
71095:                                   nsIntRect* clipRects, PRUint32 numClipRects);
71095:   private:
71095:     NPWindow* mWindow;
71095:     nsPluginInstanceOwner* mInstanceOwner;
71095:     const nsIntSize& mPluginSize;
71095:     const nsIntRect& mDirtyRect;
71095:   };
71095: #endif
71095: 
79445:   bool mWaitingForPaint;
71095: };
71095: 
71095: #endif // nsPluginInstanceOwner_h_
71095: 
