50525: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
50525: /* ***** BEGIN LICENSE BLOCK *****
50525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
50525:  *
50525:  * The contents of this file are subject to the Mozilla Public License Version
50525:  * 1.1 (the "License"); you may not use this file except in compliance with
50525:  * the License. You may obtain a copy of the License at
50525:  * http://www.mozilla.org/MPL/
50525:  *
50525:  * Software distributed under the License is distributed on an "AS IS" basis,
50525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
50525:  * for the specific language governing rights and limitations under the
50525:  * License.
50525:  *
50525:  * The Original Code is mozilla.org code.
50525:  *
50525:  * The Initial Developer of the Original Code is
50525:  * Mozilla Foundation.
50525:  * Portions created by the Initial Developer are Copyright (C) 2010
50525:  * the Initial Developer. All Rights Reserved.
50525:  *
50525:  * Contributor(s):
51578:  *   Jonathan Griffin <jgriffin@mozilla.com>
50525:  *
50525:  * Alternatively, the contents of this file may be used under the terms of
50525:  * either the GNU General Public License Version 2 or later (the "GPL"), or
50525:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
50525:  * in which case the provisions of the GPL or the LGPL are applicable instead
50525:  * of those above. If you wish to allow use of your version of this file only
50525:  * under the terms of either the GPL or the LGPL, and not to allow others to
50525:  * use your version of this file under the terms of the MPL, indicate your
50525:  * decision by deleting the provisions above and replace them with the notice
50525:  * and other provisions required by the GPL or the LGPL. If you do not delete
50525:  * the provisions above, a recipient may use your version of this file under
50525:  * the terms of any one of the MPL, the GPL or the LGPL.
50525:  *
50525:  * ***** END LICENSE BLOCK ***** */
50525: 
51578: #include <windows.h>
50525: #include "gfxWindowsPlatform.h"
50525: #include "GfxInfo.h"
51578: #include "nsUnicharUtils.h"
51578: #include "mozilla/FunctionTimer.h"
50525: 
51721: #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
51579: #include "nsExceptionHandler.h"
51579: #include "nsICrashReporter.h"
51579: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
51579: #include "nsIPrefService.h"
51579: #endif
51579: 
51579: 
50525: using namespace mozilla::widget;
50525: 
50525: NS_IMPL_ISUPPORTS1(GfxInfo, nsIGfxInfo)
50525: 
51677: /* GetD2DEnabled and GetDwriteEnabled shouldn't be called until after gfxPlatform initialization
51677:  * has occurred because they depend on it for information. (See bug 591561) */
51736: nsresult
51736: GfxInfo::GetD2DEnabled(PRBool *aEnabled)
50525: {
50525:   *aEnabled = gfxWindowsPlatform::GetPlatform()->GetRenderMode() == gfxWindowsPlatform::RENDER_DIRECT2D;
50525:   return NS_OK;
50525: }
50655: 
51736: nsresult
51736: GfxInfo::GetDWriteEnabled(PRBool *aEnabled)
50655: {
50655:   *aEnabled = gfxWindowsPlatform::GetPlatform()->DWriteEnabled();
50655:   return NS_OK;
50655: }
51578: 
51578: /* XXX: GfxInfo doesn't handle multiple GPUs. We should try to do that. Bug #591057 */
51578: 
54670: static nsresult GetKeyValue(const WCHAR* keyLocation, const WCHAR* keyName, nsAString& destString, int type)
51578: {
51578:   HKEY key;
51578:   DWORD dwcbData;
51578:   DWORD dValue;
51676:   DWORD resultType;
51578:   LONG result;
51578:   nsresult retval = NS_OK;
51578: 
51578:   result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, keyLocation, 0, KEY_QUERY_VALUE, &key);
51578:   if (result != ERROR_SUCCESS) {
51578:     return NS_ERROR_FAILURE;
51578:   }
51578: 
51578:   switch (type) {
51578:     case REG_DWORD: {
51578:       // We only use this for vram size
51578:       dwcbData = sizeof(dValue);
51676:       result = RegQueryValueExW(key, keyName, NULL, &resultType, (LPBYTE)&dValue, &dwcbData);
51676:       if (result == ERROR_SUCCESS && resultType == REG_DWORD) {
51676:         dValue = dValue / 1024 / 1024;
54145:         destString.AppendInt(PRInt32(dValue));
51676:       } else {
51578:         retval = NS_ERROR_FAILURE;
51578:       }
51578:       break;
51578:     }
51578:     case REG_MULTI_SZ: {
51578:       // A chain of null-separated strings; we convert the nulls to spaces
51676:       WCHAR wCharValue[1024];
51676:       dwcbData = sizeof(wCharValue);
51676: 
51676:       result = RegQueryValueExW(key, keyName, NULL, &resultType, (LPBYTE)wCharValue, &dwcbData);
51676:       if (result == ERROR_SUCCESS && resultType == REG_MULTI_SZ) {
51676:         // This bit here could probably be cleaner.
51676:         bool isValid = false;
51676: 
51676:         DWORD strLen = dwcbData/sizeof(wCharValue[0]);
51676:         for (DWORD i = 0; i < strLen; i++) {
51676:           if (wCharValue[i] == '\0') {
51676:             if (i < strLen - 1 && wCharValue[i + 1] == '\0') {
51676:               isValid = true;
51676:               break;
51676:             } else {
51676:               wCharValue[i] = ' ';
51676:             }
51676:           }
51676:         }
51676: 
51676:         // ensure wCharValue is null terminated
51676:         wCharValue[strLen-1] = '\0';
51676: 
51676:         if (isValid)
51676:           destString = wCharValue;
51676: 
51676:       } else {
51578:         retval = NS_ERROR_FAILURE;
51578:       }
51676: 
51578:       break;
51578:     }
51578:   }
51578:   RegCloseKey(key);
51578: 
51578:   return retval;
51578: }
51578: 
51578: // The driver ID is a string like PCI\VEN_15AD&DEV_0405&SUBSYS_040515AD, possibly
51578: // followed by &REV_XXXX.  We uppercase the string, and strip the &REV_ part
51578: // from it, if found.
54670: static void normalizeDriverId(nsString& driverid) {
51578:   ToUpperCase(driverid);
51578:   PRInt32 rev = driverid.Find(NS_LITERAL_CSTRING("&REV_"));
51578:   if (rev != -1) {
51578:     driverid.Cut(rev, driverid.Length());
51578:   }
51578: }
51578: 
51578: 
51578: 
51578: /* Other interesting places for info:
51578:  *   IDXGIAdapter::GetDesc()
51578:  *   IDirectDraw7::GetAvailableVidMem()
51578:  *   e->GetAvailableTextureMem()
51578:  * */
51578: 
51578: #define DEVICE_KEY_PREFIX L"\\Registry\\Machine\\"
51736: void
51736: GfxInfo::Init()
51578: {
51578:   NS_TIME_FUNCTION;
51578: 
51676:   DISPLAY_DEVICEW displayDevice;
51676:   displayDevice.cb = sizeof(displayDevice);
51578:   int deviceIndex = 0;
51578: 
51676:   while (EnumDisplayDevicesW(NULL, deviceIndex, &displayDevice, 0)) {
51676:     if (displayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
51578:       break;
51578:     deviceIndex++;
51578:   }
51578: 
51578:   /* DeviceKey is "reserved" according to MSDN so we'll be careful with it */
51676:   /* check that DeviceKey begins with DEVICE_KEY_PREFIX */
54669:   /* some systems have a DeviceKey starting with \REGISTRY\Machine\ so we need to compare case insenstively */
54669:   if (_wcsnicmp(displayDevice.DeviceKey, DEVICE_KEY_PREFIX, NS_ARRAY_LENGTH(DEVICE_KEY_PREFIX)-1) != 0)
51578:     return;
51578: 
51578:   // make sure the string is NULL terminated
51676:   if (wcsnlen(displayDevice.DeviceKey, NS_ARRAY_LENGTH(displayDevice.DeviceKey))
51676:       == NS_ARRAY_LENGTH(displayDevice.DeviceKey)) {
51578:     // we did not find a NULL
51578:     return;
51578:   }
51578: 
51578:   // chop off DEVICE_KEY_PREFIX
51676:   mDeviceKey = displayDevice.DeviceKey + NS_ARRAY_LENGTH(DEVICE_KEY_PREFIX)-1;
51578: 
51676:   mDeviceID = displayDevice.DeviceID;
51676:   mDeviceString = displayDevice.DeviceString;
51578: 
51578: 
51578:   HKEY key, subkey;
51578:   LONG result, enumresult;
51578:   DWORD index = 0;
51676:   WCHAR subkeyname[64];
51676:   WCHAR value[128];
51578:   DWORD dwcbData = sizeof(subkeyname);
51578: 
51578:   // "{4D36E968-E325-11CE-BFC1-08002BE10318}" is the display class
51578:   result = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
51578:                         L"System\\CurrentControlSet\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}", 
51578:                         0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &key);
51578:   if (result != ERROR_SUCCESS) {
51578:     return;
51578:   }
51578: 
51578:   nsAutoString wantedDriverId(mDeviceID);
51578:   normalizeDriverId(wantedDriverId);
51578: 
51578:   while ((enumresult = RegEnumKeyExW(key, index, subkeyname, &dwcbData, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS) {
51578:     result = RegOpenKeyExW(key, subkeyname, 0, KEY_QUERY_VALUE, &subkey);
51578:     if (result == ERROR_SUCCESS) {
51578:       dwcbData = sizeof(value);
51578:       result = RegQueryValueExW(subkey, L"MatchingDeviceId", NULL, NULL, (LPBYTE)value, &dwcbData);
51578:       if (result == ERROR_SUCCESS) {
51578:         nsAutoString matchingDeviceId(value);
51578:         normalizeDriverId(matchingDeviceId);
51578:         if (wantedDriverId.Find(matchingDeviceId) > -1) {
51578:           /* we've found the driver we're looking for */
51578:           result = RegQueryValueExW(subkey, L"DriverVersion", NULL, NULL, (LPBYTE)value, &dwcbData);
51578:           if (result == ERROR_SUCCESS)
51578:             mDriverVersion = value;
51578:           result = RegQueryValueExW(subkey, L"DriverDate", NULL, NULL, (LPBYTE)value, &dwcbData);
51578:           if (result == ERROR_SUCCESS)
51578:             mDriverDate = value;
51578:           break;
51578:         }
51578:       }
51578:       RegCloseKey(subkey);
51578:     }
51578:     index++;
51578:     dwcbData = sizeof(subkeyname);
51578:   }
51578: 
51578:   RegCloseKey(key);
51579: 
51579: 
51579:   AddCrashReportAnnotations();
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDescription; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
51578: {
51578:   aAdapterDescription = mDeviceString;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterRAM; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
51578: {
51578:   if (NS_FAILED(GetKeyValue(mDeviceKey.BeginReading(), L"HardwareInformation.MemorySize", aAdapterRAM, REG_DWORD)))
51578:     aAdapterRAM = L"Unknown";
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriver; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
51578: {
51578:   if (NS_FAILED(GetKeyValue(mDeviceKey.BeginReading(), L"InstalledDisplayDrivers", aAdapterDriver, REG_MULTI_SZ)))
51578:     aAdapterDriver = L"Unknown";
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriverVersion; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
51578: {
51578:   aAdapterDriverVersion = mDriverVersion;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriverDate; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
51578: {
51578:   aAdapterDriverDate = mDriverDate;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute unsigned long adapterVendorID; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterVendorID(PRUint32 *aAdapterVendorID)
51578: {
51578:   nsAutoString vendor(mDeviceID);
51578:   ToUpperCase(vendor);
51578:   PRInt32 start = vendor.Find(NS_LITERAL_CSTRING("VEN_"));
51578:   if (start != -1) {
51578:     vendor.Cut(0, start + strlen("VEN_"));
51578:     vendor.Truncate(4);
51578:   }
51578:   nsresult err;
51578:   *aAdapterVendorID = vendor.ToInteger(&err, 16);
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute unsigned long adapterDeviceID; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDeviceID(PRUint32 *aAdapterDeviceID)
51578: {
51578:   nsAutoString device(mDeviceID);
51578:   ToUpperCase(device);
51578:   PRInt32 start = device.Find(NS_LITERAL_CSTRING("&DEV_"));
51578:   if (start != -1) {
51578:     device.Cut(0, start + strlen("&DEV_"));
51578:     device.Truncate(4);
51578:   }
51578:   nsresult err;
51578:   *aAdapterDeviceID = device.ToInteger(&err, 16);
51578:   return NS_OK;
51578: }
51579: 
51736: void
51736: GfxInfo::AddCrashReportAnnotations()
51579: {
51721: #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
51579:   nsCAutoString deviceIDString, vendorIDString;
51579:   PRUint32 deviceID, vendorID;
51579: 
51579:   GetAdapterDeviceID(&deviceID);
51579:   GetAdapterVendorID(&vendorID);
51579: 
51733:   deviceIDString.AppendPrintf("%04x", deviceID);
51733:   vendorIDString.AppendPrintf("%04x", vendorID);
51579: 
51579:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterVendorID"),
51579:       vendorIDString);
51579:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterDeviceID"),
51579:       deviceIDString);
51579: 
51579:   /* Add an App Note for now so that we get the data immediately. These
51579:    * can go away after we store the above in the socorro db */
51733:   nsCAutoString note;
51733:   /* AppendPrintf only supports 32 character strings, mrghh. */
51733:   note.AppendPrintf("AdapterVendorID: %04x, ", vendorID);
51733:   note.AppendPrintf("AdapterDeviceID: %04x\n", deviceID);
51733: 
51733:   CrashReporter::AppendAppNotesToCrashReport(note);
51579: 
51579: #endif
51579: }
51736: 
51736: enum VersionComparisonOp {
51736:   DRIVER_LESS_THAN,             // driver <  version
51736:   DRIVER_LESS_THAN_OR_EQUAL,    // driver <= version
51736:   DRIVER_GREATER_THAN,          // driver >  version
51736:   DRIVER_GREATER_THAN_OR_EQUAL, // driver >= version
51736:   DRIVER_EQUAL,                 // driver == version
51736:   DRIVER_NOT_EQUAL,             // driver != version
51736:   DRIVER_BETWEEN_EXCLUSIVE,     // driver > version && driver < versionMax
51736:   DRIVER_BETWEEN_INCLUSIVE,     // driver >= version && driver <= versionMax
51736:   DRIVER_BETWEEN_INCLUSIVE_START // driver >= version && driver < versionMax
51736: };
51736: 
54145: typedef const PRUint32 *GfxDeviceFamily;
51736: 
51736: struct GfxDriverInfo {
54145:   PRUint32 windowsVersion;
54145: 
51736:   PRUint32 vendor;
54145:   GfxDeviceFamily devices;
51736: 
51736:   PRInt32 feature;
51736:   PRInt32 featureStatus;
51736: 
51736:   VersionComparisonOp op;
51736: 
51736:   /* versions are assumed to be A.B.C.D packed as 0xAAAABBBBCCCCDDDD */
51736:   PRUint64 version;
51736:   PRUint64 versionMax;
51736: };
51736: 
54145: static const PRUint32 allWindowsVersions = 0xffffffff;
54145: static const PRInt32  allFeatures = -1;
54145: static const PRUint32 *allDevices = (PRUint32*) nsnull;
54145: static const PRUint64 allDriverVersions = 0xffffffffffffffffULL;
51736: 
51736: /* Intel vendor and device IDs */
54145: static const PRUint32 vendorIntel = 0x8086;
51736: 
51736: /* NVIDIA vendor and device IDs */
51736: 
52041: /* AMD vendor and device IDs */
52041: 
51736: #define V(a,b,c,d)   ((PRUint64(a)<<48) | (PRUint64(b)<<32) | (PRUint64(c)<<16) | PRUint64(d))
51736: 
54145: static const PRUint32 deviceFamilyIntelGMA500[] = {
54145:     0x8108, /* IntelGMA500_1 */
54145:     0x8109, /* IntelGMA500_2 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMA900[] = {
54145:     0x2582, /* IntelGMA900_1 */
54145:     0x2782, /* IntelGMA900_2 */
54145:     0x2592, /* IntelGMA900_3 */
54145:     0x2792, /* IntelGMA900_4 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMA950[] = {
54145:     0x2772, /* Intel945G_1 */
54145:     0x2776, /* Intel945G_2 */
54145:     0x27A2, /* Intel945_1 */
54145:     0x27A6, /* Intel945_2 */
54145:     0x27AE, /* Intel945_3 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMA3150[] = {
54145:     0xA001, /* IntelGMA3150_Nettop_1 */
54145:     0xA002, /* IntelGMA3150_Nettop_2 */
54145:     0xA011, /* IntelGMA3150_Netbook_1 */
54145:     0xA012, /* IntelGMA3150_Netbook_2 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMAX3000[] = {
54145:     0x2972, /* Intel946GZ_1 */
54145:     0x2973, /* Intel946GZ_2 */
54145:     0x2982, /* IntelG35_1 */
54145:     0x2983, /* IntelG35_2 */
54145:     0x2992, /* IntelQ965_1 */
54145:     0x2993, /* IntelQ965_2 */
54145:     0x29A2, /* IntelG965_1 */
54145:     0x29A3, /* IntelG965_2 */
54145:     0x29B2, /* IntelQ35_1 */
54145:     0x29B3, /* IntelQ35_2 */
54145:     0x29C2, /* IntelG33_1 */
54145:     0x29C3, /* IntelG33_2 */
54145:     0x29D2, /* IntelQ33_1 */
54145:     0x29D3, /* IntelQ33_2 */
54145:     0x2A02, /* IntelGL960_1 */
54145:     0x2A03, /* IntelGL960_2 */
54145:     0x2A12, /* IntelGM965_1 */
54145:     0x2A13, /* IntelGM965_2 */
54145:     0
54145: };
54145: 
54670: // see bug 595364 comment 10
54704: static const PRUint32 deviceFamilyIntelBlockDirect2D[] = {
54670:     0x2982, /* IntelG35_1 */
54670:     0x2983, /* IntelG35_2 */
54670:     0x2A02, /* IntelGL960_1 */
54670:     0x2A03, /* IntelGL960_2 */
54670:     0x2A12, /* IntelGM965_1 */
54704:     0x2A13, /* IntelGM965_2 */
54704:     0
54670: };
54670: 
54145: static const PRUint32 deviceFamilyIntelGMAX4500HD[] = {
54145:     0x2A42, /* IntelGMA4500MHD_1 */
54145:     0x2A43, /* IntelGMA4500MHD_2 */
54145:     0x2E42, /* IntelB43_1 */
54145:     0x2E43, /* IntelB43_2 */
54145:     0x2E92, /* IntelB43_3 */
54145:     0x2E93, /* IntelB43_4 */
54145:     0x2E32, /* IntelG41_1 */
54145:     0x2E33, /* IntelG41_2 */
54145:     0x2E22, /* IntelG45_1 */
54145:     0x2E23, /* IntelG45_2 */
54145:     0x2E12, /* IntelQ45_1 */
54145:     0x2E13, /* IntelQ45_2 */
54145:     0x0042, /* IntelHDGraphics */
54145:     0x0046, /* IntelMobileHDGraphics */
54145:     0x0102, /* IntelSandyBridge_1 */
54145:     0x0106, /* IntelSandyBridge_2 */
54145:     0x0112, /* IntelSandyBridge_3 */
54145:     0x0116, /* IntelSandyBridge_4 */
54145:     0x0122, /* IntelSandyBridge_5 */
54145:     0x0126, /* IntelSandyBridge_6 */
54145:     0x010A, /* IntelSandyBridge_7 */
54145:     0x0080, /* IntelIvyBridge */
54145:     0
54145: };
54145: 
54145: static const GfxDriverInfo driverInfo[] = {
51736:   /*
54670:    * Notice that the first match defines the result. So always implement special cases firsts and general case last.
54670:    */
54670: 
54670:   /*
51736:    * Intel entries
51736:    */
54145: 
54670:   /*
54670:    * Implement special Direct2D blocklist from bug 595364
54670:    */
54670:   { allWindowsVersions,
54704:     vendorIntel, deviceFamilyIntelBlockDirect2D,
54670:     nsIGfxInfo::FEATURE_DIRECT2D, nsIGfxInfo::FEATURE_BLOCKED,
54670:     DRIVER_LESS_THAN, allDriverVersions },
54670: 
54145:   /* implement the blocklist from bug 594877
54670:    * Block all features on any drivers before this, as there's a crash when a MS Hotfix is installed.
54670:    * The crash itself is Direct2D-related, but for safety we block all features.
54145:    */
54145: #define IMPLEMENT_INTEL_DRIVER_BLOCKLIST(winVer, devFamily, driverVer) \
54145:   { winVer,                                                            \
54145:     vendorIntel, devFamily,                                            \
54145:     allFeatures, nsIGfxInfo::FEATURE_BLOCKED,                          \
54145:     DRIVER_LESS_THAN, driverVer },
54145: 
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA500,   V(6,14,11,1018))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA900,   V(6,14,10,4764))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA950,   V(6,14,10,4926))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMA3150,  V(6,14,10,5260))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMAX3000, V(6,14,10,5218))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsXP, deviceFamilyIntelGMAX4500HD, V(6,14,10,5284))
54145: 
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsVista, deviceFamilyIntelGMA500,   V(7,14,10,1006))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsVista, deviceFamilyIntelGMA900,   allDriverVersions)
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsVista, deviceFamilyIntelGMA950,   V(7,14,10,1504))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsVista, deviceFamilyIntelGMA3150,  V(7,14,10,2124))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsVista, deviceFamilyIntelGMAX3000, V(7,15,10,1666))
54704:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindowsVista, deviceFamilyIntelGMAX4500HD, V(8,15,10,2202))
54145: 
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA500,   V(5,0,0,2026))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA900,   allDriverVersions)
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA950,   V(8,15,10,1930))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMA3150,  V(8,14,10,2117))
54145:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMAX3000, V(8,15,10,1930))
54704:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(gfxWindowsPlatform::kWindows7, deviceFamilyIntelGMAX4500HD, V(8,15,10,2202))
51736: 
51736:   /* OpenGL on any Intel hardware is not suggested */
54145:   { allWindowsVersions,
54145:     vendorIntel, allDevices,
51736:     nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_NOT_SUGGESTED,
54145:     DRIVER_LESS_THAN, allDriverVersions },
54145:   { allWindowsVersions,
54145:     vendorIntel, allDevices,
51736:     nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_NOT_SUGGESTED,
54145:     DRIVER_LESS_THAN, allDriverVersions },
51736: 
51736:   /*
51736:    * NVIDIA entries
51736:    */
51736: 
51736:   /*
51736:    * AMD entries
51736:    */
51736: 
54145:   { 0, 0, allDevices, 0 }
51736: };
51736: 
54147: static bool
51736: ParseDriverVersion(nsAString& aVersion, PRUint64 *aNumericVersion)
51736: {
51736:   int a, b, c, d;
51736:   /* honestly, why do I even bother */
51736:   if (sscanf(nsPromiseFlatCString(NS_LossyConvertUTF16toASCII(aVersion)).get(),
51736:              "%d.%d.%d.%d", &a, &b, &c, &d) != 4)
51736:     return false;
51736:   if (a < 0 || a > 0xffff) return false;
51736:   if (b < 0 || b > 0xffff) return false;
51736:   if (c < 0 || c > 0xffff) return false;
51736:   if (d < 0 || d > 0xffff) return false;
51736: 
51736:   *aNumericVersion = V(a, b, c, d);
51736:   return true;
51736: }
51736: 
51736: NS_IMETHODIMP
51736: GfxInfo::GetFeatureStatus(PRInt32 aFeature, PRInt32 *aStatus)
51736: {
51736:   PRInt32 status = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
51736: 
51736:   PRUint32 adapterVendor = 0;
51736:   PRUint32 adapterDeviceID = 0;
51736:   nsAutoString adapterDriverVersionString;
51736:   if (NS_FAILED(GetAdapterVendorID(&adapterVendor)) ||
51736:       NS_FAILED(GetAdapterDeviceID(&adapterDeviceID)) ||
51736:       NS_FAILED(GetAdapterDriverVersion(adapterDriverVersionString)))
51736:   {
51736:     return NS_ERROR_FAILURE;
51736:   }
51736: 
51736:   PRUint64 driverVersion;
51736:   if (!ParseDriverVersion(adapterDriverVersionString, &driverVersion)) {
51736:     return NS_ERROR_FAILURE;
51736:   }
51736: 
54145:   const GfxDriverInfo *info = &driverInfo[0];
54145:   while (info->windowsVersion) {
51736: 
54145:     if (info->windowsVersion != allWindowsVersions &&
54145:         info->windowsVersion != gfxWindowsPlatform::WindowsOSVersion())
51736:     {
51736:       info++;
51736:       continue;
51736:     }
51736: 
54145:     if (info->vendor != adapterVendor) {
54145:       info++;
54145:       continue;
54145:     }
54145: 
54145:     if (info->devices != allDevices) {
54145:         bool deviceMatches = false;
54145:         for (const PRUint32 *devices = info->devices; *devices; ++devices) {
54145:             if (*devices == adapterDeviceID) {
54145:                 deviceMatches = true;
54145:                 break;
54145:             }
54145:         }
54145: 
54145:         if (!deviceMatches) {
54145:             info++;
54145:             continue;
54145:         }
54145:     }
54145: 
54145:     bool match = false;
54145: 
51736:     switch (info->op) {
51736:     case DRIVER_LESS_THAN:
51736:       match = driverVersion < info->version;
51736:       break;
51736:     case DRIVER_LESS_THAN_OR_EQUAL:
51736:       match = driverVersion <= info->version;
51736:       break;
51736:     case DRIVER_GREATER_THAN:
51736:       match = driverVersion > info->version;
51736:       break;
51736:     case DRIVER_GREATER_THAN_OR_EQUAL:
51736:       match = driverVersion >= info->version;
51736:       break;
51736:     case DRIVER_EQUAL:
51736:       match = driverVersion == info->version;
51736:       break;
51736:     case DRIVER_NOT_EQUAL:
51736:       match = driverVersion != info->version;
51736:       break;
51736:     case DRIVER_BETWEEN_EXCLUSIVE:
51736:       match = driverVersion > info->version && driverVersion < info->versionMax;
51736:       break;
51736:     case DRIVER_BETWEEN_INCLUSIVE:
51736:       match = driverVersion >= info->version && driverVersion <= info->versionMax;
51736:       break;
51736:     case DRIVER_BETWEEN_INCLUSIVE_START:
51736:       match = driverVersion >= info->version && driverVersion < info->versionMax;
51736:       break;
51736:     default:
51736:       NS_WARNING("Bogus op in GfxDriverInfo");
51736:       break;
51736:     }
51736: 
51736:     if (match) {
54145:       if (info->feature == allFeatures ||
51736:           info->feature == aFeature)
51736:       {
51736:         status = info->featureStatus;
51736:         break;
51736:       }
51736:     }
51736: 
51736:     info++;
51736:   }
51736: 
51736:   *aStatus = status;
51736:   return NS_OK;
51736: }
54145: 
