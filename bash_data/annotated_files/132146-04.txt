     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* interface for all rendering objects */
     1: 
     1: #ifndef nsIFrame_h___
     1: #define nsIFrame_h___
     1: 
 58487: #ifndef MOZILLA_INTERNAL_API
 58487: #error This header/class should only be used within Mozilla code. It should not be used by extensions.
 58487: #endif
 58487: 
 93996: #define MAX_REFLOW_DEPTH 200
 93996: 
     1: /* nsIFrame is in the process of being deCOMtaminated, i.e., this file is eventually
     1:    going to be eliminated, and all callers will use nsFrame instead.  At the moment
     1:    we're midway through this process, so you will see inlined functions and member
     1:    variables in this file.  -dwh */
     1: 
     1: #include <stdio.h>
 23554: #include "nsQueryFrame.h"
107226: #include "nsStyleContext.h"
     1: #include "nsStyleStruct.h"
107226: #include "nsStyleStructFwd.h"
107519: #include "nsHTMLReflowMetrics.h"
107519: #include "nsFrameList.h"
     1: #include "nsIContent.h"
 32531: #include "nsAlgorithm.h"
 77152: #include "mozilla/layout/FrameChildList.h"
 39965: #include "FramePropertyTable.h"
131056: #include "mozilla/TypedEnum.h"
129543: #include <algorithm>
     1: 
118929: #ifdef ACCESSIBILITY
118929: #include "mozilla/a11y/AccTypes.h"
118929: #endif
118929: 
     1: /**
     1:  * New rules of reflow:
     1:  * 1. you get a WillReflow() followed by a Reflow() followed by a DidReflow() in order
     1:  *    (no separate pass over the tree)
     1:  * 2. it's the parent frame's responsibility to size/position the child's view (not
     1:  *    the child frame's responsibility as it is today) during reflow (and before
     1:  *    sending the DidReflow() notification)
     1:  * 3. positioning of child frames (and their views) is done on the way down the tree,
     1:  *    and sizing of child frames (and their views) on the way back up
     1:  * 4. if you move a frame (outside of the reflow process, or after reflowing it),
     1:  *    then you must make sure that its view (or its child frame's views) are re-positioned
     1:  *    as well. It's reasonable to not position the view until after all reflowing the
     1:  *    entire line, for example, but the frame should still be positioned and sized (and
     1:  *    the view sized) during the reflow (i.e., before sending the DidReflow() notification)
     1:  * 5. the view system handles moving of widgets, i.e., it's not our problem
     1:  */
     1: 
     1: struct nsHTMLReflowState;
     1: class nsHTMLReflowCommand;
     1: 
107519: struct gfxMatrix;
     1: class nsIAtom;
     1: class nsPresContext;
     1: class nsIPresShell;
 68481: class nsRenderingContext;
127357: class nsView;
     1: class nsIWidget;
     1: class nsIDOMRange;
     1: class nsISelectionController;
     1: class nsBoxLayoutState;
 73636: class nsBoxLayout;
 21112: class nsILineIterator;
     1: class nsDisplayListBuilder;
     1: class nsDisplayListSet;
     1: class nsDisplayList;
  4261: class gfxSkipChars;
  4261: class gfxSkipCharsIterator;
  6862: class gfxContext;
  6029: class nsLineList_iterator;
 79482: class nsAbsoluteContainingBlock;
     1: 
     1: struct nsPeekOffsetStruct;
     1: struct nsPoint;
     1: struct nsRect;
     1: struct nsSize;
     1: struct nsMargin;
 31131: struct CharacterDataChangeInfo;
     1: 
 64542: namespace mozilla {
 64542: namespace layers {
 64542: class Layer;
 64542: }
 64542: }
 64542: 
     1: /**
     1:  * Indication of how the frame can be split. This is used when doing runaround
     1:  * of floats, and when pulling up child frames from a next-in-flow.
     1:  *
     1:  * The choices are splittable, not splittable at all, and splittable in
     1:  * a non-rectangular fashion. This last type only applies to block-level
     1:  * elements, and indicates whether splitting can be used when doing runaround.
     1:  * If you can split across page boundaries, but you expect each continuing
     1:  * frame to be the same width then return frSplittable and not
     1:  * frSplittableNonRectangular.
     1:  *
     1:  * @see #GetSplittableType()
     1:  */
108991: typedef uint32_t nsSplittableType;
     1: 
     1: #define NS_FRAME_NOT_SPLITTABLE             0   // Note: not a bit!
     1: #define NS_FRAME_SPLITTABLE                 0x1
     1: #define NS_FRAME_SPLITTABLE_NON_RECTANGULAR 0x3
     1: 
     1: #define NS_FRAME_IS_SPLITTABLE(type)\
     1:   (0 != ((type) & NS_FRAME_SPLITTABLE))
     1: 
     1: #define NS_FRAME_IS_NOT_SPLITTABLE(type)\
     1:   (0 == ((type) & NS_FRAME_SPLITTABLE))
     1: 
     1: #define NS_INTRINSIC_WIDTH_UNKNOWN nscoord_MIN
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: /**
     1:  * Frame state bits. Any bits not listed here are reserved for future
     1:  * extensions, but must be stored by the frames.
     1:  */
108991: typedef uint64_t nsFrameState;
     1: 
 43376: #define NS_FRAME_STATE_BIT(n_) (nsFrameState(1) << (n_))
 43376: 
 46278: #define NS_FRAME_IN_REFLOW                          NS_FRAME_STATE_BIT(0)
  2596: 
     1: // This bit is set when a frame is created. After it has been reflowed
     1: // once (during the DidReflow with a finished state) the bit is
     1: // cleared.
 46278: #define NS_FRAME_FIRST_REFLOW                       NS_FRAME_STATE_BIT(1)
     1: 
     1: // For a continuation frame, if this bit is set, then this a "fluid" 
     1: // continuation, i.e., across a line boundary. Otherwise it's a "hard"
     1: // continuation, e.g. a bidi continuation.
 46278: #define NS_FRAME_IS_FLUID_CONTINUATION              NS_FRAME_STATE_BIT(2)
     1: 
     1: // If this bit is set, then a reference to the frame is being held
     1: // elsewhere.  The frame may want to send a notification when it is
     1: // destroyed to allow these references to be cleared.
 46278: #define NS_FRAME_EXTERNAL_REFERENCE                 NS_FRAME_STATE_BIT(4)
     1: 
     1: // If this bit is set, this frame or one of its descendants has a
     1: // percentage height that depends on an ancestor of this frame.
     1: // (Or it did at one point in the past, since we don't necessarily clear
     1: // the bit when it's no longer needed; it's an optimization.)
 46278: #define  NS_FRAME_CONTAINS_RELATIVE_HEIGHT          NS_FRAME_STATE_BIT(5)
     1: 
     1: // If this bit is set, then the frame corresponds to generated content
 46278: #define NS_FRAME_GENERATED_CONTENT                  NS_FRAME_STATE_BIT(6)
     1: 
  4006: // If this bit is set the frame is a continuation that is holding overflow,
  4006: // i.e. it is a next-in-flow created to hold overflow after the box's
  4006: // height has ended. This means the frame should be a) at the top of the
  4006: // page and b) invisible: no borders, zero height, ignored in margin
  4006: // collapsing, etc. See nsContainerFrame.h
 46278: #define NS_FRAME_IS_OVERFLOW_CONTAINER              NS_FRAME_STATE_BIT(7)
  4006: 
     1: // If this bit is set, then the frame has been moved out of the flow,
     1: // e.g., it is absolutely positioned or floated
 46278: #define NS_FRAME_OUT_OF_FLOW                        NS_FRAME_STATE_BIT(8)
     1: 
120781: // Frame can be an abs/fixed pos. container, if its style says so.
120781: // MarkAs[Not]AbsoluteContainingBlock will assert that this bit is set.
120781: // NS_FRAME_HAS_ABSPOS_CHILDREN must not be set when this bit is unset.
120781: #define NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN           NS_FRAME_STATE_BIT(9)
     1: 
110619: // If this bit is set, then the frame and _all_ of its descendant frames need
110619: // to be reflowed.
     1: // This bit is set when the frame is first created.
     1: // This bit is cleared by DidReflow after the required call to Reflow has
     1: // finished.
  1158: // Do not set this bit yourself if you plan to pass the frame to
  1158: // nsIPresShell::FrameNeedsReflow.  Pass the right arguments instead.
 46278: #define NS_FRAME_IS_DIRTY                           NS_FRAME_STATE_BIT(10)
     1: 
  3724: // If this bit is set then the frame is too deep in the frame tree, and
  3724: // we'll stop updating it and its children, to prevent stack overflow
  3724: // and the like.
 46278: #define NS_FRAME_TOO_DEEP_IN_FRAME_TREE             NS_FRAME_STATE_BIT(11)
     1: 
110619: // If this bit is set, then either:
110619: //  1. the frame has at least one child that has the NS_FRAME_IS_DIRTY bit or
110619: //     NS_FRAME_HAS_DIRTY_CHILDREN bit set, or
110619: //  2. the frame has had at least one child removed since the last reflow, or
110619: //  3. the frame has had a style change that requires the frame to be reflowed
110619: //     but does not _necessarily_ require its descendants to be reflowed (e.g.,
110619: //     for a 'height', 'width', 'margin', etc. change, it's up to the
110619: //     applicable Reflow methods to decide whether the frame's children
110619: //     _actually_ need to be reflowed).
110619: // If this bit is set but the NS_FRAME_IS_DIRTY is not set, then Reflow still
110619: // needs to be called on the frame, but Reflow will likely not do as much work
110619: // as it would if NS_FRAME_IS_DIRTY were set. See the comment documenting
110619: // nsFrame::Reflow for more.
     1: // This bit is cleared by DidReflow after the required call to Reflow has
     1: // finished.
  1158: // Do not set this bit yourself if you plan to pass the frame to
  1158: // nsIPresShell::FrameNeedsReflow.  Pass the right arguments instead.
 46278: #define NS_FRAME_HAS_DIRTY_CHILDREN                 NS_FRAME_STATE_BIT(12)
     1: 
     1: // If this bit is set, the frame has an associated view
 46278: #define NS_FRAME_HAS_VIEW                           NS_FRAME_STATE_BIT(13)
     1: 
     1: // If this bit is set, the frame was created from anonymous content.
 46278: #define NS_FRAME_INDEPENDENT_SELECTION              NS_FRAME_STATE_BIT(14)
     1: 
     1: // If this bit is set, the frame is "special" (lame term, I know),
     1: // which means that it is part of the mangled frame hierarchy that
     1: // results when an inline has been split because of a nested block.
 34462: // See the comments in nsCSSFrameConstructor::ConstructInline for
 34462: // more details.
 46278: #define NS_FRAME_IS_SPECIAL                         NS_FRAME_STATE_BIT(15)
     1: 
 98711: // If this bit is set, then transforms (e.g. CSS or SVG transforms) are allowed
 98711: // to affect the frame, and a transform may currently be in affect. If this bit
 98711: // is not set, then any transforms on the frame will be ignored.
 19214: // This is used primarily in GetTransformMatrix to optimize for the
 19214: // common case.
 50423: #define  NS_FRAME_MAY_BE_TRANSFORMED                NS_FRAME_STATE_BIT(16)
     1: 
     1: #ifdef IBMBIDI
     1: // If this bit is set, the frame itself is a bidi continuation,
     1: // or is incomplete (its next sibling is a bidi continuation)
 46278: #define NS_FRAME_IS_BIDI                            NS_FRAME_STATE_BIT(17)
     1: #endif
     1: 
     1: // If this bit is set the frame has descendant with a view
 46278: #define NS_FRAME_HAS_CHILD_WITH_VIEW                NS_FRAME_STATE_BIT(18)
     1: 
     1: // If this bit is set, then reflow may be dispatched from the current
     1: // frame instead of the root frame.
 46278: #define NS_FRAME_REFLOW_ROOT                        NS_FRAME_STATE_BIT(19)
     1: 
 49293: // Bits 20-31 and 60-63 of the frame state are reserved for implementations.
 49293: #define NS_FRAME_IMPL_RESERVED                      nsFrameState(0xF0000000FFF00000)
 85101: #define NS_FRAME_RESERVED                           ~NS_FRAME_IMPL_RESERVED
     1: 
 48989: // This bit is set on floats whose parent does not contain their
 48989: // placeholder.  This can happen for two reasons:  (1) the float was
 48989: // split, and this piece is the continuation, or (2) the entire float
 48989: // didn't fit on the page.
110845: // Note that this bit is also shared by text frames for
110845: // TEXT_FORCE_TRIM_WHITESPACE.  That's OK because we only check the
110845: // NS_FRAME_IS_PUSHED_FLOAT bit on frames which we already know are
110845: // out-of-flow.
 49010: #define NS_FRAME_IS_PUSHED_FLOAT                    NS_FRAME_STATE_BIT(32)
 48989: 
 50435: // This bit acts as a loop flag for recursive paint server drawing.
 50435: #define NS_FRAME_DRAWING_AS_PAINTSERVER             NS_FRAME_STATE_BIT(33)
 50435: 
103528: // Frame is a display root and the retained layer tree needs to be updated
103528: // at the next paint via display list construction.
103528: // Only meaningful for display roots, so we don't really need a global state
103528: // bit; we could free up this bit with a little extra complexity.
103528: #define NS_FRAME_UPDATE_LAYER_TREE                  NS_FRAME_STATE_BIT(36)
103528: 
 79482: // Frame can accept absolutely positioned children.
 79482: #define NS_FRAME_HAS_ABSPOS_CHILDREN                NS_FRAME_STATE_BIT(37)
 79482: 
 80875: // A display item for this frame has been painted as part of a ThebesLayer.
 80875: #define NS_FRAME_PAINTED_THEBES                     NS_FRAME_STATE_BIT(38)
 80875: 
 93983: // Frame is or is a descendant of something with a fixed height, unless that
 93983: // ancestor is a body or html element, and has no closer ancestor that is
 93983: // overflow:auto or overflow:scroll.
 82666: #define NS_FRAME_IN_CONSTRAINED_HEIGHT              NS_FRAME_STATE_BIT(39)
 82666: 
 82668: // This is only set during painting
 82668: #define NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO    NS_FRAME_STATE_BIT(40)
 82668: 
 88118: // Is this frame a container for font size inflation, i.e., is it a
 88118: // frame whose width is used to determine the inflation factor for
 88118: // everything whose nearest ancestor container for this frame?
 88118: #define NS_FRAME_FONT_INFLATION_CONTAINER           NS_FRAME_STATE_BIT(41)
 88118: 
 95533: // Does this frame manage a region in which we do font size inflation,
 95533: // i.e., roughly, is it an element establishing a new block formatting
 95533: // context?
 95533: #define NS_FRAME_FONT_INFLATION_FLOW_ROOT           NS_FRAME_STATE_BIT(42)
 95533: 
 98711: // This bit is set on SVG frames that are laid out using SVG's coordinate
 98711: // system based layout (as opposed to any of the CSS layout models). Note that
 98711: // this does not include nsSVGOuterSVGFrame since it takes part is CSS layout.
 98711: #define NS_FRAME_SVG_LAYOUT                         NS_FRAME_STATE_BIT(43)
 98711: 
 99736: // Is this frame allowed to have generated (::before/::after) content?
 99736: #define NS_FRAME_MAY_HAVE_GENERATED_CONTENT         NS_FRAME_STATE_BIT(44)
 99736: 
106095: // This bit is set on frames that create ContainerLayers with component
106095: // alpha children. With BasicLayers we avoid creating these, so we mark
106095: // the frames for future reference.
106095: #define NS_FRAME_NO_COMPONENT_ALPHA                 NS_FRAME_STATE_BIT(45)
106095: 
107214: // The frame is a descendant of nsSVGTextFrame2 and is thus used for SVG
107214: // text layout.
107214: #define NS_FRAME_IS_SVG_TEXT                        NS_FRAME_STATE_BIT(47)
107214: 
115304: // Frame is marked as needing painting
115304: #define NS_FRAME_NEEDS_PAINT                        NS_FRAME_STATE_BIT(48)
115304: 
115304: // Frame has a descendant frame that needs painting - This includes
115304: // cross-doc children.
115304: #define NS_FRAME_DESCENDANT_NEEDS_PAINT             NS_FRAME_STATE_BIT(49)
115304: 
115304: // Frame is a descendant of a popup
115304: #define NS_FRAME_IN_POPUP                           NS_FRAME_STATE_BIT(50)
115304: 
115314: // Frame has only descendant frames that needs painting - This includes
115314: // cross-doc children. This guarantees that all descendents have 
115314: // NS_FRAME_NEEDS_PAINT and NS_FRAME_ALL_DESCENDANTS_NEED_PAINT, or they 
115314: // have no display items.
115314: #define NS_FRAME_ALL_DESCENDANTS_NEED_PAINT         NS_FRAME_STATE_BIT(51)
115314: 
115327: // Frame is marked as NS_FRAME_NEEDS_PAINT and also has an explicit
115327: // rect stored to invalidate.
115327: #define NS_FRAME_HAS_INVALID_RECT                   NS_FRAME_STATE_BIT(52)
115327: 
     1: // Box layout bits
 46278: #define NS_STATE_IS_HORIZONTAL                      NS_FRAME_STATE_BIT(22)
 46278: #define NS_STATE_IS_DIRECTION_NORMAL                NS_FRAME_STATE_BIT(31)
     1: 
  1158: // Helper macros
  1158: #define NS_SUBTREE_DIRTY(_frame)  \
  1158:   (((_frame)->GetStateBits() &      \
  1158:     (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN)) != 0)
  1158: 
     1: //----------------------------------------------------------------------
     1: 
     1: enum nsSelectionAmount {
 59604:   eSelectCharacter = 0, // a single Unicode character;
 59604:                         // do not use this (prefer Cluster) unless you
 59604:                         // are really sure it's what you want
 59604:   eSelectCluster   = 1, // a grapheme cluster: this is usually the right
 59604:                         // choice for movement or selection by "character"
 59604:                         // as perceived by the user
 59604:   eSelectWord      = 2,
 59604:   eSelectLine      = 3, // previous drawn line in flow.
 59604:   eSelectBeginLine = 4,
 59604:   eSelectEndLine   = 5,
 59604:   eSelectNoAmount  = 6, // just bounce back current offset.
 63601:   eSelectParagraph = 7,  // select a "paragraph"
 63601:   eSelectWordNoSpace = 8 // select a "word" without selecting the following
 63601:                          // space, no matter what the default platform
 63601:                          // behavior is
     1: };
     1: 
     1: enum nsDirection {
     1:   eDirNext    = 0,
     1:   eDirPrevious= 1
     1: };
     1: 
     1: enum nsSpread {
     1:   eSpreadNone   = 0,
     1:   eSpreadAcross = 1,
     1:   eSpreadDown   = 2
     1: };
     1: 
     1: // Carried out margin flags
     1: #define NS_CARRIED_TOP_MARGIN_IS_AUTO    0x1
     1: #define NS_CARRIED_BOTTOM_MARGIN_IS_AUTO 0x2
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: /**
  4006:  * Reflow status returned by the reflow methods. There are three
  4006:  * completion statuses, represented by two bit flags.
  4006:  *
  4006:  * NS_FRAME_COMPLETE means the frame is fully complete.
     1:  *
     1:  * NS_FRAME_NOT_COMPLETE bit flag means the frame does not map all its
     1:  * content, and that the parent frame should create a continuing frame.
     1:  * If this bit isn't set it means the frame does map all its content.
  4006:  * This bit is mutually exclusive with NS_FRAME_OVERFLOW_INCOMPLETE.
  4006:  *
  4006:  * NS_FRAME_OVERFLOW_INCOMPLETE bit flag means that the frame has
  4006:  * overflow that is not complete, but its own box is complete.
  4006:  * (This happens when content overflows a fixed-height box.)
  4006:  * The reflower should place and size the frame and continue its reflow,
  4006:  * but needs to create an overflow container as a continuation for this
  4006:  * frame. See nsContainerFrame.h for more information.
  4006:  * This bit is mutually exclusive with NS_FRAME_NOT_COMPLETE.
  4006:  * 
 15183:  * Please use the SET macro for handling
  4006:  * NS_FRAME_NOT_COMPLETE and NS_FRAME_OVERFLOW_INCOMPLETE.
     1:  *
     1:  * NS_FRAME_REFLOW_NEXTINFLOW bit flag means that the next-in-flow is
     1:  * dirty, and also needs to be reflowed. This status only makes sense
     1:  * for a frame that is not complete, i.e. you wouldn't set both
  4006:  * NS_FRAME_COMPLETE and NS_FRAME_REFLOW_NEXTINFLOW.
     1:  *
     1:  * The low 8 bits of the nsReflowStatus are reserved for future extensions;
     1:  * the remaining 24 bits are zero (and available for extensions; however
     1:  * API's that accept/return nsReflowStatus must not receive/return any
     1:  * extension bits).
     1:  *
     1:  * @see #Reflow()
     1:  */
108991: typedef uint32_t nsReflowStatus;
     1: 
     1: #define NS_FRAME_COMPLETE             0       // Note: not a bit!
     1: #define NS_FRAME_NOT_COMPLETE         0x1
     1: #define NS_FRAME_REFLOW_NEXTINFLOW    0x2
  4006: #define NS_FRAME_OVERFLOW_INCOMPLETE  0x4
     1: 
     1: #define NS_FRAME_IS_COMPLETE(status) \
     1:   (0 == ((status) & NS_FRAME_NOT_COMPLETE))
     1: 
     1: #define NS_FRAME_IS_NOT_COMPLETE(status) \
     1:   (0 != ((status) & NS_FRAME_NOT_COMPLETE))
     1: 
  4006: #define NS_FRAME_OVERFLOW_IS_INCOMPLETE(status) \
  4006:   (0 != ((status) & NS_FRAME_OVERFLOW_INCOMPLETE))
  4006: 
  4006: #define NS_FRAME_IS_FULLY_COMPLETE(status) \
  4006:   (NS_FRAME_IS_COMPLETE(status) && !NS_FRAME_OVERFLOW_IS_INCOMPLETE(status))
  4006: 
  4006: // These macros set or switch incompete statuses without touching th
  4006: // NS_FRAME_REFLOW_NEXTINFLOW bit.
  4006: #define NS_FRAME_SET_INCOMPLETE(status) \
 19264:   status = (status & ~NS_FRAME_OVERFLOW_INCOMPLETE) | NS_FRAME_NOT_COMPLETE
  4006: 
  4006: #define NS_FRAME_SET_OVERFLOW_INCOMPLETE(status) \
 19264:   status = (status & ~NS_FRAME_NOT_COMPLETE) | NS_FRAME_OVERFLOW_INCOMPLETE
  4006: 
     1: // This macro tests to see if an nsReflowStatus is an error value
     1: // or just a regular return value
108991: #define NS_IS_REFLOW_ERROR(_status) (int32_t(_status) < 0)
     1: 
     1: /**
     1:  * Extensions to the reflow status bits defined by nsIFrameReflow
     1:  */
     1: 
     1: // This bit is set, when a break is requested. This bit is orthogonal
     1: // to the nsIFrame::nsReflowStatus completion bits.
     1: #define NS_INLINE_BREAK              0x0100
     1: 
     1: // When a break is requested, this bit when set indicates that the
     1: // break should occur after the frame just reflowed; when the bit is
     1: // clear the break should occur before the frame just reflowed.
     1: #define NS_INLINE_BREAK_BEFORE       0x0000
     1: #define NS_INLINE_BREAK_AFTER        0x0200
     1: 
     1: // The type of break requested can be found in these bits.
     1: #define NS_INLINE_BREAK_TYPE_MASK    0xF000
     1: 
 16409: // Set when a break was induced by completion of a first-letter
 16409: #define NS_INLINE_BREAK_FIRST_LETTER_COMPLETE 0x10000
 16409: 
     1: //----------------------------------------
     1: // Macros that use those bits
     1: 
     1: #define NS_INLINE_IS_BREAK(_status) \
     1:   (0 != ((_status) & NS_INLINE_BREAK))
     1: 
     1: #define NS_INLINE_IS_BREAK_AFTER(_status) \
     1:   (0 != ((_status) & NS_INLINE_BREAK_AFTER))
     1: 
     1: #define NS_INLINE_IS_BREAK_BEFORE(_status) \
     1:   (NS_INLINE_BREAK == ((_status) & (NS_INLINE_BREAK|NS_INLINE_BREAK_AFTER)))
     1: 
     1: #define NS_INLINE_GET_BREAK_TYPE(_status) (((_status) >> 12) & 0xF)
     1: 
     1: #define NS_INLINE_MAKE_BREAK_TYPE(_type)  ((_type) << 12)
     1: 
     1: // Construct a line-break-before status. Note that there is no
     1: // completion status for a line-break before because we *know* that
     1: // the frame will be reflowed later and hence it's current completion
     1: // status doesn't matter.
     1: #define NS_INLINE_LINE_BREAK_BEFORE()                                   \
     1:   (NS_INLINE_BREAK | NS_INLINE_BREAK_BEFORE |                           \
     1:    NS_INLINE_MAKE_BREAK_TYPE(NS_STYLE_CLEAR_LINE))
     1: 
     1: // Take a completion status and add to it the desire to have a
     1: // line-break after. For this macro we do need the completion status
     1: // because the user of the status will need to know whether to
     1: // continue the frame or not.
     1: #define NS_INLINE_LINE_BREAK_AFTER(_completionStatus)                   \
     1:   ((_completionStatus) | NS_INLINE_BREAK | NS_INLINE_BREAK_AFTER |      \
     1:    NS_INLINE_MAKE_BREAK_TYPE(NS_STYLE_CLEAR_LINE))
     1: 
 48981: // A frame is "truncated" if the part of the frame before the first
 48981: // possible break point was unable to fit in the available vertical
 48981: // space.  Therefore, the entire frame should be moved to the next page.
 48981: // A frame that begins at the top of the page must never be "truncated".
 48981: // Doing so would likely cause an infinite loop.
     1: #define NS_FRAME_TRUNCATED  0x0010
     1: #define NS_FRAME_IS_TRUNCATED(status) \
     1:   (0 != ((status) & NS_FRAME_TRUNCATED))
     1: #define NS_FRAME_SET_TRUNCATION(status, aReflowState, aMetrics) \
     1:   aReflowState.SetTruncated(aMetrics, &status);
     1: 
 15183: // Merge the incompleteness, truncation and NS_FRAME_REFLOW_NEXTINFLOW
 15183: // status from aSecondary into aPrimary.
 15183: void NS_MergeReflowStatusInto(nsReflowStatus* aPrimary,
 15183:                               nsReflowStatus aSecondary);
 15183: 
     1: //----------------------------------------------------------------------
     1: 
     1: /**
     1:  * DidReflow status values.
     1:  */
121889: MOZ_BEGIN_ENUM_CLASS(nsDidReflowStatus, uint32_t)
121889:   NOT_FINISHED,
121889:   FINISHED
121889: MOZ_END_ENUM_CLASS(nsDidReflowStatus)
     1: 
 26950: /**
 55021:  * When there is no scrollable overflow rect, the visual overflow rect
 55021:  * may be stored as four 1-byte deltas each strictly LESS THAN 0xff, for
 55021:  * the four edges of the rectangle, or the four bytes may be read as a
 55021:  * single 32-bit "overflow-rect type" value including at least one 0xff
 55021:  * byte as an indicator that the value does NOT represent four deltas.
 26950:  * If all four deltas are zero, this means that no overflow rect has
 26950:  * actually been set (this is the initial state of newly-created frames).
 26950:  */
 26950: #define NS_FRAME_OVERFLOW_DELTA_MAX     0xfe // max delta we can store
 26950: 
 55021: #define NS_FRAME_OVERFLOW_NONE    0x00000000 // there are no overflow rects;
 26950:                                              // code relies on this being
 26950:                                              // the all-zero value
 26950: 
 26950: #define NS_FRAME_OVERFLOW_LARGE   0x000000ff // overflow is stored as a
 26950:                                              // separate rect property
 26950: 
     1: //----------------------------------------------------------------------
     1: 
     1: /**
     1:  * A frame in the layout model. This interface is supported by all frame
     1:  * objects.
     1:  *
 77154:  * Frames can have multiple child lists: the default child list
     1:  * (referred to as the <i>principal</i> child list, and additional named
     1:  * child lists. There is an ordering of frames within a child list, but
     1:  * there is no order defined between frames in different child lists of
     1:  * the same parent frame.
     1:  *
     1:  * Frames are NOT reference counted. Use the Destroy() member function
     1:  * to destroy a frame. The lifetime of the frame hierarchy is bounded by the
     1:  * lifetime of the presentation shell which owns the frames.
     1:  *
     1:  * nsIFrame is a private Gecko interface. If you are not Gecko then you
     1:  * should not use it. If you're not in layout, then you won't be able to
     1:  * link to many of the functions defined here. Too bad.
     1:  *
     1:  * If you're not in layout but you must call functions in here, at least
     1:  * restrict yourself to calling virtual methods, which won't hurt you as badly.
     1:  */
 23554: class nsIFrame : public nsQueryFrame
     1: {
     1: public:
 39965:   typedef mozilla::FramePropertyDescriptor FramePropertyDescriptor;
 39965:   typedef mozilla::FrameProperties FrameProperties;
 64542:   typedef mozilla::layers::Layer Layer;
 77152:   typedef mozilla::layout::FrameChildList ChildList;
 77152:   typedef mozilla::layout::FrameChildListID ChildListID;
 77152:   typedef mozilla::layout::FrameChildListIDs ChildListIDs;
 77152:   typedef mozilla::layout::FrameChildListIterator ChildListIterator;
 77152:   typedef mozilla::layout::FrameChildListArrayIterator ChildListArrayIterator;
 39965: 
 32423:   NS_DECL_QUERYFRAME_TARGET(nsIFrame)
     1: 
   238:   nsPresContext* PresContext() const {
     1:     return GetStyleContext()->GetRuleNode()->GetPresContext();
     1:   }
     1: 
     1:   /**
     1:    * Called to initialize the frame. This is called immediately after creating
     1:    * the frame.
     1:    *
     1:    * If the frame is a continuing frame, then aPrevInFlow indicates the previous
  3707:    * frame (the frame that was split).
     1:    *
     1:    * If you want a view associated with your frame, you should create the view
     1:    * now.
     1:    *
     1:    * @param   aContent the content object associated with the frame
     1:    * @param   aGeometricParent  the geometric parent frame
     1:    * @param   aContentParent  the content parent frame
     1:    * @param   aContext the style context associated with the frame
     1:    * @param   aPrevInFlow the prev-in-flow frame
     1:    */
     1:   NS_IMETHOD  Init(nsIContent*      aContent,
     1:                    nsIFrame*        aParent,
     1:                    nsIFrame*        aPrevInFlow) = 0;
     1: 
     1:   /**
     1:    * Destroys this frame and each of its child frames (recursively calls
 36646:    * Destroy() for each child). If this frame is a first-continuation, this
 78012:    * also removes the frame from the primary frame map and clears undisplayed
 36646:    * content for its content node.
 36646:    * If the frame is a placeholder, it also ensures the out-of-flow frame's
 36646:    * removal and destruction.
     1:    */
 36647:   void Destroy() { DestroyFrom(this); }
 36647: 
 36647: protected:
 36647:   /**
 85101:    * Return true if the frame is part of a Selection.
 85101:    * Helper method to implement the public IsSelected() API.
 85101:    */
 85101:   virtual bool IsFrameSelected() const;
 85101: 
 85101:   /**
 36647:    * Implements Destroy(). Do not call this directly except from within a
 36647:    * DestroyFrom() implementation.
 82099:    *
 82099:    * @note This will always be called, so it is not necessary to override
 82099:    *       Destroy() in subclasses of nsFrame, just DestroyFrom().
 82099:    *
 36647:    * @param  aDestructRoot is the root of the subtree being destroyed
 36647:    */
 36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot) = 0;
 36647:   friend class nsFrameList; // needed to pass aDestructRoot through to children
 36647:   friend class nsLineBox;   // needed to pass aDestructRoot through to children
132146:   friend class nsContainerFrame; // needed to pass aDestructRoot through to children
 36647: public:
     1: 
     1:   /**
     1:    * Called to set the initial list of frames. This happens after the frame
     1:    * has been initialized.
     1:    *
     1:    * This is only called once for a given child list, and won't be called
     1:    * at all for child lists with no initial list of frames.
     1:    *
 77154:    * @param   aListID the child list identifier.
     1:    * @param   aChildList list of child frames. Each of the frames has its
 30941:    *            NS_FRAME_IS_DIRTY bit set.  Must not be empty.
 79483:    *            This method cannot handle the child list returned by
 79483:    *            GetAbsoluteListID().
     1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
     1:    *            name,
     1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame or if the
     1:    *            initial list of frames has already been set for that child list,
 30790:    *          NS_OK otherwise.  In this case, SetInitialChildList empties out
 30790:    *            aChildList in the process of moving the frames over to its own
 30790:    *            child list.
     1:    * @see     #Init()
     1:    */
 77154:   NS_IMETHOD  SetInitialChildList(ChildListID     aListID,
 30790:                                   nsFrameList&    aChildList) = 0;
     1: 
     1:   /**
     1:    * This method is responsible for appending frames to the frame
     1:    * list.  The implementation should append the frames to the specified
     1:    * child list and then generate a reflow command.
     1:    *
 77154:    * @param   aListID the child list identifier.
     1:    * @param   aFrameList list of child frames to append. Each of the frames has
 30941:    *            its NS_FRAME_IS_DIRTY bit set.  Must not be empty.
     1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
     1:    *            name,
     1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame,
 30941:    *          NS_OK otherwise.  In this case, AppendFrames empties out
104655:    *            aFrameList in the process of moving the frames over to its own
 30941:    *            child list.
     1:    */
 77154:   NS_IMETHOD AppendFrames(ChildListID     aListID,
 30941:                           nsFrameList&    aFrameList) = 0;
     1: 
     1:   /**
     1:    * This method is responsible for inserting frames into the frame
     1:    * list.  The implementation should insert the new frames into the specified
     1:    * child list and then generate a reflow command.
     1:    *
 77154:    * @param   aListID the child list identifier.
     1:    * @param   aPrevFrame the frame to insert frames <b>after</b>
     1:    * @param   aFrameList list of child frames to insert <b>after</b> aPrevFrame.
     1:    *            Each of the frames has its NS_FRAME_IS_DIRTY bit set
     1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
     1:    *            name,
     1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame,
 30941:    *          NS_OK otherwise.  In this case, InsertFrames empties out
104655:    *            aFrameList in the process of moving the frames over to its own
 30941:    *            child list.
     1:    */
 77154:   NS_IMETHOD InsertFrames(ChildListID     aListID,
     1:                           nsIFrame*       aPrevFrame,
 30941:                           nsFrameList&    aFrameList) = 0;
     1: 
     1:   /**
     1:    * This method is responsible for removing a frame in the frame
     1:    * list.  The implementation should do something with the removed frame
     1:    * and then generate a reflow command. The implementation is responsible
     1:    * for destroying aOldFrame (the caller mustn't destroy aOldFrame).
     1:    *
 77154:    * @param   aListID the child list identifier.
     1:    * @param   aOldFrame the frame to remove
     1:    * @return  NS_ERROR_INVALID_ARG if there is no child list with the specified
     1:    *            name,
     1:    *          NS_ERROR_FAILURE if the child frame is not in the specified
     1:    *            child list,
     1:    *          NS_ERROR_UNEXPECTED if the frame is an atomic frame,
     1:    *          NS_OK otherwise
     1:    */
 77154:   NS_IMETHOD RemoveFrame(ChildListID     aListID,
     1:                          nsIFrame*       aOldFrame) = 0;
     1: 
     1:   /**
     1:    * Get the content object associated with this frame. Does not add a reference.
     1:    */
     1:   nsIContent* GetContent() const { return mContent; }
     1: 
     1:   /**
     1:    * Get the frame that should be the parent for the frames of child elements
106838:    * May return nullptr during reflow
     1:    */
     1:   virtual nsIFrame* GetContentInsertionFrame() { return this; }
     1: 
     1:   /**
114181:    * Move any frames on our overflow list to the end of our principal list.
114181:    * @return true if there were any overflow frames
114181:    */
114181:   virtual bool DrainSelfOverflowList() { return false; }
114181: 
114181:   /**
 37056:    * Get the frame that should be scrolled if the content associated
 37056:    * with this frame is targeted for scrolling. For frames implementing
 37056:    * nsIScrollableFrame this will return the frame itself. For frames
 37056:    * like nsTextControlFrame that contain a scrollframe, will return
 37056:    * that scrollframe.
 37056:    */
106838:   virtual nsIScrollableFrame* GetScrollTargetFrame() { return nullptr; }
 37056: 
 37056:   /**
     1:    * Get the offsets of the frame. most will be 0,0
     1:    *
     1:    */
108991:   NS_IMETHOD GetOffsets(int32_t &start, int32_t &end) const = 0;
     1: 
     1:   /**
     1:    * Reset the offsets when splitting frames during Bidi reordering
     1:    *
     1:    */
108991:   virtual void AdjustOffsetsForBidi(int32_t aStart, int32_t aEnd) {}
     1: 
     1:   /**
     1:    * Get the style context associated with this frame.
     1:    *
     1:    */
     1:   nsStyleContext* GetStyleContext() const { return mStyleContext; }
     1:   void SetStyleContext(nsStyleContext* aContext)
     1:   { 
     1:     if (aContext != mStyleContext) {
 20836:       nsStyleContext* oldStyleContext = mStyleContext;
     1:       mStyleContext = aContext;
     1:       if (aContext) {
     1:         aContext->AddRef();
 20836:         DidSetStyleContext(oldStyleContext);
     1:       }
 20836:       if (oldStyleContext)
 20836:         oldStyleContext->Release();
     1:     }
     1:   }
     1:   
     1:   void SetStyleContextWithoutNotification(nsStyleContext* aContext)
     1:   {
     1:     if (aContext != mStyleContext) {
     1:       if (mStyleContext)
     1:         mStyleContext->Release();
     1:       mStyleContext = aContext;
     1:       if (aContext) {
     1:         aContext->AddRef();
     1:       }
     1:     }
     1:   }
     1: 
     1:   // Style post processing hook
 20836:   // Attention: the old style context is the one we're forgetting,
 20836:   // and hence possibly completely bogus for GetStyle* purposes.
 20836:   // Use PeekStyleData instead.
 20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext) = 0;
     1: 
     1:   /**
     1:    * Get the style data associated with this frame.  This returns a
     1:    * const style struct pointer that should never be modified.  See
     1:    * |nsIStyleContext::GetStyleData| for more information.
     1:    *
     1:    * The use of the typesafe functions below is preferred to direct use
     1:    * of this function.
     1:    */
 10152:   virtual const void* GetStyleDataExternal(nsStyleStructID aSID) const = 0;
     1: 
     1:   /**
     1:    * Define typesafe getter functions for each style struct by
     1:    * preprocessing the list of style structs.  These functions are the
     1:    * preferred way to get style data.  The macro creates functions like:
     1:    *   const nsStyleBorder* GetStyleBorder();
     1:    *   const nsStyleColor* GetStyleColor();
     1:    */
     1: 
     1: #ifdef _IMPL_NS_LAYOUT
     1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
     1:     const nsStyle##name_ * GetStyle##name_ () const {                         \
     1:       NS_ASSERTION(mStyleContext, "No style context found!");                 \
     1:       return mStyleContext->GetStyle##name_ ();                               \
     1:     }
     1: #else
     1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)                      \
     1:     const nsStyle##name_ * GetStyle##name_ () const {                         \
  3233:       return static_cast<const nsStyle##name_*>(                              \
     1:                             GetStyleDataExternal(eStyleStruct_##name_));      \
     1:     }
     1: #endif
     1:   #include "nsStyleStructList.h"
     1:   #undef STYLE_STRUCT
     1: 
 40173: #ifdef _IMPL_NS_LAYOUT
 40173:   /** Also forward GetVisitedDependentColor to the style context */
 40173:   nscolor GetVisitedDependentColor(nsCSSProperty aProperty)
 40173:     { return mStyleContext->GetVisitedDependentColor(aProperty); }
 40173: #endif
 40173: 
     1:   /**
     1:    * These methods are to access any additional style contexts that
     1:    * the frame may be holding. These are contexts that are children
     1:    * of the frame's primary context and are NOT used as style contexts
     1:    * for any child frames. These contexts also MUST NOT have any child 
     1:    * contexts whatsoever. If you need to insert style contexts into the
     1:    * style tree, then you should create pseudo element frames to own them
     1:    * The indicies must be consecutive and implementations MUST return an 
     1:    * NS_ERROR_INVALID_ARG if asked for an index that is out of range.
     1:    */
108991:   virtual nsStyleContext* GetAdditionalStyleContext(int32_t aIndex) const = 0;
108991: 
108991:   virtual void SetAdditionalStyleContext(int32_t aIndex,
     1:                                          nsStyleContext* aStyleContext) = 0;
     1: 
     1:   /**
     1:    * Accessor functions for geometric parent
     1:    */
     1:   nsIFrame* GetParent() const { return mParent; }
 51752:   virtual void SetParent(nsIFrame* aParent) = 0;
     1: 
     1:   /**
 21841:    * Bounding rect of the frame. The values are in app units, and the origin is
     1:    * relative to the upper-left of the geometric parent. The size includes the
     1:    * content area, borders, and padding.
     1:    *
     1:    * Note: moving or sizing the frame does not affect the view's size or
     1:    * position.
     1:    */
     1:   nsRect GetRect() const { return mRect; }
     1:   nsPoint GetPosition() const { return nsPoint(mRect.x, mRect.y); }
     1:   nsSize GetSize() const { return nsSize(mRect.width, mRect.height); }
 26950: 
 26950:   /**
 26950:    * When we change the size of the frame's border-box rect, we may need to
 26950:    * reset the overflow rect if it was previously stored as deltas.
 26950:    * (If it is currently a "large" overflow and could be re-packed as deltas,
 26950:    * we don't bother as the cost of the allocation has already been paid.)
 26950:    */
 26950:   void SetRect(const nsRect& aRect) {
 55021:     if (mOverflow.mType != NS_FRAME_OVERFLOW_LARGE &&
 55021:         mOverflow.mType != NS_FRAME_OVERFLOW_NONE) {
 55021:       nsOverflowAreas overflow = GetOverflowAreas();
 26950:       mRect = aRect;
 55021:       SetOverflowAreas(overflow);
 26950:     } else {
 26950:       mRect = aRect;
 26950:     }
 26950:   }
 26950:   void SetSize(const nsSize& aSize) {
 55021:     SetRect(nsRect(mRect.TopLeft(), aSize));
 26950:   }
     1:   void SetPosition(const nsPoint& aPt) { mRect.MoveTo(aPt); }
     1: 
 14460:   /**
 14460:    * Return frame's computed offset due to relative positioning
 14460:    */
106838:   nsPoint GetRelativeOffset(const nsStyleDisplay* aDisplay = nullptr) const;
 14460: 
     1:   virtual nsPoint GetPositionOfChildIgnoringScrolling(nsIFrame* aChild)
     1:   { return aChild->GetPosition(); }
     1:   
     1:   nsPoint GetPositionIgnoringScrolling() {
     1:     return mParent ? mParent->GetPositionOfChildIgnoringScrolling(this)
     1:       : GetPosition();
     1:   }
     1: 
 47735:   static void DestroyRegion(void* aPropertyValue)
 47735:   {
 47735:     delete static_cast<nsRegion*>(aPropertyValue);
 47735:   }
 47735: 
 39965:   static void DestroyMargin(void* aPropertyValue)
 39965:   {
 39965:     delete static_cast<nsMargin*>(aPropertyValue);
 39965:   }
 39965: 
 39965:   static void DestroyRect(void* aPropertyValue)
 39965:   {
 39965:     delete static_cast<nsRect*>(aPropertyValue);
 39965:   }
 39965: 
 39965:   static void DestroyPoint(void* aPropertyValue)
 39965:   {
 39965:     delete static_cast<nsPoint*>(aPropertyValue);
 39965:   }
 39965: 
 55021:   static void DestroyOverflowAreas(void* aPropertyValue)
 55021:   {
 55021:     delete static_cast<nsOverflowAreas*>(aPropertyValue);
 55021:   }
 55021: 
106096:   static void DestroySurface(void* aPropertyValue)
106096:   {
106096:     static_cast<gfxASurface*>(aPropertyValue)->Release();
106096:   }
106096: 
 40206: #ifdef _MSC_VER
 40206: // XXX Workaround MSVC issue by making the static FramePropertyDescriptor
 40206: // non-const.  See bug 555727.
 47730: #define NS_PROPERTY_DESCRIPTOR_CONST
 47730: #else
 47730: #define NS_PROPERTY_DESCRIPTOR_CONST const
 47730: #endif
 47730: 
 40206: #define NS_DECLARE_FRAME_PROPERTY(prop, dtor)                                                  \
 40206:   static const FramePropertyDescriptor* prop() {                                               \
106838:     static NS_PROPERTY_DESCRIPTOR_CONST FramePropertyDescriptor descriptor = { dtor, nullptr }; \
 40206:     return &descriptor;                                                                        \
 40206:   }
 47730: // Don't use this unless you really know what you're doing!
 47730: #define NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR(prop, dtor)                               \
 39965:   static const FramePropertyDescriptor* prop() {                                               \
106838:     static NS_PROPERTY_DESCRIPTOR_CONST FramePropertyDescriptor descriptor = { nullptr, dtor }; \
 39965:     return &descriptor;                                                                        \
 39965:   }
 39965: 
106838:   NS_DECLARE_FRAME_PROPERTY(IBSplitSpecialSibling, nullptr)
106838:   NS_DECLARE_FRAME_PROPERTY(IBSplitSpecialPrevSibling, nullptr)
 39965: 
 39965:   NS_DECLARE_FRAME_PROPERTY(ComputedOffsetProperty, DestroyPoint)
 39965: 
 39965:   NS_DECLARE_FRAME_PROPERTY(OutlineInnerRectProperty, DestroyRect)
 39965:   NS_DECLARE_FRAME_PROPERTY(PreEffectsBBoxProperty, DestroyRect)
 87626:   NS_DECLARE_FRAME_PROPERTY(PreTransformOverflowAreasProperty,
 87626:                             DestroyOverflowAreas)
 39965: 
 80449:   // The initial overflow area passed to FinishAndStoreOverflow. This is only set
 80449:   // on frames that Preserve3D(), and when at least one of the overflow areas
 80449:   // differs from the frame bound rect.
103955:   NS_DECLARE_FRAME_PROPERTY(InitialOverflowProperty, DestroyOverflowAreas)
 80449: 
 39965:   NS_DECLARE_FRAME_PROPERTY(UsedMarginProperty, DestroyMargin)
 39965:   NS_DECLARE_FRAME_PROPERTY(UsedPaddingProperty, DestroyMargin)
 39965:   NS_DECLARE_FRAME_PROPERTY(UsedBorderProperty, DestroyMargin)
 39965: 
106838:   NS_DECLARE_FRAME_PROPERTY(ScrollLayerCount, nullptr)
106838: 
106838:   NS_DECLARE_FRAME_PROPERTY(LineBaselineOffset, nullptr)
 74792: 
106096:   NS_DECLARE_FRAME_PROPERTY(CachedBackgroundImage, DestroySurface)
106096: 
115327:   NS_DECLARE_FRAME_PROPERTY(InvalidationRect, DestroyRect)
115327: 
     1:   /**
     1:    * Return the distance between the border edge of the frame and the
 38828:    * margin edge of the frame.  Like GetRect(), returns the dimensions
 38828:    * as of the most recent reflow.
     1:    *
     1:    * This doesn't include any margin collapsing that may have occurred.
 12310:    *
 12310:    * It also treats 'auto' margins as zero, and treats any margins that
 12310:    * should have been turned into 'auto' because of overconstraint as
 12310:    * having their original values.
     1:    */
     1:   virtual nsMargin GetUsedMargin() const;
     1: 
     1:   /**
     1:    * Return the distance between the border edge of the frame (which is
 38828:    * its rect) and the padding edge of the frame. Like GetRect(), returns
 38828:    * the dimensions as of the most recent reflow.
     1:    *
     1:    * Note that this differs from GetStyleBorder()->GetBorder() in that
     1:    * this describes region of the frame's box, and
     1:    * GetStyleBorder()->GetBorder() describes a border.  They differ only
     1:    * for tables, particularly border-collapse tables.
     1:    */
     1:   virtual nsMargin GetUsedBorder() const;
     1: 
     1:   /**
     1:    * Return the distance between the padding edge of the frame and the
 38828:    * content edge of the frame.  Like GetRect(), returns the dimensions
 38828:    * as of the most recent reflow.
     1:    */
     1:   virtual nsMargin GetUsedPadding() const;
     1: 
     1:   nsMargin GetUsedBorderAndPadding() const {
     1:     return GetUsedBorder() + GetUsedPadding();
     1:   }
     1: 
     1:   /**
     1:    * Apply the result of GetSkipSides() on this frame to an nsMargin by
     1:    * setting to zero any sides that are skipped.
     1:    */
     1:   void ApplySkipSides(nsMargin& aMargin) const;
     1: 
     1:   /**
     1:    * Like the frame's rect (see |GetRect|), which is the border rect,
 21841:    * other rectangles of the frame, in app units, relative to the parent.
     1:    */
     1:   nsRect GetPaddingRect() const;
 68635:   nsRect GetPaddingRectRelativeToSelf() const;
     1:   nsRect GetContentRect() const;
 68635:   nsRect GetContentRectRelativeToSelf() const;
     1: 
     1:   /**
 52126:    * Get the size, in app units, of the border radii. It returns FALSE iff all
 52126:    * returned radii == 0 (so no border radii), TRUE otherwise.
 52126:    * For the aRadii indexes, use the NS_CORNER_* constants in nsStyleConsts.h
 52128:    * If a side is skipped via aSkipSides, its corners are forced to 0.
 52130:    *
 52130:    * All corner radii are then adjusted so they do not require more
 52130:    * space than aBorderArea, according to the algorithm in css3-background.
 52130:    *
 52130:    * aFrameSize is used as the basis for percentage widths and heights.
 52130:    * aBorderArea is used for the adjustment of radii that might be too
 52130:    * large.
 52130:    * FIXME: In the long run, we can probably get away with only one of
 52130:    * these, especially if we change the way we handle outline-radius (by
 52130:    * removing it and inflating the border radius)
 52131:    *
 52131:    * Return whether any radii are nonzero.
 52126:    */
 79445:   static bool ComputeBorderRadii(const nsStyleCorners& aBorderRadius,
 52127:                                    const nsSize& aFrameSize,
 52130:                                    const nsSize& aBorderArea,
107846:                                    int aSkipSides,
 52126:                                    nscoord aRadii[8]);
 52126: 
 52131:   /*
 52131:    * Given a set of border radii for one box (e.g., border box), convert
 52131:    * it to the equivalent set of radii for another box (e.g., in to
 52131:    * padding box, out to outline box) by reducing radii or increasing
 52131:    * nonzero radii as appropriate.
 52131:    *
 52131:    * Indices into aRadii are the NS_CORNER_* constants in nsStyleConsts.h
 52131:    *
 52131:    * Note that InsetBorderRadii is lossy, since it can turn nonzero
 52131:    * radii into zero, and OutsetBorderRadii does not inflate zero radii.
 52131:    * Therefore, callers should always inset or outset directly from the
 52131:    * original value coming from style.
 52131:    */
 52131:   static void InsetBorderRadii(nscoord aRadii[8], const nsMargin &aOffsets);
 52131:   static void OutsetBorderRadii(nscoord aRadii[8], const nsMargin &aOffsets);
 52131: 
 52131:   /**
 52131:    * Fill in border radii for this frame.  Return whether any are
 52131:    * nonzero.
 52131:    *
 52131:    * Indices into aRadii are the NS_CORNER_* constants in nsStyleConsts.h
 52131:    */
 79445:   virtual bool GetBorderRadii(nscoord aRadii[8]) const;
 79445: 
 79445:   bool GetPaddingBoxBorderRadii(nscoord aRadii[8]) const;
 79445:   bool GetContentBoxBorderRadii(nscoord aRadii[8]) const;
 52131: 
 52126:   /**
     1:    * Get the position of the frame's baseline, relative to the top of
     1:    * the frame (its top border edge).  Only valid when Reflow is not
 56866:    * needed.
     1:    */
     1:   virtual nscoord GetBaseline() const = 0;
     1: 
     1:   /**
 56866:    * Get the position of the baseline on which the caret needs to be placed,
 56866:    * relative to the top of the frame.  This is mostly needed for frames
 56866:    * which return a baseline from GetBaseline which is not useful for
 56866:    * caret positioning.
 56866:    */
 56866:   virtual nscoord GetCaretBaseline() const {
 56866:     return GetBaseline();
 56866:   }
 56866: 
 56866:   /**
 30783:    * Get the specified child list.
     1:    *
 77152:    * @param   aListID identifies the requested child list.
 77152:    * @return  the child list.  If the requested list is unsupported by this
 77152:    *          frame type, an empty list will be returned.
     1:    */
 91756:   virtual const nsFrameList& GetChildList(ChildListID aListID) const = 0;
 91756:   const nsFrameList& PrincipalChildList() { return GetChildList(kPrincipalList); }
 77152:   virtual void GetChildLists(nsTArray<ChildList>* aLists) const = 0;
115304: 
115304:   /**
115304:    * Gets the child lists for this frame, including
115304:    * ones belong to a child document.
115304:    */
115304:   void GetCrossDocChildLists(nsTArray<ChildList>* aLists);
115304: 
 30783:   // XXXbz this method should go away
 77152:   nsIFrame* GetFirstChild(ChildListID aListID) const {
 77152:     return GetChildList(aListID).FirstChild();
 30783:   }
 32843:   // XXXmats this method should also go away then
 77152:   nsIFrame* GetLastChild(ChildListID aListID) const {
 77152:     return GetChildList(aListID).LastChild();
 32843:   }
 77152:   nsIFrame* GetFirstPrincipalChild() const {
 77152:     return GetFirstChild(kPrincipalList);
 77152:   }
 77152: 
 77152:   // The individual concrete child lists.
 77152:   static const ChildListID kPrincipalList = mozilla::layout::kPrincipalList;
 77152:   static const ChildListID kAbsoluteList = mozilla::layout::kAbsoluteList;
 77152:   static const ChildListID kBulletList = mozilla::layout::kBulletList;
 77152:   static const ChildListID kCaptionList = mozilla::layout::kCaptionList;
 77152:   static const ChildListID kColGroupList = mozilla::layout::kColGroupList;
 77152:   static const ChildListID kExcessOverflowContainersList = mozilla::layout::kExcessOverflowContainersList;
 77152:   static const ChildListID kFixedList = mozilla::layout::kFixedList;
 77152:   static const ChildListID kFloatList = mozilla::layout::kFloatList;
 77152:   static const ChildListID kOverflowContainersList = mozilla::layout::kOverflowContainersList;
 77152:   static const ChildListID kOverflowList = mozilla::layout::kOverflowList;
 77152:   static const ChildListID kOverflowOutOfFlowList = mozilla::layout::kOverflowOutOfFlowList;
 77152:   static const ChildListID kPopupList = mozilla::layout::kPopupList;
 77152:   static const ChildListID kPushedFloatsList = mozilla::layout::kPushedFloatsList;
 77152:   static const ChildListID kSelectPopupList = mozilla::layout::kSelectPopupList;
 77152:   // A special alias for kPrincipalList that do not request reflow.
 77152:   static const ChildListID kNoReflowPrincipalList = mozilla::layout::kNoReflowPrincipalList;
 30827: 
 30827:   /**
 33388:    * Child frames are linked together in a doubly-linked list
     1:    */
     1:   nsIFrame* GetNextSibling() const { return mNextSibling; }
     1:   void SetNextSibling(nsIFrame* aNextSibling) {
     1:     NS_ASSERTION(this != aNextSibling, "Creating a circular frame list, this is very bad.");
 33388:     if (mNextSibling && mNextSibling->GetPrevSibling() == this) {
106838:       mNextSibling->mPrevSibling = nullptr;
 33388:     }
     1:     mNextSibling = aNextSibling;
 33388:     if (mNextSibling) {
 33388:       mNextSibling->mPrevSibling = this;
     1:     }
 33388:   }
 33388: 
 33388:   nsIFrame* GetPrevSibling() const { return mPrevSibling; }
     1: 
     1:   /**
     1:    * Builds the display lists for the content represented by this frame
     1:    * and its descendants. The background+borders of this element must
     1:    * be added first, before any other content.
     1:    * 
     1:    * This should only be called by methods in nsFrame. Instead of calling this
     1:    * directly, call either BuildDisplayListForStackingContext or
     1:    * BuildDisplayListForChild.
     1:    * 
     1:    * See nsDisplayList.h for more information about display lists.
     1:    * 
     1:    * @param aDirtyRect content outside this rectangle can be ignored; the
     1:    * rectangle is in frame coordinates
     1:    */
     1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                               const nsRect&           aDirtyRect,
     1:                               const nsDisplayListSet& aLists) { return NS_OK; }
     1:   /**
     1:    * Displays the caret onto the given display list builder. The caret is
     1:    * painted on top of the rest of the display list items.
     1:    *
     1:    * @param aDirtyRect is the dirty rectangle that we're repainting.
     1:    */
     1:   nsresult DisplayCaret(nsDisplayListBuilder*       aBuilder,
     1:                         const nsRect&               aDirtyRect,
 39949:                         nsDisplayList*              aList);
     1: 
 40078:   /**
 40078:    * Get the preferred caret color at the offset.
 40078:    *
 40078:    * @param aOffset is offset of the content.
 40078:    */
108991:   virtual nscolor GetCaretColorAt(int32_t aOffset);
 40078: 
 43487:  
106838:   bool IsThemed(nsITheme::Transparency* aTransparencyState = nullptr) const {
 43487:     return IsThemed(GetStyleDisplay(), aTransparencyState);
     1:   }
 79445:   bool IsThemed(const nsStyleDisplay* aDisp,
106838:                   nsITheme::Transparency* aTransparencyState = nullptr) const {
 55048:     nsIFrame* mutable_this = const_cast<nsIFrame*>(this);
     1:     if (!aDisp->mAppearance)
 80486:       return false;
   238:     nsPresContext* pc = PresContext();
     1:     nsITheme *theme = pc->GetTheme();
 55048:     if(!theme ||
 55048:        !theme->ThemeSupportsWidget(pc, mutable_this, aDisp->mAppearance))
 80486:       return false;
 43487:     if (aTransparencyState) {
 55048:       *aTransparencyState =
 55048:         theme->GetWidgetTransparency(mutable_this, aDisp->mAppearance);
 22803:     }
 80486:     return true;
     1:   }
     1:   
     1:   /**
     1:    * Builds a display list for the content represented by this frame,
     1:    * treating this frame as the root of a stacking context.
     1:    * @param aDirtyRect content outside this rectangle can be ignored; the
     1:    * rectangle is in frame coordinates
     1:    */
     1:   nsresult BuildDisplayListForStackingContext(nsDisplayListBuilder* aBuilder,
     1:                                               const nsRect&         aDirtyRect,
     1:                                               nsDisplayList*        aList);
     1: 
     1:   /**
     1:    * Clips the display items of aFromSet, putting the results in aToSet.
     1:    * Only items corresponding to frames which are descendants of this frame
     1:    * are clipped. In other words, descendant elements whose CSS boxes do not
     1:    * have this frame as a container are not clipped. Also,
     1:    * border/background/outline items for this frame are not clipped,
 80486:    * unless aClipBorderBackground is set to true. (We need this because
     1:    * a scrollframe must overflow-clip its scrolled child's background/borders.)
 52293:    *
 52293:    * Indices into aClipRadii are the NS_CORNER_* constants in nsStyleConsts.h
     1:    */
     1:   nsresult OverflowClip(nsDisplayListBuilder*   aBuilder,
     1:                         const nsDisplayListSet& aFromSet,
     1:                         const nsDisplayListSet& aToSet,
     1:                         const nsRect&           aClipRect,
 52293:                         const nscoord           aClipRadii[8],
 79445:                         bool                    aClipBorderBackground = false,
 79445:                         bool                    aClipAll = false);
     1: 
     1:   enum {
     1:     DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT = 0x01,
     1:     DISPLAY_CHILD_FORCE_STACKING_CONTEXT = 0x02,
     1:     DISPLAY_CHILD_INLINE = 0x04
     1:   };
     1:   /**
     1:    * Adjusts aDirtyRect for the child's offset, checks that the dirty rect
     1:    * actually intersects the child (or its descendants), calls BuildDisplayList
     1:    * on the child if necessary, and puts things in the right lists if the child
     1:    * is positioned.
     1:    *
     1:    * @param aFlags combination of DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT,
     1:    *    DISPLAY_CHILD_FORCE_STACKING_CONTEXT and DISPLAY_CHILD_INLINE
     1:    */
     1:   nsresult BuildDisplayListForChild(nsDisplayListBuilder*   aBuilder,
     1:                                     nsIFrame*               aChild,
     1:                                     const nsRect&           aDirtyRect,
     1:                                     const nsDisplayListSet& aLists,
108991:                                     uint32_t                aFlags = 0);
     1: 
     1:   /**
 52294:    * A helper for replaced elements that want to clip their content to a
 52294:    * border radius, but only need clipping at all when they have a
 52294:    * border radius.
 52294:    */
 52294:   void WrapReplacedContentForBorderRadius(nsDisplayListBuilder* aBuilder,
 52294:                                           nsDisplayList* aFromList,
 52294:                                           const nsDisplayListSet& aToLists);
 52294: 
 52294:   /**
 37085:    * Does this frame need a view?
     1:    */
 79445:   virtual bool NeedsView() { return false; }
     1: 
     1:   /**
 98711:    * Returns true if this frame is transformed (e.g. has CSS or SVG transforms)
 98711:    * or if its parent is an SVG frame that has children-only transforms (e.g.
 98711:    * an SVG viewBox attribute).
 19214:    */
 98711:   bool IsTransformed() const;
 98711:   
107003:   bool HasOpacity() const;
107003: 
 98711:    /**
116070:    * Return true if this frame might be using a transform getter.
116070:    */
116070:   virtual bool HasTransformGetter() const { return false; }
116070: 
116070:   /**
 98711:    * Returns true if this frame is an SVG frame that has SVG transforms applied
 98711:    * to it, or if its parent frame is an SVG frame that has children-only
 98711:    * transforms (e.g. an SVG viewBox attribute).
 98711:    * If aOwnTransforms is non-null and the frame has its own SVG transforms,
 98711:    * aOwnTransforms will be set to these transforms. If aFromParentTransforms
 98711:    * is non-null and the frame has an SVG parent with children-only transforms,
 98711:    * then aFromParentTransforms will be set to these transforms.
 98711:    */
106838:   virtual bool IsSVGTransformed(gfxMatrix *aOwnTransforms = nullptr,
106838:                                 gfxMatrix *aFromParentTransforms = nullptr) const;
 19214: 
 19214:   /**
 77286:    * Returns whether this frame will attempt to preserve the 3d transforms of its
 77286:    * children. This is a direct indicator of -moz-transform-style: preserve-3d.
 77286:    */
 79445:   bool Preserves3DChildren() const;
 77286: 
 77286:   /**
 77286:    * Returns whether this frame has a parent that Preserves3DChildren() and
 77286:    * can respect this. Returns false if the frame is clipped.
 77286:    */
 79445:   bool Preserves3D() const;
 77286: 
 90156:   bool HasPerspective() const;
 90156: 
 92049:   bool ChildrenHavePerspective() const;
 92049: 
 77286:   // Calculate the overflow size of all child frames, taking preserve-3d into account
 77286:   void ComputePreserve3DChildrenOverflow(nsOverflowAreas& aOverflowAreas, const nsRect& aBounds);
 77286: 
 92049:   void RecomputePerspectiveChildrenOverflow(const nsStyleContext* aStartStyle, const nsRect* aBounds);
 90156: 
 77286:   /**
125313:    * Returns the number of ancestors between this and the root of our frame tree
125313:    */
125313:   uint32_t GetDepthInFrameTree() {
125313:     uint32_t result = 0;
125313:     for (nsIFrame* ancestor = GetParent(); ancestor;
125313:          ancestor = ancestor->GetParent()) {
125313:       result++;
125313:     }
125313:     return result;
125313:   }
125313: 
125313:   /**
     1:    * Event handling of GUI events.
     1:    *
     1:    * @param   aEvent event structure describing the type of event and rge widget
     1:    *            where the event originated
     1:    *          The |point| member of this is in the coordinate system of the
     1:    *          view returned by GetOffsetFromView.
     1:    * @param   aEventStatus a return value indicating whether the event was handled
     1:    *            and whether default processing should be done
     1:    *
     1:    * XXX From a frame's perspective it's unclear what the effect of the event status
     1:    * is. Does it cause the event to continue propagating through the frame hierarchy
     1:    * or is it just returned to the widgets?
     1:    *
     1:    * @see     nsGUIEvent
     1:    * @see     nsEventStatus
     1:    */
     1:   NS_IMETHOD  HandleEvent(nsPresContext* aPresContext,
     1:                           nsGUIEvent*     aEvent,
     1:                           nsEventStatus*  aEventStatus) = 0;
     1: 
 79435:   NS_IMETHOD  GetContentForEvent(nsEvent* aEvent,
     1:                                  nsIContent** aContent) = 0;
     1: 
     1:   // This structure keeps track of the content node and offsets associated with
     1:   // a point; there is a primary and a secondary offset associated with any
     1:   // point.  The primary and secondary offsets differ when the point is over a
     1:   // non-text object.  The primary offset is the expected position of the
     1:   // cursor calculated from a point; the secondary offset, when it is different,
     1:   // indicates that the point is in the boundaries of some selectable object.
     1:   // Note that the primary offset can be after the secondary offset; for places
     1:   // that need the beginning and end of the object, the StartOffset and 
     1:   // EndOffset helpers can be used.
 15599:   struct NS_STACK_CLASS ContentOffsets {
     1:     nsCOMPtr<nsIContent> content;
 79445:     bool IsNull() { return !content; }
108991:     int32_t offset;
108991:     int32_t secondaryOffset;
     1:     // Helpers for places that need the ends of the offsets and expect them in
     1:     // numerical order, as opposed to wanting the primary and secondary offsets
129543:     int32_t StartOffset() { return std::min(offset, secondaryOffset); }
129543:     int32_t EndOffset() { return std::max(offset, secondaryOffset); }
     1:     // This boolean indicates whether the associated content is before or after
     1:     // the offset; the most visible use is to allow the caret to know which line
     1:     // to display on.
 79445:     bool associateWithNext;
     1:   };
 99685:   enum {
 99685:     IGNORE_SELECTION_STYLE = 0x01,
 99685:     // Treat visibility:hidden frames as non-selectable
 99685:     SKIP_HIDDEN = 0x02
 99685:   };
     1:   /**
     1:    * This function calculates the content offsets for selection relative to
     1:    * a point.  Note that this should generally only be callled on the event
     1:    * frame associated with an event because this function does not account
     1:    * for frame lists other than the primary one.
     1:    * @param aPoint point relative to this frame
     1:    */
     1:   ContentOffsets GetContentOffsetsFromPoint(nsPoint aPoint,
108991:                                             uint32_t aFlags = 0);
     1: 
     1:   virtual ContentOffsets GetContentOffsetsFromPointExternal(nsPoint aPoint,
108991:                                                             uint32_t aFlags = 0)
 99685:   { return GetContentOffsetsFromPoint(aPoint, aFlags); }
     1: 
     1:   /**
     1:    * This structure holds information about a cursor. mContainer represents a
     1:    * loaded image that should be preferred. If it is not possible to use it, or
     1:    * if it is null, mCursor should be used.
     1:    */
 15599:   struct NS_STACK_CLASS Cursor {
     1:     nsCOMPtr<imgIContainer> mContainer;
108991:     int32_t                 mCursor;
 79445:     bool                    mHaveHotspot;
     1:     float                   mHotspotX, mHotspotY;
     1:   };
     1:   /**
     1:    * Get the cursor for a given frame.
     1:    */
     1:   NS_IMETHOD  GetCursor(const nsPoint&  aPoint,
     1:                         Cursor&         aCursor) = 0;
     1: 
     1:   /**
     1:    * Get a point (in the frame's coordinate space) given an offset into
     1:    * the content. This point should be on the baseline of text with
     1:    * the correct horizontal offset
     1:    */
108991:   NS_IMETHOD  GetPointFromOffset(int32_t                  inOffset,
     1:                                  nsPoint*                 outPoint) = 0;
     1:   
     1:   /**
     1:    * Get the child frame of this frame which contains the given
106838:    * content offset. outChildFrame may be this frame, or nullptr on return.
     1:    * outContentOffset returns the content offset relative to the start
     1:    * of the returned node. You can also pass a hint which tells the method
     1:    * to stick to the end of the first found frame or the beginning of the 
     1:    * next in case the offset falls on a boundary.
     1:    */
108991:   NS_IMETHOD  GetChildFrameContainingOffset(int32_t       inContentOffset,
 79445:                                  bool                     inHint,//false stick left
108991:                                  int32_t*                 outFrameContentOffset,
     1:                                  nsIFrame*                *outChildFrame) = 0;
     1: 
     1:  /**
     1:    * Get the current frame-state value for this frame. aResult is
     1:    * filled in with the state bits. 
     1:    */
     1:   nsFrameState GetStateBits() const { return mState; }
     1: 
     1:   /**
     1:    * Update the current frame-state value for this frame. 
     1:    */
     1:   void AddStateBits(nsFrameState aBits) { mState |= aBits; }
     1:   void RemoveStateBits(nsFrameState aBits) { mState &= ~aBits; }
     1: 
     1:   /**
115304:    * Checks if the current frame-state includes all of the listed bits
115304:    */
115304:   bool HasAllStateBits(nsFrameState aBits) { return (mState & aBits) == aBits; }
115304:   
115304:   /**
115304:    * Checks if the current frame-state includes any of the listed bits
115304:    */
115304:   bool HasAnyStateBits(nsFrameState aBits) { return mState & aBits; }
115304: 
115304:   /**
 31131:    * This call is invoked on the primary frame for a character data content
 31131:    * node, when it is changed in the content tree.
     1:    */
 31131:   NS_IMETHOD  CharacterDataChanged(CharacterDataChangeInfo* aInfo) = 0;
     1: 
     1:   /**
     1:    * This call is invoked when the value of a content objects's attribute
     1:    * is changed. 
     1:    * The first frame that maps that content is asked to deal
     1:    * with the change by doing whatever is appropriate.
     1:    *
     1:    * @param aNameSpaceID the namespace of the attribute
     1:    * @param aAttribute the atom name of the attribute
     1:    * @param aModType Whether or not the attribute was added, changed, or removed.
     1:    *   The constants are defined in nsIDOMMutationEvent.h.
     1:    */
108991:   NS_IMETHOD  AttributeChanged(int32_t         aNameSpaceID,
     1:                                nsIAtom*        aAttribute,
108991:                                int32_t         aModType) = 0;
     1: 
     1:   /**
 59447:    * When the content states of a content object change, this method is invoked
 59447:    * on the primary frame of that content object.
 59447:    *
 59447:    * @param aStates the changed states
 59447:    */
104627:   virtual void ContentStatesChanged(nsEventStates aStates) { }
 59447: 
 59447:   /**
     1:    * Return how your frame can be split.
     1:    */
     1:   virtual nsSplittableType GetSplittableType() const = 0;
     1: 
     1:   /**
     1:    * Continuation member functions
     1:    */
     1:   virtual nsIFrame* GetPrevContinuation() const = 0;
     1:   NS_IMETHOD SetPrevContinuation(nsIFrame*) = 0;
     1:   virtual nsIFrame* GetNextContinuation() const = 0;
     1:   NS_IMETHOD SetNextContinuation(nsIFrame*) = 0;
     1:   virtual nsIFrame* GetFirstContinuation() const {
  3233:     return const_cast<nsIFrame*>(this);
     1:   }
     1:   virtual nsIFrame* GetLastContinuation() const {
  3233:     return const_cast<nsIFrame*>(this);
     1:   }
     1: 
     1:   /**
 10780:    * GetTailContinuation gets the last non-overflow-container continuation
 10780:    * in the continuation chain, i.e. where the next sibling element
 10780:    * should attach).
 10780:    */
 10780:   nsIFrame* GetTailContinuation();
 10780: 
 10780:   /**
     1:    * Flow member functions
     1:    */
     1:   virtual nsIFrame* GetPrevInFlowVirtual() const = 0;
     1:   nsIFrame* GetPrevInFlow() const { return GetPrevInFlowVirtual(); }
     1:   NS_IMETHOD SetPrevInFlow(nsIFrame*) = 0;
     1: 
     1:   virtual nsIFrame* GetNextInFlowVirtual() const = 0;
     1:   nsIFrame* GetNextInFlow() const { return GetNextInFlowVirtual(); }
     1:   NS_IMETHOD SetNextInFlow(nsIFrame*) = 0;
     1: 
     1:   /**
     1:    * Return the first frame in our current flow. 
     1:    */
     1:   virtual nsIFrame* GetFirstInFlow() const {
  3233:     return const_cast<nsIFrame*>(this);
     1:   }
     1: 
     1:   /**
     1:    * Return the last frame in our current flow.
     1:    */
     1:   virtual nsIFrame* GetLastInFlow() const {
  3233:     return const_cast<nsIFrame*>(this);
     1:   }
     1: 
     1: 
     1:   /**
     1:    * Mark any stored intrinsic width information as dirty (requiring
     1:    * re-calculation).  Note that this should generally not be called
     1:    * directly; nsPresShell::FrameNeedsReflow will call it instead.
     1:    */
     1:   virtual void MarkIntrinsicWidthsDirty() = 0;
     1: 
     1:   /**
     1:    * Get the intrinsic minimum width of the frame.  This must be less
     1:    * than or equal to the intrinsic width.
     1:    *
     1:    * This is *not* affected by the CSS 'min-width', 'width', and
     1:    * 'max-width' properties on this frame, but it is affected by the
     1:    * values of those properties on this frame's descendants.  (It may be
     1:    * called during computation of the values of those properties, so it
     1:    * cannot depend on any values in the nsStylePosition for this frame.)
     1:    *
     1:    * The value returned should **NOT** include the space required for
     1:    * padding and border.
     1:    *
     1:    * Note that many frames will cache the result of this function call
     1:    * unless MarkIntrinsicWidthsDirty is called.
     1:    *
     1:    * It is not acceptable for a frame to mark itself dirty when this
     1:    * method is called.
 16269:    *
 16269:    * This method must not return a negative value.
     1:    */
 68481:   virtual nscoord GetMinWidth(nsRenderingContext *aRenderingContext) = 0;
     1: 
     1:   /**
     1:    * Get the intrinsic width of the frame.  This must be greater than or
     1:    * equal to the intrinsic minimum width.
     1:    *
     1:    * Otherwise, all the comments for |GetMinWidth| above apply.
     1:    */
 68481:   virtual nscoord GetPrefWidth(nsRenderingContext *aRenderingContext) = 0;
     1: 
     1:   /**
     1:    * |InlineIntrinsicWidth| represents the intrinsic width information
     1:    * in inline layout.  Code that determines the intrinsic width of a
     1:    * region of inline layout accumulates the result into this structure.
     1:    * This pattern is needed because we need to maintain state
     1:    * information about whitespace (for both collapsing and trimming).
     1:    */
     1:   struct InlineIntrinsicWidthData {
     1:     InlineIntrinsicWidthData()
106838:       : line(nullptr)
106838:       , lineContainer(nullptr)
  6029:       , prevLines(0)
     1:       , currentLine(0)
 80486:       , skipWhitespace(true)
     1:       , trailingWhitespace(0)
     1:     {}
     1: 
 10113:     // The line. This may be null if the inlines are not associated with
 10113:     // a block or if we just don't know the line.
  6029:     const nsLineList_iterator* line;
  6029: 
 24819:     // The line container.
 24819:     nsIFrame* lineContainer;
 24819: 
     1:     // The maximum intrinsic width for all previous lines.
     1:     nscoord prevLines;
     1: 
     1:     // The maximum intrinsic width for the current line.  At a line
     1:     // break (mandatory for preferred width; allowed for minimum width),
     1:     // the caller should call |Break()|.
     1:     nscoord currentLine;
     1: 
     1:     // True if initial collapsable whitespace should be skipped.  This
  8930:     // should be true at the beginning of a block, after hard breaks
  8930:     // and when the last text ended with whitespace.
 79445:     bool skipWhitespace;
     1: 
     1:     // This contains the width of the trimmable whitespace at the end of
     1:     // |currentLine|; it is zero if there is no such whitespace.
     1:     nscoord trailingWhitespace;
     1: 
     1:     // Floats encountered in the lines.
108092:     class FloatInfo {
108092:     public:
108092:       FloatInfo(const nsIFrame* aFrame, nscoord aWidth)
108092:         : mFrame(aFrame), mWidth(aWidth)
108092:       { }
108092:       const nsIFrame* Frame() const { return mFrame; }
108092:       nscoord         Width() const { return mWidth; }
108092: 
108092:     private:
108092:       const nsIFrame* mFrame;
108092:       nscoord         mWidth;
108092:     };
108092: 
108092:     nsTArray<FloatInfo> floats;
     1:   };
     1: 
     1:   struct InlineMinWidthData : public InlineIntrinsicWidthData {
     1:     InlineMinWidthData()
106838:       : trailingTextFrame(nullptr)
 80486:       , atStartOfLine(true)
     1:     {}
     1: 
  2668:     // We need to distinguish forced and optional breaks for cases where the
  2668:     // current line total is negative.  When it is, we need to ignore
  2668:     // optional breaks to prevent min-width from ending up bigger than
  2668:     // pref-width.
 68481:     void ForceBreak(nsRenderingContext *aRenderingContext);
 64410: 
 64410:     // If the break here is actually taken, aHyphenWidth must be added to the
 64410:     // width of the current line.
 68481:     void OptionallyBreak(nsRenderingContext *aRenderingContext,
 64410:                          nscoord aHyphenWidth = 0);
     1: 
     1:     // The last text frame processed so far in the current line, when
     1:     // the last characters in that text frame are relevant for line
     1:     // break opportunities.
     1:     nsIFrame *trailingTextFrame;
  2668: 
  2668:     // Whether we're currently at the start of the line.  If we are, we
  2668:     // can't break (for example, between the text-indent and the first
  2668:     // word).
 79445:     bool atStartOfLine;
     1:   };
     1: 
     1:   struct InlinePrefWidthData : public InlineIntrinsicWidthData {
 68481:     void ForceBreak(nsRenderingContext *aRenderingContext);
     1:   };
     1: 
     1:   /**
     1:    * Add the intrinsic minimum width of a frame in a way suitable for
     1:    * use in inline layout to an |InlineIntrinsicWidthData| object that
     1:    * represents the intrinsic width information of all the previous
     1:    * frames in the inline layout region.
     1:    *
     1:    * All *allowed* breakpoints within the frame determine what counts as
     1:    * a line for the |InlineIntrinsicWidthData|.  This means that
     1:    * |aData->trailingWhitespace| will always be zero (unlike for
     1:    * AddInlinePrefWidth).
     1:    *
     1:    * All the comments for |GetMinWidth| apply, except that this function
     1:    * is responsible for adding padding, border, and margin and for
     1:    * considering the effects of 'width', 'min-width', and 'max-width'.
     1:    *
     1:    * This may be called on any frame.  Frames that do not participate in
     1:    * line breaking can inherit the default implementation on nsFrame,
     1:    * which calls |GetMinWidth|.
     1:    */
     1:   virtual void
 68481:   AddInlineMinWidth(nsRenderingContext *aRenderingContext,
     1:                     InlineMinWidthData *aData) = 0;
     1: 
     1:   /**
     1:    * Add the intrinsic preferred width of a frame in a way suitable for
     1:    * use in inline layout to an |InlineIntrinsicWidthData| object that
     1:    * represents the intrinsic width information of all the previous
     1:    * frames in the inline layout region.
     1:    *
     1:    * All the comments for |AddInlineMinWidth| and |GetPrefWidth| apply,
     1:    * except that this fills in an |InlineIntrinsicWidthData| structure
     1:    * based on using all *mandatory* breakpoints within the frame.
     1:    */
     1:   virtual void
 68481:   AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
     1:                      InlinePrefWidthData *aData) = 0;
     1: 
     1:   /**
     1:    * Return the horizontal components of padding, border, and margin
     1:    * that contribute to the intrinsic width that applies to the parent.
     1:    */
     1:   struct IntrinsicWidthOffsetData {
     1:     nscoord hPadding, hBorder, hMargin;
     1:     float hPctPadding, hPctMargin;
     1: 
     1:     IntrinsicWidthOffsetData()
     1:       : hPadding(0), hBorder(0), hMargin(0)
     1:       , hPctPadding(0.0f), hPctMargin(0.0f)
     1:     {}
     1:   };
     1:   virtual IntrinsicWidthOffsetData
 68481:     IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext) = 0;
     1: 
  2301:   /*
  8142:    * For replaced elements only. Gets the intrinsic dimensions of this element.
 71655:    * The dimensions may only be one of the following two types:
  8142:    *
  8142:    *   eStyleUnit_Coord   - a length in app units
  8142:    *   eStyleUnit_None    - the element has no intrinsic size in this dimension
  8142:    */
  8142:   struct IntrinsicSize {
  8142:     nsStyleCoord width, height;
  8142: 
  8142:     IntrinsicSize()
  8142:       : width(eStyleUnit_None), height(eStyleUnit_None)
  8142:     {}
  8142:     IntrinsicSize(const IntrinsicSize& rhs)
  8142:       : width(rhs.width), height(rhs.height)
  8142:     {}
  8142:     IntrinsicSize& operator=(const IntrinsicSize& rhs) {
  8142:       width = rhs.width; height = rhs.height; return *this;
  8142:     }
 79445:     bool operator==(const IntrinsicSize& rhs) {
 52205:       return width == rhs.width && height == rhs.height;
 52205:     }
 79445:     bool operator!=(const IntrinsicSize& rhs) {
 52205:       return !(*this == rhs);
 52205:     }
  8142:   };
  8142:   virtual IntrinsicSize GetIntrinsicSize() = 0;
  8142: 
  8142:   /*
  2301:    * Get the intrinsic ratio of this element, or nsSize(0,0) if it has
  2301:    * no intrinsic ratio.  The intrinsic ratio is the ratio of the
  2301:    * height/width of a box with an intrinsic size or the intrinsic
  2301:    * aspect ratio of a scalable vector image without an intrinsic size.
  2301:    *
  2301:    * Either one of the sides may be zero, indicating a zero or infinite
  2301:    * ratio.
  2301:    */
  2301:   virtual nsSize GetIntrinsicRatio() = 0;
  2301: 
     1:   /**
 93353:    * Bit-flags to pass to ComputeSize in |aFlags| parameter.
 93353:    */
 93353:   enum {
 93353:     /* Set if the frame is in a context where non-replaced blocks should
 93353:      * shrink-wrap (e.g., it's floating, absolutely positioned, or
 93353:      * inline-block). */
115549:     eShrinkWrap =        1 << 0,
115549:     /* Set if we'd like to compute our 'auto' height, regardless of our actual
115549:      * computed value of 'height'. (e.g. to get an intrinsic height for flex
115549:      * items with "min-height: auto" to use during flexbox layout.) */
115549:     eUseAutoHeight =     1 << 1
 93353:   };
 93353: 
 93353:   /**
     1:    * Compute the size that a frame will occupy.  Called while
     1:    * constructing the nsHTMLReflowState to be used to Reflow the frame,
     1:    * in order to fill its mComputedWidth and mComputedHeight member
     1:    * variables.
     1:    *
     1:    * The |height| member of the return value may be
     1:    * NS_UNCONSTRAINEDSIZE, but the |width| member must not be.
     1:    *
     1:    * Note that the reason that border and padding need to be passed
     1:    * separately is so that the 'box-sizing' property can be handled.
     1:    * Thus aMargin includes absolute positioning offsets as well.
     1:    *
     1:    * @param aCBSize  The size of the element's containing block.  (Well,
     1:    *                 the |height| component isn't really.)
     1:    * @param aAvailableWidth  The available width for 'auto' widths.
     1:    *                         This is usually the same as aCBSize.width,
     1:    *                         but differs in cases such as block
     1:    *                         formatting context roots next to floats, or
     1:    *                         in some cases of float reflow in quirks
     1:    *                         mode.
     1:    * @param aMargin  The sum of the vertical / horizontal margins
     1:    *                 ***AND*** absolute positioning offsets (top, right,
     1:    *                 bottom, left) of the frame, including actual values
     1:    *                 resulting from percentages and from the
     1:    *                 "hypothetical box" for absolute positioning, but
     1:    *                 not including actual values resulting from 'auto'
     1:    *                 margins or ignored 'auto' values in absolute
     1:    *                 positioning.
     1:    * @param aBorder  The sum of the vertical / horizontal border widths
     1:    *                 of the frame.
     1:    * @param aPadding The sum of the vertical / horizontal margins of
     1:    *                 the frame, including actual values resulting from
     1:    *                 percentages.
 93353:    * @param aFlags   Flags to further customize behavior (definitions above).
     1:    */
 68481:   virtual nsSize ComputeSize(nsRenderingContext *aRenderingContext,
     1:                              nsSize aCBSize, nscoord aAvailableWidth,
     1:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
108991:                              uint32_t aFlags) = 0;
     1: 
     1:   /**
  6862:    * Compute a tight bounding rectangle for the frame. This is a rectangle
  6862:    * that encloses the pixels that are actually drawn. We're allowed to be
  6862:    * conservative and currently we don't try very hard. The rectangle is
  6862:    * in appunits and relative to the origin of this frame.
 55035:    *
 55035:    * This probably only needs to include frame bounds, glyph bounds, and
 55035:    * text decorations, but today it sometimes includes other things that
 55035:    * contribute to visual overflow.
 55035:    *
  6862:    * @param aContext a rendering context that can be used if we need
  6862:    * to do measurement
  6862:    */
  6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
  6862: 
  6862:   /**
     1:    * Pre-reflow hook. Before a frame is reflowed this method will be called.
     1:    * This call will always be invoked at least once before a subsequent Reflow
     1:    * and DidReflow call. It may be called more than once, In general you will
     1:    * receive on WillReflow notification before each Reflow request.
     1:    *
     1:    * XXX Is this really the semantics we want? Because we have the NS_FRAME_IN_REFLOW
     1:    * bit we can ensure we don't call it more than once...
     1:    */
     1:   NS_IMETHOD  WillReflow(nsPresContext* aPresContext) = 0;
     1: 
     1:   /**
     1:    * The frame is given an available size and asked for its desired
     1:    * size.  This is the frame's opportunity to reflow its children.
     1:    *
     1:    * If the frame has the NS_FRAME_IS_DIRTY bit set then it is
     1:    * responsible for completely reflowing itself and all of its
     1:    * descendants.
     1:    *
     1:    * Otherwise, if the frame has the NS_FRAME_HAS_DIRTY_CHILDREN bit
     1:    * set, then it is responsible for reflowing at least those
     1:    * children that have NS_FRAME_HAS_DIRTY_CHILDREN or NS_FRAME_IS_DIRTY
     1:    * set.
     1:    *
     1:    * If a difference in available size from the previous reflow causes
     1:    * the frame's size to change, it should reflow descendants as needed.
     1:    *
     1:    * @param aReflowMetrics <i>out</i> parameter where you should return the
     1:    *          desired size and ascent/descent info. You should include any
     1:    *          space you want for border/padding in the desired size you return.
     1:    *
     1:    *          It's okay to return a desired size that exceeds the avail
     1:    *          size if that's the smallest you can be, i.e. it's your
     1:    *          minimum size.
     1:    *
     1:    *          For an incremental reflow you are responsible for invalidating
     1:    *          any area within your frame that needs repainting (including
     1:    *          borders). If your new desired size is different than your current
     1:    *          size, then your parent frame is responsible for making sure that
     1:    *          the difference between the two rects is repainted
     1:    *
     1:    * @param aReflowState information about your reflow including the reason
     1:    *          for the reflow and the available space in which to lay out. Each
     1:    *          dimension of the available space can either be constrained or
     1:    *          unconstrained (a value of NS_UNCONSTRAINEDSIZE).
     1:    *
     1:    *          Note that the available space can be negative. In this case you
     1:    *          still must return an accurate desired size. If you're a container
     1:    *          you must <b>always</b> reflow at least one frame regardless of the
     1:    *          available space
     1:    *
     1:    * @param aStatus a return value indicating whether the frame is complete
     1:    *          and whether the next-in-flow is dirty and needs to be reflowed
     1:    */
     1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
     1:                     nsHTMLReflowMetrics&     aReflowMetrics,
     1:                     const nsHTMLReflowState& aReflowState,
     1:                     nsReflowStatus&          aStatus) = 0;
     1: 
     1:   /**
     1:    * Post-reflow hook. After a frame is reflowed this method will be called
     1:    * informing the frame that this reflow process is complete, and telling the
     1:    * frame the status returned by the Reflow member function.
     1:    *
     1:    * This call may be invoked many times, while NS_FRAME_IN_REFLOW is set, before
     1:    * it is finally called once with a NS_FRAME_REFLOW_COMPLETE value. When called
     1:    * with a NS_FRAME_REFLOW_COMPLETE value the NS_FRAME_IN_REFLOW bit in the
     1:    * frame state will be cleared.
     1:    *
     1:    * XXX This doesn't make sense. If the frame is reflowed but not complete, then
     1:    * the status should be NS_FRAME_NOT_COMPLETE and not NS_FRAME_COMPLETE
     1:    * XXX Don't we want the semantics to dictate that we only call this once for
     1:    * a given reflow?
     1:    */
     1:   NS_IMETHOD  DidReflow(nsPresContext*           aPresContext,
     1:                         const nsHTMLReflowState*  aReflowState,
     1:                         nsDidReflowStatus         aStatus) = 0;
     1: 
     1:   // XXX Maybe these three should be a separate interface?
     1: 
     1:   /**
 87626:    * Updates the overflow areas of the frame. This can be called if an
 87626:    * overflow area of the frame's children has changed without reflowing.
 87626:    * @return true if either of the overflow areas for this frame have changed.
 87626:    */
 87626:   virtual bool UpdateOverflow() = 0;
 87626: 
 87626:   /**
     1:    * Helper method used by block reflow to identify runs of text so
     1:    * that proper word-breaking can be done.
     1:    *
     1:    * @return 
 80486:    *    true if we can continue a "text run" through the frame. A
     1:    *    text run is text that should be treated contiguously for line
     1:    *    and word breaking.
     1:    */
 79445:   virtual bool CanContinueTextRun() const = 0;
     1: 
     1:   /**
  4261:    * Append the rendered text to the passed-in string.
  4261:    * The appended text will often not contain all the whitespace from source,
  4261:    * depending on whether the CSS rule "white-space: pre" is active for this frame.
  4261:    * if aStartOffset + aLength goes past end, or if aLength is not specified
  4261:    * then use the text up to the string's end.
  4261:    * Call this on the primary frame for a text node.
  4261:    * @param aAppendToString   String to append text to, or null if text should not be returned
  4261:    * @param aSkipChars         if aSkipIter is non-null, this must also be non-null.
  4261:    * This gets used as backing data for the iterator so it should outlive the iterator.
  4261:    * @param aSkipIter         Where to fill in the gfxSkipCharsIterator info, or null if not needed by caller
  4261:    * @param aStartOffset       Skipped (rendered text) start offset
  4261:    * @param aSkippedMaxLength  Maximum number of characters to return
  4261:    * The iterator can be used to map content offsets to offsets in the returned string, or vice versa.
  4261:    */
106838:   virtual nsresult GetRenderedText(nsAString* aAppendToString = nullptr,
106838:                                    gfxSkipChars* aSkipChars = nullptr,
106838:                                    gfxSkipCharsIterator* aSkipIter = nullptr,
108991:                                    uint32_t aSkippedStartOffset = 0,
115367:                                    uint32_t aSkippedMaxLength = UINT32_MAX)
  4261:   { return NS_ERROR_NOT_IMPLEMENTED; }
  4261: 
  4261:   /**
 53735:    * Returns true if the frame contains any non-collapsed characters.
 53735:    * This method is only available for text frames, and it will return false
 53735:    * for all other frame types.
 53735:    */
 79445:   virtual bool HasAnyNoncollapsedCharacters()
 80486:   { return false; }
 53735: 
 53735:   /**
     1:    * Accessor functions to get/set the associated view object
     1:    *
     1:    * GetView returns non-null if and only if |HasView| returns true.
     1:    */
 79445:   bool HasView() const { return !!(mState & NS_FRAME_HAS_VIEW); }
127357:   nsView* GetView() const;
127357:   virtual nsView* GetViewExternal() const;
127357:   nsresult SetView(nsView* aView);
     1: 
     1:   /**
     1:    * Find the closest view (on |this| or an ancestor).
     1:    * If aOffset is non-null, it will be set to the offset of |this|
     1:    * from the returned view.
     1:    */
127357:   nsView* GetClosestView(nsPoint* aOffset = nullptr) const;
     1: 
     1:   /**
     1:    * Find the closest ancestor (excluding |this| !) that has a view
     1:    */
     1:   nsIFrame* GetAncestorWithView() const;
     1:   virtual nsIFrame* GetAncestorWithViewExternal() const;
     1: 
     1:   /**
     1:    * Get the offset between the coordinate systems of |this| and aOther.
     1:    * Adding the return value to a point in the coordinate system of |this|
     1:    * will transform the point to the coordinate system of aOther.
     1:    *
     1:    * aOther must be non-null.
     1:    * 
     1:    * This function is fastest when aOther is an ancestor of |this|.
     1:    *
 47895:    * This function _DOES NOT_ work across document boundaries.
 47895:    * Use this function only when |this| and aOther are in the same document.
 30522:    *
     1:    * NOTE: this actually returns the offset from aOther to |this|, but
     1:    * that offset is added to transform _coordinates_ from |this| to
     1:    * aOther.
     1:    */
     1:   nsPoint GetOffsetTo(const nsIFrame* aOther) const;
     1:   virtual nsPoint GetOffsetToExternal(const nsIFrame* aOther) const;
     1: 
     1:   /**
 47895:    * Get the offset between the coordinate systems of |this| and aOther
 47895:    * expressed in appunits per dev pixel of |this|' document. Adding the return
 47895:    * value to a point that is relative to the origin of |this| will make the
 47895:    * point relative to the origin of aOther but in the appunits per dev pixel
 47895:    * ratio of |this|.
 47895:    *
 47895:    * aOther must be non-null.
 47895:    * 
 47895:    * This function is fastest when aOther is an ancestor of |this|.
 47895:    *
 47895:    * This function works across document boundaries.
 47895:    *
 47895:    * Because this function may cross document boundaries that have different
 47895:    * app units per dev pixel ratios it needs to be used very carefully.
 47895:    *
 47895:    * NOTE: this actually returns the offset from aOther to |this|, but
 47895:    * that offset is added to transform _coordinates_ from |this| to
 47895:    * aOther.
 47895:    */
 47895:   nsPoint GetOffsetToCrossDoc(const nsIFrame* aOther) const;
 47895: 
 47895:   /**
 15364:    * Get the screen rect of the frame in pixels.
     1:    * @return the pixel rect of the frame in screen coordinates.
     1:    */
     1:   nsIntRect GetScreenRect() const;
     1:   virtual nsIntRect GetScreenRectExternal() const;
     1: 
     1:   /**
 15364:    * Get the screen rect of the frame in app units.
 15364:    * @return the app unit rect of the frame in screen coordinates.
 15364:    */
 15364:   nsRect GetScreenRectInAppUnits() const;
 15364:   virtual nsRect GetScreenRectInAppUnitsExternal() const;
 15364: 
 15364:   /**
     1:    * Returns the offset from this frame to the closest geometric parent that
     1:    * has a view. Also returns the containing view or null in case of error
     1:    */
     1:   NS_IMETHOD  GetOffsetFromView(nsPoint&  aOffset,
127357:                                 nsView** aView) const = 0;
     1: 
     1:   /**
 47148:    * Returns the nearest widget containing this frame. If this frame has a
 47148:    * view and the view has a widget, then this frame's widget is
     1:    * returned, otherwise this frame's geometric parent is checked
     1:    * recursively upwards.
     1:    * XXX virtual because gfx callers use it! (themes)
     1:    */
 47148:   virtual nsIWidget* GetNearestWidget() const;
     1: 
     1:   /**
 47148:    * Same as GetNearestWidget() above but uses an outparam to return the offset
 47148:    * of this frame to the returned widget expressed in appunits of |this| (the
 47148:    * widget might be in a different document with a different zoom).
 39425:    */
 47148:   virtual nsIWidget* GetNearestWidget(nsPoint& aOffset) const;
 39425: 
 39425:   /**
     1:    * Get the "type" of the frame. May return a NULL atom pointer
     1:    *
     1:    * @see nsGkAtoms
     1:    */
     1:   virtual nsIAtom* GetType() const = 0;
     1: 
 19214:   /**
 86353:    * Returns a transformation matrix that converts points in this frame's
 86353:    * coordinate space to points in some ancestor frame's coordinate space.
 86353:    * The frame decides which ancestor it will use as a reference point.
 86353:    * If this frame has no ancestor, aOutAncestor will be set to null.
 19214:    *
 86353:    * @param aStopAtAncestor don't look further than aStopAtAncestor. If null,
 86353:    *   all ancestors (including across documents) will be traversed.
 86353:    * @param aOutAncestor [out] The ancestor frame the frame has chosen.  If
119292:    *   this frame has no ancestor, *aOutAncestor will be set to null. If
119292:    * this frame is not a root frame, then *aOutAncestor will be in the same
119292:    * document as this frame. If this frame IsTransformed(), then *aOutAncestor
119292:    * will be the parent frame (if not preserve-3d) or the nearest non-transformed
119292:    * ancestor (if preserve-3d).
 86353:    * @return A gfxMatrix that converts points in this frame's coordinate space
 86353:    *   into points in aOutAncestor's coordinate space.
 19214:    */
114041:   gfx3DMatrix GetTransformMatrix(const nsIFrame* aStopAtAncestor,
 86353:                                  nsIFrame **aOutAncestor);
     1: 
     1:   /**
     1:    * Bit-flags to pass to IsFrameOfType()
     1:    */
     1:   enum {
     1:     eMathML =                           1 << 0,
     1:     eSVG =                              1 << 1,
     1:     eSVGForeignObject =                 1 << 2,
 19948:     eSVGContainer =                     1 << 3,
 46984:     eSVGGeometry =                      1 << 4,
 46984:     eSVGPaintServer =                   1 << 5,
 46984:     eBidiInlineContainer =              1 << 6,
     1:     // the frame is for a replaced element, such as an image
 46984:     eReplaced =                         1 << 7,
     1:     // Frame that contains a block but looks like a replaced element
     1:     // from the outside
 46984:     eReplacedContainsBlock =            1 << 8,
  1588:     // A frame that participates in inline reflow, i.e., one that
  1588:     // requires nsHTMLReflowState::mLineLayout.
 46984:     eLineParticipant =                  1 << 9,
 46984:     eXULBox =                           1 << 10,
 46984:     eCanContainOverflowContainers =     1 << 11,
 46984:     eBlockFrame =                       1 << 12,
 15913:     // If this bit is set, the frame doesn't allow ignorable whitespace as
 15913:     // children. For example, the whitespace between <table>\n<tr>\n<td>
 15913:     // will be excluded during the construction of children. 
 46984:     eExcludesIgnorableWhitespace =      1 << 13,
125199:     eSupportsCSSTransforms =            1 << 14,
     1: 
     1:     // These are to allow nsFrame::Init to assert that IsFrameOfType
     1:     // implementations all call the base class method.  They are only
     1:     // meaningful in DEBUG builds.
     1:     eDEBUGAllFrames =                   1 << 30,
     1:     eDEBUGNoFrames =                    1 << 31
     1:   };
     1: 
     1:   /**
     1:    * API for doing a quick check if a frame is of a given
     1:    * type. Returns true if the frame matches ALL flags passed in.
     1:    *
     1:    * Implementations should always override with inline virtual
     1:    * functions that call the base class's IsFrameOfType method.
     1:    */
108991:   virtual bool IsFrameOfType(uint32_t aFlags) const
     1:   {
     1: #ifdef DEBUG
125199:     return !(aFlags & ~(nsIFrame::eDEBUGAllFrames | nsIFrame::eSupportsCSSTransforms));
     1: #else
125199:     return !(aFlags & ~nsIFrame::eSupportsCSSTransforms);
     1: #endif
     1:   }
     1: 
     1:   /**
 79487:    * Returns true if the frame is a block wrapper.
     1:    */
 79487:   bool IsBlockWrapper() const;
 79487: 
 79487:   /**
 79487:    * Get this frame's CSS containing block.
 79487:    *
 79487:    * The algorithm is defined in
 79487:    * http://www.w3.org/TR/CSS2/visudet.html#containing-block-details.
 79487:    */
 79487:   nsIFrame* GetContainingBlock() const;
     1: 
     1:   /**
     1:    * Is this frame a containing block for floating elements?
     1:    * Note that very few frames are, so default to false.
     1:    */
 79445:   virtual bool IsFloatContainingBlock() const { return false; }
     1: 
     1:   /**
     1:    * Is this a leaf frame?  Frames that want the frame constructor to be able
     1:    * to construct kids for them should return false, all others should return
     1:    * true.  Note that returning true here does not mean that the frame _can't_
     1:    * have kids.  It could still have kids created via
     1:    * nsIAnonymousContentCreator.  Returning true indicates that "normal"
     1:    * (non-anonymous, XBL-bound, CSS generated content, etc) children should not
     1:    * be constructed.
     1:    */
 79445:   virtual bool IsLeaf() const;
     1: 
     1:   /**
111204:    * Is this a flex item? (Is the parent a flex container frame?)
111204:    */
111204:   bool IsFlexItem() const
111204:   { return mParent && mParent->GetType() == nsGkAtoms::flexContainerFrame; }
111204: 
111204:   /**
 47735:    * This must only be called on frames that are display roots (see
 47735:    * nsLayoutUtils::GetDisplayRootFrame). This causes all invalidates
 47735:    * reaching this frame to be performed asynchronously off an event,
 47735:    * instead of being applied to the widget immediately. Also,
 47771:    * invalidation of areas in aExcludeRegion is ignored completely
 47771:    * for invalidates with INVALIDATE_EXCLUDE_CURRENT_PAINT specified.
 47735:    * These can't be nested; two invocations of
 47735:    * BeginDeferringInvalidatesForDisplayRoot for a frame must have a
 47735:    * EndDeferringInvalidatesForDisplayRoot between them.
 47735:    */
 47735:   void BeginDeferringInvalidatesForDisplayRoot(const nsRegion& aExcludeRegion);
 47735: 
 47735:   /**
 47735:    * Cancel the most recent BeginDeferringInvalidatesForDisplayRoot.
 47735:    */
 47735:   void EndDeferringInvalidatesForDisplayRoot();
 47735: 
 47735:   /**
 47753:    * Mark this frame as using active layers. This marking will time out
 47753:    * after a short period. This call does no immediate invalidation,
 47753:    * but when the mark times out, we'll invalidate the frame's overflow
 47753:    * area.
 72242:    * @param aChangeHint nsChangeHint_UpdateTransformLayer or
 72242:    * nsChangeHint_UpdateOpacityLayer or 0, depending on whether the change
 72242:    * triggering the activity is a changing transform, changing opacity, or
 72242:    * something else.
 47753:    */
 72242:   void MarkLayersActive(nsChangeHint aHint);
 47753:   /**
 47753:    * Return true if this frame is marked as needing active layers.
 47753:    */
 79445:   bool AreLayersMarkedActive();
 72242:   /**
 72242:    * Return true if this frame is marked as needing active layers.
 72242:    * @param aChangeHint nsChangeHint_UpdateTransformLayer or
 72242:    * nsChangeHint_UpdateOpacityLayer. We return true only if
 72242:    * a change in the transform or opacity has been recorded while layers have
 72242:    * been marked active for this frame.
 72242:    */
 79445:   bool AreLayersMarkedActive(nsChangeHint aChangeHint);
 47753: 
 47753:   /**
115304:    * Marks all display items created by this frame as needing a repaint,
115324:    * and calls SchedulePaint() if requested and one is not already pending.
115304:    *
115304:    * This includes all display items created by this frame, including
115304:    * container types.
115332:    *
115332:    * @param aDisplayItemKey If specified, only issues an invalidate
115332:    * if this frame painted a display item of that type during the 
115332:    * previous paint. SVG rendering observers are always notified.
115304:    */
115332:   virtual void InvalidateFrame(uint32_t aDisplayItemKey = 0);
115304: 
115304:   /**
115327:    * Same as InvalidateFrame(), but only mark a fixed rect as needing
115327:    * repainting.
115327:    *
115327:    * @param aRect The rect to invalidate, relative to the TopLeft of the
115327:    * frame's border box.
115332:    * @param aDisplayItemKey If specified, only issues an invalidate
115332:    * if this frame painted a display item of that type during the 
115332:    * previous paint. SVG rendering observers are always notified.
115327:    */
115332:   virtual void InvalidateFrameWithRect(const nsRect& aRect, uint32_t aDisplayItemKey = 0);
115327:   
115327:   /**
115304:    * Calls InvalidateFrame() on all frames descendant frames (including
115304:    * this one).
115304:    * 
115304:    * This function doesn't walk through placeholder frames to invalidate
115304:    * the out-of-flow frames.
115332:    *
115332:    * @param aDisplayItemKey If specified, only issues an invalidate
115332:    * if this frame painted a display item of that type during the 
115332:    * previous paint. SVG rendering observers are always notified.
115304:    */
115332:   void InvalidateFrameSubtree(uint32_t aDisplayItemKey = 0);
115304: 
115304:   /**
115328:    * Called when a frame is about to be removed and needs to be invalidated.
115328:    * Normally does nothing since DLBI handles removed frames.
115328:    */
115328:   virtual void InvalidateFrameForRemoval() {}
115328: 
115328:   /**
116072:    * When HasUserData(frame->LayerIsPrerenderedDataKey()), then the
116072:    * entire overflow area of this frame has been rendered in its
116072:    * layer(s).
116072:    */
116072:   static void* LayerIsPrerenderedDataKey() { 
116072:     return &sLayerIsPrerenderedDataKey;
116072:   }
116072:   static uint8_t sLayerIsPrerenderedDataKey;
116072: 
116072:    /**
116072:    * Try to update this frame's transform without invalidating any
116072:    * content.  Return true iff successful.  If unsuccessful, the
116072:    * caller is responsible for scheduling an invalidating paint.
116072:    */
116072:   bool TryUpdateTransformOnly();
116072: 
116072:   /**
115304:    * Checks if a frame has had InvalidateFrame() called on it since the
115304:    * last paint.
115327:    *
115327:    * If true, then the invalid rect is returned in aRect, with an
115327:    * empty rect meaning all pixels drawn by this frame should be
115327:    * invalidated.
115327:    * If false, aRect is left unchanged.
115304:    */
115327:   bool IsInvalid(nsRect& aRect);
115304:  
115304:   /**
115304:    * Check if any frame within the frame subtree (including this frame) 
115304:    * returns true for IsInvalid().
115304:    */
115304:   bool HasInvalidFrameInSubtree()
115304:   {
115304:     return HasAnyStateBits(NS_FRAME_NEEDS_PAINT | NS_FRAME_DESCENDANT_NEEDS_PAINT);
115304:   }
115304: 
115304:   /**
115304:    * Removes the invalid state from the current frame and all
115304:    * descendant frames.
115304:    */
115304:   void ClearInvalidationStateBits();
115304: 
115304:   /**
115304:    * Ensures that the refresh driver is running, and schedules a view 
115304:    * manager flush on the next tick.
115304:    *
115304:    * The view manager flush will update the layer tree, repaint any 
115304:    * invalid areas in the layer tree and schedule a layer tree
115304:    * composite operation to display the layer tree.
115311:    *
115311:    * @param aFlags PAINT_COMPOSITE_ONLY : No changes have been made
115311:    * that require a layer tree update, so only schedule a layer
115311:    * tree composite.
115304:    */
115311:   enum {
115574:     PAINT_DEFAULT = 0,
115574:     PAINT_COMPOSITE_ONLY = 1 << 0
115311:   };
115574:   void SchedulePaint(uint32_t aFlags = PAINT_DEFAULT);
115304: 
115304:   /**
115304:    * Checks if the layer tree includes a dedicated layer for this 
115304:    * frame/display item key pair, and invalidates at least aDamageRect
115304:    * area within that layer.
115304:    *
115304:    * If no layer is found, calls InvalidateFrame() instead.
115304:    *
115304:    * @param aDamageRect Area of the layer to invalidate.
115304:    * @param aDisplayItemKey Display item type.
115304:    * @return Layer, if found, nullptr otherwise.
115304:    */
115308:   Layer* InvalidateLayer(uint32_t aDisplayItemKey, const nsIntRect* aDamageRect = nullptr);
115304: 
115304:   /**
 55021:    * Returns a rect that encompasses everything that might be painted by
   134:    * this frame.  This includes this frame, all its descendent frames, this
   134:    * frame's outline, and descentant frames' outline, but does not include
   134:    * areas clipped out by the CSS "overflow" and "clip" properties.
     1:    *
 80486:    * HasOverflowRects() (below) will return true when this overflow
 55021:    * rect has been explicitly set, even if it matches mRect.
 55021:    * XXX Note: because of a space optimization using the formula above,
 55021:    * during reflow this function does not give accurate data if
 55021:    * FinishAndStoreOverflow has been called but mRect hasn't yet been
 55021:    * updated yet.  FIXME: This actually isn't true, but it should be.
 55021:    *
 55021:    * The visual overflow rect should NEVER be used for things that
 55021:    * affect layout.  The scrollable overflow rect is permitted to affect
 55021:    * layout.
 55021:    *
 55021:    * @return the rect relative to this frame's origin, but after
 55021:    * CSS transforms have been applied (i.e. not really this frame's coordinate
 55021:    * system, and may not contain the frame's border-box, e.g. if there
 55021:    * is a CSS transform scaling it down)
 55021:    */
 55021:   nsRect GetVisualOverflowRect() const {
 55021:     return GetOverflowRect(eVisualOverflow);
 55021:   }
 55021: 
 55021:   /**
 55021:    * Returns a rect that encompasses the area of this frame that the
 55021:    * user should be able to scroll to reach.  This is similar to
 55021:    * GetVisualOverflowRect, but does not include outline or shadows, and
 55021:    * may in the future include more margins than visual overflow does.
 55021:    * It does not include areas clipped out by the CSS "overflow" and
 55021:    * "clip" properties.
 55021:    *
 80486:    * HasOverflowRects() (below) will return true when this overflow
 55021:    * rect has been explicitly set, even if it matches mRect.
 11909:    * XXX Note: because of a space optimization using the formula above,
 11909:    * during reflow this function does not give accurate data if
 11909:    * FinishAndStoreOverflow has been called but mRect hasn't yet been
 11909:    * updated yet.
 11909:    *
 19284:    * @return the rect relative to this frame's origin, but after
 19284:    * CSS transforms have been applied (i.e. not really this frame's coordinate
 19284:    * system, and may not contain the frame's border-box, e.g. if there
 19284:    * is a CSS transform scaling it down)
     1:    */
 55021:   nsRect GetScrollableOverflowRect() const {
 55021:     return GetOverflowRect(eScrollableOverflow);
 55021:   }
 55021: 
 55021:   nsRect GetOverflowRect(nsOverflowType aType) const;
 55021: 
 55021:   nsOverflowAreas GetOverflowAreas() const;
     1: 
     1:   /**
 55021:    * Same as GetScrollableOverflowRect, except relative to the parent
 55021:    * frame.
 19284:    *
 19284:    * @return the rect relative to the parent frame, in the parent frame's
 19284:    * coordinate system
 19284:    */
 55021:   nsRect GetScrollableOverflowRectRelativeToParent() const;
 19284: 
 19284:   /**
 55021:    * Like GetVisualOverflowRect, except in this frame's
 55021:    * coordinate system (before transforms are applied).
 19284:    *
 19284:    * @return the rect relative to this frame, before any CSS transforms have
 19284:    * been applied, i.e. in this frame's coordinate system
 19284:    */
 55021:   nsRect GetVisualOverflowRectRelativeToSelf() const;
 19284: 
 19284:   /**
102946:    * Returns this frame's visual overflow rect as it would be before taking
102946:    * account of SVG effects or transforms. The rect returned is relative to
102946:    * this frame.
102946:    */
102946:   nsRect GetPreEffectsVisualOverflowRect() const;
102946: 
102946:   /**
 55021:    * Store the overflow area in the frame's mOverflow.mVisualDeltas
 55021:    * fields or as a frame property in the frame manager so that it can
 83439:    * be retrieved later without reflowing the frame. Returns true if either of
 83439:    * the overflow areas changed.
     1:    */
 83439:   bool FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
120656:                               nsSize aNewSize, nsSize* aOldSize = nullptr);
     1: 
 83439:   bool FinishAndStoreOverflow(nsHTMLReflowMetrics* aMetrics) {
 83439:     return FinishAndStoreOverflow(aMetrics->mOverflowAreas,
 55024:                                   nsSize(aMetrics->width, aMetrics->height));
     1:   }
     1: 
     1:   /**
 26950:    * Returns whether the frame has an overflow rect that is different from
 26950:    * its border-box.
 26950:    */
 79445:   bool HasOverflowAreas() const {
 26950:     return mOverflow.mType != NS_FRAME_OVERFLOW_NONE;
 26950:   }
 26950: 
 26950:   /**
 55021:    * Removes any stored overflow rects (visual and scrollable) from the frame.
 83439:    * Returns true if the overflow changed.
 26950:    */
 83439:   bool ClearOverflowRects();
 26950: 
 26950:   /**
     1:    * Determine whether borders should not be painted on certain sides of the
     1:    * frame.
     1:    */
107846:   virtual int GetSkipSides() const { return 0; }
     1: 
 85101:   /**
 85101:    * @returns true if this frame is selected.
     1:    */
 85101:   bool IsSelected() const {
 85101:     return (GetContent() && GetContent()->IsSelectionDescendant()) ?
 85101:       IsFrameSelected() : false;
 85101:   }
     1: 
     1:   /**
     1:    *  called to discover where this frame, or a parent frame has user-select style
     1:    *  applied, which affects that way that it is selected.
     1:    *    
     1:    *  @param aIsSelectable out param. Set to true if the frame can be selected
     1:    *                       (i.e. is not affected by user-select: none)
     1:    *  @param aSelectStyle  out param. Returns the type of selection style found
     1:    *                        (using values defined in nsStyleConsts.h).
     1:    */
108991:   NS_IMETHOD  IsSelectable(bool* aIsSelectable, uint8_t* aSelectStyle) const = 0;
     1: 
     1:   /** 
     1:    *  Called to retrieve the SelectionController associated with the frame.
     1:    *  @param aSelCon will contain the selection controller associated with
     1:    *  the frame.
     1:    */
     1:   NS_IMETHOD  GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon) = 0;
     1: 
     1:   /**
  8295:    *  Call to get nsFrameSelection for this frame.
     1:    */
  8295:   already_AddRefed<nsFrameSelection> GetFrameSelection();
  8295: 
  8295:   /**
  8295:    * GetConstFrameSelection returns an object which methods are safe to use for
  8295:    * example in nsIFrame code.
  8295:    */
 85101:   const nsFrameSelection* GetConstFrameSelection() const;
     1: 
     1:   /**
     1:    *  called to find the previous/next character, word, or line  returns the actual 
     1:    *  nsIFrame and the frame offset.  THIS DOES NOT CHANGE SELECTION STATE
     1:    *  uses frame's begin selection state to start. if no selection on this frame will 
     1:    *  return NS_ERROR_FAILURE
     1:    *  @param aPOS is defined in nsFrameSelection
     1:    */
     1:   NS_IMETHOD PeekOffset(nsPeekOffsetStruct *aPos);
     1: 
     1:   /**
     1:    *  called to find the previous/next selectable leaf frame.
     1:    *  @param aDirection [in] the direction to move in (eDirPrevious or eDirNext)
 80486:    *  @param aVisual [in] whether bidi caret behavior is visual (true) or logical (false)
     1:    *  @param aJumpLines [in] whether to allow jumping across line boundaries
     1:    *  @param aScrollViewStop [in] whether to stop when reaching a scroll frame boundary
     1:    *  @param aOutFrame [out] the previous/next selectable leaf frame
     1:    *  @param aOutOffset [out] 0 indicates that we arrived at the beginning of the output frame;
     1:    *                          -1 indicates that we arrived at its end.
     1:    *  @param aOutJumpedLine [out] whether this frame and the returned frame are on different lines
     1:    */
 79445:   nsresult GetFrameFromDirection(nsDirection aDirection, bool aVisual,
 79445:                                  bool aJumpLines, bool aScrollViewStop, 
108991:                                  nsIFrame** aOutFrame, int32_t* aOutOffset, bool* aOutJumpedLine);
     1: 
     1:   /**
     1:    *  called to see if the children of the frame are visible from indexstart to index end.
 80486:    *  this does not change any state. returns true only if the indexes are valid and any of
     1:    *  the children are visible.  for textframes this index is the character index.
 80486:    *  if aStart = aEnd result will be false
     1:    *  @param aStart start index of first child from 0-N (number of children)
     1:    *  @param aEnd   end index of last child from 0-N
     1:    *  @param aRecurse should this frame talk to siblings to get to the contents other children?
     1:    *  @param aFinished did this frame have the aEndIndex? or is there more work to do
     1:    *  @param _retval  return value true or false. false = range is not rendered.
     1:    */
108991:   NS_IMETHOD CheckVisibility(nsPresContext* aContext, int32_t aStartIndex, int32_t aEndIndex, bool aRecurse, bool *aFinished, bool *_retval)=0;
     1: 
     1:   /**
     1:    * Called to tell a frame that one of its child frames is dirty (i.e.,
     1:    * has the NS_FRAME_IS_DIRTY *or* NS_FRAME_HAS_DIRTY_CHILDREN bit
     1:    * set).  This should always set the NS_FRAME_HAS_DIRTY_CHILDREN on
     1:    * the frame, and may do other work.
     1:    */
     1:   virtual void ChildIsDirty(nsIFrame* aChild) = 0;
     1: 
     1:   /**
     1:    * Called to retrieve this frame's accessible.
     1:    * If this frame implements Accessibility return a valid accessible
     1:    * If not return NS_ERROR_NOT_IMPLEMENTED.
 99648:    * Note: Accessible must be refcountable. Do not implement directly on your frame
     1:    * Use a mediatior of some kind.
     1:    */
     1: #ifdef ACCESSIBILITY
118929:   virtual mozilla::a11y::AccType AccessibleType() = 0;
     1: #endif
     1: 
     1:   /**
     1:    * Get the frame whose style context should be the parent of this
     1:    * frame's style context (i.e., provide the parent style context).
     1:    * This frame must either be an ancestor of this frame or a child.  If
 92182:    * this returns a child frame, then the child frame must be sure to
 92182:    * return a grandparent or higher!  Furthermore, if a child frame is
 92182:    * returned it must have the same GetContent() as this frame.
     1:    *
 78202:    * @return The frame whose style context should be the parent of this frame's
 78202:    *         style context.  Null is permitted, and means that this frame's
 78202:    *         style context should be the root of the style context tree.
     1:    */
 90155:   virtual nsIFrame* GetParentStyleContextFrame() const = 0;
     1: 
     1:   /**
     1:    * Determines whether a frame is visible for painting;
     1:    * taking into account whether it is painting a selection or printing.
     1:    */
 79445:   bool IsVisibleForPainting(nsDisplayListBuilder* aBuilder);
     1:   /**
     1:    * Determines whether a frame is visible for painting or collapsed;
     1:    * taking into account whether it is painting a selection or printing,
     1:    */
 79445:   bool IsVisibleOrCollapsedForPainting(nsDisplayListBuilder* aBuilder);
     1:   /**
     1:    * As above, but slower because we have to recompute some stuff that
     1:    * aBuilder already has.
     1:    */
 79445:   bool IsVisibleForPainting();
     1:   /**
     1:    * Check whether this frame is visible in the current selection. Returns
 80486:    * true if there is no current selection.
     1:    */
 79445:   bool IsVisibleInSelection(nsDisplayListBuilder* aBuilder);
     1: 
     1:   /**
     1:    * Overridable function to determine whether this frame should be considered
     1:    * "in" the given non-null aSelection for visibility purposes.
     1:    */  
 79445:   virtual bool IsVisibleInSelection(nsISelection* aSelection);
     1: 
     1:   /**
     1:    * Determines whether this frame is a pseudo stacking context, looking
     1:    * only as style --- i.e., assuming that it's in-flow and not a replaced
105956:    * element and not an SVG element.
105956:    * XXX maybe check IsTransformed()?
     1:    */
 79445:   bool IsPseudoStackingContextFromStyle() {
     1:     const nsStyleDisplay* disp = GetStyleDisplay();
107224:     return disp->mOpacity != 1.0f ||
107225:            disp->IsPositioned(this) ||
107224:            disp->IsFloating(this);
     1:   }
     1:   
 79445:   virtual bool HonorPrintBackgroundSettings() { return true; }
     1: 
     1:   /**
     1:    * Determine whether the frame is logically empty, which is roughly
     1:    * whether the layout would be the same whether or not the frame is
     1:    * present.  Placeholder frames should return true.  Block frames
     1:    * should be considered empty whenever margins collapse through them,
     1:    * even though those margins are relevant.  Text frames containing
     1:    * only whitespace that does not contribute to the height of the line
     1:    * should return true.
     1:    */
 79445:   virtual bool IsEmpty() = 0;
     1:   /**
     1:    * Return the same as IsEmpty(). This may only be called after the frame
     1:    * has been reflowed and before any further style or content changes.
     1:    */
 79445:   virtual bool CachedIsEmpty();
     1:   /**
     1:    * Determine whether the frame is logically empty, assuming that all
     1:    * its children are empty.
     1:    */
 79445:   virtual bool IsSelfEmpty() = 0;
     1: 
     1:   /**
     1:    * IsGeneratedContentFrame returns whether a frame corresponds to
     1:    * generated content
     1:    *
     1:    * @return whether the frame correspods to generated content
     1:    */
 79445:   bool IsGeneratedContentFrame() {
     1:     return (mState & NS_FRAME_GENERATED_CONTENT) != 0;
     1:   }
     1: 
     1:   /**
     1:    * IsPseudoFrame returns whether a frame is a pseudo frame (eg an
     1:    * anonymous table-row frame created for a CSS table-cell without an
     1:    * enclosing table-row.
     1:    *
     1:    * @param aParentContent the content node corresponding to the parent frame
     1:    * @return whether the frame is a pseudo frame
     1:    */   
 79445:   bool IsPseudoFrame(nsIContent* aParentContent) {
     1:     return mContent == aParentContent;
     1:   }
     1: 
 39965:   FrameProperties Properties() const {
 39965:     return FrameProperties(PresContext()->PropertyTable(), this);
 39965:   }
     1: 
106838:   NS_DECLARE_FRAME_PROPERTY(BaseLevelProperty, nullptr)
106838:   NS_DECLARE_FRAME_PROPERTY(EmbeddingLevelProperty, nullptr)
106838:   NS_DECLARE_FRAME_PROPERTY(ParagraphDepthProperty, nullptr)
     1: 
     1: #define NS_GET_BASE_LEVEL(frame) \
 39965: NS_PTR_TO_INT32(frame->Properties().Get(nsIFrame::BaseLevelProperty()))
     1: 
     1: #define NS_GET_EMBEDDING_LEVEL(frame) \
 39965: NS_PTR_TO_INT32(frame->Properties().Get(nsIFrame::EmbeddingLevelProperty()))
     1: 
 93532: #define NS_GET_PARAGRAPH_DEPTH(frame) \
 93532: NS_PTR_TO_INT32(frame->Properties().Get(nsIFrame::ParagraphDepthProperty()))
 93532: 
     1:   /**
 80486:    * Return true if and only if this frame obeys visibility:hidden.
     1:    * if it does not, then nsContainerFrame will hide its view even though
     1:    * this means children can't be made visible again.
     1:    */
 79445:   virtual bool SupportsVisibilityHidden() { return true; }
     1: 
     1:   /**
 91411:    * Returns true if the frame has a valid clip rect set via the 'clip'
 91411:    * property, and the 'clip' property applies to this frame. The 'clip'
 91411:    * property applies to HTML frames if they are absolutely positioned. The
 91411:    * 'clip' property applies to SVG frames regardless of the value of the
 91411:    * 'position' property.
 91411:    *
 91411:    * If this method returns true, then we also set aRect to the computed clip
 91411:    * rect, with coordinates relative to this frame's origin. aRect must not be
 91411:    * null!
     1:    */
 91411:   bool GetClipPropClipRect(const nsStyleDisplay* aDisp, nsRect* aRect,
 77286:                            const nsSize& aSize) const;
     1: 
     1:   /**
     1:    * Check if this frame is focusable and in the current tab order.
     1:    * Tabbable is indicated by a nonnegative tabindex & is a subset of focusable.
     1:    * For example, only the selected radio button in a group is in the 
     1:    * tab order, unless the radio group has no selection in which case
     1:    * all of the visible, non-disabled radio buttons in the group are 
     1:    * in the tab order. On the other hand, all of the visible, non-disabled 
     1:    * radio buttons are always focusable via clicking or script.
     1:    * Also, depending on the pref accessibility.tabfocus some widgets may be 
     1:    * focusable but removed from the tab order. This is the default on
     1:    * Mac OS X, where fewer items are focusable.
     1:    * @param  [in, optional] aTabIndex the computed tab index
     1:    *         < 0 if not tabbable
     1:    *         == 0 if in normal tab order
     1:    *         > 0 can be tabbed to in the order specified by this value
     1:    * @param  [in, optional] aWithMouse, is this focus query for mouse clicking
     1:    * @return whether the frame is focusable via mouse, kbd or script.
     1:    */
108991:   virtual bool IsFocusable(int32_t *aTabIndex = nullptr, bool aWithMouse = false);
     1: 
     1:   // BOX LAYOUT METHODS
     1:   // These methods have been migrated from nsIBox and are in the process of
     1:   // being refactored. DO NOT USE OUTSIDE OF XUL.
 79445:   bool IsBoxFrame() const
  3103:   {
  3103:     return IsFrameOfType(nsIFrame::eXULBox);
  3103:   }
 79445:   bool IsBoxWrapped() const
     1:   { return (!IsBoxFrame() && mParent && mParent->IsBoxFrame()); }
     1: 
     1:   enum Halignment {
     1:     hAlign_Left,
     1:     hAlign_Right,
     1:     hAlign_Center
     1:   };
     1: 
     1:   enum Valignment {
     1:     vAlign_Top,
     1:     vAlign_Middle,
     1:     vAlign_BaseLine,
     1:     vAlign_Bottom
     1:   };
     1: 
     1:   /**
     1:    * This calculates the minimum size required for a box based on its state
     1:    * @param[in] aBoxLayoutState The desired state to calculate for
     1:    * @return The minimum size
     1:    */
     1:   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState) = 0;
     1: 
     1:   /**
     1:    * This calculates the preferred size of a box based on its state
     1:    * @param[in] aBoxLayoutState The desired state to calculate for
     1:    * @return The preferred size
     1:    */
     1:   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState) = 0;
     1: 
     1:   /**
     1:    * This calculates the maximum size for a box based on its state
     1:    * @param[in] aBoxLayoutState The desired state to calculate for
     1:    * @return The maximum size
     1:    */    
     1:   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState) = 0;
     1: 
     1:   /**
     1:    * This returns the minimum size for the scroll area if this frame is
     1:    * being scrolled. Usually it's (0,0).
     1:    */
     1:   virtual nsSize GetMinSizeForScrollArea(nsBoxLayoutState& aBoxLayoutState) = 0;
     1: 
     1:   // Implemented in nsBox, used in nsBoxFrame
124523:   uint32_t GetOrdinal();
     1: 
     1:   virtual nscoord GetFlex(nsBoxLayoutState& aBoxLayoutState) = 0;
     1:   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState) = 0;
 87626:   virtual bool IsCollapsed() = 0;
     1:   // This does not alter the overflow area. If the caller is changing
     1:   // the box size, the caller is responsible for updating the overflow
     1:   // area. It's enough to just call Layout or SyncLayout on the
 80486:   // box. You can pass true to aRemoveOverflowArea as a
     1:   // convenience.
     1:   virtual void SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
 79445:                          bool aRemoveOverflowAreas = false) = 0;
     1:   NS_HIDDEN_(nsresult) Layout(nsBoxLayoutState& aBoxLayoutState);
107520:   nsIFrame* GetChildBox() const
     1:   {
     1:     // box layout ends at box-wrapped frames, so don't allow these frames
     1:     // to report child boxes.
106838:     return IsBoxFrame() ? GetFirstPrincipalChild() : nullptr;
     1:   }
107520:   nsIFrame* GetNextBox() const
     1:   {
106838:     return (mParent && mParent->IsBoxFrame()) ? mNextSibling : nullptr;
     1:   }
107520:   nsIFrame* GetParentBox() const
     1:   {
106838:     return (mParent && mParent->IsBoxFrame()) ? mParent : nullptr;
     1:   }
     1:   // Box methods.  Note that these do NOT just get the CSS border, padding,
     1:   // etc.  They also talk to nsITheme.
     1:   NS_IMETHOD GetBorderAndPadding(nsMargin& aBorderAndPadding);
     1:   NS_IMETHOD GetBorder(nsMargin& aBorder)=0;
     1:   NS_IMETHOD GetPadding(nsMargin& aBorderAndPadding)=0;
     1:   NS_IMETHOD GetMargin(nsMargin& aMargin)=0;
 73636:   virtual void SetLayoutManager(nsBoxLayout* aLayout) { }
106838:   virtual nsBoxLayout* GetLayoutManager() { return nullptr; }
     1:   NS_HIDDEN_(nsresult) GetClientRect(nsRect& aContentRect);
     1: 
     1:   // For nsSprocketLayout
     1:   virtual Valignment GetVAlign() const = 0;
     1:   virtual Halignment GetHAlign() const = 0;
     1: 
 79445:   bool IsHorizontal() const { return (mState & NS_STATE_IS_HORIZONTAL) != 0; }
 79445:   bool IsNormalDirection() const { return (mState & NS_STATE_IS_DIRECTION_NORMAL) != 0; }
     1: 
115305:   NS_HIDDEN_(nsresult) Redraw(nsBoxLayoutState& aState);
107520:   NS_IMETHOD RelayoutChildAtOrdinal(nsBoxLayoutState& aState, nsIFrame* aChild)=0;
 58577:   // XXX take this out after we've branched
104627:   virtual bool GetMouseThrough() const { return false; }
     1: 
     1: #ifdef DEBUG_LAYOUT
 79445:   NS_IMETHOD SetDebug(nsBoxLayoutState& aState, bool aDebug)=0;
 79445:   NS_IMETHOD GetDebug(bool& aDebug)=0;
     1: 
     1:   NS_IMETHOD DumpBox(FILE* out)=0;
     1: #endif
     1: 
     1:   /**
 80486:    * @return true if this text frame ends with a newline character.  It
 80486:    * should return false if this is not a text frame.
     1:    */
 79445:   virtual bool HasTerminalNewline() const;
 79445: 
107520:   static bool AddCSSPrefSize(nsIFrame* aBox, nsSize& aSize, bool& aWidth, bool& aHeightSet);
107520:   static bool AddCSSMinSize(nsBoxLayoutState& aState, nsIFrame* aBox,
 79445:                             nsSize& aSize, bool& aWidth, bool& aHeightSet);
107520:   static bool AddCSSMaxSize(nsIFrame* aBox, nsSize& aSize, bool& aWidth, bool& aHeightSet);
107520:   static bool AddCSSFlex(nsBoxLayoutState& aState, nsIFrame* aBox, nscoord& aFlex);
     1: 
     1:   // END OF BOX LAYOUT METHODS
     1:   // The above methods have been migrated from nsIBox and are in the process of
     1:   // being refactored. DO NOT USE OUTSIDE OF XUL.
     1: 
 94058:   struct CaretPosition {
 94058:     CaretPosition() :
 94058:       mContentOffset(0)
 94058:     {}
 94058: 
 94058:     nsCOMPtr<nsIContent> mResultContent;
108991:     int32_t              mContentOffset;
 94058:   };
 94058: 
     1:   /**
     1:    * gets the first or last possible caret position within the frame
     1:    *
     1:    * @param  [in] aStart
     1:    *         true  for getting the first possible caret position
     1:    *         false for getting the last possible caret position
 94058:    * @return The caret position in a CaretPosition.
     1:    *         the returned value is a 'best effort' in case errors
     1:    *         are encountered rummaging through the frame.
     1:    */
 94058:   CaretPosition GetExtremeCaretPosition(bool aStart);
     1: 
 17140:   /**
 21112:    * Get a line iterator for this frame, if supported.
 21112:    *
106838:    * @return nullptr if no line iterator is supported.
 21112:    * @note dispose the line iterator using nsILineIterator::DisposeLineIterator
 21112:    */
 21112:   virtual nsILineIterator* GetLineIterator() = 0;
 21112: 
 30638:   /**
 30638:    * If this frame is a next-in-flow, and its prev-in-flow has something on its
 30638:    * overflow list, pull those frames into the child list of this one.
 30638:    */
 30638:   virtual void PullOverflowsFromPrevInFlow() {}
 30638: 
 61717:   /**
 61717:    * Clear the list of child PresShells generated during the last paint
 61717:    * so that we can begin generating a new one.
 61717:    */  
 61717:   void ClearPresShellsFromLastPaint() { 
 61717:     PaintedPresShellList()->Clear(); 
 61717:   }
 61717:   
 61717:   /**
 61717:    * Flag a child PresShell as painted so that it will get its paint count
 61717:    * incremented during empty transactions.
 61717:    */  
 61717:   void AddPaintedPresShell(nsIPresShell* shell) { 
 61717:     PaintedPresShellList()->AppendElement(do_GetWeakReference(shell)); 
 61717:   }
 61717:   
 61717:   /**
 61717:    * Increment the paint count of all child PresShells that were painted during
 61717:    * the last repaint.
 61717:    */  
 61717:   void UpdatePaintCountForPaintedPresShells() {
 61717:     nsTArray<nsWeakPtr> * list = PaintedPresShellList();
 61717:     for (int i = 0, l = list->Length(); i < l; i++) {
 61717:       nsCOMPtr<nsIPresShell> shell = do_QueryReferent(list->ElementAt(i));
 61717:       
 61717:       if (shell) {
 61717:         shell->IncrementPaintCount();
 61717:       }
 61717:     }
 61717:   }  
 61717: 
 79482:   /**
 79482:    * Accessors for the absolute containing block.
 79482:    */
 79482:   bool IsAbsoluteContainer() const { return !!(mState & NS_FRAME_HAS_ABSPOS_CHILDREN); }
 79482:   bool HasAbsolutelyPositionedChildren() const;
 79482:   nsAbsoluteContainingBlock* GetAbsoluteContainingBlock() const;
120164:   void MarkAsAbsoluteContainingBlock();
120164:   void MarkAsNotAbsoluteContainingBlock();
 79482:   // Child frame types override this function to select their own child list name
 79482:   virtual mozilla::layout::FrameChildListID GetAbsoluteListID() const { return kAbsoluteList; }
 79482: 
 80875:   // Checks if we (or any of our descendents) have NS_FRAME_PAINTED_THEBES set, and
 80875:   // clears this bit if so.
 80875:   bool CheckAndClearPaintedState();
 80875: 
 80910:   // CSS visibility just doesn't cut it because it doesn't inherit through
 80910:   // documents. Also if this frame is in a hidden card of a deck then it isn't
 80910:   // visible either and that isn't expressed using CSS visibility. Also if it
 80910:   // is in a hidden view (there are a few cases left and they are hopefully
 80910:   // going away soon).
 80910:   // If the VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY flag is passed then we
 80910:   // ignore the chrome/content boundary, otherwise we stop looking when we
 80910:   // reach it.
 80910:   enum {
 80910:     VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY = 0x01
 80910:   };
108991:   bool IsVisibleConsideringAncestors(uint32_t aFlags = 0) const;
 80910: 
107226:   inline bool IsBlockInside() const;
107226:   inline bool IsBlockOutside() const;
107226:   inline bool IsInlineOutside() const;
108991:   inline uint8_t GetDisplay() const;
107224:   inline bool IsFloating() const;
107225:   inline bool IsPositioned() const;
107225:   inline bool IsRelativelyPositioned() const;
107225:   inline bool IsAbsolutelyPositioned() const;
107224: 
107220:   /**
107220:    * Returns the vertical-align value to be used for layout, if it is one
107220:    * of the enumerated values.  If this is an SVG text frame, it returns a value
107220:    * that corresponds to the value of dominant-baseline.  If the
107220:    * vertical-align property has length or percentage value, this returns
107220:    * eInvalidVerticalAlign.
107220:    */
108991:   uint8_t VerticalAlignEnum() const;
107220:   enum { eInvalidVerticalAlign = 0xFF };
107220: 
107216:   bool IsSVGText() const { return mState & NS_FRAME_IS_SVG_TEXT; }
107216: 
118568:   void CreateOwnLayerIfNeeded(nsDisplayListBuilder* aBuilder, nsDisplayList* aList);
118568: 
     1: protected:
     1:   // Members
     1:   nsRect           mRect;
     1:   nsIContent*      mContent;
     1:   nsStyleContext*  mStyleContext;
     1:   nsIFrame*        mParent;
 32845: private:
 33388:   nsIFrame*        mNextSibling;  // doubly-linked list of frames
 33388:   nsIFrame*        mPrevSibling;  // Do not touch outside SetNextSibling!
 61717: 
 79483:   void MarkAbsoluteFramesForDisplayList(nsDisplayListBuilder* aBuilder, const nsRect& aDirtyRect);
 79483: 
 61717:   static void DestroyPaintedPresShellList(void* propertyValue) {
 61717:     nsTArray<nsWeakPtr>* list = static_cast<nsTArray<nsWeakPtr>*>(propertyValue);
 61717:     list->Clear();
 61717:     delete list;
 61717:   }
 61717: 
 61717:   // Stores weak references to all the PresShells that were painted during
 61717:   // the last paint event so that we can increment their paint count during
 61717:   // empty transactions
 61717:   NS_DECLARE_FRAME_PROPERTY(PaintedPresShellsProperty, DestroyPaintedPresShellList)
 61717:   
 61717:   nsTArray<nsWeakPtr>* PaintedPresShellList() {
 61717:     nsTArray<nsWeakPtr>* list = static_cast<nsTArray<nsWeakPtr>*>(
 61717:       Properties().Get(PaintedPresShellsProperty())
 61717:     );
 61717:     
 61717:     if (!list) {
 61717:       list = new nsTArray<nsWeakPtr>();
 61717:       Properties().Set(PaintedPresShellsProperty(), list);
 61717:     }
 61717:     
 61717:     return list;
 61717:   }
 61717: 
 32845: protected:
     1:   nsFrameState     mState;
     1: 
 26950:   // When there is an overflow area only slightly larger than mRect,
 26950:   // we store a set of four 1-byte deltas from the edges of mRect
 26950:   // rather than allocating a whole separate rectangle property.
 26950:   // Note that these are unsigned values, all measured "outwards"
 26950:   // from the edges of mRect, so /mLeft/ and /mTop/ are reversed from
 26950:   // our normal coordinate system.
 26950:   // If mOverflow.mType == NS_FRAME_OVERFLOW_LARGE, then the
 26950:   // delta values are not meaningful and the overflow area is stored
 26950:   // as a separate rect property.
 83439:   struct VisualDeltas {
108991:     uint8_t mLeft;
108991:     uint8_t mTop;
108991:     uint8_t mRight;
108991:     uint8_t mBottom;
 83439:     bool operator==(const VisualDeltas& aOther) const
 83439:     {
 83439:       return mLeft == aOther.mLeft && mTop == aOther.mTop &&
 83439:              mRight == aOther.mRight && mBottom == aOther.mBottom;
 83439:     }
 83439:     bool operator!=(const VisualDeltas& aOther) const
 83439:     {
 83439:       return !(*this == aOther);
 83439:     }
 83439:   };
 83439:   union {
108991:     uint32_t     mType;
 83439:     VisualDeltas mVisualDeltas;
 26950:   } mOverflow;
 26950: 
     1:   // Helpers
     1:   /**
     1:    * Can we stop inside this frame when we're skipping non-rendered whitespace?
     1:    * @param  aForward [in] Are we moving forward (or backward) in content order.
     1:    * @param  aOffset [in/out] At what offset into the frame to start looking.
     1:    *         on output - what offset was reached (whether or not we found a place to stop).
 80486:    * @return true: An appropriate offset was found within this frame,
     1:    *         and is given by aOffset.
 80486:    *         false: Not found within this frame, need to try the next frame.
     1:    */
108991:   virtual bool PeekOffsetNoAmount(bool aForward, int32_t* aOffset) = 0;
     1:   
     1:   /**
     1:    * Search the frame for the next character
     1:    * @param  aForward [in] Are we moving forward (or backward) in content order.
     1:    * @param  aOffset [in/out] At what offset into the frame to start looking.
     1:    *         on output - what offset was reached (whether or not we found a place to stop).
 59604:    * @param  aRespectClusters [in] Whether to restrict result to valid cursor locations
 59604:    *         (between grapheme clusters) - default TRUE maintains "normal" behavior,
 59604:    *         FALSE is used for selection by "code unit" (instead of "character")
 80486:    * @return true: An appropriate offset was found within this frame,
     1:    *         and is given by aOffset.
 80486:    *         false: Not found within this frame, need to try the next frame.
     1:    */
108991:   virtual bool PeekOffsetCharacter(bool aForward, int32_t* aOffset,
 79445:                                      bool aRespectClusters = true) = 0;
     1:   
     1:   /**
     1:    * Search the frame for the next word boundary
     1:    * @param  aForward [in] Are we moving forward (or backward) in content order.
 80486:    * @param  aWordSelectEatSpace [in] true: look for non-whitespace following
     1:    *         whitespace (in the direction of movement).
 80486:    *         false: look for whitespace following non-whitespace (in the
     1:    *         direction  of movement).
     1:    * @param  aIsKeyboardSelect [in] Was the action initiated by a keyboard operation?
 80486:    *         If true, punctuation immediately following a word is considered part
     1:    *         of that word. Otherwise, a sequence of punctuation is always considered
     1:    *         as a word on its own.
     1:    * @param  aOffset [in/out] At what offset into the frame to start looking.
     1:    *         on output - what offset was reached (whether or not we found a place to stop).
  5453:    * @param  aState [in/out] the state that is carried from frame to frame
 80486:    * @return true: An appropriate offset was found within this frame,
     1:    *         and is given by aOffset.
 80486:    *         false: Not found within this frame, need to try the next frame.
     1:    */
  5453:   struct PeekWordState {
  5453:     // true when we're still at the start of the search, i.e., we can't return
  5453:     // this point as a valid offset!
 79445:     bool mAtStart;
  5453:     // true when we've encountered at least one character of the pre-boundary type
  5453:     // (whitespace if aWordSelectEatSpace is true, non-whitespace otherwise)
 79445:     bool mSawBeforeType;
  5453:     // true when the last character encountered was punctuation
 79445:     bool mLastCharWasPunctuation;
 12505:     // true when the last character encountered was whitespace
 79445:     bool mLastCharWasWhitespace;
 12505:     // true when we've seen non-punctuation since the last whitespace
 79445:     bool mSeenNonPunctuationSinceWhitespace;
  7679:     // text that's *before* the current frame when aForward is true, *after*
 12505:     // the current frame when aForward is false. Only includes the text
 12505:     // on the current line.
  7679:     nsAutoString mContext;
  5453: 
 80486:     PeekWordState() : mAtStart(true), mSawBeforeType(false),
 80486:         mLastCharWasPunctuation(false), mLastCharWasWhitespace(false),
 80486:         mSeenNonPunctuationSinceWhitespace(false) {}
 80486:     void SetSawBeforeType() { mSawBeforeType = true; }
 79445:     void Update(bool aAfterPunctuation, bool aAfterWhitespace) {
  5453:       mLastCharWasPunctuation = aAfterPunctuation;
 12505:       mLastCharWasWhitespace = aAfterWhitespace;
 12505:       if (aAfterWhitespace) {
 80486:         mSeenNonPunctuationSinceWhitespace = false;
 12505:       } else if (!aAfterPunctuation) {
 80486:         mSeenNonPunctuationSinceWhitespace = true;
 12505:       }
 80486:       mAtStart = false;
  5453:     }
  5453:   };
 79445:   virtual bool PeekOffsetWord(bool aForward, bool aWordSelectEatSpace, bool aIsKeyboardSelect,
108991:                                 int32_t* aOffset, PeekWordState* aState) = 0;
     1: 
     1:   /**
     1:    * Search for the first paragraph boundary before or after the given position
     1:    * @param  aPos See description in nsFrameSelection.h. The following fields are
     1:    *              used by this method: 
     1:    *              Input: mDirection
     1:    *              Output: mResultContent, mContentOffset
     1:    */
     1:   nsresult PeekOffsetParagraph(nsPeekOffsetStruct *aPos);
     1: 
     1: private:
 55021:   nsOverflowAreas* GetOverflowAreasProperty();
 55021:   nsRect GetVisualOverflowFromDeltas() const {
 55021:     NS_ABORT_IF_FALSE(mOverflow.mType != NS_FRAME_OVERFLOW_LARGE,
 55021:                       "should not be called when overflow is in a property");
 55021:     // Calculate the rect using deltas from the frame's border rect.
 55021:     // Note that the mOverflow.mDeltas fields are unsigned, but we will often
 55021:     // need to return negative values for the left and top, so take care
 55021:     // to cast away the unsigned-ness.
108991:     return nsRect(-(int32_t)mOverflow.mVisualDeltas.mLeft,
108991:                   -(int32_t)mOverflow.mVisualDeltas.mTop,
 55021:                   mRect.width + mOverflow.mVisualDeltas.mRight +
 55021:                                 mOverflow.mVisualDeltas.mLeft,
 55021:                   mRect.height + mOverflow.mVisualDeltas.mBottom +
 55021:                                  mOverflow.mVisualDeltas.mTop);
 55021:   }
 83439:   /**
 83439:    * Returns true if any overflow changed.
 83439:    */
 83439:   bool SetOverflowAreas(const nsOverflowAreas& aOverflowAreas);
108991:   nsPoint GetOffsetToCrossDoc(const nsIFrame* aOther, const int32_t aAPD) const;
 31709: 
102909: #ifdef DEBUG
 31709: public:
 31709:   // Formerly nsIFrameDebug
114372:   enum {
114372:     TRAVERSE_SUBDOCUMENT_FRAMES = 0x01
114372:   };
114372:   NS_IMETHOD  List(FILE* out, int32_t aIndent, uint32_t aFlags = 0) const = 0;
 31709:   NS_IMETHOD  GetFrameName(nsAString& aResult) const = 0;
 31709:   NS_IMETHOD_(nsFrameState)  GetDebugStateBits() const = 0;
 31709:   NS_IMETHOD  DumpRegressionData(nsPresContext* aPresContext,
108991:                                  FILE* out, int32_t aIndent) = 0;
 31709: #endif
     1: };
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: /**
     1:  * nsWeakFrame can be used to keep a reference to a nsIFrame in a safe way.
     1:  * Whenever an nsIFrame object is deleted, the nsWeakFrames pointing
     1:  * to it will be cleared.
     1:  *
     1:  * Create nsWeakFrame object when it is sure that nsIFrame object
     1:  * is alive and after some operations which may destroy the nsIFrame
     1:  * (for example any DOM modifications) use IsAlive() or GetFrame() methods to
     1:  * check whether it is safe to continue to use the nsIFrame object.
     1:  *
     1:  * @note The usage of this class should be kept to a minimum.
     1:  */
     1: 
     1: class nsWeakFrame {
     1: public:
106838:   nsWeakFrame() : mPrev(nullptr), mFrame(nullptr) { }
106838: 
106838:   nsWeakFrame(const nsWeakFrame& aOther) : mPrev(nullptr), mFrame(nullptr)
 51735:   {
 51735:     Init(aOther.GetFrame());
 51735:   }
 51735: 
106838:   nsWeakFrame(nsIFrame* aFrame) : mPrev(nullptr), mFrame(nullptr)
     1:   {
     1:     Init(aFrame);
     1:   }
     1: 
     1:   nsWeakFrame& operator=(nsWeakFrame& aOther) {
     1:     Init(aOther.GetFrame());
     1:     return *this;
     1:   }
     1: 
     1:   nsWeakFrame& operator=(nsIFrame* aFrame) {
     1:     Init(aFrame);
     1:     return *this;
     1:   }
     1: 
     1:   nsIFrame* operator->()
     1:   {
     1:     return mFrame;
     1:   }
     1: 
     1:   operator nsIFrame*()
     1:   {
     1:     return mFrame;
     1:   }
     1: 
     1:   void Clear(nsIPresShell* aShell) {
     1:     if (aShell) {
     1:       aShell->RemoveWeakFrame(this);
     1:     }
106838:     mFrame = nullptr;
106838:     mPrev = nullptr;
     1:   }
     1: 
 79445:   bool IsAlive() { return !!mFrame; }
     1: 
 51735:   nsIFrame* GetFrame() const { return mFrame; }
     1: 
     1:   nsWeakFrame* GetPreviousWeakFrame() { return mPrev; }
     1: 
     1:   void SetPreviousWeakFrame(nsWeakFrame* aPrev) { mPrev = aPrev; }
     1: 
     1:   ~nsWeakFrame()
     1:   {
106838:     Clear(mFrame ? mFrame->PresContext()->GetPresShell() : nullptr);
     1:   }
     1: private:
 34904:   void InitInternal(nsIFrame* aFrame);
 34904: 
 34904:   void InitExternal(nsIFrame* aFrame) {
106838:     Clear(mFrame ? mFrame->PresContext()->GetPresShell() : nullptr);
 34904:     mFrame = aFrame;
 34904:     if (mFrame) {
 34904:       nsIPresShell* shell = mFrame->PresContext()->GetPresShell();
 34904:       NS_WARN_IF_FALSE(shell, "Null PresShell in nsWeakFrame!");
 34904:       if (shell) {
 34904:         shell->AddWeakFrame(this);
 34904:       } else {
106838:         mFrame = nullptr;
 34904:       }
 34904:     }
 34904:   }
 34904: 
 34904:   void Init(nsIFrame* aFrame) {
 34904: #ifdef _IMPL_NS_LAYOUT
 34904:     InitInternal(aFrame);
 34904: #else
 34904:     InitExternal(aFrame);
 34904: #endif
 34904:   }
     1: 
     1:   nsWeakFrame*  mPrev;
     1:   nsIFrame*     mFrame;
     1: };
     1: 
 30779: inline void
 32843: nsFrameList::Enumerator::Next()
 32843: {
 30779:   NS_ASSERTION(!AtEnd(), "Should have checked AtEnd()!");
 30779:   mFrame = mFrame->GetNextSibling();
 30779: }
 30779: 
 33276: inline
 33276: nsFrameList::FrameLinkEnumerator::
 33276: FrameLinkEnumerator(const nsFrameList& aList, nsIFrame* aPrevFrame)
 33276:   : Enumerator(aList)
 33276: {
 33276:   mPrev = aPrevFrame;
 33276:   mFrame = aPrevFrame ? aPrevFrame->GetNextSibling() : aList.FirstChild();
 33276: }
107224: 
107224: #include "nsStyleStructInlines.h"
107224: 
107224: bool
107224: nsIFrame::IsFloating() const
107224: {
107224:   return GetStyleDisplay()->IsFloating(this);
107224: }
107224: 
107225: bool
107225: nsIFrame::IsPositioned() const
107225: {
107225:   return GetStyleDisplay()->IsPositioned(this);
107225: }
107225: 
107225: bool
107225: nsIFrame::IsRelativelyPositioned() const
107225: {
107225:   return GetStyleDisplay()->IsRelativelyPositioned(this);
107225: }
107225: 
107225: bool
107225: nsIFrame::IsAbsolutelyPositioned() const
107225: {
107225:   return GetStyleDisplay()->IsAbsolutelyPositioned(this);
107225: }
107225: 
107226: bool
107226: nsIFrame::IsBlockInside() const
107226: {
107226:   return GetStyleDisplay()->IsBlockInside(this);
107226: }
107226: 
107226: bool
107226: nsIFrame::IsBlockOutside() const
107226: {
107226:   return GetStyleDisplay()->IsBlockOutside(this);
107226: }
107226: 
107226: bool
107226: nsIFrame::IsInlineOutside() const
107226: {
107226:   return GetStyleDisplay()->IsInlineOutside(this);
107226: }
107226: 
108991: uint8_t
107226: nsIFrame::GetDisplay() const
107226: {
107226:   return GetStyleDisplay()->GetDisplay(this);
107226: }
107226: 
     1: #endif /* nsIFrame_h___ */
