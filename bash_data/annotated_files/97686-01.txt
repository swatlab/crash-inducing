54707: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
54707:  * vim: set ts=4 sw=4 et tw=99:
54707:  *
54707:  * ***** BEGIN LICENSE BLOCK *****
54707:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54707:  *
54707:  * The contents of this file are subject to the Mozilla Public License Version
54707:  * 1.1 (the "License"); you may not use this file except in compliance with
54707:  * the License. You may obtain a copy of the License at
54707:  * http://www.mozilla.org/MPL/
54707:  *
54707:  * Software distributed under the License is distributed on an "AS IS" basis,
54707:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54707:  * for the specific language governing rights and limitations under the
54707:  * License.
54707:  *
54707:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
54707:  * May 28, 2008.
54707:  *
54707:  * The Initial Developer of the Original Code is
54707:  *   Mozilla Foundation
54707:  * Portions created by the Initial Developer are Copyright (C) 2010
54707:  * the Initial Developer. All Rights Reserved.
54707:  *
54707:  * Contributor(s):
54707:  *
54707:  * Alternatively, the contents of this file may be used under the terms of
54707:  * either of the GNU General Public License Version 2 or later (the "GPL"),
54707:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54707:  * in which case the provisions of the GPL or the LGPL are applicable instead
54707:  * of those above. If you wish to allow use of your version of this file only
54707:  * under the terms of either the GPL or the LGPL, and not to allow others to
54707:  * use your version of this file under the terms of the MPL, indicate your
54707:  * decision by deleting the provisions above and replace them with the notice
54707:  * and other provisions required by the GPL or the LGPL. If you do not delete
54707:  * the provisions above, a recipient may use your version of this file under
54707:  * the terms of any one of the MPL, the GPL or the LGPL.
54707:  *
54707:  * ***** END LICENSE BLOCK ***** */
54707: 
56574: #include "jscntxt.h"
54707: #include "jscompartment.h"
54707: #include "jsgc.h"
56574: #include "jsiter.h"
72075: #include "jsmath.h"
54707: #include "jsproxy.h"
54707: #include "jsscope.h"
74472: #include "jswatchpoint.h"
62594: #include "jswrapper.h"
86104: 
61427: #include "assembler/wtf/Platform.h"
97569: #include "gc/Marking.h"
86104: #include "js/MemoryMetrics.h"
56773: #include "methodjit/MethodJIT.h"
54707: #include "methodjit/PolyIC.h"
54707: #include "methodjit/MonoIC.h"
76244: #include "vm/Debugger.h"
86104: #include "yarr/BumpPointerAllocator.h"
54707: 
54707: #include "jsgcinlines.h"
82129: #include "jsobjinlines.h"
64285: #include "jsscopeinlines.h"
54707: 
62572: #if ENABLE_YARR_JIT
62572: #include "assembler/jit/ExecutableAllocator.h"
62572: #endif
62572: 
80468: using namespace mozilla;
54707: using namespace js;
54707: using namespace js::gc;
54707: 
54707: JSCompartment::JSCompartment(JSRuntime *rt)
59735:   : rt(rt),
59735:     principals(NULL),
82129:     needsBarrier_(false),
94620:     gcState(NoGCScheduled),
60258:     gcBytes(0),
60258:     gcTriggerBytes(0),
64258:     hold(false),
79410:     typeLifoAlloc(TYPE_LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
59735:     data(NULL),
59922:     active(false),
89918:     regExps(rt),
63147:     propertyTree(thisForCtor()),
83230:     emptyTypeObject(NULL),
91825:     gcMallocAndFreeBytes(0),
91825:     gcTriggerMallocAndFreeBytes(0),
91825:     gcMallocBytes(0),
76246:     debugModeBits(rt->debugMode ? DebugFromC : 0),
95113:     watchpointMap(NULL),
95139:     scriptCountsMap(NULL),
95151:     sourceMapMap(NULL),
95151:     debugScriptMap(NULL)
54707: {
88570:     setGCMaxMallocBytes(rt->gcMaxMallocBytes * 0.9);
54707: }
54707: 
54707: JSCompartment::~JSCompartment()
54707: {
74472:     Foreground::delete_(watchpointMap);
95113:     Foreground::delete_(scriptCountsMap);
95139:     Foreground::delete_(sourceMapMap);
95151:     Foreground::delete_(debugScriptMap);
54707: }
54707: 
54707: bool
77343: JSCompartment::init(JSContext *cx)
54707: {
77343:     activeAnalysis = activeInference = false;
77343:     types.init(cx);
77343: 
56773:     if (!crossCompartmentWrappers.init())
56773:         return false;
56773: 
89918:     if (!regExps.init(cx))
89918:         return false;
89918: 
84195:     return debuggees.init();
54707: }
54707: 
54707: bool
54707: JSCompartment::wrap(JSContext *cx, Value *vp)
54707: {
54707:     JS_ASSERT(cx->compartment == this);
54707: 
91237:     unsigned flags = 0;
54707: 
54707:     JS_CHECK_RECURSION(cx, return false);
54707: 
54707:     /* Only GC things have to be wrapped or copied. */
54707:     if (!vp->isMarkable())
54707:         return true;
54707: 
54862:     if (vp->isString()) {
54862:         JSString *str = vp->toString();
54862: 
54862:         /* If the string is already in this compartment, we are done. */
64345:         if (str->compartment() == this)
54862:             return true;
54862: 
54862:         /* If the string is an atom, we don't have to copy. */
64343:         if (str->isAtom()) {
64345:             JS_ASSERT(str->compartment() == cx->runtime->atomsCompartment);
54862:             return true;
54862:         }
54862:     }
54862: 
55628:     /*
55628:      * Wrappers should really be parented to the wrapped parent of the wrapped
55628:      * object, but in that case a wrapped global object would have a NULL
77544:      * parent without being a proper global object (JSCLASS_IS_GLOBAL). Instead,
55628:      * we parent all wrappers to the global object in their home compartment.
55628:      * This loses us some transparency, and is generally very cheesy.
55628:      */
97353:     RootedVarObject global(cx);
71696:     if (cx->hasfp()) {
96793:         global = &cx->fp()->global();
62876:     } else {
79734:         global = JS_ObjectToInnerObject(cx, cx->globalObject);
79734:         if (!global)
55628:             return false;
62876:     }
55628: 
54707:     /* Unwrap incoming objects. */
54707:     if (vp->isObject()) {
54707:         JSObject *obj = &vp->toObject();
54707: 
54707:         /* If the object is already in this compartment, we are done. */
54862:         if (obj->compartment() == this)
54707:             return true;
54707: 
56574:         /* Translate StopIteration singleton. */
77817:         if (obj->isStopIteration())
56574:             return js_FindClassObject(cx, NULL, JSProto_StopIteration, vp);
56574: 
54707:         /* Don't unwrap an outer window proxy. */
54707:         if (!obj->getClass()->ext.innerObject) {
89339:             obj = UnwrapObject(&vp->toObject(), true, &flags);
55628:             vp->setObject(*obj);
79734:             if (obj->compartment() == this)
55628:                 return true;
55628: 
60246:             if (cx->runtime->preWrapObjectCallback) {
55628:                 obj = cx->runtime->preWrapObjectCallback(cx, global, obj, flags);
55628:                 if (!obj)
55628:                     return false;
60246:             }
55611: 
55611:             vp->setObject(*obj);
79734:             if (obj->compartment() == this)
55611:                 return true;
55611:         } else {
60246:             if (cx->runtime->preWrapObjectCallback) {
55691:                 obj = cx->runtime->preWrapObjectCallback(cx, global, obj, flags);
60246:                 if (!obj)
60246:                     return false;
60246:             }
55691: 
55611:             JS_ASSERT(!obj->isWrapper() || obj->getClass()->ext.innerObject);
55611:             vp->setObject(*obj);
55611:         }
55611: 
55628: #ifdef DEBUG
55628:         {
55628:             JSObject *outer = obj;
55628:             OBJ_TO_OUTER_OBJECT(cx, outer);
55628:             JS_ASSERT(outer && outer == obj);
55628:         }
55628: #endif
54707:     }
54707: 
54707:     /* If we already have a wrapper for this value, use it. */
54707:     if (WrapperMap::Ptr p = crossCompartmentWrappers.lookup(*vp)) {
54707:         *vp = p->value;
62594:         if (vp->isObject()) {
97353:             RootedVarObject obj(cx, &vp->toObject());
79734:             JS_ASSERT(obj->isCrossCompartmentWrapper());
80803:             if (global->getClass() != &dummy_class && obj->getParent() != global) {
62594:                 do {
97353:                     if (!JSObject::setParent(cx, obj, global))
83245:                         return false;
62594:                     obj = obj->getProto();
79734:                 } while (obj && obj->isCrossCompartmentWrapper());
62594:             }
62594:         }
54707:         return true;
54707:     }
54707: 
54707:     if (vp->isString()) {
97353:         RootedVarValue orig(cx, *vp);
54707:         JSString *str = vp->toString();
59890:         const jschar *chars = str->getChars(cx);
59890:         if (!chars)
59890:             return false;
59890:         JSString *wrapped = js_NewStringCopyN(cx, chars, str->length());
54707:         if (!wrapped)
54707:             return false;
54707:         vp->setString(wrapped);
54707:         return crossCompartmentWrappers.put(orig, *vp);
54707:     }
54707: 
97353:     RootedVarObject obj(cx, &vp->toObject());
54707: 
54707:     /*
54707:      * Recurse to wrap the prototype. Long prototype chains will run out of
54707:      * stack, causing an error in CHECK_RECURSE.
54707:      *
54707:      * Wrapping the proto before creating the new wrapper and adding it to the
54707:      * cache helps avoid leaving a bad entry in the cache on OOM. But note that
54707:      * if we wrapped both proto and parent, we would get infinite recursion
54707:      * here (since Object.prototype->parent->proto leads to Object.prototype
54707:      * itself).
54707:      */
97353:     RootedVarObject proto(cx, obj->getProto());
97353:     if (!wrap(cx, proto.address()))
54707:         return false;
54707: 
54707:     /*
55580:      * We hand in the original wrapped object into the wrap hook to allow
55580:      * the wrap hook to reason over what wrappers are currently applied
55580:      * to the object.
55580:      */
97353:     RootedVarObject wrapper(cx, cx->runtime->wrapObjectCallback(cx, obj, proto, global, flags));
55580:     if (!wrapper)
55580:         return false;
55580: 
55580:     vp->setObject(*wrapper);
55580: 
77343:     if (wrapper->getProto() != proto && !SetProto(cx, wrapper, proto, false))
77343:         return false;
77343: 
79734:     if (!crossCompartmentWrappers.put(GetProxyPrivate(wrapper), *vp))
55580:         return false;
55580: 
97353:     if (!JSObject::setParent(cx, wrapper, global))
83245:         return false;
54707:     return true;
54707: }
54707: 
54707: bool
54707: JSCompartment::wrap(JSContext *cx, JSString **strp)
54707: {
97353:     RootedVarValue value(cx, StringValue(*strp));
97353:     if (!wrap(cx, value.address()))
54707:         return false;
97353:     *strp = value.reference().toString();
54707:     return true;
54707: }
54707: 
54707: bool
82129: JSCompartment::wrap(JSContext *cx, HeapPtrString *strp)
82129: {
97353:     RootedVarValue value(cx, StringValue(*strp));
97353:     if (!wrap(cx, value.address()))
82129:         return false;
97353:     *strp = value.reference().toString();
82129:     return true;
82129: }
82129: 
82129: bool
54707: JSCompartment::wrap(JSContext *cx, JSObject **objp)
54707: {
54707:     if (!*objp)
54707:         return true;
97353:     RootedVarValue value(cx, ObjectValue(**objp));
97353:     if (!wrap(cx, value.address()))
54707:         return false;
97353:     *objp = &value.reference().toObject();
54707:     return true;
54707: }
54707: 
54707: bool
54707: JSCompartment::wrapId(JSContext *cx, jsid *idp)
54707: {
54707:     if (JSID_IS_INT(*idp))
54707:         return true;
97353:     RootedVarValue value(cx, IdToValue(*idp));
97353:     if (!wrap(cx, value.address()))
54707:         return false;
97353:     return ValueToId(cx, value.reference(), idp);
54707: }
54707: 
54707: bool
54707: JSCompartment::wrap(JSContext *cx, PropertyOp *propp)
54707: {
54707:     Value v = CastAsObjectJsval(*propp);
54707:     if (!wrap(cx, &v))
54707:         return false;
54707:     *propp = CastAsPropertyOp(v.toObjectOrNull());
54707:     return true;
54707: }
54707: 
54707: bool
62395: JSCompartment::wrap(JSContext *cx, StrictPropertyOp *propp)
62395: {
62395:     Value v = CastAsObjectJsval(*propp);
62395:     if (!wrap(cx, &v))
62395:         return false;
62395:     *propp = CastAsStrictPropertyOp(v.toObjectOrNull());
62395:     return true;
62395: }
62395: 
62395: bool
54707: JSCompartment::wrap(JSContext *cx, PropertyDescriptor *desc)
54707: {
54707:     return wrap(cx, &desc->obj) &&
54707:            (!(desc->attrs & JSPROP_GETTER) || wrap(cx, &desc->getter)) &&
54707:            (!(desc->attrs & JSPROP_SETTER) || wrap(cx, &desc->setter)) &&
54707:            wrap(cx, &desc->value);
54707: }
54707: 
54707: bool
54707: JSCompartment::wrap(JSContext *cx, AutoIdVector &props)
54707: {
54707:     jsid *vector = props.begin();
91450:     int length = props.length();
54707:     for (size_t n = 0; n < size_t(length); ++n) {
54707:         if (!wrapId(cx, &vector[n]))
54707:             return false;
54707:     }
54707:     return true;
54707: }
54707: 
62077: /*
62077:  * This method marks pointers that cross compartment boundaries. It should be
64258:  * called only for per-compartment GCs, since full GCs naturally follow pointers
62077:  * across compartments.
62077:  */
62077: void
64258: JSCompartment::markCrossCompartmentWrappers(JSTracer *trc)
62077: {
94620:     JS_ASSERT(!isCollecting());
64258: 
90302:     for (WrapperMap::Enum e(crossCompartmentWrappers); !e.empty(); e.popFront()) {
90302:         Value tmp = e.front().key;
90302:         MarkValueRoot(trc, &tmp, "cross-compartment wrapper");
90302:         JS_ASSERT(tmp == e.front().key);
90302:     }
62077: }
62077: 
62060: void
77343: JSCompartment::markTypes(JSTracer *trc)
77343: {
77441:     /*
77441:      * Mark all scripts, type objects and singleton JS objects in the
77441:      * compartment. These can be referred to directly by type sets, which we
77441:      * cannot modify while code which depends on these type sets is active.
77441:      */
77343:     JS_ASSERT(activeAnalysis);
77343: 
77659:     for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
77659:         JSScript *script = i.get<JSScript>();
90409:         MarkScriptRoot(trc, &script, "mark_types_script");
90409:         JS_ASSERT(script == i.get<JSScript>());
77343:     }
77343: 
77775:     for (size_t thingKind = FINALIZE_OBJECT0;
83301:          thingKind < FINALIZE_OBJECT_LIMIT;
77464:          thingKind++) {
77775:         for (CellIterUnderGC i(this, AllocKind(thingKind)); !i.done(); i.next()) {
77659:             JSObject *object = i.get<JSObject>();
90409:             if (object->hasSingletonType()) {
90409:                 MarkObjectRoot(trc, &object, "mark_types_singleton");
90409:                 JS_ASSERT(object == i.get<JSObject>());
90409:             }
77659:         }
77464:     }
77441: 
90409:     for (CellIterUnderGC i(this, FINALIZE_TYPE_OBJECT); !i.done(); i.next()) {
90409:         types::TypeObject *type = i.get<types::TypeObject>();
90409:         MarkTypeObjectRoot(trc, &type, "mark_types_scan");
90409:         JS_ASSERT(type == i.get<types::TypeObject>());
90409:     }
77441: }
77343: 
77343: void
94740: JSCompartment::discardJitCode(FreeOp *fop)
54707: {
80819:     /*
80819:      * Kick all frames on the stack into the interpreter, and release all JIT
80819:      * code in the compartment.
80819:      */
78637: #ifdef JS_METHODJIT
80819:     mjit::ClearAllFrames(this);
80819: 
78389:     for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
78389:         JSScript *script = i.get<JSScript>();
94740:         mjit::ReleaseScriptCode(fop, script);
80819: 
80819:         /*
80819:          * Use counts for scripts are reset on GC. After discarding code we
80819:          * need to let it warm back up to get information like which opcodes
80819:          * are setting array holes or accessing getter properties.
80819:          */
80819:         script->resetUseCount();
78413:     }
78413: #endif
82095: }
78413: 
90410: void
94738: JSCompartment::sweep(FreeOp *fop, bool releaseTypes)
90410: {
90410:     /* Remove dead wrappers from the table. */
90410:     for (WrapperMap::Enum e(crossCompartmentWrappers); !e.empty(); e.popFront()) {
90410:         JS_ASSERT_IF(IsAboutToBeFinalized(e.front().key) &&
90410:                      !IsAboutToBeFinalized(e.front().value),
90410:                      e.front().key.isString());
90410:         if (IsAboutToBeFinalized(e.front().key) ||
90410:             IsAboutToBeFinalized(e.front().value)) {
90410:             e.removeFront();
90410:         }
90410:     }
90410: 
90410:     /* Remove dead references held weakly by the compartment. */
90410: 
90410:     regExps.sweep(rt);
90410: 
94738:     sweepBaseShapeTable();
94738:     sweepInitialShapeTable();
94738:     sweepNewTypeObjectTable(newTypeObjects);
94738:     sweepNewTypeObjectTable(lazyTypeObjects);
90410: 
90410:     if (emptyTypeObject && IsAboutToBeFinalized(emptyTypeObject))
90410:         emptyTypeObject = NULL;
90410: 
94738:     sweepBreakpoints(fop);
90410: 
90410:     {
90410:         gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_DISCARD_CODE);
94740:         discardJitCode(fop);
90410:     }
90410: 
80819:     if (!activeAnalysis) {
82095:         gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_DISCARD_ANALYSIS);
82095: 
77892:         /*
77892:          * Clear the analysis pool, but don't release its data yet. While
77439:          * sweeping types any live data will be allocated into the pool.
77439:          */
79410:         LifoAlloc oldAlloc(typeLifoAlloc.defaultChunkSize());
79410:         oldAlloc.steal(&typeLifoAlloc);
77439: 
77439:         /*
80819:          * Periodically release observed types for all scripts. This is safe to
80819:          * do when there are no frames for the compartment on the stack.
80819:          */
80819:         if (active)
80819:             releaseTypes = false;
80819: 
80819:         /*
77353:          * Sweep analysis information and everything depending on it from the
77353:          * compartment, including all remaining mjit code if inference is
77353:          * enabled in the compartment.
77353:          */
77353:         if (types.inferenceEnabled) {
93368:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_DISCARD_TI);
93368: 
77659:             for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
77659:                 JSScript *script = i.get<JSScript>();
77439:                 if (script->types) {
94740:                     types::TypeScript::Sweep(fop, script);
77439: 
80819:                     if (releaseTypes) {
77439:                         script->types->destroy();
77439:                         script->types = NULL;
77885:                         script->typesPurged = true;
77439:                     }
77439:                 }
77343:             }
77343:         }
77343: 
93368:         {
93368:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_SWEEP_TYPES);
94740:             types.sweep(fop);
93368:         }
77361: 
93368:         {
93368:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_CLEAR_SCRIPT_ANALYSIS);
77659:             for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
77659:                 JSScript *script = i.get<JSScript>();
77884:                 script->clearAnalysis();
77353:             }
77343:         }
93368:     }
59895: 
59895:     active = false;
54707: }
54707: 
54707: void
91250: JSCompartment::purge()
54707: {
61432:     dtoaCache.purge();
54707: }
59735: 
88570: void
88570: JSCompartment::resetGCMallocBytes()
88570: {
88570:     gcMallocBytes = ptrdiff_t(gcMaxMallocBytes);
88570: }
88570: 
88570: void
88570: JSCompartment::setGCMaxMallocBytes(size_t value)
88570: {
88570:     /*
88570:      * For compatibility treat any value that exceeds PTRDIFF_T_MAX to
88570:      * mean that value.
88570:      */
88570:     gcMaxMallocBytes = (ptrdiff_t(value) >= 0) ? value : size_t(-1) >> 1;
88570:     resetGCMallocBytes();
88570: }
88570: 
88570: void
88570: JSCompartment::onTooMuchMalloc()
88570: {
88570:     TriggerCompartmentGC(this, gcreason::TOO_MUCH_MALLOC);
88570: }
88570: 
88570: 
75402: bool
91250: JSCompartment::hasScriptsOnStack()
75489: {
91250:     for (AllFramesIter i(rt->stackSpace); !i.done(); ++i) {
75489:         JSScript *script = i.fp()->maybeScript();
77659:         if (script && script->compartment() == this)
75489:             return true;
75489:     }
75489:     return false;
75489: }
75489: 
75489: bool
75489: JSCompartment::setDebugModeFromC(JSContext *cx, bool b)
75489: {
75489:     bool enabledBefore = debugMode();
91237:     bool enabledAfter = (debugModeBits & ~unsigned(DebugFromC)) || b;
75489: 
75489:     // Debug mode can be enabled only when no scripts from the target
75489:     // compartment are on the stack. It would even be incorrect to discard just
75489:     // the non-live scripts' JITScripts because they might share ICs with live
75489:     // scripts (bug 632343).
75489:     //
75489:     // We do allow disabling debug mode while scripts are on the stack.  In
75489:     // that case the debug-mode code for those scripts remains, so subsequently
75489:     // hooks may be called erroneously, even though debug mode is supposedly
75489:     // off, and we have to live with it.
75489:     //
75489:     bool onStack = false;
75489:     if (enabledBefore != enabledAfter) {
91250:         onStack = hasScriptsOnStack();
75489:         if (b && onStack) {
75489:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_IDLE);
75489:             return false;
75489:         }
75489:     }
75489: 
91237:     debugModeBits = (debugModeBits & ~unsigned(DebugFromC)) | (b ? DebugFromC : 0);
75489:     JS_ASSERT(debugMode() == enabledAfter);
77166:     if (enabledBefore != enabledAfter)
94740:         updateForDebugMode(cx->runtime->defaultFreeOp());
75489:     return true;
75489: }
75489: 
75489: void
94740: JSCompartment::updateForDebugMode(FreeOp *fop)
75489: {
91250:     for (ContextIter acx(rt); !acx.done(); acx.next()) {
91250:         if (acx->compartment == this) 
91250:             acx->updateJITEnabled();
77166:     }
77166: 
75489: #ifdef JS_METHODJIT
75497:     bool enabled = debugMode();
75497: 
91431:     if (enabled)
91250:         JS_ASSERT(!hasScriptsOnStack());
91431:     else if (hasScriptsOnStack())
75497:         return;
75489: 
91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
77659:         JSScript *script = i.get<JSScript>();
94740:         mjit::ReleaseScriptCode(fop, script);
75497:         script->debugMode = enabled;
75489:     }
97686: 
97686:     // Discard JIT code and bytecode analysis for all scripts in this
97686:     // compartment. Because !hasScriptsOnStack(), it suffices to do a garbage
97686:     // collection cycle or to finish the ongoing GC cycle. The necessary
97686:     // cleanup happens in JSCompartment::sweep.
97686:     if (!rt->gcRunning) {
97686:         PrepareCompartmentForGC(this);
97686:         GC(rt, GC_NORMAL, gcreason::DEBUG_MODE_GC);
75489:     }
75489: #endif
75489: }
75497: 
75497: bool
75497: JSCompartment::addDebuggee(JSContext *cx, js::GlobalObject *global)
75497: {
75497:     bool wasEnabled = debugMode();
75497:     if (!debuggees.put(global)) {
75497:         js_ReportOutOfMemory(cx);
75497:         return false;
75497:     }
75497:     debugModeBits |= DebugFromJS;
75497:     if (!wasEnabled)
94740:         updateForDebugMode(cx->runtime->defaultFreeOp());
75497:     return true;
75497: }
75497: 
75497: void
94740: JSCompartment::removeDebuggee(FreeOp *fop,
75497:                               js::GlobalObject *global,
75497:                               js::GlobalObjectSet::Enum *debuggeesEnum)
75497: {
75497:     bool wasEnabled = debugMode();
75497:     JS_ASSERT(debuggees.has(global));
75497:     if (debuggeesEnum)
75497:         debuggeesEnum->removeFront();
75497:     else
75497:         debuggees.remove(global);
75497: 
75497:     if (debuggees.empty()) {
75497:         debugModeBits &= ~DebugFromJS;
75497:         if (wasEnabled && !debugMode())
94740:             updateForDebugMode(fop);
75497:     }
75497: }
75506: 
84195: void
94959: JSCompartment::clearBreakpointsIn(FreeOp *fop, js::Debugger *dbg, JSObject *handler)
75506: {
91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
84195:         JSScript *script = i.get<JSScript>();
84195:         if (script->hasAnyBreakpointsOrStepMode())
94959:             script->clearBreakpointsIn(fop, dbg, handler);
75506:     }
75506: }
75506: 
75506: void
94959: JSCompartment::clearTraps(FreeOp *fop)
75506: {
91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
84195:         JSScript *script = i.get<JSScript>();
84195:         if (script->hasAnyBreakpointsOrStepMode())
94959:             script->clearTraps(fop);
75506:     }
75506: }
75506: 
75506: void
94738: JSCompartment::sweepBreakpoints(FreeOp *fop)
75506: {
94738:     if (JS_CLIST_IS_EMPTY(&rt->debuggerList))
84195:         return;
76243: 
84195:     for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
84195:         JSScript *script = i.get<JSScript>();
84195:         if (!script->hasAnyBreakpointsOrStepMode())
84195:             continue;
89658:         bool scriptGone = IsAboutToBeFinalized(script);
84195:         for (unsigned i = 0; i < script->length; i++) {
84195:             BreakpointSite *site = script->getBreakpointSite(script->code + i);
84195:             if (!site)
84195:                 continue;
84195:             // nextbp is necessary here to avoid possibly reading *bp after
84195:             // destroying it.
76233:             Breakpoint *nextbp;
76233:             for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = nextbp) {
76233:                 nextbp = bp->nextInSite();
89658:                 if (scriptGone || IsAboutToBeFinalized(bp->debugger->toJSObject()))
94740:                     bp->destroy(fop);
75506:             }
84195:         }
75506:     }
75506: }
82129: 
88146: size_t
88579: JSCompartment::sizeOfShapeTable(JSMallocSizeOfFun mallocSizeOf)
86104: {
88579:     return baseShapes.sizeOfExcludingThis(mallocSizeOf)
88579:          + initialShapes.sizeOfExcludingThis(mallocSizeOf)
88579:          + newTypeObjects.sizeOfExcludingThis(mallocSizeOf)
88579:          + lazyTypeObjects.sizeOfExcludingThis(mallocSizeOf);
86104: }
