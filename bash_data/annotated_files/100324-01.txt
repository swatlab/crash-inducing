     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 32381: #include "nsXULListboxAccessible.h"
 32381: 
 95352: #include "Accessible-inl.h"
 41384: #include "nsAccessibilityService.h"
 41384: #include "nsAccUtils.h"
 99568: #include "DocAccessible.h"
 87094: #include "Role.h"
 87094: #include "States.h"
 41384: 
 79384: #include "nsComponentManagerUtils.h"
 79384: #include "nsIAutoCompleteInput.h"
 79384: #include "nsIAutoCompletePopup.h"
 79384: #include "nsIDOMXULMenuListElement.h"
 79384: #include "nsIDOMXULMultSelectCntrlEl.h"
 79384: #include "nsIDOMNodeList.h"
 10594: #include "nsIDOMXULPopupElement.h"
     1: #include "nsIDOMXULSelectCntrlItemEl.h"
     1: 
 74618: using namespace mozilla::a11y;
 74618: 
  6094: ////////////////////////////////////////////////////////////////////////////////
 99648: // nsXULColumAccessible
 32381: ////////////////////////////////////////////////////////////////////////////////
     1: 
 99648: nsXULColumAccessible::
 99648:   nsXULColumAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99648:   AccessibleWrap(aContent, aDoc)
  6094: {
  6094: }
  6094: 
 87094: role
 99648: nsXULColumAccessible::NativeRole()
  6094: {
 87094:   return roles::LIST;
  6094: }
  6094: 
 67790: PRUint64
 99648: nsXULColumAccessible::NativeState()
  6094: {
 67973:   return states::READONLY;
  6094: }
  6094: 
 32381: 
  6094: ////////////////////////////////////////////////////////////////////////////////
  6094: // nsXULColumnItemAccessible
 32381: ////////////////////////////////////////////////////////////////////////////////
  6094: 
  6094: nsXULColumnItemAccessible::
 99568:   nsXULColumnItemAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 89799:   nsLeafAccessible(aContent, aDoc)
  6094: {
  6094: }
  6094: 
 87094: role
 52027: nsXULColumnItemAccessible::NativeRole()
  6094: {
 87094:   return roles::COLUMNHEADER;
  6094: }
  6094: 
 67790: PRUint64
 67790: nsXULColumnItemAccessible::NativeState()
  6094: {
 67973:   return states::READONLY;
  6094: }
  6094: 
 74781: PRUint8
 74781: nsXULColumnItemAccessible::ActionCount()
  6094: {
 74781:   return 1;
  6094: }
  6094: 
  6094: NS_IMETHODIMP
  6094: nsXULColumnItemAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
  6094: {
  6094:   if (aIndex != eAction_Click)
  6094:     return NS_ERROR_INVALID_ARG;
  6094: 
  6094:   aName.AssignLiteral("click");
  6094:   return NS_OK;
  6094: }
  6094: 
  6094: NS_IMETHODIMP
  6094: nsXULColumnItemAccessible::DoAction(PRUint8 aIndex)
  6094: {
  6094:   if (aIndex != eAction_Click)
  6094:     return NS_ERROR_INVALID_ARG;
  6094: 
 37481:   DoCommand();
 37481:   return NS_OK;
  6094: }
  6094: 
  6094: ////////////////////////////////////////////////////////////////////////////////
  6094: // nsXULListboxAccessible
 32381: ////////////////////////////////////////////////////////////////////////////////
     1: 
 11854: nsXULListboxAccessible::
 99568:   nsXULListboxAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 94235:   XULSelectControlAccessible(aContent, aDoc), xpcAccessibleTable(this)
     1: {
 79384:   nsIContent* parentContent = mContent->GetParent();
 79384:   if (parentContent) {
 79384:     nsCOMPtr<nsIAutoCompletePopup> autoCompletePopupElm =
 79384:       do_QueryInterface(parentContent);
 79384:     if (autoCompletePopupElm)
 79384:       mFlags |= eAutoCompletePopupAccessible;
 79384:   }
     1: }
     1: 
 87448: NS_IMPL_ADDREF_INHERITED(nsXULListboxAccessible, XULSelectControlAccessible)
 87448: NS_IMPL_RELEASE_INHERITED(nsXULListboxAccessible, XULSelectControlAccessible)
 11854: 
 11854: nsresult
 11854: nsXULListboxAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
 11854: {
 87448:   nsresult rv = XULSelectControlAccessible::QueryInterface(aIID, aInstancePtr);
 11854:   if (*aInstancePtr)
 11854:     return rv;
 11854: 
 32381:   if (aIID.Equals(NS_GET_IID(nsIAccessibleTable)) && IsMulticolumn()) {
 11854:     *aInstancePtr = static_cast<nsIAccessibleTable*>(this);
 11854:     NS_ADDREF_THIS();
 11854:     return NS_OK;
 11854:   }
 11854: 
 11854:   return NS_ERROR_NO_INTERFACE;
 11854: }
 11854: 
 94235: ////////////////////////////////////////////////////////////////////////////////
 94235: //nsAccessNode
 94235: 
 94235: void
 94235: nsXULListboxAccessible::Shutdown()
 94235: {
 94235:   mTable = nsnull;
 94235:   XULSelectControlAccessible::Shutdown();
 94235: }
 94235: 
 79445: bool
 32381: nsXULListboxAccessible::IsMulticolumn()
 11854: {
 11854:   PRInt32 numColumns = 0;
 32381:   nsresult rv = GetColumnCount(&numColumns);
 11854:   if (NS_FAILED(rv))
 80486:     return false;
 11854: 
 11854:   return numColumns > 1;
 11854: }
 11854: 
 11854: ////////////////////////////////////////////////////////////////////////////////
 11854: // nsXULListboxAccessible. nsIAccessible
 11854: 
 67790: PRUint64
 67790: nsXULListboxAccessible::NativeState()
     1: {
 11854:   // As a nsXULListboxAccessible we can have the following states:
 67790:   //   FOCUSED, READONLY, FOCUSABLE
 11854: 
     1:   // Get focus status from base class
 99648:   PRUint64 states = Accessible::NativeState();
     1: 
     1:   // see if we are multiple select if so set ourselves as such
 43504: 
 78350:   if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::seltype,
 78350:                             nsGkAtoms::multiple, eCaseMatters)) {
 67790:       states |= states::MULTISELECTABLE | states::EXTSELECTABLE;
     1:   }
     1: 
 67790:   return states;
     1: }
     1: 
     1: /**
     1:   * Our value is the label of our ( first ) selected child.
     1:   */
 94983: void
 94983: nsXULListboxAccessible::Value(nsString& aValue)
     1: {
 94983:   aValue.Truncate();
 94983: 
 43504:   nsCOMPtr<nsIDOMXULSelectControlElement> select(do_QueryInterface(mContent));
     1:   if (select) {
     1:     nsCOMPtr<nsIDOMXULSelectControlItemElement> selectedItem;
     1:     select->GetSelectedItem(getter_AddRefs(selectedItem));
     1:     if (selectedItem)
 94983:       selectedItem->GetLabel(aValue);
     1:   }
     1: }
     1: 
 87094: role
 52027: nsXULListboxAccessible::NativeRole()
     1: {
 43504:   // A richlistbox is used with the new autocomplete URL bar, and has a parent
 43504:   // popup <panel>.
 10594:   nsCOMPtr<nsIDOMXULPopupElement> xulPopup =
 43504:     do_QueryInterface(mContent->GetParent());
 52027:   if (xulPopup)
 87094:     return roles::COMBOBOX_LIST;
 11854: 
 87094:   return IsMulticolumn() ? roles::TABLE : roles::LISTBOX;
     1: }
     1: 
 11854: ////////////////////////////////////////////////////////////////////////////////
 11854: // nsXULListboxAccessible. nsIAccessibleTable
     1: 
 96901: PRUint32
 96901: nsXULListboxAccessible::ColCount()
 11854: {
 43504:   nsIContent* headContent = nsnull;
 84146:   for (nsIContent* childContent = mContent->GetFirstChild(); childContent;
 84146:        childContent = childContent->GetNextSibling()) {
 78350:     if (childContent->NodeInfo()->Equals(nsGkAtoms::listcols,
 11854:                                          kNameSpaceID_XUL)) {
 11854:       headContent = childContent;
 11854:     }
 11854:   }
 11854:   if (!headContent)
 96901:     return 0;
 11854: 
 11854:   PRUint32 columnCount = 0;
 84146:   for (nsIContent* childContent = headContent->GetFirstChild(); childContent;
 84146:        childContent = childContent->GetNextSibling()) {
 78350:     if (childContent->NodeInfo()->Equals(nsGkAtoms::listcol,
 11854:                                          kNameSpaceID_XUL)) {
 11854:       columnCount++;
 11854:     }
 11854:   }
 11854: 
 96901:   return columnCount;
 11854: }
 11854: 
 96901: PRUint32
 96901: nsXULListboxAccessible::RowCount()
 11854: {
 43504:   nsCOMPtr<nsIDOMXULSelectControlElement> element(do_QueryInterface(mContent));
 11854: 
 11854:   PRUint32 itemCount = 0;
 96901:   if(element)
 96901:     element->GetItemCount(&itemCount);
 11854: 
 96901:   return itemCount;
 11854: }
 11854: 
 99648: Accessible*
 99104: nsXULListboxAccessible::CellAt(PRUint32 aRowIndex, PRUint32 aColumnIndex)
 11854: { 
 11854:   nsCOMPtr<nsIDOMXULSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 99104:   NS_ENSURE_TRUE(control, nsnull);
 11854: 
 11854:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
 99104:   control->GetItemAtIndex(aRowIndex, getter_AddRefs(item));
 99104:   if (!item)
 99104:     return nsnull;
 11854: 
 43504:   nsCOMPtr<nsIContent> itemContent(do_QueryInterface(item));
 99104:   if (!itemContent)
 99104:     return nsnull;
 99104: 
 99648:   Accessible* row = mDoc->GetAccessible(itemContent);
 99104:   NS_ENSURE_TRUE(row, nsnull);
 11854: 
 99104:   return row->GetChildAt(aColumnIndex);
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetColumnIndexAt(PRInt32 aIndex, PRInt32 *aColumn)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aColumn);
 11854:   *aColumn = -1;
 11854: 
 11854:   PRInt32 columnCount = 0;
 32381:   nsresult rv = GetColumnCount(&columnCount);
 11854:   NS_ENSURE_SUCCESS(rv, rv);
 11854: 
 11854:   *aColumn = aIndex % columnCount;
 11854:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetRowIndexAt(PRInt32 aIndex, PRInt32 *aRow)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aRow);
 11854:   *aRow = -1;
 11854: 
 11854:   PRInt32 columnCount = 0;
 32381:   nsresult rv = GetColumnCount(&columnCount);
 11854:   NS_ENSURE_SUCCESS(rv, rv);
 11854: 
 11854:   *aRow = aIndex / columnCount;
 11854:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 47173: nsXULListboxAccessible::GetRowAndColumnIndicesAt(PRInt32 aCellIndex,
 47173:                                                  PRInt32* aRowIndex,
 47173:                                                  PRInt32* aColumnIndex)
 47173: {
 47173:   NS_ENSURE_ARG_POINTER(aRowIndex);
 47173:   *aRowIndex = -1;
 47173:   NS_ENSURE_ARG_POINTER(aColumnIndex);
 47173:   *aColumnIndex = -1;
 47173: 
 47173:   if (IsDefunct())
 47173:     return NS_ERROR_FAILURE;
 47173: 
 47173:   PRInt32 columnCount = 0;
 47173:   nsresult rv = GetColumnCount(&columnCount);
 47173:   NS_ENSURE_SUCCESS(rv, rv);
 47173: 
 47173:   *aColumnIndex = aCellIndex % columnCount;
 47173:   *aRowIndex = aCellIndex / columnCount;
 47173:   return NS_OK;
 47173: }
 47173: 
 47173: NS_IMETHODIMP
 11854: nsXULListboxAccessible::GetColumnDescription(PRInt32 aColumn,
 11854:                                              nsAString& aDescription)
 11854: {
 12646:   aDescription.Truncate();
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 11854: nsXULListboxAccessible::GetRowDescription(PRInt32 aRow, nsAString& aDescription)
 11854: {
 12646:   aDescription.Truncate();
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 79445: nsXULListboxAccessible::IsColumnSelected(PRInt32 aColumn, bool *aIsSelected)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aIsSelected);
 80486:   *aIsSelected = false;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 32381:   PRInt32 selectedrowCount = 0;
 32381:   nsresult rv = control->GetSelectedCount(&selectedrowCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   PRInt32 rowCount = 0;
 32381:   rv = GetRowCount(&rowCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   *aIsSelected = (selectedrowCount == rowCount);
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 79445: nsXULListboxAccessible::IsRowSelected(PRInt32 aRow, bool *aIsSelected)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aIsSelected);
 80486:   *aIsSelected = false;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULSelectControlElement.");
 12646: 
 12646:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
 12646:   control->GetItemAtIndex(aRow, getter_AddRefs(item));
 12646:   NS_ENSURE_TRUE(item, NS_ERROR_INVALID_ARG);
 12646: 
 12646:   return item->GetSelected(aIsSelected);
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::IsCellSelected(PRInt32 aRowIndex, PRInt32 aColumnIndex,
 79445:                                        bool *aIsSelected)
 11854: {
 32381:   return IsRowSelected(aRowIndex, aIsSelected);
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedCellCount(PRUint32* aCount)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aCount);
 12646:   *aCount = 0;
 11854: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 12646:   nsCOMPtr<nsIDOMNodeList> selectedItems;
 12646:   control->GetSelectedItems(getter_AddRefs(selectedItems));
 12646:   if (!selectedItems)
 12646:     return NS_OK;
 12646: 
 12646:   PRUint32 selectedItemsCount = 0;
 12646:   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 12646:   if (!selectedItemsCount)
 12646:     return NS_OK;
 12646: 
 32381:   PRInt32 columnCount = 0;
 32381:   rv = GetColumnCount(&columnCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   *aCount = selectedItemsCount * columnCount;
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedColumnCount(PRUint32* aCount)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aCount);
 12646:   *aCount = 0;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 32381:   PRInt32 selectedrowCount = 0;
 32381:   nsresult rv = control->GetSelectedCount(&selectedrowCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   PRInt32 rowCount = 0;
 32381:   rv = GetRowCount(&rowCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   if (selectedrowCount != rowCount)
 12646:     return NS_OK;
 12646: 
 32381:   PRInt32 columnCount = 0;
 32381:   rv = GetColumnCount(&columnCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   *aCount = columnCount;
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedRowCount(PRUint32* aCount)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aCount);
 12646:   *aCount = 0;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 32381:   PRInt32 selectedrowCount = 0;
 32381:   nsresult rv = control->GetSelectedCount(&selectedrowCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   *aCount = selectedrowCount;
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedCells(nsIArray **aCells)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aCells);
 32381:   *aCells = nsnull;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 32381:   nsresult rv = NS_OK;
 32381:   nsCOMPtr<nsIMutableArray> selCells =
 32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
 32381:   NS_ENSURE_SUCCESS(rv, rv);
 32381: 
 32381:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 32381:   NS_ASSERTION(control,
 32381:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 32381: 
 32381:   nsCOMPtr<nsIDOMNodeList> selectedItems;
 32381:   control->GetSelectedItems(getter_AddRefs(selectedItems));
 32381:   if (!selectedItems)
 32381:     return NS_OK;
 32381: 
 32381:   PRUint32 selectedItemsCount = 0;
 32381:   rv = selectedItems->GetLength(&selectedItemsCount);
 32381:   NS_ENSURE_SUCCESS(rv, rv);
 32381: 
 89799:   NS_ENSURE_TRUE(mDoc, NS_ERROR_FAILURE);
 32381:   PRUint32 index = 0;
 32381:   for (; index < selectedItemsCount; index++) {
 32381:     nsCOMPtr<nsIDOMNode> itemNode;
 32381:     selectedItems->Item(index, getter_AddRefs(itemNode));
 43504:     nsCOMPtr<nsIContent> itemContent(do_QueryInterface(itemNode));
 99648:     Accessible* item = mDoc->GetAccessible(itemContent);
 32381: 
 32381:     if (item) {
 99463:       PRUint32 cellCount = item->ChildCount();
 99463:       for (PRUint32 cellIdx = 0; cellIdx < cellCount; cellIdx++) {
 99648:         Accessible* cell = mChildren[cellIdx];
 87094:         if (cell->Role() == roles::CELL)
 80486:           selCells->AppendElement(static_cast<nsIAccessible*>(cell), false);
 32381:       }
 32381:     }
 32381:   }
 32381: 
 32381:   NS_ADDREF(*aCells = selCells);
 32381:   return NS_OK;
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedCellIndices(PRUint32 *aNumCells,
 32381:                                                PRInt32 **aCells)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aNumCells);
 12646:   *aNumCells = 0;
 11854:   NS_ENSURE_ARG_POINTER(aCells);
 12646:   *aCells = nsnull;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 12646:   nsCOMPtr<nsIDOMNodeList> selectedItems;
 12646:   control->GetSelectedItems(getter_AddRefs(selectedItems));
 12646:   if (!selectedItems)
 12646:     return NS_OK;
 12646: 
 12646:   PRUint32 selectedItemsCount = 0;
 12646:   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   PRInt32 columnCount = 0;
 32381:   rv = GetColumnCount(&columnCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   PRUint32 cellsCount = selectedItemsCount * columnCount;
 12646: 
 12646:   PRInt32 *cellsIdxArray =
 12646:     static_cast<PRInt32*>(nsMemory::Alloc((cellsCount) * sizeof(PRInt32)));
 12646:   NS_ENSURE_TRUE(cellsIdxArray, NS_ERROR_OUT_OF_MEMORY);
 12646: 
 12646:   PRUint32 index = 0, cellsIdx = 0;
 12646:   for (; index < selectedItemsCount; index++) {
 12646:     nsCOMPtr<nsIDOMNode> itemNode;
 12646:     selectedItems->Item(index, getter_AddRefs(itemNode));
 12646:     nsCOMPtr<nsIDOMXULSelectControlItemElement> item =
 12646:       do_QueryInterface(itemNode);
 12646: 
 12646:     if (item) {
 12646:       PRInt32 itemIdx = -1;
 12646:       control->GetIndexOfItem(item, &itemIdx);
 12646:       if (itemIdx != -1) {
 12646:         PRInt32 colIdx = 0;
 32381:         for (; colIdx < columnCount; colIdx++)
 32381:           cellsIdxArray[cellsIdx++] = itemIdx * columnCount + colIdx;
 12646:       }
 12646:     }
 12646:   }
 12646: 
 12646:   *aNumCells = cellsCount;
 12646:   *aCells = cellsIdxArray;
 12646: 
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedColumnIndices(PRUint32 *aNumColumns,
 11854:                                                  PRInt32 **aColumns)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aNumColumns);
 12646:   *aNumColumns = 0;
 11854:   NS_ENSURE_ARG_POINTER(aColumns);
 12646:   *aColumns = nsnull;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 32381:   PRUint32 columnCount = 0;
 32381:   nsresult rv = GetSelectedColumnCount(&columnCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 32381:   if (!columnCount)
 12646:     return NS_OK;
 12646: 
 12646:   PRInt32 *colsIdxArray =
 32381:     static_cast<PRInt32*>(nsMemory::Alloc((columnCount) * sizeof(PRInt32)));
 12646:   NS_ENSURE_TRUE(colsIdxArray, NS_ERROR_OUT_OF_MEMORY);
 12646: 
 12646:   PRUint32 colIdx = 0;
 32381:   for (; colIdx < columnCount; colIdx++)
 12646:     colsIdxArray[colIdx] = colIdx;
 12646: 
 32381:   *aNumColumns = columnCount;
 12646:   *aColumns = colsIdxArray;
 12646: 
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 32381: nsXULListboxAccessible::GetSelectedRowIndices(PRUint32 *aNumRows,
 32381:                                               PRInt32 **aRows)
 11854: {
 11854:   NS_ENSURE_ARG_POINTER(aNumRows);
 12646:   *aNumRows = 0;
 11854:   NS_ENSURE_ARG_POINTER(aRows);
 12646:   *aRows = nsnull;
 11854: 
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 12646:   nsCOMPtr<nsIDOMNodeList> selectedItems;
 12646:   control->GetSelectedItems(getter_AddRefs(selectedItems));
 12646:   if (!selectedItems)
 12646:     return NS_OK;
 12646: 
 12646:   PRUint32 selectedItemsCount = 0;
 12646:   nsresult rv = selectedItems->GetLength(&selectedItemsCount);
 12646:   NS_ENSURE_SUCCESS(rv, rv);
 12646: 
 12646:   if (!selectedItemsCount)
 12646:     return NS_OK;
 12646: 
 12646:   PRInt32 *rowsIdxArray =
 12646:     static_cast<PRInt32*>(nsMemory::Alloc((selectedItemsCount) * sizeof(PRInt32)));
 12646:   NS_ENSURE_TRUE(rowsIdxArray, NS_ERROR_OUT_OF_MEMORY);
 12646: 
 12646:   PRUint32 index = 0;
 12646:   for (; index < selectedItemsCount; index++) {
 12646:     nsCOMPtr<nsIDOMNode> itemNode;
 12646:     selectedItems->Item(index, getter_AddRefs(itemNode));
 12646:     nsCOMPtr<nsIDOMXULSelectControlItemElement> item =
 12646:       do_QueryInterface(itemNode);
 12646: 
 12646:     if (item) {
 12646:       PRInt32 itemIdx = -1;
 12646:       control->GetIndexOfItem(item, &itemIdx);
 12646:       if (itemIdx != -1)
 12646:         rowsIdxArray[index] = itemIdx;
 12646:     }
 12646:   }
 12646: 
 12646:   *aNumRows = selectedItemsCount;
 12646:   *aRows = rowsIdxArray;
 12646: 
 12646:   return NS_OK;
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 11854: nsXULListboxAccessible::SelectRow(PRInt32 aRow)
 11854: {
 12646:   if (IsDefunct())
 12646:     return NS_ERROR_FAILURE;
 12646: 
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 12646:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
 12646:   control->GetItemAtIndex(aRow, getter_AddRefs(item));
 12646:   NS_ENSURE_TRUE(item, NS_ERROR_INVALID_ARG);
 12646: 
 12646:   return control->SelectItem(item);
 11854: }
 11854: 
 11854: NS_IMETHODIMP
 11854: nsXULListboxAccessible::SelectColumn(PRInt32 aColumn)
 11854: {
 12646:   // xul:listbox and xul:richlistbox support row selection only.
 12646:   return NS_OK;
 11854: }
 11854: 
 97028: void
 97028: nsXULListboxAccessible::UnselectRow(PRUint32 aRowIdx)
 11854: {
 12646:   nsCOMPtr<nsIDOMXULMultiSelectControlElement> control =
 43504:     do_QueryInterface(mContent);
 12646:   NS_ASSERTION(control,
 12646:                "Doesn't implement nsIDOMXULMultiSelectControlElement.");
 12646: 
 97028:   if (control) {
 12646:     nsCOMPtr<nsIDOMXULSelectControlItemElement> item;
 97028:     control->GetItemAtIndex(aRowIdx, getter_AddRefs(item));
 97028:     control->RemoveItemFromSelection(item);
 11854:   }
 11854: }
 11854: 
 11854: ////////////////////////////////////////////////////////////////////////////////
 79384: // nsXULListboxAccessible: Widgets
 79384: 
 79384: bool
 79384: nsXULListboxAccessible::IsWidget() const
 79384: {
 79384:   return true;
 79384: }
 79384: 
 79384: bool
 79384: nsXULListboxAccessible::IsActiveWidget() const
 79384: {
 79384:   if (IsAutoCompletePopup()) {
 79384:     nsCOMPtr<nsIAutoCompletePopup> autoCompletePopupElm =
 79384:       do_QueryInterface(mContent->GetParent());
 79384: 
 79384:     if (autoCompletePopupElm) {
 79445:       bool isOpen = false;
 79384:       autoCompletePopupElm->GetPopupOpen(&isOpen);
 79384:       return isOpen;
 79384:     }
 79384:   }
 79384:   return FocusMgr()->HasDOMFocus(mContent);
 79384: }
 79384: 
 79384: bool
 79384: nsXULListboxAccessible::AreItemsOperable() const
 79384: {
 79384:   if (IsAutoCompletePopup()) {
 79384:     nsCOMPtr<nsIAutoCompletePopup> autoCompletePopupElm =
 79384:       do_QueryInterface(mContent->GetParent());
 79384: 
 79384:     if (autoCompletePopupElm) {
 79445:       bool isOpen = false;
 79384:       autoCompletePopupElm->GetPopupOpen(&isOpen);
 79384:       return isOpen;
 79384:     }
 79384:   }
 79384:   return true;
 79384: }
 79384: 
 99648: Accessible*
 79384: nsXULListboxAccessible::ContainerWidget() const
 79384: {
 79384:   if (IsAutoCompletePopup()) {
 79384:     // This works for XUL autocompletes. It doesn't work for HTML forms
 79384:     // autocomplete because of potential crossprocess calls (when autocomplete
 79384:     // lives in content process while popup lives in chrome process). If that's
 79384:     // a problem then rethink Widgets interface.
 79384:     nsCOMPtr<nsIDOMXULMenuListElement> menuListElm =
 79384:       do_QueryInterface(mContent->GetParent());
 79384:     if (menuListElm) {
 79384:       nsCOMPtr<nsIDOMNode> inputElm;
 79384:       menuListElm->GetInputField(getter_AddRefs(inputElm));
 79384:       if (inputElm) {
 79384:         nsCOMPtr<nsINode> inputNode = do_QueryInterface(inputElm);
 79384:         if (inputNode) {
 99648:           Accessible* input = 
 90150:             mDoc->GetAccessible(inputNode);
 79384:           return input ? input->ContainerWidget() : nsnull;
 79384:         }
 79384:       }
 79384:     }
 79384:   }
 79384:   return nsnull;
 79384: }
 79384: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 11854: // nsXULListitemAccessible
 32381: ////////////////////////////////////////////////////////////////////////////////
 11854: 
 11854: nsXULListitemAccessible::
 99568:   nsXULListitemAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 89799:   nsXULMenuitemAccessible(aContent, aDoc)
     1: {
 43504:   mIsCheckbox = mContent->AttrValueIs(kNameSpaceID_None,
 78350:                                       nsGkAtoms::type,
 78350:                                       nsGkAtoms::checkbox,
 43504:                                       eCaseMatters);
     1: }
     1: 
 99648: NS_IMPL_ISUPPORTS_INHERITED0(nsXULListitemAccessible, Accessible)
     1: 
 99648: Accessible* 
 11854: nsXULListitemAccessible::GetListAccessible()
 11854: {
 11854:   if (IsDefunct())
 11854:     return nsnull;
 11854:   
 11854:   nsCOMPtr<nsIDOMXULSelectControlItemElement> listItem =
 43504:     do_QueryInterface(mContent);
 12090:   if (!listItem)
 12090:     return nsnull;
 11854: 
 11854:   nsCOMPtr<nsIDOMXULSelectControlElement> list;
 11854:   listItem->GetControl(getter_AddRefs(list));
 15311: 
 43504:   nsCOMPtr<nsIContent> listContent(do_QueryInterface(list));
 43504:   if (!listContent)
 11854:     return nsnull;
 11854: 
 89799:   return mDoc->GetAccessible(listContent);
 11854: }
 11854: 
 11854: ////////////////////////////////////////////////////////////////////////////////
 99648: // nsXULListitemAccessible Accessible
 69342: 
 69342: void
 69342: nsXULListitemAccessible::Description(nsString& aDesc)
 69342: {
 99648:   AccessibleWrap::Description(aDesc);
 69342: }
 69342: 
 69342: ////////////////////////////////////////////////////////////////////////////////
 11854: // nsXULListitemAccessible. nsIAccessible
 11854: 
     1: /**
     1:   * If there is a Listcell as a child ( not anonymous ) use it, otherwise
     1:   *   default to getting the name from GetXULName
     1:   */
 20246: nsresult
 20246: nsXULListitemAccessible::GetNameInternal(nsAString& aName)
     1: {
 84146:   nsIContent* childContent = mContent->GetFirstChild();
 84146:   if (childContent) {
 84146:     if (childContent->NodeInfo()->Equals(nsGkAtoms::listcell,
 43504:                                          kNameSpaceID_XUL)) {
 84146:       childContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, aName);
     1:       return NS_OK;
     1:     }
     1:   }
 18347:   return GetXULName(aName);
     1: }
     1: 
 87094: role
 52027: nsXULListitemAccessible::NativeRole()
     1: {
 99648:   Accessible* list = GetListAccessible();
 52027:   if (!list) {
 52027:     NS_ERROR("No list accessible for listitem accessible!");
 87094:     return roles::NOTHING;
 11854:   }
 11854: 
 87094:   if (list->Role() == roles::TABLE)
 87094:     return roles::ROW;
 52027: 
     1:   if (mIsCheckbox)
 93975:     return roles::CHECK_RICH_OPTION;
 52027: 
 87094:   if (mParent && mParent->Role() == roles::COMBOBOX_LIST)
 87094:     return roles::COMBOBOX_OPTION;
 52027: 
 87094:   return roles::RICH_OPTION;
     1: }
     1: 
 67790: PRUint64
 67790: nsXULListitemAccessible::NativeState()
     1: {
 67973:   if (mIsCheckbox)
 67790:     return nsXULMenuitemAccessible::NativeState();
 21984: 
100246:   PRUint64 states = NativeInteractiveState();
 32381: 
 32381:   nsCOMPtr<nsIDOMXULSelectControlItemElement> listItem =
 43504:     do_QueryInterface(mContent);
 32381: 
     1:   if (listItem) {
 79445:     bool isSelected;
     1:     listItem->GetSelected(&isSelected);
     1:     if (isSelected)
 67790:       states |= states::SELECTED;
     1: 
 79384:     if (FocusMgr()->IsFocused(this))
 67790:       states |= states::FOCUSED;
     1:   }
     1: 
 67790:   return states;
     1: }
     1: 
100246: PRUint64
100246: nsXULListitemAccessible::NativeInteractiveState() const
100246: {
100324:   return NativelyUnavailable() ||
100324:          (mParent && mParent->NativelyUnavailable()) ?
100246:     states::UNAVAILABLE : states::FOCUSABLE | states::SELECTABLE;
100246: }
100246: 
     1: NS_IMETHODIMP nsXULListitemAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
     1: {
     1:   if (aIndex == eAction_Click && mIsCheckbox) {
     1:     // check or uncheck
 67790:     PRUint64 states = NativeState();
     1: 
 67790:     if (states & states::CHECKED)
     1:       aName.AssignLiteral("uncheck");
     1:     else
     1:       aName.AssignLiteral("check");
     1: 
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 79445: bool
 89679: nsXULListitemAccessible::CanHaveAnonChildren()
   954: {
   954:   // That indicates we should walk anonymous children for listitems
 80486:   return true;
   954: }
   954: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: // nsXULListitemAccessible: Widgets
 79384: 
 99648: Accessible*
 79384: nsXULListitemAccessible::ContainerWidget() const
 79384: {
 79384:   return Parent();
 79384: }
 79384: 
 11864: 
 11854: ////////////////////////////////////////////////////////////////////////////////
 11854: // nsXULListCellAccessible
 32381: ////////////////////////////////////////////////////////////////////////////////
 32381: 
 11854: nsXULListCellAccessible::
 99568:   nsXULListCellAccessible(nsIContent* aContent, DocAccessible* aDoc) :
 99901:   HyperTextAccessibleWrap(aContent, aDoc)
 11854: {
 11854: }
 11854: 
 32381: ////////////////////////////////////////////////////////////////////////////////
 32381: // nsISupports
 32381: 
 32381: NS_IMPL_ISUPPORTS_INHERITED1(nsXULListCellAccessible,
 99901:                              HyperTextAccessible,
 32381:                              nsIAccessibleTableCell)
 32381: 
 32381: ////////////////////////////////////////////////////////////////////////////////
 32381: // nsXULListCellAccessible: nsIAccessibleTableCell implementation
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetTable(nsIAccessibleTable **aTable)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aTable);
 32381:   *aTable = nsnull;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 99648:   Accessible* thisRow = Parent();
 87094:   if (!thisRow || thisRow->Role() != roles::ROW)
 32381:     return NS_OK;
 32381: 
 99648:   Accessible* table = thisRow->Parent();
 87094:   if (!table || table->Role() != roles::TABLE)
 32381:     return NS_OK;
 32381: 
 32381:   CallQueryInterface(table, aTable);
 32381:   return NS_OK;
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetColumnIndex(PRInt32 *aColumnIndex)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
 32381:   *aColumnIndex = -1;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 99648:   Accessible* row = Parent();
 52089:   if (!row)
 52089:     return NS_OK;
 52089: 
 32381:   *aColumnIndex = 0;
 32381: 
 72476:   PRInt32 indexInRow = IndexInParent();
 52089:   for (PRInt32 idx = 0; idx < indexInRow; idx++) {
 99648:     Accessible* cell = row->GetChildAt(idx);
 87094:     roles::Role role = cell->Role();
 87094:     if (role == roles::CELL || role == roles::GRID_CELL ||
 87094:         role == roles::ROWHEADER || role == roles::COLUMNHEADER)
 32381:       (*aColumnIndex)++;
 32381:   }
 32381: 
 32381:   return NS_OK;
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetRowIndex(PRInt32 *aRowIndex)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
 32381:   *aRowIndex = -1;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 99648:   Accessible* row = Parent();
 52089:   if (!row)
 52089:     return NS_OK;
 32381: 
 99648:   Accessible* table = row->Parent();
 52089:   if (!table)
 52089:     return NS_OK;
 52089: 
 52089:   *aRowIndex = 0;
 52089: 
 72476:   PRInt32 indexInTable = row->IndexInParent();
 52089:   for (PRInt32 idx = 0; idx < indexInTable; idx++) {
 52089:     row = table->GetChildAt(idx);
 87094:     if (row->Role() == roles::ROW)
 32381:       (*aRowIndex)++;
 32381:   }
 32381: 
 32381:   return NS_OK;
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetColumnExtent(PRInt32 *aExtentCount)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
 32381:   *aExtentCount = 0;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 32381:   *aExtentCount = 1;
 32381:   return NS_OK;
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetRowExtent(PRInt32 *aExtentCount)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
 32381:   *aExtentCount = 0;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 32381:   *aExtentCount = 1;
 32381:   return NS_OK;
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetColumnHeaderCells(nsIArray **aHeaderCells)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
 32381:   *aHeaderCells = nsnull;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 32381:   nsCOMPtr<nsIAccessibleTable> table;
 32381:   GetTable(getter_AddRefs(table));
 34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
 32381: 
 32381:   // Get column header cell from XUL listhead.
 99648:   Accessible* list = nsnull;
 32381: 
 99648:   nsRefPtr<Accessible> tableAcc(do_QueryObject(table));
 99463:   PRUint32 tableChildCount = tableAcc->ChildCount();
 99463:   for (PRUint32 childIdx = 0; childIdx < tableChildCount; childIdx++) {
 99648:     Accessible* child = tableAcc->GetChildAt(childIdx);
 87094:     if (child->Role() == roles::LIST) {
 42415:       list = child;
 32381:       break;
 42415:     }
 32381:   }
 32381: 
 32381:   if (list) {
 32381:     PRInt32 colIdx = -1;
 32381:     GetColumnIndex(&colIdx);
 32381: 
 42415:     nsIAccessible *headerCell = list->GetChildAt(colIdx);
 32381:     if (headerCell) {
 32381:       nsresult rv = NS_OK;
 32381:       nsCOMPtr<nsIMutableArray> headerCells =
 32381:         do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
 32381:       NS_ENSURE_SUCCESS(rv, rv);
 32381: 
 80486:       headerCells->AppendElement(headerCell, false);
 32381:       NS_ADDREF(*aHeaderCells = headerCells);
 32381:       return NS_OK;
 32381:     }
 32381:   }
 32381: 
 32381:   // No column header cell from XUL markup, try to get it from ARIA markup.
 32381:   return nsAccUtils::GetHeaderCellsFor(table, this,
 32381:                                        nsAccUtils::eColumnHeaderCells,
 32381:                                        aHeaderCells);
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 32381: nsXULListCellAccessible::GetRowHeaderCells(nsIArray **aHeaderCells)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
 32381:   *aHeaderCells = nsnull;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 32381:   nsCOMPtr<nsIAccessibleTable> table;
 32381:   GetTable(getter_AddRefs(table));
 34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
 32381: 
 32381:   // Calculate row header cells from ARIA markup.
 32381:   return nsAccUtils::GetHeaderCellsFor(table, this,
 32381:                                        nsAccUtils::eRowHeaderCells,
 32381:                                        aHeaderCells);
 32381: }
 32381: 
 32381: NS_IMETHODIMP
 79445: nsXULListCellAccessible::IsSelected(bool *aIsSelected)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aIsSelected);
 80486:   *aIsSelected = false;
 32381: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
 32381: 
 32381:   nsCOMPtr<nsIAccessibleTable> table;
 32381:   GetTable(getter_AddRefs(table));
 34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
 32381: 
 32381:   PRInt32 rowIdx = -1;
 32381:   GetRowIndex(&rowIdx);
 32381: 
 32381:   return table->IsRowSelected(rowIdx, aIsSelected);
 32381: }
 32381: 
 32381: ////////////////////////////////////////////////////////////////////////////////
 99648: // nsXULListCellAccessible. Accessible implementation
 32381: 
 87094: role
 52027: nsXULListCellAccessible::NativeRole()
 11854: {
 87094:   return roles::CELL;
 11854: }
 11854: 
 32381: nsresult
 32381: nsXULListCellAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
 32381: {
 32381:   NS_ENSURE_ARG_POINTER(aAttributes);
     1: 
 32381:   if (IsDefunct())
 32381:     return NS_ERROR_FAILURE;
     1: 
 32381:   // "table-cell-index" attribute
 32381:   nsCOMPtr<nsIAccessibleTable> table;
 32381:   GetTable(getter_AddRefs(table));
 34948:   NS_ENSURE_STATE(table); // we expect to be in a listbox (table)
     1: 
 32381:   PRInt32 rowIdx = -1;
 32381:   GetRowIndex(&rowIdx);
 32381:   PRInt32 colIdx = -1;
 32381:   GetColumnIndex(&colIdx);
     1: 
 32381:   PRInt32 cellIdx = -1;
 32381:   table->GetCellIndexAt(rowIdx, colIdx, &cellIdx);
     1: 
 32381:   nsAutoString stringIdx;
 32381:   stringIdx.AppendInt(cellIdx);
 78350:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::tableCellIndex,
 32381:                          stringIdx);
     1: 
     1:   return NS_OK;
     1: }
