 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is mozilla.org code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Blake Ross <blakeross@telocity.com>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: 
 1: 
 1: #include "nsCOMPtr.h"
 1: #include "nsTextControlFrame.h"
 1: #include "nsIDocument.h"
 1: #include "nsIDOMNSHTMLTextAreaElement.h"
 1: #include "nsIDOMNSHTMLInputElement.h"
 1: #include "nsIFormControl.h"
 1: #include "nsIServiceManager.h"
 1: #include "nsFrameSelection.h"
 1: #include "nsIPlaintextEditor.h"
 1: #include "nsEditorCID.h"
 1: #include "nsLayoutCID.h"
 1: #include "nsIDocumentEncoder.h"
 1: #include "nsICaret.h"
 1: #include "nsISelectionListener.h"
 1: #include "nsISelectionPrivate.h"
 1: #include "nsIController.h"
 1: #include "nsIControllers.h"
 1: #include "nsIControllerContext.h"
 1: #include "nsGenericHTMLElement.h"
 1: #include "nsIEditorIMESupport.h"
 1: #include "nsIPhonetic.h"
 1: #include "nsIEditorObserver.h"
 1: #include "nsIDOMHTMLTextAreaElement.h"
 1: #include "nsINameSpaceManager.h"
 1: #include "nsINodeInfo.h"
 1: #include "nsIScrollableView.h"
 1: #include "nsIScrollableFrame.h" //to turn off scroll bars
 1: #include "nsFormControlFrame.h" //for registering accesskeys
 1: #include "nsIDeviceContext.h" // to measure fonts
 1: 
 1: #include "nsIContent.h"
 1: #include "nsIAtom.h"
 1: #include "nsPresContext.h"
 1: #include "nsGkAtoms.h"
 1: #include "nsLayoutUtils.h"
 1: #include "nsIComponentManager.h"
 1: #include "nsIView.h"
 1: #include "nsIViewManager.h"
 1: #include "nsIDOMHTMLInputElement.h"
 1: #include "nsIDOMElement.h"
 1: #include "nsIDOMDocument.h"
 1: #include "nsIPresShell.h"
 1: #include "nsIComponentManager.h"
 1: 
 1: #include "nsBoxLayoutState.h"
 1: //for keylistener for "return" check
 1: #include "nsIPrivateDOMEvent.h"
 1: #include "nsIDOMEventReceiver.h"
 1: #include "nsIDocument.h" //observe documents to send onchangenotifications
 1: #include "nsIStyleSheet.h"//observe documents to send onchangenotifications
 1: #include "nsIStyleRule.h"//observe documents to send onchangenotifications
 1: #include "nsIDOMEventListener.h"//observe documents to send onchangenotifications
 1: #include "nsGUIEvent.h"
 1: #include "nsIDOMEventGroup.h"
 1: #include "nsIDOM3EventTarget.h"
 1: #include "nsIDOMNSEvent.h"
 1: #include "nsIDOMNSUIEvent.h"
 1: #include "nsIEventStateManager.h"
 1: 
 1: #include "nsIDOMFocusListener.h" //onchange events
 1: #include "nsIDOMCharacterData.h" //for selection setting helper func
 1: #include "nsIDOMNodeList.h" //for selection setting helper func
 1: #include "nsIDOMRange.h" //for selection setting helper func
 1: #include "nsPIDOMWindow.h" //needed for notify selection changed to update the menus ect.
 1: #ifdef ACCESSIBILITY
 1: #include "nsIAccessibilityService.h"
 1: #endif
 1: #include "nsIServiceManager.h"
 1: #include "nsIDOMNode.h"
 1: #include "nsITextControlElement.h"
 1: 
 1: #include "nsIEditorObserver.h"
 1: #include "nsITransactionManager.h"
 1: #include "nsIDOMText.h" //for multiline getselection
 1: #include "nsNodeInfoManager.h"
 1: #include "nsContentCreatorFunctions.h"
 1: #include "nsIDOMKeyListener.h"
 1: #include "nsIDOMEventGroup.h"
 1: #include "nsIDOM3EventTarget.h"
 1: #include "nsINativeKeyBindings.h"
 1: #include "nsIJSContextStack.h"
 1: 
 1: #define DEFAULT_COLUMN_WIDTH 20
 1: 
 1: #include "nsContentCID.h"
 1: static NS_DEFINE_IID(kRangeCID,     NS_RANGE_CID);
 1: 
 1: static NS_DEFINE_CID(kTextEditorCID, NS_TEXTEDITOR_CID);
 1: static NS_DEFINE_CID(kFrameSelectionCID, NS_FRAMESELECTION_CID);
 1: 
 1: static const PRInt32 DEFAULT_COLS = 20;
 1: static const PRInt32 DEFAULT_ROWS = 1;
 1: static const PRInt32 DEFAULT_ROWS_TEXTAREA = 2;
 1: static const PRInt32 DEFAULT_UNDO_CAP = 1000;
 1: 
 1: static nsINativeKeyBindings *sNativeInputBindings = nsnull;
 1: static nsINativeKeyBindings *sNativeTextAreaBindings = nsnull;
 1: 
 1: static void
 1: PlatformToDOMLineBreaks(nsString &aString)
 1: {
 1:   // Windows linebreaks: Map CRLF to LF:
 1:   aString.ReplaceSubstring(NS_LITERAL_STRING("\r\n").get(),
 1:                            NS_LITERAL_STRING("\n").get());
 1: 
 1:   // Mac linebreaks: Map any remaining CR to LF:
 1:   aString.ReplaceSubstring(NS_LITERAL_STRING("\r").get(),
 1:                            NS_LITERAL_STRING("\n").get());
 1: }
 1: 
 1: // wrap can be one of these three values.  
 1: typedef enum {
 1:   eHTMLTextWrap_Off     = 1,    // "off"
 1:   eHTMLTextWrap_Hard    = 2,    // "hard"
 1:   eHTMLTextWrap_Soft    = 3     // the default
 1: } nsHTMLTextWrap;
 1: 
 1: static PRBool 
 1: GetWrapPropertyEnum(nsIContent* aContent, nsHTMLTextWrap& aWrapProp)
 1: {
 1:   // soft is the default; "physical" defaults to soft as well because all other
 1:   // browsers treat it that way and there is no real reason to maintain physical
 1:   // and virtual as separate entities if no one else does.  Only hard and off
 1:   // do anything different.
 1:   aWrapProp = eHTMLTextWrap_Soft; // the default
 1:   
 1:   nsAutoString wrap;
 1:   if (aContent->IsNodeOfType(nsINode::eHTML)) {
 1:     static nsIContent::AttrValuesArray strings[] =
 1:       {&nsGkAtoms::HARD, &nsGkAtoms::OFF, nsnull};
 1: 
 1:     switch (aContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::wrap,
 1:                                       strings, eIgnoreCase)) {
 1:       case 0: aWrapProp = eHTMLTextWrap_Hard; break;
 1:       case 1: aWrapProp = eHTMLTextWrap_Off; break;
 1:     }
 1: 
 1:     return PR_TRUE;
 1:   }
 1:  
 1:   return PR_FALSE;
 1: }
 1: 
 1: class nsTextInputListener : public nsISelectionListener,
 1:                             public nsIDOMFocusListener,
 1:                             public nsIDOMKeyListener,
 1:                             public nsIEditorObserver,
 1:                             public nsSupportsWeakReference
 1: {
 1: public:
 1:   /** the default constructor
 1:    */ 
 1:   nsTextInputListener();
 1:   /** the default destructor. virtual due to the possibility of derivation.
 1:    */
 1:   virtual ~nsTextInputListener();
 1: 
 1:   /** SetEditor gives an address to the editor that will be accessed
 1:    *  @param aEditor the editor this listener calls for editing operations
 1:    */
 1:   void SetFrame(nsTextControlFrame *aFrame){mFrame = aFrame;}
 1: 
 1:   NS_DECL_ISUPPORTS
 1: 
 1:   NS_DECL_NSISELECTIONLISTENER
 1: 
 1:   /** nsIDOMFocusListener interfaces 
 1:     * used to propagate focus, blur, and change notifications
 1:     * @see nsIDOMFocusListener
 1:     */
 1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
 1:   NS_IMETHOD Focus(nsIDOMEvent* aEvent);
 1:   NS_IMETHOD Blur (nsIDOMEvent* aEvent);
 1:   /* END interfaces from nsIDOMFocusListener*/
 1: 
 1:   // nsIDOMKeyListener
 1:   NS_IMETHOD KeyDown(nsIDOMEvent *aKeyEvent);
 1:   NS_IMETHOD KeyPress(nsIDOMEvent *aKeyEvent);
 1:   NS_IMETHOD KeyUp(nsIDOMEvent *aKeyEvent);
 1: 
 1:   NS_DECL_NSIEDITOROBSERVER
 1: 
 1: protected:
 1: 
 1:   nsresult  UpdateTextInputCommands(const nsAString& commandsToUpdate);
 1: 
 1:   NS_HIDDEN_(nsINativeKeyBindings*) GetKeyBindings();
 1: 
 1: protected:
 1: 
 1:   nsTextControlFrame* mFrame;  // weak reference
 1:   
 1:   PRPackedBool    mSelectionWasCollapsed;
 1:   /**
 1:    * Whether we had undo items or not the last time we got EditAction()
 1:    * notification (when this state changes we update undo and redo menus)
 1:    */
 1:   PRPackedBool    mHadUndoItems;
 1:   /**
 1:    * Whether we had redo items or not the last time we got EditAction()
 1:    * notification (when this state changes we update undo and redo menus)
 1:    */
 1:   PRPackedBool    mHadRedoItems;
 1: };
 1: 
 1: 
 1: /*
 1:  * nsTextEditorListener implementation
 1:  */
 1: 
 1: nsTextInputListener::nsTextInputListener()
 1: : mFrame(nsnull)
 1: , mSelectionWasCollapsed(PR_TRUE)
 1: , mHadUndoItems(PR_FALSE)
 1: , mHadRedoItems(PR_FALSE)
 1: {
 1: }
 1: 
 1: nsTextInputListener::~nsTextInputListener() 
 1: {
 1: }
 1: 
 1: NS_IMPL_ADDREF(nsTextInputListener)
 1: NS_IMPL_RELEASE(nsTextInputListener)
 1: 
 1: NS_INTERFACE_MAP_BEGIN(nsTextInputListener)
 1:   NS_INTERFACE_MAP_ENTRY(nsISelectionListener)
 1:   NS_INTERFACE_MAP_ENTRY(nsIEditorObserver)
 1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
 1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMFocusListener)
 1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMFocusListener)
 1: NS_INTERFACE_MAP_END
 1: 
 1: // BEGIN nsIDOMSelectionListener
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::NotifySelectionChanged(nsIDOMDocument* aDoc, nsISelection* aSel, PRInt16 aReason)
 1: {
 1:   PRBool collapsed;
 1:   if (!mFrame || !aDoc || !aSel || NS_FAILED(aSel->GetIsCollapsed(&collapsed)))
 1:     return NS_OK;
 1: 
 1:   // Fire the select event
 1:   // The specs don't exactly say when we should fire the select event.
 1:   // IE: Whenever you add/remove a character to/from the selection. Also
 1:   //     each time for select all. Also if you get to the end of the text 
 1:   //     field you will get new event for each keypress or a continuous 
 1:   //     stream of events if you use the mouse. IE will fire select event 
 1:   //     when the selection collapses to nothing if you are holding down
 1:   //     the shift or mouse button.
 1:   // Mozilla: If we have non-empty selection we will fire a new event for each
 1:   //          keypress (or mouseup) if the selection changed. Mozilla will also
 1:   //          create the event each time select all is called, even if everything
 1:   //          was previously selected, becase technically select all will first collapse
 1:   //          and then extend. Mozilla will never create an event if the selection 
 1:   //          collapses to nothing.
 1:   if (!collapsed && (aReason & (nsISelectionListener::MOUSEUP_REASON | 
 1:                                 nsISelectionListener::KEYPRESS_REASON |
 1:                                 nsISelectionListener::SELECTALL_REASON)))
 1:   {
 1:     nsIContent* content = mFrame->GetContent();
 1:     if (content) 
 1:     {
 1:       nsCOMPtr<nsIDocument> doc = content->GetDocument();
 1:       if (doc) 
 1:       {
95:         nsCOMPtr<nsIPresShell> presShell = doc->GetShellAt(0);
 1:         if (presShell) 
 1:         {
 1:           nsEventStatus status = nsEventStatus_eIgnore;
 1:           nsEvent event(PR_TRUE, NS_FORM_SELECTED);
 1: 
 1:           presShell->HandleEventWithTarget(&event, mFrame, content, &status);
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   // if the collapsed state did not change, don't fire notifications
 1:   if (collapsed == mSelectionWasCollapsed)
 1:     return NS_OK;
 1:   
 1:   mSelectionWasCollapsed = collapsed;
 1: 
 1:   return UpdateTextInputCommands(NS_LITERAL_STRING("select"));
 1: }
 1: 
 1: // END nsIDOMSelectionListener
 1: 
 1: // BEGIN nsIFocusListener
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::HandleEvent(nsIDOMEvent* aEvent)
 1: {
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::Focus(nsIDOMEvent* aEvent)
 1: {
 1:   if (!mFrame)
 1:     return NS_OK;
 1: 
 1:   nsCOMPtr<nsIEditor> editor;
 1:   mFrame->GetEditor(getter_AddRefs(editor));
 1:   if (editor) {
 1:     editor->AddEditorObserver(this);
 1:   }
 1: 
 1:   return mFrame->InitFocusedValue();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::Blur(nsIDOMEvent* aEvent)
 1: {
 1:   if (!mFrame)
 1:     return NS_OK;
 1: 
 1:   nsCOMPtr<nsIEditor> editor;
 1:   mFrame->GetEditor(getter_AddRefs(editor));
 1:   if (editor) {
 1:     editor->RemoveEditorObserver(this);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: // END nsIFocusListener
 1: 
 1: // BEGIN nsIDOMKeyListener
 1: 
 1: static void
 1: DoCommandCallback(const char *aCommand, void *aData)
 1: {
 1:   nsTextControlFrame *frame = NS_STATIC_CAST(nsTextControlFrame*, aData);
 1:   nsIContent *content = frame->GetContent();
 1: 
 1:   nsCOMPtr<nsIControllers> controllers;
 1:   nsCOMPtr<nsIDOMNSHTMLInputElement> input = do_QueryInterface(content);
 1:   if (input) {
 1:     input->GetControllers(getter_AddRefs(controllers));
 1:   } else {
 1:     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea =
 1:       do_QueryInterface(content);
 1: 
 1:     if (textArea) {
 1:       textArea->GetControllers(getter_AddRefs(controllers));
 1:     }
 1:   }
 1: 
 1:   if (!controllers) {
 1:     NS_WARNING("Could not get controllers");
 1:     return;
 1:   }
 1: 
 1:   nsCOMPtr<nsIController> controller;
 1:   controllers->GetControllerForCommand(aCommand, getter_AddRefs(controller));
 1:   if (controller) {
 1:     controller->DoCommand(aCommand);
 1:   }
 1: }
 1: 
 1: static PRBool
 1: DOMEventToNativeKeyEvent(nsIDOMEvent      *aDOMEvent,
 1:                          nsNativeKeyEvent *aNativeEvent,
 1:                          PRBool            aGetCharCode)
 1: {
 1:   nsCOMPtr<nsIDOMNSUIEvent> uievent = do_QueryInterface(aDOMEvent);
 1:   PRBool defaultPrevented;
 1:   uievent->GetPreventDefault(&defaultPrevented);
 1:   if (defaultPrevented)
 1:     return PR_FALSE;
 1: 
 1:   nsCOMPtr<nsIDOMNSEvent> nsevent = do_QueryInterface(aDOMEvent);
 1:   PRBool trusted = PR_FALSE;
 1:   nsevent->GetIsTrusted(&trusted);
 1:   if (!trusted)
 1:     return PR_FALSE;
 1: 
 1:   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aDOMEvent);
 1: 
 1:   if (aGetCharCode) {
 1:       keyEvent->GetCharCode(&aNativeEvent->charCode);
 1:   } else {
 1:       aNativeEvent->charCode = 0;
 1:   }
 1:   keyEvent->GetKeyCode(&aNativeEvent->keyCode);
 1:   keyEvent->GetAltKey(&aNativeEvent->altKey);
 1:   keyEvent->GetCtrlKey(&aNativeEvent->ctrlKey);
 1:   keyEvent->GetShiftKey(&aNativeEvent->shiftKey);
 1:   keyEvent->GetMetaKey(&aNativeEvent->metaKey);
 1: 
 1:   return PR_TRUE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::KeyDown(nsIDOMEvent *aKeyEvent)
 1: {
 1:   nsNativeKeyEvent nativeEvent;
 1:   nsINativeKeyBindings *bindings = GetKeyBindings();
 1:   if (bindings &&
 1:       DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE)) {
 1:     if (bindings->KeyDown(nativeEvent, DoCommandCallback, mFrame)) {
 1:       aKeyEvent->PreventDefault();
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::KeyPress(nsIDOMEvent *aKeyEvent)
 1: {
 1:   nsNativeKeyEvent nativeEvent;
 1:   nsINativeKeyBindings *bindings = GetKeyBindings();
 1:   if (bindings &&
 1:       DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_TRUE)) {
 1:     if (bindings->KeyPress(nativeEvent, DoCommandCallback, mFrame)) {
 1:       aKeyEvent->PreventDefault();
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::KeyUp(nsIDOMEvent *aKeyEvent)
 1: {
 1:   nsNativeKeyEvent nativeEvent;
 1:   nsINativeKeyBindings *bindings = GetKeyBindings();
 1:   if (bindings &&
 1:       DOMEventToNativeKeyEvent(aKeyEvent, &nativeEvent, PR_FALSE)) {
 1:     if (bindings->KeyUp(nativeEvent, DoCommandCallback, mFrame)) {
 1:       aKeyEvent->PreventDefault();
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: // END nsIDOMKeyListener
 1: 
 1: // BEGIN nsIEditorObserver
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputListener::EditAction()
 1: {
 1:   //
 1:   // Update the undo / redo menus
 1:   //
 1:   nsCOMPtr<nsIEditor> editor;
 1:   mFrame->GetEditor(getter_AddRefs(editor));
 1: 
 1:   nsCOMPtr<nsITransactionManager> manager;
 1:   editor->GetTransactionManager(getter_AddRefs(manager));
 1:   NS_ENSURE_TRUE(manager, NS_ERROR_FAILURE);
 1: 
 1:   // Get the number of undo / redo items
 1:   PRInt32 numUndoItems = 0;
 1:   PRInt32 numRedoItems = 0;
 1:   manager->GetNumberOfUndoItems(&numUndoItems);
 1:   manager->GetNumberOfRedoItems(&numRedoItems);
 1:   if (numUndoItems && !mHadUndoItems || !numUndoItems && mHadUndoItems ||
 1:       numRedoItems && !mHadRedoItems || !numRedoItems && mHadRedoItems) {
 1:     // Modify the menu if undo or redo items are different
 1:     UpdateTextInputCommands(NS_LITERAL_STRING("undo"));
 1: 
 1:     mHadUndoItems = numUndoItems != 0;
 1:     mHadRedoItems = numRedoItems != 0;
 1:   }
 1: 
 1:   // Make sure we know we were changed (do NOT set this to false if there are
 1:   // no undo items; JS could change the value and we'd still need to save it)
 1:   mFrame->SetValueChanged(PR_TRUE);
 1: 
 1:   // Fire input event
 1:   mFrame->FireOnInput();
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: // END nsIEditorObserver
 1: 
 1: 
 1: nsresult
 1: nsTextInputListener::UpdateTextInputCommands(const nsAString& commandsToUpdate)
 1: {
 1:   NS_ENSURE_STATE(mFrame);
 1: 
 1:   nsIContent* content = mFrame->GetContent();
 1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 1:   
 1:   nsCOMPtr<nsIDocument> doc = content->GetDocument();
 1:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
 1: 
 1:   nsPIDOMWindow *domWindow = doc->GetWindow();
 1:   NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
 1: 
 1:   return domWindow->UpdateCommands(commandsToUpdate);
 1: }
 1: 
 1: nsINativeKeyBindings*
 1: nsTextInputListener::GetKeyBindings()
 1: {
 1:   if (mFrame->IsTextArea()) {
 1:     static PRBool sNoTextAreaBindings = PR_FALSE;
 1: 
 1:     if (!sNativeTextAreaBindings && !sNoTextAreaBindings) {
 1:       CallGetService(NS_NATIVEKEYBINDINGS_CONTRACTID_PREFIX "textarea",
 1:                      &sNativeTextAreaBindings);
 1: 
 1:       if (!sNativeTextAreaBindings) {
 1:         sNoTextAreaBindings = PR_TRUE;
 1:       }
 1:     }
 1: 
 1:     return sNativeTextAreaBindings;
 1:   }
 1: 
 1:   static PRBool sNoInputBindings = PR_FALSE;
 1:   if (!sNativeInputBindings && !sNoInputBindings) {
 1:     CallGetService(NS_NATIVEKEYBINDINGS_CONTRACTID_PREFIX "input",
 1:                    &sNativeInputBindings);
 1: 
 1:     if (!sNativeInputBindings) {
 1:       sNoInputBindings = PR_TRUE;
 1:     }
 1:   }
 1: 
 1:   return sNativeInputBindings;
 1: }
 1: 
 1: // END nsTextInputListener
 1: 
 1: class nsTextInputSelectionImpl : public nsSupportsWeakReference
 1:                                , public nsISelectionController
 1: {
 1: public:
 1:   NS_DECL_ISUPPORTS
 1: 
 1:   nsTextInputSelectionImpl(nsFrameSelection *aSel, nsIPresShell *aShell, nsIContent *aLimiter);
 1:   ~nsTextInputSelectionImpl(){}
 1: 
 1:   //NSISELECTIONCONTROLLER INTERFACES
 1:   NS_IMETHOD SetDisplaySelection(PRInt16 toggle);
 1:   NS_IMETHOD GetDisplaySelection(PRInt16 *_retval);
 1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
 1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
 1:   NS_IMETHOD GetSelection(PRInt16 type, nsISelection **_retval);
 1:   NS_IMETHOD ScrollSelectionIntoView(PRInt16 aType, PRInt16 aRegion, PRBool aIsSynchronous);
 1:   NS_IMETHOD RepaintSelection(PRInt16 type);
 1:   NS_IMETHOD RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType);
 1:   NS_IMETHOD SetCaretEnabled(PRBool enabled);
 1:   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
 1:   NS_IMETHOD GetCaretEnabled(PRBool *_retval);
 1:   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
 1:   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
 1:   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
 1:   NS_IMETHOD WordExtendForDelete(PRBool aForward);
 1:   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
 1:   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
 1:   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
 1:   NS_IMETHOD CompleteScroll(PRBool aForward);
 1:   NS_IMETHOD CompleteMove(PRBool aForward, PRBool aExtend);
 1:   NS_IMETHOD ScrollPage(PRBool aForward);
 1:   NS_IMETHOD ScrollLine(PRBool aForward);
 1:   NS_IMETHOD ScrollHorizontal(PRBool aLeft);
 1:   NS_IMETHOD SelectAll(void);
 1:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval);
 1: 
 1: private:
 1:   nsCOMPtr<nsFrameSelection> mFrameSelection;
 1:   nsCOMPtr<nsIContent>        mLimiter;
 1:   nsWeakPtr mPresShellWeak;
 1: };
 1: 
 1: // Implement our nsISupports methods
 1: NS_IMPL_ISUPPORTS2(nsTextInputSelectionImpl, nsISelectionController, nsISupportsWeakReference)
 1: 
 1: 
 1: // BEGIN nsTextInputSelectionImpl
 1: 
 1: nsTextInputSelectionImpl::nsTextInputSelectionImpl(nsFrameSelection *aSel, nsIPresShell *aShell, nsIContent *aLimiter)
 1: {
 1:   if (aSel && aShell)
 1:   {
 1:     mFrameSelection = aSel;//we are the owner now!
 1:     mLimiter = aLimiter;
 1:     mFrameSelection->Init(aShell, mLimiter);
 1:     mPresShellWeak = do_GetWeakReference(aShell);
 1:   }
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::SetDisplaySelection(PRInt16 aToggle)
 1: {
 1:   if (!mFrameSelection)
 1:     return NS_ERROR_NULL_POINTER;
 1:   
 1:   mFrameSelection->SetDisplaySelection(aToggle);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::GetDisplaySelection(PRInt16 *aToggle)
 1: {
 1:   if (!mFrameSelection)
 1:     return NS_ERROR_NULL_POINTER;
 1: 
 1:   *aToggle = mFrameSelection->GetDisplaySelection();
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::SetSelectionFlags(PRInt16 aToggle)
 1: {
 1:   return NS_OK;//stub this out. not used in input
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::GetSelectionFlags(PRInt16 *aOutEnable)
 1: {
 1:   *aOutEnable = nsISelectionDisplay::DISPLAY_TEXT;
 1:   return NS_OK; 
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::GetSelection(PRInt16 type, nsISelection **_retval)
 1: {
 1:   if (!mFrameSelection)
 1:     return NS_ERROR_NULL_POINTER;
 1:     
 1:   *_retval = mFrameSelection->GetSelection(type);
 1:   
 1:   if (!(*_retval))
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   NS_ADDREF(*_retval);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::ScrollSelectionIntoView(PRInt16 aType, PRInt16 aRegion, PRBool aIsSynchronous)
 1: {
 1:   if (mFrameSelection) {
 1:     nsresult rv = mFrameSelection->ScrollSelectionIntoView(aType, aRegion, aIsSynchronous);
 1: 
 1:     nsIScrollableView* scrollableView = mFrameSelection->GetScrollableView();
 1:     if (!scrollableView) {
 1:       return rv;
 1:     }
 1:     nsIView* view = nsnull;
 1:     scrollableView->GetScrolledView(view);
 1:     if (!view) {
 1:       return rv;
 1:     }
 1:     const nsRect portRect = scrollableView->View()->GetBounds();
 1:     const nsRect viewRect = view->GetBounds();
 1:     if (viewRect.XMost() < portRect.width) {
 1:       return scrollableView->ScrollTo(PR_MAX(viewRect.width - portRect.width, 0), -viewRect.y, 0);
 1:     }
 1: 
 1:     return rv;
 1:   }
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::RepaintSelection(PRInt16 type)
 1: {
 1:   if (!mFrameSelection)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   return mFrameSelection->RepaintSelection(type);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType)
 1: {
 1:   if (!mFrameSelection)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   return mFrameSelection->RepaintSelection(aSelectionType);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::SetCaretEnabled(PRBool enabled)
 1: {
 1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
 1: 
 1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak);
 1:   if (!shell) return NS_ERROR_FAILURE;
 1: 
 1:   // tell the pres shell to enable the caret, rather than settings its visibility directly.
 1:   // this way the presShell's idea of caret visibility is maintained.
 1:   nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(shell);
 1:   if (!selCon) return NS_ERROR_NO_INTERFACE;
 1:   selCon->SetCaretEnabled(enabled);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::SetCaretReadOnly(PRBool aReadOnly)
 1: {
 1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
 1:   nsresult result;
 1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
 1:   if (shell)
 1:   {
 1:     nsCOMPtr<nsICaret> caret;
 1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
 1:     {
 1:       nsISelection* domSel = mFrameSelection->
 1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
 1:       if (domSel)
 1:         return caret->SetCaretReadOnly(aReadOnly);
 1:     }
 1:   }
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::GetCaretEnabled(PRBool *_retval)
 1: {
 1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
 1:   nsresult result;
 1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
 1:   if (shell)
 1:   {
 1:     nsCOMPtr<nsICaret> caret;
 1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
 1:     {
 1:       nsISelection* domSel = mFrameSelection->
 1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
 1:       if (domSel)
 1:         return caret->GetCaretVisible(_retval);
 1:     }
 1:   }
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::SetCaretVisibilityDuringSelection(PRBool aVisibility)
 1: {
 1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
 1:   nsresult result;
 1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
 1:   if (shell)
 1:   {
 1:     nsCOMPtr<nsICaret> caret;
 1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))))
 1:     {
 1:       nsISelection* domSel = mFrameSelection->
 1:         GetSelection(nsISelectionController::SELECTION_NORMAL);
 1:       if (domSel)
 1:         return caret->SetVisibilityDuringSelection(aVisibility);
 1:     }
 1:   }
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::CharacterMove(PRBool aForward, PRBool aExtend)
 1: {
 1:   if (mFrameSelection)
 1:     return mFrameSelection->CharacterMove(aForward, aExtend);
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::WordMove(PRBool aForward, PRBool aExtend)
 1: {
 1:   if (mFrameSelection)
 1:     return mFrameSelection->WordMove(aForward, aExtend);
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::WordExtendForDelete(PRBool aForward)
 1: {
 1:   if (mFrameSelection)
 1:     return mFrameSelection->WordExtendForDelete(aForward);
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::LineMove(PRBool aForward, PRBool aExtend)
 1: {
 1:   if (mFrameSelection)
 1:   {
 1:     nsresult result = mFrameSelection->LineMove(aForward, aExtend);
 1:     if (NS_FAILED(result))
 1:       result = CompleteMove(aForward,aExtend);
 1:     return result;
 1:   }
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::IntraLineMove(PRBool aForward, PRBool aExtend)
 1: {
 1:   if (mFrameSelection)
 1:     return mFrameSelection->IntraLineMove(aForward, aExtend);
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::PageMove(PRBool aForward, PRBool aExtend)
 1: {
 1:   // expected behavior for PageMove is to scroll AND move the caret
 1:   // and to remain relative position of the caret in view. see Bug 4302.
 1: 
 1:   if (mPresShellWeak)
 1:   {
 1:     nsCOMPtr<nsIPresShell> presShell = do_QueryReferent(mPresShellWeak);
 1:     if (!presShell)
 1:       return NS_ERROR_NULL_POINTER;
 1: 
 1:     //get the scroll view
 1:     nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
 1:     if (scrollableView)
 1:       mFrameSelection->CommonPageMove(aForward, aExtend, scrollableView);
 1:   }
 1:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, nsISelectionController::SELECTION_FOCUS_REGION, PR_TRUE);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::CompleteScroll(PRBool aForward)
 1: {
 1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
 1: 
 1:   if (!scrollableView)
 1:     return NS_ERROR_NOT_INITIALIZED;
 1: 
 1:   return scrollableView->ScrollByWhole(!aForward); //TRUE = top, aForward TRUE=bottom
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::CompleteMove(PRBool aForward, PRBool aExtend)
 1: {
 1:   // grab the parent / root DIV for this text widget
 1:   nsIContent* parentDIV = mFrameSelection->GetLimiter();
 1:   if (!parentDIV)
 1:     return NS_ERROR_UNEXPECTED;
 1: 
 1:   // make the caret be either at the very beginning (0) or the very end
 1:   PRInt32 offset = 0;
 1:   nsFrameSelection::HINT hint = nsFrameSelection::HINTLEFT;
 1:   if (aForward)
 1:   {
 1:     offset = parentDIV->GetChildCount();
 1: 
 1:     // Prevent the caret from being placed after the last
 1:     // BR node in the content tree!
 1: 
 1:     if (offset > 0)
 1:     {
 1:       nsIContent *child = parentDIV->GetChildAt(offset - 1);
 1: 
 1:       if (child->Tag() == nsGkAtoms::br)
 1:       {
 1:         --offset;
 1:         hint = nsFrameSelection::HINTRIGHT; // for Bug 106855
 1:       }
 1:     }
 1:   }
 1: 
 1:   mFrameSelection->HandleClick(parentDIV, offset, offset, aExtend,
 1:                                PR_FALSE, hint);
 1: 
 1:   // if we got this far, attempt to scroll no matter what the above result is
 1:   return CompleteScroll(aForward);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::ScrollPage(PRBool aForward)
 1: {
 1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
 1:   if (!scrollableView)
 1:     return NS_ERROR_NOT_INITIALIZED;
 1: 
 1:   return scrollableView->ScrollByPages(0, aForward ? 1 : -1);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::ScrollLine(PRBool aForward)
 1: {
 1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
 1:   if (!scrollableView)
 1:     return NS_ERROR_NOT_INITIALIZED;
 1: 
 1:   // will we have bug #7354 because we aren't forcing an update here?
 1:   return scrollableView->ScrollByLines(0, aForward ? 1 : -1);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::ScrollHorizontal(PRBool aLeft)
 1: {
 1:   nsIScrollableView *scrollableView = mFrameSelection->GetScrollableView();
 1:   if (!scrollableView)
 1:     return NS_ERROR_NOT_INITIALIZED;
 1: 
 1:   // will we have bug #7354 because we aren't forcing an update here?
 1:   return scrollableView->ScrollByLines(aLeft ? -1 : 1, 0);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::SelectAll()
 1: {
 1:   if (mFrameSelection)
 1:     return mFrameSelection->SelectAll();
 1:   return NS_ERROR_NULL_POINTER;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextInputSelectionImpl::CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval)
 1: {
 1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
 1:   nsresult result;
 1:   nsCOMPtr<nsISelectionController> shell = do_QueryReferent(mPresShellWeak, &result);
 1:   if (shell)
 1:   {
 1:     return shell->CheckVisibility(node,startOffset,EndOffset, _retval);
 1:   }
 1:   return NS_ERROR_FAILURE;
 1: 
 1: }
 1: 
 1: nsIFrame*
 1: NS_NewTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 1: {
 1:   return new (aPresShell) nsTextControlFrame(aPresShell, aContext);
 1: }
 1: 
 1: NS_IMPL_ADDREF_INHERITED(nsTextControlFrame, nsBoxFrame)
 1: NS_IMPL_RELEASE_INHERITED(nsTextControlFrame, nsBoxFrame)
 1:  
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
 1: {
 1:   if (NULL == aInstancePtr) {
 1:     return NS_ERROR_NULL_POINTER;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsIFormControlFrame))) {
 1:     *aInstancePtr = (void*) ((nsIFormControlFrame*) this);
 1:     return NS_OK;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsIAnonymousContentCreator))) {
 1:     *aInstancePtr = (void*)(nsIAnonymousContentCreator*) this;
 1:     return NS_OK;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsITextControlFrame))) {
 1:     *aInstancePtr = (void*)(nsITextControlFrame*) this;
 1:     return NS_OK;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsIScrollableViewProvider)) && IsScrollable()) {
 1:     *aInstancePtr = (void*)(nsIScrollableViewProvider*) this;
 1:     return NS_OK;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsIPhonetic))) {
 1:     *aInstancePtr = (void*)(nsIPhonetic*) this;
 1:     return NS_OK;
 1:   }
 1: 
 1:   return nsBoxFrame::QueryInterface(aIID, aInstancePtr);
 1: }
 1: 
 1: #ifdef ACCESSIBILITY
 1: NS_IMETHODIMP nsTextControlFrame::GetAccessible(nsIAccessible** aAccessible)
 1: {
 1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
 1: 
 1:   if (accService) {
 1:     return accService->CreateHTMLTextFieldAccessible(NS_STATIC_CAST(nsIFrame*, this), aAccessible);
 1:   }
 1: 
 1:   return NS_ERROR_FAILURE;
 1: }
 1: #endif
 1: 
 1: nsTextControlFrame::nsTextControlFrame(nsIPresShell* aShell, nsStyleContext* aContext)
 1:   : nsStackFrame(aShell, aContext)
 1:   , mUseEditor(PR_FALSE)
 1:   , mIsProcessing(PR_FALSE)
 1:   , mNotifyOnInput(PR_TRUE)
 1:   , mDidPreDestroy(PR_FALSE)
 1:   , mFireChangeEventState(PR_FALSE)
 1:   , mTextListener(nsnull)
 1: #ifdef DEBUG
 1:   , mCreateFrameForCalled(PR_FALSE)
 1: #endif
 1: {
 1: }
 1: 
 1: nsTextControlFrame::~nsTextControlFrame()
 1: {
 1:   NS_IF_RELEASE(mTextListener);
 1: }
 1: 
 1: static PRBool
 1: SuppressEventHandlers(nsPresContext* aPresContext)
 1: {
 1:   PRBool suppressHandlers = PR_FALSE;
 1: 
 1:   if (aPresContext)
 1:   {
 1:     // Right now we only suppress event handlers and controller manipulation
 1:     // when in a print preview or print context!
 1: 
 1:     // In the current implementation, we only paginate when
 1:     // printing or in print preview.
 1: 
 1:     suppressHandlers = aPresContext->IsPaginated();
 1:   }
 1: 
 1:   return suppressHandlers;
 1: }
 1: 
 1: void
 1: nsTextControlFrame::PreDestroy()
 1: {
 1:   // notify the editor that we are going away
 1:   if (mEditor)
 1:   {
 1:     // If we were in charge of state before, relinquish it back
 1:     // to the control.
 1:     if (mUseEditor)
 1:     {
 1:       // First get the frame state from the editor
 1:       nsAutoString value;
 1:       GetValue(value, PR_TRUE);
 1: 
 1:       mUseEditor = PR_FALSE;
 1: 
 1:       // Next store the frame state in the control
 1:       // (now that mUseEditor is false values get stored
 1:       // in content).
 1:       SetValue(value);
 1:     }
 1:     mEditor->PreDestroy();
 1:   }
 1:   
 1:   // Clean up the controller
 1: 
 1:   if (!SuppressEventHandlers(GetPresContext()))
 1:   {
 1:     nsCOMPtr<nsIControllers> controllers;
 1:     nsCOMPtr<nsIDOMNSHTMLInputElement> inputElement = do_QueryInterface(mContent);
 1:     if (inputElement)
 1:       inputElement->GetControllers(getter_AddRefs(controllers));
 1:     else
 1:     {
 1:       nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaElement = do_QueryInterface(mContent);
 1:       if (textAreaElement) {
 1:         textAreaElement->GetControllers(getter_AddRefs(controllers));
 1:       }
 1:     }
 1: 
 1:     if (controllers)
 1:     {
 1:       PRUint32 numControllers;
 1:       nsresult rv = controllers->GetControllerCount(&numControllers);
 1:       NS_ASSERTION((NS_SUCCEEDED(rv)), "bad result in gfx text control destructor");
 1:       for (PRUint32 i = 0; i < numControllers; i ++)
 1:       {
 1:         nsCOMPtr<nsIController> controller;
 1:         rv = controllers->GetControllerAt(i, getter_AddRefs(controller));
 1:         if (NS_SUCCEEDED(rv) && controller)
 1:         {
 1:           nsCOMPtr<nsIControllerContext> editController = do_QueryInterface(controller);
 1:           if (editController)
 1:           {
 1:             editController->SetCommandContext(nsnull);
 1:           }
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   mEditor = nsnull;
 1:   mSelCon = nsnull;
 1:   if (mFrameSel) {
 1:     mFrameSel->SetScrollableViewProvider(nsnull);
 1:     mFrameSel = nsnull;
 1:   }
 1: 
 1: //unregister self from content
 1:   mTextListener->SetFrame(nsnull);
 1:   nsFormControlFrame::RegUnRegAccessKey(NS_STATIC_CAST(nsIFrame*, this), PR_FALSE);
 1:   if (mTextListener)
 1:   {
 1:     nsCOMPtr<nsIDOMEventReceiver> erP = do_QueryInterface(mContent);
 1:     if (erP)
 1:     {
 1:       erP->RemoveEventListenerByIID(NS_STATIC_CAST(nsIDOMFocusListener  *,mTextListener), NS_GET_IID(nsIDOMFocusListener));
 1:     }
 1: 
 1:     nsCOMPtr<nsIDOMEventGroup> systemGroup;
 1:     erP->GetSystemEventGroup(getter_AddRefs(systemGroup));
 1:     nsCOMPtr<nsIDOM3EventTarget> dom3Targ = do_QueryInterface(mContent);
 1:     if (dom3Targ) {
 1:       // cast because of ambiguous base
 1:       nsIDOMEventListener *listener = NS_STATIC_CAST(nsIDOMKeyListener*,
 1:                                                      mTextListener);
 1: 
 1:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keydown"),
 1:                                            listener, PR_FALSE, systemGroup);
 1:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keypress"),
 1:                                            listener, PR_FALSE, systemGroup);
 1:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keyup"),
 1:                                            listener, PR_FALSE, systemGroup);
 1:     }
 1:   }
 1: 
 1:   mDidPreDestroy = PR_TRUE; 
 1: }
 1: 
 1: void
 1: nsTextControlFrame::Destroy()
 1: {
 1:   if (!mDidPreDestroy) {
 1:     PreDestroy();
 1:   }
 1:   if (mFrameSel) {
 1:     mFrameSel->SetScrollableViewProvider(nsnull);
 1:   }
 1:   nsContentUtils::DestroyAnonymousContent(&mAnonymousDiv);
 1:   nsBoxFrame::Destroy();
 1: }
 1: 
 1: void 
 1: nsTextControlFrame::RemovedAsPrimaryFrame()
 1: {
 1:   if (!mDidPreDestroy) {
 1:     PreDestroy();
 1:   }
 1:   else NS_ASSERTION(PR_FALSE, "RemovedAsPrimaryFrame called after PreDestroy");
 1: }
 1: 
 1: nsIAtom*
 1: nsTextControlFrame::GetType() const 
 1: { 
 1:   return nsGkAtoms::textInputFrame;
 1: } 
 1: 
 1: // XXX: wouldn't it be nice to get this from the style context!
 1: PRBool nsTextControlFrame::IsSingleLineTextControl() const
 1: {
 1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(mContent);
 1:   if (formControl) {
 1:     PRInt32 type = formControl->GetType();
 1:     return (type == NS_FORM_INPUT_TEXT) || (type == NS_FORM_INPUT_PASSWORD);
 1:   }
 1:   return PR_FALSE;
 1: }
 1: 
 1: PRBool nsTextControlFrame::IsTextArea() const
 1: {
 1:   return mContent && mContent->Tag() == nsGkAtoms::textarea;
 1: }
 1: 
 1: // XXX: wouldn't it be nice to get this from the style context!
 1: PRBool nsTextControlFrame::IsPlainTextControl() const
 1: {
 1:   // need to check HTML attribute of mContent and/or CSS.
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool nsTextControlFrame::IsPasswordTextControl() const
 1: {
 1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(mContent);
 1:   return formControl && formControl->GetType() == NS_FORM_INPUT_PASSWORD;
 1: }
 1: 
 1: 
 1: PRInt32
 1: nsTextControlFrame::GetCols()
 1: {
 1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
 1:   NS_ASSERTION(content, "Content is not HTML content!");
 1: 
 1:   if (IsTextArea()) {
 1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::cols);
 1:     if (attr) {
 1:       PRInt32 cols = attr->Type() == nsAttrValue::eInteger ?
 1:                      attr->GetIntegerValue() : 0;
 1:       // XXX why a default of 1 char, why hide it
 1:       return (cols <= 0) ? 1 : cols;
 1:     }
 1:   } else {
 1:     // Else we know (assume) it is an input with size attr
 1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::size);
 1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
 1:       PRInt32 cols = attr->GetIntegerValue();
 1:       if (cols > 0) {
 1:         return cols;
 1:       }
 1:     }
 1:   }
 1: 
 1:   return DEFAULT_COLS;
 1: }
 1: 
 1: 
 1: PRInt32
 1: nsTextControlFrame::GetRows()
 1: {
 1:   if (IsTextArea()) {
 1:     nsGenericHTMLElement *content =
 1:       nsGenericHTMLElement::FromContent(mContent);
 1:     NS_ASSERTION(content, "Content is not HTML content!");
 1: 
 1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::rows);
 1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
 1:       PRInt32 rows = attr->GetIntegerValue();
 1:       return (rows <= 0) ? DEFAULT_ROWS_TEXTAREA : rows;
 1:     }
 1:     return DEFAULT_ROWS_TEXTAREA;
 1:   }
 1: 
 1:   return DEFAULT_ROWS;
 1: }
 1: 
 1: 
 1: nsresult
 1: nsTextControlFrame::CalcIntrinsicSize(nsIRenderingContext* aRenderingContext,
 1:                                       nsSize&              aIntrinsicSize)
 1: {
 1:   // Get leading and the Average/MaxAdvance char width 
 1:   nscoord lineHeight  = 0;
 1:   nscoord charWidth   = 0;
 1:   nscoord charMaxAdvance  = 0;
 1: 
 1:   nsCOMPtr<nsIFontMetrics> fontMet;
 1:   nsresult rv =
 1:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   aRenderingContext->SetFont(fontMet);
 1: 
 1:   nsPresContext* presContext = GetPresContext();
 1:   lineHeight = nsHTMLReflowState::CalcLineHeight(presContext,
 1:                                                  aRenderingContext,
 1:                                                  this);
 1:   fontMet->GetAveCharWidth(charWidth);
 1:   fontMet->GetMaxAdvance(charMaxAdvance);
 1: 
 1:   // Set the width equal to the width in characters
 1:   PRInt32 cols = GetCols();
 1:   aIntrinsicSize.width = cols * charWidth;
 1: 
 1:   // To better match IE, take the maximum character width(in twips) and remove
 1:   // 4 pixels add this on as additional padding(internalPadding). But only do
 1:   // this if charMaxAdvance != charWidth; if they are equal, this is almost
 1:   // certainly a fixed-width font.
 1:   if (charWidth != charMaxAdvance) {
 1:     nscoord internalPadding = PR_MAX(0, charMaxAdvance -
 1:                                         nsPresContext::CSSPixelsToAppUnits(4));
 1:     nscoord t = nsPresContext::CSSPixelsToAppUnits(1); 
 1:    // Round to a multiple of t
 1:     nscoord rest = internalPadding % t; 
 1:     if (rest < t - rest) {
 1:       internalPadding -= rest;
 1:     } else {
 1:       internalPadding += t - rest;
 1:     }
 1:     // Now add the extra padding on (so that small input sizes work well)
 1:     aIntrinsicSize.width += internalPadding;
 1:   } else {
 1:     // This is to account for the anonymous <br> having a 1 twip width
 1:     // in Full Standards mode, see BRFrame::Reflow and bug 228752.
 1:     if (presContext->CompatibilityMode() == eCompatibility_FullStandards) {
 1:       aIntrinsicSize.width += 1;
 1:     }
 1:   }
 1: 
 1:   // Increment width with cols * letter-spacing.
 1:   {
 1:     const nsStyleCoord& lsCoord = GetStyleText()->mLetterSpacing;
 1:     if (eStyleUnit_Coord == lsCoord.GetUnit()) {
 1:       nscoord letterSpacing = lsCoord.GetCoordValue();
 1:       if (letterSpacing != 0) {
 1:         aIntrinsicSize.width += cols * letterSpacing;
 1:       }
 1:     }
 1:   }
 1: 
 1:   // Set the height equal to total number of rows (times the height of each
 1:   // line, of course)
 1:   aIntrinsicSize.height = lineHeight * GetRows();
 1: 
 1:   // Add in the size of the scrollbars for textarea
 1:   if (IsTextArea()) {
 1:     nsIFrame* first = GetFirstChild(nsnull);
 1: 
 1:     nsIScrollableFrame *scrollableFrame;
 1:     CallQueryInterface(first, &scrollableFrame);
 1:     NS_ASSERTION(scrollableFrame, "Child must be scrollable");
 1: 
 1:     nsBoxLayoutState bls(GetPresContext(), aRenderingContext);
 1:     nsMargin scrollbarSizes = scrollableFrame->GetDesiredScrollbarSizes(&bls);
 1: 
 1:     aIntrinsicSize.width  += scrollbarSizes.LeftRight();
 1:     
 1:     aIntrinsicSize.height += scrollbarSizes.TopBottom();;
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: void nsTextControlFrame::PostCreateFrames() {
 1:   InitEditor();
 1: }
 1: 
 1: nsIFrame*
 1: nsTextControlFrame::CreateFrameFor(nsIContent*      aContent)
 1: {
 1: #ifdef DEBUG
 1:   NS_ASSERTION(!mCreateFrameForCalled, "CreateFrameFor called more than once!");
 1:   mCreateFrameForCalled = PR_TRUE;
 1: #endif
 1:   
 1:   nsPresContext *presContext = GetPresContext();
 1:   nsIPresShell *shell = presContext->GetPresShell();
 1:   if (!shell)
 1:     return nsnull;
 1:   
 1:   nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(shell->GetDocument());
 1:   if (!domdoc)
 1:     return nsnull;
 1: 
 1:   // Don't create any frames here, but just setup the editor.
 1:   // This way DOM Ranges (which editor uses) work properly since the anonymous
 1:   // content is bound to tree after CreateAnonymousContent but before this
 1:   // method.
 1:   nsresult rv = NS_OK;
 1:   mEditor = do_CreateInstance(kTextEditorCID, &rv);
 1:   if (NS_FAILED(rv) || !mEditor) 
 1:     return nsnull;
 1: 
 1:   // Create selection
 1: 
 1:   mFrameSel = do_CreateInstance(kFrameSelectionCID, &rv);
 1:   if (NS_FAILED(rv))
 1:     return nsnull;
 1:   mFrameSel->SetScrollableViewProvider(this);
 1: 
 1:   // Create a SelectionController
 1: 
 1:   mSelCon = NS_STATIC_CAST(nsISelectionController*,
 1:               new nsTextInputSelectionImpl(mFrameSel, shell, aContent));
 1:   if (!mSelCon)
 1:     return nsnull;
 1:   mTextListener = new nsTextInputListener();
 1:   if (!mTextListener)
 1:     return nsnull;
 1:   NS_ADDREF(mTextListener);
 1: 
 1:   mTextListener->SetFrame(this);
 1:   mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
 1: 
 1:   // Setup the editor flags
 1: 
 1:   PRUint32 editorFlags = 0;
 1:   if (IsPlainTextControl())
 1:     editorFlags |= nsIPlaintextEditor::eEditorPlaintextMask;
 1:   if (IsSingleLineTextControl())
 1:     editorFlags |= nsIPlaintextEditor::eEditorSingleLineMask;
 1:   if (IsPasswordTextControl())
 1:     editorFlags |= nsIPlaintextEditor::eEditorPasswordMask;
 1: 
 1:   // All gfxtextcontrolframe2's are widgets
 1:   editorFlags |= nsIPlaintextEditor::eEditorWidgetMask;
 1: 
 1:   // Use async reflow and painting for text widgets to improve
 1:   // performance.
 1: 
 1:   // XXX: Using editor async updates exposes bugs 158782, 151882,
 1:   //      and 165130, so we're disabling it for now, until they
 1:   //      can be addressed.
 1:   // editorFlags |= nsIPlaintextEditor::eEditorUseAsyncUpdatesMask;
 1: 
 1:   // Now initialize the editor.
 1:   //
 1:   // NOTE: Conversion of '\n' to <BR> happens inside the
 1:   //       editor's Init() call.
 1: 
 1:   rv = mEditor->Init(domdoc, shell, aContent, mSelCon, editorFlags);
 1: 
 1:   if (NS_FAILED(rv))
 1:     return nsnull;
 1: 
 1:   // Initialize the controller for the editor
 1: 
 1:   if (!SuppressEventHandlers(presContext)) {
 1:     nsCOMPtr<nsIControllers> controllers;
 1:     nsCOMPtr<nsIDOMNSHTMLInputElement> inputElement =
 1:       do_QueryInterface(mContent);
 1:     if (inputElement) {
 1:       rv = inputElement->GetControllers(getter_AddRefs(controllers));
 1:     } else {
 1:       nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaElement =
 1:         do_QueryInterface(mContent);
 1: 
 1:       if (!textAreaElement)
 1:         return nsnull;
 1: 
 1:       rv = textAreaElement->GetControllers(getter_AddRefs(controllers));
 1:     }
 1: 
 1:     if (NS_FAILED(rv))
 1:       return nsnull;
 1: 
 1:     if (controllers) {
 1:       PRUint32 numControllers;
 1:       PRBool found = PR_FALSE;
 1:       rv = controllers->GetControllerCount(&numControllers);
 1:       for (PRUint32 i = 0; i < numControllers; i ++) {
 1:         nsCOMPtr<nsIController> controller;
 1:         rv = controllers->GetControllerAt(i, getter_AddRefs(controller));
 1:         if (NS_SUCCEEDED(rv) && controller) {
 1:           nsCOMPtr<nsIControllerContext> editController =
 1:             do_QueryInterface(controller);
 1:           if (editController) {
 1:             editController->SetCommandContext(mEditor);
 1:             found = PR_TRUE;
 1:           }
 1:         }
 1:       }
 1:       if (!found)
 1:         rv = NS_ERROR_FAILURE;
 1:     }
 1:   }
 1: 
 1:   // Initialize the plaintext editor
 1:   nsCOMPtr<nsIPlaintextEditor> textEditor(do_QueryInterface(mEditor));
 1:   if (textEditor) {
 1:     // Set up wrapping
 1:     if (IsTextArea()) {
 1:       // wrap=off means -1 for wrap width no matter what cols is
 1:       nsHTMLTextWrap wrapProp;
 1:       ::GetWrapPropertyEnum(mContent, wrapProp);
 1:       if (wrapProp == eHTMLTextWrap_Off) {
 1:         // do not wrap when wrap=off
 1:         textEditor->SetWrapWidth(-1);
 1:       } else {
 1:         // Set wrapping normally otherwise
 1:         textEditor->SetWrapWidth(GetCols());
 1:       }
 1:     } else {
 1:       // Never wrap non-textareas
 1:       textEditor->SetWrapWidth(-1);
 1:     }
 1: 
 1: 
 1:     // Set max text field length
 1:     PRInt32 maxLength;
 1:     if (GetMaxLength(&maxLength)) { 
 1:       textEditor->SetMaxTextLength(maxLength);
 1:     }
 1:   }
 1:     
 1:   // Get the caret and make it a selection listener.
 1: 
 1:   nsCOMPtr<nsISelection> domSelection;
 1:   if (NS_SUCCEEDED(mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
 1:                                          getter_AddRefs(domSelection))) &&
 1:       domSelection) {
 1:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(domSelection));
 1:     nsCOMPtr<nsICaret> caret;
 1:     nsCOMPtr<nsISelectionListener> listener;
 1:     if (NS_SUCCEEDED(shell->GetCaret(getter_AddRefs(caret))) && caret) {
 1:       listener = do_QueryInterface(caret);
 1:       if (listener) {
 1:         selPriv->AddSelectionListener(listener);
 1:       }
 1:     }
 1: 
 1:     selPriv->AddSelectionListener(NS_STATIC_CAST(nsISelectionListener*,
 1:                                                  mTextListener));
 1:   }
 1:   
 1:   if (mContent) {
 1:     rv = mEditor->GetFlags(&editorFlags);
 1: 
 1:     if (NS_FAILED(rv))
 1:       return nsnull;
 1: 
 1:     // Check if the readonly attribute is set.
 1: 
 1:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::readonly))
 1:       editorFlags |= nsIPlaintextEditor::eEditorReadonlyMask;
 1: 
 1:     // Check if the disabled attribute is set.
 1: 
 1:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) 
 1:       editorFlags |= nsIPlaintextEditor::eEditorDisabledMask;
 1: 
 1:     // Disable the selection if necessary.
 1: 
 1:     if (editorFlags & nsIPlaintextEditor::eEditorDisabledMask)
 1:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
 1: 
 1:     mEditor->SetFlags(editorFlags);
 1:   }
 1:   return nsnull;
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::InitEditor()
 1: {
 1:   // This method must be called during/after the text
 1:   // control frame's initial reflow to avoid any unintened
 1:   // forced reflows that might result when the editor
 1:   // calls into DOM/layout code while trying to set the
 1:   // initial string.
 1:   //
 1:   // This code used to be called from CreateAnonymousContent(),
 1:   // but when the editor set the initial string, it would trigger
 1:   // a PresShell listener which called FlushPendingNotifications()
 1:   // during frame construction. This was causing other form controls
 1:   // to display wrong values.
 1: 
 1:   // Check if this method has been called already.
 1:   // If so, just return early.
 1: 
 1:   if (mUseEditor)
 1:     return NS_OK;
 1: 
 1:   // If the editor is not here, then we can't use it, now can we?
 1:   if (!mEditor)
 1:     return NS_ERROR_NOT_INITIALIZED;
 1: 
 1:   // Get the current value of the textfield from the content.
 1:   nsAutoString defaultValue;
 1:   GetValue(defaultValue, PR_TRUE);
 1: 
 1:   // Turn on mUseEditor so that subsequent calls will use the
 1:   // editor.
 1:   mUseEditor = PR_TRUE;
 1: 
 1:   // If we have a default value, insert it under the div we created
 1:   // above, but be sure to use the editor so that '*' characters get
 1:   // displayed for password fields, etc. SetValue() will call the
 1:   // editor for us.
 1: 
 1:   if (!defaultValue.IsEmpty()) {
 1:     PRUint32 editorFlags = 0;
 1: 
 1:     nsresult rv = mEditor->GetFlags(&editorFlags);
 1: 
 1:     if (NS_FAILED(rv))
 1:       return rv;
 1: 
 1:     // Avoid causing reentrant painting and reflowing by telling the editor
 1:     // that we don't want it to force immediate view refreshes or force
 1:     // immediate reflows during any editor calls.
 1: 
 1:     rv = mEditor->SetFlags(editorFlags |
 1:                            nsIPlaintextEditor::eEditorUseAsyncUpdatesMask);
 1: 
 1:     if (NS_FAILED(rv))
 1:       return rv;
 1: 
 1:     // Now call SetValue() which will make the necessary editor calls to set
 1:     // the default value.  Make sure to turn off undo before setting the default
 1:     // value, and turn it back on afterwards. This will make sure we can't undo
 1:     // past the default value.
 1: 
 1:     rv = mEditor->EnableUndo(PR_FALSE);
 1: 
 1:     if (NS_FAILED(rv))
 1:       return rv;
 1: 
 1:     SetValue(defaultValue);
 1: 
 1:     rv = mEditor->EnableUndo(PR_TRUE);
 1:     NS_ASSERTION(NS_SUCCEEDED(rv),"Transaction Manager must have failed");
 1:     // Now restore the original editor flags.
 1: 
 1:     rv = mEditor->SetFlags(editorFlags);
 1: 
 1:     if (NS_FAILED(rv))
 1:       return rv;
 1:   }
 1: 
 1:   nsCOMPtr<nsITransactionManager> transMgr;
 1:   mEditor->GetTransactionManager(getter_AddRefs(transMgr));
 1:   NS_ENSURE_TRUE(transMgr, NS_ERROR_FAILURE);
 1: 
 1:   transMgr->SetMaxTransactionCount(DEFAULT_UNDO_CAP);
 1: 
 1:   if (IsPasswordTextControl()) {
 1:     // Disable undo for password textfields.  Note that we want to do this at
 1:     // the very end of InitEditor, so the calls to EnableUndo when setting the
 1:     // default value don't screw us up.
 1:     // Since changing the control type does a reframe, we don't have to worry
 1:     // about dynamic type changes here.
 1:     mEditor->EnableUndo(PR_FALSE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
 1: {
 1:   mState |= NS_FRAME_INDEPENDENT_SELECTION;
 1: 
 1:   nsIPresShell* shell = GetPresContext()->GetPresShell();
 1:   if (!shell)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   nsIDocument *doc = shell->GetDocument();
 1:   if (!doc)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   // Now create a DIV and add it to the anonymous content child list.
 1:   nsCOMPtr<nsINodeInfo> nodeInfo;
 1:   nsresult rv = doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::div, nsnull,
 1:                                                     kNameSpaceID_XHTML,
 1:                                                     getter_AddRefs(nodeInfo));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   rv = NS_NewHTMLElement(getter_AddRefs(mAnonymousDiv), nodeInfo);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   // Set the div native anonymous, so CSS will be its style language
 1:   // no matter what.
 1:   mAnonymousDiv->SetNativeAnonymous(PR_TRUE);
 1: 
 1:   // Set the necessary style attributes on the text control.
 1: 
 1:   rv = mAnonymousDiv->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
 1:                               NS_LITERAL_STRING("anonymous-div"), PR_FALSE);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (!IsSingleLineTextControl()) {
 1:     // We can't just inherit the overflow because setting visible overflow will
 1:     // crash when the number of lines exceeds the height of the textarea and
 1:     // setting -moz-hidden-unscrollable overflow (NS_STYLE_OVERFLOW_CLIP)
 1:     // doesn't paint the caret for some reason.
 1:     const nsStyleDisplay* disp = GetStyleDisplay();
 1:     if (disp->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
 1:         disp->mOverflowX != NS_STYLE_OVERFLOW_CLIP) {
 1:       rv = mAnonymousDiv->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
 1:                                   NS_LITERAL_STRING("overflow: inherit;"),
 1:                                   PR_FALSE);
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1:     }
 1:   }
 1: 
 1:   if (!aElements.AppendElement(mAnonymousDiv))
 1:     return NS_ERROR_OUT_OF_MEMORY;
 1: 
 1:   // rv = divContent->SetAttr(kNameSpaceID_None,nsGkAtoms::debug, NS_LITERAL_STRING("true"), PR_FALSE);
 1:   return NS_OK;
 1: }
 1: 
 1: nscoord
 1: nsTextControlFrame::GetMinWidth(nsIRenderingContext* aRenderingContext)
 1: {
 1:   // Our min width is just our preferred width if we have auto width.
 1:   nscoord result;
 1:   DISPLAY_MIN_WIDTH(this, result);
 1: 
 1:   result = GetPrefWidth(aRenderingContext);
 1: 
 1:   return result;
 1: }
 1: 
 1: // We inherit our GetPrefWidth from nsBoxFrame
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::Reflow(nsPresContext*   aPresContext,
 1:                            nsHTMLReflowMetrics&     aDesiredSize,
 1:                            const nsHTMLReflowState& aReflowState,
 1:                            nsReflowStatus&          aStatus)
 1: {
 1:   DO_GLOBAL_REFLOW_COUNT("nsTextControlFrame");
 1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
 1: 
 1:   // make sure the the form registers itself on the initial/first reflow
 1:   if (mState & NS_FRAME_FIRST_REFLOW) {
 1:     nsFormControlFrame::RegUnRegAccessKey(this, PR_TRUE);
 1:   }
 1: 
 1:   return nsStackFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
 1:                               aStatus);
 1: }
 1: 
 1: nsSize
 1: nsTextControlFrame::GetPrefSize(nsBoxLayoutState& aState)
 1: {
 1:   if (!DoesNeedRecalc(mPrefSize))
 1:      return mPrefSize;
 1: 
 1: #ifdef DEBUG_LAYOUT
 1:   PropagateDebug(aState);
 1: #endif
 1: 
 1:   nsSize pref(0,0);
 1: 
 1:   nsresult rv = CalcIntrinsicSize(aState.GetRenderingContext(), pref);
 1:   NS_ENSURE_SUCCESS(rv, pref);
 1:   AddBorderAndPadding(pref);
 1: 
 1:   mPrefSize = pref;
 1: 
 1: #ifdef DEBUG_rods
 1:   {
 1:     nsMargin borderPadding(0,0,0,0);
 1:     GetBorderAndPadding(borderPadding);
 1:     nsSize size(169, 24);
 1:     nsSize actual(pref.width/15, 
 1:                   pref.height/15);
 1:     printf("nsGfxText(field) %d,%d  %d,%d  %d,%d\n", 
 1:            size.width, size.height, actual.width, actual.height, actual.width-size.width, actual.height-size.height);  // text field
 1:   }
 1: #endif
 1: 
 1:   return pref;
 1: }
 1: 
 1: nsSize
 1: nsTextControlFrame::GetMinSize(nsBoxLayoutState& aState)
 1: {
 1:   // XXXbz why?  Why not the nsBoxFrame sizes?
 1:   return nsBox::GetMinSize(aState);
 1: }
 1: 
 1: nsSize
 1: nsTextControlFrame::GetMaxSize(nsBoxLayoutState& aState)
 1: {
 1:   // XXXbz why?  Why not the nsBoxFrame sizes?
 1:   return nsBox::GetMaxSize(aState);
 1: }
 1: 
 1: nscoord
 1: nsTextControlFrame::GetBoxAscent(nsBoxLayoutState& aState)
 1: {
 1:   // First calculate the ascent of the text inside
 1:   nscoord ascent = nsStackFrame::GetBoxAscent(aState);
 1:     
 1:   // Now adjust the ascent for our borders and padding
 1:   nsMargin borderPadding;
 1:   GetBorderAndPadding(borderPadding);
 1:   ascent += borderPadding.top;
 1:   
 1:   return ascent;
 1: }
 1: 
 1: PRBool
 1: nsTextControlFrame::IsCollapsed(nsBoxLayoutState& aBoxLayoutState)
 1: {
 1:   // We're never collapsed in the box sense.
 1:   return PR_FALSE;
 1: }
 1: 
 1: PRBool
 1: nsTextControlFrame::IsLeaf() const
 1: {
 1:   return PR_TRUE;
 1: }
 1: 
 1: static PRBool
 1: IsFocusedContent(nsPresContext* aPresContext, nsIContent* aContent)
 1: {
 1:   nsCOMPtr<nsIContent> focusedContent;
 1:   aPresContext->EventStateManager()->
 1:     GetFocusedContent(getter_AddRefs(focusedContent));
 1:   return focusedContent == aContent;
 1: }
 1: 
 1: //IMPLEMENTING NS_IFORMCONTROLFRAME
 1: void nsTextControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
 1: {
 1:   if (!aOn || !mSelCon)
 1:     return;
 1: 
 1:   // onfocus="some_where_else.focus()" can trigger several focus
 1:   // in succession. Here, we only care if we are the winner.
 1:   // @see also nsTextEditorFocusListener::Focus()
 1:   if (!IsFocusedContent(GetPresContext(), mContent))
 1:     return;
 1: 
 1:   // tell the caret to use our selection
 1: 
 1:   nsCOMPtr<nsISelection> ourSel;
 1:   mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, 
 1:     getter_AddRefs(ourSel));
 1:   if (!ourSel) return;
 1: 
 1:   nsIPresShell* presShell = GetPresContext()->GetPresShell();
 1:   nsCOMPtr<nsICaret> caret;
 1:   presShell->GetCaret(getter_AddRefs(caret));
 1:   if (!caret) return;
 1:   caret->SetCaretDOMSelection(ourSel);
 1: 
 1:   // mutual-exclusion: the selection is either controlled by the
 1:   // document or by the text input/area. Clear any selection in the
 1:   // document since the focus is now on our independent selection.
 1: 
 1:   nsCOMPtr<nsISelectionController> selCon(do_QueryInterface(presShell));
 1:   nsCOMPtr<nsISelection> docSel;
 1:   selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
 1:     getter_AddRefs(docSel));
 1:   if (!docSel) return;
 1: 
 1:   PRBool isCollapsed = PR_FALSE;
 1:   docSel->GetIsCollapsed(&isCollapsed);
 1:   if (!isCollapsed)
 1:     docSel->RemoveAllRanges();
 1: }
 1: 
 1: nsresult nsTextControlFrame::SetFormProperty(nsIAtom* aName, const nsAString& aValue)
 1: {
 1:   if (!mIsProcessing)//some kind of lock.
 1:   {
 1:     mIsProcessing = PR_TRUE;
 1:     
 1:     if (nsGkAtoms::value == aName) 
 1:     {
 1:       if (mEditor && mUseEditor) {
 1:         // If the editor exists, the control needs to be informed that the value
 1:         // has changed.
 1:         SetValueChanged(PR_TRUE);
 1:       }
 1:       nsresult rv = SetValue(aValue); // set new text value
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1:     }
 1:     else if (nsGkAtoms::select == aName)
 1:     {
 1:       // Select all the text.
 1:       //
 1:       // XXX: This is lame, we can't call mEditor->SelectAll()
 1:       //      because that triggers AutoCopies in unix builds.
 1:       //      Instead, we have to call our own homegrown version
 1:       //      of select all which merely builds a range that selects
 1:       //      all of the content and adds that to the selection.
 1: 
 1:       SelectAllContents();
 1:     }
 1:     mIsProcessing = PR_FALSE;
 1:   }
 1:   return NS_OK;
 1: }      
 1: 
 1: nsresult
 1: nsTextControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
 1: {
 1:   // Return the value of the property from the widget it is not null.
 1:   // If widget is null, assume the widget is GFX-rendered and return a member variable instead.
 1: 
 1:   if (nsGkAtoms::value == aName) {
 1:     GetValue(aValue, PR_FALSE);
 1:   }
 1:   return NS_OK;
 1: }  
 1: 
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::GetEditor(nsIEditor **aEditor)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aEditor);
 1:   *aEditor = mEditor;
 1:   NS_IF_ADDREF(*aEditor);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::OwnsValue(PRBool* aOwnsValue)
 1: {
 1:   NS_PRECONDITION(aOwnsValue, "aOwnsValue must be non-null");
 1:   *aOwnsValue = mUseEditor;
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::GetTextLength(PRInt32* aTextLength)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aTextLength);
 1: 
 1:   nsAutoString   textContents;
 1:   GetValue(textContents, PR_FALSE);   // this is expensive!
 1:   *aTextLength = textContents.Length();
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::SetSelectionInternal(nsIDOMNode *aStartNode,
 1:                                          PRInt32 aStartOffset,
 1:                                          nsIDOMNode *aEndNode,
 1:                                          PRInt32 aEndOffset)
 1: {
 1:   // Create a new range to represent the new selection.
 1:   // Note that we use a new range to avoid having to do
 1:   // isIncreasing checks to avoid possible errors.
 1: 
 1:   nsCOMPtr<nsIDOMRange> range = do_CreateInstance(kRangeCID);
 1:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
 1: 
 1:   nsresult rv = range->SetStart(aStartNode, aStartOffset);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   rv = range->SetEnd(aEndNode, aEndOffset);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   // Get the selection, clear it and add the new range to it!
 1: 
 1:   nsCOMPtr<nsISelection> selection;
 1:   mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  
 1:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
 1: 
 1:   rv = selection->RemoveAllRanges();  
 1: 
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   return selection->AddRange(range);
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::SelectAllContents()
 1: {
 1:   if (!mEditor)
 1:     return NS_OK;
 1: 
 1:   nsCOMPtr<nsIDOMElement> rootElement;
 1:   nsresult rv = mEditor->GetRootElement(getter_AddRefs(rootElement));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   nsCOMPtr<nsIContent> rootContent = do_QueryInterface(rootElement);
 1:   PRInt32 numChildren = rootContent->GetChildCount();
 1: 
 1:   if (numChildren > 0) {
 1:     // We never want to place the selection after the last
 1:     // br under the root node!
 1:     nsIContent *child = rootContent->GetChildAt(numChildren - 1);
 1:     if (child) {
 1:       if (child->Tag() == nsGkAtoms::br)
 1:         --numChildren;
 1:     }
 1:   }
 1: 
 1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
 1: 
 1:   return SetSelectionInternal(rootNode, 0, rootNode, numChildren);
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::SetSelectionEndPoints(PRInt32 aSelStart, PRInt32 aSelEnd)
 1: {
 1:   NS_ASSERTION(aSelStart <= aSelEnd, "Invalid selection offsets!");
 1: 
 1:   if (aSelStart > aSelEnd)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 1:   PRInt32 startOffset, endOffset;
 1: 
 1:   // Calculate the selection start point.
 1: 
 1:   nsresult rv = OffsetToDOMPoint(aSelStart, getter_AddRefs(startNode), &startOffset);
 1: 
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (aSelStart == aSelEnd) {
 1:     // Collapsed selection, so start and end are the same!
 1:     endNode   = startNode;
 1:     endOffset = startOffset;
 1:   }
 1:   else {
 1:     // Selection isn't collapsed so we have to calculate
 1:     // the end point too.
 1: 
 1:     rv = OffsetToDOMPoint(aSelEnd, getter_AddRefs(endNode), &endOffset);
 1: 
 1:     NS_ENSURE_SUCCESS(rv, rv);
 1:   }
 1: 
 1:   return SetSelectionInternal(startNode, startOffset, endNode, endOffset);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::SetSelectionRange(PRInt32 aSelStart, PRInt32 aSelEnd)
 1: {
 1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
 1:   
 1:   if (aSelStart > aSelEnd) {
 1:     // Simulate what we'd see SetSelectionStart() was called, followed
 1:     // by a SetSelectionEnd().
 1: 
 1:     aSelStart   = aSelEnd;
 1:   }
 1: 
 1:   return SetSelectionEndPoints(aSelStart, aSelEnd);
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::SetSelectionStart(PRInt32 aSelectionStart)
 1: {
 1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
 1: 
 1:   PRInt32 selStart = 0, selEnd = 0; 
 1: 
 1:   nsresult rv = GetSelectionRange(&selStart, &selEnd);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (aSelectionStart > selEnd) {
 1:     // Collapse to the new start point.
 1:     selEnd = aSelectionStart; 
 1:   }
 1: 
 1:   selStart = aSelectionStart;
 1:   
 1:   return SetSelectionEndPoints(selStart, selEnd);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::SetSelectionEnd(PRInt32 aSelectionEnd)
 1: {
 1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
 1:   
 1:   PRInt32 selStart = 0, selEnd = 0; 
 1: 
 1:   nsresult rv = GetSelectionRange(&selStart, &selEnd);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (aSelectionEnd < selStart) {
 1:     // Collapse to the new end point.
 1:     selStart = aSelectionEnd; 
 1:   }
 1: 
 1:   selEnd = aSelectionEnd;
 1:   
 1:   return SetSelectionEndPoints(selStart, selEnd);
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::DOMPointToOffset(nsIDOMNode* aNode,
 1:                                      PRInt32 aNodeOffset,
 1:                                      PRInt32* aResult)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aNode && aResult);
 1: 
 1:   *aResult = 0;
 1: 
 1:   nsCOMPtr<nsIDOMElement> rootElement;
 1:   mEditor->GetRootElement(getter_AddRefs(rootElement));
 1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
 1: 
 1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
 1: 
 1:   nsCOMPtr<nsIDOMNodeList> nodeList;
 1: 
 1:   nsresult rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
 1: 
 1:   PRUint32 length = 0;
 1:   rv = nodeList->GetLength(&length);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (!length || aNodeOffset < 0)
 1:     return NS_OK;
 1: 
 1:   PRInt32 i, textOffset = 0;
 1:   PRInt32 lastIndex = (PRInt32)length - 1;
 1: 
 1:   for (i = 0; i < (PRInt32)length; i++) {
 1:     if (rootNode == aNode && i == aNodeOffset) {
 1:       *aResult = textOffset;
 1:       return NS_OK;
 1:     }
 1: 
 1:     nsCOMPtr<nsIDOMNode> item;
 1:     rv = nodeList->Item(i, getter_AddRefs(item));
 1:     NS_ENSURE_SUCCESS(rv, rv);
 1:     NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
 1: 
 1:     nsCOMPtr<nsIDOMText> domText(do_QueryInterface(item));
 1: 
 1:     if (domText) {
 1:       PRUint32 textLength = 0;
 1: 
 1:       rv = domText->GetLength(&textLength);
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:       if (item == aNode) {
 1:         NS_ASSERTION((aNodeOffset >= 0 && aNodeOffset <= (PRInt32)textLength),
 1:                      "Invalid aNodeOffset!");
 1:         *aResult = textOffset + aNodeOffset;
 1:         return NS_OK;
 1:       }
 1: 
 1:       textOffset += textLength;
 1:     }
 1:     else {
 1:       // Must be a BR node. If it's not the last BR node
 1:       // under the root, count it as a newline.
 1: 
 1:       if (i != lastIndex)
 1:         ++textOffset;
 1:     }
 1:   }
 1: 
 1:   NS_ASSERTION((aNode == rootNode && aNodeOffset == (PRInt32)length),
 1:                "Invalid node offset!");
 1: 
 1:   *aResult = textOffset;
 1:   
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::OffsetToDOMPoint(PRInt32 aOffset,
 1:                                      nsIDOMNode** aResult,
 1:                                      PRInt32* aPosition)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aResult && aPosition);
 1: 
 1:   *aResult = nsnull;
 1:   *aPosition = 0;
 1: 
 1:   nsCOMPtr<nsIDOMElement> rootElement;
 1:   mEditor->GetRootElement(getter_AddRefs(rootElement));
 1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
 1: 
 1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
 1: 
 1:   nsCOMPtr<nsIDOMNodeList> nodeList;
 1: 
 1:   nsresult rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
 1: 
 1:   PRUint32 length = 0;
 1: 
 1:   rv = nodeList->GetLength(&length);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (!length || aOffset < 0) {
 1:     *aPosition = 0;
 1:     *aResult = rootNode;
 1:     NS_ADDREF(*aResult);
 1:     return NS_OK;
 1:   }
 1: 
 1:   PRInt32 textOffset = 0;
 1:   PRUint32 lastIndex = length - 1;
 1: 
 1:   for (PRUint32 i=0; i<length; i++) {
 1:     nsCOMPtr<nsIDOMNode> item;
 1:     rv = nodeList->Item(i, getter_AddRefs(item));
 1:     NS_ENSURE_SUCCESS(rv, rv);
 1:     NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
 1: 
 1:     nsCOMPtr<nsIDOMText> domText(do_QueryInterface(item));
 1: 
 1:     if (domText) {
 1:       PRUint32 textLength = 0;
 1: 
 1:       rv = domText->GetLength(&textLength);
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:       // Check if aOffset falls within this range.
 1:       if (aOffset >= textOffset && aOffset <= textOffset+(PRInt32)textLength) {
 1:         *aPosition = aOffset - textOffset;
 1:         *aResult = item;
 1:         NS_ADDREF(*aResult);
 1:         return NS_OK;
 1:       }
 1: 
 1:       textOffset += textLength;
 1: 
 1:       // If there aren't any more siblings after this text node,
 1:       // return the point at the end of this text node!
 1: 
 1:       if (i == lastIndex) {
 1:         *aPosition = textLength;
 1:         *aResult = item;
 1:         NS_ADDREF(*aResult);
 1:         return NS_OK;
 1:       }
 1:     }
 1:     else {
 1:       // Must be a BR node, count it as a newline.
 1: 
 1:       if (aOffset == textOffset || i == lastIndex) {
 1:         // We've found the correct position, or aOffset takes us
 1:         // beyond the last child under rootNode, just return the point
 1:         // under rootNode that is in front of this br.
 1: 
 1:         *aPosition = i;
 1:         *aResult = rootNode;
 1:         NS_ADDREF(*aResult);
 1:         return NS_OK;
 1:       }
 1: 
 1:       ++textOffset;
 1:     }
 1:   }
 1: 
 1:   NS_ASSERTION(0, "We should never get here!");
 1: 
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::GetSelectionRange(PRInt32* aSelectionStart, PRInt32* aSelectionEnd)
 1: {
 1:   // make sure we have an editor
 1:   NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_INITIALIZED);
 1: 
 1:   *aSelectionStart = 0;
 1:   *aSelectionEnd = 0;
 1: 
 1:   nsCOMPtr<nsISelection> selection;
 1:   nsresult rv = mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
 1: 
 1:   PRInt32 numRanges = 0;
 1:   selection->GetRangeCount(&numRanges);
 1: 
 1:   if (numRanges < 1)
 1:     return NS_OK;
 1: 
 1:   // We only operate on the first range in the selection!
 1: 
 1:   nsCOMPtr<nsIDOMRange> firstRange;
 1:   rv = selection->GetRangeAt(0, getter_AddRefs(firstRange));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   NS_ENSURE_TRUE(firstRange, NS_ERROR_FAILURE);
 1: 
 1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 1:   PRInt32 startOffset = 0, endOffset = 0;
 1: 
 1:   // Get the start point of the range.
 1: 
 1:   rv = firstRange->GetStartContainer(getter_AddRefs(startNode));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
 1: 
 1:   rv = firstRange->GetStartOffset(&startOffset);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   // Get the end point of the range.
 1: 
 1:   rv = firstRange->GetEndContainer(getter_AddRefs(endNode));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
 1: 
 1:   rv = firstRange->GetEndOffset(&endOffset);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   // Convert the start point to a selection offset.
 1: 
 1:   rv = DOMPointToOffset(startNode, startOffset, aSelectionStart);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   // Convert the end point to a selection offset.
 1: 
 1:   return DOMPointToOffset(endNode, endOffset, aSelectionEnd);
 1: }
 1: 
 1: /////END INTERFACE IMPLEMENTATIONS
 1: 
 1: ////NSIFRAME
 1: NS_IMETHODIMP
 1: nsTextControlFrame::AttributeChanged(PRInt32         aNameSpaceID,
 1:                                      nsIAtom*        aAttribute,
 1:                                      PRInt32         aModType)
 1: {
 1:   if (!mEditor || !mSelCon) 
 1:     return NS_ERROR_NOT_INITIALIZED;
 1:   nsresult rv = NS_OK;
 1: 
 1:   if (nsGkAtoms::maxlength == aAttribute) 
 1:   {
 1:     PRInt32 maxLength;
 1:     PRBool maxDefined = GetMaxLength(&maxLength);
 1:     
 1:     nsCOMPtr<nsIPlaintextEditor> textEditor = do_QueryInterface(mEditor);
 1:     if (textEditor)
 1:     {
 1:       if (maxDefined) 
 1:       {  // set the maxLength attribute
 1:           textEditor->SetMaxTextLength(maxLength);
 1:         // if maxLength>docLength, we need to truncate the doc content
 1:       }
 1:       else { // unset the maxLength attribute
 1:           textEditor->SetMaxTextLength(-1);
 1:       }
 1:     }
 1:     rv = NS_OK; // don't propagate the error
 1:   } 
 1:   else if (nsGkAtoms::readonly == aAttribute) 
 1:   {
 1:     PRUint32 flags;
 1:     mEditor->GetFlags(&flags);
 1:     if (AttributeExists(nsGkAtoms::readonly))
 1:     { // set readonly
 1:       flags |= nsIPlaintextEditor::eEditorReadonlyMask;
 1:       if (IsFocusedContent(GetPresContext(), mContent))
 1:         mSelCon->SetCaretEnabled(PR_FALSE);
 1:     }
 1:     else 
 1:     { // unset readonly
 1:       flags &= ~(nsIPlaintextEditor::eEditorReadonlyMask);
 1:       if (!(flags & nsIPlaintextEditor::eEditorDisabledMask) &&
 1:           IsFocusedContent(GetPresContext(), mContent))
 1:         mSelCon->SetCaretEnabled(PR_TRUE);
 1:     }    
 1:     mEditor->SetFlags(flags);
 1:   }
 1:   else if (mEditor && nsGkAtoms::disabled == aAttribute) 
 1:   {
 1:     PRUint32 flags;
 1:     mEditor->GetFlags(&flags);
 1:     if (AttributeExists(nsGkAtoms::disabled))
 1:     { // set disabled
 1:       flags |= nsIPlaintextEditor::eEditorDisabledMask;
 1:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
 1:       if (IsFocusedContent(GetPresContext(), mContent))
 1:         mSelCon->SetCaretEnabled(PR_FALSE);
 1:     }
 1:     else 
 1:     { // unset disabled
 1:       flags &= ~(nsIPlaintextEditor::eEditorDisabledMask);
 1:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
 1:     }    
 1:     mEditor->SetFlags(flags);
 1:   }
 1:   // Allow the base class to handle common attributes supported
 1:   // by all form elements... 
 1:   else {
 1:     rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::GetText(nsString* aText)
 1: {
 1:   nsresult rv = NS_OK;
 1:   if (IsSingleLineTextControl()) {
 1:     // If we're going to remove newlines anyway, ignore the wrap property
 1:     GetValue(*aText, PR_TRUE);
 1:     RemoveNewlines(*aText);
 1:   } else {
 1:     nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea = do_QueryInterface(mContent);
 1:     if (textArea) {
 1:       if (mEditor) {
 1:         nsCOMPtr<nsIEditorIMESupport> imeSupport = do_QueryInterface(mEditor);
 1:         if (imeSupport)
 1:           imeSupport->ForceCompositionEnd();
 1:       }
 1:       rv = textArea->GetValue(*aText);
 1:     }
 1:   }
 1:   return rv;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::GetPhonetic(nsAString& aPhonetic)
 1: {
 1:   aPhonetic.Truncate(0); 
 1:   if (!mEditor)
 1:     return NS_ERROR_NOT_INITIALIZED;
 1:   nsCOMPtr<nsIEditorIMESupport> imeSupport = do_QueryInterface(mEditor);
 1:   if (imeSupport) {
 1:     nsCOMPtr<nsIPhonetic> phonetic = do_QueryInterface(imeSupport);
 1:     if (phonetic)
 1:       phonetic->GetPhonetic(aPhonetic);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: ///END NSIFRAME OVERLOADS
 1: /////BEGIN PROTECTED METHODS
 1: 
 1: void nsTextControlFrame::RemoveNewlines(nsString &aString)
 1: {
 1:   // strip CR/LF and null
 1:   static const char badChars[] = {10, 13, 0};
 1:   aString.StripChars(badChars);
 1: }
 1: 
 1: 
 1: PRBool
 1: nsTextControlFrame::GetMaxLength(PRInt32* aSize)
 1: {
 1:   *aSize = -1;
 1: 
 1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
 1:   if (content) {
 1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::maxlength);
 1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
 1:       *aSize = attr->GetIntegerValue();
 1: 
 1:       return PR_TRUE;
 1:     }
 1:   }
 1:   return PR_FALSE;
 1: }
 1: 
 1: // this is where we propagate a content changed event
 1: void
 1: nsTextControlFrame::FireOnInput()
 1: {
 1:   if (!mNotifyOnInput)
 1:     return; // if notification is turned off, do nothing
 1:   
 1:   // Dispatch the "input" event
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsUIEvent event(PR_TRUE, NS_FORM_INPUT, 0);
 1: 
 1:   // Have the content handle the event, propagating it according to normal
 1:   // DOM rules.
95:   nsCOMPtr<nsIPresShell> shell = GetPresContext()->PresShell();
95:   shell->HandleEventWithTarget(&event, nsnull, mContent, &status);
 1: }
 1: 
 1: nsresult
 1: nsTextControlFrame::InitFocusedValue()
 1: {
 1:   return GetText(&mFocusedValue);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::CheckFireOnChange()
 1: {
 1:   nsString value;
 1:   GetText(&value);
 1:   if (!mFocusedValue.Equals(value))
 1:   {
 1:     mFocusedValue = value;
 1:     // Dispatch the change event
 1:     nsEventStatus status = nsEventStatus_eIgnore;
 1:     nsInputEvent event(PR_TRUE, NS_FORM_CHANGE, nsnull);
95:     nsCOMPtr<nsIPresShell> shell = GetPresContext()->PresShell();
95:     shell->HandleEventWithTarget(&event, nsnull, mContent, &status);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: //======
 1: //privates
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::GetValue(nsAString& aValue, PRBool aIgnoreWrap) const
 1: {
 1:   aValue.Truncate();  // initialize out param
 1:   nsresult rv = NS_OK;
 1:   
 1:   if (mEditor && mUseEditor) 
 1:   {
 1:     PRUint32 flags = (nsIDocumentEncoder::OutputLFLineBreak |
 1:                       nsIDocumentEncoder::OutputPreformatted |
 1:                       nsIDocumentEncoder::OutputPersistNBSP);
 1: 
 1:     if (PR_TRUE==IsPlainTextControl())
 1:     {
 1:       flags |= nsIDocumentEncoder::OutputBodyOnly;
 1:     }
 1: 
 1:     if (!aIgnoreWrap) {
 1:       nsHTMLTextWrap wrapProp;
 1:       if (::GetWrapPropertyEnum(mContent, wrapProp) &&
 1:           wrapProp == eHTMLTextWrap_Hard) {
 1:         flags |= nsIDocumentEncoder::OutputWrap;
 1:       }
 1:     }
 1: 
 1:     // What follows is a bit of a hack.  The problem is that we could be in
 1:     // this method because we're being destroyed for whatever reason while
 1:     // script is executing.  If that happens, editor will run with the
 1:     // privileges of the executing script, which means it may not be able to
 1:     // access its own DOM nodes!  Let's try to deal with that by pushing a null
 1:     // JSContext on the JSContext stack to make it clear that we're native
 1:     // code.  Note that any script that's directly trying to access our value
 1:     // has to be going through some scriptable object to do that and that
 1:     // already does the relevant security checks.
 1:     // XXXbz if we could just get the textContent of our anonymous content (eg
 1:     // if plaintext editor didn't create <br> nodes all over), we wouldn't need
 1:     // this.
 1:     nsCOMPtr<nsIJSContextStack> stack =
 1:       do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 1:     PRBool pushed = stack && NS_SUCCEEDED(stack->Push(nsnull));
 1:       
 1:     rv = mEditor->OutputToString(NS_LITERAL_STRING("text/plain"), flags,
 1:                                  aValue);
 1: 
 1:     if (pushed) {
 1:       JSContext* cx;
 1:       stack->Pop(&cx);
 1:       NS_ASSERTION(!cx, "Unexpected JSContext popped!");
 1:     }
 1:   }
 1:   else
 1:   {
 1:     // Otherwise get the value from content.
 1:     nsCOMPtr<nsIDOMHTMLInputElement> inputControl = do_QueryInterface(mContent);
 1:     if (inputControl)
 1:     {
 1:       rv = inputControl->GetValue(aValue);
 1:     }
 1:     else
 1:     {
 1:       nsCOMPtr<nsIDOMHTMLTextAreaElement> textareaControl
 1:           = do_QueryInterface(mContent);
 1:       if (textareaControl)
 1:       {
 1:         rv = textareaControl->GetValue(aValue);
 1:       }
 1:     }
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: 
 1: // END IMPLEMENTING NS_IFORMCONTROLFRAME
 1: 
 1: nsresult
 1: nsTextControlFrame::SetValue(const nsAString& aValue)
 1: {
 1:   // XXX this method should actually propagate errors!  It'd make debugging it
 1:   // so much easier...
 1:   if (mEditor && mUseEditor) 
 1:   {
 1:     nsCOMPtr<nsIEditor> editor = mEditor;
 1:     nsWeakFrame weakFrame(this);
 1:     nsAutoString currentValue;
 1:     GetValue(currentValue, PR_FALSE);
 1:     if (IsSingleLineTextControl())
 1:     {
 1:       RemoveNewlines(currentValue); 
 1:     }
 1:     // this is necessary to avoid infinite recursion
 1:     if (!currentValue.Equals(aValue))
 1:     {
 1:       // \r is an illegal character in the dom, but people use them,
 1:       // so convert windows and mac platform linebreaks to \n:
 1:       // Unfortunately aValue is declared const, so we have to copy
 1:       // in order to do this substitution.
 1:       currentValue.Assign(aValue);
 1:       ::PlatformToDOMLineBreaks(currentValue);
 1: 
 1:       nsCOMPtr<nsIDOMDocument>domDoc;
 1:       nsresult rv = editor->GetDocument(getter_AddRefs(domDoc));
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1:       NS_ENSURE_STATE(domDoc);
 1: 
 1:       // Time to mess with our security context... See comments in GetValue()
 1:       // for why this is needed.  Note that we have to do this up here, because
 1:       // otherwise SelectAll() will fail.
 1:       nsCOMPtr<nsIJSContextStack> stack =
 1:         do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 1:       PRBool pushed = stack && NS_SUCCEEDED(stack->Push(nsnull));
 1: 
 1:       nsCOMPtr<nsISelection> domSel;
 1:       nsCOMPtr<nsISelectionPrivate> selPriv;
 1:       mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(domSel));
 1:       if (domSel)
 1:       {
 1:         selPriv = do_QueryInterface(domSel);
 1:         if (selPriv)
 1:           selPriv->StartBatchChanges();
 1:       }
 1: 
 1:       mSelCon->SelectAll();
 1:       nsCOMPtr<nsIPlaintextEditor> plaintextEditor = do_QueryInterface(editor);
 1:       if (!plaintextEditor) {
 1:         NS_WARNING("Somehow not a plaintext editor?");
 1:         if (pushed) {
 1:           JSContext* cx;
 1:           stack->Pop(&cx);
 1:           NS_ASSERTION(!cx, "Unexpected JSContext popped!");
 1:         }
 1:         return NS_ERROR_FAILURE;
 1:       }
 1: 
 1:       // Since this code does not handle user-generated changes to the text,
 1:       // make sure we don't fire oninput when the editor notifies us.
 1:       // (mNotifyOnInput must be reset before we return).
 1: 
 1:       // To protect against a reentrant call to SetValue, we check whether
 1:       // another SetValue is already happening for this frame.  If it is,
 1:       // we must wait until we unwind to re-enable oninput events.
 1:       PRBool outerTransaction = mNotifyOnInput;
 1:       if (outerTransaction)
 1:         mNotifyOnInput = PR_FALSE;
 1: 
 1:       // get the flags, remove readonly and disabled, set the value,
 1:       // restore flags
 1:       PRUint32 flags, savedFlags;
 1:       editor->GetFlags(&savedFlags);
 1:       flags = savedFlags;
 1:       flags &= ~(nsIPlaintextEditor::eEditorDisabledMask);
 1:       flags &= ~(nsIPlaintextEditor::eEditorReadonlyMask);
 1:       editor->SetFlags(flags);
 1: 
 1:       if (currentValue.Length() < 1)
 1:         editor->DeleteSelection(nsIEditor::eNone);
 1:       else {
 1:         nsCOMPtr<nsIPlaintextEditor> textEditor = do_QueryInterface(editor);
 1:         if (textEditor)
 1:           textEditor->InsertText(currentValue);
 1:       }
 1: 
 1:       editor->SetFlags(savedFlags);
 1:       if (selPriv)
 1:         selPriv->EndBatchChanges();
 1: 
 1:       if (pushed) {
 1:         JSContext* cx;
 1:         stack->Pop(&cx);
 1:         NS_ASSERTION(!cx, "Unexpected JSContext popped!");
 1:       }
 1: 
 1:       NS_ENSURE_STATE(weakFrame.IsAlive());
 1:       if (outerTransaction)
 1:         mNotifyOnInput = PR_TRUE;
 1: 
 1:       // This method isn't used for user-generated changes, except for calls
 1:       // from nsFileControlFrame which sets mFireChangeEventState==true and
 1:       // restores it afterwards (ie. we want onchange events for those changes).
 1:       if (!mFireChangeEventState) {
 1:         // Reset mFocusedValue so the onchange event doesn't fire incorrectly.
 1:         InitFocusedValue();
 1:       }
 1:     }
 1: 
 1:     NS_ENSURE_STATE(weakFrame.IsAlive());
 1:     nsIScrollableView* scrollableView = GetScrollableView();
 1:     if (scrollableView)
 1:     {
 1:       // Scroll the upper left corner of the text control's
 1:       // content area back into view.
 1: 
 1:       scrollableView->ScrollTo(0, 0, NS_VMREFRESH_NO_SYNC);
 1:     }
 1:   }
 1:   else
 1:   {
 1:     // Otherwise set the value in content.
 1:     nsCOMPtr<nsITextControlElement> textControl = do_QueryInterface(mContent);
 1:     if (textControl)
 1:     {
 1:       textControl->TakeTextFrameValue(aValue);
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsTextControlFrame::SetInitialChildList(nsIAtom*        aListName,
 1:                                         nsIFrame*       aChildList)
 1: {
 1:   nsresult rv = nsBoxFrame::SetInitialChildList(aListName, aChildList);
 1:   if (mEditor)
 1:     mEditor->PostCreate();
 1:   //look for scroll view below this frame go along first child list
 1:   nsIFrame* first = GetFirstChild(nsnull);
 1: 
 1:   // Mark the scroll frame as being a reflow root. This will allow
 1:   // incremental reflows to be initiated at the scroll frame, rather
 1:   // than descending from the root frame of the frame hierarchy.
 1:   first->AddStateBits(NS_FRAME_REFLOW_ROOT);
 1: 
 1:   nsIScrollableFrame *scrollableFrame = nsnull;
 1:   CallQueryInterface(first, &scrollableFrame);
 1:   NS_ASSERTION(scrollableFrame, "Child must be scrollable");
 1: 
 1:   // we must turn off scrollbars for singleline text controls
 1:   // XXX FIXME this should be removed,
 1:   // nsGfxScrollFrameInner::CreateAnonymousContent handles this
 1:   if (IsSingleLineTextControl()) 
 1:   {
 1:     if (scrollableFrame)
 1:       scrollableFrame->SetScrollbarVisibility(PR_FALSE, PR_FALSE);
 1:   }
 1: 
 1:   //register focus and key listeners
 1:   nsCOMPtr<nsIDOMEventReceiver> erP = do_QueryInterface(mContent);
 1:   if (erP) {
 1:     // register the event listeners with the DOM event receiver
 1:     rv = erP->AddEventListenerByIID(NS_STATIC_CAST(nsIDOMFocusListener *,mTextListener), NS_GET_IID(nsIDOMFocusListener));
 1:     NS_ASSERTION(NS_SUCCEEDED(rv), "failed to register focus listener");
 1:     // XXXbryner do we need to check for a null presshell here?
 1:     if (!GetPresContext()->GetPresShell())
 1:       return NS_ERROR_FAILURE;
 1:   }
 1: 
 1:   nsCOMPtr<nsIDOMEventGroup> systemGroup;
 1:   erP->GetSystemEventGroup(getter_AddRefs(systemGroup));
 1:   nsCOMPtr<nsIDOM3EventTarget> dom3Targ = do_QueryInterface(mContent);
 1:   if (dom3Targ) {
 1:     // cast because of ambiguous base
 1:     nsIDOMEventListener *listener = NS_STATIC_CAST(nsIDOMKeyListener*,
 1:                                                    mTextListener);
 1: 
 1:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keydown"),
 1:                                       listener, PR_FALSE, systemGroup);
 1:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keypress"),
 1:                                       listener, PR_FALSE, systemGroup);
 1:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keyup"),
 1:                                       listener, PR_FALSE, systemGroup);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: nsIScrollableView* nsTextControlFrame::GetScrollableView()
 1: {
 1:   nsIFrame* first = GetFirstChild(nsnull);
 1:   nsIScrollableFrame* scrollableFrame = nsnull;
 1:   if (first) {
 1:     CallQueryInterface(first, &scrollableFrame);
 1:   }
 1:   return scrollableFrame ? scrollableFrame->GetScrollableView() : nsnull;
 1: }
 1: 
 1: PRBool
 1: nsTextControlFrame::IsScrollable() const
 1: {
 1:   return !IsSingleLineTextControl();
 1: }
 1: 
 1: void
 1: nsTextControlFrame::SetValueChanged(PRBool aValueChanged)
 1: {
 1:   nsCOMPtr<nsITextControlElement> elem = do_QueryInterface(mContent);
 1:   if (elem) {
 1:     elem->SetValueChanged(aValueChanged);
 1:   }
 1: }
 1: 
 1: /* static */ void
 1: nsTextControlFrame::ShutDown()
 1: {
 1:   NS_IF_RELEASE(sNativeTextAreaBindings);
 1:   NS_IF_RELEASE(sNativeInputBindings);
 1: }
