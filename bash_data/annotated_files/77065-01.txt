43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43113:  *
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsCacheMetaData.cpp, released
43113:  * February 22, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan <gordon@netscape.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsCacheMetaData.h"
43113: #include "nsICacheEntryDescriptor.h"
43113: #include "prmem.h"
43113: 
43113: const char *
43113: nsCacheMetaData::GetElement(const char * key)
43113: {
43113:     const char * data = mBuffer;
43113:     const char * limit = mBuffer + mMetaSize;
43113: 
43113:     while (data < limit) {
43113:         // Point to the value part
43113:         const char * value = data + strlen(data) + 1;
77065:         NS_ABORT_IF_FALSE(value < limit, "Cache Metadata corrupted");
43113:         if (strcmp(data, key) == 0)
43113:             return value;
43113: 
43113:         // Skip value part
43113:         data = value + strlen(value) + 1;
43113:     }
77065:     NS_ABORT_IF_FALSE(data == limit, "Metadata corrupted");
43113:     return nsnull;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheMetaData::SetElement(const char * key,
43113:                             const char * value)
43113: {
43113:     const PRUint32 keySize = strlen(key) + 1;
43113:     char * pos = (char *)GetElement(key);
43113: 
43113:     if (!value) {
43113:         // No value means remove the key/value pair completely, if existing
43113:         if (pos) {
43113:             PRUint32 oldValueSize = strlen(pos) + 1;
43113:             PRUint32 offset = pos - mBuffer;
43113:             PRUint32 remainder = mMetaSize - (offset + oldValueSize);
43113: 
43113:             memmove(pos - keySize, pos + oldValueSize, remainder);
43113:             mMetaSize -= keySize + oldValueSize;
43113:         }
43113:         return NS_OK;
43113:     }
43113: 
43113:     const PRUint32 valueSize = strlen(value) + 1;
43113:     PRUint32 newSize = mMetaSize + valueSize;
43113:     if (pos) {
43113:         const PRUint32 oldValueSize = strlen(pos) + 1;
43113:         const PRUint32 offset = pos - mBuffer;
43113:         const PRUint32 remainder = mMetaSize - (offset + oldValueSize);
43113: 
43113:         // Update the value in place
43113:         newSize -= oldValueSize;
43113:         nsresult rv = EnsureBuffer(newSize);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         // Move the remainder to the right place
43113:         pos = mBuffer + offset;
43113:         memmove(pos + valueSize, pos + oldValueSize, remainder);
43113:     } else {
43113:         // allocate new meta data element
43113:         newSize += keySize;
43113:         nsresult rv = EnsureBuffer(newSize);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         // Add after last element
43113:         pos = mBuffer + mMetaSize;
43113:         memcpy(pos, key, keySize);
43113:         pos += keySize;
43113:     }
43113: 
43113:     // Update value
43113:     memcpy(pos, value, valueSize);
43113:     mMetaSize = newSize;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsCacheMetaData::FlattenMetaData(char * buffer, PRUint32 bufSize)
43113: {
43113:     if (mMetaSize > bufSize) {
43113:         NS_ERROR("buffer size too small for meta data.");
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113: 
43113:     memcpy(buffer, mBuffer, mMetaSize);
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsCacheMetaData::UnflattenMetaData(const char * data, PRUint32 size)
43113: {
43113:     if (data && size) {
77065:         // Check if the metadata ends with a zero byte.
77065:         if (data[size-1] != '\0') {
77065:             NS_ERROR("Cache MetaData is not null terminated");
77065:             return NS_ERROR_ILLEGAL_VALUE;
77065:         }
77065:         // Check that there are an even number of zero bytes
77065:         // to match the pattern { key \0 value \0 }
77065:         PRBool odd = PR_FALSE;
77065:         for (int i = 0; i < size; i++) {
77065:             if (data[i] == '\0') 
77065:                 odd = !odd;
77065:         }
77065:         if (odd) {
77065:             NS_ERROR("Cache MetaData is malformed");
77065:             return NS_ERROR_ILLEGAL_VALUE;
77065:         }
77065: 
43113:         nsresult rv = EnsureBuffer(size);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         memcpy(mBuffer, data, size);
43113:         mMetaSize = size;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsCacheMetaData::VisitElements(nsICacheMetaDataVisitor * visitor)
43113: {
43113:     const char * data = mBuffer;
43113:     const char * limit = mBuffer + mMetaSize;
43113: 
43113:     while (data < limit) {
43113:         const char * key = data;
43113:         // Skip key part
43113:         data += strlen(data) + 1;
77065:         NS_ABORT_IF_FALSE(data < limit, "Metadata corrupted");
43113:         PRBool keepGoing;
43113:         nsresult rv = visitor->VisitMetaDataElement(key, data, &keepGoing);
43113:         if (NS_FAILED(rv) || !keepGoing)
43113:             break;
43113: 
43113:         // Skip value part
43113:         data += strlen(data) + 1;
43113:     }
77065:     NS_ABORT_IF_FALSE(data == limit, "Metadata corrupted");
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsCacheMetaData::EnsureBuffer(PRUint32 bufSize)
43113: {
43113:     if (mBufferSize < bufSize) {
43113:         char * buf = (char *)PR_REALLOC(mBuffer, bufSize);
43113:         if (!buf) {
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         }
43113:         mBuffer = buf;
43113:         mBufferSize = bufSize;
43113:     }
43113:     return NS_OK;
43113: }        
