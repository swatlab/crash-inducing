29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18084:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS parser.
    1:  *
    1:  * This is a recursive-descent parser for the JavaScript language specified by
    1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
    1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
    1:  * induced by the recursive parsing (not precise syntax trees, see jsparse.h).
    1:  * After tree construction, it rewrites trees to fold constants and evaluate
    1:  * compile-time expressions.  Finally, it calls js_EmitTree (see jsemit.h) to
    1:  * generate bytecode.
    1:  *
    1:  * This parser attempts no error recovery.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsinterp.h"
15613: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
30268: #include "jslibmath.h"
31925: #include "jsvector.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: #include "jsdhash.h"
    1: #endif
    1: 
48470: #include "jsatominlines.h"
52802: #include "jsobjinlines.h"
50491: #include "jsregexpinlines.h"
50491: 
50491: // Grr, windows.h or something under it #defines CONST...
50491: #ifdef CONST
50491: #undef CONST
50491: #endif
48470: 
40221: using namespace js;
40221: 
    1: /*
10466:  * Asserts to verify assumptions behind pn_ macros.
10466:  */
27012: #define pn_offsetof(m)  offsetof(JSParseNode, m)
27012: 
27012: JS_STATIC_ASSERT(pn_offsetof(pn_link) == pn_offsetof(dn_uses));
27012: JS_STATIC_ASSERT(pn_offsetof(pn_u.name.atom) == pn_offsetof(pn_u.apair.atom));
27012: 
27012: #undef pn_offsetof
10466: 
10466: /*
    1:  * Insist that the next token be of type tt, or report errno and return null.
    1:  * NB: this macro uses cx and ts from its lexical environment.
    1:  */
40854: #define MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, __flags)                                     \
    1:     JS_BEGIN_MACRO                                                                          \
40854:         if (tokenStream.getToken((__flags)) != tt) {                                        \
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, errno);                                 \
    1:             return NULL;                                                                    \
    1:         }                                                                                   \
    1:     JS_END_MACRO
40854: #define MUST_MATCH_TOKEN(tt, errno) MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, 0)
    1: 
    1: #ifdef METER_PARSENODES
    1: static uint32 parsenodes = 0;
    1: static uint32 maxparsenodes = 0;
    1: static uint32 recyclednodes = 0;
    1: #endif
    1: 
27012: void
27012: JSParseNode::become(JSParseNode *pn2)
27012: {
27012:     JS_ASSERT(!pn_defn);
27012:     JS_ASSERT(!pn2->pn_defn);
27012: 
27012:     JS_ASSERT(!pn_used);
27012:     if (pn2->pn_used) {
27012:         JSParseNode **pnup = &pn2->pn_lexdef->dn_uses;
27012:         while (*pnup != pn2)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = this;
27012:         pn_link = pn2->pn_link;
27012:         pn_used = true;
27012:         pn2->pn_link = NULL;
27012:         pn2->pn_used = false;
27012:     }
27012: 
27012:     /* If this is a function node fix up the pn_funbox->node back-pointer. */
27012:     if (PN_TYPE(pn2) == TOK_FUNCTION && pn2->pn_arity == PN_FUNC)
27012:         pn2->pn_funbox->node = this;
27012: 
27012:     pn_type = pn2->pn_type;
27012:     pn_op = pn2->pn_op;
27012:     pn_arity = pn2->pn_arity;
31479:     pn_parens = pn2->pn_parens;
27012:     pn_u = pn2->pn_u;
27012:     pn2->clear();
27012: }
27012: 
27012: void
27012: JSParseNode::clear()
27012: {
27012:     pn_type = TOK_EOF;
27012:     pn_op = JSOP_NOP;
27012:     pn_used = pn_defn = false;
27012:     pn_arity = PN_NULLARY;
31479:     pn_parens = false;
27012: }
27012: 
27012: bool
40860: Parser::init(const jschar *base, size_t length,
 6561:              FILE *fp, const char *filename, uintN lineno)
 3235: {
27012:     JSContext *cx = context;
27012: 
47609:     tempPoolMark = JS_ARENA_MARK(&cx->tempPool);
40270:     if (!tokenStream.init(base, length, fp, filename, lineno)) {
47609:         JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
27012:         return false;
27012:     }
27012:     return true;
27012: }
27012: 
40860: Parser::~Parser()
27012: {
27012:     JSContext *cx = context;
27012: 
27012:     if (principals)
27012:         JSPRINCIPALS_DROP(cx, principals);
40270:     tokenStream.close();
47609:     JS_ARENA_RELEASE(&cx->tempPool, tempPoolMark);
26970: }
26970: 
26970: void
40860: Parser::setPrincipals(JSPrincipals *prin)
27012: {
27012:     JS_ASSERT(!principals);
27012:     if (prin)
27012:         JSPRINCIPALS_HOLD(context, prin);
27012:     principals = prin;
27012: }
27012: 
27012: JSObjectBox *
40860: Parser::newObjectBox(JSObject *obj)
27012: {
27012:     JS_ASSERT(obj);
 3235: 
 3235:     /*
 3235:      * We use JSContext.tempPool to allocate parsed objects and place them on
40860:      * a list in this Parser to ensure GC safety. Thus the tempPool arenas
11534:      * containing the entries must be alive until we are done with scanning,
 3235:      * parsing and code generation for the whole script or top-level function.
 3235:      */
27012:     JSObjectBox *objbox;
47609:     JS_ARENA_ALLOCATE_TYPE(objbox, JSObjectBox, &context->tempPool);
27012:     if (!objbox) {
27012:         js_ReportOutOfScriptQuota(context);
27012:         return NULL;
27012:     }
27012:     objbox->traceLink = traceListHead;
27012:     traceListHead = objbox;
27012:     objbox->emitLink = NULL;
27012:     objbox->object = obj;
27012:     return objbox;
27012: }
27012: 
27012: JSFunctionBox *
40860: Parser::newFunctionBox(JSObject *obj, JSParseNode *fn, JSTreeContext *tc)
27012: {
26970:     JS_ASSERT(obj);
40430:     JS_ASSERT(obj->isFunction());
27012: 
27012:     /*
27012:      * We use JSContext.tempPool to allocate parsed objects and place them on
40860:      * a list in this Parser to ensure GC safety. Thus the tempPool arenas
27012:      * containing the entries must be alive until we are done with scanning,
27012:      * parsing and code generation for the whole script or top-level function.
27012:      */
27012:     JSFunctionBox *funbox;
47609:     JS_ARENA_ALLOCATE_TYPE(funbox, JSFunctionBox, &context->tempPool);
27012:     if (!funbox) {
27012:         js_ReportOutOfScriptQuota(context);
27012:         return NULL;
27012:     }
27012:     funbox->traceLink = traceListHead;
27012:     traceListHead = funbox;
27012:     funbox->emitLink = NULL;
27012:     funbox->object = obj;
27012:     funbox->node = fn;
27012:     funbox->siblings = tc->functionList;
27012:     tc->functionList = funbox;
40860:     ++tc->parser->functionCount;
27012:     funbox->kids = NULL;
27012:     funbox->parent = tc->funbox;
37685:     funbox->methods = NULL;
27012:     funbox->queued = false;
28814:     funbox->inLoop = false;
28814:     for (JSStmtInfo *stmt = tc->topStmt; stmt; stmt = stmt->down) {
28814:         if (STMT_IS_LOOP(stmt)) {
28814:             funbox->inLoop = true;
28814:             break;
28814:         }
28814:     }
27012:     funbox->level = tc->staticLevel;
35113:     funbox->tcflags = (TCF_IN_FUNCTION | (tc->flags & (TCF_COMPILE_N_GO | TCF_STRICT_MODE_CODE)));
27012:     return funbox;
27012: }
26970: 
37685: bool
37685: JSFunctionBox::joinable() const
37685: {
37685:     return FUN_NULL_CLOSURE((JSFunction *) object) &&
37685:            !(tcflags & (TCF_FUN_USES_ARGUMENTS | TCF_FUN_USES_OWN_NAME));
37685: }
37685: 
37685: bool
37685: JSFunctionBox::shouldUnbrand(uintN methods, uintN slowMethods) const
37685: {
37685:     if (slowMethods != 0) {
37685:         for (const JSFunctionBox *funbox = this; funbox; funbox = funbox->parent) {
38549:             if (!(funbox->tcflags & TCF_FUN_MODULE_PATTERN))
37685:                 return true;
37685:             if (funbox->inLoop)
37685:                 return true;
37685:         }
37685:     }
37685:     return false;
37685: }
37685: 
26970: void
40860: Parser::trace(JSTracer *trc)
27012: {
40398:     JSObjectBox *objbox = traceListHead;
27012:     while (objbox) {
27012:         JS_CALL_OBJECT_TRACER(trc, objbox->object, "parser.object");
27012:         objbox = objbox->traceLink;
27012:     }
27012: }
27012: 
27012: static void
27012: UnlinkFunctionBoxes(JSParseNode *pn, JSTreeContext *tc);
27012: 
27012: static void
27012: UnlinkFunctionBox(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     JSFunctionBox *funbox = pn->pn_funbox;
27012:     if (funbox) {
27012:         JS_ASSERT(funbox->node == pn);
27012:         funbox->node = NULL;
27012: 
38608:         if (funbox->parent && PN_OP(pn) == JSOP_LAMBDA) {
38608:             /*
38608:              * Remove pn from funbox->parent's methods list if it's there. See
38608:              * the TOK_SEMI case in Statement, near the bottom, the TOK_ASSIGN
38608:              * sub-case matching a constructor method assignment pattern.
38608:              */
38608:             JS_ASSERT(!pn->pn_defn);
38608:             JS_ASSERT(!pn->pn_used);
38608:             JSParseNode **pnp = &funbox->parent->methods;
38608:             while (JSParseNode *method = *pnp) {
38608:                 if (method == pn) {
38608:                     *pnp = method->pn_link;
38608:                     break;
38608:                 }
38608:                 pnp = &method->pn_link;
38608:             }
38608:         }
38608: 
27012:         JSFunctionBox **funboxp = &tc->functionList;
27012:         while (*funboxp) {
27012:             if (*funboxp == funbox) {
27012:                 *funboxp = funbox->siblings;
27012:                 break;
27012:             }
27012:             funboxp = &(*funboxp)->siblings;
27012:         }
27012: 
33752:         uint32 oldflags = tc->flags;
27012:         JSFunctionBox *oldlist = tc->functionList;
27012: 
33752:         tc->flags = funbox->tcflags;
27012:         tc->functionList = funbox->kids;
27012:         UnlinkFunctionBoxes(pn->pn_body, tc);
27012:         funbox->kids = tc->functionList;
27012:         tc->flags = oldflags;
27012:         tc->functionList = oldlist;
27012: 
27012:         // FIXME: use a funbox freelist (consolidate aleFreeList and nodeList).
27012:         pn->pn_funbox = NULL;
27012:     }
27012: }
27012: 
27012: static void
27012: UnlinkFunctionBoxes(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     if (pn) {
27012:         switch (pn->pn_arity) {
27012:           case PN_NULLARY:
27012:             return;
27012:           case PN_UNARY:
27012:             UnlinkFunctionBoxes(pn->pn_kid, tc);
27012:             return;
27012:           case PN_BINARY:
27012:             UnlinkFunctionBoxes(pn->pn_left, tc);
27012:             UnlinkFunctionBoxes(pn->pn_right, tc);
27012:             return;
27012:           case PN_TERNARY:
27012:             UnlinkFunctionBoxes(pn->pn_kid1, tc);
27012:             UnlinkFunctionBoxes(pn->pn_kid2, tc);
27012:             UnlinkFunctionBoxes(pn->pn_kid3, tc);
27012:             return;
27012:           case PN_LIST:
27012:             for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
27012:                 UnlinkFunctionBoxes(pn2, tc);
27012:             return;
27012:           case PN_FUNC:
27012:             UnlinkFunctionBox(pn, tc);
27012:             return;
27012:           case PN_NAME:
27012:             UnlinkFunctionBoxes(pn->maybeExpr(), tc);
27012:             return;
27012:           case PN_NAMESET:
27012:             UnlinkFunctionBoxes(pn->pn_tree, tc);
27012:         }
27012:     }
27012: }
27012: 
27012: static void
27012: RecycleFuncNameKids(JSParseNode *pn, JSTreeContext *tc);
 3235: 
    1: static JSParseNode *
    1: RecycleTree(JSParseNode *pn, JSTreeContext *tc)
    1: {
27012:     JSParseNode *next, **head;
    1: 
    1:     if (!pn)
    1:         return NULL;
 3235: 
 3235:     /* Catch back-to-back dup recycles. */
40860:     JS_ASSERT(pn != tc->parser->nodeList);
    1:     next = pn->pn_next;
27012:     if (pn->pn_used || pn->pn_defn) {
27012:         /*
27012:          * JSAtomLists own definition nodes along with their used-node chains.
27012:          * Defer recycling such nodes until we unwind to top level to avoid
27012:          * linkage overhead or (alternatively) unlinking runtime complexity.
27012:          * Yes, this means dead code can contribute to static analysis results!
27012:          *
27012:          * Do recycle kids here, since they are no longer needed.
27012:          */
27012:         pn->pn_next = NULL;
27012:         RecycleFuncNameKids(pn, tc);
27012:     } else {
27012:         UnlinkFunctionBoxes(pn, tc);
40860:         head = &tc->parser->nodeList;
27012:         pn->pn_next = *head;
27012:         *head = pn;
    1: #ifdef METER_PARSENODES
    1:         recyclednodes++;
    1: #endif
27012:     }
    1:     return next;
    1: }
    1: 
27012: static void
27012: RecycleFuncNameKids(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     switch (pn->pn_arity) {
27012:       case PN_FUNC:
27012:         UnlinkFunctionBox(pn, tc);
27012:         /* FALL THROUGH */
27012: 
27012:       case PN_NAME:
27012:         /*
27012:          * Only a definition node might have a non-null strong pn_expr link
27012:          * to recycle, but we test !pn_used to handle PN_FUNC fall through.
27012:          * Every node with the pn_used flag set has a non-null pn_lexdef
27012:          * weak reference to its definition node.
27012:          */
27012:         if (!pn->pn_used && pn->pn_expr) {
27012:             RecycleTree(pn->pn_expr, tc);
27012:             pn->pn_expr = NULL;
27012:         }
27012:         break;
27012: 
27012:       default:
27648:         JS_ASSERT(PN_TYPE(pn) == TOK_FUNCTION);
27012:     }
27012: }
27012: 
40232: /*
40232:  * Allocate a JSParseNode from tc's node freelist or, failing that, from cx's
40232:  * temporary arena.
40232:  */
26970: static JSParseNode *
27012: NewOrRecycledNode(JSTreeContext *tc)
27012: {
27012:     JSParseNode *pn, *pn2;
27012: 
40860:     pn = tc->parser->nodeList;
    1:     if (!pn) {
40860:         JSContext *cx = tc->parser->context;
27012: 
47609:         JS_ARENA_ALLOCATE_TYPE(pn, JSParseNode, &cx->tempPool);
    1:         if (!pn)
 8296:             js_ReportOutOfScriptQuota(cx);
    1:     } else {
40860:         tc->parser->nodeList = pn->pn_next;
    1: 
    1:         /* Recycle immediate descendents only, to save work and working set. */
    1:         switch (pn->pn_arity) {
    1:           case PN_FUNC:
    1:             RecycleTree(pn->pn_body, tc);
    1:             break;
    1:           case PN_LIST:
27012:             pn2 = pn->pn_head;
27012:             if (pn2) {
27012:                 while (pn2 && !pn2->pn_used && !pn2->pn_defn)
27012:                     pn2 = pn2->pn_next;
27012:                 if (pn2) {
27012:                     pn2 = pn->pn_head;
27012:                     do {
27012:                         pn2 = RecycleTree(pn2, tc);
27012:                     } while (pn2);
27012:                 } else {
40860:                     *pn->pn_tail = tc->parser->nodeList;
40860:                     tc->parser->nodeList = pn->pn_head;
    1: #ifdef METER_PARSENODES
    1:                     recyclednodes += pn->pn_count;
    1: #endif
27012:                     break;
27012:                 }
    1:             }
    1:             break;
    1:           case PN_TERNARY:
    1:             RecycleTree(pn->pn_kid1, tc);
    1:             RecycleTree(pn->pn_kid2, tc);
    1:             RecycleTree(pn->pn_kid3, tc);
    1:             break;
    1:           case PN_BINARY:
15154:             if (pn->pn_left != pn->pn_right)
    1:                 RecycleTree(pn->pn_left, tc);
    1:             RecycleTree(pn->pn_right, tc);
    1:             break;
    1:           case PN_UNARY:
    1:             RecycleTree(pn->pn_kid, tc);
    1:             break;
    1:           case PN_NAME:
27012:             if (!pn->pn_used)
    1:                 RecycleTree(pn->pn_expr, tc);
    1:             break;
    1:           case PN_NULLARY:
    1:             break;
    1:         }
    1:     }
 2567:     if (pn) {
    1: #ifdef METER_PARSENODES
    1:         parsenodes++;
    1:         if (parsenodes - recyclednodes > maxparsenodes)
    1:             maxparsenodes = parsenodes - recyclednodes;
    1: #endif
27012:         pn->pn_used = pn->pn_defn = false;
 1577:         memset(&pn->pn_u, 0, sizeof pn->pn_u);
 1577:         pn->pn_next = NULL;
 2567:     }
    1:     return pn;
    1: }
    1: 
40232: /* used only by static create methods of subclasses */
40232: 
40232: JSParseNode *
40232: JSParseNode::create(JSParseNodeArity arity, JSTreeContext *tc)
40221: {
40270:     JSParseNode *pn = NewOrRecycledNode(tc);
    1:     if (!pn)
    1:         return NULL;
40860:     const Token &tok = tc->parser->tokenStream.currentToken();
40854:     pn->init(tok.type, JSOP_NOP, arity);
40854:     pn->pn_pos = tok.pos;
    1:     return pn;
    1: }
    1: 
40232: JSParseNode *
40320: JSParseNode::newBinaryOrAppend(TokenKind tt, JSOp op, JSParseNode *left, JSParseNode *right,
    1:                                JSTreeContext *tc)
    1: {
    1:     JSParseNode *pn, *pn1, *pn2;
    1: 
    1:     if (!left || !right)
    1:         return NULL;
    1: 
    1:     /*
    1:      * Flatten a left-associative (left-heavy) tree of a given operator into
    1:      * a list, to reduce js_FoldConstants and js_EmitTree recursion.
    1:      */
27012:     if (PN_TYPE(left) == tt &&
27012:         PN_OP(left) == op &&
    1:         (js_CodeSpec[op].format & JOF_LEFTASSOC)) {
    1:         if (left->pn_arity != PN_LIST) {
    1:             pn1 = left->pn_left, pn2 = left->pn_right;
    1:             left->pn_arity = PN_LIST;
31479:             left->pn_parens = false;
27012:             left->initList(pn1);
27012:             left->append(pn2);
    1:             if (tt == TOK_PLUS) {
    1:                 if (pn1->pn_type == TOK_STRING)
27012:                     left->pn_xflags |= PNX_STRCAT;
    1:                 else if (pn1->pn_type != TOK_NUMBER)
27012:                     left->pn_xflags |= PNX_CANTFOLD;
    1:                 if (pn2->pn_type == TOK_STRING)
27012:                     left->pn_xflags |= PNX_STRCAT;
    1:                 else if (pn2->pn_type != TOK_NUMBER)
27012:                     left->pn_xflags |= PNX_CANTFOLD;
27012:             }
27012:         }
27012:         left->append(right);
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         if (tt == TOK_PLUS) {
    1:             if (right->pn_type == TOK_STRING)
27012:                 left->pn_xflags |= PNX_STRCAT;
    1:             else if (right->pn_type != TOK_NUMBER)
27012:                 left->pn_xflags |= PNX_CANTFOLD;
    1:         }
    1:         return left;
    1:     }
    1: 
    1:     /*
    1:      * Fold constant addition immediately, to conserve node space and, what's
    1:      * more, so js_FoldConstants never sees mixed addition and concatenation
    1:      * operations with more than one leading non-string operand in a PN_LIST
    1:      * generated for expressions such as 1 + 2 + "pt" (which should evaluate
    1:      * to "3pt", not "12pt").
    1:      */
    1:     if (tt == TOK_PLUS &&
    1:         left->pn_type == TOK_NUMBER &&
    1:         right->pn_type == TOK_NUMBER) {
    1:         left->pn_dval += right->pn_dval;
    1:         left->pn_pos.end = right->pn_pos.end;
    1:         RecycleTree(right, tc);
    1:         return left;
    1:     }
    1: 
27012:     pn = NewOrRecycledNode(tc);
    1:     if (!pn)
    1:         return NULL;
40232:     pn->init(tt, op, PN_BINARY);
    1:     pn->pn_pos.begin = left->pn_pos.begin;
    1:     pn->pn_pos.end = right->pn_pos.end;
    1:     pn->pn_left = left;
    1:     pn->pn_right = right;
40232:     return (BinaryNode *)pn;
40232: }
40232: 
40232: namespace js {
40232: 
40232: inline void
40232: NameNode::initCommon(JSTreeContext *tc)
40232: {
40232:     pn_expr = NULL;
47573:     pn_cookie.makeFree();
40232:     pn_dflags = tc->atTopLevel() ? PND_TOPLEVEL : 0;
40232:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
40232:         pn_dflags |= PND_BLOCKCHILD;
40232:     pn_blockid = tc->blockid();
40232: }
40232: 
40232: NameNode *
40232: NameNode::create(JSAtom *atom, JSTreeContext *tc)
40232: {
40232:     JSParseNode *pn;
40232: 
40232:     pn = JSParseNode::create(PN_NAME, tc);
40232:     if (pn) {
40232:         pn->pn_atom = atom;
40232:         ((NameNode *)pn)->initCommon(tc);
40232:     }
40232:     return (NameNode *)pn;
40232: }
40232: 
40232: } /* namespace js */
    1: 
27012: static bool
27012: GenerateBlockId(JSTreeContext *tc, uint32& blockid)
27012: {
27012:     if (tc->blockidGen == JS_BIT(20)) {
40860:         JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
27012:                              JSMSG_NEED_DIET, "program");
27012:         return false;
27012:     }
27012:     blockid = tc->blockidGen++;
27012:     return true;
27012: }
27012: 
27012: static bool
27012: GenerateBlockIdForStmtNode(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     JS_ASSERT(tc->topStmt);
27012:     JS_ASSERT(STMT_MAYBE_SCOPE(tc->topStmt));
27012:     JS_ASSERT(pn->pn_type == TOK_LC || pn->pn_type == TOK_LEXICALSCOPE);
27012:     if (!GenerateBlockId(tc, tc->topStmt->blockid))
27012:         return false;
27012:     pn->pn_blockid = tc->topStmt->blockid;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Parse a top-level JS script.
    1:  */
 8444: JSParseNode *
40860: Parser::parse(JSObject *chain)
27012: {
    1:     /*
    1:      * Protect atoms from being collected by a GC activation, which might
    1:      * - nest on this thread due to out of memory (the so-called "last ditch"
    1:      *   GC attempted within js_NewGCThing), or
    1:      * - run for any reason on another thread if this thread is suspended on
    1:      *   an object lock before it finishes generating bytecode into a script
    1:      *   protected from the GC by a root or a stack frame reference.
    1:      */
40263:     JSTreeContext globaltc(this);
40263:     globaltc.scopeChain = chain;
40263:     if (!GenerateBlockId(&globaltc, globaltc.bodyid))
40263:         return NULL;
40263: 
40263:     JSParseNode *pn = statements();
    1:     if (pn) {
40354:         if (!tokenStream.matchToken(TOK_EOF)) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
    1:         } else {
40263:             if (!js_FoldConstants(context, pn, &globaltc))
    1:                 pn = NULL;
    1:         }
    1:     }
    1:     return pn;
    1: }
    1: 
47573: JS_STATIC_ASSERT(UpvarCookie::FREE_LEVEL == JS_BITMASK(JSFB_LEVEL_BITS));
28814: 
27012: static inline bool
27012: SetStaticLevel(JSTreeContext *tc, uintN staticLevel)
27012: {
27012:     /*
47573:      * This is a lot simpler than error-checking every UpvarCookie::set, and
47573:      * practically speaking it leaves more than enough room for upvars.
47573:      */
47573:     if (UpvarCookie::isLevelReserved(staticLevel)) {
40860:         JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
27012:                              JSMSG_TOO_DEEP, js_function_str);
27012:         return false;
27012:     }
27012:     tc->staticLevel = staticLevel;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Compile a top-level script.
    1:  */
27012: JSScript *
40860: Compiler::compileScript(JSContext *cx, JSObject *scopeChain, JSStackFrame *callerFrame,
18955:                         JSPrincipals *principals, uint32 tcflags,
18955:                         const jschar *chars, size_t length,
24375:                         FILE *file, const char *filename, uintN lineno,
33751:                         JSString *source /* = NULL */,
53125:                         uintN staticLevel /* = 0 */)
27012: {
 6561:     JSArenaPool codePool, notePool;
40320:     TokenKind tt;
    1:     JSParseNode *pn;
16072:     uint32 scriptGlobals;
 6561:     JSScript *script;
35113:     bool inDirectivePrologue;
    1: #ifdef METER_PARSENODES
    1:     void *sbrk(ptrdiff_t), *before = sbrk(0);
    1: #endif
    1: 
52555:     JS_ASSERT(!(tcflags & ~(TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL | TCF_NEED_MUTABLE_SCRIPT |
52555:                             TCF_COMPILE_FOR_EVAL)));
 8444: 
    1:     /*
18955:      * The scripted callerFrame can only be given for compile-and-go scripts
27012:      * and non-zero static level requires callerFrame.
    1:      */
18955:     JS_ASSERT_IF(callerFrame, tcflags & TCF_COMPILE_N_GO);
33751:     JS_ASSERT_IF(staticLevel != 0, callerFrame);
27012: 
41867:     Compiler compiler(cx, principals, callerFrame);
40860:     if (!compiler.init(chars, length, file, filename, lineno))
27012:         return NULL;
    1: 
47609:     JS_InitArenaPool(&codePool, "code", 1024, sizeof(jsbytecode),
47609:                      &cx->scriptStackQuota);
47609:     JS_InitArenaPool(&notePool, "note", 1024, sizeof(jssrcnote),
47609:                      &cx->scriptStackQuota);
27012: 
40860:     Parser &parser = compiler.parser;
40860:     TokenStream &tokenStream = parser.tokenStream;
40860: 
40860:     JSCodeGenerator cg(&parser, &codePool, &notePool, tokenStream.getLineno());
41867:     if (!cg.init())
41867:         return NULL;
 6561: 
18989:     MUST_FLOW_THROUGH("out");
28817: 
53198:     // We can specialize a bit for the given scope chain if that scope chain is the global object.
53198:     JSObject *globalObj = scopeChain && scopeChain == scopeChain->getGlobal()
53198:                         ? scopeChain->getGlobal()
53198:                         : NULL;
52555:     js::GlobalScope globalScope(cx, globalObj, &cg);
52555:     if (globalObj) {
52555:         JS_ASSERT(globalObj->isNative());
52555:         JS_ASSERT((globalObj->getClass()->flags & JSCLASS_GLOBAL_FLAGS) == JSCLASS_GLOBAL_FLAGS);
53305: 
53305:         /* Make sure function and object classes are initialized. */
53305:         JSObject *tobj;
53305:         if (!js_GetClassPrototype(cx, scopeChain, JSProto_Function, &tobj))
53305:             return NULL;
53305: 
52555:         globalScope.globalFreeSlot = globalObj->scope()->freeslot;
52555:     }
52555: 
28817:     /* Null script early in case of error, to reduce our code footprint. */
28817:     script = NULL;
28817: 
52555:     globalScope.cg = &cg;
33752:     cg.flags |= tcflags;
27012:     cg.scopeChain = scopeChain;
52555:     compiler.globalScope = &globalScope;
33751:     if (!SetStaticLevel(&cg, staticLevel))
28817:         goto out;
27012: 
35303:     /* If this is a direct call to eval, inherit the caller's strictness.  */
35303:     if (callerFrame &&
51056:         callerFrame->hasScript() &&
51056:         callerFrame->getScript()->strictModeCode) {
35303:         cg.flags |= TCF_STRICT_MODE_CODE;
40860:         tokenStream.setStrictMode();
35303:     }
35303: 
27012:     /*
27012:      * If funbox is non-null after we create the new script, callerFrame->fun
24375:      * was saved in the 0th object table entry.
21449:      */
28817:     JSObjectBox *funbox;
28817:     funbox = NULL;
24375: 
24375:     if (tcflags & TCF_COMPILE_N_GO) {
24375:         if (source) {
24375:             /*
24375:              * Save eval program source in script->atomMap.vector[0] for the
24375:              * eval cache (see obj_eval in jsobj.cpp).
24375:              */
24375:             JSAtom *atom = js_AtomizeString(cx, source, 0);
40860:             if (!atom || !cg.atomList.add(&parser, atom))
28817:                 goto out;
24375:         }
24375: 
51056:         if (callerFrame && callerFrame->hasFunction()) {
24375:             /*
24375:              * An eval script in a caller frame needs to have its enclosing
27012:              * function captured in case it refers to an upvar, and someone
27012:              * wishes to decompile it while it's running.
27012:              */
51056:             funbox = parser.newObjectBox(FUN_OBJECT(callerFrame->getFunction()));
27012:             if (!funbox)
28817:                 goto out;
27012:             funbox->emitLink = cg.objectList.lastbox;
27012:             cg.objectList.lastbox = funbox;
21449:             cg.objectList.length++;
21449:         }
24375:     }
21449: 
27012:     /*
40239:      * Inline this->statements to emit as we go to save AST space. We must
40239:      * generate our script-body blockid since we aren't calling Statements.
27012:      */
27012:     uint32 bodyid;
27012:     if (!GenerateBlockId(&cg, bodyid))
28817:         goto out;
27012:     cg.bodyid = bodyid;
27012: 
27903: #if JS_HAS_XML_SUPPORT
27903:     pn = NULL;
28817:     bool onlyXML;
28817:     onlyXML = true;
27903: #endif
27903: 
32776:     CG_SWITCH_TO_PROLOG(&cg);
32776:     if (js_Emit1(cx, &cg, JSOP_TRACE) < 0)
32776:         goto out;
32776:     CG_SWITCH_TO_MAIN(&cg);
32776: 
35113:     inDirectivePrologue = true;
 9604:     for (;;) {
40860:         tt = tokenStream.peekToken(TSF_OPERAND);
 9604:         if (tt <= TOK_EOF) {
 9604:             if (tt == TOK_EOF)
 9604:                 break;
 9604:             JS_ASSERT(tt == TOK_ERROR);
 9604:             goto out;
 9604:         }
 9604: 
40860:         pn = parser.statement();
27012:         if (!pn)
 6561:             goto out;
27012:         JS_ASSERT(!cg.blockNode);
27012: 
35113:         if (inDirectivePrologue)
40860:             inDirectivePrologue = parser.recognizeDirectivePrologue(pn);
35113: 
27012:         if (!js_FoldConstants(cx, pn, &cg))
 6561:             goto out;
27012: 
27012:         if (cg.functionList) {
40860:             if (!parser.analyzeFunctions(cg.functionList, cg.flags))
27012:                 goto out;
27012:             cg.functionList = NULL;
27012:         }
27012: 
27012:         if (!js_EmitTree(cx, &cg, pn))
27012:             goto out;
27903: #if JS_HAS_XML_SUPPORT
27903:         if (PN_TYPE(pn) != TOK_SEMI ||
27903:             !pn->pn_kid ||
40320:             !TreeTypeIsXML(PN_TYPE(pn->pn_kid))) {
27903:             onlyXML = false;
27903:         }
27903: #endif
27012:         RecycleTree(pn, &cg);
 9604:     }
 9604: 
27903: #if JS_HAS_XML_SUPPORT
27903:     /*
27903:      * Prevent XML data theft via <script src="http://victim.com/foo.xml">.
27903:      * For background, see:
27903:      *
27903:      * https://bugzilla.mozilla.org/show_bug.cgi?id=336551
27903:      */
43195:     if (pn && onlyXML && !callerFrame) {
42671:         parser.reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_XML_WHOLE_PROGRAM);
27903:         goto out;
27903:     }
27903: #endif
27903: 
16072:     /*
37029:      * Global variables (gvars) share the atom index space with locals. Due to
17947:      * incremental code generation we need to patch the bytecode to adjust the
17947:      * local references to skip the globals.
16072:      */
37029:     scriptGlobals = cg.ngvars;
32756:     if (scriptGlobals != 0 || cg.hasSharps()) {
16072:         jsbytecode *code, *end;
16072:         JSOp op;
16072:         const JSCodeSpec *cs;
16072:         uintN len, slot;
16072: 
16072:         if (scriptGlobals >= SLOTNO_LIMIT)
16072:             goto too_many_slots;
16072:         code = CG_BASE(&cg);
16072:         for (end = code + CG_OFFSET(&cg); code != end; code += len) {
16072:             JS_ASSERT(code < end);
16072:             op = (JSOp) *code;
16072:             cs = &js_CodeSpec[op];
17947:             len = (cs->length > 0)
16072:                   ? (uintN) cs->length
16072:                   : js_GetVariableBytecodeLength(code);
32729:             if ((cs->format & JOF_SHARPSLOT) ||
32729:                 JOF_TYPE(cs->format) == JOF_LOCAL ||
16072:                 (JOF_TYPE(cs->format) == JOF_SLOTATOM)) {
16072:                 /*
16429:                  * JSOP_GETARGPROP also has JOF_SLOTATOM type, but it may be
16429:                  * emitted only for a function.
16072:                  */
32729:                 JS_ASSERT_IF(!(cs->format & JOF_SHARPSLOT),
32729:                              (JOF_TYPE(cs->format) == JOF_SLOTATOM) ==
16072:                              (op == JSOP_GETLOCALPROP));
16072:                 slot = GET_SLOTNO(code);
16072:                 slot += scriptGlobals;
32729:                 if (!(cs->format & JOF_SHARPSLOT))
32729:                     slot += cg.sharpSlots();
16072:                 if (slot >= SLOTNO_LIMIT)
16072:                     goto too_many_slots;
16072:                 SET_SLOTNO(code, slot);
16072:             }
16072:         }
16072:     }
16072: 
52555:     if (globalScope.defs.length()) {
52555:         JS_ASSERT(globalObj->scope()->freeslot == globalScope.globalFreeSlot);
52555:         JS_ASSERT(!cg.compilingForEval());
52555:         for (size_t i = 0; i < globalScope.defs.length(); i++) {
52818:             GlobalScope::GlobalDef &def = globalScope.defs[i];
52818:             jsid id = ATOM_TO_JSID(def.atom);
52818:             Value rval;
52818: 
52818:             if (def.funbox) {
52818:                 JSFunction *fun = (JSFunction *)def.funbox->object;
52818: 
52818:                 /* Compile-and-go should have chosen scopeChain as the parent. */
52818:                 JS_ASSERT(fun->getParent() == scopeChain);
52818: 
52818:                 /*
52818:                  * No need to check for redeclarations or anything, global
52818:                  * optimizations only take place if the property is not
52818:                  * defined.
52818:                  */
53023:                 rval.setObject(*fun);
52818:             } else {
52818:                 rval.setUndefined();
52818:             }
52818: 
52555:             JSProperty *prop;
52555: 
52818:             if (!js_DefineNativeProperty(cx, globalObj, id, rval, PropertyStub,
52555:                                          PropertyStub, JSPROP_ENUMERATE | JSPROP_PERMANENT,
52555:                                          0, 0, &prop)) {
52555:                 goto out;
52555:             }
52555: 
52555:             JS_ASSERT(prop);
52555:             JS_ASSERT(((JSScopeProperty*)prop)->slot == globalScope.globalFreeSlot + i);
52802: 
52802:             globalObj->dropProperty(cx, prop);
52555:         }
52555:     }
52555: 
    1: #ifdef METER_PARSENODES
    1:     printf("Parser growth: %d (%u nodes, %u max, %u unrecycled)\n",
    1:            (char *)sbrk(0) - (char *)before,
    1:            parsenodes,
    1:            maxparsenodes,
    1:            parsenodes - recyclednodes);
    1:     before = sbrk(0);
    1: #endif
    1: 
    1:     /*
    1:      * Nowadays the threaded interpreter needs a stop instruction, so we
    1:      * do have to emit that here.
    1:      */
27012:     if (js_Emit1(cx, &cg, JSOP_STOP) < 0)
 6561:         goto out;
    1: #ifdef METER_PARSENODES
    1:     printf("Code-gen growth: %d (%u bytecodes, %u srcnotes)\n",
27012:            (char *)sbrk(0) - (char *)before, CG_OFFSET(&cg), cg.noteCount);
    1: #endif
47609: #ifdef JS_ARENAMETER
47609:     JS_DumpArenaStats(stdout);
    1: #endif
 8444:     script = js_NewScriptFromCG(cx, &cg);
39920:     if (script && funbox && script != script->emptyScript())
33750:         script->savedCallerFun = true;
 6561: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     if (script) {
18955:         JSObject *obj = scopeChain;
10217:         uintN depth = 1;
39930:         while ((obj = obj->getParent()) != NULL)
10217:             ++depth;
10217:         JS_BASIC_STATS_ACCUM(&cx->runtime->hostenvScopeDepthStats, depth);
10217:     }
10217: #endif
10217: 
 6561:   out:
47609:     JS_FinishArenaPool(&codePool);
47609:     JS_FinishArenaPool(&notePool);
 6561:     return script;
16072: 
16072:   too_many_slots:
42671:     parser.reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_LOCALS);
16072:     script = NULL;
16072:     goto out;
    1: }
    1: 
    1: /*
    1:  * Insist on a final return before control flows out of pn.  Try to be a bit
    1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
    1:  * that contains an early return e1 will get a strict warning.  Similarly for
    1:  * iloops: while (true){...} is treated as though ... returns.
    1:  */
    1: #define ENDS_IN_OTHER   0
    1: #define ENDS_IN_RETURN  1
    1: #define ENDS_IN_BREAK   2
    1: 
    1: static int
    1: HasFinalReturn(JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     uintN rv, rv2, hasDefault;
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_LC:
    1:         if (!pn->pn_head)
    1:             return ENDS_IN_OTHER;
27012:         return HasFinalReturn(pn->last());
    1: 
    1:       case TOK_IF:
    1:         if (!pn->pn_kid3)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_WHILE:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_type == TOK_PRIMARY && pn2->pn_op == JSOP_TRUE)
    1:             return ENDS_IN_RETURN;
    1:         if (pn2->pn_type == TOK_NUMBER && pn2->pn_dval)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_DO:
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_PRIMARY) {
    1:             if (pn2->pn_op == JSOP_FALSE)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             if (pn2->pn_op == JSOP_TRUE)
    1:                 return ENDS_IN_RETURN;
    1:         }
    1:         if (pn2->pn_type == TOK_NUMBER) {
    1:             if (pn2->pn_dval == 0)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             return ENDS_IN_RETURN;
    1:         }
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_FOR:
    1:         pn2 = pn->pn_left;
    1:         if (pn2->pn_arity == PN_TERNARY && !pn2->pn_kid2)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
    1:       case TOK_SWITCH:
    1:         rv = ENDS_IN_RETURN;
    1:         hasDefault = ENDS_IN_OTHER;
    1:         pn2 = pn->pn_right;
    1:         if (pn2->pn_type == TOK_LEXICALSCOPE)
27012:             pn2 = pn2->expr();
    1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
    1:             if (pn2->pn_type == TOK_DEFAULT)
    1:                 hasDefault = ENDS_IN_RETURN;
    1:             pn3 = pn2->pn_right;
    1:             JS_ASSERT(pn3->pn_type == TOK_LC);
    1:             if (pn3->pn_head) {
27012:                 rv2 = HasFinalReturn(pn3->last());
    1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
    1:                     /* Falling through to next case or default. */;
    1:                 else
    1:                     rv &= rv2;
    1:             }
    1:         }
    1:         /* If a final switch has no default case, we judge it harshly. */
    1:         rv &= hasDefault;
    1:         return rv;
    1: 
    1:       case TOK_BREAK:
    1:         return ENDS_IN_BREAK;
    1: 
    1:       case TOK_WITH:
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       case TOK_RETURN:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_COLON:
    1:       case TOK_LEXICALSCOPE:
27012:         return HasFinalReturn(pn->expr());
    1: 
    1:       case TOK_THROW:
    1:         return ENDS_IN_RETURN;
    1: 
    1:       case TOK_TRY:
    1:         /* If we have a finally block that returns, we are done. */
    1:         if (pn->pn_kid3) {
    1:             rv = HasFinalReturn(pn->pn_kid3);
    1:             if (rv == ENDS_IN_RETURN)
    1:                 return rv;
    1:         }
    1: 
    1:         /* Else check the try block and any and all catch statements. */
    1:         rv = HasFinalReturn(pn->pn_kid1);
    1:         if (pn->pn_kid2) {
    1:             JS_ASSERT(pn->pn_kid2->pn_arity == PN_LIST);
    1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
    1:                 rv &= HasFinalReturn(pn2);
    1:         }
    1:         return rv;
    1: 
    1:       case TOK_CATCH:
    1:         /* Check this catch block's body. */
    1:         return HasFinalReturn(pn->pn_kid3);
    1: 
    1:       case TOK_LET:
    1:         /* Non-binary let statements are let declarations. */
    1:         if (pn->pn_arity != PN_BINARY)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       default:
    1:         return ENDS_IN_OTHER;
    1:     }
    1: }
    1: 
    1: static JSBool
 8444: ReportBadReturn(JSContext *cx, JSTreeContext *tc, uintN flags, uintN errnum,
    1:                 uintN anonerrnum)
    1: {
    1:     const char *name;
    1: 
41884:     JS_ASSERT(tc->inFunction());
27012:     if (tc->fun->atom) {
27012:         name = js_AtomToPrintableString(cx, tc->fun->atom);
    1:     } else {
    1:         errnum = anonerrnum;
    1:         name = NULL;
    1:     }
40860:     return ReportCompileErrorNumber(cx, TS(tc->parser), NULL, flags, errnum, name);
    1: }
    1: 
    1: static JSBool
 8444: CheckFinalReturn(JSContext *cx, JSTreeContext *tc, JSParseNode *pn)
    1: {
41884:     JS_ASSERT(tc->inFunction());
    1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
 8444:            ReportBadReturn(cx, tc, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
    1: }
    1: 
35323: /*
35324:  * Check that it is permitted to assign to lhs.  Strict mode code may not
35324:  * assign to 'eval' or 'arguments'.
35324:  */
35324: bool
35324: CheckStrictAssignment(JSContext *cx, JSTreeContext *tc, JSParseNode *lhs)
35324: {
51097:     if (tc->needStrictChecks() && lhs->pn_type == TOK_NAME) {
35324:         JSAtom *atom = lhs->pn_atom;
35324:         JSAtomState *atomState = &cx->runtime->atomState;
35324:         if (atom == atomState->evalAtom || atom == atomState->argumentsAtom) {
35324:             const char *name = js_AtomToPrintableString(cx, atom);
35324:             if (!name ||
40860:                 !ReportStrictModeError(cx, TS(tc->parser), tc, lhs, JSMSG_DEPRECATED_ASSIGN,
40320:                                        name)) {
35324:                 return false;
35324:             }
35324:         }
35324:     }
35324:     return true;
35324: }
35324: 
35324: /*
35325:  * Check that it is permitted to introduce a binding for atom.  Strict
35325:  * mode forbids introducing new definitions for 'eval' or 'arguments'.
35325:  * Use pn for reporting error locations, or use tc's token stream if
35325:  * pn is NULL.
35325:  */
35325: bool
40232: CheckStrictBinding(JSContext *cx, JSTreeContext *tc, JSAtom *atom, JSParseNode *pn)
35325: {
35325:     if (!tc->needStrictChecks())
35325:         return true;
35325: 
35325:     JSAtomState *atomState = &cx->runtime->atomState;
35325:     if (atom == atomState->evalAtom || atom == atomState->argumentsAtom) {
35325:         const char *name = js_AtomToPrintableString(cx, atom);
51061:         if (!name)
35325:             return false;
51061:         return ReportStrictModeError(cx, TS(tc->parser), tc, pn, JSMSG_BAD_BINDING, name);
35325:     }
35325:     return true;
35325: }
35325: 
35325: /*
35323:  * In strict mode code, all formal parameter names must be distinct. If fun's
35323:  * formals are legit given fun's strictness level, return true. Otherwise,
35323:  * report an error and return false. Use pn for error position reporting,
35323:  * unless we can find something more accurate in tc's decls.
35323:  *
35323:  * In some cases the code to parse the argument list will already have noticed
35323:  * the duplication; we could try to use that knowledge instead of re-checking
35323:  * here. But since the strictness of the function's body determines what
35323:  * constraints to apply to the argument list, we can't report the error until
35323:  * after we've parsed the body. And as it turns out, the function's local name
35323:  * list makes it reasonably cheap to find duplicates after the fact.
35323:  */
35323: static bool
35323: CheckStrictFormals(JSContext *cx, JSTreeContext *tc, JSFunction *fun,
35323:                    JSParseNode *pn)
35323: {
35325:     JSAtom *atom;
35325: 
35323:     if (!tc->needStrictChecks())
35323:         return true;
35323: 
35458:     atom = fun->findDuplicateFormal();
35325:     if (atom) {
35325:         /*
35325:          * We have found a duplicate parameter name. If we can find the
35325:          * JSDefinition for the argument, that will have a more accurate source
35325:          * location.
35325:          */
35325:         JSDefinition *dn = ALE_DEFN(tc->decls.lookup(atom));
35323:         if (dn->pn_op == JSOP_GETARG)
35323:             pn = dn;
35325:         const char *name = js_AtomToPrintableString(cx, atom);
35323:         if (!name ||
40860:             !ReportStrictModeError(cx, TS(tc->parser), tc, pn, JSMSG_DUPLICATE_FORMAL, name)) {
35323:             return false;
35323:         }
35325:     }
35325: 
35325:     if (tc->flags & (TCF_FUN_PARAM_ARGUMENTS | TCF_FUN_PARAM_EVAL)) {
35325:         JSAtomState *atoms = &cx->runtime->atomState;
35325:         atom = (tc->flags & TCF_FUN_PARAM_ARGUMENTS
35325:                 ? atoms->argumentsAtom : atoms->evalAtom);
35325:         /* The definition's source position will be more precise. */
35325:         JSDefinition *dn = ALE_DEFN(tc->decls.lookup(atom));
35325:         JS_ASSERT(dn->pn_atom == atom);
35325:         const char *name = js_AtomToPrintableString(cx, atom);
35325:         if (!name ||
40860:             !ReportStrictModeError(cx, TS(tc->parser), tc, dn, JSMSG_BAD_BINDING, name)) {
35325:             return false;
35325:         }
35325:     }
35323: 
35323:     return true;
35323: }
35323: 
40239: JSParseNode *
40860: Parser::functionBody()
    1: {
    1:     JSStmtInfo stmtInfo;
    1:     uintN oldflags, firstLine;
    1:     JSParseNode *pn;
    1: 
41884:     JS_ASSERT(tc->inFunction());
    1:     js_PushStatement(tc, &stmtInfo, STMT_BLOCK, -1);
    1:     stmtInfo.flags = SIF_BODY_BLOCK;
    1: 
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~(TCF_RETURN_EXPR | TCF_RETURN_VOID);
    1: 
    1:     /*
    1:      * Save the body's first line, and store it in pn->pn_pos.begin.lineno
40239:      * later, because we may have not peeked in tokenStream yet, so statements
40239:      * won't acquire a valid pn->pn_pos.begin from the current token.
40239:      */
40270:     firstLine = tokenStream.getLineno();
 1967: #if JS_HAS_EXPR_CLOSURES
40270:     if (tokenStream.currentToken().type == TOK_LC) {
40263:         pn = statements();
 1967:     } else {
40232:         pn = UnaryNode::create(tc);
 1967:         if (pn) {
40263:             pn->pn_kid = assignExpr();
 1967:             if (!pn->pn_kid) {
 1967:                 pn = NULL;
 1967:             } else {
 1967:                 if (tc->flags & TCF_FUN_IS_GENERATOR) {
40239:                     ReportBadReturn(context, tc, JSREPORT_ERROR,
 1967:                                     JSMSG_BAD_GENERATOR_RETURN,
 1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
 1967:                     pn = NULL;
 1967:                 } else {
 1967:                     pn->pn_type = TOK_RETURN;
 1967:                     pn->pn_op = JSOP_RETURN;
 1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
 1967:                 }
 1967:             }
 1967:         }
 1967:     }
 1967: #else
40263:     pn = statements();
 1967: #endif
    1: 
10299:     if (pn) {
27012:         JS_ASSERT(!(tc->topStmt->flags & SIF_SCOPE));
    1:         js_PopStatement(tc);
10299:         pn->pn_pos.begin.lineno = firstLine;
    1: 
    1:         /* Check for falling off the end of a function that returns a value. */
40239:         if (JS_HAS_STRICT_OPTION(context) && (tc->flags & TCF_RETURN_EXPR) &&
40239:             !CheckFinalReturn(context, tc, pn)) {
    1:             pn = NULL;
    1:         }
10299:     }
 8444: 
26827:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
27012: static JSAtomListElement *
27012: MakePlaceholder(JSParseNode *pn, JSTreeContext *tc)
27012: {
40860:     JSAtomListElement *ale = tc->lexdeps.add(tc->parser, pn->pn_atom);
27012:     if (!ale)
27012:         return NULL;
27012: 
40232:     JSDefinition *dn = (JSDefinition *)NameNode::create(pn->pn_atom, tc);
27012:     if (!dn)
27012:         return NULL;
27012: 
27012:     ALE_SET_DEFN(ale, dn);
27012:     dn->pn_defn = true;
28557:     dn->pn_dflags |= PND_PLACEHOLDER;
27012:     return ale;
27012: }
27012: 
27012: static bool
27012: Define(JSParseNode *pn, JSAtom *atom, JSTreeContext *tc, bool let = false)
27012: {
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT_IF(pn->pn_defn, pn->isPlaceholder());
27012: 
27012:     JSHashEntry **hep;
27012:     JSAtomListElement *ale = NULL;
27012:     JSAtomList *list = NULL;
27012: 
27012:     if (let)
27012:         ale = (list = &tc->decls)->rawLookup(atom, hep);
27012:     if (!ale)
27012:         ale = (list = &tc->lexdeps)->rawLookup(atom, hep);
27012: 
27012:     if (ale) {
27012:         JSDefinition *dn = ALE_DEFN(ale);
27012:         if (dn != pn) {
27012:             JSParseNode **pnup = &dn->dn_uses;
27012:             JSParseNode *pnu;
27012:             uintN start = let ? pn->pn_blockid : tc->bodyid;
27012: 
27012:             while ((pnu = *pnup) != NULL && pnu->pn_blockid >= start) {
27012:                 JS_ASSERT(pnu->pn_used);
27012:                 pnu->pn_lexdef = (JSDefinition *) pn;
30457:                 pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
27012:                 pnup = &pnu->pn_link;
27012:             }
27012: 
27012:             if (pnu != dn->dn_uses) {
27012:                 *pnup = pn->dn_uses;
27012:                 pn->dn_uses = dn->dn_uses;
27012:                 dn->dn_uses = pnu;
27012: 
27371:                 if ((!pnu || pnu->pn_blockid < tc->bodyid) && list != &tc->decls)
40860:                     list->rawRemove(tc->parser, ale, hep);
40860:             }
40860:         }
40860:     }
40860: 
40860:     ale = tc->decls.add(tc->parser, atom, let ? JSAtomList::SHADOW : JSAtomList::UNIQUE);
27012:     if (!ale)
27012:         return false;
27012:     ALE_SET_DEFN(ale, pn);
27012:     pn->pn_defn = true;
27012:     pn->pn_dflags &= ~PND_PLACEHOLDER;
27012:     return true;
27012: }
27012: 
27012: static void
27012: LinkUseToDef(JSParseNode *pn, JSDefinition *dn, JSTreeContext *tc)
27012: {
27012:     JS_ASSERT(!pn->pn_used);
27012:     JS_ASSERT(!pn->pn_defn);
27012:     JS_ASSERT(pn != dn->dn_uses);
27012:     pn->pn_link = dn->dn_uses;
27012:     dn->dn_uses = pn;
33115:     dn->pn_dflags |= pn->pn_dflags & PND_USE2DEF_FLAGS;
27012:     pn->pn_used = true;
27012:     pn->pn_lexdef = dn;
27012: }
27012: 
27012: static void
27012: ForgetUse(JSParseNode *pn)
27012: {
27012:     if (!pn->pn_used) {
27012:         JS_ASSERT(!pn->pn_defn);
27012:         return;
27012:     }
27012: 
27012:     JSParseNode **pnup = &pn->lexdef()->dn_uses;
27012:     JSParseNode *pnu;
27012:     while ((pnu = *pnup) != pn)
27012:         pnup = &pnu->pn_link;
27012:     *pnup = pn->pn_link;
27012:     pn->pn_used = false;
27012: }
27012: 
27012: static JSParseNode *
27012: MakeAssignment(JSParseNode *pn, JSParseNode *rhs, JSTreeContext *tc)
27012: {
27012:     JSParseNode *lhs = NewOrRecycledNode(tc);
27012:     if (!lhs)
27012:         return NULL;
27012:     *lhs = *pn;
27012: 
27012:     if (pn->pn_used) {
27012:         JSDefinition *dn = pn->pn_lexdef;
27012:         JSParseNode **pnup = &dn->dn_uses;
27012: 
27012:         while (*pnup != pn)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = lhs;
27012:         lhs->pn_link = pn->pn_link;
27012:         pn->pn_link = NULL;
27012:     }
27012: 
27012:     pn->pn_type = TOK_ASSIGN;
27012:     pn->pn_op = JSOP_NOP;
27012:     pn->pn_arity = PN_BINARY;
31479:     pn->pn_parens = false;
27012:     pn->pn_used = pn->pn_defn = false;
27012:     pn->pn_left = lhs;
27012:     pn->pn_right = rhs;
27012:     return lhs;
27012: }
27012: 
27012: static JSParseNode *
27012: MakeDefIntoUse(JSDefinition *dn, JSParseNode *pn, JSAtom *atom, JSTreeContext *tc)
27012: {
27012:     /*
27012:      * If dn is var, const, or let, and it has an initializer, then we must
27012:      * rewrite it to be an assignment node, whose freshly allocated left-hand
27012:      * side becomes a use of pn.
27012:      */
27012:     if (dn->isBindingForm()) {
27012:         JSParseNode *rhs = dn->expr();
27012:         if (rhs) {
27012:             JSParseNode *lhs = MakeAssignment(dn, rhs, tc);
27012:             if (!lhs)
27012:                 return NULL;
27012:             //pn->dn_uses = lhs;
27012:             dn = (JSDefinition *) lhs;
27012:         }
27012: 
27012:         dn->pn_op = (js_CodeSpec[dn->pn_op].format & JOF_SET) ? JSOP_SETNAME : JSOP_NAME;
27012:     } else if (dn->kind() == JSDefinition::FUNCTION) {
27012:         JS_ASSERT(dn->isTopLevel());
27012:         JS_ASSERT(dn->pn_op == JSOP_NOP);
27012:         dn->pn_type = TOK_NAME;
27012:         dn->pn_arity = PN_NAME;
27012:         dn->pn_atom = atom;
27012:     }
27012: 
27012:     /* Now make dn no longer a definition, rather a use of pn. */
27012:     JS_ASSERT(dn->pn_type == TOK_NAME);
27012:     JS_ASSERT(dn->pn_arity == PN_NAME);
27012:     JS_ASSERT(dn->pn_atom == atom);
27012: 
27012:     for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:         JS_ASSERT(pnu->pn_used);
27012:         JS_ASSERT(!pnu->pn_defn);
27012:         pnu->pn_lexdef = (JSDefinition *) pn;
30457:         pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
30457:     }
30457:     pn->pn_dflags |= dn->pn_dflags & PND_USE2DEF_FLAGS;
27012:     pn->dn_uses = dn;
27012: 
27012:     dn->pn_defn = false;
27012:     dn->pn_used = true;
27012:     dn->pn_lexdef = (JSDefinition *) pn;
47573:     dn->pn_cookie.makeFree();
27012:     dn->pn_dflags &= ~PND_BOUND;
27012:     return dn;
27012: }
27012: 
27012: static bool
27012: DefineArg(JSParseNode *pn, JSAtom *atom, uintN i, JSTreeContext *tc)
27012: {
27012:     JSParseNode *argpn, *argsbody;
27012: 
27012:     /* Flag tc so we don't have to lookup arguments on every use. */
40860:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
27012:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
40860:     if (atom == tc->parser->context->runtime->atomState.evalAtom)
35325:         tc->flags |= TCF_FUN_PARAM_EVAL;
27012: 
27012:     /*
27012:      * Make an argument definition node, distinguished by being in tc->decls
27012:      * but having TOK_NAME type and JSOP_NOP op. Insert it in a TOK_ARGSBODY
27012:      * list node returned via pn->pn_body.
27012:      */
40232:     argpn = NameNode::create(atom, tc);
27012:     if (!argpn)
27012:         return false;
27012:     JS_ASSERT(PN_TYPE(argpn) == TOK_NAME && PN_OP(argpn) == JSOP_NOP);
27012: 
27012:     /* Arguments are initialized by definition. */
27012:     argpn->pn_dflags |= PND_INITIALIZED;
27012:     if (!Define(argpn, atom, tc))
27012:         return false;
27012: 
27012:     argsbody = pn->pn_body;
27012:     if (!argsbody) {
40232:         argsbody = ListNode::create(tc);
27012:         if (!argsbody)
27012:             return false;
27012:         argsbody->pn_type = TOK_ARGSBODY;
27012:         argsbody->pn_op = JSOP_NOP;
27012:         argsbody->makeEmpty();
27012:         pn->pn_body = argsbody;
27012:     }
27012:     argsbody->append(argpn);
27012: 
27012:     argpn->pn_op = JSOP_GETARG;
47573:     argpn->pn_cookie.set(tc->staticLevel, i);
27012:     argpn->pn_dflags |= PND_BOUND;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Compile a JS function body, which might appear as the value of an event
    1:  * handler attribute in an HTML <INPUT> tag.
    1:  */
27012: bool
40860: Compiler::compileFunctionBody(JSContext *cx, JSFunction *fun, JSPrincipals *principals,
 8444:                               const jschar *chars, size_t length,
 8444:                               const char *filename, uintN lineno)
    1: {
40860:     Compiler compiler(cx, principals);
40860: 
40860:     if (!compiler.init(chars, length, NULL, filename, lineno))
27012:         return false;
27012: 
27012:     /* No early return from after here until the js_FinishArenaPool calls. */
    1:     JSArenaPool codePool, notePool;
47609:     JS_InitArenaPool(&codePool, "code", 1024, sizeof(jsbytecode),
47609:                      &cx->scriptStackQuota);
47609:     JS_InitArenaPool(&notePool, "note", 1024, sizeof(jssrcnote),
47609:                      &cx->scriptStackQuota);
27012: 
40860:     Parser &parser = compiler.parser;
40860:     TokenStream &tokenStream = parser.tokenStream;
40860: 
40860:     JSCodeGenerator funcg(&parser, &codePool, &notePool, tokenStream.getLineno());
41868:     if (!funcg.init())
41868:         return NULL;
41868: 
27012:     funcg.flags |= TCF_IN_FUNCTION;
27012:     funcg.fun = fun;
27012:     if (!GenerateBlockId(&funcg, funcg.bodyid))
27012:         return NULL;
27012: 
27012:     /* FIXME: make Function format the source for a function definition. */
40860:     tokenStream.mungeCurrentToken(TOK_NAME);
40232:     JSParseNode *fn = FunctionNode::create(&funcg);
27012:     if (fn) {
27012:         fn->pn_body = NULL;
47573:         fn->pn_cookie.makeFree();
27012: 
27012:         uintN nargs = fun->nargs;
27012:         if (nargs) {
27012:             jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
27012:             if (!names) {
27012:                 fn = NULL;
27012:             } else {
27012:                 for (uintN i = 0; i < nargs; i++) {
27012:                     JSAtom *name = JS_LOCAL_NAME_TO_ATOM(names[i]);
27012:                     if (!DefineArg(fn, name, i, &funcg)) {
27012:                         fn = NULL;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012:         }
27012:     }
    1: 
    1:     /*
    1:      * Farble the body so that it looks like a block statement to js_EmitTree,
27012:      * which is called from js_EmitFunctionBody (see jsemit.cpp).  After we're
27012:      * done parsing, we must fold constants, analyze any nested functions, and
27012:      * generate code for this function, including a stop opcode at the end.
27012:      */
40860:     tokenStream.mungeCurrentToken(TOK_LC);
40860:     JSParseNode *pn = fn ? parser.functionBody() : NULL;
    1:     if (pn) {
35323:         if (!CheckStrictFormals(cx, &funcg, fun, pn)) {
35323:             pn = NULL;
40860:         } else if (!tokenStream.matchToken(TOK_EOF)) {
42671:             parser.reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
27012:         } else if (!js_FoldConstants(cx, pn, &funcg)) {
27012:             /* js_FoldConstants reported the error already. */
27012:             pn = NULL;
27012:         } else if (funcg.functionList &&
40860:                    !parser.analyzeFunctions(funcg.functionList, funcg.flags)) {
27012:             pn = NULL;
26970:         } else {
27012:             if (fn->pn_body) {
27012:                 JS_ASSERT(PN_TYPE(fn->pn_body) == TOK_ARGSBODY);
27012:                 fn->pn_body->append(pn);
28816:                 fn->pn_body->pn_pos = pn->pn_pos;
27012:                 pn = fn->pn_body;
27012:             }
27012: 
27012:             if (!js_EmitFunctionScript(cx, &funcg, pn))
26968:                 pn = NULL;
26970:         }
    1:     }
    1: 
    1:     /* Restore saved state and release code generation arenas. */
47609:     JS_FinishArenaPool(&codePool);
47609:     JS_FinishArenaPool(&notePool);
    1:     return pn != NULL;
    1: }
    1: 
    1: /*
    1:  * Parameter block types for the several Binder functions.  We use a common
    1:  * helper function signature in order to share code among destructuring and
    1:  * simple variable declaration parsers.  In the destructuring case, the binder
    1:  * function is called indirectly from the variable declaration parser by way
    1:  * of CheckDestructuring and its friends.
    1:  */
    1: typedef JSBool
    1: (*Binder)(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc);
    1: 
    1: struct BindData {
29379:     BindData() : fresh(true) {}
29379: 
27012:     JSParseNode     *pn;        /* name node for definition processing and
27012:                                    error source coordinates */
    1:     JSOp            op;         /* prolog bytecode or nop */
    1:     Binder          binder;     /* binder, discriminates u */
    1:     union {
    1:         struct {
    1:             uintN   overflow;
    1:         } let;
27012:     };
29379:     bool fresh;
    1: };
    1: 
    1: static JSBool
13702: BindLocalVariable(JSContext *cx, JSFunction *fun, JSAtom *atom,
35332:                   JSLocalKind localKind, bool isArg)
    1: {
 8444:     JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
    1: 
    1:     /*
    1:      * Don't bind a variable with the hidden name 'arguments', per ECMA-262.
    1:      * Instead 'var arguments' always restates the predefined property of the
27012:      * activation objects whose name is 'arguments'. Assignment to such a
27012:      * variable must be handled specially.
35332:      *
35332:      * Special case: an argument named 'arguments' *does* shadow the predefined
35332:      * arguments property.
35332:      */
35332:     if (atom == cx->runtime->atomState.argumentsAtom && !isArg)
    1:         return JS_TRUE;
    1: 
 8444:     return js_AddLocal(cx, fun, atom, localKind);
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: static JSBool
    1: BindDestructuringArg(JSContext *cx, BindData *data, JSAtom *atom,
    1:                      JSTreeContext *tc)
    1: {
27012:     JSParseNode *pn;
    1: 
29009:     /* Flag tc so we don't have to lookup arguments on every use. */
40860:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
29009:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
40860:     if (atom == tc->parser->context->runtime->atomState.evalAtom)
35325:         tc->flags |= TCF_FUN_PARAM_EVAL;
29009: 
41884:     JS_ASSERT(tc->inFunction());
27012: 
27012:     JSLocalKind localKind = js_LookupLocal(cx, tc->fun, atom, NULL);
27012:     if (localKind != JSLOCAL_NONE) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), NULL, JSREPORT_ERROR,
40320:                                  JSMSG_DESTRUCT_DUP_ARG);
    1:         return JS_FALSE;
    1:     }
35376:     JS_ASSERT(!tc->decls.lookup(atom));
35376: 
35376:     pn = data->pn;
35376:     if (!Define(pn, atom, tc))
35376:         return JS_FALSE;
27012: 
27012:     uintN index = tc->fun->u.i.nvars;
35332:     if (!BindLocalVariable(cx, tc->fun, atom, JSLOCAL_VAR, true))
27012:         return JS_FALSE;
27012:     pn->pn_op = JSOP_SETLOCAL;
47573:     pn->pn_cookie.set(tc->staticLevel, index);
27012:     pn->pn_dflags |= PND_BOUND;
27012:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
27012: JSFunction *
40860: Parser::newFunction(JSTreeContext *tc, JSAtom *atom, uintN lambda)
 8444: {
 8444:     JSObject *parent;
13702:     JSFunction *fun;
 9481: 
 9481:     JS_ASSERT((lambda & ~JSFUN_LAMBDA) == 0);
27012: 
27012:     /*
27012:      * Find the global compilation context in order to pre-set the newborn
27012:      * function's parent slot to tc->scopeChain. If the global context is a
27012:      * compile-and-go one, we leave the pre-set parent intact; otherwise we
27012:      * clear parent and proto.
27012:      */
27012:     while (tc->parent)
27012:         tc = tc->parent;
41884:     parent = tc->inFunction() ? NULL : tc->scopeChain;
27012: 
27012:     fun = js_NewFunction(context, NULL, NULL, 0, JSFUN_INTERPRETED | lambda,
13702:                          parent, atom);
27012: 
41884:     if (fun && !tc->compileAndGo()) {
39930:         FUN_OBJECT(fun)->clearParent();
39928:         FUN_OBJECT(fun)->clearProto();
13691:     }
13691:     return fun;
 8444: }
 8444: 
25110: static JSBool
40320: MatchOrInsertSemicolon(JSContext *cx, TokenStream *ts)
40320: {
40854:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
25110:     if (tt == TOK_ERROR)
25110:         return JS_FALSE;
25110:     if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
40320:         ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, JSMSG_SEMI_BEFORE_STMNT);
25110:         return JS_FALSE;
25110:     }
40354:     (void) ts->matchToken(TOK_SEMI);
25110:     return JS_TRUE;
25110: }
25110: 
27012: bool
40860: Parser::analyzeFunctions(JSFunctionBox *funbox, uint32& tcflags)
27012: {
27012:     if (!markFunArgs(funbox, tcflags))
27012:         return false;
27012:     setFunctionKinds(funbox, tcflags);
27012:     return true;
27012: }
27012: 
27012: /*
27012:  * Mark as funargs any functions that reach up to one or more upvars across an
27012:  * already-known funarg. The parser will flag the o_m lambda as a funarg in:
27012:  *
27012:  *   function f(o, p) {
27012:  *       o.m = function o_m(a) {
27012:  *           function g() { return p; }
27012:  *           function h() { return a; }
27012:  *           return g() + h();
27012:  *       }
27012:  *   }
27012:  *
27012:  * but without this extra marking phase, function g will not be marked as a
27012:  * funarg since it is called from within its parent scope. But g reaches up to
27012:  * f's parameter p, so if o_m escapes f's activation scope, g does too and
27012:  * cannot use JSOP_GETUPVAR to reach p. In contast function h neither escapes
27012:  * nor uses an upvar "above" o_m's level.
27012:  *
27012:  * If function g itself contained lambdas that contained non-lambdas that reach
27012:  * up above its level, then those non-lambdas would have to be marked too. This
27012:  * process is potentially exponential in the number of functions, but generally
27012:  * not so complex. But it can't be done during a single recursive traversal of
27012:  * the funbox tree, so we must use a work queue.
28952:  *
28952:  * Return the minimal "skipmin" for funbox and its siblings. This is the delta
28952:  * between the static level of the bodies of funbox and its peers (which must
28952:  * be funbox->level + 1), and the static level of the nearest upvar among all
28952:  * the upvars contained by funbox and its peers. If there are no upvars, return
28952:  * FREE_STATIC_LEVEL. Thus this function never returns 0.
28952:  */
28952: static uintN
27012: FindFunArgs(JSFunctionBox *funbox, int level, JSFunctionBoxQueue *queue)
27012: {
47573:     uintN allskipmin = UpvarCookie::FREE_LEVEL;
28952: 
27012:     do {
27012:         JSParseNode *fn = funbox->node;
28952:         JSFunction *fun = (JSFunction *) funbox->object;
27012:         int fnlevel = level;
27012: 
27109:         /*
27109:          * An eval can leak funbox, functions along its ancestor line, and its
27109:          * immediate kids. Since FindFunArgs uses DFS and the parser propagates
27109:          * TCF_FUN_HEAVYWEIGHT bottom up, funbox's ancestor function nodes have
27109:          * already been marked as funargs by this point. Therefore we have to
27109:          * flag only funbox->node and funbox->kids' nodes here.
27109:          */
27109:         if (funbox->tcflags & TCF_FUN_HEAVYWEIGHT) {
27111:             fn->setFunArg();
27109:             for (JSFunctionBox *kid = funbox->kids; kid; kid = kid->siblings)
27111:                 kid->node->setFunArg();
27109:         }
27109: 
28952:         /*
28952:          * Compute in skipmin the least distance from fun's static level up to
28952:          * an upvar, whether used directly by fun, or indirectly by a function
28952:          * nested in fun.
28952:          */
47573:         uintN skipmin = UpvarCookie::FREE_LEVEL;
28952:         JSParseNode *pn = fn->pn_body;
28952: 
28952:         if (pn->pn_type == TOK_UPVARS) {
28952:             JSAtomList upvars(pn->pn_names);
28952:             JS_ASSERT(upvars.count != 0);
28952: 
28952:             JSAtomListIterator iter(&upvars);
28952:             JSAtomListElement *ale;
28952: 
28952:             while ((ale = iter()) != NULL) {
28952:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
28952: 
28952:                 if (!lexdep->isFreeVar()) {
28952:                     uintN upvarLevel = lexdep->frameLevel();
28952: 
28952:                     if (int(upvarLevel) <= fnlevel)
28952:                         fn->setFunArg();
28952: 
28952:                     uintN skip = (funbox->level + 1) - upvarLevel;
28952:                     if (skip < skipmin)
28952:                         skipmin = skip;
28952:                 }
28952:             }
28952:         }
28952: 
28952:         /*
28952:          * If this function escapes, whether directly (the parser detects such
28952:          * escapes) or indirectly (because this non-escaping function uses an
28952:          * upvar that reaches across an outer function boundary where the outer
28952:          * function escapes), enqueue it for further analysis, and bump fnlevel
28952:          * to trap any non-escaping children.
28952:          */
27012:         if (fn->isFunArg()) {
27012:             queue->push(funbox);
27012:             fnlevel = int(funbox->level);
28952:         }
28952: 
28952:         /*
28952:          * Now process the current function's children, and recalibrate their
28952:          * cumulative skipmin to be relative to the current static level.
28952:          */
28952:         if (funbox->kids) {
28952:             uintN kidskipmin = FindFunArgs(funbox->kids, fnlevel, queue);
28952: 
28952:             JS_ASSERT(kidskipmin != 0);
47573:             if (kidskipmin != UpvarCookie::FREE_LEVEL) {
28952:                 --kidskipmin;
28952:                 if (kidskipmin != 0 && kidskipmin < skipmin)
28952:                     skipmin = kidskipmin;
28952:             }
28952:         }
28952: 
28952:         /*
28952:          * Finally, after we've traversed all of the current function's kids,
28952:          * minimize fun's skipmin against our accumulated skipmin. Do likewise
28952:          * with allskipmin, but minimize across funbox and all of its siblings,
28952:          * to compute our return value.
28952:          */
47573:         if (skipmin != UpvarCookie::FREE_LEVEL) {
28952:             fun->u.i.skipmin = skipmin;
28952:             if (skipmin < allskipmin)
28952:                 allskipmin = skipmin;
28952:         }
27012:     } while ((funbox = funbox->siblings) != NULL);
28952: 
28952:     return allskipmin;
27012: }
27012: 
27012: bool
40860: Parser::markFunArgs(JSFunctionBox *funbox, uintN tcflags)
27012: {
27012:     JSFunctionBoxQueue queue;
27012:     if (!queue.init(functionCount))
27012:         return false;
27012: 
27012:     FindFunArgs(funbox, -1, &queue);
27012:     while ((funbox = queue.pull()) != NULL) {
27012:         JSParseNode *fn = funbox->node;
27012:         JS_ASSERT(fn->isFunArg());
27012: 
27012:         JSParseNode *pn = fn->pn_body;
27012:         if (pn->pn_type == TOK_UPVARS) {
27012:             JSAtomList upvars(pn->pn_names);
27012:             JS_ASSERT(upvars.count != 0);
27012: 
27012:             JSAtomListIterator iter(&upvars);
27012:             JSAtomListElement *ale;
27012: 
27012:             while ((ale = iter()) != NULL) {
27012:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
27012: 
27012:                 if (!lexdep->isFreeVar() &&
27012:                     !lexdep->isFunArg() &&
38597:                     (lexdep->kind() == JSDefinition::FUNCTION ||
38597:                      PN_OP(lexdep) == JSOP_CALLEE)) {
27012:                     /*
28952:                      * Mark this formerly-Algol-like function as an escaping
28952:                      * function (i.e., as a funarg), because it is used from a
28952:                      * funarg and therefore can not use JSOP_{GET,CALL}UPVAR to
28952:                      * access upvars.
27012:                      *
28952:                      * Progress is guaranteed because we set the funarg flag
28952:                      * here, which suppresses revisiting this function (thanks
28952:                      * to the !lexdep->isFunArg() test just above).
27012:                      */
27111:                     lexdep->setFunArg();
27012: 
38597:                     JSFunctionBox *afunbox;
38597:                     if (PN_OP(lexdep) == JSOP_CALLEE) {
38597:                         /*
38597:                          * A named function expression will not appear to be a
38597:                          * funarg if it is immediately applied. However, if its
38597:                          * name is used in an escaping function nested within
38597:                          * it, then it must become flagged as a funarg again.
38597:                          * See bug 545980.
38597:                          */
38597:                         afunbox = funbox;
47573:                         uintN calleeLevel = lexdep->pn_cookie.level();
38597:                         uintN staticLevel = afunbox->level + 1U;
38597:                         while (staticLevel != calleeLevel) {
38597:                             afunbox = afunbox->parent;
38597:                             --staticLevel;
38597:                         }
38597:                         afunbox->node->setFunArg();
38597:                     } else {
38597:                        afunbox = lexdep->pn_funbox;
38597:                     }
27012:                     queue.push(afunbox);
27012: 
27012:                     /*
27012:                      * Walk over nested functions again, now that we have
27012:                      * changed the level across which it is unsafe to access
27012:                      * upvars using the runtime dynamic link (frame chain).
27012:                      */
27012:                     if (afunbox->kids)
27012:                         FindFunArgs(afunbox->kids, afunbox->level, &queue);
27012:                 }
27012:             }
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
27012: static uint32
27012: MinBlockId(JSParseNode *fn, uint32 id)
27012: {
27012:     if (fn->pn_blockid < id)
27012:         return false;
27012:     if (fn->pn_defn) {
27012:         for (JSParseNode *pn = fn->dn_uses; pn; pn = pn->pn_link) {
27012:             if (pn->pn_blockid < id)
27012:                 return false;
27012:         }
27012:     }
27012:     return true;
27012: }
27012: 
38549: static inline bool
38549: CanFlattenUpvar(JSDefinition *dn, JSFunctionBox *funbox, uint32 tcflags)
38549: {
38549:     /*
38549:      * Consider the current function (the lambda, innermost below) using a var
38549:      * x defined two static levels up:
27012:      *
27012:      *  function f() {
27012:      *      // z = g();
27012:      *      var x = 42;
27012:      *      function g() {
27012:      *          return function () { return x; };
27012:      *      }
27012:      *      return g();
27012:      *  }
27012:      *
38549:      * So long as (1) the initialization in 'var x = 42' dominates all uses of
38549:      * g and (2) x is not reassigned, it is safe to optimize the lambda to a
38549:      * flat closure. Uncommenting the early call to g makes this optimization
38549:      * unsafe (z could name a global setter that calls its argument).
27012:      */
27012:     JSFunctionBox *afunbox = funbox;
38549:     uintN dnLevel = dn->frameLevel();
38549: 
38549:     JS_ASSERT(dnLevel <= funbox->level);
38549:     while (afunbox->level != dnLevel) {
27012:         afunbox = afunbox->parent;
27012: 
27012:         /*
38549:          * NB: afunbox can't be null because we are sure to find a function box
38549:          * whose level == dnLevel before we would try to walk above the root of
38549:          * the funbox tree. See bug 493260 comments 16-18.
38549:          *
38549:          * Assert but check anyway, to protect future changes that bind eval
38549:          * upvars in the parser.
28740:          */
28740:         JS_ASSERT(afunbox);
28740: 
28740:         /*
38549:          * If this function is reaching up across an enclosing funarg, then we
38549:          * cannot copy dn's value into a flat closure slot (the display stops
38549:          * working once the funarg escapes).
28740:          */
28740:         if (!afunbox || afunbox->node->isFunArg())
38549:             return false;
41861: 
41861:         /*
41861:          * Reaching up for dn across a generator also means we can't flatten,
41861:          * since the generator iterator does not run until later, in general.
41861:          * See bug 563034.
41861:          */
41861:         if (afunbox->tcflags & TCF_FUN_IS_GENERATOR)
41861:             return false;
38549:     }
38549: 
38549:     /*
38549:      * If afunbox's function (which is at the same level as dn) is in a loop,
38549:      * pessimistically assume the variable initializer may be in the same loop.
38549:      * A flat closure would then be unsafe, as the captured variable could be
38549:      * assigned after the closure is created. See bug 493232.
28814:      */
28814:     if (afunbox->inLoop)
38549:         return false;
38549: 
38549:     /*
38549:      * |with| and eval used as an operator defeat lexical scoping: they can be
38549:      * used to assign to any in-scope variable. Therefore they must disable
38549:      * flat closures that use such upvars.  The parser detects these as special
38549:      * forms and marks the function heavyweight.
38549:      */
38549:     if ((afunbox->parent ? afunbox->parent->tcflags : tcflags) & TCF_FUN_HEAVYWEIGHT)
38549:         return false;
38549: 
38549:     /*
38549:      * If afunbox's function is not a lambda, it will be hoisted, so it could
38549:      * capture the undefined value that by default initializes var, let, and
38549:      * const bindings. And if dn is a function that comes at (meaning a
38549:      * function refers to its own name) or strictly after afunbox, we also
38549:      * defeat the flat closure optimization for this dn.
27012:      */
27012:     JSFunction *afun = (JSFunction *) afunbox->object;
27012:     if (!(afun->flags & JSFUN_LAMBDA)) {
38549:         if (dn->isBindingForm() || dn->pn_pos >= afunbox->node->pn_pos)
38549:             return false;
38549:     }
38549: 
38549:     if (!dn->isInitialized())
38549:         return false;
38549: 
38549:     JSDefinition::Kind dnKind = dn->kind();
38549:     if (dnKind != JSDefinition::CONST) {
38549:         if (dn->isAssigned())
38549:             return false;
38549: 
38549:         /*
38549:          * Any formal could be mutated behind our back via the arguments
38549:          * object, so deoptimize if the outer function uses arguments.
38549:          *
38549:          * In a Function constructor call where the final argument -- the body
38549:          * source for the function to create -- contains a nested function
38549:          * definition or expression, afunbox->parent will be null. The body
38549:          * source might use |arguments| outside of any nested functions it may
38549:          * contain, so we have to check the tcflags parameter that was passed
40860:          * in from Compiler::compileFunctionBody.
38549:          */
38549:         if (dnKind == JSDefinition::ARG &&
38549:             ((afunbox->parent ? afunbox->parent->tcflags : tcflags) & TCF_FUN_USES_ARGUMENTS)) {
38549:             return false;
38549:         }
38549:     }
38549: 
38549:     /*
38549:      * Check quick-and-dirty dominance relation. Function definitions dominate
38549:      * their uses thanks to hoisting.  Other binding forms hoist as undefined,
38549:      * of course, so check forward-reference and blockid relations.
38549:      */
38549:     if (dnKind != JSDefinition::FUNCTION) {
27012:         /*
27012:          * Watch out for code such as
27012:          *
27012:          *   (function () {
27012:          *   ...
27012:          *   var jQuery = ... = function (...) {
27012:          *       return new jQuery.foo.bar(baz);
27012:          *   }
27012:          *   ...
27012:          *   })();
27012:          *
38549:          * where the jQuery variable is not reassigned, but of course is not
38549:          * initialized at the time that the would-be-flat closure containing
38549:          * the jQuery upvar is formed.
38549:          */
38560:         if (dn->pn_pos.end >= afunbox->node->pn_pos.end)
38549:             return false;
38560:         if (!MinBlockId(afunbox->node, dn->pn_blockid))
38560:             return false;
38549:     }
38549:     return true;
38549: }
38549: 
38549: static void
38549: FlagHeavyweights(JSDefinition *dn, JSFunctionBox *funbox, uint32& tcflags)
38549: {
38549:     uintN dnLevel = dn->frameLevel();
38549: 
41849:     while ((funbox = funbox->parent) != NULL) {
41849:         /*
41849:          * Notice that funbox->level is the static level of the definition or
41849:          * expression of the function parsed into funbox, not the static level
38549:          * of its body. Therefore we must add 1 to match dn's level to find the
41849:          * funbox whose body contains the dn definition.
41849:          */
41849:         if (funbox->level + 1U == dnLevel || (dnLevel == 0 && dn->isLet())) {
41849:             funbox->tcflags |= TCF_FUN_HEAVYWEIGHT;
41849:             break;
41849:         }
41849:         funbox->tcflags |= TCF_FUN_ENTRAINS_SCOPES;
41849:     }
41849: 
41849:     if (!funbox && (tcflags & TCF_IN_FUNCTION))
38549:         tcflags |= TCF_FUN_HEAVYWEIGHT;
38549: }
38549: 
52554: static bool
52554: DeoptimizeUsesWithin(JSDefinition *dn, const TokenPos &pos)
38549: {
38549:     uintN ndeoptimized = 0;
38563: 
38563:     for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
38549:         JS_ASSERT(pnu->pn_used);
38549:         JS_ASSERT(!pnu->pn_defn);
38563:         if (pnu->pn_pos.begin >= pos.begin && pnu->pn_pos.end <= pos.end) {
38549:             pnu->pn_dflags |= PND_DEOPTIMIZED;
38549:             ++ndeoptimized;
38563:         }
38549:     }
38549: 
52554:     return ndeoptimized != 0;
38549: }
38549: 
38549: void
40860: Parser::setFunctionKinds(JSFunctionBox *funbox, uint32& tcflags)
38549: {
48676: #define FUN_METER(x) JS_FUNCTION_METER(context, x)
38549: 
38549:     for (;;) {
38549:         JSParseNode *fn = funbox->node;
38549:         JSParseNode *pn = fn->pn_body;
38549: 
38549:         if (funbox->kids) {
38549:             setFunctionKinds(funbox->kids, tcflags);
38549: 
38549:             /*
38549:              * We've unwound from recursively setting our kids' kinds, which
38549:              * also classifies enclosing functions holding upvars referenced in
38549:              * those descendants' bodies. So now we can check our "methods".
38549:              *
38549:              * Despecialize from branded method-identity-based shape to sprop-
38549:              * or slot-based shape if this function smells like a constructor
38549:              * and too many of its methods are *not* joinable null closures
38549:              * (i.e., they have one or more upvars fetched via the display).
38549:              */
38549:             JSParseNode *pn2 = pn;
38549:             if (PN_TYPE(pn2) == TOK_UPVARS)
38549:                 pn2 = pn2->pn_tree;
38549:             if (PN_TYPE(pn2) == TOK_ARGSBODY)
38549:                 pn2 = pn2->last();
38549: 
38549: #if JS_HAS_EXPR_CLOSURES
38549:             if (PN_TYPE(pn2) == TOK_LC)
38549: #endif
38549:             if (!(funbox->tcflags & TCF_RETURN_EXPR)) {
38549:                 uintN methodSets = 0, slowMethodSets = 0;
38549: 
38549:                 for (JSParseNode *method = funbox->methods; method; method = method->pn_link) {
38549:                     JS_ASSERT(PN_OP(method) == JSOP_LAMBDA || PN_OP(method) == JSOP_LAMBDA_FC);
38549:                     ++methodSets;
38549:                     if (!method->pn_funbox->joinable())
38549:                         ++slowMethodSets;
38549:                 }
38549: 
38549:                 if (funbox->shouldUnbrand(methodSets, slowMethodSets))
38549:                     funbox->tcflags |= TCF_FUN_UNBRAND_THIS;
38549:             }
38549:         }
38549: 
38549:         JSFunction *fun = (JSFunction *) funbox->object;
38549: 
41849:         JS_ASSERT(FUN_KIND(fun) == JSFUN_INTERPRETED);
41849: 
38549:         FUN_METER(allfun);
38549:         if (funbox->tcflags & TCF_FUN_HEAVYWEIGHT) {
38549:             FUN_METER(heavy);
38549:         } else if (pn->pn_type != TOK_UPVARS) {
38549:             /*
38549:              * No lexical dependencies => null closure, for best performance.
38549:              * A null closure needs no scope chain, but alas we've coupled
38549:              * principals-finding to scope (for good fundamental reasons, but
38549:              * the implementation overloads the parent slot and we should fix
38549:              * that). See, e.g., the JSOP_LAMBDA case in jsinterp.cpp.
38549:              *
38549:              * In more detail: the ES3 spec allows the implementation to create
38549:              * "joined function objects", or not, at its discretion. But real-
38549:              * world implementations always create unique function objects for
38549:              * closures, and this can be detected via mutation. Open question:
38549:              * do popular implementations create unique function objects for
38549:              * null closures?
38549:              *
38549:              * FIXME: bug 476950.
38549:              */
38549:             FUN_METER(nofreeupvar);
38549:             FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
38549:         } else {
38549:             JSAtomList upvars(pn->pn_names);
38549:             JS_ASSERT(upvars.count != 0);
38549: 
38549:             JSAtomListIterator iter(&upvars);
38549:             JSAtomListElement *ale;
38549: 
38549:             if (!fn->isFunArg()) {
38549:                 /*
38549:                  * This function is Algol-like, it never escapes. So long as it
38549:                  * does not assign to outer variables, it needs only an upvars
38549:                  * array in its script and JSOP_{GET,CALL}UPVAR opcodes in its
38549:                  * bytecode to reach up the frame stack at runtime based on
38549:                  * those upvars' cookies.
38549:                  *
38549:                  * Any assignments to upvars from functions called by this one
38549:                  * will be coherent because of the JSOP_{GET,CALL}UPVAR ops,
38549:                  * which load from stack homes when interpreting or from native
38549:                  * stack slots when executing a trace.
38549:                  *
38549:                  * We could add JSOP_SETUPVAR, etc., but it is uncommon for a
38549:                  * nested function to assign to an outer lexical variable, so
38549:                  * we defer adding yet more code footprint in the absence of
38549:                  * evidence motivating these opcodes.
38549:                  */
38549:                 bool mutation = !!(funbox->tcflags & TCF_FUN_SETS_OUTER_NAME);
38549:                 uintN nupvars = 0;
38549: 
38549:                 /*
38549:                  * Check that at least one outer lexical binding was assigned
38549:                  * to (global variables don't count). This is conservative: we
38549:                  * could limit assignments to those in the current function,
38549:                  * but that's too much work. As with flat closures (handled
38549:                  * below), we optimize for the case where outer bindings are
38549:                  * not reassigned anywhere.
38549:                  */
38549:                 while ((ale = iter()) != NULL) {
38549:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
38549: 
38549:                     if (!lexdep->isFreeVar()) {
40887:                         JS_ASSERT(lexdep->frameLevel() <= funbox->level);
38549:                         ++nupvars;
38549:                         if (lexdep->isAssigned())
38549:                             break;
38549:                     }
38549:                 }
38549:                 if (!ale)
38549:                     mutation = false;
38549: 
27012:                 if (nupvars == 0) {
27012:                     FUN_METER(onlyfreevar);
27012:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
41849:                 } else if (!mutation &&
41852:                            !(funbox->tcflags & (TCF_FUN_IS_GENERATOR | TCF_FUN_ENTRAINS_SCOPES))) {
38549:                     /*
38549:                      * Algol-like functions can read upvars using the dynamic
38549:                      * link (cx->fp/fp->down), optimized using the cx->display
38549:                      * lookup table indexed by static level. They do not need
38549:                      * to entrain and search their environment objects.
38549:                      */
38549:                     FUN_METER(display);
38549:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
38549:                 } else {
38549:                     if (!(funbox->tcflags & TCF_FUN_IS_GENERATOR))
38549:                         FUN_METER(setupvar);
38549:                 }
38549:             } else {
38549:                 uintN nupvars = 0, nflattened = 0;
38549: 
38549:                 /*
38549:                  * For each lexical dependency from this closure to an outer
38549:                  * binding, analyze whether it is safe to copy the binding's
38549:                  * value into a flat closure slot when the closure is formed.
38549:                  */
38549:                 while ((ale = iter()) != NULL) {
38549:                     JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
38549: 
38549:                     if (!lexdep->isFreeVar()) {
38549:                         ++nupvars;
38549:                         if (CanFlattenUpvar(lexdep, funbox, tcflags)) {
38549:                             ++nflattened;
38549:                             continue;
38549:                         }
52554:                         if (DeoptimizeUsesWithin(lexdep, funbox->node->pn_body->pn_pos))
52554:                             FlagHeavyweights(lexdep, funbox, tcflags);
38549:                     }
38549:                 }
38549: 
38549:                 if (nupvars == 0) {
38549:                     FUN_METER(onlyfreevar);
38549:                     FUN_SET_KIND(fun, JSFUN_NULL_CLOSURE);
39787:                 } else if (nflattened == nupvars) {
39787:                     /* FIXME bug 545759: to test nflattened != 0 */
27012:                     /*
27012:                      * We made it all the way through the upvar loop, so it's
27012:                      * safe to optimize to a flat closure.
27012:                      */
27012:                     FUN_METER(flat);
27012:                     FUN_SET_KIND(fun, JSFUN_FLAT_CLOSURE);
27012:                     switch (PN_OP(fn)) {
27012:                       case JSOP_DEFFUN:
27012:                         fn->pn_op = JSOP_DEFFUN_FC;
27012:                         break;
27012:                       case JSOP_DEFLOCALFUN:
27012:                         fn->pn_op = JSOP_DEFLOCALFUN_FC;
27012:                         break;
27012:                       case JSOP_LAMBDA:
27012:                         fn->pn_op = JSOP_LAMBDA_FC;
27012:                         break;
27012:                       default:
27012:                         /* js_EmitTree's case TOK_FUNCTION: will select op. */
27012:                         JS_ASSERT(PN_OP(fn) == JSOP_NOP);
27012:                     }
27012:                 } else {
27012:                     FUN_METER(badfunarg);
27012:                 }
27012:             }
27012:         }
27012: 
37685:         if (FUN_KIND(fun) == JSFUN_INTERPRETED && pn->pn_type == TOK_UPVARS) {
27012:             /*
27012:              * One or more upvars cannot be safely snapshot into a flat
27012:              * closure's dslot (see JSOP_GETDSLOT), so we loop again over
27012:              * all upvars, and for each non-free upvar, ensure that its
27012:              * containing function has been flagged as heavyweight.
27012:              *
27012:              * The emitter must see TCF_FUN_HEAVYWEIGHT accurately before
27012:              * generating any code for a tree of nested functions.
27012:              */
37685:             JSAtomList upvars(pn->pn_names);
37685:             JS_ASSERT(upvars.count != 0);
37685: 
37685:             JSAtomListIterator iter(&upvars);
37685:             JSAtomListElement *ale;
37685: 
27012:             while ((ale = iter()) != NULL) {
27012:                 JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
38549:                 if (!lexdep->isFreeVar())
38549:                     FlagHeavyweights(lexdep, funbox, tcflags);
27012:             }
27012:         }
27012: 
48676:         if (funbox->joinable())
48676:             fun->setJoinable();
48676: 
27012:         funbox = funbox->siblings;
27012:         if (!funbox)
27012:             break;
37685:     }
37685: 
27012: #undef FUN_METER
27012: }
27012: 
27012: const char js_argument_str[] = "argument";
27012: const char js_variable_str[] = "variable";
27012: const char js_unknown_str[]  = "unknown";
27012: 
27012: const char *
27012: JSDefinition::kindString(Kind kind)
27012: {
27012:     static const char *table[] = {
27012:         js_var_str, js_const_str, js_let_str,
27012:         js_function_str, js_argument_str, js_unknown_str
27012:     };
27012: 
27012:     JS_ASSERT(unsigned(kind) <= unsigned(ARG));
27012:     return table[kind];
27012: }
27012: 
27012: static JSFunctionBox *
40263: EnterFunction(JSParseNode *fn, JSTreeContext *funtc, JSAtom *funAtom = NULL,
40263:               uintN lambda = JSFUN_LAMBDA)
40263: {
40263:     JSTreeContext *tc = funtc->parent;
40860:     JSFunction *fun = tc->parser->newFunction(tc, funAtom, lambda);
27012:     if (!fun)
27012:         return NULL;
27012: 
27012:     /* Create box for fun->object early to protect against last-ditch GC. */
40860:     JSFunctionBox *funbox = tc->parser->newFunctionBox(FUN_OBJECT(fun), fn, tc);
27012:     if (!funbox)
27012:         return NULL;
27012: 
27012:     /* Initialize non-default members of funtc. */
27012:     funtc->flags |= funbox->tcflags;
27012:     funtc->blockidGen = tc->blockidGen;
27012:     if (!GenerateBlockId(funtc, funtc->bodyid))
27012:         return NULL;
27012:     funtc->fun = fun;
27012:     funtc->funbox = funbox;
27012:     if (!SetStaticLevel(funtc, tc->staticLevel + 1))
27012:         return NULL;
27012: 
27012:     return funbox;
27012: }
27012: 
27012: static bool
40263: LeaveFunction(JSParseNode *fn, JSTreeContext *funtc, JSAtom *funAtom = NULL,
40263:               uintN lambda = JSFUN_LAMBDA)
40263: {
40263:     JSTreeContext *tc = funtc->parent;
27012:     tc->blockidGen = funtc->blockidGen;
27012: 
37685:     JSFunctionBox *funbox = fn->pn_funbox;
37685:     funbox->tcflags |= funtc->flags & (TCF_FUN_FLAGS | TCF_COMPILE_N_GO | TCF_RETURN_EXPR);
27012: 
27012:     fn->pn_dflags |= PND_INITIALIZED;
27012:     JS_ASSERT_IF(tc->atTopLevel() && lambda == 0 && funAtom,
27012:                  fn->pn_dflags & PND_TOPLEVEL);
27012:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
27012:         fn->pn_dflags |= PND_BLOCKCHILD;
27012: 
27012:     /*
27012:      * Propagate unresolved lexical names up to tc->lexdeps, and save a copy
27371:      * of funtc->lexdeps in a TOK_UPVARS node wrapping the function's formal
27371:      * params and body. We do this only if there are lexical dependencies not
27371:      * satisfied by the function's declarations, to avoid penalizing functions
27371:      * that use only their arguments and other local bindings.
27012:      */
27012:     if (funtc->lexdeps.count != 0) {
27012:         JSAtomListIterator iter(&funtc->lexdeps);
27012:         JSAtomListElement *ale;
27371:         int foundCallee = 0;
27012: 
27012:         while ((ale = iter()) != NULL) {
27012:             JSAtom *atom = ALE_ATOM(ale);
27012:             JSDefinition *dn = ALE_DEFN(ale);
27012:             JS_ASSERT(dn->isPlaceholder());
27012: 
27012:             if (atom == funAtom && lambda != 0) {
27012:                 dn->pn_op = JSOP_CALLEE;
47573:                 dn->pn_cookie.set(funtc->staticLevel, UpvarCookie::CALLEE_SLOT);
27012:                 dn->pn_dflags |= PND_BOUND;
27052: 
27052:                 /*
27052:                  * If this named function expression uses its own name other
32658:                  * than to call itself, flag this function specially.
27052:                  */
27052:                 if (dn->isFunArg())
37685:                     funbox->tcflags |= TCF_FUN_USES_OWN_NAME;
27371:                 foundCallee = 1;
27012:                 continue;
27012:             }
27012: 
37685:             if (!(funbox->tcflags & TCF_FUN_SETS_OUTER_NAME) &&
27012:                 dn->isAssigned()) {
27012:                 /*
27012:                  * Make sure we do not fail to set TCF_FUN_SETS_OUTER_NAME if
27012:                  * any use of dn in funtc assigns. See NoteLValue for the easy
27012:                  * backward-reference case; this is the hard forward-reference
27012:                  * case where we pay a higher price.
27012:                  */
27012:                 for (JSParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:                     if (pnu->isAssigned() && pnu->pn_blockid >= funtc->bodyid) {
37685:                         funbox->tcflags |= TCF_FUN_SETS_OUTER_NAME;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012: 
27371:             JSAtomListElement *outer_ale = tc->decls.lookup(atom);
52554: 
52554:             /*
52554:              * Make sure to deoptimize lexical dependencies that are polluted
52554:              * by eval or with, to safely statically bind globals (see bug 561923).
52554:              */
53446:             if ((funtc->flags & TCF_FUN_CALLS_EVAL) ||
52554:                 (outer_ale && tc->innermostWith &&
52554:                  ALE_DEFN(outer_ale)->pn_pos < tc->innermostWith->pn_pos)) {
52554:                 DeoptimizeUsesWithin(dn, fn->pn_pos);
52554:             }
52554: 
52878:             JSDefinition *outer_dn;
52878: 
27371:             if (!outer_ale)
27371:                 outer_ale = tc->lexdeps.lookup(atom);
27012:             if (outer_ale) {
27012:                 /*
27012:                  * Insert dn's uses list at the front of outer_dn's list.
27012:                  *
27012:                  * Without loss of generality or correctness, we allow a dn to
27012:                  * be in inner and outer lexdeps, since the purpose of lexdeps
27012:                  * is one-pass coordination of name use and definition across
27012:                  * functions, and if different dn's are used we'll merge lists
27012:                  * when leaving the inner function.
27012:                  *
27012:                  * The dn == outer_dn case arises with generator expressions
27012:                  * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
27012:                  * case), and nowhere else, currently.
27012:                  */
52878:                 outer_dn = ALE_DEFN(outer_ale);
27012: 
27012:                 if (dn != outer_dn) {
27012:                     JSParseNode **pnup = &dn->dn_uses;
27012:                     JSParseNode *pnu;
27012: 
27012:                     while ((pnu = *pnup) != NULL) {
27012:                         pnu->pn_lexdef = outer_dn;
27012:                         pnup = &pnu->pn_link;
27012:                     }
27012: 
27012:                     /*
27012:                      * Make dn be a use that redirects to outer_dn, because we
27012:                      * can't replace dn with outer_dn in all the pn_namesets in
27012:                      * the AST where it may be. Instead we make it forward to
27012:                      * outer_dn. See JSDefinition::resolve.
27012:                      */
27012:                     *pnup = outer_dn->dn_uses;
27012:                     outer_dn->dn_uses = dn;
28557:                     outer_dn->pn_dflags |= dn->pn_dflags & ~PND_PLACEHOLDER;
27012:                     dn->pn_defn = false;
27012:                     dn->pn_used = true;
27012:                     dn->pn_lexdef = outer_dn;
52878: 
52878:                     /* Mark the outer dn as escaping. */
27012:                 }
27012:             } else {
27012:                 /* Add an outer lexical dependency for ale's definition. */
40860:                 outer_ale = tc->lexdeps.add(tc->parser, atom);
27012:                 if (!outer_ale)
27012:                     return false;
52878:                 outer_dn = ALE_DEFN(ale);
52878:                 ALE_SET_DEFN(outer_ale, outer_dn);
52878:             }
52878:             outer_dn->pn_dflags |= PND_CLOSED;
27012:         }
27012: 
27371:         if (funtc->lexdeps.count - foundCallee != 0) {
27012:             JSParseNode *body = fn->pn_body;
27012: 
40232:             fn->pn_body = NameSetNode::create(tc);
27012:             if (!fn->pn_body)
27012:                 return false;
27371: 
27012:             fn->pn_body->pn_type = TOK_UPVARS;
27109:             fn->pn_body->pn_pos = body->pn_pos;
27371:             if (foundCallee)
40860:                 funtc->lexdeps.remove(tc->parser, funAtom);
27371:             fn->pn_body->pn_names = funtc->lexdeps;
27012:             fn->pn_body->pn_tree = body;
27371:         }
27371: 
27371:         funtc->lexdeps.clear();
27012:     }
27012: 
51096:     /*
51096:      * Check whether any parameters have been assigned within this function.
51096:      * In strict mode parameters do not alias arguments[i], and to make the
51096:      * arguments object reflect initial parameter values prior to any mutation
51096:      * we create it eagerly whenever parameters are (or might, in the case of
51096:      * calls to eval) be assigned.
51096:      */
51096:     if (funtc->inStrictMode() && funbox->object->getFunctionPrivate()->nargs > 0) {
51096:         JSAtomListIterator iter(&funtc->decls);
51096:         JSAtomListElement *ale;
51096: 
51096:         while ((ale = iter()) != NULL) {
51096:             JSDefinition *dn = ALE_DEFN(ale);
51096:             if (dn->kind() == JSDefinition::ARG && dn->isAssigned()) {
51096:                 funbox->tcflags |= TCF_FUN_MUTATES_PARAMETER;
51096:                 break;
51096:             }
51096:         }
51096:     }
51096: 
27012:     return true;
27012: }
27012: 
52818: static bool
52818: DefineGlobal(JSParseNode *pn, JSCodeGenerator *cg, JSAtom *atom);
52818: 
51088: bool
51088: Parser::functionArguments(JSTreeContext &funtc, JSFunctionBox *funbox, JSFunction *fun,
51088:                           JSParseNode **listp)
51088: {
51088:     if (tokenStream.getToken() != TOK_LP) {
51088:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_BEFORE_FORMAL);
51088:         return false;
51088:     }
51088: 
51088:     if (!tokenStream.matchToken(TOK_RP)) {
51088: #if JS_HAS_DESTRUCTURING
51088:         JSAtom *duplicatedArg = NULL;
51088:         bool destructuringArg = false;
51088:         JSParseNode *list = NULL;
51088: #endif
51088:         do {
51088:             switch (TokenKind tt = tokenStream.getToken()) {
51088: #if JS_HAS_DESTRUCTURING
51088:               case TOK_LB:
51088:               case TOK_LC:
51088:               {
51088:                 /* See comment below in the TOK_NAME case. */
51088:                 if (duplicatedArg)
51088:                     goto report_dup_and_destructuring;
51088:                 destructuringArg = true;
51088: 
51088:                 /*
51088:                  * A destructuring formal parameter turns into one or more
51088:                  * local variables initialized from properties of a single
51088:                  * anonymous positional parameter, so here we must tweak our
51088:                  * binder and its data.
51088:                  */
51088:                 BindData data;
51088:                 data.pn = NULL;
51088:                 data.op = JSOP_DEFVAR;
51088:                 data.binder = BindDestructuringArg;
51088:                 JSParseNode *lhs = destructuringExpr(&data, tt);
51088:                 if (!lhs)
51088:                     return false;
51088: 
51088:                 /*
51088:                  * Adjust fun->nargs to count the single anonymous positional
51088:                  * parameter that is to be destructured.
51088:                  */
51088:                 jsint slot = fun->nargs;
51088:                 if (!js_AddLocal(context, fun, NULL, JSLOCAL_ARG))
51088:                     return false;
51088: 
51088:                 /*
51088:                  * Synthesize a destructuring assignment from the single
51088:                  * anonymous positional parameter into the destructuring
51088:                  * left-hand-side expression and accumulate it in list.
51088:                  */
51088:                 JSParseNode *rhs = NameNode::create(context->runtime->atomState.emptyAtom, &funtc);
51088:                 if (!rhs)
51088:                     return false;
51088:                 rhs->pn_type = TOK_NAME;
51088:                 rhs->pn_op = JSOP_GETARG;
51088:                 rhs->pn_cookie.set(funtc.staticLevel, uint16(slot));
51088:                 rhs->pn_dflags |= PND_BOUND;
51088: 
51088:                 JSParseNode *item = JSParseNode::newBinaryOrAppend(TOK_ASSIGN, JSOP_NOP, lhs, rhs, &funtc);
51088:                 if (!item)
51088:                     return false;
51088:                 if (!list) {
51088:                     list = ListNode::create(&funtc);
51088:                     if (!list)
51088:                         return false;
51088:                     list->pn_type = TOK_COMMA;
51088:                     list->makeEmpty();
51088:                     *listp = list;
51088:                 }
51088:                 list->append(item);
51088:                 break;
51088:               }
51088: #endif /* JS_HAS_DESTRUCTURING */
51088: 
51088:               case TOK_NAME:
51088:               {
51088:                 JSAtom *atom = tokenStream.currentToken().t_atom;
51088:                 if (!DefineArg(funbox->node, atom, fun->nargs, &funtc))
51088:                     return false;
51088: #ifdef JS_HAS_DESTRUCTURING
51088:                 /*
51088:                  * ECMA-262 requires us to support duplicate parameter names, but if the
51088:                  * parameter list includes destructuring, we consider the code to have
51088:                  * opted in to higher standards, and forbid duplicates. We may see a
51088:                  * destructuring parameter later, so always note duplicates now.
51088:                  *
51088:                  * Duplicates are warned about (strict option) or cause errors (strict
51088:                  * mode code), but we do those tests in one place below, after having
51088:                  * parsed the body.
51088:                  */
51088:                 if (js_LookupLocal(context, fun, atom, NULL) != JSLOCAL_NONE) {
51088:                     duplicatedArg = atom;
51088:                     if (destructuringArg)
51088:                         goto report_dup_and_destructuring;
51088:                 }
51088: #endif
51088:                 if (!js_AddLocal(context, fun, atom, JSLOCAL_ARG))
51088:                     return false;
51088:                 break;
51088:               }
51088: 
51088:               default:
51088:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_MISSING_FORMAL);
51088:                 /* FALL THROUGH */
51088:               case TOK_ERROR:
51088:                 return false;
51088: 
51088: #if JS_HAS_DESTRUCTURING
51088:               report_dup_and_destructuring:
51088:                 JSDefinition *dn = ALE_DEFN(funtc.decls.lookup(duplicatedArg));
51088:                 reportErrorNumber(dn, JSREPORT_ERROR, JSMSG_DESTRUCT_DUP_ARG);
51088:                 return false;
51088: #endif
51088:             }
51088:         } while (tokenStream.matchToken(TOK_COMMA));
51088: 
51088:         if (tokenStream.getToken() != TOK_RP) {
51088:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_AFTER_FORMAL);
51088:             return false;
51088:         }
51088:     }
51088: 
51088:     return true;
51088: }
51088: 
40239: JSParseNode *
51089: Parser::functionDef(JSAtom *funAtom, FunctionType type, uintN lambda)
40855: {
    1:     /* Make a TOK_FUNCTION node. */
51087:     tokenStream.mungeCurrentToken(TOK_FUNCTION, JSOP_NOP);
51085:     JSParseNode *pn = FunctionNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_body = NULL;
47573:     pn->pn_cookie.makeFree();
27012: 
27012:     /*
27012:      * If a lambda, give up on JSOP_{GET,CALL}UPVAR usage unless this function
40239:      * is immediately applied (we clear PND_FUNARG if so -- see memberExpr).
27012:      *
27012:      * Also treat function sub-statements (non-lambda, non-top-level functions)
27012:      * as escaping funargs, since we can't statically analyze their definitions
27012:      * and uses.
27012:      */
27012:     bool topLevel = tc->atTopLevel();
27012:     pn->pn_dflags = (lambda || !topLevel) ? PND_FUNARG : 0;
    1: 
    1:     /*
    1:      * Record names for function statements in tc->decls so we know when to
    1:      * avoid optimizing variable references that might name a function.
    1:      */
 9481:     if (lambda == 0 && funAtom) {
51085:         if (JSAtomListElement *ale = tc->decls.lookup(funAtom)) {
27012:             JSDefinition *dn = ALE_DEFN(ale);
27012:             JSDefinition::Kind dn_kind = dn->kind();
27012: 
27012:             JS_ASSERT(!dn->pn_used);
27012:             JS_ASSERT(dn->pn_defn);
27012: 
40239:             if (JS_HAS_STRICT_OPTION(context) || dn_kind == JSDefinition::CONST) {
40239:                 const char *name = js_AtomToPrintableString(context, funAtom);
    1:                 if (!name ||
42671:                     !reportErrorNumber(NULL,
27012:                                        (dn_kind != JSDefinition::CONST)
27012:                                        ? JSREPORT_WARNING | JSREPORT_STRICT
 7984:                                        : JSREPORT_ERROR,
    1:                                        JSMSG_REDECLARED_VAR,
27012:                                        JSDefinition::kindString(dn_kind),
    1:                                        name)) {
    1:                     return NULL;
    1:                 }
    1:             }
27012: 
27012:             if (topLevel) {
27012:                 ALE_SET_DEFN(ale, pn);
27012:                 pn->pn_defn = true;
27012:                 pn->dn_uses = dn;               /* dn->dn_uses is now pn_link */
27012: 
27012:                 if (!MakeDefIntoUse(dn, pn, funAtom, tc))
27012:                     return NULL;
27012:             }
27012:         } else if (topLevel) {
27012:             /*
27012:              * If this function was used before it was defined, claim the
40239:              * pre-created definition node for this function that primaryExpr
27012:              * put in tc->lexdeps on first forward reference, and recycle pn.
27012:              */
27012:             JSHashEntry **hep;
27012: 
27012:             ale = tc->lexdeps.rawLookup(funAtom, hep);
27012:             if (ale) {
27012:                 JSDefinition *fn = ALE_DEFN(ale);
27012: 
27012:                 JS_ASSERT(fn->pn_defn);
27012:                 fn->pn_type = TOK_FUNCTION;
27012:                 fn->pn_arity = PN_FUNC;
27012:                 fn->pn_pos.begin = pn->pn_pos.begin;
27012:                 fn->pn_body = NULL;
47573:                 fn->pn_cookie.makeFree();
27012: 
40860:                 tc->lexdeps.rawRemove(tc->parser, ale, hep);
27012:                 RecycleTree(pn, tc);
27012:                 pn = fn;
27012:             }
27012: 
27012:             if (!Define(pn, funAtom, tc))
27012:                 return NULL;
27012:         }
    1: 
    1:         /*
    1:          * A function nested at top level inside another's body needs only a
    1:          * local variable to bind its name to its value, and not an activation
    1:          * object property (it might also need the activation property, if the
    1:          * outer function contains with statements, e.g., but the stack slot
    1:          * wins when jsemit.c's BindNameToSlot can optimize a JSOP_NAME into a
16429:          * JSOP_GETLOCAL bytecode).
    1:          */
27012:         if (topLevel) {
27012:             pn->pn_dflags |= PND_TOPLEVEL;
27012: 
41884:             if (tc->inFunction()) {
 8179:                 JSLocalKind localKind;
27012:                 uintN index;
27012: 
27012:                 /*
27012:                  * Define a local in the outer function so that BindNameToSlot
27012:                  * can properly optimize accesses. Note that we need a local
27012:                  * variable, not an argument, for the function statement. Thus
27012:                  * we add a variable even if a parameter with the given name
27012:                  * already exists.
27012:                  */
40239:                 localKind = js_LookupLocal(context, tc->fun, funAtom, &index);
27012:                 switch (localKind) {
27012:                   case JSLOCAL_NONE:
27012:                   case JSLOCAL_ARG:
27012:                     index = tc->fun->u.i.nvars;
40239:                     if (!js_AddLocal(context, tc->fun, funAtom, JSLOCAL_VAR))
27012:                         return NULL;
27012:                     /* FALL THROUGH */
27012: 
27012:                   case JSLOCAL_VAR:
47573:                     pn->pn_cookie.set(tc->staticLevel, index);
27012:                     pn->pn_dflags |= PND_BOUND;
27012:                     break;
27012: 
27012:                   default:;
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
40263:     JSTreeContext *outertc = tc;
40263: 
40239:     /* Initialize early for possible flags mutation via destructuringExpr. */
40860:     JSTreeContext funtc(tc->parser);
27012: 
40263:     JSFunctionBox *funbox = EnterFunction(pn, &funtc, funAtom, lambda);
27012:     if (!funbox)
27012:         return NULL;
27012: 
27012:     JSFunction *fun = (JSFunction *) funbox->object;
 8179: 
    1:     /* Now parse formal argument list and compute fun->nargs. */
51097:     JSParseNode *prolog = NULL;
51097:     if (!functionArguments(funtc, funbox, fun, &prolog))
51088:         return NULL;
    1: 
51089:     if (type == GETTER && fun->nargs > 0) {
51089:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ACCESSOR_WRONG_ARGS,
51089:                           "getter", "no", "s");
51089:         return NULL;
51089:     }
51089:     if (type == SETTER && fun->nargs != 1) {
51089:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ACCESSOR_WRONG_ARGS,
51089:                           "setter", "one", "");
51089:         return NULL;
51089:     }
51089: 
 1967: #if JS_HAS_EXPR_CLOSURES
51085:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
 1967:     if (tt != TOK_LC) {
40354:         tokenStream.ungetToken();
 1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 1967:     }
 1967: #else
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
 1967: #endif
    1: 
51085:     JSParseNode *body = functionBody();
    1:     if (!body)
    1:         return NULL;
    1: 
40239:     if (!CheckStrictBinding(context, &funtc, funAtom, pn))
40239:         return NULL;
40239: 
40239:     if (!CheckStrictFormals(context, &funtc, fun, pn))
35323:         return NULL;
35323: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (tt == TOK_LC)
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
40239:     else if (lambda == 0 && !MatchOrInsertSemicolon(context, &tokenStream))
25110:         return NULL;
 1967: #else
 1967:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 1967: #endif
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
51097:     /*
51097:      * Strict mode functions' arguments objects copy initial parameter values.
51097:      * We create arguments objects lazily -- but that doesn't work for strict
51097:      * mode functions where a parameter might be modified and arguments might
51097:      * be accessed.  For such functions we synthesize an access to arguments to
51097:      * initialize it with the original parameter values.
51097:      */
53520: 
53520:     /*
53520:      * Fruit of the poisonous tree: if a closure calls eval, we consider the
53520:      * parent to call eval. We need this for two reasons: (1) the Jaegermonkey
53520:      * optimizations really need to know if eval is called transitively, and
53520:      * (2) in strict mode, eval called transitively requires eager argument
53520:      * creation in strict mode parent functions. 
53520:      *
53520:      * For the latter, we really only need to propagate callsEval if both 
53520:      * functions are strict mode, but we don't lose much by always propagating. 
53520:      * The only optimization we lose this way is in the case where a function 
53520:      * is strict, does not mutate arguments, does not call eval directly, but
53520:      * calls eval transitively.
53520:      */
51097:     if (funtc.callsEval())
51097:         outertc->noteCallsEval();
51097: 
    1: #if JS_HAS_DESTRUCTURING
    1:     /*
    1:      * If there were destructuring formal parameters, prepend the initializing
51110:      * comma expression that we synthesized to body.  If the body is a return
51110:      * node, we must make a special TOK_SEQ node, to prepend the destructuring
51110:      * code without bracing the decompilation of the function body.
    1:      */
51097:     if (prolog) {
    1:         if (body->pn_arity != PN_LIST) {
    1:             JSParseNode *block;
    1: 
40263:             block = ListNode::create(outertc);
    1:             if (!block)
    1:                 return NULL;
20413:             block->pn_type = TOK_SEQ;
    1:             block->pn_pos = body->pn_pos;
27012:             block->initList(body);
    1: 
    1:             body = block;
    1:         }
    1: 
51085:         JSParseNode *item = UnaryNode::create(outertc);
    1:         if (!item)
    1:             return NULL;
    1: 
    1:         item->pn_type = TOK_SEMI;
    1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
51097:         item->pn_kid = prolog;
    1:         item->pn_next = body->pn_head;
    1:         body->pn_head = item;
    1:         if (body->pn_tail == &body->pn_head)
    1:             body->pn_tail = &item->pn_next;
    1:         ++body->pn_count;
27012:         body->pn_xflags |= PNX_DESTRUCT;
    1:     }
    1: #endif
    1: 
    1:     /*
    1:      * If we collected flags that indicate nested heavyweight functions, or
27012:      * this function contains heavyweight-making statements (with statement,
27012:      * visible eval call, or assignment to 'arguments'), flag the function as
27012:      * heavyweight (requiring a call object per invocation).
    1:      */
    1:     if (funtc.flags & TCF_FUN_HEAVYWEIGHT) {
    1:         fun->flags |= JSFUN_HEAVYWEIGHT;
40263:         outertc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     } else {
    1:         /*
    1:          * If this function is a named statement function not at top-level
27012:          * (i.e. not a top-level function definiton or expression), then our
27012:          * enclosing function, if any, must be heavyweight.
27012:          */
27012:         if (!topLevel && lambda == 0 && funAtom)
40263:             outertc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     }
    1: 
51085:     JSParseNode *result = pn;
51086:     JSOp op = JSOP_NOP;
 9481:     if (lambda != 0) {
    1:         /*
    1:          * ECMA ed. 3 standard: function expression, possibly anonymous.
    1:          */
27012:         op = JSOP_LAMBDA;
    1:     } else if (!funAtom) {
    1:         /*
    1:          * If this anonymous function definition is *not* embedded within a
    1:          * larger expression, we treat it as an expression statement, not as
    1:          * a function declaration -- and not as a syntax error (as ECMA-262
 1967:          * Edition 3 would have it).  Backward compatibility must trump all,
 1967:          * unless JSOPTION_ANONFUNFIX is set.
    1:          */
40263:         result = UnaryNode::create(outertc);
    1:         if (!result)
    1:             return NULL;
    1:         result->pn_type = TOK_SEMI;
    1:         result->pn_pos = pn->pn_pos;
    1:         result->pn_kid = pn;
27012:         op = JSOP_LAMBDA;
27012:     } else if (!topLevel) {
    1:         /*
    1:          * ECMA ed. 3 extension: a function expression statement not at the
    1:          * top level, e.g., in a compound statement such as the "then" part
    1:          * of an "if" statement, binds a closure only if control reaches that
    1:          * sub-statement.
    1:          */
18965:         op = JSOP_DEFFUN;
    1:     }
    1: 
27012:     funbox->kids = funtc.functionList;
27012: 
27012:     pn->pn_funbox = funbox;
    1:     pn->pn_op = op;
28816:     if (pn->pn_body) {
27012:         pn->pn_body->append(body);
28816:         pn->pn_body->pn_pos = body->pn_pos;
28816:     } else {
    1:         pn->pn_body = body;
28816:     }
27012: 
52818:     if (!outertc->inFunction() && topLevel && funAtom && !lambda &&
52818:         outertc->compiling()) {
53081:         JS_ASSERT(pn->pn_cookie.isFree());
52818:         if (!DefineGlobal(pn, (JSCodeGenerator *)outertc, funAtom))
52818:             return false;
52818:     }
52818: 
40263:     pn->pn_blockid = outertc->blockid();
40263: 
40263:     if (!LeaveFunction(pn, &funtc, funAtom, lambda))
27012:         return NULL;
27012: 
35113:     /* If the surrounding function is not strict code, reset the lexer. */
51096:     if (!outertc->inStrictMode())
40854:         tokenStream.setStrictMode(false);
35113: 
    1:     return result;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::functionStmt()
40263: {
51087:     JSAtom *name = NULL;
51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME) {
51087:         name = tokenStream.currentToken().t_atom;
51087:     } else {
51087:         if (context->options & JSOPTION_ANONFUNFIX) {
51087:             /* Extension: accept unnamed function expressions as statements. */
51087:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
51087:             return NULL;
51087:         }
51087:         tokenStream.ungetToken();
51087:     }
51089:     return functionDef(name, GENERAL, 0);
40239: }
40239: 
40239: JSParseNode *
40860: Parser::functionExpr()
40263: {
51087:     JSAtom *name = NULL;
51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME)
51087:         name = tokenStream.currentToken().t_atom;
51087:     else
51087:         tokenStream.ungetToken();
51089:     return functionDef(name, GENERAL, JSFUN_LAMBDA);
    1: }
    1: 
    1: /*
35113:  * Recognize Directive Prologue members and directives.  Assuming pn
35113:  * is a candidate for membership in a directive prologue, return
35113:  * true if it is in fact a member.  Recognize directives and set
35113:  * tc's flags accordingly.
35113:  *
35113:  * Note that the following is a strict mode function:
35113:  *
35113:  * function foo() {
35113:  *   "blah" // inserted semi colon
35113:  *        "blurgh"
35113:  *   "use\x20loose"
35113:  *   "use strict"
35113:  * }
35113:  *
35113:  * That is, a statement can be a Directive Prologue member, even
35113:  * if it can't possibly be a directive, now or in the future.
35113:  */
40239: bool
40860: Parser::recognizeDirectivePrologue(JSParseNode *pn)
35113: {
35113:     if (!pn->isDirectivePrologueMember())
35113:         return false;
35113:     if (pn->isDirective()) {
35113:         JSAtom *directive = pn->pn_kid->pn_atom;
40239:         if (directive == context->runtime->atomState.useStrictAtom) {
35113:             tc->flags |= TCF_STRICT_MODE_CODE;
40854:             tokenStream.setStrictMode();
35113:         }
35113:     }
35113:     return true;
35113: }
35113: 
35113: /*
    1:  * Parse the statements in a block, creating a TOK_LC node that lists the
    1:  * statements' trees.  If called from block-parsing code, the caller must
    1:  * match { before and } after.
    1:  */
40239: JSParseNode *
40860: Parser::statements()
    1: {
    1:     JSParseNode *pn, *pn2, *saveBlock;
40320:     TokenKind tt;
35113:     bool inDirectivePrologue = tc->atTopLevel();
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40221: 
40232:     pn = ListNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_type = TOK_LC;
27012:     pn->makeEmpty();
27012:     pn->pn_blockid = tc->blockid();
    1:     saveBlock = tc->blockNode;
    1:     tc->blockNode = pn;
    1: 
 9604:     for (;;) {
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
24241:             if (tt == TOK_ERROR) {
40854:                 if (tokenStream.isEOF())
40854:                     tokenStream.setUnexpectedEOF();
40239:                 return NULL;
40239:             }
40239:             break;
40239:         }
40263:         pn2 = statement();
    1:         if (!pn2) {
40854:             if (tokenStream.isEOF())
40854:                 tokenStream.setUnexpectedEOF();
    1:             return NULL;
    1:         }
    1: 
37740:         if (inDirectivePrologue)
40263:             inDirectivePrologue = recognizeDirectivePrologue(pn2);
35113: 
10466:         if (pn2->pn_type == TOK_FUNCTION) {
10466:             /*
10466:              * PNX_FUNCDEFS notifies the emitter that the block contains top-
10466:              * level function definitions that should be processed before the
10466:              * rest of nodes.
10466:              *
10466:              * TCF_HAS_FUNCTION_STMT is for the TOK_LC case in Statement. It
10466:              * is relevant only for function definitions not at top-level,
10466:              * which we call function statements.
10466:              */
27012:             if (tc->atTopLevel())
27012:                 pn->pn_xflags |= PNX_FUNCDEFS;
10466:             else
    1:                 tc->flags |= TCF_HAS_FUNCTION_STMT;
10466:         }
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration under this block.  If
    1:      * it replaced tc->blockNode with a new block node then we must refresh pn
    1:      * and then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn)
    1:         pn = tc->blockNode;
    1:     tc->blockNode = saveBlock;
    1: 
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::condition()
    1: {
    1:     JSParseNode *pn;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
40263:     pn = parenExpr(NULL, NULL);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
    1: 
31479:     /* Check for (a = b) and warn about possible (a == b) mistype. */
    1:     if (pn->pn_type == TOK_ASSIGN &&
    1:         pn->pn_op == JSOP_NOP &&
31479:         !pn->pn_parens &&
42671:         !reportErrorNumber(NULL, JSREPORT_WARNING | JSREPORT_STRICT, JSMSG_EQUAL_AS_ASSIGN, "")) {
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
    1: static JSBool
40320: MatchLabel(JSContext *cx, TokenStream *ts, JSParseNode *pn)
    1: {
    1:     JSAtom *label;
40320:     TokenKind tt;
40320: 
40354:     tt = ts->peekTokenSameLine();
    1:     if (tt == TOK_ERROR)
    1:         return JS_FALSE;
    1:     if (tt == TOK_NAME) {
40354:         (void) ts->getToken();
40270:         label = ts->currentToken().t_atom;
    1:     } else {
    1:         label = NULL;
    1:     }
    1:     pn->pn_atom = label;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: BindLet(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
27012:     JSParseNode *pn;
    1:     JSObject *blockObj;
    1:     JSAtomListElement *ale;
27012:     jsint n;
27012: 
27012:     /*
27012:      * Top-level 'let' is the same as 'var' currently -- this may change in a
27012:      * successor standard to ES3.1 that specifies 'let'.
27012:      */
27012:     JS_ASSERT(!tc->atTopLevel());
27012: 
27012:     pn = data->pn;
35325:     if (!CheckStrictBinding(cx, tc, atom, pn))
35325:         return false;
35325: 
 8444:     blockObj = tc->blockChain;
27012:     ale = tc->decls.lookup(atom);
27012:     if (ale && ALE_DEFN(ale)->pn_blockid == tc->blockid()) {
27012:         const char *name = js_AtomToPrintableString(cx, atom);
    1:         if (name) {
40860:             ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 7984:                                      JSREPORT_ERROR, JSMSG_REDECLARED_VAR,
27012:                                      (ale && ALE_DEFN(ale)->isConst())
    1:                                      ? js_const_str
27012:                                      : js_variable_str,
    1:                                      name);
    1:         }
47497:         return false;
    1:     }
    1: 
14688:     n = OBJ_BLOCK_COUNT(cx, blockObj);
14688:     if (n == JS_BIT(16)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn,
27012:                                  JSREPORT_ERROR, data->let.overflow);
47497:         return false;
    1:     }
    1: 
27012:     /*
27012:      * Pass push = true to Define so it pushes an ale ahead of any outer scope.
27012:      * This is balanced by PopStatement, defined immediately below.
27012:      */
27012:     if (!Define(pn, atom, tc, true))
47497:         return false;
27012: 
27012:     /*
27012:      * Assign block-local index to pn->pn_cookie right away, encoding it as an
27012:      * upvar cookie whose skip tells the current static level. The emitter will
27012:      * adjust the node's slot based on its stack depth model -- and, for global
40860:      * and eval code, Compiler::compileScript will adjust the slot again to
27012:      * include script->nfixed.
27012:      */
27012:     pn->pn_op = JSOP_GETLOCAL;
48585:     pn->pn_cookie.set(tc->staticLevel, uint16(n));
27012:     pn->pn_dflags |= PND_LET | PND_BOUND;
27012: 
27012:     /*
47497:      * Define the let binding's property before storing pn in reserved slot at
47497:      * reserved slot index (NB: not slot number) n.
32717:      */
32717:     if (!js_DefineBlockVariable(cx, blockObj, ATOM_TO_JSID(atom), n))
47497:         return false;
27012: 
27012:     /*
27012:      * Store pn temporarily in what would be reserved slots in a cloned block
27012:      * object (once the prototype's final population is known, after all 'let'
27012:      * bindings for this block have been parsed). We will free these reserved
27012:      * slots in jsemit.cpp:EmitEnterBlock.
27012:      */
27012:     uintN slot = JSSLOT_FREE(&js_BlockClass) + n;
47497:     if (slot >= blockObj->numSlots() && !blockObj->growSlots(cx, slot + 1))
47497:         return false;
40847:     blockObj->scope()->freeslot = slot + 1;
48470:     blockObj->setSlot(slot, PrivateValue(pn));
47497:     return true;
27012: }
27012: 
27012: static void
27012: PopStatement(JSTreeContext *tc)
27012: {
27012:     JSStmtInfo *stmt = tc->topStmt;
27012: 
27012:     if (stmt->flags & SIF_SCOPE) {
27012:         JSObject *obj = stmt->blockObj;
40847:         JSScope *scope = obj->scope();
30645:         JS_ASSERT(!OBJ_IS_CLONED_BLOCK(obj));
27012: 
35453:         for (JSScopeProperty *sprop = scope->lastProperty(); sprop; sprop = sprop->parent) {
27012:             JSAtom *atom = JSID_TO_ATOM(sprop->id);
27012: 
27012:             /* Beware the empty destructuring dummy. */
40860:             if (atom == tc->parser->context->runtime->atomState.emptyAtom)
27012:                 continue;
40860:             tc->decls.remove(tc->parser, atom);
27012:         }
27012:     }
27012:     js_PopStatement(tc);
    1: }
    1: 
27112: static inline bool
27112: OuterLet(JSTreeContext *tc, JSStmtInfo *stmt, JSAtom *atom)
27112: {
27112:     while (stmt->downScope) {
27112:         stmt = js_LexicalLookup(tc, atom, NULL, stmt->downScope);
27112:         if (!stmt)
27112:             return false;
27112:         if (stmt->type == STMT_BLOCK)
27112:             return true;
27112:     }
27112:     return false;
27112: }
27112: 
41817: /*
41817:  * If we are generating global or eval-called-from-global code, bind a "gvar"
41817:  * here, as soon as possible. The JSOP_GETGVAR, etc., ops speed up interpreted
41817:  * global variable access by memoizing name-to-slot mappings during execution
41817:  * of the script prolog (via JSOP_DEFVAR/JSOP_DEFCONST). If the memoization
41817:  * can't be done due to a pre-existing property of the same name as the var or
41817:  * const but incompatible attributes/getter/setter/etc, these ops devolve to
41817:  * JSOP_NAME, etc.
41817:  *
41817:  * For now, don't try to lookup eval frame variables at compile time. This is
41817:  * sub-optimal: we could handle eval-called-from-global-code gvars since eval
41817:  * gets its own script and frame. The eval-from-function-code case is harder,
41817:  * since functions do not atomize gvars and then reserve their atom indexes as
41817:  * stack frame slots.
41817:  */
41817: static bool
52555: DefineGlobal(JSParseNode *pn, JSCodeGenerator *cg, JSAtom *atom)
52555: {
52555:     GlobalScope *globalScope = cg->compiler()->globalScope;
52555:     JSObject *globalObj = globalScope->globalObj;
52555: 
52555:     if (!cg->compileAndGo() || !globalObj || cg->compilingForEval())
52555:         return true;
52555: 
52555:     JS_LOCK_OBJ(cg->parser->context, globalObj);
52555:     JSScope *scope = globalObj->scope();
52555:     if (JSScopeProperty *sprop = scope->lookup(ATOM_TO_JSID(atom))) {
52555:         /*
52555:          * If the property was found, bind the slot immediately if
52555:          * we can. If we can't, don't bother emitting a GVAR op,
52555:          * since it's unlikely that it will optimize either.
52555:          */
53081:         UpvarCookie cookie;
52555:         if (!sprop->configurable() &&
52555:             SPROP_HAS_VALID_SLOT(sprop, globalObj->scope()) &&
52555:             sprop->hasDefaultGetterOrIsMethod() &&
52555:             sprop->hasDefaultSetter() &&
52818:             pn->pn_type != TOK_FUNCTION)
52818:         {
53081:             if (!cg->addGlobalUse(atom, sprop->slot, cookie)) {
52555:                 JS_UNLOCK_SCOPE(cg->parser->context, scope);
52555:                 return false;
52818:             }
53081:             if (!cookie.isFree()) {
52555:                 pn->pn_op = JSOP_GETGLOBAL;
53081:                 pn->pn_cookie.set(cookie);
52555:                 pn->pn_dflags |= PND_BOUND | PND_GVAR;
52555:             }
52818:         }
52818: 
52818:         JS_UNLOCK_SCOPE(cg->parser->context, scope);
52818:         return true;
52818:     }
52818:     JS_UNLOCK_SCOPE(cg->parser->context, scope);
52818: 
52818:     /*
52818:      * Functions can be redeclared, and the last one takes effect. Check for
52818:      * this and make sure to rewrite the definition.
52818:      */
52818:     uint32 slot = SPROP_INVALID_SLOT;
52818:     JSFunctionBox *funbox = NULL;
52818:     if (pn->pn_type == TOK_FUNCTION) {
52818:         funbox = pn->pn_funbox;
52818:         JSAtomListElement *ale = cg->globalMap.lookup(atom);
52818:         if (ale) {
52818:             uint32 index = ALE_INDEX(ale);
52818:             slot = cg->globalUses[index].slot;
52818:             uint32 defSlot = slot - globalScope->globalFreeSlot;
52818:             JS_ASSERT(globalScope->defs[defSlot].funbox);
52818:             globalScope->defs[defSlot].funbox = funbox;
52818:         }
52818:     }
52818: 
52818:     if (slot == SPROP_INVALID_SLOT) {
52818:         GlobalScope::GlobalDef def(atom, funbox);
52818:         slot = globalScope->globalFreeSlot + globalScope->defs.length();
52818:         if (!globalScope->defs.append(def))
52818:             return false;
52818:     }
52818: 
53081:     UpvarCookie cookie;
53081:     if (!cg->addGlobalUse(atom, slot, cookie))
52818:         return false;
52818: 
53081:     if (!cookie.isFree()) {
53081:         pn->pn_cookie.set(cookie);
52818:         pn->pn_dflags |= PND_GVAR;
52818:         if (pn->pn_type != TOK_FUNCTION) {
52818:             pn->pn_op = JSOP_GETGLOBAL;
52818:             pn->pn_dflags |= PND_BOUND;
52818:         }
52818:     }
52555: 
52555:     return true;
52555: }
52555: 
52555: /*
52555:  * If compile-and-go, and a global object is present, try to bake in either
52555:  * an already available slot or a predicted slot that will be defined after
52555:  * compiling is completed.
52555:  *
52555:  * If not compile-and-go, or compiling for eval, this optimization is invalid.
52795:  */
52795: static bool
52825: BindGvar(JSParseNode *pn, JSTreeContext *tc)
41817: {
41817:     JS_ASSERT(pn->pn_op == JSOP_NAME);
41884:     JS_ASSERT(!tc->inFunction());
41884: 
52555:     if (!tc->compiling() || tc->parser->callerFrame)
52555:         return true;
52555: 
41817:     JSCodeGenerator *cg = (JSCodeGenerator *) tc;
41817: 
52825:     if (pn->pn_dflags & PND_CONST)
41817:         return true;
41817: 
52825:     return DefineGlobal(pn, cg, pn->pn_atom);
41817: }
41817: 
    1: static JSBool
    1: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom, JSTreeContext *tc)
    1: {
35325:     JSParseNode *pn = data->pn;
35325: 
41817:     /* Default best op for pn is JSOP_NAME; we'll try to improve below. */
41817:     pn->pn_op = JSOP_NAME;
41817: 
35325:     if (!CheckStrictBinding(cx, tc, atom, pn))
35325:         return false;
35325: 
27012:     JSStmtInfo *stmt = js_LexicalLookup(tc, atom, NULL);
27012: 
27012:     if (stmt && stmt->type == STMT_WITH) {
29379:         data->fresh = false;
52825:         return true;
27012:     }
27012: 
27012:     JSAtomListElement *ale = tc->decls.lookup(atom);
27012:     JSOp op = data->op;
27012: 
27012:     if (stmt || ale) {
27012:         JSDefinition *dn = ale ? ALE_DEFN(ale) : NULL;
27012:         JSDefinition::Kind dn_kind = dn ? dn->kind() : JSDefinition::VAR;
26970:         const char *name;
27012: 
27012:         if (dn_kind == JSDefinition::ARG) {
 8179:             name = js_AtomToPrintableString(cx, atom);
 8179:             if (!name)
 8179:                 return JS_FALSE;
 8179: 
 8179:             if (op == JSOP_DEFCONST) {
40860:                 ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 8179:                                          JSREPORT_ERROR, JSMSG_REDECLARED_PARAM,
 8179:                                          name);
 8179:                 return JS_FALSE;
 8179:             }
40860:             if (!ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 8179:                                           JSREPORT_WARNING | JSREPORT_STRICT,
 8179:                                           JSMSG_VAR_HIDES_ARG, name)) {
 8179:                 return JS_FALSE;
 8179:             }
 8179:         } else {
28167:             bool error = (op == JSOP_DEFCONST ||
28167:                           dn_kind == JSDefinition::CONST ||
28167:                           (dn_kind == JSDefinition::LET &&
28167:                            (stmt->type != STMT_CATCH || OuterLet(tc, stmt, atom))));
28167: 
27012:             if (JS_HAS_STRICT_OPTION(cx)
27012:                 ? op != JSOP_DEFVAR || dn_kind != JSDefinition::VAR
28167:                 : error) {
27012:                 name = js_AtomToPrintableString(cx, atom);
27012:                 if (!name ||
40860:                     !ReportCompileErrorNumber(cx, TS(tc->parser), pn,
28167:                                               !error
27012:                                               ? JSREPORT_WARNING | JSREPORT_STRICT
27012:                                               : JSREPORT_ERROR,
27012:                                               JSMSG_REDECLARED_VAR,
27012:                                               JSDefinition::kindString(dn_kind),
27012:                                               name)) {
27012:                     return JS_FALSE;
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
27012:     if (!ale) {
27012:         if (!Define(pn, atom, tc))
27012:             return JS_FALSE;
27012:     } else {
27012:         /*
27012:          * A var declaration never recreates an existing binding, it restates
27012:          * it and possibly reinitializes its value. Beware that if pn becomes a
27012:          * use of ALE_DEFN(ale), and if we have an initializer for this var or
27012:          * const (typically a const would ;-), then pn must be rewritten into a
27012:          * TOK_ASSIGN node. See Variables, further below.
27012:          *
27012:          * A case such as let (x = 1) { var x = 2; print(x); } is even harder.
27012:          * There the x definition is hoisted but the x = 2 assignment mutates
27012:          * the block-local binding of x.
27012:          */
27012:         JSDefinition *dn = ALE_DEFN(ale);
27012: 
29379:         data->fresh = false;
29379: 
27012:         if (!pn->pn_used) {
27012:             /* Make pnu be a fresh name node that uses dn. */
27012:             JSParseNode *pnu = pn;
27012: 
27012:             if (pn->pn_defn) {
40232:                 pnu = NameNode::create(atom, tc);
27012:                 if (!pnu)
27012:                     return JS_FALSE;
27012:             }
27012: 
27012:             LinkUseToDef(pnu, dn, tc);
27012:             pnu->pn_op = JSOP_NAME;
27012:         }
27012: 
27012:         while (dn->kind() == JSDefinition::LET) {
27012:             do {
27012:                 ale = ALE_NEXT(ale);
27012:             } while (ale && ALE_ATOM(ale) != atom);
27012:             if (!ale)
27012:                 break;
27012:             dn = ALE_DEFN(ale);
27012:         }
27012: 
27012:         if (ale) {
27012:             JS_ASSERT_IF(data->op == JSOP_DEFCONST,
27012:                          dn->kind() == JSDefinition::CONST);
27012:             return JS_TRUE;
27012:         }
27012: 
27012:         /*
27012:          * A var or const that is shadowed by one or more let bindings of the
27012:          * same name, but that has not been declared until this point, must be
27012:          * hoisted above the let bindings.
27012:          */
27012:         if (!pn->pn_defn) {
27012:             JSHashEntry **hep;
27012: 
27012:             ale = tc->lexdeps.rawLookup(atom, hep);
27012:             if (ale) {
27012:                 pn = ALE_DEFN(ale);
40860:                 tc->lexdeps.rawRemove(tc->parser, ale, hep);
27012:             } else {
40232:                 JSParseNode *pn2 = NameNode::create(atom, tc);
27012:                 if (!pn2)
27012:                     return JS_FALSE;
27012: 
27012:                 /* The token stream may be past the location for pn. */
27012:                 pn2->pn_type = TOK_NAME;
27012:                 pn2->pn_pos = pn->pn_pos;
27012:                 pn = pn2;
27012:             }
27012:             pn->pn_op = JSOP_NAME;
27012:         }
27012: 
40860:         ale = tc->decls.add(tc->parser, atom, JSAtomList::HOIST);
27012:         if (!ale)
27012:             return JS_FALSE;
27012:         ALE_SET_DEFN(ale, pn);
27012:         pn->pn_defn = true;
27012:         pn->pn_dflags &= ~PND_PLACEHOLDER;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
41884:     if (!tc->inFunction())
41817:         return BindGvar(pn, tc);
27012: 
27012:     if (atom == cx->runtime->atomState.argumentsAtom) {
27012:         pn->pn_op = JSOP_ARGUMENTS;
27012:         pn->pn_dflags |= PND_BOUND;
27012:         return JS_TRUE;
27012:     }
27012: 
27012:     JSLocalKind localKind = js_LookupLocal(cx, tc->fun, atom, NULL);
27012:     if (localKind == JSLOCAL_NONE) {
27012:         /*
27012:          * Property not found in current variable scope: we have not seen this
27012:          * variable before. Define a new local variable by adding a property to
27012:          * the function's scope and allocating one slot in the function's vars
27012:          * frame. Any locals declared in a with statement body are handled at
27012:          * runtime, by script prolog JSOP_DEFVAR opcodes generated for global
27012:          * and heavyweight-function-local vars.
27012:          */
27012:         localKind = (data->op == JSOP_DEFCONST) ? JSLOCAL_CONST : JSLOCAL_VAR;
27012: 
27012:         uintN index = tc->fun->u.i.nvars;
35332:         if (!BindLocalVariable(cx, tc->fun, atom, localKind, false))
27012:             return JS_FALSE;
27012:         pn->pn_op = JSOP_GETLOCAL;
47573:         pn->pn_cookie.set(tc->staticLevel, index);
27012:         pn->pn_dflags |= PND_BOUND;
27012:         return JS_TRUE;
27012:     }
27012: 
27012:     if (localKind == JSLOCAL_ARG) {
27012:         /* We checked errors and strict warnings earlier -- see above. */
27012:         JS_ASSERT(ale && ALE_DEFN(ale)->kind() == JSDefinition::ARG);
27012:     } else {
 8179:         /* Not an argument, must be a redeclared local var. */
 8179:         JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
 8179:     }
 8179:     return JS_TRUE;
    1: }
    1: 
20908: static JSBool
20908: MakeSetCall(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN msg)
20908: {
20908:     JSParseNode *pn2;
20908: 
20908:     JS_ASSERT(pn->pn_arity == PN_LIST);
21460:     JS_ASSERT(pn->pn_op == JSOP_CALL || pn->pn_op == JSOP_EVAL || pn->pn_op == JSOP_APPLY);
20908:     pn2 = pn->pn_head;
27012:     if (pn2->pn_type == TOK_FUNCTION && (pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR, msg);
20908:         return JS_FALSE;
20908:     }
20908:     pn->pn_op = JSOP_SETCALL;
20908:     return JS_TRUE;
20908: }
20908: 
27012: static void
27012: NoteLValue(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, uintN dflag = PND_ASSIGNED)
27012: {
27012:     if (pn->pn_used) {
27012:         JSDefinition *dn = pn->pn_lexdef;
27012: 
27012:         /*
27012:          * Save the win of PND_INITIALIZED if we can prove 'var x;' and 'x = y'
27012:          * occur as direct kids of the same block with no forward refs to x.
27012:          */
28920:         if (!(dn->pn_dflags & (PND_INITIALIZED | PND_CONST | PND_PLACEHOLDER)) &&
28557:             dn->isBlockChild() &&
27012:             pn->isBlockChild() &&
27012:             dn->pn_blockid == pn->pn_blockid &&
28557:             dn->pn_pos.end <= pn->pn_pos.begin &&
27012:             dn->dn_uses == pn) {
27012:             dflag = PND_INITIALIZED;
27012:         }
27012: 
27012:         dn->pn_dflags |= dflag;
27012: 
47573:         if (dn->pn_cookie.isFree() || dn->frameLevel() < tc->staticLevel)
27012:             tc->flags |= TCF_FUN_SETS_OUTER_NAME;
27012:     }
27012: 
27012:     pn->pn_dflags |= dflag;
27012: 
51096:     JSAtom *lname = pn->pn_atom;
51096:     if (lname == cx->runtime->atomState.argumentsAtom)
27012:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012: }
27012: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: static JSBool
    1: BindDestructuringVar(JSContext *cx, BindData *data, JSParseNode *pn,
    1:                      JSTreeContext *tc)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * Destructuring is a form of assignment, so just as for an initialized
    1:      * simple variable, we must check for assignment to 'arguments' and flag
    1:      * the enclosing function (if any) as heavyweight.
    1:      */
    1:     JS_ASSERT(pn->pn_type == TOK_NAME);
    1:     atom = pn->pn_atom;
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1: 
    1:     data->pn = pn;
    1:     if (!data->binder(cx, data, atom, tc))
    1:         return JS_FALSE;
27012: 
27012:     /*
27012:      * Select the appropriate name-setting opcode, respecting eager selection
27012:      * done by the data->binder function.
27012:      */
27012:     if (pn->pn_dflags & PND_BOUND) {
52825:         JS_ASSERT_IF((pn->pn_dflags & PND_GVAR), PN_OP(pn) == JSOP_GETGLOBAL);
27012:         pn->pn_op = (pn->pn_op == JSOP_ARGUMENTS)
27012:                     ? JSOP_SETNAME
27012:                     : (pn->pn_dflags & PND_GVAR)
52825:                     ? JSOP_SETGLOBAL
27012:                     : JSOP_SETLOCAL;
 8444:     } else {
27012:         pn->pn_op = (data->op == JSOP_DEFCONST)
27012:                     ? JSOP_SETCONST
27012:                     : JSOP_SETNAME;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
27012:     NoteLValue(cx, pn, tc, PND_INITIALIZED);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
    1:  * LHS expression except a destructuring initialiser, and R is on the stack.
    1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
    1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
    1:  * then push its property name QN.  At this point the stack looks like
    1:  *
    1:  *   [... R, R[P], QB, QN]
    1:  *
    1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
    1:  * its operands with left-hand side above right-hand side:
    1:  *
    1:  *   [rval, lval, xval]
    1:  *
    1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
    1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
    1:  * which can be optimized further.  So we select JSOP_SETNAME.
    1:  */
    1: static JSBool
    1: BindDestructuringLHS(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     switch (pn->pn_type) {
    1:       case TOK_NAME:
27012:         NoteLValue(cx, pn, tc);
    1:         /* FALL THROUGH */
27012: 
    1:       case TOK_DOT:
    1:       case TOK_LB:
42747:         /*
42747:          * We may be called on a name node that has already been specialized,
42747:          * in the very weird and ECMA-262-required "for (var [x] = i in o) ..."
42747:          * case. See bug 558633.
42747:          */
42747:         if (!(js_CodeSpec[pn->pn_op].format & JOF_SET))
    1:             pn->pn_op = JSOP_SETNAME;
    1:         break;
    1: 
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (pn->pn_op == JSOP_XMLNAME) {
    1:             pn->pn_op = JSOP_BINDXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1:       default:
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 7984:                                  JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: typedef struct FindPropValData {
    1:     uint32          numvars;    /* # of destructuring vars in left side */
    1:     uint32          maxstep;    /* max # of steps searching right side */
    1:     JSDHashTable    table;      /* hash table for O(1) right side search */
    1: } FindPropValData;
    1: 
    1: typedef struct FindPropValEntry {
    1:     JSDHashEntryHdr hdr;
    1:     JSParseNode     *pnkey;
    1:     JSParseNode     *pnval;
    1: } FindPropValEntry;
    1: 
    1: #define ASSERT_VALID_PROPERTY_KEY(pnkey)                                      \
28995:     JS_ASSERT(((pnkey)->pn_arity == PN_NULLARY &&                             \
    1:                ((pnkey)->pn_type == TOK_NUMBER ||                             \
    1:                 (pnkey)->pn_type == TOK_STRING ||                             \
28995:                 (pnkey)->pn_type == TOK_NAME)) ||                             \
29361:                ((pnkey)->pn_arity == PN_NAME && (pnkey)->pn_type == TOK_NAME))
    1: 
18907: static JSDHashNumber
    1: HashFindPropValKey(JSDHashTable *table, const void *key)
    1: {
    1:     const JSParseNode *pnkey = (const JSParseNode *)key;
    1: 
    1:     ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:     return (pnkey->pn_type == TOK_NUMBER)
32586:            ? (JSDHashNumber) JS_HASH_DOUBLE(pnkey->pn_dval)
 3328:            : ATOM_HASH(pnkey->pn_atom);
    1: }
    1: 
18907: static JSBool
    1: MatchFindPropValEntry(JSDHashTable *table,
    1:                       const JSDHashEntryHdr *entry,
    1:                       const void *key)
    1: {
    1:     const FindPropValEntry *fpve = (const FindPropValEntry *)entry;
    1:     const JSParseNode *pnkey = (const JSParseNode *)key;
    1: 
    1:     ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:     return pnkey->pn_type == fpve->pnkey->pn_type &&
    1:            ((pnkey->pn_type == TOK_NUMBER)
    1:             ? pnkey->pn_dval == fpve->pnkey->pn_dval
    1:             : pnkey->pn_atom == fpve->pnkey->pn_atom);
    1: }
    1: 
    1: static const JSDHashTableOps FindPropValOps = {
    1:     JS_DHashAllocTable,
    1:     JS_DHashFreeTable,
    1:     HashFindPropValKey,
    1:     MatchFindPropValEntry,
    1:     JS_DHashMoveEntryStub,
    1:     JS_DHashClearEntryStub,
    1:     JS_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: #define STEP_HASH_THRESHOLD     10
    1: #define BIG_DESTRUCTURING        5
    1: #define BIG_OBJECT_INIT         20
    1: 
    1: static JSParseNode *
    1: FindPropertyValue(JSParseNode *pn, JSParseNode *pnid, FindPropValData *data)
    1: {
    1:     FindPropValEntry *entry;
  991:     JSParseNode *pnhit, *pnhead, *pnprop, *pnkey;
    1:     uint32 step;
    1: 
    1:     /* If we have a hash table, use it as the sole source of truth. */
    1:     if (data->table.ops) {
    1:         entry = (FindPropValEntry *)
    1:                 JS_DHashTableOperate(&data->table, pnid, JS_DHASH_LOOKUP);
    1:         return JS_DHASH_ENTRY_IS_BUSY(&entry->hdr) ? entry->pnval : NULL;
    1:     }
    1: 
    1:     /* If pn is not an object initialiser node, we can't do anything here. */
    1:     if (pn->pn_type != TOK_RC)
    1:         return NULL;
    1: 
    1:     /*
    1:      * We must search all the way through pn's list, to handle the case of an
    1:      * id duplicated for two or more property initialisers.
    1:      */
    1:     pnhit = NULL;
    1:     step = 0;
    1:     ASSERT_VALID_PROPERTY_KEY(pnid);
  991:     pnhead = pn->pn_head;
    1:     if (pnid->pn_type == TOK_NUMBER) {
  991:         for (pnprop = pnhead; pnprop; pnprop = pnprop->pn_next) {
    1:             JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:             if (pnprop->pn_op == JSOP_NOP) {
    1:                 pnkey = pnprop->pn_left;
    1:                 ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:                 if (pnkey->pn_type == TOK_NUMBER &&
    1:                     pnkey->pn_dval == pnid->pn_dval) {
    1:                     pnhit = pnprop;
    1:                 }
    1:                 ++step;
    1:             }
    1:         }
    1:     } else {
  991:         for (pnprop = pnhead; pnprop; pnprop = pnprop->pn_next) {
    1:             JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:             if (pnprop->pn_op == JSOP_NOP) {
    1:                 pnkey = pnprop->pn_left;
    1:                 ASSERT_VALID_PROPERTY_KEY(pnkey);
    1:                 if (pnkey->pn_type == pnid->pn_type &&
    1:                     pnkey->pn_atom == pnid->pn_atom) {
    1:                     pnhit = pnprop;
    1:                 }
    1:                 ++step;
    1:             }
    1:         }
    1:     }
    1:     if (!pnhit)
    1:         return NULL;
    1: 
    1:     /* Hit via full search -- see whether it's time to create the hash table. */
    1:     JS_ASSERT(!data->table.ops);
    1:     if (step > data->maxstep) {
    1:         data->maxstep = step;
    1:         if (step >= STEP_HASH_THRESHOLD &&
    1:             data->numvars >= BIG_DESTRUCTURING &&
    1:             pn->pn_count >= BIG_OBJECT_INIT &&
    1:             JS_DHashTableInit(&data->table, &FindPropValOps, pn,
    1:                               sizeof(FindPropValEntry),
    1:                               JS_DHASH_DEFAULT_CAPACITY(pn->pn_count)))
    1:         {
  991:             for (pn = pnhead; pn; pn = pn->pn_next) {
  991:                 JS_ASSERT(pnprop->pn_type == TOK_COLON);
    1:                 ASSERT_VALID_PROPERTY_KEY(pn->pn_left);
    1:                 entry = (FindPropValEntry *)
    1:                         JS_DHashTableOperate(&data->table, pn->pn_left,
    1:                                              JS_DHASH_ADD);
    1:                 entry->pnval = pn->pn_right;
    1:             }
    1:         }
    1:     }
    1:     return pnhit->pn_right;
    1: }
    1: 
    1: /*
33753:  * Destructuring patterns can appear in two kinds of contexts:
28995:  *
33753:  * - assignment-like: assignment expressions and |for| loop heads.  In
33753:  *   these cases, the patterns' property value positions can be
33753:  *   arbitrary lvalue expressions; the destructuring is just a fancy
33753:  *   assignment.
33753:  *
33753:  * - declaration-like: |var| and |let| declarations, functions' formal
33753:  *   parameter lists, |catch| clauses, and comprehension tails.  In
33753:  *   these cases, the patterns' property value positions must be
33753:  *   simple names; the destructuring defines them as new variables.
33753:  *
33753:  * In both cases, other code parses the pattern as an arbitrary
40239:  * primaryExpr, and then, here in CheckDestructuring, verify that the
33753:  * tree is a valid destructuring expression.
33753:  *
33753:  * In assignment-like contexts, we parse the pattern with the
33753:  * TCF_DECL_DESTRUCTURING flag clear, so the lvalue expressions in the
40239:  * pattern are parsed normally.  primaryExpr links variable references
33753:  * into the appropriate use chains; creates placeholder definitions;
33753:  * and so on.  CheckDestructuring is called with |data| NULL (since we
33753:  * won't be binding any new names), and we specialize lvalues as
33753:  * appropriate.  If right is NULL, we just check for well-formed lvalues.
33753:  *
33753:  * In declaration-like contexts, the normal variable reference
33753:  * processing would just be an obstruction, because we're going to
33753:  * define the names that appear in the property value positions as new
33753:  * variables anyway.  In this case, we parse the pattern with
40239:  * TCF_DECL_DESTRUCTURING set, which directs primaryExpr to leave
33753:  * whatever name nodes it creates unconnected.  Then, here in
33753:  * CheckDestructuring, we require the pattern's property value
33753:  * positions to be simple names, and define them as appropriate to the
33753:  * context.  For these calls, |data| points to the right sort of
33753:  * BindData.
33753:  *
33753:  * See also UndominateInitializers, immediately below. If you change
33753:  * either of these functions, you might have to change the other to
33753:  * match.
    1:  */
    1: static JSBool
    1: CheckDestructuring(JSContext *cx, BindData *data,
    1:                    JSParseNode *left, JSParseNode *right,
    1:                    JSTreeContext *tc)
    1: {
    1:     JSBool ok;
    1:     FindPropValData fpvd;
    1:     JSParseNode *lhs, *rhs, *pn, *pn2;
    1: 
    1:     if (left->pn_type == TOK_ARRAYCOMP) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), left, JSREPORT_ERROR,
40320:                                  JSMSG_ARRAY_COMP_LEFTSIDE);
    1:         return JS_FALSE;
    1:     }
    1: 
18473: #if JS_HAS_DESTRUCTURING_SHORTHAND
27012:     if (right && right->pn_arity == PN_LIST && (right->pn_xflags & PNX_DESTRUCT)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), right, JSREPORT_ERROR,
40320:                                  JSMSG_BAD_OBJECT_INIT);
18473:         return JS_FALSE;
18473:     }
18473: #endif
18473: 
    1:     fpvd.table.ops = NULL;
    1:     lhs = left->pn_head;
    1:     if (left->pn_type == TOK_RB) {
    1:         rhs = (right && right->pn_type == left->pn_type)
    1:               ? right->pn_head
    1:               : NULL;
    1: 
    1:         while (lhs) {
    1:             pn = lhs, pn2 = rhs;
    1: 
    1:             /* Nullary comma is an elision; binary comma is an expression.*/
    1:             if (pn->pn_type != TOK_COMMA || pn->pn_arity != PN_NULLARY) {
    1:                 if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
    1:                     ok = CheckDestructuring(cx, data, pn, pn2, tc);
    1:                 } else {
    1:                     if (data) {
    1:                         if (pn->pn_type != TOK_NAME)
    1:                             goto no_var_name;
    1: 
    1:                         ok = BindDestructuringVar(cx, data, pn, tc);
    1:                     } else {
    1:                         ok = BindDestructuringLHS(cx, pn, tc);
    1:                     }
    1:                 }
    1:                 if (!ok)
    1:                     goto out;
    1:             }
    1: 
    1:             lhs = lhs->pn_next;
    1:             if (rhs)
    1:                 rhs = rhs->pn_next;
    1:         }
    1:     } else {
    1:         JS_ASSERT(left->pn_type == TOK_RC);
    1:         fpvd.numvars = left->pn_count;
    1:         fpvd.maxstep = 0;
    1:         rhs = NULL;
    1: 
    1:         while (lhs) {
    1:             JS_ASSERT(lhs->pn_type == TOK_COLON);
    1:             pn = lhs->pn_right;
    1: 
    1:             if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
31479:                 if (right)
    1:                     rhs = FindPropertyValue(right, lhs->pn_left, &fpvd);
    1:                 ok = CheckDestructuring(cx, data, pn, rhs, tc);
    1:             } else if (data) {
    1:                 if (pn->pn_type != TOK_NAME)
    1:                     goto no_var_name;
    1: 
    1:                 ok = BindDestructuringVar(cx, data, pn, tc);
    1:             } else {
    1:                 ok = BindDestructuringLHS(cx, pn, tc);
    1:             }
    1:             if (!ok)
    1:                 goto out;
    1: 
    1:             lhs = lhs->pn_next;
    1:         }
    1:     }
    1: 
14688:     /*
14688:      * The catch/finally handler implementation in the interpreter assumes
14688:      * that any operation that introduces a new scope (like a "let" or "with"
14688:      * block) increases the stack depth. This way, it is possible to restore
14688:      * the scope chain based on stack depth of the handler alone. "let" with
14688:      * an empty destructuring pattern like in
14688:      *
14688:      *   let [] = 1;
14688:      *
14688:      * would violate this assumption as the there would be no let locals to
14688:      * store on the stack. To satisfy it we add an empty property to such
14688:      * blocks so that OBJ_BLOCK_COUNT(cx, blockObj), which gives the number of
14688:      * slots, would be always positive.
14688:      *
14688:      * Note that we add such a property even if the block has locals due to
14688:      * later let declarations in it. We optimize for code simplicity here,
14688:      * not the fastest runtime performance with empty [] or {}.
14688:      */
14688:     if (data &&
14688:         data->binder == BindLet &&
14688:         OBJ_BLOCK_COUNT(cx, tc->blockChain) == 0) {
27575:         ok = !!js_DefineNativeProperty(cx, tc->blockChain,
14688:                                        ATOM_TO_JSID(cx->runtime->
14688:                                                     atomState.emptyAtom),
48470:                                        UndefinedValue(), NULL, NULL,
14860:                                        JSPROP_ENUMERATE |
14860:                                        JSPROP_PERMANENT |
14860:                                        JSPROP_SHARED,
38562:                                        JSScopeProperty::HAS_SHORTID, 0, NULL);
14688:         if (!ok)
14688:             goto out;
14688:     }
14688: 
14688:     ok = JS_TRUE;
14688: 
    1:   out:
    1:     if (fpvd.table.ops)
    1:         JS_DHashTableFinish(&fpvd.table);
    1:     return ok;
    1: 
    1:   no_var_name:
40860:     ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR,
    1:                              JSMSG_NO_VARIABLE_NAME);
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
28995: /*
28995:  * This is a greatly pared down version of CheckDestructuring that extends the
28995:  * pn_pos.end source coordinate of each name in a destructuring binding such as
28995:  *
28995:  *   var [x, y] = [function () y, 42];
28995:  *
28995:  * to cover its corresponding initializer, so that the initialized binding does
28995:  * not appear to dominate any closures in its initializer. See bug 496134.
28995:  *
40860:  * The quick-and-dirty dominance computation in Parser::setFunctionKinds is not
40860:  * very precise. With one-pass SSA construction from structured source code
28995:  * (see "Single-Pass Generation of Static Single Assignment Form for Structured
28995:  * Languages", Brandis and Mössenböck), we could do much better.
28995:  *
28995:  * See CheckDestructuring, immediately above. If you change either of these
28995:  * functions, you might have to change the other to match.
28995:  */
28995: static JSBool
28995: UndominateInitializers(JSParseNode *left, JSParseNode *right, JSTreeContext *tc)
28995: {
28995:     FindPropValData fpvd;
28995:     JSParseNode *lhs, *rhs;
28995: 
28995:     JS_ASSERT(left->pn_type != TOK_ARRAYCOMP);
28995:     JS_ASSERT(right);
28995: 
28995: #if JS_HAS_DESTRUCTURING_SHORTHAND
28995:     if (right->pn_arity == PN_LIST && (right->pn_xflags & PNX_DESTRUCT)) {
40860:         ReportCompileErrorNumber(tc->parser->context, TS(tc->parser), right, JSREPORT_ERROR,
40320:                                  JSMSG_BAD_OBJECT_INIT);
28995:         return JS_FALSE;
28995:     }
28995: #endif
28995: 
28995:     if (right->pn_type != left->pn_type)
28995:         return JS_TRUE;
28995: 
28995:     fpvd.table.ops = NULL;
28995:     lhs = left->pn_head;
28995:     if (left->pn_type == TOK_RB) {
28995:         rhs = right->pn_head;
28995: 
28995:         while (lhs && rhs) {
28995:             /* Nullary comma is an elision; binary comma is an expression.*/
28995:             if (lhs->pn_type != TOK_COMMA || lhs->pn_arity != PN_NULLARY) {
28995:                 if (lhs->pn_type == TOK_RB || lhs->pn_type == TOK_RC) {
28995:                     if (!UndominateInitializers(lhs, rhs, tc))
28995:                         return JS_FALSE;
28995:                 } else {
28995:                     lhs->pn_pos.end = rhs->pn_pos.end;
28995:                 }
28995:             }
28995: 
28995:             lhs = lhs->pn_next;
28995:             rhs = rhs->pn_next;
28995:         }
28995:     } else {
28995:         JS_ASSERT(left->pn_type == TOK_RC);
28995:         fpvd.numvars = left->pn_count;
28995:         fpvd.maxstep = 0;
28995: 
28995:         while (lhs) {
28995:             JS_ASSERT(lhs->pn_type == TOK_COLON);
28995:             JSParseNode *pn = lhs->pn_right;
28995: 
28995:             rhs = FindPropertyValue(right, lhs->pn_left, &fpvd);
28995:             if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
28995:                 if (rhs && !UndominateInitializers(pn, rhs, tc))
28995:                     return JS_FALSE;
28995:             } else {
28995:                 if (rhs)
28995:                     pn->pn_pos.end = rhs->pn_pos.end;
28995:             }
28995: 
28995:             lhs = lhs->pn_next;
28995:         }
28995:     }
28995:     return JS_TRUE;
28995: }
28995: 
40239: JSParseNode *
40860: Parser::destructuringExpr(BindData *data, TokenKind tt)
40239: {
    1:     JSParseNode *pn;
    1: 
33753:     tc->flags |= TCF_DECL_DESTRUCTURING;
40263:     pn = primaryExpr(tt, JS_FALSE);
33753:     tc->flags &= ~TCF_DECL_DESTRUCTURING;
    1:     if (!pn)
    1:         return NULL;
40239:     if (!CheckDestructuring(context, data, pn, NULL, tc))
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
27012: /*
27012:  * Currently used only #if JS_HAS_DESTRUCTURING, in Statement's TOK_FOR case.
27012:  * This function assumes the cloned tree is for use in the same statement and
27012:  * binding context as the original tree.
27012:  */
20413: static JSParseNode *
27012: CloneParseTree(JSParseNode *opn, JSTreeContext *tc)
20413: {
20413:     JSParseNode *pn, *pn2, *opn2;
20413: 
27012:     pn = NewOrRecycledNode(tc);
20413:     if (!pn)
20413:         return NULL;
20413:     pn->pn_type = opn->pn_type;
20413:     pn->pn_pos = opn->pn_pos;
20413:     pn->pn_op = opn->pn_op;
27012:     pn->pn_used = opn->pn_used;
27012:     pn->pn_defn = opn->pn_defn;
20413:     pn->pn_arity = opn->pn_arity;
31479:     pn->pn_parens = opn->pn_parens;
20413: 
20413:     switch (pn->pn_arity) {
20419: #define NULLCHECK(e)    JS_BEGIN_MACRO if (!(e)) return NULL; JS_END_MACRO
20413: 
20413:       case PN_FUNC:
27012:         NULLCHECK(pn->pn_funbox =
40860:                   tc->parser->newFunctionBox(opn->pn_funbox->object, pn, tc));
27012:         NULLCHECK(pn->pn_body = CloneParseTree(opn->pn_body, tc));
27012:         pn->pn_cookie = opn->pn_cookie;
27012:         pn->pn_dflags = opn->pn_dflags;
27012:         pn->pn_blockid = opn->pn_blockid;
20413:         break;
20413: 
20413:       case PN_LIST:
27012:         pn->makeEmpty();
20413:         for (opn2 = opn->pn_head; opn2; opn2 = opn2->pn_next) {
27012:             NULLCHECK(pn2 = CloneParseTree(opn2, tc));
27012:             pn->append(pn2);
27012:         }
27012:         pn->pn_xflags = opn->pn_xflags;
20413:         break;
20413: 
20413:       case PN_TERNARY:
27012:         NULLCHECK(pn->pn_kid1 = CloneParseTree(opn->pn_kid1, tc));
27012:         NULLCHECK(pn->pn_kid2 = CloneParseTree(opn->pn_kid2, tc));
27012:         NULLCHECK(pn->pn_kid3 = CloneParseTree(opn->pn_kid3, tc));
20413:         break;
20413: 
20413:       case PN_BINARY:
27012:         NULLCHECK(pn->pn_left = CloneParseTree(opn->pn_left, tc));
20413:         if (opn->pn_right != opn->pn_left)
27012:             NULLCHECK(pn->pn_right = CloneParseTree(opn->pn_right, tc));
20413:         else
20413:             pn->pn_right = pn->pn_left;
48470:         pn->pn_pval = opn->pn_pval;
20413:         pn->pn_iflags = opn->pn_iflags;
20413:         break;
20413: 
20413:       case PN_UNARY:
27012:         NULLCHECK(pn->pn_kid = CloneParseTree(opn->pn_kid, tc));
20413:         pn->pn_num = opn->pn_num;
20413:         pn->pn_hidden = opn->pn_hidden;
20413:         break;
20413: 
20413:       case PN_NAME:
20413:         // PN_NAME could mean several arms in pn_u, so copy the whole thing.
20413:         pn->pn_u = opn->pn_u;
27012:         if (opn->pn_used) {
27012:             /*
27012:              * The old name is a use of its pn_lexdef. Make the clone also be a
27012:              * use of that definition.
27012:              */
27012:             JSDefinition *dn = pn->pn_lexdef;
27012: 
27012:             pn->pn_link = dn->dn_uses;
27012:             dn->dn_uses = pn;
27012:         } else if (opn->pn_expr) {
27012:             NULLCHECK(pn->pn_expr = CloneParseTree(opn->pn_expr, tc));
27012: 
27012:             /*
27012:              * If the old name is a definition, the new one has pn_defn set.
27012:              * Make the old name a use of the new node.
27012:              */
27012:             if (opn->pn_defn) {
27012:                 opn->pn_defn = false;
27012:                 LinkUseToDef(opn, (JSDefinition *) pn, tc);
27012:             }
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         pn->pn_names = opn->pn_names;
27012:         NULLCHECK(pn->pn_tree = CloneParseTree(opn->pn_tree, tc));
20413:         break;
20413: 
20413:       case PN_NULLARY:
20413:         // Even PN_NULLARY may have data (apair for E4X -- what a botch).
20413:         pn->pn_u = opn->pn_u;
20413:         break;
20413: 
20413: #undef NULLCHECK
20413:     }
20413:     return pn;
20413: }
20413: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1: extern const char js_with_statement_str[];
    1: 
    1: static JSParseNode *
40320: ContainsStmt(JSParseNode *pn, TokenKind tt)
    1: {
    1:     JSParseNode *pn2, *pnt;
    1: 
    1:     if (!pn)
    1:         return NULL;
27012:     if (PN_TYPE(pn) == tt)
    1:         return pn;
    1:     switch (pn->pn_arity) {
    1:       case PN_LIST:
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             pnt = ContainsStmt(pn2, tt);
    1:             if (pnt)
    1:                 return pnt;
    1:         }
    1:         break;
    1:       case PN_TERNARY:
    1:         pnt = ContainsStmt(pn->pn_kid1, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         pnt = ContainsStmt(pn->pn_kid2, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_kid3, tt);
    1:       case PN_BINARY:
    1:         /*
    1:          * Limit recursion if pn is a binary expression, which can't contain a
    1:          * var statement.
    1:          */
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         pnt = ContainsStmt(pn->pn_left, tt);
    1:         if (pnt)
    1:             return pnt;
    1:         return ContainsStmt(pn->pn_right, tt);
    1:       case PN_UNARY:
    1:         if (pn->pn_op != JSOP_NOP)
    1:             return NULL;
    1:         return ContainsStmt(pn->pn_kid, tt);
    1:       case PN_NAME:
27012:         return ContainsStmt(pn->maybeExpr(), tt);
27012:       case PN_NAMESET:
27012:         return ContainsStmt(pn->pn_tree, tt);
    1:       default:;
    1:     }
    1:     return NULL;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::returnOrYield(bool useAssignExpr)
40221: {
40320:     TokenKind tt, tt2;
    1:     JSParseNode *pn, *pn2;
    1: 
40270:     tt = tokenStream.currentToken().type;
41884:     if (tt == TOK_RETURN && !tc->inFunction()) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_RETURN_OR_YIELD, js_return_str);
    1:         return NULL;
    1:     }
    1: 
40232:     pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1: #if JS_HAS_GENERATORS
    1:     if (tt == TOK_YIELD)
    1:         tc->flags |= TCF_FUN_IS_GENERATOR;
    1: #endif
    1: 
    1:     /* This is ugly, but we don't want to require a semicolon. */
40854:     tt2 = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:     if (tt2 == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
    1: #if JS_HAS_GENERATORS
  339:         && (tt != TOK_YIELD ||
11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
    1: #endif
    1:         ) {
40263:         pn2 = useAssignExpr ? assignExpr() : expr();
    1:         if (!pn2)
    1:             return NULL;
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_EXPR;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:     } else {
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_VOID;
    1:     }
    1: 
    1:     if ((~tc->flags & (TCF_RETURN_EXPR | TCF_FUN_IS_GENERATOR)) == 0) {
    1:         /* As in Python (see PEP-255), disallow return v; in generators. */
40239:         ReportBadReturn(context, tc, JSREPORT_ERROR,
    1:                         JSMSG_BAD_GENERATOR_RETURN,
    1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
    1:         return NULL;
    1:     }
    1: 
40239:     if (JS_HAS_STRICT_OPTION(context) &&
    1:         (~tc->flags & (TCF_RETURN_EXPR | TCF_RETURN_VOID)) == 0 &&
40239:         !ReportBadReturn(context, tc, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                          JSMSG_NO_RETURN_VALUE,
    1:                          JSMSG_ANON_NO_RETURN_VALUE)) {
    1:         return NULL;
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: static JSParseNode *
40320: PushLexicalScope(JSContext *cx, TokenStream *ts, JSTreeContext *tc,
27012:                  JSStmtInfo *stmt)
    1: {
    1:     JSParseNode *pn;
    1:     JSObject *obj;
27012:     JSObjectBox *blockbox;
27012: 
40232:     pn = LexicalScopeNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     obj = js_NewBlockObject(cx);
    1:     if (!obj)
    1:         return NULL;
    1: 
40860:     blockbox = tc->parser->newObjectBox(obj);
27012:     if (!blockbox)
27012:         return NULL;
27012: 
27012:     js_PushBlockScope(tc, stmt, obj, -1);
    1:     pn->pn_type = TOK_LEXICALSCOPE;
    1:     pn->pn_op = JSOP_LEAVEBLOCK;
27012:     pn->pn_objbox = blockbox;
47573:     pn->pn_cookie.makeFree();
27012:     pn->pn_dflags = 0;
27012:     if (!GenerateBlockId(tc, stmt->blockid))
27012:         return NULL;
27012:     pn->pn_blockid = stmt->blockid;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1: 
40239: JSParseNode *
40860: Parser::letBlock(JSBool statement)
    1: {
    1:     JSParseNode *pn, *pnblock, *pnlet;
    1:     JSStmtInfo stmtInfo;
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LET);
    1: 
    1:     /* Create the let binary node. */
40232:     pnlet = BinaryNode::create(tc);
    1:     if (!pnlet)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
    1: 
    1:     /* This is a let block or expression of the form: let (a, b, c) .... */
40239:     pnblock = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
    1:     if (!pnblock)
    1:         return NULL;
    1:     pn = pnblock;
    1:     pn->pn_expr = pnlet;
    1: 
40263:     pnlet->pn_left = variables(true);
    1:     if (!pnlet->pn_left)
    1:         return NULL;
27012:     pnlet->pn_left->pn_xflags = PNX_POPVAR;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
    1: 
40854:     if (statement && !tokenStream.matchToken(TOK_LC, TSF_OPERAND)) {
    1:         /*
    1:          * If this is really an expression in let statement guise, then we
    1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
    1:          * the return value of the expression.
    1:          */
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_num = -1;
    1:         pn->pn_kid = pnblock;
    1: 
    1:         statement = JS_FALSE;
    1:     }
    1: 
    1:     if (statement) {
40263:         pnlet->pn_right = statements();
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
    1:     } else {
    1:         /*
    1:          * Change pnblock's opcode to the variant that propagates the last
    1:          * result down after popping the block, and clear statement.
    1:          */
    1:         pnblock->pn_op = JSOP_LEAVEBLOCKEXPR;
40263:         pnlet->pn_right = assignExpr();
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:     }
    1: 
27012:     PopStatement(tc);
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
27012: static bool
27012: PushBlocklikeStatement(JSStmtInfo *stmt, JSStmtType type, JSTreeContext *tc)
27012: {
27012:     js_PushStatement(tc, stmt, type, -1);
27012:     return GenerateBlockId(tc, stmt->blockid);
27012: }
27012: 
27012: static JSParseNode *
33754: NewBindingNode(JSAtom *atom, JSTreeContext *tc, bool let = false)
27012: {
27012:     JSParseNode *pn = NULL;
27012: 
27012:     JSAtomListElement *ale = tc->decls.lookup(atom);
27012:     if (ale) {
27012:         pn = ALE_DEFN(ale);
27012:         JS_ASSERT(!pn->isPlaceholder());
27012:     } else {
27012:         ale = tc->lexdeps.lookup(atom);
27012:         if (ale) {
27012:             pn = ALE_DEFN(ale);
27012:             JS_ASSERT(pn->isPlaceholder());
27012:         }
27012:     }
27012: 
27012:     if (pn) {
27012:         JS_ASSERT(pn->pn_defn);
27012: 
27012:         /*
27012:          * A let binding at top level becomes a var before we get here, so if
27012:          * pn and tc have the same blockid then that id must not be the bodyid.
27012:          * If pn is a forward placeholder definition from the same or a higher
27012:          * block then we claim it.
27012:          */
27012:         JS_ASSERT_IF(let && pn->pn_blockid == tc->blockid(),
27012:                      pn->pn_blockid != tc->bodyid);
27012: 
27012:         if (pn->isPlaceholder() && pn->pn_blockid >= (let ? tc->blockid() : tc->bodyid)) {
27012:             if (let)
27012:                 pn->pn_blockid = tc->blockid();
27012: 
40860:             tc->lexdeps.remove(tc->parser, atom);
27012:             return pn;
27012:         }
27012:     }
27012: 
27012:     /* Make a new node for this declarator name (or destructuring pattern). */
40232:     pn = NameNode::create(atom, tc);
27012:     if (!pn)
27012:         return NULL;
27012:     return pn;
27012: }
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
27012: static bool
27012: RebindLets(JSParseNode *pn, JSTreeContext *tc)
27012: {
27012:     if (!pn)
27012:         return true;
27012: 
27012:     switch (pn->pn_arity) {
27012:       case PN_LIST:
27012:         for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
27012:             RebindLets(pn2, tc);
27012:         break;
27012: 
27012:       case PN_TERNARY:
27012:         RebindLets(pn->pn_kid1, tc);
27012:         RebindLets(pn->pn_kid2, tc);
27012:         RebindLets(pn->pn_kid3, tc);
27012:         break;
27012: 
27012:       case PN_BINARY:
27012:         RebindLets(pn->pn_left, tc);
27012:         RebindLets(pn->pn_right, tc);
27012:         break;
27012: 
27012:       case PN_UNARY:
27012:         RebindLets(pn->pn_kid, tc);
27012:         break;
27012: 
27012:       case PN_FUNC:
27012:         RebindLets(pn->pn_body, tc);
27012:         break;
27012: 
27012:       case PN_NAME:
27012:         RebindLets(pn->maybeExpr(), tc);
27012: 
27012:         if (pn->pn_defn) {
27012:             JS_ASSERT(pn->pn_blockid > tc->topStmt->blockid);
27012:         } else if (pn->pn_used) {
27012:             if (pn->pn_lexdef->pn_blockid == tc->topStmt->blockid) {
27012:                 ForgetUse(pn);
27012: 
27012:                 JSAtomListElement *ale = tc->decls.lookup(pn->pn_atom);
27346:                 if (ale) {
27345:                     while ((ale = ALE_NEXT(ale)) != NULL) {
27012:                         if (ALE_ATOM(ale) == pn->pn_atom) {
27012:                             LinkUseToDef(pn, ALE_DEFN(ale), tc);
27012:                             return true;
27012:                         }
27012:                     }
27346:                 }
27012: 
27012:                 ale = tc->lexdeps.lookup(pn->pn_atom);
27012:                 if (!ale) {
27012:                     ale = MakePlaceholder(pn, tc);
27012:                     if (!ale)
27012:                         return NULL;
27012: 
27012:                     JSDefinition *dn = ALE_DEFN(ale);
27012:                     dn->pn_type = TOK_NAME;
27012:                     dn->pn_op = JSOP_NOP;
27012:                 }
27012:                 LinkUseToDef(pn, ALE_DEFN(ale), tc);
27012:             }
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         RebindLets(pn->pn_tree, tc);
27012:         break;
27012:     }
27012: 
27012:     return true;
27012: }
27012: #endif /* JS_HAS_BLOCK_SCOPE */
27012: 
40239: JSParseNode *
40860: Parser::statement()
40221: {
40320:     TokenKind tt;
    1:     JSParseNode *pn, *pn1, *pn2, *pn3, *pn4;
    1:     JSStmtInfo stmtInfo, *stmt, *stmt2;
    1:     JSAtom *label;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
40854:     tt = tokenStream.getToken(TSF_OPERAND);
    1: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
40854:         tt = tokenStream.peekToken(TSF_KEYWORD_IS_NAME);
    1:         if (tt == TOK_DBLCOLON)
    1:             goto expression;
    1: #endif
40263:         return functionStmt();
    1: 
    1:       case TOK_IF:
    1:         /* An IF node has three kids: condition, then, and optional else. */
40232:         pn = TernaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn1 = condition();
    1:         if (!pn1)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_IF, -1);
40263:         pn2 = statement();
    1:         if (!pn2)
    1:             return NULL;
40854:         if (tokenStream.matchToken(TOK_ELSE, TSF_OPERAND)) {
    1:             stmtInfo.type = STMT_ELSE;
40263:             pn3 = statement();
    1:             if (!pn3)
    1:                 return NULL;
    1:             pn->pn_pos.end = pn3->pn_pos.end;
    1:         } else {
    1:             pn3 = NULL;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
    1:         }
27012:         PopStatement(tc);
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
    1:         return pn;
    1: 
    1:       case TOK_SWITCH:
    1:       {
    1:         JSParseNode *pn5, *saveBlock;
    1:         JSBool seenDefault = JS_FALSE;
    1: 
40232:         pn = BinaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
    1: 
    1:         /* pn1 points to the switch's discriminant. */
40263:         pn1 = parenExpr(NULL, NULL);
    1:         if (!pn1)
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
    1: 
27012:         /*
27012:          * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
27012:          * because that function states tc->topStmt->blockid.
27012:          */
27012:         js_PushStatement(tc, &stmtInfo, STMT_SWITCH, -1);
27012: 
    1:         /* pn2 is a list of case nodes. The default case has pn_left == NULL */
40232:         pn2 = ListNode::create(tc);
    1:         if (!pn2)
    1:             return NULL;
27012:         pn2->makeEmpty();
27012:         if (!GenerateBlockIdForStmtNode(pn2, tc))
27012:             return NULL;
    1:         saveBlock = tc->blockNode;
    1:         tc->blockNode = pn2;
    1: 
40354:         while ((tt = tokenStream.getToken()) != TOK_RC) {
    1:             switch (tt) {
    1:               case TOK_DEFAULT:
    1:                 if (seenDefault) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_DEFAULTS);
    1:                     return NULL;
    1:                 }
    1:                 seenDefault = JS_TRUE;
 1577:                 /* FALL THROUGH */
    1: 
    1:               case TOK_CASE:
40232:                 pn3 = BinaryNode::create(tc);
    1:                 if (!pn3)
    1:                     return NULL;
 1577:                 if (tt == TOK_CASE) {
40263:                     pn3->pn_left = expr();
    1:                     if (!pn3->pn_left)
    1:                         return NULL;
    1:                 }
27012:                 pn2->append(pn3);
    1:                 if (pn2->pn_count == JS_BIT(16)) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_CASES);
    1:                     return NULL;
    1:                 }
    1:                 break;
    1: 
    1:               case TOK_ERROR:
    1:                 return NULL;
    1: 
    1:               default:
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_SWITCH);
    1:                 return NULL;
    1:             }
    1:             MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
    1: 
40232:             pn4 = ListNode::create(tc);
    1:             if (!pn4)
    1:                 return NULL;
    1:             pn4->pn_type = TOK_LC;
27012:             pn4->makeEmpty();
40854:             while ((tt = tokenStream.peekToken(TSF_OPERAND)) != TOK_RC &&
    1:                    tt != TOK_CASE && tt != TOK_DEFAULT) {
    1:                 if (tt == TOK_ERROR)
    1:                     return NULL;
40263:                 pn5 = statement();
    1:                 if (!pn5)
    1:                     return NULL;
    1:                 pn4->pn_pos.end = pn5->pn_pos.end;
27012:                 pn4->append(pn5);
40854:             }
    1: 
    1:             /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
    1:             if (pn4->pn_head)
    1:                 pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
    1:             pn3->pn_pos.end = pn4->pn_pos.end;
    1:             pn3->pn_right = pn4;
    1:         }
    1: 
    1:         /*
    1:          * Handle the case where there was a let declaration in any case in
    1:          * the switch body, but not within an inner block.  If it replaced
    1:          * tc->blockNode with a new block node then we must refresh pn2 and
    1:          * then restore tc->blockNode.
    1:          */
    1:         if (tc->blockNode != pn2)
    1:             pn2 = tc->blockNode;
    1:         tc->blockNode = saveBlock;
27012:         PopStatement(tc);
    1: 
40270:         pn->pn_pos.end = pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         pn->pn_left = pn1;
    1:         pn->pn_right = pn2;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_WHILE:
40232:         pn = BinaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_WHILE_LOOP, -1);
40263:         pn2 = condition();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
40263:         pn2 = statement();
    1:         if (!pn2)
    1:             return NULL;
27012:         PopStatement(tc);
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
    1:         return pn;
    1: 
    1:       case TOK_DO:
40232:         pn = BinaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_DO_LOOP, -1);
40263:         pn2 = statement();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_left = pn2;
    1:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
40263:         pn2 = condition();
    1:         if (!pn2)
    1:             return NULL;
27012:         PopStatement(tc);
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
40239:         if (JSVERSION_NUMBER(context) != JSVERSION_ECMA_3) {
    1:             /*
    1:              * All legacy and extended versions must do automatic semicolon
    1:              * insertion after do-while.  See the testcase and discussion in
    1:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
    1:              */
40354:             (void) tokenStream.matchToken(TOK_SEMI);
    1:             return pn;
    1:         }
    1:         break;
    1: 
    1:       case TOK_FOR:
    1:       {
20413:         JSParseNode *pnseq = NULL;
    1: #if JS_HAS_BLOCK_SCOPE
20413:         JSParseNode *pnlet = NULL;
    1:         JSStmtInfo blockInfo;
    1: #endif
    1: 
    1:         /* A FOR node is binary, left is loop control and right is the body. */
40232:         pn = BinaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         js_PushStatement(tc, &stmtInfo, STMT_FOR_LOOP, -1);
    1: 
15613:         pn->pn_op = JSOP_ITER;
15613:         pn->pn_iflags = 0;
40354:         if (tokenStream.matchToken(TOK_NAME)) {
40270:             if (tokenStream.currentToken().t_atom == context->runtime->atomState.eachAtom)
15613:                 pn->pn_iflags = JSITER_FOREACH;
    1:             else
40354:                 tokenStream.ungetToken();
    1:         }
    1: 
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:         bool let = false;
27012: #endif
27012: 
    1:         if (tt == TOK_SEMI) {
15613:             if (pn->pn_iflags & JSITER_FOREACH)
    1:                 goto bad_for_each;
    1: 
    1:             /* No initializer -- set first kid of left sub-node to null. */
    1:             pn1 = NULL;
    1:         } else {
    1:             /*
    1:              * Set pn1 to a var list or an initializing expression.
    1:              *
    1:              * Set the TCF_IN_FOR_INIT flag during parsing of the first clause
    1:              * of the for statement.  This flag will be used by the RelExpr
    1:              * production; if it is set, then the 'in' keyword will not be
    1:              * recognized as an operator, leaving it available to be parsed as
    1:              * part of a for/in loop.
    1:              *
    1:              * A side effect of this restriction is that (unparenthesized)
    1:              * expressions involving an 'in' operator are illegal in the init
    1:              * clause of an ordinary for loop.
    1:              */
    1:             tc->flags |= TCF_IN_FOR_INIT;
    1:             if (tt == TOK_VAR) {
40354:                 (void) tokenStream.getToken();
40263:                 pn1 = variables(false);
    1: #if JS_HAS_BLOCK_SCOPE
    1:             } else if (tt == TOK_LET) {
27012:                 let = true;
40354:                 (void) tokenStream.getToken();
40354:                 if (tokenStream.peekToken() == TOK_LP) {
40263:                     pn1 = letBlock(JS_FALSE);
    1:                     tt = TOK_LEXICALSCOPE;
    1:                 } else {
40239:                     pnlet = PushLexicalScope(context, &tokenStream, tc, &blockInfo);
    1:                     if (!pnlet)
    1:                         return NULL;
 9976:                     blockInfo.flags |= SIF_FOR_BLOCK;
40263:                     pn1 = variables(false);
    1:                 }
    1: #endif
    1:             } else {
40263:                 pn1 = expr();
    1:             }
    1:             tc->flags &= ~TCF_IN_FOR_INIT;
    1:             if (!pn1)
    1:                 return NULL;
    1:         }
    1: 
    1:         /*
    1:          * We can be sure that it's a for/in loop if there's still an 'in'
    1:          * keyword here, even if JavaScript recognizes 'in' as an operator,
    1:          * as we've excluded 'in' from being parsed in RelExpr by setting
    1:          * the TCF_IN_FOR_INIT flag in our JSTreeContext.
    1:          */
40354:         if (pn1 && tokenStream.matchToken(TOK_IN)) {
15613:             pn->pn_iflags |= JSITER_ENUMERATE;
    1:             stmtInfo.type = STMT_FOR_IN_LOOP;
    1: 
    1:             /* Check that the left side of the 'in' is valid. */
40320:             JS_ASSERT(!TokenKindIsDecl(tt) || PN_TYPE(pn1) == tt);
40320:             if (TokenKindIsDecl(tt)
    1:                 ? (pn1->pn_count > 1 || pn1->pn_op == JSOP_DEFCONST
    1: #if JS_HAS_DESTRUCTURING
40239:                    || (JSVERSION_NUMBER(context) == JSVERSION_1_7 &&
15613:                        pn->pn_op == JSOP_ITER &&
15613:                        !(pn->pn_iflags & JSITER_FOREACH) &&
    1:                        (pn1->pn_head->pn_type == TOK_RC ||
    1:                         (pn1->pn_head->pn_type == TOK_RB &&
    1:                          pn1->pn_head->pn_count != 2) ||
    1:                         (pn1->pn_head->pn_type == TOK_ASSIGN &&
    1:                          (pn1->pn_head->pn_left->pn_type != TOK_RB ||
    1:                           pn1->pn_head->pn_left->pn_count != 2))))
    1: #endif
    1:                   )
    1:                 : (pn1->pn_type != TOK_NAME &&
    1:                    pn1->pn_type != TOK_DOT &&
    1: #if JS_HAS_DESTRUCTURING
40239:                    ((JSVERSION_NUMBER(context) == JSVERSION_1_7 &&
15613:                      pn->pn_op == JSOP_ITER &&
15613:                      !(pn->pn_iflags & JSITER_FOREACH))
    1:                     ? (pn1->pn_type != TOK_RB || pn1->pn_count != 2)
    1:                     : (pn1->pn_type != TOK_RB && pn1->pn_type != TOK_RC)) &&
    1: #endif
    1:                    pn1->pn_type != TOK_LP &&
    1: #if JS_HAS_XML_SUPPORT
    1:                    (pn1->pn_type != TOK_UNARYOP ||
    1:                     pn1->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:                    pn1->pn_type != TOK_LB)) {
42671:                 reportErrorNumber(pn1, JSREPORT_ERROR, JSMSG_BAD_FOR_LEFTSIDE);
    1:                 return NULL;
    1:             }
    1: 
20413:             /* pn2 points to the name or destructuring pattern on in's left. */
20413:             pn2 = NULL;
27012:             uintN dflag = PND_ASSIGNED;
20413: 
40320:             if (TokenKindIsDecl(tt)) {
    1:                 /* Tell js_EmitTree(TOK_VAR) that pn1 is part of a for/in. */
27012:                 pn1->pn_xflags |= PNX_FORINVAR;
    1: 
    1:                 /*
20413:                  * Rewrite 'for (<decl> x = i in o)' where <decl> is 'let',
20413:                  * 'var', or 'const' to hoist the initializer or the entire
20413:                  * decl out of the loop head. TOK_VAR is the type for both
20413:                  * 'var' and 'const'.
    1:                  */
    1:                 pn2 = pn1->pn_head;
27012:                 if ((pn2->pn_type == TOK_NAME && pn2->maybeExpr())
20413: #if JS_HAS_DESTRUCTURING
20413:                     || pn2->pn_type == TOK_ASSIGN
20413: #endif
20413:                     ) {
40232:                     pnseq = ListNode::create(tc);
20413:                     if (!pnseq)
20413:                         return NULL;
20413:                     pnseq->pn_type = TOK_SEQ;
20413:                     pnseq->pn_pos.begin = pn->pn_pos.begin;
27012: 
27012: #if JS_HAS_BLOCK_SCOPE
20413:                     if (tt == TOK_LET) {
20413:                         /*
20413:                          * Hoist just the 'i' from 'for (let x = i in o)' to
20413:                          * before the loop, glued together via pnseq.
20413:                          */
40232:                         pn3 = UnaryNode::create(tc);
20413:                         if (!pn3)
20413:                             return NULL;
20413:                         pn3->pn_type = TOK_SEMI;
20413:                         pn3->pn_op = JSOP_NOP;
20413: #if JS_HAS_DESTRUCTURING
20413:                         if (pn2->pn_type == TOK_ASSIGN) {
20413:                             pn4 = pn2->pn_right;
20413:                             pn2 = pn1->pn_head = pn2->pn_left;
20413:                         } else
20413: #endif
20413:                         {
20413:                             pn4 = pn2->pn_expr;
20413:                             pn2->pn_expr = NULL;
20413:                         }
27012:                         if (!RebindLets(pn4, tc))
27012:                             return NULL;
20413:                         pn3->pn_pos = pn4->pn_pos;
20413:                         pn3->pn_kid = pn4;
27012:                         pnseq->initList(pn3);
27012:                     } else
27012: #endif /* JS_HAS_BLOCK_SCOPE */
27012:                     {
27012:                         dflag = PND_INITIALIZED;
27012: 
20413:                         /*
20413:                          * All of 'var x = i' is hoisted above 'for (x in o)',
20413:                          * so clear PNX_FORINVAR.
20413:                          *
20413:                          * Request JSOP_POP here since the var is for a simple
20413:                          * name (it is not a destructuring binding's left-hand
20413:                          * side) and it has an initializer.
20413:                          */
27012:                         pn1->pn_xflags &= ~PNX_FORINVAR;
27012:                         pn1->pn_xflags |= PNX_POPVAR;
27012:                         pnseq->initList(pn1);
20413: 
20413: #if JS_HAS_DESTRUCTURING
20413:                         if (pn2->pn_type == TOK_ASSIGN) {
27012:                             pn1 = CloneParseTree(pn2->pn_left, tc);
20413:                             if (!pn1)
20413:                                 return NULL;
20413:                         } else
20413: #endif
20413:                         {
27012:                             JS_ASSERT(pn2->pn_type == TOK_NAME);
40232:                             pn1 = NameNode::create(pn2->pn_atom, tc);
20413:                             if (!pn1)
20413:                                 return NULL;
20413:                             pn1->pn_type = TOK_NAME;
20413:                             pn1->pn_op = JSOP_NAME;
20413:                             pn1->pn_pos = pn2->pn_pos;
27012:                             if (pn2->pn_defn)
27012:                                 LinkUseToDef(pn1, (JSDefinition *) pn2, tc);
20413:                         }
20413:                         pn2 = pn1;
20413:                     }
20413:                 }
20413:             }
20413: 
20413:             if (!pn2) {
    1:                 pn2 = pn1;
 1577:                 if (pn2->pn_type == TOK_LP &&
40239:                     !MakeSetCall(context, pn2, tc, JSMSG_BAD_LEFTSIDE_OF_ASS)) {
 1577:                     return NULL;
 1577:                 }
    1: #if JS_HAS_XML_SUPPORT
    1:                 if (pn2->pn_type == TOK_UNARYOP)
    1:                     pn2->pn_op = JSOP_BINDXMLNAME;
    1: #endif
    1:             }
    1: 
    1:             switch (pn2->pn_type) {
    1:               case TOK_NAME:
    1:                 /* Beware 'for (arguments in ...)' with or without a 'var'. */
40239:                 NoteLValue(context, pn2, tc, dflag);
    1:                 break;
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_ASSIGN:
    1:                 pn2 = pn2->pn_left;
    1:                 JS_ASSERT(pn2->pn_type == TOK_RB || pn2->pn_type == TOK_RC);
    1:                 /* FALL THROUGH */
    1:               case TOK_RB:
    1:               case TOK_RC:
    1:                 /* Check for valid lvalues in var-less destructuring for-in. */
40239:                 if (pn1 == pn2 && !CheckDestructuring(context, NULL, pn2, NULL, tc))
40239:                     return NULL;
40239: 
40239:                 if (JSVERSION_NUMBER(context) == JSVERSION_1_7) {
 1599:                     /*
 1599:                      * Destructuring for-in requires [key, value] enumeration
 1599:                      * in JS1.7.
 1599:                      */
15613:                     JS_ASSERT(pn->pn_op == JSOP_ITER);
15613:                     if (!(pn->pn_iflags & JSITER_FOREACH))
15613:                         pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 1599:                 }
    1:                 break;
    1: #endif
    1: 
    1:               default:;
    1:             }
    1: 
27012:             /*
27012:              * Parse the object expression as the right operand of 'in', first
27012:              * removing the top statement from the statement-stack if this is a
27012:              * 'for (let x in y)' loop.
27012:              */
27012: #if JS_HAS_BLOCK_SCOPE
27012:             JSStmtInfo *save = tc->topStmt;
27012:             if (let)
27012:                 tc->topStmt = save->down;
27012: #endif
40263:             pn2 = expr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (let)
27012:                 tc->topStmt = save;
27012: #endif
27012: 
40232:             pn2 = JSParseNode::newBinaryOrAppend(TOK_IN, JSOP_NOP, pn1, pn2, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn->pn_left = pn2;
    1:         } else {
15613:             if (pn->pn_iflags & JSITER_FOREACH)
    1:                 goto bad_for_each;
    1:             pn->pn_op = JSOP_NOP;
    1: 
    1:             /* Parse the loop condition or null into pn2. */
    1:             MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
40854:             tt = tokenStream.peekToken(TSF_OPERAND);
    1:             if (tt == TOK_SEMI) {
    1:                 pn2 = NULL;
    1:             } else {
40263:                 pn2 = expr();
    1:                 if (!pn2)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Parse the update expression or null into pn3. */
    1:             MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
40854:             tt = tokenStream.peekToken(TSF_OPERAND);
    1:             if (tt == TOK_RP) {
    1:                 pn3 = NULL;
    1:             } else {
40263:                 pn3 = expr();
    1:                 if (!pn3)
    1:                     return NULL;
    1:             }
    1: 
20902:             /* Build the FORHEAD node to use as the left kid of pn. */
40232:             pn4 = TernaryNode::create(tc);
    1:             if (!pn4)
    1:                 return NULL;
20902:             pn4->pn_type = TOK_FORHEAD;
    1:             pn4->pn_op = JSOP_NOP;
    1:             pn4->pn_kid1 = pn1;
    1:             pn4->pn_kid2 = pn2;
    1:             pn4->pn_kid3 = pn3;
    1:             pn->pn_left = pn4;
    1:         }
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
    1: 
    1:         /* Parse the loop body into pn->pn_right. */
40263:         pn2 = statement();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_right = pn2;
    1: 
    1:         /* Record the absolute line number for source note emission. */
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:         if (pnlet) {
27012:             PopStatement(tc);
    1:             pnlet->pn_expr = pn;
    1:             pn = pnlet;
    1:         }
    1: #endif
20413:         if (pnseq) {
20413:             pnseq->pn_pos.end = pn->pn_pos.end;
27012:             pnseq->append(pn);
20413:             pn = pnseq;
20413:         }
27012:         PopStatement(tc);
    1:         return pn;
    1: 
    1:       bad_for_each:
42671:         reportErrorNumber(pn, JSREPORT_ERROR, JSMSG_BAD_FOR_EACH_LOOP);
    1:         return NULL;
    1:       }
    1: 
    1:       case TOK_TRY: {
    1:         JSParseNode *catchList, *lastCatch;
    1: 
    1:         /*
    1:          * try nodes are ternary.
40239:          * kid1 is the try statement
    1:          * kid2 is the catch node list or null
40239:          * kid3 is the finally statement
    1:          *
    1:          * catch nodes are ternary.
    1:          * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
    1:          * kid2 is the catch guard or null if no guard
    1:          * kid3 is the catch block
    1:          *
    1:          * catch lvalue nodes are either:
    1:          *   TOK_NAME for a single identifier
    1:          *   TOK_RB or TOK_RC for a destructuring left-hand side
    1:          *
40239:          * finally nodes are TOK_LC statement lists.
40221:          */
40232:         pn = TernaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_op = JSOP_NOP;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
27012:         if (!PushBlocklikeStatement(&stmtInfo, STMT_TRY, tc))
27012:             return NULL;
40263:         pn->pn_kid1 = statements();
    1:         if (!pn->pn_kid1)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
27012:         PopStatement(tc);
    1: 
    1:         catchList = NULL;
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_CATCH) {
40232:             catchList = ListNode::create(tc);
    1:             if (!catchList)
    1:                 return NULL;
    1:             catchList->pn_type = TOK_RESERVED;
27012:             catchList->makeEmpty();
    1:             lastCatch = NULL;
    1: 
    1:             do {
    1:                 JSParseNode *pnblock;
    1:                 BindData data;
    1: 
    1:                 /* Check for another catch after unconditional catch. */
    1:                 if (lastCatch && !lastCatch->pn_kid2) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_AFTER_GENERAL);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 /*
    1:                  * Create a lexical scope node around the whole catch clause,
    1:                  * including the head.
    1:                  */
40239:                 pnblock = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
    1:                 if (!pnblock)
    1:                     return NULL;
    1:                 stmtInfo.type = STMT_CATCH;
    1: 
    1:                 /*
    1:                  * Legal catch forms are:
    1:                  *   catch (lhs)
    1:                  *   catch (lhs if <boolean_expression>)
    1:                  * where lhs is a name or a destructuring left-hand side.
    1:                  * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
    1:                  */
40232:                 pn2 = TernaryNode::create(tc);
    1:                 if (!pn2)
    1:                     return NULL;
    1:                 pnblock->pn_expr = pn2;
    1:                 MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
    1: 
    1:                 /*
    1:                  * Contrary to ECMA Ed. 3, the catch variable is lexically
    1:                  * scoped, not a property of a new Object instance.  This is
    1:                  * an intentional change that anticipates ECMA Ed. 4.
    1:                  */
    1:                 data.pn = NULL;
    1:                 data.op = JSOP_NOP;
    1:                 data.binder = BindLet;
27012:                 data.let.overflow = JSMSG_TOO_MANY_CATCH_VARS;
    1: 
40354:                 tt = tokenStream.getToken();
    1:                 switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:                   case TOK_LB:
    1:                   case TOK_LC:
40263:                     pn3 = destructuringExpr(&data, tt);
    1:                     if (!pn3)
    1:                         return NULL;
    1:                     break;
    1: #endif
    1: 
    1:                   case TOK_NAME:
40270:                     label = tokenStream.currentToken().t_atom;
33754:                     pn3 = NewBindingNode(label, tc, true);
27012:                     if (!pn3)
27012:                         return NULL;
27012:                     data.pn = pn3;
40239:                     if (!data.binder(context, &data, label, tc))
26970:                         return NULL;
    1:                     break;
    1: 
    1:                   default:
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_IDENTIFIER);
    1:                     return NULL;
    1:                 }
    1: 
    1:                 pn2->pn_kid1 = pn3;
    1: #if JS_HAS_CATCH_GUARD
    1:                 /*
    1:                  * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
    1:                  * to avoid conflicting with the JS2/ECMAv4 type annotation
    1:                  * catchguard syntax.
    1:                  */
40354:                 if (tokenStream.matchToken(TOK_IF)) {
40263:                     pn2->pn_kid2 = expr();
    1:                     if (!pn2->pn_kid2)
    1:                         return NULL;
    1:                 }
    1: #endif
    1:                 MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
    1: 
    1:                 MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
40263:                 pn2->pn_kid3 = statements();
    1:                 if (!pn2->pn_kid3)
    1:                     return NULL;
    1:                 MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
27012:                 PopStatement(tc);
27012: 
27012:                 catchList->append(pnblock);
    1:                 lastCatch = pn2;
40854:                 tt = tokenStream.getToken(TSF_OPERAND);
    1:             } while (tt == TOK_CATCH);
    1:         }
    1:         pn->pn_kid2 = catchList;
    1: 
    1:         if (tt == TOK_FINALLY) {
    1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
27012:             if (!PushBlocklikeStatement(&stmtInfo, STMT_FINALLY, tc))
27012:                 return NULL;
40263:             pn->pn_kid3 = statements();
    1:             if (!pn->pn_kid3)
    1:                 return NULL;
    1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
27012:             PopStatement(tc);
    1:         } else {
40354:             tokenStream.ungetToken();
    1:         }
    1:         if (!catchList && !pn->pn_kid3) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_OR_FINALLY);
    1:             return NULL;
    1:         }
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_THROW:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
40854:         tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:         if (tt == TOK_ERROR)
    1:             return NULL;
    1:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             return NULL;
    1:         }
    1: 
40263:         pn2 = expr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_op = JSOP_THROW;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
    1:       case TOK_CATCH:
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_WITHOUT_TRY);
    1:         return NULL;
    1: 
    1:       case TOK_FINALLY:
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_FINALLY_WITHOUT_TRY);
    1:         return NULL;
    1: 
    1:       case TOK_BREAK:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40239:         if (!MatchLabel(context, &tokenStream, pn))
    1:             return NULL;
    1:         stmt = tc->topStmt;
    1:         label = pn->pn_atom;
    1:         if (label) {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LABEL_NOT_FOUND);
    1:                     return NULL;
    1:                 }
27012:                 if (stmt->type == STMT_LABEL && stmt->label == label)
    1:                     break;
    1:             }
    1:         } else {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOUGH_BREAK);
    1:                     return NULL;
    1:                 }
    1:                 if (STMT_IS_LOOP(stmt) || stmt->type == STMT_SWITCH)
    1:                     break;
    1:             }
    1:         }
    1:         if (label)
40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         break;
    1: 
    1:       case TOK_CONTINUE:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40239:         if (!MatchLabel(context, &tokenStream, pn))
    1:             return NULL;
    1:         stmt = tc->topStmt;
    1:         label = pn->pn_atom;
    1:         if (label) {
    1:             for (stmt2 = NULL; ; stmt = stmt->down) {
    1:                 if (!stmt) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LABEL_NOT_FOUND);
    1:                     return NULL;
    1:                 }
    1:                 if (stmt->type == STMT_LABEL) {
27012:                     if (stmt->label == label) {
    1:                         if (!stmt2 || !STMT_IS_LOOP(stmt2)) {
42671:                             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_CONTINUE);
    1:                             return NULL;
    1:                         }
    1:                         break;
    1:                     }
    1:                 } else {
    1:                     stmt2 = stmt;
    1:                 }
    1:             }
    1:         } else {
    1:             for (; ; stmt = stmt->down) {
    1:                 if (!stmt) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_CONTINUE);
    1:                     return NULL;
    1:                 }
    1:                 if (STMT_IS_LOOP(stmt))
    1:                     break;
    1:             }
    1:         }
    1:         if (label)
40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         break;
    1: 
    1:       case TOK_WITH:
52554:       {
35305:         /*
35305:          * In most cases, we want the constructs forbidden in strict mode
35305:          * code to be a subset of those that JSOPTION_STRICT warns about, and
40320:          * we should use ReportStrictModeError.  However, 'with' is the sole
35305:          * instance of a construct that is forbidden in strict mode code, but
35305:          * doesn't even merit a warning under JSOPTION_STRICT.  See
35305:          * https://bugzilla.mozilla.org/show_bug.cgi?id=514576#c1.
35305:          */
35305:         if (tc->flags & TCF_STRICT_MODE_CODE) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_STRICT_CODE_WITH);
35305:             return NULL;
35305:         }
35305: 
40232:         pn = BinaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
40263:         pn2 = parenExpr(NULL, NULL);
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
    1:         pn->pn_left = pn2;
    1: 
52554:         JSParseNode *oldWith = tc->innermostWith;
52554:         tc->innermostWith = pn;
52554: 
    1:         js_PushStatement(tc, &stmtInfo, STMT_WITH, -1);
40263:         pn2 = statement();
    1:         if (!pn2)
    1:             return NULL;
27012:         PopStatement(tc);
    1: 
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_right = pn2;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
52554:         tc->innermostWith = oldWith;
52554: 
52554:         /*
52554:          * Make sure to deoptimize lexical dependencies inside the |with|
52554:          * to safely optimize binding globals (see bug 561923).
52554:          */
52554:         JSAtomListIterator iter(&tc->lexdeps);
52554:         while (JSAtomListElement *ale = iter()) {
52554:             JSDefinition *lexdep = ALE_DEFN(ale)->resolve();
52554:             DeoptimizeUsesWithin(lexdep, pn->pn_pos);
52554:         }
52554: 
    1:         return pn;
52554:       }
    1: 
    1:       case TOK_VAR:
40263:         pn = variables(false);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Tell js_EmitTree to generate a final POP. */
27012:         pn->pn_xflags |= PNX_POPVAR;
    1:         break;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:       case TOK_LET:
    1:       {
    1:         JSObject *obj;
27012:         JSObjectBox *blockbox;
    1: 
    1:         /* Check for a let statement or let expression. */
40354:         if (tokenStream.peekToken() == TOK_LP) {
40263:             pn = letBlock(JS_TRUE);
    1:             if (!pn || pn->pn_op == JSOP_LEAVEBLOCK)
    1:                 return pn;
    1: 
    1:             /* Let expressions require automatic semicolon insertion. */
    1:             JS_ASSERT(pn->pn_type == TOK_SEMI ||
    1:                       pn->pn_op == JSOP_LEAVEBLOCKEXPR);
    1:             break;
    1:         }
    1: 
    1:         /*
 9976:          * This is a let declaration. We must be directly under a block per
 9976:          * the proposed ES4 specs, but not an implicit block created due to
 9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
 9976:          * JSStmtInfo be our scope. Further let declarations in this block
 9976:          * will find this scope statement and use the same block object.
 9976:          *
 9976:          * If we are the first let declaration in this block (i.e., when the
 9976:          * enclosing maybe-scope JSStmtInfo isn't yet a scope statement) then
 9976:          * we also need to set tc->blockNode to be our TOK_LEXICALSCOPE.
    1:          */
 9832:         stmt = tc->topStmt;
 9976:         if (stmt &&
 9976:             (!STMT_MAYBE_SCOPE(stmt) || (stmt->flags & SIF_FOR_BLOCK))) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LET_DECL_NOT_IN_BLOCK);
 9832:             return NULL;
    1:         }
    1: 
    1:         if (stmt && (stmt->flags & SIF_SCOPE)) {
27012:             JS_ASSERT(tc->blockChain == stmt->blockObj);
    1:             obj = tc->blockChain;
    1:         } else {
16379:             if (!stmt || (stmt->flags & SIF_BODY_BLOCK)) {
    1:                 /*
16379:                  * ES4 specifies that let at top level and at body-block scope
16379:                  * does not shadow var, so convert back to var.
    1:                  */
40854:                 tokenStream.mungeCurrentToken(TOK_VAR, JSOP_DEFVAR);
40239: 
40263:                 pn = variables(false);
    1:                 if (!pn)
    1:                     return NULL;
27012:                 pn->pn_xflags |= PNX_POPVAR;
    1:                 break;
    1:             }
    1: 
18084:             /*
18084:              * Some obvious assertions here, but they may help clarify the
18084:              * situation. This stmt is not yet a scope, so it must not be a
27012:              * catch block (catch is a lexical scope by definition).
18084:              */
18084:             JS_ASSERT(!(stmt->flags & SIF_SCOPE));
18084:             JS_ASSERT(stmt != tc->topScopeStmt);
18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
18084:                       stmt->type == STMT_SWITCH ||
18084:                       stmt->type == STMT_TRY ||
18084:                       stmt->type == STMT_FINALLY);
18084:             JS_ASSERT(!stmt->downScope);
18084: 
    1:             /* Convert the block statement into a scope statement. */
40860:             JSObject *obj = js_NewBlockObject(tc->parser->context);
    1:             if (!obj)
    1:                 return NULL;
27012: 
40860:             blockbox = tc->parser->newObjectBox(obj);
27012:             if (!blockbox)
    1:                 return NULL;
    1: 
    1:             /*
    1:              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
    1:              * list stack, if it isn't already there.  If it is there, but it
    1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
    1:              * block.
    1:              */
    1:             stmt->flags |= SIF_SCOPE;
 9832:             stmt->downScope = tc->topScopeStmt;
 9832:             tc->topScopeStmt = stmt;
18084:             JS_SCOPE_DEPTH_METERING(++tc->scopeDepth > tc->maxScopeDepth &&
18084:                                     (tc->maxScopeDepth = tc->scopeDepth));
    1: 
39930:             obj->setParent(tc->blockChain);
    1:             tc->blockChain = obj;
27012:             stmt->blockObj = obj;
    1: 
    1: #ifdef DEBUG
    1:             pn1 = tc->blockNode;
    1:             JS_ASSERT(!pn1 || pn1->pn_type != TOK_LEXICALSCOPE);
    1: #endif
    1: 
    1:             /* Create a new lexical scope node for these statements. */
40232:             pn1 = LexicalScopeNode::create(tc);
    1:             if (!pn1)
    1:                 return NULL;
    1: 
    1:             pn1->pn_type = TOK_LEXICALSCOPE;
    1:             pn1->pn_op = JSOP_LEAVEBLOCK;
    1:             pn1->pn_pos = tc->blockNode->pn_pos;
27012:             pn1->pn_objbox = blockbox;
    1:             pn1->pn_expr = tc->blockNode;
27012:             pn1->pn_blockid = tc->blockNode->pn_blockid;
    1:             tc->blockNode = pn1;
    1:         }
    1: 
40263:         pn = variables(false);
    1:         if (!pn)
    1:             return NULL;
27012:         pn->pn_xflags = PNX_POPVAR;
    1:         break;
    1:       }
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
    1:       case TOK_RETURN:
40263:         pn = returnOrYield(false);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LC:
    1:       {
    1:         uintN oldflags;
    1: 
    1:         oldflags = tc->flags;
    1:         tc->flags = oldflags & ~TCF_HAS_FUNCTION_STMT;
27012:         if (!PushBlocklikeStatement(&stmtInfo, STMT_BLOCK, tc))
27012:             return NULL;
40263:         pn = statements();
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
27012:         PopStatement(tc);
    1: 
    1:         /*
    1:          * If we contain a function statement and our container is top-level
    1:          * or another block, flag pn to preserve braces when decompiling.
    1:          */
    1:         if ((tc->flags & TCF_HAS_FUNCTION_STMT) &&
    1:             (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)) {
27012:             pn->pn_xflags |= PNX_NEEDBRACES;
    1:         }
    1:         tc->flags = oldflags | (tc->flags & (TCF_FUN_FLAGS | TCF_RETURN_FLAGS));
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_EOL:
    1:       case TOK_SEMI:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         return pn;
    1: 
    1: #if JS_HAS_DEBUGGER_KEYWORD
    1:       case TOK_DEBUGGER:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_DEBUGGER;
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:         break;
    1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_DEFAULT:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40354:         if (!tokenStream.matchToken(TOK_NAME) ||
40270:             tokenStream.currentToken().t_atom != context->runtime->atomState.xmlAtom ||
40354:             !tokenStream.matchToken(TOK_NAME) ||
40270:             tokenStream.currentToken().t_atom != context->runtime->atomState.namespaceAtom ||
40354:             !tokenStream.matchToken(TOK_ASSIGN) ||
40270:             tokenStream.currentToken().t_op != JSOP_NOP) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_DEFAULT_XML_NAMESPACE);
    1:             return NULL;
    1:         }
32547: 
32547:         /* Is this an E4X dagger I see before me? */
32547:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
40263:         pn2 = expr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_op = JSOP_DEFXMLNS;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: #endif
    1: 
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
    1: #if JS_HAS_XML_SUPPORT
    1:       expression:
    1: #endif
40354:         tokenStream.ungetToken();
40263:         pn2 = expr();
    1:         if (!pn2)
    1:             return NULL;
    1: 
40354:         if (tokenStream.peekToken() == TOK_COLON) {
    1:             if (pn2->pn_type != TOK_NAME) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_LABEL);
    1:                 return NULL;
    1:             }
    1:             label = pn2->pn_atom;
    1:             for (stmt = tc->topStmt; stmt; stmt = stmt->down) {
27012:                 if (stmt->type == STMT_LABEL && stmt->label == label) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_DUPLICATE_LABEL);
    1:                     return NULL;
    1:                 }
    1:             }
27012:             ForgetUse(pn2);
27012: 
40354:             (void) tokenStream.getToken();
    1: 
    1:             /* Push a label struct and parse the statement. */
    1:             js_PushStatement(tc, &stmtInfo, STMT_LABEL, -1);
27012:             stmtInfo.label = label;
40263:             pn = statement();
    1:             if (!pn)
    1:                 return NULL;
    1: 
    1:             /* Normalize empty statement to empty block for the decompiler. */
    1:             if (pn->pn_type == TOK_SEMI && !pn->pn_kid) {
    1:                 pn->pn_type = TOK_LC;
    1:                 pn->pn_arity = PN_LIST;
27012:                 pn->makeEmpty();
    1:             }
    1: 
    1:             /* Pop the label, set pn_expr, and return early. */
27012:             PopStatement(tc);
    1:             pn2->pn_type = TOK_COLON;
    1:             pn2->pn_pos.end = pn->pn_pos.end;
    1:             pn2->pn_expr = pn;
    1:             return pn2;
    1:         }
    1: 
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_SEMI;
    1:         pn->pn_pos = pn2->pn_pos;
    1:         pn->pn_kid = pn2;
32658: 
37685:         switch (PN_TYPE(pn2)) {
37685:           case TOK_LP:
37685:             /*
37685:              * Flag lambdas immediately applied as statements as instances of
37685:              * the JS "module pattern". See CheckForImmediatelyAppliedLambda.
37685:              */
37685:             if (PN_TYPE(pn2->pn_head) == TOK_FUNCTION &&
37685:                 !pn2->pn_head->pn_funbox->node->isFunArg()) {
38549:                 pn2->pn_head->pn_funbox->tcflags |= TCF_FUN_MODULE_PATTERN;
37685:             }
37685:             break;
37685:           case TOK_ASSIGN:
37685:             /*
37685:              * Keep track of all apparent methods created by assignments such
37685:              * as this.foo = function (...) {...} in a function that could end
40860:              * up a constructor function. See Parser::setFunctionKinds.
37685:              */
37685:             if (tc->funbox &&
37685:                 PN_OP(pn2) == JSOP_NOP &&
32658:                 PN_OP(pn2->pn_left) == JSOP_SETPROP &&
37685:                 PN_OP(pn2->pn_left->pn_expr) == JSOP_THIS &&
37685:                 PN_OP(pn2->pn_right) == JSOP_LAMBDA) {
37685:                 JS_ASSERT(!pn2->pn_defn);
37685:                 JS_ASSERT(!pn2->pn_used);
37685:                 pn2->pn_right->pn_link = tc->funbox->methods;
37685:                 tc->funbox->methods = pn2->pn_right;
37685:             }
37685:             break;
37685:           default:;
32658:         }
    1:         break;
    1:     }
    1: 
    1:     /* Check termination of this primitive statement. */
40239:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::variables(bool inLetHead)
40221: {
40320:     TokenKind tt;
27012:     bool let;
    1:     JSStmtInfo *scopeStmt;
    1:     BindData data;
    1:     JSParseNode *pn, *pn2;
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * The three options here are:
    1:      * - TOK_LET: We are parsing a let declaration.
    1:      * - TOK_LP: We are parsing the head of a let block.
    1:      * - Otherwise, we're parsing var declarations.
    1:      */
40270:     tt = tokenStream.currentToken().type;
    1:     let = (tt == TOK_LET || tt == TOK_LP);
    1:     JS_ASSERT(let || tt == TOK_VAR);
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:     bool popScope = (inLetHead || (let && (tc->flags & TCF_IN_FOR_INIT)));
27012:     JSStmtInfo *save = tc->topStmt, *saveScope = tc->topScopeStmt;
27012: #endif
27012: 
40239:     /* Make sure that statement set up the tree context correctly. */
    1:     scopeStmt = tc->topScopeStmt;
    1:     if (let) {
    1:         while (scopeStmt && !(scopeStmt->flags & SIF_SCOPE)) {
    1:             JS_ASSERT(!STMT_MAYBE_SCOPE(scopeStmt));
    1:             scopeStmt = scopeStmt->downScope;
    1:         }
    1:         JS_ASSERT(scopeStmt);
    1:     }
    1: 
40270:     data.op = let ? JSOP_NOP : tokenStream.currentToken().t_op;
40232:     pn = ListNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = data.op;
27012:     pn->makeEmpty();
27012: 
27012:     /*
27012:      * SpiderMonkey const is really "write once per initialization evaluation"
27012:      * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
27012:      * this code will change soon.
    1:      */
    1:     if (let) {
27012:         JS_ASSERT(tc->blockChain == scopeStmt->blockObj);
 8444:         data.binder = BindLet;
27012:         data.let.overflow = JSMSG_TOO_MANY_LOCALS;
    1:     } else {
 8444:         data.binder = BindVarOrConst;
    1:     }
    1: 
    1:     do {
40354:         tt = tokenStream.getToken();
    1: #if JS_HAS_DESTRUCTURING
    1:         if (tt == TOK_LB || tt == TOK_LC) {
33753:             tc->flags |= TCF_DECL_DESTRUCTURING;
40263:             pn2 = primaryExpr(tt, JS_FALSE);
33753:             tc->flags &= ~TCF_DECL_DESTRUCTURING;
    1:             if (!pn2)
    1:                 return NULL;
    1: 
40239:             if (!CheckDestructuring(context, &data, pn2, NULL, tc))
28995:                 return NULL;
    1:             if ((tc->flags & TCF_IN_FOR_INIT) &&
40354:                 tokenStream.peekToken() == TOK_IN) {
27012:                 pn->append(pn2);
    1:                 continue;
    1:             }
    1: 
    1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
40270:             if (tokenStream.currentToken().t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
40263:             JSParseNode *init = assignExpr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012: 
28995:             if (!init || !UndominateInitializers(pn2, init, tc))
28995:                 return NULL;
28995: 
40232:             pn2 = JSParseNode::newBinaryOrAppend(TOK_ASSIGN, JSOP_NOP, pn2, init, tc);
28995:             if (!pn2)
28995:                 return NULL;
27012:             pn->append(pn2);
    1:             continue;
    1:         }
27012: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1:         if (tt != TOK_NAME) {
27012:             if (tt != TOK_ERROR) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NO_VARIABLE_NAME);
27012:             }
27012:             return NULL;
27012:         }
27012: 
40270:         atom = tokenStream.currentToken().t_atom;
33754:         pn2 = NewBindingNode(atom, tc, let);
27012:         if (!pn2)
27012:             return NULL;
27012:         if (data.op == JSOP_DEFCONST)
27012:             pn2->pn_dflags |= PND_CONST;
27012:         data.pn = pn2;
40239:         if (!data.binder(context, &data, atom, tc))
26970:             return NULL;
27012:         pn->append(pn2);
    1: 
40354:         if (tokenStream.matchToken(TOK_ASSIGN)) {
40270:             if (tokenStream.currentToken().t_op != JSOP_NOP)
    1:                 goto bad_var_init;
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
40263:             JSParseNode *init = assignExpr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012:             if (!init)
27012:                 return NULL;
27012: 
27012:             if (pn2->pn_used) {
27012:                 pn2 = MakeAssignment(pn2, init, tc);
27012:                 if (!pn2)
27012:                     return NULL;
27012:             } else {
27012:                 pn2->pn_expr = init;
27012:             }
27012: 
52825:             JS_ASSERT_IF((pn2->pn_dflags & PND_GVAR), PN_OP(pn2) == JSOP_GETGLOBAL);
52555: 
27012:             pn2->pn_op = (PN_OP(pn2) == JSOP_ARGUMENTS)
27012:                          ? JSOP_SETNAME
27012:                          : (pn2->pn_dflags & PND_GVAR)
52825:                          ? JSOP_SETGLOBAL
27012:                          : (pn2->pn_dflags & PND_BOUND)
27012:                          ? JSOP_SETLOCAL
27012:                          : (data.op == JSOP_DEFCONST)
    1:                          ? JSOP_SETCONST
    1:                          : JSOP_SETNAME;
27012: 
40239:             NoteLValue(context, pn2, tc, data.fresh ? PND_INITIALIZED : PND_ASSIGNED);
27012: 
27012:             /* The declarator's position must include the initializer. */
27012:             pn2->pn_pos.end = init->pn_pos.end;
27012: 
41884:             if (tc->inFunction() &&
40239:                 atom == context->runtime->atomState.argumentsAtom) {
51097:                 tc->noteArgumentsUse();
27012:                 if (!let)
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:             }
27012:         }
40354:     } while (tokenStream.matchToken(TOK_COMMA));
    1: 
27012:     pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     return pn;
    1: 
    1: bad_var_init:
42671:     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_VAR_INIT);
    1:     return NULL;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::expr()
    1: {
42671:     JSParseNode *pn = assignExpr();
40354:     if (pn && tokenStream.matchToken(TOK_COMMA)) {
42671:         JSParseNode *pn2 = ListNode::create(tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn2->pn_pos.begin = pn->pn_pos.begin;
27012:         pn2->initList(pn);
    1:         pn = pn2;
    1:         do {
    1: #if JS_HAS_GENERATORS
27012:             pn2 = pn->last();
31479:             if (pn2->pn_type == TOK_YIELD && !pn2->pn_parens) {
42671:                 reportErrorNumber(pn2, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
    1:                 return NULL;
    1:             }
    1: #endif
40263:             pn2 = assignExpr();
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
40354:         } while (tokenStream.matchToken(TOK_COMMA));
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::assignExpr()
    1: {
40239:     JS_CHECK_RECURSION(context, return NULL);
    1: 
    1: #if JS_HAS_GENERATORS
40854:     if (tokenStream.matchToken(TOK_YIELD, TSF_OPERAND))
40263:         return returnOrYield(true);
    1: #endif
    1: 
42671:     JSParseNode *pn = condExpr();
    1:     if (!pn)
    1:         return NULL;
    1: 
42671:     TokenKind tt = tokenStream.getToken();
    1:     if (tt != TOK_ASSIGN) {
40354:         tokenStream.ungetToken();
    1:         return pn;
    1:     }
    1: 
42671:     JSOp op = tokenStream.currentToken().t_op;
31479:     switch (pn->pn_type) {
    1:       case TOK_NAME:
40239:         if (!CheckStrictAssignment(context, tc, pn))
35324:             return NULL;
31479:         pn->pn_op = JSOP_SETNAME;
40239:         NoteLValue(context, pn, tc);
    1:         break;
    1:       case TOK_DOT:
31479:         pn->pn_op = JSOP_SETPROP;
    1:         break;
    1:       case TOK_LB:
31479:         pn->pn_op = JSOP_SETELEM;
    1:         break;
    1: #if JS_HAS_DESTRUCTURING
    1:       case TOK_RB:
    1:       case TOK_RC:
42671:       {
    1:         if (op != JSOP_NOP) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_DESTRUCT_ASS);
42671:             return NULL;
42671:         }
42671:         JSParseNode *rhs = assignExpr();
40239:         if (!rhs || !CheckDestructuring(context, NULL, pn, rhs, tc))
40221:             return NULL;
40232:         return JSParseNode::newBinaryOrAppend(TOK_ASSIGN, op, pn, rhs, tc);
42671:       }
    1: #endif
    1:       case TOK_LP:
40239:         if (!MakeSetCall(context, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return NULL;
    1:         break;
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
31479:         if (pn->pn_op == JSOP_XMLNAME) {
31479:             pn->pn_op = JSOP_SETXMLNAME;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: #endif
    1:       default:
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
42671:         return NULL;
42671:     }
42671: 
42671:     JSParseNode *rhs = assignExpr();
31479:     if (rhs && PN_TYPE(pn) == TOK_NAME && pn->pn_used) {
31479:         JSDefinition *dn = pn->pn_lexdef;
28754: 
28754:         /*
28754:          * If the definition is not flagged as assigned, we must have imputed
28754:          * the initialized flag to it, to optimize for flat closures. But that
28754:          * optimization uses source coordinates to check dominance relations,
28754:          * so we must extend the end of the definition to cover the right-hand
28754:          * side of this assignment, i.e., the initializer.
28754:          */
28754:         if (!dn->isAssigned()) {
28754:             JS_ASSERT(dn->isInitialized());
31479:             dn->pn_pos.end = rhs->pn_pos.end;
31479:         }
31479:     }
31479: 
40232:     return JSParseNode::newBinaryOrAppend(TOK_ASSIGN, op, pn, rhs, tc);
40221: }
40221: 
40239: JSParseNode *
40860: Parser::condExpr()
    1: {
42671:     JSParseNode *pn = orExpr();
40354:     if (pn && tokenStream.matchToken(TOK_HOOK)) {
42671:         JSParseNode *pn1 = pn;
40232:         pn = TernaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40327: 
    1:         /*
    1:          * Always accept the 'in' operator in the middle clause of a ternary,
    1:          * where it's unambiguous, even if we might be parsing the init of a
    1:          * for statement.
    1:          */
42671:         uintN oldflags = tc->flags;
    1:         tc->flags &= ~TCF_IN_FOR_INIT;
42671:         JSParseNode *pn2 = assignExpr();
    1:         tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1: 
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
42671:         JSParseNode *pn3 = assignExpr();
    1:         if (!pn3)
    1:             return NULL;
    1:         pn->pn_pos.begin = pn1->pn_pos.begin;
    1:         pn->pn_pos.end = pn3->pn_pos.end;
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::orExpr()
    1: {
42671:     JSParseNode *pn = andExpr();
40354:     while (pn && tokenStream.matchToken(TOK_OR))
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_OR, JSOP_OR, pn, andExpr(), tc);
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::andExpr()
    1: {
42671:     JSParseNode *pn = bitOrExpr();
40354:     while (pn && tokenStream.matchToken(TOK_AND))
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_AND, JSOP_AND, pn, bitOrExpr(), tc);
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::bitOrExpr()
    1: {
42671:     JSParseNode *pn = bitXorExpr();
42671:     while (pn && tokenStream.matchToken(TOK_BITOR))
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_BITOR, JSOP_BITOR, pn, bitXorExpr(), tc);
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::bitXorExpr()
    1: {
42671:     JSParseNode *pn = bitAndExpr();
40354:     while (pn && tokenStream.matchToken(TOK_BITXOR)) {
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_BITXOR, JSOP_BITXOR, pn, bitAndExpr(), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::bitAndExpr()
    1: {
42671:     JSParseNode *pn = eqExpr();
40354:     while (pn && tokenStream.matchToken(TOK_BITAND))
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_BITAND, JSOP_BITAND, pn, eqExpr(), tc);
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::eqExpr()
    1: {
42671:     JSParseNode *pn = relExpr();
40354:     while (pn && tokenStream.matchToken(TOK_EQOP)) {
42671:         JSOp op = tokenStream.currentToken().t_op;
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_EQOP, op, pn, relExpr(), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::relExpr()
    1: {
    1:     uintN inForInitFlag = tc->flags & TCF_IN_FOR_INIT;
    1: 
    1:     /*
40239:      * Uses of the in operator in shiftExprs are always unambiguous,
    1:      * so unset the flag that prohibits recognizing it.
    1:      */
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
    1: 
42671:     JSParseNode *pn = shiftExpr();
    1:     while (pn &&
40354:            (tokenStream.matchToken(TOK_RELOP) ||
    1:             /*
    1:              * Recognize the 'in' token as an operator only if we're not
    1:              * currently in the init expr of a for loop.
    1:              */
40354:             (inForInitFlag == 0 && tokenStream.matchToken(TOK_IN)) ||
40354:             tokenStream.matchToken(TOK_INSTANCEOF))) {
42671:         TokenKind tt = tokenStream.currentToken().type;
42671:         JSOp op = tokenStream.currentToken().t_op;
40263:         pn = JSParseNode::newBinaryOrAppend(tt, op, pn, shiftExpr(), tc);
    1:     }
    1:     /* Restore previous state of inForInit flag. */
    1:     tc->flags |= inForInitFlag;
    1: 
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::shiftExpr()
    1: {
42671:     JSParseNode *pn = addExpr();
40354:     while (pn && tokenStream.matchToken(TOK_SHOP)) {
42671:         JSOp op = tokenStream.currentToken().t_op;
40263:         pn = JSParseNode::newBinaryOrAppend(TOK_SHOP, op, pn, addExpr(), tc);
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::addExpr()
40221: {
42671:     JSParseNode *pn = mulExpr();
40221:     while (pn &&
40354:            (tokenStream.matchToken(TOK_PLUS) ||
40354:             tokenStream.matchToken(TOK_MINUS))) {
42671:         TokenKind tt = tokenStream.currentToken().type;
42671:         JSOp op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
40263:         pn = JSParseNode::newBinaryOrAppend(tt, op, pn, mulExpr(), tc);
40221:     }
40221:     return pn;
40221: }
40221: 
40239: JSParseNode *
40860: Parser::mulExpr()
40221: {
42671:     JSParseNode *pn = unaryExpr();
42671:     while (pn && (tokenStream.matchToken(TOK_STAR) || tokenStream.matchToken(TOK_DIVOP))) {
42671:         TokenKind tt = tokenStream.currentToken().type;
42671:         JSOp op = tokenStream.currentToken().t_op;
40263:         pn = JSParseNode::newBinaryOrAppend(tt, op, pn, unaryExpr(), tc);
40221:     }
40221:     return pn;
40221: }
40221: 
    1: static JSParseNode *
40320: SetLvalKid(JSContext *cx, TokenStream *ts, JSTreeContext *tc,
35324:            JSParseNode *pn, JSParseNode *kid, const char *name)
    1: {
    1:     if (kid->pn_type != TOK_NAME &&
    1:         kid->pn_type != TOK_DOT &&
  279:         (kid->pn_type != TOK_LP ||
21460:          (kid->pn_op != JSOP_CALL && kid->pn_op != JSOP_EVAL && kid->pn_op != JSOP_APPLY)) &&
    1: #if JS_HAS_XML_SUPPORT
    1:         (kid->pn_type != TOK_UNARYOP || kid->pn_op != JSOP_XMLNAME) &&
    1: #endif
    1:         kid->pn_type != TOK_LB) {
40320:         ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, JSMSG_BAD_OPERAND, name);
    1:         return NULL;
    1:     }
35324:     if (!CheckStrictAssignment(cx, tc, kid))
35324:         return NULL;
    1:     pn->pn_kid = kid;
    1:     return kid;
    1: }
    1: 
    1: static const char incop_name_str[][10] = {"increment", "decrement"};
    1: 
    1: static JSBool
40320: SetIncOpKid(JSContext *cx, TokenStream *ts, JSTreeContext *tc,
    1:             JSParseNode *pn, JSParseNode *kid,
40320:             TokenKind tt, JSBool preorder)
    1: {
    1:     JSOp op;
    1: 
35324:     kid = SetLvalKid(cx, ts, tc, pn, kid, incop_name_str[tt == TOK_DEC]);
    1:     if (!kid)
    1:         return JS_FALSE;
    1:     switch (kid->pn_type) {
    1:       case TOK_NAME:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
    1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
27012:         NoteLValue(cx, kid, tc);
    1:         break;
    1: 
    1:       case TOK_DOT:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
    1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
    1:         break;
    1: 
    1:       case TOK_LP:
 7984:         if (!MakeSetCall(cx, kid, tc, JSMSG_BAD_INCOP_OPERAND))
 1577:             return JS_FALSE;
    1:         /* FALL THROUGH */
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_UNARYOP:
    1:         if (kid->pn_op == JSOP_XMLNAME)
    1:             kid->pn_op = JSOP_SETXMLNAME;
    1:         /* FALL THROUGH */
    1: #endif
    1:       case TOK_LB:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
    1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:         op = JSOP_NOP;
    1:     }
    1:     pn->pn_op = op;
    1:     return JS_TRUE;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::unaryExpr()
40221: {
    1:     JSParseNode *pn, *pn2;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
    1:     switch (tt) {
    1:       case TOK_UNARYOP:
    1:       case TOK_PLUS:
    1:       case TOK_MINUS:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_UNARYOP;      /* PLUS and MINUS are binary */
40270:         pn->pn_op = tokenStream.currentToken().t_op;
40263:         pn2 = unaryExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:         break;
    1: 
    1:       case TOK_INC:
    1:       case TOK_DEC:
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = memberExpr(JS_TRUE);
    1:         if (!pn2)
    1:             return NULL;
40239:         if (!SetIncOpKid(context, &tokenStream, tc, pn, pn2, tt, JS_TRUE))
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         break;
    1: 
    1:       case TOK_DELETE:
41983:       {
40232:         pn = UnaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = unaryExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1:         /*
    1:          * Under ECMA3, deleting any unary expression is valid -- it simply
31479:          * returns true. Here we fold constants before checking for a call
31479:          * expression, in order to rule out delete of a generator expression.
31479:          */
40239:         if (!js_FoldConstants(context, pn2, tc))
 1962:             return NULL;
27012:         switch (pn2->pn_type) {
27012:           case TOK_LP:
27012:             if (pn2->pn_op != JSOP_SETCALL &&
40239:                 !MakeSetCall(context, pn2, tc, JSMSG_BAD_DELETE_OPERAND)) {
 1577:                 return NULL;
 1577:             }
27012:             break;
27012:           case TOK_NAME:
40320:             if (!ReportStrictModeError(context, &tokenStream, tc, pn,
40320:                                        JSMSG_DEPRECATED_DELETE_OPERAND))
35311:                 return NULL;
27012:             pn2->pn_op = JSOP_DELNAME;
41983:             if (pn2->pn_atom == context->runtime->atomState.argumentsAtom)
41983:                 tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012:             break;
27012:           default:;
27012:         }
    1:         pn->pn_kid = pn2;
    1:         break;
41983:       }
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
40354:         tokenStream.ungetToken();
40263:         pn = memberExpr(JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Don't look across a newline boundary for a postfix incop. */
40270:         if (tokenStream.onCurrentLine(pn->pn_pos)) {
40854:             tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:             if (tt == TOK_INC || tt == TOK_DEC) {
40354:                 (void) tokenStream.getToken();
40232:                 pn2 = UnaryNode::create(tc);
    1:                 if (!pn2)
    1:                     return NULL;
40239:                 if (!SetIncOpKid(context, &tokenStream, tc, pn2, pn, tt, JS_FALSE))
    1:                     return NULL;
    1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
    1:                 pn = pn2;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     return pn;
    1: }
    1: 
 1577: #if JS_HAS_GENERATORS
 1577: 
 1577: /*
27012:  * A dedicated helper for transplanting the comprehension expression E in
27012:  *
27012:  *   [E for (V in I)]   // array comprehension
27012:  *   (E for (V in I))   // generator expression
27012:  *
27012:  * from its initial location in the AST, on the left of the 'for', to its final
27012:  * position on the right. To avoid a separate pass we do this by adjusting the
27012:  * blockids and name binding links that were established when E was parsed.
27012:  *
27012:  * A generator expression desugars like so:
27012:  *
27012:  *   (E for (V in I)) => (function () { for (var V in I) yield E; })()
27012:  *
27012:  * so the transplanter must adjust static level as well as blockid. E's source
27012:  * coordinates in root->pn_pos are critical to deciding which binding links to
27012:  * preserve and which to cut.
27012:  *
27012:  * NB: This is not a general tree transplanter -- it knows in particular that
27012:  * the one or more bindings induced by V have not yet been created.
27012:  */
27012: class CompExprTransplanter {
27012:     JSParseNode     *root;
27012:     JSTreeContext   *tc;
27012:     bool            genexp;
27012:     uintN           adjust;
27012:     uintN           funcLevel;
27012: 
27012:   public:
27012:     CompExprTransplanter(JSParseNode *pn, JSTreeContext *tc, bool ge, uintN adj)
27012:       : root(pn), tc(tc), genexp(ge), adjust(adj), funcLevel(0)
27012:     {
27012:     }
27012: 
27012:     bool transplant(JSParseNode *pn);
27012: };
27012: 
27012: /*
27012:  * Any definitions nested within the comprehension expression of a generator
27012:  * expression must move "down" one static level, which of course increases the
27012:  * upvar-frame-skip count.
27012:  */
28814: static bool
27012: BumpStaticLevel(JSParseNode *pn, JSTreeContext *tc)
27012: {
47573:     if (!pn->pn_cookie.isFree()) {
47573:         uintN level = pn->pn_cookie.level() + 1;
27012: 
27012:         JS_ASSERT(level >= tc->staticLevel);
47573:         if (level >= UpvarCookie::FREE_LEVEL) {
40860:             JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
28814:                                  JSMSG_TOO_DEEP, js_function_str);
28814:             return false;
28814:         }
28814: 
47573:         pn->pn_cookie.set(level, pn->pn_cookie.slot());
27012:     }
28814:     return true;
27012: }
27012: 
28122: static void
28122: AdjustBlockId(JSParseNode *pn, uintN adjust, JSTreeContext *tc)
28122: {
28122:     JS_ASSERT(pn->pn_arity == PN_LIST || pn->pn_arity == PN_FUNC || pn->pn_arity == PN_NAME);
28122:     pn->pn_blockid += adjust;
28122:     if (pn->pn_blockid >= tc->blockidGen)
28122:         tc->blockidGen = pn->pn_blockid + 1;
28122: }
28122: 
27012: bool
27012: CompExprTransplanter::transplant(JSParseNode *pn)
27012: {
27012:     if (!pn)
27012:         return true;
27012: 
27012:     switch (pn->pn_arity) {
27012:       case PN_LIST:
27012:         for (JSParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
27012:             transplant(pn2);
27012:         if (pn->pn_pos >= root->pn_pos)
28122:             AdjustBlockId(pn, adjust, tc);
27012:         break;
27012: 
27012:       case PN_TERNARY:
27012:         transplant(pn->pn_kid1);
27012:         transplant(pn->pn_kid2);
27012:         transplant(pn->pn_kid3);
27012:         break;
27012: 
27012:       case PN_BINARY:
27012:         transplant(pn->pn_left);
28354: 
28354:         /* Binary TOK_COLON nodes can have left == right. See bug 492714. */
28354:         if (pn->pn_right != pn->pn_left)
27012:             transplant(pn->pn_right);
27012:         break;
27012: 
27012:       case PN_UNARY:
27012:         transplant(pn->pn_kid);
27012:         break;
27012: 
27012:       case PN_FUNC:
27012:       {
27012:         /*
27012:          * Only the first level of transplant recursion through functions needs
27012:          * to reparent the funbox, since all descendant functions are correctly
27012:          * linked under the top-most funbox. But every visit to this case needs
27012:          * to update funbox->level.
27012:          *
27012:          * Recall that funbox->level is the static level of the code containing
27012:          * the definition or expression of the function and not the static level
27012:          * of the function's body.
27012:          */
27012:         JSFunctionBox *funbox = pn->pn_funbox;
27012: 
27012:         funbox->level = tc->staticLevel + funcLevel;
27012:         if (++funcLevel == 1 && genexp) {
27012:             JSFunctionBox *parent = tc->funbox;
27012: 
27012:             JSFunctionBox **funboxp = &tc->parent->functionList;
27012:             while (*funboxp != funbox)
27012:                 funboxp = &(*funboxp)->siblings;
27012:             *funboxp = funbox->siblings;
27012: 
27012:             funbox->parent = parent;
27012:             funbox->siblings = parent->kids;
27012:             parent->kids = funbox;
27012:             funbox->level = tc->staticLevel;
27012:         }
27012:         /* FALL THROUGH */
27012:       }
27012: 
27012:       case PN_NAME:
27012:         transplant(pn->maybeExpr());
27012:         if (pn->pn_arity == PN_FUNC)
27012:             --funcLevel;
27012: 
27012:         if (pn->pn_defn) {
28814:             if (genexp && !BumpStaticLevel(pn, tc))
28814:                 return false;
27012:         } else if (pn->pn_used) {
27012:             JS_ASSERT(pn->pn_op != JSOP_NOP);
47573:             JS_ASSERT(pn->pn_cookie.isFree());
27012: 
27012:             JSDefinition *dn = pn->pn_lexdef;
27012:             JS_ASSERT(dn->pn_defn);
27012: 
27012:             /*
27012:              * Adjust the definition's block id only if it is a placeholder not
27012:              * to the left of the root node, and if pn is the last use visited
27012:              * in the comprehension expression (to avoid adjusting the blockid
27012:              * multiple times).
27012:              *
27012:              * Non-placeholder definitions within the comprehension expression
27012:              * will be visited further below.
27012:              */
27012:             if (dn->isPlaceholder() && dn->pn_pos >= root->pn_pos && dn->dn_uses == pn) {
28814:                 if (genexp && !BumpStaticLevel(dn, tc))
28814:                     return false;
28122:                 AdjustBlockId(dn, adjust, tc);
27012:             }
27012: 
27012:             JSAtom *atom = pn->pn_atom;
27012: #ifdef DEBUG
27012:             JSStmtInfo *stmt = js_LexicalLookup(tc, atom, NULL);
27012:             JS_ASSERT(!stmt || stmt != tc->topStmt);
27012: #endif
27012:             if (genexp && PN_OP(dn) != JSOP_CALLEE) {
27012:                 JS_ASSERT(!tc->decls.lookup(atom));
27012: 
27012:                 if (dn->pn_pos < root->pn_pos || dn->isPlaceholder()) {
40860:                     JSAtomListElement *ale = tc->lexdeps.add(tc->parser, dn->pn_atom);
27012:                     if (!ale)
28814:                         return false;
27371: 
27574:                     if (dn->pn_pos >= root->pn_pos) {
40860:                         tc->parent->lexdeps.remove(tc->parser, atom);
27574:                     } else {
40232:                         JSDefinition *dn2 = (JSDefinition *)NameNode::create(dn->pn_atom, tc);
27371:                         if (!dn2)
28814:                             return false;
27371: 
27371:                         dn2->pn_type = dn->pn_type;
27578:                         dn2->pn_pos = root->pn_pos;
27371:                         dn2->pn_defn = true;
28557:                         dn2->pn_dflags |= PND_PLACEHOLDER;
27371: 
27371:                         JSParseNode **pnup = &dn->dn_uses;
27371:                         JSParseNode *pnu;
27371:                         while ((pnu = *pnup) != NULL && pnu->pn_pos >= root->pn_pos) {
27371:                             pnu->pn_lexdef = dn2;
30457:                             dn2->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
27371:                             pnup = &pnu->pn_link;
27371:                         }
27371:                         dn2->dn_uses = dn->dn_uses;
27371:                         dn->dn_uses = *pnup;
27371:                         *pnup = NULL;
27371: 
27371:                         dn = dn2;
27371:                     }
27371: 
27012:                     ALE_SET_DEFN(ale, dn);
27012:                 }
27012:             }
27012:         }
27012: 
27012:         if (pn->pn_pos >= root->pn_pos)
28122:             AdjustBlockId(pn, adjust, tc);
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         transplant(pn->pn_tree);
27012:         break;
27012:     }
27012:     return true;
27012: }
27012: 
27012: /*
 1577:  * Starting from a |for| keyword after the first array initialiser element or
 1577:  * an expression in an open parenthesis, parse the tail of the comprehension
 1577:  * or generator expression signified by this |for| keyword in context.
 1577:  *
 1577:  * Return null on failure, else return the top-most parse node for the array
 1577:  * comprehension or generator expression, with a unary node as the body of the
 1577:  * (possibly nested) for-loop, initialized by |type, op, kid|.
 1577:  */
40239: JSParseNode *
40860: Parser::comprehensionTail(JSParseNode *kid, uintN blockid,
40320:                           TokenKind type, JSOp op)
40239: {
27012:     uintN adjust;
 1577:     JSParseNode *pn, *pn2, *pn3, **pnp;
 1577:     JSStmtInfo stmtInfo;
 1577:     BindData data;
40320:     TokenKind tt;
 1577:     JSAtom *atom;
 1577: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_FOR);
 1577: 
27012:     if (type == TOK_SEMI) {
27012:         /*
27012:          * Generator expression desugars to an immediately applied lambda that
27012:          * yields the next value from a for-in loop (possibly nested, and with
27012:          * optional if guard). Make pn be the TOK_LC body node.
 1577:          */
40239:         pn = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
 1577:         if (!pn)
 1577:             return NULL;
27012:         adjust = pn->pn_blockid - blockid;
27012:     } else {
27012:         JS_ASSERT(type == TOK_ARRAYPUSH);
27012: 
27012:         /*
27012:          * Make a parse-node and literal object representing the block scope of
40239:          * this array comprehension. Our caller in primaryExpr, the TOK_LB case
27012:          * aka the array initialiser case, has passed the blockid to claim for
27012:          * the comprehension's block scope. We allocate that id or one above it
27012:          * here, by calling js_PushLexicalScope.
27012:          *
27012:          * In the case of a comprehension expression that has nested blocks
27012:          * (e.g., let expressions), we will allocate a higher blockid but then
27012:          * slide all blocks "to the right" to make room for the comprehension's
27012:          * block scope.
27012:          */
27012:         adjust = tc->blockid();
40239:         pn = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
27012:         if (!pn)
27012:             return NULL;
27012: 
27012:         JS_ASSERT(blockid <= pn->pn_blockid);
27012:         JS_ASSERT(blockid < tc->blockidGen);
27012:         JS_ASSERT(tc->bodyid < blockid);
27012:         pn->pn_blockid = stmtInfo.blockid = blockid;
27012:         JS_ASSERT(adjust < blockid);
27012:         adjust = blockid - adjust;
27012:     }
27012: 
 1577:     pnp = &pn->pn_expr;
 1577: 
27012:     CompExprTransplanter transplanter(kid, tc, type == TOK_SEMI, adjust);
27012:     transplanter.transplant(kid);
27012: 
 1577:     data.pn = NULL;
 1577:     data.op = JSOP_NOP;
 1577:     data.binder = BindLet;
27012:     data.let.overflow = JSMSG_ARRAY_INIT_TOO_BIG;
27012: 
 1577:     do {
 1577:         /*
 1577:          * FOR node is binary, left is loop control and right is body.  Use
 1577:          * index to count each block-local let-variable on the left-hand side
 1577:          * of the IN.
 1577:          */
40232:         pn2 = BinaryNode::create(tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577: 
15613:         pn2->pn_op = JSOP_ITER;
15613:         pn2->pn_iflags = JSITER_ENUMERATE;
40354:         if (tokenStream.matchToken(TOK_NAME)) {
40270:             if (tokenStream.currentToken().t_atom == context->runtime->atomState.eachAtom)
15613:                 pn2->pn_iflags |= JSITER_FOREACH;
 1577:             else
40354:                 tokenStream.ungetToken();
 1577:         }
 1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 1577: 
27012:         atom = NULL;
40354:         tt = tokenStream.getToken();
 1577:         switch (tt) {
 1577: #if JS_HAS_DESTRUCTURING
 1577:           case TOK_LB:
 1577:           case TOK_LC:
33753:             tc->flags |= TCF_DECL_DESTRUCTURING;
40263:             pn3 = primaryExpr(tt, JS_FALSE);
33753:             tc->flags &= ~TCF_DECL_DESTRUCTURING;
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: #endif
 1577: 
 1577:           case TOK_NAME:
40270:             atom = tokenStream.currentToken().t_atom;
 1577: 
 1577:             /*
 1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
 1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
 1577:              * in the operand stack frame.  The code generator computes that,
 1577:              * and it tries to bind all names to slots, so we must let it do
 1577:              * the deed.
 1577:              */
33754:             pn3 = NewBindingNode(atom, tc, true);
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: 
 1577:           default:
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NO_VARIABLE_NAME);
 1607: 
 1607:           case TOK_ERROR:
 1577:             return NULL;
 1577:         }
 1577: 
 1577:         MUST_MATCH_TOKEN(TOK_IN, JSMSG_IN_AFTER_FOR_NAME);
40263:         JSParseNode *pn4 = expr();
27012:         if (!pn4)
27012:             return NULL;
 1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
27012: 
27012:         switch (tt) {
27012: #if JS_HAS_DESTRUCTURING
27012:           case TOK_LB:
27012:           case TOK_LC:
40239:             if (!CheckDestructuring(context, &data, pn3, NULL, tc))
40239:                 return NULL;
40239: 
40239:             if (JSVERSION_NUMBER(context) == JSVERSION_1_7) {
27012:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
27012:                 if (pn3->pn_type != TOK_RB || pn3->pn_count != 2) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_FOR_LEFTSIDE);
27012:                     return NULL;
27012:                 }
27012: 
27012:                 JS_ASSERT(pn2->pn_op == JSOP_ITER);
27012:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
27012:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
27012:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
27012:             }
27012:             break;
27012: #endif
27012: 
27012:           case TOK_NAME:
27012:             data.pn = pn3;
40239:             if (!data.binder(context, &data, atom, tc))
27012:                 return NULL;
27012:             break;
27012: 
27012:           default:;
27012:         }
27012: 
40232:         pn2->pn_left = JSParseNode::newBinaryOrAppend(TOK_IN, JSOP_NOP, pn3, pn4, tc);
27012:         if (!pn2->pn_left)
27012:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_right;
40354:     } while (tokenStream.matchToken(TOK_FOR));
40354: 
40354:     if (tokenStream.matchToken(TOK_IF)) {
40232:         pn2 = TernaryNode::create(tc);
 1577:         if (!pn2)
 1577:             return NULL;
40263:         pn2->pn_kid1 = condition();
 1577:         if (!pn2->pn_kid1)
 1577:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_kid2;
 1577:     }
 1577: 
40232:     pn2 = UnaryNode::create(tc);
 1577:     if (!pn2)
 1577:         return NULL;
 1577:     pn2->pn_type = type;
 1577:     pn2->pn_op = op;
 1577:     pn2->pn_kid = kid;
 1577:     *pnp = pn2;
 1577: 
27012:     PopStatement(tc);
 1577:     return pn;
 1577: }
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577: 
 1577: /*
 1577:  * Starting from a |for| keyword after an expression, parse the comprehension
 1577:  * tail completing this generator expression. Wrap the expression at kid in a
 1577:  * generator function that is immediately called to evaluate to the generator
 1577:  * iterator that is the value of this generator expression.
 1577:  *
40239:  * Callers pass a blank unary node via pn, which generatorExpr fills in as the
 1577:  * yield expression, which ComprehensionTail in turn wraps in a TOK_SEMI-type
 1577:  * expression-statement node that constitutes the body of the |for| loop(s) in
 1577:  * the generator function.
 1577:  *
 1577:  * Note how unlike Python, we do not evaluate the expression to the right of
 1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
 1577:  * is merely sugar for a generator function expression and its application.
 1577:  */
40239: JSParseNode *
40860: Parser::generatorExpr(JSParseNode *pn, JSParseNode *kid)
27012: {
 1577:     /* Initialize pn, connecting it to kid. */
 1577:     JS_ASSERT(pn->pn_arity == PN_UNARY);
 1577:     pn->pn_type = TOK_YIELD;
 1577:     pn->pn_op = JSOP_YIELD;
31479:     pn->pn_parens = true;
 1577:     pn->pn_pos = kid->pn_pos;
 1577:     pn->pn_kid = kid;
31479:     pn->pn_hidden = true;
 1577: 
27012:     /* Make a new node for the desugared generator function. */
40232:     JSParseNode *genfn = FunctionNode::create(tc);
27012:     if (!genfn)
27012:         return NULL;
27012:     genfn->pn_type = TOK_FUNCTION;
27012:     genfn->pn_op = JSOP_LAMBDA;
27012:     JS_ASSERT(!genfn->pn_body);
27012:     genfn->pn_dflags = PND_FUNARG;
27012: 
27012:     {
40263:         JSTreeContext *outertc = tc;
40860:         JSTreeContext gentc(tc->parser);
27012: 
40263:         JSFunctionBox *funbox = EnterFunction(genfn, &gentc);
27012:         if (!funbox)
27012:             return NULL;
27012: 
27236:         /*
40263:          * We have to dance around a bit to propagate sharp variables from
40263:          * outertc to gentc before setting TCF_HAS_SHARPS implicitly by
40263:          * propagating all of outertc's TCF_FUN_FLAGS flags. As below, we have
40263:          * to be conservative by leaving TCF_HAS_SHARPS set in outertc if we
40263:          * do propagate to gentc.
40263:          */
40263:         if (outertc->flags & TCF_HAS_SHARPS) {
32757:             gentc.flags |= TCF_IN_FUNCTION;
32757:             if (!gentc.ensureSharpSlots())
32757:                 return NULL;
32757:         }
32757: 
32757:         /*
27236:          * We assume conservatively that any deoptimization flag in tc->flags
27236:          * besides TCF_FUN_PARAM_ARGUMENTS can come from the kid. So we
27236:          * propagate these flags into genfn. For code simplicity we also do
27236:          * not detect if the flags were only set in the kid and could be
27236:          * removed from tc->flags.
27236:          */
27236:         gentc.flags |= TCF_FUN_IS_GENERATOR | TCF_GENEXP_LAMBDA |
27236:                        (tc->flags & (TCF_FUN_FLAGS & ~TCF_FUN_PARAM_ARGUMENTS));
27012:         funbox->tcflags |= gentc.flags;
27012:         genfn->pn_funbox = funbox;
27012:         genfn->pn_blockid = gentc.bodyid;
27012: 
40263:         JSParseNode *body = comprehensionTail(pn, outertc->blockid());
 1577:         if (!body)
 1577:             return NULL;
27012:         JS_ASSERT(!genfn->pn_body);
27012:         genfn->pn_body = body;
27012:         genfn->pn_pos.begin = body->pn_pos.begin = kid->pn_pos.begin;
40270:         genfn->pn_pos.end = body->pn_pos.end = tokenStream.currentToken().pos.end;
40221: 
40263:         if (!LeaveFunction(genfn, &gentc))
27012:             return NULL;
27012:     }
27012: 
27012:     /*
27012:      * Our result is a call expression that invokes the anonymous generator
27012:      * function object.
27012:      */
40232:     JSParseNode *result = ListNode::create(tc);
27012:     if (!result)
27012:         return NULL;
27012:     result->pn_type = TOK_LP;
27012:     result->pn_op = JSOP_CALL;
27012:     result->pn_pos.begin = genfn->pn_pos.begin;
27012:     result->initList(genfn);
27012:     return result;
 1577: }
 1577: 
 1577: static const char js_generator_str[] = "generator";
 1577: 
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: #endif /* JS_HAS_GENERATORS */
 1577: 
40239: JSBool
40860: Parser::argumentList(JSParseNode *listNode)
    1: {
40854:     if (tokenStream.matchToken(TOK_RP, TSF_OPERAND))
40854:         return JS_TRUE;
40854: 
    1:     do {
40263:         JSParseNode *argNode = assignExpr();
    1:         if (!argNode)
    1:             return JS_FALSE;
    1: #if JS_HAS_GENERATORS
11844:         if (argNode->pn_type == TOK_YIELD &&
31479:             !argNode->pn_parens &&
40354:             tokenStream.peekToken() == TOK_COMMA) {
42671:             reportErrorNumber(argNode, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
    1:             return JS_FALSE;
    1:         }
    1: #endif
 1577: #if JS_HAS_GENERATOR_EXPRS
40354:         if (tokenStream.matchToken(TOK_FOR)) {
40232:             JSParseNode *pn = UnaryNode::create(tc);
 1577:             if (!pn)
 1577:                 return JS_FALSE;
40263:             argNode = generatorExpr(pn, argNode);
 1577:             if (!argNode)
 1577:                 return JS_FALSE;
 1577:             if (listNode->pn_count > 1 ||
40354:                 tokenStream.peekToken() == TOK_COMMA) {
42671:                 reportErrorNumber(argNode, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                   js_generator_str);
 1577:                 return JS_FALSE;
 1577:             }
 1577:         }
 1577: #endif
27012:         listNode->append(argNode);
40354:     } while (tokenStream.matchToken(TOK_COMMA));
40354: 
40354:     if (tokenStream.getToken() != TOK_RP) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_AFTER_ARGS);
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
27012: /* Check for an immediately-applied (new'ed) lambda and clear PND_FUNARG. */
27012: static JSParseNode *
27012: CheckForImmediatelyAppliedLambda(JSParseNode *pn)
27012: {
27012:     if (pn->pn_type == TOK_FUNCTION) {
27012:         JS_ASSERT(pn->pn_arity == PN_FUNC);
27051: 
27051:         JSFunctionBox *funbox = pn->pn_funbox;
27051:         JS_ASSERT(((JSFunction *) funbox->object)->flags & JSFUN_LAMBDA);
32658:         if (!(funbox->tcflags & (TCF_FUN_USES_ARGUMENTS | TCF_FUN_USES_OWN_NAME)))
27012:             pn->pn_dflags &= ~PND_FUNARG;
27012:     }
27012:     return pn;
27012: }
27012: 
40239: JSParseNode *
40860: Parser::memberExpr(JSBool allowCallSyntax)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
40221: 
40239:     JS_CHECK_RECURSION(context, return NULL);
    1: 
    1:     /* Check for new expression first. */
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
    1:     if (tt == TOK_NEW) {
40232:         pn = ListNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = memberExpr(JS_FALSE);
    1:         if (!pn2)
    1:             return NULL;
27012:         pn2 = CheckForImmediatelyAppliedLambda(pn2);
    1:         pn->pn_op = JSOP_NEW;
27012:         pn->initList(pn2);
    1:         pn->pn_pos.begin = pn2->pn_pos.begin;
    1: 
40354:         if (tokenStream.matchToken(TOK_LP) && !argumentList(pn))
    1:             return NULL;
    1:         if (pn->pn_count > ARGC_LIMIT) {
40239:             JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
    1:                                  JSMSG_TOO_MANY_CON_ARGS);
    1:             return NULL;
    1:         }
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     } else {
40263:         pn = primaryExpr(tt, JS_FALSE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         if (pn->pn_type == TOK_ANYNAME ||
    1:             pn->pn_type == TOK_AT ||
    1:             pn->pn_type == TOK_DBLCOLON) {
27012:             pn2 = NewOrRecycledNode(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_UNARYOP;
    1:             pn2->pn_pos = pn->pn_pos;
    1:             pn2->pn_op = JSOP_XMLNAME;
    1:             pn2->pn_arity = PN_UNARY;
31479:             pn2->pn_parens = false;
    1:             pn2->pn_kid = pn;
    1:             pn = pn2;
    1:         }
    1:     }
    1: 
40354:     while ((tt = tokenStream.getToken()) > TOK_EOF) {
    1:         if (tt == TOK_DOT) {
40232:             pn2 = NameNode::create(NULL, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1: #if JS_HAS_XML_SUPPORT
40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
40263:             pn3 = primaryExpr(tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
31479: 
31479:             /* Check both tt and pn_type, to distinguish |x.(y)| and |x.y::z| from |x.y|. */
31479:             if (tt == TOK_NAME && pn3->pn_type == TOK_NAME) {
    1:                 pn2->pn_op = JSOP_GETPROP;
    1:                 pn2->pn_expr = pn;
    1:                 pn2->pn_atom = pn3->pn_atom;
    1:                 RecycleTree(pn3, tc);
    1:             } else {
31479:                 if (tt == TOK_LP) {
31479:                     pn2->pn_type = TOK_FILTER;
31479:                     pn2->pn_op = JSOP_FILTER;
31479: 
31479:                     /* A filtering predicate is like a with statement. */
31479:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
40320:                 } else if (TokenKindIsXML(PN_TYPE(pn3))) {
    1:                     pn2->pn_type = TOK_LB;
    1:                     pn2->pn_op = JSOP_GETELEM;
    1:                 } else {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
    1:                     return NULL;
    1:                 }
    1:                 pn2->pn_arity = PN_BINARY;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
    1:             }
    1: #else
40854:             MUST_MATCH_TOKEN_WITH_FLAGS(TOK_NAME, JSMSG_NAME_AFTER_DOT, TSF_KEYWORD_IS_NAME);
    1:             pn2->pn_op = JSOP_GETPROP;
    1:             pn2->pn_expr = pn;
40270:             pn2->pn_atom = tokenStream.currentToken().t_atom;
    1: #endif
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: #if JS_HAS_XML_SUPPORT
    1:         } else if (tt == TOK_DBLDOT) {
40232:             pn2 = BinaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
40263:             pn3 = primaryExpr(tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
 3164:             tt = PN_TYPE(pn3);
32579:             if (tt == TOK_NAME && !pn3->pn_parens) {
    1:                 pn3->pn_type = TOK_STRING;
    1:                 pn3->pn_arity = PN_NULLARY;
    1:                 pn3->pn_op = JSOP_QNAMEPART;
40320:             } else if (!TokenKindIsXML(tt)) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
    1:                 return NULL;
    1:             }
    1:             pn2->pn_op = JSOP_DESCENDANTS;
    1:             pn2->pn_left = pn;
    1:             pn2->pn_right = pn3;
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: #endif
    1:         } else if (tt == TOK_LB) {
40232:             pn2 = BinaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
40263:             pn3 = expr();
    1:             if (!pn3)
    1:                 return NULL;
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
18392:             /*
18392:              * Optimize o['p'] to o.p by rewriting pn2, but avoid rewriting
18392:              * o['0'] to use JSOP_GETPROP, to keep fast indexing disjoint in
18392:              * the interpreter from fast property access. However, if the
18392:              * bracketed string is a uint32, we rewrite pn3 to be a number
18392:              * instead of a string.
18392:              */
18392:             do {
    1:                 if (pn3->pn_type == TOK_STRING) {
18392:                     jsuint index;
18392: 
18392:                     if (!js_IdIsIndex(ATOM_TO_JSID(pn3->pn_atom), &index)) {
    1:                         pn2->pn_type = TOK_DOT;
    1:                         pn2->pn_op = JSOP_GETPROP;
    1:                         pn2->pn_arity = PN_NAME;
    1:                         pn2->pn_expr = pn;
    1:                         pn2->pn_atom = pn3->pn_atom;
18392:                         break;
18392:                     }
18392:                     pn3->pn_type = TOK_NUMBER;
20902:                     pn3->pn_op = JSOP_DOUBLE;
18392:                     pn3->pn_dval = index;
18392:                 }
    1:                 pn2->pn_op = JSOP_GETELEM;
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
18392:             } while (0);
    1:         } else if (allowCallSyntax && tt == TOK_LP) {
40232:             pn2 = ListNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_op = JSOP_CALL;
27012: 
27012:             pn = CheckForImmediatelyAppliedLambda(pn);
27012:             if (pn->pn_op == JSOP_NAME) {
40239:                 if (pn->pn_atom == context->runtime->atomState.evalAtom) {
27012:                     /* Select JSOP_EVAL and flag tc as heavyweight. */
    1:                     pn2->pn_op = JSOP_EVAL;
51096:                     tc->noteCallsEval();
42780:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012:                 }
27012:             } else if (pn->pn_op == JSOP_GETPROP) {
40239:                 if (pn->pn_atom == context->runtime->atomState.applyAtom ||
40239:                     pn->pn_atom == context->runtime->atomState.callAtom) {
27012:                     /* Select JSOP_APPLY given foo.apply(...). */
21452:                     pn2->pn_op = JSOP_APPLY;
    1:                 }
27012:             }
27012: 
27012:             pn2->initList(pn);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1: 
40263:             if (!argumentList(pn2))
    1:                 return NULL;
    1:             if (pn2->pn_count > ARGC_LIMIT) {
40239:                 JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
    1:                                      JSMSG_TOO_MANY_FUN_ARGS);
    1:                 return NULL;
    1:             }
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         } else {
40354:             tokenStream.ungetToken();
    1:             return pn;
    1:         }
    1: 
    1:         pn = pn2;
    1:     }
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::bracketedExpr()
    1: {
    1:     uintN oldflags;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Always accept the 'in' operator in a parenthesized expression,
    1:      * where it's unambiguous, even if we might be parsing the init of a
    1:      * for statement.
    1:      */
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
40263:     pn = expr();
    1:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
40239: JSParseNode *
40860: Parser::endBracketedExpr()
    1: {
    1:     JSParseNode *pn;
    1: 
40263:     pn = bracketedExpr();
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ PropertySelector
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *
    1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *              PropertySelector
    1:  *
    1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
    1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
    1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector QualifiedSuffix
    1:  *
    1:  *      QualifiedSuffix:
    1:  *              :: PropertySelector
    1:  *              :: [ Expression ]
    1:  *              /nothing/
    1:  *
    1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
    1:  *
    1:  *      PrimaryExpression:
    1:  *              Identifier QualifiedSuffix
    1:  *
    1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
    1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
    1:  */
40239: JSParseNode *
40860: Parser::propertySelector()
    1: {
    1:     JSParseNode *pn;
    1: 
40232:     pn = NullaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     if (pn->pn_type == TOK_STAR) {
    1:         pn->pn_type = TOK_ANYNAME;
    1:         pn->pn_op = JSOP_ANYNAME;
40239:         pn->pn_atom = context->runtime->atomState.starAtom;
    1:     } else {
    1:         JS_ASSERT(pn->pn_type == TOK_NAME);
    1:         pn->pn_op = JSOP_QNAMEPART;
    1:         pn->pn_arity = PN_NAME;
40270:         pn->pn_atom = tokenStream.currentToken().t_atom;
47573:         pn->pn_cookie.makeFree();
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::qualifiedSuffix(JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
40320:     TokenKind tt;
40221: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_DBLCOLON);
40232:     pn2 = NameNode::create(NULL, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     /* Left operand of :: must be evaluated if it is an identifier. */
    1:     if (pn->pn_op == JSOP_QNAMEPART)
    1:         pn->pn_op = JSOP_NAME;
    1: 
40854:     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
40239:         /* Inline and specialize propertySelector for JSOP_QNAMECONST. */
    1:         pn2->pn_op = JSOP_QNAMECONST;
27012:         pn2->pn_pos.begin = pn->pn_pos.begin;
    1:         pn2->pn_atom = (tt == TOK_STAR)
40239:                        ? context->runtime->atomState.starAtom
40270:                        : tokenStream.currentToken().t_atom;
    1:         pn2->pn_expr = pn;
47573:         pn2->pn_cookie.makeFree();
    1:         return pn2;
    1:     }
    1: 
    1:     if (tt != TOK_LB) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
40263:     pn3 = endBracketedExpr();
    1:     if (!pn3)
    1:         return NULL;
    1: 
    1:     pn2->pn_op = JSOP_QNAME;
    1:     pn2->pn_arity = PN_BINARY;
27012:     pn2->pn_pos.begin = pn->pn_pos.begin;
27012:     pn2->pn_pos.end = pn3->pn_pos.end;
    1:     pn2->pn_left = pn;
    1:     pn2->pn_right = pn3;
    1:     return pn2;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::qualifiedIdentifier()
    1: {
    1:     JSParseNode *pn;
    1: 
40263:     pn = propertySelector();
    1:     if (!pn)
    1:         return NULL;
40354:     if (tokenStream.matchToken(TOK_DBLCOLON)) {
28948:         /* Hack for bug 496316. Slowing down E4X won't make it go away, alas. */
28948:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
40263:         pn = qualifiedSuffix(pn);
28948:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::attributeIdentifier()
    1: {
    1:     JSParseNode *pn, *pn2;
40320:     TokenKind tt;
40221: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_AT);
40232:     pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_op = JSOP_TOATTRNAME;
40854:     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
40263:         pn2 = qualifiedIdentifier();
    1:     } else if (tt == TOK_LB) {
40263:         pn2 = endBracketedExpr();
    1:     } else {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_kid = pn2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a TOK_LC unary node whose pn_kid is an expression.
    1:  */
40239: JSParseNode *
40860: Parser::xmlExpr(JSBool inTag)
    1: {
    1:     JSParseNode *pn, *pn2;
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LC);
40232:     pn = UnaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     /*
38596:      * Turn off XML tag mode. We save the old value of the flag because it may
38596:      * already be off: XMLExpr is called both from within a tag, and from
38596:      * within text contained in an element, but outside of any start, end, or
38596:      * point tag.
38596:      */
40854:     bool oldflag = tokenStream.isXMLTagMode();
40854:     tokenStream.setXMLTagMode(false);
40263:     pn2 = expr();
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
40854:     tokenStream.setXMLTagMode(oldflag);
    1:     pn->pn_kid = pn2;
    1:     pn->pn_op = inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a terminal node for one of TOK_XMLNAME, TOK_XMLATTR, TOK_XMLSPACE,
    1:  * TOK_XMLTEXT, TOK_XMLCDATA, TOK_XMLCOMMENT, or TOK_XMLPI.  When converting
    1:  * parse tree to XML, we preserve a TOK_XMLSPACE node only if it's the sole
    1:  * child of a container tag.
    1:  */
40239: JSParseNode *
40860: Parser::xmlAtomNode()
40221: {
40270:     JSParseNode *pn = NullaryNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
40854:     const Token &tok = tokenStream.currentToken();
40854:     pn->pn_op = tok.t_op;
40854:     pn->pn_atom = tok.t_atom;
40854:     if (tok.type == TOK_XMLPI)
40854:         pn->pn_atom2 = tok.t_atom2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLNameExpr:
    1:  *              XMLName XMLNameExpr?
    1:  *              { Expr } XMLNameExpr?
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
    1:  * a list of names and/or expressions, a single expression, or a single name.
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME; if PN_UNARY, pn_type
    1:  * will be TOK_LC.
    1:  */
40239: JSParseNode *
40860: Parser::xmlNameExpr()
    1: {
    1:     JSParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
    1: 
    1:     pn = list = NULL;
    1:     do {
40270:         tt = tokenStream.currentToken().type;
    1:         if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_TRUE);
    1:             if (!pn2)
    1:                 return NULL;
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLNAME);
40263:             pn2 = xmlAtomNode();
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         if (!pn) {
    1:             pn = pn2;
    1:         } else {
    1:             if (!list) {
40232:                 list = ListNode::create(tc);
    1:                 if (!list)
    1:                     return NULL;
    1:                 list->pn_type = TOK_XMLNAME;
    1:                 list->pn_pos.begin = pn->pn_pos.begin;
27012:                 list->initList(pn);
27012:                 list->pn_xflags = PNX_CANTFOLD;
    1:                 pn = list;
    1:             }
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
40354:     } while ((tt = tokenStream.getToken()) == TOK_XMLNAME || tt == TOK_LC);
40354: 
40354:     tokenStream.ungetToken();
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
    1:  * at compile time into a JSXML tree.
    1:  */
    1: #define XML_FOLDABLE(pn)        ((pn)->pn_arity == PN_LIST                    \
27012:                                  ? ((pn)->pn_xflags & PNX_CANTFOLD) == 0      \
    1:                                  : (pn)->pn_type != TOK_LC)
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLTagContent:
    1:  *              XMLNameExpr
    1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
    1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
    1:  * produces a list of name and attribute values and/or braced expressions, a
    1:  * single expression, or a single name.
    1:  *
    1:  * If PN_LIST or PN_NULLARY, pn_type will be TOK_XMLNAME for the case where
    1:  * XMLTagContent: XMLNameExpr.  If pn_type is not TOK_XMLNAME but pn_arity is
    1:  * PN_LIST, pn_type will be tagtype.  If PN_UNARY, pn_type will be TOK_LC and
    1:  * we parsed exactly one expression.
    1:  */
40239: JSParseNode *
40860: Parser::xmlTagContent(TokenKind tagtype, JSAtom **namep)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
40221: 
40263:     pn = xmlNameExpr();
    1:     if (!pn)
    1:         return NULL;
    1:     *namep = (pn->pn_arity == PN_NULLARY) ? pn->pn_atom : NULL;
    1:     list = NULL;
    1: 
40354:     while (tokenStream.matchToken(TOK_XMLSPACE)) {
40354:         tt = tokenStream.getToken();
    1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
40354:             tokenStream.ungetToken();
40239:             break;
40239:         }
40239: 
40263:         pn2 = xmlNameExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!list) {
40232:             list = ListNode::create(tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = tagtype;
    1:             list->pn_pos.begin = pn->pn_pos.begin;
27012:             list->initList(pn);
    1:             pn = list;
    1:         }
27012:         pn->append(pn2);
    1:         if (!XML_FOLDABLE(pn2))
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1: 
40354:         tokenStream.matchToken(TOK_XMLSPACE);
    1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
40354:         tokenStream.matchToken(TOK_XMLSPACE);
40354: 
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_XMLATTR) {
40263:             pn2 = xmlAtomNode();
    1:         } else if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_TRUE);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_ATTR_VALUE);
    1:             return NULL;
    1:         }
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                              \
    1:     JS_BEGIN_MACRO                                                                          \
    1:         if ((tt) <= TOK_EOF) {                                                              \
    1:             if ((tt) == TOK_EOF) {                                                          \
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_END_OF_XML_SOURCE);           \
    1:             }                                                                               \
    1:             return result;                                                                  \
    1:         }                                                                                   \
    1:     JS_END_MACRO
    1: 
    1: /*
    1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
    1:  * that opens the end tag for the container.
    1:  */
40239: JSBool
40860: Parser::xmlElementContent(JSParseNode *pn)
40221: {
40854:     tokenStream.setXMLTagMode(false);
    1:     for (;;) {
40854:         TokenKind tt = tokenStream.getToken(TSF_XMLTEXTMODE);
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1: 
    1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
40854:         JSAtom *textAtom = tokenStream.currentToken().t_atom;
    1:         if (textAtom) {
    1:             /* Non-zero-length XML text scanned. */
40854:             JSParseNode *pn2 = xmlAtomNode();
    1:             if (!pn2)
    1:                 return JS_FALSE;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
    1: 
40854:         tt = tokenStream.getToken(TSF_OPERAND);
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1:         if (tt == TOK_XMLETAGO)
    1:             break;
    1: 
40854:         JSParseNode *pn2;
    1:         if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_FALSE);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else if (tt == TOK_XMLSTAGO) {
40263:             pn2 = xmlElementOrList(JS_FALSE);
    1:             if (pn2) {
27012:                 pn2->pn_xflags &= ~PNX_XMLROOT;
27012:                 pn->pn_xflags |= pn2->pn_xflags;
    1:             }
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT ||
    1:                       tt == TOK_XMLPI);
40263:             pn2 = xmlAtomNode();
    1:         }
    1:         if (!pn2)
    1:             return JS_FALSE;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
40854:     tokenStream.setXMLTagMode(true);
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLETAGO);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
    1:  */
40239: JSParseNode *
40860: Parser::xmlElementOrList(JSBool allowList)
    1: {
    1:     JSParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
    1:     JSAtom *startAtom, *endAtom;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLSTAGO);
40232:     pn = ListNode::create(tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
40854:     tokenStream.setXMLTagMode(true);
40354:     tt = tokenStream.getToken();
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
    1:         /*
    1:          * XMLElement.  Append the tag and its contents, if any, to pn.
    1:          */
40263:         pn2 = xmlTagContent(TOK_XMLSTAGO, &startAtom);
    1:         if (!pn2)
    1:             return NULL;
40354:         tokenStream.matchToken(TOK_XMLSPACE);
40354: 
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_XMLPTAGC) {
    1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
    1:             if (pn2->pn_type == TOK_XMLSTAGO) {
27012:                 pn->makeEmpty();
    1:                 RecycleTree(pn, tc);
    1:                 pn = pn2;
    1:             } else {
    1:                 JS_ASSERT(pn2->pn_type == TOK_XMLNAME ||
    1:                           pn2->pn_type == TOK_LC);
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1:             pn->pn_type = TOK_XMLPTAGC;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1:         } else {
    1:             /* We had better have a tag-close (>) at this point. */
    1:             if (tt != TOK_XMLTAGC) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
    1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
    1:             if (pn2->pn_type != TOK_XMLSTAGO) {
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:                 pn2 = pn;
40232:                 pn = ListNode::create(tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
    1:             pn->pn_type = TOK_XMLELEM;
27012:             pn->pn_pos.begin = pn2->pn_pos.begin;
27012:             pn->initList(pn2);
    1:             if (!XML_FOLDABLE(pn2))
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1: 
    1:             /* Get element contents and delimiting end-tag-open sequence. */
40263:             if (!xmlElementContent(pn))
40239:                 return NULL;
40239: 
40354:             tt = tokenStream.getToken();
    1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
    1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Parse end tag; check mismatch at compile-time if we can. */
40263:             pn2 = xmlTagContent(TOK_XMLETAGO, &endAtom);
    1:             if (!pn2)
    1:                 return NULL;
    1:             if (pn2->pn_type == TOK_XMLETAGO) {
    1:                 /* Oops, end tag has attributes! */
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             if (endAtom && startAtom && endAtom != startAtom) {
    1:                 JSString *str = ATOM_TO_STRING(startAtom);
    1: 
    1:                 /* End vs. start tag name mismatch: point to the tag name. */
42671:                 reportErrorNumber(pn2, JSREPORT_UC | JSREPORT_ERROR, JSMSG_XML_TAG_NAME_MISMATCH,
42671:                                   str->chars());
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
    1:             JS_ASSERT(pn2->pn_type == TOK_XMLNAME || pn2->pn_type == TOK_LC);
40232:             list = ListNode::create(tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_type = TOK_XMLETAGO;
27012:             list->initList(pn2);
27012:             pn->append(list);
    1:             if (!XML_FOLDABLE(pn2)) {
27012:                 list->pn_xflags |= PNX_CANTFOLD;
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1: 
40354:             tokenStream.matchToken(TOK_XMLSPACE);
    1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
    1:         }
    1: 
    1:         /* Set pn_op now that pn has been updated to its final value. */
    1:         pn->pn_op = JSOP_TOXML;
    1:     } else if (allowList && tt == TOK_XMLTAGC) {
    1:         /* XMLList Initialiser. */
    1:         pn->pn_type = TOK_XMLLIST;
    1:         pn->pn_op = JSOP_TOXMLLIST;
27012:         pn->makeEmpty();
27012:         pn->pn_xflags |= PNX_XMLROOT;
40263:         if (!xmlElementContent(pn))
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
    1:     } else {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_NAME_SYNTAX);
    1:         return NULL;
    1:     }
40854:     tokenStream.setXMLTagMode(false);
    1: 
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::xmlElementOrListRoot(JSBool allowList)
    1: {
    1:     uint32 oldopts;
    1:     JSParseNode *pn;
    1: 
    1:     /*
    1:      * Force XML support to be enabled so that comments and CDATA literals
    1:      * are recognized, instead of <! followed by -- starting an HTML comment
    1:      * to end of line (used in script tags to hide content from old browsers
    1:      * that don't recognize <script>).
    1:      */
40239:     oldopts = JS_SetOptions(context, context->options | JSOPTION_XML);
40263:     pn = xmlElementOrList(allowList);
40239:     JS_SetOptions(context, oldopts);
    1:     return pn;
    1: }
    1: 
27012: JSParseNode *
40860: Parser::parseXMLText(JSObject *chain, bool allowList)
27012: {
    1:     /*
    1:      * Push a compiler frame if we have no frames, or if the top frame is a
    1:      * lightweight function activation, or if its scope chain doesn't match
    1:      * the one passed to us.
    1:      */
40263:     JSTreeContext xmltc(this);
40263:     xmltc.scopeChain = chain;
    1: 
    1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
40854:     tokenStream.setXMLOnlyMode();
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
27012: 
27012:     JSParseNode *pn;
    1:     if (tt != TOK_XMLSTAGO) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_MARKUP);
    1:         pn = NULL;
    1:     } else {
40263:         pn = xmlElementOrListRoot(allowList);
40239:     }
40854:     tokenStream.setXMLOnlyMode(false);
40854: 
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_XMLSUPPORT */
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012: /*
27012:  * Check whether blockid is an active scoping statement in tc. This code is
40239:  * necessary to qualify tc->decls.lookup() hits in primaryExpr's TOK_NAME case
27012:  * (below) where the hits come from Scheme-ish let bindings in for loop heads
27012:  * and let blocks and expressions (not let declarations).
27012:  *
27012:  * Unlike let declarations ("let as the new var"), which is a kind of letrec
27012:  * due to hoisting, let in a for loop head, let block, or let expression acts
27012:  * like Scheme's let: initializers are evaluated without the new let bindings
27012:  * being in scope.
27012:  *
27012:  * Name binding analysis is eager with fixups, rather than multi-pass, and let
27012:  * bindings push on the front of the tc->decls JSAtomList (either the singular
27012:  * list or on a hash chain -- see JSAtomList::AddHow) in order to shadow outer
27012:  * scope bindings of the same name.
27012:  *
27012:  * This simplifies binding lookup code at the price of a linear search here,
27012:  * but only if code uses let (var predominates), and even then this function's
27012:  * loop iterates more than once only in crazy cases.
27012:  */
27371: static inline bool
27371: BlockIdInScope(uintN blockid, JSTreeContext *tc)
27371: {
27371:     if (blockid > tc->blockid())
27371:         return false;
27012:     for (JSStmtInfo *stmt = tc->topScopeStmt; stmt; stmt = stmt->downScope) {
27012:         if (stmt->blockid == blockid)
27012:             return true;
27012:     }
27012:     return false;
27012: }
27012: #endif
27012: 
40239: JSParseNode *
40860: Parser::primaryExpr(TokenKind tt, JSBool afterDot)
    1: {
    1:     JSParseNode *pn, *pn2, *pn3;
    1:     JSOp op;
11139: 
40239:     JS_CHECK_RECURSION(context, return NULL);
11139: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
40854:         if (tokenStream.matchToken(TOK_DBLCOLON, TSF_KEYWORD_IS_NAME)) {
40232:             pn2 = NullaryNode::create(tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pn2->pn_type = TOK_FUNCTION;
40263:             pn = qualifiedSuffix(pn2);
    1:             if (!pn)
    1:                 return NULL;
    1:             break;
    1:         }
    1: #endif
40263:         pn = functionExpr();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LB:
    1:       {
    1:         JSBool matched;
    1:         jsuint index;
    1: 
40232:         pn = ListNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RB;
20902:         pn->pn_op = JSOP_NEWINIT;
27012:         pn->makeEmpty();
27012: 
27012: #if JS_HAS_GENERATORS
27012:         pn->pn_blockid = tc->blockidGen;
27012: #endif
    1: 
40854:         matched = tokenStream.matchToken(TOK_RB, TSF_OPERAND);
    1:         if (!matched) {
    1:             for (index = 0; ; index++) {
31823:                 if (index == JS_ARGS_LENGTH_MAX) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ARRAY_INIT_TOO_BIG);
    1:                     return NULL;
    1:                 }
    1: 
40854:                 tt = tokenStream.peekToken(TSF_OPERAND);
    1:                 if (tt == TOK_RB) {
27012:                     pn->pn_xflags |= PNX_ENDCOMMA;
    1:                     break;
    1:                 }
    1: 
    1:                 if (tt == TOK_COMMA) {
    1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
40354:                     tokenStream.matchToken(TOK_COMMA);
40232:                     pn2 = NullaryNode::create(tc);
28123:                     pn->pn_xflags |= PNX_HOLEY;
    1:                 } else {
40263:                     pn2 = assignExpr();
    1:                 }
    1:                 if (!pn2)
    1:                     return NULL;
27012:                 pn->append(pn2);
    1: 
    1:                 if (tt != TOK_COMMA) {
    1:                     /* If we didn't already match TOK_COMMA in above case. */
40354:                     if (!tokenStream.matchToken(TOK_COMMA))
    1:                         break;
    1:                 }
    1:             }
    1: 
    1: #if JS_HAS_GENERATORS
    1:             /*
    1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
26959:              * element initialiser was parsed.
    1:              *
    1:              * An array comprehension of the form:
    1:              *
    1:              *   [i * j for (i in o) for (j in p) if (i != j)]
    1:              *
    1:              * translates to roughly the following let expression:
    1:              *
    1:              *   let (array = new Array, i, j) {
    1:              *     for (i in o) let {
    1:              *       for (j in p)
    1:              *         if (i != j)
    1:              *           array.push(i * j)
    1:              *     }
    1:              *     array
    1:              *   }
    1:              *
    1:              * where array is a nameless block-local variable.  The "roughly"
    1:              * means that an implementation may optimize away the array.push.
    1:              * An array comprehension opens exactly one block scope, no matter
    1:              * how many for heads it contains.
    1:              *
    1:              * Each let () {...} or for (let ...) ... compiles to:
    1:              *
    1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
    1:              *
    1:              * where <o> is a literal object representing the block scope,
    1:              * with <n> properties, naming each var declared in the block.
    1:              *
    1:              * Each var declaration in a let-block binds a name in <o> at
    1:              * compile time, and allocates a slot on the operand stack at
    1:              * runtime via JSOP_ENTERBLOCK.  A block-local var is accessed
    1:              * by the JSOP_GETLOCAL and JSOP_SETLOCAL ops, and iterated with
    1:              * JSOP_FORLOCAL.  These ops all have an immediate operand, the
    1:              * local slot's stack index from fp->spbase.
    1:              *
    1:              * The array comprehension iteration step, array.push(i * j) in
    1:              * the example above, is done by <i * j>; JSOP_ARRAYCOMP <array>,
    1:              * where <array> is the index of array's stack slot.
    1:              */
40354:             if (index == 0 && pn->pn_count != 0 && tokenStream.matchToken(TOK_FOR)) {
 1577:                 JSParseNode *pnexp, *pntop;
    1: 
    1:                 /* Relabel pn as an array comprehension node. */
    1:                 pn->pn_type = TOK_ARRAYCOMP;
    1: 
    1:                 /*
    1:                  * Remove the comprehension expression from pn's linked list
    1:                  * and save it via pnexp.  We'll re-install it underneath the
    1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
    1:                  */
27012:                 pnexp = pn->last();
51110:                 JS_ASSERT(pn->pn_count == 1);
51110:                 pn->pn_count = 0;
51110:                 pn->pn_tail = &pn->pn_head;
    1:                 *pn->pn_tail = NULL;
    1: 
40263:                 pntop = comprehensionTail(pnexp, pn->pn_blockid,
27012:                                           TOK_ARRAYPUSH, JSOP_ARRAYPUSH);
    1:                 if (!pntop)
    1:                     return NULL;
27012:                 pn->append(pntop);
    1:             }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
    1:         }
40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_LC:
    1:       {
    1:         JSBool afterComma;
11039:         JSParseNode *pnval;
    1: 
35310:         /*
35310:          * A map from property names we've seen thus far to bit masks.
35310:          * (We use ALE_INDEX/ALE_SET_INDEX).  An atom's mask includes
35310:          * JSPROP_SETTER if we've seen a setter for it, JSPROP_GETTER
35310:          * if we've seen as getter, and both of those if we've just
35310:          * seen an ordinary value.
35310:          */
40860:         JSAutoAtomList seen(tc->parser);
35310: 
40232:         pn = ListNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_type = TOK_RC;
20902:         pn->pn_op = JSOP_NEWINIT;
27012:         pn->makeEmpty();
    1: 
    1:         afterComma = JS_FALSE;
    1:         for (;;) {
35310:             JSAtom *atom;
40854:             tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:             switch (tt) {
    1:               case TOK_NUMBER:
40232:                 pn3 = NullaryNode::create(tc);
33749:                 if (!pn3)
33749:                     return NULL;
40270:                 pn3->pn_dval = tokenStream.currentToken().t_dval;
40794:                 if (tc->needStrictChecks()) {
48470:                     /*
48470:                      * Use string-valued atoms for detecting duplicate
48470:                      * properties so that 1 and "1" properly collide.
48470:                      */
48470:                     if (!js_ValueToAtom(context, DoubleValue(pn3->pn_dval), &atom))
40794:                         return NULL;
40794:                 } else {
35310:                     atom = NULL; /* for the compiler */
40794:                 }
    1:                 break;
    1:               case TOK_NAME:
    1:                 {
40270:                     atom = tokenStream.currentToken().t_atom;
40239:                     if (atom == context->runtime->atomState.getAtom)
 1478:                         op = JSOP_GETTER;
40239:                     else if (atom == context->runtime->atomState.setAtom)
 1478:                         op = JSOP_SETTER;
 1478:                     else
 1478:                         goto property_name;
 1478: 
40854:                     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
40794:                     if (tt == TOK_NAME || tt == TOK_STRING) {
40270:                         atom = tokenStream.currentToken().t_atom;
40232:                         pn3 = NameNode::create(atom, tc);
    1:                         if (!pn3)
    1:                             return NULL;
40794:                     } else if (tt == TOK_NUMBER) {
40794:                         pn3 = NullaryNode::create(tc);
40794:                         if (!pn3)
40794:                             return NULL;
40794:                         pn3->pn_dval = tokenStream.currentToken().t_dval;
40794:                         if (tc->needStrictChecks()) {
48470:                             /*
48470:                              * Use string-valued atoms for detecting duplicate
48470:                              * properties so that 1 and "1" properly collide.
48470:                              */
48470:                             if (!js_ValueToAtom(context, DoubleValue(pn3->pn_dval), &atom))
40794:                                 return NULL;
40794:                         } else {
40794:                             atom = NULL; /* for the compiler */
40794:                         }
40794:                     } else {
40794:                         tokenStream.ungetToken();
40794:                         goto property_name;
40794:                     }
    1: 
51087:                     /* NB: Getter function in { get x(){} } is unnamed. */
51089:                     pn2 = functionDef(NULL, op == JSOP_SETTER ? SETTER : GETTER, JSFUN_LAMBDA);
40232:                     pn2 = JSParseNode::newBinaryOrAppend(TOK_COLON, op, pn3, pn2, tc);
    1:                     goto skip;
    1:                 }
 1478:               property_name:
    1:               case TOK_STRING:
40270:                 atom = tokenStream.currentToken().t_atom;
40232:                 pn3 = NullaryNode::create(tc);
33749:                 if (!pn3)
33749:                     return NULL;
35310:                 pn3->pn_atom = atom;
    1:                 break;
    1:               case TOK_RC:
    1:                 goto end_obj_init;
    1:               default:
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_PROP_ID);
    1:                 return NULL;
    1:             }
    1: 
40855:             op = JSOP_INITPROP;
40354:             tt = tokenStream.getToken();
37685:             if (tt == TOK_COLON) {
40263:                 pnval = assignExpr();
37685:             } else {
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 if (tt != TOK_COMMA && tt != TOK_RC) {
11039: #endif
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_COLON_AFTER_ID);
    1:                     return NULL;
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 }
11039: 
11039:                 /*
11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
11039:                  */
40354:                 tokenStream.ungetToken();
27012:                 pn->pn_xflags |= PNX_DESTRUCT;
11039:                 pnval = pn3;
11039:                 if (pnval->pn_type == TOK_NAME) {
11039:                     pnval->pn_arity = PN_NAME;
40232:                     ((NameNode *)pnval)->initCommon(tc);
11039:                 }
11039: #endif
11039:             }
11039: 
40232:             pn2 = JSParseNode::newBinaryOrAppend(TOK_COLON, op, pn3, pnval, tc);
    1:           skip:
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
    1: 
35310:             /*
35310:              * In strict mode code, check for duplicate property names.  Treat
35310:              * getters and setters as distinct attributes of each property.  A
35310:              * plain old value conflicts with a getter or a setter.
35310:              */
35310:             if (tc->needStrictChecks()) {
35310:                 unsigned attributesMask;
37685:                 if (op == JSOP_INITPROP) {
35310:                     attributesMask = JSPROP_GETTER | JSPROP_SETTER;
37685:                 } else if (op == JSOP_GETTER) {
35310:                     attributesMask = JSPROP_GETTER;
37685:                 } else if (op == JSOP_SETTER) {
35310:                     attributesMask = JSPROP_SETTER;
37685:                 } else {
35310:                     JS_NOT_REACHED("bad opcode in object initializer");
35310:                     attributesMask = 0;
35310:                 }
35310: 
35310:                 JSAtomListElement *ale = seen.lookup(atom);
35310:                 if (ale) {
35310:                     if (ALE_INDEX(ale) & attributesMask) {
40239:                         const char *name = js_AtomToPrintableString(context, atom);
35310:                         if (!name ||
40320:                             !ReportStrictModeError(context, &tokenStream, tc, NULL,
35310:                                                    JSMSG_DUPLICATE_PROPERTY, name)) {
35310:                             return NULL;
35310:                         }
35310:                     }
35310:                     ALE_SET_INDEX(ale, attributesMask | ALE_INDEX(ale));
35310:                 } else {
40860:                     ale = seen.add(tc->parser, atom);
35310:                     if (!ale)
35310:                         return NULL;
35310:                     ALE_SET_INDEX(ale, attributesMask);
35310:                 }
35310:             }
35310: 
40354:             tt = tokenStream.getToken();
    1:             if (tt == TOK_RC)
    1:                 goto end_obj_init;
    1:             if (tt != TOK_COMMA) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CURLY_AFTER_LIST);
    1:                 return NULL;
    1:             }
    1:             afterComma = JS_TRUE;
    1:         }
 1967: 
    1:       end_obj_init:
40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         return pn;
    1:       }
    1: 
 1967: #if JS_HAS_BLOCK_SCOPE
 1967:       case TOK_LET:
40263:         pn = letBlock(JS_FALSE);
 1967:         if (!pn)
 1967:             return NULL;
 1967:         break;
 1967: #endif
 1967: 
    1: #if JS_HAS_SHARP_VARS
    1:       case TOK_DEFSHARP:
40232:         pn = UnaryNode::create(tc);
26959:         if (!pn)
26959:             return NULL;
40270:         pn->pn_num = (jsint) tokenStream.currentToken().t_dval;
40854:         tt = tokenStream.getToken(TSF_OPERAND);
40263:         pn->pn_kid = primaryExpr(tt, JS_FALSE);
26959:         if (!pn->pn_kid)
26959:             return NULL;
42711:         if (PN_TYPE(pn->pn_kid) == TOK_USESHARP ||
42711:             PN_TYPE(pn->pn_kid) == TOK_DEFSHARP ||
42711:             PN_TYPE(pn->pn_kid) == TOK_STRING ||
42711:             PN_TYPE(pn->pn_kid) == TOK_NUMBER ||
42711:             PN_TYPE(pn->pn_kid) == TOK_PRIMARY) {
42719:             reportErrorNumber(pn->pn_kid, JSREPORT_ERROR, JSMSG_BAD_SHARP_VAR_DEF);
42711:             return NULL;
42711:         }
32729:         if (!tc->ensureSharpSlots())
32729:             return NULL;
26959:         break;
    1: 
    1:       case TOK_USESHARP:
    1:         /* Check for forward/dangling references at runtime, to allow eval. */
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
32729:         if (!tc->ensureSharpSlots())
32729:             return NULL;
40270:         pn->pn_num = (jsint) tokenStream.currentToken().t_dval;
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:       case TOK_LP:
 1577:       {
 1577:         JSBool genexp;
 1577: 
40263:         pn = parenExpr(NULL, &genexp);
    1:         if (!pn)
    1:             return NULL;
31479:         pn->pn_parens = true;
31479:         if (!genexp)
    1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
    1:         break;
 1577:       }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_STAR:
40263:         pn = qualifiedIdentifier();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_AT:
40263:         pn = attributeIdentifier();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_XMLSTAGO:
40263:         pn = xmlElementOrListRoot(JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       case TOK_STRING:
    1: #if JS_HAS_SHARP_VARS
    1:         /* FALL THROUGH */
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLCDATA:
    1:       case TOK_XMLCOMMENT:
    1:       case TOK_XMLPI:
    1: #endif
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40270:         pn->pn_atom = tokenStream.currentToken().t_atom;
    1: #if JS_HAS_XML_SUPPORT
    1:         if (tt == TOK_XMLPI)
40270:             pn->pn_atom2 = tokenStream.currentToken().t_atom2;
    1:         else
    1: #endif
40270:             pn->pn_op = tokenStream.currentToken().t_op;
27012:         break;
27012: 
27012:       case TOK_NAME:
40270:         pn = NameNode::create(tokenStream.currentToken().t_atom, tc);
27012:         if (!pn)
27012:             return NULL;
40270:         JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
27012:         pn->pn_op = JSOP_NAME;
27012: 
27012:         if ((tc->flags & (TCF_IN_FUNCTION | TCF_FUN_PARAM_ARGUMENTS)) == TCF_IN_FUNCTION &&
40239:             pn->pn_atom == context->runtime->atomState.argumentsAtom) {
27012:             /*
27012:              * Flag arguments usage so we can avoid unsafe optimizations such
27012:              * as formal parameter assignment analysis (because of the hated
27012:              * feature whereby arguments alias formals). We do this even for
27012:              * a reference of the form foo.arguments, which ancient code may
27012:              * still use instead of arguments (more hate).
27012:              */
51097:             tc->noteArgumentsUse();
27012: 
27012:             /*
27012:              * Bind early to JSOP_ARGUMENTS to relieve later code from having
27012:              * to do this work (new rule for the emitter to count on).
27012:              */
33753:             if (!afterDot && !(tc->flags & TCF_DECL_DESTRUCTURING) && !tc->inStatement(STMT_WITH)) {
27012:                 pn->pn_op = JSOP_ARGUMENTS;
27012:                 pn->pn_dflags |= PND_BOUND;
27012:             }
27595:         } else if ((!afterDot
27595: #if JS_HAS_XML_SUPPORT
40354:                     || tokenStream.peekToken() == TOK_DBLCOLON
27595: #endif
33753:                    ) && !(tc->flags & TCF_DECL_DESTRUCTURING)) {
27371:             JSStmtInfo *stmt = js_LexicalLookup(tc, pn->pn_atom, NULL);
27371:             if (!stmt || stmt->type != STMT_WITH) {
27012:                 JSDefinition *dn;
27012: 
27371:                 JSAtomListElement *ale = tc->decls.lookup(pn->pn_atom);
27012:                 if (ale) {
27012:                     dn = ALE_DEFN(ale);
27012: #if JS_HAS_BLOCK_SCOPE
28967:                     /*
28967:                      * Skip out-of-scope let bindings along an ALE list or hash
28967:                      * chain. These can happen due to |let (x = x) x| block and
28967:                      * expression bindings, where the x on the right of = comes
28967:                      * from an outer scope. See bug 496532.
28967:                      */
28967:                     while (dn->isLet() && !BlockIdInScope(dn->pn_blockid, tc)) {
28967:                         do {
28967:                             ale = ALE_NEXT(ale);
28967:                         } while (ale && ALE_ATOM(ale) != pn->pn_atom);
28967:                         if (!ale)
28967:                             break;
28967:                         dn = ALE_DEFN(ale);
28967:                     }
27012: #endif
27012:                 }
27012: 
27371:                 if (ale) {
27371:                     dn = ALE_DEFN(ale);
27371:                 } else {
27012:                     ale = tc->lexdeps.lookup(pn->pn_atom);
27371:                     if (ale) {
27371:                         dn = ALE_DEFN(ale);
27371:                     } else {
27371:                         /*
27371:                          * No definition before this use in any lexical scope.
27371:                          * Add a mapping in tc->lexdeps from pn->pn_atom to a
27371:                          * new node for the forward-referenced definition. This
27371:                          * placeholder definition node will be adopted when we
27371:                          * parse the real defining declaration form, or left as
27371:                          * a free variable definition if we never see the real
27371:                          * definition.
27012:                          */
27012:                         ale = MakePlaceholder(pn, tc);
27012:                         if (!ale)
27012:                             return NULL;
27012:                         dn = ALE_DEFN(ale);
27012: 
27012:                         /*
27371:                          * In case this is a forward reference to a function,
27371:                          * we pessimistically set PND_FUNARG if the next token
27371:                          * is not a left parenthesis.
27371:                          *
27371:                          * If the definition eventually parsed into dn is not a
27371:                          * function, this flag won't hurt, and if we do parse a
27371:                          * function with pn's name, then the PND_FUNARG flag is
40239:                          * necessary for safe context->display-based optimiza-
40239:                          * tion of the closure's static link.
27012:                          */
27012:                         JS_ASSERT(PN_TYPE(dn) == TOK_NAME);
27012:                         JS_ASSERT(dn->pn_op == JSOP_NOP);
40354:                         if (tokenStream.peekToken() != TOK_LP)
27012:                             dn->pn_dflags |= PND_FUNARG;
27012:                     }
27012:                 }
27012: 
27012:                 JS_ASSERT(dn->pn_defn);
27012:                 LinkUseToDef(pn, dn, tc);
27012: 
27012:                 /* Here we handle the backward function reference case. */
40354:                 if (tokenStream.peekToken() != TOK_LP)
27012:                     dn->pn_dflags |= PND_FUNARG;
27012: 
27012:                 pn->pn_dflags |= (dn->pn_dflags & PND_FUNARG);
27012:             }
27371:         }
27371: 
    1: #if JS_HAS_XML_SUPPORT
40354:         if (tokenStream.matchToken(TOK_DBLCOLON)) {
    1:             if (afterDot) {
    1:                 JSString *str;
    1: 
    1:                 /*
40239:                  * Here primaryExpr is called after . or .. followed by a name
27012:                  * followed by ::. This is the only case where a keyword after
27012:                  * . or .. is not treated as a property name.
    1:                  */
    1:                 str = ATOM_TO_STRING(pn->pn_atom);
29366:                 tt = js_CheckKeyword(str->chars(), str->length());
    1:                 if (tt == TOK_FUNCTION) {
    1:                     pn->pn_arity = PN_NULLARY;
    1:                     pn->pn_type = TOK_FUNCTION;
    1:                 } else if (tt != TOK_EOF) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_KEYWORD_NOT_NS);
    1:                     return NULL;
    1:                 }
    1:             }
40263:             pn = qualifiedSuffix(pn);
    1:             if (!pn)
    1:                 return NULL;
    1:         }
    1: #endif
    1:         break;
    1: 
 6561:       case TOK_REGEXP:
 6561:       {
40232:         pn = NullaryNode::create(tc);
 6561:         if (!pn)
 6561:             return NULL;
 6561: 
50491:         JSObject *obj = RegExp::createObject(context, tokenStream.getTokenbuf().begin(),
40270:                                              tokenStream.getTokenbuf().length(),
40270:                                              tokenStream.currentToken().t_reflags);
 6561:         if (!obj)
 6561:             return NULL;
41884:         if (!tc->compileAndGo()) {
39930:             obj->clearParent();
39928:             obj->clearProto();
 9481:         }
 6561: 
40860:         pn->pn_objbox = tc->parser->newObjectBox(obj);
27012:         if (!pn->pn_objbox)
 6561:             return NULL;
 6561: 
 6561:         pn->pn_op = JSOP_REGEXP;
 6561:         break;
 6561:       }
 6561: 
    1:       case TOK_NUMBER:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
20902:         pn->pn_op = JSOP_DOUBLE;
40270:         pn->pn_dval = tokenStream.currentToken().t_dval;
    1:         break;
    1: 
    1:       case TOK_PRIMARY:
40232:         pn = NullaryNode::create(tc);
    1:         if (!pn)
    1:             return NULL;
40270:         pn->pn_op = tokenStream.currentToken().t_op;
    1:         break;
    1: 
    1:       case TOK_ERROR:
    1:         /* The scanner or one of its subroutines reported the error. */
    1:         return NULL;
    1: 
    1:       default:
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
40239: JSParseNode *
40860: Parser::parenExpr(JSParseNode *pn1, JSBool *genexp)
40221: {
40320:     TokenPtr begin;
 1577:     JSParseNode *pn;
 1577: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LP);
40270:     begin = tokenStream.currentToken().pos.begin;
 1577: 
 1577:     if (genexp)
 1577:         *genexp = JS_FALSE;
40263:     pn = bracketedExpr();
 1577:     if (!pn)
 1577:         return NULL;
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
40354:     if (tokenStream.matchToken(TOK_FOR)) {
31479:         if (pn->pn_type == TOK_YIELD && !pn->pn_parens) {
42671:             reportErrorNumber(pn, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
 1577:             return NULL;
 1577:         }
31479:         if (pn->pn_type == TOK_COMMA && !pn->pn_parens) {
42671:             reportErrorNumber(pn->last(), JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
42671:                               js_generator_str);
 1577:             return NULL;
 1577:         }
 1577:         if (!pn1) {
40232:             pn1 = UnaryNode::create(tc);
 1577:             if (!pn1)
 1577:                 return NULL;
 1577:         }
40263:         pn = generatorExpr(pn1, pn);
27012:         if (!pn)
27012:             return NULL;
26970:         pn->pn_pos.begin = begin;
 1577:         if (genexp) {
40354:             if (tokenStream.getToken() != TOK_RP) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
42671:                                   js_generator_str);
40221:                 return NULL;
40221:             }
40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
 1577:             *genexp = JS_TRUE;
 1577:         }
 1577:     }
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: 
 1577:     return pn;
 1577: }
 1577: 
    1: /*
    1:  * Fold from one constant type to another.
    1:  * XXX handles only strings and numbers for now
    1:  */
    1: static JSBool
40320: FoldType(JSContext *cx, JSParseNode *pn, TokenKind type)
    1: {
27012:     if (PN_TYPE(pn) != type) {
    1:         switch (type) {
    1:           case TOK_NUMBER:
    1:             if (pn->pn_type == TOK_STRING) {
    1:                 jsdouble d;
48470:                 if (!ValueToNumber(cx, StringValue(ATOM_TO_STRING(pn->pn_atom)), &d))
    1:                     return JS_FALSE;
    1:                 pn->pn_dval = d;
    1:                 pn->pn_type = TOK_NUMBER;
 3328:                 pn->pn_op = JSOP_DOUBLE;
    1:             }
    1:             break;
    1: 
    1:           case TOK_STRING:
    1:             if (pn->pn_type == TOK_NUMBER) {
    1:                 JSString *str = js_NumberToString(cx, pn->pn_dval);
    1:                 if (!str)
    1:                     return JS_FALSE;
    1:                 pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:                 if (!pn->pn_atom)
    1:                     return JS_FALSE;
    1:                 pn->pn_type = TOK_STRING;
    1:                 pn->pn_op = JSOP_STRING;
    1:             }
    1:             break;
    1: 
    1:           default:;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Fold two numeric constants.  Beware that pn1 and pn2 are recycled, unless
    1:  * one of them aliases pn, so you can't safely fetch pn2->pn_next, e.g., after
    1:  * a successful call to this function.
    1:  */
    1: static JSBool
    1: FoldBinaryNumeric(JSContext *cx, JSOp op, JSParseNode *pn1, JSParseNode *pn2,
    1:                   JSParseNode *pn, JSTreeContext *tc)
    1: {
    1:     jsdouble d, d2;
    1:     int32 i, j;
    1: 
    1:     JS_ASSERT(pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER);
    1:     d = pn1->pn_dval;
    1:     d2 = pn2->pn_dval;
    1:     switch (op) {
    1:       case JSOP_LSH:
    1:       case JSOP_RSH:
 9613:         i = js_DoubleToECMAInt32(d);
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
    1:         d = (op == JSOP_LSH) ? i << j : i >> j;
    1:         break;
    1: 
    1:       case JSOP_URSH:
 9613:         j = js_DoubleToECMAInt32(d2);
    1:         j &= 31;
 9613:         d = js_DoubleToECMAUint32(d) >> j;
    1:         break;
    1: 
    1:       case JSOP_ADD:
    1:         d += d2;
    1:         break;
    1: 
    1:       case JSOP_SUB:
    1:         d -= d2;
    1:         break;
    1: 
    1:       case JSOP_MUL:
    1:         d *= d2;
    1:         break;
    1: 
    1:       case JSOP_DIV:
    1:         if (d2 == 0) {
    1: #if defined(XP_WIN)
    1:             /* XXX MSVC miscompiles such that (NaN == 0) */
    1:             if (JSDOUBLE_IS_NaN(d2))
34372:                 d = js_NaN;
    1:             else
    1: #endif
    1:             if (d == 0 || JSDOUBLE_IS_NaN(d))
34372:                 d = js_NaN;
32586:             else if (JSDOUBLE_IS_NEG(d) != JSDOUBLE_IS_NEG(d2))
34372:                 d = js_NegativeInfinity;
    1:             else
34372:                 d = js_PositiveInfinity;
    1:         } else {
    1:             d /= d2;
    1:         }
    1:         break;
    1: 
    1:       case JSOP_MOD:
    1:         if (d2 == 0) {
34372:             d = js_NaN;
    1:         } else {
30268:             d = js_fmod(d, d2);
    1:         }
    1:         break;
    1: 
    1:       default:;
    1:     }
    1: 
    1:     /* Take care to allow pn1 or pn2 to alias pn. */
    1:     if (pn1 != pn)
    1:         RecycleTree(pn1, tc);
    1:     if (pn2 != pn)
    1:         RecycleTree(pn2, tc);
    1:     pn->pn_type = TOK_NUMBER;
 3328:     pn->pn_op = JSOP_DOUBLE;
    1:     pn->pn_arity = PN_NULLARY;
    1:     pn->pn_dval = d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: static JSBool
    1: FoldXMLConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc)
    1: {
40320:     TokenKind tt;
    1:     JSParseNode **pnp, *pn1, *pn2;
    1:     JSString *accum, *str;
    1:     uint32 i, j;
    1: 
    1:     JS_ASSERT(pn->pn_arity == PN_LIST);
 3164:     tt = PN_TYPE(pn);
    1:     pnp = &pn->pn_head;
    1:     pn1 = *pnp;
    1:     accum = NULL;
27012:     if ((pn->pn_xflags & PNX_CANTFOLD) == 0) {
    1:         if (tt == TOK_XMLETAGO)
    1:             accum = ATOM_TO_STRING(cx->runtime->atomState.etagoAtom);
    1:         else if (tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC)
    1:             accum = ATOM_TO_STRING(cx->runtime->atomState.stagoAtom);
    1:     }
    1: 
12677:     /*
12677:      * GC Rooting here is tricky: for most of the loop, |accum| is safe via
12677:      * the newborn string root. However, when |pn2->pn_type| is TOK_XMLCDATA,
12677:      * TOK_XMLCOMMENT, or TOK_XMLPI it is knocked out of the newborn root.
12677:      * Therefore, we have to add additonal protection from GC nesting under
12677:      * js_ConcatStrings.
12677:      */
    1:     for (pn2 = pn1, i = j = 0; pn2; pn2 = pn2->pn_next, i++) {
    1:         /* The parser already rejected end-tags with attributes. */
    1:         JS_ASSERT(tt != TOK_XMLETAGO || i == 0);
    1:         switch (pn2->pn_type) {
    1:           case TOK_XMLATTR:
    1:             if (!accum)
    1:                 goto cantfold;
    1:             /* FALL THROUGH */
    1:           case TOK_XMLNAME:
    1:           case TOK_XMLSPACE:
    1:           case TOK_XMLTEXT:
    1:           case TOK_STRING:
    1:             if (pn2->pn_arity == PN_LIST)
    1:                 goto cantfold;
    1:             str = ATOM_TO_STRING(pn2->pn_atom);
    1:             break;
    1: 
    1:           case TOK_XMLCDATA:
    1:             str = js_MakeXMLCDATAString(cx, ATOM_TO_STRING(pn2->pn_atom));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLCOMMENT:
    1:             str = js_MakeXMLCommentString(cx, ATOM_TO_STRING(pn2->pn_atom));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case TOK_XMLPI:
    1:             str = js_MakeXMLPIString(cx, ATOM_TO_STRING(pn2->pn_atom),
    1:                                          ATOM_TO_STRING(pn2->pn_atom2));
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           cantfold:
    1:           default:
    1:             JS_ASSERT(*pnp == pn1);
    1:             if ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) &&
    1:                 (i & 1) ^ (j & 1)) {
    1: #ifdef DEBUG_brendanXXX
    1:                 printf("1: %d, %d => ", i, j);
    1:                 if (accum)
    1:                     js_FileEscapedString(stdout, accum, 0);
    1:                 else
    1:                     fputs("NULL", stdout);
    1:                 fputc('\n', stdout);
    1: #endif
    1:             } else if (accum && pn1 != pn2) {
    1:                 while (pn1->pn_next != pn2) {
    1:                     pn1 = RecycleTree(pn1, tc);
    1:                     --pn->pn_count;
    1:                 }
    1:                 pn1->pn_type = TOK_XMLTEXT;
    1:                 pn1->pn_op = JSOP_STRING;
    1:                 pn1->pn_arity = PN_NULLARY;
    1:                 pn1->pn_atom = js_AtomizeString(cx, accum, 0);
    1:                 if (!pn1->pn_atom)
    1:                     return JS_FALSE;
    1:                 JS_ASSERT(pnp != &pn1->pn_next);
    1:                 *pnp = pn1;
    1:             }
    1:             pnp = &pn2->pn_next;
    1:             pn1 = *pnp;
    1:             accum = NULL;
    1:             continue;
    1:         }
    1: 
    1:         if (accum) {
40398:             {
48470:                 AutoStringRooter tvr(cx, accum);
    1:                 str = ((tt == TOK_XMLSTAGO || tt == TOK_XMLPTAGC) && i != 0)
    1:                       ? js_AddAttributePart(cx, i & 1, accum, str)
    1:                       : js_ConcatStrings(cx, accum, str);
40398:             }
    1:             if (!str)
    1:                 return JS_FALSE;
    1: #ifdef DEBUG_brendanXXX
    1:             printf("2: %d, %d => ", i, j);
    1:             js_FileEscapedString(stdout, str, 0);
29366:             printf(" (%u)\n", str->length());
    1: #endif
    1:             ++j;
    1:         }
    1:         accum = str;
    1:     }
    1: 
    1:     if (accum) {
    1:         str = NULL;
27012:         if ((pn->pn_xflags & PNX_CANTFOLD) == 0) {
    1:             if (tt == TOK_XMLPTAGC)
    1:                 str = ATOM_TO_STRING(cx->runtime->atomState.ptagcAtom);
    1:             else if (tt == TOK_XMLSTAGO || tt == TOK_XMLETAGO)
    1:                 str = ATOM_TO_STRING(cx->runtime->atomState.tagcAtom);
    1:         }
    1:         if (str) {
    1:             accum = js_ConcatStrings(cx, accum, str);
    1:             if (!accum)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         JS_ASSERT(*pnp == pn1);
    1:         while (pn1->pn_next) {
    1:             pn1 = RecycleTree(pn1, tc);
    1:             --pn->pn_count;
    1:         }
    1:         pn1->pn_type = TOK_XMLTEXT;
    1:         pn1->pn_op = JSOP_STRING;
    1:         pn1->pn_arity = PN_NULLARY;
    1:         pn1->pn_atom = js_AtomizeString(cx, accum, 0);
    1:         if (!pn1->pn_atom)
    1:             return JS_FALSE;
    1:         JS_ASSERT(pnp != &pn1->pn_next);
    1:         *pnp = pn1;
    1:     }
    1: 
    1:     if (pn1 && pn->pn_count == 1) {
    1:         /*
    1:          * Only one node under pn, and it has been folded: move pn1 onto pn
    1:          * unless pn is an XML root (in which case we need it to tell the code
    1:          * generator to emit a JSOP_TOXML or JSOP_TOXMLLIST op).  If pn is an
    1:          * XML root *and* it's a point-tag, rewrite it to TOK_XMLELEM to avoid
    1:          * extra "<" and "/>" bracketing at runtime.
    1:          */
27012:         if (!(pn->pn_xflags & PNX_XMLROOT)) {
27012:             pn->become(pn1);
    1:         } else if (tt == TOK_XMLPTAGC) {
    1:             pn->pn_type = TOK_XMLELEM;
    1:             pn->pn_op = JSOP_TOXML;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
20902: static int
20902: Boolish(JSParseNode *pn)
20902: {
20902:     switch (pn->pn_op) {
20902:       case JSOP_DOUBLE:
20918:         return pn->pn_dval != 0 && !JSDOUBLE_IS_NaN(pn->pn_dval);
20902: 
20902:       case JSOP_STRING:
29366:         return ATOM_TO_STRING(pn->pn_atom)->length() != 0;
20902: 
20906: #if JS_HAS_GENERATOR_EXPRS
20902:       case JSOP_CALL:
20904:       {
20902:         /*
20902:          * A generator expression as an if or loop condition has no effects, it
20902:          * simply results in a truthy object reference. This condition folding
20903:          * is needed for the decompiler. See bug 442342 and bug 443074.
20902:          */
20902:         if (pn->pn_count != 1)
20902:             break;
20902:         JSParseNode *pn2 = pn->pn_head;
20902:         if (pn2->pn_type != TOK_FUNCTION)
20902:             break;
27012:         if (!(pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA))
20902:             break;
20902:         /* FALL THROUGH */
20904:       }
20906: #endif
20902: 
20902:       case JSOP_DEFFUN:
27012:       case JSOP_LAMBDA:
20902:       case JSOP_THIS:
20902:       case JSOP_TRUE:
20902:         return 1;
20902: 
20902:       case JSOP_NULL:
20902:       case JSOP_FALSE:
20902:         return 0;
20902: 
20902:       default:;
20902:     }
20902:     return -1;
20902: }
20902: 
    1: JSBool
20902: js_FoldConstants(JSContext *cx, JSParseNode *pn, JSTreeContext *tc, bool inCond)
    1: {
    1:     JSParseNode *pn1 = NULL, *pn2 = NULL, *pn3 = NULL;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:       {
33752:         uint32 oldflags = tc->flags;
27012:         JSFunctionBox *oldlist = tc->functionList;
27012: 
33752:         tc->flags = pn->pn_funbox->tcflags;
27012:         tc->functionList = pn->pn_funbox->kids;
    1:         if (!js_FoldConstants(cx, pn->pn_body, tc))
    1:             return JS_FALSE;
27012:         pn->pn_funbox->kids = tc->functionList;
    1:         tc->flags = oldflags;
27012:         tc->functionList = oldlist;
    1:         break;
    1:       }
    1: 
    1:       case PN_LIST:
21457:       {
21457:         /* Propagate inCond through logical connectives. */
21457:         bool cond = inCond && (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND);
21457: 
37657:         /* Don't fold a parenthesized call expression. See bug 537673. */
37657:         pn1 = pn2 = pn->pn_head;
37657:         if ((pn->pn_type == TOK_LP || pn->pn_type == TOK_NEW) && pn2->pn_parens)
37657:             pn2 = pn2->pn_next;
37657: 
    1:         /* Save the list head in pn1 for later use. */
37657:         for (; pn2; pn2 = pn2->pn_next) {
21457:             if (!js_FoldConstants(cx, pn2, tc, cond))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
21457:       }
    1: 
    1:       case PN_TERNARY:
    1:         /* Any kid may be null (e.g. for (;;)). */
    1:         pn1 = pn->pn_kid1;
    1:         pn2 = pn->pn_kid2;
    1:         pn3 = pn->pn_kid3;
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_IF))
    1:             return JS_FALSE;
20902:         if (pn2) {
20902:             if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_FORHEAD))
    1:                 return JS_FALSE;
20902:             if (pn->pn_type == TOK_FORHEAD && pn2->pn_op == JSOP_TRUE) {
20902:                 RecycleTree(pn2, tc);
20902:                 pn->pn_kid2 = NULL;
20902:             }
20902:         }
    1:         if (pn3 && !js_FoldConstants(cx, pn3, tc))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_BINARY:
    1:         pn1 = pn->pn_left;
    1:         pn2 = pn->pn_right;
20902: 
20902:         /* Propagate inCond through logical connectives. */
20909:         if (pn->pn_type == TOK_OR || pn->pn_type == TOK_AND) {
20902:             if (!js_FoldConstants(cx, pn1, tc, inCond))
    1:                 return JS_FALSE;
20902:             if (!js_FoldConstants(cx, pn2, tc, inCond))
20902:                 return JS_FALSE;
20902:             break;
20902:         }
20902: 
20902:         /* First kid may be null (for default case in switch). */
20902:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_type == TOK_WHILE))
20902:             return JS_FALSE;
20902:         if (!js_FoldConstants(cx, pn2, tc, pn->pn_type == TOK_DO))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_UNARY:
    1:         pn1 = pn->pn_kid;
35096: 
35096:         /*
35096:          * Kludge to deal with typeof expressions: because constant folding
35096:          * can turn an expression into a name node, we have to check here,
35096:          * before folding, to see if we should throw undefined name errors.
35096:          *
35096:          * NB: We know that if pn->pn_op is JSOP_TYPEOF, pn1 will not be
35096:          * null. This assumption does not hold true for other unary
35096:          * expressions.
35096:          */
35096:         if (pn->pn_op == JSOP_TYPEOF && pn1->pn_type != TOK_NAME)
35096:             pn->pn_op = JSOP_TYPEOFEXPR;
35096: 
31479:         if (pn1 && !js_FoldConstants(cx, pn1, tc, pn->pn_op == JSOP_NOT))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_NAME:
    1:         /*
    1:          * Skip pn1 down along a chain of dotted member expressions to avoid
    1:          * excessive recursion.  Our only goal here is to fold constants (if
    1:          * any) in the primary expression operand to the left of the first
    1:          * dot in the chain.
    1:          */
27012:         if (!pn->pn_used) {
    1:             pn1 = pn->pn_expr;
27012:             while (pn1 && pn1->pn_arity == PN_NAME && !pn1->pn_used)
    1:                 pn1 = pn1->pn_expr;
    1:             if (pn1 && !js_FoldConstants(cx, pn1, tc))
    1:                 return JS_FALSE;
27012:         }
27012:         break;
27012: 
27012:       case PN_NAMESET:
27012:         pn1 = pn->pn_tree;
27012:         if (!js_FoldConstants(cx, pn1, tc))
27012:             return JS_FALSE;
    1:         break;
    1: 
    1:       case PN_NULLARY:
    1:         break;
    1:     }
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_IF:
    1:         if (ContainsStmt(pn2, TOK_VAR) || ContainsStmt(pn3, TOK_VAR))
    1:             break;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_HOOK:
    1:         /* Reduce 'if (C) T; else E' into T for true C, E for false. */
    1:         switch (pn1->pn_type) {
    1:           case TOK_NUMBER:
  207:             if (pn1->pn_dval == 0 || JSDOUBLE_IS_NaN(pn1->pn_dval))
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_STRING:
29366:             if (ATOM_TO_STRING(pn1->pn_atom)->length() == 0)
    1:                 pn2 = pn3;
    1:             break;
    1:           case TOK_PRIMARY:
    1:             if (pn1->pn_op == JSOP_TRUE)
    1:                 break;
    1:             if (pn1->pn_op == JSOP_FALSE || pn1->pn_op == JSOP_NULL) {
    1:                 pn2 = pn3;
    1:                 break;
    1:             }
    1:             /* FALL THROUGH */
    1:           default:
    1:             /* Early return to dodge common code that copies pn2 to pn. */
    1:             return JS_TRUE;
    1:         }
    1: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577:         /* Don't fold a trailing |if (0)| in a generator expression. */
 1577:         if (!pn2 && (tc->flags & TCF_GENEXP_LAMBDA))
 1577:             break;
 1577: #endif
 1577: 
31479:         if (pn2 && !pn2->pn_defn)
27012:             pn->become(pn2);
    1:         if (!pn2 || (pn->pn_type == TOK_SEMI && !pn->pn_kid)) {
    1:             /*
    1:              * False condition and no else, or an empty then-statement was
    1:              * moved up over pn.  Either way, make pn an empty block (not an
    1:              * empty statement, which does not decompile, even when labeled).
    1:              * NB: pn must be a TOK_IF as TOK_HOOK can never have a null kid
    1:              * or an empty statement for a child.
    1:              */
    1:             pn->pn_type = TOK_LC;
    1:             pn->pn_arity = PN_LIST;
27012:             pn->makeEmpty();
    1:         }
    1:         RecycleTree(pn2, tc);
    1:         if (pn3 && pn3 != pn2)
    1:             RecycleTree(pn3, tc);
    1:         break;
    1: 
20902:       case TOK_OR:
20905:       case TOK_AND:
20902:         if (inCond) {
20905:             if (pn->pn_arity == PN_LIST) {
20905:                 JSParseNode **pnp = &pn->pn_head;
20905:                 JS_ASSERT(*pnp == pn1);
20905:                 do {
20905:                     int cond = Boolish(pn1);
20905:                     if (cond == (pn->pn_type == TOK_OR)) {
20905:                         for (pn2 = pn1->pn_next; pn2; pn2 = pn3) {
20905:                             pn3 = pn2->pn_next;
20905:                             RecycleTree(pn2, tc);
20905:                             --pn->pn_count;
20905:                         }
20905:                         pn1->pn_next = NULL;
20905:                         break;
20905:                     }
20905:                     if (cond != -1) {
20905:                         JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20905:                         if (pn->pn_count == 1)
20905:                             break;
20905:                         *pnp = pn1->pn_next;
20905:                         RecycleTree(pn1, tc);
20905:                         --pn->pn_count;
20905:                     } else {
20905:                         pnp = &pn1->pn_next;
20905:                     }
20905:                 } while ((pn1 = *pnp) != NULL);
20905: 
20905:                 // We may have to change arity from LIST to BINARY.
20911:                 pn1 = pn->pn_head;
20905:                 if (pn->pn_count == 2) {
20905:                     pn2 = pn1->pn_next;
20905:                     pn1->pn_next = NULL;
20905:                     JS_ASSERT(!pn2->pn_next);
20905:                     pn->pn_arity = PN_BINARY;
20905:                     pn->pn_left = pn1;
20905:                     pn->pn_right = pn2;
20905:                 } else if (pn->pn_count == 1) {
27012:                     pn->become(pn1);
20905:                     RecycleTree(pn1, tc);
20905:                 }
20905:             } else {
20905:                 int cond = Boolish(pn1);
20905:                 if (cond == (pn->pn_type == TOK_OR)) {
20902:                     RecycleTree(pn2, tc);
27012:                     pn->become(pn1);
20905:                 } else if (cond != -1) {
20905:                     JS_ASSERT(cond == (pn->pn_type == TOK_AND));
20902:                     RecycleTree(pn1, tc);
27012:                     pn->become(pn2);
20902:                 }
20902:             }
20902:         }
20902:         break;
20902: 
    1:       case TOK_ASSIGN:
    1:         /*
    1:          * Compound operators such as *= should be subject to folding, in case
    1:          * the left-hand side is constant, and so that the decompiler produces
    1:          * the same string that you get from decompiling a script or function
    1:          * compiled from that same string.  As with +, += is special.
    1:          */
    1:         if (pn->pn_op == JSOP_NOP)
    1:             break;
    1:         if (pn->pn_op != JSOP_ADD)
    1:             goto do_binary_op;
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_PLUS:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             size_t length, length2;
    1:             jschar *chars;
    1:             JSString *str, *str2;
    1: 
    1:             /*
    1:              * Any string literal term with all others number or string means
    1:              * this is a concatenation.  If any term is not a string or number
    1:              * literal, we can't fold.
    1:              */
    1:             JS_ASSERT(pn->pn_count > 2);
27012:             if (pn->pn_xflags & PNX_CANTFOLD)
    1:                 return JS_TRUE;
27012:             if (pn->pn_xflags != PNX_STRCAT)
    1:                 goto do_binary_op;
    1: 
    1:             /* Ok, we're concatenating: convert non-string constant operands. */
    1:             length = 0;
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_STRING))
    1:                     return JS_FALSE;
    1:                 /* XXX fold only if all operands convert to string */
    1:                 if (pn2->pn_type != TOK_STRING)
    1:                     return JS_TRUE;
29366:                 length += ATOM_TO_STRING(pn2->pn_atom)->flatLength();
    1:             }
    1: 
    1:             /* Allocate a new buffer and string descriptor for the result. */
30851:             chars = (jschar *) cx->malloc((length + 1) * sizeof(jschar));
    1:             if (!chars)
    1:                 return JS_FALSE;
 4718:             str = js_NewString(cx, chars, length);
    1:             if (!str) {
30851:                 cx->free(chars);
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             /* Fill the buffer, advancing chars and recycling kids as we go. */
    1:             for (pn2 = pn1; pn2; pn2 = RecycleTree(pn2, tc)) {
    1:                 str2 = ATOM_TO_STRING(pn2->pn_atom);
29366:                 length2 = str2->flatLength();
29366:                 js_strncpy(chars, str2->flatChars(), length2);
    1:                 chars += length2;
    1:             }
    1:             *chars = 0;
    1: 
    1:             /* Atomize the result string and mutate pn to refer to it. */
    1:             pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             break;
    1:         }
    1: 
    1:         /* Handle a binary string concatenation. */
    1:         JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:         if (pn1->pn_type == TOK_STRING || pn2->pn_type == TOK_STRING) {
    1:             JSString *left, *right, *str;
    1: 
    1:             if (!FoldType(cx, (pn1->pn_type != TOK_STRING) ? pn1 : pn2,
    1:                           TOK_STRING)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type != TOK_STRING || pn2->pn_type != TOK_STRING)
    1:                 return JS_TRUE;
    1:             left = ATOM_TO_STRING(pn1->pn_atom);
    1:             right = ATOM_TO_STRING(pn2->pn_atom);
    1:             str = js_ConcatStrings(cx, left, right);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             pn->pn_atom = js_AtomizeString(cx, str, 0);
    1:             if (!pn->pn_atom)
    1:                 return JS_FALSE;
    1:             pn->pn_type = TOK_STRING;
    1:             pn->pn_op = JSOP_STRING;
    1:             pn->pn_arity = PN_NULLARY;
    1:             RecycleTree(pn1, tc);
    1:             RecycleTree(pn2, tc);
    1:             break;
    1:         }
    1: 
    1:         /* Can't concatenate string literals, let's try numbers. */
    1:         goto do_binary_op;
    1: 
    1:       case TOK_STAR:
    1:       case TOK_SHOP:
    1:       case TOK_MINUS:
    1:       case TOK_DIVOP:
    1:       do_binary_op:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_count > 2);
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 if (!FoldType(cx, pn2, TOK_NUMBER))
    1:                     return JS_FALSE;
    1:             }
    1:             for (pn2 = pn1; pn2; pn2 = pn2->pn_next) {
    1:                 /* XXX fold only if all operands convert to number */
    1:                 if (pn2->pn_type != TOK_NUMBER)
    1:                     break;
    1:             }
    1:             if (!pn2) {
 3164:                 JSOp op = PN_OP(pn);
    1: 
    1:                 pn2 = pn1->pn_next;
    1:                 pn3 = pn2->pn_next;
    1:                 if (!FoldBinaryNumeric(cx, op, pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:                 while ((pn2 = pn3) != NULL) {
    1:                     pn3 = pn2->pn_next;
    1:                     if (!FoldBinaryNumeric(cx, op, pn, pn2, pn, tc))
    1:                         return JS_FALSE;
    1:                 }
    1:             }
    1:         } else {
    1:             JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:             if (!FoldType(cx, pn1, TOK_NUMBER) ||
    1:                 !FoldType(cx, pn2, TOK_NUMBER)) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (pn1->pn_type == TOK_NUMBER && pn2->pn_type == TOK_NUMBER) {
 3164:                 if (!FoldBinaryNumeric(cx, PN_OP(pn), pn1, pn2, pn, tc))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_UNARYOP:
    1:         if (pn1->pn_type == TOK_NUMBER) {
    1:             jsdouble d;
    1: 
    1:             /* Operate on one numeric constant. */
    1:             d = pn1->pn_dval;
    1:             switch (pn->pn_op) {
    1:               case JSOP_BITNOT:
 9613:                 d = ~js_DoubleToECMAInt32(d);
    1:                 break;
    1: 
    1:               case JSOP_NEG:
    1:                 d = -d;
    1:                 break;
    1: 
    1:               case JSOP_POS:
    1:                 break;
    1: 
    1:               case JSOP_NOT:
    1:                 pn->pn_type = TOK_PRIMARY;
  207:                 pn->pn_op = (d == 0 || JSDOUBLE_IS_NaN(d)) ? JSOP_TRUE : JSOP_FALSE;
    1:                 pn->pn_arity = PN_NULLARY;
    1:                 /* FALL THROUGH */
    1: 
    1:               default:
    1:                 /* Return early to dodge the common TOK_NUMBER code. */
    1:                 return JS_TRUE;
    1:             }
    1:             pn->pn_type = TOK_NUMBER;
 3328:             pn->pn_op = JSOP_DOUBLE;
    1:             pn->pn_arity = PN_NULLARY;
    1:             pn->pn_dval = d;
    1:             RecycleTree(pn1, tc);
20918:         } else if (pn1->pn_type == TOK_PRIMARY) {
20918:             if (pn->pn_op == JSOP_NOT &&
20918:                 (pn1->pn_op == JSOP_TRUE ||
20918:                  pn1->pn_op == JSOP_FALSE)) {
27012:                 pn->become(pn1);
20918:                 pn->pn_op = (pn->pn_op == JSOP_TRUE) ? JSOP_FALSE : JSOP_TRUE;
20918:                 RecycleTree(pn1, tc);
20918:             }
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLELEM:
    1:       case TOK_XMLLIST:
    1:       case TOK_XMLPTAGC:
    1:       case TOK_XMLSTAGO:
    1:       case TOK_XMLETAGO:
    1:       case TOK_XMLNAME:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_type == TOK_XMLLIST || pn->pn_count != 0);
    1:             if (!FoldXMLConstants(cx, pn, tc))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       case TOK_AT:
    1:         if (pn1->pn_type == TOK_XMLNAME) {
27012:             JSObjectBox *xmlbox;
    1: 
48470:             Value v = StringValue(ATOM_TO_STRING(pn1->pn_atom));
    1:             if (!js_ToAttributeName(cx, &v))
    1:                 return JS_FALSE;
48470:             JS_ASSERT(v.isObject());
48470: 
48470:             xmlbox = tc->parser->newObjectBox(&v.toObject());
27012:             if (!xmlbox)
    1:                 return JS_FALSE;
    1: 
    1:             pn->pn_type = TOK_XMLNAME;
    1:             pn->pn_op = JSOP_OBJECT;
    1:             pn->pn_arity = PN_NULLARY;
27012:             pn->pn_objbox = xmlbox;
    1:             RecycleTree(pn1, tc);
    1:         }
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       default:;
    1:     }
    1: 
20902:     if (inCond) {
20902:         int cond = Boolish(pn);
20902:         if (cond >= 0) {
27012:             switch (pn->pn_arity) {
27012:               case PN_LIST:
20902:                 pn2 = pn->pn_head;
20902:                 do {
20902:                     pn3 = pn2->pn_next;
20902:                     RecycleTree(pn2, tc);
20902:                 } while ((pn2 = pn3) != NULL);
27012:                 break;
27012:               case PN_FUNC:
27012:                 RecycleFuncNameKids(pn, tc);
27012:                 break;
27012:               case PN_NULLARY:
27012:                 break;
27012:               default:
27012:                 JS_NOT_REACHED("unhandled arity");
20902:             }
20902:             pn->pn_type = TOK_PRIMARY;
20902:             pn->pn_op = cond ? JSOP_TRUE : JSOP_FALSE;
20902:             pn->pn_arity = PN_NULLARY;
20902:         }
20902:     }
20902: 
    1:     return JS_TRUE;
    1: }
