 94512: # This Source Code Form is subject to the terms of the Mozilla Public
 94512: # License, v. 2.0. If a copy of the MPL was not distributed with this file,
 94512: # You can obtain one at http://mozilla.org/MPL/2.0/.
 94512: 
 94512: # Common codegen classes.
 94512: 
 94512: import os
 94512: import string
102822: import operator
 94512: 
 94512: from WebIDL import *
102326: from Configuration import NoSuchDescriptorError
 94512: 
 94512: AUTOGENERATED_WARNING_COMMENT = \
 94512:     "/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n"
 99121: ADDPROPERTY_HOOK_NAME = '_addProperty'
 99121: FINALIZE_HOOK_NAME = '_finalize'
 99121: TRACE_HOOK_NAME = '_trace'
 99121: CONSTRUCT_HOOK_NAME = '_constructor'
 99121: HASINSTANCE_HOOK_NAME = '_hasInstance'
 94512: 
 94512: def replaceFileIfChanged(filename, newContents):
 94512:     """
 94512:     Read a copy of the old file, so that we don't touch it if it hasn't changed.
 94512:     Returns True if the file was updated, false otherwise.
 94512:     """
 94512:     oldFileContents = ""
 94512:     try:
 94512:         oldFile = open(filename, 'rb')
 94512:         oldFileContents = ''.join(oldFile.readlines())
 94512:         oldFile.close()
 94512:     except:
 94512:         pass
 94512: 
 94512:     if newContents == oldFileContents:
 94512:         return False
 94512: 
 94512:     f = open(filename, 'wb')
 94512:     f.write(newContents)
 94512:     f.close()
 94512: 
 94512: def toStringBool(arg):
 94512:     return str(not not arg).lower()
 94512: 
 97422: def toBindingNamespace(arg):
 97422:     return re.sub("((_workers)?$)", "Binding\\1", arg);
 97422: 
 94512: class CGThing():
 94512:     """
 94512:     Abstract base class for things that spit out code.
 94512:     """
 94512:     def __init__(self):
 94512:         pass # Nothing for now
 94512:     def declare(self):
 94512:         """Produce code for a header file."""
 94512:         assert(False)  # Override me!
 94512:     def define(self):
 94512:         """Produce code for a cpp file."""
 94512:         assert(False) # Override me!
 94512: 
 94512: class CGNativePropertyHooks(CGThing):
 94512:     """
 94512:     Generate a NativePropertyHooks for a given descriptor
 94512:     """
120342:     def __init__(self, descriptor, properties):
 94512:         CGThing.__init__(self)
 94512:         self.descriptor = descriptor
120342:         self.properties = properties
 94512:     def declare(self):
 99238:         if self.descriptor.workers:
 99238:             return ""
120342:         return "extern const NativePropertyHooks sNativePropertyHooks;\n"
 94512:     def define(self):
 99238:         if self.descriptor.workers:
 99238:             return ""
109259:         if self.descriptor.concrete and self.descriptor.proxy:
109259:             resolveOwnProperty = "ResolveOwnProperty"
109259:             enumerateOwnProperties = "EnumerateOwnProperties"
109259:         else:
120342:             resolveOwnProperty = "nullptr"
120342:             enumerateOwnProperties = "nullptr"
120342:         if self.properties.hasNonChromeOnly():
120342:             regular = "&sNativeProperties"
120342:         else:
120342:             regular = "nullptr"
120342:         if self.properties.hasChromeOnly():
120342:             chrome = "&sChromeOnlyNativeProperties"
120342:         else:
120342:             chrome = "nullptr"
120342:         constructorID = "constructors::id::"
120342:         if self.descriptor.interface.hasInterfaceObject():
120342:             constructorID += self.descriptor.name
120342:         else:
120342:             constructorID += "_ID_Count"
120342:         prototypeID = "prototypes::id::"
120342:         if self.descriptor.interface.hasInterfacePrototypeObject():
120342:             prototypeID += self.descriptor.name
120342:         else:
120342:             prototypeID += "_ID_Count"
 94512:         parent = self.descriptor.interface.parent
120342:         parentHooks = ("&" + toBindingNamespace(parent.identifier.name) + "::sNativePropertyHooks"
 97422:                        if parent else 'NULL')
120342: 
120342:         return CGWrapper(CGIndenter(CGList([CGGeneric(resolveOwnProperty),
120342:                                             CGGeneric(enumerateOwnProperties),
120342:                                             CGWrapper(CGList([CGGeneric(regular),
120342:                                                               CGGeneric(chrome)],
120342:                                                              ", "),
120342:                                                       pre="{ ", post=" }"),
120342:                                             CGGeneric(prototypeID),
120342:                                             CGGeneric(constructorID),
120342:                                             CGGeneric(parentHooks)],
120342:                                            ",\n")),
120342:                          pre="const NativePropertyHooks sNativePropertyHooks = {\n",
120342:                          post="\n};\n").define()
120342: 
120342: def NativePropertyHooks(descriptor):
120342:     return "&sWorkerNativePropertyHooks" if descriptor.workers else "&sNativePropertyHooks"
 94512: 
109136: def DOMClass(descriptor):
109136:         protoList = ['prototypes::id::' + proto for proto in descriptor.prototypeChain]
109136:         # Pad out the list to the right length with _ID_Count so we
109136:         # guarantee that all the lists are the same length.  _ID_Count
109136:         # is never the ID of any prototype, so it's safe to use as
109136:         # padding.
109136:         protoList.extend(['prototypes::id::_ID_Count'] * (descriptor.config.maxProtoChainLength - len(protoList)))
109136:         prototypeChainString = ', '.join(protoList)
118868:         if descriptor.workers or descriptor.nativeOwnership != 'refcounted':
118868:             participant = "nullptr"
118868:         else:
118868:             participant = "NS_CYCLE_COLLECTION_PARTICIPANT(%s)" % descriptor.nativeType
109136:         return """{
109136:   { %s },
120342:   %s,
120342:   %s,
120342:   %s
115607: }""" % (prototypeChainString, toStringBool(descriptor.nativeOwnership == 'nsisupports'),
120342:         NativePropertyHooks(descriptor),
118868:         participant)
109136: 
 94512: class CGDOMJSClass(CGThing):
 94512:     """
 94512:     Generate a DOMJSClass for a given descriptor
 94512:     """
 94512:     def __init__(self, descriptor):
 94512:         CGThing.__init__(self)
 94512:         self.descriptor = descriptor
116290:         # Our current reserved slot situation is unsafe for globals. Fix bug 760095!
116290:         assert "Window" not in descriptor.interface.identifier.name
 94512:     def declare(self):
 94512:         return "extern DOMJSClass Class;\n"
 94512:     def define(self):
 94512:         traceHook = TRACE_HOOK_NAME if self.descriptor.customTrace else 'NULL'
 94512:         return """
 94512: DOMJSClass Class = {
 94512:   { "%s",
116290:     JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
 94512:     %s, /* addProperty */
 94512:     JS_PropertyStub,       /* delProperty */
 94512:     JS_PropertyStub,       /* getProperty */
 94512:     JS_StrictPropertyStub, /* setProperty */
 94512:     JS_EnumerateStub,
 94512:     JS_ResolveStub,
 94512:     JS_ConvertStub,
 94512:     %s, /* finalize */
 94512:     NULL,                  /* checkAccess */
 94512:     NULL,                  /* call */
 98058:     NULL,                  /* hasInstance */
 94512:     NULL,                  /* construct */
 94512:     %s, /* trace */
 94512:     JSCLASS_NO_INTERNAL_MEMBERS
 94512:   },
111243: %s
 94512: };
 94512: """ % (self.descriptor.interface.identifier.name,
102142:        ADDPROPERTY_HOOK_NAME if self.descriptor.concrete and not self.descriptor.workers and self.descriptor.wrapperCache else 'JS_PropertyStub',
109136:        FINALIZE_HOOK_NAME, traceHook,
109136:        CGIndenter(CGGeneric(DOMClass(self.descriptor))).define())
 94512: 
 94512: class CGPrototypeJSClass(CGThing):
120342:     def __init__(self, descriptor, properties):
 94512:         CGThing.__init__(self)
 94512:         self.descriptor = descriptor
120342:         self.properties = properties
 94512:     def declare(self):
 94512:         # We're purely for internal consumption
 94512:         return ""
 94512:     def define(self):
120342:         return """static DOMIfaceAndProtoJSClass PrototypeClass = {
120342:   {
107786:     "%sPrototype",
120342:     JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
 94512:     JS_PropertyStub,       /* addProperty */
 94512:     JS_PropertyStub,       /* delProperty */
 94512:     JS_PropertyStub,       /* getProperty */
 94512:     JS_StrictPropertyStub, /* setProperty */
 94512:     JS_EnumerateStub,
 94512:     JS_ResolveStub,
 94512:     JS_ConvertStub,
120342:     nullptr,               /* finalize */
120342:     nullptr,               /* checkAccess */
120342:     nullptr,               /* call */
120342:     nullptr,               /* hasInstance */
120342:     nullptr,               /* construct */
120342:     nullptr,               /* trace */
 94512:     JSCLASS_NO_INTERNAL_MEMBERS
120342:   },
120342:   eInterfacePrototype,
120342:   %s
 94512: };
120342: """ % (self.descriptor.interface.identifier.name,
120342:        NativePropertyHooks(self.descriptor))
 94512: 
 94512: class CGInterfaceObjectJSClass(CGThing):
120342:     def __init__(self, descriptor, properties):
 94512:         CGThing.__init__(self)
 94512:         self.descriptor = descriptor
120342:         self.properties = properties
 94512:     def declare(self):
 94512:         # We're purely for internal consumption
 94512:         return ""
 94512:     def define(self):
 97423:         if not self.descriptor.hasInstanceInterface:
 97423:             return ""
120342:         if self.descriptor.interface.ctor():
120342:             ctorname = CONSTRUCT_HOOK_NAME
120342:         else:
120342:             ctorname = "ThrowingConstructor"
 97423:         hasinstance = HASINSTANCE_HOOK_NAME
 94512:         return """
120342: static DOMIfaceAndProtoJSClass InterfaceObjectClass = {
120342:   {
120342:     "Function",
120342:     JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2),
 94512:     JS_PropertyStub,       /* addProperty */
 94512:     JS_PropertyStub,       /* delProperty */
 94512:     JS_PropertyStub,       /* getProperty */
 94512:     JS_StrictPropertyStub, /* setProperty */
 94512:     JS_EnumerateStub,
 94512:     JS_ResolveStub,
 94512:     JS_ConvertStub,
120342:     nullptr,               /* finalize */
120342:     nullptr,               /* checkAccess */
 94512:     %s, /* call */
 98058:     %s, /* hasInstance */
 94512:     %s, /* construct */
120342:     nullptr,               /* trace */
 94512:     JSCLASS_NO_INTERNAL_MEMBERS
120342:   },
120342:   eInterface,
120342:   %s
 94512: };
120342: """ % (ctorname, hasinstance, ctorname, NativePropertyHooks(self.descriptor))
 94512: 
 94512: class CGList(CGThing):
 94512:     """
 94512:     Generate code for a list of GCThings.  Just concatenates them together, with
 94512:     an optional joiner string.  "\n" is a common joiner.
 94512:     """
 94512:     def __init__(self, children, joiner=""):
 94512:         CGThing.__init__(self)
 94512:         self.children = children
 94512:         self.joiner = joiner
 94512:     def append(self, child):
 94512:         self.children.append(child)
 94512:     def prepend(self, child):
 94512:         self.children.insert(0, child)
109136:     def join(self, generator):
109136:         return self.joiner.join(filter(lambda s: len(s) > 0, (child for child in generator)))
 94512:     def declare(self):
109136:         return self.join(child.declare() for child in self.children if child is not None)
 94512:     def define(self):
109136:         return self.join(child.define() for child in self.children if child is not None)
 94512: 
 94512: class CGGeneric(CGThing):
 94512:     """
 94512:     A class that spits out a fixed string into the codegen.  Can spit out a
 94512:     separate string for the declaration too.
 94512:     """
 94512:     def __init__(self, define="", declare=""):
 94512:         self.declareText = declare
 94512:         self.defineText = define
 94512:     def declare(self):
 94512:         return self.declareText
 94512:     def define(self):
 94512:         return self.defineText
 94512: 
 94512: # We'll want to insert the indent at the beginnings of lines, but we
 94512: # don't want to indent empty lines.  So only indent lines that have a
 94512: # non-newline character on them.
 94512: lineStartDetector = re.compile("^(?=[^\n#])", re.MULTILINE)
 94512: class CGIndenter(CGThing):
 94512:     """
 94512:     A class that takes another CGThing and generates code that indents that
 94512:     CGThing by some number of spaces.  The default indent is two spaces.
 94512:     """
109136:     def __init__(self, child, indentLevel=2, declareOnly=False):
 94512:         CGThing.__init__(self)
 94512:         self.child = child
 94512:         self.indent = " " * indentLevel
109136:         self.declareOnly = declareOnly
 94512:     def declare(self):
 94512:         decl = self.child.declare()
 94512:         if decl is not "":
 94512:             return re.sub(lineStartDetector, self.indent, decl)
 94512:         else:
 94512:             return ""
 94512:     def define(self):
 94512:         defn = self.child.define()
109136:         if defn is not "" and not self.declareOnly:
 94512:             return re.sub(lineStartDetector, self.indent, defn)
 94512:         else:
109136:             return defn
 94512: 
 94512: class CGWrapper(CGThing):
 94512:     """
 94512:     Generic CGThing that wraps other CGThings with pre and post text.
 94512:     """
 94512:     def __init__(self, child, pre="", post="", declarePre=None,
 94512:                  declarePost=None, definePre=None, definePost=None,
 97422:                  declareOnly=False, defineOnly=False, reindent=False):
 94512:         CGThing.__init__(self)
 94512:         self.child = child
 94512:         self.declarePre = declarePre or pre
 94512:         self.declarePost = declarePost or post
 94512:         self.definePre = definePre or pre
 94512:         self.definePost = definePost or post
 94512:         self.declareOnly = declareOnly
 97422:         self.defineOnly = defineOnly
 96737:         self.reindent = reindent
 94512:     def declare(self):
 97422:         if self.defineOnly:
 97422:             return ''
 96737:         decl = self.child.declare()
 96737:         if self.reindent:
 96737:             # We don't use lineStartDetector because we don't want to
 96737:             # insert whitespace at the beginning of our _first_ line.
 96737:             decl = stripTrailingWhitespace(
 96737:                 decl.replace("\n", "\n" + (" " * len(self.declarePre))))
 96737:         return self.declarePre + decl + self.declarePost
 94512:     def define(self):
 94512:         if self.declareOnly:
 94512:             return ''
 96737:         defn = self.child.define()
 96737:         if self.reindent:
 96737:             # We don't use lineStartDetector because we don't want to
 96737:             # insert whitespace at the beginning of our _first_ line.
 96737:             defn = stripTrailingWhitespace(
 96737:                 defn.replace("\n", "\n" + (" " * len(self.definePre))))
 96737:         return self.definePre + defn + self.definePost
 94512: 
109136: class CGIfWrapper(CGWrapper):
109136:     def __init__(self, child, condition):
109136:         pre = CGWrapper(CGGeneric(condition), pre="if (", post=") {\n",
109136:                         reindent=True)
109136:         CGWrapper.__init__(self, CGIndenter(child), pre=pre.define(),
109136:                            post="\n}")
109136: 
 94512: class CGNamespace(CGWrapper):
 94512:     def __init__(self, namespace, child, declareOnly=False):
 94512:         pre = "namespace %s {\n" % namespace
 94512:         post = "} // namespace %s\n" % namespace
 94512:         CGWrapper.__init__(self, child, pre=pre, post=post,
 94512:                            declareOnly=declareOnly)
 94512:     @staticmethod
 94512:     def build(namespaces, child, declareOnly=False):
 94512:         """
 94512:         Static helper method to build multiple wrapped namespaces.
 94512:         """
 94512:         if not namespaces:
 99122:             return CGWrapper(child, declareOnly=declareOnly)
 99122:         inner = CGNamespace.build(namespaces[1:], child, declareOnly=declareOnly)
 99122:         return CGNamespace(namespaces[0], inner, declareOnly=declareOnly)
 94512: 
 94512: class CGIncludeGuard(CGWrapper):
 94512:     """
 94512:     Generates include guards for a header.
 94512:     """
 94512:     def __init__(self, prefix, child):
 94512:         """|prefix| is the filename without the extension."""
 97422:         define = 'mozilla_dom_%s_h__' % prefix
 94512:         CGWrapper.__init__(self, child,
 94512:                            declarePre='#ifndef %s\n#define %s\n\n' % (define, define),
 94512:                            declarePost='\n#endif // %s\n' % define)
 94512: 
121472: def getTypesFromDescriptor(descriptor):
102822:     """
102822:     Get all argument and return types for all members of the descriptor
102822:     """
102822:     members = [m for m in descriptor.interface.members]
106693:     if descriptor.interface.ctor():
106693:         members.append(descriptor.interface.ctor())
102822:     signatures = [s for m in members if m.isMethod() for s in m.signatures()]
102822:     types = []
102822:     for s in signatures:
102822:         assert len(s) == 2
102822:         (returnType, arguments) = s
102822:         types.append(returnType)
121472:         types.extend(a.type for a in arguments)
102822: 
102822:     types.extend(a.type for a in members if a.isAttr())
102822:     return types
102822: 
121472: def getTypesFromDictionary(dictionary):
121472:     """
121472:     Get all member types for this dictionary
121472:     """
121472:     types = []
121472:     curDict = dictionary
121472:     while curDict:
121472:         types.extend([m.type for m in curDict.members])
121472:         curDict = curDict.parent
121472:     return types
121472: 
121472: def getTypesFromCallback(callback):
121472:     """
121472:     Get the types this callback depends on: its return type and the
121472:     types of its arguments.
121472:     """
121472:     sig = callback.signatures()[0]
121472:     types = [sig[0]] # Return type
121472:     types.extend(arg.type for arg in sig[1]) # Arguments
121472:     return types
121472: 
121472: def getRelevantProviders(descriptor, dictionary, config):
121472:     assert not descriptor or not dictionary
121472:     if descriptor is not None:
121472:         return [descriptor]
121472:     if dictionary is not None:
121472:         # Do both the non-worker and worker versions
121472:         return [
121472:             config.getDescriptorProvider(False),
121472:             config.getDescriptorProvider(True)
121472:             ]
121472:     # Do non-workers only for callbacks
121472:     return [ config.getDescriptorProvider(False) ]
121472: 
121472: def callForEachType(descriptors, dictionaries, callbacks, func):
121472:     for d in descriptors:
121472:         if d.interface.isExternal():
121472:             continue
121472:         for t in getTypesFromDescriptor(d):
121472:             func(t, descriptor=d)
121472:     for dictionary in dictionaries:
121472:         for t in getTypesFromDictionary(dictionary):
121472:             func(t, dictionary=dictionary)
121472:     for callback in callbacks:
121472:         for t in getTypesFromCallback(callback):
121472:             func(t)
121472: 
 94512: class CGHeaders(CGWrapper):
 94512:     """
 94512:     Generates the appropriate include statements.
 94512:     """
121472:     def __init__(self, descriptors, dictionaries, callbacks, declareIncludes,
121472:                  defineIncludes, child, config=None):
 94512:         """
 94512:         Builds a set of includes to cover |descriptors|.
 94512: 
 94512:         Also includes the files in |declareIncludes| in the header
 94512:         file and the files in |defineIncludes| in the .cpp.
 94512:         """
 94512: 
 94512:         # Determine the filenames for which we need headers.
 94512:         interfaceDeps = [d.interface for d in descriptors]
 94512:         ancestors = []
 94512:         for iface in interfaceDeps:
 94512:             while iface.parent:
 94512:                 ancestors.append(iface.parent)
 94512:                 iface = iface.parent
 94512:         interfaceDeps.extend(ancestors)
101766:         bindingIncludes = set(self.getDeclarationFilename(d) for d in interfaceDeps)
 94512: 
 94512:         # Grab all the implementation declaration files we need.
 94512:         implementationIncludes = set(d.headerFile for d in descriptors)
 94512: 
 94512:         # Now find all the things we'll need as arguments because we
 94512:         # need to wrap or unwrap them.
 94512:         bindingHeaders = set()
121472:         def addHeadersForType(t, descriptor=None, dictionary=None):
121472:             """
121472:             Add the relevant headers for this type.  We use descriptor and
121472:             dictionary, if passed, to decide what to do with interface types.
121472:             """
121472:             assert not descriptor or not dictionary
102822:             if t.unroll().isUnion():
102822:                 # UnionConversions.h includes UnionTypes.h
102822:                 bindingHeaders.add("mozilla/dom/UnionConversions.h")
102822:             elif t.unroll().isInterface():
 99320:                 if t.unroll().isSpiderMonkeyInterface():
 95834:                     bindingHeaders.add("jsfriendapi.h")
 99320:                     bindingHeaders.add("mozilla/dom/TypedArray.h")
 94512:                 else:
121472:                     providers = getRelevantProviders(descriptor, dictionary,
121472:                                                      config)
121472:                     for p in providers:
121472:                         try:
121472:                             typeDesc = p.getDescriptor(t.unroll().inner.identifier.name)
121472:                         except NoSuchDescriptorError:
121472:                             continue
 94512:                         implementationIncludes.add(typeDesc.headerFile)
101766:                         bindingHeaders.add(self.getDeclarationFilename(typeDesc.interface))
101766:             elif t.unroll().isDictionary():
101766:                 bindingHeaders.add(self.getDeclarationFilename(t.unroll().inner))
121472:             elif t.unroll().isCallback():
121472:                 # Callbacks are both a type and an object
121472:                 bindingHeaders.add(self.getDeclarationFilename(t.unroll()))
121472: 
121472:         callForEachType(descriptors, dictionaries, callbacks, addHeadersForType)
101766: 
101766:         declareIncludes = set(declareIncludes)
101766:         for d in dictionaries:
101766:             if d.parent:
101766:                 declareIncludes.add(self.getDeclarationFilename(d.parent))
101766:             bindingHeaders.add(self.getDeclarationFilename(d))
 94512: 
121472:         for c in callbacks:
121472:             bindingHeaders.add(self.getDeclarationFilename(c))
121472: 
121472:         if len(callbacks) != 0:
121472:             # We need CallbackFunction to serve as our parent class
121472:             declareIncludes.add("mozilla/dom/CallbackFunction.h")
121472: 
 94512:         # Let the machinery do its thing.
 94512:         def _includeString(includes):
 94512:             return ''.join(['#include "%s"\n' % i for i in includes]) + '\n'
 94512:         CGWrapper.__init__(self, child,
101766:                            declarePre=_includeString(sorted(declareIncludes)),
 94512:                            definePre=_includeString(sorted(set(defineIncludes) |
 94512:                                                            bindingIncludes |
 94512:                                                            bindingHeaders |
 94512:                                                            implementationIncludes)))
 94512:     @staticmethod
101766:     def getDeclarationFilename(decl):
 99235:         # Use our local version of the header, not the exported one, so that
 99235:         # test bindings, which don't export, will work correctly.
101766:         basename = os.path.basename(decl.filename())
 99235:         return basename.replace('.webidl', 'Binding.h')
 94512: 
102822: def SortedTuples(l):
102822:     """
102822:     Sort a list of tuples based on the first item in the tuple
102822:     """
102822:     return sorted(l, key=operator.itemgetter(0))
102822: 
102822: def SortedDictValues(d):
102822:     """
102822:     Returns a list of values from the dict sorted by key.
102822:     """
102822:     # Create a list of tuples containing key and value, sorted on key.
102822:     d = SortedTuples(d.items())
102822:     # We're only interested in the values.
102822:     return (i[1] for i in d)
102822: 
121472: def UnionTypes(descriptors, dictionaries, callbacks, config):
102822:     """
121482:     Returns a tuple containing a set of header filenames to include in
121482:     UnionTypes.h, a set of header filenames to include in UnionTypes.cpp, a set
121482:     of tuples containing a type declaration and a boolean if the type is a
121482:     struct for member types of the unions and a CGList containing CGUnionStructs
121482:     for every union.
102822:     """
102822: 
102822:     # Now find all the things we'll need as arguments and return values because
102822:     # we need to wrap or unwrap them.
102822:     headers = set()
121482:     implheaders = set(["UnionTypes.h"])
102822:     declarations = set()
102822:     unionStructs = dict()
121472: 
121472:     def addInfoForType(t, descriptor=None, dictionary=None):
121472:         """
121472:         Add info for the given type.  descriptor and dictionary, if passed, are
121472:         used to figure out what to do with interface types.
121472:         """
121472:         assert not descriptor or not dictionary
102822:         t = t.unroll()
121472:         if not t.isUnion():
121472:             return
102822:         name = str(t)
102822:         if not name in unionStructs:
121472:             providers = getRelevantProviders(descriptor, dictionary,
121472:                                              config)
121472:             # FIXME: Unions are broken in workers.  See bug 809899.
121472:             unionStructs[name] = CGUnionStruct(t, providers[0])
102822:             for f in t.flatMemberTypes:
102822:                 f = f.unroll()
102822:                 if f.isInterface():
102822:                     if f.isSpiderMonkeyInterface():
102822:                         headers.add("jsfriendapi.h")
102822:                         headers.add("mozilla/dom/TypedArray.h")
102822:                     else:
121472:                         for p in providers:
121472:                             try:
121472:                                 typeDesc = p.getDescriptor(f.inner.identifier.name)
121472:                             except NoSuchDescriptorError:
121472:                                 continue
102822:                             declarations.add((typeDesc.nativeType, False))
121482:                             implheaders.add(typeDesc.headerFile)
102822:                 elif f.isDictionary():
102822:                     declarations.add((f.inner.identifier.name, True))
121482:                     implheaders.add(CGHeaders.getDeclarationFilename(f.inner))
102822: 
121472:     callForEachType(descriptors, dictionaries, callbacks, addInfoForType)
121472: 
121482:     return (headers, implheaders, declarations,
121482:             CGList(SortedDictValues(unionStructs), "\n"))
102822: 
102822: def UnionConversions(descriptors):
102822:     """
102822:     Returns a CGThing to declare all union argument conversion helper structs.
102822:     """
102822:     # Now find all the things we'll need as arguments because we
102822:     # need to unwrap them.
102822:     unionConversions = dict()
102822:     for d in descriptors:
102822:         if d.interface.isExternal():
102822:             continue
102822: 
102822:         def addUnionTypes(type):
102822:             if type.isUnion():
102822:                 type = type.unroll()
102822:                 name = str(type)
102822:                 if not name in unionConversions:
102822:                     unionConversions[name] = CGUnionConversionStruct(type, d)
102822: 
102822:         members = [m for m in d.interface.members]
106693:         if d.interface.ctor():
106693:             members.append(d.interface.ctor())
102822:         signatures = [s for m in members if m.isMethod() for s in m.signatures()]
102822:         for s in signatures:
102822:             assert len(s) == 2
102822:             (_, arguments) = s
102822:             for a in arguments:
102822:                 addUnionTypes(a.type)
102822: 
102822:         for m in members:
102822:             if m.isAttr() and not m.readonly:
102822:                 addUnionTypes(m.type)
102822: 
102822:     return CGWrapper(CGList(SortedDictValues(unionConversions), "\n"),
102822:                      post="\n\n")
102822: 
 94512: class Argument():
 94512:     """
 94512:     A class for outputting the type and name of an argument
 94512:     """
 94512:     def __init__(self, argType, name):
 94512:         self.argType = argType
 94512:         self.name = name
 94512:     def __str__(self):
 94512:         return self.argType + ' ' + self.name
 94512: 
 94512: class CGAbstractMethod(CGThing):
 94512:     """
 94512:     An abstract class for generating code for a method.  Subclasses
 94512:     should override definition_body to create the actual code.
 94512: 
 94512:     descriptor is the descriptor for the interface the method is associated with
 94512: 
 94512:     name is the name of the method as a string
 94512: 
 94512:     returnType is the IDLType of the return value
 94512: 
 94512:     args is a list of Argument objects
 94512: 
 94512:     inline should be True to generate an inline method, whose body is
 94512:     part of the declaration.
 94512: 
109136:     alwaysInline should be True to generate an inline method annotated with
109136:     MOZ_ALWAYS_INLINE.
109136: 
 94512:     static should be True to generate a static method, which only has
 94512:     a definition.
109136: 
109136:     If templateArgs is not None it should be a list of strings containing
109136:     template arguments, and the function will be templatized using those
109136:     arguments.
 94512:     """
109136:     def __init__(self, descriptor, name, returnType, args, inline=False, alwaysInline=False, static=False, templateArgs=None):
 94512:         CGThing.__init__(self)
 94512:         self.descriptor = descriptor
 94512:         self.name = name
 94512:         self.returnType = returnType
 94512:         self.args = args
 94512:         self.inline = inline
109136:         self.alwaysInline = alwaysInline
 94512:         self.static = static
109136:         self.templateArgs = templateArgs
 94512:     def _argstring(self):
 94512:         return ', '.join([str(a) for a in self.args])
109136:     def _template(self):
109136:         if self.templateArgs is None:
109136:             return ''
109136:         return 'template <%s>\n' % ', '.join(self.templateArgs)
 94512:     def _decorators(self):
 94512:         decorators = []
109136:         if self.alwaysInline:
109136:             decorators.append('MOZ_ALWAYS_INLINE')
109136:         elif self.inline:
 94512:             decorators.append('inline')
 94512:         if self.static:
 94512:             decorators.append('static')
 94512:         decorators.append(self.returnType)
109136:         maybeNewline = " " if self.inline else "\n"
109136:         return ' '.join(decorators) + maybeNewline
 94512:     def declare(self):
 94512:         if self.inline:
 94512:             return self._define()
109136:         return "%s%s%s(%s);\n" % (self._template(), self._decorators(), self.name, self._argstring())
 94512:     def _define(self):
 94512:         return self.definition_prologue() + "\n" + self.definition_body() + self.definition_epilogue()
 94512:     def define(self):
 94512:         return "" if self.inline else self._define()
 94512:     def definition_prologue(self):
109136:         return "%s%s%s(%s)\n{" % (self._template(), self._decorators(),
 94512:                                   self.name, self._argstring())
 94512:     def definition_epilogue(self):
 94512:         return "\n}\n"
 94512:     def definition_body(self):
 94512:         assert(False) # Override me!
 94512: 
 94512: class CGAbstractStaticMethod(CGAbstractMethod):
 94512:     """
 94512:     Abstract base class for codegen of implementation-only (no
 94512:     declaration) static methods.
 94512:     """
 94512:     def __init__(self, descriptor, name, returnType, args):
 94512:         CGAbstractMethod.__init__(self, descriptor, name, returnType, args,
 94512:                                   inline=False, static=True)
 94512:     def declare(self):
 94512:         # We only have implementation
 94512:         return ""
 94512: 
 94512: class CGAbstractClassHook(CGAbstractStaticMethod):
 94512:     """
 94512:     Meant for implementing JSClass hooks, like Finalize or Trace. Does very raw
 94512:     'this' unwrapping as it assumes that the unwrapped type is always known.
 94512:     """
 94512:     def __init__(self, descriptor, name, returnType, args):
 94512:         CGAbstractStaticMethod.__init__(self, descriptor, name, returnType,
 94512:                                         args)
 94512: 
 94512:     def definition_body_prologue(self):
 94512:         return """
109136:   %s* self = UnwrapDOMObject<%s>(obj, eRegularDOMObject);
 94512: """ % (self.descriptor.nativeType, self.descriptor.nativeType)
 94512: 
 94512:     def definition_body(self):
 94512:         return self.definition_body_prologue() + self.generate_code()
 94512: 
 94512:     def generate_code(self):
 94512:         # Override me
 94512:         assert(False)
 94512: 
 94512: class CGAddPropertyHook(CGAbstractClassHook):
 94512:     """
 94512:     A hook for addProperty, used to preserve our wrapper from GC.
 94512:     """
 94512:     def __init__(self, descriptor):
 98960:         args = [Argument('JSContext*', 'cx'), Argument('JSHandleObject', 'obj'),
106862:                 Argument('JSHandleId', 'id'), Argument('JSMutableHandleValue', 'vp')]
 94512:         CGAbstractClassHook.__init__(self, descriptor, ADDPROPERTY_HOOK_NAME,
 94512:                                      'JSBool', args)
 94512: 
 94512:     def generate_code(self):
118868:         assert not self.descriptor.workers and self.descriptor.wrapperCache
118868:         if self.descriptor.nativeOwnership == 'nsisupports':
118868:             preserveArgs = "reinterpret_cast<nsISupports*>(self), self"
118868:         else:
118868:             preserveArgs = "self, self, NS_CYCLE_COLLECTION_PARTICIPANT(%s)" % self.descriptor.nativeType
118868:         return """  nsContentUtils::PreserveWrapper(%s);
118868:   return true;""" % preserveArgs
 94512: 
115607: def DeferredFinalizeSmartPtr(descriptor):
115607:     if descriptor.nativeOwnership == 'owned':
115607:         smartPtr = 'nsAutoPtr<%s>'
115607:     else:
115607:         assert descriptor.nativeOwnership == 'refcounted'
115607:         smartPtr = 'nsRefPtr<%s>'
115607:     return smartPtr % descriptor.nativeType
115607: 
115607: class CGDeferredFinalizePointers(CGThing):
115607:     def __init__(self, descriptor):
115607:         CGThing.__init__(self)
115607:         self.descriptor = descriptor
115607: 
115607:     def declare(self):
115607:         return ""
115607: 
115607:     def define(self):
115607:         return """nsTArray<%s >* sDeferredFinalizePointers;
115607: """ % DeferredFinalizeSmartPtr(self.descriptor)
115607: 
115607: class CGGetDeferredFinalizePointers(CGAbstractStaticMethod):
115607:     def __init__(self, descriptor):
115607:         CGAbstractStaticMethod.__init__(self, descriptor, "GetDeferredFinalizePointers", "void*", [])
115607: 
115607:     def definition_body(self):
115607:         return """  nsTArray<%s >* pointers = sDeferredFinalizePointers;
115607:   sDeferredFinalizePointers = nullptr;
115607:   return pointers;""" % DeferredFinalizeSmartPtr(self.descriptor)
115607: 
115607: class CGDeferredFinalize(CGAbstractStaticMethod):
115607:     def __init__(self, descriptor):
115607:         CGAbstractStaticMethod.__init__(self, descriptor, "DeferredFinalize", "bool", [Argument('int32_t', 'slice'), Argument('void*', 'data')])
115607: 
115607:     def definition_body(self):
115607:         smartPtr = DeferredFinalizeSmartPtr(self.descriptor)
115607:         return """  nsTArray<%(smartPtr)s >* pointers = static_cast<nsTArray<%(smartPtr)s >*>(data);
115607:   uint32_t oldLen = pointers->Length();
115607:   if (slice == -1 || slice > oldLen) {
115607:     slice = oldLen;
115607:   }
115607:   uint32_t newLen = oldLen - slice;
115607:   pointers->RemoveElementsAt(newLen, slice);
115607:   if (newLen == 0) {
115607:     delete pointers;
115607:     return true;
115607:   }
115607:   return false;""" % { 'smartPtr': smartPtr }
115607: 
109136: def finalizeHook(descriptor, hookName, context):
109136:     if descriptor.customFinalize:
109136:         return """if (self) {
109136:   self->%s(%s);
109136: }""" % (hookName, context)
109136:     clearWrapper = "ClearWrapper(self, self);\n" if descriptor.wrapperCache else ""
109136:     if descriptor.workers:
109136:         release = "self->Release();"
115607:     elif descriptor.nativeOwnership == 'nsisupports':
109136:         release = """XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
109136: if (rt) {
109136:   rt->DeferredRelease(reinterpret_cast<nsISupports*>(self));
109136: } else {
109136:   NS_RELEASE(self);
109136: }"""
115607:     else:
115607:         smartPtr = DeferredFinalizeSmartPtr(descriptor)
115607:         release = """static bool registered = false;
115607: if (!registered) {
115607:   XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
115607:   if (!rt) {
115607:     %(smartPtr)s dying;
115607:     Take(dying, self);
115607:     return;
115607:   }
115607:   rt->RegisterDeferredFinalize(GetDeferredFinalizePointers, DeferredFinalize);
115607:   registered = true;
115607: }
115607: if (!sDeferredFinalizePointers) {
115607:   sDeferredFinalizePointers = new nsAutoTArray<%(smartPtr)s, 16>();
115607: }
115607: %(smartPtr)s* defer = sDeferredFinalizePointers->AppendElement();
115607: if (!defer) {
115607:   %(smartPtr)s dying;
115607:   Take(dying, self);
115607:   return;
115607: }
115607: Take(*defer, self);""" % { 'smartPtr': smartPtr }
109136:     return clearWrapper + release
109136: 
 94512: class CGClassFinalizeHook(CGAbstractClassHook):
 94512:     """
 94512:     A hook for finalize, used to release our native object.
 94512:     """
 94512:     def __init__(self, descriptor):
 94738:         args = [Argument('JSFreeOp*', 'fop'), Argument('JSObject*', 'obj')]
 94512:         CGAbstractClassHook.__init__(self, descriptor, FINALIZE_HOOK_NAME,
 94512:                                      'void', args)
 94512: 
 94512:     def generate_code(self):
109136:         return CGIndenter(CGGeneric(finalizeHook(self.descriptor, self.name, self.args[0].name))).define()
 94512: 
 94512: class CGClassTraceHook(CGAbstractClassHook):
 94512:     """
 94512:     A hook to trace through our native object; used for GC and CC
 94512:     """
 94512:     def __init__(self, descriptor):
 94512:         args = [Argument('JSTracer*', 'trc'), Argument('JSObject*', 'obj')]
 94512:         CGAbstractClassHook.__init__(self, descriptor, TRACE_HOOK_NAME, 'void',
 94512:                                      args)
 94512: 
 94512:     def generate_code(self):
 94512:         return """  if (self) {
 94512:     self->%s(%s);
 94512:   }""" % (self.name, self.args[0].name)
 94512: 
 94512: class CGClassConstructHook(CGAbstractStaticMethod):
 94512:     """
 94512:     JS-visible constructor for our objects
 94512:     """
 94512:     def __init__(self, descriptor):
 94512:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'), Argument('JS::Value*', 'vp')]
 94512:         CGAbstractStaticMethod.__init__(self, descriptor, CONSTRUCT_HOOK_NAME,
 94512:                                         'JSBool', args)
 94512:         self._ctor = self.descriptor.interface.ctor()
 94512: 
 94512:     def define(self):
 94512:         if not self._ctor:
 94512:             return ""
 94512:         return CGAbstractStaticMethod.define(self)
 94512: 
 94512:     def definition_body(self):
 94512:         return self.generate_code()
 94512: 
 94512:     def generate_code(self):
 94512:         preamble = """
 94512:   JSObject* obj = JS_GetGlobalForObject(cx, JSVAL_TO_OBJECT(JS_CALLEE(cx, vp)));
 94512: """
 94512:         if self.descriptor.workers:
 99125:             preArgs = ["cx", "obj"]
 94512:         else:
 94512:             preamble += """
 94512:   nsISupports* global;
 94512:   xpc_qsSelfRef globalRef;
 94512:   {
 94512:     nsresult rv;
 94512:     JS::Value val = OBJECT_TO_JSVAL(obj);
 94512:     rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr, &val);
 94512:     if (NS_FAILED(rv)) {
119071:       return ThrowErrorMessage(cx, MSG_GLOBAL_NOT_NATIVE);
 94512:     }
 94512:   }
 94512: """
 99125:             preArgs = ["global"]
 94512: 
 99792:         name = self._ctor.identifier.name
 99792:         nativeName = MakeNativeName(self.descriptor.binaryNames.get(name, name))
 94512:         callGenerator = CGMethodCall(preArgs, nativeName, True,
 99124:                                      self.descriptor, self._ctor)
 94512:         return preamble + callGenerator.define();
 94512: 
120342: class CGClassConstructHookHolder(CGGeneric):
120342:     def __init__(self, descriptor):
120342:         if descriptor.interface.ctor():
120342:             constructHook = CONSTRUCT_HOOK_NAME
120342:         else:
120342:             constructHook = "ThrowingConstructor"
120342:         CGGeneric.__init__(self,
120342:                            "JSNativeHolder " + CONSTRUCT_HOOK_NAME + "_holder = {\n" +
120342:                            "  " + constructHook + ",\n" +
120342:                            "  " + NativePropertyHooks(descriptor) + "\n" +
120342:                            "};\n")
120342: 
 94512: class CGClassHasInstanceHook(CGAbstractStaticMethod):
 94512:     def __init__(self, descriptor):
 98960:         args = [Argument('JSContext*', 'cx'), Argument('JSHandleObject', 'obj'),
111462:                 Argument('JSMutableHandleValue', 'vp'), Argument('JSBool*', 'bp')]
 94512:         CGAbstractStaticMethod.__init__(self, descriptor, HASINSTANCE_HOOK_NAME,
 94512:                                         'JSBool', args)
 94512: 
 94512:     def define(self):
 94512:         if not self.descriptor.hasInstanceInterface:
 94512:             return ""
 94512:         return CGAbstractStaticMethod.define(self)
 94512: 
 94512:     def definition_body(self):
 94512:         return self.generate_code()
 94512: 
 94512:     def generate_code(self):
115607:         assert self.descriptor.nativeOwnership == 'nsisupports'
111462:         return """  if (!vp.isObject()) {
 94512:     *bp = false;
 94512:     return true;
 94512:   }
 94512: 
 94512:   jsval protov;
 94512:   if (!JS_GetProperty(cx, obj, "prototype", &protov))
 94512:     return false;
 94512:   if (!protov.isObject()) {
 94512:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PROTOTYPE,
 94512:                          "%s");
 94512:     return false;
 94512:   }
 98960:   JSObject *objProto = &protov.toObject();
 94512: 
111462:   JSObject* instance = &vp.toObject();
115023:   JSObject* proto;
115023:   if (!JS_GetPrototype(cx, instance, &proto))
115023:     return false;
 94512:   while (proto) {
 98960:     if (proto == objProto) {
 94512:       *bp = true;
 94512:       return true;
 94512:     }
115023:     if (!JS_GetPrototype(cx, proto, &proto))
115023:       return false;
 94512:   }
 94512: 
 94512:   nsISupports* native =
 94512:     nsContentUtils::XPConnect()->GetNativeOfWrapper(cx, instance);
 94512:   nsCOMPtr<%s> qiResult = do_QueryInterface(native);
 94512:   *bp = !!qiResult;
 94512:   return true;
 94512: """ % (self.descriptor.name, self.descriptor.hasInstanceInterface)
 94512: 
 94512: def isChromeOnly(m):
 95064:     return m.getExtendedAttribute("ChromeOnly")
 94512: 
 94512: class PropertyDefiner:
 94512:     """
 94512:     A common superclass for defining things on prototype objects.
 94512: 
 94512:     Subclasses should implement generateArray to generate the actual arrays of
 94512:     things we're defining.  They should also set self.chrome to the list of
118871:     things only exposed to chrome and self.regular to the list of things exposed
118871:     to both chrome and web pages.
 94512:     """
 94512:     def __init__(self, descriptor, name):
 94512:         self.descriptor = descriptor
 94512:         self.name = name
 99234:         # self.prefCacheData will store an array of (prefname, bool*)
 99234:         # pairs for our bool var caches.  generateArray will fill it
 99234:         # in as needed.
 99234:         self.prefCacheData = []
 94512:     def hasChromeOnly(self):
118871:         return len(self.chrome) > 0
 94512:     def hasNonChromeOnly(self):
 94512:         return len(self.regular) > 0
 94512:     def variableName(self, chrome):
118871:         if chrome:
118871:             if self.hasChromeOnly():
 94512:                 return "sChrome" + self.name
118871:         else:
 94512:             if self.hasNonChromeOnly():
 94512:                 return "s" + self.name
118871:         return "nullptr"
118871:     def usedForXrays(self):
121716:         # No Xrays in workers.
121716:         return not self.descriptor.workers
 99234: 
 94512:     def __str__(self):
 99234:         # We only need to generate id arrays for things that will end
 99234:         # up used via ResolveProperty or EnumerateProperties.
 99234:         str = self.generateArray(self.regular, self.variableName(False),
118871:                                  self.usedForXrays())
 94512:         if self.hasChromeOnly():
 99234:             str += self.generateArray(self.chrome, self.variableName(True),
118871:                                       self.usedForXrays())
 94512:         return str
 94512: 
 99234:     @staticmethod
 99234:     def getControllingPref(interfaceMember):
 99234:         prefName = interfaceMember.getExtendedAttribute("Pref")
 99234:         if prefName is None:
 99234:             return None
 99234:         # It's a list of strings
 99234:         assert(len(prefName) is 1)
 99234:         assert(prefName[0] is not None)
 99234:         return prefName[0]
 99234: 
 99234:     def generatePrefableArray(self, array, name, specTemplate, specTerminator,
 99234:                               specType, getPref, getDataTuple, doIdArrays):
 99234:         """
 99234:         This method generates our various arrays.
 99234: 
 99234:         array is an array of interface members as passed to generateArray
 99234: 
 99234:         name is the name as passed to generateArray
 99234: 
 99234:         specTemplate is a template for each entry of the spec array
 99234: 
 99234:         specTerminator is a terminator for the spec array (inserted every time
 99234:           our controlling pref changes and at the end of the array)
 99234: 
 99234:         specType is the actual typename of our spec
 99234: 
 99234:         getPref is a callback function that takes an array entry and returns
 99234:           the corresponding pref value.
 99234: 
 99234:         getDataTuple is a callback function that takes an array entry and
 99234:           returns a tuple suitable for substitution into specTemplate.
 99234:         """
 99234: 
 99234:         # We want to generate a single list of specs, but with specTerminator
 99234:         # inserted at every point where the pref name controlling the member
 99234:         # changes.  That will make sure the order of the properties as exposed
 99234:         # on the interface and interface prototype objects does not change when
 99234:         # pref control is added to members while still allowing us to define all
 99234:         # the members in the smallest number of JSAPI calls.
 99234:         assert(len(array) is not 0)
 99234:         lastPref = getPref(array[0]) # So we won't put a specTerminator
 99234:                                      # at the very front of the list.
 99234:         specs = []
 99234:         prefableSpecs = []
 99234:         if doIdArrays:
 99234:             prefableIds = []
 99234: 
 99234:         prefableTemplate = '  { true, &%s[%d] }'
 99234:         prefCacheTemplate = '&%s[%d].enabled'
 99234:         def switchToPref(props, pref):
 99234:             # Remember the info about where our pref-controlled
 99234:             # booleans live.
 99234:             if pref is not None:
 99234:                 props.prefCacheData.append(
 99234:                     (pref, prefCacheTemplate % (name, len(prefableSpecs)))
 99234:                     )
 99234:             # Set up pointers to the new sets of specs and ids
 99234:             # inside prefableSpecs and prefableIds
 99234:             prefableSpecs.append(prefableTemplate %
 99234:                                  (name + "_specs", len(specs)))
 99234: 
 99234:         switchToPref(self, lastPref)
 99234: 
 99234:         for member in array:
 99234:             curPref = getPref(member)
 99234:             if lastPref != curPref:
 99234:                 # Terminate previous list
 99234:                 specs.append(specTerminator)
 99234:                 # And switch to our new pref
 99234:                 switchToPref(self, curPref)
 99234:                 lastPref = curPref
 99234:             # And the actual spec
 99234:             specs.append(specTemplate % getDataTuple(member))
 99234:         specs.append(specTerminator)
 99234:         prefableSpecs.append("  { false, NULL }");
 99234: 
 99234:         arrays = (("static %s %s_specs[] = {\n" +
 99234:                    ',\n'.join(specs) + "\n" +
 99234:                    "};\n\n" +
 99234:                    "static Prefable<%s> %s[] = {\n" +
 99234:                    ',\n'.join(prefableSpecs) + "\n" +
 99234:                    "};\n\n") % (specType, name, specType, name))
 99234:         if doIdArrays:
 99234:             arrays += ("static jsid %s_ids[%i] = { JSID_VOID };\n\n" %
 99234:                        (name, len(specs)))
 99234:         return arrays
 99234: 
 99234: 
 97423: # The length of a method is the maximum of the lengths of the
 97423: # argument lists of all its overloads.
 97423: def methodLength(method):
 97423:     signatures = method.signatures()
 97423:     return max([len(arguments) for (retType, arguments) in signatures])
 97423: 
 94512: class MethodDefiner(PropertyDefiner):
 94512:     """
 94512:     A class for defining methods on a prototype object.
 94512:     """
 94512:     def __init__(self, descriptor, name, static):
 94512:         PropertyDefiner.__init__(self, descriptor, name)
 94512: 
109136:         # FIXME https://bugzilla.mozilla.org/show_bug.cgi?id=772822
109136:         #       We should be able to check for special operations without an
109136:         #       identifier. For now we check if the name starts with __
 94512:         methods = [m for m in descriptor.interface.members if
109136:                    m.isMethod() and m.isStatic() == static and
109136:                    not m.isIdentifierLess()]
120397:         self.chrome = []
120397:         self.regular = []
120397:         for m in methods:
120397:             method = { "name": m.identifier.name,
120397:                        "methodInfo": not m.isStatic(),
 94512:                        "length": methodLength(m),
 99234:                        "flags": "JSPROP_ENUMERATE",
 99234:                        "pref": PropertyDefiner.getControllingPref(m) }
120397:             if isChromeOnly(m):
120397:                 self.chrome.append(method)
120397:             else:
120397:                 self.regular.append(method)
109136: 
109136:         # FIXME Check for an existing iterator on the interface first.
109136:         if any(m.isGetter() and m.isIndexed() for m in methods):
109136:             self.regular.append({"name": 'iterator',
109136:                                  "methodInfo": False,
109136:                                  "nativeName": "JS_ArrayIterator",
109136:                                  "length": 0,
109136:                                  "flags": "JSPROP_ENUMERATE",
109136:                                  "pref": None })
109136: 
121323:         if (not descriptor.interface.parent and not static and
121323:             descriptor.nativeOwnership == 'nsisupports' and
121323:             descriptor.interface.hasInterfacePrototypeObject()):
 94512:             self.chrome.append({"name": 'QueryInterface',
109136:                                 "methodInfo": False,
 94512:                                 "length": 1,
 99234:                                 "flags": "0",
 99234:                                 "pref": None })
 94512: 
119692:         if not static:
119692:             stringifier = descriptor.operations['Stringifier']
119692:             if stringifier:
119692:                 toStringDesc = { "name": "toString",
119692:                                  "nativeName": stringifier.identifier.name,
119692:                                  "length": 0,
119692:                                  "flags": "JSPROP_ENUMERATE",
119692:                                  "pref": PropertyDefiner.getControllingPref(stringifier) }
119692:                 if isChromeOnly(stringifier):
119692:                     self.chrome.append(toStringDesc)
119692:                 else:
119692:                     self.regular.append(toStringDesc)
119692: 
 94512:         if static:
 94512:             if not descriptor.interface.hasInterfaceObject():
 94512:                 # static methods go on the interface object
 94512:                 assert not self.hasChromeOnly() and not self.hasNonChromeOnly()
 94512:         else:
 94512:             if not descriptor.interface.hasInterfacePrototypeObject():
 94512:                 # non-static methods go on the interface prototype object
 94512:                 assert not self.hasChromeOnly() and not self.hasNonChromeOnly()
 94512: 
 99234:     def generateArray(self, array, name, doIdArrays):
 94512:         if len(array) == 0:
 94512:             return ""
 94512: 
 99234:         def pref(m):
 99234:             return m["pref"]
 99234: 
 99234:         def specData(m):
119692:             accessor = m.get("nativeName", m["name"])
109136:             if m.get("methodInfo", True):
119692:                 jitinfo = ("&%s_methodinfo" % accessor)
109136:                 accessor = "genericMethod"
109136:             else:
109136:                 jitinfo = "nullptr"
107793:             return (m["name"], accessor, jitinfo, m["length"], m["flags"])
 99234: 
 99234:         return self.generatePrefableArray(
 99234:             array, name,
107789:             '  JS_FNINFO("%s", %s, %s, %s, %s)',
 99234:             '  JS_FS_END',
 99234:             'JSFunctionSpec',
 99234:             pref, specData, doIdArrays)
 94512: 
 94512: class AttrDefiner(PropertyDefiner):
120397:     def __init__(self, descriptor, name, static, unforgeable=False):
120397:         assert not (static and unforgeable)
 94512:         PropertyDefiner.__init__(self, descriptor, name)
 94512:         self.name = name
120397:         attributes = [m for m in descriptor.interface.members if
120397:                       m.isAttr() and m.isStatic() == static and
120397:                       m.isUnforgeable() == unforgeable]
118871:         self.chrome = [m for m in attributes if isChromeOnly(m)]
118871:         self.regular = [m for m in attributes if not isChromeOnly(m)]
120397:         self.static = static
119931:         self.unforgeable = unforgeable
119931: 
120397:         if static:
120397:             if not descriptor.interface.hasInterfaceObject():
120397:                 # static attributes go on the interface object
120397:                 assert not self.hasChromeOnly() and not self.hasNonChromeOnly()
120397:         else:
120397:             if not descriptor.interface.hasInterfacePrototypeObject():
120397:                 # non-static attributes go on the interface prototype object
120397:                 assert not self.hasChromeOnly() and not self.hasNonChromeOnly()
120397: 
119931:         if unforgeable and len(attributes) != 0 and descriptor.proxy:
119931:             raise TypeError("Unforgeable properties are not supported on "
119931:                             "proxy bindings without [NamedPropertiesObject].  "
119931:                             "And not even supported on the ones with "
119931:                             "[NamedPropertiesObject] yet, but we should fix "
119931:                             "that, since they're safe there.")
 94512: 
 99234:     def generateArray(self, array, name, doIdArrays):
 94512:         if len(array) == 0:
 94512:             return ""
 94512: 
 94512:         def flags(attr):
119931:             unforgeable = " | JSPROP_PERMANENT" if self.unforgeable else ""
119931:             return ("JSPROP_SHARED | JSPROP_ENUMERATE | JSPROP_NATIVE_ACCESSORS" +
119931:                     unforgeable)
 94512: 
 94512:         def getter(attr):
120397:             if self.static:
120397:                 accessor = 'get_' + attr.identifier.name
120397:                 jitinfo = "nullptr"
120397:             else:
120397:                 accessor = ("genericLenientGetter" if attr.hasLenientThis()
113773:                             else "genericGetter")
120397:                 jitinfo = "&%s_getterinfo" % attr.identifier.name
120397:             return "{ (JSPropertyOp)%s, %s }" % (accessor, jitinfo)
 94512: 
 94512:         def setter(attr):
120646:             if attr.readonly and attr.getExtendedAttribute("PutForwards") is None:
120646:                 return "JSOP_NULLWRAPPER"
120397:             if self.static:
120397:                 accessor = 'set_' + attr.identifier.name
120397:                 jitinfo = "nullptr"
120397:             else:
120397:                 accessor = ("genericLenientSetter" if attr.hasLenientThis()
113773:                             else "genericSetter")
120397:                 jitinfo = "&%s_setterinfo" % attr.identifier.name
120397:             return "{ (JSStrictPropertyOp)%s, %s }" % (accessor, jitinfo)
 94512: 
 99234:         def specData(attr):
 99234:             return (attr.identifier.name, flags(attr), getter(attr),
 99234:                     setter(attr))
 99234: 
 99234:         return self.generatePrefableArray(
 99234:             array, name,
107784:             '  { "%s", 0, %s, %s, %s}',
107784:             '  { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }',
 99234:             'JSPropertySpec',
 99234:             PropertyDefiner.getControllingPref, specData, doIdArrays)
 94512: 
 94512: class ConstDefiner(PropertyDefiner):
 94512:     """
 94512:     A class for definining constants on the interface object
 94512:     """
 94512:     def __init__(self, descriptor, name):
 94512:         PropertyDefiner.__init__(self, descriptor, name)
 94512:         self.name = name
118871:         constants = [m for m in descriptor.interface.members if m.isConst()]
118871:         self.chrome = [m for m in constants if isChromeOnly(m)]
118871:         self.regular = [m for m in constants if not isChromeOnly(m)]
 94512: 
 99234:     def generateArray(self, array, name, doIdArrays):
 94512:         if len(array) == 0:
 94512:             return ""
 94512: 
 99234:         def specData(const):
 99234:             return (const.identifier.name,
 94512:                     convertConstIDLValueToJSVal(const.value))
 99234: 
 99234:         return self.generatePrefableArray(
 99234:             array, name,
 99234:             '  { "%s", %s }',
 99234:             '  { 0, JSVAL_VOID }',
 99234:             'ConstantSpec',
 99234:             PropertyDefiner.getControllingPref, specData, doIdArrays)
 94512: 
 94512: class PropertyArrays():
 94512:     def __init__(self, descriptor):
120397:         self.staticMethods = MethodDefiner(descriptor, "StaticMethods",
120397:                                            static=True)
120397:         self.staticAttrs = AttrDefiner(descriptor, "StaticAttributes",
120397:                                        static=True)
120397:         self.methods = MethodDefiner(descriptor, "Methods", static=False)
120397:         self.attrs = AttrDefiner(descriptor, "Attributes", static=False)
119931:         self.unforgeableAttrs = AttrDefiner(descriptor, "UnforgeableAttributes",
120397:                                             static=False, unforgeable=True)
 94512:         self.consts = ConstDefiner(descriptor, "Constants")
 94512: 
 94512:     @staticmethod
 94512:     def arrayNames():
120397:         return [ "staticMethods", "staticAttrs", "methods", "attrs",
120397:                  "unforgeableAttrs", "consts" ]
 94512: 
 99234:     @staticmethod
 99234:     def xrayRelevantArrayNames():
119931:         return [ "methods", "attrs", "unforgeableAttrs", "consts" ]
 99234: 
 94512:     def hasChromeOnly(self):
118871:         return any(getattr(self, a).hasChromeOnly() for a in self.arrayNames())
118871:     def hasNonChromeOnly(self):
118871:         return any(getattr(self, a).hasNonChromeOnly() for a in self.arrayNames())
 94512:     def __str__(self):
 94512:         define = ""
 94512:         for array in self.arrayNames():
 94512:             define += str(getattr(self, array))
 94512:         return define
 94512: 
118871: class CGNativeProperties(CGList):
118871:     def __init__(self, descriptor, properties):
118871:         def generateNativeProperties(name, chrome):
118871:             def check(p):
118871:                 return p.hasChromeOnly() if chrome else p.hasNonChromeOnly()
118871: 
118871:             nativeProps = []
118871:             for array in properties.arrayNames():
118871:                 propertyArray = getattr(properties, array)
118871:                 if check(propertyArray):
118871:                     if propertyArray.usedForXrays():
118871:                         ids = "%(name)s_ids"
118871:                     else:
118871:                         ids = "nullptr"
118871:                     props = "%(name)s, " + ids + ", %(name)s_specs"
118871:                     props = (props %
118871:                              { 'name': propertyArray.variableName(chrome) })
118871:                 else:
118871:                     props = "nullptr, nullptr, nullptr"
118871:                 nativeProps.append(CGGeneric(props))
118871:             return CGWrapper(CGIndenter(CGList(nativeProps, ",\n")),
118871:                              pre="static const NativeProperties %s = {\n" % name,
118871:                              post="\n};")
118871: 
121716:         nativeProperties = []
121716:         if properties.hasNonChromeOnly():
121716:             nativeProperties.append(
121716:                 generateNativeProperties("sNativeProperties", False))
121716:         if properties.hasChromeOnly():
121716:             nativeProperties.append(
121716:                 generateNativeProperties("sChromeOnlyNativeProperties", True))
121716:         CGList.__init__(self, nativeProperties, "\n\n")
118871: 
118871:     def declare(self):
118871:         return ""
118871: 
 94512: class CGCreateInterfaceObjectsMethod(CGAbstractMethod):
 94512:     """
 94512:     Generate the CreateInterfaceObjects method for an interface descriptor.
 94512: 
 94512:     properties should be a PropertyArrays instance.
 94512:     """
 94512:     def __init__(self, descriptor, properties):
 97127:         args = [Argument('JSContext*', 'aCx'), Argument('JSObject*', 'aGlobal'),
120342:                 Argument('JSObject**', 'protoAndIfaceArray')]
120342:         CGAbstractMethod.__init__(self, descriptor, 'CreateInterfaceObjects', 'void', args)
 94512:         self.properties = properties
 94512:     def definition_body(self):
 94512:         protoChain = self.descriptor.prototypeChain
 94512:         if len(protoChain) == 1:
 94512:             getParentProto = "JS_GetObjectPrototype(aCx, aGlobal)"
 94512:         else:
 94512:             parentProtoName = self.descriptor.prototypeChain[-2]
120342:             getParentProto = ("%s::GetProtoObject(aCx, aGlobal)" %
 97422:                               toBindingNamespace(parentProtoName))
 94512: 
 94512:         needInterfaceObject = self.descriptor.interface.hasInterfaceObject()
 94512:         needInterfacePrototypeObject = self.descriptor.interface.hasInterfacePrototypeObject()
 94512: 
 94512:         # if we don't need to create anything, why are we generating this?
 94512:         assert needInterfaceObject or needInterfacePrototypeObject
 94512: 
 94512:         idsToInit = []
 99238:         # There is no need to init any IDs in workers, because worker bindings
 99238:         # don't have Xrays.
 99238:         if not self.descriptor.workers:
 99234:             for var in self.properties.xrayRelevantArrayNames():
 94512:                 props = getattr(self.properties, var)
 99238:                 # We only have non-chrome ids to init if we have no chrome ids.
 99238:                 if props.hasChromeOnly():
 99238:                     idsToInit.append(props.variableName(True))
118871:                 if props.hasNonChromeOnly():
 94512:                     idsToInit.append(props.variableName(False))
 94512:         if len(idsToInit) > 0:
 96737:             initIds = CGList(
 96737:                 [CGGeneric("!InitIds(aCx, %s, %s_ids)" % (varname, varname)) for
 96737:                  varname in idsToInit], ' ||\n')
 94512:             if len(idsToInit) > 1:
 96737:                 initIds = CGWrapper(initIds, pre="(", post=")", reindent=True)
 96737:             initIds = CGList(
 96737:                 [CGGeneric("%s_ids[0] == JSID_VOID &&" % idsToInit[0]), initIds],
 96737:                 "\n")
 96737:             initIds = CGWrapper(initIds, pre="if (", post=") {", reindent=True)
 96737:             initIds = CGList(
 96737:                 [initIds,
 96737:                  CGGeneric(("  %s_ids[0] = JSID_VOID;\n"
120342:                             "  return;") % idsToInit[0]),
 96737:                  CGGeneric("}")],
 96737:                 "\n")
 96737:         else:
 96737:             initIds = None
 96737: 
 99234:         prefCacheData = []
 99234:         for var in self.properties.arrayNames():
 99234:             props = getattr(self.properties, var)
 99234:             prefCacheData.extend(props.prefCacheData)
 99234:         if len(prefCacheData) is not 0:
 99234:             prefCacheData = [
 99234:                 CGGeneric('Preferences::AddBoolVarCache(%s, "%s");' % (ptr, pref)) for
 99234:                 (pref, ptr) in prefCacheData]
 99234:             prefCache = CGWrapper(CGIndenter(CGList(prefCacheData, "\n")),
 99234:                                   pre=("static bool sPrefCachesInited = false;\n"
 99234:                                        "if (!sPrefCachesInited) {\n"
 99234:                                        "  sPrefCachesInited = true;\n"),
 99234:                                   post="\n}")
 99234:         else:
 99234:             prefCache = None
 99234:             
109136:         getParentProto = ("JSObject* parentProto = %s;\n" +
109136:                           "if (!parentProto) {\n" +
120342:                           "  return;\n" +
109136:                           "}\n") % getParentProto
 94512: 
 97423:         needConstructor = (needInterfaceObject and
 97423:                            not self.descriptor.hasInstanceInterface)
120342:         constructHook = "&" + CONSTRUCT_HOOK_NAME + "_holder"
 97423:         if self.descriptor.interface.ctor():
 97423:             constructArgs = methodLength(self.descriptor.interface.ctor())
 97423:         else:
 97423:             constructArgs = 0
 97423: 
120342:         if needInterfacePrototypeObject:
120342:             protoClass = "&PrototypeClass.mBase"
120342:             protoCache = "&protoAndIfaceArray[prototypes::id::%s]" % self.descriptor.name
120342:         else:
120342:             protoClass = "nullptr"
120342:             protoCache = "nullptr"
120342:         if needInterfaceObject:
120342:             if self.descriptor.hasInstanceInterface:
120342:                 interfaceClass = "&InterfaceObjectClass.mBase"
120342:             else:
120342:                 interfaceClass = "nullptr"
120342:             interfaceCache = "&protoAndIfaceArray[constructors::id::%s]" % self.descriptor.name
120342:         else:
120342:             interfaceClass = "nullptr"
120342:             interfaceCache = "nullptr"
120342: 
109136:         if self.descriptor.concrete:
109136:             if self.descriptor.proxy:
109136:                 domClass = "&Class"
109136:             else:
109136:                 domClass = "&Class.mClass"
109136:         else:
109136:             domClass = "nullptr"
109136: 
118871:         if self.properties.hasNonChromeOnly():
118871:             properties = "&sNativeProperties"
118871:         else:
118871:             properties = "nullptr"
118871:         if self.properties.hasChromeOnly():
119931:             accessCheck = GetAccessCheck(self.descriptor, "aGlobal")
118871:             chromeProperties = accessCheck + " ? &sChromeOnlyNativeProperties : nullptr"
118871:         else:
118871:             chromeProperties = "nullptr"
120342:         call = ("dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,\n"
120342:                 "                            %s, %s,\n"
120342:                 "                            %s, %s, %d, %s,\n"
120342:                 "                            %s,\n"
120342:                 "                            %s,\n"
120342:                 "                            %s,\n"
120342:                 "                            %s);" % (
120342:             protoClass, protoCache,
120342:             interfaceClass, constructHook if needConstructor else "nullptr",
120342:             constructArgs, interfaceCache,
109136:             domClass,
118871:             properties,
118871:             chromeProperties,
120342:             '"' + self.descriptor.interface.identifier.name + '"' if needInterfaceObject else "NULL"))
 96737:         functionBody = CGList(
118871:             [CGGeneric(getParentProto), initIds, prefCache, CGGeneric(call)],
 96737:             "\n\n")
 96737:         return CGIndenter(functionBody).define()
 94512: 
 94512: class CGGetPerInterfaceObject(CGAbstractMethod):
 94512:     """
 94512:     A method for getting a per-interface object (a prototype object or interface
 94512:     constructor object).
 94512:     """
 94512:     def __init__(self, descriptor, name, idPrefix=""):
120342:         args = [Argument('JSContext*', 'aCx'), Argument('JSObject*', 'aGlobal')]
 94512:         CGAbstractMethod.__init__(self, descriptor, name,
 94512:                                   'JSObject*', args, inline=True)
 94512:         self.id = idPrefix + "id::" + self.descriptor.name
 94512:     def definition_body(self):
 94512:         return """
 97127: 
 94512:   /* Make sure our global is sane.  Hopefully we can remove this sometime */
 94512:   if (!(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL)) {
 94512:     return NULL;
 94512:   }
 94512:   /* Check to see whether the interface objects are already installed */
120314:   JSObject** protoAndIfaceArray = GetProtoAndIfaceArray(aGlobal);
120314:   JSObject* cachedObject = protoAndIfaceArray[%s];
 94512:   if (!cachedObject) {
120342:     CreateInterfaceObjects(aCx, aGlobal, protoAndIfaceArray);
120342:     cachedObject = protoAndIfaceArray[%s];
 94512:   }
 94512: 
 94512:   /* cachedObject might _still_ be null, but that's OK */
 94512:   return cachedObject;""" % (self.id, self.id)
 94512: 
 94512: class CGGetProtoObjectMethod(CGGetPerInterfaceObject):
 94512:     """
 94512:     A method for getting the interface prototype object.
 94512:     """
 94512:     def __init__(self, descriptor):
 97422:         CGGetPerInterfaceObject.__init__(self, descriptor, "GetProtoObject",
 97422:                                          "prototypes::")
 94512:     def definition_body(self):
 94512:         return """
 94512:   /* Get the interface prototype object for this class.  This will create the
 94512:      object as needed. */""" + CGGetPerInterfaceObject.definition_body(self)
 94512: 
 94512: class CGGetConstructorObjectMethod(CGGetPerInterfaceObject):
 94512:     """
 94512:     A method for getting the interface constructor object.
 94512:     """
 94512:     def __init__(self, descriptor):
 97422:         CGGetPerInterfaceObject.__init__(self, descriptor, "GetConstructorObject",
 97422:                                          "constructors::")
 94512:     def definition_body(self):
 94512:         return """
 94512:   /* Get the interface object for this class.  This will create the object as
 94512:      needed. */""" + CGGetPerInterfaceObject.definition_body(self)
 94512: 
 97127: def CheckPref(descriptor, globalName, varName, retval, wrapperCache = None):
 94512:     """
 94512:     Check whether bindings should be enabled for this descriptor.  If not, set
 94512:     varName to false and return retval.
 94512:     """
 94512:     if not descriptor.prefable:
 94512:         return ""
107460: 
 94512:     if wrapperCache:
 94512:        wrapperCache = "      %s->ClearIsDOMBinding();\n" % (wrapperCache)
 94512:     else:
 94512:         wrapperCache = ""
107460: 
107460:     failureCode = ("      %s = false;\n" +
107460:                    "      return %s;") % (varName, retval)
 94512:     return """
 97127:   {
120051:     XPCWrappedNativeScope* scope = xpc::GetObjectScope(%s);
 97127:     if (!scope) {
107460: %s
 97127:     }
 97127: 
 97127:     if (!scope->ExperimentalBindingsEnabled()) {
107460: %s%s
 94512:     }
 97127:   }
107460: """ % (globalName, failureCode, wrapperCache, failureCode)
 94512: 
 94512: class CGDefineDOMInterfaceMethod(CGAbstractMethod):
 94512:     """
 94512:     A method for resolve hooks to try to lazily define the interface object for
 94512:     a given interface.
 94512:     """
 94512:     def __init__(self, descriptor):
120342:         args = [Argument('JSContext*', 'aCx'), Argument('JSObject*', 'aGlobal'),
 94512:                 Argument('bool*', 'aEnabled')]
120342:         CGAbstractMethod.__init__(self, descriptor, 'DefineDOMInterface', 'JSObject*', args)
 94512: 
 94512:     def declare(self):
 94512:         if self.descriptor.workers:
 94512:             return ''
 94512:         return CGAbstractMethod.declare(self)
 94512: 
 94512:     def define(self):
 94512:         if self.descriptor.workers:
 94512:             return ''
 94512:         return CGAbstractMethod.define(self)
 94512: 
 94512:     def definition_body(self):
120342:         return (CheckPref(self.descriptor, "aGlobal", "*aEnabled", "nullptr") + 
 97127:                 """
 94512:   *aEnabled = true;
120342:   return GetConstructorObject(aCx, aGlobal);""")
 94512: 
111182: class CGPrefEnabled(CGAbstractMethod):
111182:     """
111182:     A method for testing whether the preference controlling this
111182:     interface is enabled.  When it's not, the interface should not be
111182:     visible on the global.
111182:     """
111182:     def __init__(self, descriptor):
111182:         CGAbstractMethod.__init__(self, descriptor, 'PrefEnabled', 'bool', [])
111182: 
111182:     def declare(self):
111182:         return CGAbstractMethod.declare(self)
111182: 
111182:     def define(self):
111182:         return CGAbstractMethod.define(self)
111182: 
111182:     def definition_body(self):
111182:         return "  return %s::PrefEnabled();" % self.descriptor.nativeType
111182: 
109136: class CGIsMethod(CGAbstractMethod):
 94512:     def __init__(self, descriptor):
109136:         args = [Argument('JSObject*', 'obj')]
109136:         CGAbstractMethod.__init__(self, descriptor, 'Is', 'bool', args)
109136: 
109136:     def definition_body(self):
109136:         # Non-proxy implementation would check
109136:         #   js::GetObjectJSClass(obj) == &Class.mBase
109136:         return """  return IsProxy(obj);"""
109136: 
114094: def CreateBindingJSObject(descriptor, parent):
114094:     if descriptor.proxy:
114094:         create = """  JSObject *obj = NewProxyObject(aCx, DOMProxyHandler::getInstance(),
114094:                                  JS::PrivateValue(aObject), proto, %s);
114094:   if (!obj) {
114094:     return NULL;
114094:   }
114094: 
114094: """
114094:     else:
114094:         create = """  JSObject* obj = JS_NewObject(aCx, &Class.mBase, proto, %s);
114094:   if (!obj) {
114094:     return NULL;
114094:   }
114094: 
114094:   js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(aObject));
114094: """
115607:     if descriptor.nativeOwnership in ['refcounted', 'nsisupports']:
115607:         create += """  NS_ADDREF(aObject);
115607: """
115607:     else:
115607:         assert descriptor.nativeOwnership == 'owned'
115607:         create += """  // Make sure the native objects inherit from NonRefcountedDOMObject so that we
115607:   // log their ctor and dtor.
115607:   MustInheritFromNonRefcountedDOMObject(aObject);
115607: """
114094:     return create % parent
114094: 
119931: def GetAccessCheck(descriptor, globalName):
119931:     """
119931:     globalName is the name of the global JSObject*
119931: 
119931:     returns a string
119931:     """
119931:     if descriptor.workers:
119931:         accessCheck = "mozilla::dom::workers::GetWorkerPrivateFromContext(aCx)->IsChromeWorker()"
119931:     else:
119931:         accessCheck = "xpc::AccessCheck::isChrome(%s)" % globalName
119931:     return accessCheck
119931: 
119931: def InitUnforgeableProperties(descriptor, properties):
119931:     """
119931:     properties is a PropertyArrays instance
119931:     """
119931:     defineUnforgeables = ("if (!DefineUnforgeableAttributes(aCx, obj, %s)) {\n"
119931:                           "  return nullptr;\n"
119931:                           "}")
119931:     unforgeableAttrs = properties.unforgeableAttrs
119931:     unforgeables = []
119931:     if unforgeableAttrs.hasNonChromeOnly():
119931:         unforgeables.append(CGGeneric(defineUnforgeables %
119931:                                       unforgeableAttrs.variableName(False)))
119931:     if unforgeableAttrs.hasChromeOnly():
119931:         unforgeables.append(
119931:             CGIfWrapper(CGGeneric(defineUnforgeables %
119931:                                   unforgeableAttrs.variableName(True)),
119931:                         GetAccessCheck(descriptor, "global")))
119931: 
119931:     return CGIndenter(CGWrapper(
119931:             CGList(unforgeables, "\n"),
119931:             pre=("\n"
119931:             "// Important: do unforgeable property setup after we have handed\n"
119931:             "// over ownership of the C++ object to obj as needed, so that if\n"
119931:             "// we fail and it ends up GCed it won't have problems in the\n"
119931:             "// finalizer trying to drop its ownership of the C++ object.\n"),
119931:             post="\n")).define() if len(unforgeables) > 0 else ""
119931: 
109136: class CGWrapWithCacheMethod(CGAbstractMethod):
119931:     """
119931:     Create a wrapper JSObject for a given native that implements nsWrapperCache.
119931: 
119931:     properties should be a PropertyArrays instance.
119931:     """
119931:     def __init__(self, descriptor, properties):
 94512:         assert descriptor.interface.hasInterfacePrototypeObject()
 94512:         args = [Argument('JSContext*', 'aCx'), Argument('JSObject*', 'aScope'),
 94512:                 Argument(descriptor.nativeType + '*', 'aObject'),
109136:                 Argument('nsWrapperCache*', 'aCache'),
 94512:                 Argument('bool*', 'aTriedToWrap')]
 94512:         CGAbstractMethod.__init__(self, descriptor, 'Wrap', 'JSObject*', args)
119931:         self.properties = properties
 94512: 
 94512:     def definition_body(self):
 94512:         if self.descriptor.workers:
109136:             return """  *aTriedToWrap = true;
 94512:   return aObject->GetJSObject();"""
 94512: 
109136:         return """  *aTriedToWrap = true;
 94512: 
 97422:   JSObject* parent = WrapNativeParent(aCx, aScope, aObject->GetParentObject());
 94512:   if (!parent) {
 94512:     return NULL;
 94512:   }
 94512: 
109257:   JSAutoCompartment ac(aCx, parent);
 97127:   JSObject* global = JS_GetGlobalForObject(aCx, parent);
 94512: %s
120342:   JSObject* proto = GetProtoObject(aCx, global);
 94512:   if (!proto) {
 94512:     return NULL;
 94512:   }
 94512: 
109136: %s
119931: %s
109136:   aCache->SetWrapper(obj);
109136: 
114094:   return obj;""" % (CheckPref(self.descriptor, "global", "*aTriedToWrap", "NULL", "aCache"),
119931:                     CreateBindingJSObject(self.descriptor, "parent"),
119931:                     InitUnforgeableProperties(self.descriptor, self.properties))
109136: 
109136: class CGWrapMethod(CGAbstractMethod):
109136:     def __init__(self, descriptor):
109136:         # XXX can we wrap if we don't have an interface prototype object?
109136:         assert descriptor.interface.hasInterfacePrototypeObject()
109136:         args = [Argument('JSContext*', 'aCx'), Argument('JSObject*', 'aScope'),
109136:                 Argument('T*', 'aObject'), Argument('bool*', 'aTriedToWrap')]
109136:         CGAbstractMethod.__init__(self, descriptor, 'Wrap', 'JSObject*', args, inline=True, templateArgs=["class T"])
109136: 
109136:     def definition_body(self):
109136:         return "  return Wrap(aCx, aScope, aObject, aObject, aTriedToWrap);"
 94512: 
102142: class CGWrapNonWrapperCacheMethod(CGAbstractMethod):
119931:     """
119931:     Create a wrapper JSObject for a given native that does not implement
119931:     nsWrapperCache.
119931: 
119931:     properties should be a PropertyArrays instance.
119931:     """
119931:     def __init__(self, descriptor, properties):
102142:         # XXX can we wrap if we don't have an interface prototype object?
102142:         assert descriptor.interface.hasInterfacePrototypeObject()
102142:         args = [Argument('JSContext*', 'aCx'), Argument('JSObject*', 'aScope'),
102142:                 Argument(descriptor.nativeType + '*', 'aObject')]
102142:         CGAbstractMethod.__init__(self, descriptor, 'Wrap', 'JSObject*', args)
119931:         self.properties = properties
102142: 
102142:     def definition_body(self):
102142:         return """
102142:   JSObject* global = JS_GetGlobalForObject(aCx, aScope);
120342:   JSObject* proto = GetProtoObject(aCx, global);
102142:   if (!proto) {
102142:     return NULL;
102142:   }
102142: 
114094: %s
119931: %s
119931:   return obj;""" % (CreateBindingJSObject(self.descriptor, "global"),
119931:                     InitUnforgeableProperties(self.descriptor, self.properties))
102142: 
 94512: builtinNames = {
 94512:     IDLType.Tags.bool: 'bool',
 94512:     IDLType.Tags.int8: 'int8_t',
 94512:     IDLType.Tags.int16: 'int16_t',
 94512:     IDLType.Tags.int32: 'int32_t',
 94512:     IDLType.Tags.int64: 'int64_t',
 94512:     IDLType.Tags.uint8: 'uint8_t',
 94512:     IDLType.Tags.uint16: 'uint16_t',
 94512:     IDLType.Tags.uint32: 'uint32_t',
 94512:     IDLType.Tags.uint64: 'uint64_t',
 94512:     IDLType.Tags.float: 'float',
 94512:     IDLType.Tags.double: 'double'
 94512: }
 94512: 
106942: numericTags = [
106942:     IDLType.Tags.int8, IDLType.Tags.uint8,
106942:     IDLType.Tags.int16, IDLType.Tags.uint16,
106942:     IDLType.Tags.int32, IDLType.Tags.uint32,
106942:     IDLType.Tags.int64, IDLType.Tags.uint64,
106942:     IDLType.Tags.float, IDLType.Tags.double
106942:     ]
106942: 
 94512: class CastableObjectUnwrapper():
 94512:     """
 94512:     A class for unwrapping an object named by the "source" argument
 94512:     based on the passed-in descriptor and storing it in a variable
 94512:     called by the name in the "target" argument.
 94512: 
 94512:     codeOnFailure is the code to run if unwrapping fails.
 94512:     """
 94512:     def __init__(self, descriptor, source, target, codeOnFailure):
 94512:         assert descriptor.castable
110547: 
 94512:         self.substitution = { "type" : descriptor.nativeType,
 97422:                               "protoID" : "prototypes::id::" + descriptor.name,
 94512:                               "source" : source,
 94512:                               "target" : target,
102822:                               "codeOnFailure" : CGIndenter(CGGeneric(codeOnFailure), 4).define() }
110547:         if descriptor.hasXPConnectImpls:
110547:             # We don't use xpc_qsUnwrapThis because it will always throw on
110547:             # unwrap failure, whereas we want to control whether we throw or
110547:             # not.
110547:             self.substitution["codeOnFailure"] = CGIndenter(CGGeneric(string.Template(
110547:                 "${type} *objPtr;\n"
110547:                 "xpc_qsSelfRef objRef;\n"
110547:                 "JS::Value val = JS::ObjectValue(*${source});\n"
110547:                 "nsresult rv = xpc_qsUnwrapArg<${type}>(cx, val, &objPtr, &objRef.ptr, &val);\n"
110547:                 "if (NS_FAILED(rv)) {\n"
110547:                 "${codeOnFailure}\n"
110547:                 "}\n"
110547:                 "// We should be castable!\n"
110547:                 "MOZ_ASSERT(!objRef.ptr);\n"
110547:                 "// We should have an object, too!\n"
110547:                 "MOZ_ASSERT(objPtr);\n"
110547:                 "${target} = objPtr;").substitute(self.substitution)), 4).define()
 94512: 
 94512:     def __str__(self):
 94512:         return string.Template(
 94512: """{
 99323:   nsresult rv = UnwrapObject<${protoID}, ${type}>(cx, ${source}, ${target});
 94512:   if (NS_FAILED(rv)) {
 94512: ${codeOnFailure}
 94512:   }
 94512: }""").substitute(self.substitution)
 94512: 
 94512: class FailureFatalCastableObjectUnwrapper(CastableObjectUnwrapper):
 94512:     """
 94512:     As CastableObjectUnwrapper, but defaulting to throwing if unwrapping fails
 94512:     """
121475:     def __init__(self, descriptor, source, target, exceptionCode):
121475:         CastableObjectUnwrapper.__init__(
121475:             self, descriptor, source, target,
121475:             'ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s");\n'
121475:             '%s' % (descriptor.name, exceptionCode))
 94512: 
 94512: class CallbackObjectUnwrapper:
 94512:     """
 94512:     A class for unwrapping objects implemented in JS.
 94512: 
 94512:     |source| is the JSObject we want to use in native code.
 94512:     |target| is an nsCOMPtr of the appropriate type in which we store the result.
 94512:     """
121475:     def __init__(self, descriptor, source, target, exceptionCode,
121475:                  codeOnFailure=None):
 94512:         if codeOnFailure is None:
121475:             codeOnFailure = (
121475:                 'ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s");\n'
121475:                 '%s' % (descriptor.name, exceptionCode))
 94512:         self.descriptor = descriptor
 94512:         self.substitution = { "nativeType" : descriptor.nativeType,
 94512:                               "source" : source,
 94512:                               "target" : target,
102822:                               "codeOnFailure" : CGIndenter(CGGeneric(codeOnFailure)).define() }
 94512: 
 94512:     def __str__(self):
 94512:         if self.descriptor.workers:
 98551:             return string.Template(
 98551:                 "${target} = ${source};"
 98551:                 ).substitute(self.substitution)
 98551: 
 98551:         return string.Template(
 98551:             """nsresult rv;
 94512: XPCCallContext ccx(JS_CALLER, cx);
 94512: if (!ccx.IsValid()) {
 94512:   rv = NS_ERROR_XPC_BAD_CONVERT_JS;
 94512: ${codeOnFailure}
 94512: }
 94512: 
 94512: const nsIID& iid = NS_GET_IID(${nativeType});
 94512: nsRefPtr<nsXPCWrappedJS> wrappedJS;
 94512: rv = nsXPCWrappedJS::GetNewOrUsed(ccx, ${source}, iid,
 94512:                                   NULL, getter_AddRefs(wrappedJS));
 94512: if (NS_FAILED(rv) || !wrappedJS) {
 94512: ${codeOnFailure}
 94512: }
 94512: 
 98551: // Use a temp nsCOMPtr for the null-check, because ${target} might be
 98551: // OwningNonNull, not an nsCOMPtr.
 98551: nsCOMPtr<${nativeType}> tmp = do_QueryObject(wrappedJS.get());
 98551: if (!tmp) {
 94512: ${codeOnFailure}
 98551: }
 98551: ${target} = tmp.forget();""").substitute(self.substitution)
 98551: 
114326: def dictionaryHasSequenceMember(dictionary):
114326:     return (any(typeIsSequenceOrHasSequenceMember(m.type) for m in
114326:                 dictionary.members) or
114326:             (dictionary.parent and
114326:              dictionaryHasSequenceMember(dictionary.parent)))
114326: 
114326: def typeIsSequenceOrHasSequenceMember(type):
114326:     if type.nullable():
114326:         type = type.inner
114326:     if type.isSequence():
114326:         return True
114326:     if  type.isArray():
114326:         elementType = type.inner
114326:         return typeIsSequenceOrHasSequenceMember(elementType)
114326:     if type.isDictionary():
114326:         return dictionaryHasSequenceMember(type.inner)
114326:     if type.isUnion():
114326:         return any(typeIsSequenceOrHasSequenceMember(m.type) for m in
114326:                    type.flatMemberTypes)
114326:     return False
114326: 
121476: # If this function is modified, modify CGNativeMember.getArg and
121476: # CGNativeMember.getRetvalInfo accordingly.  The latter cares about the decltype
121476: # and holdertype we end up using.
 98552: def getJSToNativeConversionTemplate(type, descriptorProvider, failureCode=None,
 98552:                                     isDefinitelyObject=False,
101765:                                     isMember=False,
102418:                                     isOptional=False,
106942:                                     invalidEnumValueFatal=True,
109260:                                     defaultValue=None,
109260:                                     treatNullAs="Default",
111250:                                     treatUndefinedAs="Default",
111250:                                     isEnforceRange=False,
120966:                                     isClamp=False,
121475:                                     isNullOrUndefined=False,
121475:                                     exceptionCode=None):
 98551:     """
 98551:     Get a template for converting a JS value to a native object based on the
 98551:     given type and descriptor.  If failureCode is given, then we're actually
 98551:     testing whether we can convert the argument to the desired type.  That
 98551:     means that failures to convert due to the JS value being the wrong type of
 98551:     value need to use failureCode instead of throwing exceptions.  Failures to
 98551:     convert that are due to JS exceptions (from toString or valueOf methods) or
 98551:     out of memory conditions need to throw exceptions no matter what
121475:     failureCode is.  However what actually happens when throwing an exception
121475:     can be controlled by exceptionCode.  The only requirement on that is that
121475:     exceptionCode must end up doing a return, and every return from this
121475:     function must happen via exceptionCode if exceptionCode is not None.
 98551: 
 98551:     If isDefinitelyObject is True, that means we know the value
 98551:     isObject() and we have no need to recheck that.
 98551: 
101765:     if isMember is True, we're being converted from a property of some
101765:     JS object, not from an actual method argument, so we can't rely on
114326:     our jsval being rooted or outliving us in any way.  Any caller
114326:     passing true needs to ensure that it is handled correctly in
114326:     typeIsSequenceOrHasSequenceMember.
 99738: 
 99738:     If isOptional is true, then we are doing conversion of an optional
 99738:     argument with no default value.
 99738: 
106942:     invalidEnumValueFatal controls whether an invalid enum value conversion
106942:     attempt will throw (if true) or simply return without doing anything (if
106942:     false).
106942: 
106942:     If defaultValue is not None, it's the IDL default value for this conversion
106942: 
111250:     If isEnforceRange is true, we're converting an integer and throwing if the
111250:     value is out of range.
111250: 
111250:     If isClamp is true, we're converting an integer and clamping if the
111250:     value is out of range.
111250: 
 99738:     The return value from this function is a tuple consisting of four things:
 98551: 
 98551:     1)  A string representing the conversion code.  This will have template
 98551:         substitution performed on it as follows:
 98551: 
 98551:           ${val} replaced by an expression for the JS::Value in question
 98551:           ${valPtr} is a pointer to the JS::Value in question
 98551:           ${holderName} replaced by the holder's name, if any
 98551:           ${declName} replaced by the declaration's name
106942:           ${haveValue} replaced by an expression that evaluates to a boolean
106942:                        for whether we have a JS::Value.  Only used when
106942:                        defaultValue is not None.
121479:           ${obj} replaced by an object which, when unwrapped, tells us which
121479:                  compartment we really want to be working with here, in case
121479:                  that matters for our conversion.  This is allowed to be null if
121479:                  we just want to work with the compartment we're already in.
 98551: 
 98551:     2)  A CGThing representing the native C++ type we're converting to
 98551:         (declType).  This is allowed to be None if the conversion code is
 98551:         supposed to be used as-is.
 98551:     3)  A CGThing representing the type of a "holder" (holderType) which will
 98551:         hold a possible reference to the C++ thing whose type we returned in #1,
 98551:         or None if no such holder is needed.
 99738:     4)  A boolean indicating whether the caller has to do optional-argument handling.
 99738:         This will only be true if isOptional is true and if the returned template
 99738:         expects both declType and holderType to be wrapped in Optional<>, with
 99738:         ${declName} and ${holderName} adjusted to point to the Value() of the
 99738:         Optional, and Construct() calls to be made on the Optional<>s as needed.
 98551: 
 98551:     ${declName} must be in scope before the generated code is entered.
 98551: 
 98551:     If holderType is not None then ${holderName} must be in scope
 98551:     before the generated code is entered.
 98551:     """
106942:     # If we have a defaultValue then we're not actually optional for
106942:     # purposes of what we need to be declared as.
106942:     assert(defaultValue is None or not isOptional)
106942: 
106942:     # Also, we should not have a defaultValue if we know we're an object
106942:     assert(not isDefinitelyObject or defaultValue is None)
 98552: 
120967:     # And we can't both be an object and be null or undefined
120967:     assert not isDefinitelyObject or not isNullOrUndefined
120967: 
121475:     # If exceptionCode is not set, we'll just rethrow the exception we got.
121475:     # Note that we can't just set failureCode to exceptionCode, because setting
121475:     # failureCode will prevent pending exceptions from being set in cases when
121475:     # they really should be!
121475:     if exceptionCode is None:
121475:         exceptionCode = "return false;"
121475:     # We often want exceptionCode to be indented, since it often appears in an
121475:     # if body.
121475:     exceptionCodeIndented = CGIndenter(CGGeneric(exceptionCode))
121475: 
107126:     # Helper functions for dealing with failures due to the JS value being the
 99125:     # wrong type of value
107126:     def onFailureNotAnObject(failureCode):
 99125:         return CGWrapper(CGGeneric(
 99125:                 failureCode or
121475:                 ('ThrowErrorMessage(cx, MSG_NOT_OBJECT);\n'
121475:                  '%s' % exceptionCode)), post="\n")
107126:     def onFailureBadType(failureCode, typeName):
107126:         return CGWrapper(CGGeneric(
107126:                 failureCode or
121475:                 ('ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s");'
121475:                  '%s' % (typeName, exceptionCode))), post="\n")
118539:     def onFailureNotCallable(failureCode):
118539:         return CGWrapper(CGGeneric(
118539:                 failureCode or
121475:                 ('ThrowErrorMessage(cx, MSG_NOT_CALLABLE);\n'
121475:                  '%s' % exceptionCode)), post="\n")
 99125: 
106942:     # A helper function for handling default values.  Takes a template
106942:     # body and the C++ code to set the default value and wraps the
106942:     # given template body in handling for the default value.
106942:     def handleDefault(template, setDefault):
106942:         if defaultValue is None:
106942:             return template
106942:         return CGWrapper(
106942:             CGIndenter(CGGeneric(template)),
106942:             pre="if (${haveValue}) {\n",
106942:             post=("\n"
106942:                   "} else {\n"
106942:                   "%s;\n"
106942:                   "}" %
106942:                   CGIndenter(CGGeneric(setDefault)).define())).define()
106942: 
106942:     # A helper function for handling null default values.  Much like
106942:     # handleDefault, but checks that the default value, if it exists, is null.
106942:     def handleDefaultNull(template, codeToSetNull):
106942:         if (defaultValue is not None and
106942:             not isinstance(defaultValue, IDLNullValue)):
106942:             raise TypeError("Can't handle non-null default value here")
106942:         return handleDefault(template, codeToSetNull)
106942: 
 98552:     # A helper function for wrapping up the template body for
 98552:     # possibly-nullable objecty stuff
120967:     def wrapObjectTemplate(templateBody, type, codeToSetNull, failureCode=None):
120967:         if isNullOrUndefined:
120967:             assert type.nullable()
120967:             # Just ignore templateBody and set ourselves to null.
120967:             # Note that wedon't have to worry about default values
120967:             # here either, since we already examined this value.
120967:             return "%s;" % codeToSetNull
120967: 
 98552:         if not isDefinitelyObject:
 98552:             # Handle the non-object cases by wrapping up the whole
 98552:             # thing in an if cascade.
 98552:             templateBody = (
 98552:                 "if (${val}.isObject()) {\n" +
 98552:                 CGIndenter(CGGeneric(templateBody)).define() + "\n")
 98552:             if type.nullable():
 98552:                 templateBody += (
 98552:                     "} else if (${val}.isNullOrUndefined()) {\n"
 98552:                     "  %s;\n" % codeToSetNull)
 98552:             templateBody += (
 99125:                 "} else {\n" +
107126:                 CGIndenter(onFailureNotAnObject(failureCode)).define() +
 99125:                 "}")
106942:             if type.nullable():
106942:                 templateBody = handleDefaultNull(templateBody, codeToSetNull)
106942:             else:
106942:                 assert(defaultValue is None)
106942: 
 98552:         return templateBody
 98552: 
111250:     assert not (isEnforceRange and isClamp) # These are mutually exclusive
111250: 
 98552:     if type.isArray():
 98552:         raise TypeError("Can't handle array arguments yet")
 98552: 
 98552:     if type.isSequence():
111250:         assert not isEnforceRange and not isClamp
111250: 
120964:         if failureCode is None:
121475:             notSequence = ("ThrowErrorMessage(cx, MSG_NOT_SEQUENCE);\n"
121475:                            "%s" % exceptionCode)
120964:         else:
120964:             notSequence = failureCode
120964: 
 98552:         nullable = type.nullable();
 99322:         # Be very careful not to change "type": we need it later
 98552:         if nullable:
 99322:             elementType = type.inner.inner
 99322:         else:
 99322:             elementType = type.inner
114326: 
114326:         # We have to be careful with reallocation behavior for arrays.  In
114326:         # particular, if we have a sequence of elements which are themselves
114326:         # sequences (so nsAutoTArrays) or have sequences as members, we have a
114326:         # problem.  In that case, resizing the outermost nsAutoTarray to the
114326:         # right size will memmove its elements, but nsAutoTArrays are not
114326:         # memmovable and hence will end up with pointers to bogus memory, which
114326:         # is bad.  To deal with this, we disallow sequences, arrays,
114326:         # dictionaries, and unions which contain sequences as sequence item
114326:         # types.  If WebIDL ever adds another container type, we'd have to
114326:         # disallow it as well.
114326:         if typeIsSequenceOrHasSequenceMember(elementType):
114326:             raise TypeError("Can't handle a sequence containing another "
114326:                             "sequence as an element or member of an element.  "
114326:                             "See the big comment explaining why.\n%s" %
114326:                             str(type.location))
114326: 
 98552:         (elementTemplate, elementDeclType,
 99738:          elementHolderType, dealWithOptional) = getJSToNativeConversionTemplate(
121475:             elementType, descriptorProvider, isMember=True,
121475:             exceptionCode=exceptionCode)
 99738:         if dealWithOptional:
 99738:             raise TypeError("Shouldn't have optional things in sequences")
 98552:         if elementHolderType is not None:
 98552:             raise TypeError("Shouldn't need holders for sequences")
 98552: 
 99322:         typeName = CGWrapper(elementDeclType, pre="Sequence< ", post=" >")
 98552:         if nullable:
 98552:             typeName = CGWrapper(typeName, pre="Nullable< ", post=" >")
 99738:             arrayRef = "${declName}.Value()"
 99322:         else:
 99738:             arrayRef = "${declName}"
 99738:         # If we're optional, the const will come from the Optional
 99738:         mutableTypeName = typeName
 99738:         if not isOptional:
 99738:             typeName = CGWrapper(typeName, pre="const ")
 99738: 
 98552:         templateBody = ("""JSObject* seq = &${val}.toObject();\n
 98552: if (!IsArrayLike(cx, seq)) {
120964: %s
 98552: }
 98552: uint32_t length;
 98552: // JS_GetArrayLength actually works on all objects
 98552: if (!JS_GetArrayLength(cx, seq, &length)) {
121475: %s
 98552: }
 99738: Sequence< %s > &arr = const_cast< Sequence< %s >& >(%s);
 98552: if (!arr.SetCapacity(length)) {
119071:   JS_ReportOutOfMemory(cx);
121475: %s
 98552: }
 98552: for (uint32_t i = 0; i < length; ++i) {
 98552:   jsval temp;
 98552:   if (!JS_GetElement(cx, seq, i, &temp)) {
121475: %s
 98552:   }
120964: """ % (CGIndenter(CGGeneric(notSequence)).define(),
121475:        exceptionCodeIndented.define(),
120964:        elementDeclType.define(),
 98552:        elementDeclType.define(),
121475:        arrayRef,
121475:        exceptionCodeIndented.define(),
121475:        CGIndenter(exceptionCodeIndented).define()))
 98552: 
 98552:         templateBody += CGIndenter(CGGeneric(
 98552:                 string.Template(elementTemplate).substitute(
 98552:                     {
 98552:                         "val" : "temp",
101767:                         "valPtr": "&temp",
121479:                         "declName" : "(*arr.AppendElement())",
121479:                         # Use the same ${obj} as for the sequence itself
121479:                         "obj": "${obj}"
 98552:                         }
 98552:                     ))).define()
 98552: 
 99322:         templateBody += "\n}"
120967:         templateBody = wrapObjectTemplate(templateBody, type,
107126:                                           "const_cast< %s & >(${declName}).SetNull()" % mutableTypeName.define())
 99738:         return (templateBody, typeName, None, isOptional)
 98552: 
102822:     if type.isUnion():
102822:         if isMember:
102822:             raise TypeError("Can't handle unions as members, we have a "
102822:                             "holderType")
102822:         nullable = type.nullable();
102822:         if nullable:
102822:             type = type.inner
102822: 
106942:         assert(defaultValue is None or
106942:                (isinstance(defaultValue, IDLNullValue) and nullable))
106942: 
102822:         unionArgumentObj = "${holderName}"
102822:         if isOptional or nullable:
102822:             unionArgumentObj += ".ref()"
102822: 
102822:         memberTypes = type.flatMemberTypes
107126:         names = []
102822: 
102822:         interfaceMemberTypes = filter(lambda t: t.isNonCallbackInterface(), memberTypes)
102822:         if len(interfaceMemberTypes) > 0:
102822:             interfaceObject = []
102822:             for memberType in interfaceMemberTypes:
102822:                 if type.isGeckoInterface():
102822:                     name = memberType.inner.identifier.name
102822:                 else:
102822:                     name = memberType.name
121479:                 interfaceObject.append(CGGeneric("(failed = !%s.TrySetTo%s(cx, ${obj}, ${val}, ${valPtr}, tryNext)) || !tryNext" % (unionArgumentObj, name)))
107126:                 names.append(name)
102822:             interfaceObject = CGWrapper(CGList(interfaceObject, " ||\n"), pre="done = ", post=";\n", reindent=True)
102822:         else:
102822:             interfaceObject = None
102822: 
102822:         arrayObjectMemberTypes = filter(lambda t: t.isArray() or t.isSequence(), memberTypes)
102822:         if len(arrayObjectMemberTypes) > 0:
102822:             assert len(arrayObjectMemberTypes) == 1
102822:             memberType = arrayObjectMemberTypes[0]
102822:             name = memberType.name
121479:             arrayObject = CGGeneric("done = (failed = !%s.TrySetTo%s(cx, ${obj}, ${val}, ${valPtr}, tryNext)) || !tryNext;" % (unionArgumentObj, name))
102822:             # XXX Now we're supposed to check for an array or a platform object
102822:             # that supports indexed properties... skip that last for now. It's a
102822:             # bit of a pain.
102822:             arrayObject = CGWrapper(CGIndenter(arrayObject),
102822:                                     pre="if (IsArrayLike(cx, &argObj)) {\n",
102822:                                     post="}")
107126:             names.append(name)
102822:         else:
102822:             arrayObject = None
102822: 
102822:         dateObjectMemberTypes = filter(lambda t: t.isDate(), memberTypes)
102822:         if len(dateObjectMemberTypes) > 0:
102822:             assert len(dateObjectMemberTypes) == 1
102822:             memberType = dateObjectMemberTypes[0]
102822:             name = memberType.name
102822:             dateObject = CGGeneric("%s.SetTo%s(cx, ${val}, ${valPtr});\n"
102822:                                    "done = true;" % (unionArgumentObj, name))
102822:             dateObject = CGWrapper(CGIndenter(dateObject),
102822:                                    pre="if (JS_ObjectIsDate(cx, &argObj)) {\n",
102822:                                    post="\n}")
107126:             names.append(name)
102822:         else:
102822:             dateObject = None
102822: 
102822:         callbackMemberTypes = filter(lambda t: t.isCallback() or t.isCallbackInterface(), memberTypes)
102822:         if len(callbackMemberTypes) > 0:
102822:             assert len(callbackMemberTypes) == 1
102822:             memberType = callbackMemberTypes[0]
102822:             name = memberType.name
121479:             callbackObject = CGGeneric("done = (failed = !%s.TrySetTo%s(cx, ${obj}, ${val}, ${valPtr}, tryNext)) || !tryNext;" % (unionArgumentObj, name))
107126:             names.append(name)
102822:         else:
102822:             callbackObject = None
102822: 
102822:         dictionaryMemberTypes = filter(lambda t: t.isDictionary(), memberTypes)
102822:         if len(dictionaryMemberTypes) > 0:
102822:             raise TypeError("No support for unwrapping dictionaries as member "
102822:                             "of a union")
102822:         else:
102822:             dictionaryObject = None
102822: 
102822:         if callbackObject or dictionaryObject:
102822:             nonPlatformObject = CGList([callbackObject, dictionaryObject], "\n")
102822:             nonPlatformObject = CGWrapper(CGIndenter(nonPlatformObject),
102822:                                           pre="if (!IsPlatformObject(cx, &argObj)) {\n",
102822:                                           post="\n}")
102822:         else:
102822:             nonPlatformObject = None
102822: 
102822:         objectMemberTypes = filter(lambda t: t.isObject(), memberTypes)
102822:         if len(objectMemberTypes) > 0:
102822:             object = CGGeneric("%s.SetToObject(&argObj);\n"
102822:                                "done = true;" % unionArgumentObj)
102822:         else:
102822:             object = None
102822: 
102822:         hasObjectTypes = interfaceObject or arrayObject or dateObject or nonPlatformObject or object
102822:         if hasObjectTypes:
102822:             # If we try more specific object types first then we need to check
102822:             # whether that succeeded before converting to object.
102822:             if object and (interfaceObject or arrayObject or dateObject or nonPlatformObject):
102822:                 object = CGWrapper(CGIndenter(object), pre="if (!done) {\n",
102822:                                    post=("\n}"))
102822: 
102822:             if arrayObject or dateObject or nonPlatformObject:
102822:                 # An object can be both an array object and not a platform
102822:                 # object, but we shouldn't have both in the union's members
102822:                 # because they are not distinguishable.
102822:                 assert not (arrayObject and nonPlatformObject)
102822:                 templateBody = CGList([arrayObject, dateObject, nonPlatformObject], " else ")
102822:             else:
102822:                 templateBody = None
102822:             if interfaceObject:
102822:                 if templateBody:
102822:                     templateBody = CGList([templateBody, object], "\n")
102822:                     templateBody = CGWrapper(CGIndenter(templateBody),
102822:                                              pre="if (!done) {\n", post=("\n}"))
102822:                 templateBody = CGList([interfaceObject, templateBody], "\n")
102822:             else:
102822:                 templateBody = CGList([templateBody, object], "\n")
102822: 
102822:             if any([arrayObject, dateObject, nonPlatformObject, object]):
102822:                 templateBody.prepend(CGGeneric("JSObject& argObj = ${val}.toObject();"))
102822:             templateBody = CGWrapper(CGIndenter(templateBody),
102822:                                      pre="if (${val}.isObject()) {\n",
102822:                                      post="\n}")
102822:         else:
102822:             templateBody = CGGeneric()
102822: 
102822:         otherMemberTypes = filter(lambda t: t.isString() or t.isEnum(),
102822:                                   memberTypes)
102822:         otherMemberTypes.extend(t for t in memberTypes if t.isPrimitive())
102822:         if len(otherMemberTypes) > 0:
102822:             assert len(otherMemberTypes) == 1
102822:             memberType = otherMemberTypes[0]
102822:             if memberType.isEnum():
102822:                 name = memberType.inner.identifier.name
102822:             else:
102822:                 name = memberType.name
121479:             other = CGGeneric("done = (failed = !%s.TrySetTo%s(cx, ${obj}, ${val}, ${valPtr}, tryNext)) || !tryNext;" % (unionArgumentObj, name))
107126:             names.append(name)
102822:             if hasObjectTypes:
102822:                 other = CGWrapper(CGIndenter(other), "{\n", post="\n}")
102822:                 if object:
102822:                     join = " else "
102822:                 else:
102822:                     other = CGWrapper(other, pre="if (!done) ")
102822:                     join = "\n"
102822:                 templateBody = CGList([templateBody, other], join)
102822:         else:
102822:             other = None
102822: 
102822:         templateBody = CGWrapper(templateBody, pre="bool done = false, failed = false, tryNext;\n")
102822:         throw = CGGeneric("if (failed) {\n"
121475:                           "%s\n"
102822:                           "}\n"
102822:                           "if (!done) {\n"
121475:                           "  ThrowErrorMessage(cx, MSG_NOT_IN_UNION, \"%s\");\n"
121475:                           "%s\n"
121475:                           "}" % (exceptionCodeIndented.define(),
121475:                                  ", ".join(names),
121475:                                  exceptionCodeIndented.define()))
102822:         templateBody = CGWrapper(CGIndenter(CGList([templateBody, throw], "\n")), pre="{\n", post="\n}")
102822: 
102822:         typeName = type.name
102822:         argumentTypeName = typeName + "Argument"
102822:         if nullable:
102822:             typeName = "Nullable<" + typeName + " >"
102822:         if isOptional:
102822:             nonConstDecl = "const_cast<Optional<" + typeName + " >& >(${declName})"
102822:         else:
102822:             nonConstDecl = "const_cast<" + typeName + "& >(${declName})"
102822:             typeName = "const " + typeName
102822: 
106942:         def handleNull(templateBody, setToNullVar, extraConditionForNull=""):
106942:             null = CGGeneric("if (%s${val}.isNullOrUndefined()) {\n"
102822:                              "  %s.SetNull();\n"
106942:                              "}" % (extraConditionForNull, setToNullVar))
102822:             templateBody = CGWrapper(CGIndenter(templateBody), pre="{\n", post="\n}")
102822:             return CGList([null, templateBody], " else ")
102822: 
102822:         if type.hasNullableType:
102822:             templateBody = handleNull(templateBody, unionArgumentObj)
102822: 
102822:         declType = CGGeneric(typeName)
102822:         holderType = CGGeneric(argumentTypeName)
102822:         if isOptional:
102822:             mutableDecl = nonConstDecl + ".Value()"
102822:             declType = CGWrapper(declType, pre="const Optional<", post=" >")
102822:             holderType = CGWrapper(holderType, pre="Maybe<", post=" >")
102822:             constructDecl = CGGeneric(nonConstDecl + ".Construct();")
102822:             if nullable:
102822:                 constructHolder = CGGeneric("${holderName}.construct(%s.SetValue());" % mutableDecl)
102822:             else:
102822:                 constructHolder = CGGeneric("${holderName}.construct(${declName}.Value());")
102822:         else:
102822:             mutableDecl = nonConstDecl
102822:             constructDecl = None
102822:             if nullable:
102822:                 holderType = CGWrapper(holderType, pre="Maybe<", post=" >")
102822:                 constructHolder = CGGeneric("${holderName}.construct(%s.SetValue());" % mutableDecl)
102822:             else:
102822:                 constructHolder = CGWrapper(holderType, post=" ${holderName}(${declName});")
102822:                 holderType = None
102822: 
102822:         templateBody = CGList([constructHolder, templateBody], "\n")
102822:         if nullable:
106942:             if defaultValue:
106942:                 assert(isinstance(defaultValue, IDLNullValue))
106942:                 valueMissing = "!(${haveValue}) || "
106942:             else:
106942:                 valueMissing = ""
106942:             templateBody = handleNull(templateBody, mutableDecl,
106942:                                       extraConditionForNull=valueMissing)
102822:         templateBody = CGList([constructDecl, templateBody], "\n")
102822: 
102822:         return templateBody.define(), declType, holderType, False
102822: 
 99320:     if type.isGeckoInterface():
111250:         assert not isEnforceRange and not isClamp
111250: 
 98552:         descriptor = descriptorProvider.getDescriptor(
 98552:             type.unroll().inner.identifier.name)
 94512:         # This is an interface that we implement as a concrete class
 94512:         # or an XPCOM interface.
 98551: 
 98551:         # Allow null pointers for nullable types and old-binding classes
 94512:         argIsPointer = type.nullable() or type.unroll().inner.isExternal()
 98551: 
 98552:         # Sequences and non-worker callbacks have to hold a strong ref to the
 98552:         # thing being passed down.
 98551:         forceOwningType = (descriptor.interface.isCallback() and
101765:                            not descriptor.workers) or isMember
 98551: 
 98551:         typeName = descriptor.nativeType
 98551:         typePtr = typeName + "*"
 98551: 
 98551:         # Compute a few things:
 98551:         #  - declType is the type we want to return as the first element of our
 98551:         #    tuple.
 98551:         #  - holderType is the type we want to return as the third element
 98551:         #    of our tuple.
 98551: 
 98551:         # Set up some sensible defaults for these things insofar as we can.
 98551:         holderType = None
 94512:         if argIsPointer:
 98551:             if forceOwningType:
 98551:                 declType = "nsRefPtr<" + typeName + ">"
 94512:             else:
 98551:                 declType = typePtr
 94512:         else:
 98551:             if forceOwningType:
 98551:                 declType = "OwningNonNull<" + typeName + ">"
 98551:             else:
 98551:                 declType = "NonNull<" + typeName + ">"
 98551: 
 98551:         templateBody = ""
 94512:         if descriptor.castable:
102143:             if descriptor.prefable:
102143:                 raise TypeError("We don't support prefable castable object "
102143:                                 "arguments (like %s), because we don't know "
102143:                                 "how to handle them being preffed off" %
102143:                                 descriptor.interface.identifier.name)
105804:             if descriptor.interface.isConsequential():
105804:                 raise TypeError("Consequential interface %s being used as an "
105804:                                 "argument but flagged as castable" %
105804:                                 descriptor.interface.identifier.name)
 98551:             if failureCode is not None:
 98551:                 templateBody += str(CastableObjectUnwrapper(
 98551:                         descriptor,
 98551:                         "&${val}.toObject()",
 99323:                         "${declName}",
 98551:                         failureCode))
 98551:             else:
 94512:                 templateBody += str(FailureFatalCastableObjectUnwrapper(
 94512:                         descriptor,
 98551:                         "&${val}.toObject()",
121475:                         "${declName}",
121475:                         exceptionCode))
 94512:         elif descriptor.interface.isCallback():
 94512:             templateBody += str(CallbackObjectUnwrapper(
 94512:                     descriptor,
 98551:                     "&${val}.toObject()",
 98551:                     "${declName}",
121475:                     exceptionCode,
 98551:                     codeOnFailure=failureCode))
 94512:         elif descriptor.workers:
 98551:             templateBody += "${declName} = &${val}.toObject();"
 94512:         else:
102734:             # Either external, or new-binding non-castable.  We always have a
102734:             # holder for these, because we don't actually know whether we have
102734:             # to addref when unwrapping or not.  So we just pass an
102734:             # getter_AddRefs(nsRefPtr) to XPConnect and if we'll need a release
102734:             # it'll put a non-null pointer in there.
 98552:             if forceOwningType:
 98552:                 # Don't return a holderType in this case; our declName
 98552:                 # will just own stuff.
102326:                 templateBody += "nsRefPtr<" + typeName + "> ${holderName};\n"
 98552:             else:
 99793:                 holderType = "nsRefPtr<" + typeName + ">"
 98551:             templateBody += (
 98551:                 "jsval tmpVal = ${val};\n" +
 98551:                 typePtr + " tmp;\n"
 99793:                 "if (NS_FAILED(xpc_qsUnwrapArg<" + typeName + ">(cx, ${val}, &tmp, static_cast<" + typeName + "**>(getter_AddRefs(${holderName})), &tmpVal))) {\n")
107126:             templateBody += CGIndenter(onFailureBadType(failureCode,
107126:                                                         descriptor.interface.identifier.name)).define()
 98551:             templateBody += ("}\n"
 98551:                 "MOZ_ASSERT(tmp);\n")
 98551: 
 98551:             if not isDefinitelyObject:
 98551:                 # Our tmpVal will go out of scope, so we can't rely on it
 98551:                 # for rooting
 98551:                 templateBody += (
 98551:                     "if (tmpVal != ${val} && !${holderName}) {\n"
 98551:                     "  // We have to have a strong ref, because we got this off\n"
 98551:                     "  // some random object that might get GCed\n"
 98551:                     "  ${holderName} = tmp;\n"
 98551:                     "}\n")
 98551: 
 98551:             # And store our tmp, before it goes out of scope.
 98551:             templateBody += "${declName} = tmp;"
 98551: 
120967:         templateBody = wrapObjectTemplate(templateBody, type,
120967:                                           "${declName} = NULL",
107126:                                           failureCode)
 98551: 
 98551:         declType = CGGeneric(declType)
 98551:         if holderType is not None:
 98551:             holderType = CGGeneric(holderType)
 99738:         return (templateBody, declType, holderType, isOptional)
 94512: 
 99320:     if type.isSpiderMonkeyInterface():
111250:         assert not isEnforceRange and not isClamp
101765:         if isMember:
101765:             raise TypeError("Can't handle member arraybuffers or "
 99320:                             "arraybuffer views because making sure all the "
 99320:                             "objects are properly rooted is hard")
 99320:         name = type.name
 99738:         # By default, we use a Maybe<> to hold our typed array.  And in the optional
 99738:         # non-nullable case we want to pass Optional<TypedArray> to consumers, not
 99738:         # Optional<NonNull<TypedArray> >, so jump though some hoops to do that.
 99320:         holderType = "Maybe<%s>" % name
 99738:         constructLoc = "${holderName}"
 99738:         constructMethod = "construct"
107062:         constructInternal = "ref"
 99320:         if type.nullable():
 99738:             if isOptional:
 99738:                 declType = "const Optional<" + name + "*>"
 99738:             else:
 99320:                 declType = name + "*"
 99320:         else:
 99738:             if isOptional:
 99738:                 declType = "const Optional<" + name + ">"
 99738:                 # We don't need a holder in this case
 99738:                 holderType = None
 99738:                 constructLoc = "(const_cast<Optional<" + name + ">& >(${declName}))"
 99738:                 constructMethod = "Construct"
107062:                 constructInternal = "Value"
 99738:             else:
 99320:                 declType = "NonNull<" + name + ">"
 94512:         template = (
121703:             "%s.%s(cx, &${val}.toObject());\n"
107062:             "if (!%s.%s().inited()) {\n"
107126:             "%s" # No newline here because onFailureBadType() handles that
107062:             "}\n" %
107062:             (constructLoc, constructMethod, constructLoc, constructInternal,
107126:              CGIndenter(onFailureBadType(failureCode, type.name)).define()))
 99738:         nullableTarget = ""
 99738:         if type.nullable():
 99738:             if isOptional:
 99738:                 mutableDecl = "(const_cast<Optional<" + name + "*>& >(${declName}))"
 99738:                 template += "%s.Construct();\n" % mutableDecl
 99738:                 nullableTarget = "%s.Value()" % mutableDecl
 99738:             else:
 99738:                 nullableTarget = "${declName}"
 99738:             template += "%s = ${holderName}.addr();" % nullableTarget
 99738:         elif not isOptional:
 99320:             template += "${declName} = ${holderName}.addr();"
120967:         template = wrapObjectTemplate(template, type,
 99738:                                       "%s = NULL" % nullableTarget,
 99320:                                       failureCode)
 99320: 
 99738:         if holderType is not None:
 99738:             holderType = CGGeneric(holderType)
 99738:         # We handle all the optional stuff ourselves; no need for caller to do it.
 99738:         return (template, CGGeneric(declType), holderType, False)
 94512: 
 94512:     if type.isString():
111250:         assert not isEnforceRange and not isClamp
 94512: 
109260:         treatAs = {
109260:             "Default": "eStringify",
109260:             "EmptyString": "eEmpty",
109260:             "Null": "eNull"
109260:         }
 94512:         if type.nullable():
109260:             # For nullable strings null becomes a null string.
109260:             treatNullAs = "Null"
109260:             # For nullable strings undefined becomes a null string unless
109260:             # specified otherwise.
109260:             if treatUndefinedAs == "Default":
109260:                 treatUndefinedAs = "Null"
109260:         nullBehavior = treatAs[treatNullAs]
109260:         if treatUndefinedAs == "Missing":
109260:             raise TypeError("We don't support [TreatUndefinedAs=Missing]")
109260:         undefinedBehavior = treatAs[treatUndefinedAs]
 94512: 
106944:         def getConversionCode(varName):
106944:             conversionCode = (
106944:                 "if (!ConvertJSValueToString(cx, ${val}, ${valPtr}, %s, %s, %s)) {\n"
121475:                 "%s\n"
121475:                 "}" % (nullBehavior, undefinedBehavior, varName,
121475:                        exceptionCodeIndented.define()))
106944:             if defaultValue is None:
106944:                 return conversionCode
106944: 
106944:             if isinstance(defaultValue, IDLNullValue):
106944:                 assert(type.nullable())
106944:                 return handleDefault(conversionCode,
106944:                                      "%s.SetNull()" % varName)
106944:             return handleDefault(
106944:                 conversionCode,
107194:                 ("static const PRUnichar data[] = { %s };\n"
106944:                  "%s.SetData(data, ArrayLength(data) - 1)" %
107194:                  (", ".join(["'" + char + "'" for char in defaultValue.value] + ["0"]),
106944:                   varName)))
106942: 
101767:         if isMember:
101767:             # We have to make a copy, because our jsval may well not
101767:             # live as long as our string needs to.
101767:             declType = CGGeneric("nsString")
101767:             return (
101767:                 "{\n"
105571:                 "  FakeDependentString str;\n"
106944:                 "%s\n"
101767:                 "  ${declName} = str;\n"
106944:                 "}\n" % CGIndenter(CGGeneric(getConversionCode("str"))).define(),
106944:                 declType, None, isOptional)
101767: 
 99738:         if isOptional:
 99738:             declType = "Optional<nsAString>"
 99738:         else:
 99738:             declType = "NonNull<nsAString>"
106944: 
 94512:         return (
106944:             "%s\n"
 99738:             "const_cast<%s&>(${declName}) = &${holderName};" %
106944:             (getConversionCode("${holderName}"), declType),
105571:             CGGeneric("const " + declType), CGGeneric("FakeDependentString"),
 99738:             # No need to deal with Optional here; we have handled it already
 99738:             False)
 94512: 
 94512:     if type.isEnum():
111250:         assert not isEnforceRange and not isClamp
111250: 
 94512:         if type.nullable():
 94512:             raise TypeError("We don't support nullable enumerated arguments "
 94512:                             "yet")
 94512:         enum = type.inner.identifier.name
105520:         if invalidEnumValueFatal:
105520:             handleInvalidEnumValueCode = "  MOZ_ASSERT(index >= 0);\n"
105520:         else:
121481:             # invalidEnumValueFatal is false only for attributes.  So we won't
121481:             # have a non-default exceptionCode here unless attribute "arg
121481:             # conversion" code starts passing in an exceptionCode.  At which
121481:             # point we'll need to figure out what that even means.
121475:             assert exceptionCode == "return false;"
105520:             handleInvalidEnumValueCode = (
105520:                 "  if (index < 0) {\n"
105520:                 "    return true;\n"
105520:                 "  }\n")
105520:             
106943:         template = (
 94512:             "{\n"
 94512:             "  bool ok;\n"
105520:             "  int index = FindEnumStringIndex<%(invalidEnumValueFatal)s>(cx, ${val}, %(values)s, \"%(enumtype)s\", &ok);\n"
 94512:             "  if (!ok) {\n"
121475:             "%(exceptionCode)s\n"
 94512:             "  }\n"
105520:             "%(handleInvalidEnumValueCode)s"
102418:             "  ${declName} = static_cast<%(enumtype)s>(index);\n"
 97422:             "}" % { "enumtype" : enum,
102418:                       "values" : enum + "Values::strings",
105520:        "invalidEnumValueFatal" : toStringBool(invalidEnumValueFatal),
121475:   "handleInvalidEnumValueCode" : handleInvalidEnumValueCode,
121475:                "exceptionCode" : CGIndenter(exceptionCodeIndented).define() })
106943: 
106943:         if defaultValue is not None:
106943:             assert(defaultValue.type.tag() == IDLType.Tags.domstring)
106943:             template = handleDefault(template,
106943:                                      ("${declName} = %sValues::%s" %
106943:                                       (enum,
106943:                                        getEnumValueName(defaultValue.value))))
106943:         return (template, CGGeneric(enum), None, isOptional)
 94512: 
 94512:     if type.isCallback():
111250:         assert not isEnforceRange and not isClamp
118539:         assert not type.treatNonCallableAsNull() or type.nullable()
111250: 
101765:         if isMember:
101765:             raise TypeError("Can't handle member callbacks; need to sort out "
101765:                             "rooting issues")
118539: 
121480:         if descriptorProvider.workers:
118539:             if type.nullable():
118539:                 declType = CGGeneric("JSObject*")
118539:             else:
118539:                 declType = CGGeneric("NonNull<JSObject>")
121480:             conversion = "  ${declName} = &${val}.toObject();\n"
121480:         else:
121480:             name = type.unroll().identifier.name
121480:             if type.nullable():
121480:                 declType = CGGeneric("nsRefPtr<%s>" % name);
121480:             else:
121480:                 declType = CGGeneric("OwningNonNull<%s>" % name)
121480:             conversion = (
121480:                 "  bool inited;\n"
121480:                 "  ${declName} = new %s(cx, ${obj}, &${val}.toObject(), &inited);\n"
121480:                 "  if (!inited) {\n"
121480:                 "%s\n"
121480:                 "  }\n" % (name, CGIndenter(exceptionCodeIndented).define()))
118539: 
118539:         if type.treatNonCallableAsNull():
118539:             haveCallable = "JS_ObjectIsCallable(cx, &${val}.toObject())"
118539:             if not isDefinitelyObject:
118539:                 haveCallable = "${val}.isObject() && " + haveCallable
106942:             if defaultValue is not None:
106942:                 assert(isinstance(defaultValue, IDLNullValue))
106942:                 haveCallable = "${haveValue} && " + haveCallable
118539:             template = (
121480:                 ("if (%s) {\n" % haveCallable) +
121480:                 conversion +
 94512:                 "} else {\n"
118539:                 "  ${declName} = nullptr;\n"
121480:                 "}")
118539:         else:
118539:             template = wrapObjectTemplate(
121480:                 "if (JS_ObjectIsCallable(cx, &${val}.toObject())) {\n" +
121480:                 conversion +
118539:                 "} else {\n"
118539:                 "%s"
118539:                 "}" % CGIndenter(onFailureNotCallable(failureCode)).define(),
120967:                 type,
118539:                 "${declName} = nullptr",
118539:                 failureCode)
118539:         return (template, declType, None, isOptional)
 94512: 
 94512:     if type.isAny():
111250:         assert not isEnforceRange and not isClamp
111250: 
101765:         if isMember:
101765:             raise TypeError("Can't handle member 'any'; need to sort out "
101765:                             "rooting issues")
106942:         templateBody = "${declName} = ${val};"
106942:         templateBody = handleDefaultNull(templateBody,
106942:                                          "${declName} = JS::NullValue()")
106942:         return (templateBody, CGGeneric("JS::Value"), None, isOptional)
 94512: 
 99125:     if type.isObject():
111250:         assert not isEnforceRange and not isClamp
111250: 
101765:         if isMember:
101765:             raise TypeError("Can't handle member 'object'; need to sort out "
101765:                             "rooting issues")
 99125:         template = wrapObjectTemplate("${declName} = &${val}.toObject();",
120967:                                       type,
 99125:                                       "${declName} = NULL",
107126:                                       failureCode)
 99125:         if type.nullable():
 99125:             declType = CGGeneric("JSObject*")
 99125:         else:
 99125:             declType = CGGeneric("NonNull<JSObject>")
 99738:         return (template, declType, None, isOptional)
 99125: 
101766:     if type.isDictionary():
101766:         if failureCode is not None:
101766:             raise TypeError("Can't handle dictionaries when failureCode is not None")
105570:         # There are no nullable dictionaries
105570:         assert not type.nullable()
105570:         # All optional dictionaries always have default values, so we
105570:         # should be able to assume not isOptional here.
105570:         assert not isOptional
105570: 
102326:         typeName = CGDictionary.makeDictionaryName(type.inner,
102326:                                                    descriptorProvider.workers)
102424:         actualTypeName = typeName
101766:         selfRef = "${declName}"
102424: 
102424:         declType = CGGeneric(actualTypeName)
102424: 
105570:         # If we're a member of something else, the const
101766:         # will come from the Optional or our container.
105570:         if not isMember:
101766:             declType = CGWrapper(declType, pre="const ")
101766:             selfRef = "const_cast<%s&>(%s)" % (typeName, selfRef)
101766: 
106942:         # We do manual default value handling here, because we
106942:         # actually do want a jsval, and we only handle null anyway
106942:         if defaultValue is not None:
106942:             assert(isinstance(defaultValue, IDLNullValue))
106942:             val = "(${haveValue}) ? ${val} : JSVAL_NULL"
106942:         else:
106942:             val = "${val}"
106942: 
121479:         template = ("if (!%s.Init(cx, ${obj}, %s)) {\n"
121475:                     "%s\n"
121475:                     "}" % (selfRef, val, exceptionCodeIndented.define()))
105570: 
105570:         return (template, declType, None, False)
101766: 
121476:     if type.isVoid():
121476:         assert not isOptional
121476:         # This one only happens for return values, and its easy: Just
121476:         # ignore the jsval.
121476:         return ("", None, None, False)
121476: 
 94512:     if not type.isPrimitive():
109136:         raise TypeError("Need conversion for argument type '%s'" % str(type))
 94512: 
 98551:     typeName = builtinNames[type.tag()]
111250: 
111250:     conversionBehavior = "eDefault"
111250:     if isEnforceRange:
111250:         conversionBehavior = "eEnforceRange"
111250:     elif isClamp:
111250:         conversionBehavior = "eClamp"
111250: 
 94512:     if type.nullable():
119237:         declType = CGGeneric("Nullable<" + typeName + ">")
119237:         mutableType = declType.define() + "&"
119237:         if not isOptional and not isMember:
119237:             declType = CGWrapper(declType, pre="const ")
119237:         dataLoc = ("const_cast< %s >(${declName}).SetValue()" % mutableType)
106942:         nullCondition = "${val}.isNullOrUndefined()"
106942:         if defaultValue is not None and isinstance(defaultValue, IDLNullValue):
106942:             nullCondition = "!(${haveValue}) || " + nullCondition
106942:         template = (
106942:             "if (%s) {\n"
119237:             "  const_cast< %s >(${declName}).SetNull();\n"
111250:             "} else if (!ValueToPrimitive<%s, %s>(cx, ${val}, &%s)) {\n"
121475:             "%s\n"
121475:             "}" % (nullCondition, mutableType, typeName, conversionBehavior, dataLoc,
121475:                    exceptionCodeIndented.define()))
 94512:     else:
106942:         assert(defaultValue is None or
106942:                not isinstance(defaultValue, IDLNullValue))
106942:         dataLoc = "${declName}"
106942:         template = (
111250:             "if (!ValueToPrimitive<%s, %s>(cx, ${val}, &%s)) {\n"
121475:             "%s\n"
121475:             "}" % (typeName, conversionBehavior, dataLoc,
121475:                    exceptionCodeIndented.define()))
106942:         declType = CGGeneric(typeName)
106942:     if (defaultValue is not None and
106942:         # We already handled IDLNullValue, so just deal with the other ones
106942:         not isinstance(defaultValue, IDLNullValue)):
106942:         tag = defaultValue.type.tag()
106942:         if tag in numericTags:
106942:             defaultStr = defaultValue.value
106942:         else:
106942:             assert(tag == IDLType.Tags.bool)
106942:             defaultStr = toStringBool(defaultValue.value)
106942:         template = CGWrapper(CGIndenter(CGGeneric(template)),
106942:                              pre="if (${haveValue}) {\n",
106942:                              post=("\n"
106942:                                    "} else {\n"
106942:                                    "  %s = %s;\n"
106942:                                    "}" % (dataLoc, defaultStr))).define()
106942: 
106942:     return (template, declType, None, isOptional)
 99738: 
 99738: def instantiateJSToNativeConversionTemplate(templateTuple, replacements,
 99738:                                             argcAndIndex=None):
 98551:     """
 98551:     Take a tuple as returned by getJSToNativeConversionTemplate and a set of
 98551:     replacements as required by the strings in such a tuple, and generate code
 98551:     to convert into stack C++ types.
 99738: 
 99738:     If argcAndIndex is not None it must be a dict that can be used to
 99738:     replace ${argc} and ${index}, where ${index} is the index of this
 99738:     argument (0-based) and ${argc} is the total number of arguments.
 98551:     """
 99738:     (templateBody, declType, holderType, dealWithOptional) = templateTuple
 99738: 
 99738:     if dealWithOptional and argcAndIndex is None:
 99738:         raise TypeError("Have to deal with optional things, but don't know how")
 99738:     if argcAndIndex is not None and declType is None:
 99738:         raise TypeError("Need to predeclare optional things, so they will be "
 99738:                         "outside the check for big enough arg count!");
 99738: 
 98551:     result = CGList([], "\n")
 99738:     # Make a copy of "replacements" since we may be about to start modifying it
 99738:     replacements = dict(replacements)
 99738:     originalHolderName = replacements["holderName"]
 98551:     if holderType is not None:
 99738:         if dealWithOptional:
 99738:             replacements["holderName"] = (
 99738:                 "const_cast< %s & >(%s.Value())" %
 99738:                 (holderType.define(), originalHolderName))
 99738:             mutableHolderType = CGWrapper(holderType, pre="Optional< ", post=" >")
 99738:             holderType = CGWrapper(mutableHolderType, pre="const ")
 98551:         result.append(
 98551:             CGList([holderType, CGGeneric(" "),
 99738:                     CGGeneric(originalHolderName),
 98551:                     CGGeneric(";")]))
 99738: 
 99738:     originalDeclName = replacements["declName"]
 98551:     if declType is not None:
 99738:         if dealWithOptional:
 99738:             replacements["declName"] = (
 99738:                 "const_cast< %s & >(%s.Value())" %
 99738:                 (declType.define(), originalDeclName))
 99738:             mutableDeclType = CGWrapper(declType, pre="Optional< ", post=" >")
 99738:             declType = CGWrapper(mutableDeclType, pre="const ")
 98551:         result.append(
 98551:             CGList([declType, CGGeneric(" "),
 99738:                     CGGeneric(originalDeclName),
 98551:                     CGGeneric(";")]))
 99738: 
 99738:     conversion = CGGeneric(
 98551:             string.Template(templateBody).substitute(replacements)
 99738:             )
 99738: 
 99738:     if argcAndIndex is not None:
 99738:         if dealWithOptional:
 99738:             declConstruct = CGIndenter(
 99738:                 CGGeneric("const_cast< %s &>(%s).Construct();" %
 99738:                           (mutableDeclType.define(), originalDeclName)))
 99738:             if holderType is not None:
 99738:                 holderConstruct = CGIndenter(
 99738:                     CGGeneric("const_cast< %s &>(%s).Construct();" %
 99738:                               (mutableHolderType.define(), originalHolderName)))
 99738:             else:
 99738:                 holderConstruct = None
 99738:         else:
 99738:             declConstruct = None
 99738:             holderConstruct = None
 99738: 
 99738:         conversion = CGList(
 99738:             [CGGeneric(
 99738:                     string.Template("if (${index} < ${argc}) {").substitute(
 99738:                         argcAndIndex
 99738:                         )),
 99738:              declConstruct,
 99738:              holderConstruct,
 99738:              CGIndenter(conversion),
 99738:              CGGeneric("}")],
 99738:             "\n")
 99738: 
 99738:     result.append(conversion)
 98551:     # Add an empty CGGeneric to get an extra newline after the argument
 98551:     # conversion.
 98551:     result.append(CGGeneric(""))
 98551:     return result;
 94512: 
 94512: def convertConstIDLValueToJSVal(value):
 94512:     if isinstance(value, IDLNullValue):
 94512:         return "JSVAL_NULL"
 94512:     tag = value.type.tag()
 94512:     if tag in [IDLType.Tags.int8, IDLType.Tags.uint8, IDLType.Tags.int16,
 94512:                IDLType.Tags.uint16, IDLType.Tags.int32]:
 94512:         return "INT_TO_JSVAL(%s)" % (value.value)
 94512:     if tag == IDLType.Tags.uint32:
 94512:         return "UINT_TO_JSVAL(%s)" % (value.value)
 94512:     if tag in [IDLType.Tags.int64, IDLType.Tags.uint64]:
 94512:         return "DOUBLE_TO_JSVAL(%s)" % (value.value)
 94512:     if tag == IDLType.Tags.bool:
 94512:         return "JSVAL_TRUE" if value.value else "JSVAL_FALSE"
 94512:     if tag in [IDLType.Tags.float, IDLType.Tags.double]:
 94512:         return "DOUBLE_TO_JSVAL(%s)" % (value.value)
 94512:     raise TypeError("Const value of unhandled type: " + value.type)
 94512: 
 94512: class CGArgumentConverter(CGThing):
 94512:     """
 94512:     A class that takes an IDL argument object, its index in the
 94512:     argument list, and the argv and argc strings and generates code to
 94512:     unwrap the argument to the right native type.
 94512:     """
102418:     def __init__(self, argument, index, argv, argc, descriptorProvider,
102418:                  invalidEnumValueFatal=True):
 94512:         CGThing.__init__(self)
 94512:         self.argument = argument
106691:         if argument.variadic:
106691:             raise TypeError("We don't support variadic arguments yet " +
106691:                             str(argument.location))
106942:         assert(not argument.defaultValue or argument.optional)
106942: 
 98551:         replacer = {
 94512:             "index" : index,
 94512:             "argc" : argc,
 99739:             "argv" : argv
 98551:             }
 98551:         self.replacementVariables = {
 98551:             "declName" : "arg%d" % index,
121479:             "holderName" : ("arg%d" % index) + "_holder",
121479:             "obj" : "obj"
 94512:             }
 98551:         self.replacementVariables["val"] = string.Template(
 94512:             "${argv}[${index}]"
 98551:             ).substitute(replacer)
 98551:         self.replacementVariables["valPtr"] = (
 98551:             "&" + self.replacementVariables["val"])
106942:         if argument.defaultValue:
106942:             self.replacementVariables["haveValue"] = string.Template(
106942:                 "${index} < ${argc}").substitute(replacer)
 98552:         self.descriptorProvider = descriptorProvider
 99738:         if self.argument.optional and not self.argument.defaultValue:
 99738:             self.argcAndIndex = replacer
 99738:         else:
 99738:             self.argcAndIndex = None
102418:         self.invalidEnumValueFatal = invalidEnumValueFatal
 94512: 
 94512:     def define(self):
 98551:         return instantiateJSToNativeConversionTemplate(
 98551:             getJSToNativeConversionTemplate(self.argument.type,
 99738:                                             self.descriptorProvider,
102418:                                             isOptional=(self.argcAndIndex is not None),
106942:                                             invalidEnumValueFatal=self.invalidEnumValueFatal,
109260:                                             defaultValue=self.argument.defaultValue,
109260:                                             treatNullAs=self.argument.treatNullAs,
111250:                                             treatUndefinedAs=self.argument.treatUndefinedAs,
111250:                                             isEnforceRange=self.argument.enforceRange,
111250:                                             isClamp=self.argument.clamp),
 99738:             self.replacementVariables,
 99738:             self.argcAndIndex).define()
 94512: 
102142: def getWrapTemplateForType(type, descriptorProvider, result, successCode,
121477:                            isCreator, exceptionCode):
 98229:     """
 98229:     Reflect a C++ value stored in "result", of IDL type "type" into JS.  The
 98229:     "successCode" is the code to run once we have successfully done the
 98229:     conversion.  The resulting string should be used with string.Template, it
 98229:     needs the following keys when substituting: jsvalPtr/jsvalRef/obj.
107785: 
107785:     Returns (templateString, infallibility of conversion template)
 98229:     """
121477:     if successCode is None:
 98229:         successCode = "return true;"
 98229: 
121477:     # We often want exceptionCode to be indented, since it often appears in an
121477:     # if body.
121477:     exceptionCodeIndented = CGIndenter(CGGeneric(exceptionCode))
121477: 
 98229:     def setValue(value, callWrapValue=False):
 98229:         """
 98229:         Returns the code to set the jsval to value. If "callWrapValue" is true
119691:         MaybeWrapValue will be called on the jsval.
 98229:         """
 98229:         if not callWrapValue:
 98229:             tail = successCode
121477:         else:
119691:             tail = ("if (!MaybeWrapValue(cx, ${obj}, ${jsvalPtr})) {\n" +
121477:                     ("%s\n" % exceptionCodeIndented.define()) +
 98229:                     "}\n" +
 98229:                     successCode)
 98229:         return ("${jsvalRef} = %s;\n" +
 98229:                 tail) % (value)
 98229: 
 98229:     def wrapAndSetPtr(wrapCall, failureCode=None):
 98229:         """
 98229:         Returns the code to set the jsval by calling "wrapCall". "failureCode"
 98229:         is the code to run if calling "wrapCall" fails 
 98229:         """
 98229:         if failureCode is None:
121477:             failureCode = exceptionCode
 98229:         str = ("if (!%s) {\n" +
 98229:                CGIndenter(CGGeneric(failureCode)).define() + "\n" +
 98229:                "}\n" +
 98229:                successCode) % (wrapCall)
 98229:         return str
 98229:     
 94512:     if type is None or type.isVoid():
107785:         return (setValue("JSVAL_VOID"), True)
 94512: 
 98553:     if type.isArray():
 98553:         raise TypeError("Can't handle array return values yet")
 98553: 
 98553:     if type.isSequence():
 98553:         if type.nullable():
 98553:             # Nullable sequences are Nullable< nsTArray<T> >
107785:             (recTemplate, recInfall) = getWrapTemplateForType(type.inner, descriptorProvider,
107785:                                                               "%s.Value()" % result, successCode,
121477:                                                               isCreator, exceptionCode)
107785:             return ("""
 98553: if (%s.IsNull()) {
 98553: %s
 98553: }
107785: %s""" % (result, CGIndenter(CGGeneric(setValue("JSVAL_NULL"))).define(), recTemplate), recInfall)
 98553: 
 98553:         # Now do non-nullable sequences.  We use setting the element
 98553:         # in the array as our succcess code because when we succeed in
 98553:         # wrapping that's what we should do.
 98553:         innerTemplate = wrapForType(
 98553:             type.inner, descriptorProvider,
 98553:             {
 98553:                 'result' :  "%s[i]" % result,
118540:                 'successCode': "break;",
 98553:                 'jsvalRef': "tmp",
102142:                 'jsvalPtr': "&tmp",
121477:                 'isCreator': isCreator,
121478:                 'exceptionCode': exceptionCode,
121478:                 'obj': "returnArray"
 98553:                 }
 98553:             )
119693:         innerTemplate = CGIndenter(CGGeneric(innerTemplate), 6).define()
107785:         return (("""
 98553: uint32_t length = %s.Length();
 98553: JSObject *returnArray = JS_NewArrayObject(cx, length, NULL);
 98553: if (!returnArray) {
121477: %s
 98553: }
119693: // Scope for 'tmp'
119693: {
 98553:   jsval tmp;
 98553:   for (uint32_t i = 0; i < length; ++i) {
118540:     // Control block to let us common up the JS_DefineElement calls when there
118540:     // are different ways to succeed at wrapping the object.
118540:     do {
 98553: %s
118540:     } while (0);
118540:     if (!JS_DefineElement(cx, returnArray, i, tmp,
118540:                           nullptr, nullptr, JSPROP_ENUMERATE)) {
121477: %s
118540:     }
119693:   }
121477: }\n""" % (result, exceptionCodeIndented.define(),
121477:           innerTemplate,
121477:           CGIndenter(exceptionCodeIndented, 4).define())) +
121477:                 setValue("JS::ObjectValue(*returnArray)"), False)
 94512: 
 99320:     if type.isGeckoInterface():
 94512:         descriptor = descriptorProvider.getDescriptor(type.unroll().inner.identifier.name)
 98229:         if type.nullable():
 98229:             wrappingCode = ("if (!%s) {\n" % (result) +
 98229:                             CGIndenter(CGGeneric(setValue("JSVAL_NULL"))).define() + "\n" +
 98229:                             "}\n")
 98229:         else:
 98229:             wrappingCode = ""
118540: 
118540:         if descriptor.interface.isCallback():
121478:             wrap = "WrapCallbackInterface(cx, ${obj}, %s, ${jsvalPtr})" % result
118540:             failed = None
120975:         elif not descriptor.interface.isExternal() and not descriptor.skipGen:
102142:             if descriptor.wrapperCache:
102142:                 wrapMethod = "WrapNewBindingObject"
102142:             else:
102142:                 if not isCreator:
102142:                     raise MethodNotCreatorError(descriptor.interface.identifier.name)
102142:                 wrapMethod = "WrapNewBindingNonWrapperCachedObject"
102142:             wrap = "%s(cx, ${obj}, %s, ${jsvalPtr})" % (wrapMethod, result)
 96980:             # We don't support prefable stuff in workers.
 96980:             assert(not descriptor.prefable or not descriptor.workers)
 96980:             if not descriptor.prefable:
 96980:                 # Non-prefable bindings can only fail to wrap as a new-binding object
 96980:                 # if they already threw an exception.  Same thing for
 96980:                 # non-prefable bindings.
 98229:                 failed = ("MOZ_ASSERT(JS_IsExceptionPending(cx));\n" +
121477:                           "%s" % exceptionCode)
 94512:             else:
105803:                 if descriptor.notflattened:
105803:                     raise TypeError("%s is prefable but not flattened; "
105803:                                     "fallback won't work correctly" %
105803:                                     descriptor.interface.identifier.name)
 96980:                 # Try old-style wrapping for bindings which might be preffed off.
 98229:                 failed = wrapAndSetPtr("HandleNewBindingWrappingFailure(cx, ${obj}, %s, ${jsvalPtr})" % result)
 94512:         else:
 94512:             if descriptor.notflattened:
 94512:                 getIID = "&NS_GET_IID(%s), " % descriptor.nativeType
 94512:             else:
 94512:                 getIID = ""
 98229:             wrap = "WrapObject(cx, ${obj}, %s, %s${jsvalPtr})" % (result, getIID)
118540:             failed = None
118540: 
118540:         wrappingCode += wrapAndSetPtr(wrap, failed)
107785:         return (wrappingCode, False)
 94512: 
 94512:     if type.isString():
 94512:         if type.nullable():
107785:             return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalPtr})" % result), False)
 94512:         else:
107785:             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalPtr})" % result), False)
 94512: 
 94512:     if type.isEnum():
 94512:         if type.nullable():
 94512:             raise TypeError("We don't support nullable enumerated return types "
 94512:                             "yet")
107785:         return ("""MOZ_ASSERT(uint32_t(%(result)s) < ArrayLength(%(strings)s));
 98229: JSString* %(resultStr)s = JS_NewStringCopyN(cx, %(strings)s[uint32_t(%(result)s)].value, %(strings)s[uint32_t(%(result)s)].length);
 98229: if (!%(resultStr)s) {
121477: %(exceptionCode)s
 94512: }
 98229: """ % { "result" : result,
 98229:         "resultStr" : result + "_str",
121477:         "strings" : type.inner.identifier.name + "Values::strings",
121477:         "exceptionCode" : exceptionCode } +
107785:         setValue("JS::StringValue(%s_str)" % result), False)
 94512: 
102577:     if type.isCallback():
102577:         assert not type.isInterface()
 94512:         # XXXbz we're going to assume that callback types are always
 94512:         # nullable and always have [TreatNonCallableAsNull] for now.
 96738:         # See comments in WrapNewBindingObject explaining why we need
 96738:         # to wrap here.
107785:         # NB: setValue(..., True) calls JS_WrapValue(), so is fallible
121491:         if descriptorProvider.workers:
107785:             return (setValue("JS::ObjectOrNullValue(%s)" % result, True), False)
 94512: 
121480:         wrapCode = (("if (%(result)s) {\n" +
121480:                      CGIndenter(CGGeneric(setValue(
121480:                             "JS::ObjectValue(*%(result)s->Callable())", True))).define() +
121480:                      "} else {\n" +
121480:                      setValue("JS::NullValue()") +
121480:                      "}") % { "result": result })
121480:         return wrapCode, False
121480: 
 94512:     if type.tag() == IDLType.Tags.any:
 96738:         # See comments in WrapNewBindingObject explaining why we need
 96738:         # to wrap here.
107785:         # NB: setValue(..., True) calls JS_WrapValue(), so is fallible
107785:         return (setValue(result, True), False)
 94512: 
110545:     if type.isObject() or type.isSpiderMonkeyInterface():
 99125:         # See comments in WrapNewBindingObject explaining why we need
 99125:         # to wrap here.
 99125:         if type.nullable():
 99125:             toValue = "JS::ObjectOrNullValue(%s)"
 99125:         else:
 99125:             toValue = "JS::ObjectValue(*%s)"
107785:         # NB: setValue(..., True) calls JS_WrapValue(), so is fallible
107785:         return (setValue(toValue % result, True), False)
 99125: 
119693:     if type.isDictionary():
119693:         assert not type.nullable()
121482:         return (wrapAndSetPtr("%s.ToObject(cx, ${obj}, ${jsvalPtr})" % result),
121482:                 False)
121482: 
121482:     if type.isUnion():
121482:         if type.nullable():
121482:             prefix = "%s->"
121482:         else:
121482:             prefix = "%s."
121482:         return (wrapAndSetPtr((prefix % result) +
121482:                               "ToJSVal(cx, ${obj}, ${jsvalPtr})"), False)
119693: 
 94512:     if not type.isPrimitive():
 94512:         raise TypeError("Need to learn to wrap %s" % type)
 94512: 
 94512:     if type.nullable():
107785:         (recTemplate, recInfal) = getWrapTemplateForType(type.inner, descriptorProvider,
107785:                                                          "%s.Value()" % result, successCode,
121477:                                                          isCreator, exceptionCode)
 98229:         return ("if (%s.IsNull()) {\n" % result +
 98229:                 CGIndenter(CGGeneric(setValue("JSVAL_NULL"))).define() + "\n" +
107785:                 "}\n" + recTemplate, recInfal)
 94512:     
 94512:     tag = type.tag()
 94512:     
 94512:     if tag in [IDLType.Tags.int8, IDLType.Tags.uint8, IDLType.Tags.int16,
 94512:                IDLType.Tags.uint16, IDLType.Tags.int32]:
107785:         return (setValue("INT_TO_JSVAL(int32_t(%s))" % result), True)
 94512: 
 94512:     elif tag in [IDLType.Tags.int64, IDLType.Tags.uint64, IDLType.Tags.float,
 94512:                  IDLType.Tags.double]:
 94512:         # XXXbz will cast to double do the "even significand" thing that webidl
 94512:         # calls for for 64-bit ints?  Do we care?
107785:         return (setValue("JS_NumberValue(double(%s))" % result), True)
 94512: 
 94512:     elif tag == IDLType.Tags.uint32:
107785:         return (setValue("UINT_TO_JSVAL(%s)" % result), True)
 94512: 
 94512:     elif tag == IDLType.Tags.bool:
107785:         return (setValue("BOOLEAN_TO_JSVAL(%s)" % result), True)
 94512: 
 94512:     else:
 94512:         raise TypeError("Need to learn to wrap primitive: %s" % type)
 94512: 
 98229: def wrapForType(type, descriptorProvider, templateValues):
 98229:     """
 98229:     Reflect a C++ value of IDL type "type" into JS.  TemplateValues is a dict
 98229:     that should contain:
 98229: 
 98229:       * 'jsvalRef': a C++ reference to the jsval in which to store the result of
 98229:                     the conversion
 98229:       * 'jsvalPtr': a C++ pointer to the jsval in which to store the result of
 98229:                     the conversion
 98229:       * 'obj' (optional): the name of the variable that contains the JSObject to
 98229:                           use as a scope when wrapping, if not supplied 'obj'
 98229:                           will be used as the name
 98229:       * 'result' (optional): the name of the variable in which the C++ value is
 98229:                              stored, if not supplied 'result' will be used as
 98229:                              the name
 98229:       * 'successCode' (optional): the code to run once we have successfully done
 98229:                                   the conversion, if not supplied 'return true;'
 98229:                                   will be used as the code
102142:       * 'isCreator' (optional): If true, we're wrapping for the return value of
102142:                                 a [Creator] method.  Assumed false if not set.
121477:       * 'exceptionCode' (optional): Code to run when a JS exception is thrown.
121477:                                     The default is "return false;".  The code
121477:                                     passed here must return.
 98229:     """
 98229:     wrap = getWrapTemplateForType(type, descriptorProvider,
 98229:                                   templateValues.get('result', 'result'),
102142:                                   templateValues.get('successCode', None),
121477:                                   templateValues.get('isCreator', False),
121477:                                   templateValues.get('exceptionCode',
121477:                                                      "return false;"))[0]
 98229: 
 98229:     defaultValues = {'obj': 'obj'}
 98229:     return string.Template(wrap).substitute(defaultValues, **templateValues)
 94512: 
111082: def infallibleForMember(member, type, descriptorProvider):
107785:     """
107785:     Determine the fallibility of changing a C++ value of IDL type "type" into
107785:     JS for the given attribute. Apart from isCreator, all the defaults are used,
107785:     since the fallbility does not change based on the boolean values,
107785:     and the template will be discarded.
107785: 
107785:     CURRENT ASSUMPTIONS:
107785:         We assume that successCode for wrapping up return values cannot contain
107785:         failure conditions.
107785:     """
111082:     return getWrapTemplateForType(type, descriptorProvider, 'result', None,\
121477:                                   memberIsCreator(member), "return false;")[1]
107785: 
121480: def typeNeedsCx(type, descriptorProvider, retVal=False):
114090:     if type is None:
114090:         return False
114572:     if type.nullable():
114572:         type = type.inner
114090:     if type.isSequence() or type.isArray():
114090:         type = type.inner
114090:     if type.isUnion():
121480:         return any(typeNeedsCx(t, descriptorProvider) for t in
121480:                    type.unroll().flatMemberTypes)
114572:     if retVal and type.isSpiderMonkeyInterface():
114572:         return True
121480:     if type.isCallback():
121491:         return descriptorProvider.workers
121480:     return type.isAny() or type.isObject()
100046: 
109136: # Returns a tuple consisting of a CGThing containing the type of the return
109136: # value, or None if there is no need for a return value, and a boolean signaling
109136: # whether the return value is passed in an out parameter.
119238: #
121474: # Whenever this is modified, please update CGNativeMember.getRetvalInfo as
119238: # needed
 98553: def getRetvalDeclarationForType(returnType, descriptorProvider,
 98553:                                 resultAlreadyAddRefed):
 94512:     if returnType is None or returnType.isVoid():
 94512:         # Nothing to declare
109136:         return None, False
 99125:     if returnType.isPrimitive() and returnType.tag() in builtinNames:
 94512:         result = CGGeneric(builtinNames[returnType.tag()])
 94512:         if returnType.nullable():
 94512:             result = CGWrapper(result, pre="Nullable<", post=">")
109136:         return result, False
 99125:     if returnType.isString():
109136:         return CGGeneric("nsString"), True
 99125:     if returnType.isEnum():
 94512:         if returnType.nullable():
 94512:             raise TypeError("We don't support nullable enum return values")
109136:         return CGGeneric(returnType.inner.identifier.name), False
 99320:     if returnType.isGeckoInterface():
 94512:         result = CGGeneric(descriptorProvider.getDescriptor(
 94512:             returnType.unroll().inner.identifier.name).nativeType)
 94512:         if resultAlreadyAddRefed:
 94512:             result = CGWrapper(result, pre="nsRefPtr<", post=">")
 94512:         else:
 94512:             result = CGWrapper(result, post="*")
109136:         return result, False
 99125:     if returnType.isCallback():
121480:         name = returnType.unroll().identifier.name
121491:         if descriptorProvider.workers:
109136:             return CGGeneric("JSObject*"), False
121480:         return CGGeneric("nsRefPtr<%s>" % name), False
114090:     if returnType.isAny():
109136:         return CGGeneric("JS::Value"), False
110545:     if returnType.isObject() or returnType.isSpiderMonkeyInterface():
109136:         return CGGeneric("JSObject*"), False
 99125:     if returnType.isSequence():
 98553:         nullable = returnType.nullable()
 98553:         if nullable:
 98553:             returnType = returnType.inner
 99323:         # If our result is already addrefed, use the right type in the
 99323:         # sequence argument here.
109136:         (result, _) = getRetvalDeclarationForType(returnType.inner,
 98553:                                                   descriptorProvider,
 99323:                                                   resultAlreadyAddRefed)
 99125:         result = CGWrapper(result, pre="nsTArray< ", post=" >")
 98553:         if nullable:
 98553:             result = CGWrapper(result, pre="Nullable< ", post=" >")
109136:         return result, True
119693:     if returnType.isDictionary():
119693:         assert not returnType.nullable()
119693:         result = CGGeneric(
119693:             CGDictionary.makeDictionaryName(returnType.unroll().inner,
119693:                                             descriptorProvider.workers) +
119693:             "Initializer")
119693:         return result, True
121482:     if returnType.isUnion():
121482:         raise TypeError("Need to sort out ownership model for union retvals");
 94512:     raise TypeError("Don't know how to declare return value for %s" %
 94512:                     returnType)
 99125: 
 99124: def isResultAlreadyAddRefed(descriptor, extendedAttributes):
 99124:     # Default to already_AddRefed on the main thread, raw pointer in workers
 99124:     return not descriptor.workers and not 'resultNotAddRefed' in extendedAttributes
 99124: 
121480: def needCx(returnType, arguments, extendedAttributes, descriptorProvider):
121480:     return (typeNeedsCx(returnType, descriptorProvider, True) or
121480:             any(typeNeedsCx(a.type, descriptorProvider) for (a, _) in arguments) or
119238:             'implicitJSContext' in extendedAttributes)
119238: 
 98553: class CGCallGenerator(CGThing):
 98553:     """
 98553:     A class to generate an actual call to a C++ object.  Assumes that the C++
109136:     object is stored in a variable whose name is given by the |object| argument.
111161: 
111161:     errorReport should be a CGThing for an error report or None if no
111161:     error reporting is needed.
 98553:     """
 99125:     def __init__(self, errorReport, arguments, argsPre, returnType,
109136:                  extendedAttributes, descriptorProvider, nativeMethodName,
119693:                  static, object="self"):
 98553:         CGThing.__init__(self)
 98553: 
111161:         assert errorReport is None or isinstance(errorReport, CGThing)
111161: 
 98553:         isFallible = errorReport is not None
 98553: 
109136:         resultAlreadyAddRefed = isResultAlreadyAddRefed(descriptorProvider,
109136:                                                         extendedAttributes)
109136:         (result, resultOutParam) = getRetvalDeclarationForType(returnType,
109136:                                                                descriptorProvider,
109136:                                                                resultAlreadyAddRefed)
109136: 
 99125:         args = CGList([CGGeneric(arg) for arg in argsPre], ", ")
109136:         for (a, name) in arguments:
 99125:             # This is a workaround for a bug in Apple's clang.
 99738:             if a.type.isObject() and not a.type.nullable() and not a.optional:
109136:                 name = "(JSObject&)" + name
109136:             args.append(CGGeneric(name))
109136: 
 98553:         # Return values that go in outparams go here
 98553:         if resultOutParam:
 98553:             args.append(CGGeneric("result"))
 98553:         if isFallible:
 98553:             args.append(CGGeneric("rv"))
 98553: 
121480:         needsCx = needCx(returnType, arguments, extendedAttributes,
121480:                          descriptorProvider)
100046: 
100046:         if not "cx" in argsPre and needsCx:
 99125:             args.prepend(CGGeneric("cx"))
 99124: 
 94512:         # Build up our actual call
 94512:         self.cgRoot = CGList([], "\n")
 94512: 
 94512:         call = CGGeneric(nativeMethodName)
 94512:         if static:
109136:             call = CGWrapper(call, pre="%s::" % descriptorProvider.nativeType)
 94512:         else: 
109136:             call = CGWrapper(call, pre="%s->" % object)
 99125:         call = CGList([call, CGWrapper(args, pre="(", post=");")])
 94512:         if result is not None:
 94512:             result = CGWrapper(result, post=" result;")
 94512:             self.cgRoot.prepend(result)
 94512:             if not resultOutParam:
 94512:                 call = CGWrapper(call, pre="result = ")
 94512: 
 94512:         call = CGWrapper(call)
 94512:         self.cgRoot.append(call)
 94512: 
 94512:         if isFallible:
 97819:             self.cgRoot.prepend(CGGeneric("ErrorResult rv;"))
 97819:             self.cgRoot.append(CGGeneric("if (rv.Failed()) {"))
109136:             self.cgRoot.append(CGIndenter(errorReport))
 94512:             self.cgRoot.append(CGGeneric("}"))
 94512: 
 94512:     def define(self):
 94512:         return self.cgRoot.define()
 94512: 
102142: class MethodNotCreatorError(Exception):
102142:     def __init__(self, typename):
102142:         self.typename = typename
102142: 
 94512: class CGPerSignatureCall(CGThing):
 94512:     """
 94512:     This class handles the guts of generating code for a particular
 94512:     call signature.  A call signature consists of four things:
 94512: 
 94512:     1) A return type, which can be None to indicate that there is no
 94512:        actual return value (e.g. this is an attribute setter) or an
 94512:        IDLType if there's an IDL type involved (including |void|).
 94512:     2) An argument list, which is allowed to be empty.
 94512:     3) A name of a native method to call.
 94512:     4) Whether or not this method is static.
 94512: 
 94512:     We also need to know whether this is a method or a getter/setter
 94512:     to do error reporting correctly.
 94512: 
 94512:     The idlNode parameter can be either a method or an attr. We can query
 94512:     |idlNode.identifier| in both cases, so we can be agnostic between the two.
 94512:     """
 94512:     # XXXbz For now each entry in the argument list is either an
 94512:     # IDLArgument or a FakeArgument, but longer-term we may want to
 94512:     # have ways of flagging things like JSContext* or optional_argc in
 94512:     # there.
 94512: 
 94512:     def __init__(self, returnType, argsPre, arguments, nativeMethodName, static,
 99124:                  descriptor, idlNode, argConversionStartsAt=0,
 99124:                  getter=False, setter=False):
 94512:         CGThing.__init__(self)
 94512:         self.returnType = returnType
 94512:         self.descriptor = descriptor
 94512:         self.idlNode = idlNode
 99124:         self.extendedAttributes = descriptor.getExtendedAttributes(idlNode,
 99124:                                                                    getter=getter,
 99124:                                                                    setter=setter)
 99124:         self.argsPre = argsPre
 99125:         self.arguments = arguments
 94512:         self.argCount = len(arguments)
 94512:         if self.argCount > argConversionStartsAt:
 94512:             # Insert our argv in there
 94512:             cgThings = [CGGeneric(self.getArgvDecl())]
 94512:         else:
 94512:             cgThings = []
 94512:         cgThings.extend([CGArgumentConverter(arguments[i], i, self.getArgv(),
102418:                                              self.getArgc(), self.descriptor,
102418:                                              invalidEnumValueFatal=not setter) for
 94512:                          i in range(argConversionStartsAt, self.argCount)])
 94512: 
 94512:         cgThings.append(CGCallGenerator(
 94512:                     self.getErrorReport() if self.isFallible() else None,
109136:                     self.getArguments(), self.argsPre, returnType,
 99124:                     self.extendedAttributes, descriptor, nativeMethodName,
 94512:                     static))
 94512:         self.cgRoot = CGList(cgThings, "\n")
 94512: 
 94512:     def getArgv(self):
 94512:         return "argv" if self.argCount > 0 else ""
 94512:     def getArgvDecl(self):
 94512:         return "\nJS::Value* argv = JS_ARGV(cx, vp);\n"
 94512:     def getArgc(self):
 94512:         return "argc"
109136:     def getArguments(self):
109136:         return [(a, "arg" + str(i)) for (i, a) in enumerate(self.arguments)]
 94512: 
 94512:     def isFallible(self):
 94512:         return not 'infallible' in self.extendedAttributes
 94512: 
 94512:     def wrap_return_value(self):
107785:         isCreator = memberIsCreator(self.idlNode)
102142:         if isCreator:
102142:             # We better be returning addrefed things!
111162:             assert(isResultAlreadyAddRefed(self.descriptor,
111162:                                            self.extendedAttributes) or
111162:                    # Workers use raw pointers for new-object return
111162:                    # values or something
111162:                    self.descriptor.workers)
102142: 
102142:         resultTemplateValues = { 'jsvalRef': '*vp', 'jsvalPtr': 'vp',
102142:                                  'isCreator': isCreator}
102142:         try:
 98229:             return wrapForType(self.returnType, self.descriptor,
 98229:                                resultTemplateValues)
102142:         except MethodNotCreatorError, err:
102142:             assert not isCreator
102142:             raise TypeError("%s being returned from non-creator method or property %s.%s" %
102142:                             (err.typename,
102142:                              self.descriptor.interface.identifier.name,
102142:                              self.idlNode.identifier.name))
 94512: 
 94512:     def getErrorReport(self):
109136:         return CGGeneric('return ThrowMethodFailedWithDetails<%s>(cx, rv, "%s", "%s");'
 94512:                          % (toStringBool(not self.descriptor.workers),
 94512:                             self.descriptor.interface.identifier.name,
109136:                             self.idlNode.identifier.name))
 94512: 
 94512:     def define(self):
 98229:         return (self.cgRoot.define() + "\n" + self.wrap_return_value())
 94512: 
 94512: class CGSwitch(CGList):
 94512:     """
 94512:     A class to generate code for a switch statement.
 94512: 
 94512:     Takes three constructor arguments: an expression, a list of cases,
 94512:     and an optional default.
 94512: 
 94512:     Each case is a CGCase.  The default is a CGThing for the body of
 94512:     the default case, if any.
 94512:     """
 94512:     def __init__(self, expression, cases, default=None):
 94512:         CGList.__init__(self, [CGIndenter(c) for c in cases], "\n")
 94512:         self.prepend(CGWrapper(CGGeneric(expression),
 94512:                                pre="switch (", post=") {"));
 94512:         if default is not None:
 94512:             self.append(
 94512:                 CGIndenter(
 94512:                     CGWrapper(
 94512:                         CGIndenter(default),
 94512:                         pre="default: {\n",
 94512:                         post="\n  break;\n}"
 94512:                         )
 94512:                     )
 94512:                 )
 94512:                         
 94512:         self.append(CGGeneric("}"))
 94512: 
 94512: class CGCase(CGList):
 94512:     """
 94512:     A class to generate code for a case statement.
 94512: 
 94512:     Takes three constructor arguments: an expression, a CGThing for
 94512:     the body (allowed to be None if there is no body), and an optional
 94512:     argument (defaulting to False) for whether to fall through.
 94512:     """
 94512:     def __init__(self, expression, body, fallThrough=False):
 94512:         CGList.__init__(self, [], "\n")
 94512:         self.append(CGWrapper(CGGeneric(expression), pre="case ", post=": {"))
 96737:         bodyList = CGList([body], "\n")
 94512:         if fallThrough:
 96737:             bodyList.append(CGGeneric("/* Fall through */"))
 94512:         else:
 96737:             bodyList.append(CGGeneric("break;"))
 96737:         self.append(CGIndenter(bodyList));
 94512:         self.append(CGGeneric("}"))
 94512: 
 94512: class CGMethodCall(CGThing):
 94512:     """
 94512:     A class to generate selection of a method signature from a set of
 94512:     signatures and generation of a call to that signature.
 94512:     """
 99124:     def __init__(self, argsPre, nativeMethodName, static, descriptor, method):
 94512:         CGThing.__init__(self)
 94512: 
105520:         methodName = '"%s.%s"' % (descriptor.interface.identifier.name, method.identifier.name)
105520: 
 94512:         def requiredArgCount(signature):
 94512:             arguments = signature[1]
 94512:             if len(arguments) == 0:
 94512:                 return 0
 94512:             requiredArgs = len(arguments)
 94512:             while requiredArgs and arguments[requiredArgs-1].optional:
 94512:                 requiredArgs -= 1
 94512:             return requiredArgs
 94512: 
 94512:         def getPerSignatureCall(signature, argConversionStartsAt=0):
 94512:             return CGPerSignatureCall(signature[0], argsPre, signature[1],
 94512:                                       nativeMethodName, static, descriptor,
 99124:                                       method, argConversionStartsAt)
 94512:             
 94512: 
 94512:         signatures = method.signatures()
 94512:         if len(signatures) == 1:
 94512:             # Special case: we can just do a per-signature method call
 94512:             # here for our one signature and not worry about switching
 94512:             # on anything.
 94512:             signature = signatures[0]
 94512:             self.cgRoot = CGList([ CGIndenter(getPerSignatureCall(signature)) ])
 94512:             requiredArgs = requiredArgCount(signature)
105520: 
105520: 
 94512:             if requiredArgs > 0:
105520:                 code = (
105520:                     "if (argc < %d) {\n"
105520:                     "  return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, %s);\n"
105520:                     "}" % (requiredArgs, methodName))
 94512:                 self.cgRoot.prepend(
105520:                     CGWrapper(CGIndenter(CGGeneric(code)), pre="\n", post="\n"))
 94512:             return
 94512: 
 94512:         # Need to find the right overload
102736:         maxArgCount = method.maxArgCount
102736:         allowedArgCounts = method.allowedArgCounts
 94512: 
 94512:         argCountCases = []
 94512:         for argCount in allowedArgCounts:
102736:             possibleSignatures = method.signaturesForArgCount(argCount)
 94512:             if len(possibleSignatures) == 1:
 94512:                 # easy case!
 94512:                 signature = possibleSignatures[0]
 94512: 
 94512:                 # (possibly) important optimization: if signature[1] has >
 94512:                 # argCount arguments and signature[1][argCount] is optional and
 94512:                 # there is only one signature for argCount+1, then the
 94512:                 # signature for argCount+1 is just ourselves and we can fall
 94512:                 # through.
 94512:                 if (len(signature[1]) > argCount and
 94512:                     signature[1][argCount].optional and
 94512:                     (argCount+1) in allowedArgCounts and
102736:                     len(method.signaturesForArgCount(argCount+1)) == 1):
 94512:                     argCountCases.append(
 94512:                         CGCase(str(argCount), None, True))
 94512:                 else:
 94512:                     argCountCases.append(
 94512:                         CGCase(str(argCount), getPerSignatureCall(signature)))
 94512:                 continue
 94512: 
102736:             distinguishingIndex = method.distinguishingIndexForArgCount(argCount)
 94512: 
120965:             for (_, args) in possibleSignatures:
120965:                 # We should not have "any" args at distinguishingIndex,
120965:                 # since we have multiple possible signatures remaining,
120965:                 # but "any" is never distinguishable from anything else.
120965:                 assert not args[distinguishingIndex].type.isAny()
105570:                 # We can't handle unions at the distinguishing index.
105570:                 if args[distinguishingIndex].type.isUnion():
105570:                     raise TypeError("No support for unions as distinguishing "
105570:                                     "arguments yet: %s",
105570:                                     args[distinguishingIndex].location)
105570: 
 94512:             # Convert all our arguments up to the distinguishing index.
 94512:             # Doesn't matter which of the possible signatures we use, since
 94512:             # they all have the same types up to that point; just use
 94512:             # possibleSignatures[0]
 94512:             caseBody = [CGGeneric("JS::Value* argv_start = JS_ARGV(cx, vp);")]
 94512:             caseBody.extend([ CGArgumentConverter(possibleSignatures[0][1][i],
 94512:                                                   i, "argv_start", "argc",
 94512:                                                   descriptor) for i in
 94512:                               range(0, distinguishingIndex) ])
 94512: 
 94512:             # Select the right overload from our set.
 94512:             distinguishingArg = "argv_start[%d]" % distinguishingIndex
 94512: 
 94512:             def pickFirstSignature(condition, filterLambda):
 94512:                 sigs = filter(filterLambda, possibleSignatures)
 94512:                 assert len(sigs) < 2
 94512:                 if len(sigs) > 0:
 94512:                     if condition is None:
 94512:                         caseBody.append(
 94512:                             getPerSignatureCall(sigs[0], distinguishingIndex))
 94512:                     else:
 94512:                         caseBody.append(CGGeneric("if (" + condition + ") {"))
 94512:                         caseBody.append(CGIndenter(
 94512:                                 getPerSignatureCall(sigs[0], distinguishingIndex)))
 94512:                         caseBody.append(CGGeneric("}"))
 94512:                     return True
 94512:                 return False
 94512: 
120965:             def distinguishingType(signature):
120965:                 return signature[1][distinguishingIndex].type
120965: 
120966:             def tryCall(signature, indent, isDefinitelyObject=False,
120966:                         isNullOrUndefined=False):
120966:                 assert not isDefinitelyObject or not isNullOrUndefined
120966:                 assert isDefinitelyObject or isNullOrUndefined
120966:                 if isDefinitelyObject:
120966:                     failureCode = "break;"
120966:                 else:
120966:                     failureCode = None
120966:                 type = distinguishingType(signature)
120966:                 # The argument at index distinguishingIndex can't possibly
120966:                 # be unset here, because we've already checked that argc is
120966:                 # large enough that we can examine this argument.
120966:                 testCode = instantiateJSToNativeConversionTemplate(
120966:                     getJSToNativeConversionTemplate(type, descriptor,
120966:                                                     failureCode=failureCode,
120966:                                                     isDefinitelyObject=isDefinitelyObject,
120966:                                                     isNullOrUndefined=isNullOrUndefined),
120966:                     {
120966:                         "declName" : "arg%d" % distinguishingIndex,
120966:                         "holderName" : ("arg%d" % distinguishingIndex) + "_holder",
121479:                         "val" : distinguishingArg,
121479:                         "obj" : "obj"
120966:                         })
120966:                 caseBody.append(CGIndenter(testCode, indent));
120966:                 # If we got this far, we know we unwrapped to the right
120966:                 # C++ type, so just do the call.  Start conversion with
120966:                 # distinguishingIndex + 1, since we already converted
120966:                 # distinguishingIndex.
120966:                 caseBody.append(CGIndenter(
120966:                         getPerSignatureCall(signature, distinguishingIndex + 1),
120966:                         indent))
120966: 
120965:             # First check for null or undefined.  That means looking for
120965:             # nullable arguments at the distinguishing index and outputting a
120965:             # separate branch for them.  But if the nullable argument is a
120965:             # primitive, string, or enum, we don't need to do that.  The reason
120965:             # for that is that at most one argument at the distinguishing index
120965:             # is nullable (since two nullable arguments are not
120965:             # distinguishable), and all the argument types other than
120965:             # primitive/string/enum end up inside isObject() checks.  So if our
120965:             # nullable is a primitive/string/enum it's safe to not output the
120965:             # extra branch: we'll fall through to conversion for those types,
120965:             # which correctly handles null as needed, because isObject() will be
120965:             # false for null and undefined.
120966:             nullOrUndefSigs = [s for s in possibleSignatures
120966:                                if ((distinguishingType(s).nullable() and not
120965:                                     distinguishingType(s).isString() and not
120965:                                     distinguishingType(s).isEnum() and not
120965:                                    distinguishingType(s).isPrimitive()) or
120966:                                    distinguishingType(s).isDictionary())]
120966:             # Can't have multiple nullable types here
120966:             assert len(nullOrUndefSigs) < 2
120966:             if len(nullOrUndefSigs) > 0:
120966:                 caseBody.append(CGGeneric("if (%s.isNullOrUndefined()) {" %
120966:                                           distinguishingArg))
120966:                 tryCall(nullOrUndefSigs[0], 2, isNullOrUndefined=True)
120966:                 caseBody.append(CGGeneric("}"))
120965: 
120965:             # Now check for distinguishingArg being various kinds of objects.
120965:             # The spec says to check for the following things in order:
120965:             # 1)  A platform object that's not a platform array object, being
120965:             #     passed to an interface or "object" arg.
120965:             # 2)  A platform array object or Array or platform object with
120965:             #     indexed properties being passed to an array or sequence or
120965:             #     "object" arg.
120965:             # 3)  A Date object being passed to a Date or "object" arg
120965:             # 4)  Some other kind of object being passed to a callback
120965:             #     interface, callback function, dictionary, or "object" arg.
120965:             #
120965:             # Unfortunately, we cannot push the "some other kind of object"
120965:             # check down into case 4, because dictionaries _can_ normally be
120965:             # initialized from platform objects. But we can coalesce the other
120965:             # three cases together, as long as we make sure to check whether our
120965:             # object works as an interface argument before checking whether it
120965:             # works as an arraylike.
120965: 
120965:             # First grab all the overloads that have a non-callback interface
120965:             # (which includes typed arrays and arraybuffers) at the
120965:             # distinguishing index.  We can also include the ones that have an
120965:             # "object" here, since if those are present no other object-typed
120965:             # argument will be.
120965:             objectSigs = [
 94512:                 s for s in possibleSignatures
120965:                 if (distinguishingType(s).isObject() or
120965:                     distinguishingType(s).isNonCallbackInterface()) ]
120965: 
120965:             # Now append all the overloads that take an array or sequence:
120965:             objectSigs.extend(s for s in possibleSignatures
120965:                               if (distinguishingType(s).isArray() or
120965:                                   distinguishingType(s).isSequence()))
120965: 
120965:             # And all the overloads that take Date
120965:             objectSigs.extend(s for s in possibleSignatures
120965:                               if distinguishingType(s).isDate())
120965: 
120965:             # There might be more than one thing in objectSigs; we need to check
 94512:             # which ones we unwrap to.
120965:             if len(objectSigs) > 0:
120965:                 # Here it's enough to guard on our argument being an object. The
120965:                 # code for unwrapping non-callback interfaces, typed arrays,
120965:                 # sequences, arrays, and Dates will just bail out and move on to
120965:                 # the next overload if the object fails to unwrap correctly,
120965:                 # while "object" accepts any object anyway.  We could even not
120965:                 # do the isObject() check up front here, but in cases where we
120965:                 # have multiple object overloads it makes sense to do it only
120965:                 # once instead of for each overload.  That will also allow the
120965:                 # unwrapping test to skip having to do codegen for the
120965:                 # null-or-undefined case, which we already handled above.
 99320:                 caseBody.append(CGGeneric("if (%s.isObject()) {" %
120966:                                           distinguishingArg))
120965:                 for sig in objectSigs:
 94512:                     caseBody.append(CGIndenter(CGGeneric("do {")));
120966:                     # Indent by 4, since we need to indent further
120966:                     # than our "do" statement
120966:                     tryCall(sig, 4, isDefinitelyObject=True)
 94512:                     caseBody.append(CGIndenter(CGGeneric("} while (0);")))
 94512: 
 94512:                 caseBody.append(CGGeneric("}"))
 94512: 
 94512:             # Check for vanilla JS objects
 94512:             # XXXbz Do we need to worry about security wrappers?
 94512:             pickFirstSignature("%s.isObject() && !IsPlatformObject(cx, &%s.toObject())" %
 94512:                                (distinguishingArg, distinguishingArg),
120965:                                lambda s: (distinguishingType(s).isCallback() or
120965:                                           distinguishingType(s).isCallbackInterface() or
120965:                                           distinguishingType(s).isDictionary()))
 94512: 
 94512:             # The remaining cases are mutually exclusive.  The
 94512:             # pickFirstSignature calls are what change caseBody
 94512:             # Check for strings or enums
 94512:             if pickFirstSignature(None,
120965:                                   lambda s: (distinguishingType(s).isString() or
120965:                                              distinguishingType(s).isEnum())):
 94512:                 pass
 94512:             # Check for primitives
 94512:             elif pickFirstSignature(None,
120965:                                     lambda s: distinguishingType(s).isPrimitive()):
 94512:                 pass
 94512:             else:
 94512:                 # Just throw; we have no idea what we're supposed to
 94512:                 # do with this.
119071:                 caseBody.append(CGGeneric(
119071:                   'return ThrowErrorMessage(cx, MSG_INVALID_ARG, "%s", "%s");'
119071:                   % (str(distinguishingIndex), str(argCount))))
 94512: 
 94512:             argCountCases.append(CGCase(str(argCount),
 94512:                                         CGList(caseBody, "\n")))
 94512: 
 94512:         overloadCGThings = []
 94512:         overloadCGThings.append(
 94512:             CGGeneric("unsigned argcount = NS_MIN(argc, %du);" %
102736:                       maxArgCount))
 94512:         overloadCGThings.append(
 94512:             CGSwitch("argcount",
 94512:                      argCountCases,
105520:                      CGGeneric("return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, %s);\n" % methodName)))
 94512:         overloadCGThings.append(
 94512:             CGGeneric('MOZ_NOT_REACHED("We have an always-returning default case");\n'
 94512:                       'return false;'))
 94512:         self.cgRoot = CGWrapper(CGIndenter(CGList(overloadCGThings, "\n")),
 94512:                                 pre="\n")
 94512: 
 94512:     def define(self):
 94512:         return self.cgRoot.define()
 94512: 
107790: class CGGetterCall(CGPerSignatureCall):
 94512:     """
 94512:     A class to generate a native object getter call for a particular IDL
 94512:     getter.
 94512:     """
 99124:     def __init__(self, returnType, nativeMethodName, descriptor, attr):
120397:         if attr.isStatic():
120397:             argsPre = [ "global" ]
120397:         else:
120397:             argsPre = []
120397:         CGPerSignatureCall.__init__(self, returnType, argsPre, [],
120397:                                     nativeMethodName, attr.isStatic(),
120397:                                     descriptor, attr, getter=True)
 94512: 
 94512: class FakeArgument():
110955:     """
110955:     A class that quacks like an IDLArgument.  This is used to make
110955:     setters look like method calls or for special operations.
110955:     """
121474:     def __init__(self, type, interfaceMember, name="arg"):
 94512:         self.type = type
 94512:         self.optional = False
106691:         self.variadic = False
106942:         self.defaultValue = None
110955:         self.treatNullAs = interfaceMember.treatNullAs
110955:         self.treatUndefinedAs = interfaceMember.treatUndefinedAs
111250:         self.enforceRange = False
111250:         self.clamp = False
119238:         class FakeIdentifier():
119238:             def __init__(self):
121474:                 self.name = name
119238:         self.identifier = FakeIdentifier()
 94512: 
107790: class CGSetterCall(CGPerSignatureCall):
 94512:     """
 94512:     A class to generate a native object setter call for a particular IDL
 94512:     setter.
 94512:     """
 99124:     def __init__(self, argType, nativeMethodName, descriptor, attr):
120397:         if attr.isStatic():
120397:             argsPre = [ "global" ]
120397:         else:
120397:             argsPre = []
120397:         CGPerSignatureCall.__init__(self, None, argsPre,
110955:                                     [FakeArgument(argType, attr)],
120397:                                     nativeMethodName, attr.isStatic(),
120397:                                     descriptor, attr, setter=True)
 94512:     def wrap_return_value(self):
 94512:         # We have no return value
 94512:         return "\nreturn true;"
 94512:     def getArgc(self):
 94512:         return "1"
 94512:     def getArgvDecl(self):
107784:         # We just get our stuff from our last arg no matter what
 94512:         return ""
 94512: 
105804: class FakeCastableDescriptor():
105804:     def __init__(self, descriptor):
105804:         self.castable = True
105804:         self.workers = descriptor.workers
105804:         self.nativeType = descriptor.nativeType
105804:         self.name = descriptor.name
110547:         self.hasXPConnectImpls = descriptor.hasXPConnectImpls
105804: 
 94512: class CGAbstractBindingMethod(CGAbstractStaticMethod):
 94512:     """
 94512:     Common class to generate the JSNatives for all our methods, getters, and
 94512:     setters.  This will generate the function declaration and unwrap the
 94512:     |this| object.  Subclasses are expected to override the generate_code
 94512:     function to do the rest of the work.  This function should return a
 94512:     CGThing which is already properly indented.
 94512:     """
113773:     def __init__(self, descriptor, name, args, unwrapFailureCode=None):
 94512:         CGAbstractStaticMethod.__init__(self, descriptor, name, "JSBool", args)
 94512: 
113773:         if unwrapFailureCode is None:
119071:             self.unwrapFailureCode = 'return ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "%s");' % self.descriptor.name
113773:         else:
113773:             self.unwrapFailureCode = unwrapFailureCode
113773: 
 94512:     def definition_body(self):
105804:         # Our descriptor might claim that we're not castable, simply because
105804:         # we're someone's consequential interface.  But for this-unwrapping, we
105804:         # know that we're the real deal.  So fake a descriptor here for
121475:         # consumption by CastableObjectUnwrapper.
120397:         getThis = CGGeneric("""js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
120397: if (!obj) {
120397:   return false;
120397: }
120397: 
120397: %s* self;""" % self.descriptor.nativeType)
120397:         unwrapThis = CGGeneric(
113773:             str(CastableObjectUnwrapper(
105804:                         FakeCastableDescriptor(self.descriptor),
120397:                         "obj", "self", self.unwrapFailureCode)))
120397:         return CGList([ CGIndenter(getThis), CGIndenter(unwrapThis),
 94512:                         self.generate_code() ], "\n").define()
 94512: 
120397:     def generate_code(self):
120397:         assert(False) # Override me
120397: 
120397: class CGAbstractStaticBindingMethod(CGAbstractStaticMethod):
120397:     """
120397:     Common class to generate the JSNatives for all our static methods, getters
120397:     and setters.  This will generate the function declaration and unwrap the
120397:     global object.  Subclasses are expected to override the generate_code
120397:     function to do the rest of the work.  This function should return a
120397:     CGThing which is already properly indented.
120397:     """
120397:     def __init__(self, descriptor, name, args):
120397:         CGAbstractStaticMethod.__init__(self, descriptor, name, "JSBool", args)
120397: 
120397:     def definition_body(self):
120397:         isMainThread = toStringBool(not self.descriptor.workers)
120397:         unwrap = CGGeneric("""js::RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
120397: if (!obj) {
120397:   return false;
120397: }
120397: 
120397: if (js::IsWrapper(obj)) {
120397:   obj = XPCWrapper::Unwrap(cx, obj, false);
120397:   if (!obj) {
120397:     return Throw<%s>(cx, NS_ERROR_XPC_SECURITY_MANAGER_VETO);
120397:   }
120397: }
120397: 
120397: nsISupports* global;
120397: xpc_qsSelfRef globalRef;
120397: {
120397:   JS::Value val;
120397:   val.setObjectOrNull(JS_GetGlobalForObject(cx, obj));
120397:   nsresult rv = xpc_qsUnwrapArg<nsISupports>(cx, val, &global, &globalRef.ptr,
120397:                                              &val);
120397:   if (NS_FAILED(rv)) {
120397:     return Throw<%s>(cx, NS_ERROR_XPC_BAD_CONVERT_JS);
120397:   }
120397: }""" % (isMainThread, isMainThread))
120397:         return CGList([ CGIndenter(unwrap),
120397:                         self.generate_code() ], "\n\n").define()
 94512: 
 94512:     def generate_code(self):
 94512:         assert(False) # Override me
 94512: 
 94512: def MakeNativeName(name):
 94512:     return name[0].upper() + name[1:]
 94512: 
107793: class CGGenericMethod(CGAbstractBindingMethod):
 94512:     """
 94512:     A class for generating the C++ code for an IDL method..
 94512:     """
107793:     def __init__(self, descriptor):
 94512:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
 94512:                 Argument('JS::Value*', 'vp')]
107793:         CGAbstractBindingMethod.__init__(self, descriptor, 'genericMethod', args)
107787: 
 94512:     def generate_code(self):
107787:         return CGIndenter(CGGeneric(
107793:             "const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));\n"
107793:             "JSJitMethodOp method = (JSJitMethodOp)info->op;\n"
107793:             "return method(cx, obj, self, argc, vp);"))
107787: 
107787: class CGSpecializedMethod(CGAbstractStaticMethod):
107787:     """
107787:     A class for generating the C++ code for a specialized method that the JIT
107787:     can call with lower overhead.
107787:     """
107787:     def __init__(self, descriptor, method):
107787:         self.method = method
120633:         name = CppKeywords.checkMethodName(method.identifier.name)
107787:         args = [Argument('JSContext*', 'cx'), Argument('JSHandleObject', 'obj'),
107787:                 Argument('%s*' % descriptor.nativeType, 'self'),
107787:                 Argument('unsigned', 'argc'), Argument('JS::Value*', 'vp')]
107787:         CGAbstractStaticMethod.__init__(self, descriptor, name, 'bool', args)
107787: 
107787:     def definition_body(self):
119238:         nativeName = CGSpecializedMethod.makeNativeName(self.descriptor,
119238:                                                         self.method)
 99125:         return CGMethodCall([], nativeName, self.method.isStatic(),
107787:                             self.descriptor, self.method).define()
 94512: 
119238:     @staticmethod
119238:     def makeNativeName(descriptor, method):
119238:         name = method.identifier.name
119238:         return MakeNativeName(descriptor.binaryNames.get(name, name))
119238: 
120633: class CppKeywords():
120633:     """
120633:     A class for checking if method names declared in webidl
120633:     are not in conflict with C++ keywords.
120633:     """
120633:     keywords = frozenset(['alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand', 'bitor', 'bool',
120633:     'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class', 'compl', 'const', 'constexpr',
120633:     'const_cast', 'continue', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else', 'enum',
120633:     'explicit', 'export', 'extern', 'false', 'final', 'float', 'for', 'friend', 'goto', 'if', 'inline',
120633:     'int', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq', 'nullptr', 'operator',
120633:     'or', 'or_eq', 'override', 'private', 'protected', 'public', 'register', 'reinterpret_cast', 'return',
120633:     'short', 'signed', 'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch', 'template',
120633:     'this', 'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union', 'unsigned',
120633:     'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'])
120633: 
120633:     @staticmethod
120633:     def checkMethodName(name):
120633:         if name in CppKeywords.keywords:
120633:           name = '_' + name
120633:         return name
120633: 
120397: class CGStaticMethod(CGAbstractStaticBindingMethod):
120397:     """
120397:     A class for generating the C++ code for an IDL static method.
120397:     """
120397:     def __init__(self, descriptor, method):
120397:         self.method = method
120397:         name = method.identifier.name
120397:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
120397:                 Argument('JS::Value*', 'vp')]
120397:         CGAbstractStaticBindingMethod.__init__(self, descriptor, name, args)
120397: 
120397:     def generate_code(self):
120397:         nativeName = CGSpecializedMethod.makeNativeName(self.descriptor,
120397:                                                         self.method)
120397:         return CGMethodCall([ "global" ], nativeName, True, self.descriptor,
120397:                             self.method)
120397: 
107793: class CGGenericGetter(CGAbstractBindingMethod):
 94512:     """
 94512:     A class for generating the C++ code for an IDL attribute getter.
 94512:     """
113773:     def __init__(self, descriptor, lenientThis=False):
 94512:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
 94512:                 Argument('JS::Value*', 'vp')]
113773:         if lenientThis:
113773:             name = "genericLenientGetter"
113773:             unwrapFailureCode = (
113773:                 "MOZ_ASSERT(!JS_IsExceptionPending(cx));\n"
113773:                 "JS_SET_RVAL(cx, vp, JS::UndefinedValue());\n"
113773:                 "return true;")
113773:         else:
113773:             name = "genericGetter"
113773:             unwrapFailureCode = None
113773:         CGAbstractBindingMethod.__init__(self, descriptor, name, args,
113773:                                          unwrapFailureCode)
 94512: 
 94512:     def generate_code(self):
107784:         return CGIndenter(CGGeneric(
107793:             "const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));\n"
107793:             "JSJitPropertyOp getter = info->op;\n"
107793:             "return getter(cx, obj, self, vp);"))
107784: 
107784: class CGSpecializedGetter(CGAbstractStaticMethod):
107784:     """
107784:     A class for generating the code for a specialized attribute getter
107784:     that the JIT can call with lower overhead.
107784:     """
107784:     def __init__(self, descriptor, attr):
107784:         self.attr = attr
107793:         name = 'get_' + attr.identifier.name
107784:         args = [ Argument('JSContext*', 'cx'),
107784:                  Argument('JSHandleObject', 'obj'),
107784:                  Argument('%s*' % descriptor.nativeType, 'self'),
107784:                  Argument('JS::Value*', 'vp') ]
107784:         CGAbstractStaticMethod.__init__(self, descriptor, name, "bool", args)
107784: 
107784:     def definition_body(self):
119238:         nativeName = CGSpecializedGetter.makeNativeName(self.descriptor,
119238:                                                         self.attr)
119238:         return CGIndenter(CGGetterCall(self.attr.type, nativeName,
119238:                                        self.descriptor, self.attr)).define()
119238: 
119238:     @staticmethod
119238:     def makeNativeName(descriptor, attr):
119238:         name = attr.identifier.name
119238:         nativeName = MakeNativeName(descriptor.binaryNames.get(name, name))
113697:         # resultOutParam does not depend on whether resultAlreadyAddRefed is set
119238:         (_, resultOutParam) = getRetvalDeclarationForType(attr.type, descriptor,
113697:                                                           False)
113697:         infallible = ('infallible' in
119238:                       descriptor.getExtendedAttributes(attr, getter=True))
119238:         if resultOutParam or attr.type.nullable() or not infallible:
113697:             nativeName = "Get" + nativeName
119238:         return nativeName
 94512: 
120397: class CGStaticGetter(CGAbstractStaticBindingMethod):
120397:     """
120397:     A class for generating the C++ code for an IDL static attribute getter.
120397:     """
120397:     def __init__(self, descriptor, attr):
120397:         self.attr = attr
120397:         name = 'get_' + attr.identifier.name
120397:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
120397:                 Argument('JS::Value*', 'vp')]
120397:         CGAbstractStaticBindingMethod.__init__(self, descriptor, name, args)
120397: 
120397:     def generate_code(self):
120397:         nativeName = CGSpecializedGetter.makeNativeName(self.descriptor,
120397:                                                         self.attr)
120397:         return CGIndenter(CGGetterCall(self.attr.type, nativeName,
120397:                                        self.descriptor, self.attr))
120397: 
107793: class CGGenericSetter(CGAbstractBindingMethod):
 94512:     """
 94512:     A class for generating the C++ code for an IDL attribute setter.
 94512:     """
113773:     def __init__(self, descriptor, lenientThis=False):
 94512:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
 94512:                 Argument('JS::Value*', 'vp')]
113773:         if lenientThis:
113773:             name = "genericLenientSetter"
113773:             unwrapFailureCode = (
113773:                 "MOZ_ASSERT(!JS_IsExceptionPending(cx));\n"
113773:                 "return true;")
113773:         else:
113773:             name = "genericSetter"
113773:             unwrapFailureCode = None
113773:         CGAbstractBindingMethod.__init__(self, descriptor, name, args,
113773:                                          unwrapFailureCode)
 94512: 
 94512:     def generate_code(self):
107790:         return CGIndenter(CGGeneric(
107793:                 "JS::Value* argv = JS_ARGV(cx, vp);\n"
107790:                 "JS::Value undef = JS::UndefinedValue();\n"
107784:                 "if (argc == 0) {\n"
107784:                 "  argv = &undef;\n"
107790:                 "}\n"
107793:                 "const JSJitInfo *info = FUNCTION_VALUE_TO_JITINFO(JS_CALLEE(cx, vp));\n"
107793:                 "JSJitPropertyOp setter = info->op;\n"
107793:                 "if (!setter(cx, obj, self, argv)) {\n"
107784:                 "  return false;\n"
107793:                 "}\n"
107790:                 "*vp = JSVAL_VOID;\n"
107784:                 "return true;"))
107784: 
107784: class CGSpecializedSetter(CGAbstractStaticMethod):
107784:     """
107784:     A class for generating the code for a specialized attribute setter
107784:     that the JIT can call with lower overhead.
107784:     """
107784:     def __init__(self, descriptor, attr):
107784:         self.attr = attr
107793:         name = 'set_' + attr.identifier.name
107784:         args = [ Argument('JSContext*', 'cx'),
107784:                  Argument('JSHandleObject', 'obj'),
107790:                  Argument('%s*' % descriptor.nativeType, 'self'),
107790:                  Argument('JS::Value*', 'argv')]
107784:         CGAbstractStaticMethod.__init__(self, descriptor, name, "bool", args)
107784: 
107784:     def definition_body(self):
119238:         nativeName = CGSpecializedSetter.makeNativeName(self.descriptor,
119238:                                                         self.attr)
107784:         return CGIndenter(CGSetterCall(self.attr.type, nativeName,
107784:                                        self.descriptor, self.attr)).define()
107784: 
119238:     @staticmethod
119238:     def makeNativeName(descriptor, attr):
119238:         name = attr.identifier.name
119238:         return "Set" + MakeNativeName(descriptor.binaryNames.get(name, name))
119238: 
120397: class CGStaticSetter(CGAbstractStaticBindingMethod):
120397:     """
120397:     A class for generating the C++ code for an IDL static attribute setter.
120397:     """
120397:     def __init__(self, descriptor, attr):
120397:         self.attr = attr
120397:         name = 'set_' + attr.identifier.name
120397:         args = [Argument('JSContext*', 'cx'), Argument('unsigned', 'argc'),
120397:                 Argument('JS::Value*', 'vp')]
120397:         CGAbstractStaticBindingMethod.__init__(self, descriptor, name, args)
120397: 
120397:     def generate_code(self):
120397:         nativeName = CGSpecializedSetter.makeNativeName(self.descriptor,
120397:                                                         self.attr)
120397:         argv = CGGeneric("""JS::Value* argv = JS_ARGV(cx, vp);
120397: JS::Value undef = JS::UndefinedValue();
120397: if (argc == 0) {
120397:   argv = &undef;
120397: }""")
120397:         call = CGSetterCall(self.attr.type, nativeName, self.descriptor,
120397:                             self.attr)
120397:         return CGIndenter(CGList([ argv, call ], "\n"))
120397: 
120321: class CGSpecializedForwardingSetter(CGSpecializedSetter):
120321:     """
120321:     A class for generating the code for a specialized attribute setter with
120321:     PutForwards that the JIT can call with lower overhead.
120321:     """
120321:     def __init__(self, descriptor, attr):
120321:         CGSpecializedSetter.__init__(self, descriptor, attr)
120321: 
120321:     def definition_body(self):
120321:         attrName = self.attr.identifier.name
120321:         forwardToAttrName = self.attr.getExtendedAttribute("PutForwards")[0]
120321:         # JS_GetProperty and JS_SetProperty can only deal with ASCII
120321:         assert all(ord(c) < 128 for c in attrName)
120321:         assert all(ord(c) < 128 for c in forwardToAttrName)
120321:         return CGIndenter(CGGeneric("""js::RootedValue v(cx);
120321: if (!JS_GetProperty(cx, obj, "%s", v.address())) {
120321:   return false;
120321: }
120321: 
120321: if (!v.isObject()) {
120321:   return ThrowErrorMessage(cx, MSG_NOT_OBJECT);
120321: }
120321: 
120321: return JS_SetProperty(cx, &v.toObject(), "%s", argv);""" % (attrName, forwardToAttrName))).define()
120321: 
107785: def memberIsCreator(member):
107785:     return member.getExtendedAttribute("Creator") is not None
107785: 
107787: class CGMemberJITInfo(CGThing):
107784:     """
107784:     A class for generating the JITInfo for a property that points to
107784:     our specialized getter and setter.
107784:     """
107787:     def __init__(self, descriptor, member):
107787:         self.member = member
107784:         self.descriptor = descriptor
107784: 
107784:     def declare(self):
107784:         return ""
107784: 
107784:     def defineJitInfo(self, infoName, opName, infallible):
114572:         protoID = "prototypes::id::%s" % self.descriptor.name
107784:         depth = "PrototypeTraits<%s>::Depth" % protoID
107784:         failstr = "true" if infallible else "false"
107784:         return ("\n"
107784:                 "const JSJitInfo %s = {\n"
107784:                 "  %s,\n"
107784:                 "  %s,\n"
107784:                 "  %s,\n"
111082:                 "  %s,  /* isInfallible. False in setters. */\n"
107787:                 "  false  /* isConstant. Only relevant for getters. */\n"
107784:                 "};\n" % (infoName, opName, protoID, depth, failstr))
107784: 
107784:     def define(self):
107787:         if self.member.isAttr():
107787:             getterinfo = ("%s_getterinfo" % self.member.identifier.name)
107793:             getter = ("(JSJitPropertyOp)get_%s" % self.member.identifier.name)
107787:             getterinfal = "infallible" in self.descriptor.getExtendedAttributes(self.member, getter=True)
111082:             getterinfal = getterinfal and infallibleForMember(self.member, self.member.type, self.descriptor)
107785:             result = self.defineJitInfo(getterinfo, getter, getterinfal)
120321:             if not self.member.readonly or self.member.getExtendedAttribute("PutForwards") is not None:
107787:                 setterinfo = ("%s_setterinfo" % self.member.identifier.name)
107793:                 setter = ("(JSJitPropertyOp)set_%s" % self.member.identifier.name)
107784:                 # Setters are always fallible, since they have to do a typed unwrap.
107784:                 result += self.defineJitInfo(setterinfo, setter, False)
107784:             return result
107787:         if self.member.isMethod():
107787:             methodinfo = ("%s_methodinfo" % self.member.identifier.name)
120633:             name = CppKeywords.checkMethodName(self.member.identifier.name)
107793:             # Actually a JSJitMethodOp, but JSJitPropertyOp by struct definition.
120633:             method = ("(JSJitPropertyOp)%s" % name)
111082: 
111082:             # Methods are infallible if they are infallible, have no arguments
111082:             # to unwrap, and have a return type that's infallible to wrap up for
111082:             # return.
111082:             methodInfal = False
111082:             sigs = self.member.signatures()
111082:             if len(sigs) == 1:
111082:                 # Don't handle overloading. If there's more than one signature,
111082:                 # one of them must take arguments.
111082:                 sig = sigs[0]
111082:                 if len(sig[1]) == 0 and infallibleForMember(self.member, sig[0], self.descriptor):
111082:                     # No arguments and infallible return boxing
111082:                     methodInfal = True
111082: 
111082:             result = self.defineJitInfo(methodinfo, method, methodInfal)
107787:             return result
107787:         raise TypeError("Illegal member type to CGPropertyJITInfo")
 94512: 
 94512: def getEnumValueName(value):
 94512:     # Some enum values can be empty strings.  Others might have weird
 94512:     # characters in them.  Deal with the former by returning "_empty",
 94512:     # deal with possible name collisions from that by throwing if the
 94512:     # enum value is actually "_empty", and throw on any value
 94512:     # containing chars other than [a-z] or '-' for now. Replace '-' with '_'.
 94512:     value = value.replace('-', '_')
 94512:     if value == "_empty":
 94512:         raise SyntaxError('"_empty" is not an IDL enum value we support yet')
 94512:     if value == "":
 94512:         return "_empty"
 94512:     if not re.match("^[a-z_]+$", value):
 94512:         raise SyntaxError('Enum value "' + value + '" contains characters '
 94512:                           'outside [a-z_]')
102144:     return MakeNativeName(value)
 94512: 
 94512: class CGEnum(CGThing):
 94512:     def __init__(self, enum):
 94512:         CGThing.__init__(self)
 94512:         self.enum = enum
 94512: 
 94512:     def declare(self):
 94512:         return """
 97422:   enum valuelist {
 94512:     %s
 94512:   };
 94512: 
 94512:   extern const EnumEntry strings[%d];
 94512: """ % (",\n    ".join(map(getEnumValueName, self.enum.values())),
 94512:        len(self.enum.values()) + 1)
 94512: 
 94512:     def define(self):
 94512:         return """
 94512:   const EnumEntry strings[%d] = {
 94512:     %s,
 94512:     { NULL, 0 }
 94512:   };
 94512: """ % (len(self.enum.values()) + 1,
 94512:        ",\n    ".join(['{"' + val + '", ' + str(len(val)) + '}' for val in self.enum.values()]))
 94512: 
102822: def getUnionAccessorSignatureType(type, descriptorProvider):
102822:     """
102822:     Returns the types that are used in the getter and setter signatures for
102822:     union types
102822:     """
102822:     if type.isArray():
102822:         raise TypeError("Can't handle array arguments yet")
102822: 
102822:     if type.isSequence():
102822:         nullable = type.nullable();
102822:         if nullable:
102822:             type = type.inner.inner
102822:         else:
102822:             type = type.inner
102822:         (elementTemplate, elementDeclType,
102822:          elementHolderType, dealWithOptional) = getJSToNativeConversionTemplate(
102822:             type, descriptorProvider, isSequenceMember=True)
102822:         typeName = CGWrapper(elementDeclType, pre="Sequence< ", post=" >&")
102822:         if nullable:
102822:             typeName = CGWrapper(typeName, pre="Nullable< ", post=" >&")
102822: 
102822:         return typeName
102822: 
102822:     if type.isUnion():
102822:         typeName = CGGeneric(type.name)
102822:         if type.nullable():
102822:             typeName = CGWrapper(typeName, pre="Nullable< ", post=" >&")
102822: 
102822:         return typeName
102822: 
102822:     if type.isGeckoInterface():
102822:         descriptor = descriptorProvider.getDescriptor(
102822:             type.unroll().inner.identifier.name)
102822:         typeName = CGGeneric(descriptor.nativeType)
102822:         # Allow null pointers for nullable types and old-binding classes
102822:         if type.nullable() or type.unroll().inner.isExternal():
102822:             typeName = CGWrapper(typeName, post="*")
102822:         else:
102822:             typeName = CGWrapper(typeName, post="&")
102822:         return typeName
102822: 
102822:     if type.isSpiderMonkeyInterface():
102822:         typeName = CGGeneric(type.name)
102822:         if type.nullable():
102822:             typeName = CGWrapper(typeName, post="*")
102822:         else:
102822:             typeName = CGWrapper(typeName, post="&")
102822:         return typeName
102822: 
102822:     if type.isString():
102822:         return CGGeneric("const nsAString&")
102822: 
102822:     if type.isEnum():
102822:         if type.nullable():
102822:             raise TypeError("We don't support nullable enumerated arguments or "
102822:                             "union members yet")
102822:         return CGGeneric(type.inner.identifier.name)
102822: 
102822:     if type.isCallback():
121480:         if descriptorProvider.workers:
118539:             if type.nullable():
102822:                 return CGGeneric("JSObject*")
118539:             return CGGeneric("JSObject&")
121480:         if type.nullable():
121480:             typeName = "%s*"
121480:         else:
121480:             typeName = "%s&"
121480:         return CGGeneric(typeName % type.unroll().identifier.name)
102822: 
102822:     if type.isAny():
102822:         return CGGeneric("JS::Value")
102822: 
102822:     if type.isObject():
102822:         typeName = CGGeneric("JSObject")
102822:         if type.nullable():
102822:             typeName = CGWrapper(typeName, post="*")
102822:         else:
102822:             typeName = CGWrapper(typeName, post="&")
102822:         return typeName
102822: 
102822:     if not type.isPrimitive():
102822:         raise TypeError("Need native type for argument type '%s'" % str(type))
102822: 
102822:     typeName = CGGeneric(builtinNames[type.tag()])
102822:     if type.nullable():
102822:         typeName = CGWrapper(typeName, pre="Nullable< ", post=" >&")
102822:     return typeName
102822: 
102822: def getUnionTypeTemplateVars(type, descriptorProvider):
102822:     # For dictionaries and sequences we need to pass None as the failureCode
102822:     # for getJSToNativeConversionTemplate.
105570:     # Also, for dictionaries we would need to handle conversion of
105570:     # null/undefined to the dictionary correctly.
102822:     if type.isDictionary() or type.isSequence():
102822:         raise TypeError("Can't handle dictionaries or sequences in unions")
102822: 
102822:     if type.isGeckoInterface():
102822:         name = type.inner.identifier.name
102822:     elif type.isEnum():
102822:         name = type.inner.identifier.name
102822:     elif type.isArray() or type.isSequence():
102822:         name = str(type)
102822:     else:
102822:         name = type.name
102822: 
102822:     tryNextCode = """tryNext = true;
102822: return true;"""
102822:     if type.isGeckoInterface():
102822:          tryNextCode = ("""if (mUnion.mType != mUnion.eUninitialized) {
102822:   mUnion.Destroy%s();
102822: }""" % name) + tryNextCode
102822:     (template, declType, holderType,
102822:      dealWithOptional) = getJSToNativeConversionTemplate(
102822:         type, descriptorProvider, failureCode=tryNextCode,
102822:         isDefinitelyObject=True)
102822: 
102822:     # This is ugly, but UnionMember needs to call a constructor with no
102822:     # arguments so the type can't be const.
102822:     structType = declType.define()
102822:     if structType.startswith("const "):
102822:         structType = structType[6:]
102822:     externalType = getUnionAccessorSignatureType(type, descriptorProvider).define()
102822: 
102822:     if type.isObject():
102822:         setter = CGGeneric("void SetToObject(JSObject* obj)\n"
102822:                            "{\n"
102822:                            "  mUnion.mValue.mObject.SetValue() = obj;\n"
102822:                            "  mUnion.mType = mUnion.eObject;\n"
102822:                            "}")
102822:     else:
102822:         jsConversion = string.Template(template).substitute(
102822:             {
102822:                 "val": "value",
102822:                 "valPtr": "pvalue",
102822:                 "declName": "SetAs" + name + "()",
121479:                 "holderName": "m" + name + "Holder",
121479:                 "obj": "scopeObj"
102822:                 }
102822:             )
102822:         jsConversion = CGWrapper(CGGeneric(jsConversion),
102822:                                  post="\n"
102822:                                       "return true;")
102822:         setter = CGWrapper(CGIndenter(jsConversion),
121479:                            pre="bool TrySetTo" + name + "(JSContext* cx, JSObject* scopeObj, const JS::Value& value, JS::Value* pvalue, bool& tryNext)\n"
102822:                                "{\n"
102822:                                "  tryNext = false;\n",
102822:                            post="\n"
102822:                                 "}")
102822: 
102822:     return {
102822:                 "name": name,
102822:                 "structType": structType,
102822:                 "externalType": externalType,
102822:                 "setter": CGIndenter(setter).define(),
102822:                 "holderType": holderType.define() if holderType else None
102822:                 }
102822: 
102822: def mapTemplate(template, templateVarArray):
102822:     return map(lambda v: string.Template(template).substitute(v),
102822:                templateVarArray)
102822: 
102822: class CGUnionStruct(CGThing):
102822:     def __init__(self, type, descriptorProvider):
102822:         CGThing.__init__(self)
102822:         self.type = type.unroll()
102822:         self.descriptorProvider = descriptorProvider
121482:         self.templateVars = map(
121482:             lambda t: getUnionTypeTemplateVars(t, self.descriptorProvider),
121482:             self.type.flatMemberTypes)
121482: 
102822: 
102822:     def declare(self):
121482:         templateVars = self.templateVars
102822: 
102822:         callDestructors = []
102822:         enumValues = []
102822:         methods = []
102822:         if self.type.hasNullableType:
102822:             callDestructors.append("      case eNull:\n"
102822:                                    "        break;")
102822:             enumValues.append("eNull")
102822:             methods.append("""  bool IsNull() const
102822:   {
102822:     return mType == eNull;
102822:   }""")
102822: 
102822:         destructorTemplate = """  void Destroy${name}()
102822:   {
102822:     MOZ_ASSERT(Is${name}(), "Wrong type!");
102822:     mValue.m${name}.Destroy();
102822:     mType = eUninitialized;
102822:   }"""
102822:         destructors = mapTemplate(destructorTemplate, templateVars)
102822:         callDestructors.extend(mapTemplate("      case e${name}:\n"
102822:                                            "         Destroy${name}();\n"
102822:                                            "         break;", templateVars))
102822:         enumValues.extend(mapTemplate("e${name}", templateVars))
102822:         methodTemplate = """  bool Is${name}() const
102822:   {
102822:     return mType == e${name};
102822:   }
102822:   ${externalType} GetAs${name}() const
102822:   {
102822:     MOZ_ASSERT(Is${name}(), "Wrong type!");
115608:     return const_cast<${structType}&>(mValue.m${name}.Value());
102822:   }
102822:   ${structType}& SetAs${name}()
102822:   {
102822:     mType = e${name};
102822:     return mValue.m${name}.SetValue();
102822:   }"""
102822:         methods.extend(mapTemplate(methodTemplate, templateVars))
102822:         values = mapTemplate("UnionMember<${structType} > m${name};", templateVars)
102822:         return string.Template("""
102822: class ${structName} {
102822: public:
102822:   ${structName}() : mType(eUninitialized)
102822:   {
102822:   }
102822:   ~${structName}()
102822:   {
102822:     switch (mType) {
102822: ${callDestructors}
102822:       case eUninitialized:
102822:         break;
102822:     }
102822:   }
102822: 
102822: ${methods}
102822: 
121482:   bool ToJSVal(JSContext* cx, JSObject* scopeObj, JS::Value* vp) const;
121482: 
102822: private:
102822:   friend class ${structName}Argument;
102822: 
102822: ${destructors}
102822: 
102822:   enum Type {
102822:     eUninitialized,
102822:     ${enumValues}
102822:   };
102822:   union Value {
102822:     ${values}
102822:   };
102822: 
102822:   Type mType;
102822:   Value mValue;
102822: };
102822: 
102822: """).substitute(
102822:     {
102822:        "structName": self.type.__str__(),
102822:        "callDestructors": "\n".join(callDestructors),
102822:        "destructors": "\n".join(destructors),
102822:        "methods": "\n\n".join(methods),
102822:        "enumValues": ",\n    ".join(enumValues),
121482:        "values": "\n    ".join(values)
102822:        })
102822: 
102822:     def define(self):
121482:         templateVars = self.templateVars
121482:         conversionsToJS = []
121482:         if self.type.hasNullableType:
121482:             conversionsToJS.append("    case eNull:\n"
121498:                                    "    {\n"
121482:                                    "      *vp = JS::NullValue();\n"
121498:                                    "      return true;\n"
121498:                                    "    }")
121482:         conversionsToJS.extend(
121498:             map(self.getConversionToJS,
121498:                 zip(templateVars, self.type.flatMemberTypes)))
121482: 
121482:         return string.Template("""bool
121482: ${structName}::ToJSVal(JSContext* cx, JSObject* scopeObj, JS::Value* vp) const
121482: {
121482:   switch (mType) {
121482: ${doConversionsToJS}
121482: 
121482:     case eUninitialized:
121498:     {
121482:       break;
121482:     }
121498:   }
121482:   return false;
121482: }
121482: """).substitute({
121482:                 "structName": str(self.type),
121482:                 "doConversionsToJS": "\n\n".join(conversionsToJS)
121482:                 })
121482: 
121498:     def getConversionToJS(self, arg):
121482:         (templateVars, type) = arg
121498:         assert not type.nullable() # flatMemberTypes never has nullable types
121482:         val = "mValue.m%(name)s.Value()" % templateVars
121482:         if type.isString():
121482:             # XPConnect string-to-JS conversion wants to mutate the string.  So
121482:             # let's give it a string it can mutate
121482:             # XXXbz if we try to do a sequence of strings, this will kinda fail.
121482:             prepend = "nsString mutableStr(%s);\n" % val
121482:             val = "mutableStr"
121482:         else:
121482:             prepend = ""
121498:             if type.isObject():
121482:                 # We'll have a NonNull<JSObject> while the wrapping code
121482:                 # wants a JSObject*
121482:                 val = "%s.get()" % val
121482:             elif type.isSpiderMonkeyInterface():
121482:                 # We have a NonNull<TypedArray> object while the wrapping code
121482:                 # wants a JSObject*.  Cheat with .get() so we don't have to
121482:                 # figure out the right reference type to cast to.
121482:                 val = "%s.get()->Obj()" % val
121482:         wrapCode = prepend + wrapForType(
121482:             type, self.descriptorProvider,
121482:             {
121482:                 "jsvalRef": "*vp",
121482:                 "jsvalPtr": "vp",
121482:                 "obj": "scopeObj",
121482:                 "result": val,
121482:                 "objectCanBeNonNull": True
121482:                 })
121498:         return CGIndenter(CGList([CGGeneric("case e%(name)s:" % templateVars),
121498:                                   CGWrapper(CGIndenter(CGGeneric(wrapCode)),
121482:                                             pre="{\n",
121498:                                             post="\n}")],
121498:                                  "\n"),
121498:                           4).define()
102822: 
102822: class CGUnionConversionStruct(CGThing):
102822:     def __init__(self, type, descriptorProvider):
102822:         CGThing.__init__(self)
102822:         self.type = type.unroll()
102822:         self.descriptorProvider = descriptorProvider
102822: 
102822:     def declare(self):
102822:         setters = []
102822: 
102822:         if self.type.hasNullableType:
102822:             setters.append("""  bool SetNull()
102822:   {
102822:     mUnion.mType = mUnion.eNull;
102822:     return true;
102822:   }""")
102822: 
102822:         templateVars = map(lambda t: getUnionTypeTemplateVars(t, self.descriptorProvider),
102822:                            self.type.flatMemberTypes)
102822:         structName = self.type.__str__()
102822: 
102822:         setters.extend(mapTemplate("${setter}", templateVars))
102822:         private = "\n".join(mapTemplate("""  ${structType}& SetAs${name}()
102822:   {
102822:     mUnion.mType = mUnion.e${name};
102822:     return mUnion.mValue.m${name}.SetValue();
102822:   }""", templateVars))
102822:         private += "\n\n"
102822:         holders = filter(lambda v: v["holderType"] is not None, templateVars)
102822:         if len(holders) > 0:
102822:             private += "\n".join(mapTemplate("  ${holderType} m${name}Holder;", holders))
102822:             private += "\n\n"
102822:         private += "  " + structName + "& mUnion;"
102822:         return string.Template("""
102822: class ${structName}Argument {
102822: public:
102822:   ${structName}Argument(const ${structName}& aUnion) : mUnion(const_cast<${structName}&>(aUnion))
102822:   {
102822:   }
102822: 
102822: ${setters}
102822: 
102822: private:
102822: ${private}
102822: };
102822: """).substitute({"structName": structName,
102822:        "setters": "\n\n".join(setters),
102822:        "private": private
102822:        })
102822: 
102822:     def define(self):
102822:         return """
102822: """
102822: 
 94512: class ClassItem:
 94512:     """ Use with CGClass """
 94512:     def __init__(self, name, visibility):
 94512:         self.name = name
 94512:         self.visibility = visibility
 94512:     def declare(self, cgClass):
 94512:         assert False
 94512:     def define(self, cgClass):
 94512:         assert False
 94512: 
 94512: class ClassBase(ClassItem):
 94512:     def __init__(self, name, visibility='public'):
 94512:         ClassItem.__init__(self, name, visibility)
 94512:     def declare(self, cgClass):
 94512:         return '%s %s' % (self.visibility, self.name)
 94512:     def define(self, cgClass):
 94512:         # Only in the header
 94512:         return ''
 94512: 
 94512: class ClassMethod(ClassItem):
 94512:     def __init__(self, name, returnType, args, inline=False, static=False,
 94512:                  virtual=False, const=False, bodyInHeader=False,
121473:                  templateArgs=None, visibility='public', body=None,
121473:                  breakAfterReturnDecl="\n",
121473:                  breakAfterSelf="\n"):
 94512:         self.returnType = returnType
 94512:         self.args = args
 94512:         self.inline = inline or bodyInHeader
 94512:         self.static = static
 94512:         self.virtual = virtual
 94512:         self.const = const
 94512:         self.bodyInHeader = bodyInHeader
 94512:         self.templateArgs = templateArgs
 94512:         self.body = body
121473:         self.breakAfterReturnDecl = breakAfterReturnDecl
121473:         self.breakAfterSelf = breakAfterSelf
 94512:         ClassItem.__init__(self, name, visibility)
 94512: 
 94512:     def getDecorators(self, declaring):
 94512:         decorators = []
 94512:         if self.inline:
 94512:             decorators.append('inline')
 94512:         if declaring:
 94512:             if self.static:
 94512:                 decorators.append('static')
 94512:             if self.virtual:
 94512:                 decorators.append('virtual')
 94512:         if decorators:
 94512:             return ' '.join(decorators) + ' '
 94512:         return ''
 94512: 
 94512:     def getBody(self):
 94512:         # Override me or pass a string to constructor
 94512:         assert self.body is not None
 94512:         return self.body
 94512: 
 94512:     def declare(self, cgClass):
 94512:         templateClause = 'template <%s>\n' % ', '.join(self.templateArgs) \
 94512:                          if self.bodyInHeader and self.templateArgs else ''
 94512:         args = ', '.join([str(a) for a in self.args])
 94512:         if self.bodyInHeader:
102145:             body = CGIndenter(CGGeneric(self.getBody())).define()
 94512:             body = '\n{\n' + body + '\n}'
 94512:         else:
 94512:            body = ';'
 94512: 
121473:         return string.Template("${templateClause}${decorators}${returnType}%s"
121473:                                "${name}(${args})${const}${body}%s" %
121473:                                (self.breakAfterReturnDecl, self.breakAfterSelf)
121473:                                ).substitute({
121473:                 'templateClause': templateClause,
 94512:                 'decorators': self.getDecorators(True),
 94512:                 'returnType': self.returnType,
 94512:                 'name': self.name,
 94512:                 'const': ' const' if self.const else '',
 94512:                 'args': args,
121473:                 'body': body
121473:                 })
 94512: 
 94512:     def define(self, cgClass):
 94512:         if self.bodyInHeader:
 94512:             return ''
 94512: 
 94512:         templateArgs = cgClass.templateArgs
 94512:         if templateArgs:
 94512:             if cgClass.templateSpecialization:
 94512:                 templateArgs = \
 94512:                     templateArgs[len(cgClass.templateSpecialization):]
 94512: 
 94512:         if templateArgs:
 94512:             templateClause = \
 94512:                 'template <%s>\n' % ', '.join([str(a) for a in templateArgs])
 94512:         else:
 94512:             templateClause = ''
 94512: 
 94512:         args = ', '.join([str(a) for a in self.args])
 94512: 
102145:         body = CGIndenter(CGGeneric(self.getBody())).define()
 94512: 
 94512:         return string.Template("""${templateClause}${decorators}${returnType}
 94512: ${className}::${name}(${args})${const}
 94512: {
 94512: ${body}
 94512: }\n
 94512: """).substitute({ 'templateClause': templateClause,
 94512:                   'decorators': self.getDecorators(False),
 94512:                   'returnType': self.returnType,
 94512:                   'className': cgClass.getNameString(),
 94512:                   'name': self.name,
 94512:                   'args': args,
 94512:                   'const': ' const' if self.const else '',
 94512:                   'body': body })
 94512: 
109136: class ClassConstructor(ClassItem):
109136:     """
109136:     Used for adding a constructor to a CGClass.
109136:     
109136:     args is a list of Argument objects that are the arguments taken by the
109136:     constructor.
109136:     
109136:     inline should be True if the constructor should be marked inline.
109136: 
109136:     bodyInHeader should be True if the body should be placed in the class
109136:     declaration in the header.
109136: 
109136:     visibility determines the visibility of the constructor (public,
109136:     protected, private), defaults to private.
109136: 
109136:     baseConstructors is a list of strings containing calls to base constructors,
109136:     defaults to None.
109136: 
109136:     body contains a string with the code for the constructor, defaults to None.
109136:     """
109136:     def __init__(self, args, inline=False, bodyInHeader=False,
109136:                  visibility="private", baseConstructors=None, body=None):
109136:         self.args = args
109136:         self.inline = inline or bodyInHeader
109136:         self.bodyInHeader = bodyInHeader
109136:         self.baseConstructors = baseConstructors
109136:         self.body = body
109136:         ClassItem.__init__(self, None, visibility)
109136: 
109136:     def getDecorators(self, declaring):
109136:         decorators = []
109136:         if self.inline and declaring:
109136:             decorators.append('inline')
109136:         if decorators:
109136:             return ' '.join(decorators) + ' '
109136:         return ''
109136: 
109136:     def getInitializationList(self, cgClass):
109136:         items = [str(c) for c in self.baseConstructors]
109136:         for m in cgClass.members:
109136:             if not m.static:
109136:                 initialize = m.getBody()
109136:                 if initialize:
109136:                     items.append(m.name + "(" + initialize + ")")
109136:             
109136:         if len(items) > 0:
109136:             return '\n  : ' + ',\n    '.join(items)
109136:         return ''
109136: 
109136:     def getBody(self):
109136:         assert self.body is not None
109136:         return self.body
109136: 
109136:     def declare(self, cgClass):
109136:         args = ', '.join([str(a) for a in self.args])
109136:         if self.bodyInHeader:
109136:             body = '  ' + self.getBody();
109136:             body = stripTrailingWhitespace(body.replace('\n', '\n  '))
109136:             if len(body) > 0:
109136:                 body += '\n'
109136:             body = self.getInitializationList(cgClass) + '\n{\n' + body + '}'
109136:         else:
109136:             body = ';'
109136: 
109136:         return string.Template("""${decorators}${className}(${args})${body}
109136: """).substitute({ 'decorators': self.getDecorators(True),
109136:                   'className': cgClass.getNameString(),
109136:                   'args': args,
109136:                   'body': body })
109136: 
109136:     def define(self, cgClass):
109136:         if self.bodyInHeader:
109136:             return ''
109136: 
109136:         args = ', '.join([str(a) for a in self.args])
109136: 
109136:         body = '  ' + self.getBody()
109136:         body = '\n' + stripTrailingWhitespace(body.replace('\n', '\n  '))
109136:         if len(body) > 0:
109136:             body += '\n'
109136: 
109136:         return string.Template("""${decorators}
109136: ${className}::${className}(${args})${initializationList}
109136: {${body}}\n
109136: """).substitute({ 'decorators': self.getDecorators(False),
109136:                   'className': cgClass.getNameString(),
109136:                   'args': args,
109136:                   'initializationList': self.getInitializationList(cgClass),
109136:                   'body': body })
109136: 
121473: class ClassDestructor(ClassItem):
121473:     """
121473:     Used for adding a constructor to a CGClass.
121473: 
121473:     inline should be True if the destructor should be marked inline.
121473: 
121473:     bodyInHeader should be True if the body should be placed in the class
121473:     declaration in the header.
121473: 
121473:     visibility determines the visibility of the destructor (public,
121473:     protected, private), defaults to private.
121473: 
121473:     body contains a string with the code for the destructor, defaults to None.
121473:     """
121473:     def __init__(self, inline=False, bodyInHeader=False,
121473:                  visibility="private", body=None):
121473:         self.inline = inline or bodyInHeader
121473:         self.bodyInHeader = bodyInHeader
121473:         self.body = body
121473:         ClassItem.__init__(self, None, visibility)
121473: 
121473:     def getDecorators(self, declaring):
121473:         decorators = []
121473:         if self.inline and declaring:
121473:             decorators.append('inline')
121473:         if decorators:
121473:             return ' '.join(decorators) + ' '
121473:         return ''
121473: 
121473:     def getBody(self):
121473:         assert self.body is not None
121473:         return self.body
121473: 
121473:     def declare(self, cgClass):
121473:         if self.bodyInHeader:
121473:             body = '  ' + self.getBody();
121473:             body = stripTrailingWhitespace(body.replace('\n', '\n  '))
121473:             if len(body) > 0:
121473:                 body += '\n'
121473:             body = '\n{\n' + body + '}'
121473:         else:
121473:             body = ';'
121473: 
121473:         return string.Template("""${decorators}~${className}()${body}
121473: """).substitute({ 'decorators': self.getDecorators(True),
121473:                   'className': cgClass.getNameString(),
121473:                   'body': body })
121473: 
121473:     def define(self, cgClass):
121473:         if self.bodyInHeader:
121473:             return ''
121473: 
121473:         body = '  ' + self.getBody()
121473:         body = '\n' + stripTrailingWhitespace(body.replace('\n', '\n  '))
121473:         if len(body) > 0:
121473:             body += '\n'
121473: 
121473:         return string.Template("""${decorators}
121473: ${className}::~${className}()
121473: {${body}}\n
121473: """).substitute({ 'decorators': self.getDecorators(False),
121473:                   'className': cgClass.getNameString(),
121473:                   'body': body })
121473: 
 94512: class ClassMember(ClassItem):
 94512:     def __init__(self, name, type, visibility="private", static=False,
 94512:                  body=None):
 94512:         self.type = type;
 94512:         self.static = static
 94512:         self.body = body
 94512:         ClassItem.__init__(self, name, visibility)
 94512: 
 94512:     def declare(self, cgClass):
 94512:         return '%s%s %s;\n' % ('static ' if self.static else '', self.type,
 94512:                                self.name)
 94512: 
 94512:     def define(self, cgClass):
 94512:         if not self.static:
 94512:             return ''
109136:         if self.body:
109136:             body = " = " + self.body
109136:         else:
109136:             body = ""
109136:         return '%s %s::%s%s;\n' % (self.type, cgClass.getNameString(),
109136:                                       self.name, body)
 94512: 
 94512: class ClassTypedef(ClassItem):
 94512:     def __init__(self, name, type, visibility="public"):
 94512:         self.type = type
 94512:         ClassItem.__init__(self, name, visibility)
 94512: 
 94512:     def declare(self, cgClass):
 94512:         return 'typedef %s %s;\n' % (self.type, self.name)
 94512: 
 94512:     def define(self, cgClass):
 94512:         # Only goes in the header
 94512:         return ''
 94512: 
 94512: class ClassEnum(ClassItem):
 94512:     def __init__(self, name, entries, values=None, visibility="public"):
 94512:         self.entries = entries
 94512:         self.values = values
 94512:         ClassItem.__init__(self, name, visibility)
 94512: 
 94512:     def declare(self, cgClass):
 94512:         entries = []
 94512:         for i in range(0, len(self.entries)):
 94512:             if i >= len(self.values):
 94512:                 entry = '%s' % self.entries[i]
 94512:             else:
 94512:                 entry = '%s = %s' % (self.entries[i], self.values[i])
 94512:             entries.append(entry)
 94512:         name = '' if not self.name else ' ' + self.name
 94512:         return 'enum%s\n{\n  %s\n};\n' % (name, ',\n  '.join(entries))
 94512: 
 94512:     def define(self, cgClass):
 94512:         # Only goes in the header
 94512:         return ''
 94512: 
 94512: class CGClass(CGThing):
121473:     def __init__(self, name, bases=[], members=[], constructors=[],
121473:                  destructor=None, methods=[],
109136:                  typedefs = [], enums=[], templateArgs=[],
121473:                  templateSpecialization=[], isStruct=False, indent='',
121473:                  decorators='',
121473:                  extradeclarations='',
121473:                  extradefinitions=''):
 94512:         CGThing.__init__(self)
 94512:         self.name = name
 94512:         self.bases = bases
 94512:         self.members = members
109136:         self.constructors = constructors
121473:         # We store our single destructor in a list, since all of our
121473:         # code wants lists of members.
121473:         self.destructors = [destructor] if destructor else []
 94512:         self.methods = methods
 94512:         self.typedefs = typedefs
 94512:         self.enums = enums
 94512:         self.templateArgs = templateArgs
 94512:         self.templateSpecialization = templateSpecialization
 94512:         self.isStruct = isStruct
 94512:         self.indent = indent
 94512:         self.defaultVisibility ='public' if isStruct else 'private'
121473:         self.decorators = decorators
121473:         self.extradeclarations = extradeclarations
121473:         self.extradefinitions = extradefinitions
 94512: 
 94512:     def getNameString(self):
 94512:         className = self.name
 94512:         if self.templateSpecialization:
 94512:             className = className + \
 94512:                 '<%s>' % ', '.join([str(a) for a
 94512:                                     in self.templateSpecialization])
 94512:         return className
 94512: 
 94512:     def declare(self):
 94512:         result = ''
 94512:         if self.templateArgs:
 94512:             templateArgs = [str(a) for a in self.templateArgs]
 94512:             templateArgs = templateArgs[len(self.templateSpecialization):]
 94512:             result = result + self.indent + 'template <%s>\n' \
 94512:                      % ','.join([str(a) for a in templateArgs])
 94512: 
 94512:         type = 'struct' if self.isStruct else 'class'
 94512: 
 94512:         if self.templateSpecialization:
 94512:             specialization = \
 94512:                 '<%s>' % ', '.join([str(a) for a in self.templateSpecialization])
 94512:         else:
 94512:             specialization = ''
 94512: 
121473:         myself = '%s%s %s%s' % (self.indent, type, self.name, specialization)
121473:         if self.decorators != '':
121473:             myself += " " + self.decorators
121473:         result += myself
 94512: 
 94512:         if self.bases:
121473:             inherit = ' : '
121473:             result += inherit
121473:             # Grab our first base
121473:             baseItems = [CGGeneric(b.declare(self)) for b in self.bases]
121473:             bases = baseItems[:1]
121473:             # Indent the rest
121473:             bases.extend(CGIndenter(b, len(myself) + len(inherit)) for
121473:                          b in baseItems[1:])
121473:             result += ",\n".join(b.define() for b in bases)
 94512: 
 94512:         result = result + '\n%s{\n' % self.indent
 94512: 
121473:         result += CGIndenter(CGGeneric(self.extradeclarations),
121473:                              len(self.indent)).define()
121473: 
 94512:         def declareMembers(cgClass, memberList, defaultVisibility, itemCount,
 94512:                            separator=''):
 94512:             members = { 'private': [], 'protected': [], 'public': [] }
 94512: 
 94512:             for member in memberList:
 94512:                 members[member.visibility].append(member)
 94512: 
 94512: 
 94512:             if defaultVisibility == 'public':
 94512:                 order = [ 'public', 'protected', 'private' ]
 94512:             else:
 94512:                 order = [ 'private', 'protected', 'public' ]
 94512: 
 94512:             result = ''
 94512: 
 94512:             lastVisibility = defaultVisibility
 94512:             for visibility in order:
 94512:                 list = members[visibility]
 94512:                 if list:
 94512:                     if visibility != lastVisibility:
 94512:                         if itemCount:
 94512:                             result = result + '\n'
 94512:                         result = result + visibility + ':\n'
 94512:                         itemCount = 0
 94512:                     for member in list:
102145:                         if itemCount != 0:
102145:                             result = result + separator
 94512:                         declaration = member.declare(cgClass)
102145:                         declaration = CGIndenter(CGGeneric(declaration)).define()
 94512:                         result = result + declaration
 94512:                         itemCount = itemCount + 1
 94512:                     lastVisibility = visibility
 94512:             return (result, lastVisibility, itemCount)
 94512: 
 94512:         order = [(self.enums, ''), (self.typedefs, ''), (self.members, ''),
121473:                  (self.constructors, '\n'), (self.destructors, '\n'),
121473:                  (self.methods, '\n')]
 94512: 
 94512:         lastVisibility = self.defaultVisibility
 94512:         itemCount = 0
 94512:         for (memberList, separator) in order:
 94512:             (memberString, lastVisibility, itemCount) = \
 94512:                 declareMembers(self, memberList, lastVisibility, itemCount,
 94512:                                separator)
 94512:             if self.indent:
102145:                 memberString = CGIndenter(CGGeneric(memberString),
102145:                                           len(self.indent)).define()
 94512:             result = result + memberString
 94512: 
109136:         result = result + self.indent + '};\n'
 94512:         return result
 94512: 
 94512:     def define(self):
 94512:         def defineMembers(cgClass, memberList, itemCount, separator=''):
 94512:             result = ''
 94512:             for member in memberList:
 94512:                 if itemCount != 0:
 94512:                     result = result + separator
 94512:                 result = result + member.define(cgClass)
 94512:                 itemCount = itemCount + 1
 94512:             return (result, itemCount)
 94512: 
109136:         order = [(self.members, '\n'), (self.constructors, '\n'),
121473:                  (self.destructors, '\n'), (self.methods, '\n')]
121473: 
121473:         result = self.extradefinitions
 94512:         itemCount = 0
 94512:         for (memberList, separator) in order:
 94512:             (memberString, itemCount) = defineMembers(self, memberList,
 94512:                                                       itemCount, separator)
 94512:             result = result + memberString
 94512:         return result
 94512: 
109259: class CGResolveOwnProperty(CGAbstractMethod):
109259:     def __init__(self, descriptor):
109259:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'wrapper'),
120342:                 Argument('JSObject*', 'obj'), Argument('jsid', 'id'),
120342:                 Argument('bool', 'set'),
109259:                 Argument('JSPropertyDescriptor*', 'desc')]
109259:         CGAbstractMethod.__init__(self, descriptor, "ResolveOwnProperty", "bool", args)
109259:     def definition_body(self):
120342:         return """  // We rely on getOwnPropertyDescriptor not shadowing prototype properties by named
109259:   // properties. If that changes we'll need to filter here.
109259:   return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, set, desc);
109259: """
109259: 
109259: class CGEnumerateOwnProperties(CGAbstractMethod):
109259:     def __init__(self, descriptor):
109259:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'wrapper'),
120342:                 Argument('JSObject*', 'obj'),
109259:                 Argument('JS::AutoIdVector&', 'props')]
109259:         CGAbstractMethod.__init__(self, descriptor, "EnumerateOwnProperties", "bool", args)
109259:     def definition_body(self):
120342:         return """  // We rely on getOwnPropertyNames not shadowing prototype properties by named
109259:   // properties. If that changes we'll need to filter here.
109259:   return js::GetProxyHandler(obj)->getOwnPropertyNames(cx, wrapper, props);
109259: """
109259: 
 94512: class CGPrototypeTraitsClass(CGClass):
 94512:     def __init__(self, descriptor, indent=''):
 94512:         templateArgs = [Argument('prototypes::ID', 'PrototypeID')]
 94512:         templateSpecialization = ['prototypes::id::' + descriptor.name]
 94512:         enums = [ClassEnum('', ['Depth'],
 94512:                            [descriptor.interface.inheritanceDepth()])]
 94512:         typedefs = [ClassTypedef('NativeType', descriptor.nativeType)]
 94512:         CGClass.__init__(self, 'PrototypeTraits', indent=indent,
 94512:                          templateArgs=templateArgs,
 94512:                          templateSpecialization=templateSpecialization,
 94512:                          enums=enums, typedefs=typedefs, isStruct=True)
 94512: 
 94512: class CGPrototypeIDMapClass(CGClass):
 94512:     def __init__(self, descriptor, indent=''):
 94512:         templateArgs = [Argument('class', 'ConcreteClass')]
 94512:         templateSpecialization = [descriptor.nativeType]
 94512:         enums = [ClassEnum('', ['PrototypeID'],
 94512:                            ['prototypes::id::' + descriptor.name])]
 94512:         CGClass.__init__(self, 'PrototypeIDMap', indent=indent,
 94512:                          templateArgs=templateArgs,
 94512:                          templateSpecialization=templateSpecialization,
 94512:                          enums=enums, isStruct=True)
 94512: 
 94512: class CGClassForwardDeclare(CGThing):
 94512:     def __init__(self, name, isStruct=False):
 94512:         CGThing.__init__(self)
 94512:         self.name = name
 94512:         self.isStruct = isStruct
 94512:     def declare(self):
 94512:         type = 'struct' if self.isStruct else 'class'
 94512:         return '%s %s;\n' % (type, self.name)
 94512:     def define(self):
 94512:         # Header only
 94512:         return ''
 94512: 
109136: class CGProxySpecialOperation(CGPerSignatureCall):
109136:     """
109136:     Base class for classes for calling an indexed or named special operation
109136:     (don't use this directly, use the derived classes below).
109136:     """
109136:     def __init__(self, descriptor, operation):
109136:         nativeName = MakeNativeName(descriptor.binaryNames.get(operation, operation))
109136:         operation = descriptor.operations[operation]
109136:         assert len(operation.signatures()) == 1
109136:         signature = operation.signatures()[0]
109136:         extendedAttributes = descriptor.getExtendedAttributes(operation)
109136: 
109136:         (returnType, arguments) = signature
109136: 
109136:         # We pass len(arguments) as the final argument so that the
109136:         # CGPerSignatureCall won't do any argument conversion of its own.
109136:         CGPerSignatureCall.__init__(self, returnType, "", arguments, nativeName,
109136:                                     False, descriptor, operation,
109136:                                     len(arguments))
109136: 
109136:         if operation.isSetter() or operation.isCreator():
109136:             # arguments[0] is the index or name of the item that we're setting.
109136:             argument = arguments[1]
109260:             template = getJSToNativeConversionTemplate(argument.type, descriptor,
109260:                                                        treatNullAs=argument.treatNullAs,
109260:                                                        treatUndefinedAs=argument.treatUndefinedAs)
109136:             templateValues = {
109136:                 "declName": argument.identifier.name,
109136:                 "holderName": argument.identifier.name + "_holder",
109136:                 "val": "desc->value",
121479:                 "valPtr": "&desc->value",
121479:                 "obj": "obj"
109136:             }
109136:             self.cgRoot.prepend(instantiateJSToNativeConversionTemplate(template, templateValues))
120968:         elif operation.isGetter() or operation.isDeleter():
109136:             self.cgRoot.prepend(CGGeneric("bool found;"))
109136: 
109136:     def getArguments(self):
109136:         args = [(a, a.identifier.name) for a in self.arguments]
120968:         if self.idlNode.isGetter() or self.idlNode.isDeleter():
110955:             args.append((FakeArgument(BuiltinTypes[IDLBuiltinType.Types.boolean],
110955:                                       self.idlNode),
110955:                          "found"))
109136:         return args
109136: 
109136:     def wrap_return_value(self):
109136:         if not self.idlNode.isGetter() or self.templateValues is None:
109136:             return ""
109136: 
109136:         wrap = CGGeneric(wrapForType(self.returnType, self.descriptor, self.templateValues))
109136:         wrap = CGIfWrapper(wrap, "found")
109136:         return "\n" + wrap.define()
109136: 
121059: class CGProxyIndexedOperation(CGProxySpecialOperation):
121059:     """
121059:     Class to generate a call to an indexed operation.
121059:     """
121059:     def __init__(self, descriptor, name):
121059:         CGProxySpecialOperation.__init__(self, descriptor, name)
121059:     def define(self):
121059:         # Our first argument is the id we're getting.
121059:         argName = self.arguments[0].identifier.name
121059:         if argName == "index":
121059:             # We already have our index in a variable with that name
121059:             setIndex = ""
121059:         else:
121059:             setIndex = "uint32_t %s = index;\n" % argName
121059:         return (setIndex +
121059:                 "%s* self = UnwrapProxy(proxy);\n" +
121059:                 CGProxySpecialOperation.define(self))
121059: 
121059: class CGProxyIndexedGetter(CGProxyIndexedOperation):
109136:     """
109136:     Class to generate a call to an indexed getter. If templateValues is not None
109136:     the returned value will be wrapped with wrapForType using templateValues.
109136:     """
109136:     def __init__(self, descriptor, templateValues=None):
109136:         self.templateValues = templateValues
121436:         CGProxyIndexedOperation.__init__(self, descriptor, 'IndexedGetter')
109136: 
120973: class CGProxyIndexedPresenceChecker(CGProxyIndexedGetter):
120973:     """
120973:     Class to generate a call that checks whether an indexed property exists.
120973: 
120973:     For now, we just delegate to CGProxyIndexedGetter
120973:     """
120973:     def __init__(self, descriptor):
120973:         CGProxyIndexedGetter.__init__(self, descriptor)
121691:         self.cgRoot.append(CGGeneric("(void)result;"))
120973: 
121059: class CGProxyIndexedSetter(CGProxyIndexedOperation):
109136:     """
109136:     Class to generate a call to an indexed setter.
109136:     """
109136:     def __init__(self, descriptor):
121436:         CGProxyIndexedOperation.__init__(self, descriptor, 'IndexedSetter')
109136: 
121058: class CGProxyNamedOperation(CGProxySpecialOperation):
121058:     """
121058:     Class to generate a call to a named operation.
121436: 
121436:     'value' is the jsval to use for the name; None indicates that it should be
121436:     gotten from the property id.
121436:     """
121436:     def __init__(self, descriptor, name, value=None):
121058:         CGProxySpecialOperation.__init__(self, descriptor, name)
121436:         if value is None:
121436:             value = "js::IdToValue(id)"
121436:         self.value = value
121058:     def define(self):
121058:         # Our first argument is the id we're getting.
121058:         argName = self.arguments[0].identifier.name
121436:         return (("JS::Value nameVal = %s;\n"
121058:                  "FakeDependentString %s;\n"
121058:                  "if (!ConvertJSValueToString(cx, nameVal, &nameVal,\n"
121058:                  "                            eStringify, eStringify, %s)) {\n"
121058:                  "  return false;\n"
121058:                  "}\n"
121058:                  "\n"
121058:                  "%s* self = UnwrapProxy(proxy);\n" %
121436:                  (self.value, argName, argName, self.descriptor.nativeType)) +
121058:                 CGProxySpecialOperation.define(self))
121058: 
121058: class CGProxyNamedGetter(CGProxyNamedOperation):
109136:     """
109136:     Class to generate a call to an named getter. If templateValues is not None
109136:     the returned value will be wrapped with wrapForType using templateValues.
121436:     'value' is the jsval to use for the name; None indicates that it should be
121436:     gotten from the property id.
121436:     """
121436:     def __init__(self, descriptor, templateValues=None, value=None):
109136:         self.templateValues = templateValues
121436:         CGProxyNamedOperation.__init__(self, descriptor, 'NamedGetter', value)
109136: 
120973: class CGProxyNamedPresenceChecker(CGProxyNamedGetter):
120973:     """
120973:     Class to generate a call that checks whether a named property exists.
120973: 
120973:     For now, we just delegate to CGProxyNamedGetter
120973:     """
120973:     def __init__(self, descriptor):
120973:         CGProxyNamedGetter.__init__(self, descriptor)
121691:         self.cgRoot.append(CGGeneric("(void)result;"))
120973: 
121058: class CGProxyNamedSetter(CGProxyNamedOperation):
109136:     """
109136:     Class to generate a call to a named setter.
109136:     """
109136:     def __init__(self, descriptor):
121436:         CGProxyNamedOperation.__init__(self, descriptor, 'NamedSetter')
109136: 
121059: class CGProxyIndexedDeleter(CGProxyIndexedOperation):
120968:     """
120968:     Class to generate a call to an indexed deleter.
120968:     """
120968:     def __init__(self, descriptor):
121436:         CGProxyIndexedOperation.__init__(self, descriptor, 'IndexedDeleter')
120968: 
121058: class CGProxyNamedDeleter(CGProxyNamedOperation):
120968:     """
120968:     Class to generate a call to a named deleter.
120968:     """
120968:     def __init__(self, descriptor):
121436:         CGProxyNamedOperation.__init__(self, descriptor, 'NamedDeleter')
120968: 
109136: class CGProxyIsProxy(CGAbstractMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSObject*', 'obj')]
109136:         CGAbstractMethod.__init__(self, descriptor, "IsProxy", "bool", args, alwaysInline=True)
109136:     def declare(self):
109136:         return ""
109136:     def definition_body(self):
111270:         return "  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();"
109136: 
109136: class CGProxyUnwrap(CGAbstractMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSObject*', 'obj')]
109136:         CGAbstractMethod.__init__(self, descriptor, "UnwrapProxy", descriptor.nativeType + '*', args, alwaysInline=True)
109136:     def declare(self):
109136:         return ""
109136:     def definition_body(self):
109136:         return """  if (xpc::WrapperFactory::IsXrayWrapper(obj)) {
109136:     obj = js::UnwrapObject(obj);
109136:   }
109136:   MOZ_ASSERT(IsProxy(obj));
109136:   return static_cast<%s*>(js::GetProxyPrivate(obj).toPrivate());""" % (self.descriptor.nativeType)
109136: 
109136: class CGDOMJSProxyHandlerDOMClass(CGThing):
109136:     def __init__(self, descriptor):
109136:         CGThing.__init__(self)
109136:         self.descriptor = descriptor
109136:     def declare(self):
109136:         return "extern const DOMClass Class;\n"
109136:     def define(self):
109136:         return """
109136: const DOMClass Class = """ + DOMClass(self.descriptor) + """;
109136: 
109136: """
109136: 
109136: class CGDOMJSProxyHandler_CGDOMJSProxyHandler(ClassConstructor):
109136:     def __init__(self):
111270:         ClassConstructor.__init__(self, [], inline=True, visibility="private",
109136:                                   baseConstructors=["mozilla::dom::DOMProxyHandler(Class)"],
109136:                                   body="")
109136: 
109136: class CGDOMJSProxyHandler_getOwnPropertyDescriptor(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
109136:                 Argument('jsid', 'id'), Argument('bool', 'set'),
109136:                 Argument('JSPropertyDescriptor*', 'desc')]
109136:         ClassMethod.__init__(self, "getOwnPropertyDescriptor", "bool", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
109136:         indexedGetter = self.descriptor.operations['IndexedGetter']
109136:         indexedSetter = self.descriptor.operations['IndexedSetter']
109136: 
109136:         setOrIndexedGet = ""
120973:         if self.descriptor.supportsIndexedProperties():
109136:             setOrIndexedGet += "int32_t index = GetArrayIndexFromId(cx, id);\n"
120973:             readonly = toStringBool(indexedSetter is None)
109136:             fillDescriptor = "FillPropertyDescriptor(desc, proxy, %s);\nreturn true;" % readonly
109136:             templateValues = {'jsvalRef': 'desc->value', 'jsvalPtr': '&desc->value',
109136:                               'obj': 'proxy', 'successCode': fillDescriptor}
121436:             get = ("if (IsArrayIndex(index)) {\n" +
109136:                    CGIndenter(CGProxyIndexedGetter(self.descriptor, templateValues)).define() + "\n" +
109136:                    "}\n") % (self.descriptor.nativeType)
109136: 
109136:         if indexedSetter or self.descriptor.operations['NamedSetter']:
109136:             setOrIndexedGet += "if (set) {\n"
109136:             if indexedSetter:
121436:                 setOrIndexedGet += ("  if (IsArrayIndex(index)) {\n")
109136:                 if not 'IndexedCreator' in self.descriptor.operations:
121436:                     # FIXME need to check that this is a 'supported property
121436:                     # index'.  But if that happens, watch out for the assumption
121436:                     # below that the name setter always returns for
121436:                     # IsArrayIndex(index).
109136:                     assert False
109136:                 setOrIndexedGet += ("    FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);\n" +
109136:                                     "    return true;\n" +
109136:                                     "  }\n")
109136:             if self.descriptor.operations['NamedSetter']:
109136:                 if not 'NamedCreator' in self.descriptor.operations:
109136:                     # FIXME need to check that this is a 'supported property name'
109136:                     assert False
121436:                 create = CGGeneric("FillPropertyDescriptor(desc, proxy, JSVAL_VOID, false);\n"
121436:                                    "return true;")
121436:                 # If we have an indexed setter we've already returned
121436:                 if (self.descriptor.supportsIndexedProperties() and
121436:                     not indexedSetter):
121436:                     create = CGIfWrapper(create, "!IsArrayIndex(index)")
121436:                 setOrIndexedGet += CGIndenter(create).define() + "\n"
109136:             setOrIndexedGet += "}"
109136:             if indexedGetter:
109136:                 setOrIndexedGet += (" else {\n" +
109136:                                     CGIndenter(CGGeneric(get)).define() +
109136:                                     "}")
109136:             setOrIndexedGet += "\n\n"
109136:         elif indexedGetter:
109136:             setOrIndexedGet += ("if (!set) {\n" +
109136:                                 CGIndenter(CGGeneric(get)).define() +
109136:                                 "}\n\n")
109136: 
120973:         if self.descriptor.supportsNamedProperties():
109136:             readonly = toStringBool(self.descriptor.operations['NamedSetter'] is None)
109136:             fillDescriptor = "FillPropertyDescriptor(desc, proxy, %s);\nreturn true;" % readonly
109136:             templateValues = {'jsvalRef': 'desc->value', 'jsvalPtr': '&desc->value',
109136:                               'obj': 'proxy', 'successCode': fillDescriptor}
109259:             # Once we start supporting OverrideBuiltins we need to make
109259:             # ResolveOwnProperty or EnumerateOwnProperties filter out named
109259:             # properties that shadow prototype properties.
121436:             condition = "!set && !HasPropertyOnPrototype(cx, proxy, this, id)"
121436:             if self.descriptor.supportsIndexedProperties():
121436:                 condition = "!IsArrayIndex(index) && " + condition
109136:             namedGet = ("\n" +
121436:                         CGIfWrapper(CGProxyNamedGetter(self.descriptor, templateValues),
121436:                                     condition).define() +
121436:                         "\n")
109136:         else:
109136:             namedGet = ""
109136: 
109136:         return setOrIndexedGet + """JSObject* expando;
109136: if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = GetExpandoObject(proxy))) {
109136:   unsigned flags = (set ? JSRESOLVE_ASSIGNING : 0) | JSRESOLVE_QUALIFIED;
109136:   if (!JS_GetPropertyDescriptorById(cx, expando, id, flags, desc)) {
109136:     return false;
109136:   }
109136:   if (desc->obj) {
109136:     // Pretend the property lives on the wrapper.
109136:     desc->obj = proxy;
109136:     return true;
109136:   }
109136: }
109136: """ + namedGet + """
109136: desc->obj = NULL;
109136: return true;"""
109136: 
109136: class CGDOMJSProxyHandler_defineProperty(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
109136:                 Argument('jsid', 'id'),
109136:                 Argument('JSPropertyDescriptor*', 'desc')]
109136:         ClassMethod.__init__(self, "defineProperty", "bool", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
109136:         set = ""
109136: 
109136:         indexedSetter = self.descriptor.operations['IndexedSetter']
109136:         if indexedSetter:
109136:             if not (self.descriptor.operations['IndexedCreator'] is indexedSetter):
109136:                 raise TypeError("Can't handle creator that's different from the setter")
109136:             set += ("int32_t index = GetArrayIndexFromId(cx, id);\n" +
121436:                     "if (IsArrayIndex(index)) {\n" +
109136:                     CGIndenter(CGProxyIndexedSetter(self.descriptor)).define() +
109136:                     "  return true;\n" +
109136:                     "}\n") % (self.descriptor.nativeType)
120973:         elif self.descriptor.supportsIndexedProperties():
121436:             # XXXbz Once this is fixed to only throw in strict mode, update the
121436:             # code that decides whether to do a
121436:             # CGDOMJSProxyHandler_defineProperty at all.
121436:             set += ("if (IsArrayIndex(GetArrayIndexFromId(cx, id))) {\n" +
109136:                     "  return ThrowErrorMessage(cx, MSG_NO_PROPERTY_SETTER, \"%s\");\n" +
109136:                     "}\n") % self.descriptor.name
111238: 
109136:         namedSetter = self.descriptor.operations['NamedSetter']
109136:         if namedSetter:
109136:             if not self.descriptor.operations['NamedCreator'] is namedSetter:
109136:                 raise TypeError("Can't handle creator that's different from the setter")
121436:             # If we support indexed properties, we won't get down here for
121436:             # indices, so we can just do our setter unconditionally here.
121436:             set += (CGProxyNamedSetter(self.descriptor).define() + "\n" +
121436:                     "return true;\n")
121436:         else:
121436:             if self.descriptor.supportsNamedProperties():
121436:                 # XXXbz Once this is fixed to only throw in strict mode, update
121436:                 # the code that decides whether to do a
121436:                 # CGDOMJSProxyHandler_defineProperty at all.  If we support
121436:                 # indexed properties, we won't get down here for indices, so we
121436:                 # can just do our setter unconditionally here.
121436:                 set += (CGProxyNamedPresenceChecker(self.descriptor).define() + "\n" +
109136:                         "if (found) {\n"
121436:                         "  return ThrowErrorMessage(cx, MSG_NO_PROPERTY_SETTER, \"%s\");\n"
121436:                         "}" % self.descriptor.name)
121436:             set += ("return mozilla::dom::DOMProxyHandler::defineProperty(%s);" %
121436:                     ", ".join(a.name for a in self.args))
121436:         return set
109136: 
120968: class CGDOMJSProxyHandler_delete(ClassMethod):
120968:     def __init__(self, descriptor):
120968:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
120968:                 Argument('jsid', 'id'),
120968:                 Argument('bool*', 'bp')]
120968:         ClassMethod.__init__(self, "delete_", "bool", args)
120968:         self.descriptor = descriptor
120968: 
120968:     def getBody(self):
120968:         def getDeleterBody(type):
120968:             """
120968:             type should be "Named" or "Indexed"
120968:             """
120968:             assert type is "Named" or type is "Indexed"
120968:             deleter = self.descriptor.operations[type + 'Deleter']
120968:             if deleter:
120968:                 if (not deleter.signatures()[0][0].isPrimitive() or
120968:                     deleter.signatures()[0][0].nullable() or
120968:                     deleter.signatures()[0][0].tag() != IDLType.Tags.bool):
120968:                     setBp = "*bp = true;"
120968:                 else:
120968:                     setBp = ("if (found) {\n"
120968:                              "  // XXXbz we should throw as needed if Throw is true\n"
120968:                              "  *bp = result;\n"
120968:                              "} else {\n"
120968:                              "  *bp = true;\n"
120968:                              "}")
120968:                 body = (eval("CGProxy%sDeleter" % type)(self.descriptor).define() +
120968:                         setBp)
120973:             elif eval("self.descriptor.supports%sProperties()" % type):
120973:                 body = (eval("CGProxy%sPresenceChecker" % type)(self.descriptor).define() +
120968:                         "if (found) {\n"
120968:                         "  // XXXbz we should throw if Throw is true!\n"
120968:                         "  *bp = false;\n"
120968:                         "} else {\n"
120968:                         "  *bp = true;\n"
120968:                         "}")
120968:             else:
120968:                 body = None
120968:             return body
120968: 
120968:         delete = ""
120968: 
120968:         indexedBody = getDeleterBody("Indexed")
120968:         if indexedBody is not None:
120968:             delete += ("int32_t index = GetArrayIndexFromId(cx, id);\n" +
121436:                        "if (IsArrayIndex(index)) {\n" +
120968:                        CGIndenter(CGGeneric(indexedBody)).define() + "\n"
120968:                        "  // We always return here, even if the property was not found\n"
120968:                        "  return true;\n" +
120968:                        "}\n") % self.descriptor.nativeType
120968: 
120968:         namedBody = getDeleterBody("Named")
120968:         if namedBody is not None:
121436:             # We always return above for an index id in the case when we support
121436:             # indexed properties, so we can just treat the id as a name
121436:             # unconditionally here.
121436:             delete += ("if (!HasPropertyOnPrototype(cx, proxy, this, id)) {\n" +
120968:                        CGIndenter(CGGeneric(namedBody)).define() + "\n"
120968:                        "  if (found) {\n"
120968:                        "    return true;\n"
120968:                        "  }\n"
121058:                        "}\n")
120968: 
120968:         delete += "return dom::DOMProxyHandler::delete_(cx, proxy, id, bp);";
120968: 
120968:         return delete
120968: 
109136: class CGDOMJSProxyHandler_getOwnPropertyNames(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
109136:                 Argument('JS::AutoIdVector&', 'props')]
109136:         ClassMethod.__init__(self, "getOwnPropertyNames", "bool", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
120972:         # Per spec, we do indices, then named props, then everything else
120973:         if self.descriptor.supportsIndexedProperties():
113697:             addIndices = """uint32_t length = UnwrapProxy(proxy)->Length();
109136: MOZ_ASSERT(int32_t(length) >= 0);
109136: for (int32_t i = 0; i < int32_t(length); ++i) {
109136:   if (!props.append(INT_TO_JSID(i))) {
109136:     return false;
109136:   }
109136: }
109136: 
109136: """
109136:         else:
109136:             addIndices = ""
109136: 
120973:         if self.descriptor.supportsNamedProperties():
120972:             addNames = """nsTArray<nsString> names;
120972: UnwrapProxy(proxy)->GetSupportedNames(names);
120972: if (!AppendNamedPropertyIds(cx, proxy, names, props)) {
120972:   return false;
120972: }
120972: 
120972: """
120972:         else:
120972:             addNames = ""
120972: 
120972:         return addIndices + addNames + """JSObject* expando;
109136: if (!xpc::WrapperFactory::IsXrayWrapper(proxy) && (expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
109136:     !js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props)) {
109136:   return false;
109136: }
109136: 
109136: return true;"""
109136: 
109136: class CGDOMJSProxyHandler_hasOwn(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
109136:                 Argument('jsid', 'id'), Argument('bool*', 'bp')]
109136:         ClassMethod.__init__(self, "hasOwn", "bool", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
120973:         if self.descriptor.supportsIndexedProperties():
109136:             indexed = ("int32_t index = GetArrayIndexFromId(cx, id);\n" + 
121436:                        "if (IsArrayIndex(index)) {\n" +
120973:                        CGIndenter(CGProxyIndexedPresenceChecker(self.descriptor)).define() + "\n" +
109136:                        "  *bp = found;\n" +
109136:                        "  return true;\n" +
109136:                        "}\n\n") % (self.descriptor.nativeType)
109136:         else:
109136:             indexed = ""
109136: 
120973:         if self.descriptor.supportsNamedProperties():
121436:             # If we support indexed properties we always return above for index
121436:             # property names, so no need to check for those here.
121436:             named = ("if (!HasPropertyOnPrototype(cx, proxy, this, id)) {\n" +
120973:                      CGIndenter(CGProxyNamedPresenceChecker(self.descriptor)).define() + "\n" +
109136:                      "  *bp = found;\n"
109136:                      "  return true;\n"
109136:                      "}\n" +
121058:                      "\n")
109136:         else:
109136:             named = ""
109136: 
109136:         return indexed + """JSObject* expando = GetExpandoObject(proxy);
109136: if (expando) {
109136:   JSBool b = true;
109136:   JSBool ok = JS_HasPropertyById(cx, expando, id, &b);
109136:   *bp = !!b;
109136:   if (!ok || *bp) {
109136:     return ok;
109136:   }
109136: }
109136: 
109136: """ + named + """*bp = false;
109136: return true;"""
109136: 
109136: class CGDOMJSProxyHandler_get(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
109136:                 Argument('JSObject*', 'receiver'), Argument('jsid', 'id'),
109136:                 Argument('JS::Value*', 'vp')]
109136:         ClassMethod.__init__(self, "get", "bool", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
109136:         getFromExpando = """JSObject* expando = DOMProxyHandler::GetExpandoObject(proxy);
109136: if (expando) {
109136:   JSBool hasProp;
109136:   if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
109136:     return false;
109136:   }
109136: 
109136:   if (hasProp) {
109136:     return JS_GetPropertyById(cx, expando, id, vp);
109136:   }
109136: }"""
109136: 
109136:         templateValues = {'jsvalRef': '*vp', 'jsvalPtr': 'vp', 'obj': 'proxy'}
109136: 
120973:         if self.descriptor.supportsIndexedProperties():
109136:             getIndexedOrExpando = ("int32_t index = GetArrayIndexFromId(cx, id);\n" +
121436:                                    "if (IsArrayIndex(index)) {\n" +
109136:                                    CGIndenter(CGProxyIndexedGetter(self.descriptor, templateValues)).define()) % (self.descriptor.nativeType)
109136:             getIndexedOrExpando += """
109136:   // Even if we don't have this index, we don't forward the
109136:   // get on to our expando object.
109136: } else {
109136:   %s
109136: }
109136: """ % (stripTrailingWhitespace(getFromExpando.replace('\n', '\n  ')))
109136:         else:
109136:             getIndexedOrExpando = getFromExpando + "\n"
109136: 
120973:         if self.descriptor.supportsNamedProperties():
121436:             getNamed = CGProxyNamedGetter(self.descriptor, templateValues)
121436:             if self.descriptor.supportsIndexedProperties():
121436:                 getNamed = CGIfWrapper(getNamed, "!IsArrayIndex(index)")
121436:             getNamed = getNamed.define() + "\n"
109136:         else:
109136:             getNamed = ""
109136: 
109136:         return """MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
109136:             "Should not have a XrayWrapper here");
109136: 
109136: %s
121436: {  // Scope for this "found" so it doesn't leak to things below
109136:   bool found;
109136:   if (!GetPropertyOnPrototype(cx, proxy, id, &found, vp)) {
109136:     return false;
109136:   }
109136: 
109136:   if (found) {
109136:     return true;
109136:   }
121436: }
109136: %s
109136: vp->setUndefined();
109136: return true;""" % (getIndexedOrExpando, getNamed)
109136: 
109136: class CGDOMJSProxyHandler_obj_toString(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy')]
109136:         ClassMethod.__init__(self, "obj_toString", "JSString*", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
109136:         return "return mozilla::dom::DOMProxyHandler::obj_toString(cx, \"%s\");" % self.descriptor.name
109136: 
109136: class CGDOMJSProxyHandler_finalize(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSFreeOp*', 'fop'), Argument('JSObject*', 'proxy')]
109136:         ClassMethod.__init__(self, "finalize", "void", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
109136:         return ("%s self = UnwrapProxy(proxy);\n\n" % (self.descriptor.nativeType + "*") +
109136:                 finalizeHook(self.descriptor, FINALIZE_HOOK_NAME, self.args[0].name))
109136: 
109136: class CGDOMJSProxyHandler_getElementIfPresent(ClassMethod):
109136:     def __init__(self, descriptor):
109136:         args = [Argument('JSContext*', 'cx'), Argument('JSObject*', 'proxy'),
109136:                 Argument('JSObject*', 'receiver'),
109136:                 Argument('uint32_t', 'index'),
109136:                 Argument('JS::Value*', 'vp'), Argument('bool*', 'present')]
109136:         ClassMethod.__init__(self, "getElementIfPresent", "bool", args)
109136:         self.descriptor = descriptor
109136:     def getBody(self):
121436:         successCode = ("*present = found;\n"
121436:                        "return true;")
109136:         templateValues = {'jsvalRef': '*vp', 'jsvalPtr': 'vp',
109136:                           'obj': 'proxy', 'successCode': successCode}
121436:         if self.descriptor.supportsIndexedProperties():
121059:             get = (CGProxyIndexedGetter(self.descriptor, templateValues).define() + "\n"
121436:                    "// We skip the expando object and any named getters if\n"
121436:                    "// there is an indexed getter.\n" +
109136:                    "\n") % (self.descriptor.nativeType)
109136:         else:
121436:             if self.descriptor.supportsNamedProperties():
121436:                 get = CGProxyNamedGetter(self.descriptor, templateValues,
121436:                                          "UINT_TO_JSVAL(index)").define()
121436:             get += """
109136: 
109136: JSObject* expando = GetExpandoObject(proxy);
109136: if (expando) {
109136:   JSBool isPresent;
109136:   if (!JS_GetElementIfPresent(cx, expando, index, expando, vp, &isPresent)) {
109136:     return false;
109136:   }
109136:   if (isPresent) {
109136:     *present = true;
109136:     return true;
109136:   }
109136: }
109136: """
109136: 
109136:         return """MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
109136:              "Should not have a XrayWrapper here");
109136: 
109136: """ + get + """
115022: JSObject *proto;
115022: if (!js::GetObjectProto(cx, proxy, &proto)) {
115022:   return false;
115022: }
109136: if (proto) {
109136:   JSBool isPresent;
109136:   if (!JS_GetElementIfPresent(cx, proto, index, proxy, vp, &isPresent)) {
109136:     return false;
109136:   }
109136:   *present = isPresent;
109136:   return true;
109136: }
109136: 
109136: *present = false;
109136: // Can't Debug_SetValueRangeToCrashOnTouch because it's not public
109136: return true;"""
109136: 
111270: class CGDOMJSProxyHandler_getInstance(ClassMethod):
111270:     def __init__(self):
111270:         ClassMethod.__init__(self, "getInstance", "DOMProxyHandler*", [], static=True)
111270:     def getBody(self):
111270:         return """static DOMProxyHandler instance;
111270: return &instance;"""
111270: 
109136: class CGDOMJSProxyHandler(CGClass):
109136:     def __init__(self, descriptor):
109136:         constructors = [CGDOMJSProxyHandler_CGDOMJSProxyHandler()]
109136:         methods = [CGDOMJSProxyHandler_getOwnPropertyDescriptor(descriptor)]
121436:         # XXXbz This should really just test supportsIndexedProperties() and
121436:         # supportsNamedProperties(), but that would make us throw in all cases
121436:         # because we don't know whether we're in strict mode.
109136:         if descriptor.operations['IndexedSetter'] or descriptor.operations['NamedSetter']:
109136:             methods.append(CGDOMJSProxyHandler_defineProperty(descriptor))
109136:         methods.extend([CGDOMJSProxyHandler_getOwnPropertyNames(descriptor),
109136:                         CGDOMJSProxyHandler_hasOwn(descriptor),
109136:                         CGDOMJSProxyHandler_get(descriptor),
109136:                         CGDOMJSProxyHandler_obj_toString(descriptor),
109136:                         CGDOMJSProxyHandler_finalize(descriptor),
111270:                         CGDOMJSProxyHandler_getElementIfPresent(descriptor),
120968:                         CGDOMJSProxyHandler_getInstance(),
120968:                         CGDOMJSProxyHandler_delete(descriptor)])
109136:         CGClass.__init__(self, 'DOMProxyHandler',
109136:                          bases=[ClassBase('mozilla::dom::DOMProxyHandler')],
109136:                          constructors=constructors,
109136:                          methods=methods)
109136: 
 94512: def stripTrailingWhitespace(text):
113683:     tail = '\n' if text.endswith('\n') else ''
 94512:     lines = text.splitlines()
 94512:     for i in range(len(lines)):
 94512:         lines[i] = lines[i].rstrip()
113683:     return '\n'.join(lines) + tail
 94512: 
 94512: class CGDescriptor(CGThing):
 94512:     def __init__(self, descriptor):
 94512:         CGThing.__init__(self)
 94512: 
 94512:         assert not descriptor.concrete or descriptor.interface.hasInterfacePrototypeObject()
 94512: 
 94512:         cgThings = []
120397:         # These are set to true if at least one non-static
120397:         # method/getter/setter exist on the interface.
113773:         (hasMethod, hasGetter, hasLenientGetter,
113773:          hasSetter, hasLenientSetter) = False, False, False, False, False
107784:         for m in descriptor.interface.members:
120397:             if (m.isMethod() and
119692:                 (not m.isIdentifierLess() or m == descriptor.operations['Stringifier'])):
120397:                 if m.isStatic():
121325:                     assert descriptor.interface.hasInterfaceObject
120397:                     cgThings.append(CGStaticMethod(descriptor, m))
121325:                 elif descriptor.interface.hasInterfacePrototypeObject():
107787:                     cgThings.append(CGSpecializedMethod(descriptor, m))
107787:                     cgThings.append(CGMemberJITInfo(descriptor, m))
107793:                     hasMethod = True
107784:             elif m.isAttr():
120397:                 if m.isStatic():
121325:                     assert descriptor.interface.hasInterfaceObject
120397:                     cgThings.append(CGStaticGetter(descriptor, m))
121325:                 elif descriptor.interface.hasInterfacePrototypeObject():
107784:                     cgThings.append(CGSpecializedGetter(descriptor, m))
113773:                     if m.hasLenientThis():
113773:                         hasLenientGetter = True
113773:                     else:
107793:                         hasGetter = True
107784:                 if not m.readonly:
120397:                     if m.isStatic():
121325:                         assert descriptor.interface.hasInterfaceObject
120397:                         cgThings.append(CGStaticSetter(descriptor, m))
121325:                     elif descriptor.interface.hasInterfacePrototypeObject():
107784:                         cgThings.append(CGSpecializedSetter(descriptor, m))
113773:                         if m.hasLenientThis():
113773:                             hasLenientSetter = True
113773:                         else:
107793:                             hasSetter = True
120321:                 elif m.getExtendedAttribute("PutForwards"):
120321:                     cgThings.append(CGSpecializedForwardingSetter(descriptor, m))
120321:                     hasSetter = True
121325:                 if (not m.isStatic() and
121325:                     descriptor.interface.hasInterfacePrototypeObject()):
107787:                     cgThings.append(CGMemberJITInfo(descriptor, m))
107793:         if hasMethod: cgThings.append(CGGenericMethod(descriptor))
107793:         if hasGetter: cgThings.append(CGGenericGetter(descriptor))
113773:         if hasLenientGetter: cgThings.append(CGGenericGetter(descriptor,
113773:                                                              lenientThis=True))
107793:         if hasSetter: cgThings.append(CGGenericSetter(descriptor))
113773:         if hasLenientSetter: cgThings.append(CGGenericSetter(descriptor,
113773:                                                              lenientThis=True))
107793: 
115607:         if descriptor.concrete:
115607:             if descriptor.nativeOwnership == 'owned' or descriptor.nativeOwnership == 'refcounted':
115607:                 cgThings.append(CGDeferredFinalizePointers(descriptor))
115607:                 cgThings.append(CGGetDeferredFinalizePointers(descriptor))
115607:                 cgThings.append(CGDeferredFinalize(descriptor))
115607: 
115607:             if not descriptor.proxy:
102142:                 if not descriptor.workers and descriptor.wrapperCache:
 94512:                     cgThings.append(CGAddPropertyHook(descriptor))
 94512: 
115607:                 # Always have a finalize hook, regardless of whether the class
115607:                 # wants a custom hook.
 94512:                 cgThings.append(CGClassFinalizeHook(descriptor))
 94512: 
 94512:                 # Only generate a trace hook if the class wants a custom hook.
 94512:                 if (descriptor.customTrace):
 94512:                     cgThings.append(CGClassTraceHook(descriptor))
 94512: 
120342:         properties = PropertyArrays(descriptor)
120342:         cgThings.append(CGGeneric(define=str(properties)))
120342:         cgThings.append(CGNativeProperties(descriptor, properties))
120342: 
120342:         cgThings.append(CGNativePropertyHooks(descriptor, properties))
120342: 
 94512:         if descriptor.interface.hasInterfaceObject():
 94512:             cgThings.append(CGClassConstructHook(descriptor))
 94512:             cgThings.append(CGClassHasInstanceHook(descriptor))
120342:             cgThings.append(CGInterfaceObjectJSClass(descriptor, properties))
120342:             cgThings.append(CGClassConstructHookHolder(descriptor))
 94512: 
 94512:         if descriptor.interface.hasInterfacePrototypeObject():
120342:             cgThings.append(CGPrototypeJSClass(descriptor, properties))
120342: 
 94512:         cgThings.append(CGCreateInterfaceObjectsMethod(descriptor, properties))
 94512:         if descriptor.interface.hasInterfacePrototypeObject():
109136:             cgThings.append(CGGetProtoObjectMethod(descriptor))
120342:         if descriptor.interface.hasInterfaceObject():
109136:             cgThings.append(CGGetConstructorObjectMethod(descriptor))
 94512: 
 99238:         # Set up our Xray callbacks as needed.  Note that we don't need to do
 99238:         # it in workers.
120342:         if not descriptor.workers and descriptor.concrete and descriptor.proxy:
109259:             cgThings.append(CGResolveOwnProperty(descriptor))
109259:             cgThings.append(CGEnumerateOwnProperties(descriptor))
 94512: 
 94512:         if descriptor.interface.hasInterfaceObject():
 94512:             cgThings.append(CGDefineDOMInterfaceMethod(descriptor))
111182:             if (not descriptor.interface.isExternal() and
111182:                 # Workers stuff is never pref-controlled
111182:                 not descriptor.workers and
111182:                 descriptor.interface.getExtendedAttribute("PrefControlled") is not None):
111182:                 cgThings.append(CGPrefEnabled(descriptor))
 94512: 
 94512:         if descriptor.concrete:
109136:             if descriptor.proxy:
109136:                 cgThings.append(CGProxyIsProxy(descriptor))
109136:                 cgThings.append(CGProxyUnwrap(descriptor))
109136:                 cgThings.append(CGDOMJSProxyHandlerDOMClass(descriptor))
109136:                 cgThings.append(CGDOMJSProxyHandler(descriptor))
109136:                 cgThings.append(CGIsMethod(descriptor))
109136:             else:
109136:                 cgThings.append(CGDOMJSClass(descriptor))
109136: 
102142:             if descriptor.wrapperCache:
119931:                 cgThings.append(CGWrapWithCacheMethod(descriptor, properties))
 94512:                 cgThings.append(CGWrapMethod(descriptor))
102142:             else:
119931:                 cgThings.append(CGWrapNonWrapperCacheMethod(descriptor,
119931:                                                             properties))
 94512: 
109136:         cgThings = CGList((CGIndenter(t, declareOnly=True) for t in cgThings), "\n")
109136:         cgThings = CGWrapper(cgThings, pre='\n', post='\n')
 97422:         self.cgRoot = CGWrapper(CGNamespace(toBindingNamespace(descriptor.name),
 97422:                                             cgThings),
 94512:                                 post='\n')
 94512: 
 94512:     def declare(self):
 94512:         return self.cgRoot.declare()
 94512:     def define(self):
 94512:         return self.cgRoot.define()
 94512: 
 94512: class CGNamespacedEnum(CGThing):
 94512:     def __init__(self, namespace, enumName, names, values, comment=""):
 94512: 
 94512:         if not values:
 94512:             values = []
 94512: 
 94512:         # Account for explicit enum values.
 94512:         entries = []
 94512:         for i in range(0, len(names)):
 94512:             if len(values) > i and values[i] is not None:
 94512:                 entry = "%s = %s" % (names[i], values[i])
 94512:             else:
 94512:                 entry = names[i]
 94512:             entries.append(entry)
 94512: 
 94512:         # Append a Count.
 94512:         entries.append('_' + enumName + '_Count')
 94512: 
 94512:         # Indent.
 94512:         entries = ['  ' + e for e in entries]
 94512: 
 94512:         # Build the enum body.
 94512:         enumstr = comment + 'enum %s\n{\n%s\n};\n' % (enumName, ',\n'.join(entries))
 94512:         curr = CGGeneric(declare=enumstr)
 94512: 
 94512:         # Add some whitespace padding.
 94512:         curr = CGWrapper(curr, pre='\n',post='\n')
 94512: 
 94512:         # Add the namespace.
 94512:         curr = CGNamespace(namespace, curr)
 94512: 
 94512:         # Add the typedef
 94512:         typedef = '\ntypedef %s::%s %s;\n\n' % (namespace, enumName, enumName)
 94512:         curr = CGList([curr, CGGeneric(declare=typedef)])
 94512: 
 94512:         # Save the result.
 94512:         self.node = curr
 94512: 
 94512:     def declare(self):
 94512:         return self.node.declare()
 94512:     def define(self):
 94512:         assert False # Only for headers.
 94512: 
101766: class CGDictionary(CGThing):
102326:     def __init__(self, dictionary, descriptorProvider):
121324:         self.dictionary = dictionary
119693:         self.descriptorProvider = descriptorProvider
102326:         self.workers = descriptorProvider.workers
121324:         self.needToInitIds = not self.workers and len(dictionary.members) > 0
106694:         if all(CGDictionary(d, descriptorProvider).generatable for
106694:                d in CGDictionary.getDictionaryDependencies(dictionary)):
106694:             self.generatable = True
106694:         else:
106694:             self.generatable = False
102326:             # Nothing else to do here
102326:             return
102326:         # Getting a conversion template for interface types can fail
102326:         # if we don't have a relevant descriptor when self.workers is True.
102326:         # If that happens, just mark ourselves as not being
102326:         # generatable and move on.
102326:         try:
101766:             self.memberInfo = [
101766:                 (member,
101766:                  getJSToNativeConversionTemplate(member.type,
102326:                                                  descriptorProvider,
101766:                                                  isMember=True,
106942:                                                  isOptional=(not member.defaultValue),
106942:                                                  defaultValue=member.defaultValue))
101766:                 for member in dictionary.members ]
102326:         except NoSuchDescriptorError, err:
102326:             if not self.workers:
102326:                 raise err
102326:             self.generatable = False
101766: 
101766:     def declare(self):
102326:         if not self.generatable:
102326:             return ""
101766:         d = self.dictionary
101766:         if d.parent:
101766:             inheritance = ": public %s " % self.makeClassName(d.parent)
119028:         elif not self.workers:
119028:             inheritance = ": public MainThreadDictionaryBase "
101766:         else:
101766:             inheritance = ""
101766:         memberDecls = ["  %s %s;" %
101766:                        (self.getMemberType(m), m[0].identifier.name)
101766:                        for m in self.memberInfo]
101766: 
101766:         return (string.Template(
101766:                 "struct ${selfName} ${inheritance}{\n"
101766:                 "  ${selfName}() {}\n"
121479:                 "  bool Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val);\n"
119693:                 "  bool ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp);\n"
101766:                 "\n" +
119028:                 ("  bool Init(const nsAString& aJSON)\n"
119028:                  "  {\n"
119028:                  "    mozilla::Maybe<JSAutoRequest> ar;\n"
119028:                  "    mozilla::Maybe<JSAutoCompartment> ac;\n"
119028:                  "    jsval json = JSVAL_VOID;\n"
119028:                  "    JSContext* cx = ParseJSON(aJSON, ar, ac, json);\n"
119028:                  "    NS_ENSURE_TRUE(cx, false);\n"
121479:                  "    return Init(cx, nullptr, json);\n"
119028:                  "  }\n" if not self.workers else "") +
119028:                 "\n" +
101766:                 "\n".join(memberDecls) + "\n"
101766:                 "private:\n"
101766:                 "  // Disallow copy-construction\n"
111180:                 "  ${selfName}(const ${selfName}&) MOZ_DELETE;\n" +
111180:                 # NOTE: jsids are per-runtime, so don't use them in workers
111180:                 ("  static bool InitIds(JSContext* cx);\n"
121324:                  "  static bool initedIds;\n" if self.needToInitIds else "") +
101766:                 "\n".join("  static jsid " +
101766:                           self.makeIdName(m.identifier.name) + ";" for
101766:                           m in d.members) + "\n"
119693:                 "};\n"
119693:                 "struct ${selfName}Initializer : public ${selfName} {\n"
119693:                 "  ${selfName}Initializer() {\n"
119693:                 "    // Safe to pass a null context if we pass a null value\n"
121479:                 "    Init(nullptr, nullptr, JS::NullValue());\n"
119693:                 "  }\n"
101766:                 "};").substitute( { "selfName": self.makeClassName(d),
101766:                                     "inheritance": inheritance }))
101766: 
101766:     def define(self):
102326:         if not self.generatable:
102326:             return ""
101766:         d = self.dictionary
101766:         if d.parent:
101766:             initParent = ("// Per spec, we init the parent's members first\n"
121479:                           "if (!%s::Init(cx, scopeObj, val)) {\n"
101766:                           "  return false;\n"
101766:                           "}\n" % self.makeClassName(d.parent))
119693:             toObjectParent = ("// Per spec, we define the parent's members first\n"
119693:                               "if (!%s::ToObject(cx, parentObject, vp)) {\n"
119693:                               "  return false;\n"
119693:                               "}\n" % self.makeClassName(d.parent))
119693:             ensureObject = "JSObject* obj = &vp->toObject();\n"
101766:         else:
101766:             initParent = ""
119693:             toObjectParent = ""
119693:             ensureObject = ("JSObject* obj = JS_NewObject(cx, nullptr, nullptr, nullptr);\n"
119693:                             "if (!obj) {\n"
119693:                             "  return false;\n"
119716:                             "}\n"
119716:                             "*vp = JS::ObjectValue(*obj);\n")
101766: 
101766:         memberInits = [CGIndenter(self.getMemberConversion(m)).define()
101766:                        for m in self.memberInfo]
101766:         idinit = [CGGeneric('!InternJSString(cx, %s, "%s")' %
101766:                             (m.identifier.name + "_id", m.identifier.name))
101766:                   for m in d.members]
101766:         idinit = CGList(idinit, " ||\n")
101766:         idinit = CGWrapper(idinit, pre="if (",
101766:                            post=(") {\n"
101766:                                  "  return false;\n"
101766:                                  "}"),
101766:                            reindent=True)
119693:         memberDefines = [CGIndenter(self.getMemberDefinition(m)).define()
119693:                          for m in self.memberInfo]
101766: 
101766:         return string.Template(
111180:             # NOTE: jsids are per-runtime, so don't use them in workers
111180:             ("bool ${selfName}::initedIds = false;\n" +
101766:              "\n".join("jsid ${selfName}::%s = JSID_VOID;" %
101766:                        self.makeIdName(m.identifier.name)
101766:                        for m in d.members) + "\n"
101766:              "\n"
101766:              "bool\n"
101766:              "${selfName}::InitIds(JSContext* cx)\n"
101766:              "{\n"
101766:              "  MOZ_ASSERT(!initedIds);\n"
101766:              "${idInit}\n"
101766:              "  initedIds = true;\n"
101766:              "  return true;\n"
101766:              "}\n"
121324:              "\n" if self.needToInitIds else "") +
101766:             "bool\n"
121479:             "${selfName}::Init(JSContext* cx, JSObject* scopeObj, const JS::Value& val)\n"
119693:             "{\n"
119693:             "  // Passing a null JSContext is OK only if we're initing from null,\n"
119693:             "  // Since in that case we will not have to do any property gets\n"
119693:             "  MOZ_ASSERT_IF(!cx, val.isNull());\n" +
111180:             # NOTE: jsids are per-runtime, so don't use them in workers
119693:             ("  if (cx && !initedIds && !InitIds(cx)) {\n"
101766:              "    return false;\n"
121324:              "  }\n" if self.needToInitIds else "") +
121324:             "${initParent}" +
121324:             ("  JSBool found;\n"
121324:              "  JS::Value temp;\n" if len(memberInits) > 0 else "") +
105570:             "  bool isNull = val.isNullOrUndefined();\n"
105570:             "  if (!isNull && !val.isObject()) {\n"
119071:             "    return ThrowErrorMessage(cx, MSG_NOT_OBJECT);\n"
105570:             "  }\n"
101766:             "\n"
101766:             "${initMembers}\n"
101766:             "  return true;\n"
119693:             "}\n"
119693:             "\n"
119693:             "bool\n"
119693:             "${selfName}::ToObject(JSContext* cx, JSObject* parentObject, JS::Value *vp)\n"
119693:             "{\n" +
119693:             # NOTE: jsids are per-runtime, so don't use them in workers
119693:             ("  if (!initedIds && !InitIds(cx)) {\n"
119693:              "    return false;\n"
121324:              "  }\n" if self.needToInitIds else "") +
119693:             "${toObjectParent}"
119693:             "${ensureObject}"
119693:             "\n"
119693:             "${defineMembers}\n"
119714:             "\n"
119693:             "  return true;\n"
101766:             "}").substitute({
101766:                 "selfName": self.makeClassName(d),
101766:                 "initParent": CGIndenter(CGGeneric(initParent)).define(),
101766:                 "initMembers": "\n\n".join(memberInits),
105570:                 "idInit": CGIndenter(idinit).define(),
119693:                 "isMainThread": toStringBool(not self.workers),
119693:                 "toObjectParent": CGIndenter(CGGeneric(toObjectParent)).define(),
119693:                 "ensureObject": CGIndenter(CGGeneric(ensureObject)).define(),
119693:                 "defineMembers": "\n\n".join(memberDefines)
101766:                 })
101766: 
102326:     @staticmethod
102326:     def makeDictionaryName(dictionary, workers):
102326:         suffix = "Workers" if workers else ""
102326:         return dictionary.identifier.name + suffix
102326: 
101766:     def makeClassName(self, dictionary):
102326:         return self.makeDictionaryName(dictionary, self.workers)
101766: 
101766:     def getMemberType(self, memberInfo):
101766:         (member, (templateBody, declType,
101766:                   holderType, dealWithOptional)) = memberInfo
101766:         # We can't handle having a holderType here
101766:         assert holderType is None
101766:         if dealWithOptional:
101766:             declType = CGWrapper(declType, pre="Optional< ", post=" >")
101766:         return declType.define()
101766: 
101766:     def getMemberConversion(self, memberInfo):
101766:         (member, (templateBody, declType,
101766:                   holderType, dealWithOptional)) = memberInfo
101766:         replacements = { "val": "temp",
101766:                          "valPtr": "&temp",
101766:                          # Use this->%s to refer to members, because we don't
101766:                          # control the member names and want to make sure we're
101766:                          # talking about the member, not some local that
101766:                          # shadows the member.  Another option would be to move
101766:                          # the guts of init to a static method which is passed
101766:                          # an explicit reference to our dictionary object, so
101766:                          # we couldn't screw this up even if we wanted to....
102326:                          "declName": ("(this->%s)" % member.identifier.name),
102326:                          # We need a holder name for external interfaces, but
102326:                          # it's scoped down to the conversion so we can just use
102326:                          # anything we want.
121479:                          "holderName": "holder",
121479:                          "obj": "scopeObj" }
101766:         # We can't handle having a holderType here
101766:         assert holderType is None
101766:         if dealWithOptional:
101766:             replacements["declName"] = "(" + replacements["declName"] + ".Value())"
106942:         if member.defaultValue:
106942:             replacements["haveValue"] = "found"
101766: 
111180:         # NOTE: jsids are per-runtime, so don't use them in workers
111180:         if self.workers:
111180:             propName = member.identifier.name
111180:             propCheck = ('JS_HasProperty(cx, &val.toObject(), "%s", &found)' %
111180:                          propName)
111180:             propGet = ('JS_GetProperty(cx, &val.toObject(), "%s", &temp)' %
111180:                        propName)
111180:         else:
111180:             propId = self.makeIdName(member.identifier.name);
111180:             propCheck = ("JS_HasPropertyById(cx, &val.toObject(), %s, &found)" %
111180:                          propId)
111180:             propGet = ("JS_GetPropertyById(cx, &val.toObject(), %s, &temp)" %
111180:                        propId)
111180: 
101766:         conversionReplacements = {
101766:             "prop": "(this->%s)" % member.identifier.name,
111180:             "convert": string.Template(templateBody).substitute(replacements),
111180:             "propCheck": propCheck,
111180:             "propGet": propGet
101766:             }
105570:         conversion = ("if (isNull) {\n"
105570:                       "  found = false;\n"
111180:                       "} else if (!${propCheck}) {\n"
101766:                       "  return false;\n"
101766:                       "}\n")
101766:         if member.defaultValue:
101766:             conversion += (
101766:                 "if (found) {\n"
111180:                 "  if (!${propGet}) {\n"
101766:                 "    return false;\n"
101766:                 "  }\n"
101766:                 "}\n"
101766:                 "${convert}")
101766:         else:
101766:             conversion += (
101766:                 "if (found) {\n"
101766:                 "  ${prop}.Construct();\n"
111180:                 "  if (!${propGet}) {\n"
101766:                 "    return false;\n"
101766:                 "  }\n"
101766:                 "${convert}\n"
101766:                 "}")
101766:             conversionReplacements["convert"] = CGIndenter(
101766:                 CGGeneric(conversionReplacements["convert"])).define()
101766:         
101766:         return CGGeneric(
101766:             string.Template(conversion).substitute(conversionReplacements)
101766:             )
101766: 
119693:     def getMemberDefinition(self, memberInfo):
119693:         member = memberInfo[0]
119693:         declType = memberInfo[1][1]
119693:         # Use this->%s to refer to members, because we don't control
119693:         # the member names and want to make sure we're talking about
119693:         # the member, not some local that shadows the member.  Another
119693:         # option would be to move the guts of init to a static method
119693:         # which is passed an explicit reference to our dictionary
119693:         # object, so we couldn't screw this up even if we wanted
119693:         # to....
119693:         memberLoc = "(this->%s)" % member.identifier.name
119693:         if member.defaultValue:
119693:             memberData = memberLoc
119693:         else:
119693:             # The data is inside the Optional<>
119693:             memberData = "%s.Value()" % memberLoc
119693: 
119693:         if self.workers:
119693:             propDef = (
119693:                 'JS_DefineProperty(cx, obj, "%s", temp, nullptr, nullptr, JSPROP_ENUMERATE)' %
119693:                 member.identifier.name)
119693:         else:
119693:             propDef = (
119693:                 'JS_DefinePropertyById(cx, obj, %s, temp, nullptr, nullptr, JSPROP_ENUMERATE)' %
119693:                 self.makeIdName(member.identifier.name))
119693: 
119693:         innerTemplate = wrapForType(
119693:             member.type, self.descriptorProvider,
119693:             {
119693:                 'result' : "currentValue",
119693:                 'successCode' : ("if (!%s) {\n"
119693:                                  "  return false;\n"
119693:                                  "}" % propDef),
119693:                 'jsvalRef': "temp",
119693:                 'jsvalPtr': "&temp",
119693:                 'isCreator': False,
119693:                 'obj': "parentObject"
119693:                 }
119693:             )
119693:         conversion = CGGeneric(innerTemplate)
119693:         conversion = CGWrapper(conversion,
119693:                                pre=("JS::Value temp;\n"
119693:                                     "%s& currentValue = %s;\n" %
119693:                                     (declType.define(), memberData)
119693:                                     ))
119693: 
119693:         if not member.defaultValue:
119693:             # Only do the conversion if we have a value
119693:             conversion = CGIfWrapper(conversion, "%s.WasPassed()" % memberLoc)
119693:         else:
119693:             # Make sure we have a scope for our stuff
119693:             conversion = CGWrapper(CGIndenter(conversion),
119693:                                    pre=("{\n"
119693:                                         "  // scope for 'temp' and 'currentValue'\n"),
119693:                                    post="\n}")
119693:         return conversion
119693: 
101766:     @staticmethod
101766:     def makeIdName(name):
101766:         return name + "_id"
101766: 
106694:     @staticmethod
106694:     def getDictionaryDependencies(dictionary):
106694:         deps = set();
106694:         if dictionary.parent:
106694:             deps.add(dictionary.parent)
106694:         for member in dictionary.members:
106694:             if member.type.isDictionary():
106694:                 deps.add(member.type.unroll().inner)
106694:         return deps
106694: 
106694: 
 94512: class CGRegisterProtos(CGAbstractMethod):
 94512:     def __init__(self, config):
 94512:         CGAbstractMethod.__init__(self, None, 'Register', 'void',
 94512:                                   [Argument('nsScriptNameSpaceManager*', 'aNameSpaceManager')])
 94512:         self.config = config
 94512: 
 94512:     def _defineMacro(self):
 94512:        return """
111182: #define REGISTER_PROTO(_dom_class, _pref_check) \\
111182:   aNameSpaceManager->RegisterDefineDOMInterface(NS_LITERAL_STRING(#_dom_class), _dom_class##Binding::DefineDOMInterface, _pref_check);\n\n"""
 94512:     def _undefineMacro(self):
 94512:         return "\n#undef REGISTER_PROTO"
 94512:     def _registerProtos(self):
111182:         def getPrefCheck(desc):
111182:             if desc.interface.getExtendedAttribute("PrefControlled") is None:
111182:                 return "nullptr"
111182:             return "%sBinding::PrefEnabled" % desc.name
111182:         lines = ["REGISTER_PROTO(%s, %s);" % (desc.name, getPrefCheck(desc))
 94512:                  for desc in self.config.getDescriptors(hasInterfaceObject=True,
 94512:                                                         isExternal=False,
 99235:                                                         workers=False,
 99235:                                                         register=True)]
 94512:         return '\n'.join(lines) + '\n'
 94512:     def definition_body(self):
 94512:         return self._defineMacro() + self._registerProtos() + self._undefineMacro()
 94512: 
 94512: class CGBindingRoot(CGThing):
 94512:     """
 94512:     Root codegen class for binding generation. Instantiate the class, and call
 94512:     declare or define to generate header or cpp code (respectively).
 94512:     """
 94512:     def __init__(self, config, prefix, webIDLFile):
 94512:         descriptors = config.getDescriptors(webIDLFile=webIDLFile,
120975:                                             hasInterfaceOrInterfacePrototypeObject=True,
120975:                                             skipGen=False)
101766:         dictionaries = config.getDictionaries(webIDLFile)
121472:         callbacks = config.getCallbacks(webIDLFile)
 94512: 
 94512:         forwardDeclares = [CGClassForwardDeclare('XPCWrappedNativeScope')]
 94512: 
102326:         descriptorsForForwardDeclaration = list(descriptors)
121472:         ifaces = []
102326:         for dictionary in dictionaries:
121472:             ifaces.extend(type.unroll().inner
121472:                           for type in getTypesFromDictionary(dictionary)
121472:                           if type.unroll().isGeckoInterface())
121472: 
121472:         for callback in callbacks:
121472:             ifaces.extend(t.unroll().inner
121472:                           for t in getTypesFromCallback(callback)
121472:                           if t.unroll().isGeckoInterface())
121472: 
102326:         # Put in all the non-worker descriptors
102326:         descriptorsForForwardDeclaration.extend(
121472:             config.getDescriptor(iface.identifier.name, False) for
121472:             iface in ifaces)
102326:         # And now the worker ones.  But these may not exist, so we
102326:         # have to be more careful.
121472:         for iface in ifaces:
102326:             try:
102326:                 descriptorsForForwardDeclaration.append(
102326:                     config.getDescriptor(iface.identifier.name, True))
102326:             except NoSuchDescriptorError:
102326:                 # just move along
102326:                 pass
102326: 
121472:         def declareNativeType(nativeType):
121472:             components = nativeType.split('::')
100046:             className = components[-1]
100046:             # JSObject is a struct, not a class
100046:             declare = CGClassForwardDeclare(className, className is "JSObject")
 94512:             if len(components) > 1:
 94512:                 declare = CGNamespace.build(components[:-1],
 94512:                                             CGWrapper(declare, declarePre='\n',
 94512:                                                       declarePost='\n'),
 94512:                                             declareOnly=True)
121472:             return CGWrapper(declare, declarePost='\n')
121472: 
121472:         for x in descriptorsForForwardDeclaration:
121472:             forwardDeclares.append(declareNativeType(x.nativeType))
121472: 
121472:         # Now add the forward declarations we need for our union types
121472:         for callback in callbacks:
121472:             forwardDeclares.extend(
121472:                 declareNativeType("mozilla::dom::" + str(t.unroll()))
121472:                 for t in getTypesFromCallback(callback)
121472:                 if t.unroll().isUnion())
 94512: 
 94512:         forwardDeclares = CGList(forwardDeclares)
 94512: 
 94512:         descriptorsWithPrototype = filter(lambda d: d.interface.hasInterfacePrototypeObject(),
 94512:                                           descriptors)
 94512:         traitsClasses = [CGPrototypeTraitsClass(d) for d in descriptorsWithPrototype]
 94512: 
 94512:         # We must have a 1:1 mapping here, skip for prototypes that have more
 94512:         # than one concrete class implementation.
 94512:         traitsClasses.extend([CGPrototypeIDMapClass(d) for d in descriptorsWithPrototype
 94512:                               if d.uniqueImplementation])
 94512: 
 94512:         # Wrap all of that in our namespaces.
 94512:         if len(traitsClasses) > 0:
 97422:             traitsClasses = CGNamespace.build(['mozilla', 'dom'],
 94512:                                      CGWrapper(CGList(traitsClasses),
 94512:                                                declarePre='\n'),
 94512:                                                declareOnly=True)
 94512:             traitsClasses = CGWrapper(traitsClasses, declarePost='\n')
 94512:         else:
 97422:             traitsClasses = None
 94512: 
101766:         # Do codegen for all the enums
 97422:         def makeEnum(e):
 97422:             return CGNamespace.build([e.identifier.name + "Values"],
 97422:                                      CGEnum(e))
 97422:         def makeEnumTypedef(e):
 97422:             return CGGeneric(declare=("typedef %sValues::valuelist %s;\n" %
 97422:                                       (e.identifier.name, e.identifier.name)))
 97422:         cgthings = [ fun(e) for e in config.getEnums(webIDLFile)
 97422:                      for fun in [makeEnum, makeEnumTypedef] ]
101766: 
101766:         # Do codegen for all the dictionaries.  We have to be a bit careful
106694:         # here, because we have to generate these in order from least derived
106694:         # to most derived so that class inheritance works out.  We also have to
106694:         # generate members before the dictionary that contains them.
101766:         #
101766:         # XXXbz this will fail if we have two webidl files A and B such that A
101766:         # declares a dictionary which inherits from a dictionary in B and B
101766:         # declares a dictionary (possibly a different one!) that inherits from a
101766:         # dictionary in A.  The good news is that I expect this to never happen.
101766:         reSortedDictionaries = []
106694:         dictionaries = set(dictionaries)
101766:         while len(dictionaries) != 0:
106694:             # Find the dictionaries that don't depend on anything else anymore
106694:             # and move them over.
106694:             toMove = [d for d in dictionaries if
106694:                       len(CGDictionary.getDictionaryDependencies(d) &
106694:                           dictionaries) == 0]
106694:             if len(toMove) == 0:
106694:                 raise TypeError("Loop in dictionary dependency graph")
106694:             dictionaries = dictionaries - set(toMove)
101766:             reSortedDictionaries.extend(toMove)
101766: 
101766:         dictionaries = reSortedDictionaries
102326:         cgthings.extend([CGDictionary(d, config.getDescriptorProvider(True))
102326:                          for d in dictionaries])
102326:         cgthings.extend([CGDictionary(d, config.getDescriptorProvider(False))
102326:                          for d in dictionaries])
101766: 
121474:         # Do codegen for all the callbacks.  Only do non-worker codegen for now,
121474:         # since we don't have a sane setup yet for invoking callbacks in workers
121474:         # and managing their lifetimes.
121474:         cgthings.extend(CGCallbackFunction(c, config.getDescriptorProvider(False))
121474:                         for c in callbacks)
121474: 
101766:         # Do codegen for all the descriptors
 94512:         cgthings.extend([CGDescriptor(x) for x in descriptors])
101766: 
101766:         # And make sure we have the right number of newlines at the end
101766:         curr = CGWrapper(CGList(cgthings, "\n\n"), post="\n\n")
 94512: 
 94512:         # Wrap all of that in our namespaces.
 97422:         curr = CGNamespace.build(['mozilla', 'dom'],
 94512:                                  CGWrapper(curr, pre="\n"))
 94512: 
 97422:         curr = CGList([forwardDeclares,
 97422:                        CGWrapper(CGGeneric("using namespace mozilla::dom;"),
 97422:                                  defineOnly=True),
 97422:                        traitsClasses, curr],
 97422:                       "\n")
 94512: 
 94512:         # Add header includes.
 94512:         curr = CGHeaders(descriptors,
101766:                          dictionaries,
121472:                          callbacks,
 97422:                          ['mozilla/dom/BindingUtils.h',
109136:                           'mozilla/dom/DOMJSClass.h',
109136:                           'mozilla/dom/DOMJSProxyHandler.h'],
115607:                          ['mozilla/dom/NonRefcountedDOMObject.h',
115607:                           'mozilla/dom/Nullable.h',
101625:                           'PrimitiveConversions.h',
 94512:                           'XPCQuickStubs.h',
120646:                           'XPCWrapper.h',
 99793:                           'nsDOMQS.h',
 94512:                           'AccessCheck.h',
 94512:                           'WorkerPrivate.h',
 99234:                           'nsContentUtils.h',
100046:                           'mozilla/Preferences.h',
100046:                           # Have to include nsDOMQS.h to get fast arg unwrapping
100046:                           # for old-binding things with castability.
100046:                           'nsDOMQS.h'
 99234:                           ],
121472:                          curr,
121472:                          config)
 94512: 
 94512:         # Add include guards.
 94512:         curr = CGIncludeGuard(prefix, curr)
 94512: 
 94512:         # Add the auto-generated comment.
 94512:         curr = CGWrapper(curr, pre=AUTOGENERATED_WARNING_COMMENT)
 94512: 
 94512:         # Store the final result.
 94512:         self.root = curr
 94512: 
 94512:     def declare(self):
 94512:         return stripTrailingWhitespace(self.root.declare())
 94512:     def define(self):
 94512:         return stripTrailingWhitespace(self.root.define())
 94512: 
121473: class CGNativeMember(ClassMethod):
121473:     def __init__(self, descriptor, member, name, signature, extendedAttrs,
121478:                  breakAfter=True, passCxAsNeeded=True, visibility="public",
121478:                  jsObjectsArePtr=False):
121478:         """
121478:         If jsObjectsArePtr is true, typed arrays and "object" will be
121478:         passed as JSObject*
121478:         """
119238:         self.descriptor = descriptor
119238:         self.member = member
119238:         self.extendedAttrs = extendedAttrs
119238:         self.resultAlreadyAddRefed = isResultAlreadyAddRefed(self.descriptor,
119238:                                                              self.extendedAttrs)
121474:         self.passCxAsNeeded = passCxAsNeeded
121478:         self.jsObjectsArePtr = jsObjectsArePtr
121473:         breakAfterSelf = "\n" if breakAfter else ""
121473:         ClassMethod.__init__(self, name,
121473:                              self.getReturnType(signature[0], False),
121473:                              self.getArgs(signature[0], signature[1]),
121473:                              static=member.isStatic(),
121473:                              # Mark our getters, which are attrs that
121473:                              # have a non-void return type, as const.
121473:                              const=(not member.isStatic() and member.isAttr() and
121473:                                     not signature[0].isVoid()),
121473:                              breakAfterReturnDecl=" ",
121474:                              breakAfterSelf=breakAfterSelf,
121474:                              visibility=visibility)
119238: 
119238:     def getReturnType(self, type, isMember):
121474:         return self.getRetvalInfo(type, isMember)[0]
121474: 
121474:     def getRetvalInfo(self, type, isMember):
121474:         """
121476:         Returns a tuple:
121476: 
121476:         The first element is the type declaration for the retval
121476: 
121476:         The second element is a default value that can be used on error returns.
121474:         For cases whose behavior depends on isMember, the second element will be
121474:         None if isMember is true.
121476: 
121476:         The third element is a template for actually returning a value stored in
121476:         "${declName}" and "${holderName}".  This means actually returning it if
121476:         we're not outparam, else assigning to the "retval" outparam.  If
121476:         isMember is true, this can be None, since in that case the caller will
121476:         never examine this value.
121474:         """
119238:         if type.isVoid():
121476:             return "void", "", ""
119238:         if type.isPrimitive() and type.tag() in builtinNames:
119238:             result = CGGeneric(builtinNames[type.tag()])
121474:             defaultReturnArg = "0"
119238:             if type.nullable():
119238:                 result = CGWrapper(result, pre="Nullable<", post=">")
121474:                 defaultReturnArg = ""
121474:             return (result.define(),
121476:                     "%s(%s)" % (result.define(), defaultReturnArg),
121476:                     "return ${declName};")
119238:         if type.isString():
119238:             if isMember:
121476:                 # No need for a third element in the isMember case
121476:                 return "nsString", None, None
119238:             # Outparam
121476:             return "void", "", "retval = ${declName};"
119238:         if type.isEnum():
119238:             if type.nullable():
119238:                 raise TypeError("We don't support nullable enum return values")
121474:             typeName = type.inner.identifier.name
121476:             return typeName, "%s(0)" % typeName, "return ${declName};"
119238:         if type.isGeckoInterface():
121476:             iface = type.unroll().inner;
119238:             nativeType = self.descriptor.getDescriptor(
121476:                 iface.identifier.name).nativeType
119238:             # Now trim off unnecessary namespaces
119238:             nativeType = nativeType.split("::")
119238:             if nativeType[0] == "mozilla":
119238:                 nativeType.pop(0)
119238:                 if nativeType[0] == "dom":
119238:                     nativeType.pop(0)
119238:             result = CGGeneric("::".join(nativeType))
119238:             if self.resultAlreadyAddRefed:
119238:                 if isMember:
119238:                     holder = "nsRefPtr"
119238:                 else:
119238:                     holder = "already_AddRefed"
119238:                 if memberIsCreator(self.member):
119238:                     warning = ""
119238:                 else:
119238:                     warning = "// Mark this as resultNotAddRefed to return raw pointers\n"
119238:                 result = CGWrapper(result,
119238:                                    pre=("%s%s<" % (warning, holder)),
119238:                                    post=">")
119238:             else:
119238:                 result = CGWrapper(result, post="*")
121476:             if iface.isExternal():
121476:                 # The holder is an nsRefPtr.  If we're nullable and end up null,
121476:                 # the holder will be null anyway, so it's safe to just always
121476:                 # return it here.
121476:                 returnCode = "return ${holderName}.forget();"
121476:             elif iface.isCallback():
121476:                 # The decl is an OwningNonNull or nsRefPtr, depending
121476:                 # on whether we're nullable.
121476:                 returnCode = "return ${declName}.forget();"
121476:             elif type.nullable():
121476:                 # Decl is a raw pointer
121476:                 returnCode = ("NS_IF_ADDREF(${declName});\n"
121476:                               "return ${declName};")
121476:             else:
121476:                 # Decl is a NonNull.
121476:                 returnCode = ("NS_ADDREF(${declName}.Ptr());\n"
121476:                               "return ${declName}.Ptr();")
121476:             return result.define(), "nullptr", returnCode
119238:         if type.isCallback():
121480:             return ("already_AddRefed<%s>" % type.unroll().identifier.name,
121480:                     "nullptr", "return ${declName}.forget();")
119238:         if type.isAny():
121476:             return "JS::Value", "JS::UndefinedValue()", "return ${declName};"
121476:         if type.isObject():
121476:             if type.nullable():
121476:                 returnCode = "return ${declName};"
121476:             else:
121476:                 returnCode = "return ${declName}.Ptr();"
121476:             return "JSObject*", "nullptr", returnCode
121476:         if type.isSpiderMonkeyInterface():
121476:             if type.nullable():
121476:                 returnCode = "return ${declName} ? ${declName}->Obj() : nullptr;"
121476:             else:
121476:                 returnCode = ("return static_cast<%s&>(${declName}).Obj();" % type.name)
121476:             return "JSObject*", "nullptr", returnCode
119238:         if type.isSequence():
119238:             assert not isMember
121476:             # Outparam.  Copying is a bit suboptimal, but hard to avoid: We
121476:             # could SwapElements if we cast away const, but even then our
121476:             # Sequence is an auto-array, and will tend to copy.  The good news
121476:             # is that callbacks that return sequences should be pretty rare
121476:             # anyway, and if we have to we can rejigger the codegen here to use
121476:             # a non-const non-auto array if it's ever necessary.
121476:             # In any case, we only support sequences of primitive values for
121476:             # returning from a callback, for now.
121476:             if not type.unroll().isPrimitive():
121474:                 return "void", ""
121476:             if type.nullable():
121476:                 returnCode = ("if (${declName}.IsNull()) {\n"
121476:                               "  retval.SetNull();\n"
121476:                               "} else {\n"
121476:                               "  retval.SetValue() = ${declName}.Value();\n"
121476:                               "}")
121476:             else:
121476:                 returnCode = "retval = ${declName};"
121476:             return "void", "", returnCode
119238:         raise TypeError("Don't know how to declare return value for %s" %
119238:                         type)
119238: 
119238:     def getArgs(self, returnType, argList):
119238:         args = [self.getArg(arg) for arg in argList]
119238:         # Now the outparams
119238:         if returnType.isString():
121473:             args.append(Argument("nsString&", "retval"))
119238:         elif returnType.isSequence():
119238:             nullable = returnType.nullable()
119238:             if nullable:
119238:                 returnType = returnType.inner
119238:             # And now the actual underlying type
119238:             elementDecl = self.getReturnType(returnType.inner, True)
119238:             type = CGWrapper(CGGeneric(elementDecl), pre="nsTArray< ", post=" >")
119238:             if nullable:
119238:                 type = CGWrapper(type, pre="Nullable< ", post=" >")
121473:             args.append(Argument("%s&" % type.define(), "retval"))
119238:         # And the ErrorResult
119238:         if not 'infallible' in self.extendedAttrs:
121473:             # Use aRv so it won't conflict with local vars named "rv"
121473:             args.append(Argument("ErrorResult&", "aRv"))
119238:         # And if we're static, a global
119238:         if self.member.isStatic():
121473:             args.insert(0, Argument("nsISupports*", "global"))
119238:         # And jscontext bits.  needCx expects a list of tuples, in each of which
119238:         # the first element is the actual argument
121474:         if (self.passCxAsNeeded and
121480:             needCx(returnType, ((a, "") for a in argList), self.extendedAttrs,
121480:                    self.descriptor)):
121473:             args.insert(0, Argument("JSContext*", "cx"))
121473:         return args
119238: 
119238:     def doGetArgType(self, type, optional, isMember):
119238:         """
119238:         The main work of getArgType.  Returns a string type decl, whether this
119238:         is a const ref, as well as whether the type should be wrapped in
119238:         Nullable as needed.
119238:         """
119238:         if type.isArray():
119238:             raise TypeError("Can't handle array arguments yet")
119238: 
119238:         if type.isSequence():
119238:             nullable = type.nullable()
119238:             if nullable:
119238:                 type = type.inner
119238:             elementType = type.inner
119238:             decl = CGWrapper(self.getArgType(elementType, False, True)[0],
119238:                              pre="Sequence< ", post=" >")
119238:             return decl.define(), True, True
119238: 
119238:         if type.isUnion():
119238:             if type.nullable():
119238:                 type = type.inner
119238:             return str(type), True, True
119238: 
119238:         if type.isGeckoInterface():
119238:             iface = type.unroll().inner
119238:             argIsPointer = type.nullable() or iface.isExternal()
119238:             forceOwningType = iface.isCallback() or isMember
119238:             if argIsPointer:
119238:                 if (optional or isMember) and forceOwningType:
119238:                     typeDecl = "nsRefPtr<%s>"
119238:                 else:
119238:                     typeDecl = "%s*"
119238:             else:
119238:                 if optional or isMember:
119238:                     if forceOwningType:
119238:                         typeDecl = "OwningNonNull<%s>"
119238:                     else:
119238:                         typeDecl = "NonNull<%s>"
119238:                 else:
119238:                     typeDecl = "%s&"
119932:             return ((typeDecl %
119932:                      self.descriptor.getDescriptor(iface.identifier.name).nativeType),
119932:                     False, False)
119238: 
119238:         if type.isSpiderMonkeyInterface():
119238:             assert not isMember
121478:             if self.jsObjectsArePtr:
121478:                 typeDecl = "JSObject*"
121478:             else:
119238:                 if type.nullable():
119238:                     typeDecl = "%s*"
119238:                 else:
119272:                     typeDecl = "%s"
119272:                     if not optional:
119272:                         typeDecl += "&"
121478:                 typeDecl = typeDecl % type.name
121478:             return typeDecl, False, False
119238: 
119238:         if type.isString():
119238:             if isMember:
119238:                 declType = "nsString"
119238:             else:
119238:                 declType = "nsAString"
119238:             return declType, True, False
119238: 
119238:         if type.isEnum():
119238:             return type.inner.identifier.name, False, True
119238: 
119238:         if type.isCallback():
119272:             if type.nullable():
119272:                 if optional:
121480:                     declType = "nsRefPtr<%s>"
121480:                 else:
121480:                     declType = "%s*"
121480:             else:
121480:                 if optional:
121480:                     declType = "OwningNonNull<%s>"
121480:                 else:
121480:                     declType = "%s&"
121480:             return declType % type.unroll().identifier.name, False, False
119238: 
119238:         if type.isAny():
119238:             return "JS::Value", False, False
119238: 
119238:         if type.isObject():
121478:             if type.nullable() or self.jsObjectsArePtr:
119238:                 declType = "%s*"
121500:             elif optional:
119238:                 declType = "NonNull<%s>"
119238:             else:
119238:                 declType = "%s&"
119238:             return (declType % "JSObject"), False, False
119238: 
119238:         if type.isDictionary():
119238:             return type.inner.identifier.name, True, True
119238: 
119238:         assert type.isPrimitive()
119238: 
119238:         return builtinNames[type.tag()], False, True
119238: 
119238:     def getArgType(self, type, optional, isMember):
119238:         """
119238:         Get the type of an argument declaration.  Returns the type CGThing, and
119238:         whether this should be a const ref.
119238:         """
119238:         (decl, ref, handleNullable) = self.doGetArgType(type, optional, isMember)
119238:         decl = CGGeneric(decl)
119238:         if handleNullable and type.nullable():
119238:             decl = CGWrapper(decl, pre="Nullable< ", post=" >")
119238:             ref = True
119238:         if optional:
119238:             decl = CGWrapper(decl, pre="Optional< ", post=" >")
119238:             ref = True
119238:         return (decl, ref)
119238: 
119238:     def getArg(self, arg):
119238:         """
119238:         Get the full argument declaration for an argument
119238:         """
119238:         (decl, ref) = self.getArgType(arg.type,
119238:                                       arg.optional and not arg.defaultValue,
119238:                                       False)
119238:         if ref:
119238:             decl = CGWrapper(decl, pre="const ", post="&")
119238: 
121473:         return Argument(decl.define(), arg.identifier.name)
121473: 
121473: 
121473: class CGExampleMethod(CGNativeMember):
121473:     def __init__(self, descriptor, method, signature, breakAfter=True):
121473:         CGNativeMember.__init__(self, descriptor, method,
119238:                                 CGSpecializedMethod.makeNativeName(descriptor,
119238:                                                                    method),
121473:                                 signature,
121473:                                 descriptor.getExtendedAttributes(method),
121473:                                 breakAfter)
121473:     def define(self, cgClass):
121473:         return ''
121473: 
121473: class CGExampleGetter(CGNativeMember):
119238:     def __init__(self, descriptor, attr):
121473:         CGNativeMember.__init__(self, descriptor, attr,
119238:                                 CGSpecializedGetter.makeNativeName(descriptor,
119238:                                                                    attr),
121473:                                 (attr.type, []),
119238:                                 descriptor.getExtendedAttributes(attr,
119238:                                                                  getter=True))
121473:     def define(self, cgClass):
121473:         return ''
121473: 
121473: class CGExampleSetter(CGNativeMember):
119238:     def __init__(self, descriptor, attr):
121473:         CGNativeMember.__init__(self, descriptor, attr,
119238:                                 CGSpecializedSetter.makeNativeName(descriptor,
119238:                                                                    attr),
121473:                                 (BuiltinTypes[IDLBuiltinType.Types.void],
121473:                                  [FakeArgument(attr.type, attr)]),
119238:                                 descriptor.getExtendedAttributes(attr,
119238:                                                                  setter=True))
121473:     def define(self, cgClass):
121473:         return ''
121473: 
121473: class CGExampleClass(CGClass):
119238:     """
119238:     Codegen for the actual example class implemenation for this descriptor
119238:     """
119238:     def __init__(self, descriptor):
119238:         self.descriptor = descriptor
119238: 
119238:         iface = descriptor.interface
119238: 
119238:         methodDecls = []
121473:         def appendMethod(m):
121473:             sigs = m.signatures()
121473:             for s in sigs[:-1]:
121473:                 # Don't put an empty line after overloads, until we
121473:                 # get to the last one.
121473:                 methodDecls.append(CGExampleMethod(descriptor, m, s,
121473:                                                    breakAfter=False))
121473:             methodDecls.append(CGExampleMethod(descriptor, m, sigs[-1]))
121473: 
119238:         if iface.ctor():
121473:             appendMethod(iface.ctor())
119238:         for m in iface.members:
119238:             if m.isMethod():
121501:                 if (m.isIdentifierLess() and
121501:                     m != descriptor.operations['Stringifier']):
121501:                     continue
121473:                 appendMethod(m)
119238:             elif m.isAttr():
119238:                 methodDecls.append(CGExampleGetter(descriptor, m))
119238:                 if not m.readonly:
119238:                     methodDecls.append(CGExampleSetter(descriptor, m))
119238: 
121501:         # Now do the special operations
121501:         def appendSpecialOperation(name, op):
121501:             if op is None:
121501:                 return
121501:             if name == "IndexedCreator" or name == "NamedCreator":
121501:                 # These are identical to the setters
121501:                 return
121501:             assert len(op.signatures()) == 1
121501:             (returnType, args) = op.signatures()[0]
121501:             # Make a copy of the args, since we plan to modify them.
121501:             args = list(args)
121501:             if op.isGetter() or op.isDeleter():
121501:                 # This is a total hack.  The '&' belongs with the
121501:                 # type, not the name!  But it works, and is simpler
121501:                 # than trying to somehow make this pretty.
121501:                 args.append(FakeArgument(BuiltinTypes[IDLBuiltinType.Types.boolean],
121501:                                          op, name="&found"))
121501:             if name == "Stringifier" and op.isIdentifierLess():
121501:                 # XXXbz I wish we were consistent about our renaming here.
121501:                 name = "__stringify"
121501:             methodDecls.append(
121501:                 CGNativeMember(descriptor, op,
121501:                                name,
121501:                                (returnType, args),
121501:                                descriptor.getExtendedAttributes(op)))
121501:         # Sort things by name so we get stable ordering in the output.
121501:         ops = descriptor.operations.items()
121501:         ops.sort(key=lambda x: x[0])
121501:         for (name, op) in ops:
121501:             appendSpecialOperation(name, op)
121501:         # If we support indexed properties, then we need a Length()
121501:         # method so we know which indices are supported.
121501:         if descriptor.supportsIndexedProperties():
121501:             methodDecls.append(
121501:                 CGNativeMember(descriptor, FakeMember(),
121501:                                "Length",
121501:                                (BuiltinTypes[IDLBuiltinType.Types.unsigned_long],
121501:                                 []),
121501:                                { "infallible": True }))
121501:         # And if we support named properties we need to be able to
121501:         # enumerate the supported names.
121501:         if descriptor.supportsNamedProperties():
121501:             methodDecls.append(
121501:                 CGNativeMember(
121501:                     descriptor, FakeMember(),
121501:                     "GetSupportedNames",
121501:                     (IDLSequenceType(None,
121501:                                      BuiltinTypes[IDLBuiltinType.Types.domstring]),
121501:                      []),
121501:                     { "infallible": True }))
121501: 
121473:         wrapArgs = [Argument('JSContext*', 'aCx'),
121473:                     Argument('JSObject*', 'aScope')]
119238:         if descriptor.wrapperCache:
121473:             wrapArgs.append(Argument('bool*', 'aTriedToWrap'))
121473:         methodDecls.insert(0,
121473:                            ClassMethod("WrapObject", "JSObject*",
121500:                                        wrapArgs, virtual=descriptor.wrapperCache,
121473:                                        breakAfterReturnDecl=" "))
121473:         getParentObjectReturnType = (
121473:             "// TODO: return something sensible here, and change the return type\n"
121473:             "%s*" % descriptor.name)
121473:         methodDecls.insert(0,
121473:                            ClassMethod("GetParentObject",
121473:                                        getParentObjectReturnType,
121473:                                        [], const=True,
121473:                                        breakAfterReturnDecl=" "))
121473:         extradeclarations=(
119238:             "public:\n"
119238:             "  NS_DECL_CYCLE_COLLECTING_ISUPPORTS\n"
121473:             "  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(%s)\n"
121473:             "\n" % descriptor.name)
121473: 
121473:         CGClass.__init__(self, descriptor.name,
121500:                          bases=[ClassBase("nsISupports /* Change nativeOwnership in the binding configuration if you don't want this */"),
121500:                                 ClassBase("nsWrapperCache /* Change wrapperCache in the binding configuration if you don't want this */")],
121473:                          constructors=[ClassConstructor([],
121473:                                                         visibility="public")],
121473:                          destructor=ClassDestructor(visibility="public"),
121473:                          methods=methodDecls,
121473:                          decorators="MOZ_FINAL",
121473:                          extradeclarations=extradeclarations)
119238: 
119238:     def define(self):
121473:         # Just override CGClass and do our own thing
119238:         classImpl = """
119238: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(${ifaceName})
119238: NS_IMPL_CYCLE_COLLECTING_ADDREF(${ifaceName})
119238: NS_IMPL_CYCLE_COLLECTING_RELEASE(${ifaceName})
119238: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(${ifaceName})
119238:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
119238:   NS_INTERFACE_MAP_ENTRY(nsISupports)
119238: NS_INTERFACE_MAP_END
119238: 
119238: ${ifaceName}::${ifaceName}()
119238: {
119238:   SetIsDOMBinding();
119238: }
119238: 
119238: ${ifaceName}::~${ifaceName}()
119238: {
119238: }
119238: """
119238:         if self.descriptor.wrapperCache:
119238:             classImpl += """
119238: JSObject*
119238: ${ifaceName}::WrapObject(JSContext* aCx, JSObject* aScope, bool* aTriedToWrap)
119238: {
119238:   return ${ifaceName}Binding::Wrap(aCx, aScope, this, aTriedToWrap);
119238: }
119238: 
119238: """
119238:         else:
119238:             classImpl += """
119238: JSObject*
119238: ${ifaceName}::WrapObject(JSContext* aCx, JSObject* aScope)
119238: {
119238:   return ${ifaceName}Binding::Wrap(aCx, aScope, this);
119238: }
119238: 
119238: """
119238:         return string.Template(classImpl).substitute(
119238:             { "ifaceName": self.descriptor.name }
119238:             )
119238: 
119238: 
119238: class CGExampleRoot(CGThing):
119238:     """
119238:     Root codegen class for example implementation generation.  Instantiate the
119238:     class and call declare or define to generate header or cpp code,
119238:     respectively.
119238:     """
119238:     def __init__(self, config, interfaceName):
119238:         # Let's assume we're not doing workers stuff
119238:         descriptor = config.getDescriptor(interfaceName, False)
119238: 
121473:         self.root = CGWrapper(CGExampleClass(descriptor),
121473:                               pre="\n", post="\n")
119238: 
119238:         self.root = CGNamespace.build(["mozilla", "dom"], self.root);
119238: 
119238:         self.root = CGList([CGClassForwardDeclare("JSContext", isStruct=True),
119238:                             self.root], "\n")
119238: 
119238:         # Throw in our #includes
121472:         self.root = CGHeaders([], [], [],
119238:                               [ "nsWrapperCache.h",
119238:                                 "nsCycleCollectionParticipant.h",
121502:                                 "mozilla/Attributes.h",
121502:                                 "mozilla/ErrorResult.h" ],
119238:                               [ "%s.h" % interfaceName,
119238:                                 "mozilla/dom/%sBinding.h" % interfaceName,
119238:                                 "nsContentUtils.h" ], self.root);
119238: 
119238:         # In the header, #pragma once before everything
119238:         self.root = CGWrapper(self.root, declarePre="#pragma once\n\n")
119238: 
119238:         # And our license block comes before everything else
119238:         self.root = CGWrapper(self.root, pre="""/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
119238: /* vim:set ts=2 sw=2 sts=2 et cindent: */
119238: /* This Source Code Form is subject to the terms of the Mozilla Public
119238:  * License, v. 2.0. If a copy of the MPL was not distributed with this
119238:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
119238: 
119238: """)
119238: 
119238:     def declare(self):
119238:         return self.root.declare()
119238: 
119238:     def define(self):
119238:         return self.root.define()
119238: 
121474: class CGCallbackFunction(CGClass):
121474:     def __init__(self, callback, descriptorProvider):
121474:         name = callback.identifier.name
121474:         if descriptorProvider.workers:
121474:             name += "Workers"
121474:         try:
121474:             # For our public Call() method we want most of the same args and the
121474:             # same return type as what CallCallback generates.  So we want to
121474:             # take advantage of all its CGNativeMember infrastructure, but that
121474:             # infrastructure can't deal with templates and most especially
121474:             # template arguments.  So just cheat and have CallCallback compute
121474:             # all those things for us.
121474:             callCallback = CallCallback(callback, descriptorProvider)
121474:             CGClass.__init__(self, name,
121474:                              bases=[ClassBase("CallbackFunction")],
121474:                              constructors=[self.getConstructor()],
121474:                              methods=self.getCallImpls(callCallback))
121474:             self.generatable = True
121474:         except NoSuchDescriptorError, err:
121474:             if not descriptorProvider.workers:
121474:                 raise err
121474:             self.generatable = False
121474: 
121474:     def define(self):
121474:         if not self.generatable:
121474:             return ""
121474:         return CGClass.define(self)
121474: 
121474:     def declare(self):
121474:         if not self.generatable:
121474:             return ""
121474:         return CGClass.declare(self)
121474: 
121474:     def getConstructor(self):
121474:         return ClassConstructor(
121474:             [Argument("JSContext*", "cx"),
121474:              Argument("JSObject*", "aOwner"),
121474:              Argument("JSObject*", "aCallable"),
121474:              Argument("bool*", "aInited")],
121474:             bodyInHeader=True,
121474:             visibility="public",
121474:             baseConstructors=[
121474:                 "CallbackFunction(cx, aOwner, aCallable, aInited)"
121474:                 ],
121474:             body="")
121474: 
121474:     def getCallImpls(self, callCallback):
121474:         args = list(callCallback.args)
121474:         # Strip out the JSContext*/JSObject* args
121474:         # that got added.
121474:         assert args[0].name == "cx" and args[0].argType == "JSContext*"
121474:         assert args[1].name == "aThisObj" and args[1].argType == "JSObject*"
121474:         args = args[2:]
121474:         # Record the names of all the arguments, so we can use them when we call
121474:         # the private method.
121474:         argnames = [arg.name for arg in args]
121474:         argnamesWithThis = ["s.GetContext()", "thisObjJS"] + argnames
121474:         argnamesWithoutThis = ["s.GetContext()", "nullptr"] + argnames
121474:         # And now insert our template argument.
121474:         argsWithoutThis = list(args)
121474:         args.insert(0, Argument("const T&",  "thisObj"))
121474: 
121474:         setupCall = ("CallSetup s(mCallable);\n"
121474:                      "if (!s.GetContext()) {\n"
121474:                      "  aRv.Throw(NS_ERROR_UNEXPECTED);\n"
121474:                      "  return${errorReturn};\n"
121474:                      "}\n")
121474: 
121474:         bodyWithThis = string.Template(
121474:             setupCall+
121474:             "JSObject* thisObjJS = WrapCallThisObject(s.GetContext(), mCallable, thisObj);\n"
121474:             "if (!thisObjJS) {\n"
121474:             "  aRv.Throw(NS_ERROR_FAILURE);\n"
121474:             "  return${errorReturn};\n"
121474:             "}\n"
121474:             "return Call(${callArgs});").substitute({
121474:                 "errorReturn" : callCallback.getDefaultRetval(),
121474:                 "callArgs" : ", ".join(argnamesWithThis)
121474:                 })
121474:         bodyWithoutThis = string.Template(
121474:             setupCall +
121474:             "return Call(${callArgs});").substitute({
121474:                 "errorReturn" : callCallback.getDefaultRetval(),
121474:                 "callArgs" : ", ".join(argnamesWithoutThis)
121474:                 })
121474:         return [ClassMethod("Call", callCallback.returnType, args,
121474:                             bodyInHeader=True,
121474:                             templateArgs=["typename T"],
121474:                             body=bodyWithThis),
121474:                 ClassMethod("Call", callCallback.returnType, argsWithoutThis,
121474:                             bodyInHeader=True,
121474:                             body=bodyWithoutThis),
121474:                 callCallback]
121474: 
121474: class FakeMember():
121474:     def __init__(self):
121474:         self.treatUndefinedAs = self.treatNullAs = "Default"
121474:     def isStatic(self):
121474:         return False
121474:     def isAttr(self):
121474:         return False
121476:     def getExtendedAttribute(self, name):
121476:         # Claim to be a [Creator] so we can avoid the "mark this
121476:         # resultNotAddRefed" comments CGNativeMember codegen would
121476:         # otherwise stick in.
121476:         if name == "Creator":
121476:             return True
121476:         return None
121501: 
121501: class CallCallback(CGNativeMember):
121501:     def __init__(self, callback, descriptorProvider):
121501:         sig = callback.signatures()[0]
121501:         self.retvalType = sig[0]
121501:         self.callback = callback
121501:         args = sig[1]
121501:         self.argCount = len(args)
121474:         CGNativeMember.__init__(self, descriptorProvider, FakeMember(),
121474:                                 "Call", (self.retvalType, args),
121474:                                 extendedAttrs={},
121474:                                 passCxAsNeeded=False,
121478:                                 visibility="private",
121478:                                 jsObjectsArePtr=True)
121474:         # We have to do all the generation of our body now, because
121474:         # the caller relies on us throwing if we can't manage it.
121478:         self.exceptionCode=("aRv.Throw(NS_ERROR_UNEXPECTED);\n"
121478:                             "return%s;" % self.getDefaultRetval())
121474:         self.body = self.getImpl()
121474: 
121474:     def getImpl(self):
121474:         replacements = {
121474:             "errorReturn" : self.getDefaultRetval(),
121476:             "argCount": self.argCount,
121478:             "returnResult": self.getResultConversion(),
121478:             "convertArgs": self.getArgConversions()
121474:             }
121474:         if self.argCount > 0:
121474:             replacements["argvDecl"] = string.Template(
121474:                 "JS::Value argv[${argCount}];\n").substitute(replacements)
121474:             replacements["argv"] = "argv"
121474:         else:
121474:             # Avoid weird 0-sized arrays
121474:             replacements["argvDecl"] = ""
121474:             replacements["argv"] = "nullptr"
121474: 
121474:         return string.Template(
121474:             "JS::Value rval = JSVAL_VOID;\n"
121474:             "${argvDecl}" # Newlines and semicolons are in the value
121478:             "${convertArgs}"
121474:             "if (!JS_CallFunctionValue(cx, aThisObj, JS::ObjectValue(*mCallable),\n"
121478:             "                          argc, ${argv}, &rval)) {\n"
121474:             "  aRv.Throw(NS_ERROR_UNEXPECTED);\n"
121474:             "  return${errorReturn};\n"
121474:             "}\n"
121476:             "${returnResult}").substitute(replacements)
121476: 
121476:     def getResultConversion(self):
121476:         replacements = {
121476:             "val": "rval",
121476:             "valPtr": "&rval",
121476:             "holderName" : "rvalHolder",
121479:             "declName" : "rvalDecl",
121479:             # We actually want to pass in a null scope object here, because
121479:             # wrapping things into our current compartment (that of mCallable)
121479:             # is what we want.
121479:             "obj": "nullptr"
121476:             }
121476: 
121476:         convertType = instantiateJSToNativeConversionTemplate(
121476:             getJSToNativeConversionTemplate(self.retvalType,
121476:                                             self.descriptor,
121478:                                             exceptionCode=self.exceptionCode),
121476:             replacements)
121476:         assignRetval = string.Template(
121476:             self.getRetvalInfo(self.retvalType,
121476:                                False)[2]).substitute(replacements)
121476:         return convertType.define() + "\n" + assignRetval
121474: 
121478:     def getArgConversions(self):
121478:         # Just reget the arglist from self.callback, because our superclasses
121478:         # just have way to many members they like to clobber, so I can't find a
121478:         # safe member name to store it in.
121478:         argConversions = [self.getArgConversion(i, arg) for (i, arg)
121478:                           in enumerate(self.callback.signatures()[0][1])]
121478:         # Do them back to front, so our argc modifications will work
121478:         # correctly, because we examine trailing arguments first.
121478:         argConversions.reverse();
121478:         # Wrap each one in a scope so that any locals it has don't leak out, and
121478:         # also so that we can just "break;" for our successCode.
121478:         argConversions = [CGWrapper(CGIndenter(CGGeneric(c)),
121478:                                     pre="do {\n",
121478:                                     post="\n} while (0);")
121478:                           for c in argConversions]
121478:         argConversions.insert(0,
121478:                               CGGeneric("unsigned argc = %d;" % self.argCount));
121478:         # And slap them together.
121478:         return CGList(argConversions, "\n\n").define() + "\n\n"
121478: 
121478:     def getArgConversion(self, i, arg):
121478:         argval = arg.identifier.name
121478:         if arg.optional:
121478:             argval += ".Value()"
121478:         if arg.type.isString():
121478:             # XPConnect string-to-JS conversion wants to mutate the string.  So
121478:             # let's give it a string it can mutate
121478:             # XXXbz if we try to do a sequence of strings, this will kinda fail.
121478:             result = "mutableStr"
121478:             prepend = "nsString mutableStr(%s);\n" % argval
121478:         else:
121478:             result = argval
121478:             prepend = ""
121478: 
121478:         conversion = prepend + wrapForType(
121478:             arg.type, self.descriptor,
121478:             {
121478:                 'result' : result,
121478:                 'successCode' : "break;",
121478:                 'jsvalRef' : "argv[%d]" % i,
121478:                 'jsvalPtr' : "&argv[%d]" % i,
121478:                 # XXXbz we don't have anything better to use for 'obj',
121478:                 # really...
121478:                 'obj' : 'mCallable',
121478:                 'isCreator': False,
121478:                 'exceptionCode' : self.exceptionCode
121478:                 })
121478:         if arg.optional:
121478:             conversion = (
121478:                 CGIfWrapper(CGGeneric(conversion),
121478:                             "%s.WasPassed()" % arg.identifier.name).define() +
121478:                 " else if (argc == %d) {\n"
121478:                 "  // This is our current trailing argument; reduce argc\n"
121478:                 "  --argc;\n"
121478:                 "} else {\n"
121478:                 "  argv[%d] = JS::UndefinedValue();\n"
121478:                 "}" % (i+1, i))
121478:         return conversion
121478: 
121474:     def getDefaultRetval(self):
121474:         default = self.getRetvalInfo(self.retvalType, False)[1]
121474:         if len(default) != 0:
121474:             default = " " + default
121474:         return default
121474: 
121474:     def getArgs(self, returnType, argList):
121474:         args = CGNativeMember.getArgs(self, returnType, argList)
121474:         # We want to allow the caller to pass in a "this" object, as
121474:         # well as a JSContext.
121474:         return [Argument("JSContext*", "cx"),
121474:                 Argument("JSObject*", "aThisObj")] + args
 94512: 
 94512: class GlobalGenRoots():
 94512:     """
 94512:     Roots for global codegen.
 94512: 
 94512:     To generate code, call the method associated with the target, and then
 94512:     call the appropriate define/declare method.
 94512:     """
 94512: 
 94512:     @staticmethod
 94512:     def PrototypeList(config):
 94512: 
 94512:         # Prototype ID enum.
 94512:         protos = [d.name for d in config.getDescriptors(hasInterfacePrototypeObject=True)]
120342:         idEnum = CGNamespacedEnum('id', 'ID', ['_ID_Start'] + protos,
120342:                                   [0, '_ID_Start'])
 94512:         idEnum = CGList([idEnum])
 94512:         idEnum.append(CGGeneric(declare="const unsigned MaxProtoChainLength = " +
 94512:                                 str(config.maxProtoChainLength) + ";\n\n"))
 94512: 
 94512:         # Wrap all of that in our namespaces.
 97422:         idEnum = CGNamespace.build(['mozilla', 'dom', 'prototypes'],
 94512:                                    CGWrapper(idEnum, pre='\n'))
 94512:         idEnum = CGWrapper(idEnum, post='\n')
 94512: 
 94512:         curr = CGList([idEnum])
 94512: 
 94512:         # Constructor ID enum.
120342:         constructors = [d.name for d in config.getDescriptors(hasInterfaceObject=True)]
120342:         idEnum = CGNamespacedEnum('id', 'ID', ['_ID_Start'] + constructors,
120342:                                   ['prototypes::id::_ID_Count', '_ID_Start'])
 94512: 
 94512:         # Wrap all of that in our namespaces.
 97422:         idEnum = CGNamespace.build(['mozilla', 'dom', 'constructors'],
 94512:                                    CGWrapper(idEnum, pre='\n'))
 94512:         idEnum = CGWrapper(idEnum, post='\n')
 94512: 
 94512:         curr.append(idEnum)
 94512: 
 94512:         traitsDecl = CGGeneric(declare="""
 94512: template <prototypes::ID PrototypeID>
 94512: struct PrototypeTraits;
 94512: 
 94512: template <class ConcreteClass>
 94512: struct PrototypeIDMap;
 94512: """)
 94512: 
 97422:         traitsDecl = CGNamespace.build(['mozilla', 'dom'],
 94512:                                         CGWrapper(traitsDecl, post='\n'))
 94512: 
 94512:         curr.append(traitsDecl)
 94512: 
 94512:         # Add include guards.
 94512:         curr = CGIncludeGuard('PrototypeList', curr)
 94512: 
 94512:         # Add the auto-generated comment.
 94512:         curr = CGWrapper(curr, pre=AUTOGENERATED_WARNING_COMMENT)
 94512: 
 94512:         # Done.
 94512:         return curr
 94512: 
 94512:     @staticmethod
 97422:     def RegisterBindings(config):
 94512: 
 94512:         # TODO - Generate the methods we want
 94512:         curr = CGRegisterProtos(config)
 94512: 
 94512:         # Wrap all of that in our namespaces.
 97422:         curr = CGNamespace.build(['mozilla', 'dom'],
 94512:                                  CGWrapper(curr, post='\n'))
 94512:         curr = CGWrapper(curr, post='\n')
 94512: 
 94512:         # Add the includes
101766:         defineIncludes = [CGHeaders.getDeclarationFilename(desc.interface)
 94512:                           for desc in config.getDescriptors(hasInterfaceObject=True,
 99235:                                                             workers=False,
 99235:                                                             register=True)]
 94512:         defineIncludes.append('nsScriptNameSpaceManager.h')
121472:         curr = CGHeaders([], [], [], [], defineIncludes, curr)
 94512: 
 94512:         # Add include guards.
 97422:         curr = CGIncludeGuard('RegisterBindings', curr)
 94512: 
 94512:         # Done.
 94512:         return curr
102822: 
102822:     @staticmethod
102822:     def UnionTypes(config):
102822: 
121482:         (includes, implincludes,
121482:          declarations, unions) = UnionTypes(config.getDescriptors(),
121472:                                             config.getDictionaries(),
121472:                                             config.getCallbacks(),
121472:                                             config)
102822:         includes.add("mozilla/dom/BindingUtils.h")
102822: 
102822:         # Wrap all of that in our namespaces.
102822:         curr = CGNamespace.build(['mozilla', 'dom'], unions)
102822: 
102822:         curr = CGWrapper(curr, post='\n')
102822: 
102822:         namespaces = []
102822:         stack = [CGList([])]
102822:         for (clazz, isStruct) in SortedTuples(declarations):
102822:             elements = clazz.split("::")
102822:             clazz = CGClassForwardDeclare(elements.pop(), isStruct=isStruct)
102822:             i = 0
102822:             if len(elements) > 0:
102822:                 common = min(len(namespaces), len(elements))
102822:                 while i < common and namespaces[i] == elements[i]:
102822:                     i += 1
102822: 
102822:             # pop all the namespaces that should be closed
102822:             namespaces = namespaces[:i]
102822: 
102822:             # add all the namespaces that should be opened
102822:             for j, namespace in enumerate(elements[i:]):
102822:                 namespaces.append(namespace)
102822:                 # every CGNamespace that we add holds a CGList
102822:                 list = CGList([])
102822:                 # add the new namespace to the list on top of the stack
102822:                 stack[i + j].append(CGNamespace(namespace, list))
102822:                 # set the top of the namespace stack to the list of the new
102822:                 # namespace
102822:                 stack[i + j + 1:] = [list]
102822: 
102822:             stack[len(elements)].append(clazz)
102822: 
102822:         curr = CGList([stack[0], curr], "\n")
102822: 
121482:         curr = CGHeaders([], [], [], includes, implincludes, curr)
102822: 
102822:         # Add include guards.
102822:         curr = CGIncludeGuard('UnionTypes', curr)
102822: 
102822:         # Done.
102822:         return curr
102822: 
102822:     @staticmethod
102822:     def UnionConversions(config):
102822: 
102822:         unions = UnionConversions(config.getDescriptors())
102822: 
102822:         # Wrap all of that in our namespaces.
102822:         curr = CGNamespace.build(['mozilla', 'dom'], unions)
102822: 
102822:         curr = CGWrapper(curr, post='\n')
102822: 
121472:         curr = CGHeaders([], [], [], ["nsDebug.h", "mozilla/dom/UnionTypes.h", "nsDOMQS.h", "XPCWrapper.h"], [], curr)
102822: 
102822:         # Add include guards.
102822:         curr = CGIncludeGuard('UnionConversions', curr)
102822: 
102822:         # Done.
102822:         return curr
