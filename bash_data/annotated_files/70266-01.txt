    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Implements nsIStackFrame. */
    1: 
    1: #include "xpcprivate.h"
    1: 
    1: class XPCJSStackFrame : public nsIStackFrame
    1: {
    1: public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSISTACKFRAME
    1: 
    1:     static nsresult CreateStack(JSContext* cx, JSStackFrame* fp,
    1:                                 XPCJSStackFrame** stack);
    1: 
    1:     static nsresult CreateStackFrameLocation(
    1:                                         PRUint32 aLanguage,
    1:                                         const char* aFilename,
    1:                                         const char* aFunctionName,
    1:                                         PRInt32 aLineNumber,
    1:                                         nsIStackFrame* aCaller,
    1:                                         XPCJSStackFrame** stack);
    1: 
    1:     XPCJSStackFrame();
    1:     virtual ~XPCJSStackFrame();
    1: 
    1:     JSBool IsJSFrame() const
    1:         {return mLanguage == nsIProgrammingLanguage::JAVASCRIPT;}
    1: 
    1: private:
70266:     nsCOMPtr<nsIStackFrame> mCaller;
    1: 
    1:     char* mFilename;
    1:     char* mFunname;
    1:     PRInt32 mLineno;
    1:     PRUint32 mLanguage;
    1: };
    1: 
    1: /**********************************************/
    1: 
    1: // static
    1: 
    1: nsresult
    1: XPCJSStack::CreateStack(JSContext* cx, nsIStackFrame** stack)
    1: {
22652:     if(!cx)
    1:         return NS_ERROR_FAILURE;
    1: 
22652:     JSStackFrame *fp = NULL;
22652:     if(!JS_FrameIterator(cx, &fp))
22652:         return NS_ERROR_FAILURE;
22652:     return XPCJSStackFrame::CreateStack(cx, fp, (XPCJSStackFrame**) stack);
    1: }
    1: 
    1: // static
    1: nsresult
    1: XPCJSStack::CreateStackFrameLocation(PRUint32 aLanguage,
    1:                                      const char* aFilename,
    1:                                      const char* aFunctionName,
    1:                                      PRInt32 aLineNumber,
    1:                                      nsIStackFrame* aCaller,
    1:                                      nsIStackFrame** stack)
    1: {
    1:     return XPCJSStackFrame::CreateStackFrameLocation(
    1:                                         aLanguage,
    1:                                         aFilename,
    1:                                         aFunctionName,
    1:                                         aLineNumber,
    1:                                         aCaller,
    1:                                         (XPCJSStackFrame**) stack);
    1: }
    1: 
    1: 
    1: /**********************************************/
    1: 
    1: XPCJSStackFrame::XPCJSStackFrame()
70266:     :   mFilename(nsnull),
    1:         mFunname(nsnull),
    1:         mLineno(0),
    1:         mLanguage(nsIProgrammingLanguage::UNKNOWN)
    1: {
    1: }
    1: 
    1: XPCJSStackFrame::~XPCJSStackFrame()
    1: {
    1:     if(mFilename)
    1:         nsMemory::Free(mFilename);
    1:     if(mFunname)
    1:         nsMemory::Free(mFunname);
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(XPCJSStackFrame, nsIStackFrame)
    1: 
    1: nsresult
    1: XPCJSStackFrame::CreateStack(JSContext* cx, JSStackFrame* fp,
    1:                              XPCJSStackFrame** stack)
    1: {
70266:     nsRefPtr<XPCJSStackFrame> first = new XPCJSStackFrame();
70266:     nsRefPtr<XPCJSStackFrame> self = first;
70266:     while(fp && self)
    1:     {
53557:         if(!JS_IsScriptFrame(cx, fp))
70266:         {
    1:             self->mLanguage = nsIProgrammingLanguage::CPLUSPLUS;
70266:         }
    1:         else
70266:         {
    1:             self->mLanguage = nsIProgrammingLanguage::JAVASCRIPT;
    1:             JSScript* script = JS_GetFrameScript(cx, fp);
    1:             jsbytecode* pc = JS_GetFramePC(cx, fp);
    1:             if(script && pc)
    1:             {
64190:                 JS::AutoEnterScriptCompartment ac;
62072:                 if(ac.enter(cx, script))
62072:                 {
    1:                     const char* filename = JS_GetScriptFilename(cx, script);
    1:                     if(filename)
    1:                     {
    1:                         self->mFilename = (char*)
    1:                             nsMemory::Clone(filename,
    1:                                             sizeof(char)*(strlen(filename)+1));
    1:                     }
    1: 
    1:                     self->mLineno = (PRInt32) JS_PCToLineNumber(cx, script, pc);
    1: 
    1:                     JSFunction* fun = JS_GetFrameFunction(cx, fp);
    1:                     if(fun)
    1:                     {
57814:                         JSString *funid = JS_GetFunctionId(fun);
57814:                         if(funid)
    1:                         {
57814:                             size_t length = JS_GetStringEncodingLength(cx, funid);
57814:                             if(length != size_t(-1))
57814:                             {
57814:                                 self->mFunname = static_cast<char *>(nsMemory::Alloc(length + 1));
57814:                                 if(self->mFunname)
57814:                                 {
57814:                                     JS_EncodeStringToBuffer(funid, self->mFunname, length);
57814:                                     self->mFunname[length] = '\0';
57814:                                 }
57814:                             }
    1:                         }
    1:                     }
    1:                 }
62072:             }
    1:             else
    1:             {
    1:                 self->mLanguage = nsIProgrammingLanguage::CPLUSPLUS;
    1:             }
    1:         }
70266: 
70266:         if(JS_FrameIterator(cx, &fp))
70266:         {
70266:             XPCJSStackFrame* frame = new XPCJSStackFrame();
70266:             self->mCaller = frame;
70266:             self = frame;
    1:         }
    1:     }
    1: 
70266:     *stack = first.forget().get();
70266:     return NS_OK;
    1: }
    1: 
    1: // static
    1: nsresult
    1: XPCJSStackFrame::CreateStackFrameLocation(PRUint32 aLanguage,
    1:                                           const char* aFilename,
    1:                                           const char* aFunctionName,
    1:                                           PRInt32 aLineNumber,
    1:                                           nsIStackFrame* aCaller,
    1:                                           XPCJSStackFrame** stack)
    1: {
    1:     JSBool failed = JS_FALSE;
    1:     XPCJSStackFrame* self = new XPCJSStackFrame();
    1:     if(self)
    1:         NS_ADDREF(self);
    1:     else
    1:         failed = JS_TRUE;
    1: 
    1:     if(!failed)
    1:     {
    1:         self->mLanguage = aLanguage;
    1:         self->mLineno = aLineNumber;
    1:     }
    1: 
    1:     if(!failed && aFilename)
    1:     {
    1:         self->mFilename = (char*)
    1:                 nsMemory::Clone(aFilename,
    1:                         sizeof(char)*(strlen(aFilename)+1));
    1:         if(!self->mFilename)
    1:             failed = JS_TRUE;
    1:     }
    1: 
    1:     if(!failed && aFunctionName)
    1:     {
    1:         self->mFunname = (char*)
    1:                 nsMemory::Clone(aFunctionName,
    1:                         sizeof(char)*(strlen(aFunctionName)+1));
    1:         if(!self->mFunname)
    1:             failed = JS_TRUE;
    1:     }
    1: 
    1:     if(!failed && aCaller)
    1:     {
    1:         self->mCaller = aCaller;
    1:     }
    1: 
    1:     if(failed && self)
    1:     {
    1:         NS_RELEASE(self);   // sets self to nsnull
    1:     }
    1: 
    1:     *stack = self;
    1:     return self ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: /* readonly attribute PRUint32 language; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetLanguage(PRUint32 *aLanguage)
    1: {
    1:     *aLanguage = mLanguage;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute string languageName; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetLanguageName(char * *aLanguageName)
    1: {
    1:     static const char js[] = "JavaScript";
    1:     static const char cpp[] = "C++";
    1:     char* temp;
    1: 
    1:     if(IsJSFrame())
    1:         *aLanguageName = temp = (char*) nsMemory::Clone(js, sizeof(js));
    1:     else
    1:         *aLanguageName = temp = (char*) nsMemory::Clone(cpp, sizeof(cpp));
    1: 
    1:     return temp ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: /* readonly attribute string filename; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetFilename(char * *aFilename)
    1: {
    1:     XPC_STRING_GETTER_BODY(aFilename, mFilename);
    1: }
    1: 
    1: /* readonly attribute string name; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetName(char * *aFunction)
    1: {
    1:     XPC_STRING_GETTER_BODY(aFunction, mFunname);
    1: }
    1: 
    1: /* readonly attribute PRInt32 lineNumber; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetLineNumber(PRInt32 *aLineNumber)
    1: {
    1:     *aLineNumber = mLineno;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute string sourceLine; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetSourceLine(char * *aSourceLine)
    1: {
    1:     *aSourceLine = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIStackFrame caller; */
    1: NS_IMETHODIMP XPCJSStackFrame::GetCaller(nsIStackFrame * *aCaller)
    1: {
70266:     NS_IF_ADDREF(*aCaller = mCaller);
    1:     return NS_OK;
    1: }
    1: 
    1: /* string toString (); */
    1: NS_IMETHODIMP XPCJSStackFrame::ToString(char **_retval)
    1: {
    1:     const char* frametype = IsJSFrame() ? "JS" : "native";
    1:     const char* filename = mFilename ? mFilename : "<unknown filename>";
    1:     const char* funname = mFunname ? mFunname : "<TOP_LEVEL>";
    1:     static const char format[] = "%s frame :: %s :: %s :: line %d";
    1:     int len = sizeof(char)*
    1:                 (strlen(frametype) + strlen(filename) + strlen(funname)) +
    1:               sizeof(format) + 6 /* space for lineno */;
    1: 
    1:     char* buf = (char*) nsMemory::Alloc(len);
    1:     if(!buf)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     JS_snprintf(buf, len, format, frametype, filename, funname, mLineno);
    1:     *_retval = buf;
    1:     return NS_OK;
    1: }
    1: 
