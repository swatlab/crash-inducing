12311: /* -*- Mode: C++; tab-width: 3; indent-tabs-mode: nil; c-basic-offset: 2 -*-
12311:  *
12311:  * ***** BEGIN LICENSE BLOCK *****
12311:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
12311:  *
12311:  * The contents of this file are subject to the Mozilla Public License Version
12311:  * 1.1 (the "License"); you may not use this file except in compliance with
12311:  * the License. You may obtain a copy of the License at
12311:  * http://www.mozilla.org/MPL/
12311:  *
12311:  * Software distributed under the License is distributed on an "AS IS" basis,
12311:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
12311:  * for the specific language governing rights and limitations under the
12311:  * License.
12311:  *
12311:  * The Original Code is the Mozilla browser.
12311:  *
12311:  * The Initial Developer of the Original Code is
12311:  * Netscape Communications, Inc.
12311:  * Portions created by the Initial Developer are Copyright (C) 1999
12311:  * the Initial Developer. All Rights Reserved.
12311:  *
12311:  * Contributor(s):
12311:  *   Scott MacGregor <mscott@netscape.com>
12311:  *   Dan Mosedale <dmose@mozilla.org>
12311:  *   Stan Shebs <stanshebs@earthlink.net>
12311:  *
12311:  * Alternatively, the contents of this file may be used under the terms of
12311:  * either of the GNU General Public License Version 2 or later (the "GPL"),
12311:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
12311:  * in which case the provisions of the GPL or the LGPL are applicable instead
12311:  * of those above. If you wish to allow use of your version of this file only
12311:  * under the terms of either the GPL or the LGPL, and not to allow others to
12311:  * use your version of this file under the terms of the MPL, indicate your
12311:  * decision by deleting the provisions above and replace them with the notice
12311:  * and other provisions required by the GPL or the LGPL. If you do not delete
12311:  * the provisions above, a recipient may use your version of this file under
12311:  * the terms of any one of the MPL, the GPL or the LGPL.
12311:  *
12311:  * ***** END LICENSE BLOCK ***** */
12311: 
12311: #include "nsOSHelperAppService.h"
12538: #include "nsObjCExceptions.h"
12311: #include "nsISupports.h"
12311: #include "nsString.h"
12311: #include "nsTArray.h"
12311: #include "nsXPIDLString.h"
12311: #include "nsIURL.h"
12311: #include "nsILocalFile.h"
12311: #include "nsILocalFileMac.h"
12311: #include "nsMimeTypes.h"
12311: #include "nsIStringBundle.h"
12311: #include "nsIPromptService.h"
12311: #include "nsMemory.h"
12311: #include "nsCRT.h"
12311: #include "nsMIMEInfoMac.h"
12311: #include "nsEmbedCID.h"
12538: 
39217: #import <CoreFoundation/CoreFoundation.h>
39217: #import <ApplicationServices/ApplicationServices.h>
12311: 
12311: // chrome URL's
12311: #define HELPERAPPLAUNCHER_BUNDLE_URL "chrome://global/locale/helperAppLauncher.properties"
12311: #define BRAND_BUNDLE_URL "chrome://branding/locale/brand.properties"
12311: 
12311: extern "C" {
12311:   // Returns the CFURL for application currently set as the default opener for
12311:   // the given URL scheme. appURL must be released by the caller.
12311:   extern OSStatus _LSCopyDefaultSchemeHandlerURL(CFStringRef scheme,
12311:                                                  CFURLRef *appURL);
12311: }
12311: 
29490: /* This is an undocumented interface (in the Foundation framework) that has
29490:  * been stable since at least 10.2.8 and is still present on SnowLeopard.
29490:  * Furthermore WebKit has three public methods (in WebKitSystemInterface.h)
29490:  * that are thin wrappers around this interface's last three methods.  So
29490:  * it's unlikely to change anytime soon.  Now that we're no longer using
29490:  * Internet Config Services, this is the only way to look up a MIME type
29490:  * from an extension, or vice versa.
29490:  */
29490: @class NSURLFileTypeMappingsInternal;
29490: 
29490: @interface NSURLFileTypeMappings : NSObject
29490: {
29490:     NSURLFileTypeMappingsInternal *_internal;
29490: }
29490: 
29490: + (NSURLFileTypeMappings*)sharedMappings;
29490: - (NSString*)MIMETypeForExtension:(NSString*)aString;
29490: - (NSString*)preferredExtensionForMIMEType:(NSString*)aString;
29490: - (NSArray*)extensionsForMIMEType:(NSString*)aString;
29490: @end
29490: 
12311: nsOSHelperAppService::nsOSHelperAppService() : nsExternalHelperAppService()
12311: {
12311: }
12311: 
12311: nsOSHelperAppService::~nsOSHelperAppService()
12311: {}
12311: 
12311: nsresult nsOSHelperAppService::OSProtocolHandlerExists(const char * aProtocolScheme, PRBool * aHandlerExists)
12311: {
40516:   // CFStringCreateWithBytes() can fail even if we're not out of memory --
40516:   // for example if the 'bytes' parameter is something very wierd (like "ÿÿ~"
40516:   // aka "\xFF\xFF~"), or possibly if it can't be interpreted as using what's
40516:   // specified in the 'encoding' parameter.  See bug 548719.
29490:   CFStringRef schemeString = ::CFStringCreateWithBytes(kCFAllocatorDefault,
29490:                                                        (const UInt8*)aProtocolScheme,
29490:                                                        strlen(aProtocolScheme),
29490:                                                        kCFStringEncodingUTF8,
29490:                                                        false);
40516:   if (schemeString) {
29490:     // LSCopyDefaultHandlerForURLScheme() can fail to find the default handler
29490:     // for aProtocolScheme when it's never been explicitly set (using
29490:     // LSSetDefaultHandlerForURLScheme()).  For example, Safari is the default
29490:     // handler for the "http" scheme on a newly installed copy of OS X.  But
29490:     // this (presumably) wasn't done using LSSetDefaultHandlerForURLScheme(),
29490:     // so LSCopyDefaultHandlerForURLScheme() will fail to find Safari.  To get
29490:     // around this we use LSCopyAllHandlersForURLScheme() instead -- which seems
29490:     // never to fail.
29490:     // http://lists.apple.com/archives/Carbon-dev/2007/May/msg00349.html
29490:     // http://www.realsoftware.com/listarchives/realbasic-nug/2008-02/msg00119.html
29490:     CFArrayRef handlerArray = ::LSCopyAllHandlersForURLScheme(schemeString);
29490:     *aHandlerExists = !!handlerArray;
29490:     if (handlerArray)
29490:       ::CFRelease(handlerArray);
29490:     ::CFRelease(schemeString);
40516:   } else {
40516:     *aHandlerExists = PR_FALSE;
40516:   }
29490:   return NS_OK;
12311: }
12311: 
12311: NS_IMETHODIMP nsOSHelperAppService::GetApplicationDescription(const nsACString& aScheme, nsAString& _retval)
12311: {
12538:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
12538: 
12311:   nsresult rv = NS_ERROR_NOT_AVAILABLE;
12311: 
12311:   CFStringRef schemeCFString = 
12311:     ::CFStringCreateWithBytes(kCFAllocatorDefault,
12311:                               (const UInt8 *)PromiseFlatCString(aScheme).get(),
12311:                               aScheme.Length(),
12311:                               kCFStringEncodingUTF8,
12311:                               false);
12311:   if (schemeCFString) {
12311:     // Since the public API (LSGetApplicationForURL) fails every now and then,
12311:     // we're using undocumented _LSCopyDefaultSchemeHandlerURL
12311:     CFURLRef handlerBundleURL;
12311:     OSStatus err = ::_LSCopyDefaultSchemeHandlerURL(schemeCFString,
12311:                                                     &handlerBundleURL);
12311:     if (err == noErr) {
12311:       CFBundleRef handlerBundle = ::CFBundleCreate(NULL, handlerBundleURL);
12311:       if (handlerBundle) {
12311:         // Get the human-readable name of the default handler bundle
12311:         CFStringRef bundleName =
12311:           (CFStringRef)::CFBundleGetValueForInfoDictionaryKey(handlerBundle,
12311:                                                               kCFBundleNameKey);
12311:         if (bundleName) {
12311:           nsAutoTArray<UniChar, 255> buffer;
12311:           CFIndex bundleNameLength = ::CFStringGetLength(bundleName);
12311:           buffer.SetLength(bundleNameLength);
12311:           ::CFStringGetCharacters(bundleName, CFRangeMake(0, bundleNameLength),
12311:                                   buffer.Elements());
12311:           _retval.Assign(buffer.Elements(), bundleNameLength);
12311:           rv = NS_OK;
12311:         }
12311: 
12311:         ::CFRelease(handlerBundle);
12311:       }
12311: 
12311:       ::CFRelease(handlerBundleURL);
12311:     }
12311: 
12311:     ::CFRelease(schemeCFString);
12311:   }
12311: 
12311:   return rv;
12538: 
12538:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
12311: }
12311: 
12311: nsresult nsOSHelperAppService::GetFileTokenForPath(const PRUnichar * aPlatformAppPath, nsIFile ** aFile)
12311: {
12538:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
12538: 
12311:   nsresult rv;
12311:   nsCOMPtr<nsILocalFileMac> localFile (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &rv));
12311:   NS_ENSURE_SUCCESS(rv,rv);
12311: 
12311:   CFURLRef pathAsCFURL;
12311:   CFStringRef pathAsCFString = ::CFStringCreateWithCharacters(NULL,
12311:                                                               aPlatformAppPath,
12311:                                                               nsCRT::strlen(aPlatformAppPath));
12311:   if (!pathAsCFString)
12311:     return NS_ERROR_OUT_OF_MEMORY;
12311: 
12311:   if (::CFStringGetCharacterAtIndex(pathAsCFString, 0) == '/') {
12311:     // we have a Posix path
12311:     pathAsCFURL = ::CFURLCreateWithFileSystemPath(nsnull, pathAsCFString,
12311:                                                   kCFURLPOSIXPathStyle, PR_FALSE);
12311:     if (!pathAsCFURL) {
12311:       ::CFRelease(pathAsCFString);
12311:       return NS_ERROR_OUT_OF_MEMORY;
12311:     }
12311:   }
12311:   else {
12311:     // if it doesn't start with a / it's not an absolute Posix path
12311:     // let's check if it's a HFS path left over from old preferences
12311: 
12311:     // If it starts with a ':' char, it's not an absolute HFS path
12311:     // so bail for that, and also if it's empty
12311:     if (::CFStringGetLength(pathAsCFString) == 0 ||
12311:         ::CFStringGetCharacterAtIndex(pathAsCFString, 0) == ':')
12311:     {
12311:       ::CFRelease(pathAsCFString);
12311:       return NS_ERROR_FILE_UNRECOGNIZED_PATH;
12311:     }
12311: 
12311:     pathAsCFURL = ::CFURLCreateWithFileSystemPath(nsnull, pathAsCFString,
12311:                                                   kCFURLHFSPathStyle, PR_FALSE);
12311:     if (!pathAsCFURL) {
12311:       ::CFRelease(pathAsCFString);
12311:       return NS_ERROR_OUT_OF_MEMORY;
12311:     }
12311:   }
12311: 
12311:   rv = localFile->InitWithCFURL(pathAsCFURL);
12311:   ::CFRelease(pathAsCFString);
12311:   ::CFRelease(pathAsCFURL);
12311:   if (NS_FAILED(rv))
12311:     return rv;
12311:   *aFile = localFile;
12311:   NS_IF_ADDREF(*aFile);
12311: 
12311:   return NS_OK;
12538: 
12538:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
12311: }
12311: 
12311: NS_IMETHODIMP nsOSHelperAppService::GetFromTypeAndExtension(const nsACString& aType, const nsACString& aFileExt, nsIMIMEInfo ** aMIMEInfo)
12311: {
29490:   return nsExternalHelperAppService::GetFromTypeAndExtension(aType, aFileExt, aMIMEInfo);
12311: }
12311: 
29490: // aMIMEType and aFileExt might not match,  If they don't we set *aFound to
29490: // PR_FALSE and return a minimal nsIMIMEInfo structure.
12311: already_AddRefed<nsIMIMEInfo>
12311: nsOSHelperAppService::GetMIMEInfoFromOS(const nsACString& aMIMEType,
12311:                                         const nsACString& aFileExt,
12311:                                         PRBool * aFound)
12311: {
12538:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
12538: 
29490:   *aFound = PR_FALSE;
12311: 
12311:   const nsCString& flatType = PromiseFlatCString(aMIMEType);
12311:   const nsCString& flatExt = PromiseFlatCString(aFileExt);
12311: 
29490:   PR_LOG(mLog, PR_LOG_DEBUG, ("Mac: HelperAppService lookup for type '%s' ext '%s'\n",
29490:                               flatType.get(), flatExt.get()));
12311: 
12311:   // Create a Mac-specific MIME info so we can use Mac-specific members.
12311:   nsMIMEInfoMac* mimeInfoMac = new nsMIMEInfoMac(aMIMEType);
12311:   if (!mimeInfoMac)
12311:     return nsnull;
12311:   NS_ADDREF(mimeInfoMac);
12311: 
39159:   NSAutoreleasePool *localPool = [[NSAutoreleasePool alloc] init];
39159: 
29490:   OSStatus err;
29490:   PRBool haveAppForType = PR_FALSE;
29490:   PRBool haveAppForExt = PR_FALSE;
29490:   PRBool typeAppIsDefault = PR_FALSE;
29490:   PRBool extAppIsDefault = PR_FALSE;
29490:   FSRef typeAppFSRef;
29490:   FSRef extAppFSRef;
29490: 
29490:   if (!aMIMEType.IsEmpty()) {
29490:     CFURLRef appURL = NULL;
40516:     // CFStringCreateWithCString() can fail even if we're not out of memory --
40516:     // for example if the 'cStr' parameter is something very wierd (like "ÿÿ~"
40516:     // aka "\xFF\xFF~"), or possibly if it can't be interpreted as using what's
40516:     // specified in the 'encoding' parameter.  See bug 548719.
29490:     CFStringRef CFType = ::CFStringCreateWithCString(NULL, flatType.get(), kCFStringEncodingUTF8);
40516:     if (CFType) {
29490:       err = ::LSCopyApplicationForMIMEType(CFType, kLSRolesAll, &appURL);
29490:       if ((err == noErr) && appURL && ::CFURLGetFSRef(appURL, &typeAppFSRef)) {
29490:         haveAppForType = PR_TRUE;
29490:         PR_LOG(mLog, PR_LOG_DEBUG, ("LSCopyApplicationForMIMEType found a default application\n"));
29490:       }
29490:       if (appURL)
29490:         ::CFRelease(appURL);
29490:       ::CFRelease(CFType);
29490:     }
40516:   }
29490:   if (!aFileExt.IsEmpty()) {
40516:     // CFStringCreateWithCString() can fail even if we're not out of memory --
40516:     // for example if the 'cStr' parameter is something very wierd (like "ÿÿ~"
40516:     // aka "\xFF\xFF~"), or possibly if it can't be interpreted as using what's
40516:     // specified in the 'encoding' parameter.  See bug 548719.
29490:     CFStringRef CFExt = ::CFStringCreateWithCString(NULL, flatExt.get(), kCFStringEncodingUTF8);
40516:     if (CFExt) {
29490:       err = ::LSGetApplicationForInfo(kLSUnknownType, kLSUnknownCreator, CFExt,
29490:                                       kLSRolesAll, &extAppFSRef, nsnull);
29490:       if (err == noErr) {
29490:         haveAppForExt = PR_TRUE;
29490:         PR_LOG(mLog, PR_LOG_DEBUG, ("LSGetApplicationForInfo found a default application\n"));
29490:       }
40516:       ::CFRelease(CFExt);
40516:     }
29490:   }
29490: 
29490:   if (haveAppForType && haveAppForExt) {
29490:     // Do aMIMEType and aFileExt match?
29490:     if (::FSCompareFSRefs((const FSRef *) &typeAppFSRef, (const FSRef *) &extAppFSRef) == noErr) {
29490:       typeAppIsDefault = PR_TRUE;
29490:       *aFound = PR_TRUE;
29490:     }
29490:   } else if (haveAppForType) {
29490:     // If aFileExt isn't empty, it doesn't match aMIMEType.
29490:     if (aFileExt.IsEmpty()) {
29490:       typeAppIsDefault = PR_TRUE;
29490:       *aFound = PR_TRUE;
29490:     }
29490:   } else if (haveAppForExt) {
29490:     // If aMIMEType isn't empty, it doesn't match aFileExt.
29490:     if (aMIMEType.IsEmpty()) {
29490:       extAppIsDefault = PR_TRUE;
29490:       *aFound = PR_TRUE;
29490:     }
29490:   }
29490: 
29490:   if (aMIMEType.IsEmpty()) {
29490:     if (haveAppForExt) {
29490:       // If aMIMEType is empty and we've found a default app for aFileExt, try
29490:       // to get the MIME type from aFileExt.  (It might also be worth doing
29490:       // this when aMIMEType isn't empty but haveAppForType is false -- but
29490:       // the doc for this method says that if we have a MIME type (in
29490:       // aMIMEType), we need to give it preference.)
29490:       NSURLFileTypeMappings *map = [NSURLFileTypeMappings sharedMappings];
29490:       NSString *extStr = [NSString stringWithCString:flatExt.get() encoding:NSASCIIStringEncoding];
29490:       NSString *typeStr = map ? [map MIMETypeForExtension:extStr] : NULL;
29490:       if (typeStr) {
29490:         nsCAutoString mimeType;
29490:         mimeType.Assign((char *)[typeStr cStringUsingEncoding:NSASCIIStringEncoding]);
29490:         mimeInfoMac->SetMIMEType(mimeType);
29490:         haveAppForType = PR_TRUE;
29490:       } else {
29490:         // Sometimes the OS won't give us a MIME type for an extension that's
29490:         // registered with Launch Services and has a default app:  For example
29490:         // Real Player registers itself for the "ogg" extension and for the
29490:         // audio/x-ogg and application/x-ogg MIME types, but
29490:         // MIMETypeForExtension returns nil for the "ogg" extension even on
29490:         // systems where Real Player is installed.  This is probably an Apple
29490:         // bug.  But bad things happen if we return an nsIMIMEInfo structure
29490:         // with an empty MIME type and set *aFound to PR_TRUE.  So in this
29490:         // case we need to set it to PR_FALSE here.
29490:         haveAppForExt = PR_FALSE;
29490:         extAppIsDefault = PR_FALSE;
29490:         *aFound = PR_FALSE;
29490:       }
29490:     } else {
29490:       // Otherwise set the MIME type to a reasonable fallback.
29490:       mimeInfoMac->SetMIMEType(NS_LITERAL_CSTRING(APPLICATION_OCTET_STREAM));
29490:     }
29490:   }
29490: 
29490:   if (typeAppIsDefault || extAppIsDefault) {
29490:     if (haveAppForExt)
28211:       mimeInfoMac->AppendExtension(aFileExt);
28211: 
12311:     nsCOMPtr<nsILocalFileMac> app(do_CreateInstance(NS_LOCAL_FILE_CONTRACTID));
12311:     if (!app) {
12311:       NS_RELEASE(mimeInfoMac);
39159:       [localPool release];
12311:       return nsnull;
12311:     }
29490: 
29490:     CFStringRef CFAppName = NULL;
29490:     if (typeAppIsDefault) {
29490:       app->InitWithFSRef(&typeAppFSRef);
29490:       ::LSCopyItemAttribute((const FSRef *) &typeAppFSRef, kLSRolesAll,
29490:                             kLSItemDisplayName, (CFTypeRef *) &CFAppName);
12311:     } else {
29490:       app->InitWithFSRef(&extAppFSRef);
29490:       ::LSCopyItemAttribute((const FSRef *) &extAppFSRef, kLSRolesAll,
29490:                             kLSItemDisplayName, (CFTypeRef *) &CFAppName);
12311:     }
29490:     if (CFAppName) {
29490:       nsAutoTArray<UniChar, 255> buffer;
29490:       CFIndex appNameLength = ::CFStringGetLength(CFAppName);
29490:       buffer.SetLength(appNameLength);
29490:       ::CFStringGetCharacters(CFAppName, CFRangeMake(0, appNameLength),
29490:                               buffer.Elements());
29490:       nsAutoString appName;
29490:       appName.Assign(buffer.Elements(), appNameLength);
29490:       mimeInfoMac->SetDefaultDescription(appName);
29490:       ::CFRelease(CFAppName);
12311:     }
12311: 
29490:     mimeInfoMac->SetDefaultApplication(app);
29490:     mimeInfoMac->SetPreferredAction(nsIMIMEInfo::useSystemDefault);
29490:   } else {
29490:     mimeInfoMac->SetPreferredAction(nsIMIMEInfo::saveToDisk);
29490:   }
29490: 
29490:   nsCAutoString mimeType;
29490:   mimeInfoMac->GetMIMEType(mimeType);
29490:   if (*aFound && !mimeType.IsEmpty()) {
29490:     // If we have a MIME type, make sure its preferred extension is included
29490:     // in our list.
29490:     NSURLFileTypeMappings *map = [NSURLFileTypeMappings sharedMappings];
29490:     NSString *typeStr = [NSString stringWithCString:mimeType.get() encoding:NSASCIIStringEncoding];
29490:     NSString *extStr = map ? [map preferredExtensionForMIMEType:typeStr] : NULL;
29490:     if (extStr) {
29490:       nsCAutoString preferredExt;
29490:       preferredExt.Assign((char *)[extStr cStringUsingEncoding:NSASCIIStringEncoding]);
29490:       mimeInfoMac->AppendExtension(preferredExt);
29490:     }
29490: 
29490:     CFStringRef CFType = ::CFStringCreateWithCString(NULL, mimeType.get(), kCFStringEncodingUTF8);
29490:     CFStringRef CFTypeDesc = NULL;
29490:     if (::LSCopyKindStringForMIMEType(CFType, &CFTypeDesc) == noErr) {
29490:       nsAutoTArray<UniChar, 255> buffer;
29490:       CFIndex typeDescLength = ::CFStringGetLength(CFTypeDesc);
29490:       buffer.SetLength(typeDescLength);
29490:       ::CFStringGetCharacters(CFTypeDesc, CFRangeMake(0, typeDescLength),
29490:                               buffer.Elements());
29490:       nsAutoString typeDesc;
29490:       typeDesc.Assign(buffer.Elements(), typeDescLength);
29490:       mimeInfoMac->SetDescription(typeDesc);
29490:     }
29490:     if (CFTypeDesc)
29490:       ::CFRelease(CFTypeDesc);
29490:     ::CFRelease(CFType);
29490:   }
29490: 
29490:   PR_LOG(mLog, PR_LOG_DEBUG, ("OS gave us: type '%s' found '%i'\n", mimeType.get(), *aFound));
29490: 
39159:   [localPool release];
29490:   return mimeInfoMac;
12538: 
12538:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
12311: }
12311: 
12311: NS_IMETHODIMP
12311: nsOSHelperAppService::GetProtocolHandlerInfoFromOS(const nsACString &aScheme,
12311:                                                    PRBool *found,
12311:                                                    nsIHandlerInfo **_retval)
12311: {
12311:   NS_ASSERTION(!aScheme.IsEmpty(), "No scheme was specified!");
12311: 
12311:   nsresult rv = OSProtocolHandlerExists(nsPromiseFlatCString(aScheme).get(),
12311:                                         found);
12311:   if (NS_FAILED(rv))
12311:     return rv;
12311: 
12311:   nsMIMEInfoMac *handlerInfo =
12311:     new nsMIMEInfoMac(aScheme, nsMIMEInfoBase::eProtocolInfo);
12311:   NS_ENSURE_TRUE(handlerInfo, NS_ERROR_OUT_OF_MEMORY);
12311:   NS_ADDREF(*_retval = handlerInfo);
12311: 
12311:   if (!*found) {
12311:     // Code that calls this requires an object regardless if the OS has
12311:     // something for us, so we return the empty object.
12311:     return NS_OK;
12311:   }
12311: 
12311:   nsAutoString desc;
12311:   GetApplicationDescription(aScheme, desc);
12311:   handlerInfo->SetDefaultDescription(desc);
12311: 
12311:   return NS_OK;
12311: }
