    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
31590:  * Portions created by the Initial Developer are Copyright (C) 2005-2009
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
16418:  *   John Daggett <jdaggett@mozilla.com>
31590:  *   Jonathan Kew <jfkthame@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef GFX_FONT_H
    1: #define GFX_FONT_H
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: #include "nsString.h"
    1: #include "gfxPoint.h"
16418: #include "gfxFontUtils.h"
    1: #include "nsTArray.h"
  323: #include "nsTHashtable.h"
  323: #include "nsHashKeys.h"
    1: #include "gfxSkipChars.h"
    1: #include "gfxRect.h"
  323: #include "nsExpirationTracker.h"
24407: #include "gfxFontConstants.h"
37211: #include "gfxPlatform.h"
    1: 
10484: #ifdef DEBUG
10484: #include <stdio.h>
10484: #endif
10484: 
    1: class gfxContext;
    1: class gfxTextRun;
    1: class nsIAtom;
  323: class gfxFont;
31590: class gfxFontFamily;
    1: class gfxFontGroup;
19962: class gfxUserFontSet;
19962: class gfxUserFontData;
    1: 
24407: // We should eliminate these synonyms when it won't cause many merge conflicts.
24407: #define FONT_STYLE_NORMAL              NS_FONT_STYLE_NORMAL
24407: #define FONT_STYLE_ITALIC              NS_FONT_STYLE_ITALIC
24407: #define FONT_STYLE_OBLIQUE             NS_FONT_STYLE_OBLIQUE
    1: 
24407: // We should eliminate these synonyms when it won't cause many merge conflicts.
24407: #define FONT_WEIGHT_NORMAL             NS_FONT_WEIGHT_NORMAL
24407: #define FONT_WEIGHT_BOLD               NS_FONT_WEIGHT_BOLD
    1: 
 2210: #define FONT_MAX_SIZE                  2000.0
 2210: 
    1: struct THEBES_API gfxFontStyle {
12929:     gfxFontStyle();
24408:     gfxFontStyle(PRUint8 aStyle, PRUint16 aWeight, PRInt16 aStretch,
24408:                  gfxFloat aSize, const nsACString& aLangGroup,
    1:                  float aSizeAdjust, PRPackedBool aSystemFont,
22866:                  PRPackedBool aFamilyNameQuirks,
22866:                  PRPackedBool aPrinterFont);
  323:     gfxFontStyle(const gfxFontStyle& aStyle);
    1: 
    1:     // The style of font (normal, italic, oblique)
    1:     PRUint8 style : 7;
    1: 
    1:     // Say that this font is a system font and therefore does not
    1:     // require certain fixup that we do for fonts from untrusted
    1:     // sources.
    1:     PRPackedBool systemFont : 1;
    1: 
22866:     // Say that this font is used for print or print preview.
22866:     PRPackedBool printerFont : 1;
22866: 
    1:     // True if the character set quirks (for treatment of "Symbol",
    1:     // "Wingdings", etc.) should be applied.
    1:     PRPackedBool familyNameQuirks : 1;
    1: 
    1:     // The weight of the font.  100, 200, ... 900 are the weights, and
    1:     // single integer offsets request the next bolder/lighter font
    1:     // available.  For example, for a font available in weights 200,
    1:     // 400, 700, and 900, a weight of 898 should lead to the weight 400
    1:     // font being used, since it is two weights lighter than 900.
    1:     PRUint16 weight;
    1: 
24408:     // The stretch of the font (the sum of various NS_FONT_STRETCH_*
24408:     // constants; see gfxFontConstants.h).
24408:     PRInt16 stretch;
24408: 
    1:     // The logical size of the font, in pixels
    1:     gfxFloat size;
    1: 
    1:     // the language group
    1:     nsCString langGroup;
    1: 
    1:     // The aspect-value (ie., the ratio actualsize:actualxheight) that any
    1:     // actual physical font created from this font structure must have when
    1:     // rendering or measuring a string. A value of 0 means no adjustment
    1:     // needs to be done.
    1:     float sizeAdjust;
    1: 
 2210:     // Return the final adjusted font size for the given aspect ratio.
 2210:     // Not meant to be called when sizeAdjust = 0.
 2210:     gfxFloat GetAdjustedSize(gfxFloat aspect) const {
 2210:         NS_ASSERTION(sizeAdjust != 0.0, "Not meant to be called when sizeAdjust = 0");
 2210:         gfxFloat adjustedSize = PR_MAX(NS_round(size*(sizeAdjust/aspect)), 1.0);
 2210:         return PR_MIN(adjustedSize, FONT_MAX_SIZE);
 2210:     }
 2210: 
  323:     PLDHashNumber Hash() const {
  323:         return ((style + (systemFont << 7) + (familyNameQuirks << 8) +
  323:             (weight << 9)) + PRUint32(size*1000) + PRUint32(sizeAdjust*1000)) ^
  323:             HashString(langGroup);
  323:     }
  323: 
    1:     void ComputeWeightAndOffset(PRInt8 *outBaseWeight,
    1:                                 PRInt8 *outOffset) const;
    1: 
    1:     PRBool Equals(const gfxFontStyle& other) const {
    1:         return (size == other.size) &&
    1:             (style == other.style) &&
    1:             (systemFont == other.systemFont) &&
22866:             (printerFont == other.printerFont) &&
    1:             (familyNameQuirks == other.familyNameQuirks) &&
    1:             (weight == other.weight) &&
24408:             (stretch == other.stretch) &&
    1:             (langGroup.Equals(other.langGroup)) &&
    1:             (sizeAdjust == other.sizeAdjust);
    1:     }
    1: };
    1: 
16418: class gfxFontEntry {
16418: public:
16418:     THEBES_INLINE_DECL_REFCOUNTING(gfxFontEntry)
16418: 
31590:     gfxFontEntry(const nsAString& aName, gfxFontFamily *aFamily = nsnull,
31590:                  PRBool aIsStandardFace = PR_FALSE) : 
24683:         mName(aName), mItalic(PR_FALSE), mFixedPitch(PR_FALSE),
24683:         mIsProxy(PR_FALSE), mIsValid(PR_TRUE), 
29527:         mIsBadUnderlineFont(PR_FALSE), mIsUserFont(PR_FALSE),
31590:         mStandardFace(aIsStandardFace),
36949:         mSymbolFont(PR_FALSE),
24683:         mWeight(500), mStretch(NS_FONT_STRETCH_NORMAL),
31590:         mCmapInitialized(PR_FALSE), mUserFontData(nsnull),
31590:         mFamily(aFamily)
16418:     { }
16418: 
16418:     gfxFontEntry(const gfxFontEntry& aEntry) : 
19962:         mName(aEntry.mName), mItalic(aEntry.mItalic), 
25123:         mFixedPitch(aEntry.mFixedPitch), mIsProxy(aEntry.mIsProxy), 
19962:         mIsValid(aEntry.mIsValid), mIsBadUnderlineFont(aEntry.mIsBadUnderlineFont),
29527:         mIsUserFont(aEntry.mIsUserFont),
31590:         mStandardFace(aEntry.mStandardFace),
36949:         mSymbolFont(aEntry.mSymbolFont),
19962:         mWeight(aEntry.mWeight), mCmapInitialized(aEntry.mCmapInitialized),
31590:         mCharacterMap(aEntry.mCharacterMap), mUserFontData(aEntry.mUserFontData),
31590:         mFamily(aEntry.mFamily)
16418:     { }
16418: 
16418:     virtual ~gfxFontEntry();
16418: 
16418:     // unique name for the face, *not* the family
16418:     const nsString& Name() const { return mName; }
16418: 
36949:     PRUint16 Weight() const { return mWeight; }
36949:     PRInt16 Stretch() const { return mStretch; }
16418: 
36949:     PRBool IsUserFont() const { return mIsUserFont; }
36949:     PRBool IsFixedPitch() const { return mFixedPitch; }
36949:     PRBool IsItalic() const { return mItalic; }
36949:     PRBool IsBold() const { return mWeight >= 600; } // bold == weights 600 and above
36949:     PRBool IsSymbolFont() const { return mSymbolFont; }
16418: 
16418:     inline PRBool HasCharacter(PRUint32 ch) {
16418:         if (mCharacterMap.test(ch))
16418:             return PR_TRUE;
16418:             
16418:         return TestCharacterMap(ch);
16418:     }
16418: 
16418:     virtual PRBool TestCharacterMap(PRUint32 aCh);
31590:     virtual nsresult ReadCMAP();
31590: 
36949:     virtual PRBool MatchesGenericFamily(const nsACString& aGeneric) const {
36949:         return PR_TRUE;
36949:     }
36949:     virtual PRBool SupportsLangGroup(const nsACString& aLangGroup) const {
36949:         return PR_TRUE;
36949:     }
36949: 
36967:     void SetFamily(gfxFontFamily* aFamily) {
36967:         mFamily = aFamily;
36967:     }
36967: 
31590:     const nsString& FamilyName();
16418: 
38202:     already_AddRefed<gfxFont> FindOrMakeFont(const gfxFontStyle *aStyle, PRBool aNeedsBold);
37211: 
16418:     nsString         mName;
16418: 
16418:     PRPackedBool     mItalic      : 1;
16418:     PRPackedBool     mFixedPitch  : 1;
19962:     PRPackedBool     mIsProxy     : 1;
19962:     PRPackedBool     mIsValid     : 1;
19962:     PRPackedBool     mIsBadUnderlineFont : 1;
29527:     PRPackedBool     mIsUserFont  : 1;
31590:     PRPackedBool     mStandardFace : 1;
36949:     PRPackedBool     mSymbolFont  : 1;
16418: 
16418:     PRUint16         mWeight;
31590:     PRInt16          mStretch;
16418: 
16418:     PRPackedBool     mCmapInitialized;
16418:     gfxSparseBitSet  mCharacterMap;
19962:     gfxUserFontData* mUserFontData;
31590: 
31590: protected:
31590:     friend class gfxPlatformFontList;
31590:     friend class gfxMacPlatformFontList;
31590:     friend class gfxFcFontEntry;
31590:     friend class gfxFontFamily;
37618:     friend class gfxSingleFaceMacFontFamily;
31590: 
31590:     gfxFontEntry() :
31590:         mItalic(PR_FALSE), mFixedPitch(PR_FALSE),
31590:         mIsProxy(PR_FALSE), mIsValid(PR_TRUE), 
31590:         mIsBadUnderlineFont(PR_FALSE),
31590:         mIsUserFont(PR_FALSE),
31590:         mStandardFace(PR_FALSE),
36949:         mSymbolFont(PR_FALSE),
31590:         mWeight(500), mStretch(NS_FONT_STRETCH_NORMAL),
31590:         mCmapInitialized(PR_FALSE),
31590:         mUserFontData(nsnull),
31590:         mFamily(nsnull)
31590:     { }
31590: 
31590:     virtual nsresult GetFontTable(PRUint32 aTableTag, nsTArray<PRUint8>& aBuffer) {
31590:         return NS_ERROR_FAILURE; // all platform subclasses should reimplement this!
31590:     }
31590: 
37211:     virtual gfxFont *CreateFontInstance(const gfxFontStyle *aFontStyle, PRBool aNeedsBold) {
37211:         NS_NOTREACHED("oops, somebody didn't override CreateFontInstance");
37211:         return nsnull;
37211:     }
37211: 
31590:     gfxFontFamily *mFamily;
16418: };
16418: 
16418: 
31590: // used when picking fallback font
31590: struct FontSearch {
31590:     FontSearch(const PRUint32 aCharacter, gfxFont *aFont) :
31590:         mCh(aCharacter), mFontToMatch(aFont), mMatchRank(0) {
31590:     }
31590:     const PRUint32         mCh;
31590:     gfxFont*               mFontToMatch;
31590:     PRInt32                mMatchRank;
31590:     nsRefPtr<gfxFontEntry> mBestMatch;
31590: };
31590: 
16418: class gfxFontFamily {
16418: public:
16418:     THEBES_INLINE_DECL_REFCOUNTING(gfxFontFamily)
16418: 
16418:     gfxFontFamily(const nsAString& aName) :
35525:         mName(aName),
35525:         mOtherFamilyNamesInitialized(PR_FALSE),
35525:         mHasOtherFamilyNames(PR_FALSE),
37618:         mFaceNamesInitialized(PR_FALSE),
35525:         mHasStyles(PR_FALSE),
31590:         mIsSimpleFamily(PR_FALSE),
35525:         mIsBadUnderlineFamily(PR_FALSE)
31590:         { }
16418: 
16418:     virtual ~gfxFontFamily() { }
16418: 
16418:     const nsString& Name() { return mName; }
16418: 
31590:     virtual void LocalizedName(nsAString& aLocalizedName);
31590:     virtual PRBool HasOtherFamilyNames();
31590:     
31590:     nsTArray<nsRefPtr<gfxFontEntry> >& GetFontList() { return mAvailableFonts; }
31590:     
31590:     void AddFontEntry(nsRefPtr<gfxFontEntry> aFontEntry) {
31590:         mAvailableFonts.AppendElement(aFontEntry);
31590:     }
31590: 
31590:     // note that the styles for this family have been added
31590:     void SetHasStyles(PRBool aHasStyles) { mHasStyles = aHasStyles; }
31590: 
19962:     // choose a specific face to match a style using CSS font matching
19962:     // rules (weight matching occurs here)
31590:     // may return a face that doesn't precisely match (e.g. normal face when no italic face exists)
31590:     // aNeedsBold is set to true when bolder face couldn't be found, false otherwise
19962:     gfxFontEntry *FindFontForStyle(const gfxFontStyle& aFontStyle, 
19962:                                    PRBool& aNeedsBold);
16418: 
31590:     // iterates over faces looking for a match with a given characters
31590:     // used as part of the font fallback process
31590:     void FindFontForChar(FontSearch *aMatchData);
31590: 
31590:     // read in other family names, if any, and use functor to add each into cache
37618:     virtual void ReadOtherFamilyNames(gfxPlatformFontList *aPlatformFontList);
37618: 
37618:     // read in other localized family names, fullnames and Postscript names
37618:     // for all faces and append to lookup tables
37618:     virtual void ReadFaceNames(gfxPlatformFontList *aPlatformFontList,
37618:                                PRBool aNeedFullnamePostscriptNames);
31590: 
35525:     // find faces belonging to this family (platform implementations override this;
35525:     // should be made pure virtual once all subclasses have been updated)
31590:     virtual void FindStyleVariations() { }
31590: 
31590:     // search for a specific face using the Postscript name
31590:     gfxFontEntry* FindFont(const nsAString& aPostscriptName);
31590: 
31590:     // read in cmaps for all the faces
31590:     void ReadCMAP() {
31590:         PRUint32 i, numFonts = mAvailableFonts.Length();
31590:         // called from RunLoader BEFORE CheckForSimpleFamily so that there cannot
31590:         // be any NULL entries in mAvailableFonts
31590:         for (i = 0; i < numFonts; i++)
31590:             mAvailableFonts[i]->ReadCMAP();
31590:     }
31590: 
35525:     // mark this family as being in the "bad" underline offset blacklist
35525:     void SetBadUnderlineFamily() {
35525:         mIsBadUnderlineFamily = PR_TRUE;
35525:         if (mHasStyles) {
35525:             SetBadUnderlineFonts();
35525:         }
31590:     }
31590: 
37599:     PRBool IsBadUnderlineFamily() const { return mIsBadUnderlineFamily; }
37599: 
31590:     // sort available fonts to put preferred (standard) faces towards the end
31590:     void SortAvailableFonts();
31590: 
31590:     // check whether the family fits into the simple 4-face model,
31590:     // so we can use simplified style-matching;
31590:     // if so set the mIsSimpleFamily flag (defaults to False before we've checked)
31590:     void CheckForSimpleFamily();
31590: 
16418: protected:
31590:     // fills in an array with weights of faces that match style,
31590:     // returns whether any matching entries found
19962:     virtual PRBool FindWeightsForStyle(gfxFontEntry* aFontsForWeights[],
31590:                                        PRBool anItalic, PRInt16 aStretch);
31590: 
37618:     PRBool ReadOtherFamilyNamesForFace(gfxPlatformFontList *aPlatformFontList,
37618:                                        nsTArray<PRUint8>& aNameTable,
33382:                                        PRBool useFullName = PR_FALSE);
16418: 
35525:     // set whether this font family is in "bad" underline offset blacklist.
35525:     void SetBadUnderlineFonts() {
35525:         PRUint32 i, numFonts = mAvailableFonts.Length();
35525:         for (i = 0; i < numFonts; i++) {
35525:             if (mAvailableFonts[i]) {
35525:                 mAvailableFonts[i]->mIsBadUnderlineFont = PR_TRUE;
35525:             }
35525:         }
35525:     }
35525: 
16418:     nsString mName;
31590:     nsTArray<nsRefPtr<gfxFontEntry> >  mAvailableFonts;
31590:     PRPackedBool mOtherFamilyNamesInitialized;
31590:     PRPackedBool mHasOtherFamilyNames;
37618:     PRPackedBool mFaceNamesInitialized;
35525:     PRPackedBool mHasStyles;
31590:     PRPackedBool mIsSimpleFamily;
35525:     PRPackedBool mIsBadUnderlineFamily;
31590: 
31590:     enum {
31590:         // for "simple" families, the faces are stored in mAvailableFonts
31590:         // with fixed positions:
31590:         kRegularFaceIndex    = 0,
31590:         kBoldFaceIndex       = 1,
31590:         kItalicFaceIndex     = 2,
31590:         kBoldItalicFaceIndex = 3,
31590:         // mask values for selecting face with bold and/or italic attributes
31590:         kBoldMask   = 0x01,
31590:         kItalicMask = 0x02
31590:     };
16418: };
16418: 
16418: struct gfxTextRange {
16418:     gfxTextRange(PRUint32 aStart,  PRUint32 aEnd) : start(aStart), end(aEnd) { }
16418:     PRUint32 Length() const { return end - start; }
16418:     nsRefPtr<gfxFont> font;
16418:     PRUint32 start, end;
16418: };
16418: 
16418: 
  323: /**
  323:  * Font cache design:
  323:  * 
  323:  * The mFonts hashtable contains most fonts, indexed by (name, style).
  323:  * It does not add a reference to the fonts it contains.
  323:  * When a font's refcount decreases to zero, instead of deleting it we
  323:  * add it to our expiration tracker.
  323:  * The expiration tracker tracks fonts with zero refcount. After a certain
  323:  * period of time, such fonts expire and are deleted.
  323:  *
  323:  * We're using 3 generations with a ten-second generation interval, so
  323:  * zero-refcount fonts will be deleted 20-30 seconds after their refcount
  323:  * goes to zero, if timer events fire in a timely manner.
  323:  */
  323: class THEBES_API gfxFontCache : public nsExpirationTracker<gfxFont,3> {
  323: public:
 1656:     enum { TIMEOUT_SECONDS = 10 };
  323:     gfxFontCache()
  323:         : nsExpirationTracker<gfxFont,3>(TIMEOUT_SECONDS*1000) { mFonts.Init(); }
  323:     ~gfxFontCache() {
  323:         // Expire everything that has a zero refcount, so we don't leak them.
  323:         AgeAllGenerations();
 3117:         // All fonts should be gone.
 3117:         NS_WARN_IF_FALSE(mFonts.Count() == 0,
  323:                          "Fonts still alive while shutting down gfxFontCache");
  323:         // Note that we have to delete everything through the expiration
  323:         // tracker, since there might be fonts not in the hashtable but in
  323:         // the tracker.
  323:     }
    1: 
  323:     /*
  323:      * Get the global gfxFontCache.  You must call Init() before
  323:      * calling this method --- the result will not be null.
  323:      */
  323:     static gfxFontCache* GetCache() {
  323:         return gGlobalCache;
  323:     }
  323: 
  323:     static nsresult Init();
  323:     // It's OK to call this even if Init() has not been called.
  323:     static void Shutdown();
  323: 
  323:     // Look up a font in the cache. Returns an addrefed pointer, or null
  323:     // if there's nothing matching in the cache
  323:     already_AddRefed<gfxFont> Lookup(const nsAString &aName,
  323:                                      const gfxFontStyle *aFontGroup);
  323:     // We created a new font (presumably because Lookup returned null);
  323:     // put it in the cache. The font's refcount should be nonzero. It is
  323:     // allowable to add a new font even if there is one already in the
  323:     // cache with the same key; we'll forget about the old one.
  323:     void AddNew(gfxFont *aFont);
  323: 
  323:     // The font's refcount has gone to zero; give ownership of it to
  323:     // the cache. We delete it if it's not acquired again after a certain
  323:     // amount of time.
  323:     void NotifyReleased(gfxFont *aFont);
  323: 
  323:     // This gets called when the timeout has expired on a zero-refcount
  323:     // font; we just delete it.
  323:     virtual void NotifyExpired(gfxFont *aFont);
  323: 
  323: protected:
  323:     void DestroyFont(gfxFont *aFont);
  323: 
  323:     static gfxFontCache *gGlobalCache;
  323: 
  323:     struct Key {
  323:         const nsAString&    mString;
  323:         const gfxFontStyle* mStyle;
  323:         Key(const nsAString& aString, const gfxFontStyle* aStyle)
  323:             : mString(aString), mStyle(aStyle) {}
  323:     };
  323: 
  323:     class HashEntry : public PLDHashEntryHdr {
  323:     public:
  323:         typedef const Key& KeyType;
  323:         typedef const Key* KeyTypePointer;
  323: 
  323:         // When constructing a new entry in the hashtable, we'll leave this
  323:         // blank. The caller of Put() will fill this in.
  323:         HashEntry(KeyTypePointer aStr) : mFont(nsnull) { }
  323:         HashEntry(const HashEntry& toCopy) : mFont(toCopy.mFont) { }
  323:         ~HashEntry() { }
  323: 
  323:         PRBool KeyEquals(const KeyTypePointer aKey) const;
  323:         static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
  323:         static PLDHashNumber HashKey(const KeyTypePointer aKey) {
  323:             return HashString(aKey->mString) ^ aKey->mStyle->Hash();
  323:         }
  323:         enum { ALLOW_MEMMOVE = PR_TRUE };
  323: 
  323:         gfxFont* mFont;
  323:     };
  323: 
  323:     nsTHashtable<HashEntry> mFonts;
  323: };
    1: 
 6247: /**
 6247:  * This stores glyph bounds information for a particular gfxFont, at
 6247:  * a particular appunits-per-dev-pixel ratio (because the compressed glyph
 6247:  * width array is stored in appunits).
 6247:  * 
 6247:  * We store a hashtable from glyph IDs to float bounding rects. For the
 6247:  * common case where the glyph has no horizontal left bearing, and no
 6247:  * y overflow above the font ascent or below the font descent, and tight
 6247:  * bounding boxes are not required, we avoid storing the glyph ID in the hashtable
 6247:  * and instead consult an array of 16-bit glyph XMost values (in appunits).
 6247:  * This array always has an entry for the font's space glyph --- the width is
 6247:  * assumed to be zero.
 6247:  */
 6247: class THEBES_API gfxGlyphExtents {
 6247: public:
 6247:     gfxGlyphExtents(PRUint32 aAppUnitsPerDevUnit) :
 6247:         mAppUnitsPerDevUnit(aAppUnitsPerDevUnit) {
 6513:         MOZ_COUNT_CTOR(gfxGlyphExtents);
 6247:         mTightGlyphExtents.Init();
 6247:     }
 6513:     ~gfxGlyphExtents();
 6247: 
 6247:     enum { INVALID_WIDTH = 0xFFFF };
 6247: 
 6247:     // returns INVALID_WIDTH => not a contained glyph
 6247:     // Otherwise the glyph has no before-bearing or vertical bearings,
 6247:     // and the result is its width measured from the baseline origin, in
 6247:     // appunits.
 6247:     PRUint16 GetContainedGlyphWidthAppUnits(PRUint32 aGlyphID) const {
 6513:         return mContainedGlyphWidths.Get(aGlyphID);
 6247:     }
 6247: 
 6247:     PRBool IsGlyphKnown(PRUint32 aGlyphID) const {
 6513:         return mContainedGlyphWidths.Get(aGlyphID) != INVALID_WIDTH ||
 6513:             mTightGlyphExtents.GetEntry(aGlyphID) != nsnull;
 6247:     }
 6247: 
 6247:     PRBool IsGlyphKnownWithTightExtents(PRUint32 aGlyphID) const {
 6247:         return mTightGlyphExtents.GetEntry(aGlyphID) != nsnull;
 6247:     }
 6247: 
 6247:     // Get glyph extents; a rectangle relative to the left baseline origin
 9576:     // Returns true on success. Can fail on OOM or when aContext is null
 9576:     // and extents were not (successfully) prefetched.
 9576:     PRBool GetTightGlyphExtentsAppUnits(gfxFont *aFont, gfxContext *aContext,
 9576:             PRUint32 aGlyphID, gfxRect *aExtents);
 6247: 
 6513:     void SetContainedGlyphWidthAppUnits(PRUint32 aGlyphID, PRUint16 aWidth) {
 6513:         mContainedGlyphWidths.Set(aGlyphID, aWidth);
 6513:     }
 6247:     void SetTightGlyphExtents(PRUint32 aGlyphID, const gfxRect& aExtentsAppUnits);
 6247: 
 6247:     PRUint32 GetAppUnitsPerDevUnit() { return mAppUnitsPerDevUnit; }
 6247: 
 6247: private:
 6247:     class HashEntry : public nsUint32HashKey {
 6247:     public:
 6247:         // When constructing a new entry in the hashtable, we'll leave this
 6247:         // blank. The caller of Put() will fill this in.
 6247:         HashEntry(KeyTypePointer aPtr) : nsUint32HashKey(aPtr) {}
 6247:         HashEntry(const HashEntry& toCopy) : nsUint32HashKey(toCopy) {
 6247:           x = toCopy.x; y = toCopy.y; width = toCopy.width; height = toCopy.height;
 6247:         }
 6247: 
 6247:         float x, y, width, height;
 6247:     };
 6247: 
32259:     typedef PRUptrdiff PtrBits;
 6513:     enum { BLOCK_SIZE_BITS = 7, BLOCK_SIZE = 1 << BLOCK_SIZE_BITS }; // 128-glyph blocks
 6513: 
 6513:     class GlyphWidths {
 6513:     public:
 6513:         void Set(PRUint32 aIndex, PRUint16 aValue);
 6513:         PRUint16 Get(PRUint32 aIndex) const {
 6513:             PRUint32 block = aIndex >> BLOCK_SIZE_BITS;
 6513:             if (block >= mBlocks.Length())
 6513:                 return INVALID_WIDTH;
 6513:             PtrBits bits = mBlocks[block];
 6513:             if (!bits)
 6513:                 return INVALID_WIDTH;
 6513:             PRUint32 indexInBlock = aIndex & (BLOCK_SIZE - 1);
 6513:             if (bits & 0x1) {
 6513:                 if (GetGlyphOffset(bits) != indexInBlock)
 6513:                     return INVALID_WIDTH;
 6513:                 return GetWidth(bits);
 6513:             }
 6513:             PRUint16 *widths = reinterpret_cast<PRUint16 *>(bits);
 6513:             return widths[indexInBlock];
 6513:         }
 6513: 
 6513: #ifdef DEBUG
 6513:         PRUint32 ComputeSize();
 6513: #endif
 6513:         
 6513:         ~GlyphWidths();
 6513: 
 6513:     private:
 6513:         static PRUint32 GetGlyphOffset(PtrBits aBits) {
 6513:             NS_ASSERTION(aBits & 0x1, "This is really a pointer...");
 6513:             return (aBits >> 1) & ((1 << BLOCK_SIZE_BITS) - 1);
 6513:         }
 6513:         static PRUint32 GetWidth(PtrBits aBits) {
 6513:             NS_ASSERTION(aBits & 0x1, "This is really a pointer...");
 6513:             return aBits >> (1 + BLOCK_SIZE_BITS);
 6513:         }
 6513:         static PtrBits MakeSingle(PRUint32 aGlyphOffset, PRUint16 aWidth) {
 6513:             return (aWidth << (1 + BLOCK_SIZE_BITS)) + (aGlyphOffset << 1) + 1;
 6513:         }
 6513: 
 6513:         nsTArray<PtrBits> mBlocks;
 6513:     };
 6513:     
 6513:     GlyphWidths             mContainedGlyphWidths;
 6247:     nsTHashtable<HashEntry> mTightGlyphExtents;
 6247:     PRUint32                mAppUnitsPerDevUnit;
 6247: };
 6247: 
    1: /* a SPECIFIC single font family */
    1: class THEBES_API gfxFont {
  323: public:
  323:     nsrefcnt AddRef(void) {
  323:         NS_PRECONDITION(PRInt32(mRefCnt) >= 0, "illegal refcnt");
10514:         if (mExpirationState.IsTracked()) {
10514:             gfxFontCache::GetCache()->RemoveObject(this);
10514:         }
  323:         ++mRefCnt;
  323:         NS_LOG_ADDREF(this, mRefCnt, "gfxFont", sizeof(*this));
  323:         return mRefCnt;
  323:     }
  323:     nsrefcnt Release(void) {
  323:         NS_PRECONDITION(0 != mRefCnt, "dup release");
  323:         --mRefCnt;
  323:         NS_LOG_RELEASE(this, mRefCnt, "gfxFont");
  323:         if (mRefCnt == 0) {
19479:             NotifyReleased();
19479:             // |this| may have been deleted.
19409:             return 0;
  323:         }
  323:         return mRefCnt;
  323:     }
  323: 
  323:     PRInt32 GetRefCount() { return mRefCnt; }
  323: 
  323: protected:
  323:     nsAutoRefCnt mRefCnt;
    1: 
19479:     void NotifyReleased() {
19479:         gfxFontCache *cache = gfxFontCache::GetCache();
19479:         if (cache) {
19479:             // Don't delete just yet; return the object to the cache for
19479:             // possibly recycling within some time limit
19479:             cache->NotifyReleased(this);
19479:         } else {
19479:             // The cache may have already been shut down.
19479:             delete this;
19479:         }
19479:     }
19479: 
19479:     gfxFont(gfxFontEntry *aFontEntry, const gfxFontStyle *aFontStyle);
19479: 
19409: public:
 6247:     virtual ~gfxFont();
    1: 
37211:     PRBool Valid() {
37211:         return mIsValid;
37211:     }
37211: 
25417:     // options for the kind of bounding box to return from measurement
25417:     typedef enum {
25417:         LOOSE_INK_EXTENTS,
25417:             // A box that encloses all the painted pixels, and may
25417:             // include sidebearings and/or additional ascent/descent
25417:             // within the glyph cell even if the ink is smaller.
25417:         TIGHT_INK_EXTENTS,
25417:             // A box that tightly encloses all the painted pixels
25417:             // (although actually on Windows, at least, it may be
25417:             // slightly larger than strictly necessary because
25417:             // we can't get precise extents with ClearType).
25417:         TIGHT_HINTED_OUTLINE_EXTENTS
25417:             // A box that tightly encloses the glyph outline,
25417:             // ignoring possible antialiasing pixels that extend
25417:             // beyond this.
25417:             // NOTE: The default implementation of gfxFont::Measure(),
25417:             // which works with the glyph extents cache, does not
25417:             // differentiate between this and TIGHT_INK_EXTENTS.
25417:             // Whether the distinction is important depends on the
25417:             // antialiasing behavior of the platform; currently the
25417:             // distinction is only implemented in the gfxWindowsFont
25417:             // subclass, because of ClearType's tendency to paint
25417:             // outside the hinted outline.
25417:             // Also NOTE: it is relatively expensive to request this,
25417:             // as it does not use cached glyph extents in the font.
25417:     } BoundingBoxType;
25417: 
16418:     const nsString& GetName() const { return mFontEntry->Name(); }
  323:     const gfxFontStyle *GetStyle() const { return &mStyle; }
    1: 
    1:     virtual nsString GetUniqueName() = 0;
    1: 
    1:     // Font metrics
    1:     struct Metrics {
    1:         gfxFloat xHeight;
    1:         gfxFloat superscriptOffset;
    1:         gfxFloat subscriptOffset;
    1:         gfxFloat strikeoutSize;
    1:         gfxFloat strikeoutOffset;
    1:         gfxFloat underlineSize;
    1:         gfxFloat underlineOffset;
    1: 
    1:         gfxFloat internalLeading;
    1:         gfxFloat externalLeading;
    1: 
    1:         gfxFloat emHeight;
    1:         gfxFloat emAscent;
    1:         gfxFloat emDescent;
    1:         gfxFloat maxHeight;
    1:         gfxFloat maxAscent;
    1:         gfxFloat maxDescent;
    1:         gfxFloat maxAdvance;
    1: 
    1:         gfxFloat aveCharWidth;
    1:         gfxFloat spaceWidth;
15955:         gfxFloat zeroOrAveCharWidth;  // width of '0', or if there is
15955:                                       // no '0' glyph in this font,
15955:                                       // equal to .aveCharWidth
    1:     };
    1:     virtual const gfxFont::Metrics& GetMetrics() = 0;
    1: 
    1:     /**
    1:      * We let layout specify spacing on either side of any
    1:      * character. We need to specify both before and after
    1:      * spacing so that substring measurement can do the right things.
    1:      * These values are in appunits. They're always an integral number of
    1:      * appunits, but we specify them in floats in case very large spacing
    1:      * values are required.
    1:      */
    1:     struct Spacing {
    1:         gfxFloat mBefore;
    1:         gfxFloat mAfter;
    1:     };
    1:     /**
    1:      * Metrics for a particular string
    1:      */
16581:     struct THEBES_API RunMetrics {
    1:         RunMetrics() {
    1:             mAdvanceWidth = mAscent = mDescent = 0.0;
    1:             mBoundingBox = gfxRect(0,0,0,0);
    1:         }
    1: 
16581:         void CombineWith(const RunMetrics& aOther, PRBool aOtherIsOnLeft);
    1: 
    1:         // can be negative (partly due to negative spacing).
    1:         // Advance widths should be additive: the advance width of the
    1:         // (offset1, length1) plus the advance width of (offset1 + length1,
    1:         // length2) should be the advance width of (offset1, length1 + length2)
    1:         gfxFloat mAdvanceWidth;
    1:         
    1:         // For zero-width substrings, these must be zero!
    1:         gfxFloat mAscent;  // always non-negative
    1:         gfxFloat mDescent; // always non-negative
    1:         
    1:         // Bounding box that is guaranteed to include everything drawn.
25417:         // If a tight boundingBox was requested when these metrics were
    1:         // generated, this will tightly wrap the glyphs, otherwise it is
    1:         // "loose" and may be larger than the true bounding box.
    1:         // Coordinates are relative to the baseline left origin, so typically
    1:         // mBoundingBox.y == -mAscent
    1:         gfxRect  mBoundingBox;
    1:     };
    1: 
    1:     /**
    1:      * Draw a series of glyphs to aContext. The direction of aTextRun must
    1:      * be honoured.
    1:      * @param aStart the first character to draw
    1:      * @param aEnd draw characters up to here
    1:      * @param aBaselineOrigin the baseline origin; the left end of the baseline
    1:      * for LTR textruns, the right end of the baseline for RTL textruns. On return,
    1:      * this should be updated to the other end of the baseline. In application
    1:      * units, really!
    1:      * @param aSpacing spacing to insert before and after characters (for RTL
    1:      * glyphs, before-spacing is inserted to the right of characters). There
    1:      * are aEnd - aStart elements in this array, unless it's null to indicate
    1:      * that there is no spacing.
    1:      * @param aDrawToPath when true, add the glyph outlines to the current path
    1:      * instead of drawing the glyphs
    1:      * 
    1:      * Callers guarantee:
    1:      * -- aStart and aEnd are aligned to cluster and ligature boundaries
    1:      * -- all glyphs use this font
    1:      * 
    1:      * The default implementation builds a cairo glyph array and
    1:      * calls cairo_show_glyphs or cairo_glyph_path.
    1:      */
    1:     virtual void Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
    1:                       gfxContext *aContext, PRBool aDrawToPath, gfxPoint *aBaselineOrigin,
    1:                       Spacing *aSpacing);
    1:     /**
    1:      * Measure a run of characters. See gfxTextRun::Metrics.
    1:      * @param aTight if false, then return the union of the glyph extents
    1:      * with the font-box for the characters (the rectangle with x=0,width=
    1:      * the advance width for the character run,y=-(font ascent), and height=
    1:      * font ascent + font descent). Otherwise, we must return as tight as possible
    1:      * an approximation to the area actually painted by glyphs.
 9576:      * @param aContextForTightBoundingBox when aTight is true, this must
 9576:      * be non-null.
    1:      * @param aSpacing spacing to insert before and after glyphs. The bounding box
    1:      * need not include the spacing itself, but the spacing affects the glyph
    1:      * positions. null if there is no spacing.
    1:      * 
    1:      * Callers guarantee:
    1:      * -- aStart and aEnd are aligned to cluster and ligature boundaries
    1:      * -- all glyphs use this font
    1:      * 
    1:      * The default implementation just uses font metrics and aTextRun's
    1:      * advances, and assumes no characters fall outside the font box. In
    1:      * general this is insufficient, because that assumption is not always true.
    1:      */
    1:     virtual RunMetrics Measure(gfxTextRun *aTextRun,
    1:                                PRUint32 aStart, PRUint32 aEnd,
25417:                                BoundingBoxType aBoundingBoxType,
 6247:                                gfxContext *aContextForTightBoundingBox,
    1:                                Spacing *aSpacing);
    1:     /**
    1:      * Line breaks have been changed at the beginning and/or end of a substring
    1:      * of the text. Reshaping may be required; glyph updating is permitted.
    1:      * @return true if anything was changed, false otherwise
    1:      */
    1:     PRBool NotifyLineBreaksChanged(gfxTextRun *aTextRun,
    1:                                    PRUint32 aStart, PRUint32 aLength)
    1:     { return PR_FALSE; }
    1: 
  323:     // Expiration tracking
  323:     nsExpirationState *GetExpirationState() { return &mExpirationState; }
  323: 
 1295:     // Get the glyphID of a space
 1295:     virtual PRUint32 GetSpaceGlyph() = 0;
 1295: 
 6247:     gfxGlyphExtents *GetOrCreateGlyphExtents(PRUint32 aAppUnitsPerDevUnit);
 6247: 
 6247:     // You need to call SetupCairoFont on the aCR just before calling this
 6247:     virtual void SetupGlyphExtents(gfxContext *aContext, PRUint32 aGlyphID,
 6247:                                    PRBool aNeedTight, gfxGlyphExtents *aExtents);
 6247: 
 6247:     // This is called by the default Draw() implementation above.
 6247:     virtual PRBool SetupCairoFont(gfxContext *aContext) = 0;
 6247: 
13339:     PRBool IsSyntheticBold() { return mSyntheticBoldOffset != 0; }
13339:     PRUint32 GetSyntheticBoldOffset() { return mSyntheticBoldOffset; }
13339: 
16418:     gfxFontEntry *GetFontEntry() { return mFontEntry.get(); }
16418:     PRBool HasCharacter(PRUint32 ch) {
16418:         if (!mIsValid)
16418:             return PR_FALSE;
16418:         return mFontEntry->HasCharacter(ch); 
16418:     }
16418: 
37211:     virtual void InitTextRun(gfxTextRun *aTextRun,
37211:                              const PRUnichar *aString,
37211:                              PRUint32 aRunStart,
37211:                              PRUint32 aRunLength) {
37211:         NS_NOTREACHED("oops, somebody didn't override InitTextRun");
37211:     }
37211: 
    1: protected:
16418:     nsRefPtr<gfxFontEntry> mFontEntry;
16418: 
16418:     PRPackedBool               mIsValid;
  323:     nsExpirationState          mExpirationState;
  323:     gfxFontStyle               mStyle;
 6247:     nsAutoTArray<gfxGlyphExtents*,1> mGlyphExtentsArray;
11765: 
13339:     // synthetic bolding for environments where this is not supported by the platform
13339:     PRUint32                   mSyntheticBoldOffset;  // number of devunit pixels to offset double-strike, 0 ==> no bolding
13339: 
11765:     // some fonts have bad metrics, this method sanitize them.
12989:     // if this font has bad underline offset, aIsBadUnderlineFont should be true.
12989:     void SanitizeMetrics(gfxFont::Metrics *aMetrics, PRBool aIsBadUnderlineFont);
    1: };
    1: 
    1: class THEBES_API gfxTextRunFactory {
    1:     THEBES_INLINE_DECL_REFCOUNTING(gfxTextRunFactory)
    1: 
    1: public:
    1:     // Flags in the mask 0xFFFF0000 are reserved for textrun clients
    1:     // Flags in the mask 0x0000F000 are reserved for per-platform fonts
    1:     // Flags in the mask 0x00000FFF are set by the textrun creator.
    1:     enum {
 3118:         CACHE_TEXT_FLAGS    = 0xF0000000,
 3118:         USER_TEXT_FLAGS     = 0x0FFF0000,
 2317:         PLATFORM_TEXT_FLAGS = 0x0000F000,
 2317:         TEXTRUN_TEXT_FLAGS  = 0x00000FFF,
 3118:         SETTABLE_FLAGS      = CACHE_TEXT_FLAGS | USER_TEXT_FLAGS,
 2317: 
    1:         /**
    1:          * When set, the text string pointer used to create the text run
    1:          * is guaranteed to be available during the lifetime of the text run.
    1:          */
    1:         TEXT_IS_PERSISTENT           = 0x0001,
    1:         /**
    1:          * When set, the text is known to be all-ASCII (< 128).
    1:          */
    1:         TEXT_IS_ASCII                = 0x0002,
    1:         /**
    1:          * When set, the text is RTL.
    1:          */
    1:         TEXT_IS_RTL                  = 0x0004,
    1:         /**
    1:          * When set, spacing is enabled and the textrun needs to call GetSpacing
    1:          * on the spacing provider.
    1:          */
    1:         TEXT_ENABLE_SPACING          = 0x0008,
    1:         /**
    1:          * When set, GetHyphenationBreaks may return true for some character
    1:          * positions, otherwise it will always return false for all characters.
    1:          */
30879:         TEXT_ENABLE_HYPHEN_BREAKS    = 0x0010,
    1:         /**
 3437:          * When set, the text has no characters above 255 and it is stored
 3437:          * in the textrun in 8-bit format.
    1:          */
30879:         TEXT_IS_8BIT                 = 0x0020,
    1:         /**
    1:          * When set, the RunMetrics::mBoundingBox field will be initialized
    1:          * properly based on glyph extents, in particular, glyph extents that
    1:          * overflow the standard font-box (the box defined by the ascent, descent
    1:          * and advance width of the glyph). When not set, it may just be the
    1:          * standard font-box even if glyphs overflow.
    1:          */
30879:         TEXT_NEED_BOUNDING_BOX       = 0x0040,
 2027:         /**
 3437:          * When set, optional ligatures are disabled. Ligatures that are
 3437:          * required for legible text should still be enabled.
 2027:          */
30879:         TEXT_DISABLE_OPTIONAL_LIGATURES = 0x0080,
 4032:         /**
 4032:          * When set, the textrun should favour speed of construction over
 4032:          * quality. This may involve disabling ligatures and/or kerning or
 4032:          * other effects.
 4032:          */
30879:         TEXT_OPTIMIZE_SPEED          = 0x0100
    1:     };
    1: 
    1:     /**
    1:      * This record contains all the parameters needed to initialize a textrun.
    1:      */
    1:     struct Parameters {
    1:         // A reference context suggesting where the textrun will be rendered
    1:         gfxContext   *mContext;
    1:         // Pointer to arbitrary user data (which should outlive the textrun)
    1:         void         *mUserData;
    1:         // A description of which characters have been stripped from the original
    1:         // DOM string to produce the characters in the textrun. May be null
    1:         // if that information is not relevant.
    1:         gfxSkipChars *mSkipChars;
    1:         // A list of where linebreaks are currently placed in the textrun. May
    1:         // be null if mInitialBreakCount is zero.
    1:         PRUint32     *mInitialBreaks;
    1:         PRUint32      mInitialBreakCount;
    1:         // The ratio to use to convert device pixels to application layout units
    1:         PRUint32      mAppUnitsPerDevUnit;
    1:     };
    1: 
    1:     virtual ~gfxTextRunFactory() {}
    1: };
    1: 
    1: /**
    1:  * gfxTextRun is an abstraction for drawing and measuring substrings of a run
    1:  * of text. It stores runs of positioned glyph data, each run having a single
    1:  * gfxFont. The glyphs are associated with a string of source text, and the
    1:  * gfxTextRun APIs take parameters that are offsets into that source text.
    1:  * 
    1:  * gfxTextRuns are not refcounted. They should be deleted when no longer required.
    1:  * 
    1:  * gfxTextRuns are mostly immutable. The only things that can change are
    1:  * inter-cluster spacing and line break placement. Spacing is always obtained
    1:  * lazily by methods that need it, it is not cached. Line breaks are stored
    1:  * persistently (insofar as they affect the shaping of glyphs; gfxTextRun does
    1:  * not actually do anything to explicitly account for line breaks). Initially
    1:  * there are no line breaks. The textrun can record line breaks before or after
    1:  * any given cluster. (Line breaks specified inside clusters are ignored.)
    1:  * 
    1:  * It is important that zero-length substrings are handled correctly. This will
    1:  * be on the test!
    1:  * 
    1:  * gfxTextRun stores a list of zero or more glyphs for each character. For each
    1:  * glyph we store the glyph ID, the advance, and possibly an xoffset and yoffset.
    1:  * The idea is that a string is rendered by a loop that draws each glyph
    1:  * at its designated offset from the current point, then advances the current
    1:  * point by the glyph's advance in the direction of the textrun (LTR or RTL).
    1:  * Each glyph advance is always rounded to the nearest appunit; this ensures
    1:  * consistent results when dividing the text in a textrun into multiple text
    1:  * frames (frame boundaries are always aligned to appunits). We optimize
    1:  * for the case where a character has a single glyph and zero xoffset and yoffset,
    1:  * and the glyph ID and advance are in a reasonable range so we can pack all
    1:  * necessary data into 32 bits.
 4434:  * 
 4434:  * gfxTextRun methods that measure or draw substrings will associate all the
 4434:  * glyphs in a cluster with the first character of the cluster; if that character
 4434:  * is in the substring, the glyphs will be measured or drawn, otherwise they
 4434:  * won't.
    1:  */
    1: class THEBES_API gfxTextRun {
    1: public:
 1295:     virtual ~gfxTextRun();
    1: 
    1:     typedef gfxFont::RunMetrics Metrics;
    1: 
    1:     // Public textrun API for general use
    1: 
    1:     PRBool IsClusterStart(PRUint32 aPos) {
    1:         NS_ASSERTION(0 <= aPos && aPos < mCharacterCount, "aPos out of range");
    1:         return mCharacterGlyphs[aPos].IsClusterStart();
    1:     }
 7715:     PRBool IsLigatureGroupStart(PRUint32 aPos) {
    1:         NS_ASSERTION(0 <= aPos && aPos < mCharacterCount, "aPos out of range");
 7715:         return mCharacterGlyphs[aPos].IsLigatureGroupStart();
    1:     }
    1:     PRBool CanBreakLineBefore(PRUint32 aPos) {
    1:         NS_ASSERTION(0 <= aPos && aPos < mCharacterCount, "aPos out of range");
    1:         return mCharacterGlyphs[aPos].CanBreakBefore();
    1:     }
    1: 
    1:     PRUint32 GetLength() { return mCharacterCount; }
    1: 
    1:     // All PRUint32 aStart, PRUint32 aLength ranges below are restricted to
    1:     // grapheme cluster boundaries! All offsets are in terms of the string
    1:     // passed into MakeTextRun.
    1:     
    1:     // All coordinates are in layout/app units
    1: 
    1:     /**
    1:      * Set the potential linebreaks for a substring of the textrun. These are
    1:      * the "allow break before" points. Initially, there are no potential
    1:      * linebreaks.
    1:      * 
    6:      * This can change glyphs and/or geometry! Some textruns' shapes
    6:      * depend on potential line breaks (e.g., title-case-converting textruns).
    6:      * This function is virtual so that those textruns can reshape themselves.
    6:      * 
    1:      * @return true if this changed the linebreaks, false if the new line
    1:      * breaks are the same as the old
    1:      */
    6:     virtual PRBool SetPotentialLineBreaks(PRUint32 aStart, PRUint32 aLength,
 2834:                                           PRPackedBool *aBreakBefore,
 2834:                                           gfxContext *aRefContext);
    1: 
    1:     /**
    1:      * Layout provides PropertyProvider objects. These allow detection of
    1:      * potential line break points and computation of spacing. We pass the data
    1:      * this way to allow lazy data acquisition; for example BreakAndMeasureText
    1:      * will want to only ask for properties of text it's actually looking at.
    1:      * 
    1:      * NOTE that requested spacing may not actually be applied, if the textrun
    1:      * is unable to apply it in some context. Exception: spacing around a
    1:      * whitespace character MUST always be applied.
    1:      */
    6:     class PropertyProvider {
    1:     public:
    1:         // Detect hyphenation break opportunities in the given range; breaks
    1:         // not at cluster boundaries will be ignored.
    1:         virtual void GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
    1:                                           PRPackedBool *aBreakBefore) = 0;
    1: 
    1:         // Returns the extra width that will be consumed by a hyphen. This should
    1:         // be constant for a given textrun.
    1:         virtual gfxFloat GetHyphenWidth() = 0;
    1: 
    1:         typedef gfxFont::Spacing Spacing;
    1: 
    1:         /**
    1:          * Get the spacing around the indicated characters. Spacing must be zero
    1:          * inside clusters. In other words, if character i is not
    1:          * CLUSTER_START, then character i-1 must have zero after-spacing and
    1:          * character i must have zero before-spacing.
    1:          */
    1:         virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength,
    1:                                 Spacing *aSpacing) = 0;
    1:     };
    1: 
    1:     /**
    1:      * Draws a substring. Uses only GetSpacing from aBreakProvider.
    1:      * The provided point is the baseline origin on the left of the string
    1:      * for LTR, on the right of the string for RTL.
    1:      * @param aDirtyRect if non-null, drawing outside of the rectangle can be
    1:      * (but does not need to be) dropped. Note that if this is null, we cannot
    1:      * draw partial ligatures and we will assert if partial ligatures
    1:      * are detected.
    1:      * @param aAdvanceWidth if non-null, the advance width of the substring
    1:      * is returned here.
    1:      * 
    1:      * Drawing should respect advance widths in the sense that for LTR runs,
    1:      * Draw(ctx, pt, offset1, length1, dirty, &provider, &advance) followed by
    1:      * Draw(ctx, gfxPoint(pt.x + advance, pt.y), offset1 + length1, length2,
    1:      *      dirty, &provider, nsnull) should have the same effect as
    1:      * Draw(ctx, pt, offset1, length1+length2, dirty, &provider, nsnull).
    1:      * For RTL runs the rule is:
    1:      * Draw(ctx, pt, offset1 + length1, length2, dirty, &provider, &advance) followed by
    1:      * Draw(ctx, gfxPoint(pt.x + advance, pt.y), offset1, length1,
    1:      *      dirty, &provider, nsnull) should have the same effect as
    1:      * Draw(ctx, pt, offset1, length1+length2, dirty, &provider, nsnull).
    1:      * 
    1:      * Glyphs should be drawn in logical content order, which can be significant
    1:      * if they overlap (perhaps due to negative spacing).
    1:      */
    1:     void Draw(gfxContext *aContext, gfxPoint aPt,
    1:               PRUint32 aStart, PRUint32 aLength,
    1:               const gfxRect *aDirtyRect,
    1:               PropertyProvider *aProvider,
    1:               gfxFloat *aAdvanceWidth);
    1: 
    1:     /**
    1:      * Renders a substring to a path. Uses only GetSpacing from aBreakProvider.
    1:      * The provided point is the baseline origin on the left of the string
    1:      * for LTR, on the right of the string for RTL.
    1:      * @param aAdvanceWidth if non-null, the advance width of the substring
    1:      * is returned here.
    1:      * 
    1:      * Drawing should respect advance widths in the way that Draw above does.
    1:      * 
    1:      * Glyphs should be drawn in logical content order.
    1:      * 
    1:      * UNLIKE Draw above, this cannot be used to render substrings that start or
    1:      * end inside a ligature.
    1:      */
    1:     void DrawToPath(gfxContext *aContext, gfxPoint aPt,
    1:                     PRUint32 aStart, PRUint32 aLength,
    1:                     PropertyProvider *aBreakProvider,
    1:                     gfxFloat *aAdvanceWidth);
    1: 
    1:     /**
    1:      * Computes the ReflowMetrics for a substring.
    1:      * Uses GetSpacing from aBreakProvider.
25417:      * @param aBoundingBoxType which kind of bounding box (loose/tight)
    1:      */
    1:     Metrics MeasureText(PRUint32 aStart, PRUint32 aLength,
25417:                         gfxFont::BoundingBoxType aBoundingBoxType,
 6247:                         gfxContext *aRefContextForTightBoundingBox,
    1:                         PropertyProvider *aProvider);
    1: 
    1:     /**
    1:      * Computes just the advance width for a substring.
    1:      * Uses GetSpacing from aBreakProvider.
    1:      */
    1:     gfxFloat GetAdvanceWidth(PRUint32 aStart, PRUint32 aLength,
    1:                              PropertyProvider *aProvider);
    1: 
    1:     /**
    1:      * Clear all stored line breaks for the given range (both before and after),
    1:      * and then set the line-break state before aStart to aBreakBefore and
    1:      * after the last cluster to aBreakAfter.
    1:      * 
    1:      * We require that before and after line breaks be consistent. For clusters
    1:      * i and i+1, we require that if there is a break after cluster i, a break
    1:      * will be specified before cluster i+1. This may be temporarily violated
    1:      * (e.g. after reflowing line L and before reflowing line L+1); to handle
    1:      * these temporary violations, we say that there is a break betwen i and i+1
    1:      * if a break is specified after i OR a break is specified before i+1.
    1:      * 
    1:      * This can change textrun geometry! The existence of a linebreak can affect
    1:      * the advance width of the cluster before the break (when kerning) or the
    1:      * geometry of one cluster before the break or any number of clusters
    1:      * after the break. (The one-cluster-before-the-break limit is somewhat
    1:      * arbitrary; if some scripts require breaking it, then we need to
    1:      * alter nsTextFrame::TrimTrailingWhitespace, perhaps drastically becase
    1:      * it could affect the layout of frames before it...)
    1:      * 
    6:      * We return true if glyphs or geometry changed, false otherwise. This
    6:      * function is virtual so that gfxTextRun subclasses can reshape
    6:      * properly.
    6:      * 
    1:      * @param aAdvanceWidthDelta if non-null, returns the change in advance
    1:      * width of the given range.
    1:      */
    6:     virtual PRBool SetLineBreaks(PRUint32 aStart, PRUint32 aLength,
    1:                                  PRBool aLineBreakBefore, PRBool aLineBreakAfter,
 2834:                                  gfxFloat *aAdvanceWidthDelta,
 2834:                                  gfxContext *aRefContext);
    1: 
    1:     /**
    1:      * Finds the longest substring that will fit into the given width.
    1:      * Uses GetHyphenationBreaks and GetSpacing from aBreakProvider.
    1:      * Guarantees the following:
    1:      * -- 0 <= result <= aMaxLength
    1:      * -- result is the maximal value of N such that either
    1:      *       N < aMaxLength && line break at N && GetAdvanceWidth(aStart, N) <= aWidth
    1:      *   OR  N < aMaxLength && hyphen break at N && GetAdvanceWidth(aStart, N) + GetHyphenWidth() <= aWidth
    1:      *   OR  N == aMaxLength && GetAdvanceWidth(aStart, N) <= aWidth
    1:      * where GetAdvanceWidth assumes the effect of
    1:      * SetLineBreaks(aStart, N, aLineBreakBefore, N < aMaxLength, aProvider)
    1:      * -- if no such N exists, then result is the smallest N such that
    1:      *       N < aMaxLength && line break at N
    1:      *   OR  N < aMaxLength && hyphen break at N
    1:      *   OR  N == aMaxLength
    1:      *
    1:      * The call has the effect of
    1:      * SetLineBreaks(aStart, result, aLineBreakBefore, result < aMaxLength, aProvider)
    1:      * and the returned metrics and the invariants above reflect this.
    1:      *
    1:      * @param aMaxLength this can be PR_UINT32_MAX, in which case the length used
    1:      * is up to the end of the string
    1:      * @param aLineBreakBefore set to true if and only if there is an actual
    1:      * line break at the start of this string.
    1:      * @param aSuppressInitialBreak if true, then we assume there is no possible
    1:      * linebreak before aStart. If false, then we will check the internal
    1:      * line break opportunity state before deciding whether to return 0 as the
    1:      * character to break before.
 1731:      * @param aTrimWhitespace if non-null, then we allow a trailing run of
 1731:      * spaces to be trimmed; the width of the space(s) will not be included in
 1731:      * the measured string width for comparison with the limit aWidth, and
 1731:      * trimmed spaces will not be included in returned metrics. The width
 1731:      * of the trimmed spaces will be returned in aTrimWhitespace.
 1731:      * Trimmed spaces are still counted in the "characters fit" result.
    1:      * @param aMetrics if non-null, we fill this in for the returned substring.
    1:      * If a hyphenation break was used, the hyphen is NOT included in the returned metrics.
25417:      * @param aBoundingBoxType whether to make the bounding box in aMetrics tight
 6247:      * @param aRefContextForTightBoundingBox a reference context to get the
25417:      * tight bounding box, if requested
    1:      * @param aUsedHyphenation if non-null, records if we selected a hyphenation break
    1:      * @param aLastBreak if non-null and result is aMaxLength, we set this to
    1:      * the maximal N such that
    1:      *       N < aMaxLength && line break at N && GetAdvanceWidth(aStart, N) <= aWidth
    1:      *   OR  N < aMaxLength && hyphen break at N && GetAdvanceWidth(aStart, N) + GetHyphenWidth() <= aWidth
    1:      * or PR_UINT32_MAX if no such N exists, where GetAdvanceWidth assumes
    1:      * the effect of
    1:      * SetLineBreaks(aStart, N, aLineBreakBefore, N < aMaxLength, aProvider)
    1:      *
16166:      * @param aCanWordWrap true if we can break between any two grapheme
16166:      * clusters. This is set by word-wrap: break-word
16166:      *
16166:      * @param aBreakPriority in/out the priority of the break opportunity
16166:      * saved in the line. If we are prioritizing break opportunities, we will
16166:      * not set a break with a lower priority. @see gfxBreakPriority.
16166:      * 
    1:      * Note that negative advance widths are possible especially if negative
    1:      * spacing is provided.
    1:      */
    1:     PRUint32 BreakAndMeasureText(PRUint32 aStart, PRUint32 aMaxLength,
    1:                                  PRBool aLineBreakBefore, gfxFloat aWidth,
    1:                                  PropertyProvider *aProvider,
    1:                                  PRBool aSuppressInitialBreak,
 1731:                                  gfxFloat *aTrimWhitespace,
25417:                                  Metrics *aMetrics,
25417:                                  gfxFont::BoundingBoxType aBoundingBoxType,
 6247:                                  gfxContext *aRefContextForTightBoundingBox,
    1:                                  PRBool *aUsedHyphenation,
16166:                                  PRUint32 *aLastBreak,
16166:                                  PRBool aCanWordWrap,
16166:                                  gfxBreakPriority *aBreakPriority);
    1: 
    1:     /**
    1:      * Update the reference context.
    1:      * XXX this is a hack. New text frame does not call this. Use only
    1:      * temporarily for old text frame.
    1:      */
    1:     void SetContext(gfxContext *aContext) {}
    1: 
    1:     // Utility getters
    1: 
    1:     PRBool IsRightToLeft() const { return (mFlags & gfxTextRunFactory::TEXT_IS_RTL) != 0; }
    1:     gfxFloat GetDirection() const { return (mFlags & gfxTextRunFactory::TEXT_IS_RTL) ? -1.0 : 1.0; }
    1:     void *GetUserData() const { return mUserData; }
 1295:     void SetUserData(void *aUserData) { mUserData = aUserData; }
    1:     PRUint32 GetFlags() const { return mFlags; }
 2317:     void SetFlagBits(PRUint32 aFlags) {
 3118:       NS_ASSERTION(!(aFlags & ~gfxTextRunFactory::SETTABLE_FLAGS),
 2317:                    "Only user flags should be mutable");
 2317:       mFlags |= aFlags;
 2317:     }
 2317:     void ClearFlagBits(PRUint32 aFlags) {
 3118:       NS_ASSERTION(!(aFlags & ~gfxTextRunFactory::SETTABLE_FLAGS),
 2317:                    "Only user flags should be mutable");
 2317:       mFlags &= ~aFlags;
 2317:     }
    1:     const gfxSkipChars& GetSkipChars() const { return mSkipChars; }
    1:     PRUint32 GetAppUnitsPerDevUnit() const { return mAppUnitsPerDevUnit; }
 1295:     gfxFontGroup *GetFontGroup() const { return mFontGroup; }
 1295:     const PRUint8 *GetText8Bit() const
 1295:     { return (mFlags & gfxTextRunFactory::TEXT_IS_8BIT) ? mText.mSingle : nsnull; }
 1295:     const PRUnichar *GetTextUnicode() const
 1295:     { return (mFlags & gfxTextRunFactory::TEXT_IS_8BIT) ? nsnull : mText.mDouble; }
 2317:     const void *GetTextAt(PRUint32 aIndex) {
 2317:         return (mFlags & gfxTextRunFactory::TEXT_IS_8BIT)
 3233:             ? static_cast<const void *>(mText.mSingle + aIndex)
 3233:             : static_cast<const void *>(mText.mDouble + aIndex);
 2317:     }
 1433:     const PRUnichar GetChar(PRUint32 i) const
 1433:     { return (mFlags & gfxTextRunFactory::TEXT_IS_8BIT) ? mText.mSingle[i] : mText.mDouble[i]; }
 1384:     PRUint32 GetHashCode() const { return mHashCode; }
 1384:     void SetHashCode(PRUint32 aHash) { mHashCode = aHash; }
    1: 
 8081:     // Call this, don't call "new gfxTextRun" directly. This does custom
 8081:     // allocation and initialization
 8081:     static gfxTextRun *Create(const gfxTextRunFactory::Parameters *aParams,
 8081:         const void *aText, PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags);
 1295: 
 1295:     // Clone this textrun, according to the given parameters. This textrun's
 1295:     // glyph data is copied, so the text and length must be the same as this
 1295:     // textrun's. If there's a problem, return null. Actual linebreaks will
 1295:     // be set as per aParams; there will be no potential linebreaks.
 1435:     // If aText is not persistent (aFlags & TEXT_IS_PERSISTENT), the
 1435:     // textrun will copy it.
 1295:     virtual gfxTextRun *Clone(const gfxTextRunFactory::Parameters *aParams, const void *aText,
 1295:                               PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags);
    1: 
    1:     /**
    1:      * This class records the information associated with a character in the
    1:      * input string. It's optimized for the case where there is one glyph
    1:      * representing that character alone.
 7715:      * 
 7715:      * A character can have zero or more associated glyphs. Each glyph
 7715:      * has an advance width and an x and y offset.
 7715:      * A character may be the start of a cluster.
 7715:      * A character may be the start of a ligature group.
 7715:      * A character can be "missing", indicating that the system is unable
 7715:      * to render the character.
 7715:      * 
 7715:      * All characters in a ligature group conceptually share all the glyphs
 7715:      * associated with the characters in a group.
    1:      */
    1:     class CompressedGlyph {
    1:     public:
    1:         CompressedGlyph() { mValue = 0; }
    1: 
    1:         enum {
 7715:             // Indicates that a cluster and ligature group starts at this
 7715:             // character; this character has a single glyph with a reasonable
 7715:             // advance and zero offsets. A "reasonable" advance
 7715:             // is one that fits in the available bits (currently 14) (specified
 7715:             // in appunits).
    1:             FLAG_IS_SIMPLE_GLYPH  = 0x80000000U,
    1:             // Indicates that a linebreak is allowed before this character
    1:             FLAG_CAN_BREAK_BEFORE = 0x40000000U,
    1: 
    1:             // The advance is stored in appunits
    1:             ADVANCE_MASK  = 0x3FFF0000U,
    1:             ADVANCE_SHIFT = 16,
    1: 
    1:             GLYPH_MASK = 0x0000FFFFU,
    1: 
 7715:             // Non-simple glyphs may or may not have glyph data in the
 7715:             // corresponding mDetailedGlyphs entry. They have the following
 7715:             // flag bits:
    1: 
 7715:             // When NOT set, indicates that this character corresponds to a
 7715:             // missing glyph and should be skipped (or possibly, render the character
 7715:             // Unicode value in some special way). If there are glyphs,
 7715:             // the mGlyphID is actually the UTF16 character code. The bit is
 7715:             // inverted so we can memset the array to zero to indicate all missing.
 7715:             FLAG_NOT_MISSING              = 0x01,
 7715:             FLAG_NOT_CLUSTER_START        = 0x02,
 7715:             FLAG_NOT_LIGATURE_GROUP_START = 0x04,
    1:             
 7715:             GLYPH_COUNT_MASK = 0x00FFFF00U,
 7715:             GLYPH_COUNT_SHIFT = 8
    1:         };
    1: 
    1:         // "Simple glyphs" have a simple glyph ID, simple advance and their
    1:         // x and y offsets are zero. Also the glyph extents do not overflow
    1:         // the font-box defined by the font ascent, descent and glyph advance width.
    1:         // These case is optimized to avoid storing DetailedGlyphs.
    1: 
    1:         // Returns true if the glyph ID aGlyph fits into the compressed representation
    1:         static PRBool IsSimpleGlyphID(PRUint32 aGlyph) {
    1:             return (aGlyph & GLYPH_MASK) == aGlyph;
    1:         }
    1:         // Returns true if the advance aAdvance fits into the compressed representation.
 1385:         // aAdvance is in appunits.
    1:         static PRBool IsSimpleAdvance(PRUint32 aAdvance) {
    1:             return (aAdvance & (ADVANCE_MASK >> ADVANCE_SHIFT)) == aAdvance;
    1:         }
    1: 
    1:         PRBool IsSimpleGlyph() const { return (mValue & FLAG_IS_SIMPLE_GLYPH) != 0; }
    1:         PRUint32 GetSimpleAdvance() const { return (mValue & ADVANCE_MASK) >> ADVANCE_SHIFT; }
    1:         PRUint32 GetSimpleGlyph() const { return mValue & GLYPH_MASK; }
    1: 
 7715:         PRBool IsMissing() const { return (mValue & (FLAG_NOT_MISSING|FLAG_IS_SIMPLE_GLYPH)) == 0; }
 7715:         PRBool IsClusterStart() const {
 7715:             return (mValue & FLAG_IS_SIMPLE_GLYPH) || !(mValue & FLAG_NOT_CLUSTER_START);
 7715:         }
 7715:         PRBool IsLigatureGroupStart() const {
 7715:             return (mValue & FLAG_IS_SIMPLE_GLYPH) || !(mValue & FLAG_NOT_LIGATURE_GROUP_START);
 7715:         }
26688:         PRBool IsLigatureContinuation() const {
26688:             return (mValue & FLAG_IS_SIMPLE_GLYPH) == 0 &&
26688:                 (mValue & (FLAG_NOT_LIGATURE_GROUP_START | FLAG_NOT_MISSING)) ==
26688:                     (FLAG_NOT_LIGATURE_GROUP_START | FLAG_NOT_MISSING);
26688:         }
    1: 
    1:         PRBool CanBreakBefore() const { return (mValue & FLAG_CAN_BREAK_BEFORE) != 0; }
    1:         // Returns FLAG_CAN_BREAK_BEFORE if the setting changed, 0 otherwise
    1:         PRUint32 SetCanBreakBefore(PRBool aCanBreakBefore) {
 6247:             NS_ASSERTION(aCanBreakBefore == PR_FALSE || aCanBreakBefore == PR_TRUE,
 6247:                          "Bogus break-before value!");
    1:             PRUint32 breakMask = aCanBreakBefore*FLAG_CAN_BREAK_BEFORE;
    1:             PRUint32 toggle = breakMask ^ (mValue & FLAG_CAN_BREAK_BEFORE);
    1:             mValue ^= toggle;
    1:             return toggle;
    1:         }
    1: 
 1385:         CompressedGlyph& SetSimpleGlyph(PRUint32 aAdvanceAppUnits, PRUint32 aGlyph) {
 1385:             NS_ASSERTION(IsSimpleAdvance(aAdvanceAppUnits), "Advance overflow");
    1:             NS_ASSERTION(IsSimpleGlyphID(aGlyph), "Glyph overflow");
    1:             mValue = (mValue & FLAG_CAN_BREAK_BEFORE) | FLAG_IS_SIMPLE_GLYPH |
 1385:                 (aAdvanceAppUnits << ADVANCE_SHIFT) | aGlyph;
    1:             return *this;
    1:         }
 7715:         CompressedGlyph& SetComplex(PRBool aClusterStart, PRBool aLigatureStart,
 7715:                 PRUint32 aGlyphCount) {
 7715:             mValue = (mValue & FLAG_CAN_BREAK_BEFORE) | FLAG_NOT_MISSING |
 7715:                 (aClusterStart ? 0 : FLAG_NOT_CLUSTER_START) |
 7715:                 (aLigatureStart ? 0 : FLAG_NOT_LIGATURE_GROUP_START) |
 7715:                 (aGlyphCount << GLYPH_COUNT_SHIFT);
    1:             return *this;
    1:         }
 7715:         /**
 7715:          * Missing glyphs are treated as cluster and ligature group starts.
 7715:          */
 7715:         CompressedGlyph& SetMissing(PRUint32 aGlyphCount) {
 7715:             mValue = (mValue & FLAG_CAN_BREAK_BEFORE) |
 7715:                 (aGlyphCount << GLYPH_COUNT_SHIFT);
 7715:             return *this;
 7715:         }
 7715:         PRUint32 GetGlyphCount() const {
 7715:             NS_ASSERTION(!IsSimpleGlyph(), "Expected non-simple-glyph");
 7715:             return (mValue & GLYPH_COUNT_MASK) >> GLYPH_COUNT_SHIFT;
 7715:         }
 7715: 
    1:     private:
    1:         PRUint32 mValue;
    1:     };
    1: 
    1:     /**
    1:      * When the glyphs for a character don't fit into a CompressedGlyph record
    1:      * in SimpleGlyph format, we use an array of DetailedGlyphs instead.
    1:      */
    1:     struct DetailedGlyph {
 7715:         /** The glyphID, or the Unicode character
 7715:          * if this is a missing glyph */
 7715:         PRUint32 mGlyphID;
  780:         /** The advance, x-offset and y-offset of the glyph, in appunits
  780:          *  mAdvance is in the text direction (RTL or LTR)
  780:          *  mXOffset is always from left to right
  780:          *  mYOffset is always from bottom to top */   
    1:         PRInt32  mAdvance;
    1:         float    mXOffset, mYOffset;
    1:     };
    1: 
    1:     // The text is divided into GlyphRuns as necessary
    1:     struct GlyphRun {
    1:         nsRefPtr<gfxFont> mFont;   // never null
    1:         PRUint32          mCharacterOffset; // into original UTF16 string
    1:     };
    1: 
 7715:     class THEBES_API GlyphRunIterator {
    1:     public:
    1:         GlyphRunIterator(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aLength)
    1:           : mTextRun(aTextRun), mStartOffset(aStart), mEndOffset(aStart + aLength) {
    1:             mNextIndex = mTextRun->FindFirstGlyphRunContaining(aStart);
    1:         }
    1:         PRBool NextRun();
    1:         GlyphRun *GetGlyphRun() { return mGlyphRun; }
    1:         PRUint32 GetStringStart() { return mStringStart; }
    1:         PRUint32 GetStringEnd() { return mStringEnd; }
    1:     private:
    1:         gfxTextRun *mTextRun;
    1:         GlyphRun   *mGlyphRun;
    1:         PRUint32    mStringStart;
    1:         PRUint32    mStringEnd;
    1:         PRUint32    mNextIndex;
    1:         PRUint32    mStartOffset;
    1:         PRUint32    mEndOffset;
    1:     };
    1: 
 3609:     class GlyphRunOffsetComparator {
 3609:     public:
 3609:         PRBool Equals(const GlyphRun& a,
 3609:                       const GlyphRun& b) const
 3609:         {
 3609:             return a.mCharacterOffset == b.mCharacterOffset;
 3609:         }
 3609: 
 3609:         PRBool LessThan(const GlyphRun& a,
 3609:                         const GlyphRun& b) const
 3609:         {
 3609:             return a.mCharacterOffset < b.mCharacterOffset;
 3609:         }
 3609:     };
 3609: 
    1:     friend class GlyphRunIterator;
    1:     friend class FontSelector;
    1: 
    1:     // API for setting up the textrun glyphs. Should only be called by
    1:     // things that construct textruns.
    1:     /**
    1:      * We've found a run of text that should use a particular font. Call this
    1:      * only during initialization when font substitution has been computed.
  132:      * Call it before setting up the glyphs for the characters in this run;
  132:      * SetMissingGlyph requires that the correct glyphrun be installed.
 3609:      *
 3609:      * If aForceNewRun, a new glyph run will be added, even if the
 3609:      * previously added run uses the same font.  If glyph runs are
 3609:      * added out of strictly increasing aStartCharIndex order (via
 3609:      * force), then SortGlyphRuns must be called after all glyph runs
 3609:      * are added before any further operations are performed with this
 3609:      * TextRun.
    1:      */
 3609:     nsresult AddGlyphRun(gfxFont *aFont, PRUint32 aStartCharIndex, PRBool aForceNewRun = PR_FALSE);
    6:     void ResetGlyphRuns() { mGlyphRuns.Clear(); }
 3609:     void SortGlyphRuns();
26688:     void SanitizeGlyphRuns();
 3609: 
    1:     // Call the following glyph-setters during initialization or during reshaping
    1:     // only. It is OK to overwrite existing data for a character.
    1:     /**
 7715:      * Set the glyph data for a character. aGlyphs may be null if aGlyph is a
 7715:      * simple glyph or has no associated glyphs. If non-null the data is copied,
 7715:      * the caller retains ownership.
    1:      */
 7715:     void SetSimpleGlyph(PRUint32 aCharIndex, CompressedGlyph aGlyph) {
 7715:         NS_ASSERTION(aGlyph.IsSimpleGlyph(), "Should be a simple glyph here");
    1:         if (mCharacterGlyphs) {
    1:             mCharacterGlyphs[aCharIndex] = aGlyph;
    1:         }
    1:         if (mDetailedGlyphs) {
    1:             mDetailedGlyphs[aCharIndex] = nsnull;
    1:         }
    1:     }
 7715:     void SetGlyphs(PRUint32 aCharIndex, CompressedGlyph aGlyph,
 7715:                    const DetailedGlyph *aGlyphs);
 7715:     void SetMissingGlyph(PRUint32 aCharIndex, PRUint32 aUnicodeChar);
 2317:     void SetSpaceGlyph(gfxFont *aFont, gfxContext *aContext, PRUint32 aCharIndex);
    1:     
 9576:     /**
 9576:      * Prefetch all the glyph extents needed to ensure that Measure calls
25417:      * on this textrun not requesting tight boundingBoxes will succeed. Note
 9576:      * that some glyph extents might not be fetched due to OOM or other
 9576:      * errors.
 9576:      */
 6247:     void FetchGlyphExtents(gfxContext *aRefContext);
 6247: 
    1:     // API for access to the raw glyph data, needed by gfxFont::Draw
    1:     // and gfxFont::GetBoundingBox
    1:     const CompressedGlyph *GetCharacterGlyphs() { return mCharacterGlyphs; }
    1:     const DetailedGlyph *GetDetailedGlyphs(PRUint32 aCharIndex) {
 1127:         return mDetailedGlyphs ? mDetailedGlyphs[aCharIndex].get() : nsnull;
    1:     }
 6247:     PRBool HasDetailedGlyphs() { return mDetailedGlyphs.get() != nsnull; }
    1:     PRUint32 CountMissingGlyphs();
    6:     const GlyphRun *GetGlyphRuns(PRUint32 *aNumGlyphRuns) {
    6:         *aNumGlyphRuns = mGlyphRuns.Length();
    6:         return mGlyphRuns.Elements();
    6:     }
 2317:     // Returns the index of the GlyphRun containing the given offset.
 2317:     // Returns mGlyphRuns.Length() when aOffset is mCharacterCount.
 2317:     PRUint32 FindFirstGlyphRunContaining(PRUint32 aOffset);
 2317:     // Copy glyph data for a range of characters from aSource to this
 2317:     // textrun. If aStealData is true then we actually steal the glyph data,
 2317:     // setting the data in aSource to "missing". aDest should be in the last
 2317:     // glyphrun.
 2317:     virtual void CopyGlyphDataFrom(gfxTextRun *aSource, PRUint32 aStart,
 2317:                                    PRUint32 aLength, PRUint32 aDest,
 2317:                                    PRBool aStealData);
    1: 
 1295:     nsExpirationState *GetExpirationState() { return &mExpirationState; }
 1295: 
 4434:     struct LigatureData {
 4434:         // textrun offsets of the start and end of the containing ligature
 4434:         PRUint32 mLigatureStart;
 4434:         PRUint32 mLigatureEnd;
 4434:         // appunits advance to the start of the ligature part within the ligature;
 4434:         // never includes any spacing
 4434:         gfxFloat mPartAdvance;
 4434:         // appunits width of the ligature part; includes before-spacing
 4434:         // when the part is at the start of the ligature, and after-spacing
 4434:         // when the part is as the end of the ligature
 4434:         gfxFloat mPartWidth;
 4434:         
14568:         PRPackedBool mClipBeforePart;
14568:         PRPackedBool mClipAfterPart;
 4434:     };
 4434:     
19962:     // user font set generation when text run was created
19962:     PRUint64 GetUserFontSetGeneration() { return mUserFontSetGeneration; }
19962: 
 5320: #ifdef DEBUG
 5320:     // number of entries referencing this textrun in the gfxTextRunWordCache
 5320:     PRUint32 mCachedWords;
22917:     // generation of gfxTextRunWordCache that refers to this textrun;
22917:     // if the cache gets cleared, then mCachedWords is no longer meaningful
22917:     PRUint32 mCacheGeneration;
10484:     
10484:     void Dump(FILE* aOutput);
 5320: #endif
 5320: 
13339:     // post-process glyph advances to deal with synthetic bolding
13339:     void AdjustAdvancesForSyntheticBold(PRUint32 aStart, PRUint32 aLength);
13339: 
 8081: protected:
 8081:     /**
 8081:      * Initializes the textrun to blank.
38204:      * @param aGlyphStorage preallocated array of CompressedGlyph[aLength]
38204:      * for the textrun to use; if aText is not persistent, then it has also
38204:      * been appended to this array, so it must NOT be freed separately.
 8081:      */
 8081:     gfxTextRun(const gfxTextRunFactory::Parameters *aParams, const void *aText,
 8081:                PRUint32 aLength, gfxFontGroup *aFontGroup, PRUint32 aFlags,
38204:                CompressedGlyph *aGlyphStorage);
38204: 
38204:     /**
38204:      * Helper for the Create() factory method to allocate the required
38204:      * glyph storage, and copy the text (modifying the aText parameter)
38204:      * if it is not flagged as persistent.
38204:      */
38204:     static CompressedGlyph* AllocateStorage(const void*& aText,
38204:                                             PRUint32 aLength,
38204:                                             PRUint32 aFlags);
 8081: 
    1: private:
    1:     // **** general helpers **** 
    1: 
  132:     // Allocate aCount DetailedGlyphs for the given index
  132:     DetailedGlyph *AllocateDetailedGlyphs(PRUint32 aCharIndex, PRUint32 aCount);
    1: 
 4434:     // Spacing for characters outside the range aSpacingStart/aSpacingEnd
 4434:     // is assumed to be zero; such characters are not passed to aProvider.
 4434:     // This is useful to protect aProvider from being passed character indices
 4434:     // it is not currently able to handle.
 4434:     PRBool GetAdjustedSpacingArray(PRUint32 aStart, PRUint32 aEnd,
 4434:                                    PropertyProvider *aProvider,
 4434:                                    PRUint32 aSpacingStart, PRUint32 aSpacingEnd,
 4434:                                    nsTArray<PropertyProvider::Spacing> *aSpacing);
 4434: 
    1:     //  **** ligature helpers ****
    1:     // (Platforms do the actual ligaturization, but we need to do a bunch of stuff
    1:     // to handle requests that begin or end inside a ligature)
    1: 
    1:     // if aProvider is null then mBeforeSpacing and mAfterSpacing are set to zero
 4434:     LigatureData ComputeLigatureData(PRUint32 aPartStart, PRUint32 aPartEnd,
    1:                                      PropertyProvider *aProvider);
 4434:     gfxFloat ComputePartialLigatureWidth(PRUint32 aPartStart, PRUint32 aPartEnd,
 4434:                                          PropertyProvider *aProvider);
 4434:     void DrawPartialLigature(gfxFont *aFont, gfxContext *aCtx, PRUint32 aStart,
 4434:                              PRUint32 aEnd, const gfxRect *aDirtyRect, gfxPoint *aPt,
 4434:                              PropertyProvider *aProvider);
 4434:     // Advance aStart to the start of the nearest ligature; back up aEnd
 4434:     // to the nearest ligature end; may result in *aStart == *aEnd
    1:     void ShrinkToLigatureBoundaries(PRUint32 *aStart, PRUint32 *aEnd);
    1:     // result in appunits
    1:     gfxFloat GetPartialLigatureWidth(PRUint32 aStart, PRUint32 aEnd, PropertyProvider *aProvider);
    1:     void AccumulatePartialLigatureMetrics(gfxFont *aFont,
25417:                                           PRUint32 aStart, PRUint32 aEnd,
25417:                                           gfxFont::BoundingBoxType aBoundingBoxType,
 6247:                                           gfxContext *aRefContext,
    1:                                           PropertyProvider *aProvider,
    1:                                           Metrics *aMetrics);
    1: 
    1:     // **** measurement helper ****
25417:     void AccumulateMetricsForRun(gfxFont *aFont, PRUint32 aStart, PRUint32 aEnd,
25417:                                  gfxFont::BoundingBoxType aBoundingBoxType,
 6247:                                  gfxContext *aRefContext,
    1:                                  PropertyProvider *aProvider,
 4434:                                  PRUint32 aSpacingStart, PRUint32 aSpacingEnd,
    1:                                  Metrics *aMetrics);
    1: 
    1:     // **** drawing helper ****
    1:     void DrawGlyphs(gfxFont *aFont, gfxContext *aContext, PRBool aDrawToPath,
    1:                     gfxPoint *aPt, PRUint32 aStart, PRUint32 aEnd,
 4434:                     PropertyProvider *aProvider,
 4434:                     PRUint32 aSpacingStart, PRUint32 aSpacingEnd);
    1: 
 8081:     // All our glyph data is in logical order, not visual.
38204:     // mCharacterGlyphs is allocated by the factory that creates the textrun,
38204:     // to avoid the possibility of failure during the constructor;
38204:     // however, ownership passes to the textrun during construction and so
38204:     // it must be deleted in the destructor.
 8081:     CompressedGlyph*                               mCharacterGlyphs;
    1:     nsAutoArrayPtr<nsAutoArrayPtr<DetailedGlyph> > mDetailedGlyphs; // only non-null if needed
    1:     // XXX this should be changed to a GlyphRun plus a maybe-null GlyphRun*,
    1:     // for smaller size especially in the super-common one-glyphrun case
    1:     nsAutoTArray<GlyphRun,1>                       mGlyphRuns;
 1295:     // When TEXT_IS_8BIT is set, we use mSingle, otherwise we use mDouble.
 1295:     // When TEXT_IS_PERSISTENT is set, we don't own the text, otherwise we
38204:     // own the text. When we own the text, it's allocated fused with the
38204:     // mCharacterGlyphs array, and therefore need not be explicitly deleted.
 1295:     // This text is not null-terminated.
 1295:     union {
 1295:         const PRUint8   *mSingle;
 1295:         const PRUnichar *mDouble;
 1295:     } mText;
    1:     void             *mUserData;
 1295:     gfxFontGroup     *mFontGroup; // addrefed
    1:     gfxSkipChars      mSkipChars;
 1295:     nsExpirationState mExpirationState;
    1:     PRUint32          mAppUnitsPerDevUnit;
    1:     PRUint32          mFlags;
    1:     PRUint32          mCharacterCount;
 1384:     PRUint32          mHashCode;
19962:     PRUint64          mUserFontSetGeneration; // user font set generation when text run created
    1: };
    1: 
    1: class THEBES_API gfxFontGroup : public gfxTextRunFactory {
37211: public:
19962:     gfxFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle, gfxUserFontSet *aUserFontSet = nsnull);
    1: 
19962:     virtual ~gfxFontGroup();
    1: 
 2252:     virtual gfxFont *GetFontAt(PRInt32 i) {
21927:         // If it turns out to be hard for all clients that cache font
21927:         // groups to call UpdateFontList at appropriate times, we could
21927:         // instead consider just calling UpdateFontList from someplace
21927:         // more central (such as here).
21927:         NS_ASSERTION(!mUserFontSet || mCurrGeneration == GetGeneration(),
21927:                      "Whoever was caching this font group should have "
21927:                      "called UpdateFontList on it");
24104:         NS_ASSERTION(mFonts.Length() > PRUint32(i), 
24104:                      "Requesting a font index that doesn't exist");
21927: 
 3233:         return static_cast<gfxFont*>(mFonts[i]);
    1:     }
 2252:     virtual PRUint32 FontListLength() const {
    1:         return mFonts.Length();
    1:     }
    1: 
    1:     PRBool Equals(const gfxFontGroup& other) const {
    1:         return mFamilies.Equals(other.mFamilies) &&
    1:             mStyle.Equals(other.mStyle);
    1:     }
    1: 
    1:     const gfxFontStyle *GetStyle() const { return &mStyle; }
    1: 
37211:     virtual gfxFontGroup *Copy(const gfxFontStyle *aStyle);
    1: 
 1295:     /**
 3143:      * The listed characters should not be passed in to MakeTextRun and should
 3143:      * be treated as invisible and zero-width.
 1746:      */
19962:     static PRBool IsInvalidChar(PRUnichar ch);
 1746:     
 1746:     /**
 1295:      * Make a textrun for an empty string. This is fast; if you call it,
 1295:      * don't bother caching the result.
 1295:      */
 1295:     gfxTextRun *MakeEmptyTextRun(const Parameters *aParams, PRUint32 aFlags);
 1295:     /**
 1295:      * Make a textrun for a single ASCII space. This is fast; if you call it,
 1295:      * don't bother caching the result.
 1295:      */
 1295:     gfxTextRun *MakeSpaceTextRun(const Parameters *aParams, PRUint32 aFlags);
 1295: 
 1295:     /**
 1435:      * Make a textrun for a given string.
 1435:      * If aText is not persistent (aFlags & TEXT_IS_PERSISTENT), the
 1435:      * textrun will copy it.
 9576:      * This calls FetchGlyphExtents on the textrun.
 1295:      */
    1:     virtual gfxTextRun *MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
37211:                                     const Parameters *aParams, PRUint32 aFlags);
 1295:     /**
 1435:      * Make a textrun for a given string.
 1435:      * If aText is not persistent (aFlags & TEXT_IS_PERSISTENT), the
 1435:      * textrun will copy it.
 9576:      * This calls FetchGlyphExtents on the textrun.
 1295:      */
    1:     virtual gfxTextRun *MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
37211:                                     const Parameters *aParams, PRUint32 aFlags);
    1: 
    1:     /* helper function for splitting font families on commas and
    1:      * calling a function for each family to fill the mFonts array
    1:      */
    1:     typedef PRBool (*FontCreationCallback) (const nsAString& aName,
    1:                                             const nsACString& aGenericName,
    1:                                             void *closure);
19962:     /*static*/ PRBool ForEachFont(const nsAString& aFamilies,
    1:                               const nsACString& aLangGroup,
    1:                               FontCreationCallback fc,
    1:                               void *closure);
    1:     PRBool ForEachFont(FontCreationCallback fc, void *closure);
    1: 
37211:     /**
37211:      * Check whether a given font (specified by its gfxFontEntry)
37211:      * is already in the fontgroup's list of actual fonts
37211:      */
37211:     PRBool HasFont(const gfxFontEntry *aFontEntry);
37211: 
    1:     const nsString& GetFamilies() { return mFamilies; }
    1: 
12989:     // This returns the preferred underline for this font group.
12989:     // Some CJK fonts have wrong underline offset in its metrics.
12989:     // If this group has such "bad" font, each platform's gfxFontGroup initialized mUnderlineOffset.
12989:     // The value should be lower value of first font's metrics and the bad font's metrics.
12989:     // Otherwise, this returns from first font's metrics.
14253:     enum { UNDERLINE_OFFSET_NOT_SET = PR_INT16_MAX };
22991:     virtual gfxFloat GetUnderlineOffset() {
14253:         if (mUnderlineOffset == UNDERLINE_OFFSET_NOT_SET)
12989:             mUnderlineOffset = GetFontAt(0)->GetMetrics().underlineOffset;
12989:         return mUnderlineOffset;
12989:     }
12989: 
16418:     already_AddRefed<gfxFont> FindFontForChar(PRUint32 ch, PRUint32 prevCh, PRUint32 nextCh, gfxFont *aPrevMatchedFont);
16418: 
37211:     // search through pref fonts for a character, return nsnull if no matching pref font
37211:     virtual already_AddRefed<gfxFont> WhichPrefFontSupportsChar(PRUint32 aCh);
16418: 
37211:     virtual already_AddRefed<gfxFont> WhichSystemFontSupportsChar(PRUint32 aCh);
16418: 
16418:     void ComputeRanges(nsTArray<gfxTextRange>& mRanges, const PRUnichar *aString, PRUint32 begin, PRUint32 end);
16418: 
19962:     gfxUserFontSet* GetUserFontSet();
19962: 
19962:     // With downloadable fonts, the composition of the font group can change as fonts are downloaded
19962:     // for each change in state of the user font set, the generation value is bumped to avoid picking up
19962:     // previously created text runs in the text run word cache.  For font groups based on stylesheets
19962:     // with no @font-face rule, this always returns 0.
19962:     PRUint64 GetGeneration();
19962: 
22397:     // If there is a user font set, check to see whether the font list or any
22397:     // caches need updating.
37211:     virtual void UpdateFontList();
16418: 
    1: protected:
    1:     nsString mFamilies;
    1:     gfxFontStyle mStyle;
    1:     nsTArray< nsRefPtr<gfxFont> > mFonts;
12989:     gfxFloat mUnderlineOffset;
12989: 
19962:     gfxUserFontSet* mUserFontSet;
19962:     PRUint64 mCurrGeneration;  // track the current user font set generation, rebuild font list if needed
19962: 
37211:     // cache the most recent pref font to avoid general pref font lookup
37211:     nsRefPtr<gfxFontFamily> mLastPrefFamily;
37211:     nsRefPtr<gfxFont>       mLastPrefFont;
37211:     eFontPrefLang           mLastPrefLang;       // lang group for last pref font
37211:     PRBool                  mLastPrefFirstFont;  // is this the first font in the list of pref fonts for this lang group?
37211:     eFontPrefLang           mPageLang;
37211: 
22397:     // Used for construction/destruction.  Not intended to change the font set
22397:     // as invalidation of font lists and caches is not considered.
22397:     void SetUserFontSet(gfxUserFontSet *aUserFontSet);
22397: 
38461:     // Initialize the list of fonts
38461:     void BuildFontList();
38461: 
12989:     // Init this font group's font metrics. If there no bad fonts, you don't need to call this.
12989:     // But if there are one or more bad fonts which have bad underline offset,
12989:     // you should call this with the *first* bad font.
12989:     void InitMetricsForBadFont(gfxFont* aBadFont);
    1: 
37211:     void InitTextRun(gfxTextRun *aTextRun,
37211:                      const PRUnichar *aString,
37211:                      PRUint32 aLength);
37211: 
10774:     /* If aResolveGeneric is true, then CSS/Gecko generic family names are
10774:      * replaced with preferred fonts.
10774:      *
10774:      * If aResolveFontName is true then fc() is called only for existing fonts
10774:      * and with actual font names.  If false then fc() is called with each
10774:      * family name in aFamilies (after resolving CSS/Gecko generic family names
10774:      * if aResolveGeneric).
10774:      */
19962:     /*static*/ PRBool ForEachFontInternal(const nsAString& aFamilies,
    1:                                       const nsACString& aLangGroup,
    1:                                       PRBool aResolveGeneric,
10774:                                       PRBool aResolveFontName,
    1:                                       FontCreationCallback fc,
    1:                                       void *closure);
    1: 
    1:     static PRBool FontResolverProc(const nsAString& aName, void *aClosure);
16418: 
37211:     static PRBool FindPlatformFont(const nsAString& aName,
37211:                                    const nsACString& aGenericName,
37211:                                    void *closure);
37211: 
16418:     inline gfxFont* WhichFontSupportsChar(nsTArray< nsRefPtr<gfxFont> >& aFontList, PRUint32 aCh) {
16418:         PRUint32 len = aFontList.Length();
16418:         for (PRUint32 i = 0; i < len; i++) {
37211:             gfxFont* font = aFontList.ElementAt(i);
16418:             if (font && font->HasCharacter(aCh))
16418:                 return font;
16418:         }
16418:         return nsnull;
16418:     }
16418: 
    1: };
    1: #endif
