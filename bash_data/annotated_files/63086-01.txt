    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mark Hammond <mhammond@skippinet.com.au>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
38922: #include "jscntxt.h"
    1: #include "nsJSEnvironment.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIDOMChromeWindow.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMHTMLOptionElement.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsJSUtils.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsPresContext.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIObserverService.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsITimer.h"
    1: #include "nsIAtom.h"
    1: #include "nsContentUtils.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsIContent.h"
    1: #include "nsCycleCollector.h"
 3275: #include "nsNetUtil.h"
23546: #include "nsXPCOMCIDInternal.h"
23546: #include "nsIXULRuntime.h"
    1: 
    1: #include "nsDOMClassInfo.h"
62690: #include "xpcpublic.h"
    1: 
    1: #include "jsdbgapi.h"           // for JS_ClearWatchPointsForObject
    1: #include "jsxdrapi.h"
    1: #include "nsIArray.h"
    1: #include "nsIObjectInputStream.h"
    1: #include "nsIObjectOutputStream.h"
    1: #include "nsITimelineService.h"
    1: #include "nsDOMScriptObjectHolder.h"
    1: #include "prmem.h"
55637: #include "WrapperFactory.h"
    1: #include "nsGlobalWindow.h"
    1: 
56355: #ifdef XP_MACOSX
56355: // AssertMacros.h defines 'check' and conflicts with AccessCheck.h
56355: #undef check
56355: #endif
56355: #include "AccessCheck.h"
56355: 
    1: #ifdef MOZ_JSDEBUGGER
    1: #include "jsdIDebuggerService.h"
    1: #endif
    1: #ifdef MOZ_LOGGING
    1: // Force PR_LOGGING so we can get JS strict warnings even in release builds
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: #include "prlog.h"
    1: #include "prthread.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
    1: const size_t gStackSize = 8192;
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gJSDiagnostics;
    1: #endif
    1: 
    1: // Thank you Microsoft!
    1: #ifndef WINCE
    1: #ifdef CompareString
    1: #undef CompareString
    1: #endif
    1: #endif // WINCE
    1: 
    1: // The amount of time we wait between a request to GC (due to leaving
    1: // a page) and doing the actual GC.
62725: #define NS_GC_DELAY                 4000 // ms
    1: 
    1: // The amount of time we wait from the first request to GC to actually
    1: // doing the first GC.
    1: #define NS_FIRST_GC_DELAY           10000 // ms
    1: 
62725: // The amount of time we wait between a request to CC (after GC ran)
62725: // and doing the actual CC.
62725: #define NS_CC_DELAY                 5000 // ms
62725: 
    1: #define JAVASCRIPT nsIProgrammingLanguage::JAVASCRIPT
    1: 
    1: // if you add statics here, add them to the list in nsJSRuntime::Startup
    1: 
    1: static nsITimer *sGCTimer;
62725: static nsITimer *sCCTimer;
    1: 
63086: static bool sGCHasRun;
63086: 
    1: // The number of currently pending document loads. This count isn't
    1: // guaranteed to always reflect reality and can't easily as we don't
    1: // have an easy place to know when a load ends or is interrupted in
    1: // all cases. This counter also gets reset if we end up GC'ing while
    1: // we're waiting for a slow page to load. IOW, this count may be 0
    1: // even when there are pending loads.
    1: static PRUint32 sPendingLoadCount;
62725: static PRBool sLoadingInProgress;
62725: 
62725: static PRBool sPostGCEventsToConsole;
    1: 
    1: nsScriptNameSpaceManager *gNameSpaceManager;
    1: 
    1: static nsIJSRuntimeService *sRuntimeService;
    1: JSRuntime *nsJSRuntime::sRuntime;
    1: 
    1: static const char kJSRuntimeServiceContractID[] =
    1:   "@mozilla.org/js/xpc/RuntimeService;1";
    1: 
    1: static JSGCCallback gOldJSGCCallback;
    1: 
    1: static PRBool sIsInitialized;
    1: static PRBool sDidShutdown;
    1: 
    1: static PRInt32 sContextCount;
    1: 
    1: static PRTime sMaxScriptRunTime;
    1: static PRTime sMaxChromeScriptRunTime;
    1: 
    1: static nsIScriptSecurityManager *sSecurityManager;
    1: 
62725: // nsMemoryPressureObserver observes the memory-pressure notifications
62725: // and forces a garbage collection and cycle collection when it happens.
62725: 
62725: class nsMemoryPressureObserver : public nsIObserver
 7369: {
 7369: public:
 7369:   NS_DECL_ISUPPORTS
 7369:   NS_DECL_NSIOBSERVER
 7369: };
 7369: 
62725: NS_IMPL_ISUPPORTS1(nsMemoryPressureObserver, nsIObserver)
 7369: 
 7369: NS_IMETHODIMP
62725: nsMemoryPressureObserver::Observe(nsISupports* aSubject, const char* aTopic,
 7369:                                   const PRUnichar* aData)
 7369: {
62725:   nsJSContext::GarbageCollectNow();
62725:   nsJSContext::CycleCollectNow();
 7369:   return NS_OK;
 7369: }
 7369: 
    1: /****************************************************************
    1:  ************************** AutoFree ****************************
    1:  ****************************************************************/
    1: 
    1: class AutoFree {
    1: public:
    1:   AutoFree(void *aPtr) : mPtr(aPtr) {
    1:   }
    1:   ~AutoFree() {
    1:     if (mPtr)
    1:       nsMemory::Free(mPtr);
    1:   }
    1:   void Invalidate() {
    1:     mPtr = 0;
    1:   }
    1: private:
    1:   void *mPtr;
    1: };
    1: 
37767: class nsAutoPoolRelease {
    1: public:
37767:   nsAutoPoolRelease(JSArenaPool *p, void *m) : mPool(p), mMark(m) {}
37767:   ~nsAutoPoolRelease() { JS_ARENA_RELEASE(mPool, mMark); }
    1: private:
37767:   JSArenaPool *mPool;
37767:   void *mMark;
    1: };
    1: 
    1: // A utility function for script languages to call.  Although it looks small,
    1: // the use of nsIDocShell and nsPresContext triggers a huge number of
    1: // dependencies that most languages would not otherwise need.
    1: // XXXmarkh - This function is mis-placed!
    1: PRBool
    1: NS_HandleScriptError(nsIScriptGlobalObject *aScriptGlobal,
    1:                      nsScriptErrorEvent *aErrorEvent,
    1:                      nsEventStatus *aStatus)
    1: {
    1:   PRBool called = PR_FALSE;
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobal));
    1:   nsIDocShell *docShell = win ? win->GetDocShell() : nsnull;
    1:   if (docShell) {
39823:     nsRefPtr<nsPresContext> presContext;
    1:     docShell->GetPresContext(getter_AddRefs(presContext));
    1: 
    1:     static PRInt32 errorDepth; // Recursion prevention
    1:     ++errorDepth;
    1: 
    1:     if (presContext && errorDepth < 2) {
    1:       // Dispatch() must be synchronous for the recursion block
    1:       // (errorDepth) to work.
    1:       nsEventDispatcher::Dispatch(win, presContext, aErrorEvent, nsnull,
    1:                                   aStatus);
    1:       called = PR_TRUE;
    1:     }
    1:     --errorDepth;
    1:   }
    1:   return called;
    1: }
    1: 
36462: class ScriptErrorEvent : public nsRunnable
36462: {
36462: public:
36462:   ScriptErrorEvent(nsIScriptGlobalObject* aScriptGlobal,
36462:                    PRUint32 aLineNr, PRUint32 aColumn, PRUint32 aFlags,
36462:                    const nsAString& aErrorMsg,
36462:                    const nsAString& aFileName,
36462:                    const nsAString& aSourceLine,
56273:                    PRBool aDispatchEvent,
56273:                    PRUint64 aWindowID)
36462:   : mScriptGlobal(aScriptGlobal), mLineNr(aLineNr), mColumn(aColumn),
36462:     mFlags(aFlags), mErrorMsg(aErrorMsg), mFileName(aFileName),
56273:     mSourceLine(aSourceLine), mDispatchEvent(aDispatchEvent),
56273:     mWindowID(aWindowID)
56273:   {}
36462: 
36462:   NS_IMETHOD Run()
36462:   {
36462:     nsEventStatus status = nsEventStatus_eIgnore;
36462:     // First, notify the DOM that we have a script error.
36462:     if (mDispatchEvent) {
36462:       nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
36462:       nsIDocShell* docShell = win ? win->GetDocShell() : nsnull;
36462:       if (docShell &&
36462:           !JSREPORT_IS_WARNING(mFlags) &&
36462:           !sHandlingScriptError) {
36462:         sHandlingScriptError = PR_TRUE; // Recursion prevention
36462: 
39823:         nsRefPtr<nsPresContext> presContext;
36462:         docShell->GetPresContext(getter_AddRefs(presContext));
36462: 
36462:         if (presContext) {
36462:           nsScriptErrorEvent errorevent(PR_TRUE, NS_LOAD_ERROR);
36462: 
36462:           errorevent.fileName = mFileName.get();
36462: 
36462:           nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(win));
36462:           NS_ENSURE_STATE(sop);
36462:           nsIPrincipal* p = sop->GetPrincipal();
36462:           NS_ENSURE_STATE(p);
36462: 
36462:           PRBool sameOrigin = mFileName.IsVoid();
36462: 
36462:           if (p && !sameOrigin) {
36462:             nsCOMPtr<nsIURI> errorURI;
36462:             NS_NewURI(getter_AddRefs(errorURI), mFileName);
36462:             if (errorURI) {
36462:               // FIXME: Once error reports contain the origin of the
36462:               // error (principals) we should change this to do the
36462:               // security check based on the principals and not
36462:               // URIs. See bug 387476.
36462:               sameOrigin = NS_SUCCEEDED(p->CheckMayLoad(errorURI, PR_FALSE));
36462:             }
36462:           }
36462: 
36462:           NS_NAMED_LITERAL_STRING(xoriginMsg, "Script error.");
36462:           if (sameOrigin) {
36462:             errorevent.errorMsg = mErrorMsg.get();
36462:             errorevent.lineNr = mLineNr;
36462:           } else {
36462:             NS_WARNING("Not same origin error!");
36462:             errorevent.errorMsg = xoriginMsg.get();
36462:             errorevent.lineNr = 0;
43325:             // FIXME: once the principal of the script is not tied to
43325:             // the filename, we can stop using the post-redirect
43330:             // filename if we want and remove this line.  Note that
43330:             // apparently we can't handle null filenames in the error
43330:             // event dispatching code.
43330:             static PRUnichar nullFilename[] = { PRUnichar(0) };
43330:             errorevent.fileName = nullFilename;
36462:           }
36462: 
36462:           nsEventDispatcher::Dispatch(win, presContext, &errorevent, nsnull,
36462:                                       &status);
36462:         }
36462: 
36462:         sHandlingScriptError = PR_FALSE;
36462:       }
36462:     }
36462: 
36462:     if (status != nsEventStatus_eConsumeNoDefault) {
36462:       // Make an nsIScriptError and populate it with information from
36462:       // this error.
36462:       nsCOMPtr<nsIScriptError> errorObject =
36462:         do_CreateInstance("@mozilla.org/scripterror;1");
36462: 
36462:       if (errorObject != nsnull) {
36462:         nsresult rv = NS_ERROR_NOT_AVAILABLE;
36462: 
36462:         // Set category to chrome or content
36462:         nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal =
36462:           do_QueryInterface(mScriptGlobal);
36462:         NS_ASSERTION(scriptPrincipal, "Global objects must implement "
36462:                      "nsIScriptObjectPrincipal");
36462:         nsCOMPtr<nsIPrincipal> systemPrincipal;
36462:         sSecurityManager->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
36462:         const char * category =
36462:           scriptPrincipal->GetPrincipal() == systemPrincipal
36462:           ? "chrome javascript"
36462:           : "content javascript";
36462: 
56273:         nsCOMPtr<nsIScriptError2> error2(do_QueryInterface(errorObject));
56273:         if (error2) {
56273:           rv = error2->InitWithWindowID(mErrorMsg.get(), mFileName.get(),
56273:                                         mSourceLine.get(),
56273:                                         mLineNr, mColumn, mFlags,
56273:                                         category, mWindowID);
56273:         } else {
36462:           rv = errorObject->Init(mErrorMsg.get(), mFileName.get(),
36462:                                  mSourceLine.get(),
36462:                                  mLineNr, mColumn, mFlags,
36462:                                  category);
56273:         }
36462: 
36462:         if (NS_SUCCEEDED(rv)) {
36462:           nsCOMPtr<nsIConsoleService> consoleService =
36462:             do_GetService(NS_CONSOLESERVICE_CONTRACTID, &rv);
36462:           if (NS_SUCCEEDED(rv)) {
36462:             consoleService->LogMessage(errorObject);
36462:           }
36462:         }
36462:       }
36462:     }
36462:     return NS_OK;
36462:   }
36462: 
36462: 
36462:   nsCOMPtr<nsIScriptGlobalObject> mScriptGlobal;
36462:   PRUint32                        mLineNr;
36462:   PRUint32                        mColumn;
36462:   PRUint32                        mFlags;
36462:   nsString                        mErrorMsg;
36462:   nsString                        mFileName;
36462:   nsString                        mSourceLine;
36462:   PRBool                          mDispatchEvent;
56273:   PRUint64                        mWindowID;
36462: 
36462:   static PRBool sHandlingScriptError;
36462: };
36462: 
36462: PRBool ScriptErrorEvent::sHandlingScriptError = PR_FALSE;
36462: 
    1: // NOTE: This function could be refactored to use the above.  The only reason
    1: // it has not been done is that the code below only fills the error event
    1: // after it has a good nsPresContext - whereas using the above function
    1: // would involve always filling it.  Is that a concern?
18907: void
    1: NS_ScriptErrorReporter(JSContext *cx,
    1:                        const char *message,
    1:                        JSErrorReport *report)
    1: {
25523:   // We don't want to report exceptions too eagerly, but warnings in the
25523:   // absence of werror are swallowed whole, so report those now.
25523:   if (!JSREPORT_IS_WARNING(report->flags)) {
20343:     JSStackFrame * fp = nsnull;
20343:     while ((fp = JS_FrameIterator(cx, &fp))) {
53557:       if (JS_IsScriptFrame(cx, fp)) {
20343:         return;
20343:       }
20343:     }
20343: 
20343:     nsIXPConnect* xpc = nsContentUtils::XPConnect();
20343:     if (xpc) {
20343:       nsAXPCNativeCallContext *cc = nsnull;
20343:       xpc->GetCurrentNativeCallContext(&cc);
20343:       if (cc) {
20343:         nsAXPCNativeCallContext *prev = cc;
20343:         while (NS_SUCCEEDED(prev->GetPreviousCallContext(&prev)) && prev) {
20343:           PRUint16 lang;
20343:           if (NS_SUCCEEDED(prev->GetLanguage(&lang)) &&
20343:             lang == nsAXPCNativeCallContext::LANG_JS) {
20343:             return;
20343:           }
20343:         }
20343:       }
20343:     }
25523:   }
20343: 
    1:   // XXX this means we are not going to get error reports on non DOM contexts
    1:   nsIScriptContext *context = nsJSUtils::GetDynamicScriptContext(cx);
    1: 
    1:   // Note: we must do this before running any more code on cx (if cx is the
    1:   // dynamic script context).
    1:   ::JS_ClearPendingException(cx);
    1: 
    1:   if (context) {
    1:     nsIScriptGlobalObject *globalObject = context->GetGlobalObject();
    1: 
    1:     if (globalObject) {
    1:       nsAutoString fileName, msg;
36462:       if (!report->filename) {
36462:         fileName.SetIsVoid(PR_TRUE);
36462:       } else {
    1:         fileName.AssignWithConversion(report->filename);
36462:       }
    1: 
 3233:       const PRUnichar *m = reinterpret_cast<const PRUnichar*>
 3233:                                              (report->ucmessage);
    1:       if (m) {
    1:         msg.Assign(m);
    1:       }
    1: 
    1:       if (msg.IsEmpty() && message) {
    1:         msg.AssignWithConversion(message);
    1:       }
    1: 
36462: 
    1:       /* We do not try to report Out Of Memory via a dom
    1:        * event because the dom event handler would encounter
    1:        * an OOM exception trying to process the event, and
    1:        * then we'd need to generate a new OOM event for that
    1:        * new OOM instance -- this isn't pretty.
    1:        */
36462:       nsAutoString sourceLine;
36462:       sourceLine.Assign(reinterpret_cast<const PRUnichar*>(report->uclinebuf));
56273:       nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(globalObject);
56273:       PRUint64 windowID = win ? win->WindowID() : 0;
36462:       nsContentUtils::AddScriptRunner(
36462:         new ScriptErrorEvent(globalObject, report->lineno,
36462:                              report->uctokenptr - report->uclinebuf,
36462:                              report->flags, msg, fileName, sourceLine,
56273:                              report->errorNumber != JSMSG_OUT_OF_MEMORY,
56273:                              windowID));
    1:     }
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   // Print it to stderr as well, for the benefit of those invoking
    1:   // mozilla with -console.
    1:   nsCAutoString error;
    1:   error.Assign("JavaScript ");
    1:   if (JSREPORT_IS_STRICT(report->flags))
    1:     error.Append("strict ");
    1:   if (JSREPORT_IS_WARNING(report->flags))
    1:     error.Append("warning: ");
    1:   else
    1:     error.Append("error: ");
    1:   error.Append(report->filename);
    1:   error.Append(", line ");
    1:   error.AppendInt(report->lineno, 10);
    1:   error.Append(": ");
    1:   if (report->ucmessage) {
 3233:     AppendUTF16toUTF8(reinterpret_cast<const PRUnichar*>(report->ucmessage),
    1:                       error);
    1:   } else {
    1:     error.Append(message);
    1:   }
36462: 
    1:   fprintf(stderr, "%s\n", error.get());
    1:   fflush(stderr);
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   if (!gJSDiagnostics)
    1:     gJSDiagnostics = PR_NewLogModule("JSDiagnostics");
    1: 
    1:   if (gJSDiagnostics) {
    1:     PR_LOG(gJSDiagnostics,
    1:            JSREPORT_IS_WARNING(report->flags) ? PR_LOG_WARNING : PR_LOG_ERROR,
    1:            ("file %s, line %u: %s\n%s%s",
    1:             report->filename, report->lineno, message,
    1:             report->linebuf ? report->linebuf : "",
    1:             (report->linebuf &&
    1:              report->linebuf[strlen(report->linebuf)-1] != '\n')
    1:             ? "\n"
    1:             : ""));
    1:   }
    1: #endif
    1: }
    1: 
    1: #ifdef DEBUG
    1: // A couple of useful functions to call when you're debugging.
    1: nsGlobalWindow *
    1: JSObject2Win(JSContext *cx, JSObject *obj)
    1: {
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   if (!xpc) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:   xpc->GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrapper));
    1:   if (wrapper) {
    1:     nsCOMPtr<nsPIDOMWindow> win = do_QueryWrappedNative(wrapper);
    1:     if (win) {
 3233:       return static_cast<nsGlobalWindow *>
 3233:                         (static_cast<nsPIDOMWindow *>(win));
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: PrintWinURI(nsGlobalWindow *win)
    1: {
    1:   if (!win) {
    1:     printf("No window passed in.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(win->GetExtantDocument());
    1:   if (!doc) {
    1:     printf("No document in the window.\n");
    1:     return;
    1:   }
    1: 
    1:   nsIURI *uri = doc->GetDocumentURI();
    1:   if (!uri) {
    1:     printf("Document doesn't have a URI.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString spec;
    1:   uri->GetSpec(spec);
    1:   printf("%s\n", spec.get());
    1: }
    1: 
    1: void
    1: PrintWinCodebase(nsGlobalWindow *win)
    1: {
    1:   if (!win) {
    1:     printf("No window passed in.\n");
    1:     return;
    1:   }
    1: 
    1:   nsIPrincipal *prin = win->GetPrincipal();
    1:   if (!prin) {
    1:     printf("Window doesn't have principals.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   prin->GetURI(getter_AddRefs(uri));
    1:   if (!uri) {
    1:     printf("No URI, maybe the system principal.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString spec;
    1:   uri->GetSpec(spec);
    1:   printf("%s\n", spec.get());
    1: }
40558: 
40558: void
40558: DumpString(const nsAString &str)
40558: {
40558:   printf("%s\n", NS_ConvertUTF16toUTF8(str).get());
40558: }
    1: #endif
    1: 
18509: static already_AddRefed<nsIPrompt>
18509: GetPromptFromContext(nsJSContext* ctx)
18509: {
18509:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(ctx->GetGlobalObject()));
18509:   NS_ENSURE_TRUE(win, nsnull);
18509: 
18509:   nsIDocShell *docShell = win->GetDocShell();
18509:   NS_ENSURE_TRUE(docShell, nsnull);
18509: 
18509:   nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(docShell));
18509:   NS_ENSURE_TRUE(ireq, nsnull);
18509: 
18509:   // Get the nsIPrompt interface from the docshell
18509:   nsIPrompt* prompt;
18509:   ireq->GetInterface(NS_GET_IID(nsIPrompt), (void**)&prompt);
18509:   return prompt;
18509: }
18509: 
18907: JSBool
10142: nsJSContext::DOMOperationCallback(JSContext *cx)
    1: {
18509:   nsresult rv;
18509: 
    1:   // Get the native context
 3233:   nsJSContext *ctx = static_cast<nsJSContext *>(::JS_GetContextPrivate(cx));
    1: 
    1:   if (!ctx) {
    1:     // Can happen; see bug 355811
    1:     return JS_TRUE;
    1:   }
    1: 
21973:   // XXX Save the operation callback time so we can restore it after the GC,
21973:   // because GCing can cause JS to run on our context, causing our
21973:   // ScriptEvaluated to be called, and clearing our operation callback time.
21973:   // See bug 302333.
10413:   PRTime callbackTime = ctx->mOperationCallbackTime;
29105:   PRTime modalStateTime = ctx->mModalStateTime;
10413: 
21973:   // Now restore the callback time and count, in case they got reset.
21973:   ctx->mOperationCallbackTime = callbackTime;
29105:   ctx->mModalStateTime = modalStateTime;
21973: 
10413:   PRTime now = PR_Now();
10413: 
29105:   if (callbackTime == 0) {
10142:     // Initialize mOperationCallbackTime to start timing how long the
 9784:     // script has run
10413:     ctx->mOperationCallbackTime = now;
 9682:     return JS_TRUE;
 9682:   }
 9682: 
29105:   if (ctx->mModalStateDepth) {
29105:     // We're waiting on a modal dialog, nothing more to do here.
29105:     return JS_TRUE;
29105:   }
29105: 
29105:   PRTime duration = now - callbackTime;
    1: 
    1:   // Check the amount of time this script has been running, or if the
    1:   // dialog is disabled.
62953:   JSObject* global = ::JS_GetGlobalForScopeChain(cx);
10413:   PRBool isTrackingChromeCodeTime =
62953:     global && xpc::AccessCheck::isChrome(global->getCompartment());
10413:   if (duration < (isTrackingChromeCodeTime ?
    1:                   sMaxChromeScriptRunTime : sMaxScriptRunTime)) {
    1:     return JS_TRUE;
    1:   }
    1: 
41485:   if (!nsContentUtils::IsSafeToRunScript()) {
41485:     // If it isn't safe to run script, then it isn't safe to bring up the
41485:     // prompt (since that will cause the event loop to spin). In this case
41485:     // (which is rare), we just stop the script... But report a warning so
41485:     // that developers have some idea of what went wrong.
41485: 
41485:     JS_ReportWarning(cx, "A long running script was terminated");
41485:     return JS_FALSE;
41485:   }
41485: 
    1:   // If we get here we're most likely executing an infinite loop in JS,
    1:   // we'll tell the user about this and we'll give the user the option
    1:   // of stopping the execution of the script.
18509:   nsCOMPtr<nsIPrompt> prompt = GetPromptFromContext(ctx);
    1:   NS_ENSURE_TRUE(prompt, JS_TRUE);
    1: 
    1:   // Check if we should offer the option to debug
10142:   JSStackFrame* fp = ::JS_GetScriptedCaller(cx, NULL);
25087:   PRBool debugPossible = (fp != nsnull && cx->debugHooks &&
10142:                           cx->debugHooks->debuggerHandler != nsnull);
    1: #ifdef MOZ_JSDEBUGGER
    1:   // Get the debugger service if necessary.
    1:   if (debugPossible) {
    1:     PRBool jsds_IsOn = PR_FALSE;
    1:     const char jsdServiceCtrID[] = "@mozilla.org/js/jsd/debugger-service;1";
    1:     nsCOMPtr<jsdIExecutionHook> jsdHook;
    1:     nsCOMPtr<jsdIDebuggerService> jsds = do_GetService(jsdServiceCtrID, &rv);
    1: 
    1:     // Check if there's a user for the debugger service that's 'on' for us
    1:     if (NS_SUCCEEDED(rv)) {
    1:       jsds->GetDebuggerHook(getter_AddRefs(jsdHook));
    1:       jsds->GetIsOn(&jsds_IsOn);
    1:     }
    1: 
    1:     // If there is a debug handler registered for this runtime AND
    1:     // ((jsd is on AND has a hook) OR (jsd isn't on (something else debugs)))
    1:     // then something useful will be done with our request to debug.
    1:     debugPossible = ((jsds_IsOn && (jsdHook != nsnull)) || !jsds_IsOn);
    1:   }
    1: #endif
    1: 
    1:   // Get localizable strings
    1:   nsXPIDLString title, msg, stopButton, waitButton, debugButton, neverShowDlg;
    1: 
18509:   rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                           "KillScriptTitle",
18509:                                           title);
18509: 
18509:   rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                            "StopScriptButton",
18509:                                            stopButton);
18509: 
18509:   rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                            "WaitForScriptButton",
18509:                                            waitButton);
18509: 
18509:   rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                            "DontAskAgain",
18509:                                            neverShowDlg);
    1: 
    1: 
    1:   if (debugPossible) {
18509:     rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "DebugScriptButton",
18509:                                              debugButton);
18509: 
18509:     rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "KillScriptWithDebugMessage",
18509:                                              msg);
    1:   }
    1:   else {
18509:     rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "KillScriptMessage",
18509:                                              msg);
    1:   }
    1: 
    1:   //GetStringFromName can return NS_OK and still give NULL string
    1:   if (NS_FAILED(rv) || !title || !msg || !stopButton || !waitButton ||
    1:       (!debugButton && debugPossible) || !neverShowDlg) {
    1:     NS_ERROR("Failed to get localized strings.");
    1:     return JS_TRUE;
    1:   }
    1: 
 8577:   // Append file and line number information, if available
10142:   JSScript *script = fp ? ::JS_GetFrameScript(cx, fp) : nsnull;
 8577:   if (script) {
 8577:     const char *filename = ::JS_GetScriptFilename(cx, script);
 8577:     if (filename) {
 8577:       nsXPIDLString scriptLocation;
 8577:       NS_ConvertUTF8toUTF16 filenameUTF16(filename);
 8577:       const PRUnichar *formatParams[] = { filenameUTF16.get() };
18509:       rv = nsContentUtils::FormatLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                                  "KillScriptLocation",
 8577:                                                  formatParams, 1,
18509:                                                  scriptLocation);
 8577: 
 8577:       if (NS_SUCCEEDED(rv) && scriptLocation) {
 8577:         msg.AppendLiteral("\n\n");
 8577:         msg.Append(scriptLocation);
 8577: 
 8577:         JSStackFrame *fp, *iterator = nsnull;
 8577:         fp = ::JS_FrameIterator(cx, &iterator);
 8577:         if (fp) {
 8577:           jsbytecode *pc = ::JS_GetFramePC(cx, fp);
 8577:           if (pc) {
 8577:             PRUint32 lineno = ::JS_PCToLineNumber(cx, script, pc);
 8577:             msg.Append(':');
 8577:             msg.AppendInt(lineno);
 8577:           }
 8577:         }
 8577:       }
 8577:     }
 8577:   }
 8577: 
34168:   PRInt32 buttonPressed = 0; //In case user exits dialog by clicking X
    1:   PRBool neverShowDlgChk = PR_FALSE;
34168:   PRUint32 buttonFlags = nsIPrompt::BUTTON_POS_1_DEFAULT +
34168:                          (nsIPrompt::BUTTON_TITLE_IS_STRING *
    1:                           (nsIPrompt::BUTTON_POS_0 + nsIPrompt::BUTTON_POS_1));
    1: 
    1:   // Add a third button if necessary:
    1:   if (debugPossible)
    1:     buttonFlags += nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_2;
    1: 
25087:   // Null out the operation callback while we're re-entering JS here.
25087:   ::JS_SetOperationCallback(cx, nsnull);
25087: 
    1:   // Open the dialog.
34168:   rv = prompt->ConfirmEx(title, msg, buttonFlags, waitButton, stopButton,
    1:                          debugButton, neverShowDlg, &neverShowDlgChk,
    1:                          &buttonPressed);
    1: 
25087:   ::JS_SetOperationCallback(cx, DOMOperationCallback);
25087: 
34168:   if (NS_FAILED(rv) || (buttonPressed == 0)) {
    1:     // Allow the script to continue running
    1: 
    1:     if (neverShowDlgChk) {
    1:       nsIPrefBranch *prefBranch = nsContentUtils::GetPrefBranch();
    1: 
    1:       if (prefBranch) {
10413:         prefBranch->SetIntPref(isTrackingChromeCodeTime ?
    1:                                "dom.max_chrome_script_run_time" :
    1:                                "dom.max_script_run_time", 0);
    1:       }
    1:     }
    1: 
10142:     ctx->mOperationCallbackTime = PR_Now();
    1:     return JS_TRUE;
    1:   }
    1:   else if ((buttonPressed == 2) && debugPossible) {
    1:     // Debug the script
    1:     jsval rval;
10142:     switch(cx->debugHooks->debuggerHandler(cx, script, ::JS_GetFramePC(cx, fp),
10142:                                            &rval,
 2433:                                            cx->debugHooks->
 2433:                                            debuggerHandlerData)) {
    1:       case JSTRAP_RETURN:
57727:         JS_SetFrameReturnValue(cx, fp, rval);
    1:         return JS_TRUE;
    1:       case JSTRAP_ERROR:
60211:         JS_ClearPendingException(cx);
    1:         return JS_FALSE;
    1:       case JSTRAP_THROW:
    1:         JS_SetPendingException(cx, rval);
    1:         return JS_FALSE;
    1:       case JSTRAP_CONTINUE:
    1:       default:
    1:         return JS_TRUE;
    1:     }
    1:   }
    1: 
25709:   JS_ClearPendingException(cx);
    1:   return JS_FALSE;
    1: }
    1: 
29105: void
29105: nsJSContext::EnterModalState()
29105: {
29105:   if (!mModalStateDepth) {
29105:     mModalStateTime =  mOperationCallbackTime ? PR_Now() : 0;
29105:   }
29105:   ++mModalStateDepth;
29105: }
29105: 
29105: void
29105: nsJSContext::LeaveModalState()
29105: {
29105:   if (!mModalStateDepth) {
29105:     NS_ERROR("Uh, mismatched LeaveModalState() call!");
29105: 
29105:     return;
29105:   }
29105: 
29105:   --mModalStateDepth;
29105: 
29105:   // If we're still in a modal dialog, or mOperationCallbackTime is still
29105:   // uninitialized, do nothing.
29105:   if (mModalStateDepth || !mOperationCallbackTime) {
29105:     return;
29105:   }
29105: 
29105:   // If mOperationCallbackTime was set when we entered the first dialog
29105:   // (and mModalStateTime is thus non-zero), adjust mOperationCallbackTime
29105:   // to account for time spent in the dialog.
29105:   // If mOperationCallbackTime got set while the modal dialog was open,
29105:   // simply set mOperationCallbackTime to the closing time of the dialog so
29105:   // that we never adjust mOperationCallbackTime to be in the future. 
29105:   if (mModalStateTime) {
29105:     mOperationCallbackTime += PR_Now() - mModalStateTime;
29105:   }
29105:   else {
29105:     mOperationCallbackTime = PR_Now();
29105:   }
29105: }
29105: 
    1: #define JS_OPTIONS_DOT_STR "javascript.options."
    1: 
    1: static const char js_options_dot_str[]   = JS_OPTIONS_DOT_STR;
    1: static const char js_strict_option_str[] = JS_OPTIONS_DOT_STR "strict";
36580: #ifdef DEBUG
36580: static const char js_strict_debug_option_str[] = JS_OPTIONS_DOT_STR "strict.debug";
36580: #endif
    1: static const char js_werror_option_str[] = JS_OPTIONS_DOT_STR "werror";
   49: static const char js_relimit_option_str[]= JS_OPTIONS_DOT_STR "relimit";
 7806: #ifdef JS_GC_ZEAL
 7806: static const char js_zeal_option_str[]   = JS_OPTIONS_DOT_STR "gczeal";
 7806: #endif
53019: static const char js_tracejit_content_str[]   = JS_OPTIONS_DOT_STR "tracejit.content";
53019: static const char js_tracejit_chrome_str[]    = JS_OPTIONS_DOT_STR "tracejit.chrome";
53019: static const char js_methodjit_content_str[]  = JS_OPTIONS_DOT_STR "methodjit.content";
53019: static const char js_methodjit_chrome_str[]   = JS_OPTIONS_DOT_STR "methodjit.chrome";
56551: static const char js_profiling_content_str[]  = JS_OPTIONS_DOT_STR "jitprofiling.content";
56551: static const char js_profiling_chrome_str[]   = JS_OPTIONS_DOT_STR "jitprofiling.chrome";
62574: static const char js_methodjit_always_str[]   = JS_OPTIONS_DOT_STR "methodjit_always";
62725: static const char js_memlog_option_str[] = JS_OPTIONS_DOT_STR "mem.log";
    1: 
20261: int
    1: nsJSContext::JSOptionChangedCallback(const char *pref, void *data)
    1: {
 3233:   nsJSContext *context = reinterpret_cast<nsJSContext *>(data);
    1:   PRUint32 oldDefaultJSOptions = context->mDefaultJSOptions;
    1:   PRUint32 newDefaultJSOptions = oldDefaultJSOptions;
    1: 
62725:   sPostGCEventsToConsole = nsContentUtils::GetBoolPref(js_memlog_option_str);
62725: 
    1:   PRBool strict = nsContentUtils::GetBoolPref(js_strict_option_str);
    1:   if (strict)
    1:     newDefaultJSOptions |= JSOPTION_STRICT;
    1:   else
    1:     newDefaultJSOptions &= ~JSOPTION_STRICT;
    1: 
17605:   nsIScriptGlobalObject *global = context->GetGlobalObject();
18253:   // XXX should we check for sysprin instead of a chrome window, to make
18253:   // XXX components be covered by the chrome pref instead of the content one?
17605:   nsCOMPtr<nsIDOMChromeWindow> chromeWindow(do_QueryInterface(global));
23546: 
53019:   PRBool useTraceJIT = nsContentUtils::GetBoolPref(chromeWindow ?
53019:                                                    js_tracejit_chrome_str :
53019:                                                    js_tracejit_content_str);
53019:   PRBool useMethodJIT = nsContentUtils::GetBoolPref(chromeWindow ?
53019:                                                     js_methodjit_chrome_str :
53019:                                                     js_methodjit_content_str);
56551:   PRBool useProfiling = nsContentUtils::GetBoolPref(chromeWindow ?
56551:                                                     js_profiling_chrome_str :
56551:                                                     js_profiling_content_str);
62574:   PRBool useMethodJITAlways = nsContentUtils::GetBoolPref(js_methodjit_always_str);
23546:   nsCOMPtr<nsIXULRuntime> xr = do_GetService(XULRUNTIME_SERVICE_CONTRACTID);
23546:   if (xr) {
23546:     PRBool safeMode = PR_FALSE;
23546:     xr->GetInSafeMode(&safeMode);
53019:     if (safeMode) {
53019:       useTraceJIT = PR_FALSE;
53019:       useMethodJIT = PR_FALSE;
56551:       useProfiling = PR_FALSE;
62574:       useMethodJITAlways = PR_TRUE;
53019:     }
53019:   }    
53019: 
53019:   if (useTraceJIT)
17605:     newDefaultJSOptions |= JSOPTION_JIT;
17605:   else
17605:     newDefaultJSOptions &= ~JSOPTION_JIT;
17605: 
53019:   if (useMethodJIT)
53019:     newDefaultJSOptions |= JSOPTION_METHODJIT;
53019:   else
53019:     newDefaultJSOptions &= ~JSOPTION_METHODJIT;
53019: 
56551:   if (useProfiling)
56551:     newDefaultJSOptions |= JSOPTION_PROFILING;
56551:   else
56551:     newDefaultJSOptions &= ~JSOPTION_PROFILING;
56551: 
62574:   if (useMethodJITAlways)
62574:     newDefaultJSOptions |= JSOPTION_METHODJIT_ALWAYS;
62574:   else
62574:     newDefaultJSOptions &= ~JSOPTION_METHODJIT_ALWAYS;
62574: 
 3289: #ifdef DEBUG
61450:   // In debug builds, warnings are enabled in chrome context if
61450:   // javascript.options.strict.debug is true
36580:   PRBool strictDebug = nsContentUtils::GetBoolPref(js_strict_debug_option_str);
 3289:   // Note this callback is also called from context's InitClasses thus we don't
 3289:   // need to enable this directly from InitContext
36580:   if (strictDebug && (newDefaultJSOptions & JSOPTION_STRICT) == 0) {
 3289:     if (chromeWindow)
 3289:       newDefaultJSOptions |= JSOPTION_STRICT;
 3289:   }
 3289: #endif
 3289: 
    1:   PRBool werror = nsContentUtils::GetBoolPref(js_werror_option_str);
    1:   if (werror)
    1:     newDefaultJSOptions |= JSOPTION_WERROR;
    1:   else
    1:     newDefaultJSOptions &= ~JSOPTION_WERROR;
    1: 
   49:   PRBool relimit = nsContentUtils::GetBoolPref(js_relimit_option_str);
   49:   if (relimit)
   49:     newDefaultJSOptions |= JSOPTION_RELIMIT;
   49:   else
   49:     newDefaultJSOptions &= ~JSOPTION_RELIMIT;
   49: 
61450:   ::JS_SetOptions(context->mContext, newDefaultJSOptions & JSRUNOPTION_MASK);
    1: 
    1:   // Save the new defaults for the next page load (InitContext).
    1:   context->mDefaultJSOptions = newDefaultJSOptions;
 7806: 
 7806: #ifdef JS_GC_ZEAL
 7806:   PRInt32 zeal = nsContentUtils::GetIntPref(js_zeal_option_str, -1);
 7806:   if (zeal >= 0)
 7806:     ::JS_SetGCZeal(context->mContext, (PRUint8)zeal);
 7806: #endif
 7806: 
    1:   return 0;
    1: }
    1: 
35152: nsJSContext::nsJSContext(JSRuntime *aRuntime)
35152:   : mGCOnDestruction(PR_TRUE),
35152:     mExecuteDepth(0)
    1: {
    1: 
    1:   ++sContextCount;
    1: 
10142:   mDefaultJSOptions = JSOPTION_PRIVATE_IS_NSISUPPORTS | JSOPTION_ANONFUNFIX;
    1: 
    1:   mContext = ::JS_NewContext(aRuntime, gStackSize);
    1:   if (mContext) {
 3233:     ::JS_SetContextPrivate(mContext, static_cast<nsIScriptContext *>(this));
    1: 
48479:     // Preserve any flags the context callback might have set.
48479:     mDefaultJSOptions |= ::JS_GetOptions(mContext);
48479: 
    1:     // Make sure the new context gets the default context options
    1:     ::JS_SetOptions(mContext, mDefaultJSOptions);
    1: 
   49:     // Watch for the JS boolean options
    1:     nsContentUtils::RegisterPrefCallback(js_options_dot_str,
    1:                                          JSOptionChangedCallback,
    1:                                          this);
23442: 
25087:     ::JS_SetOperationCallback(mContext, DOMOperationCallback);
    1: 
60616:     xpc_LocalizeContext(mContext);
    1:   }
    1:   mIsInitialized = PR_FALSE;
    1:   mTerminations = nsnull;
    1:   mScriptsEnabled = PR_TRUE;
29105:   mOperationCallbackTime = 0;
29105:   mModalStateTime = 0;
29105:   mModalStateDepth = 0;
    1:   mProcessingScriptTag = PR_FALSE;
    1: }
    1: 
    1: nsJSContext::~nsJSContext()
    1: {
 6016: #ifdef DEBUG
 6016:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIScriptContext*>(this));
 6016: #endif
61409: 
61409:   // We may still have pending termination functions if the context is destroyed
61409:   // before they could be executed. In this case, free the references to their
61409:   // parameters, but don't execute the functions (see bug 622326).
61409:   delete mTerminations;
    1: 
55583:   mGlobalObjectRef = nsnull;
28455: 
28455:   DestroyJSContext();
 7286: 
 7286:   --sContextCount;
 7286: 
 7286:   if (!sContextCount && sDidShutdown) {
 7286:     // The last context is being deleted, and we're already in the
 7286:     // process of shutting down, release the JS runtime service, and
 7286:     // the security manager.
 7286: 
 7286:     NS_IF_RELEASE(sRuntimeService);
 7286:     NS_IF_RELEASE(sSecurityManager);
 7286:   }
 7286: }
 7286: 
 7286: void
28455: nsJSContext::DestroyJSContext()
 7286: {
    1:   if (!mContext)
    1:     return;
    1: 
    1:   // Clear our entry in the JSContext, bugzilla bug 66413
    1:   ::JS_SetContextPrivate(mContext, nsnull);
    1: 
    1:   // Unregister our "javascript.options.*" pref-changed callback.
    1:   nsContentUtils::UnregisterPrefCallback(js_options_dot_str,
    1:                                          JSOptionChangedCallback,
    1:                                          this);
    1: 
62725:   PRBool do_gc = mGCOnDestruction && !sGCTimer;
    1: 
    1:   // Let xpconnect destroy the JSContext when it thinks the time is right.
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   if (xpc) {
    1:     xpc->ReleaseJSContext(mContext, !do_gc);
28455:   } else if (do_gc) {
28455:     ::JS_DestroyContext(mContext);
28439:   } else {
28455:     ::JS_DestroyContextNoGC(mContext);
    1:   }
 7286:   mContext = nsnull;
 1846: }
 1846: 
    1: // QueryInterface implementation for nsJSContext
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsJSContext)
28455: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsJSContext)
28455:   NS_ASSERTION(!tmp->mContext || tmp->mContext->outstandingRequests == 0,
28455:                "Trying to unlink a context with outstanding requests.");
28455:   tmp->mIsInitialized = PR_FALSE;
28455:   tmp->mGCOnDestruction = PR_FALSE;
28455:   tmp->DestroyJSContext();
28455: NS_IMPL_CYCLE_COLLECTION_ROOT_END
28455: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSContext)
28455: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsJSContext)
55583:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGlobalObjectRef)
 7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
53870: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(nsJSContext)
53870:   NS_IMPL_CYCLE_COLLECTION_DESCRIBE(nsJSContext, tmp->GetCCRefcnt())
55583:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGlobalObjectRef)
28455:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mContext");
 7286:   nsContentUtils::XPConnect()->NoteJSContext(tmp->mContext, cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsJSContext)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScriptContext)
42412:   NS_INTERFACE_MAP_ENTRY(nsIScriptContextPrincipal)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptNotify)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptContext)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsJSContext, nsIScriptContext)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsJSContext, nsIScriptContext)
    1: 
28455: nsrefcnt
28455: nsJSContext::GetCCRefcnt()
28455: {
28728:   nsrefcnt refcnt = mRefCnt.get();
28728:   if (NS_LIKELY(mContext))
28728:     refcnt += mContext->outstandingRequests;
28728:   return refcnt;
28455: }
28455: 
    1: nsresult
    1: nsJSContext::EvaluateStringWithValue(const nsAString& aScript,
    1:                                      void *aScopeObject,
    1:                                      nsIPrincipal *aPrincipal,
    1:                                      const char *aURL,
    1:                                      PRUint32 aLineNo,
    1:                                      PRUint32 aVersion,
    1:                                      void* aRetValue,
    1:                                      PRBool* aIsUndefined)
    1: {
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (url: %s, line: %d)", MOZ_FUNCTION_NAME,
42480:                            __LINE__, aURL, aLineNo);
42480: 
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   // Safety first: get an object representing the script's principals, i.e.,
    1:   // the entities who signed this script, or the fully-qualified-domain-name
    1:   // or "codebase" from which it was loaded.
    1:   JSPrincipals *jsprin;
    1:   nsIPrincipal *principal = aPrincipal;
    1:   if (!aPrincipal) {
    1:     nsIScriptGlobalObject *global = GetGlobalObject();
    1:     if (!global)
    1:       return NS_ERROR_FAILURE;
    1:     nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
    1:       do_QueryInterface(global, &rv);
    1:     if (NS_FAILED(rv))
    1:       return NS_ERROR_FAILURE;
    1:     principal = objPrincipal->GetPrincipal();
    1:     if (!principal)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   principal->GetJSPrincipals(mContext, &jsprin);
    1: 
    1:   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
    1: 
    1:   PRBool ok = PR_FALSE;
    1: 
    1:   rv = sSecurityManager->CanExecuteScripts(mContext, principal, &ok);
    1:   if (NS_FAILED(rv)) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Push our JSContext on the current thread's context stack so JS called
    1:   // from native code via XPConnect uses the right context.  Do this whether
    1:   // or not the SecurityManager said "ok", in order to simplify control flow
    1:   // below where we pop before returning.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   jsval val;
    1: 
48113:   rv = sSecurityManager->PushContextPrincipal(mContext, nsnull, principal);
48113:   NS_ENSURE_SUCCESS(rv, rv);
48113: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1: 
    1:   // SecurityManager said "ok", but don't compile if aVersion is unknown.
11775:   // Since the caller is responsible for parsing the version strings, we just
    1:   // check it isn't JSVERSION_UNKNOWN.
    1:   if (ok && ((JSVersion)aVersion) != JSVERSION_UNKNOWN) {
11775: 
    1:     JSAutoRequest ar(mContext);
    1: 
54733:     JSAutoEnterCompartment ac;
54733:     if (!ac.enter(mContext, (JSObject *)aScopeObject)) {
48503:       JSPRINCIPALS_DROP(mContext, jsprin);
48503:       stack->Pop(nsnull);
48503:       return NS_ERROR_FAILURE;
48503:     }
48503: 
35152:     ++mExecuteDepth;
35152: 
53848:     ok = ::JS_EvaluateUCScriptForPrincipalsVersion(mContext,
    1:                                                    (JSObject *)aScopeObject,
    1:                                                    jsprin,
    1:                                                    (jschar*)PromiseFlatString(aScript).get(),
    1:                                                    aScript.Length(),
    1:                                                    aURL,
    1:                                                    aLineNo,
53848:                                                    &val,
53848:                                                    JSVersion(aVersion));
28612: 
35152:     --mExecuteDepth;
35152: 
28612:     if (!ok) {
28612:       // Tell XPConnect about any pending exceptions. This is needed
28612:       // to avoid dropping JS exceptions in case we got here through
28612:       // nested calls through XPConnect.
28612: 
28612:       ReportPendingException();
28612:     }
    1:   }
    1: 
    1:   // Whew!  Finally done with these manually ref-counted things.
    1:   JSPRINCIPALS_DROP(mContext, jsprin);
    1: 
    1:   // If all went well, convert val to a string (XXXbe unless undefined?).
    1:   if (ok) {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = JSVAL_IS_VOID(val);
    1:     }
    1: 
 3233:     *static_cast<jsval*>(aRetValue) = val;
    1:     // XXX - nsScriptObjectHolder should be used once this method moves to
    1:     // the new world order. However, use of 'jsval' appears to make this
    1:     // tricky...
    1:   }
    1:   else {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1:   }
    1: 
48113:   sSecurityManager->PopContextPrincipal(mContext);
48113: 
    1:   // Pop here, after JS_ValueToString and any other possible evaluation.
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: 
    1: }
    1: 
    1: // Helper function to convert a jsval to an nsAString, and set
    1: // exception flags if the conversion fails.
    1: static nsresult
    1: JSValueToAString(JSContext *cx, jsval val, nsAString *result,
    1:                  PRBool *isUndefined)
    1: {
    1:   if (isUndefined) {
    1:     *isUndefined = JSVAL_IS_VOID(val);
    1:   }
    1: 
    1:   if (!result) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   JSString* jsstring = ::JS_ValueToString(cx, val);
59889:   if (!jsstring) {
59889:     goto error;
59889:   }
59889: 
59889:   size_t length;
59889:   const jschar *chars;
59889:   chars = ::JS_GetStringCharsAndLength(cx, jsstring, &length);
59889:   if (!chars) {
59889:     goto error;
59889:   }
59889: 
59889:   result->Assign(chars, length);
59889:   return NS_OK;
59889: 
59889: error:
    1:   // We failed to convert val to a string. We're either OOM, or the
    1:   // security manager denied access to .toString(), or somesuch, on
    1:   // an object. Treat this case as if the result were undefined.
    1: 
59889:   result->Truncate();
59889: 
    1:   if (isUndefined) {
    1:     *isUndefined = PR_TRUE;
    1:   }
    1: 
    1:   if (!::JS_IsExceptionPending(cx)) {
59889:     // JS_ValueToString()/JS_GetStringCharsAndLength returned null w/o an
59889:     // exception pending. That means we're OOM.
    1: 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
42412: nsIScriptObjectPrincipal*
42412: nsJSContext::GetObjectPrincipal()
42412: {
42412:   nsCOMPtr<nsIScriptObjectPrincipal> prin = do_QueryInterface(GetGlobalObject());
42412:   return prin;
42412: }
42412: 
    1: nsresult
    1: nsJSContext::EvaluateString(const nsAString& aScript,
    1:                             void *aScopeObject,
    1:                             nsIPrincipal *aPrincipal,
    1:                             const char *aURL,
    1:                             PRUint32 aLineNo,
    1:                             PRUint32 aVersion,
    1:                             nsAString *aRetValue,
    1:                             PRBool* aIsUndefined)
    1: {
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (url: %s, line: %d)", MOZ_FUNCTION_NAME,
42480:                            __LINE__, aURL, aLineNo);
42480: 
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
27903:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
27903:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   // Safety first: get an object representing the script's principals, i.e.,
    1:   // the entities who signed this script, or the fully-qualified-domain-name
    1:   // or "codebase" from which it was loaded.
    1:   JSPrincipals *jsprin;
    1:   nsIPrincipal *principal = aPrincipal;
    1:   if (aPrincipal) {
    1:     aPrincipal->GetJSPrincipals(mContext, &jsprin);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
    1:       do_QueryInterface(GetGlobalObject(), &rv);
    1:     if (NS_FAILED(rv))
    1:       return NS_ERROR_FAILURE;
    1:     principal = objPrincipal->GetPrincipal();
    1:     if (!principal)
    1:       return NS_ERROR_FAILURE;
    1:     principal->GetJSPrincipals(mContext, &jsprin);
    1:   }
    1: 
    1:   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
    1: 
    1:   PRBool ok = PR_FALSE;
    1: 
    1:   rv = sSecurityManager->CanExecuteScripts(mContext, principal, &ok);
    1:   if (NS_FAILED(rv)) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Push our JSContext on the current thread's context stack so JS called
    1:   // from native code via XPConnect uses the right context.  Do this whether
    1:   // or not the SecurityManager said "ok", in order to simplify control flow
    1:   // below where we pop before returning.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // The result of evaluation, used only if there were no errors.  This need
10142:   // not be a GC root currently, provided we run the GC only from the
10142:   // operation callback or from ScriptEvaluated.
17840:   jsval val = JSVAL_VOID;
17840:   jsval* vp = aRetValue ? &val : NULL;
    1: 
48113:   rv = sSecurityManager->PushContextPrincipal(mContext, nsnull, principal);
48113:   NS_ENSURE_SUCCESS(rv, rv);
48113: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1: 
35152:   ++mExecuteDepth;
35152: 
    1:   // SecurityManager said "ok", but don't compile if aVersion is unknown.
11775:   // Since the caller is responsible for parsing the version strings, we just
    1:   // check it isn't JSVERSION_UNKNOWN.
    1:   if (ok && ((JSVersion)aVersion) != JSVERSION_UNKNOWN) {
    1:     JSAutoRequest ar(mContext);
54733:     JSAutoEnterCompartment ac;
54733:     if (!ac.enter(mContext, (JSObject *)aScopeObject)) {
48503:       stack->Pop(nsnull);
48503:       JSPRINCIPALS_DROP(mContext, jsprin);
48503:       return NS_ERROR_FAILURE;
48503:     }
48503: 
53848:     ok = ::JS_EvaluateUCScriptForPrincipalsVersion(mContext,
    1:                                                    (JSObject *)aScopeObject,
    1:                                                    jsprin,
    1:                                                    (jschar*)PromiseFlatString(aScript).get(),
    1:                                                    aScript.Length(),
    1:                                                    aURL,
    1:                                                    aLineNo,
53848:                                                    vp,
53848:                                                    JSVersion(aVersion));
    1: 
    1:     if (!ok) {
    1:       // Tell XPConnect about any pending exceptions. This is needed
    1:       // to avoid dropping JS exceptions in case we got here through
    1:       // nested calls through XPConnect.
    1: 
28612:       ReportPendingException();
    1:     }
    1:   }
    1: 
    1:   // Whew!  Finally done with these manually ref-counted things.
    1:   JSPRINCIPALS_DROP(mContext, jsprin);
    1: 
17840:   // If all went well, convert val to a string if one is wanted.
    1:   if (ok) {
    1:     JSAutoRequest ar(mContext);
55621:     JSAutoEnterCompartment ac;
55621:     if (!ac.enter(mContext, (JSObject *)aScopeObject)) {
55621:       stack->Pop(nsnull);
55621:     }
    1:     rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
    1:   }
    1:   else {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1:   }
    1: 
35152:   --mExecuteDepth;
35152: 
48113:   sSecurityManager->PopContextPrincipal(mContext);
48113: 
    1:   // Pop here, after JS_ValueToString and any other possible evaluation.
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::CompileScript(const PRUnichar* aText,
    1:                            PRInt32 aTextLength,
    1:                            void *aScopeObject,
    1:                            nsIPrincipal *aPrincipal,
    1:                            const char *aURL,
    1:                            PRUint32 aLineNo,
    1:                            PRUint32 aVersion,
    1:                            nsScriptObjectHolder &aScriptObject)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv;
    1:   NS_ENSURE_ARG_POINTER(aPrincipal);
    1: 
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   JSPrincipals *jsprin;
    1:   aPrincipal->GetJSPrincipals(mContext, &jsprin);
    1:   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
    1: 
    1:   PRBool ok = PR_FALSE;
    1: 
    1:   rv = sSecurityManager->CanExecuteScripts(mContext, aPrincipal, &ok);
    1:   if (NS_FAILED(rv)) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   aScriptObject.drop(); // ensure old object not used on failure...
    1: 
    1:   // SecurityManager said "ok", but don't compile if aVersion is unknown.
11775:   // Since the caller is responsible for parsing the version strings, we just
    1:   // check it isn't JSVERSION_UNKNOWN.
    1:   if (ok && ((JSVersion)aVersion) != JSVERSION_UNKNOWN) {
    1:     JSAutoRequest ar(mContext);
    1: 
    1:     JSScript* script =
53848:         ::JS_CompileUCScriptForPrincipalsVersion(mContext,
    1:                                                  (JSObject *)aScopeObject,
    1:                                                  jsprin,
    1:                                                  (jschar*) aText,
    1:                                                  aTextLength,
    1:                                                  aURL,
53848:                                                  aLineNo,
53848:                                                  JSVersion(aVersion));
    1:     if (script) {
    1:       JSObject *scriptObject = ::JS_NewScriptObject(mContext, script);
    1:       if (scriptObject) {
    1:         NS_ASSERTION(aScriptObject.getScriptTypeID()==JAVASCRIPT,
    1:                      "Expecting JS script object holder");
    1:         rv = aScriptObject.set(scriptObject);
    1:       } else {
    1:         ::JS_DestroyScript(mContext, script);
    1:         script = nsnull;
    1:       }
11775:     } else {
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   // Whew!  Finally done.
    1:   JSPRINCIPALS_DROP(mContext, jsprin);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::ExecuteScript(void *aScriptObject,
    1:                            void *aScopeObject,
    1:                            nsAString* aRetValue,
    1:                            PRBool* aIsUndefined)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1: 
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   // Push our JSContext on our thread's context stack, in case native code
    1:   // called from JS calls back into JS via XPConnect.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // The result of evaluation, used only if there were no errors.  This need
10142:   // not be a GC root currently, provided we run the GC only from the
10142:   // operation callback or from ScriptEvaluated.
    1:   jsval val;
    1:   JSBool ok;
    1: 
48114:   JSObject *scriptObj = (JSObject*)aScriptObject;
48114:   nsCOMPtr<nsIPrincipal> principal;
48114: 
48114:   rv = sSecurityManager->GetObjectPrincipal(mContext, scriptObj, getter_AddRefs(principal));
48114:   NS_ENSURE_SUCCESS(rv, rv);
48114: 
48113:   rv = sSecurityManager->PushContextPrincipal(mContext, nsnull, principal);
48113:   NS_ENSURE_SUCCESS(rv, rv);
48113: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1:   JSAutoRequest ar(mContext);
35152:   ++mExecuteDepth;
    1:   ok = ::JS_ExecuteScript(mContext,
    1:                           (JSObject *)aScopeObject,
48114:                           (JSScript*)::JS_GetPrivate(mContext, scriptObj),
    1:                           &val);
    1: 
    1:   if (ok) {
    1:     // If all went well, convert val to a string (XXXbe unless undefined?).
    1:     rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
    1:   } else {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1:   }
    1: 
35152:   --mExecuteDepth;
35152: 
48113:   sSecurityManager->PopContextPrincipal(mContext);
48113: 
    1:   // Pop here, after JS_ValueToString and any other possible evaluation.
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
39100: #ifdef DEBUG
39100: PRBool
39100: AtomIsEventHandlerName(nsIAtom *aName)
    1: {
39100:   const PRUnichar *name = aName->GetUTF16String();
39100: 
39100:   const PRUnichar *cp;
39100:   PRUnichar c;
    1:   for (cp = name; *cp != '\0'; ++cp)
    1:   {
    1:     c = *cp;
39100:     if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z'))
39100:       return PR_FALSE;
39100:   }
39100: 
39100:   return PR_TRUE;
    1: }
    1: #endif
    1: 
    1: // Helper function to find the JSObject associated with a (presumably DOM)
    1: // interface.
    1: nsresult
    1: nsJSContext::JSObjectFromInterface(nsISupports* aTarget, void *aScope, JSObject **aRet)
    1: {
30625:   // It is legal to specify a null target.
30625:   if (!aTarget) {
    1:       *aRet = nsnull;
    1:       return NS_OK;
    1:   }
30625: 
    1:   // Get the jsobject associated with this target
30625:   // We don't wrap here because we trust the JS engine to wrap the target
30625:   // later.
    1:   nsresult rv;
30001:   jsval v;
31981:   rv = nsContentUtils::WrapNative(mContext, (JSObject *)aScope, aTarget, &v);
    1:   NS_ENSURE_SUCCESS(rv, rv);
30001: 
    1: #ifdef NS_DEBUG
    1:   nsCOMPtr<nsISupports> targetSupp = do_QueryInterface(aTarget);
30001:   nsCOMPtr<nsISupports> native =
30001:     nsContentUtils::XPConnect()->GetNativeOfWrapper(mContext,
30001:                                                     JSVAL_TO_OBJECT(v));
30001:   NS_ASSERTION(native == targetSupp, "Native should be the target!");
    1: #endif
30001: 
30001:   *aRet = JSVAL_TO_OBJECT(v);
30001: 
30001:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsJSContext::CompileEventHandler(nsIAtom *aName,
    1:                                  PRUint32 aArgCount,
    1:                                  const char** aArgNames,
    1:                                  const nsAString& aBody,
    1:                                  const char *aURL, PRUint32 aLineNo,
11775:                                  PRUint32 aVersion,
    1:                                  nsScriptObjectHolder &aHandler)
    1: {
42480:   NS_TIME_FUNCTION_MIN_FMT(1.0, "%s (line %d) (url: %s, line: %d)", MOZ_FUNCTION_NAME,
42480:                            __LINE__, aURL, aLineNo);
42480: 
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
39100:   NS_PRECONDITION(AtomIsEventHandlerName(aName), "Bad event name");
22253:   NS_PRECONDITION(!::JS_IsExceptionPending(mContext),
22253:                   "Why are we being called with a pending exception?");
22253: 
    1:   if (!sSecurityManager) {
    1:     NS_ERROR("Huh, we need a script security manager to compile "
    1:              "an event handler!");
    1: 
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
11775:   // Don't compile if aVersion is unknown.  Since the caller is responsible for
11775:   // parsing the version strings, we just check it isn't JSVERSION_UNKNOWN.
11775:   if ((JSVersion)aVersion == JSVERSION_UNKNOWN) {
11775:     return NS_ERROR_ILLEGAL_VALUE;
11775:   }
11775: 
26165: #ifdef DEBUG
26165:   JSContext* top = nsContentUtils::GetCurrentJSContext();
26165:   NS_ASSERTION(mContext == top, "Context not properly pushed!");
26165: #endif
26165: 
    1:   // Event handlers are always shared, and must be bound before use.
    1:   // Therefore we never bother compiling with principals.
    1:   // (that probably means we should avoid JS_CompileUCFunctionForPrincipals!)
    1:   JSAutoRequest ar(mContext);
11775: 
    1:   JSFunction* fun =
53848:       ::JS_CompileUCFunctionForPrincipalsVersion(mContext,
    1:                                                  nsnull, nsnull,
39100:                                                  nsAtomCString(aName).get(), aArgCount, aArgNames,
    1:                                                  (jschar*)PromiseFlatString(aBody).get(),
    1:                                                  aBody.Length(),
53848:                                                  aURL, aLineNo, JSVersion(aVersion));
    1: 
    1:   if (!fun) {
28612:     ReportPendingException();
 3187:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   JSObject *handler = ::JS_GetFunctionObject(fun);
    1:   NS_ASSERTION(aHandler.getScriptTypeID()==JAVASCRIPT,
    1:                "Expecting JS script object holder");
    1:   return aHandler.set((void *)handler);
    1: }
    1: 
    1: // XXX - note that CompileFunction doesn't yet play the nsScriptObjectHolder
    1: // game - caller must still ensure JS GC root.
    1: nsresult
    1: nsJSContext::CompileFunction(void* aTarget,
    1:                              const nsACString& aName,
    1:                              PRUint32 aArgCount,
    1:                              const char** aArgArray,
    1:                              const nsAString& aBody,
    1:                              const char* aURL,
    1:                              PRUint32 aLineNo,
11775:                              PRUint32 aVersion,
    1:                              PRBool aShared,
    1:                              void** aFunctionObject)
    1: {
42480:   NS_TIME_FUNCTION_FMT(1.0, "%s (line %d) (function: %s, url: %s, line: %d)", MOZ_FUNCTION_NAME,
42480:                        __LINE__, aName.BeginReading(), aURL, aLineNo);
42480: 
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
11775:   // Don't compile if aVersion is unknown.  Since the caller is responsible for
11775:   // parsing the version strings, we just check it isn't JSVERSION_UNKNOWN.
11775:   if ((JSVersion)aVersion == JSVERSION_UNKNOWN) {
11775:     return NS_ERROR_ILLEGAL_VALUE;
11775:   }
11775: 
    1:   JSPrincipals *jsprin = nsnull;
    1: 
    1:   nsIScriptGlobalObject *global = GetGlobalObject();
    1:   if (global) {
    1:     // XXXbe why the two-step QI? speed up via a new GetGlobalObjectData func?
    1:     nsCOMPtr<nsIScriptObjectPrincipal> globalData = do_QueryInterface(global);
    1:     if (globalData) {
    1:       nsIPrincipal *prin = globalData->GetPrincipal();
    1:       if (!prin)
    1:         return NS_ERROR_FAILURE;
    1:       prin->GetJSPrincipals(mContext, &jsprin);
    1:     }
    1:   }
    1: 
    1:   JSObject *target = (JSObject*)aTarget;
    1: 
    1:   JSAutoRequest ar(mContext);
    1: 
    1:   JSFunction* fun =
53848:       ::JS_CompileUCFunctionForPrincipalsVersion(mContext,
    1:                                                  aShared ? nsnull : target, jsprin,
    1:                                                  PromiseFlatCString(aName).get(),
    1:                                                  aArgCount, aArgArray,
    1:                                                  (jschar*)PromiseFlatString(aBody).get(),
    1:                                                  aBody.Length(),
53848:                                                  aURL, aLineNo,
53848:                                                  JSVersion(aVersion));
    1: 
    1:   if (jsprin)
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:   if (!fun)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   JSObject *handler = ::JS_GetFunctionObject(fun);
    1:   if (aFunctionObject)
    1:     *aFunctionObject = (void*) handler;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::CallEventHandler(nsISupports* aTarget, void *aScope, void *aHandler,
    1:                               nsIArray *aargv, nsIVariant **arv)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
    1:     return NS_OK;
    1:   }
 4051: 
57814: #ifdef NS_FUNCTION_TIMER
57814:   {
57814:     JSObject *obj = static_cast<JSObject *>(aHandler);
57927:     JSString *id = JS_GetFunctionId(static_cast<JSFunction *>(JS_GetPrivate(mContext, obj)));
57814:     JSAutoByteString bytes;
57814:     const char *name = !id ? "anonymous" : bytes.encode(mContext, id) ? bytes.ptr() : "<error>";
57814:     NS_TIME_FUNCTION_FMT(1.0, "%s (line %d) (function: %s)", MOZ_FUNCTION_NAME, __LINE__, name);
57814:   }
57814: #endif
48539: 
48539:   JSAutoRequest ar(mContext);
    1:   JSObject* target = nsnull;
27434:   nsresult rv = JSObjectFromInterface(aTarget, aScope, &target);
    1:   NS_ENSURE_SUCCESS(rv, rv);
27434: 
40407:   js::AutoObjectRooter targetVal(mContext, target);
    1:   jsval rval = JSVAL_VOID;
    1: 
    1:   // This one's a lot easier than EvaluateString because we don't have to
    1:   // hassle with principals: they're already compiled into the JS function.
    1:   // xxxmarkh - this comment is no longer true - principals are not used at
    1:   // all now, and never were in some cases.
    1: 
60475:   nsCxPusher pusher;
60475:   if (!pusher.Push(mContext, PR_TRUE))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // check if the event handler can be run on the object in question
    1:   rv = sSecurityManager->CheckFunctionAccess(mContext, aHandler, target);
    1: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Convert args to jsvals.
    1:     PRUint32 argc = 0;
    1:     jsval *argv = nsnull;
    1: 
61213:     JSObject *funobj = static_cast<JSObject *>(aHandler);
61213:     nsCOMPtr<nsIPrincipal> principal;
61213:     rv = sSecurityManager->GetObjectPrincipal(mContext, funobj,
61213:                                               getter_AddRefs(principal));
61213:     NS_ENSURE_SUCCESS(rv, rv);
61213: 
61213:     JSStackFrame *currentfp = nsnull;
61213:     rv = sSecurityManager->PushContextPrincipal(mContext,
61213:                                                 JS_FrameIterator(mContext, &currentfp),
61213:                                                 principal);
61213:     NS_ENSURE_SUCCESS(rv, rv);
61213: 
61213:     jsval funval = OBJECT_TO_JSVAL(funobj);
61213:     JSAutoEnterCompartment ac;
61454:     if (!ac.enter(mContext, funobj) || !JS_WrapObject(mContext, &target)) {
61213:       sSecurityManager->PopContextPrincipal(mContext);
61213:       return NS_ERROR_FAILURE;
61213:     }
61213: 
37767:     js::LazilyConstructed<nsAutoPoolRelease> poolRelease;
40407:     js::LazilyConstructed<js::AutoArrayRooter> tvr;
37767: 
    1:     // Use |target| as the scope for wrapping the arguments, since aScope is
    1:     // the safe scope in many cases, which isn't very useful.  Wrapping aTarget
    1:     // was OK because those typically have PreCreate methods that give them the
    1:     // right scope anyway, and we want to make sure that the arguments end up
    1:     // in the same scope as aTarget.
    1:     rv = ConvertSupportsTojsvals(aargv, target, &argc,
37767:                                  &argv, poolRelease, tvr);
60475:     NS_ENSURE_SUCCESS(rv, rv);
60475: 
35152:     ++mExecuteDepth;
    1:     PRBool ok = ::JS_CallFunctionValue(mContext, target,
    1:                                        funval, argc, argv, &rval);
35152:     --mExecuteDepth;
    1: 
    1:     if (!ok) {
    1:       // Tell XPConnect about any pending exceptions. This is needed
    1:       // to avoid dropping JS exceptions in case we got here through
    1:       // nested calls through XPConnect.
    1: 
28612:       ReportPendingException();
    1: 
    1:       // Don't pass back results from failed calls.
    1:       rval = JSVAL_VOID;
    1: 
    1:       // Tell the caller that the handler threw an error.
    1:       rv = NS_ERROR_FAILURE;
    1:     }
60475: 
60475:     sSecurityManager->PopContextPrincipal(mContext);
60475:   }
60475: 
60475:   pusher.Pop();
    1: 
    1:   // Convert to variant before calling ScriptEvaluated, as it may GC, meaning
    1:   // we would need to root rval.
    1:   if (NS_SUCCEEDED(rv)) {
11211:     if (rval == JSVAL_NULL)
11211:       *arv = nsnull;
11211:     else
    1:       rv = nsContentUtils::XPConnect()->JSToVariant(mContext, rval, arv);
    1:   }
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::BindCompiledEventHandler(nsISupports* aTarget, void *aScope,
    1:                                       nsIAtom *aName,
    1:                                       void *aHandler)
    1: {
    1:   NS_ENSURE_ARG(aHandler);
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
39100:   NS_PRECONDITION(AtomIsEventHandlerName(aName), "Bad event name");
58977: 
58977:   JSAutoRequest ar(mContext);
    1: 
    1:   // Get the jsobject associated with this target
    1:   JSObject *target = nsnull;
58977:   nsresult rv = JSObjectFromInterface(aTarget, aScope, &target);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   JSObject *funobj = (JSObject*) aHandler;
 6082: 
55601: #ifdef DEBUG
55601:   {
55601:     JSAutoEnterCompartment ac;
55601:     if (!ac.enter(mContext, funobj)) {
55601:       return NS_ERROR_FAILURE;
55601:     }
55601: 
55601:     NS_ASSERTION(JS_TypeOfValue(mContext,
55601:                                 OBJECT_TO_JSVAL(funobj)) == JSTYPE_FUNCTION,
    1:                  "Event handler object not a function");
55601:   }
55601: #endif
55601: 
55601:   JSAutoEnterCompartment ac;
55601:   if (!ac.enter(mContext, target)) {
55601:     return NS_ERROR_FAILURE;
55601:   }
    1: 
    1:   // Push our JSContext on our thread's context stack, in case native code
    1:   // called from JS calls back into JS via XPConnect.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Make sure the handler function is parented by its event target object
    1:   if (funobj) { // && ::JS_GetParent(mContext, funobj) != target) {
    1:     funobj = ::JS_CloneFunctionObject(mContext, funobj, target);
    1:     if (!funobj)
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv) &&
    1:       // Make sure the flags here match those in nsEventReceiverSH::NewResolve
39100:       !::JS_DefineProperty(mContext, target, nsAtomCString(aName).get(),
    1:                            OBJECT_TO_JSVAL(funobj), nsnull, nsnull,
    1:                            JSPROP_ENUMERATE | JSPROP_PERMANENT)) {
28612:     ReportPendingException();
    1:     rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // XXXmarkh - ideally we should assert that the wrapped native is now
    1:   // "long lived" - how to do that?
    1: 
    1:   if (NS_FAILED(stack->Pop(nsnull)) && NS_SUCCEEDED(rv)) {
    1:     rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::GetBoundEventHandler(nsISupports* aTarget, void *aScope,
    1:                                   nsIAtom* aName,
    1:                                   nsScriptObjectHolder &aHandler)
    1: {
39100:     NS_PRECONDITION(AtomIsEventHandlerName(aName), "Bad event name");
39100: 
58977:     JSAutoRequest ar(mContext);
    1:     JSObject *obj = nsnull;
58977:     nsresult rv = JSObjectFromInterface(aTarget, aScope, &obj);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
55601:     JSAutoEnterCompartment ac;
55601:     if (!ac.enter(mContext, obj)) {
55601:       return NS_ERROR_FAILURE;
55601:     }
55601: 
    1:     jsval funval;
    1:     if (!JS_LookupProperty(mContext, obj,
39100:                            nsAtomCString(aName).get(), &funval))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (JS_TypeOfValue(mContext, funval) != JSTYPE_FUNCTION) {
    1:         NS_WARNING("Event handler object not a function");
    1:         aHandler.drop();
    1:         return NS_OK;
    1:     }
    1:     NS_ASSERTION(aHandler.getScriptTypeID()==JAVASCRIPT,
    1:                  "Expecting JS script object holder");
    1:     return aHandler.set(JSVAL_TO_OBJECT(funval));
    1: }
    1: 
    1: // serialization
    1: nsresult
    1: nsJSContext::Serialize(nsIObjectOutputStream* aStream, void *aScriptObject)
    1: {
    1:     JSObject *mJSObject = (JSObject *)aScriptObject;
    1:     if (!mJSObject)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsresult rv;
    1: 
    1:     JSContext* cx = mContext;
    1:     JSXDRState *xdr = ::JS_XDRNewMem(cx, JSXDR_ENCODE);
    1:     if (! xdr)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     xdr->userdata = (void*) aStream;
    1: 
    1:     JSAutoRequest ar(cx);
 3233:     JSScript *script = reinterpret_cast<JSScript*>
 3233:                                        (::JS_GetPrivate(cx, mJSObject));
    1:     if (! ::JS_XDRScript(xdr, &script)) {
    1:         rv = NS_ERROR_FAILURE;  // likely to be a principals serialization error
    1:     } else {
    1:         // Get the encoded JSXDRState data and write it.  The JSXDRState owns
    1:         // this buffer memory and will free it beneath ::JS_XDRDestroy.
    1:         //
    1:         // If an XPCOM object needs to be written in the midst of the JS XDR
    1:         // encoding process, the C++ code called back from the JS engine (e.g.,
    1:         // nsEncodeJSPrincipals in caps/src/nsJSPrincipals.cpp) will flush data
    1:         // from the JSXDRState to aStream, then write the object, then return
    1:         // to JS XDR code with xdr reset so new JS data is encoded at the front
    1:         // of the xdr's data buffer.
    1:         //
    1:         // However many XPCOM objects are interleaved with JS XDR data in the
    1:         // stream, when control returns here from ::JS_XDRScript, we'll have
    1:         // one last buffer of data to write to aStream.
    1: 
    1:         uint32 size;
 3233:         const char* data = reinterpret_cast<const char*>
 3233:                                            (::JS_XDRMemGetData(xdr, &size));
    1:         NS_ASSERTION(data, "no decoded JSXDRState data!");
    1: 
    1:         rv = aStream->Write32(size);
    1:         if (NS_SUCCEEDED(rv))
    1:             rv = aStream->WriteBytes(data, size);
    1:     }
    1: 
    1:     ::JS_XDRDestroy(xdr);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::Deserialize(nsIObjectInputStream* aStream,
    1:                          nsScriptObjectHolder &aResult)
    1: {
    1:     JSObject *result = nsnull;
    1:     nsresult rv;
    1: 
42480:     NS_TIME_FUNCTION_MIN(1.0);
42480: 
    1:     NS_TIMELINE_MARK_FUNCTION("js script deserialize");
    1: 
    1:     PRUint32 size;
    1:     rv = aStream->Read32(&size);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     char* data;
    1:     rv = aStream->ReadBytes(size, &data);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     JSContext* cx = mContext;
    1: 
    1:     JSXDRState *xdr = ::JS_XDRNewMem(cx, JSXDR_DECODE);
    1:     if (! xdr) {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:     } else {
    1:         xdr->userdata = (void*) aStream;
    1:         JSAutoRequest ar(cx);
    1:         ::JS_XDRMemSetData(xdr, data, size);
    1: 
    1:         JSScript *script = nsnull;
    1:         if (! ::JS_XDRScript(xdr, &script)) {
    1:             rv = NS_ERROR_FAILURE;  // principals deserialization error?
    1:         } else {
    1:             result = ::JS_NewScriptObject(cx, script);
    1:             if (! result) {
    1:                 rv = NS_ERROR_OUT_OF_MEMORY;    // certain error
    1:                 ::JS_DestroyScript(cx, script);
    1:             }
    1:         }
    1: 
    1:         // Update data in case ::JS_XDRScript called back into C++ code to
    1:         // read an XPCOM object.
    1:         //
    1:         // In that case, the serialization process must have flushed a run
    1:         // of counted bytes containing JS data at the point where the XPCOM
    1:         // object starts, after which an encoding C++ callback from the JS
    1:         // XDR code must have written the XPCOM object directly into the
    1:         // nsIObjectOutputStream.
    1:         //
    1:         // The deserialization process will XDR-decode counted bytes up to
    1:         // but not including the XPCOM object, then call back into C++ to
    1:         // read the object, then read more counted bytes and hand them off
    1:         // to the JSXDRState, so more JS data can be decoded.
    1:         //
    1:         // This interleaving of JS XDR data and XPCOM object data may occur
    1:         // several times beneath the call to ::JS_XDRScript, above.  At the
    1:         // end of the day, we need to free (via nsMemory) the data owned by
    1:         // the JSXDRState.  So we steal it back, nulling xdr's buffer so it
    1:         // doesn't get passed to ::JS_free by ::JS_XDRDestroy.
    1: 
    1:         uint32 junk;
    1:         data = (char*) ::JS_XDRMemGetData(xdr, &junk);
    1:         if (data)
    1:             ::JS_XDRMemSetData(xdr, NULL, 0);
    1:         ::JS_XDRDestroy(xdr);
    1:     }
    1: 
    1:     // If data is null now, it must have been freed while deserializing an
    1:     // XPCOM object (e.g., a principal) beneath ::JS_XDRScript.
    1:     if (data)
    1:         nsMemory::Free(data);
    1:     NS_ASSERTION(aResult.getScriptTypeID()==JAVASCRIPT,
    1:                  "Expecting JS script object holder");
 3729: 
 3729:     // Now that we've cleaned up, handle the case when rv is a failure
 3729:     // code, which could happen for all sorts of reasons above.
 3729:     NS_ENSURE_SUCCESS(rv, rv);
 3729: 
    1:     return aResult.set(result);
    1: }
    1: 
    1: void
    1: nsJSContext::SetDefaultLanguageVersion(PRUint32 aVersion)
    1: {
    1:   ::JS_SetVersion(mContext, (JSVersion)aVersion);
    1: }
    1: 
    1: nsIScriptGlobalObject *
    1: nsJSContext::GetGlobalObject()
    1: {
    1:   JSObject *global = ::JS_GetGlobalObject(mContext);
    1: 
    1:   if (!global) {
55577:     return nsnull;
55577:   }
55577: 
55577:   OBJ_TO_INNER_OBJECT(mContext, global);
55577:   if (!global) {
    1:     return nsnull;
    1:   }
    1: 
    1:   JSClass *c = JS_GET_CLASS(mContext, global);
    1: 
    1:   if (!c || ((~c->flags) & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_PRIVATE_IS_NSISUPPORTS))) {
    1:     return nsnull;
    1:   }
    1: 
62404:   nsISupports *priv = (nsISupports *)global->getPrivate();
    1: 
    1:   nsCOMPtr<nsIXPConnectWrappedNative> wrapped_native =
    1:     do_QueryInterface(priv);
    1: 
62404:   nsCOMPtr<nsIScriptGlobalObject> sgo;
    1:   if (wrapped_native) {
    1:     // The global object is a XPConnect wrapped native, the native in
    1:     // the wrapper might be the nsIScriptGlobalObject
    1: 
    1:     sgo = do_QueryWrappedNative(wrapped_native);
    1:   } else {
    1:     sgo = do_QueryInterface(priv);
    1:   }
    1: 
    1:   // This'll return a pointer to something we're about to release, but
    1:   // that's ok, the JS object will hold it alive long enough.
55577:   nsCOMPtr<nsPIDOMWindow> pwin(do_QueryInterface(sgo));
55577:   if (!pwin)
    1:     return sgo;
55577: 
55577:   return static_cast<nsGlobalWindow *>(pwin->GetOuterWindow());
    1: }
    1: 
    1: void *
    1: nsJSContext::GetNativeGlobal()
    1: {
    1:     return ::JS_GetGlobalObject(mContext);
    1: }
    1: 
    1: nsresult
    1: nsJSContext::CreateNativeGlobalForInner(
    1:                                 nsIScriptGlobalObject *aNewInner,
    1:                                 PRBool aIsChrome,
48503:                                 nsIPrincipal *aPrincipal,
    1:                                 void **aNativeGlobal, nsISupports **aHolder)
    1: {
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   PRUint32 flags = aIsChrome? nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT : 0;
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> jsholder;
55595: 
55595:   nsCOMPtr<nsIPrincipal> systemPrincipal;
55595:   if (aIsChrome) {
55595:     nsIScriptSecurityManager *ssm = nsContentUtils::GetSecurityManager();
55595:     ssm->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
55595:   }
55595: 
    1:   nsresult rv = xpc->
    1:           InitClassesWithNewWrappedGlobal(mContext,
    1:                                           aNewInner, NS_GET_IID(nsISupports),
55595:                                           aIsChrome ? systemPrincipal.get() : aPrincipal,
56748:                                           nsnull, flags,
    1:                                           getter_AddRefs(jsholder));
    1:   if (NS_FAILED(rv))
    1:     return rv;
 3233:   jsholder->GetJSObject(reinterpret_cast<JSObject **>(aNativeGlobal));
    1:   *aHolder = jsholder.get();
    1:   NS_ADDREF(*aHolder);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::ConnectToInner(nsIScriptGlobalObject *aNewInner, void *aOuterGlobal)
    1: {
    1:   NS_ENSURE_ARG(aNewInner);
    1:   JSObject *newInnerJSObject = (JSObject *)aNewInner->GetScriptGlobal(JAVASCRIPT);
51078:   JSObject *outerGlobal = (JSObject *)aOuterGlobal;
    1: 
55604:   // Now that we're connecting the outer global to the inner one,
55604:   // we must have transplanted it. The JS engine tries to maintain
55604:   // the global object's compartment as its default compartment,
55604:   // so update that now since it might have changed.
55604:   JS_SetGlobalObject(mContext, outerGlobal);
59622:   NS_ASSERTION(JS_GetPrototype(mContext, outerGlobal) ==
59622:                JS_GetPrototype(mContext, newInnerJSObject),
59622:                "outer and inner globals should have the same prototype");
51078: 
    1:   return NS_OK;
    1: }
    1: 
    1: void *
    1: nsJSContext::GetNativeContext()
    1: {
    1:   return mContext;
    1: }
    1: 
    1: nsresult
48477: nsJSContext::InitContext()
    1: {
    1:   // Make sure callers of this use
    1:   // WillInitializeContext/DidInitializeContext around this call.
    1:   NS_ENSURE_TRUE(!mIsInitialized, NS_ERROR_ALREADY_INITIALIZED);
    1: 
    1:   if (!mContext)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   ::JS_SetErrorReporter(mContext, NS_ScriptErrorReporter);
    1: 
    1:   return NS_OK;
    1: }
    1: 
48477: nsresult
48503: nsJSContext::CreateOuterObject(nsIScriptGlobalObject *aGlobalObject,
51078:                                nsIScriptGlobalObject *aCurrentInner)
48477: {
55583:   mGlobalObjectRef = aGlobalObject;
55583: 
    1:   nsCOMPtr<nsIDOMChromeWindow> chromeWindow(do_QueryInterface(aGlobalObject));
    1:   PRUint32 flags = 0;
    1: 
    1:   if (chromeWindow) {
 7987:     // Flag this window's global object and objects under it as "system",
 7987:     // for optional automated XPCNativeWrapper construction when chrome JS
 7987:     // views a content DOM.
    1:     flags = nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT;
    1: 
    1:     // Always enable E4X for XUL and other chrome content -- there is no
    1:     // need to preserve the <!-- script hiding hack from JS-in-HTML daze
    1:     // (introduced in 1995 for graceful script degradation in Netscape 1,
    1:     // Mosaic, and other pre-JS browsers).
51078:     JS_SetOptions(mContext, JS_GetOptions(mContext) | JSOPTION_XML);
    1:   }
    1: 
55577:   JSObject *outer =
55577:     NS_NewOuterWindowProxy(mContext, aCurrentInner->GetGlobalJSObject());
55577:   if (!outer) {
55577:     return NS_ERROR_FAILURE;
55577:   }
55577: 
55577:   return SetOuterObject(outer);
55577: }
55577: 
55577: nsresult
55577: nsJSContext::SetOuterObject(void *aOuterObject)
55577: {
55577:   JSObject *outer = static_cast<JSObject *>(aOuterObject);
55577: 
51078:   // Force our context's global object to be the outer.
55577:   JS_SetGlobalObject(mContext, outer);
59622: 
59622:   // NB: JS_SetGlobalObject sets mContext->compartment.
59622:   JSObject *inner = JS_GetParent(mContext, outer);
59622: 
59622:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
59622:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
59622:   nsresult rv = xpc->GetWrappedNativeOfJSObject(mContext, inner,
59622:                                                 getter_AddRefs(wrapper));
59622:   NS_ENSURE_SUCCESS(rv, rv);
59622:   NS_ABORT_IF_FALSE(wrapper, "bad wrapper");
59622: 
59622:   wrapper->RefreshPrototype();
59622:   JS_SetPrototype(mContext, outer, JS_GetPrototype(mContext, inner));
59622: 
48477:   return NS_OK;
48477: }
48477: 
48477: nsresult
48477: nsJSContext::InitOuterWindow()
48477: {
48477:   JSObject *global = JS_GetGlobalObject(mContext);
55604:   OBJ_TO_INNER_OBJECT(mContext, global);
55577: 
55577:   nsresult rv = InitClasses(global); // this will complete global object initialization
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
48477:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::InitializeExternalClasses()
    1: {
 7941:   nsScriptNameSpaceManager *nameSpaceManager = nsJSRuntime::GetNameSpaceManager();
 7941:   NS_ENSURE_TRUE(nameSpaceManager, NS_ERROR_NOT_INITIALIZED);
 7941: 
 7941:   return nameSpaceManager->InitForContext(this);
    1: }
    1: 
    1: nsresult
    1: nsJSContext::SetProperty(void *aTarget, const char *aPropName, nsISupports *aArgs)
    1: {
    1:   PRUint32  argc;
    1:   jsval    *argv = nsnull;
    1: 
    1:   JSAutoRequest ar(mContext);
    1: 
37767:   js::LazilyConstructed<nsAutoPoolRelease> poolRelease;
40407:   js::LazilyConstructed<js::AutoArrayRooter> tvr;
37767: 
    1:   nsresult rv;
    1:   rv = ConvertSupportsTojsvals(aArgs, GetNativeGlobal(), &argc,
37767:                                &argv, poolRelease, tvr);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4040:   jsval vargs;
 4040: 
 4040:   // got the arguments, now attach them.
 4040: 
 4040:   // window.dialogArguments is supposed to be an array if a JS array
 4040:   // was passed to showModalDialog(), deal with that here.
 4123:   if (strcmp(aPropName, "dialogArguments") == 0 && argc <= 1) {
 4123:     vargs = argc ? argv[0] : JSVAL_VOID;
 4040:   } else {
55609:     for (PRUint32 i = 0; i < argc; ++i) {
55609:       if (!JS_WrapValue(mContext, &argv[i])) {
55609:         return NS_ERROR_FAILURE;
55609:       }
55609:     }
55609: 
    1:     JSObject *args = ::JS_NewArrayObject(mContext, argc, argv);
 4040:     vargs = OBJECT_TO_JSVAL(args);
 4040:   }
 4040: 
 4040:   // Make sure to use JS_DefineProperty here so that we can override
 4040:   // readonly XPConnect properties here as well (read dialogArguments).
 4040:   rv = ::JS_DefineProperty(mContext, reinterpret_cast<JSObject *>(aTarget),
 4040:                            aPropName, vargs, nsnull, nsnull, 0) ?
    1:        NS_OK : NS_ERROR_FAILURE;
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::ConvertSupportsTojsvals(nsISupports *aArgs,
    1:                                      void *aScope,
37767:                                      PRUint32 *aArgc,
37767:                                      jsval **aArgv,
37767:                                      js::LazilyConstructed<nsAutoPoolRelease> &aPoolRelease,
40407:                                      js::LazilyConstructed<js::AutoArrayRooter> &aRooter)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // If the array implements nsIJSArgArray, just grab the values directly.
    1:   nsCOMPtr<nsIJSArgArray> fastArray = do_QueryInterface(aArgs);
37767:   if (fastArray != nsnull)
37767:     return fastArray->GetArgs(aArgc, reinterpret_cast<void **>(aArgv));
37767: 
    1:   // Take the slower path converting each item.
    1:   // Handle only nsIArray and nsIVariant.  nsIArray is only needed for
    1:   // SetProperty('arguments', ...);
    1: 
    1:   *aArgv = nsnull;
    1:   *aArgc = 0;
    1: 
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   NS_ENSURE_TRUE(xpc, NS_ERROR_UNEXPECTED);
    1: 
    1:   if (!aArgs)
    1:     return NS_OK;
    1:   PRUint32 argCtr, argCount;
    1:   // This general purpose function may need to convert an arg array
    1:   // (window.arguments, event-handler args) and a generic property.
    1:   nsCOMPtr<nsIArray> argsArray(do_QueryInterface(aArgs));
    1: 
    1:   if (argsArray) {
    1:     rv = argsArray->GetLength(&argCount);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (argCount == 0)
    1:       return NS_OK;
    1:   } else {
    1:     argCount = 1; // the nsISupports which is not an array
    1:   }
    1: 
37767:   void *mark = JS_ARENA_MARK(&mContext->tempPool);
37767:   jsval *argv;
38213:   size_t nbytes = argCount * sizeof(jsval);
38213:   JS_ARENA_ALLOCATE_CAST(argv, jsval *, &mContext->tempPool, nbytes);
    1:   NS_ENSURE_TRUE(argv, NS_ERROR_OUT_OF_MEMORY);
38213:   memset(argv, 0, nbytes);  /* initialize so GC-able */
38213: 
38213:   // Use the caller's auto guards to release and unroot.
37767:   aPoolRelease.construct(&mContext->tempPool, mark);
37767:   aRooter.construct(mContext, argCount, argv);
37767: 
    1:   if (argsArray) {
    1:     for (argCtr = 0; argCtr < argCount && NS_SUCCEEDED(rv); argCtr++) {
    1:       nsCOMPtr<nsISupports> arg;
    1:       jsval *thisval = argv + argCtr;
    1:       argsArray->QueryElementAt(argCtr, NS_GET_IID(nsISupports),
    1:                                 getter_AddRefs(arg));
    1:       if (!arg) {
    1:         *thisval = JSVAL_NULL;
    1:         continue;
    1:       }
    1:       nsCOMPtr<nsIVariant> variant(do_QueryInterface(arg));
    1:       if (variant != nsnull) {
    1:         rv = xpc->VariantToJS(mContext, (JSObject *)aScope, variant,
    1:                               thisval);
    1:       } else {
    1:         // And finally, support the nsISupportsPrimitives supplied
    1:         // by the AppShell.  It generally will pass only strings, but
    1:         // as we have code for handling all, we may as well use it.
    1:         rv = AddSupportsPrimitiveTojsvals(arg, thisval);
    1:         if (rv == NS_ERROR_NO_INTERFACE) {
 4040:           // something else - probably an event object or similar -
    1:           // just wrap it.
    1: #ifdef NS_DEBUG
    1:           // but first, check its not another nsISupportsPrimitive, as
    1:           // these are now deprecated for use with script contexts.
    1:           nsCOMPtr<nsISupportsPrimitive> prim(do_QueryInterface(arg));
    1:           NS_ASSERTION(prim == nsnull,
    1:                        "Don't pass nsISupportsPrimitives - use nsIVariant!");
    1: #endif
    1:           nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
31981:           jsval v;
31981:           rv = nsContentUtils::WrapNative(mContext, (JSObject *)aScope, arg,
31981:                                           &v, getter_AddRefs(wrapper));
    1:           if (NS_SUCCEEDED(rv)) {
31981:             *thisval = v;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   } else {
    1:     nsCOMPtr<nsIVariant> variant(do_QueryInterface(aArgs));
    1:     if (variant)
    1:       rv = xpc->VariantToJS(mContext, (JSObject *)aScope, variant, argv);
    1:     else {
    1:       NS_ERROR("Not an array, not an interface?");
    1:       rv = NS_ERROR_UNEXPECTED;
    1:     }
    1:   }
37767:   if (NS_FAILED(rv))
    1:     return rv;
    1:   *aArgv = argv;
    1:   *aArgc = argCount;
    1:   return NS_OK;
    1: }
    1: 
    1: // This really should go into xpconnect somewhere...
    1: nsresult
    1: nsJSContext::AddSupportsPrimitiveTojsvals(nsISupports *aArg, jsval *aArgv)
    1: {
    1:   NS_PRECONDITION(aArg, "Empty arg");
    1: 
    1:   nsCOMPtr<nsISupportsPrimitive> argPrimitive(do_QueryInterface(aArg));
    1:   if (!argPrimitive)
    1:     return NS_ERROR_NO_INTERFACE;
    1: 
    1:   JSContext *cx = mContext;
    1:   PRUint16 type;
    1:   argPrimitive->GetType(&type);
    1: 
    1:   switch(type) {
    1:     case nsISupportsPrimitive::TYPE_CSTRING : {
    1:       nsCOMPtr<nsISupportsCString> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsCAutoString data;
    1: 
    1:       p->GetData(data);
    1: 
    1: 
    1:       JSString *str = ::JS_NewStringCopyN(cx, data.get(), data.Length());
    1:       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       *aArgv = STRING_TO_JSVAL(str);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_STRING : {
    1:       nsCOMPtr<nsISupportsString> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsAutoString data;
    1: 
    1:       p->GetData(data);
    1: 
    1:       // cast is probably safe since wchar_t and jschar are expected
    1:       // to be equivalent; both unsigned 16-bit entities
    1:       JSString *str =
    1:         ::JS_NewUCStringCopyN(cx,
 3233:                               reinterpret_cast<const jschar *>(data.get()),
    1:                               data.Length());
    1:       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       *aArgv = STRING_TO_JSVAL(str);
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRBOOL : {
    1:       nsCOMPtr<nsISupportsPRBool> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRBool data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = BOOLEAN_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRUINT8 : {
    1:       nsCOMPtr<nsISupportsPRUint8> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRUint8 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRUINT16 : {
    1:       nsCOMPtr<nsISupportsPRUint16> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRUint16 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRUINT32 : {
    1:       nsCOMPtr<nsISupportsPRUint32> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRUint32 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_CHAR : {
    1:       nsCOMPtr<nsISupportsChar> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       char data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       JSString *str = ::JS_NewStringCopyN(cx, &data, 1);
    1:       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       *aArgv = STRING_TO_JSVAL(str);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRINT16 : {
    1:       nsCOMPtr<nsISupportsPRInt16> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRInt16 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRINT32 : {
    1:       nsCOMPtr<nsISupportsPRInt32> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRInt32 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_FLOAT : {
    1:       nsCOMPtr<nsISupportsFloat> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       float data;
    1: 
    1:       p->GetData(&data);
    1: 
16094:       JSBool ok = ::JS_NewNumberValue(cx, data, aArgv);
16094:       NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_DOUBLE : {
    1:       nsCOMPtr<nsISupportsDouble> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       double data;
    1: 
    1:       p->GetData(&data);
    1: 
16094:       JSBool ok = ::JS_NewNumberValue(cx, data, aArgv);
16094:       NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_INTERFACE_POINTER : {
    1:       nsCOMPtr<nsISupportsInterfacePointer> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsCOMPtr<nsISupports> data;
    1:       nsIID *iid = nsnull;
    1: 
    1:       p->GetData(getter_AddRefs(data));
    1:       p->GetDataIID(&iid);
    1:       NS_ENSURE_TRUE(iid, NS_ERROR_UNEXPECTED);
    1: 
    1:       AutoFree iidGuard(iid); // Free iid upon destruction.
    1: 
31981:       nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
31981:       jsval v;
31981:       nsresult rv = nsContentUtils::WrapNative(cx, ::JS_GetGlobalObject(cx),
31981:                                                data, iid, &v,
31981:                                                getter_AddRefs(wrapper));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
31981:       *aArgv = v;
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_ID :
    1:     case nsISupportsPrimitive::TYPE_PRUINT64 :
    1:     case nsISupportsPrimitive::TYPE_PRINT64 :
    1:     case nsISupportsPrimitive::TYPE_PRTIME :
    1:     case nsISupportsPrimitive::TYPE_VOID : {
    1:       NS_WARNING("Unsupported primitive type used");
    1:       *aArgv = JSVAL_NULL;
    1:       break;
    1:     }
    1:     default : {
    1:       NS_WARNING("Unknown primitive type used");
    1:       *aArgv = JSVAL_NULL;
    1:       break;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef NS_TRACE_MALLOC
    1: 
    1: #include <errno.h>              // XXX assume Linux if NS_TRACE_MALLOC
    1: #include <fcntl.h>
    1: #ifdef XP_UNIX
    1: #include <unistd.h>
    1: #endif
    1: #ifdef XP_WIN32
    1: #include <io.h>
    1: #endif
    1: #include "nsTraceMalloc.h"
    1: 
    1: static JSBool
55983: CheckUniversalXPConnectForTraceMalloc(JSContext *cx)
55983: {
55983:     PRBool hasCap = PR_FALSE;
55983:     nsresult rv = nsContentUtils::GetSecurityManager()->
55983:                     IsCapabilityEnabled("UniversalXPConnect", &hasCap);
55983:     if (NS_SUCCEEDED(rv) && hasCap)
55983:         return JS_TRUE;
55983:     JS_ReportError(cx, "trace-malloc functions require UniversalXPConnect");
55983:     return JS_FALSE;
55983: }
55983: 
55983: static JSBool
53557: TraceMallocDisable(JSContext *cx, uintN argc, jsval *vp)
    1: {
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
    1:     NS_TraceMallocDisable();
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: TraceMallocEnable(JSContext *cx, uintN argc, jsval *vp)
    1: {
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
    1:     NS_TraceMallocEnable();
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: TraceMallocOpenLogFile(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     int fd;
    1:     JSString *str;
    1: 
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
    1:     if (argc == 0) {
    1:         fd = -1;
    1:     } else {
53557:         str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
    1:         if (!str)
    1:             return JS_FALSE;
57812:         JSAutoByteString filename(cx, str);
57812:         if (!filename)
57812:             return JS_FALSE;
57812:         fd = open(filename.ptr(), O_CREAT | O_WRONLY | O_TRUNC, 0644);
    1:         if (fd < 0) {
57812:             JS_ReportError(cx, "can't open %s: %s", filename.ptr(), strerror(errno));
    1:             return JS_FALSE;
    1:         }
    1:     }
53557:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(fd));
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: TraceMallocChangeLogFD(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     int32 fd, oldfd;
    1: 
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
    1:     if (argc == 0) {
    1:         oldfd = -1;
    1:     } else {
53557:         if (!JS_ValueToECMAInt32(cx, JS_ARGV(cx, vp)[0], &fd))
    1:             return JS_FALSE;
    1:         oldfd = NS_TraceMallocChangeLogFD(fd);
    1:         if (oldfd == -2) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return JS_FALSE;
    1:         }
    1:     }
53557:     JS_SET_RVAL(cx, vp, INT_TO_JSVAL(oldfd));
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: TraceMallocCloseLogFD(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     int32 fd;
    1: 
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
    1:     if (argc == 0)
    1:         return JS_TRUE;
53557:     if (!JS_ValueToECMAInt32(cx, JS_ARGV(cx, vp)[0], &fd))
    1:         return JS_FALSE;
    1:     NS_TraceMallocCloseLogFD((int) fd);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: TraceMallocLogTimestamp(JSContext *cx, uintN argc, jsval *vp)
    1: {
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
57812:     JSString *str = JS_ValueToString(cx, argc ? JS_ARGV(cx, vp)[0] : JSVAL_VOID);
    1:     if (!str)
    1:         return JS_FALSE;
57812:     JSAutoByteString caption(cx, str);
57812:     if (!caption)
57812:         return JS_FALSE;
57812:     NS_TraceMallocLogTimestamp(caption.ptr());
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: TraceMallocDumpAllocations(JSContext *cx, uintN argc, jsval *vp)
    1: {
55983:     if (!CheckUniversalXPConnectForTraceMalloc(cx))
55983:         return JS_FALSE;
55983: 
57812:     JSString *str = JS_ValueToString(cx, argc ? JS_ARGV(cx, vp)[0] : JSVAL_VOID);
    1:     if (!str)
    1:         return JS_FALSE;
57812:     JSAutoByteString pathname(cx, str);
57812:     if (!pathname)
57812:         return JS_FALSE;
57812:     if (NS_TraceMallocDumpAllocations(pathname.ptr()) < 0) {
57812:         JS_ReportError(cx, "can't dump to %s: %s", pathname.ptr(), strerror(errno));
    1:         return JS_FALSE;
    1:     }
53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSFunctionSpec TraceMallocFunctions[] = {
53557:     {"TraceMallocDisable",         TraceMallocDisable,         0, 0},
53557:     {"TraceMallocEnable",          TraceMallocEnable,          0, 0},
53557:     {"TraceMallocOpenLogFile",     TraceMallocOpenLogFile,     1, 0},
53557:     {"TraceMallocChangeLogFD",     TraceMallocChangeLogFD,     1, 0},
53557:     {"TraceMallocCloseLogFD",      TraceMallocCloseLogFD,      1, 0},
53557:     {"TraceMallocLogTimestamp",    TraceMallocLogTimestamp,    1, 0},
53557:     {"TraceMallocDumpAllocations", TraceMallocDumpAllocations, 1, 0},
53557:     {nsnull,                       nsnull,                     0, 0}
    1: };
    1: 
    1: #endif /* NS_TRACE_MALLOC */
    1: 
    1: #ifdef MOZ_JPROF
    1: 
    1: #include <signal.h>
    1: 
    1: inline PRBool
    1: IsJProfAction(struct sigaction *action)
    1: {
    1:     return (action->sa_sigaction &&
18876:             action->sa_flags == (SA_RESTART | SA_SIGINFO));
    1: }
    1: 
    1: void NS_JProfStartProfiling();
    1: void NS_JProfStopProfiling();
    1: 
    1: static JSBool
53646: JProfStartProfilingJS(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:   NS_JProfStartProfiling();
    1:   return JS_TRUE;
    1: }
    1: 
    1: void NS_JProfStartProfiling()
    1: {
    1:     // Figure out whether we're dealing with SIGPROF, SIGALRM, or
    1:     // SIGPOLL profiling (SIGALRM for JP_REALTIME, SIGPOLL for
    1:     // JP_RTC_HZ)
    1:     struct sigaction action;
    1: 
    1:     sigaction(SIGALRM, nsnull, &action);
    1:     if (IsJProfAction(&action)) {
    1:         printf("Beginning real-time jprof profiling.\n");
    1:         raise(SIGALRM);
    1:         return;
    1:     }
    1: 
    1:     sigaction(SIGPROF, nsnull, &action);
    1:     if (IsJProfAction(&action)) {
    1:         printf("Beginning process-time jprof profiling.\n");
    1:         raise(SIGPROF);
    1:         return;
    1:     }
    1: 
    1:     sigaction(SIGPOLL, nsnull, &action);
    1:     if (IsJProfAction(&action)) {
    1:         printf("Beginning rtc-based jprof profiling.\n");
    1:         raise(SIGPOLL);
    1:         return;
    1:     }
    1: 
    1:     printf("Could not start jprof-profiling since JPROF_FLAGS was not set.\n");
    1: }
    1: 
    1: static JSBool
53646: JProfStopProfilingJS(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:   NS_JProfStopProfiling();
    1:   return JS_TRUE;
    1: }
    1: 
    1: void
    1: NS_JProfStopProfiling()
    1: {
    1:     raise(SIGUSR1);
    1:     printf("Stopped jprof profiling.\n");
    1: }
    1: 
    1: static JSFunctionSpec JProfFunctions[] = {
53644:     {"JProfStartProfiling",        JProfStartProfilingJS,      0, 0},
53644:     {"JProfStopProfiling",         JProfStopProfilingJS,       0, 0},
53644:     {nsnull,                       nsnull,                     0, 0}
    1: };
    1: 
    1: #endif /* defined(MOZ_JPROF) */
    1: 
15763: #ifdef MOZ_CALLGRIND
15763: static JSFunctionSpec CallgrindFunctions[] = {
53644:     {"startCallgrind",             js_StartCallgrind,          0, 0},
53644:     {"stopCallgrind",              js_StopCallgrind,           0, 0},
53644:     {"dumpCallgrind",              js_DumpCallgrind,           1, 0},
53644:     {nsnull,                       nsnull,                     0, 0}
15763: };
15763: #endif
15763: 
16288: #ifdef MOZ_VTUNE
16288: static JSFunctionSpec VtuneFunctions[] = {
53644:     {"startVtune",                 js_StartVtune,              1, 0},
53644:     {"stopVtune",                  js_StopVtune,               0, 0},
53644:     {"pauseVtune",                 js_PauseVtune,              0, 0},
53644:     {"resumeVtune",                js_ResumeVtune,             0, 0},
53644:     {nsnull,                       nsnull,                     0, 0}
16288: };
16288: #endif
16288: 
31063: #ifdef MOZ_TRACEVIS
31063: static JSFunctionSpec EthogramFunctions[] = {
53644:     {"initEthogram",               js_InitEthogram,            0, 0},
53644:     {"shutdownEthogram",           js_ShutdownEthogram,        0, 0},
53644:     {nsnull,                       nsnull,                     0, 0}
31063: };
31063: #endif
31063: 
    1: nsresult
    1: nsJSContext::InitClasses(void *aGlobalObj)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
 3233:   JSObject *globalObj = static_cast<JSObject *>(aGlobalObj);
    1: 
    1:   rv = InitializeExternalClasses();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   JSAutoRequest ar(mContext);
    1: 
    1:   ::JS_SetOptions(mContext, mDefaultJSOptions);
    1: 
60787:   // Attempt to initialize profiling functions
60787:   ::JS_DefineProfilingFunctions(mContext, globalObj);
60787: 
    1: #ifdef NS_TRACE_MALLOC
    1:   // Attempt to initialize TraceMalloc functions
    1:   ::JS_DefineFunctions(mContext, globalObj, TraceMallocFunctions);
    1: #endif
    1: 
    1: #ifdef MOZ_JPROF
    1:   // Attempt to initialize JProf functions
    1:   ::JS_DefineFunctions(mContext, globalObj, JProfFunctions);
    1: #endif
    1: 
15763: #ifdef MOZ_CALLGRIND
15763:   // Attempt to initialize Callgrind functions
15763:   ::JS_DefineFunctions(mContext, globalObj, CallgrindFunctions);
15763: #endif
15763: 
16288: #ifdef MOZ_VTUNE
16288:   // Attempt to initialize Vtune functions
16288:   ::JS_DefineFunctions(mContext, globalObj, VtuneFunctions);
16288: #endif
16288: 
31063: #ifdef MOZ_TRACEVIS
31063:   // Attempt to initialize Ethogram functions
31063:   ::JS_DefineFunctions(mContext, globalObj, EthogramFunctions);
31063: #endif
31063: 
 3289:   JSOptionChangedCallback(js_options_dot_str, this);
 3289: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsJSContext::ClearScope(void *aGlobalObj, PRBool aClearFromProtoChain)
    1: {
12050:   // Push our JSContext on our thread's context stack.
12050:   nsCOMPtr<nsIJSContextStack> stack =
12050:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
12050:   if (stack && NS_FAILED(stack->Push(mContext))) {
12050:     stack = nsnull;
12050:   }
12050: 
    1:   if (aGlobalObj) {
    1:     JSObject *obj = (JSObject *)aGlobalObj;
    1:     JSAutoRequest ar(mContext);
55601: 
55601:     JSAutoEnterCompartment ac;
55601:     ac.enterAndIgnoreErrors(mContext, obj);
55601: 
58522:     // Grab a reference to the window property, which is the outer
58522:     // window, so that we can re-define it once we've cleared
58522:     // scope. This is what keeps the outer window alive in cases where
58522:     // nothing else does.
58522:     jsval window;
58522:     if (!JS_GetProperty(mContext, obj, "window", &window)) {
58522:       window = JSVAL_VOID;
58522: 
58522:       JS_ClearPendingException(mContext);
58522:     }
58522: 
53858:     JS_ClearScope(mContext, obj);
62046: 
62643:     NS_ABORT_IF_FALSE(!xpc::WrapperFactory::IsXrayWrapper(obj), "unexpected wrapper");
58522: 
58522:     if (window != JSVAL_VOID) {
58522:       if (!JS_DefineProperty(mContext, obj, "window", window,
62397:                              JS_PropertyStub, JS_StrictPropertyStub,
58522:                              JSPROP_ENUMERATE | JSPROP_READONLY |
58522:                              JSPROP_PERMANENT)) {
58522:         JS_ClearPendingException(mContext);
58522:       }
58522:     }
58522: 
53858:     if (!obj->getParent()) {
53858:       JS_ClearRegExpStatics(mContext, obj);
53858:     }
    1: 
    1:     // Always clear watchpoints, to deal with two cases:
    1:     // 1.  The first document for this window is loading, and a miscreant has
    1:     //     preset watchpoints on the window object in order to attack the new
    1:     //     document's privileged information.
    1:     // 2.  A document loaded and used watchpoints on its own window, leaving
    1:     //     them set until the next document loads. We must clean up window
    1:     //     watchpoints here.
    1:     // Watchpoints set on document and subordinate objects are all cleared
    1:     // when those sub-window objects are finalized, after JS_ClearScope and
    1:     // a GC run that finds them to be garbage.
    1:     ::JS_ClearWatchPointsForObject(mContext, obj);
    1: 
    1:     // Since the prototype chain is shared between inner and outer (and
    1:     // stays with the inner), we don't clear things from the prototype
    1:     // chain when we're clearing an outer window whose current inner we
    1:     // still want.
    1:     if (aClearFromProtoChain) {
55578:       nsWindowSH::InvalidateGlobalScopePolluter(mContext, obj);
    1: 
    1:       // Clear up obj's prototype chain, but not Object.prototype.
    1:       for (JSObject *o = ::JS_GetPrototype(mContext, obj), *next;
    1:            o && (next = ::JS_GetPrototype(mContext, o)); o = next)
    1:         ::JS_ClearScope(mContext, o);
    1:     }
    1:   }
12050: 
12050:   if (stack) {
12050:     stack->Pop(nsnull);
12050:   }
    1: }
    1: 
    1: void
    1: nsJSContext::WillInitializeContext()
    1: {
    1:   mIsInitialized = PR_FALSE;
    1: }
    1: 
    1: void
    1: nsJSContext::DidInitializeContext()
    1: {
    1:   mIsInitialized = PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsJSContext::IsContextInitialized()
    1: {
    1:   return mIsInitialized;
    1: }
    1: 
    1: void
    1: nsJSContext::FinalizeContext()
    1: {
    1:   ;
    1: }
    1: 
    1: void
    1: nsJSContext::ScriptEvaluated(PRBool aTerminated)
    1: {
    1:   if (aTerminated && mTerminations) {
    1:     // Make sure to null out mTerminations before doing anything that
    1:     // might cause new termination funcs to be added!
    1:     nsJSContext::TerminationFuncClosure* start = mTerminations;
    1:     mTerminations = nsnull;
    1: 
    1:     for (nsJSContext::TerminationFuncClosure* cur = start;
    1:          cur;
    1:          cur = cur->mNext) {
    1:       (*(cur->mTerminationFunc))(cur->mTerminationFuncArg);
    1:     }
    1:     delete start;
    1:   }
    1: 
60258:   JS_MaybeGC(mContext);
21973: 
21973:   if (aTerminated) {
29105:     mOperationCallbackTime = 0;
29105:     mModalStateTime = 0;
    1:   }
21973: }
    1: 
    1: nsresult
    1: nsJSContext::SetTerminationFunction(nsScriptTerminationFunc aFunc,
    1:                                     nsISupports* aRef)
    1: {
61409:   NS_PRECONDITION(GetExecutingScript(), "should be executing script");
    1: 
    1:   nsJSContext::TerminationFuncClosure* newClosure =
    1:     new nsJSContext::TerminationFuncClosure(aFunc, aRef, mTerminations);
    1:   if (!newClosure) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   mTerminations = newClosure;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsJSContext::GetScriptsEnabled()
    1: {
    1:   return mScriptsEnabled;
    1: }
    1: 
    1: void
    1: nsJSContext::SetScriptsEnabled(PRBool aEnabled, PRBool aFireTimeouts)
    1: {
    1:   // eeek - this seems the wrong way around - the global should callback
    1:   // into each context, so every language is disabled.
    1:   mScriptsEnabled = aEnabled;
    1: 
    1:   nsIScriptGlobalObject *global = GetGlobalObject();
    1: 
    1:   if (global) {
    1:     global->SetScriptsEnabled(aEnabled, aFireTimeouts);
    1:   }
    1: }
    1: 
    1: 
    1: PRBool
    1: nsJSContext::GetProcessingScriptTag()
    1: {
    1:   return mProcessingScriptTag;
    1: }
    1: 
    1: void
    1: nsJSContext::SetProcessingScriptTag(PRBool aFlag)
    1: {
    1:   mProcessingScriptTag = aFlag;
    1: }
    1: 
35152: PRBool
35152: nsJSContext::GetExecutingScript()
35152: {
35152:   return JS_IsRunning(mContext) || mExecuteDepth > 0;
35152: }
35152: 
    1: void
    1: nsJSContext::SetGCOnDestruction(PRBool aGCOnDestruction)
    1: {
    1:   mGCOnDestruction = aGCOnDestruction;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJSContext::ScriptExecuted()
    1: {
12523:   ScriptEvaluated(!::JS_IsRunning(mContext));
    1: 
    1:   return NS_OK;
    1: }
    1: 
 7093: //static
 7093: void
62725: nsJSContext::GarbageCollectNow()
 7093: {
42480:   NS_TIME_FUNCTION_MIN(1.0);
42480: 
62725:   KillGCTimer();
    1: 
    1:   // Reset sPendingLoadCount in case the timer that fired was a
    1:   // timer we scheduled due to a normal GC timer firing while
    1:   // documents were loading. If this happens we're waiting for a
    1:   // document that is taking a long time to load, and we effectively
    1:   // ignore the fact that the currently loading documents are still
    1:   // loading and move on as if they weren't.
    1:   sPendingLoadCount = 0;
62725:   sLoadingInProgress = PR_FALSE;
62725: 
62945:   if (nsContentUtils::XPConnect()) {
62725:     nsContentUtils::XPConnect()->GarbageCollect();
62725:   }
62945: }
62725: 
62725: //Static
62725: void
62725: nsJSContext::CycleCollectNow(nsICycleCollectorListener *aListener)
62725: {
62725:   if (!NS_IsMainThread()) {
62725:     return;
62725:   }
62725: 
62725:   NS_TIME_FUNCTION_MIN(1.0);
62725: 
62725:   KillCCTimer();
62725: 
62725:   PRTime start = PR_Now();
62725: 
62725:   PRUint32 suspected = nsCycleCollector_suspectedCount();
62725:   PRUint32 collected = nsCycleCollector_collect(aListener);
62725: 
62725:   // If we collected cycles, poke the GC since more objects might be unreachable now.
62725:   if (collected > 0) {
62725:     PokeGC();
62725:   }
62725: 
62725:   if (sPostGCEventsToConsole) {
62725:     PRTime now = PR_Now();
62725:     NS_NAMED_LITERAL_STRING(kFmt,
62725:                             "CC timestamp: %lld, collected: %lu, suspected: %lu, duration: %llu ms.");
62725:     nsString msg;
62725:     msg.Adopt(nsTextFormatter::smprintf(kFmt.get(), now,
62725:                                         collected, suspected,
62725:                                         (now - start) / PR_USEC_PER_MSEC));
62725:     nsCOMPtr<nsIConsoleService> cs =
62725:       do_GetService(NS_CONSOLESERVICE_CONTRACTID);
62725:     if (cs) {
62725:       cs->LogStringMessage(msg.get());
62725:     }
62725:   }
62725: }
62725: 
62725: // static
62725: void
62725: GCTimerFired(nsITimer *aTimer, void *aClosure)
62725: {
62725:   NS_RELEASE(sGCTimer);
62725: 
62725:   nsJSContext::GarbageCollectNow();
62725: }
62725: 
62725: // static
62725: void
62725: CCTimerFired(nsITimer *aTimer, void *aClosure)
62725: {
62725:   NS_RELEASE(sCCTimer);
62725: 
62725:   nsJSContext::CycleCollectNow();
    1: }
    1: 
    1: // static
    1: void
    1: nsJSContext::LoadStart()
    1: {
62725:   sLoadingInProgress = PR_TRUE;
    1:   ++sPendingLoadCount;
    1: }
    1: 
    1: // static
    1: void
 7080: nsJSContext::LoadEnd()
    1: {
62725:   if (!sLoadingInProgress)
62725:     return;
62725: 
    1:   // sPendingLoadCount is not a well managed load counter (and doesn't
    1:   // need to be), so make sure we don't make it wrap backwards here.
    1:   if (sPendingLoadCount > 0) {
    1:     --sPendingLoadCount;
62725:     return;
62725:   }
62725: 
62725:   // Its probably a good idea to GC soon since we have finished loading.
62725:   sLoadingInProgress = PR_FALSE;
62725:   PokeGC();
    1: }
    1: 
24951: // static
    1: void
62725: nsJSContext::PokeGC()
    1: {
    1:   if (sGCTimer) {
    1:     // There's already a timer for GC'ing, just return
    1:     return;
    1:   }
    1: 
    1:   CallCreateInstance("@mozilla.org/timer;1", &sGCTimer);
    1: 
    1:   if (!sGCTimer) {
    1:     NS_WARNING("Failed to create timer");
    1:     return;
    1:   }
    1: 
    1:   static PRBool first = PR_TRUE;
    1: 
24951:   sGCTimer->InitWithFuncCallback(GCTimerFired, nsnull,
62725:                                  first
62725:                                  ? NS_FIRST_GC_DELAY
62725:                                  : NS_GC_DELAY,
    1:                                  nsITimer::TYPE_ONE_SHOT);
    1: 
    1:   first = PR_FALSE;
    1: }
    1: 
62725: // static
62725: void
62725: nsJSContext::MaybePokeCC()
62725: {
62725:   if (nsCycleCollector_suspectedCount() > 1000) {
62725:     PokeCC();
62725:   }
62725: }
62725: 
62725: // static
62725: void
62725: nsJSContext::PokeCC()
62725: {
63086:   if (sCCTimer || !sGCHasRun) {
63086:     // There's already a timer for GC'ing, or GC hasn't run yet, just return.
62725:     return;
62725:   }
62725: 
62725:   CallCreateInstance("@mozilla.org/timer;1", &sCCTimer);
62725: 
62725:   if (!sCCTimer) {
62725:     NS_WARNING("Failed to create timer");
62725:     return;
62725:   }
62725: 
62725:   sCCTimer->InitWithFuncCallback(CCTimerFired, nsnull,
62725:                                  NS_CC_DELAY,
62725:                                  nsITimer::TYPE_ONE_SHOT);
62725: }
62725: 
62725: //static
62725: void
62725: nsJSContext::KillGCTimer()
62725: {
62725:   if (sGCTimer) {
62725:     sGCTimer->Cancel();
62725: 
62725:     NS_RELEASE(sGCTimer);
62725:   }
62725: }
62725: 
62725: //static
62725: void
62725: nsJSContext::KillCCTimer()
62725: {
62725:   if (sCCTimer) {
62725:     sCCTimer->Cancel();
62725: 
62725:     NS_RELEASE(sCCTimer);
62725:   }
62725: }
62725: 
62725: void
62725: nsJSContext::GC()
62725: {
62725:   PokeGC();
62725: }
62725: 
18907: static JSBool
    1: DOMGCCallback(JSContext *cx, JSGCStatus status)
    1: {
62725:   static PRTime start;
62725: 
62725:   if (sPostGCEventsToConsole && NS_IsMainThread()) {
62725:     if (status == JSGC_BEGIN) {
62725:       start = PR_Now();
62725:     } else if (status == JSGC_END) {
62725:       PRTime now = PR_Now();
62725:       NS_NAMED_LITERAL_STRING(kFmt, "GC timestamp: %lld, duration: %llu ms.");
62725:       nsString msg;
62725:       msg.Adopt(nsTextFormatter::smprintf(kFmt.get(), now,
62725:                 (now - start) / PR_USEC_PER_MSEC));
62725:       nsCOMPtr<nsIConsoleService> cs = do_GetService(NS_CONSOLESERVICE_CONTRACTID);
62725:       if (cs) {
62725:         cs->LogStringMessage(msg.get());
62725:       }
62725:     }
62725:   }
62725: 
62725:   if (status == JSGC_END) {
62725:     if (sGCTimer) {
62725:       // If we were waiting for a GC to happen, kill the timer.
62725:       nsJSContext::KillGCTimer();
62725: 
62725:       // If this is a compartment GC, restart it. We still want
62725:       // a full GC to happen. Compartment GCs usually happen as a
62725:       // result of last-ditch or MaybeGC. In both cases its
62725:       // probably a time of heavy activity and we want to delay
62725:       // the full GC, but we do want it to happen eventually.
62725:       if (cx->runtime->gcTriggerCompartment) {
62725:         nsJSContext::PokeGC();
62725: 
62725:         // We poked the GC, so we can kill any pending CC here.
62725:         nsJSContext::KillCCTimer();
62725:       }
62725:     } else {
62725:       // If this was a full GC, poke the CC to run soon.
62725:       if (!cx->runtime->gcTriggerCompartment) {
63086:         sGCHasRun = true;
62725:         nsJSContext::PokeCC();
62725:       }
62725:     }
62964: 
62964:     // If we didn't end up scheduling a GC, and there are unused
62964:     // chunks waiting to expire, make sure we will GC again soon.
62964:     if (!sGCTimer && JS_GetGCParameter(cx->runtime, JSGC_UNUSED_CHUNKS) > 0) {
62964:       nsJSContext::PokeGC();
62964:     }
62725:   }
62725: 
    1:   JSBool result = gOldJSGCCallback ? gOldJSGCCallback(cx, status) : JS_TRUE;
    1: 
    1:   if (status == JSGC_BEGIN && !NS_IsMainThread())
    1:     return JS_FALSE;
    1: 
    1:   return result;
    1: }
    1: 
    1: // Script object mananagement - note duplicate implementation
    1: // in nsJSRuntime below...
    1: nsresult
    1: nsJSContext::HoldScriptObject(void* aScriptObject)
    1: {
    1:     NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:     if (! nsJSRuntime::sRuntime) {
    1:         NS_NOTREACHED("couldn't add GC root - no runtime");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     ::JS_LockGCThingRT(nsJSRuntime::sRuntime, aScriptObject);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::DropScriptObject(void* aScriptObject)
    1: {
    1:   NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:   if (! nsJSRuntime::sRuntime) {
    1:     NS_NOTREACHED("couldn't remove GC root");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   ::JS_UnlockGCThingRT(nsJSRuntime::sRuntime, aScriptObject);
    1:   return NS_OK;
    1: }
    1: 
13341: void
28612: nsJSContext::ReportPendingException()
13341: {
28612:   // set aside the frame chain, since it has nothing to do with the
28612:   // exception we're reporting.
13341:   if (mIsInitialized && ::JS_IsExceptionPending(mContext)) {
28612:     JSStackFrame* frame = JS_SaveFrameChain(mContext);
13341:     ::JS_ReportPendingException(mContext);
22751:     JS_RestoreFrameChain(mContext, frame);
22751:   }
13341: }
13341: 
    1: /**********************************************************************
    1:  * nsJSRuntime implementation
    1:  *********************************************************************/
    1: 
    1: // QueryInterface implementation for nsJSRuntime
    1: NS_INTERFACE_MAP_BEGIN(nsJSRuntime)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScriptRuntime)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsJSRuntime)
    1: NS_IMPL_RELEASE(nsJSRuntime)
    1: 
    1: nsresult
    1: nsJSRuntime::CreateContext(nsIScriptContext **aContext)
    1: {
    1:   nsCOMPtr<nsIScriptContext> scriptContext;
    1: 
    1:   *aContext = new nsJSContext(sRuntime);
    1:   NS_ENSURE_TRUE(*aContext, NS_ERROR_OUT_OF_MEMORY);
    1:   NS_ADDREF(*aContext);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSRuntime::ParseVersion(const nsString &aVersionStr, PRUint32 *flags)
    1: {
    1:     NS_PRECONDITION(flags, "Null flags param?");
    1:     JSVersion jsVersion = JSVERSION_UNKNOWN;
    1:     if (aVersionStr.Length() != 3 || aVersionStr[0] != '1' || aVersionStr[1] != '.')
    1:         jsVersion = JSVERSION_UNKNOWN;
    1:     else switch (aVersionStr[2]) {
    1:         case '0': jsVersion = JSVERSION_1_0; break;
    1:         case '1': jsVersion = JSVERSION_1_1; break;
    1:         case '2': jsVersion = JSVERSION_1_2; break;
    1:         case '3': jsVersion = JSVERSION_1_3; break;
    1:         case '4': jsVersion = JSVERSION_1_4; break;
    1:         case '5': jsVersion = JSVERSION_1_5; break;
    1:         case '6': jsVersion = JSVERSION_1_6; break;
    1:         case '7': jsVersion = JSVERSION_1_7; break;
 1981:         case '8': jsVersion = JSVERSION_1_8; break;
    1:         default:  jsVersion = JSVERSION_UNKNOWN;
    1:     }
    1:     *flags = (PRUint32)jsVersion;
    1:     return NS_OK;
    1: }
    1: 
    1: //static
    1: void
    1: nsJSRuntime::Startup()
    1: {
    1:   // initialize all our statics, so that we can restart XPCOM
62725:   sGCTimer = sCCTimer = nsnull;
63086:   sGCHasRun = false;
    1:   sPendingLoadCount = 0;
62725:   sLoadingInProgress = PR_FALSE;
62725:   sPostGCEventsToConsole = PR_FALSE;
    1:   gNameSpaceManager = nsnull;
    1:   sRuntimeService = nsnull;
    1:   sRuntime = nsnull;
    1:   gOldJSGCCallback = nsnull;
    1:   sIsInitialized = PR_FALSE;
    1:   sDidShutdown = PR_FALSE;
    1:   sContextCount = 0;
    1:   sSecurityManager = nsnull;
    1: }
    1: 
20261: static int
    1: MaxScriptRunTimePrefChangedCallback(const char *aPrefName, void *aClosure)
    1: {
    1:   // Default limit on script run time to 10 seconds. 0 means let
    1:   // scripts run forever.
    1:   PRBool isChromePref =
    1:     strcmp(aPrefName, "dom.max_chrome_script_run_time") == 0;
    1:   PRInt32 time = nsContentUtils::GetIntPref(aPrefName, isChromePref ? 20 : 10);
    1: 
    1:   PRTime t;
    1:   if (time <= 0) {
    1:     // Let scripts run for a really, really long time.
    1:     t = LL_INIT(0x40000000, 0);
    1:   } else {
    1:     t = time * PR_USEC_PER_SEC;
    1:   }
    1: 
    1:   if (isChromePref) {
    1:     sMaxChromeScriptRunTime = t;
    1:   } else {
    1:     sMaxScriptRunTime = t;
    1:   }
    1: 
    1:   return 0;
    1: }
    1: 
20261: static int
14170: ReportAllJSExceptionsPrefChangedCallback(const char* aPrefName, void* aClosure)
14170: {
14170:   PRBool reportAll = nsContentUtils::GetBoolPref(aPrefName, PR_FALSE);
14170:   nsContentUtils::XPConnect()->SetReportAllJSExceptions(reportAll);
14170:   return 0;
14170: }
14170: 
30112: static int
30112: SetMemoryHighWaterMarkPrefChangedCallback(const char* aPrefName, void* aClosure)
30112: {
60056:   PRInt32 highwatermark = nsContentUtils::GetIntPref(aPrefName, 128);
60056: 
31888:   JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MAX_MALLOC_BYTES,
31888:                     highwatermark * 1024L * 1024L);
60056:   return 0;
60056: }
60056: 
60056: static int
60056: SetMemoryMaxPrefChangedCallback(const char* aPrefName, void* aClosure)
60056: {
60387:   PRInt32 pref = nsContentUtils::GetIntPref(aPrefName, -1);
60387:   // handle overflow and negative pref values
60387:   PRUint32 max = (pref <= 0 || pref >= 0x1000) ? -1 : (PRUint32)pref * 1024 * 1024;
60387:   JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MAX_BYTES, max);
31888:   return 0;
31888: }
31888: 
31888: static int
31888: SetMemoryGCFrequencyPrefChangedCallback(const char* aPrefName, void* aClosure)
31888: {
56232:   PRInt32 triggerFactor = nsContentUtils::GetIntPref(aPrefName, 300);
31888:   JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_TRIGGER_FACTOR, triggerFactor);
30112:   return 0;
30112: }
30112: 
60531: static int
60531: SetMemoryGCModePrefChangedCallback(const char* aPrefName, void* aClosure)
60531: {
60531:   PRBool enableCompartmentGC = nsContentUtils::GetBoolPref(aPrefName);
60531:   JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MODE, enableCompartmentGC
60531:                                                       ? JSGC_MODE_COMPARTMENT
60531:                                                       : JSGC_MODE_GLOBAL);
60531:   return 0;
60531: }
60531: 
18907: static JSPrincipals *
    1: ObjectPrincipalFinder(JSContext *cx, JSObject *obj)
    1: {
    1:   if (!sSecurityManager)
    1:     return nsnull;
    1: 
    1:   nsCOMPtr<nsIPrincipal> principal;
    1:   nsresult rv =
    1:     sSecurityManager->GetObjectPrincipal(cx, obj,
    1:                                          getter_AddRefs(principal));
    1: 
    1:   if (NS_FAILED(rv) || !principal) {
    1:     return nsnull;
    1:   }
    1: 
    1:   JSPrincipals *jsPrincipals = nsnull;
    1:   principal->GetJSPrincipals(cx, &jsPrincipals);
    1: 
    1:   // nsIPrincipal::GetJSPrincipals() returns a strong reference to the
    1:   // JS principals, but the caller of this function expects a weak
    1:   // reference. So we need to release here.
    1: 
    1:   JSPRINCIPALS_DROP(cx, jsPrincipals);
    1: 
    1:   return jsPrincipals;
    1: }
    1: 
55645: static JSObject*
55645: DOMReadStructuredClone(JSContext* cx,
55645:                        JSStructuredCloneReader* reader,
55645:                        uint32 tag,
60105:                        uint32 data,
60105:                        void* closure)
55645: {
55645:   // We don't currently support any extensions to structured cloning.
55645:   nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_DOM_DATA_CLONE_ERR);
55645:   return nsnull;
55645: }
55645: 
55645: static JSBool
55645: DOMWriteStructuredClone(JSContext* cx,
55645:                         JSStructuredCloneWriter* writer,
60105:                         JSObject* obj,
60105:                         void *closure)
55645: {
55645:   // We don't currently support any extensions to structured cloning.
55645:   nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_DOM_DATA_CLONE_ERR);
55645:   return JS_FALSE;
55645: }
55645: 
55645: static void
55645: DOMStructuredCloneError(JSContext* cx,
55645:                         uint32 errorid)
55645: {
55645:   // We don't currently support any extensions to structured cloning.
55645:   nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_DOM_DATA_CLONE_ERR);
55645: }
55645: 
    1: //static
    1: nsresult
    1: nsJSRuntime::Init()
    1: {
    1:   if (sIsInitialized) {
    1:     if (!nsContentUtils::XPConnect())
    1:       return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
18871:   nsresult rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID,
18871:                                &sSecurityManager);
18871:   NS_ENSURE_SUCCESS(rv, rv);
18871: 
18871:   rv = CallGetService(kJSRuntimeServiceContractID, &sRuntimeService);
    1:   // get the JSRuntime from the runtime svc, if possible
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = sRuntimeService->GetRuntime(&sRuntime);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Let's make sure that our main thread is the same as the xpcom main thread.
    1:   NS_ASSERTION(NS_IsMainThread(), "bad");
    1: 
    1:   NS_ASSERTION(!gOldJSGCCallback,
    1:                "nsJSRuntime initialized more than once");
    1: 
    1:   // Save the old GC callback to chain to it, for GC-observing generality.
    1:   gOldJSGCCallback = ::JS_SetGCCallbackRT(sRuntime, DOMGCCallback);
    1: 
18871:   JSSecurityCallbacks *callbacks = JS_GetRuntimeSecurityCallbacks(sRuntime);
18871:   NS_ASSERTION(callbacks, "SecMan should have set security callbacks!");
18871: 
18871:   callbacks->findObjectPrincipals = ObjectPrincipalFinder;
    1: 
55645:   // Set up the structured clone callbacks.
55645:   static JSStructuredCloneCallbacks cloneCallbacks = {
55645:     DOMReadStructuredClone,
55645:     DOMWriteStructuredClone,
55645:     DOMStructuredCloneError
55645:   };
55645:   JS_SetStructuredCloneCallbacks(sRuntime, &cloneCallbacks);
55645: 
    1:   // Set these global xpconnect options...
    1:   nsContentUtils::RegisterPrefCallback("dom.max_script_run_time",
    1:                                        MaxScriptRunTimePrefChangedCallback,
    1:                                        nsnull);
    1:   MaxScriptRunTimePrefChangedCallback("dom.max_script_run_time", nsnull);
    1: 
    1:   nsContentUtils::RegisterPrefCallback("dom.max_chrome_script_run_time",
    1:                                        MaxScriptRunTimePrefChangedCallback,
    1:                                        nsnull);
    1:   MaxScriptRunTimePrefChangedCallback("dom.max_chrome_script_run_time",
    1:                                       nsnull);
    1: 
14170:   nsContentUtils::RegisterPrefCallback("dom.report_all_js_exceptions",
14170:                                        ReportAllJSExceptionsPrefChangedCallback,
14170:                                        nsnull);
14170:   ReportAllJSExceptionsPrefChangedCallback("dom.report_all_js_exceptions",
14170:                                            nsnull);
14170: 
30112:   nsContentUtils::RegisterPrefCallback("javascript.options.mem.high_water_mark",
30112:                                        SetMemoryHighWaterMarkPrefChangedCallback,
30112:                                        nsnull);
30112:   SetMemoryHighWaterMarkPrefChangedCallback("javascript.options.mem.high_water_mark",
30112:                                             nsnull);
30112: 
60056:   nsContentUtils::RegisterPrefCallback("javascript.options.mem.max",
60056:                                        SetMemoryMaxPrefChangedCallback,
60056:                                        nsnull);
60056:   SetMemoryMaxPrefChangedCallback("javascript.options.mem.max",
60056:                                   nsnull);
60056: 
31888:   nsContentUtils::RegisterPrefCallback("javascript.options.mem.gc_frequency",
31888:                                        SetMemoryGCFrequencyPrefChangedCallback,
31888:                                        nsnull);
31888:   SetMemoryGCFrequencyPrefChangedCallback("javascript.options.mem.gc_frequency",
31888:                                           nsnull);
31888: 
60531:   nsContentUtils::RegisterPrefCallback("javascript.options.mem.gc_per_compartment",
60531:                                        SetMemoryGCModePrefChangedCallback,
60531:                                        nsnull);
60531:   SetMemoryGCModePrefChangedCallback("javascript.options.mem.gc_per_compartment",
60531:                                      nsnull);
60531: 
41540:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
41540:   if (!obs)
41540:     return NS_ERROR_FAILURE;
62725: 
62725:   nsIObserver* memPressureObserver = new nsMemoryPressureObserver();
62725:   NS_ENSURE_TRUE(memPressureObserver, NS_ERROR_OUT_OF_MEMORY);
62725:   obs->AddObserver(memPressureObserver, "memory-pressure", PR_FALSE);
 7369: 
18871:   sIsInitialized = PR_TRUE;
    1: 
41540:   return NS_OK;
    1: }
    1: 
 7941: //static
 7941: nsScriptNameSpaceManager*
 7941: nsJSRuntime::GetNameSpaceManager()
 7941: {
 7941:   if (sDidShutdown)
 7941:     return nsnull;
 7941: 
 7941:   if (!gNameSpaceManager) {
 7941:     gNameSpaceManager = new nsScriptNameSpaceManager;
57622:     NS_ADDREF(gNameSpaceManager);
 7941: 
 7941:     nsresult rv = gNameSpaceManager->Init();
 7941:     NS_ENSURE_SUCCESS(rv, nsnull);
 7941:   }
 7941: 
 7941:   return gNameSpaceManager;
 7941: }
 7941: 
19157: /* static */
19157: void
19157: nsJSRuntime::Shutdown()
    1: {
62725:   nsJSContext::KillGCTimer();
62725:   nsJSContext::KillCCTimer();
    1: 
57622:   NS_IF_RELEASE(gNameSpaceManager);
    1: 
    1:   if (!sContextCount) {
    1:     // We're being shutdown, and there are no more contexts
    1:     // alive, release the JS runtime service and the security manager.
    1: 
    1:     if (sRuntimeService && sSecurityManager) {
18871:       JSSecurityCallbacks *callbacks = JS_GetRuntimeSecurityCallbacks(sRuntime);
18871:       if (callbacks) {
18871:         NS_ASSERTION(callbacks->findObjectPrincipals == ObjectPrincipalFinder,
18871:                      "Fighting over the findObjectPrincipals callback!");
18871:         callbacks->findObjectPrincipals = NULL;
18871:       }
    1:     }
    1:     NS_IF_RELEASE(sRuntimeService);
    1:     NS_IF_RELEASE(sSecurityManager);
    1:   }
    1: 
    1:   sDidShutdown = PR_TRUE;
    1: }
    1: 
    1: // Script object mananagement - note duplicate implementation
    1: // in nsJSContext above...
    1: nsresult
    1: nsJSRuntime::HoldScriptObject(void* aScriptObject)
    1: {
    1:     NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:     if (! sRuntime) {
    1:         NS_NOTREACHED("couldn't remove GC root - no runtime");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     ::JS_LockGCThingRT(sRuntime, aScriptObject);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSRuntime::DropScriptObject(void* aScriptObject)
    1: {
    1:   NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:   if (! sRuntime) {
    1:     NS_NOTREACHED("couldn't remove GC root");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   ::JS_UnlockGCThingRT(sRuntime, aScriptObject);
    1:   return NS_OK;
    1: }
    1: 
    1: // A factory for the runtime.
    1: nsresult NS_CreateJSRuntime(nsIScriptRuntime **aRuntime)
    1: {
    1:   nsresult rv = nsJSRuntime::Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *aRuntime = new nsJSRuntime();
    1:   if (*aRuntime == nsnull)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_IF_ADDREF(*aRuntime);
    1:   return NS_OK;
    1: }
    1: 
    1: // A fast-array class for JS.  This class supports both nsIJSScriptArray and
    1: // nsIArray.  If it is JS itself providing and consuming this class, all work
    1: // can be done via nsIJSScriptArray, and avoid the conversion of elements
    1: // to/from nsISupports.
    1: // When consumed by non-JS (eg, another script language), conversion is done
    1: // on-the-fly.
    1: class nsJSArgArray : public nsIJSArgArray, public nsIArray {
    1: public:
    1:   nsJSArgArray(JSContext *aContext, PRUint32 argc, jsval *argv, nsresult *prv);
    1:   ~nsJSArgArray();
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 7230:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsJSArgArray,
 7230:                                                          nsIJSArgArray)
    1: 
    1:   // nsIArray
    1:   NS_DECL_NSIARRAY
    1: 
    1:   // nsIJSArgArray
    1:   nsresult GetArgs(PRUint32 *argc, void **argv);
    1: 
    1:   void ReleaseJSObjects();
    1: 
    1: protected:
    1:   JSContext *mContext;
    1:   jsval *mArgv;
    1:   PRUint32 mArgc;
    1: };
    1: 
    1: nsJSArgArray::nsJSArgArray(JSContext *aContext, PRUint32 argc, jsval *argv,
    1:                            nsresult *prv) :
    1:     mContext(aContext),
39013:     mArgv(nsnull),
    1:     mArgc(argc)
    1: {
    1:   // copy the array - we don't know its lifetime, and ours is tied to xpcom
    1:   // refcounting.  Alloc zero'd array so cleanup etc is safe.
39013:   if (argc) {
    1:     mArgv = (jsval *) PR_CALLOC(argc * sizeof(jsval));
    1:     if (!mArgv) {
    1:       *prv = NS_ERROR_OUT_OF_MEMORY;
    1:       return;
    1:     }
39013:   }
 6082: 
 7230:   // Callers are allowed to pass in a null argv even for argc > 0. They can
 7230:   // then use GetArgs to initialize the values.
 7230:   if (argv) {
 7230:     for (PRUint32 i = 0; i < argc; ++i)
    1:       mArgv[i] = argv[i];
 7230:   }
 7264: 
 7264:   *prv = argc > 0 ? NS_HOLD_JS_OBJECTS(this, nsJSArgArray) : NS_OK;
    1: }
    1: 
    1: nsJSArgArray::~nsJSArgArray()
    1: {
    1:   ReleaseJSObjects();
    1: }
    1: 
    1: void
    1: nsJSArgArray::ReleaseJSObjects()
    1: {
 7230:   if (mArgc > 0)
 7230:     NS_DROP_JS_OBJECTS(this, nsJSArgArray);
    1:   if (mArgv) {
    1:     PR_DELETE(mArgv);
    1:   }
    1:   mArgc = 0;
    1: }
    1: 
    1: // QueryInterface implementation for nsJSArgArray
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsJSArgArray)
10981: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsJSArgArray)
    1:   tmp->ReleaseJSObjects();
10981: NS_IMPL_CYCLE_COLLECTION_ROOT_END
10981: NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsJSArgArray)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsJSArgArray)
 7230:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 7230: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 7230: 
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSArgArray)
    1:   jsval *argv = tmp->mArgv;
    1:   if (argv) {
    1:     jsval *end;
    1:     for (end = argv + tmp->mArgc; argv < end; ++argv) {
 7230:       if (JSVAL_IS_GCTHING(*argv))
 7230:         NS_IMPL_CYCLE_COLLECTION_TRACE_CALLBACK(JAVASCRIPT,
 7230:                                                 JSVAL_TO_GCTHING(*argv))
 7230:     }
 7230:   }
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_END
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsJSArgArray)
    1:   NS_INTERFACE_MAP_ENTRY(nsIArray)
    1:   NS_INTERFACE_MAP_ENTRY(nsIJSArgArray)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIJSArgArray)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsJSArgArray, nsIJSArgArray)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsJSArgArray, nsIJSArgArray)
    1: 
    1: nsresult
    1: nsJSArgArray::GetArgs(PRUint32 *argc, void **argv)
    1: {
    1:   if (!mArgv) {
    1:     NS_WARNING("nsJSArgArray has no argv!");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1:   *argv = (void *)mArgv;
    1:   *argc = mArgc;
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIArray impl
    1: NS_IMETHODIMP nsJSArgArray::GetLength(PRUint32 *aLength)
    1: {
    1:   *aLength = mArgc;
    1:   return NS_OK;
    1: }
    1: 
    1: /* void queryElementAt (in unsigned long index, in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
    1: NS_IMETHODIMP nsJSArgArray::QueryElementAt(PRUint32 index, const nsIID & uuid, void * *result)
    1: {
    1:   *result = nsnull;
    1:   if (index >= mArgc)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   if (uuid.Equals(NS_GET_IID(nsIVariant)) || uuid.Equals(NS_GET_IID(nsISupports))) {
    1:     return nsContentUtils::XPConnect()->JSToVariant(mContext, mArgv[index],
    1:                                                     (nsIVariant **)result);
    1:   }
    1:   NS_WARNING("nsJSArgArray only handles nsIVariant");
    1:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: /* unsigned long indexOf (in unsigned long startIndex, in nsISupports element); */
    1: NS_IMETHODIMP nsJSArgArray::IndexOf(PRUint32 startIndex, nsISupports *element, PRUint32 *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsISimpleEnumerator enumerate (); */
    1: NS_IMETHODIMP nsJSArgArray::Enumerate(nsISimpleEnumerator **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: // The factory function
    1: nsresult NS_CreateJSArgv(JSContext *aContext, PRUint32 argc, void *argv,
    1:                          nsIArray **aArray)
    1: {
    1:   nsresult rv;
    1:   nsJSArgArray *ret = new nsJSArgArray(aContext, argc,
 3233:                                        static_cast<jsval *>(argv), &rv);
    1:   if (ret == nsnull)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   if (NS_FAILED(rv)) {
    1:     delete ret;
    1:     return rv;
    1:   }
    1:   return ret->QueryInterface(NS_GET_IID(nsIArray), (void **)aArray);
    1: }
