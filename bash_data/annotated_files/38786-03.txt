19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *   Tim Copperfield <timecop@network.email.ne.jp>
19246:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
19246: #include "prlog.h"
19246: #include "prmem.h"
19246: #include "nscore.h"
19246: #include "prenv.h"
19246: 
19246: #include "nsNPAPIPluginInstance.h"
19246: #include "nsNPAPIPlugin.h"
19246: #include "nsNPAPIPluginStreamListener.h"
29956: #include "nsPluginHost.h"
19246: #include "nsPluginSafety.h"
19246: #include "nsPluginLogging.h"
24475: #include "nsIPrivateBrowsingService.h"
19246: 
19246: #include "nsIDocument.h"
29808: #include "nsIScriptGlobalObject.h"
29808: #include "nsIScriptContext.h"
29834: #include "nsDirectoryServiceDefs.h"
19246: 
19246: #include "nsJSNPRuntime.h"
19246: 
36125: using namespace mozilla::plugins::parent;
36355: using mozilla::TimeStamp;
36125: 
19246: static NS_DEFINE_IID(kIPluginStreamListenerIID, NS_IPLUGINSTREAMLISTENER_IID);
19246: 
29834: // nsPluginStreamToFile
29834: // --------------------
29834: // Used to handle NPN_NewStream() - writes the stream as received by the plugin
29834: // to a file and at completion (NPN_DestroyStream), tells the browser to load it into
29834: // a plugin-specified target
29834: 
29834: static NS_DEFINE_IID(kIOutputStreamIID, NS_IOUTPUTSTREAM_IID);
29834: 
29834: class nsPluginStreamToFile : public nsIOutputStream
29834: {
29834: public:
29834:   nsPluginStreamToFile(const char* target, nsIPluginInstanceOwner* owner);
29834:   virtual ~nsPluginStreamToFile();
29834: 
29834:   NS_DECL_ISUPPORTS
29834:   NS_DECL_NSIOUTPUTSTREAM
29834: protected:
29834:   char* mTarget;
29834:   nsCString mFileURL;
29834:   nsCOMPtr<nsILocalFile> mTempFile;
29834:   nsCOMPtr<nsIOutputStream> mOutputStream;
29834:   nsIPluginInstanceOwner* mOwner;
29834: };
29834: 
29834: NS_IMPL_ISUPPORTS1(nsPluginStreamToFile, nsIOutputStream)
29834: 
29834: nsPluginStreamToFile::nsPluginStreamToFile(const char* target,
29834:                                            nsIPluginInstanceOwner* owner)
29834: : mTarget(PL_strdup(target)),
29834: mOwner(owner)
29834: {
29834:   nsresult rv;
29834:   nsCOMPtr<nsIFile> pluginTmp;
29834:   rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(pluginTmp));
29834:   if (NS_FAILED(rv)) return;
29834:   
29834:   mTempFile = do_QueryInterface(pluginTmp, &rv);
29834:   if (NS_FAILED(rv)) return;
29834:   
29834:   // need to create a file with a unique name - use target as the basis
29834:   rv = mTempFile->AppendNative(nsDependentCString(target));
29834:   if (NS_FAILED(rv)) return;
29834:   
29834:   // Yes, make it unique.
29834:   rv = mTempFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0700); 
29834:   if (NS_FAILED(rv)) return;
29834:   
29834:   // create the file
29834:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(mOutputStream), mTempFile, -1, 00600);
29834:   if (NS_FAILED(rv))
29834:     return;
29834: 	
29834:   // construct the URL we'll use later in calls to GetURL()
29834:   NS_GetURLSpecFromFile(mTempFile, mFileURL);
29834:   
29834: #ifdef NS_DEBUG
29834:   printf("File URL = %s\n", mFileURL.get());
29834: #endif
29834: }
29834: 
29834: nsPluginStreamToFile::~nsPluginStreamToFile()
29834: {
29834:   // should we be deleting mTempFile here?
29834:   if (nsnull != mTarget)
29834:     PL_strfree(mTarget);
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsPluginStreamToFile::Flush()
29834: {
29834:   return NS_OK;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsPluginStreamToFile::Write(const char* aBuf, PRUint32 aCount,
29834:                             PRUint32 *aWriteCount)
29834: {
33282:   mOutputStream->Write(aBuf, aCount, aWriteCount);
29834:   mOutputStream->Flush();
36766:   mOwner->GetURL(mFileURL.get(), mTarget, nsnull, nsnull, 0);
29834:   
29834:   return NS_OK;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsPluginStreamToFile::WriteFrom(nsIInputStream *inStr, PRUint32 count,
29834:                                 PRUint32 *_retval)
29834: {
29834:   NS_NOTREACHED("WriteFrom");
29834:   return NS_ERROR_NOT_IMPLEMENTED;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsPluginStreamToFile::WriteSegments(nsReadSegmentFun reader, void * closure,
29834:                                     PRUint32 count, PRUint32 *_retval)
29834: {
29834:   NS_NOTREACHED("WriteSegments");
29834:   return NS_ERROR_NOT_IMPLEMENTED;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsPluginStreamToFile::IsNonBlocking(PRBool *aNonBlocking)
29834: {
29834:   *aNonBlocking = PR_FALSE;
29834:   return NS_OK;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsPluginStreamToFile::Close(void)
29834: {
33282:   mOutputStream->Close();
36766:   mOwner->GetURL(mFileURL.get(), mTarget, nsnull, nsnull, 0);
29834:   return NS_OK;
29834: }
29834: 
29834: // end of nsPluginStreamToFile
29834: 
19246: // nsNPAPIPluginStreamListener Methods
19246: 
19246: NS_IMPL_ISUPPORTS3(nsNPAPIPluginStreamListener, nsIPluginStreamListener,
19246:                    nsITimerCallback, nsIHTTPHeaderListener)
19246: 
19246: nsNPAPIPluginStreamListener::nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, 
19246:                                                          void* notifyData,
19246:                                                          const char* aURL)
19246:   : mNotifyData(notifyData),
19246:     mStreamBuffer(nsnull),
19246:     mNotifyURL(aURL ? PL_strdup(aURL) : nsnull),
19246:     mInst(inst),
19246:     mStreamBufferSize(0),
19246:     mStreamBufferByteCount(0),
32799:     mStreamType(NP_NORMAL),
19246:     mStreamStarted(PR_FALSE),
19246:     mStreamCleanedUp(PR_FALSE),
19246:     mCallNotify(PR_FALSE),
19246:     mIsSuspended(PR_FALSE),
19246:     mIsPluginInitJSStream(mInst->mInPluginInitCall &&
19246:                           aURL && strncmp(aURL, "javascript:",
19246:                                           sizeof("javascript:") - 1) == 0),
19246:     mResponseHeaderBuf(nsnull)
19246: {
19246:   memset(&mNPStream, 0, sizeof(mNPStream));
19246: 
19246:   NS_IF_ADDREF(mInst);
19246: }
19246: 
19246: nsNPAPIPluginStreamListener::~nsNPAPIPluginStreamListener(void)
19246: {
19246:   // remove itself from the instance stream list
19246:   nsNPAPIPluginInstance *inst = mInst;
19246:   if (inst) {
19246:     nsInstanceStream * prev = nsnull;
19246:     for (nsInstanceStream *is = inst->mStreams; is != nsnull; is = is->mNext) {
19246:       if (is->mPluginStreamListener == this) {
19246:         if (!prev)
19246:           inst->mStreams = is->mNext;
19246:         else
19246:           prev->mNext = is->mNext;
19246: 
19246:         delete is;
19246:         break;
19246:       }
19246:       prev = is;
19246:     }
19246:   }
19246: 
19246:   // For those cases when NewStream is never called, we still may need
19246:   // to fire a notification callback. Return network error as fallback
19246:   // reason because for other cases, notify should have already been
19246:   // called for other reasons elsewhere.
19246:   CallURLNotify(NPRES_NETWORK_ERR);
19246: 
19246:   // lets get rid of the buffer
19246:   if (mStreamBuffer) {
19246:     PR_Free(mStreamBuffer);
19246:     mStreamBuffer=nsnull;
19246:   }
19246: 
19246:   NS_IF_RELEASE(inst);
19246: 
19246:   if (mNotifyURL)
19246:     PL_strfree(mNotifyURL);
19246: 
19246:   if (mResponseHeaderBuf)
19246:     PL_strfree(mResponseHeaderBuf);
19246: }
19246: 
19246: nsresult nsNPAPIPluginStreamListener::CleanUpStream(NPReason reason)
19246: {
19246:   nsresult rv = NS_ERROR_FAILURE;
19246: 
19246:   if (mStreamCleanedUp)
19246:     return NS_OK;
19246: 
36355:   if (!mInst || !mInst->IsRunning())
19246:     return rv;
19246: 
19246:   PluginDestructionGuard guard(mInst);
19246: 
19246:   const NPPluginFuncs *callbacks = nsnull;
19246:   mInst->GetCallbacks(&callbacks);
19246:   if (!callbacks)
19246:     return rv;
19246: 
19246:   NPP npp;
19246:   mInst->GetNPP(&npp);
19246: 
19246:   if (mStreamStarted && callbacks->destroystream) {
35965:     NPPAutoPusher nppPusher(npp);
35965: 
36010:     PluginLibrary* lib = nsnull;
30212:     lib = mInst->mLibrary;
19246:     NPError error;
20125:     NS_TRY_SAFE_CALL_RETURN(error, (*callbacks->destroystream)(npp, &mNPStream, reason), lib, mInst);
19246: 
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPP DestroyStream called: this=%p, npp=%p, reason=%d, return=%d, url=%s\n",
19246:     this, npp, reason, error, mNPStream.url));
19246: 
19246:     if (error == NPERR_NO_ERROR)
19246:       rv = NS_OK;
19246:   }
19246: 
38785:   mStreamCleanedUp = PR_TRUE;
19246:   mStreamStarted   = PR_FALSE;
19246: 
38785:   StopDataPump();
38785: 
19246:   // fire notification back to plugin, just like before
19246:   CallURLNotify(reason);
19246: 
19246:   return rv;
19246: }
19246: 
19246: void nsNPAPIPluginStreamListener::CallURLNotify(NPReason reason)
19246: {
36355:   if (!mCallNotify || !mInst || !mInst->IsRunning())
19246:     return;
19246: 
19246:   PluginDestructionGuard guard(mInst);
19246: 
19246:   mCallNotify = PR_FALSE; // only do this ONCE and prevent recursion
19246: 
19246:   const NPPluginFuncs *callbacks = nsnull;
19246:   mInst->GetCallbacks(&callbacks);
19246:   if (!callbacks)
19246:     return;
19246:   
19246:   if (callbacks->urlnotify) {
19246: 
19246:     NPP npp;
19246:     mInst->GetNPP(&npp);
19246: 
30212:     NS_TRY_SAFE_CALL_VOID((*callbacks->urlnotify)(npp, mNotifyURL, reason, mNotifyData), mInst->mLibrary, mInst);
19246: 
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPP URLNotify called: this=%p, npp=%p, notify=%p, reason=%d, url=%s\n",
19246:     this, npp, mNotifyData, reason, mNotifyURL));
19246:   }
19246: }
19246: 
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::OnStartBinding(nsIPluginStreamInfo* pluginInfo)
19246: {
19246:   if (!mInst)
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   PluginDestructionGuard guard(mInst);
19246: 
19246:   NPP npp;
19246:   const NPPluginFuncs *callbacks = nsnull;
19246: 
19246:   mInst->GetCallbacks(&callbacks);
19246:   mInst->GetNPP(&npp);
19246: 
36355:   if (!callbacks || !mInst->IsRunning())
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   PRBool seekable;
30101:   char* contentType;
19246:   PRUint16 streamType = NP_NORMAL;
19246:   NPError error;
19246: 
19246:   mNPStream.ndata = (void*) this;
19246:   pluginInfo->GetURL(&mNPStream.url);
19246:   mNPStream.notifyData = mNotifyData;
19246: 
19246:   pluginInfo->GetLength((PRUint32*)&(mNPStream.end));
19246:   pluginInfo->GetLastModified((PRUint32*)&(mNPStream.lastmodified));
19246:   pluginInfo->IsSeekable(&seekable);
19246:   pluginInfo->GetContentType(&contentType);
19246:   
19246:   if (!mResponseHeaders.IsEmpty()) {
19246:     mResponseHeaderBuf = PL_strdup(mResponseHeaders.get());
19246:     mNPStream.headers = mResponseHeaderBuf;
19246:   }
19246: 
19246:   mStreamInfo = pluginInfo;
19246: 
35965:   NPPAutoPusher nppPusher(npp);
35965: 
30212:   NS_TRY_SAFE_CALL_RETURN(error, (*callbacks->newstream)(npp, (char*)contentType, &mNPStream, seekable, &streamType), mInst->mLibrary, mInst);
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPP NewStream called: this=%p, npp=%p, mime=%s, seek=%d, type=%d, return=%d, url=%s\n",
19246:   this, npp, (char *)contentType, seekable, streamType, error, mNPStream.url));
19246: 
19246:   if (error != NPERR_NO_ERROR)
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   switch(streamType)
19246:   {
19246:     case NP_NORMAL:
32799:       mStreamType = NP_NORMAL; 
19246:       break;
19246:     case NP_ASFILEONLY:
32799:       mStreamType = NP_ASFILEONLY; 
19246:       break;
19246:     case NP_ASFILE:
32799:       mStreamType = NP_ASFILE; 
19246:       break;
19246:     case NP_SEEK:
32799:       mStreamType = NP_SEEK; 
19246:       break;
19246:     default:
19246:       return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   mStreamStarted = PR_TRUE;
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult
19246: nsNPAPIPluginStreamListener::SuspendRequest()
19246: {
19246:   NS_ASSERTION(!mIsSuspended,
19246:                "Suspending a request that's already suspended!");
19246: 
19246:   nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
19246:     do_QueryInterface(mStreamInfo);
19246:   nsIRequest *request;
19246: 
19246:   if (!pluginInfoNPAPI || !(request = pluginInfoNPAPI->GetRequest())) {
19246:     NS_ERROR("Trying to suspend a non-suspendable stream!");
19246:     return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   nsresult rv = StartDataPump();
19246:   NS_ENSURE_SUCCESS(rv, rv);
19246: 
19246:   mIsSuspended = PR_TRUE;
19246: 
19246:   return request->Suspend();
19246: }
19246: 
19246: void
19246: nsNPAPIPluginStreamListener::ResumeRequest()
19246: {
19246:   nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
19246:     do_QueryInterface(mStreamInfo);
19246: 
19246:   nsIRequest *request = pluginInfoNPAPI->GetRequest();
19246: 
19246:   // request can be null if the network stream is done.
21231:   if (request)
19246:     request->Resume();
19246: 
19246:   mIsSuspended = PR_FALSE;
19246: }
19246: 
19246: nsresult
19246: nsNPAPIPluginStreamListener::StartDataPump()
19246: {
19246:   nsresult rv;
19246:   mDataPumpTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
19246:   NS_ENSURE_SUCCESS(rv, rv);
19246: 
19246:   // Start pumping data to the plugin every 100ms until it obeys and
19246:   // eats the data.
19246:   return mDataPumpTimer->InitWithCallback(this, 100,
19246:                                           nsITimer::TYPE_REPEATING_SLACK);
19246: }
19246: 
19246: void
19246: nsNPAPIPluginStreamListener::StopDataPump()
19246: {
19246:   if (mDataPumpTimer) {
19246:     mDataPumpTimer->Cancel();
19246:     mDataPumpTimer = nsnull;
19246:   }
19246: }
19246: 
19246: // Return true if a javascript: load that was started while the plugin
19246: // was being initialized is still in progress.
19246: PRBool
19246: nsNPAPIPluginStreamListener::PluginInitJSLoadInProgress()
19246: {
19246:   for (nsInstanceStream *is = mInst->mStreams; is; is = is->mNext) {
19246:     if (is->mPluginStreamListener->mIsPluginInitJSStream) {
19246:       return PR_TRUE;
19246:     }
19246:   }
19246: 
19246:   return PR_FALSE;
19246: }
19246: 
19246: // This method is called when there's more data available off the
19246: // network, but it's also called from our data pump when we're feeding
19246: // the plugin data that we already got off the network, but the plugin
19246: // was unable to consume it at the point it arrived. In the case when
19246: // the plugin pump calls this method, the input argument will be null,
19246: // and the length will be the number of bytes available in our
19246: // internal buffer.
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,
19246:                                           nsIInputStream* input,
19246:                                           PRUint32 length)
19246: {
36355:   if (!mInst || !mInst->IsRunning())
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   PluginDestructionGuard guard(mInst);
19246: 
19246:   // Just in case the caller switches plugin info on us.
19246:   mStreamInfo = pluginInfo;
19246: 
19246:   const NPPluginFuncs *callbacks = nsnull;
19246:   mInst->GetCallbacks(&callbacks);
19246:   // check out if plugin implements NPP_Write call
19246:   if (!callbacks || !callbacks->write || !length)
19246:     return NS_ERROR_FAILURE; // it'll cancel necko transaction 
19246:   
19246:   if (!mStreamBuffer) {
19246:     // To optimize the mem usage & performance we have to allocate
19246:     // mStreamBuffer here in first ODA when length of data available
19246:     // in input stream is known.  mStreamBuffer will be freed in DTOR.
19246:     // we also have to remember the size of that buff to make safe
19246:     // consecutive Read() calls form input stream into our buff.
19246: 
19246:     PRUint32 contentLength;
19246:     pluginInfo->GetLength(&contentLength);
19246: 
35671:     mStreamBufferSize = NS_MAX(length, contentLength);
19246: 
19246:     // Limit the size of the initial buffer to MAX_PLUGIN_NECKO_BUFFER
19246:     // (16k). This buffer will grow if needed, as in the case where
19246:     // we're getting data faster than the plugin can process it.
35671:     mStreamBufferSize = NS_MIN(mStreamBufferSize,
35671:                                PRUint32(MAX_PLUGIN_NECKO_BUFFER));
19246: 
19246:     mStreamBuffer = (char*) PR_Malloc(mStreamBufferSize);
19246:     if (!mStreamBuffer)
19246:       return NS_ERROR_OUT_OF_MEMORY;
19246:   }
19246:   
19246:   // prepare NPP_ calls params
19246:   NPP npp;
19246:   mInst->GetNPP(&npp);
19246: 
19246:   PRInt32 streamPosition;
19246:   pluginInfo->GetStreamOffset(&streamPosition);
19246:   PRInt32 streamOffset = streamPosition;
19246: 
19246:   if (input) {
19246:     streamOffset += length;
19246: 
19246:     // Set new stream offset for the next ODA call regardless of how
19246:     // following NPP_Write call will behave we pretend to consume all
19246:     // data from the input stream.  It's possible that current steam
19246:     // position will be overwritten from NPP_RangeRequest call made
19246:     // from NPP_Write, so we cannot call SetStreamOffset after
19246:     // NPP_Write.
19246:     //
19246:     // Note: there is a special case when data flow should be
19246:     // temporarily stopped if NPP_WriteReady returns 0 (bug #89270)
19246:     pluginInfo->SetStreamOffset(streamOffset);
19246: 
19246:     // set new end in case the content is compressed
19246:     // initial end is less than end of decompressed stream
19246:     // and some plugins (e.g. acrobat) can fail. 
19246:     if ((PRInt32)mNPStream.end < streamOffset)
19246:       mNPStream.end = streamOffset;
19246:   }
19246: 
19246:   nsresult rv = NS_OK;
19246:   while (NS_SUCCEEDED(rv) && length > 0) {
19246:     if (input && length) {
21231:       if (mStreamBufferSize < mStreamBufferByteCount + length && mIsSuspended) {
19246:         // We're in the ::OnDataAvailable() call that we might get
19246:         // after suspending a request, or we suspended the request
19246:         // from within this ::OnDataAvailable() call while there's
19246:         // still data in the input, and we don't have enough space to
19246:         // store what we got off the network. Reallocate our internal
19246:         // buffer.
19246:         mStreamBufferSize = mStreamBufferByteCount + length;
19246:         char *buf = (char*)PR_Realloc(mStreamBuffer, mStreamBufferSize);
19246:         if (!buf)
19246:           return NS_ERROR_OUT_OF_MEMORY;
19246: 
19246:         mStreamBuffer = buf;
19246:       }
19246: 
19246:       PRUint32 bytesToRead =
35671:         NS_MIN(length, mStreamBufferSize - mStreamBufferByteCount);
19246: 
19246:       PRUint32 amountRead = 0;
19246:       rv = input->Read(mStreamBuffer + mStreamBufferByteCount, bytesToRead,
19246:                        &amountRead);
19246:       NS_ENSURE_SUCCESS(rv, rv);
19246: 
19246:       if (amountRead == 0) {
19246:         NS_NOTREACHED("input->Read() returns no data, it's almost impossible "
19246:                       "to get here");
19246: 
19246:         break;
19246:       }
19246: 
19246:       mStreamBufferByteCount += amountRead;
19246:       length -= amountRead;
19246:     } else {
19246:       // No input, nothing to read. Set length to 0 so that we don't
19246:       // keep iterating through this outer loop any more.
19246: 
19246:       length = 0;
19246:     }
19246: 
19246:     // Temporary pointer to the beginning of the data we're writing as
19246:     // we loop and feed the plugin data.
19246:     char *ptrStreamBuffer = mStreamBuffer;
19246: 
19246:     // it is possible plugin's NPP_Write() returns 0 byte consumed. We
19246:     // use zeroBytesWriteCount to count situation like this and break
19246:     // the loop
19246:     PRInt32 zeroBytesWriteCount = 0;
19246: 
19246:     // mStreamBufferByteCount tells us how many bytes there are in the
19246:     // buffer. WriteReady returns to us how many bytes the plugin is
19246:     // ready to handle.
19246:     while (mStreamBufferByteCount > 0) {
19246:       PRInt32 numtowrite;
19246:       if (callbacks->writeready) {
35965:         NPPAutoPusher nppPusher(npp);
35965: 
30212:         NS_TRY_SAFE_CALL_RETURN(numtowrite, (*callbacks->writeready)(npp, &mNPStream), mInst->mLibrary, mInst);
19246:         NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                        ("NPP WriteReady called: this=%p, npp=%p, "
19246:                         "return(towrite)=%d, url=%s\n",
19246:                         this, npp, numtowrite, mNPStream.url));
19246: 
19246:         if (!mStreamStarted) {
19246:           // The plugin called NPN_DestroyStream() from within
19246:           // NPP_WriteReady(), kill the stream.
19246: 
19246:           return NS_BINDING_ABORTED;
19246:         }
19246: 
19246:         // if WriteReady returned 0, the plugin is not ready to handle
19246:         // the data, suspend the stream (if it isn't already
19246:         // suspended).
19246:         //
19246:         // Also suspend the stream if the stream we're loading is not
19246:         // a javascript: URL load that was initiated during plugin
19246:         // initialization and there currently is such a stream
19246:         // loading. This is done to work around a Windows Media Player
19246:         // plugin bug where it can't deal with being fed data for
19246:         // other streams while it's waiting for data from the
19246:         // javascript: URL loads it requests during
19246:         // initialization. See bug 386493 for more details.
19246: 
19246:         if (numtowrite <= 0 ||
19246:             (!mIsPluginInitJSStream && PluginInitJSLoadInProgress())) {
19246:           if (!mIsSuspended) {
19246:             rv = SuspendRequest();
19246:           }
19246: 
19246:           // Break out of the inner loop, but keep going through the
19246:           // outer loop in case there's more data to read from the
19246:           // input stream.
19246: 
19246:           break;
19246:         }
19246: 
35671:         numtowrite = NS_MIN(numtowrite, mStreamBufferByteCount);
19246:       } else {
19246:         // if WriteReady is not supported by the plugin, just write
19246:         // the whole buffer
19246:         numtowrite = mStreamBufferByteCount;
19246:       }
19246: 
35965:       NPPAutoPusher nppPusher(npp);
35965: 
19246:       PRInt32 writeCount = 0; // bytes consumed by plugin instance
30212:       NS_TRY_SAFE_CALL_RETURN(writeCount, (*callbacks->write)(npp, &mNPStream, streamPosition, numtowrite, ptrStreamBuffer), mInst->mLibrary, mInst);
19246: 
19246:       NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                      ("NPP Write called: this=%p, npp=%p, pos=%d, len=%d, "
19246:                       "buf=%s, return(written)=%d,  url=%s\n",
19246:                       this, npp, streamPosition, numtowrite,
19246:                       ptrStreamBuffer, writeCount, mNPStream.url));
19246: 
19246:       if (!mStreamStarted) {
19246:         // The plugin called NPN_DestroyStream() from within
19246:         // NPP_Write(), kill the stream.
19246:         return NS_BINDING_ABORTED;
19246:       }
19246: 
19246:       if (writeCount > 0) {
19246:         NS_ASSERTION(writeCount <= mStreamBufferByteCount,
19246:                      "Plugin read past the end of the available data!");
19246: 
35671:         writeCount = NS_MIN(writeCount, mStreamBufferByteCount);
19246:         mStreamBufferByteCount -= writeCount;
19246: 
19246:         streamPosition += writeCount;
19246: 
19246:         zeroBytesWriteCount = 0;
19246: 
19246:         if (mStreamBufferByteCount > 0) {
19246:           // This alignment code is most likely bogus, but we'll leave
19246:           // it in for now in case it matters for some plugins on some
19246:           // architectures. Who knows...
19246:           if (writeCount % sizeof(PRWord)) {
19246:             // memmove will take care  about alignment 
19246:             memmove(mStreamBuffer, ptrStreamBuffer + writeCount,
19246:                     mStreamBufferByteCount);
19246:             ptrStreamBuffer = mStreamBuffer;
19246:           } else {
19246:             // if aligned we can use ptrStreamBuffer += to eliminate
19246:             // memmove()
19246:             ptrStreamBuffer += writeCount;
19246:           }
19246:         }
19246:       } else if (writeCount == 0) {
19246:         // if NPP_Write() returns writeCount == 0 lets say 3 times in
19246:         // a row, suspend the request and continue feeding the plugin
19246:         // the data we got so far. Once that data is consumed, we'll
19246:         // resume the request.
19246:         if (mIsSuspended || ++zeroBytesWriteCount == 3) {
19246:           if (!mIsSuspended) {
19246:             rv = SuspendRequest();
19246:           }
19246: 
19246:           // Break out of the for loop, but keep going through the
19246:           // while loop in case there's more data to read from the
19246:           // input stream.
19246: 
19246:           break;
19246:         }
19246:       } else {
19246:         // Something's really wrong, kill the stream.
19246:         rv = NS_ERROR_FAILURE;
19246: 
19246:         break;
19246:       }  
19246:     } // end of inner while loop
19246: 
19246:     if (mStreamBufferByteCount && mStreamBuffer != ptrStreamBuffer) {
19246:       memmove(mStreamBuffer, ptrStreamBuffer, mStreamBufferByteCount);
19246:     }
19246:   }
19246: 
19246:   if (streamPosition != streamOffset) {
19246:     // The plugin didn't consume all available data, or consumed some
19246:     // of our cached data while we're pumping cached data. Adjust the
19246:     // plugin info's stream offset to match reality, except if the
19246:     // plugin info's stream offset was set by a re-entering
19246:     // NPN_RequestRead() call.
19246: 
19246:     PRInt32 postWriteStreamPosition;
19246:     pluginInfo->GetStreamOffset(&postWriteStreamPosition);
19246: 
19246:     if (postWriteStreamPosition == streamOffset) {
19246:       pluginInfo->SetStreamOffset(streamPosition);
19246:     }
19246:   }
19246: 
19246:   return rv;
19246: }
19246: 
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::OnFileAvailable(nsIPluginStreamInfo* pluginInfo, 
19246:                                              const char* fileName)
19246: {
36355:   if (!mInst || !mInst->IsRunning())
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   PluginDestructionGuard guard(mInst);
19246: 
19246:   const NPPluginFuncs *callbacks = nsnull;
19246:   mInst->GetCallbacks(&callbacks);
19246:   if (!callbacks || !callbacks->asfile)
19246:     return NS_ERROR_FAILURE;
19246:   
19246:   NPP npp;
19246:   mInst->GetNPP(&npp);
19246: 
36010:   PluginLibrary* lib = nsnull;
30212:   lib = mInst->mLibrary;
19246: 
20125:   NS_TRY_SAFE_CALL_VOID((*callbacks->asfile)(npp, &mNPStream, fileName), lib, mInst);
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPP StreamAsFile called: this=%p, npp=%p, url=%s, file=%s\n",
19246:   this, npp, mNPStream.url, fileName));
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::OnStopBinding(nsIPluginStreamInfo* pluginInfo, 
19246:                                         nsresult status)
19246: {
19246:   StopDataPump();
19246: 
19246:   if (NS_FAILED(status)) {
19246:     // The stream was destroyed, or died for some reason. Make sure we
19246:     // cancel the underlying request.
19246:     nsCOMPtr<nsINPAPIPluginStreamInfo> pluginInfoNPAPI =
19246:       do_QueryInterface(mStreamInfo);
19246: 
19246:     nsIRequest *request;
19246:     if (pluginInfoNPAPI && (request = pluginInfoNPAPI->GetRequest())) {
19246:       request->Cancel(status);
19246:     }
19246:   }
19246: 
36355:   if (!mInst || !mInst->IsRunning())
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   // check if the stream is of seekable type and later its destruction
19246:   // see bug 91140    
19246:   nsresult rv = NS_OK;
38785:   if (mStreamType != NP_SEEK) {
38785:     NPReason reason = NPRES_DONE;
38785: 
38785:     if (NS_FAILED(status))
38785:       reason = NPRES_NETWORK_ERR;   // since the stream failed, we need to tell the plugin that
38785: 
19246:     rv = CleanUpStream(reason);
19246:   }
19246: 
38785:   if (rv != NPERR_NO_ERROR)
38785:     return NS_ERROR_FAILURE;
38785: 
38785:   return NS_OK;
19246: }
19246: 
19246: NS_IMETHODIMP
32799: nsNPAPIPluginStreamListener::GetStreamType(PRInt32 *result)
19246: {
19246:   *result = mStreamType;
19246:   return NS_OK;
19246: }
19246: 
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::Notify(nsITimer *aTimer)
19246: {
19246:   NS_ASSERTION(aTimer == mDataPumpTimer, "Uh, wrong timer?");
19246: 
19246:   PRInt32 oldStreamBufferByteCount = mStreamBufferByteCount;
19246: 
19246:   nsresult rv = OnDataAvailable(mStreamInfo, nsnull, mStreamBufferByteCount);
19246: 
19246:   if (NS_FAILED(rv)) {
19246:     // We ran into an error, no need to keep firing this timer then.
19246:     aTimer->Cancel();
19246:     return NS_OK;
19246:   }
19246: 
19246:   if (mStreamBufferByteCount != oldStreamBufferByteCount &&
19246:       ((mStreamStarted && mStreamBufferByteCount < 1024) ||
19246:        mStreamBufferByteCount == 0)) {
19246:     // The plugin read some data and we've got less than 1024 bytes in
19246:     // our buffer (or its empty and the stream is already
19246:     // done). Resume the request so that we get more data off the
19246:     // network.
19246:     ResumeRequest();
19246:     // Necko will pump data now that we've resumed the request.
19246:     StopDataPump();
19246:   }
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::StatusLine(const char* line)
19246: {
19246:   mResponseHeaders.Append(line);
19246:   mResponseHeaders.Append('\n');
19246:   return NS_OK;
19246: }
19246: 
19246: NS_IMETHODIMP
19246: nsNPAPIPluginStreamListener::NewResponseHeader(const char* headerName,
19246:                                             const char* headerValue)
19246: {
19246:   mResponseHeaders.Append(headerName);
19246:   mResponseHeaders.Append(": ");
19246:   mResponseHeaders.Append(headerValue);
19246:   mResponseHeaders.Append('\n');
19246:   return NS_OK;
19246: }
19246: 
19246: nsInstanceStream::nsInstanceStream()
19246: {
19246:   mNext = nsnull;
19246:   mPluginStreamListener = nsnull;
19246: }
19246: 
19246: nsInstanceStream::~nsInstanceStream()
19246: {
19246: }
19246: 
29953: NS_IMPL_ISUPPORTS1(nsNPAPIPluginInstance, nsIPluginInstance)
19246: 
37841: nsNPAPIPluginInstance::nsNPAPIPluginInstance(NPPluginFuncs* callbacks,
36173:                                              PluginLibrary* aLibrary)
30212:   : mCallbacks(callbacks),
19246: #ifdef XP_MACOSX
19246: #ifdef NP_NO_QUICKDRAW
19246:     mDrawingModel(NPDrawingModelCoreGraphics),
19246: #else
19246:     mDrawingModel(NPDrawingModelQuickDraw),
19246: #endif
19246: #endif
19246:     mWindowless(PR_FALSE),
34217:     mWindowlessLocal(PR_FALSE),
19246:     mTransparent(PR_FALSE),
36355:     mRunning(PR_FALSE),
19246:     mCached(PR_FALSE),
19246:     mWantsAllNetworkStreams(PR_FALSE),
19246:     mInPluginInitCall(PR_FALSE),
30212:     mLibrary(aLibrary),
29808:     mStreams(nsnull),
32019:     mMIMEType(nsnull),
32019:     mOwner(nsnull),
37841:     mCurrentPluginEvent(nsnull)
19246: {
37841:   NS_ASSERTION(mCallbacks != NULL, "null callbacks");
19246: 
19246:   // Initialize the NPP structure.
19246: 
30212:   mNPP.pdata = NULL;
30212:   mNPP.ndata = this;
19246: 
19246:   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance ctor: this=%p\n",this));
19246: }
19246: 
19246: nsNPAPIPluginInstance::~nsNPAPIPluginInstance(void)
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance dtor: this=%p\n",this));
19246: 
19246:   // clean the stream list if any
19246:   for (nsInstanceStream *is = mStreams; is != nsnull;) {
19246:     nsInstanceStream * next = is->mNext;
19246:     delete is;
19246:     is = next;
19246:   }
29808: 
29808:   if (mMIMEType) {
29808:     PR_Free((void *)mMIMEType);
29808:     mMIMEType = nsnull;
29808:   }
19246: }
19246: 
19246: PRBool
36355: nsNPAPIPluginInstance::IsRunning()
19246: {
36355:   return mRunning;
36355: }
36355: 
36355: TimeStamp
36355: nsNPAPIPluginInstance::LastStopTime()
36355: {
36355:   return mStopTime;
19246: }
19246: 
30101: NS_IMETHODIMP nsNPAPIPluginInstance::Initialize(nsIPluginInstanceOwner* aOwner, const char* aMIMEType)
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Initialize this=%p\n",this));
19246: 
29834:   mOwner = aOwner;
29834: 
29808:   if (aMIMEType) {
30101:     mMIMEType = (char*)PR_Malloc(PL_strlen(aMIMEType) + 1);
29808: 
29808:     if (mMIMEType)
30101:       PL_strcpy(mMIMEType, aMIMEType);
29808:   }
29808: 
29834:   return InitializePlugin();
19246: }
19246: 
36355: NS_IMETHODIMP nsNPAPIPluginInstance::Start()
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Start this=%p\n",this));
19246: 
36355:   if (mRunning)
19246:     return NS_OK;
19246: 
29834:   return InitializePlugin();
19246: }
19246: 
36355: NS_IMETHODIMP nsNPAPIPluginInstance::Stop()
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Stop this=%p\n",this));
19246: 
19246:   NPError error;
19246: 
19246:   // Make sure the plugin didn't leave popups enabled.
26912:   if (mPopupStates.Length() > 0) {
19246:     nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
19246: 
19246:     if (window) {
19246:       window->PopPopupControlState(openAbused);
19246:     }
19246:   }
19246: 
36355:   if (!mRunning) {
19246:     return NS_OK;
23529:   }
19246: 
29937:   // clean up all outstanding timers
29937:   for (PRUint32 i = mTimers.Length(); i > 0; i--)
29937:     UnscheduleTimer(mTimers[i - 1]->id);
29937: 
19246:   // If there's code from this plugin instance on the stack, delay the
19246:   // destroy.
19246:   if (PluginDestructionGuard::DelayDestroy(this)) {
19246:     return NS_OK;
19246:   }
19246: 
36355:   // Make sure we lock while we're writing to mRunning after we've
19246:   // started as other threads might be checking that inside a lock.
19246:   EnterAsyncPluginThreadCallLock();
36355:   mRunning = PR_FALSE;
36355:   mStopTime = TimeStamp::Now();
19246:   ExitAsyncPluginThreadCallLock();
19246: 
30212:   OnPluginDestroy(&mNPP);
19246: 
30212:   if (mCallbacks->destroy == NULL) {
21231:     return NS_ERROR_FAILURE;
23529:   }
19246: 
19246:   NPSavedData *sdata = 0;
19246: 
19246:   // clean up open streams
19246:   for (nsInstanceStream *is = mStreams; is != nsnull;) {
38785:     nsNPAPIPluginStreamListener * listener = is->mPluginStreamListener;
19246: 
19246:     nsInstanceStream *next = is->mNext;
19246:     delete is;
19246:     is = next;
19246:     mStreams = is;
19246: 
19246:     // Clean up our stream after removing it from the list because 
19246:     // it may be released and destroyed at this point.
19246:     if (listener)
19246:       listener->CleanUpStream(NPRES_USER_BREAK);
19246:   }
19246: 
30212:   NS_TRY_SAFE_CALL_RETURN(error, (*mCallbacks->destroy)(&mNPP, &sdata), mLibrary, this);
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
30212:   ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this, &mNPP, error));
19246: 
30212:   nsJSNPRuntime::OnPluginDestroy(&mNPP);
19246: 
19246:   if (error != NPERR_NO_ERROR)
19246:     return NS_ERROR_FAILURE;
19246:   else
19246:     return NS_OK;
19246: }
19246: 
19246: already_AddRefed<nsPIDOMWindow>
19246: nsNPAPIPluginInstance::GetDOMWindow()
19246: {
19246:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
21231:   if (!owner)
19246:     return nsnull;
19246: 
19246:   nsCOMPtr<nsIDocument> doc;
19246:   owner->GetDocument(getter_AddRefs(doc));
21231:   if (!doc)
19246:     return nsnull;
19246: 
19246:   nsPIDOMWindow *window = doc->GetWindow();
19246:   NS_IF_ADDREF(window);
19246: 
19246:   return window;
19246: }
19246: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetTagType(nsPluginTagType *result)
19246: {
29834:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:     if (tinfo)
29834:       return tinfo->GetTagType(result);
29834:   }
19246: 
29834:   return NS_ERROR_FAILURE;
29834: }
19246: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetAttributes(PRUint16& n, const char*const*& names,
29834:                                      const char*const*& values)
29834: {
29834:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:     if (tinfo)
29834:       return tinfo->GetAttributes(n, names, values);
29834:   }
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetParameters(PRUint16& n, const char*const*& names,
29834:                                      const char*const*& values)
29834: {
29834:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:     if (tinfo)
29834:       return tinfo->GetParameters(n, names, values);
29834:   }
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29834: nsresult
32799: nsNPAPIPluginInstance::GetMode(PRInt32 *result)
29834: {
29834:   if (mOwner)
29834:     return mOwner->GetMode(result);
29834:   else
29834:     return NS_ERROR_FAILURE;
29834: }
29834: 
29834: nsresult
29834: nsNPAPIPluginInstance::InitializePlugin()
29834: { 
19246:   PluginDestructionGuard guard(this);
19246: 
19246:   PRUint16 count = 0;
19246:   const char* const* names = nsnull;
19246:   const char* const* values = nsnull;
19246:   nsPluginTagType tagtype;
29834:   nsresult rv = GetTagType(&tagtype);
19246:   if (NS_SUCCEEDED(rv)) {
19246:     // Note: If we failed to get the tag type, we may be a full page plugin, so no arguments
29834:     rv = GetAttributes(count, names, values);
19246:     NS_ENSURE_SUCCESS(rv, rv);
19246:     
19246:     // nsPluginTagType_Object or Applet may also have PARAM tags
19246:     // Note: The arrays handed back by GetParameters() are
19246:     // crafted specially to be directly behind the arrays from GetAttributes()
19246:     // with a null entry as a separator. This is for 4.x backwards compatibility!
19246:     // see bug 111008 for details
19246:     if (tagtype != nsPluginTagType_Embed) {
19246:       PRUint16 pcount = 0;
19246:       const char* const* pnames = nsnull;
19246:       const char* const* pvalues = nsnull;    
29834:       if (NS_SUCCEEDED(GetParameters(pcount, pnames, pvalues))) {
21231:         NS_ASSERTION(!values[count], "attribute/parameter array not setup correctly for NPAPI plugins");
19246:         if (pcount)
21231:           count += ++pcount; // if it's all setup correctly, then all we need is to
21231:                              // change the count (attrs + PARAM/blank + params)
19246:       }
19246:     }
19246:   }
19246: 
19246:   // XXX Note that the NPPluginType_* enums were crafted to be
19246:   // backward compatible...
19246:   
32799:   PRInt32       mode;
30224:   const char*   mimetype;
37569:   NPError       error = NPERR_GENERIC_ERROR;
19246: 
29834:   GetMode(&mode);
29808:   GetMIMEType(&mimetype);
19246: 
19246:   // Some older versions of Flash have a bug in them
19246:   // that causes the stack to become currupt if we
29923:   // pass swliveconnect=1 in the NPP_NewProc arrays.
19246:   // See bug 149336 (UNIX), bug 186287 (Mac)
19246:   //
19246:   // The code below disables the attribute unless
19246:   // the environment variable:
19246:   // MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK
19246:   // is set.
19246:   //
19246:   // It is okay to disable this attribute because
19246:   // back in 4.x, scripting required liveconnect to
19246:   // start Java which was slow. Scripting no longer
19246:   // requires starting Java and is quick plus controled
19246:   // from the browser, so Flash now ignores this attribute.
19246:   //
19246:   // This code can not be put at the time of creating
19246:   // the array because we may need to examine the
19246:   // stream header to determine we want Flash.
19246: 
19246:   static const char flashMimeType[] = "application/x-shockwave-flash";
19246:   static const char blockedParam[] = "swliveconnect";
19246:   if (count && !PL_strcasecmp(mimetype, flashMimeType)) {
19246:     static int cachedDisableHack = 0;
19246:     if (!cachedDisableHack) {
19246:        if (PR_GetEnv("MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK"))
19246:          cachedDisableHack = -1;
19246:        else
19246:          cachedDisableHack = 1;
19246:     }
19246:     if (cachedDisableHack > 0) {
19246:       for (PRUint16 i=0; i<count; i++) {
19246:         if (!PL_strcasecmp(names[i], blockedParam)) {
19246:           // BIG FAT WARNIG:
19246:           // I'm ugly casting |const char*| to |char*| and altering it
19246:           // because I know we do malloc it values in
19246:           // http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/layout/html/base/src/nsObjectFrame.cpp&rev=1.349&root=/cvsroot#3020
19246:           // and free it at line #2096, so it couldn't be a const ptr to string literal
19246:           char *val = (char*) values[i];
19246:           if (val && *val) {
19246:             // we cannot just *val=0, it won't be free properly in such case
19246:             val[0] = '0';
19246:             val[1] = 0;
19246:           }
19246:           break;
19246:         }
19246:       }
19246:     }
19246:   }
19246: 
36355:   // Mark this instance as running before calling NPP_New because the plugin may
29834:   // call other NPAPI functions, like NPN_GetURLNotify, that assume this is set
29834:   // before returning. If the plugin returns failure, we'll clear it out below.
36355:   mRunning = PR_TRUE;
19246: 
19246:   PRBool oldVal = mInPluginInitCall;
19246:   mInPluginInitCall = PR_TRUE;
19246: 
35965:   // Need this on the stack before calling NPP_New otherwise some callbacks that
35965:   // the plugin may make could fail (NPN_HasProperty, for example).
35965:   NPPAutoPusher autopush(&mNPP);
36173:   nsresult newResult = mLibrary->NPP_New((char*)mimetype, &mNPP, (PRUint16)mode, count, (char**)names, (char**)values, NULL, &error);
36355:   if (NS_FAILED(newResult)) {
36355:     mRunning = PR_FALSE;
36010:     return newResult;
36355:   }
19246: 
19246:   mInPluginInitCall = oldVal;
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPP New called: this=%p, npp=%p, mime=%s, mode=%d, argc=%d, return=%d\n",
30212:   this, &mNPP, mimetype, mode, count, error));
19246: 
19246:   if (error != NPERR_NO_ERROR) {
36355:     mRunning = PR_FALSE;
19246:     return NS_ERROR_FAILURE;
19246:   }
19246:   
19246:   return NS_OK;
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::SetWindow(NPWindow* window)
19246: {
32019:   // NPAPI plugins don't want a SetWindow(NULL).
36355:   if (!window || !mRunning)
19246:     return NS_OK;
19246: 
19246: #if defined(MOZ_WIDGET_GTK2)
19246:   // bug 108347, flash plugin on linux doesn't like window->width <=
19246:   // 0, but Java needs wants this call.
32799:   if (!nsPluginHost::IsJavaMIMEType(mMIMEType) && window->type == NPWindowTypeWindow &&
19246:       (window->width <= 0 || window->height <= 0)) {
19246:     return NS_OK;
19246:   }
32019: #endif
19246: 
30212:   if (mCallbacks->setwindow) {
19246:     PluginDestructionGuard guard(this);
19246: 
19246:     // XXX Turns out that NPPluginWindow and NPWindow are structurally
19246:     // identical (on purpose!), so there's no need to make a copy.
19246: 
19246:     PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::SetWindow (about to call it) this=%p\n",this));
19246: 
19246:     PRBool oldVal = mInPluginInitCall;
19246:     mInPluginInitCall = PR_TRUE;
19246: 
35965:     NPPAutoPusher nppPusher(&mNPP);
35965: 
32019:     NPError error;
30212:     NS_TRY_SAFE_CALL_RETURN(error, (*mCallbacks->setwindow)(&mNPP, (NPWindow*)window), mLibrary, this);
19246: 
19246:     mInPluginInitCall = oldVal;
19246: 
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
19246:     this, window->x, window->y, window->width, window->height,
19246:     window->clipRect.top, window->clipRect.bottom, window->clipRect.left, window->clipRect.right, error));
19246:   }
19246:   return NS_OK;
19246: }
19246: 
19246: /* NOTE: the caller must free the stream listener */
19246: // Create a normal stream, one without a urlnotify callback
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::NewStreamToPlugin(nsIPluginStreamListener** listener)
19246: {
19246:   return NewNotifyStream(listener, nsnull, PR_FALSE, nsnull);
19246: }
19246: 
29834: NS_IMETHODIMP
30101: nsNPAPIPluginInstance::NewStreamFromPlugin(const char* type, const char* target,
29834:                                            nsIOutputStream* *result)
29834: {
29834:   nsPluginStreamToFile* stream = new nsPluginStreamToFile(target, mOwner);
29834:   if (!stream)
29834:     return NS_ERROR_OUT_OF_MEMORY;
29834: 
29834:   return stream->QueryInterface(kIOutputStreamIID, (void**)result);
29834: }
29834: 
19246: // Create a stream that will notify when complete
19246: nsresult nsNPAPIPluginInstance::NewNotifyStream(nsIPluginStreamListener** listener, 
19246:                                                 void* notifyData,
19246:                                                 PRBool aCallNotify,
19246:                                                 const char* aURL)
19246: {
19246:   nsNPAPIPluginStreamListener* stream = new nsNPAPIPluginStreamListener(this, notifyData, aURL);
19246:   NS_ENSURE_TRUE(stream, NS_ERROR_OUT_OF_MEMORY);
19246: 
19246:   // add it to the list
19246:   nsInstanceStream * is = new nsInstanceStream();
19246:   NS_ENSURE_TRUE(is, NS_ERROR_OUT_OF_MEMORY);
19246: 
19246:   is->mNext = mStreams;
19246:   is->mPluginStreamListener = stream;
19246:   mStreams = is;
19246:   stream->SetCallNotify(aCallNotify); // set flag in stream to call URLNotify
19246: 
19246:   NS_ADDREF(stream); // Stabilize
19246:     
19246:   nsresult res = stream->QueryInterface(kIPluginStreamListenerIID, (void**)listener);
19246: 
19246:   // Destabilize and avoid leaks. Avoid calling delete <interface pointer>
19246:   NS_RELEASE(stream);
19246: 
19246:   return res;
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::Print(NPPrint* platformPrint)
19246: {
19246:   NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
19246: 
19246:   PluginDestructionGuard guard(this);
19246: 
19246:   NPPrint* thePrint = (NPPrint *)platformPrint;
19246: 
19246:   // to be compatible with the older SDK versions and to match what
21231:   // NPAPI and other browsers do, overwrite |window.type| field with one
19246:   // more copy of |platformPrint|. See bug 113264
30212:   PRUint16 sdkmajorversion = (mCallbacks->version & 0xff00)>>8;
30212:   PRUint16 sdkminorversion = mCallbacks->version & 0x00ff;
19246:   if ((sdkmajorversion == 0) && (sdkminorversion < 11)) {
19246:     // Let's copy platformPrint bytes over to where it was supposed to be
19246:     // in older versions -- four bytes towards the beginning of the struct
19246:     // but we should be careful about possible misalignments
19246:     if (sizeof(NPWindowType) >= sizeof(void *)) {
19246:       void* source = thePrint->print.embedPrint.platformPrint;
19246:       void** destination = (void **)&(thePrint->print.embedPrint.window.type);
19246:       *destination = source;
31379:     } else {
31379:       NS_ERROR("Incompatible OS for assignment");
19246:     }
19246:   }
19246: 
30212:   if (mCallbacks->print)
30212:       NS_TRY_SAFE_CALL_VOID((*mCallbacks->print)(&mNPP, thePrint), mLibrary, this);
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPP PrintProc called: this=%p, pDC=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d]\n",
19246:   this,
19246:   platformPrint->print.embedPrint.platformPrint,
19246:   platformPrint->print.embedPrint.window.x,
19246:   platformPrint->print.embedPrint.window.y,
19246:   platformPrint->print.embedPrint.window.width,
19246:   platformPrint->print.embedPrint.window.height,
19246:   platformPrint->print.embedPrint.window.clipRect.top,
19246:   platformPrint->print.embedPrint.window.clipRect.bottom,
19246:   platformPrint->print.embedPrint.window.clipRect.left,
19246:   platformPrint->print.embedPrint.window.clipRect.right));
19246: 
19246:   return NS_OK;
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::HandleEvent(void* event, PRBool* handled)
19246: {
36355:   if (!mRunning)
19246:     return NS_OK;
19246: 
19246:   if (!event)
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   PluginDestructionGuard guard(this);
19246: 
19246:   PRInt16 result = 0;
19246:   
30212:   if (mCallbacks->event) {
32019:     mCurrentPluginEvent = event;
32799: #if defined(XP_WIN) || defined(XP_OS2)
32799:     NS_TRY_SAFE_CALL_RETURN(result, (*mCallbacks->event)(&mNPP, event), mLibrary, this);
32799: #else
32799:     result = (*mCallbacks->event)(&mNPP, event);
19246: #endif
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
32799:       ("NPP HandleEvent called: this=%p, npp=%p, event=%p, return=%d\n", 
32799:       this, &mNPP, event, result));
19246: 
19246:     *handled = result;
32019:     mCurrentPluginEvent = nsnull;
19246:   }
19246: 
19246:   return NS_OK;
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::GetValueFromPlugin(NPPVariable variable, void* value)
19246: {
38014: #if (MOZ_PLATFORM_MAEMO == 5)
34217:   // The maemo flash plugin does not remember this.  It sets the
34217:   // value, but doesn't support the get value.
34217:   if (variable == NPPVpluginWindowlessLocalBool) {
34217:     *(NPBool*)value = mWindowlessLocal;
34217:     return NS_OK;
34217:   }
34217: #endif
38126:   nsresult  res = NS_ERROR_FAILURE;
36355:   if (mCallbacks->getvalue && mRunning) {
19246:     PluginDestructionGuard guard(this);
19246: 
30212:     NS_TRY_SAFE_CALL_RETURN(res, (*mCallbacks->getvalue)(&mNPP, variable, value), mLibrary, this);
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
30212:     this, &mNPP, variable, value, res));
19246:   }
19246: 
19246:   return res;
19246: }
19246: 
19246: nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) 
19246: {
21231:   if (aNPP)
30212:     *aNPP = &mNPP;
19246:   else
19246:     return NS_ERROR_NULL_POINTER;
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult nsNPAPIPluginInstance::GetCallbacks(const NPPluginFuncs ** aCallbacks)
19246: {
21231:   if (aCallbacks)
30212:     *aCallbacks = mCallbacks;
19246:   else
19246:     return NS_ERROR_NULL_POINTER;
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: NPError nsNPAPIPluginInstance::SetWindowless(PRBool aWindowless)
19246: {
19246:   mWindowless = aWindowless;
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
34217: NPError nsNPAPIPluginInstance::SetWindowlessLocal(PRBool aWindowlessLocal)
34217: {
34217:   mWindowlessLocal = aWindowlessLocal;
34217:   return NPERR_NO_ERROR;
34217: }
34217: 
19246: NPError nsNPAPIPluginInstance::SetTransparent(PRBool aTransparent)
19246: {
19246:   mTransparent = aTransparent;
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
19246: NPError nsNPAPIPluginInstance::SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams)
19246: {
19246:   mWantsAllNetworkStreams = aWantsAllNetworkStreams;
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
19246: #ifdef XP_MACOSX
19246: void nsNPAPIPluginInstance::SetDrawingModel(NPDrawingModel aModel)
19246: {
19246:   mDrawingModel = aModel;
19246: }
19246: 
32019: void nsNPAPIPluginInstance::SetEventModel(NPEventModel aModel)
32019: {
34717:   // the event model needs to be set for the object frame immediately
34717:   nsCOMPtr<nsIPluginInstanceOwner> owner;
34717:   GetOwner(getter_AddRefs(owner));
34717:   if (!owner) {
34717:     NS_WARNING("Trying to set event model without a plugin instance owner!");
34717:     return;
34717:   }
34717: 
34717:   owner->SetEventModel(aModel);
32019: }
32019: 
32799: #endif
32799: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::GetDrawingModel(PRInt32* aModel)
32019: {
32799: #ifdef XP_MACOSX
32799:   *aModel = (PRInt32)mDrawingModel;
32799:   return NS_OK;
32799: #else
32799:   return NS_ERROR_FAILURE;
32799: #endif
32019: }
32799: 
29953: NS_IMETHODIMP
29953: nsNPAPIPluginInstance::GetJSObject(JSContext *cx, JSObject** outObject)
19246: {
19246:   NPObject *npobj = nsnull;
32799:   nsresult rv = GetValueFromPlugin(NPPVpluginScriptableNPObject, &npobj);
29953:   if (NS_FAILED(rv) || !npobj)
29953:     return NS_ERROR_FAILURE;
19246: 
30212:   *outObject = nsNPObjWrapper::GetNewOrUsed(&mNPP, cx, npobj);
19246: 
19246:   _releaseobject(npobj);
29953: 
29953:   return NS_OK;
19246: }
19246: 
29953: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::DefineJavaProperties()
19246: {
19246:   NPObject *plugin_obj = nsnull;
19246: 
19246:   // The dummy Java plugin's scriptable object is what we want to
19246:   // expose as window.Packages. And Window.Packages.java will be
19246:   // exposed as window.java.
19246: 
19246:   // Get the scriptable plugin object.
32799:   nsresult rv = GetValueFromPlugin(NPPVpluginScriptableNPObject, &plugin_obj);
19246: 
19246:   if (NS_FAILED(rv) || !plugin_obj) {
29953:     return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   // Get the NPObject wrapper for window.
30212:   NPObject *window_obj = _getwindowobject(&mNPP);
19246: 
19246:   if (!window_obj) {
19246:     _releaseobject(plugin_obj);
19246: 
29953:     return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   NPIdentifier java_id = _getstringidentifier("java");
19246:   NPIdentifier packages_id = _getstringidentifier("Packages");
19246: 
19246:   NPObject *java_obj = nsnull;
19246:   NPVariant v;
19246:   OBJECT_TO_NPVARIANT(plugin_obj, v);
19246: 
19246:   // Define the properties.
19246: 
30212:   bool ok = _setproperty(&mNPP, window_obj, packages_id, &v);
19246:   if (ok) {
30212:     ok = _getproperty(&mNPP, plugin_obj, java_id, &v);
19246: 
19246:     if (ok && NPVARIANT_IS_OBJECT(v)) {
19246:       // Set java_obj so that we properly release it at the end of
19246:       // this function.
19246:       java_obj = NPVARIANT_TO_OBJECT(v);
19246: 
30212:       ok = _setproperty(&mNPP, window_obj, java_id, &v);
19246:     }
19246:   }
19246: 
19246:   _releaseobject(window_obj);
19246:   _releaseobject(plugin_obj);
19246:   _releaseobject(java_obj);
29953: 
29953:   if (!ok)
29953:     return NS_ERROR_FAILURE;
29953: 
29953:   return NS_OK;
19246: }
19246: 
35426: nsresult
35426: nsNPAPIPluginInstance::SetCached(PRBool aCache)
35426: {
35426:   mCached = aCache;
35426:   return NS_OK;
35426: }
35426: 
29953: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::ShouldCache(PRBool* shouldCache)
32799: {
32799:   *shouldCache = mCached;
32799:   return NS_OK;
32799: }
32799: 
32799: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::IsWindowless(PRBool* isWindowless)
32799: {
32799:   *isWindowless = mWindowless;
32799:   return NS_OK;
32799: }
32799: 
32799: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::IsTransparent(PRBool* isTransparent)
32799: {
32799:   *isTransparent = mTransparent;
32799:   return NS_OK;
32799: }
32799: 
32799: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::GetFormValue(nsAString& aValue)
19246: {
19246:   aValue.Truncate();
19246: 
19246:   char *value = nsnull;
32799:   nsresult rv = GetValueFromPlugin(NPPVformValue, &value);
29953:   if (NS_FAILED(rv) || !value)
29953:     return NS_ERROR_FAILURE;
19246: 
19246:   CopyUTF8toUTF16(value, aValue);
19246: 
19246:   // NPPVformValue allocates with NPN_MemAlloc(), which uses
19246:   // nsMemory.
19246:   nsMemory::Free(value);
19246: 
19246:   return NS_OK;
19246: }
19246: 
29953: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::PushPopupsEnabledState(PRBool aEnabled)
19246: {
19246:   nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
19246:   if (!window)
29953:     return NS_ERROR_FAILURE;
19246: 
19246:   PopupControlState oldState =
19246:     window->PushPopupControlState(aEnabled ? openAllowed : openAbused,
19246:                                   PR_TRUE);
19246: 
26912:   if (!mPopupStates.AppendElement(oldState)) {
29953:     // Appending to our state stack failed, pop what we just pushed.
19246:     window->PopPopupControlState(oldState);
29953:     return NS_ERROR_FAILURE;
19246:   }
19246: 
29953:   return NS_OK;
29953: }
29953: 
29953: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::PopPopupsEnabledState()
19246: {
26912:   PRInt32 last = mPopupStates.Length() - 1;
19246: 
19246:   if (last < 0) {
19246:     // Nothing to pop.
29953:     return NS_OK;
19246:   }
19246: 
19246:   nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
19246:   if (!window)
29953:     return NS_ERROR_FAILURE;
19246: 
26912:   PopupControlState &oldState = mPopupStates[last];
19246: 
19246:   window->PopPopupControlState(oldState);
19246: 
19246:   mPopupStates.RemoveElementAt(last);
29953:   
29953:   return NS_OK;
19246: }
19246: 
29953: NS_IMETHODIMP
29953: nsNPAPIPluginInstance::GetPluginAPIVersion(PRUint16* version)
19246: {
29953:   NS_ENSURE_ARG_POINTER(version);
30212:   *version = mCallbacks->version;
29953:   return NS_OK;
19246: }
24475: 
29937: nsresult
29937: nsNPAPIPluginInstance::PrivateModeStateChanged()
24475: {
36355:   if (!mRunning)
24475:     return NS_OK;
24475:   
24475:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance informing plugin of private mode state change this=%p\n",this));
24475:   
30212:   if (mCallbacks->setvalue) {
24475:     PluginDestructionGuard guard(this);
24475:     
24475:     nsCOMPtr<nsIPrivateBrowsingService> pbs = do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
24475:     if (pbs) {
24475:       PRBool pme = PR_FALSE;
24475:       nsresult rv = pbs->GetPrivateBrowsingEnabled(&pme);
24475:       if (NS_FAILED(rv))
24475:         return rv;
24475: 
24475:       NPError error;
30212:       NS_TRY_SAFE_CALL_RETURN(error, (*mCallbacks->setvalue)(&mNPP, NPNVprivateModeBool, &pme), mLibrary, this);
24475:       return (error == NPERR_NO_ERROR) ? NS_OK : NS_ERROR_FAILURE;
24475:     }
24475:   }
24475:   return NS_ERROR_FAILURE;
24475: }
29603: 
29937: static void
29937: PluginTimerCallback(nsITimer *aTimer, void *aClosure)
29937: {
29937:   nsNPAPITimer* t = (nsNPAPITimer*)aClosure;
29937:   NPP npp = t->npp;
29937:   uint32_t id = t->id;
29937: 
29937:   (*(t->callback))(npp, id);
29937: 
29937:   // Make sure we still have an instance and the timer is still alive
29937:   // after the callback.
29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
29937:   if (!inst || !inst->TimerWithID(id, NULL))
29937:     return;
29937: 
29937:   // use UnscheduleTimer to clean up if this is a one-shot timer
29937:   PRUint32 timerType;
29937:   t->timer->GetType(&timerType);
29937:   if (timerType == nsITimer::TYPE_ONE_SHOT)
29937:       inst->UnscheduleTimer(id);
29937: }
29937: 
29937: nsNPAPITimer*
29937: nsNPAPIPluginInstance::TimerWithID(uint32_t id, PRUint32* index)
29937: {
29937:   PRUint32 len = mTimers.Length();
29937:   for (PRUint32 i = 0; i < len; i++) {
29937:     if (mTimers[i]->id == id) {
29937:       if (index)
29937:         *index = i;
29937:       return mTimers[i];
29937:     }
29937:   }
29937:   return nsnull;
29937: }
29937: 
29937: uint32_t
29937: nsNPAPIPluginInstance::ScheduleTimer(uint32_t interval, NPBool repeat, void (*timerFunc)(NPP npp, uint32_t timerID))
29937: {
29937:   nsNPAPITimer *newTimer = new nsNPAPITimer();
29937: 
30212:   newTimer->npp = &mNPP;
29937: 
29937:   // generate ID that is unique to this instance
29937:   uint32_t uniqueID = mTimers.Length();
29937:   while ((uniqueID == 0) || TimerWithID(uniqueID, NULL))
29937:     uniqueID++;
29937:   newTimer->id = uniqueID;
29937: 
29937:   // create new xpcom timer, scheduled correctly
29937:   nsresult rv;
29937:   nsCOMPtr<nsITimer> xpcomTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
29937:   if (NS_FAILED(rv))
29937:     return 0;
29937:   const short timerType = (repeat ? (short)nsITimer::TYPE_REPEATING_SLACK : (short)nsITimer::TYPE_ONE_SHOT);
29937:   xpcomTimer->InitWithFuncCallback(PluginTimerCallback, newTimer, interval, timerType);
29937:   newTimer->timer = xpcomTimer;
29937: 
29937:   // save callback function
29937:   newTimer->callback = timerFunc;
29937: 
29937:   // add timer to timers array
29937:   mTimers.AppendElement(newTimer);
29937: 
29937:   return newTimer->id;
29937: }
29937: 
29937: void
29937: nsNPAPIPluginInstance::UnscheduleTimer(uint32_t timerID)
29937: {
29937:   // find the timer struct by ID
29937:   PRUint32 index;
29937:   nsNPAPITimer* t = TimerWithID(timerID, &index);
29937:   if (!t)
29937:     return;
29937: 
29937:   // cancel the timer
29937:   t->timer->Cancel();
29937: 
29937:   // remove timer struct from array
29937:   mTimers.RemoveElementAt(index);
29937: 
29937:   // delete timer
29937:   delete t;
29937: }
29937: 
32019: // Show the context menu at the location for the current event.
32019: // This can only be called from within an NPP_SendEvent call.
32019: NPError
32019: nsNPAPIPluginInstance::PopUpContextMenu(NPMenu* menu)
32019: {
32019:   if (mOwner && mCurrentPluginEvent)
32019:     return mOwner->ShowNativeContextMenu(menu, mCurrentPluginEvent);
32019: 
32019:   return NPERR_GENERIC_ERROR;
32019: }
32019: 
32019: NPBool
32019: nsNPAPIPluginInstance::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                                     double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019:   if (mOwner)
32019:     return mOwner->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY, destSpace);
32019: 
32019:   return PR_FALSE;
32019: }
32019: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetDOMElement(nsIDOMElement* *result)
29834: {
29834:   if (!mOwner) {
29834:     *result = nsnull;
29834:     return NS_ERROR_FAILURE;
29834:   }
29834: 
29952:   nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:   if (tinfo)
29834:     return tinfo->GetDOMElement(result);
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29603: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::InvalidateRect(NPRect *invalidRect)
29603: {
29603:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29603:   if (!owner)
29603:     return NS_ERROR_FAILURE;
29603: 
29603:   return owner->InvalidateRect(invalidRect);
29603: }
29603: 
29603: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::InvalidateRegion(NPRegion invalidRegion)
29603: {
29603:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29603:   if (!owner)
29603:     return NS_ERROR_FAILURE;
29603: 
29603:   return owner->InvalidateRegion(invalidRegion);
29603: }
29603: 
29603: NS_IMETHODIMP
29603: nsNPAPIPluginInstance::ForceRedraw()
29603: {
29603:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29603:   if (!owner)
29603:     return NS_ERROR_FAILURE;
29603: 
29603:   return owner->ForceRedraw();
29603: }
29808: 
29808: NS_IMETHODIMP
30224: nsNPAPIPluginInstance::GetMIMEType(const char* *result)
29808: {
29808:   if (!mMIMEType)
29808:     *result = "";
29808:   else
29808:     *result = mMIMEType;
29808: 
29808:   return NS_OK;
29808: }
29808: 
29808: NS_IMETHODIMP
29808: nsNPAPIPluginInstance::GetJSContext(JSContext* *outContext)
29808: {
29808:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29808:   if (!owner)
29808:     return NS_ERROR_FAILURE;
29808: 
29808:   *outContext = NULL;
29808:   nsCOMPtr<nsIDocument> document;
29808: 
29808:   nsresult rv = owner->GetDocument(getter_AddRefs(document));
29808: 
29808:   if (NS_SUCCEEDED(rv) && document) {
29808:     nsIScriptGlobalObject *global = document->GetScriptGlobalObject();
29808: 
29808:     if (global) {
29808:       nsIScriptContext *context = global->GetContext();
29808: 
29808:       if (context) {
29808:         *outContext = (JSContext*) context->GetNativeContext();
29808:       }
29808:     }
29808:   }
29808: 
29808:   return rv;
29808: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::GetOwner(nsIPluginInstanceOwner **aOwner)
29834: {
29834:   NS_ENSURE_ARG_POINTER(aOwner);
29834:   *aOwner = mOwner;
29834:   NS_IF_ADDREF(mOwner);
29834:   return (mOwner ? NS_OK : NS_ERROR_FAILURE);
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::SetOwner(nsIPluginInstanceOwner *aOwner)
29834: {
29834:   mOwner = aOwner;
29834:   return NS_OK;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::ShowStatus(const char* message)
29834: {
29834:   if (mOwner)
29834:     return mOwner->ShowStatus(message);
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::InvalidateOwner()
29834: {
29834:   mOwner = nsnull;
29834: 
29834:   return NS_OK;
29834: }
