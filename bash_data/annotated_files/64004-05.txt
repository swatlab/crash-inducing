32381: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
32381: /* vim:expandtab:shiftwidth=2:tabstop=2:
32381:  */
32381: /* ***** BEGIN LICENSE BLOCK *****
32381:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32381:  *
32381:  * The contents of this file are subject to the Mozilla Public License Version
32381:  * 1.1 (the "License"); you may not use this file except in compliance with
32381:  * the License. You may obtain a copy of the License at
32381:  * http://www.mozilla.org/MPL/
32381:  *
32381:  * Software distributed under the License is distributed on an "AS IS" basis,
32381:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32381:  * for the specific language governing rights and limitations under the
32381:  * License.
32381:  *
32381:  * The Original Code is mozilla.org code.
32381:  *
32381:  * The Initial Developer of the Original Code is
63247:  * Mozilla Foundation.
32381:  * Portions created by the Initial Developer are Copyright (C) 2009
32381:  * the Initial Developer. All Rights Reserved.
32381:  *
32381:  * Contributor(s):
32381:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
32381:  *
32381:  * Alternatively, the contents of this file may be used under the terms of
32381:  * either the GNU General Public License Version 2 or later (the "GPL"), or
32381:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32381:  * in which case the provisions of the GPL or the LGPL are applicable instead
32381:  * of those above. If you wish to allow use of your version of this file only
32381:  * under the terms of either the GPL or the LGPL, and not to allow others to
32381:  * use your version of this file under the terms of the MPL, indicate your
32381:  * decision by deleting the provisions above and replace them with the notice
32381:  * and other provisions required by the GPL or the LGPL. If you do not delete
32381:  * the provisions above, a recipient may use your version of this file under
32381:  * the terms of any one of the MPL, the GPL or the LGPL.
32381:  *
32381:  * ***** END LICENSE BLOCK ***** */
32381: 
32381: #include "nsWinUtils.h"
32381: 
32381: #include "nsIWinAccessNode.h"
63261: #include "nsRootAccessible.h"
63261: 
32381: #include "nsArrayUtils.h"
54220: #include "nsIDocShellTreeItem.h"
32381: 
32381: HRESULT
32381: nsWinUtils::ConvertToIA2Array(nsIArray *aGeckoArray, IUnknown ***aIA2Array,
32381:                               long *aIA2ArrayLen)
32381: {
32381:   *aIA2Array = NULL;
32381:   *aIA2ArrayLen = 0;
32381: 
33454:   if (!aGeckoArray)
33454:     return S_FALSE;
33454: 
32381:   PRUint32 length = 0;
32381:   nsresult rv = aGeckoArray->GetLength(&length);
32381:   if (NS_FAILED(rv))
32381:     return GetHRESULT(rv);
32381: 
33454:   if (length == 0)
33454:     return S_FALSE;
33454: 
32381:   *aIA2Array =
54687:     static_cast<IUnknown**>(::CoTaskMemAlloc((length) * sizeof(IUnknown*)));
32381:   if (!*aIA2Array)
32381:     return E_OUTOFMEMORY;
32381: 
32381:   PRUint32 idx = 0;
32381:   for (; idx < length; ++idx) {
32381:     nsCOMPtr<nsIWinAccessNode> winAccessNode =
32381:       do_QueryElementAt(aGeckoArray, idx, &rv);
32381:     if (NS_FAILED(rv))
32381:       break;
32381: 
32381:     void *instancePtr = NULL;
32381:     nsresult rv = winAccessNode->QueryNativeInterface(IID_IUnknown,
32381:                                                       &instancePtr);
32381:     if (NS_FAILED(rv))
32381:       break;
32381: 
32381:     (*aIA2Array)[idx] = static_cast<IUnknown*>(instancePtr);
32381:   }
32381: 
32381:   if (NS_FAILED(rv)) {
32381:     for (PRUint32 idx2 = 0; idx2 < idx; idx2++) {
32381:       (*aIA2Array)[idx2]->Release();
32381:       (*aIA2Array)[idx2] = NULL;
32381:     }
32381: 
54687:     ::CoTaskMemFree(*aIA2Array);
32381:     return GetHRESULT(rv);
32381:   }
32381: 
32381:   *aIA2ArrayLen = length;
32381:   return S_OK;
32381: }
54220: 
64004: bool
64004: nsWinUtils::MaybeStartWindowEmulation()
64004: {
64004:   // Register window class that'll be used for document accessibles associated
64004:   // with tabs.
64004:   if (IsWindowEmulationFor(0)) {
64004:     RegisterNativeWindow(kClassNameTabContent);
64004:     nsAccessNodeWrap::sHWNDCache.Init(4);
64004:     return true;
64004:   }
64004:   return false;
64004: }
64004: 
64004: void
64004: nsWinUtils::ShutdownWindowEmulation()
64004: {
64004:   // Unregister window call that's used for document accessibles associated
64004:   // with tabs.
64004:   if (IsWindowEmulationFor(0))
64004:     ::UnregisterClassW(kClassNameTabContent, GetModuleHandle(NULL));
64004: }
64004: 
64004: bool
64004: nsWinUtils::IsWindowEmulationStarted()
64004: {
64004:   return nsAccessNodeWrap::sHWNDCache.IsInitialized();
64004: }
64004: 
54220: void
54220: nsWinUtils::RegisterNativeWindow(LPCWSTR aWindowClass)
54220: {
54220:   WNDCLASSW wc;
54220:   wc.style = CS_GLOBALCLASS;
54220:   wc.lpfnWndProc = nsAccessNodeWrap::WindowProc;
54220:   wc.cbClsExtra = 0;
54220:   wc.cbWndExtra = 0;
54220:   wc.hInstance = GetModuleHandle(NULL);
54220:   wc.hIcon = NULL;
54220:   wc.hCursor = NULL;
54220:   wc.hbrBackground = NULL;
54220:   wc.lpszMenuName = NULL;
54220:   wc.lpszClassName = aWindowClass;
54220:   ::RegisterClassW(&wc);
54220: }
54220: 
54220: HWND
63261: nsWinUtils::CreateNativeWindow(LPCWSTR aWindowClass, HWND aParentWnd,
63261:                                int aX, int aY, int aWidth, int aHeight,
63261:                                bool aIsActive)
54220: {
63261:   return ::CreateWindowExW(WS_EX_TRANSPARENT, aWindowClass,
54220:                            L"NetscapeDispatchWnd",
63261:                            WS_CHILD | (aIsActive ? WS_VISIBLE : 0),
63261:                            aX, aY, aWidth, aHeight,
54220:                            aParentWnd,
54220:                            NULL,
54220:                            GetModuleHandle(NULL),
54220:                            NULL);
54220: }
54220: 
63261: void
63261: nsWinUtils::ShowNativeWindow(HWND aWnd)
63261: {
63261:   ::ShowWindow(aWnd, SW_SHOW);
63261: }
63261: 
63261: void
63261: nsWinUtils::HideNativeWindow(HWND aWnd)
63261: {
63261:   ::SetWindowPos(aWnd, NULL, 0, 0, 0, 0,
63261:                  SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE |
63261:                  SWP_NOZORDER | SWP_NOACTIVATE);
63261: }
63261: 
54220: bool
64004: nsWinUtils::IsWindowEmulationFor(LPCWSTR kModuleHandle)
54220: {
63261:   return kModuleHandle ? ::GetModuleHandleW(kModuleHandle) :
63261:     ::GetModuleHandleW(kJAWSModuleHandle) ||
54274:     ::GetModuleHandleW(kWEModuleHandle)  ||
63261:     ::GetModuleHandleW(kDolphinModuleHandle);
54220: }
54220: 
54220: bool
54220: nsWinUtils::IsTabDocument(nsIDocument* aDocumentNode)
54220: {
54220:   nsCOMPtr<nsISupports> container = aDocumentNode->GetContainer();
54220:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
54220: 
54220:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
54220:   treeItem->GetParent(getter_AddRefs(parentTreeItem));
54220: 
54220:   nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
54220:   treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
54220: 
54220:   return parentTreeItem == rootTreeItem;
54220: }
