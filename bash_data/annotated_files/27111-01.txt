    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript API.
    1:  */
    1: #include <ctype.h>
    1: #include <stdarg.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdate.h"
    1: #include "jsdtoa.h"
    1: #include "jsemit.h"
    1: #include "jsexn.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
 6464: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsmath.h"
    1: #include "jsnum.h"
20092: #include "json.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsregexp.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
22652: #include "jsdbgapi.h"
    1: #include "prmjtime.h"
18989: #include "jsstaticcheck.h"
    1: 
    1: #if JS_HAS_FILE_OBJECT
    1: #include "jsfile.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #ifdef HAVE_VA_LIST_AS_ARRAY
    1: #define JS_ADDRESSOF_VA_LIST(ap) ((va_list *)(ap))
    1: #else
    1: #define JS_ADDRESSOF_VA_LIST(ap) (&(ap))
    1: #endif
    1: 
 6082: #if defined(JS_THREADSAFE)
 6082: #define CHECK_REQUEST(cx)                                                   \
 6082:     JS_ASSERT((cx)->requestDepth || (cx)->thread == (cx)->runtime->gcThread)
    1: #else
    1: #define CHECK_REQUEST(cx)       ((void)0)
    1: #endif
    1: 
25901: /* Check that we can cast JSObject* as jsval without tag bit manipulations. */
25901: JS_STATIC_ASSERT(JSVAL_OBJECT == 0);
25901: 
25901: /* Check that JSVAL_TRACE_KIND works. */
25901: JS_STATIC_ASSERT(JSVAL_TRACE_KIND(JSVAL_OBJECT) == JSTRACE_OBJECT);
25901: JS_STATIC_ASSERT(JSVAL_TRACE_KIND(JSVAL_DOUBLE) == JSTRACE_DOUBLE);
25901: JS_STATIC_ASSERT(JSVAL_TRACE_KIND(JSVAL_STRING) == JSTRACE_STRING);
25901: 
    1: JS_PUBLIC_API(int64)
    1: JS_Now()
    1: {
    1:     return PRMJ_Now();
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetNaNValue(JSContext *cx)
    1: {
    1:     return DOUBLE_TO_JSVAL(cx->runtime->jsNaN);
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetNegativeInfinityValue(JSContext *cx)
    1: {
    1:     return DOUBLE_TO_JSVAL(cx->runtime->jsNegativeInfinity);
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetPositiveInfinityValue(JSContext *cx)
    1: {
    1:     return DOUBLE_TO_JSVAL(cx->runtime->jsPositiveInfinity);
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetEmptyStringValue(JSContext *cx)
    1: {
    1:     return STRING_TO_JSVAL(cx->runtime->emptyString);
    1: }
    1: 
    1: static JSBool
    1: TryArgumentFormatter(JSContext *cx, const char **formatp, JSBool fromJS,
    1:                      jsval **vpp, va_list *app)
    1: {
    1:     const char *format;
    1:     JSArgumentFormatMap *map;
    1: 
    1:     format = *formatp;
    1:     for (map = cx->argumentFormatMap; map; map = map->next) {
    1:         if (!strncmp(format, map->format, map->length)) {
    1:             *formatp = format + map->length;
    1:             return map->formatter(cx, format, fromJS, vpp, app);
    1:         }
    1:     }
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_CHAR, format);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ConvertArguments(JSContext *cx, uintN argc, jsval *argv, const char *format,
    1:                     ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, format);
    1:     ok = JS_ConvertArgumentsVA(cx, argc, argv, format, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ConvertArgumentsVA(JSContext *cx, uintN argc, jsval *argv,
    1:                       const char *format, va_list ap)
    1: {
    1:     jsval *sp;
    1:     JSBool required;
    1:     char c;
    1:     JSFunction *fun;
    1:     jsdouble d;
    1:     JSString *str;
    1:     JSObject *obj;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     sp = argv;
    1:     required = JS_TRUE;
    1:     while ((c = *format++) != '\0') {
    1:         if (isspace(c))
    1:             continue;
    1:         if (c == '/') {
    1:             required = JS_FALSE;
    1:             continue;
    1:         }
    1:         if (sp == argv + argc) {
    1:             if (required) {
    1:                 fun = js_ValueToFunction(cx, &argv[-2], 0);
    1:                 if (fun) {
    1:                     char numBuf[12];
    1:                     JS_snprintf(numBuf, sizeof numBuf, "%u", argc);
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                          JSMSG_MORE_ARGS_NEEDED,
    1:                                          JS_GetFunctionName(fun), numBuf,
    1:                                          (argc == 1) ? "" : "s");
    1:                 }
    1:                 return JS_FALSE;
    1:             }
    1:             break;
    1:         }
    1:         switch (c) {
    1:           case 'b':
10449:             *va_arg(ap, JSBool *) = js_ValueToBoolean(*sp);
    1:             break;
    1:           case 'c':
12694:             if (!JS_ValueToUint16(cx, *sp, va_arg(ap, uint16 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'i':
12681:             if (!JS_ValueToECMAInt32(cx, *sp, va_arg(ap, int32 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'u':
12681:             if (!JS_ValueToECMAUint32(cx, *sp, va_arg(ap, uint32 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'j':
12694:             if (!JS_ValueToInt32(cx, *sp, va_arg(ap, int32 *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'd':
12694:             if (!JS_ValueToNumber(cx, *sp, va_arg(ap, jsdouble *)))
    1:                 return JS_FALSE;
    1:             break;
    1:           case 'I':
12694:             if (!JS_ValueToNumber(cx, *sp, &d))
    1:                 return JS_FALSE;
    1:             *va_arg(ap, jsdouble *) = js_DoubleToInteger(d);
    1:             break;
    1:           case 's':
    1:           case 'S':
    1:           case 'W':
    1:             str = js_ValueToString(cx, *sp);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:             *sp = STRING_TO_JSVAL(str);
    1:             if (c == 's') {
    1:                 const char *bytes = js_GetStringBytes(cx, str);
    1:                 if (!bytes)
    1:                     return JS_FALSE;
    1:                 *va_arg(ap, const char **) = bytes;
    1:             } else if (c == 'W') {
    1:                 const jschar *chars = js_GetStringChars(cx, str);
    1:                 if (!chars)
    1:                     return JS_FALSE;
    1:                 *va_arg(ap, const jschar **) = chars;
    1:             } else {
    1:                 *va_arg(ap, JSString **) = str;
    1:             }
    1:             break;
    1:           case 'o':
    1:             if (!js_ValueToObject(cx, *sp, &obj))
    1:                 return JS_FALSE;
    1:             *sp = OBJECT_TO_JSVAL(obj);
    1:             *va_arg(ap, JSObject **) = obj;
    1:             break;
    1:           case 'f':
    1:             obj = js_ValueToFunctionObject(cx, sp, 0);
    1:             if (!obj)
    1:                 return JS_FALSE;
10574:             *sp = OBJECT_TO_JSVAL(obj);
    1:             *va_arg(ap, JSFunction **) = (JSFunction *) JS_GetPrivate(cx, obj);
    1:             break;
    1:           case 'v':
    1:             *va_arg(ap, jsval *) = *sp;
    1:             break;
    1:           case '*':
    1:             break;
    1:           default:
    1:             format--;
    1:             if (!TryArgumentFormatter(cx, &format, JS_TRUE, &sp,
    1:                                       JS_ADDRESSOF_VA_LIST(ap))) {
    1:                 return JS_FALSE;
    1:             }
    1:             /* NB: the formatter already updated sp, so we continue here. */
    1:             continue;
    1:         }
    1:         sp++;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(jsval *)
    1: JS_PushArguments(JSContext *cx, void **markp, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     jsval *argv;
    1: 
    1:     va_start(ap, format);
    1:     argv = JS_PushArgumentsVA(cx, markp, format, ap);
    1:     va_end(ap);
    1:     return argv;
    1: }
    1: 
    1: JS_PUBLIC_API(jsval *)
    1: JS_PushArgumentsVA(JSContext *cx, void **markp, const char *format, va_list ap)
    1: {
    1:     uintN argc;
    1:     jsval *argv, *sp;
    1:     char c;
    1:     const char *cp;
    1:     JSString *str;
    1:     JSFunction *fun;
    1:     JSStackHeader *sh;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     *markp = NULL;
    1:     argc = 0;
    1:     for (cp = format; (c = *cp) != '\0'; cp++) {
    1:         /*
    1:          * Count non-space non-star characters as individual jsval arguments.
    1:          * This may over-allocate stack, but we'll fix below.
    1:          */
    1:         if (isspace(c) || c == '*')
    1:             continue;
    1:         argc++;
    1:     }
24499:     js_LeaveTrace(cx);
    1:     sp = js_AllocStack(cx, argc, markp);
    1:     if (!sp)
    1:         return NULL;
    1:     argv = sp;
    1:     while ((c = *format++) != '\0') {
    1:         if (isspace(c) || c == '*')
    1:             continue;
    1:         switch (c) {
    1:           case 'b':
    1:             *sp = BOOLEAN_TO_JSVAL((JSBool) va_arg(ap, int));
    1:             break;
    1:           case 'c':
    1:             *sp = INT_TO_JSVAL((uint16) va_arg(ap, unsigned int));
    1:             break;
    1:           case 'i':
    1:           case 'j':
12850:             /*
12850:              * Use JS_New{Double,Number}Value here and in the next two cases,
12850:              * not js_New{Double,Number}InRootedValue, as sp may point to an
12850:              * unrooted location.
12850:              */
12850:             if (!JS_NewNumberValue(cx, (jsdouble) va_arg(ap, int32), sp))
    1:                 goto bad;
    1:             break;
    1:           case 'u':
12850:             if (!JS_NewNumberValue(cx, (jsdouble) va_arg(ap, uint32), sp))
    1:                 goto bad;
    1:             break;
    1:           case 'd':
    1:           case 'I':
15512:             if (!JS_NewDoubleValue(cx, va_arg(ap, jsdouble), sp))
    1:                 goto bad;
    1:             break;
    1:           case 's':
    1:             str = JS_NewStringCopyZ(cx, va_arg(ap, char *));
    1:             if (!str)
    1:                 goto bad;
    1:             *sp = STRING_TO_JSVAL(str);
    1:             break;
    1:           case 'W':
    1:             str = JS_NewUCStringCopyZ(cx, va_arg(ap, jschar *));
    1:             if (!str)
    1:                 goto bad;
    1:             *sp = STRING_TO_JSVAL(str);
    1:             break;
    1:           case 'S':
    1:             str = va_arg(ap, JSString *);
    1:             *sp = STRING_TO_JSVAL(str);
    1:             break;
    1:           case 'o':
    1:             *sp = OBJECT_TO_JSVAL(va_arg(ap, JSObject *));
    1:             break;
    1:           case 'f':
    1:             fun = va_arg(ap, JSFunction *);
13427:             *sp = fun ? OBJECT_TO_JSVAL(FUN_OBJECT(fun)) : JSVAL_NULL;
    1:             break;
    1:           case 'v':
    1:             *sp = va_arg(ap, jsval);
    1:             break;
    1:           default:
    1:             format--;
    1:             if (!TryArgumentFormatter(cx, &format, JS_FALSE, &sp,
    1:                                       JS_ADDRESSOF_VA_LIST(ap))) {
    1:                 goto bad;
    1:             }
    1:             /* NB: the formatter already updated sp, so we continue here. */
    1:             continue;
    1:         }
    1:         sp++;
    1:     }
    1: 
    1:     /*
    1:      * We may have overallocated stack due to a multi-character format code
    1:      * handled by a JSArgumentFormatter.  Give back that stack space!
    1:      */
    1:     JS_ASSERT(sp <= argv + argc);
    1:     if (sp < argv + argc) {
    1:         /* Return slots not pushed to the current stack arena. */
    1:         cx->stackPool.current->avail = (jsuword)sp;
    1: 
    1:         /* Reduce the count of slots the GC will scan in this stack segment. */
    1:         sh = cx->stackHeaders;
    1:         JS_ASSERT(JS_STACK_SEGMENT(sh) + sh->nslots == argv + argc);
    1:         sh->nslots -= argc - (sp - argv);
    1:     }
    1:     return argv;
    1: 
    1: bad:
    1:     js_FreeStack(cx, *markp);
    1:     return NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_PopArguments(JSContext *cx, void *mark)
    1: {
    1:     CHECK_REQUEST(cx);
24499:     JS_ASSERT_NOT_ON_TRACE(cx);
    1:     js_FreeStack(cx, mark);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_AddArgumentFormatter(JSContext *cx, const char *format,
    1:                         JSArgumentFormatter formatter)
    1: {
    1:     size_t length;
    1:     JSArgumentFormatMap **mpp, *map;
    1: 
    1:     length = strlen(format);
    1:     mpp = &cx->argumentFormatMap;
    1:     while ((map = *mpp) != NULL) {
    1:         /* Insert before any shorter string to match before prefixes. */
    1:         if (map->length < length)
    1:             break;
    1:         if (map->length == length && !strcmp(map->format, format))
    1:             goto out;
    1:         mpp = &map->next;
    1:     }
    1:     map = (JSArgumentFormatMap *) JS_malloc(cx, sizeof *map);
    1:     if (!map)
    1:         return JS_FALSE;
    1:     map->format = format;
    1:     map->length = length;
    1:     map->next = *mpp;
    1:     *mpp = map;
    1: out:
    1:     map->formatter = formatter;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_RemoveArgumentFormatter(JSContext *cx, const char *format)
    1: {
    1:     size_t length;
    1:     JSArgumentFormatMap **mpp, *map;
    1: 
    1:     length = strlen(format);
    1:     mpp = &cx->argumentFormatMap;
    1:     while ((map = *mpp) != NULL) {
    1:         if (map->length == length && !strcmp(map->format, format)) {
    1:             *mpp = map->next;
    1:             JS_free(cx, map);
    1:             return;
    1:         }
    1:         mpp = &map->next;
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ConvertValue(JSContext *cx, jsval v, JSType type, jsval *vp)
    1: {
10449:     JSBool ok;
    1:     JSObject *obj;
    1:     JSString *str;
    1:     jsdouble d, *dp;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     switch (type) {
    1:       case JSTYPE_VOID:
    1:         *vp = JSVAL_VOID;
    1:         ok = JS_TRUE;
    1:         break;
    1:       case JSTYPE_OBJECT:
    1:         ok = js_ValueToObject(cx, v, &obj);
    1:         if (ok)
    1:             *vp = OBJECT_TO_JSVAL(obj);
    1:         break;
    1:       case JSTYPE_FUNCTION:
    1:         *vp = v;
    1:         obj = js_ValueToFunctionObject(cx, vp, JSV2F_SEARCH_STACK);
    1:         ok = (obj != NULL);
    1:         break;
    1:       case JSTYPE_STRING:
    1:         str = js_ValueToString(cx, v);
    1:         ok = (str != NULL);
    1:         if (ok)
    1:             *vp = STRING_TO_JSVAL(str);
    1:         break;
    1:       case JSTYPE_NUMBER:
12694:         ok = JS_ValueToNumber(cx, v, &d);
    1:         if (ok) {
12850:             dp = js_NewWeaklyRootedDouble(cx, d);
    1:             ok = (dp != NULL);
    1:             if (ok)
    1:                 *vp = DOUBLE_TO_JSVAL(dp);
    1:         }
    1:         break;
    1:       case JSTYPE_BOOLEAN:
11891:         *vp = BOOLEAN_TO_JSVAL(js_ValueToBoolean(v));
10449:         return JS_TRUE;
    1:       default: {
    1:         char numBuf[12];
    1:         JS_snprintf(numBuf, sizeof numBuf, "%d", (int)type);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_TYPE,
    1:                              numBuf);
    1:         ok = JS_FALSE;
    1:         break;
    1:       }
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToObject(JSContext *cx, jsval v, JSObject **objp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ValueToObject(cx, v, objp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_ValueToFunction(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ValueToFunction(cx, &v, JSV2F_SEARCH_STACK);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_ValueToConstructor(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ValueToFunction(cx, &v, JSV2F_SEARCH_STACK);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_ValueToString(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ValueToString(cx, v);
    1: }
    1: 
21482: JS_PUBLIC_API(JSString *)
21482: JS_ValueToSource(JSContext *cx, jsval v)
21482: {
21482:     CHECK_REQUEST(cx);
21482:     return js_ValueToSource(cx, v);
21482: }
21482: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToNumber(JSContext *cx, jsval v, jsdouble *dp)
    1: {
12694:     JSTempValueRooter tvr;
12694: 
    1:     CHECK_REQUEST(cx);
12694:     JS_PUSH_SINGLE_TEMP_ROOT(cx, v, &tvr);
12694:     *dp = js_ValueToNumber(cx, &tvr.u.value);
12694:     JS_POP_TEMP_ROOT(cx, &tvr);
12694:     return !JSVAL_IS_NULL(tvr.u.value);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToECMAInt32(JSContext *cx, jsval v, int32 *ip)
    1: {
12681:     JSTempValueRooter tvr;
12681: 
    1:     CHECK_REQUEST(cx);
12681:     JS_PUSH_SINGLE_TEMP_ROOT(cx, v, &tvr);
12681:     *ip = js_ValueToECMAInt32(cx, &tvr.u.value);
12681:     JS_POP_TEMP_ROOT(cx, &tvr);
12694:     return !JSVAL_IS_NULL(tvr.u.value);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToECMAUint32(JSContext *cx, jsval v, uint32 *ip)
    1: {
12681:     JSTempValueRooter tvr;
12681: 
    1:     CHECK_REQUEST(cx);
12681:     JS_PUSH_SINGLE_TEMP_ROOT(cx, v, &tvr);
12681:     *ip = js_ValueToECMAUint32(cx, &tvr.u.value);
12681:     JS_POP_TEMP_ROOT(cx, &tvr);
12694:     return !JSVAL_IS_NULL(tvr.u.value);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToInt32(JSContext *cx, jsval v, int32 *ip)
    1: {
12694:     JSTempValueRooter tvr;
12694: 
    1:     CHECK_REQUEST(cx);
12694:     JS_PUSH_SINGLE_TEMP_ROOT(cx, v, &tvr);
12694:     *ip = js_ValueToInt32(cx, &tvr.u.value);
12694:     JS_POP_TEMP_ROOT(cx, &tvr);
12694:     return !JSVAL_IS_NULL(tvr.u.value);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToUint16(JSContext *cx, jsval v, uint16 *ip)
    1: {
12694:     JSTempValueRooter tvr;
12694: 
    1:     CHECK_REQUEST(cx);
12694:     JS_PUSH_SINGLE_TEMP_ROOT(cx, v, &tvr);
12694:     *ip = js_ValueToUint16(cx, &tvr.u.value);
12694:     JS_POP_TEMP_ROOT(cx, &tvr);
12694:     return !JSVAL_IS_NULL(tvr.u.value);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToBoolean(JSContext *cx, jsval v, JSBool *bp)
    1: {
    1:     CHECK_REQUEST(cx);
10449:     *bp = js_ValueToBoolean(v);
10449:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSType)
    1: JS_TypeOfValue(JSContext *cx, jsval v)
    1: {
    1:     JSType type;
    1:     JSObject *obj;
    1:     JSObjectOps *ops;
    1:     JSClass *clasp;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     if (JSVAL_IS_OBJECT(v)) {
    1:         type = JSTYPE_OBJECT;           /* XXXbe JSTYPE_NULL for JS2 */
    1:         obj = JSVAL_TO_OBJECT(v);
    1:         if (obj) {
14292:             JSObject *wrapped;
14292: 
14292:             wrapped = js_GetWrappedObject(cx, obj);
14292:             if (wrapped)
14292:                 obj = wrapped;
14292: 
    1:             ops = obj->map->ops;
    1: #if JS_HAS_XML_SUPPORT
26187:             if (ops == &js_XMLObjectOps) {
    1:                 type = JSTYPE_XML;
    1:             } else
    1: #endif
    1:             {
    1:                 /*
    1:                  * ECMA 262, 11.4.3 says that any native object that implements
26059:                  * [[Call]] should be of type "function". However, RegExp is of
26059:                  * type "object", not "function", for Web compatibility.
    1:                  */
    1:                 clasp = OBJ_GET_CLASS(cx, obj);
    1:                 if ((ops == &js_ObjectOps)
    1:                     ? (clasp->call
    1:                        ? clasp == &js_ScriptClass
    1:                        : clasp == &js_FunctionClass)
    1:                     : ops->call != NULL) {
    1:                     type = JSTYPE_FUNCTION;
    1:                 } else {
    1: #ifdef NARCISSUS
19712:                     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
19712: 
    1:                     if (!OBJ_GET_PROPERTY(cx, obj,
    1:                                           ATOM_TO_JSID(cx->runtime->atomState
21471:                                                        .__call__Atom),
    1:                                           &v)) {
    1:                         JS_ClearPendingException(cx);
    1:                     } else if (VALUE_IS_FUNCTION(cx, v)) {
    1:                         type = JSTYPE_FUNCTION;
    1:                     }
    1: #endif
    1:                 }
    1:             }
    1:         }
    1:     } else if (JSVAL_IS_NUMBER(v)) {
    1:         type = JSTYPE_NUMBER;
    1:     } else if (JSVAL_IS_STRING(v)) {
    1:         type = JSTYPE_STRING;
    1:     } else if (JSVAL_IS_BOOLEAN(v)) {
    1:         type = JSTYPE_BOOLEAN;
    1:     } else {
    1:         type = JSTYPE_VOID;
    1:     }
    1:     return type;
    1: }
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetTypeName(JSContext *cx, JSType type)
    1: {
    1:     if ((uintN)type >= (uintN)JSTYPE_LIMIT)
    1:         return NULL;
 4342:     return JS_TYPE_STR(type);
    1: }
    1: 
    1: /************************************************************************/
    1: 
 8893: /*
 8893:  * Has a new runtime ever been created?  This flag is used to detect unsafe
 8893:  * changes to js_CStringsAreUTF8 after a runtime has been created, and to
 8893:  * ensure that "first checks" on runtime creation are run only once.
 8893:  */
 8893: #ifdef DEBUG
 8893: static JSBool js_NewRuntimeWasCalled = JS_FALSE;
 8893: #endif
 8893: 
    1: JS_PUBLIC_API(JSRuntime *)
    1: JS_NewRuntime(uint32 maxbytes)
    1: {
    1:     JSRuntime *rt;
    1: 
    1: #ifdef DEBUG
 8893:     if (!js_NewRuntimeWasCalled) {
    1:         /*
    1:          * This code asserts that the numbers associated with the error names
    1:          * in jsmsg.def are monotonically increasing.  It uses values for the
    1:          * error names enumerated in jscntxt.c.  It's not a compile-time check
    1:          * but it's better than nothing.
    1:          */
    1:         int errorNumber = 0;
    1: #define MSG_DEF(name, number, count, exception, format)                       \
    1:     JS_ASSERT(name == errorNumber++);
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: 
    1: #define MSG_DEF(name, number, count, exception, format)                       \
    1:     JS_BEGIN_MACRO                                                            \
    1:         uintN numfmtspecs = 0;                                                \
    1:         const char *fmt;                                                      \
    1:         for (fmt = format; *fmt != '\0'; fmt++) {                             \
    1:             if (*fmt == '{' && isdigit(fmt[1]))                               \
    1:                 ++numfmtspecs;                                                \
    1:         }                                                                     \
    1:         JS_ASSERT(count == numfmtspecs);                                      \
    1:     JS_END_MACRO;
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: 
24846:         /*
24846:          * If it were possible for pure inline function calls with constant
24846:          * arguments to be computed at compile time, these would be static
24846:          * assertions, but since it isn't, this is the best we can do.
24846:          */
24846:         JS_ASSERT(JSVAL_NULL == OBJECT_TO_JSVAL(NULL));
24846:         JS_ASSERT(JSVAL_ZERO == INT_TO_JSVAL(0));
24846:         JS_ASSERT(JSVAL_ONE == INT_TO_JSVAL(1));
24846:         JS_ASSERT(JSVAL_FALSE == BOOLEAN_TO_JSVAL(JS_FALSE));
24846:         JS_ASSERT(JSVAL_TRUE == BOOLEAN_TO_JSVAL(JS_TRUE));
24846: 
24846:         JS_ASSERT(JSVAL_TO_PSEUDO_BOOLEAN(JSVAL_VOID) == 2);
24846:         JS_ASSERT(JSVAL_TO_PSEUDO_BOOLEAN(JSVAL_HOLE) == 3);
24846:         JS_ASSERT(JSVAL_TO_PSEUDO_BOOLEAN(JSVAL_ARETURN) == 4);
24846: 
 8893:         js_NewRuntimeWasCalled = JS_TRUE;
    1:     }
    1: #endif /* DEBUG */
    1: 
    1:     rt = (JSRuntime *) malloc(sizeof(JSRuntime));
    1:     if (!rt)
    1:         return NULL;
    1: 
    1:     /* Initialize infallibly first, so we can goto bad and JS_DestroyRuntime. */
    1:     memset(rt, 0, sizeof(JSRuntime));
    1:     JS_INIT_CLIST(&rt->contextList);
    1:     JS_INIT_CLIST(&rt->trapList);
    1:     JS_INIT_CLIST(&rt->watchPointList);
    1: 
16394:     if (!js_InitDtoa())
16394:         goto bad;
    1:     if (!js_InitGC(rt, maxbytes))
    1:         goto bad;
 4342:     if (!js_InitAtomState(rt))
 4342:         goto bad;
 8029:     if (!js_InitDeflatedStringCache(rt))
 8029:         goto bad;
    1: #ifdef JS_THREADSAFE
    1:     rt->gcLock = JS_NEW_LOCK();
    1:     if (!rt->gcLock)
    1:         goto bad;
    1:     rt->gcDone = JS_NEW_CONDVAR(rt->gcLock);
    1:     if (!rt->gcDone)
    1:         goto bad;
    1:     rt->requestDone = JS_NEW_CONDVAR(rt->gcLock);
    1:     if (!rt->requestDone)
    1:         goto bad;
    1:     /* this is asymmetric with JS_ShutDown: */
    1:     if (!js_SetupLocks(8, 16))
    1:         goto bad;
    1:     rt->rtLock = JS_NEW_LOCK();
    1:     if (!rt->rtLock)
    1:         goto bad;
    1:     rt->stateChange = JS_NEW_CONDVAR(rt->gcLock);
    1:     if (!rt->stateChange)
    1:         goto bad;
11739:     rt->titleSharingDone = JS_NEW_CONDVAR(rt->gcLock);
11739:     if (!rt->titleSharingDone)
    1:         goto bad;
11739:     rt->titleSharingTodo = NO_TITLE_SHARING_TODO;
    1:     rt->debuggerLock = JS_NEW_LOCK();
    1:     if (!rt->debuggerLock)
    1:         goto bad;
    1: #endif
    1:     if (!js_InitPropertyTree(rt))
    1:         goto bad;
26569:     if (!js_InitThreads(rt))
26569:         goto bad;
18068: 
    1:     return rt;
    1: 
    1: bad:
    1:     JS_DestroyRuntime(rt);
    1:     return NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyRuntime(JSRuntime *rt)
    1: {
    1: #ifdef DEBUG
    1:     /* Don't hurt everyone in leaky ol' Mozilla with a fatal JS_ASSERT! */
    1:     if (!JS_CLIST_IS_EMPTY(&rt->contextList)) {
    1:         JSContext *cx, *iter = NULL;
    1:         uintN cxcount = 0;
13957:         while ((cx = js_ContextIterator(rt, JS_TRUE, &iter)) != NULL) {
13957:             fprintf(stderr,
13957: "JS API usage error: found live context at %p\n",
22452:                     (void *) cx);
    1:             cxcount++;
13957:         }
    1:         fprintf(stderr,
13957: "JS API usage error: %u context%s left in runtime upon JS_DestroyRuntime.\n",
13957:                 cxcount, (cxcount == 1) ? "" : "s");
    1:     }
    1: #endif
    1: 
26569:     js_FinishThreads(rt);
    1:     js_FreeRuntimeScriptState(rt);
 4342:     js_FinishAtomState(rt);
 4489: 
 4489:     /*
 8898:      * Free unit string storage only after all strings have been finalized, so
 8898:      * that js_FinalizeString can detect unit strings and avoid calling free
 8898:      * on their chars storage.
 8898:      */
 8898:     js_FinishUnitStrings(rt);
 8898: 
 8898:     /*
 4489:      * Finish the deflated string cache after the last GC and after
 4489:      * calling js_FinishAtomState, which finalizes strings.
 4489:      */
 4489:     js_FinishDeflatedStringCache(rt);
    1:     js_FinishGC(rt);
    1: #ifdef JS_THREADSAFE
    1:     if (rt->gcLock)
    1:         JS_DESTROY_LOCK(rt->gcLock);
    1:     if (rt->gcDone)
    1:         JS_DESTROY_CONDVAR(rt->gcDone);
    1:     if (rt->requestDone)
    1:         JS_DESTROY_CONDVAR(rt->requestDone);
    1:     if (rt->rtLock)
    1:         JS_DESTROY_LOCK(rt->rtLock);
    1:     if (rt->stateChange)
    1:         JS_DESTROY_CONDVAR(rt->stateChange);
11739:     if (rt->titleSharingDone)
11739:         JS_DESTROY_CONDVAR(rt->titleSharingDone);
    1:     if (rt->debuggerLock)
    1:         JS_DESTROY_LOCK(rt->debuggerLock);
    1: #endif
    1:     js_FinishPropertyTree(rt);
    1:     free(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ShutDown(void)
    1: {
    1: #ifdef JS_OPMETER
    1:     extern void js_DumpOpMeters();
    1: 
    1:     js_DumpOpMeters();
    1: #endif
    1: 
    1:     js_FinishDtoa();
    1: #ifdef JS_THREADSAFE
    1:     js_CleanupLocks();
    1: #endif
 3531:     PRMJ_NowShutdown();
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetRuntimePrivate(JSRuntime *rt)
    1: {
    1:     return rt->data;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetRuntimePrivate(JSRuntime *rt, void *data)
    1: {
    1:     rt->data = data;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_BeginRequest(JSContext *cx)
    1: {
11277: #ifdef JS_THREADSAFE
    1:     JSRuntime *rt;
    1: 
26569:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
    1:     if (!cx->requestDepth) {
19699:         JS_ASSERT(cx->gcLocalFreeLists == &js_GCEmptyFreeListSet);
19699: 
    1:         /* Wait until the GC is finished. */
    1:         rt = cx->runtime;
    1:         JS_LOCK_GC(rt);
    1: 
    1:         if (rt->gcThread != cx->thread) {
    1:             while (rt->gcLevel > 0)
    1:                 JS_AWAIT_GC_DONE(rt);
    1:         }
    1: 
    1:         /* Indicate that a request is running. */
    1:         rt->requestCount++;
    1:         cx->requestDepth = 1;
 7286:         cx->outstandingRequests++;
    1:         JS_UNLOCK_GC(rt);
    1:         return;
    1:     }
    1:     cx->requestDepth++;
 7286:     cx->outstandingRequests++;
11277: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_EndRequest(JSContext *cx)
    1: {
11277: #ifdef JS_THREADSAFE
    1:     JSRuntime *rt;
11739:     JSTitle *title, **todop;
11739:     JSBool shared;
    1: 
    1:     CHECK_REQUEST(cx);
26569:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
    1:     JS_ASSERT(cx->requestDepth > 0);
 7286:     JS_ASSERT(cx->outstandingRequests > 0);
    1:     if (cx->requestDepth == 1) {
    1:         /* Lock before clearing to interlock with ClaimScope, in jslock.c. */
    1:         rt = cx->runtime;
    1:         JS_LOCK_GC(rt);
    1:         cx->requestDepth = 0;
 7286:         cx->outstandingRequests--;
 3624: 
11739:         /* See whether cx has any single-threaded titles to start sharing. */
11739:         todop = &rt->titleSharingTodo;
11739:         shared = JS_FALSE;
11739:         while ((title = *todop) != NO_TITLE_SHARING_TODO) {
11739:             if (title->ownercx != cx) {
11739:                 todop = &title->u.link;
    1:                 continue;
    1:             }
11739:             *todop = title->u.link;
11739:             title->u.link = NULL;       /* null u.link for sanity ASAP */
    1: 
    1:             /*
    1:              * If js_DropObjectMap returns null, we held the last ref to scope.
    1:              * The waiting thread(s) must have been killed, after which the GC
    1:              * collected the object that held this scope.  Unlikely, because it
 9780:              * requires that the GC ran (e.g., from an operation callback)
 9780:              * during this request, but possible.
    1:              */
11739:             if (js_DropObjectMap(cx, TITLE_TO_MAP(title), NULL)) {
11739:                 js_InitLock(&title->lock);
11739:                 title->u.count = 0;   /* NULL may not pun as 0 */
11739:                 js_FinishSharingTitle(cx, title); /* set ownercx = NULL */
11739:                 shared = JS_TRUE;
11739:             }
11739:         }
11739:         if (shared)
11739:             JS_NOTIFY_ALL_CONDVAR(rt->titleSharingDone);
    1: 
19699:         js_RevokeGCLocalFreeLists(cx);
19699: 
    1:         /* Give the GC a chance to run if this was the last request running. */
    1:         JS_ASSERT(rt->requestCount > 0);
    1:         rt->requestCount--;
    1:         if (rt->requestCount == 0)
    1:             JS_NOTIFY_REQUEST_DONE(rt);
23442: 
    1:         JS_UNLOCK_GC(rt);
    1:         return;
    1:     }
    1: 
    1:     cx->requestDepth--;
 7286:     cx->outstandingRequests--;
11277: #endif
    1: }
    1: 
    1: /* Yield to pending GC operations, regardless of request depth */
    1: JS_PUBLIC_API(void)
    1: JS_YieldRequest(JSContext *cx)
    1: {
11277: #ifdef JS_THREADSAFE
    1:     JS_ASSERT(cx->thread);
    1:     CHECK_REQUEST(cx);
11716:     JS_ResumeRequest(cx, JS_SuspendRequest(cx));
11277: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(jsrefcount)
    1: JS_SuspendRequest(JSContext *cx)
    1: {
11277: #ifdef JS_THREADSAFE
    1:     jsrefcount saveDepth = cx->requestDepth;
    1: 
11527:     while (cx->requestDepth) {
11527:         cx->outstandingRequests++;  /* compensate for JS_EndRequest */
    1:         JS_EndRequest(cx);
11527:     }
    1:     return saveDepth;
11277: #else
11277:     return 0;
11277: #endif
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ResumeRequest(JSContext *cx, jsrefcount saveDepth)
    1: {
11277: #ifdef JS_THREADSAFE
    1:     JS_ASSERT(!cx->requestDepth);
11527:     while (--saveDepth >= 0) {
    1:         JS_BeginRequest(cx);
11527:         cx->outstandingRequests--;  /* compensate for JS_BeginRequest */
11527:     }
11277: #endif
11277: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_Lock(JSRuntime *rt)
    1: {
    1:     JS_LOCK_RUNTIME(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_Unlock(JSRuntime *rt)
    1: {
    1:     JS_UNLOCK_RUNTIME(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(JSContextCallback)
    1: JS_SetContextCallback(JSRuntime *rt, JSContextCallback cxCallback)
    1: {
    1:     JSContextCallback old;
    1: 
    1:     old = rt->cxCallback;
    1:     rt->cxCallback = cxCallback;
    1:     return old;
    1: }
    1: 
    1: JS_PUBLIC_API(JSContext *)
    1: JS_NewContext(JSRuntime *rt, size_t stackChunkSize)
    1: {
    1:     return js_NewContext(rt, stackChunkSize);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyContext(JSContext *cx)
    1: {
    1:     js_DestroyContext(cx, JSDCM_FORCE_GC);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyContextNoGC(JSContext *cx)
    1: {
    1:     js_DestroyContext(cx, JSDCM_NO_GC);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyContextMaybeGC(JSContext *cx)
    1: {
    1:     js_DestroyContext(cx, JSDCM_MAYBE_GC);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetContextPrivate(JSContext *cx)
    1: {
    1:     return cx->data;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetContextPrivate(JSContext *cx, void *data)
    1: {
    1:     cx->data = data;
    1: }
    1: 
    1: JS_PUBLIC_API(JSRuntime *)
    1: JS_GetRuntime(JSContext *cx)
    1: {
    1:     return cx->runtime;
    1: }
    1: 
    1: JS_PUBLIC_API(JSContext *)
    1: JS_ContextIterator(JSRuntime *rt, JSContext **iterp)
    1: {
    1:     return js_ContextIterator(rt, JS_TRUE, iterp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_GetVersion(JSContext *cx)
    1: {
 1599:     return JSVERSION_NUMBER(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_SetVersion(JSContext *cx, JSVersion version)
    1: {
    1:     JSVersion oldVersion;
    1: 
    1:     JS_ASSERT(version != JSVERSION_UNKNOWN);
    1:     JS_ASSERT((version & ~JSVERSION_MASK) == 0);
    1: 
 1599:     oldVersion = JSVERSION_NUMBER(cx);
    1:     if (version == oldVersion)
    1:         return oldVersion;
    1: 
    1:     /* We no longer support 1.4 or below. */
    1:     if (version != JSVERSION_DEFAULT && version <= JSVERSION_1_4)
    1:         return oldVersion;
    1: 
    1:     cx->version = (cx->version & ~JSVERSION_MASK) | version;
    1:     js_OnVersionChange(cx);
    1:     return oldVersion;
    1: }
    1: 
    1: static struct v2smap {
    1:     JSVersion   version;
    1:     const char  *string;
    1: } v2smap[] = {
    1:     {JSVERSION_1_0,     "1.0"},
    1:     {JSVERSION_1_1,     "1.1"},
    1:     {JSVERSION_1_2,     "1.2"},
    1:     {JSVERSION_1_3,     "1.3"},
    1:     {JSVERSION_1_4,     "1.4"},
    1:     {JSVERSION_ECMA_3,  "ECMAv3"},
    1:     {JSVERSION_1_5,     "1.5"},
    1:     {JSVERSION_1_6,     "1.6"},
    1:     {JSVERSION_1_7,     "1.7"},
 1981:     {JSVERSION_1_8,     "1.8"},
    1:     {JSVERSION_DEFAULT, js_default_str},
    1:     {JSVERSION_UNKNOWN, NULL},          /* must be last, NULL is sentinel */
    1: };
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_VersionToString(JSVersion version)
    1: {
    1:     int i;
    1: 
    1:     for (i = 0; v2smap[i].string; i++)
    1:         if (v2smap[i].version == version)
    1:             return v2smap[i].string;
    1:     return "unknown";
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_StringToVersion(const char *string)
    1: {
    1:     int i;
    1: 
    1:     for (i = 0; v2smap[i].string; i++)
    1:         if (strcmp(v2smap[i].string, string) == 0)
    1:             return v2smap[i].version;
    1:     return JSVERSION_UNKNOWN;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_GetOptions(JSContext *cx)
    1: {
    1:     return cx->options;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_SetOptions(JSContext *cx, uint32 options)
    1: {
    1:     uint32 oldopts = cx->options;
    1:     cx->options = options;
24874:     js_SyncOptionsToVersion(cx);
    1:     return oldopts;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_ToggleOptions(JSContext *cx, uint32 options)
    1: {
    1:     uint32 oldopts = cx->options;
    1:     cx->options ^= options;
24874:     js_SyncOptionsToVersion(cx);
    1:     return oldopts;
    1: }
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetImplementationVersion(void)
    1: {
 6602:     return "JavaScript-C 1.8.0 pre-release 1 2007-10-03";
    1: }
    1: 
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetGlobalObject(JSContext *cx)
    1: {
    1:     return cx->globalObject;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetGlobalObject(JSContext *cx, JSObject *obj)
    1: {
    1:     cx->globalObject = obj;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     cx->xmlSettingFlags = 0;
    1: #endif
    1: }
    1: 
 3164: JS_BEGIN_EXTERN_C
 3164: 
    1: JSObject *
    1: js_InitFunctionAndObjectClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     JSDHashTable *table;
    1:     JSBool resolving;
    1:     JSRuntime *rt;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     JSObject *fun_proto, *obj_proto;
    1: 
    1:     /* If cx has no global object, use obj so prototypes can be found. */
    1:     if (!cx->globalObject)
    1:         JS_SetGlobalObject(cx, obj);
    1: 
    1:     /* Record Function and Object in cx->resolvingTable, if we are resolving. */
    1:     table = cx->resolvingTable;
    1:     resolving = (table && table->entryCount);
    1:     rt = cx->runtime;
    1:     key.obj = obj;
    1:     if (resolving) {
    1:         key.id = ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Function]);
    1:         entry = (JSResolvingEntry *)
    1:                 JS_DHashTableOperate(table, &key, JS_DHASH_ADD);
    1:         if (entry && entry->key.obj && (entry->flags & JSRESFLAG_LOOKUP)) {
    1:             /* Already resolving Function, record Object too. */
    1:             JS_ASSERT(entry->key.obj == obj);
    1:             key.id = ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Object]);
    1:             entry = (JSResolvingEntry *)
    1:                     JS_DHashTableOperate(table, &key, JS_DHASH_ADD);
    1:         }
    1:         if (!entry) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         JS_ASSERT(!entry->key.obj && entry->flags == 0);
    1:         entry->key = key;
    1:         entry->flags = JSRESFLAG_LOOKUP;
    1:     } else {
    1:         key.id = ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Object]);
    1:         if (!js_StartResolving(cx, &key, JSRESFLAG_LOOKUP, &entry))
    1:             return NULL;
    1: 
    1:         key.id = ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Function]);
    1:         if (!js_StartResolving(cx, &key, JSRESFLAG_LOOKUP, &entry)) {
    1:             key.id = ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Object]);
    1:             JS_DHashTableOperate(table, &key, JS_DHASH_REMOVE);
    1:             return NULL;
    1:         }
    1: 
    1:         table = cx->resolvingTable;
    1:     }
    1: 
    1:     /* Initialize the function class first so constructors can be made. */
14352:     if (!js_GetClassPrototype(cx, obj, INT_TO_JSID(JSProto_Function),
14352:                               &fun_proto)) {
14352:         fun_proto = NULL;
14352:         goto out;
14352:     }
14352:     if (!fun_proto) {
    1:         fun_proto = js_InitFunctionClass(cx, obj);
    1:         if (!fun_proto)
    1:             goto out;
14352:     } else {
14352:         JSObject *ctor;
14352: 
14352:         ctor = JS_GetConstructor(cx, fun_proto);
14352:         if (!ctor) {
14352:             fun_proto = NULL;
14352:             goto out;
14352:         }
14352:         OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(CLASS_ATOM(cx, Function)),
14352:                             OBJECT_TO_JSVAL(ctor), 0, 0, 0, NULL);
14352:     }
    1: 
    1:     /* Initialize the object class next so Object.prototype works. */
14352:     if (!js_GetClassPrototype(cx, obj, INT_TO_JSID(JSProto_Object),
14352:                               &obj_proto)) {
14352:         fun_proto = NULL;
14352:         goto out;
14352:     }
14352:     if (!obj_proto)
    1:         obj_proto = js_InitObjectClass(cx, obj);
    1:     if (!obj_proto) {
    1:         fun_proto = NULL;
    1:         goto out;
    1:     }
    1: 
    1:     /* Function.prototype and the global object delegate to Object.prototype. */
    1:     OBJ_SET_PROTO(cx, fun_proto, obj_proto);
    1:     if (!OBJ_GET_PROTO(cx, obj))
    1:         OBJ_SET_PROTO(cx, obj, obj_proto);
    1: 
    1: out:
    1:     /* If resolving, remove the other entry (Object or Function) from table. */
    1:     JS_DHashTableOperate(table, &key, JS_DHASH_REMOVE);
    1:     if (!resolving) {
    1:         /* If not resolving, remove the first entry added above, for Object. */
    1:         JS_ASSERT(key.id ==                                                   \
    1:                   ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Function]));
    1:         key.id = ATOM_TO_JSID(rt->atomState.classAtoms[JSProto_Object]);
    1:         JS_DHashTableOperate(table, &key, JS_DHASH_REMOVE);
    1:     }
    1:     return fun_proto;
    1: }
    1: 
 3164: JS_END_EXTERN_C
 3164: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_InitStandardClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     /* Define a top-level property 'undefined' with the undefined value. */
    1:     atom = cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
    1:     if (!OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), JSVAL_VOID,
27067:                              JS_PropertyStub, JS_PropertyStub, JSPROP_PERMANENT, 
27067:                              NULL)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Function and Object require cooperative bootstrapping magic. */
    1:     if (!js_InitFunctionAndObjectClasses(cx, obj))
    1:         return JS_FALSE;
    1: 
    1:     /* Initialize the rest of the standard objects and functions. */
    1:     return js_InitArrayClass(cx, obj) &&
    1:            js_InitBlockClass(cx, obj) &&
    1:            js_InitBooleanClass(cx, obj) &&
    1:            js_InitCallClass(cx, obj) &&
    1:            js_InitExceptionClasses(cx, obj) &&
    1:            js_InitMathClass(cx, obj) &&
    1:            js_InitNumberClass(cx, obj) &&
20092:            js_InitJSONClass(cx, obj) &&
    1:            js_InitRegExpClass(cx, obj) &&
    1:            js_InitStringClass(cx, obj) &&
14920:            js_InitEval(cx, obj) &&
    1: #if JS_HAS_SCRIPT_OBJECT
    1:            js_InitScriptClass(cx, obj) &&
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:            js_InitXMLClasses(cx, obj) &&
    1: #endif
    1: #if JS_HAS_FILE_OBJECT
    1:            js_InitFileClass(cx, obj) &&
    1: #endif
    1: #if JS_HAS_GENERATORS
    1:            js_InitIteratorClasses(cx, obj) &&
    1: #endif
    1:            js_InitDateClass(cx, obj);
    1: }
    1: 
18414: #define CLASP(name)                 (&js_##name##Class)
18414: #define EXT_CLASP(name)             (&js_##name##Class.base)
    1: #define EAGER_ATOM(name)            ATOM_OFFSET(name), NULL
    1: #define EAGER_CLASS_ATOM(name)      CLASS_ATOM_OFFSET(name), NULL
    1: #define EAGER_ATOM_AND_CLASP(name)  EAGER_CLASS_ATOM(name), CLASP(name)
18414: #define EAGER_ATOM_AND_EXT_CLASP(name) EAGER_CLASS_ATOM(name), EXT_CLASP(name)
    1: #define LAZY_ATOM(name)             ATOM_OFFSET(lazy.name), js_##name##_str
    1: 
    1: typedef struct JSStdName {
    1:     JSObjectOp  init;
    1:     size_t      atomOffset;     /* offset of atom pointer in JSAtomState */
    1:     const char  *name;          /* null if atom is pre-pinned, else name */
    1:     JSClass     *clasp;
    1: } JSStdName;
    1: 
    1: static JSAtom *
    1: StdNameToAtom(JSContext *cx, JSStdName *stdn)
    1: {
    1:     size_t offset;
    1:     JSAtom *atom;
    1:     const char *name;
    1: 
    1:     offset = stdn->atomOffset;
    1:     atom = OFFSET_TO_ATOM(cx->runtime, offset);
    1:     if (!atom) {
    1:         name = stdn->name;
    1:         if (name) {
    1:             atom = js_Atomize(cx, name, strlen(name), ATOM_PINNED);
    1:             OFFSET_TO_ATOM(cx->runtime, offset) = atom;
    1:         }
    1:     }
    1:     return atom;
    1: }
    1: 
    1: /*
    1:  * Table of class initializers and their atom offsets in rt->atomState.
    1:  * If you add a "standard" class, remember to update this table.
    1:  */
    1: static JSStdName standard_class_atoms[] = {
    1:     {js_InitFunctionAndObjectClasses,   EAGER_ATOM_AND_CLASP(Function)},
    1:     {js_InitFunctionAndObjectClasses,   EAGER_ATOM_AND_CLASP(Object)},
    1:     {js_InitArrayClass,                 EAGER_ATOM_AND_CLASP(Array)},
    1:     {js_InitBlockClass,                 EAGER_ATOM_AND_CLASP(Block)},
    1:     {js_InitBooleanClass,               EAGER_ATOM_AND_CLASP(Boolean)},
    1:     {js_InitDateClass,                  EAGER_ATOM_AND_CLASP(Date)},
    1:     {js_InitMathClass,                  EAGER_ATOM_AND_CLASP(Math)},
    1:     {js_InitNumberClass,                EAGER_ATOM_AND_CLASP(Number)},
    1:     {js_InitStringClass,                EAGER_ATOM_AND_CLASP(String)},
    1:     {js_InitCallClass,                  EAGER_ATOM_AND_CLASP(Call)},
    1:     {js_InitExceptionClasses,           EAGER_ATOM_AND_CLASP(Error)},
    1:     {js_InitRegExpClass,                EAGER_ATOM_AND_CLASP(RegExp)},
    1: #if JS_HAS_SCRIPT_OBJECT
    1:     {js_InitScriptClass,                EAGER_ATOM_AND_CLASP(Script)},
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:     {js_InitXMLClass,                   EAGER_ATOM_AND_CLASP(XML)},
18414:     {js_InitNamespaceClass,             EAGER_ATOM_AND_EXT_CLASP(Namespace)},
18414:     {js_InitQNameClass,                 EAGER_ATOM_AND_EXT_CLASP(QName)},
    1: #endif
    1: #if JS_HAS_FILE_OBJECT
    1:     {js_InitFileClass,                  EAGER_ATOM_AND_CLASP(File)},
    1: #endif
    1: #if JS_HAS_GENERATORS
    1:     {js_InitIteratorClasses,            EAGER_ATOM_AND_CLASP(StopIteration)},
    1: #endif
20092:     {js_InitJSONClass,                  EAGER_ATOM_AND_CLASP(JSON)},
    1:     {NULL,                              0, NULL, NULL}
    1: };
    1: 
    1: /*
    1:  * Table of top-level function and constant names and their init functions.
    1:  * If you add a "standard" global function or property, remember to update
    1:  * this table.
    1:  */
    1: static JSStdName standard_class_names[] = {
    1:     /* ECMA requires that eval be a direct property of the global object. */
14322:     {js_InitEval,               EAGER_ATOM(eval), NULL},
    1: 
    1:     /* Global properties and functions defined by the Number class. */
    1:     {js_InitNumberClass,        LAZY_ATOM(NaN), NULL},
    1:     {js_InitNumberClass,        LAZY_ATOM(Infinity), NULL},
    1:     {js_InitNumberClass,        LAZY_ATOM(isNaN), NULL},
    1:     {js_InitNumberClass,        LAZY_ATOM(isFinite), NULL},
    1:     {js_InitNumberClass,        LAZY_ATOM(parseFloat), NULL},
    1:     {js_InitNumberClass,        LAZY_ATOM(parseInt), NULL},
    1: 
    1:     /* String global functions. */
    1:     {js_InitStringClass,        LAZY_ATOM(escape), NULL},
    1:     {js_InitStringClass,        LAZY_ATOM(unescape), NULL},
    1:     {js_InitStringClass,        LAZY_ATOM(decodeURI), NULL},
    1:     {js_InitStringClass,        LAZY_ATOM(encodeURI), NULL},
    1:     {js_InitStringClass,        LAZY_ATOM(decodeURIComponent), NULL},
    1:     {js_InitStringClass,        LAZY_ATOM(encodeURIComponent), NULL},
    1: #if JS_HAS_UNEVAL
    1:     {js_InitStringClass,        LAZY_ATOM(uneval), NULL},
    1: #endif
    1: 
    1:     /* Exception constructors. */
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(Error), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(InternalError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(EvalError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(RangeError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(ReferenceError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(SyntaxError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(TypeError), CLASP(Error)},
    1:     {js_InitExceptionClasses,   EAGER_CLASS_ATOM(URIError), CLASP(Error)},
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     {js_InitAnyNameClass,       EAGER_ATOM_AND_CLASP(AnyName)},
    1:     {js_InitAttributeNameClass, EAGER_ATOM_AND_CLASP(AttributeName)},
    1:     {js_InitXMLClass,           LAZY_ATOM(XMLList), &js_XMLClass},
    1:     {js_InitXMLClass,           LAZY_ATOM(isXMLName), NULL},
    1: #endif
    1: 
    1: #if JS_HAS_GENERATORS
    1:     {js_InitIteratorClasses,    EAGER_ATOM_AND_CLASP(Iterator)},
    1:     {js_InitIteratorClasses,    EAGER_ATOM_AND_CLASP(Generator)},
    1: #endif
    1: 
    1:     {NULL,                      0, NULL, NULL}
    1: };
    1: 
    1: static JSStdName object_prototype_names[] = {
    1:     /* Object.prototype properties (global delegates to Object.prototype). */
    1:     {js_InitObjectClass,        EAGER_ATOM(proto), NULL},
    1:     {js_InitObjectClass,        EAGER_ATOM(parent), NULL},
    1:     {js_InitObjectClass,        EAGER_ATOM(count), NULL},
    1: #if JS_HAS_TOSOURCE
    1:     {js_InitObjectClass,        EAGER_ATOM(toSource), NULL},
    1: #endif
    1:     {js_InitObjectClass,        EAGER_ATOM(toString), NULL},
    1:     {js_InitObjectClass,        EAGER_ATOM(toLocaleString), NULL},
    1:     {js_InitObjectClass,        EAGER_ATOM(valueOf), NULL},
    1: #if JS_HAS_OBJ_WATCHPOINT
    1:     {js_InitObjectClass,        LAZY_ATOM(watch), NULL},
    1:     {js_InitObjectClass,        LAZY_ATOM(unwatch), NULL},
    1: #endif
    1:     {js_InitObjectClass,        LAZY_ATOM(hasOwnProperty), NULL},
    1:     {js_InitObjectClass,        LAZY_ATOM(isPrototypeOf), NULL},
    1:     {js_InitObjectClass,        LAZY_ATOM(propertyIsEnumerable), NULL},
    1: #if JS_HAS_GETTER_SETTER
    1:     {js_InitObjectClass,        LAZY_ATOM(defineGetter), NULL},
    1:     {js_InitObjectClass,        LAZY_ATOM(defineSetter), NULL},
    1:     {js_InitObjectClass,        LAZY_ATOM(lookupGetter), NULL},
    1:     {js_InitObjectClass,        LAZY_ATOM(lookupSetter), NULL},
    1: #endif
    1: 
    1:     {NULL,                      0, NULL, NULL}
    1: };
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ResolveStandardClass(JSContext *cx, JSObject *obj, jsval id,
    1:                         JSBool *resolved)
    1: {
    1:     JSString *idstr;
    1:     JSRuntime *rt;
    1:     JSAtom *atom;
    1:     JSStdName *stdnm;
    1:     uintN i;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     *resolved = JS_FALSE;
    1: 
 4556:     rt = cx->runtime;
 4556:     JS_ASSERT(rt->state != JSRTS_DOWN);
 4556:     if (rt->state == JSRTS_LANDING || !JSVAL_IS_STRING(id))
    1:         return JS_TRUE;
 4556: 
    1:     idstr = JSVAL_TO_STRING(id);
    1: 
    1:     /* Check whether we're resolving 'undefined', and define it if so. */
    1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
    1:     if (idstr == ATOM_TO_STRING(atom)) {
    1:         *resolved = JS_TRUE;
    1:         return OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), JSVAL_VOID,
27067:                                    JS_PropertyStub, JS_PropertyStub, 
27067:                                    JSPROP_PERMANENT, NULL);
    1:     }
    1: 
    1:     /* Try for class constructors/prototypes named by well-known atoms. */
    1:     stdnm = NULL;
    1:     for (i = 0; standard_class_atoms[i].init; i++) {
    1:         atom = OFFSET_TO_ATOM(rt, standard_class_atoms[i].atomOffset);
    1:         if (idstr == ATOM_TO_STRING(atom)) {
    1:             stdnm = &standard_class_atoms[i];
    1:             break;
    1:         }
    1:     }
    1: 
    1:     if (!stdnm) {
    1:         /* Try less frequently used top-level functions and constants. */
    1:         for (i = 0; standard_class_names[i].init; i++) {
    1:             atom = StdNameToAtom(cx, &standard_class_names[i]);
    1:             if (!atom)
    1:                 return JS_FALSE;
    1:             if (idstr == ATOM_TO_STRING(atom)) {
    1:                 stdnm = &standard_class_names[i];
    1:                 break;
    1:             }
    1:         }
    1: 
    1:         if (!stdnm && !OBJ_GET_PROTO(cx, obj)) {
    1:             /*
    1:              * Try even less frequently used names delegated from the global
    1:              * object to Object.prototype, but only if the Object class hasn't
    1:              * yet been initialized.
    1:              */
    1:             for (i = 0; object_prototype_names[i].init; i++) {
    1:                 atom = StdNameToAtom(cx, &object_prototype_names[i]);
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:                 if (idstr == ATOM_TO_STRING(atom)) {
    1:                     stdnm = &standard_class_names[i];
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (stdnm) {
    1:         /*
    1:          * If this standard class is anonymous and obj advertises itself as a
    1:          * global object (in order to reserve slots for standard class object
    1:          * pointers), then we don't want to resolve by name.
    1:          *
    1:          * If inversely, either id does not name a class, or id does not name
    1:          * an anonymous class, or the global does not reserve slots for class
    1:          * objects, then we must call the init hook here.
    1:          */
    1:         if (stdnm->clasp &&
    1:             (stdnm->clasp->flags & JSCLASS_IS_ANONYMOUS) &&
    1:             (OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL)) {
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         if (!stdnm->init(cx, obj))
    1:             return JS_FALSE;
    1:         *resolved = JS_TRUE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, JSAtom *atom)
    1: {
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1: 
    1:     JS_ASSERT(OBJ_IS_NATIVE(obj));
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = OBJ_SCOPE(obj);
    1:     sprop = SCOPE_GET_PROPERTY(scope, ATOM_TO_JSID(atom));
    1:     JS_UNLOCK_SCOPE(cx, scope);
    1:     return sprop != NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EnumerateStandardClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     JSRuntime *rt;
    1:     JSAtom *atom;
    1:     uintN i;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     rt = cx->runtime;
    1: 
    1:     /* Check whether we need to bind 'undefined' and define it if so. */
    1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
    1:     if (!AlreadyHasOwnProperty(cx, obj, atom) &&
    1:         !OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), JSVAL_VOID,
27067:                              JS_PropertyStub, JS_PropertyStub, JSPROP_PERMANENT, 
27067:                              NULL)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Initialize any classes that have not been resolved yet. */
    1:     for (i = 0; standard_class_atoms[i].init; i++) {
    1:         atom = OFFSET_TO_ATOM(rt, standard_class_atoms[i].atomOffset);
    1:         if (!AlreadyHasOwnProperty(cx, obj, atom) &&
    1:             !standard_class_atoms[i].init(cx, obj)) {
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSIdArray *
15677: NewIdArray(JSContext *cx, jsint length)
15677: {
15677:     JSIdArray *ida;
15677: 
15677:     ida = (JSIdArray *)
15677:           JS_malloc(cx, offsetof(JSIdArray, vector) + length * sizeof(jsval));
15677:     if (ida)
15677:         ida->length = length;
15677:     return ida;
15677: }
15677: 
15677: /*
15677:  * Unlike realloc(3), this function frees ida on failure.
15677:  */
15677: static JSIdArray *
15677: SetIdArrayLength(JSContext *cx, JSIdArray *ida, jsint length)
15677: {
15677:     JSIdArray *rida;
15677: 
15677:     rida = (JSIdArray *)
15677:            JS_realloc(cx, ida,
15677:                       offsetof(JSIdArray, vector) + length * sizeof(jsval));
15677:     if (!rida)
15677:         JS_DestroyIdArray(cx, ida);
15677:     else
15677:         rida->length = length;
15677:     return rida;
15677: }
15677: 
15677: static JSIdArray *
    1: AddAtomToArray(JSContext *cx, JSAtom *atom, JSIdArray *ida, jsint *ip)
    1: {
    1:     jsint i, length;
    1: 
    1:     i = *ip;
    1:     length = ida->length;
    1:     if (i >= length) {
15677:         ida = SetIdArrayLength(cx, ida, JS_MAX(length * 2, 8));
    1:         if (!ida)
    1:             return NULL;
    1:         JS_ASSERT(i < ida->length);
    1:     }
    1:     ida->vector[i] = ATOM_TO_JSID(atom);
    1:     *ip = i + 1;
    1:     return ida;
    1: }
    1: 
    1: static JSIdArray *
    1: EnumerateIfResolved(JSContext *cx, JSObject *obj, JSAtom *atom, JSIdArray *ida,
    1:                     jsint *ip, JSBool *foundp)
    1: {
    1:     *foundp = AlreadyHasOwnProperty(cx, obj, atom);
    1:     if (*foundp)
    1:         ida = AddAtomToArray(cx, atom, ida, ip);
    1:     return ida;
    1: }
    1: 
    1: JS_PUBLIC_API(JSIdArray *)
    1: JS_EnumerateResolvedStandardClasses(JSContext *cx, JSObject *obj,
    1:                                     JSIdArray *ida)
    1: {
    1:     JSRuntime *rt;
    1:     jsint i, j, k;
    1:     JSAtom *atom;
    1:     JSBool found;
    1:     JSObjectOp init;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     rt = cx->runtime;
    1:     if (ida) {
    1:         i = ida->length;
    1:     } else {
15677:         ida = NewIdArray(cx, 8);
    1:         if (!ida)
    1:             return NULL;
    1:         i = 0;
    1:     }
    1: 
    1:     /* Check whether 'undefined' has been resolved and enumerate it if so. */
    1:     atom = rt->atomState.typeAtoms[JSTYPE_VOID];
    1:     ida = EnumerateIfResolved(cx, obj, atom, ida, &i, &found);
    1:     if (!ida)
    1:         return NULL;
    1: 
    1:     /* Enumerate only classes that *have* been resolved. */
    1:     for (j = 0; standard_class_atoms[j].init; j++) {
    1:         atom = OFFSET_TO_ATOM(rt, standard_class_atoms[j].atomOffset);
    1:         ida = EnumerateIfResolved(cx, obj, atom, ida, &i, &found);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         if (found) {
    1:             init = standard_class_atoms[j].init;
    1: 
    1:             for (k = 0; standard_class_names[k].init; k++) {
    1:                 if (standard_class_names[k].init == init) {
    1:                     atom = StdNameToAtom(cx, &standard_class_names[k]);
    1:                     ida = AddAtomToArray(cx, atom, ida, &i);
    1:                     if (!ida)
    1:                         return NULL;
    1:                 }
    1:             }
    1: 
    1:             if (init == js_InitObjectClass) {
    1:                 for (k = 0; object_prototype_names[k].init; k++) {
    1:                     atom = StdNameToAtom(cx, &object_prototype_names[k]);
    1:                     ida = AddAtomToArray(cx, atom, ida, &i);
    1:                     if (!ida)
    1:                         return NULL;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
15677:     /* Trim to exact length. */
15677:     return SetIdArrayLength(cx, ida, i);
    1: }
    1: 
    1: #undef CLASP
    1: #undef EAGER_ATOM
    1: #undef EAGER_CLASS_ATOM
    1: #undef EAGER_ATOM_CLASP
    1: #undef LAZY_ATOM
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_GetClassObject(cx, obj, key, objp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetScopeChain(JSContext *cx)
    1: {
    1:     JSStackFrame *fp;
    1: 
17070:     CHECK_REQUEST(cx);
22652:     fp = js_GetTopStackFrame(cx);
    1:     if (!fp) {
 4375:         /*
 4375:          * There is no code active on this context. In place of an actual
 4375:          * scope chain, use the context's global object, which is set in
 4375:          * js_InitFunctionAndObjectClasses, and which represents the default
 4375:          * scope chain for the embedding. See also js_FindClassObject.
 4375:          *
 4375:          * For embeddings that use the inner and outer object hooks, the inner
 4375:          * object represents the ultimate global object, with the outer object
 4375:          * acting as a stand-in.
 4375:          */
 4375:         JSObject *obj = cx->globalObject;
 4375:         if (!obj) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INACTIVE);
    1:             return NULL;
    1:         }
 4375: 
 4375:         OBJ_TO_INNER_OBJECT(cx, obj);
 4375:         return obj;
 4375:     }
    1:     return js_GetScopeChain(cx, fp);
    1: }
    1: 
 4427: JS_PUBLIC_API(JSObject *)
 4427: JS_GetGlobalForObject(JSContext *cx, JSObject *obj)
 4427: {
 4427:     JSObject *parent;
 4427: 
 4427:     while ((parent = OBJ_GET_PARENT(cx, obj)) != NULL)
 4427:         obj = parent;
 4427:     return obj;
 4427: }
 4427: 
11809: JS_PUBLIC_API(jsval)
11809: JS_ComputeThis(JSContext *cx, jsval *vp)
11809: {
11809:     if (!js_ComputeThis(cx, JS_FALSE, vp + 2))
11809:         return JSVAL_NULL;
11809:     return vp[1];
11809: }
11809: 
    1: JS_PUBLIC_API(void *)
    1: JS_malloc(JSContext *cx, size_t nbytes)
    1: {
    1:     void *p;
    1: 
    1:     JS_ASSERT(nbytes != 0);
    1:     if (nbytes == 0)
    1:         nbytes = 1;
    1: 
    1:     p = malloc(nbytes);
    1:     if (!p) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return NULL;
    1:     }
    1:     js_UpdateMallocCounter(cx, nbytes);
    1: 
    1:     return p;
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_realloc(JSContext *cx, void *p, size_t nbytes)
    1: {
25104:     void *orig = p;
    1:     p = realloc(p, nbytes);
25104:     if (!p) {
    1:         JS_ReportOutOfMemory(cx);
25104:         return NULL;
25104:     }
25104:     if (!orig)
25104:         js_UpdateMallocCounter(cx, nbytes);
    1:     return p;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_free(JSContext *cx, void *p)
    1: {
    1:     if (p)
    1:         free(p);
    1: }
    1: 
    1: JS_PUBLIC_API(char *)
    1: JS_strdup(JSContext *cx, const char *s)
    1: {
    1:     size_t n;
    1:     void *p;
    1: 
    1:     n = strlen(s) + 1;
    1:     p = JS_malloc(cx, n);
    1:     if (!p)
    1:         return NULL;
    1:     return (char *)memcpy(p, s, n);
    1: }
    1: 
    1: JS_PUBLIC_API(jsdouble *)
    1: JS_NewDouble(JSContext *cx, jsdouble d)
    1: {
    1:     CHECK_REQUEST(cx);
12850:     return js_NewWeaklyRootedDouble(cx, d);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_NewDoubleValue(JSContext *cx, jsdouble d, jsval *rval)
    1: {
12850:     jsdouble *dp;
12850: 
    1:     CHECK_REQUEST(cx);
12850:     dp = js_NewWeaklyRootedDouble(cx, d);
12850:     if (!dp)
12850:         return JS_FALSE;
12850:     *rval = DOUBLE_TO_JSVAL(dp);
12850:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_NewNumberValue(JSContext *cx, jsdouble d, jsval *rval)
    1: {
    1:     CHECK_REQUEST(cx);
26564:     return js_NewWeaklyRootedNumber(cx, d, rval);
    1: }
    1: 
    1: #undef JS_AddRoot
    1: JS_PUBLIC_API(JSBool)
    1: JS_AddRoot(JSContext *cx, void *rp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_AddRoot(cx, rp, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_AddNamedRootRT(JSRuntime *rt, void *rp, const char *name)
    1: {
    1:     return js_AddRootRT(rt, rp, name);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_RemoveRoot(JSContext *cx, void *rp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_RemoveRoot(cx->runtime, rp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_RemoveRootRT(JSRuntime *rt, void *rp)
    1: {
    1:     return js_RemoveRoot(rt, rp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_AddNamedRoot(JSContext *cx, void *rp, const char *name)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_AddRoot(cx, rp, name);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearNewbornRoots(JSContext *cx)
    1: {
    1:     JS_CLEAR_WEAK_ROOTS(&cx->weakRoots);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EnterLocalRootScope(JSContext *cx)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_EnterLocalRootScope(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_LeaveLocalRootScope(JSContext *cx)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     js_LeaveLocalRootScope(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     js_LeaveLocalRootScopeWithResult(cx, rval);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ForgetLocalRoot(JSContext *cx, void *thing)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     js_ForgetLocalRoot(cx, (jsval) thing);
    1: }
    1: 
    1: #ifdef DEBUG
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DumpNamedRoots(JSRuntime *rt,
    1:                   void (*dump)(const char *name, void *rp, void *data),
    1:                   void *data)
    1: {
    1:     js_DumpNamedRoots(rt, dump, data);
    1: }
    1: 
    1: #endif /* DEBUG */
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_MapGCRoots(JSRuntime *rt, JSGCRootMapFun map, void *data)
    1: {
    1:     return js_MapGCRoots(rt, map, data);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_LockGCThing(JSContext *cx, void *thing)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
12282:     ok = js_LockGCThingRT(cx->runtime, thing);
    1:     if (!ok)
12282:         JS_ReportOutOfMemory(cx);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_LockGCThingRT(JSRuntime *rt, void *thing)
    1: {
    1:     return js_LockGCThingRT(rt, thing);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_UnlockGCThing(JSContext *cx, void *thing)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     ok = js_UnlockGCThingRT(cx->runtime, thing);
    1:     if (!ok)
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_UNLOCK);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_UnlockGCThingRT(JSRuntime *rt, void *thing)
    1: {
    1:     return js_UnlockGCThingRT(rt, thing);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
  958: JS_SetExtraGCRoots(JSRuntime *rt, JSTraceDataOp traceOp, void *data)
  958: {
  958:     rt->gcExtraRootsTraceOp = traceOp;
  958:     rt->gcExtraRootsData = data;
  958: }
  958: 
  958: JS_PUBLIC_API(void)
  786: JS_TraceRuntime(JSTracer *trc)
  786: {
  786:     JSBool allAtoms = trc->context->runtime->gcKeepAtoms != 0;
  786: 
24499:     js_LeaveTrace(trc->context);
  786:     js_TraceRuntime(trc, allAtoms);
  786: }
  786: 
  786: #ifdef DEBUG
  786: 
  786: #ifdef HAVE_XPCONNECT
  786: #include "dump_xpc.h"
  786: #endif
  786: 
  786: JS_PUBLIC_API(void)
  786: JS_PrintTraceThingInfo(char *buf, size_t bufsize, JSTracer *trc,
  786:                        void *thing, uint32 kind, JSBool details)
  786: {
  786:     const char *name;
  786:     size_t n;
  786: 
  786:     if (bufsize == 0)
  786:         return;
  786: 
  786:     switch (kind) {
  786:       case JSTRACE_OBJECT:
  786:       {
  786:         JSObject *obj = (JSObject *)thing;
  786:         JSClass *clasp = STOBJ_GET_CLASS(obj);
  786: 
  786:         name = clasp->name;
  786: #ifdef HAVE_XPCONNECT
  786:         if (clasp->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS) {
  786:             jsval privateValue = STOBJ_GET_SLOT(obj, JSSLOT_PRIVATE);
  786: 
  786:             JS_ASSERT(clasp->flags & JSCLASS_HAS_PRIVATE);
  786:             if (!JSVAL_IS_VOID(privateValue)) {
  786:                 void  *privateThing = JSVAL_TO_PRIVATE(privateValue);
  786:                 const char *xpcClassName = GetXPCObjectClassName(privateThing);
  786: 
  786:                 if (xpcClassName)
  786:                     name = xpcClassName;
  786:             }
  786:         }
  786: #endif
  786:         break;
  786:       }
  786: 
  786:       case JSTRACE_STRING:
  786:         name = JSSTRING_IS_DEPENDENT((JSString *)thing)
  786:                ? "substring"
  786:                : "string";
  786:         break;
  786: 
  786:       case JSTRACE_DOUBLE:
  786:         name = "double";
  786:         break;
  786: 
  786: #if JS_HAS_XML_SUPPORT
  786:       case JSTRACE_XML:
  786:         name = "xml";
  786:         break;
  786: #endif
  786:       default:
  786:         JS_ASSERT(0);
  786:         return;
  786:         break;
  786:     }
  786: 
  786:     n = strlen(name);
  786:     if (n > bufsize - 1)
  786:         n = bufsize - 1;
  786:     memcpy(buf, name, n + 1);
  786:     buf += n;
  786:     bufsize -= n;
  786: 
  786:     if (details && bufsize > 2) {
  786:         *buf++ = ' ';
  786:         bufsize--;
  786: 
  786:         switch (kind) {
  786:           case JSTRACE_OBJECT:
  786:           {
  786:             JSObject  *obj = (JSObject *)thing;
11846:             JSClass *clasp = STOBJ_GET_CLASS(obj);
13824:             if (clasp == &js_FunctionClass) {
13824:                 JSFunction *fun = (JSFunction *)
13824:                                   JS_GetPrivate(trc->context, obj);
13824: 
13824:                 if (!fun) {
13824:                     JS_snprintf(buf, bufsize, "<newborn>");
13824:                 } else if (FUN_OBJECT(fun) != obj) {
13824:                     JS_snprintf(buf, bufsize, "%p", fun);
13824:                 } else {
13824:                     if (fun->atom && ATOM_IS_STRING(fun->atom))
13824:                         js_PutEscapedString(buf, bufsize,
13824:                                             ATOM_TO_STRING(fun->atom), 0);
13824:                 }
13824:             } else if (clasp->flags & JSCLASS_HAS_PRIVATE) {
  786:                 jsval     privateValue = STOBJ_GET_SLOT(obj, JSSLOT_PRIVATE);
  786:                 void      *privateThing = JSVAL_IS_VOID(privateValue)
  786:                                           ? NULL
  786:                                           : JSVAL_TO_PRIVATE(privateValue);
  786: 
  786:                 JS_snprintf(buf, bufsize, "%p", privateThing);
11846:             } else {
11846:                 JS_snprintf(buf, bufsize, "<no private>");
11846:             }
  786:             break;
  786:           }
  786: 
  786:           case JSTRACE_STRING:
  786:             js_PutEscapedString(buf, bufsize, (JSString *)thing, 0);
  786:             break;
  786: 
  786:           case JSTRACE_DOUBLE:
  786:             JS_snprintf(buf, bufsize, "%g", *(jsdouble *)thing);
  786:             break;
  786: 
  786: #if JS_HAS_XML_SUPPORT
 4529:           case JSTRACE_XML:
  786:           {
  786:             extern const char *js_xml_class_str[];
  786:             JSXML *xml = (JSXML *)thing;
  786: 
  786:             JS_snprintf(buf, bufsize, "%s", js_xml_class_str[xml->xml_class]);
  786:             break;
  786:           }
  786: #endif
  786:           default:
  786:             JS_ASSERT(0);
  786:             break;
  786:         }
  786:     }
  786:     buf[bufsize - 1] = '\0';
  786: }
  786: 
  786: typedef struct JSHeapDumpNode JSHeapDumpNode;
  786: 
  786: struct JSHeapDumpNode {
  786:     void            *thing;
  786:     uint32          kind;
  786:     JSHeapDumpNode  *next;          /* next sibling */
  786:     JSHeapDumpNode  *parent;        /* node with the thing that refer to thing
  786:                                        from this node */
  786:     char            edgeName[1];    /* name of the edge from parent->thing
  786:                                        into thing */
  786: };
  786: 
  786: typedef struct JSDumpingTracer {
  786:     JSTracer            base;
  786:     JSDHashTable        visited;
  786:     JSBool              ok;
  786:     void                *startThing;
  786:     void                *thingToFind;
  786:     void                *thingToIgnore;
  786:     JSHeapDumpNode      *parentNode;
  786:     JSHeapDumpNode      **lastNodep;
  786:     char                buffer[200];
  786: } JSDumpingTracer;
  786: 
  786: static void
  786: DumpNotify(JSTracer *trc, void *thing, uint32 kind)
  786: {
  786:     JSDumpingTracer *dtrc;
  786:     JSContext *cx;
  786:     JSDHashEntryStub *entry;
  786:     JSHeapDumpNode *node;
  786:     const char *edgeName;
  786:     size_t edgeNameSize;
  786: 
  786:     JS_ASSERT(trc->callback == DumpNotify);
  786:     dtrc = (JSDumpingTracer *)trc;
  786: 
  786:     if (!dtrc->ok || thing == dtrc->thingToIgnore)
  786:         return;
  786: 
  786:     cx = trc->context;
  786: 
  786:     /*
  786:      * Check if we have already seen thing unless it is thingToFind to include
  786:      * it to the graph each time we reach it and print all live things that
  786:      * refer to thingToFind.
  786:      *
  786:      * This does not print all possible paths leading to thingToFind since
  786:      * when a thing A refers directly or indirectly to thingToFind and A is
  786:      * present several times in the graph, we will print only the first path
  786:      * leading to A and thingToFind, other ways to reach A will be ignored.
  786:      */
  786:     if (dtrc->thingToFind != thing) {
  786:         /*
  786:          * The startThing check allows to avoid putting startThing into the
  786:          * hash table before tracing startThing in JS_DumpHeap.
  786:          */
  786:         if (thing == dtrc->startThing)
  786:             return;
  786:         entry = (JSDHashEntryStub *)
  786:             JS_DHashTableOperate(&dtrc->visited, thing, JS_DHASH_ADD);
  786:         if (!entry) {
  786:             JS_ReportOutOfMemory(cx);
  786:             dtrc->ok = JS_FALSE;
  786:             return;
  786:         }
  786:         if (entry->key)
  786:             return;
  786:         entry->key = thing;
  786:     }
  786: 
  786:     if (dtrc->base.debugPrinter) {
  786:         dtrc->base.debugPrinter(trc, dtrc->buffer, sizeof(dtrc->buffer));
  786:         edgeName = dtrc->buffer;
  786:     } else if (dtrc->base.debugPrintIndex != (size_t)-1) {
  786:         JS_snprintf(dtrc->buffer, sizeof(dtrc->buffer), "%s[%lu]",
  786:                     (const char *)dtrc->base.debugPrintArg,
  786:                     dtrc->base.debugPrintIndex);
  786:         edgeName = dtrc->buffer;
  786:     } else {
  786:         edgeName = (const char*)dtrc->base.debugPrintArg;
  786:     }
  786: 
  786:     edgeNameSize = strlen(edgeName) + 1;
  786:     node = (JSHeapDumpNode *)
  786:         JS_malloc(cx, offsetof(JSHeapDumpNode, edgeName) + edgeNameSize);
  786:     if (!node) {
  786:         dtrc->ok = JS_FALSE;
  786:         return;
  786:     }
  786: 
  786:     node->thing = thing;
  786:     node->kind = kind;
  786:     node->next = NULL;
  786:     node->parent = dtrc->parentNode;
  786:     memcpy(node->edgeName, edgeName, edgeNameSize);
  786: 
  786:     JS_ASSERT(!*dtrc->lastNodep);
  786:     *dtrc->lastNodep = node;
  786:     dtrc->lastNodep = &node->next;
  786: }
  786: 
  786: /* Dump node and the chain that leads to thing it contains. */
  786: static JSBool
  917: DumpNode(JSDumpingTracer *dtrc, FILE* fp, JSHeapDumpNode *node)
  786: {
  786:     JSHeapDumpNode *prev, *following;
  786:     size_t chainLimit;
  786:     JSBool ok;
  786:     enum { MAX_PARENTS_TO_PRINT = 10 };
  786: 
  786:     JS_PrintTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
  786:                            &dtrc->base, node->thing, node->kind, JS_TRUE);
  917:     if (fprintf(fp, "%p %-22s via ", node->thing, dtrc->buffer) < 0)
  786:         return JS_FALSE;
  786: 
  786:     /*
  786:      * We need to print the parent chain in the reverse order. To do it in
  786:      * O(N) time where N is the chain length we first reverse the chain while
  786:      * searching for the top and then print each node while restoring the
  786:      * chain order.
  786:      */
  786:     chainLimit = MAX_PARENTS_TO_PRINT;
  786:     prev = NULL;
  786:     for (;;) {
  786:         following = node->parent;
  786:         node->parent = prev;
  786:         prev = node;
  786:         node = following;
  786:         if (!node)
  786:             break;
  786:         if (chainLimit == 0) {
  917:             if (fputs("...", fp) < 0)
  786:                 return JS_FALSE;
  786:             break;
  786:         }
  786:         --chainLimit;
  786:     }
  786: 
  786:     node = prev;
  786:     prev = following;
  786:     ok = JS_TRUE;
  786:     do {
  786:         /* Loop must continue even when !ok to restore the parent chain. */
  786:         if (ok) {
  786:             if (!prev) {
  786:                 /* Print edge from some runtime root or startThing. */
  917:                 if (fputs(node->edgeName, fp) < 0)
  786:                     ok = JS_FALSE;
  786:             } else {
  786:                 JS_PrintTraceThingInfo(dtrc->buffer, sizeof dtrc->buffer,
  786:                                        &dtrc->base, prev->thing, prev->kind,
  786:                                        JS_FALSE);
  917:                 if (fprintf(fp, "(%p %s).%s",
  786:                            prev->thing, dtrc->buffer, node->edgeName) < 0) {
  786:                     ok = JS_FALSE;
  786:                 }
  786:             }
  786:         }
  786:         following = node->parent;
  786:         node->parent = prev;
  786:         prev = node;
  786:         node = following;
  786:     } while (node);
  786: 
  917:     return ok && putc('\n', fp) >= 0;
  786: }
  786: 
  786: JS_PUBLIC_API(JSBool)
  917: JS_DumpHeap(JSContext *cx, FILE *fp, void* startThing, uint32 startKind,
  917:             void *thingToFind, size_t maxDepth, void *thingToIgnore)
  786: {
  786:     JSDumpingTracer dtrc;
  786:     JSHeapDumpNode *node, *children, *next, *parent;
  786:     size_t depth;
  786:     JSBool thingToFindWasTraced;
  786: 
  786:     if (maxDepth == 0)
  786:         return JS_TRUE;
  786: 
  786:     JS_TRACER_INIT(&dtrc.base, cx, DumpNotify);
  786:     if (!JS_DHashTableInit(&dtrc.visited, JS_DHashGetStubOps(),
  786:                            NULL, sizeof(JSDHashEntryStub),
  786:                            JS_DHASH_DEFAULT_CAPACITY(100))) {
  786:         JS_ReportOutOfMemory(cx);
  786:         return JS_FALSE;
  786:     }
  786:     dtrc.ok = JS_TRUE;
  786:     dtrc.startThing = startThing;
  786:     dtrc.thingToFind = thingToFind;
  786:     dtrc.thingToIgnore = thingToIgnore;
  786:     dtrc.parentNode = NULL;
  786:     node = NULL;
  786:     dtrc.lastNodep = &node;
  786:     if (!startThing) {
  786:         JS_ASSERT(startKind == 0);
  786:         JS_TraceRuntime(&dtrc.base);
  786:     } else {
  786:         JS_TraceChildren(&dtrc.base, startThing, startKind);
  786:     }
  786: 
  786:     depth = 1;
  786:     if (!node)
  786:         goto dump_out;
  786: 
  786:     thingToFindWasTraced = thingToFind && thingToFind == startThing;
  786:     for (;;) {
  786:         /*
  786:          * Loop must continue even when !dtrc.ok to free all nodes allocated
  786:          * so far.
  786:          */
  786:         if (dtrc.ok) {
  786:             if (thingToFind == NULL || thingToFind == node->thing)
  917:                 dtrc.ok = DumpNode(&dtrc, fp, node);
  786: 
  786:             /* Descend into children. */
  786:             if (dtrc.ok &&
  786:                 depth < maxDepth &&
  786:                 (thingToFind != node->thing || !thingToFindWasTraced)) {
  786:                 dtrc.parentNode = node;
  786:                 children = NULL;
  786:                 dtrc.lastNodep = &children;
  786:                 JS_TraceChildren(&dtrc.base, node->thing, node->kind);
  786:                 if (thingToFind == node->thing)
  786:                     thingToFindWasTraced = JS_TRUE;
  786:                 if (children != NULL) {
  786:                     ++depth;
  786:                     node = children;
  786:                     continue;
  786:                 }
  786:             }
  786:         }
  786: 
  786:         /* Move to next or parents next and free the node. */
  786:         for (;;) {
  786:             next = node->next;
  786:             parent = node->parent;
  786:             JS_free(cx, node);
  786:             node = next;
  786:             if (node)
  786:                 break;
  786:             if (!parent)
  786:                 goto dump_out;
  786:             JS_ASSERT(depth > 1);
  786:             --depth;
  786:             node = parent;
  786:         }
  786:     }
  786: 
  786:   dump_out:
  786:     JS_ASSERT(depth == 1);
  786:     JS_DHashTableFinish(&dtrc.visited);
  786:     return dtrc.ok;
  786: }
  786: 
  786: #endif /* DEBUG */
  786: 
  786: JS_PUBLIC_API(void)
    1: JS_MarkGCThing(JSContext *cx, void *thing, const char *name, void *arg)
    1: {
  583:     JSTracer *trc;
  583: 
  583:     trc = (JSTracer *)arg;
  583:     if (!trc)
  583:         trc = cx->runtime->gcMarkingTracer;
  583:     else
  583:         JS_ASSERT(trc == cx->runtime->gcMarkingTracer);
  583: 
    1: #ifdef JS_THREADSAFE
  583:     JS_ASSERT(cx->runtime->gcThread == trc->context->thread);
    1: #endif
  583:     JS_SET_TRACING_NAME(trc, name ? name : "unknown");
  771:     js_CallValueTracerIfGCThing(trc, (jsval)thing);
  583: }
  583: 
  583: extern JS_PUBLIC_API(JSBool)
  583: JS_IsGCMarkingTracer(JSTracer *trc)
  583: {
  583:     return IS_GC_MARKING_TRACER(trc);
  583: }
  583: 
    1: JS_PUBLIC_API(void)
    1: JS_GC(JSContext *cx)
    1: {
24499:     js_LeaveTrace(cx);
24499: 
    1:     /* Don't nuke active arenas if executing or compiling. */
    1:     if (cx->stackPool.current == &cx->stackPool.first)
    1:         JS_FinishArenaPool(&cx->stackPool);
    1:     if (cx->tempPool.current == &cx->tempPool.first)
    1:         JS_FinishArenaPool(&cx->tempPool);
    1:     js_GC(cx, GC_NORMAL);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_MaybeGC(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     uint32 bytes, lastBytes;
    1: 
    1:     rt = cx->runtime;
 1492: 
 1492: #ifdef JS_GC_ZEAL
 1492:     if (rt->gcZeal > 0) {
 1492:         JS_GC(cx);
 1492:         return;
 1492:     }
 1492: #endif
 1492: 
    1:     bytes = rt->gcBytes;
    1:     lastBytes = rt->gcLastBytes;
    1: 
    1:     /*
    1:      * We run the GC if we used all available free GC cells and had to
    1:      * allocate extra 1/3 of GC arenas since the last run of GC, or if
    1:      * we have malloc'd more bytes through JS_malloc than we were told
    1:      * to allocate by JS_NewRuntime.
    1:      *
    1:      * The reason for
    1:      *   bytes > 4/3 lastBytes
    1:      * condition is the following. Bug 312238 changed bytes and lastBytes
    1:      * to mean the total amount of memory that the GC uses now and right
    1:      * after the last GC.
    1:      *
    1:      * Before the bug the variables meant the size of allocated GC things
    1:      * now and right after the last GC. That size did not include the
    1:      * memory taken by free GC cells and the condition was
    1:      *   bytes > 3/2 lastBytes.
    1:      * That is, we run the GC if we have half again as many bytes of
    1:      * GC-things as the last time we GC'd. To be compatible we need to
    1:      * express that condition through the new meaning of bytes and
    1:      * lastBytes.
    1:      *
    1:      * We write the original condition as
    1:      *   B*(1-F) > 3/2 Bl*(1-Fl)
    1:      * where B is the total memory size allocated by GC and F is the free
    1:      * cell density currently and Sl and Fl are the size and the density
    1:      * right after GC. The density by definition is memory taken by free
    1:      * cells divided by total amount of memory. In other words, B and Bl
    1:      * are bytes and lastBytes with the new meaning and B*(1-F) and
    1:      * Bl*(1-Fl) are bytes and lastBytes with the original meaning.
    1:      *
    1:      * Our task is to exclude F and Fl from the last statement. According
    1:      * to the stats from bug 331966 comment 23, Fl is about 10-25% for a
    1:      * typical run of the browser. It means that the original condition
    1:      * implied that we did not run GC unless we exhausted the pool of
    1:      * free cells. Indeed if we still have free cells, then B == Bl since
    1:      * we did not yet allocated any new arenas and the condition means
    1:      *   1 - F > 3/2 (1-Fl) or 3/2Fl > 1/2 + F
    1:      * That implies 3/2 Fl > 1/2 or Fl > 1/3. That cannot be fulfilled
    1:      * for the state described by the stats. So we can write the original
    1:      * condition as:
    1:      *   F == 0 && B > 3/2 Bl(1-Fl)
    1:      * Again using the stats we see that Fl is about 11% when the browser
    1:      * starts up and when we are far from hitting rt->gcMaxBytes. With
    1:      * this F we have
    1:      * F == 0 && B > 3/2 Bl(1-0.11)
    1:      * or approximately F == 0 && B > 4/3 Bl.
    1:      */
    1:     if ((bytes > 8192 && bytes > lastBytes + lastBytes / 3) ||
    1:         rt->gcMallocBytes >= rt->gcMaxMallocBytes) {
    1:         JS_GC(cx);
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSGCCallback)
    1: JS_SetGCCallback(JSContext *cx, JSGCCallback cb)
    1: {
11022:     CHECK_REQUEST(cx);
    1:     return JS_SetGCCallbackRT(cx->runtime, cb);
    1: }
    1: 
    1: JS_PUBLIC_API(JSGCCallback)
    1: JS_SetGCCallbackRT(JSRuntime *rt, JSGCCallback cb)
    1: {
    1:     JSGCCallback oldcb;
    1: 
    1:     oldcb = rt->gcCallback;
    1:     rt->gcCallback = cb;
    1:     return oldcb;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsAboutToBeFinalized(JSContext *cx, void *thing)
    1: {
    1:     JS_ASSERT(thing);
    1:     return js_IsAboutToBeFinalized(cx, thing);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetGCParameter(JSRuntime *rt, JSGCParamKey key, uint32 value)
    1: {
    1:     switch (key) {
    1:       case JSGC_MAX_BYTES:
    1:         rt->gcMaxBytes = value;
    1:         break;
    1:       case JSGC_MAX_MALLOC_BYTES:
    1:         rt->gcMaxMallocBytes = value;
    1:         break;
10985:       case JSGC_STACKPOOL_LIFESPAN:
19196:         rt->gcEmptyArenaPoolLifespan = value;
10985:         break;
24313:       default:
24313:         JS_ASSERT(key == JSGC_TRIGGER_FACTOR);
24313:         JS_ASSERT(value >= 100);
24313:         rt->gcTriggerFactor = value;
24313:         return;
24313:     }
24313: }
24313: 
24313: JS_PUBLIC_API(uint32)
24313: JS_GetGCParameter(JSRuntime *rt, JSGCParamKey key)
24313: {
24313:     switch (key) {
24313:       case JSGC_MAX_BYTES:
24313:         return rt->gcMaxBytes;
24313:       case JSGC_MAX_MALLOC_BYTES:
24313:         return rt->gcMaxMallocBytes;
24313:       case JSGC_STACKPOOL_LIFESPAN:
24313:         return rt->gcEmptyArenaPoolLifespan;
24313:       case JSGC_TRIGGER_FACTOR:
24313:         return rt->gcTriggerFactor;
24313:       case JSGC_BYTES:
24313:         return rt->gcBytes;
24313:       default:
24313:         JS_ASSERT(key == JSGC_NUMBER);
24313:         return rt->gcNumber;
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(intN)
    1: JS_AddExternalStringFinalizer(JSStringFinalizeOp finalizer)
    1: {
    1:     return js_ChangeExternalStringFinalizer(NULL, finalizer);
    1: }
    1: 
    1: JS_PUBLIC_API(intN)
    1: JS_RemoveExternalStringFinalizer(JSStringFinalizeOp finalizer)
    1: {
    1:     return js_ChangeExternalStringFinalizer(finalizer, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewExternalString(JSContext *cx, jschar *chars, size_t length, intN type)
    1: {
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
 8005:     JS_ASSERT((uintN) type < (uintN) (GCX_NTYPES - GCX_EXTERNAL_STRING));
 8005: 
 8005:     str = (JSString *) js_NewGCThing(cx, (uintN) type + GCX_EXTERNAL_STRING,
 8005:                                      sizeof(JSString));
    1:     if (!str)
    1:         return NULL;
10444:     JSFLATSTR_INIT(str, chars, length);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(intN)
    1: JS_GetExternalStringGCType(JSRuntime *rt, JSString *str)
    1: {
 8005:     return js_GetExternalStringGCType(str);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetThreadStackLimit(JSContext *cx, jsuword limitAddr)
    1: {
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1:     if (limitAddr == 0)
    1:         limitAddr = (jsuword)-1;
    1: #endif
    1:     cx->stackLimit = limitAddr;
    1: }
    1: 
 5344: JS_PUBLIC_API(void)
 5344: JS_SetScriptStackQuota(JSContext *cx, size_t quota)
 5344: {
 5344:     cx->scriptStackQuota = quota;
 5344: }
 5344: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyIdArray(JSContext *cx, JSIdArray *ida)
    1: {
    1:     JS_free(cx, ida);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ValueToId(JSContext *cx, jsval v, jsid *idp)
    1: {
    1:     CHECK_REQUEST(cx);
10573:     if (JSVAL_IS_INT(v))
    1:         *idp = INT_JSVAL_TO_JSID(v);
    1: #if JS_HAS_XML_SUPPORT
10573:     else if (!JSVAL_IS_PRIMITIVE(v))
    1:         *idp = OBJECT_JSVAL_TO_JSID(v);
    1: #endif
10573:     else
10573:         return js_ValueToStringId(cx, v, idp);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IdToValue(JSContext *cx, jsid id, jsval *vp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     *vp = ID_TO_VALUE(id);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_PropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EnumerateStub(JSContext *cx, JSObject *obj)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ResolveStub(JSContext *cx, JSObject *obj, jsval id)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ConvertStub(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
    1:     return js_TryValueOf(cx, obj, type, vp);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_FinalizeStub(JSContext *cx, JSObject *obj)
    1: {
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
    1:              JSClass *clasp, JSNative constructor, uintN nargs,
    1:              JSPropertySpec *ps, JSFunctionSpec *fs,
    1:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
    1: {
25897:     CHECK_REQUEST(cx);
25897:     return js_InitClass(cx, obj, parent_proto, clasp, constructor, nargs,
25887:                         ps, fs, static_ps, static_fs, NULL);
25887: }
25887: 
    1: #ifdef JS_THREADSAFE
    1: JS_PUBLIC_API(JSClass *)
    1: JS_GetClass(JSContext *cx, JSObject *obj)
    1: {
10592:     return OBJ_GET_CLASS(cx, obj);
    1: }
    1: #else
    1: JS_PUBLIC_API(JSClass *)
    1: JS_GetClass(JSObject *obj)
    1: {
    1:     return LOCKED_OBJ_GET_CLASS(obj);
    1: }
    1: #endif
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_InstanceOf(JSContext *cx, JSObject *obj, JSClass *clasp, jsval *argv)
    1: {
    1:     JSFunction *fun;
    1: 
    1:     CHECK_REQUEST(cx);
11809:     if (obj && OBJ_GET_CLASS(cx, obj) == clasp)
    1:         return JS_TRUE;
    1:     if (argv) {
    1:         fun = js_ValueToFunction(cx, &argv[-2], 0);
    1:         if (fun) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_INCOMPATIBLE_PROTO,
    1:                                  clasp->name, JS_GetFunctionName(fun),
11809:                                  obj
11809:                                  ? OBJ_GET_CLASS(cx, obj)->name
11809:                                  : js_null_str);
    1:         }
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     return js_HasInstance(cx, obj, v, bp);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetPrivate(JSContext *cx, JSObject *obj)
    1: {
    1:     jsval v;
    1: 
    1:     JS_ASSERT(OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_HAS_PRIVATE);
10592:     v = obj->fslots[JSSLOT_PRIVATE];
    1:     if (!JSVAL_IS_INT(v))
    1:         return NULL;
    1:     return JSVAL_TO_PRIVATE(v);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetPrivate(JSContext *cx, JSObject *obj, void *data)
    1: {
    1:     JS_ASSERT(OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_HAS_PRIVATE);
10592:     obj->fslots[JSSLOT_PRIVATE] = PRIVATE_TO_JSVAL(data);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetInstancePrivate(JSContext *cx, JSObject *obj, JSClass *clasp,
    1:                       jsval *argv)
    1: {
    1:     if (!JS_InstanceOf(cx, obj, clasp, argv))
    1:         return NULL;
    1:     return JS_GetPrivate(cx, obj);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetPrototype(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto;
    1: 
    1:     CHECK_REQUEST(cx);
10592:     proto = OBJ_GET_PROTO(cx, obj);
    1: 
    1:     /* Beware ref to dead object (we may be called from obj's finalizer). */
    1:     return proto && proto->map ? proto : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetPrototype(JSContext *cx, JSObject *obj, JSObject *proto)
    1: {
    1:     CHECK_REQUEST(cx);
14601:     JS_ASSERT(obj != proto);
11778:     if (OBJ_IS_NATIVE(obj)) {
11700:         JS_LOCK_OBJ(cx, obj);
11778:         if (!js_GetMutableScope(cx, obj)) {
11700:             JS_UNLOCK_OBJ(cx, obj);
11700:             return JS_FALSE;
11700:         }
11700:         LOCKED_OBJ_SET_PROTO(obj, proto);
11700:         JS_UNLOCK_OBJ(cx, obj);
11778:         return JS_TRUE;
11778:     }
    1:     OBJ_SET_PROTO(cx, obj, proto);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetParent(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *parent;
    1: 
10592:     parent = OBJ_GET_PARENT(cx, obj);
    1: 
    1:     /* Beware ref to dead object (we may be called from obj's finalizer). */
    1:     return parent && parent->map ? parent : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetParent(JSContext *cx, JSObject *obj, JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
14601:     JS_ASSERT(obj != parent);
    1:     OBJ_SET_PARENT(cx, obj, parent);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetConstructor(JSContext *cx, JSObject *proto)
    1: {
    1:     jsval cval;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     {
19712:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
19712: 
    1:         if (!OBJ_GET_PROPERTY(cx, proto,
    1:                               ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
    1:                               &cval)) {
    1:             return NULL;
    1:         }
19712:     }
    1:     if (!VALUE_IS_FUNCTION(cx, cval)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR,
    1:                              OBJ_GET_CLASS(cx, proto)->name);
    1:         return NULL;
    1:     }
    1:     return JSVAL_TO_OBJECT(cval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetObjectId(JSContext *cx, JSObject *obj, jsid *idp)
    1: {
 4529:     JS_ASSERT(JSID_IS_OBJECT(obj));
    1:     *idp = OBJECT_TO_JSID(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewObject(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
13427:     return js_NewObject(cx, clasp, proto, parent, 0);
 3624: }
 3624: 
11700: JS_PUBLIC_API(JSObject *)
11700: JS_NewObjectWithGivenProto(JSContext *cx, JSClass *clasp, JSObject *proto,
11700:                            JSObject *parent)
11700: {
11700:     CHECK_REQUEST(cx);
11700:     if (!clasp)
11700:         clasp = &js_ObjectClass;    /* default class is Object */
13427:     return js_NewObjectWithGivenProto(cx, clasp, proto, parent, 0);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SealObject(JSContext *cx, JSObject *obj, JSBool deep)
    1: {
    1:     JSScope *scope;
    1:     JSIdArray *ida;
    1:     uint32 nslots, i;
    1:     jsval v;
    1: 
22452:     if (OBJ_IS_DENSE_ARRAY(cx, obj) && !js_MakeArraySlow(cx, obj))
22452:         return JS_FALSE;
22452: 
    1:     if (!OBJ_IS_NATIVE(obj)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_SEAL_OBJECT,
    1:                              OBJ_GET_CLASS(cx, obj)->name);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     scope = OBJ_SCOPE(obj);
    1: 
    1: #if defined JS_THREADSAFE && defined DEBUG
    1:     /* Insist on scope being used exclusively by cx's thread. */
11739:     if (scope->title.ownercx != cx) {
    1:         JS_LOCK_OBJ(cx, obj);
    1:         JS_ASSERT(OBJ_SCOPE(obj) == scope);
11739:         JS_ASSERT(scope->title.ownercx == cx);
    1:         JS_UNLOCK_SCOPE(cx, scope);
    1:     }
    1: #endif
    1: 
    1:     /* Nothing to do if obj's scope is already sealed. */
    1:     if (SCOPE_IS_SEALED(scope))
    1:         return JS_TRUE;
    1: 
    1:     /* XXX Enumerate lazy properties now, as they can't be added later. */
    1:     ida = JS_Enumerate(cx, obj);
    1:     if (!ida)
    1:         return JS_FALSE;
    1:     JS_DestroyIdArray(cx, ida);
    1: 
    1:     /* Ensure that obj has its own, mutable scope, and seal that scope. */
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
11377:     if (scope) {
    1:         SCOPE_SET_SEALED(scope);
12307:         SCOPE_MAKE_UNIQUE_SHAPE(cx, scope);
11377:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     if (!scope)
    1:         return JS_FALSE;
    1: 
    1:     /* If we are not sealing an entire object graph, we're done. */
    1:     if (!deep)
    1:         return JS_TRUE;
    1: 
    1:     /* Walk slots in obj and if any value is a non-null object, seal it. */
13705:     nslots = scope->map.freeslot;
    1:     for (i = 0; i != nslots; ++i) {
    1:         v = STOBJ_GET_SLOT(obj, i);
    1:         if (JSVAL_IS_PRIMITIVE(v))
    1:             continue;
    1:         if (!JS_SealObject(cx, JSVAL_TO_OBJECT(v), deep))
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_ConstructObject(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                    JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
    1:     return js_ConstructObject(cx, clasp, proto, parent, 0, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_ConstructObjectWithArguments(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                                 JSObject *parent, uintN argc, jsval *argv)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
    1:     return js_ConstructObject(cx, clasp, proto, parent, argc, argv);
    1: }
    1: 
    1: static JSBool
20964: DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
20964:                    JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
20964:                    uintN flags, intN tinyid)
20964: {
20964:     if (flags != 0 && OBJ_IS_NATIVE(obj)) {
20964:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
20964:         return js_DefineNativeProperty(cx, obj, id, value, getter, setter,
20964:                                        attrs, flags, tinyid, NULL);
20964:     }
20964:     return OBJ_DEFINE_PROPERTY(cx, obj, id, value, getter, setter, attrs,
20964:                                NULL);   
20964: }
20964: 
20964: static JSBool
    1: DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
    1:                JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
    1:                uintN flags, intN tinyid)
    1: {
    1:     jsid id;
    1:     JSAtom *atom;
    1: 
    1:     if (attrs & JSPROP_INDEX) {
    1:         id = INT_TO_JSID(JS_PTR_TO_INT32(name));
    1:         atom = NULL;
    1:         attrs &= ~JSPROP_INDEX;
    1:     } else {
    1:         atom = js_Atomize(cx, name, strlen(name), 0);
    1:         if (!atom)
    1:             return JS_FALSE;
    1:         id = ATOM_TO_JSID(atom);
    1:     }
20964:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs,
20964:                               flags, tinyid);
    1: }
    1: 
    1: #define AUTO_NAMELEN(s,n)   (((n) == (size_t)-1) ? js_strlen(s) : (n))
    1: 
    1: static JSBool
    1: DefineUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen, jsval value,
    1:                  JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
    1:                  uintN flags, intN tinyid)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
    1:     if (flags != 0 && OBJ_IS_NATIVE(obj)) {
19712:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
    1:         return js_DefineNativeProperty(cx, obj, ATOM_TO_JSID(atom), value,
    1:                                        getter, setter, attrs, flags, tinyid,
    1:                                        NULL);
    1:     }
    1:     return OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), value,
    1:                                getter, setter, attrs, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_DefineObject(JSContext *cx, JSObject *obj, const char *name, JSClass *clasp,
    1:                 JSObject *proto, uintN attrs)
    1: {
    1:     JSObject *nobj;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     if (!clasp)
    1:         clasp = &js_ObjectClass;    /* default class is Object */
13427:     nobj = js_NewObject(cx, clasp, proto, obj, 0);
    1:     if (!nobj)
    1:         return NULL;
    1:     if (!DefineProperty(cx, obj, name, OBJECT_TO_JSVAL(nobj), NULL, NULL, attrs,
    1:                         0, 0)) {
    1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:         return NULL;
    1:     }
    1:     return nobj;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineConstDoubles(JSContext *cx, JSObject *obj, JSConstDoubleSpec *cds)
    1: {
    1:     JSBool ok;
    1:     jsval value;
19712:     uintN attrs;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     for (ok = JS_TRUE; cds->name; cds++) {
12850:         ok = js_NewNumberInRootedValue(cx, cds->dval, &value);
    1:         if (!ok)
    1:             break;
19712:         attrs = cds->flags;
19712:         if (!attrs)
19712:             attrs = JSPROP_READONLY | JSPROP_PERMANENT;
19712:         ok = DefineProperty(cx, obj, cds->name, value, NULL, NULL, attrs, 0, 0);
    1:         if (!ok)
    1:             break;
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineProperties(JSContext *cx, JSObject *obj, JSPropertySpec *ps)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     for (ok = JS_TRUE; ps->name; ps++) {
    1:         ok = DefineProperty(cx, obj, ps->name, JSVAL_VOID,
    1:                             ps->getter, ps->setter, ps->flags,
    1:                             SPROP_HAS_SHORTID, ps->tinyid);
    1:         if (!ok)
    1:             break;
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineProperty(JSContext *cx, JSObject *obj, const char *name, jsval value,
    1:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return DefineProperty(cx, obj, name, value, getter, setter, attrs, 0, 0);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_DefinePropertyById(JSContext *cx, JSObject *obj, jsid id, jsval value,
20964:                       JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
20964: {
20964:     CHECK_REQUEST(cx);
20964:     return DefinePropertyById(cx, obj, id, value, getter, setter, attrs, 0, 0);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_DefinePropertyWithTinyId(JSContext *cx, JSObject *obj, const char *name,
    1:                             int8 tinyid, jsval value,
    1:                             JSPropertyOp getter, JSPropertyOp setter,
    1:                             uintN attrs)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return DefineProperty(cx, obj, name, value, getter, setter, attrs,
    1:                           SPROP_HAS_SHORTID, tinyid);
    1: }
    1: 
    1: static JSBool
19712: LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
19712:                    JSObject **objp, JSProperty **propp)
19712: {
19712:     JSAutoResolveFlags rf(cx, flags);
19712:     return OBJ_LOOKUP_PROPERTY(cx, obj, id, objp, propp);
19712: }
19712: 
19712: static JSBool
19712: LookupProperty(JSContext *cx, JSObject *obj, const char *name, uintN flags,
19712:                JSObject **objp, JSProperty **propp)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     atom = js_Atomize(cx, name, strlen(name), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712:     return LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), flags, objp, propp);
    1: }
    1: 
    1: static JSBool
    1: LookupUCProperty(JSContext *cx, JSObject *obj,
19712:                  const jschar *name, size_t namelen, uintN flags,
    1:                  JSObject **objp, JSProperty **propp)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712:     return LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), flags, objp, propp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_AliasProperty(JSContext *cx, JSObject *obj, const char *name,
    1:                  const char *alias)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     JSAtom *atom;
    1:     JSBool ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     if (!LookupProperty(cx, obj, name, JSRESOLVE_QUALIFIED, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         js_ReportIsNotDefined(cx, name);
    1:         return JS_FALSE;
    1:     }
    1:     if (obj2 != obj || !OBJ_IS_NATIVE(obj)) {
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_ALIAS,
    1:                              alias, name, OBJ_GET_CLASS(cx, obj2)->name);
    1:         return JS_FALSE;
    1:     }
    1:     atom = js_Atomize(cx, alias, strlen(alias), 0);
    1:     if (!atom) {
    1:         ok = JS_FALSE;
    1:     } else {
    1:         sprop = (JSScopeProperty *)prop;
    1:         ok = (js_AddNativeProperty(cx, obj, ATOM_TO_JSID(atom),
    1:                                    sprop->getter, sprop->setter, sprop->slot,
    1:                                    sprop->attrs, sprop->flags | SPROP_IS_ALIAS,
    1:                                    sprop->shortid)
    1:               != NULL);
    1:     }
    1:     OBJ_DROP_PROPERTY(cx, obj, prop);
    1:     return ok;
    1: }
    1: 
    1: static jsval
    1: LookupResult(JSContext *cx, JSObject *obj, JSObject *obj2, JSProperty *prop)
    1: {
    1:     JSScopeProperty *sprop;
    1:     jsval rval;
    1: 
    1:     if (!prop) {
    1:         /* XXX bad API: no way to tell "not defined" from "void value" */
    1:         return JSVAL_VOID;
    1:     }
    1:     if (OBJ_IS_NATIVE(obj2)) {
    1:         /* Peek at the native property's slot value, without doing a Get. */
    1:         sprop = (JSScopeProperty *)prop;
    1:         rval = SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj2))
    1:                ? LOCKED_OBJ_GET_SLOT(obj2, sprop->slot)
    1:                : JSVAL_TRUE;
26820:     } else if (OBJ_IS_DENSE_ARRAY(cx, obj2)) {
26820:         rval = js_GetDenseArrayElementValue(obj2, prop);
    1:     } else {
    1:         /* XXX bad API: no way to return "defined but value unknown" */
    1:         rval = JSVAL_TRUE;
    1:     }
    1:     OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:     return rval;
    1: }
    1: 
    1: static JSBool
26022: GetPropertyAttributesById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
26022:                           JSBool own, JSPropertyDescriptor *desc)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     JSBool ok;
    1: 
26022:     if (!LookupPropertyById(cx, obj, id, flags, &obj2, &prop))
    1:         return JS_FALSE;
26022: 
26022:     if (!prop || (own && obj != obj2)) {
26022:         desc->obj = NULL;
26022:         desc->attrs = 0;
26022:         desc->getter = NULL;
26022:         desc->setter = NULL;
26024:         desc->value = JSVAL_VOID;
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         return JS_TRUE;
    1:     }
    1: 
26022:     desc->obj = obj2;
26022: 
26022:     ok = OBJ_GET_ATTRIBUTES(cx, obj2, id, prop, &desc->attrs);
26022:     if (ok) {
26022:         if (OBJ_IS_NATIVE(obj2)) {
    1:             JSScopeProperty *sprop = (JSScopeProperty *) prop;
    1: 
26022:             desc->getter = sprop->getter;
26022:             desc->setter = sprop->setter;
26024:             desc->value = SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj2))
26022:                           ? LOCKED_OBJ_GET_SLOT(obj2, sprop->slot)
26022:                           : JSVAL_VOID;
26022:         } else {
26022:             desc->getter = NULL;
26022:             desc->setter = NULL;
26024:             desc->value = JSVAL_VOID;
26022:         }
26022:     }
26022:     OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
24224: GetPropertyAttributes(JSContext *cx, JSObject *obj, JSAtom *atom,
24224:                       uintN *attrsp, JSBool *foundp,
24224:                       JSPropertyOp *getterp, JSPropertyOp *setterp)
26022: 
24224: {
24224:     if (!atom)
24224:         return JS_FALSE;
26022: 
26022:     JSPropertyDescriptor desc;
26022:     if (!GetPropertyAttributesById(cx, obj, ATOM_TO_JSID(atom),
26022:                                    JSRESOLVE_QUALIFIED, JS_FALSE, &desc)) {
26022:         return JS_FALSE;
26022:     }
26022: 
26022:     *attrsp = desc.attrs;
26022:     *foundp = (desc.obj != NULL);
26022:     if (getterp)
26022:         *getterp = desc.getter;
26022:     if (setterp)
26022:         *setterp = desc.setter;
26022:     return JS_TRUE;
24224: }
24224: 
24224: static JSBool
    1: SetPropertyAttributes(JSContext *cx, JSObject *obj, JSAtom *atom,
    1:                       uintN attrs, JSBool *foundp)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     JSBool ok;
    1: 
    1:     if (!atom)
    1:         return JS_FALSE;
19712:     if (!LookupPropertyById(cx, obj, ATOM_TO_JSID(atom), JSRESOLVE_QUALIFIED,
19712:                             &obj2, &prop)) {
    1:         return JS_FALSE;
19712:     }
    1:     if (!prop || obj != obj2) {
    1:         *foundp = JS_FALSE;
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     *foundp = JS_TRUE;
    1:     ok = OBJ_SET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop, &attrs);
    1:     OBJ_DROP_PROPERTY(cx, obj, prop);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
    1:                          uintN *attrsp, JSBool *foundp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return GetPropertyAttributes(cx, obj,
    1:                                  js_Atomize(cx, name, strlen(name), 0),
    1:                                  attrsp, foundp, NULL, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
    1:                                    const char *name,
    1:                                    uintN *attrsp, JSBool *foundp,
    1:                                    JSPropertyOp *getterp,
    1:                                    JSPropertyOp *setterp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return GetPropertyAttributes(cx, obj,
    1:                                  js_Atomize(cx, name, strlen(name), 0),
    1:                                  attrsp, foundp, getterp, setterp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
24145: JS_GetPropertyAttrsGetterAndSetterById(JSContext *cx, JSObject *obj,
24145:                                        jsid id,
24145:                                        uintN *attrsp, JSBool *foundp,
24145:                                        JSPropertyOp *getterp,
24145:                                        JSPropertyOp *setterp)
24145: {
24145:     CHECK_REQUEST(cx);
26022: 
26022:     JSPropertyDescriptor desc;
26022:     if (!GetPropertyAttributesById(cx, obj, id, JSRESOLVE_QUALIFIED, JS_FALSE, &desc))
26022:         return JS_FALSE;
26022: 
26022:     *attrsp = desc.attrs;
26022:     *foundp = (desc.obj != NULL);
26022:     if (getterp)
26022:         *getterp = desc.getter;
26022:     if (setterp)
26022:         *setterp = desc.setter;
26022:     return JS_TRUE;
24145: }
24145: 
24145: JS_PUBLIC_API(JSBool)
    1: JS_SetPropertyAttributes(JSContext *cx, JSObject *obj, const char *name,
    1:                          uintN attrs, JSBool *foundp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return SetPropertyAttributes(cx, obj,
    1:                                  js_Atomize(cx, name, strlen(name), 0),
    1:                                  attrs, foundp);
    1: }
    1: 
 7927: static JSBool
 7927: AlreadyHasOwnPropertyHelper(JSContext *cx, JSObject *obj, jsid id,
 7927:                             JSBool *foundp)
 7927: {
 7927:     JSScope *scope;
 7927: 
 7927:     if (!OBJ_IS_NATIVE(obj)) {
 7927:         JSObject *obj2;
 7927:         JSProperty *prop;
 7927: 
19712:         if (!LookupPropertyById(cx, obj, id,
19712:                                 JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
19712:                                 &obj2, &prop)) {
 7927:             return JS_FALSE;
19712:         }
 7927:         *foundp = (obj == obj2);
 7927:         if (prop)
 7927:             OBJ_DROP_PROPERTY(cx, obj2, prop);
 7927:         return JS_TRUE;
 7927:     }
 7927: 
 7927:     JS_LOCK_OBJ(cx, obj);
 7927:     scope = OBJ_SCOPE(obj);
 7927:     *foundp = (scope->object == obj && SCOPE_GET_PROPERTY(scope, id));
 7927:     JS_UNLOCK_SCOPE(cx, scope);
 7927:     return JS_TRUE;
 7927: }
 7927: 
 7927: JS_PUBLIC_API(JSBool)
 7927: JS_AlreadyHasOwnProperty(JSContext *cx, JSObject *obj, const char *name,
 7927:                          JSBool *foundp)
 7927: {
 7927:     JSAtom *atom;
 7927: 
10363:     CHECK_REQUEST(cx);
 7927:     atom = js_Atomize(cx, name, strlen(name), 0);
 7927:     if (!atom)
 7927:         return JS_FALSE;
 7927:     return AlreadyHasOwnPropertyHelper(cx, obj, ATOM_TO_JSID(atom), foundp);
 7927: }
 7927: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_AlreadyHasOwnPropertyById(JSContext *cx, JSObject *obj, jsid id,
20964:                              JSBool *foundp)
20964: {
20964:     CHECK_REQUEST(cx);
20964:     return AlreadyHasOwnPropertyHelper(cx, obj, id, foundp);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_HasProperty(JSContext *cx, JSObject *obj, const char *name, JSBool *foundp)
    1: {
    1:     JSBool ok;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = LookupProperty(cx, obj, name,
19712:                         JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
19712:                         &obj2, &prop);
    1:     if (ok) {
    1:         *foundp = (prop != NULL);
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_HasPropertyById(JSContext *cx, JSObject *obj, jsid id, JSBool *foundp)
20964: {
20964:     JSBool ok;
20964:     JSObject *obj2;
20964:     JSProperty *prop;
20964: 
20964:     CHECK_REQUEST(cx);
20964:     ok = LookupPropertyById(cx, obj, id,
20964:                             JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
20964:                             &obj2, &prop);
20964:     if (ok) {
20964:        *foundp = (prop != NULL);
20964:        if (prop)
20964:            OBJ_DROP_PROPERTY(cx, obj2, prop);
20964:     }
20964:     return ok;
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_LookupProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
    1: {
    1:     JSBool ok;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = LookupProperty(cx, obj, name, JSRESOLVE_QUALIFIED, &obj2, &prop);
    1:     if (ok)
    1:         *vp = LookupResult(cx, obj, obj2, prop);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_LookupPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
20964: {
20964:     JSBool ok;
20964:     JSObject *obj2;
20964:     JSProperty *prop;
20964: 
20964:     CHECK_REQUEST(cx);
20964:     ok = LookupPropertyById(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop);
20964:     if (ok)
20964:         *vp = LookupResult(cx, obj, obj2, prop);
20964:     return ok;
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, const char *name,
    1:                            uintN flags, jsval *vp)
    1: {
    1:     JSAtom *atom;
19712:     JSObject *obj2;
19712: 
19712:     atom = js_Atomize(cx, name, strlen(name), 0);
19712:     return atom &&
20964:            JS_LookupPropertyWithFlagsById(cx, obj, ATOM_TO_JSID(atom), flags,
19712:                                           &obj2, vp);
19712: }
19712: 
19712: JS_PUBLIC_API(JSBool)
20964: JS_LookupPropertyWithFlagsById(JSContext *cx, JSObject *obj, jsid id,
19712:                                uintN flags, JSObject **objp, jsval *vp)
19712: {
    1:     JSBool ok;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = OBJ_IS_NATIVE(obj)
19712:          ? js_LookupPropertyWithFlags(cx, obj, id, flags, objp, &prop) >= 0
19712:          : OBJ_LOOKUP_PROPERTY(cx, obj, id, objp, &prop);
19712:     if (ok)
19712:         *vp = LookupResult(cx, obj, *objp, prop);
19712:     return ok;
19712: }
19712: 
19712: JS_PUBLIC_API(JSBool)
26022: JS_GetPropertyDescriptorById(JSContext *cx, JSObject *obj, jsid id, uintN flags,
26022:                              JSPropertyDescriptor *desc)
26022: {
26022:     CHECK_REQUEST(cx);
26022: 
26428:     return GetPropertyAttributesById(cx, obj, id, flags, JS_FALSE, desc);
26022: }
26022: 
26022: JS_PUBLIC_API(JSBool)
19712: JS_GetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
19712: {
19712:     JSAtom *atom;
19712: 
19712:     CHECK_REQUEST(cx);
    1:     atom = js_Atomize(cx, name, strlen(name), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712: 
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
    1:     return OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_GetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
20964: {
20964:     CHECK_REQUEST(cx);
20964:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
20964:     return OBJ_GET_PROPERTY(cx, obj, id, vp);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_GetMethodById(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                  jsval *vp)
    1: {
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
19712: 
    1:     CHECK_REQUEST(cx);
26187:     if (!js_GetMethod(cx, obj, id, vp, NULL))
    1:         return JS_FALSE;
26187:     if (objp)
    1:         *objp = obj;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetMethod(JSContext *cx, JSObject *obj, const char *name, JSObject **objp,
    1:              jsval *vp)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     atom = js_Atomize(cx, name, strlen(name), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
    1:     return JS_GetMethodById(cx, obj, ATOM_TO_JSID(atom), objp, vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetProperty(JSContext *cx, JSObject *obj, const char *name, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_Atomize(cx, name, strlen(name), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712: 
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
    1:     return OBJ_SET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_SetPropertyById(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
20964: {
20964:     CHECK_REQUEST(cx);
20964:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
20964:     return OBJ_SET_PROPERTY(cx, obj, id, vp);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_DeleteProperty(JSContext *cx, JSObject *obj, const char *name)
    1: {
    1:     jsval junk;
    1: 
    1:     return JS_DeleteProperty2(cx, obj, name, &junk);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DeleteProperty2(JSContext *cx, JSObject *obj, const char *name,
    1:                    jsval *rval)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_Atomize(cx, name, strlen(name), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712: 
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
    1:     return OBJ_DELETE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
20964: JS_DeletePropertyById(JSContext *cx, JSObject *obj, jsid id)
20964: {
20964:     jsval junk;
20964: 
20964:     return JS_DeletePropertyById2(cx, obj, id, &junk);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
20964: JS_DeletePropertyById2(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
20964: {
20964:     CHECK_REQUEST(cx);
20964:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
20964:     return OBJ_DELETE_PROPERTY(cx, obj, id, rval);
20964: }
20964: 
20964: JS_PUBLIC_API(JSBool)
    1: JS_DefineUCProperty(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen, jsval value,
    1:                     JSPropertyOp getter, JSPropertyOp setter,
    1:                     uintN attrs)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return DefineUCProperty(cx, obj, name, namelen, value, getter, setter,
    1:                             attrs, 0, 0);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetUCPropertyAttributes(JSContext *cx, JSObject *obj,
    1:                            const jschar *name, size_t namelen,
    1:                            uintN *attrsp, JSBool *foundp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return GetPropertyAttributes(cx, obj,
    1:                     js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0),
    1:                     attrsp, foundp, NULL, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetUCPropertyAttrsGetterAndSetter(JSContext *cx, JSObject *obj,
    1:                                      const jschar *name, size_t namelen,
    1:                                      uintN *attrsp, JSBool *foundp,
    1:                                      JSPropertyOp *getterp,
    1:                                      JSPropertyOp *setterp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return GetPropertyAttributes(cx, obj,
    1:                     js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0),
    1:                     attrsp, foundp, getterp, setterp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetUCPropertyAttributes(JSContext *cx, JSObject *obj,
    1:                            const jschar *name, size_t namelen,
    1:                            uintN attrs, JSBool *foundp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return SetPropertyAttributes(cx, obj,
    1:                     js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0),
    1:                     attrs, foundp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineUCPropertyWithTinyId(JSContext *cx, JSObject *obj,
    1:                               const jschar *name, size_t namelen,
    1:                               int8 tinyid, jsval value,
    1:                               JSPropertyOp getter, JSPropertyOp setter,
    1:                               uintN attrs)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return DefineUCProperty(cx, obj, name, namelen, value, getter, setter,
    1:                             attrs, SPROP_HAS_SHORTID, tinyid);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
 7927: JS_AlreadyHasOwnUCProperty(JSContext *cx, JSObject *obj,
 7927:                            const jschar *name, size_t namelen,
 7927:                            JSBool *foundp)
 7927: {
 7927:     JSAtom *atom;
 7927: 
10363:     CHECK_REQUEST(cx);
 7927:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
 7927:     if (!atom)
 7927:         return JS_FALSE;
 7927:     return AlreadyHasOwnPropertyHelper(cx, obj, ATOM_TO_JSID(atom), foundp);
 7927: }
 7927: 
 7927: JS_PUBLIC_API(JSBool)
    1: JS_HasUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen,
    1:                  JSBool *vp)
    1: {
    1:     JSBool ok;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = LookupUCProperty(cx, obj, name, namelen, 
19712:                           JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
19712:                           &obj2, &prop);
    1:     if (ok) {
    1:         *vp = (prop != NULL);
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_LookupUCProperty(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen,
    1:                     jsval *vp)
    1: {
    1:     JSBool ok;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = LookupUCProperty(cx, obj, name, namelen, JSRESOLVE_QUALIFIED,
19712:                           &obj2, &prop);
    1:     if (ok)
    1:         *vp = LookupResult(cx, obj, obj2, prop);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen,
    1:                  jsval *vp)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712: 
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
    1:     return OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetUCProperty(JSContext *cx, JSObject *obj,
    1:                  const jschar *name, size_t namelen,
    1:                  jsval *vp)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712: 
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
    1:     return OBJ_SET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DeleteUCProperty2(JSContext *cx, JSObject *obj,
    1:                      const jschar *name, size_t namelen,
    1:                      jsval *rval)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
    1:     if (!atom)
    1:         return JS_FALSE;
19712: 
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
    1:     return OBJ_DELETE_PROPERTY(cx, obj, ATOM_TO_JSID(atom), rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewArrayObject(JSContext *cx, jsint length, jsval *vector)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     /* NB: jsuint cast does ToUint32. */
    1:     return js_NewArrayObject(cx, (jsuint)length, vector);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsArrayObject(JSContext *cx, JSObject *obj)
    1: {
11835:     return OBJ_IS_ARRAY(cx, obj);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetArrayLength(JSContext *cx, JSObject *obj, jsuint *lengthp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_GetLengthProperty(cx, obj, lengthp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetArrayLength(JSContext *cx, JSObject *obj, jsuint length)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_SetLengthProperty(cx, obj, length);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_HasArrayLength(JSContext *cx, JSObject *obj, jsuint *lengthp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_HasLengthProperty(cx, obj, lengthp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineElement(JSContext *cx, JSObject *obj, jsint index, jsval value,
    1:                  JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
    1: {
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
19712: 
    1:     CHECK_REQUEST(cx);
    1:     return OBJ_DEFINE_PROPERTY(cx, obj, INT_TO_JSID(index), value,
    1:                                getter, setter, attrs, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_AliasElement(JSContext *cx, JSObject *obj, const char *name, jsint alias)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     if (!LookupProperty(cx, obj, name, JSRESOLVE_QUALIFIED, &obj2, &prop))
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         js_ReportIsNotDefined(cx, name);
    1:         return JS_FALSE;
    1:     }
    1:     if (obj2 != obj || !OBJ_IS_NATIVE(obj)) {
    1:         char numBuf[12];
    1:         OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:         JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)alias);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_ALIAS,
    1:                              numBuf, name, OBJ_GET_CLASS(cx, obj2)->name);
    1:         return JS_FALSE;
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
    1:     ok = (js_AddNativeProperty(cx, obj, INT_TO_JSID(alias),
    1:                                sprop->getter, sprop->setter, sprop->slot,
    1:                                sprop->attrs, sprop->flags | SPROP_IS_ALIAS,
    1:                                sprop->shortid)
    1:           != NULL);
    1:     OBJ_DROP_PROPERTY(cx, obj, prop);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
 7927: JS_AlreadyHasOwnElement(JSContext *cx, JSObject *obj, jsint index,
 7927:                         JSBool *foundp)
 7927: {
 7927:     return AlreadyHasOwnPropertyHelper(cx, obj, INT_TO_JSID(index), foundp);
 7927: }
 7927: 
 7927: JS_PUBLIC_API(JSBool)
    1: JS_HasElement(JSContext *cx, JSObject *obj, jsint index, JSBool *foundp)
    1: {
    1:     JSBool ok;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = LookupPropertyById(cx, obj, INT_TO_JSID(index),
19712:                             JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING,
19712:                             &obj2, &prop);
    1:     if (ok) {
    1:         *foundp = (prop != NULL);
    1:         if (prop)
    1:             OBJ_DROP_PROPERTY(cx, obj2, prop);
    1:     }
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_LookupElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp)
    1: {
    1:     JSBool ok;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1: 
    1:     CHECK_REQUEST(cx);
19712:     ok = LookupPropertyById(cx, obj, INT_TO_JSID(index), JSRESOLVE_QUALIFIED,
19712:                             &obj2, &prop);
    1:     if (ok)
    1:         *vp = LookupResult(cx, obj, obj2, prop);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp)
    1: {
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
19712: 
    1:     CHECK_REQUEST(cx);
    1:     return OBJ_GET_PROPERTY(cx, obj, INT_TO_JSID(index), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetElement(JSContext *cx, JSObject *obj, jsint index, jsval *vp)
    1: {
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_ASSIGNING);
19712: 
    1:     CHECK_REQUEST(cx);
    1:     return OBJ_SET_PROPERTY(cx, obj, INT_TO_JSID(index), vp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DeleteElement(JSContext *cx, JSObject *obj, jsint index)
    1: {
    1:     jsval junk;
    1: 
    1:     return JS_DeleteElement2(cx, obj, index, &junk);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DeleteElement2(JSContext *cx, JSObject *obj, jsint index, jsval *rval)
    1: {
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
19712: 
    1:     CHECK_REQUEST(cx);
    1:     return OBJ_DELETE_PROPERTY(cx, obj, INT_TO_JSID(index), rval);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearScope(JSContext *cx, JSObject *obj)
    1: {
    1:     CHECK_REQUEST(cx);
    1: 
    1:     if (obj->map->ops->clear)
    1:         obj->map->ops->clear(cx, obj);
    1: 
    1:     /* Clear cached class objects on the global object. */
10592:     if (OBJ_GET_CLASS(cx, obj)->flags & JSCLASS_IS_GLOBAL) {
 3164:         int key;
    1: 
    1:         for (key = JSProto_Null; key < JSProto_LIMIT; key++)
    1:             JS_SetReservedSlot(cx, obj, key, JSVAL_VOID);
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSIdArray *)
    1: JS_Enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:     jsint i, n;
    1:     jsval iter_state, num_properties;
    1:     jsid id;
    1:     JSIdArray *ida;
    1:     jsval *vector;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     ida = NULL;
    1:     iter_state = JSVAL_NULL;
    1: 
    1:     /* Get the number of properties to enumerate. */
    1:     if (!OBJ_ENUMERATE(cx, obj, JSENUMERATE_INIT, &iter_state, &num_properties))
    1:         goto error;
    1:     if (!JSVAL_IS_INT(num_properties)) {
    1:         JS_ASSERT(0);
    1:         goto error;
    1:     }
    1: 
    1:     /* Grow as needed if we don't know the exact amount ahead of time. */
    1:     n = JSVAL_TO_INT(num_properties);
    1:     if (n <= 0)
    1:         n = 8;
    1: 
    1:     /* Create an array of jsids large enough to hold all the properties */
15677:     ida = NewIdArray(cx, n);
    1:     if (!ida)
    1:         goto error;
    1: 
    1:     i = 0;
    1:     vector = &ida->vector[0];
    1:     for (;;) {
    1:         if (!OBJ_ENUMERATE(cx, obj, JSENUMERATE_NEXT, &iter_state, &id))
    1:             goto error;
    1: 
    1:         /* No more jsid's to enumerate ? */
    1:         if (iter_state == JSVAL_NULL)
    1:             break;
    1: 
    1:         if (i == ida->length) {
15677:             ida = SetIdArrayLength(cx, ida, ida->length * 2);
    1:             if (!ida)
    1:                 goto error;
    1:             vector = &ida->vector[0];
    1:         }
    1:         vector[i++] = id;
    1:     }
15677:     return SetIdArrayLength(cx, ida, i);
    1: 
    1: error:
    1:     if (iter_state != JSVAL_NULL)
    1:         OBJ_ENUMERATE(cx, obj, JSENUMERATE_DESTROY, &iter_state, 0);
    1:     if (ida)
    1:         JS_DestroyIdArray(cx, ida);
    1:     return NULL;
    1: }
    1: 
    1: /*
    1:  * XXX reverse iterator for properties, unreverse and meld with jsinterp.c's
    1:  *     prop_iterator_class somehow...
    1:  * + preserve the OBJ_ENUMERATE API while optimizing the native object case
    1:  * + native case here uses a JSScopeProperty *, but that iterates in reverse!
    1:  * + so we make non-native match, by reverse-iterating after JS_Enumerating
    1:  */
    1: #define JSSLOT_ITER_INDEX       (JSSLOT_PRIVATE + 1)
    1: 
    1: #if JSSLOT_ITER_INDEX >= JS_INITIAL_NSLOTS
    1: # error "JSSLOT_ITER_INDEX botch!"
    1: #endif
    1: 
    1: static void
    1: prop_iter_finalize(JSContext *cx, JSObject *obj)
    1: {
    1:     jsval v;
    1:     jsint i;
    1:     JSIdArray *ida;
    1: 
10592:     v = obj->fslots[JSSLOT_ITER_INDEX];
    1:     if (JSVAL_IS_VOID(v))
    1:         return;
    1: 
    1:     i = JSVAL_TO_INT(v);
    1:     if (i >= 0) {
    1:         /* Non-native case: destroy the ida enumerated when obj was created. */
    1:         ida = (JSIdArray *) JS_GetPrivate(cx, obj);
    1:         if (ida)
    1:             JS_DestroyIdArray(cx, ida);
    1:     }
    1: }
    1: 
  583: static void
  583: prop_iter_trace(JSTracer *trc, JSObject *obj)
    1: {
    1:     jsval v;
    1:     jsint i, n;
    1:     JSScopeProperty *sprop;
    1:     JSIdArray *ida;
    1:     jsid id;
    1: 
10592:     v = obj->fslots[JSSLOT_PRIVATE];
    1:     JS_ASSERT(!JSVAL_IS_VOID(v));
    1: 
10592:     i = JSVAL_TO_INT(obj->fslots[JSSLOT_ITER_INDEX]);
    1:     if (i < 0) {
    1:         /* Native case: just mark the next property to visit. */
    1:         sprop = (JSScopeProperty *) JSVAL_TO_PRIVATE(v);
    1:         if (sprop)
  583:             TRACE_SCOPE_PROPERTY(trc, sprop);
    1:     } else {
    1:         /* Non-native case: mark each id in the JSIdArray private. */
    1:         ida = (JSIdArray *) JSVAL_TO_PRIVATE(v);
    1:         for (i = 0, n = ida->length; i < n; i++) {
    1:             id = ida->vector[i];
  583:             TRACE_ID(trc, id);
  583:         }
  583:     }
    1: }
    1: 
    1: static JSClass prop_iter_class = {
    1:     "PropertyIterator",
  583:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) |
  583:     JSCLASS_MARK_IS_TRACE,
    1:     JS_PropertyStub,  JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
    1:     JS_EnumerateStub, JS_ResolveStub,  JS_ConvertStub,  prop_iter_finalize,
    1:     NULL,             NULL,            NULL,            NULL,
  583:     NULL,             NULL,            JS_CLASS_TRACE(prop_iter_trace), NULL
    1: };
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewPropertyIterator(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *iterobj;
    1:     JSScope *scope;
    1:     void *pdata;
    1:     jsint index;
    1:     JSIdArray *ida;
    1: 
    1:     CHECK_REQUEST(cx);
13427:     iterobj = js_NewObject(cx, &prop_iter_class, NULL, obj, 0);
    1:     if (!iterobj)
    1:         return NULL;
    1: 
    1:     if (OBJ_IS_NATIVE(obj)) {
    1:         /* Native case: start with the last property in obj's own scope. */
    1:         scope = OBJ_SCOPE(obj);
    1:         pdata = (scope->object == obj) ? scope->lastProp : NULL;
    1:         index = -1;
    1:     } else {
    1:         JSTempValueRooter tvr;
    1: 
    1:         /*
    1:          * Non-native case: enumerate a JSIdArray and keep it via private.
    1:          *
    1:          * Note: we have to make sure that we root obj around the call to
    1:          * JS_Enumerate to protect against multiple allocations under it.
    1:          */
    1:         JS_PUSH_SINGLE_TEMP_ROOT(cx, OBJECT_TO_JSVAL(iterobj), &tvr);
    1:         ida = JS_Enumerate(cx, obj);
    1:         JS_POP_TEMP_ROOT(cx, &tvr);
    1:         if (!ida)
    1:             goto bad;
    1:         pdata = ida;
    1:         index = ida->length;
    1:     }
    1: 
    1:     /* iterobj cannot escape to other threads here. */
    1:     STOBJ_SET_SLOT(iterobj, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(pdata));
    1:     STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_INDEX, INT_TO_JSVAL(index));
    1:     return iterobj;
    1: 
    1: bad:
    1:     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:     return NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_NextProperty(JSContext *cx, JSObject *iterobj, jsid *idp)
    1: {
    1:     jsint i;
    1:     JSObject *obj;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1:     JSIdArray *ida;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     i = JSVAL_TO_INT(OBJ_GET_SLOT(cx, iterobj, JSSLOT_ITER_INDEX));
    1:     if (i < 0) {
    1:         /* Native case: private data is a property tree node pointer. */
    1:         obj = OBJ_GET_PARENT(cx, iterobj);
    1:         JS_ASSERT(OBJ_IS_NATIVE(obj));
    1:         scope = OBJ_SCOPE(obj);
    1:         JS_ASSERT(scope->object == obj);
    1:         sprop = (JSScopeProperty *) JS_GetPrivate(cx, iterobj);
    1: 
    1:         /*
    1:          * If the next property mapped by scope in the property tree ancestor
    1:          * line is not enumerable, or it's an alias, or one or more properties
    1:          * were deleted from the "middle" of the scope-mapped ancestor line
    1:          * and the next property was among those deleted, skip it and keep on
    1:          * trying to find an enumerable property that is still in scope.
    1:          */
    1:         while (sprop &&
    1:                (!(sprop->attrs & JSPROP_ENUMERATE) ||
    1:                 (sprop->flags & SPROP_IS_ALIAS) ||
    1:                 (SCOPE_HAD_MIDDLE_DELETE(scope) &&
    1:                  !SCOPE_HAS_PROPERTY(scope, sprop)))) {
    1:             sprop = sprop->parent;
    1:         }
    1: 
    1:         if (!sprop) {
    1:             *idp = JSVAL_VOID;
    1:         } else {
    1:             if (!JS_SetPrivate(cx, iterobj, sprop->parent))
    1:                 return JS_FALSE;
    1:             *idp = sprop->id;
    1:         }
    1:     } else {
    1:         /* Non-native case: use the ida enumerated when iterobj was created. */
    1:         ida = (JSIdArray *) JS_GetPrivate(cx, iterobj);
    1:         JS_ASSERT(i <= ida->length);
    1:         if (i == 0) {
    1:             *idp = JSVAL_VOID;
    1:         } else {
    1:             *idp = ida->vector[--i];
11377:             STOBJ_SET_SLOT(iterobj, JSSLOT_ITER_INDEX, INT_TO_JSVAL(i));
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return OBJ_CHECK_ACCESS(cx, obj, id, mode, vp, attrsp);
    1: }
    1: 
    1: static JSBool
    1: ReservedSlotIndexOK(JSContext *cx, JSObject *obj, JSClass *clasp,
    1:                     uint32 index, uint32 limit)
    1: {
    1:     /* Check the computed, possibly per-instance, upper bound. */
    1:     if (clasp->reserveSlots)
    1:         JS_LOCK_OBJ_VOID(cx, obj, limit += clasp->reserveSlots(cx, obj));
    1:     if (index >= limit) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_RESERVED_SLOT_RANGE);
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval *vp)
    1: {
    1:     JSClass *clasp;
    1:     uint32 limit, slot;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     limit = JSCLASS_RESERVED_SLOTS(clasp);
    1:     if (index >= limit && !ReservedSlotIndexOK(cx, obj, clasp, index, limit))
    1:         return JS_FALSE;
    1:     slot = JSSLOT_START(clasp) + index;
    1:     *vp = OBJ_GET_REQUIRED_SLOT(cx, obj, slot);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval v)
    1: {
    1:     JSClass *clasp;
    1:     uint32 limit, slot;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     clasp = OBJ_GET_CLASS(cx, obj);
    1:     limit = JSCLASS_RESERVED_SLOTS(clasp);
    1:     if (index >= limit && !ReservedSlotIndexOK(cx, obj, clasp, index, limit))
    1:         return JS_FALSE;
    1:     slot = JSSLOT_START(clasp) + index;
    1:     return OBJ_SET_REQUIRED_SLOT(cx, obj, slot, v);
    1: }
    1: 
    1: #ifdef JS_THREADSAFE
    1: JS_PUBLIC_API(jsrefcount)
    1: JS_HoldPrincipals(JSContext *cx, JSPrincipals *principals)
    1: {
    1:     return JS_ATOMIC_INCREMENT(&principals->refcount);
    1: }
    1: 
    1: JS_PUBLIC_API(jsrefcount)
    1: JS_DropPrincipals(JSContext *cx, JSPrincipals *principals)
    1: {
    1:     jsrefcount rc = JS_ATOMIC_DECREMENT(&principals->refcount);
    1:     if (rc == 0)
    1:         principals->destroy(cx, principals);
    1:     return rc;
    1: }
    1: #endif
    1: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_SetRuntimeSecurityCallbacks(JSRuntime *rt, JSSecurityCallbacks *callbacks)
18870: {
18870:     JSSecurityCallbacks *oldcallbacks;
18870: 
18870:     oldcallbacks = rt->securityCallbacks;
18870:     rt->securityCallbacks = callbacks;
18870:     return oldcallbacks;
18870: }
18870: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_GetRuntimeSecurityCallbacks(JSRuntime *rt)
18870: {
18870:   return rt->securityCallbacks;
18870: }
18870: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_SetContextSecurityCallbacks(JSContext *cx, JSSecurityCallbacks *callbacks)
18870: {
18870:     JSSecurityCallbacks *oldcallbacks;
18870: 
18870:     oldcallbacks = cx->securityCallbacks;
18870:     cx->securityCallbacks = callbacks;
18870:     return oldcallbacks;
18870: }
18870: 
18870: JS_PUBLIC_API(JSSecurityCallbacks *)
18870: JS_GetSecurityCallbacks(JSContext *cx)
18870: {
18870:   return cx->securityCallbacks
18870:          ? cx->securityCallbacks
18870:          : cx->runtime->securityCallbacks;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_NewFunction(JSContext *cx, JSNative native, uintN nargs, uintN flags,
    1:                JSObject *parent, const char *name)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     if (!name) {
    1:         atom = NULL;
    1:     } else {
    1:         atom = js_Atomize(cx, name, strlen(name), 0);
    1:         if (!atom)
    1:             return NULL;
    1:     }
    1:     return js_NewFunction(cx, NULL, native, nargs, flags, parent, atom);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_CloneFunctionObject(JSContext *cx, JSObject *funobj, JSObject *parent)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (OBJ_GET_CLASS(cx, funobj) != &js_FunctionClass) {
27012:         /*
27012:          * We cannot clone this object, so fail (we used to return funobj, bad
27012:          * idea, but we changed incompatibly to teach any abusers a lesson!).
27012:          */
27012:         jsval v = OBJECT_TO_JSVAL(funobj);
27012:         js_ReportIsNotFunction(cx, &v, 0);
27012:         return NULL;
27012:     }
27012: 
27012:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
27012:     JSObject *clone = js_CloneFunctionObject(cx, fun, parent);
27012:     if (!clone)
27012:         return NULL;
27012: 
27012:     /*
27012:      * A flat closure carries its own environment, so why clone it? In case
27012:      * someone wants to mutate its fixed slots or add ad-hoc properties. API
27012:      * compatibility suggests we not return funobj and let callers mutate the
27012:      * returned object at will.
27012:      *
27012:      * But it's worse than that: API compatibility according to the test for
27012:      * bug 300079 requires we get "upvars" from parent and its ancestors! So
27012:      * we do that (grudgingly!). The scope chain ancestors are searched as if
27012:      * they were activations, respecting the skip field in each upvar's cookie
27012:      * but looking up the property by name instead of frame slot.
27012:      */
27012:     if (FUN_FLAT_CLOSURE(fun)) {
27012:         JS_ASSERT(funobj->dslots);
27012:         JS_ASSERT(JSSLOT_FREE(&js_FunctionClass) == JS_INITIAL_NSLOTS);
27012: 
27012:         uint32 nslots = JSSLOT_FREE(&js_FunctionClass);
27012:         JS_ASSERT(nslots == JS_INITIAL_NSLOTS);
27012:         nslots += js_FunctionClass.reserveSlots(cx, clone);
27012:         if (!js_ReallocSlots(cx, clone, nslots, JS_TRUE))
27012:             return NULL;
27012: 
27012:         JSUpvarArray *uva = JS_SCRIPT_UPVARS(fun->u.i.script);
27012:         JS_ASSERT(uva->length <= size_t(clone->dslots[-1]));
27012: 
27012:         void *mark = JS_ARENA_MARK(&cx->tempPool);
27012:         jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
27012:         if (!names)
27012:             return NULL;
27012: 
27012:         uint32 i = 0, n = uva->length;
27012:         for (; i < n; i++) {
27012:             JSObject *obj = parent;
27111:             int skip = UPVAR_FRAME_SKIP(uva->vector[i]);
27111:             while (--skip > 0) {
27012:                 if (!obj) {
27012:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
27012:                                          JSMSG_BAD_CLONE_FUNOBJ_SCOPE);
27012:                     goto break2;
27012:                 }
27012:                 obj = OBJ_GET_PARENT(cx, obj);
27012:             }
27012: 
27012:             JSAtom *atom = JS_LOCAL_NAME_TO_ATOM(names[i]);
27012:             if (!OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &clone->dslots[i]))
27012:                 break;
27012:         }
27012: 
27012:       break2:
27012:         JS_ARENA_RELEASE(&cx->tempPool, mark);
27012:         if (i < n)
27012:             return NULL;
27012:     }
27012: 
27012:     return clone;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFunctionObject(JSFunction *fun)
    1: {
13427:     return FUN_OBJECT(fun);
    1: }
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetFunctionName(JSFunction *fun)
    1: {
    1:     return fun->atom
    1:            ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom))
    1:            : js_anonymous_str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_GetFunctionId(JSFunction *fun)
    1: {
    1:     return fun->atom ? ATOM_TO_STRING(fun->atom) : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetFunctionFlags(JSFunction *fun)
    1: {
    1:     return fun->flags;
    1: }
    1: 
    1: JS_PUBLIC_API(uint16)
    1: JS_GetFunctionArity(JSFunction *fun)
    1: {
    1:     return fun->nargs;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ObjectIsFunction(JSContext *cx, JSObject *obj)
    1: {
    1:     return OBJ_GET_CLASS(cx, obj) == &js_FunctionClass;
    1: }
    1: 
18563: JS_BEGIN_EXTERN_C
18907: static JSBool
 4127: js_generic_fast_native_method_dispatcher(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fsv;
    1:     JSFunctionSpec *fs;
    1:     JSObject *tmp;
20408:     JSFastNative native;
    1: 
 4127:     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(*vp), 0, &fsv))
 4127:         return JS_FALSE;
 4127:     fs = (JSFunctionSpec *) JSVAL_TO_PRIVATE(fsv);
 4127:     JS_ASSERT((~fs->flags & (JSFUN_FAST_NATIVE | JSFUN_GENERIC_NATIVE)) == 0);
 4127: 
 4127:     /*
 4127:      * We know that vp[2] is valid because JS_DefineFunctions, which is our
 4127:      * only (indirect) referrer, defined us as requiring at least one argument
 4127:      * (notice how it passes fs->nargs + 1 as the next-to-last argument to
 4127:      * JS_DefineFunction).
 4127:      */
 4127:     if (JSVAL_IS_PRIMITIVE(vp[2])) {
 4127:         /*
 4127:          * Make sure that this is an object or null, as required by the generic
 4127:          * functions.
 4127:          */
 4127:         if (!js_ValueToObject(cx, vp[2], &tmp))
 4127:             return JS_FALSE;
 4127:         vp[2] = OBJECT_TO_JSVAL(tmp);
 4127:     }
 4127: 
 4127:     /*
 4127:      * Copy all actual (argc) arguments down over our |this| parameter, vp[1],
 4127:      * which is almost always the class constructor object, e.g. Array.  Then
 4127:      * call the corresponding prototype native method with our first argument
 4127:      * passed as |this|.
 4127:      */
 4127:     memmove(vp + 1, vp + 2, argc * sizeof(jsval));
 4127: 
 4127:     /*
 4127:      * Follow Function.prototype.apply and .call by using the global object as
 4127:      * the 'this' param if no args.
 4127:      */
11774:     if (!js_ComputeThis(cx, JS_FALSE, vp + 2))
 4127:         return JS_FALSE;
 4127:     /*
 4127:      * Protect against argc underflowing. By calling js_ComputeThis, we made
 4127:      * it as if the static was called with one parameter, the explicit |this|
 4127:      * object.
 4127:      */
25712:     if (argc != 0) {
25712:         /* Clear the last parameter in case too few arguments were passed. */
25712:         vp[2 + --argc] = JSVAL_VOID;
25712:     }
 4127: 
20408:     native =
20408: #ifdef JS_TRACER
20408:              (fs->flags & JSFUN_TRACEABLE)
25218:              ? JS_FUNC_TO_DATA_PTR(JSTraceableNative *, fs->call)->native
20408:              :
20408: #endif
20408:                (JSFastNative) fs->call;
20408:     return native(cx, argc, vp);
 4127: }
 4127: 
18907: static JSBool
 4127: js_generic_native_method_dispatcher(JSContext *cx, JSObject *obj,
 4127:                                     uintN argc, jsval *argv, jsval *rval)
 4127: {
 4127:     jsval fsv;
 4127:     JSFunctionSpec *fs;
 4127:     JSObject *tmp;
 4127: 
    1:     if (!JS_GetReservedSlot(cx, JSVAL_TO_OBJECT(argv[-2]), 0, &fsv))
    1:         return JS_FALSE;
    1:     fs = (JSFunctionSpec *) JSVAL_TO_PRIVATE(fsv);
 4127:     JS_ASSERT((fs->flags & (JSFUN_FAST_NATIVE | JSFUN_GENERIC_NATIVE)) ==
 4127:               JSFUN_GENERIC_NATIVE);
    1: 
    1:     /*
    1:      * We know that argv[0] is valid because JS_DefineFunctions, which is our
    1:      * only (indirect) referrer, defined us as requiring at least one argument
    1:      * (notice how it passes fs->nargs + 1 as the next-to-last argument to
    1:      * JS_DefineFunction).
    1:      */
    1:     if (JSVAL_IS_PRIMITIVE(argv[0])) {
    1:         /*
    1:          * Make sure that this is an object or null, as required by the generic
    1:          * functions.
    1:          */
    1:         if (!js_ValueToObject(cx, argv[0], &tmp))
    1:             return JS_FALSE;
    1:         argv[0] = OBJECT_TO_JSVAL(tmp);
    1:     }
    1: 
    1:     /*
 4127:      * Copy all actual (argc) arguments down over our |this| parameter,
 4127:      * argv[-1], which is almost always the class constructor object, e.g.
 4127:      * Array.  Then call the corresponding prototype native method with our
 4127:      * first argument passed as |this|.
    1:      */
 4127:     memmove(argv - 1, argv, argc * sizeof(jsval));
    1: 
    1:     /*
    1:      * Follow Function.prototype.apply and .call by using the global object as
    1:      * the 'this' param if no args.
    1:      */
11774:     if (!js_ComputeThis(cx, JS_TRUE, argv))
    1:         return JS_FALSE;
22652:     js_GetTopStackFrame(cx)->thisp = JSVAL_TO_OBJECT(argv[-1]);
22652:     JS_ASSERT(cx->fp->argv == argv);
    1: 
    1:     /*
 4127:      * Protect against argc underflowing. By calling js_ComputeThis, we made
 4127:      * it as if the static was called with one parameter, the explicit |this|
 4127:      * object.
    1:      */
25712:     if (argc != 0) {
25712:         /* Clear the last parameter in case too few arguments were passed. */
25712:         argv[--argc] = JSVAL_VOID;
25712:     }
 4127: 
 4127:     return fs->call(cx, JSVAL_TO_OBJECT(argv[-1]), argc, argv, rval);
    1: }
18563: JS_END_EXTERN_C
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DefineFunctions(JSContext *cx, JSObject *obj, JSFunctionSpec *fs)
    1: {
    1:     uintN flags;
    1:     JSObject *ctor;
    1:     JSFunction *fun;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     ctor = NULL;
    1:     for (; fs->name; fs++) {
    1:         flags = fs->flags;
    1: 
    1:         /*
    1:          * Define a generic arity N+1 static method for the arity N prototype
    1:          * method if flags contains JSFUN_GENERIC_NATIVE.
    1:          */
    1:         if (flags & JSFUN_GENERIC_NATIVE) {
    1:             if (!ctor) {
    1:                 ctor = JS_GetConstructor(cx, obj);
    1:                 if (!ctor)
    1:                     return JS_FALSE;
    1:             }
    1: 
    1:             flags &= ~JSFUN_GENERIC_NATIVE;
    1:             fun = JS_DefineFunction(cx, ctor, fs->name,
 4127:                                     (flags & JSFUN_FAST_NATIVE)
 4127:                                     ? (JSNative)
 4127:                                       js_generic_fast_native_method_dispatcher
 4127:                                     : js_generic_native_method_dispatcher,
20408:                                     fs->nargs + 1,
20408:                                     flags & ~JSFUN_TRACEABLE);
    1:             if (!fun)
    1:                 return JS_FALSE;
    1:             fun->u.n.extra = (uint16)fs->extra;
    1: 
    1:             /*
    1:              * As jsapi.h notes, fs must point to storage that lives as long
    1:              * as fun->object lives.
    1:              */
13824:             if (!JS_SetReservedSlot(cx, FUN_OBJECT(fun), 0, PRIVATE_TO_JSVAL(fs)))
    1:                 return JS_FALSE;
    1:         }
    1: 
 4127:         JS_ASSERT(!(flags & JSFUN_FAST_NATIVE) ||
 4127:                   (uint16)(fs->extra >> 16) <= fs->nargs);
    1:         fun = JS_DefineFunction(cx, obj, fs->name, fs->call, fs->nargs, flags);
    1:         if (!fun)
    1:             return JS_FALSE;
    1:         fun->u.n.extra = (uint16)fs->extra;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_DefineFunction(JSContext *cx, JSObject *obj, const char *name, JSNative call,
    1:                   uintN nargs, uintN attrs)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_Atomize(cx, name, strlen(name), 0);
    1:     if (!atom)
    1:         return NULL;
    1:     return js_DefineFunction(cx, obj, atom, call, nargs, attrs);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_DefineUCFunction(JSContext *cx, JSObject *obj,
    1:                     const jschar *name, size_t namelen, JSNative call,
    1:                     uintN nargs, uintN attrs)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     atom = js_AtomizeChars(cx, name, AUTO_NAMELEN(name, namelen), 0);
    1:     if (!atom)
    1:         return NULL;
    1:     return js_DefineFunction(cx, obj, atom, call, nargs, attrs);
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileScript(JSContext *cx, JSObject *obj,
    1:                  const char *bytes, size_t length,
    1:                  const char *filename, uintN lineno)
    1: {
    1:     jschar *chars;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1:     script = JS_CompileUCScript(cx, obj, chars, length, filename, lineno);
    1:     JS_free(cx, chars);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                               JSPrincipals *principals,
    1:                               const char *bytes, size_t length,
    1:                               const char *filename, uintN lineno)
    1: {
    1:     jschar *chars;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1:     script = JS_CompileUCScriptForPrincipals(cx, obj, principals,
    1:                                              chars, length, filename, lineno);
    1:     JS_free(cx, chars);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileUCScript(JSContext *cx, JSObject *obj,
    1:                    const jschar *chars, size_t length,
    1:                    const char *filename, uintN lineno)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return JS_CompileUCScriptForPrincipals(cx, obj, NULL, chars, length,
    1:                                            filename, lineno);
    1: }
    1: 
    1: #define LAST_FRAME_EXCEPTION_CHECK(cx,result)                                 \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if (!(result) && !((cx)->options & JSOPTION_DONT_REPORT_UNCAUGHT))    \
    1:             js_ReportUncaughtException(cx);                                   \
    1:     JS_END_MACRO
    1: 
    1: #define LAST_FRAME_CHECKS(cx,result)                                          \
    1:     JS_BEGIN_MACRO                                                            \
22652:         if (!JS_IsRunning(cx)) {                                              \
    1:             (cx)->weakRoots.lastInternalResult = JSVAL_NULL;                  \
    1:             LAST_FRAME_EXCEPTION_CHECK(cx, result);                           \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
17828: #define JS_OPTIONS_TO_TCFLAGS(cx)                                             \
17828:     ((((cx)->options & JSOPTION_COMPILE_N_GO) ? TCF_COMPILE_N_GO : 0) |       \
17828:      (((cx)->options & JSOPTION_NO_SCRIPT_RVAL) ? TCF_NO_SCRIPT_RVAL : 0))
17828: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileUCScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                 JSPrincipals *principals,
    1:                                 const jschar *chars, size_t length,
    1:                                 const char *filename, uintN lineno)
    1: {
 8444:     uint32 tcflags;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
17828:     tcflags = JS_OPTIONS_TO_TCFLAGS(cx);
27012:     script = JSCompiler::compileScript(cx, obj, NULL, principals, tcflags,
 8444:                                        chars, length, NULL, filename, lineno);
    1:     LAST_FRAME_CHECKS(cx, script);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_BufferIsCompilableUnit(JSContext *cx, JSObject *obj,
    1:                           const char *bytes, size_t length)
    1: {
    1:     jschar *chars;
    1:     JSBool result;
    1:     JSExceptionState *exnState;
    1:     JSErrorReporter older;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return JS_TRUE;
    1: 
    1:     /*
    1:      * Return true on any out-of-memory error, so our caller doesn't try to
    1:      * collect more buffered source.
    1:      */
    1:     result = JS_TRUE;
    1:     exnState = JS_SaveExceptionState(cx);
27012:     {
27012:         JSCompiler jsc(cx);
27012:         if (jsc.init(chars, length, NULL, NULL, 1)) {
    1:             older = JS_SetErrorReporter(cx, NULL);
27012:             if (!jsc.parse(obj) &&
27012:                 (jsc.tokenStream.flags & TSF_UNEXPECTED_EOF)) {
    1:                 /*
27012:                  * We ran into an error. If it was because we ran out of
27012:                  * source, we return false so our caller knows to try to
27012:                  * collect more buffered source.
    1:                  */
    1:                 result = JS_FALSE;
    1:             }
 6561:             JS_SetErrorReporter(cx, older);
27012:         }
 6561:     }
    1:     JS_free(cx, chars);
    1:     JS_RestoreExceptionState(cx, exnState);
    1:     return result;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileFile(JSContext *cx, JSObject *obj, const char *filename)
    1: {
 6561:     FILE *fp;
 8444:     uint32 tcflags;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
 6561:     if (!filename || strcmp(filename, "-") == 0) {
 6561:         fp = stdin;
 6561:     } else {
 6561:         fp = fopen(filename, "r");
 6561:         if (!fp) {
 6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_OPEN,
 6561:                                  filename, "No such file or directory");
    1:             return NULL;
 6561:         }
 6561:     }
 6561: 
17828:     tcflags = JS_OPTIONS_TO_TCFLAGS(cx);
27012:     script = JSCompiler::compileScript(cx, obj, NULL, NULL, tcflags,
 8444:                                        NULL, 0, fp, filename, 1);
 6561:     if (fp != stdin)
 6561:         fclose(fp);
    1:     LAST_FRAME_CHECKS(cx, script);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileFileHandle(JSContext *cx, JSObject *obj, const char *filename,
    1:                      FILE *file)
    1: {
    1:     return JS_CompileFileHandleForPrincipals(cx, obj, filename, file, NULL);
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_CompileFileHandleForPrincipals(JSContext *cx, JSObject *obj,
    1:                                   const char *filename, FILE *file,
    1:                                   JSPrincipals *principals)
    1: {
 8444:     uint32 tcflags;
    1:     JSScript *script;
    1: 
    1:     CHECK_REQUEST(cx);
17828:     tcflags = JS_OPTIONS_TO_TCFLAGS(cx);
27012:     script = JSCompiler::compileScript(cx, obj, NULL, principals, tcflags,
 8444:                                        NULL, 0, file, filename, 1);
    1:     LAST_FRAME_CHECKS(cx, script);
    1:     return script;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewScriptObject(JSContext *cx, JSScript *script)
    1: {
 7359:     JSTempValueRooter tvr;
    1:     JSObject *obj;
    1: 
17070:     CHECK_REQUEST(cx);
 7359:     if (!script)
13427:         return js_NewObject(cx, &js_ScriptClass, NULL, NULL, 0);
 7359: 
18285:     JS_ASSERT(!script->u.object);
18285: 
 7359:     JS_PUSH_TEMP_ROOT_SCRIPT(cx, script, &tvr);
13427:     obj = js_NewObject(cx, &js_ScriptClass, NULL, NULL, 0);
 7359:     if (obj) {
 7359:         JS_SetPrivate(cx, obj, script);
18285:         script->u.object = obj;
11377: #ifdef CHECK_SCRIPT_OWNER
11377:         script->owner = NULL;
11377: #endif
 3624:     }
 7359:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return obj;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetScriptObject(JSScript *script)
    1: {
18285:     return script->u.object;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DestroyScript(JSContext *cx, JSScript *script)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     js_DestroyScript(cx, script);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_CompileFunction(JSContext *cx, JSObject *obj, const char *name,
    1:                    uintN nargs, const char **argnames,
    1:                    const char *bytes, size_t length,
    1:                    const char *filename, uintN lineno)
    1: {
    1:     jschar *chars;
    1:     JSFunction *fun;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1:     fun = JS_CompileUCFunction(cx, obj, name, nargs, argnames, chars, length,
    1:                                filename, lineno);
    1:     JS_free(cx, chars);
    1:     return fun;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_CompileFunctionForPrincipals(JSContext *cx, JSObject *obj,
    1:                                 JSPrincipals *principals, const char *name,
    1:                                 uintN nargs, const char **argnames,
    1:                                 const char *bytes, size_t length,
    1:                                 const char *filename, uintN lineno)
    1: {
    1:     jschar *chars;
    1:     JSFunction *fun;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1:     fun = JS_CompileUCFunctionForPrincipals(cx, obj, principals, name,
    1:                                             nargs, argnames, chars, length,
    1:                                             filename, lineno);
    1:     JS_free(cx, chars);
    1:     return fun;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_CompileUCFunction(JSContext *cx, JSObject *obj, const char *name,
    1:                      uintN nargs, const char **argnames,
    1:                      const jschar *chars, size_t length,
    1:                      const char *filename, uintN lineno)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return JS_CompileUCFunctionForPrincipals(cx, obj, NULL, name,
    1:                                              nargs, argnames,
    1:                                              chars, length,
    1:                                              filename, lineno);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_CompileUCFunctionForPrincipals(JSContext *cx, JSObject *obj,
    1:                                   JSPrincipals *principals, const char *name,
    1:                                   uintN nargs, const char **argnames,
    1:                                   const jschar *chars, size_t length,
    1:                                   const char *filename, uintN lineno)
    1: {
    1:     JSFunction *fun;
10448:     JSTempValueRooter tvr;
    1:     JSAtom *funAtom, *argAtom;
    1:     uintN i;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     if (!name) {
    1:         funAtom = NULL;
    1:     } else {
    1:         funAtom = js_Atomize(cx, name, strlen(name), 0);
    1:         if (!funAtom) {
    1:             fun = NULL;
10448:             goto out2;
 3624:         }
 3624:     }
13702:     fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, obj, funAtom);
    1:     if (!fun)
10448:         goto out2;
10448: 
18989:     MUST_FLOW_THROUGH("out");
13824:     JS_PUSH_TEMP_ROOT_OBJECT(cx, FUN_OBJECT(fun), &tvr);
    1:     for (i = 0; i < nargs; i++) {
    1:         argAtom = js_Atomize(cx, argnames[i], strlen(argnames[i]), 0);
 6561:         if (!argAtom) {
    1:             fun = NULL;
    1:             goto out;
    1:         }
13691:         if (!js_AddLocal(cx, fun, argAtom, JSLOCAL_ARG)) {
    1:             fun = NULL;
    1:             goto out;
    1:         }
 3624:     }
 6561: 
27012:     if (!JSCompiler::compileFunctionBody(cx, fun, principals,
27012:                                          chars, length, filename, lineno)) {
13691:         fun = NULL;
 3624:         goto out;
 3624:     }
 6561: 
 6561:     if (obj &&
 6561:         funAtom &&
 6561:         !OBJ_DEFINE_PROPERTY(cx, obj, ATOM_TO_JSID(funAtom),
13824:                              OBJECT_TO_JSVAL(FUN_OBJECT(fun)),
    1:                              NULL, NULL, JSPROP_ENUMERATE, NULL)) {
13691:         fun = NULL;
 6561:     }
 6561: 
10217: #ifdef JS_SCOPE_DEPTH_METER
13691:     if (fun && obj) {
10217:         JSObject *pobj = obj;
10217:         uintN depth = 1;
10217: 
10217:         while ((pobj = OBJ_GET_PARENT(cx, pobj)) != NULL)
10217:             ++depth;
10217:         JS_BASIC_STATS_ACCUM(&cx->runtime->hostenvScopeDepthStats, depth);
10217:     }
10217: #endif
10217: 
    1:   out:
13824:     cx->weakRoots.newborn[JSTRACE_OBJECT] = FUN_OBJECT(fun);
10448:     JS_POP_TEMP_ROOT(cx, &tvr);
10448: 
10448:   out2:
    1:     LAST_FRAME_CHECKS(cx, fun);
    1:     return fun;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_DecompileScript(JSContext *cx, JSScript *script, const char *name,
    1:                    uintN indent)
    1: {
    1:     JSPrinter *jp;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
13702:     jp = JS_NEW_PRINTER(cx, name, NULL,
    1:                         indent & ~JS_DONT_PRETTY_PRINT,
    1:                         !(indent & JS_DONT_PRETTY_PRINT));
    1:     if (!jp)
    1:         return NULL;
    1:     if (js_DecompileScript(jp, script))
    1:         str = js_GetPrinterOutput(jp);
    1:     else
    1:         str = NULL;
    1:     js_DestroyPrinter(jp);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_DecompileFunction(JSContext *cx, JSFunction *fun, uintN indent)
    1: {
    1:     JSPrinter *jp;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
13702:     jp = JS_NEW_PRINTER(cx, "JS_DecompileFunction", fun,
    1:                         indent & ~JS_DONT_PRETTY_PRINT,
    1:                         !(indent & JS_DONT_PRETTY_PRINT));
    1:     if (!jp)
    1:         return NULL;
13702:     if (js_DecompileFunction(jp))
    1:         str = js_GetPrinterOutput(jp);
    1:     else
    1:         str = NULL;
    1:     js_DestroyPrinter(jp);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_DecompileFunctionBody(JSContext *cx, JSFunction *fun, uintN indent)
    1: {
    1:     JSPrinter *jp;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
13702:     jp = JS_NEW_PRINTER(cx, "JS_DecompileFunctionBody", fun,
    1:                         indent & ~JS_DONT_PRETTY_PRINT,
    1:                         !(indent & JS_DONT_PRETTY_PRINT));
    1:     if (!jp)
    1:         return NULL;
13702:     if (js_DecompileFunctionBody(jp))
    1:         str = js_GetPrinterOutput(jp);
    1:     else
    1:         str = NULL;
    1:     js_DestroyPrinter(jp);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ExecuteScript(JSContext *cx, JSObject *obj, JSScript *script, jsval *rval)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     ok = js_Execute(cx, obj, script, NULL, 0, rval);
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ExecuteScriptPart(JSContext *cx, JSObject *obj, JSScript *script,
    1:                      JSExecPart part, jsval *rval)
    1: {
    1:     JSScript tmp;
 2433:     JSDebugHooks *hooks;
    1:     JSBool ok;
    1: 
    1:     /* Make a temporary copy of the JSScript structure and farble it a bit. */
    1:     tmp = *script;
    1:     if (part == JSEXEC_PROLOG) {
25144:         tmp.length = tmp.main - tmp.code;
    1:     } else {
25144:         tmp.length -= tmp.main - tmp.code;
    1:         tmp.code = tmp.main;
    1:     }
    1: 
    1:     /* Tell the debugger about our temporary copy of the script structure. */
 2433:     hooks = cx->debugHooks;
 2433:     if (hooks->newScriptHook) {
 2433:         hooks->newScriptHook(cx, tmp.filename, tmp.lineno, &tmp, NULL,
 2433:                              hooks->newScriptHookData);
    1:     }
    1: 
    1:     /* Execute the farbled struct and tell the debugger to forget about it. */
    1:     ok = JS_ExecuteScript(cx, obj, &tmp, rval);
 2433:     if (hooks->destroyScriptHook)
 2433:         hooks->destroyScriptHook(cx, &tmp, hooks->destroyScriptHookData);
    1:     return ok;
    1: }
    1: 
    1: /* Ancient uintN nbytes is part of API/ABI, so use size_t length local. */
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateScript(JSContext *cx, JSObject *obj,
    1:                   const char *bytes, uintN nbytes,
    1:                   const char *filename, uintN lineno,
    1:                   jsval *rval)
    1: {
    1:     size_t length = nbytes;
    1:     jschar *chars;
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return JS_FALSE;
    1:     ok = JS_EvaluateUCScript(cx, obj, chars, length, filename, lineno, rval);
    1:     JS_free(cx, chars);
    1:     return ok;
    1: }
    1: 
    1: /* Ancient uintN nbytes is part of API/ABI, so use size_t length local. */
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                JSPrincipals *principals,
    1:                                const char *bytes, uintN nbytes,
    1:                                const char *filename, uintN lineno,
    1:                                jsval *rval)
    1: {
    1:     size_t length = nbytes;
    1:     jschar *chars;
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return JS_FALSE;
    1:     ok = JS_EvaluateUCScriptForPrincipals(cx, obj, principals, chars, length,
    1:                                           filename, lineno, rval);
    1:     JS_free(cx, chars);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCScript(JSContext *cx, JSObject *obj,
    1:                     const jschar *chars, uintN length,
    1:                     const char *filename, uintN lineno,
    1:                     jsval *rval)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return JS_EvaluateUCScriptForPrincipals(cx, obj, NULL, chars, length,
    1:                                             filename, lineno, rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCScriptForPrincipals(JSContext *cx, JSObject *obj,
    1:                                  JSPrincipals *principals,
    1:                                  const jschar *chars, uintN length,
    1:                                  const char *filename, uintN lineno,
    1:                                  jsval *rval)
    1: {
    1:     JSScript *script;
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
27012:     script = JSCompiler::compileScript(cx, obj, NULL, principals,
17828:                                        !rval
17828:                                        ? TCF_COMPILE_N_GO | TCF_NO_SCRIPT_RVAL
17828:                                        : TCF_COMPILE_N_GO,
 8444:                                        chars, length, NULL, filename, lineno);
18486:     if (!script) {
18486:         LAST_FRAME_CHECKS(cx, script);
    1:         return JS_FALSE;
18486:     }
    1:     ok = js_Execute(cx, obj, script, NULL, 0, rval);
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     JS_DestroyScript(cx, script);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_CallFunction(JSContext *cx, JSObject *obj, JSFunction *fun, uintN argc,
    1:                 jsval *argv, jsval *rval)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
13824:     ok = js_InternalCall(cx, obj, OBJECT_TO_JSVAL(FUN_OBJECT(fun)), argc, argv,
    1:                          rval);
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_CallFunctionName(JSContext *cx, JSObject *obj, const char *name, uintN argc,
    1:                     jsval *argv, jsval *rval)
    1: {
    1:     CHECK_REQUEST(cx);
26187: 
26187:     JSAutoTempValueRooter tvr(cx);
26187:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
26187:     JSBool ok = atom &&
26187:                 JS_GetMethodById(cx, obj, ATOM_TO_JSID(atom), NULL,
26187:                                  tvr.addr()) &&
26187:                 js_InternalCall(cx, obj, tvr.value(), argc, argv, rval);
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_CallFunctionValue(JSContext *cx, JSObject *obj, jsval fval, uintN argc,
    1:                      jsval *argv, jsval *rval)
    1: {
    1:     JSBool ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     ok = js_InternalCall(cx, obj, fval, argc, argv, rval);
    1:     LAST_FRAME_CHECKS(cx, ok);
    1:     return ok;
    1: }
    1: 
25087: JS_PUBLIC_API(JSOperationCallback)
25087: JS_SetOperationCallback(JSContext *cx, JSOperationCallback callback)
25087: {
25087: #ifdef JS_THREADSAFE
25087:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
 9780: #endif    
25087:     JSOperationCallback old = cx->operationCallback;
23726:     cx->operationCallback = callback;
25087:     return old;
23726: }
23726: 
23726: JS_PUBLIC_API(JSOperationCallback)
23726: JS_GetOperationCallback(JSContext *cx)
23726: {
23726:     return cx->operationCallback;
23726: }
23726: 
23726: JS_PUBLIC_API(void)
23726: JS_TriggerOperationCallback(JSContext *cx)
23726: {
25087:     /*
25087:      * Use JS_ATOMIC_SET in the hope that it will make sure the write
25087:      * will become immediately visible to other processors polling
25087:      * cx->operationCallbackFlag. Note that we only care about
25087:      * visibility here, not read/write ordering.
25087:      */
25087:     JS_ATOMIC_SET(&cx->operationCallbackFlag, 1);
23726: }
23726: 
25472: JS_PUBLIC_API(void)
25472: JS_TriggerAllOperationCallbacks(JSRuntime *rt)
25472: {
25472:     JSContext *acx, *iter;
25472:     JS_LOCK_GC(rt);
25472:     iter = NULL;
25472:     while ((acx = js_ContextIterator(rt, JS_FALSE, &iter)))
25472:         JS_TriggerOperationCallback(acx);
25472:     JS_UNLOCK_GC(rt);
25472: }
25472: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsRunning(JSContext *cx)
    1: {
22652:     /* The use of cx->fp below is safe: if we're on trace, it is skipped. */
22652:     VOUCH_DOES_NOT_REQUIRE_STACK();
22652: 
22652:     return JS_ON_TRACE(cx) || cx->fp != NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsConstructing(JSContext *cx)
    1: {
22652:     JSStackFrame *fp;
22652: 
22652:     fp = js_GetTopStackFrame(cx);
22652:     return fp && (fp->flags & JSFRAME_CONSTRUCTING);
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: JS_IsAssigning(JSContext *cx)
    1: {
    1:     JSStackFrame *fp;
    1: 
22652:     fp = js_GetScriptedCaller(cx, NULL);
13168:     if (!fp || !fp->regs)
    1:         return JS_FALSE;
13168:     return (js_CodeSpec[*fp->regs->pc].format & JOF_ASSIGNING) != 0;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetCallReturnValue2(JSContext *cx, jsval v)
    1: {
    1: #if JS_HAS_LVALUE_RETURN
    1:     cx->rval2 = v;
    1:     cx->rval2set = JS_TRUE;
    1: #endif
    1: }
    1: 
  520: JS_PUBLIC_API(JSStackFrame *)
  520: JS_SaveFrameChain(JSContext *cx)
  520: {
  520:     JSStackFrame *fp;
  520: 
22652:     fp = js_GetTopStackFrame(cx);
  520:     if (!fp)
  520:         return fp;
  520: 
  520:     JS_ASSERT(!fp->dormantNext);
  520:     fp->dormantNext = cx->dormantFrameChain;
  520:     cx->dormantFrameChain = fp;
  520:     cx->fp = NULL;
  520:     return fp;
  520: }
  520: 
  520: JS_PUBLIC_API(void)
  520: JS_RestoreFrameChain(JSContext *cx, JSStackFrame *fp)
  520: {
24499:     JS_ASSERT_NOT_ON_TRACE(cx);
  520:     JS_ASSERT(!cx->fp);
  520:     if (!fp)
  520:         return;
  520: 
 1324:     JS_ASSERT(fp == cx->dormantFrameChain);
  520:     cx->fp = fp;
  520:     cx->dormantFrameChain = fp->dormantNext;
  520:     fp->dormantNext = NULL;
  520: }
  520: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewString(JSContext *cx, char *bytes, size_t nbytes)
    1: {
    1:     size_t length = nbytes;
    1:     jschar *chars;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     /* Make a UTF-16 vector from the 8-bit char codes in bytes. */
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1: 
    1:     /* Free chars (but not bytes, which caller frees on error) if we fail. */
 4718:     str = js_NewString(cx, chars, length);
    1:     if (!str) {
    1:         JS_free(cx, chars);
    1:         return NULL;
    1:     }
    1: 
    1:     /* Hand off bytes to the deflated string cache, if possible. */
    1:     if (!js_SetStringBytes(cx, str, bytes, nbytes))
    1:         JS_free(cx, bytes);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewStringCopyN(JSContext *cx, const char *s, size_t n)
    1: {
    1:     jschar *js;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     js = js_InflateString(cx, s, &n);
    1:     if (!js)
    1:         return NULL;
 4718:     str = js_NewString(cx, js, n);
    1:     if (!str)
    1:         JS_free(cx, js);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewStringCopyZ(JSContext *cx, const char *s)
    1: {
    1:     size_t n;
    1:     jschar *js;
    1:     JSString *str;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     if (!s)
    1:         return cx->runtime->emptyString;
    1:     n = strlen(s);
    1:     js = js_InflateString(cx, s, &n);
    1:     if (!js)
    1:         return NULL;
 4718:     str = js_NewString(cx, js, n);
    1:     if (!str)
    1:         JS_free(cx, js);
    1:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_InternString(JSContext *cx, const char *s)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_Atomize(cx, s, strlen(s), ATOM_INTERNED);
    1:     if (!atom)
    1:         return NULL;
    1:     return ATOM_TO_STRING(atom);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewUCString(JSContext *cx, jschar *chars, size_t length)
    1: {
    1:     CHECK_REQUEST(cx);
 4718:     return js_NewString(cx, chars, length);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewUCStringCopyN(JSContext *cx, const jschar *s, size_t n)
    1: {
    1:     CHECK_REQUEST(cx);
 4076:     return js_NewStringCopyN(cx, s, n);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewUCStringCopyZ(JSContext *cx, const jschar *s)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!s)
    1:         return cx->runtime->emptyString;
 4076:     return js_NewStringCopyZ(cx, s);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_InternUCStringN(JSContext *cx, const jschar *s, size_t length)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     atom = js_AtomizeChars(cx, s, length, ATOM_INTERNED);
    1:     if (!atom)
    1:         return NULL;
    1:     return ATOM_TO_STRING(atom);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_InternUCString(JSContext *cx, const jschar *s)
    1: {
    1:     return JS_InternUCStringN(cx, s, js_strlen(s));
    1: }
    1: 
    1: JS_PUBLIC_API(char *)
    1: JS_GetStringBytes(JSString *str)
    1: {
    1:     const char *bytes;
    1: 
    1:     bytes = js_GetStringBytes(NULL, str);
    1:     return (char *)(bytes ? bytes : "");
    1: }
    1: 
    1: JS_PUBLIC_API(jschar *)
    1: JS_GetStringChars(JSString *str)
    1: {
    1:     size_t n, size;
    1:     jschar *s;
    1: 
    1:     /*
    1:      * API botch (again, shades of JS_GetStringBytes): we have no cx to report
    1:      * out-of-memory when undepending strings, so we replace js_UndependString
    1:      * with explicit malloc call and ignore its errors.
    1:      *
    1:      * If we fail to convert a dependent string into an independent one, our
    1:      * caller will not be guaranteed a \u0000 terminator as a backstop.  This
    1:      * may break some clients who already misbehave on embedded NULs.
    1:      *
    1:      * The gain of dependent strings, which cure quadratic and cubic growth
    1:      * rate bugs in string concatenation, is worth this slight loss in API
    1:      * compatibility.
    1:      */
    1:     if (JSSTRING_IS_DEPENDENT(str)) {
    1:         n = JSSTRDEP_LENGTH(str);
    1:         size = (n + 1) * sizeof(jschar);
    1:         s = (jschar *) malloc(size);
    1:         if (s) {
 4718:             memcpy(s, JSSTRDEP_CHARS(str), n * sizeof *s);
    1:             s[n] = 0;
10444:             JSFLATSTR_INIT(str, s, n);
 4718:         } else {
 4718:             s = JSSTRDEP_CHARS(str);
 4718:         }
 4718:     } else {
10444:         JSFLATSTR_CLEAR_MUTABLE(str);
10444:         s = JSFLATSTR_CHARS(str);
 4718:     }
 4718:     return s;
    1: }
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetStringLength(JSString *str)
    1: {
    1:     return JSSTRING_LENGTH(str);
    1: }
    1: 
    1: JS_PUBLIC_API(intN)
    1: JS_CompareStrings(JSString *str1, JSString *str2)
    1: {
    1:     return js_CompareStrings(str1, str2);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewGrowableString(JSContext *cx, jschar *chars, size_t length)
    1: {
 4718:     JSString *str;
 4718: 
    1:     CHECK_REQUEST(cx);
 4718:     str = js_NewString(cx, chars, length);
 4718:     if (!str)
 4718:         return str;
10444:     JSFLATSTR_SET_MUTABLE(str);
 4718:     return str;
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_NewDependentString(JSContext *cx, JSString *str, size_t start,
    1:                       size_t length)
    1: {
    1:     CHECK_REQUEST(cx);
 4076:     return js_NewDependentString(cx, str, start, length);
    1: }
    1: 
    1: JS_PUBLIC_API(JSString *)
    1: JS_ConcatStrings(JSContext *cx, JSString *left, JSString *right)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ConcatStrings(cx, left, right);
    1: }
    1: 
    1: JS_PUBLIC_API(const jschar *)
    1: JS_UndependString(JSContext *cx, JSString *str)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_UndependString(cx, str);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_MakeStringImmutable(JSContext *cx, JSString *str)
    1: {
    1:     CHECK_REQUEST(cx);
 4718:     return js_MakeStringImmutable(cx, str);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EncodeCharacters(JSContext *cx, const jschar *src, size_t srclen, char *dst,
    1:                     size_t *dstlenp)
    1: {
    1:     size_t n;
    1: 
    1:     if (!dst) {
    1:         n = js_GetDeflatedStringLength(cx, src, srclen);
    1:         if (n == (size_t)-1) {
    1:             *dstlenp = 0;
    1:             return JS_FALSE;
    1:         }
    1:         *dstlenp = n;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     return js_DeflateStringToBuffer(cx, src, srclen, dst, dstlenp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_DecodeBytes(JSContext *cx, const char *src, size_t srclen, jschar *dst,
    1:                size_t *dstlenp)
    1: {
    1:     return js_InflateStringToBuffer(cx, src, srclen, dst, dstlenp);
    1: }
    1: 
 8893: JS_PUBLIC_API(char *)
 8893: JS_EncodeString(JSContext *cx, JSString *str)
 8893: {
 8893:     return js_DeflateString(cx, JSSTRING_CHARS(str), JSSTRING_LENGTH(str));
 8893: }
 8893: 
20092: JS_PUBLIC_API(JSBool)
20092: JS_Stringify(JSContext *cx, jsval *vp, JSObject *replacer,
20092:              JSONWriteCallback callback, void *data)
20092: {
20092:     CHECK_REQUEST(cx);
20092:     return js_Stringify(cx, vp, replacer, callback, data, 0);
20092: }
20092: 
20092: JS_PUBLIC_API(JSBool)
20092: JS_TryJSON(JSContext *cx, jsval *vp)
20092: {
20092:     CHECK_REQUEST(cx);
20092:     return js_TryJSON(cx, vp);
20092: }
20092: 
20092: JS_PUBLIC_API(JSONParser *)
20092: JS_BeginJSONParse(JSContext *cx, jsval *vp)
20092: {
20092:     CHECK_REQUEST(cx);
20092:     return js_BeginJSONParse(cx, vp);
20092: }
20092: 
20092: JS_PUBLIC_API(JSBool)
20092: JS_ConsumeJSONText(JSContext *cx, JSONParser *jp, const jschar *data, uint32 len)
20092: {
20092:     CHECK_REQUEST(cx);
20092:     return js_ConsumeJSONText(cx, jp, data, len);
20092: }
20092: 
20092: JS_PUBLIC_API(JSBool)
25718: JS_FinishJSONParse(JSContext *cx, JSONParser *jp, jsval reviver)
20092: {
20092:     CHECK_REQUEST(cx);
25718:     return js_FinishJSONParse(cx, jp, reviver);
20092: }
20092: 
 8893: /*
 8893:  * The following determines whether C Strings are to be treated as UTF-8
 8893:  * or ISO-8859-1.  For correct operation, it must be set prior to the
 8893:  * first call to JS_NewRuntime.
 8893:  */
 8893: #ifndef JS_C_STRINGS_ARE_UTF8
 8893: JSBool js_CStringsAreUTF8 = JS_FALSE;
 8893: #endif
 8893: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_CStringsAreUTF8()
    1: {
 8893:     return js_CStringsAreUTF8;
 8893: }
 8893: 
 8893: JS_PUBLIC_API(void)
 8893: JS_SetCStringsAreUTF8()
 8893: {
 8893:     JS_ASSERT(!js_NewRuntimeWasCalled);
 8893: 
 8893: #ifndef JS_C_STRINGS_ARE_UTF8
 8893:     js_CStringsAreUTF8 = JS_TRUE;
    1: #endif
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportError(JSContext *cx, const char *format, ...)
    1: {
    1:     va_list ap;
    1: 
    1:     va_start(ap, format);
    1:     js_ReportErrorVA(cx, JSREPORT_ERROR, format, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportErrorNumber(JSContext *cx, JSErrorCallback errorCallback,
    1:                      void *userRef, const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1: 
    1:     va_start(ap, errorNumber);
    1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
    1:                            errorNumber, JS_TRUE, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportErrorNumberUC(JSContext *cx, JSErrorCallback errorCallback,
    1:                      void *userRef, const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1: 
    1:     va_start(ap, errorNumber);
    1:     js_ReportErrorNumberVA(cx, JSREPORT_ERROR, errorCallback, userRef,
    1:                            errorNumber, JS_FALSE, ap);
    1:     va_end(ap);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportWarning(JSContext *cx, const char *format, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, format);
    1:     ok = js_ReportErrorVA(cx, JSREPORT_WARNING, format, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportErrorFlagsAndNumber(JSContext *cx, uintN flags,
    1:                              JSErrorCallback errorCallback, void *userRef,
    1:                              const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, errorNumber);
    1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
    1:                                 errorNumber, JS_TRUE, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportErrorFlagsAndNumberUC(JSContext *cx, uintN flags,
    1:                                JSErrorCallback errorCallback, void *userRef,
    1:                                const uintN errorNumber, ...)
    1: {
    1:     va_list ap;
    1:     JSBool ok;
    1: 
    1:     va_start(ap, errorNumber);
    1:     ok = js_ReportErrorNumberVA(cx, flags, errorCallback, userRef,
    1:                                 errorNumber, JS_FALSE, ap);
    1:     va_end(ap);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ReportOutOfMemory(JSContext *cx)
    1: {
    1:     js_ReportOutOfMemory(cx);
    1: }
    1: 
12983: JS_PUBLIC_API(void)
12983: JS_ReportAllocationOverflow(JSContext *cx)
12983: {
12983:     js_ReportAllocationOverflow(cx);
12983: }
12983: 
    1: JS_PUBLIC_API(JSErrorReporter)
    1: JS_SetErrorReporter(JSContext *cx, JSErrorReporter er)
    1: {
    1:     JSErrorReporter older;
    1: 
    1:     older = cx->errorReporter;
    1:     cx->errorReporter = er;
    1:     return older;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Regular Expressions.
    1:  */
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewRegExpObject(JSContext *cx, char *bytes, size_t length, uintN flags)
    1: {
    1:     jschar *chars;
    1:     JSObject *obj;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     chars = js_InflateString(cx, bytes, &length);
    1:     if (!chars)
    1:         return NULL;
    1:     obj = js_NewRegExpObject(cx, NULL, chars, length, flags);
    1:     JS_free(cx, chars);
    1:     return obj;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_NewUCRegExpObject(JSContext *cx, jschar *chars, size_t length, uintN flags)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_NewRegExpObject(cx, NULL, chars, length, flags);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetRegExpInput(JSContext *cx, JSString *input, JSBool multiline)
    1: {
    1:     JSRegExpStatics *res;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     /* No locking required, cx is thread-private and input must be live. */
    1:     res = &cx->regExpStatics;
    1:     res->input = input;
    1:     res->multiline = multiline;
    1:     cx->runtime->gcPoke = JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearRegExpStatics(JSContext *cx)
    1: {
    1:     JSRegExpStatics *res;
    1: 
    1:     /* No locking required, cx is thread-private and input must be live. */
    1:     res = &cx->regExpStatics;
    1:     res->input = NULL;
    1:     res->multiline = JS_FALSE;
    1:     res->parenCount = 0;
    1:     res->lastMatch = res->lastParen = js_EmptySubString;
    1:     res->leftContext = res->rightContext = js_EmptySubString;
    1:     cx->runtime->gcPoke = JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearRegExpRoots(JSContext *cx)
    1: {
    1:     JSRegExpStatics *res;
    1: 
    1:     /* No locking required, cx is thread-private and input must be live. */
    1:     res = &cx->regExpStatics;
    1:     res->input = NULL;
    1:     cx->runtime->gcPoke = JS_TRUE;
    1: }
    1: 
    1: /* TODO: compile, execute, get/set other statics... */
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetLocaleCallbacks(JSContext *cx, JSLocaleCallbacks *callbacks)
    1: {
    1:     cx->localeCallbacks = callbacks;
    1: }
    1: 
    1: JS_PUBLIC_API(JSLocaleCallbacks *)
    1: JS_GetLocaleCallbacks(JSContext *cx)
    1: {
    1:     return cx->localeCallbacks;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsExceptionPending(JSContext *cx)
    1: {
    1:     return (JSBool) cx->throwing;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPendingException(JSContext *cx, jsval *vp)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (!cx->throwing)
    1:         return JS_FALSE;
    1:     *vp = cx->exception;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetPendingException(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     cx->throwing = JS_TRUE;
    1:     cx->exception = v;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearPendingException(JSContext *cx)
    1: {
    1:     cx->throwing = JS_FALSE;
    1:     cx->exception = JSVAL_VOID;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ReportPendingException(JSContext *cx)
    1: {
    1:     JSBool save, ok;
    1: 
    1:     CHECK_REQUEST(cx);
    1: 
    1:     /*
    1:      * Set cx->generatingError to suppress the standard error-to-exception
    1:      * conversion done by all {js,JS}_Report* functions except for OOM.  The
    1:      * cx->generatingError flag was added to suppress recursive divergence
    1:      * under js_ErrorToException, but it serves for our purposes here too.
    1:      */
    1:     save = cx->generatingError;
    1:     cx->generatingError = JS_TRUE;
    1:     ok = js_ReportUncaughtException(cx);
    1:     cx->generatingError = save;
    1:     return ok;
    1: }
    1: 
    1: struct JSExceptionState {
    1:     JSBool throwing;
    1:     jsval  exception;
    1: };
    1: 
    1: JS_PUBLIC_API(JSExceptionState *)
    1: JS_SaveExceptionState(JSContext *cx)
    1: {
    1:     JSExceptionState *state;
    1: 
    1:     CHECK_REQUEST(cx);
    1:     state = (JSExceptionState *) JS_malloc(cx, sizeof(JSExceptionState));
    1:     if (state) {
    1:         state->throwing = JS_GetPendingException(cx, &state->exception);
    1:         if (state->throwing && JSVAL_IS_GCTHING(state->exception))
    1:             js_AddRoot(cx, &state->exception, "JSExceptionState.exception");
    1:     }
    1:     return state;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_RestoreExceptionState(JSContext *cx, JSExceptionState *state)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (state) {
    1:         if (state->throwing)
    1:             JS_SetPendingException(cx, state->exception);
    1:         else
    1:             JS_ClearPendingException(cx);
    1:         JS_DropExceptionState(cx, state);
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_DropExceptionState(JSContext *cx, JSExceptionState *state)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     if (state) {
    1:         if (state->throwing && JSVAL_IS_GCTHING(state->exception))
    1:             JS_RemoveRoot(cx, &state->exception);
    1:         JS_free(cx, state);
    1:     }
    1: }
    1: 
    1: JS_PUBLIC_API(JSErrorReport *)
    1: JS_ErrorFromException(JSContext *cx, jsval v)
    1: {
    1:     CHECK_REQUEST(cx);
    1:     return js_ErrorFromException(cx, v);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ThrowReportedError(JSContext *cx, const char *message,
    1:                       JSErrorReport *reportp)
    1: {
22652:     return JS_IsRunning(cx) && js_ErrorToException(cx, message, reportp);
    1: }
    1: 
 6464: JS_PUBLIC_API(JSBool)
 6464: JS_ThrowStopIteration(JSContext *cx)
 6464: {
 6464:     return js_ThrowStopIteration(cx);
 6464: }
 6464: 
    1: /*
    1:  * Get the owning thread id of a context. Returns 0 if the context is not
    1:  * owned by any thread.
    1:  */
    1: JS_PUBLIC_API(jsword)
    1: JS_GetContextThread(JSContext *cx)
    1: {
11941: #ifdef JS_THREADSAFE
    1:     return JS_THREAD_ID(cx);
11941: #else
11941:     return 0;
11941: #endif
    1: }
    1: 
    1: /*
    1:  * Set the current thread as the owning thread of a context. Returns the
    1:  * old owning thread id, or -1 if the operation failed.
    1:  */
    1: JS_PUBLIC_API(jsword)
    1: JS_SetContextThread(JSContext *cx)
    1: {
11941: #ifdef JS_THREADSAFE
24871:     JS_ASSERT(cx->requestDepth == 0);
24871:     if (cx->thread) {
26569:         JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
24871:         return cx->thread->id;
24871:     }
24871: 
26569:     if (!js_InitContextThread(cx)) {
24871:         js_ReportOutOfMemory(cx);
    1:         return -1;
24871:     }
24871: 
26569:     /* Here the GC lock is still held after js_InitContextThread took it. */
26569:     JS_UNLOCK_GC(cx->runtime);
24871: #endif
24871:     return 0;
24871: }
24871: 
24871: JS_PUBLIC_API(jsword)
24871: JS_ClearContextThread(JSContext *cx)
24871: {
24871: #ifdef JS_THREADSAFE
24871:     /*
24871:      * This must be called outside a request and, if cx is associated with a
24871:      * thread, this must be called only from that thread.  If not, this is a
24871:      * harmless no-op.
24871:      */
24871:     JS_ASSERT(cx->requestDepth == 0);
24871:     if (!cx->thread)
24871:         return 0;
26569:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
24871:     jsword old = cx->thread->id;
24871: 
24871:     /*
24871:      * We must not race with a GC that accesses cx->thread for all threads,
24871:      * see bug 476934.
24871:      */
24871:     JSRuntime *rt = cx->runtime;
24871:     JS_LOCK_GC(rt);
24871:     js_WaitForGC(rt);
26569:     js_ClearContextThread(cx);
26569:     JS_UNLOCK_GC(rt);
    1:     return old;
11941: #else
11941:     return 0;
11941: #endif
    1: }
    1: 
 1492: #ifdef JS_GC_ZEAL
 1492: JS_PUBLIC_API(void)
 1492: JS_SetGCZeal(JSContext *cx, uint8 zeal)
 1492: {
 1492:     cx->runtime->gcZeal = zeal;
 1492: }
 1492: #endif
 1492: 
    1: /************************************************************************/
    1: 
19616: #if !defined(STATIC_JS_API) && defined(XP_WIN) && !defined (WINCE)
11461: 
    1: #include <windows.h>
11461: 
    1: /*
11461:  * Initialization routine for the JS DLL.
    1:  */
    1: BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
    1: {
    1:     return TRUE;
    1: }
    1: 
11461: #endif
