50491: /*
50491:  * Copyright (C) 2008 Apple Inc. All rights reserved.
50491:  *
50491:  * Redistribution and use in source and binary forms, with or without
50491:  * modification, are permitted provided that the following conditions
50491:  * are met:
50491:  * 1. Redistributions of source code must retain the above copyright
50491:  *    notice, this list of conditions and the following disclaimer.
50491:  * 2. Redistributions in binary form must reproduce the above copyright
50491:  *    notice, this list of conditions and the following disclaimer in the
50491:  *    documentation and/or other materials provided with the distribution.
50491:  *
50491:  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
50491:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
50491:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
50491:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
50491:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
50491:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
50491:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
50491:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
50491:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
50491:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
50491:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
50491:  */
50491: 
50491: #ifndef ExecutableAllocator_h
50491: #define ExecutableAllocator_h
50491: 
50491: #include <stddef.h> // for ptrdiff_t
50491: #include <limits>
50646: #include "assembler/wtf/Assertions.h"
50491: 
50491: #include "jsapi.h"
50491: #include "jsprvtd.h"
50491: #include "jsvector.h"
50646: #include "jslock.h"
50491: 
50491: #if WTF_PLATFORM_IPHONE
50491: #include <libkern/OSCacheControl.h>
50491: #include <sys/mman.h>
50491: #endif
50491: 
50491: #if WTF_PLATFORM_SYMBIAN
50491: #include <e32std.h>
50491: #endif
50491: 
50491: #if WTF_CPU_MIPS && WTF_PLATFORM_LINUX
50491: #include <sys/cachectl.h>
50491: #endif
50491: 
50491: #if WTF_PLATFORM_WINCE
50491: // From pkfuncs.h (private header file from the Platform Builder)
50491: #define CACHE_SYNC_ALL 0x07F
50491: extern "C" __declspec(dllimport) void CacheRangeFlush(LPVOID pAddr, DWORD dwLength, DWORD dwFlags);
50491: #endif
50491: 
50491: #define JIT_ALLOCATOR_PAGE_SIZE (ExecutableAllocator::pageSize)
56035: #if WTF_PLATFORM_WIN_OS || WTF_PLATFORM_WINCE
56035: /*
56035:  * In practice, VirtualAlloc allocates in 64K chunks. (Technically, it
56035:  * allocates in page chunks, but the starting address is always a multiple
56035:  * of 64K, so each allocation uses up 64K of address space.
56035:  */
56035: # define JIT_ALLOCATOR_LARGE_ALLOC_SIZE (ExecutableAllocator::pageSize * 16)
56035: #else
50491: # define JIT_ALLOCATOR_LARGE_ALLOC_SIZE (ExecutableAllocator::pageSize * 4)
56035: #endif
50491: 
50491: #if ENABLE_ASSEMBLER_WX_EXCLUSIVE
50491: #define PROTECTION_FLAGS_RW (PROT_READ | PROT_WRITE)
50491: #define PROTECTION_FLAGS_RX (PROT_READ | PROT_EXEC)
50491: #define INITIAL_PROTECTION_FLAGS PROTECTION_FLAGS_RX
50491: #else
50491: #define INITIAL_PROTECTION_FLAGS (PROT_READ | PROT_WRITE | PROT_EXEC)
50491: #endif
50491: 
50491: namespace JSC {
50491: 
50491: // Something included via windows.h defines a macro with this name,
50491: // which causes the function below to fail to compile.
50491: #ifdef _MSC_VER
50491: # undef max
50491: #endif
50491: 
57810: const size_t OVERSIZE_ALLOCATION = size_t(-1);
57810: 
50491: inline size_t roundUpAllocationSize(size_t request, size_t granularity)
50491: {
50491:     if ((std::numeric_limits<size_t>::max() - granularity) <= request)
57810:         return OVERSIZE_ALLOCATION;
50491:     
50491:     // Round up to next page boundary
50491:     size_t size = request + (granularity - 1);
50491:     size = size & ~(granularity - 1);
50646:     JS_ASSERT(size >= request);
50491:     return size;
50491: }
50491: 
50491: }
50491: 
50491: #if ENABLE_ASSEMBLER
50491: 
50491: namespace JSC {
50491: 
50491:   // These are reference-counted. A new one (from the constructor or create)
50491:   // starts with a count of 1. 
50491:   class ExecutablePool {
50491: private:
50491:     struct Allocation {
50491:         char* pages;
50491:         size_t size;
50491: #if WTF_PLATFORM_SYMBIAN
50491:         RChunk* chunk;
50491: #endif
50491:     };
50491:     typedef js::Vector<Allocation, 2 ,js::SystemAllocPolicy > AllocationList;
50491: 
50491:     // Reference count for automatic reclamation.
50646:     jsrefcount m_refCount;
50491: 
50491: public:
50491:       // It should be impossible for us to roll over, because only small
50491:       // pools have multiple holders, and they have one holder per chunk
50491:       // of generated code, and they only hold 16KB or so of code.
50646:       void addRef() { JS_ATOMIC_INCREMENT(&m_refCount); }
50491:       void release() { 
50646: 	  JS_ASSERT(m_refCount != 0);
50646: 	  if (JS_ATOMIC_DECREMENT(&m_refCount) == 0) 
50491: 	      delete this; 
50491:       }
50491: 
50491:     //static PassRefPtr<ExecutablePool> create(size_t n)
50491:     static ExecutablePool* create(size_t n)
50491:     {
57810:         ExecutablePool *pool = new ExecutablePool(n);
57810:         if (!pool->m_freePtr) {
57810:             delete pool;
57810:             return NULL;
57810:         }
57810:         return pool;
50491:     }
50491: 
50491:     void* alloc(size_t n)
50491:     {
50646:         JS_ASSERT(m_freePtr <= m_end);
50491: 
50491:         // Round 'n' up to a multiple of word size; if all allocations are of
50491:         // word sized quantities, then all subsequent allocations will be aligned.
50491:         n = roundUpAllocationSize(n, sizeof(void*));
57810:         if (n == OVERSIZE_ALLOCATION)
57810:             return NULL;
50491: 
50491:         if (static_cast<ptrdiff_t>(n) < (m_end - m_freePtr)) {
50491:             void* result = m_freePtr;
50491:             m_freePtr += n;
50491:             return result;
50491:         }
50491: 
50491:         // Insufficient space to allocate in the existing pool
50491:         // so we need allocate into a new pool
50491:         return poolAllocate(n);
50491:     }
50491:     
50491:     ~ExecutablePool()
50491:     {
50491:         Allocation* end = m_pools.end();
50491:         for (Allocation* ptr = m_pools.begin(); ptr != end; ++ptr)
50491:             ExecutablePool::systemRelease(*ptr);
50491:     }
50491: 
50491:     size_t available() const { return (m_pools.length() > 1) ? 0 : m_end - m_freePtr; }
50491: 
50491: private:
57810:     // On OOM, this will return an Allocation where pages is NULL.
50491:     static Allocation systemAlloc(size_t n);
50491:     static void systemRelease(const Allocation& alloc);
50491: 
50491:     ExecutablePool(size_t n);
50491: 
50491:     void* poolAllocate(size_t n);
50491: 
50491:     char* m_freePtr;
50491:     char* m_end;
50491:     AllocationList m_pools;
50491: };
50491: 
50491: class ExecutableAllocator {
50491:     enum ProtectionSeting { Writable, Executable };
50491: 
57810:     // Initialization can fail so we use a create method instead.
57810:     ExecutableAllocator() {}
50491: public:
50491:     static size_t pageSize;
57810: 
57810:     // Returns NULL on OOM.
57810:     static ExecutableAllocator *create()
50491:     {
57810:         ExecutableAllocator *allocator = new ExecutableAllocator();
57810:         if (!allocator)
57810:             return allocator;
57810: 
50491:         if (!pageSize)
50491:             intializePageSize();
57810:         allocator->m_smallAllocationPool = ExecutablePool::create(JIT_ALLOCATOR_LARGE_ALLOC_SIZE);
57810:         if (!allocator->m_smallAllocationPool) {
57810:             delete allocator;
57810:             return NULL;
57810:         }
50491:     }
50491: 
50491:     ~ExecutableAllocator() { delete m_smallAllocationPool; }
50491: 
50491:     // poolForSize returns reference-counted objects. The caller owns a reference
50491:     // to the object; i.e., poolForSize increments the count before returning the
50491:     // object.
50491: 
50491:     ExecutablePool* poolForSize(size_t n)
50491:     {
50491:         // Try to fit in the existing small allocator
50491:         if (n < m_smallAllocationPool->available()) {
50491: 	    m_smallAllocationPool->addRef();
50491:             return m_smallAllocationPool;
50491: 	}
50491: 
50491:         // If the request is large, we just provide a unshared allocator
50491:         if (n > JIT_ALLOCATOR_LARGE_ALLOC_SIZE)
50491:             return ExecutablePool::create(n);
50491: 
50491:         // Create a new allocator
50491:         ExecutablePool* pool = ExecutablePool::create(JIT_ALLOCATOR_LARGE_ALLOC_SIZE);
57810:         if (!pool)
57810:             return NULL;
50491:   	    // At this point, local |pool| is the owner.
50491: 
50491:         // If the new allocator will result in more free space than in
50491:         // the current small allocator, then we will use it instead
50491:         if ((pool->available() - n) > m_smallAllocationPool->available()) {
50491: 	        m_smallAllocationPool->release();
50491:             m_smallAllocationPool = pool;
50491: 	        pool->addRef();
50491: 	    }
50491: 
50491:    	    // Pass ownership to the caller.
50491:         return pool;
50491:     }
50491: 
50491: #if ENABLE_ASSEMBLER_WX_EXCLUSIVE
50491:     static void makeWritable(void* start, size_t size)
50491:     {
50491:         reprotectRegion(start, size, Writable);
50491:     }
50491: 
50491:     static void makeExecutable(void* start, size_t size)
50491:     {
50491:         reprotectRegion(start, size, Executable);
50491:     }
50491: #else
50491:     static void makeWritable(void*, size_t) {}
50491:     static void makeExecutable(void*, size_t) {}
50491: #endif
50491: 
50491: 
50491: #if WTF_CPU_X86 || WTF_CPU_X86_64
50491:     static void cacheFlush(void*, size_t)
50491:     {
50491:     }
50491: #elif WTF_CPU_MIPS
50491:     static void cacheFlush(void* code, size_t size)
50491:     {
50491: #if WTF_COMPILER_GCC && (GCC_VERSION >= 40300)
50491: #if WTF_MIPS_ISA_REV(2) && (GCC_VERSION < 40403)
50491:         int lineSize;
50491:         asm("rdhwr %0, $1" : "=r" (lineSize));
50491:         //
50491:         // Modify "start" and "end" to avoid GCC 4.3.0-4.4.2 bug in
50491:         // mips_expand_synci_loop that may execute synci one more time.
50491:         // "start" points to the fisrt byte of the cache line.
50491:         // "end" points to the last byte of the line before the last cache line.
50491:         // Because size is always a multiple of 4, this is safe to set
50491:         // "end" to the last byte.
50491:         //
50491:         intptr_t start = reinterpret_cast<intptr_t>(code) & (-lineSize);
50491:         intptr_t end = ((reinterpret_cast<intptr_t>(code) + size - 1) & (-lineSize)) - 1;
50491:         __builtin___clear_cache(reinterpret_cast<char*>(start), reinterpret_cast<char*>(end));
50491: #else
50491:         intptr_t end = reinterpret_cast<intptr_t>(code) + size;
50491:         __builtin___clear_cache(reinterpret_cast<char*>(code), reinterpret_cast<char*>(end));
50491: #endif
50491: #else
50491:         _flush_cache(reinterpret_cast<char*>(code), size, BCACHE);
50491: #endif
50491:     }
50491: #elif WTF_CPU_ARM_THUMB2 && WTF_PLATFORM_IPHONE
50491:     static void cacheFlush(void* code, size_t size)
50491:     {
50491:         sys_dcache_flush(code, size);
50491:         sys_icache_invalidate(code, size);
50491:     }
50491: #elif WTF_CPU_ARM_THUMB2 && WTF_PLATFORM_LINUX
50491:     static void cacheFlush(void* code, size_t size)
50491:     {
50491:         asm volatile (
50491:             "push    {r7}\n"
50491:             "mov     r0, %0\n"
50491:             "mov     r1, %1\n"
50491:             "movw    r7, #0x2\n"
50491:             "movt    r7, #0xf\n"
50491:             "movs    r2, #0x0\n"
50491:             "svc     0x0\n"
50491:             "pop     {r7}\n"
50491:             :
50491:             : "r" (code), "r" (reinterpret_cast<char*>(code) + size)
50491:             : "r0", "r1", "r2");
50491:     }
50491: #elif WTF_PLATFORM_SYMBIAN
50491:     static void cacheFlush(void* code, size_t size)
50491:     {
50491:         User::IMB_Range(code, static_cast<char*>(code) + size);
50491:     }
50491: #elif WTF_CPU_ARM_TRADITIONAL && WTF_PLATFORM_LINUX && WTF_COMPILER_RVCT
50491:     static __asm void cacheFlush(void* code, size_t size);
50693: #elif WTF_CPU_ARM_TRADITIONAL && (WTF_PLATFORM_LINUX || WTF_PLATFORM_ANDROID) && WTF_COMPILER_GCC
50491:     static void cacheFlush(void* code, size_t size)
50491:     {
50491:         asm volatile (
50491:             "push    {r7}\n"
50491:             "mov     r0, %0\n"
50491:             "mov     r1, %1\n"
50491:             "mov     r7, #0xf0000\n"
50491:             "add     r7, r7, #0x2\n"
50491:             "mov     r2, #0x0\n"
50491:             "svc     0x0\n"
50491:             "pop     {r7}\n"
50491:             :
50491:             : "r" (code), "r" (reinterpret_cast<char*>(code) + size)
50491:             : "r0", "r1", "r2");
50491:     }
50491: #elif WTF_PLATFORM_WINCE
50491:     static void cacheFlush(void* code, size_t size)
50491:     {
50491:         CacheRangeFlush(code, size, CACHE_SYNC_ALL);
50491:     }
50491: #else
50491:     #error "The cacheFlush support is missing on this platform."
50491: #endif
50491: 
50491: private:
50491: 
50491: #if ENABLE_ASSEMBLER_WX_EXCLUSIVE
50491:     static void reprotectRegion(void*, size_t, ProtectionSeting);
50491: #endif
50491: 
50491:     ExecutablePool* m_smallAllocationPool;
50491:     static void intializePageSize();
50491: };
50491: 
57810: // This constructor can fail due to OOM. If it does, m_freePtr will be
57810: // set to NULL. 
50491: inline ExecutablePool::ExecutablePool(size_t n) : m_refCount(1)
50491: {
50491:     size_t allocSize = roundUpAllocationSize(n, JIT_ALLOCATOR_PAGE_SIZE);
57810:     if (allocSize == OVERSIZE_ALLOCATION) {
57810:         m_freePtr = NULL;
57810:         return;
57810:     }
50491:     Allocation mem = systemAlloc(allocSize);
57810:     if (!mem.pages) {
57810:         m_freePtr = NULL;
57810:         return;
57810:     }
57810:     if (!m_pools.append(mem)) {
57810:         systemRelease(mem);
57810:         m_freePtr = NULL;
57810:         return;
57810:     }
50491:     m_freePtr = mem.pages;
50491:     m_end = m_freePtr + allocSize;
50491: }
50491: 
50491: inline void* ExecutablePool::poolAllocate(size_t n)
50491: {
50491:     size_t allocSize = roundUpAllocationSize(n, JIT_ALLOCATOR_PAGE_SIZE);
57810:     if (allocSize == OVERSIZE_ALLOCATION)
57810:         return NULL;
50491:     
50491:     Allocation result = systemAlloc(allocSize);
50491:     if (!result.pages)
57810:         return NULL;
50491:     
50646:     JS_ASSERT(m_end >= m_freePtr);
50491:     if ((allocSize - n) > static_cast<size_t>(m_end - m_freePtr)) {
50491:         // Replace allocation pool
50491:         m_freePtr = result.pages + n;
50491:         m_end = result.pages + allocSize;
50491:     }
50491: 
50491:     m_pools.append(result);
50491:     return result.pages;
50491: }
50491: 
50491: }
50491: 
50491: #endif // ENABLE(ASSEMBLER)
50491: 
50491: #endif // !defined(ExecutableAllocator)
