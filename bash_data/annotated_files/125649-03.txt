 36949: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 36949: 
 80467: #include "mozilla/Util.h"
 80467: 
 61084: #ifdef MOZ_LOGGING
 61084: #define FORCE_PR_LOG /* Allow logging in the release build */
 61084: #endif
 61084: #include "prlog.h"
 61084: 
 36949: #include "gfxGDIFontList.h"
 36949: #include "gfxWindowsPlatform.h"
 36949: #include "gfxUserFontSet.h"
 36949: #include "gfxFontUtils.h"
 39447: #include "gfxGDIFont.h"
 36949: 
 36949: #include "nsServiceManagerUtils.h"
 36949: #include "nsTArray.h"
 36949: #include "nsUnicharUtils.h"
 36949: 
 36949: #include "nsDirectoryServiceUtils.h"
 36949: #include "nsDirectoryServiceDefs.h"
 36949: #include "nsAppDirectoryServiceDefs.h"
 36949: #include "nsISimpleEnumerator.h"
 36949: #include "nsIWindowsRegKey.h"
 36949: 
 74430: #include "mozilla/Telemetry.h"
 74430: 
 39447: #include <usp10.h>
 90802: #include <t2embapi.h>
 39447: 
 74430: using namespace mozilla;
 74430: 
 36949: #define ROUND(x) floor((x) + 0.5)
 36949: 
 42854: 
 42854: #ifndef CLEARTYPE_QUALITY
 42854: #define CLEARTYPE_QUALITY 5
 42854: #endif
 42854: 
 36949: #ifdef PR_LOGGING
 61084: #define LOG_FONTLIST(args) PR_LOG(gfxPlatform::GetLog(eGfxLog_fontlist), \
 61084:                                PR_LOG_DEBUG, args)
 61084: #define LOG_FONTLIST_ENABLED() PR_LOG_TEST( \
 61084:                                    gfxPlatform::GetLog(eGfxLog_fontlist), \
 61084:                                    PR_LOG_DEBUG)
 36949: 
 91869: #define LOG_CMAPDATA_ENABLED() PR_LOG_TEST( \
 91869:                                    gfxPlatform::GetLog(eGfxLog_cmapdata), \
 91869:                                    PR_LOG_DEBUG)
 91869: 
 61084: #endif // PR_LOGGING
 36949: 
 36949: // font info loader constants
 61083: 
 61083: // avoid doing this during startup even on slow machines but try to start
 61083: // it soon enough so that system fallback doesn't happen first
108991: static const uint32_t kDelayBeforeLoadingFonts = 120 * 1000; // 2 minutes after init
108991: static const uint32_t kIntervalBetweenLoadingFonts = 2000;   // every 2 seconds until complete
 36949: 
 36949: static __inline void
 36949: BuildKeyNameFromFontName(nsAString &aName)
 36949: {
 36949:     if (aName.Length() >= LF_FACESIZE)
 36949:         aName.Truncate(LF_FACESIZE - 1);
 36949:     ToLowerCase(aName);
 36949: }
 36949: 
 36949: // Implementation of gfxPlatformFontList for Win32 GDI,
 36949: // using GDI font enumeration APIs to get the list of fonts
 36949: 
 93527: typedef LONG
 93527: (WINAPI *TTLoadEmbeddedFontProc)(HANDLE* phFontReference, ULONG ulFlags,
 93527:                                  ULONG* pulPrivStatus, ULONG ulPrivs,
 93527:                                  ULONG* pulStatus,
 93527:                                  READEMBEDPROC lpfnReadFromStream,
 93527:                                  LPVOID lpvReadStream,
 93527:                                  LPWSTR szWinFamilyName, 
 93527:                                  LPSTR szMacFamilyName,
 93527:                                  TTLOADINFO* pTTLoadInfo);
 93527: 
 93527: typedef LONG
 93527: (WINAPI *TTDeleteEmbeddedFontProc)(HANDLE hFontReference, ULONG ulFlags,
 93527:                                    ULONG* pulStatus);
 93527: 
 93527: 
106838: static TTLoadEmbeddedFontProc TTLoadEmbeddedFontPtr = nullptr;
106838: static TTDeleteEmbeddedFontProc TTDeleteEmbeddedFontPtr = nullptr;
 91197: 
 36949: class WinUserFontData : public gfxUserFontData {
 36949: public:
 79445:     WinUserFontData(HANDLE aFontRef, bool aIsEmbedded)
 47845:         : mFontRef(aFontRef), mIsEmbedded(aIsEmbedded)
 36949:     { }
 36949: 
 36949:     virtual ~WinUserFontData()
 36949:     {
 47845:         if (mIsEmbedded) {
 47845:             ULONG pulStatus;
 47845:             LONG err;
 93527:             err = TTDeleteEmbeddedFontPtr(mFontRef, 0, &pulStatus);
 47845: #if DEBUG
 47845:             if (err != E_NONE) {
 47845:                 char buf[256];
 47845:                 sprintf(buf, "error deleting embedded font handle (%p) - TTDeleteEmbeddedFont returned %8.8x", mFontRef, err);
 47845:                 NS_ASSERTION(err == E_NONE, buf);
 47845:             }
 47845: #endif
 36949:         } else {
116100:             DebugOnly<BOOL> success;
 47845:             success = RemoveFontMemResourceEx(mFontRef);
 47845: #if DEBUG
 47845:             if (!success) {
 47845:                 char buf[256];
 47845:                 sprintf(buf, "error deleting font handle (%p) - RemoveFontMemResourceEx failed", mFontRef);
 47845:                 NS_ASSERTION(success, buf);
 47845:             }
 47845: #endif
 36949:         }
 36949:     }
 36949:     
 36949:     HANDLE mFontRef;
 79445:     bool mIsEmbedded;
 36949: };
 36949: 
 36949: BYTE 
108991: FontTypeToOutPrecision(uint8_t fontType)
 36949: {
 36949:     BYTE ret;
 36949:     switch (fontType) {
 36949:     case GFX_FONT_TYPE_TT_OPENTYPE:
 36949:     case GFX_FONT_TYPE_TRUETYPE:
 36949:         ret = OUT_TT_ONLY_PRECIS;
 36949:         break;
 36949:     case GFX_FONT_TYPE_PS_OPENTYPE:
 36949:         ret = OUT_PS_ONLY_PRECIS;
 36949:         break;
 36949:     case GFX_FONT_TYPE_TYPE1:
 36949:         ret = OUT_OUTLINE_PRECIS;
 36949:         break;
 36949:     case GFX_FONT_TYPE_RASTER:
 36949:         ret = OUT_RASTER_PRECIS;
 36949:         break;
 36949:     case GFX_FONT_TYPE_DEVICE:
 36949:         ret = OUT_DEVICE_PRECIS;
 36949:         break;
 36949:     default:
 36949:         ret = OUT_DEFAULT_PRECIS;
 36949:     }
 36949:     return ret;
 36949: }
 36949: 
 36949: /***************************************************************
 36949:  *
 36949:  * GDIFontEntry
 36949:  *
 36949:  */
 36949: 
 77858: GDIFontEntry::GDIFontEntry(const nsAString& aFaceName,
 77858:                            gfxWindowsFontType aFontType,
108991:                            bool aItalic, uint16_t aWeight, int16_t aStretch,
103472:                            gfxUserFontData *aUserFontData,
103472:                            bool aFamilyHasItalicFace)
 77858:     : gfxFontEntry(aFaceName),
 40483:       mWindowsFamily(0), mWindowsPitch(0),
 40483:       mFontType(aFontType),
 95682:       mForceGDI(false),
103472:       mFamilyHasItalicFace(aFamilyHasItalicFace),
 36949:       mCharset(), mUnicodeRanges()
 36949: {
 36949:     mUserFontData = aUserFontData;
 36949:     mItalic = aItalic;
 36949:     mWeight = aWeight;
 77858:     mStretch = aStretch;
 36949:     if (IsType1())
 80486:         mForceGDI = true;
106838:     mIsUserFont = aUserFontData != nullptr;
 42854: 
 43347:     InitLogFont(aFaceName, aFontType);
 36949: }
 36949: 
 36949: nsresult
 36949: GDIFontEntry::ReadCMAP()
 36949: {
 95682:     // attempt this once, if errors occur leave a blank cmap
 95682:     if (mCharacterMap) {
 95682:         return NS_OK;
 95682:     }
 95682: 
 46221:     // skip non-SFNT fonts completely
 46221:     if (mFontType != GFX_FONT_TYPE_PS_OPENTYPE && 
 46221:         mFontType != GFX_FONT_TYPE_TT_OPENTYPE &&
 46221:         mFontType != GFX_FONT_TYPE_TRUETYPE) 
 46221:     {
 95682:         mCharacterMap = new gfxCharacterMap();
 97122:         mCharacterMap->mBuildOnTheFly = true;
 46221:         return NS_ERROR_FAILURE;
 46221:     }
 46221: 
 95682:     nsRefPtr<gfxCharacterMap> charmap = new gfxCharacterMap();
 36949: 
108991:     uint32_t kCMAP = TRUETYPE_TAG('c','m','a','p');
 95682:     nsresult rv;
 36949: 
108991:     AutoFallibleTArray<uint8_t,16384> cmap;
 95682:     rv = GetFontTable(kCMAP, cmap);
 95682: 
 95682:     bool unicodeFont = false, symbolFont = false; // currently ignored
 95682: 
 95682:     if (NS_SUCCEEDED(rv)) {
 95682:         rv = gfxFontUtils::ReadCMAP(cmap.Elements(), cmap.Length(),
 95682:                                     *charmap, mUVSOffset,
 43527:                                     unicodeFont, symbolFont);
 95682:     }
 36949:     mSymbolFont = symbolFont;
 95682: 
 43527:     mHasCmapTable = NS_SUCCEEDED(rv);
 95682:     if (mHasCmapTable) {
 95682:         gfxPlatformFontList *pfl = gfxPlatformFontList::PlatformFontList();
 95682:         mCharacterMap = pfl->FindCharMap(charmap);
 95682:     } else {
 95682:         // if error occurred, initialize to null cmap
 95682:         mCharacterMap = new gfxCharacterMap();
 95682:         // For fonts where we failed to read the character map,
 95682:         // we can take a slow path to look up glyphs character by character
 95682:         mCharacterMap->mBuildOnTheFly = true;
 95682:     }
 36949: 
 61084: #ifdef PR_LOGGING
 95682:     LOG_FONTLIST(("(fontlist-cmap) name: %s, size: %d hash: %8.8x%s\n",
 94199:                   NS_ConvertUTF16toUTF8(mName).get(),
 95682:                   charmap->SizeOfIncludingThis(moz_malloc_size_of),
 95682:                   charmap->mHash, mCharacterMap == charmap ? " new" : ""));
 91869:     if (LOG_CMAPDATA_ENABLED()) {
 91869:         char prefix[256];
 91869:         sprintf(prefix, "(cmapdata) name: %.220s",
 91869:                 NS_ConvertUTF16toUTF8(mName).get());
 95682:         charmap->Dump(prefix, eGfxLog_cmapdata);
 91869:     }
 61084: #endif
 95682: 
 36949:     return rv;
 36949: }
 36949: 
 79445: bool
 70100: GDIFontEntry::IsSymbolFont()
 70100: {
 70100:     // initialize cmap first
 70100:     HasCmapTable();
 70100:     return mSymbolFont;  
 70100: }
 70100: 
 37211: gfxFont *
 79445: GDIFontEntry::CreateFontInstance(const gfxFontStyle* aFontStyle, bool aNeedsBold)
 37211: {
 79445:     bool isXP = (gfxWindowsPlatform::WindowsOSVersion() 
 42854:                        < gfxWindowsPlatform::kWindowsVista);
 42854: 
 79445:     bool useClearType = isXP && !aFontStyle->systemFont &&
 42854:         (gfxWindowsPlatform::GetPlatform()->UseClearTypeAlways() ||
 43347:          (mIsUserFont && !mIsLocalUserFont &&
 42854:           gfxWindowsPlatform::GetPlatform()->UseClearTypeForDownloadableFonts()));
 42854: 
 42854:     return new gfxGDIFont(this, aFontStyle, aNeedsBold, 
 42854:                           (useClearType ? gfxFont::kAntialiasSubpixel
 42854:                                         : gfxFont::kAntialiasDefault));
 37211: }
 37211: 
 36949: nsresult
108991: GDIFontEntry::GetFontTable(uint32_t aTableTag,
108991:                            FallibleTArray<uint8_t>& aBuffer)
 36949: {
 43526:     if (!IsTrueType()) {
 43526:         return NS_ERROR_FAILURE;
 43526:     }
 43526: 
 36949:     AutoDC dc;
 36949:     AutoSelectFont font(dc.GetDC(), &mLogFont);
 36949:     if (font.IsValid()) {
116100:         uint32_t tableSize =
116100:             ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0, NULL, 0);
 36949:         if (tableSize != GDI_ERROR) {
 36949:             if (aBuffer.SetLength(tableSize)) {
 43526:                 ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0,
 43526:                               aBuffer.Elements(), tableSize);
 36949:                 return NS_OK;
 36949:             }
 36949:             return NS_ERROR_OUT_OF_MEMORY;
 36949:         }
 36949:     }
 36949:     return NS_ERROR_FAILURE;
 36949: }
 36949: 
 36949: void
 90073: GDIFontEntry::FillLogFont(LOGFONTW *aLogFont,
108991:                           uint16_t aWeight, gfxFloat aSize,
 79445:                           bool aUseCleartype)
 36949: {
 36949:     memcpy(aLogFont, &mLogFont, sizeof(LOGFONTW));
 36949: 
 36949:     aLogFont->lfHeight = (LONG)-ROUND(aSize);
 36949: 
 90073:     if (aLogFont->lfHeight == 0) {
 36949:         aLogFont->lfHeight = -1;
 90073:     }
 36949: 
 90073:     // If a non-zero weight is passed in, use this to override the original
 90073:     // weight in the entry's logfont. This is used to control synthetic bolding
 90073:     // for installed families with no bold face, and for downloaded fonts
 90073:     // (but NOT for local user fonts, because it could cause a different,
 90073:     // glyph-incompatible face to be used)
 90073:     if (aWeight) {
 36949:         aLogFont->lfWeight = aWeight;
 90073:     }
 90073: 
 90073:     // for non-local() user fonts, we never want to apply italics here;
 90073:     // if the face is described as italic, we should use it as-is,
 90073:     // and if it's not, but then the element is styled italic, we'll use
 90073:     // a cairo transform to create fake italic (oblique)
 90073:     if (IsUserFont() && !IsLocalUserFont()) {
 90073:         aLogFont->lfItalic = 0;
 90073:     }
 90073: 
 43347:     aLogFont->lfQuality = (aUseCleartype ? CLEARTYPE_QUALITY : DEFAULT_QUALITY);
 36949: }
 36949: 
 62924: #define MISSING_GLYPH 0x1F // glyph index returned for missing characters
 62924:                            // on WinXP with .fon fonts, but not Type1 (.pfb)
 46221: 
 79445: bool 
108991: GDIFontEntry::TestCharacterMap(uint32_t aCh)
 36949: {
 95682:     if (!mCharacterMap) {
116100:         ReadCMAP();
 95682:         NS_ASSERTION(mCharacterMap, "failed to initialize a character map");
 36949:     }
 36949: 
 95682:     if (mCharacterMap->mBuildOnTheFly) {
 36949:         if (aCh > 0xFFFF)
 80486:             return false;
 36949: 
 36949:         // previous code was using the group style
 36949:         gfxFontStyle fakeStyle;  
 36949:         if (mItalic)
 93220:             fakeStyle.style = NS_FONT_STYLE_ITALIC;
 36949:         fakeStyle.weight = mWeight * 100;
 36949: 
 80486:         nsRefPtr<gfxFont> tempFont = FindOrMakeFont(&fakeStyle, false);
 39447:         if (!tempFont || !tempFont->Valid())
 80486:             return false;
 39447:         gfxGDIFont *font = static_cast<gfxGDIFont*>(tempFont.get());
 36949: 
106838:         HDC dc = GetDC((HWND)nullptr);
 36949:         SetGraphicsMode(dc, GM_ADVANCED);
 36949:         HFONT hfont = font->GetHFONT();
 36949:         HFONT oldFont = (HFONT)SelectObject(dc, hfont);
 36949: 
 36949:         PRUnichar str[1] = { (PRUnichar)aCh };
 36949:         WORD glyph[1];
 36949: 
 79445:         bool hasGlyph = false;
 46221: 
 46221:         // Bug 573038 - in some cases GetGlyphIndicesW returns 0xFFFF for a 
 46221:         // missing glyph or 0x1F in other cases to indicate the "invalid" 
 46221:         // glyph.  Map both cases to "not found"
 39447:         if (IsType1() || mForceGDI) {
 46221:             // Type1 fonts and uniscribe APIs don't get along.  
 46221:             // ScriptGetCMap will return E_HANDLE
 46221:             DWORD ret = GetGlyphIndicesW(dc, str, 1, 
 46221:                                          glyph, GGI_MARK_NONEXISTING_GLYPHS);
 46221:             if (ret != GDI_ERROR
 46221:                 && glyph[0] != 0xFFFF
 62924:                 && (IsType1() || glyph[0] != MISSING_GLYPH))
 46221:             {
 80486:                 hasGlyph = true;
 46221:             }
 36949:         } else {
 46221:             // ScriptGetCMap works better than GetGlyphIndicesW 
 46221:             // for things like bitmap/vector fonts
 39447:             SCRIPT_CACHE sc = NULL;
 39447:             HRESULT rv = ScriptGetCMap(dc, &sc, str, 1, 0, glyph);
 36949:             if (rv == S_OK)
 80486:                 hasGlyph = true;
 36949:         }
 36949: 
 36949:         SelectObject(dc, oldFont);
 36949:         ReleaseDC(NULL, dc);
 36949: 
 36949:         if (hasGlyph) {
 95682:             mCharacterMap->set(aCh);
 80486:             return true;
 36949:         }
 36949:     } else {
 36949:         // font had a cmap so simply check that
 95682:         return mCharacterMap->test(aCh);
 36949:     }
 36949: 
 80486:     return false;
 36949: }
 36949: 
 36949: void
 36949: GDIFontEntry::InitLogFont(const nsAString& aName,
 43347:                           gfxWindowsFontType aFontType)
 36949: {
 36949: #define CLIP_TURNOFF_FONTASSOCIATION 0x40
 36949: 
 36949:     mLogFont.lfHeight = -1;
 36949: 
 36949:     // Fill in logFont structure
 36949:     mLogFont.lfWidth          = 0;
 36949:     mLogFont.lfEscapement     = 0;
 36949:     mLogFont.lfOrientation    = 0;
 36949:     mLogFont.lfUnderline      = FALSE;
 36949:     mLogFont.lfStrikeOut      = FALSE;
 36949:     mLogFont.lfCharSet        = DEFAULT_CHARSET;
 36949:     mLogFont.lfOutPrecision   = FontTypeToOutPrecision(aFontType);
 36949:     mLogFont.lfClipPrecision  = CLIP_TURNOFF_FONTASSOCIATION;
 43347:     mLogFont.lfQuality        = DEFAULT_QUALITY;
 36949:     mLogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
 36949:     // always force lfItalic if we want it.  Font selection code will
 36949:     // do its best to give us an italic font entry, but if no face exists
 36949:     // it may give us a regular one based on weight.  Windows should
 36949:     // do fake italic for us in that case.
 36949:     mLogFont.lfItalic         = mItalic;
 36949:     mLogFont.lfWeight         = mWeight;
 36949: 
 71173:     int len = NS_MIN<int>(aName.Length(), LF_FACESIZE - 1);
 71519:     memcpy(&mLogFont.lfFaceName, nsPromiseFlatString(aName).get(), len * 2);
 36949:     mLogFont.lfFaceName[len] = '\0';
 36949: }
 36949: 
 36949: GDIFontEntry* 
 77858: GDIFontEntry::CreateFontEntry(const nsAString& aName,
 79445:                               gfxWindowsFontType aFontType, bool aItalic,
108991:                               uint16_t aWeight, int16_t aStretch,
103472:                               gfxUserFontData* aUserFontData,
103472:                               bool aFamilyHasItalicFace)
 36949: {
 36949:     // jtdfix - need to set charset, unicode ranges, pitch/family
 36949: 
 77858:     GDIFontEntry *fe = new GDIFontEntry(aName, aFontType, aItalic,
103472:                                         aWeight, aStretch, aUserFontData,
103472:                                         aFamilyHasItalicFace);
 36949: 
 36949:     return fe;
 36949: }
 36949: 
 94199: void
 94199: GDIFontEntry::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                   FontListSizes*    aSizes) const
 94199: {
 94199:     aSizes->mFontListSize += aMallocSizeOf(this);
 94199:     SizeOfExcludingThis(aMallocSizeOf, aSizes);
 94199: }
 94199: 
 36949: /***************************************************************
 36949:  *
 36949:  * GDIFontFamily
 36949:  *
 36949:  */
 36949: 
 36949: int CALLBACK
 36949: GDIFontFamily::FamilyAddStylesProc(const ENUMLOGFONTEXW *lpelfe,
 36949:                                         const NEWTEXTMETRICEXW *nmetrics,
 36949:                                         DWORD fontType, LPARAM data)
 36949: {
 36949:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
 36949:     LOGFONTW logFont = lpelfe->elfLogFont;
 36949:     GDIFontFamily *ff = reinterpret_cast<GDIFontFamily*>(data);
 36949: 
 36949:     // Some fonts claim to support things > 900, but we don't so clamp the sizes
 81029:     logFont.lfWeight = clamped(logFont.lfWeight, LONG(100), LONG(900));
 36949: 
 36949:     gfxWindowsFontType feType = GDIFontEntry::DetermineFontType(metrics, fontType);
 36949: 
106838:     GDIFontEntry *fe = nullptr;
108991:     for (uint32_t i = 0; i < ff->mAvailableFonts.Length(); ++i) {
 36949:         fe = static_cast<GDIFontEntry*>(ff->mAvailableFonts[i].get());
 36949:         if (feType > fe->mFontType) {
 36949:             // if the new type is better than the old one, remove the old entries
 36949:             ff->mAvailableFonts.RemoveElementAt(i);
 36949:             --i;
 36949:         } else if (feType < fe->mFontType) {
 36949:             // otherwise if the new type is worse, skip it
 36949:             return 1;
 36949:         }
 36949:     }
 36949: 
108991:     for (uint32_t i = 0; i < ff->mAvailableFonts.Length(); ++i) {
 36949:         fe = static_cast<GDIFontEntry*>(ff->mAvailableFonts[i].get());
 36949:         // check if we already know about this face
 36949:         if (fe->mWeight == logFont.lfWeight &&
 36949:             fe->mItalic == (logFont.lfItalic == 0xFF)) {
 36949:             // update the charset bit here since this could be different
 37209:             fe->mCharset.set(metrics.tmCharSet);
 36949:             return 1; 
 36949:         }
 36949:     }
 36949: 
103472:     // We can't set the hasItalicFace flag correctly here,
103472:     // because we might not have seen the family's italic face(s) yet.
125649:     // So we'll set that flag for all members after loading all the faces.
 77858:     fe = GDIFontEntry::CreateFontEntry(nsDependentString(lpelfe->elfFullName),
 77858:                                        feType, (logFont.lfItalic == 0xFF),
108991:                                        (uint16_t) (logFont.lfWeight), 0,
106838:                                        nullptr, false);
 36949:     if (!fe)
 36949:         return 1;
 36949: 
 61357:     ff->AddFontEntry(fe);
 36949: 
 36949:     // mark the charset bit
 37209:     fe->mCharset.set(metrics.tmCharSet);
 36949: 
 36949:     fe->mWindowsFamily = logFont.lfPitchAndFamily & 0xF0;
 36949:     fe->mWindowsPitch = logFont.lfPitchAndFamily & 0x0F;
 36949: 
 36949:     if (nmetrics->ntmFontSig.fsUsb[0] != 0x00000000 &&
 36949:         nmetrics->ntmFontSig.fsUsb[1] != 0x00000000 &&
 36949:         nmetrics->ntmFontSig.fsUsb[2] != 0x00000000 &&
 36949:         nmetrics->ntmFontSig.fsUsb[3] != 0x00000000) {
 36949: 
 36949:         // set the unicode ranges
108991:         uint32_t x = 0;
108991:         for (uint32_t i = 0; i < 4; ++i) {
 36949:             DWORD range = nmetrics->ntmFontSig.fsUsb[i];
108991:             for (uint32_t k = 0; k < 32; ++k) {
 37209:                 fe->mUnicodeRanges.set(x++, (range & (1 << k)) != 0);
 36949:             }
 36949:         }
 36949:     }
 36949: 
 36949: #ifdef PR_LOGGING
 61084:     if (LOG_FONTLIST_ENABLED()) {
 61084:         LOG_FONTLIST(("(fontlist) added (%s) to family (%s)"
 36949:              " with style: %s weight: %d stretch: %d",
 36949:              NS_ConvertUTF16toUTF8(fe->Name()).get(), 
 36949:              NS_ConvertUTF16toUTF8(ff->Name()).get(), 
 36949:              (logFont.lfItalic == 0xff) ? "italic" : "normal",
 36949:              logFont.lfWeight, fe->Stretch()));
 36949:     }
 36949: #endif
 36949:     return 1;
 36949: }
 36949: 
 36949: void
 36949: GDIFontFamily::FindStyleVariations()
 36949: {
 36949:     if (mHasStyles)
 36949:         return;
 80486:     mHasStyles = true;
 36949: 
106838:     HDC hdc = GetDC(nullptr);
 36949:     SetGraphicsMode(hdc, GM_ADVANCED);
 36949: 
 36949:     LOGFONTW logFont;
 36949:     memset(&logFont, 0, sizeof(LOGFONTW));
 36949:     logFont.lfCharSet = DEFAULT_CHARSET;
 36949:     logFont.lfPitchAndFamily = 0;
108991:     uint32_t l = NS_MIN<uint32_t>(mName.Length(), LF_FACESIZE - 1);
 36949:     memcpy(logFont.lfFaceName,
 36949:            nsPromiseFlatString(mName).get(),
 36949:            l * sizeof(PRUnichar));
 36949:     logFont.lfFaceName[l] = 0;
 36949: 
 36949:     EnumFontFamiliesExW(hdc, &logFont,
 36949:                         (FONTENUMPROCW)GDIFontFamily::FamilyAddStylesProc,
 36949:                         (LPARAM)this, 0);
 38205: #ifdef PR_LOGGING
 61084:     if (LOG_FONTLIST_ENABLED() && mAvailableFonts.Length() == 0) {
 61084:         LOG_FONTLIST(("(fontlist) no styles available in family \"%s\"",
 61084:                       NS_ConvertUTF16toUTF8(mName).get()));
 36949:     }
 36949: #endif
 36949: 
106838:     ReleaseDC(nullptr, hdc);
 36949: 
125649:     if (mIsBadUnderlineFamily) {
 36949:         SetBadUnderlineFonts();
 36949:     }
 36949: 
125649:     // check for existence of italic face(s); if present, set the
125649:     // FamilyHasItalic flag on all faces so that we'll know *not*
125649:     // to use GDI's fake-italic effect with them
125649:     size_t count = mAvailableFonts.Length();
125649:     for (size_t i = 0; i < count; ++i) {
125649:         if (mAvailableFonts[i]->IsItalic()) {
125649:             for (uint32_t j = 0; j < count; ++j) {
125649:                 static_cast<GDIFontEntry*>(mAvailableFonts[j].get())->
125649:                     mFamilyHasItalicFace = true;
125649:             }
125649:             break;
125649:         }
125649:     }
125649: }
125649: 
 36949: /***************************************************************
 36949:  *
 36949:  * gfxGDIFontList
 36949:  *
 36949:  */
 36949: 
 36949: gfxGDIFontList::gfxGDIFontList()
 36949: {
 36949:     mFontSubstitutes.Init(50);
 91197: 
 93527:     InitializeFontEmbeddingProcs();
 36949: }
 36949: 
 36949: static void
 36949: RemoveCharsetFromFontSubstitute(nsAString &aName)
 36949: {
108991:     int32_t comma = aName.FindChar(PRUnichar(','));
 36949:     if (comma >= 0)
 36949:         aName.Truncate(comma);
 36949: }
 36949: 
 61083: #define MAX_VALUE_NAME 512
 61083: #define MAX_VALUE_DATA 512
 61083: 
 36949: nsresult
 36949: gfxGDIFontList::GetFontSubstitutes()
 36949: {
 61083:     HKEY hKey;
 61083:     DWORD i, rv, lenAlias, lenActual, valueType;
 61083:     WCHAR aliasName[MAX_VALUE_NAME];
 61083:     WCHAR actualName[MAX_VALUE_DATA];
 61083: 
 61083:     if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
 61083:           L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes",
 61083:           0, KEY_READ, &hKey) != ERROR_SUCCESS)
 61083:     {
 36949:         return NS_ERROR_FAILURE;
 61083:     }
 36949: 
 61083:     for (i = 0, rv = ERROR_SUCCESS; rv != ERROR_NO_MORE_ITEMS; i++) {
 61083:         aliasName[0] = 0;
 80467:         lenAlias = ArrayLength(aliasName);
 61083:         actualName[0] = 0;
 61083:         lenActual = sizeof(actualName);
 61083:         rv = RegEnumValueW(hKey, i, aliasName, &lenAlias, NULL, &valueType, 
 61083:                 (LPBYTE)actualName, &lenActual);
 36949: 
 61083:         if (rv != ERROR_SUCCESS || valueType != REG_SZ || lenAlias == 0) {
 36949:             continue;
 61083:         }
 61083: 
 61083:         if (aliasName[0] == WCHAR('@')) {
 36949:             continue;
 61083:         }
 36949: 
 61083:         nsAutoString substituteName((PRUnichar*) aliasName);
 61083:         nsAutoString actualFontName((PRUnichar*) actualName);
 36949:         RemoveCharsetFromFontSubstitute(substituteName);
 36949:         BuildKeyNameFromFontName(substituteName);
 36949:         RemoveCharsetFromFontSubstitute(actualFontName);
 36949:         BuildKeyNameFromFontName(actualFontName);
 36949:         gfxFontFamily *ff;
 61083:         if (!actualFontName.IsEmpty() && 
 61083:             (ff = mFontFamilies.GetWeak(actualFontName))) {
 36949:             mFontSubstitutes.Put(substituteName, ff);
 36949:         } else {
 36949:             mNonExistingFonts.AppendElement(substituteName);
 36949:         }
 36949:     }
 81013: 
 81013:     // "Courier" on a default Windows install is an ugly bitmap font.
 81013:     // If there is no substitution for Courier in the registry
 81013:     // substitute "Courier" with "Courier New".
 81013:     nsAutoString substituteName;
 81013:     substituteName.AssignLiteral("Courier");
 81013:     BuildKeyNameFromFontName(substituteName);
 94199:     if (!mFontSubstitutes.GetWeak(substituteName)) {
 81013:         gfxFontFamily *ff;
 81013:         nsAutoString actualFontName;
 81013:         actualFontName.AssignLiteral("Courier New");
 81013:         BuildKeyNameFromFontName(actualFontName);
 81013:         ff = mFontFamilies.GetWeak(actualFontName);
 81013:         if (ff) {
 81013:             mFontSubstitutes.Put(substituteName, ff);
 81013:         }
 81013:     }
 36949:     return NS_OK;
 36949: }
 36949: 
 57104: nsresult
 36949: gfxGDIFontList::InitFontList()
 36949: {
 74430:     Telemetry::AutoTimer<Telemetry::GDI_INITFONTLIST_TOTAL> timer;
 36949:     gfxFontCache *fc = gfxFontCache::GetCache();
 36949:     if (fc)
 36949:         fc->AgeAllGenerations();
 36949: 
 37618:     // reset font lists
 37618:     gfxPlatformFontList::InitFontList();
 37618:     
 36949:     mFontSubstitutes.Clear();
 36949:     mNonExistingFonts.Clear();
 36949: 
 36949:     // iterate over available families
 36949:     LOGFONTW logfont;
 36949:     memset(&logfont, 0, sizeof(logfont));
 36949:     logfont.lfCharSet = DEFAULT_CHARSET;
 36949: 
 36949:     AutoDC hdc;
 36949:     int result = EnumFontFamiliesExW(hdc.GetDC(), &logfont,
 36949:                                      (FONTENUMPROCW)&EnumFontFamExProc,
 36949:                                      0, 0);
 36949: 
 36949:     GetFontSubstitutes();
 36949: 
 36949:     StartLoader(kDelayBeforeLoadingFonts, kIntervalBetweenLoadingFonts);
 57104: 
 57104:     return NS_OK;
 36949: }
 36949: 
 36949: int CALLBACK
 36949: gfxGDIFontList::EnumFontFamExProc(ENUMLOGFONTEXW *lpelfe,
 36949:                                       NEWTEXTMETRICEXW *lpntme,
 36949:                                       DWORD fontType,
 36949:                                       LPARAM lParam)
 36949: {
 36949:     const LOGFONTW& lf = lpelfe->elfLogFont;
 36949: 
 36949:     if (lf.lfFaceName[0] == '@') {
 36949:         return 1;
 36949:     }
 36949: 
 36949:     nsAutoString name(lf.lfFaceName);
 36949:     BuildKeyNameFromFontName(name);
 36949: 
 36949:     gfxGDIFontList *fontList = PlatformFontList();
 36949: 
 36949:     if (!fontList->mFontFamilies.GetWeak(name)) {
 37209:         nsDependentString faceName(lf.lfFaceName);
 37209:         nsRefPtr<gfxFontFamily> family = new GDIFontFamily(faceName);
 36949:         fontList->mFontFamilies.Put(name, family);
 60116: 
 60116:         // if locale is such that CJK font names are the default coming from
 60116:         // GDI, then if a family name is non-ASCII immediately read in other
 60116:         // family names.  This assures that MS Gothic, MS Mincho are all found
 60116:         // before lookups begin.
 60116:         if (!IsASCII(faceName)) {
 60116:             family->ReadOtherFamilyNames(gfxPlatformFontList::PlatformFontList());
 60116:         }
 60116: 
 38060:         if (fontList->mBadUnderlineFamilyNames.Contains(name))
 37599:             family->SetBadUnderlineFamily();
 36949:     }
 36949: 
 36949:     return 1;
 36949: }
 36949: 
 36949: gfxFontEntry* 
 36949: gfxGDIFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
 36949:                                 const nsAString& aFullname)
 36949: {
 37618:     gfxFontEntry *lookup;
 36949: 
 37618:     // initialize name lookup tables if needed
 37618:     if (!mFaceNamesInitialized) {
 37618:         InitFaceNameLists();
 37618:     }
 36949: 
 37618:     // lookup in name lookup tables, return null if not found
 94199:     if (!(lookup = mPostscriptNames.GetWeak(aFullname)) &&
 94199:         !(lookup = mFullnames.GetWeak(aFullname))) 
 36949:     {
106838:         return nullptr;
 36949:     }
 36949: 
 79445:     bool isCFF = false; // jtdfix -- need to determine this
 36949:     
 37618:     // use the face name from the lookup font entry, which will be the localized
 37618:     // face name which GDI mapping tables use (e.g. with the system locale set to
 37618:     // Dutch, a fullname of 'Arial Bold' will find a font entry with the face name
 37618:     // 'Arial Vet' which can be used as a key in GDI font lookups).
103143:     GDIFontEntry *fe = GDIFontEntry::CreateFontEntry(lookup->Name(), 
 36949:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
103143:         lookup->mItalic ? NS_FONT_STYLE_ITALIC : NS_FONT_STYLE_NORMAL,
106838:         lookup->mWeight, aProxyEntry->mStretch, nullptr,
125649:         static_cast<GDIFontEntry*>(lookup)->mFamilyHasItalicFace);
 36949:         
 36949:     if (!fe)
106838:         return nullptr;
 36949: 
 80486:     fe->mIsUserFont = true;
 80486:     fe->mIsLocalUserFont = true;
103143: 
103143:     // make the new font entry match the proxy entry style characteristics
103143:     fe->mWeight = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
103143:     fe->mItalic = aProxyEntry->mItalic;
103143: 
 36949:     return fe;
 36949: }
 36949: 
 93527: void gfxGDIFontList::InitializeFontEmbeddingProcs()
 93527: {
 93527:     static HMODULE fontlib = LoadLibraryW(L"t2embed.dll");
 93527:     if (!fontlib)
 93527:         return;
 93527:     TTLoadEmbeddedFontPtr = (TTLoadEmbeddedFontProc)
 93527:         GetProcAddress(fontlib, "TTLoadEmbeddedFont");
 93527:     TTDeleteEmbeddedFontPtr = (TTDeleteEmbeddedFontProc)
 93527:         GetProcAddress(fontlib, "TTDeleteEmbeddedFont");
 93527: }
 93527: 
 36949: // used to control stream read by Windows TTLoadEmbeddedFont API
 36949: 
 36949: class EOTFontStreamReader {
 36949: public:
108991:     EOTFontStreamReader(const uint8_t *aFontData, uint32_t aLength, uint8_t *aEOTHeader, 
108991:                            uint32_t aEOTHeaderLen, FontDataOverlay *aNameOverlay)
 36949:         : mCurrentChunk(0), mChunkOffset(0)
 36949:     {
 36949:         NS_ASSERTION(aFontData, "null font data ptr passed in");
 36949:         NS_ASSERTION(aEOTHeader, "null EOT header ptr passed in");
 36949:         NS_ASSERTION(aNameOverlay, "null name overlay struct passed in");
 36949: 
 36949:         if (aNameOverlay->overlaySrc) {
 36949:             mNumChunks = 4;
 36949:             // 0 : EOT header
 36949:             mDataChunks[0].mData = aEOTHeader;
 36949:             mDataChunks[0].mLength = aEOTHeaderLen;
 36949:             // 1 : start of font data to overlayDest
 36949:             mDataChunks[1].mData = aFontData;
 36949:             mDataChunks[1].mLength = aNameOverlay->overlayDest;
 36949:             // 2 : overlay data
 36949:             mDataChunks[2].mData = aFontData + aNameOverlay->overlaySrc;
 36949:             mDataChunks[2].mLength = aNameOverlay->overlaySrcLen;
 36949:             // 3 : rest of font data
 36949:             mDataChunks[3].mData = aFontData + aNameOverlay->overlayDest + aNameOverlay->overlaySrcLen;
 36949:             mDataChunks[3].mLength = aLength - aNameOverlay->overlayDest - aNameOverlay->overlaySrcLen;
 36949:         } else {
 36949:             mNumChunks = 2;
 36949:             // 0 : EOT header
 36949:             mDataChunks[0].mData = aEOTHeader;
 36949:             mDataChunks[0].mLength = aEOTHeaderLen;
 36949:             // 1 : font data
 36949:             mDataChunks[1].mData = aFontData;
 36949:             mDataChunks[1].mLength = aLength;
 36949:         }
 36949:     }
 36949: 
 36949:     ~EOTFontStreamReader() 
 36949:     { 
 36949: 
 36949:     }
 36949: 
 36949:     struct FontDataChunk {
108991:         const uint8_t *mData;
108991:         uint32_t       mLength;
 36949:     };
 36949: 
108991:     uint32_t                mNumChunks;
 36949:     FontDataChunk           mDataChunks[4];
108991:     uint32_t                mCurrentChunk;
108991:     uint32_t                mChunkOffset;
 36949: 
 36949:     unsigned long Read(void *outBuffer, const unsigned long aBytesToRead)
 36949:     {
108991:         uint32_t bytesLeft = aBytesToRead;  // bytes left in the out buffer
108991:         uint8_t *out = static_cast<uint8_t*> (outBuffer);
 36949: 
 36949:         while (mCurrentChunk < mNumChunks && bytesLeft) {
 36949:             FontDataChunk& currentChunk = mDataChunks[mCurrentChunk];
108991:             uint32_t bytesToCopy = NS_MIN(bytesLeft, 
 36949:                                           currentChunk.mLength - mChunkOffset);
 36949:             memcpy(out, currentChunk.mData + mChunkOffset, bytesToCopy);
 36949:             bytesLeft -= bytesToCopy;
 36949:             mChunkOffset += bytesToCopy;
 36949:             out += bytesToCopy;
 36949: 
 36949:             NS_ASSERTION(mChunkOffset <= currentChunk.mLength, "oops, buffer overrun");
 36949: 
 36949:             if (mChunkOffset == currentChunk.mLength) {
 36949:                 mCurrentChunk++;
 36949:                 mChunkOffset = 0;
 36949:             }
 36949:         }
 36949: 
 36949:         return aBytesToRead - bytesLeft;
 36949:     }
 36949: 
 36949:     static unsigned long ReadEOTStream(void *aReadStream, void *outBuffer, 
 36949:                                        const unsigned long aBytesToRead) 
 36949:     {
 36949:         EOTFontStreamReader *eotReader = 
 36949:                                static_cast<EOTFontStreamReader*> (aReadStream);
 36949:         return eotReader->Read(outBuffer, aBytesToRead);
 36949:     }        
 36949:         
 36949: };
 36949: 
 36949: gfxFontEntry* 
 36949: gfxGDIFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry, 
108991:                                  const uint8_t *aFontData,
108991:                                  uint32_t aLength)
 36949: {
 36949:     // MakePlatformFont is responsible for deleting the font data with NS_Free
 36949:     // so we set up a stack object to ensure it is freed even if we take an
 36949:     // early exit
 36949:     struct FontDataDeleter {
108991:         FontDataDeleter(const uint8_t *aFontData)
 36949:             : mFontData(aFontData) { }
 36949:         ~FontDataDeleter() { NS_Free((void*)mFontData); }
108991:         const uint8_t *mFontData;
 36949:     };
 36949:     FontDataDeleter autoDelete(aFontData);
 36949: 
 79445:     bool hasVertical;
 79445:     bool isCFF = gfxFontUtils::IsCffFont(aFontData, hasVertical);
 36949: 
 36949:     nsresult rv;
106838:     HANDLE fontRef = nullptr;
 79445:     bool isEmbedded = false;
 36949: 
 36949:     nsAutoString uniqueName;
 36949:     rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
 36949:     if (NS_FAILED(rv))
106838:         return nullptr;
 36949: 
 93527:     // for TTF fonts, first try using the t2embed library if available
 93527:     if (!isCFF && TTLoadEmbeddedFontPtr && TTDeleteEmbeddedFontPtr) {
 36949:         // TrueType-style glyphs, use EOT library
108991:         AutoFallibleTArray<uint8_t,2048> eotHeader;
108991:         uint8_t *buffer;
108991:         uint32_t eotlen;
 36949: 
 80486:         isEmbedded = true;
108991:         uint32_t nameLen = NS_MIN<uint32_t>(uniqueName.Length(), LF_FACESIZE - 1);
 71730:         nsAutoString fontName(Substring(uniqueName, 0, nameLen));
 36949:         
 36949:         FontDataOverlay overlayNameData = {0, 0, 0};
 36949: 
 36949:         rv = gfxFontUtils::MakeEOTHeader(aFontData, aLength, &eotHeader, 
 36949:                                          &overlayNameData);
 47845:         if (NS_SUCCEEDED(rv)) {
 36949: 
 36949:             // load in embedded font data
 36949:             eotlen = eotHeader.Length();
108991:             buffer = reinterpret_cast<uint8_t*> (eotHeader.Elements());
 36949:             
108991:             int32_t ret;
 36949:             ULONG privStatus, pulStatus;
 36949:             EOTFontStreamReader eotReader(aFontData, aLength, buffer, eotlen,
 36949:                                           &overlayNameData);
 36949: 
 93527:             ret = TTLoadEmbeddedFontPtr(&fontRef, TTLOAD_PRIVATE, &privStatus,
 36949:                                         LICENSE_PREVIEWPRINT, &pulStatus,
 36949:                                         EOTFontStreamReader::ReadEOTStream,
 47845:                                         &eotReader,
 47845:                                         (PRUnichar*)(fontName.get()), 0, 0);
 47845:             if (ret != E_NONE) {
106838:                 fontRef = nullptr;
 47845:                 char buf[256];
 47845:                 sprintf(buf, "font (%s) not loaded using TTLoadEmbeddedFont - error %8.8x", NS_ConvertUTF16toUTF8(aProxyEntry->FamilyName()).get(), ret);
 47845:                 NS_WARNING(buf);
 47845:             }
 47845:         }
 36949:     }
 36949: 
 36949:     // load CFF fonts or fonts that failed with t2embed loader
106838:     if (fontRef == nullptr) {
 36949:         // Postscript-style glyphs, swizzle name table, load directly
108991:         FallibleTArray<uint8_t> newFontData;
 36949: 
 80486:         isEmbedded = false;
 36949:         rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
 36949: 
 36949:         if (NS_FAILED(rv))
106838:             return nullptr;
 36949:         
 36949:         DWORD numFonts = 0;
 36949: 
108991:         uint8_t *fontData = reinterpret_cast<uint8_t*> (newFontData.Elements());
108991:         uint32_t fontLength = newFontData.Length();
 36949:         NS_ASSERTION(fontData, "null font data after renaming");
 36949: 
 36949:         // http://msdn.microsoft.com/en-us/library/ms533942(VS.85).aspx
 36949:         // "A font that is added by AddFontMemResourceEx is always private 
 36949:         //  to the process that made the call and is not enumerable."
 36949:         fontRef = AddFontMemResourceEx(fontData, fontLength, 
 36949:                                        0 /* reserved */, &numFonts);
 36949:         if (!fontRef)
106838:             return nullptr;
 36949: 
 36949:         // only load fonts with a single face contained in the data
 63900:         // AddFontMemResourceEx generates an additional face name for
 63900:         // vertical text if the font supports vertical writing
 63900:         if (fontRef && numFonts != 1 + !!hasVertical) {
 36949:             RemoveFontMemResourceEx(fontRef);
106838:             return nullptr;
 36949:         }
 36949:     }
 36949: 
 36949:     // make a new font entry using the unique name
 47845:     WinUserFontData *winUserFontData = new WinUserFontData(fontRef, isEmbedded);
108991:     uint16_t w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
 36949: 
 36949:     GDIFontEntry *fe = GDIFontEntry::CreateFontEntry(uniqueName, 
 36949:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
108991:         uint32_t(aProxyEntry->mItalic ? NS_FONT_STYLE_ITALIC : NS_FONT_STYLE_NORMAL), 
103472:         w, aProxyEntry->mStretch, winUserFontData, false);
 36949: 
 36949:     if (!fe)
 36949:         return fe;
 36949: 
 80486:     fe->mIsUserFont = true;
 36949: 
 47845:     // Uniscribe doesn't place CFF fonts loaded privately 
 47845:     // via AddFontMemResourceEx on XP/Vista
 47845:     if (isCFF && gfxWindowsPlatform::WindowsOSVersion() 
 47845:                  < gfxWindowsPlatform::kWindows7) {
 80486:         fe->mForceGDI = true;
 47845:     }
 36949:  
 36949:     return fe;
 36949: }
 36949: 
 36949: gfxFontEntry*
 79445: gfxGDIFontList::GetDefaultFont(const gfxFontStyle* aStyle, bool& aNeedsBold)
 36949: {
 36949:     // this really shouldn't fail to find a font....
 36949:     HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
 36949:     LOGFONTW logFont;
 36949:     if (hGDI && ::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
 36949:         nsAutoString resolvedName;
 36949:         if (ResolveFontName(nsDependentString(logFont.lfFaceName), resolvedName)) {
 36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
 36949:         }
 36949:     }
 36949: 
 36949:     // ...but just in case, try another approach as well
 36949:     NONCLIENTMETRICSW ncm;
 36949:     ncm.cbSize = sizeof(ncm);
 36949:     BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
 36949:                                           sizeof(ncm), &ncm, 0);
 36949:     if (status) {
 36949:         nsAutoString resolvedName;
 36949:         if (ResolveFontName(nsDependentString(ncm.lfMessageFont.lfFaceName), resolvedName)) {
 36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
 36949:         }
 36949:     }
 36949: 
106838:     return nullptr;
 36949: }
 36949: 
 36949: 
 79445: bool 
 36949: gfxGDIFontList::ResolveFontName(const nsAString& aFontName, nsAString& aResolvedFontName)
 36949: {
 36949:     nsAutoString keyName(aFontName);
 36949:     BuildKeyNameFromFontName(keyName);
 36949: 
 94199:     gfxFontFamily *ff = mFontSubstitutes.GetWeak(keyName);
 94199:     if (ff) {
 36949:         aResolvedFontName = ff->Name();
 80486:         return true;
 36949:     }
 36949: 
 36949:     if (mNonExistingFonts.Contains(keyName))
 80486:         return false;
 36949: 
 36949:     if (gfxPlatformFontList::ResolveFontName(aFontName, aResolvedFontName))
 80486:         return true;
 36949: 
 80486:     return false;
 36949: }
 94199: 
 94199: void
 94199: gfxGDIFontList::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                     FontListSizes*    aSizes) const
 94199: {
 94199:     gfxPlatformFontList::SizeOfExcludingThis(aMallocSizeOf, aSizes);
 94199:     aSizes->mFontListSize +=
 94199:         mFontSubstitutes.SizeOfExcludingThis(SizeOfFamilyNameEntryExcludingThis,
 94199:                                              aMallocSizeOf);
 94199:     aSizes->mFontListSize +=
 94199:         mNonExistingFonts.SizeOfExcludingThis(aMallocSizeOf);
108991:     for (uint32_t i = 0; i < mNonExistingFonts.Length(); ++i) {
 94199:         aSizes->mFontListSize +=
 94199:             mNonExistingFonts[i].SizeOfExcludingThisIfUnshared(aMallocSizeOf);
 94199:     }
 94199: }
 94199: 
 94199: void
 94199: gfxGDIFontList::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 94199:                                     FontListSizes*    aSizes) const
 94199: {
 94199:     aSizes->mFontListSize += aMallocSizeOf(this);
 94199:     SizeOfExcludingThis(aMallocSizeOf, aSizes);
 94199: }
