37281: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
37281: /* ***** BEGIN LICENSE BLOCK *****
37281:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
37281:  *
37281:  * The contents of this file are subject to the Mozilla Public License Version
37281:  * 1.1 (the "License"); you may not use this file except in compliance with
37281:  * the License. You may obtain a copy of the License at
37281:  * http://www.mozilla.org/MPL/
37281:  *
37281:  * Software distributed under the License is distributed on an "AS IS" basis,
37281:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37281:  * for the specific language governing rights and limitations under the
37281:  * License.
37281:  *
37281:  * The Original Code is mozilla.org code.
37281:  *
37281:  * The Initial Developer of the Original Code is
60746:  * Mozilla Foundation.
37281:  * Portions created by the Initial Developer are Copyright (C) 2010
37281:  * the Initial Developer. All Rights Reserved.
37281:  *
37281:  * Contributor(s):
37281:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
37281:  *
37281:  * Alternatively, the contents of this file may be used under the terms of
37281:  * either of the GNU General Public License Version 2 or later (the "GPL"),
37281:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37281:  * in which case the provisions of the GPL or the LGPL are applicable instead
37281:  * of those above. If you wish to allow use of your version of this file only
37281:  * under the terms of either the GPL or the LGPL, and not to allow others to
37281:  * use your version of this file under the terms of the MPL, indicate your
37281:  * decision by deleting the provisions above and replace them with the notice
37281:  * and other provisions required by the GPL or the LGPL. If you do not delete
37281:  * the provisions above, a recipient may use your version of this file under
37281:  * the terms of any one of the MPL, the GPL or the LGPL.
37281:  *
37281:  * ***** END LICENSE BLOCK ***** */
37281: 
61649: #include "NotificationController.h"
37281: 
61649: #include "nsAccessibilityService.h"
41384: #include "nsAccUtils.h"
41384: #include "nsCoreUtils.h"
37537: #include "nsDocAccessible.h"
61649: #include "nsEventShell.h"
61649: #include "nsTextAccessible.h"
62125: #include "TextUpdater.h"
74131: #include "mozilla/dom/Element.h"
37282: 
60746: 
37339: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationCollector
37339: ////////////////////////////////////////////////////////////////////////////////
37339: 
60746: NotificationController::NotificationController(nsDocAccessible* aDocument,
60746:                                                nsIPresShell* aPresShell) :
60746:   mObservingState(eNotObservingRefresh), mDocument(aDocument),
75013:   mPresShell(aPresShell)
37282: {
61516:   mTextHash.Init();
61516: 
61152:   // Schedule initial accessible tree construction.
61152:   ScheduleProcessing();
37339: }
37339: 
60746: NotificationController::~NotificationController()
60746: {
60746:   NS_ASSERTION(!mDocument, "Controller wasn't shutdown properly!");
60746:   if (mDocument)
60746:     Shutdown();
60746: }
37339: 
60746: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationCollector: AddRef/Release and cycle collection
60746: 
60746: NS_IMPL_ADDREF(NotificationController)
60746: NS_IMPL_RELEASE(NotificationController)
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_CLASS(NotificationController)
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(NotificationController)
61729:   if (tmp->mDocument)
60746:     tmp->Shutdown();
60746: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(NotificationController)
60746:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mDocument");
60746:   cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mDocument.get()));
61317:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(mHangingChildDocuments,
61317:                                                     nsDocAccessible)
60746:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(mContentInsertions,
60746:                                                     ContentInsertion)
60746:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(mEvents, AccEvent)
60746: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(NotificationController, AddRef)
60746: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(NotificationController, Release)
60746: 
60746: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationCollector: public
60746: 
60746: void
60746: NotificationController::Shutdown()
60746: {
60746:   if (mObservingState != eNotObservingRefresh &&
60746:       mPresShell->RemoveRefreshObserver(this, Flush_Display)) {
60746:     mObservingState = eNotObservingRefresh;
60746:   }
60746: 
61317:   // Shutdown handling child documents.
61317:   PRInt32 childDocCount = mHangingChildDocuments.Length();
61317:   for (PRInt32 idx = childDocCount - 1; idx >= 0; idx--)
61317:     mHangingChildDocuments[idx]->Shutdown();
61317: 
61317:   mHangingChildDocuments.Clear();
61317: 
60746:   mDocument = nsnull;
60746:   mPresShell = nsnull;
61317: 
61516:   mTextHash.Clear();
60746:   mContentInsertions.Clear();
60746:   mNotifications.Clear();
60746:   mEvents.Clear();
37282: }
37281: 
37281: void
60746: NotificationController::QueueEvent(AccEvent* aEvent)
37281: {
60746:   if (!mEvents.AppendElement(aEvent))
37339:     return;
37339: 
37537:   // Filter events.
37537:   CoalesceEvents();
37537: 
47106:   // Associate text change with hide event if it wasn't stolen from hiding
47106:   // siblings during coalescence.
56292:   AccMutationEvent* showOrHideEvent = downcast_accEvent(aEvent);
56292:   if (showOrHideEvent && !showOrHideEvent->mTextChangeEvent)
56292:     CreateTextChangeEventFor(showOrHideEvent);
47106: 
60746:   ScheduleProcessing();
37537: }
37537: 
37537: void
61317: NotificationController::ScheduleChildDocBinding(nsDocAccessible* aDocument)
61317: {
61317:   // Schedule child document binding to the tree.
61317:   mHangingChildDocuments.AppendElement(aDocument);
61317:   ScheduleProcessing();
61317: }
61317: 
61317: void
60746: NotificationController::ScheduleContentInsertion(nsAccessible* aContainer,
60746:                                                  nsIContent* aStartChildNode,
60746:                                                  nsIContent* aEndChildNode)
37537: {
67625:   nsRefPtr<ContentInsertion> insertion = new ContentInsertion(mDocument,
67625:                                                               aContainer);
67625:   if (insertion && insertion->InitChildList(aStartChildNode, aEndChildNode) &&
67625:       mContentInsertions.AppendElement(insertion)) {
60746:     ScheduleProcessing();
37537:   }
67625: }
37537: 
37537: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationCollector: protected
37537: 
37537: void
60746: NotificationController::ScheduleProcessing()
37537: {
60746:   // If notification flush isn't planed yet start notification flush
60746:   // asynchronously (after style and layout).
60746:   if (mObservingState == eNotObservingRefresh) {
60746:     if (mPresShell->AddRefreshObserver(this, Flush_Display))
60746:       mObservingState = eRefreshObserving;
37537:   }
37537: }
37537: 
60746: bool
60746: NotificationController::IsUpdatePending()
60746: {
64531:   return mPresShell->IsLayoutFlushObserver() ||
60746:     mObservingState == eRefreshProcessingForUpdate ||
61637:     mContentInsertions.Length() != 0 || mNotifications.Length() != 0 ||
61637:     mTextHash.Count() != 0;
60746: }
60746: 
60746: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationCollector: private
60746: 
37537: void
60746: NotificationController::WillRefresh(mozilla::TimeStamp aTime)
37537: {
60746:   // If the document accessible that notification collector was created for is
60746:   // now shut down, don't process notifications anymore.
60746:   NS_ASSERTION(mDocument,
60746:                "The document was shut down while refresh observer is attached!");
37537:   if (!mDocument)
37537:     return;
37537: 
60746:   // Any generic notifications should be queued if we're processing content
60746:   // insertions or generic notifications.
60746:   mObservingState = eRefreshProcessingForUpdate;
60746: 
61152:   // Initial accessible tree construction.
75013:   if (!mDocument->HasLoadState(nsDocAccessible::eTreeConstructed)) {
61317:     // If document is not bound to parent at this point then the document is not
61317:     // ready yet (process notifications later).
61317:     if (!mDocument->IsBoundToParent())
61317:       return;
61317: 
61516: #ifdef DEBUG_NOTIFICATIONS
61516:     printf("\ninitial tree created, document: %p, document node: %p\n",
61516:            mDocument.get(), mDocument->GetDocumentNode());
61516: #endif
61516: 
75013:     mDocument->DoInitialUpdate();
61152: 
61152:     NS_ASSERTION(mContentInsertions.Length() == 0,
61152:                  "Pending content insertions while initial accessible tree isn't created!");
61152:   }
61152: 
60746:   // Process content inserted notifications to update the tree. Process other
60746:   // notifications like DOM events and then flush event queue. If any new
60746:   // notifications are queued during this processing then they will be processed
60746:   // on next refresh. If notification processing queues up new events then they
60746:   // are processed in this refresh. If events processing queues up new events
60746:   // then new events are processed on next refresh.
60746:   // Note: notification processing or event handling may shut down the owning
60746:   // document accessible.
60746: 
60746:   // Process only currently queued content inserted notifications.
60746:   nsTArray<nsRefPtr<ContentInsertion> > contentInsertions;
60746:   contentInsertions.SwapElements(mContentInsertions);
60746: 
60746:   PRUint32 insertionCount = contentInsertions.Length();
60746:   for (PRUint32 idx = 0; idx < insertionCount; idx++) {
60746:     contentInsertions[idx]->Process();
60746:     if (!mDocument)
60746:       return;
60746:   }
60746: 
61516:   // Process rendered text change notifications.
61516:   mTextHash.EnumerateEntries(TextEnumerator, mDocument);
61516:   mTextHash.Clear();
61516: 
61317:   // Bind hanging child documents.
75013:   PRUint32 hangingDocCnt = mHangingChildDocuments.Length();
75013:   for (PRUint32 idx = 0; idx < hangingDocCnt; idx++) {
61317:     nsDocAccessible* childDoc = mHangingChildDocuments[idx];
61317: 
61317:     nsIContent* ownerContent = mDocument->GetDocumentNode()->
61317:       FindContentForSubDocument(childDoc->GetDocumentNode());
61317:     if (ownerContent) {
61461:       nsAccessible* outerDocAcc = mDocument->GetAccessible(ownerContent);
61317:       if (outerDocAcc && outerDocAcc->AppendChild(childDoc)) {
74015:         if (mDocument->AppendChildDocument(childDoc))
74015:           continue;
61317: 
61317:         outerDocAcc->RemoveChild(childDoc);
61317:       }
61317: 
61317:       // Failed to bind the child document, destroy it.
61317:       childDoc->Shutdown();
61317:     }
61317:   }
61317:   mHangingChildDocuments.Clear();
61317: 
75013:   // If the document is ready and all its subdocuments are completely loaded
75013:   // then process the document load.
75013:   if (mDocument->HasLoadState(nsDocAccessible::eReady) &&
75013:       !mDocument->HasLoadState(nsDocAccessible::eCompletelyLoaded) &&
75013:       hangingDocCnt == 0) {
75013:     PRUint32 childDocCnt = mDocument->ChildDocumentCount(), childDocIdx = 0;
75013:     for (; childDocIdx < childDocCnt; childDocIdx++) {
75013:       nsDocAccessible* childDoc = mDocument->GetChildDocumentAt(childDocIdx);
75013:       if (!childDoc->HasLoadState(nsDocAccessible::eCompletelyLoaded))
75013:         break;
75013:     }
75013: 
75013:     if (childDocIdx == childDocCnt) {
75013:       mDocument->ProcessLoad();
75013:       if (!mDocument)
75013:         return;
75013:     }
75013:   }
75013: 
60746:   // Process only currently queued generic notifications.
60746:   nsTArray < nsRefPtr<Notification> > notifications;
60746:   notifications.SwapElements(mNotifications);
60746: 
60746:   PRUint32 notificationCount = notifications.Length();
60746:   for (PRUint32 idx = 0; idx < notificationCount; idx++) {
60746:     notifications[idx]->Process();
60746:     if (!mDocument)
60746:       return;
60746:   }
60746: 
74257:   // Process invalidation list of the document after all accessible tree
74257:   // modification are done.
74257:   mDocument->ProcessInvalidationList();
74257: 
60746:   // If a generic notification occurs after this point then we may be allowed to
60746:   // process it synchronously.
60746:   mObservingState = eRefreshObserving;
60746: 
60746:   // Process only currently queued events.
51377:   nsTArray<nsRefPtr<AccEvent> > events;
43800:   events.SwapElements(mEvents);
37537: 
60746:   PRUint32 eventCount = events.Length();
60746:   for (PRUint32 idx = 0; idx < eventCount; idx++) {
60746:     AccEvent* accEvent = events[idx];
51377:     if (accEvent->mEventRule != AccEvent::eDoNotEmit) {
46341:       mDocument->ProcessPendingEvent(accEvent);
46341: 
64006:       AccMutationEvent* showOrHideEvent = downcast_accEvent(accEvent);
64006:       if (showOrHideEvent) {
64006:         if (showOrHideEvent->mTextChangeEvent)
64006:           mDocument->ProcessPendingEvent(showOrHideEvent->mTextChangeEvent);
47106:       }
47106:     }
46342:     if (!mDocument)
46341:       return;
37537:   }
37537: 
75013:   // Stop further processing if there are no new notifications of any kind or
75013:   // events and document load is processed.
60746:   if (mContentInsertions.Length() == 0 && mNotifications.Length() == 0 &&
75013:       mEvents.Length() == 0 && mTextHash.Count() == 0 &&
75013:       mHangingChildDocuments.Length() == 0 &&
75013:       mDocument->HasLoadState(nsDocAccessible::eCompletelyLoaded) &&
60746:       mPresShell->RemoveRefreshObserver(this, Flush_Display)) {
60746:     mObservingState = eNotObservingRefresh;
37537:   }
37537: }
37537: 
60746: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationController: event queue
60746: 
37537: void
60746: NotificationController::CoalesceEvents()
37537: {
37537:   PRUint32 numQueuedEvents = mEvents.Length();
37537:   PRInt32 tail = numQueuedEvents - 1;
51377:   AccEvent* tailEvent = mEvents[tail];
37537: 
43383:   // No node means this is application accessible (which can be a subject
43383:   // of reorder events), we do not coalesce events for it currently.
43383:   if (!tailEvent->mNode)
43383:     return;
43383: 
37537:   switch(tailEvent->mEventRule) {
51377:     case AccEvent::eCoalesceFromSameSubtree:
37537:     {
43800:       for (PRInt32 index = tail - 1; index >= 0; index--) {
51377:         AccEvent* thisEvent = mEvents[index];
43383: 
37537:         if (thisEvent->mEventType != tailEvent->mEventType)
37537:           continue; // Different type
37537: 
43383:         // Skip event for application accessible since no coalescence for it
47106:         // is supported. Ignore events from different documents since we don't
47106:         // coalesce them.
47106:         if (!thisEvent->mNode ||
43383:             thisEvent->mNode->GetOwnerDoc() != tailEvent->mNode->GetOwnerDoc())
43383:           continue;
43383: 
60746:         // Coalesce earlier event for the same target.
60746:         if (thisEvent->mNode == tailEvent->mNode) {
60746:           thisEvent->mEventRule = AccEvent::eDoNotEmit;
60746:           return;
60746:         }
60746: 
43383:         // If event queue contains an event of the same type and having target
43383:         // that is sibling of target of newly appended event then apply its
43383:         // event rule to the newly appended event.
47106: 
56292:         // Coalesce hide and show events for sibling targets.
47106:         if (tailEvent->mEventType == nsIAccessibleEvent::EVENT_HIDE) {
47106:           AccHideEvent* tailHideEvent = downcast_accEvent(tailEvent);
47106:           AccHideEvent* thisHideEvent = downcast_accEvent(thisEvent);
47106:           if (thisHideEvent->mParent == tailHideEvent->mParent) {
47106:             tailEvent->mEventRule = thisEvent->mEventRule;
47106: 
47106:             // Coalesce text change events for hide events.
51377:             if (tailEvent->mEventRule != AccEvent::eDoNotEmit)
47106:               CoalesceTextChangeEventsFor(tailHideEvent, thisHideEvent);
47106: 
47106:             return;
47106:           }
56292:         } else if (tailEvent->mEventType == nsIAccessibleEvent::EVENT_SHOW) {
74545:           if (thisEvent->mAccessible->Parent() ==
74545:               tailEvent->mAccessible->Parent()) {
56292:             tailEvent->mEventRule = thisEvent->mEventRule;
56292: 
56292:             // Coalesce text change events for show events.
56292:             if (tailEvent->mEventRule != AccEvent::eDoNotEmit) {
56292:               AccShowEvent* tailShowEvent = downcast_accEvent(tailEvent);
56292:               AccShowEvent* thisShowEvent = downcast_accEvent(thisEvent);
56292:               CoalesceTextChangeEventsFor(tailShowEvent, thisShowEvent);
56292:             }
56292: 
56292:             return;
56292:           }
47106:         }
47106: 
47106:         // Ignore events unattached from DOM since we don't coalesce them.
47106:         if (!thisEvent->mNode->IsInDoc())
47106:           continue;
47106: 
56292:         // Coalesce events by sibling targets (this is a case for reorder
56292:         // events).
43383:         if (thisEvent->mNode->GetNodeParent() ==
43383:             tailEvent->mNode->GetNodeParent()) {
43383:           tailEvent->mEventRule = thisEvent->mEventRule;
43383:           return;
43383:         }
43383: 
43383:         // This and tail events can be anywhere in the tree, make assumptions
43383:         // for mutation events.
43383: 
43383:         // Coalesce tail event if tail node is descendant of this node. Stop
43383:         // processing if tail event is coalesced since all possible descendants
43383:         // of this node was coalesced before.
43383:         // Note: more older hide event target (thisNode) can't contain recent
43383:         // hide event target (tailNode), i.e. be ancestor of tailNode. Skip
43383:         // this check for hide events.
43383:         if (tailEvent->mEventType != nsIAccessibleEvent::EVENT_HIDE &&
43383:             nsCoreUtils::IsAncestorOf(thisEvent->mNode, tailEvent->mNode)) {
51377:           tailEvent->mEventRule = AccEvent::eDoNotEmit;
43383:           return;
43383:         }
43383: 
43383:         // If this node is a descendant of tail node then coalesce this event,
56292:         // check other events in the queue. Do not emit thisEvent, also apply
56292:         // this result to sibling nodes of thisNode.
56292:         if (nsCoreUtils::IsAncestorOf(tailEvent->mNode, thisEvent->mNode)) {
51377:           thisEvent->mEventRule = AccEvent::eDoNotEmit;
43800:           ApplyToSiblings(0, index, thisEvent->mEventType,
51377:                           thisEvent->mNode, AccEvent::eDoNotEmit);
37537:           continue;
37537:         }
37540: 
37537:       } // for (index)
37537: 
37537:     } break; // case eCoalesceFromSameSubtree
37537: 
51377:     case AccEvent::eCoalesceFromSameDocument:
39509:     {
43383:       // Used for focus event, coalesce more older event since focus event
43383:       // for accessible can be duplicated by event for its document, we are
43383:       // interested in focus event for accessible.
43800:       for (PRInt32 index = tail - 1; index >= 0; index--) {
51377:         AccEvent* thisEvent = mEvents[index];
39509:         if (thisEvent->mEventType == tailEvent->mEventType &&
39509:             thisEvent->mEventRule == tailEvent->mEventRule &&
39509:             thisEvent->GetDocAccessible() == tailEvent->GetDocAccessible()) {
51377:           thisEvent->mEventRule = AccEvent::eDoNotEmit;
43383:           return;
39509:         }
39509:       }
39509:     } break; // case eCoalesceFromSameDocument
39509: 
51377:     case AccEvent::eRemoveDupes:
37537:     {
43383:       // Check for repeat events, coalesce newly appended event by more older
43383:       // event.
43800:       for (PRInt32 index = tail - 1; index >= 0; index--) {
51377:         AccEvent* accEvent = mEvents[index];
37537:         if (accEvent->mEventType == tailEvent->mEventType &&
37537:             accEvent->mEventRule == tailEvent->mEventRule &&
37539:             accEvent->mNode == tailEvent->mNode) {
51377:           tailEvent->mEventRule = AccEvent::eDoNotEmit;
43383:           return;
37537:         }
37537:       }
37537:     } break; // case eRemoveDupes
37537: 
37537:     default:
37537:       break; // case eAllowDupes, eDoNotEmit
37537:   } // switch
37537: }
37537: 
37537: void
60746: NotificationController::ApplyToSiblings(PRUint32 aStart, PRUint32 aEnd,
37539:                                         PRUint32 aEventType, nsINode* aNode,
51377:                                         AccEvent::EEventRule aEventRule)
37537: {
37537:   for (PRUint32 index = aStart; index < aEnd; index ++) {
51377:     AccEvent* accEvent = mEvents[index];
37537:     if (accEvent->mEventType == aEventType &&
55773:         accEvent->mEventRule != AccEvent::eDoNotEmit && accEvent->mNode &&
43383:         accEvent->mNode->GetNodeParent() == aNode->GetNodeParent()) {
37537:       accEvent->mEventRule = aEventRule;
37537:     }
37537:   }
37537: }
37537: 
37537: void
60746: NotificationController::CoalesceTextChangeEventsFor(AccHideEvent* aTailEvent,
47106:                                                     AccHideEvent* aThisEvent)
47106: {
47106:   // XXX: we need a way to ignore SplitNode and JoinNode() when they do not
47106:   // affect the text within the hypertext.
47106: 
51377:   AccTextChangeEvent* textEvent = aThisEvent->mTextChangeEvent;
47106:   if (!textEvent)
47106:     return;
47106: 
47106:   if (aThisEvent->mNextSibling == aTailEvent->mAccessible) {
61682:     aTailEvent->mAccessible->AppendTextTo(textEvent->mModifiedText);
47106: 
47106:   } else if (aThisEvent->mPrevSibling == aTailEvent->mAccessible) {
47106:     PRUint32 oldLen = textEvent->GetLength();
61682:     aTailEvent->mAccessible->AppendTextTo(textEvent->mModifiedText);
47106:     textEvent->mStart -= textEvent->GetLength() - oldLen;
47106:   }
47106: 
47106:   aTailEvent->mTextChangeEvent.swap(aThisEvent->mTextChangeEvent);
47106: }
47106: 
47106: void
60746: NotificationController::CoalesceTextChangeEventsFor(AccShowEvent* aTailEvent,
56292:                                                     AccShowEvent* aThisEvent)
56292: {
56292:   AccTextChangeEvent* textEvent = aThisEvent->mTextChangeEvent;
56292:   if (!textEvent)
56292:     return;
56292: 
72476:   if (aTailEvent->mAccessible->IndexInParent() ==
72476:       aThisEvent->mAccessible->IndexInParent() + 1) {
56292:     // If tail target was inserted after this target, i.e. tail target is next
56292:     // sibling of this target.
61682:     aTailEvent->mAccessible->AppendTextTo(textEvent->mModifiedText);
56292: 
72476:   } else if (aTailEvent->mAccessible->IndexInParent() ==
72476:              aThisEvent->mAccessible->IndexInParent() -1) {
56292:     // If tail target was inserted before this target, i.e. tail target is
56292:     // previous sibling of this target.
56292:     nsAutoString startText;
61682:     aTailEvent->mAccessible->AppendTextTo(startText);
56292:     textEvent->mModifiedText = startText + textEvent->mModifiedText;
56292:     textEvent->mStart -= startText.Length();
56292:   }
56292: 
56292:   aTailEvent->mTextChangeEvent.swap(aThisEvent->mTextChangeEvent);
56292: }
56292: 
56292: void
60746: NotificationController::CreateTextChangeEventFor(AccMutationEvent* aEvent)
47106: {
61468:   nsAccessible* container =
47106:     GetAccService()->GetContainerAccessible(aEvent->mNode,
61468:                                             aEvent->mAccessible->GetWeakShell());
61468:   if (!container)
61468:     return;
61468: 
61468:   nsHyperTextAccessible* textAccessible = container->AsHyperText();
47106:   if (!textAccessible)
47106:     return;
47106: 
47106:   // Don't fire event for the first html:br in an editor.
52089:   if (aEvent->mAccessible->Role() == nsIAccessibleRole::ROLE_WHITESPACE) {
47106:     nsCOMPtr<nsIEditor> editor;
47106:     textAccessible->GetAssociatedEditor(getter_AddRefs(editor));
47106:     if (editor) {
47106:       PRBool isEmpty = PR_FALSE;
47106:       editor->GetDocumentIsEmpty(&isEmpty);
47106:       if (isEmpty)
47106:         return;
47106:     }
47106:   }
47106: 
47107:   PRInt32 offset = textAccessible->GetChildOffset(aEvent->mAccessible);
47107: 
47106:   nsAutoString text;
61682:   aEvent->mAccessible->AppendTextTo(text);
47106:   if (text.IsEmpty())
47106:     return;
47106: 
47106:   aEvent->mTextChangeEvent =
56292:     new AccTextChangeEvent(textAccessible, offset, text, aEvent->IsShow(),
47106:                            aEvent->mIsFromUserInput ? eFromUserInput : eNoUserInput);
47106: }
60746: 
61649: ////////////////////////////////////////////////////////////////////////////////
61649: // Notification controller: text leaf accessible text update
61649: 
61516: PLDHashOperator
61648: NotificationController::TextEnumerator(nsCOMPtrHashKey<nsIContent>* aEntry,
61516:                                        void* aUserArg)
61516: {
61516:   nsDocAccessible* document = static_cast<nsDocAccessible*>(aUserArg);
61516:   nsIContent* textNode = aEntry->GetKey();
61516:   nsAccessible* textAcc = document->GetAccessible(textNode);
61516: 
61516:   // If the text node is not in tree or doesn't have frame then this case should
61516:   // have been handled already by content removal notifications.
61516:   nsINode* containerNode = textNode->GetNodeParent();
61516:   if (!containerNode) {
61516:     NS_ASSERTION(!textAcc,
61516:                  "Text node was removed but accessible is kept alive!");
61516:     return PL_DHASH_NEXT;
61516:   }
61516: 
61516:   nsIFrame* textFrame = textNode->GetPrimaryFrame();
61516:   if (!textFrame) {
61516:     NS_ASSERTION(!textAcc,
61516:                  "Text node isn't rendered but accessible is kept alive!");
61516:     return PL_DHASH_NEXT;
61516:   }
61516: 
61516:   nsIContent* containerElm = containerNode->IsElement() ?
61516:     containerNode->AsElement() : nsnull;
61516: 
61649:   nsAutoString text;
61649:   textFrame->GetRenderedText(&text);
61516: 
61516:   // Remove text accessible if rendered text is empty.
61516:   if (textAcc) {
61649:     if (text.IsEmpty()) {
61516: #ifdef DEBUG_NOTIFICATIONS
61516:       PRUint32 index = containerNode->IndexOf(textNode);
61516: 
61516:       nsCAutoString tag;
61516:       nsCAutoString id;
61516:       if (containerElm) {
61516:         containerElm->Tag()->ToUTF8String(tag);
61516:         nsIAtom* atomid = containerElm->GetID();
61516:         if (atomid)
61516:           atomid->ToUTF8String(id);
61516:       }
61516: 
61516:       printf("\npending text node removal: container: %s@id='%s', index in container: %d\n\n",
61516:              tag.get(), id.get(), index);
61516: #endif
61516: 
61516:       document->ContentRemoved(containerElm, textNode);
61649:       return PL_DHASH_NEXT;
61516:     }
61516: 
61649:     // Update text of the accessible and fire text change events.
61649: #ifdef DEBUG_TEXTCHANGE
61649:       PRUint32 index = containerNode->IndexOf(textNode);
61649: 
61649:       nsCAutoString tag;
61649:       nsCAutoString id;
61649:       if (containerElm) {
61649:         containerElm->Tag()->ToUTF8String(tag);
61649:         nsIAtom* atomid = containerElm->GetID();
61649:         if (atomid)
61649:           atomid->ToUTF8String(id);
61649:       }
61649: 
61649:       printf("\ntext may be changed: container: %s@id='%s', index in container: %d, old text '%s', new text: '%s'\n\n",
61649:              tag.get(), id.get(), index,
61649:              NS_ConvertUTF16toUTF8(textAcc->AsTextLeaf()->Text()).get(),
61649:              NS_ConvertUTF16toUTF8(text).get());
61649: #endif
61649: 
62125:     TextUpdater::Run(document, textAcc->AsTextLeaf(), text);
61516:     return PL_DHASH_NEXT;
61516:   }
61516: 
61516:   // Append an accessible if rendered text is not empty.
61649:   if (!text.IsEmpty()) {
61516: #ifdef DEBUG_NOTIFICATIONS
61516:       PRUint32 index = containerNode->IndexOf(textNode);
61516: 
61516:       nsCAutoString tag;
61516:       nsCAutoString id;
61516:       if (containerElm) {
61516:         containerElm->Tag()->ToUTF8String(tag);
61516:         nsIAtom* atomid = containerElm->GetID();
61516:         if (atomid)
61516:           atomid->ToUTF8String(id);
61516:       }
61516: 
61516:       printf("\npending text node insertion: container: %s@id='%s', index in container: %d\n\n",
61516:              tag.get(), id.get(), index);
61516: #endif
61516: 
77683:     // Make sure the text node is in accessible document still.
61516:     nsAccessible* container = document->GetAccessibleOrContainer(containerNode);
77683:     NS_ASSERTION(container,
77683:                  "Text node having rendered text hasn't accessible document!");
77683:     if (container) {
61516:       nsTArray<nsCOMPtr<nsIContent> > insertedContents;
61516:       insertedContents.AppendElement(textNode);
61516:       document->ProcessContentInserted(container, &insertedContents);
61516:     }
77683:   }
61516: 
61516:   return PL_DHASH_NEXT;
61516: }
61516: 
61516: 
60746: ////////////////////////////////////////////////////////////////////////////////
60746: // NotificationController: content inserted notification
60746: 
60746: NotificationController::ContentInsertion::
67625:   ContentInsertion(nsDocAccessible* aDocument, nsAccessible* aContainer) :
60746:   mDocument(aDocument), mContainer(aContainer)
60746: {
67625: }
67625: 
67625: bool
67625: NotificationController::ContentInsertion::
67625:   InitChildList(nsIContent* aStartChildNode, nsIContent* aEndChildNode)
67625: {
67625:   bool haveToUpdate = false;
67625: 
60746:   nsIContent* node = aStartChildNode;
60746:   while (node != aEndChildNode) {
67625:     // Notification triggers for content insertion even if no content was
67625:     // actually inserted, check if the given content has a frame to discard
67625:     // this case early.
67625:     if (node->GetPrimaryFrame()) {
67625:       if (mInsertedContent.AppendElement(node))
67625:         haveToUpdate = true;
67625:     }
67625: 
60746:     node = node->GetNextSibling();
60746:   }
67625: 
67625:   return haveToUpdate;
60746: }
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_CLASS(NotificationController::ContentInsertion)
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(NotificationController::ContentInsertion)
60746:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContainer)
60746: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(NotificationController::ContentInsertion)
60746:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mContainer");
60746:   cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mContainer.get()));
60746: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
60746: 
60746: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(NotificationController::ContentInsertion,
60746:                                      AddRef)
60746: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(NotificationController::ContentInsertion,
60746:                                        Release)
60746: 
60746: void
60746: NotificationController::ContentInsertion::Process()
60746: {
60746: #ifdef DEBUG_NOTIFICATIONS
60746:   nsIContent* firstChildNode = mInsertedContent[0];
60746: 
60746:   nsCAutoString tag;
60746:   firstChildNode->Tag()->ToUTF8String(tag);
60746: 
60746:   nsIAtom* atomid = firstChildNode->GetID();
60746:   nsCAutoString id;
60746:   if (atomid)
60746:     atomid->ToUTF8String(id);
60746: 
60746:   nsCAutoString ctag;
60746:   nsCAutoString cid;
60746:   nsIAtom* catomid = nsnull;
60746:   if (mContainer->IsContent()) {
60746:     mContainer->GetContent()->Tag()->ToUTF8String(ctag);
60746:     catomid = mContainer->GetContent()->GetID();
60746:     if (catomid)
60746:       catomid->ToUTF8String(cid);
60746:   }
60746: 
61516:   printf("\npending content insertion: %s@id='%s', container: %s@id='%s', inserted content amount: %d\n\n",
60746:          tag.get(), id.get(), ctag.get(), cid.get(), mInsertedContent.Length());
60746: #endif
60746: 
60746:   mDocument->ProcessContentInserted(mContainer, &mInsertedContent);
60746: 
60746:   mDocument = nsnull;
60746:   mContainer = nsnull;
60746:   mInsertedContent.Clear();
60746: }
61649: 
