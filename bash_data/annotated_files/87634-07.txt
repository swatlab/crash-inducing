30147: // In each list of tests below, test file types that are not supported should
30147: // be ignored. To make sure tests respect that, we include a file of type
30147: // "bogus/duh" in each list.
30147: 
33870: // These are small test files, good for just seeing if something loads. We
33870: // really only need one test file per backend here.
30146: var gSmallTests = [
87634:   { name:"small-shot.ogg", type:"audio/ogg", duration:0.276 },
30146:   { name:"r11025_s16_c1.wav", type:"audio/x-wav", duration:1.0 },
42935:   { name:"320x240.ogv", type:"video/ogg", width:320, height:240, duration:0.233 },
47959:   { name:"seek.webm", type:"video/webm", duration:3.966 },
42935:   { name:"bogus.duh", type:"bogus/duh" }
42935: ];
42935: 
42935: // Used by test_progress to ensure we get the correct progress information
42935: // during resource download.
42935: var gProgressTests = [
42935:   { name:"r11025_u8_c1.wav", type:"audio/x-wav", duration:1.0, size:11069 },
42935:   { name:"big.wav", type:"audio/x-wav", duration:9.0, size:102444 },
42935:   { name:"seek.ogv", type:"video/ogg", duration:3.966, size:285310 },
42935:   { name:"320x240.ogv", type:"video/ogg", width:320, height:240, duration:0.233, size:28942 },
47959:   { name:"seek.webm", type:"video/webm", duration:3.966, size:215529 },
32145:   { name:"bogus.duh", type:"bogus/duh" }
30146: ];
30147: 
33873: // Used by test_mozLoadFrom.  Need one test file per decoder backend, plus
33873: // anything for testing clone-specific bugs.
82746: var cloneKey = Math.floor(Math.random()*100000000);
33873: var gCloneTests = gSmallTests.concat([
37543:   // Actual duration is ~200ms, we have Content-Duration lie about it.
33873:   { name:"bug520908.ogv", type:"video/ogg", duration:9000 },
82746:   // short-video is more like 1s, so if you load this twice you'll get an unexpected duration
82746:   { name:"dynamic_resource.sjs?key=" + cloneKey + "&res1=320x240.ogv&res2=short-video.ogv",
82746:     type:"video/ogg", duration:0.233 },
33873: ]);
33873: 
37973: // Used by test_play_twice.  Need one test file per decoder backend, plus
37973: // anything for testing bugs that occur when replying a played file.
37973: var gReplayTests = gSmallTests.concat([
37973:   { name:"bug533822.ogg", type:"audio/ogg" },
37973: ]);
37973: 
42935: // Used by test_paused_after_ended. Need one test file per decoder backend, plus
42935: // anything for testing bugs that occur when replying a played file.
42935: var gPausedAfterEndedTests = gSmallTests.concat([
42935:   { name:"r11025_u8_c1.wav", type:"audio/x-wav", duration:1.0 },
42935:   { name:"small-shot.ogg", type:"video/ogg", duration:0.276 }
42935: ]);
42935: 
33870: // These are files that we want to make sure we can play through.  We can
33447: // also check metadata.  Put files of the same type together in this list so if
33447: // something crashes we have some idea of which backend is responsible.
33870: // Used by test_playback, which expects no error event and one ended event.
30147: var gPlayTests = [
30149:   // 8-bit samples
30149:   { name:"r11025_u8_c1.wav", type:"audio/x-wav", duration:1.0 },
30149:   // 8-bit samples, file is truncated
30147:   { name:"r11025_u8_c1_trunc.wav", type:"audio/x-wav", duration:1.8 },
30147:   // file has trailing non-PCM data
30147:   { name:"r11025_s16_c1_trailing.wav", type:"audio/x-wav", duration:1.0 },
30147:   // file with list chunk
30147:   { name:"r16000_u8_c1_list.wav", type:"audio/x-wav", duration:4.2 },
33870: 
42254:   // Ogg stream without eof marker
42935:   { name:"bug461281.ogg", type:"application/ogg", duration:2.208 },
42254: 
30147:   // oggz-chop stream
40132:   { name:"bug482461.ogv", type:"video/ogg", duration:4.34 },
62888:   // Theora only oggz-chop stream
62888:   { name:"bug482461-theora.ogv", type:"video/ogg", duration:4.138 },
31111:   // With first frame a "duplicate" (empty) frame.
31111:   { name:"bug500311.ogv", type:"video/ogg", duration:1.96 },
31108:   // Small audio file
42935:   { name:"small-shot.ogg", type:"video/ogg", duration:0.276 },
31597:   // More audio in file than video.
31597:   { name:"short-video.ogv", type:"video/ogg", duration:1.081 },
32932:   // First Theora data packet is zero bytes.
42935:   { name:"bug504613.ogv", type:"video/ogg", duration:Number.NaN },
33256:   // Multiple audio streams.
40132:   { name:"bug516323.ogv", type:"video/ogg", duration:4.208 },
63854:   // oggz-chop with non-keyframe as first frame
63854:   { name:"bug556821.ogv", type:"video/ogg", duration:2.551 },
40132: 
33447:   // Encoded with vorbis beta1, includes unusually sized codebooks
40132:   { name:"beta-phrasebook.ogg", type:"audio/ogg", duration:4.01 },
33825:   // Small file, only 1 frame with audio only.
33825:   { name:"bug520493.ogg", type:"audio/ogg", duration:0.458 },
33826:   // Small file with vorbis comments with 0 length values and names.
33826:   { name:"bug520500.ogg", type:"audio/ogg", duration:0.123 },
31108: 
33870:   // Various weirdly formed Ogg files
33870:   { name:"bug499519.ogv", type:"video/ogg", duration:0.24 },
33870:   { name:"bug506094.ogv", type:"video/ogg", duration:0 },
40132:   { name:"bug498855-1.ogv", type:"video/ogg", duration:0.24 },
40132:   { name:"bug498855-2.ogv", type:"video/ogg", duration:0.24 },
40132:   { name:"bug498855-3.ogv", type:"video/ogg", duration:0.24 },
40132:   { name:"bug504644.ogv", type:"video/ogg", duration:1.6 },
33870:   { name:"chain.ogv", type:"video/ogg", duration:Number.NaN },
40132:   { name:"bug523816.ogv", type:"video/ogg", duration:0.533 },
40132:   { name:"bug495129.ogv", type:"video/ogg", duration:2.41 },
42935:   { name:"bug498380.ogv", type:"video/ogg", duration:0.533 },
40132:   { name:"bug495794.ogg", type:"audio/ogg", duration:0.3 },
40583:   { name:"bug557094.ogv", type:"video/ogg", duration:0.24 },
74885:   { name:"multiple-bos.ogg", type:"video/ogg", duration:0.431 },
40132:   { name:"audio-overhang.ogg", type:"audio/ogg", duration:2.3 },
40132:   { name:"video-overhang.ogg", type:"audio/ogg", duration:3.966 },
33870: 
50359:   // bug461281.ogg with the middle second chopped out.
50359:   { name:"audio-gaps.ogg", type:"audio/ogg", duration:2.208 },
50359: 
41190:   // Test playback/metadata work after a redirect
42935:   { name:"redirect.sjs?domain=mochi.test:8888&file=320x240.ogv",
41190:     type:"video/ogg", duration:0.233 },
41190: 
43341:   // Test playback of a webm file
43341:   { name:"seek.webm", type:"video/webm", duration:3.966 },
43341: 
54994:   // Test playback of a WebM file with non-zero start time.
54994:   { name:"split.webm", type:"video/webm", duration:1.967 },
54994:   
48220:   // Test playback of a raw file
48220:   { name:"seek.yuv", type:"video/x-raw-yuv", duration:1.833 },
48220:   
59468:   // A really short, low sample rate, single channel file. This tests whether
59468:   // we can handle playing files when only push very little audio data to the
59468:   // hardware.
59468:   { name:"spacestorm-1000Hz-100ms.ogg", type:"audio/ogg", duration:0.099 },
59468: 
42935:   { name:"bogus.duh", type:"bogus/duh", duration:Number.NaN }
42935: ];
42935: 
42935: // Converts a path/filename to a file:// URI which we can load from disk.
42935: // Optionally checks whether the file actually exists on disk at the location
42935: // we've specified.
42935: function fileUriToSrc(path, mustExist) {
42935:   netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
42935:   const Ci = Components.interfaces;
42935:   const Cc = Components.classes;
42935:   const Cr = Components.results;
42935:   var dirSvc = Cc["@mozilla.org/file/directory_service;1"].
42935:                getService(Ci.nsIProperties);
42935:   var f = dirSvc.get("CurWorkD", Ci.nsILocalFile);
42935:   var split = path.split("/");
42935:   for(var i = 0; i < split.length; ++i) {
42935:     f.append(split[i]);
42935:   }
42935:   if (mustExist && !f.exists()) {
42935:     ok(false, "We expected '" + path + "' to exist, but it doesn't!");
42935:   }
42935:   return f.path;
42935: }
42935: 
75108: // Returns true if two nsTimeRanges are equal, false otherwise
75108: function range_equals(r1, r2) {
75108:   if (r1.length != r2.length) {
75108:     return false;
75108:   }
75108:   for (var i = 0; i < r1.length; i++) {
75108:     if (r1.start(i) != r2.start(i) || r1.end(i) != r2.end(i)) {
75108:       return false;
75108:     }
75108:   }
75108:   return true;
75108: }
75108: 
42935: // These are URIs to files that we use to check that we don't leak any state
42935: // or other information such that script can determine stuff about a user's
42935: // environment. Used by test_info_leak.
42935: var gInfoLeakTests = [
42935:   {
42935:     type: 'video/ogg',
42935:     src: fileUriToSrc("tests/content/media/test/320x240.ogv", true),
42935:   },{
42935:     type: 'video/ogg',
42935:     src: fileUriToSrc("tests/content/media/test/404.ogv", false),
42935:   }, {
42935:     type: 'audio/x-wav',
42935:     src: fileUriToSrc("tests/content/media/test/r11025_s16_c1.wav", true),
42935:   }, {
42935:     type: 'audio/x-wav',
42935:     src: fileUriToSrc("tests/content/media/test/404.wav", false),
42935:   }, {
42935:     type: 'audio/ogg',
42935:     src: fileUriToSrc("tests/content/media/test/bug461281.ogg", true),
42935:   }, {
42935:     type: 'audio/ogg',
42935:     src: fileUriToSrc("tests/content/media/test/404.ogg", false),
42935:   }, {
47959:     type: 'video/webm',
47959:     src: fileUriToSrc("tests/content/media/test/seek.webm", true),
47959:   }, {
47959:     type: 'video/webm',
47959:     src: fileUriToSrc("tests/content/media/test/404.webm", false),
47959:   }, {
42935:     type: 'video/ogg',
42935:     src: 'http://localhost/404.ogv',
42935:   }, {
42935:     type: 'audio/x-wav',
42935:     src: 'http://localhost/404.wav',
42935:   }, {
47959:     type: 'video/webm',
47959:     src: 'http://localhost/404.webm',
47959:   }, {
42935:     type: 'video/ogg',
42935:     src: 'http://example.com/tests/content/media/test/test_info_leak.html'
42935:   }, {
42935:     type: 'audio/ogg',
42935:     src: 'http://example.com/tests/content/media/test/test_info_leak.html'
42935:   }
30147: ];
30147: 
33447: // These are files that must fire an error during load or playback, and do not
33447: // cause a crash.  Put files of the same type together in this list so if
33447: // something crashes we have some idea of which backend is responsible.  Used
33447: // by test_playback_errors, which expects one error event and no ended event.
30147: // Put files of the same type together in this list so if something crashes
30147: // we have some idea of which backend is responsible.
30147: var gErrorTests = [
30147:   { name:"bogus.wav", type:"audio/x-wav" },
30147:   { name:"bogus.ogv", type:"video/ogg" },
31105:   { name:"448636.ogv", type:"video/ogg" },
40132:   { name:"bug504843.ogv", type:"video/ogg" },
40132:   { name:"bug501279.ogg", type:"audio/ogg" },
49181:   { name:"bug580982.webm", type:"video/webm" },
55967:   { name:"bug603918.webm", type:"video/webm" },
55967:   { name:"bug604067.webm", type:"video/webm" },
30147:   { name:"bogus.duh", type:"bogus/duh" }
30147: ];
30147: 
30148: // These are files that have nontrivial duration and are useful for seeking within.
30148: var gSeekTests = [
30148:   { name:"r11025_s16_c1.wav", type:"audio/x-wav", duration:1.0 },
68451:   { name:"audio.wav", type:"audio/x-wav", duration:0.031247 },
30148:   { name:"seek.ogv", type:"video/ogg", duration:3.966 },
34136:   { name:"320x240.ogv", type:"video/ogg", duration:0.233 },
47959:   { name:"seek.webm", type:"video/webm", duration:3.966 },
50947:   { name:"bug516323.indexed.ogv", type:"video/ogg", duration:4.208 },
54994:   { name:"split.webm", type:"video/webm", duration:1.967 },
30148:   { name:"bogus.duh", type:"bogus/duh", duration:123 }
30148: ];
30148: 
30150: // These are files suitable for using with a "new Audio" constructor.
30150: var gAudioTests = [
30150:   { name:"r11025_s16_c1.wav", type:"audio/x-wav", duration:1.0 },
30150:   { name:"sound.ogg", type:"audio/ogg" },
30150:   { name:"bogus.duh", type:"bogus/duh", duration:123 }
30150: ];
30150: 
52451: // These files ensure our handling of 404 errors is consistent across the
42935: // various backends.
42935: var g404Tests = [
42935:   { name:"404.wav", type:"audio/x-wav" },
42935:   { name:"404.ogv", type:"video/ogg" },
42935:   { name:"404.oga", type:"audio/ogg" },
42935:   { name:"404.webm", type:"video/webm" },
42935:   { name:"bogus.duh", type:"bogus/duh" }
42935: ];
42935: 
32934: // These are files suitable for testing various decoder failures that are
32934: // expected to fire MEDIA_ERR_DECODE.  Used by test_decode_error, which expects
32934: // an error and emptied event, and no loadedmetadata or ended event.
32934: var gDecodeErrorTests = [
32934:   // Valid files with unsupported codecs
32934:   { name:"r11025_msadpcm_c1.wav", type:"audio/x-wav" },
32934:   { name:"dirac.ogg", type:"video/ogg" },
32934:   // Invalid files
32934:   { name:"bogus.wav", type:"audio/x-wav" },
32934:   { name:"bogus.ogv", type:"video/ogg" },
32934: 
32934:   { name:"bogus.duh", type:"bogus/duh" }
32934: ];
32934: 
77176: // These are files that are used for media fragments tests
77176: var gFragmentTests = [
77176:   { name:"big.wav", type:"audio/x-wav", duration:9.28, size:102444 }
77176: ];
77176: 
77176: 
30147: function checkMetadata(msg, e, test) {
30147:   if (test.width) {
30147:     is(e.videoWidth, test.width, msg + " video width");
30147:   }
30147:   if (test.height) {
30147:     is(e.videoHeight, test.height, msg + " video height");
30147:   }
30147:   if (test.duration) {
30147:     ok(Math.abs(e.duration - test.duration) < 0.1,
42935:        msg + " duration (" + e.duration + ") should be around " + test.duration);
30147:   }
30147: }
42935: 
42935: // Returns the first test from candidates array which we can play with the
42935: // installed video backends.
42935: function getPlayableVideo(candidates) {
42935:   var v = document.createElement("video");
42935:   var resources = candidates.filter(function(x){return /^video/.test(x.type) && v.canPlayType(x.type);});
42935:   if (resources.length > 0)
42935:     return resources[0];
42935:   return null;
42935: }
51544: 
87634: function getPlayableAudio(candidates) {
87634:   var v = document.createElement("audio");
87634:   var resources = candidates.filter(function(x){return /^audio/.test(x.type) && v.canPlayType(x.type);});
87634:   if (resources.length > 0)
87634:     return resources[0];
87634:   return null;
87634: }
87634: 
51544: // Number of tests to run in parallel. Warning: Each media element requires
51544: // at least 3 threads (4 on Linux), and on Linux each thread uses 10MB of
51544: // virtual address space. Beware!
51544: var PARALLEL_TESTS = 2;
51544: 
60417: // When true, we'll loop forever on whatever test we run. Use this to debug
60417: // intermittent test failures.
60417: const DEBUG_TEST_LOOP_FOREVER = false;
60417: 
51544: // Manages a run of media tests. Runs them in chunks in order to limit
51544: // the number of media elements/threads running in parallel. This limits peak
51544: // memory use, particularly on Linux x86 where thread stacks use 10MB of
51544: // virtual address space.
51544: // Usage:
51544: //   1. Create a new MediaTestManager object.
51544: //   2. Create a test startTest function. This takes a test object and a token,
51544: //      and performs anything necessary to start the test. The test object is an
51544: //      element in one of the g*Tests above. Your startTest function must call 
51544: //      MediaTestManager.start(token) if it starts a test. The test object is
51544: //      guaranteed to be playable by our supported decoders; you don't need to
51544: //      check canPlayType.
51544: //   3. When your tests finishes, call MediaTestManager.finished(), passing
51544: //      the token back to the manager. The manager may either start the next run
51544: //      or end the mochitest if all the tests are done.
51544: function MediaTestManager() {
51544: 
51544:   // Sets up a MediaTestManager to runs through the 'tests' array, which needs
51544:   // to be one of, or have the same fields as, the g*Test arrays of tests. Uses
51544:   // the user supplied 'startTest' function to initialize the test. This 
51544:   // function must accept two arguments, the test entry from the 'tests' array,
51544:   // and a token. Call MediaTestManager.started(token) if you start the test,
51544:   // and MediaTestManager.finished(token) when the test finishes. You don't have
51544:   // to start every test, but if you call started() you *must* call finish()
51544:   // else you'll timeout. 
51544:   this.runTests = function(tests, startTest) {
77565:     this.startTime = new Date();
77565:     SimpleTest.info("Started " + this.startTime + " (" + this.startTime.getTime()/1000 + "s)");
51544:     this.testNum = 0;
51544:     this.tests = tests;
51544:     this.startTest = startTest;
51544:     this.tokens = [];
77565:     this.isShutdown = false;
82891:     this.numTestsRunning = 0;
51544:     // Always wait for explicit finish.
51544:     SimpleTest.waitForExplicitFinish();
51544:     this.nextTest();
51544:   }
51544:   
51544:   // Registers that the test corresponding to 'token' has been started.
51544:   // Don't call more than once per token.
51544:   this.started = function(token) {
51544:     this.tokens.push(token);
82891:     this.numTestsRunning++;
82958:     is(this.numTestsRunning, this.tokens.length, "[started " + token + "] Length of array should match number of running tests");
51544:   }
51544:   
51544:   // Registers that the test corresponding to 'token' has finished. Call when
51544:   // you've finished your test. If all tests are complete this will finish the
51544:   // run, otherwise it may start up the next run. It's ok to call multiple times
51544:   // per token.
51544:   this.finished = function(token) {
51544:     var i = this.tokens.indexOf(token);
51544:     if (i != -1) {
51544:       // Remove the element from the list of running tests.
51544:       this.tokens.splice(i, 1);
51544:     }
82891:     this.numTestsRunning--;
82958:     is(this.numTestsRunning, this.tokens.length, "[finished " + token + "] Length of array should match number of running tests");
77565:     if (this.tokens.length < PARALLEL_TESTS) {
51544:       this.nextTest();
51544:     }
51544:   }
51544: 
51544:   // Starts the next batch of tests, or finishes if they're all done.
51544:   // Don't call this directly, call finished(token) when you're done.
51544:   this.nextTest = function() {
51544:     // Force a GC after every completed testcase. This ensures that any decoders
51544:     // with live threads waiting for the GC are killed promptly, to free up the
51544:     // thread stacks' address space.
51544:     netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
51544:     Components.utils.forceGC();
77565:     
51544:     while (this.testNum < this.tests.length && this.tokens.length < PARALLEL_TESTS) {
51544:       var test = this.tests[this.testNum];
51544:       var token = (test.name ? (test.name + "-"): "") + this.testNum;
51544:       this.testNum++;
51544: 
60417:       if (DEBUG_TEST_LOOP_FOREVER && this.testNum == this.tests.length) {
60417:         this.testNum = 0;
60417:       }
60417:       
51544:       // Ensure we can play the resource type.
51544:       if (test.type && !document.createElement('video').canPlayType(test.type))
51544:         continue;
51544:       
51544:       // Do the init. This should start the test.
51544:       this.startTest(test, token);
77565:     }
51544: 
77565:     if (this.testNum == this.tests.length &&
77565:         !DEBUG_TEST_LOOP_FOREVER &&
77565:         this.tokens.length == 0 &&
77565:         !this.isShutdown)
77565:     {
77565:       this.isShutdown = true;
77565:       if (this.onFinished) {
77565:         this.onFinished();
51544:       }
77565:       mediaTestCleanup();
77565:       var end = new Date();
77565:       SimpleTest.info("Finished at " + end + " (" + (end.getTime() / 1000) + "s)");
77565:       SimpleTest.info("Running time: " + (end.getTime() - this.startTime.getTime())/1000 + "s");
51544:       SimpleTest.finish();
77565:       return;
51544:     }
51544:   }
51544: }
51544: 
51544: // Ensures we've got no active video or audio elements in the document, and
51544: // forces a GC to release the address space reserved by the decoders' threads'
51544: // stacks.
51544: function mediaTestCleanup() {
51544:     var V = document.getElementsByTagName("video");
51544:     for (i=0; i<V.length; i++) {
51544:       V[i].parentNode.removeChild(V[i]);
51544:       V[i] = null;
51544:     }
51544:     var A = document.getElementsByTagName("audio");
51544:     for (i=0; i<A.length; i++) {
51544:       A[i].parentNode.removeChild(A[i]);
51544:       A[i] = null;
51544:     }
51544:     netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
51544:     Components.utils.forceGC();
51544: }
62638: 
62638: (function() {
62638:   netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
62638:   // Ensure that preload preferences are comsistent
62638:   var prefService = Components.classes["@mozilla.org/preferences-service;1"]
62638:                                .getService(Components.interfaces.nsIPrefService);
62638:   var branch = prefService.getBranch("media.");
62638:   var oldDefault = 2;
62638:   var oldAuto = 3;
62638:   try {
62638:     oldDefault = branch.getIntPref("preload.default");
62638:     oldAuto    = branch.getIntPref("preload.auto");
62638:   } catch(ex) { }
62638:   branch.setIntPref("preload.default", 2); // preload_metadata
62638:   branch.setIntPref("preload.auto", 3); // preload_enough
62638: 
62638:   window.addEventListener("unload", function() {
62638:     netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
62638:     branch.setIntPref("preload.default", oldDefault);
62638:     branch.setIntPref("preload.auto", oldAuto);
62638:   }, false);
62638:  })();
