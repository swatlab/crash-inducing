29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jscntxt_h___
    1: #define jscntxt_h___
    1: /*
    1:  * JS execution context.
    1:  */
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jslong.h"
    1: #include "jsatom.h"
18863: #include "jsversion.h"
    1: #include "jsdhash.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
    1: #include "jsregexp.h"
    1: #include "jsutil.h"
30023: #include "jsarray.h"
30851: #include "jstask.h"
34299: #include "jsvector.h"
    1: 
    1: /*
    1:  * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
15530:  * given pc in a script. We use the script->code pointer to tag the cache,
15530:  * instead of the script address itself, so that source notes are always found
15530:  * by offset from the bytecode with which they were generated.
    1:  */
    1: typedef struct JSGSNCache {
15530:     jsbytecode      *code;
    1:     JSDHashTable    table;
    1: #ifdef JS_GSNMETER
    1:     uint32          hits;
    1:     uint32          misses;
    1:     uint32          fills;
26569:     uint32          purges;
    1: # define GSN_CACHE_METER(cache,cnt) (++(cache)->cnt)
    1: #else
    1: # define GSN_CACHE_METER(cache,cnt) /* nothing */
    1: #endif
    1: } JSGSNCache;
    1: 
26569: #define js_FinishGSNCache(cache) js_PurgeGSNCache(cache)
26569: 
26569: extern void
26569: js_PurgeGSNCache(JSGSNCache *cache);
    1: 
    1: /* These helper macros take a cx as parameter and operate on its GSN cache. */
26569: #define JS_PURGE_GSN_CACHE(cx)      js_PurgeGSNCache(&JS_GSN_CACHE(cx))
    1: #define JS_METER_GSN_CACHE(cx,cnt)  GSN_CACHE_METER(&JS_GSN_CACHE(cx), cnt)
    1: 
34572: /* Forward declarations of nanojit types. */
34572: namespace nanojit
34572: {
31475:     class Assembler;
31475:     class CodeAlloc;
17937:     class Fragment;
23237:     class LirBuffer;
31920: #ifdef DEBUG
31920:     class LabelMap;
31920: #endif
33166:     template<typename K> struct DefaultHash;
32784:     template<typename K, typename V, typename H> class HashMap;
32784:     template<typename T> class Seq;
17583: }
34572: 
34572: /* Tracer constants. */
34572: static const size_t MONITOR_N_GLOBAL_STATES = 4;
34572: static const size_t FRAGMENT_TABLE_SIZE = 512;
34572: static const size_t MAX_NATIVE_STACK_SLOTS = 4096;
34572: static const size_t MAX_CALL_STACK_ENTRIES = 500;
34572: static const size_t MAX_GLOBAL_SLOTS = 4096;
34572: static const size_t GLOBAL_SLOTS_BUFFER_SIZE = MAX_GLOBAL_SLOTS + 1;
34572: 
34572: /* Forward declarations of tracer types. */
34572: class TreeInfo;
34572: class VMAllocator;
34572: class TraceRecorder;
34572: class FrameInfoCache;
34572: struct REHashFn;
34572: struct REHashKey;
34572: struct FrameInfo;
34572: struct VMSideExit;
35044: struct TreeFragment;
34572: struct InterpState;
34572: template<typename T> class Queue;
34572: typedef Queue<uint16> SlotList;
35044: struct REFragment;
35044: typedef nanojit::HashMap<REHashKey, REFragment*, REHashFn> REHashMap;
34572: 
32784: #if defined(JS_JIT_SPEW) || defined(DEBUG)
32784: struct FragPI;
32788: typedef nanojit::HashMap<uint32, FragPI, nanojit::DefaultHash<uint32> > FragStatsMap;
32784: #endif
17583: 
34572: /* Holds the execution state during trace execution. */
34572: struct InterpState
34572: {
35083:     JSContext*     cx;                  // current VM context handle
35083:     double*        stackBase;           // native stack base
34572:     double*        sp;                  // native stack pointer, stack[0] is spbase[0]
35083:     double*        eos;                 // first unusable word after the native stack / begin of globals
35083:     FrameInfo**    callstackBase;       // call stack base
35083:     void*          sor;                 // start of rp stack
34572:     FrameInfo**    rp;                  // call stack pointer
34572:     void*          eor;                 // first unusable word after the call stack
34572:     VMSideExit*    lastTreeExitGuard;   // guard we exited on during a tree call
34572:     VMSideExit*    lastTreeCallGuard;   // guard we want to grow from if the tree
34572:                                         // call exit guard mismatched
34572:     void*          rpAtLastTreeCall;    // value of rp at innermost tree call guard
34572:     VMSideExit*    outermostTreeExitGuard; // the last side exit returned by js_CallTree
34572:     TreeInfo*      outermostTree;       // the outermost tree we initially invoked
34572:     uintN*         inlineCallCountp;    // inline call count counter
34572:     VMSideExit**   innermostNestedGuardp;
34572:     VMSideExit*    innermost;
34572:     uint64         startTime;
34572:     InterpState*   prev;
24307: 
34572:     // Used by _FAIL builtins; see jsbuiltins.h. The builtin sets the
34572:     // JSBUILTIN_BAILED bit if it bails off trace and the JSBUILTIN_ERROR bit
34572:     // if an error or exception occurred.
34572:     uint32         builtinStatus;
31918: 
34572:     // Used to communicate the location of the return value in case of a deep bail.
34572:     double*        deepBailSp;
34572: 
34572:     // Used when calling natives from trace to root the vp vector.
34572:     uintN          nativeVpLen;
34572:     jsval*         nativeVp;
35083: 
35083:     InterpState(JSContext *cx, JSTraceMonitor *tm, TreeInfo *ti,
35083:                 uintN &inlineCallCountp, VMSideExit** innermostNestedGuardp);
35083:     ~InterpState();
34572: };
34572: 
34572: /*
34572:  * Storage for the execution state and store during trace execution. Generated
34572:  * code depends on the fact that the globals begin |MAX_NATIVE_STACK_SLOTS|
34572:  * doubles after the stack begins. Thus, on trace, |InterpState::eos| holds a
34572:  * pointer to the first global.
34572:  */
34572: struct TraceNativeStorage
34572: {
34572:     double stack_global_buf[MAX_NATIVE_STACK_SLOTS + GLOBAL_SLOTS_BUFFER_SIZE];
34572:     FrameInfo *callstack_buf[MAX_CALL_STACK_ENTRIES];
34572: 
34572:     double *stack() { return stack_global_buf; }
34572:     double *global() { return stack_global_buf + MAX_NATIVE_STACK_SLOTS; }
34572:     FrameInfo **callstack() { return callstack_buf; }
34572: };
34572: 
34572: /* Holds data to track a single globa. */
24491: struct GlobalState {
26819:     JSObject*               globalObj;
24491:     uint32                  globalShape;
34299:     SlotList*               globalSlots;
24491: };
24491: 
17583: /*
17583:  * Trace monitor. Every JSThread (if JS_THREADSAFE) or JSRuntime (if not
17583:  * JS_THREADSAFE) has an associated trace monitor that keeps track of loop
17583:  * frequencies for all JavaScript code loaded into that runtime.
17583:  */
26569: struct JSTraceMonitor {
18782:     /*
27882:      * The context currently executing JIT-compiled code on this thread, or
27882:      * NULL if none. Among other things, this can in certain cases prevent
27882:      * last-ditch GC and suppress calls to JS_ReportOutOfMemory.
24613:      *
27882:      * !tracecx && !recorder: not on trace
33172:      * !tracecx && recorder: recording
27882:      * tracecx && !recorder: executing a trace
27882:      * tracecx && recorder: executing inner loop, recording outer loop
18782:      */
27882:     JSContext               *tracecx;
24598: 
33545:     /*
34572:      * Cached storage to use when executing on trace. While we may enter nested
34572:      * traces, we always reuse the outer trace's storage, so never need more
34572:      * than of these.
34572:      */
34572:     TraceNativeStorage      storage;
34572: 
34572:     /*
33545:      * There are 3 allocators here. This might seem like overkill, but they
33545:      * have different lifecycles, and by keeping them separate we keep the
33545:      * amount of retained memory down significantly.
33545:      *
33545:      * The dataAlloc has the lifecycle of the monitor. It's flushed only
33545:      * when the monitor is flushed.
33545:      *
33545:      * The traceAlloc has the same flush lifecycle as the dataAlloc, but
33545:      * it is also *marked* when a recording starts and rewinds to the mark
33545:      * point if recording aborts. So you can put things in it that are only
33545:      * reachable on a successful record/compile cycle.
33545:      *
33545:      * The tempAlloc is flushed after each recording, successful or not.
33545:      */
33545: 
34299:     VMAllocator*            dataAlloc;   /* A chunk allocator for fragments. */
34299:     VMAllocator*            traceAlloc;  /* An allocator for trace metadata. */
34299:     VMAllocator*            tempAlloc;   /* A temporary chunk allocator.  */
34299:     nanojit::CodeAlloc*     codeAlloc;   /* An allocator for native code. */
34299:     nanojit::Assembler*     assembler;
34299:     nanojit::LirBuffer*     lirbuf;
34299:     nanojit::LirBuffer*     reLirBuf;
34299:     FrameInfoCache*         frameCache;
31920: #ifdef DEBUG
34299:     nanojit::LabelMap*      labels;
31920: #endif
31920: 
34299:     TraceRecorder*          recorder;
21491: 
24491:     struct GlobalState      globalStates[MONITOR_N_GLOBAL_STATES];
35044:     struct TreeFragment*    vmfragments[FRAGMENT_TABLE_SIZE];
28105:     JSDHashTable            recordAttempts;
27379: 
27379:     /*
27884:      * Maximum size of the code cache before we start flushing. 1/16 of this
27884:      * size is used as threshold for the regular expression code cache.
27884:      */
27884:     uint32                  maxCodeCacheBytes;
27884: 
27884:     /*
28312:      * If nonzero, do not flush the JIT cache after a deep bail. That would
28312:      * free JITted code pages that we will later return to. Instead, set the
28312:      * needFlush flag so that it can be flushed later.
28312:      */
31526:     JSBool                  needFlush;
28312: 
28312:     /*
23448:      * reservedObjects is a linked list (via fslots[0]) of preallocated JSObjects.
23448:      * The JIT uses this to ensure that leaving a trace tree can't fail.
23448:      */
31526:     JSBool                  useReservedObjects;
23448:     JSObject                *reservedObjects;
23448: 
32767:     /*
32767:      * Fragment map for the regular expression compiler.
32767:      */
34299:     REHashMap*              reFragments;
21723: 
33167:     /*
33167:      * A temporary allocator for RE recording.
33167:      */
34299:     VMAllocator*            reTempAlloc;
33167: 
32784: #ifdef DEBUG
32784:     /* Fields needed for fragment/guard profiling. */
34299:     nanojit::Seq<nanojit::Fragment*>* branches;
32788:     uint32                  lastFragID;
32784:     /*
32784:      * profAlloc has a lifetime which spans exactly from js_InitJIT to
32784:      * js_FinishJIT.
32784:      */
34299:     VMAllocator*            profAlloc;
34299:     FragStatsMap*           profTab;
32784: #endif
32784: 
31843:     /* Flush the JIT cache. */
31843:     void flush();
31843: 
31843:     /* Mark all objects baked into native code in the code cache. */
31843:     void mark(JSTracer *trc);
35083: 
35083:     bool outOfMemory() const;
26569: };
17583: 
24612: typedef struct InterpStruct InterpStruct;
24612: 
27577: /*
27577:  * N.B. JS_ON_TRACE(cx) is true if JIT code is on the stack in the current
27577:  * thread, regardless of whether cx is the context in which that trace is
27577:  * executing.  cx must be a context on the current thread.
27577:  */
18782: #ifdef JS_TRACER
27882: # define JS_ON_TRACE(cx)            (JS_TRACE_MONITOR(cx).tracecx != NULL)
18782: #else
18782: # define JS_ON_TRACE(cx)            JS_FALSE
18782: #endif
18782: 
24375: #ifdef DEBUG
24375: # define JS_EVAL_CACHE_METERING     1
27012: # define JS_FUNCTION_METERING       1
24375: #endif
24375: 
24375: /* Number of potentially reusable scriptsToGC to search for the eval cache. */
24375: #ifndef JS_EVAL_CACHE_SHIFT
24375: # define JS_EVAL_CACHE_SHIFT        6
24375: #endif
24375: #define JS_EVAL_CACHE_SIZE          JS_BIT(JS_EVAL_CACHE_SHIFT)
24375: 
24375: #ifdef JS_EVAL_CACHE_METERING
24375: # define EVAL_CACHE_METER_LIST(_)   _(probe), _(hit), _(step), _(noscope)
27012: # define identity(x)                x
24375: 
29923: struct JSEvalCacheMeter {
27012:     uint64 EVAL_CACHE_METER_LIST(identity);
29923: };
24375: 
27012: # undef identity
27012: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012: # define FUNCTION_KIND_METER_LIST(_)                                          \
27012:                         _(allfun), _(heavy), _(nofreeupvar), _(onlyfreevar),  \
27012:                         _(display), _(flat), _(setupvar), _(badfunarg)
27012: # define identity(x)    x
27012: 
35075: struct JSFunctionMeter {
27012:     int32 FUNCTION_KIND_METER_LIST(identity);
35075: };
27012: 
27012: # undef identity
24375: #endif
24375: 
35075: struct JSLocalRootChunk;
35075: 
35075: #define JSLRS_CHUNK_SHIFT       8
35075: #define JSLRS_CHUNK_SIZE        JS_BIT(JSLRS_CHUNK_SHIFT)
35075: #define JSLRS_CHUNK_MASK        JS_BITMASK(JSLRS_CHUNK_SHIFT)
35075: 
35075: struct JSLocalRootChunk {
35075:     jsval               roots[JSLRS_CHUNK_SIZE];
35075:     JSLocalRootChunk    *down;
35075: };
35075: 
35075: struct JSLocalRootStack {
35075:     uint32              scopeMark;
35075:     uint32              rootCount;
35075:     JSLocalRootChunk    *topChunk;
35075:     JSLocalRootChunk    firstChunk;
35075: 
35075:     /* See comments in js_NewFinalizableGCThing. */
35075:     JSGCFreeLists       gcFreeLists;
35075: };
35075: 
35075: const uint32 JSLRS_NULL_MARK = uint32(-1);
35075: 
26569: struct JSThreadData {
33952:     JSGCFreeLists       gcFreeLists;
33747: 
26569:     /*
35078:      * Flag indicating that we are waiving any soft limits on the GC heap
35078:      * because we want allocations to be infallible (except when we hit
35078:      * a hard quota).
35078:      */
35078:     bool                waiveGCQuota;
35078: 
35078:     /*
26569:      * The GSN cache is per thread since even multi-cx-per-thread embeddings
26569:      * do not interleave js_GetSrcNote calls.
26569:      */
26569:     JSGSNCache          gsnCache;
26569: 
26569:     /* Property cache for faster call/get/set invocation. */
26569:     JSPropertyCache     propertyCache;
26569: 
31898:     /* Random number generator state, used by jsmath.cpp. */
31898:     int64               rngSeed;
31898: 
35075:     /* Optional stack of heap-allocated scoped local GC roots. */
35075:     JSLocalRootStack    *localRootStack;
35075: 
26569: #ifdef JS_TRACER
26569:     /* Trace-tree JIT recorder/interpreter state. */
26569:     JSTraceMonitor      traceMonitor;
26569: #endif
26569: 
26569:     /* Lock-free hashed lists of scripts created by eval to garbage-collect. */
26569:     JSScript            *scriptsToGC[JS_EVAL_CACHE_SIZE];
26569: 
26569: #ifdef JS_EVAL_CACHE_METERING
26569:     JSEvalCacheMeter    evalCacheMeter;
26569: #endif
30453: 
32553:     /*
33128:      * Cache of reusable JSNativeEnumerators mapped by shape identifiers (as
33128:      * stored in scope->shape). This cache is nulled by the GC and protected
33128:      * by gcLock.
33128:      */
33128: #define NATIVE_ENUM_CACHE_LOG2  8
33128: #define NATIVE_ENUM_CACHE_MASK  JS_BITMASK(NATIVE_ENUM_CACHE_LOG2)
33128: #define NATIVE_ENUM_CACHE_SIZE  JS_BIT(NATIVE_ENUM_CACHE_LOG2)
33128: 
33128: #define NATIVE_ENUM_CACHE_HASH(shape)                                         \
33128:     ((((shape) >> NATIVE_ENUM_CACHE_LOG2) ^ (shape)) & NATIVE_ENUM_CACHE_MASK)
33128: 
33128:     jsuword             nativeEnumCache[NATIVE_ENUM_CACHE_SIZE];
33128: 
35075:     void init();
35075:     void finish();
35075:     void mark(JSTracer *trc);
35075:     void purge(JSContext *cx);
35075:     void purgeGCFreeLists();
26569: };
26569: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * Structure uniquely representing a thread.  It holds thread-private data
    1:  * that can be accessed without a global lock.
    1:  */
    1: struct JSThread {
28312:     /* Linked list of all contexts in use on this thread. */
    1:     JSCList             contextList;
    1: 
    1:     /* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */
    1:     jsword              id;
    1: 
27384:     /* Indicates that the thread is waiting in ClaimTitle from jslock.cpp. */
27384:     JSTitle             *titleToShare;
27384: 
34288:     /*
34288:      * Thread-local version of JSRuntime.gcMallocBytes to avoid taking
34288:      * locks on each JS_malloc.
34288:      */
34288:     ptrdiff_t           gcThreadMallocBytes;
34288: 
35075:     /*
35075:      * Deallocator task for this thread.
35075:      */
35075:     JSFreePointerListTask *deallocatorTask;
35075: 
28312:     /* Factored out of JSThread for !JS_THREADSAFE embedding in JSRuntime. */
26569:     JSThreadData        data;
    1: };
    1: 
34288: /*
34288:  * Only when JSThread::gcThreadMallocBytes exhausts the following limit we
34288:  * update JSRuntime::gcMallocBytes.
34288:  * .
34288:  */
34288: const size_t JS_GC_THREAD_MALLOC_LIMIT = 1 << 19;
34288: 
26569: #define JS_THREAD_DATA(cx)      (&(cx)->thread->data)
    1: 
26569: struct JSThreadsHashEntry {
26569:     JSDHashEntryHdr     base;
26569:     JSThread            *thread;
26569: };
26569: 
34365: extern JSThread *
34365: js_CurrentThread(JSRuntime *rt);
34365: 
26569: /*
26569:  * The function takes the GC lock and does not release in successful return.
26569:  * On error (out of memory) the function releases the lock but delegates
26569:  * the error reporting to the caller.
26569:  */
26569: extern JSBool
26569: js_InitContextThread(JSContext *cx);
26569: 
26569: /*
26569:  * On entrance the GC lock must be held and it will be held on exit.
26569:  */
26561: extern void
26569: js_ClearContextThread(JSContext *cx);
    1: 
    1: #endif /* JS_THREADSAFE */
    1: 
    1: typedef enum JSDestroyContextMode {
    1:     JSDCM_NO_GC,
    1:     JSDCM_MAYBE_GC,
    1:     JSDCM_FORCE_GC,
    1:     JSDCM_NEW_FAILED
    1: } JSDestroyContextMode;
    1: 
    1: typedef enum JSRuntimeState {
    1:     JSRTS_DOWN,
    1:     JSRTS_LAUNCHING,
    1:     JSRTS_UP,
    1:     JSRTS_LANDING
    1: } JSRuntimeState;
    1: 
24384: typedef enum JSBuiltinFunctionId {
24384:     JSBUILTIN_ObjectToIterator,
24384:     JSBUILTIN_CallIteratorNext,
24384:     JSBUILTIN_LIMIT
24384: } JSBuiltinFunctionId;
24384: 
    1: typedef struct JSPropertyTreeEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSScopeProperty     *child;
    1: } JSPropertyTreeEntry;
    1: 
11041: typedef struct JSSetSlotRequest JSSetSlotRequest;
11041: 
11041: struct JSSetSlotRequest {
11041:     JSObject            *obj;           /* object containing slot to set */
11041:     JSObject            *pobj;          /* new proto or parent reference */
11041:     uint16              slot;           /* which to set, proto or parent */
28003:     JSPackedBool        cycle;          /* true if a cycle was detected */
11041:     JSSetSlotRequest    *next;          /* next request in GC worklist */
11041: };
11041: 
    1: struct JSRuntime {
    1:     /* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */
    1:     JSRuntimeState      state;
    1: 
    1:     /* Context create/destroy callback. */
    1:     JSContextCallback   cxCallback;
    1: 
28312:     /*
28312:      * Shape regenerated whenever a prototype implicated by an "add property"
28312:      * property cache fill and induced trace guard has a readonly property or a
28312:      * setter defined on it. This number proxies for the shapes of all objects
28312:      * along the prototype chain of all objects in the runtime on which such an
28312:      * add-property result has been cached/traced.
28312:      *
28312:      * See bug 492355 for more details.
28312:      *
28312:      * This comes early in JSRuntime to minimize the immediate format used by
28312:      * trace-JITted code that reads it.
28312:      */
28312:     uint32              protoHazardShape;
28312: 
    1:     /* Garbage collector state, used by jsgc.c. */
32823:     JSGCChunkInfo       *gcChunkList;
33582:     JSGCArenaList       gcArenaList[FINALIZE_LIMIT];
12282:     JSGCDoubleArenaList gcDoubleArenaList;
    1:     JSDHashTable        gcRootsHash;
    1:     JSDHashTable        *gcLocksHash;
    1:     jsrefcount          gcKeepAtoms;
32553:     size_t              gcBytes;
32553:     size_t              gcLastBytes;
32553:     size_t              gcMaxBytes;
32553:     size_t              gcMaxMallocBytes;
19196:     uint32              gcEmptyArenaPoolLifespan;
    1:     uint32              gcLevel;
    1:     uint32              gcNumber;
  583:     JSTracer            *gcMarkingTracer;
32553:     uint32              gcTriggerFactor;
32553:     size_t              gcTriggerBytes;
27546:     volatile JSBool     gcIsNeeded;
31885:     volatile JSBool     gcFlushCodeCaches;
    1: 
    1:     /*
    1:      * NB: do not pack another flag here by claiming gcPadding unless the new
    1:      * flag is written only by the GC thread.  Atomic updates to packed bytes
    1:      * are not guaranteed, so stores issued by one thread may be lost due to
    1:      * unsynchronized read-modify-write cycles on other threads.
    1:      */
    1:     JSPackedBool        gcPoke;
    1:     JSPackedBool        gcRunning;
30733:     JSPackedBool        gcRegenShapes;
30845: 
30845:     /*
30845:      * During gc, if rt->gcRegenShapes &&
30845:      *   (scope->flags & JSScope::SHAPE_REGEN) == rt->gcRegenShapesScopeFlag,
30845:      * then the scope's shape has already been regenerated during this GC.
30845:      * To avoid having to sweep JSScopes, the bit's meaning toggles with each
30845:      * shape-regenerating GC.
30845:      *
30845:      * FIXME Once scopes are GC'd (bug 505004), this will be obsolete.
30845:      */
30845:     uint8               gcRegenShapesScopeFlag;
30845: 
 1492: #ifdef JS_GC_ZEAL
 7944:     jsrefcount          gcZeal;
 1492: #endif
    1: 
    1:     JSGCCallback        gcCallback;
34288: 
34288:     /*
34288:      * Malloc counter to measure memory pressure for GC scheduling. It runs
34288:      * from gcMaxMallocBytes down to zero.
34288:      */
34288:     ptrdiff_t           gcMallocBytes;
34288: 
34288:     /*
34288:      * Stack of GC arenas containing things that the GC marked, where children
34288:      * reached from those things have not yet been marked. This helps avoid
34288:      * using too much native stack during recursive GC marking.
34288:      */
 5917:     JSGCArenaInfo       *gcUntracedArenaStackTop;
    1: #ifdef DEBUG
 5917:     size_t              gcTraceLaterCount;
    1: #endif
    1: 
    1:     /*
    1:      * Table for tracking iterators to ensure that we close iterator's state
    1:      * before finalizing the iterable object.
    1:      */
34299:     js::Vector<JSObject*, 0, js::SystemAllocPolicy> gcIteratorTable;
    1: 
  958:     /*
  958:      * The trace operation and its data argument to trace embedding-specific
  958:      * GC roots.
  958:      */
  958:     JSTraceDataOp       gcExtraRootsTraceOp;
  958:     void                *gcExtraRootsData;
  958: 
11041:     /*
11041:      * Used to serialize cycle checks when setting __proto__ or __parent__ by
11041:      * requesting the GC handle the required cycle detection. If the GC hasn't
11041:      * been poked, it won't scan for garbage. This member is protected by
11041:      * rt->gcLock.
11041:      */
11041:     JSSetSlotRequest    *setSlotRequests;
11041: 
    1:     /* Well-known numbers held for use by this runtime's contexts. */
34372:     jsval               NaNValue;
34372:     jsval               negativeInfinityValue;
34372:     jsval               positiveInfinityValue;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     JSLock              *deflatedStringCacheLock;
    1: #endif
    1:     JSHashTable         *deflatedStringCache;
    1: #ifdef DEBUG
    1:     uint32              deflatedStringCacheBytes;
    1: #endif
    1: 
    1:     JSString            *emptyString;
    1: 
24384:     /*
24384:      * Builtin functions, lazily created and held for use by the trace recorder.
24384:      *
24384:      * This field would be #ifdef JS_TRACER, but XPConnect is compiled without
24384:      * -DJS_TRACER and includes this header.
24384:      */
24384:     JSObject            *builtinFunctions[JSBUILTIN_LIMIT];
24384: 
    1:     /* List of active contexts sharing this runtime; protected by gcLock. */
    1:     JSCList             contextList;
    1: 
 2433:     /* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */
 2433:     JSDebugHooks        globalDebugHooks;
    1: 
35331: #ifdef JS_TRACER
35331:     /* True if any debug hooks not supported by the JIT are enabled. */
35331:     bool debuggerInhibitsJIT() const {
35331:         return (globalDebugHooks.interruptHandler ||
35331:                 globalDebugHooks.callHook ||
35331:                 globalDebugHooks.objectHook);
35331:     }
35331: #endif
35331: 
    1:     /* More debugging state, see jsdbgapi.c. */
    1:     JSCList             trapList;
    1:     JSCList             watchPointList;
    1: 
20312:     /* Client opaque pointers */
    1:     void                *data;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     /* These combine to interlock the GC and new requests. */
    1:     PRLock              *gcLock;
    1:     PRCondVar           *gcDone;
    1:     PRCondVar           *requestDone;
    1:     uint32              requestCount;
    1:     JSThread            *gcThread;
    1: 
    1:     /* Lock and owning thread pointer for JS_LOCK_RUNTIME. */
    1:     PRLock              *rtLock;
    1: #ifdef DEBUG
    1:     jsword              rtLockOwner;
    1: #endif
    1: 
    1:     /* Used to synchronize down/up state change; protected by gcLock. */
    1:     PRCondVar           *stateChange;
    1: 
    1:     /*
11739:      * State for sharing single-threaded titles, once a second thread tries to
11739:      * lock a title.  The titleSharingDone condvar is protected by rt->gcLock
    1:      * to minimize number of locks taken in JS_EndRequest.
    1:      *
11739:      * The titleSharingTodo linked list is likewise "global" per runtime, not
    1:      * one-list-per-context, to conserve space over all contexts, optimizing
11739:      * for the likely case that titles become shared rarely, and among a very
    1:      * small set of threads (contexts).
    1:      */
11739:     PRCondVar           *titleSharingDone;
11739:     JSTitle             *titleSharingTodo;
    1: 
    1: /*
11739:  * Magic terminator for the rt->titleSharingTodo linked list, threaded through
11739:  * title->u.link.  This hack allows us to test whether a title is on the list
11739:  * by asking whether title->u.link is non-null.  We use a large, likely bogus
    1:  * pointer here to distinguish this value from any valid u.count (small int)
    1:  * value.
    1:  */
11739: #define NO_TITLE_SHARING_TODO   ((JSTitle *) 0xfeedbeef)
    1: 
    1:     /*
    1:      * Lock serializing trapList and watchPointList accesses, and count of all
    1:      * mutations to trapList and watchPointList made by debugger threads.  To
    1:      * keep the code simple, we define debuggerMutations for the thread-unsafe
    1:      * case too.
    1:      */
    1:     PRLock              *debuggerLock;
26569: 
26569:     JSDHashTable        threads;
    1: #endif /* JS_THREADSAFE */
    1:     uint32              debuggerMutations;
    1: 
    1:     /*
18870:      * Security callbacks set on the runtime are used by each context unless
18870:      * an override is set on the context.
    1:      */
18870:     JSSecurityCallbacks *securityCallbacks;
    1: 
    1:     /*
    1:      * Shared scope property tree, and arena-pool for allocating its nodes.
30258:      * The propertyRemovals counter is incremented for every JSScope::clear,
30258:      * and for each JSScope::remove method call that frees a slot in an object.
    1:      * See js_NativeGet and js_NativeSet in jsobj.c.
    1:      */
    1:     JSDHashTable        propertyTreeHash;
    1:     JSScopeProperty     *propertyFreeList;
    1:     JSArenaPool         propertyArenaPool;
    1:     int32               propertyRemovals;
    1: 
    1:     /* Script filename table. */
    1:     struct JSHashTable  *scriptFilenameTable;
    1:     JSCList             scriptFilenamePrefixes;
    1: #ifdef JS_THREADSAFE
    1:     PRLock              *scriptFilenameTableLock;
    1: #endif
    1: 
    1:     /* Number localization, used by jsnum.c */
    1:     const char          *thousandsSeparator;
    1:     const char          *decimalSeparator;
    1:     const char          *numGrouping;
    1: 
    1:     /*
    1:      * Weak references to lazily-created, well-known XML singletons.
    1:      *
    1:      * NB: Singleton objects must be carefully disconnected from the rest of
    1:      * the object graph usually associated with a JSContext's global object,
    1:      * including the set of standard class objects.  See jsxml.c for details.
    1:      */
    1:     JSObject            *anynameObject;
    1:     JSObject            *functionNamespaceObject;
    1: 
    1: #ifndef JS_THREADSAFE
26569:     JSThreadData        threadData;
    1: 
26569: #define JS_THREAD_DATA(cx)      (&(cx)->runtime->threadData)
    1: #endif
    1: 
11377:     /*
11377:      * Object shape (property cache structural type) identifier generator.
11377:      *
11377:      * Type 0 stands for the empty scope, and must not be regenerated due to
27546:      * uint32 wrap-around. Since js_GenerateShape (in jsinterp.cpp) uses
27546:      * atomic pre-increment, the initial value for the first typed non-empty
27546:      * scope will be 1.
11377:      *
11377:      * If this counter overflows into SHAPE_OVERFLOW_BIT (in jsinterp.h), the
27546:      * cache is disabled, to avoid aliasing two different types. It stays
27546:      * disabled until a triggered GC at some later moment compresses live
27546:      * types, minimizing rt->shapeGen in the process.
11377:      */
27546:     volatile uint32     shapeGen;
11377: 
 4342:     /* Literal table maintained by jsatom.c functions. */
 4342:     JSAtomState         atomState;
 4342: 
34288: #ifdef JS_THREADSAFE
34288:     JSBackgroundThread    *deallocatorThread;
34288: #endif
34288: 
10954:     /*
10954:      * Various metering fields are defined at the end of JSRuntime. In this
10954:      * way there is no need to recompile all the code that refers to other
10954:      * fields of JSRuntime after enabling the corresponding metering macro.
10954:      */
17049: #ifdef JS_DUMP_ENUM_CACHE_STATS
17049:     int32               nativeEnumProbes;
17049:     int32               nativeEnumMisses;
17049: # define ENUM_CACHE_METER(name)     JS_ATOMIC_INCREMENT(&cx->runtime->name)
17049: #else
17049: # define ENUM_CACHE_METER(name)     ((void) 0)
17049: #endif
10954: 
17182: #ifdef JS_DUMP_LOOP_STATS
17182:     /* Loop statistics, to trigger trace recording and compiling. */
17182:     JSBasicStats        loopStats;
17182: #endif
17182: 
10217: #if defined DEBUG || defined JS_DUMP_PROPTREE_STATS
    1:     /* Function invocation metering. */
    1:     jsrefcount          inlineCalls;
    1:     jsrefcount          nativeCalls;
    1:     jsrefcount          nonInlineCalls;
    1:     jsrefcount          constructs;
    1: 
11739:     /* Title lock and scope property metering. */
    1:     jsrefcount          claimAttempts;
11739:     jsrefcount          claimedTitles;
    1:     jsrefcount          deadContexts;
    1:     jsrefcount          deadlocksAvoided;
    1:     jsrefcount          liveScopes;
11739:     jsrefcount          sharedTitles;
    1:     jsrefcount          totalScopes;
    1:     jsrefcount          liveScopeProps;
10217:     jsrefcount          liveScopePropsPreSweep;
    1:     jsrefcount          totalScopeProps;
    1:     jsrefcount          livePropTreeNodes;
    1:     jsrefcount          duplicatePropTreeNodes;
    1:     jsrefcount          totalPropTreeNodes;
    1:     jsrefcount          propTreeKidsChunks;
    1:     jsrefcount          middleDeleteFixups;
    1: 
    1:     /* String instrumentation. */
    1:     jsrefcount          liveStrings;
    1:     jsrefcount          totalStrings;
    1:     jsrefcount          liveDependentStrings;
    1:     jsrefcount          totalDependentStrings;
10217:     jsrefcount          badUndependStrings;
    1:     double              lengthSum;
    1:     double              lengthSquaredSum;
    1:     double              strdepLengthSum;
    1:     double              strdepLengthSquaredSum;
34290: 
34290:     /* Script instrumentation. */
34290:     jsrefcount          liveScripts;
34290:     jsrefcount          totalScripts;
34290:     jsrefcount          liveEmptyScripts;
34290:     jsrefcount          totalEmptyScripts;
10217: #endif /* DEBUG || JS_DUMP_PROPTREE_STATS */
10217: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     /*
10217:      * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
10217:      * counts of objects traversed on a chain until the wanted id is found.
10217:      */
10217:     JSBasicStats        protoLookupDepthStats;
10217:     JSBasicStats        scopeSearchDepthStats;
10217: 
10217:     /*
10217:      * Stats on compile-time host environment and lexical scope chain lengths
10217:      * (maximum depths).
10217:      */
10217:     JSBasicStats        hostenvScopeDepthStats;
10217:     JSBasicStats        lexicalScopeDepthStats;
    1: #endif
10954: 
10954: #ifdef JS_GCMETER
10954:     JSGCStats           gcStats;
10954: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012:     JSFunctionMeter     functionMeter;
27012:     char                lastScriptFilename[1024];
27012: #endif
30438: 
34299:     JSRuntime();
34299:     ~JSRuntime();
34299: 
34299:     bool init(uint32 maxbytes);
34299: 
32553:     void setGCTriggerFactor(uint32 factor);
32553:     void setGCLastBytes(size_t lastBytes);
32553: 
34288:     void* malloc(size_t bytes) { return ::js_malloc(bytes); }
34288: 
34288:     void* calloc(size_t bytes) { return ::js_calloc(bytes); }
34288: 
34288:     void* realloc(void* p, size_t bytes) { return ::js_realloc(p, bytes); }
34288: 
34288:     void free(void* p) { ::js_free(p); }
34288: 
34288:     bool isGCMallocLimitReached() const { return gcMallocBytes <= 0; }
34288: 
34288:     void resetGCMallocBytes() { gcMallocBytes = ptrdiff_t(gcMaxMallocBytes); }
34288: 
34288:     void setGCMaxMallocBytes(size_t value) {
34288:         /*
34288:          * For compatibility treat any value that exceeds PTRDIFF_T_MAX to
34288:          * mean that value.
34288:          */
34288:         gcMaxMallocBytes = (ptrdiff_t(value) >= 0) ? value : size_t(-1) >> 1;
34288:         resetGCMallocBytes();
30851:     }
    1: };
    1: 
24375: /* Common macros to access thread-local caches in JSThread or JSRuntime. */
26569: #define JS_GSN_CACHE(cx)        (JS_THREAD_DATA(cx)->gsnCache)
26569: #define JS_PROPERTY_CACHE(cx)   (JS_THREAD_DATA(cx)->propertyCache)
26569: #define JS_TRACE_MONITOR(cx)    (JS_THREAD_DATA(cx)->traceMonitor)
26569: #define JS_SCRIPTS_TO_GC(cx)    (JS_THREAD_DATA(cx)->scriptsToGC)
24375: 
24375: #ifdef JS_EVAL_CACHE_METERING
26569: # define EVAL_CACHE_METER(x)    (JS_THREAD_DATA(cx)->evalCacheMeter.x++)
24375: #else
24375: # define EVAL_CACHE_METER(x)    ((void) 0)
24375: #endif
24375: 
    1: #ifdef DEBUG
    1: # define JS_RUNTIME_METER(rt, which)    JS_ATOMIC_INCREMENT(&(rt)->which)
    1: # define JS_RUNTIME_UNMETER(rt, which)  JS_ATOMIC_DECREMENT(&(rt)->which)
    1: #else
    1: # define JS_RUNTIME_METER(rt, which)    /* nothing */
    1: # define JS_RUNTIME_UNMETER(rt, which)  /* nothing */
    1: #endif
    1: 
    1: #define JS_KEEP_ATOMS(rt)   JS_ATOMIC_INCREMENT(&(rt)->gcKeepAtoms);
    1: #define JS_UNKEEP_ATOMS(rt) JS_ATOMIC_DECREMENT(&(rt)->gcKeepAtoms);
    1: 
    1: #ifdef JS_ARGUMENT_FORMATTER_DEFINED
    1: /*
    1:  * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
    1:  * formatter functions.  Elements are sorted in non-increasing format string
    1:  * length order.
    1:  */
    1: struct JSArgumentFormatMap {
    1:     const char          *format;
    1:     size_t              length;
    1:     JSArgumentFormatter formatter;
    1:     JSArgumentFormatMap *next;
    1: };
    1: #endif
    1: 
    1: struct JSStackHeader {
    1:     uintN               nslots;
    1:     JSStackHeader       *down;
    1: };
    1: 
    1: #define JS_STACK_SEGMENT(sh)    ((jsval *)(sh) + 2)
    1: 
    1: /*
    1:  * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
    1:  * here because all consumers need to see these declarations (and not just the
    1:  * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
    1:  * declaration), along with cx->resolvingTable.
    1:  */
    1: typedef struct JSResolvingKey {
    1:     JSObject            *obj;
    1:     jsid                id;
    1: } JSResolvingKey;
    1: 
    1: typedef struct JSResolvingEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSResolvingKey      key;
    1:     uint32              flags;
    1: } JSResolvingEntry;
    1: 
    1: #define JSRESFLAG_LOOKUP        0x1     /* resolving id from lookup */
    1: #define JSRESFLAG_WATCH         0x2     /* resolving id from watch */
    1: 
 3235: /*
 3235:  * Macros to push/pop JSTempValueRooter instances to context-linked stack of
 3235:  * temporary GC roots. If you need to protect a result value that flows out of
 3235:  * a C function across several layers of other functions, use the
 3235:  * js_LeaveLocalRootScopeWithResult internal API (see further below) instead.
 3235:  *
10448:  * The macros also provide a simple way to get a single rooted pointer via
10448:  * JS_PUSH_TEMP_ROOT_<KIND>(cx, NULL, &tvr). Then &tvr.u.<kind> gives the
10448:  * necessary pointer.
10448:  *
 3235:  * JSTempValueRooter.count defines the type of the rooted value referenced by
10448:  * JSTempValueRooter.u union of type JSTempValueUnion. When count is positive
10448:  * or zero, u.array points to a vector of jsvals. Otherwise it must be one of
10448:  * the following constants:
 3235:  */
10448: #define JSTVU_SINGLE        (-1)    /* u.value or u.<gcthing> is single jsval
32694:                                        or non-JSString GC-thing pointer */
10448: #define JSTVU_TRACE         (-2)    /* u.trace is a hook to trace a custom
10448:                                      * structure */
10448: #define JSTVU_SPROP         (-3)    /* u.sprop roots property tree node */
10448: #define JSTVU_WEAK_ROOTS    (-4)    /* u.weakRoots points to saved weak roots */
27012: #define JSTVU_COMPILER      (-5)    /* u.compiler roots JSCompiler* */
10448: #define JSTVU_SCRIPT        (-6)    /* u.script roots JSScript* */
33128: #define JSTVU_ENUMERATOR    (-7)    /* a pointer to JSTempValueRooter points
33128:                                        to an instance of JSAutoEnumStateRooter
33128:                                        with u.object storing the enumeration
33128:                                        object */
    1: 
    1: /*
32694:  * Here single JSTVU_SINGLE covers both jsval and pointers to almost (see note
32694:  * below) any GC-thing via reinterpreting the thing as JSVAL_OBJECT. This works
32694:  * because the GC-thing is aligned on a 0 mod 8 boundary, and object has the 0
32694:  * jsval tag. So any GC-heap-allocated thing pointer may be tagged as if it
32694:  * were an object and untagged, if it's then used only as an opaque pointer
32694:  * until discriminated by other means than tag bits. This is how, for example,
32694:  * js_GetGCThingTraceKind uses its |thing| parameter -- it consults GC-thing
32694:  * flags stored separately from the thing to decide the kind of thing.
32694:  *
32694:  * Note well that JSStrings may be statically allocated (see the intStringTable
32694:  * and unitStringTable static arrays), so this hack does not work for arbitrary
32694:  * GC-thing pointers.
    1:  */
10448: #define JS_PUSH_TEMP_ROOT_COMMON(cx,x,tvr,cnt,kind)                           \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT((cx)->tempValueRooters != (tvr));                           \
10448:         (tvr)->count = (cnt);                                                 \
10448:         (tvr)->u.kind = (x);                                                  \
    1:         (tvr)->down = (cx)->tempValueRooters;                                 \
    1:         (cx)->tempValueRooters = (tvr);                                       \
    1:     JS_END_MACRO
    1: 
    1: #define JS_POP_TEMP_ROOT(cx,tvr)                                              \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT((cx)->tempValueRooters == (tvr));                           \
    1:         (cx)->tempValueRooters = (tvr)->down;                                 \
    1:     JS_END_MACRO
    1: 
10448: #define JS_PUSH_TEMP_ROOT(cx,cnt,arr,tvr)                                     \
    1:     JS_BEGIN_MACRO                                                            \
10448:         JS_ASSERT((int)(cnt) >= 0);                                           \
10448:         JS_PUSH_TEMP_ROOT_COMMON(cx, arr, tvr, (ptrdiff_t) (cnt), array);     \
    1:     JS_END_MACRO
    1: 
10448: #define JS_PUSH_SINGLE_TEMP_ROOT(cx,val,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, val, tvr, JSTVU_SINGLE, value)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_OBJECT(cx,obj,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, obj, tvr, JSTVU_SINGLE, object)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_STRING(cx,str,tvr)                                  \
32696:     JS_PUSH_SINGLE_TEMP_ROOT(cx, str ? STRING_TO_JSVAL(str) : JSVAL_NULL, tvr)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_XML(cx,xml_,tvr)                                    \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, xml_, tvr, JSTVU_SINGLE, xml)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_TRACE(cx,trace_,tvr)                                \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, trace_, tvr, JSTVU_TRACE, trace)
10448: 
    1: #define JS_PUSH_TEMP_ROOT_SPROP(cx,sprop_,tvr)                                \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, sprop_, tvr, JSTVU_SPROP, sprop)
    1: 
    1: #define JS_PUSH_TEMP_ROOT_WEAK_COPY(cx,weakRoots_,tvr)                        \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, weakRoots_, tvr, JSTVU_WEAK_ROOTS, weakRoots)
    1: 
27012: #define JS_PUSH_TEMP_ROOT_COMPILER(cx,pc,tvr)                                 \
27012:     JS_PUSH_TEMP_ROOT_COMMON(cx, pc, tvr, JSTVU_COMPILER, compiler)
 3235: 
 7359: #define JS_PUSH_TEMP_ROOT_SCRIPT(cx,script_,tvr)                              \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, script_, tvr, JSTVU_SCRIPT, script)
 7359: 
19712: #define JSRESOLVE_INFER         0xffff  /* infer bits from current bytecode */
19712: 
    1: struct JSContext {
 9780:     /*
25087:      * If this flag is set, we were asked to call back the operation callback
25087:      * as soon as possible.
 9780:      */
25087:     volatile jsint      operationCallbackFlag;
    1: 
23092:     /* JSRuntime contextList linkage. */
23092:     JSCList             link;
23092: 
    1: #if JS_HAS_XML_SUPPORT
    1:     /*
    1:      * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
    1:      * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
    1:      * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
    1:      * property values associated with this context's global object.
    1:      */
    1:     uint8               xmlSettingFlags;
18782:     uint8               padding;
18041: #else
18782:     uint16              padding;
    1: #endif
    1: 
18041:     /*
18308:      * Classic Algol "display" static link optimization.
18308:      */
27109: #define JS_DISPLAY_SIZE 16U
18308: 
18308:     JSStackFrame        *display[JS_DISPLAY_SIZE];
18308: 
    1:     /* Runtime version control identifier. */
    1:     uint16              version;
    1: 
    1:     /* Per-context options. */
    1:     uint32              options;            /* see jsapi.h for JSOPTION_* */
    1: 
    1:     /* Locale specific callbacks for string conversion. */
    1:     JSLocaleCallbacks   *localeCallbacks;
    1: 
    1:     /*
    1:      * cx->resolvingTable is non-null and non-empty if we are initializing
    1:      * standard classes lazily, or if we are otherwise recursing indirectly
    1:      * from js_LookupProperty through a JSClass.resolve hook.  It is used to
    1:      * limit runaway recursion (see jsapi.c and jsobj.c).
    1:      */
    1:     JSDHashTable        *resolvingTable;
    1: 
    1:     /*
    1:      * True if generating an error, to prevent runaway recursion.
31815:      * NB: generatingError packs with insideGCMarkCallback and throwing below.
    1:      */
    1:     JSPackedBool        generatingError;
    1: 
    1:     /* Flag to indicate that we run inside gcCallback(cx, JSGC_MARK_END). */
    1:     JSPackedBool        insideGCMarkCallback;
    1: 
    1:     /* Exception state -- the exception member is a GC root by definition. */
    1:     JSPackedBool        throwing;           /* is there a pending exception? */
    1:     jsval               exception;          /* most-recently-thrown exception */
    1: 
 5344:     /* Limit pointer for checking native stack consumption during recursion. */
    1:     jsuword             stackLimit;
    1: 
 5344:     /* Quota on the size of arenas used to compile and execute scripts. */
 5344:     size_t              scriptStackQuota;
 5344: 
    1:     /* Data shared by threads in an address space. */
32777:     JSRuntime * const   runtime;
32777: 
32777:     explicit JSContext(JSRuntime *rt) : runtime(rt) {}
    1: 
    1:     /* Stack arena pool and frame pointer register. */
24499:     JS_REQUIRES_STACK
    1:     JSArenaPool         stackPool;
22652: 
22652:     JS_REQUIRES_STACK
    1:     JSStackFrame        *fp;
    1: 
    1:     /* Temporary arena pool used while compiling and decompiling. */
    1:     JSArenaPool         tempPool;
    1: 
    1:     /* Top-level object and pointer to top stack frame's scope chain. */
    1:     JSObject            *globalObject;
    1: 
    1:     /* Storage to root recently allocated GC things and script result. */
    1:     JSWeakRoots         weakRoots;
    1: 
    1:     /* Regular expression class statics (XXX not shared globally). */
    1:     JSRegExpStatics     regExpStatics;
    1: 
    1:     /* State for object and array toSource conversion. */
    1:     JSSharpObjectMap    sharpObjectMap;
32750:     JSHashTable         *busyArrayTable;
    1: 
    1:     /* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */
    1:     JSArgumentFormatMap *argumentFormatMap;
    1: 
    1:     /* Last message string and trace file for debugging. */
    1:     char                *lastMessage;
    1: #ifdef DEBUG
    1:     void                *tracefp;
27233:     jsbytecode          *tracePrevPc;
    1: #endif
    1: 
 9780:     /* Per-context optional error reporter. */
    1:     JSErrorReporter     errorReporter;
    1: 
25087:     /* Branch callback. */
 9780:     JSOperationCallback operationCallback;
 9780: 
    1:     /* Interpreter activation count. */
    1:     uintN               interpLevel;
    1: 
20312:     /* Client opaque pointers. */
    1:     void                *data;
20312:     void                *data2;
    1: 
    1:     /* GC and thread-safe state. */
    1:     JSStackFrame        *dormantFrameChain; /* dormant stack frame to scan */
    1: #ifdef JS_THREADSAFE
    1:     JSThread            *thread;
    1:     jsrefcount          requestDepth;
 7286:     /* Same as requestDepth but ignoring JS_SuspendRequest/JS_ResumeRequest */
 7286:     jsrefcount          outstandingRequests;
11739:     JSTitle             *lockedSealedTitle; /* weak ref, for low-cost sealed
11739:                                                title locking */
    1:     JSCList             threadLinks;        /* JSThread contextList linkage */
    1: 
    1: #define CX_FROM_THREAD_LINKS(tl) \
    1:     ((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))
    1: #endif
    1: 
    1:     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
    1:     JSStackHeader       *stackHeaders;
    1: 
    1:     /* Stack of thread-stack-allocated temporary GC roots. */
    1:     JSTempValueRooter   *tempValueRooters;
 2433: 
 2433:     /* Debug hooks associated with the current context. */
35331:     const JSDebugHooks  *debugHooks;
18870: 
18870:     /* Security callbacks that override any defined on the runtime. */
18870:     JSSecurityCallbacks *securityCallbacks;
19196: 
19196:     /* Pinned regexp pool used for regular expressions. */
19196:     JSArenaPool         regexpPool;
19712: 
19712:     /* Stored here to avoid passing it around as a parameter. */
19712:     uintN               resolveFlags;
24598: 
24612: #ifdef JS_TRACER
24612:     /*
24612:      * State for the current tree execution.  bailExit is valid if the tree has
24612:      * called back into native code via a _FAIL builtin and has not yet bailed,
24612:      * else garbage (NULL in debug builds).
24612:      */
24612:     InterpState         *interpState;
24612:     VMSideExit          *bailExit;
35331: 
35331:     /*
35331:      * True if traces may be executed. Invariant: The value of jitEnabled is
35331:      * always equal to the expression in updateJITEnabled below.
35331:      *
35331:      * This flag and the fields accessed by updateJITEnabled are written only
35331:      * in runtime->gcLock, to avoid race conditions that would leave the wrong
35331:      * value in jitEnabled. (But the interpreter reads this without
35331:      * locking. That can race against another thread setting debug hooks, but
35331:      * we always read cx->debugHooks without locking anyway.)
35331:      */
35331:     bool                 jitEnabled;
24612: #endif
30453: 
35331:     /* Caller must be holding runtime->gcLock. */
35331:     void updateJITEnabled() {
35331: #ifdef JS_TRACER
35331:         jitEnabled = ((options & JSOPTION_JIT) &&
35331:                       !runtime->debuggerInhibitsJIT() &&
35331:                       debugHooks == &runtime->globalDebugHooks);
35331: #endif
35331:     }
35331: 
30851: #ifdef JS_THREADSAFE
32553:     inline void createDeallocatorTask() {
35075:         JS_ASSERT(!thread->deallocatorTask);
30851:         if (runtime->deallocatorThread && !runtime->deallocatorThread->busy())
35075:             thread->deallocatorTask = new JSFreePointerListTask();
30851:     }
30851: 
30851:     inline void submitDeallocatorTask() {
35075:         if (thread->deallocatorTask) {
35075:             runtime->deallocatorThread->schedule(thread->deallocatorTask);
35075:             thread->deallocatorTask = NULL;
30851:         }
30851:     }
30851: #endif
30851: 
34288:     ptrdiff_t &getMallocCounter() {
34288: #ifdef JS_THREADSAFE
34288:         return thread->gcThreadMallocBytes;
34288: #else
34288:         return runtime->gcMallocBytes;
34288: #endif
34288:     }
34288: 
34288:     /*
34288:      * Call this after allocating memory held by GC things, to update memory
34288:      * pressure counters or report the OOM error if necessary.
34288:      */
34288:     inline void updateMallocCounter(void *p, size_t nbytes) {
34288:         JS_ASSERT(ptrdiff_t(nbytes) >= 0);
34288:         ptrdiff_t &counter = getMallocCounter();
34288:         counter -= ptrdiff_t(nbytes);
34288:         if (!p || counter <= 0)
34288:             checkMallocGCPressure(p);
34288:     }
34288: 
34288:     /*
34288:      * Call this after successfully allocating memory held by GC things, to
34288:      * update memory pressure counters.
34288:      */
32553:     inline void updateMallocCounter(size_t nbytes) {
34288:         JS_ASSERT(ptrdiff_t(nbytes) >= 0);
34288:         ptrdiff_t &counter = getMallocCounter();
34288:         counter -= ptrdiff_t(nbytes);
34288:         if (counter <= 0) {
34288:             /*
34288:              * Use 1 as an arbitrary non-null pointer indicating successful
34288:              * allocation.
34288:              */
34288:             checkMallocGCPressure(reinterpret_cast<void *>(jsuword(1)));
34288:         }
32553:     }
32553: 
30851:     inline void* malloc(size_t bytes) {
30851:         JS_ASSERT(bytes != 0);
30851:         void *p = runtime->malloc(bytes);
34288:         updateMallocCounter(p, bytes);
30851:         return p;
30851:     }
30851: 
33128:     inline void* mallocNoReport(size_t bytes) {
33128:         JS_ASSERT(bytes != 0);
33128:         void *p = runtime->malloc(bytes);
33128:         if (!p)
33128:             return NULL;
33128:         updateMallocCounter(bytes);
33128:         return p;
33128:     }
33128: 
30851:     inline void* calloc(size_t bytes) {
30851:         JS_ASSERT(bytes != 0);
30851:         void *p = runtime->calloc(bytes);
34288:         updateMallocCounter(p, bytes);
30851:         return p;
30851:     }
30851: 
30851:     inline void* realloc(void* p, size_t bytes) {
32553:         void *orig = p;
30851:         p = runtime->realloc(p, bytes);
34288: 
34288:         /*
34288:          * For compatibility we do not account for realloc that increases
34288:          * previously allocated memory.
34288:          */
34288:         updateMallocCounter(p, orig ? 0 : bytes);
30851:         return p;
30851:     }
30851: 
30851: #ifdef JS_THREADSAFE
30851:     inline void free(void* p) {
30851:         if (!p)
30851:             return;
30851:         if (thread) {
35075:             JSFreePointerListTask* task = thread->deallocatorTask;
30851:             if (task) {
30851:                 task->add(p);
30851:                 return;
30851:             }
30851:         }
30851:         runtime->free(p);
30851:     }
30851: #else
30851:     inline void free(void* p) {
30851:         if (!p)
30851:             return;
30851:         runtime->free(p);
30851:     }
30851: #endif
32651: 
32651:     /*
32651:      * In the common case that we'd like to allocate the memory for an object
32651:      * with cx->malloc/free, we cannot use overloaded C++ operators (no
32651:      * placement delete).  Factor the common workaround into one place.
32651:      */
32651: #define CREATE_BODY(parms)                                                    \
32651:     void *memory = this->malloc(sizeof(T));                                   \
34288:     if (!memory)                                                              \
32651:         return NULL;                                                          \
32651:     return new(memory) T parms;
32651: 
32651:     template <class T>
32651:     JS_ALWAYS_INLINE T *create() {
32651:         CREATE_BODY(())
32651:     }
32651: 
32651:     template <class T, class P1>
32651:     JS_ALWAYS_INLINE T *create(const P1 &p1) {
32651:         CREATE_BODY((p1))
32651:     }
32651: 
32651:     template <class T, class P1, class P2>
32651:     JS_ALWAYS_INLINE T *create(const P1 &p1, const P2 &p2) {
32651:         CREATE_BODY((p1, p2))
32651:     }
32651: 
32651:     template <class T, class P1, class P2, class P3>
32651:     JS_ALWAYS_INLINE T *create(const P1 &p1, const P2 &p2, const P3 &p3) {
32651:         CREATE_BODY((p1, p2, p3))
32651:     }
32651: #undef CREATE_BODY
32651: 
32651:     template <class T>
32651:     JS_ALWAYS_INLINE void destroy(T *p) {
32651:         p->~T();
32651:         this->free(p);
32651:     }
34288: 
34288: private:
34288: 
34288:     /*
34288:      * The allocation code calls the function to indicate either OOM failure
34288:      * when p is null or that a memory pressure counter has reached some
34288:      * threshold when p is not null. The function takes the pointer and not
34288:      * a boolean flag to minimize the amount of code in its inlined callers.
34288:      */
34288:     void checkMallocGCPressure(void *p);
    1: };
    1: 
    1: #ifdef JS_THREADSAFE
    1: # define JS_THREAD_ID(cx)       ((cx)->thread ? (cx)->thread->id : 0)
    1: #endif
    1: 
    1: #ifdef __cplusplus
24293: 
24293: static inline JSAtom **
24293: FrameAtomBase(JSContext *cx, JSStackFrame *fp)
24293: {
24293:     return fp->imacpc
24293:            ? COMMON_ATOMS_START(&cx->runtime->atomState)
24293:            : fp->script->atomMap.vector;
24293: }
24293: 
    1: /* FIXME(bug 332648): Move this into a public header. */
    1: class JSAutoTempValueRooter
    1: {
    1:   public:
33538:     JSAutoTempValueRooter(JSContext *cx, size_t len, jsval *vec
33538:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
    1:         : mContext(cx) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
    1:         JS_PUSH_TEMP_ROOT(mContext, len, vec, &mTvr);
    1:     }
33538:     explicit JSAutoTempValueRooter(JSContext *cx, jsval v = JSVAL_NULL
33538:                                    JS_GUARD_OBJECT_NOTIFIER_PARAM)
    1:         : mContext(cx) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
    1:         JS_PUSH_SINGLE_TEMP_ROOT(mContext, v, &mTvr);
    1:     }
33538:     JSAutoTempValueRooter(JSContext *cx, JSString *str
33538:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
23914:         : mContext(cx) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
23914:         JS_PUSH_TEMP_ROOT_STRING(mContext, str, &mTvr);
23914:     }
33538:     JSAutoTempValueRooter(JSContext *cx, JSObject *obj
33538:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
26238:         : mContext(cx) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
26238:         JS_PUSH_TEMP_ROOT_OBJECT(mContext, obj, &mTvr);
26238:     }
34312:     JSAutoTempValueRooter(JSContext *cx, JSScopeProperty *sprop
34312:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
34312:         : mContext(cx) {
34312:         JS_GUARD_OBJECT_NOTIFIER_INIT;
34312:         JS_PUSH_TEMP_ROOT_SPROP(mContext, sprop, &mTvr);
34312:     }
    1: 
    1:     ~JSAutoTempValueRooter() {
    1:         JS_POP_TEMP_ROOT(mContext, &mTvr);
    1:     }
    1: 
25094:     jsval value() { return mTvr.u.value; }
25094:     jsval *addr() { return &mTvr.u.value; }
25094: 
20444:   protected:
20444:     JSContext *mContext;
20444: 
    1:   private:
15009: #ifndef AIX
    1:     static void *operator new(size_t);
    1:     static void operator delete(void *, size_t);
15009: #endif
    1: 
    1:     JSTempValueRooter mTvr;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
    1: };
19712: 
25094: class JSAutoTempIdRooter
25094: {
25094:   public:
33538:     explicit JSAutoTempIdRooter(JSContext *cx, jsid id = INT_TO_JSID(0)
33538:                                 JS_GUARD_OBJECT_NOTIFIER_PARAM)
25094:         : mContext(cx) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
25094:         JS_PUSH_SINGLE_TEMP_ROOT(mContext, ID_TO_VALUE(id), &mTvr);
25094:     }
25094: 
25094:     ~JSAutoTempIdRooter() {
25094:         JS_POP_TEMP_ROOT(mContext, &mTvr);
25094:     }
25094: 
25094:     jsid id() { return (jsid) mTvr.u.value; }
25094:     jsid * addr() { return (jsid *) &mTvr.u.value; }
25094: 
25094:   private:
25094:     JSContext *mContext;
25094:     JSTempValueRooter mTvr;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
25094: };
25094: 
33155: class JSAutoIdArray {
33155:   public:
33538:     JSAutoIdArray(JSContext *cx, JSIdArray *ida
33538:                   JS_GUARD_OBJECT_NOTIFIER_PARAM)
33538:         : cx(cx), idArray(ida) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
33155:         if (ida)
33155:             JS_PUSH_TEMP_ROOT(cx, ida->length, ida->vector, &tvr);
33155:     }
33155:     ~JSAutoIdArray() {
33155:         if (idArray) {
33155:             JS_POP_TEMP_ROOT(cx, &tvr);
33155:             JS_DestroyIdArray(cx, idArray);
33155:         }
33155:     }
33155:     bool operator!() {
33155:         return idArray == NULL;
33155:     }
33155:     jsid operator[](size_t i) const {
33155:         JS_ASSERT(idArray);
33155:         JS_ASSERT(i < size_t(idArray->length));
33155:         return idArray->vector[i];
33155:     }
33155:     size_t length() const {
33155:          return idArray->length;
33155:     }
33155:   private:
33155:     JSContext * const cx;
33155:     JSIdArray * const idArray;
33155:     JSTempValueRooter tvr;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
33155: };
33155: 
33128: /* The auto-root for enumeration object and its state. */
33128: class JSAutoEnumStateRooter : public JSTempValueRooter
33128: {
33128:   public:
33538:     JSAutoEnumStateRooter(JSContext *cx, JSObject *obj, jsval *statep
33538:                           JS_GUARD_OBJECT_NOTIFIER_PARAM)
33128:         : mContext(cx), mStatep(statep)
33128:     {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
33128:         JS_ASSERT(obj);
33128:         JS_ASSERT(statep);
33128:         JS_PUSH_TEMP_ROOT_COMMON(cx, obj, this, JSTVU_ENUMERATOR, object);
33128:     }
33128: 
33128:     ~JSAutoEnumStateRooter() {
33128:         JS_POP_TEMP_ROOT(mContext, this);
33128:     }
33128: 
33128:     void mark(JSTracer *trc) {
33128:         JS_CALL_OBJECT_TRACER(trc, u.object, "enumerator_obj");
33128:         js_MarkEnumeratorState(trc, u.object, *mStatep);
33128:     }
33128: 
33128:   private:
33128:     JSContext   *mContext;
33128:     jsval       *mStatep;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
33128: };
33128: 
19712: class JSAutoResolveFlags
19712: {
19712:   public:
33538:     JSAutoResolveFlags(JSContext *cx, uintN flags
33538:                        JS_GUARD_OBJECT_NOTIFIER_PARAM)
19712:         : mContext(cx), mSaved(cx->resolveFlags) {
33538:         JS_GUARD_OBJECT_NOTIFIER_INIT;
19712:         cx->resolveFlags = flags;
19712:     }
19712: 
19712:     ~JSAutoResolveFlags() { mContext->resolveFlags = mSaved; }
19712: 
19712:   private:
19712:     JSContext *mContext;
19712:     uintN mSaved;
33538:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
19712: };
24293: 
24293: #endif /* __cpluscplus */
    1: 
    1: /*
    1:  * Slightly more readable macros for testing per-context option settings (also
    1:  * to hide bitset implementation detail).
    1:  *
    1:  * JSOPTION_XML must be handled specially in order to propagate from compile-
    1:  * to run-time (from cx->options to script->version/cx->version).  To do that,
    1:  * we copy JSOPTION_XML from cx->options into cx->version as JSVERSION_HAS_XML
    1:  * whenever options are set, and preserve this XML flag across version number
    1:  * changes done via the JS_SetVersion API.
    1:  *
    1:  * But when executing a script or scripted function, the interpreter changes
    1:  * cx->version, including the XML flag, to script->version.  Thus JSOPTION_XML
    1:  * is a compile-time option that causes a run-time version change during each
    1:  * activation of the compiled script.  That version change has the effect of
    1:  * changing JS_HAS_XML_OPTION, so that any compiling done via eval enables XML
    1:  * support.  If an XML-enabled script or function calls a non-XML function,
    1:  * the flag bit will be cleared during the callee's activation.
    1:  *
    1:  * Note that JS_SetVersion API calls never pass JSVERSION_HAS_XML or'd into
    1:  * that API's version parameter.
    1:  *
    1:  * Note also that script->version must contain this XML option flag in order
    1:  * for XDR'ed scripts to serialize and deserialize with that option preserved
    1:  * for detection at run-time.  We can't copy other compile-time options into
    1:  * script->version because that would break backward compatibility (certain
    1:  * other options, e.g. JSOPTION_VAROBJFIX, are analogous to JSOPTION_XML).
    1:  */
    1: #define JS_HAS_OPTION(cx,option)        (((cx)->options & (option)) != 0)
    1: #define JS_HAS_STRICT_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_STRICT)
    1: #define JS_HAS_WERROR_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_WERROR)
    1: #define JS_HAS_COMPILE_N_GO_OPTION(cx)  JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)
    1: #define JS_HAS_ATLINE_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_ATLINE)
    1: 
    1: #define JSVERSION_MASK                  0x0FFF  /* see JSVersion in jspubtd.h */
    1: #define JSVERSION_HAS_XML               0x1000  /* flag induced by XML option */
24375: #define JSVERSION_ANONFUNFIX            0x2000  /* see jsapi.h, the comments
24375:                                                    for JSOPTION_ANONFUNFIX */
    1: 
 3164: #define JSVERSION_NUMBER(cx)            ((JSVersion)((cx)->version &          \
 3164:                                                      JSVERSION_MASK))
    1: #define JS_HAS_XML_OPTION(cx)           ((cx)->version & JSVERSION_HAS_XML || \
    1:                                          JSVERSION_NUMBER(cx) >= JSVERSION_1_6)
    1: 
34365: extern JSThreadData *
34365: js_CurrentThreadData(JSRuntime *rt);
34365: 
    1: extern JSBool
26569: js_InitThreads(JSRuntime *rt);
    1: 
26569: extern void
26569: js_FinishThreads(JSRuntime *rt);
26569: 
26569: extern void
26569: js_PurgeThreads(JSContext *cx);
22627: 
31843: extern void
31843: js_TraceThreads(JSRuntime *rt, JSTracer *trc);
31843: 
22627: /*
24874:  * Ensures the JSOPTION_XML and JSOPTION_ANONFUNFIX bits of cx->options are
24874:  * reflected in cx->version, since each bit must travel with a script that has
24874:  * it set.
24874:  */
24874: extern void
24874: js_SyncOptionsToVersion(JSContext *cx);
24874: 
24874: /*
    1:  * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
    1:  * data that depends on version.
    1:  */
    1: extern void
    1: js_OnVersionChange(JSContext *cx);
    1: 
    1: /*
    1:  * Unlike the JS_SetVersion API, this function stores JSVERSION_HAS_XML and
    1:  * any future non-version-number flags induced by compiler options.
    1:  */
    1: extern void
    1: js_SetVersion(JSContext *cx, JSVersion version);
    1: 
    1: /*
    1:  * Create and destroy functions for JSContext, which is manually allocated
    1:  * and exclusively owned.
    1:  */
    1: extern JSContext *
    1: js_NewContext(JSRuntime *rt, size_t stackChunkSize);
    1: 
    1: extern void
    1: js_DestroyContext(JSContext *cx, JSDestroyContextMode mode);
    1: 
    1: /*
    1:  * Return true if cx points to a context in rt->contextList, else return false.
11739:  * NB: the caller (see jslock.c:ClaimTitle) must hold rt->gcLock.
    1:  */
    1: extern JSBool
    1: js_ValidContextPointer(JSRuntime *rt, JSContext *cx);
    1: 
23092: static JS_INLINE JSContext *
23092: js_ContextFromLinkField(JSCList *link)
23092: {
23092:     JS_ASSERT(link);
23092:     return (JSContext *) ((uint8 *) link - offsetof(JSContext, link));
23092: }
23092: 
    1: /*
    1:  * If unlocked, acquire and release rt->gcLock around *iterp update; otherwise
    1:  * the caller must be holding rt->gcLock.
    1:  */
23442: extern JSContext *
    1: js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp);
    1: 
    1: /*
25087:  * Iterate through contexts with active requests. The caller must be holding
25087:  * rt->gcLock in case of a thread-safe build, or otherwise guarantee that the
25087:  * context list is not alternated asynchroniously.
25087:  */
25087: extern JS_FRIEND_API(JSContext *)
25087: js_NextActiveContext(JSRuntime *, JSContext *);
25087: 
27384: #ifdef JS_THREADSAFE
27384: 
27384: /*
27384:  * Count the number of contexts entered requests on the current thread.
27384:  */
27384: uint32
27384: js_CountThreadRequests(JSContext *cx);
27384: 
27384: /*
27384:  * This is a helper for code at can potentially run outside JS request to
27384:  * ensure that the GC is not running when the function returns.
27384:  *
27384:  * This function must be called with the GC lock held.
27384:  */
27384: extern void
27384: js_WaitForGC(JSRuntime *rt);
27384: 
27384: /*
27384:  * If we're in one or more requests (possibly on more than one context)
27384:  * running on the current thread, indicate, temporarily, that all these
27384:  * requests are inactive so a possible GC can proceed on another thread.
27384:  * This function returns the number of discounted requests. The number must
27384:  * be passed later to js_ActivateRequestAfterGC to reactivate the requests.
27384:  *
27384:  * This function must be called with the GC lock held.
27384:  */
27384: uint32
27384: js_DiscountRequestsForGC(JSContext *cx);
27384: 
27384: /*
27384:  * This function must be called with the GC lock held.
27384:  */
27384: void
27384: js_RecountRequestsAfterGC(JSRuntime *rt, uint32 requestDebit);
27384: 
27384: #else /* !JS_THREADSAFE */
27384: 
27384: # define js_WaitForGC(rt)    ((void) 0)
27384: 
27384: #endif
27384: 
25087: /*
    1:  * JSClass.resolve and watchpoint recursion damping machinery.
    1:  */
    1: extern JSBool
    1: js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                   JSResolvingEntry **entryp);
    1: 
    1: extern void
    1: js_StopResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                  JSResolvingEntry *entry, uint32 generation);
    1: 
    1: /*
    1:  * Local root set management.
    1:  *
    1:  * NB: the jsval parameters below may be properly tagged jsvals, or GC-thing
    1:  * pointers cast to (jsval).  This relies on JSObject's tag being zero, but
    1:  * on the up side it lets us push int-jsval-encoded scopeMark values on the
    1:  * local root stack.
    1:  */
    1: extern JSBool
    1: js_EnterLocalRootScope(JSContext *cx);
    1: 
    1: #define js_LeaveLocalRootScope(cx) \
    1:     js_LeaveLocalRootScopeWithResult(cx, JSVAL_NULL)
    1: 
    1: extern void
    1: js_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval);
    1: 
    1: extern void
    1: js_ForgetLocalRoot(JSContext *cx, jsval v);
    1: 
    1: extern int
    1: js_PushLocalRoot(JSContext *cx, JSLocalRootStack *lrs, jsval v);
    1: 
    1: /*
    1:  * Report an exception, which is currently realized as a printf-style format
    1:  * string and its arguments.
    1:  */
    1: typedef enum JSErrNum {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     name = number,
    1: #include "js.msg"
    1: #undef MSG_DEF
    1:     JSErr_Limit
    1: } JSErrNum;
    1: 
18543: extern JS_FRIEND_API(const JSErrorFormatString *)
    1: js_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
    1: 
    1: #ifdef va_start
    1: extern JSBool
    1: js_ReportErrorVA(JSContext *cx, uintN flags, const char *format, va_list ap);
    1: 
    1: extern JSBool
    1: js_ReportErrorNumberVA(JSContext *cx, uintN flags, JSErrorCallback callback,
    1:                        void *userRef, const uintN errorNumber,
    1:                        JSBool charArgs, va_list ap);
    1: 
    1: extern JSBool
    1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
    1:                         void *userRef, const uintN errorNumber,
    1:                         char **message, JSErrorReport *reportp,
35302:                         bool charArgs, va_list ap);
    1: #endif
    1: 
    1: extern void
    1: js_ReportOutOfMemory(JSContext *cx);
    1: 
    1: /*
 8296:  * Report that cx->scriptStackQuota is exhausted.
 8296:  */
 8296: extern void
 8296: js_ReportOutOfScriptQuota(JSContext *cx);
 8296: 
 8296: extern void
 8296: js_ReportOverRecursed(JSContext *cx);
 8296: 
12983: extern void
12983: js_ReportAllocationOverflow(JSContext *cx);
12983: 
11139: #define JS_CHECK_RECURSION(cx, onerror)                                       \
11139:     JS_BEGIN_MACRO                                                            \
11139:         int stackDummy_;                                                      \
11139:                                                                               \
11139:         if (!JS_CHECK_STACK_SIZE(cx, stackDummy_)) {                          \
11139:             js_ReportOverRecursed(cx);                                        \
11139:             onerror;                                                          \
11139:         }                                                                     \
11139:     JS_END_MACRO
11139: 
 8296: /*
    1:  * Report an exception using a previously composed JSErrorReport.
    1:  * XXXbe remove from "friend" API
    1:  */
    1: extern JS_FRIEND_API(void)
    1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *report);
    1: 
    1: extern void
    1: js_ReportIsNotDefined(JSContext *cx, const char *name);
    1: 
    1: /*
 7897:  * Report an attempt to access the property of a null or undefined value (v).
 7897:  */
 7897: extern JSBool
 7897: js_ReportIsNullOrUndefined(JSContext *cx, intN spindex, jsval v,
 7897:                            JSString *fallback);
 7897: 
16519: extern void
16519: js_ReportMissingArg(JSContext *cx, jsval *vp, uintN arg);
16519: 
 7897: /*
    1:  * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
    1:  * the first argument for the error message. If the error message has less
    1:  * then 3 arguments, use null for arg1 or arg2.
    1:  */
    1: extern JSBool
    1: js_ReportValueErrorFlags(JSContext *cx, uintN flags, const uintN errorNumber,
    1:                          intN spindex, jsval v, JSString *fallback,
    1:                          const char *arg1, const char *arg2);
    1: 
    1: #define js_ReportValueError(cx,errorNumber,spindex,v,fallback)                \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, NULL, NULL))
    1: 
    1: #define js_ReportValueError2(cx,errorNumber,spindex,v,fallback,arg1)          \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, NULL))
    1: 
    1: #define js_ReportValueError3(cx,errorNumber,spindex,v,fallback,arg1,arg2)     \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, arg2))
    1: 
    1: extern JSErrorFormatString js_ErrorFormatString[JSErr_Limit];
    1: 
    1: /*
    1:  * See JS_SetThreadStackLimit in jsapi.c, where we check that the stack grows
    1:  * in the expected direction.  On Unix-y systems, JS_STACK_GROWTH_DIRECTION is
    1:  * computed on the build host by jscpucfg.c and written into jsautocfg.h.  The
    1:  * macro is hardcoded in jscpucfg.h on Windows and Mac systems (for historical
    1:  * reasons pre-dating autoconf usage).
    1:  */
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) < (cx)->stackLimit)
    1: #else
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) > (cx)->stackLimit)
    1: #endif
    1: 
 9780: /*
25087:  * If the operation callback flag was set, call the operation callback.
 9780:  * This macro can run the full GC. Return true if it is OK to continue and
 9780:  * false otherwise.
 9780:  */
25087: #define JS_CHECK_OPERATION_LIMIT(cx) \
25087:     (!(cx)->operationCallbackFlag || js_InvokeOperationCallback(cx))
 9780: 
 9780: /*
25087:  * Invoke the operation callback and return false if the current execution
25087:  * is to be terminated.
    1:  */
    1: extern JSBool
25087: js_InvokeOperationCallback(JSContext *cx);
23726: 
27546: #ifndef JS_THREADSAFE
27546: # define js_TriggerAllOperationCallbacks(rt, gcLocked) \
27546:     js_TriggerAllOperationCallbacks (rt)
27546: #endif
27546: 
27546: void
27546: js_TriggerAllOperationCallbacks(JSRuntime *rt, JSBool gcLocked);
27546: 
25214: extern JSStackFrame *
25214: js_GetScriptedCaller(JSContext *cx, JSStackFrame *fp);
25214: 
26550: extern jsbytecode*
26550: js_GetCurrentBytecodePC(JSContext* cx);
26550: 
31911: extern bool
31911: js_CurrentPCIsInImacro(JSContext *cx);
31911: 
25214: #ifdef JS_TRACER
25214: /*
27882:  * Reconstruct the JS stack and clear cx->tracecx. We must be currently in a
27882:  * _FAIL builtin from trace on cx or another context on the same thread. The
27882:  * machine code for the trace remains on the C stack when js_DeepBail returns.
25214:  *
25214:  * Implemented in jstracer.cpp.
25214:  */
25214: JS_FORCES_STACK JS_FRIEND_API(void)
25214: js_DeepBail(JSContext *cx);
25214: #endif
25214: 
25214: static JS_FORCES_STACK JS_INLINE void
25214: js_LeaveTrace(JSContext *cx)
25214: {
25214: #ifdef JS_TRACER
25214:     if (JS_ON_TRACE(cx))
25214:         js_DeepBail(cx);
25214: #endif
25214: }
25214: 
27894: static JS_INLINE void
27894: js_LeaveTraceIfGlobalObject(JSContext *cx, JSObject *obj)
27894: {
27894:     if (!obj->fslots[JSSLOT_PARENT])
27894:         js_LeaveTrace(cx);
27894: }
27894: 
25214: static JS_INLINE JSBool
25214: js_CanLeaveTrace(JSContext *cx)
25214: {
25214:     JS_ASSERT(JS_ON_TRACE(cx));
25214: #ifdef JS_TRACER
25214:     return cx->bailExit != NULL;
25214: #else
25214:     return JS_FALSE;
25214: #endif
25214: }
25214: 
22652: /*
22652:  * Get the current cx->fp, first lazily instantiating stack frames if needed.
22652:  * (Do not access cx->fp directly except in JS_REQUIRES_STACK code.)
22652:  *
22652:  * Defined in jstracer.cpp if JS_TRACER is defined.
22652:  */
25214: static JS_FORCES_STACK JS_INLINE JSStackFrame *
25214: js_GetTopStackFrame(JSContext *cx)
25214: {
25214:     js_LeaveTrace(cx);
25214:     return cx->fp;
25214: }
22652: 
33121: static JS_INLINE JSBool
33121: js_IsPropertyCacheDisabled(JSContext *cx)
33121: {
33121:     return cx->runtime->shapeGen >= SHAPE_OVERFLOW_BIT;
33121: }
33121: 
27546: static JS_INLINE uint32
27546: js_RegenerateShapeForGC(JSContext *cx)
27546: {
27546:     JS_ASSERT(cx->runtime->gcRunning);
30733:     JS_ASSERT(cx->runtime->gcRegenShapes);
27546: 
27546:     /*
27546:      * Under the GC, compared with js_GenerateShape, we don't need to use
27546:      * atomic increments but we still must make sure that after an overflow
27546:      * the shape stays such.
27546:      */
27546:     uint32 shape = cx->runtime->shapeGen;
27546:     shape = (shape + 1) | (shape & SHAPE_OVERFLOW_BIT);
27546:     cx->runtime->shapeGen = shape;
27546:     return shape;
27546: }
27546: 
34299: namespace js {
34299: 
34299: /*
34299:  * Policy that calls JSContext:: memory functions and reports errors to the
34299:  * context.  Since the JSContext* given on construction is stored for the
34299:  * lifetime of the container, this policy may only be used for containers whose
34299:  * lifetime is a shorter than the given JSContext.
34299:  */
34299: class ContextAllocPolicy
34299: {
34299:     JSContext *mCx;
34299: 
34299:   public:
34299:     ContextAllocPolicy(JSContext *cx) : mCx(cx) {}
34299:     JSContext *context() const { return mCx; }
34299: 
34299:     void *malloc(size_t bytes) { return mCx->malloc(bytes); }
34299:     void free(void *p) { mCx->free(p); }
34299:     void *realloc(void *p, size_t bytes) { return mCx->realloc(p, bytes); }
34299:     void reportAllocOverflow() const { js_ReportAllocationOverflow(mCx); }
34299: };
34299: 
34299: }
34299: 
    1: #endif /* jscntxt_h___ */
