    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all our document implementations.
    1:  */
    1: 
    1: #ifndef nsDocument_h___
    1: #define nsDocument_h___
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCRT.h"
    1: #include "nsIDocument.h"
    1: #include "nsWeakReference.h"
    1: #include "nsWeakPtr.h"
    1: #include "nsVoidArray.h"
26413: #include "nsTArray.h"
    1: #include "nsHashSets.h"
    1: #include "nsIDOMXMLDocument.h"
68870: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSDocumentStyle.h"
    1: #include "nsIDOMDocumentRange.h"
    1: #include "nsIDOMDocumentTraversal.h"
    1: #include "nsStubDocumentObserver.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOMNSEventTarget.h"
    1: #include "nsIDOMStyleSheetList.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIContent.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIDOM3Node.h"
16106: #include "nsIDOMNodeSelector.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIParser.h"
    1: #include "nsBindingManager.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOM3DocumentEvent.h"
    1: #include "nsHashtable.h"
    1: #include "nsInterfaceHashtable.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIBoxObject.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIURI.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsIRadioGroupContainer.h"
    1: #include "nsIScriptEventManager.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsIRequest.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsTObserverArray.h"
    1: #include "nsStubMutationObserver.h"
    1: #include "nsIChannel.h"
    1: #include "nsCycleCollectionParticipant.h"
15474: #include "nsContentList.h"
16977: #include "nsGkAtoms.h"
18430: #include "nsIApplicationCache.h"
18430: #include "nsIApplicationCacheContainer.h"
    1: #include "nsStyleSet.h"
    1: #include "pldhash.h"
    1: #include "nsAttrAndChildArray.h"
    1: #include "nsDOMAttributeMap.h"
16056: #include "nsContentUtils.h"
16977: #include "nsThreadUtils.h"
20078: #include "nsIDocumentViewer.h"
29215: #include "nsIDOMXPathNSResolver.h"
20078: #include "nsIInterfaceRequestor.h"
21877: #include "nsILoadContext.h"
21877: #include "nsIProgressEventSink.h"
21877: #include "nsISecurityEventSink.h"
21877: #include "nsIChannelEventSink.h"
30065: #include "imgIRequest.h"
34007: #include "nsIDOMDOMImplementation.h"
    1: 
    1: #define XML_DECLARATION_BITS_DECLARATION_EXISTS   (1 << 0)
    1: #define XML_DECLARATION_BITS_ENCODING_EXISTS      (1 << 1)
    1: #define XML_DECLARATION_BITS_STANDALONE_EXISTS    (1 << 2)
    1: #define XML_DECLARATION_BITS_STANDALONE_YES       (1 << 3)
    1: 
    1: 
    1: class nsIEventListenerManager;
    1: class nsDOMStyleSheetList;
    1: class nsDOMStyleSheetSetList;
    1: class nsIOutputStream;
    1: class nsDocument;
    1: class nsIDTD;
    1: class nsIRadioVisitor;
    1: class nsIFormControl;
    1: struct nsRadioGroupStruct;
    1: class nsOnloadBlocker;
    1: class nsUnblockOnloadEvent;
    1: class nsChildContentList;
42984: class nsXMLEventsManager;
42984: class nsHTMLStyleSheet;
42984: class nsHTMLCSSStyleSheet;
    1: 
15474: /**
15474:  * Right now our identifier map entries contain information for 'name'
15474:  * and 'id' mappings of a given string. This is so that
15474:  * nsHTMLDocument::ResolveName only has to do one hash lookup instead
15474:  * of two. It's not clear whether this still matters for performance.
15474:  * 
15474:  * We also store the document.all result list here. This is mainly so that
15474:  * when all elements with the given ID are removed and we remove
15474:  * the ID's nsIdentifierMapEntry, the document.all result is released too.
15474:  * Perhaps the document.all results should have their own hashtable
15474:  * in nsHTMLDocument.
15474:  */
43946: class nsIdentifierMapEntry : public nsStringHashKey
15474: {
15474: public:
42325:   typedef mozilla::dom::Element Element;
42325:   
43946:   nsIdentifierMapEntry(const nsAString& aKey) :
43946:     nsStringHashKey(&aKey), mNameContentList(nsnull)
43946:   {
43946:   }
43946:   nsIdentifierMapEntry(const nsAString *aKey) :
43946:     nsStringHashKey(aKey), mNameContentList(nsnull)
15474:   {
15474:   }
15474:   nsIdentifierMapEntry(const nsIdentifierMapEntry& aOther) :
43946:     nsStringHashKey(&aOther.GetKey())
15474:   {
15474:     NS_ERROR("Should never be called");
15474:   }
15474:   ~nsIdentifierMapEntry();
15474: 
15474:   void SetInvalidName();
15474:   PRBool IsInvalidName();
42325:   void AddNameElement(Element* aElement);
42325:   void RemoveNameElement(Element* aElement);
50428:   PRBool IsEmpty();
15474:   nsBaseContentList* GetNameContentList() {
15474:     return mNameContentList;
15474:   }
15474: 
15474:   /**
15474:    * Returns the element if we know the element associated with this
15474:    * id. Otherwise returns null.
15474:    */
42325:   Element* GetIdElement();
26475:   /**
50428:    * If this entry has a non-null image element set (using SetImageElement),
50428:    * the image element will be returned, otherwise the same as GetIdElement().
50428:    */
50428:   Element* GetImageIdElement();
50428:   /**
26475:    * Append all the elements with this id to aElements
26475:    */
15475:   void AppendAllIdContent(nsCOMArray<nsIContent>* aElements);
15515:   /**
15515:    * This can fire ID change callbacks.
15515:    * @return true if the content could be added, false if we failed due
15515:    * to OOM.
15515:    */
42325:   PRBool AddIdElement(Element* aElement);
15475:   /**
15515:    * This can fire ID change callbacks.
15475:    */
50428:   void RemoveIdElement(Element* aElement);
50428:   /**
50428:    * Set the image element override for this ID. This will be returned by
50428:    * GetIdElement(PR_TRUE) if non-null.
50428:    */
50428:   void SetImageElement(Element* aElement);
15474: 
15515:   PRBool HasContentChangeCallback() { return mChangeCallbacks != nsnull; }
50428:   void AddContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
50428:                                 void* aData, PRBool aForImage);
50428:   void RemoveContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
50428:                                 void* aData, PRBool aForImage);
15515: 
15474:   void Traverse(nsCycleCollectionTraversalCallback* aCallback);
15474: 
15474:   void SetDocAllList(nsContentList* aContentList) { mDocAllList = aContentList; }
15474:   nsContentList* GetDocAllList() { return mDocAllList; }
15474: 
15515:   struct ChangeCallback {
15515:     nsIDocument::IDTargetObserver mCallback;
15515:     void* mData;
50428:     PRBool mForImage;
15515:   };
15515: 
15515:   struct ChangeCallbackEntry : public PLDHashEntryHdr {
15515:     typedef const ChangeCallback KeyType;
15515:     typedef const ChangeCallback* KeyTypePointer;
15515: 
15515:     ChangeCallbackEntry(const ChangeCallback* key) :
15515:       mKey(*key) { }
15515:     ChangeCallbackEntry(const ChangeCallbackEntry& toCopy) :
15515:       mKey(toCopy.mKey) { }
15515: 
15515:     KeyType GetKey() const { return mKey; }
15515:     PRBool KeyEquals(KeyTypePointer aKey) const {
15515:       return aKey->mCallback == mKey.mCallback &&
50428:              aKey->mData == mKey.mData &&
50428:              aKey->mForImage == mKey.mForImage;
15515:     }
15515: 
15515:     static KeyTypePointer KeyToPointer(KeyType& aKey) { return &aKey; }
15515:     static PLDHashNumber HashKey(KeyTypePointer aKey)
15515:     {
20340:       return (NS_PTR_TO_INT32(aKey->mCallback) >> 2) ^
20340:              (NS_PTR_TO_INT32(aKey->mData));
15515:     }
15515:     enum { ALLOW_MEMMOVE = PR_TRUE };
15515:     
15515:     ChangeCallback mKey;
15515:   };
15515: 
15474: private:
50428:   void FireChangeCallbacks(Element* aOldElement, Element* aNewElement,
50428:                            PRBool aImageOnly = PR_FALSE);
15515: 
41635:   // empty if there are no elementswith this ID.
51858:   // The elements are stored as weak pointers.
15474:   nsSmallVoidArray mIdContentList;
68823:   nsRefPtr<nsBaseContentList> mNameContentList;
15474:   nsRefPtr<nsContentList> mDocAllList;
15515:   nsAutoPtr<nsTHashtable<ChangeCallbackEntry> > mChangeCallbacks;
51986:   nsRefPtr<Element> mImageElement;
15474: };
    1: 
    1: class nsDocHeaderData
    1: {
    1: public:
    1:   nsDocHeaderData(nsIAtom* aField, const nsAString& aData)
    1:     : mField(aField), mData(aData), mNext(nsnull)
    1:   {
    1:   }
    1: 
    1:   ~nsDocHeaderData(void)
    1:   {
    1:     delete mNext;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> mField;
    1:   nsString          mData;
    1:   nsDocHeaderData*  mNext;
    1: };
    1: 
    1: class nsDOMStyleSheetList : public nsIDOMStyleSheetList,
    1:                             public nsStubDocumentObserver
    1: {
    1: public:
    1:   nsDOMStyleSheetList(nsIDocument *aDocument);
    1:   virtual ~nsDOMStyleSheetList();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOMSTYLESHEETLIST
    1: 
    1:   // nsIDocumentObserver
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETADDED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETREMOVED
56166: 
56166:   // nsIMutationObserver
56166:   NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
    1: 
20752:   nsIStyleSheet* GetItemAt(PRUint32 aIndex);
20752: 
20752:   static nsDOMStyleSheetList* FromSupports(nsISupports* aSupports)
20752:   {
20752:     nsIDOMStyleSheetList* list = static_cast<nsIDOMStyleSheetList*>(aSupports);
20752: #ifdef DEBUG
20752:     {
20752:       nsCOMPtr<nsIDOMStyleSheetList> list_qi = do_QueryInterface(aSupports);
20752: 
20752:       // If this assertion fires the QI implementation for the object in
20752:       // question doesn't use the nsIDOMStyleSheetList pointer as the
20752:       // nsISupports pointer. That must be fixed, or we'll crash...
20752:       NS_ASSERTION(list_qi == list, "Uh, fix QI!");
20752:     }
20752: #endif
20752:     return static_cast<nsDOMStyleSheetList*>(list);
20752:   }
20752: 
    1: protected:
    1:   PRInt32       mLength;
    1:   nsIDocument*  mDocument;
    1: };
    1: 
    1: class nsOnloadBlocker : public nsIRequest
    1: {
    1: public:
    1:   nsOnloadBlocker() {}
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIREQUEST
    1: 
    1: private:
    1:   ~nsOnloadBlocker() {}
    1: };
    1: 
20078: class nsExternalResourceMap
20078: {
20078: public:
20078:   typedef nsIDocument::ExternalResourceLoad ExternalResourceLoad;
20078:   nsExternalResourceMap();
20078: 
20078:   /**
20078:    * Request an external resource document.  This does exactly what
20078:    * nsIDocument::RequestExternalResource is documented to do.
20078:    */
20078:   nsIDocument* RequestResource(nsIURI* aURI,
20078:                                nsINode* aRequestingNode,
20078:                                nsDocument* aDisplayDocument,
20078:                                ExternalResourceLoad** aPendingLoad);
20078: 
20078:   /**
20078:    * Enumerate the resource documents.  See
20078:    * nsIDocument::EnumerateExternalResources.
20078:    */
20078:   void EnumerateResources(nsIDocument::nsSubDocEnumFunc aCallback, void* aData);
20078: 
20078:   /**
20078:    * Traverse ourselves for cycle-collection
20078:    */
20078:   void Traverse(nsCycleCollectionTraversalCallback* aCallback) const;
20078: 
20078:   /**
20078:    * Shut ourselves down (used for cycle-collection unlink), as well
20078:    * as for document destruction.
20078:    */
20078:   void Shutdown()
20078:   {
20078:     mPendingLoads.Clear();
20078:     mMap.Clear();
20078:     mHaveShutDown = PR_TRUE;
20078:   }
20078: 
20078:   PRBool HaveShutDown() const
20078:   {
20078:     return mHaveShutDown;
20078:   }
20078: 
20078:   // Needs to be public so we can traverse them sanely
20078:   struct ExternalResource
20078:   {
20078:     ~ExternalResource();
20078:     nsCOMPtr<nsIDocument> mDocument;
20078:     nsCOMPtr<nsIContentViewer> mViewer;
20078:     nsCOMPtr<nsILoadGroup> mLoadGroup;
20078:   };
20078: 
49570:   // Hide all our viewers
49570:   void HideViewers();
49570: 
49570:   // Show all our viewers
49570:   void ShowViewers();
49570: 
20078: protected:
20078:   class PendingLoad : public ExternalResourceLoad,
20078:                       public nsIStreamListener
20078:   {
20078:   public:
20078:     PendingLoad(nsDocument* aDisplayDocument) :
20078:       mDisplayDocument(aDisplayDocument)
20078:     {}
20078: 
20078:     NS_DECL_ISUPPORTS
20078:     NS_DECL_NSISTREAMLISTENER
20078:     NS_DECL_NSIREQUESTOBSERVER
20078: 
20078:     /**
20078:      * Start aURI loading.  This will perform the necessary security checks and
20078:      * so forth.
20078:      */
20078:     nsresult StartLoad(nsIURI* aURI, nsINode* aRequestingNode);
20078: 
20078:     /**
20078:      * Set up an nsIDocumentViewer based on aRequest.  This is guaranteed to
20078:      * put null in *aViewer and *aLoadGroup on all failures.
20078:      */
20078:     nsresult SetupViewer(nsIRequest* aRequest, nsIDocumentViewer** aViewer,
20078:                          nsILoadGroup** aLoadGroup);
20078: 
20078:   private:
20078:     nsRefPtr<nsDocument> mDisplayDocument;
20078:     nsCOMPtr<nsIStreamListener> mTargetListener;
20078:     nsCOMPtr<nsIURI> mURI;
20078:   };
20078:   friend class PendingLoad;
20078: 
20078:   class LoadgroupCallbacks : public nsIInterfaceRequestor
20078:   {
20078:   public:
20078:     LoadgroupCallbacks(nsIInterfaceRequestor* aOtherCallbacks)
20078:       : mCallbacks(aOtherCallbacks)
20078:     {}
20078:     NS_DECL_ISUPPORTS
20078:     NS_DECL_NSIINTERFACEREQUESTOR
20078:   private:
21877:     // The only reason it's safe to hold a strong ref here without leaking is
21877:     // that the notificationCallbacks on a loadgroup aren't the docshell itself
21877:     // but a shim that holds a weak reference to the docshell.
20078:     nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
21877: 
21877:     // Use shims for interfaces that docshell implements directly so that we
21877:     // don't hand out references to the docshell.  The shims should all allow
21877:     // getInterface back on us, but other than that each one should only
21877:     // implement one interface.
21877:     
21877:     // XXXbz I wish we could just derive the _allcaps thing from _i
21877: #define DECL_SHIM(_i, _allcaps)                                              \
21877:     class _i##Shim : public nsIInterfaceRequestor,                           \
21877:                      public _i                                               \
21877:     {                                                                        \
21877:     public:                                                                  \
21877:       _i##Shim(nsIInterfaceRequestor* aIfreq, _i* aRealPtr)                  \
21877:         : mIfReq(aIfreq), mRealPtr(aRealPtr)                                 \
21877:       {                                                                      \
21877:         NS_ASSERTION(mIfReq, "Expected non-null here");                      \
21877:         NS_ASSERTION(mRealPtr, "Expected non-null here");                    \
21877:       }                                                                      \
21877:       NS_DECL_ISUPPORTS                                                      \
21877:       NS_FORWARD_NSIINTERFACEREQUESTOR(mIfReq->);                            \
21877:       NS_FORWARD_##_allcaps(mRealPtr->);                                     \
21877:     private:                                                                 \
21877:       nsCOMPtr<nsIInterfaceRequestor> mIfReq;                                \
21877:       nsCOMPtr<_i> mRealPtr;                                                 \
21877:     };
21877: 
21877:     DECL_SHIM(nsILoadContext, NSILOADCONTEXT)
21877:     DECL_SHIM(nsIProgressEventSink, NSIPROGRESSEVENTSINK)
21877:     DECL_SHIM(nsIChannelEventSink, NSICHANNELEVENTSINK)
21877:     DECL_SHIM(nsISecurityEventSink, NSISECURITYEVENTSINK)
21877:     DECL_SHIM(nsIApplicationCacheContainer, NSIAPPLICATIONCACHECONTAINER)
21877: #undef DECL_SHIM
20078:   };
20078:   
20078:   /**
20078:    * Add an ExternalResource for aURI.  aViewer and aLoadGroup might be null
20078:    * when this is called if the URI didn't result in an XML document.  This
20078:    * function makes sure to remove the pending load for aURI, if any, from our
20078:    * hashtable, and to notify its observers, if any.
20078:    */
20078:   nsresult AddExternalResource(nsIURI* aURI, nsIDocumentViewer* aViewer,
20078:                                nsILoadGroup* aLoadGroup,
20078:                                nsIDocument* aDisplayDocument);
20078:   
20078:   nsClassHashtable<nsURIHashKey, ExternalResource> mMap;
20078:   nsRefPtrHashtable<nsURIHashKey, PendingLoad> mPendingLoads;
20078:   PRPackedBool mHaveShutDown;
20078: };
20078: 
    1: // Base class for our document implementations.
    1: //
    1: // Note that this class *implements* nsIDOMXMLDocument, but it's not
    1: // really an nsIDOMXMLDocument. The reason for implementing
    1: // nsIDOMXMLDocument on this class is to avoid having to duplicate all
    1: // its inherited methods on document classes that *are*
    1: // nsIDOMXMLDocument's. nsDocument's QI should *not* claim to support
    1: // nsIDOMXMLDocument unless someone writes a real implementation of
    1: // the interface.
    1: class nsDocument : public nsIDocument,
    1:                    public nsIDOMXMLDocument, // inherits nsIDOMDocument
    1:                    public nsIDOMNSDocument,
    1:                    public nsIDOMDocumentEvent,
    1:                    public nsIDOM3DocumentEvent,
    1:                    public nsIDOMNSDocumentStyle,
68870:                    public nsIDOMDocumentView,
    1:                    public nsIDOMDocumentRange,
    1:                    public nsIDOMDocumentTraversal,
    1:                    public nsIDOMDocumentXBL,
    1:                    public nsSupportsWeakReference,
 1418:                    public nsIDOMEventTarget,
    1:                    public nsIDOM3EventTarget,
    1:                    public nsIDOMNSEventTarget,
    1:                    public nsIScriptObjectPrincipal,
63105:                    public nsIRadioGroupContainer_MOZILLA_2_0_BRANCH,
18430:                    public nsIApplicationCacheContainer,
63882:                    public nsStubMutationObserver
    1: {
    1: public:
44178:   typedef mozilla::dom::Element Element;
44178: 
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
37351:   using nsINode::GetScriptTypeID;
37351: 
    1:   virtual void Reset(nsIChannel *aChannel, nsILoadGroup *aLoadGroup);
    1:   virtual void ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
    1:                           nsIPrincipal* aPrincipal);
    1: 
    1:   // StartDocumentLoad is pure virtual so that subclasses must override it.
    1:   // The nsDocument StartDocumentLoad does some setup, but does NOT set
    1:   // *aDocListener; this is the job of subclasses.
    1:   virtual nsresult StartDocumentLoad(const char* aCommand,
    1:                                      nsIChannel* aChannel,
    1:                                      nsILoadGroup* aLoadGroup,
    1:                                      nsISupports* aContainer,
    1:                                      nsIStreamListener **aDocListener,
    1:                                      PRBool aReset = PR_TRUE,
    1:                                      nsIContentSink* aContentSink = nsnull) = 0;
    1: 
    1:   virtual void StopDocumentLoad();
    1: 
16977:   virtual void NotifyPossibleTitleChange(PRBool aBoundTitleElement);
16977: 
    1:   virtual void SetDocumentURI(nsIURI* aURI);
    1:   
    1:   /**
    1:    * Set the principal responsible for this document.
    1:    */
    1:   virtual void SetPrincipal(nsIPrincipal *aPrincipal);
    1: 
    1:   /**
    1:    * Get the Content-Type of this document.
    1:    */
    1:   // NS_IMETHOD GetContentType(nsAString& aContentType);
    1:   // Already declared in nsIDOMNSDocument
    1: 
    1:   /**
    1:    * Set the Content-Type of this document.
    1:    */
    1:   virtual void SetContentType(const nsAString& aContentType);
    1: 
    1:   virtual nsresult SetBaseURI(nsIURI* aURI);
    1: 
    1:   /**
    1:    * Get/Set the base target of a link in a document.
    1:    */
41221:   virtual void GetBaseTarget(nsAString &aBaseTarget);
    1: 
    1:   /**
    1:    * Return a standard name for the document's character set. This will
    1:    * trigger a startDocumentLoad if necessary to answer the question.
    1:    */
    1:   virtual void SetDocumentCharacterSet(const nsACString& aCharSetID);
    1: 
    1:   /**
    1:    * Add an observer that gets notified whenever the charset changes.
    1:    */
    1:   virtual nsresult AddCharSetObserver(nsIObserver* aObserver);
    1: 
    1:   /**
    1:    * Remove a charset observer.
    1:    */
    1:   virtual void RemoveCharSetObserver(nsIObserver* aObserver);
    1: 
42325:   virtual Element* AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
50428:                                        void* aData, PRBool aForImage);
50428:   virtual void RemoveIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
50428:                                       void* aData, PRBool aForImage);
15515: 
    1:   /**
    1:    * Access HTTP header data (this may also get set from other sources, like
    1:    * HTML META tags).
    1:    */
    1:   virtual void GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const;
    1:   virtual void SetHeaderData(nsIAtom* aheaderField,
    1:                              const nsAString& aData);
    1: 
    1:   /**
    1:    * Create a new presentation shell that will use aContext for
24112:    * its presentation context (presentation context's <b>must not</b> be
    1:    * shared among multiple presentation shell's).
    1:    */
    1:   virtual nsresult CreateShell(nsPresContext* aContext,
    1:                                nsIViewManager* aViewManager,
    1:                                nsStyleSet* aStyleSet,
    1:                                nsIPresShell** aInstancePtrResult);
49570:   virtual void DeleteShell();
    1: 
    1:   virtual nsresult SetSubDocumentFor(nsIContent *aContent,
    1:                                      nsIDocument* aSubDoc);
    1:   virtual nsIDocument* GetSubDocumentFor(nsIContent *aContent) const;
    1:   virtual nsIContent* FindContentForSubDocument(nsIDocument *aDocument) const;
42325:   virtual Element* GetRootElementInternal() const;
    1: 
    1:   /**
    1:    * Get the style sheets owned by this document.
    1:    * These are ordered, highest priority last
    1:    */
    1:   virtual PRInt32 GetNumberOfStyleSheets() const;
    1:   virtual nsIStyleSheet* GetStyleSheetAt(PRInt32 aIndex) const;
    1:   virtual PRInt32 GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const;
    1:   virtual void AddStyleSheet(nsIStyleSheet* aSheet);
    1:   virtual void RemoveStyleSheet(nsIStyleSheet* aSheet);
    1: 
    1:   virtual void UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
    1:                                  nsCOMArray<nsIStyleSheet>& aNewSheets);
    1:   virtual void AddStyleSheetToStyleSets(nsIStyleSheet* aSheet);
    1:   virtual void RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet);
    1: 
    1:   virtual void InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex);
    1:   virtual void SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
    1:                                             PRBool aApplicable);
    1: 
    1:   virtual PRInt32 GetNumberOfCatalogStyleSheets() const;
    1:   virtual nsIStyleSheet* GetCatalogStyleSheetAt(PRInt32 aIndex) const;
    1:   virtual void AddCatalogStyleSheet(nsIStyleSheet* aSheet);
    1:   virtual void EnsureCatalogStyleSheet(const char *aStyleSheetURI);
    1: 
    1:   virtual nsIChannel* GetChannel() const {
    1:     return mChannel;
    1:   }
    1: 
    1:   /**
    1:    * Get this document's attribute stylesheet.  May return null if
    1:    * there isn't one.
    1:    */
    1:   virtual nsHTMLStyleSheet* GetAttributeStyleSheet() const {
    1:     return mAttrStyleSheet;
    1:   }
    1: 
    1:   /**
    1:    * Get this document's inline style sheet.  May return null if there
    1:    * isn't one
    1:    */
36782:   virtual nsHTMLCSSStyleSheet* GetInlineStyleSheet() const {
    1:     return mStyleAttrStyleSheet;
    1:   }
    1:   
    1:   /**
    1:    * Set the object from which a document can get a script context.
    1:    * This is the context within which all scripts (during document
    1:    * creation and during event handling) will run.
    1:    */
    1:   virtual nsIScriptGlobalObject* GetScriptGlobalObject() const;
    1:   virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aGlobalObject);
    1: 
 6475:   virtual void SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject);
 6475: 
    1:   virtual nsIScriptGlobalObject* GetScopeObject();
    1: 
    1:   /**
    1:    * Get the script loader for this document
    1:    */
 2007:   virtual nsScriptLoader* ScriptLoader();
    1: 
    1:   /**
43079:    * Add/Remove an element to the document's id and name hashes
43079:    */
50428:   virtual void AddToIdTable(Element* aElement, nsIAtom* aId);
50428:   virtual void RemoveFromIdTable(Element* aElement, nsIAtom* aId);
50428:   virtual void AddToNameTable(Element* aElement, nsIAtom* aName);
50428:   virtual void RemoveFromNameTable(Element* aElement, nsIAtom* aName);
43079: 
43079:   /**
    1:    * Add a new observer of document change notifications. Whenever
    1:    * content is changed, appended, inserted or removed the observers are
    1:    * informed.
    1:    */
    1:   virtual void AddObserver(nsIDocumentObserver* aObserver);
    1: 
    1:   /**
    1:    * Remove an observer of document change notifications. This will
    1:    * return false if the observer cannot be found.
    1:    */
    1:   virtual PRBool RemoveObserver(nsIDocumentObserver* aObserver);
    1: 
    1:   // Observation hooks used to propagate notifications to document
    1:   // observers.
    1:   virtual void BeginUpdate(nsUpdateType aUpdateType);
    1:   virtual void EndUpdate(nsUpdateType aUpdateType);
    1:   virtual void BeginLoad();
    1:   virtual void EndLoad();
23639: 
23639:   virtual void SetReadyStateInternal(ReadyState rs);
29975:   virtual ReadyState GetReadyStateEnum();
23639: 
64120:   virtual void ContentStateChanged(nsIContent* aContent,
56168:                                    nsEventStates aStateMask);
56168:   virtual void DocumentStatesChanged(nsEventStates aStateMask);
    1: 
    1:   virtual void StyleRuleChanged(nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aOldStyleRule,
    1:                                 nsIStyleRule* aNewStyleRule);
    1:   virtual void StyleRuleAdded(nsIStyleSheet* aStyleSheet,
    1:                               nsIStyleRule* aStyleRule);
    1:   virtual void StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
    1:                                 nsIStyleRule* aStyleRule);
    1: 
    1:   virtual void FlushPendingNotifications(mozFlushType aType);
40701:   virtual void FlushExternalResources(mozFlushType aType);
    1:   virtual nsIScriptEventManager* GetScriptEventManager();
    1:   virtual void SetXMLDeclaration(const PRUnichar *aVersion,
    1:                                  const PRUnichar *aEncoding,
    1:                                  const PRInt32 aStandalone);
    1:   virtual void GetXMLDeclaration(nsAString& aVersion,
    1:                                  nsAString& aEncoding,
    1:                                  nsAString& Standalone);
    1:   virtual PRBool IsScriptEnabled();
    1: 
25572:   virtual void OnPageShow(PRBool aPersisted, nsIDOMEventTarget* aDispatchStartTarget);
25572:   virtual void OnPageHide(PRBool aPersisted, nsIDOMEventTarget* aDispatchStartTarget);
    1:   
   62:   virtual void WillDispatchMutationEvent(nsINode* aTarget);
   62:   virtual void MutationEventDispatched(nsINode* aTarget);
   62: 
    1:   // nsINode
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
    1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const;
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
    1:   virtual PRUint32 GetChildCount() const;
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                  PRBool aNotify);
    1:   virtual nsresult AppendChildTo(nsIContent* aKid, PRBool aNotify);
29805:   virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent = PR_TRUE);
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual nsresult DispatchDOMEvent(nsEvent* aEvent, nsIDOMEvent* aDOMEvent,
    1:                                     nsPresContext* aPresContext,
    1:                                     nsEventStatus* aEventStatus);
29474:   virtual nsIEventListenerManager* GetListenerManager(PRBool aCreateIfNotFound);
 1418:   virtual nsresult AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                          const nsIID& aIID);
 1418:   virtual nsresult RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                             const nsIID& aIID);
 1418:   virtual nsresult GetSystemEventGroup(nsIDOMEventGroup** aGroup);
27700:   virtual nsIScriptContext* GetContextForEventHandlers(nsresult* aRv)
16056:   {
27700:     return nsContentUtils::GetContextForEventHandlers(this, aRv);
16056:   }
    1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
    1:   {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
41906:   virtual PRBool IsEqualNode(nsINode* aOther);
41907:   virtual void GetTextContent(nsAString &aTextContent);
    1: 
    1:   // nsIRadioGroupContainer
    1:   NS_IMETHOD WalkRadioGroup(const nsAString& aName,
    1:                             nsIRadioVisitor* aVisitor,
    1:                             PRBool aFlushContent);
    1:   NS_IMETHOD SetCurrentRadioButton(const nsAString& aName,
    1:                                    nsIDOMHTMLInputElement* aRadio);
    1:   NS_IMETHOD GetCurrentRadioButton(const nsAString& aName,
    1:                                    nsIDOMHTMLInputElement** aRadio);
    1:   NS_IMETHOD GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
    1:                                 PRInt32 *aPositionIndex,
    1:                                 PRInt32 *aItemsInGroup);
    1:   NS_IMETHOD GetNextRadioButton(const nsAString& aName,
    1:                                 const PRBool aPrevious,
    1:                                 nsIDOMHTMLInputElement*  aFocusedRadio,
    1:                                 nsIDOMHTMLInputElement** aRadioOut);
    1:   NS_IMETHOD AddToRadioGroup(const nsAString& aName,
    1:                              nsIFormControl* aRadio);
    1:   NS_IMETHOD RemoveFromRadioGroup(const nsAString& aName,
    1:                                   nsIFormControl* aRadio);
63105:   virtual PRUint32 GetRequiredRadioCount(const nsAString& aName) const;
63105:   virtual void RadioRequiredChanged(const nsAString& aName,
63105:                                     nsIFormControl* aRadio);
63107:   virtual bool GetValueMissingState(const nsAString& aName) const;
63107:   virtual void SetValueMissingState(const nsAString& aName, bool aValue);
    1: 
    1:   // for radio group
    1:   nsresult GetRadioGroup(const nsAString& aName,
    1:                          nsRadioGroupStruct **aRadioGroup);
    1: 
    1:   // nsIDOMNode
    1:   NS_DECL_NSIDOMNODE
    1: 
    1:   // nsIDOMDocument
    1:   NS_DECL_NSIDOMDOCUMENT
    1: 
    1:   // nsIDOMXMLDocument
    1:   NS_DECL_NSIDOMXMLDOCUMENT
    1: 
    1:   // nsIDOMNSDocument
    1:   NS_DECL_NSIDOMNSDOCUMENT
    1: 
    1:   // nsIDOMDocumentEvent
    1:   NS_DECL_NSIDOMDOCUMENTEVENT
    1: 
    1:   // nsIDOM3DocumentEvent
    1:   NS_DECL_NSIDOM3DOCUMENTEVENT
    1: 
    1:   // nsIDOMDocumentStyle
    1:   NS_DECL_NSIDOMDOCUMENTSTYLE
    1: 
    1:   // nsIDOMNSDocumentStyle
    1:   NS_DECL_NSIDOMNSDOCUMENTSTYLE
    1: 
68870:   // nsIDOMDocumentView
68870:   NS_DECL_NSIDOMDOCUMENTVIEW
68870: 
    1:   // nsIDOMDocumentRange
    1:   NS_DECL_NSIDOMDOCUMENTRANGE
    1: 
    1:   // nsIDOMDocumentTraversal
    1:   NS_DECL_NSIDOMDOCUMENTTRAVERSAL
    1: 
    1:   // nsIDOMDocumentXBL
    1:   NS_DECL_NSIDOMDOCUMENTXBL
    1: 
    1:   // nsIDOMEventTarget
    1:   NS_DECL_NSIDOMEVENTTARGET
    1: 
    1:   // nsIDOM3EventTarget
    1:   NS_DECL_NSIDOM3EVENTTARGET
    1: 
    1:   // nsIDOMNSEventTarget
    1:   NS_DECL_NSIDOMNSEVENTTARGET
    1: 
    1:   // nsIScriptObjectPrincipal
    1:   virtual nsIPrincipal* GetPrincipal();
    1: 
18430:   // nsIApplicationCacheContainer
18430:   NS_DECL_NSIAPPLICATIONCACHECONTAINER
18430: 
    1:   virtual nsresult Init();
    1:   
    1:   virtual nsresult AddXMLEventsContent(nsIContent * aXMLEventsElement);
    1: 
48124:   virtual nsresult CreateElem(const nsAString& aName, nsIAtom *aPrefix,
    1:                               PRInt32 aNamespaceID,
    1:                               PRBool aDocumentDefaultType,
    1:                               nsIContent **aResult);
    1: 
48124:   nsresult CreateElement(const nsAString& aTagName,
48124:                          nsIContent** aReturn);
58484:   nsresult CreateElementNS(const nsAString& aNamespaceURI,
58484:                            const nsAString& aQualifiedName,
58484:                            nsIContent** aReturn);
48124: 
48124:   nsresult CreateTextNode(const nsAString& aData, nsIContent** aReturn);
48124: 
    1:   virtual NS_HIDDEN_(nsresult) Sanitize();
    1: 
    1:   virtual NS_HIDDEN_(void) EnumerateSubDocuments(nsSubDocEnumFunc aCallback,
    1:                                                  void *aData);
    1: 
    1:   virtual NS_HIDDEN_(PRBool) CanSavePresentation(nsIRequest *aNewRequest);
    1:   virtual NS_HIDDEN_(void) Destroy();
14469:   virtual NS_HIDDEN_(void) RemovedFromDocShell();
    1:   virtual NS_HIDDEN_(already_AddRefed<nsILayoutHistoryState>) GetLayoutHistoryState() const;
    1: 
    1:   virtual NS_HIDDEN_(void) BlockOnload();
    1:   virtual NS_HIDDEN_(void) UnblockOnload(PRBool aFireSync);
    1: 
38488:   virtual NS_HIDDEN_(void) AddStyleRelevantLink(mozilla::dom::Link* aLink);
38488:   virtual NS_HIDDEN_(void) ForgetLink(mozilla::dom::Link* aLink);
    1: 
    1:   NS_HIDDEN_(void) ClearBoxObjectFor(nsIContent* aContent);
26701:   NS_IMETHOD GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult);
    1: 
    1:   virtual NS_HIDDEN_(nsresult) GetXBLChildNodesFor(nsIContent* aContent,
    1:                                                    nsIDOMNodeList** aResult);
    1:   virtual NS_HIDDEN_(nsresult) GetContentListFor(nsIContent* aContent,
    1:                                                  nsIDOMNodeList** aResult);
21333: 
40200:   virtual NS_HIDDEN_(nsresult) ElementFromPointHelper(float aX, float aY,
21333:                                                       PRBool aIgnoreRootScrollFrame,
21333:                                                       PRBool aFlushLayout,
21333:                                                       nsIDOMElement** aReturn);
21333: 
40568:   virtual NS_HIDDEN_(nsresult) NodesFromRectHelper(float aX, float aY,
40568:                                                    float aTopSize, float aRightSize,
40568:                                                    float aBottomSize, float aLeftSize,
40568:                                                    PRBool aIgnoreRootScrollFrame,
40568:                                                    PRBool aFlushLayout,
40568:                                                    nsIDOMNodeList** aReturn);
40568: 
    1:   virtual NS_HIDDEN_(void) FlushSkinBindings();
    1: 
13433:   virtual NS_HIDDEN_(nsresult) InitializeFrameLoader(nsFrameLoader* aLoader);
12256:   virtual NS_HIDDEN_(nsresult) FinalizeFrameLoader(nsFrameLoader* aLoader);
14660:   virtual NS_HIDDEN_(void) TryCancelFrameLoaderInitialization(nsIDocShell* aShell);
14757:   virtual NS_HIDDEN_(PRBool) FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell);
20078:   virtual NS_HIDDEN_(nsIDocument*)
20078:     RequestExternalResource(nsIURI* aURI,
20078:                             nsINode* aRequestingNode,
20078:                             ExternalResourceLoad** aPendingLoad);
20078:   virtual NS_HIDDEN_(void)
20078:     EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData);
12256: 
38871:   nsTArray<nsCString> mFileDataUris;
38871: 
23697: #ifdef MOZ_SMIL
38869:   // Returns our (lazily-initialized) animation controller.
38869:   // If HasAnimationController is true, this is guaranteed to return non-null.
23697:   nsSMILAnimationController* GetAnimationController();
23697: #endif // MOZ_SMIL
23697: 
57023:   void SetImagesNeedAnimating(PRBool aAnimating);
57023: 
25722:   virtual void SuppressEventHandling(PRUint32 aIncrease);
25722: 
25722:   virtual void UnsuppressEventHandlingAndFireEvents(PRBool aFireEvents);
25722:   
25722:   void DecreaseEventSuppression() { --mEventsSuppressed; }
25722: 
30001:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsDocument,
30001:                                                          nsIDocument)
    1: 
16977:   void DoNotifyPossibleTitleChange();
16977: 
20078:   nsExternalResourceMap& ExternalResourceMap()
20078:   {
20078:     return mExternalResourceMap;
20078:   }
20078: 
19384:   void SetLoadedAsData(PRBool aLoadedAsData) { mLoadedAsData = aLoadedAsData; }
19384: 
19384:   nsresult CloneDocHelper(nsDocument* clone) const;
19384: 
24482:   void MaybeInitializeFinalizeFrameLoaders();
24482: 
24482:   void MaybeEndOutermostXBLUpdate();
30065: 
30065:   virtual void MaybePreLoadImage(nsIURI* uri);
34394: 
38850:   virtual void PreloadStyle(nsIURI* uri, const nsAString& charset);
38850: 
38850:   virtual nsresult LoadChromeSheetSync(nsIURI* uri, PRBool isAgentSheet,
42163:                                        nsCSSStyleSheet** sheet);
38850: 
34394:   virtual nsISupports* GetCurrentContentSink();
34394: 
56168:   virtual nsEventStates GetDocumentState();
39698: 
53994:   virtual void RegisterFileDataUri(const nsACString& aUri);
53994:   virtual void UnregisterFileDataUri(const nsACString& aUri);
38871: 
41406:   // Only BlockOnload should call this!
41406:   void AsyncBlockOnload();
41406: 
42357:   virtual void SetScrollToRef(nsIURI *aDocumentURI);
42357:   virtual void ScrollToRef();
42357:   virtual void ResetScrolledToRefAlready();
42357:   virtual void SetChangeScrollPosWhenScrollingToRef(PRBool aValue);
42357: 
42425:   already_AddRefed<nsContentList>
63637:   GetElementsByTagName(const nsAString& aTagName) {
63637:     return NS_GetContentList(this, kNameSpaceID_Unknown, aTagName);
63637:   }
42425:   already_AddRefed<nsContentList>
42425:     GetElementsByTagNameNS(const nsAString& aNamespaceURI,
42425:                            const nsAString& aLocalName);
42425: 
50428:   virtual Element *GetElementById(const nsAString& aElementId);
50428: 
50428:   virtual Element *LookupImageElement(const nsAString& aElementId);
42425: 
50815:   virtual NS_HIDDEN_(nsresult) AddImage(imgIRequest* aImage);
50815:   virtual NS_HIDDEN_(nsresult) RemoveImage(imgIRequest* aImage);
50815:   virtual NS_HIDDEN_(nsresult) SetImageLockingState(PRBool aLocked);
50815: 
63882:   virtual nsresult GetMozCurrentStateObject(nsIVariant** aResult);
63882: 
    1: protected:
32360:   friend class nsNodeUtils;
15474: 
    1:   /**
    1:    * Check that aId is not empty and log a message to the console
    1:    * service if it is.
    1:    * @returns PR_TRUE if aId looks correct, PR_FALSE otherwise.
    1:    */
59513:   inline PRBool CheckGetElementByIdArg(const nsAString& aId)
43946:   {
43946:     if (aId.IsEmpty()) {
43946:       ReportEmptyGetElementByIdArg();
43946:       return PR_FALSE;
43946:     }
43946:     return PR_TRUE;
43946:   }
43946: 
59513:   void ReportEmptyGetElementByIdArg();
    1: 
24144:   void DispatchContentLoadedEvents();
24144: 
    1:   void RetrieveRelevantHeaders(nsIChannel *aChannel);
    1: 
    1:   static PRBool TryChannelCharset(nsIChannel *aChannel,
    1:                                   PRInt32& aCharsetSource,
    1:                                   nsACString& aCharset);
    1: 
    1:   // Call this before the document does something that will unbind all content.
43079:   // That will stop us from doing a lot of work as each element is removed.
43079:   void DestroyElementMaps();
    1: 
33055:   // Refreshes the hrefs of all the links in the document.
33055:   void RefreshLinkHrefs();
33055: 
33055:   nsIContent* GetFirstBaseNodeWithHref();
33055:   nsresult SetFirstBaseNodeWithHref(nsIContent *node);
33055: 
16977:   // Get the first <title> element with the given IsNodeOfType type, or
16977:   // return null if there isn't one
16977:   nsIContent* GetTitleContent(PRUint32 aNodeType);
16977:   // Find the first "title" element in the given IsNodeOfType type and
16977:   // append the concatenation of its text node children to aTitle. Do
16977:   // nothing if there is no such element.
16977:   void GetTitleFromElement(PRUint32 aNodeType, nsAString& aTitle);
16977: 
    1:   nsresult doCreateShell(nsPresContext* aContext,
    1:                          nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
    1:                          nsCompatibility aCompatMode,
    1:                          nsIPresShell** aInstancePtrResult);
    1: 
    1:   nsresult ResetStylesheetsToURI(nsIURI* aURI);
    1:   void FillStyleSet(nsStyleSet* aStyleSet);
    1: 
    1:   // Return whether all the presshells for this document are safe to flush
    1:   PRBool IsSafeToFlush() const;
    1:   
    1:   virtual PRInt32 GetDefaultNamespaceID() const
    1:   {
    1:     return kNameSpaceID_None;
  731:   }
    1: 
29539:   void DispatchPageTransition(nsPIDOMEventTarget* aDispatchTarget,
29539:                               const nsAString& aType,
29539:                               PRBool aPersisted);
    1: 
63954:   virtual nsPIDOMWindow *GetWindowInternal() const;
40925:   virtual nsPIDOMWindow *GetInnerWindowInternal();
42823:   virtual nsIScriptGlobalObject* GetScriptHandlingObjectInternal() const;
51393:   virtual PRBool InternalAllowXULXBL();
40925: 
    1: #define NS_DOCUMENT_NOTIFY_OBSERVERS(func_, params_)                        \
48006:   NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS(mObservers, nsIDocumentObserver, \
    1:                                            func_, params_);
    1:   
    1: #ifdef DEBUG
    1:   void VerifyRootContentState();
    1: #endif
    1: 
    1:   nsDocument(const char* aContentType);
    1:   virtual ~nsDocument();
    1: 
40932:   void EnsureOnloadBlocker();
40932: 
    1:   nsCString mReferrer;
    1:   nsString mLastModified;
    1: 
26413:   nsTArray<nsIObserver*> mCharSetObservers;
    1: 
    1:   PLDHashTable *mSubDocuments;
    1: 
    1:   // Array of owning references to all children
    1:   nsAttrAndChildArray mChildren;
    1: 
    1:   // Pointer to our parser if we're currently in the process of being
    1:   // parsed into.
    1:   nsCOMPtr<nsIParser> mParser;
    1: 
 6170:   // Weak reference to our sink for in case we no longer have a parser.  This
 6170:   // will allow us to flush out any pending stuff from the sink even if
 6170:   // EndLoad() has already happened.
 6170:   nsWeakPtr mWeakSink;
 6170: 
    1:   nsCOMArray<nsIStyleSheet> mStyleSheets;
    1:   nsCOMArray<nsIStyleSheet> mCatalogSheets;
    1: 
    1:   // Array of observers
 9536:   nsTObserverArray<nsIDocumentObserver*> mObservers;
    1: 
 6475:   // If document is created for example using
 6475:   // document.implementation.createDocument(...), mScriptObject points to
 6475:   // the script global object of the original document.
 6475:   nsWeakPtr mScriptObject;
 6475: 
    1:   // Weak reference to the scope object (aka the script global object)
    1:   // that, unlike mScriptGlobalObject, is never unset once set. This
    1:   // is a weak reference to avoid leaks due to circular references.
    1:   nsWeakPtr mScopeObject;
    1: 
    1:   nsCOMPtr<nsIEventListenerManager> mListenerManager;
    1:   nsCOMPtr<nsIDOMStyleSheetList> mDOMStyleSheets;
    1:   nsRefPtr<nsDOMStyleSheetSetList> mStyleSheetSetList;
    1:   nsRefPtr<nsScriptLoader> mScriptLoader;
    1:   nsDocHeaderData* mHeaderData;
15474:   /* mIdentifierMap works as follows for IDs:
15474:    * 1) Attribute changes affect the table immediately (removing and adding
15474:    *    entries as needed).
15474:    * 2) Removals from the DOM affect the table immediately
26475:    * 3) Additions to the DOM always update existing entries for names, and add
26475:    *    new ones for IDs.
15474:    */
15474:   nsTHashtable<nsIdentifierMapEntry> mIdentifierMap;
    1: 
 6365:   nsClassHashtable<nsStringHashKey, nsRadioGroupStruct> mRadioGroups;
    1: 
    1:   // True if the document has been detached from its content viewer.
    1:   PRPackedBool mIsGoingAway:1;
    1:   // True if the document is being destroyed.
    1:   PRPackedBool mInDestructor:1;
31946: 
16977:   // True if this document has ever had an HTML or SVG <title> element
16977:   // bound to it
16977:   PRPackedBool mMayHaveTitleElement:1;
    1: 
11731:   PRPackedBool mHasWarnedAboutBoxObjects:1;
11731: 
14464:   PRPackedBool mDelayFrameLoaderInitialization:1;
14464: 
24144:   PRPackedBool mSynchronousDOMContentLoaded:1;
24144: 
16447:   // If true, we have an input encoding.  If this is false, then the
16447:   // document was created entirely in memory
16447:   PRPackedBool mHaveInputEncoding:1;
16447: 
24482:   PRPackedBool mInXBLUpdate:1;
24482: 
36884:   // This flag is only set in nsXMLDocument, for e.g. documents used in XBL. We
36884:   // don't want animations to play in such documents, so we need to store the
36884:   // flag here so that we can check it in nsDocument::GetAnimationController.
36884:   PRPackedBool mLoadedAsInteractiveData:1;
36884: 
50815:   // Whether we're currently holding a lock on all of our images.
50815:   PRPackedBool mLockingImages:1;
50815: 
52149:   // Whether we currently require our images to animate
52149:   PRPackedBool mAnimatingImages:1;
52149: 
    1:   PRUint8 mXMLDeclarationBits;
    1: 
    1:   PRUint8 mDefaultElementType;
    1: 
11731:   nsInterfaceHashtable<nsVoidPtrHashKey, nsPIBoxObject> *mBoxObjectTable;
    1: 
    1:   // The channel that got passed to StartDocumentLoad(), if any
    1:   nsCOMPtr<nsIChannel> mChannel;
    1:   nsRefPtr<nsHTMLStyleSheet> mAttrStyleSheet;
36782:   nsRefPtr<nsHTMLCSSStyleSheet> mStyleAttrStyleSheet;
    1:   nsRefPtr<nsXMLEventsManager> mXMLEventsManager;
    1: 
    1:   nsCOMPtr<nsIScriptEventManager> mScriptEventManager;
    1: 
 7199:   // Our update nesting level
 7199:   PRUint32 mUpdateNestLevel;
 7199: 
18430:   // The application cache that this document is associated with, if
18430:   // any.  This can change during the lifetime of the document.
18430:   nsCOMPtr<nsIApplicationCache> mApplicationCache;
18430: 
33055:   nsCOMPtr<nsIContent> mFirstBaseNodeWithHref;
33055: 
56168:   nsEventStates mDocumentState;
56168:   nsEventStates mGotDocumentState;
39698: 
12033: private:
    1:   friend class nsUnblockOnloadEvent;
    1: 
    1:   void PostUnblockOnloadEvent();
    1:   void DoUnblockOnload();
    1: 
48017:   nsresult CheckFrameOptions();
37418:   nsresult InitCSP();
37418: 
    1:   /**
    1:    * See if aDocument is a child of this.  If so, return the frame element in
    1:    * this document that holds currentDoc (or an ancestor).
    1:    */
    1:   already_AddRefed<nsIDOMElement>
    1:     CheckAncestryAndGetFrame(nsIDocument* aDocument) const;
    1: 
    1:   // Just like EnableStyleSheetsForSet, but doesn't check whether
    1:   // aSheetSet is null and allows the caller to control whether to set
    1:   // aSheetSet as the preferred set in the CSSLoader.
    1:   void EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
    1:                                        PRBool aUpdateCSSLoader);
    1: 
63939:   // Revoke any pending notifications due to mozRequestAnimationFrame calls
63939:   void RevokeAnimationFrameNotifications();
63939:   // Reschedule any notifications we need to handle mozRequestAnimationFrame
63939:   void RescheduleAnimationFrameNotifications();
63939: 
    1:   // These are not implemented and not supported.
    1:   nsDocument(const nsDocument& aOther);
    1:   nsDocument& operator=(const nsDocument& aOther);
    1: 
    1:   nsCOMPtr<nsISupports> mXPathEvaluatorTearoff;
    1: 
    1:   // The layout history state that should be used by nodes in this
    1:   // document.  We only actually store a pointer to it when:
    1:   // 1)  We have no script global object.
    1:   // 2)  We haven't had Destroy() called on us yet.
    1:   nsCOMPtr<nsILayoutHistoryState> mLayoutHistoryState;
    1: 
41406:   // Currently active onload blockers
    1:   PRUint32 mOnloadBlockCount;
41406:   // Onload blockers which haven't been activated yet
41406:   PRUint32 mAsyncOnloadBlockCount;
    1:   nsCOMPtr<nsIRequest> mOnloadBlocker;
23639:   ReadyState mReadyState;
    1: 
38488:   // A hashtable of styled links keyed by address pointer.
38488:   nsTHashtable<nsPtrHashKey<mozilla::dom::Link> > mStyledLinks;
38488: #ifdef DEBUG
38488:   // Indicates whether mStyledLinks was cleared or not.  This is used to track
38488:   // state so we can provide useful assertions to consumers of ForgetLink and
38488:   // AddStyleRelevantLink.
38488:   bool mStyledLinksCleared;
38488: #endif
    1: 
    1:   // Member to store out last-selected stylesheet set.
    1:   nsString mLastStyleSheetSet;
12256: 
13433:   nsTArray<nsRefPtr<nsFrameLoader> > mInitializableFrameLoaders;
12256:   nsTArray<nsRefPtr<nsFrameLoader> > mFinalizableFrameLoaders;
24482:   nsRefPtr<nsRunnableMethod<nsDocument> > mFrameLoaderRunner;
16977: 
41359:   nsRevocableEventPtr<nsRunnableMethod<nsDocument, void, false> >
28045:     mPendingTitleChangeEvent;
20078: 
20078:   nsExternalResourceMap mExternalResourceMap;
23697: 
30065:   // All images in process of being preloaded
30065:   nsCOMArray<imgIRequest> mPreloadingImages;
30065: 
34007:   nsCOMPtr<nsIDOMDOMImplementation> mDOMImplementation;
34007: 
42357:   nsCString mScrollToRef;
42357:   PRUint8 mScrolledToRefAlready : 1;
42357:   PRUint8 mChangeScrollPosWhenScrollingToRef : 1;
42357: 
50815:   // Tracking for images in the document.
50815:   nsDataHashtable< nsPtrHashKey<imgIRequest>, PRUint32> mImageTracker;
50815: 
31428: #ifdef DEBUG
31428: protected:
31428:   PRBool mWillReparent;
31428: #endif
    1: };
    1: 
21218: #define NS_DOCUMENT_INTERFACE_TABLE_BEGIN(_class)                             \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocument, nsDocument)      \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNSDocument, nsDocument)    \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentEvent, nsDocument) \
68870:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentView, nsDocument)  \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMDocumentTraversal,         \
21218:                                      nsDocument)                              \
21218:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMEventTarget, nsDocument)   \
64020:   NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNode, nsDocument)
21218: 
    1: #endif /* nsDocument_h___ */
