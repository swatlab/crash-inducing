42402: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
39997:  * ***** BEGIN LICENSE BLOCK *****
39997:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39997:  *
39997:  * The contents of this file are subject to the Mozilla Public License Version
39997:  * 1.1 (the "License"); you may not use this file except in compliance with
39997:  * the License. You may obtain a copy of the License at
39997:  * http://www.mozilla.org/MPL/
39997:  *
39997:  * Software distributed under the License is distributed on an "AS IS" basis,
39997:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39997:  * for the specific language governing rights and limitations under the
39997:  * License.
39997:  *
39997:  * The Original Code is Mozilla Corporation code.
39997:  *
39997:  * The Initial Developer of the Original Code is Mozilla Foundation.
39997:  * Portions created by the Initial Developer are Copyright (C) 2009
39997:  * the Initial Developer. All Rights Reserved.
39997:  *
39997:  * Contributor(s):
39997:  *   Bas Schouten <bschouten@mozilla.org>
42791:  *   Frederic Plourde <frederic.plourde@collabora.co.uk>
42791:  *   Vladimir Vukicevic <vladimir@pobox.com>
39997:  *
39997:  * Alternatively, the contents of this file may be used under the terms of
39997:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39997:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39997:  * in which case the provisions of the GPL or the LGPL are applicable instead
39997:  * of those above. If you wish to allow use of your version of this file only
39997:  * under the terms of either the GPL or the LGPL, and not to allow others to
39997:  * use your version of this file under the terms of the MPL, indicate your
39997:  * decision by deleting the provisions above and replace them with the notice
39997:  * and other provisions required by the GPL or the LGPL. If you do not delete
39997:  * the provisions above, a recipient may use your version of this file under
39997:  * the terms of any one of the MPL, the GPL or the LGPL.
39997:  *
39997:  * ***** END LICENSE BLOCK ***** */
39997: 
39997: #ifndef GFX_LAYERMANAGEROGL_H
39997: #define GFX_LAYERMANAGEROGL_H
39997: 
39997: #include "Layers.h"
39997: 
55451: #include "mozilla/layers/ShadowLayers.h"
55451: 
69696: #include "mozilla/TimeStamp.h"
69696: 
39997: #ifdef XP_WIN
39997: #include <windows.h>
39997: #endif
39997: 
41372: /**
41372:  * We don't include GLDefs.h here since we don't want to drag in all defines
41372:  * in for all our users.
41372:  */
41372: typedef unsigned int GLenum;
41372: typedef unsigned int GLbitfield;
39997: typedef unsigned int GLuint;
39997: typedef int GLint;
41372: typedef int GLsizei;
39997: 
39997: #define BUFFER_OFFSET(i) ((char *)NULL + (i))
39997: 
39997: #include "gfxContext.h"
42791: #include "gfx3DMatrix.h"
39997: #include "nsIWidget.h"
41370: #include "GLContext.h"
39997: 
42791: #include "LayerManagerOGLProgram.h"
42791: 
39997: namespace mozilla {
39997: namespace layers {
39997: 
39997: class LayerOGL;
55460: class ShadowThebesLayer;
55460: class ShadowContainerLayer;
55460: class ShadowImageLayer;
55460: class ShadowCanvasLayer;
55460: class ShadowColorLayer;
39997: 
39997: /**
39997:  * This is the LayerManager used for OpenGL 2.1. For now this will render on
39997:  * the main thread.
39997:  */
55451: class THEBES_API LayerManagerOGL :
55451:     public ShadowLayerManager
55451: {
46261:   typedef mozilla::gl::GLContext GLContext;
59436:   typedef mozilla::gl::ShaderProgramType ProgramType;
46261: 
39997: public:
39997:   LayerManagerOGL(nsIWidget *aWidget);
39997:   virtual ~LayerManagerOGL();
39997: 
47908:   void CleanupResources();
47908: 
49072:   void Destroy();
49072: 
60832: 
39997:   /**
60832:    * Initializes the layer manager with a given GLContext. If aContext is null
60832:    * then the layer manager will try to create one for the associated widget.
39997:    *
60832:    * \param aContext an existing GL context to use. Can be created with CreateContext()
46261:    *
39997:    * \return True is initialization was succesful, false when it was not.
39997:    */
88849:   bool Initialize(bool force = false) {
88849:     return Initialize(CreateContext(), force);
60832:   }
60832: 
88849:   bool Initialize(nsRefPtr<GLContext> aContext, bool force = false);
39997: 
39997:   /**
39997:    * Sets the clipping region for this layer manager. This is important on 
39997:    * windows because using OGL we no longer have GDI's native clipping. Therefor
39997:    * widget must tell us what part of the screen is being invalidated,
39997:    * and we should clip to this.
39997:    *
39997:    * \param aClippingRegion Region to clip to. Setting an empty region
39997:    * will disable clipping.
39997:    */
39997:   void SetClippingRegion(const nsIntRegion& aClippingRegion);
39997: 
39997:   /**
39997:    * LayerManager implementation.
39997:    */
75148:   virtual ShadowLayerManager* AsShadowManager()
75148:   {
75148:     return this;
75148:   }
75148: 
39997:   void BeginTransaction();
39997: 
39997:   void BeginTransactionWithTarget(gfxContext* aTarget);
39997: 
39997:   void EndConstruction();
39997: 
61836:   virtual bool EndEmptyTransaction();
59171:   virtual void EndTransaction(DrawThebesLayerCallback aCallback,
78887:                               void* aCallbackData,
78887:                               EndTransactionFlags aFlags = END_DEFAULT);
39997: 
44202:   virtual void SetRoot(Layer* aLayer) { mRoot = aLayer; }
39997: 
73612:   virtual bool CanUseCanvasLayerForSize(const gfxIntSize &aSize)
73612:   {
73612:       if (!mGLContext)
73612:           return false;
73612:       PRInt32 maxSize = mGLContext->GetMaxTextureSize();
73612:       return aSize <= gfxIntSize(maxSize, maxSize);
73612:   }
73612: 
39997:   virtual already_AddRefed<ThebesLayer> CreateThebesLayer();
39997: 
39997:   virtual already_AddRefed<ContainerLayer> CreateContainerLayer();
39997: 
39997:   virtual already_AddRefed<ImageLayer> CreateImageLayer();
39997: 
42249:   virtual already_AddRefed<ColorLayer> CreateColorLayer();
42249: 
42402:   virtual already_AddRefed<CanvasLayer> CreateCanvasLayer();
42402: 
39997:   virtual already_AddRefed<ImageContainer> CreateImageContainer();
39997: 
55451:   virtual already_AddRefed<ShadowThebesLayer> CreateShadowThebesLayer();
55451:   virtual already_AddRefed<ShadowContainerLayer> CreateShadowContainerLayer();
55451:   virtual already_AddRefed<ShadowImageLayer> CreateShadowImageLayer();
55451:   virtual already_AddRefed<ShadowColorLayer> CreateShadowColorLayer();
55451:   virtual already_AddRefed<ShadowCanvasLayer> CreateShadowCanvasLayer();
55451: 
40011:   virtual LayersBackend GetBackendType() { return LAYERS_OPENGL; }
51975:   virtual void GetBackendName(nsAString& name) { name.AssignLiteral("OpenGL"); }
40011: 
39997:   /**
49072:    * Image Container management.
49072:    */
49072: 
49072:   /* Forget this image container.  Should be called by ImageContainerOGL
49072:    * on its current layer manager before switching to a new one.
49072:    */
49072:   void ForgetImageContainer(ImageContainer* aContainer);
49072:   void RememberImageContainer(ImageContainer* aContainer);
49072: 
49072:   /**
39997:    * Helper methods.
39997:    */
79445:   void MakeCurrent(bool aForce = false) {
53689:     if (mDestroyed) {
53689:       NS_WARNING("Call on destroyed layer manager");
53689:       return;
53689:     }
53689:     mGLContext->MakeCurrent(aForce);
53689:   }
39997: 
59436:   ColorTextureLayerProgram *GetColorTextureLayerProgram(ProgramType type){
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[type]);
59436:   }
59436: 
42791:   ColorTextureLayerProgram *GetRGBALayerProgram() {
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::RGBALayerProgramType]);
42791:   }
42791:   ColorTextureLayerProgram *GetBGRALayerProgram() {
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::BGRALayerProgramType]);
42791:   }
42791:   ColorTextureLayerProgram *GetRGBXLayerProgram() {
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::RGBXLayerProgramType]);
42791:   }
42791:   ColorTextureLayerProgram *GetBGRXLayerProgram() {
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::BGRXLayerProgramType]);
42791:   }
79445:   ColorTextureLayerProgram *GetBasicLayerProgram(bool aOpaque, bool aIsRGB)
52152:   {
52152:     if (aIsRGB) {
52152:       return aOpaque
52152:         ? GetRGBXLayerProgram()
52152:         : GetRGBALayerProgram();
52152:     } else {
52152:       return aOpaque
52152:         ? GetBGRXLayerProgram()
52152:         : GetBGRALayerProgram();
52152:     }
52152:   }
52152: 
42791:   ColorTextureLayerProgram *GetRGBARectLayerProgram() {
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::RGBARectLayerProgramType]);
42791:   }
42791:   SolidColorLayerProgram *GetColorLayerProgram() {
59436:     return static_cast<SolidColorLayerProgram*>(mPrograms[gl::ColorLayerProgramType]);
42791:   }
42791:   YCbCrTextureLayerProgram *GetYCbCrLayerProgram() {
59436:     return static_cast<YCbCrTextureLayerProgram*>(mPrograms[gl::YCbCrLayerProgramType]);
42791:   }
60740:   ComponentAlphaTextureLayerProgram *GetComponentAlphaPass1LayerProgram() {
60740:     return static_cast<ComponentAlphaTextureLayerProgram*>
60740:              (mPrograms[gl::ComponentAlphaPass1ProgramType]);
60740:   }
60740:   ComponentAlphaTextureLayerProgram *GetComponentAlphaPass2LayerProgram() {
60740:     return static_cast<ComponentAlphaTextureLayerProgram*>
60740:              (mPrograms[gl::ComponentAlphaPass2ProgramType]);
60740:   }
42791:   CopyProgram *GetCopy2DProgram() {
59436:     return static_cast<CopyProgram*>(mPrograms[gl::Copy2DProgramType]);
42791:   }
42791:   CopyProgram *GetCopy2DRectProgram() {
59436:     return static_cast<CopyProgram*>(mPrograms[gl::Copy2DRectProgramType]);
42791:   }
42791: 
42791:   ColorTextureLayerProgram *GetFBOLayerProgram() {
42791:     if (mFBOTextureTarget == LOCAL_GL_TEXTURE_RECTANGLE_ARB)
59436:       return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::RGBARectLayerProgramType]);
59436:     return static_cast<ColorTextureLayerProgram*>(mPrograms[gl::RGBALayerProgramType]);
42791:   }
39997: 
41370:   GLContext *gl() const { return mGLContext; }
41370: 
48092:   DrawThebesLayerCallback GetThebesLayerCallback() const
48092:   { return mThebesLayerCallback; }
48092: 
48092:   void* GetThebesLayerCallbackData() const
48092:   { return mThebesLayerCallbackData; }
48092: 
49072:   // This is a GLContext that can be used for resource
49072:   // management (creation, destruction).  It is guaranteed
49072:   // to be either the same as the gl() context, or a context
49072:   // that is in the same share pool.
49072:   GLContext *glForResources() const {
49072:     if (mGLContext->GetSharedContext())
49072:       return mGLContext->GetSharedContext();
49072:     return mGLContext;
49072:   }
49072: 
42791:   /*
42791:    * Helper functions for our layers
42791:    */
42791:   void CallThebesLayerDrawCallback(ThebesLayer* aLayer,
42791:                                    gfxContext* aContext,
42791:                                    const nsIntRegion& aRegionToDraw)
42791:   {
42791:     NS_ASSERTION(mThebesLayerCallback,
42791:                  "CallThebesLayerDrawCallback without callback!");
42791:     mThebesLayerCallback(aLayer, aContext,
47108:                          aRegionToDraw, nsIntRegion(),
47108:                          mThebesLayerCallbackData);
42791:   }
42791: 
42791:   GLenum FBOTextureTarget() { return mFBOTextureTarget; }
42791: 
60740:   /**
60740:    * Controls how to initialize the texture / FBO created by
60740:    * CreateFBOWithTexture.
60740:    *  - InitModeNone: No initialization, contents are undefined.
60740:    *  - InitModeClear: Clears the FBO.
60740:    *  - InitModeCopy: Copies the contents of the current glReadBuffer into the
60740:    *    texture.
60740:    */
60740:   enum InitMode {
60740:     InitModeNone,
60740:     InitModeClear,
60740:     InitModeCopy
60740:   };
60740: 
42791:   /* Create a FBO backed by a texture; will leave the FBO
42791:    * bound.  Note that the texture target type will be
42791:    * of the type returned by FBOTextureTarget; different
42791:    * shaders are required to sample from the different
42791:    * texture types.
42791:    */
60740:   void CreateFBOWithTexture(const nsIntRect& aRect, InitMode aInit,
88239:                             GLuint aCurrentFrameBuffer,
42791:                             GLuint *aFBO, GLuint *aTexture);
42791: 
42791:   GLuint QuadVBO() { return mQuadVBO; }
42791:   GLintptr QuadVBOVertexOffset() { return 0; }
42791:   GLintptr QuadVBOTexCoordOffset() { return sizeof(float)*4*2; }
42791:   GLintptr QuadVBOFlippedTexCoordOffset() { return sizeof(float)*8*2; }
42791: 
42791:   void BindQuadVBO() {
42791:     mGLContext->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, mQuadVBO);
42791:   }
42791: 
42791:   void QuadVBOVerticesAttrib(GLuint aAttribIndex) {
42791:     mGLContext->fVertexAttribPointer(aAttribIndex, 2,
42791:                                      LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
42791:                                      (GLvoid*) QuadVBOVertexOffset());
42791:   }
42791: 
42791:   void QuadVBOTexCoordsAttrib(GLuint aAttribIndex) {
42791:     mGLContext->fVertexAttribPointer(aAttribIndex, 2,
42791:                                      LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
42791:                                      (GLvoid*) QuadVBOTexCoordOffset());
42791:   }
42791: 
42791:   void QuadVBOFlippedTexCoordsAttrib(GLuint aAttribIndex) {
42791:     mGLContext->fVertexAttribPointer(aAttribIndex, 2,
42791:                                      LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
42791:                                      (GLvoid*) QuadVBOFlippedTexCoordOffset());
42791:   }
42791: 
42791:   // Super common
42791: 
42791:   void BindAndDrawQuad(GLuint aVertAttribIndex,
42791:                        GLuint aTexCoordAttribIndex,
42791:                        bool aFlipped = false)
42791:   {
42791:     BindQuadVBO();
42791:     QuadVBOVerticesAttrib(aVertAttribIndex);
42791: 
42956:     if (aTexCoordAttribIndex != GLuint(-1)) {
42791:       if (aFlipped)
42791:         QuadVBOFlippedTexCoordsAttrib(aTexCoordAttribIndex);
42791:       else
42791:         QuadVBOTexCoordsAttrib(aTexCoordAttribIndex);
42791: 
42791:       mGLContext->fEnableVertexAttribArray(aTexCoordAttribIndex);
42791:     }
42791: 
42791:     mGLContext->fEnableVertexAttribArray(aVertAttribIndex);
42791: 
42791:     mGLContext->fDrawArrays(LOCAL_GL_TRIANGLE_STRIP, 0, 4);
42791: 
42791:     mGLContext->fDisableVertexAttribArray(aVertAttribIndex);
42791: 
42956:     if (aTexCoordAttribIndex != GLuint(-1)) {
42791:       mGLContext->fDisableVertexAttribArray(aTexCoordAttribIndex);
42791:     }
42791:   }
42791: 
42791:   void BindAndDrawQuad(LayerProgram *aProg,
42791:                        bool aFlipped = false)
42791:   {
42791:     BindAndDrawQuad(aProg->AttribLocation(LayerProgram::VertexAttrib),
42791:                     aProg->AttribLocation(LayerProgram::TexCoordAttrib),
42791:                     aFlipped);
42791:   }
42791: 
73013:   void BindAndDrawQuadWithTextureRect(LayerProgram *aProg,
73013:                                       const nsIntRect& aTexCoordRect,
73013:                                       const nsIntSize& aTexSize,
73013:                                       GLenum aWrapMode = LOCAL_GL_REPEAT);
73013:                                       
73013: 
51960: #ifdef MOZ_LAYERS_HAVE_LOG
51960:   virtual const char* Name() const { return "OGL"; }
51960: #endif // MOZ_LAYERS_HAVE_LOG
51960: 
54505:   const nsIntSize& GetWigetSize() {
54505:     return mWidgetSize;
54505:   }
54505: 
61971:   enum WorldTransforPolicy {
61971:     ApplyWorldTransform,
61971:     DontApplyWorldTransform
61971:   };
61971: 
54778:   /**
54778:    * Setup the viewport and projection matrix for rendering
54778:    * to a window of the given dimensions.
54778:    */
61971:   void SetupPipeline(int aWidth, int aHeight, WorldTransforPolicy aTransformPolicy);
61971:   
61971:   /**
61971:    * Setup World transform matrix.
61971:    * Transform will be ignored if it is not PreservesAxisAlignedRectangles
61971:    * or has non integer scale
61971:    */
61971:   void SetWorldTransform(const gfxMatrix& aMatrix);
61971:   gfxMatrix& GetWorldTransform(void);
61971:   void WorldTransformRect(nsIntRect& aRect);
54778: 
39997: private:
39997:   /** Widget associated with this layer manager */
39997:   nsIWidget *mWidget;
53689:   nsIntSize mWidgetSize;
53689: 
39997:   /** 
39997:    * Context target, NULL when drawing directly to our swap chain.
39997:    */
39997:   nsRefPtr<gfxContext> mTarget;
39997: 
41370:   nsRefPtr<GLContext> mGLContext;
39997: 
60832:   already_AddRefed<mozilla::gl::GLContext> CreateContext();
60832: 
49072:   // The image containers that this layer manager has created.
49072:   // The destructor will tell the layer manager to remove
49072:   // it from the list.
49072:   nsTArray<ImageContainer*> mImageContainers;
49072: 
42791:   static ProgramType sLayerProgramTypes[];
42791: 
42791:   /** Backbuffer */
42791:   GLuint mBackBufferFBO;
42791:   GLuint mBackBufferTexture;
42791:   nsIntSize mBackBufferSize;
42791: 
42791:   /** Shader Programs */
42791:   nsTArray<LayerManagerOGLProgram*> mPrograms;
42791: 
42209:   /** Texture target to use for FBOs */
42209:   GLenum mFBOTextureTarget;
39997: 
42791:   /** VBO that has some basics in it for a textured quad,
42791:    *  including vertex coords and texcoords for both
42791:    *  flipped and unflipped textures */
42791:   GLuint mQuadVBO;
42791: 
42791:   /** Region we're clipping our current drawing to. */
39997:   nsIntRegion mClippingRegion;
42791: 
42791:   /** Misc */
79445:   bool mHasBGRA;
42791: 
44202:   /** Current root layer. */
44202:   LayerOGL *RootLayer() const;
44202: 
39997:   /**
39997:    * Render the current layer tree to the active target.
39997:    */
42791:   void Render();
54778: 
39997:   /**
42791:    * Setup a backbuffer of the given dimensions.
39997:    */
42791:   void SetupBackBuffer(int aWidth, int aHeight);
54778: 
39997:   /**
39997:    * Copies the content of our backbuffer to the set transaction target.
39997:    */
39997:   void CopyToTarget();
42791: 
42791:   /**
42791:    * Updates all layer programs with a new projection matrix.
42791:    *
42791:    * XXX we need a way to be able to delay setting this until
42791:    * the program is actually used.  Maybe a DelayedSetUniform
42791:    * on Program, that will delay the set until the next Activate?
42791:    *
42791:    * XXX this is only called once per frame, so it's not awful.
42791:    * If we have any more similar updates, then we should delay.
42791:    */
42791:   void SetLayerProgramProjectionMatrix(const gfx3DMatrix& aMatrix);
42791: 
42791:   /* Thebes layer callbacks; valid at the end of a transaciton,
42791:    * while rendering */
42791:   DrawThebesLayerCallback mThebesLayerCallback;
42791:   void *mThebesLayerCallbackData;
61971:   gfxMatrix mWorldMatrix;
69696: 
69696:   struct FPSState
69696:   {
69696:       GLuint texture;
69696:       int fps;
69696:       bool initialized;
69696:       int fcount;
69696:       TimeStamp last;
69696: 
69696:       FPSState()
69696:         : texture(0)
69696:         , fps(0)
69696:         , initialized(false)
69696:         , fcount(0)
78618:       {
78618:         last = TimeStamp::Now();
78618:       }
69696:       void DrawFPS(GLContext*, CopyProgram*);
69696:   } mFPS;
69696: 
79445:   static bool sDrawFPS;
39997: };
39997: 
39997: /**
39997:  * General information and tree management for OGL layers.
39997:  */
39997: class LayerOGL
39997: {
39997: public:
42791:   LayerOGL(LayerManagerOGL *aManager)
80486:     : mOGLManager(aManager), mDestroyed(false)
42791:   { }
39997: 
49072:   virtual ~LayerOGL() { }
49072: 
42791:   virtual LayerOGL *GetFirstChildOGL() {
42791:     return nsnull;
42791:   }
39997: 
49072:   /* Do NOT call this from the generic LayerOGL destructor.  Only from the
49072:    * concrete class destructor
49072:    */
49072:   virtual void Destroy() = 0;
49072: 
39997:   virtual Layer* GetLayer() = 0;
39997: 
42791:   virtual void RenderLayer(int aPreviousFrameBuffer,
57097:                            const nsIntPoint& aOffset) = 0;
39997: 
41370:   typedef mozilla::gl::GLContext GLContext;
41370: 
55455:   LayerManagerOGL* OGLManager() const { return mOGLManager; }
41370:   GLContext *gl() const { return mOGLManager->gl(); }
87402:   virtual void CleanupResources() = 0;
54468: 
39997: protected:
41370:   LayerManagerOGL *mOGLManager;
79445:   bool mDestroyed;
39997: };
39997: 
39997: } /* layers */
39997: } /* mozilla */
39997: 
39997: #endif /* GFX_LAYERMANAGEROGL_H */
