 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsIKeyModule.h"
     1: #include "nsStreamCipher.h"
     1: #include "nsStreamUtils.h"
     1: #include "base64.h"
     1: 
     1: NS_IMPL_ISUPPORTS1(nsStreamCipher, nsIStreamCipher)
     1: 
     1: nsStreamCipher::nsStreamCipher()
119832:   : mContext(NULL)
     1: {
     1: }
     1: 
     1: nsStreamCipher::~nsStreamCipher()
     1: {
     1:   if (mContext)
 80486:     PK11_DestroyContext(mContext, true /* free sub-objects */);
     1: }
     1: 
     1: nsresult
     1: nsStreamCipher::InitWithIV_(nsIKeyObject *aKey, SECItem* aIV)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aKey);
     1: 
     1:   // Make sure we have a SYM_KEY.
108991:   int16_t keyType;
     1:   nsresult rv = aKey->GetType(&keyType);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   if (keyType != nsIKeyObject::SYM_KEY)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
     1:   if (mContext)
 80486:     PK11_DestroyContext(mContext, true /* free sub-objects */);
     1: 
     1:   // Get the PK11SymKey out of the key object and create the PK11Context.
     1:   void* keyObj;
     1:   rv = aKey->GetKeyObj(&keyObj);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  3233:   PK11SymKey *symkey = reinterpret_cast<PK11SymKey*>(keyObj);
     1:   if (!symkey)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   CK_MECHANISM_TYPE cipherMech = PK11_GetMechanism(symkey);
     1: 
106838:   SECItem *param = nullptr;
     1:   // aIV may be null
     1:   param = PK11_ParamFromIV(cipherMech, aIV);
     1:   if (!param)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   mContext = PK11_CreateContextBySymKey(cipherMech, CKA_ENCRYPT,
     1:                                         symkey, param);
     1: 
 80486:   SECITEM_FreeItem(param, true);
     1: 
     1:   // Something went wrong if mContext doesn't exist.
     1:   if (!mContext)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   // Everything went ok.      
     1:   mValue.Truncate();
     1:   return NS_OK;
     1: }
     1: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // nsIStreamCipher
     1: 
     1: NS_IMETHODIMP nsStreamCipher::Init(nsIKeyObject *aKey)
     1: {
106838:   return InitWithIV_(aKey, nullptr);
     1: }
     1: 
     1: NS_IMETHODIMP nsStreamCipher::InitWithIV(nsIKeyObject *aKey,
108991:                                          const uint8_t *aIV, uint32_t aIVLen)
     1: {
     1:   SECItem IV;
     1:   IV.data = (unsigned char*)aIV;
     1:   IV.len = aIVLen;
     1:   return InitWithIV_(aKey, &IV);
     1: }
     1: 
108991: NS_IMETHODIMP nsStreamCipher::Update(const uint8_t *aData, uint32_t aLen)
     1: {
     1:   if (!mContext)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   unsigned char* output = new unsigned char[aLen];
119832:   if (!output)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   unsigned char* input = (unsigned char*)aData;
     1:   
108991:   int32_t setLen;
 64055: 
 64055: #ifdef DEBUG
 64055:   SECStatus rv =
 64055: #endif
 64055:     PK11_CipherOp(mContext, output, &setLen, aLen, input, aLen);
     1:   NS_ASSERTION(rv == SECSuccess, "failed to encrypt");
108991:   NS_ASSERTION((uint32_t)setLen == aLen, "data length should not change");
     1: 
     1:   mValue.Append((const char*)output, aLen);
     1: 
     1:   delete [] output;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsStreamCipher::UpdateFromStream(nsIInputStream *aStream,
108991:                                                int32_t aLen)
     1: {
     1:   if (!mContext)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   nsCString inputString;
     1:   nsresult rv = NS_ConsumeStream(aStream, aLen, inputString);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
     1:   return UpdateFromString(inputString);
     1: }
     1: 
     1: NS_IMETHODIMP nsStreamCipher::UpdateFromString(const nsACString& aInput)
     1: {
     1:   if (!mContext)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   const nsCString& flatInput = PromiseFlatCString(aInput);
     1:   unsigned char* input = (unsigned char*)flatInput.get();
108991:   uint32_t len = aInput.Length();
     1: 
     1:   unsigned char* output = new unsigned char[len];
119832:   if (!output)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
108991:   int32_t setLen;
 64055: 
 64055: #ifdef DEBUG
 64055:   SECStatus rv =
 64055: #endif
 64055:     PK11_CipherOp(mContext, output, &setLen, len, input, len);
     1:   NS_ASSERTION(rv == SECSuccess, "failed to encrypt");
108991:   NS_ASSERTION((uint32_t)setLen == len, "data length should not change");
     1: 
     1:   mValue.Append((const char*)output, len);
     1:   delete [] output;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsStreamCipher::Finish(bool aASCII, nsACString & _retval)
     1: {
     1:   if (!mContext)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   if (aASCII) {
     1:     char *asciiData = BTOA_DataToAscii((unsigned char*)(mValue.get()),
     1:                                        mValue.Length());
     1:     _retval.Assign(asciiData);
     1:     PORT_Free(asciiData);
     1:   } else {
     1:     _retval.Assign(mValue);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsStreamCipher::Discard(int32_t aLen)
     1: {
     1:   if (!mContext)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   unsigned char* output = new unsigned char[aLen];
119832:   if (!output)
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832: 
     1:   unsigned char* input = new unsigned char[aLen];
119832:   if (!input) {
119832:     delete [] output;
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832:   }
     1: 
108991:   int32_t setLen;
 64055: 
 64055: #ifdef DEBUG
 64055:   SECStatus rv =
 64055: #endif
 64055:     PK11_CipherOp(mContext, output, &setLen, aLen, input, aLen);
     1:   NS_ASSERTION(rv == SECSuccess, "failed to encrypt");
     1:   NS_ASSERTION(setLen == aLen, "data length should not change");
     1:   
     1:   delete [] output;
     1:   delete [] input;
     1:   return NS_OK;
     1: }
