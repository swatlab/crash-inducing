    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is TransforMiiX XSLT processor code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Peter Van der Beken <peterv@propagandism.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "txMozillaXSLTProcessor.h"
    1: #include "nsContentCID.h"
    1: #include "nsDOMError.h"
    1: #include "nsIChannel.h"
51350: #include "mozilla/dom/Element.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMClassInfo.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIIOService.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsIURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsXPathResult.h"
    1: #include "txExecutionState.h"
    1: #include "txMozillaTextOutput.h"
    1: #include "txMozillaXMLOutput.h"
    1: #include "txURIUtils.h"
    1: #include "txXMLUtils.h"
    1: #include "txUnknownHandler.h"
    1: #include "txXSLTProcessor.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsThreadUtils.h"
    1: #include "jsapi.h"
    1: #include "txExprParser.h"
    1: #include "nsIErrorService.h"
 3582: #include "nsIScriptSecurityManager.h"
    1: 
51350: using namespace mozilla::dom;
51350: 
    1: static NS_DEFINE_CID(kXMLDocumentCID, NS_XMLDOCUMENT_CID);
    1: 
    1: /**
    1:  * Output Handler Factories
    1:  */
    1: class txToDocHandlerFactory : public txAOutputHandlerFactory
    1: {
    1: public:
    1:     txToDocHandlerFactory(txExecutionState* aEs,
    1:                           nsIDOMDocument* aSourceDocument,
    1:                           nsIDOMDocument* aResultDocument,
    1:                           nsITransformObserver* aObserver)
    1:         : mEs(aEs), mSourceDocument(aSourceDocument),
    1:           mResultDocument(aResultDocument), mObserver(aObserver)
    1:     {
    1:     }
    1: 
    1:     TX_DECL_TXAOUTPUTHANDLERFACTORY
    1: 
    1: private:
    1:     txExecutionState* mEs;
    1:     nsCOMPtr<nsIDOMDocument> mSourceDocument;
    1:     nsCOMPtr<nsIDOMDocument> mResultDocument;
    1:     nsCOMPtr<nsITransformObserver> mObserver;
    1: };
    1: 
    1: class txToFragmentHandlerFactory : public txAOutputHandlerFactory
    1: {
    1: public:
    1:     txToFragmentHandlerFactory(nsIDOMDocumentFragment* aFragment)
    1:         : mFragment(aFragment)
    1:     {
    1:     }
    1: 
    1:     TX_DECL_TXAOUTPUTHANDLERFACTORY
    1: 
    1: private:
    1:     nsCOMPtr<nsIDOMDocumentFragment> mFragment;
    1: };
    1: 
    1: nsresult
    1: txToDocHandlerFactory::createHandlerWith(txOutputFormat* aFormat,
    1:                                          txAXMLEventHandler** aHandler)
    1: {
    1:     *aHandler = nsnull;
    1:     switch (aFormat->mMethod) {
    1:         case eMethodNotSet:
    1:         case eXMLOutput:
    1:         {
    1:             *aHandler = new txUnknownHandler(mEs);
    1:             break;
    1:         }
    1: 
    1:         case eHTMLOutput:
    1:         {
    1:             *aHandler = new txMozillaXMLOutput(EmptyString(),
    1:                                                kNameSpaceID_None,
    1:                                                aFormat, mSourceDocument,
    1:                                                mResultDocument, mObserver);
    1:             break;
    1:         }
    1: 
    1:         case eTextOutput:
    1:         {
    1:             *aHandler = new txMozillaTextOutput(mSourceDocument,
    1:                                                 mResultDocument,
    1:                                                 mObserver);
    1:             break;
    1:         }
    1:     }
    1:     NS_ENSURE_TRUE(*aHandler, NS_ERROR_OUT_OF_MEMORY);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: txToDocHandlerFactory::createHandlerWith(txOutputFormat* aFormat,
    1:                                          const nsSubstring& aName,
    1:                                          PRInt32 aNsID,
    1:                                          txAXMLEventHandler** aHandler)
    1: {
    1:     *aHandler = nsnull;
    1:     switch (aFormat->mMethod) {
    1:         case eMethodNotSet:
    1:         {
    1:             NS_ERROR("How can method not be known when root element is?");
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1: 
    1:         case eXMLOutput:
    1:         case eHTMLOutput:
    1:         {
    1:             *aHandler = new txMozillaXMLOutput(aName, aNsID, aFormat,
    1:                                                mSourceDocument,
    1:                                                mResultDocument,
    1:                                                mObserver);
    1:             break;
    1:         }
    1: 
    1:         case eTextOutput:
    1:         {
    1:             *aHandler = new txMozillaTextOutput(mSourceDocument,
    1:                                                 mResultDocument,
    1:                                                 mObserver);
    1:             break;
    1:         }
    1:     }
    1:     NS_ENSURE_TRUE(*aHandler, NS_ERROR_OUT_OF_MEMORY);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: txToFragmentHandlerFactory::createHandlerWith(txOutputFormat* aFormat,
    1:                                               txAXMLEventHandler** aHandler)
    1: {
    1:     *aHandler = nsnull;
    1:     switch (aFormat->mMethod) {
    1:         case eMethodNotSet:
    1:         {
    1:             txOutputFormat format;
    1:             format.merge(*aFormat);
    1:             nsCOMPtr<nsIDOMDocument> domdoc;
    1:             mFragment->GetOwnerDocument(getter_AddRefs(domdoc));
    1:             NS_ASSERTION(domdoc, "unable to get ownerdocument");
    1:             nsCOMPtr<nsIDocument> doc = do_QueryInterface(domdoc);
    1: 
31946:             if (doc && doc->IsHTML()) {
31946:                 format.mMethod = eHTMLOutput;
31946:             } else {
    1:                 format.mMethod = eXMLOutput;
    1:             }
    1: 
    1:             *aHandler = new txMozillaXMLOutput(&format, mFragment, PR_FALSE);
    1:             break;
    1:         }
    1: 
    1:         case eXMLOutput:
    1:         case eHTMLOutput:
    1:         {
    1:             *aHandler = new txMozillaXMLOutput(aFormat, mFragment, PR_FALSE);
    1:             break;
    1:         }
    1: 
    1:         case eTextOutput:
    1:         {
    1:             *aHandler = new txMozillaTextOutput(mFragment);
    1:             break;
    1:         }
    1:     }
    1:     NS_ENSURE_TRUE(*aHandler, NS_ERROR_OUT_OF_MEMORY);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: txToFragmentHandlerFactory::createHandlerWith(txOutputFormat* aFormat,
    1:                                               const nsSubstring& aName,
    1:                                               PRInt32 aNsID,
    1:                                               txAXMLEventHandler** aHandler)
    1: {
    1:     *aHandler = nsnull;
    1:     NS_ASSERTION(aFormat->mMethod != eMethodNotSet,
    1:                  "How can method not be known when root element is?");
    1:     NS_ENSURE_TRUE(aFormat->mMethod != eMethodNotSet, NS_ERROR_UNEXPECTED);
    1:     return createHandlerWith(aFormat, aHandler);
    1: }
    1: 
    1: class txVariable : public txIGlobalParameter
    1: {
    1: public:
    1:     txVariable(nsIVariant *aValue) : mValue(aValue)
    1:     {
    1:         NS_ASSERTION(aValue, "missing value");
    1:     }
    1:     txVariable(txAExprResult* aValue) : mTxValue(aValue)
    1:     {
    1:         NS_ASSERTION(aValue, "missing value");
    1:     }
    1:     nsresult getValue(txAExprResult** aValue)
    1:     {
    1:         NS_ASSERTION(mValue || mTxValue, "variablevalue is null");
    1: 
    1:         if (!mTxValue) {
    1:             nsresult rv = Convert(mValue, getter_AddRefs(mTxValue));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1:         }
    1: 
    1:         *aValue = mTxValue;
    1:         NS_ADDREF(*aValue);
    1: 
    1:         return NS_OK;
    1:     }
    1:     nsresult getValue(nsIVariant** aValue)
    1:     {
    1:         *aValue = mValue;
    1:         NS_ADDREF(*aValue);
    1:         return NS_OK;
    1:     }
 8468:     nsIVariant* getValue()
 8468:     {
 8468:         return mValue;
 8468:     }
    1:     void setValue(nsIVariant* aValue)
    1:     {
    1:         NS_ASSERTION(aValue, "setting variablevalue to null");
    1:         mValue = aValue;
    1:         mTxValue = nsnull;
    1:     }
    1:     void setValue(txAExprResult* aValue)
    1:     {
    1:         NS_ASSERTION(aValue, "setting variablevalue to null");
    1:         mValue = nsnull;
    1:         mTxValue = aValue;
    1:     }
    1: 
    1: private:
    1:     static nsresult Convert(nsIVariant *aValue, txAExprResult** aResult);
    1: 
    1:     nsCOMPtr<nsIVariant> mValue;
    1:     nsRefPtr<txAExprResult> mTxValue;
    1: };
    1: 
    1: /**
    1:  * txMozillaXSLTProcessor
    1:  */
    1: 
 8468: NS_IMPL_CYCLE_COLLECTION_CLASS(txMozillaXSLTProcessor)
 8468: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(txMozillaXSLTProcessor)
 8468:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEmbeddedStylesheetRoot)
 8468:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSource)
 8468:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrincipal)
 8468:     tmp->mVariables.clear();
 8468: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 8468: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(txMozillaXSLTProcessor)
 8468:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEmbeddedStylesheetRoot)
 8468:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSource)
 8468:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrincipal)
 8468:     txOwningExpandedNameMap<txIGlobalParameter>::iterator iter(tmp->mVariables);
 8468:     while (iter.next()) {
 8468:         cb.NoteXPCOMChild(static_cast<txVariable*>(iter.value())->getValue());
 8468:     }
 8468: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 8468: 
 8468: NS_IMPL_CYCLE_COLLECTING_ADDREF(txMozillaXSLTProcessor)
 8468: NS_IMPL_CYCLE_COLLECTING_RELEASE(txMozillaXSLTProcessor)
40490: 
40490: DOMCI_DATA(XSLTProcessor, txMozillaXSLTProcessor)
40490: 
 8468: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(txMozillaXSLTProcessor)
    1:     NS_INTERFACE_MAP_ENTRY(nsIXSLTProcessor)
    1:     NS_INTERFACE_MAP_ENTRY(nsIXSLTProcessorObsolete)
    1:     NS_INTERFACE_MAP_ENTRY(nsIXSLTProcessorPrivate)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocumentTransformer)
    1:     NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
 3582:     NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
    1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXSLTProcessor)
39587:     NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XSLTProcessor)
    1: NS_INTERFACE_MAP_END
    1: 
    1: txMozillaXSLTProcessor::txMozillaXSLTProcessor() : mStylesheetDocument(nsnull),
    1:                                                    mTransformResult(NS_OK),
    1:                                                    mCompileResult(NS_OK),
    1:                                                    mFlags(0)
    1: {
    1: }
    1: 
    1: txMozillaXSLTProcessor::~txMozillaXSLTProcessor()
    1: {
    1:     if (mStylesheetDocument) {
    1:         mStylesheetDocument->RemoveMutationObserver(this);
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::TransformDocument(nsIDOMNode* aSourceDOM,
    1:                                           nsIDOMNode* aStyleDOM,
    1:                                           nsIDOMDocument* aOutputDoc,
    1:                                           nsISupports* aObserver)
    1: {
    1:     NS_ENSURE_ARG(aSourceDOM);
    1:     NS_ENSURE_ARG(aStyleDOM);
    1:     NS_ENSURE_ARG(aOutputDoc);
    1:     NS_ENSURE_FALSE(aObserver, NS_ERROR_NOT_IMPLEMENTED);
    1: 
    1:     if (!nsContentUtils::CanCallerAccess(aSourceDOM) ||
    1:         !nsContentUtils::CanCallerAccess(aStyleDOM) ||
    1:         !nsContentUtils::CanCallerAccess(aOutputDoc)) {
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
    1: 
    1:     PRUint16 type = 0;
    1:     aStyleDOM->GetNodeType(&type);
    1:     NS_ENSURE_TRUE(type == nsIDOMNode::ELEMENT_NODE ||
    1:                    type == nsIDOMNode::DOCUMENT_NODE,
    1:                    NS_ERROR_INVALID_ARG);
    1: 
 6372:     nsCOMPtr<nsINode> styleNode = do_QueryInterface(aStyleDOM);
 6372:     nsresult rv = TX_CompileStylesheet(styleNode, this, mPrincipal,
    1:                                        getter_AddRefs(mStylesheet));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mSource = aSourceDOM;
    1: 
    1:     return TransformToDoc(aOutputDoc, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::SetTransformObserver(nsITransformObserver* aObserver)
    1: {
    1:     mObserver = aObserver;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: txMozillaXSLTProcessor::SetSourceContentModel(nsIDOMNode* aSourceDOM)
    1: {
    1:     mSource = aSourceDOM;
    1: 
    1:     if (NS_FAILED(mTransformResult)) {
    1:         notifyError();
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (mStylesheet) {
    1:         return DoTransform();
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::AddXSLTParamNamespace(const nsString& aPrefix,
    1:                                               const nsString& aNamespace)
    1: {
    1:     nsCOMPtr<nsIAtom> pre = do_GetAtom(aPrefix);
    1:     return mParamNamespaceMap.mapNamespace(pre, aNamespace);
    1: }
    1: 
    1: 
    1: class txXSLTParamContext : public txIParseContext,
    1:                            public txIEvalContext
    1: {
    1: public:
    1:     txXSLTParamContext(txNamespaceMap *aResolver, const txXPathNode& aContext,
    1:                        txResultRecycler* aRecycler)
    1:         : mResolver(aResolver),
    1:           mContext(aContext),
    1:           mRecycler(aRecycler)
    1:     {
    1:     }
    1: 
    1:     // txIParseContext
    1:     nsresult resolveNamespacePrefix(nsIAtom* aPrefix, PRInt32& aID)
    1:     {
    1:         aID = mResolver->lookupNamespace(aPrefix);
    1:         return aID == kNameSpaceID_Unknown ? NS_ERROR_DOM_NAMESPACE_ERR :
    1:                                              NS_OK;
    1:     }
    1:     nsresult resolveFunctionCall(nsIAtom* aName, PRInt32 aID,
    1:                                  FunctionCall** aFunction)
    1:     {
    1:         return NS_ERROR_XPATH_UNKNOWN_FUNCTION;
    1:     }
    1:     PRBool caseInsensitiveNameTests()
    1:     {
    1:         return PR_FALSE;
    1:     }
    1:     void SetErrorOffset(PRUint32 aOffset)
    1:     {
    1:     }
    1: 
    1:     // txIEvalContext
    1:     nsresult getVariable(PRInt32 aNamespace, nsIAtom* aLName,
    1:                          txAExprResult*& aResult)
    1:     {
    1:         aResult = nsnull;
    1:         return NS_ERROR_INVALID_ARG;
    1:     }
    1:     PRBool isStripSpaceAllowed(const txXPathNode& aNode)
    1:     {
    1:         return PR_FALSE;
    1:     }
    1:     void* getPrivateContext()
    1:     {
    1:         return nsnull;
    1:     }
    1:     txResultRecycler* recycler()
    1:     {
    1:         return mRecycler;
    1:     }
    1:     void receiveError(const nsAString& aMsg, nsresult aRes)
    1:     {
    1:     }
    1:     const txXPathNode& getContextNode()
    1:     {
    1:       return mContext;
    1:     }
    1:     PRUint32 size()
    1:     {
    1:       return 1;
    1:     }
    1:     PRUint32 position()
    1:     {
    1:       return 1;
    1:     }
    1: 
    1: private:
    1:     txNamespaceMap *mResolver;
    1:     const txXPathNode& mContext;
    1:     txResultRecycler* mRecycler;
    1: };
    1: 
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::AddXSLTParam(const nsString& aName,
    1:                                      const nsString& aNamespace,
    1:                                      const nsString& aSelect,
    1:                                      const nsString& aValue,
    1:                                      nsIDOMNode* aContext)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     if (aSelect.IsVoid() == aValue.IsVoid()) {
    1:         // Ignore if neither or both are specified
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsRefPtr<txAExprResult> value;
    1:     if (!aSelect.IsVoid()) {
    1: 
    1:         // Set up context
    1:         nsAutoPtr<txXPathNode> contextNode(
    1:           txXPathNativeNode::createXPathNode(aContext));
    1:         NS_ENSURE_TRUE(contextNode, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:         if (!mRecycler) {
    1:             mRecycler = new txResultRecycler;
    1:             NS_ENSURE_TRUE(mRecycler, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:             rv = mRecycler->init();
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1:         }
    1: 
    1:         txXSLTParamContext paramContext(&mParamNamespaceMap, *contextNode,
    1:                                         mRecycler);
    1: 
    1:         // Parse
    1:         nsAutoPtr<Expr> expr;
    1:         rv = txExprParser::createExpr(aSelect, &paramContext,
    1:                                       getter_Transfers(expr));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         // Evaluate
    1:         rv = expr->evaluate(&paramContext, getter_AddRefs(value));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else {
    1:         value = new StringResult(aValue, nsnull);
    1:         NS_ENSURE_TRUE(value, NS_ERROR_OUT_OF_MEMORY);
    1:     }
    1: 
    1:     nsCOMPtr<nsIAtom> name = do_GetAtom(aName);
    1:     PRInt32 nsId = kNameSpaceID_Unknown;
    1:     rv = nsContentUtils::NameSpaceManager()->
    1:         RegisterNameSpace(aNamespace, nsId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     txExpandedName varName(nsId, name);
 3233:     txVariable* var = static_cast<txVariable*>(mVariables.get(varName));
    1:     if (var) {
    1:         var->setValue(value);
    1:         
    1:         return NS_OK;
    1:     }
    1: 
    1:     var = new txVariable(value);
    1:     NS_ENSURE_TRUE(var, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return mVariables.add(varName, var);
    1: }
    1: 
    1: class nsTransformBlockerEvent : public nsRunnable {
    1: public:
    1:   nsRefPtr<txMozillaXSLTProcessor> mProcessor;
    1: 
    1:   nsTransformBlockerEvent(txMozillaXSLTProcessor *processor)
    1:     : mProcessor(processor)
    1:   {}
    1: 
    1:   ~nsTransformBlockerEvent()
    1:   {
    1:     nsCOMPtr<nsIDocument> document =
    1:         do_QueryInterface(mProcessor->GetSourceContentModel());
    1:     document->UnblockOnload(PR_TRUE);
    1:   }
    1: 
    1:   NS_IMETHOD Run()
    1:   {
    1:     mProcessor->TransformToDoc(nsnull, nsnull);
    1:     return NS_OK;
    1:   }
    1: };
    1: 
    1: nsresult
    1: txMozillaXSLTProcessor::DoTransform()
    1: {
    1:     NS_ENSURE_TRUE(mSource, NS_ERROR_UNEXPECTED);
    1:     NS_ENSURE_TRUE(mStylesheet, NS_ERROR_UNEXPECTED);
    1:     NS_ASSERTION(mObserver, "no observer");
    1:     NS_ASSERTION(NS_IsMainThread(), "should only be on main thread");
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDocument> document = do_QueryInterface(mSource, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIRunnable> event = new nsTransformBlockerEvent(this);
    1:     if (!event) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     document->BlockOnload();
    1: 
    1:     rv = NS_DispatchToCurrentThread(event);
    1:     if (NS_FAILED(rv)) {
    1:         // XXX Maybe we should just display the source document in this case?
    1:         //     Also, set up context information, see bug 204655.
    1:         reportError(rv, nsnull, nsnull);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::ImportStylesheet(nsIDOMNode *aStyle)
    1: {
    1:     NS_ENSURE_TRUE(aStyle, NS_ERROR_NULL_POINTER);
    1:     
    1:     // We don't support importing multiple stylesheets yet.
    1:     NS_ENSURE_TRUE(!mStylesheetDocument && !mStylesheet,
    1:                    NS_ERROR_NOT_IMPLEMENTED);
    1: 
    1:     if (!nsContentUtils::CanCallerAccess(aStyle)) {
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
    1:     
 6372:     nsCOMPtr<nsINode> styleNode = do_QueryInterface(aStyle);
 6372:     NS_ENSURE_TRUE(styleNode &&
41637:                    (styleNode->IsElement() ||
 6372:                     styleNode->IsNodeOfType(nsINode::eDOCUMENT)),
    1:                    NS_ERROR_INVALID_ARG);
    1: 
 6372:     nsresult rv = TX_CompileStylesheet(styleNode, this, mPrincipal,
    1:                                        getter_AddRefs(mStylesheet));
    1:     // XXX set up exception context, bug 204658
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
41637:     if (styleNode->IsElement()) {
 6372:         mStylesheetDocument = styleNode->GetOwnerDoc();
 6372:         NS_ENSURE_TRUE(mStylesheetDocument, NS_ERROR_UNEXPECTED);
    1: 
 6372:         mEmbeddedStylesheetRoot = static_cast<nsIContent*>(styleNode.get());
    1:     }
    1:     else {
 6372:         mStylesheetDocument = static_cast<nsIDocument*>(styleNode.get());
    1:     }
    1: 
    1:     mStylesheetDocument->AddMutationObserver(this);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::TransformToDocument(nsIDOMNode *aSource,
    1:                                             nsIDOMDocument **aResult)
    1: {
    1:     NS_ENSURE_ARG(aSource);
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1:     NS_ENSURE_SUCCESS(mCompileResult, mCompileResult);
    1: 
    1:     if (!nsContentUtils::CanCallerAccess(aSource)) {
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
    1: 
    1:     nsresult rv = ensureStylesheet();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mSource = aSource;
    1: 
    1:     return TransformToDoc(nsnull, aResult);
    1: }
    1: 
    1: nsresult
    1: txMozillaXSLTProcessor::TransformToDoc(nsIDOMDocument *aOutputDoc,
    1:                                        nsIDOMDocument **aResult)
    1: {
    1:     nsAutoPtr<txXPathNode> sourceNode(txXPathNativeNode::createXPathNode(mSource));
    1:     if (!sourceNode) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMDocument> sourceDOMDocument;
    1:     mSource->GetOwnerDocument(getter_AddRefs(sourceDOMDocument));
    1:     if (!sourceDOMDocument) {
    1:         sourceDOMDocument = do_QueryInterface(mSource);
    1:     }
    1: 
    1:     txExecutionState es(mStylesheet, IsLoadDisabled());
    1: 
    1:     // XXX Need to add error observers
    1: 
    1:     txToDocHandlerFactory handlerFactory(&es, sourceDOMDocument, aOutputDoc,
    1:                                          mObserver);
    1:     es.mOutputHandlerFactory = &handlerFactory;
    1: 
    1:     es.init(*sourceNode, &mVariables);
    1: 
    1:     // Process root of XML source document
    1:     nsresult rv = txXSLTProcessor::execute(es);
    1:     
    1:     nsresult endRv = es.end(rv);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = endRv;
    1:     }
    1:     
    1:     if (NS_SUCCEEDED(rv)) {
    1:         if (aResult) {
    1:             txAOutputXMLEventHandler* handler =
 3233:                 static_cast<txAOutputXMLEventHandler*>(es.mOutputHandler);
    1:             handler->getOutputDocument(aResult);
23639:             nsCOMPtr<nsIDocument> doc = do_QueryInterface(*aResult);
23639:             doc->SetReadyStateInternal(nsIDocument::READYSTATE_COMPLETE);
    1:         }
    1:     }
    1:     else if (mObserver) {
    1:         // XXX set up context information, bug 204655
    1:         reportError(rv, nsnull, nsnull);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::TransformToFragment(nsIDOMNode *aSource,
    1:                                             nsIDOMDocument *aOutput,
    1:                                             nsIDOMDocumentFragment **aResult)
    1: {
    1:     NS_ENSURE_ARG(aSource);
    1:     NS_ENSURE_ARG(aOutput);
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1:     NS_ENSURE_SUCCESS(mCompileResult, mCompileResult);
    1: 
    1:     if (!nsContentUtils::CanCallerAccess(aSource) ||
    1:         !nsContentUtils::CanCallerAccess(aOutput)) {
    1:         return NS_ERROR_DOM_SECURITY_ERR;
    1:     }
    1: 
    1:     nsresult rv = ensureStylesheet();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsAutoPtr<txXPathNode> sourceNode(txXPathNativeNode::createXPathNode(aSource));
    1:     if (!sourceNode) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     txExecutionState es(mStylesheet, IsLoadDisabled());
    1: 
    1:     // XXX Need to add error observers
    1: 
    1:     rv = aOutput->CreateDocumentFragment(aResult);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     txToFragmentHandlerFactory handlerFactory(*aResult);
    1:     es.mOutputHandlerFactory = &handlerFactory;
    1: 
    1:     es.init(*sourceNode, &mVariables);
    1: 
    1:     // Process root of XML source document
    1:     rv = txXSLTProcessor::execute(es);
    1:     // XXX setup exception context, bug 204658
    1:     nsresult endRv = es.end(rv);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = endRv;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::SetParameter(const nsAString & aNamespaceURI,
    1:                                      const nsAString & aLocalName,
    1:                                      nsIVariant *aValue)
    1: {
    1:     NS_ENSURE_ARG(aValue);
    1: 
    1:     nsCOMPtr<nsIVariant> value = aValue;
    1: 
    1:     PRUint16 dataType;
    1:     value->GetDataType(&dataType);
    1:     switch (dataType) {
    1:         // Number
    1:         case nsIDataType::VTYPE_INT8:
    1:         case nsIDataType::VTYPE_INT16:
    1:         case nsIDataType::VTYPE_INT32:
    1:         case nsIDataType::VTYPE_INT64:
    1:         case nsIDataType::VTYPE_UINT8:
    1:         case nsIDataType::VTYPE_UINT16:
    1:         case nsIDataType::VTYPE_UINT32:
    1:         case nsIDataType::VTYPE_UINT64:
    1:         case nsIDataType::VTYPE_FLOAT:
    1:         case nsIDataType::VTYPE_DOUBLE:
    1: 
    1:         // Boolean
    1:         case nsIDataType::VTYPE_BOOL:
    1: 
    1:         // String
    1:         case nsIDataType::VTYPE_CHAR:
    1:         case nsIDataType::VTYPE_WCHAR:
    1:         case nsIDataType::VTYPE_DOMSTRING:
    1:         case nsIDataType::VTYPE_CHAR_STR:
    1:         case nsIDataType::VTYPE_WCHAR_STR:
    1:         case nsIDataType::VTYPE_STRING_SIZE_IS:
    1:         case nsIDataType::VTYPE_WSTRING_SIZE_IS:
    1:         case nsIDataType::VTYPE_UTF8STRING:
    1:         case nsIDataType::VTYPE_CSTRING:
    1:         case nsIDataType::VTYPE_ASTRING:
    1:         {
    1:             break;
    1:         }
    1: 
    1:         // Nodeset
    1:         case nsIDataType::VTYPE_INTERFACE:
    1:         case nsIDataType::VTYPE_INTERFACE_IS:
    1:         {
    1:             nsCOMPtr<nsISupports> supports;
    1:             nsresult rv = value->GetAsISupports(getter_AddRefs(supports));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             nsCOMPtr<nsIDOMNode> node = do_QueryInterface(supports);
    1:             if (node) {
    1:                 if (!nsContentUtils::CanCallerAccess(node)) {
    1:                     return NS_ERROR_DOM_SECURITY_ERR;
    1:                 }
    1: 
    1:                 break;
    1:             }
    1: 
    1:             nsCOMPtr<nsIXPathResult> xpathResult = do_QueryInterface(supports);
    1:             if (xpathResult) {
    1:                 nsRefPtr<txAExprResult> result;
    1:                 nsresult rv = xpathResult->GetExprResult(getter_AddRefs(result));
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                 if (result->getResultType() == txAExprResult::NODESET) {
    1:                     txNodeSet *nodeSet =
 3233:                         static_cast<txNodeSet*>
 3233:                                    (static_cast<txAExprResult*>(result));
    1: 
    1:                     nsCOMPtr<nsIDOMNode> node;
    1:                     PRInt32 i, count = nodeSet->size();
    1:                     for (i = 0; i < count; ++i) {
    1:                         rv = txXPathNativeNode::getNode(nodeSet->get(i),
    1:                                                         getter_AddRefs(node));
    1:                         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                         if (!nsContentUtils::CanCallerAccess(node)) {
    1:                             return NS_ERROR_DOM_SECURITY_ERR;
    1:                         }
    1:                     }
    1:                 }
    1: 
    1:                 // Clone the nsXPathResult so that mutations don't affect this
    1:                 // variable.
    1:                 nsCOMPtr<nsIXPathResult> clone;
    1:                 rv = xpathResult->Clone(getter_AddRefs(clone));
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                 nsCOMPtr<nsIWritableVariant> variant =
    1:                     do_CreateInstance("@mozilla.org/variant;1", &rv);
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                 rv = variant->SetAsISupports(clone);
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                 value = variant;
    1: 
    1:                 break;
    1:             }
    1: 
    1:             nsCOMPtr<nsIDOMNodeList> nodeList = do_QueryInterface(supports);
    1:             if (nodeList) {
    1:                 PRUint32 length;
    1:                 nodeList->GetLength(&length);
    1: 
    1:                 nsCOMPtr<nsIDOMNode> node;
    1:                 PRUint32 i;
    1:                 for (i = 0; i < length; ++i) {
    1:                     nodeList->Item(i, getter_AddRefs(node));
    1: 
    1:                     if (!nsContentUtils::CanCallerAccess(node)) {
    1:                         return NS_ERROR_DOM_SECURITY_ERR;
    1:                     }
    1:                 }
    1: 
    1:                 break;
    1:             }
    1: 
    1:             // Random JS Objects will be converted to a string.
    1:             nsCOMPtr<nsIXPConnectJSObjectHolder> holder =
    1:                 do_QueryInterface(supports);
    1:             if (holder) {
    1:                 break;
    1:             }
    1: 
    1:             // We don't know how to handle this type of param.
    1:             return NS_ERROR_ILLEGAL_VALUE;
    1:         }
    1: 
    1:         case nsIDataType::VTYPE_ARRAY:
    1:         {
    1:             PRUint16 type;
    1:             nsIID iid;
    1:             PRUint32 count;
    1:             void* array;
    1:             nsresult rv = value->GetAsArray(&type, &iid, &count, &array);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             if (type != nsIDataType::VTYPE_INTERFACE &&
    1:                 type != nsIDataType::VTYPE_INTERFACE_IS) {
    1:                 nsMemory::Free(array);
    1: 
    1:                 // We only support arrays of DOM nodes.
    1:                 return NS_ERROR_ILLEGAL_VALUE;
    1:             }
    1: 
 3233:             nsISupports** values = static_cast<nsISupports**>(array);
    1: 
    1:             PRUint32 i;
    1:             for (i = 0; i < count; ++i) {
    1:                 nsISupports *supports = values[i];
    1:                 nsCOMPtr<nsIDOMNode> node = do_QueryInterface(supports);
    1: 
    1:                 if (node) {
    1:                     rv = nsContentUtils::CanCallerAccess(node) ? NS_OK :
    1:                          NS_ERROR_DOM_SECURITY_ERR;
    1:                 }
    1:                 else {
    1:                     // We only support arrays of DOM nodes.
    1:                     rv = NS_ERROR_ILLEGAL_VALUE;
    1:                 }
    1: 
    1:                 if (NS_FAILED(rv)) {
    1:                     while (i < count) {
55280:                         NS_IF_RELEASE(values[i]);
    1:                         ++i;
    1:                     }
    1:                     nsMemory::Free(array);
    1: 
    1:                     return rv;
    1:                 }
    1: 
    1:                 NS_RELEASE(supports);
    1:             }
    1: 
    1:             nsMemory::Free(array);
    1: 
    1:             break;
    1:         }
    1: 
    1:         default:
    1:         {
    1:             return NS_ERROR_FAILURE;
    1:         }        
    1:     }
    1: 
    1:     PRInt32 nsId = kNameSpaceID_Unknown;
    1:     nsresult rv = nsContentUtils::NameSpaceManager()->
    1:         RegisterNameSpace(aNamespaceURI, nsId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIAtom> localName = do_GetAtom(aLocalName);
    1:     txExpandedName varName(nsId, localName);
    1: 
 3233:     txVariable* var = static_cast<txVariable*>(mVariables.get(varName));
    1:     if (var) {
    1:         var->setValue(value);
    1:         return NS_OK;
    1:     }
    1: 
    1:     var = new txVariable(value);
    1:     NS_ENSURE_TRUE(var, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return mVariables.add(varName, var);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::GetParameter(const nsAString& aNamespaceURI,
    1:                                      const nsAString& aLocalName,
    1:                                      nsIVariant **aResult)
    1: {
    1:     PRInt32 nsId = kNameSpaceID_Unknown;
    1:     nsresult rv = nsContentUtils::NameSpaceManager()->
    1:         RegisterNameSpace(aNamespaceURI, nsId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIAtom> localName = do_GetAtom(aLocalName);
    1:     txExpandedName varName(nsId, localName);
    1: 
 3233:     txVariable* var = static_cast<txVariable*>(mVariables.get(varName));
    1:     if (var) {
    1:         return var->getValue(aResult);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::RemoveParameter(const nsAString& aNamespaceURI,
    1:                                         const nsAString& aLocalName)
    1: {
    1:     PRInt32 nsId = kNameSpaceID_Unknown;
    1:     nsresult rv = nsContentUtils::NameSpaceManager()->
    1:         RegisterNameSpace(aNamespaceURI, nsId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIAtom> localName = do_GetAtom(aLocalName);
    1:     txExpandedName varName(nsId, localName);
    1: 
    1:     mVariables.remove(varName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::ClearParameters()
    1: {
    1:     mVariables.clear();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::Reset()
    1: {
    1:     if (mStylesheetDocument) {
    1:         mStylesheetDocument->RemoveMutationObserver(this);
    1:     }
    1:     mStylesheet = nsnull;
    1:     mStylesheetDocument = nsnull;
    1:     mEmbeddedStylesheetRoot = nsnull;
    1:     mCompileResult = NS_OK;
    1:     mVariables.clear();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::SetFlags(PRUint32 aFlags)
    1: {
    1:     NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(),
    1:                    NS_ERROR_DOM_SECURITY_ERR);
    1: 
    1:     mFlags = aFlags;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: txMozillaXSLTProcessor::GetFlags(PRUint32* aFlags)
    1: {
    1:     NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(),
    1:                    NS_ERROR_DOM_SECURITY_ERR);
    1: 
    1:     *aFlags = mFlags;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 3582: txMozillaXSLTProcessor::LoadStyleSheet(nsIURI* aUri, nsILoadGroup* aLoadGroup)
    1: {
 3582:     nsresult rv = TX_LoadSheet(aUri, this, aLoadGroup, mPrincipal);
    1:     if (NS_FAILED(rv) && mObserver) {
    1:         // This is most likely a network or security error, just
    1:         // use the uri as context.
    1:         nsCAutoString spec;
    1:         aUri->GetSpec(spec);
    1:         CopyUTF8toUTF16(spec, mSourceText);
    1:         nsresult status = NS_ERROR_GET_MODULE(rv) == NS_ERROR_MODULE_XSLT ? rv :
    1:                           NS_ERROR_XSLT_NETWORK_ERROR;
    1:         reportError(status, nsnull, nsnull);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: txMozillaXSLTProcessor::setStylesheet(txStylesheet* aStylesheet)
    1: {
    1:     mStylesheet = aStylesheet;
    1:     if (mSource) {
    1:         return DoTransform();
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::reportError(nsresult aResult,
    1:                                     const PRUnichar *aErrorText,
    1:                                     const PRUnichar *aSourceText)
    1: {
    1:     if (!mObserver) {
    1:         return;
    1:     }
    1: 
    1:     mTransformResult = aResult;
    1: 
    1:     if (aErrorText) {
    1:         mErrorText.Assign(aErrorText);
    1:     }
    1:     else {
    1:         nsCOMPtr<nsIStringBundleService> sbs =
42314:             mozilla::services::GetStringBundleService();
    1:         if (sbs) {
    1:             nsXPIDLString errorText;
    1:             sbs->FormatStatusMessage(aResult, EmptyString().get(),
    1:                                      getter_Copies(errorText));
    1: 
    1:             nsXPIDLString errorMessage;
    1:             nsCOMPtr<nsIStringBundle> bundle;
    1:             sbs->CreateBundle(XSLT_MSGS_URL, getter_AddRefs(bundle));
    1: 
    1:             if (bundle) {
    1:                 const PRUnichar* error[] = { errorText.get() };
    1:                 if (mStylesheet) {
    1:                     bundle->FormatStringFromName(NS_LITERAL_STRING("TransformError").get(),
    1:                                                  error, 1,
    1:                                                  getter_Copies(errorMessage));
    1:                 }
    1:                 else {
    1:                     bundle->FormatStringFromName(NS_LITERAL_STRING("LoadingError").get(),
    1:                                                  error, 1,
    1:                                                  getter_Copies(errorMessage));
    1:                 }
    1:             }
    1:             mErrorText.Assign(errorMessage);
    1:         }
    1:     }
    1: 
    1:     if (aSourceText) {
    1:         mSourceText.Assign(aSourceText);
    1:     }
    1: 
    1:     if (mSource) {
    1:         notifyError();
    1:     }
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::notifyError()
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDOMDocument> errorDocument = do_CreateInstance(kXMLDocumentCID,
    1:                                                                &rv);
    1:     if (NS_FAILED(rv)) {
    1:         return;
    1:     }
    1: 
    1:     // Set up the document
    1:     nsCOMPtr<nsIDocument> document = do_QueryInterface(errorDocument);
    1:     if (!document) {
    1:         return;
    1:     }
    1:     URIUtils::ResetWithSource(document, mSource);
    1: 
    1:     NS_NAMED_LITERAL_STRING(ns, "http://www.mozilla.org/newlayout/xml/parsererror.xml");
    1: 
    1:     nsCOMPtr<nsIDOMElement> element;
    1:     rv = errorDocument->CreateElementNS(ns, NS_LITERAL_STRING("parsererror"),
    1:                                         getter_AddRefs(element));
    1:     if (NS_FAILED(rv)) {
    1:         return;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMNode> resultNode;
    1:     rv = errorDocument->AppendChild(element, getter_AddRefs(resultNode));
    1:     if (NS_FAILED(rv)) {
    1:         return;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMText> text;
    1:     rv = errorDocument->CreateTextNode(mErrorText, getter_AddRefs(text));
    1:     if (NS_FAILED(rv)) {
    1:         return;
    1:     }
    1: 
    1:     rv = element->AppendChild(text, getter_AddRefs(resultNode));
    1:     if (NS_FAILED(rv)) {
    1:         return;
    1:     }
    1: 
    1:     if (!mSourceText.IsEmpty()) {
    1:         nsCOMPtr<nsIDOMElement> sourceElement;
    1:         rv = errorDocument->CreateElementNS(ns,
    1:                                             NS_LITERAL_STRING("sourcetext"),
    1:                                             getter_AddRefs(sourceElement));
    1:         if (NS_FAILED(rv)) {
    1:             return;
    1:         }
    1:     
    1:         rv = element->AppendChild(sourceElement, getter_AddRefs(resultNode));
    1:         if (NS_FAILED(rv)) {
    1:             return;
    1:         }
    1: 
    1:         rv = errorDocument->CreateTextNode(mSourceText, getter_AddRefs(text));
    1:         if (NS_FAILED(rv)) {
    1:             return;
    1:         }
    1:     
    1:         rv = sourceElement->AppendChild(text, getter_AddRefs(resultNode));
    1:         if (NS_FAILED(rv)) {
    1:             return;
    1:         }
    1:     }
    1: 
    1:     mObserver->OnTransformDone(mTransformResult, document);
    1: }
    1: 
    1: nsresult
    1: txMozillaXSLTProcessor::ensureStylesheet()
    1: {
    1:     if (mStylesheet) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     NS_ENSURE_TRUE(mStylesheetDocument, NS_ERROR_NOT_INITIALIZED);
    1: 
 6372:     nsINode* style = mEmbeddedStylesheetRoot;
    1:     if (!style) {
 6372:         style = mStylesheetDocument;
    1:     }
 6372: 
 3582:     return TX_CompileStylesheet(style, this, mPrincipal,
 3582:                                 getter_AddRefs(mStylesheet));
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::NodeWillBeDestroyed(const nsINode* aNode)
    1: {
48009:     nsCOMPtr<nsIMutationObserver> kungFuDeathGrip(this);
    1:     if (NS_FAILED(mCompileResult)) {
    1:         return;
    1:     }
    1: 
    1:     mCompileResult = ensureStylesheet();
    1:     mStylesheetDocument = nsnull;
    1:     mEmbeddedStylesheetRoot = nsnull;
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::CharacterDataChanged(nsIDocument* aDocument,
    1:                                              nsIContent *aContent,
    1:                                              CharacterDataChangeInfo* aInfo)
    1: {
    1:     mStylesheet = nsnull;
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::AttributeChanged(nsIDocument* aDocument,
51350:                                          Element* aElement,
    1:                                          PRInt32 aNameSpaceID,
    1:                                          nsIAtom* aAttribute,
35535:                                          PRInt32 aModType)
    1: {
    1:     mStylesheet = nsnull;
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::ContentAppended(nsIDocument* aDocument,
    1:                                         nsIContent* aContainer,
42107:                                         nsIContent* aFirstNewContent,
42107:                                         PRInt32 /* unused */)
    1: {
    1:     mStylesheet = nsnull;
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::ContentInserted(nsIDocument* aDocument,
    1:                                         nsIContent* aContainer,
    1:                                         nsIContent* aChild,
42107:                                         PRInt32 /* unused */)
    1: {
    1:     mStylesheet = nsnull;
    1: }
    1: 
    1: void
    1: txMozillaXSLTProcessor::ContentRemoved(nsIDocument* aDocument,
    1:                                        nsIContent* aContainer,
    1:                                        nsIContent* aChild,
48038:                                        PRInt32 aIndexInContainer,
48038:                                        nsIContent* aPreviousSibling)
    1: {
    1:     mStylesheet = nsnull;
    1: }
    1: 
 3582: NS_IMETHODIMP
 8947: txMozillaXSLTProcessor::Initialize(nsISupports* aOwner, JSContext* cx,
 8947:                                    JSObject* obj, PRUint32 argc, jsval* argv)
 3582: {
 3582:     nsCOMPtr<nsIPrincipal> prin;
 3582:     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 3582:     NS_ENSURE_TRUE(secMan, NS_ERROR_UNEXPECTED);
 3582: 
 3582:     secMan->GetSubjectPrincipal(getter_AddRefs(prin));
 3582:     NS_ENSURE_TRUE(prin, NS_ERROR_UNEXPECTED);
 3582: 
 3582:     return Init(prin);
 3582: }
 3582: 
 3582: NS_IMETHODIMP
 3582: txMozillaXSLTProcessor::Init(nsIPrincipal* aPrincipal)
 3582: {
 3582:     NS_ENSURE_ARG_POINTER(aPrincipal);
 3582:     mPrincipal = aPrincipal;
 3582: 
 3582:     return NS_OK;
 3582: }
 3582: 
    1: /* static*/
    1: nsresult
 3582: txMozillaXSLTProcessor::Startup()
    1: {
    1:     if (!txXSLTProcessor::init()) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     nsCOMPtr<nsIErrorService> errorService =
    1:         do_GetService(NS_ERRORSERVICE_CONTRACTID);
    1:     if (errorService) {
    1:         errorService->RegisterErrorStringBundle(NS_ERROR_MODULE_XSLT,
    1:                                                 XSLT_MSGS_URL);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* static*/
    1: void
    1: txMozillaXSLTProcessor::Shutdown()
    1: {
    1:     txXSLTProcessor::shutdown();
    1: 
    1:     nsCOMPtr<nsIErrorService> errorService =
    1:         do_GetService(NS_ERRORSERVICE_CONTRACTID);
    1:     if (errorService) {
    1:         errorService->UnregisterErrorStringBundle(NS_ERROR_MODULE_XSLT);
    1:     }
    1: }
    1: 
    1: /* static*/
    1: nsresult
    1: txVariable::Convert(nsIVariant *aValue, txAExprResult** aResult)
    1: {
    1:     *aResult = nsnull;
    1: 
    1:     PRUint16 dataType;
    1:     aValue->GetDataType(&dataType);
    1:     switch (dataType) {
    1:         // Number
    1:         case nsIDataType::VTYPE_INT8:
    1:         case nsIDataType::VTYPE_INT16:
    1:         case nsIDataType::VTYPE_INT32:
    1:         case nsIDataType::VTYPE_INT64:
    1:         case nsIDataType::VTYPE_UINT8:
    1:         case nsIDataType::VTYPE_UINT16:
    1:         case nsIDataType::VTYPE_UINT32:
    1:         case nsIDataType::VTYPE_UINT64:
    1:         case nsIDataType::VTYPE_FLOAT:
    1:         case nsIDataType::VTYPE_DOUBLE:
    1:         {
    1:             double value;
    1:             nsresult rv = aValue->GetAsDouble(&value);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             *aResult = new NumberResult(value, nsnull);
    1:             NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:             NS_ADDREF(*aResult);
    1: 
    1:             return NS_OK;
    1:         }
    1: 
    1:         // Boolean
    1:         case nsIDataType::VTYPE_BOOL:
    1:         {
    1:             PRBool value;
    1:             nsresult rv = aValue->GetAsBool(&value);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             *aResult = new BooleanResult(value);
    1:             NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:             NS_ADDREF(*aResult);
    1: 
    1:             return NS_OK;
    1:         }
    1: 
    1:         // String
    1:         case nsIDataType::VTYPE_CHAR:
    1:         case nsIDataType::VTYPE_WCHAR:
    1:         case nsIDataType::VTYPE_DOMSTRING:
    1:         case nsIDataType::VTYPE_CHAR_STR:
    1:         case nsIDataType::VTYPE_WCHAR_STR:
    1:         case nsIDataType::VTYPE_STRING_SIZE_IS:
    1:         case nsIDataType::VTYPE_WSTRING_SIZE_IS:
    1:         case nsIDataType::VTYPE_UTF8STRING:
    1:         case nsIDataType::VTYPE_CSTRING:
    1:         case nsIDataType::VTYPE_ASTRING:
    1:         {
    1:             nsAutoString value;
    1:             nsresult rv = aValue->GetAsAString(value);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             *aResult = new StringResult(value, nsnull);
    1:             NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:             NS_ADDREF(*aResult);
    1: 
    1:             return NS_OK;
    1:         }
    1: 
    1:         // Nodeset
    1:         case nsIDataType::VTYPE_INTERFACE:
    1:         case nsIDataType::VTYPE_INTERFACE_IS:
    1:         {
    1:             nsCOMPtr<nsISupports> supports;
    1:             nsresult rv = aValue->GetAsISupports(getter_AddRefs(supports));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             nsCOMPtr<nsIDOMNode> node = do_QueryInterface(supports);
    1:             if (node) {
    1:                 nsAutoPtr<txXPathNode> xpathNode(txXPathNativeNode::createXPathNode(node));
    1:                 if (!xpathNode) {
    1:                     return NS_ERROR_FAILURE;
    1:                 }
    1: 
    1:                 *aResult = new txNodeSet(*xpathNode, nsnull);
    1:                 if (!*aResult) {
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 }
    1: 
    1:                 NS_ADDREF(*aResult);
    1: 
    1:                 return NS_OK;
    1:             }
    1: 
    1:             nsCOMPtr<nsIXPathResult> xpathResult = do_QueryInterface(supports);
    1:             if (xpathResult) {
    1:                 return xpathResult->GetExprResult(aResult);
    1:             }
    1: 
    1:             nsCOMPtr<nsIDOMNodeList> nodeList = do_QueryInterface(supports);
    1:             if (nodeList) {
    1:                 nsRefPtr<txNodeSet> nodeSet = new txNodeSet(nsnull);
    1:                 if (!nodeSet) {
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 }
    1: 
    1:                 PRUint32 length;
    1:                 nodeList->GetLength(&length);
    1: 
    1:                 nsCOMPtr<nsIDOMNode> node;
    1:                 PRUint32 i;
    1:                 for (i = 0; i < length; ++i) {
    1:                     nodeList->Item(i, getter_AddRefs(node));
    1: 
    1:                     nsAutoPtr<txXPathNode> xpathNode(
    1:                         txXPathNativeNode::createXPathNode(node));
    1:                     if (!xpathNode) {
    1:                         return NS_ERROR_FAILURE;
    1:                     }
    1: 
    1:                     nodeSet->add(*xpathNode);
    1:                 }
    1: 
    1:                 NS_ADDREF(*aResult = nodeSet);
    1: 
    1:                 return NS_OK;
    1:             }
    1: 
    1:             // Convert random JS Objects to a string.
    1:             nsCOMPtr<nsIXPConnectJSObjectHolder> holder =
    1:                 do_QueryInterface(supports);
    1:             if (holder) {
18868:                 JSContext* cx = nsContentUtils::GetCurrentJSContext();
18868:                 NS_ENSURE_TRUE(cx, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:                 JSObject *jsobj;
    1:                 rv = holder->GetJSObject(&jsobj);
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:                 JSString *str = JS_ValueToString(cx, OBJECT_TO_JSVAL(jsobj));
    1:                 NS_ENSURE_TRUE(str, NS_ERROR_FAILURE);
    1: 
    1:                 const PRUnichar *strChars =
 3233:                     reinterpret_cast<const PRUnichar*>
 3233:                                     (::JS_GetStringChars(str));
    1:                 nsDependentString value(strChars, ::JS_GetStringLength(str));
    1: 
    1:                 *aResult = new StringResult(value, nsnull);
    1:                 if (!*aResult) {
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 }
    1: 
    1:                 NS_ADDREF(*aResult);
    1: 
    1:                 return NS_OK;
    1:             }
    1: 
    1:             break;
    1:         }
    1: 
    1:         case nsIDataType::VTYPE_ARRAY:
    1:         {
    1:             PRUint16 type;
    1:             nsIID iid;
    1:             PRUint32 count;
    1:             void* array;
    1:             nsresult rv = aValue->GetAsArray(&type, &iid, &count, &array);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             NS_ASSERTION(type == nsIDataType::VTYPE_INTERFACE ||
    1:                          type == nsIDataType::VTYPE_INTERFACE_IS,
    1:                          "Huh, we checked this in SetParameter?");
    1: 
 3233:             nsISupports** values = static_cast<nsISupports**>(array);
    1: 
    1:             nsRefPtr<txNodeSet> nodeSet = new txNodeSet(nsnull);
    1:             if (!nodeSet) {
    1:                 NS_FREE_XPCOM_ISUPPORTS_POINTER_ARRAY(count, values);
    1: 
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:             }
    1: 
    1:             PRUint32 i;
    1:             for (i = 0; i < count; ++i) {
    1:                 nsISupports *supports = values[i];
    1:                 nsCOMPtr<nsIDOMNode> node = do_QueryInterface(supports);
    1:                 NS_ASSERTION(node, "Huh, we checked this in SetParameter?");
    1: 
    1:                 nsAutoPtr<txXPathNode> xpathNode(
    1:                     txXPathNativeNode::createXPathNode(node));
    1:                 if (!xpathNode) {
    1:                     while (i < count) {
    1:                         NS_RELEASE(values[i]);
    1:                         ++i;
    1:                     }
    1:                     nsMemory::Free(array);
    1: 
    1:                     return NS_ERROR_FAILURE;
    1:                 }
    1: 
    1:                 nodeSet->add(*xpathNode);
    1: 
    1:                 NS_RELEASE(supports);
    1:             }
    1: 
    1:             nsMemory::Free(array);
    1: 
    1:             NS_ADDREF(*aResult = nodeSet);
    1: 
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: }
