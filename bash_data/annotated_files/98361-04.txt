43426: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43426: /* ***** BEGIN LICENSE BLOCK *****
43426:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43426:  *
43426:  * The contents of this file are subject to the Mozilla Public License Version
43426:  * 1.1 (the "License"); you may not use this file except in compliance with
43426:  * the License. You may obtain a copy of the License at
43426:  * http://www.mozilla.org/MPL/
43426:  *
43426:  * Software distributed under the License is distributed on an "AS IS" basis,
43426:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43426:  * for the specific language governing rights and limitations under the
43426:  * License.
43426:  *
43426:  * The Original Code is mozilla.org code.
43426:  *
43426:  * The Initial Developer of the Original Code is
43426:  *   Mozilla Corporation.
43426:  * Portions created by the Initial Developer are Copyright (C) 2010
43426:  * the Initial Developer. All Rights Reserved.
43426:  *
43426:  * Contributor(s):
43426:  *   Vladimir Vukicevic <vladimir@pobox.com>
43426:  *   Mark Steele <mwsteele@gmail.com>
43426:  *   Bas Schouten <bschouten@mozilla.com>
43426:  *   Frederic Plourde <frederic.plourde@collabora.co.uk>
43426:  *
43426:  * Alternatively, the contents of this file may be used under the terms of
43426:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43426:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43426:  * in which case the provisions of the GPL or the LGPL are applicable instead
43426:  * of those above. If you wish to allow use of your version of this file only
43426:  * under the terms of either the GPL or the LGPL, and not to allow others to
43426:  * use your version of this file under the terms of the MPL, indicate your
43426:  * decision by deleting the provisions above and replace them with the notice
43426:  * and other provisions required by the GPL or the LGPL. If you do not delete
43426:  * the provisions above, a recipient may use your version of this file under
43426:  * the terms of any one of the MPL, the GPL or the LGPL.
43426:  *
43426:  * ***** END LICENSE BLOCK ***** */
43426: 
80467: #include "mozilla/Util.h"
92119: // please add new includes below Qt, otherwise it break Qt build due malloc wrapper conflicts
91861: 
77137: #if defined(XP_UNIX)
43426: 
43426: #ifdef MOZ_WIDGET_GTK2
43426: #include <gdk/gdkx.h>
43426: // we're using default display for now
43426: #define GET_NATIVE_WINDOW(aWidget) (EGLNativeWindowType)GDK_WINDOW_XID((GdkWindow *) aWidget->GetNativeData(NS_NATIVE_WINDOW))
43426: #elif defined(MOZ_WIDGET_QT)
77137: #include <QtOpenGL/QGLContext>
44172: #define GLdouble_defined 1
43426: // we're using default display for now
77137: #define GET_NATIVE_WINDOW(aWidget) (EGLNativeWindowType)static_cast<QWidget*>(aWidget->GetNativeData(NS_NATIVE_SHELLWIDGET))->winId()
82142: #elif defined(MOZ_WIDGET_GONK)
82142: #define GET_NATIVE_WINDOW(aWidget) ((EGLNativeWindowType)aWidget->GetNativeData(NS_NATIVE_WINDOW))
43426: #endif
43426: 
77137: #if defined(MOZ_X11)
43426: #include <X11/Xlib.h>
43426: #include <X11/Xutil.h>
47908: #include "mozilla/X11Util.h"
44173: #include "gfxXlibSurface.h"
77137: #endif
77137: 
77137: #if defined(ANDROID)
77137: /* from widget */
82142: #if defined(MOZ_WIDGET_ANDROID)
77137: #include "AndroidBridge.h"
82142: #endif
82142: #include <android/log.h>
87843: #endif
87843: 
87223: #define GLES2_LIB "libGLESv2.so"
87843: #define GLES2_LIB2 "libGLESv2.so.2"
43426: 
49076: #elif defined(XP_WIN)
49076: 
58583: #include "nsILocalFile.h"
49078: 
93376: #define GLES2_LIB "libGLESv2.dll"
93376: 
49076: #ifndef WIN32_LEAN_AND_MEAN
49076: #define WIN32_LEAN_AND_MEAN 1
49076: #endif
49076: 
49076: #include <windows.h>
49076: 
49076: // a little helper
49076: class AutoDestroyHWND {
49076: public:
49076:     AutoDestroyHWND(HWND aWnd = NULL)
49076:         : mWnd(aWnd)
49076:     {
49076:     }
49076: 
49076:     ~AutoDestroyHWND() {
49076:         if (mWnd) {
49076:             ::DestroyWindow(mWnd);
49076:         }
49076:     }
49076: 
49076:     operator HWND() {
49076:         return mWnd;
49076:     }
49076: 
49076:     HWND forget() {
49076:         HWND w = mWnd;
49076:         mWnd = NULL;
49076:         return w;
49076:     }
49076: 
49076:     HWND operator=(HWND aWnd) {
49076:         if (mWnd && mWnd != aWnd) {
49076:             ::DestroyWindow(mWnd);
49076:         }
49076:         mWnd = aWnd;
49076:         return mWnd;
49076:     }
49076: 
49076:     HWND mWnd;
49076: };
49076: 
43426: #else
43426: 
43426: #error "Platform not recognized"
43426: 
43426: #endif
43426: 
92119: #include "mozilla/Preferences.h"
92119: #include "nsIScreen.h"
92119: #include "nsIScreenManager.h"
60438: #include "gfxUtils.h"
77638: #include "gfxFailure.h"
44182: #include "gfxASurface.h"
53687: #include "gfxImageSurface.h"
46978: #include "gfxPlatform.h"
43426: #include "GLContextProvider.h"
93376: #include "GLLibraryEGL.h"
43426: #include "nsDebug.h"
58301: #include "nsThreadUtils.h"
43426: 
43426: #include "nsIWidget.h"
43426: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
60438: #ifdef MOZ_PLATFORM_MAEMO
60438: static bool gUseBackingSurface = true;
60438: #else
58301: static bool gUseBackingSurface = false;
60438: #endif
58301: 
82142: #ifdef MOZ_WIDGET_GONK
82142: extern nsIntRect gScreenBounds;
82142: #endif
82142: 
43426: namespace mozilla {
43426: namespace gl {
43426: 
93376: static GLLibraryEGL sEGLLibrary;
47908: 
60090: #define ADD_ATTR_2(_array, _k, _v) do {         \
60090:     (_array).AppendElement(_k);                 \
60090:     (_array).AppendElement(_v);                 \
60090: } while (0)
60090: 
60090: #define ADD_ATTR_1(_array, _k) do {             \
60090:     (_array).AppendElement(_k);                 \
60090: } while (0)
60090: 
78716: static EGLSurface
59165: CreateSurfaceForWindow(nsIWidget *aWidget, EGLConfig config);
78716: static bool
78716: CreateConfig(EGLConfig* aConfig);
60438: #ifdef MOZ_X11
74436: 
74436: #ifdef MOZ_EGL_XRENDER_COMPOSITE
74436: static EGLSurface
74436: CreateBasicEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig);
74436: #endif
74436: 
60438: static EGLConfig
97354: CreateEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig = nsnull);
60438: #endif
59165: 
84592: static EGLint gContextAttribs[] = {
84592:     LOCAL_EGL_CONTEXT_CLIENT_VERSION, 2,
84592:     LOCAL_EGL_NONE
84592: };
84592: 
84592: static EGLint gContextAttribsRobustness[] = {
84592:     LOCAL_EGL_CONTEXT_CLIENT_VERSION, 2,
84592:     //LOCAL_EGL_CONTEXT_ROBUST_ACCESS_EXT, LOCAL_EGL_TRUE,
84592:     LOCAL_EGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_EXT, LOCAL_EGL_LOSE_CONTEXT_ON_RESET_EXT,
84592:     LOCAL_EGL_NONE
84592: };
84592: 
47908: static int
47908: next_power_of_two(int v)
47908: {
47908:     v--;
47908:     v |= v >> 1;
47908:     v |= v >> 2;
47908:     v |= v >> 4;
47908:     v |= v >> 8;
47908:     v |= v >> 16;
47908:     v++;
47908: 
47908:     return v;
47908: }
47908: 
47908: static bool
47908: is_power_of_two(int v)
47908: {
47908:     NS_ASSERTION(v >= 0, "bad value");
47908: 
47908:     if (v == 0)
47908:         return true;
47908: 
47908:     return (v & (v-1)) == 0;
47908: }
47908: 
43426: class GLContextEGL : public GLContext
43426: {
46978:     friend class TextureImageEGL;
46978: 
71551:     static already_AddRefed<GLContextEGL>
71551:     CreateGLContext(const ContextFormat& format,
71551:                     EGLSurface surface,
71551:                     EGLConfig config,
71551:                     GLContextEGL *shareContext,
79445:                     bool aIsOffscreen = false)
71551:     {
71551:         EGLContext context;
71551: 
71551:         context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
71551:                                              config,
71551:                                              shareContext ? shareContext->mContext : EGL_NO_CONTEXT,
84592:                                              sEGLLibrary.HasRobustness() ? gContextAttribsRobustness
84592:                                                                          : gContextAttribs);
71551:         if (!context) {
71551:             if (shareContext) {
71551:                 shareContext = nsnull;
71551:                 context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
71551:                                                      config,
71551:                                                      EGL_NO_CONTEXT,
84592:                                                      sEGLLibrary.HasRobustness() ? gContextAttribsRobustness
84592:                                                                                  : gContextAttribs);
71551:                 if (!context) {
71551:                     NS_WARNING("Failed to create EGLContext!");
71551:                     return nsnull;
71551:                 }
71551:             }
71551:         }
71551: 
71551:         nsRefPtr<GLContextEGL> glContext =
71551:             new GLContextEGL(format, shareContext, config,
71551:                              surface, context, aIsOffscreen);
71551: 
71551:         if (!glContext->Init())
71551:             return nsnull;
71551: 
71551:         return glContext.forget();
71551:     }
71551: 
43426: public:
47908:     GLContextEGL(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  EGLConfig aConfig,
47908:                  EGLSurface aSurface,
47908:                  EGLContext aContext,
79445:                  bool aIsOffscreen = false)
47908:         : GLContext(aFormat, aIsOffscreen, aShareContext)
47908:         , mConfig(aConfig) 
44172:         , mSurface(aSurface), mContext(aContext)
77137:         , mPlatformContext(nsnull)
47908:         , mThebesSurface(nsnull)
80486:         , mBound(false)
80486:         , mIsPBuffer(false)
80486:         , mIsDoubleBuffered(false)
93759:         , mCanBindToTexture(false)
49076:     {
49076:         // any EGL contexts will always be GLESv2
80486:         SetIsGLES2(true);
53687: 
55263: #ifdef DEBUG
53687:         printf_stderr("Initializing context %p surface %p on display %p\n", mContext, mSurface, EGL_DISPLAY());
55263: #endif
49076:     }
43426: 
43426:     ~GLContextEGL()
43426:     {
54505:         MarkDestroyed();
49071: 
44172:         // If mGLWidget is non-null, then we've been given it by the GL context provider,
44172:         // and it's managed by the widget implementation. In this case, We can't destroy
44172:         // our contexts.
77137:         if (mPlatformContext)
44172:             return;
44172: 
55263: #ifdef DEBUG
53687:         printf_stderr("Destroying context %p surface %p on display %p\n", mContext, mSurface, EGL_DISPLAY());
55263: #endif
53687: 
47908:         sEGLLibrary.fDestroyContext(EGL_DISPLAY(), mContext);
78284:         if (mSurface && !mPlatformContext) {
47908:             sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
47908:         }
77086:     }
47908: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeEGL;
43426:     }
43426: 
79445:     bool Init()
43426:     {
91516: #if defined(ANDROID)
91516:         // We can't use LoadApitraceLibrary here because the GLContext
91516:         // expects its own handle to the GL library
91516:         if (!OpenLibrary(APITRACE_LIB))
91516: #endif
43426:             if (!OpenLibrary(GLES2_LIB)) {
87843: #if defined(XP_UNIX)
87843:                 if (!OpenLibrary(GLES2_LIB2)) {
91516:                     NS_WARNING("Couldn't load GLES2 LIB.");
91516:                     return false;
87843:                 }
87843: #endif
43426:             }
43426: 
79445:         bool current = MakeCurrent();
77638:         if (!current) {
77638:             gfx::LogFailure(NS_LITERAL_CSTRING(
77638:                 "Couldn't get device attachments for device."));
80486:             return false;
77638:         }
77638: 
79445:         bool ok = InitWithPrefix("gl", true);
81033: 
81033:         PR_STATIC_ASSERT(sizeof(GLint) >= sizeof(int32_t));
81033:         mMaxTextureImageSize = PR_INT32_MAX;
53687: #if 0
53687:         if (ok) {
53687:             EGLint v;
53687:             sEGLLibrary.fQueryContext(EGL_DISPLAY(), mContext, LOCAL_EGL_RENDER_BUFFER, &v);
53687:             if (v == LOCAL_EGL_BACK_BUFFER)
80486:                 mIsDoubleBuffered = true;
53687:         }
53687: #endif
84592: 
92137:         if (ok)
92137:             InitFramebuffers();
92137: 
53687:         return ok;
53687:     }
53687: 
79445:     bool IsDoubleBuffered() {
53687:         return mIsDoubleBuffered;
53687:     }
53687: 
79445:     void SetIsDoubleBuffered(bool aIsDB) {
53687:         mIsDoubleBuffered = aIsDB;
43426:     }
43426: 
82479:     bool SupportsRobustness()
82479:     {
84592:         return sEGLLibrary.HasRobustness();
84592:     }
84592: 
84592:     virtual bool IsANGLE()
84592:     {
84592:         return sEGLLibrary.IsANGLE();
82479:     }
82479: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:     gfxASurface* GetOffscreenPixmapSurface()
74436:     {
74436:       return mThebesSurface;
74436:     }
74436:     
79445:     virtual bool WaitNative() {
74436:       return sEGLLibrary.fWaitNative(LOCAL_EGL_CORE_NATIVE_ENGINE);
74436:     }
74436: #endif
74436: 
79445:     bool BindTexImage()
44173:     {
46146:         if (!mSurface)
80486:             return false;
44173: 
46146:         if (mBound && !ReleaseTexImage())
80486:             return false;
46146: 
47908:         EGLBoolean success = sEGLLibrary.fBindTexImage(EGL_DISPLAY(),
46146:             (EGLSurface)mSurface, LOCAL_EGL_BACK_BUFFER);
44173:         if (success == LOCAL_EGL_FALSE)
80486:             return false;
80486: 
80486:         mBound = true;
80486:         return true;
44173:     }
44173: 
79445:     bool ReleaseTexImage()
44173:     {
44173:         if (!mBound)
80486:             return true;
44173: 
47908:         if (!mSurface)
80486:             return false;
44173: 
44173:         EGLBoolean success;
47908:         success = sEGLLibrary.fReleaseTexImage(EGL_DISPLAY(),
47908:                                                (EGLSurface)mSurface,
47908:                                                LOCAL_EGL_BACK_BUFFER);
44173:         if (success == LOCAL_EGL_FALSE)
80486:             return false;
80486: 
80486:         mBound = false;
80486:         return true;
44173:     }
44173: 
98361:     bool MakeCurrentImpl(bool aForce = false) {
79445:         bool succeeded = true;
43426: 
43426:         // Assume that EGL has the same problem as WGL does,
43426:         // where MakeCurrent with an already-current context is
43426:         // still expensive.
77086: #ifndef MOZ_WIDGET_QT
77086:         if (!mSurface) {
92885:             // We need to be able to bind NO_SURFACE when we don't
92885:             // have access to a surface. We won't be drawing to the screen
90395:             // but we will be able to do things like resource releases.
90395:             succeeded = sEGLLibrary.fMakeCurrent(EGL_DISPLAY(),
90395:                                                  EGL_NO_SURFACE, EGL_NO_SURFACE,
94312:                                                  EGL_NO_CONTEXT);
90395:             if (!succeeded && sEGLLibrary.fGetError() == LOCAL_EGL_CONTEXT_LOST) {
90395:                 mContextLost = true;
90395:                 NS_WARNING("EGL context has been lost.");
90395:             }
90395:             NS_ASSERTION(succeeded, "Failed to make GL context current!");
90395:             return succeeded;
77086:         }
77086: #endif
98361:         if (aForce || sEGLLibrary.fGetCurrentContext() != mContext) {
93759: #ifdef MOZ_WIDGET_QT
93759:             // Shared Qt GL context need to be informed about context switch
93759:             if (mSharedContext) {
93759:                 QGLContext* qglCtx = static_cast<QGLContext*>(static_cast<GLContextEGL*>(mSharedContext.get())->mPlatformContext);
93759:                 if (qglCtx) {
93759:                     qglCtx->doneCurrent();
93759:                 }
93759:             }
93759: #endif
47908:             succeeded = sEGLLibrary.fMakeCurrent(EGL_DISPLAY(),
47908:                                                  mSurface, mSurface,
47908:                                                  mContext);
83211:             if (!succeeded && sEGLLibrary.fGetError() == LOCAL_EGL_CONTEXT_LOST) {
83211:                 mContextLost = true;
83211:                 NS_WARNING("EGL context has been lost.");
83211:             }
43426:             NS_ASSERTION(succeeded, "Failed to make GL context current!");
98361:         }
43426: 
43426:         return succeeded;
43426:     }
43426: 
59165: #ifdef MOZ_WIDGET_QT
79445:     virtual bool
59165:     RenewSurface() {
59165:         /* We don't support renewing on QT because we don't create the surface ourselves */
80486:         return false;
59165:     }
59165: #else
79445:     virtual bool
59165:     RenewSurface() {
77086:         ReleaseSurface();
78716:         EGLConfig config;
78716:         CreateConfig(&config);
59165:         mSurface = CreateSurfaceForWindow(NULL, config);
59165: 
59165:         return sEGLLibrary.fMakeCurrent(EGL_DISPLAY(),
59165:                                         mSurface, mSurface,
59165:                                         mContext);
59165:     }
59165: #endif
59165: 
77086:     virtual void
77086:     ReleaseSurface() {
78284:         if (mSurface && !mPlatformContext) {
77086:             sEGLLibrary.fMakeCurrent(EGL_DISPLAY(), EGL_NO_SURFACE, EGL_NO_SURFACE,
77086:                                      EGL_NO_CONTEXT);
77086:             sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
77086:             mSurface = NULL;
77086:         }
77086:     }
77086: 
79445:     bool SetupLookupFunction()
43426:     {
89810:         mLookupFunc = (PlatformLookupFunction)sEGLLibrary.mSymbols.fGetProcAddress;
80486:         return true;
43426:     }
43426: 
43426:     void *GetNativeData(NativeDataType aType)
43426:     {
43426:         switch (aType) {
43426:         case NativeGLContext:
43426:             return mContext;
43426: 
43426:         default:
43426:             return nsnull;
43426:         }
43426:     }
43426: 
79445:     bool SwapBuffers()
46261:     {
78284:         if (mSurface && !mPlatformContext) {
47908:             return sEGLLibrary.fSwapBuffers(EGL_DISPLAY(), mSurface);
77086:         } else {
80486:             return false;
77086:         }
46261:     }
73465:     // GLContext interface - returns Tiled Texture Image in our case
46978:     virtual already_AddRefed<TextureImage>
46978:     CreateTextureImage(const nsIntSize& aSize,
46978:                        TextureImage::ContentType aContentType,
57421:                        GLenum aWrapMode,
98144:                        TextureImage::Flags aFlags = TextureImage::NoFlags);
46978: 
73465:     // a function to generate Tiles for Tiled Texture Image
73465:     virtual already_AddRefed<TextureImage>
73465:     TileGenFunc(const nsIntSize& aSize,
73465:                 TextureImage::ContentType aContentType,
98144:                 TextureImage::Flags aFlags = TextureImage::NoFlags);
47908:     // hold a reference to the given surface
47908:     // for the lifetime of this context.
47908:     void HoldSurface(gfxASurface *aSurf) {
47908:         mThebesSurface = aSurf;
47908:     }
47908: 
77137:     void SetPlatformContext(void *context) {
77137:         mPlatformContext = context;
47908:     }
47908: 
47908:     EGLContext Context() {
47908:         return mContext;
47908:     }
47908: 
79445:     bool BindTex2DOffscreen(GLContext *aOffscreen);
47908:     void UnbindTex2DOffscreen(GLContext *aOffscreen);
79445:     bool ResizeOffscreen(const gfxIntSize& aNewSize);
47908:     void BindOffscreenFramebuffer();
47908: 
47908:     static already_AddRefed<GLContextEGL>
47908:     CreateEGLPixmapOffscreenContext(const gfxIntSize& aSize,
71551:                                     const ContextFormat& aFormat,
79445:                                     bool aShare);
47908: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436:     static already_AddRefed<GLContextEGL>
74436:     CreateBasicEGLPixmapOffscreenContext(const gfxIntSize& aSize,
74436:                                          const ContextFormat& aFormat);
74436: 
79445:     bool ResizeOffscreenPixmapSurface(const gfxIntSize& aNewSize);
74436: #endif
74436: 
47908:     static already_AddRefed<GLContextEGL>
47908:     CreateEGLPBufferOffscreenContext(const gfxIntSize& aSize,
89556:                                      const ContextFormat& aFormat,
89556:                                      bool bufferUnused = false);
47908: 
47908:     void SetOffscreenSize(const gfxIntSize &aRequestedSize,
47908:                           const gfxIntSize &aActualSize)
47908:     {
47908:         mOffscreenSize = aRequestedSize;
47908:         mOffscreenActualSize = aActualSize;
47908:     }
47908: 
60089:     void *GetD3DShareHandle() {
74513:         if (!sEGLLibrary.HasANGLESurfaceD3DTexture2DShareHandle()) {
60089:             return nsnull;
60089:         }
60089: 
60089:         void *h = nsnull;
60089: 
60089: #ifndef EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE
60089: #define EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE 0x3200
60089: #endif
60089: 
60089:         if (!sEGLLibrary.fQuerySurfacePointerANGLE(EGL_DISPLAY(), mSurface,
60089:                                                    EGL_D3D_TEXTURE_2D_SHARE_HANDLE_ANGLE, (void**) &h))
60089:         {
60089:             return nsnull;
60089:         }
60089: 
60089:         return h;
60089:     }
60089: 
97184:     virtual bool HasLockSurface() {
97184:         return sEGLLibrary.HasKHRLockSurface();
97184:     }
97184: 
47908: protected:
47908:     friend class GLContextProviderEGL;
47908: 
43426:     EGLConfig  mConfig;
43426:     EGLSurface mSurface;
43426:     EGLContext mContext;
77137:     void *mPlatformContext;
47908:     nsRefPtr<gfxASurface> mThebesSurface;
79445:     bool mBound;
79445: 
79445:     bool mIsPBuffer;
79445:     bool mIsDoubleBuffered;
93759:     bool mCanBindToTexture;
61664: 
61664:     static EGLSurface CreatePBufferSurfaceTryingPowerOfTwo(EGLConfig config,
61664:                                                            EGLenum bindToTextureFormat,
61664:                                                            gfxIntSize& pbsize)
61664:     {
61664:         nsTArray<EGLint> pbattrs(16);
61664:         EGLSurface surface = nsnull;
61664: 
61664:     TRY_AGAIN_POWER_OF_TWO:
61664:         pbattrs.Clear();
61664:         pbattrs.AppendElement(LOCAL_EGL_WIDTH); pbattrs.AppendElement(pbsize.width);
61664:         pbattrs.AppendElement(LOCAL_EGL_HEIGHT); pbattrs.AppendElement(pbsize.height);
61664: 
61664:         if (bindToTextureFormat != LOCAL_EGL_NONE) {
61664:             pbattrs.AppendElement(LOCAL_EGL_TEXTURE_TARGET);
61664:             pbattrs.AppendElement(LOCAL_EGL_TEXTURE_2D);
61664: 
61664:             pbattrs.AppendElement(LOCAL_EGL_TEXTURE_FORMAT);
61664:             pbattrs.AppendElement(bindToTextureFormat);
61664:         }
61664: 
61664:         pbattrs.AppendElement(LOCAL_EGL_NONE);
61664: 
61664:         surface = sEGLLibrary.fCreatePbufferSurface(EGL_DISPLAY(), config, &pbattrs[0]);
61664:         if (!surface) {
61664:             if (!is_power_of_two(pbsize.width) ||
61664:                 !is_power_of_two(pbsize.height))
61664:             {
61664:                 if (!is_power_of_two(pbsize.width))
61664:                     pbsize.width = next_power_of_two(pbsize.width);
61664:                 if (!is_power_of_two(pbsize.height))
61664:                     pbsize.height = next_power_of_two(pbsize.height);
61664: 
61664:                 NS_WARNING("Failed to create pbuffer, trying power of two dims");
61664:                 goto TRY_AGAIN_POWER_OF_TWO;
61664:             }
61664: 
61664:             NS_WARNING("Failed to create pbuffer surface");
61664:             return nsnull;
61664:         }
61664: 
61664:         return surface;
61664:     }
43426: };
43426: 
79445: bool
47908: GLContextEGL::BindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     if (aOffscreen->GetContextType() != ContextTypeEGL) {
47908:         NS_WARNING("non-EGL context");
80486:         return false;
47908:     }
47908: 
47908:     GLContextEGL *offs = static_cast<GLContextEGL*>(aOffscreen);
47908: 
93759:     if (offs->mCanBindToTexture) {
79445:         bool ok = sEGLLibrary.fBindTexImage(EGL_DISPLAY(),
47908:                                               offs->mSurface,
47908:                                               LOCAL_EGL_BACK_BUFFER);
47908:         return ok;
47908:     }
47908: 
47908:     if (offs->mOffscreenTexture) {
47908:         if (offs->GetSharedContext() != GLContextProviderEGL::GetGlobalContext())
47908:         {
47908:             NS_WARNING("offscreen FBO context can only be bound with context sharing!");
80486:             return false;
47908:         }
47908: 
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, offs->mOffscreenTexture);
80486:         return true;
47908:     }
47908: 
47908:     NS_WARNING("don't know how to bind this!");
47908: 
80486:     return false;
47908: }
47908: 
47908: void
47908: GLContextEGL::UnbindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     NS_ASSERTION(aOffscreen->GetContextType() == ContextTypeEGL, "wrong type");
47908: 
47908:     GLContextEGL *offs = static_cast<GLContextEGL*>(aOffscreen);
47908: 
93759:     if (offs->mCanBindToTexture) {
47908:         sEGLLibrary.fReleaseTexImage(EGL_DISPLAY(),
47908:                                      offs->mSurface,
47908:                                      LOCAL_EGL_BACK_BUFFER);
47908:     }
47908: }
47908: 
79445: bool
47908: GLContextEGL::ResizeOffscreen(const gfxIntSize& aNewSize)
47908: {
80612:     if (!IsOffscreenSizeAllowed(aNewSize))
80612:         return false;
80612: 
47908:     if (mIsPBuffer) {
47908:         gfxIntSize pbsize(aNewSize);
47908: 
61664:         EGLSurface surface =
61664:             CreatePBufferSurfaceTryingPowerOfTwo(mConfig,
93759:                                                  mCanBindToTexture
61664:                                                  ? (mCreationFormat.minAlpha
61664:                                                     ? LOCAL_EGL_TEXTURE_RGBA
61664:                                                     : LOCAL_EGL_TEXTURE_RGB)
61664:                                                  : LOCAL_EGL_NONE,
61664:                                                  pbsize);
47908:         if (!surface) {
47908:             NS_WARNING("Failed to resize pbuffer");
80617:             return false;
47908:         }
47908: 
96935:         if (!ResizeOffscreenFBOs(pbsize, false))
80617:             return false;
80617: 
47908:         SetOffscreenSize(aNewSize, pbsize);
47908: 
78284:         if (mSurface && !mPlatformContext) {
47908:             sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
77086:         }
47908: 
47908:         mSurface = surface;
47908: 
80486:         MakeCurrent(true);
47908:         ClearSafely();
47908: 
80486:         return true;
47908:     }
47908: 
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
80621:     if (ResizeOffscreenPixmapSurface(aNewSize)) {
96935:         if (ResizeOffscreenFBOs(aNewSize, true))
80621:             return true;
80621:     }
74436: #endif
74436: 
96935:     return ResizeOffscreenFBOs(aNewSize, true);
47908: }
47908: 
47908: 
47908: static GLContextEGL *
47908: GetGlobalContextEGL()
47908: {
47908:     return static_cast<GLContextEGL*>(GLContextProviderEGL::GetGlobalContext());
47908: }
47908: 
58301: static GLenum
58301: GLFormatForImage(gfxASurface::gfxImageFormat aFormat)
58301: {
58301:     switch (aFormat) {
58301:     case gfxASurface::ImageFormatARGB32:
58301:     case gfxASurface::ImageFormatRGB24:
93800:         // Thebes only supports RGBX, not packed RGB.
58301:         return LOCAL_GL_RGBA;
58301:     case gfxASurface::ImageFormatRGB16_565:
58301:         return LOCAL_GL_RGB;
58301:     default:
58301:         NS_WARNING("Unknown GL format for Image format");
58301:     }
58301:     return 0;
58301: }
58301: 
58301: static GLenum
58301: GLTypeForImage(gfxASurface::gfxImageFormat aFormat)
58301: {
58301:     switch (aFormat) {
58301:     case gfxASurface::ImageFormatARGB32:
58301:     case gfxASurface::ImageFormatRGB24:
58301:         return LOCAL_GL_UNSIGNED_BYTE;
58301:     case gfxASurface::ImageFormatRGB16_565:
58301:         return LOCAL_GL_UNSIGNED_SHORT_5_6_5;
58301:     default:
58301:         NS_WARNING("Unknown GL format for Image format");
58301:     }
58301:     return 0;
58301: }
58301: 
58301: class TextureImageEGL
58301:     : public TextureImage
46978: {
46978: public:
46978:     TextureImageEGL(GLuint aTexture,
46978:                     const nsIntSize& aSize,
57421:                     GLenum aWrapMode,
46978:                     ContentType aContentType,
98144:                     GLContext* aContext,
98144:                     TextureImage::Flags aFlags = TextureImage::NoFlags)
98144:         : TextureImage(aSize, aWrapMode, aContentType, aFlags)
46978:         , mGLContext(aContext)
58301:         , mUpdateFormat(gfxASurface::ImageFormatUnknown)
58301:         , mSurface(nsnull)
58301:         , mConfig(nsnull)
78716:         , mTexture(aTexture)
58301:         , mImageKHR(nsnull)
74463:         , mTextureState(Created)
80486:         , mBound(false)
80486:         , mIsLocked(false)
58301:     {
58301:         mUpdateFormat = gfxASurface::FormatFromContent(GetContentType());
58301: 
60438:         if (gUseBackingSurface) {
94773:             if (mUpdateFormat != gfxASurface::ImageFormatARGB32) {
60438:                 mShaderType = RGBXLayerProgramType;
60438:             } else {
60438:                 mShaderType = RGBALayerProgramType;
60438:             }
74836:             Resize(aSize);
60438:         } else {
94773:             if (mUpdateFormat == gfxASurface::ImageFormatRGB16_565) {
94773:                 mShaderType = RGBXLayerProgramType;
94773:             } else if (mUpdateFormat == gfxASurface::ImageFormatRGB24) {
93800:                 // RGB24 means really RGBX for Thebes, which means we have to
93800:                 // use the right shader and ignore the uninitialized alpha
93800:                 // value.
93800:                 mShaderType = BGRXLayerProgramType;
93800:             } else {
93800:                 mShaderType = BGRALayerProgramType;
58301:             }
58301:         }
60438:     }
46978: 
46978:     virtual ~TextureImageEGL()
46978:     {
58301:         GLContext *ctx = mGLContext;
95097:         if (ctx->IsDestroyed() || !ctx->IsOwningThreadCurrent()) {
58301:             ctx = ctx->GetSharedContext();
58301:         }
58301: 
58301:         // If we have a context, then we need to delete the texture;
58301:         // if we don't have a context (either real or shared),
58301:         // then they went away when the contex was deleted, because it
58301:         // was the only one that had access to it.
58301:         if (ctx && !ctx->IsDestroyed()) {
60010:             ctx->MakeCurrent();
60010:             ctx->fDeleteTextures(1, &mTexture);
58301:             ReleaseTexImage();
58301:             DestroyEGLSurface();
58301:         }
46978:     }
46978: 
77141:     virtual void GetUpdateRegion(nsIntRegion& aForRegion)
46978:     {
74463:         if (mTextureState != Valid) {
58301:             // if the texture hasn't been initialized yet, force the
58301:             // client to paint everything
77141:             aForRegion = nsIntRect(nsIntPoint(0, 0), mSize);
77141:         } else if (!mBackingSurface) {
58301:             // We can only draw a rectangle, not subregions due to
58301:             // the way that our texture upload functions work.  If
58301:             // needed, we /could/ do multiple texture uploads if we have
58301:             // non-overlapping rects, but that's a tradeoff.
77141:             aForRegion = nsIntRegion(aForRegion.GetBounds());
60438:         }
60438:     }
58301: 
77141:     virtual gfxASurface* BeginUpdate(nsIntRegion& aRegion)
77141:     {
77141:         NS_ASSERTION(!mUpdateSurface, "BeginUpdate() without EndUpdate()?");
77141: 
77141:         // determine the region the client will need to repaint
77141:         GetUpdateRegion(aRegion);
77141:         mUpdateRect = aRegion.GetBounds();
77141: 
60438:         //printf_stderr("BeginUpdate with updateRect [%d %d %d %d]\n", mUpdateRect.x, mUpdateRect.y, mUpdateRect.width, mUpdateRect.height);
58301:         if (!nsIntRect(nsIntPoint(0, 0), mSize).Contains(mUpdateRect)) {
58301:             NS_ERROR("update outside of image");
58301:             return NULL;
53687:         }
53687: 
58301:         if (mBackingSurface) {
58301:             if (sEGLLibrary.HasKHRLockSurface()) {
60739:                 mUpdateSurface = GetLockSurface();
58301:             } else {
60739:                 mUpdateSurface = mBackingSurface;
60438:             }
60438: 
60739:             return mUpdateSurface;
46978:         }
46978: 
58301:         //printf_stderr("creating image surface %dx%d format %d\n", mUpdateRect.width, mUpdateRect.height, mUpdateFormat);
58301: 
60739:         mUpdateSurface =
58301:             new gfxImageSurface(gfxIntSize(mUpdateRect.width, mUpdateRect.height),
58301:                                 mUpdateFormat);
58301: 
60739:         mUpdateSurface->SetDeviceOffset(gfxPoint(-mUpdateRect.x, -mUpdateRect.y));
58301: 
60739:         return mUpdateSurface;
58301:     }
58301: 
60740:     virtual void EndUpdate()
46978:     {
60739:         NS_ASSERTION(!!mUpdateSurface, "EndUpdate() without BeginUpdate()?");
46978: 
58301:         if (mIsLocked) {
58301:             UnlockSurface();
74463:             mTextureState = Valid;
60739:             mUpdateSurface = nsnull;
60740:             return;
58301:         }
53687: 
60739:         if (mBackingSurface && mUpdateSurface == mBackingSurface) {
46978: #ifdef MOZ_X11
58301:             if (mBackingSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
58301:                 XSync(DefaultXDisplay(), False);
58301:             }
53687: #endif
46978: 
58301:             mBackingSurface->SetDeviceOffset(gfxPoint(0, 0));
74463:             mTextureState = Valid;
60739:             mUpdateSurface = nsnull;
60740:             return;
58301:         }
58301: 
58301:         //printf_stderr("EndUpdate: slow path");
58301: 
58301:         // This is the slower path -- we didn't have any way to set up
58301:         // a fast mapping between our cairo target surface and the GL
58301:         // texture, so we have to upload data.
58301: 
58301:         // Undo the device offset that BeginUpdate set; doesn't much
58301:         // matter for us here, but important if we ever do anything
58301:         // directly with the surface.
60739:         mUpdateSurface->SetDeviceOffset(gfxPoint(0, 0));
58301: 
58301:         nsRefPtr<gfxImageSurface> uploadImage = nsnull;
58301:         gfxIntSize updateSize(mUpdateRect.width, mUpdateRect.height);
58301: 
60739:         NS_ASSERTION(mUpdateSurface->GetType() == gfxASurface::SurfaceTypeImage &&
60739:                      mUpdateSurface->GetSize() == updateSize,
58301:                      "Upload image isn't an image surface when one is expected, or is wrong size!");
58301: 
60739:         uploadImage = static_cast<gfxImageSurface*>(mUpdateSurface.get());
58301: 
58301:         if (!uploadImage) {
60740:             return;
46978:         }
46978: 
53687:         mGLContext->MakeCurrent();
53687:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
57642: 
74463:         if (mTextureState != Valid) {
58301:             NS_ASSERTION(mUpdateRect.x == 0 && mUpdateRect.y == 0 &&
58301:                          mUpdateRect.Size() == mSize,
58301:                          "Bad initial update on non-created texture!");
58301: 
58301:             mGLContext->fTexImage2D(LOCAL_GL_TEXTURE_2D,
58301:                                     0,
58301:                                     GLFormatForImage(mUpdateFormat),
58301:                                     mUpdateRect.width,
58301:                                     mUpdateRect.height,
58301:                                     0,
58301:                                     GLFormatForImage(uploadImage->Format()),
58301:                                     GLTypeForImage(uploadImage->Format()),
58301:                                     uploadImage->Data());
58301:         } else {
57642:             mGLContext->fTexSubImage2D(LOCAL_GL_TEXTURE_2D,
57642:                                        0,
57642:                                        mUpdateRect.x,
57642:                                        mUpdateRect.y,
57642:                                        mUpdateRect.width,
57642:                                        mUpdateRect.height,
58301:                                        GLFormatForImage(uploadImage->Format()),
58301:                                        GLTypeForImage(uploadImage->Format()),
58301:                                        uploadImage->Data());
57642:         }
53687: 
60739:         mUpdateSurface = nsnull;
74463:         mTextureState = Valid;
60740:         return;         // mTexture is bound
53687:     }
53687: 
73465:     virtual bool DirectUpdate(gfxASurface* aSurf, const nsIntRegion& aRegion, const nsIntPoint& aFrom /* = nsIntPoint(0, 0) */)
59443:     {
59443:         nsIntRect bounds = aRegion.GetBounds();
59443: 
60728:         nsIntRegion region;
74463:         if (mTextureState != Valid) {
59443:             bounds = nsIntRect(0, 0, mSize.width, mSize.height);
60728:             region = nsIntRegion(bounds);
60728:         } else {
60728:             region = aRegion;
59443:         }
59443: 
60438:         if (mBackingSurface && sEGLLibrary.HasKHRLockSurface()) {
60739:             mUpdateSurface = GetLockSurface();
60739:             if (mUpdateSurface) {
60739:                 nsRefPtr<gfxContext> ctx = new gfxContext(mUpdateSurface);
60739:                 gfxUtils::ClipToRegion(ctx, aRegion);
73465:                 ctx->SetSource(aSurf, gfxPoint(-aFrom.x, -aFrom.y));
60739:                 ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
60739:                 ctx->Paint();
60739:                 mUpdateSurface = nsnull;
60438:                 UnlockSurface();
60438:             }
60438:         } else {
59443:             mShaderType =
59443:               mGLContext->UploadSurfaceToTexture(aSurf,
60728:                                                  region,
59443:                                                  mTexture,
74463:                                                  mTextureState == Created,
73465:                                                  bounds.TopLeft() + aFrom,
80486:                                                  false);
60438:         }
60438: 
74463:         mTextureState = Valid;
59443:         return true;
59443:     }
59443: 
67635:     virtual void BindTexture(GLenum aTextureUnit)
67635:     {
74836:         // Ensure the texture is allocated before it is used.
74836:         if (mTextureState == Created) {
74836:             Resize(mSize);
74836:         }
74836: 
67635:         mGLContext->fActiveTexture(aTextureUnit);
73465:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
67635:         mGLContext->fActiveTexture(LOCAL_GL_TEXTURE0);
67635:     }
67635: 
74836:     virtual GLuint GetTextureID() 
74836:     {
74836:         // Ensure the texture is allocated before it is used.
74836:         if (mTextureState == Created) {
74836:             Resize(mSize);
74836:         }
73465:         return mTexture;
73465:     };
73465: 
79445:     virtual bool InUpdate() const { return !!mUpdateSurface; }
48091: 
58301:     virtual void Resize(const nsIntSize& aSize)
58301:     {
60739:         NS_ASSERTION(!mUpdateSurface, "Resize() while in update?");
58301: 
74463:         if (mSize == aSize && mTextureState != Created)
58301:             return;
58301: 
60438:         mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
74462: 	
74462:         // Try to generate a backin surface first if we have the ability
74462:         if (gUseBackingSurface) {
58301:             CreateBackingSurface(gfxIntSize(aSize.width, aSize.height));
74462:         }
74462: 
74462:         if (!mBackingSurface) {
74462:             // If we don't have a backing surface or failed to obtain one,
74462:             // use the GL Texture failsafe
58301:             mGLContext->fTexImage2D(LOCAL_GL_TEXTURE_2D,
58301:                                     0,
58301:                                     GLFormatForImage(mUpdateFormat),
58301:                                     aSize.width,
58301:                                     aSize.height,
58301:                                     0,
58301:                                     GLFormatForImage(mUpdateFormat),
58301:                                     GLTypeForImage(mUpdateFormat),
58301:                                     NULL);
58301:         }
58301: 
74463:         mTextureState = Allocated;
58301:         mSize = aSize;
58301:     }
58301: 
79445:     bool BindTexImage()
58301:     {
58301:         if (mBound && !ReleaseTexImage())
80486:             return false;
58301: 
58301:         EGLBoolean success =
58301:             sEGLLibrary.fBindTexImage(EGL_DISPLAY(),
58301:                                       (EGLSurface)mSurface,
58301:                                       LOCAL_EGL_BACK_BUFFER);
58301: 
58301:         if (success == LOCAL_EGL_FALSE)
80486:             return false;
80486: 
80486:         mBound = true;
80486:         return true;
58301:     }
58301: 
79445:     bool ReleaseTexImage()
58301:     {
58301:         if (!mBound)
80486:             return true;
58301: 
58301:         EGLBoolean success =
58301:             sEGLLibrary.fReleaseTexImage(EGL_DISPLAY(),
58301:                                          (EGLSurface)mSurface,
58301:                                          LOCAL_EGL_BACK_BUFFER);
58301: 
58301:         if (success == LOCAL_EGL_FALSE)
80486:             return false;
80486: 
80486:         mBound = false;
80486:         return true;
58301:     }
58301: 
58301:     virtual already_AddRefed<gfxImageSurface> GetLockSurface()
58301:     {
58301:         if (mIsLocked) {
58301:             NS_WARNING("Can't lock surface twice");
58301:             return nsnull;
58301:         }
58301: 
58301:         if (!sEGLLibrary.HasKHRLockSurface()) {
58301:             NS_WARNING("GetLockSurface called, but no EGL_KHR_lock_surface extension!");
58301:             return nsnull;
58301:         }
58301: 
58301:         if (!CreateEGLSurface(mBackingSurface)) {
58301:             NS_WARNING("Failed to create EGL surface");
58301:             return nsnull;
58301:         }
58301: 
58301:         static EGLint lock_attribs[] = {
58301:             LOCAL_EGL_MAP_PRESERVE_PIXELS_KHR, LOCAL_EGL_TRUE,
58301:             LOCAL_EGL_LOCK_USAGE_HINT_KHR, LOCAL_EGL_READ_SURFACE_BIT_KHR | LOCAL_EGL_WRITE_SURFACE_BIT_KHR,
58301:             LOCAL_EGL_NONE
58301:         };
58301: 
58301:         sEGLLibrary.fLockSurfaceKHR(EGL_DISPLAY(), mSurface, lock_attribs);
58301: 
80486:         mIsLocked = true;
58301: 
58301:         unsigned char *data = nsnull;
58301:         int pitch = 0;
58301:         int pixsize = 0;
58301: 
58301:         sEGLLibrary.fQuerySurface(EGL_DISPLAY(), mSurface, LOCAL_EGL_BITMAP_POINTER_KHR, (EGLint*)&data);
58301:         sEGLLibrary.fQuerySurface(EGL_DISPLAY(), mSurface, LOCAL_EGL_BITMAP_PITCH_KHR, &pitch);
58301:         sEGLLibrary.fQuerySurface(EGL_DISPLAY(), mSurface, LOCAL_EGL_BITMAP_PIXEL_SIZE_KHR, &pixsize);
58301: 
58301:         nsRefPtr<gfxImageSurface> sharedImage =
58301:             new gfxImageSurface(data,
58301:                                 mBackingSurface->GetSize(),
58301:                                 pitch,
58301:                                 mUpdateFormat);
58301: 
58301:         return sharedImage.forget();
58301:     }
58301: 
58301:     virtual void UnlockSurface()
58301:     {
58301:         if (!mIsLocked) {
58301:             NS_WARNING("UnlockSurface called, surface not locked!");
58301:             return;
58301:         }
58301: 
58301:         sEGLLibrary.fUnlockSurfaceKHR(EGL_DISPLAY(), mSurface);
80486:         mIsLocked = false;
58301:     }
58301: 
58301:     virtual already_AddRefed<gfxASurface> GetBackingSurface()
58301:     {
78894:         nsRefPtr<gfxASurface> copy = mBackingSurface;
78894:         return copy.forget();
58301:     }
58301: 
79445:     virtual bool CreateEGLSurface(gfxASurface* aSurface)
58301:     {
60438: #ifdef MOZ_X11
58301:         if (!aSurface) {
58301:             NS_WARNING("no surface");
80486:             return false;
58301:         }
58301: 
58301:         if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
58301:             NS_WARNING("wrong surface type, must be xlib");
80486:             return false;
58301:         }
58301: 
58301:         if (mSurface) {
80486:             return true;
58301:         }
58301: 
60438:         EGLSurface surface = CreateEGLSurfaceForXSurface(aSurface, &mConfig);
58301: 
58301:         if (!surface) {
58301:             NS_WARNING("couldn't find X config for surface");
80486:             return false;
58301:         }
58301: 
58301:         mSurface = surface;
80486:         return true;
58301: #else
80486:         return false;
58301: #endif
58301:     }
58301: 
58301:     virtual void DestroyEGLSurface(void)
58301:     {
58301:         if (!mSurface)
58301:             return;
58301: 
58301:         sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
58301:         mSurface = nsnull;
58301:     }
58301: 
79445:     virtual bool CreateBackingSurface(const gfxIntSize& aSize)
58301:     {
58301:         ReleaseTexImage();
58301:         DestroyEGLSurface();
58301:         mBackingSurface = nsnull;
58301: 
58301: #ifdef MOZ_X11
58301:         Display* dpy = DefaultXDisplay();
58301:         XRenderPictFormat* renderFMT =
58301:             gfxXlibSurface::FindRenderFormat(dpy, mUpdateFormat);
58301: 
58301:         nsRefPtr<gfxXlibSurface> xsurface =
58301:             gfxXlibSurface::Create(DefaultScreenOfDisplay(dpy),
58301:                                    renderFMT,
58301:                                    gfxIntSize(aSize.width, aSize.height));
58301: 
58301:         XSync(dpy, False);
58301:         mConfig = nsnull;
58301: 
58301:         if (sEGLLibrary.HasKHRImagePixmap() && sEGLLibrary.HasKHRImageTexture2D()) {
58301:             mImageKHR =
58301:                 sEGLLibrary.fCreateImageKHR(EGL_DISPLAY(),
58301:                                             EGL_NO_CONTEXT,
58301:                                             LOCAL_EGL_NATIVE_PIXMAP_KHR,
58301:                                             (EGLClientBuffer)xsurface->XDrawable(),
58301:                                             NULL);
58301: 
58301:             if (!mImageKHR) {
58301:                 printf_stderr("couldn't create EGL image: ERROR (0x%04x)\n", sEGLLibrary.fGetError());
80486:                 return false;
58301:             }
58301:             mGLContext->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
58301:             sEGLLibrary.fImageTargetTexture2DOES(LOCAL_GL_TEXTURE_2D, mImageKHR);
58301:             sEGLLibrary.fDestroyImageKHR(EGL_DISPLAY(), mImageKHR);
58301:             mImageKHR = NULL;
58301:         } else {
58301:             if (!CreateEGLSurface(xsurface)) {
58301:                 printf_stderr("ProviderEGL Failed create EGL surface: ERROR (0x%04x)\n", sEGLLibrary.fGetError());
80486:                 return false;
58301:             }
58301: 
58301:             if (!BindTexImage()) {
58301:                 printf_stderr("ProviderEGL Failed to bind teximage: ERROR (0x%04x)\n", sEGLLibrary.fGetError());
80486:                 return false;
58301:             }
58301:         }
58301: 
58301:         mBackingSurface = xsurface;
58301: #endif
58301: 
58301:         return mBackingSurface != nsnull;
58301:     }
58301: 
58301: protected:
58301:     typedef gfxASurface::gfxImageFormat ImageFormat;
58301: 
46978:     GLContext* mGLContext;
53687: 
53687:     nsIntRect mUpdateRect;
58301:     ImageFormat mUpdateFormat;
58301:     nsRefPtr<gfxASurface> mBackingSurface;
60739:     nsRefPtr<gfxASurface> mUpdateSurface;
58301:     EGLSurface mSurface;
58301:     EGLConfig mConfig;
73465:     GLuint mTexture;
58301:     EGLImageKHR mImageKHR;
74463:     TextureState mTextureState;
74463: 
79445:     bool mBound;
79445:     bool mIsLocked;
79815: 
79815:     virtual void ApplyFilter()
79815:     {
79815:         mGLContext->ApplyFilterToBoundTexture(mFilter);
79815:     }
46978: };
46978: 
46978: already_AddRefed<TextureImage>
46978: GLContextEGL::CreateTextureImage(const nsIntSize& aSize,
46978:                                  TextureImage::ContentType aContentType,
57421:                                  GLenum aWrapMode,
98144:                                  TextureImage::Flags aFlags)
46978: {
98144:     nsRefPtr<TextureImage> t = new gl::TiledTextureImage(this, aSize, aContentType, aFlags);
73465:     return t.forget();
92021: }
73465: 
73465: already_AddRefed<TextureImage>
73465: GLContextEGL::TileGenFunc(const nsIntSize& aSize,
73465:                                  TextureImage::ContentType aContentType,
98144:                                  TextureImage::Flags aFlags)
73465: {
46978:   MakeCurrent();
46978: 
46978:   GLuint texture;
46978:   fGenTextures(1, &texture);
46978: 
46978:   fActiveTexture(LOCAL_GL_TEXTURE0);
46978:   fBindTexture(LOCAL_GL_TEXTURE_2D, texture);
46978: 
58301:   nsRefPtr<TextureImageEGL> teximage =
98144:       new TextureImageEGL(texture, aSize, LOCAL_GL_CLAMP_TO_EDGE, aContentType, this, aFlags);
58301: 
98144:   GLint texfilter = aFlags & TextureImage::UseNearestFilter ? LOCAL_GL_NEAREST : LOCAL_GL_LINEAR;
46978:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, texfilter);
46978:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, texfilter);
73465:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, LOCAL_GL_CLAMP_TO_EDGE);
73465:   fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, LOCAL_GL_CLAMP_TO_EDGE);
46978: 
46978:   return teximage.forget();
46978: }
46978: 
78716: inline static ContextFormat
54904: DepthToGLFormat(int aDepth)
54904: {
54904:     switch (aDepth) {
54904:         case 32:
54904:             return ContextFormat::BasicRGBA32;
54904:         case 24:
54904:             return ContextFormat::BasicRGB24;
54904:         case 16:
54904:             return ContextFormat::BasicRGB16_565;
54904:         default:
54904:             break;
54904:     }
54904:     return ContextFormat::BasicRGBA32;
54904: }
54904: 
93759: static nsRefPtr<GLContext> gGlobalContext;
54904: 
78716: static const EGLint kEGLConfigAttribsRGB16[] = {
43426:     LOCAL_EGL_SURFACE_TYPE,    LOCAL_EGL_WINDOW_BIT,
43426:     LOCAL_EGL_RENDERABLE_TYPE, LOCAL_EGL_OPENGL_ES2_BIT,
46261:     LOCAL_EGL_RED_SIZE,        5,
46261:     LOCAL_EGL_GREEN_SIZE,      6,
46261:     LOCAL_EGL_BLUE_SIZE,       5,
46261:     LOCAL_EGL_ALPHA_SIZE,      0,
78716:     LOCAL_EGL_NONE
78716: };
78716: 
78716: 
78716: static const EGLint kEGLConfigAttribsRGBA32[] = {
78716:     LOCAL_EGL_SURFACE_TYPE,    LOCAL_EGL_WINDOW_BIT,
78716:     LOCAL_EGL_RENDERABLE_TYPE, LOCAL_EGL_OPENGL_ES2_BIT,
53687:     LOCAL_EGL_RED_SIZE,        8,
53687:     LOCAL_EGL_GREEN_SIZE,      8,
53687:     LOCAL_EGL_BLUE_SIZE,       8,
53687:     LOCAL_EGL_ALPHA_SIZE,      8,
43426:     LOCAL_EGL_NONE
43426: };
43426: 
78716: static bool
95115: CreateConfig(EGLConfig* aConfig, PRInt32 depth)
78716: {
47908:     EGLConfig configs[64];
91861:     const EGLint* attribs = depth == 16 ? kEGLConfigAttribsRGB16 :
91861:                                           kEGLConfigAttribsRGBA32;
80467:     EGLint ncfg = ArrayLength(configs);
78716: 
91861:     if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(), attribs,
78716:                                    configs, ncfg, &ncfg) ||
91861:         ncfg < 1) {
91861:         return false;
43426:     }
43426: 
78716:     for (int j = 0; j < ncfg; ++j) {
78716:         EGLConfig config = configs[j];
53687:         EGLint r, g, b, a;
47908: 
78716:         if (sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), config,
78716:                                          LOCAL_EGL_RED_SIZE, &r) &&
78716:             sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), config,
78716:                                          LOCAL_EGL_GREEN_SIZE, &g) &&
78716:             sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), config,
78716:                                          LOCAL_EGL_BLUE_SIZE, &b) &&
78716:             sEGLLibrary.fGetConfigAttrib(EGL_DISPLAY(), config,
78716:                                          LOCAL_EGL_ALPHA_SIZE, &a) &&
91861:             ((depth == 16 && r == 5 && g == 6 && b == 5) ||
91861:              (depth == 24 && r == 8 && g == 8 && b == 8 && a == 8)))
78716:         {
78716:             *aConfig = config;
78716:             return true;
53687:         }
53687:     }
78716:     return false;
53687: }
53687: 
95241: static int
95241: GetScreenDepth()
95241: {
95241:     nsCOMPtr<nsIScreenManager> screenMgr = do_GetService("@mozilla.org/gfx/screenmanager;1");
95241:     nsCOMPtr<nsIScreen> screen;
95241:     screenMgr->GetPrimaryScreen(getter_AddRefs(screen));
95241:     PRInt32 depth = 24;
95241:     screen->GetColorDepth(&depth);
95241:     return depth;
95241: }
95241: 
95115: // Return true if a suitable EGLConfig was found and pass it out
95115: // through aConfig.  Return false otherwise.
95115: //
95115: // NB: It's entirely legal for the returned EGLConfig to be valid yet
95115: // have the value null.
95115: static bool
95115: CreateConfig(EGLConfig* aConfig)
95115: {
95241:     PRInt32 depth = GetScreenDepth();
95115:     if (!CreateConfig(aConfig, depth)) {
95115: #ifdef MOZ_WIDGET_ANDROID
95115:         // Bug 736005
95115:         // Android doesn't always support 16 bit so also try 24 bit
95115:         if (depth == 16) {
95115:             return CreateConfig(aConfig, 24);
95115:         }
95115: #endif
95115:         return false;
95115:     } else {
95115:         return true;
95115:     }
95115: }
95115: 
78716: static EGLSurface
59165: CreateSurfaceForWindow(nsIWidget *aWidget, EGLConfig config)
59165: {
59165:     EGLSurface surface;
59165: 
47908: #ifdef DEBUG
47908:     sEGLLibrary.DumpEGLConfig(config);
47908: #endif
47908: 
92826: #ifdef MOZ_JAVA_COMPOSITOR
92823:     surface = mozilla::AndroidBridge::Bridge()->ProvideEGLSurface();
92794: #elif defined(MOZ_WIDGET_ANDROID)
92781: 
46261:     // On Android, we have to ask Java to make the eglCreateWindowSurface
46261:     // call for us.  See GLHelpers.java for a description of why.
46261:     //
46261:     // We also only have one true "window", so we just use it directly and ignore
46261:     // what was passed in.
92781:     AndroidGeckoSurfaceView& sview = mozilla::AndroidBridge::Bridge()->SurfaceView();
92781:     if (sview.isNull()) {
92781:         printf_stderr("got null surface\n");
92781:         return NULL;
92781:     }
92781: 
46261:     surface = mozilla::AndroidBridge::Bridge()->
92781:         CallEglCreateWindowSurface(EGL_DISPLAY(), config, sview);
46261: #else
53686:     surface = sEGLLibrary.fCreateWindowSurface(EGL_DISPLAY(), config, GET_NATIVE_WINDOW(aWidget), 0);
46261: #endif
46261: 
82142: #ifdef MOZ_WIDGET_GONK
82142:     gScreenBounds.x = 0;
82142:     gScreenBounds.y = 0;
82142:     sEGLLibrary.fQuerySurface(EGL_DISPLAY(), surface, LOCAL_EGL_WIDTH, &gScreenBounds.width);
82142:     sEGLLibrary.fQuerySurface(EGL_DISPLAY(), surface, LOCAL_EGL_HEIGHT, &gScreenBounds.height);
82142: #endif
82142: 
59165:     return surface;
59165: }
59165: 
59165: already_AddRefed<GLContext>
59165: GLContextProviderEGL::CreateForWindow(nsIWidget *aWidget)
59165: {
59165:     EGLConfig config;
59165: 
59165:     if (!sEGLLibrary.EnsureInitialized()) {
59165:         return nsnull;
59165:     }
59165: 
95241: #if defined(XP_WIN) || defined(ANDROID) || defined(MOZ_PLATFORM_MAEMO)
95241:     bool doubleBuffered = true;
95241: #else
95241:     bool doubleBuffered = false;
95241: #endif
95241: 
95241:     void* currentContext = sEGLLibrary.fGetCurrentContext();
95241:     if (aWidget->HasGLContext() && currentContext) {
95241:         PRInt32 depth = GetScreenDepth();
95241:         void* platformContext = currentContext;
95241: #ifdef MOZ_WIDGET_QT
95241:         QGLContext* context = const_cast<QGLContext*>(QGLContext::currentContext());
95241:         if (context && context->device()) {
95241:             depth = context->device()->depth();
95241:         }
95241:         doubleBuffered = context->format().doubleBuffer();
95241:         platformContext = context;
95241: #endif
95241:         nsRefPtr<GLContextEGL> glContext =
95241:             new GLContextEGL(ContextFormat(DepthToGLFormat(depth)),
95241:                              gGlobalContext,
95241:                              NULL,
95241:                              sEGLLibrary.fGetCurrentSurface(LOCAL_EGL_DRAW), // just use same surface for read and draw
95241:                              currentContext,
95241:                              false);
95241: 
95241:         if (!glContext->Init())
95241:             return nsnull;
95241: 
95241:         glContext->SetIsDoubleBuffered(doubleBuffered);
95241: 
95241:         glContext->SetPlatformContext(platformContext);
95241:         if (!gGlobalContext) {
95241:             gGlobalContext = glContext;
95241:         }
95241: 
95241:         return glContext.forget();
95241:     }
95241: 
78716:     if (!CreateConfig(&config)) {
59165:         printf_stderr("Failed to create EGL config!\n");
59165:         return nsnull;
59165:     }
59165: 
92851: #ifdef MOZ_JAVA_COMPOSITOR
92823:     mozilla::AndroidBridge::Bridge()->RegisterCompositor();
92823: #endif
92823: 
59165:    EGLSurface surface = CreateSurfaceForWindow(aWidget, config);
59165: 
43426:     if (!surface) {
43426:         return nsnull;
43426:     }
43426: 
46261:     if (!sEGLLibrary.fBindAPI(LOCAL_EGL_OPENGL_ES_API)) {
53686:         sEGLLibrary.fDestroySurface(EGL_DISPLAY(), surface);
46261:         return nsnull;
46261:     }
46261: 
47908:     GLContextEGL *shareContext = GetGlobalContextEGL();
47908: 
71551:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateGLContext(ContextFormat(ContextFormat::BasicRGB24),
71551:                                       surface,
47908:                                       config,
71551:                                       shareContext,
80486:                                       false);
47908: 
71551:     if (!glContext) {
43426:         return nsnull;
43426:     }
43426: 
95241:     glContext->SetIsDoubleBuffered(doubleBuffered);
53687: 
47908:     return glContext.forget();
59165: }
43426: 
61664: static void
96853: FillPBufferAttribs_Minimal(nsTArray<EGLint>& aAttrs)
96853: {
96853:     aAttrs.Clear();
96853: 
96853: #define A1(_x)      do { aAttrs.AppendElement(_x); } while (0)
96853: #define A2(_x,_y)   do { A1(_x); A1(_y); } while (0)
96853: 
96853:     A2(LOCAL_EGL_RENDERABLE_TYPE, LOCAL_EGL_OPENGL_ES2_BIT);
96853: 
96853:     A2(LOCAL_EGL_SURFACE_TYPE, LOCAL_EGL_PBUFFER_BIT);
96853: 
96853:     A1(LOCAL_EGL_NONE);
96853: #undef A1
96853: #undef A2
96853: }
96853: 
96853: static void
61664: FillPBufferAttribs(nsTArray<EGLint>& aAttrs,
61664:                    const ContextFormat& aFormat,
61664:                    bool aCanBindToTexture,
61664:                    int aColorBitsOverride,
61664:                    int aDepthBitsOverride)
61664: {
61664:     aAttrs.Clear();
61664: 
61664: #define A1(_x)      do { aAttrs.AppendElement(_x); } while (0)
61664: #define A2(_x,_y)   do { A1(_x); A1(_y); } while (0)
61664: 
61664:     A2(LOCAL_EGL_RENDERABLE_TYPE, LOCAL_EGL_OPENGL_ES2_BIT);
61664: 
96853:     A2(LOCAL_EGL_SURFACE_TYPE, LOCAL_EGL_PBUFFER_BIT);
96853: 
61664:     if (aColorBitsOverride == -1) {
61664:         A2(LOCAL_EGL_RED_SIZE, aFormat.red);
61664:         A2(LOCAL_EGL_GREEN_SIZE, aFormat.green);
61664:         A2(LOCAL_EGL_BLUE_SIZE, aFormat.blue);
61664:     } else {
61664:         A2(LOCAL_EGL_RED_SIZE, aColorBitsOverride);
61664:         A2(LOCAL_EGL_GREEN_SIZE, aColorBitsOverride);
61664:         A2(LOCAL_EGL_BLUE_SIZE, aColorBitsOverride);
61664:     }
61664: 
61664:     A2(LOCAL_EGL_ALPHA_SIZE, aFormat.alpha);
61664: 
61664:     if (aDepthBitsOverride == -1) {
61664:         A2(LOCAL_EGL_DEPTH_SIZE, aFormat.minDepth);
61664:     } else {
61664:         A2(LOCAL_EGL_DEPTH_SIZE, aDepthBitsOverride);
61664:     }
61664: 
61664:     A2(LOCAL_EGL_STENCIL_SIZE, aFormat.minStencil);
61664: 
61664:     if (aCanBindToTexture) {
61664:         A2(aFormat.minAlpha ? LOCAL_EGL_BIND_TO_TEXTURE_RGBA : LOCAL_EGL_BIND_TO_TEXTURE_RGB,
61664:            LOCAL_EGL_TRUE);
61664:     }
61664: 
61664:     A1(LOCAL_EGL_NONE);
61664: #undef A1
61664: #undef A2
61664: }
61664: 
47908: already_AddRefed<GLContextEGL>
47908: GLContextEGL::CreateEGLPBufferOffscreenContext(const gfxIntSize& aSize,
89556:                                                const ContextFormat& aFormat,
89556:                                                bool bufferUnused)
43426: {
43426:     EGLConfig config;
43426:     EGLSurface surface;
43426:     EGLContext context;
43426: 
61663:     bool configCanBindToTexture = true;
61663: 
61663:     EGLConfig configs[64];
61663:     int numConfigs = sizeof(configs)/sizeof(EGLConfig);
61663:     int foundConfigs = 0;
61663: 
61663:     // if we're running under ANGLE, we can't set BIND_TO_TEXTURE --
61663:     // it's not supported, and we have dx interop pbuffers anyway
92137:     if (sEGLLibrary.IsANGLE() || bufferUnused)
61663:         configCanBindToTexture = false;
61663: 
61664:     nsTArray<EGLint> attribs(32);
61664:     int attribAttempt = 0;
43426: 
80617:     int tryDepthSize = (aFormat.depth > 0) ? 24 : 0;
80617: 
61664: TRY_ATTRIBS_AGAIN:
96853:     if (bufferUnused) {
96853:         FillPBufferAttribs_Minimal(attribs);
96853:     } else {
61664:         switch (attribAttempt) {
61664:         case 0:
80617:             FillPBufferAttribs(attribs, aFormat, configCanBindToTexture, 8, tryDepthSize);
61664:             break;
61664:         case 1:
80617:             FillPBufferAttribs(attribs, aFormat, configCanBindToTexture, -1, tryDepthSize);
61664:             break;
61664:         case 2:
61664:             FillPBufferAttribs(attribs, aFormat, configCanBindToTexture, -1, -1);
61664:             break;
60089:         }
96853:     }
60089: 
47908:     if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(),
61664:                                    &attribs[0],
47908:                                    configs, numConfigs,
61663:                                    &foundConfigs)
61663:         || foundConfigs == 0)
47908:     {
96853:         if (bufferUnused) {
96853:             NS_WARNING("No EGL Config for minimal PBuffer!");
96853:             return nsnull;
96853:         }
96853: 
61664:         if (attribAttempt < 3) {
61664:             attribAttempt++;
61664:             goto TRY_ATTRIBS_AGAIN;
61664:         }
61664: 
61663:         if (configCanBindToTexture) {
61663:             NS_WARNING("No pbuffer EGL configs that can bind to texture, trying without");
61663:             configCanBindToTexture = false;
61664:             attribAttempt = 0;
61664:             goto TRY_ATTRIBS_AGAIN;
61663:         }
61663: 
47908:         // no configs? no pbuffers!
92137:         NS_WARNING("Failed to select acceptable config for PBuffer creation!");
43426:         return nsnull;
47908:     }
47908: 
61664:     // XXX do some smarter matching here, perhaps instead of the more complex
61664:     // minimum overrides above
47908:     config = configs[0];
47908: #ifdef DEBUG
47908:     sEGLLibrary.DumpEGLConfig(config);
47908: #endif
47908: 
47908:     gfxIntSize pbsize(aSize);
61664:     surface = GLContextEGL::CreatePBufferSurfaceTryingPowerOfTwo(config,
61664:                                                                  configCanBindToTexture
61664:                                                                  ? (aFormat.minAlpha
61664:                                                                     ? LOCAL_EGL_TEXTURE_RGBA
61664:                                                                     : LOCAL_EGL_TEXTURE_RGB)
61664:                                                                  : LOCAL_EGL_NONE,
61664:                                                                  pbsize);
92137:     if (!surface) {
92137:         NS_WARNING("Failed to create PBuffer for context!");
47908:         return nsnull;
92137:     }
43426: 
43426:     sEGLLibrary.fBindAPI(LOCAL_EGL_OPENGL_ES_API);
43426: 
89556:     GLContextEGL* shareContext = GetGlobalContextEGL();
47908:     context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
47908:                                          config,
89556:                                          shareContext ? shareContext->mContext
89556:                                                       : EGL_NO_CONTEXT,
84592:                                          sEGLLibrary.HasRobustness() ? gContextAttribsRobustness
84592:                                                                      : gContextAttribs);
43426:     if (!context) { 
92137:         NS_WARNING("Failed to create GLContext from PBuffer");
47908:         sEGLLibrary.fDestroySurface(EGL_DISPLAY(), surface);
43426:         return nsnull;
43426:     }
43426: 
89556:     nsRefPtr<GLContextEGL> glContext = new GLContextEGL(aFormat, shareContext,
47908:                                                         config, surface, context,
80486:                                                         true);
43426: 
47908:     if (!glContext->Init()) {
92137:         NS_WARNING("Failed to initialize GLContext!");
47908:         return nsnull;
47908:     }
47908: 
93759:     glContext->mCanBindToTexture = configCanBindToTexture;
92137: 
92137:     if (!bufferUnused) {  // We *are* using the buffer
47908:       glContext->SetOffscreenSize(aSize, pbsize);
80486:       glContext->mIsPBuffer = true;
89556:     }
47908: 
47908:     return glContext.forget();
47908: }
47908: 
54904: #ifdef MOZ_X11
60438: EGLSurface
97354: CreateEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig)
54904: {
54904:     gfxXlibSurface* xsurface = static_cast<gfxXlibSurface*>(aSurface);
79445:     bool opaque =
60438:         aSurface->GetContentType() == gfxASurface::CONTENT_COLOR;
60438: 
60438:     static EGLint pixmap_config_rgb[] = {
60438:         LOCAL_EGL_TEXTURE_TARGET,       LOCAL_EGL_TEXTURE_2D,
60438:         LOCAL_EGL_TEXTURE_FORMAT,       LOCAL_EGL_TEXTURE_RGB,
60438:         LOCAL_EGL_NONE
60438:     };
60438: 
60438:     static EGLint pixmap_config_rgba[] = {
60438:         LOCAL_EGL_TEXTURE_TARGET,       LOCAL_EGL_TEXTURE_2D,
60438:         LOCAL_EGL_TEXTURE_FORMAT,       LOCAL_EGL_TEXTURE_RGBA,
60438:         LOCAL_EGL_NONE
60438:     };
60438: 
60438:     EGLSurface surface = nsnull;
60438:     if (aConfig && *aConfig) {
60438:         if (opaque)
60438:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), *aConfig,
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
60438:                                                        pixmap_config_rgb);
60438:         else
60438:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), *aConfig,
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
60438:                                                        pixmap_config_rgba);
60438: 
60438:         if (surface != EGL_NO_SURFACE)
60438:             return surface;
60438:     }
54904: 
54904:     EGLConfig configs[32];
54904:     int numConfigs = 32;
54904: 
60438:     static EGLint pixmap_config[] = {
54904:         LOCAL_EGL_SURFACE_TYPE,         LOCAL_EGL_PIXMAP_BIT,
54904:         LOCAL_EGL_RENDERABLE_TYPE,      LOCAL_EGL_OPENGL_ES2_BIT,
97354:         LOCAL_EGL_DEPTH_SIZE,           0,
54904:         LOCAL_EGL_BIND_TO_TEXTURE_RGB,  LOCAL_EGL_TRUE,
54904:         LOCAL_EGL_NONE
54904:     };
54904: 
60438:     static EGLint pixmap_lock_config[] = {
60438:         LOCAL_EGL_SURFACE_TYPE,         LOCAL_EGL_PIXMAP_BIT | LOCAL_EGL_LOCK_SURFACE_BIT_KHR,
60438:         LOCAL_EGL_RENDERABLE_TYPE,      LOCAL_EGL_OPENGL_ES2_BIT,
97354:         LOCAL_EGL_DEPTH_SIZE,           0,
60438:         LOCAL_EGL_BIND_TO_TEXTURE_RGB,  LOCAL_EGL_TRUE,
54904:         LOCAL_EGL_NONE
54904:     };
54904: 
60438:     if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(),
60438:                                    sEGLLibrary.HasKHRLockSurface() ?
60438:                                        pixmap_lock_config : pixmap_config,
54904:                                    configs, numConfigs, &numConfigs))
54904:         return nsnull;
54904: 
54904:     if (numConfigs == 0)
54904:         return nsnull;
54904: 
54904:     int i = 0;
54904:     for (i = 0; i < numConfigs; ++i) {
54904:         if (opaque)
54904:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), configs[i],
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
54904:                                                        pixmap_config_rgb);
54904:         else
54904:             surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), configs[i],
77137:                                                        (EGLNativePixmapType)xsurface->XDrawable(),
54904:                                                        pixmap_config_rgba);
54904: 
54904:         if (surface != EGL_NO_SURFACE)
54904:             break;
54904:     }
54904: 
54904:     if (!surface) {
54904:         return nsnull;
54904:     }
54904: 
60438:     if (aConfig)
60438:         *aConfig = configs[i];
54904: 
60438:     return surface;
54904: }
54904: #endif
54904: 
47908: already_AddRefed<GLContextEGL>
47908: GLContextEGL::CreateEGLPixmapOffscreenContext(const gfxIntSize& aSize,
71551:                                               const ContextFormat& aFormat,
79445:                                               bool aShare)
47908: {
47908:     gfxASurface *thebesSurface = nsnull;
47908:     EGLNativePixmapType pixmap = 0;
47908: 
47908: #ifdef MOZ_X11
47908:     nsRefPtr<gfxXlibSurface> xsurface =
47908:         gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()),
47908:                                gfxXlibSurface::FindRenderFormat(DefaultXDisplay(),
47908:                                                                 gfxASurface::ImageFormatRGB24),
97354:                                aSize);
60438: 
60438:     // XSync required after gfxXlibSurface::Create, otherwise EGL will fail with BadDrawable error
60438:     XSync(DefaultXDisplay(), False);
47908:     if (xsurface->CairoStatus() != 0)
43426:         return nsnull;
43426: 
47908:     thebesSurface = xsurface;
77137:     pixmap = (EGLNativePixmapType)xsurface->XDrawable();
47908: #endif
47908: 
47908:     if (!pixmap) {
47908:         return nsnull;
47908:     }
47908: 
60090:     EGLSurface surface = 0;
47908:     EGLConfig config = 0;
47908: 
54904: #ifdef MOZ_X11
97354:     surface = CreateEGLSurfaceForXSurface(thebesSurface, &config);
54904: #endif
54904:     if (!config) {
47908:         return nsnull;
47908:     }
47908: 
71551:     GLContextEGL *shareContext = aShare ? GetGlobalContextEGL() : nsnull;
47908: 
71551:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateGLContext(aFormat,
71551:                                       surface,
47908:                                       config,
71551:                                       shareContext,
80486:                                       true);
47908: 
47908:     glContext->HoldSurface(thebesSurface);
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: // Under EGL, if we're under X11, then we have to create a Pixmap
47908: // because Maemo's EGL implementation doesn't support pbuffers at all
47908: // for some reason.  On Android, pbuffers are supported fine, though
47908: // often without the ability to texture from them directly.
47908: already_AddRefed<GLContext>
47908: GLContextProviderEGL::CreateOffscreen(const gfxIntSize& aSize,
93720:                                       const ContextFormat& aFormat,
93720:                                       const ContextFlags aFlags)
47908: {
47908:     if (!sEGLLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
93812: #if !defined(MOZ_X11)
92137:     bool usePBuffers = false; // Generally, prefer FBOs to PBuffers
92137: 
92137:     if (sEGLLibrary.IsANGLE())
92137:       usePBuffers = true; // For d3d share handle, we need an EGL surface
92137: 
92137:     gfxIntSize pbufferSize = usePBuffers ? aSize : gfxIntSize(16, 16);
80617:     nsRefPtr<GLContextEGL> glContext =
92137:         GLContextEGL::CreateEGLPBufferOffscreenContext(pbufferSize, aFormat, !usePBuffers);
80617: 
80617:     if (!glContext)
80617:         return nsnull;
80617: 
92137:     gfxIntSize fboSize = usePBuffers ? glContext->OffscreenActualSize() : aSize;
96935:     if (!(aFlags & GLContext::ContextFlagsGlobal) && !glContext->ResizeOffscreenFBOs(fboSize, !usePBuffers))
80617:         return nsnull;
80617: 
80617:     return glContext.forget();
74436: #elif defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
80617:     nsRefPtr<GLContextEGL> glContext =
80900:         GLContextEGL::CreateBasicEGLPixmapOffscreenContext(aSize, aFormat);
80617: 
80617:     if (!glContext)
80617:         return nsnull;
80617: 
96935:     if (!(aFlags & GLContext::ContextFlagsGlobal) && !glContext->ResizeOffscreenFBOs(glContext->OffscreenActualSize(), true))
80617:         return nsnull;
80617: 
80617:     return glContext.forget();
47908: #elif defined(MOZ_X11)
71551:     nsRefPtr<GLContextEGL> glContext =
97354:         GLContextEGL::CreateEGLPixmapOffscreenContext(gfxIntSize(16, 16), aFormat, true);
71551: 
71551:     if (!glContext) {
71551:         return nsnull;
71551:     }
91427: 
97563:     if (!(aFlags & GLContext::ContextFlagsGlobal) && !glContext->ResizeOffscreenFBOs(aSize, true)) {
71551:         // we weren't able to create the initial
71551:         // offscreen FBO, so this is dead
71551:         return nsnull;
71551:     }
71551:     return glContext.forget();
47908: #else
47908:     return nsnull;
47908: #endif
43426: }
43426: 
44173: already_AddRefed<GLContext>
47907: GLContextProviderEGL::CreateForNativePixmapSurface(gfxASurface* aSurface)
44173: {
44173:     if (!sEGLLibrary.EnsureInitialized())
44173:         return nsnull;
44173: 
44173: #ifdef MOZ_X11
72361:     EGLSurface surface = nsnull;
72361:     EGLConfig config = nsnull;
72361: 
44173:     if (aSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
44173:         // Not implemented
44173:         return nsnull;
44173:     }
44173: 
60438:     surface = CreateEGLSurfaceForXSurface(aSurface, &config);
54904:     if (!config) {
44173:         return nsnull;
44173:     }
44173: 
71551:     GLContextEGL *shareContext = GetGlobalContextEGL();
71551:     gfxXlibSurface* xsurface = static_cast<gfxXlibSurface*>(aSurface);
44173: 
44173:     nsRefPtr<GLContextEGL> glContext =
71551:         GLContextEGL::CreateGLContext(DepthToGLFormat(xsurface->XRenderFormat()->depth),
80486:                                       surface, config, shareContext, false);
71551: 
54904:     glContext->HoldSurface(aSurface);
44173: 
44173:     return glContext.forget().get();
44173: #else
44173:     // Not implemented
44173:     return nsnull;
44173: #endif
44173: }
44173: 
47908: GLContext *
47908: GLContextProviderEGL::GetGlobalContext()
47908: {
47908:     static bool triedToCreateContext = false;
47908:     if (!triedToCreateContext && !gGlobalContext) {
47908:         triedToCreateContext = true;
89556:         // Don't assign directly to gGlobalContext here, because
89556:         // CreateOffscreen can call us re-entrantly.
89556:         nsRefPtr<GLContext> ctx =
89556:             GLContextProviderEGL::CreateOffscreen(gfxIntSize(16, 16),
93720:                                                   ContextFormat(ContextFormat::BasicRGB24),
93720:                                                   GLContext::ContextFlagsGlobal);
89556:         gGlobalContext = ctx;
49071:         if (gGlobalContext)
80486:             gGlobalContext->SetIsGlobalSharedContext(true);
47908:     }
47908: 
47908:     return gGlobalContext;
47908: }
47908: 
47967: void
47967: GLContextProviderEGL::Shutdown()
47967: {
54672:     gGlobalContext = nsnull;
47967: }
47967: 
74436: //------------------------------------------------------------------------------
74436: // The following methods exist to support an accelerated WebGL XRender composite
74436: // path for BasicLayers. This is a potentially temporary change that can be
74436: // removed when performance of GL layers is superior on mobile linux platforms.
74436: //------------------------------------------------------------------------------
74436: #if defined(MOZ_X11) && defined(MOZ_EGL_XRENDER_COMPOSITE)
74436: 
74436: EGLSurface
74436: CreateBasicEGLSurfaceForXSurface(gfxASurface* aSurface, EGLConfig* aConfig)
74436: {
74436:   gfxXlibSurface* xsurface = static_cast<gfxXlibSurface*>(aSurface);
74436: 
79445:   bool opaque =
74436:     aSurface->GetContentType() == gfxASurface::CONTENT_COLOR;
74436: 
74436:   EGLSurface surface = nsnull;
74436:   if (aConfig && *aConfig) {
74436:     surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), *aConfig,
74436:                                                xsurface->XDrawable(),
74436:                                                0);
74436: 
74436:     if (surface != EGL_NO_SURFACE)
74436:       return surface;
74436:   }
74436: 
74436:   EGLConfig configs[32];
74436:   int numConfigs = 32;
74436: 
74436:   static EGLint pixmap_config[] = {
74436:       LOCAL_EGL_SURFACE_TYPE,         LOCAL_EGL_PIXMAP_BIT,
74436:       LOCAL_EGL_RENDERABLE_TYPE,      LOCAL_EGL_OPENGL_ES2_BIT,
74436:       0x30E2, 0x30E3,
74436:       LOCAL_EGL_DEPTH_SIZE,           16,
74436:       LOCAL_EGL_NONE
74436:   };
74436: 
74436:   if (!sEGLLibrary.fChooseConfig(EGL_DISPLAY(),
74436:                                  pixmap_config,
74436:                                  configs, numConfigs, &numConfigs))
74436:       return nsnull;
74436: 
74436:   if (numConfigs == 0)
74436:       return nsnull;
74436: 
74436:   int i = 0;
74436:   for (i = 0; i < numConfigs; ++i) {
74436:     surface = sEGLLibrary.fCreatePixmapSurface(EGL_DISPLAY(), configs[i],
74436:                                                xsurface->XDrawable(),
74436:                                                0);
74436: 
74436:     if (surface != EGL_NO_SURFACE)
74436:       break;
74436:   }
74436: 
74436:   if (!surface) {
74436:     return nsnull;
74436:   }
74436: 
74436:   if (aConfig)
74436:   {
74436:     *aConfig = configs[i];
74436:   }
74436: 
74436:   return surface;
74436: }
74436: 
74436: already_AddRefed<GLContextEGL>
74436: GLContextEGL::CreateBasicEGLPixmapOffscreenContext(const gfxIntSize& aSize,
74436:                                               const ContextFormat& aFormat)
74436: {
74436:   gfxASurface *thebesSurface = nsnull;
74436:   EGLNativePixmapType pixmap = 0;
74436: 
74436:   XRenderPictFormat* format = gfxXlibSurface::FindRenderFormat(DefaultXDisplay(), gfxASurface::ImageFormatARGB32);
74436: 
74436:   nsRefPtr<gfxXlibSurface> xsurface =
74436:     gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()), format, aSize);
74436: 
74436:   // XSync required after gfxXlibSurface::Create, otherwise EGL will fail with BadDrawable error
74436:   XSync(DefaultXDisplay(), False);
74436:   if (xsurface->CairoStatus() != 0)
74436:   {
74436:     return nsnull;
74436:   }
74436: 
74436:   thebesSurface = xsurface;
74436: 
74436:   pixmap = xsurface->XDrawable();
74436: 
74436:   if (!pixmap) {
74436:     return nsnull;
74436:   }
74436: 
74436:   EGLSurface surface = 0;
74436:   EGLConfig config = 0;
74436: 
74436:   surface = CreateBasicEGLSurfaceForXSurface(xsurface, &config);
74436: 
74436:   if (!config) {
74436:     return nsnull;
74436:   }
74436: 
74436:   EGLContext context = sEGLLibrary.fCreateContext(EGL_DISPLAY(),
74436:                                                   config,
74436:                                                   EGL_NO_CONTEXT,
84592:                                                   sEGLLibrary.HasRobustness() ? gContextAttribsRobustness
84592:                                                                               : gContextAttribs);
74436:   if (!context) {
74436:     sEGLLibrary.fDestroySurface(EGL_DISPLAY(), surface);
74436:     return nsnull;
74436:   }
74436: 
74436:   nsRefPtr<GLContextEGL> glContext = new GLContextEGL(aFormat, nsnull,
74436:                                                       config, surface, context,
80486:                                                       true);
74436: 
74436:   if (!glContext->Init())
74436:   {
74436:     return nsnull;
74436:   }
74436: 
74436:   glContext->HoldSurface(thebesSurface);
74436: 
74436:   return glContext.forget();
74436: }
74436: 
79445: bool GLContextEGL::ResizeOffscreenPixmapSurface(const gfxIntSize& aNewSize)
74436: {
74436:   gfxASurface *thebesSurface = nsnull;
74436:   EGLNativePixmapType pixmap = 0;
74436: 
74436:   XRenderPictFormat* format = gfxXlibSurface::FindRenderFormat(DefaultXDisplay(), gfxASurface::ImageFormatARGB32);
74436: 
74436:   nsRefPtr<gfxXlibSurface> xsurface =
74436:     gfxXlibSurface::Create(DefaultScreenOfDisplay(DefaultXDisplay()),
74436:                            format,
74436:                            aNewSize);
74436: 
74436:   // XSync required after gfxXlibSurface::Create, otherwise EGL will fail with BadDrawable error
74436:   XSync(DefaultXDisplay(), False);
74436:   if (xsurface->CairoStatus() != 0)
74436:     return nsnull;
74436: 
74436:   thebesSurface = xsurface;
74436: 
74436:   pixmap = xsurface->XDrawable();
74436: 
74436:   if (!pixmap) {
74436:     return nsnull;
74436:   }
74436: 
74436:   EGLSurface surface = 0;
74436:   EGLConfig config = 0;
74436:   surface = CreateBasicEGLSurfaceForXSurface(xsurface, &config);
74436:   if (!surface) {
74436:     NS_WARNING("Failed to resize pbuffer");
74436:     return nsnull;
74436:   }
74436: 
74436:   sEGLLibrary.fDestroySurface(EGL_DISPLAY(), mSurface);
74436: 
74436:   mSurface = surface;
74436:   HoldSurface(thebesSurface);
74436:   SetOffscreenSize(aNewSize, aNewSize);
80486:   MakeCurrent(true);
80486: 
80486:   return true;
74436: }
74436: 
74436: #endif
74436: 
43426: } /* namespace gl */
43426: } /* namespace mozilla */
43426: 
