 48470: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 48523:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
 48470:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 48470: 
 48470: #ifndef jsvalimpl_h__
 48470: #define jsvalimpl_h__
 95341: 
 48470: /*
 78613:  * Implementation details for js::Value in jsapi.h.
 48470:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: 
 80202: #include "js/Utility.h"
 48470: 
 48470: JS_BEGIN_EXTERN_C
 48470: 
 48470: /*
 48470:  * Try to get jsvals 64-bit aligned. We could almost assert that all values are
 48470:  * aligned, but MSVC and GCC occasionally break alignment.
 48470:  */
 64337: #if defined(__GNUC__) || defined(__xlc__) || defined(__xlC__)
 48470: # define JSVAL_ALIGNMENT        __attribute__((aligned (8)))
 48470: #elif defined(_MSC_VER)
 48470:   /*
 48470:    * Structs can be aligned with MSVC, but not if they are used as parameters,
 48470:    * so we just don't try to align.
 48470:    */
 48470: # define JSVAL_ALIGNMENT
 48470: #elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
 48470: # define JSVAL_ALIGNMENT
 64337: #elif defined(__HP_cc) || defined(__HP_aCC)
 64337: # define JSVAL_ALIGNMENT
 48470: #endif
 48470: 
 48523: #if JS_BITS_PER_WORD == 64
 48523: # define JSVAL_TAG_SHIFT 47
 48523: #endif
 48523: 
 48470: /*
 48470:  * We try to use enums so that printing a jsval_layout in the debugger shows
 48470:  * nice symbolic type tags, however we can only do this when we can force the
 48470:  * underlying type of the enum to be the desired size.
 48470:  */
 64337: #if defined(__cplusplus) && !defined(__SUNPRO_CC) && !defined(__xlC__)
 48470: 
 48470: #if defined(_MSC_VER)
 48470: # define JS_ENUM_HEADER(id, type)              enum id : type
 48470: # define JS_ENUM_FOOTER(id)
 48470: #else
 48470: # define JS_ENUM_HEADER(id, type)              enum id
 48470: # define JS_ENUM_FOOTER(id)                    __attribute__((packed))
 48470: #endif
 48470: 
 48470: /* Remember to propagate changes to the C defines below. */
 84755: JS_ENUM_HEADER(JSValueType, uint8_t)
 48470: {
 48470:     JSVAL_TYPE_DOUBLE              = 0x00,
 48470:     JSVAL_TYPE_INT32               = 0x01,
 48470:     JSVAL_TYPE_UNDEFINED           = 0x02,
 48470:     JSVAL_TYPE_BOOLEAN             = 0x03,
 48470:     JSVAL_TYPE_MAGIC               = 0x04,
 48470:     JSVAL_TYPE_STRING              = 0x05,
 48470:     JSVAL_TYPE_NULL                = 0x06,
 48470:     JSVAL_TYPE_OBJECT              = 0x07,
 48470: 
 87654:     /* These never appear in a jsval; they are only provided as an out-of-band value. */
 87654:     JSVAL_TYPE_UNKNOWN             = 0x20,
 87654:     JSVAL_TYPE_MISSING             = 0x21
 48470: } JS_ENUM_FOOTER(JSValueType);
 48470: 
 48488: JS_STATIC_ASSERT(sizeof(JSValueType) == 1);
 48488: 
 48470: #if JS_BITS_PER_WORD == 32
 48470: 
 48470: /* Remember to propagate changes to the C defines below. */
 84755: JS_ENUM_HEADER(JSValueTag, uint32_t)
 48470: {
 74599:     JSVAL_TAG_CLEAR                = 0xFFFFFF80,
 48470:     JSVAL_TAG_INT32                = JSVAL_TAG_CLEAR | JSVAL_TYPE_INT32,
 48470:     JSVAL_TAG_UNDEFINED            = JSVAL_TAG_CLEAR | JSVAL_TYPE_UNDEFINED,
 48470:     JSVAL_TAG_STRING               = JSVAL_TAG_CLEAR | JSVAL_TYPE_STRING,
 48470:     JSVAL_TAG_BOOLEAN              = JSVAL_TAG_CLEAR | JSVAL_TYPE_BOOLEAN,
 48470:     JSVAL_TAG_MAGIC                = JSVAL_TAG_CLEAR | JSVAL_TYPE_MAGIC,
 48470:     JSVAL_TAG_NULL                 = JSVAL_TAG_CLEAR | JSVAL_TYPE_NULL,
 48470:     JSVAL_TAG_OBJECT               = JSVAL_TAG_CLEAR | JSVAL_TYPE_OBJECT
 48558: } JS_ENUM_FOOTER(JSValueTag);
 48470: 
 48488: JS_STATIC_ASSERT(sizeof(JSValueTag) == 4);
 48488: 
 48470: #elif JS_BITS_PER_WORD == 64
 48470: 
 48470: /* Remember to propagate changes to the C defines below. */
 84755: JS_ENUM_HEADER(JSValueTag, uint32_t)
 48470: {
 48470:     JSVAL_TAG_MAX_DOUBLE           = 0x1FFF0,
 48470:     JSVAL_TAG_INT32                = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_INT32,
 48470:     JSVAL_TAG_UNDEFINED            = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_UNDEFINED,
 48470:     JSVAL_TAG_STRING               = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_STRING,
 48470:     JSVAL_TAG_BOOLEAN              = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_BOOLEAN,
 48470:     JSVAL_TAG_MAGIC                = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_MAGIC,
 48470:     JSVAL_TAG_NULL                 = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_NULL,
 48470:     JSVAL_TAG_OBJECT               = JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_OBJECT
 48523: } JS_ENUM_FOOTER(JSValueTag);
 48470: 
 84755: JS_STATIC_ASSERT(sizeof(JSValueTag) == sizeof(uint32_t));
 48523: 
 84755: JS_ENUM_HEADER(JSValueShiftedTag, uint64_t)
 48523: {
 84755:     JSVAL_SHIFTED_TAG_MAX_DOUBLE   = ((((uint64_t)JSVAL_TAG_MAX_DOUBLE) << JSVAL_TAG_SHIFT) | 0xFFFFFFFF),
 84755:     JSVAL_SHIFTED_TAG_INT32        = (((uint64_t)JSVAL_TAG_INT32)      << JSVAL_TAG_SHIFT),
 84755:     JSVAL_SHIFTED_TAG_UNDEFINED    = (((uint64_t)JSVAL_TAG_UNDEFINED)  << JSVAL_TAG_SHIFT),
 84755:     JSVAL_SHIFTED_TAG_STRING       = (((uint64_t)JSVAL_TAG_STRING)     << JSVAL_TAG_SHIFT),
 84755:     JSVAL_SHIFTED_TAG_BOOLEAN      = (((uint64_t)JSVAL_TAG_BOOLEAN)    << JSVAL_TAG_SHIFT),
 84755:     JSVAL_SHIFTED_TAG_MAGIC        = (((uint64_t)JSVAL_TAG_MAGIC)      << JSVAL_TAG_SHIFT),
 84755:     JSVAL_SHIFTED_TAG_NULL         = (((uint64_t)JSVAL_TAG_NULL)       << JSVAL_TAG_SHIFT),
 84755:     JSVAL_SHIFTED_TAG_OBJECT       = (((uint64_t)JSVAL_TAG_OBJECT)     << JSVAL_TAG_SHIFT)
 48523: } JS_ENUM_FOOTER(JSValueShiftedTag);
 48523: 
 84755: JS_STATIC_ASSERT(sizeof(JSValueShiftedTag) == sizeof(uint64_t));
 48488: 
 48470: #endif
 48470: 
 48470: #else  /* defined(__cplusplus) */
 48470: 
 84755: typedef uint8_t JSValueType;
 84755: #define JSVAL_TYPE_DOUBLE            ((uint8_t)0x00)
 84755: #define JSVAL_TYPE_INT32             ((uint8_t)0x01)
 84755: #define JSVAL_TYPE_UNDEFINED         ((uint8_t)0x02)
 84755: #define JSVAL_TYPE_BOOLEAN           ((uint8_t)0x03)
 84755: #define JSVAL_TYPE_MAGIC             ((uint8_t)0x04)
 84755: #define JSVAL_TYPE_STRING            ((uint8_t)0x05)
 84755: #define JSVAL_TYPE_NULL              ((uint8_t)0x06)
 84755: #define JSVAL_TYPE_OBJECT            ((uint8_t)0x07)
 84755: #define JSVAL_TYPE_UNKNOWN           ((uint8_t)0x20)
 48470: 
 48470: #if JS_BITS_PER_WORD == 32
 48470: 
 84755: typedef uint32_t JSValueTag;
 84755: #define JSVAL_TAG_CLEAR              ((uint32_t)(0xFFFFFF80))
 84755: #define JSVAL_TAG_INT32              ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_INT32))
 84755: #define JSVAL_TAG_UNDEFINED          ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_UNDEFINED))
 84755: #define JSVAL_TAG_STRING             ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_STRING))
 84755: #define JSVAL_TAG_BOOLEAN            ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_BOOLEAN))
 84755: #define JSVAL_TAG_MAGIC              ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_MAGIC))
 84755: #define JSVAL_TAG_NULL               ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_NULL))
 84755: #define JSVAL_TAG_OBJECT             ((uint32_t)(JSVAL_TAG_CLEAR | JSVAL_TYPE_OBJECT))
 48470: 
 48470: #elif JS_BITS_PER_WORD == 64
 48470: 
 84755: typedef uint32_t JSValueTag;
 84755: #define JSVAL_TAG_MAX_DOUBLE         ((uint32_t)(0x1FFF0))
 84755: #define JSVAL_TAG_INT32              (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_INT32)
 84755: #define JSVAL_TAG_UNDEFINED          (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_UNDEFINED)
 84755: #define JSVAL_TAG_STRING             (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_STRING)
 84755: #define JSVAL_TAG_BOOLEAN            (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_BOOLEAN)
 84755: #define JSVAL_TAG_MAGIC              (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_MAGIC)
 84755: #define JSVAL_TAG_NULL               (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_NULL)
 84755: #define JSVAL_TAG_OBJECT             (uint32_t)(JSVAL_TAG_MAX_DOUBLE | JSVAL_TYPE_OBJECT)
 48470: 
 84755: typedef uint64_t JSValueShiftedTag;
 84755: #define JSVAL_SHIFTED_TAG_MAX_DOUBLE ((((uint64_t)JSVAL_TAG_MAX_DOUBLE) << JSVAL_TAG_SHIFT) | 0xFFFFFFFF)
 84755: #define JSVAL_SHIFTED_TAG_INT32      (((uint64_t)JSVAL_TAG_INT32)      << JSVAL_TAG_SHIFT)
 84755: #define JSVAL_SHIFTED_TAG_UNDEFINED  (((uint64_t)JSVAL_TAG_UNDEFINED)  << JSVAL_TAG_SHIFT)
 84755: #define JSVAL_SHIFTED_TAG_STRING     (((uint64_t)JSVAL_TAG_STRING)     << JSVAL_TAG_SHIFT)
 84755: #define JSVAL_SHIFTED_TAG_BOOLEAN    (((uint64_t)JSVAL_TAG_BOOLEAN)    << JSVAL_TAG_SHIFT)
 84755: #define JSVAL_SHIFTED_TAG_MAGIC      (((uint64_t)JSVAL_TAG_MAGIC)      << JSVAL_TAG_SHIFT)
 84755: #define JSVAL_SHIFTED_TAG_NULL       (((uint64_t)JSVAL_TAG_NULL)       << JSVAL_TAG_SHIFT)
 84755: #define JSVAL_SHIFTED_TAG_OBJECT     (((uint64_t)JSVAL_TAG_OBJECT)     << JSVAL_TAG_SHIFT)
 48523: 
 48470: #endif  /* JS_BITS_PER_WORD */
 49082: #endif  /* defined(__cplusplus) && !defined(__SUNPRO_CC) */
 48470: 
 48470: #define JSVAL_LOWER_INCL_TYPE_OF_OBJ_OR_NULL_SET        JSVAL_TYPE_NULL
 48470: #define JSVAL_UPPER_EXCL_TYPE_OF_PRIMITIVE_SET          JSVAL_TYPE_OBJECT
 48470: #define JSVAL_UPPER_INCL_TYPE_OF_NUMBER_SET             JSVAL_TYPE_INT32
 53557: #define JSVAL_LOWER_INCL_TYPE_OF_PTR_PAYLOAD_SET        JSVAL_TYPE_MAGIC
 48470: 
 48470: #if JS_BITS_PER_WORD == 32
 48470: 
 48470: #define JSVAL_TYPE_TO_TAG(type)      ((JSValueTag)(JSVAL_TAG_CLEAR | (type)))
 48470: 
 48470: #define JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET         JSVAL_TAG_NULL
 48470: #define JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET           JSVAL_TAG_OBJECT
 48470: #define JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET              JSVAL_TAG_INT32
 48470: #define JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET             JSVAL_TAG_STRING
 48470: 
 48470: #elif JS_BITS_PER_WORD == 64
 48470: 
 48470: #define JSVAL_PAYLOAD_MASK           0x00007FFFFFFFFFFFLL
 48523: #define JSVAL_TAG_MASK               0xFFFF800000000000LL
 48470: #define JSVAL_TYPE_TO_TAG(type)      ((JSValueTag)(JSVAL_TAG_MAX_DOUBLE | (type)))
 84755: #define JSVAL_TYPE_TO_SHIFTED_TAG(type) (((uint64_t)JSVAL_TYPE_TO_TAG(type)) << JSVAL_TAG_SHIFT)
 48470: 
 48470: #define JSVAL_LOWER_INCL_SHIFTED_TAG_OF_OBJ_OR_NULL_SET  JSVAL_SHIFTED_TAG_NULL
 48470: #define JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_PRIMITIVE_SET    JSVAL_SHIFTED_TAG_OBJECT
 48470: #define JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_NUMBER_SET       JSVAL_SHIFTED_TAG_UNDEFINED
 48470: #define JSVAL_LOWER_INCL_SHIFTED_TAG_OF_GCTHING_SET      JSVAL_SHIFTED_TAG_STRING
 48470: 
 48470: #endif /* JS_BITS_PER_WORD */
 48470: 
 48470: typedef enum JSWhyMagic
 48470: {
 48470:     JS_ARRAY_HOLE,               /* a hole in a dense array */
 48470:     JS_NATIVE_ENUMERATE,         /* indicates that a custom enumerate hook forwarded
 79734:                                   * to JS_EnumerateState, which really means the object can be
 48470:                                   * enumerated like a native object. */
 48470:     JS_NO_ITER_VALUE,            /* there is not a pending iterator value */
 48470:     JS_GENERATOR_CLOSING,        /* exception value thrown when closing a generator */
 48470:     JS_NO_CONSTANT,              /* compiler sentinel value */
 48470:     JS_THIS_POISON,              /* used in debug builds to catch tracing errors */
 53840:     JS_ARG_POISON,               /* used in debug builds to catch tracing errors */
 51110:     JS_SERIALIZE_NO_NODE,        /* an empty subnode in the AST serializer */
 77343:     JS_LAZY_ARGUMENTS,           /* lazy arguments value on the stack */
100006:     JS_UNASSIGNED_ARGUMENTS,     /* the initial value of callobj.arguments */
 93250:     JS_OPTIMIZED_ARGUMENTS,      /* optimized-away 'arguments' value */
 86533:     JS_IS_CONSTRUCTING,          /* magic value passed to natives to indicate construction */
 93646:     JS_OVERWRITTEN_CALLEE,       /* arguments.callee has been overwritten */
 48470:     JS_GENERIC_MAGIC             /* for local use */
 48470: } JSWhyMagic;
 48470: 
 48470: #if defined(IS_LITTLE_ENDIAN)
 48470: # if JS_BITS_PER_WORD == 32
 48470: typedef union jsval_layout
 48470: {
 84755:     uint64_t asBits;
 48470:     struct {
 48470:         union {
 84755:             int32_t        i32;
 84755:             uint32_t       u32;
 48470:             JSBool         boo;
 48470:             JSString       *str;
 48470:             JSObject       *obj;
 48470:             void           *ptr;
 48470:             JSWhyMagic     why;
 78613:             size_t         word;
 99089:             uintptr_t      uintptr;
 48470:         } payload;
 48470:         JSValueTag tag;
 48470:     } s;
 48470:     double asDouble;
 53638:     void *asPtr;
 87357: } JSVAL_ALIGNMENT jsval_layout;
 48470: # elif JS_BITS_PER_WORD == 64
 48470: typedef union jsval_layout
 48470: {
 84755:     uint64_t asBits;
 60530: #if (!defined(_WIN64) && defined(__cplusplus))
 48560:     /* MSVC does not pack these correctly :-( */
 48470:     struct {
 84755:         uint64_t           payload47 : 47;
 48470:         JSValueTag         tag : 17;
 48470:     } debugView;
 48560: #endif
 48470:     struct {
 48470:         union {
 84755:             int32_t        i32;
 84755:             uint32_t       u32;
 48470:             JSWhyMagic     why;
 48470:         } payload;
 48470:     } s;
 48470:     double asDouble;
 53638:     void *asPtr;
 78613:     size_t asWord;
 99089:     uintptr_t asUIntPtr;
 87357: } JSVAL_ALIGNMENT jsval_layout;
 48470: # endif  /* JS_BITS_PER_WORD */
 48470: #else   /* defined(IS_LITTLE_ENDIAN) */
 48470: # if JS_BITS_PER_WORD == 32
 48470: typedef union jsval_layout
 48470: {
 84755:     uint64_t asBits;
 48470:     struct {
 48470:         JSValueTag tag;
 48470:         union {
 84755:             int32_t        i32;
 84755:             uint32_t       u32;
 48470:             JSBool         boo;
 48470:             JSString       *str;
 48470:             JSObject       *obj;
 48470:             void           *ptr;
 48470:             JSWhyMagic     why;
 78613:             size_t         word;
 99089:             uintptr_t      uintptr;
 48470:         } payload;
 48470:     } s;
 48470:     double asDouble;
 53640:     void *asPtr;
 87357: } JSVAL_ALIGNMENT jsval_layout;
 59981: # elif JS_BITS_PER_WORD == 64
 59981: typedef union jsval_layout
 59981: {
 84755:     uint64_t asBits;
 59981:     struct {
 59981:         JSValueTag         tag : 17;
 84755:         uint64_t           payload47 : 47;
 59981:     } debugView;
 59981:     struct {
 84755:         uint32_t           padding;
 59981:         union {
 84755:             int32_t        i32;
 84755:             uint32_t       u32;
 59981:             JSWhyMagic     why;
 59981:         } payload;
 59981:     } s;
 59981:     double asDouble;
 59981:     void *asPtr;
 78613:     size_t asWord;
 99089:     uintptr_t asUIntPtr;
 87357: } JSVAL_ALIGNMENT jsval_layout;
 48470: # endif /* JS_BITS_PER_WORD */
 48470: #endif  /* defined(IS_LITTLE_ENDIAN) */
 48470: 
 74913: JS_STATIC_ASSERT(sizeof(jsval_layout) == 8);
 74913: 
 48470: #if JS_BITS_PER_WORD == 32
 48470: 
 48488: /*
 48488:  * N.B. GCC, in some but not all cases, chooses to emit signed comparison of
 84755:  * JSValueTag even though its underlying type has been forced to be uint32_t.
 84755:  * Thus, all comparisons should explicitly cast operands to uint32_t.
 48488:  */
 48488: 
 78613: static JS_ALWAYS_INLINE jsval_layout
 84755: BUILD_JSVAL(JSValueTag tag, uint32_t payload)
 78613: {
 78613:     jsval_layout l;
 84755:     l.asBits = (((uint64_t)(uint32_t)tag) << 32) | payload;
 78613:     return l;
 78613: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_DOUBLE_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)l.s.tag <= (uint32_t)JSVAL_TAG_CLEAR;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: DOUBLE_TO_JSVAL_IMPL(double d)
 48470: {
 48470:     jsval_layout l;
 48470:     l.asDouble = d;
 48488:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_INT32_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_INT32;
 48470: }
 48470: 
 84755: static JS_ALWAYS_INLINE int32_t
 48470: JSVAL_TO_INT32_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.payload.i32;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 84755: INT32_TO_JSVAL_IMPL(int32_t i)
 48470: {
 48470:     jsval_layout l;
 48470:     l.s.tag = JSVAL_TAG_INT32;
 48470:     l.s.payload.i32 = i;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_NUMBER_IMPL(jsval_layout l)
 48470: {
 48470:     JSValueTag tag = l.s.tag;
 48470:     JS_ASSERT(tag != JSVAL_TAG_CLEAR);
 84755:     return (uint32_t)tag <= (uint32_t)JSVAL_UPPER_INCL_TAG_OF_NUMBER_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_UNDEFINED_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_UNDEFINED;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_STRING_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_STRING;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: STRING_TO_JSVAL_IMPL(JSString *str)
 48470: {
 48470:     jsval_layout l;
 55713:     JS_ASSERT(str);
 48470:     l.s.tag = JSVAL_TAG_STRING;
 48470:     l.s.payload.str = str;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSString *
 48470: JSVAL_TO_STRING_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.payload.str;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_BOOLEAN_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_BOOLEAN;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_TO_BOOLEAN_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.payload.boo;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: BOOLEAN_TO_JSVAL_IMPL(JSBool b)
 48470: {
 70875:     jsval_layout l;
 71082:     JS_ASSERT(b == JS_TRUE || b == JS_FALSE);
 48470:     l.s.tag = JSVAL_TAG_BOOLEAN;
 48470:     l.s.payload.boo = b;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 53557: JSVAL_IS_MAGIC_IMPL(jsval_layout l)
 53557: {
 53557:     return l.s.tag == JSVAL_TAG_MAGIC;
 53557: }
 53557: 
 53557: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_OBJECT_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_OBJECT;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_PRIMITIVE_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)l.s.tag < (uint32_t)JSVAL_UPPER_EXCL_TAG_OF_PRIMITIVE_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_OBJECT_OR_NULL_IMPL(jsval_layout l)
 48470: {
 84755:     JS_ASSERT((uint32_t)l.s.tag <= (uint32_t)JSVAL_TAG_OBJECT);
 84755:     return (uint32_t)l.s.tag >= (uint32_t)JSVAL_LOWER_INCL_TAG_OF_OBJ_OR_NULL_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSObject *
 48470: JSVAL_TO_OBJECT_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.payload.obj;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: OBJECT_TO_JSVAL_IMPL(JSObject *obj)
 48470: {
 48470:     jsval_layout l;
 53557:     JS_ASSERT(obj);
 48470:     l.s.tag = JSVAL_TAG_OBJECT;
 48470:     l.s.payload.obj = obj;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_NULL_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_NULL;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: PRIVATE_PTR_TO_JSVAL_IMPL(void *ptr)
 48470: {
 48470:     jsval_layout l;
 84755:     JS_ASSERT(((uint32_t)ptr & 1) == 0);
 48470:     l.s.tag = (JSValueTag)0;
 48470:     l.s.payload.ptr = ptr;
 48470:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE void *
 48470: JSVAL_TO_PRIVATE_PTR_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.payload.ptr;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_GCTHING_IMPL(jsval_layout l)
 48470: {
 48488:     /* gcc sometimes generates signed < without explicit casts. */
 84755:     return (uint32_t)l.s.tag >= (uint32_t)JSVAL_LOWER_INCL_TAG_OF_GCTHING_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE void *
 48470: JSVAL_TO_GCTHING_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.payload.ptr;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_TRACEABLE_IMPL(jsval_layout l)
 48470: {
 48470:     return l.s.tag == JSVAL_TAG_STRING || l.s.tag == JSVAL_TAG_OBJECT;
 48470: }
 48470: 
 84755: static JS_ALWAYS_INLINE uint32_t
 48470: JSVAL_TRACE_KIND_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)(JSBool)JSVAL_IS_STRING_IMPL(l);
 48470: }
 48470: 
 78613: static JS_ALWAYS_INLINE JSBool
 84755: JSVAL_IS_SPECIFIC_INT32_IMPL(jsval_layout l, int32_t i32)
 78613: {
 78613:     return l.s.tag == JSVAL_TAG_INT32 && l.s.payload.i32 == i32;
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE JSBool
 78613: JSVAL_IS_SPECIFIC_BOOLEAN(jsval_layout l, JSBool b)
 78613: {
 78613:     return (l.s.tag == JSVAL_TAG_BOOLEAN) && (l.s.payload.boo == b);
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE jsval_layout
 78613: MAGIC_TO_JSVAL_IMPL(JSWhyMagic why)
 78613: {
 78613:     jsval_layout l;
 78613:     l.s.tag = JSVAL_TAG_MAGIC;
 78613:     l.s.payload.why = why;
 78613:     return l;
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE JSBool
 78613: JSVAL_SAME_TYPE_IMPL(jsval_layout lhs, jsval_layout rhs)
 78613: {
 78613:     JSValueTag ltag = lhs.s.tag, rtag = rhs.s.tag;
 78613:     return ltag == rtag || (ltag < JSVAL_TAG_CLEAR && rtag < JSVAL_TAG_CLEAR);
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE jsval_layout
 84755: PRIVATE_UINT32_TO_JSVAL_IMPL(uint32_t ui)
 78613: {
 78613:     jsval_layout l;
 78613:     l.s.tag = (JSValueTag)0;
 78613:     l.s.payload.u32 = ui;
 78613:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
 78613:     return l;
 78613: }
 78613: 
 84755: static JS_ALWAYS_INLINE uint32_t
 78613: JSVAL_TO_PRIVATE_UINT32_IMPL(jsval_layout l)
 78613: {
 78613:     return l.s.payload.u32;
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE JSValueType
 78613: JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL(jsval_layout l)
 78613: {
 84755:     uint32_t type = l.s.tag & 0xF;
 78613:     JS_ASSERT(type > JSVAL_TYPE_DOUBLE);
 78613:     return (JSValueType)type;
 78613: }
 78613: 
 48470: #elif JS_BITS_PER_WORD == 64
 48470: 
 78613: static JS_ALWAYS_INLINE jsval_layout
 84755: BUILD_JSVAL(JSValueTag tag, uint64_t payload)
 78613: {
 78613:     jsval_layout l;
 84755:     l.asBits = (((uint64_t)(uint32_t)tag) << JSVAL_TAG_SHIFT) | payload;
 78613:     return l;
 78613: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_DOUBLE_IMPL(jsval_layout l)
 48470: {
 48470:     return l.asBits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: DOUBLE_TO_JSVAL_IMPL(double d)
 48470: {
 48470:     jsval_layout l;
 48470:     l.asDouble = d;
 48470:     JS_ASSERT(l.asBits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE);
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_INT32_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)(l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_INT32;
 48470: }
 48470: 
 84755: static JS_ALWAYS_INLINE int32_t
 48470: JSVAL_TO_INT32_IMPL(jsval_layout l)
 48470: {
 84755:     return (int32_t)l.asBits;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 84755: INT32_TO_JSVAL_IMPL(int32_t i32)
 48470: {
 48470:     jsval_layout l;
 84755:     l.asBits = ((uint64_t)(uint32_t)i32) | JSVAL_SHIFTED_TAG_INT32;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_NUMBER_IMPL(jsval_layout l)
 48470: {
 48470:     return l.asBits < JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_NUMBER_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_UNDEFINED_IMPL(jsval_layout l)
 48470: {
 48470:     return l.asBits == JSVAL_SHIFTED_TAG_UNDEFINED;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_STRING_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)(l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_STRING;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: STRING_TO_JSVAL_IMPL(JSString *str)
 48470: {
 48470:     jsval_layout l;
 84755:     uint64_t strBits = (uint64_t)str;
 56022:     JS_ASSERT(str);
 48470:     JS_ASSERT((strBits >> JSVAL_TAG_SHIFT) == 0);
 48470:     l.asBits = strBits | JSVAL_SHIFTED_TAG_STRING;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSString *
 48470: JSVAL_TO_STRING_IMPL(jsval_layout l)
 48470: {
 48470:     return (JSString *)(l.asBits & JSVAL_PAYLOAD_MASK);
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_BOOLEAN_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)(l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_BOOLEAN;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_TO_BOOLEAN_IMPL(jsval_layout l)
 48470: {
 48470:     return (JSBool)l.asBits;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: BOOLEAN_TO_JSVAL_IMPL(JSBool b)
 48470: {
 70875:     jsval_layout l;
 71082:     JS_ASSERT(b == JS_TRUE || b == JS_FALSE);
 84755:     l.asBits = ((uint64_t)(uint32_t)b) | JSVAL_SHIFTED_TAG_BOOLEAN;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 53557: JSVAL_IS_MAGIC_IMPL(jsval_layout l)
 53557: {
 53557:     return (l.asBits >> JSVAL_TAG_SHIFT) == JSVAL_TAG_MAGIC;
 53557: }
 53557: 
 53557: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_PRIMITIVE_IMPL(jsval_layout l)
 48470: {
 48470:     return l.asBits < JSVAL_UPPER_EXCL_SHIFTED_TAG_OF_PRIMITIVE_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_OBJECT_IMPL(jsval_layout l)
 48470: {
 48470:     JS_ASSERT((l.asBits >> JSVAL_TAG_SHIFT) <= JSVAL_SHIFTED_TAG_OBJECT);
 48470:     return l.asBits >= JSVAL_SHIFTED_TAG_OBJECT;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_OBJECT_OR_NULL_IMPL(jsval_layout l)
 48470: {
 48470:     JS_ASSERT((l.asBits >> JSVAL_TAG_SHIFT) <= JSVAL_TAG_OBJECT);
 48470:     return l.asBits >= JSVAL_LOWER_INCL_SHIFTED_TAG_OF_OBJ_OR_NULL_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSObject *
 48470: JSVAL_TO_OBJECT_IMPL(jsval_layout l)
 48470: {
 84755:     uint64_t ptrBits = l.asBits & JSVAL_PAYLOAD_MASK;
 48470:     JS_ASSERT((ptrBits & 0x7) == 0);
 48470:     return (JSObject *)ptrBits;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: OBJECT_TO_JSVAL_IMPL(JSObject *obj)
 48470: {
 48470:     jsval_layout l;
 84755:     uint64_t objBits = (uint64_t)obj;
 53557:     JS_ASSERT(obj);
 48470:     JS_ASSERT((objBits >> JSVAL_TAG_SHIFT) == 0);
 48470:     l.asBits = objBits | JSVAL_SHIFTED_TAG_OBJECT;
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_NULL_IMPL(jsval_layout l)
 48470: {
 48470:     return l.asBits == JSVAL_SHIFTED_TAG_NULL;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_GCTHING_IMPL(jsval_layout l)
 48470: {
 48470:     return l.asBits >= JSVAL_LOWER_INCL_SHIFTED_TAG_OF_GCTHING_SET;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE void *
 48470: JSVAL_TO_GCTHING_IMPL(jsval_layout l)
 48470: {
 84755:     uint64_t ptrBits = l.asBits & JSVAL_PAYLOAD_MASK;
 48470:     JS_ASSERT((ptrBits & 0x7) == 0);
 48470:     return (void *)ptrBits;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE JSBool
 48470: JSVAL_IS_TRACEABLE_IMPL(jsval_layout l)
 48470: {
 48470:     return JSVAL_IS_GCTHING_IMPL(l) && !JSVAL_IS_NULL_IMPL(l);
 48470: }
 48470: 
 84755: static JS_ALWAYS_INLINE uint32_t
 48470: JSVAL_TRACE_KIND_IMPL(jsval_layout l)
 48470: {
 84755:     return (uint32_t)(JSBool)!(JSVAL_IS_OBJECT_IMPL(l));
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE jsval_layout
 48470: PRIVATE_PTR_TO_JSVAL_IMPL(void *ptr)
 48470: {
 48470:     jsval_layout l;
 84755:     uint64_t ptrBits = (uint64_t)ptr;
 48470:     JS_ASSERT((ptrBits & 1) == 0);
 48470:     l.asBits = ptrBits >> 1;
 48470:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
 48470:     return l;
 48470: }
 48470: 
 48470: static JS_ALWAYS_INLINE void *
 48470: JSVAL_TO_PRIVATE_PTR_IMPL(jsval_layout l)
 48470: {
 48470:     JS_ASSERT((l.asBits & 0x8000000000000000LL) == 0);
 48470:     return (void *)(l.asBits << 1);
 48470: }
 48470: 
 78613: static JS_ALWAYS_INLINE JSBool
 84755: JSVAL_IS_SPECIFIC_INT32_IMPL(jsval_layout l, int32_t i32)
 78613: {
 84755:     return l.asBits == (((uint64_t)(uint32_t)i32) | JSVAL_SHIFTED_TAG_INT32);
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE JSBool
 78613: JSVAL_IS_SPECIFIC_BOOLEAN(jsval_layout l, JSBool b)
 78613: {
 84755:     return l.asBits == (((uint64_t)(uint32_t)b) | JSVAL_SHIFTED_TAG_BOOLEAN);
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE jsval_layout
 78613: MAGIC_TO_JSVAL_IMPL(JSWhyMagic why)
 78613: {
 78613:     jsval_layout l;
 84755:     l.asBits = ((uint64_t)(uint32_t)why) | JSVAL_SHIFTED_TAG_MAGIC;
 78613:     return l;
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE JSBool
 78613: JSVAL_SAME_TYPE_IMPL(jsval_layout lhs, jsval_layout rhs)
 78613: {
 84755:     uint64_t lbits = lhs.asBits, rbits = rhs.asBits;
 78613:     return (lbits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE && rbits <= JSVAL_SHIFTED_TAG_MAX_DOUBLE) ||
 78613:            (((lbits ^ rbits) & 0xFFFF800000000000LL) == 0);
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE jsval_layout
 84755: PRIVATE_UINT32_TO_JSVAL_IMPL(uint32_t ui)
 78613: {
 78613:     jsval_layout l;
 84755:     l.asBits = (uint64_t)ui;
 78613:     JS_ASSERT(JSVAL_IS_DOUBLE_IMPL(l));
 78613:     return l;
 78613: }
 78613: 
 84755: static JS_ALWAYS_INLINE uint32_t
 78613: JSVAL_TO_PRIVATE_UINT32_IMPL(jsval_layout l)
 78613: {
 78613:     JS_ASSERT((l.asBits >> 32) == 0);
 84755:     return (uint32_t)l.asBits;
 78613: }
 78613: 
 78613: static JS_ALWAYS_INLINE JSValueType
 78613: JSVAL_EXTRACT_NON_DOUBLE_TYPE_IMPL(jsval_layout l)
 78613: {
 84755:    uint64_t type = (l.asBits >> JSVAL_TAG_SHIFT) & 0xF;
 78613:    JS_ASSERT(type > JSVAL_TYPE_DOUBLE);
 78613:    return (JSValueType)type;
 78613: }
 78613: 
 78613: #endif  /* JS_BITS_PER_WORD */
 78613: 
 49081: static JS_ALWAYS_INLINE double
 49081: JS_CANONICALIZE_NAN(double d)
 49081: {
 49081:     if (JS_UNLIKELY(d != d)) {
 49081:         jsval_layout l;
 49081:         l.asBits = 0x7FF8000000000000LL;
 49081:         return l.asDouble;
 49081:     }
 49081:     return d;
 49081: }
 49081: 
 78613: JS_END_EXTERN_C
 78613: 
 78613: #ifdef __cplusplus
 78613: static jsval_layout JSVAL_TO_IMPL(JS::Value);
 78613: static JS::Value IMPL_TO_JSVAL(jsval_layout);
 48470: #endif
 48470: 
 48470: #endif /* jsvalimpl_h__ */
