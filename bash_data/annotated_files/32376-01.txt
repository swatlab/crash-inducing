    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Masatoshi Kimura <VYV03354@nifty.ne.jp>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxWindowsSurface.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: 
26915: #include "nsIPrefService.h"
26915: #include "nsIPrefBranch2.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
    1: 
    1: #include "nsIWindowsRegKey.h"
19962: #include "nsILocalFile.h"
19962: #include "plbase64.h"
    1: 
24104: #ifdef MOZ_FT2_FONTS
24104: #include "ft2build.h"
24104: #include FT_FREETYPE_H
24104: #include "gfxFT2Fonts.h"
24104: #include "cairo-ft.h"
31344: #include "nsAppDirectoryServiceDefs.h"
24104: #else
  270: #include "gfxWindowsFonts.h"
24104: #endif
24104: 
30086: /*XXX to get CAIRO_HAS_DDRAW_SURFACE */
30086: #include "cairo.h"
30086: 
24104: #ifdef WINCE
24104: #include <shlwapi.h>
30086: 
30086: #ifdef CAIRO_HAS_DDRAW_SURFACE
30086: #include "gfxDDrawSurface.h"
30086: #endif
24104: #endif
24104: 
19962: #include "gfxUserFontSet.h"
  270: 
    1: #include <string>
    1: 
24104: #ifdef MOZ_FT2_FONTS
24104: static FT_Library gPlatformFTLibrary = NULL;
24104: #endif
 1959: 
13877: // font info loader constants
13877: static const PRUint32 kDelayBeforeLoadingCmaps = 8 * 1000; // 8secs
13877: static const PRUint32 kIntervalBetweenLoadingCmaps = 150; // 150ms
13877: static const PRUint32 kNumFontsPerSlice = 10; // read in info 10 fonts at a time
13877: 
13578: static __inline void
13578: BuildKeyNameFromFontName(nsAString &aName)
13578: {
13578:     if (aName.Length() >= LF_FACESIZE)
13578:         aName.Truncate(LF_FACESIZE - 1);
13578:     ToLowerCase(aName);
13578: }
13280: 
26915: class gfxWindowsPlatformPrefObserver : public nsIObserver {
26915: public:
26915:     NS_DECL_ISUPPORTS
26915:     NS_DECL_NSIOBSERVER
26915: };
26915: 
26915: NS_IMPL_ISUPPORTS1(gfxWindowsPlatformPrefObserver, nsIObserver)
26915: 
26915: NS_IMETHODIMP
26915: gfxWindowsPlatformPrefObserver::Observe(nsISupports     *aSubject,
26915:                                         const char      *aTopic,
26915:                                         const PRUnichar *aData)
 5254: {
26915:     NS_ASSERTION(!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID), "invalid topic");
 5259:     // XXX this could be made to only clear out the cache for the prefs that were changed
 5259:     // but it probably isn't that big a deal.
26915:     gfxWindowsPlatform::GetPlatform()->ClearPrefFonts();
26915:     return NS_OK;
 5254: }
 1959: 
    1: gfxWindowsPlatform::gfxWindowsPlatform()
13877:     : mStartIndex(0), mIncrement(kNumFontsPerSlice), mNumFamilies(0)
    1: {
    1:     mFonts.Init(200);
    1:     mFontAliases.Init(20);
    1:     mFontSubstitutes.Init(50);
 5254:     mPrefFonts.Init(10);
 5254: 
24104: #ifdef MOZ_FT2_FONTS
24104:     FT_Init_FreeType(&gPlatformFTLibrary);
24104: #else
24104:     FontEntry::InitializeFontEmbeddingProcs();
24104: #endif
24104: 
    1:     UpdateFontList();
 5254: 
30087:     nsCOMPtr<nsIPrefBranch2> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
30087: 
30087:     if (pref) {
26915:         gfxWindowsPlatformPrefObserver *observer = new gfxWindowsPlatformPrefObserver();
26915:         if (observer) {
26915:             pref->AddObserver("font.", observer, PR_FALSE);
26915:             pref->AddObserver("font.name-list.", observer, PR_FALSE);
26915:             pref->AddObserver("intl.accept_languages", observer, PR_FALSE);
 5254:             // don't bother unregistering.  We'll get shutdown after the pref service
30087:         }
30087:     }
30087: 
30087: /* Pick the default render mode differently between
30087:  * desktop, Windows Mobile, and Windows CE.
30087:  */
30087: #if defined(WINCE_WINDOWS_MOBILE)
30087:     mRenderMode = RENDER_IMAGE_DDRAW16;
30087: #elif defined(WINCE)
30087:     mRenderMode = RENDER_DDRAW_GL;
30087: #else
30087:     mRenderMode = RENDER_GDI;
30087: #endif
30087: 
30087:     PRInt32 rmode;
30087:     if (NS_SUCCEEDED(pref->GetIntPref("mozilla.widget.render-mode", &rmode))) {
30087:         if (rmode >= 0 || rmode < RENDER_MODE_MAX) {
30087: #ifndef CAIRO_HAS_DDRAW_SURFACE
30087:             if (rmode == RENDER_DDRAW || rmode == RENDER_DDRAW_GL)
30087:                 rmode = RENDER_IMAGE_STRETCH24;
30087: #endif
30087:             mRenderMode = (RenderMode) rmode;
26915:         }
26915:     }
    1: }
    1: 
    1: gfxWindowsPlatform::~gfxWindowsPlatform()
    1: {
24104:     // not calling FT_Done_FreeType because cairo may still hold references to
24104:     // these FT_Faces.  See bug 458169.
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: gfxWindowsPlatform::CreateOffscreenSurface(const gfxIntSize& size,
    1:                                            gfxASurface::gfxImageFormat imageFormat)
    1: {
30087:     gfxASurface *surf = nsnull;
30087: 
30086: #ifdef CAIRO_HAS_DDRAW_SURFACE
30087:     if (mRenderMode == RENDER_DDRAW || mRenderMode == RENDER_DDRAW_GL)
30087:         surf = new gfxDDrawSurface(NULL, size, imageFormat);
23691: #endif
30087: 
30087: #ifdef CAIRO_HAS_WIN32_SURFACE
30087:     if (mRenderMode == RENDER_GDI)
30087:         surf = new gfxWindowsSurface(size, imageFormat);
30086: #endif
30087: 
30087:     if (surf == nsnull)
30087:         surf = new gfxImageSurface(size, imageFormat);
30087: 
    1:     NS_IF_ADDREF(surf);
30087: 
    1:     return surf;
    1: }
    1: 
    1: int CALLBACK 
    1: gfxWindowsPlatform::FontEnumProc(const ENUMLOGFONTEXW *lpelfe,
    1:                                  const NEWTEXTMETRICEXW *nmetrics,
    1:                                  DWORD fontType, LPARAM data)
    1: {
13280:     FontTable *ht = reinterpret_cast<FontTable*>(data);
    1: 
    1:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
13578:     const LOGFONTW& logFont = lpelfe->elfLogFont;
13280: 
13280:     // Ignore vertical fonts
13578:     if (logFont.lfFaceName[0] == L'@')
13280:         return 1;
    1: 
13578:     nsAutoString name(logFont.lfFaceName);
13578:     BuildKeyNameFromFontName(name);
    1: 
13280:     nsRefPtr<FontFamily> ff;
13280:     if (!ht->Get(name, &ff)) {
13280:         ff = new FontFamily(nsDependentString(logFont.lfFaceName));
13280:         ht->Put(name, ff);
13280:     }
13280: 
    1:     return 1;
    1: }
    1: 
13578: 
13574: // general cmap reading routines moved to gfxFontUtils.cpp
13570: 
    1: struct FontListData {
23904:     FontListData(const nsACString& aLangGroup, const nsACString& aGenericFamily, nsTArray<nsString>& aListOfFonts) :
    1:         mLangGroup(aLangGroup), mGenericFamily(aGenericFamily), mStringArray(aListOfFonts) {}
    1:     const nsACString& mLangGroup;
    1:     const nsACString& mGenericFamily;
23904:     nsTArray<nsString>& mStringArray;
    1: };
    1: 
20261: PLDHashOperator
    1: gfxWindowsPlatform::HashEnumFunc(nsStringHashKey::KeyType aKey,
13280:                                  nsRefPtr<FontFamily>& aFontFamily,
    1:                                  void* userArg)
    1: {
    1:     FontListData *data = (FontListData*)userArg;
    1: 
13280:     // use the first variation for now.  This data should be the same
13280:     // for all the variations and should probably be moved up to
13280:     // the Family
13578:     gfxFontStyle style;
13578:     style.langGroup = data->mLangGroup;
13578:     nsRefPtr<FontEntry> aFontEntry = aFontFamily->FindFontEntry(style);
25720:     NS_ASSERTION(aFontEntry, "couldn't find any font entry in family");
25720:     if (!aFontEntry)
25720:         return PL_DHASH_NEXT;
13280: 
25123: 
25123: #ifndef MOZ_FT2_FONTS
 2773:     /* skip symbol fonts */
 2773:     if (aFontEntry->mSymbolFont)
 2773:         return PL_DHASH_NEXT;
 2773: 
    1:     if (aFontEntry->SupportsLangGroup(data->mLangGroup) &&
    1:         aFontEntry->MatchesGenericFamily(data->mGenericFamily))
24104: #endif
26309:     data->mStringArray.AppendElement(aFontFamily->Name());
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::GetFontList(const nsACString& aLangGroup,
    1:                                 const nsACString& aGenericFamily,
23904:                                 nsTArray<nsString>& aListOfFonts)
    1: {
    1:     FontListData data(aLangGroup, aGenericFamily, aListOfFonts);
    1: 
    1:     mFonts.Enumerate(gfxWindowsPlatform::HashEnumFunc, &data);
    1: 
    1:     aListOfFonts.Sort();
    1:     aListOfFonts.Compact();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: static void
    1: RemoveCharsetFromFontSubstitute(nsAString &aName)
    1: {
    1:     PRInt32 comma = aName.FindChar(PRUnichar(','));
    1:     if (comma >= 0)
    1:         aName.Truncate(comma);
    1: }
    1: 
24104: #ifdef MOZ_FT2_FONTS
24104: void gfxWindowsPlatform::AppendFacesFromFontFile(const PRUnichar *aFileName) {
24104:     char fileName[MAX_PATH];
24104:     WideCharToMultiByte(CP_ACP, 0, aFileName, -1, fileName, MAX_PATH, NULL, NULL);
24104:     FT_Face dummy;
24104:     if (FT_Err_Ok == FT_New_Face(GetFTLibrary(), fileName, -1, &dummy)) {
24104:         for (FT_Long i = 0; i < dummy->num_faces; i++) {
24104:             FT_Face face;
24104:             if (FT_Err_Ok != FT_New_Face(GetFTLibrary(), fileName, 
24104:                                          i, &face))
24104:                 continue;
24104: 
24104:             FontEntry* fe = FontEntry::CreateFontEntryFromFace(face);
24104:             if (fe) {
24104:                 NS_ConvertUTF8toUTF16 name(face->family_name);
24104:                 BuildKeyNameFromFontName(name);       
24104:                 nsRefPtr<FontFamily> ff;
24104:                 if (!mFonts.Get(name, &ff)) {
24104:                     ff = new FontFamily(name);
24104:                     mFonts.Put(name, ff);
24104:                 }
31591:                 ff->AddFontEntry(fe);
31590:                 ff->SetHasStyles(PR_TRUE);
24104:             }
24104:         }
24104:         FT_Done_Face(dummy);
24104:     }
24104: }
24104: 
24104: void
24104: gfxWindowsPlatform::FindFonts()
24104: {
31344:     nsTArray<nsString> searchPaths(3);
27499:     nsTArray<nsString> fontPatterns(3);
24104:     fontPatterns.AppendElement(NS_LITERAL_STRING("\\*.ttf"));
27499:     fontPatterns.AppendElement(NS_LITERAL_STRING("\\*.ttc"));
24104:     fontPatterns.AppendElement(NS_LITERAL_STRING("\\*.otf"));
24104:     wchar_t pathBuf[256];
24104:     SHGetSpecialFolderPathW(0, pathBuf, CSIDL_WINDOWS, 0);
24104:     searchPaths.AppendElement(pathBuf);
24104:     SHGetSpecialFolderPathW(0, pathBuf, CSIDL_FONTS, 0);
24104:     searchPaths.AppendElement(pathBuf);
31344:     nsCOMPtr<nsIFile> resDir;
31344:     NS_GetSpecialDirectory(NS_APP_RES_DIR, getter_AddRefs(resDir));
31344:     if (resDir) {
31344:         resDir->Append(NS_LITERAL_STRING("fonts"));
31350:         nsAutoString resPath;
31344:         resDir->GetPath(resPath);
31344:         searchPaths.AppendElement(resPath);
31344:     }
24104:     WIN32_FIND_DATAW results;
24104:     for (PRUint32 i = 0;  i < searchPaths.Length(); i++) {
24104:         const nsString& path(searchPaths[i]);
24104:         for (PRUint32 j = 0; j < fontPatterns.Length(); j++) { 
24104:             nsAutoString pattern(path);
24104:             pattern.Append(fontPatterns[j]);
27282:             HANDLE handle = FindFirstFileExW(pattern.get(),
27282:                                              FindExInfoStandard,
27282:                                              &results,
27282:                                              FindExSearchNameMatch,
27282:                                              NULL,
27282:                                              0);
24104:             PRBool moreFiles = handle != INVALID_HANDLE_VALUE;
24104:             while (moreFiles) {
24104:                 nsAutoString filePath(path);
24104:                 filePath.AppendLiteral("\\");
24104:                 filePath.Append(results.cFileName);
24104:                 AppendFacesFromFontFile(static_cast<const PRUnichar*>(filePath.get()));
24104:                 moreFiles = FindNextFile(handle, &results);
24104:             }
27283:             if (handle != INVALID_HANDLE_VALUE)
27283:                 FindClose(handle);
24104:         }
24104:     }
24104: }
24104: 
24104: #endif
24104: 
24104: 
    1: nsresult
    1: gfxWindowsPlatform::UpdateFontList()
    1: {
13446:     gfxFontCache *fc = gfxFontCache::GetCache();
13446:     if (fc)
13446:         fc->AgeAllGenerations();
    1:     mFonts.Clear();
    1:     mFontAliases.Clear();
    1:     mNonExistingFonts.Clear();
    1:     mFontSubstitutes.Clear();
 5254:     mPrefFonts.Clear();
12526:     mCodepointsWithNoFonts.reset();
13877:     CancelLoader();
24104: #ifdef MOZ_FT2_FONTS
24104:     FindFonts();
24104: #else    
    1:     LOGFONTW logFont;
    1:     logFont.lfCharSet = DEFAULT_CHARSET;
    1:     logFont.lfFaceName[0] = 0;
    1:     logFont.lfPitchAndFamily = 0;
    1: 
    1:     // Use the screen DC here.. should we use something else for printing?
    1:     HDC dc = ::GetDC(nsnull);
13280:     EnumFontFamiliesExW(dc, &logFont, (FONTENUMPROCW)gfxWindowsPlatform::FontEnumProc, (LPARAM)&mFonts, 0);
    1:     ::ReleaseDC(nsnull, dc);
24104: #endif
13877:     // initialize the cmap loading process after font list has been initialized
13877:     StartLoader(kDelayBeforeLoadingCmaps, kIntervalBetweenLoadingCmaps); 
13877: 
    1:     // Create the list of FontSubstitutes
 1959:     nsCOMPtr<nsIWindowsRegKey> regKey = do_CreateInstance("@mozilla.org/windows-registry-key;1");
    1:     if (!regKey)
    1:         return NS_ERROR_FAILURE;
 1959:      NS_NAMED_LITERAL_STRING(kFontSubstitutesKey, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
    1: 
 1959:     nsresult rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
    1:                                kFontSubstitutesKey, nsIWindowsRegKey::ACCESS_READ);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 count;
    1:     rv = regKey->GetValueCount(&count);
    1:     if (NS_FAILED(rv) || count == 0)
    1:         return rv;
    1:     for (PRUint32 i = 0; i < count; i++) {
    1:         nsAutoString substituteName;
    1:         rv = regKey->GetValueName(i, substituteName);
    1:         if (NS_FAILED(rv) || substituteName.IsEmpty() ||
    1:             substituteName.CharAt(1) == PRUnichar('@'))
    1:             continue;
    1:         PRUint32 valueType;
    1:         rv = regKey->GetValueType(substituteName, &valueType);
    1:         if (NS_FAILED(rv) || valueType != nsIWindowsRegKey::TYPE_STRING)
    1:             continue;
    1:         nsAutoString actualFontName;
    1:         rv = regKey->ReadStringValue(substituteName, actualFontName);
    1:         if (NS_FAILED(rv))
    1:             continue;
    1: 
    1:         RemoveCharsetFromFontSubstitute(substituteName);
    1:         BuildKeyNameFromFontName(substituteName);
    1:         RemoveCharsetFromFontSubstitute(actualFontName);
    1:         BuildKeyNameFromFontName(actualFontName);
13280:         nsRefPtr<FontFamily> ff;
13280:         if (!actualFontName.IsEmpty() && mFonts.Get(actualFontName, &ff))
13280:             mFontSubstitutes.Put(substituteName, ff);
    1:         else
23904:             mNonExistingFonts.AppendElement(substituteName);
    1:     }
    1: 
12526:     // initialize ranges of characters for which system-wide font search should be skipped
12526:     mCodepointsWithNoFonts.SetRange(0,0x1f);     // C0 controls
12526:     mCodepointsWithNoFonts.SetRange(0x7f,0x9f);  // C1 controls
12526: 
12989:     InitBadUnderlineList();
12989: 
    1:     return NS_OK;
    1: }
    1: 
13877: struct FontFamilyListData {
13877:     FontFamilyListData(nsTArray<nsRefPtr<FontFamily> >& aFamilyArray) 
13877:         : mFamilyArray(aFamilyArray)
13877:     {}
13877: 
20261:     static PLDHashOperator AppendFamily(nsStringHashKey::KeyType aKey,
13877:                                         nsRefPtr<FontFamily>& aFamilyEntry,
13877:                                         void *aUserArg)
13877:     {
13877:         FontFamilyListData *data = (FontFamilyListData*)aUserArg;
13877:         data->mFamilyArray.AppendElement(aFamilyEntry);
13877:         return PL_DHASH_NEXT;
13877:     }
13877: 
13877:     nsTArray<nsRefPtr<FontFamily> >& mFamilyArray;
13877: };
13877: 
13877: void
13877: gfxWindowsPlatform::GetFontFamilyList(nsTArray<nsRefPtr<FontFamily> >& aFamilyArray)
13877: {
13877:     FontFamilyListData data(aFamilyArray);
13877:     mFonts.Enumerate(FontFamilyListData::AppendFamily, &data);
13877: }
13877: 
12989: static PRBool SimpleResolverCallback(const nsAString& aName, void* aClosure)
12989: {
12989:     nsString *result = static_cast<nsString*>(aClosure);
12989:     result->Assign(aName);
12989:     return PR_FALSE;
12989: }
12989: 
12989: void
12989: gfxWindowsPlatform::InitBadUnderlineList()
12989: {
24104: // Only windows fonts have mIsBadUnderlineFontFamily flag
24104: #ifndef MOZ_FT2_FONTS
14457:     nsAutoTArray<nsString, 10> blacklist;
12989:     gfxFontUtils::GetPrefsFontList("font.blacklist.underline_offset", blacklist);
12989:     PRUint32 numFonts = blacklist.Length();
12989:     for (PRUint32 i = 0; i < numFonts; i++) {
12989:         PRBool aborted;
12989:         nsAutoString resolved;
12989:         ResolveFontName(blacklist[i], SimpleResolverCallback, &resolved, aborted);
12989:         if (resolved.IsEmpty())
12989:             continue;
13280:         FontFamily *ff = FindFontFamily(resolved);
13280:         if (!ff)
12989:             continue;
19962:         ff->mIsBadUnderlineFontFamily = 1;
12989:     }
24104: #endif
13280: }
12989: 
13003: nsresult
13003: gfxWindowsPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
13003: {
13003:     aFamilyName.Truncate();
13003:     PRBool aborted;
13003:     return ResolveFontName(aFontName, SimpleResolverCallback, &aFamilyName, aborted);
13003: }
13003: 
    1: struct ResolveData {
    1:     ResolveData(gfxPlatform::FontResolverCallback aCallback,
    1:                 gfxWindowsPlatform *aCaller, const nsAString *aFontName,
    1:                 void *aClosure) :
    1:         mFoundCount(0), mCallback(aCallback), mCaller(aCaller),
    1:         mFontName(aFontName), mClosure(aClosure) {}
    1:     PRUint32 mFoundCount;
    1:     gfxPlatform::FontResolverCallback mCallback;
    1:     gfxWindowsPlatform *mCaller;
    1:     const nsAString *mFontName;
    1:     void *mClosure;
    1: };
    1: 
    1: nsresult
    1: gfxWindowsPlatform::ResolveFontName(const nsAString& aFontName,
    1:                                     FontResolverCallback aCallback,
    1:                                     void *aClosure,
    1:                                     PRBool& aAborted)
    1: {
    1:     if (aFontName.IsEmpty())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsAutoString keyName(aFontName);
    1:     BuildKeyNameFromFontName(keyName);
    1: 
13280:     nsRefPtr<FontFamily> ff;
13280:     if (mFonts.Get(keyName, &ff) ||
13280:         mFontSubstitutes.Get(keyName, &ff) ||
13280:         mFontAliases.Get(keyName, &ff)) {
26309:         aAborted = !(*aCallback)(ff->Name(), aClosure);
    1:         // XXX If the font has font link, we should add the linked font.
    1:         return NS_OK;
    1:     }
    1: 
23904:     if (mNonExistingFonts.Contains(keyName)) {
    1:         aAborted = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     LOGFONTW logFont;
    1:     logFont.lfCharSet = DEFAULT_CHARSET;
    1:     logFont.lfPitchAndFamily = 0;
    1:     PRInt32 len = aFontName.Length();
    1:     if (len >= LF_FACESIZE)
    1:         len = LF_FACESIZE - 1;
    1:     memcpy(logFont.lfFaceName,
    1:            nsPromiseFlatString(aFontName).get(), len * sizeof(PRUnichar));
    1:     logFont.lfFaceName[len] = 0;
    1: 
    1:     HDC dc = ::GetDC(nsnull);
    1:     ResolveData data(aCallback, this, &keyName, aClosure);
13280:     aAborted = !EnumFontFamiliesExW(dc, &logFont,
    1:                                     (FONTENUMPROCW)gfxWindowsPlatform::FontResolveProc,
    1:                                     (LPARAM)&data, 0);
    1:     if (data.mFoundCount == 0)
23904:         mNonExistingFonts.AppendElement(keyName);
    1:     ::ReleaseDC(nsnull, dc);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: int CALLBACK 
    1: gfxWindowsPlatform::FontResolveProc(const ENUMLOGFONTEXW *lpelfe,
    1:                                     const NEWTEXTMETRICEXW *nmetrics,
    1:                                     DWORD fontType, LPARAM data)
    1: {
    1:     const LOGFONTW& logFont = lpelfe->elfLogFont;
    1:     // Ignore vertical fonts
    1:     if (logFont.lfFaceName[0] == L'@' || logFont.lfFaceName[0] == 0)
    1:         return 1;
    1: 
    1:     ResolveData *rData = reinterpret_cast<ResolveData*>(data);
    1: 
    1:     nsAutoString name(logFont.lfFaceName);
    1: 
    1:     // Save the alias name to cache
13280:     nsRefPtr<FontFamily> ff;
    1:     nsAutoString keyName(name);
    1:     BuildKeyNameFromFontName(keyName);
13280:     if (!rData->mCaller->mFonts.Get(keyName, &ff)) {
    1:         // This case only occurs on failing to build
    1:         // the list of font substitue. In this case, the user should
    1:         // reboot the Windows. Probably, we don't have the good way for
    1:         // resolving in this time.
    1:         NS_WARNING("Cannot find actual font");
    1:         return 1;
    1:     }
    1: 
    1:     rData->mFoundCount++;
13280:     rData->mCaller->mFontAliases.Put(*(rData->mFontName), ff);
    1: 
    1:     return (rData->mCallback)(name, rData->mClosure);
    1: 
    1:     // XXX If the font has font link, we should add the linked font.
    1: }
    1: 
20261: PLDHashOperator
12526: gfxWindowsPlatform::FindFontForCharProc(nsStringHashKey::KeyType aKey,
13280:                                         nsRefPtr<FontFamily>& aFontFamily,
    1:                                         void* userArg)
    1: {
13340:     FontSearch *data = (FontSearch*)userArg;
13280: 
32342: #ifdef MOZ_FT2_FONTS
32342:     aFontFamily->FindFontForChar(data);
32342: #else
31590:     const PRUint32 ch = data->mCh;
13340: 
31590:     nsRefPtr<FontEntry> fe = aFontFamily->FindFontEntry(*data->mFontToMatch->GetStyle());
25720:     NS_ASSERTION(fe, "couldn't find any font entry in family");
25720:     if (!fe)
25720:         return PL_DHASH_NEXT;
25720: 
32376:     // initialize rank to 1 so that any match is better than the initial
32376:     // value of data->mMatchRank (zero); therefore the first font that
32376:     // passes the mCharacterMap.test() will become the mBestMatch until
32376:     // a better entry is found
32376:     PRInt32 rank = 1;
13340: 
13340:     // skip over non-unicode and bitmap fonts and fonts that don't have
13340:     // the code point we're looking for
13340:     if (fe->IsCrappyFont() || !fe->mCharacterMap.test(ch))
    1:         return PL_DHASH_NEXT;
    1: 
 1959:     // fonts that claim to support the range are more
 1959:     // likely to be "better fonts" than ones that don't... (in theory)
13280:     if (fe->SupportsRange(gfxFontUtils::CharRangeBit(ch)))
 1959:         rank += 1;
 1959: 
31590:     if (fe->SupportsLangGroup(data->mFontToMatch->GetStyle()->langGroup))
13340:         rank += 2;
 1959: 
31590:     FontEntry* mfe = static_cast<FontEntry*>(data->mFontToMatch->GetFontEntry());
24104: 
24104:     if (fe->mWindowsFamily == mfe->mWindowsFamily)
13340:         rank += 3;
24104:     if (fe->mWindowsPitch == mfe->mWindowsPitch)
13340:         rank += 3;
32342: 
13280:     /* italic */
31590:     const PRBool italic = (data->mFontToMatch->GetStyle()->style != FONT_STYLE_NORMAL);
13340:     if (fe->mItalic != italic)
13340:         rank += 3;
13280: 
 1959:     /* weight */
 1959:     PRInt8 baseWeight, weightDistance;
31590:     data->mFontToMatch->GetStyle()->ComputeWeightAndOffset(&baseWeight, &weightDistance);
13340:     if (fe->mWeight == (baseWeight * 100) + (weightDistance * 100))
13340:         rank += 2;
31590:     else if (fe->mWeight == data->mFontToMatch->GetFontEntry()->mWeight)
13340:         rank += 1;
 1959: 
31590:     if (rank > data->mMatchRank ||
31590:         (rank == data->mMatchRank && Compare(fe->Name(), data->mBestMatch->Name()) > 0)) {
31590:         data->mBestMatch = fe;
31590:         data->mMatchRank = rank;
    1:     }
32342: #endif
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
24104: already_AddRefed<gfxFont>
24104: gfxWindowsPlatform::FindFontForChar(PRUint32 aCh, gfxFont *aFont)
 1943: {
12526:     // is codepoint with no matching font? return null immediately
12526:     if (mCodepointsWithNoFonts.test(aCh)) {
12526:         return nsnull;
12526:     }
12526: 
12526:     FontSearch data(aCh, aFont);
 1940: 
 1959:     // find fonts that support the character
12526:     mFonts.Enumerate(gfxWindowsPlatform::FindFontForCharProc, &data);
12526: 
31590:     if (data.mBestMatch) {
24104: #ifdef MOZ_FT2_FONTS
24104:         nsRefPtr<gfxFT2Font> font =
32342:             gfxFT2Font::GetOrMakeFont(static_cast<FontEntry*>(data.mBestMatch.get()), 
24104:                                       aFont->GetStyle()); 
24104:         gfxFont* ret = font.forget().get();
24104:         return already_AddRefed<gfxFont>(ret);
24104: #else
14798:         nsRefPtr<gfxWindowsFont> font =
31590:             gfxWindowsFont::GetOrMakeFont(static_cast<FontEntry*>(data.mBestMatch.get()),
31590:                                           aFont->GetStyle());
24104:         if (font->IsValid()) {
24104:             gfxFont* ret = font.forget().get();
24104:             return already_AddRefed<gfxFont>(ret);
24104:         }
24104: #endif
14798:         return nsnull;
12526:     }
14798:     // no match? add to set of non-matching codepoints
14798:     mCodepointsWithNoFonts.set(aCh);
14798:     return nsnull;
    1: }
  270: 
  270: gfxFontGroup *
  270: gfxWindowsPlatform::CreateFontGroup(const nsAString &aFamilies,
19962:                                     const gfxFontStyle *aStyle,
19962:                                     gfxUserFontSet *aUserFontSet)
  270: {
24104: #ifdef MOZ_FT2_FONTS
24104:     return new gfxFT2FontGroup(aFamilies, aStyle);
24104: #else
19962:     return new gfxWindowsFontGroup(aFamilies, aStyle, aUserFontSet);
24104: #endif
19962: }
19962: 
19962: 
19962: struct FullFontNameSearch {
19962:     FullFontNameSearch(const nsAString& aFullName)
19962:         : mFound(PR_FALSE), mFullName(aFullName), mDC(nsnull), mFontEntry(nsnull)
19962:     { }
19962: 
19962:     PRPackedBool mFound;
19962:     nsString     mFullName;
19962:     nsString     mFamilyName;
19962:     HDC          mDC;
19962:     gfxFontEntry *mFontEntry;
19962: };
19962: 
24104: #ifndef MOZ_FT2_FONTS
19962: // callback called for each face within a single family
19962: // match against elfFullName
19962: 
19962: static int CALLBACK 
19962: FindFullNameForFace(const ENUMLOGFONTEXW *lpelfe,
19962:                     const NEWTEXTMETRICEXW *nmetrics,
19962:                     DWORD fontType, LPARAM userArg)
19962: {
19962:     FullFontNameSearch *data = reinterpret_cast<FullFontNameSearch*>(userArg);
19962: 
19962:     // does the full name match?
19962:     if (!data->mFullName.Equals(nsDependentString(lpelfe->elfFullName)))
19962:         return 1;  // continue
19962: 
19962:     // found match, create a new font entry
19962:     data->mFound = PR_TRUE;
19962: 
19962:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
19962:     LOGFONTW logFont = lpelfe->elfLogFont;
19962: 
19962:     // Some fonts claim to support things > 900, but we don't so clamp the sizes
19962:     logFont.lfWeight = PR_MAX(PR_MIN(logFont.lfWeight, 900), 100);
19962: 
19962:     gfxWindowsFontType feType = FontEntry::DetermineFontType(metrics, fontType);
19962: 
19962:     data->mFontEntry = FontEntry::CreateFontEntry(data->mFamilyName, feType, (logFont.lfItalic == 0xFF), (PRUint16) (logFont.lfWeight), nsnull, data->mDC, &logFont);
19962: 
19962:     return 0;  // stop iteration
19962: }
24104: #endif
19962: 
19962: // callback called for each family name, based on the assumption that the 
19962: // first part of the full name is the family name
19962: 
20705: static PLDHashOperator
19962: FindFullName(nsStringHashKey::KeyType aKey,
19962:              nsRefPtr<FontFamily>& aFontFamily,
19962:              void* userArg)
19962: {
19962:     FullFontNameSearch *data = reinterpret_cast<FullFontNameSearch*>(userArg);
19962: 
19962:     // does the family name match up to the length of the family name?
19962:     const nsString& family = aFontFamily->Name();
19962:     
19962:     nsString fullNameFamily;
19962:     data->mFullName.Left(fullNameFamily, family.Length());
19962: 
19962:     // if so, iterate over faces in this family to see if there is a match
19962:     if (family.Equals(fullNameFamily)) {
24104: #ifdef MOZ_FT2_FONTS
31591:         int len = aFontFamily->GetFontList().Length();
24104:         int index = 0;
24104:         for (; index < len && 
31591:                  !aFontFamily->GetFontList()[index]->Name().Equals(data->mFullName); index++);
24104:         if (index < len) {
24104:             data->mFound = PR_TRUE;
31591:             data->mFontEntry = aFontFamily->GetFontList()[index];
24104:         }
24104: #else
19962:         HDC hdc;
19962:         
19962:         if (!data->mDC) {
19962:             data->mDC= GetDC(nsnull);
19962:             SetGraphicsMode(data->mDC, GM_ADVANCED);
19962:         }
19962:         hdc = data->mDC;
19962: 
19962:         LOGFONTW logFont;
19962:         memset(&logFont, 0, sizeof(LOGFONTW));
19962:         logFont.lfCharSet = DEFAULT_CHARSET;
19962:         logFont.lfPitchAndFamily = 0;
19962:         PRUint32 l = PR_MIN(family.Length(), LF_FACESIZE - 1);
19962:         memcpy(logFont.lfFaceName,
19962:                nsPromiseFlatString(family).get(),
19962:                l * sizeof(PRUnichar));
19962:         logFont.lfFaceName[l] = 0;
19962:         data->mFamilyName.Assign(family);
19962: 
19962:         EnumFontFamiliesExW(hdc, &logFont, (FONTENUMPROCW)FindFullNameForFace, (LPARAM)data, 0);
24104: #endif
19962:     }
19962: 
19962:     if (data->mFound)
19962:         return PL_DHASH_STOP;
19962: 
19962:     return PL_DHASH_NEXT;
19962: }
19962: 
19962: gfxFontEntry* 
23273: gfxWindowsPlatform::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                     const nsAString& aFontName)
19962: {
26852: #ifdef MOZ_FT2_FONTS
19962:     // walk over list of names
19962:     FullFontNameSearch data(aFontName);
19962: 
19962:     // find fonts that support the character
19962:     mFonts.Enumerate(FindFullName, &data);
19962: 
19962:     if (data.mDC)
19962:         ReleaseDC(nsnull, data.mDC);
19962:     
19962:     return data.mFontEntry;
26852: #else
26852:     return FontEntry::LoadLocalFont(*aProxyEntry, aFontName);
26852: #endif
19962: }
19962: 
19962: gfxFontEntry* 
22397: gfxWindowsPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
22397:                                      nsISupports *aLoader,
21067:                                      const PRUint8 *aFontData, PRUint32 aLength)
19962: {
26853: #ifdef MOZ_FT2_FONTS
26853:     return FontEntry::CreateFontEntry(*aProxyEntry, aLoader, aFontData, aLength);
26853: #else
26852:     return FontEntry::LoadFont(*aProxyEntry, aLoader, aFontData, aLength);
26853: #endif    
19962: }
19962: 
19962: PRBool
19962: gfxWindowsPlatform::IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags)
19962: {
23576:     // check for strange format flags
23576:     NS_ASSERTION(!(aFormatFlags & gfxUserFontSet::FLAG_FORMAT_NOT_USED),
23576:                  "strange font format hint set");
23576: 
23576:     // accept supported formats
23576:     if (aFormatFlags & (gfxUserFontSet::FLAG_FORMAT_OPENTYPE | 
23576:                         gfxUserFontSet::FLAG_FORMAT_TRUETYPE)) {
23576:         return PR_TRUE;
23576:     }
23576: 
23576:     // reject all other formats, known and unknown
23576:     if (aFormatFlags != 0) {
19962:         return PR_FALSE;
19962:     }
19962: 
23576:     // no format hint set, need to look at data
19962:     return PR_TRUE;
  270: }
 1959: 
13280: FontFamily *
13280: gfxWindowsPlatform::FindFontFamily(const nsAString& aName)
 1959: {
13578:     nsAutoString name(aName);
13578:     BuildKeyNameFromFontName(name);
 1959: 
13280:     nsRefPtr<FontFamily> ff;
13280:     if (!mFonts.Get(name, &ff) &&
13280:         !mFontSubstitutes.Get(name, &ff) &&
13280:         !mFontAliases.Get(name, &ff)) {
 1959:         return nsnull;
 1959:     }
13280:     return ff.get();
13280: }
13280: 
13280: FontEntry *
13578: gfxWindowsPlatform::FindFontEntry(const nsAString& aName, const gfxFontStyle& aFontStyle)
13280: {
13280:     nsRefPtr<FontFamily> ff = FindFontFamily(aName);
13280:     if (!ff)
13280:         return nsnull;
13280: 
13578:     return ff->FindFontEntry(aFontStyle);
 1959: }
 3787: 
27035: qcms_profile*
 3787: gfxWindowsPlatform::GetPlatformCMSOutputProfile()
 3787: {
24104: #ifndef MOZ_FT2_FONTS
 3787:     WCHAR str[1024+1];
 3787:     DWORD size = 1024;
 3787: 
 3787:     HDC dc = GetDC(nsnull);
 3787:     GetICMProfileW(dc, &size, (LPWSTR)&str);
 3787:     ReleaseDC(nsnull, dc);
 3787: 
27035:     qcms_profile* profile =
27035:         qcms_profile_from_path(NS_ConvertUTF16toUTF8(str).get());
 3787: #ifdef DEBUG_tor
 3787:     if (profile)
 3787:         fprintf(stderr,
 3787:                 "ICM profile read from %s successfully\n",
 3787:                 NS_ConvertUTF16toUTF8(str).get());
 3787: #endif
 3787:     return profile;
22248: #else
22248:     return nsnull;
22248: #endif
 3787: }
 5254: 
 5254: PRBool
13280: gfxWindowsPlatform::GetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<FontEntry> > *array)
 5254: {
13280:     return mPrefFonts.Get(aKey, array);
 5254: }
 5254: 
 5254: void
13280: gfxWindowsPlatform::SetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<FontEntry> >& array)
 5254: {
13280:     mPrefFonts.Put(aKey, array);
 5254: }
13877: 
13877: void 
13877: gfxWindowsPlatform::InitLoader()
13877: {
13877:     GetFontFamilyList(mFontFamilies);
13877:     mStartIndex = 0;
13877:     mNumFamilies = mFontFamilies.Length();
13877: }
13877: 
13877: PRBool 
13877: gfxWindowsPlatform::RunLoader()
13877: {
13877:     PRUint32 i, endIndex = ( mStartIndex + mIncrement < mNumFamilies ? mStartIndex + mIncrement : mNumFamilies );
13877: 
24104: #ifndef MOZ_FT2_FONTS
13877:     // for each font family, load in various font info
13877:     for (i = mStartIndex; i < endIndex; i++) {
13877:         // load the cmaps for all variations
13877:         mFontFamilies[i]->FindStyleVariations();
13877:     }
24104: #endif
13877:     mStartIndex += mIncrement;
13877:     if (mStartIndex < mNumFamilies)
13877:         return PR_FALSE;
13877:     return PR_TRUE;
13877: }
13877: 
13877: void 
13877: gfxWindowsPlatform::FinishLoader()
13877: {
13877:     mFontFamilies.Clear();
13877:     mNumFamilies = 0;
13877: }
13877: 
24104: #ifdef MOZ_FT2_FONTS
24104: FT_Library
24104: gfxWindowsPlatform::GetFTLibrary()
24104: {
24104:     return gPlatformFTLibrary;
24104: }
24104: #endif
