 36092: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 36166:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 35734: 
 35734: #include "GeckoChildProcessHost.h"
 35734: 
 35734: #include "base/command_line.h"
 35734: #include "base/path_service.h"
 35766: #include "base/string_util.h"
 35734: #include "chrome/common/chrome_switches.h"
 36096: #include "chrome/common/process_watcher.h"
 80376: #ifdef MOZ_WIDGET_COCOA
 52392: #include "chrome/common/mach_ipc_mac.h"
 52392: #include "base/rand_util.h"
 54133: #include "nsILocalFileMac.h"
 52392: #endif
 35734: 
 36016: #include "prprf.h"
 63953: #include "prenv.h"
 36016: 
 37203: #if defined(OS_LINUX)
 37203: #  define XP_LINUX 1
 37203: #endif
 37203: #include "nsExceptionHandler.h"
 37203: 
 40628: #include "nsDirectoryServiceDefs.h"
 40628: #include "nsIFile.h"
 40628: 
 37884: #include "mozilla/ipc/BrowserProcessSubThread.h"
 46923: #include "mozilla/Omnijar.h"
 46920: #include <sys/stat.h>
 35801: 
 42347: #ifdef XP_WIN
 42347: #include "nsIWinTaskbar.h"
 42347: #define NS_TASKBAR_CONTRACTID "@mozilla.org/windows-taskbar;1"
 42347: #endif
 42347: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 56694: #include "APKOpen.h"
 56694: #endif
 56694: 
 69144: using mozilla::MonitorAutoLock;
 35734: using mozilla::ipc::GeckoChildProcessHost;
 35734: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 60942: // Like its predecessor in nsExceptionHandler.cpp, this is
 60942: // the magic number of a file descriptor remapping we must
 60942: // preserve for the child process.
 60942: static const int kMagicAndroidSystemPropFd = 5;
 60942: #endif
 60942: 
 71232: static bool
 71232: ShouldHaveDirectoryService()
 71232: {
 71232:   return GeckoProcessType_Default == XRE_GetProcessType();
 71232: }
 71232: 
 35801: template<>
 35801: struct RunnableMethodTraits<GeckoChildProcessHost>
 35801: {
 35801:     static void RetainCallee(GeckoChildProcessHost* obj) { }
 35801:     static void ReleaseCallee(GeckoChildProcessHost* obj) { }
 35801: };
 35801: 
 35887: GeckoChildProcessHost::GeckoChildProcessHost(GeckoProcessType aProcessType,
 35887:                                              base::WaitableEventWatcher::Delegate* aDelegate)
 35766:   : ChildProcessHost(RENDER_PROCESS), // FIXME/cjones: we should own this enum
 35801:     mProcessType(aProcessType),
 69144:     mMonitor("mozilla.ipc.GeckChildProcessHost.mMonitor"),
 35887:     mLaunched(false),
 36092:     mChannelInitialized(false),
 36016:     mDelegate(aDelegate),
 36016:     mChildProcessHandle(0)
 80376: #if defined(MOZ_WIDGET_COCOA)
 51563:   , mChildTask(MACH_PORT_NULL)
 51563: #endif
 35734: {
 36063:     MOZ_COUNT_CTOR(GeckoChildProcessHost);
 36092:     
 41060:     MessageLoop* ioLoop = XRE_GetIOMessageLoop();
 36092:     ioLoop->PostTask(FROM_HERE,
 36092:                      NewRunnableMethod(this,
 36092:                                        &GeckoChildProcessHost::InitializeChannel));
 36063: }
 36063: 
 36063: GeckoChildProcessHost::~GeckoChildProcessHost()
 36610: 
 36063: {
 36610:   AssertIOThread();
 36610: 
 36063:   MOZ_COUNT_DTOR(GeckoChildProcessHost);
 36096: 
 36165:   if (mChildProcessHandle > 0)
 37240:     ProcessWatcher::EnsureProcessTerminated(mChildProcessHandle
 37479: #if defined(NS_BUILD_REFCNT_LOGGING)
 37240:                                             , false // don't "force"
 37240: #endif
 37240:     );
 51563: 
 80376: #if defined(MOZ_WIDGET_COCOA)
 51563:   if (mChildTask != MACH_PORT_NULL)
 51563:     mach_port_deallocate(mach_task_self(), mChildTask);
 51563: #endif
 35734: }
 35734: 
 54133: void GetPathToBinary(FilePath& exePath)
 54133: {
 71232:   if (ShouldHaveDirectoryService()) {
 54133:     nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
 71232:     NS_ASSERTION(directoryService, "Expected XPCOM to be available");
 71232:     if (directoryService) {
 54133:       nsCOMPtr<nsIFile> greDir;
 54133:       nsresult rv = directoryService->Get(NS_GRE_DIR, NS_GET_IID(nsIFile), getter_AddRefs(greDir));
 54133:       if (NS_SUCCEEDED(rv)) {
104163: #ifdef OS_WIN
104163:         nsString path;
104163:         greDir->GetPath(path);
104163: #else
 54133:         nsCString path;
 54133:         greDir->GetNativePath(path);
104163: #endif
 54133:         exePath = FilePath(path.get());
 80376: #ifdef MOZ_WIDGET_COCOA
 77903:         // We need to use an App Bundle on OS X so that we can hide
 77903:         // the dock icon. See Bug 557225.
 77903:         exePath = exePath.AppendASCII(MOZ_CHILD_PROCESS_BUNDLE);
 77903: #endif
 54133:       }
 71232:     }
 71232:   }
 77903: 
 71232:   if (exePath.empty()) {
104163: #ifdef OS_WIN
104163:     exePath = FilePath::FromWStringHack(CommandLine::ForCurrentProcess()->program());
104163: #else
 54133:     exePath = FilePath(CommandLine::ForCurrentProcess()->argv()[0]);
104163: #endif
 54133:     exePath = exePath.DirName();
 54133:   }
 54133: 
 54133:   exePath = exePath.AppendASCII(MOZ_CHILD_PROCESS_NAME);
 54133: }
 54133: 
 80376: #ifdef MOZ_WIDGET_COCOA
 54133: class AutoCFTypeObject {
 54133: public:
 54133:   AutoCFTypeObject(CFTypeRef object)
 54133:   {
 54133:     mObject = object;
 54133:   }
 54133:   ~AutoCFTypeObject()
 54133:   {
 54133:     ::CFRelease(mObject);
 54133:   }
 54133: private:
 54133:   CFTypeRef mObject;
 54133: };
 54133: #endif
 54133: 
 54133: nsresult GeckoChildProcessHost::GetArchitecturesForBinary(const char *path, uint32 *result)
 54133: {
 54133:   *result = 0;
 54133: 
 80376: #ifdef MOZ_WIDGET_COCOA
 54133:   CFURLRef url = ::CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault,
 54133:                                                            (const UInt8*)path,
 54133:                                                            strlen(path),
 54133:                                                            false);
 54133:   if (!url) {
 54133:     return NS_ERROR_FAILURE;
 54133:   }
 54133:   AutoCFTypeObject autoPluginContainerURL(url);
 54133: 
 54133:   CFArrayRef pluginContainerArchs = ::CFBundleCopyExecutableArchitecturesForURL(url);
 54133:   if (!pluginContainerArchs) {
 54133:     return NS_ERROR_FAILURE;
 54133:   }
 54133:   AutoCFTypeObject autoPluginContainerArchs(pluginContainerArchs);
 54133: 
 54133:   CFIndex pluginArchCount = ::CFArrayGetCount(pluginContainerArchs);
 54133:   for (CFIndex i = 0; i < pluginArchCount; i++) {
 54133:     CFNumberRef currentArch = static_cast<CFNumberRef>(::CFArrayGetValueAtIndex(pluginContainerArchs, i));
 54133:     int currentArchInt = 0;
 54133:     if (!::CFNumberGetValue(currentArch, kCFNumberIntType, &currentArchInt)) {
 54133:       continue;
 54133:     }
 54133:     switch (currentArchInt) {
 54133:       case kCFBundleExecutableArchitectureI386:
 54133:         *result |= base::PROCESS_ARCH_I386;
 54133:         break;
 54133:       case kCFBundleExecutableArchitectureX86_64:
 54133:         *result |= base::PROCESS_ARCH_X86_64;
 54133:         break;
 54133:       case kCFBundleExecutableArchitecturePPC:
 54133:         *result |= base::PROCESS_ARCH_PPC;
 54133:         break;
 54133:       default:
 54133:         break;
 54133:     }
 54133:   }
 54133: 
 54133:   return (*result ? NS_OK : NS_ERROR_FAILURE);
 54133: #else
 54133:   return NS_ERROR_NOT_IMPLEMENTED;
 54133: #endif
 54133: }
 54133: 
 54133: uint32 GeckoChildProcessHost::GetSupportedArchitecturesForProcessType(GeckoProcessType type)
 54133: {
 80376: #ifdef MOZ_WIDGET_COCOA
 54133:   if (type == GeckoProcessType_Plugin) {
 54133:     // Cache this, it shouldn't ever change.
 54133:     static uint32 pluginContainerArchs = 0;
 54133:     if (pluginContainerArchs == 0) {
 54133:       FilePath exePath;
 54133:       GetPathToBinary(exePath);
 54133:       nsresult rv = GetArchitecturesForBinary(exePath.value().c_str(), &pluginContainerArchs);
 54133:       NS_ASSERTION(NS_SUCCEEDED(rv) && pluginContainerArchs != 0, "Getting architecture of plugin container failed!");
 54133:       if (NS_FAILED(rv) || pluginContainerArchs == 0) {
 54133:         pluginContainerArchs = base::GetCurrentProcessArchitecture();
 54133:       }
 54133:     }
 54133:     return pluginContainerArchs;
 54133:   }
 54133: #endif
 54133: 
 54133:   return base::GetCurrentProcessArchitecture();
 54133: }
 54133: 
 46959: #ifdef XP_WIN
 46959: void GeckoChildProcessHost::InitWindowsGroupID()
 46959: {
 46959:   // On Win7+, pass the application user model to the child, so it can
 46959:   // register with it. This insures windows created by the container
 46959:   // properly group with the parent app on the Win7 taskbar.
 46959:   nsCOMPtr<nsIWinTaskbar> taskbarInfo =
 46959:     do_GetService(NS_TASKBAR_CONTRACTID);
 46959:   if (taskbarInfo) {
 79445:     bool isSupported = false;
 46959:     taskbarInfo->GetAvailable(&isSupported);
 46959:     nsAutoString appId;
 46959:     if (isSupported && NS_SUCCEEDED(taskbarInfo->GetDefaultGroupId(appId))) {
 46959:       mGroupId.Append(appId);
 46959:     } else {
 46959:       mGroupId.AssignLiteral("-");
 46959:     }
 46959:   }
 46959: }
 46959: #endif
 46959: 
 35734: bool
 54133: GeckoChildProcessHost::SyncLaunch(std::vector<std::string> aExtraOpts, int aTimeoutMs, base::ProcessArchitecture arch)
 35734: {
 46959: #ifdef XP_WIN
 46959:   InitWindowsGroupID();
 46959: #endif
 46959: 
 49311:   PRIntervalTime timeoutTicks = (aTimeoutMs > 0) ? 
 49311:     PR_MillisecondsToInterval(aTimeoutMs) : PR_INTERVAL_NO_TIMEOUT;
 41060:   MessageLoop* ioLoop = XRE_GetIOMessageLoop();
 36050:   NS_ASSERTION(MessageLoop::current() != ioLoop, "sync launch from the IO thread NYI");
 35801: 
 35801:   ioLoop->PostTask(FROM_HERE,
 35801:                    NewRunnableMethod(this,
 36092:                                      &GeckoChildProcessHost::PerformAsyncLaunch,
 54133:                                      aExtraOpts, arch));
 35801:   // NB: this uses a different mechanism than the chromium parent
 35801:   // class.
 69144:   MonitorAutoLock lock(mMonitor);
 49311:   PRIntervalTime waitStart = PR_IntervalNow();
 49311:   PRIntervalTime current;
 49311: 
 49311:   // We'll receive several notifications, we need to exit when we
 49311:   // have either successfully launched or have timed out.
 35801:   while (!mLaunched) {
 69144:     lock.Wait(timeoutTicks);
 49311: 
 49311:     if (timeoutTicks != PR_INTERVAL_NO_TIMEOUT) {
 49311:       current = PR_IntervalNow();
 49311:       PRIntervalTime elapsed = current - waitStart;
 49311:       if (elapsed > timeoutTicks) {
 49311:         break;
 49311:       }
 49311:       timeoutTicks = timeoutTicks - elapsed;
 49311:       waitStart = current;
 49311:     }
 35801:   }
 35801: 
 49311:   return mLaunched;
 35801: }
 35801: 
 35801: bool
 36050: GeckoChildProcessHost::AsyncLaunch(std::vector<std::string> aExtraOpts)
 35801: {
 46959: #ifdef XP_WIN
 46959:   InitWindowsGroupID();
 46959: #endif
 46959: 
 41060:   MessageLoop* ioLoop = XRE_GetIOMessageLoop();
 36092:   ioLoop->PostTask(FROM_HERE,
 36092:                    NewRunnableMethod(this,
 36092:                                      &GeckoChildProcessHost::PerformAsyncLaunch,
 54133:                                      aExtraOpts, base::GetCurrentProcessArchitecture()));
 36092: 
 36092:   // This may look like the sync launch wait, but we only delay as
 36092:   // long as it takes to create the channel.
 69144:   MonitorAutoLock lock(mMonitor);
 36092:   while (!mChannelInitialized) {
 69144:     lock.Wait();
 36092:   }
 36092: 
 36092:   return true;
 36092: }
 36092: 
 36092: void
 36092: GeckoChildProcessHost::InitializeChannel()
 36092: {
 36092:   CreateChannel();
 36092: 
 69144:   MonitorAutoLock lock(mMonitor);
 36092:   mChannelInitialized = true;
 69144:   lock.Notify();
 36092: }
 36092: 
 63953: PRInt32 GeckoChildProcessHost::mChildCounter = 0;
 63953: 
 63953: //
 63953: // Wrapper function for handling GECKO_SEPARATE_NSPR_LOGS
 63953: //
 36092: bool
 54133: GeckoChildProcessHost::PerformAsyncLaunch(std::vector<std::string> aExtraOpts, base::ProcessArchitecture arch)
 36092: {
 63953:   // If separate NSPR log files are not requested, we're done.
 63953:   const char* origLogName = PR_GetEnv("NSPR_LOG_FILE");
 63953:   const char* separateLogs = PR_GetEnv("GECKO_SEPARATE_NSPR_LOGS");
 63953:   if (!origLogName || !separateLogs || !*separateLogs ||
 63953:       *separateLogs == '0' || *separateLogs == 'N' || *separateLogs == 'n') {
 63953:     return PerformAsyncLaunchInternal(aExtraOpts, arch);
 63953:   }
 63953: 
 63953:   // We currently have no portable way to launch child with environment
 63953:   // different than parent.  So temporarily change NSPR_LOG_FILE so child
 63953:   // inherits value we want it to have. (NSPR only looks at NSPR_LOG_FILE at
 63953:   // startup, so it's 'safe' to play with the parent's environment this way.)
 63953:   nsCAutoString setChildLogName("NSPR_LOG_FILE=");
 63953:   setChildLogName.Append(origLogName);
 63953: 
 63953:   // remember original value so we can restore it.
 63953:   // - buffer needs to be permanently allocated for PR_SetEnv()
 63953:   // - Note: this code is not called re-entrantly, nor are restoreOrigLogName
 63953:   //   or mChildCounter touched by any other thread, so this is safe.
 63953:   static char* restoreOrigLogName = 0;
 63953:   if (!restoreOrigLogName)
 71727:     restoreOrigLogName = strdup(setChildLogName.get());
 63953: 
 63953:   // Append child-specific postfix to name
 63953:   setChildLogName.AppendLiteral(".child-");
 63953:   setChildLogName.AppendInt(++mChildCounter);
 63953: 
 63953:   // Passing temporary to PR_SetEnv is ok here because env gets copied
 63953:   // by exec, etc., to permanent storage in child when process launched.
 71727:   PR_SetEnv(setChildLogName.get());
 63953:   bool retval = PerformAsyncLaunchInternal(aExtraOpts, arch);
 63953: 
 63953:   // Revert to original value
 63953:   PR_SetEnv(restoreOrigLogName);
 63953: 
 63953:   return retval;
 63953: }
 63953: 
 63953: bool
 63953: GeckoChildProcessHost::PerformAsyncLaunchInternal(std::vector<std::string>& aExtraOpts, base::ProcessArchitecture arch)
 63953: {
 35801:   // FIXME/cjones: make this work from non-IO threads, too
 35801: 
 36092:   // We rely on the fact that InitializeChannel() has already been processed
 36092:   // on the IO thread before this point is reached.
 36092:   if (!GetChannel()) {
 35734:     return false;
 35734:   }
 35734: 
 36050:   base::ProcessHandle process;
 36050: 
 36050:   // send the child the PID so that it can open a ProcessHandle back to us.
 36050:   // probably don't want to do this in the long run
 36050:   char pidstring[32];
 36050:   PR_snprintf(pidstring, sizeof(pidstring) - 1,
 36050: 	      "%ld", base::Process::Current().pid());
 36050: 
 36050:   const char* const childProcessType =
 36050:       XRE_ChildProcessTypeToString(mProcessType);
 36050: 
 36050: //--------------------------------------------------
 36050: #if defined(OS_POSIX)
 36050:   // For POSIX, we have to be extremely anal about *not* using
 36050:   // std::wstring in code compiled with Mozilla's -fshort-wchar
 36050:   // configuration, because chromium is compiled with -fno-short-wchar
 36050:   // and passing wstrings from one config to the other is unsafe.  So
 36050:   // we split the logic here.
 36050: 
 47971: #if defined(OS_LINUX) || defined(OS_MACOSX)
 40629:   base::environment_map newEnvVars;
 71232:   // XPCOM may not be initialized in some subprocesses.  We don't want
 71232:   // to initialize XPCOM just for the directory service, especially
 71232:   // since LD_LIBRARY_PATH is already set correctly in subprocesses
 71232:   // (meaning that we don't need to set that up in the environment).
 71232:   if (ShouldHaveDirectoryService()) {
 39465:     nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
 71232:     NS_ASSERTION(directoryService, "Expected XPCOM to be available");
 71232:     if (directoryService) {
 39465:       nsCOMPtr<nsIFile> greDir;
 39465:       nsresult rv = directoryService->Get(NS_GRE_DIR, NS_GET_IID(nsIFile), getter_AddRefs(greDir));
 40628:       if (NS_SUCCEEDED(rv)) {
 39465:         nsCString path;
 39465:         greDir->GetNativePath(path);
 40628: # ifdef OS_LINUX
 82142: #  ifdef MOZ_WIDGET_ANDROID
 46920:         path += "/lib";
 82142: #  endif  // MOZ_WIDGET_ANDROID
 74161:         const char *ld_library_path = PR_GetEnv("LD_LIBRARY_PATH");
 74161:         nsCString new_ld_lib_path;
 74161:         if (ld_library_path && *ld_library_path) {
 86251:             new_ld_lib_path.Assign(path.get());
 74161:             new_ld_lib_path.AppendLiteral(":");
 86251:             new_ld_lib_path.Append(ld_library_path);
 74161:             newEnvVars["LD_LIBRARY_PATH"] = new_ld_lib_path.get();
 74161:         } else {
 40628:             newEnvVars["LD_LIBRARY_PATH"] = path.get();
 74161:         }
 47971: # elif OS_MACOSX
 47971:         newEnvVars["DYLD_LIBRARY_PATH"] = path.get();
 70434:         // XXX DYLD_INSERT_LIBRARIES should only be set when launching a plugin
 70434:         //     process, and has no effect on other subprocesses (the hooks in
 70434:         //     libplugin_child_interpose.dylib become noops).  But currently it
 70434:         //     gets set when launching any kind of subprocess.
 70434:         //
 70434:         // Trigger "dyld interposing" for the dylib that contains
 70434:         // plugin_child_interpose.mm.  This allows us to hook OS calls in the
 70434:         // plugin process (ones that don't work correctly in a background
 70434:         // process).  Don't break any other "dyld interposing" that has already
 70434:         // been set up by whatever may have launched the browser.
 70434:         const char* prevInterpose = PR_GetEnv("DYLD_INSERT_LIBRARIES");
 70434:         nsCString interpose;
 70434:         if (prevInterpose) {
 70434:           interpose.Assign(prevInterpose);
 70434:           interpose.AppendLiteral(":");
 70434:         }
 70434:         interpose.Append(path.get());
 70434:         interpose.AppendLiteral("/libplugin_child_interpose.dylib");
 70434:         newEnvVars["DYLD_INSERT_LIBRARIES"] = interpose.get();
 71232: # endif  // OS_LINUX
 39465:       }
 71232:     }
 71232:   }
 71232: #endif  // OS_LINUX || OS_MACOSX
 47971: 
 54133:   FilePath exePath;
 54133:   GetPathToBinary(exePath);
 36050: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 46920:   // The java wrapper unpacks this for us but can't make it executable
 46920:   chmod(exePath.value().c_str(), 0700);
 56694:   int cacheCount = 0;
 56694:   const struct lib_cache_info * cache = getLibraryCache();
 56694:   nsCString cacheStr;
 56694:   while (cache &&
 56694:          cacheCount++ < MAX_LIB_CACHE_ENTRIES &&
 56694:          strlen(cache->name)) {
 56694:     mFileMap.push_back(std::pair<int,int>(cache->fd, cache->fd));
 56694:     cacheStr.Append(cache->name);
 56694:     cacheStr.AppendPrintf(":%d;", cache->fd);
 56694:     cache++;
 56694:   }
 56694:   // fill the last arg with something if there's no cache
 56694:   if (cacheStr.IsEmpty())
 56694:     cacheStr.AppendLiteral("-");
 60942: 
 60942:   // Remap the Android property workspace to a well-known int,
 60942:   // and update the environment to reflect the new value for the
 60942:   // child process.
 60942:   const char *apws = getenv("ANDROID_PROPERTY_WORKSPACE");
 60942:   if (apws) {
 60942:     int fd = atoi(apws);
 60942:     mFileMap.push_back(std::pair<int, int>(fd, kMagicAndroidSystemPropFd));
 60942: 
 60942:     char buf[32];
 60942:     char *szptr = strchr(apws, ',');
 60942: 
 60942:     snprintf(buf, sizeof(buf), "%d%s", kMagicAndroidSystemPropFd, szptr);
 60942:     newEnvVars["ANDROID_PROPERTY_WORKSPACE"] = buf;
 60942:   }
 82142: #endif  // MOZ_WIDGET_ANDROID
 46920: 
 36050:   // remap the IPC socket fd to a well-known int, as the OS does for
 36050:   // STDOUT_FILENO, for example
 36050:   int srcChannelFd, dstChannelFd;
 36050:   channel().GetClientFileDescriptorMapping(&srcChannelFd, &dstChannelFd);
 36050:   mFileMap.push_back(std::pair<int,int>(srcChannelFd, dstChannelFd));
 36050: 
 36050:   // no need for kProcessChannelID, the child process inherits the
 36050:   // other end of the socketpair() from us
 36050: 
 36050:   std::vector<std::string> childArgv;
 36050: 
 36050:   childArgv.push_back(exePath.value());
 36050: 
 36050:   childArgv.insert(childArgv.end(), aExtraOpts.begin(), aExtraOpts.end());
 36050: 
 71233:   if (Omnijar::IsInitialized()) {
 71233:     // Make sure that child processes can find the omnijar
 49360:     // See XRE_InitCommandLine in nsAppRunner.cpp
 70010:     nsCAutoString path;
 71233:     nsCOMPtr<nsIFile> file = Omnijar::GetPath(Omnijar::GRE);
 70010:     if (file && NS_SUCCEEDED(file->GetNativePath(path))) {
 70010:       childArgv.push_back("-greomni");
 70010:       childArgv.push_back(path.get());
 49360:     }
 71233:     file = Omnijar::GetPath(Omnijar::APP);
 70010:     if (file && NS_SUCCEEDED(file->GetNativePath(path))) {
 70010:       childArgv.push_back("-appomni");
 70010:       childArgv.push_back(path.get());
 70010:     }
 71233:   }
 49360: 
 36050:   childArgv.push_back(pidstring);
 36050: 
 40723: #if defined(MOZ_CRASHREPORTER)
 40723: #  if defined(OS_LINUX)
 37203:   int childCrashFd, childCrashRemapFd;
 37203:   if (!CrashReporter::CreateNotificationPipeForChild(
 37203:         &childCrashFd, &childCrashRemapFd))
 37203:     return false;
 37203:   if (0 <= childCrashFd) {
 37203:     mFileMap.push_back(std::pair<int,int>(childCrashFd, childCrashRemapFd));
 37203:     // "true" == crash reporting enabled
 37203:     childArgv.push_back("true");
 37203:   }
 37203:   else {
 37203:     // "false" == crash reporting disabled
 37203:     childArgv.push_back("false");
 37203:   }
 80376: #  elif defined(MOZ_WIDGET_COCOA)
 50679:   childArgv.push_back(CrashReporter::GetChildNotificationPipe());
 40723: #  endif  // OS_LINUX
 37203: #endif
 37203: 
 80376: #ifdef MOZ_WIDGET_COCOA
 52392:   // Add a mach port to the command line so the child can communicate its
 52392:   // 'task_t' back to the parent.
 52392:   //
 52392:   // Put a random number into the channel name, so that a compromised renderer
 52392:   // can't pretend being the child that's forked off.
 52392:   std::string mach_connection_name = StringPrintf("org.mozilla.machname.%d",
 52392:                                                   base::RandInt(0, std::numeric_limits<int>::max()));
 52392:   childArgv.push_back(mach_connection_name.c_str());
 52392: #endif
 52392: 
 52392:   childArgv.push_back(childProcessType);
 52392: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 56694:   childArgv.push_back(cacheStr.get());
 56694: #endif
 56694: 
 40628:   base::LaunchApp(childArgv, mFileMap,
 47971: #if defined(OS_LINUX) || defined(OS_MACOSX)
 40628:                   newEnvVars,
 40628: #endif
 54133:                   false, &process, arch);
 52392: 
 80376: #ifdef MOZ_WIDGET_COCOA
 52392:   // Wait for the child process to send us its 'task_t' data.
 55802:   const int kTimeoutMs = 10000;
 52392: 
 52392:   MachReceiveMessage child_message;
 52392:   ReceivePort parent_recv_port(mach_connection_name.c_str());
 52392:   kern_return_t err = parent_recv_port.WaitForMessage(&child_message, kTimeoutMs);
 52392:   if (err != KERN_SUCCESS) {
 52392:     std::string errString = StringPrintf("0x%x %s", err, mach_error_string(err));
 52392:     LOG(ERROR) << "parent WaitForMessage() failed: " << errString;
 52392:     return false;
 52392:   }
 52392: 
 52392:   task_t child_task = child_message.GetTranslatedPort(0);
 52392:   if (child_task == MACH_PORT_NULL) {
 52392:     LOG(ERROR) << "parent GetTranslatedPort(0) failed.";
 52392:     return false;
 52392:   }
 52392: 
 52392:   if (child_message.GetTranslatedPort(1) == MACH_PORT_NULL) {
 52392:     LOG(ERROR) << "parent GetTranslatedPort(1) failed.";
 52392:     return false;
 52392:   }
 52392:   MachPortSender parent_sender(child_message.GetTranslatedPort(1));
 52392: 
 52392:   MachSendMessage parent_message(/* id= */0);
 52392:   if (!parent_message.AddDescriptor(bootstrap_port)) {
 52392:     LOG(ERROR) << "parent AddDescriptor(" << bootstrap_port << ") failed.";
 52392:     return false;
 52392:   }
 52392: 
 52392:   err = parent_sender.SendMessage(parent_message, kTimeoutMs);
 52392:   if (err != KERN_SUCCESS) {
 52392:     std::string errString = StringPrintf("0x%x %s", err, mach_error_string(err));
 52392:     LOG(ERROR) << "parent SendMessage() failed: " << errString;
 52392:     return false;
 52392:   }
 51563: #endif
 36050: 
 36050: //--------------------------------------------------
 36050: #elif defined(OS_WIN)
 36050: 
 54133:   FilePath exePath;
 54133:   GetPathToBinary(exePath);
 35734: 
 35734:   CommandLine cmdLine(exePath.ToWStringHack());
 35734:   cmdLine.AppendSwitchWithValue(switches::kProcessChannelID, channel_id());
 35734: 
 36050:   for (std::vector<std::string>::iterator it = aExtraOpts.begin();
 35766:        it != aExtraOpts.end();
 35766:        ++it) {
 36050:       cmdLine.AppendLooseValue(UTF8ToWide(*it));
 35766:   }
 35766: 
 46959:   cmdLine.AppendLooseValue(std::wstring(mGroupId.get()));
 49360: 
 71233:   if (Omnijar::IsInitialized()) {
 49360:     // Make sure the child process can find the omnijar
 49360:     // See XRE_InitCommandLine in nsAppRunner.cpp
 70010:     nsAutoString path;
 71233:     nsCOMPtr<nsIFile> file = Omnijar::GetPath(Omnijar::GRE);
 70010:     if (file && NS_SUCCEEDED(file->GetPath(path))) {
 70010:       cmdLine.AppendLooseValue(UTF8ToWide("-greomni"));
 70010:       cmdLine.AppendLooseValue(path.get());
 49360:     }
 71233:     file = Omnijar::GetPath(Omnijar::APP);
 70010:     if (file && NS_SUCCEEDED(file->GetPath(path))) {
 70010:       cmdLine.AppendLooseValue(UTF8ToWide("-appomni"));
 70010:       cmdLine.AppendLooseValue(path.get());
 70010:     }
 71233:   }
 49360: 
 36016:   cmdLine.AppendLooseValue(UTF8ToWide(pidstring));
 52392: 
 37203: #if defined(MOZ_CRASHREPORTER)
 37203:   cmdLine.AppendLooseValue(
 37208:     UTF8ToWide(CrashReporter::GetChildNotificationPipe()));
 37203: #endif
 36016: 
 52392:   cmdLine.AppendLooseValue(UTF8ToWide(childProcessType));
 52392: 
 36050:   base::LaunchApp(cmdLine, false, false, &process);
 35766: 
 35734: #else
 36050: #  error Sorry
 35734: #endif
 35734: 
 35734:   if (!process) {
 35734:     return false;
 35734:   }
 35734:   SetHandle(process);
 80376: #if defined(MOZ_WIDGET_COCOA)
 51563:   mChildTask = child_task;
 51563: #endif
 35734: 
 35734:   return true;
 35734: }
 35734: 
 35734: void
 35779: GeckoChildProcessHost::OnChannelConnected(int32 peer_pid)
 35779: {
 69144:   MonitorAutoLock lock(mMonitor);
 35801:   mLaunched = true;
 36016: 
 39798:   if (!base::OpenPrivilegedProcessHandle(peer_pid, &mChildProcessHandle))
 36016:       NS_RUNTIMEABORT("can't open handle to child process");
 36016: 
 69144:   lock.Notify();
 35779: }
 35801: 
 35801: // XXX/cjones: these next two methods should basically never be called.
 35801: // after the process is launched, its channel will be used to create
 35801: // one of our channels, AsyncChannel et al.
 35779: void
 35734: GeckoChildProcessHost::OnMessageReceived(const IPC::Message& aMsg)
 35734: {
 35734: }
 35734: void
 35734: GeckoChildProcessHost::OnChannelError()
 35734: {
 35734:   // XXXbent Notify that the child process is gone?
 35734: }
 35887: 
 35887: void
 35887: GeckoChildProcessHost::OnWaitableEventSignaled(base::WaitableEvent *event)
 35887: {
 35887:   if (mDelegate) {
 35887:     mDelegate->OnWaitableEventSignaled(event);
 35887:   }
 35887:   ChildProcessHost::OnWaitableEventSignaled(event);
 35887: }
