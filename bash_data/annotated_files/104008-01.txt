 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 61170: 
 61502: #undef NDEBUG
 61170: #include <assert.h>
 61170: #include <cstring>
 61170: #include <cstdlib>
 61170: #include <cstdio>
 61170: #include "elfxx.h"
 61170: 
 61170: #define ver "0"
 61170: #define elfhack_data ".elfhack.data.v" ver
 61170: #define elfhack_text ".elfhack.text.v" ver
 61170: 
 61170: #ifndef R_ARM_V4BX
 61170: #define R_ARM_V4BX 0x28
 61170: #endif
 62673: #ifndef R_ARM_THM_JUMP24
 62673: #define R_ARM_THM_JUMP24 0x1e
 62673: #endif
 61170: 
 61170: char *rundir = NULL;
 61170: 
 72592: template <typename T>
 72592: struct wrapped {
 72592:     T value;
 72592: };
 72592: 
 72592: class Elf_Addr_Traits {
 72592: public:
 72592:     typedef wrapped<Elf32_Addr> Type32;
 72592:     typedef wrapped<Elf64_Addr> Type64;
 72592: 
 72592:     template <class endian, typename R, typename T>
 72592:     static inline void swap(T &t, R &r) {
 72592:         r.value = endian::swap(t.value);
 72592:     }
 72592: };
 72592: 
 61170: class Elf_RelHack_Traits {
 61170: public:
 61170:     typedef Elf32_Rel Type32;
 61170:     typedef Elf32_Rel Type64;
 61170: 
 61170:     template <class endian, typename R, typename T>
 61170:     static inline void swap(T &t, R &r) {
 61170:         r.r_offset = endian::swap(t.r_offset);
 61170:         r.r_info = endian::swap(t.r_info);
 61170:     }
 61170: };
 61170: 
 61170: typedef serializable<Elf_RelHack_Traits> Elf_RelHack;
 61170: 
 61170: class ElfRelHack_Section: public ElfSection {
 61170: public:
 61170:     ElfRelHack_Section(Elf_Shdr &s)
 61170:     : ElfSection(s, NULL, NULL)
 61170:     {
 61170:         name = elfhack_data;
 61170:     };
 61170: 
 61170:     void serialize(std::ofstream &file, char ei_class, char ei_data)
 61170:     {
 61170:         for (std::vector<Elf_RelHack>::iterator i = rels.begin();
 61170:              i != rels.end(); ++i)
 61170:             (*i).serialize(file, ei_class, ei_data);
 61170:     }
 61170: 
 61170:     bool isRelocatable() {
 61170:         return true;
 61170:     }
 61170: 
 61170:     void push_back(Elf_RelHack &r) {
 61170:         rels.push_back(r);
 61170:         shdr.sh_size = rels.size() * shdr.sh_entsize;
 61170:     }
 61170: private:
 61170:     std::vector<Elf_RelHack> rels;
 61170: };
 61170: 
 61170: class ElfRelHackCode_Section: public ElfSection {
 61170: public:
 61170:     ElfRelHackCode_Section(Elf_Shdr &s, Elf &e)
 61170:     : ElfSection(s, NULL, NULL), parent(e) {
 61170:         std::string file(rundir);
 61170:         init = parent.getDynSection()->getSectionForType(DT_INIT);
 61170:         file += "/inject/";
 61170:         switch (parent.getMachine()) {
 61170:         case EM_386:
 61170:             file += "x86";
 61170:             break;
 61170:         case EM_X86_64:
 61170:             file += "x86_64";
 61170:             break;
 61170:         case EM_ARM:
 61170:             file += "arm";
 61170:             break;
 61170:         default:
 61170:             throw std::runtime_error("unsupported architecture");
 61170:         }
 61170:         if (init == NULL)
 61170:             file += "-noinit";
 61170:         file += ".o";
 61170:         std::ifstream inject(file.c_str(), std::ios::in|std::ios::binary);
 61170:         elf = new Elf(inject);
 61170:         if (elf->getType() != ET_REL)
 61170:             throw std::runtime_error("object for injected code is not ET_REL");
 61170:         if (elf->getMachine() != parent.getMachine())
 61170:             throw std::runtime_error("architecture of object for injected code doesn't match");
 61170: 
 61504:         ElfSymtab_Section *symtab = NULL;
 61504: 
 61170:         // Get all executable sections from the injected code object.
 61170:         // Most of the time, there will only be one for the init function,
 61170:         // but on e.g. x86, there is a separate section for
 61170:         // __i686.get_pc_thunk.$reg
 61504:         // Find the symbol table at the same time.
 61504:         for (ElfSection *section = elf->getSection(1); section != NULL;
 61504:              section = section->getNext()) {
 61504:             if ((section->getType() == SHT_PROGBITS) &&
 61504:                 (section->getFlags() & SHF_EXECINSTR)) {
 61504:                 code.push_back(section);
 61170:                 // We need to align this section depending on the greater
 61170:                 // alignment required by code sections.
 61504:                 if (shdr.sh_addralign < section->getAddrAlign())
 61504:                     shdr.sh_addralign = section->getAddrAlign();
 61504:             } else if (section->getType() == SHT_SYMTAB) {
 61504:                 symtab = (ElfSymtab_Section *) section;
 61170:             }
 61170:         }
 61170:         assert(code.size() != 0);
 61504:         if (symtab == NULL)
 61504:             throw std::runtime_error("Couldn't find a symbol table for the injected code");
 61504: 
 61504:         // Find the init symbol
 61504:         entry_point = -1;
 61504:         int shndx = 0;
 72590:         Elf_SymValue *sym = symtab->lookup("init");
 72590:         if (sym) {
 61509:             entry_point = sym->value.getValue();
 61509:             shndx = sym->value.getSection()->getIndex();
 72590:         } else
 61504:             throw std::runtime_error("Couldn't find an 'init' symbol in the injected code");
 61170: 
 61170:         // Adjust code sections offsets according to their size
 61170:         std::vector<ElfSection *>::iterator c = code.begin();
 61170:         (*c)->getShdr().sh_addr = 0;
 61170:         for(ElfSection *last = *(c++); c != code.end(); c++) {
 61170:             unsigned int addr = last->getShdr().sh_addr + last->getSize();
 61170:             if (addr & ((*c)->getAddrAlign() - 1))
 61170:                 addr = (addr | ((*c)->getAddrAlign() - 1)) + 1;
 61170:             (*c)->getShdr().sh_addr = addr;
 61170:         }
 61170:         shdr.sh_size = code.back()->getAddr() + code.back()->getSize();
 61170:         data = new char[shdr.sh_size];
 61170:         char *buf = data;
 61170:         for (c = code.begin(); c != code.end(); c++) {
 61170:             memcpy(buf, (*c)->getData(), (*c)->getSize());
 61170:             buf += (*c)->getSize();
 61504:             if ((*c)->getIndex() < shndx)
 61504:                 entry_point += (*c)->getSize();
 61170:         }
 61170:         name = elfhack_text;
 61170:     }
 61170: 
 61170:     ~ElfRelHackCode_Section() {
 61170:         delete elf;
 61170:     }
 61170: 
 61170:     void serialize(std::ofstream &file, char ei_class, char ei_data)
 61170:     {
 61170:         // Readjust code offsets
 61170:         for (std::vector<ElfSection *>::iterator c = code.begin(); c != code.end(); c++)
 61170:             (*c)->getShdr().sh_addr += getAddr();
 61170: 
 61170:         // Apply relocations
 61170:         for (ElfSection *rel = elf->getSection(1); rel != NULL; rel = rel->getNext())
 61170:             if ((rel->getType() == SHT_REL) || (rel->getType() == SHT_RELA)) {
 61170:                 ElfSection *section = rel->getInfo().section;
 61170:                 if ((section->getType() == SHT_PROGBITS) && (section->getFlags() & SHF_EXECINSTR)) {
 61170:                     if (rel->getType() == SHT_REL)
 61170:                         apply_relocations((ElfRel_Section<Elf_Rel> *)rel, section);
 61170:                     else
 61170:                         apply_relocations((ElfRel_Section<Elf_Rela> *)rel, section);
 61170:                 }
 61170:             }
 61170: 
 61170:         ElfSection::serialize(file, ei_class, ei_data);
 61170:     }
 61170: 
 61170:     bool isRelocatable() {
 61170:         return true;
 61170:     }
 61170: 
 61504:     unsigned int getEntryPoint() {
 61504:         return entry_point;
 61504:     }
 61170: private:
 62672:     class pc32_relocation {
 62672:     public:
 62672:         Elf32_Addr operator()(unsigned int base_addr, Elf32_Off offset,
 62672:                               Elf32_Word addend, unsigned int addr)
 61170:         {
 62672:             return addr + addend - offset - base_addr;
 61170:         }
 62672:     };
 61170: 
 62672:     class arm_plt32_relocation {
 62672:     public:
 62672:         Elf32_Addr operator()(unsigned int base_addr, Elf32_Off offset,
 62672:                               Elf32_Word addend, unsigned int addr)
 61170:         {
 61170:             // We don't care about sign_extend because the only case where this is
 61170:             // going to be used only jumps forward.
 62672:             Elf32_Addr tmp = (Elf32_Addr) (addr - offset - base_addr) >> 2;
 62672:             tmp = (addend + tmp) & 0x00ffffff;
 62672:             return (addend & 0xff000000) | tmp;
 62672:         }
 62672:     };
 62672: 
 62673:     class arm_thm_jump24_relocation {
 62673:     public:
 62673:         Elf32_Addr operator()(unsigned int base_addr, Elf32_Off offset,
 62673:                               Elf32_Word addend, unsigned int addr)
 62673:         {
 62673:             /* Follows description of b.w instructions as per
 62673:                ARM Architecture Reference Manual ARM® v7-A and ARM® v7-R edition, A8.6.16
 62673:                We limit ourselves to Encoding T3.
 62673:                We don't care about sign_extend because the only case where this is
 62673:                going to be used only jumps forward. */
 62673:             Elf32_Addr tmp = (Elf32_Addr) (addr - offset - base_addr);
 62673:             unsigned int word0 = addend & 0xffff,
 62673:                          word1 = addend >> 16;
 62673: 
 62673:             if (((word0 & 0xf800) != 0xf000) || ((word1 & 0xd000) != 0x9000))
 62673:                 throw std::runtime_error("R_ARM_THM_JUMP24 relocation only supported for B.W <label>");
 62673: 
 62673:             unsigned int s = (word0 & (1 << 10)) >> 10;
 62673:             unsigned int j1 = (word1 & (1 << 13)) >> 13;
 62673:             unsigned int j2 = (word1 & (1 << 11)) >> 11;
 62673:             unsigned int i1 = j1 ^ s ? 0 : 1;
 62673:             unsigned int i2 = j2 ^ s ? 0 : 1;
 62673: 
 62673:             tmp += ((s << 24) | (i1 << 23) | (i2 << 22) | ((word0 & 0x3ff) << 12) | ((word1 & 0x7ff) << 1));
 62673: 
 62673:             s = (tmp & (1 << 24)) >> 24;
 62673:             j1 = ((tmp & (1 << 23)) >> 23) ^ !s;
 62673:             j2 = ((tmp & (1 << 22)) >> 22) ^ !s;
 62673: 
 62673:             return 0xf000 | (s << 10) | ((tmp & (0x3ff << 12)) >> 12) | 
 62673:                    (0x9000 << 16) | (j1 << 29) | (j2 << 27) | ((tmp & 0xffe) << 15);
 62673:         }
 62673:     };
 62673: 
 62672:     class gotoff_relocation {
 62672:     public:
 62672:         Elf32_Addr operator()(unsigned int base_addr, Elf32_Off offset,
 62672:                               Elf32_Word addend, unsigned int addr)
 62672:         {
 62672:             return addr + addend;
 62672:         }
 62672:     };
 62672: 
 62672:     template <class relocation_type>
 62672:     void apply_relocation(ElfSection *the_code, char *base, Elf_Rel *r, unsigned int addr)
 62672:     {
 62672:         relocation_type relocation;
 62672:         Elf32_Addr value;
 62672:         memcpy(&value, base + r->r_offset, 4);
 62672:         value = relocation(the_code->getAddr(), r->r_offset, value, addr);
 62672:         memcpy(base + r->r_offset, &value, 4);
 61170:     }
 61170: 
 62672:     template <class relocation_type>
 62672:     void apply_relocation(ElfSection *the_code, char *base, Elf_Rela *r, unsigned int addr)
 61170:     {
 62672:         relocation_type relocation;
 62672:         Elf32_Addr value = relocation(the_code->getAddr(), r->r_offset, r->r_addend, addr);
 62672:         memcpy(base + r->r_offset, &value, 4);
 61170:     }
 61170: 
 61170:     template <typename Rel_Type>
 61170:     void apply_relocations(ElfRel_Section<Rel_Type> *rel, ElfSection *the_code)
 61170:     {
 61170:         assert(rel->getType() == Rel_Type::sh_type);
 61170:         char *buf = data + (the_code->getAddr() - code.front()->getAddr());
 61170:         // TODO: various checks on the sections
 61170:         ElfSymtab_Section *symtab = (ElfSymtab_Section *)rel->getLink();
 61170:         for (typename std::vector<Rel_Type>::iterator r = rel->rels.begin(); r != rel->rels.end(); r++) {
 61170:             // TODO: various checks on the symbol
 61509:             const char *name = symtab->syms[ELF32_R_SYM(r->r_info)].name;
 61170:             unsigned int addr;
 61509:             if (symtab->syms[ELF32_R_SYM(r->r_info)].value.getSection() == NULL) {
 61170:                 if (strcmp(name, "relhack") == 0) {
 61170:                     addr = getNext()->getAddr();
 61170:                 } else if (strcmp(name, "elf_header") == 0) {
 61170:                     // TODO: change this ungly hack to something better
 61170:                     ElfSection *ehdr = parent.getSection(1)->getPrevious()->getPrevious();
 61170:                     addr = ehdr->getAddr();
 61170:                 } else if (strcmp(name, "original_init") == 0) {
 61170:                     addr = init->getAddr();
 61170:                 } else if (strcmp(name, "_GLOBAL_OFFSET_TABLE_") == 0) {
 61170:                     // We actually don't need a GOT, but need it as a reference for
 61170:                     // GOTOFF relocations. We'll just use the start of the ELF file
 61170:                     addr = 0;
 61170:                 } else if (strcmp(name, "") == 0) {
 61170:                     // This is for R_ARM_V4BX, until we find something better
 61170:                     addr = -1;
 61170:                 } else {
 61502:                     throw std::runtime_error("Unsupported symbol in relocation");
 61170:                 }
 61170:             } else {
 61509:                 ElfSection *section = symtab->syms[ELF32_R_SYM(r->r_info)].value.getSection();
 61170:                 assert((section->getType() == SHT_PROGBITS) && (section->getFlags() & SHF_EXECINSTR));
 61509:                 addr = symtab->syms[ELF32_R_SYM(r->r_info)].value.getValue();
 61170:             }
 61170:             // Do the relocation
 61170: #define REL(machine, type) (EM_ ## machine | (R_ ## machine ## _ ## type << 8))
 61170:             switch (elf->getMachine() | (ELF32_R_TYPE(r->r_info) << 8)) {
 61170:             case REL(X86_64, PC32):
 61170:             case REL(386, PC32):
 61170:             case REL(386, GOTPC):
 61170:             case REL(ARM, GOTPC):
 62673:             case REL(ARM, REL32):
 62672:                 apply_relocation<pc32_relocation>(the_code, buf, &*r, addr);
 61170:                 break;
 61170:             case REL(ARM, PLT32):
 62672:                 apply_relocation<arm_plt32_relocation>(the_code, buf, &*r, addr);
 61170:                 break;
 62673:             case REL(ARM, THM_JUMP24):
 62673:                 apply_relocation<arm_thm_jump24_relocation>(the_code, buf, &*r, addr);
 62673:                 break;
 61170:             case REL(386, GOTOFF):
 61170:             case REL(ARM, GOTOFF):
 62672:                 apply_relocation<gotoff_relocation>(the_code, buf, &*r, addr);
 61170:                 break;
 61170:             case REL(ARM, V4BX):
 61170:                 // Ignore R_ARM_V4BX relocations
 61170:                 break;
 61170:             default:
 61502:                 throw std::runtime_error("Unsupported relocation type");
 61170:             }
 61170:         }
 61170:     }
 61170: 
 61170:     Elf *elf, &parent;
 61170:     std::vector<ElfSection *> code;
 61170:     ElfSection *init;
 61504:     int entry_point;
 61170: };
 61170: 
 61170: template <typename Rel_Type>
 72592: int do_relocation_section(Elf *elf, unsigned int rel_type, unsigned int rel_type2)
 61170: {
 61170:     ElfDynamic_Section *dyn = elf->getDynSection();
 61170:     if (dyn ==NULL) {
 61170:         fprintf(stderr, "Couldn't find SHT_DYNAMIC section\n");
 61170:         return -1;
 61170:     }
 61170: 
 61185:     ElfSegment *relro = elf->getSegmentByType(PT_GNU_RELRO);
 61185: 
 61170:     ElfRel_Section<Rel_Type> *section = (ElfRel_Section<Rel_Type> *)dyn->getSectionForType(Rel_Type::d_tag);
 61170:     assert(section->getType() == Rel_Type::sh_type);
 61170: 
 61170:     Elf32_Shdr relhack32_section =
 76729:         { 0, SHT_PROGBITS, SHF_ALLOC, 0, (Elf32_Off)-1, 0, SHN_UNDEF, 0,
 61170:           Elf_RelHack::size(elf->getClass()), Elf_RelHack::size(elf->getClass()) }; // TODO: sh_addralign should be an alignment, not size
 61170:     Elf32_Shdr relhackcode32_section =
 76729:         { 0, SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR, 0, (Elf32_Off)-1, 0,
 76729:           SHN_UNDEF, 0, 1, 0 };
 61170:     Elf_Shdr relhack_section(relhack32_section);
 61170:     Elf_Shdr relhackcode_section(relhackcode32_section);
 61170:     ElfRelHack_Section *relhack = new ElfRelHack_Section(relhack_section);
 61170:     ElfRelHackCode_Section *relhackcode = new ElfRelHackCode_Section(relhackcode_section, *elf);
 61170: 
 72592:     ElfSymtab_Section *symtab = (ElfSymtab_Section *) section->getLink();
 72592:     Elf_SymValue *sym = symtab->lookup("__cxa_pure_virtual");
 72592: 
 61170:     std::vector<Rel_Type> new_rels;
 61170:     Elf_RelHack relhack_entry;
 61170:     relhack_entry.r_offset = relhack_entry.r_info = 0;
 61170:     int entry_sz = (elf->getClass() == ELFCLASS32) ? 4 : 8;
 61170:     for (typename std::vector<Rel_Type>::iterator i = section->rels.begin();
 61170:          i != section->rels.end(); i++) {
 73908:         // We don't need to keep R_*_NONE relocations
 73908:         if (!ELF32_R_TYPE(i->r_info))
 73908:             continue;
 72592:         ElfSection *section = elf->getSectionAt(i->r_offset);
 72592:         // __cxa_pure_virtual is a function used in vtables to point at pure
 72592:         // virtual methods. The __cxa_pure_virtual function usually abort()s.
 72592:         // These functions are however normally never called. In the case
 72592:         // where they would, jumping to the NULL address instead of calling
 72592:         // __cxa_pure_virtual is going to work just as well. So we can remove
 72592:         // relocations for the __cxa_pure_virtual symbol and NULL out the
 72592:         // content at the offset pointed by the relocation.
 72592:         if (sym) {
 72592:             if (sym->defined) {
 72592:                 // If we are statically linked to libstdc++, the
 72592:                 // __cxa_pure_virtual symbol is defined in our lib, and we
 72592:                 // have relative relocations (rel_type) for it.
 72592:                 if (ELF32_R_TYPE(i->r_info) == rel_type) {
 72592:                     serializable<Elf_Addr_Traits> addr(&section->getData()[i->r_offset - section->getAddr()], entry_sz, elf->getClass(), elf->getData());
 72592:                     if (addr.value == sym->value.getValue()) {
 72592:                         memset((char *)&section->getData()[i->r_offset - section->getAddr()], 0, entry_sz);
 72592:                         continue;
 72592:                     }
 72592:                 }
 72592:             } else {
 72592:                 // If we are dynamically linked to libstdc++, the
 72592:                 // __cxa_pure_virtual symbol is undefined in our lib, and we
 72592:                 // have absolute relocations (rel_type2) for it.
 72592:                 if ((ELF32_R_TYPE(i->r_info) == rel_type2) &&
 72592:                     (sym == &symtab->syms[ELF32_R_SYM(i->r_info)])) {
 72592:                     memset((char *)&section->getData()[i->r_offset - section->getAddr()], 0, entry_sz);
 72592:                     continue;
 72592:                 }
 72592:             }
 72592:         }
 61170:         // Don't pack relocations happening in non writable sections.
 61170:         // Our injected code is likely not to be allowed to write there.
 61185:         if (!(section->getFlags() & SHF_WRITE) || (ELF32_R_TYPE(i->r_info) != rel_type) ||
 62463:             (relro && (i->r_offset >= relro->getAddr()) &&
 62463:                       (i->r_offset < relro->getAddr() + relro->getMemSize())))
 61170:             new_rels.push_back(*i);
 61170:         else {
 61170:             // TODO: check that i->r_addend == *i->r_offset
 61170:             if (i->r_offset == relhack_entry.r_offset + relhack_entry.r_info * entry_sz) {
 61170:                 relhack_entry.r_info++;
 61170:             } else {
 61170:                 if (relhack_entry.r_offset)
 61170:                     relhack->push_back(relhack_entry);
 61170:                 relhack_entry.r_offset = i->r_offset;
 61170:                 relhack_entry.r_info = 1;
 61170:             }
 61170:         }
 61170:     }
 61170:     if (relhack_entry.r_offset)
 61170:         relhack->push_back(relhack_entry);
 61170:     // Last entry must be NULL
 61170:     relhack_entry.r_offset = relhack_entry.r_info = 0;
 61170:     relhack->push_back(relhack_entry);
 61170: 
104008:     unsigned int old_end = section->getOffset() + section->getSize();
104008: 
104008:     relhackcode->insertBefore(section);
 61500:     relhack->insertAfter(relhackcode);
 61500: 
 61170:     section->rels.assign(new_rels.begin(), new_rels.end());
 61170:     section->shrink(new_rels.size() * section->getEntSize());
 61504:     ElfLocation *init = new ElfLocation(relhackcode, relhackcode->getEntryPoint());
 61170:     dyn->setValueForType(DT_INIT, init);
 61170:     // TODO: adjust the value according to the remaining number of relative relocations
 61499:     if (dyn->getValueForType(Rel_Type::d_tag_count))
 61170:         dyn->setValueForType(Rel_Type::d_tag_count, new ElfPlainValue(0));
 62465: 
104008:     if (section->getOffset() + section->getSize() >= old_end) {
 63510:         fprintf(stderr, "No gain. Skipping\n");
 62465:         return -1;
 62465:     }
 61170:     return 0;
 61170: }
 61170: 
 61170: static inline int backup_file(const char *name)
 61170: {
 61170:     std::string fname(name);
 61170:     fname += ".bak";
 61170:     return rename(name, fname.c_str());
 61170: }
 61170: 
 90548: void do_file(const char *name, bool backup = false, bool force = false)
 61170: {
 61170:     std::ifstream file(name, std::ios::in|std::ios::binary);
 61170:     Elf *elf = new Elf(file);
 61170:     unsigned int size = elf->getSize();
 61170:     fprintf(stderr, "%s: ", name);
 92205:     if (elf->getType() != ET_DYN) {
 92205:         fprintf(stderr, "Not a shared object. Skipping\n");
 92205:         delete elf;
 92205:         return;
 92205:     }
 61170: 
 63510:     for (ElfSection *section = elf->getSection(1); section != NULL;
 63510:          section = section->getNext()) {
 63510:         if (section->getName() &&
 63510:             (strncmp(section->getName(), ".elfhack.", 9) == 0)) {
 63510:             fprintf(stderr, "Already elfhacked. Skipping\n");
 63510:             delete elf;
 63510:             return;
 63510:         }
 63510:     }
 63510: 
 61170:     int exit = -1;
 61170:     switch (elf->getMachine()) {
 61170:     case EM_386:
 72592:         exit = do_relocation_section<Elf_Rel>(elf, R_386_RELATIVE, R_386_32);
 61170:         break;
 61170:     case EM_X86_64:
 72592:         exit = do_relocation_section<Elf_Rela>(elf, R_X86_64_RELATIVE, R_X86_64_64);
 61170:         break;
 61170:     case EM_ARM:
 72592:         exit = do_relocation_section<Elf_Rel>(elf, R_ARM_RELATIVE, R_ARM_ABS32);
 61170:         break;
 61170:     }
 62465:     if (exit == 0) {
 90548:         if (!force && (elf->getSize() >= size)) {
 63510:             fprintf(stderr, "No gain. Skipping\n");
 62465:         } else if (backup && backup_file(name) != 0) {
 61170:             fprintf(stderr, "Couln't create backup file\n");
 61170:         } else {
 61170:             std::ofstream ofile(name, std::ios::out|std::ios::binary|std::ios::trunc);
 61170:             elf->write(ofile);
 61170:             fprintf(stderr, "Reduced by %d bytes\n", size - elf->getSize());
 61170:         }
 61170:     }
 61170:     delete elf;
 61170: }
 61170: 
 61170: int main(int argc, char *argv[])
 61170: {
 61170:     int arg;
 61170:     bool backup = false;
 90548:     bool force = false;
 61170:     char *lastSlash = rindex(argv[0], '/');
 61170:     if (lastSlash != NULL)
 61170:         rundir = strndup(argv[0], lastSlash - argv[0]);
 61170:     for (arg = 1; arg < argc; arg++) {
 90548:         if (strcmp(argv[arg], "-f") == 0)
 90548:             force = true;
 90548:         else if (strcmp(argv[arg], "-b") == 0)
 61170:             backup = true;
 61170:         else
 90548:             do_file(argv[arg], backup, force);
 61170:     }
 61170: 
 61170:     free(rundir);
 61170:     return 0;
 61170: }
