     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* base class #1 for rendering objects that have child lists */
     1: 
     1: #include "nsContainerFrame.h"
 86231: 
125899: #include "nsAbsoluteContainingBlock.h"
     1: #include "nsIContent.h"
     1: #include "nsIDocument.h"
     1: #include "nsPresContext.h"
     1: #include "nsStyleContext.h"
     1: #include "nsRect.h"
     1: #include "nsPoint.h"
     1: #include "nsGUIEvent.h"
     1: #include "nsStyleConsts.h"
127357: #include "nsView.h"
     1: #include "nsFrameManager.h"
     1: #include "nsIPresShell.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsCSSAnonBoxes.h"
127607: #include "nsViewManager.h"
     1: #include "nsIWidget.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsCSSRendering.h"
     1: #include "nsTransform2D.h"
     1: #include "nsRegion.h"
108290: #include "nsError.h"
     1: #include "nsDisplayList.h"
  9635: #include "nsListControlFrame.h"
 10102: #include "nsIBaseWindow.h"
 16601: #include "nsThemeConstants.h"
106923: #include "nsBoxLayoutState.h"
106923: #include "nsRenderingContext.h"
 16601: #include "nsCSSFrameConstructor.h"
 41930: #include "mozilla/dom/Element.h"
129543: #include <algorithm>
     1: 
102909: #ifdef DEBUG
     1: #undef NOISY
     1: #else
     1: #undef NOISY
     1: #endif
     1: 
 39965: using namespace mozilla;
 41634: using namespace mozilla::dom;
 39965: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsContainerFrame)
 32423: 
     1: nsContainerFrame::~nsContainerFrame()
     1: {
     1: }
     1: 
 32841: NS_QUERYFRAME_HEAD(nsContainerFrame)
 32841:   NS_QUERYFRAME_ENTRY(nsContainerFrame)
 32841: NS_QUERYFRAME_TAIL_INHERITING(nsSplittableFrame)
 32841: 
     1: NS_IMETHODIMP
     1: nsContainerFrame::Init(nsIContent* aContent,
     1:                        nsIFrame*   aParent,
     1:                        nsIFrame*   aPrevInFlow)
     1: {
     1:   nsresult rv = nsSplittableFrame::Init(aContent, aParent, aPrevInFlow);
     1:   if (aPrevInFlow) {
     1:     // Make sure we copy bits from our prev-in-flow that will affect
     1:     // us. A continuation for a container frame needs to know if it
     1:     // has a child with a view so that we'll properly reposition it.
     1:     if (aPrevInFlow->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)
     1:       AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsContainerFrame::SetInitialChildList(ChildListID  aListID,
 30790:                                       nsFrameList& aChildList)
     1: {
     1:   nsresult  result;
 32843:   if (mFrames.NotEmpty()) {
     1:     // We already have child frames which means we've already been
     1:     // initialized
     1:     NS_NOTREACHED("unexpected second call to SetInitialChildList");
     1:     result = NS_ERROR_UNEXPECTED;
 77154:   } else if (aListID != kPrincipalList) {
 77154:     // All we know about is the principal child list.
     1:     NS_NOTREACHED("unknown frame list");
     1:     result = NS_ERROR_INVALID_ARG;
     1:   } else {
102909: #ifdef DEBUG
     1:     nsFrame::VerifyDirtyBitSet(aChildList);
     1: #endif
     1:     mFrames.SetFrames(aChildList);
     1:     result = NS_OK;
     1:   }
     1:   return result;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsContainerFrame::AppendFrames(ChildListID  aListID,
 30941:                                nsFrameList& aFrameList)
     1: {
 77154:   if (aListID != kPrincipalList) {
     1: #ifdef IBMBIDI
 77154:     if (aListID != kNoReflowPrincipalList)
     1: #endif
     1:     {
     1:       NS_ERROR("unexpected child list");
     1:       return NS_ERROR_INVALID_ARG;
     1:     }
     1:   }
 30941:   if (aFrameList.NotEmpty()) {
     1:     mFrames.AppendFrames(this, aFrameList);
     1: 
     1:     // Ask the parent frame to reflow me.
     1: #ifdef IBMBIDI
 77154:     if (aListID == kPrincipalList)
     1: #endif
     1:     {
   238:       PresContext()->PresShell()->
 27201:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 27201:                          NS_FRAME_HAS_DIRTY_CHILDREN);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsContainerFrame::InsertFrames(ChildListID aListID,
     1:                                nsIFrame* aPrevFrame,
 30941:                                nsFrameList& aFrameList)
     1: {
     1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
     1:                "inserting after sibling frame with different parent");
     1: 
 77154:   if (aListID != kPrincipalList) {
     1: #ifdef IBMBIDI
 77154:     if (aListID != kNoReflowPrincipalList)
     1: #endif
     1:     {
     1:       NS_ERROR("unexpected child list");
     1:       return NS_ERROR_INVALID_ARG;
     1:     }
     1:   }
 30941:   if (aFrameList.NotEmpty()) {
     1:     // Insert frames after aPrevFrame
     1:     mFrames.InsertFrames(this, aPrevFrame, aFrameList);
     1: 
     1: #ifdef IBMBIDI
 77154:     if (aListID == kPrincipalList)
     1: #endif
     1:     {
   238:       PresContext()->PresShell()->
 27201:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 27201:                          NS_FRAME_HAS_DIRTY_CHILDREN);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsContainerFrame::RemoveFrame(ChildListID aListID,
     1:                               nsIFrame* aOldFrame)
     1: {
 77154:   if (aListID != kPrincipalList) {
     1: #ifdef IBMBIDI
 77154:     if (kNoReflowPrincipalList != aListID)
     1: #endif
     1:     {
     1:       NS_ERROR("unexpected child list");
     1:       return NS_ERROR_INVALID_ARG;
     1:     }
     1:   }
     1: 
 82347:   // Loop and destroy aOldFrame and all of its continuations.
 82347:   // Request a reflow on the parent frames involved unless we were explicitly
 82347:   // told not to (kNoReflowPrincipalList).
 79445:   bool generateReflowCommand = true;
  8854: #ifdef IBMBIDI
 77154:   if (kNoReflowPrincipalList == aListID) {
 80486:     generateReflowCommand = false;
  8854:   }
  8854: #endif
 82347:   nsPresContext* pc = PresContext();
106838:   nsContainerFrame* lastParent = nullptr;
     1:   while (aOldFrame) {
  4006:     //XXXfr probably should use StealFrame here. I'm not sure if we need to
  4006:     //      check the overflow lists atm, but we'll need a prescontext lookup
  4006:     //      for overflow containers once we can split abspos elements with
  4006:     //      inline containing blocks.
 82347:     nsIFrame* oldFrameNextContinuation = aOldFrame->GetNextContinuation();
 82347:     nsContainerFrame* parent =
 82347:       static_cast<nsContainerFrame*>(aOldFrame->GetParent());
 82347:     parent->StealFrame(pc, aOldFrame, true);
 10266:     aOldFrame->Destroy();
 82347:     aOldFrame = oldFrameNextContinuation;
 82347:     if (parent != lastParent && generateReflowCommand) {
 82347:       pc->PresShell()->
 82347:         FrameNeedsReflow(parent, nsIPresShell::eTreeChange,
 82347:                          NS_FRAME_HAS_DIRTY_CHILDREN);
 82347:       lastParent = parent;
 10266:     }
  6589:   }
     1:   return NS_OK;
     1: }
     1: 
     1: void
120780: nsContainerFrame::DestroyAbsoluteFrames(nsIFrame* aDestructRoot)
120780: {
120780:   if (IsAbsoluteContainer()) {
120780:     GetAbsoluteContainingBlock()->DestroyFrames(this, aDestructRoot);
120780:     MarkAsNotAbsoluteContainingBlock();
120780:   }
120780: }
120780: 
120780: void
132146: nsContainerFrame::SafelyDestroyFrameListProp(nsIFrame* aDestructRoot,
132146:                                              FramePropertyTable* aPropTable,
132146:                                              const FramePropertyDescriptor* aProp)
132146: {
132146:   // Note that the last frame can be removed through another route and thus
132146:   // delete the property -- that's why we fetch the property again before
132146:   // removing each frame rather than fetching it once and iterating the list.
132146:   while (nsFrameList* frameList =
132146:            static_cast<nsFrameList*>(aPropTable->Get(this, aProp))) {
132146:     nsIFrame* frame = frameList->RemoveFirstChild();
132146:     if (MOZ_LIKELY(frame)) {
132146:       frame->DestroyFrom(aDestructRoot);
132146:     } else {
132146:       aPropTable->Remove(this, aProp);
132146:       delete frameList;
132146:       return;
132146:     }
132146:   }
132146: }
132146: 
132146: void
 36647: nsContainerFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
     1:   // Prevent event dispatch during destruction
     1:   if (HasView()) {
106838:     GetView()->SetFrame(nullptr);
     1:   }
     1: 
120780:   DestroyAbsoluteFrames(aDestructRoot);
120780: 
     1:   // Delete the primary child list
 36647:   mFrames.DestroyFramesFrom(aDestructRoot);
     1: 
  4006:   // Destroy auxiliary frame lists
  4006:   nsPresContext* prescontext = PresContext();
  4006: 
 36647:   DestroyOverflowList(prescontext, aDestructRoot);
     1: 
  4006:   if (IsFrameOfType(nsIFrame::eCanContainOverflowContainers)) {
132146:     FramePropertyTable* props = prescontext->PropertyTable();
132146:     SafelyDestroyFrameListProp(aDestructRoot, props,
132146:                                OverflowContainersProperty());
132146:     SafelyDestroyFrameListProp(aDestructRoot, props,
 39965:                                ExcessOverflowContainersProperty());
  4006:   }
  4006: 
     1:   // Destroy the frame and remove the flow pointers
 36647:   nsSplittableFrame::DestroyFrom(aDestructRoot);
     1: }
     1: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // Child frame enumeration
     1: 
 91756: const nsFrameList&
 77152: nsContainerFrame::GetChildList(ChildListID aListID) const
     1: {
 77152:   // We only know about the principal child list and the overflow lists.
 77152:   switch (aListID) {
 77152:     case kPrincipalList:
 30783:       return mFrames;
 77152:     case kOverflowList: {
 77152:       nsFrameList* list = GetOverflowFrames();
 77152:       return list ? *list : nsFrameList::EmptyList();
 77152:     }
 77152:     case kOverflowContainersList: {
 77152:       nsFrameList* list =
 77152:         GetPropTableFrames(PresContext(), OverflowContainersProperty());
 77152:       return list ? *list : nsFrameList::EmptyList();
 77152:     }
 77152:     case kExcessOverflowContainersList: {
 77152:       nsFrameList* list =
 77152:         GetPropTableFrames(PresContext(), ExcessOverflowContainersProperty());
 77152:       return list ? *list : nsFrameList::EmptyList();
 77152:     }
 77152:     default:
 77152:       return nsSplittableFrame::GetChildList(aListID);
 77152:   }
 30783: }
 30783: 
 77152: static void AppendIfNonempty(const nsIFrame* aFrame,
 77152:                             FramePropertyTable* aPropTable,
 77152:                             const FramePropertyDescriptor* aProperty,
 77152:                             nsTArray<nsIFrame::ChildList>* aLists,
 77152:                             nsIFrame::ChildListID aListID)
 77152: {
 77152:   nsFrameList* list = static_cast<nsFrameList*>(
 77152:     aPropTable->Get(aFrame, aProperty));
 77152:   if (list) {
 77152:     list->AppendIfNonempty(aLists, aListID);
 77152:   }
 30783: }
 30783: 
 77152: void
 77152: nsContainerFrame::GetChildLists(nsTArray<ChildList>* aLists) const
 77152: {
 77152:   mFrames.AppendIfNonempty(aLists, kPrincipalList);
 77152:   FramePropertyTable* propTable = PresContext()->PropertyTable();
 77152:   ::AppendIfNonempty(this, propTable, OverflowProperty(),
 77152:                      aLists, kOverflowList);
 77152:   if (IsFrameOfType(nsIFrame::eCanContainOverflowContainers)) {
 77152:     ::AppendIfNonempty(this, propTable, OverflowContainersProperty(),
 77152:                        aLists, kOverflowContainersList);
 77152:     ::AppendIfNonempty(this, propTable, ExcessOverflowContainersProperty(),
 77152:                        aLists, kExcessOverflowContainersList);
 30783:   }
 79483:   nsSplittableFrame::GetChildLists(aLists);
     1: }
     1: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // Painting/Events
     1: 
132778: void
     1: nsContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                    const nsRect&           aDirtyRect,
     1:                                    const nsDisplayListSet& aLists)
     1: {
132777:   DisplayBorderBackgroundOutline(aBuilder, aLists);
     1: 
132777:   BuildDisplayListForNonBlockChildren(aBuilder, aDirtyRect, aLists);
     1: }
     1: 
132778: void
     1: nsContainerFrame::BuildDisplayListForNonBlockChildren(nsDisplayListBuilder*   aBuilder,
     1:                                                       const nsRect&           aDirtyRect,
     1:                                                       const nsDisplayListSet& aLists,
108991:                                                       uint32_t                aFlags)
     1: {
     1:   nsIFrame* kid = mFrames.FirstChild();
     1:   // Put each child's background directly onto the content list
     1:   nsDisplayListSet set(aLists, aLists.Content());
     1:   // The children should be in content order
     1:   while (kid) {
132777:     BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set, aFlags);
     1:     kid = kid->GetNextSibling();
     1:   }
     1: }
     1: 
     1: /* virtual */ void
     1: nsContainerFrame::ChildIsDirty(nsIFrame* aChild)
     1: {
     1:   AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
     1: }
     1: 
 79445: bool
     1: nsContainerFrame::IsLeaf() const
     1: {
 80486:   return false;
     1: }
     1: 
 79445: bool
108991: nsContainerFrame::PeekOffsetNoAmount(bool aForward, int32_t* aOffset)
     1: {
     1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
     1:   // Don't allow the caret to stay in an empty (leaf) container frame.
 80486:   return false;
     1: }
     1: 
 79445: bool
108991: nsContainerFrame::PeekOffsetCharacter(bool aForward, int32_t* aOffset,
 79445:                                       bool aRespectClusters)
     1: {
     1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
     1:   // Don't allow the caret to stay in an empty (leaf) container frame.
 80486:   return false;
     1: }
     1: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // Helper member functions
     1: 
 68656: static nsresult
 68656: ReparentFrameViewTo(nsIFrame*       aFrame,
127607:                     nsViewManager* aViewManager,
127357:                     nsView*        aNewParentView,
127357:                     nsView*        aOldParentView)
 68656: {
 68656: 
 68656:   // XXX What to do about placeholder views for "position: fixed" elements?
 68656:   // They should be reparented too.
 68656: 
 68656:   // Does aFrame have a view?
 68656:   if (aFrame->HasView()) {
 68656: #ifdef MOZ_XUL
 68656:     if (aFrame->GetType() == nsGkAtoms::menuPopupFrame) {
 68656:       // This view must be parented by the root view, don't reparent it.
 68656:       return NS_OK;
 68656:     }
 68656: #endif
127357:     nsView* view = aFrame->GetView();
 68656:     // Verify that the current parent view is what we think it is
127357:     //nsView*  parentView;
 68656:     //NS_ASSERTION(parentView == aOldParentView, "unexpected parent view");
 68656: 
 68656:     aViewManager->RemoveChild(view);
 68656:     
 68656:     // The view will remember the Z-order and other attributes that have been set on it.
127357:     nsView* insertBefore = nsLayoutUtils::FindSiblingViewFor(aNewParentView, aFrame);
106838:     aViewManager->InsertChild(aNewParentView, view, insertBefore, insertBefore != nullptr);
 68656:   } else {
 77153:     nsIFrame::ChildListIterator lists(aFrame);
 77153:     for (; !lists.IsDone(); lists.Next()) {
 68656:       // Iterate the child frames, and check each child frame to see if it has
 68656:       // a view
 77153:       nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:       for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:         ReparentFrameViewTo(childFrames.get(), aViewManager,
 68656:                             aNewParentView, aOldParentView);
 68656:       }
 77153:     }
 68656:   }
 68656: 
 68656:   return NS_OK;
 68656: }
 68656: 
 68656: nsresult
 68656: nsContainerFrame::CreateViewForFrame(nsIFrame* aFrame,
 79445:                                      bool aForce)
 68656: {
 68656:   if (aFrame->HasView()) {
 68656:     return NS_OK;
 68656:   }
 68656: 
 68656:   // If we don't yet have a view, see if we need a view
 68656:   if (!aForce && !aFrame->NeedsView()) {
 68656:     // don't need a view
 68656:     return NS_OK;
 68656:   }
 68656: 
127357:   nsView* parentView = aFrame->GetParent()->GetClosestView();
 68656:   NS_ASSERTION(parentView, "no parent with view");
 68656: 
127607:   nsViewManager* viewManager = parentView->GetViewManager();
 68656:   NS_ASSERTION(viewManager, "null view manager");
 68656: 
 68656:   // Create a view
127357:   nsView* view = viewManager->CreateView(aFrame->GetRect(), parentView);
 68656:   if (!view)
 68656:     return NS_ERROR_OUT_OF_MEMORY;
 68656: 
106838:   SyncFrameViewProperties(aFrame->PresContext(), aFrame, nullptr, view);
 68656: 
127357:   nsView* insertBefore = nsLayoutUtils::FindSiblingViewFor(parentView, aFrame);
 68656:   // we insert this view 'above' the insertBefore view, unless insertBefore is null,
 80486:   // in which case we want to call with aAbove == false to insert at the beginning
 68656:   // in document order
106838:   viewManager->InsertChild(parentView, view, insertBefore, insertBefore != nullptr);
 68656: 
 68656:   // REVIEW: Don't create a widget for fixed-pos elements anymore.
 68656:   // ComputeRepaintRegionForCopy will calculate the right area to repaint
 68656:   // when we scroll.
 68656:   // Reparent views on any child frames (or their descendants) to this
 68656:   // view. We can just call ReparentFrameViewTo on this frame because
 68656:   // we know this frame has no view, so it will crawl the children. Also,
 68656:   // we know that any descendants with views must have 'parentView' as their
 68656:   // parent view.
 68656:   ReparentFrameViewTo(aFrame, viewManager, view, parentView);
 68656: 
 68656:   // Remember our view
 68656:   aFrame->SetView(view);
 68656: 
 68656:   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
 86231:                ("nsContainerFrame::CreateViewForFrame: frame=%p view=%p",
 68656:                 aFrame));
 68656:   return NS_OK;
 68656: }
 68656: 
     1: /**
     1:  * Position the view associated with |aKidFrame|, if there is one. A
     1:  * container frame should call this method after positioning a frame,
     1:  * but before |Reflow|.
     1:  */
     1: void
     1: nsContainerFrame::PositionFrameView(nsIFrame* aKidFrame)
     1: {
     1:   nsIFrame* parentFrame = aKidFrame->GetParent();
     1:   if (!aKidFrame->HasView() || !parentFrame)
     1:     return;
     1: 
127357:   nsView* view = aKidFrame->GetView();
127607:   nsViewManager* vm = view->GetViewManager();
     1:   nsPoint pt;
127357:   nsView* ancestorView = parentFrame->GetClosestView(&pt);
     1: 
     1:   if (ancestorView != view->GetParent()) {
     1:     NS_ASSERTION(ancestorView == view->GetParent()->GetParent(),
     1:                  "Allowed only one anonymous view between frames");
     1:     // parentFrame is responsible for positioning aKidFrame's view
     1:     // explicitly
     1:     return;
     1:   }
     1: 
     1:   pt += aKidFrame->GetPosition();
     1:   vm->MoveViewTo(view, pt.x, pt.y);
     1: }
     1: 
 68656: nsresult
 68656: nsContainerFrame::ReparentFrameView(nsPresContext* aPresContext,
 68656:                                     nsIFrame*       aChildFrame,
 68656:                                     nsIFrame*       aOldParentFrame,
 68656:                                     nsIFrame*       aNewParentFrame)
 68656: {
 68656:   NS_PRECONDITION(aChildFrame, "null child frame pointer");
 68656:   NS_PRECONDITION(aOldParentFrame, "null old parent frame pointer");
 68656:   NS_PRECONDITION(aNewParentFrame, "null new parent frame pointer");
 68656:   NS_PRECONDITION(aOldParentFrame != aNewParentFrame, "same old and new parent frame");
 68656: 
 68656:   // See if either the old parent frame or the new parent frame have a view
 68656:   while (!aOldParentFrame->HasView() && !aNewParentFrame->HasView()) {
 68656:     // Walk up both the old parent frame and the new parent frame nodes
 68656:     // stopping when we either find a common parent or views for one
 68656:     // or both of the frames.
 68656:     //
 68656:     // This works well in the common case where we push/pull and the old parent
 68656:     // frame and the new parent frame are part of the same flow. They will
 68656:     // typically be the same distance (height wise) from the
 68656:     aOldParentFrame = aOldParentFrame->GetParent();
 68656:     aNewParentFrame = aNewParentFrame->GetParent();
 68656:     
 68656:     // We should never walk all the way to the root frame without finding
 68656:     // a view
 68656:     NS_ASSERTION(aOldParentFrame && aNewParentFrame, "didn't find view");
 68656: 
 68656:     // See if we reached a common ancestor
 68656:     if (aOldParentFrame == aNewParentFrame) {
 68656:       break;
 68656:     }
 68656:   }
 68656: 
 68656:   // See if we found a common parent frame
 68656:   if (aOldParentFrame == aNewParentFrame) {
 68656:     // We found a common parent and there are no views between the old parent
 68656:     // and the common parent or the new parent frame and the common parent.
 68656:     // Because neither the old parent frame nor the new parent frame have views,
 68656:     // then any child views don't need reparenting
 68656:     return NS_OK;
 68656:   }
 68656: 
 68656:   // We found views for one or both of the ancestor frames before we
 68656:   // found a common ancestor.
127357:   nsView* oldParentView = aOldParentFrame->GetClosestView();
127357:   nsView* newParentView = aNewParentFrame->GetClosestView();
 68656:   
 68656:   // See if the old parent frame and the new parent frame are in the
 68656:   // same view sub-hierarchy. If they are then we don't have to do
 68656:   // anything
 68656:   if (oldParentView != newParentView) {
 68656:     // They're not so we need to reparent any child views
 68656:     return ReparentFrameViewTo(aChildFrame, oldParentView->GetViewManager(), newParentView,
 68656:                                oldParentView);
 68656:   }
 68656: 
 68656:   return NS_OK;
 68656: }
 68656: 
 68656: nsresult
 68656: nsContainerFrame::ReparentFrameViewList(nsPresContext*     aPresContext,
 68656:                                         const nsFrameList& aChildFrameList,
 68656:                                         nsIFrame*          aOldParentFrame,
 68656:                                         nsIFrame*          aNewParentFrame)
 68656: {
 68656:   NS_PRECONDITION(aChildFrameList.NotEmpty(), "empty child frame list");
 68656:   NS_PRECONDITION(aOldParentFrame, "null old parent frame pointer");
 68656:   NS_PRECONDITION(aNewParentFrame, "null new parent frame pointer");
 68656:   NS_PRECONDITION(aOldParentFrame != aNewParentFrame, "same old and new parent frame");
 68656: 
 68656:   // See if either the old parent frame or the new parent frame have a view
 68656:   while (!aOldParentFrame->HasView() && !aNewParentFrame->HasView()) {
 68656:     // Walk up both the old parent frame and the new parent frame nodes
 68656:     // stopping when we either find a common parent or views for one
 68656:     // or both of the frames.
 68656:     //
 68656:     // This works well in the common case where we push/pull and the old parent
 68656:     // frame and the new parent frame are part of the same flow. They will
 68656:     // typically be the same distance (height wise) from the
 68656:     aOldParentFrame = aOldParentFrame->GetParent();
 68656:     aNewParentFrame = aNewParentFrame->GetParent();
 68656:     
 68656:     // We should never walk all the way to the root frame without finding
 68656:     // a view
 68656:     NS_ASSERTION(aOldParentFrame && aNewParentFrame, "didn't find view");
 68656: 
 68656:     // See if we reached a common ancestor
 68656:     if (aOldParentFrame == aNewParentFrame) {
 68656:       break;
 68656:     }
 68656:   }
 68656: 
 68656: 
 68656:   // See if we found a common parent frame
 68656:   if (aOldParentFrame == aNewParentFrame) {
 68656:     // We found a common parent and there are no views between the old parent
 68656:     // and the common parent or the new parent frame and the common parent.
 68656:     // Because neither the old parent frame nor the new parent frame have views,
 68656:     // then any child views don't need reparenting
 68656:     return NS_OK;
 68656:   }
 68656: 
 68656:   // We found views for one or both of the ancestor frames before we
 68656:   // found a common ancestor.
127357:   nsView* oldParentView = aOldParentFrame->GetClosestView();
127357:   nsView* newParentView = aNewParentFrame->GetClosestView();
 68656:   
 68656:   // See if the old parent frame and the new parent frame are in the
 68656:   // same view sub-hierarchy. If they are then we don't have to do
 68656:   // anything
 68656:   if (oldParentView != newParentView) {
127607:     nsViewManager* viewManager = oldParentView->GetViewManager();
 68656: 
 68656:     // They're not so we need to reparent any child views
 68656:     for (nsFrameList::Enumerator e(aChildFrameList); !e.AtEnd(); e.Next()) {
 68656:       ReparentFrameViewTo(e.get(), viewManager, newParentView, oldParentView);
 68656:     }
 68656:   }
 68656: 
 68656:   return NS_OK;
 68656: }
 68656: 
 31401: static nsIWidget*
 31401: GetPresContextContainerWidget(nsPresContext* aPresContext)
 10102: {
 10102:   nsCOMPtr<nsISupports> container = aPresContext->Document()->GetContainer();
 10102:   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(container);
 10102:   if (!baseWindow)
106838:     return nullptr;
 10102: 
 10102:   nsCOMPtr<nsIWidget> mainWidget;
 10102:   baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
 31401:   return mainWidget;
 31401: }
 10102: 
 79445: static bool
 31401: IsTopLevelWidget(nsIWidget* aWidget)
 31401: {
 10102:   nsWindowType windowType;
 31401:   aWidget->GetWindowType(windowType);
 10102:   return windowType == eWindowType_toplevel ||
 31401:          windowType == eWindowType_dialog ||
 31401:          windowType == eWindowType_sheet;
 10102:   // popups aren't toplevel so they're not handled here
 10102: }
 10102: 
 31401: void
 31401: nsContainerFrame::SyncWindowProperties(nsPresContext*       aPresContext,
     1:                                        nsIFrame*            aFrame,
127357:                                        nsView*             aView,
106923:                                        nsRenderingContext*  aRC)
     1: {
 23154: #ifdef MOZ_XUL
 31401:   if (!aView || !nsCSSRendering::IsCanvasFrame(aFrame) || !aView->HasWidget())
 23154:     return;
 23154: 
 31401:   nsIWidget* windowWidget = GetPresContextContainerWidget(aPresContext);
 31401:   if (!windowWidget || !IsTopLevelWidget(windowWidget))
 25022:     return;
 25022: 
127607:   nsViewManager* vm = aView->GetViewManager();
127357:   nsView* rootView = vm->GetRootView();
     1: 
 25022:   if (aView != rootView)
 23154:     return;
 23154: 
 41634:   Element* rootElement = aPresContext->Document()->GetRootElement();
 41634:   if (!rootElement || !rootElement->IsXUL()) {
 23154:     // Scrollframes use native widgets which don't work well with
 23154:     // translucent windows, at least in Windows XP. So if the document
 23154:     // has a root scrollrame it's useless to try to make it transparent,
 23154:     // we'll just get something broken.
 23154:     // nsCSSFrameConstructor::ConstructRootFrame constructs root
 23154:     // scrollframes whenever the root element is not a XUL element, so
 23154:     // we test for that here. We can't just call
 23154:     // presShell->GetRootScrollFrame() since that might not have
 23154:     // been constructed yet.
 23154:     // We can change this to allow translucent toplevel HTML documents
 23154:     // (e.g. to do something like Dashboard widgets), once we
 23154:     // have broad support for translucent scrolled documents, but be
 23154:     // careful because apparently some Firefox extensions expect
 23154:     // openDialog("something.html") to produce an opaque window
 23154:     // even if the HTML doesn't have a background-color set.
 23154:     return;
 23154:   }
 23154: 
 31401:   nsIFrame *rootFrame = aPresContext->PresShell()->FrameConstructor()->GetRootElementStyleFrame();
 31401:   if (!rootFrame)
 31401:     return;
 31401: 
 31535:   nsTransparencyMode mode = nsLayoutUtils::GetFrameTransparency(aFrame, rootFrame);
 31401:   nsIWidget* viewWidget = aView->GetWidget();
 31401:   viewWidget->SetTransparencyMode(mode);
132812:   windowWidget->SetWindowShadowStyle(rootFrame->StyleUIReset()->mWindowShadow);
106923: 
106923:   if (!aRC)
106923:     return;
106923:   
106923:   nsBoxLayoutState aState(aPresContext, aRC);
106923:   nsSize minSize = rootFrame->GetMinSize(aState);
106923:   nsSize maxSize = rootFrame->GetMaxSize(aState);
106923: 
106923:   SetSizeConstraints(aPresContext, windowWidget, minSize, maxSize);
 23154: #endif
     1: }
     1: 
106923: void nsContainerFrame::SetSizeConstraints(nsPresContext* aPresContext,
106923:                                           nsIWidget* aWidget,
106923:                                           const nsSize& aMinSize,
106923:                                           const nsSize& aMaxSize)
106923: {
106923:   nsIntSize devMinSize(aPresContext->AppUnitsToDevPixels(aMinSize.width),
106923:                        aPresContext->AppUnitsToDevPixels(aMinSize.height));
106923:   nsIntSize devMaxSize(aMaxSize.width == NS_INTRINSICSIZE ? NS_MAXSIZE :
106923:                          aPresContext->AppUnitsToDevPixels(aMaxSize.width),
106923:                        aMaxSize.height == NS_INTRINSICSIZE ? NS_MAXSIZE :
106923:                          aPresContext->AppUnitsToDevPixels(aMaxSize.height));
106923:   widget::SizeConstraints constraints(devMinSize, devMaxSize);
106923: 
106923:   // The sizes are in inner window sizes, so convert them into outer window sizes.
106923:   // Use a size of (200, 200) as only the difference between the inner and outer
106923:   // size is needed.
106923:   nsIntSize windowSize = aWidget->ClientToWindowSize(nsIntSize(200, 200));
106923:   if (constraints.mMinSize.width)
106923:     constraints.mMinSize.width += windowSize.width - 200;
106923:   if (constraints.mMinSize.height)
106923:     constraints.mMinSize.height += windowSize.height - 200;
106923:   if (constraints.mMaxSize.width != NS_MAXSIZE)
106923:     constraints.mMaxSize.width += windowSize.width - 200;
106923:   if (constraints.mMaxSize.height != NS_MAXSIZE)
106923:     constraints.mMaxSize.height += windowSize.height - 200;
106923: 
106923:   aWidget->SetSizeConstraints(constraints);
106923: }
106923: 
     1: void
     1: nsContainerFrame::SyncFrameViewAfterReflow(nsPresContext* aPresContext,
     1:                                            nsIFrame*       aFrame,
127357:                                            nsView*        aView,
 55021:                                            const nsRect&   aVisualOverflowArea,
108991:                                            uint32_t        aFlags)
     1: {
     1:   if (!aView) {
     1:     return;
     1:   }
     1: 
     1:   // Make sure the view is sized and positioned correctly
     1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
     1:     PositionFrameView(aFrame);
     1:   }
     1: 
     1:   if (0 == (aFlags & NS_FRAME_NO_SIZE_VIEW)) {
127607:     nsViewManager* vm = aView->GetViewManager();
     1: 
 80486:     vm->ResizeView(aView, aVisualOverflowArea, true);
     1:   }
     1: }
     1: 
     1: void
     1: nsContainerFrame::SyncFrameViewProperties(nsPresContext*  aPresContext,
     1:                                           nsIFrame*        aFrame,
     1:                                           nsStyleContext*  aStyleContext,
127357:                                           nsView*         aView,
108991:                                           uint32_t         aFlags)
     1: {
132768:   NS_ASSERTION(!aStyleContext || aFrame->StyleContext() == aStyleContext,
     1:                "Wrong style context for frame?");
     1: 
     1:   if (!aView) {
     1:     return;
     1:   }
     1: 
127607:   nsViewManager* vm = aView->GetViewManager();
     1: 
106838:   if (nullptr == aStyleContext) {
132768:     aStyleContext = aFrame->StyleContext();
     1:   }
     1: 
 32181:   // Make sure visibility is correct. This only affects nsSubdocumentFrame.
 32181:   if (0 == (aFlags & NS_FRAME_NO_VISIBILITY) &&
 32181:       !aFrame->SupportsVisibilityHidden()) {
     1:     // See if the view should be hidden or visible
 32181:     vm->SetViewVisibility(aView,
132812:         aStyleContext->StyleVisibility()->IsVisible()
 32181:             ? nsViewVisibility_kShow : nsViewVisibility_kHide);
     1:   }
     1: 
     1:   // See if the frame is being relatively positioned or absolutely
     1:   // positioned
107225:   bool isPositioned = aFrame->IsPositioned();
     1: 
108991:   int32_t zIndex = 0;
 79445:   bool    autoZIndex = false;
     1: 
     1:   if (!isPositioned) {
 80486:     autoZIndex = true;
     1:   } else {
     1:     // Make sure z-index is correct
132812:     const nsStylePosition* position = aStyleContext->StylePosition();
     1: 
     1:     if (position->mZIndex.GetUnit() == eStyleUnit_Integer) {
     1:       zIndex = position->mZIndex.GetIntValue();
     1:     } else if (position->mZIndex.GetUnit() == eStyleUnit_Auto) {
 80486:       autoZIndex = true;
     1:     }
     1:   }
     1: 
     1:   vm->SetViewZIndex(aView, autoZIndex, zIndex, isPositioned);
     1: }
     1: 
     1: static nscoord GetCoord(const nsStyleCoord& aCoord, nscoord aIfNotCoord)
     1: {
 51776:   if (aCoord.ConvertsToLength()) {
 51776:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, 0);
 51776:   }
 51776:   return aIfNotCoord;
     1: }
     1: 
     1: void
 68481: nsContainerFrame::DoInlineIntrinsicWidth(nsRenderingContext *aRenderingContext,
     1:                                          InlineIntrinsicWidthData *aData,
     1:                                          nsLayoutUtils::IntrinsicWidthType aType)
     1: {
     1:   if (GetPrevInFlow())
     1:     return; // Already added.
     1: 
     1:   NS_PRECONDITION(aType == nsLayoutUtils::MIN_WIDTH ||
     1:                   aType == nsLayoutUtils::PREF_WIDTH, "bad type");
     1: 
 41419:   mozilla::css::Side startSide, endSide;
132812:   if (StyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR) {
     1:     startSide = NS_SIDE_LEFT;
     1:     endSide = NS_SIDE_RIGHT;
     1:   } else {
     1:     startSide = NS_SIDE_RIGHT;
     1:     endSide = NS_SIDE_LEFT;
     1:   }
     1: 
132812:   const nsStylePadding *stylePadding = StylePadding();
132812:   const nsStyleBorder *styleBorder = StyleBorder();
132812:   const nsStyleMargin *styleMargin = StyleMargin();
     1: 
     1:   // This goes at the beginning no matter how things are broken and how
     1:   // messy the bidi situations are, since per CSS2.1 section 8.6
     1:   // (implemented in bug 328168), the startSide border is always on the
     1:   // first line.
 12899:   // This frame is a first-in-flow, but it might have a previous bidi
 12899:   // continuation, in which case that continuation should handle the startSide
 12899:   // border.
 12899:   if (!GetPrevContinuation()) {
     1:     aData->currentLine +=
 52283:       // clamp negative calc() to 0
129543:       std::max(GetCoord(stylePadding->mPadding.Get(startSide), 0), 0) +
 99856:       styleBorder->GetComputedBorderWidth(startSide) +
 12630:       GetCoord(styleMargin->mMargin.Get(startSide), 0);
 12899:   }
     1: 
 10113:   const nsLineList_iterator* savedLine = aData->line;
 25237:   nsIFrame* const savedLineContainer = aData->lineContainer;
 10113: 
 12899:   nsContainerFrame *lastInFlow;
 10116:   for (nsContainerFrame *nif = this; nif;
 25237:        nif = static_cast<nsContainerFrame*>(nif->GetNextInFlow())) {
     1:     for (nsIFrame *kid = nif->mFrames.FirstChild(); kid;
     1:          kid = kid->GetNextSibling()) {
     1:       if (aType == nsLayoutUtils::MIN_WIDTH)
     1:         kid->AddInlineMinWidth(aRenderingContext,
  3233:                                static_cast<InlineMinWidthData*>(aData));
     1:       else
     1:         kid->AddInlinePrefWidth(aRenderingContext,
  3233:                                 static_cast<InlinePrefWidthData*>(aData));
     1:     }
 10113: 
 25237:     // After we advance to our next-in-flow, the stored line and line container
 25237:     // may no longer be correct. Just forget them.
106838:     aData->line = nullptr;
106838:     aData->lineContainer = nullptr;
 25237: 
 12899:     lastInFlow = nif;
     1:   }
 10113: 
 10113:   aData->line = savedLine;
 25237:   aData->lineContainer = savedLineContainer;
     1: 
     1:   // This goes at the end no matter how things are broken and how
     1:   // messy the bidi situations are, since per CSS2.1 section 8.6
     1:   // (implemented in bug 328168), the endSide border is always on the
     1:   // last line.
 12899:   // We reached the last-in-flow, but it might have a next bidi
 12899:   // continuation, in which case that continuation should handle
 12899:   // the endSide border.
 12899:   if (!lastInFlow->GetNextContinuation()) {
     1:     aData->currentLine +=
 52283:       // clamp negative calc() to 0
129543:       std::max(GetCoord(stylePadding->mPadding.Get(endSide), 0), 0) +
 99856:       styleBorder->GetComputedBorderWidth(endSide) +
 12630:       GetCoord(styleMargin->mMargin.Get(endSide), 0);
     1:   }
 12899: }
     1: 
     1: /* virtual */ nsSize
 68481: nsContainerFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                                   nsSize aCBSize, nscoord aAvailableWidth,
     1:                                   nsSize aMargin, nsSize aBorder,
 79445:                                   nsSize aPadding, bool aShrinkWrap)
     1: {
     1:   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
     1:   nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
     1:                        aPadding.width;
     1:   // replaced elements always shrink-wrap
     1:   if (aShrinkWrap || IsFrameOfType(eReplaced)) {
     1:     // don't bother setting it if the result won't be used
132812:     if (StylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
     1:       result.width = ShrinkWidthToFit(aRenderingContext, availBased);
     1:     }
     1:   } else {
     1:     result.width = availBased;
     1:   }
     1:   return result;
     1: }
     1: 
     1: /**
     1:  * Invokes the WillReflow() function, positions the frame and its view (if
     1:  * requested), and then calls Reflow(). If the reflow succeeds and the child
     1:  * frame is complete, deletes any next-in-flows using DeleteNextInFlowChild()
     1:  */
     1: nsresult
     1: nsContainerFrame::ReflowChild(nsIFrame*                aKidFrame,
     1:                               nsPresContext*           aPresContext,
     1:                               nsHTMLReflowMetrics&     aDesiredSize,
     1:                               const nsHTMLReflowState& aReflowState,
     1:                               nscoord                  aX,
     1:                               nscoord                  aY,
108991:                               uint32_t                 aFlags,
  4006:                               nsReflowStatus&          aStatus,
  4006:                               nsOverflowContinuationTracker* aTracker)
     1: {
     1:   NS_PRECONDITION(aReflowState.frame == aKidFrame, "bad reflow state");
     1: 
     1:   nsresult  result;
     1: 
     1:   // Send the WillReflow() notification, and position the child frame
     1:   // and its view if requested
     1:   aKidFrame->WillReflow(aPresContext);
     1: 
 18884:   if (NS_FRAME_NO_MOVE_FRAME != (aFlags & NS_FRAME_NO_MOVE_FRAME)) {
     1:     aKidFrame->SetPosition(nsPoint(aX, aY));
     1:   }
     1: 
     1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
     1:     PositionFrameView(aKidFrame);
     1:   }
     1: 
     1:   // Reflow the child frame
     1:   result = aKidFrame->Reflow(aPresContext, aDesiredSize, aReflowState,
     1:                              aStatus);
     1: 
     1:   // If the reflow was successful and the child frame is complete, delete any
136175:   // next-in-flows, but only if the NO_DELETE_NEXT_IN_FLOW flag isn't set.
136175:   if (NS_SUCCEEDED(result) && NS_FRAME_IS_FULLY_COMPLETE(aStatus) &&
136175:       !(aFlags & NS_FRAME_NO_DELETE_NEXT_IN_FLOW_CHILD)) {
     1:     nsIFrame* kidNextInFlow = aKidFrame->GetNextInFlow();
106838:     if (nullptr != kidNextInFlow) {
     1:       // Remove all of the childs next-in-flows. Make sure that we ask
     1:       // the right parent to do the removal (it's possible that the
     1:       // parent is not this because we are executing pullup code)
  6521:       if (aTracker) aTracker->Finish(aKidFrame);
  3233:       static_cast<nsContainerFrame*>(kidNextInFlow->GetParent())
 80486:         ->DeleteNextInFlowChild(aPresContext, kidNextInFlow, true);
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: 
     1: /**
     1:  * Position the views of |aFrame|'s descendants. A container frame
     1:  * should call this method if it moves a frame after |Reflow|.
     1:  */
     1: void
     1: nsContainerFrame::PositionChildViews(nsIFrame* aFrame)
     1: {
     1:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
     1:     return;
     1:   }
     1: 
 77153:   // Recursively walk aFrame's child frames.
 77153:   // Process the additional child lists, but skip the popup list as the
 77153:   // view for popups is managed by the parent. Currently only nsMenuFrame
 77153:   // has a popupList and during layout will call nsMenuPopupFrame::AdjustView.
 77153:   ChildListIterator lists(aFrame);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     if (lists.CurrentID() == kPopupList) {
 77153:       continue;
 77153:     }
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
     1:       // Position the frame's view (if it has one) otherwise recursively
     1:       // process its children
 77153:       nsIFrame* childFrame = childFrames.get();
     1:       if (childFrame->HasView()) {
     1:         PositionFrameView(childFrame);
     1:       } else {
     1:         PositionChildViews(childFrame);
     1:       }
     1:     }
 77153:   }
     1: }
     1: 
     1: /**
     1:  * The second half of frame reflow. Does the following:
     1:  * - sets the frame's bounds
     1:  * - sizes and positions (if requested) the frame's view. If the frame's final
     1:  *   position differs from the current position and the frame itself does not
     1:  *   have a view, then any child frames with views are positioned so they stay
     1:  *   in sync
     1:  * - sets the view's visibility, opacity, content transparency, and clip
     1:  * - invoked the DidReflow() function
     1:  *
     1:  * Flags:
     1:  * NS_FRAME_NO_MOVE_FRAME - don't move the frame. aX and aY are ignored in this
     1:  *    case. Also implies NS_FRAME_NO_MOVE_VIEW
     1:  * NS_FRAME_NO_MOVE_VIEW - don't position the frame's view. Set this if you
     1:  *    don't want to automatically sync the frame and view
     1:  * NS_FRAME_NO_SIZE_VIEW - don't size the frame's view
     1:  */
     1: nsresult
     1: nsContainerFrame::FinishReflowChild(nsIFrame*                  aKidFrame,
     1:                                     nsPresContext*             aPresContext,
     1:                                     const nsHTMLReflowState*   aReflowState,
  9771:                                     const nsHTMLReflowMetrics& aDesiredSize,
     1:                                     nscoord                    aX,
     1:                                     nscoord                    aY,
108991:                                     uint32_t                   aFlags)
     1: {
     1:   nsPoint curOrigin = aKidFrame->GetPosition();
     1:   nsRect  bounds(aX, aY, aDesiredSize.width, aDesiredSize.height);
     1: 
     1:   aKidFrame->SetRect(bounds);
     1: 
     1:   if (aKidFrame->HasView()) {
127357:     nsView* view = aKidFrame->GetView();
     1:     // Make sure the frame's view is properly sized and positioned and has
     1:     // things like opacity correct
     1:     SyncFrameViewAfterReflow(aPresContext, aKidFrame, view,
 55039:                              aDesiredSize.VisualOverflow(), aFlags);
     1:   }
     1: 
     1:   if (!(aFlags & NS_FRAME_NO_MOVE_VIEW) &&
     1:       (curOrigin.x != aX || curOrigin.y != aY)) {
     1:     if (!aKidFrame->HasView()) {
     1:       // If the frame has moved, then we need to make sure any child views are
     1:       // correctly positioned
     1:       PositionChildViews(aKidFrame);
     1:     }
     1:   }
     1: 
121889:   return aKidFrame->DidReflow(aPresContext, aReflowState, nsDidReflowStatus::FINISHED);
     1: }
     1: 
  4006: nsresult
  4006: nsContainerFrame::ReflowOverflowContainerChildren(nsPresContext*           aPresContext,
  4006:                                                   const nsHTMLReflowState& aReflowState,
 55023:                                                   nsOverflowAreas&         aOverflowRects,
108991:                                                   uint32_t                 aFlags,
  4006:                                                   nsReflowStatus&          aStatus)
  4006: {
  4006:   NS_PRECONDITION(aPresContext, "null pointer");
  4006:   nsresult rv = NS_OK;
  4006: 
  4006:   nsFrameList* overflowContainers =
  4006:                GetPropTableFrames(aPresContext,
 39965:                                   OverflowContainersProperty());
  4006: 
  4006:   NS_ASSERTION(!(overflowContainers && GetPrevInFlow()
  4006:                  && static_cast<nsContainerFrame*>(GetPrevInFlow())
  4006:                       ->GetPropTableFrames(aPresContext,
 39965:                           ExcessOverflowContainersProperty())),
  4006:                "conflicting overflow containers lists");
  4006: 
  4006:   if (!overflowContainers) {
  4006:     // Drain excess from previnflow
  4006:     nsContainerFrame* prev = (nsContainerFrame*) GetPrevInFlow();
  4006:     if (prev) {
  4006:       nsFrameList* excessFrames =
  4006:         prev->RemovePropTableFrames(aPresContext,
 39965:                                     ExcessOverflowContainersProperty());
  4006:       if (excessFrames) {
 32843:         excessFrames->ApplySetParent(this);
 68656:         nsContainerFrame::ReparentFrameViewList(aPresContext, *excessFrames,
  4006:                                                 prev, this);
  4006:         overflowContainers = excessFrames;
  4006:         rv = SetPropTableFrames(aPresContext, overflowContainers,
 39965:                                 OverflowContainersProperty());
  4006:         if (NS_FAILED(rv)) {
  4006:           excessFrames->DestroyFrames();
  4006:           delete excessFrames;
  4006:           return rv;
  4006:         }
  4006:       }
  4006:     }
  4006:   }
  4006: 
  4006:   if (!overflowContainers)
  4006:     return NS_OK; // nothing to reflow
  4006: 
 80486:   nsOverflowContinuationTracker tracker(aPresContext, this, false, false);
 79445:   bool shouldReflowAllKids = aReflowState.ShouldReflowAllKids();
 42437: 
  4006:   for (nsIFrame* frame = overflowContainers->FirstChild(); frame;
  4006:        frame = frame->GetNextSibling()) {
 28158:     if (frame->GetPrevInFlow()->GetParent() != GetPrevInFlow()) {
 28158:       // frame's prevInFlow has moved, skip reflowing this frame;
 28158:       // it will get reflowed once it's been placed
 28158:       continue;
 28158:     }
 42437:     // If the available vertical height has changed, we need to reflow
 42437:     // even if the frame isn't dirty.
 42437:     if (shouldReflowAllKids || NS_SUBTREE_DIRTY(frame)) {
  4006:       // Get prev-in-flow
  4006:       nsIFrame* prevInFlow = frame->GetPrevInFlow();
  4006:       NS_ASSERTION(prevInFlow,
  4006:                    "overflow container frame must have a prev-in-flow");
  4006:       NS_ASSERTION(frame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER,
  4006:                    "overflow container frame must have overflow container bit set");
  4006:       nsRect prevRect = prevInFlow->GetRect();
  4006: 
  4006:       // Initialize reflow params
  4006:       nsSize availSpace(prevRect.width, aReflowState.availableHeight);
  4006:       nsHTMLReflowMetrics desiredSize;
  4006:       nsHTMLReflowState frameState(aPresContext, aReflowState,
  4006:                                    frame, availSpace);
133986:       nsReflowStatus frameStatus;
  4006: 
  4006:       // Reflow
  4006:       rv = ReflowChild(frame, aPresContext, desiredSize, frameState,
  6521:                        prevRect.x, 0, aFlags, frameStatus, &tracker);
  4006:       NS_ENSURE_SUCCESS(rv, rv);
  4006:       //XXXfr Do we need to override any shrinkwrap effects here?
  4006:       // e.g. desiredSize.width = prevRect.width;
  4006:       rv = FinishReflowChild(frame, aPresContext, &frameState, desiredSize,
  4006:                              prevRect.x, 0, aFlags);
  4006:       NS_ENSURE_SUCCESS(rv, rv);
  4006: 
  4006:       // Handle continuations
  6521:       if (!NS_FRAME_IS_FULLY_COMPLETE(frameStatus)) {
  6521:         if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
  6521:           // Abspos frames can't cause their parent to be incomplete,
  6521:           // only overflow incomplete.
  6521:           NS_FRAME_SET_OVERFLOW_INCOMPLETE(frameStatus);
  6521:         }
  6521:         else {
  4006:           NS_ASSERTION(NS_FRAME_IS_COMPLETE(frameStatus),
  4006:                        "overflow container frames can't be incomplete, only overflow-incomplete");
  6521:         }
  6521: 
  4006:         // Acquire a next-in-flow, creating it if necessary
  4006:         nsIFrame* nif = frame->GetNextInFlow();
  4006:         if (!nif) {
  4006:           NS_ASSERTION(frameStatus & NS_FRAME_REFLOW_NEXTINFLOW,
  4006:                        "Someone forgot a REFLOW_NEXTINFLOW flag");
 32841:           rv = aPresContext->PresShell()->FrameConstructor()->
 32841:                  CreateContinuingFrame(aPresContext, frame, this, &nif);
 32841:           NS_ENSURE_SUCCESS(rv, rv);
  4006:         }
  4006:         else if (!(nif->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
  4006:           // used to be a normal next-in-flow; steal it from the child list
  4006:           rv = static_cast<nsContainerFrame*>(nif->GetParent())
  4006:                  ->StealFrame(aPresContext, nif);
  4006:           NS_ENSURE_SUCCESS(rv, rv);
  4006:         }
  4006: 
  4006:         tracker.Insert(nif, frameStatus);
  4006:       }
 15183:       NS_MergeReflowStatusInto(&aStatus, frameStatus);
  4006:       // At this point it would be nice to assert !frame->GetOverflowRect().IsEmpty(),
  4006:       // but we have some unsplittable frames that, when taller than
  4006:       // availableHeight will push zero-height content into a next-in-flow.
  4006:     }
  4006:     else {
  4006:       tracker.Skip(frame, aStatus);
 32108:       if (aReflowState.mFloatManager)
 32108:         nsBlockFrame::RecoverFloatsFor(frame, *aReflowState.mFloatManager);
  4006:     }
 55023:     ConsiderChildOverflow(aOverflowRects, frame);
  4006:   }
  4006: 
  4006:   return NS_OK;
  4006: }
  4006: 
  4006: void
  4006: nsContainerFrame::DisplayOverflowContainers(nsDisplayListBuilder*   aBuilder,
  4006:                                             const nsRect&           aDirtyRect,
  4006:                                             const nsDisplayListSet& aLists)
  4006: {
 39965:   nsFrameList* overflowconts =
 39965:     GetPropTableFrames(PresContext(), OverflowContainersProperty());
  4006:   if (overflowconts) {
  4006:     for (nsIFrame* frame = overflowconts->FirstChild(); frame;
  4006:          frame = frame->GetNextSibling()) {
  4006:       BuildDisplayListForChild(aBuilder, frame, aDirtyRect, aLists);
  4006:     }
  4006:   }
  4006: }
  4006: 
134498: static bool
134498: TryRemoveFrame(nsIFrame* aFrame, FramePropertyTable* aPropTable,
134498:                const FramePropertyDescriptor* aProp, nsIFrame* aChildToRemove,
134498:                bool (nsFrameList::*aRemoveMethod)(nsIFrame* aFrame))
134498: {
134498:   nsFrameList* list = static_cast<nsFrameList*>(aPropTable->Get(aFrame, aProp));
134498:   if (list && (list->*aRemoveMethod)(aChildToRemove)) {
134498:     // aChildToRemove *may* have been removed from this list.
134498:     if (list->IsEmpty()) {
134498:       aPropTable->Remove(aFrame, aProp);
134498:       delete list;
134498:     }
134498:     return true;
134498:   }
134498:   return false;
134498: }
134498: 
  4006: nsresult
  4006: nsContainerFrame::StealFrame(nsPresContext* aPresContext,
  4006:                              nsIFrame*      aChild,
 79445:                              bool           aForceNormal)
  4006: {
134498: #ifdef DEBUG
134498:   if (!mFrames.ContainsFrame(aChild)) {
134498:     FramePropertyTable* propTable = aPresContext->PropertyTable();
134498:     nsFrameList* list = static_cast<nsFrameList*>(
134498:                           propTable->Get(this, OverflowContainersProperty()));
134498:     if (!list || !list->ContainsFrame(aChild)) {
134498:       list = static_cast<nsFrameList*>(
134498:                propTable->Get(this, ExcessOverflowContainersProperty()));
134498:       MOZ_ASSERT(list && list->ContainsFrame(aChild), "aChild is not our child "
134498:                  "or on a frame list not supported by StealFrame");
134498:     }
134498:   }
134498: #endif
134498: 
134498:   bool removed;
  4006:   if ((aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
  4006:       && !aForceNormal) {
134498:     FramePropertyTable* propTable = aPresContext->PropertyTable();
134498:     // Try removing from the overflow container list.
134498:     removed = ::TryRemoveFrame(this, propTable, OverflowContainersProperty(),
134498:                                aChild, &nsFrameList::StartRemoveFrame);
134498:     if (!removed) {
134498:       // It must be in the excess overflow container list.
134498:       removed = ::TryRemoveFrame(this, propTable,
134498:                                  ExcessOverflowContainersProperty(),
134498:                                  aChild, &nsFrameList::ContinueRemoveFrame);
  4006:     }
134498:   } else {
134498:     removed = mFrames.StartRemoveFrame(aChild);
134498:     if (!removed) {
134498:       // We didn't find the child in our principal child list.
  4006:       // Maybe it's on the overflow list?
 30781:       nsFrameList* frameList = GetOverflowFrames();
 30781:       if (frameList) {
134498:         removed = frameList->ContinueRemoveFrame(aChild);
 30781:         if (frameList->IsEmpty()) {
106838:           DestroyOverflowList(aPresContext, nullptr);
 30781:         }
  4006:       }
  4006:     }
  4006:   }
 32844: 
 32844:   NS_POSTCONDITION(removed, "StealFrame: can't find aChild");
 32844:   return removed ? NS_OK : NS_ERROR_UNEXPECTED;
  4006: }
  4006: 
 32841: nsFrameList
 32841: nsContainerFrame::StealFramesAfter(nsIFrame* aChild)
 32841: {
 32841:   NS_ASSERTION(!aChild ||
 32841:                !(aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER),
 32841:                "StealFramesAfter doesn't handle overflow containers");
 32841:   NS_ASSERTION(GetType() != nsGkAtoms::blockFrame, "unexpected call");
 32841: 
 32841:   if (!aChild) {
 32841:     nsFrameList copy(mFrames);
 32841:     mFrames.Clear();
 32841:     return copy;
 32841:   }
 32841: 
 32841:   for (nsFrameList::FrameLinkEnumerator iter(mFrames); !iter.AtEnd();
 32841:        iter.Next()) {
 32841:     if (iter.PrevFrame() == aChild) {
 32841:       return mFrames.ExtractTail(iter);
 32841:     }
 32841:   }
 32841: 
 32841:   // We didn't find the child in the principal child list.
 32841:   // Maybe it's on the overflow list?
 32841:   nsFrameList* overflowFrames = GetOverflowFrames();
 32841:   if (overflowFrames) {
 32841:     for (nsFrameList::FrameLinkEnumerator iter(*overflowFrames); !iter.AtEnd();
 32841:          iter.Next()) {
 32841:       if (iter.PrevFrame() == aChild) {
 32841:         return overflowFrames->ExtractTail(iter);
 32841:       }
 32841:     }
 32841:   }
 32841: 
 32841:   NS_ERROR("StealFramesAfter: can't find aChild");
 32841:   return nsFrameList::EmptyList();
 32841: }
 32841: 
 30781: void
 36647: nsContainerFrame::DestroyOverflowList(nsPresContext* aPresContext,
 36647:                                       nsIFrame*      aDestructRoot)
 30781: {
 30781:   nsFrameList* list =
 39965:     RemovePropTableFrames(aPresContext, OverflowProperty());
 50444:   if (list) {
 50444:     if (aDestructRoot)
 36647:       list->DestroyFrom(aDestructRoot);
 50444:     else
 50444:       list->Destroy();
 50444:   }
 30781: }
 30781: 
 86231: /*
 86231:  * Create a next-in-flow for aFrame. Will return the newly created
 86231:  * frame in aNextInFlowResult <b>if and only if</b> a new frame is
106838:  * created; otherwise nullptr is returned in aNextInFlowResult.
 86231:  */
 86231: nsresult
 86231: nsContainerFrame::CreateNextInFlow(nsPresContext* aPresContext,
 86231:                                    nsIFrame*      aFrame,
 86231:                                    nsIFrame*&     aNextInFlowResult)
 86231: {
 86231:   NS_PRECONDITION(GetType() != nsGkAtoms::blockFrame,
 86231:                   "you should have called nsBlockFrame::CreateContinuationFor instead");
 86231:   NS_PRECONDITION(mFrames.ContainsFrame(aFrame), "expected an in-flow child frame");
 86231: 
106838:   aNextInFlowResult = nullptr;
 86231: 
 86231:   nsIFrame* nextInFlow = aFrame->GetNextInFlow();
106838:   if (nullptr == nextInFlow) {
 86231:     // Create a continuation frame for the child frame and insert it
 86231:     // into our child list.
 86231:     nsresult rv = aPresContext->PresShell()->FrameConstructor()->
 86231:       CreateContinuingFrame(aPresContext, aFrame, this, &nextInFlow);
 86231:     if (NS_FAILED(rv)) {
 86231:       return rv;
 86231:     }
106838:     mFrames.InsertFrame(nullptr, aFrame, nextInFlow);
 86231: 
 86231:     NS_FRAME_LOG(NS_FRAME_TRACE_NEW_FRAMES,
 86231:        ("nsContainerFrame::CreateNextInFlow: frame=%p nextInFlow=%p",
 86231:         aFrame, nextInFlow));
 86231: 
 86231:     aNextInFlowResult = nextInFlow;
 86231:   }
 86231:   return NS_OK;
 86231: }
 86231: 
     1: /**
     1:  * Remove and delete aNextInFlow and its next-in-flows. Updates the sibling and flow
     1:  * pointers
     1:  */
     1: void
     1: nsContainerFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
 22195:                                         nsIFrame*      aNextInFlow,
 79445:                                         bool           aDeletingEmptyFrames)
     1: {
 19448: #ifdef DEBUG
 18981:   nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
 19448: #endif
 18981:   NS_PRECONDITION(prevInFlow, "bad prev-in-flow");
     1: 
     1:   // If the next-in-flow has a next-in-flow then delete it, too (and
     1:   // delete it first).
     1:   // Do this in a loop so we don't overflow the stack for frames
     1:   // with very many next-in-flows
     1:   nsIFrame* nextNextInFlow = aNextInFlow->GetNextInFlow();
     1:   if (nextNextInFlow) {
 24551:     nsAutoTArray<nsIFrame*, 8> frames;
     1:     for (nsIFrame* f = nextNextInFlow; f; f = f->GetNextInFlow()) {
     1:       frames.AppendElement(f);
     1:     }
108991:     for (int32_t i = frames.Length() - 1; i >= 0; --i) {
 24551:       nsIFrame* delFrame = frames.ElementAt(i);
  3233:       static_cast<nsContainerFrame*>(delFrame->GetParent())
 22195:         ->DeleteNextInFlowChild(aPresContext, delFrame, aDeletingEmptyFrames);
     1:     }
     1:   }
     1: 
     1:   // Take the next-in-flow out of the parent's child list
 19448: #ifdef DEBUG
 19448:   nsresult rv =
 19448: #endif
 19448:     StealFrame(aPresContext, aNextInFlow);
  4006:   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failure");
     1: 
 60341: #ifdef DEBUG
 60341:   if (aDeletingEmptyFrames) {
 60341:     nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(aNextInFlow);
 60341:   }
 60341: #endif
 60341: 
 22489:   // Delete the next-in-flow frame and its descendants. This will also
 22489:   // remove it from its next-in-flow/prev-in-flow chain.
     1:   aNextInFlow->Destroy();
     1: 
     1:   NS_POSTCONDITION(!prevInFlow->GetNextInFlow(), "non null next-in-flow");
     1: }
     1: 
 30781: /**
 30781:  * Set the frames on the overflow list
 30781:  */
 72505: void
 30781: nsContainerFrame::SetOverflowFrames(nsPresContext* aPresContext,
 30781:                                     const nsFrameList& aOverflowFrames)
 30781: {
 30781:   NS_PRECONDITION(aOverflowFrames.NotEmpty(), "Shouldn't be called");
 30781:   nsFrameList* newList = new nsFrameList(aOverflowFrames);
 30781: 
 39965:   aPresContext->PropertyTable()->Set(this, OverflowProperty(), newList);
 30781: }
 30781: 
  4006: nsFrameList*
  4006: nsContainerFrame::GetPropTableFrames(nsPresContext*                 aPresContext,
 39965:                                      const FramePropertyDescriptor* aProperty) const
  4006: {
 39965:   FramePropertyTable* propTable = aPresContext->PropertyTable();
 39965:   return static_cast<nsFrameList*>(propTable->Get(this, aProperty));
  4006: }
  4006: 
  4006: nsFrameList*
  4006: nsContainerFrame::RemovePropTableFrames(nsPresContext*                 aPresContext,
 39965:                                         const FramePropertyDescriptor* aProperty)
  4006: {
 39965:   FramePropertyTable* propTable = aPresContext->PropertyTable();
 39965:   return static_cast<nsFrameList*>(propTable->Remove(this, aProperty));
  4006: }
  4006: 
  4006: nsresult
  4006: nsContainerFrame::SetPropTableFrames(nsPresContext*                 aPresContext,
  4006:                                      nsFrameList*                   aFrameList,
 39965:                                      const FramePropertyDescriptor* aProperty)
  4006: {
 39965:   NS_PRECONDITION(aPresContext && aProperty && aFrameList, "null ptr");
 40719:   NS_PRECONDITION(
 40719:     (aProperty != nsContainerFrame::OverflowContainersProperty() &&
 40719:      aProperty != nsContainerFrame::ExcessOverflowContainersProperty()) ||
 40719:     IsFrameOfType(nsIFrame::eCanContainOverflowContainers),
 40719:     "this type of frame can't have overflow containers");
 39965:   aPresContext->PropertyTable()->Set(this, aProperty, aFrameList);
 39965:   return NS_OK;
  4006: }
  4006: 
     1: /**
     1:  * Push aFromChild and its next siblings to the next-in-flow. Change the
     1:  * geometric parent of each frame that's pushed. If there is no next-in-flow
     1:  * the frames are placed on the overflow list (and the geometric parent is
     1:  * left unchanged).
     1:  *
     1:  * Updates the next-in-flow's child count. Does <b>not</b> update the
     1:  * pusher's child count.
     1:  *
     1:  * @param   aFromChild the first child frame to push. It is disconnected from
     1:  *            aPrevSibling
     1:  * @param   aPrevSibling aFromChild's previous sibling. Must not be null. It's
     1:  *            an error to push a parent's first child frame
     1:  */
     1: void
     1: nsContainerFrame::PushChildren(nsPresContext* aPresContext,
     1:                                nsIFrame*       aFromChild,
     1:                                nsIFrame*       aPrevSibling)
     1: {
 32841:   NS_PRECONDITION(aFromChild, "null pointer");
 32841:   NS_PRECONDITION(aPrevSibling, "pushing first child");
     1:   NS_PRECONDITION(aPrevSibling->GetNextSibling() == aFromChild, "bad prev sibling");
     1: 
     1:   // Disconnect aFromChild from its previous sibling
 32841:   nsFrameList tail = mFrames.RemoveFramesAfter(aPrevSibling);
     1: 
 32841:   nsContainerFrame* nextInFlow =
 32841:     static_cast<nsContainerFrame*>(GetNextInFlow());
 32841:   if (nextInFlow) {
     1:     // XXX This is not a very good thing to do. If it gets removed
     1:     // then remove the copy of this routine that doesn't do this from
     1:     // nsInlineFrame.
     1:     // When pushing and pulling frames we need to check for whether any
     1:     // views need to be reparented.
     1:     for (nsIFrame* f = aFromChild; f; f = f->GetNextSibling()) {
 68656:       nsContainerFrame::ReparentFrameView(aPresContext, f, this, nextInFlow);
     1:     }
106838:     nextInFlow->mFrames.InsertFrames(nextInFlow, nullptr, tail);
     1:   }
     1:   else {
     1:     // Add the frames to our overflow list
 32846:     SetOverflowFrames(aPresContext, tail);
     1:   }
     1: }
     1: 
     1: /**
     1:  * Moves any frames on the overflow lists (the prev-in-flow's overflow list and
     1:  * the receiver's overflow list) to the child list.
     1:  *
     1:  * Updates this frame's child count and content mapping.
     1:  *
 80486:  * @return  true if any frames were moved and false otherwise
     1:  */
 79445: bool
     1: nsContainerFrame::MoveOverflowToChildList(nsPresContext* aPresContext)
     1: {
 79445:   bool result = false;
     1: 
     1:   // Check for an overflow list with our prev-in-flow
     1:   nsContainerFrame* prevInFlow = (nsContainerFrame*)GetPrevInFlow();
106838:   if (nullptr != prevInFlow) {
 30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
     1:     if (prevOverflowFrames) {
 30781:       // Tables are special; they can have repeated header/footer
 30781:       // frames on mFrames at this point.
 30781:       NS_ASSERTION(mFrames.IsEmpty() || GetType() == nsGkAtoms::tableFrame,
 30781:                    "bad overflow list");
     1:       // When pushing and pulling frames we need to check for whether any
     1:       // views need to be reparented.
 68656:       nsContainerFrame::ReparentFrameViewList(aPresContext,
 30781:                                               *prevOverflowFrames,
 30781:                                               prevInFlow, this);
 30781:       mFrames.AppendFrames(this, *prevOverflowFrames);
 80486:       result = true;
     1:     }
     1:   }
     1: 
114181:   // It's also possible that we have an overflow list for ourselves.
114181:   return DrainSelfOverflowList() || result;
114181: }
114181: 
114181: bool
114181: nsContainerFrame::DrainSelfOverflowList()
114181: {
 30781:   nsAutoPtr<nsFrameList> overflowFrames(StealOverflowFrames());
     1:   if (overflowFrames) {
     1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
106838:     mFrames.AppendFrames(nullptr, *overflowFrames);
114181:     return true;
     1:   }
114181:   return false;
     1: }
     1: 
  4006: nsOverflowContinuationTracker::nsOverflowContinuationTracker(nsPresContext*    aPresContext,
  4006:                                                              nsContainerFrame* aFrame,
 79445:                                                              bool              aWalkOOFFrames,
 79445:                                                              bool              aSkipOverflowContainerChildren)
106838:   : mOverflowContList(nullptr),
106838:     mPrevOverflowCont(nullptr),
106838:     mSentry(nullptr),
  4006:     mParent(aFrame),
  6521:     mSkipOverflowContainerChildren(aSkipOverflowContainerChildren),
  6521:     mWalkOOFFrames(aWalkOOFFrames)
  4006: {
  4006:   NS_PRECONDITION(aFrame, "null frame pointer");
  4006:   nsContainerFrame* next = static_cast<nsContainerFrame*>
  4006:                              (aFrame->GetNextInFlow());
  4006:   if (next) {
 39965:     mOverflowContList = next->GetPropTableFrames(aPresContext,
 39965:       nsContainerFrame::OverflowContainersProperty());
  4006:     if (mOverflowContList) {
  4006:       mParent = next;
  4006:       SetUpListWalker();
  4006:     }
  4006:   }
  6758:   if (!mOverflowContList) {
 39965:     mOverflowContList = mParent->GetPropTableFrames(aPresContext,
 39965:       nsContainerFrame::ExcessOverflowContainersProperty());
  4006:     if (mOverflowContList) {
  4006:       SetUpListWalker();
  4006:     }
  4006:   }
  4006: }
  4006: 
  4006: /**
  4006:  * Helper function to walk past overflow continuations whose prev-in-flow
  4006:  * isn't a normal child and to set mSentry and mPrevOverflowCont correctly.
  4006:  */
  4006: void
  4006: nsOverflowContinuationTracker::SetUpListWalker()
  4006: {
  4006:   NS_ASSERTION(!mSentry && !mPrevOverflowCont,
  4006:                "forgot to reset mSentry or mPrevOverflowCont");
  4006:   if (mOverflowContList) {
  4006:     nsIFrame* cur = mOverflowContList->FirstChild();
  4006:     if (mSkipOverflowContainerChildren) {
  4006:       while (cur && (cur->GetPrevInFlow()->GetStateBits()
  4006:                      & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
  4006:         mPrevOverflowCont = cur;
  4006:         cur = cur->GetNextSibling();
  4006:       }
  8531:       while (cur && (!(cur->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
  8531:                      == mWalkOOFFrames)) {
  6521:         mPrevOverflowCont = cur;
  6521:         cur = cur->GetNextSibling();
  6521:       }
  4006:     }
  4006:     if (cur) {
  4006:       mSentry = cur->GetPrevInFlow();
  4006:     }
  4006:   }
  4006: }
  4006: 
  4006: /**
  4006:  * Helper function to step forward through the overflow continuations list.
  6521:  * Sets mSentry and mPrevOverflowCont, skipping over OOF or non-OOF frames
  6521:  * as appropriate. May only be called when we have already set up an
  6521:  * mOverflowContList; mOverflowContList cannot be null.
  4006:  */
  4006: void
  4006: nsOverflowContinuationTracker::StepForward()
  4006: {
  4006:   NS_PRECONDITION(mOverflowContList, "null list");
  4006: 
  4006:   // Step forward
  4006:   if (mPrevOverflowCont) {
  4006:     mPrevOverflowCont = mPrevOverflowCont->GetNextSibling();
  4006:   }
  4006:   else {
  4006:     mPrevOverflowCont = mOverflowContList->FirstChild();
  4006:   }
  4006: 
  6521:   // Skip over oof or non-oof frames as appropriate
  6521:   if (mSkipOverflowContainerChildren) {
  6521:     nsIFrame* cur = mPrevOverflowCont->GetNextSibling();
  8531:     while (cur && (!(cur->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
  8531:                    == mWalkOOFFrames)) {
  6521:       mPrevOverflowCont = cur;
  6521:       cur = cur->GetNextSibling();
  6521:     }
  6521:   }
  6521: 
  4006:   // Set up the sentry
  4006:   mSentry = (mPrevOverflowCont->GetNextSibling())
  4006:             ? mPrevOverflowCont->GetNextSibling()->GetPrevInFlow()
106838:             : nullptr;
  4006: }
  4006: 
  4006: nsresult
  4006: nsOverflowContinuationTracker::Insert(nsIFrame*       aOverflowCont,
  4006:                                       nsReflowStatus& aReflowStatus)
  4006: {
  4006:   NS_PRECONDITION(aOverflowCont, "null frame pointer");
  8531:   NS_PRECONDITION(!mSkipOverflowContainerChildren || mWalkOOFFrames ==
  8531:                   !!(aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
  8531:                   "shouldn't insert frame that doesn't match walker type");
  4006:   NS_PRECONDITION(aOverflowCont->GetPrevInFlow(),
  4006:                   "overflow containers must have a prev-in-flow");
  4006:   nsresult rv = NS_OK;
130477:   bool reparented = false;
 18883:   nsPresContext* presContext = aOverflowCont->PresContext();
130477:   const bool addToList = !mSentry || aOverflowCont != mSentry->GetNextInFlow();
130477:   if (addToList) {
  8049:     if (aOverflowCont->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
  8049:       // aOverflowCont is in some other overflow container list,
  4006:       // steal it first
  8049:       NS_ASSERTION(!(mOverflowContList &&
  8049:                      mOverflowContList->ContainsFrame(aOverflowCont)),
  8049:                    "overflow containers out of order");
  4006:       rv = static_cast<nsContainerFrame*>(aOverflowCont->GetParent())
  4006:              ->StealFrame(presContext, aOverflowCont);
  4006:       NS_ENSURE_SUCCESS(rv, rv);
  4006:     }
  4006:     else {
  4006:       aOverflowCont->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
  4006:     }
  4006:     if (!mOverflowContList) {
  4006:       mOverflowContList = new nsFrameList();
 39965:       rv = mParent->SetPropTableFrames(presContext, mOverflowContList,
 39965:         nsContainerFrame::ExcessOverflowContainersProperty());
  4006:       NS_ENSURE_SUCCESS(rv, rv);
  4006:       SetUpListWalker();
  4006:     }
  4006:     if (aOverflowCont->GetParent() != mParent) {
 68656:       nsContainerFrame::ReparentFrameView(presContext, aOverflowCont,
  4006:                                           aOverflowCont->GetParent(),
  4006:                                           mParent);
130477:       reparented = true;
  4006:     }
  4006:     mOverflowContList->InsertFrame(mParent, mPrevOverflowCont, aOverflowCont);
  4006:     aReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
  4006:   }
  4006: 
  4006:   // If we need to reflow it, mark it dirty
  4006:   if (aReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW)
  4006:     aOverflowCont->AddStateBits(NS_FRAME_IS_DIRTY);
  4006: 
  4006:   // It's in our list, just step forward
  4006:   StepForward();
  8531:   NS_ASSERTION(mPrevOverflowCont == aOverflowCont ||
  8531:                (mSkipOverflowContainerChildren &&
  8531:                 (mPrevOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW) !=
  8531:                 (aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW)),
  8531:               "OverflowContTracker in unexpected state");
 18883: 
130477:   if (addToList) {
 18883:     // Convert all non-overflow-container continuations of aOverflowCont
 18883:     // into overflow containers and move them to our overflow
 18883:     // tracker. This preserves the invariant that the next-continuations
 18883:     // of an overflow container are also overflow containers.
 18883:     nsIFrame* f = aOverflowCont->GetNextContinuation();
130477:     if (f && (!(f->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) ||
130477:               (!reparented && f->GetParent() == mParent) ||
130477:               (reparented && f->GetParent() != mParent))) {
130477:       if (!(f->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 18883:         nsContainerFrame* parent = static_cast<nsContainerFrame*>(f->GetParent());
 18883:         rv = parent->StealFrame(presContext, f);
 18883:         NS_ENSURE_SUCCESS(rv, rv);
130477:       }
 18883:       Insert(f, aReflowStatus);
 18883:     }
 18883:   }
  4006:   return rv;
  4006: }
  4006: 
  4006: void
  4006: nsOverflowContinuationTracker::Finish(nsIFrame* aChild)
  4006: {
  4006:   NS_PRECONDITION(aChild, "null ptr");
  4006:   NS_PRECONDITION(aChild->GetNextInFlow(),
  6521:                   "supposed to call Finish *before* deleting next-in-flow!");
 18883: 
 97579:   for (nsIFrame* f = aChild; f; ) {
 97579:     // Make sure we drop all references if all the frames in the
 97579:     // overflow containers list are about to be destroyed.
 97579:     nsIFrame* nif = f->GetNextInFlow();
 42242:     if (mOverflowContList &&
 97579:         mOverflowContList->FirstChild() == nif &&
 97579:         (!nif->GetNextSibling() ||
 97579:          nif->GetNextSibling() == nif->GetNextInFlow())) {
106838:       mOverflowContList = nullptr;
106838:       mPrevOverflowCont = nullptr;
106838:       mSentry = nullptr;
 18883:       mParent = static_cast<nsContainerFrame*>(f->GetParent());
 18883:       break;
  4006:     }
 42242:     if (f == mSentry) {
  8531:       // Step past aChild
  6521:       nsIFrame* prevOverflowCont = mPrevOverflowCont;
  6521:       StepForward();
 97579:       if (mPrevOverflowCont == nif) {
  8531:         // Pull mPrevOverflowChild back to aChild's prevSibling:
  8531:         // aChild will be removed from our list by our caller
  6521:         mPrevOverflowCont = prevOverflowCont;
  4006:       }
  4006:     }
 97579:     f = nif;
  4006:   }
  8531: }
  4006: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // Debugging
     1: 
102909: #ifdef DEBUG
     1: NS_IMETHODIMP
114372: nsContainerFrame::List(FILE* out, int32_t aIndent, uint32_t aFlags) const
     1: {
     1:   IndentBy(out, aIndent);
     1:   ListTag(out);
     1: #ifdef DEBUG_waterson
  3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
     1: #endif
     1:   if (HasView()) {
  3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
     1:   }
 32845:   if (GetNextSibling()) {
 32845:     fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
     1:   }
106838:   if (nullptr != GetPrevContinuation()) {
  3233:     fprintf(out, " prev-continuation=%p", static_cast<void*>(GetPrevContinuation()));
     1:   }
106838:   if (nullptr != GetNextContinuation()) {
  3233:     fprintf(out, " next-continuation=%p", static_cast<void*>(GetNextContinuation()));
     1:   }
 39965:   void* IBsibling = Properties().Get(IBSplitSpecialSibling());
 34444:   if (IBsibling) {
 34444:     fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
 34444:   }
 39965:   void* IBprevsibling = Properties().Get(IBSplitSpecialPrevSibling());
 34444:   if (IBprevsibling) {
 34444:     fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
 34444:   }
     1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
     1:   if (0 != mState) {
 85981:     fprintf(out, " [state=%016llx]", (unsigned long long)mState);
     1:   }
  3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
  3233:   nsContainerFrame* f = const_cast<nsContainerFrame*>(this);
 55040:   if (f->HasOverflowAreas()) {
 55040:     nsRect overflowArea = f->GetVisualOverflowRect();
 55040:     fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
 55040:             overflowArea.width, overflowArea.height);
 55040:     overflowArea = f->GetScrollableOverflowRect();
 55040:     fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
 11909:             overflowArea.width, overflowArea.height);
     1:   }
  3233:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
 34387:   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
     1:   if (pseudoTag) {
     1:     nsAutoString atomString;
     1:     pseudoTag->ToString(atomString);
     1:     fprintf(out, " pst=%s",
     1:             NS_LossyConvertUTF16toASCII(atomString).get());
     1:   }
     1: 
     1:   // Output the children
 79445:   bool outputOneList = false;
 77153:   ChildListIterator lists(this);
 77153:   for (; !lists.IsDone(); lists.Next()) {
     1:     if (outputOneList) {
     1:       IndentBy(out, aIndent);
     1:     }
 80486:     outputOneList = true;
 77153:     fputs(mozilla::layout::ChildListName(lists.CurrentID()), out);
     1:     fputs("<\n", out);
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       nsIFrame* kid = childFrames.get();
     1:       // Verify the child frame's parent frame pointer is correct
 77153:       NS_ASSERTION(kid->GetParent() == this, "bad parent frame pointer");
     1: 
     1:       // Have the child frame list
114372:       kid->List(out, aIndent + 1, aFlags);
     1:     }
     1:     IndentBy(out, aIndent);
     1:     fputs(">\n", out);
     1:   }
     1: 
     1:   if (!outputOneList) {
     1:     fputs("<>\n", out);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: #endif
