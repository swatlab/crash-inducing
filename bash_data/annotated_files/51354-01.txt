  144: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  144: /* ***** BEGIN LICENSE BLOCK *****
  144:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  144:  *
  144:  * The contents of this file are subject to the Mozilla Public License Version
  144:  * 1.1 (the "License"); you may not use this file except in compliance with
  144:  * the License. You may obtain a copy of the License at
  144:  * http://www.mozilla.org/MPL/
  144:  *
  144:  * Software distributed under the License is distributed on an "AS IS" basis,
  144:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  144:  * for the specific language governing rights and limitations under the
  144:  * License.
  144:  *
  144:  * The Original Code is mozilla.org code.
  144:  *
  144:  * The Initial Developer of the Original Code is
  144:  * Mozilla Foundation.
  144:  * Portions created by the Initial Developer are Copyright (C) 2007
  144:  * the Initial Developer. All Rights Reserved.
  144:  *
  144:  * Contributor(s):
  144:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
  144:  *
  144:  * Alternatively, the contents of this file may be used under the terms of
  144:  * either of the GNU General Public License Version 2 or later (the "GPL"),
  144:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  144:  * in which case the provisions of the GPL or the LGPL are applicable instead
  144:  * of those above. If you wish to allow use of your version of this file only
  144:  * under the terms of either the GPL or the LGPL, and not to allow others to
  144:  * use your version of this file under the terms of the MPL, indicate your
  144:  * decision by deleting the provisions above and replace them with the notice
  144:  * and other provisions required by the GPL or the LGPL. If you do not delete
  144:  * the provisions above, a recipient may use your version of this file under
  144:  * the terms of any one of the MPL, the GPL or the LGPL.
  144:  *
  144:  * ***** END LICENSE BLOCK ***** */
  144: 
20521: #include "nsCoreUtils.h"
20536: #include "nsAccUtils.h"
 3152: 
 6646: #include "nsIAccessibleStates.h"
 5245: #include "nsIAccessibleTypes.h"
20566: 
41384: #include "nsAccessibilityService.h"
41384: #include "nsAccessibilityAtoms.h"
41384: #include "nsAccessible.h"
41384: #include "nsAccTreeWalker.h"
41384: #include "nsARIAMap.h"
41384: #include "nsDocAccessible.h"
20566: #include "nsHyperTextAccessible.h"
28316: #include "nsHTMLTableAccessible.h"
31673: #include "nsXULTreeGridAccessible.h"
20566: 
11581: #include "nsIDOMXULContainerElement.h"
  144: #include "nsIDOMXULSelectCntrlEl.h"
  144: #include "nsIDOMXULSelectCntrlItemEl.h"
 7830: #include "nsWhitespaceTokenizer.h"
32381: #include "nsComponentManagerUtils.h"
 5245: 
  144: void
20536: nsAccUtils::GetAccAttr(nsIPersistentProperties *aAttributes,
20521:                        nsIAtom *aAttrName, nsAString& aAttrValue)
  144: {
 6099:   aAttrValue.Truncate();
 6099: 
39101:   aAttributes->GetStringProperty(nsAtomCString(aAttrName), aAttrValue);
  144: }
  144: 
  144: void
20536: nsAccUtils::SetAccAttr(nsIPersistentProperties *aAttributes,
20521:                        nsIAtom *aAttrName, const nsAString& aAttrValue)
  144: {
  144:   nsAutoString oldValue;
  144:   nsCAutoString attrName;
  144: 
39101:   aAttributes->SetStringProperty(nsAtomCString(aAttrName), aAttrValue, oldValue);
  144: }
  144: 
  144: void
20536: nsAccUtils::SetAccGroupAttrs(nsIPersistentProperties *aAttributes,
36879:                              PRInt32 aLevel, PRInt32 aSetSize,
36879:                              PRInt32 aPosInSet)
  144: {
  144:   nsAutoString value;
  144: 
  144:   if (aLevel) {
  144:     value.AppendInt(aLevel);
  144:     SetAccAttr(aAttributes, nsAccessibilityAtoms::level, value);
  144:   }
  144: 
  401:   if (aSetSize && aPosInSet) {
  144:     value.Truncate();
  144:     value.AppendInt(aPosInSet);
  144:     SetAccAttr(aAttributes, nsAccessibilityAtoms::posinset, value);
  144: 
  144:     value.Truncate();
  401:     value.AppendInt(aSetSize);
  144:     SetAccAttr(aAttributes, nsAccessibilityAtoms::setsize, value);
  144:   }
  144: }
  144: 
37109: PRInt32
43539: nsAccUtils::GetDefaultLevel(nsAccessible *aAccessible)
37109: {
43539:   PRUint32 role = nsAccUtils::Role(aAccessible);
37109: 
37109:   if (role == nsIAccessibleRole::ROLE_OUTLINEITEM)
37109:     return 1;
37109: 
37109:   if (role == nsIAccessibleRole::ROLE_ROW) {
43539:     nsAccessible *parent = aAccessible->GetParent();
37109:     if (Role(parent) == nsIAccessibleRole::ROLE_TREE_TABLE) {
37109:       // It is a row inside flatten treegrid. Group level is always 1 until it
37109:       // is overriden by aria-level attribute.
37109:       return 1;
37109:     }
37109:   }
37109: 
37109:   return 0;
37109: }
37109: 
37109: PRInt32
43539: nsAccUtils::GetARIAOrDefaultLevel(nsAccessible *aAccessible)
37109: {
37109:   PRInt32 level = 0;
43539:   nsCoreUtils::GetUIntAttr(aAccessible->GetContent(),
43539:                            nsAccessibilityAtoms::aria_level, &level);
37109: 
37109:   if (level != 0)
37109:     return level;
37109: 
43539:   return GetDefaultLevel(aAccessible);
37109: }
37109: 
  144: void
43504: nsAccUtils::GetPositionAndSizeForXULSelectControlItem(nsIContent *aContent,
36879:                                                       PRInt32 *aPosInSet,
36879:                                                       PRInt32 *aSetSize)
  144: {
43504:   nsCOMPtr<nsIDOMXULSelectControlItemElement> item(do_QueryInterface(aContent));
  144:   if (!item)
  144:     return;
  144: 
  144:   nsCOMPtr<nsIDOMXULSelectControlElement> control;
  144:   item->GetControl(getter_AddRefs(control));
  144:   if (!control)
  144:     return;
  144: 
 6646:   PRUint32 itemsCount = 0;
  144:   control->GetItemCount(&itemsCount);
 6646: 
 6646:   PRInt32 indexOf = 0;
  144:   control->GetIndexOfItem(item, &indexOf);
  144: 
36879:   *aSetSize = itemsCount;
36879:   *aPosInSet = indexOf;
36879: 
 6646:   for (PRUint32 index = 0; index < itemsCount; index++) {
 6646:     nsCOMPtr<nsIDOMXULSelectControlItemElement> currItem;
 6646:     control->GetItemAtIndex(index, getter_AddRefs(currItem));
46340:     nsCOMPtr<nsINode> currNode(do_QueryInterface(currItem));
 6646: 
46340:     nsAccessible* itemAcc = GetAccService()->GetAccessible(currNode);
46340: 
 6646:     if (!itemAcc ||
20566:         State(itemAcc) & nsIAccessibleStates::STATE_INVISIBLE) {
36879:       (*aSetSize)--;
 7830:       if (index < static_cast<PRUint32>(indexOf))
36879:         (*aPosInSet)--;
 6646:     }
 6646:   }
 6646: 
36879:   (*aPosInSet)++; // group position is 1-index based.
  144: }
 1294: 
11581: void
43504: nsAccUtils::GetPositionAndSizeForXULContainerItem(nsIContent *aContent,
36879:                                                   PRInt32 *aPosInSet,
36879:                                                   PRInt32 *aSetSize)
11581: {
43504:   nsCOMPtr<nsIDOMXULContainerItemElement> item(do_QueryInterface(aContent));
11581:   if (!item)
11581:     return;
11581: 
11581:   nsCOMPtr<nsIDOMXULContainerElement> container;
11581:   item->GetParentContainer(getter_AddRefs(container));
11581:   if (!container)
11581:     return;
11581: 
11581:   // Get item count.
11581:   PRUint32 itemsCount = 0;
11581:   container->GetItemCount(&itemsCount);
11581: 
11581:   // Get item index.
11581:   PRInt32 indexOf = 0;
11581:   container->GetIndexOfItem(item, &indexOf);
11581: 
15757:   // Calculate set size and position in the set.
36879:   *aSetSize = 0, *aPosInSet = 0;
15757:   for (PRInt32 index = indexOf; index >= 0; index--) {
15757:     nsCOMPtr<nsIDOMXULElement> item;
15757:     container->GetItemAtIndex(index, getter_AddRefs(item));
46340:     nsCOMPtr<nsINode> itemNode(do_QueryInterface(item));
11581: 
46340:     nsAccessible* itemAcc = GetAccService()->GetAccessible(itemNode);
15757: 
15757:     if (itemAcc) {
20566:       PRUint32 itemRole = Role(itemAcc);
15757:       if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
15757:         break; // We reached the beginning of our group.
15757: 
20566:       PRUint32 itemState = State(itemAcc);
15757:       if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE)) {
36879:         (*aSetSize)++;
36879:         (*aPosInSet)++;
15757:       }
15757:     }
15757:   }
15757: 
20536:   for (PRInt32 index = indexOf + 1; index < static_cast<PRInt32>(itemsCount);
20536:        index++) {
15757:     nsCOMPtr<nsIDOMXULElement> item;
15757:     container->GetItemAtIndex(index, getter_AddRefs(item));
46340:     nsCOMPtr<nsINode> itemNode(do_QueryInterface(item));
15757:     
46340:     nsAccessible* itemAcc = GetAccService()->GetAccessible(itemNode);
15757: 
15757:     if (itemAcc) {
20566:       PRUint32 itemRole = Role(itemAcc);
15757:       if (itemRole == nsIAccessibleRole::ROLE_SEPARATOR)
15757:         break; // We reached the end of our group.
15757: 
20566:       PRUint32 itemState = State(itemAcc);
15757:       if (!(itemState & nsIAccessibleStates::STATE_INVISIBLE))
36879:         (*aSetSize)++;
11581:     }
11581:   }
36879: }
36879: 
36879: PRInt32
43504: nsAccUtils::GetLevelForXULContainerItem(nsIContent *aContent)
36879: {
43504:   nsCOMPtr<nsIDOMXULContainerItemElement> item(do_QueryInterface(aContent));
36879:   if (!item)
36879:     return 0;
36879: 
36879:   nsCOMPtr<nsIDOMXULContainerElement> container;
36879:   item->GetParentContainer(getter_AddRefs(container));
36879:   if (!container)
36879:     return 0;
11581: 
11581:   // Get level of the item.
11581:   PRInt32 level = -1;
11581:   while (container) {
11581:     level++;
11581: 
11581:     nsCOMPtr<nsIDOMXULContainerElement> parentContainer;
11581:     container->GetParentContainer(getter_AddRefs(parentContainer));
11581:     parentContainer.swap(container);
11581:   }
11581: 
36879:   return level;
11581: }
11581: 
20536: void
20536: nsAccUtils::SetLiveContainerAttributes(nsIPersistentProperties *aAttributes,
20536:                                        nsIContent *aStartContent,
20536:                                        nsIContent *aTopContent)
 1294: {
23582:   nsAutoString atomic, live, relevant, busy;
20536:   nsIContent *ancestor = aStartContent;
20536:   while (ancestor) {
25174: 
25174:     // container-relevant attribute
20536:     if (relevant.IsEmpty() &&
23549:         nsAccUtils::HasDefinedARIAToken(ancestor, nsAccessibilityAtoms::aria_relevant) &&
20536:         ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_relevant, relevant))
20536:       SetAccAttr(aAttributes, nsAccessibilityAtoms::containerRelevant, relevant);
 1294: 
29394:     // container-live, and container-live-role attributes
25174:     if (live.IsEmpty()) {
43504:       nsRoleMapEntry *role = GetRoleMapEntry(ancestor);
25174:       if (nsAccUtils::HasDefinedARIAToken(ancestor,
25174:                                           nsAccessibilityAtoms::aria_live)) {
25174:         ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_live,
25174:                           live);
29394:       } else if (role) {
29394:         GetLiveAttrValue(role->liveAttRule, live);
29394:       }
29394:       if (!live.IsEmpty()) {
20536:         SetAccAttr(aAttributes, nsAccessibilityAtoms::containerLive, live);
25174:         if (role) {
29290:           nsAccUtils::SetAccAttr(aAttributes,
29290:                                  nsAccessibilityAtoms::containerLiveRole,
29290:                                  NS_ConvertASCIItoUTF16(role->roleString));
25174:         }
25174:       }
25174:     }
20536: 
25174:     // container-atomic attribute
20536:     if (atomic.IsEmpty() &&
23549:         nsAccUtils::HasDefinedARIAToken(ancestor, nsAccessibilityAtoms::aria_atomic) &&
20536:         ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_atomic, atomic))
20536:       SetAccAttr(aAttributes, nsAccessibilityAtoms::containerAtomic, atomic);
20536: 
25174:     // container-busy attribute
20536:     if (busy.IsEmpty() &&
23549:         nsAccUtils::HasDefinedARIAToken(ancestor, nsAccessibilityAtoms::aria_busy) &&
20536:         ancestor->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_busy, busy))
20536:       SetAccAttr(aAttributes, nsAccessibilityAtoms::containerBusy, busy);
20536: 
20536:     if (ancestor == aTopContent)
20536:       break;
20536: 
20536:     ancestor = ancestor->GetParent();
20536:     if (!ancestor)
20536:       ancestor = aTopContent; // Use <body>/<frameset>
20536:   }
 1294: }
 1294: 
16427: PRBool
23549: nsAccUtils::HasDefinedARIAToken(nsIContent *aContent, nsIAtom *aAtom)
23549: {
27511:   NS_ASSERTION(aContent, "aContent is null in call to HasDefinedARIAToken!");
27511: 
23549:   if (!aContent->HasAttr(kNameSpaceID_None, aAtom) ||
23549:       aContent->AttrValueIs(kNameSpaceID_None, aAtom,
23549:                             nsAccessibilityAtoms::_empty, eCaseMatters) ||
23549:       aContent->AttrValueIs(kNameSpaceID_None, aAtom,
23549:                             nsAccessibilityAtoms::_undefined, eCaseMatters)) {
23549:         return PR_FALSE;
23549:   }
23549:   return PR_TRUE;
23549: }
23549: 
24654: PRBool
43504: nsAccUtils::HasAccessibleChildren(nsINode *aNode)
24654: {
24654:   if (!aNode)
24654:     return PR_FALSE;
24654: 
42374:   nsIPresShell *presShell = nsCoreUtils::GetPresShellFor(aNode);
24654:   if (!presShell)
24654:     return PR_FALSE;
24654: 
43504:   nsIContent *content = nsCoreUtils::GetRoleContent(aNode);
24654:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(presShell));
38358:   nsAccTreeWalker walker(weakShell, content, PR_FALSE);
38359:   nsRefPtr<nsAccessible> accessible = walker.GetNextChild();
38358:   return accessible ? PR_TRUE : PR_FALSE;
24654: }
24654: 
43504: nsAccessible *
43504: nsAccUtils::GetAncestorWithRole(nsAccessible *aDescendant, PRUint32 aRole)
 4846: {
43504:   nsAccessible *document = aDescendant->GetDocAccessible();
43504:   nsAccessible *parent = aDescendant;
43504:   while ((parent = parent->GetParent())) {
43504:     PRUint32 testRole = nsAccUtils::Role(parent);
43504:     if (testRole == aRole)
43504:       return parent;
43504: 
43504:     if (parent == document)
 4846:       break;
 4846:   }
 4846:   return nsnull;
 4846: }
 5245: 
43504: nsAccessible *
43504: nsAccUtils::GetSelectableContainer(nsAccessible *aAccessible, PRUint32 aState)
35584: {
35584:   if (!aAccessible)
35584:     return nsnull;
35584: 
35584:   if (!(aState & nsIAccessibleStates::STATE_SELECTABLE))
35584:     return nsnull;
35584: 
35584:   nsCOMPtr<nsIAccessibleSelectable> container;
43504:   nsAccessible *parent = aAccessible;
35584:   while (!container) {
43504:     parent = parent->GetParent();
35584:     if (!parent || Role(parent) == nsIAccessibleRole::ROLE_PANE)
35584:       return nsnull;
35584: 
43504:     container = do_QueryObject(parent);
35584:   }
35584: 
43504:   return parent;
35584: }
35584: 
43504: nsAccessible *
43504: nsAccUtils::GetMultiSelectableContainer(nsINode *aNode)
35584: {
43504:   nsAccessible *accessible = GetAccService()->GetAccessible(aNode);
43504:   nsAccessible *container = GetSelectableContainer(accessible,
43504:                                                    State(accessible));
35584: 
35584:   if (State(container) & nsIAccessibleStates::STATE_MULTISELECTABLE)
43504:     return container;
35584:   return nsnull;
35584: }
35584: 
32381: PRBool
43539: nsAccUtils::IsARIASelected(nsAccessible *aAccessible)
32381: {
43539:   return aAccessible->GetContent()->
43539:     AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected,
43539:                 nsAccessibilityAtoms::_true, eCaseMatters);
32381: }
32381: 
43537: already_AddRefed<nsHyperTextAccessible>
20999: nsAccUtils::GetTextAccessibleFromSelection(nsISelection *aSelection,
43504:                                            nsINode **aNode)
20999: {
20999:   // Get accessible from selection's focus DOM point (the DOM point where
20999:   // selection is ended).
20999: 
42796:   nsCOMPtr<nsIDOMNode> focusDOMNode;
42796:   aSelection->GetFocusNode(getter_AddRefs(focusDOMNode));
42796:   if (!focusDOMNode)
20999:     return nsnull;
20999: 
22834:   PRInt32 focusOffset = 0;
22834:   aSelection->GetFocusOffset(&focusOffset);
20999: 
42796:   nsCOMPtr<nsINode> focusNode(do_QueryInterface(focusDOMNode));
42796:   nsCOMPtr<nsINode> resultNode =
22834:     nsCoreUtils::GetDOMNodeFromDOMPoint(focusNode, focusOffset);
46469:   nsCOMPtr<nsIWeakReference> weakShell(nsCoreUtils::GetWeakShellFor(resultNode));
20999: 
20999:   // Get text accessible containing the result node.
46469:   nsAccessible* accessible =
46469:     GetAccService()->GetAccessibleOrContainer(resultNode, weakShell);
46469:   if (!accessible) {
46469:     NS_NOTREACHED("No nsIAccessibleText for selection change event!");
46469:     return nsnull;
46469:   }
46469: 
46469:   do {
43537:     nsHyperTextAccessible* textAcc = nsnull;
20999:     CallQueryInterface(accessible, &textAcc);
20999:     if (textAcc) {
20999:       if (aNode)
46469:         NS_ADDREF(*aNode = accessible->GetNode());
20999: 
20999:       return textAcc;
20999:     }
46469:   } while (accessible = accessible->GetParent());
20999: 
46469:   NS_NOTREACHED("We must reach document accessible implementing nsIAccessibleText!");
20999:   return nsnull;
20999: }
20999: 
 5245: nsresult
20536: nsAccUtils::ConvertToScreenCoords(PRInt32 aX, PRInt32 aY,
 6286:                                   PRUint32 aCoordinateType,
43504:                                   nsAccessNode *aAccessNode,
 6286:                                   nsIntPoint *aCoords)
 6286: {
 6286:   NS_ENSURE_ARG_POINTER(aCoords);
 6286: 
 6286:   aCoords->MoveTo(aX, aY);
 6286: 
 6286:   switch (aCoordinateType) {
 6286:     case nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE:
 6286:       break;
 6286: 
 6286:     case nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE:
 6286:     {
 6286:       NS_ENSURE_ARG(aAccessNode);
 8525:       *aCoords += GetScreenCoordsForWindow(aAccessNode);
 6286:       break;
 6286:     }
 6286: 
 6286:     case nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE:
 6286:     {
 6286:       NS_ENSURE_ARG(aAccessNode);
 8525:       *aCoords += GetScreenCoordsForParent(aAccessNode);
 8525:       break;
 6286:     }
 6286: 
 8525:     default:
 8525:       return NS_ERROR_INVALID_ARG;
 8525:   }
 6286: 
 8525:   return NS_OK;
 8525: }
 6286: 
 8525: nsresult
20536: nsAccUtils::ConvertScreenCoordsTo(PRInt32 *aX, PRInt32 *aY,
 8525:                                   PRUint32 aCoordinateType,
43504:                                   nsAccessNode *aAccessNode)
 8525: {
 8525:   switch (aCoordinateType) {
 8525:     case nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE:
 8525:       break;
 8525: 
 8525:     case nsIAccessibleCoordinateType::COORDTYPE_WINDOW_RELATIVE:
 8525:     {
 8525:       NS_ENSURE_ARG(aAccessNode);
20536:       nsIntPoint coords = nsAccUtils::GetScreenCoordsForWindow(aAccessNode);
 8525:       *aX -= coords.x;
 8525:       *aY -= coords.y;
 8525:       break;
 8525:     }
 8525: 
 8525:     case nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE:
 8525:     {
 8525:       NS_ENSURE_ARG(aAccessNode);
20536:       nsIntPoint coords = nsAccUtils::GetScreenCoordsForParent(aAccessNode);
 8525:       *aX -= coords.x;
 8525:       *aY -= coords.y;
 6286:       break;
 6286:     }
 6286: 
 6286:     default:
 6286:       return NS_ERROR_INVALID_ARG;
 6286:   }
 6286: 
 6286:   return NS_OK;
 6286: }
 6286: 
 5679: nsIntPoint
43504: nsAccUtils::GetScreenCoordsForWindow(nsAccessNode *aAccessNode)
 8525: {
43504:   return nsCoreUtils::GetScreenCoordsForWindow(aAccessNode->GetNode());
 8525: }
 8525: 
 8525: nsIntPoint
43504: nsAccUtils::GetScreenCoordsForParent(nsAccessNode *aAccessNode)
 8525: {
43538:   nsAccessible *parent =
46469:     GetAccService()->GetContainerAccessible(aAccessNode->GetNode(),
46469:                                             aAccessNode->GetWeakShell());
 8525:   if (!parent)
 8525:     return nsIntPoint(0, 0);
 8525: 
 8525:   nsIFrame *parentFrame = parent->GetFrame();
 8525:   if (!parentFrame)
 8525:     return nsIntPoint(0, 0);
 8525: 
 8525:   nsIntRect parentRect = parentFrame->GetScreenRectExternal();
 8525:   return nsIntPoint(parentRect.x, parentRect.y);
 8525: }
 8525: 
 7830: nsRoleMapEntry*
43504: nsAccUtils::GetRoleMapEntry(nsINode *aNode)
 7830: {
20566:   nsIContent *content = nsCoreUtils::GetRoleContent(aNode);
 7830:   nsAutoString roleString;
32104:   if (!content ||
32104:       !content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, roleString) ||
32104:       roleString.IsEmpty()) {
32104:     // We treat role="" as if the role attribute is absent (per aria spec:8.1.1)
 7830:     return nsnull;
 7830:   }
 7830: 
 7830:   nsWhitespaceTokenizer tokenizer(roleString);
 7830:   while (tokenizer.hasMoreTokens()) {
 7830:     // Do a binary search through table for the next role in role list
29922:     NS_LossyConvertUTF16toASCII role(tokenizer.nextToken());
29922:     PRUint32 low = 0;
29922:     PRUint32 high = nsARIAMap::gWAIRoleMapLength;
29922:     while (low < high) {
29922:       PRUint32 index = (low + high) / 2;
29922:       PRInt32 compare = PL_strcmp(role.get(), nsARIAMap::gWAIRoleMap[index].roleString);
 7830:       if (compare == 0) {
 7830:         // The  role attribute maps to an entry in the role table
 7830:         return &nsARIAMap::gWAIRoleMap[index];
 7830:       }
 7830:       if (compare < 0) {
29922:         high = index;
 7830:       }
 7830:       else {
 7830:         low = index + 1;
 7830:       }
 7830:     }
 7830:   }
 7830: 
32104:   // Always use some entry if there is a non-empty role string
 7830:   // To ensure an accessible object is created
 7830:   return &nsARIAMap::gLandmarkRoleMap;
 7830: }
20566: 
25822: PRUint32
25822: nsAccUtils::RoleInternal(nsIAccessible *aAcc)
25822: {
25822:   PRUint32 role = nsIAccessibleRole::ROLE_NOTHING;
25822:   if (aAcc) {
25822:     nsAccessible* accessible = nsnull;
25822:     CallQueryInterface(aAcc, &accessible);
25822: 
25826:     if (accessible) {
25822:       accessible->GetRoleInternal(&role);
25826:       NS_RELEASE(accessible);
25826:     }
25822:   }
25822: 
25822:   return role;
25822: }
25822: 
24997: PRUint8
24997: nsAccUtils::GetAttributeCharacteristics(nsIAtom* aAtom)
24997: {
24997:     for (PRUint32 i = 0; i < nsARIAMap::gWAIUnivAttrMapLength; i++)
24997:       if (*nsARIAMap::gWAIUnivAttrMap[i].attributeName == aAtom)
24997:         return nsARIAMap::gWAIUnivAttrMap[i].characteristics;
24997: 
24997:     return 0;
24997: }
24997: 
32053: PRBool
25174: nsAccUtils::GetLiveAttrValue(PRUint32 aRule, nsAString& aValue)
25174: {
25174:   switch (aRule) {
25174:     case eOffLiveAttr:
25174:       aValue = NS_LITERAL_STRING("off");
32053:       return PR_TRUE;
25174:     case ePoliteLiveAttr:
25174:       aValue = NS_LITERAL_STRING("polite");
32053:       return PR_TRUE;
25174:   }
32053: 
32053:   return PR_FALSE;
25174: }
20566: 
20566: #ifdef DEBUG_A11Y
20566: 
20566: PRBool
42415: nsAccUtils::IsTextInterfaceSupportCorrect(nsAccessible *aAccessible)
20566: {
20566:   PRBool foundText = PR_FALSE;
20566:   
42415:   nsCOMPtr<nsIAccessibleDocument> accDoc = do_QueryObject(aAccessible);
20566:   if (accDoc) {
20566:     // Don't test for accessible docs, it makes us create accessibles too
20566:     // early and fire mutation events before we need to
20566:     return PR_TRUE;
20566:   }
20566: 
42415:   PRInt32 childCount = aAccessible->GetChildCount();
42415:   for (PRint32 childIdx = 0; childIdx < childCount; childIdx++) {
42415:     nsAccessible *child = GetChildAt(childIdx);
20566:     if (IsText(child)) {
20566:       foundText = PR_TRUE;
20566:       break;
20566:     }
20566:   }
20566: 
20566:   if (foundText) {
20566:     // found text child node
42415:     nsCOMPtr<nsIAccessibleText> text = do_QueryObject(aAccessible);
20566:     if (!text)
20566:       return PR_FALSE;
20566:   }
20566: 
20566:   return PR_TRUE; 
20566: }
20566: #endif
20566: 
42801: PRUint32
42801: nsAccUtils::TextLength(nsAccessible *aAccessible)
20566: {
20566:   if (!IsText(aAccessible))
20566:     return 1;
20566: 
42801:   nsIFrame *frame = aAccessible->GetFrame();
20566:   if (frame && frame->GetType() == nsAccessibilityAtoms::textFrame) {
20566:     // Ensure that correct text length is calculated (with non-rendered
20566:     // whitespace chars not counted).
20566:     nsIContent *content = frame->GetContent();
20566:     if (content) {
20566:       PRUint32 length;
20566:       nsresult rv = nsHyperTextAccessible::
20566:         ContentToRenderedOffset(frame, content->TextLength(), &length);
42801:       if (NS_FAILED(rv)) {
42801:         NS_NOTREACHED("Failed to get rendered offset!");
42801:         return 0;
42801:       }
42801: 
42801:       return length;
20566:     }
20566:   }
20566: 
20566:   // For list bullets (or anything other accessible which would compute its own
20566:   // text. They don't have their own frame.
20566:   // XXX In the future, list bullets may have frame and anon content, so 
20566:   // we should be able to remove this at that point
20566:   nsAutoString text;
42801:   aAccessible->AppendTextTo(text, 0, PR_UINT32_MAX); // Get all the text
20566:   return text.Length();
20566: }
20566: 
20566: PRBool
20566: nsAccUtils::MustPrune(nsIAccessible *aAccessible)
20566: { 
20566:   PRUint32 role = nsAccUtils::Role(aAccessible);
20566: 
34719:   // We don't prune buttons any more however AT don't expect children inside of
34719:   // button in general, we allow menu buttons to have children to make them
34719:   // accessible.
20566:   return role == nsIAccessibleRole::ROLE_MENUITEM || 
20566:     role == nsIAccessibleRole::ROLE_COMBOBOX_OPTION ||
20566:     role == nsIAccessibleRole::ROLE_OPTION ||
20566:     role == nsIAccessibleRole::ROLE_ENTRY ||
20566:     role == nsIAccessibleRole::ROLE_FLAT_EQUATION ||
20566:     role == nsIAccessibleRole::ROLE_PASSWORD_TEXT ||
20566:     role == nsIAccessibleRole::ROLE_TOGGLE_BUTTON ||
20566:     role == nsIAccessibleRole::ROLE_GRAPHIC ||
20566:     role == nsIAccessibleRole::ROLE_SLIDER ||
20566:     role == nsIAccessibleRole::ROLE_PROGRESSBAR ||
20566:     role == nsIAccessibleRole::ROLE_SEPARATOR;
20566: }
20566: 
32381: nsresult
32381: nsAccUtils::GetHeaderCellsFor(nsIAccessibleTable *aTable,
32381:                               nsIAccessibleTableCell *aCell,
32381:                               PRInt32 aRowOrColHeaderCells, nsIArray **aCells)
32381: {
32381:   nsresult rv = NS_OK;
32381:   nsCOMPtr<nsIMutableArray> cells = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRInt32 rowIdx = -1;
32381:   rv = aCell->GetRowIndex(&rowIdx);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRInt32 colIdx = -1;
32381:   rv = aCell->GetColumnIndex(&colIdx);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRBool moveToLeft = aRowOrColHeaderCells == eRowHeaderCells;
32381: 
32381:   // Move to the left or top to find row header cells or column header cells.
32381:   PRInt32 index = (moveToLeft ? colIdx : rowIdx) - 1;
32381:   for (; index >= 0; index--) {
32381:     PRInt32 curRowIdx = moveToLeft ? rowIdx : index;
32381:     PRInt32 curColIdx = moveToLeft ? index : colIdx;
32381: 
32381:     nsCOMPtr<nsIAccessible> cell;
32381:     rv = aTable->GetCellAt(curRowIdx, curColIdx, getter_AddRefs(cell));
32381:     NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:     nsCOMPtr<nsIAccessibleTableCell> tableCellAcc =
32381:       do_QueryInterface(cell);
32381: 
51354:     // GetCellAt should always return an nsIAccessibleTableCell (XXX Bug 587529)
51354:     NS_ENSURE_STATE(tableCellAcc);
51354: 
32381:     PRInt32 origIdx = 1;
32381:     if (moveToLeft)
32381:       rv = tableCellAcc->GetColumnIndex(&origIdx);
32381:     else
32381:       rv = tableCellAcc->GetRowIndex(&origIdx);
32381:     NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:     if (origIdx == index) {
32381:       // Append original header cells only.
32381:       PRUint32 role = Role(cell);
32381:       PRBool isHeader = moveToLeft ?
32381:         role == nsIAccessibleRole::ROLE_ROWHEADER :
32381:         role == nsIAccessibleRole::ROLE_COLUMNHEADER;
32381: 
32381:       if (isHeader)
32381:         cells->AppendElement(cell, PR_FALSE);
32381:     }
32381:   }
32381: 
32381:   NS_ADDREF(*aCells = cells);
32381:   return NS_OK;
32381: }
