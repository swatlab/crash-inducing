    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is nsCSSDataBlock.cpp.
    1:  *
    1:  * The Initial Developer of the Original Code is L. David Baron.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * compact representation of the property-value pairs within a CSS
    1:  * declaration, and the code for expanding and compacting it
    1:  */
    1: 
    1: #include "nsCSSDataBlock.h"
    1: #include "nsCSSProps.h"
    1: #include "nsRuleData.h"
  902: #include "nsRuleNode.h"
 1540: #include "nsStyleSet.h"
    1: 
    1: /*
    1:  * nsCSSCompressedDataBlock holds property-value pairs corresponding to
16372:  * CSS declaration blocks.  The value is stored in one of the five CSS
16372:  * data types: nsCSSValue, nsCSSRect, nsCSSValueList, nsCSSValuePair,
16372:  * and nsCSSValuePairList, which each correspond to a value of the
16372:  * nsCSSType enumeration.
    1:  *
    1:  * The storage strategy uses the CDB*Storage structs below to help
    1:  * ensure that all the types remain properly aligned.  nsCSSValue's
    1:  * alignment requirements cannot be weaker than any others, since it
    1:  * contains a pointer and an enumeration.
    1:  *
    1:  * The simple types, nsCSSValue and nsCSSRect have the nsCSSValue or
    1:  * nsCSSRect objects stored in the block.  The list types have only a
    1:  * pointer to the first element in the list stored in the block.
    1:  */
    1: 
    1: struct CDBValueStorage {
    1:     nsCSSProperty property;
    1:     nsCSSValue value;
    1: };
    1: 
    1: struct CDBRectStorage {
    1:     nsCSSProperty property;
    1:     nsCSSRect value;
    1: 
    1: };
    1: 
    1: struct CDBValuePairStorage {
    1:     nsCSSProperty property;
    1:     nsCSSValuePair value;
    1: };
    1: 
    1: struct CDBPointerStorage {
    1:     nsCSSProperty property;
    1:     void *value;
    1: };
    1: 
    1: enum {
    1:     CDBValueStorage_advance = sizeof(CDBValueStorage),
    1:     CDBRectStorage_advance = sizeof(CDBRectStorage),
    1:     CDBValuePairStorage_advance = sizeof(CDBValuePairStorage),
    1:     // round up using the closest estimate we can get of the alignment
    1:     // requirements of nsCSSValue:
    1:     CDBPointerStorage_advance = PR_ROUNDUP(sizeof(CDBPointerStorage),
    1:                                 sizeof(CDBValueStorage) - sizeof(nsCSSValue))
    1: };
    1: 
    1: /*
    1:  * Define a bunch of utility functions for getting the property or any
    1:  * of the value types when the cursor is at the beginning of the storage
    1:  * for the property-value pair.  The versions taking a non-const cursor
    1:  * argument return a reference so that the caller can assign into the
    1:  * result.
    1:  */
    1: 
    1: inline nsCSSProperty& PropertyAtCursor(char *aCursor) {
 3233:     return *reinterpret_cast<nsCSSProperty*>(aCursor);
    1: }
    1: 
    1: inline nsCSSProperty PropertyAtCursor(const char *aCursor) {
 3233:     return *reinterpret_cast<const nsCSSProperty*>(aCursor);
    1: }
    1: 
    1: inline nsCSSValue* ValueAtCursor(char *aCursor) {
 3233:     return & reinterpret_cast<CDBValueStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline const nsCSSValue* ValueAtCursor(const char *aCursor) {
 3233:     return & reinterpret_cast<const CDBValueStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline nsCSSRect* RectAtCursor(char *aCursor) {
 3233:     return & reinterpret_cast<CDBRectStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline const nsCSSRect* RectAtCursor(const char *aCursor) {
 3233:     return & reinterpret_cast<const CDBRectStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline nsCSSValuePair* ValuePairAtCursor(char *aCursor) {
 3233:   return & reinterpret_cast<CDBValuePairStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline const nsCSSValuePair* ValuePairAtCursor(const char *aCursor) {
 3233:   return & reinterpret_cast<const CDBValuePairStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline void*& PointerAtCursor(char *aCursor) {
 3233:     return reinterpret_cast<CDBPointerStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline void* PointerAtCursor(const char *aCursor) {
 3233:     return reinterpret_cast<const CDBPointerStorage*>(aCursor)->value;
    1: }
    1: 
    1: inline nsCSSValueList*& ValueListAtCursor(char *aCursor) {
 3233:     return * reinterpret_cast<nsCSSValueList**>
 3233:                              (& reinterpret_cast<CDBPointerStorage*>(aCursor)->value);
    1: }
    1: 
    1: inline nsCSSValueList* ValueListAtCursor(const char *aCursor) {
 3233:     return static_cast<nsCSSValueList*>
 3233:                       (reinterpret_cast<const CDBPointerStorage*>(aCursor)->value);
    1: }
    1: 
16372: inline nsCSSValuePairList*& ValuePairListAtCursor(char *aCursor) {
16372:     return * reinterpret_cast<nsCSSValuePairList**>
 3233:                              (& reinterpret_cast<CDBPointerStorage*>(aCursor)->value);
    1: }
    1: 
16372: inline nsCSSValuePairList* ValuePairListAtCursor(const char *aCursor) {
16372:     return static_cast<nsCSSValuePairList*>
 3233:                       (reinterpret_cast<const CDBPointerStorage*>(aCursor)->value);
    1: }
    1: 
 1540: static PRBool
 1540: ShouldIgnoreColors(nsRuleData *aRuleData)
 1540: {
 1540:     return aRuleData->mLevel != nsStyleSet::eAgentSheet &&
 1540:            aRuleData->mLevel != nsStyleSet::eUserSheet &&
 8088:            !aRuleData->mPresContext->UseDocumentColors();
 1540: }
 1540: 
    1: nsresult
    1: nsCSSCompressedDataBlock::MapRuleInfoInto(nsRuleData *aRuleData) const
    1: {
 6732:     // If we have no data for these structs, then return immediately.
    1:     // This optimization should make us return most of the time, so we
    1:     // have to worry much less (although still some) about the speed of
    1:     // the rest of the function.
 6732:     if (!(aRuleData->mSIDs & mStyleBits))
    1:         return NS_OK;
    1: 
    1:     const char* cursor = Block();
    1:     const char* cursor_end = BlockEnd();
    1:     while (cursor < cursor_end) {
    1:         nsCSSProperty iProp = PropertyAtCursor(cursor);
    1:         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                      "out of range");
 6732:         if (nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[iProp]) &
 6732:             aRuleData->mSIDs) {
    1:             void *prop =
    1:                 nsCSSExpandedDataBlock::RuleDataPropertyAt(aRuleData, iProp);
    1:             switch (nsCSSProps::kTypeTable[iProp]) {
    1:                 case eCSSType_Value: {
 3233:                     nsCSSValue* target = static_cast<nsCSSValue*>(prop);
    1:                     if (target->GetUnit() == eCSSUnit_Null) {
    1:                         const nsCSSValue *val = ValueAtCursor(cursor);
    1:                         NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
15992:                         if (iProp == eCSSProperty_background_image ||
15992:                             iProp == eCSSProperty_list_style_image) {
15992:                             if (val->GetUnit() == eCSSUnit_URL) {
15992:                                 val->StartImageLoad(
15992:                                     aRuleData->mPresContext->Document());
15992:                             }
15992:                         } else if (iProp == eCSSProperty_border_image) {
15992:                             if (val->GetUnit() == eCSSUnit_Array) {
15992:                                 nsCSSValue::Array *array = val->GetArrayValue();
15992:                                 if (array->Item(0).GetUnit() == eCSSUnit_URL) {
15992:                                     array->Item(0).StartImageLoad(
15992:                                         aRuleData->mPresContext->Document());
15992:                                 }
15992:                             }
    1:                         }
    1:                         *target = *val;
    1:                         if (iProp == eCSSProperty_font_family) {
    1:                             // XXX Are there other things like this?
    1:                             aRuleData->mFontData->mFamilyFromHTML = PR_FALSE;
    1:                         }
 1540:                         else if (iProp == eCSSProperty_color ||
 1540:                                  iProp == eCSSProperty_background_color ||
 1540:                                  iProp == eCSSProperty_background_image ||
 1540:                                  iProp == eCSSProperty_border_top_color ||
12629:                                  iProp == eCSSProperty_border_right_color_value ||
12629:                                  iProp == eCSSProperty_border_right_color_ltr_source ||
12629:                                  iProp == eCSSProperty_border_right_color_rtl_source ||
 1540:                                  iProp == eCSSProperty_border_bottom_color ||
12629:                                  iProp == eCSSProperty_border_left_color_value ||
12629:                                  iProp == eCSSProperty_border_left_color_ltr_source ||
12629:                                  iProp == eCSSProperty_border_left_color_rtl_source ||
16055:                                  iProp == eCSSProperty__moz_column_rule_color ||
 1587:                                  iProp == eCSSProperty_outline_color) {
 1540:                             if (ShouldIgnoreColors(aRuleData)) {
 1540:                                 if (iProp == eCSSProperty_background_color) {
 1540:                                     // Force non-'transparent' background
 1540:                                     // colors to the user's default.
19182:                                     // We have the value in the form it was
19182:                                     // specified at this point, so we have to
19182:                                     // look for both the keyword 'transparent'
19182:                                     // and its equivalent in rgba notation.
 1540:                                     nsCSSUnit u = target->GetUnit();
19182:                                     nsDependentString buf;
19182:                                     
19182:                                     if ((u == eCSSUnit_Color &&
19182:                                          NS_GET_A(target->GetColorValue())
19182:                                          > 0) ||
19182:                                         (u == eCSSUnit_String &&
19182:                                          !nsGkAtoms::transparent->
19182:                                          Equals(target->GetStringValue(buf))) ||
19182:                                         (u == eCSSUnit_EnumColor)) {
 1540:                                         target->SetColorValue(aRuleData->
 1540:                                             mPresContext->
 1540:                                             DefaultBackgroundColor());
 1540:                                     }
 1540:                                 } else {
 1540:                                     // Ignore 'color', 'border-*-color', and
 1540:                                     // 'background-image'
 1540:                                     *target = nsCSSValue();
 1540:                                 }
 1540:                             }
 1540:                         }
    1:                     }
    1:                     cursor += CDBValueStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_Rect: {
    1:                     const nsCSSRect* val = RectAtCursor(cursor);
    1:                     NS_ASSERTION(val->HasValue(), "oops");
 3233:                     nsCSSRect* target = static_cast<nsCSSRect*>(prop);
    1:                     if (target->mTop.GetUnit() == eCSSUnit_Null)
    1:                         target->mTop = val->mTop;
    1:                     if (target->mRight.GetUnit() == eCSSUnit_Null)
    1:                         target->mRight = val->mRight;
    1:                     if (target->mBottom.GetUnit() == eCSSUnit_Null)
    1:                         target->mBottom = val->mBottom;
    1:                     if (target->mLeft.GetUnit() == eCSSUnit_Null)
    1:                         target->mLeft = val->mLeft;
    1:                     cursor += CDBRectStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValuePair: {
    1:                     const nsCSSValuePair* val = ValuePairAtCursor(cursor);
    1:                     NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
    1:                                  val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
 3233:                     nsCSSValuePair* target = static_cast<nsCSSValuePair*>(prop);
    1:                     if (target->mXValue.GetUnit() == eCSSUnit_Null)
    1:                         target->mXValue = val->mXValue;
    1:                     if (target->mYValue.GetUnit() == eCSSUnit_Null)
    1:                         target->mYValue = val->mYValue;
    1:                     cursor += CDBValuePairStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValueList:
    1:                     if (iProp == eCSSProperty_content) {
    1:                         for (nsCSSValueList* l = ValueListAtCursor(cursor);
    1:                              l; l = l->mNext)
    1:                             if (l->mValue.GetUnit() == eCSSUnit_URL)
    1:                                 l->mValue.StartImageLoad(
    1:                                     aRuleData->mPresContext->Document());
    1:                     } else if (iProp == eCSSProperty_cursor) {
    1:                         for (nsCSSValueList* l = ValueListAtCursor(cursor);
    1:                              l; l = l->mNext)
    1:                             if (l->mValue.GetUnit() == eCSSUnit_Array) {
    1:                                 // Don't try to restart loads we've already
    1:                                 // started
    1:                                 nsCSSValue& val =
    1:                                     l->mValue.GetArrayValue()->Item(0);
    1:                                 if (val.GetUnit() == eCSSUnit_URL)
    1:                                     val.StartImageLoad(
    1:                                       aRuleData->mPresContext->Document());
    1:                             }
    1:                     }
    1:                 // fall through
16372:                 case eCSSType_ValuePairList: {
 3233:                     void** target = static_cast<void**>(prop);
    1:                     if (!*target) {
    1:                         void* val = PointerAtCursor(cursor);
    1:                         NS_ASSERTION(val, "oops");
    1:                         *target = val;
 1540: 
 1540:                         if (iProp == eCSSProperty_border_top_colors ||
 1540:                             iProp == eCSSProperty_border_right_colors ||
 1540:                             iProp == eCSSProperty_border_bottom_colors ||
 1540:                             iProp == eCSSProperty_border_left_colors) {
 1540:                             if (ShouldIgnoreColors(aRuleData)) {
 1540:                                 *target = nsnull;
 1540:                             }
 1540:                         }
    1:                     }
    1:                     cursor += CDBPointerStorage_advance;
    1:                 } break;
    1:             }
    1:         } else {
    1:             switch (nsCSSProps::kTypeTable[iProp]) {
    1:                 case eCSSType_Value: {
    1:                     cursor += CDBValueStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_Rect: {
    1:                     cursor += CDBRectStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValuePair: {
    1:                     cursor += CDBValuePairStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValueList:
16372:                 case eCSSType_ValuePairList: {
    1:                     cursor += CDBPointerStorage_advance;
    1:                 } break;
    1:             }
    1:         }
    1:     }
    1:     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: const void*
    1: nsCSSCompressedDataBlock::StorageFor(nsCSSProperty aProperty) const
    1: {
    1:     // If we have no data for this struct, then return immediately.
    1:     // This optimization should make us return most of the time, so we
    1:     // have to worry much less (although still some) about the speed of
    1:     // the rest of the function.
    1:     if (!(nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[aProperty]) &
    1:           mStyleBits))
    1:         return nsnull;
    1: 
    1:     const char* cursor = Block();
    1:     const char* cursor_end = BlockEnd();
    1:     while (cursor < cursor_end) {
    1:         nsCSSProperty iProp = PropertyAtCursor(cursor);
    1:         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                      "out of range");
    1:         if (iProp == aProperty) {
    1:             switch (nsCSSProps::kTypeTable[iProp]) {
    1:                 case eCSSType_Value: {
    1:                     return ValueAtCursor(cursor);
    1:                 }
    1:                 case eCSSType_Rect: {
    1:                     return RectAtCursor(cursor);
    1:                 }
    1:                 case eCSSType_ValuePair: {
    1:                     return ValuePairAtCursor(cursor);
    1:                 }
    1:                 case eCSSType_ValueList:
16372:                 case eCSSType_ValuePairList: {
 3233:                     return &PointerAtCursor(const_cast<char*>(cursor));
    1:                 }
    1:             }
    1:         }
    1:         switch (nsCSSProps::kTypeTable[iProp]) {
    1:             case eCSSType_Value: {
    1:                 cursor += CDBValueStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_Rect: {
    1:                 cursor += CDBRectStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValuePair: {
    1:                 cursor += CDBValuePairStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValueList:
16372:             case eCSSType_ValuePairList: {
    1:                 cursor += CDBPointerStorage_advance;
    1:             } break;
    1:         }
    1:     }
    1:     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: nsCSSCompressedDataBlock*
    1: nsCSSCompressedDataBlock::Clone() const
    1: {
    1:     const char *cursor = Block(), *cursor_end = BlockEnd();
    1:     char *result_cursor;
    1: 
    1:     nsCSSCompressedDataBlock *result =
    1:         new(cursor_end - cursor) nsCSSCompressedDataBlock();
    1:     if (!result)
    1:         return nsnull;
    1:     result_cursor = result->Block();
    1: 
    1:     while (cursor < cursor_end) {
    1:         nsCSSProperty iProp = PropertyAtCursor(cursor);
    1:         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                      "out of range");
    1:         PropertyAtCursor(result_cursor) = iProp;
    1: 
    1:         switch (nsCSSProps::kTypeTable[iProp]) {
    1:             case eCSSType_Value: {
    1:                 const nsCSSValue* val = ValueAtCursor(cursor);
    1:                 NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
    1:                 nsCSSValue *result_val = ValueAtCursor(result_cursor);
    1:                 new (result_val) nsCSSValue(*val);
    1:                 cursor += CDBValueStorage_advance;
    1:                 result_cursor +=  CDBValueStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_Rect: {
    1:                 const nsCSSRect* val = RectAtCursor(cursor);
    1:                 NS_ASSERTION(val->HasValue(), "oops");
    1:                 nsCSSRect* result_val = RectAtCursor(result_cursor);
    1:                 new (result_val) nsCSSRect(*val);
    1:                 cursor += CDBRectStorage_advance;
    1:                 result_cursor += CDBRectStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValuePair: {
    1:                 const nsCSSValuePair* val = ValuePairAtCursor(cursor);
    1:                 NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
    1:                              val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
    1:                 nsCSSValuePair* result_val = ValuePairAtCursor(result_cursor);
    1:                 new (result_val) nsCSSValuePair(*val);
    1:                 cursor += CDBValuePairStorage_advance;
    1:                 result_cursor += CDBValuePairStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValueList:
16372:             case eCSSType_ValuePairList: {
    1:                 void *copy;
    1:                 NS_ASSERTION(PointerAtCursor(cursor), "oops");
    1:                 switch (nsCSSProps::kTypeTable[iProp]) {
    1:                     default:
    1:                         NS_NOTREACHED("unreachable");
    1:                         // fall through to keep gcc's uninitialized
    1:                         // variable warning quiet
    1:                     case eCSSType_ValueList:
20563:                         copy = ValueListAtCursor(cursor)->Clone();
    1:                         break;
16372:                     case eCSSType_ValuePairList:
20563:                         copy = ValuePairListAtCursor(cursor)->Clone();
    1:                         break;
    1:                 }
    1:                 if (!copy) {
    1:                     result->mBlockEnd = result_cursor;
    1:                     result->Destroy();
    1:                     return nsnull;
    1:                 }
    1:                 PointerAtCursor(result_cursor) = copy;
    1:                 cursor += CDBPointerStorage_advance;
    1:                 result_cursor += CDBPointerStorage_advance;
    1:             } break;
    1:         }
    1:     }
    1:     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
    1: 
    1:     result->mBlockEnd = result_cursor;
    1:     result->mStyleBits = mStyleBits;
    1:     NS_ASSERTION(result->DataSize() == DataSize(), "wrong size");
    1:     return result;
    1: }
    1: 
    1: void
    1: nsCSSCompressedDataBlock::Destroy()
    1: {
    1:     const char* cursor = Block();
    1:     const char* cursor_end = BlockEnd();
    1:     while (cursor < cursor_end) {
    1:         nsCSSProperty iProp = PropertyAtCursor(cursor);
    1:         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                      "out of range");
    1: 
    1:         switch (nsCSSProps::kTypeTable[iProp]) {
    1:             case eCSSType_Value: {
    1:                 const nsCSSValue* val = ValueAtCursor(cursor);
    1:                 NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
    1:                 val->~nsCSSValue();
    1:                 cursor += CDBValueStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_Rect: {
    1:                 const nsCSSRect* val = RectAtCursor(cursor);
    1:                 NS_ASSERTION(val->HasValue(), "oops");
    1:                 val->~nsCSSRect();
    1:                 cursor += CDBRectStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValuePair: {
    1:                 const nsCSSValuePair* val = ValuePairAtCursor(cursor);
    1:                 NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
    1:                              val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
    1:                 val->~nsCSSValuePair();
    1:                 cursor += CDBValuePairStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValueList: {
    1:                 nsCSSValueList* val = ValueListAtCursor(cursor);
    1:                 NS_ASSERTION(val, "oops");
    1:                 delete val;
    1:                 cursor += CDBPointerStorage_advance;
    1:             } break;
    1: 
16372:             case eCSSType_ValuePairList: {
16372:                 nsCSSValuePairList* val = ValuePairListAtCursor(cursor);
    1:                 NS_ASSERTION(val, "oops");
    1:                 delete val;
    1:                 cursor += CDBPointerStorage_advance;
    1:             } break;
    1:         }
    1:     }
    1:     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
    1:     delete this;
    1: }
    1: 
    1: /* static */ nsCSSCompressedDataBlock*
    1: nsCSSCompressedDataBlock::CreateEmptyBlock()
    1: {
    1:     nsCSSCompressedDataBlock *result = new(0) nsCSSCompressedDataBlock();
    1:     if (!result)
    1:         return nsnull;
    1:     result->mBlockEnd = result->Block();
    1:     return result;
    1: }
    1: 
    1: /*****************************************************************************/
    1: 
    1: nsCSSExpandedDataBlock::nsCSSExpandedDataBlock()
    1: {
    1:     ClearSets();
    1:     AssertInitialState();
    1: }
    1: 
    1: nsCSSExpandedDataBlock::~nsCSSExpandedDataBlock()
    1: {
    1:     AssertInitialState();
    1: }
    1: 
    1: const nsCSSExpandedDataBlock::PropertyOffsetInfo
    1: nsCSSExpandedDataBlock::kOffsetTable[eCSSProperty_COUNT_no_shorthands] = {
20115:     #define CSS_PROP_BACKENDONLY(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
    1:         { offsetof(nsCSSExpandedDataBlock, m##datastruct_.member_),           \
    1:           size_t(-1),                                                         \
    1:           size_t(-1) },
20115:     #define CSS_PROP(name_, id_, method_, flags_, datastruct_, member_, type_, kwtable_) \
    1:         { offsetof(nsCSSExpandedDataBlock, m##datastruct_.member_),           \
    1:           offsetof(nsRuleData, m##datastruct_##Data),                         \
    1:           offsetof(nsRuleData##datastruct_, member_) },
    1:     #include "nsCSSPropList.h"
    1:     #undef CSS_PROP
    1:     #undef CSS_PROP_BACKENDONLY
    1: };
    1: 
    1: void
    1: nsCSSExpandedDataBlock::DoExpand(nsCSSCompressedDataBlock *aBlock,
    1:                                  PRBool aImportant)
    1: {
    1:     NS_PRECONDITION(aBlock, "unexpected null block");
    1: 
    1:     /*
    1:      * Save needless copying and allocation by copying the memory
    1:      * corresponding to the stored data in the compressed block, and
    1:      * then, to avoid destructors, deleting the compressed block by
    1:      * calling |delete| instead of using its |Destroy| method.
    1:      */
    1:     const char* cursor = aBlock->Block();
    1:     const char* cursor_end = aBlock->BlockEnd();
    1:     while (cursor < cursor_end) {
    1:         nsCSSProperty iProp = PropertyAtCursor(cursor);
    1:         NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                      "out of range");
    1:         NS_ASSERTION(!HasPropertyBit(iProp),
    1:                      "compressed block has property multiple times");
    1:         SetPropertyBit(iProp);
    1:         if (aImportant)
    1:             SetImportantBit(iProp);
    1:         void *prop = PropertyAt(iProp);
    1: 
    1:         switch (nsCSSProps::kTypeTable[iProp]) {
    1:             case eCSSType_Value: {
    1:                 const nsCSSValue* val = ValueAtCursor(cursor);
 5368:                 nsCSSValue* dest = static_cast<nsCSSValue*>(prop);
    1:                 NS_ASSERTION(val->GetUnit() != eCSSUnit_Null, "oops");
 5368:                 NS_ASSERTION(dest->GetUnit() == eCSSUnit_Null,
 5368:                              "expanding into non-empty block");
 5368: #ifdef NS_BUILD_REFCNT_LOGGING
 5368:                 dest->~nsCSSValue();
 5368: #endif
 5368:                 memcpy(dest, val, sizeof(nsCSSValue));
    1:                 cursor += CDBValueStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_Rect: {
    1:                 const nsCSSRect* val = RectAtCursor(cursor);
 5368:                 nsCSSRect* dest = static_cast<nsCSSRect*>(prop);
    1:                 NS_ASSERTION(val->HasValue(), "oops");
 5368:                 NS_ASSERTION(!dest->HasValue(),
 5368:                              "expanding into non-empty block");
 5368: #ifdef NS_BUILD_REFCNT_LOGGING
 5368:                 dest->~nsCSSRect();
 5368: #endif
 5368:                 memcpy(dest, val, sizeof(nsCSSRect));
    1:                 cursor += CDBRectStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValuePair: {
    1:                 const nsCSSValuePair* val = ValuePairAtCursor(cursor);
 5368:                 nsCSSValuePair* dest = static_cast<nsCSSValuePair*>(prop);
    1:                 NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
    1:                              val->mYValue.GetUnit() != eCSSUnit_Null, "oops");
 5368:                 NS_ASSERTION(dest->mXValue.GetUnit() == eCSSUnit_Null &&
 5368:                              dest->mYValue.GetUnit() == eCSSUnit_Null,
 5368:                              "expanding into non-empty block");
 5368: #ifdef NS_BUILD_REFCNT_LOGGING
 5368:                 dest->~nsCSSValuePair();
 5368: #endif
 5368:                 memcpy(dest, val, sizeof(nsCSSValuePair));
    1:                 cursor += CDBValuePairStorage_advance;
    1:             } break;
    1: 
    1:             case eCSSType_ValueList:
16372:             case eCSSType_ValuePairList: {
    1:                 void* val = PointerAtCursor(cursor);
 5368:                 void** dest = static_cast<void**>(prop);
    1:                 NS_ASSERTION(val, "oops");
 5368:                 NS_ASSERTION(!*dest, "expanding into non-empty block");
 5368:                 *dest = val;
    1:                 cursor += CDBPointerStorage_advance;
    1:             } break;
    1:         }
    1:     }
    1:     NS_ASSERTION(cursor == cursor_end, "inconsistent data");
    1: 
    1:     delete aBlock;
    1: }
    1: 
    1: void
    1: nsCSSExpandedDataBlock::Expand(nsCSSCompressedDataBlock **aNormalBlock,
    1:                                nsCSSCompressedDataBlock **aImportantBlock)
    1: {
    1:     NS_PRECONDITION(*aNormalBlock, "unexpected null block");
    1:     AssertInitialState();
    1: 
    1:     DoExpand(*aNormalBlock, PR_FALSE);
    1:     *aNormalBlock = nsnull;
    1:     if (*aImportantBlock) {
    1:         DoExpand(*aImportantBlock, PR_TRUE);
    1:         *aImportantBlock = nsnull;
    1:     }
    1: }
    1: 
    1: nsCSSExpandedDataBlock::ComputeSizeResult
    1: nsCSSExpandedDataBlock::ComputeSize()
    1: {
    1:     ComputeSizeResult result = {0, 0};
    1:     for (PRUint32 iHigh = 0; iHigh < NS_ARRAY_LENGTH(mPropertiesSet); ++iHigh) {
    1:         if (mPropertiesSet[iHigh] == 0)
    1:             continue;
    1:         for (PRInt32 iLow = 0; iLow < kPropertiesSetChunkSize; ++iLow) {
    1:             if ((mPropertiesSet[iHigh] & (1 << iLow)) == 0)
    1:                 continue;
    1:             nsCSSProperty iProp =
    1:                 nsCSSProperty(iHigh * kPropertiesSetChunkSize + iLow);
    1:             NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                          "out of range");
19448: #ifdef DEBUG
    1:             void *prop = PropertyAt(iProp);
19448: #endif
    1:             PRUint32 increment = 0;
    1:             switch (nsCSSProps::kTypeTable[iProp]) {
    1:                 case eCSSType_Value: {
    1: #ifdef DEBUG
 3233:                     nsCSSValue* val = static_cast<nsCSSValue*>(prop);
    1:                     NS_ASSERTION(val->GetUnit() != eCSSUnit_Null,
    1:                                  "null value while computing size");
    1: #endif
    1:                     increment = CDBValueStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_Rect: {
    1: #ifdef DEBUG
 3233:                     nsCSSRect* val = static_cast<nsCSSRect*>(prop);
    1:                     NS_ASSERTION(val->HasValue(),
    1:                                  "Valueless rect while computing size");
    1: #endif
    1:                     increment = CDBRectStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValuePair: {
    1: #ifdef DEBUG
 3233:                     nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
    1:                     NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
    1:                                  val->mYValue.GetUnit() != eCSSUnit_Null,
    1:                                  "Valueless pair while computing size");
    1: #endif
    1:                     increment = CDBValuePairStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValueList:
16372:                 case eCSSType_ValuePairList: {
    1: #ifdef DEBUG
 3233:                     void* val = *static_cast<void**>(prop);
    1:                     NS_ASSERTION(val, "Null pointer while computing size");
    1: #endif
    1:                     increment = CDBPointerStorage_advance;
    1:                 } break;
    1:             }
    1:             if ((mPropertiesImportant[iHigh] & (1 << iLow)) == 0)
    1:                 result.normal += increment;
    1:             else
    1:                 result.important += increment;
    1:         }
    1:     }
    1:     return result;
    1: }
    1: 
    1: void
    1: nsCSSExpandedDataBlock::Compress(nsCSSCompressedDataBlock **aNormalBlock,
    1:                                  nsCSSCompressedDataBlock **aImportantBlock)
    1: {
    1:     nsCSSCompressedDataBlock *result_normal, *result_important;
    1:     char *cursor_normal, *cursor_important;
    1: 
    1:     ComputeSizeResult size = ComputeSize();
    1:     
    1:     result_normal = new(size.normal) nsCSSCompressedDataBlock();
    1:     if (!result_normal) {
    1:         *aNormalBlock = nsnull;
    1:         *aImportantBlock = nsnull;
    1:         return;
    1:     }
    1:     cursor_normal = result_normal->Block();
    1: 
    1:     if (size.important != 0) {
    1:         result_important = new(size.important) nsCSSCompressedDataBlock();
    1:         if (!result_important) {
    1:             delete result_normal;
    1:             *aNormalBlock = nsnull;
    1:             *aImportantBlock = nsnull;
    1:             return;
    1:         }
    1:         cursor_important = result_important->Block();
    1:     } else {
    1:         result_important = nsnull;
    1:     }
    1: 
    1:     /*
    1:      * Save needless copying and allocation by copying the memory
    1:      * corresponding to the stored data in the expanded block, and then
    1:      * clearing the data in the expanded block.
    1:      */
    1:     for (PRUint32 iHigh = 0; iHigh < NS_ARRAY_LENGTH(mPropertiesSet); ++iHigh) {
    1:         if (mPropertiesSet[iHigh] == 0)
    1:             continue;
    1:         for (PRInt32 iLow = 0; iLow < kPropertiesSetChunkSize; ++iLow) {
    1:             if ((mPropertiesSet[iHigh] & (1 << iLow)) == 0)
    1:                 continue;
    1:             nsCSSProperty iProp =
    1:                 nsCSSProperty(iHigh * kPropertiesSetChunkSize + iLow);
    1:             NS_ASSERTION(0 <= iProp && iProp < eCSSProperty_COUNT_no_shorthands,
    1:                          "out of range");
    1:             void *prop = PropertyAt(iProp);
    1:             PRBool important =
    1:                 (mPropertiesImportant[iHigh] & (1 << iLow)) != 0;
    1:             char *&cursor = important ? cursor_important : cursor_normal;
    1:             nsCSSCompressedDataBlock *result =
    1:                 important ? result_important : result_normal;
    1:             switch (nsCSSProps::kTypeTable[iProp]) {
    1:                 case eCSSType_Value: {
 3233:                     nsCSSValue* val = static_cast<nsCSSValue*>(prop);
    1:                     NS_ASSERTION(val->GetUnit() != eCSSUnit_Null,
    1:                                  "Null value while compressing");
    1:                     CDBValueStorage *storage =
 3233:                         reinterpret_cast<CDBValueStorage*>(cursor);
    1:                     storage->property = iProp;
    1:                     memcpy(&storage->value, val, sizeof(nsCSSValue));
    1:                     new (val) nsCSSValue();
    1:                     cursor += CDBValueStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_Rect: {
 3233:                     nsCSSRect* val = static_cast<nsCSSRect*>(prop);
    1:                     NS_ASSERTION(val->HasValue(),
    1:                                  "Valueless rect while compressing");
    1:                     CDBRectStorage *storage =
 3233:                         reinterpret_cast<CDBRectStorage*>(cursor);
    1:                     storage->property = iProp;
    1:                     memcpy(&storage->value, val, sizeof(nsCSSRect));
    1:                     new (val) nsCSSRect();
    1:                     cursor += CDBRectStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValuePair: {
 3233:                     nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
    1:                     NS_ASSERTION(val->mXValue.GetUnit() != eCSSUnit_Null ||
    1:                                  val->mYValue.GetUnit() != eCSSUnit_Null,
    1:                                  "Valueless pair while compressing");
    1:                     CDBValuePairStorage *storage =
 3233:                         reinterpret_cast<CDBValuePairStorage*>(cursor);
    1:                     storage->property = iProp;
    1:                     memcpy(&storage->value, val, sizeof(nsCSSValuePair));
    1:                     new (val) nsCSSValuePair();
    1:                     cursor += CDBValuePairStorage_advance;
    1:                 } break;
    1: 
    1:                 case eCSSType_ValueList:
16372:                 case eCSSType_ValuePairList: {
 3233:                     void*& val = *static_cast<void**>(prop);
    1:                     NS_ASSERTION(val, "Null pointer while compressing");
    1:                     CDBPointerStorage *storage =
 3233:                         reinterpret_cast<CDBPointerStorage*>(cursor);
    1:                     storage->property = iProp;
    1:                     storage->value = val;
    1:                     val = nsnull;
    1:                     cursor += CDBPointerStorage_advance;
    1:                 } break;
    1:             }
    1:             result->mStyleBits |=
    1:                 nsCachedStyleData::GetBitForSID(nsCSSProps::kSIDTable[iProp]);
    1:         }
    1:     }
    1: 
    1:     result_normal->mBlockEnd = cursor_normal;
    1:     NS_ASSERTION(result_normal->DataSize() == ptrdiff_t(size.normal),
    1:                  "size miscalculation");
    1:     if (result_important) {
    1:         result_important->mBlockEnd = cursor_important;
    1:         NS_ASSERTION(result_important->DataSize() == ptrdiff_t(size.important),
    1:                      "size miscalculation");
    1:     }
    1: 
    1:     ClearSets();
    1:     AssertInitialState();
    1:     *aNormalBlock = result_normal;
    1:     *aImportantBlock = result_important;
    1: }
    1: 
    1: void
    1: nsCSSExpandedDataBlock::Clear()
    1: {
    1:     for (PRUint32 iHigh = 0; iHigh < NS_ARRAY_LENGTH(mPropertiesSet); ++iHigh) {
    1:         if (mPropertiesSet[iHigh] == 0)
    1:             continue;
    1:         for (PRInt32 iLow = 0; iLow < kPropertiesSetChunkSize; ++iLow) {
    1:             if ((mPropertiesSet[iHigh] & (1 << iLow)) == 0)
    1:                 continue;
    1:             nsCSSProperty iProp =
    1:                 nsCSSProperty(iHigh * kPropertiesSetChunkSize + iLow);
    1:             ClearProperty(iProp);
    1:         }
    1:     }
    1: 
    1:     AssertInitialState();
    1: }
    1: 
    1: void
    1: nsCSSExpandedDataBlock::ClearProperty(nsCSSProperty aPropID)
    1: {
    1:     NS_ASSERTION(0 <= aPropID && aPropID < eCSSProperty_COUNT_no_shorthands,
    1:                  "out of range");
    1: 
    1:     ClearPropertyBit(aPropID);
    1:     ClearImportantBit(aPropID);
    1: 
    1:     void *prop = PropertyAt(aPropID);
    1:     switch (nsCSSProps::kTypeTable[aPropID]) {
    1:         case eCSSType_Value: {
 3233:             nsCSSValue* val = static_cast<nsCSSValue*>(prop);
    1:             val->Reset();
    1:         } break;
    1: 
    1:         case eCSSType_Rect: {
 3233:             nsCSSRect* val = static_cast<nsCSSRect*>(prop);
    1:             val->Reset();
    1:         } break;
    1: 
    1:         case eCSSType_ValuePair: {
 3233:             nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
    1:             val->mXValue.Reset();
    1:             val->mYValue.Reset();
    1:         } break;
    1: 
    1:         case eCSSType_ValueList: {
 3233:             nsCSSValueList*& val = *static_cast<nsCSSValueList**>(prop);
    1:             if (val) {
    1:                 delete val;
    1:                 val = nsnull;
    1:             }
    1:         } break;
    1: 
16372:         case eCSSType_ValuePairList: {
16372:             nsCSSValuePairList*& val =
16372:               *static_cast<nsCSSValuePairList**>(prop);
    1:             if (val) {
    1:                 delete val;
    1:                 val = nsnull;
    1:             }
    1:         } break;
    1:     }
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsCSSExpandedDataBlock::DoAssertInitialState()
    1: {
    1:     PRUint32 i;
    1:     for (i = 0; i < NS_ARRAY_LENGTH(mPropertiesSet); ++i) {
    1:         NS_ASSERTION(mPropertiesSet[i] == 0, "not initial state");
    1:     }
    1:     for (i = 0; i < NS_ARRAY_LENGTH(mPropertiesImportant); ++i) {
    1:         NS_ASSERTION(mPropertiesImportant[i] == 0, "not initial state");
    1:     }
    1: 
    1:     for (i = 0; i < eCSSProperty_COUNT_no_shorthands; ++i) {
    1:         void *prop = PropertyAt(nsCSSProperty(i));
    1:         switch (nsCSSProps::kTypeTable[i]) {
    1:             case eCSSType_Value: {
 3233:                 nsCSSValue* val = static_cast<nsCSSValue*>(prop);
    1:                 NS_ASSERTION(val->GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:             } break;
    1: 
    1:             case eCSSType_Rect: {
 3233:                 nsCSSRect* val = static_cast<nsCSSRect*>(prop);
    1:                 NS_ASSERTION(val->mTop.GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:                 NS_ASSERTION(val->mRight.GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:                 NS_ASSERTION(val->mBottom.GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:                 NS_ASSERTION(val->mLeft.GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:             } break;
    1: 
    1:             case eCSSType_ValuePair: {
 3233:                 nsCSSValuePair* val = static_cast<nsCSSValuePair*>(prop);
    1:                 NS_ASSERTION(val->mXValue.GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:                 NS_ASSERTION(val->mYValue.GetUnit() == eCSSUnit_Null,
    1:                              "not initial state");
    1:             } break;
    1: 
    1:             case eCSSType_ValueList: {
 3233:                 nsCSSValueList* val = *static_cast<nsCSSValueList**>(prop);
    1:                 NS_ASSERTION(val == nsnull, "not initial state");
    1:             } break;
    1: 
16372:             case eCSSType_ValuePairList: {
16372:                 nsCSSValuePairList* val =
16372:                   *static_cast<nsCSSValuePairList**>(prop);
    1:                 NS_ASSERTION(val == nsnull, "not initial state");
    1:             } break;
    1:         }
    1:     }
    1: }
    1: #endif
