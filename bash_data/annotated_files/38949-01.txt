37412: /* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
37412: /* Cairo - a vector graphics library with display and print output
37412:  *
37412:  * Copyright © 2010 Mozilla Foundation
37412:  *
37412:  * This library is free software; you can redistribute it and/or
37412:  * modify it either under the terms of the GNU Lesser General Public
37412:  * License version 2.1 as published by the Free Software Foundation
37412:  * (the "LGPL") or, at your option, under the terms of the Mozilla
37412:  * Public License Version 1.1 (the "MPL"). If you do not alter this
37412:  * notice, a recipient may use your version of this file under either
37412:  * the MPL or the LGPL.
37412:  *
37412:  * You should have received a copy of the LGPL along with this library
37412:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
37412:  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
37412:  * You should have received a copy of the MPL along with this library
37412:  * in the file COPYING-MPL-1.1
37412:  *
37412:  * The contents of this file are subject to the Mozilla Public License
37412:  * Version 1.1 (the "License"); you may not use this file except in
37412:  * compliance with the License. You may obtain a copy of the License at
37412:  * http://www.mozilla.org/MPL/
37412:  *
37412:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
37412:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
37412:  * the specific language governing rights and limitations.
37412:  *
37412:  * The Original Code is the cairo graphics library.
37412:  *
37412:  * The Initial Developer of the Original Code is the Mozilla Foundation
37412:  *
37412:  * Contributor(s):
37412:  *	Bas Schouten <bschouten@mozilla.com>
37412:  */
37412: #define INITGUID
37412: 
37412: #include "cairo.h"
37412: #include "cairo-d2d-private.h"
37412: #include "cairo-dwrite-private.h"
37412: 
37412: extern "C" {
37412: #include "cairo-win32.h"
37412: #include "cairo-analysis-surface-private.h"
37412: }
37412: 
37412: 
37412: ID2D1Factory *D2DSurfFactory::mFactoryInstance = NULL;
37412: ID3D10Device1 *D3D10Factory::mDeviceInstance = NULL;
37412: 
37412: #define CAIRO_INT_STATUS_SUCCESS (cairo_int_status_t)CAIRO_STATUS_SUCCESS
37412: 
37412: /**
37412:  * Create a similar surface which will blend effectively to
37412:  * another surface. For D2D, this will create another texture.
37412:  * Within the types we use blending is always easy.
37412:  *
37412:  * \param surface Surface this needs to be similar to
37412:  * \param content Content type of the new surface
37412:  * \param width Width of the new surface
37412:  * \param height Height of the new surface
37412:  * \return New surface
37412:  */
37412: static cairo_surface_t*
37412: _cairo_d2d_create_similar(void			*surface,
37412: 			  cairo_content_t	 content,
37412: 			  int			 width,
37412: 			  int			 height);
37412: 
37412: /**
37412:  * Release all the data held by a surface, the surface structure
37412:  * itsself will be freed by cairo.
37412:  *
37412:  * \param surface Surface to clean up
37412:  */
37412: static cairo_status_t
37412: _cairo_d2d_finish(void	    *surface);
37412: 
37412: /**
37412:  * Get a read-only image surface that contains the pixel data
37412:  * of a D2D surface.
37412:  *
37412:  * \param abstract_surface D2D surface to acquire the image from
37412:  * \param image_out Pointer to where we should store the image surface pointer
37412:  * \param image_extra Pointer where to store extra data we want to know about
37412:  * at the point of release.
37412:  * \return CAIRO_STATUS_SUCCESS for success
37412:  */
37412: static cairo_status_t
37412: _cairo_d2d_acquire_source_image(void                    *abstract_surface,
37412: 				cairo_image_surface_t  **image_out,
37412: 				void                   **image_extra);
37412: 
37412: /**
37412:  * Release a read-only image surface that was obtained using acquire_source_image
37412:  *
37412:  * \param abstract_surface D2D surface to acquire the image from
37412:  * \param image_out Pointer to where we should store the image surface pointer
37412:  * \param image_extra Pointer where to store extra data we want to know about
37412:  * at the point of release.
37412:  * \return CAIRO_STATUS_SUCCESS for success
37412:  */
37412: static void
37412: _cairo_d2d_release_source_image(void                   *abstract_surface,
37412: 				cairo_image_surface_t  *image,
37412: 				void                   *image_extra);
37412: 
37412: /**
37412:  * Get a read-write image surface that contains the pixel data
37412:  * of a D2D surface.
37412:  *
37412:  * \param abstract_surface D2D surface to acquire the image from
37412:  * \param image_out Pointer to where we should store the image surface pointer
37412:  * \param image_extra Pointer where to store extra data we want to know about
37412:  * at the point of release.
37412:  * \return CAIRO_STATUS_SUCCESS for success
37412:  */
37412: static cairo_status_t
37412: _cairo_d2d_acquire_dest_image(void                    *abstract_surface,
37412: 			      cairo_rectangle_int_t   *interest_rect,
37412: 			      cairo_image_surface_t  **image_out,
37412: 			      cairo_rectangle_int_t   *image_rect,
37412: 			      void                   **image_extra);
37412: 
37412: /**
37412:  * Release a read-write image surface that was obtained using acquire_source_image
37412:  *
37412:  * \param abstract_surface D2D surface to acquire the image from
37412:  * \param image_out Pointer to where we should store the image surface pointer
37412:  * \param image_extra Pointer where to store extra data we want to know about
37412:  * at the point of release.
37412:  * \return CAIRO_STATUS_SUCCESS for success
37412:  */
37412: static void
37412: _cairo_d2d_release_dest_image(void                    *abstract_surface,
37412: 			      cairo_rectangle_int_t   *interest_rect,
37412: 			      cairo_image_surface_t   *image,
37412: 			      cairo_rectangle_int_t   *image_rect,
37412: 			      void                    *image_extra);
37412: 
37412: /**
37412:  * Flush this surface, only after this operation is the related hardware texture
37412:  * guaranteed to contain all the results of the executed drawing operations.
37412:  *
37412:  * \param surface D2D surface to flush
37412:  * \return CAIRO_STATUS_SUCCESS or CAIRO_SURFACE_TYPE_MISMATCH
37412:  */
37412: static cairo_status_t
37412: _cairo_d2d_flush(void                  *surface);
37412: 
37412: /**
37412:  * Fill a path on this D2D surface.
37412:  *
37412:  * \param surface The surface to apply this operation to, must be
37412:  * a D2D surface
37412:  * \param op The operator to use
37412:  * \param source The source pattern to fill this path with
37412:  * \param path The path to fill
37412:  * \param fill_rule The fill rule to uses on the path
37412:  * \param tolerance The tolerance applied to the filling
37412:  * \param antialias The anti-alias mode to use
37412:  * \param extents The extents of the surface to which to apply this operation
37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_fill(void			*surface,
37412: 		cairo_operator_t	 op,
37412: 		const cairo_pattern_t	*source,
37412: 		cairo_path_fixed_t	*path,
37412: 		cairo_fill_rule_t	 fill_rule,
37412: 		double			 tolerance,
37412: 		cairo_antialias_t	 antialias,
37412: 		cairo_rectangle_int_t	*extents);
37412: 
37412: /**
37412:  * Paint this surface, applying the operation to the entire surface
37412:  * or to the passed in 'extents' of the surface.
37412:  *
37412:  * \param surface The surface to apply this operation to, must be
37412:  * a D2D surface
37412:  * \param op Operator to use when painting
37412:  * \param source The pattern to fill this surface with, source of the op
37412:  * \param Extents of the surface to apply this operation to
37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_paint(void			*surface,
37412: 		 cairo_operator_t	 op,
37412: 		 const cairo_pattern_t	*source,
37412: 		 cairo_rectangle_int_t  *extents);
37412: 
37412: /**
37412:  * Paint something on the surface applying a certain mask to that
37412:  * source.
37412:  *
37412:  * \param surface The surface to apply this oepration to, must be
37412:  * a D2D surface
37412:  * \param op Operator to use
37412:  * \param source Source for this operation
37412:  * \param mask Pattern to mask source with
37412:  * \param extents Extents of the surface to apply this operation to
37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_mask(void			*surface,
37412: 		cairo_operator_t	 op,
37412: 		const cairo_pattern_t	*source,
37412: 		const cairo_pattern_t	*mask,
37412: 		cairo_rectangle_int_t  *extents);
37412: 
37412: /**
37412:  * Show a glyph run on the target D2D surface.
37412:  *
37412:  * \param surface The surface to apply this oepration to, must be
37412:  * a D2D surface
37412:  * \param op Operator to use
37412:  * \param source Source for this operation
37412:  * \param glyphs Glyphs to draw
37412:  * \param num_gluphs Amount of glyphs stored at glyphs
37412:  * \param scaled_font Scaled font to draw
37412:  * \param remaining_glyphs Pointer to store amount of glyphs still
37412:  * requiring drawing.
37412:  * \param extents Extents this operation applies to.
37412:  * \return CAIRO_ERROR_SURFACE_TYPE_MISMATCH, CAIRO_ERROR_FONT_TYPE_MISMATCH,
37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_show_glyphs (void			*surface,
37412: 			cairo_operator_t	 op,
37412: 			const cairo_pattern_t	*source,
37412: 			cairo_glyph_t		*glyphs,
37412: 			int			 num_glyphs,
37412: 			cairo_scaled_font_t	*scaled_font,
37412: 			int			*remaining_glyphs,
37412: 			cairo_rectangle_int_t	*extents);
37412: 
37412: /**
37412:  * Get the extents of this surface.
37412:  *
37412:  * \param surface D2D surface to get the extents for
37412:  * \param extents Pointer to where to store the extents
37412:  * \param CAIRO_ERROR_SURFACE_TYPE_MISTMATCH or CAIRO_STATUS_SUCCESS
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_getextents(void		       *surface,
37412: 		      cairo_rectangle_int_t    *extents);
37412: 
37412: 
37412: /**
37412:  * See cairo backend documentation.
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_intersect_clip_path(void			*dst,
37412: 			       cairo_path_fixed_t	*path,
37412: 			       cairo_fill_rule_t	fill_rule,
37412: 			       double			tolerance,
37412: 			       cairo_antialias_t	antialias);
37412: 
37412: /**
37412:  * Stroke a path on this D2D surface.
37412:  *
37412:  * \param surface The surface to apply this operation to, must be
37412:  * a D2D surface
37412:  * \param op The operator to use
37412:  * \param source The source pattern to fill this path with
37412:  * \param path The path to stroke
37412:  * \param style The style of the stroke
37412:  * \param ctm A logical to device matrix, since the path might be in
37412:  * device space the miter angle and such are not, hence we need to
37412:  * be aware of the transformation to apply correct stroking.
37412:  * \param ctm_inverse Inverse of ctm, used to transform the path back
37412:  * to logical space.
37412:  * \param tolerance Tolerance to stroke with
37412:  * \param antialias Antialias mode to use
37412:  * \param extents Extents of the surface to apply this operation to
37412:  * \return Return code, this can be CAIRO_ERROR_SURFACE_TYPE_MISMATCH,
37412:  * CAIRO_INT_STATUS_UNSUPPORTED or CAIRO_STATUS_SUCCESS
37412:  */
37412: static cairo_int_status_t
37412: _cairo_d2d_stroke(void			*surface,
37412: 		  cairo_operator_t	 op,
37412: 		  const cairo_pattern_t	*source,
37412: 		  cairo_path_fixed_t	*path,
37412: 		  cairo_stroke_style_t	*style,
37412: 		  cairo_matrix_t	*ctm,
37412: 		  cairo_matrix_t	*ctm_inverse,
37412: 		  double		 tolerance,
37412: 		  cairo_antialias_t	 antialias,
37412: 		  cairo_rectangle_int_t  *extents);
37412: 
37412: static const cairo_surface_backend_t cairo_d2d_surface_backend = {
37412:     CAIRO_SURFACE_TYPE_D2D,
37412:     _cairo_d2d_create_similar, /* create_similar */
37412:     _cairo_d2d_finish, /* finish */
37412:     _cairo_d2d_acquire_source_image, /* acquire_source_image */
37412:     _cairo_d2d_release_source_image, /* release_source_image */
37412:     _cairo_d2d_acquire_dest_image, /* acquire_dest_image */
37412:     _cairo_d2d_release_dest_image, /* release_dest_image */
37412:     NULL, /* clone_similar */
37412:     NULL, /* composite */
37412:     NULL, /* fill_rectangles */
37412:     NULL, /* composite_trapezoids */
37412:     NULL, /* create_span_renderer */
37412:     NULL, /* check_span_renderer */
37412:     NULL, /* copy_page */
37412:     NULL, /* show_page */
37412:     NULL, /* set_clip_region */
37412:     _cairo_d2d_intersect_clip_path, /* intersect_clip_path */
37412:     _cairo_d2d_getextents, /* getextents */
37412:     NULL, /* old_show_glyphs */
37412:     NULL, /* get_font_options */
37412:     _cairo_d2d_flush, /* flush */
37412:     NULL, /* mark_dirty_rectangle */
37412:     NULL, /* scaled_font_fini */
37412:     NULL, /* scaled_glyph_fini */
37412:     _cairo_d2d_paint, /* paint */
37412:     _cairo_d2d_mask, /* mask */
37412:     _cairo_d2d_stroke, /* stroke */
37412:     _cairo_d2d_fill, /* fill */
37412:     _cairo_d2d_show_glyphs, /* show_glyphs */
37412:     NULL, /* snapshot */
37412:     NULL,
37412:     NULL
37412: };
37412: 
37412: /*
37412:  * Helper functions.
37412:  */
37412: 
37412: static D2D1_POINT_2F
37412: _d2d_point_from_cairo_point(const cairo_point_t *point)
37412: {
37412:     return D2D1::Point2F(_cairo_fixed_to_float(point->x),
37412: 			 _cairo_fixed_to_float(point->y));
37412: }
37412: 
37412: static D2D1_COLOR_F
37412: _cairo_d2d_color_from_cairo_color(const cairo_color_t &color)
37412: {
37412:     return D2D1::ColorF((FLOAT)color.red, 
37412: 			(FLOAT)color.green, 
37412: 			(FLOAT)color.blue,
37412: 			(FLOAT)color.alpha);
37412: }
37412: 
37412: /**
37412:  * Gets the surface buffer texture for window surfaces whose backbuffer
37412:  * is not directly usable as a bitmap.
37412:  *
37412:  * \param surface D2D surface.
37412:  * \return Buffer texture
37412:  */
37412: static ID3D10Texture2D*
37412: _cairo_d2d_get_buffer_texture(cairo_d2d_surface_t *surface) 
37412: {
37412:     if (!surface->bufferTexture) {
37412: 	DXGI_SURFACE_DESC surfDesc;
37412: 	surface->backBuf->GetDesc(&surfDesc);
37412: 	CD3D10_TEXTURE2D_DESC softDesc(surfDesc.Format, surfDesc.Width, surfDesc.Height);
37412:         softDesc.MipLevels = 1;
37412: 	softDesc.Usage = D3D10_USAGE_DEFAULT;
37412: 	softDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
37412: 	D3D10Factory::Device()->CreateTexture2D(&softDesc, NULL, &surface->bufferTexture);
37412:     }
37412:     return surface->bufferTexture;
37412: }
37412: 
37412: /**
37412:  * Ensure that the surface has an up-to-date surface bitmap. Used for
37412:  * window surfaces which cannot have a surface bitmap directly related
37412:  * to their backbuffer for some reason.
37412:  * You cannot create a bitmap around a backbuffer surface for reason (it will 
37412:  * fail with an E_INVALIDARG). Meaning they need a special texture to store 
37412:  * their graphical data which is wrapped by a D2D bitmap if a window surface 
37412:  * is ever used in a surface pattern. All other D2D surfaces use a texture as 
37412:  * their backing store so can have a bitmap directly.
37412:  *
37412:  * \param surface D2D surface.
37412:  */
37412: static void _cairo_d2d_update_surface_bitmap(cairo_d2d_surface_t *d2dsurf)
37412: {
37412:     if (!d2dsurf->backBuf) {
37412: 	return;
37412:     }
37412:     ID3D10Texture2D *texture = _cairo_d2d_get_buffer_texture(d2dsurf);
37412:     if (!d2dsurf->surfaceBitmap) {
37412: 	IDXGISurface *dxgiSurface;
37412: 	D2D1_ALPHA_MODE alpha;
37412: 	if (d2dsurf->base.content == CAIRO_CONTENT_COLOR) {
37412: 	    alpha = D2D1_ALPHA_MODE_IGNORE;
37412: 	} else {
37412: 	    alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
37412: 	}
37412:         /** Using DXGI_FORMAT_UNKNOWN will automatically use the texture's format. */
37412: 	D2D1_BITMAP_PROPERTIES bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
37412: 										   alpha));
37412: 	texture->QueryInterface(&dxgiSurface);
37412: 	d2dsurf->rt->CreateSharedBitmap(IID_IDXGISurface,
37412: 					dxgiSurface,
37412: 					&bitProps,
37412: 					&d2dsurf->surfaceBitmap);
37412: 	dxgiSurface->Release();
37412:     }
37412:     D3D10Factory::Device()->CopyResource(texture, d2dsurf->surface);
37412: }
37412: 
37412: /**
37412:  * Present the backbuffer for a surface create for an HWND. This needs
37412:  * to be called when the owner of the original window surface wants to
37412:  * actually present the executed drawing operations to the screen.
37412:  *
37412:  * \param surface D2D surface.
37412:  */
37412: void cairo_d2d_present_backbuffer(cairo_surface_t *surface)
37412: {
37412:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
37412: 	return;
37412:     }
37412:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
37412:     _cairo_d2d_flush(d2dsurf);
37412:     if (d2dsurf->dxgiChain) {
37412: 	d2dsurf->dxgiChain->Present(0, 0);
37412: 	D3D10Factory::Device()->Flush();
37412:     }
37412: }
37412: 
37412: /**
37412:  * Push the clipping are cairo has currently set to the render target.
37412:  * This needs to be balanced with pops, where both -must- be while inside
37412:  * the drawing state.
37412:  *
37412:  * \param d2dsurf Surface
37412:  */
37412: static void
37412: _cairo_d2d_surface_push_clip(cairo_d2d_surface_t *d2dsurf)
37412: {
37412:     if (d2dsurf->isDrawing) {
37412: 	if (d2dsurf->clipMask) {
37412: 	    if (!d2dsurf->clipLayer) {
37412: 		d2dsurf->rt->CreateLayer(&d2dsurf->clipLayer);
37412: 	    }
37412: 	    D2D1_RECT_F bounds;
37412: 	    d2dsurf->clipMask->GetBounds(D2D1::IdentityMatrix(), &bounds);
37412: 	    d2dsurf->rt->PushLayer(D2D1::LayerParameters(bounds,
37412: 							 d2dsurf->clipMask,
37412: 							 D2D1_ANTIALIAS_MODE_ALIASED,
37412: 							 D2D1::IdentityMatrix(),
37412: 							 1.0,
37412: 							 0,
37412: 							 D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE),
37412: 				   d2dsurf->clipLayer);
37412: 	}
37412: 	if (d2dsurf->clipRect) {
37412: 	    d2dsurf->rt->PushAxisAlignedClip(d2dsurf->clipRect, D2D1_ANTIALIAS_MODE_ALIASED);
37412: 	}
37412: 	d2dsurf->clipping = true;
37412:     }
37412: }
37412: 
37412: /**
37412:  * Pop the clipping area cairo has currently set to the render target.
37412:  * This needs to be balanced with pushes, where both -must- be while inside
37412:  * the drawing state.
37412:  *
37412:  * \param d2dsurf Surface
37412:  */
37412: static void
37412: _cairo_d2d_surface_pop_clip(cairo_d2d_surface_t *d2dsurf)
37412: {
37412:     if (d2dsurf->isDrawing) {
37412: 	if (d2dsurf->clipping) {
37412: 	    if (d2dsurf->clipMask) {
37412: 		d2dsurf->rt->PopLayer();
37412: 	    }
37412: 	    if (d2dsurf->clipRect) {
37412: 		d2dsurf->rt->PopAxisAlignedClip();
37412: 	    }
37412: 	    d2dsurf->clipping = false;
37412: 	}
37412:     }
37412: }
37412: 
37412: /**
37412:  * Enter the state where the surface is ready for drawing. This will guarantee
37412:  * the surface is in the correct state, and the correct clipping area is pushed.
37412:  *
37412:  * \param surface D2D surface
37412:  */
37412: static void _begin_draw_state(cairo_d2d_surface_t* surface)
37412: {
37412:     if (!surface->isDrawing) {
37412: 	surface->rt->BeginDraw();
37412: 	surface->isDrawing = true;
37412:     }
37412:     if (!surface->clipping) {
37412: 	_cairo_d2d_surface_push_clip(surface);
37412:     }
37412: }
37412: 
37412: /**
37412:  * Get a D2D matrix from a cairo matrix. Note that D2D uses row vectors where cairo
37412:  * uses column vectors. Hence the transposition.
37412:  *
37412:  * \param Cairo matrix
37412:  * \return D2D matrix
37412:  */
37412: static D2D1::Matrix3x2F
37412: _cairo_d2d_matrix_from_matrix(const cairo_matrix_t *matrix)
37412: {
37412:     return D2D1::Matrix3x2F((FLOAT)matrix->xx,
37412: 			    (FLOAT)matrix->yx,
37412: 			    (FLOAT)matrix->xy,
37412: 			    (FLOAT)matrix->yy,
37412: 			    (FLOAT)matrix->x0,
37412: 			    (FLOAT)matrix->y0);
37412: }
37412: 
37412: /**
37412:  * Create a D2D stroke style interface for a cairo stroke style object. Must be
37412:  * released when the calling function is finished with it.
37412:  *
37412:  * \param style Cairo stroke style object
37412:  * \return D2D StrokeStyle interface
37412:  */
37412: static ID2D1StrokeStyle*
37412: _cairo_d2d_create_strokestyle_for_stroke_style(const cairo_stroke_style_t *style)
37412: {
37412:     D2D1_CAP_STYLE line_cap = D2D1_CAP_STYLE_FLAT;
37412:     switch (style->line_cap) {
37412: 	case CAIRO_LINE_CAP_BUTT:
37412: 	    line_cap = D2D1_CAP_STYLE_FLAT;
37412: 	    break;
37412: 	case CAIRO_LINE_CAP_SQUARE:
37412: 	    line_cap = D2D1_CAP_STYLE_SQUARE;
37412: 	    break;
37412: 	case CAIRO_LINE_CAP_ROUND:
37412: 	    line_cap = D2D1_CAP_STYLE_ROUND;
37412: 	    break;
37412:     }
37412: 
37412:     D2D1_LINE_JOIN line_join = D2D1_LINE_JOIN_MITER;
37412:     switch (style->line_join) {
37412: 	case CAIRO_LINE_JOIN_MITER:
37412: 	    line_join = D2D1_LINE_JOIN_MITER;
37412: 	    break;
37412: 	case CAIRO_LINE_JOIN_ROUND:
37412: 	    line_join = D2D1_LINE_JOIN_ROUND;
37412: 	    break;
37412: 	case CAIRO_LINE_JOIN_BEVEL:
37412: 	    line_join = D2D1_LINE_JOIN_BEVEL;
37412: 	    break;
37412:     }
37412: 
37412:     FLOAT *dashes = NULL;
37412:     if (style->num_dashes) {
37412: 	dashes = new FLOAT[style->num_dashes];
37412: 	for (unsigned int i = 0; i < style->num_dashes; i++) {
37412: 	    dashes[i] = (FLOAT)style->dash[i];
37412: 	}
37412:     }
37412: 
37412:     D2D1_DASH_STYLE dashStyle = D2D1_DASH_STYLE_SOLID;
37412:     if (dashes) {
37412: 	dashStyle = D2D1_DASH_STYLE_CUSTOM;
37412:     }
37412: 
37412:     ID2D1StrokeStyle *strokeStyle;
37412:     D2DSurfFactory::Instance()->CreateStrokeStyle(D2D1::StrokeStyleProperties(line_cap, 
37412: 									      line_cap,
37412: 									      line_cap, 
37412: 									      line_join, 
37412: 									      (FLOAT)style->miter_limit,
37412: 									      dashStyle,
37412: 									      (FLOAT)style->dash_offset),
37412: 						  dashes,
37412: 						  style->num_dashes,
37412: 						  &strokeStyle);
37412:     delete [] dashes;
37412:     return strokeStyle;
37412: }
37412: 
37412: cairo_user_data_key_t bitmap_key;
37412: 
37412: struct cached_bitmap {
37412:     /** The cached bitmap */
37412:     ID2D1Bitmap *bitmap;
37412:     /** The cached bitmap was created with a transparent rectangle around it */
37412:     bool isNoneExtended;
37412:     /** The cached bitmap is dirty and needs its data refreshed */
37412:     bool dirty;
37412:     /** Order of snapshot detach/release bitmap called not guaranteed, single threaded refcount for now */
37412:     int refs;
37412: };
37412: 
37412: /** 
37412:  * This is called when user data on a surface is replaced or the surface is
37412:  * destroyed.
37412:  */
37412: static void _d2d_release_bitmap(void *bitmap)
37412: {
37412:     cached_bitmap *bitmp = (cached_bitmap*)bitmap;
37412:     bitmp->bitmap->Release();
37412:     if (!--bitmp->refs) {
37412: 	delete bitmap;
37412:     }
37412: }
37412: 
37412: /**
37412:  * Via a little trick this is just used to determine when a surface has been
37412:  * modified.
37412:  */
37412: static void _d2d_snapshot_detached(cairo_surface_t *surface)
37412: {
37412:     cached_bitmap *existingBitmap = (cached_bitmap*)cairo_surface_get_user_data(surface, &bitmap_key);
37412:     if (existingBitmap) {
37412: 	existingBitmap->dirty = true;
37412:     }
37412:     if (!--existingBitmap->refs) {
37412: 	delete existingBitmap;
37412:     }
37412:     cairo_surface_destroy(surface);
37412: }
37412: 
37412: /**
37412:  * This creates an ID2D1Brush that will fill with the correct pattern.
37412:  * This function passes a -strong- reference to the caller, the brush
37412:  * needs to be released, even if it is not unique. This function can
37412:  * potentially return multiple brushes, in order to facilitate drawing
37412:  * surfaces which do not fit in a single bitmap. It will then be responsible
37412:  * for providing the proper clipping.
37412:  *
37412:  * \param d2dsurf Surface to create a brush for
37412:  * \param pattern The pattern to create a brush for
37412:  * \param unique We cache the bitmap/color brush for speed. If this
37412:  * needs a brush that is unique (i.e. when more than one is needed),
37412:  * this will make the function return a seperate brush.
37412:  * \return A brush object
37412:  */
37412: ID2D1Brush*
37412: _cairo_d2d_create_brush_for_pattern(cairo_d2d_surface_t *d2dsurf, 
37412: 				    const cairo_pattern_t *pattern,
37412: 				    unsigned int last_run,
37412: 				    unsigned int *remaining_runs,
37412: 				    bool *pushed_clip,
37412: 				    bool unique)
37412: {
37412:     *remaining_runs = 1;
37412:     *pushed_clip = false;
37412: 
37412:     if (pattern->type == CAIRO_PATTERN_TYPE_SOLID) {
37412: 	cairo_solid_pattern_t *sourcePattern =
37412: 	    (cairo_solid_pattern_t*)pattern;
37412: 	D2D1_COLOR_F color = _cairo_d2d_color_from_cairo_color(sourcePattern->color);
37412: 	if (unique) {
37412: 	    ID2D1SolidColorBrush *brush;
37412: 	    d2dsurf->rt->CreateSolidColorBrush(color,
37412: 					       &brush);
37412: 	    *remaining_runs = 0;
37412: 	    return brush;
37412: 	} else {
37412: 	    if (d2dsurf->solidColorBrush->GetColor().a != color.a ||
37412: 		d2dsurf->solidColorBrush->GetColor().r != color.r ||
37412: 		d2dsurf->solidColorBrush->GetColor().g != color.g ||
37412: 		d2dsurf->solidColorBrush->GetColor().b != color.b) {
37412: 		d2dsurf->solidColorBrush->SetColor(color);
37412: 	    }
37412: 	    d2dsurf->solidColorBrush->AddRef();
37412: 	    *remaining_runs = 0;
37412: 	    return d2dsurf->solidColorBrush;
37412: 	}
37412: 
37412:     } else if (pattern->type == CAIRO_PATTERN_TYPE_LINEAR) {
37412: 	cairo_matrix_t mat = pattern->matrix;
37412: 	/**
37412: 	 * Cairo views this matrix as the transformation of the destination
37412: 	 * when the pattern is imposed. We see this differently, D2D transformation
37412: 	 * moves the pattern over the destination.
37412: 	 */
37412: 	cairo_matrix_invert(&mat);
37412: 
37412: 	D2D1_BRUSH_PROPERTIES brushProps =
37412: 	    D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&mat));
37412: 	cairo_linear_pattern_t *sourcePattern =
37412: 	    (cairo_linear_pattern_t*)pattern;
37412: 
37412: 	D2D1_GRADIENT_STOP *stops = 
37412: 	    new D2D1_GRADIENT_STOP[sourcePattern->base.n_stops];
37412: 	for (unsigned int i = 0; i < sourcePattern->base.n_stops; i++) {
37412: 	    stops[i].position = (FLOAT)sourcePattern->base.stops[i].offset;
37412: 	    stops[i].color = 
37412: 		_cairo_d2d_color_from_cairo_color(sourcePattern->base.stops[i].color);
37412: 	}
37412: 	ID2D1GradientStopCollection *stopCollection;
37412: 	d2dsurf->rt->CreateGradientStopCollection(stops, sourcePattern->base.n_stops, &stopCollection);
37412: 	ID2D1LinearGradientBrush *brush;
37412: 	d2dsurf->rt->CreateLinearGradientBrush(D2D1::LinearGradientBrushProperties(_d2d_point_from_cairo_point(&sourcePattern->p1),
37412: 										   _d2d_point_from_cairo_point(&sourcePattern->p2)),
37412: 					       brushProps,
37412: 					       stopCollection,
37412: 					       &brush);
37412: 	delete [] stops;
37412: 	stopCollection->Release();
37412: 	*remaining_runs = 0;
37412: 	return brush;
37412: 
37412:     } else if (pattern->type == CAIRO_PATTERN_TYPE_RADIAL) {
37412: 	cairo_matrix_t mat = pattern->matrix;
37412: 	cairo_matrix_invert(&mat);
37412: 
37412: 	D2D1_BRUSH_PROPERTIES brushProps =
37412: 	    D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&mat));
37412: 	cairo_radial_pattern_t *sourcePattern =
37412: 	    (cairo_radial_pattern_t*)pattern;
37412: 	
37412: 	if ((sourcePattern->c1.x != sourcePattern->c2.x ||
37412: 	    sourcePattern->c1.y != sourcePattern->c2.y) &&
37412: 	    sourcePattern->r1 != 0) {
37412: 		/**
37412: 		 * In this particular case there's no way to deal with this!
37412: 		 * \todo Create an image surface with the gradient and use that.
37412: 		 */
37412: 		return NULL;
37412: 	}
37412: 	D2D_POINT_2F center =
37412: 	    _d2d_point_from_cairo_point(&sourcePattern->c2);
37412: 	D2D_POINT_2F origin =
37412: 	    _d2d_point_from_cairo_point(&sourcePattern->c1);
37412: 	origin.x -= center.x;
37412: 	origin.y -= center.y;
37412: 
37412: 	D2D1_GRADIENT_STOP *stops = 
37412: 	    new D2D1_GRADIENT_STOP[sourcePattern->base.n_stops];
37412: 	for (unsigned int i = 0; i < sourcePattern->base.n_stops; i++) {
37412: 	    stops[i].position = (FLOAT)sourcePattern->base.stops[i].offset;
37412: 	    stops[i].color = 
37412: 		_cairo_d2d_color_from_cairo_color(sourcePattern->base.stops[i].color);
37412: 	}
37412: 	ID2D1GradientStopCollection *stopCollection;
37412: 	d2dsurf->rt->CreateGradientStopCollection(stops, sourcePattern->base.n_stops, &stopCollection);
37412: 	ID2D1RadialGradientBrush *brush;
37412: 
37412: 	d2dsurf->rt->CreateRadialGradientBrush(D2D1::RadialGradientBrushProperties(center,
37412: 										   origin,
37412: 										   _cairo_fixed_to_float(sourcePattern->r2),
37412: 										   _cairo_fixed_to_float(sourcePattern->r2)),
37412: 					       brushProps,
37412: 					       stopCollection,
37412: 					       &brush);
37412: 	stopCollection->Release();
37412: 	delete [] stops;
37412: 	*remaining_runs = 0;
37412: 	return brush;
37412: 
37412:     } else if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE) {
37412: 	cairo_matrix_t mat = pattern->matrix;
37412: 	cairo_matrix_invert(&mat);
37412: 
37412: 	cairo_surface_pattern_t *surfacePattern =
37412: 	    (cairo_surface_pattern_t*)pattern;
37412: 	D2D1_EXTEND_MODE extendMode;
37412: 	bool nonExtended = false;
37412: 	if (pattern->extend == CAIRO_EXTEND_NONE) {
37412: 	    extendMode = D2D1_EXTEND_MODE_CLAMP;
37412: 	    nonExtended = true;
37412: 	    /** 
37412: 	     * For image surfaces we create a slightly larger bitmap with
37412: 	     * a transparent border around it for this case. Need to translate
37412: 	     * for that.
37412: 	     */
37412: 	    if (surfacePattern->surface->type == CAIRO_SURFACE_TYPE_IMAGE) {
37412: 		cairo_matrix_translate(&mat, -1.0, -1.0);
37412: 	    }
37412: 	} else if (pattern->extend == CAIRO_EXTEND_REPEAT) {
37412: 	    extendMode = D2D1_EXTEND_MODE_WRAP;
37412: 	} else if (pattern->extend == CAIRO_EXTEND_REFLECT) {
37412: 	    extendMode = D2D1_EXTEND_MODE_MIRROR;
37412: 	} else {
37412: 	    extendMode = D2D1_EXTEND_MODE_CLAMP;
37412: 	}
37412: 	ID2D1Bitmap *sourceBitmap;
37412: 	bool tiled = false;
37412: 	unsigned int xoffset = 0;
37412: 	unsigned int yoffset = 0;
37412: 	unsigned int width;
37412: 	unsigned int height;
37412: 	*remaining_runs = 0;
37412: 	if (surfacePattern->surface->type == CAIRO_SURFACE_TYPE_D2D) {
37412: 	    /**
37412: 	     * \todo We need to somehow get a rectangular transparent
37412: 	     * border here too!!
37412: 	     */
37412: 	    cairo_d2d_surface_t *srcSurf = 
37412: 		reinterpret_cast<cairo_d2d_surface_t*>(surfacePattern->surface);
37412: 
37412: 	    _cairo_d2d_update_surface_bitmap(srcSurf);
37412: 	    sourceBitmap = srcSurf->surfaceBitmap;
37412: 
37412: 	    _cairo_d2d_flush(srcSurf);
37412: 	} else if (surfacePattern->surface->type == CAIRO_SURFACE_TYPE_IMAGE) {
37412: 	    cairo_image_surface_t *srcSurf = 
37412: 		reinterpret_cast<cairo_image_surface_t*>(surfacePattern->surface);
37412: 	    D2D1_ALPHA_MODE alpha;
37412: 	    if (srcSurf->format == CAIRO_FORMAT_ARGB32 ||
37412: 		srcSurf->format == CAIRO_FORMAT_A8) {
37412: 		alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
37412: 	    } else {
37412: 		alpha = D2D1_ALPHA_MODE_IGNORE;
37412: 	    }
37412: 
37412: 	    DXGI_FORMAT format;
37412: 	    unsigned int Bpp;
37412: 	    if (srcSurf->format == CAIRO_FORMAT_ARGB32) {
37412: 		format = DXGI_FORMAT_B8G8R8A8_UNORM;
37412: 		Bpp = 4;
37412: 	    } else if (srcSurf->format == CAIRO_FORMAT_RGB24) {
37412: 		format = DXGI_FORMAT_B8G8R8A8_UNORM;
37412: 		Bpp = 4;
37412: 	    } else if (srcSurf->format == CAIRO_FORMAT_A8) {
37412: 		format = DXGI_FORMAT_A8_UNORM;
37412: 		Bpp = 1;
37412: 	    } else {
37412: 		return NULL;
37412: 	    }
37412: 
37412: 	    /** Leave room for extend_none space, 2 pixels */
37412: 	    UINT32 maxSize = d2dsurf->rt->GetMaximumBitmapSize() - 2;
37412: 
37412: 	    if ((UINT32)srcSurf->width > maxSize || (UINT32)srcSurf->height > maxSize) {
37412: 		tiled = true;
37412: 		UINT32 horiz_tiles = (UINT32)ceil((float)srcSurf->width / maxSize);
37412: 		UINT32 vert_tiles = (UINT32)ceil((float)srcSurf->height / maxSize);
37412: 		UINT32 current_vert_tile = last_run / horiz_tiles;
37412: 		UINT32 current_horiz_tile = last_run % horiz_tiles;
37412: 		xoffset = current_horiz_tile * maxSize;
37412: 		yoffset = current_vert_tile * maxSize;
37412: 		*remaining_runs = horiz_tiles * vert_tiles - last_run - 1;
37412: 		width = min(maxSize, srcSurf->width - maxSize * current_horiz_tile);
37412: 		height = min(maxSize, srcSurf->height - maxSize * current_vert_tile);
37412: 		// Move the image to the right spot.
37412: 		cairo_matrix_translate(&mat, xoffset, yoffset);
37412: 		if (true) {
37412: 		    ID2D1RectangleGeometry *clipRect;
37412: 		    D2DSurfFactory::Instance()->CreateRectangleGeometry(D2D1::RectF(0, 0, (float)width, (float)height),
37412: 									&clipRect);
37412: 
38944: 		    if (!d2dsurf->helperLayer) {
38944: 			d2dsurf->rt->CreateLayer(&d2dsurf->helperLayer);
37412: 		    }
37412: 		    
37412: 		    d2dsurf->rt->PushLayer(D2D1::LayerParameters(D2D1::InfiniteRect(),
37412: 								 clipRect,
37412: 								 D2D1_ANTIALIAS_MODE_PER_PRIMITIVE,
37412: 								 _cairo_d2d_matrix_from_matrix(&mat)),
38944: 					   d2dsurf->helperLayer);
37412: 		    *pushed_clip = true;
37412: 		    clipRect->Release();
37412: 		}
37412: 	    } else {
37412: 		width = srcSurf->width;
37412: 		height = srcSurf->height;
37412: 	    }
37412: 
37412: 	    cached_bitmap *cachebitmap = NULL;
37412: 	    if (!tiled) {
37412: 		cachebitmap = 
37412: 		    (cached_bitmap*)cairo_surface_get_user_data(
37412: 		    surfacePattern->surface,
37412: 		    &bitmap_key);
37412: 	    }
37412: 
37412: 	    if (cachebitmap && cachebitmap->isNoneExtended == nonExtended) {
37412: 		sourceBitmap = cachebitmap->bitmap;
37412: 		if (cachebitmap->dirty) {
37412: 		    D2D1_RECT_U rect;
37412: 		    /** No need to take tiling into account - tiled surfaces are never cached. */
37412: 		    if (nonExtended) {
37412: 			rect = D2D1::RectU(1, 1, srcSurf->width + 1, srcSurf->height + 1);
37412: 		    } else {
37412: 			rect = D2D1::RectU(0, 0, srcSurf->width, srcSurf->height);
37412: 		    }
37412: 		    sourceBitmap->CopyFromMemory(&rect,
37412: 						 srcSurf->data,
37412: 						 srcSurf->stride);
37412: 		    cairo_surface_t *nullSurf =
37412: 			_cairo_null_surface_create(CAIRO_CONTENT_COLOR_ALPHA);
37412: 		    cachebitmap->refs++;
37412: 		    cairo_surface_set_user_data(nullSurf,
37412: 						&bitmap_key,
37412: 						cachebitmap,
37412: 						NULL);
37412: 		    _cairo_surface_attach_snapshot(surfacePattern->surface,
37412: 						   nullSurf,
37412: 						   _d2d_snapshot_detached);
37412: 		}
37412: 	    } else {
37412: 		cached_bitmap *cachebitmap = new cached_bitmap;
37412: 		cachebitmap->isNoneExtended = nonExtended;
37412: 		if (pattern->extend != CAIRO_EXTEND_NONE) {
37412: 		    d2dsurf->rt->CreateBitmap(D2D1::SizeU(width, height),
37412: 							  srcSurf->data + yoffset * srcSurf->stride + xoffset,
37412: 							  srcSurf->stride,
37412: 							  D2D1::BitmapProperties(D2D1::PixelFormat(format,
37412: 												   alpha)),
37412: 					      &sourceBitmap);
37412: 		} else {
37412: 		    /**
37412: 		     * Trick here, we create a temporary rectangular
37412: 		     * surface with 1 pixel margin on each side. This
37412: 		     * provides a rectangular transparent border, that
37412: 		     * will ensure CLAMP acts as EXTEND_NONE. Perhaps
37412: 		     * this could be further optimized by not memsetting
37412: 		     * the whole array.
37412: 		     */
37412: 		    unsigned int tmpWidth = width + 2;
37412: 		    unsigned int tmpHeight = height + 2;
37412: 		    unsigned char *tmp = new unsigned char[tmpWidth * tmpHeight * Bpp];
37412: 		    memset(tmp, 0, tmpWidth * tmpHeight * Bpp);
37412: 		    for (unsigned int y = 0; y < height; y++) {
37412: 			memcpy(
37412: 			    tmp + tmpWidth * Bpp * y + tmpWidth * Bpp + Bpp, 
37412: 			    srcSurf->data + yoffset * srcSurf->stride + y * srcSurf->stride + xoffset, 
37412: 			    width * Bpp);
37412: 		    }
37412: 
37412: 		    d2dsurf->rt->CreateBitmap(D2D1::SizeU(tmpWidth, tmpHeight),
37412: 					      tmp,
37412: 					      tmpWidth * Bpp,
37412: 					      D2D1::BitmapProperties(D2D1::PixelFormat(format,
37412: 										       D2D1_ALPHA_MODE_PREMULTIPLIED)),
37412: 					      &sourceBitmap);
37412: 		    delete [] tmp;
37412: 		}
37412: 
37412: 		cachebitmap->dirty = false;
37412: 		cachebitmap->bitmap = sourceBitmap;
37412: 		cachebitmap->refs = 2;
37412: 		cairo_surface_set_user_data(surfacePattern->surface,
37412: 					    &bitmap_key,
37412: 					    cachebitmap,
37412: 					    _d2d_release_bitmap);
37412: 		cairo_surface_t *nullSurf =
37412: 		    _cairo_null_surface_create(CAIRO_CONTENT_COLOR_ALPHA);
37412: 		cairo_surface_set_user_data(nullSurf,
37412: 					    &bitmap_key,
37412: 					    cachebitmap,
37412: 					    NULL);
37412: 		_cairo_surface_attach_snapshot(surfacePattern->surface,
37412: 					       nullSurf,
37412: 					       _d2d_snapshot_detached);
37412: 	    }
37412: 	} else {
37412: 	    return NULL;
37412: 	}
37412: 	D2D1_BITMAP_BRUSH_PROPERTIES bitProps;
37412: 	
37412: 	if (surfacePattern->base.filter == CAIRO_FILTER_NEAREST) {
37412: 	    bitProps = D2D1::BitmapBrushProperties(extendMode, 
37412: 						   extendMode,
37412: 						   D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
37412: 	} else {
37412: 	    bitProps = D2D1::BitmapBrushProperties(extendMode,
37412: 						   extendMode,
37412: 						   D2D1_BITMAP_INTERPOLATION_MODE_LINEAR);
37412: 	}
37412: 	if (unique) {
37412: 	    ID2D1BitmapBrush *bitBrush;
37412: 	    D2D1_BRUSH_PROPERTIES brushProps =
37412: 		D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&mat));
37412: 	    d2dsurf->rt->CreateBitmapBrush(sourceBitmap, 
37412: 					   &bitProps,
37412: 					   &brushProps,
37412: 					   &bitBrush);
37412: 	    return bitBrush;
37412: 	} else {
37412: 	    D2D1_MATRIX_3X2_F matrix = _cairo_d2d_matrix_from_matrix(&mat);
37412: 
37412: 	    if (d2dsurf->bitmapBrush) {
37412: 		d2dsurf->bitmapBrush->SetTransform(matrix);
37412: 
37412: 		if (surfacePattern->base.filter == CAIRO_FILTER_NEAREST) {
37412: 		    d2dsurf->bitmapBrush->SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR);
37412: 		} else {
37412: 		    d2dsurf->bitmapBrush->SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE_LINEAR);
37412: 		}
37412: 
37412: 		d2dsurf->bitmapBrush->SetBitmap(sourceBitmap);
37412: 		d2dsurf->bitmapBrush->SetExtendModeX(extendMode);
37412: 		d2dsurf->bitmapBrush->SetExtendModeY(extendMode);
37412: 	    } else {
37412: 		D2D1_BRUSH_PROPERTIES brushProps =
37412: 		    D2D1::BrushProperties(1.0, _cairo_d2d_matrix_from_matrix(&mat));
37412: 		d2dsurf->rt->CreateBitmapBrush(sourceBitmap,
37412: 					       &bitProps,
37412: 					       &brushProps,
37412: 					       &d2dsurf->bitmapBrush);
37412: 	    }
37412: 	    d2dsurf->bitmapBrush->AddRef();
37412: 	    return d2dsurf->bitmapBrush;
37412: 	}
37412:     } else {
37412: 	return NULL;
37412:     }
37412: }
37412: 
37412: 
37412: /** Path Conversion */
37412: 
37412: /**
37412:  * Structure to use for the closure, containing all needed data.
37412:  */
37412: struct path_conversion {
37412:     /** Geometry sink that we need to write to */
37412:     ID2D1GeometrySink *sink;
37412:     /** 
37412:      * If this figure is active, cairo doesn't always send us a close. But
37412:      * we do need to end this figure if it didn't.
37412:      */
37412:     bool figureActive;
37412:     /**
37412:      * Current point, D2D has no explicit move so we need to track moved for
37412:      * the next begin.
37412:      */
37412:     cairo_point_t current_point;
37412:     /** The type of figure begin for this geometry instance */
37412:     D2D1_FIGURE_BEGIN type;
37412: };
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_path_move_to(void		 *closure,
37412: 			const cairo_point_t *point)
37412: {
37412:     path_conversion *pathConvert =
37412: 	static_cast<path_conversion*>(closure);
37412:     if (pathConvert->figureActive) {
37412: 	pathConvert->sink->EndFigure(D2D1_FIGURE_END_OPEN);
37412: 	pathConvert->figureActive = false;
37412:     }
37412: 
37412:     pathConvert->current_point = *point;
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_path_line_to(void		    *closure,
37412: 			const cairo_point_t *point)
37412: {
37412:     path_conversion *pathConvert =
37412: 	static_cast<path_conversion*>(closure);
37412:     if (!pathConvert->figureActive) {
37412: 	pathConvert->sink->BeginFigure(_d2d_point_from_cairo_point(&pathConvert->current_point),
37412: 				       pathConvert->type);
37412: 	pathConvert->figureActive = true;
37412:     }
37412: 
37412:     D2D1_POINT_2F d2dpoint = _d2d_point_from_cairo_point(point);
37412: 
37412:     pathConvert->sink->AddLine(d2dpoint);
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_path_curve_to(void	  *closure,
37412: 			 const cairo_point_t *p0,
37412: 			 const cairo_point_t *p1,
37412: 			 const cairo_point_t *p2)
37412: {
37412:     path_conversion *pathConvert =
37412: 	static_cast<path_conversion*>(closure);
37412:     if (!pathConvert->figureActive) {
37412: 	pathConvert->sink->BeginFigure(_d2d_point_from_cairo_point(&pathConvert->current_point),
37412: 				       D2D1_FIGURE_BEGIN_FILLED);
37412: 	pathConvert->figureActive = true;
37412:     }
37412: 
37412:     pathConvert->sink->AddBezier(D2D1::BezierSegment(_d2d_point_from_cairo_point(p0),
37412: 						     _d2d_point_from_cairo_point(p1),
37412: 						     _d2d_point_from_cairo_point(p2)));
37412: 	
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_path_close(void *closure)
37412: {
37412:     path_conversion *pathConvert =
37412: 	static_cast<path_conversion*>(closure);
37412: 
37412:     pathConvert->sink->EndFigure(D2D1_FIGURE_END_CLOSED);
37412:     pathConvert->figureActive = false;
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: /**
37412:  * Create an ID2D1PathGeometry for a cairo_path_fixed_t
37412:  *
37412:  * \param path Path to create a geometry for
37412:  * \param fill_rule Fill rule to use
37412:  * \param type Figure begin type to use
37412:  * \return A D2D geometry
37412:  */
37412: static ID2D1PathGeometry*
37412: _cairo_d2d_create_path_geometry_for_path(cairo_path_fixed_t *path, 
37412: 					 cairo_fill_rule_t fill_rule,
37412: 					 D2D1_FIGURE_BEGIN type)
37412: {
37412:     ID2D1PathGeometry *d2dpath;
37412:     D2DSurfFactory::Instance()->CreatePathGeometry(&d2dpath);
37412:     ID2D1GeometrySink *sink;
37412:     d2dpath->Open(&sink);
37412:     D2D1_FILL_MODE fillMode = D2D1_FILL_MODE_WINDING;
37412:     if (fill_rule == CAIRO_FILL_RULE_WINDING) {
37412: 	fillMode = D2D1_FILL_MODE_WINDING;
37412:     } else if (fill_rule == CAIRO_FILL_RULE_EVEN_ODD) {
37412: 	fillMode = D2D1_FILL_MODE_ALTERNATE;
37412:     }
37412:     sink->SetFillMode(fillMode);
37412: 
37412:     path_conversion pathConvert;
37412:     pathConvert.type = type;
37412:     pathConvert.sink = sink;
37412:     pathConvert.figureActive = false;
37412:     _cairo_path_fixed_interpret(path,
37412: 				CAIRO_DIRECTION_FORWARD,
37412: 				_cairo_d2d_path_move_to,
37412: 				_cairo_d2d_path_line_to,
37412: 				_cairo_d2d_path_curve_to,
37412: 				_cairo_d2d_path_close,
37412: 				&pathConvert);
37412:     if (pathConvert.figureActive) {
37412: 	sink->EndFigure(D2D1_FIGURE_END_OPEN);
37412:     }
37412:     sink->Close();
37412:     sink->Release();
37412:     return d2dpath;
37412: }
37412: 
38944: /**
38944:  * We use this to clear out a certain geometry on a surface. This will respect
38944:  * the existing clip.
38944:  *
38944:  * \param d2dsurf Surface we clear
38944:  * \param geometry Geometry of the area to clear
38944:  */
38944: static void _cairo_d2d_clear_geometry(cairo_d2d_surface_t *d2dsurf,
38944: 				      ID2D1Geometry *geometry)
38944: {
38944:     if (!d2dsurf->helperLayer) {
38944: 	d2dsurf->rt->CreateLayer(&d2dsurf->helperLayer);
38944:     }
38944: 
38944:     d2dsurf->rt->PushLayer(D2D1::LayerParameters(D2D1::InfiniteRect(),
38944: 						 geometry),
38944: 			   d2dsurf->helperLayer);
38944:     d2dsurf->rt->Clear(D2D1::ColorF(0, 0));
38944:     d2dsurf->rt->PopLayer();
38944: }
38944: 
38945: static cairo_operator_t _cairo_d2d_simplify_operator(cairo_operator_t op,
38945: 						     const cairo_pattern_t *source)
38945: {
38945:     if (op == CAIRO_OPERATOR_SOURCE) {
38945: 	/** Operator over is easier for D2D! If the source if opaque, change */
38945: 	if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {
38945: 	    const cairo_surface_pattern_t *surfpattern =
38945: 		reinterpret_cast<const cairo_surface_pattern_t*>(source);
38945: 	    if (surfpattern->surface->content == CAIRO_CONTENT_COLOR) {
38945: 		return CAIRO_OPERATOR_OVER;
38945: 	    }
38945: 	} else if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
38945: 	    const cairo_solid_pattern_t *solidpattern =
38945: 		reinterpret_cast<const cairo_solid_pattern_t*>(source);
38945: 	    if (solidpattern->color.alpha == 1.0) {
38945: 		return CAIRO_OPERATOR_OVER;
38945: 	    }
38945: 	}
38945:     }
38945:     return op;
38945: }
38945: 
37412: // Implementation
37412: static cairo_surface_t*
37412: _cairo_d2d_create_similar(void			*surface,
37412: 			  cairo_content_t	 content,
37412: 			  int			 width,
37412: 			  int			 height)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
37412:     
37412:     memset(newSurf, 0, sizeof(cairo_d2d_surface_t));
37412: 
37412:     _cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, content);
37412: 
37412:     D2D1_SIZE_U sizePixels;
37412:     D2D1_SIZE_F size;
37412:     HRESULT hr;
37412: 
37412:     sizePixels.width = width;
37412:     sizePixels.height = height;
37412:     FLOAT dpiX;
37412:     FLOAT dpiY;
37412: 
37412:     d2dsurf->rt->GetDpi(&dpiX, &dpiY);
37412: 
37412:     D2D1_ALPHA_MODE alpha;
37412: 
37412:     if (content == CAIRO_CONTENT_COLOR) {
37412: 	alpha = D2D1_ALPHA_MODE_IGNORE;
37412:     } else {
37412: 	alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
37412:     }
37412: 
37412:     size.width = sizePixels.width * dpiX;
37412:     size.height = sizePixels.height * dpiY;
37412:     D2D1_BITMAP_PROPERTIES bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
37412: 									       alpha));
37412:     D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
37412: 								       D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN,
37412: 											 alpha),
37412: 								       dpiX,
37412: 								       dpiY);
37412: 
37412:     if (sizePixels.width < 1) {
37412: 	sizePixels.width = 1;
37412:     }
37412:     if (sizePixels.height < 1) {
37412: 	sizePixels.height = 1;
37412:     }
37412:     IDXGISurface *oldDxgiSurface;
37412:     d2dsurf->surface->QueryInterface(&oldDxgiSurface);
37412:     DXGI_SURFACE_DESC origDesc;
37412: 
37412:     oldDxgiSurface->GetDesc(&origDesc);
37412:     oldDxgiSurface->Release();
37412: 
37412:     CD3D10_TEXTURE2D_DESC desc(origDesc.Format,
37412: 			       sizePixels.width,
37412: 			       sizePixels.height);
37412: 
37412:     if (content == CAIRO_CONTENT_ALPHA) {
37412: 	desc.Format = DXGI_FORMAT_A8_UNORM;
37412:     }
37412: 
37412:     desc.MipLevels = 1;
37412:     desc.Usage = D3D10_USAGE_DEFAULT;
37412:     desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
37412:     ID3D10Texture2D *texture;
37412: 
37412:     hr = D3D10Factory::Device()->CreateTexture2D(&desc, NULL, &texture);
37412:     if (FAILED(hr)) {
37412: 	goto FAIL_D3DTEXTURE;
37412:     }
37412: 
37412:     newSurf->surface = texture;
37412: 
37412:     // Create the DXGI surface.
37412:     IDXGISurface *dxgiSurface;
37412:     hr = newSurf->surface->QueryInterface(IID_IDXGISurface, (void**)&dxgiSurface);
37412:     if (FAILED(hr)) {
37412: 	goto FAIL_DXGISURFACE;
37412:     }
37412:     hr = D2DSurfFactory::Instance()->CreateDxgiSurfaceRenderTarget(dxgiSurface,
37412: 								   props,
37412: 								   &newSurf->rt);
37412: 
37412:     if (FAILED(hr)) {
37412: 	goto FAIL_DXGIRT;
37412:     }
37412: 
37412:     hr = newSurf->rt->CreateSharedBitmap(IID_IDXGISurface,
37412: 					 dxgiSurface,
37412: 					 &bitProps,
37412: 					 &newSurf->surfaceBitmap);
37412:     if (FAILED(hr)) {
37412: 	goto FAIL_SHAREDBITMAP;
37412:     }
37412: 
37412:     dxgiSurface->Release();
37412: 
37412:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
37412: 
37412:     return reinterpret_cast<cairo_surface_t*>(newSurf);
37412: 
37412: FAIL_SHAREDBITMAP:
37412:     newSurf->rt->Release();
37412: FAIL_DXGIRT:
37412:     dxgiSurface->Release();
37412: FAIL_DXGISURFACE:
37412:     newSurf->surface->Release();
37412: FAIL_D3DTEXTURE:
37412:     free(newSurf);
37412:     return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_finish(void	    *surface)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     if (d2dsurf->rt) {
37412: 	d2dsurf->rt->Release();
37412:     }
37412:     if (d2dsurf->surfaceBitmap) {
37412: 	d2dsurf->surfaceBitmap->Release();
37412:     }
37412:     if (d2dsurf->backBuf) {
37412: 	d2dsurf->backBuf->Release();
37412:     }
37412:     if (d2dsurf->dxgiChain) {
37412: 	d2dsurf->dxgiChain->Release();
37412:     }
37412:     if (d2dsurf->clipMask) {
37412: 	d2dsurf->clipMask->Release();
37412:     }
37412:     if (d2dsurf->clipRect) {
37412: 	delete d2dsurf->clipRect;
37412:     }
37412:     if (d2dsurf->clipLayer) {
37412: 	d2dsurf->clipLayer->Release();
37412:     }
37412:     if (d2dsurf->maskLayer) {
37412: 	d2dsurf->maskLayer->Release();
37412:     }
37412:     if (d2dsurf->solidColorBrush) {
37412: 	d2dsurf->solidColorBrush->Release();
37412:     }
37412:     if (d2dsurf->bitmapBrush) {
37412: 	d2dsurf->bitmapBrush->Release();
37412:     }
37412:     if (d2dsurf->surface) {
37412: 	d2dsurf->surface->Release();
37412:     }
38944:     if (d2dsurf->helperLayer) {
38944: 	d2dsurf->helperLayer->Release();
37412:     }
37412:     if (d2dsurf->bufferTexture) {
37412: 	d2dsurf->bufferTexture->Release();
37412:     }
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_acquire_source_image(void                    *abstract_surface,
37412: 				cairo_image_surface_t  **image_out,
37412: 				void                   **image_extra)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
37412:     _cairo_d2d_flush(d2dsurf);
37412: 
37412:     HRESULT hr;
37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
37412: 
37412:     ID3D10Texture2D *softTexture;
37412: 
37412:     IDXGISurface *dxgiSurface;
37412:     d2dsurf->surface->QueryInterface(&dxgiSurface);
37412:     DXGI_SURFACE_DESC desc;
37412: 
37412:     dxgiSurface->GetDesc(&desc);
37412:     dxgiSurface->Release();
37412: 
37412:     CD3D10_TEXTURE2D_DESC softDesc(desc.Format, desc.Width, desc.Height);
37412: 
37412:     /**
37412:      * We can't actually map our backing store texture, so we create one in CPU memory, and then
37412:      * tell D3D to copy the data from our surface there, readback is expensive, we -never-
37412:      * -ever- want this to happen.
37412:      */
37412:     softDesc.MipLevels = 1;
37412:     softDesc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE | D3D10_CPU_ACCESS_READ;
37412:     softDesc.Usage = D3D10_USAGE_STAGING;
37412:     softDesc.BindFlags = 0;
37412:     hr = D3D10Factory::Device()->CreateTexture2D(&softDesc, NULL, &softTexture);
37412:     if (FAILED(hr)) {
37412: 	return CAIRO_STATUS_NO_MEMORY;
37412:     }
37412: 
37412:     D3D10Factory::Device()->CopyResource(softTexture, d2dsurf->surface);
37412: 
37412:     D3D10_MAPPED_TEXTURE2D data;
37412:     hr = softTexture->Map(0, D3D10_MAP_READ_WRITE, 0, &data);
37412:     if (FAILED(hr)) {
37412: 	d2dsurf->surface->Release();
37412: 	d2dsurf->surface = NULL;
37412: 	return (cairo_status_t)CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     *image_out = 
37412: 	(cairo_image_surface_t*)_cairo_image_surface_create_for_data_with_content((unsigned char*)data.pData,
37412: 										  CAIRO_CONTENT_COLOR_ALPHA,
37412: 										  size.width,
37412: 										  size.height,
37412: 										  data.RowPitch);
37412:     *image_extra = softTexture;
37412: 
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static void
37412: _cairo_d2d_release_source_image(void                   *abstract_surface,
37412: 				cairo_image_surface_t  *image,
37412: 				void                   *image_extra)
37412: {
37412:     if (((cairo_surface_t*)abstract_surface)->type != CAIRO_SURFACE_TYPE_D2D) {
37412: 	return;
37412:     }
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
37412: 
37412:     if (!d2dsurf->surface) {
37412: 	return;
37412:     }
37412:     ID3D10Texture2D *softTexture = (ID3D10Texture2D*)image_extra;
37412:     
37412:     softTexture->Unmap(0);
37412:     softTexture->Release();
37412:     softTexture = NULL;
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_acquire_dest_image(void                    *abstract_surface,
37412: 			      cairo_rectangle_int_t   *interest_rect,
37412: 			      cairo_image_surface_t  **image_out,
37412: 			      cairo_rectangle_int_t   *image_rect,
37412: 			      void                   **image_extra)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
37412:     _cairo_d2d_flush(d2dsurf);
37412: 
37412:     HRESULT hr;
37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
37412: 
37412:     ID3D10Texture2D *softTexture;
37412: 
37412: 
37412:     IDXGISurface *dxgiSurface;
37412:     d2dsurf->surface->QueryInterface(&dxgiSurface);
37412:     DXGI_SURFACE_DESC desc;
37412: 
37412:     dxgiSurface->GetDesc(&desc);
37412:     dxgiSurface->Release();
37412: 
37412:     CD3D10_TEXTURE2D_DESC softDesc(desc.Format, desc.Width, desc.Height);
37412: 
37412:     softDesc.MipLevels = 1;
37412:     softDesc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE | D3D10_CPU_ACCESS_READ;
37412:     softDesc.Usage = D3D10_USAGE_STAGING;
37412:     softDesc.BindFlags = 0;
37412:     hr = D3D10Factory::Device()->CreateTexture2D(&softDesc, NULL, &softTexture);
37412:     if (FAILED(hr)) {
37412: 	return CAIRO_STATUS_NO_MEMORY;
37412:     }
37412:     D3D10Factory::Device()->CopyResource(softTexture, d2dsurf->surface);
37412: 
37412:     D3D10_MAPPED_TEXTURE2D data;
37412:     hr = softTexture->Map(0, D3D10_MAP_READ_WRITE, 0, &data);
37412:     if (FAILED(hr)) {
37412: 	d2dsurf->surface->Release();
37412: 	d2dsurf->surface = NULL;
37412: 	return (cairo_status_t)CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     *image_out = 
37412: 	(cairo_image_surface_t*)_cairo_image_surface_create_for_data_with_content((unsigned char*)data.pData,
37412: 										  CAIRO_CONTENT_COLOR_ALPHA,
37412: 										  size.width,
37412: 										  size.height,
37412: 										  data.RowPitch);
37412:     *image_extra = softTexture;
37412: 
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static void
37412: _cairo_d2d_release_dest_image(void                    *abstract_surface,
37412: 			      cairo_rectangle_int_t   *interest_rect,
37412: 			      cairo_image_surface_t   *image,
37412: 			      cairo_rectangle_int_t   *image_rect,
37412: 			      void                    *image_extra)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(abstract_surface);
37412: 
37412:     ID3D10Texture2D *softTexture = (ID3D10Texture2D*)image_extra;
37412:     D2D1_POINT_2U point;
37412:     point.x = 0;
37412:     point.y = 0;
37412:     D2D1_RECT_U rect;
37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize();
37412:     rect.left = rect.top = 0;
37412:     rect.right = size.width;
37412:     rect.bottom = size.height;
37412:     softTexture->Unmap(0);
37412:     D3D10Factory::Device()->CopyResource(d2dsurf->surface, softTexture);
37412:     softTexture->Release();
37412: }
37412: 
37412: cairo_int_status_t
37412: _cairo_d2d_intersect_clip_path(void			*dst,
37412: 			       cairo_path_fixed_t	*path,
37412: 			       cairo_fill_rule_t	fill_rule,
37412: 			       double			tolerance,
37412: 			       cairo_antialias_t	antialias)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(dst);
37412: 
37412:     _cairo_d2d_surface_pop_clip(d2dsurf);
37412:     if (!path) {
37412: 	if (d2dsurf->clipMask) {
37412: 	    d2dsurf->clipMask->Release();
37412: 	    d2dsurf->clipMask = NULL;
37412: 	}
37412: 	if (d2dsurf->clipRect) {
37412: 	    delete d2dsurf->clipRect;
37412: 	    d2dsurf->clipRect = NULL;
37412: 	}
37412: 	return CAIRO_INT_STATUS_SUCCESS;
37412:     }
37412:     cairo_box_t box;
37412: 
37412:     if (_cairo_path_fixed_is_box(path, &box) && box.p1.y < box.p2.y) {
37412: 	/** 
37412: 	 * Nice axis aligned rectangular clip, try and do our best to keep it
37412: 	 * that way.
37412: 	 */
37412: 	if (!d2dsurf->clipRect && !d2dsurf->clipMask) {
37412: 	    /** Nothing yet, just use this clip rect */
37412: 	    d2dsurf->clipRect = new D2D1_RECT_F(D2D1::RectF(_cairo_fixed_to_float(box.p1.x),
37412: 							    _cairo_fixed_to_float(box.p1.y),
37412: 							    _cairo_fixed_to_float(box.p2.x),
37412: 							    _cairo_fixed_to_float(box.p2.y)));
37412: 	    return CAIRO_INT_STATUS_SUCCESS;
37412: 	} else if (!d2dsurf->clipMask) {
37412: 	    /** We have a clip rect, intersect of two rects is simple */
37412: 	    d2dsurf->clipRect->top = max(_cairo_fixed_to_float(box.p1.y), d2dsurf->clipRect->top);
37412: 	    d2dsurf->clipRect->left = max(d2dsurf->clipRect->left, _cairo_fixed_to_float(box.p1.x));
37412: 	    d2dsurf->clipRect->bottom = min(d2dsurf->clipRect->bottom, _cairo_fixed_to_float(box.p2.y));
37412: 	    d2dsurf->clipRect->right = min(d2dsurf->clipRect->right, _cairo_fixed_to_float(box.p2.x));
37412: 	    if (d2dsurf->clipRect->top > d2dsurf->clipRect->bottom) {
37412: 		d2dsurf->clipRect->top = d2dsurf->clipRect->bottom;
37412: 	    }
37412: 	    if (d2dsurf->clipRect->left > d2dsurf->clipRect->right) {
37412: 		d2dsurf->clipRect->left = d2dsurf->clipRect->right;
37412: 	    }
37412: 	    return CAIRO_INT_STATUS_SUCCESS;
37412: 	} else {
37412: 	    /** 
37412: 	     * We have a mask, see if this rect is completely contained by it, so we
37412: 	     * can optimize by just using this rect rather than a geometry mask.
37412: 	     */
37412: 	    ID2D1RectangleGeometry *newMask;
37412: 	    D2DSurfFactory::Instance()->CreateRectangleGeometry(D2D1::RectF(_cairo_fixed_to_float(box.p1.x),
37412: 									    _cairo_fixed_to_float(box.p1.y),
37412: 									    _cairo_fixed_to_float(box.p2.x),
37412: 									    _cairo_fixed_to_float(box.p2.y)), 
37412: 								&newMask);
37412: 	    D2D1_GEOMETRY_RELATION relation;
37412: 	    d2dsurf->clipMask->CompareWithGeometry(newMask, D2D1::Matrix3x2F::Identity(), &relation);
37412: 	    if (relation == D2D1_GEOMETRY_RELATION_CONTAINS) {
37412: 	        d2dsurf->clipMask->Release();
37412: 		d2dsurf->clipMask = NULL;
37412: 	        newMask->Release();
37412: 	        d2dsurf->clipRect = new D2D1_RECT_F(D2D1::RectF(_cairo_fixed_to_float(box.p1.x),
37412: 								_cairo_fixed_to_float(box.p1.y),
37412: 								_cairo_fixed_to_float(box.p2.x),
37412: 								_cairo_fixed_to_float(box.p2.y)));
37412: 		return CAIRO_INT_STATUS_SUCCESS;		    
37412: 		
37412: 	    }
37412: 	    newMask->Release();
37412: 	}
37412:     }
37412:     
37412:     if (!d2dsurf->clipRect && !d2dsurf->clipMask) {
37412: 	/** Nothing yet, just use this clip path */
37412: 	d2dsurf->clipMask = _cairo_d2d_create_path_geometry_for_path(path, fill_rule, D2D1_FIGURE_BEGIN_FILLED);
37412:     } else if (d2dsurf->clipMask) {
37412: 	/** We already have a clip mask, combine the two into a new clip mask */
37412: 	ID2D1Geometry *newMask = _cairo_d2d_create_path_geometry_for_path(path, fill_rule, D2D1_FIGURE_BEGIN_FILLED);
37412: 	ID2D1PathGeometry *finalMask;
37412: 	D2DSurfFactory::Instance()->CreatePathGeometry(&finalMask);
37412: 	ID2D1GeometrySink *sink;
37412: 	finalMask->Open(&sink);
37412: 	newMask->CombineWithGeometry(d2dsurf->clipMask,
37412: 				     D2D1_COMBINE_MODE_INTERSECT,
37412: 				     D2D1::Matrix3x2F::Identity(),
37412: 				     sink);
37412: 	sink->Close();
37412: 	sink->Release();
37412: 	d2dsurf->clipMask->Release();
37412: 	newMask->Release();
37412: 	d2dsurf->clipMask = finalMask;
37412:     } else if (d2dsurf->clipRect) {
37412: 	/** 
37412: 	 * We have a clip rect, if we contain it, we can keep using that, if
37412: 	 * it contains the new path, use the new path, otherwise, go into a
37412: 	 * potentially expensive combine.
37412: 	 */
37412: 	ID2D1RectangleGeometry *currentMask;
37412: 	D2DSurfFactory::Instance()->CreateRectangleGeometry(d2dsurf->clipRect, &currentMask);
37412: 	ID2D1Geometry *newMask = _cairo_d2d_create_path_geometry_for_path(path, fill_rule, D2D1_FIGURE_BEGIN_FILLED);
37412:         D2D1_GEOMETRY_RELATION relation;
37412: 	newMask->CompareWithGeometry(currentMask, D2D1::Matrix3x2F::Identity(), &relation);
37412: 	if (relation == D2D1_GEOMETRY_RELATION_CONTAINS) {
37412: 	    currentMask->Release();
37412: 	    newMask->Release();
37412: 	    return CAIRO_INT_STATUS_SUCCESS;
37412: 	} else if (relation == D2D1_GEOMETRY_RELATION_IS_CONTAINED) {
37412: 	    currentMask->Release();
37412: 	    d2dsurf->clipMask = newMask;
37412: 	} else {
37412: 	    ID2D1PathGeometry *finalMask;
37412: 	    D2DSurfFactory::Instance()->CreatePathGeometry(&finalMask);
37412: 	    ID2D1GeometrySink *sink;
37412: 	    finalMask->Open(&sink);
37412: 	    newMask->CombineWithGeometry(currentMask,
37412: 					 D2D1_COMBINE_MODE_INTERSECT,
37412: 					 D2D1::Matrix3x2F::Identity(),
37412: 					 sink);
37412: 	    sink->Close();
37412: 	    sink->Release();
37412: 	    currentMask->Release();
37412: 	    newMask->Release();
37412: 	    d2dsurf->clipMask = finalMask;
37412: 	}
37412:     }
37412: 
37412:     if (d2dsurf->clipRect) {
37412: 	delete d2dsurf->clipRect;
37412: 	d2dsurf->clipRect = NULL;
37412:     }
37412:   
37412:     return CAIRO_INT_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_status_t
37412: _cairo_d2d_flush(void                  *surface)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412: 
37412:     if (d2dsurf->isDrawing) {
37412: 	_cairo_d2d_surface_pop_clip(d2dsurf);
37412: 	HRESULT hr = d2dsurf->rt->EndDraw();
37412: 	d2dsurf->isDrawing = false;
37412:     }
37412:     return CAIRO_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_int_status_t
37412: _cairo_d2d_paint(void			*surface,
37412: 		 cairo_operator_t	 op,
37412: 		 const cairo_pattern_t	*source,
37412: 		 cairo_rectangle_int_t  *extents)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     _begin_draw_state(d2dsurf);
38945: 
38945:     op = _cairo_d2d_simplify_operator(op, source);
38945: 
37412:     if (op == CAIRO_OPERATOR_CLEAR) {
38944: 	d2dsurf->rt->Clear(D2D1::ColorF(0, 0));
37412: 	return CAIRO_INT_STATUS_SUCCESS;
37412:     }
37412: 
37412:     d2dsurf->rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
37412: 
37412:     unsigned int runs_remaining = 1;
37412:     unsigned int last_run = 0;
37412:     bool pushed_clip = false;
37412: 
37412:     while (runs_remaining) {
37412: 	ID2D1Brush *brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
37412: 								source,
37412: 								last_run++,
37412: 								&runs_remaining,
37412: 								&pushed_clip);
37412: 
37412: 	if (!brush) {
37412: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
37412: 	}
37412: 	if (op == CAIRO_OPERATOR_OVER && extents) {
37412: 	    d2dsurf->rt->FillRectangle(D2D1::RectF((FLOAT)extents->x,
37412: 						   (FLOAT)extents->y,
37412: 						   (FLOAT)extents->x + extents->width,
37412: 						   (FLOAT)extents->y + extents->height),
37412: 				       brush);
37412: 	} else if (op == CAIRO_OPERATOR_OVER) {
37412: 	    D2D1_SIZE_F size = d2dsurf->rt->GetSize();
37412: 	    d2dsurf->rt->FillRectangle(D2D1::RectF((FLOAT)0,
37412: 						   (FLOAT)0,
37412: 						   (FLOAT)size.width,
37412: 						   (FLOAT)size.height),
37412: 				       brush);
37412:         } else if (op == CAIRO_OPERATOR_SOURCE && !extents) {
37412: 	    D2D1_SIZE_F size = d2dsurf->rt->GetSize();
37412:             d2dsurf->rt->Clear(D2D1::ColorF(0, 0));
37412:             d2dsurf->rt->FillRectangle(D2D1::RectF((FLOAT)0,
37412: 						   (FLOAT)0,
37412: 						   (FLOAT)size.width,
37412: 						   (FLOAT)size.height),
37412: 				       brush);
37412:         } else {
37412: 	    brush->Release();
37412: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
37412: 	}
37412: 	brush->Release();
37412: 
37412: 	if (pushed_clip) {
37412: 	    d2dsurf->rt->PopLayer();
37412: 	}
37412:     }
37412:     return CAIRO_INT_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_int_status_t
37412: _cairo_d2d_mask(void			*surface,
37412: 		cairo_operator_t	 op,
37412: 		const cairo_pattern_t	*source,
37412: 		const cairo_pattern_t	*mask,
37412: 		cairo_rectangle_int_t	*extents)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     _begin_draw_state(d2dsurf);
37412: 
37412:     unsigned int runs_remaining = 0;
37412:     bool pushed_clip;
37412: 
37412:     ID2D1Brush *brush = _cairo_d2d_create_brush_for_pattern(d2dsurf, source, 0, &runs_remaining, &pushed_clip);
37412:     if (!brush) {
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     if (runs_remaining) {
37412: 	brush->Release();
37412: 	// TODO: Implement me!!
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     D2D1_RECT_F rect = D2D1::RectF(0,
37412: 				   0,
37412: 				   (FLOAT)d2dsurf->rt->GetPixelSize().width,
37412: 				   (FLOAT)d2dsurf->rt->GetPixelSize().height);
37412:     if (extents) {
37412: 	rect.left = (FLOAT)extents->x;
37412: 	rect.right = (FLOAT)(extents->x + extents->width);
37412: 	rect.top = (FLOAT)extents->y;
37412: 	rect.bottom = (FLOAT)(extents->y + extents->height);
37412:     }
37412: 
37412:     if (mask->type == CAIRO_PATTERN_TYPE_SOLID) {
37412: 	cairo_solid_pattern_t *solidPattern =
37412: 	    (cairo_solid_pattern_t*)mask;
37412: 	if (solidPattern->content = CAIRO_CONTENT_ALPHA) {
37412: 	    brush->SetOpacity((FLOAT)solidPattern->color.alpha);
37412: 	    d2dsurf->rt->FillRectangle(rect,
37412: 				       brush);
37412: 	    brush->SetOpacity(1.0);
37412: 	    brush->Release();
37412: 	    return CAIRO_INT_STATUS_SUCCESS;
37412: 	}
37412:     }
37412:     ID2D1Brush *opacityBrush = _cairo_d2d_create_brush_for_pattern(d2dsurf, mask, 0, &runs_remaining, &pushed_clip, true);
37412:     if (!opacityBrush) {
37412: 	brush->Release();
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     if (runs_remaining) {
37412: 	brush->Release();
37412: 	opacityBrush->Release();
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     if (!d2dsurf->maskLayer) {
37412: 	d2dsurf->rt->CreateLayer(&d2dsurf->maskLayer);
37412:     }
37412:     d2dsurf->rt->PushLayer(D2D1::LayerParameters(D2D1::InfiniteRect(),
37412: 						 0,
37412: 						 D2D1_ANTIALIAS_MODE_ALIASED,
37412: 						 D2D1::IdentityMatrix(),
37412: 						 1.0,
37412: 						 opacityBrush),
37412: 			   d2dsurf->maskLayer);
37412: 
37412:     d2dsurf->rt->FillRectangle(rect,
37412: 			       brush);
37412:     d2dsurf->rt->PopLayer();
37412:     brush->Release();
37412:     opacityBrush->Release();
37412:     return CAIRO_INT_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_int_status_t
37412: _cairo_d2d_stroke(void			*surface,
37412: 		  cairo_operator_t	 op,
37412: 		  const cairo_pattern_t	*source,
37412: 		  cairo_path_fixed_t	*path,
37412: 		  cairo_stroke_style_t	*style,
37412: 		  cairo_matrix_t	*ctm,
37412: 		  cairo_matrix_t	*ctm_inverse,
37412: 		  double		 tolerance,
37412: 		  cairo_antialias_t	 antialias,
37412: 		  cairo_rectangle_int_t  *extents)
37412: {
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     _begin_draw_state(d2dsurf);
38944: 
38945:     op = _cairo_d2d_simplify_operator(op, source);
38945: 
38944:     if (op != CAIRO_OPERATOR_OVER && op != CAIRO_OPERATOR_ADD &&
38944: 	op != CAIRO_OPERATOR_CLEAR) {
37412: 	/** 
38944: 	 * We don't really support ADD yet. True ADD support requires getting
38944: 	 * the tesselated mesh from D2D, and blending that using D3D which has
38944: 	 * an add operator available.
37412: 	 */
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412: 
37412:     if (antialias == CAIRO_ANTIALIAS_NONE) {
37412: 	d2dsurf->rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
37412:     } else {
37412: 	d2dsurf->rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
37412:     }
37412:     ID2D1StrokeStyle *strokeStyle = _cairo_d2d_create_strokestyle_for_stroke_style(style);
37412: 
37412:     if (!strokeStyle) {
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     D2D1::Matrix3x2F mat = _cairo_d2d_matrix_from_matrix(ctm);
37412: 
37412:     _cairo_path_fixed_transform(path, ctm_inverse);
38944: 
38944:     if (op == CAIRO_OPERATOR_CLEAR) {
38944: 	ID2D1Geometry *d2dpath = _cairo_d2d_create_path_geometry_for_path(path,
38944: 									  CAIRO_FILL_RULE_WINDING,
38944: 									  D2D1_FIGURE_BEGIN_FILLED);
38944: 
38944:         ID2D1PathGeometry *strokeGeometry;
38944: 	D2DSurfFactory::Instance()->CreatePathGeometry(&strokeGeometry);
38944: 
38944: 	ID2D1GeometrySink *sink;
38944: 	strokeGeometry->Open(&sink);
38944: 	d2dpath->Widen((FLOAT)style->line_width, strokeStyle, mat, (FLOAT)tolerance, sink);
38944: 	sink->Close();
38944: 	sink->Release();
38944: 
38944: 	_cairo_d2d_clear_geometry(d2dsurf, strokeGeometry);
38944: 
38944: 	strokeGeometry->Release();
38944: 	d2dpath->Release();
38944: 
38944:         return CAIRO_INT_STATUS_SUCCESS;
38944:     }
38944: 
37412:     d2dsurf->rt->SetTransform(mat);
37412: 
37412:     unsigned int runs_remaining = 1;
37412:     unsigned int last_run = 0;
37412:     bool pushed_clip = false;
37412:     cairo_box_t box;
37412: 
37412:     if (_cairo_path_fixed_is_box(path, &box)) {
37412: 	float x1 = _cairo_fixed_to_float(box.p1.x);    
37412: 	float y1 = _cairo_fixed_to_float(box.p1.y);    
37412: 	float x2 = _cairo_fixed_to_float(box.p2.x);    
37412: 	float y2 = _cairo_fixed_to_float(box.p2.y);
37412: 	while (runs_remaining) {
37412: 	    ID2D1Brush *brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
37412: 								    source,
37412: 								    last_run++,
37412: 								    &runs_remaining,
37412: 								    &pushed_clip);
37412: 
37412: 	    if (!brush) {
37412: 		strokeStyle->Release();
37412: 		return CAIRO_INT_STATUS_UNSUPPORTED;
37412: 	    }
37412: 	    d2dsurf->rt->DrawRectangle(D2D1::RectF(x1,
37412: 						   y1,
37412: 						   x2,
37412: 						   y2),
37412: 				       brush,
37412: 				       (FLOAT)style->line_width,
37412: 				       strokeStyle);
37412: 
37412: 	    brush->Release();
37412: 	    if (pushed_clip) {
37412: 		d2dsurf->rt->PopLayer();
37412: 	    }
37412: 	}
37412:     } else {
37412: 	ID2D1Geometry *d2dpath = _cairo_d2d_create_path_geometry_for_path(path, 
37412: 									  CAIRO_FILL_RULE_WINDING, 
37412: 									  D2D1_FIGURE_BEGIN_HOLLOW);
37412: 	while (runs_remaining) {
37412: 	    ID2D1Brush *brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
37412: 								    source,
37412: 								    last_run++,
37412: 								    &runs_remaining,
37412: 								    &pushed_clip);
37412: 
37412: 	    if (!brush) {
37412: 		strokeStyle->Release();
38946: 		d2dpath->Release();
37412: 		return CAIRO_INT_STATUS_UNSUPPORTED;
37412: 	    }
37412: 	    d2dsurf->rt->DrawGeometry(d2dpath, brush, (FLOAT)style->line_width, strokeStyle);
37412: 
37412: 	    brush->Release();
37412: 	    if (pushed_clip) {
37412: 		d2dsurf->rt->PopLayer();
37412: 	    }
37412: 	}
37412: 	d2dpath->Release();
37412:     }
37412: 
37412:     _cairo_path_fixed_transform(path, ctm);
37412:     d2dsurf->rt->SetTransform(D2D1::Matrix3x2F::Identity());
37412:     strokeStyle->Release();
37412:     return CAIRO_INT_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_int_status_t
37412: _cairo_d2d_fill(void			*surface,
37412: 		cairo_operator_t	 op,
37412: 		const cairo_pattern_t	*source,
37412: 		cairo_path_fixed_t	*path,
37412: 		cairo_fill_rule_t	 fill_rule,
37412: 		double			 tolerance,
37412: 		cairo_antialias_t	 antialias,
37412: 		cairo_rectangle_int_t	*extents)
37412: {
37412:     if (((cairo_surface_t*)surface)->type != CAIRO_SURFACE_TYPE_D2D) {
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     _begin_draw_state(d2dsurf);
37412: 
38945:     op = _cairo_d2d_simplify_operator(op, source);
38945: 
38944:     if (op != CAIRO_OPERATOR_OVER && op != CAIRO_OPERATOR_ADD &&
38944: 	op != CAIRO_OPERATOR_CLEAR) {
37412: 	/** 
38944: 	 * We don't really support ADD yet. True ADD support requires getting
38944: 	 * the tesselated mesh from D2D, and blending that using D3D which has
38944: 	 * an add operator available.
37412: 	 */
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412: 
37412:     if (antialias == CAIRO_ANTIALIAS_NONE) {
37412: 	d2dsurf->rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_ALIASED);
37412:     } else {
37412: 	d2dsurf->rt->SetAntialiasMode(D2D1_ANTIALIAS_MODE_PER_PRIMITIVE);
37412:     }
37412: 
37412:     unsigned int runs_remaining = 1;
37412:     unsigned int last_run = 0;
37412:     bool pushed_clip = false;
37412: 
38944:     if (op == CAIRO_OPERATOR_CLEAR) {
38944: 	ID2D1Geometry *d2dpath = _cairo_d2d_create_path_geometry_for_path(path,
38944: 									  fill_rule,
38944: 									  D2D1_FIGURE_BEGIN_FILLED);
38944: 	_cairo_d2d_clear_geometry(d2dsurf, d2dpath);
38944: 	
38944: 	d2dpath->Release();
38944: 	return CAIRO_INT_STATUS_SUCCESS;
38944:     }
38944: 
37412:     cairo_box_t box;
37412:     if (_cairo_path_fixed_is_box(path, &box)) {
37412: 	float x1 = _cairo_fixed_to_float(box.p1.x);
37412: 	float y1 = _cairo_fixed_to_float(box.p1.y);    
37412: 	float x2 = _cairo_fixed_to_float(box.p2.x);    
37412: 	float y2 = _cairo_fixed_to_float(box.p2.y);
37412: 	while (runs_remaining) {
37412: 	    ID2D1Brush *brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
37412: 								    source,
37412: 								    last_run++,
37412: 								    &runs_remaining,
37412: 								    &pushed_clip);
37412: 	    if (!brush) {
37412: 		return CAIRO_INT_STATUS_UNSUPPORTED;
37412: 	    }
37412: 
37412: 	    d2dsurf->rt->FillRectangle(D2D1::RectF(x1,
37412: 						   y1,
37412: 						   x2,
37412: 						   y2),
37412: 				       brush);
37412: 	    if (pushed_clip) {
37412: 		d2dsurf->rt->PopLayer();
37412: 	    }
37412: 	    brush->Release();
37412: 	}
37412:     } else {
37412: 	ID2D1Geometry *d2dpath = _cairo_d2d_create_path_geometry_for_path(path, fill_rule, D2D1_FIGURE_BEGIN_FILLED);
37412: 	while (runs_remaining) {
37412: 	    ID2D1Brush *brush = _cairo_d2d_create_brush_for_pattern(d2dsurf,
37412: 								    source,
37412: 								    last_run++,
37412: 								    &runs_remaining,
37412: 								    &pushed_clip);
37412: 	    if (!brush) {
37412: 		d2dpath->Release();
37412: 		return CAIRO_INT_STATUS_UNSUPPORTED;
37412: 	    }
37412: 	    d2dsurf->rt->FillGeometry(d2dpath, brush);
37412: 	    brush->Release();
37412: 	    if (pushed_clip) {
37412: 		d2dsurf->rt->PopLayer();
37412: 	    }
37412: 	}
37412: 	d2dpath->Release();
37412:     }
37412:     return CAIRO_INT_STATUS_SUCCESS;
37412: }
37412: 
37412: static cairo_int_status_t
37412: _cairo_d2d_show_glyphs (void			*surface,
37412: 			cairo_operator_t	 op,
37412: 			const cairo_pattern_t	*source,
37412: 			cairo_glyph_t		*glyphs,
37412: 			int			 num_glyphs,
37412: 			cairo_scaled_font_t	*scaled_font,
37412: 			int			*remaining_glyphs,
37412: 			cairo_rectangle_int_t	*extents)
37412: {
37412:     if (((cairo_surface_t*)surface)->type != CAIRO_SURFACE_TYPE_D2D) {
37412: 	return CAIRO_INT_STATUS_UNSUPPORTED;
37412:     }
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     if (!d2dsurf->textRenderingInit) {
37412: 	IDWriteRenderingParams *params;
37412: 	DWriteFactory::Instance()->CreateRenderingParams(&params);
37412: 	d2dsurf->rt->SetTextRenderingParams(params);
37412: 	d2dsurf->textRenderingInit = true;
37412: 	params->Release();
37412:     }
37412:     _begin_draw_state(d2dsurf);
37412:     cairo_int_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
37412:     if (scaled_font->backend->type == CAIRO_FONT_TYPE_DWRITE) {
37412:         status = (cairo_int_status_t)
37412: 	    cairo_dwrite_show_glyphs_on_d2d_surface(surface, op, source, glyphs, num_glyphs, scaled_font, extents);
37412:     }
37412: 
37412:     return status;
37412: }
37412: 
37412: static cairo_int_status_t
37412: _cairo_d2d_getextents(void		       *surface,
37412: 		      cairo_rectangle_int_t    *extents)
37412: {
37412:     if (((cairo_surface_t*)surface)->type != CAIRO_SURFACE_TYPE_D2D) {
37412: 	return (cairo_int_status_t)CAIRO_STATUS_SURFACE_TYPE_MISMATCH;
37412:     }
37412:     cairo_d2d_surface_t *d2dsurf = static_cast<cairo_d2d_surface_t*>(surface);
37412:     extents->x = 0;
37412:     extents->y = 0;
37412:     D2D1_SIZE_U size = d2dsurf->rt->GetPixelSize(); 
37412:     extents->width = size.width;
37412:     extents->height = size.height;
37412:     return CAIRO_INT_STATUS_SUCCESS;
37412: }
37412: 
37412: 
37412: /** Helper functions. */
37412: 
37412: cairo_surface_t*
37412: cairo_d2d_surface_create_for_hwnd(HWND wnd)
37412: {
38825:     if (!D3D10Factory::Device() || !D2DSurfFactory::Instance()) {
38825: 	/**
38825: 	 * FIXME: In the near future we can use cairo_device_t to pass in a
38825: 	 * device.
38825: 	 */
38825: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_DEVICE));
38825:     }
38825: 
37412:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
37412: 
37412:     memset(newSurf, 0, sizeof(cairo_d2d_surface_t));
37412:     _cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, CAIRO_CONTENT_COLOR);
37412: 
37412:     RECT rc;
37412:     HRESULT hr;
37412: 
37412:     newSurf->isDrawing = false;
37412:     ::GetClientRect(wnd, &rc);
37412: 
37412:     FLOAT dpiX;
37412:     FLOAT dpiY;
37412:     D2D1_SIZE_U sizePixels;
37412:     D2D1_SIZE_F size;
37412: 
37412:     dpiX = 96;
37412:     dpiY = 96;
37412: 
37412: 
37412:     sizePixels.width = rc.right - rc.left;
37412:     sizePixels.height = rc.bottom - rc.top;
37412: 
37412:     if (!sizePixels.width) {
37412: 	sizePixels.width = 1;
37412:     }
37412:     if (!sizePixels.height) {
37412: 	sizePixels.height = 1;
37412:     }
37412:     ID3D10Device1 *device = D3D10Factory::Device();
37412:     IDXGIDevice *dxgiDevice;
37412:     IDXGIAdapter *dxgiAdapter;
37412:     IDXGIFactory *dxgiFactory;
37412:     
37412:     device->QueryInterface(&dxgiDevice);
37412:     dxgiDevice->GetAdapter(&dxgiAdapter);
37412:     dxgiAdapter->GetParent(IID_PPV_ARGS(&dxgiFactory));
37412:     dxgiAdapter->Release();
37412:     dxgiDevice->Release();
37412: 
37412:     DXGI_SWAP_CHAIN_DESC swapDesc;
37412:     ::ZeroMemory(&swapDesc, sizeof(swapDesc));
37412: 
37412:     swapDesc.BufferDesc.Width = sizePixels.width;
37412:     swapDesc.BufferDesc.Height = sizePixels.height;
37412:     swapDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
37412:     swapDesc.BufferDesc.RefreshRate.Numerator = 60;
37412:     swapDesc.BufferDesc.RefreshRate.Denominator = 1;
37412:     swapDesc.SampleDesc.Count = 1;
37412:     swapDesc.SampleDesc.Quality = 0;
37412:     swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
37412:     swapDesc.BufferCount = 1;
37412:     swapDesc.OutputWindow = wnd;
37412:     swapDesc.Windowed = TRUE;
37412: 
37412:     /**
37412:      * Create a swap chain, this swap chain will contain the backbuffer for
37412:      * the window we draw to. The front buffer is the full screen front
37412:      * buffer.
37412:      */
37412:     hr = dxgiFactory->CreateSwapChain(dxgiDevice, &swapDesc, &newSurf->dxgiChain);
37412: 
37412:     dxgiFactory->Release();
37412:     if (FAILED(hr)) {
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412:     /** Get the backbuffer surface from the swap chain */
37412:     hr = newSurf->dxgiChain->GetBuffer(0,
37412: 	                               IID_PPV_ARGS(&newSurf->backBuf));
37412: 
37412:     if (FAILED(hr)) {
37412: 	newSurf->dxgiChain->Release();
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412: 
37412:     newSurf->backBuf->QueryInterface(&newSurf->surface);
37412: 
37412:     size.width = sizePixels.width * dpiX;
37412:     size.height = sizePixels.height * dpiY;
37412: 
37412:     /** Create the DXGI surface. */
37412:     IDXGISurface *dxgiSurface;
37412:     hr = newSurf->surface->QueryInterface(IID_IDXGISurface, (void**)&dxgiSurface);
37412: 
37412:     D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
37412: 								       D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, D2D1_ALPHA_MODE_PREMULTIPLIED),
37412: 								       dpiX,
37412: 								       dpiY,
37412: 								       D2D1_RENDER_TARGET_USAGE_NONE);
37412:     hr = D2DSurfFactory::Instance()->CreateDxgiSurfaceRenderTarget(dxgiSurface,
37412: 								   props,
37412: 								   &newSurf->rt);
37412:     if (FAILED(hr)) {
37412: 	dxgiSurface->Release();
37412: 	newSurf->surface->Release();
37412: 	newSurf->dxgiChain->Release();
37412: 	newSurf->backBuf->Release();
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412: 
37412:     D2D1_BITMAP_PROPERTIES bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, 
37412: 									       D2D1_ALPHA_MODE_PREMULTIPLIED));
37412:     
37412:     dxgiSurface->Release();
37412: 
37412:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
37412: 
37412:     return reinterpret_cast<cairo_surface_t*>(newSurf);
37412: }
37412: 
37412: cairo_surface_t *
37412: cairo_d2d_surface_create(cairo_format_t format,
37412:                          int width,
37412:                          int height)
37412: {
38825:     if (!D3D10Factory::Device() || !D2DSurfFactory::Instance()) {
38825: 	/**
38825: 	 * FIXME: In the near future we can use cairo_device_t to pass in a
38825: 	 * device.
38825: 	 */
38825: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_DEVICE));
38825:     }
37412:     cairo_d2d_surface_t *newSurf = static_cast<cairo_d2d_surface_t*>(malloc(sizeof(cairo_d2d_surface_t)));
37412: 
37412:     memset(newSurf, 0, sizeof(cairo_d2d_surface_t));
37412:     DXGI_FORMAT dxgiformat = DXGI_FORMAT_B8G8R8A8_UNORM;
37412:     D2D1_ALPHA_MODE alpha = D2D1_ALPHA_MODE_PREMULTIPLIED;
37412:     if (format == CAIRO_FORMAT_ARGB32) {
37412: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, CAIRO_CONTENT_COLOR_ALPHA);
37412:     } else if (format == CAIRO_FORMAT_RGB24) {
37412: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, CAIRO_CONTENT_COLOR);
37412: 	alpha = D2D1_ALPHA_MODE_IGNORE;
37412:     } else {
37412: 	_cairo_surface_init(&newSurf->base, &cairo_d2d_surface_backend, CAIRO_CONTENT_ALPHA);
37412: 	dxgiformat = DXGI_FORMAT_A8_UNORM;
37412:     }
37412:     newSurf->format = format;
37412: 
37412:     D2D1_SIZE_U sizePixels;
37412:     HRESULT hr;
37412: 
37412:     sizePixels.width = width;
37412:     sizePixels.height = height;
37412: 
37412:     CD3D10_TEXTURE2D_DESC desc(
37412: 	dxgiformat,
37412: 	sizePixels.width,
37412: 	sizePixels.height
37412: 	);
37412:     desc.MipLevels = 1;
37412:     desc.Usage = D3D10_USAGE_DEFAULT;
37412:     desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
37412:     
37412:     ID3D10Texture2D *texture;
37412: 
37412:     hr = D3D10Factory::Device()->CreateTexture2D(&desc, NULL, &texture);
37412: 
37412:     if (FAILED(hr)) {
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412: 
37412:     newSurf->surface = texture;
37412: 
37412:     /** Create the DXGI surface. */
37412:     IDXGISurface *dxgiSurface;
37412:     hr = newSurf->surface->QueryInterface(IID_IDXGISurface, (void**)&dxgiSurface);
37412:     if (FAILED(hr)) {
37412: 	newSurf->surface->Release();
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412: 
37412:     D2D1_RENDER_TARGET_PROPERTIES props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,
37412: 								       D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, alpha));
37412:     hr = D2DSurfFactory::Instance()->CreateDxgiSurfaceRenderTarget(dxgiSurface,
37412: 								   props,
37412: 								   &newSurf->rt);
37412: 
37412:     if (FAILED(hr)) {
37412: 	dxgiSurface->Release();
37412: 	newSurf->surface->Release();
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412: 
37412:     D2D1_BITMAP_PROPERTIES bitProps = D2D1::BitmapProperties(D2D1::PixelFormat(DXGI_FORMAT_UNKNOWN, 
37412: 									       alpha));
37412:     hr = newSurf->rt->CreateSharedBitmap(IID_IDXGISurface,
37412: 					 dxgiSurface,
37412: 					 &bitProps,
37412: 					 &newSurf->surfaceBitmap);
37412: 
37412:     if (FAILED(hr)) {
37412: 	dxgiSurface->Release();
37412: 	newSurf->rt->Release();
37412: 	newSurf->surface->Release();
37412: 	free(newSurf);
37412: 	return _cairo_surface_create_in_error(_cairo_error(CAIRO_STATUS_NO_MEMORY));
37412:     }
37412: 
37412:     dxgiSurface->Release();
37412: 
37412:     newSurf->rt->CreateSolidColorBrush(D2D1::ColorF(0, 1.0), &newSurf->solidColorBrush);
37412: 
37412:     return reinterpret_cast<cairo_surface_t*>(newSurf);
37412: }
37412: 
37412: void cairo_d2d_scroll(cairo_surface_t *surface, int x, int y, cairo_rectangle_t *clip)
37412: {
37412:     if (surface->type != CAIRO_SURFACE_TYPE_D2D) {
37412:         return;
37412:     }
37412:     cairo_d2d_surface_t *d2dsurf = reinterpret_cast<cairo_d2d_surface_t*>(surface);
37412: 
37412:     /** For now, we invalidate our storing texture with this operation. */
37412:     D2D1_POINT_2U point;
37412:     D3D10_BOX rect;
37412:     rect.front = 0;
37412:     rect.back = 1;
37412: 
38949:     IDXGISurface *dxgiSurface;
38949:     d2dsurf->surface->QueryInterface(&dxgiSurface);
38949:     DXGI_SURFACE_DESC desc;
38949: 
38949:     dxgiSurface->GetDesc(&desc);
38949:     dxgiSurface->Release();
38949: 
38949:     /**
38949:      * It's important we constrain the size of the clip region to the area of
38949:      * the surface. If we don't we might get a box that goes outside the
38949:      * surface, and CopySubresourceRegion will become very angry with us.
38949:      * It will cause a device failure and subsequent drawing will break.
38949:      */
38949:     clip->x = MAX(clip->x, 0);
38949:     clip->y = MAX(clip->y, 0);
38949:     clip->width = MIN(clip->width, desc.Width - clip->x);
38949:     clip->height = MIN(clip->height, desc.Height - clip->y);
38949: 
37412:     if (x < 0) {
37412: 	point.x = (UINT32)clip->x;
37412: 	rect.left = (UINT)(clip->x - x);
37412: 	rect.right = (UINT)(clip->x + clip->width);
37412:     } else {
37412: 	point.x = (UINT32)(clip->x + x);
37412: 	rect.left = (UINT)clip->x;
37412: 	rect.right = (UINT32)(clip->x + clip->width - x);
37412:     }
37412:     if (y < 0) {
37412: 	point.y = (UINT32)clip->y;
37412: 	rect.top = (UINT)(clip->y - y);
37412: 	rect.bottom = (UINT)(clip->y + clip->height);
37412:     } else {
37412: 	point.y = (UINT32)(clip->y + y);
37412: 	rect.top = (UINT)clip->y;
37412: 	rect.bottom = (UINT)(clip->y + clip->height - y);
37412:     }
37412:     ID3D10Texture2D *texture = _cairo_d2d_get_buffer_texture(d2dsurf);
37412: 
37412:     D3D10Factory::Device()->CopyResource(texture, d2dsurf->surface);
37412:     D3D10Factory::Device()->CopySubresourceRegion(d2dsurf->surface,
37412: 						  0,
37412: 						  point.x,
37412: 						  point.y,
37412: 						  0,
37412: 						  texture,
37412: 						  0,
37412: 						  &rect);
37412: 
37412: }
38825: 
38825: cairo_bool_t
38825: cairo_d2d_has_support()
38825: {
38825:     /**
38825:      * FIXME: We should be able to fix this in the near future when we pass in
38825:      * a cairo_device_t to our surface creation functions.
38825:      */
38825:     if (!D3D10Factory::Device() || !D2DSurfFactory::Instance()) {
38825: 	return false;
38825:     }
38825:     return true;
38825: }
