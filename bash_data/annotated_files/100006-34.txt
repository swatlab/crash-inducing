 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS symbol tables.
     1:  */
 32777: #include <new>
     1: #include <stdlib.h>
     1: #include <string.h>
     1: #include "jstypes.h"
     1: #include "jsclist.h"
 55477: #include "jsutil.h"
     1: #include "jsapi.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
     1: #include "jsdbgapi.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
 40405: #include "jsobj.h"
     1: #include "jsscope.h"
     1: #include "jsstr.h"
     1: 
 86104: #include "js/MemoryMetrics.h"
 86104: 
 74471: #include "jsatominlines.h"
 98835: #include "jscntxtinlines.h"
 47497: #include "jsobjinlines.h"
 34349: #include "jsscopeinlines.h"
 34349: 
 37741: using namespace js;
 54707: using namespace js::gc;
 37741: 
 30258: bool
 97571: ShapeTable::init(JSRuntime *rt, Shape *lastProp)
     1: {
     1:     /*
 12307:      * Either we're creating a table for a large scope that was populated
 12307:      * via property cache hit logic under JSOP_INITPROP, JSOP_SETNAME, or
 12307:      * JSOP_SETPROP; or else calloc failed at least once already. In any
 12307:      * event, let's try to grow, overallocating to hold at least twice the
 12307:      * current population.
     1:      */
 84755:     uint32_t sizeLog2 = JS_CEILING_LOG2W(2 * entryCount);
 59992:     if (sizeLog2 < MIN_SIZE_LOG2)
 52503:         sizeLog2 = MIN_SIZE_LOG2;
     1: 
 56587:     /*
 64560:      * Use rt->calloc_ for memory accounting and overpressure handling
 97571:      * without OOM reporting. See ShapeTable::change.
 56587:      */
 74300:     entries = (Shape **) rt->calloc_(sizeOfEntries(JS_BIT(sizeLog2)));
 72559:     if (!entries)
 30258:         return false;
     1: 
 94610:     hashShift = HASH_BITS - sizeLog2;
 52503:     for (Shape::Range r = lastProp->all(); !r.empty(); r.popFront()) {
 52503:         const Shape &shape = r.front();
 83221:         Shape **spp = search(shape.propid(), true);
 54857: 
 54857:         /*
 54857:          * Beware duplicate args and arg vs. var conflicts: the youngest shape
 54857:          * (nearest to lastProp) must win. See bug 600067.
 54857:          */
 54857:         if (!SHAPE_FETCH(spp))
 52503:             SHAPE_STORE_PRESERVING_COLLISION(spp, &shape);
     1:     }
 30258:     return true;
     1: }
     1: 
 52503: bool
 83221: Shape::makeOwnBaseShape(JSContext *cx)
 83221: {
 83221:     JS_ASSERT(!base()->isOwned());
 93956:     assertSameCompartment(cx, compartment());
 83221: 
 99421:     RootedShape self(cx, this);
 86437: 
 83221:     BaseShape *nbase = js_NewGCBaseShape(cx);
 83221:     if (!nbase)
 83221:         return false;
 83221: 
 98446:     new (nbase) BaseShape(StackBaseShape(self));
 86437:     nbase->setOwned(self->base()->toUnowned());
 83221: 
 86437:     self->base_ = nbase;
 83221: 
 83221:     return true;
 83221: }
 83221: 
 83221: void
 83229: Shape::handoffTableTo(Shape *shape)
 83221: {
 83221:     JS_ASSERT(inDictionary() && shape->inDictionary());
 83221: 
 83221:     if (this == shape)
 83221:         return;
 83221: 
 83221:     JS_ASSERT(base()->isOwned() && !shape->base()->isOwned());
 83221: 
 83221:     BaseShape *nbase = base();
 83221: 
 83245:     JS_ASSERT_IF(shape->hasSlot(), nbase->slotSpan() > shape->slot());
 83221: 
 83229:     this->base_ = nbase->baseUnowned();
 83245:     nbase->adoptUnowned(shape->base()->toUnowned());
 83221: 
 83221:     shape->base_ = nbase;
 83221: }
 83221: 
 83221: bool
 78194: Shape::hashify(JSContext *cx)
     1: {
 62399:     JS_ASSERT(!hasTable());
 83221: 
 99421:     RootedShape self(cx, this);
 86437: 
 83221:     if (!ensureOwnBaseShape(cx))
 83221:         return false;
 83221: 
 78194:     JSRuntime *rt = cx->runtime;
 97571:     ShapeTable *table = rt->new_<ShapeTable>(self->entryCount());
 64559:     if (!table)
 59992:         return false;
 71357: 
 86437:     if (!table->init(rt, self)) {
 71357:         rt->free_(table);
 71357:         return false;
 71357:     }
 71357: 
 86437:     self->base()->setTable(table);
 71357:     return true;
 30645: }
 30645: 
     1: /*
     1:  * Double hashing needs the second hash code to be relatively prime to table
 74471:  * size, so we simply make hash2 odd.
     1:  */
 52503: #define HASH1(hash0,shift)      ((hash0) >> (shift))
 52503: #define HASH2(hash0,log2,shift) ((((hash0) << (log2)) >> (shift)) | 1)
     1: 
 52503: Shape **
 97571: ShapeTable::search(jsid id, bool adding)
     1: {
     1:     JSHashNumber hash0, hash1, hash2;
 30258:     int sizeLog2;
 52503:     Shape *stored, *shape, **spp, **firstRemoved;
 84755:     uint32_t sizeMask;
     1: 
 52503:     JS_ASSERT(entries);
 83221:     JS_ASSERT(!JSID_IS_EMPTY(id));
     1: 
 12307:     /* Compute the primary hash address. */
 74471:     hash0 = HashId(id);
 52503:     hash1 = HASH1(hash0, hashShift);
 52503:     spp = entries + hash1;
     1: 
     1:     /* Miss: return space for a new entry. */
     1:     stored = *spp;
 72559:     if (SHAPE_IS_FREE(stored))
     1:         return spp;
     1: 
     1:     /* Hit: return entry. */
 52503:     shape = SHAPE_CLEAR_COLLISION(stored);
 83221:     if (shape && shape->propid() == id)
     1:         return spp;
     1: 
     1:     /* Collision: double hash. */
 94610:     sizeLog2 = HASH_BITS - hashShift;
 52503:     hash2 = HASH2(hash0, sizeLog2, hashShift);
     1:     sizeMask = JS_BITMASK(sizeLog2);
     1: 
 35465: #ifdef DEBUG
 86976:     uintptr_t collision_flag = SHAPE_COLLISION;
 35465: #endif
 35465: 
     1:     /* Save the first removed entry pointer so we can recycle it if adding. */
 52503:     if (SHAPE_IS_REMOVED(stored)) {
     1:         firstRemoved = spp;
     1:     } else {
     1:         firstRemoved = NULL;
 52503:         if (adding && !SHAPE_HAD_COLLISION(stored))
 52503:             SHAPE_FLAG_COLLISION(spp, shape);
 35465: #ifdef DEBUG
 86976:         collision_flag &= uintptr_t(*spp) & SHAPE_COLLISION;
 35465: #endif
     1:     }
     1: 
     1:     for (;;) {
     1:         hash1 -= hash2;
     1:         hash1 &= sizeMask;
 52503:         spp = entries + hash1;
     1: 
     1:         stored = *spp;
 72559:         if (SHAPE_IS_FREE(stored))
     1:             return (adding && firstRemoved) ? firstRemoved : spp;
     1: 
 52503:         shape = SHAPE_CLEAR_COLLISION(stored);
 83221:         if (shape && shape->propid() == id) {
 35465:             JS_ASSERT(collision_flag);
     1:             return spp;
     1:         }
     1: 
 52503:         if (SHAPE_IS_REMOVED(stored)) {
     1:             if (!firstRemoved)
     1:                 firstRemoved = spp;
     1:         } else {
 52503:             if (adding && !SHAPE_HAD_COLLISION(stored))
 52503:                 SHAPE_FLAG_COLLISION(spp, shape);
 35465: #ifdef DEBUG
 86976:             collision_flag &= uintptr_t(*spp) & SHAPE_COLLISION;
 35465: #endif
     1:         }
     1:     }
     1: 
     1:     /* NOTREACHED */
     1:     return NULL;
     1: }
     1: 
 30258: bool
 97571: ShapeTable::change(int log2Delta, JSContext *cx)
     1: {
 52503:     JS_ASSERT(entries);
 12307: 
 56587:     /*
 64559:      * Grow, shrink, or compress by changing this->entries.
 56587:      */
 94610:     int oldlog2 = HASH_BITS - hashShift;
 74300:     int newlog2 = oldlog2 + log2Delta;
 84755:     uint32_t oldsize = JS_BIT(oldlog2);
 84755:     uint32_t newsize = JS_BIT(newlog2);
 74300:     Shape **newTable = (Shape **) cx->calloc_(sizeOfEntries(newsize));
 72559:     if (!newTable)
 30258:         return false;
     1: 
 52503:     /* Now that we have newTable allocated, update members. */
 94610:     hashShift = HASH_BITS - newlog2;
 30258:     removedCount = 0;
 74300:     Shape **oldTable = entries;
 52503:     entries = newTable;
     1: 
     1:     /* Copy only live entries, leaving removed and free ones behind. */
 74300:     for (Shape **oldspp = oldTable; oldsize != 0; oldspp++) {
 74300:         Shape *shape = SHAPE_FETCH(oldspp);
 52503:         if (shape) {
 83221:             Shape **spp = search(shape->propid(), true);
 52503:             JS_ASSERT(SHAPE_IS_FREE(*spp));
 52503:             *spp = shape;
     1:         }
     1:         oldsize--;
     1:     }
     1: 
 64559:     /* Finally, free the old entries storage. */
 64560:     cx->free_(oldTable);
 30258:     return true;
     1: }
     1: 
 58067: bool
 97571: ShapeTable::grow(JSContext *cx)
 58067: {
 58067:     JS_ASSERT(needsToGrow());
 58067: 
 84755:     uint32_t size = capacity();
 58067:     int delta = removedCount < size >> 2;
 58067: 
 58067:     if (!change(delta, cx) && entryCount + removedCount == size - 1) {
 58067:         JS_ReportOutOfMemory(cx);
 58067:         return false;
 58067:     }
 58067:     return true;
 58067: }
 58067: 
 80212: Shape *
 86437: Shape::getChildBinding(JSContext *cx, const StackShape &child)
 82129: {
 83229:     JS_ASSERT(!inDictionary());
 52503: 
 98835:     Shape *shape = cx->propertyTree().getChild(cx, this, numFixedSlots(), child);
 52503:     if (shape) {
 95355:         //JS_ASSERT(shape->parent == this); // XXX 'this' is not rooted here
 83247: 
 83247:         /*
 83247:          * Update the number of fixed slots which bindings of this shape will
 83247:          * have. Bindings are constructed as new properties come in, so the
 83247:          * call object allocation class is not known ahead of time. Compute
 83247:          * the fixed slot count here, which will feed into call objects created
 83247:          * off of the bindings.
 83247:          */
100006:         uint32_t slots = child.slotSpan() + 1;  /* Add one for private data. */
 83247:         gc::AllocKind kind = gc::GetGCObjectKind(slots);
 83247: 
 83247:         /*
 83247:          * Make sure that the arguments and variables in the call object all
 83247:          * end up in a contiguous range of slots. We need this to be able to
 83247:          * embed the args/vars arrays in the TypeScriptNesting for the function
 83247:          * after the call object's frame has finished.
 83247:          */
 84755:         uint32_t nfixed = gc::GetGCKindSlots(kind);
 83247:         if (nfixed < slots) {
100006:             nfixed = CallObject::RESERVED_SLOTS + 1;
100006:             JS_ASSERT(gc::GetGCKindSlots(gc::GetGCObjectKind(nfixed)) == CallObject::RESERVED_SLOTS + 1);
 83247:         }
 83247: 
100006:         shape->setNumFixedSlots(nfixed - 1);
 52503:     }
 52503:     return shape;
 52503: }
 52503: 
 86437: /* static */ Shape *
 99364: Shape::replaceLastProperty(JSContext *cx, const StackBaseShape &base, JSObject *proto, Shape *shape_)
 83245: {
 99421:     RootedShape shape(cx, shape_);
 99364: 
 83308:     JS_ASSERT(!shape->inDictionary());
 83308: 
 83308:     if (!shape->parent) {
 83308:         /* Treat as resetting the initial property of the shape hierarchy. */
 83308:         AllocKind kind = gc::GetGCObjectKind(shape->numFixedSlots());
 86437:         return EmptyShape::getInitialShape(cx, base.clasp, proto,
 83308:                                            base.parent, kind,
 83308:                                            base.flags & BaseShape::OBJECT_FLAG_MASK);
 83308:     }
 83308: 
 86437:     UnownedBaseShape *nbase = BaseShape::getUnowned(cx, base);
 83287:     if (!nbase)
 86457:         return NULL;
 83287: 
 86437:     StackShape child(shape);
 86437:     child.base = nbase;
 83245: 
 98835:     return cx->propertyTree().getChild(cx, shape->parent, shape->numFixedSlots(), child);
 83245: }
 83245: 
 35453: /*
 86523:  * Get or create a property-tree or dictionary child property of |parent|,
 86523:  * which must be lastProperty() if inDictionaryMode(), else parent must be
 86523:  * one of lastProperty() or lastProperty()->parent.
 35453:  */
 52503: Shape *
 86437: JSObject::getChildProperty(JSContext *cx, Shape *parent, StackShape &child)
 35453: {
 35453:     /*
 83221:      * Shared properties have no slot, but slot_ will reflect that of parent.
 83221:      * Unshared properties allocate a slot here but may lose it due to a
 83221:      * JS_ClearScope call.
 35453:      */
 83221:     if (!child.hasSlot()) {
 83247:         child.setSlot(parent->maybeSlot());
 35453:     } else {
 83221:         if (child.hasMissingSlot()) {
 84755:             uint32_t slot;
 83221:             if (!allocSlot(cx, &slot))
 35453:                 return NULL;
 83247:             child.setSlot(slot);
 83221:         } else {
 83221:             /* Slots can only be allocated out of order on objects in dictionary mode. */
 83221:             JS_ASSERT(inDictionaryMode() ||
 83231:                       parent->hasMissingSlot() ||
 83325:                       child.slot() == parent->maybeSlot() + 1);
 83221:         }
 35453:     }
 35453: 
 53650:     Shape *shape;
 53650: 
 99421:     RootedObject self(cx, this);
 86437: 
 35453:     if (inDictionaryMode()) {
 83231:         JS_ASSERT(parent == lastProperty());
 99364:         StackShape::AutoRooter childRoot(cx, &child);
 83221:         shape = js_NewGCShape(cx);
 53650:         if (!shape)
 35453:             return NULL;
 86437:         if (child.hasSlot() && child.slot() >= self->lastProperty()->base()->slotSpan()) {
 86437:             if (!self->setSlotSpan(cx, child.slot() + 1))
 83232:                 return NULL;
 83232:         }
 86437:         shape->initDictionaryShape(child, self->numFixedSlots(), &self->shape_);
 53650:     } else {
 98835:         shape = cx->propertyTree().getChild(cx, parent, self->numFixedSlots(), child);
 62049:         if (!shape)
 62049:             return NULL;
 86437:         //JS_ASSERT(shape->parent == parent);
 86437:         //JS_ASSERT_IF(parent != lastProperty(), parent == lastProperty()->parent);
 86437:         if (!self->setLastProperty(cx, shape))
 83231:             return NULL;
 53650:     }
 53650: 
 52503:     return shape;
 35453: }
 35453: 
 52503: bool
 52503: JSObject::toDictionaryMode(JSContext *cx)
 52503: {
 52503:     JS_ASSERT(!inDictionaryMode());
 64360: 
 64360:     /* We allocate the shapes from cx->compartment, so make sure it's right. */
 64360:     JS_ASSERT(compartment() == cx->compartment);
 83221: 
 84755:     uint32_t span = slotSpan();
 83221: 
 99421:     RootedObject self(cx, this);
 86437: 
 83240:     /*
 83240:      * Clone the shapes into a new dictionary list. Don't update the
 83240:      * last property of this object until done, otherwise a GC
 83240:      * triggered while creating the dictionary will get the wrong
 83240:      * slot span for this object.
 83240:      */
 99421:     RootedShape root(cx);
 99421:     RootedShape dictionaryShape(cx);
 86437: 
 99421:     RootedShape shape(cx);
 86437:     shape = lastProperty();
 86437: 
 86437:     while (shape) {
 86437:         JS_ASSERT(!shape->inDictionary());
 86437: 
 86437:         Shape *dprop = js_NewGCShape(cx);
 92002:         if (!dprop) {
 92002:             js_ReportOutOfMemory(cx);
 52503:             return false;
 92002:         }
 52503: 
 86437:         HeapPtrShape *listp = dictionaryShape
 86437:                               ? &dictionaryShape->parent
 86437:                               : (HeapPtrShape *) root.address();
 83240: 
 86437:         StackShape child(shape);
 86437:         dprop->initDictionaryShape(child, self->numFixedSlots(), listp);
 86437: 
 86437:         JS_ASSERT(!dprop->hasTable());
 86437:         dictionaryShape = dprop;
 86437:         shape = shape->previous();
 86437:     }
 86437: 
 92002:     if (!root->hashify(cx)) {
 92002:         js_ReportOutOfMemory(cx);
 86437:         return false;
 92002:     }
 86437: 
 86437:     JS_ASSERT((Shape **) root->listp == root.address());
 86437:     root->listp = &self->shape_;
 86437:     self->shape_ = root;
 86437: 
 86437:     JS_ASSERT(self->inDictionaryMode());
 86437:     root->base()->setSlotSpan(span);
 83221: 
 52503:     return true;
 52503: }
 52503: 
 52503: /*
 52503:  * Normalize stub getter and setter values for faster is-stub testing in the
 52503:  * SHAPE_CALL_[GS]ETTER macros.
 52503:  */
 52503: static inline bool
 52503: NormalizeGetterAndSetter(JSContext *cx, JSObject *obj,
 91237:                          jsid id, unsigned attrs, unsigned flags,
 52503:                          PropertyOp &getter,
 62395:                          StrictPropertyOp &setter)
 52503: {
 78614:     if (setter == JS_StrictPropertyStub) {
 52503:         JS_ASSERT(!(attrs & JSPROP_SETTER));
 52503:         setter = NULL;
 52503:     }
 78614:     if (getter == JS_PropertyStub) {
 52503:         JS_ASSERT(!(attrs & JSPROP_GETTER));
 52503:         getter = NULL;
 52503:     }
 52503: 
 52503:     return true;
 52503: }
 52503: 
 83297: Shape *
 52503: JSObject::addProperty(JSContext *cx, jsid id,
 62395:                       PropertyOp getter, StrictPropertyOp setter,
 91237:                       uint32_t slot, unsigned attrs,
 91237:                       unsigned flags, int shortid, bool allowDictionary)
 52503: {
 52503:     JS_ASSERT(!JSID_IS_VOID(id));
 52503: 
 54587:     if (!isExtensible()) {
 54587:         reportNotExtensible(cx);
 54587:         return NULL;
 54587:     }
 54587: 
 52503:     NormalizeGetterAndSetter(cx, this, id, attrs, flags, getter, setter);
 52503: 
 99421:     RootedObject self(cx, this);
 95355: 
 86437:     Shape **spp = NULL;
 86437:     if (inDictionaryMode())
 86437:         spp = lastProperty()->table().search(id, true);
 86437: 
 95355:     return self->addPropertyInternal(cx, id, getter, setter, slot, attrs, flags, shortid,
 86437:                                      spp, allowDictionary);
 52503: }
 52503: 
 83297: Shape *
 99364: JSObject::addPropertyInternal(JSContext *cx, jsid id_,
 62395:                               PropertyOp getter, StrictPropertyOp setter,
 91237:                               uint32_t slot, unsigned attrs,
 91237:                               unsigned flags, int shortid, Shape **spp,
 86437:                               bool allowDictionary)
 52503: {
 83221:     JS_ASSERT_IF(!allowDictionary, !inDictionaryMode());
 54563: 
 99421:     RootedId id(cx, id_);
 99421:     RootedObject self(cx, this);
 86437: 
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 97353: 
 97571:     ShapeTable *table = NULL;
 52503:     if (!inDictionaryMode()) {
 83221:         bool stableSlot =
 83221:             (slot == SHAPE_INVALID_SLOT) ||
 83231:             lastProperty()->hasMissingSlot() ||
 83231:             (slot == lastProperty()->maybeSlot() + 1);
 83221:         JS_ASSERT_IF(!allowDictionary, stableSlot);
 83221:         if (allowDictionary &&
 83231:             (!stableSlot || lastProperty()->entryCount() >= PropertyTree::MAX_HEIGHT)) {
 52503:             if (!toDictionaryMode(cx))
 52503:                 return NULL;
 95355:             table = &self->lastProperty()->table();
 86437:             spp = table->search(id, true);
 52503:         }
 86437:     } else {
 83231:         table = &lastProperty()->table();
 58067:         if (table->needsToGrow()) {
 58067:             if (!table->grow(cx))
 52503:                 return NULL;
 52503:             spp = table->search(id, true);
 52503:             JS_ASSERT(!SHAPE_FETCH(spp));
 52503:         }
 52503:     }
 52503: 
 86437:     JS_ASSERT(!!table == !!spp);
 86437: 
 52503:     /* Find or create a property tree node labeled by our arguments. */
 83221:     Shape *shape;
 52503:     {
 86437:         shape = self->lastProperty();
 86437: 
 91688:         uint32_t index;
 86163:         bool indexed = js_IdIsIndex(id, &index);
 84345:         UnownedBaseShape *nbase;
 86437:         if (shape->base()->matchesGetterSetter(getter, setter) && !indexed) {
 86437:             nbase = shape->base()->unowned();
 83320:         } else {
 86437:             StackBaseShape base(shape->base());
 86437:             base.updateGetterSetter(attrs, getter, setter);
 86437:             if (indexed)
 86437:                 base.flags |= BaseShape::INDEXED;
 83320:             nbase = BaseShape::getUnowned(cx, base);
 83221:             if (!nbase)
 83221:                 return NULL;
 83320:         }
 83221: 
 86437:         StackShape child(nbase, id, slot, self->numFixedSlots(), attrs, flags, shortid);
 86437:         shape = self->getChildProperty(cx, self->lastProperty(), child);
 52503:     }
 52503: 
 52503:     if (shape) {
 86437:         JS_ASSERT(shape == self->lastProperty());
 52503: 
 52503:         if (table) {
 52503:             /* Store the tree node pointer in the table entry for id. */
 52503:             SHAPE_STORE_PRESERVING_COLLISION(spp, shape);
 52503:             ++table->entryCount;
 52503: 
 83231:             /* Pass the table along to the new last property, namely shape. */
 83229:             JS_ASSERT(&shape->parent->table() == table);
 83229:             shape->parent->handoffTableTo(shape);
 52503:         }
 68896: 
 93703:         self->checkShapeConsistency();
 52503:         return shape;
 52503:     }
 52503: 
 93703:     self->checkShapeConsistency();
 52503:     return NULL;
 52503: }
 52503: 
 61690: /*
 61690:  * Check and adjust the new attributes for the shape to make sure that our
 61690:  * slot access optimizations are sound. It is responsibility of the callers to
 61690:  * enforce all restrictions from ECMA-262 v5 8.12.9 [[DefineOwnProperty]].
 61690:  */
 61690: inline bool
 91237: CheckCanChangeAttrs(JSContext *cx, JSObject *obj, const Shape *shape, unsigned *attrsp)
 61690: {
 61690:     if (shape->configurable())
 61690:         return true;
 61690: 
 61690:     /* A permanent property must stay permanent. */
 61690:     *attrsp |= JSPROP_PERMANENT;
 61690: 
 61690:     /* Reject attempts to remove a slot from the permanent data property. */
 61690:     if (shape->isDataDescriptor() && shape->hasSlot() &&
 61690:         (*attrsp & (JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED))) {
 83221:         obj->reportNotConfigurable(cx, shape->propid());
 61690:         return false;
 61690:     }
 61690: 
 61690:     return true;
 61690: }
 61690: 
 83297: Shape *
 99364: JSObject::putProperty(JSContext *cx, jsid id_,
 62395:                       PropertyOp getter, StrictPropertyOp setter,
 91237:                       uint32_t slot, unsigned attrs,
 91237:                       unsigned flags, int shortid)
 52503: {
 99421:     RootedId id(cx, id_);
 54587:     JS_ASSERT(!JSID_IS_VOID(id));
 52503: 
 52503:     NormalizeGetterAndSetter(cx, this, id, attrs, flags, getter, setter);
 52503: 
 99421:     RootedObject self(cx, this);
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 86437: 
 52503:     /* Search for id in order to claim its entry if table has been allocated. */
 86437:     Shape **spp;
 99421:     RootedShape shape(cx, Shape::search(cx, lastProperty(), id, &spp, true));
 54587:     if (!shape) {
 54587:         /*
 54587:          * You can't add properties to a non-extensible object, but you can change
 54587:          * attributes of properties in such objects.
 54587:          */
 86437:         if (!self->isExtensible()) {
 86437:             self->reportNotExtensible(cx);
 54587:             return NULL;
 54587:         }
 54587: 
 86437:         return self->addPropertyInternal(cx, id, getter, setter, slot, attrs, flags, shortid, spp, true);
 54587:     }
 52503: 
 52503:     /* Property exists: search must have returned a valid *spp. */
 86437:     JS_ASSERT_IF(spp, !SHAPE_IS_REMOVED(*spp));
 52503: 
 86437:     if (!CheckCanChangeAttrs(cx, self, shape, &attrs))
 61690:         return NULL;
 61690: 
 52503:     /*
 54587:      * If the caller wants to allocate a slot, but doesn't care which slot,
 54587:      * copy the existing shape's slot into slot so we can match shape, if all
 54587:      * other members match.
 52503:      */
 74907:     bool hadSlot = shape->hasSlot();
 84755:     uint32_t oldSlot = shape->maybeSlot();
 54473:     if (!(attrs & JSPROP_SHARED) && slot == SHAPE_INVALID_SLOT && hadSlot)
 54473:         slot = oldSlot;
 54587: 
 99421:     Rooted<UnownedBaseShape*> nbase(cx);
 83221:     {
 91688:         uint32_t index;
 86163:         bool indexed = js_IdIsIndex(id, &index);
 86437:         StackBaseShape base(self->lastProperty()->base());
 86437:         base.updateGetterSetter(attrs, getter, setter);
 86437:         if (indexed)
 86437:             base.flags |= BaseShape::INDEXED;
 83316:         nbase = BaseShape::getUnowned(cx, base);
 83221:         if (!nbase)
 83221:             return NULL;
 83221:     }
 83221: 
 54587:     /*
 54587:      * Now that we've possibly preserved slot, check whether all members match.
 54587:      * If so, this is a redundant "put" and we can return without more work.
 54587:      */
 83221:     if (shape->matchesParamsAfterId(nbase, slot, attrs, flags, shortid))
 52503:         return shape;
 52503: 
 52503:     /*
 54587:      * Overwriting a non-last property requires switching to dictionary mode.
 54587:      * The shape tree is shared immutable, and we can't removeProperty and then
 54587:      * addPropertyInternal because a failure under add would lose data.
 52503:      */
 86437:     if (shape != self->lastProperty() && !self->inDictionaryMode()) {
 86437:         if (!self->toDictionaryMode(cx))
 57752:             return NULL;
 86437:         spp = self->lastProperty()->table().search(shape->propid(), false);
 52503:         shape = SHAPE_FETCH(spp);
 52509:     }
 52509: 
 83221:     JS_ASSERT_IF(shape->hasSlot() && !(attrs & JSPROP_SHARED), shape->slot() == slot);
 83221: 
 86702:     if (self->inDictionaryMode()) {
 54473:         /*
 86702:          * Updating some property in a dictionary-mode object. Create a new
 86702:          * shape for the existing property, and also generate a new shape for
 86702:          * the last property of the dictionary (unless the modified property
 86702:          * is also the last property).
 54473:          */
 86437:         bool updateLast = (shape == self->lastProperty());
 86702:         shape = self->replaceWithNewEquivalentShape(cx, shape);
 86702:         if (!shape)
 83221:             return NULL;
 86702:         if (!updateLast && !self->generateOwnShape(cx))
 86702:             return NULL;
 83221: 
 54587:         /* FIXME bug 593129 -- slot allocation and JSObject *this must move out of here! */
 74907:         if (slot == SHAPE_INVALID_SLOT && !(attrs & JSPROP_SHARED)) {
 86437:             if (!self->allocSlot(cx, &slot))
 54587:                 return NULL;
 54587:         }
 54587: 
 86702:         if (updateLast)
 83245:             shape->base()->adoptUnowned(nbase);
 83245:         else
 83221:             shape->base_ = nbase;
 54587: 
 83247:         shape->setSlot(slot);
 84755:         shape->attrs = uint8_t(attrs);
 54587:         shape->flags = flags | Shape::IN_DICTIONARY;
 84755:         shape->shortid_ = int16_t(shortid);
 54587:     } else {
 54587:         /*
 86702:          * Updating the last property in a non-dictionary-mode object. Find an
 86702:          * alternate shared child of the last property's previous shape.
 54587:          */
 86437:         StackBaseShape base(self->lastProperty()->base());
 86437:         base.updateGetterSetter(attrs, getter, setter);
 84345:         UnownedBaseShape *nbase = BaseShape::getUnowned(cx, base);
 83221:         if (!nbase)
 83221:             return NULL;
 83221: 
 86437:         JS_ASSERT(shape == self->lastProperty());
 54587: 
 54587:         /* Find or create a property tree node labeled by our arguments. */
 86437:         StackShape child(nbase, id, slot, self->numFixedSlots(), attrs, flags, shortid);
 86437:         Shape *newShape = self->getChildProperty(cx, shape->parent, child);
 54587: 
 54587:         if (!newShape) {
 93703:             self->checkShapeConsistency();
 54587:             return NULL;
 54587:         }
 54587: 
 54587:         shape = newShape;
 57677:     }
 54587: 
 54587:     /*
 54587:      * Can't fail now, so free the previous incarnation's slot if the new shape
 54587:      * has no slot. But we do not need to free oldSlot (and must not, as trying
 83231:      * to will botch an assertion in JSObject::freeSlot) if the new last
 83231:      * property (shape here) has a slotSpan that does not cover it.
 54587:      */
 54587:     if (hadSlot && !shape->hasSlot()) {
 86437:         if (oldSlot < self->slotSpan())
 86437:             self->freeSlot(cx, oldSlot);
 54473:         JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
 54473:     }
 54473: 
 93703:     self->checkShapeConsistency();
 57752: 
 74472:     return shape;
 52503: }
 52503: 
 83297: Shape *
 91237: JSObject::changeProperty(JSContext *cx, Shape *shape, unsigned attrs, unsigned mask,
 62395:                          PropertyOp getter, StrictPropertyOp setter)
 52503: {
 78194:     JS_ASSERT(nativeContains(cx, *shape));
 52503: 
 52503:     attrs |= shape->attrs & mask;
 52503: 
 53650:     /* Allow only shared (slotless) => unshared (slotful) transition. */
 52503:     JS_ASSERT(!((attrs ^ shape->attrs) & JSPROP_SHARED) ||
 52503:               !(attrs & JSPROP_SHARED));
 52503: 
 83221:     types::MarkTypePropertyConfigured(cx, this, shape->propid());
 77343:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER))
 83221:         types::AddTypePropertyId(cx, this, shape->propid(), types::Type::UnknownType());
 77343: 
 78614:     if (getter == JS_PropertyStub)
 52503:         getter = NULL;
 78614:     if (setter == JS_StrictPropertyStub)
 52503:         setter = NULL;
 61690: 
 61690:     if (!CheckCanChangeAttrs(cx, this, shape, &attrs))
 61690:         return NULL;
 61690: 
 52503:     if (shape->attrs == attrs && shape->getter() == getter && shape->setter() == setter)
 52503:         return shape;
 52503: 
 52503:     /*
 52503:      * Let JSObject::putProperty handle this |overwriting| case, including
 52503:      * the conservation of shape->slot (if it's valid). We must not call
 54587:      * removeProperty because it will free an allocated shape->slot, and
 54587:      * putProperty won't re-allocate it.
 52503:      */
 83297:     Shape *newShape = putProperty(cx, shape->propid(), getter, setter, shape->maybeSlot(),
 83221:                                   attrs, shape->flags, shape->maybeShortid());
 52503: 
 93703:     checkShapeConsistency();
 52503:     return newShape;
 52503: }
 52503: 
 52503: bool
 99364: JSObject::removeProperty(JSContext *cx, jsid id_)
 52503: {
 99421:     RootedId id(cx, id_);
 99421:     RootedObject self(cx, this);
 86437: 
 99421:     RootedShape shape(cx);
 86437: 
 86437:     Shape **spp;
 86437:     shape = Shape::search(cx, lastProperty(), id, &spp);
 72559:     if (!shape)
 52503:         return true;
 52503: 
 83245:     /*
 83245:      * If shape is not the last property added, or the last property cannot
 83245:      * be removed, switch to dictionary mode.
 83245:      */
 86437:     if (!self->inDictionaryMode() && (shape != self->lastProperty() || !self->canRemoveLastProperty())) {
 86437:         if (!self->toDictionaryMode(cx))
 52503:             return false;
 86437:         spp = self->lastProperty()->table().search(shape->propid(), false);
 52503:         shape = SHAPE_FETCH(spp);
 52503:     }
 52503: 
 52503:     /*
 83221:      * If in dictionary mode, get a new shape for the last property after the
 83221:      * removal. We need a fresh shape for all dictionary deletions, even of
 83231:      * the last property. Otherwise, a shape could replay and caches might
 83231:      * return deleted DictionaryShapes! See bug 595365. Do this before changing
 83231:      * the object or table, so the remaining removal is infallible.
 83221:      */
 99421:     RootedShape spare(cx);
 86437:     if (self->inDictionaryMode()) {
 83221:         spare = js_NewGCShape(cx);
 83221:         if (!spare)
 83221:             return false;
 84345:         new (spare) Shape(shape->base()->unowned(), 0);
 97353:         if (shape == self->lastProperty()) {
 86163:             /*
 86163:              * Get an up to date unowned base shape for the new last property
 86163:              * when removing the dictionary's last property. Information in
 86163:              * base shapes for non-last properties may be out of sync with the
 86163:              * object's state.
 86163:              */
 99421:             RootedShape previous(cx, self->lastProperty()->parent);
 97353:             StackBaseShape base(self->lastProperty()->base());
 86437:             base.updateGetterSetter(previous->attrs, previous->getter(), previous->setter());
 86163:             BaseShape *nbase = BaseShape::getUnowned(cx, base);
 86163:             if (!nbase)
 86163:                 return false;
 86163:             previous->base_ = nbase;
 86163:         }
 83221:     }
 83221: 
 83221:     /* If shape has a slot, free its slot number. */
 83221:     if (shape->hasSlot()) {
 86437:         self->freeSlot(cx, shape->slot());
 83221:         JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
 83221:     }
 83221: 
 83221:     /*
 54587:      * A dictionary-mode object owns mutable, unique shapes on a non-circular
 86523:      * doubly linked list, hashed by lastProperty()->table. So we can edit the
 86523:      * list and hash in place.
 52503:      */
 86437:     if (self->inDictionaryMode()) {
 97571:         ShapeTable &table = self->lastProperty()->table();
 52503: 
 52503:         if (SHAPE_HAD_COLLISION(*spp)) {
 52503:             *spp = SHAPE_REMOVED;
 83229:             ++table.removedCount;
 83229:             --table.entryCount;
 52503:         } else {
 52503:             *spp = NULL;
 83229:             --table.entryCount;
 52503: 
 52503: #ifdef DEBUG
 52503:             /*
 52503:              * Check the consistency of the table but limit the number of
 52503:              * checks not to alter significantly the complexity of the
 52503:              * delete in debug builds, see bug 534493.
 52503:              */
 86437:             const Shape *aprop = self->lastProperty();
 53651:             for (int n = 50; --n >= 0 && aprop->parent; aprop = aprop->parent)
 86437:                 JS_ASSERT_IF(aprop != shape, self->nativeContains(cx, *aprop));
 52503: #endif
 52503:         }
 52503: 
 83221:         /* Remove shape from its non-circular doubly linked list. */
 86437:         Shape *oldLastProp = self->lastProperty();
 86437:         shape->removeFromDictionary(self);
 53650: 
 83231:         /* Hand off table from the old to new last property. */
 86437:         oldLastProp->handoffTableTo(self->lastProperty());
 53650: 
 83221:         /* Generate a new shape for the object, infallibly. */
 86437:         JS_ALWAYS_TRUE(self->generateOwnShape(cx, spare));
 58749: 
 83221:         /* Consider shrinking table if its load factor is <= .25. */
 84755:         uint32_t size = table.capacity();
 97571:         if (size > ShapeTable::MIN_SIZE && table.entryCount <= size >> 2)
 83229:             (void) table.change(-1, cx);
 52503:     } else {
 52503:         /*
 97571:          * Non-dictionary-mode shape tables are shared immutables, so all we
 83231:          * need do is retract the last property and we'll either get or else
 83231:          * lazily make via a later hashify the exact table for the new property
 83231:          * lineage.
 52503:          */
 86437:         JS_ASSERT(shape == self->lastProperty());
 86437:         self->removeLastProperty(cx);
 64259:     }
 64259: 
 93703:     self->checkShapeConsistency();
 52503:     return true;
 52503: }
 52503: 
 30733: void
 52503: JSObject::clear(JSContext *cx)
 52503: {
 83231:     Shape *shape = lastProperty();
 52503:     JS_ASSERT(inDictionaryMode() == shape->inDictionary());
 52503: 
 52503:     while (shape->parent) {
 52503:         shape = shape->parent;
 52503:         JS_ASSERT(inDictionaryMode() == shape->inDictionary());
 52503:     }
 52503:     JS_ASSERT(shape->isEmptyShape());
 52503: 
 52503:     if (inDictionaryMode())
 83231:         shape->listp = &shape_;
 52503: 
 83231:     JS_ALWAYS_TRUE(setLastProperty(cx, shape));
 52503: 
 52503:     JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
 93703:     checkShapeConsistency();
 52503: }
 52503: 
 52503: void
 84755: JSObject::rollbackProperties(JSContext *cx, uint32_t slotSpan)
 77343: {
 83245:     /*
 83245:      * Remove properties from this object until it has a matching slot span.
 83245:      * The object cannot have escaped in a way which would prevent safe
 83245:      * removal of the last properties.
 83245:      */
 83231:     JS_ASSERT(!inDictionaryMode() && slotSpan <= this->slotSpan());
 77343:     while (this->slotSpan() != slotSpan) {
 83231:         JS_ASSERT(lastProperty()->hasSlot() && getSlot(lastProperty()->slot()).isUndefined());
 83245:         removeLastProperty(cx);
 77343:     }
 77343: }
 77343: 
 86702: Shape *
 86702: JSObject::replaceWithNewEquivalentShape(JSContext *cx, Shape *oldShape, Shape *newShape)
 30258: {
 86702:     JS_ASSERT_IF(oldShape != lastProperty(),
 86702:                  inDictionaryMode() &&
 90419:                  nativeLookup(cx, oldShape->propidRef()) == oldShape);
 86437: 
 86702:     JSObject *self = this;
 86702: 
 86702:     if (!inDictionaryMode()) {
 99421:         RootedObject selfRoot(cx, self);
 99421:         RootedShape newRoot(cx, newShape);
 86702:         if (!toDictionaryMode(cx))
 86725:             return NULL;
 95355:         oldShape = self->lastProperty();
 99364:         self = selfRoot;
 99364:         newShape = newRoot;
 86702:     }
 83221: 
 83221:     if (!newShape) {
 99421:         RootedObject selfRoot(cx, self);
 99421:         RootedShape oldRoot(cx, oldShape);
 83221:         newShape = js_NewGCShape(cx);
 83221:         if (!newShape)
 86725:             return NULL;
 86702:         new (newShape) Shape(oldShape->base()->unowned(), 0);
 99364:         self = selfRoot;
 99364:         oldShape = oldRoot;
     1:     }
     1: 
 97571:     ShapeTable &table = self->lastProperty()->table();
 86702:     Shape **spp = oldShape->isEmptyShape()
 86437:                   ? NULL
 90419:                   : table.search(oldShape->propidRef(), false);
 83221: 
 86702:     /*
 86702:      * Splice the new shape into the same position as the old shape, preserving
 86702:      * enumeration order (see bug 601399).
 86702:      */
 86702:     StackShape nshape(oldShape);
 86702:     newShape->initDictionaryShape(nshape, self->numFixedSlots(), oldShape->listp);
 83221: 
 83221:     JS_ASSERT(newShape->parent == oldShape);
 86437:     oldShape->removeFromDictionary(self);
 83221: 
 95355:     if (newShape == self->lastProperty())
 83229:         oldShape->handoffTableTo(newShape);
 83221: 
 83229:     if (spp)
 83229:         SHAPE_STORE_PRESERVING_COLLISION(spp, newShape);
 86702:     return newShape;
 30258: }
 30258: 
 32658: bool
 83221: JSObject::shadowingShapeChange(JSContext *cx, const Shape &shape)
 30258: {
 83221:     return generateOwnShape(cx);
 32658: }
 83221: 
 83245: bool
 83245: JSObject::clearParent(JSContext *cx)
 83245: {
 99421:     return setParent(cx, RootedObject(cx, this), RootedObject(cx));
 32658: }
 83245: 
 97353: /* static */ bool
 97353: JSObject::setParent(JSContext *cx, HandleObject obj, HandleObject parent)
 83245: {
 83285:     if (parent && !parent->setDelegate(cx))
 83285:         return false;
 83285: 
 97353:     if (obj->inDictionaryMode()) {
 97353:         StackBaseShape base(obj->lastProperty());
 86437:         base.parent = parent;
 86163:         UnownedBaseShape *nbase = BaseShape::getUnowned(cx, base);
 86163:         if (!nbase)
 86163:             return false;
 86163: 
 97353:         obj->lastProperty()->base()->adoptUnowned(nbase);
 32658:         return true;
 30258:     }
 30258: 
 97353:     Shape *newShape = Shape::setObjectParent(cx, parent, obj->getProto(), obj->shape_);
 86437:     if (!newShape)
 86437:         return false;
 86437: 
 97353:     obj->shape_ = newShape;
 86437:     return true;
 83245: }
 83245: 
 86437: /* static */ Shape *
 86437: Shape::setObjectParent(JSContext *cx, JSObject *parent, JSObject *proto, Shape *last)
 82129: {
 86437:     if (last->getObjectParent() == parent)
 86437:         return last;
 83251: 
 86437:     StackBaseShape base(last);
 86437:     base.parent = parent;
 83245: 
 86437:     return replaceLastProperty(cx, base, proto, last);
 83245: }
 83245: 
 83248: bool
 97157: JSObject::preventExtensions(JSContext *cx)
 83248: {
 83248:     JS_ASSERT(isExtensible());
 83248: 
 99421:     RootedObject self(cx, this);
 86437: 
 97157:     /*
 97157:      * Force lazy properties to be resolved by iterating over the objects' own
 97157:      * properties.
 97157:      */
 97157:     AutoIdVector props(cx);
 97731:     if (!js::GetPropertyNames(cx, self, JSITER_HIDDEN | JSITER_OWNONLY, &props))
 83248:         return false;
 97157: 
 97731:     if (self->isDenseArray())
 97731:         self->makeDenseArraySlow(cx, self);
 83248: 
 86437:     return self->setFlag(cx, BaseShape::NOT_EXTENSIBLE, GENERATE_SHAPE);
 83248: }
 83248: 
 83248: bool
 84755: JSObject::setFlag(JSContext *cx, /*BaseShape::Flag*/ uint32_t flag_, GenerateShape generateShape)
 83248: {
 83248:     BaseShape::Flag flag = (BaseShape::Flag) flag_;
 83248: 
 83251:     if (lastProperty()->getObjectFlags() & flag)
 83251:         return true;
 83251: 
 99421:     RootedObject self(cx, this);
 86437: 
 83248:     if (inDictionaryMode()) {
 83248:         if (generateShape == GENERATE_SHAPE && !generateOwnShape(cx))
 83248:             return false;
 86437:         StackBaseShape base(self->lastProperty());
 86437:         base.flags |= flag;
 86163:         UnownedBaseShape *nbase = BaseShape::getUnowned(cx, base);
 86163:         if (!nbase)
 86163:             return false;
 86163: 
 86437:         self->lastProperty()->base()->adoptUnowned(nbase);
 83248:         return true;
 83248:     }
 83248: 
 86437:     Shape *newShape = Shape::setObjectFlag(cx, flag, getProto(), lastProperty());
 86437:     if (!newShape)
 86437:         return false;
 86437: 
 86437:     self->shape_ = newShape;
 86437:     return true;
 83248: }
 83248: 
 86437: /* static */ Shape *
 86437: Shape::setObjectFlag(JSContext *cx, BaseShape::Flag flag, JSObject *proto, Shape *last)
 83248: {
 86437:     if (last->getObjectFlags() & flag)
 86437:         return last;
 83251: 
 86437:     StackBaseShape base(last);
 83248:     base.flags |= flag;
 83248: 
 86437:     return replaceLastProperty(cx, base, proto, last);
 83248: }
 83248: 
 83221: /* static */ inline HashNumber
 86437: StackBaseShape::hash(const StackBaseShape *base)
 83221: {
 94610:     HashNumber hash = base->flags;
 91527:     hash = JS_ROTATE_LEFT32(hash, 4) ^ (uintptr_t(base->clasp) >> 3);
 91527:     hash = JS_ROTATE_LEFT32(hash, 4) ^ (uintptr_t(base->parent) >> 3);
 91527:     hash = JS_ROTATE_LEFT32(hash, 4) ^ uintptr_t(base->rawGetter);
 91527:     hash = JS_ROTATE_LEFT32(hash, 4) ^ uintptr_t(base->rawSetter);
 91527:     return hash;
 83221: }
 83221: 
 83221: /* static */ inline bool
 86437: StackBaseShape::match(UnownedBaseShape *key, const StackBaseShape *lookup)
 83221: {
 83221:     return key->flags == lookup->flags
 83221:         && key->clasp == lookup->clasp
 83245:         && key->parent == lookup->parent
 86439:         && key->rawGetter == lookup->rawGetter
 86439:         && key->rawSetter == lookup->rawSetter;
 83221: }
 83221: 
 83229: /* static */ UnownedBaseShape *
 86437: BaseShape::getUnowned(JSContext *cx, const StackBaseShape &base)
 83221: {
 83297:     BaseShapeSet &table = cx->compartment->baseShapes;
 83221: 
 83297:     if (!table.initialized() && !table.init())
 83221:         return NULL;
 83291: 
 83297:     BaseShapeSet::AddPtr p = table.lookupForAdd(&base);
 83302: 
 86321:     if (p)
 86321:         return *p;
 83291: 
 99364:     StackBaseShape::AutoRooter root(cx, &base);
 86437: 
 83297:     BaseShape *nbase_ = js_NewGCBaseShape(cx);
 83297:     if (!nbase_)
 83247:         return NULL;
 83297:     new (nbase_) BaseShape(base);
 83247: 
 83297:     UnownedBaseShape *nbase = static_cast<UnownedBaseShape *>(nbase_);
 83247: 
 83297:     if (!table.relookupOrAdd(p, &base, nbase))
 83297:         return NULL;
 83221: 
 83297:     return nbase;
 30258: }
 30258: 
 30258: void
 94738: JSCompartment::sweepBaseShapeTable()
 30258: {
 83221:     if (baseShapes.initialized()) {
 83221:         for (BaseShapeSet::Enum e(baseShapes); !e.empty(); e.popFront()) {
 83297:             UnownedBaseShape *base = e.front();
 83297:             if (!base->isMarked())
 83221:                 e.removeFront();
 83221:         }
 83221:     }
 83221: }
 83221: 
 83221: void
 94738: BaseShape::finalize(FreeOp *fop)
 83221: {
 83221:     if (table_) {
 94738:         fop->delete_(table_);
 83221:         table_ = NULL;
 83221:     }
 83221: }
 83221: 
 86437: /* static */ Shape *
 86437: Shape::setExtensibleParents(JSContext *cx, Shape *shape)
 83221: {
 83221:     JS_ASSERT(!shape->inDictionary());
 83221: 
 86437:     StackBaseShape base(shape);
 83221:     base.flags |= BaseShape::EXTENSIBLE_PARENTS;
 83221: 
 83311:     /* This is only used for Block and Call objects, which have a NULL proto. */
 86437:     return replaceLastProperty(cx, base, NULL, shape);
 30258: }
 30258: 
 40871: bool
 83221: Bindings::setExtensibleParents(JSContext *cx)
 40871: {
 83221:     if (!ensureShape(cx))
 83221:         return false;
 86437:     Shape *newShape = Shape::setExtensibleParents(cx, lastBinding);
 86437:     if (!newShape)
 86437:         return false;
 86437:     lastBinding = newShape;
 86437:     return true;
 40871: }
 83245: 
 83245: bool
 99364: Bindings::setParent(JSContext *cx, JSObject *obj_)
 83245: {
 99421:     RootedObject obj(cx, obj_);
 99364: 
 86437:     /*
 86437:      * This may be invoked on GC heap allocated bindings, in which case this
 86437:      * is pointing to an internal value of a JSScript that can't itself be
 86437:      * relocated. The script itself will be rooted, and will not be moved, so
 86437:      * mark the stack value as non-relocatable for the stack root analysis.
 86437:      */
 86437:     Bindings *self = this;
 95355:     SkipRoot root(cx, &self);
 86437: 
 83245:     if (!ensureShape(cx))
 83231:         return false;
 83311: 
 83311:     /* This is only used for Block objects, which have a NULL proto. */
 86437:     Shape *newShape = Shape::setObjectParent(cx, obj, NULL, self->lastBinding);
 86437:     if (!newShape)
 86437:         return false;
 86437:     self->lastBinding = newShape;
 86437:     return true;
 79410: }
 83297: 
 99246: inline
 99246: InitialShapeEntry::InitialShapeEntry() : shape(NULL), proto(NULL)
 99246: {
 99246: }
 99246: 
 99246: inline
 99246: InitialShapeEntry::InitialShapeEntry(const ReadBarriered<Shape> &shape, JSObject *proto)
 99246:   : shape(shape), proto(proto)
 99246: {
 99246: }
 99246: 
 99246: inline InitialShapeEntry::Lookup
 99246: InitialShapeEntry::getLookup()
 99246: {
 99246:     return Lookup(shape->getObjectClass(), proto, shape->getObjectParent(),
 99246:                   shape->numFixedSlots(), shape->getObjectFlags());
 99246: }
 99246: 
 83297: /* static */ inline HashNumber
 83297: InitialShapeEntry::hash(const Lookup &lookup)
 83297: {
 94610:     HashNumber hash = uintptr_t(lookup.clasp) >> 3;
 91527:     hash = JS_ROTATE_LEFT32(hash, 4) ^ (uintptr_t(lookup.proto) >> 3);
 91527:     hash = JS_ROTATE_LEFT32(hash, 4) ^ (uintptr_t(lookup.parent) >> 3);
 91527:     return hash + lookup.nfixed;
 83297: }
 83297: 
 83297: /* static */ inline bool
 83297: InitialShapeEntry::match(const InitialShapeEntry &key, const Lookup &lookup)
 83297: {
 83297:     return lookup.clasp == key.shape->getObjectClass()
 83297:         && lookup.proto == key.proto
 83297:         && lookup.parent == key.shape->getObjectParent()
 83308:         && lookup.nfixed == key.shape->numFixedSlots()
 83308:         && lookup.baseFlags == key.shape->getObjectFlags();
 83297: }
 83297: 
 83297: /* static */ Shape *
 83316: EmptyShape::getInitialShape(JSContext *cx, Class *clasp, JSObject *proto, JSObject *parent,
 84755:                             AllocKind kind, uint32_t objectFlags)
 83297: {
 83297:     InitialShapeSet &table = cx->compartment->initialShapes;
 83297: 
 83297:     if (!table.initialized() && !table.init())
 83297:         return NULL;
 83297: 
 83297:     size_t nfixed = GetGCKindSlots(kind, clasp);
 83308:     InitialShapeEntry::Lookup lookup(clasp, proto, parent, nfixed, objectFlags);
 83297: 
 83297:     InitialShapeSet::AddPtr p = table.lookupForAdd(lookup);
 83302: 
 86321:     if (p)
 86321:         return p->shape;
 83297: 
 99421:     RootedObject protoRoot(cx, lookup.proto);
 99421:     RootedObject parentRoot(cx, lookup.parent);
 95355: 
 99421:     Rooted<UnownedBaseShape*> nbase(cx);
 86437: 
 86437:     StackBaseShape base(clasp, parent, objectFlags);
 86437:     nbase = BaseShape::getUnowned(cx, base);
 83297:     if (!nbase)
 83297:         return NULL;
 83297: 
 98835:     Shape *shape = cx->propertyTree().newShape(cx);
 83297:     if (!shape)
 83297:         return NULL;
 83297:     new (shape) EmptyShape(nbase, nfixed);
 83297: 
 99364:     lookup.proto = protoRoot;
 99364:     lookup.parent = parentRoot;
 99364: 
 99246:     if (!table.relookupOrAdd(p, lookup, InitialShapeEntry(shape, lookup.proto)))
 83297:         return NULL;
 83297: 
 83297:     return shape;
 83297: }
 83297: 
 83300: void
 83300: NewObjectCache::invalidateEntriesForShape(JSContext *cx, Shape *shape, JSObject *proto)
 83300: {
 83300:     Class *clasp = shape->getObjectClass();
 83300: 
 83300:     gc::AllocKind kind = gc::GetGCObjectKind(shape->numFixedSlots());
 83300:     if (CanBeFinalizedInBackground(kind, clasp))
 83300:         kind = GetBackgroundAllocKind(kind);
 83300: 
 86483:     GlobalObject *global = &shape->getObjectParent()->global();
 83300:     types::TypeObject *type = proto->getNewType(cx);
 83300: 
 83313:     EntryIndex entry;
 83313:     if (lookupGlobal(clasp, global, kind, &entry))
 83313:         PodZero(&entries[entry]);
 83313:     if (!proto->isGlobal() && lookupProto(clasp, proto, kind, &entry))
 83313:         PodZero(&entries[entry]);
 83313:     if (lookupType(clasp, type, kind, &entry))
 83313:         PodZero(&entries[entry]);
 83300: }
 83300: 
 83297: /* static */ void
 83297: EmptyShape::insertInitialShape(JSContext *cx, Shape *shape, JSObject *proto)
 83297: {
 83297:     InitialShapeEntry::Lookup lookup(shape->getObjectClass(), proto, shape->getObjectParent(),
 83308:                                      shape->numFixedSlots(), shape->getObjectFlags());
 83297: 
 83297:     InitialShapeSet::Ptr p = cx->compartment->initialShapes.lookup(lookup);
 83297:     JS_ASSERT(p);
 83297: 
 83297:     InitialShapeEntry &entry = const_cast<InitialShapeEntry &>(*p);
 83300:     JS_ASSERT(entry.shape->isEmptyShape());
 83299: 
 83299:     /* The new shape had better be rooted at the old one. */
 83299: #ifdef DEBUG
 83299:     const Shape *nshape = shape;
 83299:     while (!nshape->isEmptyShape())
 83299:         nshape = nshape->previous();
 83299:     JS_ASSERT(nshape == entry.shape);
 83299: #endif
 83299: 
 83297:     entry.shape = shape;
 83299: 
 83299:     /*
 83299:      * This affects the shape that will be produced by the various NewObject
 83299:      * methods, so clear any cache entry referring to the old shape. This is
 83300:      * not required for correctness (though it may bust on the above asserts):
 83300:      * the NewObject must always check for a nativeEmpty() result and generate
 83300:      * the appropriate properties if found. Clearing the cache entry avoids
 83300:      * this duplicate regeneration.
 83299:      */
 97465:     cx->runtime->newObjectCache.invalidateEntriesForShape(cx, shape, proto);
 83297: }
 83297: 
 83297: void
 94738: JSCompartment::sweepInitialShapeTable()
 83297: {
 83297:     if (initialShapes.initialized()) {
 83297:         for (InitialShapeSet::Enum e(initialShapes); !e.empty(); e.popFront()) {
 83297:             const InitialShapeEntry &entry = e.front();
 99246:             Shape *shape = entry.shape;
 99246:             JSObject *proto = entry.proto;
 99246:             if (!IsShapeMarked(&shape) || (proto && !IsObjectMarked(&proto))) {
 83297:                 e.removeFront();
 99246:             } else {
 99246:                 JSObject *parent = shape->getObjectParent();
 99246:                 JS_ASSERT(!parent || IsObjectMarked(&parent));
 99246:                 JS_ASSERT(parent == shape->getObjectParent());
 99246:                 InitialShapeEntry newKey(shape, proto);
 99246:                 e.rekeyFront(newKey.getLookup(), newKey);
 83297:             }
 83297:         }
 83297:     }
 99246: }
