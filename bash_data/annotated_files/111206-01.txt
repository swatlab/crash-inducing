 89745: /* -*- Mode: C++; tab-width: 6; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 78065:  * vim: set ts=8 sw=4 et tw=78:
 78065:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 78065: 
 86483: #include "jscompartment.h"
 86483: #include "jsiter.h"
 86483: #include "jsscope.h"
 86483: 
 86483: #include "GlobalObject.h"
 86483: #include "ScopeObject.h"
 94006: #include "Xdr.h"
 86483: 
 86483: #include "jsatominlines.h"
 78065: #include "jsobjinlines.h"
 78065: 
 86483: #include "ScopeObject-inl.h"
 78065: 
 86483: using namespace js;
 86483: using namespace js::types;
 78065: 
 98921: /*****************************************************************************/
 98921: 
104378: StaticScopeIter::StaticScopeIter(JSObject *obj)
104378:   : obj(obj), onNamedLambda(false)
104378: {
104378:     JS_ASSERT_IF(obj, obj->isStaticBlock() || obj->isFunction());
104378: }
104378: 
104378: bool
104378: StaticScopeIter::done() const
104378: {
104378:     return obj == NULL;
104378: }
104378: 
104378: void
104378: StaticScopeIter::operator++(int)
104378: {
104378:     if (obj->isStaticBlock()) {
104378:         obj = obj->asStaticBlock().enclosingStaticScope();
104378:     } else if (onNamedLambda || !obj->toFunction()->isNamedLambda()) {
104378:         onNamedLambda = false;
104378:         obj = obj->toFunction()->script()->enclosingStaticScope();
104378:     } else {
104378:         onNamedLambda = true;
104378:     }
104378:     JS_ASSERT_IF(obj, obj->isStaticBlock() || obj->isFunction());
104378:     JS_ASSERT_IF(onNamedLambda, obj->isFunction());
104378: }
104378: 
104378: bool
104378: StaticScopeIter::hasDynamicScopeObject() const
104378: {
104378:     return obj->isStaticBlock()
104378:            ? obj->asStaticBlock().needsClone()
104378:            : obj->toFunction()->isHeavyweight();
104378: }
104378: 
105527: Shape *
105527: StaticScopeIter::scopeShape() const
105527: {
105527:     JS_ASSERT(hasDynamicScopeObject());
105527:     JS_ASSERT(type() != NAMED_LAMBDA);
108509:     return type() == BLOCK ? block().lastProperty() : funScript()->bindings.callObjShape();
105527: }
105527: 
104378: StaticScopeIter::Type
104378: StaticScopeIter::type() const
104378: {
104378:     if (onNamedLambda)
104378:         return NAMED_LAMBDA;
104378:     return obj->isStaticBlock() ? BLOCK : FUNCTION;
104378: }
104378: 
104378: StaticBlockObject &
104378: StaticScopeIter::block() const
104378: {
104378:     JS_ASSERT(type() == BLOCK);
104378:     return obj->asStaticBlock();
104378: }
104378: 
104378: JSScript *
104378: StaticScopeIter::funScript() const
104378: {
104378:     JS_ASSERT(type() == FUNCTION);
104378:     return obj->toFunction()->script();
104378: }
104378: 
104378: /*****************************************************************************/
104378: 
105527: StaticScopeIter
105527: js::ScopeCoordinateToStaticScope(JSScript *script, jsbytecode *pc)
104333: {
105527:     JS_ASSERT(pc >= script->code && pc < script->code + script->length);
105527:     JS_ASSERT(JOF_OPTYPE(*pc) == JOF_SCOPECOORD);
101074: 
101074:     uint32_t blockIndex = GET_UINT32_INDEX(pc + 2 * sizeof(uint16_t));
105527:     JSObject *innermostStaticScope;
101074:     if (blockIndex == UINT32_MAX)
105527:         innermostStaticScope = script->function();
105527:     else
105527:         innermostStaticScope = &script->getObject(blockIndex)->asStaticBlock();
101074: 
105527:     StaticScopeIter ssi(innermostStaticScope);
105527:     ScopeCoordinate sc(pc);
101074:     while (true) {
105527:         if (ssi.hasDynamicScopeObject()) {
105527:             if (!sc.hops)
101074:                 break;
105527:             sc.hops--;
101074:         }
105527:         ssi++;
105527:     }
105527:     return ssi;
101074: }
101074: 
101074: PropertyName *
101075: js::ScopeCoordinateName(JSRuntime *rt, JSScript *script, jsbytecode *pc)
101074: {
105527:     Shape::Range r = ScopeCoordinateToStaticScope(script, pc).scopeShape()->all();
101074:     ScopeCoordinate sc(pc);
103284:     while (r.front().slot() != sc.slot)
101074:         r.popFront();
101075:     jsid id = r.front().propid();
105527: 
101075:     /* Beware nameless destructuring formal. */
101075:     if (!JSID_IS_ATOM(id))
101075:         return rt->atomState.emptyAtom;
101075:     return JSID_TO_ATOM(id)->asPropertyName();
101074: }
101074: 
101074: /*****************************************************************************/
101074: 
 78065: /*
 78065:  * Construct a call object for the given bindings.  If this is a call object
 78065:  * for a function invocation, callee should be the function being called.
 78065:  * Otherwise it must be a call object for eval of strict mode code, and callee
 78065:  * must be null.
 78065:  */
 78065: CallObject *
101075: CallObject::create(JSContext *cx, JSScript *script, HandleObject enclosing, HandleFunction callee)
 78065: {
108509:     RootedShape shape(cx, script->bindings.callObjShape());
 89745: 
101075:     gc::AllocKind kind = gc::GetGCObjectKind(shape->numFixedSlots());
101075:     JS_ASSERT(CanBeFinalizedInBackground(kind, &CallClass));
101075:     kind = gc::GetBackgroundAllocKind(kind);
 78065: 
103990:     RootedTypeObject type(cx, cx->compartment->getEmptyType(cx));
 83275:     if (!type)
 83275:         return NULL;
 83275: 
 91146:     HeapSlot *slots;
 89745:     if (!PreallocateObjectDynamicSlots(cx, shape, &slots))
 83275:         return NULL;
 78065: 
 99421:     RootedObject obj(cx, JSObject::create(cx, kind, shape, type, slots));
 78065:     if (!obj)
 78065:         return NULL;
 78065: 
104376:     JS_ASSERT(enclosing->global() == obj->global());
 86483:     if (!obj->asScope().setEnclosingScope(cx, enclosing))
 86483:         return NULL;
 83275: 
 86483:     obj->initFixedSlot(CALLEE_SLOT, ObjectOrNullValue(callee));
 83275: 
 86483:     return &obj->asCall();
 78065: }
 78065: 
 91175: CallObject *
 91175: CallObject::createForFunction(JSContext *cx, StackFrame *fp)
 91175: {
 91175:     JS_ASSERT(fp->isNonEvalFunctionFrame());
109256:     assertSameCompartment(cx, fp);
 91175: 
 99421:     RootedObject scopeChain(cx, fp->scopeChain());
 91175: 
 91175:     /*
 91175:      * For a named function expression Call's parent points to an environment
 91175:      * object holding function's name.
 91175:      */
104378:     if (fp->fun()->isNamedLambda()) {
 91175:         scopeChain = DeclEnvObject::create(cx, fp);
 91175:         if (!scopeChain)
 91175:             return NULL;
 91175:     }
 91175: 
101995:     RootedScript script(cx, fp->script());
102586:     Rooted<JSFunction*> callee(cx, &fp->callee());
102586:     CallObject *callobj = create(cx, script, scopeChain, callee);
 91175:     if (!callobj)
 91175:         return NULL;
 91175: 
101075:     /* Copy in the closed-over formal arguments. */
108509:     for (AliasedFormalIter i(script); i; i++)
108509:         callobj->setAliasedVar(i, fp->unaliasedFormal(i.frameIndex(), DONT_CHECK_ALIASING));
101075: 
 91175:     return callobj;
 91175: }
 91175: 
 91175: CallObject *
 91175: CallObject::createForStrictEval(JSContext *cx, StackFrame *fp)
 91175: {
101075:     JS_ASSERT(fp->isStrictEvalFrame());
101075:     JS_ASSERT(cx->fp() == fp);
101075:     JS_ASSERT(cx->regs().pc == fp->script()->code);
 91175: 
102586:     Rooted<JSFunction*> callee(cx, NULL);
102586:     return create(cx, fp->script(), fp->scopeChain(), callee);
 91175: }
 91175: 
 91175: JS_PUBLIC_DATA(Class) js::CallClass = {
 91175:     "Call",
101075:     JSCLASS_IS_ANONYMOUS | JSCLASS_HAS_RESERVED_SLOTS(CallObject::RESERVED_SLOTS),
 91175:     JS_PropertyStub,         /* addProperty */
 91175:     JS_PropertyStub,         /* delProperty */
 91175:     JS_PropertyStub,         /* getProperty */
 91175:     JS_StrictPropertyStub,   /* setProperty */
 91175:     JS_EnumerateStub,
 95100:     JS_ResolveStub,
101075:     NULL                     /* convert: Leave it NULL so we notice if calls ever escape */
 91175: };
 91175: 
 86483: Class js::DeclEnvClass = {
 86483:     js_Object_str,
 86483:     JSCLASS_HAS_PRIVATE |
 86483:     JSCLASS_HAS_RESERVED_SLOTS(DeclEnvObject::RESERVED_SLOTS) |
 86483:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
 86483:     JS_PropertyStub,         /* addProperty */
 86483:     JS_PropertyStub,         /* delProperty */
 86483:     JS_PropertyStub,         /* getProperty */
 86483:     JS_StrictPropertyStub,   /* setProperty */
 86483:     JS_EnumerateStub,
 86483:     JS_ResolveStub,
 86483:     JS_ConvertStub
 86483: };
 86483: 
 86483: DeclEnvObject *
 86483: DeclEnvObject::create(JSContext *cx, StackFrame *fp)
 86483: {
109256:     assertSameCompartment(cx, fp);
109256: 
103990:     RootedTypeObject type(cx, cx->compartment->getEmptyType(cx));
 86483:     if (!type)
 86483:         return NULL;
 86483: 
 99421:     RootedShape emptyDeclEnvShape(cx);
 86483:     emptyDeclEnvShape = EmptyShape::getInitialShape(cx, &DeclEnvClass, NULL,
 96793:                                                     &fp->global(), FINALIZE_KIND);
 86483:     if (!emptyDeclEnvShape)
 86483:         return NULL;
 86483: 
 99421:     RootedObject obj(cx, JSObject::create(cx, FINALIZE_KIND, emptyDeclEnvShape, type, NULL));
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
 96793:     if (!obj->asScope().setEnclosingScope(cx, fp->scopeChain()))
 86483:         return NULL;
 86483: 
109108:     Rooted<jsid> id(cx, AtomToId(fp->fun()->atom()));
106862:     RootedValue value(cx, ObjectValue(fp->callee()));
106862:     if (!DefineNativeProperty(cx, obj, id, value, NULL, NULL,
 98921:                               JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY,
 98921:                               0, 0)) {
 98921:         return NULL;
 98921:     }
 98921: 
 86483:     return &obj->asDeclEnv();
 78065: }
 86483: 
 86483: WithObject *
 98921: WithObject::create(JSContext *cx, HandleObject proto, HandleObject enclosing, uint32_t depth)
 86483: {
103990:     RootedTypeObject type(cx, proto->getNewType(cx));
 86483:     if (!type)
 86483:         return NULL;
 86483: 
103990:     RootedShape shape(cx, EmptyShape::getInitialShape(cx, &WithClass, proto,
103990:                                                       &enclosing->global(), FINALIZE_KIND));
103990:     if (!shape)
 86483:         return NULL;
 86483: 
103990:     RootedObject obj(cx, JSObject::create(cx, FINALIZE_KIND, shape, type, NULL));
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
 86483:     if (!obj->asScope().setEnclosingScope(cx, enclosing))
 86483:         return NULL;
 86483: 
 86483:     obj->setReservedSlot(DEPTH_SLOT, PrivateUint32Value(depth));
 86483: 
108951:     JSObject *thisp = JSObject::thisObject(cx, proto);
 86483:     if (!thisp)
 86483:         return NULL;
 86483: 
 86483:     obj->setFixedSlot(THIS_SLOT, ObjectValue(*thisp));
 86483: 
 86483:     return &obj->asWith();
 86483: }
 86483: 
 86483: static JSBool
103636: with_LookupGeneric(JSContext *cx, HandleObject obj, HandleId id,
103716:                    MutableHandleObject objp, MutableHandleShape propp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::lookupGeneric(cx, actual, id, objp, propp);
 86483: }
 86483: 
 86483: static JSBool
103636: with_LookupProperty(JSContext *cx, HandleObject obj, HandlePropertyName name,
103716:                     MutableHandleObject objp, MutableHandleShape propp)
 86483: {
102586:     Rooted<jsid> id(cx, NameToId(name));
102586:     return with_LookupGeneric(cx, obj, id, objp, propp);
 86483: }
 86483: 
 86483: static JSBool
103716: with_LookupElement(JSContext *cx, HandleObject obj, uint32_t index,
103716:                    MutableHandleObject objp, MutableHandleShape propp)
 86483: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 86483:         return false;
 86483:     return with_LookupGeneric(cx, obj, id, objp, propp);
 86483: }
 86483: 
 86483: static JSBool
103636: with_LookupSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid,
103716:                    MutableHandleObject objp, MutableHandleShape propp)
 86483: {
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return with_LookupGeneric(cx, obj, id, objp, propp);
 86483: }
 86483: 
 86483: static JSBool
106862: with_GetGeneric(JSContext *cx, HandleObject obj, HandleObject receiver, HandleId id,
106862:                 MutableHandleValue vp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::getGeneric(cx, actual, actual, id, vp);
 86483: }
 86483: 
 86483: static JSBool
106862: with_GetProperty(JSContext *cx, HandleObject obj, HandleObject receiver, HandlePropertyName name,
106862:                  MutableHandleValue vp)
 86483: {
102586:     Rooted<jsid> id(cx, NameToId(name));
102586:     return with_GetGeneric(cx, obj, receiver, id, vp);
 86483: }
 86483: 
 86483: static JSBool
106862: with_GetElement(JSContext *cx, HandleObject obj, HandleObject receiver, uint32_t index,
106862:                 MutableHandleValue vp)
 86483: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 86483:         return false;
 86483:     return with_GetGeneric(cx, obj, receiver, id, vp);
 86483: }
 86483: 
 86483: static JSBool
106862: with_GetSpecial(JSContext *cx, HandleObject obj, HandleObject receiver, HandleSpecialId sid,
106862:                 MutableHandleValue vp)
 86483: {
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return with_GetGeneric(cx, obj, receiver, id, vp);
 86483: }
 86483: 
 86483: static JSBool
106862: with_SetGeneric(JSContext *cx, HandleObject obj, HandleId id,
106862:                 MutableHandleValue vp, JSBool strict)
 86483: {
103345:     Rooted<JSObject*> actual(cx, &obj->asWith().object());
108951:     return JSObject::setGeneric(cx, actual, actual, id, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
106862: with_SetProperty(JSContext *cx, HandleObject obj, HandlePropertyName name,
106862:                  MutableHandleValue vp, JSBool strict)
 86483: {
103345:     Rooted<JSObject*> actual(cx, &obj->asWith().object());
108951:     return JSObject::setProperty(cx, actual, actual, name, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
106862: with_SetElement(JSContext *cx, HandleObject obj, uint32_t index,
106862:                 MutableHandleValue vp, JSBool strict)
 86483: {
103345:     Rooted<JSObject*> actual(cx, &obj->asWith().object());
108951:     return JSObject::setElement(cx, actual, actual, index, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
106862: with_SetSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid,
106862:                 MutableHandleValue vp, JSBool strict)
 86483: {
103345:     Rooted<JSObject*> actual(cx, &obj->asWith().object());
108951:     return JSObject::setSpecial(cx, actual, actual, sid, vp, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetGenericAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::getGenericAttributes(cx, actual, id, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetPropertyAttributes(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::getPropertyAttributes(cx, actual, name, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::getElementAttributes(cx, actual, index, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_GetSpecialAttributes(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::getSpecialAttributes(cx, actual, sid, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetGenericAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::setGenericAttributes(cx, actual, id, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetPropertyAttributes(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::setPropertyAttributes(cx, actual, name, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::setElementAttributes(cx, actual, index, attrsp);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_SetSpecialAttributes(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::setSpecialAttributes(cx, actual, sid, attrsp);
 86483: }
 86483: 
 86483: static JSBool
106862: with_DeleteProperty(JSContext *cx, HandleObject obj, HandlePropertyName name,
106862:                     MutableHandleValue rval, JSBool strict)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::deleteProperty(cx, actual, name, rval, strict);
 86483: }
 86483: 
 86483: static JSBool
106862: with_DeleteElement(JSContext *cx, HandleObject obj, uint32_t index,
106862:                    MutableHandleValue rval, JSBool strict)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::deleteElement(cx, actual, index, rval, strict);
 86483: }
 86483: 
 86483: static JSBool
106862: with_DeleteSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid,
106862:                    MutableHandleValue rval, JSBool strict)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::deleteSpecial(cx, actual, sid, rval, strict);
 86483: }
 86483: 
 86483: static JSBool
 98960: with_Enumerate(JSContext *cx, HandleObject obj, JSIterateOp enum_op,
 86483:                Value *statep, jsid *idp)
 86483: {
108951:     RootedObject actual(cx, &obj->asWith().object());
108951:     return JSObject::enumerate(cx, actual, enum_op, statep, idp);
 86483: }
 86483: 
 86483: static JSType
 98960: with_TypeOf(JSContext *cx, HandleObject obj)
 86483: {
 86483:     return JSTYPE_OBJECT;
 86483: }
 86483: 
 86483: static JSObject *
 98960: with_ThisObject(JSContext *cx, HandleObject obj)
 86483: {
 86483:     return &obj->asWith().withThis();
 86483: }
 86483: 
 86483: Class js::WithClass = {
 86483:     "With",
 86483:     JSCLASS_HAS_RESERVED_SLOTS(WithObject::RESERVED_SLOTS) |
 86483:     JSCLASS_IS_ANONYMOUS,
 86483:     JS_PropertyStub,         /* addProperty */
 86483:     JS_PropertyStub,         /* delProperty */
 86483:     JS_PropertyStub,         /* getProperty */
 86483:     JS_StrictPropertyStub,   /* setProperty */
 86483:     JS_EnumerateStub,
 86483:     JS_ResolveStub,
 86483:     JS_ConvertStub,
 86483:     NULL,                    /* finalize */
 86483:     NULL,                    /* checkAccess */
 86483:     NULL,                    /* call        */
 86483:     NULL,                    /* construct   */
 86483:     NULL,                    /* hasInstance */
 86483:     NULL,                    /* trace       */
 86483:     JS_NULL_CLASS_EXT,
 86483:     {
 86483:         with_LookupGeneric,
 86483:         with_LookupProperty,
 86483:         with_LookupElement,
 86483:         with_LookupSpecial,
 86483:         NULL,             /* defineGeneric */
 86483:         NULL,             /* defineProperty */
 86483:         NULL,             /* defineElement */
 86483:         NULL,             /* defineSpecial */
 86483:         with_GetGeneric,
 86483:         with_GetProperty,
 86483:         with_GetElement,
 86483:         NULL,             /* getElementIfPresent */
 86483:         with_GetSpecial,
 86483:         with_SetGeneric,
 86483:         with_SetProperty,
 86483:         with_SetElement,
 86483:         with_SetSpecial,
 86483:         with_GetGenericAttributes,
 86483:         with_GetPropertyAttributes,
 86483:         with_GetElementAttributes,
 86483:         with_GetSpecialAttributes,
 86483:         with_SetGenericAttributes,
 86483:         with_SetPropertyAttributes,
 86483:         with_SetElementAttributes,
 86483:         with_SetSpecialAttributes,
 86483:         with_DeleteProperty,
 86483:         with_DeleteElement,
 86483:         with_DeleteSpecial,
 86483:         with_Enumerate,
 86483:         with_TypeOf,
 86483:         with_ThisObject,
 86483:     }
 86483: };
 86483: 
 98921: /*****************************************************************************/
 98921: 
 86483: ClonedBlockObject *
 97353: ClonedBlockObject::create(JSContext *cx, Handle<StaticBlockObject *> block, StackFrame *fp)
 86483: {
109256:     assertSameCompartment(cx, fp);
109256: 
103990:     RootedTypeObject type(cx, block->getNewType(cx));
 86483:     if (!type)
 86483:         return NULL;
 86483: 
 91146:     HeapSlot *slots;
 97353:     if (!PreallocateObjectDynamicSlots(cx, block->lastProperty(), &slots))
 86483:         return NULL;
 86483: 
103990:     RootedShape shape(cx, block->lastProperty());
 86483: 
 99421:     RootedObject obj(cx, JSObject::create(cx, FINALIZE_KIND, shape, type, slots));
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
 86483:     /* Set the parent if necessary, as for call objects. */
 97353:     if (&fp->global() != obj->getParent()) {
 86483:         JS_ASSERT(obj->getParent() == NULL);
102586:         Rooted<GlobalObject*> global(cx, &fp->global());
102586:         if (!JSObject::setParent(cx, obj, global))
 86483:             return NULL;
 86483:     }
 86483: 
 86483:     JS_ASSERT(!obj->inDictionaryMode());
 97353:     JS_ASSERT(obj->slotSpan() >= block->slotCount() + RESERVED_SLOTS);
 86483: 
 98921:     obj->setReservedSlot(SCOPE_CHAIN_SLOT, ObjectValue(*fp->scopeChain()));
 97353:     obj->setReservedSlot(DEPTH_SLOT, PrivateUint32Value(block->stackDepth()));
 86483: 
101075:     /*
101075:      * Copy in the closed-over locals. Closed-over locals don't need
101075:      * any fixup since the initial value is 'undefined'.
101075:      */
101075:     Value *src = fp->base() + block->stackDepth();
101075:     unsigned nslots = block->slotCount();
101075:     for (unsigned i = 0; i < nslots; ++i, ++src) {
101075:         if (block->isAliased(i))
101075:             obj->asClonedBlock().setVar(i, *src);
 86483:     }
 86483: 
101075:     return &obj->asClonedBlock();
 99991: }
100006: 
101072: void
101072: ClonedBlockObject::copyUnaliasedValues(StackFrame *fp)
101072: {
101072:     StaticBlockObject &block = staticBlock();
103284:     unsigned base = fp->script()->nfixed + block.stackDepth();
101072:     for (unsigned i = 0; i < slotCount(); ++i) {
101072:         if (!block.isAliased(i))
101075:             setVar(i, fp->unaliasedLocal(base + i), DONT_CHECK_ALIASING);
101072:     }
101072: }
101072: 
 86483: StaticBlockObject *
 86483: StaticBlockObject::create(JSContext *cx)
 86483: {
103990:     RootedTypeObject type(cx, cx->compartment->getEmptyType(cx));
 86483:     if (!type)
 86483:         return NULL;
 86483: 
103990:     RootedShape shape(cx, EmptyShape::getInitialShape(cx, &BlockClass, NULL, NULL, FINALIZE_KIND));
103990:     if (!shape)
 86483:         return NULL;
 86483: 
103990:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, shape, type, NULL);
 86483:     if (!obj)
 86483:         return NULL;
 86483: 
 86483:     return &obj->asStaticBlock();
 86483: }
 86483: 
104205: /* static */ Shape *
104205: StaticBlockObject::addVar(JSContext *cx, Handle<StaticBlockObject*> block, HandleId id,
104205:                           int index, bool *redeclared)
 86483: {
 87188:     JS_ASSERT(JSID_IS_ATOM(id) || (JSID_IS_INT(id) && JSID_TO_INT(id) == index));
 87188: 
 86483:     *redeclared = false;
 86483: 
 86483:     /* Inline JSObject::addProperty in order to trap the redefinition case. */
 86483:     Shape **spp;
104205:     if (Shape::search(cx, block->lastProperty(), id, &spp, true)) {
 86483:         *redeclared = true;
 86483:         return NULL;
 86483:     }
 86483: 
 86483:     /*
 86483:      * Don't convert this object to dictionary mode so that we can clone the
 86483:      * block's shape later.
 86483:      */
 86483:     uint32_t slot = JSSLOT_FREE(&BlockClass) + index;
104205:     return block->addPropertyInternal(cx, id, /* getter = */ NULL, /* setter = */ NULL,
 86483:                                       slot, JSPROP_ENUMERATE | JSPROP_PERMANENT,
 86483:                                       Shape::HAS_SHORTID, index, spp,
 86483:                                       /* allowDictionary = */ false);
 86483: }
 86483: 
 86483: Class js::BlockClass = {
 86483:     "Block",
101075:     JSCLASS_IMPLEMENTS_BARRIERS |
 86483:     JSCLASS_HAS_RESERVED_SLOTS(BlockObject::RESERVED_SLOTS) |
 86483:     JSCLASS_IS_ANONYMOUS,
 86483:     JS_PropertyStub,         /* addProperty */
 86483:     JS_PropertyStub,         /* delProperty */
 86483:     JS_PropertyStub,         /* getProperty */
 86483:     JS_StrictPropertyStub,   /* setProperty */
 86483:     JS_EnumerateStub,
 86483:     JS_ResolveStub,
101075:     JS_ConvertStub
 86483: };
 86483: 
 94006: template<XDRMode mode>
 86483: bool
104378: js::XDRStaticBlockObject(XDRState<mode> *xdr, HandleObject enclosingScope, HandleScript script,
104378:                          StaticBlockObject **objp)
 86483: {
 97298:     /* NB: Keep this in sync with CloneStaticBlockObject. */
 97298: 
 94006:     JSContext *cx = xdr->cx();
 86483: 
104205:     Rooted<StaticBlockObject*> obj(cx);
 87187:     uint32_t count = 0;
 87187:     uint32_t depthAndCount = 0;
104378: 
 94006:     if (mode == XDR_ENCODE) {
 86483:         obj = *objp;
 87187:         uint32_t depth = obj->stackDepth();
 87187:         JS_ASSERT(depth <= UINT16_MAX);
 87187:         count = obj->slotCount();
 87187:         JS_ASSERT(count <= UINT16_MAX);
 87187:         depthAndCount = (depth << 16) | uint16_t(count);
 86483:     }
 86483: 
 94006:     if (mode == XDR_DECODE) {
 86483:         obj = StaticBlockObject::create(cx);
 86483:         if (!obj)
 87187:             return false;
104378:         obj->initEnclosingStaticScope(enclosingScope);
 86483:         *objp = obj;
 86483:     }
 86483: 
 94006:     if (!xdr->codeUint32(&depthAndCount))
 86483:         return false;
 86483: 
 94006:     if (mode == XDR_DECODE) {
 87187:         uint32_t depth = uint16_t(depthAndCount >> 16);
 86483:         count = uint16_t(depthAndCount);
 86483:         obj->setStackDepth(depth);
 86483: 
 86483:         /*
 86483:          * XDR the block object's properties. We know that there are 'count'
 86483:          * properties to XDR, stored as id/shortid pairs.
 86483:          */
 91237:         for (unsigned i = 0; i < count; i++) {
 86483:             JSAtom *atom;
 94006:             if (!XDRAtom(xdr, &atom))
 86483:                 return false;
 86483: 
 87188:             /* The empty string indicates an int id. */
104205:             RootedId id(cx, atom != cx->runtime->emptyString
 97828:                             ? AtomToId(atom)
104205:                             : INT_TO_JSID(i));
 87188: 
 86483:             bool redeclared;
104205:             if (!StaticBlockObject::addVar(cx, obj, id, i, &redeclared)) {
 86483:                 JS_ASSERT(!redeclared);
 86483:                 return false;
 86483:             }
 95099: 
 95099:             uint32_t aliased;
 95099:             if (!xdr->codeUint32(&aliased))
 95099:                 return false;
 95099: 
 95099:             JS_ASSERT(aliased == 0 || aliased == 1);
 95099:             obj->setAliased(i, !!aliased);
 86483:         }
 86483:     } else {
 86483:         AutoShapeVector shapes(cx);
 97298:         if (!shapes.growBy(count))
 97298:             return false;
 86483: 
 86483:         for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
103639:             Shape *shape = &r.front();
 86483:             shapes[shape->shortid()] = shape;
 86483:         }
 86483: 
 86483:         /*
 86483:          * XDR the block object's properties. We know that there are 'count'
 86483:          * properties to XDR, stored as id/shortid pairs.
 86483:          */
 91237:         for (unsigned i = 0; i < count; i++) {
103639:             Shape *shape = shapes[i];
101075:             JS_ASSERT(shape->hasDefaultGetter());
 91237:             JS_ASSERT(unsigned(shape->shortid()) == i);
 86483: 
 86483:             jsid propid = shape->propid();
 87188:             JS_ASSERT(JSID_IS_ATOM(propid) || JSID_IS_INT(propid));
 86483: 
 87188:             /* The empty string indicates an int id. */
 87188:             JSAtom *atom = JSID_IS_ATOM(propid)
 87188:                            ? JSID_TO_ATOM(propid)
 87188:                            : cx->runtime->emptyString;
 87188: 
 94006:             if (!XDRAtom(xdr, &atom))
 86483:                 return false;
 95099: 
 95099:             uint32_t aliased = obj->isAliased(i);
 95099:             if (!xdr->codeUint32(&aliased))
 95099:                 return false;
 86483:         }
 86483:     }
 86483:     return true;
 86483: }
 86483: 
 94006: template bool
104378: js::XDRStaticBlockObject(XDRState<XDR_ENCODE> *, HandleObject, HandleScript, StaticBlockObject **);
 94006: 
 94006: template bool
104378: js::XDRStaticBlockObject(XDRState<XDR_DECODE> *, HandleObject, HandleScript, StaticBlockObject **);
 97298: 
 97298: JSObject *
104378: js::CloneStaticBlockObject(JSContext *cx, HandleObject enclosingScope, Handle<StaticBlockObject*> srcBlock)
 97298: {
 97298:     /* NB: Keep this in sync with XDRStaticBlockObject. */
 97298: 
104205:     Rooted<StaticBlockObject*> clone(cx, StaticBlockObject::create(cx));
 97298:     if (!clone)
 97545:         return NULL;
 97298: 
104378:     clone->initEnclosingStaticScope(enclosingScope);
104205:     clone->setStackDepth(srcBlock->stackDepth());
 97298: 
 97298:     /* Shape::Range is reverse order, so build a list in forward order. */
 97298:     AutoShapeVector shapes(cx);
104205:     if (!shapes.growBy(srcBlock->slotCount()))
 97545:         return NULL;
104205:     for (Shape::Range r = srcBlock->lastProperty()->all(); !r.empty(); r.popFront())
 97298:         shapes[r.front().shortid()] = &r.front();
 97298: 
103639:     for (Shape **p = shapes.begin(); p != shapes.end(); ++p) {
104205:         RootedId id(cx, (*p)->propid());
 97298:         unsigned i = (*p)->shortid();
 97298: 
 97298:         bool redeclared;
104205:         if (!StaticBlockObject::addVar(cx, clone, id, i, &redeclared)) {
 97298:             JS_ASSERT(!redeclared);
 97545:             return NULL;
 97298:         }
 97298: 
104205:         clone->setAliased(i, srcBlock->isAliased(i));
 97298:     }
 97298: 
 97298:     return clone;
 97298: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
101995: ScopeIter::ScopeIter(JSContext *cx
101995:                      JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 98921:   : fp_(NULL),
101995:     cur_(cx, reinterpret_cast<JSObject *>(-1)),
101995:     block_(cx, reinterpret_cast<StaticBlockObject *>(-1)),
 98921:     type_(Type(-1))
101995: {
101995:     JS_GUARD_OBJECT_NOTIFIER_INIT;
101995: }
 98921: 
101995: ScopeIter::ScopeIter(const ScopeIter &si, JSContext *cx
101995:                      JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
101995:   : fp_(si.fp_),
101995:     cur_(cx, si.cur_),
101995:     block_(cx, si.block_),
101995:     type_(si.type_),
101995:     hasScopeObject_(si.hasScopeObject_)
101995: {
101995:     JS_GUARD_OBJECT_NOTIFIER_INIT;
101995: }
101995: 
101995: ScopeIter::ScopeIter(JSObject &enclosingScope, JSContext *cx
101995:                      JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 98921:   : fp_(NULL),
101995:     cur_(cx, &enclosingScope),
101995:     block_(cx, reinterpret_cast<StaticBlockObject *>(-1)),
 98921:     type_(Type(-1))
101995: {
101995:     JS_GUARD_OBJECT_NOTIFIER_INIT;
101995: }
 98921: 
101995: ScopeIter::ScopeIter(StackFrame *fp, JSContext *cx
101995:                      JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 98921:   : fp_(fp),
101995:     cur_(cx, fp->scopeChain()),
101995:     block_(cx, fp->maybeBlockChain())
 98921: {
109256:     assertSameCompartment(cx, fp);
 98921:     settle();
101995:     JS_GUARD_OBJECT_NOTIFIER_INIT;
 98921: }
 98921: 
101995: ScopeIter::ScopeIter(const ScopeIter &si, StackFrame *fp, JSContext *cx
101995:                      JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 98921:   : fp_(fp),
101995:     cur_(cx, si.cur_),
101995:     block_(cx, si.block_),
 98921:     type_(si.type_),
 98921:     hasScopeObject_(si.hasScopeObject_)
101995: {
101995:     JS_GUARD_OBJECT_NOTIFIER_INIT;
101995: }
 98921: 
101995: ScopeIter::ScopeIter(StackFrame *fp, ScopeObject &scope, JSContext *cx
101995:                      JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 98921:   : fp_(fp),
101995:     cur_(cx, &scope),
101995:     block_(cx)
 98921: {
 98921:     /*
 98921:      * Find the appropriate static block for this iterator, given 'scope'. We
 98921:      * know that 'scope' is a (non-optimized) scope on fp's scope chain. We do
 98921:      * not, however, know whether fp->maybeScopeChain() encloses 'scope'. E.g.:
 98921:      *
 98921:      *   let (x = 1) {
 98921:      *     g = function() { eval('debugger') };
 98921:      *     let (y = 1) g();
 98921:      *   }
 98921:      *
 98921:      * g will have x's block in its enclosing scope but not y's. However, at
 98921:      * the debugger statement, both the x's and y's blocks will be on
 98921:      * fp->blockChain. Fortunately, we can compare scope object stack depths to
 98921:      * determine the block (if any) that encloses 'scope'.
 98921:      */
 98921:     if (cur_->isNestedScope()) {
 98921:         block_ = fp->maybeBlockChain();
 98921:         while (block_) {
 98921:             if (block_->stackDepth() <= cur_->asNestedScope().stackDepth())
 98921:                 break;
 98921:             block_ = block_->enclosingBlock();
 98921:         }
 98921:         JS_ASSERT_IF(cur_->isClonedBlock(), cur_->asClonedBlock().staticBlock() == *block_);
 98921:     } else {
 98921:         block_ = NULL;
 98921:     }
 98921:     settle();
101995:     JS_GUARD_OBJECT_NOTIFIER_INIT;
 98921: }
 98921: 
 98921: ScopeObject &
 98921: ScopeIter::scope() const
 98921: {
 98921:     JS_ASSERT(hasScopeObject());
 98921:     return cur_->asScope();
 98921: }
 98921: 
101995: ScopeIter &
101995: ScopeIter::operator++()
 98921: {
 98921:     JS_ASSERT(!done());
 98921:     switch (type_) {
 98921:       case Call:
 98921:         if (hasScopeObject_) {
101995:             cur_ = &cur_->asCall().enclosingScope();
103492:             if (CallObjectLambdaName(*fp_->fun()))
101995:                 cur_ = &cur_->asDeclEnv().enclosingScope();
 98921:         }
101995:         fp_ = NULL;
 98921:         break;
 98921:       case Block:
101995:         block_ = block_->enclosingBlock();
 98921:         if (hasScopeObject_)
101995:             cur_ = &cur_->asClonedBlock().enclosingScope();
101995:         settle();
 98921:         break;
 98921:       case With:
 98921:         JS_ASSERT(hasScopeObject_);
101995:         cur_ = &cur_->asWith().enclosingScope();
101995:         settle();
 98921:         break;
 98921:       case StrictEvalScope:
 98921:         if (hasScopeObject_)
101995:             cur_ = &cur_->asCall().enclosingScope();
101995:         fp_ = NULL;
 98921:         break;
 98921:     }
101995:     return *this;
 98921: }
 98921: 
 98921: void
 98921: ScopeIter::settle()
 98921: {
 98921:     /*
 98921:      * Given an iterator state (cur_, block_), figure out which (potentially
 98921:      * optimized) scope the iterator should report. Thus, the result is a pair
 98921:      * (type_, hasScopeObject_) where hasScopeObject_ indicates whether the
 98921:      * scope object has been optimized away and does not exist on the scope
 98921:      * chain. Beware: while ScopeIter iterates over the scopes of a single
 98921:      * frame, the scope chain (pointed to by cur_) continues into the scopes of
 98921:      * enclosing frames. Thus, it is important not to look at cur_ until it is
 98921:      * certain that cur_ points to a scope object in the current frame. In
 99462:      * particular, there are three tricky corner cases:
 99462:      *  - non-heavyweight functions;
 98921:      *  - non-strict direct eval.
 99462:      *  - heavyweight functions observed before the prologue has finished;
 99462:      * In all cases, cur_ can already be pointing into an enclosing frame's
 99462:      * scope chain. Furthermore, in the first two cases: even if cur_ points
 99462:      * into an enclosing frame's scope chain, the current frame may still have
 99462:      * uncloned blocks. In the last case, since we haven't entered the
 99462:      * function, we simply return a ScopeIter where done() == true.
 98921:      *
 98921:      * Note: DebugScopeObject falls nicely into this plan: since they are only
 98921:      * ever introduced as the *enclosing* scope of a frame, they should never
 98921:      * show up in scope iteration and fall into the final non-scope case.
 98921:      */
 98921:     if (fp_->isNonEvalFunctionFrame() && !fp_->fun()->isHeavyweight()) {
 98921:         if (block_) {
 98921:             type_ = Block;
 98921:             hasScopeObject_ = block_->needsClone();
 98921:         } else {
 98921:             type_ = Call;
 98921:             hasScopeObject_ = false;
 98921:         }
 98921:     } else if (fp_->isNonStrictDirectEvalFrame() && cur_ == fp_->prev()->scopeChain()) {
 98921:         if (block_) {
 98921:             JS_ASSERT(!block_->needsClone());
 98921:             type_ = Block;
 98921:             hasScopeObject_ = false;
 98921:         } else {
 98921:             fp_ = NULL;
 98921:         }
100006:     } else if (fp_->isNonEvalFunctionFrame() && !fp_->hasCallObj()) {
 99462:         JS_ASSERT(cur_ == fp_->fun()->environment());
 99462:         fp_ = NULL;
101075:     } else if (fp_->isStrictEvalFrame() && !fp_->hasCallObj()) {
101075:         JS_ASSERT(cur_ == fp_->prev()->scopeChain());
101075:         fp_ = NULL;
 98921:     } else if (cur_->isWith()) {
 98921:         JS_ASSERT_IF(fp_->isFunctionFrame(), fp_->fun()->isHeavyweight());
 98921:         JS_ASSERT_IF(block_, block_->needsClone());
 98921:         JS_ASSERT_IF(block_, block_->stackDepth() < cur_->asWith().stackDepth());
 98921:         type_ = With;
 98921:         hasScopeObject_ = true;
 98921:     } else if (block_) {
 98921:         type_ = Block;
 98921:         hasScopeObject_ = block_->needsClone();
 98921:         JS_ASSERT_IF(hasScopeObject_, cur_->asClonedBlock().staticBlock() == *block_);
 98921:     } else if (cur_->isCall()) {
 98921:         CallObject &callobj = cur_->asCall();
 98921:         type_ = callobj.isForEval() ? StrictEvalScope : Call;
 98921:         hasScopeObject_ = true;
103492:         JS_ASSERT_IF(type_ == Call, callobj.callee().script() == fp_->script());
 98921:     } else {
 98921:         JS_ASSERT(!cur_->isScope());
 98921:         JS_ASSERT(fp_->isGlobalFrame() || fp_->isDebuggerFrame());
 98921:         fp_ = NULL;
 98921:     }
 98921: }
 98921: 
 98921: /* static */ HashNumber
101995: ScopeIterKey::hash(ScopeIterKey si)
 98921: {
 98921:     /* hasScopeObject_ is determined by the other fields. */
 98921:     return size_t(si.fp_) ^ size_t(si.cur_) ^ size_t(si.block_) ^ si.type_;
 98921: }
 98921: 
 98921: /* static */ bool
101995: ScopeIterKey::match(ScopeIterKey si1, ScopeIterKey si2)
 98921: {
 98921:     /* hasScopeObject_ is determined by the other fields. */
 98921:     return si1.fp_ == si2.fp_ &&
 98921:            (!si1.fp_ ||
 98921:             (si1.cur_   == si2.cur_   &&
 98921:              si1.block_ == si2.block_ &&
 98921:              si1.type_  == si2.type_));
 98921: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: namespace js {
 98921: 
 98921: /*
108507:  * DebugScopeProxy is the handler for DebugScopeObject proxy objects. Having a
108507:  * custom handler (rather than trying to reuse js::Wrapper) gives us several
108507:  * important abilities:
 98921:  *  - We want to pass the ScopeObject as the receiver to forwarded scope
108507:  *    property ops on aliased variables so that Call/Block/With ops do not all
108507:  *    require a 'normalization' step.
101072:  *  - The debug scope proxy can directly manipulate the stack frame to allow
101072:  *    the debugger to read/write args/locals that were otherwise unaliased.
108507:  *  - The debug scope proxy can store unaliased variables after the stack frame
108507:  *    is popped so that they may still be read/written by the debugger.
 98921:  *  - The engine has made certain assumptions about the possible reads/writes
 98921:  *    in a scope. DebugScopeProxy allows us to prevent the debugger from
108507:  *    breaking those assumptions.
 98921:  *  - The engine makes optimizations that are observable to the debugger. The
 98921:  *    proxy can either hide these optimizations or make the situation more
 98921:  *    clear to the debugger. An example is 'arguments'.
 98921:  */
 98922: class DebugScopeProxy : public BaseProxyHandler
 98921: {
101072:     enum Action { SET, GET };
101072: 
101072:     /*
108507:      * This function handles access to unaliased locals/formals. Since they are
108507:      * unaliased, the values of these variables are not stored in the slots of
108507:      * the normal Call/BlockObject scope objects and thus must be recovered
108507:      * from somewhere else:
108507:      *  + if the invocation for which the scope was created is still executing,
108507:      *    there is a StackFrame (either live on the stack or floating in a
108507:      *    generator object) holding the values;
108507:      *  + if the invocation for which the scope was created finished executing:
108507:      *     - and there was a DebugScopeObject associated with scope, then the
108507:      *       DebugScopes::onPop(Call|Block) handler copied out the unaliased
108507:      *       variables:
108507:      *        . for block scopes, the unaliased values were copied directly
108507:      *          into the block object, since there is a slot allocated for every
108507:      *          block binding, regardless of whether it is aliased;
108507:      *        . for function scopes, a dense array is created in onPopCall to hold
108507:      *          the unaliased values and attached to the DebugScopeObject;
108507:      *     - and there was not a DebugScopeObject yet associated with the
108507:      *       scope, then the unaliased values are lost and not recoverable.
101072:      *
101072:      * handleUnaliasedAccess returns 'true' if the access was unaliased and
101072:      * completed by handleUnaliasedAccess.
101072:      */
108507:     bool handleUnaliasedAccess(JSContext *cx, Handle<DebugScopeObject*> debugScope, Handle<ScopeObject*> scope,
108507:                                jsid id, Action action, Value *vp)
101072:     {
108507:         JS_ASSERT(&debugScope->scope() == scope);
104205:         StackFrame *maybefp = cx->runtime->debugScopes->hasLiveFrame(*scope);
101072: 
108508:         /* Handle unaliased formals, vars, and consts at function scope. */
104205:         if (scope->isCall() && !scope->asCall().isForEval()) {
104205:             CallObject &callobj = scope->asCall();
103492:             JSScript *script = callobj.callee().script();
101072:             if (!script->ensureHasTypes(cx))
101072:                 return false;
101072: 
105581:             Bindings &bindings = script->bindings;
108509:             BindingIter bi(script->bindings);
111206:             while (bi && NameToId(bi->name()) != id)
111206:                 bi++;
111206:             if (!bi)
108508:                 return false;
105581: 
108509:             if (bi->kind() == VARIABLE || bi->kind() == CONSTANT) {
108508:                 unsigned i = bi.frameIndex();
101072:                 if (script->varIsAliased(i))
101072:                     return false;
101072: 
101072:                 if (maybefp) {
101072:                     if (action == GET)
101075:                         *vp = maybefp->unaliasedVar(i);
101072:                     else
101075:                         maybefp->unaliasedVar(i) = *vp;
108507:                 } else if (JSObject *snapshot = debugScope->maybeSnapshot()) {
108507:                     if (action == GET)
108507:                         *vp = snapshot->getDenseArrayElement(bindings.numArgs() + i);
108507:                     else
108507:                         snapshot->setDenseArrayElement(bindings.numArgs() + i, *vp);
101072:                 } else {
108507:                     /* The unaliased value has been lost to the debugger. */
101072:                     if (action == GET)
108507:                         *vp = UndefinedValue();
101072:                 }
101072: 
101072:                 if (action == SET)
101072:                     TypeScript::SetLocal(cx, script, i, *vp);
101072: 
108508:             } else {
108509:                 JS_ASSERT(bi->kind() == ARGUMENT);
108508:                 unsigned i = bi.frameIndex();
108509:                 if (script->formalIsAliased(i))
101072:                     return false;
101072: 
101072:                 if (maybefp) {
102445:                     if (script->argsObjAliasesFormals() && maybefp->hasArgsObj()) {
101072:                         if (action == GET)
101075:                             *vp = maybefp->argsObj().arg(i);
101072:                         else
101075:                             maybefp->argsObj().setArg(i, *vp);
101072:                     } else {
101072:                         if (action == GET)
102445:                             *vp = maybefp->unaliasedFormal(i, DONT_CHECK_ALIASING);
101072:                         else
102445:                             maybefp->unaliasedFormal(i, DONT_CHECK_ALIASING) = *vp;
101075:                     }
108507:                 } else if (JSObject *snapshot = debugScope->maybeSnapshot()) {
108507:                     if (action == GET)
108507:                         *vp = snapshot->getDenseArrayElement(i);
108507:                     else
108507:                         snapshot->setDenseArrayElement(i, *vp);
101075:                 } else {
108507:                     /* The unaliased value has been lost to the debugger. */
101075:                     if (action == GET)
108507:                         *vp = UndefinedValue();
101072:                 }
101072: 
101072:                 if (action == SET)
101072:                     TypeScript::SetArgument(cx, script, i, *vp);
108508:             }
101072: 
101072:             return true;
101072:         }
101072: 
108508:         /* Handle unaliased let and catch bindings at block scope. */
104205:         if (scope->isClonedBlock()) {
104205:             ClonedBlockObject &block = scope->asClonedBlock();
108508:             Shape *shape = block.lastProperty()->search(cx, id);
108508:             if (!shape)
108508:                 return false;
108508: 
101072:             unsigned i = shape->shortid();
101072:             if (block.staticBlock().isAliased(i))
101072:                 return false;
101072: 
101072:             if (maybefp) {
101072:                 JSScript *script = maybefp->script();
103284:                 unsigned local = block.slotToLocalIndex(script->bindings, shape->slot());
101072:                 if (action == GET)
101075:                     *vp = maybefp->unaliasedLocal(local);
101072:                 else
101075:                     maybefp->unaliasedLocal(local) = *vp;
101072:                 JS_ASSERT(analyze::LocalSlot(script, local) >= analyze::TotalSlots(script));
101072:             } else {
101072:                 if (action == GET)
101075:                     *vp = block.var(i, DONT_CHECK_ALIASING);
101072:                 else
101075:                     block.setVar(i, *vp, DONT_CHECK_ALIASING);
101072:             }
101072: 
101072:             return true;
101072:         }
101072: 
108508:         /* The rest of the internal scopes do not have unaliased vars. */
104205:         JS_ASSERT(scope->isDeclEnv() || scope->isWith() || scope->asCall().isForEval());
101072:         return false;
101072:     }
101072: 
 98922:     static bool isArguments(JSContext *cx, jsid id)
 98922:     {
 98922:         return id == NameToId(cx->runtime->atomState.argumentsAtom);
 98922:     }
 98922: 
 98922:     static bool isFunctionScope(ScopeObject &scope)
 98922:     {
 98922:         return scope.isCall() && !scope.asCall().isForEval();
 98922:     }
 98922: 
 98922:     /*
 98922:      * In theory, every function scope contains an 'arguments' bindings.
 98922:      * However, the engine only adds a binding if 'arguments' is used in the
 98922:      * function body. Thus, from the debugger's perspective, 'arguments' may be
 98922:      * missing from the list of bindings.
 98922:      */
 98922:     static bool isMissingArgumentsBinding(ScopeObject &scope)
 98922:     {
 98922:         return isFunctionScope(scope) &&
103492:                !scope.asCall().callee().script()->argumentsHasVarBinding();
 98922:     }
 98922: 
 98922:     /*
 98922:      * This function creates an arguments object when the debugger requests
 98922:      * 'arguments' for a function scope where the arguments object has been
 98922:      * optimized away (either because the binding is missing altogether or
 98922:      * because !ScriptAnalysis::needsArgsObj).
 98922:      */
 98922:     static bool checkForMissingArguments(JSContext *cx, jsid id, ScopeObject &scope,
 98922:                                          ArgumentsObject **maybeArgsObj)
 98922:     {
 98922:         *maybeArgsObj = NULL;
 98922: 
 98922:         if (!isArguments(cx, id) || !isFunctionScope(scope))
 98922:             return true;
 98922: 
103492:         JSScript *script = scope.asCall().callee().script();
 98922:         if (script->needsArgsObj())
 98922:             return true;
 98922: 
101072:         StackFrame *maybefp = cx->runtime->debugScopes->hasLiveFrame(scope);
101072:         if (!maybefp) {
 98922:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_LIVE,
 98922:                                  "Debugger scope");
 98922:             return false;
 98922:         }
 98922: 
101072:         *maybeArgsObj = ArgumentsObject::createUnexpected(cx, maybefp);
 98922:         return true;
 98922:     }
 98922: 
 98922:   public:
 98921:     static int family;
 98921:     static DebugScopeProxy singleton;
 98921: 
 98921:     DebugScopeProxy() : BaseProxyHandler(&family) {}
 98921: 
 98921:     bool getPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid id, bool set,
 98921:                                PropertyDescriptor *desc) MOZ_OVERRIDE
 98921:     {
 98921:         return getOwnPropertyDescriptor(cx, proxy, id, set, desc);
 98921:     }
 98921: 
108507:     bool getOwnPropertyDescriptor(JSContext *cx, JSObject *proxy, jsid idArg, bool set,
 98921:                                   PropertyDescriptor *desc) MOZ_OVERRIDE
 98921:     {
108507:         Rooted<DebugScopeObject*> debugScope(cx, &proxy->asDebugScope());
108507:         Rooted<ScopeObject*> scope(cx, &debugScope->scope());
108507:         RootedId id(cx, idArg);
 98922: 
 98922:         ArgumentsObject *maybeArgsObj;
104205:         if (!checkForMissingArguments(cx, id, *scope, &maybeArgsObj))
 98922:             return false;
 98922: 
 98922:         if (maybeArgsObj) {
 98922:             PodZero(desc);
108507:             desc->obj = debugScope;
 98922:             desc->attrs = JSPROP_READONLY | JSPROP_ENUMERATE | JSPROP_PERMANENT;
 98922:             desc->value = ObjectValue(*maybeArgsObj);
 98922:             return true;
 98922:         }
 98922: 
101072:         Value v;
108507:         if (handleUnaliasedAccess(cx, debugScope, scope, id, GET, &v)) {
101072:             PodZero(desc);
108507:             desc->obj = debugScope;
101072:             desc->attrs = JSPROP_READONLY | JSPROP_ENUMERATE | JSPROP_PERMANENT;
101072:             desc->value = v;
101072:             return true;
101072:         }
101072: 
104205:         return JS_GetPropertyDescriptorById(cx, scope, id, JSRESOLVE_QUALIFIED, desc);
 98921:     }
 98921: 
108507:     bool get(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid idArg, Value *vp) MOZ_OVERRIDE
 98921:     {
108507:         Rooted<DebugScopeObject*> debugScope(cx, &proxy->asDebugScope());
104205:         Rooted<ScopeObject*> scope(cx, &proxy->asDebugScope().scope());
108507:         RootedId id(cx, idArg);
 98922: 
 98922:         ArgumentsObject *maybeArgsObj;
104205:         if (!checkForMissingArguments(cx, id, *scope, &maybeArgsObj))
 98922:             return false;
 98922: 
 98922:         if (maybeArgsObj) {
 98922:             *vp = ObjectValue(*maybeArgsObj);
 98922:             return true;
 98922:         }
 98922: 
108507:         if (handleUnaliasedAccess(cx, debugScope, scope, id, GET, vp))
101072:             return true;
101072: 
106862:         RootedValue value(cx);
108951:         if (!JSObject::getGeneric(cx, scope, scope, id, &value))
106862:             return false;
106862: 
106862:         *vp = value;
106862:         return true;
 98921:     }
 98921: 
108507:     bool set(JSContext *cx, JSObject *proxy, JSObject *receiver, jsid idArg, bool strict,
 98921:                      Value *vp) MOZ_OVERRIDE
 98921:     {
108507:         Rooted<DebugScopeObject*> debugScope(cx, &proxy->asDebugScope());
103345:         Rooted<ScopeObject*> scope(cx, &proxy->asDebugScope().scope());
108507:         RootedId id(cx, idArg);
101072: 
108507:         if (handleUnaliasedAccess(cx, debugScope, scope, id, SET, vp))
101072:             return true;
101072: 
106862:         RootedValue value(cx, *vp);
108951:         if (!JSObject::setGeneric(cx, scope, scope, id, &value, strict))
106862:             return false;
106862: 
106862:         *vp = value;
106862:         return true;
 98921:     }
 98921: 
108507:     bool defineProperty(JSContext *cx, JSObject *proxy, jsid idArg, PropertyDescriptor *desc) MOZ_OVERRIDE
 98921:     {
104205:         Rooted<ScopeObject*> scope(cx, &proxy->asDebugScope().scope());
108507:         RootedId id(cx, idArg);
104205: 
 99960:         bool found;
 99960:         if (!has(cx, proxy, id, &found))
 99960:             return false;
 99960:         if (found)
 98921:             return Throw(cx, id, JSMSG_CANT_REDEFINE_PROP);
 99960: 
104205:         return JS_DefinePropertyById(cx, scope, id, desc->value, desc->getter, desc->setter,
 99960:                                      desc->attrs);
 98921:     }
 98921: 
108509:     bool getScopePropertyNames(JSContext *cx, JSObject *proxy, AutoIdVector &props, unsigned flags)
 98921:     {
 98921:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         if (isMissingArgumentsBinding(scope) &&
 98922:             !props.append(NameToId(cx->runtime->atomState.argumentsAtom)))
 98922:         {
 98922:             return false;
 98922:         }
 98922: 
108509:         RootedObject rootedScope(cx, &scope);
108509:         if (!GetPropertyNames(cx, rootedScope, flags, &props))
108509:             return false;
108509: 
108509:         /*
108509:          * Function scopes are optimized to not contain unaliased variables so
108509:          * they must be manually appended here.
108509:          */
108509:         if (scope.isCall() && !scope.asCall().isForEval()) {
108509:             for (BindingIter bi(scope.asCall().callee().script()->bindings); bi; bi++) {
108509:                 if (!bi->aliased() && !props.append(NameToId(bi->name())))
108509:                     return false;
108509:             }
 98921:         }
 98921: 
108509:         return true;
108509:     }
108509: 
108509:     bool getOwnPropertyNames(JSContext *cx, JSObject *proxy, AutoIdVector &props) MOZ_OVERRIDE
 98921:     {
108509:         return getScopePropertyNames(cx, proxy, props, JSITER_OWNONLY);
 98921:     }
 98921: 
 98921:     bool enumerate(JSContext *cx, JSObject *proxy, AutoIdVector &props) MOZ_OVERRIDE
 98921:     {
108509:         return getScopePropertyNames(cx, proxy, props, 0);
 98921:     }
 98922: 
 98922:     bool has(JSContext *cx, JSObject *proxy, jsid id, bool *bp) MOZ_OVERRIDE
 98922:     {
 98922:         ScopeObject &scope = proxy->asDebugScope().scope();
 98922: 
 98922:         if (isArguments(cx, id) && isFunctionScope(scope)) {
 98922:             *bp = true;
 98922:             return true;
 98922:         }
 98922: 
 98922:         JSBool found;
108509:         RootedObject rootedScope(cx, &scope);
108509:         if (!JS_HasPropertyById(cx, rootedScope, id, &found))
 98922:             return false;
 98922: 
108509:         /*
108509:          * Function scopes are optimized to not contain unaliased variables so
108509:          * a manual search is necessary.
108509:          */
108509:         if (!found && scope.isCall() && !scope.asCall().isForEval()) {
108509:             for (BindingIter bi(scope.asCall().callee().script()->bindings); bi; bi++) {
108509:                 if (!bi->aliased() && NameToId(bi->name()) == id) {
108509:                     found = true;
108509:                     break;
108509:                 }
108509:             }
108509:         }
108509: 
 98922:         *bp = found;
 98922:         return true;
 98922:     }
108509: 
108509:     bool delete_(JSContext *cx, JSObject *proxy, jsid id, bool *bp) MOZ_OVERRIDE
108509:     {
108509:         RootedValue idval(cx, IdToValue(id));
108509:         return js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_CANT_DELETE,
108509:                                         JSDVG_IGNORE_STACK, idval, NullPtr(), NULL, NULL);
108509:     }
 98921: };
 98921: 
 98921: }  /* namespace js */
 98921: 
 98921: int DebugScopeProxy::family = 0;
 98921: DebugScopeProxy DebugScopeProxy::singleton;
 98921: 
 98921: /* static */ DebugScopeObject *
101203: DebugScopeObject::create(JSContext *cx, ScopeObject &scope, HandleObject enclosing)
 98921: {
 98921:     JSObject *obj = NewProxyObject(cx, &DebugScopeProxy::singleton, ObjectValue(scope),
 98921:                                    NULL /* proto */, &scope.global(),
 98921:                                    NULL /* call */, NULL /* construct */);
 98921:     if (!obj)
 98921:         return NULL;
 98921: 
101203:     JS_ASSERT(!enclosing->isScope());
103637:     SetProxyExtra(obj, ENCLOSING_EXTRA, ObjectValue(*enclosing));
108507:     SetProxyExtra(obj, SNAPSHOT_EXTRA, NullValue());
 98921: 
 98921:     return &obj->asDebugScope();
 98921: }
 98921: 
 98921: ScopeObject &
 98921: DebugScopeObject::scope() const
 98921: {
107154:     return GetProxyTargetObject(const_cast<DebugScopeObject*>(this))->asScope();
 98921: }
 98921: 
 98921: JSObject &
 98921: DebugScopeObject::enclosingScope() const
 98921: {
107154:     return GetProxyExtra(const_cast<DebugScopeObject*>(this), ENCLOSING_EXTRA).toObject();
 98921: }
 98921: 
108507: JSObject *
108507: DebugScopeObject::maybeSnapshot() const
108507: {
108507:     JS_ASSERT(!scope().asCall().isForEval());
108507:     return GetProxyExtra(const_cast<DebugScopeObject*>(this), SNAPSHOT_EXTRA).toObjectOrNull();
108507: }
108507: 
108507: void
108507: DebugScopeObject::initSnapshot(JSObject &o)
108507: {
108507:     JS_ASSERT(maybeSnapshot() == NULL);
108507:     SetProxyExtra(this, SNAPSHOT_EXTRA, ObjectValue(o));
108507: }
108507: 
 98921: bool
 98921: DebugScopeObject::isForDeclarative() const
 98921: {
 98921:     ScopeObject &s = scope();
 98921:     return s.isCall() || s.isBlock() || s.isDeclEnv();
 98921: }
 98921: 
 98921: bool
107154: js_IsDebugScopeSlow(RawObject obj)
 98921: {
 98921:     return obj->getClass() == &ObjectProxyClass &&
 98921:            GetProxyHandler(obj) == &DebugScopeProxy::singleton;
 98921: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: DebugScopes::DebugScopes(JSRuntime *rt)
101078:  : rt(rt),
101078:    proxiedScopes(rt),
101071:    missingScopes(rt),
101071:    liveScopes(rt)
 98921: {}
 98921: 
 98921: DebugScopes::~DebugScopes()
 98921: {
 98921:     JS_ASSERT(missingScopes.empty());
 98921: }
 98921: 
 98921: bool
 98921: DebugScopes::init()
 98921: {
101071:     if (!liveScopes.init() ||
101071:         !proxiedScopes.init() ||
 98921:         !missingScopes.init())
 98921:     {
 98921:         return false;
 98921:     }
 98921:     return true;
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::mark(JSTracer *trc)
 98921: {
 98921:     proxiedScopes.trace(trc);
 98921: }
 98921: 
 98921: void
101078: DebugScopes::sweep()
 98921: {
 98921:     /*
 98921:      * Note: missingScopes points to debug scopes weakly not just so that debug
 98921:      * scopes can be released more eagerly, but, more importantly, to avoid
 98921:      * creating an uncollectable cycle with suspended generator frames.
 98921:      */
 98921:     for (MissingScopeMap::Enum e(missingScopes); !e.empty(); e.popFront()) {
101078:         if (!IsObjectMarked(e.front().value.unsafeGet()))
 98921:             e.removeFront();
 98921:     }
101071: 
101075:     for (LiveScopeMap::Enum e(liveScopes); !e.empty(); e.popFront()) {
101075:         ScopeObject *scope = e.front().key;
101075:         StackFrame *fp = e.front().value;
101075: 
101071:         /*
101075:          * Scopes can be finalized when a debugger-synthesized ScopeObject is
101075:          * no longer reachable via its DebugScopeObject.
101071:          */
101995:         if (!IsObjectMarked(&scope)) {
101071:             e.removeFront();
101075:             continue;
101075:         }
101075: 
101075:         /*
101075:          * As explained in onGeneratorFrameChange, liveScopes includes
101075:          * suspended generator frames. Since a generator can be finalized while
101075:          * its scope is live, we must explicitly detect finalized generators.
101075:          */
101075:         if (JSGenerator *gen = fp->maybeSuspendedGenerator(rt)) {
101075:             JS_ASSERT(gen->state == JSGEN_NEWBORN || gen->state == JSGEN_OPEN);
101995:             if (!IsObjectMarked(&gen->obj)) {
101075:                 e.removeFront();
101075:                 continue;
101075:             }
101071:         }
101071:     }
 98921: }
 98921: 
 98921: /*
 98921:  * Unfortunately, GetDebugScopeForFrame needs to work even outside debug mode
 98921:  * (in particular, JS_GetFrameScopeChain does not require debug mode). Since
 98921:  * DebugScopes::onPop* are only called in debug mode, this means we cannot
 98921:  * use any of the maps in DebugScopes. This will produce debug scope chains
 98921:  * that do not obey the debugger invariants but that is just fine.
 98921:  */
 98921: static bool
 98921: CanUseDebugScopeMaps(JSContext *cx)
 98921: {
 98921:     return cx->compartment->debugMode();
 98921: }
 98921: 
 98921: DebugScopeObject *
 98921: DebugScopes::hasDebugScope(JSContext *cx, ScopeObject &scope) const
 98921: {
 98921:     if (ObjectWeakMap::Ptr p = proxiedScopes.lookup(&scope)) {
 98921:         JS_ASSERT(CanUseDebugScopeMaps(cx));
 98921:         return &p->value->asDebugScope();
 98921:     }
 98921:     return NULL;
 98921: }
 98921: 
 98921: bool
 98921: DebugScopes::addDebugScope(JSContext *cx, ScopeObject &scope, DebugScopeObject &debugScope)
 98921: {
 98921:     if (!CanUseDebugScopeMaps(cx))
 98921:         return true;
101072: 
 98921:     JS_ASSERT(!proxiedScopes.has(&scope));
 98921:     if (!proxiedScopes.put(&scope, &debugScope)) {
 98921:         js_ReportOutOfMemory(cx);
 98921:         return false;
 98921:     }
109329:     HashTableWriteBarrierPost(debugScope.compartment(), &proxiedScopes, &scope);
 98921:     return true;
 98921: }
 98921: 
 98921: DebugScopeObject *
101995: DebugScopes::hasDebugScope(JSContext *cx, const ScopeIter &si) const
 98921: {
 98921:     JS_ASSERT(!si.hasScopeObject());
 98921:     if (MissingScopeMap::Ptr p = missingScopes.lookup(si)) {
 98921:         JS_ASSERT(CanUseDebugScopeMaps(cx));
 98921:         return p->value;
 98921:     }
 98921:     return NULL;
 98921: }
 98921: 
 98921: bool
101995: DebugScopes::addDebugScope(JSContext *cx, const ScopeIter &si, DebugScopeObject &debugScope)
 98921: {
 98921:     JS_ASSERT(!si.hasScopeObject());
 98921:     if (!CanUseDebugScopeMaps(cx))
 98921:         return true;
101072: 
 98921:     JS_ASSERT(!missingScopes.has(si));
 98921:     if (!missingScopes.put(si, &debugScope)) {
 98921:         js_ReportOutOfMemory(cx);
 98921:         return false;
 98921:     }
101072: 
101072:     JS_ASSERT(!liveScopes.has(&debugScope.scope()));
101072:     if (!liveScopes.put(&debugScope.scope(), si.fp())) {
101072:         js_ReportOutOfMemory(cx);
101072:         return false;
101072:     }
 98921:     return true;
 98921: }
 98921: 
 98921: void
101995: DebugScopes::onPopCall(StackFrame *fp, JSContext *cx)
 98921: {
101075:     JS_ASSERT(!fp->isYielding());
109256:     assertSameCompartment(cx, fp);
108507: 
108507:     DebugScopeObject *debugScope = NULL;
108507: 
101071:     if (fp->fun()->isHeavyweight()) {
101071:         /*
101075:          * The StackFrame may be observed before the prologue has created the
101075:          * CallObject. See ScopeIter::settle.
101071:          */
108507:         if (!fp->hasCallObj())
108507:             return;
108507: 
101072:         CallObject &callobj = fp->scopeChain()->asCall();
101072:         liveScopes.remove(&callobj);
108507:         if (ObjectWeakMap::Ptr p = proxiedScopes.lookup(&callobj))
108507:             debugScope = &p->value->asDebugScope();
101071:     } else {
101995:         ScopeIter si(fp, cx);
101995:         if (MissingScopeMap::Ptr p = missingScopes.lookup(si)) {
108507:             debugScope = p->value;
108507:             liveScopes.remove(&debugScope->scope().asCall());
 98921:             missingScopes.remove(p);
 98921:         }
 98921:     }
108507: 
108507:     /*
108507:      * When the StackFrame is popped, the values of unaliased variables
108507:      * are lost. If there is any debug scope referring to this scope, save a
109307:      * copy of the unaliased variables' values in an array for later debugger
108507:      * access via DebugScopeProxy::handleUnaliasedAccess.
108507:      *
108507:      * Note: since it is simplest for this function to be infallible, failure
108507:      * in this code will be silently ignored. This does not break any
108507:      * invariants since DebugScopeObject::maybeSnapshot can already be NULL.
108507:      */
108507:     if (debugScope) {
108507:         /*
108507:          * Copy all frame values into the snapshot, regardless of
108507:          * aliasing. This unnecessarily includes aliased variables
108507:          * but it simplifies later indexing logic.
108507:          */
108507:         StackFrame::CopyVector vec;
108507:         if (!fp->copyRawFrameSlots(&vec) || vec.length() == 0)
108507:             return;
108507: 
108507:         /*
108507:          * Copy in formals that are not aliased via the scope chain
108507:          * but are aliased via the arguments object.
108507:          */
108507:         JSScript *script = fp->script();
108507:         if (script->needsArgsObj() && fp->hasArgsObj()) {
108507:             for (unsigned i = 0; i < fp->numFormalArgs(); ++i) {
108507:                 if (script->formalLivesInArgumentsObject(i))
108507:                     vec[i] = fp->argsObj().arg(i);
108507:             }
108507:         }
108507: 
108507:         /*
108507:          * Use a dense array as storage (since proxies do not have trace
108507:          * hooks). This array must not escape into the wild.
108507:          */
108507:         JSObject *snapshot = NewDenseCopiedArray(cx, vec.length(), vec.begin());
108507:         if (!snapshot) {
108507:             cx->clearPendingException();
108507:             return;
108507:         }
108507: 
108507:         debugScope->initSnapshot(*snapshot);
108507:     }
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::onPopBlock(JSContext *cx, StackFrame *fp)
 98921: {
109256:     assertSameCompartment(cx, fp);
109256: 
101072:     StaticBlockObject &staticBlock = *fp->maybeBlockChain();
101072:     if (staticBlock.needsClone()) {
101072:         ClonedBlockObject &clone = fp->scopeChain()->asClonedBlock();
101072:         clone.copyUnaliasedValues(fp);
101072:         liveScopes.remove(&clone);
101071:     } else {
101995:         ScopeIter si(fp, cx);
101995:         if (MissingScopeMap::Ptr p = missingScopes.lookup(si)) {
101072:             ClonedBlockObject &clone = p->value->scope().asClonedBlock();
101072:             clone.copyUnaliasedValues(fp);
101072:             liveScopes.remove(&clone);
 98921:             missingScopes.remove(p);
 98921:         }
 98921:     }
 98921: }
 98921: 
 98921: void
101071: DebugScopes::onPopWith(StackFrame *fp)
101071: {
101071:     liveScopes.remove(&fp->scopeChain()->asWith());
101071: }
101071: 
101071: void
101071: DebugScopes::onPopStrictEvalScope(StackFrame *fp)
101071: {
101075:     /*
101075:      * The StackFrame may be observed before the prologue has created the
101075:      * CallObject. See ScopeIter::settle.
101075:      */
101075:     if (fp->hasCallObj())
101071:         liveScopes.remove(&fp->scopeChain()->asCall());
101071: }
101071: 
101071: void
101995: DebugScopes::onGeneratorFrameChange(StackFrame *from, StackFrame *to, JSContext *cx)
 98921: {
101995:     for (ScopeIter toIter(to, cx); !toIter.done(); ++toIter) {
101071:         if (toIter.hasScopeObject()) {
101071:             /*
101071:              * Not only must we correctly replace mappings [scope -> from] with
101071:              * mappings [scope -> to], but we must add [scope -> to] if it
101071:              * doesn't already exist so that if we need to proxy a generator's
101071:              * scope while it is suspended, we can find its frame (which would
101071:              * otherwise not be found by AllFramesIter).
101071:              */
101071:             LiveScopeMap::AddPtr livePtr = liveScopes.lookupForAdd(&toIter.scope());
101071:             if (livePtr)
101071:                 livePtr->value = to;
101071:             else
101071:                 liveScopes.add(livePtr, &toIter.scope(), to);
101071:         } else {
101995:             ScopeIter si(toIter, from, cx);
101995:             if (MissingScopeMap::Ptr p = missingScopes.lookup(si)) {
 98921:                 DebugScopeObject &debugScope = *p->value;
101072:                 liveScopes.lookup(&debugScope.scope())->value = to;
 98921:                 missingScopes.remove(p);
 98921:                 missingScopes.put(toIter, &debugScope);
 98921:             }
 98921:         }
 98921:     }
 98921: }
 98921: 
 98921: void
 98921: DebugScopes::onCompartmentLeaveDebugMode(JSCompartment *c)
 98921: {
109307:     for (ObjectWeakMap::Enum e(proxiedScopes); !e.empty(); e.popFront()) {
109307:         if (e.front().key->compartment() == c)
109307:             e.removeFront();
109307:     }
 98921:     for (MissingScopeMap::Enum e(missingScopes); !e.empty(); e.popFront()) {
 98921:         if (e.front().key.fp()->compartment() == c)
 98921:             e.removeFront();
 98921:     }
101071:     for (LiveScopeMap::Enum e(liveScopes); !e.empty(); e.popFront()) {
101071:         if (e.front().key->compartment() == c)
101071:             e.removeFront();
101071:     }
101071: }
101071: 
101071: bool
101071: DebugScopes::updateLiveScopes(JSContext *cx)
101071: {
101071:     JS_CHECK_RECURSION(cx, return false);
101071: 
101071:     /*
101071:      * Note that we must always update the top frame's scope objects' entries
101071:      * in liveScopes because we can't be sure code hasn't run in that frame to
101071:      * change the scope chain since we were last called. The fp->prevUpToDate()
101071:      * flag indicates whether the scopes of frames older than fp are already
101071:      * included in liveScopes. It might seem simpler to have fp instead carry a
101071:      * flag indicating whether fp itself is accurately described, but then we
101071:      * would need to clear that flag whenever fp ran code. By storing the 'up
101071:      * to date' bit for fp->prev() in fp, simply popping fp effectively clears
101071:      * the flag for us, at exactly the time when execution resumes fp->prev().
101071:      */
101071:     for (AllFramesIter i(cx->runtime->stackSpace); !i.done(); ++i) {
101071:         StackFrame *fp = i.fp();
109256:         if (fp->scopeChain()->compartment() != cx->compartment)
101071:             continue;
101071: 
101995:         for (ScopeIter si(fp, cx); !si.done(); ++si) {
101071:             if (si.hasScopeObject() && !liveScopes.put(&si.scope(), fp))
101071:                 return false;
101071:         }
101071: 
101071:         if (fp->prevUpToDate())
101071:             return true;
101071:         JS_ASSERT(fp->compartment()->debugMode());
101071:         fp->setPrevUpToDate();
101071:     }
101071: 
101071:     return true;
101071: }
101071: 
101071: StackFrame *
101071: DebugScopes::hasLiveFrame(ScopeObject &scope)
101071: {
101078:     if (LiveScopeMap::Ptr p = liveScopes.lookup(&scope)) {
101078:         StackFrame *fp = p->value;
101078: 
101078:         /*
101078:          * Since liveScopes is effectively a weak pointer, we need a read
101078:          * barrier. The scenario where this is necessary is:
101078:          *  1. GC starts, a suspended generator is not live
101078:          *  2. hasLiveFrame returns a StackFrame* to the (soon to be dead)
101078:          *     suspended generator
101078:          *  3. stack frame values (which will neve be marked) are read from the
101078:          *     StackFrame
101078:          *  4. GC completes, live objects may now point to values that weren't
101078:          *     marked and thus may point to swept GC things
101078:          */
101078:         if (JSGenerator *gen = fp->maybeSuspendedGenerator(rt))
101078:             JSObject::readBarrier(gen->obj);
101078: 
101078:         return fp;
101078:     }
101071:     return NULL;
 98921: }
 98921: 
 98921: /*****************************************************************************/
 98921: 
 98921: static JSObject *
101995: GetDebugScope(JSContext *cx, const ScopeIter &si);
 98921: 
 98921: static DebugScopeObject *
104205: GetDebugScopeForScope(JSContext *cx, Handle<ScopeObject*> scope, const ScopeIter &enclosing)
 98921: {
 98921:     DebugScopes &debugScopes = *cx->runtime->debugScopes;
104205:     if (DebugScopeObject *debugScope = debugScopes.hasDebugScope(cx, *scope))
 98921:         return debugScope;
 98921: 
101203:     RootedObject enclosingDebug(cx, GetDebugScope(cx, enclosing));
 98921:     if (!enclosingDebug)
 98921:         return NULL;
 98921: 
104205:     JSObject &maybeDecl = scope->enclosingScope();
 98921:     if (maybeDecl.isDeclEnv()) {
104205:         JS_ASSERT(CallObjectLambdaName(scope->asCall().callee()));
101203:         enclosingDebug = DebugScopeObject::create(cx, maybeDecl.asDeclEnv(), enclosingDebug);
 98921:         if (!enclosingDebug)
 98921:             return NULL;
 98921:     }
 98921: 
104205:     DebugScopeObject *debugScope = DebugScopeObject::create(cx, *scope, enclosingDebug);
 98921:     if (!debugScope)
 98921:         return NULL;
 98921: 
104205:     if (!debugScopes.addDebugScope(cx, *scope, *debugScope))
 98921:         return NULL;
 98921: 
 98921:     return debugScope;
 98921: }
 98921: 
 98921: static DebugScopeObject *
101995: GetDebugScopeForMissing(JSContext *cx, const ScopeIter &si)
 98921: {
 98921:     DebugScopes &debugScopes = *cx->runtime->debugScopes;
 98921:     if (DebugScopeObject *debugScope = debugScopes.hasDebugScope(cx, si))
 98921:         return debugScope;
 98921: 
101995:     ScopeIter copy(si, cx);
101995:     RootedObject enclosingDebug(cx, GetDebugScope(cx, ++copy));
 98921:     if (!enclosingDebug)
 98921:         return NULL;
 98921: 
 98921:     /*
108507:      * Create the missing scope object. For block objects, this takes care of
108507:      * storing variable values after the StackFrame has been popped. For call
108507:      * objects, we only use the pretend call object to access callee, bindings
108507:      * and to receive dynamically added properties. Together, this provides the
108507:      * nice invariant that every DebugScopeObject has a ScopeObject.
108507:      *
108507:      * Note: to preserve scopeChain depth invariants, these lazily-reified
108507:      * scopes must not be put on the frame's scope chain; instead, they are
108507:      * maintained via DebugScopes hooks.
 98921:      */
 98921:     DebugScopeObject *debugScope = NULL;
 98921:     switch (si.type()) {
 98921:       case ScopeIter::Call: {
104205:         Rooted<CallObject*> callobj(cx, CallObject::createForFunction(cx, si.fp()));
 98921:         if (!callobj)
 98921:             return NULL;
 98921: 
101072:         if (callobj->enclosingScope().isDeclEnv()) {
103492:             JS_ASSERT(CallObjectLambdaName(callobj->callee()));
101072:             DeclEnvObject &declenv = callobj->enclosingScope().asDeclEnv();
101203:             enclosingDebug = DebugScopeObject::create(cx, declenv, enclosingDebug);
 98921:             if (!enclosingDebug)
 98921:                 return NULL;
 98921:         }
 98921: 
101203:         debugScope = DebugScopeObject::create(cx, *callobj, enclosingDebug);
 98921:         break;
 98921:       }
 98921:       case ScopeIter::Block: {
 99421:         Rooted<StaticBlockObject *> staticBlock(cx, &si.staticBlock());
 98921:         ClonedBlockObject *block = ClonedBlockObject::create(cx, staticBlock, si.fp());
 98921:         if (!block)
 98921:             return NULL;
 98921: 
101203:         debugScope = DebugScopeObject::create(cx, *block, enclosingDebug);
 98921:         break;
 98921:       }
 98921:       case ScopeIter::With:
 98921:       case ScopeIter::StrictEvalScope:
 98921:         JS_NOT_REACHED("should already have a scope");
 98921:     }
101072:     if (!debugScope)
101072:         return NULL;
 98921: 
 98921:     if (!debugScopes.addDebugScope(cx, si, *debugScope))
 98921:         return NULL;
 98921: 
 98921:     return debugScope;
 98921: }
 98921: 
 98921: static JSObject *
 98921: GetDebugScope(JSContext *cx, JSObject &obj)
 98921: {
 98921:     /*
 98921:      * As an engine invariant (maintained internally and asserted by Execute),
 98921:      * ScopeObjects and non-ScopeObjects cannot be interleaved on the scope
 98921:      * chain; every scope chain must start with zero or more ScopeObjects and
 98921:      * terminate with one or more non-ScopeObjects (viz., GlobalObject).
 98921:      */
 98921:     if (!obj.isScope()) {
 98921: #ifdef DEBUG
 98921:         JSObject *o = &obj;
 98921:         while ((o = o->enclosingScope()))
 98921:             JS_ASSERT(!o->isScope());
 98921: #endif
 98921:         return &obj;
 98921:     }
 98921: 
104205:     Rooted<ScopeObject*> scope(cx, &obj.asScope());
104205:     if (StackFrame *fp = cx->runtime->debugScopes->hasLiveFrame(*scope)) {
104205:         ScopeIter si(fp, *scope, cx);
101995:         return GetDebugScope(cx, si);
101995:     }
104205:     ScopeIter si(scope->enclosingScope(), cx);
101995:     return GetDebugScopeForScope(cx, scope, si);
 98921: }
 98921: 
 98921: static JSObject *
101995: GetDebugScope(JSContext *cx, const ScopeIter &si)
 98921: {
 98921:     JS_CHECK_RECURSION(cx, return NULL);
 98921: 
 98921:     if (si.done())
 98921:         return GetDebugScope(cx, si.enclosingScope());
 98921: 
 98921:     if (!si.hasScopeObject())
 98921:         return GetDebugScopeForMissing(cx, si);
 98921: 
104205:     Rooted<ScopeObject*> scope(cx, &si.scope());
104205: 
101995:     ScopeIter copy(si, cx);
104205:     return GetDebugScopeForScope(cx, scope, ++copy);
 98921: }
 98921: 
 98921: JSObject *
 98921: js::GetDebugScopeForFunction(JSContext *cx, JSFunction *fun)
 98921: {
 98921:     assertSameCompartment(cx, fun);
 98921:     JS_ASSERT(cx->compartment->debugMode());
101071:     if (!cx->runtime->debugScopes->updateLiveScopes(cx))
101071:         return NULL;
 98921:     return GetDebugScope(cx, *fun->environment());
 98921: }
 98921: 
 98921: JSObject *
 98921: js::GetDebugScopeForFrame(JSContext *cx, StackFrame *fp)
 98921: {
 98921:     assertSameCompartment(cx, fp);
101071:     if (CanUseDebugScopeMaps(cx) && !cx->runtime->debugScopes->updateLiveScopes(cx))
101071:         return NULL;
101995:     ScopeIter si(fp, cx);
101995:     return GetDebugScope(cx, si);
 98921: }
