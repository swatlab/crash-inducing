    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set ts=2 sts=2 sw=2 et cin:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Jacek Piskozub <piskozub@iopan.gda.pl>
    1:  *   Leon Sha <leon.sha@sun.com>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Christian Biesinger <cbiesinger@web.de>
  130:  *   Josh Aas <josh@mozilla.com>
54309:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
50722: #ifdef MOZ_WIDGET_QT
50722: #include <QWidget>
50722: #include <QKeyEvent>
50722: #ifdef MOZ_X11
50722: #include <QX11Info>
50722: #endif
57889: #undef slots
50722: #endif
50722: 
50669: #ifdef MOZ_X11
50669: #include <cairo-xlib.h>
50669: #include "gfxXlibSurface.h"
50669: /* X headers suck */
50669: enum { XKeyPress = KeyPress };
50669: #ifdef KeyPress
50669: #undef KeyPress
50669: #endif
71095: #include "mozilla/X11Util.h"
71095: using mozilla::DefaultXDisplay;
50671: #endif
50669: 
71095: #include "nsPluginInstanceOwner.h"
71095: #include "nsIRunnable.h"
71095: #include "nsContentUtils.h"
71095: #include "nsRect.h"
71095: #include "nsSize.h"
71095: #include "nsDisplayList.h"
71095: #include "ImageLayers.h"
71095: #include "nsIDOMEventTarget.h"
71095: #include "nsObjectFrame.h"
71095: #include "nsIPluginDocument.h"
71095: #include "nsIStringStream.h"
71095: #include "nsNetUtil.h"
71095: #include "mozilla/Preferences.h"
71095: #include "nsILinkHandler.h"
71095: #include "nsIDocShellTreeItem.h"
71095: #include "nsIWebBrowserChrome.h"
71095: #include "nsLayoutUtils.h"
71095: #include "nsIPrivateDOMEvent.h"
71095: #include "nsIPluginWidget.h"
    1: #include "nsIViewManager.h"
71095: #include "nsIDocShellTreeOwner.h"
71095: #include "nsIDOMHTMLObjectElement.h"
71095: #include "nsIAppShell.h"
71095: #include "nsIDOMHTMLAppletElement.h"
71095: #include "nsAttrName.h"
71095: #include "nsIFocusManager.h"
71095: #include "nsFocusManager.h"
20592: #include "nsIDOMDragEvent.h"
37067: #include "nsIScrollableFrame.h"
89114: #include "nsIImageLoadingContent.h"
    1: 
    1: #include "nsContentCID.h"
71095: #include "nsWidgetsCID.h"
89114: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
13537: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
71095: #ifdef XP_WIN
71095: #include <wtypes.h>
71095: #include <winuser.h>
71095: #endif
71095: 
11944: #ifdef XP_MACOSX
71095: #include <Carbon/Carbon.h>
32019: #include "nsPluginUtilsOSX.h"
11944: #endif
11944: 
 3059: #ifdef MOZ_WIDGET_GTK2
23281: #include <gdk/gdk.h>
 3059: #include <gdk/gdkx.h>
25500: #include <gtk/gtk.h>
47118: #include "gfxXlibNativeRenderer.h"
 3059: #endif
    1: 
82142: #ifdef MOZ_WIDGET_ANDROID
78424: #include "ANPBase.h"
78424: #include "android_npapi.h"
78424: #include "AndroidBridge.h"
89219: #include "AndroidMediaLayer.h"
78424: using namespace mozilla::dom;
78424: 
78424: #include <android/log.h>
78424: #define LOG(args...)  __android_log_print(ANDROID_LOG_INFO, "GeckoPlugins" , ## args)
78424: #endif
78424: 
62699: using namespace mozilla;
54223: 
    1: // special class for handeling DOM context menu events because for
    1: // some reason it starves other mouse events if implemented on the
    1: // same class
75044: class nsPluginDOMContextMenuListener : public nsIDOMEventListener
    1: {
    1: public:
    1:   nsPluginDOMContextMenuListener();
    1:   virtual ~nsPluginDOMContextMenuListener();
    1: 
    1:   NS_DECL_ISUPPORTS
75044:   NS_DECL_NSIDOMEVENTLISTENER
    1: 
    1:   nsresult Init(nsIContent* aContent);
    1:   nsresult Destroy(nsIContent* aContent);
    1:   
    1:   nsEventStatus ProcessEvent(const nsGUIEvent& anEvent)
    1:   {
    1:     return nsEventStatus_eConsumeNoDefault;
    1:   }
    1: };
    1: 
59486: class AsyncPaintWaitEvent : public nsRunnable
59486: {
59486: public:
79445:   AsyncPaintWaitEvent(nsIContent* aContent, bool aFinished) :
59486:     mContent(aContent), mFinished(aFinished)
59486:   {
59486:   }
59486: 
59486:   NS_IMETHOD Run()
59486:   {
80526:     nsContentUtils::DispatchTrustedEvent(mContent->OwnerDoc(), mContent,
59486:         mFinished ? NS_LITERAL_STRING("MozPaintWaitFinished") : NS_LITERAL_STRING("MozPaintWait"),
79533:         true, true);
59486:     return NS_OK;
59486:   }
59486: 
59486: private:
59486:   nsCOMPtr<nsIContent> mContent;
79445:   bool                 mFinished;
59486: };
59486: 
54223: void
58634: nsPluginInstanceOwner::NotifyPaintWaiter(nsDisplayListBuilder* aBuilder)
54223: {
54223:   // This is notification for reftests about async plugin paint start
54223:   if (!mWaitingForPaint && !IsUpToDate() && aBuilder->ShouldSyncDecodeImages()) {
79533:     nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(mContent, false);
59486:     // Run this event as soon as it's safe to do so, since listeners need to
59486:     // receive it immediately
59486:     mWaitingForPaint = nsContentUtils::AddScriptRunner(event);
54223:   }
54223: }
54223: 
68763: #ifdef XP_MACOSX
63443: static void DrawPlugin(ImageContainer* aContainer, void* aPluginInstanceOwner)
63443: {
89114:   nsObjectFrame* frame = static_cast<nsPluginInstanceOwner*>(aPluginInstanceOwner)->GetFrame();
63443:   if (frame) {
89708:     frame->UpdateImageLayer(gfxRect(0,0,0,0));
63443:   }
63443: }
63443: 
63443: static void OnDestroyImage(void* aPluginInstanceOwner)
63443: {
63444:   nsPluginInstanceOwner* owner = static_cast<nsPluginInstanceOwner*>(aPluginInstanceOwner);
63444:   NS_IF_RELEASE(owner);
62724: }
68763: #endif // XP_MACOSX
62724: 
89708: already_AddRefed<ImageContainer>
89708: nsPluginInstanceOwner::GetImageContainer()
54223: {
67851:   if (mInstance) {
89708:     nsRefPtr<ImageContainer> container;
67851:     // Every call to nsIPluginInstance::GetImage() creates
63443:     // a new image.  See nsIPluginInstance.idl.
89708:     mInstance->GetImageContainer(getter_AddRefs(container));
89708:     if (container) {
62724: #ifdef XP_MACOSX
89708:       nsRefPtr<Image> image = container->GetCurrentImage();
89708:       if (image && image->GetFormat() == Image::MAC_IO_SURFACE && mObjectFrame) {
62724:         MacIOSurfaceImage *oglImage = static_cast<MacIOSurfaceImage*>(image.get());
63443:         NS_ADDREF_THIS();
63443:         oglImage->SetUpdateCallback(&DrawPlugin, this);
63443:         oglImage->SetDestroyCallback(&OnDestroyImage);
62724:       }
62724: #endif
89708:       return container.forget();
89708:     }
89708:   }
89708:   return nsnull;
57516: }
54223: 
62704: void
62704: nsPluginInstanceOwner::SetBackgroundUnknown()
62704: {
67851:   if (mInstance) {
67851:     mInstance->SetBackgroundUnknown();
62704:   }
62704: }
62704: 
62704: already_AddRefed<gfxContext>
62704: nsPluginInstanceOwner::BeginUpdateBackground(const nsIntRect& aRect)
62704: {
62704:   nsIntRect rect = aRect;
62704:   nsRefPtr<gfxContext> ctx;
67851:   if (mInstance &&
67851:       NS_SUCCEEDED(mInstance->BeginUpdateBackground(&rect, getter_AddRefs(ctx)))) {
62704:     return ctx.forget();
62704:   }
62704:   return nsnull;
62704: }
62704: 
62704: void
62704: nsPluginInstanceOwner::EndUpdateBackground(gfxContext* aContext,
62704:                                            const nsIntRect& aRect)
62704: {
62704:   nsIntRect rect = aRect;
67851:   if (mInstance) {
67851:     mInstance->EndUpdateBackground(aContext, &rect);
62704:   }
62704: }
62704: 
79445: bool
71284: nsPluginInstanceOwner::UseAsyncRendering()
71284: {
71284: #ifdef XP_MACOSX
89114:   if (mUseAsyncRendering) {
89114:     return true;
89114:   }
71284: #endif
71284: 
79445:   bool useAsyncRendering;
79445:   bool result = (mInstance &&
71284:           NS_SUCCEEDED(mInstance->UseAsyncPainting(&useAsyncRendering)) &&
89204:           useAsyncRendering
89204: #ifndef XP_MACOSX
89204:           && (!mPluginWindow ||
71284:            mPluginWindow->type == NPWindowTypeDrawable)
71284: #endif
71284:           );
72866: 
89114: #ifdef XP_MACOSX
89114:   if (result) {
89114:     mUseAsyncRendering = true;
89114:   }
89114: #endif
89114: 
72866:   return result;
71284: }
71284: 
62982: nsIntSize
62982: nsPluginInstanceOwner::GetCurrentImageSize()
62982: {
62982:   nsIntSize size(0,0);
67851:   if (mInstance) {
67851:     mInstance->GetImageSize(&size);
62982:   }
62982:   return size;
62982: }
62982: 
    1: nsPluginInstanceOwner::nsPluginInstanceOwner()
    1: {
32799:   // create nsPluginNativeWindow object, it is derived from NPWindow
    1:   // struct and allows to manipulate native window procedure
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
89114:   mPluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());  
89114:   if (mPluginHost)
89114:     mPluginHost->NewPluginNativeWindow(&mPluginWindow);
    1:   else
    1:     mPluginWindow = nsnull;
    1: 
34679:   mObjectFrame = nsnull;
89114:   mContent = nsnull;
    1:   mTagText = nsnull;
89114:   mWidgetCreationComplete = false;
21108: #ifdef XP_MACOSX
32799:   memset(&mCGPluginPortCopy, 0, sizeof(NP_CGContext));
43652: #ifndef NP_NO_QUICKDRAW
32799:   memset(&mQDPluginPortCopy, 0, sizeof(NP_Port));
43652: #endif
21108:   mInCGPaintLevel = 0;
79533:   mSentInitialTopLevelWindowEvent = false;
67592:   mColorProfile = nsnull;
79533:   mPluginPortChanged = false;
21108: #endif
79533:   mContentFocused = false;
79533:   mWidgetVisible = true;
79533:   mPluginWindowVisible = false;
79533:   mPluginDocumentActiveState = true;
    1:   mNumCachedAttrs = 0;
    1:   mNumCachedParams = 0;
    1:   mCachedAttrParamNames = nsnull;
    1:   mCachedAttrParamValues = nsnull;
12417: 
35174: #ifdef XP_MACOSX
35174: #ifndef NP_NO_QUICKDRAW
35174:   mEventModel = NPEventModelCarbon;
35174: #else
35174:   mEventModel = NPEventModelCocoa;
35174: #endif
89114:   mUseAsyncRendering = false;
35174: #endif
54223: 
79533:   mWaitingForPaint = false;
82979: 
82979: #ifdef MOZ_WIDGET_ANDROID
89219:   mInverted = false;
90194:   mLayer = nsnull;
82979: #endif
    1: }
    1: 
    1: nsPluginInstanceOwner::~nsPluginInstanceOwner()
    1: {
    1:   PRInt32 cnt;
    1: 
59486:   if (mWaitingForPaint) {
59486:     // We don't care when the event is dispatched as long as it's "soon",
63041:     // since whoever needs it will be waiting for it.
79533:     nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(mContent, true);
59486:     NS_DispatchToMainThread(event);
59486:   }
59486: 
36227: #ifdef MAC_CARBON_PLUGINS
    1:   CancelTimer();
36227: #endif
    1: 
34679:   mObjectFrame = nsnull;
    1: 
    1:   for (cnt = 0; cnt < (mNumCachedAttrs + 1 + mNumCachedParams); cnt++) {
    1:     if (mCachedAttrParamNames && mCachedAttrParamNames[cnt]) {
26930:       NS_Free(mCachedAttrParamNames[cnt]);
    1:       mCachedAttrParamNames[cnt] = nsnull;
    1:     }
    1: 
    1:     if (mCachedAttrParamValues && mCachedAttrParamValues[cnt]) {
26930:       NS_Free(mCachedAttrParamValues[cnt]);
    1:       mCachedAttrParamValues[cnt] = nsnull;
    1:     }
    1:   }
    1: 
    1:   if (mCachedAttrParamNames) {
44203:     NS_Free(mCachedAttrParamNames);
    1:     mCachedAttrParamNames = nsnull;
    1:   }
    1: 
    1:   if (mCachedAttrParamValues) {
44203:     NS_Free(mCachedAttrParamValues);
    1:     mCachedAttrParamValues = nsnull;
    1:   }
    1: 
    1:   if (mTagText) {
    1:     NS_Free(mTagText);
    1:     mTagText = nsnull;
    1:   }
    1: 
89114:   PLUG_DeletePluginNativeWindow(mPluginWindow);
    1:   mPluginWindow = nsnull;
24200: 
89219: #ifdef MOZ_WIDGET_ANDROID
90194:   RemovePluginView();
89219: #endif
89219: 
24200:   if (mInstance) {
29834:     mInstance->InvalidateOwner();
24200:   }
    1: }
    1: 
75043: NS_IMPL_ISUPPORTS3(nsPluginInstanceOwner,
75043:                    nsIPluginInstanceOwner,
75043:                    nsIPluginTagInfo,
75043:                    nsIDOMEventListener)
    1: 
70007: nsresult
70007: nsPluginInstanceOwner::SetInstance(nsNPAPIPluginInstance *aInstance)
    1: {
58080:   NS_ASSERTION(!mInstance || !aInstance, "mInstance should only be set or unset!");
58080: 
58080:   // If we're going to null out mInstance after use, be sure to call
58080:   // mInstance->InvalidateOwner() here, since it now won't be called
58080:   // from our destructor.  This fixes bug 613376.
58080:   if (mInstance && !aInstance)
58080:     mInstance->InvalidateOwner();
24200: 
    1:   mInstance = aInstance;
    1: 
    1:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::GetWindow(NPWindow *&aWindow)
    1: {
    1:   NS_ASSERTION(mPluginWindow, "the plugin window object being returned is null");
    1:   aWindow = mPluginWindow;
    1:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::GetMode(PRInt32 *aMode)
    1: {
    1:   nsCOMPtr<nsIDocument> doc;
    1:   nsresult rv = GetDocument(getter_AddRefs(doc));
    1:   nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(doc));
    1: 
    1:   if (pDoc) {
32799:     *aMode = NP_FULL;
    1:   } else {
32799:     *aMode = NP_EMBED;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAttributes(PRUint16& n,
    1:                                                    const char*const*& names,
    1:                                                    const char*const*& values)
    1: {
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   n = mNumCachedAttrs;
    1:   names  = (const char **)mCachedAttrParamNames;
    1:   values = (const char **)mCachedAttrParamValues;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAttribute(const char* name, const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(name);
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *result = nsnull;
    1: 
    1:   for (int i = 0; i < mNumCachedAttrs; i++) {
    1:     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
    1:       *result = mCachedAttrParamValues[i];
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDOMElement(nsIDOMElement* *result)
    1: {
    1:   return CallQueryInterface(mContent, result);
    1: }
    1: 
70007: nsresult nsPluginInstanceOwner::GetInstance(nsNPAPIPluginInstance **aInstance)
70007: {
70007:   NS_ENSURE_ARG_POINTER(aInstance);
70007: 
70007:   *aInstance = mInstance;
78894:   NS_IF_ADDREF(*aInstance);
    1:   return NS_OK;
    1: }
    1: 
36766: NS_IMETHODIMP nsPluginInstanceOwner::GetURL(const char *aURL,
36766:                                             const char *aTarget,
36766:                                             nsIInputStream *aPostStream,
36766:                                             void *aHeadersData,
36766:                                             PRUint32 aHeadersDataLen)
    1: {
89114:   NS_ENSURE_TRUE(mContent, NS_ERROR_NULL_POINTER);
    1: 
 3333:   if (mContent->IsEditable()) {
 3333:     return NS_OK;
 3333:   }
 3333: 
89114:   nsIDocument *doc = mContent->GetCurrentDoc();
89114:   if (!doc) {
89114:     return NS_ERROR_FAILURE;
89114:   }
89114: 
89114:   nsIPresShell *presShell = doc->GetShell();
89114:   if (!presShell) {
89114:     return NS_ERROR_FAILURE;
89114:   }
89114: 
89114:   nsPresContext *presContext = presShell->GetPresContext();
89114:   if (!presContext) {
89114:     return NS_ERROR_FAILURE;
89114:   }
89114: 
    1:   // the container of the pres context will give us the link handler
89114:   nsCOMPtr<nsISupports> container = presContext->GetContainer();
    1:   NS_ENSURE_TRUE(container,NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsILinkHandler> lh = do_QueryInterface(container);
    1:   NS_ENSURE_TRUE(lh, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString  unitarget;
    1:   unitarget.AssignASCII(aTarget); // XXX could this be nonascii?
    1: 
    1:   nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1: 
    1:   // Create an absolute URL
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, baseURI);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIInputStream> headersDataStream;
36766:   if (aPostStream && aHeadersData) {
36766:     if (!aHeadersDataLen)
36766:       return NS_ERROR_UNEXPECTED;
36766: 
36766:     nsCOMPtr<nsIStringInputStream> sis = do_CreateInstance("@mozilla.org/io/string-input-stream;1");
36766:     if (!sis)
36766:       return NS_ERROR_OUT_OF_MEMORY;
36766: 
36766:     rv = sis->SetData((char *)aHeadersData, aHeadersDataLen);
36766:     NS_ENSURE_SUCCESS(rv, rv);
36766:     headersDataStream = do_QueryInterface(sis);
    1:   }
    1: 
    1:   PRInt32 blockPopups =
70842:     Preferences::GetInt("privacy.popups.disable_from_plugins");
    1:   nsAutoPopupStatePusher popupStatePusher((PopupControlState)blockPopups);
    1: 
    1:   rv = lh->OnLinkClick(mContent, uri, unitarget.get(), 
79533:                        aPostStream, headersDataStream, true);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ShowStatus(const char *aStatusMsg)
    1: {
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1:   
    1:   rv = this->ShowStatus(NS_ConvertUTF8toUTF16(aStatusMsg).get());
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ShowStatus(const PRUnichar *aStatusMsg)
    1: {
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1: 
34679:   if (!mObjectFrame) {
    1:     return rv;
    1:   }
34679:   nsCOMPtr<nsISupports> cont = mObjectFrame->PresContext()->GetContainer();
    1:   if (!cont) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellItem(do_QueryInterface(cont, &rv));
    1:   if (NS_FAILED(rv) || !docShellItem) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   rv = docShellItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   if (NS_FAILED(rv) || !treeOwner) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(treeOwner, &rv));
    1:   if (NS_FAILED(rv) || !browserChrome) {
    1:     return rv;
    1:   }
    1:   rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT, 
    1:                                 aStatusMsg);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocument(nsIDocument* *aDocument)
    1: {
    1:   if (!aDocument)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // XXX sXBL/XBL2 issue: current doc or owner doc?
    1:   // But keep in mind bug 322414 comment 33
80526:   NS_IF_ADDREF(*aDocument = mContent->OwnerDoc());
    1:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRect(NPRect *invalidRect)
    1: {
62860:   // If our object frame has gone away, we won't be able to determine
62860:   // up-to-date-ness, so just fire off the event.
62860:   if (mWaitingForPaint && (!mObjectFrame || IsUpToDate())) {
59486:     // We don't care when the event is dispatched as long as it's "soon",
63041:     // since whoever needs it will be waiting for it.
79533:     nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(mContent, true);
59486:     NS_DispatchToMainThread(event);
59486:     mWaitingForPaint = false;
59486:   }
59486: 
34679:   if (!mObjectFrame || !invalidRect || !mWidgetVisible)
34501:     return NS_ERROR_FAILURE;
34501: 
54223:   // Each time an asynchronously-drawing plugin sends a new surface to display,
54223:   // InvalidateRect is called. We notify reftests that painting is up to
54223:   // date and update our ImageContainer with the new surface.
89708:   nsRefPtr<ImageContainer> container;
89708:   mInstance->GetImageContainer(getter_AddRefs(container));
67647:   gfxIntSize oldSize(0, 0);
54223: 
34501: #ifndef XP_MACOSX
34501:   // Windowed plugins should not be calling NPN_InvalidateRect, but
34501:   // Silverlight does and expects it to "work"
34501:   if (mWidget) {
34501:     mWidget->Invalidate(nsIntRect(invalidRect->left, invalidRect->top,
34501:                                   invalidRect->right - invalidRect->left,
87336:                                   invalidRect->bottom - invalidRect->top));
34501:     return NS_OK;
34501:   }
34501: #endif
34501: 
34679:   nsPresContext* presContext = mObjectFrame->PresContext();
    1:   nsRect rect(presContext->DevPixelsToAppUnits(invalidRect->left),
    1:               presContext->DevPixelsToAppUnits(invalidRect->top),
    1:               presContext->DevPixelsToAppUnits(invalidRect->right - invalidRect->left),
    1:               presContext->DevPixelsToAppUnits(invalidRect->bottom - invalidRect->top));
63041:   if (container) {
63041:     gfxIntSize newSize = container->GetCurrentSize();
63041:     if (newSize != oldSize) {
63041:       // The image size has changed - invalidate the old area too, bug 635405.
63041:       nsRect oldRect = nsRect(0, 0,
63041:                               presContext->DevPixelsToAppUnits(oldSize.width),
63041:                               presContext->DevPixelsToAppUnits(oldSize.height));
63041:       rect.UnionRect(rect, oldRect);
63041:     }
63041:   }
68635:   rect.MoveBy(mObjectFrame->GetContentRectRelativeToSelf().TopLeft());
63041:   mObjectFrame->InvalidateLayer(rect, nsDisplayItem::TYPE_PLUGIN);
34501:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRegion(NPRegion invalidRegion)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
29834: NS_IMETHODIMP nsPluginInstanceOwner::GetNetscapeWindow(void *value)
    1: {
34679:   if (!mObjectFrame) {
29834:     NS_WARNING("plugin owner has no owner in getting doc's window handle");
29834:     return NS_ERROR_FAILURE;
29834:   }
29834:   
 3061: #if defined(XP_WIN) || defined(XP_OS2)
    1:   void** pvalue = (void**)value;
34679:   nsIViewManager* vm = mObjectFrame->PresContext()->GetPresShell()->GetViewManager();
29834:   if (!vm)
29834:     return NS_ERROR_FAILURE;
    1: #if defined(XP_WIN)
    1:   // This property is provided to allow a "windowless" plugin to determine the window it is drawing
    1:   // in, so it can translate mouse coordinates it receives directly from the operating system
    1:   // to coordinates relative to itself.
    1:   
    1:   // The original code (outside this #if) returns the document's window, which is OK if the window the "windowless" plugin
    1:   // is drawing into has the same origin as the document's window, but this is not the case for "windowless" plugins inside of scrolling DIVs etc
    1:   
    1:   // To make sure "windowless" plugins always get the right origin for translating mouse coordinates, this code
    1:   // determines the window handle of the mozilla window containing the "windowless" plugin.
    1:   
    1:   // Given that this HWND may not be that of the document's window, there is a slight risk
    1:   // of confusing a plugin that is using this HWND for illicit purposes, but since the documentation
    1:   // does not suggest this HWND IS that of the document window, rather that of the window
    1:   // the plugin is drawn in, this seems like a safe fix.
    1:   
    1:   // we only attempt to get the nearest window if this really is a "windowless" plugin so as not
    1:   // to change any behaviour for the much more common windowed plugins,
    1:   // though why this method would even be being called for a windowed plugin escapes me.
32799:   if (mPluginWindow && mPluginWindow->type == NPWindowTypeDrawable) {
    1:     // it turns out that flash also uses this window for determining focus, and is currently
    1:     // unable to show a caret correctly if we return the enclosing window. Therefore for
    1:     // now we only return the enclosing window when there is an actual offset which
    1:     // would otherwise cause coordinates to be offset incorrectly. (i.e.
    1:     // if the enclosing window if offset from the document window)
    1:     //
    1:     // fixing both the caret and ability to interact issues for a windowless control in a non document aligned windw
    1:     // does not seem to be possible without a change to the flash plugin
    1:     
47148:     nsIWidget* win = mObjectFrame->GetNearestWidget();
    1:     if (win) {
    1:       nsIView *view = nsIView::GetViewFor(win);
    1:       NS_ASSERTION(view, "No view for widget");
30535:       nsPoint offset = view->GetOffsetTo(nsnull);
    1:       
    1:       if (offset.x || offset.y) {
    1:         // in the case the two windows are offset from eachother, we do go ahead and return the correct enclosing window
    1:         // so that mouse co-ordinates are not messed up.
    1:         *pvalue = (void*)win->GetNativeData(NS_NATIVE_WINDOW);
    1:         if (*pvalue)
    1:           return NS_OK;
    1:       }
    1:     }
29836:   }
    1: #endif
30535:   // simply return the topmost document window
    1:   nsCOMPtr<nsIWidget> widget;
30535:   nsresult rv = vm->GetRootWidget(getter_AddRefs(widget));            
    1:   if (widget) {
    1:     *pvalue = (void*)widget->GetNativeData(NS_NATIVE_WINDOW);
29834:   } else {
29834:     NS_ASSERTION(widget, "couldn't get doc's widget in getting doc's window handle");
29834:   }
29834: 
29834:   return rv;
77658: #elif defined(MOZ_WIDGET_GTK2) || defined(MOZ_WIDGET_QT)
 3061:   // X11 window managers want the toplevel window for WM_TRANSIENT_FOR.
47148:   nsIWidget* win = mObjectFrame->GetNearestWidget();
 3061:   if (!win)
29834:     return NS_ERROR_FAILURE;
77658:   *static_cast<Window*>(value) = (long unsigned int)win->GetNativeData(NS_NATIVE_SHAREABLE_WINDOW);
 3061:   return NS_OK;
29834: #else
29834:   return NS_ERROR_NOT_IMPLEMENTED;
 3061: #endif
    1: }
    1: 
34717: NS_IMETHODIMP nsPluginInstanceOwner::SetEventModel(PRInt32 eventModel)
34717: {
34717: #ifdef XP_MACOSX
34717:   mEventModel = static_cast<NPEventModel>(eventModel);
34717:   return NS_OK;
34717: #else
34717:   return NS_ERROR_NOT_IMPLEMENTED;
34717: #endif
34717: }
34717: 
32799: NPError nsPluginInstanceOwner::ShowNativeContextMenu(NPMenu* menu, void* event)
32019: {
32019:   if (!menu || !event)
32019:     return NPERR_GENERIC_ERROR;
32019: 
32019: #ifdef XP_MACOSX
32019:   if (GetEventModel() != NPEventModelCocoa)
32019:     return NPERR_INCOMPATIBLE_VERSION_ERROR;
32019: 
32019:   return NS_NPAPI_ShowCocoaContextMenu(static_cast<void*>(menu), mWidget,
32799:                                        static_cast<NPCocoaEvent*>(event));
32019: #else
32019:   return NPERR_INCOMPATIBLE_VERSION_ERROR;
32019: #endif
32019: }
32019: 
32019: NPBool nsPluginInstanceOwner::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                                            double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019: #ifdef XP_MACOSX
32019:   if (!mWidget)
79533:     return false;
32019: 
32019:   return NS_NPAPI_ConvertPointCocoa(mWidget->GetNativeData(NS_NATIVE_WIDGET),
32019:                                     sourceX, sourceY, sourceSpace, destX, destY, destSpace);
32019: #else
32019:   // we should implement this for all platforms
79533:   return false;
32019: #endif
32019: }
32019: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetTagType(nsPluginTagType *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   *result = nsPluginTagType_Unknown;
    1: 
    1:   nsIAtom *atom = mContent->Tag();
    1: 
    1:   if (atom == nsGkAtoms::applet)
    1:     *result = nsPluginTagType_Applet;
    1:   else if (atom == nsGkAtoms::embed)
    1:     *result = nsPluginTagType_Embed;
    1:   else if (atom == nsGkAtoms::object)
    1:     *result = nsPluginTagType_Object;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetTagText(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   if (nsnull == mTagText) {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent, &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDocument> document;
    1:     rv = GetDocument(getter_AddRefs(document));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(document);
    1:     NS_ASSERTION(domDoc, "Need a document");
    1: 
    1:     nsCOMPtr<nsIDocumentEncoder> docEncoder(do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE "text/html", &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = docEncoder->Init(domDoc, NS_LITERAL_STRING("text/html"), nsIDocumentEncoder::OutputEncodeBasicEntities);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
86939:     nsRefPtr<nsRange> range = new nsRange();
    1:     rv = range->SelectNode(node);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     docEncoder->SetRange(range);
    1:     nsString elementHTML;
    1:     rv = docEncoder->EncodeToString(elementHTML);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     mTagText = ToNewUTF8String(elementHTML);
    1:     if (!mTagText)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   *result = mTagText;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetParameters(PRUint16& n, const char*const*& names, const char*const*& values)
    1: {
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   n = mNumCachedParams;
    1:   if (n) {
    1:     names  = (const char **)(mCachedAttrParamNames + mNumCachedAttrs + 1);
    1:     values = (const char **)(mCachedAttrParamValues + mNumCachedAttrs + 1);
    1:   } else
    1:     names = values = nsnull;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetParameter(const char* name, const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(name);
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *result = nsnull;
    1: 
    1:   for (int i = mNumCachedAttrs + 1; i < (mNumCachedParams + 1 + mNumCachedAttrs); i++) {
    1:     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
    1:       *result = mCachedAttrParamValues[i];
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentBase(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   nsresult rv = NS_OK;
    1:   if (mDocumentBase.IsEmpty()) {
34679:     if (!mObjectFrame) {
    1:       *result = nsnull;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
80526:     nsIDocument* doc = mContent->OwnerDoc();
    1:     NS_ASSERTION(doc, "Must have an owner doc");
41900:     rv = doc->GetDocBaseURI()->GetSpec(mDocumentBase);
    1:   }
    1:   if (NS_SUCCEEDED(rv))
    1:     *result = ToNewCString(mDocumentBase);
    1:   return rv;
    1: }
    1: 
    1: static nsDataHashtable<nsDepCharHashKey, const char *> * gCharsetMap;
    1: typedef struct {
    1:     char mozName[16];
    1:     char javaName[12];
    1: } moz2javaCharset;
    1: 
    1: /* XXX If you add any strings longer than
    1:  *  {"x-mac-cyrillic",  "MacCyrillic"},
    1:  *  {"x-mac-ukrainian", "MacUkraine"},
    1:  * to the following array then you MUST update the
    1:  * sizes of the arrays in the moz2javaCharset struct
    1:  */
    1: 
    1: static const moz2javaCharset charsets[] = 
    1: {
    1:     {"windows-1252",    "Cp1252"},
    1:     {"IBM850",          "Cp850"},
    1:     {"IBM852",          "Cp852"},
    1:     {"IBM855",          "Cp855"},
    1:     {"IBM857",          "Cp857"},
    1:     {"IBM828",          "Cp862"},
    1:     {"IBM864",          "Cp864"},
    1:     {"IBM866",          "Cp866"},
    1:     {"windows-1250",    "Cp1250"},
    1:     {"windows-1251",    "Cp1251"},
    1:     {"windows-1253",    "Cp1253"},
    1:     {"windows-1254",    "Cp1254"},
    1:     {"windows-1255",    "Cp1255"},
    1:     {"windows-1256",    "Cp1256"},
    1:     {"windows-1257",    "Cp1257"},
    1:     {"windows-1258",    "Cp1258"},
    1:     {"EUC-JP",          "EUC_JP"},
    1:     {"EUC-KR",          "EUC_KR"},
    1:     {"x-euc-tw",        "EUC_TW"},
    1:     {"gb18030",         "GB18030"},
64407:     {"gbk",             "GBK"},
    1:     {"ISO-2022-JP",     "ISO2022JP"},
    1:     {"ISO-2022-KR",     "ISO2022KR"},
    1:     {"ISO-8859-2",      "ISO8859_2"},
    1:     {"ISO-8859-3",      "ISO8859_3"},
    1:     {"ISO-8859-4",      "ISO8859_4"},
    1:     {"ISO-8859-5",      "ISO8859_5"},
    1:     {"ISO-8859-6",      "ISO8859_6"},
    1:     {"ISO-8859-7",      "ISO8859_7"},
    1:     {"ISO-8859-8",      "ISO8859_8"},
    1:     {"ISO-8859-9",      "ISO8859_9"},
    1:     {"ISO-8859-13",     "ISO8859_13"},
    1:     {"x-johab",         "Johab"},
    1:     {"KOI8-R",          "KOI8_R"},
    1:     {"TIS-620",         "MS874"},
    1:     {"x-windows-949",   "MS949"},
    1:     {"x-mac-arabic",    "MacArabic"},
    1:     {"x-mac-croatian",  "MacCroatia"},
    1:     {"x-mac-cyrillic",  "MacCyrillic"},
    1:     {"x-mac-greek",     "MacGreek"},
    1:     {"x-mac-hebrew",    "MacHebrew"},
    1:     {"x-mac-icelandic", "MacIceland"},
    1:     {"x-mac-roman",     "MacRoman"},
    1:     {"x-mac-romanian",  "MacRomania"},
    1:     {"x-mac-ukrainian", "MacUkraine"},
    1:     {"Shift_JIS",       "SJIS"},
    1:     {"TIS-620",         "TIS620"}
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentEncoding(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   *result = nsnull;
    1: 
    1:   nsresult rv;
    1:   // XXX sXBL/XBL2 issue: current doc or owner doc?
    1:   nsCOMPtr<nsIDocument> doc;
    1:   rv = GetDocument(getter_AddRefs(doc));
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get document");
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   const nsCString &charset = doc->GetDocumentCharacterSet();
    1: 
    1:   if (charset.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   // common charsets and those not requiring conversion first
    1:   if (charset.EqualsLiteral("us-ascii")) {
    1:     *result = PL_strdup("US_ASCII");
    1:   } else if (charset.EqualsLiteral("ISO-8859-1") ||
    1:       !nsCRT::strncmp(PromiseFlatCString(charset).get(), "UTF", 3)) {
    1:     *result = ToNewCString(charset);
    1:   } else {
    1:     if (!gCharsetMap) {
    1:       const int NUM_CHARSETS = sizeof(charsets) / sizeof(moz2javaCharset);
    1:       gCharsetMap = new nsDataHashtable<nsDepCharHashKey, const char*>();
    1:       if (!gCharsetMap || !gCharsetMap->Init(NUM_CHARSETS))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       for (PRUint16 i = 0; i < NUM_CHARSETS; i++) {
    1:         gCharsetMap->Put(charsets[i].mozName, charsets[i].javaName);
    1:       }
    1:     }
    1:     // if found mapping, return it; otherwise return original charset
    1:     const char *mapping;
    1:     *result = gCharsetMap->Get(charset.get(), &mapping) ? PL_strdup(mapping) :
    1:                                                           ToNewCString(charset);
    1:   }
    1: 
    1:   return (*result) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAlignment(const char* *result)
    1: {
    1:   return GetAttribute("ALIGN", result);
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetWidth(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   *result = mPluginWindow->width;
    1: 
    1:   return NS_OK;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetHeight(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   *result = mPluginWindow->height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetBorderVertSpace(PRUint32 *result)
    1: {
    1:   nsresult    rv;
    1:   const char  *vspace;
    1: 
    1:   rv = GetAttribute("VSPACE", &vspace);
    1: 
    1:   if (NS_OK == rv) {
    1:     if (*result != 0)
    1:       *result = (PRUint32)atol(vspace);
    1:     else
    1:       *result = 0;
    1:   }
    1:   else
    1:     *result = 0;
    1: 
    1:   return rv;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetBorderHorizSpace(PRUint32 *result)
    1: {
    1:   nsresult    rv;
    1:   const char  *hspace;
    1: 
    1:   rv = GetAttribute("HSPACE", &hspace);
    1: 
    1:   if (NS_OK == rv) {
    1:     if (*result != 0)
    1:       *result = (PRUint32)atol(hspace);
    1:     else
    1:       *result = 0;
    1:   }
    1:   else
    1:     *result = 0;
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Cache the attributes and/or parameters of our tag into a single set
44203: // of arrays to be compatible with Netscape 4.x. The attributes go first,
    1: // followed by a PARAM/null and then any PARAM tags. Also, hold the
    1: // cached array around for the duration of the life of the instance
44203: // because Netscape 4.x did. See bug 111008.
    1: nsresult nsPluginInstanceOwner::EnsureCachedAttrParamArrays()
    1: {
    1:   if (mCachedAttrParamValues)
    1:     return NS_OK;
    1: 
    1:   NS_PRECONDITION(((mNumCachedAttrs + mNumCachedParams) == 0) &&
    1:                     !mCachedAttrParamNames,
    1:                   "re-cache of attrs/params not implemented! use the DOM "
    1:                     "node directy instead");
    1: 
44203:   // Convert to a 16-bit count. Subtract 2 in case we add an extra
44203:   // "src" or "wmode" entry below.
    1:   PRUint32 cattrs = mContent->GetAttrCount();
44203:   if (cattrs < 0x0000FFFD) {
 3233:     mNumCachedAttrs = static_cast<PRUint16>(cattrs);
    1:   } else {
44203:     mNumCachedAttrs = 0xFFFD;
    1:   }
    1: 
    1:   // now, we need to find all the PARAM tags that are children of us
44203:   // however, be careful not to include any PARAMs that don't have us
    1:   // as a direct parent. For nested object (or applet) tags, be sure
    1:   // to only round up the param tags that coorespond with THIS
    1:   // instance. And also, weed out any bogus tags that may get in the
    1:   // way, see bug 39609. Then, with any param tag that meet our
    1:   // qualification, temporarly cache them in an nsCOMArray until
    1:   // we can figure out what size to make our fixed char* array.
    1:   nsCOMArray<nsIDOMElement> ourParams;
    1: 
44203:   // Get all dependent PARAM tags, even if they are not direct children.
    1:   nsCOMPtr<nsIDOMElement> mydomElement = do_QueryInterface(mContent);
    1:   NS_ENSURE_TRUE(mydomElement, NS_ERROR_NO_INTERFACE);
    1: 
44203:   // Making DOM method calls can cause our frame to go away.
44203:   nsCOMPtr<nsIPluginInstanceOwner> kungFuDeathGrip(this);
44203: 
    1:   nsCOMPtr<nsIDOMNodeList> allParams;
    1:   NS_NAMED_LITERAL_STRING(xhtml_ns, "http://www.w3.org/1999/xhtml");
    1:   mydomElement->GetElementsByTagNameNS(xhtml_ns, NS_LITERAL_STRING("param"),
    1:                                        getter_AddRefs(allParams));
    1:   if (allParams) {
    1:     PRUint32 numAllParams; 
    1:     allParams->GetLength(&numAllParams);
    1:     for (PRUint32 i = 0; i < numAllParams; i++) {
    1:       nsCOMPtr<nsIDOMNode> pnode;
    1:       allParams->Item(i, getter_AddRefs(pnode));
    1:       nsCOMPtr<nsIDOMElement> domelement = do_QueryInterface(pnode);
    1:       if (domelement) {
44203:         // Ignore params without a name attribute.
    1:         nsAutoString name;
    1:         domelement->GetAttribute(NS_LITERAL_STRING("name"), name);
    1:         if (!name.IsEmpty()) {
44203:           // Find the first object or applet parent.
    1:           nsCOMPtr<nsIDOMNode> parent;
    1:           nsCOMPtr<nsIDOMHTMLObjectElement> domobject;
    1:           nsCOMPtr<nsIDOMHTMLAppletElement> domapplet;
    1:           pnode->GetParentNode(getter_AddRefs(parent));
    1:           while (!(domobject || domapplet) && parent) {
    1:             domobject = do_QueryInterface(parent);
    1:             domapplet = do_QueryInterface(parent);
    1:             nsCOMPtr<nsIDOMNode> temp;
    1:             parent->GetParentNode(getter_AddRefs(temp));
    1:             parent = temp;
    1:           }
    1:           if (domapplet || domobject) {
44203:             if (domapplet) {
    1:               parent = domapplet;
44203:             }
44203:             else {
    1:               parent = domobject;
44203:             }
    1:             nsCOMPtr<nsIDOMNode> mydomNode = do_QueryInterface(mydomElement);
    1:             if (parent == mydomNode) {
    1:               ourParams.AppendObject(domelement);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
44203:   // Convert to a 16-bit count.
44203:   PRUint32 cparams = ourParams.Count();
44203:   if (cparams < 0x0000FFFF) {
 3233:     mNumCachedParams = static_cast<PRUint16>(cparams);
44203:   } else {
    1:     mNumCachedParams = 0xFFFF;
44203:   }
44203: 
44203:   PRUint16 numRealAttrs = mNumCachedAttrs;
    1: 
    1:   // Some plugins were never written to understand the "data" attribute of the OBJECT tag.
    1:   // Real and WMP will not play unless they find a "src" attribute, see bug 152334.
    1:   // Nav 4.x would simply replace the "data" with "src". Because some plugins correctly
    1:   // look for "data", lets instead copy the "data" attribute and add another entry
    1:   // to the bottom of the array if there isn't already a "src" specified.
    1:   nsAutoString data;
44203:   if (mContent->Tag() == nsGkAtoms::object &&
44203:       !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::src) &&
47341:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::data, data) &&
47341:       !data.IsEmpty()) {
    1:     mNumCachedAttrs++;
    1:   }
    1: 
34217:   // "plugins.force.wmode" preference is forcing wmode type for plugins
34181:   // possible values - "opaque", "transparent", "windowed"
70976:   nsAdoptingCString wmodeType = Preferences::GetCString("plugins.force.wmode");
44203:   if (!wmodeType.IsEmpty()) {
34181:     mNumCachedAttrs++;
44203:   }
44203: 
44203:   mCachedAttrParamNames  = (char**)NS_Alloc(sizeof(char*) * (mNumCachedAttrs + 1 + mNumCachedParams));
    1:   NS_ENSURE_TRUE(mCachedAttrParamNames,  NS_ERROR_OUT_OF_MEMORY);
44203:   mCachedAttrParamValues = (char**)NS_Alloc(sizeof(char*) * (mNumCachedAttrs + 1 + mNumCachedParams));
    1:   NS_ENSURE_TRUE(mCachedAttrParamValues, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Some plugins (eg Flash, see bug 234675.) are actually sensitive to the
    1:   // attribute order.  So we want to make sure we give the plugin the
    1:   // attributes in the order they came in in the source, to be compatible with
    1:   // other browsers.  Now in HTML, the storage order is the reverse of the
    1:   // source order, while in XML and XHTML it's the same as the source order
    1:   // (see the AddAttributes functions in the HTML and XML content sinks).
44203:   PRInt32 start, end, increment;
33329:   if (mContent->IsHTML() &&
29004:       mContent->IsInHTMLDocument()) {
    1:     // HTML.  Walk attributes in reverse order.
    1:     start = numRealAttrs - 1;
    1:     end = -1;
    1:     increment = -1;
    1:   } else {
    1:     // XHTML or XML.  Walk attributes in forward order.
    1:     start = 0;
    1:     end = numRealAttrs;
    1:     increment = 1;
    1:   }
44203: 
44203:   // Set to the next slot to fill in name and value cache arrays.
44203:   PRUint32 nextAttrParamIndex = 0;
44203: 
80591:   // Whether or not we force the wmode below while traversing
80591:   // the name/value pairs.
80591:   bool wmodeSet = false;
44203: 
44203:   // Add attribute name/value pairs.
44203:   for (PRInt32 index = start; index != end; index += increment) {
    1:     const nsAttrName* attrName = mContent->GetAttrNameAt(index);
    1:     nsIAtom* atom = attrName->LocalName();
    1:     nsAutoString value;
    1:     mContent->GetAttr(attrName->NamespaceID(), atom, value);
    1:     nsAutoString name;
    1:     atom->ToString(name);
    1: 
    1:     FixUpURLS(name, value);
    1: 
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(name);
80591:     if (!wmodeType.IsEmpty() && 
80591:         0 == PL_strcasecmp(mCachedAttrParamNames[nextAttrParamIndex], "wmode")) {
80591:       mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(NS_ConvertUTF8toUTF16(wmodeType));
80591: 
80591:       if (!wmodeSet) {
80591:         // We allocated space to add a wmode attr, but we don't need it now.
80591:         mNumCachedAttrs--;
80591:         wmodeSet = true;
80591:       }
80591:     } else {
44203:       mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(value);
80591:     }
80591:     nextAttrParamIndex++;
80591:   }
80591: 
80591:   // Potentially add WMODE attribute.
80591:   if (!wmodeType.IsEmpty() && !wmodeSet) {
80591:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("wmode"));
80591:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(NS_ConvertUTF8toUTF16(wmodeType));
44203:     nextAttrParamIndex++;
44203:   }
44203: 
44203:   // Potentially add SRC attribute.
44203:   if (!data.IsEmpty()) {
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("SRC"));
44203:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(data);
44203:     nextAttrParamIndex++;
44203:   }
44203: 
44203:   // Add PARAM and null separator.
44203:   mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("PARAM"));
82142: #ifdef MOZ_WIDGET_ANDROID
78424:   // Flash expects an empty string on android
78424:   mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING(""));
78424: #else
78410:   mCachedAttrParamValues[nextAttrParamIndex] = nsnull;
78424: #endif
44203:   nextAttrParamIndex++;
44203: 
44203:   // Add PARAM name/value pairs.
44203:   for (PRUint16 i = 0; i < mNumCachedParams; i++) {
44203:     nsIDOMElement* param = ourParams.ObjectAt(i);
44203:     if (!param) {
44203:       continue;
44203:     }
44203: 
    1:     nsAutoString name;
    1:     nsAutoString value;
    1:     param->GetAttribute(NS_LITERAL_STRING("name"), name); // check for empty done above
    1:     param->GetAttribute(NS_LITERAL_STRING("value"), value);
    1:     
    1:     FixUpURLS(name, value);
    1: 
    1:     /*
    1:      * According to the HTML 4.01 spec, at
    1:      * http://www.w3.org/TR/html4/types.html#type-cdata
    1:      * ''User agents may ignore leading and trailing
    1:      * white space in CDATA attribute values (e.g., "
    1:      * myval " may be interpreted as "myval"). Authors
    1:      * should not declare attribute values with
    1:      * leading or trailing white space.''
    1:      * However, do not trim consecutive spaces as in bug 122119
    1:      */
79533:     name.Trim(" \n\r\t\b", true, true, false);
79533:     value.Trim(" \n\r\t\b", true, true, false);
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(name);
44203:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(value);
44203:     nextAttrParamIndex++;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MACOSX
    1: 
32972: #ifndef NP_NO_CARBON
68631: static void InitializeEventRecord(EventRecord* event, ::Point* aMousePosition)
    1: {
    1:   memset(event, 0, sizeof(EventRecord));
31130:   if (aMousePosition) {
31130:     event->where = *aMousePosition;
31130:   } else {
    1:     ::GetGlobalMouse(&event->where);
31130:   }
    1:   event->when = ::TickCount();
33068:   event->modifiers = ::GetCurrentKeyModifiers();
    1: }
32972: #endif
    1: 
32019: static void InitializeNPCocoaEvent(NPCocoaEvent* event)
32019: {
32019:   memset(event, 0, sizeof(NPCocoaEvent));
32019: }
32019: 
  130: NPDrawingModel nsPluginInstanceOwner::GetDrawingModel()
  130: {
  130: #ifndef NP_NO_QUICKDRAW
  130:   NPDrawingModel drawingModel = NPDrawingModelQuickDraw;
  130: #else
  130:   NPDrawingModel drawingModel = NPDrawingModelCoreGraphics;
  130: #endif
  130: 
  130:   if (!mInstance)
  130:     return drawingModel;
  130: 
32799:   mInstance->GetDrawingModel((PRInt32*)&drawingModel);
  130:   return drawingModel;
  130: }
  130: 
79445: bool nsPluginInstanceOwner::IsRemoteDrawingCoreAnimation()
72866: {
72866:   if (!mInstance)
79533:     return false;
72866: 
79445:   bool coreAnimation;
72866:   if (!NS_SUCCEEDED(mInstance->IsRemoteDrawingCoreAnimation(&coreAnimation)))
79533:     return false;
72866: 
72866:   return coreAnimation;
72866: }
72866: 
32019: NPEventModel nsPluginInstanceOwner::GetEventModel()
32019: {
34717:   return mEventModel;
32019: }
32019: 
39757: #define DEFAULT_REFRESH_RATE 20 // 50 FPS
39757: 
39757: nsCOMPtr<nsITimer>                *nsPluginInstanceOwner::sCATimer = NULL;
39757: nsTArray<nsPluginInstanceOwner*>  *nsPluginInstanceOwner::sCARefreshListeners = NULL;
39757: 
39757: void nsPluginInstanceOwner::CARefresh(nsITimer *aTimer, void *aClosure) {
39757:   if (!sCARefreshListeners) {
39757:     return;
39757:   }
39757:   for (size_t i = 0; i < sCARefreshListeners->Length(); i++) {
39757:     nsPluginInstanceOwner* instanceOwner = (*sCARefreshListeners)[i];
39757:     NPWindow *window;
39757:     instanceOwner->GetWindow(window);
39757:     if (!window) {
39757:       continue;
39757:     }
39757:     NPRect r;
39757:     r.left = 0;
39757:     r.top = 0;
39757:     r.right = window->width;
39757:     r.bottom = window->height; 
39757:     instanceOwner->InvalidateRect(&r);
39757:   }
39757: }
39757: 
90335: void nsPluginInstanceOwner::AddToCARefreshTimer() {
90335:   if (!mInstance) {
90335:     return;
90335:   }
90335: 
90335:   // Flash invokes InvalidateRect for us.
90335:   const char* mime = nsnull;
90335:   if (NS_SUCCEEDED(mInstance->GetMIMEType(&mime)) && mime) {
90335:     if (strcmp(mime, "application/x-shockwave-flash") == 0) {
90335:       return;
90335:     }
90335:   }
90335: 
39757:   if (!sCARefreshListeners) {
39757:     sCARefreshListeners = new nsTArray<nsPluginInstanceOwner*>();
39757:     if (!sCARefreshListeners) {
39757:       return;
39757:     }
39757:   }
39757: 
90335:   if (sCARefreshListeners->Contains(this)) {
90335:     return;
90335:   }
90335: 
90335:   sCARefreshListeners->AppendElement(this);
39757: 
39757:   if (!sCATimer) {
39757:     sCATimer = new nsCOMPtr<nsITimer>();
39757:     if (!sCATimer) {
39757:       return;
39757:     }
39757:   }
39757: 
39757:   if (sCARefreshListeners->Length() == 1) {
39757:     *sCATimer = do_CreateInstance("@mozilla.org/timer;1");
39757:     (*sCATimer)->InitWithFuncCallback(CARefresh, NULL, 
39757:                    DEFAULT_REFRESH_RATE, nsITimer::TYPE_REPEATING_SLACK);
39757:   }
39757: }
39757: 
90335: void nsPluginInstanceOwner::RemoveFromCARefreshTimer() {
90335:   if (!sCARefreshListeners || sCARefreshListeners->Contains(this) == false) {
39757:     return;
39757:   }
42504: 
90335:   sCARefreshListeners->RemoveElement(this);
42504: 
39757:   if (sCARefreshListeners->Length() == 0) {
39757:     if (sCATimer) {
39757:       (*sCATimer)->Cancel();
39757:       delete sCATimer;
39757:       sCATimer = NULL;
39757:     }
39757:     delete sCARefreshListeners;
39757:     sCARefreshListeners = NULL;
39757:   }
39757: }
39757: 
42504: void nsPluginInstanceOwner::RenderCoreAnimation(CGContextRef aCGContext,
42504:                                                 int aWidth, int aHeight)
42504: {
42504:   if (aWidth == 0 || aHeight == 0)
42504:     return;
42504: 
42504:   if (!mIOSurface ||
43369:       (mIOSurface->GetWidth() != (size_t)aWidth ||
43369:        mIOSurface->GetHeight() != (size_t)aHeight)) {
74046:     mIOSurface = nsnull;
42504: 
42504:     // If the renderer is backed by an IOSurface, resize it as required.
42504:     mIOSurface = nsIOSurface::CreateIOSurface(aWidth, aHeight);
42504:     if (mIOSurface) {
73761:       nsRefPtr<nsIOSurface> attachSurface = nsIOSurface::LookupSurface(
42504:                                               mIOSurface->GetIOSurfaceID());
42504:       if (attachSurface) {
42504:         mCARenderer.AttachIOSurface(attachSurface);
42504:       } else {
42504:         NS_ERROR("IOSurface attachment failed");
74046:         mIOSurface = nsnull;
42504:       }
42504:     }
42504:   }
42504: 
67592:   if (!mColorProfile) {
67592:     mColorProfile = CreateSystemColorSpace();
67592:   }
67592: 
42504:   if (mCARenderer.isInit() == false) {
39757:     void *caLayer = NULL;
63555:     nsresult rv = mInstance->GetValueFromPlugin(NPPVpluginCoreAnimationLayer, &caLayer);
63555:     if (NS_FAILED(rv) || !caLayer) {
39757:       return;
39757:     }
42504: 
80957:     // We don't run Flash in-process so we can unconditionally disallow
80957:     // the offliner renderer.
80957:     mCARenderer.SetupRenderer(caLayer, aWidth, aHeight, DISALLOW_OFFLINE_RENDERER);
42504: 
42504:     // Setting up the CALayer requires resetting the painting otherwise we
42504:     // get garbage for the first few frames.
42504:     FixUpPluginWindow(ePluginPaintDisable);
42504:     FixUpPluginWindow(ePluginPaintEnable);
42504:   }
42504: 
41029:   CGImageRef caImage = NULL;
41029:   nsresult rt = mCARenderer.Render(aWidth, aHeight, &caImage);
67592:   if (rt == NS_OK && mIOSurface && mColorProfile) {
67592:     nsCARenderer::DrawSurfaceToCGContext(aCGContext, mIOSurface, mColorProfile,
42504:                                          0, 0, aWidth, aHeight);
42504:   } else if (rt == NS_OK && caImage != NULL) {
41029:     // Significant speed up by resetting the scaling
41029:     ::CGContextSetInterpolationQuality(aCGContext, kCGInterpolationNone );
41029:     ::CGContextTranslateCTM(aCGContext, 0, aHeight);
41029:     ::CGContextScaleCTM(aCGContext, 1.0, -1.0);
41029: 
41029:     ::CGContextDrawImage(aCGContext, CGRectMake(0,0,aWidth,aHeight), caImage);
42504:   } else {
42504:     NS_NOTREACHED("nsCARenderer::Render failure");
41029:   }
39757: }
39757: 
32799: void* nsPluginInstanceOwner::GetPluginPortCopy()
32799: {
32799: #ifndef NP_NO_QUICKDRAW
32799:   if (GetDrawingModel() == NPDrawingModelQuickDraw)
32799:     return &mQDPluginPortCopy;
32799: #endif
39757:   if (GetDrawingModel() == NPDrawingModelCoreGraphics || 
43370:       GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:       GetDrawingModel() == NPDrawingModelInvalidatingCoreAnimation)
32799:     return &mCGPluginPortCopy;
32799:   return nsnull;
32799: }
32799:   
21108: // Currently (on OS X in Cocoa widgets) any changes made as a result of
37446: // calling GetPluginPortFromWidget() are immediately reflected in the NPWindow
21108: // structure that has been passed to the plugin via SetWindow().  This is
21108: // because calls to nsChildView::GetNativeData(NS_NATIVE_PLUGIN_PORT_CG)
21108: // always return a pointer to the same internal (private) object, but may
37446: // make changes inside that object.  All calls to GetPluginPortFromWidget() made while
21108: // the plugin is active (i.e. excluding those made at our initialization)
21108: // need to take this into account.  The easiest way to do so is to replace
21108: // them with calls to SetPluginPortAndDetectChange().  This method keeps track
37446: // of when calls to GetPluginPortFromWidget() result in changes, and sets a flag to make
21108: // sure SetWindow() gets called the next time through FixUpPluginWindow(), so
21108: // that the plugin is notified of these changes.
32799: void* nsPluginInstanceOwner::SetPluginPortAndDetectChange()
21108: {
21108:   if (!mPluginWindow)
21108:     return nsnull;
37446:   void* pluginPort = GetPluginPortFromWidget();
21108:   if (!pluginPort)
21108:     return nsnull;
21108:   mPluginWindow->window = pluginPort;
21108: 
32972: #ifndef NP_NO_QUICKDRAW
21108:   NPDrawingModel drawingModel = GetDrawingModel();
21108:   if (drawingModel == NPDrawingModelQuickDraw) {
32799:     NP_Port* windowQDPort = static_cast<NP_Port*>(mPluginWindow->window);
32799:     if (windowQDPort->port != mQDPluginPortCopy.port) {
32799:       mQDPluginPortCopy.port = windowQDPort->port;
79533:       mPluginPortChanged = true;
21108:     }
39757:   } else if (drawingModel == NPDrawingModelCoreGraphics || 
43370:              drawingModel == NPDrawingModelCoreAnimation ||
43370:              drawingModel == NPDrawingModelInvalidatingCoreAnimation)
21108: #endif
21108:   {
34737: #ifndef NP_NO_CARBON
34717:     if (GetEventModel() == NPEventModelCarbon) {
32799:       NP_CGContext* windowCGPort = static_cast<NP_CGContext*>(mPluginWindow->window);
32799:       if ((windowCGPort->context != mCGPluginPortCopy.context) ||
32799:           (windowCGPort->window != mCGPluginPortCopy.window)) {
32799:         mCGPluginPortCopy.context = windowCGPort->context;
32799:         mCGPluginPortCopy.window = windowCGPort->window;
79533:         mPluginPortChanged = true;
21108:       }
21108:     }
34737: #endif
34717:   }
21108: 
21108:   return mPluginWindow->window;
21108: }
21108: 
21108: void nsPluginInstanceOwner::BeginCGPaint()
21108: {
21108:   ++mInCGPaintLevel;
21108: }
21108: 
21108: void nsPluginInstanceOwner::EndCGPaint()
21108: {
21108:   --mInCGPaintLevel;
32019:   NS_ASSERTION(mInCGPaintLevel >= 0, "Mismatched call to nsPluginInstanceOwner::EndCGPaint()!");
21108: }
21108: 
    1: #endif
    1: 
24543: // static
24543: PRUint32
24543: nsPluginInstanceOwner::GetEventloopNestingLevel()
24543: {
24543:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
24543:   PRUint32 currentLevel = 0;
24543:   if (appShell) {
24543:     appShell->GetEventloopNestingLevel(&currentLevel);
24543: #ifdef XP_MACOSX
24543:     // Cocoa widget code doesn't process UI events through the normal
24543:     // appshell event loop, so it needs an additional count here.
24543:     currentLevel++;
24543: #endif
24543:   }
24543: 
24543:   // No idea how this happens... but Linux doesn't consistently
24543:   // process UI events through the appshell event loop. If we get a 0
24543:   // here on any platform we increment the level just in case so that
24543:   // we make sure we always tear the plugin down eventually.
24543:   if (!currentLevel) {
24543:     currentLevel++;
24543:   }
24543: 
24543:   return currentLevel;
24543: }
24543: 
37871: void nsPluginInstanceOwner::ScrollPositionWillChange(nscoord aX, nscoord aY)
    1: {
36227: #ifdef MAC_CARBON_PLUGINS
32019:   if (GetEventModel() != NPEventModelCarbon)
37871:     return;
32019: 
    1:   CancelTimer();
    1: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:       EventRecord scrollEvent;
31130:       InitializeEventRecord(&scrollEvent, nsnull);
30189:       scrollEvent.what = NPEventType_ScrollingBeginsEvent;
    1: 
32019:       void* window = FixUpPluginWindow(ePluginPaintDisable);
  130:       if (window) {
43436:         mInstance->HandleEvent(&scrollEvent, nsnull);
    1:       }
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
37871: }
37871: 
37871: void nsPluginInstanceOwner::ScrollPositionDidChange(nscoord aX, nscoord aY)
    1: {
36227: #ifdef MAC_CARBON_PLUGINS
32019:   if (GetEventModel() != NPEventModelCarbon)
37871:     return;
32019: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:       EventRecord scrollEvent;
31130:       InitializeEventRecord(&scrollEvent, nsnull);
30189:       scrollEvent.what = NPEventType_ScrollingEndsEvent;
    1: 
32019:       void* window = FixUpPluginWindow(ePluginPaintEnable);
  130:       if (window) {
43436:         mInstance->HandleEvent(&scrollEvent, nsnull);
    1:       }
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
82142: #ifdef MOZ_WIDGET_ANDROID
89219: 
89219: void nsPluginInstanceOwner::SendSize(int width, int height)
89219: {
89219:   if (!mInstance)
89219:     return;
89219: 
89219:   PRInt32 model = mInstance->GetANPDrawingModel();
89219: 
89219:   if (model != kOpenGL_ANPDrawingModel)
89219:     return;
89219: 
89219:   ANPEvent event;
89219:   event.inSize = sizeof(ANPEvent);
89219:   event.eventType = kDraw_ANPEventType;
89219:   event.data.draw.model = kOpenGL_ANPDrawingModel;
89219:   event.data.draw.data.surfaceSize.width = width;
89219:   event.data.draw.data.surfaceSize.height = height;
89219: 
89219:   mInstance->HandleEvent(&event, nsnull);
89219: }
89219: 
82979: bool nsPluginInstanceOwner::AddPluginView(const gfxRect& aRect)
80592: {
80592:   void* javaSurface = mInstance->GetJavaSurface();
82979:   if (!javaSurface) {
82979:     mInstance->RequestJavaSurface();
82979:     return false;
82979:   }
82979: 
80592:   JNIEnv* env = GetJNIForThread();
88498:   if (!env)
88498:     return false;
88498: 
88498:   AndroidBridge::AutoLocalJNIFrame frame(env, 1);
88498: 
80592:   jclass cls = env->FindClass("org/mozilla/gecko/GeckoAppShell");
87659: 
87659: #ifdef MOZ_JAVA_COMPOSITOR
87659:   nsAutoString metadata;
87659:   nsCOMPtr<nsIAndroidDrawMetadataProvider> metadataProvider =
87659:       AndroidBridge::Bridge()->GetDrawMetadataProvider();
87659:   metadataProvider->GetDrawMetadata(metadata);
87659: 
87659:   jstring jMetadata = env->NewString(nsPromiseFlatString(metadata).get(), metadata.Length());
87659: 
87659:   jmethodID method = env->GetStaticMethodID(cls,
87659:                                             "addPluginView",
87659:                                             "(Landroid/view/View;IIIILjava/lang/String;)V");
87659: 
87659:   env->CallStaticVoidMethod(cls,
87659:                             method,
87659:                             javaSurface,
87659:                             (int)aRect.x,
87659:                             (int)aRect.y,
87659:                             (int)aRect.width,
87659:                             (int)aRect.height,
87659:                             jMetadata);
87659: #else
80592:   jmethodID method = env->GetStaticMethodID(cls,
80592:                                             "addPluginView",
80592:                                             "(Landroid/view/View;DDDD)V");
82979: 
80592:   env->CallStaticVoidMethod(cls,
80592:                             method,
80592:                             javaSurface,
80592:                             aRect.x,
80592:                             aRect.y,
80592:                             aRect.width,
80592:                             aRect.height);
87659: #endif
82979: 
82979:   return true;
80592: }
80592: 
78424: void nsPluginInstanceOwner::RemovePluginView()
78424: {
90194:   if (!mInstance || !mObjectFrame)
88506:     return;
88506: 
78424:   void* surface = mInstance->GetJavaSurface();
88498:   if (!surface)
88498:     return;
88498: 
78424:   JNIEnv* env = GetJNIForThread();
88498:   if (!env)
88498:     return;
88498: 
88498:   AndroidBridge::AutoLocalJNIFrame frame(env, 1);
88498: 
78424:   jclass cls = env->FindClass("org/mozilla/gecko/GeckoAppShell");
78424:   jmethodID method = env->GetStaticMethodID(cls,
78424:                                             "removePluginView",
78424:                                             "(Landroid/view/View;)V");
78424:   env->CallStaticVoidMethod(cls, method, surface);
89219: }
89219: 
89219: void nsPluginInstanceOwner::Invalidate() {
89219:   NPRect rect;
89219:   rect.left = rect.top = 0;
89219:   rect.right = mPluginWindow->width;
89219:   rect.bottom = mPluginWindow->height;
89219:   InvalidateRect(&rect);
89219: }
89219: 
78424: #endif
78424: 
    1: nsresult nsPluginInstanceOwner::DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent)
    1: {
82142: #ifdef MOZ_WIDGET_ANDROID
78424:   {
78424:     ANPEvent event;
78424:     event.inSize = sizeof(ANPEvent);
78424:     event.eventType = kLifecycle_ANPEventType;
78424: 
78424:     nsAutoString eventType;
78424:     aFocusEvent->GetType(eventType);
78424:     if (eventType.EqualsLiteral("focus")) {
78424:       event.data.lifecycle.action = kGainFocus_ANPLifecycleAction;
78424:     }
78424:     else if (eventType.EqualsLiteral("blur")) {
78424:       event.data.lifecycle.action = kLoseFocus_ANPLifecycleAction;
78424:     }
78424:     else {
79533:       NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchFocusToPlugin, wierd eventType");   
78424:     }
78424:     mInstance->HandleEvent(&event, nsnull);
78424:   }
78424: #endif
78424: 
    1: #ifndef XP_MACOSX
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow)) {
    1:     // continue only for cases without child window
    1:     return aFocusEvent->PreventDefault(); // consume event
    1:   }
    1: #endif
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aFocusEvent));
    1:   if (privateEvent) {
20234:     nsEvent * theEvent = privateEvent->GetInternalNSEvent();
    1:     if (theEvent) {
    1:       // we only care about the message in ProcessEvent
    1:       nsGUIEvent focusEvent(NS_IS_TRUSTED_EVENT(theEvent), theEvent->message,
    1:                             nsnull);
    1:       nsEventStatus rv = ProcessEvent(focusEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         aFocusEvent->PreventDefault();
    1:         aFocusEvent->StopPropagation();
    1:       }
    1:     }
79533:     else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchFocusToPlugin failed, focusEvent null");   
79533:   }
79533:   else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchFocusToPlugin failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }    
    1: 
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498: nsresult nsPluginInstanceOwner::Text(nsIDOMEvent* aTextEvent)
77498: {
77498:   if (mInstance) {
77498:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aTextEvent));
77498:     if (privateEvent) {
77498:       nsEvent *event = privateEvent->GetInternalNSEvent();
77498:       if (event && event->eventStructType == NS_TEXT_EVENT) {
77498:         nsEventStatus rv = ProcessEvent(*static_cast<nsGUIEvent*>(event));
77498:         if (nsEventStatus_eConsumeNoDefault == rv) {
77498:           aTextEvent->PreventDefault();
77498:           aTextEvent->StopPropagation();
77498:         }
77498:       }
79533:       else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchTextToPlugin failed, textEvent null");
79533:     }
79533:     else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchTextToPlugin failed, privateEvent null");
77498:   }
77498: 
77498:   return NS_OK;
77498: }
77498: #endif
77498: 
    1: nsresult nsPluginInstanceOwner::KeyPress(nsIDOMEvent* aKeyEvent)
    1: {
39851: #ifdef XP_MACOSX
39851: #ifndef NP_NO_CARBON
39851:   if (GetEventModel() == NPEventModelCarbon) {
    1:     // KeyPress events are really synthesized keyDown events.
    1:     // Here we check the native message of the event so that
    1:     // we won't send the plugin two keyDown events.
    1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
    1:     if (privateEvent) {
20234:       nsEvent *theEvent = privateEvent->GetInternalNSEvent();
75043:       const EventRecord *ev;
75043:       if (theEvent &&
75043:           theEvent->message == NS_KEY_PRESS &&
75043:           (ev = (EventRecord*)(((nsGUIEvent*)theEvent)->pluginEvent)) &&
    1:           ev->what == keyDown)
    1:         return aKeyEvent->PreventDefault(); // consume event
    1:     }
    1: 
    1:     // Nasty hack to avoid recursive event dispatching with Java. Java can
    1:     // dispatch key events to a TSM handler, which comes back and calls 
    1:     // [ChildView insertText:] on the cocoa widget, which sends a key
    1:     // event back down.
79445:     static bool sInKeyDispatch = false;
    1: 
    1:     if (sInKeyDispatch)
    1:       return aKeyEvent->PreventDefault(); // consume event
    1: 
79533:     sInKeyDispatch = true;
    1:     nsresult rv =  DispatchKeyToPlugin(aKeyEvent);
79533:     sInKeyDispatch = false;
    1:     return rv;
39851:   }
39851: #endif
39851: 
39851:   return DispatchKeyToPlugin(aKeyEvent);
    1: #else
22788:   if (SendNativeEvents())
25280:     DispatchKeyToPlugin(aKeyEvent);
22788: 
    1:   if (mInstance) {
    1:     // If this event is going to the plugin, we want to kill it.
    1:     // Not actually sending keypress to the plugin, since we didn't before.
    1:     aKeyEvent->PreventDefault();
    1:     aKeyEvent->StopPropagation();
    1:   }
    1:   return NS_OK;
    1: #endif
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent)
    1: {
70893: #if !defined(XP_MACOSX)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aKeyEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
    1:     if (privateEvent) {
75043:       nsEvent *event = privateEvent->GetInternalNSEvent();
75043:       if (event && event->eventStructType == NS_KEY_EVENT) {
75043:         nsEventStatus rv = ProcessEvent(*static_cast<nsGUIEvent*>(event));
    1:         if (nsEventStatus_eConsumeNoDefault == rv) {
    1:           aKeyEvent->PreventDefault();
    1:           aKeyEvent->StopPropagation();
    1:         }
    1:       }
79533:       else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchKeyToPlugin failed, keyEvent null");   
79533:     }
79533:     else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchKeyToPlugin failed, privateEvent null");   
    1:   }
    1: 
    1:   return NS_OK;
    1: }    
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseDown(nsIDOMEvent* aMouseEvent)
    1: {
70893: #if !defined(XP_MACOSX)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   // if the plugin is windowless, we need to set focus ourselves
    1:   // otherwise, we might not get key events
34679:   if (mObjectFrame && mPluginWindow &&
32799:       mPluginWindow->type == NPWindowTypeDrawable) {
29018:     
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     if (fm) {
29018:       nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(mContent);
29018:       fm->SetFocus(elem, 0);
29018:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
75043:     nsEvent* event = privateEvent->GetInternalNSEvent();
75043:       if (event && event->eventStructType == NS_MOUSE_EVENT) {
75043:         nsEventStatus rv = ProcessEvent(*static_cast<nsGUIEvent*>(event));
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         return aMouseEvent->PreventDefault(); // consume event
    1:       }
    1:     }
79533:     else NS_ASSERTION(false, "nsPluginInstanceOwner::MouseDown failed, mouseEvent null");   
79533:   }
79533:   else NS_ASSERTION(false, "nsPluginInstanceOwner::MouseDown failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent)
    1: {
70893: #if !defined(XP_MACOSX)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
18408:   // don't send mouse events if we are hidden
    1:   if (!mWidgetVisible)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
75043:     nsEvent* event = privateEvent->GetInternalNSEvent();
75043:     if (event && event->eventStructType == NS_MOUSE_EVENT) {
75043:       nsEventStatus rv = ProcessEvent(*static_cast<nsGUIEvent*>(event));
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         aMouseEvent->PreventDefault();
    1:         aMouseEvent->StopPropagation();
    1:       }
    1:     }
79533:     else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, mouseEvent null");   
79533:   }
79533:   else NS_ASSERTION(false, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::HandleEvent(nsIDOMEvent* aEvent)
    1: {
75043:   nsAutoString eventType;
75043:   aEvent->GetType(eventType);
75043:   if (eventType.EqualsLiteral("focus")) {
79533:     mContentFocused = true;
75043:     return DispatchFocusToPlugin(aEvent);
75043:   }
75043:   if (eventType.EqualsLiteral("blur")) {
79533:     mContentFocused = false;
75043:     return DispatchFocusToPlugin(aEvent);
75043:   }
75043:   if (eventType.EqualsLiteral("mousedown")) {
75043:     return MouseDown(aEvent);
75043:   }
75043:   if (eventType.EqualsLiteral("mouseup")) {
75043:     // Don't send a mouse-up event to the plugin if it isn't focused.  This can
75043:     // happen if the previous mouse-down was sent to a DOM element above the
75043:     // plugin, the mouse is still above the plugin, and the mouse-down event
75043:     // caused the element to disappear.  See bug 627649.
75043:     if (!mContentFocused) {
75043:       aEvent->PreventDefault();
75043:       return NS_OK;
75043:     }
75043:     return DispatchMouseToPlugin(aEvent);
75043:   }
75043:   if (eventType.EqualsLiteral("mousemove") ||
75043:       eventType.EqualsLiteral("click") ||
75043:       eventType.EqualsLiteral("dblclick") ||
75043:       eventType.EqualsLiteral("mouseover") ||
75043:       eventType.EqualsLiteral("mouseout")) {
75043:     return DispatchMouseToPlugin(aEvent);
75043:   }
75043:   if (eventType.EqualsLiteral("keydown") ||
75043:       eventType.EqualsLiteral("keyup")) {
75043:     return DispatchKeyToPlugin(aEvent);
75043:   }
75043:   if (eventType.EqualsLiteral("keypress")) {
75043:     return KeyPress(aEvent);
75043:   }
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498:   if (eventType.EqualsLiteral("text")) {
77498:     return Text(aEvent);
77498:   }
77498: #endif
75043: 
75043:   nsCOMPtr<nsIDOMDragEvent> dragEvent(do_QueryInterface(aEvent));
75043:   if (dragEvent && mInstance) {
32034:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aEvent));
75043:     if (privateEvent) {
32034:       nsEvent* ievent = privateEvent->GetInternalNSEvent();
77049:       if ((ievent && NS_IS_TRUSTED_EVENT(ievent)) &&
77049:            ievent->message != NS_DRAGDROP_ENTER && ievent->message != NS_DRAGDROP_OVER) {
77049:         aEvent->PreventDefault();
32034:       }
32034: 
20592:       // Let the plugin handle drag events.
20592:       aEvent->StopPropagation();
20592:     }
20592:   }
    1:   return NS_OK;
    1: }
    1: 
 3060: #ifdef MOZ_X11
 3060: static unsigned int XInputEventState(const nsInputEvent& anEvent)
 3060: {
 3060:   unsigned int state = 0;
 3060:   if (anEvent.isShift) state |= ShiftMask;
 3060:   if (anEvent.isControl) state |= ControlMask;
 3060:   if (anEvent.isAlt) state |= Mod1Mask;
 3060:   if (anEvent.isMeta) state |= Mod4Mask;
 3060:   return state;
 3060: }
 3060: #endif
    1: 
70893: nsEventStatus nsPluginInstanceOwner::ProcessEvent(const nsGUIEvent& anEvent)
25500: {
    1:   nsEventStatus rv = nsEventStatus_eIgnore;
32019: 
34679:   if (!mInstance || !mObjectFrame)   // if mInstance is null, we shouldn't be here
32019:     return nsEventStatus_eIgnore;
    1: 
    1: #ifdef XP_MACOSX
42850:   if (!mWidget)
42850:     return nsEventStatus_eIgnore;
42850: 
32019:   // we never care about synthesized mouse enter
32019:   if (anEvent.message == NS_MOUSE_ENTER_SYNTH)
32019:     return nsEventStatus_eIgnore;
32019: 
    1:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
42850:   if (!pluginWidget || NS_FAILED(pluginWidget->StartDrawPlugin()))
42850:     return nsEventStatus_eIgnore;
42850: 
32019:   NPEventModel eventModel = GetEventModel();
32019: 
32019:   // If we have to synthesize an event we'll use one of these.
32972: #ifndef NP_NO_CARBON
32019:   EventRecord synthCarbonEvent;
32972: #endif
32019:   NPCocoaEvent synthCocoaEvent;
34743:   void* event = anEvent.pluginEvent;
41424:   nsPoint pt =
41424:   nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
68635:   mObjectFrame->GetContentRectRelativeToSelf().TopLeft();
34679:   nsPresContext* presContext = mObjectFrame->PresContext();
31130:   nsIntPoint ptPx(presContext->AppUnitsToDevPixels(pt.x),
31130:                   presContext->AppUnitsToDevPixels(pt.y));
41424: #ifndef NP_NO_CARBON
41424:   nsIntPoint geckoScreenCoords = mWidget->WidgetToScreenOffset();
75308:   ::Point carbonPt = { static_cast<short>(ptPx.y + geckoScreenCoords.y),
75308:                        static_cast<short>(ptPx.x + geckoScreenCoords.x) };
41424:   if (eventModel == NPEventModelCarbon) {
41424:     if (event && anEvent.eventStructType == NS_MOUSE_EVENT) {
41424:       static_cast<EventRecord*>(event)->where = carbonPt;
41424:     }
41424:   }
41424: #endif
41424:   if (!event) {
32972: #ifndef NP_NO_CARBON
32019:     if (eventModel == NPEventModelCarbon) {
32019:       InitializeEventRecord(&synthCarbonEvent, &carbonPt);
32972:     } else
32972: #endif
32972:     {
32019:       InitializeNPCocoaEvent(&synthCocoaEvent);
32019:     }
31130:     
31130:     switch (anEvent.message) {
31130:       case NS_FOCUS_CONTENT:
31130:       case NS_BLUR_CONTENT:
32972: #ifndef NP_NO_CARBON
32019:         if (eventModel == NPEventModelCarbon) {
32019:           synthCarbonEvent.what = (anEvent.message == NS_FOCUS_CONTENT) ?
30189:           NPEventType_GetFocusEvent : NPEventType_LoseFocusEvent;
41747:           event = &synthCarbonEvent;
41321:         }
32972: #endif
31130:         break;
31130:       case NS_MOUSE_MOVE:
37413:       {
37413:         // Ignore mouse-moved events that happen as part of a dragging
37413:         // operation that started over another frame.  See bug 525078.
70097:         nsRefPtr<nsFrameSelection> frameselection = mObjectFrame->GetFrameSelection();
41747:         if (!frameselection->GetMouseDownState() ||
41747:             (nsIPresShell::GetCapturingContent() == mObjectFrame->GetContent())) {
32972: #ifndef NP_NO_CARBON
32019:           if (eventModel == NPEventModelCarbon) {
32019:             synthCarbonEvent.what = osEvt;
41747:             event = &synthCarbonEvent;
32972:           } else
32972: #endif
32972:           {
32019:             synthCocoaEvent.type = NPCocoaEventMouseMoved;
32019:             synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
32019:             synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:             event = &synthCocoaEvent;
41747:           }
41747:         }
32019:       }
31130:         break;
31130:       case NS_MOUSE_BUTTON_DOWN:
32972: #ifndef NP_NO_CARBON
32019:         if (eventModel == NPEventModelCarbon) {
32019:           synthCarbonEvent.what = mouseDown;
41747:           event = &synthCarbonEvent;
32972:         } else
32972: #endif
32972:         {
32019:           synthCocoaEvent.type = NPCocoaEventMouseDown;
32019:           synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
32019:           synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:           event = &synthCocoaEvent;
32019:         }
31130:         break;
31130:       case NS_MOUSE_BUTTON_UP:
37413:         // If we're in a dragging operation that started over another frame,
37413:         // either ignore the mouse-up event (in the Carbon Event Model) or
37413:         // convert it into a mouse-entered event (in the Cocoa Event Model).
37413:         // See bug 525078.
37413:         if ((static_cast<const nsMouseEvent&>(anEvent).button == nsMouseEvent::eLeftButton) &&
37413:             (nsIPresShell::GetCapturingContent() != mObjectFrame->GetContent())) {
41747:           if (eventModel == NPEventModelCocoa) {
37413:             synthCocoaEvent.type = NPCocoaEventMouseEntered;
37413:             synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
37413:             synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:             event = &synthCocoaEvent;
37413:           }
37413:         } else {
32972: #ifndef NP_NO_CARBON
32019:           if (eventModel == NPEventModelCarbon) {
32019:             synthCarbonEvent.what = mouseUp;
41747:             event = &synthCarbonEvent;
32972:           } else
32972: #endif
32972:           {
32019:             synthCocoaEvent.type = NPCocoaEventMouseUp;
32019:             synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
32019:             synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:             event = &synthCocoaEvent;
32019:           }
37413:         }
31130:         break;
33028:       default:
41747:         break;
41747:     }
41747: 
41747:     // If we still don't have an event, bail.
41747:     if (!event) {
33028:       pluginWidget->EndDrawPlugin();
33028:       return nsEventStatus_eIgnore;
31130:     }
32972:   }
32973: 
32972: #ifndef NP_NO_CARBON
    1:   // Work around an issue in the Flash plugin, which can cache a pointer
    1:   // to a doomed TSM document (one that belongs to a NSTSMInputContext)
    1:   // and try to activate it after it has been deleted. See bug 183313.
32019:   if (eventModel == NPEventModelCarbon && anEvent.message == NS_FOCUS_CONTENT)
    1:     ::DeactivateTSMDocument(::TSMGetActiveDocument());
32972: #endif
  130: 
43436:   PRInt16 response = kNPEventNotHandled;
32019:   void* window = FixUpPluginWindow(ePluginPaintEnable);
32019:   if (window || (eventModel == NPEventModelCocoa)) {
43436:     mInstance->HandleEvent(event, &response);
43436:   }
43436: 
43436:   if (eventModel == NPEventModelCocoa && response == kNPEventStartIME) {
43436:     pluginWidget->StartComplexTextInputForCurrentEvent();
43436:   }
43436: 
43436:   if ((response == kNPEventHandled || response == kNPEventStartIME) &&
33028:       !(anEvent.eventStructType == NS_MOUSE_EVENT &&
    1:         anEvent.message == NS_MOUSE_BUTTON_DOWN &&
33028:         static_cast<const nsMouseEvent&>(anEvent).button == nsMouseEvent::eLeftButton &&
    1:         !mContentFocused))
    1:     rv = nsEventStatus_eConsumeNoDefault;
    1: 
    1:   pluginWidget->EndDrawPlugin();
    1: #endif
    1: 
    1: #ifdef XP_WIN
    1:   // this code supports windowless plugins
34743:   NPEvent *pPluginEvent = (NPEvent*)anEvent.pluginEvent;
    1:   // we can get synthetic events from the nsEventStateManager... these
34743:   // have no pluginEvent
32799:   NPEvent pluginEvent;
29018:   if (anEvent.eventStructType == NS_MOUSE_EVENT) {
31130:     if (!pPluginEvent) {
31130:       // XXX Should extend this list to synthesize events for more event
31130:       // types
31130:       pluginEvent.event = 0;
31130:       const nsMouseEvent* mouseEvent = static_cast<const nsMouseEvent*>(&anEvent);
31130:       switch (anEvent.message) {
31130:       case NS_MOUSE_MOVE:
31130:         pluginEvent.event = WM_MOUSEMOVE;
31130:         break;
31130:       case NS_MOUSE_BUTTON_DOWN: {
31130:         static const int downMsgs[] =
31130:           { WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN };
36904:         static const int dblClickMsgs[] =
36904:           { WM_LBUTTONDBLCLK, WM_MBUTTONDBLCLK, WM_RBUTTONDBLCLK };
36904:         if (mouseEvent->clickCount == 2) {
36904:           pluginEvent.event = dblClickMsgs[mouseEvent->button];
36904:         } else {
31130:           pluginEvent.event = downMsgs[mouseEvent->button];
36904:         }
31130:         break;
31130:       }
31130:       case NS_MOUSE_BUTTON_UP: {
31130:         static const int upMsgs[] =
31130:           { WM_LBUTTONUP, WM_MBUTTONUP, WM_RBUTTONUP };
31130:         pluginEvent.event = upMsgs[mouseEvent->button];
31130:         break;
31130:       }
36904:       // don't synthesize anything for NS_MOUSE_DOUBLECLICK, since that
36904:       // is a synthetic event generated on mouse-up, and Windows WM_*DBLCLK
36904:       // messages are sent on mouse-down
31130:       default:
31130:         break;
31130:       }
31130:       if (pluginEvent.event) {
31130:         pPluginEvent = &pluginEvent;
31130:         pluginEvent.wParam =
31130:           (::GetKeyState(VK_CONTROL) ? MK_CONTROL : 0) |
31130:           (::GetKeyState(VK_SHIFT) ? MK_SHIFT : 0) |
31130:           (::GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0) |
31130:           (::GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0) |
31130:           (::GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0) |
31130:           (::GetKeyState(VK_XBUTTON1) ? MK_XBUTTON1 : 0) |
31130:           (::GetKeyState(VK_XBUTTON2) ? MK_XBUTTON2 : 0);
31130:       }
31130:     }
21403:     if (pPluginEvent) {
21403:       // Make event coordinates relative to our enclosing widget,
21403:       // not the widget they were received on.
86545:       // See use of NPEvent in widget/windows/nsWindow.cpp
21403:       // for why this assert should be safe
21403:       NS_ASSERTION(anEvent.message == NS_MOUSE_BUTTON_DOWN ||
21403:                    anEvent.message == NS_MOUSE_BUTTON_UP ||
21403:                    anEvent.message == NS_MOUSE_DOUBLECLICK ||
22564:                    anEvent.message == NS_MOUSE_ENTER_SYNTH ||
22564:                    anEvent.message == NS_MOUSE_EXIT_SYNTH ||
21403:                    anEvent.message == NS_MOUSE_MOVE,
21403:                    "Incorrect event type for coordinate translation");
33369:       nsPoint pt =
34679:         nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
68635:         mObjectFrame->GetContentRectRelativeToSelf().TopLeft();
34679:       nsPresContext* presContext = mObjectFrame->PresContext();
21403:       nsIntPoint ptPx(presContext->AppUnitsToDevPixels(pt.x),
21403:                       presContext->AppUnitsToDevPixels(pt.y));
79533:       nsIntPoint widgetPtPx = ptPx + mObjectFrame->GetWindowOriginInPixels(true);
21403:       pPluginEvent->lParam = MAKELPARAM(widgetPtPx.x, widgetPtPx.y);
21403:     }
29018:   }
29018:   else if (!pPluginEvent) {
    1:     switch (anEvent.message) {
    1:       case NS_FOCUS_CONTENT:
    1:         pluginEvent.event = WM_SETFOCUS;
    1:         pluginEvent.wParam = 0;
    1:         pluginEvent.lParam = 0;
    1:         pPluginEvent = &pluginEvent;
    1:         break;
    1:       case NS_BLUR_CONTENT:
    1:         pluginEvent.event = WM_KILLFOCUS;
    1:         pluginEvent.wParam = 0;
    1:         pluginEvent.lParam = 0;
    1:         pPluginEvent = &pluginEvent;
    1:         break;
    1:     }
    1:   }
    1: 
37167:   if (pPluginEvent && !pPluginEvent->event) {
37167:     // Don't send null events to plugins.
37167:     NS_WARNING("nsObjectFrame ProcessEvent: trying to send null event to plugin.");
37167:     return rv;
37167:   }
37167: 
    1:   if (pPluginEvent) {
43436:     PRInt16 response = kNPEventNotHandled;
43436:     mInstance->HandleEvent(pPluginEvent, &response);
43436:     if (response == kNPEventHandled)
    1:       rv = nsEventStatus_eConsumeNoDefault;
    1:   }
    1: #endif
    1: 
 3060: #ifdef MOZ_X11
 3060:   // this code supports windowless plugins
 3060:   nsIWidget* widget = anEvent.widget;
43911:   XEvent pluginEvent = XEvent();
32799:   pluginEvent.type = 0;
 3060: 
 3060:   switch(anEvent.eventStructType)
 3060:     {
 3060:     case NS_MOUSE_EVENT:
 3060:       {
 3060:         switch (anEvent.message)
 3060:           {
 3060:           case NS_MOUSE_CLICK:
 3060:           case NS_MOUSE_DOUBLECLICK:
 3060:             // Button up/down events sent instead.
 3060:             return rv;
 3060:           }
 3060: 
 3060:         // Get reference point relative to plugin origin.
34679:         const nsPresContext* presContext = mObjectFrame->PresContext();
 3060:         nsPoint appPoint =
34679:           nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
68635:           mObjectFrame->GetContentRectRelativeToSelf().TopLeft();
 3060:         nsIntPoint pluginPoint(presContext->AppUnitsToDevPixels(appPoint.x),
 3060:                                presContext->AppUnitsToDevPixels(appPoint.y));
 3060:         const nsMouseEvent& mouseEvent =
 3233:           static_cast<const nsMouseEvent&>(anEvent);
 3060:         // Get reference point relative to screen:
25183:         nsIntPoint rootPoint(-1,-1);
 3060:         if (widget)
25183:           rootPoint = anEvent.refPoint + widget->WidgetToScreenOffset();
 3060: #ifdef MOZ_WIDGET_GTK2
 3060:         Window root = GDK_ROOT_WINDOW();
41059: #elif defined(MOZ_WIDGET_QT)
41059:         Window root = QX11Info::appRootWindow();
 3060: #else
 3060:         Window root = None; // Could XQueryTree, but this is not important.
 3060: #endif
 3060: 
 3060:         switch (anEvent.message)
 3060:           {
 3060:           case NS_MOUSE_ENTER_SYNTH:
 3060:           case NS_MOUSE_EXIT_SYNTH:
 3060:             {
32799:               XCrossingEvent& event = pluginEvent.xcrossing;
 3060:               event.type = anEvent.message == NS_MOUSE_ENTER_SYNTH ?
 3060:                 EnterNotify : LeaveNotify;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               // information lost
 3060:               event.subwindow = None;
 3060:               event.mode = -1;
 3060:               event.detail = NotifyDetailNone;
 3060:               event.same_screen = True;
 3060:               event.focus = mContentFocused;
 3060:             }
 3060:             break;
 3060:           case NS_MOUSE_MOVE:
 3060:             {
32799:               XMotionEvent& event = pluginEvent.xmotion;
 3060:               event.type = MotionNotify;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               // information lost
 3060:               event.subwindow = None;
 3060:               event.is_hint = NotifyNormal;
 3060:               event.same_screen = True;
 3060:             }
 3060:             break;
 3060:           case NS_MOUSE_BUTTON_DOWN:
 3060:           case NS_MOUSE_BUTTON_UP:
 3060:             {
32799:               XButtonEvent& event = pluginEvent.xbutton;
 3060:               event.type = anEvent.message == NS_MOUSE_BUTTON_DOWN ?
 3060:                 ButtonPress : ButtonRelease;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               switch (mouseEvent.button)
 3060:                 {
 3060:                 case nsMouseEvent::eMiddleButton:
 3060:                   event.button = 2;
 3060:                   break;
 3060:                 case nsMouseEvent::eRightButton:
 3060:                   event.button = 3;
 3060:                   break;
 3060:                 default: // nsMouseEvent::eLeftButton;
 3060:                   event.button = 1;
 3060:                   break;
 3060:                 }
 3060:               // information lost:
 3060:               event.subwindow = None;
 3060:               event.same_screen = True;
 3060:             }
 3060:             break;
 3060:           }
 3060:       }
 3060:       break;
 3060: 
 3060:    //XXX case NS_MOUSE_SCROLL_EVENT: not received.
 3060:  
 3060:    case NS_KEY_EVENT:
34743:       if (anEvent.pluginEvent)
 3060:         {
32799:           XKeyEvent &event = pluginEvent.xkey;
 3060: #ifdef MOZ_WIDGET_GTK2
 3060:           event.root = GDK_ROOT_WINDOW();
 3060:           event.time = anEvent.time;
 3060:           const GdkEventKey* gdkEvent =
34743:             static_cast<const GdkEventKey*>(anEvent.pluginEvent);
 3060:           event.keycode = gdkEvent->hardware_keycode;
 3060:           event.state = gdkEvent->state;
 3060:           switch (anEvent.message)
 3060:             {
 3060:             case NS_KEY_DOWN:
36763:               // Handle NS_KEY_DOWN for modifier key presses
36763:               // For non-modifiers we get NS_KEY_PRESS
36763:               if (gdkEvent->is_modifier)
36763:                 event.type = XKeyPress;
36763:               break;
36763:             case NS_KEY_PRESS:
 3060:               event.type = XKeyPress;
 3060:               break;
 3060:             case NS_KEY_UP:
 3060:               event.type = KeyRelease;
 3060:               break;
 3060:             }
 3060: #endif
48345: 
48345: #ifdef MOZ_WIDGET_QT
48345:           const nsKeyEvent& keyEvent = static_cast<const nsKeyEvent&>(anEvent);
48345: 
48345:           memset( &event, 0, sizeof(event) );
48345:           event.time = anEvent.time;
48345: 
48345:           QWidget* qWidget = static_cast<QWidget*>(widget->GetNativeData(NS_NATIVE_WINDOW));
48345:           if (qWidget)
48345:             event.root = qWidget->x11Info().appRootWindow();
48345: 
48345:           // deduce keycode from the information in the attached QKeyEvent
48345:           const QKeyEvent* qtEvent = static_cast<const QKeyEvent*>(anEvent.pluginEvent);
48345:           if (qtEvent) {
48345: 
48345:             if (qtEvent->nativeModifiers())
48345:               event.state = qtEvent->nativeModifiers();
48345:             else // fallback
48345:               event.state = XInputEventState(keyEvent);
48345: 
48345:             if (qtEvent->nativeScanCode())
48345:               event.keycode = qtEvent->nativeScanCode();
48345:             else // fallback
48345:               event.keycode = XKeysymToKeycode( (widget ? static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull), qtEvent->key());
48345:           }
48345: 
48345:           switch (anEvent.message)
48345:             {
48345:             case NS_KEY_DOWN:
48345:               event.type = XKeyPress;
48345:               break;
48345:             case NS_KEY_UP:
48345:               event.type = KeyRelease;
48345:               break;
48345:            }
48345: #endif
34743:           // Information that could be obtained from pluginEvent but we may not
 3060:           // want to promise to provide:
 3060:           event.subwindow = None;
 3060:           event.x = 0;
 3060:           event.y = 0;
 3060:           event.x_root = -1;
 3060:           event.y_root = -1;
 3060:           event.same_screen = False;
 3060:         }
 3060:       else
 3060:         {
 3060:           // If we need to send synthesized key events, then
 3060:           // DOMKeyCodeToGdkKeyCode(keyEvent.keyCode) and
 3060:           // gdk_keymap_get_entries_for_keyval will be useful, but the
 3060:           // mappings will not be unique.
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498:           bool handled;
77498:           if (NS_SUCCEEDED(mInstance->HandleGUIEvent(anEvent, &handled)) &&
77498:               handled) {
77498:             rv = nsEventStatus_eConsumeNoDefault;
77498:           }
77498: #else
 3060:           NS_WARNING("Synthesized key event not sent to plugin");
77498: #endif
 3060:         }
 3060:       break;
 3060: 
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498:    case NS_TEXT_EVENT:
77498:         {
77498:           bool handled;
77498:           if (NS_SUCCEEDED(mInstance->HandleGUIEvent(anEvent, &handled)) &&
77498:               handled) {
77498:             rv = nsEventStatus_eConsumeNoDefault;
77498:           }
77498:         }
77498:       break;
77498: #endif
 3060:     default: 
 3060:       switch (anEvent.message)
 3060:         {
 3060:         case NS_FOCUS_CONTENT:
 3060:         case NS_BLUR_CONTENT:
 3060:           {
32799:             XFocusChangeEvent &event = pluginEvent.xfocus;
 3060:             event.type =
 3060:               anEvent.message == NS_FOCUS_CONTENT ? FocusIn : FocusOut;
 3060:             // information lost:
 3060:             event.mode = -1;
 3060:             event.detail = NotifyDetailNone;
 3060:           }
 3060:           break;
 3060:         }
 3060:     }
 3060: 
32799:   if (!pluginEvent.type) {
 3060:     return rv;
 3060:   }
 3060: 
 3060:   // Fill in (useless) generic event information.
32799:   XAnyEvent& event = pluginEvent.xany;
 3060:   event.display = widget ?
 3233:     static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull;
 3060:   event.window = None; // not a real window
 3060:   // information lost:
 3060:   event.serial = 0;
 3060:   event.send_event = False;
 3060: 
43436:   PRInt16 response = kNPEventNotHandled;
43436:   mInstance->HandleEvent(&pluginEvent, &response);
43436:   if (response == kNPEventHandled)
 3060:     rv = nsEventStatus_eConsumeNoDefault;
 3060: #endif
 3060: 
82142: #ifdef MOZ_WIDGET_ANDROID
78424:   // this code supports windowless plugins
78424:   {
78424:     // The plugin needs focus to receive keyboard and touch events
78424:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
78424:     if (fm) {
78424:       nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(mContent);
78424:       fm->SetFocus(elem, 0);
78424:     }
78424:   }
78424:   switch(anEvent.eventStructType)
78424:     {
78424:     case NS_MOUSE_EVENT:
78424:       {
78424:         switch (anEvent.message)
78424:           {
78424:           case NS_MOUSE_CLICK:
78424:           case NS_MOUSE_DOUBLECLICK:
78424:             // Button up/down events sent instead.
78424:             return rv;
78424:           }
78424: 
78424:         // Get reference point relative to plugin origin.
78424:         const nsPresContext* presContext = mObjectFrame->PresContext();
78424:         nsPoint appPoint =
78424:           nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
78424:           mObjectFrame->GetContentRectRelativeToSelf().TopLeft();
78424:         nsIntPoint pluginPoint(presContext->AppUnitsToDevPixels(appPoint.x),
78424:                                presContext->AppUnitsToDevPixels(appPoint.y));
78424: 
78424:         switch (anEvent.message)
78424:           {
78424:           case NS_MOUSE_MOVE:
78424:             {
78424:               // are these going to be touch events?
78424:               // pluginPoint.x;
78424:               // pluginPoint.y;
78424:             }
78424:             break;
78424:           case NS_MOUSE_BUTTON_DOWN:
78424:             {
78424:               ANPEvent event;
78424:               event.inSize = sizeof(ANPEvent);
78424:               event.eventType = kMouse_ANPEventType;
78424:               event.data.mouse.action = kDown_ANPMouseAction;
78424:               event.data.mouse.x = pluginPoint.x;
78424:               event.data.mouse.y = pluginPoint.y;
78424:               mInstance->HandleEvent(&event, nsnull);
78424:             }
78424:             break;
78424:           case NS_MOUSE_BUTTON_UP:
78424:             {
78424:               ANPEvent event;
78424:               event.inSize = sizeof(ANPEvent);
78424:               event.eventType = kMouse_ANPEventType;
78424:               event.data.mouse.action = kUp_ANPMouseAction;
78424:               event.data.mouse.x = pluginPoint.x;
78424:               event.data.mouse.y = pluginPoint.y;
78424:               mInstance->HandleEvent(&event, nsnull);
78424:             }
78424:             break;
78424:           }
78424:       }
78424:       break;
78424: 
78424:     case NS_KEY_EVENT:
78424:      {
78424:        const nsKeyEvent& keyEvent = static_cast<const nsKeyEvent&>(anEvent);
78424:        LOG("Firing NS_KEY_EVENT %d %d\n", keyEvent.keyCode, keyEvent.charCode);
78424:        
78424:        int modifiers = 0;
78424:        if (keyEvent.isShift)
78424:          modifiers |= kShift_ANPKeyModifier;
78424:        if (keyEvent.isAlt)
78424:          modifiers |= kAlt_ANPKeyModifier;
78424: 
78424:        ANPEvent event;
78424:        event.inSize = sizeof(ANPEvent);
78424:        event.eventType = kKey_ANPEventType;
78424:        event.data.key.nativeCode = keyEvent.keyCode;
78424:        event.data.key.virtualCode = keyEvent.charCode;
78424:        event.data.key.modifiers = modifiers;
78424:        event.data.key.repeatCount = 0;
78424:        event.data.key.unichar = 0;
78424:        switch (anEvent.message)
78424:          {
78424:          case NS_KEY_DOWN:
78424:            event.data.key.action = kDown_ANPKeyAction;
78424:            mInstance->HandleEvent(&event, nsnull);
78424:            break;
78424:            
78424:          case NS_KEY_UP:
78424:            event.data.key.action = kUp_ANPKeyAction;
78424:            mInstance->HandleEvent(&event, nsnull);
78424:            break;
78424:          }
78424:      }
78424:     }
78424:     rv = nsEventStatus_eConsumeNoDefault;
78424: #endif
78424:  
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::Destroy()
    1: {
89353:   if (mObjectFrame)
89353:     mObjectFrame->SetInstanceOwner(nsnull);
89353: 
36227: #ifdef MAC_CARBON_PLUGINS
    1:   // stop the timer explicitly to reduce reference count.
    1:   CancelTimer();
36227: #endif
39757: #ifdef XP_MACOSX
90335:   RemoveFromCARefreshTimer();
67592:   if (mColorProfile)
67592:     ::CGColorSpaceRelease(mColorProfile);  
39757: #endif
    1: 
    1:   // unregister context menu listener
    1:   if (mCXMenuListener) {
    1:     mCXMenuListener->Destroy(mContent);
12417:     mCXMenuListener = nsnull;
    1:   }
    1: 
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("focus"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("blur"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("mouseup"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("mousedown"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("mousemove"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("click"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dblclick"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("mouseover"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("mouseout"), this, false);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("keypress"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("keydown"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("keyup"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("drop"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("drag"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragenter"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragover"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragleave"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragexit"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragstart"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("draggesture"), this, true);
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("dragend"), this, true);
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
79533:   mContent->RemoveEventListener(NS_LITERAL_STRING("text"), this, true);
77498: #endif
    1: 
90194: #if MOZ_WIDGET_ANDROID
90194:   RemovePluginView();
90194: 
90194:   if (mLayer)
90194:     mLayer->SetVisible(false);
90194: 
90194: #endif
90194: 
14641:   if (mWidget) {
89114:     if (mPluginWindow) {
89114:       mPluginWindow->SetPluginWidget(nsnull);
89114:     }
89114: 
14641:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
89114:     if (pluginWidget) {
14641:       pluginWidget->SetPluginInstanceOwner(nsnull);
89114:     }
 4577:     mWidget->Destroy();
 4577:   }
 4577: 
 4577:   return NS_OK;
 4577: }
 4577: 
    1: // Paints are handled differently, so we just simulate an update event.
    1: 
 3059: #ifdef XP_MACOSX
34717: void nsPluginInstanceOwner::Paint(const gfxRect& aDirtyRect, CGContextRef cgContext)
    1: {
34679:   if (!mInstance || !mObjectFrame)
    1:     return;
    1:  
    1:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:   if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
34737: #ifndef NP_NO_CARBON
32019:     void* window = FixUpPluginWindow(ePluginPaintEnable);
32019:     if (GetEventModel() == NPEventModelCarbon && window) {
    1:       EventRecord updateEvent;
31130:       InitializeEventRecord(&updateEvent, nsnull);
    1:       updateEvent.what = updateEvt;
  130:       updateEvent.message = UInt32(window);
  130: 
43436:       mInstance->HandleEvent(&updateEvent, nsnull);
34717:     } else if (GetEventModel() == NPEventModelCocoa)
32972: #endif
32972:     {
62474:       DoCocoaEventDrawRect(aDirtyRect, cgContext);
62474:     }
62474:     pluginWidget->EndDrawPlugin();
62474:   }
62474: }
62474: 
62474: void nsPluginInstanceOwner::DoCocoaEventDrawRect(const gfxRect& aDrawRect, CGContextRef cgContext)
62474: {
63395:   if (!mInstance || !mObjectFrame)
63395:     return;
63395:  
32019:   // The context given here is only valid during the HandleEvent call.
32019:   NPCocoaEvent updateEvent;
32019:   InitializeNPCocoaEvent(&updateEvent);
32019:   updateEvent.type = NPCocoaEventDrawRect;
34717:   updateEvent.data.draw.context = cgContext;
62474:   updateEvent.data.draw.x = aDrawRect.X();
62474:   updateEvent.data.draw.y = aDrawRect.Y();
62474:   updateEvent.data.draw.width = aDrawRect.Width();
62474:   updateEvent.data.draw.height = aDrawRect.Height();
32019: 
43436:   mInstance->HandleEvent(&updateEvent, nsnull);
32019: }
    1: #endif
    1: 
    1: #ifdef XP_WIN
21080: void nsPluginInstanceOwner::Paint(const RECT& aDirty, HDC aDC)
 3059: {
34679:   if (!mInstance || !mObjectFrame)
 3059:     return;
 3059: 
32799:   NPEvent pluginEvent;
    1:   pluginEvent.event = WM_PAINT;
21080:   pluginEvent.wParam = WPARAM(aDC);
21080:   pluginEvent.lParam = LPARAM(&aDirty);
43436:   mInstance->HandleEvent(&pluginEvent, nsnull);
 3059: }
    1: #endif
 3059: 
12859: #ifdef XP_OS2
12859: void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, HPS aHPS)
12859: {
34679:   if (!mInstance || !mObjectFrame)
12859:     return;
12859: 
32799:   NPWindow *window;
12859:   GetWindow(window);
34679:   nsIntRect relDirtyRect = aDirtyRect.ToOutsidePixels(mObjectFrame->PresContext()->AppUnitsPerDevPixel());
12859: 
12859:   // we got dirty rectangle in relative window coordinates, but we
12859:   // need it in absolute units and in the (left, top, right, bottom) form
12859:   RECTL rectl;
23738:   rectl.xLeft   = relDirtyRect.x + window->x;
23738:   rectl.yBottom = relDirtyRect.y + window->y;
23738:   rectl.xRight  = rectl.xLeft + relDirtyRect.width;
23738:   rectl.yTop    = rectl.yBottom + relDirtyRect.height;
12859: 
32799:   NPEvent pluginEvent;
12859:   pluginEvent.event = WM_PAINT;
12859:   pluginEvent.wParam = (uint32)aHPS;
12859:   pluginEvent.lParam = (uint32)&rectl;
43436:   mInstance->HandleEvent(&pluginEvent, nsnull);
12859: }
12859: #endif
12859: 
82142: #ifdef MOZ_WIDGET_ANDROID
78424: 
78424: void nsPluginInstanceOwner::Paint(gfxContext* aContext,
78424:                                   const gfxRect& aFrameRect,
78424:                                   const gfxRect& aDirtyRect)
78424: {
90194:   if (!mInstance || !mObjectFrame || !mPluginDocumentActiveState)
78424:     return;
78424: 
87577:   PRInt32 model = mInstance->GetANPDrawingModel();
78424: 
78424:   if (model == kSurface_ANPDrawingModel) {
82979:     if (!AddPluginView(aFrameRect)) {
89219:       Invalidate();
89219:     }
89219:     return;
89219:   }
89219: 
89219:   if (model == kOpenGL_ANPDrawingModel) {
90194:     if (!mLayer)
90194:       mLayer = new AndroidMediaLayer();
90194: 
89219:     // FIXME: this is gross
89219:     float zoomLevel = aFrameRect.width / (float)mPluginWindow->width;
89219:     mLayer->UpdatePosition(aFrameRect, zoomLevel);
89219: 
89219:     SendSize((int)aFrameRect.width, (int)aFrameRect.height);
78424:     return;
78424:   }
78424: 
78424:   if (model != kBitmap_ANPDrawingModel)
78424:     return;
78424: 
78424: #ifdef ANP_BITMAP_DRAWING_MODEL
78424:   static nsRefPtr<gfxImageSurface> pluginSurface;
78424: 
78424:   if (pluginSurface == nsnull ||
78424:       aFrameRect.width  != pluginSurface->Width() ||
78424:       aFrameRect.height != pluginSurface->Height()) {
78424: 
78424:     pluginSurface = new gfxImageSurface(gfxIntSize(aFrameRect.width, aFrameRect.height), 
78424:                                         gfxImageSurface::ImageFormatARGB32);
78424:     if (!pluginSurface)
78424:       return;
78424:   }
78424: 
78424:   // Clears buffer.  I think this is needed.
78424:   nsRefPtr<gfxContext> ctx = new gfxContext(pluginSurface);
78424:   ctx->SetOperator(gfxContext::OPERATOR_CLEAR);
78424:   ctx->Paint();
78424:   
78424:   ANPEvent event;
78424:   event.inSize = sizeof(ANPEvent);
78424:   event.eventType = 4;
78424:   event.data.draw.model = 1;
78424:   
78424:   event.data.draw.clip.top     = 0;
78424:   event.data.draw.clip.left    = 0;
78424:   event.data.draw.clip.bottom  = aFrameRect.width;
78424:   event.data.draw.clip.right   = aFrameRect.height;
78424:   
78424:   event.data.draw.data.bitmap.format   = kRGBA_8888_ANPBitmapFormat;
78424:   event.data.draw.data.bitmap.width    = aFrameRect.width;
78424:   event.data.draw.data.bitmap.height   = aFrameRect.height;
78424:   event.data.draw.data.bitmap.baseAddr = pluginSurface->Data();
78424:   event.data.draw.data.bitmap.rowBytes = aFrameRect.width * 4;
78424:   
78424:   if (!mInstance)
78424:     return;
78424:     
78424:   mInstance->HandleEvent(&event, nsnull);
78424: 
78424:   aContext->SetOperator(gfxContext::OPERATOR_SOURCE);
78424:   aContext->SetSource(pluginSurface, gfxPoint(aFrameRect.x, aFrameRect.y));
78424:   aContext->Clip(aFrameRect);
78424:   aContext->Paint();
78424: #endif
78424: }
78424: #endif
78424: 
47118: #if defined(MOZ_X11)
15688: void nsPluginInstanceOwner::Paint(gfxContext* aContext,
15688:                                   const gfxRect& aFrameRect,
15688:                                   const gfxRect& aDirtyRect)
 3059: {
34679:   if (!mInstance || !mObjectFrame)
 3059:     return;
 3059: 
15688:   // to provide crisper and faster drawing.
15688:   gfxRect pluginRect = aFrameRect;
15688:   if (aContext->UserToDevicePixelSnapped(pluginRect)) {
15688:     pluginRect = aContext->DeviceToUser(pluginRect);
15688:   }
15688: 
15688:   // Round out the dirty rect to plugin pixels to ensure the plugin draws
15688:   // enough pixels for interpolation to device pixels.
68634:   gfxRect dirtyRect = aDirtyRect - pluginRect.TopLeft();
15688:   dirtyRect.RoundOut();
15688: 
15688:   // Plugins can only draw an integer number of pixels.
15688:   //
15688:   // With translation-only transformation matrices, pluginRect is already
15688:   // pixel-aligned.
15688:   //
15688:   // With more complex transformations, modifying the scales in the
15688:   // transformation matrix could retain subpixel accuracy and let the plugin
15688:   // draw a suitable number of pixels for interpolation to device pixels in
15688:   // Renderer::Draw, but such cases are not common enough to warrant the
15688:   // effort now.
68634:   nsIntSize pluginSize(NS_lround(pluginRect.width),
68634:                        NS_lround(pluginRect.height));
15688: 
15688:   // Determine what the plugin needs to draw.
68634:   nsIntRect pluginDirtyRect(PRInt32(dirtyRect.x),
68634:                             PRInt32(dirtyRect.y),
68634:                             PRInt32(dirtyRect.width),
68634:                             PRInt32(dirtyRect.height));
15688:   if (!pluginDirtyRect.
15688:       IntersectRect(nsIntRect(0, 0, pluginSize.width, pluginSize.height),
15688:                     pluginDirtyRect))
15688:     return;
15688: 
32799:   NPWindow* window;
 3059:   GetWindow(window);
 3059: 
47118:   PRUint32 rendererFlags = 0;
47115:   if (!mFlash10Quirks) {
47115:     rendererFlags |=
 3059:       Renderer::DRAW_SUPPORTS_CLIP_RECT |
47118:       Renderer::DRAW_SUPPORTS_ALTERNATE_VISUAL;
47115:   }
 3059: 
79445:   bool transparent;
32799:   mInstance->IsTransparent(&transparent);
 3059:   if (!transparent)
 3059:     rendererFlags |= Renderer::DRAW_IS_OPAQUE;
 3059: 
15688:   // Renderer::Draw() draws a rectangle with top-left at the aContext origin.
15688:   gfxContextAutoSaveRestore autoSR(aContext);
68634:   aContext->Translate(pluginRect.TopLeft());
 3059: 
47115:   Renderer renderer(window, this, pluginSize, pluginDirtyRect);
47118: #ifdef MOZ_WIDGET_GTK2
47118:   // This is the visual used by the widgets, 24-bit if available.
47118:   GdkVisual* gdkVisual = gdk_rgb_get_visual();
47118:   Visual* visual = gdk_x11_visual_get_xvisual(gdkVisual);
47118:   Screen* screen =
47118:     gdk_x11_screen_get_xscreen(gdk_visual_get_screen(gdkVisual));
47118: #endif
47118: #ifdef MOZ_WIDGET_QT
47118:   Display* dpy = QX11Info().display();
47118:   Screen* screen = ScreenOfDisplay(dpy, QX11Info().screen());
47118:   Visual* visual = static_cast<Visual*>(QX11Info().visual());
47118: #endif
47118:   renderer.Draw(aContext, nsIntSize(window->width, window->height),
47118:                 rendererFlags, screen, visual, nsnull);
 3059: }
 3059: nsresult
47118: nsPluginInstanceOwner::Renderer::DrawWithXlib(gfxXlibSurface* xsurface, 
47118:                                               nsIntPoint offset,
47118:                                               nsIntRect *clipRects, 
 3059:                                               PRUint32 numClipRects)
47118: {
41059:   Screen *screen = cairo_xlib_surface_get_screen(xsurface->CairoSurface());
47118:   Colormap colormap;
47118:   Visual* visual;
47118:   if (!xsurface->GetColormapAndVisual(&colormap, &visual)) {
47118:     NS_ERROR("Failed to get visual and colormap");
47118:     return NS_ERROR_UNEXPECTED;
47118:   }
47115: 
70007:   nsNPAPIPluginInstance *instance = mInstanceOwner->mInstance;
47115:   if (!instance)
47115:     return NS_ERROR_FAILURE;
47115: 
 3059:   // See if the plugin must be notified of new window parameters.
79445:   bool doupdatewindow = false;
 3059: 
47118:   if (mWindow->x != offset.x || mWindow->y != offset.y) {
47118:     mWindow->x = offset.x;
47118:     mWindow->y = offset.y;
79533:     doupdatewindow = true;
 3059:   }
 3059: 
15688:   if (nsIntSize(mWindow->width, mWindow->height) != mPluginSize) {
15688:     mWindow->width = mPluginSize.width;
15688:     mWindow->height = mPluginSize.height;
79533:     doupdatewindow = true;
15688:   }
15688: 
16083:   // The clip rect is relative to drawable top-left.
 3059:   NS_ASSERTION(numClipRects <= 1, "We don't support multiple clip rectangles!");
16083:   nsIntRect clipRect;
 3059:   if (numClipRects) {
16083:     clipRect.x = clipRects[0].x;
16083:     clipRect.y = clipRects[0].y;
16083:     clipRect.width  = clipRects[0].width;
16083:     clipRect.height = clipRects[0].height;
48107:     // NPRect members are unsigned, but clip rectangles should be contained by
48107:     // the surface.
48107:     NS_ASSERTION(clipRect.x >= 0 && clipRect.y >= 0,
48107:                  "Clip rectangle offsets are negative!");
 3059:   }
 3059:   else {
47118:     clipRect.x = offset.x;
47118:     clipRect.y = offset.y;
16083:     clipRect.width  = mWindow->width;
16083:     clipRect.height = mWindow->height;
48107:     // Don't ask the plugin to draw outside the drawable.
48107:     // This also ensures that the unsigned clip rectangle offsets won't be -ve.
48107:     gfxIntSize surfaceSize = xsurface->GetSize();
48107:     clipRect.IntersectRect(clipRect,
48107:                            nsIntRect(0, 0,
48107:                                      surfaceSize.width, surfaceSize.height));
16083:   }
16083: 
32799:   NPRect newClipRect;
16083:   newClipRect.left = clipRect.x;
16083:   newClipRect.top = clipRect.y;
16083:   newClipRect.right = clipRect.XMost();
16083:   newClipRect.bottom = clipRect.YMost();
 3059:   if (mWindow->clipRect.left    != newClipRect.left   ||
 3059:       mWindow->clipRect.top     != newClipRect.top    ||
 3059:       mWindow->clipRect.right   != newClipRect.right  ||
 3059:       mWindow->clipRect.bottom  != newClipRect.bottom) {
 3059:     mWindow->clipRect = newClipRect;
79533:     doupdatewindow = true;
 3059:   }
 3059: 
 3059:   NPSetWindowCallbackStruct* ws_info = 
 3233:     static_cast<NPSetWindowCallbackStruct*>(mWindow->ws_info);
16528: #ifdef MOZ_X11
15703:   if (ws_info->visual != visual || ws_info->colormap != colormap) {
 3059:     ws_info->visual = visual;
15703:     ws_info->colormap = colormap;
47113:     ws_info->depth = gfxXlibSurface::DepthOfVisual(screen, visual);
79533:     doupdatewindow = true;
 3059:   }
16528: #endif
 3059: 
28368:   {
 3059:     if (doupdatewindow)
47115:       instance->SetWindow(mWindow);
28368:   }
 3059: 
47115:   // Translate the dirty rect to drawable coordinates.
47118:   nsIntRect dirtyRect = mDirtyRect + offset;
47115:   if (mInstanceOwner->mFlash10Quirks) {
47115:     // Work around a bug in Flash up to 10.1 d51 at least, where expose event
47115:     // top left coordinates within the plugin-rect and not at the drawable
47115:     // origin are misinterpreted.  (We can move the top left coordinate
47115:     // provided it is within the clipRect.)
47118:     dirtyRect.SetRect(offset.x, offset.y,
36767:                       mDirtyRect.XMost(), mDirtyRect.YMost());
47115:   }
16083:   // Intersect the dirty rect with the clip rect to ensure that it lies within
16083:   // the drawable.
16083:   if (!dirtyRect.IntersectRect(dirtyRect, clipRect))
16083:     return NS_OK;
16083: 
70893:   {
43911:     XEvent pluginEvent = XEvent();
32799:     XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
 3059:     // set the drawing info
 3059:     exposeEvent.type = GraphicsExpose;
15703:     exposeEvent.display = DisplayOfScreen(screen);
47118:     exposeEvent.drawable = xsurface->XDrawable();
36767:     exposeEvent.x = dirtyRect.x;
36767:     exposeEvent.y = dirtyRect.y;
36767:     exposeEvent.width  = dirtyRect.width;
36767:     exposeEvent.height = dirtyRect.height;
 3059:     exposeEvent.count = 0;
 3059:     // information not set:
 3059:     exposeEvent.serial = 0;
 3059:     exposeEvent.send_event = False;
 3059:     exposeEvent.major_code = 0;
 3059:     exposeEvent.minor_code = 0;
 3059: 
47115:     instance->HandleEvent(&pluginEvent, nsnull);
70893:   }
 3059:   return NS_OK;
 3059: }
 3059: #endif
    1: 
36227: void nsPluginInstanceOwner::SendIdleEvent()
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
    1:   // validate the plugin clipping information by syncing the plugin window info to
    1:   // reflect the current widget location. This makes sure that everything is updated
    1:   // correctly in the event of scrolling in the window.
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
32019:       void* window = FixUpPluginWindow(ePluginPaintEnable);
  130:       if (window) {
    1:         EventRecord idleEvent;
31130:         InitializeEventRecord(&idleEvent, nsnull);
    1:         idleEvent.what = nullEvent;
    1: 
    1:         // give a bogus 'where' field of our null event when hidden, so Flash
    1:         // won't respond to mouse moves in other tabs, see bug 120875
    1:         if (!mWidgetVisible)
    1:           idleEvent.where.h = idleEvent.where.v = 20000;
    1: 
43436:         mInstance->HandleEvent(&idleEvent, nsnull);
    1:       }
    1: 
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
36227: }
36227: 
36227: #ifdef MAC_CARBON_PLUGINS
79445: void nsPluginInstanceOwner::StartTimer(bool isVisible)
36227: {
32019:   if (GetEventModel() != NPEventModelCarbon)
32019:     return;
32019: 
36227:   mPluginHost->AddIdleTimeTarget(this, isVisible);
36227: }
36227: 
36227: void nsPluginInstanceOwner::CancelTimer()
36227: {
36227:   mPluginHost->RemoveIdleTimeTarget(this);
    1: }
    1: #endif
    1: 
89114: nsresult nsPluginInstanceOwner::Init(nsIContent* aContent)
    1: {
24543:   mLastEventloopNestingLevel = GetEventloopNestingLevel();
13537: 
    1:   mContent = aContent;
    1: 
89114:   // Get a frame, don't reflow. If a reflow was necessary it should have been
89114:   // done at a higher level than this (content).
89114:   nsIFrame* frame = aContent->GetPrimaryFrame();
89114:   nsIObjectFrame* iObjFrame = do_QueryFrame(frame);
89114:   nsObjectFrame* objFrame =  static_cast<nsObjectFrame*>(iObjFrame);
89114:   if (objFrame) {
89114:     SetFrame(objFrame);
    1:     // Some plugins require a specific sequence of shutdown and startup when
    1:     // a page is reloaded. Shutdown happens usually when the last instance
    1:     // is destroyed. Here we make sure the plugin instance in the old
    1:     // document is destroyed before we try to create the new one.
89114:     objFrame->PresContext()->EnsureVisible();
89647:   } else {
89647:     return NS_ERROR_FAILURE;
12417:   }
12417: 
    1:   // register context menu listener
    1:   mCXMenuListener = new nsPluginDOMContextMenuListener();
    1:   if (mCXMenuListener) {    
    1:     mCXMenuListener->Init(aContent);
    1:   }
    1: 
79533:   mContent->AddEventListener(NS_LITERAL_STRING("focus"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("blur"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("mouseup"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("mousedown"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("mousemove"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("click"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dblclick"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("mouseover"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("mouseout"), this, false,
79533:                              false);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("keypress"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("keydown"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("keyup"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("drop"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragdrop"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("drag"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragenter"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragover"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragleave"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragexit"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragstart"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("draggesture"), this, true);
79533:   mContent->AddEventListener(NS_LITERAL_STRING("dragend"), this, true);
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
79533:   mContent->AddEventListener(NS_LITERAL_STRING("text"), this, true);
77498: #endif
    1: 
    1:   return NS_OK; 
    1: }
    1: 
37446: void* nsPluginInstanceOwner::GetPluginPortFromWidget()
    1: {
    1: //!!! Port must be released for windowless plugins on Windows, because it is HDC !!!
    1: 
32799:   void* result = NULL;
    1:   if (mWidget) {
    1: #ifdef XP_WIN
32799:     if (mPluginWindow && (mPluginWindow->type == NPWindowTypeDrawable))
32799:       result = mWidget->GetNativeData(NS_NATIVE_GRAPHIC);
    1:     else
    1: #endif
  130: #ifdef XP_MACOSX
39757:     if (GetDrawingModel() == NPDrawingModelCoreGraphics || 
43370:         GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:         GetDrawingModel() == NPDrawingModelInvalidatingCoreAnimation)
32799:       result = mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT_CG);
  130:     else
  130: #endif
32799:       result = mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
    1:   }
    1:   return result;
    1: }
    1: 
32799: void nsPluginInstanceOwner::ReleasePluginPort(void * pluginPort)
    1: {
    1: #ifdef XP_WIN
    1:   if (mWidget && mPluginWindow &&
32799:       mPluginWindow->type == NPWindowTypeDrawable) {
    1:     mWidget->FreeNativeData((HDC)pluginPort, NS_NATIVE_GRAPHIC);
    1:   }
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::CreateWidget(void)
    1: {
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   
89114:   // Can't call this twice!
89114:   if (mWidget) {
89114:     NS_WARNING("Trying to create a plugin widget twice!");
89114:     return NS_ERROR_FAILURE;
89114:   }
89114:   
79445:   bool windowless = false;
32799:   mInstance->IsWindowless(&windowless);
89114:   if (!windowless && !nsIWidget::UsePuppetWidgets()) {
89114:     // Try to get a parent widget, on some platforms widget creation will fail without
89114:     // a parent.
89114:     nsCOMPtr<nsIWidget> parentWidget;
89114:     nsIDocument *doc = nsnull;
89114:     if (mContent) {
89114:       doc = mContent->OwnerDoc();
89114:       parentWidget = nsContentUtils::WidgetForDocument(doc);
89114:     }
89114: 
89114:     mWidget = do_CreateInstance(kWidgetCID, &rv);
89114:     if (NS_FAILED(rv)) {
89114:       return rv;
89114:     }
89114: 
89114:     nsWidgetInitData initData;
89114:     initData.mWindowType = eWindowType_plugin;
89114:     initData.mUnicode = false;
89114:     initData.clipChildren = true;
89114:     initData.clipSiblings = true;
89114:     rv = mWidget->Create(parentWidget.get(), nsnull, nsIntRect(0,0,0,0),
89114:                          nsnull, nsnull, &initData);
89114:     if (NS_FAILED(rv)) {
89114:       mWidget->Destroy();
89114:       mWidget = nsnull;
89114:       return rv;
89114:     }
89114: 
89114:     mWidget->EnableDragDrop(true);
89114:     mWidget->Show(false);
89114:     mWidget->Enable(false);
90335: 
90335: #ifdef XP_MACOSX
90335:     // Now that we have a widget we want to set the event model before
90335:     // any events are processed.
90335:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
90335:     if (!pluginWidget) {
90335:       return NS_ERROR_FAILURE;
90335:     }
90335:     pluginWidget->SetPluginEventModel(GetEventModel());
90335:     pluginWidget->SetPluginDrawingModel(GetDrawingModel());
90335: 
90335:     if (GetDrawingModel() == NPDrawingModelCoreAnimation) {
90335:       AddToCARefreshTimer();
90335:     }
90335: #endif
89114:   }
89114: 
89114:   if (mObjectFrame) {
89114:     // NULL widget is fine, will result in windowless setup.
89114:     mObjectFrame->PrepForDrawing(mWidget);
89114:   }
89114: 
89114:   if (windowless) {
32799:     mPluginWindow->type = NPWindowTypeDrawable;
    1: 
    1:     // this needs to be a HDC according to the spec, but I do
    1:     // not see the right way to release it so let's postpone
    1:     // passing HDC till paint event when it is really
    1:     // needed. Change spec?
    1:     mPluginWindow->window = nsnull;
15703: #ifdef MOZ_X11
15703:     // Fill in the display field.
15703:     NPSetWindowCallbackStruct* ws_info = 
15703:     static_cast<NPSetWindowCallbackStruct*>(mPluginWindow->ws_info);
43912:     ws_info->display = DefaultXDisplay();
47115:     
47115:     nsCAutoString description;
47115:     GetPluginDescription(description);
47115:     NS_NAMED_LITERAL_CSTRING(flash10Head, "Shockwave Flash 10.");
47115:     mFlash10Quirks = StringBeginsWith(description, flash10Head);
15703: #endif
    1:   } else if (mWidget) {
    1:     // mPluginWindow->type is used in |GetPluginPort| so it must
14641:     // be initialized first
32799:     mPluginWindow->type = NPWindowTypeWindow;
37446:     mPluginWindow->window = GetPluginPortFromWidget();
36227: #ifdef MAC_CARBON_PLUGINS
    1:     // start the idle timer.
79533:     StartTimer(true);
36227: #endif
    1:     // tell the plugin window about the widget
    1:     mPluginWindow->SetPluginWidget(mWidget);
14641:     
14641:     // tell the widget about the current plugin instance owner.
14641:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
89114:     if (pluginWidget) {
14641:       pluginWidget->SetPluginInstanceOwner(this);
    1:     }
    1:   }
89114: 
89114:   mWidgetCreationComplete = true;
89114: 
89114:   return NS_OK;
    1: }
    1: 
    1: // Mac specific code to fix up the port location and clipping region
    1: #ifdef XP_MACOSX
    1: 
32019: void* nsPluginInstanceOwner::FixUpPluginWindow(PRInt32 inPaintState)
    1: {
34679:   if (!mWidget || !mPluginWindow || !mInstance || !mObjectFrame)
    1:     return nsnull;
    1: 
21108:   NPDrawingModel drawingModel = GetDrawingModel();
37446:   NPEventModel eventModel = GetEventModel();
32019: 
32019:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
32019:   if (!pluginWidget)
32019:     return nsnull;
32019: 
21108:   // If we've already set up a CGContext in nsObjectFrame::PaintPlugin(), we
21108:   // don't want calls to SetPluginPortAndDetectChange() to step on our work.
32799:   void* pluginPort = nsnull;
21108:   if (mInCGPaintLevel > 0) {
21108:     pluginPort = mPluginWindow->window;
21108:   } else {
21108:     pluginPort = SetPluginPortAndDetectChange();
21108:   }
    1: 
37446: #ifdef MAC_CARBON_PLUGINS
37446:   if (eventModel == NPEventModelCarbon && !pluginPort)
    1:     return nsnull;
37446: #endif
    1: 
41061:   // We'll need the top-level Cocoa window for the Cocoa event model.
41061:   void* cocoaTopLevelWindow = nsnull;
41061:   if (eventModel == NPEventModelCocoa) {
47148:     nsIWidget* widget = mObjectFrame->GetNearestWidget();
41061:     if (!widget)
41061:       return nsnull;
41061:     cocoaTopLevelWindow = widget->GetNativeData(NS_NATIVE_WINDOW);
41061:     if (!cocoaTopLevelWindow)
41061:       return nsnull;
41061:   }
41061: 
23738:   nsIntPoint pluginOrigin;
23738:   nsIntRect widgetClip;
79445:   bool widgetVisible;
29388:   pluginWidget->GetPluginClipRect(widgetClip, pluginOrigin, widgetVisible);
30522:   mWidgetVisible = widgetVisible;
    1: 
    1:   // printf("GetPluginClipRect returning visible %d\n", widgetVisible);
    1: 
  130: #ifndef NP_NO_QUICKDRAW
    1:   // set the port coordinates
  130:   if (drawingModel == NPDrawingModelQuickDraw) {
32799:     mPluginWindow->x = -static_cast<NP_Port*>(pluginPort)->portx;
32799:     mPluginWindow->y = -static_cast<NP_Port*>(pluginPort)->porty;
  130:   }
39757:   else if (drawingModel == NPDrawingModelCoreGraphics || 
43370:            drawingModel == NPDrawingModelCoreAnimation ||
43370:            drawingModel == NPDrawingModelInvalidatingCoreAnimation)
  130: #endif
 2078:   {
 2078:     // This would be a lot easier if we could use obj-c here,
 2078:     // but we can't. Since we have only nsIWidget and we can't
 2078:     // use its native widget (an obj-c object) we have to go
 2078:     // from the widget's screen coordinates to its window coords
 2078:     // instead of straight to window coords.
25183:     nsIntPoint geckoScreenCoords = mWidget->WidgetToScreenOffset();
 2078: 
32019:     nsRect windowRect;
32972: #ifndef NP_NO_CARBON
37446:     if (eventModel == NPEventModelCarbon)
32799:       NS_NPAPI_CarbonWindowFrame(static_cast<WindowRef>(static_cast<NP_CGContext*>(pluginPort)->window), windowRect);
32019:     else
32972: #endif
34717:     {
41061:       NS_NPAPI_CocoaWindowFrame(cocoaTopLevelWindow, windowRect);
34717:     }
32019: 
32019:     mPluginWindow->x = geckoScreenCoords.x - windowRect.x;
32019:     mPluginWindow->y = geckoScreenCoords.y - windowRect.y;
 2078:   }
    1: 
32799:   NPRect oldClipRect = mPluginWindow->clipRect;
    1:   
    1:   // fix up the clipping region
    1:   mPluginWindow->clipRect.top    = widgetClip.y;
    1:   mPluginWindow->clipRect.left   = widgetClip.x;
    1: 
    1:   if (!mWidgetVisible || inPaintState == ePluginPaintDisable) {
    1:     mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top;
    1:     mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left;
    1:   }
    1:   else if (inPaintState == ePluginPaintEnable)
    1:   {
    1:     mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top + widgetClip.height;
    1:     mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left + widgetClip.width; 
    1:   }
    1: 
    1:   // if the clip rect changed, call SetWindow()
    1:   // (RealPlayer needs this to draw correctly)
    1:   if (mPluginWindow->clipRect.left    != oldClipRect.left   ||
    1:       mPluginWindow->clipRect.top     != oldClipRect.top    ||
    1:       mPluginWindow->clipRect.right   != oldClipRect.right  ||
    1:       mPluginWindow->clipRect.bottom  != oldClipRect.bottom)
    1:   {
89114:     if (UseAsyncRendering()) {
89114:       mInstance->AsyncSetWindow(mPluginWindow);
89114:     }
89114:     else {
89114:       mPluginWindow->CallSetWindow(mInstance);
89114:     }
79533:     mPluginPortChanged = false;
36227: #ifdef MAC_CARBON_PLUGINS
    1:     // if the clipRect is of size 0, make the null timer fire less often
    1:     CancelTimer();
    1:     if (mPluginWindow->clipRect.left == mPluginWindow->clipRect.right ||
    1:         mPluginWindow->clipRect.top == mPluginWindow->clipRect.bottom) {
79533:       StartTimer(false);
    1:     }
    1:     else {
79533:       StartTimer(true);
36227:     }
36227: #endif
21108:   } else if (mPluginPortChanged) {
89114:     if (UseAsyncRendering()) {
89114:       mInstance->AsyncSetWindow(mPluginWindow);
89114:     }
89114:     else {
89114:       mPluginWindow->CallSetWindow(mInstance);
89114:     }
79533:     mPluginPortChanged = false;
    1:   }
    1: 
41061:   // After the first NPP_SetWindow call we need to send an initial
41061:   // top-level window focus event.
41061:   if (eventModel == NPEventModelCocoa && !mSentInitialTopLevelWindowEvent) {
41061:     // Set this before calling ProcessEvent to avoid endless recursion.
79533:     mSentInitialTopLevelWindowEvent = true;
79533: 
79533:     nsPluginEvent pluginEvent(true, NS_PLUGIN_FOCUS_EVENT, nsnull);
41061:     NPCocoaEvent cocoaEvent;
41061:     InitializeNPCocoaEvent(&cocoaEvent);
41061:     cocoaEvent.type = NPCocoaEventWindowFocusChanged;
41061:     cocoaEvent.data.focus.hasFocus = NS_NPAPI_CocoaWindowIsMain(cocoaTopLevelWindow);
41061:     pluginEvent.pluginEvent = &cocoaEvent;
41061:     ProcessEvent(pluginEvent);
41061:   }
41061: 
  130: #ifndef NP_NO_QUICKDRAW
  130:   if (drawingModel == NPDrawingModelQuickDraw)
32799:     return ::GetWindowFromPort(static_cast<NP_Port*>(pluginPort)->port);
  130: #endif
  130: 
37446: #ifdef MAC_CARBON_PLUGINS
37446:   if (drawingModel == NPDrawingModelCoreGraphics && eventModel == NPEventModelCarbon)
32799:     return static_cast<NP_CGContext*>(pluginPort)->window;
37446: #endif
  130: 
  130:   return nsnull;
    1: }
    1: 
56652: void
56652: nsPluginInstanceOwner::HidePluginWindow()
56652: {
56652:   if (!mPluginWindow || !mInstance) {
56652:     return;
56652:   }
56652: 
56652:   mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top;
56652:   mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left;
79533:   mWidgetVisible = false;
89114:   if (UseAsyncRendering()) {
71284:     mInstance->AsyncSetWindow(mPluginWindow);
71284:   } else {
56652:     mInstance->SetWindow(mPluginWindow);
56652:   }
71284: }
56652: 
57224: #else // XP_MACOSX
57228: 
79445: void nsPluginInstanceOwner::UpdateWindowPositionAndClipRect(bool aSetWindow)
57224: {
57224:   if (!mPluginWindow)
57224:     return;
57224: 
57224:   // For windowless plugins a non-empty clip rectangle will be
57224:   // passed to the plugin during paint, an additional update
57224:   // of the the clip rectangle here is not required
62474:   if (aSetWindow && !mWidget && mPluginWindowVisible && !UseAsyncRendering())
57224:     return;
57224: 
57514:   const NPWindow oldWindow = *mPluginWindow;
57514: 
79445:   bool windowless = (mPluginWindow->type == NPWindowTypeDrawable);
57514:   nsIntPoint origin = mObjectFrame->GetWindowOriginInPixels(windowless);
57514: 
57514:   mPluginWindow->x = origin.x;
57514:   mPluginWindow->y = origin.y;
57224: 
57224:   mPluginWindow->clipRect.left = 0;
57224:   mPluginWindow->clipRect.top = 0;
57224: 
76815:   if (mPluginWindowVisible && mPluginDocumentActiveState) {
57224:     mPluginWindow->clipRect.right = mPluginWindow->width;
57224:     mPluginWindow->clipRect.bottom = mPluginWindow->height;
57224:   } else {
57224:     mPluginWindow->clipRect.right = 0;
57224:     mPluginWindow->clipRect.bottom = 0;
57224:   }
57224: 
57224:   if (!aSetWindow)
57224:     return;
57224: 
57514:   if (mPluginWindow->x               != oldWindow.x               ||
57514:       mPluginWindow->y               != oldWindow.y               ||
57514:       mPluginWindow->clipRect.left   != oldWindow.clipRect.left   ||
57514:       mPluginWindow->clipRect.top    != oldWindow.clipRect.top    ||
57514:       mPluginWindow->clipRect.right  != oldWindow.clipRect.right  ||
57514:       mPluginWindow->clipRect.bottom != oldWindow.clipRect.bottom) {
58796:     CallSetWindow();
57224:   }
57224: }
57224: 
57224: void
79445: nsPluginInstanceOwner::UpdateWindowVisibility(bool aVisible)
71284: {
71284:   mPluginWindowVisible = aVisible;
79533:   UpdateWindowPositionAndClipRect(true);
71284: }
71284: 
76815: void
79445: nsPluginInstanceOwner::UpdateDocumentActiveState(bool aIsActive)
76815: {
76815:   mPluginDocumentActiveState = aIsActive;
79533:   UpdateWindowPositionAndClipRect(true);
90194: 
90194: #ifdef MOZ_WIDGET_ANDROID
90194:   if (mInstance) {
90194:     if (mLayer)
90194:       mLayer->SetVisible(mPluginDocumentActiveState);
90194: 
90194:     if (!mPluginDocumentActiveState)
90194:       RemovePluginView();
90194: 
90194:     mInstance->NotifyOnScreen(mPluginDocumentActiveState);
90194: 
90194:     // This is, perhaps, incorrect. It is supposed to be sent
90194:     // when "the webview has paused or resumed". The side effect
90194:     // is that Flash video players pause or resume (if they were
90194:     // playing before) based on the value here. I personally think
90194:     // we want that on Android when switching to another tab, so
90194:     // that's why we call it here.
90194:     mInstance->NotifyForeground(mPluginDocumentActiveState);
90194:   }
90194: #endif
76815: }
71284: #endif // XP_MACOSX
71284: 
89114: NS_IMETHODIMP
58796: nsPluginInstanceOwner::CallSetWindow()
57224: {
89114:   if (mObjectFrame) {
89114:     mObjectFrame->CallSetWindow(false);
89114:   } else if (mInstance) {
62474:     if (UseAsyncRendering()) {
57224:       mInstance->AsyncSetWindow(mPluginWindow);
57224:     } else {
57224:       mInstance->SetWindow(mPluginWindow);
57224:     }
57224:   }
57224: 
89114:   return NS_OK;
89114: }
89114: 
89114: void nsPluginInstanceOwner::SetFrame(nsObjectFrame *aFrame)
89114: {
89114:   // Don't do anything if the frame situation hasn't changed.
89114:   if (mObjectFrame == aFrame) {
89114:     return;
89114:   }
89114: 
90606:   // If we already have a frame that is changing or going away...
89114:   if (mObjectFrame) {
89114:     // We have an old frame.
89114:     // Drop image reference because the child may destroy the surface after we return.
89114:     nsRefPtr<ImageContainer> container = mObjectFrame->GetImageContainer();
89114:     if (container) {
89114: #ifdef XP_MACOSX
89114:       nsRefPtr<Image> image = container->GetCurrentImage();
89114:       if (image && (image->GetFormat() == Image::MAC_IO_SURFACE) && mObjectFrame) {
89114:         // Undo what we did to the current image in SetCurrentImage().
89114:         MacIOSurfaceImage *oglImage = static_cast<MacIOSurfaceImage*>(image.get());
89114:         oglImage->SetUpdateCallback(nsnull, nsnull);
89114:         oglImage->SetDestroyCallback(nsnull);
89114:         // If we have a current image here, its destructor hasn't yet been
89114:         // called, so OnDestroyImage() can't yet have been called.  So we need
89114:         // to do ourselves what OnDestroyImage() would have done.
89114:         NS_RELEASE_THIS();
89114:       }
89114: #endif
89114:       container->SetCurrentImage(nsnull);
89114:     }
89114: 
90606:     // Scroll position listening is only required for Carbon event model plugins on Mac OS X.
90421: #if defined(XP_MACOSX) && !defined(NP_NO_QUICKDRAW)
90606:     // Our frame is changing or going away, unregister for a scroll position listening.
90606:     // It's OK to unregister when we didn't register, so don't be strict about unregistering.
90606:     // Better to unregister when we didn't have to than to not unregister when we should.
89114:     for (nsIFrame* f = mObjectFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
89114:       nsIScrollableFrame* sf = do_QueryFrame(f);
89114:       if (sf) {
89114:         sf->RemoveScrollPositionListener(this);
89114:       }
89114:     }
90421: #endif
89114: 
89114:     // Make sure the old frame isn't holding a reference to us.
89114:     mObjectFrame->SetInstanceOwner(nsnull);
90421:   }
89114: 
89114:   // Swap in the new frame (or no frame)
89114:   mObjectFrame = aFrame;
89114: 
89114:   // Set up a new frame
89114:   if (mObjectFrame) {
89114:     mObjectFrame->SetInstanceOwner(this);
89114:     // Can only call PrepForDrawing on an object frame once. Don't do it here unless
89114:     // widget creation is complete. Doesn't matter if we actually have a widget.
89114:     if (mWidgetCreationComplete) {
89114:       mObjectFrame->PrepForDrawing(mWidget);
89114:     }
89114:     mObjectFrame->FixupWindow(mObjectFrame->GetContentRectRelativeToSelf().Size());
89114:     mObjectFrame->Invalidate(mObjectFrame->GetContentRectRelativeToSelf());
90606: 
90606:     // Scroll position listening is only required for Carbon event model plugins on Mac OS X.
90606: #if defined(XP_MACOSX) && !defined(NP_NO_QUICKDRAW)
90606:     // We need to register as a scroll position listener on every scrollable frame up to the top.
90606:     if (GetEventModel() == NPEventModelCarbon) {
90606:       for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
90606:         nsIScrollableFrame* sf = do_QueryFrame(f);
90606:         if (sf) {
90606:           sf->AddScrollPositionListener(this);
90606:         }
90606:       }
90606:     }
90606: #endif
89114:   }
89114: }
89114: 
89114: nsObjectFrame* nsPluginInstanceOwner::GetFrame()
89114: {
89114:   return mObjectFrame;
89114: }
89114: 
    1: // Little helper function to resolve relative URL in
    1: // |value| for certain inputs of |name|
    1: void nsPluginInstanceOwner::FixUpURLS(const nsString &name, nsAString &value)
    1: {
    1:   if (name.LowerCaseEqualsLiteral("pluginurl") ||
    1:       name.LowerCaseEqualsLiteral("pluginspage")) {        
    1:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1:     nsAutoString newURL;
    1:     NS_MakeAbsoluteURI(newURL, value, baseURI);
    1:     if (!newURL.IsEmpty())
    1:       value = newURL;
    1:   }
    1: }
71095: 
71095: // nsPluginDOMContextMenuListener class implementation
71095: 
71095: nsPluginDOMContextMenuListener::nsPluginDOMContextMenuListener()
71095: {
71095: }
71095: 
71095: nsPluginDOMContextMenuListener::~nsPluginDOMContextMenuListener()
71095: {
71095: }
71095: 
75044: NS_IMPL_ISUPPORTS1(nsPluginDOMContextMenuListener,
71095:                    nsIDOMEventListener)
71095: 
71095: NS_IMETHODIMP
75044: nsPluginDOMContextMenuListener::HandleEvent(nsIDOMEvent* aEvent)
71095: {
75044:   aEvent->PreventDefault(); // consume event
71095:   
71095:   return NS_OK;
71095: }
71095: 
71095: nsresult nsPluginDOMContextMenuListener::Init(nsIContent* aContent)
71095: {
71095:   nsCOMPtr<nsIDOMEventTarget> receiver(do_QueryInterface(aContent));
71095:   if (receiver) {
79533:     receiver->AddEventListener(NS_LITERAL_STRING("contextmenu"), this, true);
71095:     return NS_OK;
71095:   }
71095:   
71095:   return NS_ERROR_NO_INTERFACE;
71095: }
71095: 
71095: nsresult nsPluginDOMContextMenuListener::Destroy(nsIContent* aContent)
71095: {
71095:   // Unregister context menu listener
71095:   nsCOMPtr<nsIDOMEventTarget> receiver(do_QueryInterface(aContent));
71095:   if (receiver) {
79533:     receiver->RemoveEventListener(NS_LITERAL_STRING("contextmenu"), this, true);
71095:   }
71095:   
71095:   return NS_OK;
71095: }
