43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is IBM Corporation.
43113:  * Portions created by IBM Corporation are Copyright (C) 2003
43113:  * IBM Corporation. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   IBM Corp.
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsDNSService2.h"
43113: #include "nsIDNSRecord.h"
43113: #include "nsIDNSListener.h"
43113: #include "nsICancelable.h"
43113: #include "nsIProxyObjectManager.h"
43113: #include "nsIPrefService.h"
43113: #include "nsIPrefBranch.h"
43113: #include "nsIPrefBranch2.h"
43113: #include "nsIServiceManager.h"
43113: #include "nsReadableUtils.h"
43113: #include "nsString.h"
43113: #include "nsAutoLock.h"
43113: #include "nsAutoPtr.h"
43113: #include "nsNetCID.h"
43113: #include "nsNetError.h"
43113: #include "nsDNSPrefetch.h"
43832: #include "nsIProtocolProxyService.h"
43113: #include "prsystem.h"
43113: #include "prnetdb.h"
43113: #include "prmon.h"
43113: #include "prio.h"
43113: #include "plstr.h"
43113: 
43113: #include "mozilla/FunctionTimer.h"
43113: 
43113: static const char kPrefDnsCacheEntries[]    = "network.dnsCacheEntries";
43113: static const char kPrefDnsCacheExpiration[] = "network.dnsCacheExpiration";
43113: static const char kPrefEnableIDN[]          = "network.enableIDN";
43113: static const char kPrefIPv4OnlyDomains[]    = "network.dns.ipv4OnlyDomains";
43113: static const char kPrefDisableIPv6[]        = "network.dns.disableIPv6";
43113: static const char kPrefDisablePrefetch[]    = "network.dns.disablePrefetch";
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: class nsDNSRecord : public nsIDNSRecord
43113: {
43113: public:
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSIDNSRECORD
43113: 
43113:     nsDNSRecord(nsHostRecord *hostRecord)
43113:         : mHostRecord(hostRecord)
43113:         , mIter(nsnull)
43113:         , mIterGenCnt(-1)
43113:         , mDone(PR_FALSE) {}
43113: 
43113: private:
43113:     virtual ~nsDNSRecord() {}
43113: 
43113:     nsRefPtr<nsHostRecord>  mHostRecord;
43113:     void                   *mIter;
43113:     int                     mIterGenCnt; // the generation count of
43113:                                          // mHostRecord->addr_info when we
43113:                                          // start iterating
43113:     PRBool                  mDone;
43113: };
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDNSRecord, nsIDNSRecord)
43113: 
43113: NS_IMETHODIMP
43113: nsDNSRecord::GetCanonicalName(nsACString &result)
43113: {
43113:     // this method should only be called if we have a CNAME
43113:     NS_ENSURE_TRUE(mHostRecord->flags & nsHostResolver::RES_CANON_NAME,
43113:                    NS_ERROR_NOT_AVAILABLE);
43113: 
43113:     // if the record is for an IP address literal, then the canonical
43113:     // host name is the IP address literal.
43113:     const char *cname;
43113:     PR_Lock(mHostRecord->addr_info_lock);
43113:     if (mHostRecord->addr_info)
43113:         cname = PR_GetCanonNameFromAddrInfo(mHostRecord->addr_info);
43113:     else
43113:         cname = mHostRecord->host;
43113:     result.Assign(cname);
43113:     PR_Unlock(mHostRecord->addr_info_lock);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSRecord::GetNextAddr(PRUint16 port, PRNetAddr *addr)
43113: {
43113:     // not a programming error to poke the DNS record when it has no more
43113:     // entries.  just fail without any debug warnings.  this enables consumers
43113:     // to enumerate the DNS record without calling HasMore.
43113:     if (mDone)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     PR_Lock(mHostRecord->addr_info_lock);
43113:     if (mHostRecord->addr_info) {
43113:         if (!mIter)
43113:             mIterGenCnt = mHostRecord->addr_info_gencnt;
43113:         else if (mIterGenCnt != mHostRecord->addr_info_gencnt) {
43113:             // mHostRecord->addr_info has changed, so mIter is invalid.
43113:             // Restart the iteration.  Alternatively, we could just fail.
43113:             mIter = nsnull;
43113:             mIterGenCnt = mHostRecord->addr_info_gencnt;
43113:         }
43113:         mIter = PR_EnumerateAddrInfo(mIter, mHostRecord->addr_info, port, addr);
43113:         PR_Unlock(mHostRecord->addr_info_lock);
43113:         if (!mIter) {
43113:             mDone = PR_TRUE;
43113:             return NS_ERROR_NOT_AVAILABLE;
43113:         }
43113:     }
43113:     else {
43113:         PR_Unlock(mHostRecord->addr_info_lock);
43113:         if (!mHostRecord->addr) {
43113:             // Both mHostRecord->addr_info and mHostRecord->addr are null.
43113:             // This can happen if mHostRecord->addr_info expired and the
43113:             // attempt to reresolve it failed.
43113:             return NS_ERROR_NOT_AVAILABLE;
43113:         }
43113:         memcpy(addr, mHostRecord->addr, sizeof(PRNetAddr));
43113:         // set given port
43113:         port = PR_htons(port);
43113:         if (addr->raw.family == PR_AF_INET)
43113:             addr->inet.port = port;
43113:         else
43113:             addr->ipv6.port = port;
43113:         mDone = PR_TRUE; // no iterations
43113:     }
43113:         
43113:     return NS_OK; 
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSRecord::GetNextAddrAsString(nsACString &result)
43113: {
43113:     PRNetAddr addr;
43113:     nsresult rv = GetNextAddr(0, &addr);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     char buf[64];
43113:     if (PR_NetAddrToString(&addr, buf, sizeof(buf)) == PR_SUCCESS) {
43113:         result.Assign(buf);
43113:         return NS_OK;
43113:     }
43113:     NS_ERROR("PR_NetAddrToString failed unexpectedly");
43113:     return NS_ERROR_FAILURE; // conversion failed for some reason
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSRecord::HasMore(PRBool *result)
43113: {
43113:     if (mDone)
43113:         *result = PR_FALSE;
43113:     else {
43113:         // unfortunately, NSPR does not provide a way for us to determine if
43113:         // there is another address other than to simply get the next address.
43113:         void *iterCopy = mIter;
43113:         PRNetAddr addr;
43113:         *result = NS_SUCCEEDED(GetNextAddr(0, &addr));
43113:         mIter = iterCopy; // backup iterator
43113:         mDone = PR_FALSE;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSRecord::Rewind()
43113: {
43113:     mIter = nsnull;
43113:     mIterGenCnt = -1;
43113:     mDone = PR_FALSE;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: class nsDNSAsyncRequest : public nsResolveHostCallback
43113:                         , public nsICancelable
43113: {
43113: public:
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSICANCELABLE
43113: 
43113:     nsDNSAsyncRequest(nsHostResolver   *res,
43113:                       const nsACString &host,
43113:                       nsIDNSListener   *listener,
43113:                       PRUint16          flags,
43113:                       PRUint16          af)
43113:         : mResolver(res)
43113:         , mHost(host)
43113:         , mListener(listener)
43113:         , mFlags(flags)
43113:         , mAF(af) {}
43113:     ~nsDNSAsyncRequest() {}
43113: 
43113:     void OnLookupComplete(nsHostResolver *, nsHostRecord *, nsresult);
43113: 
43113:     nsRefPtr<nsHostResolver> mResolver;
43113:     nsCString                mHost; // hostname we're resolving
43113:     nsCOMPtr<nsIDNSListener> mListener;
43113:     PRUint16                 mFlags;
43113:     PRUint16                 mAF;
43113: };
43113: 
43113: void
43113: nsDNSAsyncRequest::OnLookupComplete(nsHostResolver *resolver,
43113:                                     nsHostRecord   *hostRecord,
43113:                                     nsresult        status)
43113: {
43113:     // need to have an owning ref when we issue the callback to enable
43113:     // the caller to be able to addref/release multiple times without
43113:     // destroying the record prematurely.
43113:     nsCOMPtr<nsIDNSRecord> rec;
43113:     if (NS_SUCCEEDED(status)) {
43113:         NS_ASSERTION(hostRecord, "no host record");
43113:         rec = new nsDNSRecord(hostRecord);
43113:         if (!rec)
43113:             status = NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113: 
43113:     mListener->OnLookupComplete(this, rec, status);
43113:     mListener = nsnull;
43113: 
43113:     // release the reference to ourselves that was added before we were
43113:     // handed off to the host resolver.
43113:     NS_RELEASE_THIS();
43113: }
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDNSAsyncRequest, nsICancelable)
43113: 
43113: NS_IMETHODIMP
43113: nsDNSAsyncRequest::Cancel(nsresult reason)
43113: {
43113:     NS_ENSURE_ARG(NS_FAILED(reason));
43113:     mResolver->DetachCallback(mHost.get(), mFlags, mAF, this, reason);
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: class nsDNSSyncRequest : public nsResolveHostCallback
43113: {
43113: public:
43113:     nsDNSSyncRequest(PRMonitor *mon)
43113:         : mDone(PR_FALSE)
43113:         , mStatus(NS_OK)
43113:         , mMonitor(mon) {}
43113:     virtual ~nsDNSSyncRequest() {}
43113: 
43113:     void OnLookupComplete(nsHostResolver *, nsHostRecord *, nsresult);
43113: 
43113:     PRBool                 mDone;
43113:     nsresult               mStatus;
43113:     nsRefPtr<nsHostRecord> mHostRecord;
43113: 
43113: private:
43113:     PRMonitor             *mMonitor;
43113: };
43113: 
43113: void
43113: nsDNSSyncRequest::OnLookupComplete(nsHostResolver *resolver,
43113:                                    nsHostRecord   *hostRecord,
43113:                                    nsresult        status)
43113: {
43113:     // store results, and wake up nsDNSService::Resolve to process results.
43113:     PR_EnterMonitor(mMonitor);
43113:     mDone = PR_TRUE;
43113:     mStatus = status;
43113:     mHostRecord = hostRecord;
43113:     PR_Notify(mMonitor);
43113:     PR_ExitMonitor(mMonitor);
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsDNSService::nsDNSService()
43113:     : mLock(nsnull)
43113: {
43113: }
43113: 
43113: nsDNSService::~nsDNSService()
43113: {
43113:     if (mLock)
43113:         PR_DestroyLock(mLock);
43113: }
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS3(nsDNSService, nsIDNSService, nsPIDNSService,
43113:                               nsIObserver)
43113: 
43113: NS_IMETHODIMP
43113: nsDNSService::Init()
43113: {
43113:     NS_TIME_FUNCTION;
43113: 
43113:     NS_ENSURE_TRUE(!mResolver, NS_ERROR_ALREADY_INITIALIZED);
43113: 
43113:     PRBool firstTime = (mLock == nsnull);
43113: 
43113:     // prefs
43113:     PRUint32 maxCacheEntries  = 400;
43113:     PRUint32 maxCacheLifetime = 3; // minutes
43113:     PRBool   enableIDN        = PR_TRUE;
43113:     PRBool   disableIPv6      = PR_FALSE;
43113:     PRBool   disablePrefetch  = PR_FALSE;
43832:     int      proxyType        = nsIProtocolProxyService::PROXYCONFIG_DIRECT;
43113:     
43113:     nsAdoptingCString ipv4OnlyDomains;
43113: 
43113:     // read prefs
43113:     nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:     if (prefs) {
43113:         PRInt32 val;
43113:         if (NS_SUCCEEDED(prefs->GetIntPref(kPrefDnsCacheEntries, &val)))
43113:             maxCacheEntries = (PRUint32) val;
43113:         if (NS_SUCCEEDED(prefs->GetIntPref(kPrefDnsCacheExpiration, &val)))
43113:             maxCacheLifetime = val / 60; // convert from seconds to minutes
43113: 
43113:         // ASSUMPTION: pref branch does not modify out params on failure
43113:         prefs->GetBoolPref(kPrefEnableIDN, &enableIDN);
43113:         prefs->GetBoolPref(kPrefDisableIPv6, &disableIPv6);
43113:         prefs->GetCharPref(kPrefIPv4OnlyDomains, getter_Copies(ipv4OnlyDomains));
43113:         prefs->GetBoolPref(kPrefDisablePrefetch, &disablePrefetch);
43113: 
43113:         // If a manual proxy is in use, disable prefetch implicitly
43113:         prefs->GetIntPref("network.proxy.type", &proxyType);
43113:     }
43113: 
43113:     if (firstTime) {
43113:         mLock = PR_NewLock();
43113:         if (!mLock)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:         // register as prefs observer
43113:         if (prefs) {
43113:             prefs->AddObserver(kPrefDnsCacheEntries, this, PR_FALSE);
43113:             prefs->AddObserver(kPrefDnsCacheExpiration, this, PR_FALSE);
43113:             prefs->AddObserver(kPrefEnableIDN, this, PR_FALSE);
43113:             prefs->AddObserver(kPrefIPv4OnlyDomains, this, PR_FALSE);
43113:             prefs->AddObserver(kPrefDisableIPv6, this, PR_FALSE);
43113:             prefs->AddObserver(kPrefDisablePrefetch, this, PR_FALSE);
43113: 
43113:             // Monitor these to see if there is a change in proxy configuration
43113:             // If a manual proxy is in use, disable prefetch implicitly
43113:             prefs->AddObserver("network.proxy.type", this, PR_FALSE);
43113:         }
43113:     }
43113: 
43113:     // we have to null out mIDN since we might be getting re-initialized
43113:     // as a result of a pref change.
43113:     nsCOMPtr<nsIIDNService> idn;
43113:     if (enableIDN)
43113:         idn = do_GetService(NS_IDNSERVICE_CONTRACTID);
43113: 
43113:     nsRefPtr<nsHostResolver> res;
43113:     nsresult rv = nsHostResolver::Create(maxCacheEntries,
43113:                                          maxCacheLifetime,
43113:                                          getter_AddRefs(res));
43113:     if (NS_SUCCEEDED(rv)) {
43113:         // now, set all of our member variables while holding the lock
43113:         nsAutoLock lock(mLock);
43113:         mResolver = res;
43113:         mIDN = idn;
43113:         mIPv4OnlyDomains = ipv4OnlyDomains; // exchanges buffer ownership
43113:         mDisableIPv6 = disableIPv6;
43113: 
43113:         // Disable prefetching either by explicit preference or if a manual proxy is configured 
43832:         mDisablePrefetch = disablePrefetch || (proxyType == nsIProtocolProxyService::PROXYCONFIG_MANUAL);
43113:     }
58389:     
58389:     nsDNSPrefetch::Initialize(this);
43113:     return rv;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSService::Shutdown()
43113: {
43113:     nsRefPtr<nsHostResolver> res;
43113:     {
43113:         nsAutoLock lock(mLock);
43113:         res = mResolver;
43113:         mResolver = nsnull;
43113:     }
43113:     if (res)
43113:         res->Shutdown();
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSService::AsyncResolve(const nsACString  &hostname,
43113:                            PRUint32           flags,
43113:                            nsIDNSListener    *listener,
43113:                            nsIEventTarget    *target,
43113:                            nsICancelable    **result)
43113: {
43113:     // grab reference to global host resolver and IDN service.  beware
43113:     // simultaneous shutdown!!
43113:     nsRefPtr<nsHostResolver> res;
43113:     nsCOMPtr<nsIIDNService> idn;
43113:     {
43113:         nsAutoLock lock(mLock);
43113: 
43113:         if (mDisablePrefetch && (flags & RESOLVE_SPECULATE))
43113:             return NS_ERROR_DNS_LOOKUP_QUEUE_FULL;
43113: 
43113:         res = mResolver;
43113:         idn = mIDN;
43113:     }
43113:     if (!res)
43113:         return NS_ERROR_OFFLINE;
43113: 
43113:     const nsACString *hostPtr = &hostname;
43113: 
43113:     nsresult rv;
43113:     nsCAutoString hostACE;
43113:     if (idn && !IsASCII(hostname)) {
43113:         if (NS_SUCCEEDED(idn->ConvertUTF8toACE(hostname, hostACE)))
43113:             hostPtr = &hostACE;
43113:     }
43113: 
43113:     nsCOMPtr<nsIDNSListener> listenerProxy;
43113:     if (target) {
43113:         rv = NS_GetProxyForObject(target,
43113:                                   NS_GET_IID(nsIDNSListener),
43113:                                   listener,
43113:                                   NS_PROXY_ASYNC | NS_PROXY_ALWAYS,
43113:                                   getter_AddRefs(listenerProxy));
43113:         if (NS_FAILED(rv)) return rv;
43113:         listener = listenerProxy;
43113:     }
43113: 
43113:     PRUint16 af = GetAFForLookup(*hostPtr);
43113: 
43113:     nsDNSAsyncRequest *req =
43113:             new nsDNSAsyncRequest(res, *hostPtr, listener, flags, af);
43113:     if (!req)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     NS_ADDREF(*result = req);
43113: 
43113:     // addref for resolver; will be released when OnLookupComplete is called.
43113:     NS_ADDREF(req);
43113:     rv = res->ResolveHost(req->mHost.get(), flags, af, req);
43113:     if (NS_FAILED(rv)) {
43113:         NS_RELEASE(req);
43113:         NS_RELEASE(*result);
43113:     }
43113:     return rv;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSService::Resolve(const nsACString &hostname,
43113:                       PRUint32          flags,
43113:                       nsIDNSRecord    **result)
43113: {
43113:     // grab reference to global host resolver and IDN service.  beware
43113:     // simultaneous shutdown!!
43113:     nsRefPtr<nsHostResolver> res;
43113:     nsCOMPtr<nsIIDNService> idn;
43113:     {
43113:         nsAutoLock lock(mLock);
43113:         res = mResolver;
43113:         idn = mIDN;
43113:     }
43113:     NS_ENSURE_TRUE(res, NS_ERROR_OFFLINE);
43113: 
43113:     const nsACString *hostPtr = &hostname;
43113: 
43113:     nsresult rv;
43113:     nsCAutoString hostACE;
43113:     if (idn && !IsASCII(hostname)) {
43113:         if (NS_SUCCEEDED(idn->ConvertUTF8toACE(hostname, hostACE)))
43113:             hostPtr = &hostACE;
43113:     }
43113: 
43113:     //
43113:     // sync resolve: since the host resolver only works asynchronously, we need
43113:     // to use a mutex and a condvar to wait for the result.  however, since the
43113:     // result may be in the resolvers cache, we might get called back recursively
43113:     // on the same thread.  so, our mutex needs to be re-entrant.  in other words,
43113:     // we need to use a monitor! ;-)
43113:     //
43113:     
43113:     PRMonitor *mon = PR_NewMonitor();
43113:     if (!mon)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     PR_EnterMonitor(mon);
43113:     nsDNSSyncRequest syncReq(mon);
43113: 
43113:     PRUint16 af = GetAFForLookup(*hostPtr);
43113: 
43113:     rv = res->ResolveHost(PromiseFlatCString(*hostPtr).get(), flags, af, &syncReq);
43113:     if (NS_SUCCEEDED(rv)) {
43113:         // wait for result
43113:         while (!syncReq.mDone)
43113:             PR_Wait(mon, PR_INTERVAL_NO_TIMEOUT);
43113: 
43113:         if (NS_FAILED(syncReq.mStatus))
43113:             rv = syncReq.mStatus;
43113:         else {
43113:             NS_ASSERTION(syncReq.mHostRecord, "no host record");
43113:             nsDNSRecord *rec = new nsDNSRecord(syncReq.mHostRecord);
43113:             if (!rec)
43113:                 rv = NS_ERROR_OUT_OF_MEMORY;
43113:             else
43113:                 NS_ADDREF(*result = rec);
43113:         }
43113:     }
43113: 
43113:     PR_ExitMonitor(mon);
43113:     PR_DestroyMonitor(mon);
43113:     return rv;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSService::GetMyHostName(nsACString &result)
43113: {
43113:     char name[100];
43113:     if (PR_GetSystemInfo(PR_SI_HOSTNAME, name, sizeof(name)) == PR_SUCCESS) {
43113:         result = name;
43113:         return NS_OK;
43113:     }
43113:     return NS_ERROR_FAILURE;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsDNSService::Observe(nsISupports *subject, const char *topic, const PRUnichar *data)
43113: {
43113:     // we are only getting called if a preference has changed. 
43113:     NS_ASSERTION(strcmp(topic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) == 0,
43113:         "unexpected observe call");
43113: 
43113:     //
43113:     // Shutdown and this function are both only called on the UI thread, so we don't
43113:     // have to worry about mResolver being cleared out from under us.
43113:     //
43113:     // NOTE Shutting down and reinitializing the service like this is obviously
43113:     // suboptimal if Observe gets called several times in a row, but we don't
43113:     // expect that to be the case.
43113:     //
43113: 
43113:     if (mResolver) {
43113:         Shutdown();
58389:         Init();
58375:     }
43113:     return NS_OK;
43113: }
43113: 
43113: PRUint16
43113: nsDNSService::GetAFForLookup(const nsACString &host)
43113: {
43113:     if (mDisableIPv6)
43113:         return PR_AF_INET;
43113: 
43113:     nsAutoLock lock(mLock);
43113: 
43113:     PRUint16 af = PR_AF_UNSPEC;
43113: 
43113:     if (!mIPv4OnlyDomains.IsEmpty()) {
43113:         const char *domain, *domainEnd, *end;
43113:         PRUint32 hostLen, domainLen;
43113: 
43113:         // see if host is in one of the IPv4-only domains
43113:         domain = mIPv4OnlyDomains.BeginReading();
43113:         domainEnd = mIPv4OnlyDomains.EndReading(); 
43113: 
43113:         nsACString::const_iterator hostStart;
43113:         host.BeginReading(hostStart);
43113:         hostLen = host.Length();
43113: 
43113:         do {
43113:             // skip any whitespace
43113:             while (*domain == ' ' || *domain == '\t')
43113:                 ++domain;
43113: 
43113:             // find end of this domain in the string
43113:             end = strchr(domain, ',');
43113:             if (!end)
43113:                 end = domainEnd;
43113: 
43113:             // to see if the hostname is in the domain, check if the domain
43113:             // matches the end of the hostname.
43113:             domainLen = end - domain;
43113:             if (domainLen && hostLen >= domainLen) {
43113:                 const char *hostTail = hostStart.get() + hostLen - domainLen;
43113:                 if (PL_strncasecmp(domain, hostTail, domainLen) == 0) {
43113:                     // now, make sure either that the hostname is a direct match or
43113:                     // that the hostname begins with a dot.
43113:                     if (hostLen == domainLen ||
43113:                             *hostTail == '.' || *(hostTail - 1) == '.') {
43113:                         af = PR_AF_INET;
43113:                         break;
43113:                     }
43113:                 }
43113:             }
43113: 
43113:             domain = end + 1;
43113:         } while (*end);
43113:     }
43113: 
43113:     return af;
43113: }
