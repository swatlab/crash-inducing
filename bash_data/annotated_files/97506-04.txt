    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 4042:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* JavaScript JSClasses and JSOps for our Wrapped Native JS Objects. */
    1: 
    1: #include "xpcprivate.h"
25050: #include "XPCWrapper.h"
80074: #include "nsWrapperCacheInlines.h"
97422: #include "mozilla/dom/BindingUtils.h"
    1: 
    1: /***************************************************************************/
    1: 
    1: // All of the exceptions thrown into JS from this file go through here.
    1: // That makes this a nice place to set a breakpoint.
    1: 
91237: static JSBool Throw(unsigned errNum, JSContext* cx)
    1: {
    1:     XPCThrower::Throw(errNum, cx);
82794:     return false;
    1: }
    1: 
    1: // Handy macro used in many callback stub below.
    1: 
30001: #define MORPH_SLIM_WRAPPER(cx, obj)                                           \
30001:     PR_BEGIN_MACRO                                                            \
30001:     SLIM_LOG_WILL_MORPH(cx, obj);                                             \
30001:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))                   \
30001:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);                    \
30001:     PR_END_MACRO
30001: 
    1: #define THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper)                          \
    1:     PR_BEGIN_MACRO                                                            \
    1:     if (!wrapper)                                                             \
    1:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);                    \
    1:     if (!wrapper->IsValid())                                                  \
    1:         return Throw(NS_ERROR_XPC_HAS_BEEN_SHUTDOWN, cx);                     \
    1:     PR_END_MACRO
    1: 
    1: /***************************************************************************/
    1: 
    1: static JSBool
    1: ToStringGuts(XPCCallContext& ccx)
    1: {
    1:     char* sz;
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1: 
    1:     if (wrapper)
    1:         sz = wrapper->ToString(ccx, ccx.GetTearOff());
    1:     else
    1:         sz = JS_smprintf("[xpconnect wrapped native prototype]");
    1: 
80389:     if (!sz) {
    1:         JS_ReportOutOfMemory(ccx);
82794:         return false;
    1:     }
    1: 
58975:     JSString* str = JS_NewStringCopyZ(ccx, sz);
58975:     JS_smprintf_free(sz);
58920:     if (!str)
82794:         return false;
    1: 
    1:     ccx.SetRetVal(STRING_TO_JSVAL(str));
82794:     return true;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
18907: static JSBool
91237: XPC_WN_Shared_ToString(JSContext *cx, unsigned argc, jsval *vp)
    1: {
53557:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
53557:     if (!obj)
82794:         return false;
53557: 
80389:     if (IS_SLIM_WRAPPER(obj)) {
30001:         XPCNativeScriptableInfo *si =
30001:             GetSlimWrapperProto(obj)->GetScriptableInfo();
30001: #ifdef DEBUG
30001: #  define FMT_ADDR " @ 0x%p"
30001: #  define FMT_STR(str) str
30001: #  define PARAM_ADDR(w) , w
30001: #else
30001: #  define FMT_ADDR ""
30001: #  define FMT_STR(str)
30001: #  define PARAM_ADDR(w)
30001: #endif
30001:         char *sz = JS_smprintf("[object %s" FMT_ADDR FMT_STR(" (native") FMT_ADDR FMT_STR(")") "]", si->GetJSClass()->name PARAM_ADDR(obj) PARAM_ADDR(xpc_GetJSPrivate(obj)));
30001:         if (!sz)
82794:             return false;
30001: 
58975:         JSString* str = JS_NewStringCopyZ(cx, sz);
58975:         JS_smprintf_free(sz);
58920:         if (!str)
82794:             return false;
30001: 
30001:         *vp = STRING_TO_JSVAL(str);
30001: 
82794:         return true;
30001:     }
30001: 
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
48470:     ccx.SetName(ccx.GetRuntime()->GetStringID(XPCJSRuntime::IDX_TO_STRING));
53557:     ccx.SetArgsAndResultPtr(argc, JS_ARGV(cx, vp), vp);
    1:     return ToStringGuts(ccx);
    1: }
    1: 
18907: static JSBool
91237: XPC_WN_Shared_ToSource(JSContext *cx, unsigned argc, jsval *vp)
    1: {
30317:     static const char empty[] = "({})";
30317:     JSString *str = JS_NewStringCopyN(cx, empty, sizeof(empty)-1);
30317:     if (!str)
82794:         return false;
30317:     *vp = STRING_TO_JSVAL(str);
30317: 
82794:     return true;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // A "double wrapped object" is a user JSObject that has been wrapped as a
    1: // wrappedJS in order to be used by native code and then re-wrapped by a
    1: // wrappedNative wrapper to be used by JS code. One might think of it as:
    1: //    wrappedNative(wrappedJS(underlying_JSObject))
    1: // This is done (as opposed to just unwrapping the wrapped JS and automatically
    1: // returning the underlying JSObject) so that JS callers will see what looks
    1: // Like any other xpcom object - and be limited to use its interfaces.
    1: //
42263: // See the comment preceding nsIXPCWrappedJSObjectGetter in nsIXPConnect.idl.
    1: 
    1: static JSObject*
    1: GetDoubleWrappedJSObject(XPCCallContext& ccx, XPCWrappedNative* wrapper)
    1: {
    1:     JSObject* obj = nsnull;
    1:     nsCOMPtr<nsIXPConnectWrappedJS>
    1:         underware = do_QueryInterface(wrapper->GetIdentityObject());
80389:     if (underware) {
    1:         JSObject* mainObj = nsnull;
80389:         if (NS_SUCCEEDED(underware->GetJSObject(&mainObj)) && mainObj) {
    1:             jsid id = ccx.GetRuntime()->
    1:                     GetStringID(XPCJSRuntime::IDX_WRAPPED_JSOBJECT);
    1: 
55662:             JSAutoEnterCompartment ac;
55662:             if (!ac.enter(ccx, mainObj))
55662:                 return NULL;
55662: 
    1:             jsval val;
26167:             if (JS_GetPropertyById(ccx, mainObj, id, &val) &&
80389:                 !JSVAL_IS_PRIMITIVE(val)) {
    1:                 obj = JSVAL_TO_OBJECT(val);
    1:             }
    1:         }
    1:     }
    1:     return obj;
    1: }
    1: 
    1: // This is the getter native function we use to handle 'wrappedJSObject' for
    1: // double wrapped JSObjects.
    1: 
18907: static JSBool
91237: XPC_WN_DoubleWrappedGetter(JSContext *cx, unsigned argc, jsval *vp)
    1: {
53557:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
53557:     if (!obj)
82794:         return false;
53557: 
30001:     MORPH_SLIM_WRAPPER(cx, obj);
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
53557:     NS_ASSERTION(JS_TypeOfValue(cx, JS_CALLEE(cx, vp)) == JSTYPE_FUNCTION, "bad function");
    1: 
    1:     JSObject* realObject = GetDoubleWrappedJSObject(ccx, wrapper);
80389:     if (!realObject) {
    1:         // This is pretty unexpected at this point. The object originally
    1:         // responded to this get property call and now gives no object.
    1:         // XXX Should this throw something at the caller?
    1:         *vp = JSVAL_NULL;
82794:         return true;
    1:     }
    1: 
    1:     // It is a double wrapped object. Figure out if the caller
    1:     // is allowed to see it.
    1: 
    1:     nsIXPCSecurityManager* sm;
    1:     XPCContext* xpcc = ccx.GetXPCContext();
    1: 
80387:     sm = xpcc->GetAppropriateSecurityManager(nsIXPCSecurityManager::HOOK_GET_PROPERTY);
80389:     if (sm) {
    1:         AutoMarkingNativeInterfacePtr iface(ccx);
    1:         iface = XPCNativeInterface::
    1:                     GetNewOrUsed(ccx, &NS_GET_IID(nsIXPCWrappedJSObjectGetter));
    1: 
80389:         if (iface) {
48470:             jsid id = ccx.GetRuntime()->
48470:                         GetStringID(XPCJSRuntime::IDX_WRAPPED_JSOBJECT);
    1: 
82794:             ccx.SetCallInfo(iface, iface->GetMemberAt(1), false);
    1:             if (NS_FAILED(sm->
    1:                           CanAccess(nsIXPCSecurityManager::ACCESS_GET_PROPERTY,
    1:                                     &ccx, ccx,
    1:                                     ccx.GetFlattenedJSObject(),
    1:                                     wrapper->GetIdentityObject(),
48470:                                     wrapper->GetClassInfo(), id,
80389:                                     wrapper->GetSecurityInfoAddr()))) {
    1:                 // The SecurityManager should have set an exception.
82794:                 return false;
    1:             }
    1:         }
    1:     }
    1:     *vp = OBJECT_TO_JSVAL(realObject);
55662:     return JS_WrapValue(cx, vp);
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // This is our shared function to define properties on our JSObjects.
    1: 
    1: /*
    1:  * NOTE:
    1:  * We *never* set the tearoff names (e.g. nsIFoo) as JS_ENUMERATE.
    1:  * We *never* set toString or toSource as JS_ENUMERATE.
    1:  */
    1: 
    1: static JSBool
    1: DefinePropertyIfFound(XPCCallContext& ccx,
48470:                       JSObject *obj, jsid id,
    1:                       XPCNativeSet* set,
    1:                       XPCNativeInterface* iface,
    1:                       XPCNativeMember* member,
    1:                       XPCWrappedNativeScope* scope,
    1:                       JSBool reflectToStringAndToSource,
    1:                       XPCWrappedNative* wrapperToReflectInterfaceNames,
    1:                       XPCWrappedNative* wrapperToReflectDoubleWrap,
    1:                       XPCNativeScriptableInfo* scriptableInfo,
91237:                       unsigned propFlags,
    1:                       JSBool* resolved)
    1: {
    1:     XPCJSRuntime* rt = ccx.GetRuntime();
    1:     JSBool found;
    1:     const char* name;
    1: 
80389:     if (set) {
    1:         if (iface)
82794:             found = true;
    1:         else
48470:             found = set->FindMember(id, &member, &iface);
80390:     } else
48470:         found = (nsnull != (member = iface->FindMember(id)));
    1: 
80389:     if (!found) {
80389:         if (reflectToStringAndToSource) {
    1:             JSNative call;
    1: 
80389:             if (id == rt->GetStringID(XPCJSRuntime::IDX_TO_STRING)) {
    1:                 call = XPC_WN_Shared_ToString;
    1:                 name = rt->GetStringName(XPCJSRuntime::IDX_TO_STRING);
    1:                 id   = rt->GetStringID(XPCJSRuntime::IDX_TO_STRING);
80390:             } else if (id == rt->GetStringID(XPCJSRuntime::IDX_TO_SOURCE)) {
    1:                 call = XPC_WN_Shared_ToSource;
    1:                 name = rt->GetStringName(XPCJSRuntime::IDX_TO_SOURCE);
    1:                 id   = rt->GetStringID(XPCJSRuntime::IDX_TO_SOURCE);
    1:             }
    1: 
    1:             else
    1:                 call = nsnull;
    1: 
80389:             if (call) {
    1:                 JSFunction* fun = JS_NewFunction(ccx, call, 0, 0, obj, name);
80389:                 if (!fun) {
    1:                     JS_ReportOutOfMemory(ccx);
82794:                     return false;
    1:                 }
    1: 
48470:                 AutoResolveName arn(ccx, id);
    1:                 if (resolved)
82794:                     *resolved = true;
26167:                 return JS_DefinePropertyById(ccx, obj, id,
    1:                                              OBJECT_TO_JSVAL(JS_GetFunctionObject(fun)),
    1:                                              nsnull, nsnull,
26167:                                              propFlags & ~JSPROP_ENUMERATE);
    1:             }
    1:         }
    1:         // This *might* be a tearoff name that is not yet part of our
    1:         // set. Let's lookup the name and see if it is the name of an
    1:         // interface. Then we'll see if the object actually *does* this
    1:         // interface and add a tearoff as necessary.
    1: 
80389:         if (wrapperToReflectInterfaceNames) {
57812:             JSAutoByteString name;
    1:             AutoMarkingNativeInterfacePtr iface2(ccx);
    1:             XPCWrappedNativeTearOff* to;
    1:             JSObject* jso;
60212:             nsresult rv = NS_OK;
    1: 
48470:             if (JSID_IS_STRING(id) &&
57812:                 name.encode(ccx, JSID_TO_STRING(id)) &&
57812:                 (iface2 = XPCNativeInterface::GetNewOrUsed(ccx, name.ptr()), iface2) &&
    1:                 nsnull != (to = wrapperToReflectInterfaceNames->
82794:                            FindTearOff(ccx, iface2, true, &rv)) &&
    1:                 nsnull != (jso = to->GetJSObject()))
    1: 
    1:             {
48470:                 AutoResolveName arn(ccx, id);
    1:                 if (resolved)
82794:                     *resolved = true;
48470:                 return JS_DefinePropertyById(ccx, obj, id, OBJECT_TO_JSVAL(jso),
    1:                                              nsnull, nsnull,
26167:                                              propFlags & ~JSPROP_ENUMERATE);
80390:             } else if (NS_FAILED(rv) && rv != NS_ERROR_NO_INTERFACE) {
60212:                 return Throw(rv, ccx);
60212:             }
    1:         }
    1: 
    1:         // This *might* be a double wrapped JSObject
    1:         if (wrapperToReflectDoubleWrap &&
48470:             id == rt->GetStringID(XPCJSRuntime::IDX_WRAPPED_JSOBJECT) &&
80389:             GetDoubleWrappedJSObject(ccx, wrapperToReflectDoubleWrap)) {
    1:             // We build and add a getter function.
    1:             // A security check is done on a per-get basis.
    1: 
    1:             JSFunction* fun;
    1: 
    1:             id = rt->GetStringID(XPCJSRuntime::IDX_WRAPPED_JSOBJECT);
    1:             name = rt->GetStringName(XPCJSRuntime::IDX_WRAPPED_JSOBJECT);
    1: 
    1:             fun = JS_NewFunction(ccx, XPC_WN_DoubleWrappedGetter,
48607:                                  0, 0, obj, name);
    1: 
    1:             if (!fun)
82794:                 return false;
    1: 
    1:             JSObject* funobj = JS_GetFunctionObject(fun);
    1:             if (!funobj)
82794:                 return false;
    1: 
    1:             propFlags |= JSPROP_GETTER;
    1:             propFlags &= ~JSPROP_ENUMERATE;
    1: 
48470:             AutoResolveName arn(ccx, id);
    1:             if (resolved)
82794:                 *resolved = true;
26167:             return JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID,
26167:                                          JS_DATA_TO_FUNC_PTR(JSPropertyOp,
26167:                                                              funobj),
26167:                                          nsnull, propFlags);
    1:         }
    1: 
    1:         if (resolved)
82794:             *resolved = false;
82794:         return true;
    1:     }
    1: 
80389:     if (!member) {
80389:         if (wrapperToReflectInterfaceNames) {
    1:             XPCWrappedNativeTearOff* to =
82794:               wrapperToReflectInterfaceNames->FindTearOff(ccx, iface, true);
    1: 
    1:             if (!to)
82794:                 return false;
    1:             JSObject* jso = to->GetJSObject();
    1:             if (!jso)
82794:                 return false;
    1: 
48470:             AutoResolveName arn(ccx, id);
    1:             if (resolved)
82794:                 *resolved = true;
48470:             return JS_DefinePropertyById(ccx, obj, id, OBJECT_TO_JSVAL(jso),
    1:                                          nsnull, nsnull,
26167:                                          propFlags & ~JSPROP_ENUMERATE);
    1:         }
    1:         if (resolved)
82794:             *resolved = false;
82794:         return true;
    1:     }
    1: 
80389:     if (member->IsConstant()) {
    1:         jsval val;
48470:         AutoResolveName arn(ccx, id);
    1:         if (resolved)
82794:             *resolved = true;
10471:         return member->GetConstantValue(ccx, iface, &val) &&
26167:                JS_DefinePropertyById(ccx, obj, id, val, nsnull, nsnull,
26167:                                      propFlags);
    1:     }
    1: 
48470:     if (id == rt->GetStringID(XPCJSRuntime::IDX_TO_STRING) ||
48470:         id == rt->GetStringID(XPCJSRuntime::IDX_TO_SOURCE) ||
    1:         (scriptableInfo &&
    1:          scriptableInfo->GetFlags().DontEnumQueryInterface() &&
48470:          id == rt->GetStringID(XPCJSRuntime::IDX_QUERY_INTERFACE)))
    1:         propFlags &= ~JSPROP_ENUMERATE;
    1: 
    1:     jsval funval;
10471:     if (!member->NewFunctionObject(ccx, iface, obj, &funval))
82794:         return false;
    1: 
10471:     // protect funobj until it is actually attached
10397:     AUTO_MARK_JSVAL(ccx, funval);
10397: 
    1: #ifdef off_DEBUG_jband
    1:     {
    1:         static int cloneCount = 0;
    1:         if (!(++cloneCount%10))
    1:             printf("<><><> %d cloned functions created\n", cloneCount);
    1:     }
    1: #endif
    1: 
80389:     if (member->IsMethod()) {
48470:         AutoResolveName arn(ccx, id);
    1:         if (resolved)
82794:             *resolved = true;
48470:         return JS_DefinePropertyById(ccx, obj, id, funval, nsnull, nsnull,
26167:                                      propFlags);
    1:     }
    1: 
    1:     // else...
    1: 
    1:     NS_ASSERTION(member->IsAttribute(), "way broken!");
    1: 
    1:     propFlags |= JSPROP_GETTER | JSPROP_SHARED;
27641:     JSObject* funobj = JSVAL_TO_OBJECT(funval);
27641:     JSPropertyOp getter = JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj);
62397:     JSStrictPropertyOp setter;
80389:     if (member->IsWritableAttribute()) {
    1:         propFlags |= JSPROP_SETTER;
    1:         propFlags &= ~JSPROP_READONLY;
62397:         setter = JS_DATA_TO_FUNC_PTR(JSStrictPropertyOp, funobj);
80390:     } else {
27641:         setter = js_GetterOnlyPropertyStub;
    1:     }
    1: 
48470:     AutoResolveName arn(ccx, id);
    1:     if (resolved)
82794:         *resolved = true;
10471: 
48470:     return JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID, getter, setter,
26167:                                  propFlags);
    1: }
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: 
18907: static JSBool
62397: XPC_WN_OnlyIWrite_AddPropertyStub(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
48470:     XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, id);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
62397:     // Allow only XPConnect to add/set the property
48470:     if (ccx.GetResolveName() == id)
82794:         return true;
    1: 
    1:     return Throw(NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN, cx);
    1: }
    1: 
18907: static JSBool
62397: XPC_WN_OnlyIWrite_SetPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
62397: {
62397:     return XPC_WN_OnlyIWrite_AddPropertyStub(cx, obj, id, vp);
62397: }
62397: 
62397: static JSBool
48470: XPC_WN_CannotModifyPropertyStub(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     return Throw(NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN, cx);
    1: }
    1: 
18907: static JSBool
62397: XPC_WN_CannotModifyStrictPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict,
62397:                                       jsval *vp)
62397: {
62397:     return XPC_WN_CannotModifyPropertyStub(cx, obj, id, vp);
62397: }
62397: 
62397: static JSBool
    1: XPC_WN_Shared_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
80389:     if (type == JSTYPE_OBJECT) {
    1:         *vp = OBJECT_TO_JSVAL(obj);
82794:         return true;
    1:     }
    1: 
30001:     MORPH_SLIM_WRAPPER(cx, obj);
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
80389:     switch (type) {
    1:         case JSTYPE_FUNCTION:
    1:             {
80389:                 if (!ccx.GetTearOff()) {
    1:                     XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
    1:                     if (si && (si->GetFlags().WantCall() ||
80389:                                si->GetFlags().WantConstruct())) {
    1:                         *vp = OBJECT_TO_JSVAL(obj);
82794:                         return true;
    1:                     }
    1:                 }
    1:             }
    1:             return Throw(NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN, cx);
    1:         case JSTYPE_NUMBER:
    1:             *vp = JS_GetNaNValue(cx);
82794:             return true;
    1:         case JSTYPE_BOOLEAN:
    1:             *vp = JSVAL_TRUE;
82794:             return true;
    1:         case JSTYPE_VOID:
    1:         case JSTYPE_STRING:
    1:         {
48470:             ccx.SetName(ccx.GetRuntime()->GetStringID(XPCJSRuntime::IDX_TO_STRING));
    1:             ccx.SetArgsAndResultPtr(0, nsnull, vp);
    1: 
    1:             XPCNativeMember* member = ccx.GetMember();
80389:             if (member && member->IsMethod()) {
    1:                 if (!XPCWrappedNative::CallMethod(ccx))
82794:                     return false;
    1: 
    1:                 if (JSVAL_IS_PRIMITIVE(*vp))
82794:                     return true;
    1:             }
    1: 
    1:             // else...
    1:             return ToStringGuts(ccx);
    1:         }
    1:         default:
    1:             NS_ERROR("bad type in conversion");
82794:             return false;
    1:     }
    1:     NS_NOTREACHED("huh?");
82794:     return false;
    1: }
    1: 
18907: static JSBool
    1: XPC_WN_Shared_Enumerate(JSContext *cx, JSObject *obj)
    1: {
30001:     MORPH_SLIM_WRAPPER(cx, obj);
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     // Since we aren't going to enumerate tearoff names and the prototype
    1:     // handles non-mutated members, we can do this potential short-circuit.
    1:     if (!wrapper->HasMutatedSet())
82794:         return true;
    1: 
    1:     XPCNativeSet* set = wrapper->GetSet();
    1:     XPCNativeSet* protoSet = wrapper->HasProto() ?
    1:                                 wrapper->GetProto()->GetSet() : nsnull;
    1: 
    1:     PRUint16 interface_count = set->GetInterfaceCount();
    1:     XPCNativeInterface** interfaceArray = set->GetInterfaceArray();
80389:     for (PRUint16 i = 0; i < interface_count; i++) {
    1:         XPCNativeInterface* iface = interfaceArray[i];
    1:         PRUint16 member_count = iface->GetMemberCount();
80389:         for (PRUint16 k = 0; k < member_count; k++) {
    1:             XPCNativeMember* member = iface->GetMemberAt(k);
48470:             jsid name = member->GetName();
    1: 
    1:             // Skip if this member is going to come from the proto.
    1:             PRUint16 index;
    1:             if (protoSet &&
    1:                 protoSet->FindMember(name, nsnull, &index) && index == i)
    1:                 continue;
    1:             if (!xpc_ForcePropertyResolve(cx, obj, name))
82794:                 return false;
    1:         }
    1:     }
82794:     return true;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
33785: #ifdef DEBUG_slimwrappers
33785: static PRUint32 sFinalizedSlimWrappers;
33785: #endif
33785: 
18907: static void
94738: XPC_WN_NoHelper_Finalize(js::FreeOp *fop, JSObject *obj)
    1: {
94512:     js::Class* clazz = js::GetObjectClass(obj);
94512:     if (clazz->flags & JSCLASS_DOM_GLOBAL) {
97422:         mozilla::dom::DestroyProtoOrIfaceCache(obj);
94512:     }
33785:     nsISupports* p = static_cast<nsISupports*>(xpc_GetJSPrivate(obj));
    1:     if (!p)
    1:         return;
33785: 
80389:     if (IS_SLIM_WRAPPER_OBJECT(obj)) {
33785:         SLIM_LOG(("----- %i finalized slim wrapper (%p, %p)\n",
33785:                   ++sFinalizedSlimWrappers, obj, p));
33785: 
33785:         nsWrapperCache* cache;
33785:         CallQueryInterface(p, &cache);
33785:         cache->ClearWrapper();
85977: 
85977:         XPCJSRuntime *rt = nsXPConnect::GetRuntimeInstance();
85977:         if(rt)
85977:             rt->DeferredRelease(p);
85977:         else
33785:             NS_RELEASE(p);
33785:         return;
33785:     }
33785: 
89826:     static_cast<XPCWrappedNative*>(p)->FlatJSObjectFinalized();
    1: }
    1: 
    1: static void
 1025: TraceScopeJSObjects(JSTracer *trc, XPCWrappedNativeScope* scope)
    1: {
    1:     NS_ASSERTION(scope, "bad scope");
    1: 
    1:     JSObject* obj;
    1: 
96904:     obj = scope->GetGlobalJSObject();
 7230:     NS_ASSERTION(obj, "bad scope JSObject");
 1025:     JS_CALL_OBJECT_TRACER(trc, obj, "XPCWrappedNativeScope::mGlobalJSObject");
    1: 
96904:     obj = scope->GetPrototypeJSObject();
80389:     if (obj) {
 1025:         JS_CALL_OBJECT_TRACER(trc, obj,
 1025:                               "XPCWrappedNativeScope::mPrototypeJSObject");
    1:     }
    1: }
    1: 
71347: static void
71347: TraceForValidWrapper(JSTracer *trc, XPCWrappedNative* wrapper)
    1: {
 1025:     // NOTE: It might be nice to also do the wrapper->Mark() call here too
 1025:     // when we are called during the marking phase of JS GC to mark the
 1025:     // wrapper's and wrapper's proto's interface sets.
 1025:     //
    1:     // We currently do that in the GC callback code. The reason we don't do that
    1:     // here is because the bits used in that marking do unpleasant things to the
    1:     // member counts in the interface and interface set objects. Those counts
    1:     // are used in the DealWithDyingGCThings calls that are part of this JS GC
    1:     // marking phase. By doing these calls later during our GC callback we
    1:     // avoid that problem. Arguably this could be changed. But it ain't broke.
 1025:     //
 1025:     // However, we do need to call the wrapper's TraceJS so that
 1025:     // it can be sure that its (potentially shared) JSClass is traced. The
    1:     // danger is that a live wrapper might not be in a wrapper map and thus
    1:     // won't be fully marked in the GC callback. This can happen if there is
    1:     // a security exception during wrapper creation or if during wrapper
    1:     // creation it is determined that the wrapper is not needed. In those cases
    1:     // the wrapper can never actually be used from JS code - so resources like
    1:     // the interface set will never be accessed. But the JS engine will still
    1:     // need to use the JSClass. So, some marking is required for protection.
    1: 
 1025:     wrapper->TraceJS(trc);
    1: 
 1025:     TraceScopeJSObjects(trc, wrapper->GetScope());
    1: }
    1: 
18907: static void
86631: MarkWrappedNative(JSTracer *trc, JSObject *obj)
    1: {
97506:     js::Class* clazz = js::GetObjectClass(obj);
97506:     if (clazz->flags & JSCLASS_DOM_GLOBAL) {
97506:         mozilla::dom::TraceProtoOrIfaceCache(trc, obj);
97506:     }
97506: 
33785:     JSObject *obj2;
71347: 
71347:     // Pass null for the first JSContext* parameter  to skip any security
71347:     // checks and to avoid potential state change there.
    1:     XPCWrappedNative* wrapper =
71347:         XPCWrappedNative::GetWrappedNativeOfJSObject(nsnull, obj, nsnull, &obj2);
    1: 
80389:     if (wrapper) {
86631:         if (wrapper->IsValid())
71347:              TraceForValidWrapper(trc, wrapper);
80390:     } else if (obj2) {
33785:         GetSlimWrapperProto(obj2)->TraceJS(trc);
33785:     }
33785: }
    1: 
71347: static void
86631: XPC_WN_NoHelper_Trace(JSTracer *trc, JSObject *obj)
71347: {
86631:     MarkWrappedNative(trc, obj);
71347: }
71347: 
18907: static JSBool
48470: XPC_WN_NoHelper_Resolve(JSContext *cx, JSObject *obj, jsid id)
    1: {
30001:     MORPH_SLIM_WRAPPER(cx, obj);
48470:     XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, id);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCNativeSet* set = ccx.GetSet();
    1:     if (!set)
82794:         return true;
    1: 
    1:     // Don't resolve properties that are on our prototype.
    1:     if (ccx.GetInterface() && !ccx.GetStaticMemberIsLocal())
82794:         return true;
    1: 
48470:     return DefinePropertyIfFound(ccx, obj, id,
    1:                                  set, nsnull, nsnull, wrapper->GetScope(),
82794:                                  true, wrapper, wrapper, nsnull,
    1:                                  JSPROP_ENUMERATE |
    1:                                  JSPROP_READONLY |
    1:                                  JSPROP_PERMANENT, nsnull);
    1: }
    1: 
    1: nsISupports *
    1: XPC_GetIdentityObject(JSContext *cx, JSObject *obj)
    1: {
55659:     XPCWrappedNative *wrapper =
55659:         XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);
    1: 
55659:     return wrapper ? wrapper->GetIdentityObject() : nsnull;
    1: }
    1: 
30001: JSBool
48470: XPC_WN_Equality(JSContext *cx, JSObject *obj, const jsval *valp, JSBool *bp)
    1: {
48470:     jsval v = *valp;
82794:     *bp = false;
    1: 
33785:     JSObject *obj2;
    1:     XPCWrappedNative *wrapper =
33785:         XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj, nsnull, &obj2);
80389:     if (obj2) {
33785:         *bp = !JSVAL_IS_PRIMITIVE(v) && (JSVAL_TO_OBJECT(v) == obj2);
33785: 
82794:         return true;
33785:     }
33785: 
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
80389:     if (si && si->GetFlags().WantEquality()) {
79445:         bool res;
74834:         nsresult rv = si->GetCallback()->Equality(wrapper, cx, obj, v, &res);
    1:         if (NS_FAILED(rv))
    1:             return Throw(rv, cx);
74834:         *bp = res;
80390:     } else if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         JSObject *other = JSVAL_TO_OBJECT(v);
    1: 
    1:         *bp = (obj == other ||
    1:                XPC_GetIdentityObject(cx, obj) ==
    1:                XPC_GetIdentityObject(cx, other));
    1:     }
    1: 
82794:     return true;
    1: }
    1: 
18907: static JSObject *
    1: XPC_WN_OuterObject(JSContext *cx, JSObject *obj)
    1: {
    1:     XPCWrappedNative *wrapper =
79734:         static_cast<XPCWrappedNative *>(js::GetObjectPrivate(obj));
80389:     if (!wrapper) {
    1:         Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
    1: 
    1:         return nsnull;
    1:     }
    1: 
80389:     if (!wrapper->IsValid()) {
    1:         Throw(NS_ERROR_XPC_HAS_BEEN_SHUTDOWN, cx);
    1: 
    1:         return nsnull;
    1:     }
    1: 
    1:     XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
80389:     if (si && si->GetFlags().WantOuterObject()) {
    1:         JSObject *newThis;
    1:         nsresult rv =
    1:             si->GetCallback()->OuterObject(wrapper, cx, obj, &newThis);
    1: 
80389:         if (NS_FAILED(rv)) {
    1:             Throw(rv, cx);
    1: 
    1:             return nsnull;
    1:         }
    1: 
    1:         obj = newThis;
    1:     }
    1: 
    1:     return obj;
    1: }
    1: 
90308: XPCWrappedNativeJSClass XPC_WN_NoHelper_JSClass = {
90308:   { // base
    1:     "XPCWrappedNative_NoHelper",    // name;
30001:     WRAPPER_SLOTS |
64218:     JSCLASS_PRIVATE_IS_NSISUPPORTS, // flags
    1: 
    1:     /* Mandatory non-null function pointer members. */
78614:     XPC_WN_OnlyIWrite_AddPropertyStub, // addProperty
78614:     XPC_WN_CannotModifyPropertyStub,   // delProperty
78614:     JS_PropertyStub,                   // getProperty
78614:     XPC_WN_OnlyIWrite_SetPropertyStub, // setProperty
    1: 
48622:     XPC_WN_Shared_Enumerate,           // enumerate
48622:     XPC_WN_NoHelper_Resolve,           // resolve
78614:     XPC_WN_Shared_Convert,             // convert
48622:     XPC_WN_NoHelper_Finalize,          // finalize
    1: 
    1:     /* Optionally non-null members start here. */
48622:     nsnull,                         // checkAccess
48622:     nsnull,                         // call
48622:     nsnull,                         // construct
48622:     nsnull,                         // hasInstance
86631:     XPC_WN_NoHelper_Trace,          // trace
48622: 
48622:     // ClassExtension
48622:     {
78614:         XPC_WN_Equality,
56818:         nsnull, // outerObject
56818:         nsnull, // innerObject
48622:         nsnull, // iteratorObject
74261:         nsnull, // unused
74261:         true,   // isWrappedNative
48622:     },
48622: 
48622:     // ObjectOps
48622:     {
78672:         nsnull, // lookupGeneric
48622:         nsnull, // lookupProperty
77980:         nsnull, // lookupElement
78672:         nsnull, // lookupSpecial
78672:         nsnull, // defineGeneric
48622:         nsnull, // defineProperty
77980:         nsnull, // defineElement
78672:         nsnull, // defineSpecial
78672:         nsnull, // getGeneric
48622:         nsnull, // getProperty
77980:         nsnull, // getElement
81417:         nsnull, // getElementIfPresent
78672:         nsnull, // getSpecial
78672:         nsnull, // setGeneric
48622:         nsnull, // setProperty
77980:         nsnull, // setElement
78672:         nsnull, // setSpecial
78672:         nsnull, // getGenericAttributes
48622:         nsnull, // getAttributes
77980:         nsnull, // getElementAttributes
78672:         nsnull, // getSpecialAttributes
78672:         nsnull, // setGenericAttributes
48622:         nsnull, // setAttributes
77980:         nsnull, // setElementAttributes
78672:         nsnull, // setSpecialAttributes
48622:         nsnull, // deleteProperty
77980:         nsnull, // deleteElement
78672:         nsnull, // deleteSpecial
78614:         XPC_WN_JSOp_Enumerate,
48622:         XPC_WN_JSOp_TypeOf_Object,
48622:         XPC_WN_JSOp_ThisObject,
48622:         XPC_WN_JSOp_Clear
48622:     }
90308:   },
90308:   0 // interfacesBitmap
    1: };
    1: 
    1: 
    1: /***************************************************************************/
    1: 
18907: static JSBool
48470: XPC_WN_MaybeResolvingPropertyStub(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
30001:     MORPH_SLIM_WRAPPER(cx, obj);
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     if (ccx.GetResolvingWrapper() == wrapper)
82794:         return true;
    1:     return Throw(NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN, cx);
    1: }
    1: 
62397: static JSBool
62397: XPC_WN_MaybeResolvingStrictPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict,
62397:                                         jsval *vp)
62397: {
62397:     return XPC_WN_MaybeResolvingPropertyStub(cx, obj, id, vp);
62397: }
62397: 
    1: // macro fun!
30001: #define PRE_HELPER_STUB_NO_SLIM                                               \
    1:     XPCWrappedNative* wrapper =                                               \
30001:         XPCWrappedNative::GetAndMorphWrappedNativeOfJSObject(cx, obj);        \
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);                             \
82794:     bool retval = true;                                                       \
    1:     nsresult rv = wrapper->GetScriptableCallback()->
    1: 
30001: #define PRE_HELPER_STUB                                                       \
30001:     XPCWrappedNative* wrapper;                                                \
30001:     nsIXPCScriptable* si;                                                     \
80389:     if (IS_SLIM_WRAPPER(obj)) {                                               \
30001:         wrapper = nsnull;                                                     \
30001:         si = GetSlimWrapperProto(obj)->GetScriptableInfo()->GetCallback();    \
30001:     }                                                                         \
30001:     else                                                                      \
30001:     {                                                                         \
30001:         wrapper = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);      \
30001:         THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);                         \
30001:         si = wrapper->GetScriptableCallback();                                \
30001:     }                                                                         \
82794:     bool retval = true;                                                       \
30001:     nsresult rv = si->
30001: 
    1: #define POST_HELPER_STUB                                                      \
    1:     if (NS_FAILED(rv))                                                        \
    1:         return Throw(rv, cx);                                                 \
    1:     return retval;
    1: 
18907: static JSBool
48470: XPC_WN_Helper_AddProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     PRE_HELPER_STUB
48470:     AddProperty(wrapper, cx, obj, id, vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
48470: XPC_WN_Helper_DelProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     PRE_HELPER_STUB
48470:     DelProperty(wrapper, cx, obj, id, vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
48470: XPC_WN_Helper_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     PRE_HELPER_STUB
48470:     GetProperty(wrapper, cx, obj, id, vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
62397: XPC_WN_Helper_SetProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
    1: {
    1:     PRE_HELPER_STUB
48470:     SetProperty(wrapper, cx, obj, id, vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
    1: XPC_WN_Helper_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
    1: {
30001:     SLIM_LOG_WILL_MORPH(cx, obj);
30001:     PRE_HELPER_STUB_NO_SLIM
    1:     Convert(wrapper, cx, obj, type, vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
48470: XPC_WN_Helper_CheckAccess(JSContext *cx, JSObject *obj, jsid id,
    1:                           JSAccessMode mode, jsval *vp)
    1: {
    1:     PRE_HELPER_STUB
48470:     CheckAccess(wrapper, cx, obj, id, mode, vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
91237: XPC_WN_Helper_Call(JSContext *cx, unsigned argc, jsval *vp)
    1: {
53557:     // N.B. we want obj to be the callee, not JS_THIS(cx, vp)
53557:     JSObject *obj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
    1: 
53557:     XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, JSID_VOID,
53557:                        argc, JS_ARGV(cx, vp), vp);
53556:     if (!ccx.IsValid())
82794:         return false;
53556: 
53556:     JS_ASSERT(obj == ccx.GetFlattenedJSObject());
53556: 
30001:     SLIM_LOG_WILL_MORPH(cx, obj);
30001:     PRE_HELPER_STUB_NO_SLIM
53557:     Call(wrapper, cx, obj, argc, JS_ARGV(cx, vp), vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
91237: XPC_WN_Helper_Construct(JSContext *cx, unsigned argc, jsval *vp)
    1: {
53557:     JSObject *obj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
53557:     if (!obj)
82794:         return false;
    1: 
53557:     XPCCallContext ccx(JS_CALLER, cx, obj, nsnull, JSID_VOID,
53557:                        argc, JS_ARGV(cx, vp), vp);
53556:     if (!ccx.IsValid())
82794:         return false;
53556: 
53556:     JS_ASSERT(obj == ccx.GetFlattenedJSObject());
53556: 
30001:     SLIM_LOG_WILL_MORPH(cx, obj);
30001:     PRE_HELPER_STUB_NO_SLIM
53557:     Construct(wrapper, cx, obj, argc, JS_ARGV(cx, vp), vp, &retval);
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static JSBool
48470: XPC_WN_Helper_HasInstance(JSContext *cx, JSObject *obj, const jsval *valp, JSBool *bp)
    1: {
30001:     SLIM_LOG_WILL_MORPH(cx, obj);
79445:     bool retval2;
30001:     PRE_HELPER_STUB_NO_SLIM
74834:     HasInstance(wrapper, cx, obj, *valp, &retval2, &retval);
74834:     *bp = retval2;
    1:     POST_HELPER_STUB
    1: }
    1: 
18907: static void
94738: XPC_WN_Helper_Finalize(js::FreeOp *fop, JSObject *obj)
    1: {
94512:     js::Class* clazz = js::GetObjectClass(obj);
94512:     if (clazz->flags & JSCLASS_DOM_GLOBAL) {
97422:         mozilla::dom::DestroyProtoOrIfaceCache(obj);
94512:     }
33785:     nsISupports* p = static_cast<nsISupports*>(xpc_GetJSPrivate(obj));
80389:     if (IS_SLIM_WRAPPER(obj)) {
33785:         SLIM_LOG(("----- %i finalized slim wrapper (%p, %p)\n",
33785:                   ++sFinalizedSlimWrappers, obj, p));
33785: 
33785:         nsWrapperCache* cache;
33785:         CallQueryInterface(p, &cache);
33785:         cache->ClearWrapper();
33785:         NS_RELEASE(p);
33785:         return;
33785:     }
33785: 
33785:     XPCWrappedNative* wrapper = (XPCWrappedNative*)p;
    1:     if (!wrapper)
    1:         return;
94738: 
94738:     wrapper->GetScriptableCallback()->Finalize(wrapper, js::CastToJSFreeOp(fop), obj);
89826:     wrapper->FlatJSObjectFinalized();
    1: }
    1: 
18907: static JSBool
91237: XPC_WN_Helper_NewResolve(JSContext *cx, JSObject *obj, jsid id, unsigned flags,
    1:                          JSObject **objp)
    1: {
30001:     nsresult rv = NS_OK;
82794:     bool retval = true;
30001:     JSObject* obj2FromScriptable = nsnull;
80389:     if (IS_SLIM_WRAPPER(obj)) {
30001:         XPCNativeScriptableInfo *si =
30001:             GetSlimWrapperProto(obj)->GetScriptableInfo();
30001:         if (!si->GetFlags().WantNewResolve())
30001:             return retval;
30001: 
31395:         NS_ASSERTION(si->GetFlags().AllowPropModsToPrototype() &&
31395:                      !si->GetFlags().AllowPropModsDuringResolve(),
31395:                      "We don't support these flags for slim wrappers!");
31395: 
48470:         rv = si->GetCallback()->NewResolve(nsnull, cx, obj, id, flags,
30001:                                            &obj2FromScriptable, &retval);
30001:         if (NS_FAILED(rv))
30001:             return Throw(rv, cx);
30001: 
30001:         if (obj2FromScriptable)
30001:             *objp = obj2FromScriptable;
30001: 
30001:         return retval;
30001:     }
30001: 
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
48470:     jsid old = ccx.SetResolveName(id);
    1: 
    1:     XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
80389:     if (si && si->GetFlags().WantNewResolve()) {
    1:         XPCWrappedNative* oldResolvingWrapper;
    1:         JSBool allowPropMods = si->GetFlags().AllowPropModsDuringResolve();
    1: 
    1:         if (allowPropMods)
    1:             oldResolvingWrapper = ccx.SetResolvingWrapper(wrapper);
    1: 
48470:         rv = si->GetCallback()->NewResolve(wrapper, cx, obj, id, flags,
    1:                                            &obj2FromScriptable, &retval);
    1: 
    1:         if (allowPropMods)
    1:             (void)ccx.SetResolvingWrapper(oldResolvingWrapper);
    1:     }
    1: 
    1:     old = ccx.SetResolveName(old);
48470:     NS_ASSERTION(old == id, "bad nest");
    1: 
80389:     if (NS_FAILED(rv)) {
    1:         return Throw(rv, cx);
    1:     }
    1: 
80389:     if (obj2FromScriptable) {
    1:         *objp = obj2FromScriptable;
80390:     } else if (wrapper->HasMutatedSet()) {
    1:         // We are here if scriptable did not resolve this property and
    1:         // it *might* be in the instance set but not the proto set.
    1: 
    1:         XPCNativeSet* set = wrapper->GetSet();
    1:         XPCNativeSet* protoSet = wrapper->HasProto() ?
    1:                                     wrapper->GetProto()->GetSet() : nsnull;
    1:         XPCNativeMember* member;
    1:         XPCNativeInterface* iface;
    1:         JSBool IsLocal;
    1: 
48470:         if (set->FindMember(id, &member, &iface, protoSet, &IsLocal) &&
80389:             IsLocal) {
    1:             XPCWrappedNative* oldResolvingWrapper;
    1: 
    1:             XPCNativeScriptableFlags siFlags(0);
    1:             if (si)
    1:                 siFlags = si->GetFlags();
    1: 
91237:             unsigned enumFlag =
    1:                 siFlags.DontEnumStaticProps() ? 0 : JSPROP_ENUMERATE;
    1: 
    1:             XPCWrappedNative* wrapperForInterfaceNames =
    1:                 siFlags.DontReflectInterfaceNames() ? nsnull : wrapper;
    1: 
    1:             JSBool resolved;
    1:             oldResolvingWrapper = ccx.SetResolvingWrapper(wrapper);
48470:             retval = DefinePropertyIfFound(ccx, obj, id,
    1:                                            set, iface, member,
    1:                                            wrapper->GetScope(),
82794:                                            false,
    1:                                            wrapperForInterfaceNames,
    1:                                            nsnull, si,
    1:                                            enumFlag, &resolved);
    1:             (void)ccx.SetResolvingWrapper(oldResolvingWrapper);
    1:             if (retval && resolved)
    1:                 *objp = obj;
    1:         }
    1:     }
    1: 
    1:     return retval;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: /*
    1:     Here are the enumerator cases:
    1: 
    1:     set jsclass enumerate to stub (unless noted otherwise)
    1: 
    1:     if ( helper wants new enumerate )
    1:         if ( DONT_ENUM_STATICS )
    1:             forward to scriptable enumerate
    1:         else
    1:             if ( set not mutated )
    1:                 forward to scriptable enumerate
    1:             else
    1:                 call shared enumerate
    1:                 forward to scriptable enumerate
    1:     else if ( helper wants old enumerate )
    1:         use this JSOp
    1:         if ( DONT_ENUM_STATICS )
    1:             call scriptable enumerate
    1:             call stub
    1:         else
    1:             if ( set not mutated )
    1:                 call scriptable enumerate
    1:                 call stub
    1:             else
    1:                 call shared enumerate
    1:                 call scriptable enumerate
    1:                 call stub
    1: 
    1:     else //... if ( helper wants NO enumerate )
    1:         if ( DONT_ENUM_STATICS )
    1:             use enumerate stub - don't use this JSOp thing at all
    1:         else
    1:             do shared enumerate - don't use this JSOp thing at all
    1: */
    1: 
48622: JSBool
    1: XPC_WN_JSOp_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:                       jsval *statep, jsid *idp)
    1: {
79734:     js::Class *clazz = js::GetObjectClass(obj);
90308:     if (!IS_WRAPPER_CLASS(clazz) || clazz == &XPC_WN_NoHelper_JSClass.base) {
10478:         // obj must be a prototype object or a wrapper w/o a
48622:         // helper. Short circuit this call to the default
48622:         // implementation.
 9030: 
79734:         return JS_EnumerateState(cx, obj, enum_op, statep, idp);
 9030:     }
 9030: 
33785:     MORPH_SLIM_WRAPPER(cx, obj);
33785: 
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
    1:     if (!si)
    1:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
    1: 
82794:     bool retval = true;
    1:     nsresult rv;
    1: 
80389:     if (si->GetFlags().WantNewEnumerate()) {
47569:         if (((enum_op == JSENUMERATE_INIT &&
47569:               !si->GetFlags().DontEnumStaticProps()) ||
47569:              enum_op == JSENUMERATE_INIT_ALL) &&
    1:             wrapper->HasMutatedSet() &&
80389:             !XPC_WN_Shared_Enumerate(cx, obj)) {
    1:             *statep = JSVAL_NULL;
82794:             return false;
    1:         }
    1: 
    1:         // XXX Might we really need to wrap this call and *also* call
    1:         // js_ObjectOps.enumerate ???
    1: 
    1:         rv = si->GetCallback()->
    1:             NewEnumerate(wrapper, cx, obj, enum_op, statep, idp, &retval);
    1: 
47569:         if ((enum_op == JSENUMERATE_INIT || enum_op == JSENUMERATE_INIT_ALL) &&
80389:             (NS_FAILED(rv) || !retval)) {
    1:             *statep = JSVAL_NULL;
47569:         }
    1: 
    1:         if (NS_FAILED(rv))
    1:             return Throw(rv, cx);
    1:         return retval;
    1:     }
    1: 
80389:     if (si->GetFlags().WantEnumerate()) {
80389:         if (enum_op == JSENUMERATE_INIT || enum_op == JSENUMERATE_INIT_ALL) {
47569:             if ((enum_op == JSENUMERATE_INIT_ALL ||
47569:                  !si->GetFlags().DontEnumStaticProps()) &&
    1:                 wrapper->HasMutatedSet() &&
80389:                 !XPC_WN_Shared_Enumerate(cx, obj)) {
    1:                 *statep = JSVAL_NULL;
82794:                 return false;
    1:             }
    1:             rv = si->GetCallback()->
    1:                 Enumerate(wrapper, cx, obj, &retval);
    1: 
    1:             if (NS_FAILED(rv) || !retval)
    1:                 *statep = JSVAL_NULL;
    1: 
    1:             if (NS_FAILED(rv))
    1:                 return Throw(rv, cx);
    1:             if (!retval)
82794:                 return false;
48622:             // Then fall through and call the default implementation...
    1:         }
    1:     }
    1: 
    1:     // else call js_ObjectOps.enumerate...
    1: 
79734:     return JS_EnumerateState(cx, obj, enum_op, statep, idp);
    1: }
    1: 
48622: JSType
38633: XPC_WN_JSOp_TypeOf_Object(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
48622: JSType
38633: XPC_WN_JSOp_TypeOf_Function(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_FUNCTION;
38633: }
38633: 
48622: void
    1: XPC_WN_JSOp_Clear(JSContext *cx, JSObject *obj)
    1: {
55659:     // XXX Clear XrayWrappers?
    1: }
    1: 
25050: namespace {
25050: 
25050: NS_STACK_CLASS class AutoPopJSContext
25050: {
25050: public:
25050:   AutoPopJSContext(XPCJSContextStack *stack)
25050:   : mCx(nsnull), mStack(stack)
25050:   {
25050:       NS_ASSERTION(stack, "Null stack!");
25050:   }
25050: 
25050:   ~AutoPopJSContext()
25050:   {
25050:       if (mCx)
86979:           mStack->Pop();
25050:   }
25050: 
25050:   void PushIfNotTop(JSContext *cx)
25050:   {
25050:       NS_ASSERTION(cx, "Null context!");
25050:       NS_ASSERTION(!mCx, "This class is only meant to be used once!");
25050: 
86979:       JSContext *cxTop = mStack->Peek();
25050: 
86979:       if (cxTop != cx && mStack->Push(cx))
25050:           mCx = cx;
25050:   }
25050: 
25050: private:
25050:   JSContext *mCx;
25050:   XPCJSContextStack *mStack;
25050: };
25050: 
25050: } // namespace
25050: 
48622: JSObject*
25050: XPC_WN_JSOp_ThisObject(JSContext *cx, JSObject *obj)
25050: {
25050:     // None of the wrappers we could potentially hand out are threadsafe so
25050:     // just hand out the given object.
25050:     if (!XPCPerThreadData::IsMainThread(cx))
25050:         return obj;
25050: 
79734:     return JS_ObjectToOuterObject(cx, obj);
25050: }
25050: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: XPCNativeScriptableInfo*
    1: XPCNativeScriptableInfo::Construct(XPCCallContext& ccx,
    1:                                    const XPCNativeScriptableCreateInfo* sci)
    1: {
 2137:     NS_ASSERTION(sci, "bad param");
    1:     NS_ASSERTION(sci->GetCallback(), "bad param");
    1: 
    1:     XPCNativeScriptableInfo* newObj =
    1:         new XPCNativeScriptableInfo(sci->GetCallback());
    1:     if (!newObj)
    1:         return nsnull;
    1: 
    1:     char* name = nsnull;
80389:     if (NS_FAILED(sci->GetCallback()->GetClassName(&name)) || !name) {
    1:         delete newObj;
    1:         return nsnull;
    1:     }
    1: 
    1:     JSBool success;
    1: 
    1:     XPCJSRuntime* rt = ccx.GetRuntime();
    1:     XPCNativeScriptableSharedMap* map = rt->GetNativeScriptableSharedMap();
    1:     {   // scoped lock
    1:         XPCAutoLock lock(rt->GetMapLock());
91578:         success = map->GetNewOrUsed(sci->GetFlags(), name,
40491:                                     sci->GetInterfacesBitmap(), newObj);
    1:     }
    1: 
80389:     if (!success) {
    1:         delete newObj;
    1:         return nsnull;
    1:     }
    1: 
    1:     return newObj;
    1: }
    1: 
    1: void
91578: XPCNativeScriptableShared::PopulateJSClass()
    1: {
    1:     NS_ASSERTION(mJSClass.base.name, "bad state!");
    1: 
30001:     mJSClass.base.flags = WRAPPER_SLOTS |
    1:                           JSCLASS_PRIVATE_IS_NSISUPPORTS |
64218:                           JSCLASS_NEW_RESOLVE;
    1: 
91578:     if (mFlags.IsGlobalObject())
80070:         mJSClass.base.flags |= XPCONNECT_GLOBAL_FLAGS;
    1: 
48622:     JSPropertyOp addProperty;
    1:     if (mFlags.WantAddProperty())
48622:         addProperty = XPC_WN_Helper_AddProperty;
    1:     else if (mFlags.UseJSStubForAddProperty())
48622:         addProperty = JS_PropertyStub;
    1:     else if (mFlags.AllowPropModsDuringResolve())
48622:         addProperty = XPC_WN_MaybeResolvingPropertyStub;
    1:     else
48622:         addProperty = XPC_WN_CannotModifyPropertyStub;
78614:     mJSClass.base.addProperty = addProperty;
    1: 
48622:     JSPropertyOp delProperty;
    1:     if (mFlags.WantDelProperty())
48622:         delProperty = XPC_WN_Helper_DelProperty;
    1:     else if (mFlags.UseJSStubForDelProperty())
48622:         delProperty = JS_PropertyStub;
    1:     else if (mFlags.AllowPropModsDuringResolve())
48622:         delProperty = XPC_WN_MaybeResolvingPropertyStub;
    1:     else
48622:         delProperty = XPC_WN_CannotModifyPropertyStub;
78614:     mJSClass.base.delProperty = delProperty;
    1: 
    1:     if (mFlags.WantGetProperty())
78614:         mJSClass.base.getProperty = XPC_WN_Helper_GetProperty;
    1:     else
78614:         mJSClass.base.getProperty = JS_PropertyStub;
    1: 
62397:     JSStrictPropertyOp setProperty;
    1:     if (mFlags.WantSetProperty())
48622:         setProperty = XPC_WN_Helper_SetProperty;
    1:     else if (mFlags.UseJSStubForSetProperty())
62397:         setProperty = JS_StrictPropertyStub;
    1:     else if (mFlags.AllowPropModsDuringResolve())
62397:         setProperty = XPC_WN_MaybeResolvingStrictPropertyStub;
    1:     else
62397:         setProperty = XPC_WN_CannotModifyStrictPropertyStub;
78614:     mJSClass.base.setProperty = setProperty;
    1: 
    1:     // We figure out most of the enumerate strategy at call time.
    1: 
    1:     if (mFlags.WantNewEnumerate() || mFlags.WantEnumerate() ||
    1:         mFlags.DontEnumStaticProps())
78614:         mJSClass.base.enumerate = JS_EnumerateStub;
    1:     else
    1:         mJSClass.base.enumerate = XPC_WN_Shared_Enumerate;
    1: 
    1:     // We have to figure out resolve strategy at call time
    1:     mJSClass.base.resolve = (JSResolveOp) XPC_WN_Helper_NewResolve;
    1: 
    1:     if (mFlags.WantConvert())
78614:         mJSClass.base.convert = XPC_WN_Helper_Convert;
    1:     else
78614:         mJSClass.base.convert = XPC_WN_Shared_Convert;
    1: 
    1:     if (mFlags.WantFinalize())
    1:         mJSClass.base.finalize = XPC_WN_Helper_Finalize;
    1:     else
    1:         mJSClass.base.finalize = XPC_WN_NoHelper_Finalize;
    1: 
    1:     // We let the rest default to nsnull unless the helper wants them...
    1:     if (mFlags.WantCheckAccess())
78614:         mJSClass.base.checkAccess = XPC_WN_Helper_CheckAccess;
    1: 
48622:     // Note that we *must* set the ObjectOps (even for the cases were it does
48622:     // not do much) because with these dynamically generated JSClasses, the
48622:     // code in XPCWrappedNative::GetWrappedNativeOfJSObject() needs to look
48622:     // for that these callback pointers in order to identify that a given
    1:     // JSObject represents a wrapper.
48622:     js::ObjectOps *ops = &mJSClass.base.ops;
78614:     ops->enumerate = XPC_WN_JSOp_Enumerate;
48622:     ops->clear = XPC_WN_JSOp_Clear;
48622:     ops->thisObject = XPC_WN_JSOp_ThisObject;
    1: 
80389:     if (mFlags.WantCall() || mFlags.WantConstruct()) {
48622:         ops->typeOf = XPC_WN_JSOp_TypeOf_Function;
    1:         if (mFlags.WantCall())
78614:             mJSClass.base.call = XPC_WN_Helper_Call;
    1:         if (mFlags.WantConstruct())
78614:             mJSClass.base.construct = XPC_WN_Helper_Construct;
80390:     } else {
48622:         ops->typeOf = XPC_WN_JSOp_TypeOf_Object;
    1:     }
    1: 
80389:     if (mFlags.UseStubEqualityHook()) {
77985:         NS_ASSERTION(!mFlags.WantEquality(),
77985:                      "If you want an Equality callback, you can't use a stub "
77985:                      "equality hook");
77985:         mJSClass.base.ext.equality = nsnull;
80390:     } else {
78614:         mJSClass.base.ext.equality = XPC_WN_Equality;
77985:     }
48622: 
    1:     if (mFlags.WantHasInstance())
78614:         mJSClass.base.hasInstance = XPC_WN_Helper_HasInstance;
    1: 
86631:     mJSClass.base.trace = XPC_WN_NoHelper_Trace;
    1: 
19279:     if (mFlags.WantOuterObject())
48622:         mJSClass.base.ext.outerObject = XPC_WN_OuterObject;
30001: 
56818:     if (!(mFlags & nsIXPCScriptable::WANT_OUTER_OBJECT))
82794:         mCanBeSlim = true;
74261: 
74261:     mJSClass.base.ext.isWrappedNative = true;
    1: }
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: 
18907: JSBool
91237: XPC_WN_CallMethod(JSContext *cx, unsigned argc, jsval *vp)
    1: {
53557:     NS_ASSERTION(JS_TypeOfValue(cx, JS_CALLEE(cx, vp)) == JSTYPE_FUNCTION, "bad function");
53557:     JSObject* funobj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
53557: 
53557:     JSObject* obj = JS_THIS_OBJECT(cx, vp);
53557:     if (!obj)
82794:         return false;
30001: 
30001: #ifdef DEBUG_slimwrappers
57814:     {
76812:         JSFunction* fun = funobj->getFunctionPrivate();
57814:         JSString *funid = JS_GetFunctionId(fun);
57814:         JSAutoByteString bytes;
57814:         const char *funname = !funid ? "" : bytes.encode(cx, funid) ? bytes.ptr() : "<error>";
30001:         SLIM_LOG_WILL_MORPH_FOR_PROP(cx, obj, funname);
57814:     }
30001: #endif
30001:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
30001:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
30001: 
53557:     XPCCallContext ccx(JS_CALLER, cx, obj, funobj, JSID_VOID, argc, JS_ARGV(cx, vp), vp);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCNativeInterface* iface;
    1:     XPCNativeMember*    member;
    1: 
    1:     if (!XPCNativeMember::GetCallInfo(ccx, funobj, &iface, &member))
    1:         return Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, cx);
82794:     ccx.SetCallInfo(iface, member, false);
    1:     return XPCWrappedNative::CallMethod(ccx);
    1: }
    1: 
18907: JSBool
91237: XPC_WN_GetterSetter(JSContext *cx, unsigned argc, jsval *vp)
    1: {
53557:     NS_ASSERTION(JS_TypeOfValue(cx, JS_CALLEE(cx, vp)) == JSTYPE_FUNCTION, "bad function");
53557:     JSObject* funobj = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));
53557: 
53557:     JSObject* obj = JS_THIS_OBJECT(cx, vp);
53557:     if (!obj)
82794:         return false;
    1: 
30001: #ifdef DEBUG_slimwrappers
57814:     {
30001:         const char* funname = nsnull;
57814:         JSAutoByteString bytes;
80389:         if (JS_TypeOfValue(cx, JS_CALLEE(cx, vp)) == JSTYPE_FUNCTION) {
76812:             JSString *funid = JS_GetFunctionId(funobj->getFunctionPrivate());
57814:             funname = !funid ? "" : bytes.encode(cx, funid) ? bytes.ptr() : "<error>";
30001:         }
30001:         SLIM_LOG_WILL_MORPH_FOR_PROP(cx, obj, funname);
57814:     }
30001: #endif
30001:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
30001:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
30001: 
    1:     XPCCallContext ccx(JS_CALLER, cx, obj, funobj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCNativeInterface* iface;
    1:     XPCNativeMember*    member;
    1: 
    1:     if (!XPCNativeMember::GetCallInfo(ccx, funobj, &iface, &member))
    1:         return Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, cx);
    1: 
53557:     ccx.SetArgsAndResultPtr(argc, JS_ARGV(cx, vp), vp);
80389:     if (argc && member->IsWritableAttribute()) {
82794:         ccx.SetCallInfo(iface, member, true);
    1:         JSBool retval = XPCWrappedNative::SetAttribute(ccx);
53557:         if (retval)
53557:             *vp = JS_ARGV(cx, vp)[0];
    1:         return retval;
    1:     }
    1:     // else...
    1: 
82794:     ccx.SetCallInfo(iface, member, false);
    1:     return XPCWrappedNative::GetAttribute(ccx);
    1: }
    1: 
    1: /***************************************************************************/
    1: 
18907: static JSBool
    1: XPC_WN_Shared_Proto_Enumerate(JSContext *cx, JSObject *obj)
    1: {
80387:     NS_ASSERTION(js::GetObjectClass(obj) == &XPC_WN_ModsAllowed_WithCall_Proto_JSClass ||
79734:                  js::GetObjectClass(obj) == &XPC_WN_ModsAllowed_NoCall_Proto_JSClass ||
79734:                  js::GetObjectClass(obj) == &XPC_WN_NoMods_WithCall_Proto_JSClass ||
79734:                  js::GetObjectClass(obj) == &XPC_WN_NoMods_NoCall_Proto_JSClass,
    1:                  "bad proto");
10858:     XPCWrappedNativeProto* self =
10858:         (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:     if (!self)
82794:         return false;
    1: 
    1:     if (self->GetScriptableInfo() &&
    1:         self->GetScriptableInfo()->GetFlags().DontEnumStaticProps())
82794:         return true;
    1: 
    1:     XPCNativeSet* set = self->GetSet();
    1:     if (!set)
82794:         return false;
    1: 
    1:     XPCCallContext ccx(JS_CALLER, cx);
    1:     if (!ccx.IsValid())
82794:         return false;
62405:     ccx.SetScopeForNewJSObjects(obj);
    1: 
    1:     PRUint16 interface_count = set->GetInterfaceCount();
    1:     XPCNativeInterface** interfaceArray = set->GetInterfaceArray();
80389:     for (PRUint16 i = 0; i < interface_count; i++) {
    1:         XPCNativeInterface* iface = interfaceArray[i];
    1:         PRUint16 member_count = iface->GetMemberCount();
    1: 
80389:         for (PRUint16 k = 0; k < member_count; k++) {
    1:             if (!xpc_ForcePropertyResolve(cx, obj, iface->GetMemberAt(k)->GetName()))
82794:                 return false;
    1:         }
    1:     }
    1: 
82794:     return true;
    1: }
    1: 
18907: static void
94738: XPC_WN_Shared_Proto_Finalize(js::FreeOp *fop, JSObject *obj)
    1: {
    1:     // This can be null if xpc shutdown has already happened
10858:     XPCWrappedNativeProto* p = (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:     if (p)
94738:         p->JSProtoObjectFinalized(fop, obj);
    1: }
    1: 
18907: static void
 1025: XPC_WN_Shared_Proto_Trace(JSTracer *trc, JSObject *obj)
    1: {
    1:     // This can be null if xpc shutdown has already happened
 1025:     XPCWrappedNativeProto* p =
10858:         (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:     if (p)
 1025:         TraceScopeJSObjects(trc, p->GetScope());
    1: }
    1: 
    1: /*****************************************************/
    1: 
18907: static JSBool
48470: XPC_WN_ModsAllowed_Proto_Resolve(JSContext *cx, JSObject *obj, jsid id)
    1: {
80387:     NS_ASSERTION(js::GetObjectClass(obj) == &XPC_WN_ModsAllowed_WithCall_Proto_JSClass ||
79734:                  js::GetObjectClass(obj) == &XPC_WN_ModsAllowed_NoCall_Proto_JSClass,
    1:                  "bad proto");
    1: 
10858:     XPCWrappedNativeProto* self =
10858:         (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:     if (!self)
82794:         return false;
    1: 
    1:     XPCCallContext ccx(JS_CALLER, cx);
    1:     if (!ccx.IsValid())
82794:         return false;
62405:     ccx.SetScopeForNewJSObjects(obj);
    1: 
    1:     XPCNativeScriptableInfo* si = self->GetScriptableInfo();
91237:     unsigned enumFlag = (si && si->GetFlags().DontEnumStaticProps()) ?
    1:                                                 0 : JSPROP_ENUMERATE;
    1: 
48470:     return DefinePropertyIfFound(ccx, obj, id,
    1:                                  self->GetSet(), nsnull, nsnull,
    1:                                  self->GetScope(),
82794:                                  true, nsnull, nsnull, si,
    1:                                  enumFlag, nsnull);
    1: }
    1: 
48622: js::Class XPC_WN_ModsAllowed_WithCall_Proto_JSClass = {
 9030:     "XPC_WN_ModsAllowed_WithCall_Proto_JSClass", // name;
64218:     WRAPPER_SLOTS, // flags;
    1: 
    1:     /* Mandatory non-null function pointer members. */
78614:     JS_PropertyStub,                // addProperty;
78614:     JS_PropertyStub,                // delProperty;
78614:     JS_PropertyStub,                // getProperty;
78614:     JS_StrictPropertyStub,          // setProperty;
    1:     XPC_WN_Shared_Proto_Enumerate,  // enumerate;
    1:     XPC_WN_ModsAllowed_Proto_Resolve, // resolve;
78614:     JS_ConvertStub,                 // convert;
    1:     XPC_WN_Shared_Proto_Finalize,   // finalize;
    1: 
    1:     /* Optionally non-null members start here. */
 9030:     nsnull,                         // checkAccess;
 9030:     nsnull,                         // call;
 9030:     nsnull,                         // construct;
 9030:     nsnull,                         // hasInstance;
64218:     XPC_WN_Shared_Proto_Trace,      // trace;
48622: 
48622:     JS_NULL_CLASS_EXT,
48622:     XPC_WN_WithCall_ObjectOps
 9030: };
 9030: 
48622: js::Class XPC_WN_ModsAllowed_NoCall_Proto_JSClass = {
 9030:     "XPC_WN_ModsAllowed_NoCall_Proto_JSClass", // name;
64218:     WRAPPER_SLOTS,                  // flags;
 9030: 
 9030:     /* Mandatory non-null function pointer members. */
78614:     JS_PropertyStub,                // addProperty;
78614:     JS_PropertyStub,                // delProperty;
78614:     JS_PropertyStub,                // getProperty;
78614:     JS_StrictPropertyStub,          // setProperty;
 9030:     XPC_WN_Shared_Proto_Enumerate,  // enumerate;
 9030:     XPC_WN_ModsAllowed_Proto_Resolve, // resolve;
78614:     JS_ConvertStub,                 // convert;
 9030:     XPC_WN_Shared_Proto_Finalize,   // finalize;
 9030: 
 9030:     /* Optionally non-null members start here. */
    1:     nsnull,                         // checkAccess;
    1:     nsnull,                         // call;
    1:     nsnull,                         // construct;
    1:     nsnull,                         // hasInstance;
64223:     XPC_WN_Shared_Proto_Trace,      // trace;
48622: 
48622:     JS_NULL_CLASS_EXT,
48622:     XPC_WN_NoCall_ObjectOps
    1: };
    1: 
    1: /***************************************************************************/
    1: 
18907: static JSBool
62397: XPC_WN_OnlyIWrite_Proto_AddPropertyStub(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
79734:     NS_ASSERTION(js::GetObjectClass(obj) == &XPC_WN_NoMods_WithCall_Proto_JSClass ||
79734:                  js::GetObjectClass(obj) == &XPC_WN_NoMods_NoCall_Proto_JSClass,
    1:                  "bad proto");
    1: 
10858:     XPCWrappedNativeProto* self =
10858:         (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:     if (!self)
82794:         return false;
    1: 
    1:     XPCCallContext ccx(JS_CALLER, cx);
    1:     if (!ccx.IsValid())
82794:         return false;
62405:     ccx.SetScopeForNewJSObjects(obj);
    1: 
    1:     // Allow XPConnect to add the property only
48470:     if (ccx.GetResolveName() == id)
82794:         return true;
    1: 
    1:     return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
    1: }
    1: 
18907: static JSBool
62397: XPC_WN_OnlyIWrite_Proto_SetPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict,
62397:                                         jsval *vp)
62397: {
62397:     return XPC_WN_OnlyIWrite_Proto_AddPropertyStub(cx, obj, id, vp);
62397: }
62397: 
62397: static JSBool
48470: XPC_WN_NoMods_Proto_Resolve(JSContext *cx, JSObject *obj, jsid id)
    1: {
79734:     NS_ASSERTION(js::GetObjectClass(obj) == &XPC_WN_NoMods_WithCall_Proto_JSClass ||
79734:                  js::GetObjectClass(obj) == &XPC_WN_NoMods_NoCall_Proto_JSClass,
    1:                  "bad proto");
    1: 
10858:     XPCWrappedNativeProto* self =
10858:         (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:     if (!self)
82794:         return false;
    1: 
    1:     XPCCallContext ccx(JS_CALLER, cx);
    1:     if (!ccx.IsValid())
82794:         return false;
62405:     ccx.SetScopeForNewJSObjects(obj);
    1: 
    1:     XPCNativeScriptableInfo* si = self->GetScriptableInfo();
91237:     unsigned enumFlag = (si && si->GetFlags().DontEnumStaticProps()) ?
    1:                                                 0 : JSPROP_ENUMERATE;
    1: 
48470:     return DefinePropertyIfFound(ccx, obj, id,
    1:                                  self->GetSet(), nsnull, nsnull,
    1:                                  self->GetScope(),
82794:                                  true, nsnull, nsnull, si,
    1:                                  JSPROP_READONLY |
    1:                                  JSPROP_PERMANENT |
    1:                                  enumFlag, nsnull);
    1: }
    1: 
48622: js::Class XPC_WN_NoMods_WithCall_Proto_JSClass = {
 9030:     "XPC_WN_NoMods_WithCall_Proto_JSClass",    // name;
64218:     WRAPPER_SLOTS,                             // flags;
    1: 
    1:     /* Mandatory non-null function pointer members. */
78614:     XPC_WN_OnlyIWrite_Proto_AddPropertyStub,   // addProperty;
78614:      XPC_WN_CannotModifyPropertyStub,          // delProperty;
78614:     JS_PropertyStub,                           // getProperty;
78614:     XPC_WN_OnlyIWrite_Proto_SetPropertyStub,   // setProperty;
    1:     XPC_WN_Shared_Proto_Enumerate,             // enumerate;
    1:     XPC_WN_NoMods_Proto_Resolve,               // resolve;
78614:     JS_ConvertStub,                            // convert;
    1:     XPC_WN_Shared_Proto_Finalize,              // finalize;
    1: 
    1:     /* Optionally non-null members start here. */
 9030:     nsnull,                         // checkAccess;
 9030:     nsnull,                         // call;
 9030:     nsnull,                         // construct;
 9030:     nsnull,                         // hasInstance;
64218:     XPC_WN_Shared_Proto_Trace,      // trace;
48622: 
48622:     JS_NULL_CLASS_EXT,
48622:     XPC_WN_WithCall_ObjectOps
 9030: };
 9030: 
48622: js::Class XPC_WN_NoMods_NoCall_Proto_JSClass = {
 9030:     "XPC_WN_NoMods_NoCall_Proto_JSClass",      // name;
64218:     WRAPPER_SLOTS,                             // flags;
 9030: 
 9030:     /* Mandatory non-null function pointer members. */
78614:     XPC_WN_OnlyIWrite_Proto_AddPropertyStub,   // addProperty;
78614:     XPC_WN_CannotModifyPropertyStub,           // delProperty;
78614:     JS_PropertyStub,                           // getProperty;
78614:     XPC_WN_OnlyIWrite_Proto_SetPropertyStub,   // setProperty;
 9030:     XPC_WN_Shared_Proto_Enumerate,             // enumerate;
 9030:     XPC_WN_NoMods_Proto_Resolve,               // resolve;
78614:     JS_ConvertStub,                            // convert;
 9030:     XPC_WN_Shared_Proto_Finalize,              // finalize;
 9030: 
 9030:     /* Optionally non-null members start here. */
    1:     nsnull,                         // checkAccess;
    1:     nsnull,                         // call;
    1:     nsnull,                         // construct;
    1:     nsnull,                         // hasInstance;
64218:     XPC_WN_Shared_Proto_Trace,      // trace;
48622: 
48622:     JS_NULL_CLASS_EXT,
48622:     XPC_WN_NoCall_ObjectOps
    1: };
    1: 
    1: /***************************************************************************/
    1: 
18907: static JSBool
    1: XPC_WN_TearOff_Enumerate(JSContext *cx, JSObject *obj)
    1: {
30001:     MORPH_SLIM_WRAPPER(cx, obj);
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCWrappedNativeTearOff* to = ccx.GetTearOff();
    1:     XPCNativeInterface* iface;
    1: 
    1:     if (!to || nsnull == (iface = to->GetInterface()))
    1:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
    1: 
    1:     PRUint16 member_count = iface->GetMemberCount();
80389:     for (PRUint16 k = 0; k < member_count; k++) {
    1:         if (!xpc_ForcePropertyResolve(cx, obj, iface->GetMemberAt(k)->GetName()))
82794:             return false;
    1:     }
    1: 
82794:     return true;
    1: }
    1: 
18907: static JSBool
48470: XPC_WN_TearOff_Resolve(JSContext *cx, JSObject *obj, jsid id)
    1: {
30001:     MORPH_SLIM_WRAPPER(cx, obj);
    1:     XPCCallContext ccx(JS_CALLER, cx, obj);
    1:     XPCWrappedNative* wrapper = ccx.GetWrapper();
    1:     THROW_AND_RETURN_IF_BAD_WRAPPER(cx, wrapper);
    1: 
    1:     XPCWrappedNativeTearOff* to = ccx.GetTearOff();
    1:     XPCNativeInterface* iface;
    1: 
    1:     if (!to || nsnull == (iface = to->GetInterface()))
    1:         return Throw(NS_ERROR_XPC_BAD_OP_ON_WN_PROTO, cx);
    1: 
48470:     return DefinePropertyIfFound(ccx, obj, id, nsnull, iface, nsnull,
    1:                                  wrapper->GetScope(),
82794:                                  true, nsnull, nsnull, nsnull,
    1:                                  JSPROP_READONLY |
    1:                                  JSPROP_PERMANENT |
    1:                                  JSPROP_ENUMERATE, nsnull);
    1: }
    1: 
18907: static void
94738: XPC_WN_TearOff_Finalize(js::FreeOp *fop, JSObject *obj)
    1: {
    1:     XPCWrappedNativeTearOff* p = (XPCWrappedNativeTearOff*)
10858:         xpc_GetJSPrivate(obj);
    1:     if (!p)
    1:         return;
    1:     p->JSObjectFinalized();
    1: }
    1: 
48622: js::Class XPC_WN_Tearoff_JSClass = {
    1:     "WrappedNative_TearOff",                   // name;
64218:     WRAPPER_SLOTS,                             // flags;
    1: 
78614:     XPC_WN_OnlyIWrite_AddPropertyStub,         // addProperty;
78614:     XPC_WN_CannotModifyPropertyStub,           // delProperty;
78614:     JS_PropertyStub,                           // getProperty;
78614:     XPC_WN_OnlyIWrite_SetPropertyStub,         // setProperty;
    1:     XPC_WN_TearOff_Enumerate,                  // enumerate;
    1:     XPC_WN_TearOff_Resolve,                    // resolve;
78614:     XPC_WN_Shared_Convert,                     // convert;
48622:     XPC_WN_TearOff_Finalize                    // finalize;
    1: };
