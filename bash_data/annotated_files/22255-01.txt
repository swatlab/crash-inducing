    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Mike Pinkerton (pinkerton@netscape.com).
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *    Vladimir Vukicevic <vladimir@pobox.com> (HITheme rewrite)
    1:  *    Josh Aas <josh@mozilla.com>
  458:  *    Colin Barrett <cbarrett@mozilla.com>
11944:  *    Matthew Gregan <kinetik@flim.org>
20384:  *    Markus Stange <mstange@themasta.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNativeThemeCocoa.h"
11981: #include "nsObjCExceptions.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsRect.h"
    1: #include "nsSize.h"
    1: #include "nsThemeConstants.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIFrame.h"
    1: #include "nsIAtom.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsPresContext.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsWidgetAtoms.h"
 9641: #include "nsToolkit.h"
19295: #include "nsCocoaWindow.h"
20506: #include "nsNativeThemeColors.h"
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxQuartzSurface.h"
11944: #include "gfxQuartzNativeDrawing.h"
    1: 
    1: #define DRAW_IN_FRAME_DEBUG 0
  458: #define SCROLLBARS_VISUAL_DEBUG 0
    1: 
 4356: // private Quartz routines needed here
    1: extern "C" {
    1:   CG_EXTERN void CGContextSetCTM(CGContextRef, CGAffineTransform);
    1: }
    1: 
20384: // Workaround for NSCell control tint drawing
20384: // Without this workaround, NSCells are always drawn with the clear control tint
20384: // as long as they're not attached to an NSControl which is a subview of an active window.
20384: // XXXmstange Why doesn't Webkit need this?
20384: @implementation NSCell (ControlTintWorkaround)
20384: - (int)_realControlTint { return [self controlTint]; }
20384: @end
20384: 
  458: // Copied from nsLookAndFeel.h
  458: // Apple hasn't defined a constant for scollbars with two arrows on each end, so we'll use this one.
  458: static const int kThemeScrollBarArrowsBoth = 2;
  458: 
    1: #define HITHEME_ORIENTATION kHIThemeOrientationNormal
10038: #define MAX_FOCUS_RING_WIDTH 4
10038: 
10038: // These enums are for indexing into the margin array.
10038: enum {
10038:   tigerOS,
10038:   leopardOS
10038: };
10038: 
10038: enum {
10038:   miniControlSize,
10038:   smallControlSize,
10038:   regularControlSize
10038: };
10038: 
10038: enum {
10038:   leftMargin,
10038:   topMargin,
10038:   rightMargin,
10038:   bottomMargin
10038: };
10038: 
10038: static int EnumSizeForCocoaSize(NSControlSize cocoaControlSize) {
10038:   if (cocoaControlSize == NSMiniControlSize)
10038:     return miniControlSize;
10038:   else if (cocoaControlSize == NSSmallControlSize)
10038:     return smallControlSize;
10038:   else
10038:     return regularControlSize;
10038: }
10038: 
10038: static void InflateControlRect(NSRect* rect, NSControlSize cocoaControlSize, const float marginSet[][3][4])
10038: {
20384:   if (!marginSet)
20384:     return;
10038:   static int osIndex = nsToolkit::OnLeopardOrLater() ? leopardOS : tigerOS;
10038:   int controlSize = EnumSizeForCocoaSize(cocoaControlSize);
10038:   const float* buttonMargins = marginSet[osIndex][controlSize];
10038:   rect->origin.x -= buttonMargins[leftMargin];
10038:   rect->origin.y -= buttonMargins[bottomMargin];
10038:   rect->size.width += buttonMargins[leftMargin] + buttonMargins[rightMargin];
10038:   rect->size.height += buttonMargins[bottomMargin] + buttonMargins[topMargin];
10038: }
    1: 
19490: static NSWindow* NativeWindowForFrame(nsIFrame* aFrame, int* aLevelsUp = NULL,
19490:                                       nsIWidget** aTopLevelWidget = NULL)
19295: {
19295:   if (!aFrame)
19295:     return nil;  
19295: 
19295:   nsIWidget* widget = aFrame->GetWindow();
19295:   if (!widget)
19295:     return nil;
19295: 
19295:   nsIWidget* topLevelWidget = widget->GetTopLevelWidget(aLevelsUp);
19490:   if (aTopLevelWidget)
19490:     *aTopLevelWidget = topLevelWidget;
19295: 
19295:   return (NSWindow*)topLevelWidget->GetNativeData(NS_NATIVE_WINDOW);
19295: }
 1283: 
19490: static BOOL FrameIsInActiveWindow(nsIFrame* aFrame)
19490: {
19490:   nsIWidget* topLevelWidget = NULL;
19490:   NSWindow* win = NativeWindowForFrame(aFrame, NULL, &topLevelWidget);
19490:   if (!topLevelWidget || !win)
19490:     return YES;
19490: 
19490:   // XUL popups, e.g. the toolbar customization popup, can't become key windows,
19490:   // but controls in these windows should still get the active look.
19490:   nsWindowType windowType;
19490:   topLevelWidget->GetWindowType(windowType);
22060:   if (windowType == eWindowType_popup)
22060:     return YES;
22060:   if ([win isSheet])
22060:     return [win isKeyWindow];
22060:   return [win isMainWindow] && ![win attachedSheet];
19490: }
19490: 
    1: NS_IMPL_ISUPPORTS1(nsNativeThemeCocoa, nsITheme)
    1: 
    1: 
    1: nsNativeThemeCocoa::nsNativeThemeCocoa()
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
 9641:   mPushButtonCell = [[NSButtonCell alloc] initTextCell:nil];
 9641:   [mPushButtonCell setButtonType:NSMomentaryPushInButton];
 9641:   [mPushButtonCell setHighlightsBy:NSPushInCellMask];
10241: 
10241:   mRadioButtonCell = [[NSButtonCell alloc] initTextCell:nil];
10241:   [mRadioButtonCell setButtonType:NSRadioButton];
20384: 
20384:   mCheckboxCell = [[NSButtonCell alloc] initTextCell:nil];
20384:   [mCheckboxCell setButtonType:NSSwitchButton];
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: nsNativeThemeCocoa::~nsNativeThemeCocoa()
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
 9641:   [mPushButtonCell release];
10241:   [mRadioButtonCell release];
20384:   [mCheckboxCell release];
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
22255: // Limit on the area of the target rect (in pixels^2) in
22255: // DrawCellWithScaling(), DrawButton() and DrawScrollbar(), above which we
22255: // don't draw the object into a bitmap buffer.  This is to avoid crashes in
19342: // [NSGraphicsContext graphicsContextWithGraphicsPort:flipped:] and
19342: // CGContextDrawImage(), and also to avoid very poor drawing performance in
22255: // CGContextDrawImage() when it scales the bitmap (particularly if xscale or
22255: // yscale is less than but near 1 -- e.g. 0.9).  This value was determined
22255: // by trial and error, on OS X 10.4.11 and 10.5.4, and on systems with
22255: // different amounts of RAM.
22255: #define BITMAP_MAX_AREA 500000
19342: 
12566: /*
12566:  * Draw the given NSCell into the given cgContext.
12566:  *
12566:  * destRect - the size and position of the resulting control rectangle
12566:  * controlSize - the NSControlSize which will be given to the NSCell before
12566:  *  asking it to render
20384:  * naturalSize - The natural dimensions of this control.
12566:  *  If the control rect size is not equal to either of these, a scale
12566:  *  will be applied to the context so that rendering the control at the
12566:  *  natural size will result in it filling the destRect space.
12566:  *  If a control has no natural dimensions in either/both axes, pass 0.0f.
20384:  * minimumSize - The minimum dimensions of this control.
12566:  *  If the control rect size is less than the minimum for a given axis,
12566:  *  a scale will be applied to the context so that the minimum is used
12566:  *  for drawing.  If a control has no minimum dimensions in either/both
12566:  *  axes, pass 0.0f.
12566:  * marginSet - an array of margins; a multidimensional array of [2][3][4],
20384:  *  with the first dimension being the OS version (Tiger or Leopard),
20384:  *  the second being the control size (mini, small, regular), and the third
20384:  *  being the 4 margin values (left, top, right, bottom).
20384:  * flip - Whether to draw the control mirrored
20384:  * needsBuffer - Set this to false if no buffer should be used. Bypassing the
20384:  *  buffer is faster but it can lead to painting problems with accumulating
20384:  *  focus rings.
12566:  */
20384: static void DrawCellWithScaling(NSCell *cell,
12566:                                 CGContextRef cgContext,
12566:                                 const HIRect& destRect,
12566:                                 NSControlSize controlSize,
20384:                                 NSSize naturalSize,
20384:                                 NSSize minimumSize,
12566:                                 const float marginSet[][3][4],
20384:                                 PRBool flip,
20384:                                 PRBool needsBuffer = PR_TRUE)
12566: {
12566:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12566: 
12568:   NSRect drawRect = NSMakeRect(destRect.origin.x, destRect.origin.y, destRect.size.width, destRect.size.height);
12566: 
20384:   if (naturalSize.width != 0.0f)
20384:     drawRect.size.width = naturalSize.width;
20384:   if (naturalSize.height != 0.0f)
20384:     drawRect.size.height = naturalSize.height;
12566: 
20384:   // Keep aspect ratio when scaling if one dimension is free.
20384:   if (naturalSize.width == 0.0f && naturalSize.height != 0.0f)
20384:     drawRect.size.width = destRect.size.width * naturalSize.height / destRect.size.height;
20384:   if (naturalSize.height == 0.0f && naturalSize.width != 0.0f)
20384:     drawRect.size.height = destRect.size.height * naturalSize.width / destRect.size.width;
12566: 
20384:   // Honor minimum sizes.
20384:   if (drawRect.size.width < minimumSize.width)
20384:     drawRect.size.width = minimumSize.width;
20384:   if (drawRect.size.height < minimumSize.height)
20384:     drawRect.size.height = minimumSize.height;
20384: 
21536:   [NSGraphicsContext saveGraphicsState];
20384: 
20384:   if (flip) {
20384:     // This flips the image in place and is necessary to work around a bug in the way
20384:     // NSButtonCell draws buttons.
20384:     CGContextScaleCTM(cgContext, 1.0f, -1.0f);
20384:     CGContextTranslateCTM(cgContext, 0.0f, -(2.0 * destRect.origin.y + destRect.size.height));
12566:   }
12566: 
22255:   // Fall back to no bitmap buffer (and no scaling) if the area of our cell
22255:   // (in pixels^2) is too large.
22255:   BOOL noBufferOverride = (drawRect.size.width * drawRect.size.height > BITMAP_MAX_AREA);
12566: 
20384:   if ((!needsBuffer && drawRect.size.width == destRect.size.width &&
20384:        drawRect.size.height == destRect.size.height) || noBufferOverride) {
12566:     // Inflate the rect Gecko gave us by the margin for the control.
12566:     InflateControlRect(&drawRect, controlSize, marginSet);
13085: 
21536:     NSGraphicsContext* savedContext = [NSGraphicsContext currentContext];
21536: 
13085:     // Set up the graphics context we've been asked to draw to.
13085:     [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:cgContext flipped:YES]];
13085: 
19342:     // [NSView focusView] may return nil here, but
19342:     // [NSCell drawWithFrame:inView:] can deal with that.
19271:     [cell drawWithFrame:drawRect inView:[NSView focusView]];
21536: 
21536:     [NSGraphicsContext setCurrentContext:savedContext];
13085:   }
13085:   else {
13085:     float w = ceil(drawRect.size.width);
13085:     float h = ceil(drawRect.size.height);
13085: 
13085:     NSRect tmpRect = NSMakeRect(0.0f, 0.0f, w, h);
13085: 
13085:     // inflate to figure out the frame we need to tell NSCell to draw in, to get something that's 0,0,w,h
13085:     InflateControlRect(&tmpRect, controlSize, marginSet);
13085: 
13085:     // and then, expand by MAX_FOCUS_RING_WIDTH size to make sure we can capture any focus ring
13085:     w += MAX_FOCUS_RING_WIDTH * 2.0;
13085:     h += MAX_FOCUS_RING_WIDTH * 2.0;
13085: 
13085:     CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB();
13085:     CGContextRef ctx = CGBitmapContextCreate(NULL,
13085:                                              (int) w, (int) h,
13085:                                              8, (int) w * 4,
13085:                                              rgb, kCGImageAlphaPremultipliedFirst);
13085:     CGColorSpaceRelease(rgb);
13085: 
13085:     CGContextTranslateCTM(ctx, MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH);
13085: 
21536:     NSGraphicsContext* savedContext = [NSGraphicsContext currentContext];
21536: 
13085:     [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:ctx flipped:YES]];
13085: 
19342:     // [NSView focusView] may return nil here, but
19342:     // [NSCell drawWithFrame:inView:] can deal with that.
19271:     [cell drawWithFrame:tmpRect inView:[NSView focusView]];
12566: 
12566:     [NSGraphicsContext setCurrentContext:savedContext];
12566: 
13085:     CGImageRef img = CGBitmapContextCreateImage(ctx);
13085: 
13085:     // Drop the image into the original destination rectangle, scaling to fit
20384:     // Only scale MAX_FOCUS_RING_WIDTH by xscale/yscale when the resulting rect
20384:     // doesn't extend beyond the overflow rect
20384:     float xscale = destRect.size.width / drawRect.size.width;
20384:     float yscale = destRect.size.height / drawRect.size.height;
20384:     float scaledFocusRingX = xscale < 1.0f ? MAX_FOCUS_RING_WIDTH * xscale : MAX_FOCUS_RING_WIDTH;
20384:     float scaledFocusRingY = yscale < 1.0f ? MAX_FOCUS_RING_WIDTH * yscale : MAX_FOCUS_RING_WIDTH;
20384:     CGContextDrawImage(cgContext, CGRectMake(destRect.origin.x - scaledFocusRingX,
20384:                                              destRect.origin.y - scaledFocusRingY,
20384:                                              destRect.size.width + scaledFocusRingX * 2,
20384:                                              destRect.size.height + scaledFocusRingY * 2),
13085:                        img);
13085: 
13085:     CGImageRelease(img);
13085:     CGContextRelease(ctx);
13085:   }
13085: 
21536:   [NSGraphicsContext restoreGraphicsState];
13085: 
12566: #if DRAW_IN_FRAME_DEBUG
13085:   CGContextSetRGBFillColor(cgContext, 0.0, 0.0, 0.5, 0.25);
12566:   CGContextFillRect(cgContext, destRect);
12566: #endif
12566: 
12566:   NS_OBJC_END_TRY_ABORT_BLOCK;
12566: }
12566: 
20384: struct CellRenderSettings {
20384:   // The natural dimensions of the control.
20384:   // If a control has no natural dimensions in either/both axes, set to 0.0f.
20384:   NSSize naturalSizes[3];
20384: 
20384:   // The minimum dimensions of the control.
20384:   // If a control has no minimum dimensions in either/both axes, set to 0.0f.
20384:   NSSize minimumSizes[3];
20384: 
20384:   // A multidimensional array of [2][3][4],
20384:   // with the first dimension being the OS version (Tiger or Leopard),
20384:   // the second being the control size (mini, small, regular), and the third
20384:   // being the 4 margin values (left, top, right, bottom).
20384:   float margins[2][3][4];
20384: };
20384: 
20384: /*
20384:  * Draw the given NSCell into the given cgContext with a nice control size.
20384:  *
20384:  * This function is similar to DrawCellWithScaling, but it decides what
20384:  * control size to use based on the destRect's size.
20384:  * Scaling is only applied when the difference between the destRect's size
20384:  * and the next smaller natural size is greater than sSnapTolerance. Otherwise
20384:  * it snaps to the next smaller control size without scaling because unscaled
20384:  * controls look nicer.
20384:  */
20384: static const float sSnapTolerance = 1.0f;
20384: static void DrawCellWithSnapping(NSCell *cell,
20384:                                  CGContextRef cgContext,
20384:                                  const HIRect& destRect,
20384:                                  const CellRenderSettings settings,
20384:                                  PRBool flip,
20384:                                  float verticalAlignFactor,
20384:                                  PRBool needsBuffer = PR_TRUE)
20384: {
20384:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
20384: 
20384:   const float rectWidth = destRect.size.width, rectHeight = destRect.size.height;
20384:   const NSSize *sizes = settings.naturalSizes;
20384:   const NSSize miniSize = sizes[EnumSizeForCocoaSize(NSMiniControlSize)];
20384:   const NSSize smallSize = sizes[EnumSizeForCocoaSize(NSSmallControlSize)];
20384:   const NSSize regularSize = sizes[EnumSizeForCocoaSize(NSRegularControlSize)];
20384: 
20384:   NSControlSize controlSizeX = NSRegularControlSize, controlSizeY = NSRegularControlSize;
20384:   HIRect drawRect = destRect;
20384: 
20384:   if (rectWidth <= miniSize.width + sSnapTolerance)
20384:     controlSizeX = NSMiniControlSize;
20384:   else if(rectWidth <= smallSize.width + sSnapTolerance)
20384:     controlSizeX = NSSmallControlSize;
20384: 
20384:   if (rectHeight <= miniSize.height + sSnapTolerance)
20384:     controlSizeY = NSMiniControlSize;
20384:   else if(rectHeight <= smallSize.height + sSnapTolerance)
20384:     controlSizeY = NSSmallControlSize;
20384: 
20384:   NSControlSize controlSize = NSRegularControlSize;
20384:   int sizeIndex = 0;
20384: 
20384:   // At some sizes, don't scale but snap.
20384:   const NSControlSize smallerControlSize =
20384:     EnumSizeForCocoaSize(controlSizeX) < EnumSizeForCocoaSize(controlSizeY) ?
20384:     controlSizeX : controlSizeY;
20384:   const int smallerControlSizeIndex = EnumSizeForCocoaSize(smallerControlSize);
20384:   float diffWidth = rectWidth - sizes[smallerControlSizeIndex].width;
20384:   float diffHeight = rectHeight - sizes[smallerControlSizeIndex].height;
20384:   if (diffWidth >= 0.0f && diffHeight >= 0.0f &&
20384:       diffWidth <= sSnapTolerance && diffHeight <= sSnapTolerance) {
20384:     // Snap to the smaller control size.
20384:     controlSize = smallerControlSize;
20384:     sizeIndex = smallerControlSizeIndex;
20384:     // Resize and center the drawRect.
20384:     if (sizes[sizeIndex].width) {
20384:       drawRect.origin.x += ceil((destRect.size.width - sizes[sizeIndex].width) / 2);
20384:       drawRect.size.width = sizes[sizeIndex].width;
20384:     }
20384:     if (sizes[sizeIndex].height) {
20384:       drawRect.origin.y += floor((destRect.size.height - sizes[sizeIndex].height) * verticalAlignFactor);
20384:       drawRect.size.height = sizes[sizeIndex].height;
20384:     }
20384:   } else {
20384:     // Use the larger control size.
20384:     controlSize = EnumSizeForCocoaSize(controlSizeX) > EnumSizeForCocoaSize(controlSizeY) ?
20384:                   controlSizeX : controlSizeY;
20384:     sizeIndex = EnumSizeForCocoaSize(controlSize);
20384:    }
20384: 
20384:   [cell setControlSize:controlSize];
20384: 
20384:   NSSize minimumSize = settings.minimumSizes ? settings.minimumSizes[sizeIndex] : NSZeroSize;
20384:   DrawCellWithScaling(cell, cgContext, drawRect, controlSize, sizes[sizeIndex],
20384:                       minimumSize, settings.margins, flip, needsBuffer);
20384: 
20384:   NS_OBJC_END_TRY_ABORT_BLOCK;
20384: }
20384: 
20384: static float VerticalAlignFactor(nsIFrame *aFrame)
20384: {
20384:   if (!aFrame)
20384:     return 0.5f; // default: center
20384: 
20384:   const nsStyleCoord& va = aFrame->GetStyleTextReset()->mVerticalAlign;
20384:   PRUint8 intval = (va.GetUnit() == eStyleUnit_Enumerated)
20384:                      ? va.GetIntValue()
20384:                      : NS_STYLE_VERTICAL_ALIGN_MIDDLE;
20384:   switch (intval) {
20384:     case NS_STYLE_VERTICAL_ALIGN_TOP:
20384:     case NS_STYLE_VERTICAL_ALIGN_TEXT_TOP:
20384:       return 0.0f;
20384: 
20384:     case NS_STYLE_VERTICAL_ALIGN_SUB:
20384:     case NS_STYLE_VERTICAL_ALIGN_SUPER:
20384:     case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
20384:     case NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE:
20384:       return 0.5f;
20384: 
20384:     case NS_STYLE_VERTICAL_ALIGN_BASELINE:
20384:     case NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM:
20384:     case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
20384:       return 1.0f;
20384: 
20384:     default:
20384:       NS_NOTREACHED("invalid vertical-align");
20384:       return 0.5f;
20384:   }
20384: }
20384: 
13085: // These are the sizes that Gecko needs to request to draw if it wants
13085: // to get a standard-sized Aqua radio button drawn. Note that the rects
13085: // that draw these are actually a little bigger.
20384: static const CellRenderSettings radioSettings = {
20384:   {
20384:     NSMakeSize(11, 11), // mini
20384:     NSMakeSize(13, 13), // small
20384:     NSMakeSize(16, 16)  // regular
20384:   },
20384:   {
20384:     NSZeroSize, NSZeroSize, NSZeroSize
20384:   },
13085:   {
13085:     { // Tiger
20384:       {0, 0, 0, 0},     // mini
20384:       {0, 2, 1, 1},     // small
20384:       {0, 1, 0, -1}     // regular
13085:     },
13085:     { // Leopard
20384:       {0, 0, 0, 0},     // mini
20384:       {0, 1, 1, 1},     // small
20384:       {0, 0, 0, 0}      // regular
20384:     }
20384:   }
20384: };
20384: 
20384: static const CellRenderSettings checkboxSettings = {
20384:   {
20384:     NSMakeSize(11, 11), // mini
20384:     NSMakeSize(13, 13), // small
20384:     NSMakeSize(16, 16)  // regular
20384:   },
20384:   {
20384:     NSZeroSize, NSZeroSize, NSZeroSize
20384:   },
20384:   {
20384:     { // Tiger
20384:       {0, 1, 0, 0},     // mini
20384:       {0, 2, 0, 1},     // small
20384:       {0, 1, 0, 1}      // regular
20384:     },
20384:     { // Leopard
20384:       {0, 1, 0, 0},     // mini
20384:       {0, 1, 0, 1},     // small
20384:       {0, 1, 0, 1}      // regular
20384:     }
13085:   }
13085: };
13085: 
10241: void
20384: nsNativeThemeCocoa::DrawCheckboxOrRadio(CGContextRef cgContext, PRBool inCheckbox,
20384:                                         const HIRect& inBoxRect, PRBool inSelected,
20384:                                         PRBool inDisabled, PRInt32 inState,
20384:                                         nsIFrame* aFrame)
10241: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
20384:   NSButtonCell *cell = inCheckbox ? mCheckboxCell : mRadioButtonCell;
10241: 
20384:   [cell setEnabled:!inDisabled];
20384:   [cell setShowsFirstResponder:(inState & NS_EVENT_STATE_FOCUS)];
20384:   [cell setState:(inSelected ? NSOnState : NSOffState)];
20384:   [cell setHighlighted:((inState & NS_EVENT_STATE_ACTIVE) && (inState & NS_EVENT_STATE_HOVER))];
20384:   [cell setControlTint:(FrameIsInActiveWindow(aFrame) ? [NSColor currentControlTint] : NSClearControlTint)];
10241:  
20384:   DrawCellWithSnapping(cell, cgContext, inBoxRect,
20384:                        inCheckbox ? checkboxSettings : radioSettings,
20384:                        nsToolkit::OnLeopardOrLater(),  // Tiger doesn't need flipping
20384:                        VerticalAlignFactor(aFrame));
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
10241: }
10241: 
10241: 
10241: // These are the sizes that Gecko needs to request to draw if it wants
 9641: // to get a standard-sized Aqua rounded bevel button drawn. Note that
 9641: // the rects that draw these are actually a little bigger.
 9641: #define NATURAL_MINI_ROUNDED_BUTTON_MIN_WIDTH 18
 9641: #define NATURAL_MINI_ROUNDED_BUTTON_HEIGHT 16
 9641: #define NATURAL_SMALL_ROUNDED_BUTTON_MIN_WIDTH 26
 9641: #define NATURAL_SMALL_ROUNDED_BUTTON_HEIGHT 19
 9641: #define NATURAL_REGULAR_ROUNDED_BUTTON_MIN_WIDTH 30
 9641: #define NATURAL_REGULAR_ROUNDED_BUTTON_HEIGHT 22
 9641: 
 9641: // These were calculated by testing all three sizes on the respective operating system.
 9641: static const float pushButtonMargins[2][3][4] =
 9641: {
 9641:   { // Tiger
 9641:     {1, 1, 1, 1}, // mini
 9641:     {5, 1, 5, 1}, // small
 9641:     {6, 0, 6, 2}  // regular
 9641:   },
 9641:   { // Leopard
 9641:     {0, 0, 0, 0}, // mini
 9641:     {4, 0, 4, 1}, // small
 9641:     {5, 0, 5, 2}  // regular
 9641:   }
 9641: };
 9641: 
12566: // The height at which we start doing square buttons instead of rounded buttons
12566: // Rounded buttons look bad if drawn at a height greater than 26, so at that point
12566: // we switch over to doing square buttons which looks fine at any size.
12566: #define DO_SQUARE_BUTTON_HEIGHT 26
12566: 
 9641: void
 9641: nsNativeThemeCocoa::DrawPushButton(CGContextRef cgContext, const HIRect& inBoxRect, PRBool inIsDefault,
19490:                                    PRBool inDisabled, PRInt32 inState, nsIFrame* aFrame)
 9641: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
 9641:   NSRect drawRect = NSMakeRect(inBoxRect.origin.x, inBoxRect.origin.y, inBoxRect.size.width, inBoxRect.size.height);
 9641: 
19490:   BOOL isActive = FrameIsInActiveWindow(aFrame);
19490: 
 9641:   [mPushButtonCell setEnabled:!inDisabled];
19490:   [mPushButtonCell setHighlighted:(((inState & NS_EVENT_STATE_ACTIVE) &&
19490:                                     (inState & NS_EVENT_STATE_HOVER) ||
19490:                                     (inIsDefault && !inDisabled)) && 
19490:                                    isActive)];
19490:   [mPushButtonCell setShowsFirstResponder:(inState & NS_EVENT_STATE_FOCUS) && !inDisabled && isActive];
 9641: 
 9641:   // If the button is tall enough, draw the square button style so that buttons with
 9641:   // non-standard content look good. Otherwise draw normal rounded aqua buttons.
12566:   if (drawRect.size.height > DO_SQUARE_BUTTON_HEIGHT) {
 9641:     [mPushButtonCell setBezelStyle:NSShadowlessSquareBezelStyle];
20384:     DrawCellWithScaling(mPushButtonCell, cgContext, inBoxRect, NSRegularControlSize,
20384:                         NSZeroSize, NSMakeSize(14, 0), NULL, PR_TRUE);
12566:   } else {
 9641:     [mPushButtonCell setBezelStyle:NSRoundedBezelStyle];
 9641: 
 9641:     // Figure out what size cell control we're going to draw and grab its
 9641:     // natural height and min width.
 9641:     NSControlSize controlSize = NSRegularControlSize;
 9641:     float naturalHeight = NATURAL_REGULAR_ROUNDED_BUTTON_HEIGHT;
 9641:     float minWidth = NATURAL_REGULAR_ROUNDED_BUTTON_MIN_WIDTH;
 9641:     if (drawRect.size.height <= NATURAL_MINI_ROUNDED_BUTTON_HEIGHT &&
 9641:         drawRect.size.width >= NATURAL_MINI_ROUNDED_BUTTON_MIN_WIDTH) {
 9641:       controlSize = NSMiniControlSize;
 9641:       naturalHeight = NATURAL_MINI_ROUNDED_BUTTON_HEIGHT;
 9641:       minWidth = NATURAL_MINI_ROUNDED_BUTTON_MIN_WIDTH;
 9641:     }
 9641:     else if (drawRect.size.height <= NATURAL_SMALL_ROUNDED_BUTTON_HEIGHT &&
 9641:              drawRect.size.width >= NATURAL_SMALL_ROUNDED_BUTTON_MIN_WIDTH) {
 9641:       controlSize = NSSmallControlSize;
 9641:       naturalHeight = NATURAL_SMALL_ROUNDED_BUTTON_HEIGHT;
 9641:       minWidth = NATURAL_SMALL_ROUNDED_BUTTON_MIN_WIDTH;
 9641:     }
 9641:     [mPushButtonCell setControlSize:controlSize];
 9641: 
12566:     DrawCellWithScaling(mPushButtonCell, cgContext, inBoxRect, controlSize,
20384:                         NSMakeSize(0.0f, naturalHeight),
20384:                         NSMakeSize(minWidth, 0.0f),
20384:                         pushButtonMargins, PR_TRUE);
 9641:   }
 9641: 
 9641: #if DRAW_IN_FRAME_DEBUG
13085:   CGContextSetRGBFillColor(cgContext, 0.0, 0.0, 0.5, 0.25);
 9641:   CGContextFillRect(cgContext, inBoxRect);
 9641: #endif
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
 9641: }
 9641: 
 9641: 
    1: void
    1: nsNativeThemeCocoa::DrawButton(CGContextRef cgContext, ThemeButtonKind inKind,
    1:                                const HIRect& inBoxRect, PRBool inIsDefault, PRBool inDisabled,
    1:                                ThemeButtonValue inValue, ThemeButtonAdornment inAdornment,
19490:                                PRInt32 inState, nsIFrame* aFrame)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
19490:   BOOL isActive = FrameIsInActiveWindow(aFrame);
19490: 
  985:   HIThemeButtonDrawInfo bdi;
    1:   bdi.version = 0;
    1:   bdi.kind = inKind;
    1:   bdi.value = inValue;
    1:   bdi.adornment = inAdornment;
    1: 
19490:   if (inDisabled) {
    1:     bdi.state = kThemeStateUnavailable;
19490:   }
19490:   else if ((inState & NS_EVENT_STATE_ACTIVE) && (inState & NS_EVENT_STATE_HOVER)) {
    1:     bdi.state = kThemeStatePressed;
19490:   }
19490:   else {
19490:     if (inKind == kThemeArrowButton)
19490:       bdi.state = kThemeStateUnavailable; // these are always drawn as unavailable
19490:     else if (!isActive && (inKind == kThemeListHeaderButton || inKind == kThemePopupButton))
19490:       bdi.state = kThemeStateInactive;
    1:     else
19490:       bdi.state = kThemeStateActive;
19490:   }
    1: 
19490:   if (inState & NS_EVENT_STATE_FOCUS && isActive)
    1:     bdi.adornment |= kThemeAdornmentFocus;
    1: 
    1:   if (inIsDefault && !inDisabled)
    1:     bdi.adornment |= kThemeAdornmentDefault;
    1: 
 1578:   HIRect drawFrame = inBoxRect;
13330:   PRBool needsScaling = PR_FALSE;
13330:   int drawWidth = 0, drawHeight = 0;
13330: 
 9641:   if (inKind == kThemePopupButton) {
13330:     /* popup buttons draw outside their frame by 1 pixel on each side and
13330:      * two on the bottom but of the bottom two pixels one is a 'shadow'
13330:      * and not the frame itself.  That extra pixel should be handled
13330:      * by GetWidgetOverflow, but we already extend each widget's overflow
13330:      * by 4px to handle a potential focus ring.
13330:      */
13330: 
13330:     if (nsToolkit::OnLeopardOrLater()) {
13330:       /* Leopard will happily scale up for buttons that are sized 20px or higher,
13330:        * drawing 1px below the actual requested area.  (So 20px == 21px.)
13330:        * but anything below that will be clamped:
13330:        *  requested: 20 actual: 21 (handled above)
13330:        *  requested: 19 actual: 18 <- note that there is no way to draw a dropdown that's exactly 20 px in size
13330:        *  requested: 18 actual: 18
13330:        *  requested: 17 actual: 18
13330:        *  requested: 16 actual: 15 (min size)
13330:        * For those, draw to a buffer and scale
13330:        */
13330:       if (drawFrame.size.height != 18 && drawFrame.size.height != 15) {
13330:         if (drawFrame.size.height > 20) {
 5896:           drawFrame.size.width -= 2;
 5896:           drawFrame.origin.x += 1;
13330:           drawFrame.size.height -= 1;
13330:         }
13330:         else {
13330:           // pick which native height to use for the small scale
13330:           float nativeHeight = 15.0f;
13330:           if (drawFrame.size.height > 16)
13330:             nativeHeight = 18.0f;
13330: 
13330:           drawWidth = (int) drawFrame.size.width;
13330:           drawHeight = (int) nativeHeight;
13330: 
13330:           needsScaling = PR_TRUE;
13330:         }
13330:       }
13330:     }
13330:     else {
13330:       // leave things alone on Tiger
13330:       drawFrame.size.height -= 1;
13330:     }
22055:   } else if (inKind == kThemeListHeaderButton) {
22055:     CGContextClipToRect(cgContext, inBoxRect);
22055:     // Always remove the top border.
22055:     drawFrame.origin.y -= 1;
22055:     drawFrame.size.height += 1;
22055:     // Remove the left border in LTR mode and the right border in RTL mode.
22055:     drawFrame.size.width += 1;
22055:     PRBool isLast = IsLastTreeHeaderCell(aFrame);
22055:     if (isLast)
22055:       drawFrame.size.width += 1; // Also remove the other border.
22055:     if (!IsFrameRTL(aFrame) || isLast)
22055:       drawFrame.origin.x -= 1;
 5896:   }
 1032: 
22255:   // Fall back to no bitmap buffer (and no scaling) if the area of our button
22255:   // (in pixels^2) is too large.
22255:   if (!needsScaling || (drawWidth * drawHeight > BITMAP_MAX_AREA)) {
 1032:     HIThemeDrawButton(&drawFrame, &bdi, cgContext, kHIThemeOrientationNormal, NULL);
13330:   } else {
13330:     int w = drawWidth + MAX_FOCUS_RING_WIDTH*2;
13330:     int h = drawHeight + MAX_FOCUS_RING_WIDTH*2;
13330: 
13330:     CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB();
13330:     CGContextRef ctx = CGBitmapContextCreate(NULL, w, h, 8, w * 4,
13330:                                              rgb, kCGImageAlphaPremultipliedFirst);
13330:     CGColorSpaceRelease(rgb);
13330: 
13330:     // Flip the context
13330:     CGContextTranslateCTM(ctx, 0.0f, h);
13330:     CGContextScaleCTM(ctx, 1.0f, -1.0f);
13330: 
13330:     // then draw the button (offset by the focus ring size
13330:     CGRect tmpFrame = CGRectMake(MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH, drawWidth, drawHeight);
13330:     HIThemeDrawButton(&tmpFrame, &bdi, ctx, kHIThemeOrientationNormal, NULL);
13330: 
13330:     CGImageRef img = CGBitmapContextCreateImage(ctx);
13330:     CGRect imgRect = CGRectMake(drawFrame.origin.x - MAX_FOCUS_RING_WIDTH,
13330:                                 drawFrame.origin.y - MAX_FOCUS_RING_WIDTH,
13330:                                 drawFrame.size.width + MAX_FOCUS_RING_WIDTH * 2.0,
13330:                                 drawFrame.size.height + MAX_FOCUS_RING_WIDTH * 2.0);
13330: 
13330:     // And then flip the main context here so that the image gets drawn right-side up
13330:     CGAffineTransform ctm = CGContextGetCTM (cgContext);
13330: 
13330:     CGContextTranslateCTM (cgContext, imgRect.origin.x, imgRect.origin.y + imgRect.size.height);
13330:     CGContextScaleCTM (cgContext, 1.0, -1.0);
13330: 
13330:     imgRect.origin.x = imgRect.origin.y = 0.0f;
13330: 
13330:     // See comment about why we don't scale MAX_FOCUS_RING in DrawCellWithScaling
13330:     CGContextDrawImage(cgContext, imgRect, img);
13330: 
13330:     CGContextSetCTM (cgContext, ctm);
13330: 
13330:     CGImageRelease(img);
13330:     CGContextRelease(ctx);
13330:   }
    1: 
    1: #if DRAW_IN_FRAME_DEBUG
13330:   CGContextSetRGBFillColor(cgContext, 0.0, 0.0, 0.5, 0.25);
    1:   CGContextFillRect(cgContext, inBoxRect);
    1: #endif
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
  458: 
    1: void
    1: nsNativeThemeCocoa::DrawSpinButtons(CGContextRef cgContext, ThemeButtonKind inKind,
    1:                                     const HIRect& inBoxRect, PRBool inDisabled,
 5362:                                     ThemeDrawState inDrawState,
 5362:                                     ThemeButtonAdornment inAdornment,
19490:                                     PRInt32 inState, nsIFrame* aFrame)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
    1:   HIThemeButtonDrawInfo bdi;
    1:   bdi.version = 0;
    1:   bdi.kind = inKind;
    1:   bdi.value = kThemeButtonOff;
    1:   bdi.adornment = inAdornment;
    1: 
    1:   if (inDisabled)
    1:     bdi.state = kThemeStateUnavailable;
19490:   else
19490:     bdi.state = FrameIsInActiveWindow(aFrame) ? inDrawState : kThemeStateActive;
    1: 
    1:   HIThemeDrawButton(&inBoxRect, &bdi, cgContext, HITHEME_ORIENTATION, NULL);
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
  458: 
    1: void
    1: nsNativeThemeCocoa::DrawFrame(CGContextRef cgContext, HIThemeFrameKind inKind,
15089:                               const HIRect& inBoxRect, PRBool inIsDisabled, PRInt32 inState)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
    1:   HIThemeFrameDrawInfo fdi;
    1:   fdi.version = 0;
    1:   fdi.kind = inKind;
19490: 
19490:   // We don't ever set an inactive state for this because it doesn't
19490:   // look right (see other apps).
    1:   fdi.state = inIsDisabled ? kThemeStateUnavailable : kThemeStateActive;
19490: 
11335:   // for some reason focus rings on listboxes draw incorrectly
11335:   if (inKind == kHIThemeFrameListBox)
    1:     fdi.isFocused = 0;
11335:   else
11335:     fdi.isFocused = (inState & NS_EVENT_STATE_FOCUS) != 0;
    1: 
    1:   // HIThemeDrawFrame takes the rect for the content area of the frame, not
    1:   // the bounding rect for the frame. Here we reduce the size of the rect we
    1:   // will pass to make it the size of the content.
    1:   HIRect drawRect = inBoxRect;
    1:   if (inKind == kHIThemeFrameTextFieldSquare) {
    1:     SInt32 frameOutset = 0;
    1:     ::GetThemeMetric(kThemeMetricEditTextFrameOutset, &frameOutset);
    1:     drawRect.origin.x += frameOutset;
    1:     drawRect.origin.y += frameOutset;
    1:     drawRect.size.width -= frameOutset * 2;
    1:     drawRect.size.height -= frameOutset * 2;
    1:   }
 5371:   else if (inKind == kHIThemeFrameListBox) {
 5371:     SInt32 frameOutset = 0;
 5371:     ::GetThemeMetric(kThemeMetricListBoxFrameOutset, &frameOutset);
 5371:     drawRect.origin.x += frameOutset;
 5371:     drawRect.origin.y += frameOutset;
 5371:     drawRect.size.width -= frameOutset * 2;
 5371:     drawRect.size.height -= frameOutset * 2;
 5371:   }
    1: 
    1: #if DRAW_IN_FRAME_DEBUG
13085:   CGContextSetRGBFillColor(cgContext, 0.0, 0.0, 0.5, 0.25);
    1:   CGContextFillRect(cgContext, inBoxRect);
    1: #endif
    1: 
    1:   HIThemeDrawFrame(&drawRect, &fdi, cgContext, HITHEME_ORIENTATION);
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
  458: 
    1: void
19490: nsNativeThemeCocoa::DrawProgress(CGContextRef cgContext, const HIRect& inBoxRect,
19490:                                  PRBool inIsIndeterminate, PRBool inIsHorizontal,
21093:                                  PRInt32 inValue, PRInt32 inMaxValue,
21093:                                  nsIFrame* aFrame)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
    1:   HIThemeTrackDrawInfo tdi;
14006: 
14006:   PRInt32 stepsPerSecond = inIsIndeterminate ? 60 : 30;
14006:   PRInt32 milliSecondsPerStep = 1000 / stepsPerSecond;
    1: 
    1:   tdi.version = 0;
    1:   tdi.kind = inIsIndeterminate ? kThemeMediumIndeterminateBar: kThemeMediumProgressBar;
    1:   tdi.bounds = inBoxRect;
    1:   tdi.min = 0;
21093:   tdi.max = inMaxValue;
    1:   tdi.value = inValue;
    1:   tdi.attributes = inIsHorizontal ? kThemeTrackHorizontal : 0;
19490:   tdi.enableState = FrameIsInActiveWindow(aFrame) ? kThemeTrackActive : kThemeTrackInactive;
14006:   tdi.trackInfo.progress.phase = PR_IntervalToMilliseconds(PR_IntervalNow()) /
14006:                                  milliSecondsPerStep % 16;
    1: 
    1:   HIThemeDrawTrack(&tdi, NULL, cgContext, HITHEME_ORIENTATION);
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: void
19490: nsNativeThemeCocoa::DrawTabPanel(CGContextRef cgContext, const HIRect& inBoxRect,
19490:                                  nsIFrame* aFrame)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
    1:   HIThemeTabPaneDrawInfo tpdi;
    1: 
22056:   tpdi.version = 1;
19490:   tpdi.state = FrameIsInActiveWindow(aFrame) ? kThemeStateActive : kThemeStateInactive;
    1:   tpdi.direction = kThemeTabNorth;
    1:   tpdi.size = kHIThemeTabSizeNormal;
22056:   tpdi.kind = kHIThemeTabKindNormal;
    1: 
    1:   HIThemeDrawTabPane(&inBoxRect, &tpdi, cgContext, HITHEME_ORIENTATION);
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
    1: void
    1: nsNativeThemeCocoa::DrawScale(CGContextRef cgContext, const HIRect& inBoxRect,
    1:                               PRBool inIsDisabled, PRInt32 inState,
  421:                               PRBool inIsVertical, PRBool inIsReverse,
19490:                               PRInt32 inCurrentValue, PRInt32 inMinValue,
19490:                               PRInt32 inMaxValue, nsIFrame* aFrame)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
    1:   HIThemeTrackDrawInfo tdi;
    1: 
    1:   tdi.version = 0;
    1:   tdi.kind = kThemeMediumSlider;
    1:   tdi.bounds = inBoxRect;
    1:   tdi.min = inMinValue;
    1:   tdi.max = inMaxValue;
    1:   tdi.value = inCurrentValue;
    1:   tdi.attributes = kThemeTrackShowThumb;
    1:   if (!inIsVertical)
    1:     tdi.attributes |= kThemeTrackHorizontal;
  421:   if (inIsReverse)
  421:     tdi.attributes |= kThemeTrackRightToLeft;
    1:   if (inState & NS_EVENT_STATE_FOCUS)
    1:     tdi.attributes |= kThemeTrackHasFocus;
19490:   if (inIsDisabled)
19490:     tdi.enableState = kThemeTrackDisabled;
19490:   else
19490:     tdi.enableState = FrameIsInActiveWindow(aFrame) ? kThemeTrackActive : kThemeTrackInactive;
    1:   tdi.trackInfo.slider.thumbDir = kThemeThumbPlain;
    1:   tdi.trackInfo.slider.pressState = 0;
    1: 
    1:   HIThemeDrawTrack(&tdi, NULL, cgContext, HITHEME_ORIENTATION);
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: 
22056: #define NATURAL_MINI_TAB_BUTTON_HEIGHT    17
22056: #define NATURAL_SMALL_TAB_BUTTON_HEIGHT   20
22056: #define NATURAL_REGULAR_TAB_BUTTON_HEIGHT 23
22056: 
22056: 
    1: void
22056: nsNativeThemeCocoa::DrawTab(CGContextRef cgContext, HIRect inBoxRect,
19490:                             PRInt32 inState, nsIFrame* aFrame)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
    1:   HIThemeTabDrawInfo tdi;
22056:   tdi.version = 1;
    1: 
22056:   PRBool isSelected = IsSelectedTab(aFrame);
22056:   PRBool isDisabled = IsDisabled(aFrame);
22056:   if (isSelected) {
22056:     if (isDisabled) 
    1:       tdi.style = kThemeTabFrontUnavailable;
    1:     else
19490:       tdi.style = FrameIsInActiveWindow(aFrame) ? kThemeTabFront : kThemeTabFrontInactive;
    1:   } else {
22056:     if (isDisabled)
    1:       tdi.style = kThemeTabNonFrontUnavailable;
    1:     else if ((inState & NS_EVENT_STATE_ACTIVE) && (inState & NS_EVENT_STATE_HOVER))
    1:       tdi.style = kThemeTabNonFrontPressed;
    1:     else
19490:       tdi.style = FrameIsInActiveWindow(aFrame) ? kThemeTabNonFront : kThemeTabNonFrontInactive;
    1:   }
    1: 
22056:   tdi.direction = kThemeTabNorth;
    1:   tdi.size = kHIThemeTabSizeNormal;
22056:   if (inBoxRect.size.height < NATURAL_REGULAR_TAB_BUTTON_HEIGHT)
22056:     tdi.size = kHIThemeTabSizeSmall;
22056:   if (inBoxRect.size.height < NATURAL_SMALL_TAB_BUTTON_HEIGHT)
22056:     tdi.size = kHIThemeTabSizeMini;
22056: 
22056:   PRBool isRTL = IsFrameRTL(aFrame);
22056:   PRBool isFirst = isRTL ? IsLastTab(aFrame) : IsFirstTab(aFrame);
22056:   PRBool isLast = isRTL ? IsFirstTab(aFrame) : IsLastTab(aFrame);
22056: 
22056:   if (isFirst && isLast)
22056:     tdi.position = kHIThemeTabPositionOnly;
22056:   else if (isFirst)
22056:     tdi.position = kHIThemeTabPositionFirst;
22056:   else if (isLast)
22056:     tdi.position = kHIThemeTabPositionLast;
22056:   else
22056:     tdi.position = kHIThemeTabPositionMiddle;
22056: 
22056:   // Tab separator management:
22056:   // Normal tabs only draw their left separator, in the leftmost pixel row of
22056:   // their frame. Selected tabs additionally draw their right separator, outside
22056:   // of their frame. To prevent overlapping, the tab to the right of the
22056:   // selected tab shouldn't draw its left separator.
22056:   tdi.adornment = kHIThemeTabAdornmentNone;
22056:   if (isRTL ? IsBeforeSelectedTab(aFrame) : IsAfterSelectedTab(aFrame)) {
22056:     if (nsToolkit::OnLeopardOrLater()) {
22056:       // On Leopard, the tab's left edge must be shifted 1px to the right.
22056:       // On Tiger, this happens automatically when no leading separator is drawn.
22056:       inBoxRect.origin.x += 1;
22056:       inBoxRect.size.width -= 1;
22056:     }
22056:   }
22056:   else {
22056:     tdi.adornment = kHIThemeTabAdornmentLeadingSeparator;
22056:   }
22056: 
22056:   if (isSelected && !isLast) {
22056:     tdi.adornment |= kHIThemeTabAdornmentTrailingSeparator;
22056:     if (nsToolkit::OnLeopardOrLater()) {
22056:       // On Tiger, the right separator is drawn outside of the frame.
22056:       // On Leopard, the right edge must be shifted 1px to the right.
22056:       inBoxRect.size.width += 1;
22056:     }
22056:   }
22056:   
22056:   if (inState & NS_EVENT_STATE_FOCUS)
22056:     tdi.adornment |= kThemeAdornmentFocus;
    1: 
    1:   HIThemeDrawTab(&inBoxRect, &tdi, cgContext, HITHEME_ORIENTATION, NULL);
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
  458: 
12566: static inline UInt8
  458: ConvertToPressState(PRInt32 aButtonState, UInt8 aPressState)
  458: {
  458:   // If the button is pressed, return the press state passed in. Otherwise, return 0.
  458:   return ((aButtonState & NS_EVENT_STATE_ACTIVE) && (aButtonState & NS_EVENT_STATE_HOVER)) ? aPressState : 0;
  458: }
  458: 
  458: 
  458: void 
  458: nsNativeThemeCocoa::GetScrollbarPressStates(nsIFrame *aFrame, PRInt32 aButtonStates[])
  458: {
  458:   static nsIContent::AttrValuesArray attributeValues[] = {
  458:     &nsWidgetAtoms::scrollbarUpTop,
  458:     &nsWidgetAtoms::scrollbarDownTop,
  458:     &nsWidgetAtoms::scrollbarUpBottom,
  458:     &nsWidgetAtoms::scrollbarDownBottom,
  458:     nsnull
  458:   };
  458: 
  458:   // Get the state of any scrollbar buttons in our child frames
  458:   for (nsIFrame *childFrame = aFrame->GetFirstChild(nsnull); 
  458:        childFrame;
  458:        childFrame = childFrame->GetNextSibling()) {
  458: 
  458:     nsIContent *childContent = childFrame->GetContent();
  458:     if (!childContent) continue;
  458:     PRInt32 attrIndex = childContent->FindAttrValueIn(kNameSpaceID_None, nsWidgetAtoms::sbattr, 
  458:                                                       attributeValues, eCaseMatters);
  458:     if (attrIndex < 0) continue;
  458: 
  458:     PRInt32 currentState = GetContentState(childFrame, NS_THEME_BUTTON);
  458:     aButtonStates[attrIndex] = currentState;
  458:   }
  458: }
  458: 
  458: 
 3093: // Both of the following sets of numbers were derived by loading the testcase in
 3093: // bmo bug 380185 in Safari and observing its behavior for various heights of scrollbar.
 3090: // These magic numbers are the minimum sizes we can draw a scrollbar and still 
 3090: // have room for everything to display, including the thumb
 3090: #define MIN_SCROLLBAR_SIZE_WITH_THUMB 61
 3090: #define MIN_SMALL_SCROLLBAR_SIZE_WITH_THUMB 49
 3090: // And these are the minimum sizes if we don't draw the thumb
 3090: #define MIN_SCROLLBAR_SIZE 56
 3090: #define MIN_SMALL_SCROLLBAR_SIZE 46
 3090: 
  458: void
  458: nsNativeThemeCocoa::GetScrollbarDrawInfo(HIThemeTrackDrawInfo& aTdi, nsIFrame *aFrame, 
  458:                                          const HIRect& aRect, PRBool aShouldGetButtonStates)
  458: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
13622:   PRInt32 curpos = CheckIntAttr(aFrame, nsWidgetAtoms::curpos, 0);
13622:   PRInt32 minpos = CheckIntAttr(aFrame, nsWidgetAtoms::minpos, 0);
13622:   PRInt32 maxpos = CheckIntAttr(aFrame, nsWidgetAtoms::maxpos, 100);
13622:   PRInt32 thumbSize = CheckIntAttr(aFrame, nsWidgetAtoms::pageincrement, 10);
  458: 
  458:   PRBool isHorizontal = aFrame->GetContent()->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::orient, 
  458:                                                           nsWidgetAtoms::horizontal, eCaseMatters);
  458:   PRBool isSmall = aFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL;
  458: 
  458:   aTdi.version = 0;
  458:   aTdi.kind = isSmall ? kThemeSmallScrollBar : kThemeMediumScrollBar;
  458:   aTdi.bounds = aRect;
  458:   aTdi.min = minpos;
  458:   aTdi.max = maxpos;
  458:   aTdi.value = curpos;
 3090:   aTdi.attributes = 0;
 6677:   aTdi.enableState = kThemeTrackActive;
  458:   if (isHorizontal)
  458:     aTdi.attributes |= kThemeTrackHorizontal;
  458: 
13622:   aTdi.trackInfo.scrollbar.viewsize = (SInt32)thumbSize;
  458: 
19490:   // This should be done early on so things like "kThemeTrackNothingToScroll" can
19490:   // override the active enable state.
19490:   aTdi.enableState = FrameIsInActiveWindow(aFrame) ? kThemeTrackActive : kThemeTrackInactive;
19490: 
12566:   /* Only display features if we have enough room for them.
12566:    * Gecko still maintains the scrollbar info; this is just a visual issue (bug 380185).
12566:    */
13622:   PRInt32 longSideLength = (PRInt32)(isHorizontal ? (aRect.size.width) : (aRect.size.height));
 3093:   if (longSideLength >= (isSmall ? MIN_SMALL_SCROLLBAR_SIZE_WITH_THUMB : MIN_SCROLLBAR_SIZE_WITH_THUMB)) {
 3090:     aTdi.attributes |= kThemeTrackShowThumb;
 3090:   }
 3093:   else if (longSideLength < (isSmall ? MIN_SMALL_SCROLLBAR_SIZE : MIN_SCROLLBAR_SIZE)) {
 3090:     aTdi.enableState = kThemeTrackNothingToScroll;
 3090:     return;
 3090:   }
 3090: 
  458:   // Only go get these scrollbar button states if we need it. For example, there's no reaon to look up scrollbar button 
  458:   // states when we're only creating a TrackDrawInfo to determine the size of the thumb.
  458:   if (aShouldGetButtonStates) {
  458:     PRInt32 buttonStates[] = {0, 0, 0, 0};
  458:     GetScrollbarPressStates(aFrame, buttonStates);
  458:     ThemeScrollBarArrowStyle arrowStyle;
  458:     ::GetThemeScrollBarArrowStyle(&arrowStyle);
  458:     // If all four buttons are visible
  458:     if (arrowStyle == kThemeScrollBarArrowsBoth) {
  458:       aTdi.trackInfo.scrollbar.pressState = ConvertToPressState(buttonStates[0], kThemeTopOutsideArrowPressed) |
  458:                                             ConvertToPressState(buttonStates[1], kThemeTopInsideArrowPressed) |
  458:                                             ConvertToPressState(buttonStates[2], kThemeBottomInsideArrowPressed) |
  458:                                             ConvertToPressState(buttonStates[3], kThemeBottomOutsideArrowPressed);
  458:     } else {
  458:       // It seems that unless all four buttons are showing, kThemeTopOutsideArrowPressed is the correct constant for
  458:       // the up scrollbar button.
  458:       aTdi.trackInfo.scrollbar.pressState = ConvertToPressState(buttonStates[0], kThemeTopOutsideArrowPressed) |
14127:                                             ConvertToPressState(buttonStates[1], kThemeBottomOutsideArrowPressed) |
  458:                                             ConvertToPressState(buttonStates[2], kThemeTopOutsideArrowPressed) |
  458:                                             ConvertToPressState(buttonStates[3], kThemeBottomOutsideArrowPressed);
  458:     }
  458:   }
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
  458: }
  458: 
  458: 
  458: void
  458: nsNativeThemeCocoa::DrawScrollbar(CGContextRef aCGContext, const HIRect& aBoxRect, nsIFrame *aFrame)
  458: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11981: 
12566:   // HIThemeDrawTrack is buggy with rotations and scaling
12566:   CGAffineTransform savedCTM = CGContextGetCTM(aCGContext);
12566:   PRBool drawDirect;
12566:   HIRect drawRect = aBoxRect;
12566: 
12566:   if (savedCTM.a == 1.0f && savedCTM.b == 0.0f &&
12566:       savedCTM.c == 0.0f && (savedCTM.d == 1.0f || savedCTM.d == -1.0f))
12566:   {
12566:     drawDirect = TRUE;
12566:   } else {
12566:     drawRect.origin.x = drawRect.origin.y = 0.0f;
12566:     drawDirect = FALSE;
12566:   }
12566: 
  458:   HIThemeTrackDrawInfo tdi;
 6677:   GetScrollbarDrawInfo(tdi, aFrame, drawRect, PR_TRUE); //True means we want the press states
 6677: 
22255:   // Fall back to no bitmap buffer if the area of our scrollbar (in pixels^2)
22255:   // is too large.
22255:   if (drawDirect || (aBoxRect.size.width * aBoxRect.size.height > BITMAP_MAX_AREA)) {
  458:     ::HIThemeDrawTrack(&tdi, NULL, aCGContext, HITHEME_ORIENTATION);
12566:   } else {
12566:     // Note that NSScroller can draw transformed just fine, but HITheme can't.
12566:     // However, we can't make NSScroller's parts light up easily (depressed buttons, etc.)
12566:     // This is very frustrating.
 6677: 
12566:     CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
12566:     CGContextRef bitmapctx = CGBitmapContextCreate(NULL,
12566:                                                    (size_t) ceil(drawRect.size.width),
12566:                                                    (size_t) ceil(drawRect.size.height),
12566:                                                    8,
12566:                                                    (size_t) ceil(drawRect.size.width) * 4,
12566:                                                    colorSpace,
12566:                                                    kCGImageAlphaPremultipliedFirst);
12566:     CGColorSpaceRelease(colorSpace);
 6677: 
12566:     // HITheme always wants to draw into a flipped context, or things
12566:     // get confused.
12566:     CGContextTranslateCTM(bitmapctx, 0.0f, aBoxRect.size.height);
12566:     CGContextScaleCTM(bitmapctx, 1.0f, -1.0f);
12566: 
12566:     HIThemeDrawTrack(&tdi, NULL, bitmapctx, HITHEME_ORIENTATION);
12566: 
12566:     CGImageRef bitmap = CGBitmapContextCreateImage(bitmapctx);
12566: 
12566:     CGAffineTransform ctm = CGContextGetCTM(aCGContext);
12566: 
12566:     // We need to unflip, so that we can do a DrawImage without getting a flipped image.
12566:     CGContextTranslateCTM(aCGContext, 0.0f, aBoxRect.size.height);
 6677:     CGContextScaleCTM(aCGContext, 1.0f, -1.0f);
 6677: 
12566:     CGContextDrawImage(aCGContext, aBoxRect, bitmap);
 6677: 
12566:     CGContextSetCTM(aCGContext, ctm);
12566: 
12566:     CGImageRelease(bitmap);
12566:     CGContextRelease(bitmapctx);
 6677:   }
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK;
  458: }
  458: 
  458: 
  458: nsIFrame*
  458: nsNativeThemeCocoa::GetParentScrollbarFrame(nsIFrame *aFrame)
  458: {
  458:   // Walk our parents to find a scrollbar frame
  458:   nsIFrame *scrollbarFrame = aFrame;
  458:   do {
  458:     if (scrollbarFrame->GetType() == nsWidgetAtoms::scrollbarFrame) break;
  458:   } while ((scrollbarFrame = scrollbarFrame->GetParent()));
  458:   
  458:   // We return null if we can't find a parent scrollbar frame
  458:   return scrollbarFrame;
  458: }
  458: 
  458: 
19295: void
19295: nsNativeThemeCocoa::DrawUnifiedToolbar(CGContextRef cgContext, const HIRect& inBoxRect,
19295:                                        nsIFrame *aFrame)
19295: {
19295:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
19295: 
19295:   float titlebarHeight = 0;
19295:   int levelsUp = 0;
19295:   NSWindow* win = NativeWindowForFrame(aFrame, &levelsUp);
19295: 
19295:   // If the toolbar is directly below the titlebar in the top level view of a ToolbarWindow
19295:   if ([win isKindOfClass:[ToolbarWindow class]] && levelsUp == 0 &&
19295:       inBoxRect.origin.y <= 0) {
19295:     // Consider the titlebar height when calculating the gradient.
19295:     titlebarHeight = [(ToolbarWindow*)win titlebarHeight];
19295:     // Notify the window about the toolbar's height so that it can draw the
19295:     // correct gradient in the titlebar.
19295:     [(ToolbarWindow*)win setUnifiedToolbarHeight:inBoxRect.size.height];
19295:   }
19295:   
19295:   BOOL isMain = win ? [win isMainWindow] : YES;
19295: 
19295:   // Draw the gradient
19295:   UnifiedGradientInfo info = { titlebarHeight, inBoxRect.size.height, isMain, NO };
20506:   struct CGFunctionCallbacks callbacks = { 0, nsCocoaWindow::UnifiedShading, NULL };
19295:   CGFunctionRef function = CGFunctionCreate(&info, 1,  NULL, 4, NULL, &callbacks);
19295:   float srcY = inBoxRect.origin.y;
19295:   float dstY = srcY + inBoxRect.size.height - 1;
19295:   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
19295:   CGShadingRef shading = CGShadingCreateAxial(colorSpace,
19295:                                               CGPointMake(0, srcY),
19295:                                               CGPointMake(0, dstY), function,
19295:                                               NO, NO);
19295:   CGColorSpaceRelease(colorSpace);
19295:   CGFunctionRelease(function);
19295:   CGContextClipToRect(cgContext, inBoxRect);
19295:   CGContextDrawShading(cgContext, shading);
19295:   CGShadingRelease(shading);
19295: 
19295:   // Draw the border at the bottom of the toolbar.
19320:   [NativeGreyColorAsNSColor(headerBorderGrey, isMain) set];
19295:   NSRectFill(NSMakeRect(inBoxRect.origin.x, inBoxRect.origin.y +
19295:                         inBoxRect.size.height - 1.0f, inBoxRect.size.width, 1.0f));
19295: 
19295:   NS_OBJC_END_TRY_ABORT_BLOCK;
19295: }
19295: 
19295: 
    1: NS_IMETHODIMP
    1: nsNativeThemeCocoa::DrawWidgetBackground(nsIRenderingContext* aContext, nsIFrame* aFrame,
    1:                                          PRUint8 aWidgetType, const nsRect& aRect,
16193:                                          const nsRect& aDirtyRect)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11981: 
    1:   // setup to draw into the correct port
    1:   nsCOMPtr<nsIDeviceContext> dctx;
    1:   aContext->GetDeviceContext(*getter_AddRefs(dctx));
    1:   PRInt32 p2a = dctx->AppUnitsPerDevPixel();
    1: 
16193:   gfxRect nativeDirtyRect(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
11944:   gfxRect nativeWidgetRect(aRect.x, aRect.y, aRect.width, aRect.height);
11944:   nativeWidgetRect.ScaleInverse(gfxFloat(p2a));
16193:   nativeDirtyRect.ScaleInverse(gfxFloat(p2a));
16245:   nativeWidgetRect.Round();
20756:   if (nativeWidgetRect.IsEmpty())
20756:     return NS_OK; // Don't attempt to draw invisible widgets.
11944: 
 9438:   nsRefPtr<gfxContext> thebesCtx = aContext->ThebesContext();
    1:   if (!thebesCtx)
    1:     return NS_ERROR_FAILURE;
    1: 
16193:   gfxQuartzNativeDrawing nativeDrawing(thebesCtx, nativeDirtyRect);
    1: 
11944:   CGContextRef cgContext = nativeDrawing.BeginNativeDrawing();
 3610:   if (cgContext == nsnull) {
10696:     // The Quartz surface handles 0x0 surfaces by internally
10696:     // making all operations no-ops; there's no cgcontext created for them.
10696:     // Unfortunately, this means that callers that want to render
10696:     // directly to the CGContext need to be aware of this quirk.
10696:     return NS_OK;
    1:   }
    1: 
    1: #if 0
    1:   if (1 /*aWidgetType == NS_THEME_TEXTFIELD*/) {
    1:     fprintf(stderr, "Native theme drawing widget %d [%p] dis:%d in rect [%d %d %d %d]\n",
    1:             aWidgetType, aFrame, IsDisabled(aFrame), aRect.x, aRect.y, aRect.width, aRect.height);
 6430:     fprintf(stderr, "Cairo matrix: [%f %f %f %f %f %f]\n",
 6430:             mat.xx, mat.yx, mat.xy, mat.yy, mat.x0, mat.y0);
    1:     fprintf(stderr, "Native theme xform[0]: [%f %f %f %f %f %f]\n",
    1:             mm0.a, mm0.b, mm0.c, mm0.d, mm0.tx, mm0.ty);
    1:     CGAffineTransform mm = CGContextGetCTM(cgContext);
    1:     fprintf(stderr, "Native theme xform[1]: [%f %f %f %f %f %f]\n",
    1:             mm.a, mm.b, mm.c, mm.d, mm.tx, mm.ty);
    1:   }
    1: #endif
    1: 
16245:   CGRect macRect = CGRectMake(nativeWidgetRect.X(), nativeWidgetRect.Y(),
16245:                               nativeWidgetRect.Width(), nativeWidgetRect.Height());
 4356: 
    1: #if 0
    1:   fprintf(stderr, "    --> macRect %f %f %f %f\n",
    1:           macRect.origin.x, macRect.origin.y, macRect.size.width, macRect.size.height);
    1:   CGRect bounds = CGContextGetClipBoundingBox(cgContext);
    1:   fprintf(stderr, "    --> clip bounds: %f %f %f %f\n",
    1:           bounds.origin.x, bounds.origin.y, bounds.size.width, bounds.size.height);
    1: 
    1:   //CGContextSetRGBFillColor(cgContext, 0.0, 0.0, 1.0, 0.1);
    1:   //CGContextFillRect(cgContext, bounds);
    1: #endif
    1: 
    1:   PRInt32 eventState = GetContentState(aFrame, aWidgetType);
    1: 
    1:   switch (aWidgetType) {
    1:     case NS_THEME_DIALOG: {
 7980:       HIThemeSetFill(kThemeBrushDialogBackgroundActive, NULL, cgContext, HITHEME_ORIENTATION);
    1:       CGContextFillRect(cgContext, macRect);
    1:     }
    1:       break;
    1: 
    1:     case NS_THEME_MENUPOPUP: {
    1:       HIThemeMenuDrawInfo mdi = {
    1:         version: 0,
    1:         menuType: IsDisabled(aFrame) ? kThemeMenuTypeInactive : kThemeMenuTypePopUp
    1:       };
    1: 
    1:       HIThemeDrawMenuBackground(&macRect, &mdi, cgContext, HITHEME_ORIENTATION);
    1:     }
    1:       break;
    1: 
    1:     case NS_THEME_MENUITEM: {
    1:       // maybe use kThemeMenuItemHierBackground or PopUpBackground instead of just Plain?
    1:       HIThemeMenuItemDrawInfo drawInfo = {
    1:         version: 0,
    1:         itemType: kThemeMenuItemPlain,
    1:         state: (IsDisabled(aFrame) ? kThemeMenuDisabled :
    1:                 CheckBooleanAttr(aFrame, nsWidgetAtoms::mozmenuactive) ? kThemeMenuSelected :
    1:                 kThemeMenuActive)
    1:       };
    1: 
    1:       // XXX pass in the menu rect instead of always using the item rect
    1:       HIRect ignored;
    1:       HIThemeDrawMenuItem(&macRect, &macRect, &drawInfo, cgContext, HITHEME_ORIENTATION, &ignored);
    1:     }
    1:       break;
    1: 
12179:     case NS_THEME_MENUSEPARATOR: {
12179:       ThemeMenuState menuState;
12179:       if (IsDisabled(aFrame)) {
12179:         menuState = kThemeMenuDisabled;
12179:       }
12179:       else {
12179:         menuState = CheckBooleanAttr(aFrame, nsWidgetAtoms::mozmenuactive) ?
12179:                     kThemeMenuSelected : kThemeMenuActive;
12179:       }
12179: 
12179:       HIThemeMenuItemDrawInfo midi = { 0, kThemeMenuItemPlain, menuState };
12179:       HIThemeDrawMenuSeparator(&macRect, &macRect, &midi, cgContext, HITHEME_ORIENTATION);
12179:     }
12179:       break;
12179: 
    1:     case NS_THEME_TOOLTIP:
    1:       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 0.78, 1.0);
    1:       CGContextFillRect(cgContext, macRect);
    1:       break;
    1: 
    1:     case NS_THEME_CHECKBOX:
21220:     case NS_THEME_RADIO: {
21220:       PRBool isCheckbox = (aWidgetType == NS_THEME_CHECKBOX);
20384:       DrawCheckboxOrRadio(cgContext, isCheckbox, macRect, GetCheckedOrSelected(aFrame, !isCheckbox),
20384:                           IsDisabled(aFrame), eventState, aFrame);
20384:     }
    1:       break;
    1: 
    1:     case NS_THEME_BUTTON:
19490:       DrawPushButton(cgContext, macRect, IsDefaultButton(aFrame), IsDisabled(aFrame), eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_BUTTON_BEVEL:
    1:       DrawButton(cgContext, kThemeMediumBevelButton, macRect,
    1:                  IsDefaultButton(aFrame), IsDisabled(aFrame), 
19490:                  kThemeButtonOff, kThemeAdornmentNone, eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_SPINNER: {
    1:       ThemeDrawState state = kThemeStateActive;
    1:       nsIContent* content = aFrame->GetContent();
    1:       if (content->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::state,
    1:                                NS_LITERAL_STRING("up"), eCaseMatters)) {
    1:         state = kThemeStatePressedUp;
    1:       }
    1:       else if (content->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::state,
    1:                                     NS_LITERAL_STRING("down"), eCaseMatters)) {
    1:         state = kThemeStatePressedDown;
    1:       }
    1: 
    1:       DrawSpinButtons(cgContext, kThemeIncDecButton, macRect, IsDisabled(aFrame),
19490:                       state, kThemeAdornmentNone, eventState, aFrame);
    1:     }
    1:       break;
    1: 
    1:     case NS_THEME_TOOLBAR_BUTTON:
    1:       DrawButton(cgContext, kThemePushButton, macRect,
    1:                  IsDefaultButton(aFrame), IsDisabled(aFrame),
19490:                  kThemeButtonOn, kThemeAdornmentNone, eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_TOOLBAR_SEPARATOR: {
    1:       HIThemeSeparatorDrawInfo sdi = { 0, kThemeStateActive };
    1:       HIThemeDrawSeparator(&macRect, &sdi, cgContext, HITHEME_ORIENTATION);
    1:     }
    1:       break;
    1: 
19295:     case NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR:
19295:       DrawUnifiedToolbar(cgContext, macRect, aFrame);
19295:       break;
19295: 
    1:     case NS_THEME_TOOLBAR:
    1:     case NS_THEME_TOOLBOX:
    1:     case NS_THEME_STATUSBAR: {
    1:       HIThemeHeaderDrawInfo hdi = { 0, kThemeStateActive, kHIThemeHeaderKindWindow };
    1:       HIThemeDrawHeader(&macRect, &hdi, cgContext, HITHEME_ORIENTATION);
    1:     }
    1:       break;
    1:       
    1:     case NS_THEME_DROPDOWN:
    1:       DrawButton(cgContext, kThemePopupButton, macRect,
    1:                  IsDefaultButton(aFrame), IsDisabled(aFrame), 
19490:                  kThemeButtonOn, kThemeAdornmentNone, eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:       DrawButton(cgContext, kThemeArrowButton, macRect, PR_FALSE,
    1:                  IsDisabled(aFrame), kThemeButtonOn,
19490:                  kThemeAdornmentArrowDownArrow, eventState, aFrame);
    1:       break;
    1: 
13030:     case NS_THEME_GROUPBOX: {
13030:       HIThemeGroupBoxDrawInfo gdi = { 0, kThemeStateActive, kHIThemeGroupBoxKindPrimary };
13030:       HIThemeDrawGroupBox(&macRect, &gdi, cgContext, HITHEME_ORIENTATION);
13030:       break;
13030:     }
13030: 
    1:     case NS_THEME_TEXTFIELD:
    1:       // HIThemeSetFill is not available on 10.3
    1:       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 1.0, 1.0);
    1:       CGContextFillRect(cgContext, macRect);
11366: 
11366:       // XUL textboxes set the native appearance on the containing box, while
11366:       // concrete focus is set on the html:input element within it. We can
11366:       // though, check the focused attribute of xul textboxes in this case.
11366:       if (aFrame->GetContent()->IsNodeOfType(nsINode::eXUL) &&
11366:           IsFocused(aFrame)) {
11366:         eventState |= NS_EVENT_STATE_FOCUS;
11366:       }
11366: 
    1:       DrawFrame(cgContext, kHIThemeFrameTextFieldSquare,
    1:                 macRect, (IsDisabled(aFrame) || IsReadOnly(aFrame)), eventState);
    1:       break;
    1:       
    1:     case NS_THEME_PROGRESSBAR:
    1:       DrawProgress(cgContext, macRect, IsIndeterminateProgress(aFrame),
21093:                    PR_TRUE, GetProgressValue(aFrame),
21093:                    GetProgressMaxValue(aFrame), aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:       DrawProgress(cgContext, macRect, IsIndeterminateProgress(aFrame),
21093:                    PR_FALSE, GetProgressValue(aFrame),
21093:                    GetProgressMaxValue(aFrame), aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:       // do nothing, covered by the progress bar cases above
    1:       break;
    1: 
    1:     case NS_THEME_TREEVIEW_TWISTY:
    1:       DrawButton(cgContext, kThemeDisclosureButton, macRect, PR_FALSE, IsDisabled(aFrame), 
19490:                  kThemeDisclosureRight, kThemeAdornmentNone, eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_TREEVIEW_TWISTY_OPEN:
    1:       DrawButton(cgContext, kThemeDisclosureButton, macRect, PR_FALSE, IsDisabled(aFrame), 
19490:                  kThemeDisclosureDown, kThemeAdornmentNone, eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_TREEVIEW_HEADER_CELL: {
    1:       TreeSortDirection sortDirection = GetTreeSortDirection(aFrame);
    1:       DrawButton(cgContext, kThemeListHeaderButton, macRect, PR_FALSE, IsDisabled(aFrame), 
    1:                  sortDirection == eTreeSortDirection_Natural ? kThemeButtonOff : kThemeButtonOn,
22055:                  sortDirection == eTreeSortDirection_Ascending ?
19490:                  kThemeAdornmentHeaderButtonSortUp : kThemeAdornmentNone, eventState, aFrame);      
    1:     }
    1:       break;
    1: 
    1:     case NS_THEME_TREEVIEW_TREEITEM:
    1:     case NS_THEME_TREEVIEW:
    1:       // HIThemeSetFill is not available on 10.3
    1:       // HIThemeSetFill(kThemeBrushWhite, NULL, cgContext, HITHEME_ORIENTATION);
    1:       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 1.0, 1.0);
    1:       CGContextFillRect(cgContext, macRect);
    1:       break;
    1: 
    1:     case NS_THEME_TREEVIEW_HEADER:
    1:       // do nothing, taken care of by individual header cells
    1:     case NS_THEME_TREEVIEW_HEADER_SORTARROW:
    1:       // do nothing, taken care of by treeview header
    1:     case NS_THEME_TREEVIEW_LINE:
    1:       // do nothing, these lines don't exist on macos
    1:       break;
    1: 
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL: {
13622:       PRInt32 curpos = CheckIntAttr(aFrame, nsWidgetAtoms::curpos, 0);
13622:       PRInt32 minpos = CheckIntAttr(aFrame, nsWidgetAtoms::minpos, 0);
13622:       PRInt32 maxpos = CheckIntAttr(aFrame, nsWidgetAtoms::maxpos, 100);
    1:       if (!maxpos)
    1:         maxpos = 100;
    1: 
  421:       PRBool reverse = aFrame->GetContent()->
  421:         AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::dir,
  421:                     NS_LITERAL_STRING("reverse"), eCaseMatters);
    1:       DrawScale(cgContext, macRect, IsDisabled(aFrame), eventState,
  421:                 (aWidgetType == NS_THEME_SCALE_VERTICAL), reverse,
19490:                 curpos, minpos, maxpos, aFrame);
    1:     }
    1:       break;
    1: 
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1:       // do nothing, drawn by scale
    1:       break;
    1: 
  458:     case NS_THEME_SCROLLBAR_SMALL:
  458:     case NS_THEME_SCROLLBAR: {
  458:       DrawScrollbar(cgContext, macRect, aFrame);
  458:     }
  458:       break;
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
  458: #if SCROLLBARS_VISUAL_DEBUG
  458:       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 0, 0.6);
  458:       CGContextFillRect(cgContext, macRect);
  458:     break;
  458: #endif
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
  458:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
  458: #if SCROLLBARS_VISUAL_DEBUG
  458:       CGContextSetRGBFillColor(cgContext, 1.0, 0, 0, 0.6);
  458:       CGContextFillRect(cgContext, macRect);
  458:     break;
  458: #endif
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
  458:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
  458: #if SCROLLBARS_VISUAL_DEBUG
  458:       CGContextSetRGBFillColor(cgContext, 0, 1.0, 0, 0.6);
  458:       CGContextFillRect(cgContext, macRect);
  458:     break;      
  458: #endif
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
  458:       // do nothing, drawn by scrollbar
    1:       break;
    1: 
 1191:     case NS_THEME_TEXTFIELD_MULTILINE: {
 1191:       // we have to draw this by hand because there is no HITheme value for it
 1191:       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 1.0, 1.0);
 1191:       
 1191:       CGContextFillRect(cgContext, macRect);
 1191: 
 1191:       CGContextSetLineWidth(cgContext, 1.0);
 1191:       CGContextSetShouldAntialias(cgContext, false);
 1191: 
 1191:       // stroke everything but the top line of the text area
 1191:       CGContextSetRGBStrokeColor(cgContext, 0.6, 0.6, 0.6, 1.0);
 1191:       CGContextBeginPath(cgContext);
 1191:       CGContextMoveToPoint(cgContext, macRect.origin.x, macRect.origin.y + 1);
 1191:       CGContextAddLineToPoint(cgContext, macRect.origin.x, macRect.origin.y + macRect.size.height);
 1191:       CGContextAddLineToPoint(cgContext, macRect.origin.x + macRect.size.width - 1, macRect.origin.y + macRect.size.height);
 1191:       CGContextAddLineToPoint(cgContext, macRect.origin.x + macRect.size.width - 1, macRect.origin.y + 1);
 1191:       CGContextStrokePath(cgContext);
 1191: 
 1191:       // stroke the line across the top of the text area
 1191:       CGContextSetRGBStrokeColor(cgContext, 0.4510, 0.4510, 0.4510, 1.0);
 1191:       CGContextBeginPath(cgContext);
 1191:       CGContextMoveToPoint(cgContext, macRect.origin.x, macRect.origin.y + 1);
 1191:       CGContextAddLineToPoint(cgContext, macRect.origin.x + macRect.size.width - 1, macRect.origin.y + 1);
 1191:       CGContextStrokePath(cgContext);
11335: 
11335:       // draw a focus ring
11335:       if (eventState & NS_EVENT_STATE_FOCUS) {
11338:         // We need to bring the rectangle in by 1 pixel on each side.
11338:         CGRect cgr = CGRectMake(macRect.origin.x + 1,
11338:                                 macRect.origin.y + 1,
11338:                                 macRect.size.width - 2,
11338:                                 macRect.size.height - 2);
11335:         HIThemeDrawFocusRect(&cgr, true, cgContext, kHIThemeOrientationNormal);
11335:       }
 1191:     }
 1191:       break;
 1191: 
    1:     case NS_THEME_LISTBOX:
    1:       // HIThemeSetFill is not available on 10.3
    1:       CGContextSetRGBFillColor(cgContext, 1.0, 1.0, 1.0, 1.0);
    1:       CGContextFillRect(cgContext, macRect);
19490:       DrawFrame(cgContext, kHIThemeFrameListBox, macRect,
19490:                 (IsDisabled(aFrame) || IsReadOnly(aFrame)), eventState);
    1:       break;
    1:     
22056:     case NS_THEME_TAB:
22056:       DrawTab(cgContext, macRect, eventState, aFrame);
    1:       break;
    1: 
    1:     case NS_THEME_TAB_PANELS:
19490:       DrawTabPanel(cgContext, macRect, aFrame);
    1:       break;
    1:   }
    1: 
11944:   nativeDrawing.EndNativeDrawing();
    1: 
    1:   return NS_OK;
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
 1934: 
 1708: static const int kAquaDropdownLeftBorder = 5;
 1934: static const int kAquaDropdownRightBorder = 22;
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeCocoa::GetWidgetBorder(nsIDeviceContext* aContext, 
    1:                                     nsIFrame* aFrame,
    1:                                     PRUint8 aWidgetType,
19835:                                     nsMargin* aResult)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11981: 
    1:   aResult->SizeTo(0, 0, 0, 0);
    1: 
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON:
 9641:     {
 9641:       aResult->SizeTo(7, 1, 7, 3);
    1:       break;
 9641:     }
    1: 
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_BUTTON:
 5896:       aResult->SizeTo(kAquaDropdownLeftBorder, 2, kAquaDropdownRightBorder, 2);
    1:       break;
    1: 
 5600:     case NS_THEME_TEXTFIELD:
 5600:     {
    1:       SInt32 frameOutset = 0;
    1:       ::GetThemeMetric(kThemeMetricEditTextFrameOutset, &frameOutset);
 5600: 
 5600:       SInt32 textPadding = 0;
 5600:       ::GetThemeMetric(kThemeMetricEditTextWhitespace, &textPadding);
 5600: 
 5600:       frameOutset += textPadding;
 5600: 
    1:       aResult->SizeTo(frameOutset, frameOutset, frameOutset, frameOutset);
 5600:       break;
    1:     }
    1: 
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
 1191:       aResult->SizeTo(1, 1, 1, 1);
 1191:       break;
 1191: 
 5600:     case NS_THEME_LISTBOX:
 5600:     {
    1:       SInt32 frameOutset = 0;
    1:       ::GetThemeMetric(kThemeMetricListBoxFrameOutset, &frameOutset);
    1:       aResult->SizeTo(frameOutset, frameOutset, frameOutset, frameOutset);
 5600:       break;
    1:     }
 1191: 
  458:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
  458:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
  458:     {
  458:       // There's only an endcap to worry about when both arrows are on the bottom
  458:       ThemeScrollBarArrowStyle arrowStyle;
  458:       ::GetThemeScrollBarArrowStyle(&arrowStyle);
  458:       if (arrowStyle == kThemeScrollBarArrowsLowerRight) {
  458:         PRBool isHorizontal = (aWidgetType == NS_THEME_SCROLLBAR_TRACK_HORIZONTAL);
  458: 
  458:         nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
  458:         if (!scrollbarFrame) return NS_ERROR_FAILURE;
  458:         PRBool isSmall = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL);
  458: 
  458:         // There isn't a metric for this, so just hardcode a best guess at the value.
  458:         // This value is even less exact due to the fact that the endcap is partially concave.
  458:         PRInt32 endcapSize = isSmall ? 5 : 6;
  458: 
  458:         if (isHorizontal)
  458:           aResult->SizeTo(endcapSize, 0, 0, 0);
  458:         else
  458:           aResult->SizeTo(0, endcapSize, 0, 0);
  458:       }
 5600:       break;
  458:     }
19295: 
19295:     case NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR:
19295:       aResult->SizeTo(0, 0, 1, 0);
19295:       break;
    1:   }
    1: 
    1:   return NS_OK;
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
  458: 
 5600: // Return PR_FALSE here to indicate that CSS padding values should be used. There is
 5600: // no reason to make a distinction between padding and border values, just specify
 5600: // whatever values you want in GetWidgetBorder and only use this to return PR_TRUE
 5600: // if you want to override CSS padding values.
    1: PRBool
    1: nsNativeThemeCocoa::GetWidgetPadding(nsIDeviceContext* aContext, 
    1:                                      nsIFrame* aFrame,
    1:                                      PRUint8 aWidgetType,
19835:                                      nsMargin* aResult)
    1: {
 8130:   // We don't want CSS padding being used for certain widgets.
 8130:   // See bug 381639 for an example of why.
12732:   switch (aWidgetType) {
12732:     case NS_THEME_BUTTON:
12732:     // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
12732:     // and have a meaningful baseline, so they can't have
12732:     // author-specified padding.
12732:     case NS_THEME_CHECKBOX:
12732:     case NS_THEME_RADIO:
 8130:       aResult->SizeTo(0, 0, 0, 0);
 8130:       return PR_TRUE;
 8130:   }
    1:   return PR_FALSE;
    1: }
    1: 
  458: 
    1: PRBool
    1: nsNativeThemeCocoa::GetWidgetOverflow(nsIDeviceContext* aContext, nsIFrame* aFrame,
13812:                                       PRUint8 aWidgetType, nsRect* aOverflowRect)
    1: {
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     case NS_THEME_LISTBOX:
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:     case NS_THEME_CHECKBOX:
    1:     case NS_THEME_RADIO:
22056:     case NS_THEME_TAB:
    1:     {
    1:       // We assume that the above widgets can draw a focus ring that will be less than
    1:       // or equal to 4 pixels thick.
10038:       nsIntMargin extraSize = nsIntMargin(MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH, MAX_FOCUS_RING_WIDTH);
    1:       PRInt32 p2a = aContext->AppUnitsPerDevPixel();
    1:       nsMargin m(NSIntPixelsToAppUnits(extraSize.left, p2a),
    1:                  NSIntPixelsToAppUnits(extraSize.top, p2a),
    1:                  NSIntPixelsToAppUnits(extraSize.right, p2a),
    1:                  NSIntPixelsToAppUnits(extraSize.bottom, p2a));
13812:       aOverflowRect->Inflate(m);
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
  458: 
    1: NS_IMETHODIMP
    1: nsNativeThemeCocoa::GetMinimumWidgetSize(nsIRenderingContext* aContext,
    1:                                          nsIFrame* aFrame,
    1:                                          PRUint8 aWidgetType,
19835:                                          nsSize* aResult,
    1:                                          PRBool* aIsOverridable)
    1: {
11981:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11981: 
    1:   aResult->SizeTo(0,0);
    1:   *aIsOverridable = PR_TRUE;
    1: 
    1:   switch (aWidgetType) {
    1:     case NS_THEME_BUTTON:
    1:     {
 9641:       aResult->SizeTo(NATURAL_MINI_ROUNDED_BUTTON_MIN_WIDTH, NATURAL_MINI_ROUNDED_BUTTON_HEIGHT);
    1:       break;
    1:     }
    1: 
    1:     case NS_THEME_SPINNER:
    1:     {
 6042:       SInt32 buttonHeight = 0, buttonWidth = 0;
 6042:       ::GetThemeMetric(kThemeMetricLittleArrowsWidth, &buttonWidth);
 6042:       ::GetThemeMetric(kThemeMetricLittleArrowsHeight, &buttonHeight);
 6042:       aResult->SizeTo(buttonWidth, buttonHeight);
 6042:       *aIsOverridable = PR_FALSE;
    1:       break;
    1:     }
    1: 
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:     {
    1:       SInt32 popupHeight = 0;
    1:       ::GetThemeMetric(kThemeMetricPopupButtonHeight, &popupHeight);
    1:       aResult->SizeTo(0, popupHeight);
    1:       break;
    1:     }
    1:  
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     {
    1:       // at minimum, we should be tall enough for 9pt text.
    1:       // I'm using hardcoded values here because the appearance manager
    1:       // values for the frame size are incorrect.
    1:       aResult->SizeTo(0, (2 + 2) /* top */ + 9 + (1 + 1) /* bottom */);
    1:       break;
    1:     }
    1:       
    1:     case NS_THEME_PROGRESSBAR:
    1:     {
    1:       SInt32 barHeight = 0;
    1:       ::GetThemeMetric(kThemeMetricNormalProgressBarThickness, &barHeight);
    1:       aResult->SizeTo(0, barHeight);
    1:       break;
    1:     }
    1: 
    1:     case NS_THEME_TREEVIEW_TWISTY:
    1:     case NS_THEME_TREEVIEW_TWISTY_OPEN:   
    1:     {
    1:       SInt32 twistyHeight = 0, twistyWidth = 0;
    1:       ::GetThemeMetric(kThemeMetricDisclosureButtonWidth, &twistyWidth);
    1:       ::GetThemeMetric(kThemeMetricDisclosureButtonHeight, &twistyHeight);
    1:       aResult->SizeTo(twistyWidth, twistyHeight);
    1:       *aIsOverridable = PR_FALSE;
    1:       break;
    1:     }
    1:     
    1:     case NS_THEME_TREEVIEW_HEADER:
    1:     case NS_THEME_TREEVIEW_HEADER_CELL:
    1:     {
    1:       SInt32 headerHeight = 0;
    1:       ::GetThemeMetric(kThemeMetricListHeaderHeight, &headerHeight);
22055:       aResult->SizeTo(0, headerHeight - 1); // We don't need the top border.
    1:       break;
    1:     }
    1: 
22056:     case NS_THEME_TAB:
22056:     {
22056:       aResult->SizeTo(0, NATURAL_MINI_TAB_BUTTON_HEIGHT);
22056:       break;
22056:     }
22056: 
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     {
    1:       SInt32 scaleHeight = 0;
    1:       ::GetThemeMetric(kThemeMetricHSliderHeight, &scaleHeight);
    1:       aResult->SizeTo(scaleHeight, scaleHeight);
    1:       *aIsOverridable = PR_FALSE;
    1:       break;
    1:     }
    1: 
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     {
    1:       SInt32 scaleWidth = 0;
    1:       ::GetThemeMetric(kThemeMetricVSliderWidth, &scaleWidth);
    1:       aResult->SizeTo(scaleWidth, scaleWidth);
    1:       *aIsOverridable = PR_FALSE;
    1:       break;
    1:     }
    1:       
    1:     case NS_THEME_SCROLLBAR_SMALL:
    1:     {
    1:       SInt32 scrollbarWidth = 0;
    1:       ::GetThemeMetric(kThemeMetricSmallScrollBarWidth, &scrollbarWidth);
    1:       aResult->SizeTo(scrollbarWidth, scrollbarWidth);
    1:       *aIsOverridable = PR_FALSE;
    1:       break;
    1:     }
    1: 
  458:     // Get the rect of the thumb from HITheme, so we can return it to Gecko, which has different ideas about
  458:     // how big the thumb should be. This is kind of a hack.
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
  458:     {
  458:       // Find our parent scrollbar frame. If we can't, abort.
  458:       nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
  458:       if (!scrollbarFrame) return NS_ERROR_FAILURE;
  458: 
 1489:       nsRect scrollbarRect = scrollbarFrame->GetRect();      
 1489:       *aIsOverridable = PR_FALSE;
 1489: 
 1489:       if (scrollbarRect.IsEmpty()) {
 1489:         // just return (0,0)
 1489:         return NS_OK;
 1489:       }
 1489: 
  458:       // We need to get the device context to convert from app units :(
  458:       nsCOMPtr<nsIDeviceContext> dctx;
  458:       aContext->GetDeviceContext(*getter_AddRefs(dctx));
  458:       PRInt32 p2a = dctx->AppUnitsPerDevPixel();
  458:       CGRect macRect = CGRectMake(NSAppUnitsToIntPixels(scrollbarRect.x, p2a),
  458:                                   NSAppUnitsToIntPixels(scrollbarRect.y, p2a),
  458:                                   NSAppUnitsToIntPixels(scrollbarRect.width, p2a),
  458:                                   NSAppUnitsToIntPixels(scrollbarRect.height, p2a));
  458: 
  458:       // False here means not to get scrollbar button state information.
  458:       HIThemeTrackDrawInfo tdi;
  458:       GetScrollbarDrawInfo(tdi, scrollbarFrame, macRect, PR_FALSE);
  458: 
  458:       HIRect thumbRect;
  458:       ::HIThemeGetTrackPartBounds(&tdi, kControlIndicatorPart, &thumbRect);
  458: 
  458:       // HITheme is just lying to us, I guess...
  458:       PRInt32 thumbAdjust = ((scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
  458:                              2 : 4);
  458: 
  458:       if (aWidgetType == NS_THEME_SCROLLBAR_THUMB_VERTICAL)
  458:         aResult->SizeTo(nscoord(thumbRect.size.width), nscoord(thumbRect.size.height - thumbAdjust));
  458:       else
  458:         aResult->SizeTo(nscoord(thumbRect.size.width - thumbAdjust), nscoord(thumbRect.size.height));
  458:       break;
  458:     }
  458: 
  458:     case NS_THEME_SCROLLBAR:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     {
    1:       // yeah, i know i'm cheating a little here, but i figure that it
    1:       // really doesn't matter if the scrollbar is vertical or horizontal
    1:       // and the width metric is a really good metric for every piece
    1:       // of the scrollbar.
  458: 
  458:       nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
  458:       if (!scrollbarFrame) return NS_ERROR_FAILURE;
  458: 
  458:       PRInt32 themeMetric = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
  458:                             kThemeMetricSmallScrollBarWidth :
  458:                             kThemeMetricScrollBarWidth;
    1:       SInt32 scrollbarWidth = 0;
  458:       ::GetThemeMetric(themeMetric, &scrollbarWidth);
    1:       aResult->SizeTo(scrollbarWidth, scrollbarWidth);
    1:       *aIsOverridable = PR_FALSE;
    1:       break;
    1:     }
  458: 
  458:     case NS_THEME_SCROLLBAR_BUTTON_UP:
  458:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
  458:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
  458:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
  458:     {
  458:       nsIFrame *scrollbarFrame = GetParentScrollbarFrame(aFrame);
  458:       if (!scrollbarFrame) return NS_ERROR_FAILURE;
  458: 
  458:       // Since there is no NS_THEME_SCROLLBAR_BUTTON_UP_SMALL we need to ask the parent what appearance style it has.
  458:       PRInt32 themeMetric = (scrollbarFrame->GetStyleDisplay()->mAppearance == NS_THEME_SCROLLBAR_SMALL) ?
  458:                             kThemeMetricSmallScrollBarWidth :
  458:                             kThemeMetricScrollBarWidth;
  458:       SInt32 scrollbarWidth = 0;
  458:       ::GetThemeMetric(themeMetric, &scrollbarWidth);
  458: 
  458:       // It seems that for both sizes of scrollbar, the buttons are one pixel "longer".
  458:       if (aWidgetType == NS_THEME_SCROLLBAR_BUTTON_LEFT || aWidgetType == NS_THEME_SCROLLBAR_BUTTON_RIGHT)
  458:         aResult->SizeTo(scrollbarWidth+1, scrollbarWidth);
  458:       else
  458:         aResult->SizeTo(scrollbarWidth, scrollbarWidth+1);
  458:  
  458:       *aIsOverridable = PR_FALSE;
  458:       break;
  458:     }
    1:   }
    1: 
    1:   return NS_OK;
11981: 
11981:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeCocoa::WidgetStateChanged(nsIFrame* aFrame, PRUint8 aWidgetType, 
    1:                                      nsIAtom* aAttribute, PRBool* aShouldRepaint)
    1: {
    1:   // Some widget types just never change state.
    1:   switch (aWidgetType) {
    1:     case NS_THEME_TOOLBOX:
    1:     case NS_THEME_TOOLBAR:
19295:     case NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR:
    1:     case NS_THEME_TOOLBAR_BUTTON:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL: 
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_STATUSBAR_PANEL:
    1:     case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     case NS_THEME_TOOLTIP:
    1:     case NS_THEME_TAB_PANELS:
    1:     case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_DIALOG:
    1:     case NS_THEME_MENUPOPUP:
13030:     case NS_THEME_GROUPBOX:
    1:       *aShouldRepaint = PR_FALSE;
    1:       return NS_OK;
14006:     case NS_THEME_PROGRESSBAR_CHUNK:
14006:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
14006:     case NS_THEME_PROGRESSBAR:
14006:     case NS_THEME_PROGRESSBAR_VERTICAL:
14006:       *aShouldRepaint = (aAttribute == nsWidgetAtoms::step);
14006:       return NS_OK;
    1:   }
    1: 
    1:   // XXXdwh Not sure what can really be done here.  Can at least guess for
    1:   // specific widgets that they're highly unlikely to have certain states.
    1:   // For example, a toolbar doesn't care about any states.
    1:   if (!aAttribute) {
    1:     // Hover/focus/active changed.  Always repaint.
    1:     *aShouldRepaint = PR_TRUE;
    1:   } else {
    1:     // Check the attribute to see if it's relevant.  
    1:     // disabled, checked, dlgtype, default, etc.
    1:     *aShouldRepaint = PR_FALSE;
    1:     if (aAttribute == nsWidgetAtoms::disabled ||
    1:         aAttribute == nsWidgetAtoms::checked ||
    1:         aAttribute == nsWidgetAtoms::selected ||
    1:         aAttribute == nsWidgetAtoms::mozmenuactive ||
 1734:         aAttribute == nsWidgetAtoms::sortdirection ||
10241:         aAttribute == nsWidgetAtoms::focused ||
 1734:         aAttribute == nsWidgetAtoms::_default)
    1:       *aShouldRepaint = PR_TRUE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeCocoa::ThemeChanged()
    1: {
    1:   // This is unimplemented because we don't care if gecko changes its theme
    1:   // and Mac OS X doesn't have themes.
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool 
    1: nsNativeThemeCocoa::ThemeSupportsWidget(nsPresContext* aPresContext, nsIFrame* aFrame,
    1:                                       PRUint8 aWidgetType)
    1: {
21616:   // We don't have CSS set up to render non-native scrollbars on Mac OS X so we
21616:   // render natively even if native theme support is disabled.
21616:   if (aWidgetType != NS_THEME_SCROLLBAR &&
21616:       aPresContext && !aPresContext->PresShell()->IsThemeSupportEnabled())
    1:     return PR_FALSE;
    1: 
 5361:   // if this is a dropdown button in a combobox the answer is always no
 5361:   if (aWidgetType == NS_THEME_DROPDOWN_BUTTON) {
 5361:     nsIFrame* parentFrame = aFrame->GetParent();
 5361:     if (parentFrame && (parentFrame->GetType() == nsWidgetAtoms::comboboxControlFrame))
 5361:       return PR_FALSE;
 5361:   }
    1: 
    1:   switch (aWidgetType) {
 5361:     case NS_THEME_LISTBOX:
 5361: 
    1:     case NS_THEME_DIALOG:
    1:     case NS_THEME_WINDOW:
    1:     case NS_THEME_MENUPOPUP:
    1:     case NS_THEME_MENUITEM:
12179:     case NS_THEME_MENUSEPARATOR:
    1:     case NS_THEME_TOOLTIP:
    1:     
    1:     case NS_THEME_CHECKBOX:
    1:     case NS_THEME_CHECKBOX_CONTAINER:
    1:     case NS_THEME_RADIO:
    1:     case NS_THEME_RADIO_CONTAINER:
13030:     case NS_THEME_GROUPBOX:
    1:     case NS_THEME_BUTTON:
    1:     case NS_THEME_BUTTON_BEVEL:
    1:     case NS_THEME_SPINNER:
    1:     case NS_THEME_TOOLBAR:
19295:     case NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR:
    1:     case NS_THEME_STATUSBAR:
    1:     case NS_THEME_TEXTFIELD:
 1191:     case NS_THEME_TEXTFIELD_MULTILINE:
    1:     //case NS_THEME_TOOLBOX:
    1:     //case NS_THEME_TOOLBAR_BUTTON:
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     case NS_THEME_TOOLBAR_SEPARATOR:
    1:     
    1:     case NS_THEME_TAB_PANELS:
    1:     case NS_THEME_TAB:
    1:     
    1:     case NS_THEME_TREEVIEW_TWISTY:
    1:     case NS_THEME_TREEVIEW_TWISTY_OPEN:
    1:     case NS_THEME_TREEVIEW:
    1:     case NS_THEME_TREEVIEW_HEADER:
    1:     case NS_THEME_TREEVIEW_HEADER_CELL:
    1:     case NS_THEME_TREEVIEW_HEADER_SORTARROW:
    1:     case NS_THEME_TREEVIEW_TREEITEM:
    1:     case NS_THEME_TREEVIEW_LINE:
    1: 
    1:     case NS_THEME_SCALE_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_VERTICAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1: 
    1:     case NS_THEME_SCROLLBAR:
    1:     case NS_THEME_SCROLLBAR_SMALL:
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1: 
    1:     case NS_THEME_DROPDOWN:
    1:     case NS_THEME_DROPDOWN_BUTTON:
    1:     case NS_THEME_DROPDOWN_TEXT:
 5361:       return !IsWidgetStyled(aPresContext, aFrame, aWidgetType);
 5361:       break;
    1:   }
    1: 
 5361:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsNativeThemeCocoa::WidgetIsContainer(PRUint8 aWidgetType)
    1: {
    1:   // flesh this out at some point
    1:   switch (aWidgetType) {
    1:    case NS_THEME_DROPDOWN_BUTTON:
    1:    case NS_THEME_RADIO:
    1:    case NS_THEME_CHECKBOX:
    1:    case NS_THEME_PROGRESSBAR:
    1:     return PR_FALSE;
    1:     break;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsNativeThemeCocoa::ThemeDrawsFocusForWidget(nsPresContext* aPresContext, nsIFrame* aFrame, PRUint8 aWidgetType)
    1: {
    1:   if (aWidgetType == NS_THEME_DROPDOWN ||
10241:       aWidgetType == NS_THEME_BUTTON ||
10241:       aWidgetType == NS_THEME_RADIO ||
21220:       aWidgetType == NS_THEME_CHECKBOX)
    1:     return PR_TRUE;
    1: 
    1:   return PR_FALSE;
    1: }
 1582: 
 1582: PRBool
 1582: nsNativeThemeCocoa::ThemeNeedsComboboxDropmarker()
 1582: {
 1582:   return PR_FALSE;
 1582: }
