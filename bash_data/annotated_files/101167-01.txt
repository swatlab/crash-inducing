 59931: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 59931:  * vim: set ts=4 sw=4 et tw=99:
 59931:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 59931: 
 89265: #include "mozilla/GuardObjects.h"
 91311: #include "mozilla/StandardInteger.h"
 89265: 
 59931: #include "jscntxt.h"
 67915: #include "jscompartment.h"
 59931: #include "jsfriendapi.h"
 79734: #include "jswrapper.h"
 82724: #include "jsweakmap.h"
 88447: #include "jswatchpoint.h"
 59931: 
 91659: #include "builtin/TestingFunctions.h"
 91659: 
 77343: #include "jsobjinlines.h"
 77343: 
 67915: using namespace js;
 78158: using namespace JS;
 67915: 
 80159: JS_FRIEND_API(void)
 80159: JS_SetGrayGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data)
 80159: {
 80159:     rt->gcGrayRootsTraceOp = traceOp;
 80159:     rt->gcGrayRootsData = data;
 80159: }
 80159: 
 59931: JS_FRIEND_API(JSString *)
 59931: JS_GetAnonymousString(JSRuntime *rt)
 59931: {
 87611:     JS_ASSERT(rt->hasContexts());
 64345:     return rt->atomState.anonymousAtom;
 59931: }
 67915: 
 67915: JS_FRIEND_API(JSObject *)
 98960: JS_FindCompilationScope(JSContext *cx, JSObject *obj_)
 67915: {
 99421:     RootedObject obj(cx, obj_);
 98960: 
 67915:     /*
 67915:      * We unwrap wrappers here. This is a little weird, but it's what's being
 67915:      * asked of us.
 67915:      */
 67915:     if (obj->isWrapper())
 79734:         obj = UnwrapObject(obj);
 67915: 
 67915:     /*
 67915:      * Innerize the target_obj so that we compile in the correct (inner)
 67915:      * scope.
 67915:      */
 67915:     if (JSObjectOp op = obj->getClass()->ext.innerObject)
 67915:         obj = op(cx, obj);
 67915:     return obj;
 67915: }
 67915: 
 79734: JS_FRIEND_API(JSFunction *)
 79734: JS_GetObjectFunction(JSObject *obj)
 67915: {
 79734:     if (obj->isFunction())
 83234:         return obj->toFunction();
 79734:     return NULL;
 67915: }
 69223: 
 69223: JS_FRIEND_API(JSObject *)
 80154: JS_GetGlobalForFrame(JSStackFrame *fp)
 69223: {
 96793:     return &Valueify(fp)->global();
 69223: }
 74914: 
 77353: JS_FRIEND_API(JSBool)
 77343: JS_SplicePrototype(JSContext *cx, JSObject *obj, JSObject *proto)
 77343: {
 77343:     /*
 77343:      * Change the prototype of an object which hasn't been used anywhere
 77343:      * and does not share its type with another object. Unlike JS_SetPrototype,
 77343:      * does not nuke type information for the object.
 77343:      */
 77343:     CHECK_REQUEST(cx);
 78454: 
 78454:     if (!obj->hasSingletonType()) {
 78454:         /*
 78454:          * We can see non-singleton objects when trying to splice prototypes
 78454:          * due to mutable __proto__ (ugh).
 78454:          */
 78454:         return JS_SetPrototype(cx, obj, proto);
 78454:     }
 78454: 
 77353:     return obj->splicePrototype(cx, proto);
 77343: }
 77343: 
 77343: JS_FRIEND_API(JSObject *)
 77343: JS_NewObjectWithUniqueType(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent)
 77343: {
 77343:     JSObject *obj = JS_NewObject(cx, clasp, proto, parent);
 77353:     if (!obj || !obj->setSingletonType(cx))
 77343:         return NULL;
 77343:     return obj;
 77343: }
 77343: 
 86375: JS_FRIEND_API(void)
 94871: js::PrepareCompartmentForGC(JSCompartment *comp)
 82884: {
 94871:     comp->scheduleGC();
 88182: }
 88182: 
 88182: JS_FRIEND_API(void)
 94871: js::PrepareForFullGC(JSRuntime *rt)
 89284: {
 94871:     for (CompartmentsIter c(rt); !c.done(); c.next())
 94871:         c->scheduleGC();
 94871: }
 89284: 
 97770: JS_FRIEND_API(bool)
 97770: js::IsGCScheduled(JSRuntime *rt)
 97770: {
 97770:     for (CompartmentsIter c(rt); !c.done(); c.next()) {
 97770:         if (c->isGCScheduled())
 97770:             return true;
 97770:     }
 97770: 
 97770:     return false;
 97770: }
 97770: 
 94871: JS_FRIEND_API(void)
 98111: js::SkipCompartmentForGC(JSCompartment *comp)
 98111: {
 98111:     comp->unscheduleGC();
 98111: }
 98111: 
 98111: JS_FRIEND_API(void)
 94960: js::GCForReason(JSRuntime *rt, gcreason::Reason reason)
 94871: {
 94960:     GC(rt, GC_NORMAL, reason);
 89284: }
 89284: 
 89284: JS_FRIEND_API(void)
 94960: js::ShrinkingGC(JSRuntime *rt, gcreason::Reason reason)
 88182: {
 94960:     GC(rt, GC_SHRINK, reason);
 90410: }
 90410: 
 90410: JS_FRIEND_API(void)
 94960: js::IncrementalGC(JSRuntime *rt, gcreason::Reason reason)
 90410: {
 94960:     GCSlice(rt, GC_NORMAL, reason);
 82884: }
 82884: 
 86375: JS_FRIEND_API(void)
 86375: JS_ShrinkGCBuffers(JSRuntime *rt)
 86375: {
 86375:     ShrinkGCBuffers(rt);
 86375: }
 86375: 
 78158: JS_FRIEND_API(JSPrincipals *)
 78158: JS_GetCompartmentPrincipals(JSCompartment *compartment)
 78158: {
 78158:     return compartment->principals;
 78158: }
 78158: 
 78158: JS_FRIEND_API(JSBool)
 78158: JS_WrapPropertyDescriptor(JSContext *cx, js::PropertyDescriptor *desc)
 78158: {
 78158:     return cx->compartment->wrap(cx, desc);
 78158: }
 78158: 
101167: JS_FRIEND_API(JSBool)
101167: JS_WrapAutoIdVector(JSContext *cx, js::AutoIdVector &props)
101167: {
101167:     return cx->compartment->wrap(cx, props);
101167: }
101167: 
 85055: JS_FRIEND_API(void)
 85055: JS_TraceShapeCycleCollectorChildren(JSTracer *trc, void *shape)
 84173: {
 90419:     MarkCycleCollectorChildren(trc, (Shape *)shape);
 84173: }
 84173: 
 91659: static bool
 97353: DefineHelpProperty(JSContext *cx, HandleObject obj, const char *prop, const char *value)
 91659: {
 91659:     JSAtom *atom = js_Atomize(cx, value, strlen(value));
 91659:     if (!atom)
 91659:         return false;
 91659:     jsval v = STRING_TO_JSVAL(atom);
 91659:     return JS_DefineProperty(cx, obj, prop, v,
 91659:                              JS_PropertyStub, JS_StrictPropertyStub,
 91659:                              JSPROP_READONLY | JSPROP_PERMANENT);
 91659: }
 91659: 
 91659: JS_FRIEND_API(bool)
 99364: JS_DefineFunctionsWithHelp(JSContext *cx, JSObject *obj_, const JSFunctionSpecWithHelp *fs)
 91659: {
 99421:     RootedObject obj(cx, obj_);
 91659: 
 91659:     JS_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 91659: 
 91659:     CHECK_REQUEST(cx);
 91659:     assertSameCompartment(cx, obj);
 91659:     for (; fs->name; fs++) {
 91659:         JSAtom *atom = js_Atomize(cx, fs->name, strlen(fs->name));
 91659:         if (!atom)
 91659:             return false;
 91659: 
 99421:         RootedFunction fun(cx);
 99421:         fun = js_DefineFunction(cx, obj, RootedId(cx, AtomToId(atom)),
 97828:                                 fs->call, fs->nargs, fs->flags);
 91659:         if (!fun)
 91659:             return false;
 91659: 
 91659:         if (fs->usage) {
 91659:             if (!DefineHelpProperty(cx, fun, "usage", fs->usage))
 91659:                 return false;
 91659:         }
 91659: 
 91659:         if (fs->help) {
 91659:             if (!DefineHelpProperty(cx, fun, "help", fs->help))
 91659:                 return false;
 91659:         }
 91659:     }
 91659: 
 91659:     return true;
 91659: }
 91659: 
 78158: AutoSwitchCompartment::AutoSwitchCompartment(JSContext *cx, JSCompartment *newCompartment
 78158:                                              JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 78158:   : cx(cx), oldCompartment(cx->compartment)
 78158: {
 78158:     JS_GUARD_OBJECT_NOTIFIER_INIT;
 78158:     cx->setCompartment(newCompartment);
 78158: }
 78158: 
 78158: AutoSwitchCompartment::AutoSwitchCompartment(JSContext *cx, JSObject *target
 78158:                                              JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 78158:   : cx(cx), oldCompartment(cx->compartment)
 78158: {
 78158:     JS_GUARD_OBJECT_NOTIFIER_INIT;
 78158:     cx->setCompartment(target->compartment());
 78158: }
 78158: 
 78158: AutoSwitchCompartment::~AutoSwitchCompartment()
 78158: {
 78158:     /* The old compartment may have been destroyed, so we can't use cx->setCompartment. */
 78158:     cx->compartment = oldCompartment;
 78158: }
 78158: 
 83278: JS_FRIEND_API(bool)
 86105: js::IsSystemCompartment(const JSCompartment *c)
 86105: {
 86105:     return c->isSystemCompartment;
 86105: }
 86105: 
 86105: JS_FRIEND_API(bool)
 91250: js::IsAtomsCompartment(const JSCompartment *c)
 86986: {
 91250:     return c == c->rt->atomsCompartment;
 86986: }
 86986: 
 86986: JS_FRIEND_API(bool)
 86483: js::IsScopeObject(JSObject *obj)
 82095: {
 86483:     return obj->isScope();
 80213: }
 80213: 
 83239: JS_FRIEND_API(JSObject *)
 86483: js::GetObjectParentMaybeScope(JSObject *obj)
 80213: {
 86483:     return obj->enclosingScope();
 83239: }
 83239: 
 83293: JS_FRIEND_API(JSObject *)
 83293: js::GetGlobalForObjectCrossCompartment(JSObject *obj)
 83293: {
 86483:     return &obj->global();
 83293: }
 83293: 
 98147: JS_FRIEND_API(void)
 98147: js::NotifyAnimationActivity(JSObject *obj)
 98147: {
 98147:     obj->compartment()->lastAnimationTime = PRMJ_Now();
 98147: }
 98147: 
 84755: JS_FRIEND_API(uint32_t)
 86483: js::GetObjectSlotSpan(JSObject *obj)
 83252: {
 83252:     return obj->slotSpan();
 83252: }
 80213: 
 83256: JS_FRIEND_API(bool)
 86111: js::IsObjectInContextCompartment(const JSObject *obj, const JSContext *cx)
 86111: {
 86111:     return obj->compartment() == cx->compartment;
 86111: }
 86111: 
 86111: JS_FRIEND_API(bool)
 83256: js::IsOriginalScriptFunction(JSFunction *fun)
 83256: {
 83256:     return fun->script()->function() == fun;
 83256: }
 83256: 
 83262: JS_FRIEND_API(JSFunction *)
 99364: js::DefineFunctionWithReserved(JSContext *cx, JSObject *obj_, const char *name, JSNative call,
 91237:                                unsigned nargs, unsigned attrs)
 83262: {
 99421:     RootedObject obj(cx, obj_);
 86437: 
 83262:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 83262:     CHECK_REQUEST(cx);
 83262:     assertSameCompartment(cx, obj);
 83262:     JSAtom *atom = js_Atomize(cx, name, strlen(name));
 83262:     if (!atom)
 83262:         return NULL;
 99421:     return js_DefineFunction(cx, obj, RootedId(cx, AtomToId(atom)),
 97828:                              call, nargs, attrs,
 83262:                              JSFunction::ExtendedFinalizeKind);
 83262: }
 83262: 
 83262: JS_FRIEND_API(JSFunction *)
 91237: js::NewFunctionWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
 99364:                             JSObject *parent_, const char *name)
 83268: {
 99421:     RootedObject parent(cx, parent_);
 86437: 
 83268:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 83268:     JSAtom *atom;
 83268: 
 83268:     CHECK_REQUEST(cx);
 83268:     assertSameCompartment(cx, parent);
 83268: 
 83268:     if (!name) {
 83268:         atom = NULL;
 83268:     } else {
 83268:         atom = js_Atomize(cx, name, strlen(name));
 83268:         if (!atom)
 83268:             return NULL;
 83268:     }
 83268: 
 99364:     return js_NewFunction(cx, NULL, native, nargs, flags, parent, atom,
 83268:                           JSFunction::ExtendedFinalizeKind);
 83268: }
 83268: 
 83268: JS_FRIEND_API(JSFunction *)
 99364: js::NewFunctionByIdWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags, JSObject *parent_,
 83262:                                 jsid id)
 83262: {
 99421:     RootedObject parent(cx, parent_);
 86437: 
 83262:     JS_ASSERT(JSID_IS_STRING(id));
 83262:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 83262:     CHECK_REQUEST(cx);
 83262:     assertSameCompartment(cx, parent);
 83262: 
 99364:     return js_NewFunction(cx, NULL, native, nargs, flags, parent, JSID_TO_ATOM(id),
 83262:                           JSFunction::ExtendedFinalizeKind);
 83262: }
 83262: 
 83262: JS_FRIEND_API(JSObject *)
 99364: js::InitClassWithReserved(JSContext *cx, JSObject *obj_, JSObject *parent_proto,
 91237:                           JSClass *clasp, JSNative constructor, unsigned nargs,
 83262:                           JSPropertySpec *ps, JSFunctionSpec *fs,
 83262:                           JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
 83262: {
 99421:     RootedObject obj(cx, obj_);
 99364: 
 83262:     CHECK_REQUEST(cx);
 83262:     assertSameCompartment(cx, obj, parent_proto);
 99364:     return js_InitClass(cx, obj, parent_proto, Valueify(clasp), constructor,
 83262:                         nargs, ps, fs, static_ps, static_fs, NULL,
 83262:                         JSFunction::ExtendedFinalizeKind);
 83262: }
 83262: 
 83258: JS_FRIEND_API(const Value &)
 83258: js::GetFunctionNativeReserved(JSObject *fun, size_t which)
 83258: {
 83301:     JS_ASSERT(fun->toFunction()->isNative());
 83301:     return fun->toFunction()->getExtendedSlot(which);
 80062: }
 80062: 
 80062: JS_FRIEND_API(void)
 83258: js::SetFunctionNativeReserved(JSObject *fun, size_t which, const Value &val)
 80062: {
 83301:     JS_ASSERT(fun->toFunction()->isNative());
 83301:     fun->toFunction()->setExtendedSlot(which, val);
 79734: }
 79734: 
 87982: JS_FRIEND_API(void)
 87982: js::SetReservedSlotWithBarrier(JSObject *obj, size_t slot, const js::Value &value)
 87982: {
 87982:     obj->setSlot(slot, value);
 87982: }
 87982: 
 84729: void
 84729: js::SetPreserveWrapperCallback(JSRuntime *rt, PreserveWrapperCallback callback)
 84729: {
 84729:     rt->preserveWrapperCallback = callback;
 84729: }
 84729: 
 74914: /*
 74914:  * The below code is for temporary telemetry use. It can be removed when
 74914:  * sufficient data has been harvested.
 74914:  */
 74914: 
 74914: extern size_t sE4XObjectsCreated;
 74914: 
 74914: JS_FRIEND_API(size_t)
 74914: JS_GetE4XObjectsCreated(JSContext *)
 74914: {
 74914:     return sE4XObjectsCreated;
 74914: }
 74914: 
 74914: extern size_t sSetProtoCalled;
 74914: 
 74914: JS_FRIEND_API(size_t)
 74914: JS_SetProtoCalled(JSContext *)
 74914: {
 74914:     return sSetProtoCalled;
 74914: }
 74914: 
 74914: extern size_t sCustomIteratorCount;
 74914: 
 74914: JS_FRIEND_API(size_t)
 74914: JS_GetCustomIteratorCount(JSContext *cx)
 74914: {
 74914:     return sCustomIteratorCount;
 74914: }
 80213: 
 82724: void
 82724: js::TraceWeakMaps(WeakMapTracer *trc)
 82724: {
 82724:     WeakMapBase::traceAllMappings(trc);
 88447:     WatchpointMap::traceAll(trc);
 82724: }
 82724: 
 89501: JS_FRIEND_API(bool)
 89501: js::GCThingIsMarkedGray(void *thing)
 89501: {
 89501:     JS_ASSERT(thing);
 89501:     return reinterpret_cast<gc::Cell *>(thing)->isMarked(gc::GRAY);
 89501: }
 89501: 
 80213: JS_FRIEND_API(void)
 80213: JS_SetAccumulateTelemetryCallback(JSRuntime *rt, JSAccumulateTelemetryDataCallback callback)
 80213: {
 80213:     rt->telemetryCallback = callback;
 80213: }
 80670: 
 80670: #ifdef DEBUG
 89265: JS_FRIEND_API(void)
 89265: js_DumpString(JSString *str)
 89265: {
 89265:     str->dump();
 89265: }
 89265: 
 89265: JS_FRIEND_API(void)
 89265: js_DumpAtom(JSAtom *atom)
 89265: {
 89265:     atom->dump();
 89265: }
 89265: 
 89265: extern void
 89265: DumpChars(const jschar *s, size_t n)
 89265: {
 89265:     if (n == SIZE_MAX) {
 89265:         n = 0;
 89265:         while (s[n])
 89265:             n++;
 89265:     }
 89265: 
 89265:     fputc('"', stderr);
 89265:     for (size_t i = 0; i < n; i++) {
 89265:         if (s[i] == '\n')
 89265:             fprintf(stderr, "\\n");
 89265:         else if (s[i] == '\t')
 89265:             fprintf(stderr, "\\t");
 89265:         else if (s[i] >= 32 && s[i] < 127)
 89265:             fputc(s[i], stderr);
 89265:         else if (s[i] <= 255)
 89265:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
 89265:         else
 89265:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
 89265:     }
 89265:     fputc('"', stderr);
 89265: }
 89265: 
 89265: JS_FRIEND_API(void)
 89265: js_DumpChars(const jschar *s, size_t n)
 89265: {
 89265:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
 89265:     DumpChars(s, n);
 89265:     fputc('\n', stderr);
 89265: }
 89265: 
 89265: JS_FRIEND_API(void)
 89265: js_DumpObject(JSObject *obj)
 89265: {
 89265:     obj->dump();
 89265: }
 80670: 
 80670: struct DumpingChildInfo {
 80670:     void *node;
 80670:     JSGCTraceKind kind;
 80670: 
 80670:     DumpingChildInfo (void *n, JSGCTraceKind k)
 80670:         : node(n), kind(k)
 80670:     {}
 80670: };
 80670: 
 91339: typedef HashSet<void *, DefaultHasher<void *>, SystemAllocPolicy> PtrSet;
 80670: 
 80670: struct JSDumpHeapTracer : public JSTracer {
 80670:     PtrSet visited;
 80670:     FILE   *output;
 91339:     Vector<DumpingChildInfo, 0, SystemAllocPolicy> nodes;
 80670:     char   buffer[200];
 80670:     bool   rootTracing;
 80670: 
 91339:     JSDumpHeapTracer(FILE *fp)
 91339:       : output(fp)
 80670:     {}
 80670: };
 80670: 
 80670: static void
 90232: DumpHeapVisitChild(JSTracer *trc, void **thingp, JSGCTraceKind kind);
 80670: 
 91317: static char
 91317: MarkDescriptor(void *thing)
 91317: {
 91317:     gc::Cell *cell = static_cast<gc::Cell*>(thing);
 91317:     if (cell->isMarked(gc::BLACK))
 91317:         return cell->isMarked(gc::GRAY) ? 'G' : 'B';
 91317:     else
 91317:         return cell->isMarked(gc::GRAY) ? 'X' : 'W';
 91317: }
 91317: 
 80670: static void
 90232: DumpHeapPushIfNew(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 80670: {
 80670:     JS_ASSERT(trc->callback == DumpHeapPushIfNew ||
 80670:               trc->callback == DumpHeapVisitChild);
 90232:     void *thing = *thingp;
 80670:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(trc);
 80670: 
 80670:     /*
 80670:      * If we're tracing roots, print root information.  Do this even if we've
 80670:      * already seen thing, for complete root information.
 80670:      */
 80670:     if (dtrc->rootTracing) {
 91317:         fprintf(dtrc->output, "%p %c %s\n", thing, MarkDescriptor(thing),
 80670:                 JS_GetTraceEdgeName(dtrc, dtrc->buffer, sizeof(dtrc->buffer)));
 80670:     }
 80670: 
 80670:     PtrSet::AddPtr ptrEntry = dtrc->visited.lookupForAdd(thing);
 80670:     if (ptrEntry || !dtrc->visited.add(ptrEntry, thing))
 80670:         return;
 80670: 
 80670:     dtrc->nodes.append(DumpingChildInfo(thing, kind));
 80670: }
 80670: 
 80670: static void
 90232: DumpHeapVisitChild(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 80670: {
 80670:     JS_ASSERT(trc->callback == DumpHeapVisitChild);
 80670:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(trc);
 80670:     const char *edgeName = JS_GetTraceEdgeName(dtrc, dtrc->buffer, sizeof(dtrc->buffer));
 91317:     fprintf(dtrc->output, "> %p %c %s\n", *thingp, MarkDescriptor(*thingp), edgeName);
 90232:     DumpHeapPushIfNew(dtrc, thingp, kind);
 80670: }
 80670: 
 80670: void
 91339: js::DumpHeapComplete(JSRuntime *rt, FILE *fp)
 80670: {
 91339:     JSDumpHeapTracer dtrc(fp);
 91339:     JS_TracerInit(&dtrc, rt, DumpHeapPushIfNew);
 80670:     if (!dtrc.visited.init(10000))
 80670:         return;
 80670: 
 80670:     /* Store and log the root information. */
 80670:     dtrc.rootTracing = true;
 80670:     TraceRuntime(&dtrc);
 80670:     fprintf(dtrc.output, "==========\n");
 80670: 
 80670:     /* Log the graph. */
 80670:     dtrc.rootTracing = false;
 80670:     dtrc.callback = DumpHeapVisitChild;
 80670: 
 80670:     while (!dtrc.nodes.empty()) {
 80670:         DumpingChildInfo dci = dtrc.nodes.popCopy();
 80670:         JS_PrintTraceThingInfo(dtrc.buffer, sizeof(dtrc.buffer),
 80670:                                &dtrc, dci.node, dci.kind, JS_TRUE);
 91317:         fprintf(fp, "%p %c %s\n", dci.node, MarkDescriptor(dci.node), dtrc.buffer);
 80670:         JS_TraceChildren(&dtrc, dci.node, dci.kind);
 80670:     }
 80670: 
 80670:     dtrc.visited.finish();
 90876:     fflush(dtrc.output);
 80670: }
 80670: 
 80670: #endif
 86984: 
 86984: namespace js {
 86984: 
 87277: JS_FRIEND_API(const JSStructuredCloneCallbacks *)
 87277: GetContextStructuredCloneCallbacks(JSContext *cx)
 87277: {
 87277:     return cx->runtime->structuredCloneCallbacks;
 87277: }
 87277: 
 87278: JS_FRIEND_API(JSVersion)
 99820: VersionSetMoarXML(JSVersion version, bool enable)
 87278: {
 99820:     return enable ? JSVersion(uint32_t(version) | VersionFlags::MOAR_XML)
 99820:                   : JSVersion(uint32_t(version) & ~VersionFlags::MOAR_XML);
 87278: }
 87278: 
 87279: JS_FRIEND_API(bool)
 87279: CanCallContextDebugHandler(JSContext *cx)
 87279: {
 91178:     return !!cx->runtime->debugHooks.debuggerHandler;
 87279: }
 87279: 
 87279: JS_FRIEND_API(JSTrapStatus)
 87279: CallContextDebugHandler(JSContext *cx, JSScript *script, jsbytecode *bc, Value *rval)
 87279: {
 91178:     if (!cx->runtime->debugHooks.debuggerHandler)
 87279:         return JSTRAP_RETURN;
 87279: 
 91178:     return cx->runtime->debugHooks.debuggerHandler(cx, script, bc, rval,
 91178:                                                    cx->runtime->debugHooks.debuggerHandlerData);
 87279: }
 87279: 
 86984: #ifdef JS_THREADSAFE
 88135: void *
 88135: GetOwnerThread(const JSContext *cx)
 86984: {
 88135:     return cx->runtime->ownerThread();
 86984: }
 87282: 
 87282: JS_FRIEND_API(unsigned)
 87282: GetContextOutstandingRequests(const JSContext *cx)
 87282: {
 87282:     return cx->outstandingRequests;
 87282: }
 86984: #endif
 86984: 
 87284: JS_FRIEND_API(JSCompartment *)
 87284: GetContextCompartment(const JSContext *cx)
 87284: {
 87284:     return cx->compartment;
 87284: }
 87284: 
 87285: JS_FRIEND_API(bool)
 87285: HasUnrootedGlobal(const JSContext *cx)
 87285: {
 87285:     return cx->hasRunOption(JSOPTION_UNROOTED_GLOBAL);
 87285: }
 87285: 
 87286: JS_FRIEND_API(void)
 87286: SetActivityCallback(JSRuntime *rt, ActivityCallback cb, void *arg)
 87286: {
 87286:     rt->activityCallback = cb;
 87286:     rt->activityCallbackArg = arg;
 87286: }
 87291: 
 87291: JS_FRIEND_API(bool)
 87291: IsContextRunningJS(JSContext *cx)
 87291: {
 87291:     return !cx->stack.empty();
 87291: }
 87291: 
 87293: JS_FRIEND_API(const CompartmentVector&)
 87293: GetRuntimeCompartments(JSRuntime *rt)
 87293: {
 87293:     return rt->compartments;
 87293: }
 87293: 
 87298: JS_FRIEND_API(size_t)
 87298: SizeOfJSContext()
 87298: {
 87298:     return sizeof(JSContext);
 87298: }
 87298: 
 90410: JS_FRIEND_API(GCSliceCallback)
 90410: SetGCSliceCallback(JSRuntime *rt, GCSliceCallback callback)
 90410: {
 90410:     GCSliceCallback old = rt->gcSliceCallback;
 90410:     rt->gcSliceCallback = callback;
 90410:     return old;
 90410: }
 90410: 
 92707: jschar *
 92707: GCDescription::formatMessage(JSRuntime *rt) const
 92707: {
 92707:     return rt->gcStats.formatMessage();
 92707: }
 92707: 
 92707: jschar *
 93384: GCDescription::formatJSON(JSRuntime *rt, uint64_t timestamp) const
 92707: {
 93384:     return rt->gcStats.formatJSON(timestamp);
 92707: }
 92707: 
 94960: JS_FRIEND_API(void)
 94960: NotifyDidPaint(JSRuntime *rt)
 90410: {
 90410:     if (rt->gcZeal() == gc::ZealFrameVerifierValue) {
 94959:         gc::VerifyBarriers(rt);
 90410:         return;
 90410:     }
 90410: 
 90410:     if (rt->gcZeal() == gc::ZealFrameGCValue) {
 94869:         PrepareForFullGC(rt);
 94960:         GCSlice(rt, GC_NORMAL, gcreason::REFRESH_FRAME);
 90410:         return;
 90410:     }
 90410: 
 94620:     if (rt->gcIncrementalState != gc::NO_INCREMENTAL && !rt->gcInterFrameGC) {
 94620:         for (CompartmentsIter c(rt); !c.done(); c.next()) {
 94620:             if (c->needsBarrier())
 94620:                 PrepareCompartmentForGC(c);
 94620:         }
 94960:         GCSlice(rt, GC_NORMAL, gcreason::REFRESH_FRAME);
 94620:     }
 90410: 
 90410:     rt->gcInterFrameGC = false;
 90410: }
 90410: 
 90410: extern JS_FRIEND_API(bool)
 90410: IsIncrementalGCEnabled(JSRuntime *rt)
 90410: {
 98153:     return rt->gcIncrementalEnabled && rt->gcMode == JSGC_MODE_INCREMENTAL;
 90410: }
 90410: 
 91205: extern JS_FRIEND_API(void)
 91205: DisableIncrementalGC(JSRuntime *rt)
 91205: {
 91205:     rt->gcIncrementalEnabled = false;
 91205: }
 91205: 
 90410: JS_FRIEND_API(bool)
 90410: IsIncrementalBarrierNeeded(JSRuntime *rt)
 90410: {
 90410:     return (rt->gcIncrementalState == gc::MARK && !rt->gcRunning);
 90410: }
 90410: 
 90410: JS_FRIEND_API(bool)
 90410: IsIncrementalBarrierNeeded(JSContext *cx)
 90410: {
 90410:     return IsIncrementalBarrierNeeded(cx->runtime);
 90410: }
 90410: 
 90410: JS_FRIEND_API(bool)
 90410: IsIncrementalBarrierNeededOnObject(JSObject *obj)
 90410: {
 90410:     return obj->compartment()->needsBarrier();
 90410: }
 90410: 
 97587: JS_FRIEND_API(bool)
 97587: IsIncrementalBarrierNeededOnScript(JSScript *script)
 97587: {
 97587:     return script->compartment()->needsBarrier();
 97587: }
 97587: 
 90410: extern JS_FRIEND_API(void)
 90410: IncrementalReferenceBarrier(void *ptr)
 90410: {
 90410:     if (!ptr)
 90410:         return;
 90410:     JS_ASSERT(!static_cast<gc::Cell *>(ptr)->compartment()->rt->gcRunning);
 90410:     uint32_t kind = gc::GetGCThingTraceKind(ptr);
 90410:     if (kind == JSTRACE_OBJECT)
 90410:         JSObject::writeBarrierPre((JSObject *) ptr);
 90410:     else if (kind == JSTRACE_STRING)
 90410:         JSString::writeBarrierPre((JSString *) ptr);
 97830:     else if (kind == JSTRACE_SCRIPT)
 97830:         JSScript::writeBarrierPre((JSScript *) ptr);
 97830:     else if (kind == JSTRACE_SHAPE)
 97830:         Shape::writeBarrierPre((Shape *) ptr);
 97830:     else if (kind == JSTRACE_BASE_SHAPE)
 97830:         BaseShape::writeBarrierPre((BaseShape *) ptr);
 97830:     else if (kind == JSTRACE_TYPE_OBJECT)
 97830:         types::TypeObject::writeBarrierPre((types::TypeObject *) ptr);
 90410:     else
 90410:         JS_NOT_REACHED("invalid trace kind");
 90410: }
 90410: 
 90410: extern JS_FRIEND_API(void)
 90410: IncrementalValueBarrier(const Value &v)
 90410: {
 90410:     HeapValue::writeBarrierPre(v);
 90410: }
 90410: 
 99131: extern JS_FRIEND_API(void)
 99131: PokeGC(JSRuntime *rt)
 99131: {
 99131:     rt->gcPoke = true;
 99131: }
 99131: 
 91659: JS_FRIEND_API(JSObject *)
 91659: GetTestingFunctions(JSContext *cx)
 91659: {
 91659:     JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
 91659:     if (!obj)
 91659:         return NULL;
 91659: 
 91659:     if (!DefineTestingFunctions(cx, obj))
 91659:         return NULL;
 91659: 
 91659:     return obj;
 91659: }
 91659: 
 86984: } // namespace js
