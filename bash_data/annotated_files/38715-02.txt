    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Japan code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Japan.
    1:  * Portions created by the Initial Developer are Copyright (C) 2007
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
19759:  *   Karl Tomlinson <karlt+@karlt.net>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxFontconfigUtils.h"
19289: #include "gfxFont.h"
    1: 
19759: #include <locale.h>
    1: #include <fontconfig/fontconfig.h>
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsServiceManagerUtils.h"
19759: #include "nsILanguageAtomService.h"
23904: #include "nsTArray.h"
    1: 
    1: #include "nsIAtom.h"
    1: #include "nsCRT.h"
    1: 
    1: /* static */ gfxFontconfigUtils* gfxFontconfigUtils::sUtils = nsnull;
19759: static nsILanguageAtomService* gLangService = nsnull;
19759: 
19759: /* static */ void
19759: gfxFontconfigUtils::Shutdown() {
19759:     if (sUtils) {
19759:         delete sUtils;
19759:         sUtils = nsnull;
19759:     }
19759:     NS_IF_RELEASE(gLangService);
19759: }
    1: 
19289: /* static */ PRUint8
22397: gfxFontconfigUtils::FcSlantToThebesStyle(int aFcSlant)
22397: {
22397:     switch (aFcSlant) {
22397:         case FC_SLANT_ITALIC:
22397:             return FONT_STYLE_ITALIC;
22397:         case FC_SLANT_OBLIQUE:
22397:             return FONT_STYLE_OBLIQUE;
22397:         default:
22397:             return FONT_STYLE_NORMAL;
22397:     }
22397: }
22397: 
22397: /* static */ PRUint8
19289: gfxFontconfigUtils::GetThebesStyle(FcPattern *aPattern)
19289: {
19289:     int slant;
22397:     if (FcPatternGetInteger(aPattern, FC_SLANT, 0, &slant) != FcResultMatch) {
22397:         return FONT_STYLE_NORMAL;
19289:     }
19289: 
22397:     return FcSlantToThebesStyle(slant);
19289: }
19289: 
21407: /* static */ int
21407: gfxFontconfigUtils::GetFcSlant(const gfxFontStyle& aFontStyle)
21407: {
21407:     if (aFontStyle.style == FONT_STYLE_ITALIC)
21407:         return FC_SLANT_ITALIC;
21407:     if (aFontStyle.style == FONT_STYLE_OBLIQUE)
21407:         return FC_SLANT_OBLIQUE;
21407: 
21407:     return FC_SLANT_ROMAN;
21407: }
21407: 
19289: // OS/2 weight classes were introduced in fontconfig-2.1.93 (2003).
19289: #ifndef FC_WEIGHT_THIN 
19289: #define FC_WEIGHT_THIN              0 // 2.1.93
19289: #define FC_WEIGHT_EXTRALIGHT        40 // 2.1.93
19289: #define FC_WEIGHT_REGULAR           80 // 2.1.93
19289: #define FC_WEIGHT_EXTRABOLD         205 // 2.1.93
19289: #endif
19289: // book was introduced in fontconfig-2.2.90 (and so fontconfig-2.3.0 in 2005)
19289: #ifndef FC_WEIGHT_BOOK
19289: #define FC_WEIGHT_BOOK              75
19289: #endif
21407: // extra black was introduced in fontconfig-2.4.91 (2007)
21407: #ifndef FC_WEIGHT_EXTRABLACK
21407: #define FC_WEIGHT_EXTRABLACK        215
21407: #endif
19289: 
19289: /* static */ PRUint16
19289: gfxFontconfigUtils::GetThebesWeight(FcPattern *aPattern)
19289: {
19289:     int weight;
19289:     if (FcPatternGetInteger(aPattern, FC_WEIGHT, 0, &weight) != FcResultMatch)
19289:         return FONT_WEIGHT_NORMAL;
19289: 
19289:     if (weight <= (FC_WEIGHT_THIN + FC_WEIGHT_EXTRALIGHT) / 2)
19289:         return 100;
19289:     if (weight <= (FC_WEIGHT_EXTRALIGHT + FC_WEIGHT_LIGHT) / 2)
19289:         return 200;
19289:     if (weight <= (FC_WEIGHT_LIGHT + FC_WEIGHT_BOOK) / 2)
19289:         return 300;
19289:     if (weight <= (FC_WEIGHT_REGULAR + FC_WEIGHT_MEDIUM) / 2)
19289:         // This includes FC_WEIGHT_BOOK
19289:         return 400;
19289:     if (weight <= (FC_WEIGHT_MEDIUM + FC_WEIGHT_DEMIBOLD) / 2)
19289:         return 500;
19289:     if (weight <= (FC_WEIGHT_DEMIBOLD + FC_WEIGHT_BOLD) / 2)
19289:         return 600;
19289:     if (weight <= (FC_WEIGHT_BOLD + FC_WEIGHT_EXTRABOLD) / 2)
19289:         return 700;
19289:     if (weight <= (FC_WEIGHT_EXTRABOLD + FC_WEIGHT_BLACK) / 2)
19289:         return 800;
19289:     if (weight <= FC_WEIGHT_BLACK)
19289:         return 900;
19289: 
21407:     // including FC_WEIGHT_EXTRABLACK
19289:     return 901;
19289: }
19289: 
21407: /* static */ int
21407: gfxFontconfigUtils::FcWeightForBaseWeight(PRInt8 aBaseWeight)
21407: {
26030:     NS_PRECONDITION(aBaseWeight >= 0 && aBaseWeight <= 10,
26030:                     "base weight out of range");
26030: 
21407:     switch (aBaseWeight) {
21407:         case 2:
21407:             return FC_WEIGHT_EXTRALIGHT;
21407:         case 3:
21407:             return FC_WEIGHT_LIGHT;
21407:         case 4:
21407:             return FC_WEIGHT_REGULAR;
21407:         case 5:
21407:             return FC_WEIGHT_MEDIUM;
21407:         case 6:
21407:             return FC_WEIGHT_DEMIBOLD;
21407:         case 7:
21407:             return FC_WEIGHT_BOLD;
21407:         case 8:
21407:             return FC_WEIGHT_EXTRABOLD;
21407:         case 9:
21407:             return FC_WEIGHT_BLACK;
21407:     }
21407: 
21407:     // extremes
21407:     return aBaseWeight < 2 ? FC_WEIGHT_THIN : FC_WEIGHT_EXTRABLACK;
21407: }
21407: 
21407: // This makes a guess at an FC_WEIGHT corresponding to a base weight and
21407: // offset (without any knowledge of which weights are available).
21407: 
21407: /* static */ int
21407: GuessFcWeight(const gfxFontStyle& aFontStyle)
21407: {
21407:     /*
21407:      * weights come in two parts crammed into one
21407:      * integer -- the "base" weight is weight / 100,
21407:      * the rest of the value is the "offset" from that
21407:      * weight -- the number of steps to move to adjust
21407:      * the weight in the list of supported font weights,
21407:      * this value can be negative or positive.
21407:      */
21407:     PRInt8 weight;
21407:     PRInt8 offset;
21407:     aFontStyle.ComputeWeightAndOffset(&weight, &offset);
21407: 
21407:     // ComputeWeightAndOffset trimmed the range of weights for us
21407:     NS_ASSERTION(weight >= 0 && weight <= 10,
21407:                  "base weight out of range");
21407: 
21407:     // Most font families do not support every weight.  The tables here are
21407:     // chosen such that a normal (4) base weight and an offset of +1 will
21407:     // guess bold.
21407: 
21407:     // Mapping from weight to a guess of the nearest available lighter weight
21407:     static const int lighterGuess[11] =
21407:         { 0, 0, 1, 1, 2, 3, 4, 4, 6, 7, 8 };
21407:     // Mapping from weight to a guess of the nearest available bolder weight
21407:     static const int bolderGuess[11] =
21407:         { 2, 3, 4, 6, 7, 7, 8, 9, 10, 10, 10 };
21407: 
21407:     while (offset < 0) {
21407:         weight = lighterGuess[weight];
21407:         offset++;
21407:     }
21407:     while (offset > 0) {
21407:         weight = bolderGuess[weight];
21407:         offset--;
21407:     }
21407: 
21407:     return gfxFontconfigUtils::FcWeightForBaseWeight(weight);
21407: }
21407: 
21407: static void
21407: AddString(FcPattern *aPattern, const char *object, const char *aString)
21407: {
22397:     FcPatternAddString(aPattern, object,
22397:                        gfxFontconfigUtils::ToFcChar8(aString));
21407: }
21407: 
21407: static void
21407: AddLangGroup(FcPattern *aPattern, const nsACString& aLangGroup)
21407: {
21407:     // Translate from mozilla's internal mapping into fontconfig's
21407:     nsCAutoString lang;
21407:     gfxFontconfigUtils::GetSampleLangForGroup(aLangGroup, &lang);
21407: 
21407:     if (!lang.IsEmpty()) {
21407:         AddString(aPattern, FC_LANG, lang.get());
21407:     }
21407: }
21407: 
21407: 
21407: nsReturnRef<FcPattern>
22397: gfxFontconfigUtils::NewPattern(const nsTArray<nsString>& aFamilies,
21407:                                const gfxFontStyle& aFontStyle,
21407:                                const char *aLang)
21407: {
21407:     nsAutoRef<FcPattern> pattern(FcPatternCreate());
21407:     if (!pattern)
21407:         return nsReturnRef<FcPattern>();
21407: 
21407:     FcPatternAddDouble(pattern, FC_PIXEL_SIZE, aFontStyle.size);
21407:     FcPatternAddInteger(pattern, FC_SLANT, GetFcSlant(aFontStyle));
21407:     FcPatternAddInteger(pattern, FC_WEIGHT, GuessFcWeight(aFontStyle));
21407: 
21407:     if (aLang) {
21407:         AddString(pattern, FC_LANG, aLang);
21407:     }
21407: 
22397:     for (PRUint32 i = 0; i < aFamilies.Length(); ++i) {
22397:         NS_ConvertUTF16toUTF8 family(aFamilies[i]);
21407:         AddString(pattern, FC_FAMILY, family.get());
21407:     }
21407: 
21407:     return pattern.out();
21407: }
21407: 
    1: gfxFontconfigUtils::gfxFontconfigUtils()
19478:     : mLastConfig(NULL)
    1: {
21407:     mFontsByFamily.Init(50);
23273:     mFontsByFullname.Init(50);
21407:     mLangSupportTable.Init(20);
21407:     UpdateFontListInternal();
    1: }
    1: 
    1: nsresult
38493: gfxFontconfigUtils::GetFontList(nsIAtom *aLangGroup,
    1:                                 const nsACString& aGenericFamily,
23904:                                 nsTArray<nsString>& aListOfFonts)
    1: {
    1:     aListOfFonts.Clear();
    1: 
24031:     nsTArray<nsCString> fonts;
38715:     nsCAutoString langGroupStr;
38715:     if (aLangGroup) {
38493:         aLangGroup->ToUTF8String(langGroupStr);
38715:     }
38493:     nsresult rv = GetFontListInternal(fonts, langGroupStr);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
24031:     for (PRUint32 i = 0; i < fonts.Length(); ++i) {
24031:         aListOfFonts.AppendElement(NS_ConvertUTF8toUTF16(fonts[i]));
    1:     }
    1: 
 5317:     aListOfFonts.Sort();
 5317: 
 5317:     PRInt32 serif = 0, sansSerif = 0, monospace = 0;
    1: 
    1:     // Fontconfig supports 3 generic fonts, "serif", "sans-serif", and
    1:     // "monospace", slightly different from CSS's 5.
    1:     if (aGenericFamily.IsEmpty())
    1:         serif = sansSerif = monospace = 1;
    1:     else if (aGenericFamily.LowerCaseEqualsLiteral("serif"))
    1:         serif = 1;
    1:     else if (aGenericFamily.LowerCaseEqualsLiteral("sans-serif"))
    1:         sansSerif = 1;
    1:     else if (aGenericFamily.LowerCaseEqualsLiteral("monospace"))
    1:         monospace = 1;
    1:     else if (aGenericFamily.LowerCaseEqualsLiteral("cursive") ||
    1:              aGenericFamily.LowerCaseEqualsLiteral("fantasy"))
    1:         serif = sansSerif = 1;
    1:     else
    1:         NS_NOTREACHED("unexpected CSS generic font family");
    1: 
 5317:     // The first in the list becomes the default in
 5317:     // gFontsDialog.readFontSelection() if the preference-selected font is not
 5317:     // available, so put system configured defaults first.
 5317:     if (monospace)
23904:         aListOfFonts.InsertElementAt(0, NS_LITERAL_STRING("monospace"));
 5317:     if (sansSerif)
23904:         aListOfFonts.InsertElementAt(0, NS_LITERAL_STRING("sans-serif"));
    1:     if (serif)
23904:         aListOfFonts.InsertElementAt(0, NS_LITERAL_STRING("serif"));
    1: 
    1:     return NS_OK;
    1: }
    1: 
19759: struct MozLangGroupData {
 3589:     const char *mozLangGroup;
19759:     const char *defaultLang;
 3589: };
 3589: 
19759: const MozLangGroupData MozLangGroups[] = {
19759:     { "x-western",      "en" },
19759:     { "x-central-euro", "pl" },
19759:     { "x-cyrillic",     "ru" },
19759:     { "x-baltic",       "lv" },
19759:     { "x-devanagari",   "hi" },
19759:     { "x-tamil",        "ta" },
19759:     { "x-armn",         "hy" },
19759:     { "x-beng",         "bn" },
19759:     { "x-cans",         "iu" },
19759:     { "x-ethi",         "am" },
19759:     { "x-geor",         "ka" },
19759:     { "x-gujr",         "gu" },
19759:     { "x-guru",         "pa" },
19759:     { "x-khmr",         "km" },
19759:     { "x-knda",         "kn" },
19759:     { "x-mlym",         "ml" },
19759:     { "x-orya",         "or" },
19759:     { "x-sinh",         "si" },
19759:     { "x-telu",         "te" },
 3589:     { "x-unicode",      0    },
 3589:     { "x-user-def",     0    }
 3589: };
 3589: 
19759: static PRBool
19759: TryLangForGroup(const nsACString& aOSLang, nsIAtom *aLangGroup,
19759:                 nsACString *aFcLang)
 3589: {
19759:     // Truncate at '.' or '@' from aOSLang, and convert '_' to '-'.
19759:     // aOSLang is in the form "language[_territory][.codeset][@modifier]".
19759:     // fontconfig takes languages in the form "language-territory".
19759:     // nsILanguageAtomService takes languages in the form language-subtag,
19759:     // where subtag may be a territory.  fontconfig and nsILanguageAtomService
19759:     // handle case-conversion for us.
19759:     const char *pos, *end;
19759:     aOSLang.BeginReading(pos);
19759:     aOSLang.EndReading(end);
19759:     aFcLang->Truncate();
19759:     while (pos < end) {
19759:         switch (*pos) {
19759:             case '.':
19759:             case '@':
19759:                 end = pos;
19759:                 break;
19759:             case '_':
19759:                 aFcLang->Append('-');
19759:                 break;
19759:             default:
19759:                 aFcLang->Append(*pos);
 3589:         }
19759:         ++pos;
 3589:     }
 3589: 
19759:     nsIAtom *atom =
19759:         gLangService->LookupLanguage(NS_ConvertUTF8toUTF16(*aFcLang));
19759: 
19759:     return atom == aLangGroup;
19759: }
19759: 
19759: /* static */ void
19759: gfxFontconfigUtils::GetSampleLangForGroup(const nsACString& aLangGroup,
19759:                                           nsACString *aFcLang)
19759: {
19759:     NS_PRECONDITION(aFcLang != nsnull, "aFcLang must not be NULL");
19759: 
19759:     const MozLangGroupData *langGroup = nsnull;
19759: 
19759:     for (unsigned int i = 0; i < NS_ARRAY_LENGTH(MozLangGroups); ++i) {
19759:         if (aLangGroup.Equals(MozLangGroups[i].mozLangGroup,
19759:                               nsCaseInsensitiveCStringComparator())) {
19759:             langGroup = &MozLangGroups[i];
19759:             break;
19759:         }
19759:     }
19759: 
19759:     if (!langGroup) {
19759:         // Not a special mozilla language group.
19759:         // Use aLangGroup as a language code.
19759:         aFcLang->Assign(aLangGroup);
19759:         return;
19759:     }
19759: 
19759:     // Check the environment for the users preferred language that corresponds
19759:     // to this langGroup.
19759:     if (!gLangService) {
19759:         CallGetService(NS_LANGUAGEATOMSERVICE_CONTRACTID, &gLangService);
19759:     }
19759: 
19759:     if (gLangService) {
19759:         nsRefPtr<nsIAtom> langGroupAtom = do_GetAtom(langGroup->mozLangGroup);
19759: 
19759:         const char *languages = getenv("LANGUAGE");
19759:         if (languages) {
19759:             const char separator = ':';
19759: 
19759:             for (const char *pos = languages; PR_TRUE; ++pos) {
19759:                 if (*pos == '\0' || *pos == separator) {
19759:                     if (languages < pos &&
19759:                         TryLangForGroup(Substring(languages, pos),
19759:                                         langGroupAtom, aFcLang))
19759:                         return;
19759: 
19759:                     if (*pos == '\0')
19759:                         break;
19759: 
19759:                     languages = pos + 1;
19759:                 }
19759:             }
19759:         }
19759:         const char *ctype = setlocale(LC_CTYPE, NULL);
19759:         if (ctype &&
19759:             TryLangForGroup(nsDependentCString(ctype), langGroupAtom, aFcLang))
19759:             return;
19759:     }
19759: 
19759:     if (langGroup->defaultLang) {
19759:         aFcLang->Assign(langGroup->defaultLang);
19759:     } else {
19759:         aFcLang->Truncate();
19759:     }
 3589: }
 3589: 
    1: nsresult
24031: gfxFontconfigUtils::GetFontListInternal(nsTArray<nsCString>& aListOfFonts,
21407:                                         const nsACString& aLangGroup)
    1: {
    1:     FcPattern *pat = NULL;
    1:     FcObjectSet *os = NULL;
    1:     FcFontSet *fs = NULL;
    1:     nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:     aListOfFonts.Clear();
    1: 
    1:     pat = FcPatternCreate();
    1:     if (!pat)
    1:         goto end;
    1: 
    1:     os = FcObjectSetBuild(FC_FAMILY, NULL);
    1:     if (!os)
    1:         goto end;
    1: 
    1:     // take the pattern and add the lang group to it
21407:     if (!aLangGroup.IsEmpty()) {
21407:         AddLangGroup(pat, aLangGroup);
    1:     }
    1: 
    1:     fs = FcFontList(NULL, pat, os);
    1:     if (!fs)
    1:         goto end;
    1: 
    1:     for (int i = 0; i < fs->nfont; i++) {
    1:         char *family;
    1: 
    1:         if (FcPatternGetString(fs->fonts[i], FC_FAMILY, 0,
    1:                                (FcChar8 **) &family) != FcResultMatch)
    1:         {
    1:             continue;
    1:         }
    1: 
    1:         // Remove duplicates...
    1:         nsCAutoString strFamily(family);
24031:         if (aListOfFonts.Contains(strFamily))
    1:             continue;
    1: 
24031:         aListOfFonts.AppendElement(strFamily);
    1:     }
    1: 
    1:     rv = NS_OK;
    1: 
    1:   end:
    1:     if (NS_FAILED(rv))
    1:         aListOfFonts.Clear();
    1: 
    1:     if (pat)
    1:         FcPatternDestroy(pat);
    1:     if (os)
    1:         FcObjectSetDestroy(os);
    1:     if (fs)
    1:         FcFontSetDestroy(fs);
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: gfxFontconfigUtils::UpdateFontList()
    1: {
    1:     return UpdateFontListInternal(PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: gfxFontconfigUtils::UpdateFontListInternal(PRBool aForce)
    1: {
19478:     if (!aForce) {
19478:         // This checks periodically according to fontconfig's configured
19478:         // <rescan> interval.
19478:         FcInitBringUptoDate();
19478:     } else if (!FcConfigUptoDate(NULL)) { // check now with aForce
19478:         mLastConfig = NULL;
19478:         FcInitReinitialize();
19478:     }
19478: 
19478:     // FcInitReinitialize() (used by FcInitBringUptoDate) creates a new config
19478:     // before destroying the old config, so the only way that we'd miss an
19478:     // update is if fontconfig did more than one update and the memory for the
19478:     // most recent config happened to be at the same location as the original
19478:     // config.
19478:     FcConfig *currentConfig = FcConfigGetCurrent();
19478:     if (currentConfig == mLastConfig)
    1:         return NS_OK;
    1: 
21407:     // This FcFontSet is owned by fontconfig
21407:     FcFontSet *fontSet = FcConfigGetFonts(currentConfig, FcSetSystem);
21407: 
21407:     mFontsByFamily.Clear();
23273:     mFontsByFullname.Clear();
21407:     mLangSupportTable.Clear();
21399:     mAliasForMultiFonts.Clear();
21388: 
21407:     // Record the existing font families
21407:     for (int f = 0; f < fontSet->nfont; ++f) {
21407:         FcPattern *font = fontSet->fonts[f];
21354: 
21407:         FcChar8 *family;
21407:         for (int v = 0;
21407:              FcPatternGetString(font, FC_FAMILY, v, &family) == FcResultMatch;
21407:              ++v) {
21407:             FontsByFcStrEntry *entry = mFontsByFamily.PutEntry(family);
21407:             if (entry) {
21407:                 PRBool added = entry->AddFont(font);
21407: 
21407:                 if (!entry->mKey) {
21407:                     // The reference to the font pattern keeps the pointer to
21407:                     // string for the key valid.  If adding the font failed
21407:                     // then the entry must be removed.
21407:                     if (added) {
21407:                         entry->mKey = family;
21407:                     } else {
21407:                         mFontsByFamily.RawRemoveEntry(entry);
21407:                     }
21407:                 }
21407:             }
21407:         }
21407:     }
    1: 
    1:     // XXX we don't support all alias names.
    1:     // Because if we don't check whether the given font name is alias name,
    1:     // fontconfig converts the non existing font to sans-serif.
    1:     // This is not good if the web page specifies font-family
    1:     // that has Windows font name in the first.
    1:     nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (!prefs)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIPrefBranch> prefBranch;
    1:     prefs->GetBranch(0, getter_AddRefs(prefBranch));
    1:     if (!prefBranch)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsXPIDLCString list;
19478:     prefBranch->GetCharPref("font.alias-list", getter_Copies(list));
    1: 
    1:     if (!list.IsEmpty()) {
    1:         const char kComma = ',';
    1:         const char *p, *p_end;
    1:         list.BeginReading(p);
    1:         list.EndReading(p_end);
    1:         while (p < p_end) {
    1:             while (nsCRT::IsAsciiSpace(*p)) {
    1:                 if (++p == p_end)
    1:                     break;
    1:             }
    1:             if (p == p_end)
    1:                 break;
    1:             const char *start = p;
    1:             while (++p != p_end && *p != kComma)
    1:                 /* nothing */ ;
    1:             nsCAutoString name(Substring(start, p));
    1:             name.CompressWhitespace(PR_FALSE, PR_TRUE);
24031:             mAliasForMultiFonts.AppendElement(name);
    1:             p++;
    1:         }
    1:     }
    1: 
19478:     mLastConfig = currentConfig;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
13003: gfxFontconfigUtils::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
13003: {
13003:     aFamilyName.Truncate();
13003: 
13003:     // The fontconfig has generic family names in the font list.
13003:     if (aFontName.EqualsLiteral("serif") ||
13003:         aFontName.EqualsLiteral("sans-serif") ||
13003:         aFontName.EqualsLiteral("monospace")) {
13003:         aFamilyName.Assign(aFontName);
13003:         return NS_OK;
13003:     }
13003: 
19478:     nsresult rv = UpdateFontListInternal();
19478:     if (NS_FAILED(rv))
19478:         return rv;
19478: 
13003:     NS_ConvertUTF16toUTF8 fontname(aFontName);
13003: 
21407:     // return empty string if no such family exists
21407:     if (!IsExistingFamily(fontname))
13003:         return NS_OK;
13003: 
13003:     FcPattern *pat = NULL;
13003:     FcObjectSet *os = NULL;
13003:     FcFontSet *givenFS = NULL;
24031:     nsTArray<nsCString> candidates;
13003:     FcFontSet *candidateFS = NULL;
19478:     rv = NS_ERROR_FAILURE;
13003: 
13003:     pat = FcPatternCreate();
13003:     if (!pat)
13003:         goto end;
13003: 
13003:     FcPatternAddString(pat, FC_FAMILY, (FcChar8 *)fontname.get());
13003: 
13003:     os = FcObjectSetBuild(FC_FAMILY, FC_FILE, FC_INDEX, NULL);
13003:     if (!os)
13003:         goto end;
13003: 
13003:     givenFS = FcFontList(NULL, pat, os);
13003:     if (!givenFS)
13003:         goto end;
13003: 
13003:     // The first value associated with a FC_FAMILY property is the family
13003:     // returned by GetFontList(), so use this value if appropriate.
13003: 
13003:     // See if there is a font face with first family equal to the given family.
13003:     for (int i = 0; i < givenFS->nfont; ++i) {
13003:         char *firstFamily;
13003:         if (FcPatternGetString(givenFS->fonts[i], FC_FAMILY, 0,
13003:                                (FcChar8 **) &firstFamily) != FcResultMatch)
13003:             continue;
13003: 
13003:         nsDependentCString first(firstFamily);
24031:         if (!candidates.Contains(first)) {
24031:             candidates.AppendElement(first);
13003: 
13003:             if (fontname.Equals(first)) {
13003:                 aFamilyName.Assign(aFontName);
13003:                 rv = NS_OK;
13003:                 goto end;
13003:             }
13003:         }
13003:     }
13003: 
13003:     // See if any of the first family names represent the same set of font
13003:     // faces as the given family.
24031:     for (PRUint32 j = 0; j < candidates.Length(); ++j) {
13003:         FcPatternDel(pat, FC_FAMILY);
24031:         FcPatternAddString(pat, FC_FAMILY, (FcChar8 *)candidates[j].get());
13003: 
13003:         candidateFS = FcFontList(NULL, pat, os);
13003:         if (!candidateFS)
13003:             goto end;
13003: 
13003:         if (candidateFS->nfont != givenFS->nfont)
13003:             continue;
13003: 
13003:         PRBool equal = PR_TRUE;
13003:         for (int i = 0; i < givenFS->nfont; ++i) {
13003:             if (!FcPatternEqual(candidateFS->fonts[i], givenFS->fonts[i])) {
13003:                 equal = PR_FALSE;
13003:                 break;
13003:             }
13003:         }
13003:         if (equal) {
24031:             AppendUTF8toUTF16(candidates[j], aFamilyName);
13003:             rv = NS_OK;
13003:             goto end;
13003:         }
13003:     }
13003: 
13003:     // No match found; return empty string.
13003:     rv = NS_OK;
13003: 
13003:   end:
13003:     if (pat)
13003:         FcPatternDestroy(pat);
13003:     if (os)
13003:         FcObjectSetDestroy(os);
13003:     if (givenFS)
13003:         FcFontSetDestroy(givenFS);
13003:     if (candidateFS)
13003:         FcFontSetDestroy(candidateFS);
13003: 
13003:     return rv;
13003: }
13003: 
13003: nsresult
    1: gfxFontconfigUtils::ResolveFontName(const nsAString& aFontName,
    1:                                     gfxPlatform::FontResolverCallback aCallback,
    1:                                     void *aClosure,
    1:                                     PRBool& aAborted)
    1: {
    1:     aAborted = PR_FALSE;
    1: 
    1:     nsresult rv = UpdateFontListInternal();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     NS_ConvertUTF16toUTF8 fontname(aFontName);
21407:     // Sometimes, the font has two or more names (e.g., "Sazanami Gothic" has
21407:     // Japanese localized name).  We should not resolve to a single name
21407:     // because different names sometimes have different behavior. e.g., with
21407:     // the default settings of "Sazanami" on Fedora Core 5, the non-localized
21407:     // name uses anti-alias, but the localized name uses it.  So, we should
21407:     // check just whether the font is existing, without resolving to regular
21407:     // name.
21407:     //
21407:     // The family names in mAliasForMultiFonts are names understood by
21407:     // fontconfig.  The actual font to which they resolve depends on the
21407:     // entire match pattern.  That info is not available here, but there
21407:     // will be a font so leave the resolving to the gfxFontGroup.
21407:     if (IsExistingFamily(fontname) ||
24031:         mAliasForMultiFonts.Contains(fontname, gfxIgnoreCaseCStringComparator()))
    1:         aAborted = !(*aCallback)(aFontName, aClosure);
    1: 
    1:     return NS_OK;
    1: }
    1: 
21407: PRBool
21407: gfxFontconfigUtils::IsExistingFamily(const nsCString& aFamilyName)
    1: {
23273:     return mFontsByFamily.GetEntry(ToFcChar8(aFamilyName)) != nsnull;
 5498: }
    1: 
21407: const nsTArray< nsCountedRef<FcPattern> >&
21407: gfxFontconfigUtils::GetFontsForFamily(const FcChar8 *aFamilyName)
21407: {
21407:     FontsByFcStrEntry *entry = mFontsByFamily.GetEntry(aFamilyName);
21407: 
21407:     if (!entry)
21407:         return mEmptyPatternArray;
21407: 
21407:     return entry->GetFonts();
21407: }
21407: 
23273: // Fontconfig only provides a fullname property for fonts in formats with SFNT
23273: // wrappers.  For other font formats (including PCF and PS Type 1), a fullname
23273: // must be generated from the family and style properties.  Only the first
23273: // family and style is checked, but that should be OK, as I don't expect
23273: // non-SFNT fonts to have multiple families or styles.
23273: PRBool
23273: gfxFontconfigUtils::GetFullnameFromFamilyAndStyle(FcPattern *aFont,
23273:                                                   nsACString *aFullname)
23273: {
23273:     FcChar8 *family;
23273:     if (FcPatternGetString(aFont, FC_FAMILY, 0, &family) != FcResultMatch)
23273:         return PR_FALSE;
23273: 
23273:     aFullname->Truncate();
23273:     aFullname->Append(ToCString(family));
23273: 
23273:     FcChar8 *style;
23273:     if (FcPatternGetString(aFont, FC_STYLE, 0, &style) == FcResultMatch &&
23273:         strcmp(ToCString(style), "Regular") != 0) {
23273:         aFullname->Append(' ');
23273:         aFullname->Append(ToCString(style));
23273:     }
23273: 
23273:     return PR_TRUE;
23273: }
23273: 
23273: PRBool
23273: gfxFontconfigUtils::FontsByFullnameEntry::KeyEquals(KeyTypePointer aKey) const
23273: {
23273:     const FcChar8 *key = mKey;
23273:     // If mKey is NULL, key comes from the style and family of the first font.
23273:     nsCAutoString fullname;
23273:     if (!key) {
23273:         NS_ASSERTION(mFonts.Length(), "No font in FontsByFullnameEntry!");
23273:         GetFullnameFromFamilyAndStyle(mFonts[0], &fullname);
23273: 
23273:         key = ToFcChar8(fullname);
23273:     }
23273: 
23273:     return FcStrCmpIgnoreCase(aKey, key) == 0;
23273: }
23273: 
23273: void
23273: gfxFontconfigUtils::AddFullnameEntries()
23273: {
23273:     // This FcFontSet is owned by fontconfig
23273:     FcFontSet *fontSet = FcConfigGetFonts(NULL, FcSetSystem);
23273: 
23273:     // Record the existing font families
23273:     for (int f = 0; f < fontSet->nfont; ++f) {
23273:         FcPattern *font = fontSet->fonts[f];
23273: 
23273:         int v = 0;
23273:         FcChar8 *fullname;
23273:         while (FcPatternGetString(font,
23273:                                   FC_FULLNAME, v, &fullname) == FcResultMatch) {
23273:             FontsByFullnameEntry *entry = mFontsByFullname.PutEntry(fullname);
23273:             if (entry) {
23273:                 // entry always has space for one font, so the first AddFont
23273:                 // will always succeed, and so the entry will always have a
23273:                 // font from which to obtain the key.
23273:                 PRBool added = entry->AddFont(font);
23273:                 // The key may be NULL either if this is the first font, or if
23273:                 // the first font does not have a fullname property, and so
23273:                 // the key is obtained from the font.  Set the key in both
23273:                 // cases.  The check that AddFont succeeded is required for
23273:                 // the second case.
23273:                 if (!entry->mKey && added) {
23273:                     entry->mKey = fullname;
23273:                 }
23273:             }
23273: 
23273:             ++v;
23273:         }
23273: 
23273:         // Fontconfig does not provide a fullname property for all fonts.
23273:         if (v == 0) {
23273:             nsCAutoString name;
23273:             if (!GetFullnameFromFamilyAndStyle(font, &name))
23273:                 continue;
23273: 
23273:             FontsByFullnameEntry *entry =
23273:                 mFontsByFullname.PutEntry(ToFcChar8(name));
23273:             if (entry) {
23273:                 entry->AddFont(font);
23273:                 // Either entry->mKey has been set for a previous font or it
23273:                 // remains NULL to indicate that the key is obtained from the
23273:                 // first font.
23273:             }
23273:         }
23273:     }
23273: }
23273: 
23273: const nsTArray< nsCountedRef<FcPattern> >&
23273: gfxFontconfigUtils::GetFontsForFullname(const FcChar8 *aFullname)
23273: {
23273:     if (mFontsByFullname.Count() == 0) {
23273:         AddFullnameEntries();
23273:     }
23273: 
23273:     FontsByFullnameEntry *entry = mFontsByFullname.GetEntry(aFullname);
23273: 
23273:     if (!entry)
23273:         return mEmptyPatternArray;
23273: 
23273:     return entry->GetFonts();
23273: }
23273: 
21407: static FcLangResult
21407: CompareLangString(const FcChar8 *aLangA, const FcChar8 *aLangB) {
21407:     FcLangResult result = FcLangDifferentLang;
21407:     for (PRUint32 i = 0; ; ++i) {
21407:         FcChar8 a = FcToLower(aLangA[i]);
21407:         FcChar8 b = FcToLower(aLangB[i]);
21407: 
21407:         if (a != b) {
21407:             if ((a == '\0' && b == '-') || (a == '-' && b == '\0'))
21407:                 return FcLangDifferentCountry;
21407: 
    1:             return result;
    1:         }
21407:         if (a == '\0')
21407:             return FcLangEqual;
21407: 
21407:         if (a == '-') {
21407:             result = FcLangDifferentCountry;
21407:         }
21407:     }
21407: }
21407: 
21407: /* static */
21407: FcLangResult
21407: gfxFontconfigUtils::GetLangSupport(FcPattern *aFont, const FcChar8 *aLang)
21407: {
22397:     // When fontconfig builds a pattern for a system font, it will set a
22397:     // single LangSet property value for the font.  That value may be removed
22397:     // and additional string values may be added through FcConfigSubsitute
22397:     // with FcMatchScan.  Values that are neither LangSet nor string are
22397:     // considered errors in fontconfig sort and match functions.
22397:     //
22397:     // If no string nor LangSet value is found, then either the font is a
22397:     // system font and the LangSet has been removed through FcConfigSubsitute,
22397:     // or the font is a web font and its language support is unknown.
22397:     // Returning FcLangDifferentLang for these fonts ensures that this font
22397:     // will not be assumed to satisfy the language, and so language will be
22397:     // prioritized in sorting fallback fonts.
21407:     FcValue value;
21407:     FcLangResult best = FcLangDifferentLang;
22397:     for (int v = 0;
22397:          FcPatternGet(aFont, FC_LANG, v, &value) == FcResultMatch;
22397:          ++v) {
21407: 
21407:         FcLangResult support;
21407:         switch (value.type) {
21407:             case FcTypeLangSet:
21407:                 support = FcLangSetHasLang(value.u.l, aLang);
21407:                 break;
21407:             case FcTypeString:
21407:                 support = CompareLangString(value.u.s, aLang);
21407:                 break;
21407:             default:
22397:                 // error. continue to see if there is a useful value.
22397:                 continue;
21407:         }
21407: 
21407:         if (support < best) { // lower is better
21407:             if (support == FcLangEqual)
21407:                 return support;
21407:             best = support;
21407:         }        
21407:     }
21407: 
21407:     return best;
21407: }
21407: 
21407: gfxFontconfigUtils::LangSupportEntry *
21407: gfxFontconfigUtils::GetLangSupportEntry(const FcChar8 *aLang, PRBool aWithFonts)
21407: {
21407:     // Currently any unrecognized languages from documents will be converted
21407:     // to x-unicode by nsILanguageAtomService, so there is a limit on the
21407:     // langugages that will be added here.  Reconsider when/if document
21407:     // languages are passed to this routine.
21407: 
21407:     LangSupportEntry *entry = mLangSupportTable.PutEntry(aLang);
21407:     if (!entry)
21407:         return nsnull;
21407: 
21407:     FcLangResult best = FcLangDifferentLang;
21407: 
21407:     if (!entry->IsKeyInitialized()) {
21407:         entry->InitKey(aLang);
21407:     } else {
21407:         // mSupport is already initialized.
21407:         if (!aWithFonts)
21407:             return entry;
21407: 
21407:         best = entry->mSupport;
21407:         // If there is support for this language, an empty font list indicates
21407:         // that the list hasn't been initialized yet.
21407:         if (best == FcLangDifferentLang || entry->mFonts.Length() > 0)
21407:             return entry;
21407:     }
21407: 
21407:     // This FcFontSet is owned by fontconfig
21407:     FcFontSet *fontSet = FcConfigGetFonts(NULL, FcSetSystem);
21407: 
21407:     nsAutoTArray<FcPattern*,100> fonts;
21407: 
21407:     for (int f = 0; f < fontSet->nfont; ++f) {
21407:         FcPattern *font = fontSet->fonts[f];
21407: 
21407:         FcLangResult support = GetLangSupport(font, aLang);
21407: 
21407:         if (support < best) { // lower is better
21407:             best = support;
21407:             if (aWithFonts) {
21407:                 fonts.Clear();
21407:             } else if (best == FcLangEqual) {
21407:                 break;
21407:             }
21407:         }
21407: 
21407:         // The font list in the LangSupportEntry is expected to be used only
21407:         // when no default fonts support the language.  There would be a large
21407:         // number of fonts in entries for languages using Latin script but
21407:         // these do not need to be created because default fonts already
21407:         // support these languages.
21407:         if (aWithFonts && support != FcLangDifferentLang && support == best) {
21407:             fonts.AppendElement(font);
21407:         }
21407:     }
21407: 
21407:     entry->mSupport = best;
21407:     if (aWithFonts) {
21407:         if (fonts.Length() != 0) {
21407:             entry->mFonts.AppendElements(fonts.Elements(), fonts.Length());
21407:         } else if (best != FcLangDifferentLang) {
21407:             // Previously there was a font that supported this language at the
21407:             // level of entry->mSupport, but it has now disappeared.  At least
21407:             // entry->mSupport needs to be recalculated, but this is an
21407:             // indication that the set of installed fonts has changed, so
21407:             // update all caches.
21407:             mLastConfig = NULL; // invalidates caches
21407:             UpdateFontListInternal(PR_TRUE);
21407:             return GetLangSupportEntry(aLang, aWithFonts);
21407:         }
21407:     }
21407: 
21407:     return entry;
21407: }
21407: 
21407: FcLangResult
21407: gfxFontconfigUtils::GetBestLangSupport(const FcChar8 *aLang)
21407: {
21407:     UpdateFontListInternal();
21407: 
21407:     LangSupportEntry *entry = GetLangSupportEntry(aLang, PR_FALSE);
21407:     if (!entry)
21407:         return FcLangEqual;
21407: 
21407:     return entry->mSupport;
21407: }
21407: 
21407: const nsTArray< nsCountedRef<FcPattern> >&
21407: gfxFontconfigUtils::GetFontsForLang(const FcChar8 *aLang)
21407: {
21407:     LangSupportEntry *entry = GetLangSupportEntry(aLang, PR_TRUE);
21407:     if (!entry)
21407:         return mEmptyPatternArray;
21407: 
21407:     return entry->mFonts;
21407: }
    1: 
    1: PRBool
    1: gfxFontNameList::Exists(nsAString& aName) {
    1:     for (PRUint32 i = 0; i < Length(); i++) {
    1:         if (aName.Equals(ElementAt(i)))
    1:             return PR_TRUE;
    1:     }
    1:     return PR_FALSE;
    1: }
