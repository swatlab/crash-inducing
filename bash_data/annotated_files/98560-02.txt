49072: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
39997:  * ***** BEGIN LICENSE BLOCK *****
39997:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39997:  *
39997:  * The contents of this file are subject to the Mozilla Public License Version
39997:  * 1.1 (the "License"); you may not use this file except in compliance with
39997:  * the License. You may obtain a copy of the License at
39997:  * http://www.mozilla.org/MPL/
39997:  *
39997:  * Software distributed under the License is distributed on an "AS IS" basis,
39997:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39997:  * for the specific language governing rights and limitations under the
39997:  * License.
39997:  *
39997:  * The Original Code is Mozilla Corporation code.
39997:  *
39997:  * The Initial Developer of the Original Code is Mozilla Foundation.
39997:  * Portions created by the Initial Developer are Copyright (C) 2009
39997:  * the Initial Developer. All Rights Reserved.
39997:  *
39997:  * Contributor(s):
39997:  *   Bas Schouten <bschouten@mozilla.org>
39997:  *
39997:  * Alternatively, the contents of this file may be used under the terms of
39997:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39997:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39997:  * in which case the provisions of the GPL or the LGPL are applicable instead
39997:  * of those above. If you wish to allow use of your version of this file only
39997:  * under the terms of either the GPL or the LGPL, and not to allow others to
39997:  * use your version of this file under the terms of the MPL, indicate your
39997:  * decision by deleting the provisions above and replace them with the notice
39997:  * and other provisions required by the GPL or the LGPL. If you do not delete
39997:  * the provisions above, a recipient may use your version of this file under
39997:  * the terms of any one of the MPL, the GPL or the LGPL.
39997:  *
39997:  * ***** END LICENSE BLOCK ***** */
39997: 
39997: #ifndef GFX_IMAGELAYEROGL_H
39997: #define GFX_IMAGELAYEROGL_H
39997: 
55454: #include "mozilla/layers/PLayers.h"
55454: #include "mozilla/layers/ShadowLayers.h"
55454: 
39997: #include "LayerManagerOGL.h"
39997: #include "ImageLayers.h"
51961: #include "yuv_convert.h"
40576: #include "mozilla/Mutex.h"
39997: 
39997: namespace mozilla {
39997: namespace layers {
39997: 
42441: /**
42441:  * This class wraps a GL texture. It includes a GLContext reference
42441:  * so we can use to free the texture when destroyed. The implementation
42441:  * makes sure to always free the texture on the main thread, even if the
42441:  * destructor runs on another thread.
42441:  *
42441:  * We ensure that the GLContext reference is only addrefed and released
42441:  * on the main thread, although it uses threadsafe recounting so we don't
42441:  * really have to.
42441:  *
42441:  * Initially the texture is not allocated --- it's in a "null" state.
42441:  */
42441: class GLTexture {
42441:   typedef mozilla::gl::GLContext GLContext;
42441: 
42441: public:
42441:   GLTexture() : mTexture(0) {}
42441:   ~GLTexture() { Release(); }
42441: 
42441:   /**
42441:    * Allocate the texture. This can only be called on the main thread.
42441:    */
42441:   void Allocate(GLContext *aContext);
42441:   /**
42441:    * Move the state of aOther to this GLTexture. If this GLTexture currently
42441:    * has a texture, it is released. This can be called on any thread.
42441:    */
42441:   void TakeFrom(GLTexture *aOther);
42441: 
79445:   bool IsAllocated() { return mTexture != 0; }
42441:   GLuint GetTextureID() { return mTexture; }
42441:   GLContext *GetGLContext() { return mContext; }
42441: 
98560:   void Release();
42441: private:
42441: 
42441:   nsRefPtr<GLContext> mContext;
42441:   GLuint mTexture;
42441: };
42441: 
42442: /**
89204:  * A RecycleBin is owned by an ImageLayer. We store textures in it that we
89204:  * want to recycle from one image to the next. It's a separate object from 
89204:  * ImageContainer because images need to store a strong ref to their RecycleBin
89204:  * and we must avoid creating a reference loop between an ImageContainer and
89204:  * its active image.
42442:  */
89204: class TextureRecycleBin {
89204:   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(TextureRecycleBin)
42442: 
42443:   typedef mozilla::gl::GLContext GLContext;
42443: 
42442: public:
89204:   TextureRecycleBin();
42442: 
42443:   enum TextureType {
42443:     TEXTURE_Y,
42443:     TEXTURE_C
42443:   };
42443: 
42443:   void RecycleTexture(GLTexture *aTexture, TextureType aType,
42443:                       const gfxIntSize& aSize);
49072:   void GetTexture(TextureType aType, const gfxIntSize& aSize,
42443:                   GLContext *aContext, GLTexture *aOutTexture);
42443: 
42442: private:
42442:   typedef mozilla::Mutex Mutex;
42442: 
42443:   // This protects mRecycledBuffers, mRecycledBufferSize, mRecycledTextures
42443:   // and mRecycledTextureSizes
42442:   Mutex mLock;
42442: 
42443:   nsTArray<GLTexture> mRecycledTextures[2];
42443:   gfxIntSize mRecycledTextureSizes[2];
42442: };
42442: 
39997: class THEBES_API ImageLayerOGL : public ImageLayer,
39997:                                  public LayerOGL
39997: {
39997: public:
89204:   ImageLayerOGL(LayerManagerOGL *aManager);
49072:   ~ImageLayerOGL() { Destroy(); }
39997: 
39997:   // LayerOGL Implementation
80486:   virtual void Destroy() { mDestroyed = true; }
39997:   virtual Layer* GetLayer();
97445:   virtual bool LoadAsTexture(GLuint aTextureUnit, gfxIntSize* aSize);
39997: 
42791:   virtual void RenderLayer(int aPreviousFrameBuffer,
57097:                            const nsIntPoint& aOffset);
87402:   virtual void CleanupResources() {}
89204: 
97445: 
89204:   void AllocateTexturesYCbCr(PlanarYCbCrImage *aImage);
89204:   void AllocateTexturesCairo(CairoImage *aImage);
89204: 
89204: protected:
89204:   nsRefPtr<TextureRecycleBin> mTextureRecycleBin;
39997: };
39997: 
89204: struct THEBES_API PlanarYCbCrOGLBackendData : public ImageBackendData
39997: {
89204:   ~PlanarYCbCrOGLBackendData()
89204:   {
89204:     if (HasTextures()) {
89204:       mTextureRecycleBin->RecycleTexture(&mTextures[0], TextureRecycleBin::TEXTURE_Y, mYSize);
89204:       mTextureRecycleBin->RecycleTexture(&mTextures[1], TextureRecycleBin::TEXTURE_C, mCbCrSize);
89204:       mTextureRecycleBin->RecycleTexture(&mTextures[2], TextureRecycleBin::TEXTURE_C, mCbCrSize);
89204:     }
89204:   }
42441: 
79445:   bool HasTextures()
42441:   {
42441:     return mTextures[0].IsAllocated() && mTextures[1].IsAllocated() &&
42441:            mTextures[2].IsAllocated();
42441:   }
39997: 
42441:   GLTexture mTextures[3];
89204:   gfxIntSize mYSize, mCbCrSize;
89204:   nsRefPtr<TextureRecycleBin> mTextureRecycleBin;
39997: };
39997: 
39997: 
89204: struct CairoOGLBackendData : public ImageBackendData
39997: {
93424:   CairoOGLBackendData() : mLayerProgram(gl::RGBALayerProgramType) {}
42441:   GLTexture mTexture;
59437:   gl::ShaderProgramType mLayerProgram;
97445:   gfxIntSize mTextureSize;
39997: };
39997: 
55454: class ShadowImageLayerOGL : public ShadowImageLayer,
55454:                             public LayerOGL
55454: {
55454:   typedef gl::TextureImage TextureImage;
55454: 
55454: public:
55454:   ShadowImageLayerOGL(LayerManagerOGL* aManager);
55454:   virtual ~ShadowImageLayerOGL();
55454: 
55454:   // ShadowImageLayer impl
79425:   virtual void Swap(const SharedImage& aFront,
79425:                     SharedImage* aNewBack);
55454: 
60065:   virtual void Disconnect();
60065: 
55454:   // LayerOGL impl
55454:   virtual void Destroy();
97448:   virtual bool LoadAsTexture(GLuint aTextureUnit, gfxIntSize* aSize);
55454: 
55454:   virtual Layer* GetLayer();
55454: 
55454:   virtual void RenderLayer(int aPreviousFrameBuffer,
57097:                            const nsIntPoint& aOffset);
55454: 
87402:   virtual void CleanupResources();
87402: 
55454: private:
79445:   bool Init(const SharedImage& aFront);
79425: 
55454:   nsRefPtr<TextureImage> mTexImage;
69765:   GLTexture mYUVTexture[3];
69765:   gfxIntSize mSize;
79425:   gfxIntSize mCbCrSize;
73014:   nsIntRect mPictureRect;
55454: };
55454: 
39997: } /* layers */
39997: } /* mozilla */
39997: #endif /* GFX_IMAGELAYEROGL_H */
