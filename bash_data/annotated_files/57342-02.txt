    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998-1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Veditz <dveditz@netscape.com>
    1:  *   Samir Gehani <sgehani@netscape.com>
    1:  *   Mitch Stoltz <mstoltz@netscape.com>
31399:  *   Taras Glek <tglek@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsZipArchive_h_
    1: #define nsZipArchive_h_
    1: 
    1: #define ZIP_TABSIZE   256
33443: #define ZIP_BUFLEN    (4*1024)      /* Used as output buffer when deflating items to a file */
    1: 
52248: #ifndef PL_ARENA_CONST_ALIGN_MASK
33990: #define PL_ARENA_CONST_ALIGN_MASK  (sizeof(void*)-1)
52248: #endif
    1: #include "plarena.h"
    1: 
    1: #include "zlib.h"
33990: #include "zipstruct.h"
31399: #include "nsAutoPtr.h"
37439: #include "nsILocalFile.h"
50832: #include "mozilla/FileUtils.h"
    1: 
57341: #if defined(XP_WIN)
57341: #define MOZ_WIN_MEM_TRY_BEGIN __try {
57341: #define MOZ_WIN_MEM_TRY_CATCH(cmd) }                                \
57341:   __except(GetExceptionCode()==EXCEPTION_IN_PAGE_ERROR ?            \
57341:            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)   \
57341:   {                                                                 \
57341:     NS_WARNING("EXCEPTION_IN_PAGE_ERROR in " __FUNCTION__);         \
57341:     cmd;                                                            \
57341:   }
57341: #else
57341: #define MOZ_WIN_MEM_TRY_BEGIN {
57341: #define MOZ_WIN_MEM_TRY_CATCH(cmd) }
57341: #endif
57341: 
    1: class nsZipFind;
    1: struct PRFileDesc;
    1: 
    1: /**
    1:  * This file defines some of the basic structures used by libjar to
    1:  * read Zip files. It makes use of zlib in order to do the decompression.
    1:  *
    1:  * A few notes on the classes/structs:
    1:  * nsZipArchive   represents a single Zip file, and maintains an index
    1:  *                of all the items in the file.
    1:  * nsZipItem      represents a single item (file) in the Zip archive.
    1:  * nsZipFind      represents the metadata involved in doing a search,
    1:  *                and current state of the iteration of found objects.
    1:  * 'MT''safe' reading from the zipfile is performed through JARInputStream,
    1:  * which maintains its own file descriptor, allowing for multiple reads 
    1:  * concurrently from the same zip file.
    1:  */
    1: 
    1: /**
    1:  * nsZipItem -- a helper struct for nsZipArchive
    1:  *
    1:  * each nsZipItem represents one file in the archive and all the
    1:  * information needed to manipulate it.
    1:  */
33990: class nsZipItem
    1: {
33990: public:
33990:   const char* Name() { return ((const char*)central) + ZIPCENTRAL_SIZE; }
    1: 
37369:   PRUint32 LocalOffset();
37369:   PRUint32 Size();
37369:   PRUint32 RealSize();
37369:   PRUint32 CRC32();
37369:   PRUint16 Date();
37369:   PRUint16 Time();
37369:   PRUint16 Compression();
37369:   bool     IsDirectory();
37369:   PRUint16 Mode();
37369:   const PRUint8* GetExtraField(PRUint16 aTag, PRUint16 *aBlockSize);
37369:   PRTime   LastModTime();
    1: 
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
37369:   bool     IsSymlink();
    1: #endif
    1: 
33990:   nsZipItem*         next;
33990:   const ZipCentral*  central;
33990:   PRUint16           nameLength;
33990:   bool               isSynthetic;
    1: };
    1: 
31399: class nsZipHandle;
33443: 
    1: /** 
    1:  * nsZipArchive -- a class for reading the PKZIP file format.
    1:  *
    1:  */
    1: class nsZipArchive 
    1: {
    1:   friend class nsZipFind;
    1: 
    1: public:
    1:   /** constructing does not open the archive. See OpenArchive() */
    1:   nsZipArchive();
    1: 
    1:   /** destructing the object closes the archive */
    1:   ~nsZipArchive();
    1: 
    1:   /** 
    1:    * OpenArchive 
    1:    * 
    1:    * It's an error to call this more than once on the same nsZipArchive
    1:    * object. If we were allowed to use exceptions this would have been 
    1:    * part of the constructor 
    1:    *
52249:    * @param   aZipHandle  The nsZipHandle used to access the zip
    1:    * @return  status code
    1:    */
52249:   nsresult OpenArchive(nsZipHandle *aZipHandle);
52249: 
52249:   /** 
52249:    * OpenArchive 
52249:    * 
52249:    * Convenience function that generates nsZipHandle
52249:    *
52249:    * @param   aFile  The file used to access the zip
52249:    * @return  status code
52249:    */
52249:   nsresult OpenArchive(nsIFile *aFile);
    1: 
    1:   /**
    1:    * Test the integrity of items in this archive by running
    1:    * a CRC check after extracting each item into a memory 
    1:    * buffer.  If an entry name is supplied only the 
    1:    * specified item is tested.  Else, if null is supplied
    1:    * then all the items in the archive are tested.
    1:    *
    1:    * @return  status code       
    1:    */
    1:   nsresult Test(const char *aEntryName);
    1: 
    1:   /**
    1:    * Closes an open archive.
    1:    */
    1:   nsresult CloseArchive();
    1: 
    1:   /** 
    1:    * GetItem
    1:    * @param   aEntryName Name of file in the archive
    1:    * @return  pointer to nsZipItem
    1:    */  
    1:   nsZipItem* GetItem(const char * aEntryName);
    1:   
    1:   /** 
    1:    * ExtractFile
    1:    *
    1:    * @param   zipEntry   Name of file in archive to extract
    1:    * @param   outFD      Filedescriptor to write contents to
    1:    * @param   outname    Name of file to write to
    1:    * @return  status code
    1:    */
    1:   nsresult ExtractFile(nsZipItem * zipEntry, const char *outname, PRFileDesc * outFD);
    1: 
    1:   /**
    1:    * FindInit
    1:    *
    1:    * Initializes a search for files in the archive. FindNext() returns
    1:    * the actual matches. The nsZipFind must be deleted when you're done
    1:    *
    1:    * @param   aPattern    a string or RegExp pattern to search for
    1:    *                      (may be NULL to find all files in archive)
    1:    * @param   aFind       a pointer to a pointer to a structure used
    1:    *                      in FindNext.  In the case of an error this
    1:    *                      will be set to NULL.
    1:    * @return  status code
    1:    */
    1:   PRInt32 FindInit(const char * aPattern, nsZipFind** aFind);
    1: 
33443:   /*
33443:    * Gets an undependent handle to the mapped file.
    1:    */
33443:   nsZipHandle* GetFD();
33443: 
33443:   /**
33443:    * Get pointer to the data of the item.
33443:    * @param   aItem       Pointer to nsZipItem
33443:    * reutrns null when zip file is corrupt.
33443:    */
52249:   const PRUint8* GetData(nsZipItem* aItem);
    1: 
    1: private:
    1:   //--- private members ---
    1: 
    1:   nsZipItem*    mFiles[ZIP_TABSIZE];
    1:   PLArenaPool   mArena;
    1: 
    1:   // Whether we synthesized the directory entries
33443:   bool          mBuiltSynthetics;
    1: 
31399:   // file handle
31399:   nsRefPtr<nsZipHandle> mFd;
50832: 
50832:   // logging handle
50832:   mozilla::AutoFDClose mLog;
50832: 
    1:   //--- private methods ---
    1:   
    1:   nsZipArchive& operator=(const nsZipArchive& rhs); // prevent assignments
    1:   nsZipArchive(const nsZipArchive& rhs);            // prevent copies
    1: 
33990:   nsZipItem*        CreateZipItem();
    1:   nsresult          BuildFileList();
    1:   nsresult          BuildSynthetics();
31399: };
31399: 
    1: /** 
    1:  * nsZipFind 
    1:  *
    1:  * a helper class for nsZipArchive, representing a search
    1:  */
    1: class nsZipFind
    1: {
    1: public:
    1:   nsZipFind(nsZipArchive* aZip, char* aPattern, PRBool regExp);
    1:   ~nsZipFind();
    1: 
33990:   nsresult      FindNext(const char** aResult, PRUint16* aNameLen);
    1: 
    1: private:
    1:   nsZipArchive* mArchive;
    1:   char*         mPattern;
    1:   nsZipItem*    mItem;
    1:   PRUint16      mSlot;
    1:   PRPackedBool  mRegExp;
    1: 
    1:   //-- prevent copies and assignments
    1:   nsZipFind& operator=(const nsZipFind& rhs);
    1:   nsZipFind(const nsZipFind& rhs);
    1: };
    1: 
43106: /** 
43106:  * nsZipCursor -- a low-level class for reading the individual items in a zip.
43106:  */
43106: class nsZipCursor {
43106: public:
43106:   /**
43106:    * Initializes the cursor
43106:    *
43106:    * @param   aItem       Item of interest
43106:    * @param   aZip        Archive
43106:    * @param   aBuf        Buffer used for decompression.
43106:    *                      This determines the maximum Read() size in the compressed case.
43106:    * @param   aBufSize    Buffer size
43106:    * @param   doCRC       When set to true Read() will check crc
43106:    */
43106:   nsZipCursor(nsZipItem *aItem, nsZipArchive *aZip, PRUint8* aBuf = NULL, PRUint32 aBufSize = 0, bool doCRC = false);
43106: 
43106:   ~nsZipCursor();
43106: 
43106:   /**
43106:    * Performs reads. In the compressed case it uses aBuf(passed in constructor), for stored files
43106:    * it returns a zero-copy buffer.
43106:    *
43106:    * @param   aBytesRead  Outparam for number of bytes read.
43106:    * @return  data read or NULL if item is corrupted.
43106:    */
43106:   PRUint8* Read(PRUint32 *aBytesRead);
43106: 
43106: private:
43106:   nsZipItem *mItem; 
43106:   PRUint8  *mBuf; 
43106:   PRUint32  mBufSize; 
43106:   z_stream  mZs;
43106:   PRUint32 mCRC;
43106:   bool mDoCRC;
43106: };
43106: 
43106: /**
43106:  * nsZipItemPtr - a RAII convenience class for reading the individual items in a zip.
43106:  * It reads whole files and does zero-copy IO for stored files. A buffer is allocated
43106:  * for decompression.
43106:  * Do not use when the file may be very large.
43106:  */
43106: class nsZipItemPtr_base {
43106: public:
43106:   /**
43106:    * Initializes the reader
43106:    *
43106:    * @param   aZip        Archive
43106:    * @param   aEntryName  Archive membername
43106:    * @param   doCRC       When set to true Read() will check crc
43106:    */
43106:   nsZipItemPtr_base(nsZipArchive *aZip, const char *aEntryName, bool doCRC);
43106: 
43106:   PRUint32 Length() const {
43106:     return mReadlen;
43106:   }
43106: 
43106: protected:
43106:   nsRefPtr<nsZipHandle> mZipHandle;
43106:   nsAutoArrayPtr<PRUint8> mAutoBuf;
43106:   PRUint8 *mReturnBuf;
43106:   PRUint32 mReadlen;
43106: };
43106: 
43106: template <class T>
43106: class nsZipItemPtr : public nsZipItemPtr_base {
43106: public:
43106:   nsZipItemPtr(nsZipArchive *aZip, const char *aEntryName, bool doCRC = false) : nsZipItemPtr_base(aZip, aEntryName, doCRC) { }
43106:   /**
43106:    * @return buffer containing the whole zip member or NULL on error.
43106:    * The returned buffer is owned by nsZipItemReader.
43106:    */
43106:   const T* Buffer() const {
43106:     return (const T*)mReturnBuf;
43106:   }
43106: 
43106:   operator const T*() const {
43106:     return Buffer();
43106:   }
57342: 
57342:   /**
57342:    * Relinquish ownership of zip member if compressed.
57342:    * Copy member into a new buffer if uncompressed.
57342:    * @return a buffer with whole zip member. It is caller's responsibility to free() it.
57342:    */
57342:   T* Forget() {
57342:     if (!mReturnBuf)
57342:       return NULL;
57342:     // In uncompressed mmap case, give up buffer
57342:     if (mAutoBuf.get() == mReturnBuf) {
57342:       mReturnBuf = NULL;
57342:       return (T*) mAutoBuf.forget();
57342:     }
57342:     T *ret = (T*) malloc(Length());
57342:     memcpy(ret, mReturnBuf, Length());
57342:     mReturnBuf = NULL;
57342:     return ret;
57342:   }
43106: };
43106: 
52249: class nsZipHandle {
52249: friend class nsZipArchive;
52249: public:
52249:   static nsresult Init(nsILocalFile *file, nsZipHandle **ret NS_OUTPARAM);
52249:   static nsresult Init(nsZipArchive *zip, const char *entry,
52249:                        nsZipHandle **ret NS_OUTPARAM);
52249: 
52249:   NS_METHOD_(nsrefcnt) AddRef(void);
52249:   NS_METHOD_(nsrefcnt) Release(void);
52249: 
52249: protected:
52249:   const PRUint8 * mFileData; /* pointer to mmaped file */
52249:   PRUint32        mLen;      /* length of file and memory mapped area */
52249:   nsCOMPtr<nsILocalFile> mFile; /* source file if any, for logging */
52249: 
52249: private:
52249:   nsZipHandle();
52249:   ~nsZipHandle();
52249: 
52249:   PRFileMap *                       mMap;    /* nspr datastructure for mmap */
52249:   nsAutoPtr<nsZipItemPtr<PRUint8> > mBuf;
52249:   nsrefcnt                          mRefCnt; /* ref count */
52249: };
52249: 
    1: nsresult gZlibInit(z_stream *zs);
    1: 
    1: #endif /* nsZipArchive_h_ */
