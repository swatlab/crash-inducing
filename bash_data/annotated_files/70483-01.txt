47525: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
47525:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
47525:  *
47525:  * ***** BEGIN LICENSE BLOCK *****
47525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47525:  *
47525:  * The contents of this file are subject to the Mozilla Public License Version
47525:  * 1.1 (the "License"); you may not use this file except in compliance with
47525:  * the License. You may obtain a copy of the License at
47525:  * http://www.mozilla.org/MPL/
47525:  *
47525:  * Software distributed under the License is distributed on an "AS IS" basis,
47525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47525:  * for the specific language governing rights and limitations under the
47525:  * License.
47525:  *
47525:  * The Original Code is mozilla.org code, released
47525:  * June 24, 2010.
47525:  *
47525:  * The Initial Developer of the Original Code is
47525:  *    The Mozilla Foundation
47525:  *
47525:  * Contributor(s):
47525:  *    Andreas Gal <gal@mozilla.com>
47525:  *
47525:  * Alternatively, the contents of this file may be used under the terms of
47525:  * either of the GNU General Public License Version 2 or later (the "GPL"),
47525:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47525:  * in which case the provisions of the GPL or the LGPL are applicable instead
47525:  * of those above. If you wish to allow use of your version of this file only
47525:  * under the terms of either the GPL or the LGPL, and not to allow others to
47525:  * use your version of this file under the terms of the MPL, indicate your
47525:  * decision by deleting the provisions above and replace them with the notice
47525:  * and other provisions required by the GPL or the LGPL. If you do not delete
47525:  * the provisions above, a recipient may use your version of this file under
47525:  * the terms of any one of the MPL, the GPL or the LGPL.
47525:  *
47525:  * ***** END LICENSE BLOCK ***** */
47525: 
47574: #include "jsobj.h"
55599: #include "jsvalue.h"
47574: 
47525: #include "WrapperFactory.h"
47574: #include "CrossOriginWrapper.h"
47574: #include "FilteringWrapper.h"
47574: #include "XrayWrapper.h"
47525: #include "AccessCheck.h"
55628: #include "XPCWrapper.h"
47525: 
47574: #include "xpcprivate.h"
58722: #include "xpcmaps.h"
47574: 
47525: namespace xpc {
47525: 
47574: // When chrome pulls a naked property across the membrane using
47574: // .wrappedJSObject, we want it to cross the membrane into the
47574: // chrome compartment without automatically being wrapped into an
47574: // X-ray wrapper. We achieve this by wrapping it into a special
47574: // transparent wrapper in the origin (non-chrome) compartment. When
47574: // an object with that special wrapper applied crosses into chrome,
47574: // we know to not apply an X-ray wrapper.
47574: JSWrapper WaiveXrayWrapperWrapper(WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG);
47574: 
61453: // Objects that haven't been explicitly waived, but have been exposed
61453: // to chrome don't want a CrossOriginWrapper, since that deeply-waives
61453: // but need the transparent behavior of a CrossOriginWrapper. The
61453: // NoWaiverWrapper is like a CrossOriginWrapper that can also hand out
61453: // XrayWrappers as return values.
61453: NoWaiverWrapper NoWaiverWrapper::singleton(0);
61453: 
47574: // When objects for which we waived the X-ray wrapper cross into
47574: // chrome, we wrap them into a special cross-compartment wrapper
47574: // that transitively extends the waiver to all properties we get
47574: // off it.
55691: CrossOriginWrapper CrossOriginWrapper::singleton(0);
55691: 
55691: static JSObject *
56105: GetCurrentOuter(JSContext *cx, JSObject *obj)
56105: {
56105:     OBJ_TO_OUTER_OBJECT(cx, obj);
56105:     if (obj->isWrapper() && !obj->getClass()->ext.innerObject) {
56105:         obj = obj->unwrap();
56105:         NS_ASSERTION(obj->getClass()->ext.innerObject,
56105:                      "weird object, expecting an outer window proxy");
56105:     }
56105: 
56105:     return obj;
56105: }
56105: 
47574: JSObject *
60580: WrapperFactory::WaiveXray(JSContext *cx, JSObject *obj)
60580: {
61061:     obj = obj->unwrap();
61061: 
60580:     // We have to make sure that if we're wrapping an outer window, that
60580:     // the .wrappedJSObject also wraps the outer window.
60580:     obj = GetCurrentOuter(cx, obj);
60580: 
60580:     {
60580:         // See if we already have a waiver wrapper for this object.
60580:         CompartmentPrivate *priv =
60580:             (CompartmentPrivate *)JS_GetCompartmentPrivate(cx, obj->compartment());
60580:         JSObject *wobj = nsnull;
60580:         if (priv && priv->waiverWrapperMap)
60580:             wobj = priv->waiverWrapperMap->Find(obj);
60580: 
60580:         // No wrapper yet, make one.
60580:         if (!wobj) {
60580:             JSObject *proto = obj->getProto();
60580:             if (proto && !(proto = WaiveXray(cx, proto)))
60580:                 return nsnull;
60580: 
61046:             JSAutoEnterCompartment ac;
61046:             if (!ac.enter(cx, obj))
61046:                 return nsnull;
68955:             wobj = JSWrapper::New(cx, obj, proto, JS_GetGlobalForObject(cx, obj),
68955:                                   &WaiveXrayWrapperWrapper);
60580:             if (!wobj)
60580:                 return nsnull;
60580: 
60580:             // Add the new wrapper so we find it next time.
60580:             if (priv) {
60580:                 if (!priv->waiverWrapperMap) {
60580:                     priv->waiverWrapperMap = JSObject2JSObjectMap::newMap(XPC_WRAPPER_MAP_SIZE);
60580:                     if (!priv->waiverWrapperMap)
60580:                         return nsnull;
60580:                 }
60580:                 if (!priv->waiverWrapperMap->Add(obj, wobj))
60580:                     return nsnull;
60580:             }
60580:         }
60580: 
60580:         obj = wobj;
60580:     }
60580: 
60580:     return obj;
60580: }
60580: 
60580: JSObject *
60580: WrapperFactory::DoubleWrap(JSContext *cx, JSObject *obj, uintN flags)
60580: {
60580:     if (flags & WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG) {
61061:         JSAutoEnterCompartment ac;
61061:         if (!ac.enter(cx, obj))
61061:             return nsnull;
61061: 
60580:         return WaiveXray(cx, obj);
60580:     }
60580:     return obj;
60580: }
60580: 
60580: JSObject *
55628: WrapperFactory::PrepareForWrapping(JSContext *cx, JSObject *scope, JSObject *obj, uintN flags)
55628: {
55691:     // Don't unwrap an outer window, just double wrap it if needed.
55691:     if (obj->getClass()->ext.innerObject)
55691:         return DoubleWrap(cx, obj, flags);
55691: 
55628:     // Here are the rules for wrapping:
55628:     // We should never get a proxy here (the JS engine unwraps those for us).
55691:     JS_ASSERT(!obj->isWrapper());
55628: 
55628:     // As soon as an object is wrapped in a security wrapper, it morphs to be
55628:     // a fat wrapper. (see also: bug XXX).
55628:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
55628:         return nsnull;
55628: 
55628:     // We only hand out outer objects to script.
56106:     obj = GetCurrentOuter(cx, obj);
56105:     if (obj->getClass()->ext.innerObject)
56105:         return DoubleWrap(cx, obj, flags);
55628: 
55628:     // Now, our object is ready to be wrapped, but several objects (notably
55628:     // nsJSIIDs) have a wrapper per scope. If we are about to wrap one of
55628:     // those objects in a security wrapper, then we need to hand back the
55689:     // wrapper for the new scope instead. Also, global objects don't move
55689:     // between scopes so for those we also want to return the wrapper. So...
55689:     if (!IS_WN_WRAPPER(obj) || !obj->getParent())
55691:         return DoubleWrap(cx, obj, flags);
55628: 
55628:     XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
55628: 
55947:     // If the object doesn't have classinfo we want to return the same
55947:     // XPCWrappedNative so that we keep the same set of interfaces.
55947:     if (!wn->GetClassInfo())
55947:         return DoubleWrap(cx, obj, flags);
55947: 
62405:     JSAutoEnterCompartment ac;
62405:     if (!ac.enter(cx, obj))
62405:         return nsnull;
55628:     XPCCallContext ccx(JS_CALLER, cx, obj);
62582: 
62582:     {
55628:         if (NATIVE_HAS_FLAG(&ccx, WantPreCreate)) {
55628:             // We have a precreate hook. This object might enforce that we only
55628:             // ever create JS object for it.
55628:             JSObject *originalScope = scope;
55628:             nsresult rv = wn->GetScriptableInfo()->GetCallback()->
55628:                 PreCreate(wn->Native(), cx, scope, &scope);
55691:             NS_ENSURE_SUCCESS(rv, DoubleWrap(cx, obj, flags));
55628: 
55628:             // If the handed back scope differs from the passed-in scope and is in
55628:             // a separate compartment, then this object is explicitly requesting
55628:             // that we don't create a second JS object for it: create a security
55628:             // wrapper.
61451:             if (originalScope->compartment() != scope->getCompartment())
55691:                 return DoubleWrap(cx, obj, flags);
55628: 
55628:             // Note: this penalizes objects that only have one wrapper, but are
55628:             // being accessed across compartments. We would really prefer to
55628:             // replace the above code with a test that says "do you only have one
55628:             // wrapper?"
55628:         }
62405:     }
55628: 
56818:     // NB: Passing a holder here inhibits slim wrappers under
56818:     // WrapNativeToJSVal.
56818:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
62582: 
62582:     // This public WrapNativeToJSVal API enters the compartment of 'scope'
62582:     // so we don't have to.
55628:     jsval v;
55628:     nsresult rv =
55628:         nsXPConnect::FastGetXPConnect()->WrapNativeToJSVal(cx, scope, wn->Native(), nsnull,
55628:                                                            &NS_GET_IID(nsISupports), PR_FALSE,
56818:                                                            &v, getter_AddRefs(holder));
56818:     if (NS_SUCCEEDED(rv)) {
55691:         obj = JSVAL_TO_OBJECT(v);
56818:         NS_ASSERTION(IS_WN_WRAPPER(obj), "bad object");
56818: 
56818:         XPCWrappedNative *newwn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
57182:         if (newwn->GetSet()->GetInterfaceCount() < wn->GetSet()->GetInterfaceCount())
56818:             newwn->SetSet(wn->GetSet());
56818:     }
56818: 
55691:     return DoubleWrap(cx, obj, flags);
55628: }
55628: 
70483: static XPCWrappedNative *
70483: GetWrappedNative(JSContext *cx, JSObject *obj)
70483: {
70483:     OBJ_TO_INNER_OBJECT(cx, obj);
70483:     return IS_WN_WRAPPER(obj)
70483:            ? static_cast<XPCWrappedNative *>(obj->getPrivate())
70483:            : nsnull;
70483: }
70483: 
55628: JSObject *
55580: WrapperFactory::Rewrap(JSContext *cx, JSObject *obj, JSObject *wrappedProto, JSObject *parent,
55580:                        uintN flags)
47525: {
55691:     NS_ASSERTION(!obj->isWrapper() ||
55691:                  (obj->isWrapper() &&
55691:                   obj->getProxyHandler() == &WaiveXrayWrapperWrapper) ||
55691:                  obj->getClass()->ext.innerObject,
54404:                  "wrapped object passed to rewrap");
55602:     NS_ASSERTION(JS_GET_CLASS(cx, obj) != &XrayUtils::HolderClass, "trying to wrap a holder");
47574: 
61451:     JSCompartment *origin = obj->compartment();
47574:     JSCompartment *target = cx->compartment;
55599:     JSObject *xrayHolder = nsnull;
47574: 
47574:     JSWrapper *wrapper;
55733:     CompartmentPrivate *targetdata = static_cast<CompartmentPrivate *>(target->data);
47574:     if (AccessCheck::isChrome(target)) {
68955:         if (AccessCheck::isChrome(origin)) {
68955:             wrapper = &JSCrossCompartmentWrapper::singleton;
68955:         } else {
68955:             bool isSystem;
68955:             {
68955:                 JSAutoEnterCompartment ac;
68955:                 if (!ac.enter(cx, obj))
68955:                     return nsnull;
68955:                 JSObject *globalObj = JS_GetGlobalForObject(cx, obj);
68955:                 JS_ASSERT(globalObj);
68955:                 isSystem = JS_IsSystemObject(cx, globalObj);
68955:             }
68955: 
68955:             if (isSystem) {
55591:                 wrapper = &JSCrossCompartmentWrapper::singleton;
55591:             } else if (flags & WAIVE_XRAY_WRAPPER_FLAG) {
47574:                 // If we waived the X-ray wrapper for this object, wrap it into a
47574:                 // special wrapper to transitively maintain the X-ray waiver.
55691:                 wrapper = &CrossOriginWrapper::singleton;
47574:             } else {
47574:                 // Native objects must be wrapped into an X-ray wrapper.
61453:                 if (IS_WN_WRAPPER(obj) || obj->getClass()->ext.innerObject) {
61453:                     typedef XrayWrapper<JSCrossCompartmentWrapper> Xray;
55582:                     wrapper = &Xray::singleton;
55599:                     xrayHolder = Xray::createHolder(cx, obj, parent);
55599:                     if (!xrayHolder)
55599:                         return nsnull;
55582:                 } else {
61453:                     wrapper = &NoWaiverWrapper::singleton;
55582:                 }
47525:             }
68955:         }
47574:     } else if (AccessCheck::isChrome(origin)) {
61448:         if (obj->isFunction()) {
61448:             JSFunction *fun = obj->getFunctionPrivate();
64210:             if (JS_IsBuiltinEvalFunction(fun) || JS_IsBuiltinFunctionConstructor(fun)) {
61448:                 JS_ReportError(cx, "Not allowed to access chrome eval or Function from content");
61448:                 return nsnull;
61448:             }
61448:         }
69850: 
69850:         XPCWrappedNative *wn;
70483:         if (targetdata &&
70483:             (wn = GetWrappedNative(cx, obj)) &&
70483:             wn->HasProto() && wn->GetProto()->ClassIsDOMObject()) {
69850:             typedef XrayWrapper<JSCrossCompartmentWrapper> Xray;
69850:             wrapper = &FilteringWrapper<Xray,
69850:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
69850:             xrayHolder = Xray::createHolder(cx, obj, parent);
69850:             if (!xrayHolder)
69850:                 return nsnull;
69850:         } else {
55700:             wrapper = &FilteringWrapper<JSCrossCompartmentWrapper,
55700:                                         ExposedPropertiesOnly>::singleton;
69850:         }
55700:     } else if (AccessCheck::isSameOrigin(origin, target)) {
55700:         // Same origin we use a transparent wrapper, unless the compartment asks
55700:         // for an Xray or the wrapper needs a SOW.
47574:         if (AccessCheck::needsSystemOnlyWrapper(obj)) {
47574:             wrapper = &FilteringWrapper<JSCrossCompartmentWrapper,
47574:                                         OnlyIfSubjectIsSystem>::singleton;
60345:         } else if (targetdata && targetdata->wantXrays &&
60345:                    (IS_WN_WRAPPER(obj) || obj->getClass()->ext.innerObject)) {
61453:             typedef XrayWrapper<JSCrossCompartmentWrapper> Xray;
55675:             wrapper = &Xray::singleton;
55675:             xrayHolder = Xray::createHolder(cx, obj, parent);
55675:             if (!xrayHolder)
55675:                 return nsnull;
55675:         } else {
47574:             wrapper = &JSCrossCompartmentWrapper::singleton;
55675:         }
47574:     } else {
55700:         NS_ASSERTION(!AccessCheck::needsSystemOnlyWrapper(obj),
55700:                      "bad object exposed across origins");
55700: 
47574:         // Cross origin we want to disallow scripting and limit access to
47574:         // a predefined set of properties. XrayWrapper adds a property
47574:         // (.wrappedJSObject) which allows bypassing the XrayWrapper, but
47574:         // we filter out access to that property.
55653:         if (!IS_WN_WRAPPER(obj) && !obj->getClass()->ext.innerObject) {
55582:             wrapper = &FilteringWrapper<JSCrossCompartmentWrapper,
55582:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
55582:         } else {
61453:             typedef XrayWrapper<JSCrossCompartmentWrapper> Xray;
55617: 
55617:             // Location objects can become same origin after navigation, so we might
55617:             // have to grant transparent access later on.
55617:             if (IsLocationObject(obj)) {
55617:                 wrapper = &FilteringWrapper<Xray,
55617:                     SameOriginOrCrossOriginAccessiblePropertiesOnly>::singleton;
55617:             } else {
55598:                 wrapper = &FilteringWrapper<Xray,
47574:                     CrossOriginAccessiblePropertiesOnly>::singleton;
55617:             }
55617: 
55599:             xrayHolder = Xray::createHolder(cx, obj, parent);
55599:             if (!xrayHolder)
55599:                 return nsnull;
55582:         }
47574:     }
55599: 
55604:     JSObject *wrapperObj = JSWrapper::New(cx, obj, wrappedProto, parent, wrapper);
55599:     if (!wrapperObj || !xrayHolder)
55599:         return wrapperObj;
55622: 
55622:     // NB: The fact that the only wrappers to use ProxyExtra are XrayWrappers
55622:     // is relied on by XPCNativeWrapper.unwrap.
55599:     wrapperObj->setProxyExtra(js::ObjectValue(*xrayHolder));
55599:     return wrapperObj;
47525: }
47525: 
61453: typedef FilteringWrapper<XrayWrapper<JSWrapper>,
55617:                          SameOriginOrCrossOriginAccessiblePropertiesOnly> LW;
55617: 
55617: bool
55617: WrapperFactory::IsLocationObject(JSObject *obj)
55617: {
55617:     const char *name = obj->getClass()->name;
55617:     return name[0] == 'L' && !strcmp(name, "Location");
47525: }
55617: 
55617: JSObject *
55617: WrapperFactory::WrapLocationObject(JSContext *cx, JSObject *obj)
55617: {
55617:     JSObject *xrayHolder = LW::createHolder(cx, obj, obj->getParent());
55617:     if (!xrayHolder)
60580:         return nsnull;
56820:     JSObject *wrapperObj = JSWrapper::New(cx, obj, obj->getProto(), obj->getParent(),
56820:                                           &LW::singleton);
55617:     if (!wrapperObj)
60580:         return nsnull;
55617:     wrapperObj->setProxyExtra(js::ObjectValue(*xrayHolder));
55617:     return wrapperObj;
55617: }
55617: 
55696: bool
55696: WrapperFactory::WaiveXrayAndWrap(JSContext *cx, jsval *vp)
55696: {
55815:     if (JSVAL_IS_PRIMITIVE(*vp))
55815:         return JS_WrapValue(cx, vp);
55696: 
61061:     JSObject *obj = JSVAL_TO_OBJECT(*vp);
55696: 
60580:     obj = WaiveXray(cx, obj);
60580:     if (!obj)
55696:         return false;
58722: 
55696:     *vp = OBJECT_TO_JSVAL(obj);
55696:     return JS_WrapValue(cx, vp);
55696: }
55696: 
55700: JSObject *
55700: WrapperFactory::WrapSOWObject(JSContext *cx, JSObject *obj)
55700: {
55700:     JSObject *wrapperObj =
68955:         JSWrapper::New(cx, obj, obj->getProto(), JS_GetGlobalForObject(cx, obj),
55700:                        &FilteringWrapper<JSWrapper,
55700:                                          OnlyIfSubjectIsSystem>::singleton);
55700:     return wrapperObj;
55696: }
55700: 
55700: }
