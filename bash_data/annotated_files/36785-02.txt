    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:tabstop=2:expandtab:shiftwidth=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* representation of a CSS style sheet */
    1: 
    1: #ifndef nsCSSStyleSheet_h_
    1: #define nsCSSStyleSheet_h_
    1: 
    1: #include "nscore.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIDOMCSSStyleSheet.h"
    1: #include "nsICSSLoaderObserver.h"
24551: #include "nsTArray.h"
    1: #include "nsCOMArray.h"
    1: 
    1: class nsIURI;
    1: class nsMediaList;
16223: class nsMediaQueryResultCacheKey;
19019: class nsCSSStyleSheet;
    1: 
    1: // -------------------------------
    1: // CSS Style Sheet Inner Data Container
    1: //
    1: 
    1: class nsCSSStyleSheetInner {
    1: public:
19022:   nsCSSStyleSheetInner(nsICSSStyleSheet* aPrimarySheet);
19022:   nsCSSStyleSheetInner(nsCSSStyleSheetInner& aCopy,
19022:                        nsCSSStyleSheet* aPrimarySheet);
20510:   ~nsCSSStyleSheetInner();
    1: 
20510:   nsCSSStyleSheetInner* CloneFor(nsCSSStyleSheet* aPrimarySheet);
20510:   void AddSheet(nsICSSStyleSheet* aSheet);
20510:   void RemoveSheet(nsICSSStyleSheet* aSheet);
    1: 
20510:   void RebuildNameSpaces();
    1: 
20509:   // Create a new namespace map
20509:   nsresult CreateNamespaceMap();
20509: 
24551:   nsAutoTArray<nsICSSStyleSheet*, 8> mSheets;
    1:   nsCOMPtr<nsIURI>       mSheetURI; // for error reports, etc.
 7109:   nsCOMPtr<nsIURI>       mOriginalSheetURI;  // for GetHref.  Can be null.
    1:   nsCOMPtr<nsIURI>       mBaseURI; // for resolving relative URIs
  972:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1:   nsCOMArray<nsICSSRule> mOrderedRules;
    1:   nsAutoPtr<nsXMLNameSpaceMap> mNameSpaceMap;
19019:   // Linked list of child sheets.  This is al fundamentally broken, because
19019:   // each of the child sheets has a unique parent... We can only hope (and
19019:   // currently this is the case) that any time page JS can get ts hands on a
19019:   // child sheet that means we've already ensured unique inners throughout its
19019:   // parent chain and things are good.
19019:   nsRefPtr<nsCSSStyleSheet> mFirstChild;
28329:   PRBool                 mComplete;
  972: 
  972: #ifdef DEBUG
  972:   PRBool                 mPrincipalSet;
  972: #endif
    1: };
    1: 
    1: 
    1: // -------------------------------
    1: // CSS Style Sheet
    1: //
    1: 
    1: class CSSRuleListImpl;
19019: struct ChildSheetListBuilder;
    1: 
    1: class nsCSSStyleSheet : public nsICSSStyleSheet, 
    1:                         public nsIDOMCSSStyleSheet,
    1:                         public nsICSSLoaderObserver
    1: {
    1: public:
    1:   nsCSSStyleSheet();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIStyleSheet interface
    1:   NS_IMETHOD GetSheetURI(nsIURI** aSheetURI) const;
    1:   NS_IMETHOD GetBaseURI(nsIURI** aBaseURI) const;
    1:   NS_IMETHOD GetTitle(nsString& aTitle) const;
    1:   NS_IMETHOD GetType(nsString& aType) const;
    1:   NS_IMETHOD_(PRBool) HasRules() const;
    1:   NS_IMETHOD GetApplicable(PRBool& aApplicable) const;
    1:   NS_IMETHOD SetEnabled(PRBool aEnabled);
    1:   NS_IMETHOD GetComplete(PRBool& aComplete) const;
    1:   NS_IMETHOD SetComplete();
    1:   NS_IMETHOD GetParentSheet(nsIStyleSheet*& aParent) const;  // may be null
    1:   NS_IMETHOD GetOwningDocument(nsIDocument*& aDocument) const;  // may be null
    1:   NS_IMETHOD SetOwningDocument(nsIDocument* aDocument);
    1: #ifdef DEBUG
    1:   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
    1: #endif
    1:   
    1:   // nsICSSStyleSheet interface
    1:   NS_IMETHOD AppendStyleSheet(nsICSSStyleSheet* aSheet);
    1:   NS_IMETHOD InsertStyleSheetAt(nsICSSStyleSheet* aSheet, PRInt32 aIndex);
    1:   NS_IMETHOD PrependStyleRule(nsICSSRule* aRule);
    1:   NS_IMETHOD AppendStyleRule(nsICSSRule* aRule);
    1:   NS_IMETHOD ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew);
    1:   NS_IMETHOD StyleRuleCount(PRInt32& aCount) const;
    1:   NS_IMETHOD GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const;
    1:   NS_IMETHOD DeleteRuleFromGroup(nsICSSGroupRule* aGroup, PRUint32 aIndex);
    1:   NS_IMETHOD InsertRuleIntoGroup(const nsAString& aRule, nsICSSGroupRule* aGroup, PRUint32 aIndex, PRUint32* _retval);
    1:   NS_IMETHOD ReplaceRuleInGroup(nsICSSGroupRule* aGroup, nsICSSRule* aOld, nsICSSRule* aNew);
    1:   NS_IMETHOD StyleSheetCount(PRInt32& aCount) const;
    1:   NS_IMETHOD GetStyleSheetAt(PRInt32 aIndex, nsICSSStyleSheet*& aSheet) const;
 7109:   NS_IMETHOD SetURIs(nsIURI* aSheetURI, nsIURI* aOriginalSheetURI,
 7109:                      nsIURI* aBaseURI);
  972:   virtual NS_HIDDEN_(void) SetPrincipal(nsIPrincipal* aPrincipal);
  972:   virtual NS_HIDDEN_(nsIPrincipal*) Principal() const;
    1:   NS_IMETHOD SetTitle(const nsAString& aTitle);
    1:   NS_IMETHOD SetMedia(nsMediaList* aMedia);
    1:   NS_IMETHOD SetOwningNode(nsIDOMNode* aOwningNode);
    1:   NS_IMETHOD SetOwnerRule(nsICSSImportRule* aOwnerRule);
    1:   NS_IMETHOD GetOwnerRule(nsICSSImportRule** aOwnerRule);
    1:   virtual NS_HIDDEN_(nsXMLNameSpaceMap*) GetNameSpaceMap() const;
    1:   NS_IMETHOD Clone(nsICSSStyleSheet* aCloneParent,
    1:                    nsICSSImportRule* aCloneOwnerRule,
    1:                    nsIDocument* aCloneDocument,
    1:                    nsIDOMNode* aCloneOwningNode,
    1:                    nsICSSStyleSheet** aClone) const;
    1:   NS_IMETHOD IsModified(PRBool* aSheetModified) const;
    1:   NS_IMETHOD SetModified(PRBool aModified);
    1:   NS_IMETHOD AddRuleProcessor(nsCSSRuleProcessor* aProcessor);
    1:   NS_IMETHOD DropRuleProcessor(nsCSSRuleProcessor* aProcessor);
10382:   NS_IMETHOD InsertRuleInternal(const nsAString& aRule,
10382:                                 PRUint32 aIndex, PRUint32* aReturn);
25982:   NS_IMETHOD_(nsIURI*) GetOriginalURI() const;
    1: 
    1:   // nsICSSLoaderObserver interface
    1:   NS_IMETHOD StyleSheetLoaded(nsICSSStyleSheet* aSheet, PRBool aWasAlternate,
    1:                               nsresult aStatus);
    1: 
36783:   enum EnsureUniqueInnerResult {
36783:     // No work was needed to ensure a unique inner.
36783:     eUniqueInner_AlreadyUnique,
36783:     // A clone was done to ensure a unique inner (which means the style
36783:     // rules in this sheet have changed).
36783:     eUniqueInner_ClonedInner,
36783:     // A clone was attempted, but it failed.
36783:     eUniqueInner_CloneFailed
36783:   };
36783:   EnsureUniqueInnerResult EnsureUniqueInner();
    1: 
36785:   // Append all of this sheet's child sheets to aArray.  Return PR_TRUE
36785:   // on success and PR_FALSE on allocation failure.
36785:   PRBool AppendAllChildSheets(nsTArray<nsCSSStyleSheet*>& aArray);
36785: 
16223:   PRBool UseForPresentation(nsPresContext* aPresContext,
16223:                             nsMediaQueryResultCacheKey& aKey) const;
16223: 
    1:   // nsIDOMStyleSheet interface
    1:   NS_DECL_NSIDOMSTYLESHEET
    1: 
    1:   // nsIDOMCSSStyleSheet interface
    1:   NS_DECL_NSIDOMCSSSTYLESHEET
    1: 
28778:   // Function used as a callback to rebuild our inner's child sheet
28778:   // list after we clone a unique inner for ourselves.
28778:   static PRBool RebuildChildList(nsICSSRule* aRule, void* aBuilder);
28778: 
    1: private:
    1:   nsCSSStyleSheet(const nsCSSStyleSheet& aCopy,
    1:                   nsICSSStyleSheet* aParentToUse,
    1:                   nsICSSImportRule* aOwnerRuleToUse,
    1:                   nsIDocument* aDocumentToUse,
    1:                   nsIDOMNode* aOwningNodeToUse);
    1:   
    1:   // These are not supported and are not implemented! 
    1:   nsCSSStyleSheet(const nsCSSStyleSheet& aCopy); 
    1:   nsCSSStyleSheet& operator=(const nsCSSStyleSheet& aCopy); 
    1: 
    1: protected:
    1:   virtual ~nsCSSStyleSheet();
    1: 
    1:   void ClearRuleCascades();
    1: 
    1:   nsresult WillDirty();
    1:   void     DidDirty();
    1: 
 3088:   // Return success if the subject principal subsumes the principal of our
 3088:   // inner, error otherwise.  This will also succeed if the subject has
 3088:   // UniversalBrowserWrite.
 3088:   nsresult SubjectSubsumesInnerPrincipal() const;
 3088: 
20509:   // Add the namespace mapping from this @namespace rule to our namespace map
20509:   nsresult RegisterNamespaceRule(nsICSSRule* aRule);
20509: 
    1: protected:
    1:   nsString              mTitle;
    1:   nsCOMPtr<nsMediaList> mMedia;
19019:   nsRefPtr<nsCSSStyleSheet> mNext;
    1:   nsICSSStyleSheet*     mParent;    // weak ref
    1:   nsICSSImportRule*     mOwnerRule; // weak ref
    1: 
    1:   CSSRuleListImpl*      mRuleCollection;
    1:   nsIDocument*          mDocument; // weak ref; parents maintain this for their children
    1:   nsIDOMNode*           mOwningNode; // weak ref
    1:   PRPackedBool          mDisabled;
    1:   PRPackedBool          mDirty; // has been modified 
    1: 
    1:   nsCSSStyleSheetInner* mInner;
    1: 
24551:   nsAutoTArray<nsCSSRuleProcessor*, 8>* mRuleProcessors;
    1: 
    1:   friend class nsMediaList;
20113:   friend class nsCSSRuleProcessor;
  972:   friend nsresult NS_NewCSSStyleSheet(nsICSSStyleSheet** aInstancePtrResult);
19019:   friend struct ChildSheetListBuilder;
    1: };
    1: 
    1: #endif /* !defined(nsCSSStyleSheet_h_) */
