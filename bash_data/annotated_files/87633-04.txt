    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
87633: #include "TestHarness.h"
    1: #include "nsDeque.h"
    1: #include "nsCRT.h"
    1: #include <stdio.h>
    1: 
    1: /**************************************************************
    1:   Now define the token deallocator class...
    1:  **************************************************************/
    1: class _TestDeque {
    1: public:
87633:   int Test();
87633: private:
87633:   int OriginalTest();
87633:   int OriginalFlaw();
87633:   int AssignFlaw();
87633:   int TestRemove();
    1: };
    1: static _TestDeque sTestDeque;
    1: 
    1: class _Dealloc: public nsDequeFunctor {
    1:   virtual void* operator()(void* aObject) {
    1:     return 0;
    1:   }
    1: };
    1: 
87633: #define TEST(aCondition, aMsg) \
87633:   if (!(aCondition)) { fail("TestDeque: "#aMsg); return 1; }
87633: 
87633: 
    1: /**
    1:  * conduct automated self test for this class
    1:  *
    1:  * @param
    1:  * @return
    1:  */
87633: int _TestDeque::Test() {
    1:   /* the old deque should have failed a bunch of these tests */
    1:   int results=0;
    1:   results+=OriginalTest();
    1:   results+=OriginalFlaw();
    1:   results+=AssignFlaw();
87633:   results+=TestRemove();
    1:   return results;
    1: }
    1: 
87633: int _TestDeque::OriginalTest() {
87633:   const int size = 200;
87633:   int ints[size];
    1:   int i=0;
87633:   int temp;
    1:   nsDeque theDeque(new _Dealloc); //construct a simple one...
    1:  
87633:   // ints = [0...199]
87633:   for (i=0;i<size;i++) { //initialize'em
87633:     ints[i]=i;
    1:   }
87633:   // queue = [0...69]
    1:   for (i=0;i<70;i++) {
    1:     theDeque.Push(&ints[i]);
87633:     temp=*(int*)theDeque.Peek();
87633:     TEST(temp == i, "Verify end after push #1");
87633:     TEST(theDeque.GetSize() == i + 1, "Verify size after push #1");
    1:   }
87633:   TEST(theDeque.GetSize() == 70, "Verify overall size after pushes #1");
87633:   // queue = [0...14]
87633:   for (i=1;i<=55;i++) {
87633:     temp=*(int*)theDeque.Pop();
87633:     TEST(temp == 70-i, "Verify end after pop # 1");
87633:     TEST(theDeque.GetSize() == 70 - i, "Verify size after pop # 1");
    1:   }
87633:   TEST(theDeque.GetSize() == 15, "Verify overall size after pops");
87633: 
87633:   // queue = [0...14,0...54]
    1:   for (i=0;i<55;i++) {
    1:     theDeque.Push(&ints[i]);
87633:     temp=*(int*)theDeque.Peek();
87633:     TEST(temp == i, "Verify end after push #2");
87633:     TEST(theDeque.GetSize() == i + 15 + 1, "Verify size after push # 2");
    1:   }
87633:   TEST(theDeque.GetSize() == 70, "Verify size after end of all pushes #2");
87633: 
87633:   // queue = [0...14,0...19]
87633:   for (i=1;i<=35;i++) {
87633:     temp=*(int*)theDeque.Pop();
87633:     TEST(temp == 55-i, "Verify end after pop # 2");
87633:     TEST(theDeque.GetSize() == 70 - i, "Verify size after pop #2");
    1:   }
87633:   TEST(theDeque.GetSize() == 35, "Verify overall size after end of all pops #2");
87633: 
87633:   // queue = [0...14,0...19,0...34]
    1:   for (i=0;i<35;i++) {
    1:     theDeque.Push(&ints[i]);
87633:     temp = *(int*)theDeque.Peek();
87633:     TEST(temp == i, "Verify end after push # 3");
87633:     TEST(theDeque.GetSize() == 35 + 1 + i, "Verify size after push #3");
    1:   }
    1: 
87633:   // queue = [0...14,0...19]
87633:   for (i=0;i<35;i++) {
87633:     temp=*(int*)theDeque.Pop();
87633:     TEST(temp == 34 - i, "Verify end after pop # 3");
87633:   }
87633: 
87633:   // queue = [0...14]
87633:   for (i=0;i<20;i++) {
87633:     temp=*(int*)theDeque.Pop();
87633:     TEST(temp == 19 - i, "Verify end after pop # 4");
87633:   }
87633: 
87633:   // queue = []
87633:   for (i=0;i<15;i++) {
87633:     temp=*(int*)theDeque.Pop();
87633:     TEST(temp == 14 - i, "Verify end after pop # 5");
87633:   }
87633: 
87633:   TEST(theDeque.GetSize() == 0, "Deque should finish empty.");
87633: 
87633:   return 0;
87633: }
87633: 
87633: int _TestDeque::OriginalFlaw() {
    1:   int ints[200];
    1:   int i=0;
87633:   int temp;
87633:   nsDeque d(new _Dealloc);
    1:   /**
    1:    * Test 1. Origin near end, semi full, call Peek().
    1:    * you start, mCapacity is 8
    1:    */
    1:   printf("fill array\n");
87633:   for (i=0; i<30; i++)
87633:     ints[i]=i;
87633: 
87633:   for (i=0; i<6; i++) {
87633:     d.Push(&ints[i]);
87633:     temp = *(int*)d.Peek();
87633:     TEST(temp == i, "OriginalFlaw push #1");
    1:   }
87633:   TEST(d.GetSize() == 6, "OriginalFlaw size check #1");
    1: 
87633:   for (i=0; i<4; i++) {
87633:     temp=*(int*)d.PopFront();
87633:     TEST(temp == i, "PopFront test");
87633:   }
87633:   // d = [4,5]
87633:   TEST(d.GetSize() == 2, "OriginalFlaw size check #2");
    1: 
87633:   for (i=0; i<4; i++) {
87633:     d.Push(&ints[6 + i]);
87633:   }
87633:   // d = [4...9]
    1: 
87633:   for (i=4; i<=9; i++) {
87633:     temp=*(int*)d.PopFront();
87633:     TEST(temp == i, "OriginalFlaw empty check");
    1:   }
    1: 
87633:   return 0;
87633: }
87633: 
87633: int _TestDeque::AssignFlaw() {
    1:   nsDeque src(new _Dealloc),dest(new _Dealloc);
87633:   return 0;
87633: }
87633: 
87633: static bool VerifyContents(const nsDeque& aDeque, const int* aContents, int aLength) {
87633:   for (int i=0; i<aLength; ++i) {
87633:     if (*(int*)aDeque.ObjectAt(i) != aContents[i]) {
87633:       return false;
87633:     }
87633:   }
87633:   return true;
87633: }
87633: 
87633: int _TestDeque::TestRemove() {
87633:   nsDeque d;
87633:   const int count = 10;
87633:   int ints[count];
87633:   for (int i=0; i<count; i++) {
87633:     ints[i] = i;
87633:   }
87633: 
87633:   for (int i=0; i<6; i++) {
87633:     d.Push(&ints[i]);
87633:   }
87633:   // d = [0...5]
87633:   d.PopFront();
87633:   d.PopFront();
87633: 
87633:   // d = [2,5]
87633:   for (int i=2; i<=5; i++) {
87633:     int t = *(int*)d.ObjectAt(i-2);
87633:     TEST(t == i, "Verify ObjectAt()");
87633:   }
87633: 
87633:   d.RemoveObjectAt(1);
87633:   // d == [2,4,5]
87633:   static const int t1[] = {2,4,5};
87633:   TEST(VerifyContents(d, t1, 3), "verify contents t1");
87633: 
87633:   d.PushFront(&ints[1]);
87633:   d.PushFront(&ints[0]);
87633:   d.PushFront(&ints[7]);
87633:   d.PushFront(&ints[6]);
87633:   //  d == [6,7,0,1,2,4,5] // (0==mOrigin)
87633:   static const int t2[] = {6,7,0,1,2,4,5};
87633:   TEST(VerifyContents(d, t2, 7), "verify contents t2");
87633: 
87633:   d.RemoveObjectAt(1);
87633:   //  d == [6,0,1,2,4,5] // (1==mOrigin)
87633:   static const int t3[] = {6,0,1,2,4,5};
87633:   TEST(VerifyContents(d, t3, 6), "verify contents t3");
87633: 
87633:   d.RemoveObjectAt(5);
87633:   //  d == [6,0,1,2,4] // (1==mOrigin)
87633:   static const int t4[] = {6,0,1,2,4};
87633:   TEST(VerifyContents(d, t4, 5), "verify contents t4");
87633: 
87633:   d.RemoveObjectAt(0);
87633:   //  d == [0,1,2,4] // (2==mOrigin)
87633:   static const int t5[] = {0,1,2,4};
87633:   TEST(VerifyContents(d, t5, 4), "verify contents t5");
87633: 
87633: 
87633:   return 0;
    1: }
    1: 
    1: int main (void) {
87633:   ScopedXPCOM xpcom("TestTimers");
87633:   NS_ENSURE_FALSE(xpcom.failed(), 1);
87633: 
    1:   _TestDeque test;
87633:   int result = test.Test();
87633:   TEST(result == 0, "All tests pass");
    1:   return 0;
    1: }
