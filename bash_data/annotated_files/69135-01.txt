    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is Netscape
    1:  * Communications Corporation. Portions created by Netscape are
    1:  * Copyright (C) 1999 Netscape Communications Corporation. All
    1:  * Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *   Steve Dagley <sdagley@netscape.com>
    1:  *   David Haas <haasd@cae.wisc.edu>
    1:  *   Simon Fraser <sfraser@netscape.com>
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
12428: #import <Cocoa/Cocoa.h>
    1: 
12428: #include "nsFilePicker.h"
11881: #include "nsObjCExceptions.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsILocalFile.h"
    1: #include "nsILocalFileMac.h"
    1: #include "nsIURL.h"
    1: #include "nsArrayEnumerator.h"
    1: #include "nsIStringBundle.h"
12428: #include "nsIPrefService.h"
12428: #include "nsIPrefBranch.h"
13608: #include "nsCocoaUtils.h"
68781: #include "nsToolkit.h"
    1: 
    1: const float kAccessoryViewPadding = 5;
    1: const int   kSaveTypeControlTag = 1;
12428: const char  kLastTypeIndexPref[] = "filepicker.lastTypeIndex";
    1: 
27947: static PRBool gCallSecretHiddenFileAPI = PR_FALSE;
27947: const char kShowHiddenFilesPref[] = "filepicker.showHiddenFiles";
27947: 
68781: /**
68781:  * This class is an observer of NSPopUpButton selection change.
68781:  */
68781: @interface NSPopUpButtonObserver : NSObject
68781: {
68781:   NSPopUpButton* mPopUpButton;
68781:   NSOpenPanel*   mOpenPanel;
68781:   nsFilePicker*  mFilePicker;
68781: }
68781: - (void) setPopUpButton:(NSPopUpButton*)aPopUpButton;
68781: - (void) setOpenPanel:(NSOpenPanel*)aOpenPanel;
68781: - (void) setFilePicker:(nsFilePicker*)aFilePicker;
68781: - (void) menuChangedItem:(NSNotification*)aSender;
68781: @end
68781: 
    1: NS_IMPL_ISUPPORTS1(nsFilePicker, nsIFilePicker)
    1: 
27947: // We never want to call the secret show hidden files API unless the pref
27947: // has been set. Once the pref has been set we always need to call it even
27947: // if it disappears so that we stop showing hidden files if a user deletes
27947: // the pref. If the secret API was used once and things worked out it should
27947: // continue working for subsequent calls so the user is at no more risk.
27947: static void SetShowHiddenFileState(NSSavePanel* panel)
27947: {
27947:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
27947: 
27947:   PRBool show = PR_FALSE;
27947:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
27947:   if (prefs) {
27947:     nsresult rv = prefs->GetBoolPref(kShowHiddenFilesPref, &show);
27947:     if (NS_SUCCEEDED(rv))
27947:       gCallSecretHiddenFileAPI = PR_TRUE;
27947:   }
27947: 
27947:   if (gCallSecretHiddenFileAPI) {
27947:     // invoke a method to get a Cocoa-internal nav view
27947:     SEL navViewSelector = @selector(_navView);
27947:     NSMethodSignature* navViewSignature = [panel methodSignatureForSelector:navViewSelector];
27947:     if (!navViewSignature)
27947:       return;
27947:     NSInvocation* navViewInvocation = [NSInvocation invocationWithMethodSignature:navViewSignature];
27947:     [navViewInvocation setSelector:navViewSelector];
27947:     [navViewInvocation setTarget:panel];
27947:     [navViewInvocation invoke];
27947: 
27947:     // get the returned nav view
27947:     id navView = nil;
27947:     [navViewInvocation getReturnValue:&navView];
27947: 
27947:     // invoke the secret show hidden file state method on the nav view
27947:     SEL showHiddenFilesSelector = @selector(setShowsHiddenFiles:);
27947:     NSMethodSignature* showHiddenFilesSignature = [navView methodSignatureForSelector:showHiddenFilesSelector];
27947:     if (!showHiddenFilesSignature)
27947:       return;
27947:     NSInvocation* showHiddenFilesInvocation = [NSInvocation invocationWithMethodSignature:showHiddenFilesSignature];
27947:     [showHiddenFilesInvocation setSelector:showHiddenFilesSelector];
27947:     [showHiddenFilesInvocation setTarget:navView];
27947:     [showHiddenFilesInvocation setArgument:&show atIndex:2];
27947:     [showHiddenFilesInvocation invoke];
27947:   }
27947: 
27947:   NS_OBJC_END_TRY_ABORT_BLOCK;
27947: }
12428: 
    1: nsFilePicker::nsFilePicker()
12428: : mMode(0)
12428: , mSelectedTypeIndex(0)
    1: {
    1: }
    1: 
    1: nsFilePicker::~nsFilePicker()
    1: {
    1: }
    1: 
    1: void
    1: nsFilePicker::InitNative(nsIWidget *aParent, const nsAString& aTitle,
    1:                          PRInt16 aMode)
    1: {
    1:   mTitle = aTitle;
    1:   mMode = aMode;
12428: 
12428:   // read in initial type index from prefs
12428:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
12428:   if (prefs) {
12428:     int prefIndex;
12428:     if (NS_SUCCEEDED(prefs->GetIntPref(kLastTypeIndexPref, &prefIndex)))
12428:       mSelectedTypeIndex = prefIndex;
    1:   }
12428: }
12428: 
    1: NSView* nsFilePicker::GetAccessoryView()
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11881: 
    1:   NSView* accessoryView = [[[NSView alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)] autorelease];
    1: 
68781:   // Set a label's default value.
68781:   NSString* label = @"Format:";
68781: 
68781:   // Try to get the localized string.
    1:   nsCOMPtr<nsIStringBundleService> sbs = do_GetService(NS_STRINGBUNDLE_CONTRACTID);
    1:   nsCOMPtr<nsIStringBundle> bundle;
    1:   nsresult rv = sbs->CreateBundle("chrome://global/locale/filepicker.properties", getter_AddRefs(bundle));
    1:   if (NS_SUCCEEDED(rv)) {
68781:     nsXPIDLString locaLabel;
68781:     bundle->GetStringFromName(NS_LITERAL_STRING("formatLabel").get(),
68781: 			      getter_Copies(locaLabel));
68781:     if (locaLabel) {
68781:       label = [NSString stringWithCharacters:locaLabel.get() length:locaLabel.Length()];
68781:     }
    1:   }
    1: 
    1:   // set up label text field
    1:   NSTextField* textField = [[[NSTextField alloc] init] autorelease];
    1:   [textField setEditable:NO];
    1:   [textField setSelectable:NO];
    1:   [textField setDrawsBackground:NO];
    1:   [textField setBezeled:NO];
    1:   [textField setBordered:NO];
    1:   [textField setFont:[NSFont labelFontOfSize:13.0]];
68781:   [textField setStringValue:label];
    1:   [textField setTag:0];
    1:   [textField sizeToFit];
    1: 
    1:   // set up popup button
    1:   NSPopUpButton* popupButton = [[[NSPopUpButton alloc] initWithFrame:NSMakeRect(0, 0, 0, 0) pullsDown:NO] autorelease];
24835:   PRUint32 numMenuItems = mTitles.Length();
24835:   for (PRUint32 i = 0; i < numMenuItems; i++) {
23904:     const nsString& currentTitle = mTitles[i];
11618:     NSString *titleString;
11618:     if (currentTitle.IsEmpty()) {
23904:       const nsString& currentFilter = mFilters[i];
11618:       titleString = [[NSString alloc] initWithCharacters:currentFilter.get()
11618:                                                   length:currentFilter.Length()];
11618:     }
11618:     else {
11618:       titleString = [[NSString alloc] initWithCharacters:currentTitle.get()
    1:                                                   length:currentTitle.Length()];
11618:     }
    1:     [popupButton addItemWithTitle:titleString];
    1:     [titleString release];
    1:   }
29633:   if (mSelectedTypeIndex >= 0 && (PRUint32)mSelectedTypeIndex < numMenuItems)
12428:     [popupButton selectItemAtIndex:mSelectedTypeIndex];
    1:   [popupButton setTag:kSaveTypeControlTag];
11618:   [popupButton sizeToFit]; // we have to do sizeToFit to get the height calculated for us
11618:   // This is just a default width that works well, doesn't truncate the vast majority of
11618:   // things that might end up in the menu.
11618:   [popupButton setFrameSize:NSMakeSize(180, [popupButton frame].size.height)];
    1: 
    1:   // position everything based on control sizes with kAccessoryViewPadding pix padding
    1:   // on each side kAccessoryViewPadding pix horizontal padding between controls
    1:   float greatestHeight = [textField frame].size.height;
    1:   if ([popupButton frame].size.height > greatestHeight)
    1:     greatestHeight = [popupButton frame].size.height;
    1:   float totalViewHeight = greatestHeight + kAccessoryViewPadding * 2;
    1:   float totalViewWidth  = [textField frame].size.width + [popupButton frame].size.width + kAccessoryViewPadding * 3;
    1:   [accessoryView setFrameSize:NSMakeSize(totalViewWidth, totalViewHeight)];
    1: 
    1:   float textFieldOriginY = ((greatestHeight - [textField frame].size.height) / 2 + 1) + kAccessoryViewPadding;
    1:   [textField setFrameOrigin:NSMakePoint(kAccessoryViewPadding, textFieldOriginY)];
    1:   
    1:   float popupOriginX = [textField frame].size.width + kAccessoryViewPadding * 2;
    1:   float popupOriginY = ((greatestHeight - [popupButton frame].size.height) / 2) + kAccessoryViewPadding;
    1:   [popupButton setFrameOrigin:NSMakePoint(popupOriginX, popupOriginY)];
    1: 
    1:   [accessoryView addSubview:textField];
    1:   [accessoryView addSubview:popupButton];
    1:   return accessoryView;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
12428: // Display the file dialog
    1: NS_IMETHODIMP nsFilePicker::Show(PRInt16 *retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(retval);
    1: 
    1:   *retval = returnCancel;
    1: 
    1:   PRInt16 userClicksOK = returnCancel;
    1: 
    1: // Random questions from DHH:
    1: //
    1: // Why do we pass mTitle, mDefault to the functions?  Can GetLocalFile. PutLocalFile,
    1: // and GetLocalFolder get called someplace else?  It generates a bunch of warnings
    1: // as it is right now.
    1: //
    1: // I think we could easily combine GetLocalFile and GetLocalFolder together, just
    1: // setting panel pick options based on mMode.  I didn't do it here b/c I wanted to 
    1: // make this look as much like Carbon nsFilePicker as possible.  
    1: 
    1:   mFiles.Clear();
    1:   nsCOMPtr<nsILocalFile> theFile;
    1: 
    1:   switch (mMode)
    1:   {
    1:     case modeOpen:
68781:       userClicksOK = GetLocalFiles(mTitle, PR_FALSE, mFiles);
    1:       break;
    1:     
    1:     case modeOpenMultiple:
68781:       userClicksOK = GetLocalFiles(mTitle, PR_TRUE, mFiles);
    1:       break;
    1:       
    1:     case modeSave:
    1:       userClicksOK = PutLocalFile(mTitle, mDefault, getter_AddRefs(theFile));
    1:       break;
    1:       
    1:     case modeGetFolder:
    1:       userClicksOK = GetLocalFolder(mTitle, getter_AddRefs(theFile));
    1:       break;
    1:     
    1:     default:
31561:       NS_ERROR("Unknown file picker mode");
    1:       break;
    1:   }
    1: 
    1:   if (theFile)
    1:     mFiles.AppendObject(theFile);
    1:   
    1:   *retval = userClicksOK;
    1:   return NS_OK;
    1: }
    1: 
68781: @implementation NSPopUpButtonObserver
68781: - (void) setPopUpButton:(NSPopUpButton*)aPopUpButton
68781: {
68781:   mPopUpButton = aPopUpButton;
68781: }
68781: 
68781: - (void) setOpenPanel:(NSOpenPanel*)aOpenPanel
68781: {
68781:   mOpenPanel = aOpenPanel;
68781: }
68781: 
68781: - (void) setFilePicker:(nsFilePicker*)aFilePicker
68781: {
68781:   mFilePicker = aFilePicker;
68781: }
68781: 
68781: - (void) menuChangedItem:(NSNotification *)aSender
68781: {
68781:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
68781:   PRInt32 selectedItem = [mPopUpButton indexOfSelectedItem];
68781:   if (selectedItem < 0) {
68781:     return;
68781:   }
68781: 
68781:   mFilePicker->SetFilterIndex(selectedItem);
68781:   NSArray* filters = mFilePicker->GetFilterList();
68781:   [mOpenPanel setAllowedFileTypes:filters];
68781: 
68781:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN();
68781: }
68781: @end
68781: 
    1: // Use OpenPanel to do a GetFile. Returns |returnOK| if the user presses OK in the dialog. 
    1: PRInt16
68781: nsFilePicker::GetLocalFiles(const nsString& inTitle, PRBool inAllowMultiple, nsCOMArray<nsILocalFile>& outFiles)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11881: 
    1:   PRInt16 retVal = (PRInt16)returnCancel;
    1:   NSOpenPanel *thePanel = [NSOpenPanel openPanel];
    1: 
27947:   SetShowHiddenFileState(thePanel);
27947: 
    1:   // Get filters
    1:   // filters may be null, if we should allow all file types.
68781:   NSArray *filters = GetFilterList();
    1: 
    1:   // Set the options for how the get file dialog will appear
    1:   SetDialogTitle(inTitle, thePanel);
    1:   [thePanel setAllowsMultipleSelection:inAllowMultiple];
    1:   [thePanel setCanSelectHiddenExtension:YES];
    1:   [thePanel setCanChooseDirectories:NO];
    1:   [thePanel setCanChooseFiles:YES];
    1:   [thePanel setResolvesAliases:YES];        //this is default - probably doesn't need to be set
    1:   
    1:   // if we show all file types, also "expose" bundles' contents.
    1:   if (!filters)
    1:     [thePanel setTreatsFilePackagesAsDirectories:NO];       
    1: 
    1:   // set up default directory
    1:   NSString *theDir = PanelDefaultDirectory();
    1:   
    1:   // if this is the "Choose application..." dialog, and no other start
    1:   // dir has been set, then use the Applications folder.
    1:   if (!theDir && filters && [filters count] == 1 && 
    1:       [(NSString *)[filters objectAtIndex:0] isEqualToString:@"app"]) {
    1:     theDir = @"/Applications/";
    1:   }
    1: 
68781:   // On 10.6+, we let users change the filters. Unfortunately, some methods
68781:   // are not available on 10.5 and without using them it happens to be buggy.
68781:   int result;
13608:   nsCocoaUtils::PrepareForNativeAppModalDialog();
68781:   if (nsToolkit::OnSnowLeopardOrLater()) {
69135:     // [NSURL initWithString:] (below) throws an exception if URLString is nil.
69135:     if (!theDir) {
69135:       theDir = @"";
69135:     }
69135: 
68781:     NSPopUpButtonObserver* observer = [[NSPopUpButtonObserver alloc] init];
68781: 
68781:     NSView* accessoryView = GetAccessoryView();
68781:     [thePanel setAccessoryView:accessoryView];
68781: 
68781:     [observer setPopUpButton:[accessoryView viewWithTag:kSaveTypeControlTag]];
68781:     [observer setOpenPanel:thePanel];
68781:     [observer setFilePicker:this];
68781: 
68781:     [[NSNotificationCenter defaultCenter]
68781:       addObserver:observer
68781:       selector:@selector(menuChangedItem:)
68781:       name:NSMenuWillSendActionNotification object:nil];
68781: 
68781:     [thePanel setDirectoryURL:[[NSURL alloc] initWithString:theDir]];
68781:     [thePanel setAllowedFileTypes:filters];
68781:     result = [thePanel runModal];
68781: 
68781:     [[NSNotificationCenter defaultCenter] removeObserver:observer];
68781:     [observer release];
68781:   } else {
68781:     result = [thePanel runModalForDirectory:theDir file:nil types:filters];
68781:   }
13608:   nsCocoaUtils::CleanUpAfterNativeAppModalDialog();
    1:   
    1:   if (result == NSFileHandlingPanelCancelButton)
    1:     return retVal;
    1:   
    1:   // append each chosen file to our list
    1:   for (unsigned int i = 0; i < [[thePanel URLs] count]; i++) {
    1:     NSURL *theURL = [[thePanel URLs] objectAtIndex:i];
    1:     if (theURL) {
    1:       nsCOMPtr<nsILocalFile> localFile;
    1:       NS_NewLocalFile(EmptyString(), PR_TRUE, getter_AddRefs(localFile));
    1:       nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(localFile);
    1:       if (macLocalFile && NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)theURL)))
    1:         outFiles.AppendObject(localFile);
    1:     }
    1:   }
    1: 
    1:   if (outFiles.Count() > 0)
    1:     retVal = returnOK;
    1: 
    1:   return retVal;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
12428: }
    1: 
    1: // Use OpenPanel to do a GetFolder. Returns |returnOK| if the user presses OK in the dialog.
    1: PRInt16
    1: nsFilePicker::GetLocalFolder(const nsString& inTitle, nsILocalFile** outFile)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
47298:   NS_ASSERTION(outFile, "this protected member function expects a null initialized out pointer");
    1:   
    1:   PRInt16 retVal = (PRInt16)returnCancel;
    1:   NSOpenPanel *thePanel = [NSOpenPanel openPanel];
    1: 
27947:   SetShowHiddenFileState(thePanel);
27947: 
    1:   // Set the options for how the get file dialog will appear
    1:   SetDialogTitle(inTitle, thePanel);
    1:   [thePanel setAllowsMultipleSelection:NO];   //this is default -probably doesn't need to be set
    1:   [thePanel setCanSelectHiddenExtension:YES];
    1:   [thePanel setCanChooseDirectories:YES];
    1:   [thePanel setCanChooseFiles:NO];
    1:   [thePanel setResolvesAliases:YES];          //this is default - probably doesn't need to be set
    1:   [thePanel setCanCreateDirectories:YES];
    1:   
    1:   // packages != folders
    1:   [thePanel setTreatsFilePackagesAsDirectories:NO];
    1: 
    1:   // set up default directory
    1:   NSString *theDir = PanelDefaultDirectory();
13608:   nsCocoaUtils::PrepareForNativeAppModalDialog();
    1:   int result = [thePanel runModalForDirectory:theDir file:nil types:nil];  
13608:   nsCocoaUtils::CleanUpAfterNativeAppModalDialog();
    1: 
    1:   if (result == NSFileHandlingPanelCancelButton)
    1:     return retVal;
    1: 
    1:   // get the path for the folder (we allow just 1, so that's all we get)
    1:   NSURL *theURL = [[thePanel URLs] objectAtIndex:0];
    1:   if (theURL) {
    1:     nsCOMPtr<nsILocalFile> localFile;
    1:     NS_NewLocalFile(EmptyString(), PR_TRUE, getter_AddRefs(localFile));
    1:     nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(localFile);
    1:     if (macLocalFile && NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)theURL))) {
    1:       *outFile = localFile;
    1:       NS_ADDREF(*outFile);
    1:       retVal = returnOK;
    1:     }
    1:   }
    1: 
    1:   return retVal;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
12428: }
    1: 
12428: // Returns |returnOK| if the user presses OK in the dialog.
    1: PRInt16
    1: nsFilePicker::PutLocalFile(const nsString& inTitle, const nsString& inDefaultName, nsILocalFile** outFile)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
47298:   NS_ASSERTION(outFile, "this protected member function expects a null initialized out pointer");
    1: 
    1:   PRInt16 retVal = returnCancel;
    1:   NSSavePanel *thePanel = [NSSavePanel savePanel];
    1: 
27947:   SetShowHiddenFileState(thePanel);
27947: 
    1:   SetDialogTitle(inTitle, thePanel);
    1: 
    1:   // set up accessory view for file format options
    1:   NSView* accessoryView = GetAccessoryView();
    1:   [thePanel setAccessoryView:accessoryView];
    1: 
    1:   // set up default file name
    1:   NSString* defaultFilename = [NSString stringWithCharacters:(const unichar*)inDefaultName.get() length:inDefaultName.Length()];
    1: 
    1:   // set up default directory
    1:   NSString *theDir = PanelDefaultDirectory();
    1: 
    1:   // load the panel
13608:   nsCocoaUtils::PrepareForNativeAppModalDialog();
13608:   int result = [thePanel runModalForDirectory:theDir file:defaultFilename];
13608:   nsCocoaUtils::CleanUpAfterNativeAppModalDialog();
13608:   if (result == NSFileHandlingPanelCancelButton)
    1:     return retVal;
    1: 
    1:   // get the save type
    1:   NSPopUpButton* popupButton = [accessoryView viewWithTag:kSaveTypeControlTag];
12428:   if (popupButton) {
12428:     mSelectedTypeIndex = [popupButton indexOfSelectedItem];
12428:     // save out to prefs for initializing other file picker instances
12428:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
12428:     if (prefs)
12428:       prefs->SetIntPref(kLastTypeIndexPref, mSelectedTypeIndex);
12428:   }
    1: 
    1:   NSURL* fileURL = [thePanel URL];
    1:   if (fileURL) { 
    1:     nsCOMPtr<nsILocalFile> localFile;
    1:     NS_NewLocalFile(EmptyString(), PR_TRUE, getter_AddRefs(localFile));
    1:     nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(localFile);
    1:     if (macLocalFile && NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)fileURL))) {
    1:       *outFile = localFile;
    1:       NS_ADDREF(*outFile);
    1:       // We tell if we are replacing or not by just looking to see if the file exists.
    1:       // The user could not have hit OK and not meant to replace the file.
    1:       if ([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]])
    1:         retVal = returnReplace;
    1:       else
    1:         retVal = returnOK;
    1:     }
    1:   }
    1: 
    1:   return retVal;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
    1: }
    1: 
    1: NSArray *
68781: nsFilePicker::GetFilterList()
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11881: 
64577:   if (mFilters.Length() <= (PRUint32)mSelectedTypeIndex) {
    1:     return nil;
    1:   }
64577: 
64577:   const nsString& filterWide = mFilters[mSelectedTypeIndex];
64577:   if (!filterWide.Length()) {
64577:     return nil;
    1:   }
    1: 
64577:   if (filterWide.Equals(NS_LITERAL_STRING("*"))) {
64577:     return nil;
    1:   }
    1: 
64577:   // The extensions in filterWide are in the format "*.ext" but are expected
64577:   // in the format "ext" by NSOpenPanel. So we need to filter some characters.
64577:   NSMutableString* filterString = [[[NSMutableString alloc] initWithString:
64577:                                     [NSString stringWithCharacters:filterWide.get()
64577: 				              length:filterWide.Length()]] autorelease];
64577:   NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:
64577:                           [NSString stringWithString:@". *"]];
64577:   NSRange range = [filterString rangeOfCharacterFromSet:set];
64577:   while (range.length) {
64577:     [filterString replaceCharactersInRange:range withString:@""];
64577:     range = [filterString rangeOfCharacterFromSet:set];
    1:   }
64577: 
64577:   return [[[NSArray alloc] initWithArray:
64577:            [filterString componentsSeparatedByString:@";"]] autorelease];
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
12428: }
    1: 
    1: // Sets the dialog title to whatever it should be.  If it fails, eh,
    1: // the OS will provide a sensible default.
    1: void
    1: nsFilePicker::SetDialogTitle(const nsString& inTitle, id aPanel)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11881: 
    1:   [aPanel setTitle:[NSString stringWithCharacters:(const unichar*)inTitle.get() length:inTitle.Length()]];
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: } 
    1: 
    1: // Converts path from an nsILocalFile into a NSString path
    1: // If it fails, returns an empty string.
    1: NSString *
    1: nsFilePicker::PanelDefaultDirectory()
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11881: 
    1:   NSString *directory = nil;
    1:   if (mDisplayDirectory) {
    1:     nsAutoString pathStr;
    1:     mDisplayDirectory->GetPath(pathStr);
    1:     directory = [[[NSString alloc] initWithCharacters:pathStr.get() length:pathStr.Length()] autorelease];
    1:   }
    1:   return directory;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: NS_IMETHODIMP nsFilePicker::GetFile(nsILocalFile **aFile)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFile);
    1:   *aFile = nsnull;
    1:   
    1:   // just return the first file
12428:   if (mFiles.Count() > 0) {
    1:     *aFile = mFiles.ObjectAt(0);
    1:     NS_IF_ADDREF(*aFile);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
12264: NS_IMETHODIMP nsFilePicker::GetFileURL(nsIURI **aFileURL)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFileURL);
    1:   *aFileURL = nsnull;
    1: 
    1:   if (mFiles.Count() == 0)
    1:     return NS_OK;
    1: 
12264:   return NS_NewFileURI(aFileURL, mFiles.ObjectAt(0));
    1: }
    1: 
    1: NS_IMETHODIMP nsFilePicker::GetFiles(nsISimpleEnumerator **aFiles)
    1: {
    1:   return NS_NewArrayEnumerator(aFiles, mFiles);
    1: }
    1: 
    1: NS_IMETHODIMP nsFilePicker::SetDefaultString(const nsAString& aString)
    1: {
    1:   mDefault = aString;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsFilePicker::GetDefaultString(nsAString& aString)
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // The default extension to use for files
    1: NS_IMETHODIMP nsFilePicker::GetDefaultExtension(nsAString& aExtension)
    1: {
    1:   aExtension.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsFilePicker::SetDefaultExtension(const nsAString& aExtension)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Append an entry to the filters array
    1: NS_IMETHODIMP
    1: nsFilePicker::AppendFilter(const nsAString& aTitle, const nsAString& aFilter)
    1: {
64577:   // "..apps" has to be translated with native executable extensions.
64577:   if (aFilter.EqualsLiteral("..apps")) {
64577:     mFilters.AppendElement(NS_LITERAL_STRING("*.app"));
64577:   } else {
23904:     mFilters.AppendElement(aFilter);
64577:   }
23904:   mTitles.AppendElement(aTitle);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // Get the filter index - do we still need this?
    1: NS_IMETHODIMP nsFilePicker::GetFilterIndex(PRInt32 *aFilterIndex)
    1: {
12428:   *aFilterIndex = mSelectedTypeIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: // Set the filter index - do we still need this?
    1: NS_IMETHODIMP nsFilePicker::SetFilterIndex(PRInt32 aFilterIndex)
    1: {
12428:   mSelectedTypeIndex = aFilterIndex;
    1:   return NS_OK;
    1: }
