52557: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52557:  * vim: set ts=4 sw=4 et tw=99:
52557:  *
52557:  * ***** BEGIN LICENSE BLOCK *****
52557:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52557:  *
52557:  * The contents of this file are subject to the Mozilla Public License Version
52557:  * 1.1 (the "License"); you may not use this file except in compliance with
52557:  * the License. You may obtain a copy of the License at
52557:  * http://www.mozilla.org/MPL/
52557:  *
52557:  * Software distributed under the License is distributed on an "AS IS" basis,
52557:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52557:  * for the specific language governing rights and limitations under the
52557:  * License.
52557:  *
52557:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52557:  * May 28, 2008.
52557:  *
52557:  * The Initial Developer of the Original Code is
52557:  *   Brendan Eich <brendan@mozilla.org>
52557:  *
52557:  * Contributor(s):
52557:  *   David Anderson <danderson@mozilla.com>
52557:  *   David Mandelin <dmandelin@mozilla.com>
52557:  *
52557:  * Alternatively, the contents of this file may be used under the terms of
52557:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52557:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52557:  * in which case the provisions of the GPL or the LGPL are applicable instead
52557:  * of those above. If you wish to allow use of your version of this file only
52557:  * under the terms of either the GPL or the LGPL, and not to allow others to
52557:  * use your version of this file under the terms of the MPL, indicate your
52557:  * decision by deleting the provisions above and replace them with the notice
52557:  * and other provisions required by the GPL or the LGPL. If you do not delete
52557:  * the provisions above, a recipient may use your version of this file under
52557:  * the terms of any one of the MPL, the GPL or the LGPL.
52557:  *
52557:  * ***** END LICENSE BLOCK ***** */
52557: 
52557: #include "jscntxt.h"
52557: #include "jsscope.h"
52557: #include "jsobj.h"
52557: #include "jslibmath.h"
52557: #include "jsiter.h"
52557: #include "jsnum.h"
52557: #include "jsxml.h"
52557: #include "jsstaticcheck.h"
52557: #include "jsbool.h"
52557: #include "assembler/assembler/MacroAssemblerCodeRef.h"
52557: #include "jsiter.h"
52557: #include "jstypes.h"
53168: #include "methodjit/Compiler.h"
52608: #include "methodjit/StubCalls.h"
52557: #include "jstracer.h"
52557: #include "jspropertycache.h"
52557: #include "jspropertycacheinlines.h"
52557: #include "jsscopeinlines.h"
52557: #include "jsscriptinlines.h"
52557: #include "jsstrinlines.h"
52557: #include "jsobjinlines.h"
52557: #include "jscntxtinlines.h"
52696: #include "jsatominlines.h"
52880: #include "StubCalls-inl.h"
52897: #ifdef XP_WIN
52897: # include "jswin.h"
52897: #endif
52557: 
52557: #include "jsautooplen.h"
52557: 
52557: using namespace js;
52557: using namespace js::mjit;
52557: using namespace JSC;
52557: 
52789: void JS_FASTCALL
53473: stubs::BindName(VMFrame &f)
52608: {
52608:     PropertyCacheEntry *entry;
52608: 
52608:     /* Fast-path should have caught this. See comment in interpreter. */
53482:     JS_ASSERT(f.fp()->getScopeChain()->getParent());
52608: 
52608:     JSAtom *atom;
52608:     JSObject *obj2;
52608:     JSContext *cx = f.cx;
53482:     JSObject *obj = f.fp()->getScopeChain();
52608:     JS_PROPERTY_CACHE(cx).test(cx, f.regs.pc, obj, obj2, entry, atom);
52789:     if (atom) {
52608:         jsid id = ATOM_TO_JSID(atom);
53482:         obj = js_FindIdentifierBase(cx, f.fp()->getScopeChain(), id);
52608:         if (!obj)
52789:             THROW();
52789:     }
52789:     f.regs.sp++;
53023:     f.regs.sp[-1].setObject(*obj);
52608: }
52608: 
52826: JSObject * JS_FASTCALL
53473: stubs::BindGlobalName(VMFrame &f)
52826: {
53482:     return f.fp()->getScopeChain()->getGlobal();
52826: }
52826: 
52847: void JS_FASTCALL
53473: stubs::SetName(VMFrame &f, JSAtom *origAtom)
52611: {
52611:     JSContext *cx = f.cx;
52611: 
53203:     Value rval = f.regs.sp[-1];
52611:     Value &lref = f.regs.sp[-2];
52611:     JSObject *obj = ValueToObject(cx, &lref);
52611:     if (!obj)
52611:         THROW();
52611: 
52611:     do {
52611:         PropertyCache *cache = &JS_PROPERTY_CACHE(cx);
52611: 
52611:         /*
52611:          * Probe the property cache, specializing for two important
52611:          * set-property cases. First:
52611:          *
52611:          *   function f(a, b, c) {
52611:          *     var o = {p:a, q:b, r:c};
52611:          *     return o;
52611:          *   }
52611:          *
52611:          * or similar real-world cases, which evolve a newborn native
52611:          * object predicatably through some bounded number of property
52611:          * additions. And second:
52611:          *
52611:          *   o.p = x;
52611:          *
52611:          * in a frequently executed method or loop body, where p will
52611:          * (possibly after the first iteration) always exist in native
52611:          * object o.
52611:          */
52611:         PropertyCacheEntry *entry;
52611:         JSObject *obj2;
52611:         JSAtom *atom;
52611:         if (cache->testForSet(cx, f.regs.pc, obj, &entry, &obj2, &atom)) {
53531:             JS_ASSERT(!obj->sealed());
53531: 
52611:             /*
52611:              * Fast property cache hit, only partially confirmed by
52611:              * testForSet. We know that the entry applies to regs.pc and
52611:              * that obj's shape matches.
52611:              *
52611:              * The entry predicts either a new property to be added
52611:              * directly to obj by this set, or on an existing "own"
52611:              * property, or on a prototype property that has a setter.
52611:              */
53531:             const Shape *shape = entry->vword.toShape();
53531:             JS_ASSERT_IF(shape->isDataDescriptor(), shape->writable());
53531:             JS_ASSERT_IF(shape->hasSlot(), entry->vcapTag() == 0);
52611: 
52611:             /*
53531:              * Fastest path: check whether obj already has the cached shape and
53531:              * call NATIVE_SET and break to get out of the do-while(0). But we
53531:              * can call NATIVE_SET only for a direct or proto-setter hit.
52611:              */
53531:             if (!entry->adding()) {
52611:                 if (entry->vcapTag() == 0 ||
53537:                     ((obj2 = obj->getProto()) && obj2->shape() == entry->vshape()))
53531:                 {
53531: #ifdef DEBUG
53531:                     if (entry->directHit()) {
53531:                         JS_ASSERT(obj->nativeContains(*shape));
53531:                     } else {
53531:                         JS_ASSERT(obj2->nativeContains(*shape));
53531:                         JS_ASSERT(entry->vcapTag() == 1);
53531:                         JS_ASSERT(entry->kshape != entry->vshape());
53531:                         JS_ASSERT(!shape->hasSlot());
52611:                     }
53531: #endif
52611: 
52611:                     PCMETER(cache->pchits++);
52611:                     PCMETER(cache->setpchits++);
53531:                     NATIVE_SET(cx, obj, shape, entry, &rval);
52611:                     break;
52611:                 }
52611:             } else {
53531:                 if (obj->nativeEmpty()) {
52611:                     /*
53531:                      * We check that cx owns obj here and will continue to own
53531:                      * it after ensureClassReservedSlotsForEmptyObject returns
53531:                      * so we can continue to skip JS_UNLOCK_OBJ calls.
52611:                      */
52611:                     JS_ASSERT(CX_OWNS_OBJECT_TITLE(cx, obj));
53531:                     bool ok = obj->ensureClassReservedSlotsForEmptyObject(cx);
52611:                     JS_ASSERT(CX_OWNS_OBJECT_TITLE(cx, obj));
53531:                     if (!ok)
52611:                         THROW();
52611:                 }
52611: 
52611:                 uint32 slot;
53531:                 if (shape->previous() == obj->lastProperty() &&
52611:                     entry->vshape() == cx->runtime->protoHazardShape &&
53531:                     shape->hasDefaultSetter()) {
53531:                     slot = shape->slot;
53531:                     JS_ASSERT(slot == obj->freeslot);
53531: 
52611:                     /*
53531:                      * Fast path: adding a plain old property that was once at
53531:                      * the frontier of the property tree, whose slot is next to
53531:                      * claim among the already-allocated slots in obj, where
53531:                      * shape->table has not been created yet.
52611:                      */
52611:                     PCMETER(cache->pchits++);
52611:                     PCMETER(cache->addpchits++);
52611: 
53081:                     if (slot < obj->numSlots()) {
53531:                         JS_ASSERT(obj->getSlot(slot).isUndefined());
53531:                         ++obj->freeslot;
53531:                         JS_ASSERT(obj->freeslot != 0);
52611:                     } else {
53531:                         if (!obj->allocSlot(cx, &slot))
52611:                             THROW();
53531:                         JS_ASSERT(slot == shape->slot);
52611:                     }
52611: 
53531:                     /* Simply extend obj's property tree path with shape! */
53531:                     obj->extend(cx, shape);
52611: 
52611:                     /*
53531:                      * No method change check here because here we are adding a
53531:                      * new property, not updating an existing slot's value that
53531:                      * might contain a method of a branded shape.
52611:                      */
53203:                     obj->lockedSetSlot(slot, rval);
52611: 
52611:                     /*
52611:                      * Purge the property cache of the id we may have just
53531:                      * shadowed in obj's scope and proto chains.
52611:                      */
53531:                     js_PurgeScopeChain(cx, obj, shape->id);
52611:                     break;
52611:                 }
53531:             }
52611:             PCMETER(cache->setpcmisses++);
52611:             atom = NULL;
52611:         } else if (!atom) {
52611:             /*
53531:              * Slower property cache hit, fully confirmed by testForSet (in the
53531:              * slow path, via fullTest).
52611:              */
53531:             const Shape *shape = NULL;
52611:             if (obj == obj2) {
53531:                 shape = entry->vword.toShape();
53531:                 JS_ASSERT(shape->writable());
53531:                 JS_ASSERT(!obj2->sealed());
53531:                 NATIVE_SET(cx, obj, shape, entry, &rval);
52611:             }
53531:             if (shape)
52611:                 break;
52611:         }
52611: 
52611:         if (!atom)
52819:             atom = origAtom;
52611:         jsid id = ATOM_TO_JSID(atom);
53245:         if (entry && JS_LIKELY(!obj->getOps()->setProperty)) {
52611:             uintN defineHow;
52611:             JSOp op = JSOp(*f.regs.pc);
52611:             if (op == JSOP_SETMETHOD)
52611:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_SET_METHOD;
52611:             else if (op == JSOP_SETNAME)
52611:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_UNQUALIFIED;
52611:             else
52611:                 defineHow = JSDNP_CACHE_RESULT;
53203:             if (!js_SetPropertyHelper(cx, obj, id, defineHow, &rval))
52611:                 THROW();
52611:         } else {
53203:             if (!obj->setProperty(cx, id, &rval))
52611:                 THROW();
52611:         }
52611:     } while (0);
52611: 
52611:     f.regs.sp[-2] = f.regs.sp[-1];
52611: }
52611: 
52825: void JS_FASTCALL
53511: stubs::SetGlobalNameDumb(VMFrame &f, JSAtom *atom)
53511: {
53511:     JSContext *cx = f.cx;
53511: 
53511:     Value rval = f.regs.sp[-1];
53511:     Value &lref = f.regs.sp[-2];
53511:     JSObject *obj = ValueToObject(cx, &lref);
53511:     if (!obj)
53511:         THROW();
53511:     jsid id = ATOM_TO_JSID(atom);
53511:     if (!obj->setProperty(cx, id, &rval))
53511:         THROW();
53511: 
53511:     f.regs.sp[-2] = f.regs.sp[-1];
53511: }
53511: 
53511: void JS_FASTCALL
52825: stubs::SetGlobalName(VMFrame &f, JSAtom *atom)
52825: {
52825:     SetName(f, atom);
52825: }
52825: 
52644: static JSObject *
53004: NameOp(VMFrame &f, JSObject *obj, bool callname = false)
52615: {
52615:     JSContext *cx = f.cx;
52615: 
53531:     const Shape *shape;
52615:     Value rval;
52615: 
52615:     PropertyCacheEntry *entry;
52615:     JSObject *obj2;
52615:     JSAtom *atom;
52615:     JS_PROPERTY_CACHE(cx).test(cx, f.regs.pc, obj, obj2, entry, atom);
52615:     if (!atom) {
52615:         if (entry->vword.isFunObj()) {
52650:             f.regs.sp++;
53023:             f.regs.sp[-1].setObject(entry->vword.toFunObj());
53004:         } else if (entry->vword.isSlot()) {
52615:             uintN slot = entry->vword.toSlot();
53531:             JS_ASSERT(slot < obj2->freeslot);
52650:             f.regs.sp++;
52615:             f.regs.sp[-1] = obj2->lockedGetSlot(slot);
53004:         } else {
53531:             JS_ASSERT(entry->vword.isShape());
53531:             shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, obj, obj2, shape, JSGET_METHOD_BARRIER, &rval, return NULL);
53004:             f.regs.sp++;
53004:             f.regs.sp[-1] = rval;
52615:         }
52615: 
53004:         /*
53531:          * Push results, the same as below, but with a prop$ hit there
53531:          * is no need to test for the unusual and uncacheable case where
53531:          * the caller determines |this|.
53004:          */
53004: #if DEBUG
53004:         Class *clasp;
53004:         JS_ASSERT(!obj->getParent() ||
53004:                   (clasp = obj->getClass()) == &js_CallClass ||
53004:                   clasp == &js_BlockClass ||
53004:                   clasp == &js_DeclEnvClass);
53004: #endif
53004:         if (callname) {
53004:             f.regs.sp++;
53004:             f.regs.sp[-1].setNull();
53004:         }
53004:         return obj;
52615:     }
52615: 
52615:     jsid id;
52615:     id = ATOM_TO_JSID(atom);
52615:     JSProperty *prop;
52615:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
52644:         return NULL;
52615:     if (!prop) {
52615:         /* Kludge to allow (typeof foo == "undefined") tests. */
53482:         JSOp op2 = js_GetOpcode(cx, f.fp()->getScript(), f.regs.pc + JSOP_NAME_LENGTH);
52615:         if (op2 == JSOP_TYPEOF) {
52650:             f.regs.sp++;
52615:             f.regs.sp[-1].setUndefined();
52644:             return obj;
52615:         }
52615:         ReportAtomNotDefined(cx, atom);
52644:         return NULL;
52615:     }
52615: 
52615:     /* Take the slow path if prop was not found in a native object. */
52615:     if (!obj->isNative() || !obj2->isNative()) {
52615:         obj2->dropProperty(cx, prop);
52615:         if (!obj->getProperty(cx, id, &rval))
52644:             return NULL;
52615:     } else {
53531:         shape = (Shape *)prop;
53399:         JSObject *normalized = obj;
53531:         if (normalized->getClass() == &js_WithClass && !shape->hasDefaultGetter())
53531:             normalized = js_UnwrapWithObject(cx, normalized);
53531:         NATIVE_GET(cx, normalized, obj2, shape, JSGET_METHOD_BARRIER, &rval, return NULL);
53531:         JS_UNLOCK_OBJ(cx, obj2);
52615:     }
52615: 
52644:     f.regs.sp++;
52615:     f.regs.sp[-1] = rval;
53004:     if (callname) {
53004:         Class *clasp;
53004:         JSObject *thisp = obj;
53004:         if (!thisp->getParent() ||
53004:             (clasp = thisp->getClass()) == &js_CallClass ||
53004:             clasp == &js_BlockClass ||
53004:             clasp == &js_DeclEnvClass) {
53004:             thisp = NULL;
53004:         } else {
53004:             thisp = thisp->thisObject(cx);
53004:             if (!thisp)
53004:                 return NULL;
53004:         }
53004:         f.regs.sp++;
53023:         f.regs.sp[-1].setObjectOrNull(thisp);
53004:     }
52644:     return obj;
52615: }
52615: 
52617: void JS_FASTCALL
52819: stubs::Name(VMFrame &f)
52644: {
53482:     if (!NameOp(f, f.fp()->getScopeChain()))
52825:         THROW();
52825: }
52825: 
52825: void JS_FASTCALL
52825: stubs::GetGlobalName(VMFrame &f)
52825: {
53482:     JSObject *globalObj = f.fp()->getScopeChain()->getGlobal();
52825:     if (!NameOp(f, globalObj))
52644:          THROW();
52644: }
52644: 
52773: static inline bool
52773: IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
52773: {
53244:     if (iterobj->getClass() == &js_IteratorClass) {
52773:         NativeIterator *ni = (NativeIterator *) iterobj->getPrivate();
52773:         JS_ASSERT(ni->props_cursor < ni->props_end);
53081:         if (ni->isKeyIter()) {
53081:             jsid id = *ni->currentKey();
52954:             if (JSID_IS_ATOM(id)) {
52954:                 rval->setString(JSID_TO_STRING(id));
53081:                 ni->incKeyCursor();
52773:                 return true;
52773:             }
52773:             /* Take the slow path if we have to stringify a numeric property name. */
52954:         } else {
53081:             *rval = *ni->currentValue();
52954:             ni->incValueCursor();
52954:             return true;
52954:         }
52773:     }
52773:     return js_IteratorNext(cx, iterobj, rval);
52773: }
52773: 
52773: void JS_FASTCALL
52773: stubs::ForName(VMFrame &f, JSAtom *atom)
52773: {
52773:     JSContext *cx = f.cx;
52773:     JSFrameRegs &regs = f.regs;
52773: 
53482:     JS_ASSERT(regs.sp - 1 >= f.fp()->base());
52773:     jsid id = ATOM_TO_JSID(atom);
52773:     JSObject *obj, *obj2;
52773:     JSProperty *prop;
52773:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
52773:         THROW();
52773:     if (prop)
52773:         obj2->dropProperty(cx, prop);
52773:     {
52773:         AutoValueRooter tvr(cx);
52773:         JS_ASSERT(regs.sp[-1].isObject());
53081:         if (!IteratorNext(cx, &regs.sp[-1].toObject(), tvr.addr()))
52773:             THROW();
52773:         if (!obj->setProperty(cx, id, tvr.addr()))
52773:             THROW();
52773:     }
52773: }
52773: 
52644: void JS_FASTCALL
52693: stubs::GetElem(VMFrame &f)
52693: {
52693:     JSContext *cx = f.cx;
52693:     JSFrameRegs &regs = f.regs;
52693: 
53491:     Value &lref = regs.sp[-2];
53491:     Value &rref = regs.sp[-1];
53491:     if (lref.isString() && rref.isInt32()) {
53491:         JSString *str = lref.toString();
53491:         int32_t i = rref.toInt32();
53219:         if ((size_t)i < str->length()) {
52693:             str = JSString::getUnitString(cx, str, (size_t)i);
52693:             if (!str)
52693:                 THROW();
52693:             f.regs.sp[-2].setString(str);
52693:             return;
52693:         }
53219:     }
52693: 
53491:     JSObject *obj = ValueToObject(cx, &lref);
52694:     if (!obj)
52693:         THROW();
52693: 
53491:     const Value *copyFrom;
53491:     Value rval;
53491:     jsid id;
53491:     if (rref.isInt32()) {
53491:         int32_t i = rref.toInt32();
52693:         if (obj->isDenseArray()) {
53491:             jsuint idx = jsuint(i);
52693:             
52693:             if (idx < obj->getArrayLength() &&
52693:                 idx < obj->getDenseArrayCapacity()) {
52693:                 copyFrom = obj->addressOfDenseArrayElement(idx);
52693:                 if (!copyFrom->isMagic())
52693:                     goto end_getelem;
53491: 
53491:                 /* Reload retval from the stack in the rare hole case. */
53491:                 copyFrom = &regs.sp[-1];
52693:             }
53491:         } else if (obj->isArguments()) {
53491:             uint32 arg = uint32(i);
52693: 
53446:             if (arg < obj->getArgsInitialLength()) {
52693:                 JSStackFrame *afp = (JSStackFrame *) obj->getPrivate();
52693:                 if (afp) {
52693:                     copyFrom = &afp->argv[arg];
52693:                     goto end_getelem;
52693:                 }
52693: 
52693:                 copyFrom = obj->addressOfArgsElement(arg);
52693:                 if (!copyFrom->isMagic())
52693:                     goto end_getelem;
52693:                 /* Otherwise, fall to getProperty(). */
52693:             }
52693:         }
53491:         if (JS_LIKELY(INT_FITS_IN_JSID(i)))
53491:             id = INT_TO_JSID(i);
53491:         else
53491:             goto intern_big_int;
52693: 
52693:     } else {
53491:       intern_big_int:
53491:         if (!js_InternNonIntElementId(cx, obj, rref, &id))
52693:             THROW();
52693:     }
52693: 
52693:     if (!obj->getProperty(cx, id, &rval))
52693:         THROW();
52693:     copyFrom = &rval;
52693: 
52693:   end_getelem:
52693:     f.regs.sp[-2] = *copyFrom;
52693: }
52693: 
52723: static inline bool
52723: FetchElementId(VMFrame &f, JSObject *obj, const Value &idval, jsid &id, Value *vp)
52723: {
52723:     int32_t i_;
53341:     if (ValueFitsInInt32(idval, &i_) && INT_FITS_IN_JSID(i_)) {
52723:         id = INT_TO_JSID(i_);
52723:         return true;
52723:     }
52723:     return !!js_InternNonIntElementId(f.cx, obj, idval, &id, vp);
52723: }
52723: 
52693: void JS_FASTCALL
52771: stubs::CallElem(VMFrame &f)
52771: {
52771:     JSContext *cx = f.cx;
52771:     JSFrameRegs &regs = f.regs;
52771: 
52771:     /* Fetch the left part and resolve it to a non-null object. */
52771:     JSObject *obj = ValueToObject(cx, &regs.sp[-2]);
52771:     if (!obj)
52771:         THROW();
52771: 
52771:     /* Fetch index and convert it to id suitable for use with obj. */
52771:     jsid id;
52771:     if (!FetchElementId(f, obj, regs.sp[-1], id, &regs.sp[-2]))
52771:         THROW();
52771: 
52771:     /* Get or set the element. */
52771:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, &regs.sp[-2]))
52771:         THROW();
52771: 
52771: #if JS_HAS_NO_SUCH_METHOD
52771:     if (JS_UNLIKELY(regs.sp[-2].isUndefined())) {
52771:         regs.sp[-2] = regs.sp[-1];
52771:         regs.sp[-1].setObject(*obj);
52771:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
52771:             THROW();
52771:     } else
52771: #endif
52771:     {
52771:         regs.sp[-1].setObject(*obj);
52771:     }
52771: }
52771: 
52771: void JS_FASTCALL
52693: stubs::SetElem(VMFrame &f)
52693: {
52693:     JSContext *cx = f.cx;
52693:     JSFrameRegs &regs = f.regs;
52693: 
52693:     Value &objval = regs.sp[-3];
52693:     Value &idval  = regs.sp[-2];
52693:     Value retval  = regs.sp[-1];
52693:     
52693:     JSObject *obj;
52693:     jsid id;
52693: 
52694:     obj = ValueToObject(cx, &objval);
52694:     if (!obj)
52693:         THROW();
52693: 
52723:     if (!FetchElementId(f, obj, idval, id, &regs.sp[-2]))
52693:         THROW();
52693: 
53161:     do {
52693:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
52693:             jsuint length = obj->getDenseArrayCapacity();
52693:             jsint i = JSID_TO_INT(id);
52693:             if ((jsuint)i < length) {
52693:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
52693:                     if (js_PrototypeHasIndexedProperties(cx, obj))
53161:                         break;
52693:                     if ((jsuint)i >= obj->getArrayLength())
53161:                         obj->setArrayLength(i + 1);
52693:                 }
52693:                 obj->setDenseArrayElement(i, regs.sp[-1]);
52693:                 goto end_setelem;
52693:             }
52693:         }
53161:     } while (0);
53203:     if (!obj->setProperty(cx, id, &retval))
52693:         THROW();
52693:   end_setelem:
52693:     /* :FIXME: Moving the assigned object into the lowest stack slot
52693:      * is a temporary hack. What we actually want is an implementation
52693:      * of popAfterSet() that allows popping more than one value;
52693:      * this logic can then be handled in Compiler.cpp. */
52693:     regs.sp[-3] = retval;
52693: }
52693: 
52693: void JS_FASTCALL
52819: stubs::CallName(VMFrame &f)
52644: {
53482:     JSObject *obj = NameOp(f, f.fp()->getScopeChain(), true);
52644:     if (!obj)
52644:         THROW();
52644: }
52644: 
52644: void JS_FASTCALL
52721: stubs::BitOr(VMFrame &f)
52617: {
52617:     int32_t i, j;
52617: 
52617:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i) ||
52617:         !ValueToECMAInt32(f.cx, f.regs.sp[-1], &j)) {
52617:         THROW();
52617:     }
52721:     i = i | j;
52617:     f.regs.sp[-2].setInt32(i);
52617: }
52617: 
52685: void JS_FASTCALL
52718: stubs::BitXor(VMFrame &f)
52718: {
52718:     int32_t i, j;
52718: 
52718:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i) ||
52718:         !ValueToECMAInt32(f.cx, f.regs.sp[-1], &j)) {
52718:         THROW();
52718:     }
52718:     i = i ^ j;
52718:     f.regs.sp[-2].setInt32(i);
52718: }
52718: 
52718: void JS_FASTCALL
52721: stubs::BitAnd(VMFrame &f)
52721: {
52721:     int32_t i, j;
52721: 
52721:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i) ||
52721:         !ValueToECMAInt32(f.cx, f.regs.sp[-1], &j)) {
52721:         THROW();
52721:     }
52721:     i = i & j;
52721:     f.regs.sp[-2].setInt32(i);
52721: }
52721: 
52721: void JS_FASTCALL
52724: stubs::BitNot(VMFrame &f)
52724: {
52724:     int32_t i;
52724: 
52724:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &i))
52724:         THROW();
52724:     i = ~i;
52724:     f.regs.sp[-1].setInt32(i);
52724: }
52724: 
52724: void JS_FASTCALL
52685: stubs::Lsh(VMFrame &f)
52685: {
52685:     int32_t i, j;
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i))
52685:         THROW();
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &j))
52685:         THROW();
52685:     i = i << (j & 31);
52685:     f.regs.sp[-2].setInt32(i);
52685: }
52685: 
52685: void JS_FASTCALL
52685: stubs::Rsh(VMFrame &f)
52685: {
52685:     int32_t i, j;
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i))
52685:         THROW();
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &j))
52685:         THROW();
52685:     i = i >> (j & 31);
52685:     f.regs.sp[-2].setInt32(i);
52685: }
52685: 
52725: void JS_FASTCALL
52725: stubs::Ursh(VMFrame &f)
52725: {
52725:     uint32_t u;
52725:     if (!ValueToECMAUint32(f.cx, f.regs.sp[-2], &u))
52725:         THROW();
52725:     int32_t j;
52725:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &j))
52725:         THROW();
52725: 
52725:     u >>= (j & 31);
52725: 
52725: 	f.regs.sp[-2].setNumber(uint32(u));
52725: }
52725: 
52623: template <int32 N>
52623: static inline bool
52623: PostInc(VMFrame &f, Value *vp)
52623: {
52623:     double d;
52623:     if (!ValueToNumber(f.cx, *vp, &d))
52623:         return false;
52623:     f.regs.sp++;
52623:     f.regs.sp[-1].setDouble(d);
52623:     d += N;
52623:     vp->setDouble(d);
52623:     return true;
52623: }
52623: 
52623: template <int32 N>
52623: static inline bool
52623: PreInc(VMFrame &f, Value *vp)
52623: {
52623:     double d;
52623:     if (!ValueToNumber(f.cx, *vp, &d))
52623:         return false;
52623:     d += N;
52623:     vp->setDouble(d);
52623:     f.regs.sp++;
52623:     f.regs.sp[-1].setDouble(d);
52623:     return true;
52623: }
52623: 
52623: void JS_FASTCALL
52623: stubs::VpInc(VMFrame &f, Value *vp)
52623: {
52623:     if (!PostInc<1>(f, vp))
52623:         THROW();
52623: }
52623: 
52623: void JS_FASTCALL
52623: stubs::VpDec(VMFrame &f, Value *vp)
52623: {
52623:     if (!PostInc<-1>(f, vp))
52623:         THROW();
52623: }
52623: 
52623: void JS_FASTCALL
52623: stubs::DecVp(VMFrame &f, Value *vp)
52623: {
52623:     if (!PreInc<-1>(f, vp))
52623:         THROW();
52623: }
52623: 
52623: void JS_FASTCALL
52623: stubs::IncVp(VMFrame &f, Value *vp)
52623: {
52623:     if (!PreInc<1>(f, vp))
52623:         THROW();
52623: }
52623: 
52647: void JS_FASTCALL
53345: stubs::LocalInc(VMFrame &f, uint32 slot)
53345: {
53345:     double d;
53345:     if (!ValueToNumber(f.cx, f.regs.sp[-2], &d))
53345:         THROW();
53345:     f.regs.sp[-2].setNumber(d);
53345:     f.regs.sp[-1].setNumber(d + 1);
53482:     f.fp()->slots()[slot] = f.regs.sp[-1];
53345: }
53345: 
53345: void JS_FASTCALL
53345: stubs::LocalDec(VMFrame &f, uint32 slot)
53345: {
53345:     double d;
53345:     if (!ValueToNumber(f.cx, f.regs.sp[-2], &d))
53345:         THROW();
53345:     f.regs.sp[-2].setNumber(d);
53345:     f.regs.sp[-1].setNumber(d - 1);
53482:     f.fp()->slots()[slot] = f.regs.sp[-1];
53345: }
53345: 
53345: void JS_FASTCALL
53345: stubs::IncLocal(VMFrame &f, uint32 slot)
53345: {
53345:     double d;
53345:     if (!ValueToNumber(f.cx, f.regs.sp[-1], &d))
53345:         THROW();
53345:     f.regs.sp[-1].setNumber(d + 1);
53482:     f.fp()->slots()[slot] = f.regs.sp[-1];
53345: }
53345: 
53345: void JS_FASTCALL
53345: stubs::DecLocal(VMFrame &f, uint32 slot)
53345: {
53345:     double d;
53345:     if (!ValueToNumber(f.cx, f.regs.sp[-1], &d))
53345:         THROW();
53345:     f.regs.sp[-1].setNumber(d - 1);
53482:     f.fp()->slots()[slot] = f.regs.sp[-1];
53345: }
53345: 
53345: void JS_FASTCALL
53591: stubs::DefFun(VMFrame &f, JSFunction *fun)
52647: {
53531:     JSObject *obj2;
52647: 
52647:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52647: 
52647:     /*
52647:      * A top-level function defined in Global or Eval code (see ECMA-262
52647:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
52647:      * a compound statement (not at the top statement level of global code, or
52647:      * at the top level of a function body).
52647:      */
52647:     JSObject *obj = FUN_OBJECT(fun);
52647: 
52647:     if (FUN_NULL_CLOSURE(fun)) {
52647:         /*
52647:          * Even a null closure needs a parent for principals finding.
52647:          * FIXME: bug 476950, although debugger users may also demand some kind
52647:          * of scope link for debugger-assisted eval-in-frame.
52647:          */
53435:         obj2 = fp->getScopeChain();
52647:     } else {
52647:         JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
52647: 
52647:         /*
52647:          * Inline js_GetScopeChain a bit to optimize for the case of a
52647:          * top-level function.
52647:          */
53435:         if (!fp->hasBlockChain()) {
53435:             obj2 = fp->getScopeChain();
52647:         } else {
52647:             obj2 = js_GetScopeChain(cx, fp);
52647:             if (!obj2)
52647:                 THROW();
52647:         }
52647:     }
52647: 
52647:     /*
52647:      * If static link is not current scope, clone fun's object to link to the
52647:      * current scope via parent. We do this to enable sharing of compiled
52647:      * functions among multiple equivalent scopes, amortizing the cost of
52647:      * compilation over a number of executions.  Examples include XUL scripts
52647:      * and event handlers shared among Firefox or other Mozilla app chrome
52647:      * windows, and user-defined JS functions precompiled and then shared among
52647:      * requests in server-side JS.
52647:      */
52647:     if (obj->getParent() != obj2) {
52647:         obj = CloneFunctionObject(cx, fun, obj2);
52647:         if (!obj)
52647:             THROW();
52647:     }
52647: 
52647:     /*
52647:      * Protect obj from any GC hiding below JSObject::setProperty or
52647:      * JSObject::defineProperty.  All paths from here must flow through the
52647:      * fp->scopeChain code below the parent->defineProperty call.
52647:      */
52647:     MUST_FLOW_THROUGH("restore_scope");
53435:     fp->setScopeChain(obj);
52647: 
53531:     Value rval = ObjectValue(*obj);
52647: 
52647:     /*
52647:      * ECMA requires functions defined when entering Eval code to be
52647:      * impermanent.
52647:      */
53531:     uintN attrs = (fp->flags & JSFRAME_EVAL)
52647:                   ? JSPROP_ENUMERATE
52647:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
52647: 
52647:     /*
52647:      * We define the function as a property of the variable object and not the
52647:      * current scope chain even for the case of function expression statements
52647:      * and functions defined by eval inside let or with blocks.
52647:      */
53531:     JSObject *parent = fp->varobj(cx);
52647:     JS_ASSERT(parent);
52647: 
53531:     uint32 old;
53531:     bool doSet;
53531: 
52647:     /*
52647:      * Check for a const property of the same name -- or any kind of property
52647:      * if executing with the strict option.  We check here at runtime as well
52647:      * as at compile-time, to handle eval as well as multiple HTML script tags.
52647:      */
53531:     jsid id = ATOM_TO_JSID(fun->atom);
53531:     JSProperty *prop = NULL;
53531:     JSObject *pobj;
53531:     JSBool ok = CheckRedeclaration(cx, parent, id, attrs, &pobj, &prop);
52647:     if (!ok)
52647:         goto restore_scope;
52647: 
52647:     /*
52647:      * We deviate from 10.1.2 in ECMA 262 v3 and under eval use for function
52647:      * declarations JSObject::setProperty, not JSObject::defineProperty, to
52647:      * preserve the JSOP_PERMANENT attribute of existing properties and make
52647:      * sure that such properties cannot be deleted.
52647:      *
52647:      * We also use JSObject::setProperty for the existing properties of Call
52647:      * objects with matching attributes to preserve the native getters and
52647:      * setters that store the value of the property in the interpreter frame,
52647:      * see bug 467495.
52647:      */
52647:     doSet = (attrs == JSPROP_ENUMERATE);
52647:     JS_ASSERT_IF(doSet, fp->flags & JSFRAME_EVAL);
52647:     if (prop) {
52647:         if (parent == pobj &&
53531:             parent->isCall() &&
53531:             (old = ((Shape *) prop)->attributes(),
52647:              !(old & (JSPROP_GETTER|JSPROP_SETTER)) &&
52647:              (old & (JSPROP_ENUMERATE|JSPROP_PERMANENT)) == attrs)) {
52647:             /*
52647:              * js_CheckRedeclaration must reject attempts to add a getter or
52647:              * setter to an existing property without a getter or setter.
52647:              */
52647:             JS_ASSERT(!(attrs & ~(JSPROP_ENUMERATE|JSPROP_PERMANENT)));
52647:             JS_ASSERT(!(old & JSPROP_READONLY));
53531:             doSet = true;
52647:         }
52647:         pobj->dropProperty(cx, prop);
52647:     }
52647:     ok = doSet
52647:          ? parent->setProperty(cx, id, &rval)
53226:          : parent->defineProperty(cx, id, rval, PropertyStub, PropertyStub, attrs);
52647: 
52647:   restore_scope:
52647:     /* Restore fp->scopeChain now that obj is defined in fp->callobj. */
53435:     fp->setScopeChain(obj2);
52647:     if (!ok)
52647:         THROW();
52647: }
52653: 
52653: #define DEFAULT_VALUE(cx, n, hint, v)                                         \
52653:     JS_BEGIN_MACRO                                                            \
52653:         JS_ASSERT(v.isObject());                                              \
52653:         JS_ASSERT(v == regs.sp[n]);                                           \
53125:         if (!DefaultValue(cx, &v.toObject(), hint, &regs.sp[n]))              \
52653:             THROWV(JS_FALSE);                                                 \
52653:         v = regs.sp[n];                                                       \
52653:     JS_END_MACRO
52653: 
52653: #define RELATIONAL(OP)                                                        \
52653:     JS_BEGIN_MACRO                                                            \
52653:         JSContext *cx = f.cx;                                                 \
52653:         JSFrameRegs &regs = f.regs;                                           \
52653:         Value rval = regs.sp[-1];                                             \
52653:         Value lval = regs.sp[-2];                                             \
52653:         bool cond;                                                            \
52653:         if (lval.isObject())                                                  \
52653:             DEFAULT_VALUE(cx, -2, JSTYPE_NUMBER, lval);                       \
52653:         if (rval.isObject())                                                  \
52653:             DEFAULT_VALUE(cx, -1, JSTYPE_NUMBER, rval);                       \
52954:         if (lval.isString() && rval.isString()) {                             \
53081:             JSString *l = lval.toString(), *r = rval.toString();              \
52653:             cond = js_CompareStrings(l, r) OP 0;                              \
52653:         } else {                                                              \
52653:             double l, r;                                                      \
52653:             if (!ValueToNumber(cx, lval, &l) ||                               \
52653:                 !ValueToNumber(cx, rval, &r)) {                               \
52653:                 THROWV(JS_FALSE);                                             \
52653:             }                                                                 \
52653:             cond = JSDOUBLE_COMPARE(l, OP, r, false);                         \
52653:         }                                                                     \
52668:         regs.sp[-2].setBoolean(cond);                                         \
52653:         return cond;                                                          \
52653:     JS_END_MACRO
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::LessThan(VMFrame &f)
52653: {
52653:     RELATIONAL(<);
52653: }
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::LessEqual(VMFrame &f)
52653: {
52653:     RELATIONAL(<=);
52653: }
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::GreaterThan(VMFrame &f)
52653: {
52653:     RELATIONAL(>);
52653: }
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::GreaterEqual(VMFrame &f)
52653: {
52653:     RELATIONAL(>=);
52653: }
52653: 
52686: JSBool JS_FASTCALL
52686: stubs::ValueToBoolean(VMFrame &f)
52686: {
52686:     return js_ValueToBoolean(f.regs.sp[-1]);
52686: }
52686: 
52734: void JS_FASTCALL
52734: stubs::Not(VMFrame &f)
52734: {
52734:     JSBool b = !js_ValueToBoolean(f.regs.sp[-1]);
52734:     f.regs.sp[-1].setBoolean(b);
52734: }
52734: 
52954: template <JSBool EQ, bool IFNAN>
52679: static inline bool
52954: StubEqualityOp(VMFrame &f)
52679: {
52679:     JSContext *cx = f.cx;
52679:     JSFrameRegs &regs = f.regs;
52679: 
52679:     Value rval = regs.sp[-1];
52679:     Value lval = regs.sp[-2];
52679: 
52954:     JSBool cond;
52679: 
53429:     /* The string==string case is easily the hottest;  try it first. */
53429:     if (lval.isString() && rval.isString()) {
53429:         JSString *l = lval.toString();
53429:         JSString *r = rval.toString();
53429:         cond = js_EqualStrings(l, r) == EQ;
53429:     } else
52679: #if JS_HAS_XML_SUPPORT
53081:     if ((lval.isObject() && lval.toObject().isXML()) ||
53081:         (rval.isObject() && rval.toObject().isXML())) {
52954:         if (!js_TestXMLEquality(cx, lval, rval, &cond))
52954:             return false;
52954:         cond = cond == EQ;
52679:     } else
52954: #endif
52679: 
53023:     if (SameType(lval, rval)) {
53429:         JS_ASSERT(!lval.isString());    /* this case is handled above */
53429:         if (lval.isDouble()) {
53081:             double l = lval.toDouble();
53081:             double r = rval.toDouble();
52954:             if (EQ)
52954:                 cond = JSDOUBLE_COMPARE(l, ==, r, IFNAN);
52954:             else
52954:                 cond = JSDOUBLE_COMPARE(l, !=, r, IFNAN);
52954:         } else if (lval.isObject()) {
53081:             JSObject *l = &lval.toObject(), *r = &rval.toObject();
53244:             if (EqualityOp eq = l->getClass()->ext.equality) {
53244:                 if (!eq(cx, l, &rval, &cond))
52954:                     return false;
52954:                 cond = cond == EQ;
52679:             } else {
52954:                 cond = (l == r) == EQ;
52679:             }
53418:         } else if (lval.isNullOrUndefined()) {
53418:             cond = EQ;
52679:         } else {
53081:             cond = (lval.payloadAsRawUint32() == rval.payloadAsRawUint32()) == EQ;
52679:         }
52679:     } else {
52679:         if (lval.isNullOrUndefined()) {
52954:             cond = rval.isNullOrUndefined() == EQ;
52679:         } else if (rval.isNullOrUndefined()) {
52954:             cond = !EQ;
52679:         } else {
52679:             if (lval.isObject()) {
53125:                 if (!DefaultValue(cx, &lval.toObject(), JSTYPE_VOID, &regs.sp[-2]))
52954:                     return false;
52679:                 lval = regs.sp[-2];
52679:             }
52679: 
52679:             if (rval.isObject()) {
53125:                 if (!DefaultValue(cx, &rval.toObject(), JSTYPE_VOID, &regs.sp[-1]))
52954:                     return false;
52679:                 rval = regs.sp[-1];
52679:             }
52679: 
53429:             /*
53429:              * The string==string case is repeated because DefaultValue() can
53429:              * convert lval/rval to strings. 
53429:              */
52954:             if (lval.isString() && rval.isString()) {
53081:                 JSString *l = lval.toString();
53081:                 JSString *r = rval.toString();
52954:                 cond = js_EqualStrings(l, r) == EQ;
52679:             } else {
52679:                 double l, r;
52679:                 if (!ValueToNumber(cx, lval, &l) ||
52679:                     !ValueToNumber(cx, rval, &r)) {
52954:                     return false;
52679:                 }
52679:                 
52954:                 if (EQ)
52997:                     cond = JSDOUBLE_COMPARE(l, ==, r, false);
52679:                 else
52997:                     cond = JSDOUBLE_COMPARE(l, !=, r, true);
52679:             }
52679:         }
52679:     }
52679: 
52680:     regs.sp[-2].setBoolean(cond);
52954:     return true;
52679: }
52679: 
52679: JSBool JS_FASTCALL
52679: stubs::Equal(VMFrame &f)
52679: {
52954:     if (!StubEqualityOp<JS_TRUE, false>(f))
52954:         THROWV(JS_FALSE);
53081:     return f.regs.sp[-2].toBoolean();
52679: }
52679: 
52679: JSBool JS_FASTCALL
52679: stubs::NotEqual(VMFrame &f)
52679: {
52954:     if (!StubEqualityOp<JS_FALSE, true>(f))
52954:         THROWV(JS_FALSE);
53081:     return f.regs.sp[-2].toBoolean();
52679: }
52679: 
52692: static inline bool
52692: DefaultValue(VMFrame &f, JSType hint, Value &v, int n)
52692: {
52692:     JS_ASSERT(v.isObject());
53125:     if (!DefaultValue(f.cx, &v.toObject(), hint, &f.regs.sp[n]))
52692:         return false;
52692:     v = f.regs.sp[n];
52692:     return true;
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Add(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692:     Value rval = regs.sp[-1];
52692:     Value lval = regs.sp[-2];
52692: 
53357:     /* The string + string case is easily the hottest;  try it first. */
53357:     bool lIsString = lval.isString();
53357:     bool rIsString = rval.isString();
53357:     JSString *lstr, *rstr;
53357:     if (lIsString && rIsString) {
53357:         lstr = lval.toString();
53357:         rstr = rval.toString();
53357:         goto string_concat;
53357: 
52692:     } else
52692: #if JS_HAS_XML_SUPPORT
53081:     if (lval.isObject() && lval.toObject().isXML() &&
53081:         rval.isObject() && rval.toObject().isXML()) {
53081:         if (!js_ConcatenateXML(cx, &lval.toObject(), &rval.toObject(), &rval))
52692:             THROW();
52692:         regs.sp--;
52692:         regs.sp[-1] = rval;
52692:     } else
52692: #endif
52692:     {
53357:         /* These can convert lval/rval to strings. */
52692:         if (lval.isObject() && !DefaultValue(f, JSTYPE_VOID, lval, -2))
52692:             THROW();
52692:         if (rval.isObject() && !DefaultValue(f, JSTYPE_VOID, rval, -1))
52692:             THROW();
53357:         if ((lIsString = lval.isString()) || (rIsString = rval.isString())) {
52692:             if (lIsString) {
53081:                 lstr = lval.toString();
52692:             } else {
52692:                 lstr = js_ValueToString(cx, lval);
52692:                 if (!lstr)
52692:                     THROW();
52692:                 regs.sp[-2].setString(lstr);
52692:             }
52692:             if (rIsString) {
53081:                 rstr = rval.toString();
52692:             } else {
52692:                 rstr = js_ValueToString(cx, rval);
52692:                 if (!rstr)
52692:                     THROW();
52692:                 regs.sp[-1].setString(rstr);
52692:             }
53357:             goto string_concat;
53357: 
52692:         } else {
52692:             double l, r;
52692:             if (!ValueToNumber(cx, lval, &l) || !ValueToNumber(cx, rval, &r))
52692:                 THROW();
52692:             l += r;
52692:             regs.sp--;
52692:             regs.sp[-1].setNumber(l);
52692:         }
52692:     }
53357:     return;
53357: 
53357:   string_concat:
53357:     JSString *str = js_ConcatStrings(cx, lstr, rstr);
53357:     if (!str)
53357:         THROW();
53357:     regs.sp--;
53357:     regs.sp[-1].setString(str);
52692: }
52692: 
52692: 
52692: void JS_FASTCALL
52692: stubs::Sub(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692:     double d1, d2;
52692:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:         THROW();
52692:     }
52692:     double d = d1 - d2;
52692:     regs.sp[-2].setNumber(d);
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Mul(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692:     double d1, d2;
52692:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:         THROW();
52692:     }
52692:     double d = d1 * d2;
52692:     regs.sp[-2].setNumber(d);
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Div(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSRuntime *rt = cx->runtime;
52692:     JSFrameRegs &regs = f.regs;
52692: 
52692:     double d1, d2;
52692:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:         THROW();
52692:     }
52692:     if (d2 == 0) {
52692:         const Value *vp;
52692: #ifdef XP_WIN
52692:         /* XXX MSVC miscompiles such that (NaN == 0) */
52692:         if (JSDOUBLE_IS_NaN(d2))
52692:             vp = &rt->NaNValue;
52692:         else
52692: #endif
52692:         if (d1 == 0 || JSDOUBLE_IS_NaN(d1))
52692:             vp = &rt->NaNValue;
52692:         else if (JSDOUBLE_IS_NEG(d1) != JSDOUBLE_IS_NEG(d2))
52692:             vp = &rt->negativeInfinityValue;
52692:         else
52692:             vp = &rt->positiveInfinityValue;
52692:         regs.sp[-2] = *vp;
52692:     } else {
52692:         d1 /= d2;
52692:         regs.sp[-2].setNumber(d1);
52692:     }
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Mod(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692: 
52692:     Value &lref = regs.sp[-2];
52692:     Value &rref = regs.sp[-1];
52692:     int32_t l, r;
52692:     if (lref.isInt32() && rref.isInt32() &&
53081:         (l = lref.toInt32()) >= 0 && (r = rref.toInt32()) > 0) {
52692:         int32_t mod = l % r;
52692:         regs.sp[-2].setInt32(mod);
52692:     } else {
52692:         double d1, d2;
52692:         if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:             !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:             THROW();
52692:         }
52692:         if (d2 == 0) {
52692:             regs.sp[-2].setDouble(js_NaN);
52692:         } else {
52692:             d1 = js_fmod(d1, d2);
52692:             regs.sp[-2].setDouble(d1);
52692:         }
52692:     }
52692: }
52692: 
52703: JSObject *JS_FASTCALL
52703: stubs::NewArray(VMFrame &f, uint32 len)
52703: {
53161:     JSObject *obj = js_NewArrayObject(f.cx, len, f.regs.sp - len);
52703:     if (!obj)
52703:         THROWV(NULL);
52703:     return obj;
52703: }
52703: 
52704: void JS_FASTCALL
53395: stubs::Debugger(VMFrame &f, jsbytecode *pc)
53395: {
53395:     JSDebuggerHandler handler = f.cx->debugHooks->debuggerHandler;
53395:     if (handler) {
53395:         Value rval;
53482:         switch (handler(f.cx, f.cx->fp()->getScript(), pc, Jsvalify(&rval),
53395:                         f.cx->debugHooks->debuggerHandlerData)) {
53395:           case JSTRAP_THROW:
53395:             f.cx->throwing = JS_TRUE;
53395:             f.cx->exception = rval;
53395:             THROW();
53395: 
53395:           case JSTRAP_RETURN:
53395:             f.cx->throwing = JS_FALSE;
53482:             f.cx->fp()->setReturnValue(rval);
53477: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
53477:             *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
53477:                                          JS_METHODJIT_DATA(f.cx).trampolines.forceReturnFast);
53477: #else
53395:             *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
53469:                                          JS_METHODJIT_DATA(f.cx).trampolines.forceReturn);
53468: #endif
53395:             break;
53395: 
53395:           case JSTRAP_ERROR:
53395:             f.cx->throwing = JS_FALSE;
53395:             THROW();
53395: 
53395:           default:
53395:             break;
53395:         }
53395:     }
53395: }
53395: 
53395: void JS_FASTCALL
53168: stubs::Interrupt(VMFrame &f, jsbytecode *pc)
52753: {
53168:     if (!js_HandleExecutionInterrupt(f.cx))
52753:         THROW();
52753: }
53168: 
53168: void JS_FASTCALL
53168: stubs::Trap(VMFrame &f, jsbytecode *pc)
53168: {
53168:     Value rval;
53168: 
53482:     switch (JS_HandleTrap(f.cx, f.cx->fp()->getScript(), pc, Jsvalify(&rval))) {
53168:       case JSTRAP_THROW:
53168:         f.cx->throwing = JS_TRUE;
53168:         f.cx->exception = rval;
53168:         THROW();
53168: 
53168:       case JSTRAP_RETURN:
53168:         f.cx->throwing = JS_FALSE;
53482:         f.cx->fp()->setReturnValue(rval);
53477: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
53477:         *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
53477:                                      JS_METHODJIT_DATA(f.cx).trampolines.forceReturnFast);
53477: #else
53168:         *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
53469:                                      JS_METHODJIT_DATA(f.cx).trampolines.forceReturn);
53468: #endif
53168:         break;
53168: 
53168:       case JSTRAP_ERROR:
53168:         f.cx->throwing = JS_FALSE;
53168:         THROW();
53168: 
53168:       default:
53168:         break;
53168:     }
52753: }
52753: 
52753: void JS_FASTCALL
52704: stubs::This(VMFrame &f)
52704: {
53482:     if (!f.fp()->getThisObject(f.cx))
52704:         THROW();
53482:     f.regs.sp[-1] = f.fp()->getThisValue();
52704: }
52704: 
52713: void JS_FASTCALL
53023: stubs::ComputeThis(VMFrame &f)
53023: {
53482:     if (!f.fp()->getThisObject(f.cx))
53023:         THROW();
53023: }
53023: 
53023: void JS_FASTCALL
52713: stubs::Neg(VMFrame &f)
52713: {
52713:     double d;
52713:     if (!ValueToNumber(f.cx, f.regs.sp[-1], &d))
52713:         THROW();
52713:     d = -d;
52713:     f.regs.sp[-1].setNumber(d);
52713: }
52713: 
52719: JSObject * JS_FASTCALL
52719: stubs::NewInitArray(VMFrame &f)
52719: {
52719:     JSObject *obj = js_NewArrayObject(f.cx, 0, NULL);
52719:     if (!obj)
52719:         THROWV(NULL);
52719:     return obj;
52719: }
52719: 
52719: JSObject * JS_FASTCALL
53531: stubs::NewInitObject(VMFrame &f)
52719: {
52719:     JSContext *cx = f.cx;
52719: 
53133:     JSObject *obj = NewBuiltinClassInstance(cx, &js_ObjectClass); 
52719:     if (!obj)
52719:         THROWV(NULL);
52719: 
52719:     return obj;
52719: }
52719: 
52719: void JS_FASTCALL
52723: stubs::InitElem(VMFrame &f, uint32 last)
52723: {
52723:     JSContext *cx = f.cx;
52723:     JSFrameRegs &regs = f.regs;
52723: 
52723:     /* Pop the element's value into rval. */
53482:     JS_ASSERT(regs.sp - f.fp()->base() >= 3);
52723:     const Value &rref = regs.sp[-1];
52723: 
52723:     /* Find the object being initialized at top of stack. */
52723:     const Value &lref = regs.sp[-3];
52723:     JS_ASSERT(lref.isObject());
53081:     JSObject *obj = &lref.toObject();
52723: 
52723:     /* Fetch id now that we have obj. */
52723:     jsid id;
52723:     const Value &idval = regs.sp[-2];
52723:     if (!FetchElementId(f, obj, idval, id, &regs.sp[-2]))
52723:         THROW();
52723: 
52723:     /*
52723:      * Check for property redeclaration strict warning (we may be in an object
52723:      * initialiser, not an array initialiser).
52723:      */
52723:     if (!CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER, NULL, NULL))
52723:         THROW();
52723: 
52723:     /*
52723:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
52723:      * obj must be an array, so if the current op is the last element
52723:      * initialiser, set the array length to one greater than id.
52723:      */
52723:     if (rref.isMagic(JS_ARRAY_HOLE)) {
52723:         JS_ASSERT(obj->isArray());
52723:         JS_ASSERT(JSID_IS_INT(id));
52723:         JS_ASSERT(jsuint(JSID_TO_INT(id)) < JS_ARGS_LENGTH_MAX);
52723:         if (last && !js_SetLengthProperty(cx, obj, (jsuint) (JSID_TO_INT(id) + 1)))
52723:             THROW();
52723:     } else {
52723:         if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
52723:             THROW();
52723:     }
52723: }
52723: 
52726: void JS_FASTCALL
53081: stubs::GetUpvar(VMFrame &f, uint32 ck)
52726: {
52726:     /* :FIXME: We can do better, this stub isn't needed. */
53482:     uint32 staticLevel = f.fp()->getScript()->staticLevel;
53081:     UpvarCookie cookie;
53081:     cookie.fromInteger(ck);
53091:     f.regs.sp[0] = GetUpvar(f.cx, staticLevel, cookie);
52726: }
52726: 
52727: JSObject * JS_FASTCALL
52727: stubs::DefLocalFun(VMFrame &f, JSFunction *fun)
52727: {
52727:     /*
52727:      * Define a local function (i.e., one nested at the top level of another
52727:      * function), parented by the current scope chain, stored in a local
52727:      * variable slot that the compiler allocated.  This is an optimization over
52727:      * JSOP_DEFFUN that avoids requiring a call object for the outer function's
52727:      * activation.
52727:      */
52727:     JS_ASSERT(fun->isInterpreted());
52727:     JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
52727:     JSObject *obj = FUN_OBJECT(fun);
52727: 
52727:     if (FUN_NULL_CLOSURE(fun)) {
53482:         obj = CloneFunctionObject(f.cx, fun, f.fp()->getScopeChain());
52727:         if (!obj)
52727:             THROWV(NULL);
52727:     } else {
53482:         JSObject *parent = js_GetScopeChain(f.cx, f.fp());
52727:         if (!parent)
52727:             THROWV(NULL);
52727: 
52727:         if (obj->getParent() != parent) {
52727:             obj = CloneFunctionObject(f.cx, fun, parent);
52727:             if (!obj)
52727:                 THROWV(NULL);
52727:         }
52727:     }
52727: 
52727:     return obj;
52727: }
52727: 
52729: JSObject * JS_FASTCALL
53038: stubs::DefLocalFun_FC(VMFrame &f, JSFunction *fun)
53038: {
53038:     JSObject *obj = js_NewFlatClosure(f.cx, fun);
53038:     if (!obj)
53038:         THROWV(NULL);
53038:     return obj;
53038: }
53038: 
53038: JSObject * JS_FASTCALL
52729: stubs::RegExp(VMFrame &f, JSObject *regex)
52729: {
52729:     /*
52729:      * Push a regexp object cloned from the regexp literal object mapped by the
52729:      * bytecode at pc. ES5 finally fixed this bad old ES3 design flaw which was
52729:      * flouted by many browser-based implementations.
52729:      *
53435:      * We avoid the js_GetScopeChain call here and pass fp->getScopeChain() as
52729:      * js_GetClassPrototype uses the latter only to locate the global.
52729:      */
52729:     JSObject *proto;
53482:     if (!js_GetClassPrototype(f.cx, f.fp()->getScopeChain(), JSProto_RegExp, &proto))
52729:         THROWV(NULL);
52729:     JS_ASSERT(proto);
52729:     JSObject *obj = js_CloneRegExpObject(f.cx, regex, proto);
52729:     if (!obj)
52729:         THROWV(NULL);
52729:     return obj;
52729: }
52729: 
52730: JSObject * JS_FASTCALL
53128: stubs::LambdaForInit(VMFrame &f, JSFunction *fun)
53128: {
53128:     JSObject *obj = FUN_OBJECT(fun);
53482:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == f.fp()->getScopeChain()) {
53482:         fun->setMethodAtom(f.fp()->getScript()->getAtom(GET_SLOTNO(f.regs.pc + JSOP_LAMBDA_LENGTH)));
53128:         return obj;
53249:     }
53249:     return Lambda(f, fun);
53128: }
53128: 
53249: JSObject * JS_FASTCALL
53249: stubs::LambdaForSet(VMFrame &f, JSFunction *fun)
53249: {
53249:     JSObject *obj = FUN_OBJECT(fun);
53482:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == f.fp()->getScopeChain()) {
53249:         const Value &lref = f.regs.sp[-1];
53249:         if (lref.isObject() && lref.toObject().canHaveMethodBarrier()) {
53482:             fun->setMethodAtom(f.fp()->getScript()->getAtom(GET_SLOTNO(f.regs.pc + JSOP_LAMBDA_LENGTH)));
53249:             return obj;
53249:         }
53249:     }
53249:     return Lambda(f, fun);
53249: }
53128: 
53249: JSObject * JS_FASTCALL
53249: stubs::LambdaJoinableForCall(VMFrame &f, JSFunction *fun)
53249: {
53249:     JSObject *obj = FUN_OBJECT(fun);
53482:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == f.fp()->getScopeChain()) {
53249:         /*
53249:          * Array.prototype.sort and String.prototype.replace are
53249:          * optimized as if they are special form. We know that they
53249:          * won't leak the joined function object in obj, therefore
53249:          * we don't need to clone that compiler- created function
53249:          * object for identity/mutation reasons.
53249:          */
53249:         int iargc = GET_ARGC(f.regs.pc + JSOP_LAMBDA_LENGTH);
53249: 
53249:         /*
53249:          * Note that we have not yet pushed obj as the final argument,
53249:          * so regs.sp[1 - (iargc + 2)], and not regs.sp[-(iargc + 2)],
53249:          * is the callee for this JSOP_CALL.
53249:          */
53249:         const Value &cref = f.regs.sp[1 - (iargc + 2)];
53249:         JSObject *callee;
53249: 
53249:         if (IsFunctionObject(cref, &callee)) {
53557:             JSFunction *calleeFun = callee->getFunctionPrivate();
53557:             Native native = calleeFun->maybeNative();
53249: 
53557:             if (native) {
53557:                 if (iargc == 1 && native == array_sort)
53128:                     return obj;
53557:                 if (iargc == 2 && native == str_replace)
53249:                     return obj;
53249:             }
53249:         }
53249:     }
53249:     return Lambda(f, fun);
53249: }
53249: 
53249: JSObject * JS_FASTCALL
53249: stubs::LambdaJoinableForNull(VMFrame &f, JSFunction *fun)
53249: {
53249:     JSObject *obj = FUN_OBJECT(fun);
53482:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == f.fp()->getScopeChain()) {
53249:         jsbytecode *pc2 = f.regs.pc + JSOP_LAMBDA_LENGTH + JSOP_NULL_LENGTH;
53249:         JSOp op2 = JSOp(*pc2);
53249: 
53249:         if (op2 == JSOP_CALL && GET_ARGC(pc2) == 0)
53249:             return obj;
53249:     }
53249:     return Lambda(f, fun);
53128: }
53128: 
53128: JSObject * JS_FASTCALL
52730: stubs::Lambda(VMFrame &f, JSFunction *fun)
52730: {
52730:     JSObject *obj = FUN_OBJECT(fun);
52730: 
52730:     JSObject *parent;
52730:     if (FUN_NULL_CLOSURE(fun)) {
53482:         parent = f.fp()->getScopeChain();
52730:     } else {
53482:         parent = js_GetScopeChain(f.cx, f.fp());
52730:         if (!parent)
52730:             THROWV(NULL);
52730:     }
52730: 
52730:     obj = CloneFunctionObject(f.cx, fun, parent);
52730:     if (!obj)
52730:         THROWV(NULL);
52730: 
52730:     return obj;
52730: }
52730: 
52732: /* Test whether v is an int in the range [-2^31 + 1, 2^31 - 2] */
52732: static JS_ALWAYS_INLINE bool
52732: CanIncDecWithoutOverflow(int32_t i)
52732: {
52732:     return (i > JSVAL_INT_MIN) && (i < JSVAL_INT_MAX);
52732: }
52730: 
52732: template <int32 N, bool POST>
52732: static inline bool
52732: ObjIncOp(VMFrame &f, JSObject *obj, jsid id)
52732: {
52732:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52732: 
52732:     f.regs.sp[0].setNull();
52732:     f.regs.sp++;
52732:     if (!obj->getProperty(cx, id, &f.regs.sp[-1]))
52732:         return false;
52732: 
52732:     Value &ref = f.regs.sp[-1];
52732:     int32_t tmp;
53081:     if (JS_LIKELY(ref.isInt32() && CanIncDecWithoutOverflow(tmp = ref.toInt32()))) {
52732:         if (POST)
53081:             ref.getInt32Ref() = tmp + N;
52732:         else
53081:             ref.getInt32Ref() = tmp += N;
52732:         fp->flags |= JSFRAME_ASSIGNING;
52732:         JSBool ok = obj->setProperty(cx, id, &ref);
52732:         fp->flags &= ~JSFRAME_ASSIGNING;
52732:         if (!ok)
52732:             return false;
52732: 
52732:         /*
52732:          * We must set regs.sp[-1] to tmp for both post and pre increments
52732:          * as the setter overwrites regs.sp[-1].
52732:          */
52732:         ref.setInt32(tmp);
52732:     } else {
52732:         Value v;
52732:         double d;
52732:         if (!ValueToNumber(cx, ref, &d))
52732:             return false;
52732:         if (POST) {
52732:             ref.setDouble(d);
52732:             d += N;
52732:         } else {
52732:             d += N;
52732:             ref.setDouble(d);
52732:         }
52732:         v.setDouble(d);
52732:         fp->flags |= JSFRAME_ASSIGNING;
52732:         JSBool ok = obj->setProperty(cx, id, &v);
52732:         fp->flags &= ~JSFRAME_ASSIGNING;
52732:         if (!ok)
52732:             return false;
52732:     }
52732: 
52732:     return true;
52732: }
52732: 
52732: template <int32 N, bool POST>
52732: static inline bool
52825: NameIncDec(VMFrame &f, JSObject *obj, JSAtom *origAtom)
52732: {
52732:     JSContext *cx = f.cx;
52732: 
52732:     JSAtom *atom;
52732:     JSObject *obj2;
52732:     JSProperty *prop;
52732:     PropertyCacheEntry *entry;
52732:     JS_PROPERTY_CACHE(cx).test(cx, f.regs.pc, obj, obj2, entry, atom);
52732:     if (!atom) {
52732:         if (obj == obj2 && entry->vword.isSlot()) {
52732:             uint32 slot = entry->vword.toSlot();
53531:             JS_ASSERT(slot < obj->freeslot);
52732:             Value &rref = obj->getSlotRef(slot);
52732:             int32_t tmp;
53081:             if (JS_LIKELY(rref.isInt32() && CanIncDecWithoutOverflow(tmp = rref.toInt32()))) {
52732:                 int32_t inc = tmp + N;
52732:                 if (!POST)
52732:                     tmp = inc;
53081:                 rref.getInt32Ref() = inc;
52732:                 f.regs.sp[0].setInt32(tmp);
52732:                 return true;
52732:             }
52732:         }
52732:         atom = origAtom;
52732:     }
52732: 
52732:     jsid id = ATOM_TO_JSID(atom);
52732:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
52732:         return false;
52732:     if (!prop) {
52732:         ReportAtomNotDefined(cx, atom);
52732:         return false;
52732:     }
52732:     obj2->dropProperty(cx, prop);
52732:     return ObjIncOp<N, POST>(f, obj, id);
52732: }
52732: 
52732: void JS_FASTCALL
52746: stubs::PropInc(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
52746:     if (!ObjIncOp<1, true>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
52746: void JS_FASTCALL
52746: stubs::PropDec(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
52781:     if (!ObjIncOp<-1, true>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
52746: void JS_FASTCALL
52746: stubs::IncProp(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
52746:     if (!ObjIncOp<1, false>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
52746: void JS_FASTCALL
52746: stubs::DecProp(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
52746:     if (!ObjIncOp<-1, false>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
52746: void JS_FASTCALL
52815: stubs::ElemInc(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
52815:     if (!ObjIncOp<1, true>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
52815: void JS_FASTCALL
52815: stubs::ElemDec(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
52815:     if (!ObjIncOp<-1, true>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
52815: void JS_FASTCALL
52815: stubs::IncElem(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
52815:     if (!ObjIncOp<1, false>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
52815: void JS_FASTCALL
52815: stubs::DecElem(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
52815:     if (!ObjIncOp<-1, false>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
52815: void JS_FASTCALL
52732: stubs::NameInc(VMFrame &f, JSAtom *atom)
52732: {
53482:     JSObject *obj = f.fp()->getScopeChain();
52825:     if (!NameIncDec<1, true>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
52732: void JS_FASTCALL
52732: stubs::NameDec(VMFrame &f, JSAtom *atom)
52732: {
53482:     JSObject *obj = f.fp()->getScopeChain();
52825:     if (!NameIncDec<-1, true>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
52732: void JS_FASTCALL
52732: stubs::IncName(VMFrame &f, JSAtom *atom)
52732: {
53482:     JSObject *obj = f.fp()->getScopeChain();
52825:     if (!NameIncDec<1, false>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
52732: void JS_FASTCALL
52732: stubs::DecName(VMFrame &f, JSAtom *atom)
52732: {
53482:     JSObject *obj = f.fp()->getScopeChain();
52825:     if (!NameIncDec<-1, false>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
52825: void JS_FASTCALL
52825: stubs::GlobalNameInc(VMFrame &f, JSAtom *atom)
52825: {
53482:     JSObject *obj = f.fp()->getScopeChain()->getGlobal();
52825:     if (!NameIncDec<1, true>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
52825: void JS_FASTCALL
52825: stubs::GlobalNameDec(VMFrame &f, JSAtom *atom)
52825: {
53482:     JSObject *obj = f.fp()->getScopeChain()->getGlobal();
52825:     if (!NameIncDec<-1, true>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
52825: void JS_FASTCALL
52825: stubs::IncGlobalName(VMFrame &f, JSAtom *atom)
52825: {
53482:     JSObject *obj = f.fp()->getScopeChain()->getGlobal();
52825:     if (!NameIncDec<1, false>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
52825: void JS_FASTCALL
52825: stubs::DecGlobalName(VMFrame &f, JSAtom *atom)
52825: {
53482:     JSObject *obj = f.fp()->getScopeChain()->getGlobal();
52825:     if (!NameIncDec<-1, false>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
52761: static bool JS_FASTCALL
52761: InlineGetProp(VMFrame &f)
52741: {
52741:     JSContext *cx = f.cx;
52741:     JSFrameRegs &regs = f.regs;
52741: 
52741:     Value *vp = &f.regs.sp[-1];
52741:     JSObject *obj = ValueToObject(f.cx, vp);
52741:     if (!obj)
52761:         return false;
52741: 
52741:     Value rval;
52741:     do {
52741:         /*
52741:          * We do not impose the method read barrier if in an imacro,
52741:          * assuming any property gets it does (e.g., for 'toString'
52741:          * from JSOP_NEW) will not be leaked to the calling script.
52741:          */
52741:         JSObject *aobj = js_GetProtoIfDenseArray(obj);
52741: 
52741:         PropertyCacheEntry *entry;
52741:         JSObject *obj2;
52741:         JSAtom *atom;
52741:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
52741:         if (!atom) {
52741:             if (entry->vword.isFunObj()) {
53023:                 rval.setObject(entry->vword.toFunObj());
52741:             } else if (entry->vword.isSlot()) {
52741:                 uint32 slot = entry->vword.toSlot();
53531:                 JS_ASSERT(slot < obj2->freeslot);
52741:                 rval = obj2->lockedGetSlot(slot);
52741:             } else {
53531:                 JS_ASSERT(entry->vword.isShape());
53531:                 const Shape *shape = entry->vword.toShape();
53531:                 NATIVE_GET(cx, obj, obj2, shape,
53482:                         f.fp()->hasIMacroPC() ? JSGET_NO_METHOD_BARRIER : JSGET_METHOD_BARRIER,
52761:                         &rval, return false);
52741:             }
52741:             break;
52741:         }
52741: 
52741:         jsid id = ATOM_TO_JSID(atom);
53244:         if (JS_LIKELY(!aobj->getOps()->getProperty)
52741:                 ? !js_GetPropertyHelper(cx, obj, id,
53482:                     f.fp()->hasIMacroPC()
52741:                     ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
52741:                     : JSGET_CACHE_RESULT | JSGET_METHOD_BARRIER,
52741:                     &rval)
52741:                 : !obj->getProperty(cx, id, &rval)) {
52761:             return false;
52741:         }
52741:     } while(0);
52741: 
52741:     regs.sp[-1] = rval;
52761:     return true;
52761: }
52761: 
52761: void JS_FASTCALL
52761: stubs::GetProp(VMFrame &f)
52761: {
52761:     if (!InlineGetProp(f))
52761:         THROW();
52761: }
52761: 
52761: void JS_FASTCALL
52788: stubs::CallProp(VMFrame &f, JSAtom *origAtom)
52761: {
52761:     JSContext *cx = f.cx;
52761:     JSFrameRegs &regs = f.regs;
52761: 
52788:     Value lval;
52788:     lval = regs.sp[-1];
52788: 
52788:     Value objv;
52788:     if (lval.isObject()) {
52788:         objv = lval;
52788:     } else {
52788:         JSProtoKey protoKey;
52788:         if (lval.isString()) {
52788:             protoKey = JSProto_String;
52788:         } else if (lval.isNumber()) {
52788:             protoKey = JSProto_Number;
52788:         } else if (lval.isBoolean()) {
52788:             protoKey = JSProto_Boolean;
52788:         } else {
52788:             JS_ASSERT(lval.isNull() || lval.isUndefined());
52788:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
52761:             THROW();
52788:         }
52788:         JSObject *pobj;
52788:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
52788:             THROW();
53023:         objv.setObject(*pobj);
52788:     }
52761: 
53081:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
52788:     Value rval;
52761: 
52788:     PropertyCacheEntry *entry;
52788:     JSObject *obj2;
52788:     JSAtom *atom;
52788:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
52788:     if (!atom) {
52788:         if (entry->vword.isFunObj()) {
53023:             rval.setObject(entry->vword.toFunObj());
52788:         } else if (entry->vword.isSlot()) {
52788:             uint32 slot = entry->vword.toSlot();
53531:             JS_ASSERT(slot < obj2->freeslot);
52788:             rval = obj2->lockedGetSlot(slot);
52788:         } else {
53531:             JS_ASSERT(entry->vword.isShape());
53531:             const Shape *shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, &objv.toObject(), obj2, shape, JSGET_NO_METHOD_BARRIER, &rval,
52788:                        THROW());
52788:         }
52788:         regs.sp++;
52788:         regs.sp[-2] = rval;
52788:         regs.sp[-1] = lval;
52788:         goto end_callprop;
52788:     }
52788: 
52788:     /*
52788:      * Cache miss: use the immediate atom that was loaded for us under
52788:      * PropertyCache::test.
52788:      */
52788:     jsid id;
52788:     id = ATOM_TO_JSID(origAtom);
52788: 
52788:     regs.sp++;
52788:     regs.sp[-1].setNull();
52788:     if (lval.isObject()) {
53081:         if (!js_GetMethod(cx, &objv.toObject(), id,
53244:                           JS_LIKELY(!aobj->getOps()->getProperty)
52788:                           ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
52788:                           : JSGET_NO_METHOD_BARRIER,
52788:                           &rval)) {
52788:             THROW();
52788:         }
52788:         regs.sp[-1] = objv;
52788:         regs.sp[-2] = rval;
52788:     } else {
53244:         JS_ASSERT(!objv.toObject().getOps()->getProperty);
53081:         if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
52788:                                   JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
52788:                                   &rval)) {
52788:             THROW();
52788:         }
52788:         regs.sp[-1] = lval;
52788:         regs.sp[-2] = rval;
52788:     }
52788: 
52788:   end_callprop:
52788:     /* Wrap primitive lval in object clothing if necessary. */
52761:     if (lval.isPrimitive()) {
52761:         /* FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=412571 */
53023:         JSObject *funobj;
53023:         if (!IsFunctionObject(rval, &funobj) ||
53023:             !PrimitiveThisTest(GET_FUNCTION_PRIVATE(cx, funobj), lval)) {
52761:             if (!js_PrimitiveToObject(cx, &regs.sp[-1]))
52761:                 THROW();
52761:         }
52761:     }
52761: #if JS_HAS_NO_SUCH_METHOD
52761:     if (JS_UNLIKELY(rval.isUndefined())) {
52788:         regs.sp[-2].setString(ATOM_TO_STRING(origAtom));
52761:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
52761:             THROW();
52761:     }
52788: #endif
52741: }
52741: 
52741: void JS_FASTCALL
52903: stubs::WrapPrimitiveThis(VMFrame &f)
52903: {
52903:     JSContext *cx = f.cx;
52903:     const Value &funv = f.regs.sp[-2];
52903:     const Value &thisv = f.regs.sp[-1];
52903: 
52903:     JS_ASSERT(thisv.isPrimitive());
52903: 
52903:     /* FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=412571 */
53023:     JSObject *funobj;
53023:     if (!IsFunctionObject(funv, &funobj) ||
53023:         !PrimitiveThisTest(GET_FUNCTION_PRIVATE(cx, funobj), thisv)) {
52903:         if (!js_PrimitiveToObject(cx, &f.regs.sp[-1]))
52903:             THROW();
52903:     }
52903: }
52903: 
52903: void JS_FASTCALL
52762: stubs::Length(VMFrame &f)
52762: {
52762:     JSFrameRegs &regs = f.regs;
52762:     Value *vp = &regs.sp[-1];
52762: 
52762:     if (vp->isString()) {
53081:         vp->setInt32(vp->toString()->length());
52762:         return;
52762:     } else if (vp->isObject()) {
53081:         JSObject *obj = &vp->toObject();
52762:         if (obj->isArray()) {
52762:             jsuint length = obj->getArrayLength();
53182:             regs.sp[-1].setNumber(length);
52762:             return;
52762:         } else if (obj->isArguments() && !obj->isArgsLengthOverridden()) {
53446:             uint32 length = obj->getArgsInitialLength();
52762:             JS_ASSERT(length < INT32_MAX);
52762:             regs.sp[-1].setInt32(int32_t(length));
52762:             return;
52762:         }
52762:     }
52762: 
52762:     if (!InlineGetProp(f))
52762:         THROW();
52762: }
52762: 
52762: void JS_FASTCALL
52733: stubs::Iter(VMFrame &f, uint32 flags)
52733: {
52733:     if (!js_ValueToIterator(f.cx, flags, &f.regs.sp[-1]))
52733:         THROW();
52733:     JS_ASSERT(!f.regs.sp[-1].isPrimitive());
52733: }
52733: 
52735: static void 
52735: InitPropOrMethod(VMFrame &f, JSAtom *atom, JSOp op)
52735: {
52735:     JSContext *cx = f.cx;
52735:     JSRuntime *rt = cx->runtime;
52735:     JSFrameRegs &regs = f.regs;
52735: 
52735:     /* Load the property's initial value into rval. */
53482:     JS_ASSERT(regs.sp - f.fp()->base() >= 2);
52735:     Value rval;
52735:     rval = regs.sp[-1];
52735: 
52735:     /* Load the object being initialized into lval/obj. */
53081:     JSObject *obj = &regs.sp[-2].toObject();
52735:     JS_ASSERT(obj->isNative());
52735: 
52735:     /*
52735:      * Probe the property cache.
52735:      *
52735:      * We can not assume that the object created by JSOP_NEWINIT is still
52735:      * single-threaded as the debugger can access it from other threads.
52735:      * So check first.
52735:      *
53531:      * On a hit, if the cached shape has a non-default setter, it must be
53531:      * __proto__. If shape->previous() != obj->lastProperty(), there must be a
52735:      * repeated property name. The fast path does not handle these two cases.
52735:      */
52735:     PropertyCacheEntry *entry;
53531:     const Shape *shape;
52735:     if (CX_OWNS_OBJECT_TITLE(cx, obj) &&
53531:         JS_PROPERTY_CACHE(cx).testForInit(rt, regs.pc, obj, &shape, &entry) &&
53531:         shape->hasDefaultSetter() &&
53531:         shape->previous() == obj->lastProperty())
52735:     {
52735:         /* Fast path. Property cache hit. */
53531:         uint32 slot = shape->slot;
53531: 
53531:         JS_ASSERT(slot == obj->freeslot);
53531:         JS_ASSERT(slot >= JSSLOT_FREE(obj->getClass()));
52735:         if (slot < obj->numSlots()) {
53531:             JS_ASSERT(obj->getSlot(slot).isUndefined());
53531:             ++obj->freeslot;
53531:             JS_ASSERT(obj->freeslot != 0);
52735:         } else {
53531:             if (!obj->allocSlot(cx, &slot))
52735:                 THROW();
53531:             JS_ASSERT(slot == shape->slot);
52735:         }
52735: 
53531:         /* A new object, or one we just extended in a recent initprop op. */
53531:         JS_ASSERT(!obj->lastProperty() ||
53531:                   obj->shape() == obj->lastProperty()->shape);
53531:         obj->extend(cx, shape);
52735: 
52735:         /*
52735:          * No method change check here because here we are adding a new
52735:          * property, not updating an existing slot's value that might
53531:          * contain a method of a branded shape.
52735:          */
52735:         obj->lockedSetSlot(slot, rval);
52735:     } else {
52735:         PCMETER(JS_PROPERTY_CACHE(cx).inipcmisses++);
52735: 
52735:         /* Get the immediate property name into id. */
52735:         jsid id = ATOM_TO_JSID(atom);
52735: 
53531:         /* No need to check for duplicate property; the compiler already did. */
52735: 
52735:         uintN defineHow = (op == JSOP_INITMETHOD)
52735:                           ? JSDNP_CACHE_RESULT | JSDNP_SET_METHOD
52735:                           : JSDNP_CACHE_RESULT;
52735:         if (!(JS_UNLIKELY(atom == cx->runtime->atomState.protoAtom)
52735:               ? js_SetPropertyHelper(cx, obj, id, defineHow, &rval)
52735:               : js_DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
52735:                                         JSPROP_ENUMERATE, 0, 0, NULL,
52735:                                         defineHow))) {
52735:             THROW();
52735:         }
52735:     }
52735: }
52735: 
52735: void JS_FASTCALL
52735: stubs::InitProp(VMFrame &f, JSAtom *atom)
52735: {
52735:     InitPropOrMethod(f, atom, JSOP_INITPROP);
52735: }
52735: 
52737: void JS_FASTCALL
52783: stubs::InitMethod(VMFrame &f, JSAtom *atom)
52783: {
52783:     InitPropOrMethod(f, atom, JSOP_INITMETHOD);
52783: }
52783: 
52783: void JS_FASTCALL
52737: stubs::IterNext(VMFrame &f)
52737: {
53482:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
52737:     JS_ASSERT(f.regs.sp[-1].isObject());
52737: 
53081:     JSObject *iterobj = &f.regs.sp[-1].toObject();
52737:     f.regs.sp[0].setNull();
52737:     f.regs.sp++;
52737:     if (!js_IteratorNext(f.cx, iterobj, &f.regs.sp[-1]))
52737:         THROW();
52737: }
52737: 
52737: JSBool JS_FASTCALL
52737: stubs::IterMore(VMFrame &f)
52737: {
53482:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
52737:     JS_ASSERT(f.regs.sp[-1].isObject());
52737: 
52737:     Value v;
53081:     JSObject *iterobj = &f.regs.sp[-1].toObject();
52737:     if (!js_IteratorMore(f.cx, iterobj, &v))
52737:         THROWV(JS_FALSE);
52737: 
53081:     return v.toBoolean();
52737: }
52737: 
52737: void JS_FASTCALL
52737: stubs::EndIter(VMFrame &f)
52737: {
53482:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
53100:     if (!js_CloseIterator(f.cx, &f.regs.sp[-1].toObject()))
52737:         THROW();
52737: }
52737: 
52738: JSString * JS_FASTCALL
52738: stubs::TypeOf(VMFrame &f)
52738: {
52738:     const Value &ref = f.regs.sp[-1];
52738:     JSType type = JS_TypeOfValue(f.cx, Jsvalify(ref));
52738:     JSAtom *atom = f.cx->runtime->atomState.typeAtoms[type];
52738:     return ATOM_TO_STRING(atom);
52738: }
52738: 
53513: void JS_FASTCALL
52739: stubs::StrictEq(VMFrame &f)
52739: {
52739:     const Value &rhs = f.regs.sp[-1];
52739:     const Value &lhs = f.regs.sp[-2];
53513:     const bool b = StrictlyEqual(f.cx, lhs, rhs) == true;
53513:     f.regs.sp--;
53513:     f.regs.sp[-1].setBoolean(b);
52739: }
52739: 
53513: void JS_FASTCALL
52739: stubs::StrictNe(VMFrame &f)
52739: {
52739:     const Value &rhs = f.regs.sp[-1];
52739:     const Value &lhs = f.regs.sp[-2];
53513:     const bool b = StrictlyEqual(f.cx, lhs, rhs) != true;
53513:     f.regs.sp--;
53513:     f.regs.sp[-1].setBoolean(b);
52739: }
52739: 
52772: void JS_FASTCALL
52772: stubs::Throw(VMFrame &f)
52772: {
52772:     JSContext *cx = f.cx;
52772: 
52772:     JS_ASSERT(!cx->throwing);
52772:     cx->throwing = JS_TRUE;
52772:     cx->exception = f.regs.sp[-1];
52772:     THROW();
52772: }
52772: 
52775: JSObject * JS_FASTCALL
52775: stubs::FlatLambda(VMFrame &f, JSFunction *fun)
52775: {
52775:     JSObject *obj = js_NewFlatClosure(f.cx, fun);
52775:     if (!obj)
52775:         THROWV(NULL);
52775:     return obj;
52775: }
52775: 
52778: void JS_FASTCALL
52778: stubs::Arguments(VMFrame &f)
52778: {
52778:     f.regs.sp++;
53482:     if (!js_GetArgsValue(f.cx, f.fp(), &f.regs.sp[-1]))
52778:         THROW();
52778: }
52778: 
52780: JSBool JS_FASTCALL
52780: stubs::InstanceOf(VMFrame &f)
52780: {
52780:     JSContext *cx = f.cx;
52780:     JSFrameRegs &regs = f.regs;
52780: 
52780:     const Value &rref = regs.sp[-1];
53155:     if (rref.isPrimitive()) {
52780:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
52780:                             -1, rref, NULL);
52780:         THROWV(JS_FALSE);
52780:     }
53155:     JSObject *obj = &rref.toObject();
52780:     const Value &lref = regs.sp[-2];
52780:     JSBool cond = JS_FALSE;
53161:     if (!HasInstance(cx, obj, &lref, &cond))
52780:         THROWV(JS_FALSE);
52894:     f.regs.sp[-2].setBoolean(cond);
52780:     return cond;
52780: }
52780: 
52911: void JS_FASTCALL
52894: stubs::FastInstanceOf(VMFrame &f)
52894: {
52894:     const Value &lref = f.regs.sp[-1];
52894: 
52894:     if (lref.isPrimitive()) {
52894:         /*
52894:          * Throw a runtime error if instanceof is called on a function that
52894:          * has a non-object as its .prototype value.
52894:          */
52894:         js_ReportValueError(f.cx, JSMSG_BAD_PROTOTYPE, -1, f.regs.sp[-2], NULL);
52911:         THROW();
52894:     }
52894: 
53081:     f.regs.sp[-3].setBoolean(js_IsDelegate(f.cx, &lref.toObject(), f.regs.sp[-3]));
52894: }
52781: 
52781: void JS_FASTCALL
52781: stubs::ArgCnt(VMFrame &f)
52781: {
52781:     JSContext *cx = f.cx;
52781:     JSRuntime *rt = cx->runtime;
53482:     JSStackFrame *fp = f.fp();
52781: 
52781:     jsid id = ATOM_TO_JSID(rt->atomState.lengthAtom);
52781:     f.regs.sp++;
52781:     if (!js_GetArgsProperty(cx, fp, id, &f.regs.sp[-1]))
52781:         THROW();
52781: }
52781: 
52785: void JS_FASTCALL
52785: stubs::EnterBlock(VMFrame &f, JSObject *obj)
52785: {
52785:     JSFrameRegs &regs = f.regs;
53482:     JSStackFrame *fp = f.fp();
52785: 
52785:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(obj));
52785:     JS_ASSERT(fp->base() + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
52785:     Value *vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
52785:     JS_ASSERT(regs.sp < vp);
53440:     JS_ASSERT(vp <= fp->slots() + fp->getScript()->nslots);
52785:     SetValueRangeToUndefined(regs.sp, vp);
52785:     regs.sp = vp;
52785: 
52785: #ifdef DEBUG
52787:     JSContext *cx = f.cx;
53435:     JS_ASSERT(fp->maybeBlockChain() == obj->getParent());
52785: 
52785:     /*
53435:      * The young end of fp->getScopeChain() may omit blocks if we haven't closed
53435:      * over them, but if there are any closure blocks on fp->getScopeChain(), they'd
52785:      * better be (clones of) ancestors of the block we're entering now;
53435:      * anything else we should have popped off fp->getScopeChain() when we left its
52785:      * static scope.
52785:      */
53435:     JSObject *obj2 = fp->getScopeChain();
52785:     Class *clasp;
52785:     while ((clasp = obj2->getClass()) == &js_WithClass)
52785:         obj2 = obj2->getParent();
52785:     if (clasp == &js_BlockClass &&
52785:         obj2->getPrivate() == js_FloatingFrameIfGenerator(cx, fp)) {
52785:         JSObject *youngestProto = obj2->getProto();
52785:         JS_ASSERT(!OBJ_IS_CLONED_BLOCK(youngestProto));
52785:         JSObject *parent = obj;
52785:         while ((parent = parent->getParent()) != youngestProto)
52785:             JS_ASSERT(parent);
52785:     }
52785: #endif
52785: 
53435:     fp->setBlockChain(obj);
52785: }
52785: 
52785: void JS_FASTCALL
52785: stubs::LeaveBlock(VMFrame &f)
52785: {
52785:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52785: 
52785: #ifdef DEBUG
53435:     JS_ASSERT(fp->getBlockChain()->getClass() == &js_BlockClass);
53435:     uintN blockDepth = OBJ_BLOCK_DEPTH(cx, fp->getBlockChain());
52785: 
53440:     JS_ASSERT(blockDepth <= StackDepth(fp->getScript()));
52785: #endif
52785:     /*
52785:      * If we're about to leave the dynamic scope of a block that has been
53435:      * cloned onto fp->getScopeChain(), clear its private data, move its locals from
52785:      * the stack into the clone, and pop it off the chain.
52785:      */
53435:     JSObject *obj = fp->getScopeChain();
53435:     if (obj->getProto() == fp->getBlockChain()) {
52785:         JS_ASSERT(obj->getClass() == &js_BlockClass);
52785:         if (!js_PutBlockObject(cx, JS_TRUE))
52785:             THROW();
52785:     }
52785: 
52785:     /* Pop the block chain, too.  */
53435:     fp->setBlockChain(fp->getBlockChain()->getParent());
52785: }
52785: 
52793: void * JS_FASTCALL
52793: stubs::LookupSwitch(VMFrame &f, jsbytecode *pc)
52793: {
52793:     jsbytecode *jpc = pc;
53482:     JSScript *script = f.fp()->getScript();
52793: 
52793:     /* This is correct because the compiler adjusts the stack beforehand. */
52793:     Value lval = f.regs.sp[-1];
52793: 
52793:     if (!lval.isPrimitive()) {
52793:         ptrdiff_t offs = (pc + GET_JUMP_OFFSET(pc)) - script->code;
52793:         JS_ASSERT(script->nmap[offs]);
52793:         return script->nmap[offs];
52793:     }
52793: 
52793:     JS_ASSERT(pc[0] == JSOP_LOOKUPSWITCH);
52793:     
52793:     pc += JUMP_OFFSET_LEN;
52793:     uint32 npairs = GET_UINT16(pc);
52793:     pc += UINT16_LEN;
52793: 
52793:     JS_ASSERT(npairs);
52793: 
52793:     if (lval.isString()) {
53081:         JSString *str = lval.toString();
52793:         for (uint32 i = 1; i <= npairs; i++) {
52793:             Value rval = script->getConst(GET_INDEX(pc));
52793:             pc += INDEX_LEN;
52793:             if (rval.isString()) {
53081:                 JSString *rhs = rval.toString();
52793:                 if (rhs == str || js_EqualStrings(str, rhs)) {
52793:                     ptrdiff_t offs = (jpc + GET_JUMP_OFFSET(pc)) - script->code;
52793:                     JS_ASSERT(script->nmap[offs]);
52793:                     return script->nmap[offs];
52793:                 }
52793:             }
52793:             pc += JUMP_OFFSET_LEN;
52793:         }
52793:     } else if (lval.isNumber()) {
53081:         double d = lval.toNumber();
52793:         for (uint32 i = 1; i <= npairs; i++) {
52793:             Value rval = script->getConst(GET_INDEX(pc));
52793:             pc += INDEX_LEN;
53081:             if (rval.isNumber() && d == rval.toNumber()) {
52793:                 ptrdiff_t offs = (jpc + GET_JUMP_OFFSET(pc)) - script->code;
52793:                 JS_ASSERT(script->nmap[offs]);
52793:                 return script->nmap[offs];
52793:             }
52793:             pc += JUMP_OFFSET_LEN;
52793:         }
52793:     } else {
52793:         for (uint32 i = 1; i <= npairs; i++) {
52793:             Value rval = script->getConst(GET_INDEX(pc));
52793:             pc += INDEX_LEN;
52793:             if (lval == rval) {
52793:                 ptrdiff_t offs = (jpc + GET_JUMP_OFFSET(pc)) - script->code;
52793:                 JS_ASSERT(script->nmap[offs]);
52793:                 return script->nmap[offs];
52793:             }
52793:             pc += JUMP_OFFSET_LEN;
52793:         }
52793:     }
52793: 
52793:     ptrdiff_t offs = (jpc + GET_JUMP_OFFSET(jpc)) - script->code;
52793:     JS_ASSERT(script->nmap[offs]);
52793:     return script->nmap[offs];
52793: }
52793: 
52794: void * JS_FASTCALL
52794: stubs::TableSwitch(VMFrame &f, jsbytecode *origPc)
52794: {
52794:     jsbytecode * const originalPC = origPc;
52794:     jsbytecode *pc = originalPC;
53482:     JSScript *script = f.fp()->getScript();
52794:     uint32 jumpOffset = GET_JUMP_OFFSET(pc);
52794:     pc += JUMP_OFFSET_LEN;
52794: 
52794:     /* Note: compiler adjusts the stack beforehand. */
52794:     Value rval = f.regs.sp[-1];
52794: 
52794:     jsint tableIdx;
52794:     if (rval.isInt32()) {
53081:         tableIdx = rval.toInt32();
52794:     } else if (rval.isDouble()) {
53081:         double d = rval.toDouble();
52794:         if (d == 0) {
52794:             /* Treat -0 (double) as 0. */
52794:             tableIdx = 0;
53051:         } else if (!JSDOUBLE_IS_INT32(d, (int32_t *)&tableIdx)) {
52794:             goto finally;
52794:         }
52794:     } else {
52794:         goto finally;
52794:     }
52794: 
52794:     {
52794:         uint32 low = GET_JUMP_OFFSET(pc);
52794:         pc += JUMP_OFFSET_LEN;
52794:         uint32 high = GET_JUMP_OFFSET(pc);
52794:         pc += JUMP_OFFSET_LEN;
52794: 
52794:         tableIdx -= low;
52794:         if ((jsuint) tableIdx < (jsuint)(high - low + 1)) {
52794:             pc += JUMP_OFFSET_LEN * tableIdx;
52794:             uint32 candidateOffset = GET_JUMP_OFFSET(pc);
52794:             if (candidateOffset)
52794:                 jumpOffset = candidateOffset;
52794:         }
52794:     }
52794: 
52794: finally:
52794:     /* Provide the native address. */
52794:     ptrdiff_t offset = (originalPC + jumpOffset) - script->code;
52794:     JS_ASSERT(script->nmap[offset]);
52794:     return script->nmap[offset];
52794: }
52794: 
52874: void JS_FASTCALL
52874: stubs::Unbrand(VMFrame &f)
52874: {
53531:     JSObject *obj = &f.regs.sp[-1].toObject();
53531:     if (obj->isNative() && !obj->unbrand(f.cx))
52874:         THROW();
52874: }
52874: 
52916: void JS_FASTCALL
52916: stubs::Pos(VMFrame &f)
52916: {
52916:     if (!ValueToNumber(f.cx, &f.regs.sp[-1]))
52916:         THROW();
52916: }
52916: 
53037: void JS_FASTCALL
53037: stubs::ArgSub(VMFrame &f, uint32 n)
53037: {
53037:     jsid id = INT_TO_JSID(n);
53037:     Value rval;
53482:     if (!js_GetArgsProperty(f.cx, f.fp(), id, &rval))
53037:         THROW();
53037:     f.regs.sp[0] = rval;
53037: }
53037: 
