75615: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
75615: /* vim: set ts=40 sw=4 et tw=99: */
75615: /* ***** BEGIN LICENSE BLOCK *****
75615:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
75615:  *
75615:  * The contents of this file are subject to the Mozilla Public License Version
75615:  * 1.1 (the "License"); you may not use this file except in compliance with
75615:  * the License. You may obtain a copy of the License at
75615:  * http://www.mozilla.org/MPL/
75615:  *
75615:  * Software distributed under the License is distributed on an "AS IS" basis,
75615:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
75615:  * for the specific language governing rights and limitations under the
75615:  * License.
75615:  *
75615:  * The Original Code is the Mozilla SpiderMonkey bytecode type inference
75615:  *
75615:  * The Initial Developer of the Original Code is
75615:  *   Mozilla Foundation
75615:  * Portions created by the Initial Developer are Copyright (C) 2010
75615:  * the Initial Developer. All Rights Reserved.
75615:  *
75615:  * Contributor(s):
75615:  *   Brian Hackett <bhackett@mozilla.com>
75615:  *
75615:  * Alternatively, the contents of this file may be used under the terms of
75615:  * either of the GNU General Public License Version 2 or later (the "GPL"),
75615:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
75615:  * in which case the provisions of the GPL or the LGPL are applicable instead
75615:  * of those above. If you wish to allow use of your version of this file only
75615:  * under the terms of either the GPL or the LGPL, and not to allow others to
75615:  * use your version of this file under the terms of the MPL, indicate your
75615:  * decision by deleting the provisions above and replace them with the notice
75615:  * and other provisions required by the GPL or the LGPL. If you do not delete
75615:  * the provisions above, a recipient may use your version of this file under
75615:  * the terms of any one of the MPL, the GPL or the LGPL.
75615:  *
75615:  * ***** END LICENSE BLOCK ***** */
75615: 
75615: #include "jsapi.h"
75615: #include "jsautooplen.h"
75615: #include "jsbit.h"
75615: #include "jsbool.h"
75615: #include "jsdate.h"
75615: #include "jsexn.h"
75637: #include "jsgc.h"
75615: #include "jsinfer.h"
75615: #include "jsmath.h"
75615: #include "jsnum.h"
75615: #include "jsobj.h"
75615: #include "jsscript.h"
75615: #include "jscntxt.h"
75615: #include "jsscan.h"
75615: #include "jsscope.h"
75615: #include "jsstr.h"
75615: #include "jstl.h"
75615: #include "jsiter.h"
75615: 
75636: #include "methodjit/MethodJIT.h"
75636: #include "methodjit/Retcon.h"
75636: 
75640: #include "jsatominlines.h"
75615: #include "jsinferinlines.h"
75615: #include "jsobjinlines.h"
75615: #include "jsscriptinlines.h"
75615: 
75615: #ifdef JS_HAS_XML_SUPPORT
75615: #include "jsxml.h"
75615: #endif
75615: 
75615: static inline jsid
75615: id_prototype(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_arguments(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_length(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
75615: }
75615: 
75615: static inline jsid
75615: id___proto__(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_constructor(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.constructorAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_caller(JSContext *cx) {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.callerAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_toString(JSContext *cx)
75615: {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.toStringAtom);
75615: }
75615: 
75615: static inline jsid
75615: id_toSource(JSContext *cx)
75615: {
75615:     return ATOM_TO_JSID(cx->runtime->atomState.toSourceAtom);
75615: }
75615: 
75615: namespace js {
75615: namespace types {
75615: 
75615: static const char *js_CodeNameTwo[] = {
75615: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
75615:     name,
75615: #include "jsopcode.tbl"
75615: #undef OPDEF
75615: };
75615: 
75720: const char *
75720: TypeIdStringImpl(jsid id)
75720: {
75720:     if (JSID_IS_VOID(id))
75720:         return "(index)";
75720:     if (JSID_IS_EMPTY(id))
75720:         return "(new)";
75720:     static char bufs[4][100];
75720:     static unsigned which = 0;
75720:     which = (which + 1) & 3;
75720:     PutEscapedString(bufs[which], 100, JSID_TO_FLAT_STRING(id), 0);
75720:     return bufs[which];
75720: }
75720: 
75615: /////////////////////////////////////////////////////////////////////
75638: // Logging
75638: /////////////////////////////////////////////////////////////////////
75638: 
75638: static bool InferSpewActive(SpewChannel channel)
75638: {
75638:     static bool active[SPEW_COUNT];
75638:     static bool checked = false;
75638:     if (!checked) {
75638:         checked = true;
75638:         PodArrayZero(active);
75638:         const char *env = getenv("INFERFLAGS");
75638:         if (!env)
75638:             return false;
75638:         if (strstr(env, "ops"))
75638:             active[ISpewOps] = true;
75638:         if (strstr(env, "result"))
75638:             active[ISpewResult] = true;
75638:         if (strstr(env, "full")) {
75638:             for (unsigned i = 0; i < SPEW_COUNT; i++)
75638:                 active[i] = true;
75638:         }
75638:     }
75638:     return active[channel];
75638: }
75638: 
75640: #ifdef DEBUG
75640: 
75640: const char *
75640: TypeString(jstype type)
75640: {
75640:     switch (type) {
75640:       case TYPE_UNDEFINED:
75640:         return "void";
75640:       case TYPE_NULL:
75640:         return "null";
75640:       case TYPE_BOOLEAN:
75640:         return "bool";
75640:       case TYPE_INT32:
75640:         return "int";
75640:       case TYPE_DOUBLE:
75640:         return "float";
75640:       case TYPE_STRING:
75640:         return "string";
75640:       case TYPE_UNKNOWN:
75640:         return "unknown";
75640:       default: {
75640:         JS_ASSERT(TypeIsObject(type));
75640:         TypeObject *object = (TypeObject *) type;
75679:         return object->name();
75640:       }
75640:     }
75640: }
75640: 
75638: void InferSpew(SpewChannel channel, const char *fmt, ...)
75638: {
75638:     if (!InferSpewActive(channel))
75638:         return;
75638: 
75638:     va_list ap;
75638:     va_start(ap, fmt);
75638:     fprintf(stdout, "[infer] ");
75638:     vfprintf(stdout, fmt, ap);
75638:     fprintf(stdout, "\n");
75638:     va_end(ap);
75638: }
75638: 
75737: /* Whether types can be considered to contain type or an equivalent, for checking results. */
75737: static inline bool
75737: TypeSetMatches(JSContext *cx, TypeSet *types, jstype type)
75737: {
75737:     if (types->hasType(type))
75737:         return true;
75737: 
75737:     /*
75737:      * If this is a type for an object with unknown properties, match any object
75737:      * in the type set which also has unknown properties. This avoids failure
75737:      * on objects whose prototype (and thus type) changes dynamically, which will
75737:      * mark the old and new type objects as unknown.
75737:      */
75760:     if (js::types::TypeIsObject(type) && ((js::types::TypeObject*)type)->unknownProperties) {
75737:         if (types->objectCount >= 2) {
75737:             unsigned objectCapacity = HashSetCapacity(types->objectCount);
75737:             for (unsigned i = 0; i < objectCapacity; i++) {
75737:                 TypeObject *object = types->objectSet[i];
75760:                 if (object && object->unknownProperties)
75737:                     return true;
75737:             }
75737:         } else if (types->objectCount == 1) {
75737:             TypeObject *object = (TypeObject *) types->objectSet;
75760:             if (object->unknownProperties)
75737:                 return true;
75760:         }
75737:     }
75737: 
75737:     return false;
75737: }
75737: 
75737: bool
75737: TypeHasProperty(JSContext *cx, TypeObject *obj, jsid id, const Value &value)
75737: {
75737:     /*
75737:      * Check the correctness of the type information in the object's property
75737:      * against an actual value. Note that we are only checking the .types set,
75737:      * not the .ownTypes set, and could miss cases where a type set is missing
75737:      * entries from its ownTypes set when they are shadowed by a prototype property.
75737:      */
75757:     if (cx->typeInferenceEnabled() && !obj->unknownProperties && !value.isUndefined()) {
75737:         id = MakeTypeId(cx, id);
75737: 
75737:         /* Watch for properties which inference does not monitor. */
75737:         if (id == id___proto__(cx) || id == id_constructor(cx) || id == id_caller(cx))
75737:             return true;
75737: 
75737:         /*
75737:          * If we called in here while resolving a type constraint, we may be in the
75737:          * middle of resolving a standard class and the type sets will not be updated
75737:          * until the outer TypeSet::add finishes.
75737:          */
75737:         if (cx->compartment->types.pendingCount)
75737:             return true;
75737: 
75737:         jstype type = GetValueType(cx, value);
75737: 
75737:         AutoEnterTypeInference enter(cx);
75737: 
75737:         TypeSet *types = obj->getProperty(cx, id, false);
75737:         if (types && !TypeSetMatches(cx, types, type)) {
75737:             TypeFailure(cx, "Missing type in object %s %s: %s",
75737:                         obj->name(), TypeIdString(id), TypeString(type));
75737:         }
75737: 
75737:         cx->compartment->types.checkPendingRecompiles(cx);
75737:     }
75737:     return true;
75737: }
75737: 
75640: #endif
75640: 
75640: void TypeFailure(JSContext *cx, const char *fmt, ...)
75638: {
75638:     va_list ap;
75638:     va_start(ap, fmt);
75731:     fprintf(stderr, "[infer failure] ");
75731:     vfprintf(stderr, fmt, ap);
75731:     fprintf(stderr, "\n");
75638:     va_end(ap);
75638: 
75770:     cx->compartment->types.print(cx, cx->compartment);
75640: 
75731:     fflush(stderr);
75640:     *((int*)NULL) = 0;  /* Type warnings */
75640: }
75638: 
75638: /////////////////////////////////////////////////////////////////////
75615: // TypeSet
75615: /////////////////////////////////////////////////////////////////////
75615: 
75708: /* Type state maintained during the inference pass through the script. */
75708: 
75708: struct AnalyzeStateStack {
75708:     TypeSet *types;
75708: 
75708:     /* Whether this node is the iterator for a 'for each' loop. */
75708:     bool isForEach;
75708: 
75708:     /* Any active initializer. */
75708:     TypeObject *initializer;
75708: };
75708: 
75708: struct AnalyzeState {
75720:     JSContext *cx;
75720: 
75708:     analyze::Script &analysis;
75708:     JSArenaPool &pool;
75708: 
75708:     AnalyzeStateStack *stack;
75708: 
75708:     /* Current stack depth. */
75708:     unsigned stackDepth;
75708: 
75708:     /* Stack types at join points. */
75708:     TypeSet ***joinTypes;
75708: 
75708:     /* Last opcode was JSOP_GETTER or JSOP_SETTER. */
75708:     bool hasGetSet;
75708: 
75708:     /* Last opcode was JSOP_HOLE. */
75708:     bool hasHole;
75708: 
75720:     AnalyzeState(JSContext *cx, analyze::Script &analysis)
75720:         : cx(cx), analysis(analysis), pool(analysis.pool),
75718:           stack(NULL), stackDepth(0), hasGetSet(false), hasHole(false)
75708:     {}
75708: 
75720:     bool init(JSScript *script)
75708:     {
75708:         unsigned length = (script->nslots * sizeof(AnalyzeStateStack))
75708:                         + (script->length * sizeof(TypeSet**));
75708:         unsigned char *cursor = (unsigned char *) cx->calloc(length);
75708:         if (!cursor)
75708:             return false;
75708: 
75708:         stack = (AnalyzeStateStack *) cursor;
75708: 
75708:         cursor += (script->nslots * sizeof(AnalyzeStateStack));
75708:         joinTypes = (TypeSet ***) cursor;
75708:         return true;
75708:     }
75708: 
75720:     ~AnalyzeState()
75708:     {
75708:         cx->free(stack);
75708:     }
75708: 
75708:     AnalyzeStateStack &popped(unsigned i) {
75708:         JS_ASSERT(i < stackDepth);
75708:         return stack[stackDepth - 1 - i];
75708:     }
75708: 
75708:     const AnalyzeStateStack &popped(unsigned i) const {
75708:         JS_ASSERT(i < stackDepth);
75708:         return stack[stackDepth - 1 - i];
75708:     }
75708: };
75708: 
75708: /////////////////////////////////////////////////////////////////////
75708: // TypeSet
75708: /////////////////////////////////////////////////////////////////////
75708: 
75794: void
75794: TypeSet::addTypeSet(JSContext *cx, ClonedTypeSet *types)
75794: {
75794:     if (types->typeFlags & TYPE_FLAG_UNKNOWN) {
75794:         addType(cx, TYPE_UNKNOWN);
75794:         return;
75794:     }
75794: 
75794:     for (jstype type = TYPE_UNDEFINED; type <= TYPE_STRING; type++) {
75794:         if (types->typeFlags & (1 << type))
75794:             addType(cx, type);
75794:     }
75794: 
75794:     if (types->objectCount >= 2) {
75794:         for (unsigned i = 0; i < types->objectCount; i++)
75794:             addType(cx, (jstype) types->objectSet[i]);
75794:     } else if (types->objectCount == 1) {
75794:         addType(cx, (jstype) types->objectSet);
75794:     }
75794: }
75794: 
75615: inline void
75615: TypeSet::add(JSContext *cx, TypeConstraint *constraint, bool callExisting)
75615: {
75854:     JS_ASSERT_IF(!constraint->condensed() && !constraint->baseSubset(),
75854:                  constraint->script->compartment == cx->compartment);
75720:     JS_ASSERT_IF(!constraint->condensed(), cx->compartment->types.inferenceDepth);
75720:     JS_ASSERT_IF(typeFlags & TYPE_FLAG_INTERMEDIATE_SET,
75720:                  !constraint->baseSubset() && !constraint->condensed());
75720: 
75720:     if (!constraint) {
75720:         /* OOM failure while constructing the constraint. */
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:     }
75720: 
75718:     InferSpew(ISpewOps, "addConstraint: T%p C%p %s",
75718:               this, constraint, constraint->kind());
75615: 
75615:     JS_ASSERT(constraint->next == NULL);
75615:     constraint->next = constraintList;
75615:     constraintList = constraint;
75615: 
75615:     if (!callExisting)
75615:         return;
75615: 
75615:     if (typeFlags & TYPE_FLAG_UNKNOWN) {
75615:         cx->compartment->types.addPending(cx, constraint, this, TYPE_UNKNOWN);
75615:         cx->compartment->types.resolvePending(cx);
75615:         return;
75615:     }
75615: 
75615:     for (jstype type = TYPE_UNDEFINED; type <= TYPE_STRING; type++) {
75615:         if (typeFlags & (1 << type))
75615:             cx->compartment->types.addPending(cx, constraint, this, type);
75615:     }
75615: 
75615:     if (objectCount >= 2) {
75615:         unsigned objectCapacity = HashSetCapacity(objectCount);
75615:         for (unsigned i = 0; i < objectCapacity; i++) {
75615:             TypeObject *object = objectSet[i];
75615:             if (object)
75615:                 cx->compartment->types.addPending(cx, constraint, this, (jstype) object);
75615:         }
75615:     } else if (objectCount == 1) {
75615:         TypeObject *object = (TypeObject*) objectSet;
75615:         cx->compartment->types.addPending(cx, constraint, this, (jstype) object);
75615:     }
75615: 
75615:     cx->compartment->types.resolvePending(cx);
75615: }
75615: 
75615: void
75638: TypeSet::print(JSContext *cx)
75615: {
75720:     if ((typeFlags & ~TYPE_FLAG_INTERMEDIATE_SET) == 0 && !objectCount) {
75638:         printf(" missing");
75615:         return;
75615:     }
75615: 
75615:     if (typeFlags & TYPE_FLAG_UNKNOWN)
75638:         printf(" unknown");
75615: 
75615:     if (typeFlags & TYPE_FLAG_UNDEFINED)
75638:         printf(" void");
75615:     if (typeFlags & TYPE_FLAG_NULL)
75638:         printf(" null");
75615:     if (typeFlags & TYPE_FLAG_BOOLEAN)
75638:         printf(" bool");
75615:     if (typeFlags & TYPE_FLAG_INT32)
75638:         printf(" int");
75615:     if (typeFlags & TYPE_FLAG_DOUBLE)
75638:         printf(" float");
75615:     if (typeFlags & TYPE_FLAG_STRING)
75638:         printf(" string");
75615: 
75720:     if (objectCount) {
75638:         printf(" object[%u]", objectCount);
75615: 
75615:         if (objectCount >= 2) {
75615:             unsigned objectCapacity = HashSetCapacity(objectCount);
75615:             for (unsigned i = 0; i < objectCapacity; i++) {
75615:                 TypeObject *object = objectSet[i];
75615:                 if (object)
75679:                     printf(" %s", object->name());
75615:             }
75615:         } else if (objectCount == 1) {
75615:             TypeObject *object = (TypeObject*) objectSet;
75679:             printf(" %s", object->name());
75615:         }
75615:     }
75615: }
75615: 
75718: class TypeConstraintInput : public TypeConstraint
75718: {
75718: public:
75718:     TypeConstraintInput(JSScript *script)
75718:         : TypeConstraint("input", script)
75718:     {}
75718: 
75718:     bool input() { return true; }
75718: 
75718:     void newType(JSContext *cx, TypeSet *source, jstype type);
75718: };
75718: 
75615: /* Standard subset constraint, propagate all types from one set to another. */
75615: class TypeConstraintSubset : public TypeConstraint
75615: {
75615: public:
75615:     TypeSet *target;
75615: 
75718:     TypeConstraintSubset(JSScript *script, TypeSet *target)
75718:         : TypeConstraint("subset", script), target(target)
75615:     {
75615:         JS_ASSERT(target);
75615:     }
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75718: TypeSet::addSubset(JSContext *cx, JSScript *script, TypeSet *target)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintSubset>(cx->compartment->types.pool, script, target));
75718: }
75718: 
75718: /* Subset constraint not associated with a script's analysis. */
75718: class TypeConstraintBaseSubset : public TypeConstraint
75718: {
75718: public:
75718:     TypeObject *object;
75718:     TypeSet *target;
75718: 
75718:     TypeConstraintBaseSubset(TypeObject *object, TypeSet *target)
75718:         : TypeConstraint("baseSubset", (JSScript *) 0x1),
75718:           object(object), target(target)
75718:     {}
75718: 
75718:     void newType(JSContext *cx, TypeSet *source, jstype type);
75718: 
75718:     TypeObject * baseSubset() { return object; }
75718: };
75718: 
75718: void
75718: TypeSet::addBaseSubset(JSContext *cx, TypeObject *obj, TypeSet *target)
75718: {
75718:     TypeConstraintBaseSubset *constraint =
75750:         (TypeConstraintBaseSubset *) ::js_calloc(sizeof(TypeConstraintBaseSubset));
75720:     if (constraint)
75718:         new(constraint) TypeConstraintBaseSubset(obj, target);
75718:     add(cx, constraint);
75718: }
75718: 
75718: /* Condensed constraint marking a script dependent on this type set. */
75718: class TypeConstraintCondensed : public TypeConstraint
75718: {
75718: public:
75718:     TypeConstraintCondensed(JSScript *script)
75718:         : TypeConstraint("condensed", script)
75718:     {}
75718: 
75718:     void newType(JSContext *cx, TypeSet *source, jstype type);
75833:     void newObjectState(JSContext *cx);
75718: 
75718:     bool condensed() { return true; }
75718: };
75718: 
75718: void
75718: TypeSet::addCondensed(JSContext *cx, JSScript *script)
75718: {
75718:     TypeConstraintCondensed *constraint =
75750:         (TypeConstraintCondensed *) ::js_calloc(sizeof(TypeConstraintCondensed));
75720: 
75720:     if (!constraint) {
75720:         /*
75720:          * These constraints are created during GC, where cx->compartment may
75720:          * not match script->compartment.
75720:          */
75720:         script->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75720: 
75718:     new(constraint) TypeConstraintCondensed(script);
75718:     add(cx, constraint, false);
75615: }
75615: 
75615: /* Constraints for reads/writes on object properties. */
75615: class TypeConstraintProp : public TypeConstraint
75615: {
75615: public:
75708:     const jsbytecode *pc;
75615: 
75615:     /*
75615:      * If assign is true, the target is used to update a property of the object.
75615:      * If assign is false, the target is assigned the value of the property.
75615:      */
75615:     bool assign;
75615:     TypeSet *target;
75615: 
75615:     /* Property being accessed. */
75615:     jsid id;
75615: 
75708:     TypeConstraintProp(JSScript *script, const jsbytecode *pc,
75708:                        TypeSet *target, jsid id, bool assign)
75718:         : TypeConstraint("prop", script), pc(pc),
75708:           assign(assign), target(target), id(id)
75615:     {
75708:         JS_ASSERT(script && pc);
75615: 
75615:         /* If the target is NULL, this is as an inc/dec on the property. */
75615:         JS_ASSERT_IF(!target, assign);
75615:     }
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75708: TypeSet::addGetProperty(JSContext *cx, JSScript *script, const jsbytecode *pc,
75708:                         TypeSet *target, jsid id)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintProp>(cx->compartment->types.pool, script, pc, target, id, false));
75615: }
75615: 
75615: void
75708: TypeSet::addSetProperty(JSContext *cx, JSScript *script, const jsbytecode *pc,
75708:                         TypeSet *target, jsid id)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintProp>(cx->compartment->types.pool, script, pc, target, id, true));
75615: }
75615: 
75679: /* Constraints for determining the 'this' object at sites invoked using 'new'. */
75679: class TypeConstraintNewObject : public TypeConstraint
75679: {
75697:     TypeFunction *fun;
75679:     TypeSet *target;
75679: 
75679:   public:
75718:     TypeConstraintNewObject(JSScript *script, TypeFunction *fun, TypeSet *target)
75718:         : TypeConstraint("newObject", script), fun(fun), target(target)
75679:     {}
75679: 
75679:     void newType(JSContext *cx, TypeSet *source, jstype type);
75679: };
75679: 
75679: void
75718: TypeSet::addNewObject(JSContext *cx, JSScript *script, TypeFunction *fun, TypeSet *target)
75679: {
75720:     add(cx, ArenaNew<TypeConstraintNewObject>(cx->compartment->types.pool, script, fun, target));
75679: }
75679: 
75615: /*
75615:  * Constraints for watching call edges as they are discovered and invoking native
75615:  * function handlers, adding constraints for arguments, receiver objects and the
75615:  * return value, and updating script foundOffsets.
75615:  */
75615: class TypeConstraintCall : public TypeConstraint
75615: {
75615: public:
75615:     /* Call site being tracked. */
75615:     TypeCallsite *callsite;
75615: 
75615:     TypeConstraintCall(TypeCallsite *callsite)
75718:         : TypeConstraint("call", callsite->script), callsite(callsite)
75615:     {}
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75615: TypeSet::addCall(JSContext *cx, TypeCallsite *site)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintCall>(cx->compartment->types.pool, site));
75615: }
75615: 
75615: /* Constraints for arithmetic operations. */
75615: class TypeConstraintArith : public TypeConstraint
75615: {
75615: public:
75615:     /* Type set receiving the result of the arithmetic. */
75615:     TypeSet *target;
75615: 
75615:     /* For addition operations, the other operand. */
75615:     TypeSet *other;
75615: 
75718:     TypeConstraintArith(JSScript *script, TypeSet *target, TypeSet *other)
75718:         : TypeConstraint("arith", script), target(target), other(other)
75615:     {
75615:         JS_ASSERT(target);
75615:     }
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75718: TypeSet::addArith(JSContext *cx, JSScript *script, TypeSet *target, TypeSet *other)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintArith>(cx->compartment->types.pool, script, target, other));
75615: }
75615: 
75615: /* Subset constraint which transforms primitive values into appropriate objects. */
75615: class TypeConstraintTransformThis : public TypeConstraint
75615: {
75615: public:
75615:     TypeSet *target;
75615: 
75708:     TypeConstraintTransformThis(JSScript *script, TypeSet *target)
75718:         : TypeConstraint("transformthis", script), target(target)
75615:     {}
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75708: TypeSet::addTransformThis(JSContext *cx, JSScript *script, TypeSet *target)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintTransformThis>(cx->compartment->types.pool, script, target));
75615: }
75615: 
75615: /* Subset constraint which filters out primitive types. */
75615: class TypeConstraintFilterPrimitive : public TypeConstraint
75615: {
75615: public:
75615:     TypeSet *target;
75615: 
75615:     /* Primitive types other than null and undefined are passed through. */
75615:     bool onlyNullVoid;
75615: 
75718:     TypeConstraintFilterPrimitive(JSScript *script, TypeSet *target, bool onlyNullVoid)
75718:         : TypeConstraint("filter", script), target(target), onlyNullVoid(onlyNullVoid)
75615:     {}
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75718: TypeSet::addFilterPrimitives(JSContext *cx, JSScript *script, TypeSet *target, bool onlyNullVoid)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintFilterPrimitive>(cx->compartment->types.pool,
75720:                                                     script, target, onlyNullVoid));
75615: }
75615: 
75615: /*
75615:  * Subset constraint for property reads which monitors accesses on properties
75615:  * with scripted getters and polymorphic types.
75615:  */
75615: class TypeConstraintMonitorRead : public TypeConstraint
75615: {
75615: public:
75615:     TypeSet *target;
75615: 
75718:     TypeConstraintMonitorRead(JSScript *script, TypeSet *target)
75718:         : TypeConstraint("monitorRead", script), target(target)
75615:     {}
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type);
75615: };
75615: 
75615: void
75718: TypeSet::addMonitorRead(JSContext *cx, JSScript *script, TypeSet *target)
75615: {
75720:     add(cx, ArenaNew<TypeConstraintMonitorRead>(cx->compartment->types.pool, script, target));
75615: }
75615: 
75627: /*
75627:  * Type constraint which marks the result of 'for in' loops as unknown if the
75627:  * iterated value could be a generator.
75627:  */
75627: class TypeConstraintGenerator : public TypeConstraint
75627: {
75627: public:
75627:     TypeSet *target;
75627: 
75718:     TypeConstraintGenerator(JSScript *script, TypeSet *target)
75718:         : TypeConstraint("generator", script), target(target)
75627:     {}
75627: 
75627:     void newType(JSContext *cx, TypeSet *source, jstype type);
75627: };
75627: 
75627: /* Update types with the possible values bound by the for loop in code. */
75627: static inline void
75708: SetForTypes(JSContext *cx, JSScript *script, const AnalyzeState &state, TypeSet *types)
75627: {
75640:     if (state.popped(0).isForEach)
75627:         types->addType(cx, TYPE_UNKNOWN);
75627:     else
75627:         types->addType(cx, TYPE_STRING);
75627: 
75720:     state.popped(0).types->add(cx,
75720:         ArenaNew<TypeConstraintGenerator>(cx->compartment->types.pool, script, types));
75627: }
75627: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeConstraint
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: void
75615: TypeConstraintSubset::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75615:     /* Basic subset constraint, move all types to the target. */
75615:     target->addType(cx, type);
75615: }
75615: 
75718: void
75718: TypeConstraintBaseSubset::newType(JSContext *cx, TypeSet *source, jstype type)
75718: {
75718:     target->addType(cx, type);
75718: }
75718: 
75615: /* Get the object to use for a property access on type. */
75615: static inline TypeObject *
75708: GetPropertyObject(JSContext *cx, JSScript *script, jstype type)
75615: {
75615:     if (TypeIsObject(type))
75615:         return (TypeObject*) type;
75615: 
75615:     /*
75615:      * Handle properties attached to primitive types, treating this access as a
75615:      * read on the primitive's new object.
75615:      */
75720:     TypeObject *object = NULL;
75615:     switch (type) {
75615: 
75615:       case TYPE_INT32:
75615:       case TYPE_DOUBLE:
75720:         object = script->getTypeNewObject(cx, JSProto_Number);
75720:         break;
75615: 
75615:       case TYPE_BOOLEAN:
75720:         object = script->getTypeNewObject(cx, JSProto_Boolean);
75720:         break;
75615: 
75615:       case TYPE_STRING:
75720:         object = script->getTypeNewObject(cx, JSProto_String);
75720:         break;
75615: 
75615:       default:
75615:         /* undefined and null do not have properties. */
75615:         return NULL;
75615:     }
75720: 
75720:     if (!object)
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:     return object;
75615: }
75615: 
75636: /*
75636:  * Handle a property access on a specific object. All property accesses go through
75636:  * here, whether via x.f, x[f], or global name accesses.
75636:  */
75636: static inline void
75708: PropertyAccess(JSContext *cx, JSScript *script, const jsbytecode *pc, TypeObject *object,
75636:                bool assign, TypeSet *target, jsid id)
75636: {
75636:     JS_ASSERT_IF(!target, assign);
75636: 
75636:     /* Monitor assigns on the 'prototype' property. */
75636:     if (assign && id == id_prototype(cx)) {
75708:         cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75636:         return;
75636:     }
75636: 
75636:     /* Monitor accesses on other properties with special behavior we don't keep track of. */
75636:     if (id == id___proto__(cx) || id == id_constructor(cx) || id == id_caller(cx)) {
75636:         if (assign)
75708:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75636:         else
75636:             target->addType(cx, TYPE_UNKNOWN);
75636:         return;
75636:     }
75636: 
75876:     /* Reads from objects with unknown properties are unknown, writes to such objects are ignored. */
75876:     if (object->unknownProperties) {
75876:         if (!assign)
75876:             target->addType(cx, TYPE_UNKNOWN);
75876:         return;
75876:     }
75876: 
75636:     /* Capture the effects of a standard property access. */
75636:     if (target) {
75641:         TypeSet *types = object->getProperty(cx, id, assign);
75720:         if (!types)
75720:             return;
75636:         if (assign)
75718:             target->addSubset(cx, script, types);
75636:         else
75718:             types->addMonitorRead(cx, script, target);
75636:     } else {
75641:         TypeSet *readTypes = object->getProperty(cx, id, false);
75641:         TypeSet *writeTypes = object->getProperty(cx, id, true);
75720:         if (!readTypes || !writeTypes)
75720:             return;
75718:         readTypes->addArith(cx, script, writeTypes);
75636:     }
75636: }
75636: 
75615: void
75615: TypeConstraintProp::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75688:     if (type == TYPE_UNKNOWN ||
75708:         (!TypeIsObject(type) && !script->compileAndGo)) {
75633:         /*
75633:          * Access on an unknown object.  Reads produce an unknown result, writes
75633:          * need to be monitored.  Note: this isn't a problem for handling overflows
75633:          * on inc/dec below, as these go through a slow path which must call
75633:          * addTypeProperty.
75633:          */
75633:         if (assign)
75708:             cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75633:         else
75633:             target->addType(cx, TYPE_UNKNOWN);
75615:         return;
75615:     }
75615: 
75708:     TypeObject *object = GetPropertyObject(cx, script, type);
75636:     if (object)
75708:         PropertyAccess(cx, script, pc, object, assign, target, id);
75615: }
75615: 
75615: void
75679: TypeConstraintNewObject::newType(JSContext *cx, TypeSet *source, jstype type)
75641: {
75641:     if (type == TYPE_UNKNOWN) {
75641:         target->addType(cx, TYPE_UNKNOWN);
75641:         return;
75641:     }
75641: 
75641:     if (TypeIsObject(type)) {
75641:         TypeObject *object = (TypeObject *) type;
75760:         if (object->unknownProperties) {
75760:             target->addType(cx, TYPE_UNKNOWN);
75760:         } else {
75679:             TypeSet *newTypes = object->getProperty(cx, JSID_EMPTY, true);
75720:             if (!newTypes)
75720:                 return;
75718:             newTypes->addMonitorRead(cx, script, target);
75760:         }
75697:     } else if (!fun->script) {
75697:         /*
75768:          * This constraint should only be used for scripted functions and for
75768:          * native constructors with immutable non-primitive prototypes.
75768:          * Disregard primitives here.
75697:          */
75697:     } else if (!fun->script->compileAndGo) {
75697:         target->addType(cx, TYPE_UNKNOWN);
75697:     } else {
75720:         TypeObject *object = fun->script->getTypeNewObject(cx, JSProto_Object);
75720:         if (!object) {
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             return;
75720:         }
75720:         target->addType(cx, (jstype) object);
75641:     }
75641: }
75641: 
75615: void
75615: TypeConstraintCall::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75708:     JSScript *script = callsite->script;
75708:     const jsbytecode *pc = callsite->pc;
75708: 
75615:     if (type == TYPE_UNKNOWN) {
75615:         /* Monitor calls on unknown functions. */
75708:         cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75615:         return;
75615:     }
75615: 
75822:     if (!TypeIsObject(type))
75822:         return;
75822: 
75615:     /* Get the function being invoked. */
75615:     TypeObject *object = (TypeObject*) type;
75822:     if (object->unknownProperties) {
75822:         /* Unknown return value for calls on generic objects. */
75708:         cx->compartment->types.monitorBytecode(cx, script, pc - script->code);
75615:         return;
75822:     }
75822:     if (!object->isFunction) {
75822:         /*
75822:          * If a call on a non-function actually occurs, the call's result
75822:          * should be marked as unknown.
75822:          */
75822:         return;
75822:     }
75822:     TypeFunction *function = object->asFunction();
75615: 
75615:     if (!function->script) {
75615:         JS_ASSERT(function->handler);
75615: 
75777:         if (function->isGeneric) {
75615:             if (callsite->argumentCount == 0) {
75615:                 /* Generic methods called with zero arguments generate runtime errors. */
75615:                 return;
75615:             }
75615: 
75615:             /*
75615:              * Make a new callsite transforming the arguments appropriately, as is
75615:              * done by the generic native dispatchers. watch out for cases where the
75615:              * first argument is null, which will transform to the global object.
75615:              */
75615: 
75720:             TypeSet *thisTypes = TypeSet::make(cx, "genericthis");
75720:             if (!thisTypes)
75720:                 return;
75708:             callsite->argumentTypes[0]->addTransformThis(cx, script, thisTypes);
75708: 
75720:             TypeCallsite *newSite = ArenaNew<TypeCallsite>(cx->compartment->types.pool,
75720:                                                            cx, script, pc, callsite->isNew,
75615:                                                            callsite->argumentCount - 1);
75720:             if (!newSite || (callsite->argumentCount > 1 && !newSite->argumentTypes)) {
75720:                 cx->compartment->types.setPendingNukeTypes(cx);
75720:                 return;
75720:             }
75720: 
75615:             newSite->thisTypes = thisTypes;
75615:             newSite->returnTypes = callsite->returnTypes;
75615:             for (unsigned i = 0; i < callsite->argumentCount - 1; i++)
75615:                 newSite->argumentTypes[i] = callsite->argumentTypes[i + 1];
75615: 
75615:             function->handler(cx, (JSTypeFunction*)function, (JSTypeCallsite*)newSite);
75615:         } else {
75615:             /* Model the function's effects directly. */
75615:             function->handler(cx, (JSTypeFunction*)function, (JSTypeCallsite*)callsite);
75615:         }
75627: 
75615:         return;
75615:     }
75615: 
75708:     JSScript *callee = function->script;
75708:     unsigned nargs = callee->fun->nargs;
75708: 
75708:     /* Analyze the function if we have not already done so. */
75718:     if (!callee->analyzed)
75718:         AnalyzeScriptTypes(cx, callee);
75615: 
75615:     /* Add bindings for the arguments of the call. */
75708:     for (unsigned i = 0; i < callsite->argumentCount && i < nargs; i++) {
75615:         TypeSet *argTypes = callsite->argumentTypes[i];
75718:         TypeSet *types = callee->argTypes(i);
75718:         argTypes->addSubset(cx, script, types);
75615:     }
75615: 
75615:     /* Add void type for any formals in the callee not supplied at the call site. */
75708:     for (unsigned i = callsite->argumentCount; i < nargs; i++) {
75718:         TypeSet *types = callee->argTypes(i);
75615:         types->addType(cx, TYPE_UNDEFINED);
75615:     }
75615: 
75615:     /* Add a binding for the receiver object of the call. */
75615:     if (callsite->isNew) {
75768:         callee->typeSetNewCalled(cx);
75615: 
75615:         /*
75615:          * If the script does not return a value then the pushed value is the new
75615:          * object (typical case).
75615:          */
75615:         if (callsite->returnTypes) {
75718:             callee->thisTypes()->addSubset(cx, script, callsite->returnTypes);
75718:             callee->returnTypes()->addFilterPrimitives(cx, script,
75615:                                                        callsite->returnTypes, false);
75615:         }
75615:     } else {
75615:         if (callsite->thisTypes) {
75615:             /* Add a binding for the receiver object of the call. */
75718:             callsite->thisTypes->addSubset(cx, script, callee->thisTypes());
75615:         } else {
75615:             JS_ASSERT(callsite->thisType != TYPE_NULL);
75718:             callee->thisTypes()->addType(cx, callsite->thisType);
75615:         }
75615: 
75615:         /* Add a binding for the return value of the call. */
75615:         if (callsite->returnTypes)
75718:             callee->returnTypes()->addSubset(cx, script, callsite->returnTypes);
75615:     }
75615: }
75615: 
75615: void
75615: TypeConstraintArith::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75820:     /*
75820:      * We only model a subset of the arithmetic behavior that is actually
75820:      * possible. The following need to be watched for at runtime:
75820:      *
75820:      * 1. Operations producing a double where no operand was a double.
75820:      * 2. Operations producing a string where no operand was a string (addition only).
75820:      * 3. Operations producing a value other than int/double/string.
75820:      */
75615:     if (other) {
75615:         /*
75615:          * Addition operation, consider these cases:
75633:          *   {int,bool} x {int,bool} -> int
75820:          *   double x {int,bool,double} -> double
75615:          *   string x any -> string
75615:          */
75615:         switch (type) {
75615:           case TYPE_DOUBLE:
75615:             if (other->typeFlags & (TYPE_FLAG_UNDEFINED | TYPE_FLAG_NULL |
75820:                                     TYPE_FLAG_INT32 | TYPE_FLAG_DOUBLE | TYPE_FLAG_BOOLEAN) ||
75820:                 other->objectCount != 0) {
75615:                 target->addType(cx, TYPE_DOUBLE);
75820:             }
75615:             break;
75615:           case TYPE_STRING:
75615:             target->addType(cx, TYPE_STRING);
75615:             break;
75820:           case TYPE_UNKNOWN:
75820:             target->addType(cx, TYPE_UNKNOWN);
75615:           default:
75820:             if (other->typeFlags & (TYPE_FLAG_UNDEFINED | TYPE_FLAG_NULL |
75820:                                     TYPE_FLAG_INT32 | TYPE_FLAG_BOOLEAN) ||
75820:                 other->objectCount != 0) {
75820:                 target->addType(cx, TYPE_INT32);
75820:             }
75820:             if (other->typeFlags & TYPE_FLAG_DOUBLE)
75820:                 target->addType(cx, TYPE_DOUBLE);
75615:             break;
75615:         }
75615:     } else {
75633:         switch (type) {
75633:           case TYPE_DOUBLE:
75633:             target->addType(cx, TYPE_DOUBLE);
75633:             break;
75820:           case TYPE_UNKNOWN:
75820:             target->addType(cx, TYPE_UNKNOWN);
75633:           default:
75820:             target->addType(cx, TYPE_INT32);
75633:             break;
75633:         }
75615:     }
75615: }
75615: 
75615: void
75615: TypeConstraintTransformThis::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75708:     if (type == TYPE_UNKNOWN || TypeIsObject(type) || script->strictModeCode) {
75615:         target->addType(cx, type);
75615:         return;
75615:     }
75615: 
75708:     if (!script->compileAndGo) {
75688:         target->addType(cx, TYPE_UNKNOWN);
75688:         return;
75688:     }
75688: 
75615:     TypeObject *object = NULL;
75615:     switch (type) {
75615:       case TYPE_NULL:
75615:       case TYPE_UNDEFINED:
75708:         object = script->getGlobalType();
75615:         break;
75615:       case TYPE_INT32:
75615:       case TYPE_DOUBLE:
75708:         object = script->getTypeNewObject(cx, JSProto_Number);
75615:         break;
75615:       case TYPE_BOOLEAN:
75708:         object = script->getTypeNewObject(cx, JSProto_Boolean);
75615:         break;
75615:       case TYPE_STRING:
75708:         object = script->getTypeNewObject(cx, JSProto_String);
75615:         break;
75615:       default:
75615:         JS_NOT_REACHED("Bad type");
75615:     }
75615: 
75720:     if (!object) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75720: 
75615:     target->addType(cx, (jstype) object);
75615: }
75615: 
75615: void
75615: TypeConstraintFilterPrimitive::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75615:     if (onlyNullVoid) {
75615:         if (type == TYPE_NULL || type == TYPE_UNDEFINED)
75615:             return;
75641:     } else if (type != TYPE_UNKNOWN && TypeIsPrimitive(type)) {
75615:         return;
75615:     }
75615: 
75615:     target->addType(cx, type);
75615: }
75615: 
75615: void
75615: TypeConstraintMonitorRead::newType(JSContext *cx, TypeSet *source, jstype type)
75615: {
75615:     target->addType(cx, type);
75615: }
75615: 
75627: void
75627: TypeConstraintGenerator::newType(JSContext *cx, TypeSet *source, jstype type)
75627: {
75679:     if (type == TYPE_UNKNOWN) {
75627:         target->addType(cx, TYPE_UNKNOWN);
75679:         return;
75679:     }
75679: 
75679:     if (TypeIsPrimitive(type))
75679:         return;
75679: 
75679:     /*
75760:      * Watch for 'for in' on Iterator and Generator objects, which can produce
75760:      * values other than strings.
75679:      */
75679:     TypeObject *object = (TypeObject *) type;
75699:     if (object->proto) {
75699:         Class *clasp = object->proto->getClass();
75699:         if (clasp == &js_IteratorClass || clasp == &js_GeneratorClass)
75627:             target->addType(cx, TYPE_UNKNOWN);
75627:     }
75641: }
75627: 
75615: /////////////////////////////////////////////////////////////////////
75615: // Freeze constraints
75615: /////////////////////////////////////////////////////////////////////
75615: 
75718: void
75718: TypeConstraintCondensed::newType(JSContext *cx, TypeSet *source, jstype type)
75718: {
75718:     if (script->types) {
75718:         /*
75718:          * The script was analyzed, had the analysis collected/condensed,
75718:          * and then was reanalyzed. There are other constraints specifying
75718:          * exactly what the script depends on to trigger recompilation, and
75718:          * we can ignore this new type.
75718:          *
75718:          * Note that for this to hold, reanalysis of a script must always
75718:          * trigger recompilation, to ensure the freeze constraints which
75718:          * describe what the compiler depends on are in place.
75718:          */
75718:         return;
75718:     }
75718: 
75718:     AnalyzeScriptTypes(cx, script);
75718: }
75718: 
75732: void
75833: TypeConstraintCondensed::newObjectState(JSContext *cx)
75732: {
75732:     if (script->types)
75732:         return;
75732:     AnalyzeScriptTypes(cx, script);
75732: }
75732: 
75827: /* Constraint which marks all types as pushed by some bytecode. */
75827: class TypeConstraintPushAll : public TypeConstraint
75827: {
75827: public:
75827:     const jsbytecode *pc;
75827: 
75827:     TypeConstraintPushAll(JSScript *script, const jsbytecode *pc)
75827:         : TypeConstraint("pushAll", script), pc(pc)
75827:     {}
75827: 
75827:     void newType(JSContext *cx, TypeSet *source, jstype type)
75827:     {
75827:         cx->compartment->types.dynamicPush(cx, script, pc - script->code, type);
75827:     }
75827: };
75827: 
75827: void
75827: TypeSet::pushAllTypes(JSContext *cx, JSScript *script, const jsbytecode *pc)
75827: {
75827:     add(cx, ArenaNew<TypeConstraintPushAll>(cx->compartment->types.pool, script, pc));
75827: }
75827: 
75775: /* Constraint which triggers recompilation of a script if any type is added to a type set. */
75794: class TypeConstraintFreeze : public TypeConstraint
75775: {
75775: public:
75794:     /* Whether a new type has already been added, triggering recompilation. */
75775:     bool typeAdded;
75775: 
75794:     TypeConstraintFreeze(JSScript *script)
75794:         : TypeConstraint("freeze", script), typeAdded(false)
75775:     {}
75775: 
75775:     void newType(JSContext *cx, TypeSet *source, jstype type)
75775:     {
75775:         if (typeAdded)
75775:             return;
75775: 
75775:         typeAdded = true;
75775:         cx->compartment->types.addPendingRecompile(cx, script);
75775:     }
75775: };
75775: 
75794: void
75893: TypeSet::addFreeze(JSContext *cx)
75870: {
75893:     add(cx, ArenaNew<TypeConstraintFreeze>(cx->compartment->types.pool,
75893:                                            cx->compartment->types.compiledScript), false);
75870: }
75870: 
75870: void
75893: TypeSet::Clone(JSContext *cx, TypeSet *source, ClonedTypeSet *target)
75775: {
75794:     if (!source) {
75794:         target->typeFlags = TYPE_FLAG_UNKNOWN;
75794:         return;
75794:     }
75794: 
75893:     if (cx->compartment->types.compiledScript && !source->unknown())
75893:         source->addFreeze(cx);
75794: 
75794:     target->typeFlags = source->typeFlags & ~TYPE_FLAG_INTERMEDIATE_SET;
75794:     target->objectCount = source->objectCount;
75794:     if (source->objectCount >= 2) {
75794:         target->objectSet = (TypeObject **) ::js_malloc(sizeof(TypeObject*) * source->objectCount);
75794:         if (!target->objectSet) {
75794:             cx->compartment->types.setPendingNukeTypes(cx);
75794:             target->objectCount = 0;
75794:             return;
75794:         }
75794:         unsigned objectCapacity = HashSetCapacity(source->objectCount);
75794:         unsigned index = 0;
75794:         for (unsigned i = 0; i < objectCapacity; i++) {
75794:             TypeObject *object = source->objectSet[i];
75794:             if (object)
75794:                 target->objectSet[index++] = object;
75794:         }
75794:         JS_ASSERT(index == source->objectCount);
75794:     } else if (source->objectCount == 1) {
75794:         target->objectSet = source->objectSet;
75794:     } else {
75794:         target->objectSet = NULL;
75794:     }
75775: }
75775: 
75615: /*
75623:  * Constraint which triggers recompilation of a script if a possible new JSValueType
75623:  * tag is realized for a type set.
75615:  */
75623: class TypeConstraintFreezeTypeTag : public TypeConstraint
75615: {
75615: public:
75623:     /*
75623:      * Whether the type tag has been marked unknown due to a type change which
75623:      * occurred after this constraint was generated (and which triggered recompilation).
75623:      */
75623:     bool typeUnknown;
75623: 
75636:     TypeConstraintFreezeTypeTag(JSScript *script)
75718:         : TypeConstraint("freezeTypeTag", script), typeUnknown(false)
75615:     {}
75615: 
75615:     void newType(JSContext *cx, TypeSet *source, jstype type)
75615:     {
75623:         if (typeUnknown)
75623:             return;
75623: 
75615:         if (type != TYPE_UNKNOWN && TypeIsObject(type)) {
75623:             /* Ignore new objects when the type set already has other objects. */
75720:             if (source->objectCount >= 2)
75615:                 return;
75615:         }
75615: 
75623:         typeUnknown = true;
75636:         cx->compartment->types.addPendingRecompile(cx, script);
75615:     }
75615: };
75615: 
75625: static inline JSValueType
75625: GetValueTypeFromTypeFlags(TypeFlags flags)
75625: {
75625:     switch (flags) {
75625:       case TYPE_FLAG_UNDEFINED:
75625:         return JSVAL_TYPE_UNDEFINED;
75625:       case TYPE_FLAG_NULL:
75625:         return JSVAL_TYPE_NULL;
75625:       case TYPE_FLAG_BOOLEAN:
75625:         return JSVAL_TYPE_BOOLEAN;
75625:       case TYPE_FLAG_INT32:
75625:         return JSVAL_TYPE_INT32;
75630:       case (TYPE_FLAG_INT32 | TYPE_FLAG_DOUBLE):
75630:         return JSVAL_TYPE_DOUBLE;
75625:       case TYPE_FLAG_STRING:
75625:         return JSVAL_TYPE_STRING;
75625:       default:
75625:         return JSVAL_TYPE_UNKNOWN;
75625:     }
75625: }
75625: 
75625: JSValueType
75893: TypeSet::getKnownTypeTag(JSContext *cx)
75615: {
75720:     TypeFlags flags = typeFlags & ~TYPE_FLAG_INTERMEDIATE_SET;
75720:     JSValueType type;
75720: 
75720:     if (objectCount)
75720:         type = flags ? JSVAL_TYPE_UNKNOWN : JSVAL_TYPE_OBJECT;
75720:     else
75720:         type = GetValueTypeFromTypeFlags(flags);
75636: 
75893:     if (cx->compartment->types.compiledScript && type != JSVAL_TYPE_UNKNOWN) {
75893:         add(cx, ArenaNew<TypeConstraintFreezeTypeTag>(cx->compartment->types.pool,
75893:                                                       cx->compartment->types.compiledScript), false);
75893:     }
75625: 
75625:     return type;
75625: }
75625: 
75864: static inline bool
75864: ObjectKindPair(ObjectKind v0, ObjectKind v1, ObjectKind cmp0, ObjectKind cmp1)
75864: {
75864:     JS_ASSERT(v0 != v1);
75864:     return (v0 == cmp0 && v1 == cmp1) || (v0 == cmp1 && v1 == cmp0);
75864: }
75864: 
75625: /* Compute the meet of kind with the kind of object, per the ObjectKind lattice. */
75625: static inline ObjectKind
75625: CombineObjectKind(TypeObject *object, ObjectKind kind)
75625: {
75734:     /*
75734:      * All type objects with unknown properties are considered interchangeable
75734:      * with one another, as they can be freely exchanged in type sets to handle
75734:      * objects whose __proto__ has been changed.
75734:      */
75833:     if (object->unknownProperties || object->hasSpecialEquality || kind == OBJECT_UNKNOWN)
75734:         return OBJECT_UNKNOWN;
75734: 
75625:     ObjectKind nkind;
75864:     if (object->isFunction && object->asFunction()->script && !object->isUninlineable)
75864:         nkind = OBJECT_INLINEABLE_FUNCTION;
75864:     else if (object->isFunction && object->asFunction()->script)
75864:         nkind = OBJECT_SCRIPTED_FUNCTION;
75864:     else if (object->isFunction)
75864:         nkind = OBJECT_NATIVE_FUNCTION;
75625:     else if (object->isPackedArray)
75625:         nkind = OBJECT_PACKED_ARRAY;
75625:     else if (object->isDenseArray)
75625:         nkind = OBJECT_DENSE_ARRAY;
75625:     else
75833:         nkind = OBJECT_NO_SPECIAL_EQUALITY;
75625: 
75625:     if (kind == nkind || kind == OBJECT_NONE)
75625:         return nkind;
75625: 
75864:     if (ObjectKindPair(kind, nkind, OBJECT_INLINEABLE_FUNCTION, OBJECT_SCRIPTED_FUNCTION))
75864:         return OBJECT_SCRIPTED_FUNCTION;
75864: 
75864:     if (ObjectKindPair(kind, nkind, OBJECT_PACKED_ARRAY, OBJECT_DENSE_ARRAY))
75625:         return OBJECT_DENSE_ARRAY;
75625: 
75833:     return OBJECT_NO_SPECIAL_EQUALITY;
75833: }
75833: 
75833: /* Constraint which triggers recompilation if an object changes state. */
75833: class TypeConstraintFreezeObjectKind : public TypeConstraint
75625: {
75625: public:
75833:     TypeObject *object;
75833: 
75625:     /*
75833:      * Kind being specialized by the parent FreezeObjectConstraint. This may
75833:      * have already changed since this constraint was created.
75625:      */
75625:     ObjectKind *pkind;
75625: 
75833:     TypeConstraintFreezeObjectKind(TypeObject *object, ObjectKind *pkind, JSScript *script)
75833:         : TypeConstraint("freezeObjectKind", script), object(object), pkind(pkind)
75833:     {}
75833: 
75833:     void newType(JSContext *cx, TypeSet *source, jstype type) {}
75833: 
75833:     void newObjectState(JSContext *cx)
75625:     {
75833:         ObjectKind nkind = CombineObjectKind(object, *pkind);
75833:         if (nkind != *pkind) {
75833:             *pkind = nkind;
75636:             cx->compartment->types.addPendingRecompile(cx, script);
75625:         }
75833:     }
75625: };
75625: 
75625: /*
75625:  * Constraint which triggers recompilation if objects of a different kind are
75625:  * added to a type set.
75625:  */
75833: class TypeConstraintFreezeObjectKindSet : public TypeConstraint
75625: {
75625: public:
75625:     ObjectKind kind;
75636: 
75833:     TypeConstraintFreezeObjectKindSet(ObjectKind kind, JSScript *script)
75833:         : TypeConstraint("freezeObjectKindSet", script), kind(kind)
75833:     {
75833:         JS_ASSERT(kind != OBJECT_NONE);
75833:     }
75625: 
75625:     void newType(JSContext *cx, TypeSet *source, jstype type)
75625:     {
75625:         if (kind == OBJECT_UNKNOWN) {
75625:             /* Despecialized the kind we were interested in due to recompilation. */
75625:             return;
75625:         }
75625: 
75625:         if (type == TYPE_UNKNOWN) {
75625:             kind = OBJECT_UNKNOWN;
75625:         } else if (TypeIsObject(type)) {
75625:             TypeObject *object = (TypeObject *) type;
75625:             ObjectKind nkind = CombineObjectKind(object, kind);
75625: 
75841:             if (nkind != OBJECT_UNKNOWN) {
75625:                 /*
75833:                  * Add a constraint on the element type of the object to pick up
75833:                  * changes in the object's array-ness or any unknown properties.
75625:                  */
75641:                 TypeSet *elementTypes = object->getProperty(cx, JSID_VOID, false);
75720:                 if (!elementTypes)
75720:                     return;
75625:                 elementTypes->add(cx,
75833:                     ArenaNew<TypeConstraintFreezeObjectKind>(cx->compartment->types.pool,
75833:                                                              object, &kind, script), false);
75841:             }
75625: 
75625:             if (nkind == kind) {
75625:                 /* New object with the same kind we are interested in. */
75625:                 return;
75625:             }
75625:             kind = nkind;
75833:         } else {
75833:             return;
75833:         }
75636: 
75636:         cx->compartment->types.addPendingRecompile(cx, script);
75625:     }
75625: };
75625: 
75625: ObjectKind
75893: TypeSet::getKnownObjectKind(JSContext *cx)
75625: {
75625:     ObjectKind kind = OBJECT_NONE;
75625: 
75625:     if (objectCount >= 2) {
75625:         unsigned objectCapacity = HashSetCapacity(objectCount);
75625:         for (unsigned i = 0; i < objectCapacity; i++) {
75625:             TypeObject *object = objectSet[i];
75625:             if (object)
75625:                 kind = CombineObjectKind(object, kind);
75625:         }
75625:     } else if (objectCount == 1) {
75625:         kind = CombineObjectKind((TypeObject *) objectSet, kind);
75833:     } else {
75833:         return OBJECT_UNKNOWN;
75625:     }
75625: 
75625:     if (kind != OBJECT_UNKNOWN) {
75625:         /*
75625:          * Watch for new objects of different kind, and re-traverse existing types
75625:          * in this set to add any needed FreezeArray constraints.
75625:          */
75893:         add(cx, ArenaNew<TypeConstraintFreezeObjectKindSet>(cx->compartment->types.pool, kind,
75893:                                                             cx->compartment->types.compiledScript));
75625:     }
75625: 
75625:     return kind;
75625: }
75625: 
75864: static inline void
75864: ObjectStateChange(JSContext *cx, TypeObject *object, bool markingUnknown)
75864: {
75864:     /* All constraints listening to state changes are on the element types. */
75864:     TypeSet *elementTypes = object->getProperty(cx, JSID_VOID, false);
75864:     if (!elementTypes)
75864:         return;
75864:     if (markingUnknown) {
75864:         /* Mark as unknown after getting the element types, to avoid assert. */
75864:         object->unknownProperties = true;
75864:     }
75864:     TypeConstraint *constraint = elementTypes->constraintList;
75864:     while (constraint) {
75864:         constraint->newObjectState(cx);
75864:         constraint = constraint->next;
75864:     }
75864: }
75864: 
75625: bool
75893: TypeSet::knownNonEmpty(JSContext *cx)
75625: {
75858:     if ((typeFlags & ~TYPE_FLAG_INTERMEDIATE_SET) != 0 || objectCount != 0)
75625:         return true;
75677: 
75893:     add(cx, ArenaNew<TypeConstraintFreeze>(cx->compartment->types.pool,
75893:                                            cx->compartment->types.compiledScript), false);
75625: 
75625:     return false;
75615: }
75615: 
75845: JSObject *
75893: TypeSet::getSingleton(JSContext *cx)
75845: {
75858:     if ((typeFlags & ~TYPE_FLAG_INTERMEDIATE_SET) != 0 || objectCount != 1)
75845:         return NULL;
75845: 
75845:     TypeObject *object = (TypeObject *) objectSet;
75845:     if (!object->singleton)
75845:         return NULL;
75845: 
75893:     add(cx, ArenaNew<TypeConstraintFreeze>(cx->compartment->types.pool,
75893:                                            cx->compartment->types.compiledScript), false);
75845: 
75845:     return object->singleton;
75845: }
75845: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeCompartment
75615: /////////////////////////////////////////////////////////////////////
75615: 
75720: void
75720: TypeCompartment::init(JSContext *cx)
75720: {
75720:     PodZero(this);
75720: 
75760:     /*
75760:      * Initialize the empty type object. This is not threaded onto the objects list,
75760:      * will never be collected during GC, and does not have a proto or any properties
75760:      * that need to be marked. It *can* have empty shapes, which are weak references.
75760:      */
75760: #ifdef DEBUG
75760:     typeEmpty.name_ = JSID_VOID;
75760: #endif
75844:     typeEmpty.hasSpecialEquality = true;
75864:     typeEmpty.isUninlineable = true;
75760:     typeEmpty.unknownProperties = true;
75760: 
75720:     if (cx && cx->getRunOptions() & JSOPTION_TYPE_INFERENCE)
75720:         inferenceEnabled = true;
75720: 
75720:     JS_InitArenaPool(&pool, "typeinfer", 512, 8, NULL);
75720: }
75720: 
75720: TypeObject *
75720: TypeCompartment::newTypeObject(JSContext *cx, JSScript *script, const char *name,
75720:                                bool isFunction, JSObject *proto)
75720: {
75720: #ifdef DEBUG
75720: #if 0
75720:     /* Add a unique counter to the name, to distinguish objects from different globals. */
75720:     static unsigned nameCount = 0;
75720:     unsigned len = strlen(name) + 15;
75720:     char *newName = (char *) alloca(len);
75720:     JS_snprintf(newName, len, "%u:%s", ++nameCount, name);
75720:     name = newName;
75720: #endif
75720:     JSAtom *atom = js_Atomize(cx, name, strlen(name), 0);
75720:     if (!atom)
75720:         return NULL;
75720:     jsid id = ATOM_TO_JSID(atom);
75720: #else
75720:     jsid id = JSID_VOID;
75720: #endif
75720: 
75720:     TypeObject *object;
75720:     if (isFunction) {
75720:         object = (TypeFunction *) cx->calloc(sizeof(TypeFunction));
75720:         if (!object)
75720:             return NULL;
75720:         new(object) TypeFunction(id, proto);
75720:     } else {
75720:         object = (TypeObject *) cx->calloc(sizeof(TypeObject));
75720:         if (!object)
75720:             return NULL;
75720:         new(object) TypeObject(id, proto);
75720:     }
75720: 
75720:     TypeObject *&objects = script ? script->typeObjects : this->objects;
75720:     object->next = objects;
75720:     objects = object;
75720: 
75839:     if (!cx->typeInferenceEnabled())
75864:         object->hasSpecialEquality = true;  /* Avoid syncSpecialEquality assert */
75839: 
75720:     return object;
75720: }
75720: 
75720: TypeObject *
75720: TypeCompartment::newInitializerTypeObject(JSContext *cx, JSScript *script,
75720:                                           uint32 offset, bool isArray)
75720: {
75720:     char *name = NULL;
75720: #ifdef DEBUG
75720:     name = (char *) alloca(40);
75720:     JS_snprintf(name, 40, "#%lu:%lu:%s", script->id(), offset, isArray ? "Array" : "Object");
75720: #endif
75720: 
75720:     JSObject *proto;
75720:     JSProtoKey key = isArray ? JSProto_Array : JSProto_Object;
75720:     if (!js_GetClassPrototype(cx, script->getGlobal(), key, &proto, NULL))
75720:         return NULL;
75720: 
75720:     TypeObject *res = newTypeObject(cx, script, name, false, proto);
75720:     if (!res)
75720:         return NULL;
75720: 
75814:     if (isArray) {
75814:         if (!res->unknownProperties)
75814:             res->isDenseArray = res->isPackedArray = true;
75720:         res->initializerArray = true;
75814:     } else {
75720:         res->initializerObject = true;
75814:     }
75720:     res->initializerOffset = offset;
75720: 
75720:     return res;
75720: }
75720: 
75708: static inline jsid
75708: GetAtomId(JSContext *cx, JSScript *script, const jsbytecode *pc, unsigned offset)
75708: {
75708:     unsigned index = js_GetIndexFromBytecode(cx, script, (jsbytecode*) pc, offset);
75708:     return MakeTypeId(cx, ATOM_TO_JSID(script->getAtom(index)));
75708: }
75708: 
75708: static inline jsid
75708: GetGlobalId(JSContext *cx, JSScript *script, const jsbytecode *pc)
75708: {
75708:     unsigned index = GET_SLOTNO(pc);
75708:     return MakeTypeId(cx, ATOM_TO_JSID(script->getGlobalAtom(index)));
75708: }
75708: 
75708: static inline JSObject *
75708: GetScriptObject(JSContext *cx, JSScript *script, const jsbytecode *pc, unsigned offset)
75708: {
75708:     unsigned index = js_GetIndexFromBytecode(cx, script, (jsbytecode*) pc, offset);
75708:     return script->getObject(index);
75708: }
75708: 
75708: static inline const Value &
75708: GetScriptConst(JSContext *cx, JSScript *script, const jsbytecode *pc)
75708: {
75708:     unsigned index = js_GetIndexFromBytecode(cx, script, (jsbytecode*) pc, 0);
75708:     return script->getConst(index);
75708: }
75708: 
75788: bool
75788: UseNewType(JSContext *cx, JSScript *script, jsbytecode *pc)
75788: {
75788:     JS_ASSERT(cx->typeInferenceEnabled());
75788: 
75788:     /*
75788:      * Make a heuristic guess at a use of JSOP_NEW that the constructed object
75788:      * should have a fresh type object. We do this when the NEW is immediately
75788:      * followed by a simple assignment to an object's .prototype field.
75788:      * This is designed to catch common patterns for subclassing in JS:
75788:      *
75788:      * function Super() { ... }
75788:      * function Sub1() { ... }
75788:      * function Sub2() { ... }
75788:      *
75788:      * Sub1.prototype = new Super();
75788:      * Sub2.prototype = new Super();
75788:      *
75788:      * Using distinct type objects for the particular prototypes of Sub1 and
75788:      * Sub2 lets us continue to distinguish the two subclasses and any extra
75788:      * properties added to those prototype objects.
75788:      */
75788:     if (JSOp(*pc) != JSOP_NEW)
75788:         return false;
75788:     pc += JSOP_NEW_LENGTH;
75788:     if (JSOp(*pc) == JSOP_SETPROP) {
75788:         jsid id = GetAtomId(cx, script, pc, 0);
75788:         if (id == id_prototype(cx))
75788:             return true;
75788:     }
75788: 
75788:     return false;
75788: }
75788: 
75615: void
75718: TypeCompartment::growPendingArray(JSContext *cx)
75615: {
75720:     unsigned newCapacity = js::Max(unsigned(100), pendingCapacity * 2);
75770:     PendingWork *newArray = (PendingWork *) js_calloc(newCapacity * sizeof(PendingWork));
75720:     if (!newArray) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75720: 
75720:     memcpy(newArray, pendingArray, pendingCount * sizeof(PendingWork));
75770:     js_free(pendingArray);
75720: 
75720:     pendingArray = newArray;
75720:     pendingCapacity = newCapacity;
75720: }
75720: 
75720: bool
75720: TypeCompartment::dynamicCall(JSContext *cx, JSObject *callee,
75720:                              const js::CallArgs &args, bool constructing)
75615: {
75720:     unsigned nargs = callee->getFunctionPrivate()->nargs;
75720:     JSScript *script = callee->getFunctionPrivate()->script();
75720: 
75720:     if (constructing) {
75768:         script->typeSetNewCalled(cx);
75720:     } else {
75768:         jstype type = GetValueType(cx, args.thisv());
75720:         if (!script->typeSetThis(cx, type))
75720:             return false;
75768:     }
75720: 
75720:     /*
75720:      * Add constraints going up to the minimum of the actual and formal count.
75720:      * If there are more actuals than formals the later values can only be
75720:      * accessed through the arguments object, which is monitored.
75720:      */
75720:     unsigned arg = 0;
75720:     for (; arg < args.argc() && arg < nargs; arg++) {
75720:         if (!script->typeSetArgument(cx, arg, args[arg]))
75720:             return false;
75720:     }
75720: 
75720:     /* Watch for fewer actuals than formals to the call. */
75720:     for (; arg < nargs; arg++) {
75720:         if (!script->typeSetArgument(cx, arg, UndefinedValue()))
75720:             return false;
75720:     }
75720: 
75720:     return true;
75720: }
75720: 
75720: bool
75720: TypeCompartment::dynamicPush(JSContext *cx, JSScript *script, uint32 offset, jstype type)
75633: {
75720:     if (script->types) {
75720:         /*
75827:          * If the pushed set already has this type, we don't need to ensure
75827:          * there is a TypeResult. Either there already is a TypeResult, or the
75827:          * type could be determined from the script's other input type sets.
75720:          */
75720:         js::types::TypeSet *pushed = script->types->pushed(offset, 0);
75720:         if (pushed->hasType(type))
75720:             return true;
75720:     } else {
75720:         /* Scan all TypeResults on the script to check for a duplicate. */
75720:         js::types::TypeResult *result, **presult = &script->typeResults;
75720:         while (*presult) {
75720:             result = *presult;
75720:             if (result->offset == offset && result->type == type) {
75720:                 if (presult != &script->typeResults) {
75720:                     /* Move this result to the head of the list, maintain LRU order. */
75720:                     *presult = result->next;
75720:                     result->next = script->typeResults;
75720:                     script->typeResults = result;
75720:                 }
75720:                 return true;
75720:             }
75720:             presult = &result->next;
75720:         }
75720:     }
75720: 
75718:     AutoEnterTypeInference enter(cx);
75633: 
75789:     InferSpew(ISpewOps, "externalType: monitorResult #%u:%05u: %s",
75722:                script->id(), offset, TypeString(type));
75633: 
75718:     TypeResult *result = (TypeResult *) cx->calloc(sizeof(TypeResult));
75827:     if (!result) {
75827:         setPendingNukeTypes(cx);
75827:         return checkPendingRecompiles(cx);
75827:     }
75720: 
75718:     result->offset = offset;
75718:     result->type = type;
75718:     result->next = script->typeResults;
75718:     script->typeResults = result;
75633: 
75720:     if (script->types) {
75720:         TypeSet *pushed = script->types->pushed(offset, 0);
75720:         pushed->addType(cx, type);
75720:     } else if (script->analyzed) {
75720:         /* Any new dynamic result triggers reanalysis and recompilation. */
75720:         AnalyzeScriptTypes(cx, script);
75720:     }
75720: 
75633:     /*
75864:      * If this script was inlined into a parent, we need to make sure the
75864:      * parent has constraints listening to type changes in this one (it won't
75864:      * necessarily, if we have condensed the constraints but not reanalyzed the
75864:      * parent). The parent is listening for isUninlineable changes on the
75864:      * function, so we can treat this as a state change on the function to
75864:      * trigger any necessary reanalysis.
75864:      */
75877:     if (script->fun && !script->fun->getType()->unknownProperties)
75864:         ObjectStateChange(cx, script->fun->getType(), false);
75864: 
75864:     /*
75633:      * For inc/dec ops, we need to go back and reanalyze the affected opcode
75633:      * taking the overflow into account. We won't see an explicit adjustment
75708:      * of the type of the thing being inc/dec'ed, nor will adding TYPE_DOUBLE to
75708:      * the pushed value affect that type. We only handle inc/dec operations
75708:      * that do not have an object lvalue; INCNAME/INCPROP/INCELEM and friends
75708:      * should call typeMonitorAssign to update the property type.
75633:      */
75708:     jsbytecode *pc = script->code + offset;
75708:     JSOp op = JSOp(*pc);
75633:     const JSCodeSpec *cs = &js_CodeSpec[op];
75633:     if (cs->format & (JOF_INC | JOF_DEC)) {
75708: 
75708:         switch (op) {
75708:           case JSOP_INCGNAME:
75708:           case JSOP_DECGNAME:
75708:           case JSOP_GNAMEINC:
75708:           case JSOP_GNAMEDEC: {
75708:             jsid id = GetAtomId(cx, script, pc, 0);
75760:             TypeObject *global = script->getGlobalType();
75760:             if (!global->unknownProperties) {
75760:                 TypeSet *types = global->getProperty(cx, id, true);
75720:                 if (!types)
75720:                     break;
75708:                 types->addType(cx, type);
75760:             }
75708:             break;
75708:           }
75708: 
75708:           case JSOP_INCLOCAL:
75708:           case JSOP_DECLOCAL:
75708:           case JSOP_LOCALINC:
75720:           case JSOP_LOCALDEC:
75720:             if (GET_SLOTNO(pc) < script->nfixed) {
75718:                 TypeSet *types = script->localTypes(GET_SLOTNO(pc));
75708:                 types->addType(cx, type);
75720:             }
75708:             break;
75708: 
75708:           case JSOP_INCARG:
75708:           case JSOP_DECARG:
75708:           case JSOP_ARGINC:
75708:           case JSOP_ARGDEC: {
75718:             TypeSet *types = script->argTypes(GET_SLOTNO(pc));
75708:             types->addType(cx, type);
75708:             break;
75708:           }
75708: 
75708:           default:;
75708:         }
75633:     }
75633: 
75720:     return checkPendingRecompiles(cx);
75720: }
75720: 
75720: bool
75636: TypeCompartment::processPendingRecompiles(JSContext *cx)
75636: {
75720:     /* Steal the list of scripts to recompile, else we will try to recursively recompile them. */
75720:     Vector<JSScript*> *pending = pendingRecompiles;
75720:     pendingRecompiles = NULL;
75720: 
75864:     JS_ASSERT(!pending->empty());
75864: 
75864: #ifdef JS_METHODJIT
75864: 
75864:     mjit::ExpandInlineFrames(cx, true);
75864: 
75720:     for (unsigned i = 0; i < pending->length(); i++) {
75720:         JSScript *script = (*pending)[i];
75720:         mjit::Recompiler recompiler(cx, script);
75885:         if (script->hasJITCode() && !recompiler.recompile()) {
75720:             pendingNukeTypes = true;
75864:             js_delete< Vector<JSScript*> >(pending);
75720:             return nukeTypes(cx);
75720:         }
75864:     }
75864: 
75864: #endif /* JS_METHODJIT */
75864: 
75864:     js_delete< Vector<JSScript*> >(pending);
75720:     return true;
75720: }
75720: 
75720: void
75720: TypeCompartment::setPendingNukeTypes(JSContext *cx)
75720: {
75720:     if (!pendingNukeTypes) {
75720:         js_ReportOutOfMemory(cx);
75720:         pendingNukeTypes = true;
75720:     }
75720: }
75720: 
75720: bool
75720: TypeCompartment::nukeTypes(JSContext *cx)
75720: {
75636:     /*
75720:      * This is the usual response if we encounter an OOM while adding a type
75720:      * or resolving type constraints. Release all memory used for type information,
75720:      * reset the compartment to not use type inference, and recompile all scripts.
75720:      *
75720:      * Because of the nature of constraint-based analysis (add constraints, and
75720:      * iterate them until reaching a fixpoint), we can't undo an add of a type set,
75720:      * and merely aborting the operation which triggered the add will not be
75720:      * sufficient for correct behavior as we will be leaving the types in an
75720:      * inconsistent state.
75636:      */
75720:     JS_ASSERT(pendingNukeTypes);
75720:     if (pendingRecompiles) {
75730:         cx->free(pendingRecompiles);
75636:         pendingRecompiles = NULL;
75636:     }
75636: 
75720:     /* :FIXME: Implement this function. */
75720:     *((int*)0) = 0;
75720: 
75720:     return true;
75720: }
75720: 
75636: void
75636: TypeCompartment::addPendingRecompile(JSContext *cx, JSScript *script)
75636: {
75636:     if (!script->jitNormal && !script->jitCtor) {
75636:         /* Scripts which haven't been compiled yet don't need to be recompiled. */
75636:         return;
75636:     }
75636: 
75730:     if (!pendingRecompiles) {
75864:         pendingRecompiles = js_new< Vector<JSScript*> >(cx);
75730:         if (!pendingRecompiles) {
75730:             cx->compartment->types.setPendingNukeTypes(cx);
75730:             return;
75730:         }
75730:     }
75636: 
75636:     for (unsigned i = 0; i < pendingRecompiles->length(); i++) {
75636:         if (script == (*pendingRecompiles)[i])
75636:             return;
75636:     }
75636: 
75720:     if (!pendingRecompiles->append(script)) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75720: }
75720: 
75720: bool
75635: TypeCompartment::dynamicAssign(JSContext *cx, JSObject *obj, jsid id, const Value &rval)
75635: {
75674:     if (obj->isWith())
75674:         obj = js_UnwrapWithObject(cx, obj);
75674: 
75635:     jstype rvtype = GetValueType(cx, rval);
75679:     TypeObject *object = obj->getType();
75640: 
75708:     if (object->unknownProperties)
75720:         return true;
75708: 
75679:     id = MakeTypeId(cx, id);
75640: 
75640:     /*
75664:      * Mark as unknown any object which has had dynamic assignments to __proto__,
75664:      * and any object which has had dynamic assignments to string properties through SETELEM.
75664:      * The latter avoids making large numbers of type properties for hashmap-style objects.
75640:      * :FIXME: this is too aggressive for things like prototype library initialization.
75640:      */
75664:     JSOp op = JSOp(*cx->regs->pc);
75720:     if (id == id___proto__(cx) || (op == JSOP_SETELEM && !JSID_IS_VOID(id)))
75720:         return cx->markTypeObjectUnknownProperties(object);
75720: 
75720:     AutoEnterTypeInference enter(cx);
75640: 
75708:     TypeSet *assignTypes = object->getProperty(cx, id, true);
75720:     if (!assignTypes || assignTypes->hasType(rvtype))
75720:         return cx->compartment->types.checkPendingRecompiles(cx);
75635: 
75789:     InferSpew(ISpewOps, "externalType: monitorAssign %s %s: %s",
75679:               object->name(), TypeIdString(id), TypeString(rvtype));
75720:     assignTypes->addType(cx, rvtype);
75720: 
75720:     return cx->compartment->types.checkPendingRecompiles(cx);
75635: }
75635: 
75635: void
75708: TypeCompartment::monitorBytecode(JSContext *cx, JSScript *script, uint32 offset)
75633: {
75708:     if (script->types->monitored(offset))
75633:         return;
75633: 
75633:     /*
75633:      * Make sure monitoring is limited to property sets and calls where the
75633:      * target of the set/call could be statically unknown, and mark the bytecode
75633:      * results as unknown.
75633:      */
75708:     JSOp op = JSOp(script->code[offset]);
75633:     switch (op) {
75633:       case JSOP_SETNAME:
75636:       case JSOP_SETGNAME:
75697:       case JSOP_SETXMLNAME:
75752:       case JSOP_SETCONST:
75633:       case JSOP_SETELEM:
75633:       case JSOP_SETPROP:
75633:       case JSOP_SETMETHOD:
75636:       case JSOP_INITPROP:
75636:       case JSOP_INITMETHOD:
75636:       case JSOP_FORPROP:
75636:       case JSOP_FORNAME:
75716:       case JSOP_FORGNAME:
75636:       case JSOP_ENUMELEM:
75753:       case JSOP_ENUMCONSTELEM:
75636:       case JSOP_DEFFUN:
75636:       case JSOP_DEFFUN_FC:
75716:       case JSOP_ARRAYPUSH:
75633:         break;
75633:       case JSOP_INCNAME:
75633:       case JSOP_DECNAME:
75633:       case JSOP_NAMEINC:
75633:       case JSOP_NAMEDEC:
75636:       case JSOP_INCGNAME:
75636:       case JSOP_DECGNAME:
75636:       case JSOP_GNAMEINC:
75636:       case JSOP_GNAMEDEC:
75633:       case JSOP_INCELEM:
75633:       case JSOP_DECELEM:
75633:       case JSOP_ELEMINC:
75633:       case JSOP_ELEMDEC:
75633:       case JSOP_INCPROP:
75633:       case JSOP_DECPROP:
75633:       case JSOP_PROPINC:
75633:       case JSOP_PROPDEC:
75633:       case JSOP_CALL:
75633:       case JSOP_EVAL:
75633:       case JSOP_FUNCALL:
75633:       case JSOP_FUNAPPLY:
75633:       case JSOP_NEW:
75708:         script->types->addType(cx, offset, 0, TYPE_UNKNOWN);
75633:         break;
75633:       default:
75640:         TypeFailure(cx, "Monitoring unknown bytecode: %s", js_CodeNameTwo[op]);
75640:     }
75640: 
75708:     InferSpew(ISpewOps, "addMonitorNeeded: #%u:%05u", script->id(), offset);
75708: 
75708:     script->types->setMonitored(offset);
75708: 
75864:     /* :FIXME: Also mark scripts this was inlined into as needing recompilation? */
75636:     if (script->hasJITCode())
75636:         cx->compartment->types.addPendingRecompile(cx, script);
75633: }
75633: 
75633: void
75770: TypeCompartment::print(JSContext *cx, JSCompartment *compartment)
75615: {
75615:     JS_ASSERT(this == &compartment->types);
75615: 
75640:     if (!InferSpewActive(ISpewResult) || JS_CLIST_IS_EMPTY(&compartment->scripts))
75638:         return;
75638: 
75615:     for (JSScript *script = (JSScript *)compartment->scripts.next;
75615:          &script->links != &compartment->scripts;
75615:          script = (JSScript *)script->links.next) {
75708:         if (script->types)
75770:             script->types->print(cx, script);
75737:         TypeObject *object = script->typeObjects;
75737:         while (object) {
75737:             object->print(cx);
75737:             object = object->next;
75737:         }
75640:     }
75640: 
75640: #ifdef DEBUG
75615:     TypeObject *object = objects;
75615:     while (object) {
75638:         object->print(cx);
75615:         object = object->next;
75615:     }
75640: #endif
75615: 
75615:     double millis = analysisTime / 1000.0;
75615: 
75638:     printf("Counts: ");
75615:     for (unsigned count = 0; count < TYPE_COUNT_LIMIT; count++) {
75615:         if (count)
75638:             printf("/");
75638:         printf("%u", typeCounts[count]);
75615:     }
75638:     printf(" (%u over)\n", typeCountOver);
75638: 
75640:     printf("Recompilations: %u\n", recompilations);
75638:     printf("Time: %.2f ms\n", millis);
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75770: // TypeCompartment tables
75770: /////////////////////////////////////////////////////////////////////
75770: 
75770: /*
75770:  * The arrayTypeTable and objectTypeTable are per-compartment tables for making
75770:  * common type objects to model the contents of large script singletons and
75770:  * JSON objects. These are vanilla Arrays and native Objects, so we distinguish
75770:  * the types of different ones by looking at the types of their properties.
75770:  *
75770:  * All singleton/JSON arrays which have the same prototype, are homogenous and
75770:  * of the same type will share a type object. All singleton/JSON objects which
75770:  * have the same shape and property types will also share a type object. We
75770:  * don't try to collate arrays or objects that have type mismatches.
75770:  */
75770: 
75770: static inline bool
75770: NumberTypes(jstype a, jstype b)
75770: {
75770:     return (a == TYPE_INT32 || a == TYPE_DOUBLE) && (b == TYPE_INT32 || b == TYPE_DOUBLE);
75770: }
75770: 
75770: struct ArrayTableKey
75770: {
75770:     jstype type;
75770:     JSObject *proto;
75770: 
75770:     typedef ArrayTableKey Lookup;
75770: 
75770:     static inline uint32 hash(const ArrayTableKey &v) {
75771:         return (uint32) (v.type ^ ((uint32)(size_t)v.proto >> 2));
75770:     }
75770: 
75770:     static inline bool match(const ArrayTableKey &v1, const ArrayTableKey &v2) {
75770:         return v1.type == v2.type && v1.proto == v2.proto;
75770:     }
75770: };
75770: 
75770: bool
75770: TypeCompartment::fixArrayType(JSContext *cx, JSObject *obj)
75770: {
75770:     if (!arrayTypeTable) {
75771:         arrayTypeTable = js_new<ArrayTypeTable>();
75770:         if (!arrayTypeTable || !arrayTypeTable->init()) {
75770:             arrayTypeTable = NULL;
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75770:     }
75770: 
75770:     /*
75770:      * If the array is of homogenous type, pick a type object which will be
75770:      * shared with all other singleton/JSON arrays of the same type.
75770:      * If the array is heterogenous, keep the existing type object, which has
75770:      * unknown properties.
75770:      */
75770:     JS_ASSERT(obj->isPackedDenseArray());
75770: 
75770:     unsigned len = obj->getDenseArrayInitializedLength();
75770:     if (len == 0)
75770:         return true;
75770: 
75770:     jstype type = GetValueType(cx, obj->getDenseArrayElement(0));
75770: 
75770:     for (unsigned i = 1; i < len; i++) {
75770:         jstype ntype = GetValueType(cx, obj->getDenseArrayElement(i));
75770:         if (ntype != type) {
75770:             if (NumberTypes(type, ntype))
75770:                 type = TYPE_DOUBLE;
75770:             else
75770:                 return true;
75770:         }
75770:     }
75770: 
75770:     ArrayTableKey key;
75770:     key.type = type;
75770:     key.proto = obj->getProto();
75770:     ArrayTypeTable::AddPtr p = arrayTypeTable->lookupForAdd(key);
75770: 
75770:     if (p) {
75770:         obj->setType(p->value);
75770:     } else {
75770:         TypeObject *objType = newTypeObject(cx, NULL, "TableArray", false, obj->getProto());
75770:         if (!objType) {
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75814:         if (!objType->unknownProperties)
75814:             objType->isDenseArray = objType->isPackedArray = true;
75770:         obj->setType(objType);
75770: 
75770:         if (!cx->addTypePropertyId(objType, JSID_VOID, type))
75770:             return false;
75770: 
75770:         if (!arrayTypeTable->relookupOrAdd(p, key, objType)) {
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75770:     }
75770: 
75770:     return true;
75770: }
75770: 
75770: /*
75770:  * N.B. We could also use the initial shape of the object (before its type is
75770:  * fixed) as the key in the object table, but since all references in the table
75770:  * are weak the hash entries would usually be collected on GC even if objects
75770:  * with the new type/shape are still live.
75770:  */
75770: struct ObjectTableKey
75770: {
75770:     jsid *ids;
75770:     uint32 nslots;
75770:     JSObject *proto;
75770: 
75770:     typedef JSObject * Lookup;
75770: 
75770:     static inline uint32 hash(JSObject *obj) {
75770:         return (uint32) (JSID_BITS(obj->lastProperty()->id) ^
75770:                          obj->slotSpan() ^
75771:                          ((uint32)(size_t)obj->getProto() >> 2));
75770:     }
75770: 
75770:     static inline bool match(const ObjectTableKey &v, JSObject *obj) {
75770:         if (obj->slotSpan() != v.nslots || obj->getProto() != v.proto)
75770:             return false;
75770:         const Shape *shape = obj->lastProperty();
75770:         while (!JSID_IS_EMPTY(shape->id)) {
75770:             if (shape->id != v.ids[shape->slot])
75770:                 return false;
75770:             shape = shape->previous();
75770:         }
75770:         return true;
75770:     }
75770: };
75770: 
75770: struct ObjectTableEntry
75770: {
75770:     TypeObject *object;
75770:     Shape *newShape;
75770:     jstype *types;
75770: };
75770: 
75770: bool
75770: TypeCompartment::fixObjectType(JSContext *cx, JSObject *obj)
75770: {
75770:     if (!objectTypeTable) {
75771:         objectTypeTable = js_new<ObjectTypeTable>();
75770:         if (!objectTypeTable || !objectTypeTable->init()) {
75770:             objectTypeTable = NULL;
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75770:     }
75770: 
75770:     /*
75770:      * Use the same type object for all singleton/JSON arrays with the same
75770:      * base shape, i.e. the same fields written in the same order. If there
75770:      * is a type mismatch with previous objects of the same shape, use the
75770:      * generic unknown type.
75770:      */
75770:     JS_ASSERT(obj->isObject());
75770: 
75770:     if (obj->slotSpan() == 0 || obj->inDictionaryMode())
75770:         return true;
75770: 
75770:     ObjectTypeTable::AddPtr p = objectTypeTable->lookupForAdd(obj);
75770:     const Shape *baseShape = obj->lastProperty();
75770: 
75770:     if (p) {
75770:         /* The lookup ensures the shape matches, now check that the types match. */
75770:         jstype *types = p->value.types;
75770:         for (unsigned i = 0; i < obj->slotSpan(); i++) {
75770:             jstype ntype = GetValueType(cx, obj->getSlot(i));
75770:             if (ntype != types[i]) {
75770:                 if (NumberTypes(ntype, types[i])) {
75770:                     if (types[i] == TYPE_INT32) {
75770:                         types[i] = TYPE_DOUBLE;
75770:                         const Shape *shape = baseShape;
75770:                         while (!JSID_IS_EMPTY(shape->id)) {
75770:                             if (shape->slot == i) {
75770:                                 if (!cx->addTypePropertyId(p->value.object, shape->id, TYPE_DOUBLE))
75770:                                     return false;
75770:                                 break;
75770:                             }
75770:                             shape = shape->previous();
75770:                         }
75770:                     }
75770:                 } else {
75770:                     return true;
75770:                 }
75770:             }
75770:         }
75770: 
75770:         obj->setTypeAndShape(p->value.object, p->value.newShape);
75770:     } else {
75770:         /*
75770:          * Make a new type to use, and regenerate a new shape to go with it.
75770:          * Shapes are rooted at the empty shape for the object's type, so we
75770:          * can't change the type without changing the shape.
75770:          */
75770:         JSObject *xobj = NewBuiltinClassInstance(cx, &js_ObjectClass,
75770:                                                  (gc::FinalizeKind) obj->finalizeKind());
75770:         if (!xobj) {
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75770:         AutoObjectRooter xvr(cx, xobj);
75770: 
75770:         TypeObject *objType = newTypeObject(cx, NULL, "TableObject", false, obj->getProto());
75770:         if (!objType) {
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75770:         xobj->setType(objType);
75770: 
75770:         jsid *ids = (jsid *) cx->calloc(obj->slotSpan() * sizeof(jsid));
75770:         if (!ids)
75770:             return false;
75770: 
75770:         jstype *types = (jstype *) cx->calloc(obj->slotSpan() * sizeof(jstype));
75770:         if (!types)
75770:             return false;
75770: 
75770:         const Shape *shape = baseShape;
75770:         while (!JSID_IS_EMPTY(shape->id)) {
75770:             ids[shape->slot] = shape->id;
75770:             types[shape->slot] = GetValueType(cx, obj->getSlot(shape->slot));
75770:             if (!cx->addTypePropertyId(objType, shape->id, types[shape->slot]))
75770:                 return false;
75770:             shape = shape->previous();
75770:         }
75770: 
75770:         /* Construct the new shape. */
75770:         for (unsigned i = 0; i < obj->slotSpan(); i++) {
75770:             if (!js_DefineNativeProperty(cx, xobj, ids[i], UndefinedValue(), NULL, NULL,
75770:                                          JSPROP_ENUMERATE, 0, 0, NULL, 0)) {
75770:                 return false;
75770:             }
75770:         }
75770:         JS_ASSERT(!xobj->inDictionaryMode());
75770:         const Shape *newShape = xobj->lastProperty();
75770: 
75770:         ObjectTableKey key;
75770:         key.ids = ids;
75770:         key.nslots = obj->slotSpan();
75770:         key.proto = obj->getProto();
75770:         JS_ASSERT(ObjectTableKey::match(key, obj));
75770: 
75770:         ObjectTableEntry entry;
75770:         entry.object = objType;
75770:         entry.newShape = (Shape *) newShape;
75770:         entry.types = types;
75770: 
75770:         p = objectTypeTable->lookupForAdd(obj);
75770:         if (!objectTypeTable->add(p, key, entry)) {
75770:             js_ReportOutOfMemory(cx);
75770:             return false;
75770:         }
75770: 
75770:         obj->setTypeAndShape(objType, newShape);
75770:     }
75770: 
75770:     return true;
75770: }
75770: 
75770: /////////////////////////////////////////////////////////////////////
75641: // TypeObject
75615: /////////////////////////////////////////////////////////////////////
75615: 
75641: void
75641: TypeObject::storeToInstances(JSContext *cx, Property *base)
75641: {
75641:     TypeObject *object = instanceList;
75641:     while (object) {
75641:         Property *p =
75641:             HashSetLookup<jsid,Property,Property>(object->propertySet, object->propertyCount, base->id);
75641:         if (p)
75718:             base->ownTypes.addBaseSubset(cx, object, &p->types);
75641:         if (object->instanceList)
75641:             object->storeToInstances(cx, base);
75641:         object = object->instanceNext;
75641:     }
75641: }
75641: 
75641: void
75705: TypeObject::getFromPrototypes(JSContext *cx, Property *base)
75705: {
75705:      JSObject *obj = proto;
75705:      while (obj) {
75705:          TypeObject *object = obj->getType();
75705:          Property *p =
75705:              HashSetLookup<jsid,Property,Property>(object->propertySet, object->propertyCount, base->id);
75705:          if (p)
75718:              p->ownTypes.addBaseSubset(cx, this, &base->types);
75705:          obj = obj->getProto();
75705:      }
75705: }
75705: 
75705: void
75720: TypeObject::splicePrototype(JSContext *cx, JSObject *proto)
75641: {
75720:     JS_ASSERT(!this->proto);
75813: 
75813:     /*
75813:      * Make sure this is not the shared 'empty' type object. :TODO: once we
75813:      * can mark type objects as singletons, assert that instead.
75813:      */
75813:     JS_ASSERT(this != &cx->compartment->types.typeEmpty);
75813: 
75720:     this->proto = proto;
75720:     this->instanceNext = proto->getType()->instanceList;
75720:     proto->getType()->instanceList = this;
75720: 
75720:     if (!cx->typeInferenceEnabled())
75720:         return;
75720: 
75720:     AutoEnterTypeInference enter(cx);
75720: 
75720:     /*
75720:      * Note: we require (but do not assert) that any property in the prototype
75720:      * or its own prototypes must not share a name with a property already
75720:      * added to an instance of this object.
75720:      */
75720:     if (propertyCount >= 2) {
75720:         unsigned capacity = HashSetCapacity(propertyCount);
75720:         for (unsigned i = 0; i < capacity; i++) {
75720:             Property *prop = propertySet[i];
75720:             if (prop)
75720:                 getFromPrototypes(cx, prop);
75720:         }
75720:     } else if (propertyCount == 1) {
75720:         Property *prop = (Property *) propertySet;
75720:         getFromPrototypes(cx, prop);
75720:     }
75720: 
75720:     JS_ALWAYS_TRUE(cx->compartment->types.checkPendingRecompiles(cx));
75720: }
75720: 
75720: bool
75720: TypeObject::addProperty(JSContext *cx, jsid id, Property **pprop)
75720: {
75720:     JS_ASSERT(!*pprop);
75720:     Property *base = (Property *) cx->calloc(sizeof(Property));
75720:     if (!base) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return false;
75720:     }
75718:     new(base) Property(id);
75718: 
75720:     *pprop = base;
75720: 
75789:     InferSpew(ISpewOps, "typeSet: T%p property %s %s",
75789:               &base->types, name(), TypeIdString(id));
75789:     InferSpew(ISpewOps, "typeSet: T%p own property %s %s",
75789:               &base->ownTypes, name(), TypeIdString(id));
75718: 
75718:     base->ownTypes.addBaseSubset(cx, this, &base->types);
75641: 
75641:     /* Check all transitive instances for this property. */
75641:     if (instanceList)
75641:         storeToInstances(cx, base);
75641: 
75641:     /* Pull in this property from all prototypes up the chain. */
75705:     getFromPrototypes(cx, base);
75720: 
75720:     return true;
75720: }
75720: 
75720: void
75720: TypeObject::markNotPacked(JSContext *cx, bool notDense)
75720: {
75720:     JS_ASSERT(cx->compartment->types.inferenceDepth);
75720: 
75720:     if (notDense) {
75720:         if (!isDenseArray)
75720:             return;
75720:         isDenseArray = false;
75720:     } else if (!isPackedArray) {
75720:         return;
75720:     }
75720:     isPackedArray = false;
75720: 
75789:     InferSpew(ISpewOps, "%s: %s", notDense ? "NonDenseArray" : "NonPackedArray", name());
75720: 
75833:     ObjectStateChange(cx, this, false);
75615: }
75615: 
75615: void
75864: TypeObject::markUninlineable(JSContext *cx)
75864: {
75864:     JS_ASSERT(cx->compartment->types.inferenceDepth);
75864: 
75864:     JS_ASSERT(!isUninlineable);
75864:     isUninlineable = true;
75864: 
75864:     InferSpew(ISpewOps, "Uninlineable: %s", name());
75864: 
75864:     ObjectStateChange(cx, this, false);
75864: }
75864: 
75864: void
75641: TypeObject::markUnknown(JSContext *cx)
75640: {
75641:     JS_ASSERT(!unknownProperties);
75760: 
75833:     InferSpew(ISpewOps, "UnknownProperties: %s", name());
75833: 
75833:     isDenseArray = false;
75833:     isPackedArray = false;
75864:     isUninlineable = true;
75833:     hasSpecialEquality = true;
75833: 
75833:     ObjectStateChange(cx, this, true);
75641: 
75720:     /* Mark existing instances as unknown. */
75720: 
75720:     TypeObject *instance = instanceList;
75720:     while (instance) {
75720:         if (!instance->unknownProperties)
75720:             instance->markUnknown(cx);
75720:         instance = instance->instanceNext;
75720:     }
75640: 
75640:     /*
75641:      * Existing constraints may have already been added to this object, which we need
75640:      * to do the right thing for.  We can't ensure that we will mark all unknown
75640:      * objects before they have been accessed, as the __proto__ of a known object
75640:      * could be dynamically set to an unknown object, and we can decide to ignore
75640:      * properties of an object during analysis (i.e. hashmaps). Adding unknown for
75640:      * any properties accessed already accounts for possible values read from them.
75640:      */
75640: 
75641:     if (propertyCount >= 2) {
75641:         unsigned capacity = HashSetCapacity(propertyCount);
75640:         for (unsigned i = 0; i < capacity; i++) {
75641:             Property *prop = propertySet[i];
75641:             if (prop)
75641:                 prop->ownTypes.addType(cx, TYPE_UNKNOWN);
75641:         }
75641:     } else if (propertyCount == 1) {
75641:         Property *prop = (Property *) propertySet;
75641:         prop->ownTypes.addType(cx, TYPE_UNKNOWN);
75641:     }
75641: }
75641: 
75615: void
75638: TypeObject::print(JSContext *cx)
75615: {
75679:     printf("%s : %s", name(), proto ? proto->getType()->name() : "(null)");
75679: 
75679:     if (unknownProperties)
75679:         printf(" unknown");
75826:     else if (isPackedArray)
75826:         printf(" packed");
75826:     else if (isDenseArray)
75826:         printf(" dense");
75641: 
75641:     if (propertyCount == 0) {
75641:         printf(" {}\n");
75641:         return;
75641:     }
75641: 
75641:     printf(" {");
75641: 
75641:     if (propertyCount >= 2) {
75641:         unsigned capacity = HashSetCapacity(propertyCount);
75641:         for (unsigned i = 0; i < capacity; i++) {
75641:             Property *prop = propertySet[i];
75641:             if (prop) {
75641:                 printf("\n    %s:", TypeIdString(prop->id));
75641:                 prop->ownTypes.print(cx);
75641:             }
75641:         }
75641:     } else if (propertyCount == 1) {
75641:         Property *prop = (Property *) propertySet;
75641:         printf("\n    %s:", TypeIdString(prop->id));
75641:         prop->ownTypes.print(cx);
75641:     }
75641: 
75641:     printf("\n}\n");
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeScript
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: static inline ptrdiff_t
75615: GetJumpOffset(jsbytecode *pc, jsbytecode *pc2)
75615: {
75615:     uint32 type = JOF_OPTYPE(*pc);
75615:     if (JOF_TYPE_IS_EXTENDED_JUMP(type))
75615:         return GET_JUMPX_OFFSET(pc2);
75615:     return GET_JUMP_OFFSET(pc2);
75615: }
75615: 
75615: /* Return whether op bytecodes do not fallthrough (they may do a jump). */
75615: static inline bool
75615: BytecodeNoFallThrough(JSOp op)
75615: {
75615:     switch (op) {
75615:       case JSOP_GOTO:
75615:       case JSOP_GOTOX:
75615:       case JSOP_DEFAULT:
75615:       case JSOP_DEFAULTX:
75615:       case JSOP_RETURN:
75615:       case JSOP_STOP:
75615:       case JSOP_RETRVAL:
75615:       case JSOP_THROW:
75615:       case JSOP_TABLESWITCH:
75615:       case JSOP_TABLESWITCHX:
75615:       case JSOP_LOOKUPSWITCH:
75615:       case JSOP_LOOKUPSWITCHX:
75615:       case JSOP_FILTER:
75615:         return true;
75615:       case JSOP_GOSUB:
75615:       case JSOP_GOSUBX:
75615:         /* These fall through indirectly, after executing a 'finally'. */
75615:         return false;
75615:       default:
75615:         return false;
75615:     }
75615: }
75615: 
75708: /* Merge any types currently in the state with those computed for the join point at offset. */
75708: void
75708: MergeTypes(JSContext *cx, AnalyzeState &state, JSScript *script, uint32 offset)
75615: {
75708:     unsigned targetDepth = state.analysis.getCode(offset).stackDepth;
75708:     JS_ASSERT(state.stackDepth >= targetDepth);
75708:     if (!state.joinTypes[offset]) {
75720:         TypeSet **joinTypes = ArenaArray<TypeSet*>(state.pool, targetDepth);
75720:         if (!joinTypes) {
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             return;
75720:         }
75720:         state.joinTypes[offset] = joinTypes;
75708:         for (unsigned i = 0; i < targetDepth; i++)
75720:             joinTypes[i] = state.stack[i].types;
75615:     }
75708:     for (unsigned i = 0; i < targetDepth; i++) {
75708:         if (!state.joinTypes[offset][i])
75708:             state.joinTypes[offset][i] = state.stack[i].types;
75708:         else if (state.stack[i].types && state.joinTypes[offset][i] != state.stack[i].types)
75718:             state.stack[i].types->addSubset(cx, script, state.joinTypes[offset][i]);
75708:     }
75708: }
75615: 
75615: /*
75615:  * If the bytecode immediately following code/pc is a test of the value
75708:  * pushed by code, that value should be marked as possibly void.
75615:  */
75708: static inline bool
75708: CheckNextTest(jsbytecode *pc)
75615: {
75708:     jsbytecode *next = pc + analyze::GetBytecodeLength(pc);
75615:     switch ((JSOp)*next) {
75615:       case JSOP_IFEQ:
75615:       case JSOP_IFNE:
75615:       case JSOP_NOT:
75703:       case JSOP_OR:
75703:       case JSOP_ORX:
75703:       case JSOP_AND:
75703:       case JSOP_ANDX:
75615:       case JSOP_TYPEOF:
75615:       case JSOP_TYPEOFEXPR:
75708:         return true;
75615:       default:
75708:         return false;
75615:     }
75615: }
75615: 
75708: /* Analyze type information for a single bytecode. */
75720: static bool
75708: AnalyzeBytecode(JSContext *cx, AnalyzeState &state, JSScript *script, uint32 offset)
75615: {
75615:     jsbytecode *pc = script->code + offset;
75615:     JSOp op = (JSOp)*pc;
75615: 
75708:     InferSpew(ISpewOps, "analyze: #%u:%05u", script->id(), offset);
75708: 
75708:     /*
75708:      * Track the state's stack depth against the stack depth computed by the bytecode
75708:      * analysis, and adjust as necessary.
75708:      */
75708:     uint32 stackDepth = state.analysis.getCode(offset).stackDepth;
75708:     if (stackDepth > state.stackDepth) {
75640: #ifdef DEBUG
75640:         /*
75640:          * Check that we aren't destroying any useful information. This should only
75640:          * occur around exception handling bytecode.
75640:          */
75756:         for (unsigned i = state.stackDepth; i < stackDepth; i++)
75640:             JS_ASSERT(!state.stack[i].isForEach);
75640: #endif
75708:         unsigned ndefs = stackDepth - state.stackDepth;
75640:         memset(&state.stack[state.stackDepth], 0, ndefs * sizeof(AnalyzeStateStack));
75640:     }
75708:     state.stackDepth = stackDepth;
75708: 
75708:     /*
75708:      * If this is a join point, merge existing types with the join and then pull
75708:      * in the types already computed.
75708:      */
75708:     if (state.joinTypes[offset]) {
75708:         MergeTypes(cx, state, script, offset);
75708:         for (unsigned i = 0; i < stackDepth; i++)
75708:             state.stack[i].types = state.joinTypes[offset][i];
75708:     }
75708: 
75708:     TypeObject *initializer = NULL;
75708: 
75708:     unsigned defCount = analyze::GetDefCount(script, offset);
75720:     TypeSet *pushed = ArenaArray<TypeSet>(cx->compartment->types.pool, defCount);
75720:     if (!pushed)
75720:         return false;
75708: 
75708:     JS_ASSERT(!script->types->pushedArray[offset]);
75708:     script->types->pushedArray[offset] = pushed;
75708: 
75708:     PodZero(pushed, defCount);
75708: 
75789:     for (unsigned i = 0; i < defCount; i++) {
75720:         pushed[i].setIntermediate();
75789:         InferSpew(ISpewOps, "typeSet: T%p pushed%u #%u:%05u", &pushed[i], i, script->id(), offset);
75789:     }
75720: 
75615:     /* Add type constraints for the various opcodes. */
75615:     switch (op) {
75615: 
75615:         /* Nop bytecodes. */
75636:       case JSOP_POP:
75615:       case JSOP_NOP:
75615:       case JSOP_TRACE:
75615:       case JSOP_GOTO:
75615:       case JSOP_GOTOX:
75615:       case JSOP_IFEQ:
75615:       case JSOP_IFEQX:
75615:       case JSOP_IFNE:
75615:       case JSOP_IFNEX:
75615:       case JSOP_LINENO:
75615:       case JSOP_DEFCONST:
75615:       case JSOP_LEAVEWITH:
75615:       case JSOP_LEAVEBLOCK:
75615:       case JSOP_RETRVAL:
75615:       case JSOP_ENDITER:
75615:       case JSOP_THROWING:
75615:       case JSOP_GOSUB:
75615:       case JSOP_GOSUBX:
75615:       case JSOP_RETSUB:
75615:       case JSOP_CONDSWITCH:
75615:       case JSOP_DEFAULT:
75784:       case JSOP_DEFAULTX:
75615:       case JSOP_POPN:
75615:       case JSOP_UNBRANDTHIS:
75615:       case JSOP_STARTXML:
75615:       case JSOP_STARTXMLEXPR:
75615:       case JSOP_DEFXMLNS:
75615:       case JSOP_SHARPINIT:
75615:       case JSOP_INDEXBASE:
75615:       case JSOP_INDEXBASE1:
75615:       case JSOP_INDEXBASE2:
75615:       case JSOP_INDEXBASE3:
75615:       case JSOP_RESETBASE:
75615:       case JSOP_RESETBASE0:
75615:       case JSOP_BLOCKCHAIN:
75615:       case JSOP_NULLBLOCKCHAIN:
75615:       case JSOP_POPV:
75636:       case JSOP_DEBUGGER:
75699:       case JSOP_SETCALL:
75615:         break;
75615: 
75615:         /* Bytecodes pushing values of known type. */
75615:       case JSOP_VOID:
75615:       case JSOP_PUSH:
75708:         pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       case JSOP_ZERO:
75615:       case JSOP_ONE:
75615:       case JSOP_INT8:
75615:       case JSOP_INT32:
75615:       case JSOP_UINT16:
75615:       case JSOP_UINT24:
75615:       case JSOP_BITAND:
75615:       case JSOP_BITOR:
75615:       case JSOP_BITXOR:
75615:       case JSOP_BITNOT:
75615:       case JSOP_RSH:
75615:       case JSOP_LSH:
75630:       case JSOP_URSH:
75630:         /* :TODO: Add heuristics for guessing URSH which can overflow. */
75708:         pushed[0].addType(cx, TYPE_INT32);
75615:         break;
75615:       case JSOP_FALSE:
75615:       case JSOP_TRUE:
75615:       case JSOP_EQ:
75615:       case JSOP_NE:
75615:       case JSOP_LT:
75615:       case JSOP_LE:
75615:       case JSOP_GT:
75615:       case JSOP_GE:
75615:       case JSOP_NOT:
75615:       case JSOP_STRICTEQ:
75615:       case JSOP_STRICTNE:
75615:       case JSOP_IN:
75615:       case JSOP_INSTANCEOF:
75615:       case JSOP_DELDESC:
75708:         pushed[0].addType(cx, TYPE_BOOLEAN);
75615:         break;
75615:       case JSOP_DOUBLE:
75708:         pushed[0].addType(cx, TYPE_DOUBLE);
75615:         break;
75615:       case JSOP_STRING:
75615:       case JSOP_TYPEOF:
75615:       case JSOP_TYPEOFEXPR:
75615:       case JSOP_QNAMEPART:
75615:       case JSOP_XMLTAGEXPR:
75615:       case JSOP_TOATTRVAL:
75615:       case JSOP_ADDATTRNAME:
75615:       case JSOP_ADDATTRVAL:
75615:       case JSOP_XMLELTEXPR:
75708:         pushed[0].addType(cx, TYPE_STRING);
75615:         break;
75615:       case JSOP_NULL:
75708:         pushed[0].addType(cx, TYPE_NULL);
75615:         break;
75720: 
75615:       case JSOP_REGEXP:
75720:         if (script->compileAndGo) {
75720:             TypeObject *object = script->getTypeNewObject(cx, JSProto_RegExp);
75720:             if (!object)
75720:                 return false;
75720:             pushed[0].addType(cx, (jstype) object);
75720:         } else {
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75720:         }
75615:         break;
75615: 
75716:       case JSOP_OBJECT: {
75716:         JSObject *obj = GetScriptObject(cx, script, pc, 0);
75716:         pushed[0].addType(cx, (jstype) obj->getType());
75716:         break;
75716:       }
75716: 
75615:       case JSOP_STOP:
75615:         /* If a stop is reachable then the return type may be void. */
75708:         if (script->fun)
75718:             script->returnTypes()->addType(cx, TYPE_UNDEFINED);
75615:         break;
75615: 
75615:       case JSOP_OR:
75615:       case JSOP_ORX:
75615:       case JSOP_AND:
75615:       case JSOP_ANDX:
75615:         /* OR/AND push whichever operand determined the result. */
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75640:       case JSOP_DUP:
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[1]);
75615:         break;
75615: 
75615:       case JSOP_DUP2:
75718:         state.popped(1).types->addSubset(cx, script, &pushed[0]);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[1]);
75718:         state.popped(1).types->addSubset(cx, script, &pushed[2]);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[3]);
75615:         break;
75615: 
75615:       case JSOP_GETGLOBAL:
75615:       case JSOP_CALLGLOBAL:
75615:       case JSOP_GETGNAME:
75718:       case JSOP_CALLGNAME: {
75615:         jsid id;
75718:         if (op == JSOP_GETGLOBAL || op == JSOP_CALLGLOBAL)
75708:             id = GetGlobalId(cx, script, pc);
75718:         else
75708:             id = GetAtomId(cx, script, pc, 0);
75636: 
75888:         /*
75888:          * Normally we rely on lazy standard class initialization to fill in
75888:          * the types of global properties the script can access. In a few cases
75888:          * the method JIT will bypass this, and we need to add the types direclty.
75888:          */
75888:         if (id == ATOM_TO_JSID(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]))
75888:             cx->addTypePropertyId(script->getGlobalType(), id, TYPE_UNDEFINED);
75888:         if (id == ATOM_TO_JSID(cx->runtime->atomState.NaNAtom))
75888:             cx->addTypePropertyId(script->getGlobalType(), id, TYPE_DOUBLE);
75888:         if (id == ATOM_TO_JSID(cx->runtime->atomState.InfinityAtom))
75888:             cx->addTypePropertyId(script->getGlobalType(), id, TYPE_DOUBLE);
75888: 
75636:         /* Handle as a property access. */
75708:         PropertyAccess(cx, script, pc, script->getGlobalType(),
75708:                        false, &pushed[0], id);
75718: 
75718:         if (op == JSOP_CALLGLOBAL || op == JSOP_CALLGNAME)
75716:             pushed[1].addType(cx, TYPE_UNKNOWN);
75716: 
75708:         if (CheckNextTest(pc))
75708:             pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75718:       case JSOP_NAME:
75718:       case JSOP_CALLNAME:
75827:         /* The first value pushed by NAME/CALLNAME must always be reported to inference. */
75718:         if (op == JSOP_CALLNAME)
75718:             pushed[1].addType(cx, TYPE_UNKNOWN);
75718:         break;
75718: 
75640:       case JSOP_BINDGNAME:
75640:       case JSOP_BINDNAME:
75615:         break;
75615: 
75718:       case JSOP_SETGNAME: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75708:         PropertyAccess(cx, script, pc, script->getGlobalType(),
75708:                        true, state.popped(0).types, id);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615:       }
75615: 
75718:       case JSOP_SETNAME:
75752:       case JSOP_SETCONST:
75718:         cx->compartment->types.monitorBytecode(cx, script, offset);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75718:         break;
75718: 
75718:       case JSOP_GETXPROP:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75615:         break;
75615: 
75697:       case JSOP_INCGNAME:
75697:       case JSOP_DECGNAME:
75697:       case JSOP_GNAMEINC:
75718:       case JSOP_GNAMEDEC: {
75718:         jsid id = GetAtomId(cx, script, pc, 0);
75718:         PropertyAccess(cx, script, pc, script->getGlobalType(), true, NULL, id);
75718:         PropertyAccess(cx, script, pc, script->getGlobalType(), false, &pushed[0], id);
75718:         break;
75718:       }
75718: 
75615:       case JSOP_INCNAME:
75615:       case JSOP_DECNAME:
75615:       case JSOP_NAMEINC:
75718:       case JSOP_NAMEDEC:
75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
75615:         break;
75615: 
75615:       case JSOP_GETFCSLOT:
75615:       case JSOP_CALLFCSLOT: {
75615:         unsigned index = GET_UINT16(pc);
75718:         TypeSet *types = script->upvarTypes(index);
75718:         types->addSubset(cx, script, &pushed[0]);
75716:         if (op == JSOP_CALLFCSLOT)
75708:             pushed[1].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75718:       case JSOP_GETUPVAR_DBG:
75718:       case JSOP_CALLUPVAR_DBG:
75718:         pushed[0].addType(cx, TYPE_UNKNOWN);
75718:         if (op == JSOP_CALLUPVAR_DBG)
75718:             pushed[1].addType(cx, TYPE_UNDEFINED);
75718:         break;
75718: 
75615:       case JSOP_GETARG:
75615:       case JSOP_SETARG:
75615:       case JSOP_CALLARG: {
75718:         TypeSet *types = script->argTypes(GET_ARGNO(pc));
75718:         types->addSubset(cx, script, &pushed[0]);
75615:         if (op == JSOP_SETARG)
75718:             state.popped(0).types->addSubset(cx, script, types);
75615:         if (op == JSOP_CALLARG)
75708:             pushed[1].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_INCARG:
75615:       case JSOP_DECARG:
75615:       case JSOP_ARGINC:
75615:       case JSOP_ARGDEC: {
75718:         TypeSet *types = script->argTypes(GET_ARGNO(pc));
75718:         types->addArith(cx, script, types);
75718:         types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_ARGSUB:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75615:         break;
75615: 
75615:       case JSOP_GETLOCAL:
75615:       case JSOP_SETLOCAL:
75615:       case JSOP_SETLOCALPOP:
75615:       case JSOP_CALLLOCAL: {
75615:         uint32 local = GET_SLOTNO(pc);
75718:         TypeSet *types = local < script->nfixed ? script->localTypes(local) : NULL;
75708: 
75708:         if (op != JSOP_SETLOCALPOP) {
75708:             if (types)
75718:                 types->addSubset(cx, script, &pushed[0]);
75708:             else
75708:                 pushed[0].addType(cx, TYPE_UNKNOWN);
75615:         }
75615:         if (op == JSOP_CALLLOCAL)
75708:             pushed[1].addType(cx, TYPE_UNDEFINED);
75615: 
75615:         if (op == JSOP_SETLOCAL || op == JSOP_SETLOCALPOP) {
75708:             if (types)
75718:                 state.popped(0).types->addSubset(cx, script, types);
75615:         } else {
75615:             /*
75615:              * Add void type if the variable might be undefined. TODO: monitor for
75708:              * undefined read instead?
75615:              */
75708:             if (state.analysis.localHasUseBeforeDef(local) ||
75708:                 !state.analysis.localDefined(local, pc)) {
75708:                 pushed[0].addType(cx, TYPE_UNDEFINED);
75708:             }
75615:         }
75615: 
75615:         break;
75615:       }
75615: 
75615:       case JSOP_INCLOCAL:
75615:       case JSOP_DECLOCAL:
75615:       case JSOP_LOCALINC:
75615:       case JSOP_LOCALDEC: {
75627:         uint32 local = GET_SLOTNO(pc);
75718:         TypeSet *types = local < script->nfixed ? script->localTypes(local) : NULL;
75708:         if (types) {
75718:             types->addArith(cx, script, types);
75718:             types->addSubset(cx, script, &pushed[0]);
75708:         } else {
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75708:         }
75615:         break;
75615:       }
75615: 
75708:       case JSOP_ARGUMENTS:
75708:       case JSOP_ARGCNT:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75708:         break;
75708: 
75708:       case JSOP_SETPROP:
75708:       case JSOP_SETMETHOD: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75708:         state.popped(1).types->addSetProperty(cx, script, pc, state.popped(0).types, id);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_GETPROP:
75615:       case JSOP_CALLPROP: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75708:         state.popped(0).types->addGetProperty(cx, script, pc, &pushed[0], id);
75615: 
75615:         if (op == JSOP_CALLPROP)
75718:             state.popped(0).types->addFilterPrimitives(cx, script, &pushed[1], true);
75708:         if (CheckNextTest(pc))
75708:             pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_INCPROP:
75615:       case JSOP_DECPROP:
75615:       case JSOP_PROPINC:
75615:       case JSOP_PROPDEC: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75708:         state.popped(0).types->addGetProperty(cx, script, pc, &pushed[0], id);
75708:         state.popped(0).types->addSetProperty(cx, script, pc, NULL, id);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_GETTHISPROP: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75615: 
75615:         /* Need a new type set to model conversion of NULL to the global object. */
75720:         TypeSet *newTypes = TypeSet::make(cx, "thisprop");
75720:         if (!newTypes)
75720:             return false;
75718:         script->thisTypes()->addTransformThis(cx, script, newTypes);
75708:         newTypes->addGetProperty(cx, script, pc, &pushed[0], id);
75708: 
75708:         if (CheckNextTest(pc))
75708:             pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_GETARGPROP: {
75718:         TypeSet *types = script->argTypes(GET_ARGNO(pc));
75708: 
75708:         jsid id = GetAtomId(cx, script, pc, SLOTNO_LEN);
75708:         types->addGetProperty(cx, script, pc, &pushed[0], id);
75708: 
75708:         if (CheckNextTest(pc))
75708:             pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_GETLOCALPROP: {
75708:         uint32 local = GET_SLOTNO(pc);
75718:         TypeSet *types = local < script->nfixed ? script->localTypes(local) : NULL;
75708:         if (types) {
75708:             jsid id = GetAtomId(cx, script, pc, SLOTNO_LEN);
75708:             types->addGetProperty(cx, script, pc, &pushed[0], id);
75708:         } else {
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75699:         }
75699: 
75708:         if (CheckNextTest(pc))
75708:             pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_GETELEM:
75615:       case JSOP_CALLELEM:
75825:         /*
75825:          * We only consider ELEM accesses on integers here. Any element access
75825:          * which is accessing a non-integer property must be monitored.
75825:          */
75825:         state.popped(1).types->addGetProperty(cx, script, pc, &pushed[0], JSID_VOID);
75615: 
75615:         if (op == JSOP_CALLELEM)
75718:             state.popped(1).types->addFilterPrimitives(cx, script, &pushed[1], true);
75708:         if (CheckNextTest(pc))
75708:             pushed[0].addType(cx, TYPE_UNDEFINED);
75615:         break;
75615: 
75615:       case JSOP_SETELEM:
75825:         state.popped(2).types->addSetProperty(cx, script, pc, state.popped(0).types, JSID_VOID);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_INCELEM:
75615:       case JSOP_DECELEM:
75615:       case JSOP_ELEMINC:
75615:       case JSOP_ELEMDEC:
75825:         state.popped(1).types->addGetProperty(cx, script, pc, &pushed[0], JSID_VOID);
75825:         state.popped(1).types->addSetProperty(cx, script, pc, NULL, JSID_VOID);
75615:         break;
75615: 
75615:       case JSOP_LENGTH:
75615:         /* Treat this as an access to the length property. */
75708:         state.popped(0).types->addGetProperty(cx, script, pc, &pushed[0], id_length(cx));
75615:         break;
75615: 
75615:       case JSOP_THIS:
75718:         script->thisTypes()->addTransformThis(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_RETURN:
75615:       case JSOP_SETRVAL:
75718:         if (script->fun)
75718:             state.popped(0).types->addSubset(cx, script, script->returnTypes());
75615:         break;
75615: 
75615:       case JSOP_ADD:
75718:         state.popped(0).types->addArith(cx, script, &pushed[0], state.popped(1).types);
75718:         state.popped(1).types->addArith(cx, script, &pushed[0], state.popped(0).types);
75615:         break;
75615: 
75615:       case JSOP_SUB:
75615:       case JSOP_MUL:
75615:       case JSOP_MOD:
75630:       case JSOP_DIV:
75718:         state.popped(0).types->addArith(cx, script, &pushed[0]);
75718:         state.popped(1).types->addArith(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_NEG:
75615:       case JSOP_POS:
75718:         state.popped(0).types->addArith(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_LAMBDA:
75615:       case JSOP_LAMBDA_FC:
75615:       case JSOP_DEFFUN:
75615:       case JSOP_DEFFUN_FC:
75615:       case JSOP_DEFLOCALFUN:
75615:       case JSOP_DEFLOCALFUN_FC: {
75615:         unsigned off = (op == JSOP_DEFLOCALFUN || op == JSOP_DEFLOCALFUN_FC) ? SLOTNO_LEN : 0;
75640:         JSObject *obj = GetScriptObject(cx, script, pc, off);
75615: 
75615:         TypeSet *res = NULL;
75718:         if (op == JSOP_LAMBDA || op == JSOP_LAMBDA_FC)
75708:             res = &pushed[0];
75718:         else if (op == JSOP_DEFLOCALFUN || op == JSOP_DEFLOCALFUN_FC)
75718:             res = script->localTypes(GET_SLOTNO(pc));
75615: 
75688:         if (res) {
75688:             if (script->compileAndGo)
75816:                 res->addType(cx, (jstype) obj->getType());
75615:             else
75688:                 res->addType(cx, TYPE_UNKNOWN);
75688:         } else {
75708:             cx->compartment->types.monitorBytecode(cx, script, offset);
75688:         }
75615:         break;
75615:       }
75615: 
75718:       case JSOP_DEFVAR:
75718:         break;
75718: 
75615:       case JSOP_CALL:
75615:       case JSOP_EVAL:
75631:       case JSOP_FUNCALL:
75631:       case JSOP_FUNAPPLY:
75615:       case JSOP_NEW: {
75615:         /* Construct the base call information about this site. */
75708:         unsigned argCount = analyze::GetUseCount(script, offset) - 2;
75720:         TypeCallsite *callsite = ArenaNew<TypeCallsite>(cx->compartment->types.pool,
75720:                                                         cx, script, pc, op == JSOP_NEW, argCount);
75720:         if (!callsite || (argCount && !callsite->argumentTypes)) {
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             break;
75720:         }
75708:         callsite->thisTypes = state.popped(argCount).types;
75708:         callsite->returnTypes = &pushed[0];
75708: 
75708:         for (unsigned i = 0; i < argCount; i++)
75708:             callsite->argumentTypes[i] = state.popped(argCount - 1 - i).types;
75708: 
75708:         state.popped(argCount + 1).types->addCall(cx, callsite);
75615:         break;
75615:       }
75615: 
75639:       case JSOP_NEWINIT:
75639:       case JSOP_NEWARRAY:
75688:       case JSOP_NEWOBJECT:
75688:         if (script->compileAndGo) {
75708:             bool isArray = (op == JSOP_NEWARRAY || (op == JSOP_NEWINIT && pc[1] == JSProto_Array));
75708:             initializer = script->getTypeInitObject(cx, pc, isArray);
75720:             if (!initializer)
75720:                 return false;
75708:             pushed[0].addType(cx, (jstype) initializer);
75688:         } else {
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75688:         }
75615:         break;
75615: 
75627:       case JSOP_ENDINIT:
75627:         break;
75627: 
75688:       case JSOP_INITELEM:
75708:         initializer = state.popped(2).initializer;
75762:         JS_ASSERT((initializer != NULL) == script->compileAndGo);
75762:         if (initializer) {
75708:             pushed[0].addType(cx, (jstype) initializer);
75762:             if (!initializer->unknownProperties) {
75759:                 /*
75759:                  * Assume the initialized element is an integer. INITELEM can be used
75759:                  * for doubles which don't map to the JSID_VOID property, which must
75759:                  * be caught with dynamic monitoring.
75759:                  */
75759:                 TypeSet *types = initializer->getProperty(cx, JSID_VOID, true);
75720:                 if (!types)
75720:                     return false;
75760:                 if (state.hasGetSet)
75760:                     types->addType(cx, TYPE_UNKNOWN);
75760:                 else if (state.hasHole)
75720:                     initializer->markNotPacked(cx, false);
75760:                 else
75718:                     state.popped(0).types->addSubset(cx, script, types);
75762:             }
75688:         } else {
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75688:         }
75627:         state.hasGetSet = false;
75639:         state.hasHole = false;
75615:         break;
75615: 
75627:       case JSOP_GETTER:
75627:       case JSOP_SETTER:
75627:         state.hasGetSet = true;
75627:         break;
75627: 
75639:       case JSOP_HOLE:
75639:         state.hasHole = true;
75639:         break;
75639: 
75615:       case JSOP_INITPROP:
75688:       case JSOP_INITMETHOD:
75708:         initializer = state.popped(1).initializer;
75762:         JS_ASSERT((initializer != NULL) == script->compileAndGo);
75762:         if (initializer) {
75708:             pushed[0].addType(cx, (jstype) initializer);
75762:             if (!initializer->unknownProperties) {
75708:                 jsid id = GetAtomId(cx, script, pc, 0);
75708:                 TypeSet *types = initializer->getProperty(cx, id, true);
75720:                 if (!types)
75720:                     return false;
75760:                 if (id == id___proto__(cx) || id == id_prototype(cx))
75708:                     cx->compartment->types.monitorBytecode(cx, script, offset);
75760:                 else if (state.hasGetSet)
75760:                     types->addType(cx, TYPE_UNKNOWN);
75760:                 else
75718:                     state.popped(0).types->addSubset(cx, script, types);
75762:             }
75688:         } else {
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75688:         }
75627:         state.hasGetSet = false;
75639:         JS_ASSERT(!state.hasHole);
75615:         break;
75615: 
75615:       case JSOP_ENTERWITH:
75708:       case JSOP_ENTERBLOCK:
75615:         /*
75708:          * Scope lookups can occur on the values being pushed here. We don't track
75708:          * the value or its properties, and just monitor all name opcodes in the
75718:          * script.
75615:          */
75615:         break;
75615: 
75640:       case JSOP_ITER:
75627:         /*
75627:          * The actual pushed value is an iterator object, which we don't care about.
75627:          * Propagate the target of the iteration itself so that we'll be able to detect
75627:          * when an object of Iterator class flows to the JSOP_FOR* opcode, which could
75636:          * be a generator that produces arbitrary values with 'for in' syntax.
75627:          */
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_MOREITER:
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75708:         pushed[1].addType(cx, TYPE_BOOLEAN);
75615:         break;
75615: 
75716:       case JSOP_FORGNAME: {
75708:         jsid id = GetAtomId(cx, script, pc, 0);
75760:         TypeObject *global = script->getGlobalType();
75760:         if (!global->unknownProperties) {
75760:             TypeSet *types = global->getProperty(cx, id, true);
75720:             if (!types)
75720:                 return false;
75720:             SetForTypes(cx, script, state, types);
75760:         }
75718:         break;
75718:       }
75718: 
75718:       case JSOP_FORNAME:
75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
75615:         break;
75615: 
75615:       case JSOP_FORLOCAL: {
75708:         uint32 local = GET_SLOTNO(pc);
75718:         TypeSet *types = local < script->nfixed ? script->localTypes(local) : NULL;
75708:         if (types)
75708:             SetForTypes(cx, script, state, types);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_FORARG: {
75718:         TypeSet *types = script->argTypes(GET_ARGNO(pc));
75708:         SetForTypes(cx, script, state, types);
75615:         break;
75615:       }
75615: 
75699:       case JSOP_FORELEM:
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75708:         pushed[1].addType(cx, TYPE_UNKNOWN);
75699:         break;
75699: 
75615:       case JSOP_FORPROP:
75615:       case JSOP_ENUMELEM:
75753:       case JSOP_ENUMCONSTELEM:
75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
75615:         break;
75615: 
75615:       case JSOP_ARRAYPUSH: {
75708:         TypeSet *types = state.stack[GET_SLOTNO(pc) - script->nfixed].types;
75708:         types->addSetProperty(cx, script, pc, state.popped(0).types, JSID_VOID);
75615:         break;
75615:       }
75615: 
75615:       case JSOP_THROW:
75615:         /* There will be a monitor on the bytecode catching the exception. */
75615:         break;
75615: 
75615:       case JSOP_FINALLY:
75615:         /* Pushes information about whether an exception was thrown. */
75615:         break;
75615: 
75615:       case JSOP_EXCEPTION:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75615:         break;
75615: 
75615:       case JSOP_DELPROP:
75615:       case JSOP_DELELEM:
75615:       case JSOP_DELNAME:
75615:         /* TODO: watch for deletes on the global object. */
75708:         pushed[0].addType(cx, TYPE_BOOLEAN);
75615:         break;
75615: 
75615:       case JSOP_LEAVEBLOCKEXPR:
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_CASE:
75784:       case JSOP_CASEX:
75718:         state.popped(1).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_UNBRAND:
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_GENERATOR:
75708:         if (script->fun) {
75688:             if (script->compileAndGo) {
75708:                 TypeObject *object = script->getTypeNewObject(cx, JSProto_Generator);
75720:                 if (!object)
75720:                     return false;
75718:                 script->returnTypes()->addType(cx, (jstype) object);
75688:             } else {
75718:                 script->returnTypes()->addType(cx, TYPE_UNKNOWN);
75688:             }
75615:         }
75615:         break;
75615: 
75615:       case JSOP_YIELD:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75615:         break;
75615: 
75641:       case JSOP_CALLXMLNAME:
75708:         pushed[1].addType(cx, TYPE_UNKNOWN);
75633:         /* FALLTHROUGH */
75641:       case JSOP_XMLNAME:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75633:         break;
75633: 
75615:       case JSOP_SETXMLNAME:
75708:         cx->compartment->types.monitorBytecode(cx, script, offset);
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_BINDXMLNAME:
75615:         break;
75615: 
75615:       case JSOP_TOXML:
75615:       case JSOP_TOXMLLIST:
75615:       case JSOP_XMLPI:
75615:       case JSOP_XMLCDATA:
75615:       case JSOP_XMLCOMMENT:
75615:       case JSOP_DESCENDANTS:
75615:       case JSOP_TOATTRNAME:
75615:       case JSOP_QNAMECONST:
75615:       case JSOP_QNAME:
75615:       case JSOP_ANYNAME:
75615:       case JSOP_GETFUNNS:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75615:         break;
75615: 
75615:       case JSOP_FILTER:
75615:         /* Note: the second value pushed by filter is a hole, and not modelled. */
75718:         state.popped(0).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75615:       case JSOP_ENDFILTER:
75718:         state.popped(1).types->addSubset(cx, script, &pushed[0]);
75615:         break;
75615: 
75708:       case JSOP_DEFSHARP:
75708:         break;
75708: 
75708:       case JSOP_USESHARP:
75708:         pushed[0].addType(cx, TYPE_UNKNOWN);
75708:         break;
75708: 
75708:       case JSOP_CALLEE:
75708:         if (script->compileAndGo)
75708:             pushed[0].addType(cx, (jstype) script->fun->getType());
75708:         else
75708:             pushed[0].addType(cx, TYPE_UNKNOWN);
75708:         break;
75708: 
75708:       case JSOP_TABLESWITCH:
75708:       case JSOP_TABLESWITCHX: {
75708:         jsbytecode *pc2 = pc;
75708:         unsigned jmplen = (op == JSOP_TABLESWITCH) ? JUMP_OFFSET_LEN : JUMPX_OFFSET_LEN;
75708:         unsigned defaultOffset = offset + GetJumpOffset(pc, pc2);
75708:         pc2 += jmplen;
75708:         jsint low = GET_JUMP_OFFSET(pc2);
75708:         pc2 += JUMP_OFFSET_LEN;
75708:         jsint high = GET_JUMP_OFFSET(pc2);
75708:         pc2 += JUMP_OFFSET_LEN;
75708: 
75708:         MergeTypes(cx, state, script, defaultOffset);
75708: 
75708:         for (jsint i = low; i <= high; i++) {
75708:             unsigned targetOffset = offset + GetJumpOffset(pc, pc2);
75708:             if (targetOffset != offset)
75708:                 MergeTypes(cx, state, script, targetOffset);
75708:             pc2 += jmplen;
75708:         }
75615:         break;
75615:       }
75615: 
75708:       case JSOP_LOOKUPSWITCH:
75708:       case JSOP_LOOKUPSWITCHX: {
75708:         jsbytecode *pc2 = pc;
75708:         unsigned jmplen = (op == JSOP_LOOKUPSWITCH) ? JUMP_OFFSET_LEN : JUMPX_OFFSET_LEN;
75708:         unsigned defaultOffset = offset + GetJumpOffset(pc, pc2);
75708:         pc2 += jmplen;
75708:         unsigned npairs = GET_UINT16(pc2);
75708:         pc2 += UINT16_LEN;
75708: 
75708:         MergeTypes(cx, state, script, defaultOffset);
75708: 
75708:         while (npairs) {
75708:             pc2 += INDEX_LEN;
75708:             unsigned targetOffset = offset + GetJumpOffset(pc, pc2);
75708:             MergeTypes(cx, state, script, targetOffset);
75708:             pc2 += jmplen;
75708:             npairs--;
75708:         }
75615:         break;
75615:       }
75615: 
75708:       case JSOP_TRY: {
75708:         JSTryNote *tn = script->trynotes()->vector;
75708:         JSTryNote *tnlimit = tn + script->trynotes()->length;
75708:         for (; tn < tnlimit; tn++) {
75708:             unsigned startOffset = script->main - script->code + tn->start;
75708:             if (startOffset == offset + 1) {
75708:                 unsigned catchOffset = startOffset + tn->length;
75708:                 if (tn->kind != JSTRY_ITER)
75708:                     MergeTypes(cx, state, script, catchOffset);
75708:             }
75708:         }
75615:         break;
75708:       }
75615: 
75615:       default:
75640:         TypeFailure(cx, "Unknown bytecode: %s", js_CodeNameTwo[op]);
75640:     }
75640: 
75640:     /* Compute temporary analysis state after the bytecode. */
75640: 
75640:     if (op == JSOP_DUP) {
75708:         state.stack[stackDepth] = state.stack[stackDepth - 1];
75708:         state.stackDepth = stackDepth + 1;
75640:     } else if (op == JSOP_DUP2) {
75708:         state.stack[stackDepth]     = state.stack[stackDepth - 2];
75708:         state.stack[stackDepth + 1] = state.stack[stackDepth - 1];
75708:         state.stackDepth = stackDepth + 2;
75640:     } else {
75708:         unsigned nuses = analyze::GetUseCount(script, offset);
75708:         unsigned ndefs = analyze::GetDefCount(script, offset);
75708:         memset(&state.stack[stackDepth - nuses], 0, ndefs * sizeof(AnalyzeStateStack));
75708:         state.stackDepth = stackDepth - nuses + ndefs;
75640:     }
75640: 
75708:     for (unsigned i = 0; i < defCount; i++)
75708:         state.popped(defCount -1 - i).types = &pushed[i];
75708: 
75640:     switch (op) {
75640:       case JSOP_ITER: {
75640:         uintN flags = pc[1];
75640:         if (flags & JSITER_FOREACH)
75640:             state.popped(0).isForEach = true;
75640:         break;
75640:       }
75640: 
75708:       case JSOP_NEWINIT:
75708:       case JSOP_NEWARRAY:
75708:       case JSOP_NEWOBJECT:
75708:       case JSOP_INITELEM:
75708:       case JSOP_INITPROP:
75708:       case JSOP_INITMETHOD:
75708:         state.popped(0).initializer = initializer;
75708:         break;
75708: 
75640:       default:;
75615:     }
75708: 
75708:     /* Merge types with other jump targets of this opcode. */
75708:     uint32 type = JOF_TYPE(js_CodeSpec[op].format);
75708:     if (type == JOF_JUMP || type == JOF_JUMPX) {
75708:         unsigned targetOffset = offset + GetJumpOffset(pc, pc);
75708:         MergeTypes(cx, state, script, targetOffset);
75615:     }
75720: 
75720:     return true;
75708: }
75615: 
75701: void
75718: AnalyzeScriptTypes(JSContext *cx, JSScript *script)
75701: {
75718:     JS_ASSERT(!script->types && !script->isUncachedEval);
75720: 
75720:     analyze::Script analysis;
75720:     analysis.analyze(cx, script);
75720: 
75720:     AnalyzeState state(cx, analysis);
75720: 
75720:     unsigned length = sizeof(TypeScript)
75720:         + (script->length * sizeof(TypeScript*));
75720:     unsigned char *cursor = (unsigned char *) cx->calloc(length);
75720: 
75720:     if (analysis.failed() || !script->ensureVarTypes(cx) || !state.init(script) || !cursor) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return;
75720:     }
75718: 
75718:     if (script->analyzed) {
75718:         /*
75718:          * Reanalyzing this script after discarding from GC.
75718:          * Discard/recompile any JIT code for this script,
75718:          * to preserve invariant in TypeConstraintCondensed.
75718:          */
75718:         cx->compartment->types.addPendingRecompile(cx, script);
75718:     }
75718: 
75708:     TypeScript *types = (TypeScript *) cursor;
75708:     script->types = types;
75718:     script->analyzed = true;
75708: #ifdef DEBUG
75708:     types->script = script;
75708: #endif
75708: 
75708:     cursor += sizeof(TypeScript);
75708:     types->pushedArray = (TypeSet **) cursor;
75708: 
75768:     if (script->calledWithNew)
75768:         AnalyzeScriptNew(cx, script);
75768: 
75701:     unsigned offset = 0;
75701:     while (offset < script->length) {
75708:         analyze::Bytecode *code = analysis.maybeCode(offset);
75701: 
75701:         jsbytecode *pc = script->code + offset;
75701:         analyze::UntrapOpcode untrap(cx, script, pc);
75701: 
75720:         if (code && !AnalyzeBytecode(cx, state, script, offset)) {
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             return;
75720:         }
75708: 
75708:         offset += analyze::GetBytecodeLength(pc);
75708:     }
75708: 
75718:     /*
75718:      * Sync with any dynamic types previously generated either because
75718:      * we ran the interpreter some before analyzing or because we
75718:      * are reanalyzing after a GC.
75718:      */
75718:     TypeResult *result = script->typeResults;
75718:     while (result) {
75718:         TypeSet *pushed = script->types->pushed(result->offset);
75718:         pushed->addType(cx, result->type);
75718:         result = result->next;
75718:     }
75708: }
75708: 
75708: void
75768: AnalyzeScriptNew(JSContext *cx, JSScript *script)
75708: {
75768:     JS_ASSERT(script->calledWithNew && script->fun);
75768: 
75768:     /*
75768:      * Compute the 'this' type when called with 'new'. We do not distinguish regular
75768:      * from 'new' calls to the function.
75768:      */
75781: 
75785:     if (script->fun->getType()->unknownProperties ||
75785:         script->fun->isFunctionPrototype() ||
75785:         !script->compileAndGo) {
75781:         script->thisTypes()->addType(cx, TYPE_UNKNOWN);
75781:         return;
75781:     }
75781: 
75768:     TypeFunction *funType = script->fun->getType()->asFunction();
75768:     TypeSet *prototypeTypes = funType->getProperty(cx, id_prototype(cx), false);
75768:     if (!prototypeTypes)
75768:         return;
75768:     prototypeTypes->addNewObject(cx, script, funType, script->thisTypes());
75768: }
75701: 
75615: /////////////////////////////////////////////////////////////////////
75615: // Printing
75615: /////////////////////////////////////////////////////////////////////
75615: 
75640: #ifdef DEBUG
75640: 
75615: void
75708: PrintBytecode(JSContext *cx, JSScript *script, jsbytecode *pc)
75615: {
75708:     unsigned offset = pc - script->code;
75615: 
75615:     JSOp op = (JSOp)*pc;
75615:     JS_ASSERT(op < JSOP_LIMIT);
75615: 
75615:     const JSCodeSpec *cs = &js_CodeSpec[op];
75615:     const char *name = js_CodeNameTwo[op];
75615: 
75615:     uint32 type = JOF_TYPE(cs->format);
75615:     switch (type) {
75615:       case JOF_BYTE:
75615:       case JOF_TABLESWITCH:
75615:       case JOF_TABLESWITCHX:
75615:       case JOF_LOOKUPSWITCH:
75615:       case JOF_LOOKUPSWITCHX:
75638:         printf("%s", name);
75615:         break;
75615: 
75615:       case JOF_JUMP:
75615:       case JOF_JUMPX: {
75615:         ptrdiff_t off = GetJumpOffset(pc, pc);
75638:         printf("%s %u", name, unsigned(offset + off));
75615:         break;
75615:       }
75615: 
75615:       case JOF_ATOM: {
75615:         if (op == JSOP_DOUBLE) {
75638:             printf("%s", name);
75615:         } else {
75615:             jsid id = GetAtomId(cx, script, pc, 0);
75615:             if (JSID_IS_STRING(id))
75640:                 printf("%s %s", name, TypeIdString(id));
75615:             else
75638:                 printf("%s (index)", name);
75615:         }
75615:         break;
75615:       }
75615: 
75615:       case JOF_OBJECT:
75638:         printf("%s (object)", name);
75615:         break;
75615: 
75615:       case JOF_REGEXP:
75638:         printf("%s (regexp)", name);
75615:         break;
75615: 
75615:       case JOF_UINT16PAIR:
75638:         printf("%s %d %d", name, GET_UINT16(pc), GET_UINT16(pc + UINT16_LEN));
75615:         break;
75615: 
75615:       case JOF_UINT16:
75638:         printf("%s %d", name, GET_UINT16(pc));
75615:         break;
75615: 
75708:       case JOF_QARG:
75708:         printf("%s %d", name, GET_ARGNO(pc));
75615:         break;
75615: 
75615:       case JOF_GLOBAL:
75640:         printf("%s %s", name, TypeIdString(GetGlobalId(cx, script, pc)));
75615:         break;
75615: 
75615:       case JOF_LOCAL:
75638:         printf("%s %d", name, GET_SLOTNO(pc));
75615:         break;
75615: 
75615:       case JOF_SLOTATOM: {
75615:         jsid id = GetAtomId(cx, script, pc, SLOTNO_LEN);
75615: 
75708:         printf("%s %d %s", name, GET_SLOTNO(pc), TypeIdString(id));
75615:         break;
75615:       }
75615: 
75615:       case JOF_SLOTOBJECT:
75638:         printf("%s %u (object)", name, GET_SLOTNO(pc));
75615:         break;
75615: 
75615:       case JOF_UINT24:
75615:         JS_ASSERT(op == JSOP_UINT24 || op == JSOP_NEWARRAY);
75638:         printf("%s %d", name, (jsint)GET_UINT24(pc));
75615:         break;
75615: 
75615:       case JOF_UINT8:
75638:         printf("%s %d", name, (jsint)pc[1]);
75615:         break;
75615: 
75615:       case JOF_INT8:
75638:         printf("%s %d", name, (jsint)GET_INT8(pc));
75615:         break;
75615: 
75615:       case JOF_INT32:
75638:         printf("%s %d", name, (jsint)GET_INT32(pc));
75615:         break;
75615: 
75615:       default:
75615:         JS_NOT_REACHED("Unknown opcode type");
75615:     }
75615: }
75615: 
75640: #endif
75640: 
75615: void
75770: TypeScript::print(JSContext *cx, JSScript *script)
75615: {
75615:     TypeCompartment *compartment = &script->compartment->types;
75615: 
75615:     /*
75615:      * Check if there are warnings for used values with unknown types, and build
75615:      * statistics about the size of type sets found for stack values.
75615:      */
75615:     for (unsigned offset = 0; offset < script->length; offset++) {
75708:         TypeSet *array = pushed(offset);
75708:         if (!array)
75615:             continue;
75615: 
75708:         unsigned defCount = analyze::GetDefCount(script, offset);
75708:         if (!defCount)
75615:             continue;
75615: 
75708:         for (unsigned i = 0; i < defCount; i++) {
75708:             TypeSet *types = &array[i];
75615: 
75615:             /* TODO: distinguish direct and indirect call sites. */
75615:             unsigned typeCount = types->objectCount ? 1 : 0;
75615:             for (jstype type = TYPE_UNDEFINED; type <= TYPE_STRING; type++) {
75615:                 if (types->typeFlags & (1 << type))
75615:                     typeCount++;
75615:             }
75615: 
75615:             /*
75615:              * Adjust the type counts for floats: values marked as floats
75615:              * are also marked as ints by the inference, but for counting
75615:              * we don't consider these to be separate types.
75615:              */
75615:             if (types->typeFlags & TYPE_FLAG_DOUBLE) {
75615:                 JS_ASSERT(types->typeFlags & TYPE_FLAG_INT32);
75615:                 typeCount--;
75615:             }
75615: 
75615:             if ((types->typeFlags & TYPE_FLAG_UNKNOWN) ||
75615:                 typeCount > TypeCompartment::TYPE_COUNT_LIMIT) {
75615:                 compartment->typeCountOver++;
75615:             } else if (typeCount == 0) {
75615:                 /* Ignore values without types, this may be unreached code. */
75615:             } else {
75615:                 compartment->typeCounts[typeCount-1]++;
75615:             }
75615:         }
75615:     }
75615: 
75640: #ifdef DEBUG
75640: 
75708:     if (script->fun)
75638:         printf("Function");
75718:     else if (script->isCachedEval || script->isUncachedEval)
75718:         printf("Eval");
75615:     else
75718:         printf("Main");
75789:     printf(" #%u %s (line %d):\n", script->id(), script->filename, script->lineno);
75718: 
75718:     printf("locals:");
75718:     printf("\n    return:");
75718:     script->returnTypes()->print(cx);
75718:     printf("\n    this:");
75718:     script->thisTypes()->print(cx);
75641: 
75708:     for (unsigned i = 0; script->fun && i < script->fun->nargs; i++) {
75708:         printf("\n    arg%u:", i);
75718:         script->argTypes(i)->print(cx);
75641:     }
75708:     for (unsigned i = 0; i < script->nfixed; i++) {
75708:         printf("\n    local%u:", i);
75718:         script->localTypes(i)->print(cx);
75718:     }
75718:     for (unsigned i = 0; i < script->bindings.countUpvars(); i++) {
75718:         printf("\n    upvar%u:", i);
75718:         script->upvarTypes(i)->print(cx);
75641:     }
75641:     printf("\n");
75615: 
75615:     for (unsigned offset = 0; offset < script->length; offset++) {
75708:         TypeSet *array = pushed(offset);
75708:         if (!array)
75615:             continue;
75615: 
75708:         printf("#%u:%05u:  ", script->id(), offset);
75708:         PrintBytecode(cx, script, script->code + offset);
75638:         printf("\n");
75615: 
75708:         unsigned defCount = analyze::GetDefCount(script, offset);
75708:         for (unsigned i = 0; i < defCount; i++) {
75708:             printf("  type %d:", i);
75708:             array[i].print(cx);
75638:             printf("\n");
75615:         }
75615: 
75708:         if (monitored(offset))
75638:             printf("  monitored\n");
75615:     }
75615: 
75638:     printf("\n");
75615: 
75640: #endif /* DEBUG */
75640: 
75615: }
75615: 
75708: } } /* namespace js::types */
75708: 
75720: /////////////////////////////////////////////////////////////////////
75720: // JSContext
75720: /////////////////////////////////////////////////////////////////////
75720: 
75720: js::types::TypeFunction *
75720: JSContext::newTypeFunction(const char *name, JSObject *proto)
75720: {
75720:     return (js::types::TypeFunction *) compartment->types.newTypeObject(this, NULL, name, true, proto);
75720: }
75720: 
75720: js::types::TypeObject *
75720: JSContext::newTypeObject(const char *name, JSObject *proto)
75720: {
75720:     return compartment->types.newTypeObject(this, NULL, name, false, proto);
75720: }
75720: 
75720: js::types::TypeObject *
75768: JSContext::newTypeObject(const char *base, const char *postfix, JSObject *proto, bool isFunction)
75720: {
75720:     char *name = NULL;
75720: #ifdef DEBUG
75720:     unsigned len = strlen(base) + strlen(postfix) + 5;
75720:     name = (char *)alloca(len);
75720:     JS_snprintf(name, len, "%s:%s", base, postfix);
75720: #endif
75768:     return compartment->types.newTypeObject(this, NULL, name, isFunction, proto);
75720: }
75720: 
75720: /////////////////////////////////////////////////////////////////////
75720: // JSScript
75720: /////////////////////////////////////////////////////////////////////
75720: 
75708: /*
75708:  * Returns true if we don't expect to compute the correct types for some value
75708:  * pushed by the specified bytecode.
75708:  */
75708: static inline bool
75708: IgnorePushed(JSOp op, unsigned index)
75708: {
75708:     switch (op) {
75708:       /* We keep track of the scopes pushed by BINDNAME separately. */
75708:       case JSOP_BINDNAME:
75708:       case JSOP_BINDGNAME:
75708:       case JSOP_BINDXMLNAME:
75708:         return true;
75708: 
75708:       /* Stack not consistent in TRY_BRANCH_AFTER_COND. */
75708:       case JSOP_IN:
75708:       case JSOP_EQ:
75708:       case JSOP_NE:
75708:       case JSOP_LT:
75708:       case JSOP_LE:
75708:       case JSOP_GT:
75708:       case JSOP_GE:
75708:         return (index == 0);
75708: 
75708:       /* Value not determining result is not pushed by OR/AND. */
75708:       case JSOP_OR:
75708:       case JSOP_ORX:
75708:       case JSOP_AND:
75708:       case JSOP_ANDX:
75708:         return (index == 0);
75708: 
75708:       /* Holes tracked separately. */
75708:       case JSOP_HOLE:
75708:         return (index == 0);
75708:       case JSOP_FILTER:
75708:         return (index == 1);
75708: 
75708:       /* Storage for 'with' and 'let' blocks not monitored. */
75708:       case JSOP_ENTERWITH:
75708:       case JSOP_ENTERBLOCK:
75708:         return true;
75708: 
75708:       /* We don't keep track of the iteration state for 'for in' or 'for each in' loops. */
75708:       case JSOP_FORNAME:
75716:       case JSOP_FORGNAME:
75708:       case JSOP_FORLOCAL:
75708:       case JSOP_FORARG:
75708:       case JSOP_FORPROP:
75708:       case JSOP_FORELEM:
75708:       case JSOP_ITER:
75708:       case JSOP_MOREITER:
75708:       case JSOP_ENDITER:
75708:         return true;
75708: 
75708:       /* DUP can be applied to values pushed by other opcodes we don't model. */
75708:       case JSOP_DUP:
75708:       case JSOP_DUP2:
75708:         return true;
75708: 
75708:       /* We don't keep track of state indicating whether there is a pending exception. */
75708:       case JSOP_FINALLY:
75708:         return true;
75708: 
75708:       default:
75708:         return false;
75708:     }
75708: }
75708: 
75718: bool
75718: JSScript::makeVarTypes(JSContext *cx)
75718: {
75718:     JS_ASSERT(!varTypes);
75718: 
75718:     unsigned nargs = fun ? fun->nargs : 0;
75718:     unsigned count = 2 + nargs + nfixed + bindings.countUpvars();
75718:     varTypes = (js::types::TypeSet *) cx->calloc(sizeof(js::types::TypeSet) * count);
75718:     if (!varTypes)
75718:         return false;
75718: 
75718: #ifdef DEBUG
75789:     InferSpew(js::types::ISpewOps, "typeSet: T%p return #%u", returnTypes(), id());
75789:     InferSpew(js::types::ISpewOps, "typeSet: T%p this #%u", thisTypes(), id());
75718:     for (unsigned i = 0; i < nargs; i++)
75789:         InferSpew(js::types::ISpewOps, "typeSet: T%p arg%u #%u", argTypes(i), i, id());
75718:     for (unsigned i = 0; i < nfixed; i++)
75789:         InferSpew(js::types::ISpewOps, "typeSet: T%p local%u #%u", localTypes(i), i, id());
75718:     for (unsigned i = 0; i < bindings.countUpvars(); i++)
75789:         InferSpew(js::types::ISpewOps, "typeSet: T%p upvar%u #%u", upvarTypes(i), i, id());
75718: #endif
75718: 
75718:     return true;
75718: }
75718: 
75742: bool
75742: JSScript::typeSetFunction(JSContext *cx, JSFunction *fun)
75742: {
75843:     this->fun = fun;
75843: 
75843:     if (!cx->typeInferenceEnabled())
75843:         return true;
75742: 
75742:     char *name = NULL;
75742: #ifdef DEBUG
75742:     name = (char *) alloca(10);
75742:     JS_snprintf(name, 10, "#%u", id());
75742: #endif
75742:     js::types::TypeFunction *type = cx->newTypeFunction(name, fun->getProto())->asFunction();
75742:     if (!type)
75742:         return false;
75742: 
75812:     if (!fun->setTypeAndUniqueShape(cx, type))
75812:         return false;
75742:     type->script = this;
75742:     this->fun = fun;
75742: 
75742:     return true;
75742: }
75742: 
75739: #ifdef DEBUG
75739: 
75708: void
75708: JSScript::typeCheckBytecode(JSContext *cx, const jsbytecode *pc, const js::Value *sp)
75708: {
75708:     if (!types)
75708:         return;
75708: 
75708:     int defCount = js::analyze::GetDefCount(this, pc - code);
75708:     js::types::TypeSet *array = types->pushed(pc - code);
75708: 
75708:     for (int i = 0; i < defCount; i++) {
75708:         const js::Value &val = sp[-defCount + i];
75708:         js::types::TypeSet *types = &array[i];
75708:         if (IgnorePushed(JSOp(*pc), i))
75708:             continue;
75708: 
75708:         js::types::jstype type = js::types::GetValueType(cx, val);
75708: 
75737:         if (!js::types::TypeSetMatches(cx, types, type)) {
75708:             js::types::TypeFailure(cx, "Missing type at #%u:%05u pushed %u: %s",
75708:                                    id(), pc - code, i, js::types::TypeString(type));
75708:         }
75708: 
75708:         if (js::types::TypeIsObject(type)) {
75708:             JS_ASSERT(val.isObject());
75708:             JSObject *obj = &val.toObject();
75708:             js::types::TypeObject *object = (js::types::TypeObject *) type;
75708: 
75708:             if (object->unknownProperties) {
75708:                 JS_ASSERT(!object->isDenseArray);
75708:                 continue;
75708:             }
75708: 
75708:             /* Make sure information about the array status of this object is right. */
75708:             JS_ASSERT_IF(object->isPackedArray, object->isDenseArray);
75708:             if (object->isDenseArray) {
75708:                 if (!obj->isDenseArray() ||
75708:                     (object->isPackedArray && !obj->isPackedDenseArray())) {
75708:                     js::types::TypeFailure(cx, "Object not %s array at #%u:%05u popped %u: %s",
75708:                         object->isPackedArray ? "packed" : "dense",
75708:                         id(), pc - code, i, object->name());
75708:                 }
75708:             }
75708:         }
75708:     }
75708: }
75720: 
75739: #endif
75739: 
75720: /////////////////////////////////////////////////////////////////////
75720: // JSObject
75720: /////////////////////////////////////////////////////////////////////
75720: 
75720: void
75720: JSObject::makeNewType(JSContext *cx)
75720: {
75720:     JS_ASSERT(!newType);
75720: 
75720:     js::types::TypeObject *type = cx->newTypeObject(getType()->name(), "new", this);
75720:     if (!type)
75720:         return;
75720: 
75720:     if (cx->typeInferenceEnabled() && !getType()->unknownProperties) {
75720:         js::types::AutoEnterTypeInference enter(cx);
75720: 
75720:         /* Update the possible 'new' types for all prototype objects sharing the same type object. */
75720:         js::types::TypeSet *types = getType()->getProperty(cx, JSID_EMPTY, true);
75720:         if (types)
75720:             types->addType(cx, (js::types::jstype) type);
75720: 
75720:         if (!cx->compartment->types.checkPendingRecompiles(cx))
75720:             return;
75720:     }
75720: 
75720:     newType = type;
75720:     setDelegate();
75720: }
75720: 
75720: /////////////////////////////////////////////////////////////////////
75720: // Tracing
75720: /////////////////////////////////////////////////////////////////////
75720: 
75720: namespace js {
75720: namespace types {
75720: 
75720: void
75720: types::TypeObject::trace(JSTracer *trc)
75720: {
75720:     JS_ASSERT(!marked);
75720: 
75720:     /*
75720:      * Only mark types if the Mark/Sweep GC is running; the bit won't be cleared
75720:      * by the cycle collector.
75720:      */
75720:     if (trc->context->runtime->gcMarkAndSweep)
75720:         marked = true;
75720: 
75720: #ifdef DEBUG
75720:     gc::MarkId(trc, name_, "type_name");
75720: #endif
75720: 
75720:     if (propertyCount >= 2) {
75720:         unsigned capacity = HashSetCapacity(propertyCount);
75720:         for (unsigned i = 0; i < capacity; i++) {
75720:             Property *prop = propertySet[i];
75720:             if (prop)
75720:                 gc::MarkId(trc, prop->id, "type_prop");
75720:         }
75720:     } else if (propertyCount == 1) {
75720:         Property *prop = (Property *) propertySet;
75720:         gc::MarkId(trc, prop->id, "type_prop");
75720:     }
75720: 
75720:     if (emptyShapes) {
75720:         int count = gc::FINALIZE_OBJECT_LAST - gc::FINALIZE_OBJECT0 + 1;
75720:         for (int i = 0; i < count; i++) {
75720:             if (emptyShapes[i])
75806:                 Shape::trace(trc, emptyShapes[i]);
75720:         }
75720:     }
75720: 
75720:     if (proto)
75720:         gc::MarkObject(trc, *proto, "type_proto");
75845: 
75845:     if (singleton)
75845:         gc::MarkObject(trc, *singleton, "type_singleton");
75720: }
75720: 
75720: /*
75720:  * Condense any constraints on a type set which were generated during analysis
75720:  * of a script, and sweep all type objects and references to type objects
75720:  * which no longer exist.
75720:  */
75720: void
75720: CondenseSweepTypeSet(JSContext *cx, TypeCompartment *compartment,
75720:                      HashSet<JSScript*> *pcondensed, TypeSet *types)
75720: {
75750:     /*
75750:      * This function is called from GC, and cannot malloc any data that could
75750:      * trigger a reentrant GC. The only allocation that can happen here is
75750:      * the construction of condensed constraints and tables for hash sets.
75750:      * Both of these use js_malloc rather than cx->malloc, and thus do not
75750:      * contribute towards the runtime's overall malloc bytes.
75750:      */
75720:     JS_ASSERT(!(types->typeFlags & TYPE_FLAG_INTERMEDIATE_SET));
75720: 
75720:     if (types->objectCount >= 2) {
75720:         bool removed = false;
75720:         unsigned objectCapacity = HashSetCapacity(types->objectCount);
75720:         for (unsigned i = 0; i < objectCapacity; i++) {
75720:             TypeObject *object = types->objectSet[i];
75720:             if (object && !object->marked) {
75734:                 /*
75734:                  * If the object has unknown properties, instead of removing it
75734:                  * replace it with the compartment's empty type object. This is
75734:                  * needed to handle mutable __proto__ --- the type object in
75734:                  * the set may no longer be used but there could be a JSObject
75734:                  * which originally had the type and was changed to a different
75734:                  * type object with unknown properties.
75734:                  */
75836:                 if (object->unknownProperties)
75760:                     types->objectSet[i] = &compartment->typeEmpty;
75836:                 else
75734:                     types->objectSet[i] = NULL;
75720:                 removed = true;
75720:             }
75720:         }
75720:         if (removed) {
75720:             /* Reconstruct the type set to re-resolve hash collisions. */
75720:             TypeObject **oldArray = types->objectSet;
75720:             types->objectSet = NULL;
75720:             types->objectCount = 0;
75720:             for (unsigned i = 0; i < objectCapacity; i++) {
75720:                 TypeObject *object = oldArray[i];
75720:                 if (object) {
75720:                     TypeObject **pentry = HashSetInsert<TypeObject *,TypeObject,TypeObjectKey>
75720:                         (cx, types->objectSet, types->objectCount, object, false);
75720:                     if (pentry)
75720:                         *pentry = object;
75720:                 }
75720:             }
75750:             ::js_free(oldArray);
75720:         }
75720:     } else if (types->objectCount == 1) {
75720:         TypeObject *object = (TypeObject*) types->objectSet;
75720:         if (!object->marked) {
75734:             if (object->unknownProperties) {
75760:                 types->objectSet = (TypeObject**) &compartment->typeEmpty;
75734:             } else {
75720:                 types->objectSet = NULL;
75720:                 types->objectCount = 0;
75720:             }
75720:         }
75734:     }
75720: 
75720:     TypeConstraint *constraint = types->constraintList;
75720:     types->constraintList = NULL;
75720: 
75720:     /*
75720:      * Keep track of all the scripts we have found or generated
75720:      * condensed constraints for, in the condensed table. We reuse the
75720:      * same table for each type set to avoid extra initialization cost,
75720:      * but the table is emptied after each set is processed.
75720:      */
75720: 
75720:     while (constraint) {
75720:         TypeConstraint *next = constraint->next;
75720: 
75720:         TypeObject *object = constraint->baseSubset();
75720:         if (object) {
75720:             /*
75720:              * Constraint propagating data between objects. If the target
75720:              * is not being collected (these are weak references) then
75720:              * keep the constraint.
75720:              */
75720:             if (object->marked) {
75720:                 constraint->next = types->constraintList;
75720:                 types->constraintList = constraint;
75720:             } else {
75750:                 ::js_free(constraint);
75720:             }
75720:             constraint = next;
75720:             continue;
75720:         }
75720: 
75720:         /*
75720:          * Throw away constraints propagating types into scripts which are
75720:          * about to be destroyed.
75720:          */
75720:         JSScript *script = constraint->script;
75720:         if (script->isCachedEval ||
75720:             (script->u.object && IsAboutToBeFinalized(cx, script->u.object)) ||
75720:             (script->fun && IsAboutToBeFinalized(cx, script->fun))) {
75720:             if (constraint->condensed())
75750:                 ::js_free(constraint);
75720:             constraint = next;
75720:             continue;
75720:         }
75720: 
75720:         if (pcondensed) {
75720:             HashSet<JSScript*>::AddPtr p = pcondensed->lookupForAdd(script);
75720:             if (!p) {
75720:                 if (pcondensed->add(p, script))
75720:                     types->addCondensed(cx, script);
75720:                 else
75720:                     compartment->setPendingNukeTypes(cx);
75720:             }
75720:         }
75720: 
75720:         if (constraint->condensed())
75750:             ::js_free(constraint);
75720:         constraint = next;
75720:     }
75720: 
75720:     if (pcondensed)
75720:         pcondensed->clear();
75720: }
75720: 
75760: /* Remove to-be-destroyed objects from the list of instances of a type object. */
75760: static inline void
75760: PruneInstanceObjects(TypeObject *object)
75760: {
75760:     TypeObject **pinstance = &object->instanceList;
75760:     while (*pinstance) {
75760:         if ((*pinstance)->marked)
75760:             pinstance = &(*pinstance)->instanceNext;
75760:         else
75760:             *pinstance = (*pinstance)->instanceNext;
75760:     }
75760: }
75760: 
75760: static void
75720: CondenseTypeObjectList(JSContext *cx, TypeCompartment *compartment, TypeObject *objects)
75720: {
75720:     HashSet<JSScript *> condensed(cx), *pcondensed = &condensed;
75720:     if (!condensed.init()) {
75720:         compartment->setPendingNukeTypes(cx);
75720:         pcondensed = NULL;
75720:     }
75720: 
75720:     TypeObject *object = objects;
75720:     while (object) {
75736:         if (!object->marked) {
75736:             /*
75736:              * Leave all constraints and references to to-be-destroyed objects in.
75736:              * We will release all memory when sweeping the object.
75736:              */
75736:             object = object->next;
75736:             continue;
75736:         }
75736: 
75760:         PruneInstanceObjects(object);
75736: 
75736:         /* Condense type sets for all properties of the object. */
75720:         if (object->propertyCount >= 2) {
75720:             unsigned capacity = HashSetCapacity(object->propertyCount);
75720:             for (unsigned i = 0; i < capacity; i++) {
75720:                 Property *prop = object->propertySet[i];
75720:                 if (prop) {
75720:                     CondenseSweepTypeSet(cx, compartment, pcondensed, &prop->types);
75720:                     CondenseSweepTypeSet(cx, compartment, pcondensed, &prop->ownTypes);
75720:                 }
75720:             }
75720:         } else if (object->propertyCount == 1) {
75720:             Property *prop = (Property *) object->propertySet;
75720:             CondenseSweepTypeSet(cx, compartment, pcondensed, &prop->types);
75720:             CondenseSweepTypeSet(cx, compartment, pcondensed, &prop->ownTypes);
75720:         }
75736: 
75720:         object = object->next;
75720:     }
75720: }
75720: 
75760: void
75760: TypeCompartment::condense(JSContext *cx)
75760: {
75760:     PruneInstanceObjects(&typeEmpty);
75760: 
75760:     CondenseTypeObjectList(cx, this, objects);
75760: }
75760: 
75720: static void
75720: DestroyProperty(JSContext *cx, Property *prop)
75720: {
75720:     prop->types.destroy(cx);
75720:     prop->ownTypes.destroy(cx);
75720:     cx->free(prop);
75720: }
75720: 
75760: static void
75720: SweepTypeObjectList(JSContext *cx, TypeObject *&objects)
75720: {
75720:     TypeObject **pobject = &objects;
75720:     while (*pobject) {
75720:         TypeObject *object = *pobject;
75720:         if (object->marked) {
75720:             object->marked = false;
75720:             pobject = &object->next;
75720:         } else {
75720:             if (object->emptyShapes)
75720:                 cx->free(object->emptyShapes);
75720:             *pobject = object->next;
75720: 
75720:             if (object->propertyCount >= 2) {
75720:                 unsigned capacity = HashSetCapacity(object->propertyCount);
75720:                 for (unsigned i = 0; i < capacity; i++) {
75720:                     Property *prop = object->propertySet[i];
75720:                     if (prop)
75720:                         DestroyProperty(cx, prop);
75720:                 }
75750:                 ::js_free(object->propertySet);
75720:             } else if (object->propertyCount == 1) {
75720:                 Property *prop = (Property *) object->propertySet;
75720:                 DestroyProperty(cx, prop);
75720:             }
75720: 
75720:             cx->free(object);
75720:         }
75720:     }
75720: }
75720: 
75760: void
75760: TypeCompartment::sweep(JSContext *cx)
75760: {
75760:     if (typeEmpty.marked) {
75760:         typeEmpty.marked = false;
75760:     } else if (typeEmpty.emptyShapes) {
75760:         cx->free(typeEmpty.emptyShapes);
75760:         typeEmpty.emptyShapes = NULL;
75760:     }
75760: 
75770:     /*
75770:      * Iterate through the array/object type tables and remove all entries
75770:      * referencing collected data. These tables only hold weak references.
75770:      */
75770: 
75770:     if (arrayTypeTable) {
75770:         for (ArrayTypeTable::Enum e(*arrayTypeTable); !e.empty(); e.popFront()) {
75770:             const ArrayTableKey &key = e.front().key;
75770:             TypeObject *obj = e.front().value;
75770:             JS_ASSERT(obj->proto == key.proto);
75770: 
75770:             bool remove = false;
75770:             if (TypeIsObject(key.type) && !((TypeObject *)key.type)->marked)
75770:                 remove = true;
75770:             if (!obj->marked)
75770:                 remove = true;
75770: 
75770:             if (remove)
75770:                 e.removeFront();
75770:         }
75770:     }
75770: 
75770:     if (objectTypeTable) {
75770:         for (ObjectTypeTable::Enum e(*objectTypeTable); !e.empty(); e.popFront()) {
75770:             const ObjectTableKey &key = e.front().key;
75770:             const ObjectTableEntry &entry = e.front().value;
75770:             JS_ASSERT(entry.object->proto == key.proto);
75770: 
75770:             bool remove = false;
75770:             if (!entry.object->marked || !entry.newShape->marked())
75770:                 remove = true;
75770:             for (unsigned i = 0; !remove && i < key.nslots; i++) {
75772:                 if (JSID_IS_STRING(key.ids[i])) {
75772:                     JSString *str = JSID_TO_STRING(key.ids[i]);
75857:                     if (!str->isStaticAtom() && !str->isMarked())
75770:                         remove = true;
75772:                 }
75770:                 if (TypeIsObject(entry.types[i]) && !((TypeObject *)entry.types[i])->marked)
75770:                     remove = true;
75770:             }
75770: 
75770:             if (remove) {
75770:                 cx->free(key.ids);
75770:                 cx->free(entry.types);
75770:                 e.removeFront();
75770:             }
75770:         }
75770:     }
75770: 
75760:     SweepTypeObjectList(cx, objects);
75760: }
75760: 
75771: TypeCompartment::~TypeCompartment()
75771: {
75771:     if (pendingArray)
75771:         js_free(pendingArray);
75771: 
75771:     if (arrayTypeTable)
75771:         js_delete<ArrayTypeTable>(arrayTypeTable);
75771: 
75771:     if (objectTypeTable)
75771:         js_delete<ObjectTypeTable>(objectTypeTable);
75771: }
75771: 
75720: } } /* namespace js::types */
75720: 
75720: void
75720: JSScript::condenseTypes(JSContext *cx)
75720: {
75720:     js::types::CondenseTypeObjectList(cx, &compartment->types, typeObjects);
75720: 
75720:     if (varTypes) {
75720:         js::HashSet<JSScript *> condensed(cx), *pcondensed = &condensed;
75720:         if (!condensed.init()) {
75720:             compartment->types.setPendingNukeTypes(cx);
75720:             pcondensed = NULL;
75720:         }
75720: 
75720:         unsigned num = 2 + nfixed + (fun ? fun->nargs : 0) + bindings.countUpvars();
75720: 
75720:         if (isCachedEval ||
75720:             (u.object && IsAboutToBeFinalized(cx, u.object)) ||
75720:             (fun && IsAboutToBeFinalized(cx, fun))) {
75720:             for (unsigned i = 0; i < num; i++)
75720:                 varTypes[i].destroy(cx);
75747:             cx->free(varTypes);
75720:             varTypes = NULL;
75736:         } else {
75736:             for (unsigned i = 0; i < num; i++)
75736:                 js::types::CondenseSweepTypeSet(cx, &compartment->types, pcondensed, &varTypes[i]);
75720:         }
75720:     }
75836: 
75836:     js::types::TypeResult **presult = &typeResults;
75836:     while (*presult) {
75836:         js::types::TypeResult *result = *presult;
75836:         if (js::types::TypeIsObject(result->type)) {
75836:             js::types::TypeObject *object = (js::types::TypeObject *) result->type;
75836:             if (!object->marked) {
75836:                 if (!object->unknownProperties) {
75836:                     *presult = result->next;
75836:                     cx->free(result);
75836:                     continue;
75836:                 } else {
75836:                     result->type = (js::types::jstype) &compartment->types.typeEmpty;
75836:                 }
75836:             }
75836:         }
75836:         presult = &result->next;
75836:     }
75720: }
75720: 
75720: void
75720: JSScript::sweepTypes(JSContext *cx)
75720: {
75720:     SweepTypeObjectList(cx, typeObjects);
75720: 
75768:     if (types && !compartment->types.inferenceDepth) {
75768:         cx->free(types);
75768:         types = NULL;
75768:     }
75768: }
