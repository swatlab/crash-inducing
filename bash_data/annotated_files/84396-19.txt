43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@netscape.com> (original author)
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsHttpConnection.h"
43113: #include "nsHttpTransaction.h"
43113: #include "nsHttpRequestHead.h"
43113: #include "nsHttpResponseHead.h"
43113: #include "nsHttpHandler.h"
43113: #include "nsIOService.h"
43113: #include "nsISocketTransportService.h"
43113: #include "nsISocketTransport.h"
43113: #include "nsIServiceManager.h"
43113: #include "nsISSLSocketControl.h"
43113: #include "nsStringStream.h"
43113: #include "netCore.h"
43113: #include "nsNetCID.h"
64613: #include "nsProxyRelease.h"
43113: #include "prmem.h"
70090: #include "nsPreloadedStream.h"
43113: 
43113: #ifdef DEBUG
43113: // defined by the socket transport service while active
43113: extern PRThread *gSocketThread;
43113: #endif
43113: 
43113: static NS_DEFINE_CID(kSocketTransportServiceCID, NS_SOCKETTRANSPORTSERVICE_CID);
43113: 
70090: using namespace mozilla::net;
70090: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection <public>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpConnection::nsHttpConnection()
43113:     : mTransaction(nsnull)
43113:     , mLastReadTime(0)
43113:     , mIdleTimeout(0)
64613:     , mConsiderReusedAfterInterval(0)
64613:     , mConsiderReusedAfterEpoch(0)
67709:     , mCurrentBytesRead(0)
67709:     , mMaxBytesRead(0)
80486:     , mKeepAlive(true) // assume to keep-alive by default
80486:     , mKeepAliveMask(true)
80486:     , mSupportsPipelining(false) // assume low-grade server
80486:     , mIsReused(false)
80486:     , mCompletedProxyConnect(false)
80486:     , mLastTransactionExpectedNoContent(false)
80486:     , mIdleMonitoring(false)
43113: {
43113:     LOG(("Creating nsHttpConnection @%x\n", this));
43113: 
43113:     // grab a reference to the handler to ensure that it doesn't go away.
43113:     nsHttpHandler *handler = gHttpHandler;
43113:     NS_ADDREF(handler);
43113: }
43113: 
43113: nsHttpConnection::~nsHttpConnection()
43113: {
43113:     LOG(("Destroying nsHttpConnection @%x\n", this));
43113: 
64613:     if (mCallbacks) {
64613:         nsIInterfaceRequestor *cbs = nsnull;
64613:         mCallbacks.swap(cbs);
64613:         NS_ProxyRelease(mCallbackTarget, cbs);
64613:     }
43113: 
43113:     // release our reference to the handler
43113:     nsHttpHandler *handler = gHttpHandler;
43113:     NS_RELEASE(handler);
43113: }
43113: 
43113: nsresult
64613: nsHttpConnection::Init(nsHttpConnectionInfo *info,
64613:                        PRUint16 maxHangTime,
64613:                        nsISocketTransport *transport,
64613:                        nsIAsyncInputStream *instream,
64613:                        nsIAsyncOutputStream *outstream,
64613:                        nsIInterfaceRequestor *callbacks,
64613:                        nsIEventTarget *callbackTarget)
43113: {
64613:     NS_ABORT_IF_FALSE(transport && instream && outstream,
64613:                       "invalid socket information");
64613:     LOG(("nsHttpConnection::Init [this=%p "
64613:          "transport=%p instream=%p outstream=%p]\n",
64613:          this, transport, instream, outstream));
43113: 
43113:     NS_ENSURE_ARG_POINTER(info);
43113:     NS_ENSURE_TRUE(!mConnInfo, NS_ERROR_ALREADY_INITIALIZED);
43113: 
43113:     mConnInfo = info;
43113:     mMaxHangTime = maxHangTime;
43113:     mLastReadTime = NowInSeconds();
64613: 
64613:     mSocketTransport = transport;
64613:     mSocketIn = instream;
64613:     mSocketOut = outstream;
64613:     nsresult rv = mSocketTransport->SetEventSink(this, nsnull);
64613:     NS_ENSURE_SUCCESS(rv, rv);
64613: 
64613:     mCallbacks = callbacks;
64613:     mCallbackTarget = callbackTarget;
64613:     rv = mSocketTransport->SetSecurityCallbacks(this);
64613:     NS_ENSURE_SUCCESS(rv, rv);
64613: 
43113:     return NS_OK;
43113: }
43113: 
43113: // called on the socket thread
43113: nsresult
84396: nsHttpConnection::Activate(nsAHttpTransaction *trans, PRUint8 caps)
43113: {
43113:     nsresult rv;
43113: 
64613:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     LOG(("nsHttpConnection::Activate [this=%x trans=%x caps=%x]\n",
43113:          this, trans, caps));
43113: 
43113:     NS_ENSURE_ARG_POINTER(trans);
43113:     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_IN_PROGRESS);
43113: 
69866:     // Update security callbacks
69866:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
69866:     nsCOMPtr<nsIEventTarget>        callbackTarget;
69866:     trans->GetSecurityCallbacks(getter_AddRefs(callbacks),
69866:                                 getter_AddRefs(callbackTarget));
69866:     if (callbacks != mCallbacks) {
69866:         mCallbacks.swap(callbacks);
69866:         if (callbacks)
69866:             NS_ProxyRelease(mCallbackTarget, callbacks);
69866:         mCallbackTarget = callbackTarget;
69866:     }
69866: 
43113:     // take ownership of the transaction
43113:     mTransaction = trans;
43113: 
70873:     NS_ABORT_IF_FALSE(!mIdleMonitoring,
70873:                       "Activating a connection with an Idle Monitor");
80486:     mIdleMonitoring = false;
70873: 
43113:     // set mKeepAlive according to what will be requested
43113:     mKeepAliveMask = mKeepAlive = (caps & NS_HTTP_ALLOW_KEEPALIVE);
43113: 
69816:     // need to handle HTTP CONNECT tunnels if this is the first time if
69816:     // we are tunneling through a proxy
69816:     if (((mConnInfo->UsingSSL() && mConnInfo->UsingHttpProxy()) ||
69816:          mConnInfo->ShouldForceConnectMethod()) && !mCompletedProxyConnect) {
69816:         rv = SetupProxyConnect();
43113:         if (NS_FAILED(rv))
64613:             goto failed_activation;
43113:     }
43113: 
67709:     // Clear the per activation counter
67709:     mCurrentBytesRead = 0;
67709: 
64613:     rv = OnOutputStreamReady(mSocketOut);
57969:     
64613: failed_activation:
64613:     if (NS_FAILED(rv)) {
64613:         mTransaction = nsnull;
64613:     }
64613: 
43113:     return rv;
43113: }
43113: 
83165: void
43113: nsHttpConnection::Close(nsresult reason)
43113: {
43113:     LOG(("nsHttpConnection::Close [this=%x reason=%x]\n", this, reason));
43113: 
64613:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     if (NS_FAILED(reason)) {
70873:         if (mIdleMonitoring)
70873:             EndIdleMonitoring();
70873: 
43113:         if (mSocketTransport) {
43113:             mSocketTransport->SetSecurityCallbacks(nsnull);
43113:             mSocketTransport->SetEventSink(nsnull, nsnull);
43113:             mSocketTransport->Close(reason);
43113:         }
80486:         mKeepAlive = false;
43113:     }
43113: }
43113: 
43113: // called on the socket thread
43113: nsresult
43113: nsHttpConnection::ProxyStartSSL()
43113: {
43113:     LOG(("nsHttpConnection::ProxyStartSSL [this=%x]\n", this));
43113: #ifdef DEBUG
43113:     NS_PRECONDITION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: #endif
43113: 
43113:     nsCOMPtr<nsISupports> securityInfo;
43113:     nsresult rv = mSocketTransport->GetSecurityInfo(getter_AddRefs(securityInfo));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsCOMPtr<nsISSLSocketControl> ssl = do_QueryInterface(securityInfo, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return ssl->ProxyStartSSL();
43113: }
43113: 
79445: bool
43113: nsHttpConnection::CanReuse()
43113: {
84396:     bool canReuse = IsKeepAlive() &&
64613:         (NowInSeconds() - mLastReadTime < mIdleTimeout) &&
64613:         IsAlive();
64613:     
64613:     // An idle persistent connection should not have data waiting to be read
64613:     // before a request is sent. Data here is likely a 408 timeout response
64613:     // which we would deal with later on through the restart logic, but that
64613:     // path is more expensive than just closing the socket now. SSL check can
64613:     // be removed with fixing of 631801
64613: 
64613:     PRUint32 dataSize;
84396:     if (canReuse && mSocketIn && !mConnInfo->UsingSSL() &&
64613:         NS_SUCCEEDED(mSocketIn->Available(&dataSize)) && dataSize) {
64613:         LOG(("nsHttpConnection::CanReuse %p %s"
64613:              "Socket not reusable because read data pending (%d) on it.\n",
64613:              this, mConnInfo->Host(), dataSize));
80486:         canReuse = false;
64613:     }
64613:     return canReuse;
43113: }
43113: 
55822: PRUint32 nsHttpConnection::TimeToLive()
55822: {
55822:     PRInt32 tmp = mIdleTimeout - (NowInSeconds() - mLastReadTime);
55822:     if (0 > tmp)
55822:         tmp = 0;
55822: 
55822:     return tmp;
55822: }
55822: 
79445: bool
43113: nsHttpConnection::IsAlive()
43113: {
43113:     if (!mSocketTransport)
80486:         return false;
43113: 
79445:     bool alive;
71858:     nsresult rv = mSocketTransport->IsAlive(&alive);
43113:     if (NS_FAILED(rv))
80486:         alive = false;
43113: 
43113: //#define TEST_RESTART_LOGIC
43113: #ifdef TEST_RESTART_LOGIC
43113:     if (!alive) {
43113:         LOG(("pretending socket is still alive to test restart logic\n"));
80486:         alive = true;
43113:     }
43113: #endif
43113: 
43113:     return alive;
43113: }
43113: 
79445: bool
43113: nsHttpConnection::SupportsPipelining(nsHttpResponseHead *responseHead)
43113: {
43113:     // XXX there should be a strict mode available that disables this
43113:     // blacklisting.
43113: 
43113:     // assuming connection is HTTP/1.1 with keep-alive enabled
43113:     if (mConnInfo->UsingHttpProxy() && !mConnInfo->UsingSSL()) {
43113:         // XXX check for bad proxy servers...
80486:         return true;
43113:     }
43113: 
43113:     // XXX what about checking for a Via header? (transparent proxies)
43113: 
43113:     // check for bad origin servers
43113:     const char *val = responseHead->PeekHeader(nsHttp::Server);
43113:     if (!val)
80486:         return false; // no header, no love
43113: 
55936:     // The blacklist is indexed by the first character. All of these servers are
55936:     // known to return their identifier as the first thing in the server string,
55936:     // so we can do a leading match. 
55936: 
82396:     static const char *bad_servers[26][6] = {
55936:         { nsnull }, { nsnull }, { nsnull }, { nsnull },                 // a - d
55936:         { "EFAServer/", nsnull },                                       // e
55936:         { nsnull }, { nsnull }, { nsnull }, { nsnull },                 // f - i
55936:         { nsnull }, { nsnull }, { nsnull },                             // j - l 
55936:         { "Microsoft-IIS/4.", "Microsoft-IIS/5.", nsnull },             // m
55936:         { "Netscape-Enterprise/3.", "Netscape-Enterprise/4.", 
55936:           "Netscape-Enterprise/5.", "Netscape-Enterprise/6.", nsnull }, // n
55936:         { nsnull }, { nsnull }, { nsnull }, { nsnull },                 // o - r
55936:         { nsnull }, { nsnull }, { nsnull }, { nsnull },                 // s - v
82396:         { "WebLogic 3.", "WebLogic 4.","WebLogic 5.", "WebLogic 6.",
82396:           "Winstone Servlet Engine v0.", nsnull },                      // w 
55936:         { nsnull }, { nsnull }, { nsnull }                              // x - z
43113:     };  
43113: 
55936:     int index = val[0] - 'A'; // the whole table begins with capital letters
55936:     if ((index >= 0) && (index <= 25))
55936:     {
55936:         for (int i = 0; bad_servers[index][i] != nsnull; i++) {
55936:             if (!PL_strncmp (val, bad_servers[index][i], strlen (bad_servers[index][i]))) {
43113:                 LOG(("looks like this server does not support pipelining"));
80486:                 return false;
43113:             }
43113:         }
55936:     }
43113: 
43113:     // ok, let's allow pipelining to this server
80486:     return true;
43113: }
43113: 
43113: //----------------------------------------------------------------------------
43113: // nsHttpConnection::nsAHttpConnection compatible methods
43113: //----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpConnection::OnHeadersAvailable(nsAHttpTransaction *trans,
43113:                                      nsHttpRequestHead *requestHead,
43113:                                      nsHttpResponseHead *responseHead,
79445:                                      bool *reset)
43113: {
43113:     LOG(("nsHttpConnection::OnHeadersAvailable [this=%p trans=%p response-head=%p]\n",
43113:         this, trans, responseHead));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113:     NS_ENSURE_ARG_POINTER(trans);
43113:     NS_ASSERTION(responseHead, "No response head?");
43113: 
43113:     // If the server issued an explicit timeout, then we need to close down the
43113:     // socket transport.  We pass an error code of NS_ERROR_NET_RESET to
43113:     // trigger the transactions 'restart' mechanism.  We tell it to reset its
43113:     // response headers so that it will be ready to receive the new response.
43113:     if (responseHead->Status() == 408) {
43113:         Close(NS_ERROR_NET_RESET);
80486:         *reset = true;
43113:         return NS_OK;
43113:     }
43113: 
43113:     // we won't change our keep-alive policy unless the server has explicitly
43113:     // told us to do so.
43113: 
43113:     // inspect the connection headers for keep-alive info provided the
43113:     // transaction completed successfully.
43113:     const char *val = responseHead->PeekHeader(nsHttp::Connection);
43113:     if (!val)
43113:         val = responseHead->PeekHeader(nsHttp::Proxy_Connection);
43113: 
43113:     // reset to default (the server may have changed since we last checked)
80486:     mSupportsPipelining = false;
43113: 
43113:     if ((responseHead->Version() < NS_HTTP_VERSION_1_1) ||
43113:         (requestHead->Version() < NS_HTTP_VERSION_1_1)) {
43113:         // HTTP/1.0 connections are by default NOT persistent
43113:         if (val && !PL_strcasecmp(val, "keep-alive"))
80486:             mKeepAlive = true;
43113:         else
80486:             mKeepAlive = false;
43113:     }
43113:     else {
43113:         // HTTP/1.1 connections are by default persistent
43113:         if (val && !PL_strcasecmp(val, "close")) 
80486:             mKeepAlive = false;
43113:         else {
80486:             mKeepAlive = true;
43113: 
43113:             // Do not support pipelining when we are establishing
43113:             // an SSL tunnel though an HTTP proxy. Pipelining support
43113:             // determination must be based on comunication with the
43113:             // target server in this case. See bug 422016 for futher
43113:             // details.
69816:             if (!mProxyConnectStream)
43113:               mSupportsPipelining = SupportsPipelining(responseHead);
43113:         }
43113:     }
43113:     mKeepAliveMask = mKeepAlive;
43113: 
43113:     // if this connection is persistent, then the server may send a "Keep-Alive"
43113:     // header specifying the maximum number of times the connection can be
43113:     // reused as well as the maximum amount of time the connection can be idle
43113:     // before the server will close it.  we ignore the max reuse count, because
43113:     // a "keep-alive" connection is by definition capable of being reused, and
43113:     // we only care about being able to reuse it once.  if a timeout is not 
43113:     // specified then we use our advertized timeout value.
43113:     if (mKeepAlive) {
43113:         val = responseHead->PeekHeader(nsHttp::Keep_Alive);
43113: 
43113:         const char *cp = PL_strcasestr(val, "timeout=");
43113:         if (cp)
43113:             mIdleTimeout = (PRUint32) atoi(cp + 8);
43113:         else
43113:             mIdleTimeout = gHttpHandler->IdleTimeout();
43113:         
43113:         LOG(("Connection can be reused [this=%x idle-timeout=%u]\n", this, mIdleTimeout));
43113:     }
43113: 
43113:     // if we're doing an SSL proxy connect, then we need to check whether or not
43113:     // the connect was successful.  if so, then we have to reset the transaction
43113:     // and step-up the socket connection to SSL. finally, we have to wake up the
43113:     // socket write request.
69816:     if (mProxyConnectStream) {
69816:         mProxyConnectStream = 0;
43113:         if (responseHead->Status() == 200) {
69816:             LOG(("proxy CONNECT succeeded! ssl=%s\n",
69816:                  mConnInfo->UsingSSL() ? "true" :"false"));
80486:             *reset = true;
69816:             nsresult rv;
69816:             if (mConnInfo->UsingSSL()) {
69816:                 rv = ProxyStartSSL();
43113:                 if (NS_FAILED(rv)) // XXX need to handle this for real
43113:                     LOG(("ProxyStartSSL failed [rv=%x]\n", rv));
69816:             }
80486:             mCompletedProxyConnect = true;
43113:             rv = mSocketOut->AsyncWait(this, 0, 0, nsnull);
43113:             // XXX what if this fails -- need to handle this error
43113:             NS_ASSERTION(NS_SUCCEEDED(rv), "mSocketOut->AsyncWait failed");
43113:         }
43113:         else {
69816:             LOG(("proxy CONNECT failed! ssl=%s\n",
69816:                  mConnInfo->UsingSSL() ? "true" :"false"));
67712:             mTransaction->SetSSLConnectFailed();
43113:         }
43113:     }
43113:     
70090:     const char *upgradeReq = requestHead->PeekHeader(nsHttp::Upgrade);
70090:     if (upgradeReq) {
70090:         LOG(("HTTP Upgrade in play - disable keepalive\n"));
70090:         DontReuse();
70090:     }
70090:     
70090:     if (responseHead->Status() == 101) {
70090:         const char *upgradeResp = responseHead->PeekHeader(nsHttp::Upgrade);
70090:         if (!upgradeReq || !upgradeResp ||
70090:             !nsHttp::FindToken(upgradeResp, upgradeReq,
70090:                                HTTP_HEADER_VALUE_SEPS)) {
70090:             LOG(("HTTP 101 Upgrade header mismatch req = %s, resp = %s\n",
70090:                  upgradeReq, upgradeResp));
70090:             Close(NS_ERROR_ABORT);
70090:         }
70090:         else {
70090:             LOG(("HTTP Upgrade Response to %s\n", upgradeResp));
70090:         }
70090:     }
70090: 
43113:     return NS_OK;
43113: }
43113: 
79445: bool
64613: nsHttpConnection::IsReused()
64613: {
64613:     if (mIsReused)
80486:         return true;
64613:     if (!mConsiderReusedAfterInterval)
80486:         return false;
64613:     
64613:     // ReusedAfter allows a socket to be consider reused only after a certain
64613:     // interval of time has passed
64613:     return (PR_IntervalNow() - mConsiderReusedAfterEpoch) >=
64613:         mConsiderReusedAfterInterval;
64613: }
64613: 
64613: void
64613: nsHttpConnection::SetIsReusedAfter(PRUint32 afterMilliseconds)
64613: {
64613:     mConsiderReusedAfterEpoch = PR_IntervalNow();
64613:     mConsiderReusedAfterInterval = PR_MillisecondsToInterval(afterMilliseconds);
64613: }
64613: 
70090: nsresult
70090: nsHttpConnection::TakeTransport(nsISocketTransport  **aTransport,
70090:                                 nsIAsyncInputStream **aInputStream,
70090:                                 nsIAsyncOutputStream **aOutputStream)
70090: {
70090:     if (mTransaction && !mTransaction->IsDone())
70090:         return NS_ERROR_IN_PROGRESS;
70090:     if (!(mSocketTransport && mSocketIn && mSocketOut))
70090:         return NS_ERROR_NOT_INITIALIZED;
70090: 
70090:     if (mInputOverflow)
70090:         mSocketIn = mInputOverflow.forget();
70090: 
70090:     NS_IF_ADDREF(*aTransport = mSocketTransport);
70090:     NS_IF_ADDREF(*aInputStream = mSocketIn);
70090:     NS_IF_ADDREF(*aOutputStream = mSocketOut);
70090: 
70090:     mSocketTransport->SetSecurityCallbacks(nsnull);
70090:     mSocketTransport->SetEventSink(nsnull, nsnull);
70090:     mSocketTransport = nsnull;
70090:     mSocketIn = nsnull;
70090:     mSocketOut = nsnull;
70090:     
70090:     return NS_OK;
70090: }
70090: 
43113: void
43113: nsHttpConnection::GetSecurityInfo(nsISupports **secinfo)
43113: {
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     if (mSocketTransport) {
43113:         if (NS_FAILED(mSocketTransport->GetSecurityInfo(secinfo)))
43113:             *secinfo = nsnull;
43113:     }
43113: }
43113: 
43113: nsresult
70090: nsHttpConnection::PushBack(const char *data, PRUint32 length)
70090: {
70090:     LOG(("nsHttpConnection::PushBack [this=%p, length=%d]\n", this, length));
70090: 
70090:     if (mInputOverflow) {
70090:         NS_ERROR("nsHttpConnection::PushBack only one buffer supported");
70090:         return NS_ERROR_UNEXPECTED;
70090:     }
70090:     
70090:     mInputOverflow = new nsPreloadedStream(mSocketIn, data, length);
70090:     return NS_OK;
70090: }
70090: 
70090: nsresult
84396: nsHttpConnection::ResumeSend()
43113: {
43113:     LOG(("nsHttpConnection::ResumeSend [this=%p]\n", this));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     if (mSocketOut)
43113:         return mSocketOut->AsyncWait(this, 0, 0, nsnull);
43113: 
43113:     NS_NOTREACHED("no socket output stream");
43113:     return NS_ERROR_UNEXPECTED;
43113: }
43113: 
43113: nsresult
84396: nsHttpConnection::ResumeRecv()
43113: {
43113:     LOG(("nsHttpConnection::ResumeRecv [this=%p]\n", this));
43113: 
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
43113:     if (mSocketIn)
43113:         return mSocketIn->AsyncWait(this, 0, 0, nsnull);
43113: 
43113:     NS_NOTREACHED("no socket input stream");
43113:     return NS_ERROR_UNEXPECTED;
43113: }
43113: 
70873: void
70873: nsHttpConnection::BeginIdleMonitoring()
70873: {
70873:     LOG(("nsHttpConnection::BeginIdleMonitoring [this=%p]\n", this));
70873:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "wrong thread");
70873:     NS_ABORT_IF_FALSE(!mTransaction, "BeginIdleMonitoring() while active");
70873:     
70873:     LOG(("Entering Idle Monitoring Mode [this=%p]", this));
80486:     mIdleMonitoring = true;
70873:     if (mSocketIn)
70873:         mSocketIn->AsyncWait(this, 0, 0, nsnull);
70873: }
70873: 
70873: void
70873: nsHttpConnection::EndIdleMonitoring()
70873: {
70873:     LOG(("nsHttpConnection::EndIdleMonitoring [this=%p]\n", this));
70873:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "wrong thread");
70873:     NS_ABORT_IF_FALSE(!mTransaction, "EndIdleMonitoring() while active");
70873: 
70873:     if (mIdleMonitoring) {
70873:         LOG(("Leaving Idle Monitoring Mode [this=%p]", this));
80486:         mIdleMonitoring = false;
70873:         if (mSocketIn)
70873:             mSocketIn->AsyncWait(nsnull, 0, 0, nsnull);
70873:     }
70873: }
70873: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection <private>
43113: //-----------------------------------------------------------------------------
43113: 
43113: void
43113: nsHttpConnection::CloseTransaction(nsAHttpTransaction *trans, nsresult reason)
43113: {
43113:     LOG(("nsHttpConnection::CloseTransaction[this=%x trans=%x reason=%x]\n",
43113:         this, trans, reason));
43113: 
43113:     NS_ASSERTION(trans == mTransaction, "wrong transaction");
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
67709:     if (mCurrentBytesRead > mMaxBytesRead)
67709:         mMaxBytesRead = mCurrentBytesRead;
67709: 
43113:     // mask this error code because its not a real error.
43113:     if (reason == NS_BASE_STREAM_CLOSED)
43113:         reason = NS_OK;
43113: 
43113:     mTransaction->Close(reason);
64613:     mTransaction = nsnull;
43113: 
73865:     if (mCallbacks) {
73865:         nsIInterfaceRequestor *cbs = nsnull;
73865:         mCallbacks.swap(cbs);
73865:         NS_ProxyRelease(mCallbackTarget, cbs);
73865:     }
73865: 
43113:     if (NS_FAILED(reason))
43113:         Close(reason);
43113: 
43113:     // flag the connection as reused here for convenience sake.  certainly
43113:     // it might be going away instead ;-)
80486:     mIsReused = true;
43113: }
43113: 
43113: NS_METHOD
43113: nsHttpConnection::ReadFromStream(nsIInputStream *input,
43113:                                  void *closure,
43113:                                  const char *buf,
43113:                                  PRUint32 offset,
43113:                                  PRUint32 count,
43113:                                  PRUint32 *countRead)
43113: {
43113:     // thunk for nsIInputStream instance
43113:     nsHttpConnection *conn = (nsHttpConnection *) closure;
43113:     return conn->OnReadSegment(buf, count, countRead);
43113: }
43113: 
43113: nsresult
43113: nsHttpConnection::OnReadSegment(const char *buf,
43113:                                 PRUint32 count,
43113:                                 PRUint32 *countRead)
43113: {
43113:     if (count == 0) {
43113:         // some ReadSegments implementations will erroneously call the writer
43113:         // to consume 0 bytes worth of data.  we must protect against this case
43113:         // or else we'd end up closing the socket prematurely.
43113:         NS_ERROR("bad ReadSegments implementation");
43113:         return NS_ERROR_FAILURE; // stop iterating
43113:     }
43113: 
43113:     nsresult rv = mSocketOut->Write(buf, count, countRead);
43113:     if (NS_FAILED(rv))
43113:         mSocketOutCondition = rv;
43113:     else if (*countRead == 0)
43113:         mSocketOutCondition = NS_BASE_STREAM_CLOSED;
43113:     else
43113:         mSocketOutCondition = NS_OK; // reset condition
43113: 
43113:     return mSocketOutCondition;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnection::OnSocketWritable()
43113: {
43113:     LOG(("nsHttpConnection::OnSocketWritable [this=%x]\n", this));
43113: 
43113:     nsresult rv;
43113:     PRUint32 n;
79445:     bool again = true;
43113: 
43113:     do {
43113:         // if we're doing an SSL proxy connect, then we need to bypass calling
43113:         // into the transaction.
43113:         //
43113:         // NOTE: this code path can't be shared since the transaction doesn't
43113:         // implement nsIInputStream.  doing so is not worth the added cost of
43113:         // extra indirections during normal reading.
43113:         //
69816:         if (mProxyConnectStream) {
43113:             LOG(("  writing CONNECT request stream\n"));
69816:             rv = mProxyConnectStream->ReadSegments(ReadFromStream, this,
43113:                                                       nsIOService::gDefaultSegmentSize,
43113:                                                       &n);
43113:         }
43113:         else {
43113:             LOG(("  writing transaction request stream\n"));
43113:             rv = mTransaction->ReadSegments(this, nsIOService::gDefaultSegmentSize, &n);
43113:         }
43113: 
43113:         LOG(("  ReadSegments returned [rv=%x read=%u sock-cond=%x]\n",
43113:             rv, n, mSocketOutCondition));
43113: 
43113:         // XXX some streams return NS_BASE_STREAM_CLOSED to indicate EOF.
43113:         if (rv == NS_BASE_STREAM_CLOSED) {
43113:             rv = NS_OK;
43113:             n = 0;
43113:         }
43113: 
43113:         if (NS_FAILED(rv)) {
43113:             // if the transaction didn't want to write any more data, then
43113:             // wait for the transaction to call ResumeSend.
43113:             if (rv == NS_BASE_STREAM_WOULD_BLOCK)
43113:                 rv = NS_OK;
80486:             again = false;
43113:         }
43113:         else if (NS_FAILED(mSocketOutCondition)) {
43113:             if (mSocketOutCondition == NS_BASE_STREAM_WOULD_BLOCK)
43113:                 rv = mSocketOut->AsyncWait(this, 0, 0, nsnull); // continue writing
43113:             else
43113:                 rv = mSocketOutCondition;
80486:             again = false;
43113:         }
43113:         else if (n == 0) {
43113:             // 
43113:             // at this point we've written out the entire transaction, and now we
43113:             // must wait for the server's response.  we manufacture a status message
43113:             // here to reflect the fact that we are waiting.  this message will be
43113:             // trumped (overwritten) if the server responds quickly.
43113:             //
67756:             mTransaction->OnTransportStatus(mSocketTransport,
67756:                                             nsISocketTransport::STATUS_WAITING_FOR,
43113:                                             LL_ZERO);
43113: 
43113:             rv = mSocketIn->AsyncWait(this, 0, 0, nsnull); // start reading
80486:             again = false;
43113:         }
43113:         // write more to the socket until error or end-of-request...
43113:     } while (again);
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnection::OnWriteSegment(char *buf,
43113:                                  PRUint32 count,
43113:                                  PRUint32 *countWritten)
43113: {
43113:     if (count == 0) {
43113:         // some WriteSegments implementations will erroneously call the reader
43113:         // to provide 0 bytes worth of data.  we must protect against this case
43113:         // or else we'd end up closing the socket prematurely.
43113:         NS_ERROR("bad WriteSegments implementation");
43113:         return NS_ERROR_FAILURE; // stop iterating
43113:     }
43113: 
43113:     nsresult rv = mSocketIn->Read(buf, count, countWritten);
43113:     if (NS_FAILED(rv))
43113:         mSocketInCondition = rv;
43113:     else if (*countWritten == 0)
43113:         mSocketInCondition = NS_BASE_STREAM_CLOSED;
43113:     else
43113:         mSocketInCondition = NS_OK; // reset condition
43113: 
43113:     return mSocketInCondition;
43113: }
43113: 
43113: nsresult
43113: nsHttpConnection::OnSocketReadable()
43113: {
43113:     LOG(("nsHttpConnection::OnSocketReadable [this=%x]\n", this));
43113: 
43113:     PRUint32 now = NowInSeconds();
43113: 
43113:     if (mKeepAliveMask && (now - mLastReadTime >= PRUint32(mMaxHangTime))) {
43113:         LOG(("max hang time exceeded!\n"));
43113:         // give the handler a chance to create a new persistent connection to
43113:         // this host if we've been busy for too long.
80486:         mKeepAliveMask = false;
43113:         gHttpHandler->ProcessPendingQ(mConnInfo);
43113:     }
43113:     mLastReadTime = now;
43113: 
43113:     nsresult rv;
43113:     PRUint32 n;
79445:     bool again = true;
43113: 
43113:     do {
43113:         rv = mTransaction->WriteSegments(this, nsIOService::gDefaultSegmentSize, &n);
43113:         if (NS_FAILED(rv)) {
43113:             // if the transaction didn't want to take any more data, then
43113:             // wait for the transaction to call ResumeRecv.
43113:             if (rv == NS_BASE_STREAM_WOULD_BLOCK)
43113:                 rv = NS_OK;
80486:             again = false;
43113:         }
67709:         else {
67709:             mCurrentBytesRead += n;
67709:             if (NS_FAILED(mSocketInCondition)) {
43113:                 // continue waiting for the socket if necessary...
43113:                 if (mSocketInCondition == NS_BASE_STREAM_WOULD_BLOCK)
43113:                     rv = mSocketIn->AsyncWait(this, 0, 0, nsnull);
43113:                 else
43113:                     rv = mSocketInCondition;
80486:                 again = false;
43113:             }
67709:         }
43113:         // read more from the socket until error...
43113:     } while (again);
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
69816: nsHttpConnection::SetupProxyConnect()
43113: {
43113:     const char *val;
43113: 
69816:     LOG(("nsHttpConnection::SetupProxyConnect [this=%x]\n", this));
43113: 
69816:     NS_ENSURE_TRUE(!mProxyConnectStream, NS_ERROR_ALREADY_INITIALIZED);
43113: 
43113:     nsCAutoString buf;
43113:     nsresult rv = nsHttpHandler::GenerateHostPort(
43113:             nsDependentCString(mConnInfo->Host()), mConnInfo->Port(), buf);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     // CONNECT host:port HTTP/1.1
43113:     nsHttpRequestHead request;
43113:     request.SetMethod(nsHttp::Connect);
43113:     request.SetVersion(gHttpHandler->HttpVersion());
43113:     request.SetRequestURI(buf);
43113:     request.SetHeader(nsHttp::User_Agent, gHttpHandler->UserAgent());
43113: 
43113:     // send this header for backwards compatibility.
43113:     request.SetHeader(nsHttp::Proxy_Connection, NS_LITERAL_CSTRING("keep-alive"));
43113: 
67712:     val = mTransaction->RequestHead()->PeekHeader(nsHttp::Host);
43113:     if (val) {
43113:         // all HTTP/1.1 requests must include a Host header (even though it
43113:         // may seem redundant in this case; see bug 82388).
43113:         request.SetHeader(nsHttp::Host, nsDependentCString(val));
43113:     }
43113: 
67712:     val = mTransaction->RequestHead()->PeekHeader(nsHttp::Proxy_Authorization);
43113:     if (val) {
43113:         // we don't know for sure if this authorization is intended for the
43113:         // SSL proxy, so we add it just in case.
43113:         request.SetHeader(nsHttp::Proxy_Authorization, nsDependentCString(val));
43113:     }
43113: 
43113:     buf.Truncate();
80486:     request.Flatten(buf, false);
43113:     buf.AppendLiteral("\r\n");
43113: 
69816:     return NS_NewCStringInputStream(getter_AddRefs(mProxyConnectStream), buf);
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection::nsISupports
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS4(nsHttpConnection,
43113:                               nsIInputStreamCallback,
43113:                               nsIOutputStreamCallback,
43113:                               nsITransportEventSink,
43113:                               nsIInterfaceRequestor)
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection::nsIInputStreamCallback
43113: //-----------------------------------------------------------------------------
43113: 
43113: // called on the socket transport thread
43113: NS_IMETHODIMP
43113: nsHttpConnection::OnInputStreamReady(nsIAsyncInputStream *in)
43113: {
43113:     NS_ASSERTION(in == mSocketIn, "unexpected stream");
43113:     NS_ASSERTION(PR_GetCurrentThread() == gSocketThread, "wrong thread");
43113: 
70873:     if (mIdleMonitoring) {
70873:         NS_ABORT_IF_FALSE(!mTransaction, "Idle Input Event While Active");
70873: 
70873:         // The only read event that is protocol compliant for an idle connection
70873:         // is an EOF, which we check for with CanReuse(). If the data is
70873:         // something else then just ignore it and suspend checking for EOF -
70873:         // our normal timers or protocol stack are the place to deal with
70873:         // any exception logic.
70873: 
70873:         if (!CanReuse()) {
70873:             LOG(("Server initiated close of idle conn %p\n", this));
70873:             gHttpHandler->ConnMgr()->CloseIdleConnection(this);
70873:             return NS_OK;
70873:         }
70873: 
70873:         LOG(("Input data on idle conn %p, but not closing yet\n", this));
70873:         return NS_OK;
70873:     }
70873: 
43113:     // if the transaction was dropped...
43113:     if (!mTransaction) {
43113:         LOG(("  no transaction; ignoring event\n"));
43113:         return NS_OK;
43113:     }
43113: 
43113:     nsresult rv = OnSocketReadable();
43113:     if (NS_FAILED(rv))
43113:         CloseTransaction(mTransaction, rv);
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection::nsIOutputStreamCallback
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpConnection::OnOutputStreamReady(nsIAsyncOutputStream *out)
43113: {
64613:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "wrong thread");
64613:     NS_ABORT_IF_FALSE(out == mSocketOut, "unexpected socket");
60015: 
59609:     // if the transaction was dropped...
59609:     if (!mTransaction) {
59609:         LOG(("  no transaction; ignoring event\n"));
59609:         return NS_OK;
59609:     }
59609: 
59398:     nsresult rv = OnSocketWritable();
43113:     if (NS_FAILED(rv))
43113:         CloseTransaction(mTransaction, rv);
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection::nsITransportEventSink
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpConnection::OnTransportStatus(nsITransport *trans,
43113:                                     nsresult status,
43113:                                     PRUint64 progress,
43113:                                     PRUint64 progressMax)
43113: {
43113:     if (mTransaction)
67756:         mTransaction->OnTransportStatus(trans, status, progress);
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpConnection::nsIInterfaceRequestor
43113: //-----------------------------------------------------------------------------
43113: 
43113: // not called on the socket transport thread
43113: NS_IMETHODIMP
43113: nsHttpConnection::GetInterface(const nsIID &iid, void **result)
43113: {
43113:     // NOTE: This function is only called on the UI thread via sync proxy from
43113:     //       the socket transport thread.  If that weren't the case, then we'd
43113:     //       have to worry about the possibility of mTransaction going away
43113:     //       part-way through this function call.  See CloseTransaction.
64613: 
64613:     // NOTE - there is a bug here, the call to getinterface is proxied off the
64613:     // nss thread, not the ui thread as the above comment says. So there is
64613:     // indeed a chance of mTransaction going away. bug 615342
64613: 
43113:     NS_ASSERTION(PR_GetCurrentThread() != gSocketThread, "wrong thread");
43113: 
64613:     if (mCallbacks)
64613:         return mCallbacks->GetInterface(iid, result);
43113:     return NS_ERROR_NO_INTERFACE;
43113: }
