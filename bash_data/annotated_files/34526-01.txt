    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *   Alec Flett <alecf@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIXBLService.h"
    1: #include "nsIInputStream.h"
    1: #include "nsDoubleHashtable.h"
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
    1: #include "nsIChannel.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIParser.h"
    1: #include "nsParserCIID.h"
    1: #include "nsNetUtil.h"
    1: #include "plstr.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIXMLContentSink.h"
    1: #include "nsContentCID.h"
    1: #include "nsXMLDocument.h"
    1: #include "nsIStreamListener.h"
    1: 
    1: #include "nsXBLBinding.h"
    1: #include "nsXBLPrototypeBinding.h"
    1: #include "nsIXBLDocumentInfo.h"
    1: #include "nsXBLInsertionPoint.h"
    1: 
    1: #include "nsIStyleSheet.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsIHTMLCSSStyleSheet.h"
    1: 
    1: #include "nsIStyleRuleProcessor.h"
30988: #include "nsRuleProcessorData.h"
    1: #include "nsIWeakReference.h"
    1: 
    1: #include "jsapi.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIDOMScriptObjectFactory.h"
    1: #include "nsIScriptGlobalObject.h"
16231: #include "nsTHashtable.h"
    1: 
    1: #include "nsIScriptContext.h"
    1: #include "nsBindingManager.h"
    1: 
    1: #include "nsThreadUtils.h"
    1: 
    1: // ==================================================================
    1: // = nsAnonymousContentList 
    1: // ==================================================================
    1: 
 6864: #define NS_ANONYMOUS_CONTENT_LIST_IID \
 6864:   { 0xa29df1f8, 0xaeca, 0x4356, \
 6864:     { 0xa8, 0xc2, 0xa7, 0x24, 0xa2, 0x11, 0x73, 0xac } }
 6864: 
20752: class nsAnonymousContentList : public nsINodeList
    1: {
    1: public:
    1:   nsAnonymousContentList(nsInsertionPointList* aElements);
    1:   virtual ~nsAnonymousContentList();
    1: 
 1829:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
20752:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsAnonymousContentList, nsINodeList)
    1:   // nsIDOMNodeList interface
    1:   NS_DECL_NSIDOMNODELIST
    1: 
19130:   // nsINodeList interface
24403:   virtual nsIContent* GetNodeAt(PRUint32 aIndex);
24403:   virtual PRInt32 IndexOf(nsIContent* aContent);
19130: 
    1:   PRInt32 GetInsertionPointCount() { return mElements->Length(); }
    1: 
 3233:   nsXBLInsertionPoint* GetInsertionPointAt(PRInt32 i) { return static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i)); }
    1:   void RemoveInsertionPointAt(PRInt32 i) { mElements->RemoveElementAt(i); }
 6864:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ANONYMOUS_CONTENT_LIST_IID)
    1: private:
    1:   nsInsertionPointList* mElements;
    1: };
    1: 
 6864: NS_DEFINE_STATIC_IID_ACCESSOR(nsAnonymousContentList,
 6864:                               NS_ANONYMOUS_CONTENT_LIST_IID)
 6864: 
    1: nsAnonymousContentList::nsAnonymousContentList(nsInsertionPointList* aElements)
    1:   : mElements(aElements)
    1: {
    1:   MOZ_COUNT_CTOR(nsAnonymousContentList);
    1: 
    1:   // We don't reference count our Anonymous reference (to avoid circular
    1:   // references). We'll be told when the Anonymous goes away.
    1: }
    1: 
    1: nsAnonymousContentList::~nsAnonymousContentList()
    1: {
    1:   MOZ_COUNT_DTOR(nsAnonymousContentList);
    1:   delete mElements;
    1: }
    1: 
 1829: NS_IMPL_CYCLE_COLLECTION_CLASS(nsAnonymousContentList)
 1829: 
 1829: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAnonymousContentList)
 1829: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAnonymousContentList)
 1829: 
21218: NS_INTERFACE_TABLE_HEAD(nsAnonymousContentList)
21218:   NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsAnonymousContentList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsAnonymousContentList, nsINodeList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsAnonymousContentList, nsIDOMNodeList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsAnonymousContentList, nsAnonymousContentList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
 1829:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeList)
 1829:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsAnonymousContentList)
 1829: NS_INTERFACE_MAP_END
 1829: 
 1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsAnonymousContentList)
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsAnonymousContentList)
 1829:   {
 1829:     PRInt32 i, count = tmp->mElements->Length();
 1829:     for (i = 0; i < count; ++i) {
 1829:       NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mElements->ElementAt(i),
 1829:                                                       nsXBLInsertionPoint);
 1829:     }
 1829:   }
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 1829: 
    1: NS_IMETHODIMP
    1: nsAnonymousContentList::GetLength(PRUint32* aLength)
    1: {
    1:   NS_ASSERTION(aLength != nsnull, "null ptr");
    1:   if (! aLength)
    1:       return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRInt32 cnt = mElements->Length();
    1: 
    1:   *aLength = 0;
    1:   for (PRInt32 i = 0; i < cnt; i++)
 3233:     *aLength += static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i))->ChildCount();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsAnonymousContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
    1: {
19130:   nsINode* item = GetNodeAt(aIndex);
19130:   if (!item)
19130:     return NS_ERROR_FAILURE;
19130: 
19130:   return CallQueryInterface(item, aReturn);    
19130: }
19130: 
24403: nsIContent*
19130: nsAnonymousContentList::GetNodeAt(PRUint32 aIndex)
19130: {
    1:   PRInt32 cnt = mElements->Length();
    1:   PRUint32 pointCount = 0;
    1: 
    1:   for (PRInt32 i = 0; i < cnt; i++) {
    1:     aIndex -= pointCount;
    1:     
 3233:     nsXBLInsertionPoint* point = static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i));
    1:     pointCount = point->ChildCount();
    1: 
    1:     if (aIndex < pointCount) {
19130:       return point->ChildAt(aIndex);
    1:     }
    1:   }
    1: 
19130:   return nsnull;
    1: }
    1: 
24403: PRInt32
24403: nsAnonymousContentList::IndexOf(nsIContent* aContent)
24403: {
24403:   PRInt32 cnt = mElements->Length();
24403:   PRInt32 lengthSoFar = 0;
24403: 
24403:   for (PRInt32 i = 0; i < cnt; ++i) {
24403:     nsXBLInsertionPoint* point =
24403:       static_cast<nsXBLInsertionPoint*>(mElements->ElementAt(i));
24403:     PRInt32 idx = point->IndexOf(aContent);
24403:     if (idx != -1) {
24403:       return idx + lengthSoFar;
24403:     }
24403: 
24403:     lengthSoFar += point->ChildCount();
24403:   }
24403: 
24403:   // Didn't find it anywhere
24403:   return -1;
24403: }
24403: 
    1: //
    1: // Generic pldhash table stuff for mapping one nsISupports to another
    1: //
    1: // These values are never null - a null value implies that this
    1: // whole key should be removed (See SetOrRemoveObject)
    1: class ObjectEntry : public PLDHashEntryHdr
    1: {
    1: public:
    1: 
    1:   // note that these are allocated within the PLDHashTable, but we
    1:   // want to keep track of them anyway
    1:   ObjectEntry() { MOZ_COUNT_CTOR(ObjectEntry); }
    1:   ~ObjectEntry() { MOZ_COUNT_DTOR(ObjectEntry); }
    1:   
    1:   nsISupports* GetValue() { return mValue; }
    1:   nsISupports* GetKey() { return mKey; }
    1:   void SetValue(nsISupports* aValue) { mValue = aValue; }
    1:   void SetKey(nsISupports* aKey) { mKey = aKey; }
    1:   
    1: private:
    1:   nsCOMPtr<nsISupports> mKey;
    1:   nsCOMPtr<nsISupports> mValue;
    1: };
    1: 
20261: static void
    1: ClearObjectEntry(PLDHashTable* table, PLDHashEntryHdr *entry)
    1: {
 3233:   ObjectEntry* objEntry = static_cast<ObjectEntry*>(entry);
    1:   objEntry->~ObjectEntry();
    1: }
    1: 
20261: static PRBool
    1: InitObjectEntry(PLDHashTable* table, PLDHashEntryHdr* entry, const void* key)
    1: {
    1:   new (entry) ObjectEntry;
    1:   return PR_TRUE;
    1: }
    1:   
    1: 
    1: 
    1: static PLDHashTableOps ObjectTableOps = {
    1:   PL_DHashAllocTable,
    1:   PL_DHashFreeTable,
    1:   PL_DHashVoidPtrKeyStub,
    1:   PL_DHashMatchEntryStub,
    1:   PL_DHashMoveEntryStub,
    1:   ClearObjectEntry,
    1:   PL_DHashFinalizeStub,
    1:   InitObjectEntry
    1: };
    1: 
    1: // helper routine for adding a new entry
    1: static nsresult
    1: AddObjectEntry(PLDHashTable& table, nsISupports* aKey, nsISupports* aValue)
    1: {
    1:   NS_ASSERTION(aKey, "key must be non-null");
    1:   if (!aKey) return NS_ERROR_INVALID_ARG;
    1:   
    1:   ObjectEntry *entry =
 3233:     static_cast<ObjectEntry*>
 3233:                (PL_DHashTableOperate(&table, aKey, PL_DHASH_ADD));
    1: 
    1:   if (!entry)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // only add the key if the entry is new
    1:   if (!entry->GetKey())
    1:     entry->SetKey(aKey);
    1: 
    1:   // now attach the new entry - note that entry->mValue could possibly
    1:   // have a value already, this will release that.
    1:   entry->SetValue(aValue);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // helper routine for looking up an existing entry. Note that the
    1: // return result is NOT addreffed
    1: static nsISupports*
 5141: LookupObject(PLDHashTable& table, nsIContent* aKey)
    1: {
 5141:   if (aKey && aKey->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
    1:     ObjectEntry *entry =
 3233:       static_cast<ObjectEntry*>
 3233:                  (PL_DHashTableOperate(&table, aKey, PL_DHASH_LOOKUP));
    1: 
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry))
    1:       return entry->GetValue();
 5141:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: inline void
    1: RemoveObjectEntry(PLDHashTable& table, nsISupports* aKey)
    1: {
    1:   PL_DHashTableOperate(&table, aKey, PL_DHASH_REMOVE);
    1: }
    1: 
    1: static nsresult
 1376: SetOrRemoveObject(PLDHashTable& table, nsIContent* aKey, nsISupports* aValue)
    1: {
    1:   if (aValue) {
    1:     // lazily create the table, but only when adding elements
    1:     if (!table.ops &&
    1:         !PL_DHashTableInit(&table, &ObjectTableOps, nsnull,
    1:                            sizeof(ObjectEntry), 16)) {
    1:       table.ops = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
 1376:     aKey->SetFlags(NODE_MAY_BE_IN_BINDING_MNGR);
    1:     return AddObjectEntry(table, aKey, aValue);
    1:   }
    1: 
    1:   // no value, so remove the key from the table
 6864:   if (table.ops) {
 6864:     ObjectEntry* entry =
 6864:       static_cast<ObjectEntry*>
 6864:         (PL_DHashTableOperate(&table, aKey, PL_DHASH_LOOKUP));
 6864:     if (entry && PL_DHASH_ENTRY_IS_BUSY(entry)) {
 6864:       // Keep key and value alive while removing the entry.
 6864:       nsCOMPtr<nsISupports> key = entry->GetKey();
 6864:       nsCOMPtr<nsISupports> value = entry->GetValue();
    1:       RemoveObjectEntry(table, aKey);
 6864:     }
 6864:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Implementation /////////////////////////////////////////////////////////////////
    1: 
    1: // Static member variable initialization
    1: 
    1: // Implement our nsISupports methods
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsBindingManager)
 8681:   tmp->mDestroyed = PR_TRUE;
 8681: 
    1:   if (tmp->mBindingTable.IsInitialized())
    1:     tmp->mBindingTable.Clear();
    1: 
    1:   if (tmp->mDocumentTable.IsInitialized())
    1:     tmp->mDocumentTable.Clear();
    1: 
    1:   if (tmp->mLoadingDocTable.IsInitialized())
    1:     tmp->mLoadingDocTable.Clear();
    1: 
    1:   if (tmp->mContentListTable.ops)
    1:     PL_DHashTableFinish(&(tmp->mContentListTable));
    1:   tmp->mContentListTable.ops = nsnull;
    1: 
    1:   if (tmp->mAnonymousNodesTable.ops)
    1:     PL_DHashTableFinish(&(tmp->mAnonymousNodesTable));
    1:   tmp->mAnonymousNodesTable.ops = nsnull;
    1: 
    1:   if (tmp->mInsertionParentTable.ops)
    1:     PL_DHashTableFinish(&(tmp->mInsertionParentTable));
    1:   tmp->mInsertionParentTable.ops = nsnull;
    1: 
    1:   if (tmp->mWrapperTable.ops)
    1:     PL_DHashTableFinish(&(tmp->mWrapperTable));
    1:   tmp->mWrapperTable.ops = nsnull;
    1: 
 1829:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mAttachedStack)
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
    1: 
    1: static PLDHashOperator
    1: DocumentInfoHashtableTraverser(nsIURI* key,
    1:                                nsIXBLDocumentInfo* di,
    1:                                void* userArg)
    1: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
30000:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mDocumentTable value");
    1:   cb->NoteXPCOMChild(di);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: static PLDHashOperator
    1: LoadingDocHashtableTraverser(nsIURI* key,
    1:                              nsIStreamListener* sl,
    1:                              void* userArg)
    1: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
30000:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mLoadingDocTable value");
    1:   cb->NoteXPCOMChild(sl);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsBindingManager)
    1:   // The hashes keyed on nsIContent are traversed from the nsIContent itself.
    1:   if (tmp->mDocumentTable.IsInitialized())
    1:       tmp->mDocumentTable.EnumerateRead(&DocumentInfoHashtableTraverser, &cb);
    1:   if (tmp->mLoadingDocTable.IsInitialized())
    1:       tmp->mLoadingDocTable.EnumerateRead(&LoadingDocHashtableTraverser, &cb);
 1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY_MEMBER(mAttachedStack,
 1829:                                                     nsXBLBinding)
    1:   // No need to traverse mProcessAttachedQueueEvent, since it'll just
24565:   // fire at some point or become revoke and drop its ref to us.
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsBindingManager)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsBindingManager)
    1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsBindingManager)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsBindingManager)
    1: 
    1: // Constructors/Destructors
 6627: nsBindingManager::nsBindingManager(nsIDocument* aDocument)
 2025:   : mProcessingAttachedStack(PR_FALSE),
 8681:     mDestroyed(PR_FALSE),
 7274:     mAttachedStackSizeOnOutermost(0),
 6627:     mDocument(aDocument)
    1: {
    1:   mContentListTable.ops = nsnull;
    1:   mAnonymousNodesTable.ops = nsnull;
    1:   mInsertionParentTable.ops = nsnull;
    1:   mWrapperTable.ops = nsnull;
    1: }
    1: 
    1: nsBindingManager::~nsBindingManager(void)
    1: {
 8681:   mDestroyed = PR_TRUE;
 8681: 
    1:   if (mContentListTable.ops)
    1:     PL_DHashTableFinish(&mContentListTable);
    1:   if (mAnonymousNodesTable.ops)
    1:     PL_DHashTableFinish(&mAnonymousNodesTable);
 6864:   NS_ASSERTION(!mInsertionParentTable.ops || !mInsertionParentTable.entryCount,
 6864:                "Insertion parent table isn't empty!");
    1:   if (mInsertionParentTable.ops)
    1:     PL_DHashTableFinish(&mInsertionParentTable);
    1:   if (mWrapperTable.ops)
    1:     PL_DHashTableFinish(&mWrapperTable);
    1: }
    1: 
 6864: PLDHashOperator
20261: RemoveInsertionParentCB(PLDHashTable* aTable, PLDHashEntryHdr* aEntry,
 6864:                         PRUint32 aNumber, void* aArg)
 6864: {
 6864:   return (static_cast<ObjectEntry*>(aEntry)->GetValue() ==
 6864:           static_cast<nsISupports*>(aArg)) ? PL_DHASH_REMOVE : PL_DHASH_NEXT;
 6864: }
 6864: 
 6864: static void
 6864: RemoveInsertionParentForNodeList(nsIDOMNodeList* aList, nsIContent* aParent)
 6864: {
19130:   nsAnonymousContentList* list = nsnull;
19130:   if (aList) {
19130:     CallQueryInterface(aList, &list);
19130:   }
 6864:   if (list) {
 6864:     PRInt32 count = list->GetInsertionPointCount();
 6864:     for (PRInt32 i = 0; i < count; ++i) {
 6864:       nsRefPtr<nsXBLInsertionPoint> currPoint = list->GetInsertionPointAt(i);
10861:       currPoint->UnbindDefaultContent();
 6864: #ifdef DEBUG
 6864:       nsCOMPtr<nsIContent> parent = currPoint->GetInsertionParent();
 6864:       NS_ASSERTION(!parent || parent == aParent, "Wrong insertion parent!");
 6864: #endif
 6864:       currPoint->ClearInsertionParent();
 6864:     }
19130:     NS_RELEASE(list);
 6864:   }
 6864: }
 6864: 
 6864: void
 6864: nsBindingManager::RemoveInsertionParent(nsIContent* aParent)
 6864: {
 6864:   nsCOMPtr<nsIDOMNodeList> contentlist;
 6864:   GetContentListFor(aParent, getter_AddRefs(contentlist));
 6864:   RemoveInsertionParentForNodeList(contentlist, aParent);
 6864: 
 6864:   nsCOMPtr<nsIDOMNodeList> anonnodes;
 6864:   GetAnonymousNodesFor(aParent, getter_AddRefs(anonnodes));
 6864:   RemoveInsertionParentForNodeList(anonnodes, aParent);
 6864: 
 6864:   if (mInsertionParentTable.ops) {
 6864:     PL_DHashTableEnumerate(&mInsertionParentTable, RemoveInsertionParentCB,
 6864:                            static_cast<nsISupports*>(aParent));
 6864:   }
 6864: }
 6864: 
    1: nsXBLBinding*
    1: nsBindingManager::GetBinding(nsIContent* aContent)
    1: {
 1376:   if (aContent && aContent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR) &&
 1376:       mBindingTable.IsInitialized()) {
    1:     return mBindingTable.GetWeak(aContent);
 1376:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::SetBinding(nsIContent* aContent, nsXBLBinding* aBinding)
    1: {
    1:   if (!mBindingTable.IsInitialized()) {
    1:     if (!mBindingTable.Init())
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // After this point, aBinding will be the most-derived binding for aContent.
    1:   // If we already have a binding for aContent in our table, make sure to
    1:   // remove it from the attached stack.  Otherwise we might end up firing its
    1:   // constructor twice (if aBinding inherits from it) or firing its constructor
    1:   // after aContent has been deleted (if aBinding is null and the content node
    1:   // dies before we process mAttachedStack).
 6864:   nsRefPtr<nsXBLBinding> oldBinding = GetBinding(aContent);
    1:   if (oldBinding) {
 6864:     if (aContent->HasFlag(NODE_IS_INSERTION_PARENT)) {
 6864:       nsRefPtr<nsXBLBinding> parentBinding =
 6864:         GetBinding(aContent->GetBindingParent());
 6864:       // Clear insertion parent only if we don't have a parent binding which
 6864:       // marked content to be an insertion parent. See also ChangeDocumentFor().
 6864:       if (!parentBinding || !parentBinding->HasInsertionParent(aContent)) {
 6864:         RemoveInsertionParent(aContent);
 6864:         aContent->UnsetFlags(NODE_IS_INSERTION_PARENT);
 6864:       }
 6864:     }
 7274:     // Don't remove items here as that could mess up an executing
 7274:     // ProcessAttachedQueue
 7274:     PRUint32 index = mAttachedStack.IndexOf(oldBinding);
 7274:     if (index != mAttachedStack.NoIndex) {
 7274:       mAttachedStack[index] = nsnull;
 7274:     }
    1:   }
    1:   
    1:   PRBool result = PR_TRUE;
    1: 
    1:   if (aBinding) {
 1376:     aContent->SetFlags(NODE_MAY_BE_IN_BINDING_MNGR);
    1:     result = mBindingTable.Put(aContent, aBinding);
    1:   } else {
    1:     mBindingTable.Remove(aContent);
    1: 
    1:     // The death of the bindings means the death of the JS wrapper,
    1:     // and the flushing of our explicit and anonymous insertion point
    1:     // lists.
    1:     SetWrappedJS(aContent, nsnull);
    1:     SetContentListFor(aContent, nsnull);
    1:     SetAnonymousNodesFor(aContent, nsnull);
    1:   }
    1: 
    1:   return result ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsIContent*
    1: nsBindingManager::GetInsertionParent(nsIContent* aContent)
    1: { 
    1:   if (mInsertionParentTable.ops) {
 3233:     return static_cast<nsIContent*>
 3233:                       (LookupObject(mInsertionParentTable, aContent));
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::SetInsertionParent(nsIContent* aContent, nsIContent* aParent)
    1: {
 6864:   NS_ASSERTION(!aParent || aParent->HasFlag(NODE_IS_INSERTION_PARENT),
 6864:                "Insertion parent should have NODE_IS_INSERTION_PARENT flag!");
 8681: 
 8681:   if (mDestroyed) {
 8681:     return NS_OK;
 8681:   }
 8681: 
    1:   return SetOrRemoveObject(mInsertionParentTable, aContent, aParent);
    1: }
    1: 
    1: nsIXPConnectWrappedJS*
    1: nsBindingManager::GetWrappedJS(nsIContent* aContent)
    1: { 
    1:   if (mWrapperTable.ops) {
 3233:     return static_cast<nsIXPConnectWrappedJS*>(LookupObject(mWrapperTable, aContent));
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::SetWrappedJS(nsIContent* aContent, nsIXPConnectWrappedJS* aWrappedJS)
    1: {
 8681:   if (mDestroyed) {
 8681:     return NS_OK;
 8681:   }
 8681: 
    1:   return SetOrRemoveObject(mWrapperTable, aContent, aWrappedJS);
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::ChangeDocumentFor(nsIContent* aContent, nsIDocument* aOldDocument,
    1:                                     nsIDocument* aNewDocument)
    1: {
    1:   // XXXbz this code is pretty broken, since moving from one document
    1:   // to another always passes through a null document!
    1:   NS_PRECONDITION(aOldDocument != nsnull, "no old document");
    1:   NS_PRECONDITION(!aNewDocument,
    1:                   "Changing to a non-null new document not supported yet");
    1:   if (! aOldDocument)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Hold a ref to the binding so it won't die when we remove it from our
    1:   // table.
    1:   nsRefPtr<nsXBLBinding> binding = GetBinding(aContent);
 6864:   if (aContent->HasFlag(NODE_IS_INSERTION_PARENT)) {
 6864:     nsRefPtr<nsXBLBinding> parentBinding = GetBinding(aContent->GetBindingParent());
 6864:     if (parentBinding) {
 6864:       parentBinding->RemoveInsertionParent(aContent);
 6864:       // Clear insertion parent only if we don't have a binding which
 6864:       // marked content to be an insertion parent. See also SetBinding().
 6864:       if (!binding || !binding->HasInsertionParent(aContent)) {
 6864:         RemoveInsertionParent(aContent);
 6864:         aContent->UnsetFlags(NODE_IS_INSERTION_PARENT);
 6864:       }
 6864:     }
 6864:   }
 6864: 
    1:   if (binding) {
    1:     binding->ChangeDocument(aOldDocument, aNewDocument);
    1:     SetBinding(aContent, nsnull);
    1:     if (aNewDocument)
    1:       aNewDocument->BindingManager()->SetBinding(aContent, binding);
    1:   }
    1: 
    1:   // Clear out insertion parents and content lists.
    1:   SetInsertionParent(aContent, nsnull);
    1:   SetContentListFor(aContent, nsnull);
    1:   SetAnonymousNodesFor(aContent, nsnull);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsBindingManager::ResolveTag(nsIContent* aContent, PRInt32* aNameSpaceID)
    1: {
    1:   nsXBLBinding *binding = GetBinding(aContent);
    1:   
    1:   if (binding) {
    1:     nsIAtom* base = binding->GetBaseTag(aNameSpaceID);
    1: 
    1:     if (base) {
    1:       return base;
    1:     }
    1:   }
    1: 
    1:   *aNameSpaceID = aContent->GetNameSpaceID();
    1:   return aContent->Tag();
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::GetContentListFor(nsIContent* aContent, nsIDOMNodeList** aResult)
    1: { 
    1:   *aResult = nsnull;
    1:   
    1:   if (mContentListTable.ops) {
24403:     *aResult = static_cast<nsAnonymousContentList*>
 3233:                           (LookupObject(mContentListTable, aContent));
    1:     NS_IF_ADDREF(*aResult);
    1:   }
    1:   
    1:   if (!*aResult) {
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aContent));
    1:     node->GetChildNodes(aResult);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::SetContentListFor(nsIContent* aContent,
    1:                                     nsInsertionPointList* aList)
    1: {
 8681:   if (mDestroyed) {
 8681:     return NS_OK;
 8681:   }
 8681: 
24403:   nsAnonymousContentList* contentList = nsnull;
    1:   if (aList) {
    1:     contentList = new nsAnonymousContentList(aList);
    1:     if (!contentList) {
    1:       delete aList;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   return SetOrRemoveObject(mContentListTable, aContent, contentList);
    1: }
    1: 
    1: PRBool
    1: nsBindingManager::HasContentListFor(nsIContent* aContent)
    1: {
    1:   return mContentListTable.ops && LookupObject(mContentListTable, aContent);
    1: }
    1: 
24403: nsINodeList*
    1: nsBindingManager::GetAnonymousNodesInternal(nsIContent* aContent,
    1:                                             PRBool* aIsAnonymousContentList)
    1: { 
24403:   nsINodeList* result = nsnull;
    1:   if (mAnonymousNodesTable.ops) {
24403:     result = static_cast<nsAnonymousContentList*>
 3233:                         (LookupObject(mAnonymousNodesTable, aContent));
    1:   }
    1: 
24403:   if (!result) {
    1:     *aIsAnonymousContentList = PR_FALSE;
    1:     nsXBLBinding *binding = GetBinding(aContent);
    1:     if (binding) {
24403:       result = binding->GetAnonymousNodes();
    1:     }
    1:   } else
    1:     *aIsAnonymousContentList = PR_TRUE;
    1: 
24403:   return result;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::GetAnonymousNodesFor(nsIContent* aContent,
    1:                                        nsIDOMNodeList** aResult)
    1: {
    1:   PRBool dummy;
24403:   NS_IF_ADDREF(*aResult = GetAnonymousNodesInternal(aContent, &dummy));
24403:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::SetAnonymousNodesFor(nsIContent* aContent,
    1:                                        nsInsertionPointList* aList)
    1: {
 8681:   if (mDestroyed) {
 8681:     return NS_OK;
 8681:   }
 8681: 
24403:   nsAnonymousContentList* contentList = nsnull;
    1:   if (aList) {
    1:     contentList = new nsAnonymousContentList(aList);
    1:     if (!contentList) {
    1:       delete aList;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   return SetOrRemoveObject(mAnonymousNodesTable, aContent, contentList);
    1: }
    1: 
24403: nsINodeList*
    1: nsBindingManager::GetXBLChildNodesInternal(nsIContent* aContent,
    1:                                            PRBool* aIsAnonymousContentList)
    1: {
    1:   PRUint32 length;
    1: 
    1:   // Retrieve the anonymous content that we should build.
24403:   nsINodeList* result = GetAnonymousNodesInternal(aContent,
    1:                                                   aIsAnonymousContentList);
    1:   if (result) {
    1:     result->GetLength(&length);
    1:     if (length == 0)
    1:       result = nsnull;
    1:   }
    1:     
    1:   // We may have an altered list of children from XBL insertion points.
    1:   // If we don't have any anonymous kids, we next check to see if we have 
    1:   // insertion points.
    1:   if (!result) {
    1:     if (mContentListTable.ops) {
24403:       result = static_cast<nsAnonymousContentList*>
 3233:                           (LookupObject(mContentListTable, aContent));
    1:       *aIsAnonymousContentList = PR_TRUE;
    1:     }
    1:   }
    1: 
24403:   return result;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::GetXBLChildNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult)
    1: {
24403:   NS_IF_ADDREF(*aResult = GetXBLChildNodesFor(aContent));
24403:   return NS_OK;
24403: }
24403: 
24403: nsINodeList*
24403: nsBindingManager::GetXBLChildNodesFor(nsIContent* aContent)
24403: {
    1:   PRBool dummy;
24403:   return GetXBLChildNodesInternal(aContent, &dummy);
    1: }
    1: 
    1: nsIContent*
    1: nsBindingManager::GetInsertionPoint(nsIContent* aParent, nsIContent* aChild,
    1:                                     PRUint32* aIndex)
    1: {
    1:   nsXBLBinding *binding = GetBinding(aParent);
    1:   return binding ? binding->GetInsertionPoint(aChild, aIndex) : nsnull;
    1: }
    1: 
    1: nsIContent*
    1: nsBindingManager::GetSingleInsertionPoint(nsIContent* aParent,
    1:                                           PRUint32* aIndex,
    1:                                           PRBool* aMultipleInsertionPoints)
    1: {
    1:   nsXBLBinding *binding = GetBinding(aParent);
    1:   if (binding)
    1:     return binding->GetSingleInsertionPoint(aIndex, aMultipleInsertionPoints);
    1: 
    1:   *aMultipleInsertionPoints = PR_FALSE;
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
 3645: nsBindingManager::AddLayeredBinding(nsIContent* aContent, nsIURI* aURL,
 3645:                                     nsIPrincipal* aOriginPrincipal)
    1: {
    1:   // First we need to load our binding.
    1:   nsresult rv;
    1:   nsCOMPtr<nsIXBLService> xblService = 
    1:            do_GetService("@mozilla.org/xbl;1", &rv);
    1:   if (!xblService)
    1:     return rv;
    1: 
    1:   // Load the bindings.
    1:   nsRefPtr<nsXBLBinding> binding;
    1:   PRBool dummy;
 3645:   xblService->LoadBindings(aContent, aURL, aOriginPrincipal, PR_TRUE,
 3645:                            getter_AddRefs(binding), &dummy);
    1:   if (binding) {
    1:     AddToAttachedQueue(binding);
    1:     ProcessAttachedQueue();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::RemoveLayeredBinding(nsIContent* aContent, nsIURI* aURL)
    1: {
    1:   // Hold a ref to the binding so it won't die when we remove it from our table
    1:   nsRefPtr<nsXBLBinding> binding = GetBinding(aContent);
    1:   
    1:   if (!binding) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // For now we can only handle removing a binding if it's the only one
    1:   NS_ENSURE_FALSE(binding->GetBaseBinding(), NS_ERROR_FAILURE);
    1: 
    1:   // Make sure that the binding has the URI that is requested to be removed
34526:   if (!binding->PrototypeBinding()->CompareBindingURI(aURL)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Make sure it isn't a style binding
    1:   if (binding->IsStyleBinding()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Hold strong ref in case removing the binding tries to close the
    1:   // window or something.
    1:   // XXXbz should that be ownerdoc?  Wouldn't we need a ref to the
    1:   // currentdoc too?  What's the one that should be passed to
    1:   // ChangeDocument?
    1:   nsCOMPtr<nsIDocument> doc = aContent->GetOwnerDoc();
    1:   NS_ASSERTION(doc, "No owner document?");
    1:   
    1:   // Finally remove the binding...
 8069:   // XXXbz this doesn't remove the implementation!  Should fix!  Until
 8069:   // then we need the explicit UnhookEventHandlers here.
    1:   binding->UnhookEventHandlers();
    1:   binding->ChangeDocument(doc, nsnull);
    1:   SetBinding(aContent, nsnull);
    1:   binding->MarkForDeath();
    1:   
24112:   // ...and recreate its frames. We need to do this since the frames may have
    1:   // been removed and style may have changed due to the removal of the
    1:   // anonymous children.
    1:   // XXXbz this should be using the current doc (if any), not the owner doc.
  981:   nsIPresShell *presShell = doc->GetPrimaryShell();
    1:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:   return presShell->RecreateFramesFor(aContent);;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::LoadBindingDocument(nsIDocument* aBoundDoc,
 3645:                                       nsIURI* aURL,
 3645:                                       nsIPrincipal* aOriginPrincipal)
    1: {
    1:   NS_PRECONDITION(aURL, "Must have a URI to load!");
    1:   
    1:   // First we need to load our binding.
    1:   nsresult rv;
    1:   nsCOMPtr<nsIXBLService> xblService = 
    1:            do_GetService("@mozilla.org/xbl;1", &rv);
    1:   if (!xblService)
    1:     return rv;
    1: 
    1:   // Load the binding doc.
    1:   nsCOMPtr<nsIXBLDocumentInfo> info;
    1:   xblService->LoadBindingDocumentInfo(nsnull, aBoundDoc, aURL,
 3645:                                       aOriginPrincipal, PR_TRUE,
 3645:                                       getter_AddRefs(info));
    1:   if (!info)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::AddToAttachedQueue(nsXBLBinding* aBinding)
    1: {
    1:   if (!mAttachedStack.AppendElement(aBinding))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // If we're in the middle of processing our queue already, don't
    1:   // bother posting the event.
    1:   if (!mProcessingAttachedStack && !mProcessAttachedQueueEvent) {
 8670:     PostProcessAttachedQueueEvent();
 8670:   }
 8670: 
 8670:   return NS_OK;
 8670: 
 8670: }
 8670: 
 8670: void
 8670: nsBindingManager::PostProcessAttachedQueueEvent()
 8670: {
    1:   mProcessAttachedQueueEvent =
24565:     NS_NEW_RUNNABLE_METHOD(nsBindingManager, this, DoProcessAttachedQueue);
 6627:   nsresult rv = NS_DispatchToCurrentThread(mProcessAttachedQueueEvent);
 6627:   if (NS_SUCCEEDED(rv) && mDocument) {
 6627:     mDocument->BlockOnload();
 6627:   }
    1: }
    1: 
    1: void
    1: nsBindingManager::DoProcessAttachedQueue()
    1: {
 8670:   if (!mProcessingAttachedStack) {
    1:     ProcessAttachedQueue();
    1: 
    1:     NS_ASSERTION(mAttachedStack.Length() == 0,
    1:                "Shouldn't have pending bindings!");
    1:   
    1:     mProcessAttachedQueueEvent = nsnull;
 8670:   } else {
 8670:     // Someone's doing event processing from inside a constructor.
 8670:     // They're evil, but we'll fight back!  Just poll on them being
 8670:     // done and repost the attached queue event.
 8670:     PostProcessAttachedQueueEvent();
 8670:   }
 6627: 
 8670:   // No matter what, unblock onload for the event that's fired.
 6627:   if (mDocument) {
 7240:     // Hold a strong reference while calling UnblockOnload since that might
 7240:     // run script.
 7240:     nsCOMPtr<nsIDocument> doc = mDocument;
 7240:     doc->UnblockOnload(PR_TRUE);
 6627:   }
    1: }
    1: 
    1: void
 7274: nsBindingManager::ProcessAttachedQueue(PRUint32 aSkipSize)
    1: {
 7274:   if (mProcessingAttachedStack || mAttachedStack.Length() <= aSkipSize)
    1:     return;
    1: 
    1:   mProcessingAttachedStack = PR_TRUE;
    1: 
13098:   // Excute constructors. Do this from high index to low
 7274:   while (mAttachedStack.Length() > aSkipSize) {
13098:     PRUint32 lastItem = mAttachedStack.Length() - 1;
13098:     nsRefPtr<nsXBLBinding> binding = mAttachedStack.ElementAt(lastItem);
13098:     mAttachedStack.RemoveElementAt(lastItem);
 7274:     if (binding) {
    1:       binding->ExecuteAttachedHandler();
    1:     }
 7274:   }
    1: 
 7274:   // If NodeWillBeDestroyed has run we don't want to clobber
 7274:   // mProcessingAttachedStack set there.
 7274:   if (mDocument) {
    1:     mProcessingAttachedStack = PR_FALSE;
 7274:   }
    1: 
 7274:   NS_ASSERTION(mAttachedStack.Length() == aSkipSize, "How did we get here?");
    1:   
    1:   mAttachedStack.Compact();
    1: }
    1: 
 4876: // Keep bindings and bound elements alive while executing detached handlers.
 4876: struct BindingTableReadClosure
 4876: {
 4876:   nsCOMArray<nsIContent> mBoundElements;
 4876:   nsBindingList          mBindings;
 4876: };
 4876: 
20261: static PLDHashOperator
    1: AccumulateBindingsToDetach(nsISupports *aKey, nsXBLBinding *aBinding,
 4876:                            void* aClosure)
    1:  {
 4876:   BindingTableReadClosure* closure =
 4876:     static_cast<BindingTableReadClosure*>(aClosure);
 4876:   if (aBinding && closure->mBindings.AppendElement(aBinding)) {
 4876:     if (!closure->mBoundElements.AppendObject(aBinding->GetBoundElement())) {
 4876:       closure->mBindings.RemoveElementAt(closure->mBindings.Length() - 1);
 4876:     }
 4876:   }
 2836:   return PL_DHASH_NEXT;
 2835: }
 2836: 
    1: void
    1: nsBindingManager::ExecuteDetachedHandlers()
    1: {
    1:   // Walk our hashtable of bindings.
    1:   if (mBindingTable.IsInitialized()) {
 4876:     BindingTableReadClosure closure;
 4876:     mBindingTable.EnumerateRead(AccumulateBindingsToDetach, &closure);
 4876:     PRUint32 i, count = closure.mBindings.Length();
 4876:     for (i = 0; i < count; ++i) {
 4876:       closure.mBindings[i]->ExecuteDetachedHandler();
 4876:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::PutXBLDocumentInfo(nsIXBLDocumentInfo* aDocumentInfo)
    1: {
    1:   NS_PRECONDITION(aDocumentInfo, "Must have a non-null documentinfo!");
    1:   
    1:   NS_ENSURE_TRUE(mDocumentTable.IsInitialized() || mDocumentTable.Init(16),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ENSURE_TRUE(mDocumentTable.Put(aDocumentInfo->DocumentURI(),
    1:                                     aDocumentInfo),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsBindingManager::RemoveXBLDocumentInfo(nsIXBLDocumentInfo* aDocumentInfo)
    1: {
    1:   if (mDocumentTable.IsInitialized()) {
    1:     mDocumentTable.Remove(aDocumentInfo->DocumentURI());
    1:   }
    1: }
    1: 
    1: nsIXBLDocumentInfo*
    1: nsBindingManager::GetXBLDocumentInfo(nsIURI* aURL)
    1: {
    1:   if (!mDocumentTable.IsInitialized())
    1:     return nsnull;
    1: 
    1:   return mDocumentTable.GetWeak(aURL);
    1: }
    1: 
    1: nsresult
    1: nsBindingManager::PutLoadingDocListener(nsIURI* aURL, nsIStreamListener* aListener)
    1: {
    1:   NS_PRECONDITION(aListener, "Must have a non-null listener!");
    1:   
    1:   NS_ENSURE_TRUE(mLoadingDocTable.IsInitialized() || mLoadingDocTable.Init(16),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1:   
    1:   NS_ENSURE_TRUE(mLoadingDocTable.Put(aURL, aListener),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIStreamListener*
    1: nsBindingManager::GetLoadingDocListener(nsIURI* aURL)
    1: {
    1:   if (!mLoadingDocTable.IsInitialized())
    1:     return nsnull;
    1: 
    1:   return mLoadingDocTable.GetWeak(aURL);
    1: }
    1: 
    1: void
    1: nsBindingManager::RemoveLoadingDocListener(nsIURI* aURL)
    1: {
    1:   if (mLoadingDocTable.IsInitialized()) {
    1:     mLoadingDocTable.Remove(aURL);
    1:   }
    1: }
    1: 
20261: static PLDHashOperator
    1: MarkForDeath(nsISupports *aKey, nsXBLBinding *aBinding, void* aClosure)
    1: {
    1:   if (aBinding->MarkedForDeath())
    1:     return PL_DHASH_NEXT; // Already marked for death.
    1: 
    1:   nsCAutoString path;
    1:   aBinding->PrototypeBinding()->DocURI()->GetPath(path);
    1: 
    1:   if (!strncmp(path.get(), "/skin", 5))
    1:     aBinding->MarkForDeath();
    1:   
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsBindingManager::FlushSkinBindings()
    1: {
    1:   if (mBindingTable.IsInitialized())
    1:     mBindingTable.EnumerateRead(MarkForDeath, nsnull);
    1: }
    1: 
    1: // Used below to protect from recurring in QI calls through XPConnect.
    1: struct AntiRecursionData {
    1:   nsIContent* element; 
    1:   REFNSIID iid; 
    1:   AntiRecursionData* next;
    1: 
    1:   AntiRecursionData(nsIContent* aElement, 
    1:                     REFNSIID aIID, 
    1:                     AntiRecursionData* aNext)
    1:     : element(aElement), iid(aIID), next(aNext) {}
    1: };
    1: 
    1: nsresult
    1: nsBindingManager::GetBindingImplementation(nsIContent* aContent, REFNSIID aIID,
    1:                                            void** aResult)
    1: {
    1:   *aResult = nsnull;
    1:   nsXBLBinding *binding = GetBinding(aContent);
    1:   if (binding) {
    1:     // The binding should not be asked for nsISupports
    1:     NS_ASSERTION(!aIID.Equals(NS_GET_IID(nsISupports)), "Asking a binding for nsISupports");
    1:     if (binding->ImplementsInterface(aIID)) {
    1:       nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS = GetWrappedJS(aContent);
    1: 
    1:       if (wrappedJS) {
    1:         // Protect from recurring in QI calls through XPConnect. 
    1:         // This can happen when a second binding is being resolved.
    1:         // At that point a wrappedJS exists, but it doesn't yet know about
    1:         // the iid we are asking for. So, without this protection, 
    1:         // AggregatedQueryInterface would end up recurring back into itself
    1:         // through this code. 
    1:         //
    1:         // With this protection, when we detect the recursion we return 
    1:         // NS_NOINTERFACE in the inner call. The outer call will then fall 
    1:         // through (see below) and build a new chained wrappedJS for the iid.
    1:         //
    1:         // We're careful to not assume that only one direct nesting can occur
    1:         // because there is a call into JS in the middle and we can't assume 
    1:         // that this code won't be reached by some more complex nesting path.
    1:         //
    1:         // NOTE: We *assume* this is single threaded, so we can use a
    1:         // static linked list to do the check.
    1: 
    1:         static AntiRecursionData* list = nsnull;
    1: 
    1:         for (AntiRecursionData* p = list; p; p = p->next) {
    1:           if (p->element == aContent && p->iid.Equals(aIID)) {
    1:             *aResult = nsnull;
    1:             return NS_NOINTERFACE;
    1:           }
    1:         }
    1: 
    1:         AntiRecursionData item(aContent, aIID, list);
    1:         list = &item;
    1: 
    1:         nsresult rv = wrappedJS->AggregatedQueryInterface(aIID, aResult);
    1:         
    1:         list = item.next;
    1:         
    1:         if (*aResult)
    1:           return rv;
    1:         
    1:         // No result was found, so this must be another XBL interface.
    1:         // Fall through to create a new wrapper.
    1:       }
    1: 
    1:       // We have never made a wrapper for this implementation.
    1:       // Create an XPC wrapper for the script object and hand it back.
    1: 
    1:       nsIDocument* doc = aContent->GetOwnerDoc();
    1:       if (!doc)
    1:         return NS_NOINTERFACE;
    1: 
    1:       nsIScriptGlobalObject *global = doc->GetScriptGlobalObject();
    1:       if (!global)
    1:         return NS_NOINTERFACE;
    1: 
    1:       nsIScriptContext *context = global->GetContext();
    1:       if (!context)
    1:         return NS_NOINTERFACE;
    1: 
    1:       JSContext* jscontext = (JSContext*)context->GetNativeContext();
    1:       if (!jscontext)
    1:         return NS_NOINTERFACE;
    1: 
    1:       nsIXPConnect *xpConnect = nsContentUtils::XPConnect();
    1: 
    1:       nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:       xpConnect->GetWrappedNativeOfNativeObject(jscontext,
    1:                                                 global->GetGlobalJSObject(),
    1:                                                 aContent,
    1:                                                 NS_GET_IID(nsISupports),
    1:                                                 getter_AddRefs(wrapper));
    1:       NS_ENSURE_TRUE(wrapper, NS_NOINTERFACE);
    1: 
    1:       JSObject* jsobj = nsnull;
    1: 
    1:       wrapper->GetJSObject(&jsobj);
    1:       NS_ENSURE_TRUE(jsobj, NS_NOINTERFACE);
    1: 
    1:       nsresult rv = xpConnect->WrapJSAggregatedToNative(aContent, jscontext,
    1:                                                         jsobj, aIID, aResult);
    1:       if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:       // We successfully created a wrapper.  We will own this wrapper for as long as the binding remains
    1:       // alive.  At the time the binding is cleared out of the bindingManager, we will remove the wrapper
    1:       // from the bindingManager as well.
 3233:       nsISupports* supp = static_cast<nsISupports*>(*aResult);
    1:       wrappedJS = do_QueryInterface(supp);
    1:       SetWrappedJS(aContent, wrappedJS);
    1: 
    1:       return rv;
    1:     }
    1:   }
    1:   
    1:   *aResult = nsnull;
    1:   return NS_NOINTERFACE;
    1: }
    1: 
    1: nsresult
16231: nsBindingManager::WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc,
    1:                             RuleProcessorData* aData,
    1:                             PRBool* aCutOffInheritance)
    1: {
    1:   *aCutOffInheritance = PR_FALSE;
    1:   
    1:   if (!aData->mContent)
    1:     return NS_OK;
    1: 
    1:   // Walk the binding scope chain, starting with the binding attached to our
    1:   // content, up till we run out of scopes or we get cut off.
    1:   nsIContent *content = aData->mContent;
    1:   
    1:   do {
    1:     nsXBLBinding *binding = GetBinding(content);
    1:     if (binding) {
    1:       aData->mScopedRoot = content;
    1:       binding->WalkRules(aFunc, aData);
    1:       // If we're not looking at our original content, allow the binding to cut
    1:       // off style inheritance
    1:       if (content != aData->mContent) {
    1:         if (!binding->InheritsStyle()) {
    1:           // Go no further; we're not inheriting style from anything above here
    1:           break;
    1:         }
    1:       }
    1:     }
    1: 
16126:     if (content->IsRootOfNativeAnonymousSubtree()) {
16126:       break; // Deliberately cut off style inheritance here.
 1111:     }
    1: 
16126:     content = content->GetBindingParent();
    1:   } while (content);
    1: 
    1:   // If "content" is non-null that means we cut off inheritance at some point
    1:   // in the loop.
    1:   *aCutOffInheritance = (content != nsnull);
    1: 
    1:   // Null out the scoped root that we set repeatedly
    1:   aData->mScopedRoot = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
16231: typedef nsTHashtable<nsVoidPtrHashKey> RuleProcessorSet;
16231: 
20261: static PLDHashOperator
16231: EnumRuleProcessors(nsISupports *aKey, nsXBLBinding *aBinding, void* aClosure)
16231: {
16231:   RuleProcessorSet *set = static_cast<RuleProcessorSet*>(aClosure);
16231:   for (nsXBLBinding *binding = aBinding; binding;
16231:        binding = binding->GetBaseBinding()) {
16231:     nsIStyleRuleProcessor *ruleProc =
16231:       binding->PrototypeBinding()->GetRuleProcessor();
16231:     if (ruleProc) {
16231:       if (!set->IsInitialized() && !set->Init(16))
16231:         return PL_DHASH_STOP;
16231:       set->PutEntry(ruleProc);
16231:     }
16231:   }
16231:   return PL_DHASH_NEXT;
16231: }
16231: 
16231: struct MediumFeaturesChangedData {
16231:   nsPresContext *mPresContext;
16231:   PRBool *mRulesChanged;
16231: };
16231: 
20261: static PLDHashOperator
16231: EnumMediumFeaturesChanged(nsVoidPtrHashKey *aKey, void* aClosure)
16231: {
16231:   nsIStyleRuleProcessor *ruleProcessor =
16231:     static_cast<nsIStyleRuleProcessor*>(const_cast<void*>(aKey->GetKey()));
16231:   MediumFeaturesChangedData *data =
16231:     static_cast<MediumFeaturesChangedData*>(aClosure);
16231: 
16231:   PRBool thisChanged = PR_FALSE;
16231:   ruleProcessor->MediumFeaturesChanged(data->mPresContext, &thisChanged);
16231:   *data->mRulesChanged = *data->mRulesChanged || thisChanged;
16231: 
16231:   return PL_DHASH_NEXT;
16231: }
16231: 
16231: nsresult
16231: nsBindingManager::MediumFeaturesChanged(nsPresContext* aPresContext,
16231:                                         PRBool* aRulesChanged)
16231: {
16231:   *aRulesChanged = PR_FALSE;
16231:   if (!mBindingTable.IsInitialized())
16231:     return NS_OK;
16231: 
16231:   RuleProcessorSet set;
16231:   mBindingTable.EnumerateRead(EnumRuleProcessors, &set);
16231:   if (!set.IsInitialized())
16231:     return NS_OK;
16231: 
16231:   MediumFeaturesChangedData data = { aPresContext, aRulesChanged };
16231:   set.EnumerateEntries(EnumMediumFeaturesChanged, &data);
16231:   return NS_OK;
16231: }
16231: 
    1: nsIContent*
    1: nsBindingManager::GetNestedInsertionPoint(nsIContent* aParent, nsIContent* aChild)
    1: {
    1:   // Check to see if the content is anonymous.
    1:   if (aChild->GetBindingParent() == aParent)
    1:     return nsnull; // It is anonymous. Don't use the insertion point, since that's only
    1:                    // for the explicit kids.
    1: 
    1:   PRUint32 index;
    1:   nsIContent *insertionElement = GetInsertionPoint(aParent, aChild, &index);
 8198:   if (insertionElement && insertionElement != aParent) {
    1:     // See if we nest even further in.
    1:     nsIContent* nestedPoint = GetNestedInsertionPoint(insertionElement, aChild);
    1:     if (nestedPoint)
    1:       insertionElement = nestedPoint;
    1:   }
    1: 
    1:   return insertionElement;
    1: }
    1: 
 8198: nsIContent*
 8198: nsBindingManager::GetNestedSingleInsertionPoint(nsIContent* aParent,
 8198:                                                 PRBool* aMultipleInsertionPoints)
 8198: {
 8198:   *aMultipleInsertionPoints = PR_FALSE;
 8198:   
 8198:   PRUint32 index;
 8198:   nsIContent *insertionElement =
 8198:     GetSingleInsertionPoint(aParent, &index, aMultipleInsertionPoints);
 8198:   if (*aMultipleInsertionPoints) {
 8198:     return nsnull;
 8198:   }
 8198:   if (insertionElement && insertionElement != aParent) {
 8198:     // See if we nest even further in.
 8198:     nsIContent* nestedPoint =
 8198:       GetNestedSingleInsertionPoint(insertionElement,
 8198:                                     aMultipleInsertionPoints);
 8198:     if (nestedPoint)
 8198:       insertionElement = nestedPoint;
 8198:   }
 8198: 
 8198:   return insertionElement;
 8198: }
 8198: 
27088: nsXBLInsertionPoint*
27088: nsBindingManager::FindInsertionPointAndIndex(nsIContent* aContainer,
27088:                                              nsIContent* aInsertionParent,
27088:                                              PRUint32 aIndexInContainer,
27088:                                              PRInt32 aAppend,
27088:                                              PRInt32* aInsertionIndex)
27088: {
27088:   PRBool isAnonymousContentList;
27088:   nsINodeList* nodeList =
27088:     GetXBLChildNodesInternal(aInsertionParent, &isAnonymousContentList);
27088:   if (!nodeList || !isAnonymousContentList) {
27088:     return nsnull;
27088:   }
27088: 
27088:   // Find a non-pseudo-insertion point and just jam ourselves in.  This is
27088:   // not 100% correct, since there might be multiple insertion points under
27088:   // this insertion parent, and we should really be using the one that
27088:   // matches our content...  Hack city, baby.
27088:   nsAnonymousContentList* contentList =
27088:     static_cast<nsAnonymousContentList*>(nodeList);
27088: 
27088:   PRInt32 count = contentList->GetInsertionPointCount();
27088:   for (PRInt32 i = 0; i < count; i++) {
27088:     nsXBLInsertionPoint* point = contentList->GetInsertionPointAt(i);
27088:     if (point->GetInsertionIndex() != -1) {
27088:       // We're real. Jam the kid in.
27088: 
27088:       // Find the right insertion spot.  Can't just insert in the insertion
27088:       // point at aIndexInContainer since the point may contain anonymous
27088:       // content, not all of aContainer's kids, etc.  So find the last
27088:       // child of aContainer that comes before aIndexInContainer and is in
27088:       // the insertion point and insert right after it.
27088:       PRInt32 pointSize = point->ChildCount();
27088:       for (PRInt32 parentIndex = aIndexInContainer - 1; parentIndex >= 0;
27088:            --parentIndex) {
27088:         nsIContent* currentSibling = aContainer->GetChildAt(parentIndex);
27088:         for (PRInt32 pointIndex = pointSize - 1; pointIndex >= 0;
27088:              --pointIndex) {
27088:           if (point->ChildAt(pointIndex) == currentSibling) {
27088:             *aInsertionIndex = pointIndex + 1;
27088:             return point;
27088:           }
27088:         }
27088:       }
27088: 
27088:       // None of our previous siblings are in here... just stick
27088:       // ourselves in at the end of the insertion point if we're
27088:       // appending, and at the beginning otherwise.            
27088:       // XXXbz if we ever start doing the filter thing right, this may be no
27088:       // good, since we may _still_ have anonymous kids in there and may need
27088:       // to get the ordering with those right.  In fact, this is even wrong
27088:       // without the filter thing for nested insertion points, since they might
27088:       // contain anonymous content that needs to come after all explicit
27088:       // kids... but we have no way to know that here easily.
27088:       if (aAppend) {
27088:         *aInsertionIndex = pointSize;
27088:       } else {
27088:         *aInsertionIndex = 0;
27088:       }
27088:       return point;
27088:     }
27088:   }
27088: 
27088:   return nsnull;  
27088: }
27088: 
    1: void
    1: nsBindingManager::ContentAppended(nsIDocument* aDocument,
    1:                                   nsIContent* aContainer,
    1:                                   PRInt32     aNewIndexInContainer)
    1: {
  855:   if (aNewIndexInContainer != -1 &&
  855:       (mContentListTable.ops || mAnonymousNodesTable.ops)) {
    1:     // It's not anonymous.
27088:     NS_ASSERTION(aNewIndexInContainer >= 0, "Bogus index");
27088: 
 8040:     PRBool multiple;
 8198:     nsIContent* ins = GetNestedSingleInsertionPoint(aContainer, &multiple);
 8040: 
 8040:     if (multiple) {
 8040:       // Do each kid individually
    1:       PRInt32 childCount = aContainer->GetChildCount();
 8040:       for (PRInt32 idx = aNewIndexInContainer; idx < childCount; ++idx) {
 8040:         HandleChildInsertion(aContainer, aContainer->GetChildAt(idx),
 8040:                              idx, PR_TRUE);
 8040:       }
 8040:     }
 8040:     else if (ins) {
27088:       PRInt32 insertionIndex;
27088:       nsXBLInsertionPoint* point =
27088:         FindInsertionPointAndIndex(aContainer, ins, aNewIndexInContainer,
27088:                                    PR_TRUE, &insertionIndex);
27088:       if (point) {
 8040:         PRInt32 childCount = aContainer->GetChildCount();
27088:         for (PRInt32 j = aNewIndexInContainer; j < childCount;
27088:              j++, insertionIndex++) {
 8040:           nsIContent* child = aContainer->GetChildAt(j);
27088:           point->InsertChildAt(insertionIndex, child);
    1:           SetInsertionParent(child, ins);
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsBindingManager::ContentInserted(nsIDocument* aDocument,
    1:                                   nsIContent* aContainer,
    1:                                   nsIContent* aChild,
    1:                                   PRInt32 aIndexInContainer)
    1: {
  855:   if (aIndexInContainer != -1 &&
  855:       (mContentListTable.ops || mAnonymousNodesTable.ops)) {
    1:     // It's not anonymous.
 8040:     NS_ASSERTION(aIndexInContainer >= 0, "Bogus index");
 8040:     HandleChildInsertion(aContainer, aChild, aIndexInContainer, PR_FALSE);
    1:   }
    1: }
    1: 
10812: static void
10812: RemoveChildFromInsertionPoint(nsAnonymousContentList* aInsertionPointList,
10812:                               nsIContent* aChild,
10812:                               PRBool aRemoveFromPseudoPoints)
10812: {
10812:   // We need to find the insertion point that contains aChild and remove it
10812:   // from that insertion point.  Sadly, we don't know which point it is, or
10812:   // when we've hit it, but just trying to remove from all the pseudo or
10812:   // non-pseudo insertion points, depending on the value of
10812:   // aRemoveFromPseudoPoints, should work.
10812:   PRInt32 count = aInsertionPointList->GetInsertionPointCount();
10812:   for (PRInt32 i = 0; i < count; i++) {
10812:     nsXBLInsertionPoint* point =
10812:       aInsertionPointList->GetInsertionPointAt(i);
10812:     if ((point->GetInsertionIndex() == -1) == aRemoveFromPseudoPoints) {
10812:       point->RemoveChild(aChild);
10812:     }
10812:   }
10812: }
10812: 
    1: void
    1: nsBindingManager::ContentRemoved(nsIDocument* aDocument,
    1:                                  nsIContent* aContainer,
    1:                                  nsIContent* aChild,
    1:                                  PRInt32 aIndexInContainer)
    1: {
10812:   if (aContainer && aIndexInContainer != -1 &&
 2840:       (mContentListTable.ops || mAnonymousNodesTable.ops)) {
 2840:     // It's not anonymous
    1:     nsCOMPtr<nsIContent> point = GetNestedInsertionPoint(aContainer, aChild);
    1: 
    1:     if (point) {
    1:       PRBool isAnonymousContentList;
24403:       nsCOMPtr<nsIDOMNodeList> nodeList =
24403:         GetXBLChildNodesInternal(point, &isAnonymousContentList);
    1:       
    1:       if (nodeList && isAnonymousContentList) {
    1:         // Find a non-pseudo-insertion point and remove ourselves.
10812:         RemoveChildFromInsertionPoint(static_cast<nsAnonymousContentList*>
10812:                                         (static_cast<nsIDOMNodeList*>
10812:                                                     (nodeList)),
10812:                                       aChild,
10812:                                       PR_FALSE);
10812:         SetInsertionParent(aChild, nsnull);
    1:       }
    1:     }
10812: 
10812:     // Whether the child has a nested insertion point or not, aContainer might
10812:     // have insertion points under it.  If that's the case, we need to remove
10812:     // aChild from the pseudo insertion point it's in.
10812:     if (mContentListTable.ops) {
10812:       nsAnonymousContentList* insertionPointList =
24403:         static_cast<nsAnonymousContentList*>(LookupObject(mContentListTable,
24403:                                                           aContainer));
10812:       if (insertionPointList) {
10812:         RemoveChildFromInsertionPoint(insertionPointList, aChild, PR_TRUE);
    1:       }
    1:     }
    1:   }
 2840: }
 2840: 
    1: void
 8678: nsBindingManager::DropDocumentReference()
    1: {
    1:   // Make sure to not run any more XBL constructors
    1:   mProcessingAttachedStack = PR_TRUE;
24565:   if (mProcessAttachedQueueEvent) {
24565:     mProcessAttachedQueueEvent->Revoke();
24565:   }
30000: 
30000:   if (mContentListTable.ops)
30000:     PL_DHashTableFinish(&(mContentListTable));
30000:   mContentListTable.ops = nsnull;
30000: 
30000:   if (mAnonymousNodesTable.ops)
30000:     PL_DHashTableFinish(&(mAnonymousNodesTable));
30000:   mAnonymousNodesTable.ops = nsnull;
30000: 
30000:   if (mInsertionParentTable.ops)
30000:     PL_DHashTableFinish(&(mInsertionParentTable));
30000:   mInsertionParentTable.ops = nsnull;
30000: 
 6627:   mDocument = nsnull;
    1: }
    1: 
    1: void
    1: nsBindingManager::Traverse(nsIContent *aContent,
    1:                            nsCycleCollectionTraversalCallback &cb)
    1: {
 1376:   if (!aContent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
 1376:     return;
 1376:   }
 1376: 
13669:   nsISupports *value;
13669:   if (mInsertionParentTable.ops &&
13669:       (value = LookupObject(mInsertionParentTable, aContent))) {
13669:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mInsertionParentTable key");
13669:     cb.NoteXPCOMChild(aContent);
13669:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mInsertionParentTable value");
13669:     cb.NoteXPCOMChild(value);
13669:   }
13669: 
13669:   if (!aContent->IsNodeOfType(nsINode::eELEMENT)) {
13669:     return;
13669:   }
13669: 
    1:   nsXBLBinding *binding = GetBinding(aContent);
    1:   if (binding) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mBindingTable key");
    1:     cb.NoteXPCOMChild(aContent);
13202:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(binding, nsXBLBinding,
13202:                                   "[via binding manager] mBindingTable value")
    1:   }
    1:   if (mContentListTable.ops &&
    1:       (value = LookupObject(mContentListTable, aContent))) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mContentListTable key");
    1:     cb.NoteXPCOMChild(aContent);
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mContentListTable value");
    1:     cb.NoteXPCOMChild(value);
    1:   }
    1:   if (mAnonymousNodesTable.ops &&
    1:       (value = LookupObject(mAnonymousNodesTable, aContent))) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mAnonymousNodesTable key");
    1:     cb.NoteXPCOMChild(aContent);
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mAnonymousNodesTable value");
    1:     cb.NoteXPCOMChild(value);
    1:   }
    1:   if (mWrapperTable.ops &&
    1:       (value = LookupObject(mWrapperTable, aContent))) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mWrapperTable key");
    1:     cb.NoteXPCOMChild(aContent);
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[via binding manager] mWrapperTable value");
    1:     cb.NoteXPCOMChild(value);
    1:   }
    1: }
 2025: 
 2025: void
 2025: nsBindingManager::BeginOutermostUpdate()
 2025: {
 7274:   mAttachedStackSizeOnOutermost = mAttachedStack.Length();
 2025: }
 2025: 
 2025: void
 2025: nsBindingManager::EndOutermostUpdate()
 2025: {
 7274:   if (!mProcessingAttachedStack) {
 7274:     ProcessAttachedQueue(mAttachedStackSizeOnOutermost);
 7274:     mAttachedStackSizeOnOutermost = 0;
 2025:   }
 7274: }
 8040: 
 8040: void
 8040: nsBindingManager::HandleChildInsertion(nsIContent* aContainer,
 8040:                                        nsIContent* aChild,
 8040:                                        PRUint32 aIndexInContainer,
 8040:                                        PRBool aAppend)
 8040: {
 8040:   NS_PRECONDITION(aChild, "Must have child");
 8040:   NS_PRECONDITION(!aContainer ||
10812:                   PRUint32(aContainer->IndexOf(aChild)) == aIndexInContainer,
 8040:                   "Child not at the right index?");
 8040: 
 8040:   nsIContent* ins = GetNestedInsertionPoint(aContainer, aChild);
 8040: 
 8040:   if (ins) {
27088:     PRInt32 insertionIndex;
27088:     nsXBLInsertionPoint* point =
27088:       FindInsertionPointAndIndex(aContainer, ins, aIndexInContainer, aAppend,
27088:                                  &insertionIndex);
27088:     if (point) {
27088:       point->InsertChildAt(insertionIndex, aChild);
27088:       SetInsertionParent(aChild, ins);
 8040:     }
 8040:   }
 8040: }
