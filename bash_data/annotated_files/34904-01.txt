    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // NOTE: alphabetically ordered
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsAccessibilityService.h"
20521: #include "nsCoreUtils.h"
20536: #include "nsAccUtils.h"
31732: #include "nsApplicationAccessibleWrap.h"
29269: #include "nsARIAGridAccessibleWrap.h"
 7830: #include "nsARIAMap.h"
12240: #include "nsIContentViewer.h"
    1: #include "nsCURILoader.h"
    1: #include "nsDocAccessible.h"
 1306: #include "nsHTMLImageAccessibleWrap.h"
    1: #include "nsHTMLLinkAccessible.h"
    1: #include "nsHTMLSelectAccessible.h"
 1133: #include "nsHTMLTableAccessibleWrap.h"
    1: #include "nsHTMLTextAccessible.h"
  966: #include "nsHyperTextAccessibleWrap.h"
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleProvider.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLOptGroupElement.h"
    1: #include "nsIDOMHTMLOptionElement.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIFrame.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIImageFrame.h"
    1: #include "nsILink.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPluginInstance.h"
    1: #include "nsIPresShell.h"
    1: #include "nsISupportsUtils.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsObjectFrame.h"
    1: #include "nsOuterDocAccessible.h"
    1: #include "nsRootAccessibleWrap.h"
    1: #include "nsTextFragment.h"
    1: #include "nsPresContext.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsNetError.h"
    1: #include "nsDocShellLoadTypes.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsXULAlertAccessible.h"
    1: #include "nsXULColorPickerAccessible.h"
32381: #include "nsXULComboboxAccessible.h"
    1: #include "nsXULFormControlAccessible.h"
32381: #include "nsXULListboxAccessibleWrap.h"
    1: #include "nsXULMenuAccessibleWrap.h"
 4274: #include "nsXULSliderAccessible.h"
    1: #include "nsXULTabAccessible.h"
    1: #include "nsXULTextAccessible.h"
32381: #include "nsXULTreeGridAccessibleWrap.h"
    1: #endif
    1: 
    1: // For native window support for object/embed/applet tags
    1: #ifdef XP_WIN
    1: #include "nsHTMLWin32ObjectAccessible.h"
    1: #endif
    1: 
    1: #ifndef DISABLE_XFORMS_HOOKS
    1: #include "nsXFormsFormControlsAccessible.h"
    1: #include "nsXFormsWidgetsAccessible.h"
    1: #endif
    1: 
    1: nsAccessibilityService *nsAccessibilityService::gAccessibilityService = nsnull;
30820: PRBool nsAccessibilityService::gIsShutdown = PR_TRUE;
    1: 
    1: /**
    1:   * nsAccessibilityService
    1:   */
    1: 
    1: nsAccessibilityService::nsAccessibilityService()
    1: {
30820:   // Add observers.
    1:   nsCOMPtr<nsIObserverService> observerService = 
    1:     do_GetService("@mozilla.org/observer-service;1");
    1:   if (!observerService)
    1:     return;
    1: 
    1:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_FALSE);
    1:   nsCOMPtr<nsIWebProgress> progress(do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID));
    1:   if (progress) {
 3233:     progress->AddProgressListener(static_cast<nsIWebProgressListener*>(this),
34455:                                   nsIWebProgress::NOTIFY_STATE_DOCUMENT);
    1:   }
30820: 
30820:   // Initialize accessibility.
    1:   nsAccessNodeWrap::InitAccessibility();
    1: }
    1: 
    1: nsAccessibilityService::~nsAccessibilityService()
    1: {
30820:   NS_ASSERTION(gIsShutdown, "Accessibility wasn't shutdown!");
30820:   gAccessibilityService = nsnull;
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS5(nsAccessibilityService, nsIAccessibilityService, nsIAccessibleRetrieval,
    1:                               nsIObserver, nsIWebProgressListener, nsISupportsWeakReference)
    1: 
    1: // nsIObserver
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibilityService::Observe(nsISupports *aSubject, const char *aTopic,
    1:                          const PRUnichar *aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
30820: 
30820:     // Remove observers.
    1:     nsCOMPtr<nsIObserverService> observerService = 
    1:       do_GetService("@mozilla.org/observer-service;1");
    1:     if (observerService) {
    1:       observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
    1:     }
    1:     nsCOMPtr<nsIWebProgress> progress(do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID));
12240:     if (progress)
 3233:       progress->RemoveProgressListener(static_cast<nsIWebProgressListener*>(this));
30820: 
30820:     // Cancel and release load timers.
12240:     while (mLoadTimers.Count() > 0 ) {
12240:       nsCOMPtr<nsITimer> timer = mLoadTimers.ObjectAt(0);
12240:       void *closure = nsnull;
12240:       timer->GetClosure(&closure);
12240:       if (closure) {
12240:         nsIWebProgress *webProgress = static_cast<nsIWebProgress*>(closure);
12240:         NS_RELEASE(webProgress);  // Release nsIWebProgress for timer
    1:       }
12240:       timer->Cancel();
12240:       mLoadTimers.RemoveObjectAt(0);
12240:     }
30820: 
30820:     // Application is going to be closed, shutdown accessibility and mark
30820:     // accessibility service as shutdown to prevent calls of its methods.
30820:     // Don't null accessibility service static member at this point to be safe
30820:     // if someone will try to operate with it.
30820: 
30820:     NS_ASSERTION(!gIsShutdown, "Accessibility was shutdown already");
30820: 
30820:     gIsShutdown = PR_TRUE;
30820:     nsAccessNodeWrap::ShutdownAccessibility();
    1:   }
30820: 
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIWebProgressListener
    1: NS_IMETHODIMP nsAccessibilityService::OnStateChange(nsIWebProgress *aWebProgress,
    1:   nsIRequest *aRequest, PRUint32 aStateFlags, nsresult aStatus)
    1: {
    1:   NS_ASSERTION(aStateFlags & STATE_IS_DOCUMENT, "Other notifications excluded");
    1: 
30820:   if (gIsShutdown || !aWebProgress ||
30820:       (aStateFlags & (STATE_START | STATE_STOP)) == 0) {
    1:     return NS_OK;
    1:   }
    1:   
12240:   nsCAutoString name;
12240:   aRequest->GetName(name);
12240:   if (name.EqualsLiteral("about:blank"))
12240:     return NS_OK;
    1: 
12240:   if (NS_FAILED(aStatus) && (aStateFlags & STATE_START))
12240:     return NS_OK;
    1:  
12240:   nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
12240:   if (!timer)
11392:     return NS_OK;
12240:   mLoadTimers.AppendObject(timer);
12240:   NS_ADDREF(aWebProgress);
12240: 
12240:   if (aStateFlags & STATE_START)
12240:     timer->InitWithFuncCallback(StartLoadCallback, aWebProgress, 0,
12240:                                 nsITimer::TYPE_ONE_SHOT);
12240:   else if (NS_SUCCEEDED(aStatus)) 
12240:     timer->InitWithFuncCallback(EndLoadCallback, aWebProgress, 0,
12240:                                 nsITimer::TYPE_ONE_SHOT);
12240:   else // Failed end load
12240:     timer->InitWithFuncCallback(FailedLoadCallback, aWebProgress, 0,
12240:                                 nsITimer::TYPE_ONE_SHOT);
11392:   return NS_OK;
11392: }
11392: 
12240: NS_IMETHODIMP nsAccessibilityService::ProcessDocLoadEvent(nsITimer *aTimer, void *aClosure, PRUint32 aEventType)
12240: {
12240:   nsCOMPtr<nsIDOMWindow> domWindow;
12240:   nsIWebProgress *webProgress = static_cast<nsIWebProgress*>(aClosure);
12240:   webProgress->GetDOMWindow(getter_AddRefs(domWindow));
12240:   NS_RELEASE(webProgress);
12240:   mLoadTimers.RemoveObject(aTimer);
12240:   NS_ENSURE_STATE(domWindow);
12240: 
12240:   if (aEventType == nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_START) {
    1:     nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(domWindow));
    1:     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(webNav));
12240:     NS_ENSURE_STATE(docShell);
    1:     PRUint32 loadType;
    1:     docShell->GetLoadType(&loadType);
    1:     if (loadType == LOAD_RELOAD_NORMAL ||
    1:         loadType == LOAD_RELOAD_BYPASS_CACHE ||
    1:         loadType == LOAD_RELOAD_BYPASS_PROXY ||
    1:         loadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE) {
12240:       aEventType = nsIAccessibleEvent::EVENT_DOCUMENT_RELOAD;
    1:     }
    1:   }
    1:       
12240:   nsCOMPtr<nsIDOMDocument> domDoc;
12240:   domWindow->GetDocument(getter_AddRefs(domDoc));
12240:   nsCOMPtr<nsIDOMNode> docNode = do_QueryInterface(domDoc);
12240:   NS_ENSURE_STATE(docNode);
12240: 
12240:   nsCOMPtr<nsIAccessible> accessible;
12240:   GetAccessibleFor(docNode, getter_AddRefs(accessible));
29564:   nsRefPtr<nsDocAccessible> docAcc =
29564:     nsAccUtils::QueryAccessibleDocument(accessible);
29564:   NS_ENSURE_STATE(docAcc);
29564: 
29564:   docAcc->FireDocLoadEvents(aEventType);
12240: 
12240:   return NS_OK;
10998: }
    1: 
21255: NS_IMETHODIMP
34455: nsAccessibilityService::NotifyOfAnchorJumpTo(nsIContent *aTarget)
34455: {
34455:   nsCOMPtr<nsIDOMNode> targetNode(do_QueryInterface(aTarget));
34455: 
34455:   nsCOMPtr<nsIAccessible> targetAcc;
34455:   GetAccessibleFor(targetNode, getter_AddRefs(targetAcc));
34455: 
34455:   // If the jump target is not accessible then fire an event for nearest
34455:   // accessible in parent chain.
34455:   if (!targetAcc) {
34455:     nsIDocument *document = aTarget->GetCurrentDoc();
34455:     nsCOMPtr<nsIDOMNode> documentNode(do_QueryInterface(document));
34455:     if (documentNode) {
34455:       nsCOMPtr<nsIAccessibleDocument> accessibleDoc =
34455:         nsAccessNode::GetDocAccessibleFor(documentNode);
34455:       if (accessibleDoc)
34455:         accessibleDoc->GetAccessibleInParentChain(targetNode, PR_TRUE,
34455:                                                   getter_AddRefs(targetAcc));
34455:     }
34455:   }
34455: 
34455:   if (targetAcc)
34455:     return nsAccUtils::FireAccEvent(nsIAccessibleEvent::EVENT_SCROLLING_START,
34455:                                     targetAcc);
34455: 
34455:   return NS_OK;
34455: }
34455: 
34455: NS_IMETHODIMP
21255: nsAccessibilityService::FireAccessibleEvent(PRUint32 aEvent,
21255:                                             nsIAccessible *aTarget)
21255: {
21255:   return nsAccUtils::FireAccEvent(aEvent, aTarget);
21255: }
21255: 
12240: void nsAccessibilityService::StartLoadCallback(nsITimer *aTimer, void *aClosure)
12240: {
30820:   if (gAccessibilityService)
30820:     gAccessibilityService->
30820:       ProcessDocLoadEvent(aTimer, aClosure,
30820:                           nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_START);
12240: }
12240: 
12240: void nsAccessibilityService::EndLoadCallback(nsITimer *aTimer, void *aClosure)
12240: {
30820:   if (gAccessibilityService)
30820:     gAccessibilityService->
30820:       ProcessDocLoadEvent(aTimer, aClosure,
30820:                           nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE);
12240: }
12240: 
12240: void nsAccessibilityService::FailedLoadCallback(nsITimer *aTimer, void *aClosure)
12240: {
30820:   if (gAccessibilityService)
30820:     gAccessibilityService->
30820:       ProcessDocLoadEvent(aTimer, aClosure,
30820:                           nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_STOPPED);
    1: }
    1: 
    1: /* void onProgressChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in long aCurSelfProgress, in long aMaxSelfProgress, in long aCurTotalProgress, in long aMaxTotalProgress); */
    1: NS_IMETHODIMP nsAccessibilityService::OnProgressChange(nsIWebProgress *aWebProgress,
    1:   nsIRequest *aRequest, PRInt32 aCurSelfProgress, PRInt32 aMaxSelfProgress,
    1:   PRInt32 aCurTotalProgress, PRInt32 aMaxTotalProgress)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onLocationChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in nsIURI location); */
    1: NS_IMETHODIMP nsAccessibilityService::OnLocationChange(nsIWebProgress *aWebProgress,
    1:   nsIRequest *aRequest, nsIURI *location)
    1: {
34455:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStatusChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in nsresult aStatus, in wstring aMessage); */
    1: NS_IMETHODIMP nsAccessibilityService::OnStatusChange(nsIWebProgress *aWebProgress,
    1:   nsIRequest *aRequest, nsresult aStatus, const PRUnichar *aMessage)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onSecurityChange (in nsIWebProgress aWebProgress, in nsIRequest aRequest, in unsigned long state); */
    1: NS_IMETHODIMP nsAccessibilityService::OnSecurityChange(nsIWebProgress *aWebProgress,
    1:   nsIRequest *aRequest, PRUint32 state)
    1: {
    1:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
23554: nsAccessibilityService::GetInfo(nsIFrame* aFrame, nsIWeakReference** aShell, nsIDOMNode** aNode)
    1: {
    1:   NS_ASSERTION(aFrame,"Error -- 1st argument (aFrame) is null!!");
34904:   if (!aFrame) {
34904:     return NS_ERROR_FAILURE;
34904:   }
23554:   nsCOMPtr<nsIContent> content = aFrame->GetContent();
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));
    1:   if (!content || !node)
    1:     return NS_ERROR_FAILURE;
34904: 
    1:   *aNode = node;
    1:   NS_IF_ADDREF(*aNode);
    1: 
    1:   nsCOMPtr<nsIDocument> document = content->GetDocument();
    1:   if (!document)
    1:     return NS_ERROR_FAILURE;
    1: 
 1814:   NS_ASSERTION(document->GetPrimaryShell(),"Error no shells!");
    1: 
    1:   // do_GetWR only works into a |nsCOMPtr| :-(
    1:   nsCOMPtr<nsIWeakReference> weakShell =
  981:     do_GetWeakReference(document->GetPrimaryShell());
    1:   NS_IF_ADDREF(*aShell = weakShell);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAccessibilityService::GetShellFromNode(nsIDOMNode *aNode, nsIWeakReference **aWeakShell)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   aNode->GetOwnerDocument(getter_AddRefs(domDoc));
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
    1:   if (!doc)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   // ---- Get the pres shell ----
  981:   nsIPresShell *shell = doc->GetPrimaryShell();
    1:   if (!shell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIWeakReference> weakRef(do_GetWeakReference(shell));
    1:   
    1:   *aWeakShell = weakRef;
    1:   NS_IF_ADDREF(*aWeakShell);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * nsIAccessibilityService methods:
    1:   */
    1: 
    1: NS_IMETHODIMP 
    1: nsAccessibilityService::CreateOuterDocAccessible(nsIDOMNode* aDOMNode, 
    1:                                                  nsIAccessible **aOuterDocAccessible)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDOMNode);
    1:   
    1:   *aOuterDocAccessible = nsnull;
    1: 
    1:   nsCOMPtr<nsIWeakReference> outerWeakShell;
    1:   GetShellFromNode(aDOMNode, getter_AddRefs(outerWeakShell));
    1:   NS_ENSURE_TRUE(outerWeakShell, NS_ERROR_FAILURE);
    1: 
    1:   nsOuterDocAccessible *outerDocAccessible =
    1:     new nsOuterDocAccessible(aDOMNode, outerWeakShell);
    1:   NS_ENSURE_TRUE(outerDocAccessible, NS_ERROR_FAILURE);
    1: 
    1:   NS_ADDREF(*aOuterDocAccessible = outerDocAccessible);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsAccessibilityService::CreateRootAccessible(nsIPresShell *aShell, 
    1:                                              nsIDocument* aDocument, 
    1:                                              nsIAccessible **aRootAcc)
    1: {
    1:   *aRootAcc = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(aDocument));
    1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
    1: 
    1:   nsIPresShell *presShell = aShell;
    1:   if (!presShell) {
  981:     presShell = aDocument->GetPrimaryShell();
    1:   }
    1:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(presShell));
    1: 
    1:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
12240:   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(container);
12240:   NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
12240:   nsCOMPtr<nsIContentViewer> contentViewer;
12240:   docShell->GetContentViewer(getter_AddRefs(contentViewer));
12240:   NS_ENSURE_TRUE(contentViewer, NS_ERROR_FAILURE); // Doc was already shut down
12252:   PRUint32 busyFlags;
12252:   docShell->GetBusyFlags(&busyFlags);
12252:   if (busyFlags != nsIDocShell::BUSY_FLAGS_NONE) {
12252:     nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(docShell));
12252:     nsCOMPtr<nsIURI> uri;
12252:     webNav->GetCurrentURI(getter_AddRefs(uri));
12252:     NS_ENSURE_STATE(uri);
12252:     nsCAutoString url;
12252:     uri->GetSpec(url);
12252:     if (url.EqualsLiteral("about:blank")) {
12252:       return NS_OK;  // No load events for a busy about:blank -- they are often temporary
12252:     }
12252:   }
12240: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
    1:     do_QueryInterface(container);
    1:   NS_ENSURE_TRUE(docShellTreeItem, NS_ERROR_FAILURE);
    1:   
    1:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
    1:   docShellTreeItem->GetParent(getter_AddRefs(parentTreeItem));
    1: 
    1:   if (parentTreeItem) {
    1:     // We only create root accessibles for the true root, othewise create a
    1:     // doc accessible
    1:     *aRootAcc = new nsDocAccessibleWrap(rootNode, weakShell);
    1:   }
    1:   else {
    1:     *aRootAcc = new nsRootAccessibleWrap(rootNode, weakShell);
    1:   }
    1:   if (!*aRootAcc)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
29320:   nsRefPtr<nsAccessible> rootAcc = nsAccUtils::QueryAccessible(*aRootAcc);
21169:   rootAcc->Init();
21169: 
20536:   nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(rootNode);
29320:   rootAcc->SetRoleMapEntry(roleMapEntry);
    1: 
    1:   NS_ADDREF(*aRootAcc);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1:  /**
    1:    * HTML widget creation
    1:    */
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTML4ButtonAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTML4ButtonAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLButtonAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLButtonAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAccessibilityService::CreateHTMLAccessibleByMarkup(nsIFrame *aFrame,
    1:                                                      nsIWeakReference *aWeakShell,
    1:                                                      nsIDOMNode *aNode,
    1:                                                      nsIAccessible **aAccessible)
    1: {
    1:   // This method assumes we're in an HTML namespace.
    1:   *aAccessible = nsnull;
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1:   nsIAtom *tag = content->Tag();
 2985:   if (tag == nsAccessibilityAtoms::legend) {
 2985:     *aAccessible = new nsHTMLLegendAccessible(aNode, aWeakShell);
 2985:   }
 2985:   else if (tag == nsAccessibilityAtoms::option) {
    1:     *aAccessible = new nsHTMLSelectOptionAccessible(aNode, aWeakShell);
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::optgroup) {
    1:     *aAccessible = new nsHTMLSelectOptGroupAccessible(aNode, aWeakShell);
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::ul || tag == nsAccessibilityAtoms::ol) {
    1:     *aAccessible = new nsHTMLListAccessible(aNode, aWeakShell);
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::a) {
34014: 
34014:     // Only some roles truly enjoy life as nsHTMLLinkAccessibles, for details
34014:     // see closed bug 494807.
34014:     nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(aNode);
34014:     if (roleMapEntry && roleMapEntry->role != nsIAccessibleRole::ROLE_NOTHING
34014:         && roleMapEntry->role != nsIAccessibleRole::ROLE_LINK) {
34014:       return CreateHyperTextAccessible(aFrame, aAccessible);
34014:     }
34014: 
 2735:     *aAccessible = new nsHTMLLinkAccessible(aNode, aWeakShell);
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::li && aFrame->GetType() != nsAccessibilityAtoms::blockFrame) {
    1:     // Normally this is created by the list item frame which knows about the bullet frame
    1:     // However, in this case the list item must have been styled using display: foo
 2735:     *aAccessible = new nsHTMLLIAccessible(aNode, aWeakShell, EmptyString());
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::abbr ||
    1:            tag == nsAccessibilityAtoms::acronym ||
    1:            tag == nsAccessibilityAtoms::blockquote ||
    1:            tag == nsAccessibilityAtoms::dd ||
    1:            tag == nsAccessibilityAtoms::dl ||
    1:            tag == nsAccessibilityAtoms::dt ||
    1:            tag == nsAccessibilityAtoms::form ||
    1:            tag == nsAccessibilityAtoms::h1 ||
    1:            tag == nsAccessibilityAtoms::h2 ||
    1:            tag == nsAccessibilityAtoms::h3 ||
    1:            tag == nsAccessibilityAtoms::h4 ||
    1:            tag == nsAccessibilityAtoms::h5 ||
    1:            tag == nsAccessibilityAtoms::h6 ||
    1:            tag == nsAccessibilityAtoms::q) {
    1:     return CreateHyperTextAccessible(aFrame, aAccessible);
    1:   }
29127:   else if (tag == nsAccessibilityAtoms::tr) {
29127:     *aAccessible = new nsEnumRoleAccessible(aNode, aWeakShell,
29127:                                             nsIAccessibleRole::ROLE_ROW);
29127:   }
28316:   else if (nsCoreUtils::IsHTMLTableHeader(content)) {
32381:     *aAccessible = new nsHTMLTableHeaderCellAccessibleWrap(aNode, aWeakShell);
28316:   }
28316: 
    1:   NS_IF_ADDREF(*aAccessible);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLLIAccessible(nsIFrame *aFrame, 
23554:                                                nsIFrame *aBulletFrame,
    1:                                                const nsAString& aBulletText,
    1:                                                nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 2735:   *_retval = new nsHTMLLIAccessible(node, weakShell, aBulletText);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHyperTextAccessible(nsIFrame *aFrame, nsIAccessible **aAccessible)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
    1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 1294:   
  966:   *aAccessible = new nsHyperTextAccessibleWrap(node, weakShell);
21047:   NS_ENSURE_TRUE(*aAccessible, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ADDREF(*aAccessible);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLCheckboxAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLCheckboxAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsAccessibilityService::CreateHTMLComboboxAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aPresShell, nsIAccessible **_retval)
    1: {
    1:   *_retval = new nsHTMLComboboxAccessible(aDOMNode, aPresShell);
    1:   if (! *_retval)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLImageAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = nsnull;
    1:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(node));
    1:   if (domElement) {
 1306:       *_retval = new nsHTMLImageAccessibleWrap(node, weakShell);
    1:   }
    1: 
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLGenericAccessible(nsIFrame *aFrame, nsIAccessible **aAccessible)
    1: {
 2075:   return CreateHyperTextAccessible(aFrame, aAccessible);
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLGroupboxAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLGroupboxAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsAccessibilityService::CreateHTMLListboxAccessible(nsIDOMNode* aDOMNode, nsIWeakReference* aPresShell, nsIAccessible **_retval)
    1: {
    1:   *_retval = new nsHTMLSelectListAccessible(aDOMNode, aPresShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
27515: NS_IMETHODIMP
27515: nsAccessibilityService::CreateHTMLMediaAccessible(nsIFrame *aFrame,
27515:                                                   nsIAccessible **aAccessible)
27515: {
27515:   NS_ENSURE_ARG_POINTER(aAccessible);
27515:   *aAccessible = nsnull;
27515: 
27515:   nsCOMPtr<nsIDOMNode> node;
27515:   nsCOMPtr<nsIWeakReference> weakShell;
27515:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell),
27515:                         getter_AddRefs(node));
27515:   NS_ENSURE_SUCCESS(rv, rv);
27515: 
27515:   *aAccessible = new nsEnumRoleAccessible(node, weakShell,
27515:                                           nsIAccessibleRole::ROLE_GROUPING);
27515:   NS_ENSURE_TRUE(*aAccessible, NS_ERROR_OUT_OF_MEMORY);
27515: 
27515:   NS_ADDREF(*aAccessible);
27515:   return NS_OK;
27515: }
27515: 
    1: /**
    1:   * We can have several cases here. 
    1:   *  1) a text or html embedded document where the contentDocument
    1:   *     variable in the object element holds the content
    1:   *  2) web content that uses a plugin, which means we will
    1:   *     have to go to the plugin to get the accessible content
    1:   *  3) An image or imagemap, where the image frame points back to 
    1:   *     the object element DOMNode
    1:   */
    1: NS_IMETHODIMP
    1: nsAccessibilityService::CreateHTMLObjectFrameAccessible(nsObjectFrame *aFrame,
    1:                                                         nsIAccessible **aAccessible)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1: 
    1:   *aAccessible = nsnull;
23554:   if (aFrame->GetRect().IsEmpty()) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   // 1) for object elements containing either HTML or TXT documents
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   nsCOMPtr<nsIDOMHTMLObjectElement> obj(do_QueryInterface(node));
    1:   if (obj)
    1:     obj->GetContentDocument(getter_AddRefs(domDoc));
    1:   else
    1:     domDoc = do_QueryInterface(node);
    1:   if (domDoc)
    1:     return CreateOuterDocAccessible(node, aAccessible);
    1: 
    1: #ifdef XP_WIN
    1:   // 2) for plugins
    1:   nsCOMPtr<nsIPluginInstance> pluginInstance ;
    1:   aFrame->GetPluginInstance(*getter_AddRefs(pluginInstance));
    1:   if (pluginInstance) {
33872:     // Note: pluginPort will be null if windowless.
    1:     HWND pluginPort = nsnull;
    1:     aFrame->GetPluginPort(&pluginPort);
33872: 
33872:     *aAccessible =
33872:       new nsHTMLWin32ObjectOwnerAccessible(node, weakShell, pluginPort);
33872:     NS_ENSURE_TRUE(*aAccessible, NS_ERROR_OUT_OF_MEMORY);
33872: 
    1:     NS_ADDREF(*aAccessible);
    1:     return NS_OK;
    1:   }
    1: #endif
    1: 
    1:   // 3) for images and imagemaps, or anything else with a child frame
    1:   // we have the object frame, get the image frame
23554:   nsIFrame *frame = aFrame->GetFirstChild(nsnull);
    1:   if (frame)
    1:     return frame->GetAccessible(aAccessible);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLRadioButtonAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
  144:   *_retval = new nsHTMLRadioButtonAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsAccessibilityService::CreateHTMLSelectOptionAccessible(nsIDOMNode* aDOMNode, 
    1:                                                          nsIAccessible *aParent, 
    1:                                                          nsIWeakReference* aPresShell, 
    1:                                                          nsIAccessible **_retval)
    1: {
    1:   *_retval = new nsHTMLSelectOptionAccessible(aDOMNode, aPresShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLTableAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
 1133:   *_retval = new nsHTMLTableAccessibleWrap(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32381: nsAccessibilityService::CreateHTMLTableCellAccessible(nsIFrame *aFrame,
32381:                                                       nsIAccessible **aAccessible)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
32381:   *aAccessible = new nsHTMLTableCellAccessibleWrap(node, weakShell);
32381:   if (!*aAccessible) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
32381:   NS_ADDREF(*aAccessible);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLTextAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // XXX Don't create ATK objects for these
 2735:   *_retval = new nsHTMLTextAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLTextFieldAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLTextFieldAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLLabelAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLLabelAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLHRAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLHRAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLBRAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   *_retval = new nsHTMLBRAccessible(node, weakShell);
    1:   if (! *_retval) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
 3151: NS_IMETHODIMP
23554: nsAccessibilityService::CreateHTMLCaptionAccessible(nsIFrame *aFrame, nsIAccessible **_retval)
 3151: {
 3151:   nsCOMPtr<nsIDOMNode> node;
 3151:   nsCOMPtr<nsIWeakReference> weakShell;
23554:   nsresult rv = GetInfo(aFrame, getter_AddRefs(weakShell), getter_AddRefs(node));
 3151:   if (NS_FAILED(rv))
 3151:     return rv;
 3151: 
 3151:   *_retval = new nsHTMLCaptionAccessible(node, weakShell);
 3151:   if (! *_retval) 
 3151:     return NS_ERROR_OUT_OF_MEMORY;
 3151: 
 3151:   NS_ADDREF(*_retval);
 3151:   return NS_OK;
 3151: }
 3151: 
    1: NS_IMETHODIMP nsAccessibilityService::GetCachedAccessible(nsIDOMNode *aNode, 
    1:                                                           nsIWeakReference *aWeakShell,
    1:                                                           nsIAccessible **aAccessible)
    1: {
    1:   nsCOMPtr<nsIAccessNode> accessNode;
    1:   nsresult rv = GetCachedAccessNode(aNode, aWeakShell, getter_AddRefs(accessNode));
    1:   nsCOMPtr<nsIAccessible> accessible(do_QueryInterface(accessNode));
    1:   NS_IF_ADDREF(*aAccessible = accessible);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibilityService::GetCachedAccessNode(nsIDOMNode *aNode, 
    1:                                                           nsIWeakReference *aWeakShell,
    1:                                                           nsIAccessNode **aAccessNode)
    1: {
    1:   nsCOMPtr<nsIAccessibleDocument> accessibleDoc =
    1:     nsAccessNode::GetDocAccessibleFor(aWeakShell);
    1: 
    1:   if (!accessibleDoc) {
    1:     *aAccessNode = nsnull;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 3233:   return accessibleDoc->GetCachedAccessNode(static_cast<void*>(aNode), aAccessNode);
    1: }
    1: 
 2064: NS_IMETHODIMP
 2064: nsAccessibilityService::GetStringRole(PRUint32 aRole, nsAString& aString)
 2064: {
 2064:   if ( aRole >= NS_ARRAY_LENGTH(kRoleNames)) {
 2064:     aString.AssignLiteral("unknown");
 2064:     return NS_OK;
 2064:   }
 2064: 
 2064:   CopyUTF8toUTF16(kRoleNames[aRole], aString);
 2064:   return NS_OK;
 2064: }
 2064: 
 2064: NS_IMETHODIMP
 2064: nsAccessibilityService::GetStringStates(PRUint32 aStates, PRUint32 aExtraStates,
 2064:                                         nsIDOMDOMStringList **aStringStates)
 2064: {
 2064:   nsAccessibleDOMStringList *stringStates = new nsAccessibleDOMStringList();
 2064:   NS_ENSURE_TRUE(stringStates, NS_ERROR_OUT_OF_MEMORY);
 2064: 
 2064:   //states
 2064:   if (aStates & nsIAccessibleStates::STATE_UNAVAILABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("unavailable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_SELECTED)
 2064:     stringStates->Add(NS_LITERAL_STRING("selected"));
 2064:   if (aStates & nsIAccessibleStates::STATE_FOCUSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("focused"));
 2064:   if (aStates & nsIAccessibleStates::STATE_PRESSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("pressed"));
 2064:   if (aStates & nsIAccessibleStates::STATE_CHECKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("checked"));
 2064:   if (aStates & nsIAccessibleStates::STATE_MIXED)
 2064:     stringStates->Add(NS_LITERAL_STRING("mixed"));
 2064:   if (aStates & nsIAccessibleStates::STATE_READONLY)
 2064:     stringStates->Add(NS_LITERAL_STRING("readonly"));
 2064:   if (aStates & nsIAccessibleStates::STATE_HOTTRACKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("hottracked"));
 2064:   if (aStates & nsIAccessibleStates::STATE_DEFAULT)
 2064:     stringStates->Add(NS_LITERAL_STRING("default"));
 2064:   if (aStates & nsIAccessibleStates::STATE_EXPANDED)
 2064:     stringStates->Add(NS_LITERAL_STRING("expanded"));
 2064:   if (aStates & nsIAccessibleStates::STATE_COLLAPSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("collapsed"));
 2064:   if (aStates & nsIAccessibleStates::STATE_BUSY)
 2064:     stringStates->Add(NS_LITERAL_STRING("busy"));
 2064:   if (aStates & nsIAccessibleStates::STATE_FLOATING)
 2064:     stringStates->Add(NS_LITERAL_STRING("floating"));
 2064:   if (aStates & nsIAccessibleStates::STATE_ANIMATED)
 2064:     stringStates->Add(NS_LITERAL_STRING("animated"));
 2064:   if (aStates & nsIAccessibleStates::STATE_INVISIBLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("invisible"));
 2064:   if (aStates & nsIAccessibleStates::STATE_OFFSCREEN)
 2064:     stringStates->Add(NS_LITERAL_STRING("offscreen"));
 2064:   if (aStates & nsIAccessibleStates::STATE_SIZEABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("sizeable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_MOVEABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("moveable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_SELFVOICING)
 2064:     stringStates->Add(NS_LITERAL_STRING("selfvoicing"));
 2064:   if (aStates & nsIAccessibleStates::STATE_FOCUSABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("focusable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_SELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("selectable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_LINKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("linked"));
 2064:   if (aStates & nsIAccessibleStates::STATE_TRAVERSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("traversed"));
 2064:   if (aStates & nsIAccessibleStates::STATE_MULTISELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("multiselectable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_EXTSELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("extselectable"));
 2064:   if (aStates & nsIAccessibleStates::STATE_PROTECTED)
 2064:     stringStates->Add(NS_LITERAL_STRING("protected"));
 2064:   if (aStates & nsIAccessibleStates::STATE_HASPOPUP)
 2064:     stringStates->Add(NS_LITERAL_STRING("haspopup"));
 2064:   if (aStates & nsIAccessibleStates::STATE_REQUIRED)
 2064:     stringStates->Add(NS_LITERAL_STRING("required"));
 2064:   if (aStates & nsIAccessibleStates::STATE_IMPORTANT)
 2064:     stringStates->Add(NS_LITERAL_STRING("important"));
 2064:   if (aStates & nsIAccessibleStates::STATE_INVALID)
 2064:     stringStates->Add(NS_LITERAL_STRING("invalid"));
 2064:   if (aStates & nsIAccessibleStates::STATE_CHECKABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("checkable"));
 2064: 
 2064:   //extraStates
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_SUPPORTS_AUTOCOMPLETION)
 3513:     stringStates->Add(NS_LITERAL_STRING("autocompletion"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_DEFUNCT)
 3513:     stringStates->Add(NS_LITERAL_STRING("defunct"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_SELECTABLE_TEXT)
 2064:     stringStates->Add(NS_LITERAL_STRING("selectable text"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_EDITABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("editable"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_ACTIVE)
 2064:     stringStates->Add(NS_LITERAL_STRING("active"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_MODAL)
 2064:     stringStates->Add(NS_LITERAL_STRING("modal"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_MULTI_LINE)
 2064:     stringStates->Add(NS_LITERAL_STRING("multi line"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_HORIZONTAL)
 3513:     stringStates->Add(NS_LITERAL_STRING("horizontal"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_OPAQUE)
 3513:     stringStates->Add(NS_LITERAL_STRING("opaque"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_SINGLE_LINE)
 2064:     stringStates->Add(NS_LITERAL_STRING("single line"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_TRANSIENT)
 2064:     stringStates->Add(NS_LITERAL_STRING("transient"));
 2064:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_VERTICAL)
 2064:     stringStates->Add(NS_LITERAL_STRING("vertical"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_STALE)
 3513:     stringStates->Add(NS_LITERAL_STRING("stale"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_ENABLED)
 3513:     stringStates->Add(NS_LITERAL_STRING("enabled"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_SENSITIVE)
 3513:     stringStates->Add(NS_LITERAL_STRING("sensitive"));
 3513:   if (aExtraStates & nsIAccessibleStates::EXT_STATE_EXPANDABLE)
 3513:     stringStates->Add(NS_LITERAL_STRING("expandable"));
 2064: 
 2064:   //unknown states
 2064:   PRUint32 stringStatesLength = 0;
 2064: 
 2064:   stringStates->GetLength(&stringStatesLength);
 2064:   if (!stringStatesLength)
 2064:     stringStates->Add(NS_LITERAL_STRING("unknown"));
 2064: 
 2064:   NS_ADDREF(*aStringStates = stringStates);
 2064:   return NS_OK;
 2064: }
 2064: 
 5188: // nsIAccessibleRetrieval::getStringEventType()
 5188: NS_IMETHODIMP
 5188: nsAccessibilityService::GetStringEventType(PRUint32 aEventType,
 5188:                                            nsAString& aString)
 5188: {
 6284:   NS_ASSERTION(nsIAccessibleEvent::EVENT_LAST_ENTRY == NS_ARRAY_LENGTH(kEventTypeNames),
 6284:                "nsIAccessibleEvent constants are out of sync to kEventTypeNames");
 6284: 
 5188:   if (aEventType >= NS_ARRAY_LENGTH(kEventTypeNames)) {
 5188:     aString.AssignLiteral("unknown");
 5188:     return NS_OK;
 5188:   }
 5188: 
 5188:   CopyUTF8toUTF16(kEventTypeNames[aEventType], aString);
 5188:   return NS_OK;
 5188: }
 5188: 
 6812: // nsIAccessibleRetrieval::getStringRelationType()
 6812: NS_IMETHODIMP
 6812: nsAccessibilityService::GetStringRelationType(PRUint32 aRelationType,
 6812:                                               nsAString& aString)
 6812: {
 6812:   if (aRelationType >= NS_ARRAY_LENGTH(kRelationTypeNames)) {
 6812:     aString.AssignLiteral("unknown");
 6812:     return NS_OK;
 6812:   }
 6812: 
 6812:   CopyUTF8toUTF16(kRelationTypeNames[aRelationType], aString);
 6812:   return NS_OK;
 6812: }
 6812: 
 6812: 
    1: /**
    1:   * GetAccessibleFor - get an nsIAccessible from a DOM node
    1:   */
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibilityService::GetAccessibleFor(nsIDOMNode *aNode,
    1:                                          nsIAccessible **aAccessible)
    1: {
 1440:   NS_ENSURE_ARG_POINTER(aAccessible);
 1440:   *aAccessible = nsnull;
 1440: 
 1440:   NS_ENSURE_ARG(aNode);
 1440: 
    1:   // We use presentation shell #0 because we assume that is presentation of
    1:   // given node window.
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1:   nsCOMPtr<nsIDocument> doc;
    1:   if (content) {
    1:     doc = content->GetDocument();
    1:   }
    1:   else {// Could be document node
    1:     doc = do_QueryInterface(aNode);
    1:   }
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
  981:   nsIPresShell *presShell = doc->GetPrimaryShell();
    1:   return GetAccessibleInShell(aNode, presShell, aAccessible);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibilityService::GetAttachedAccessibleFor(nsIDOMNode *aNode,
    1:                                                  nsIAccessible **aAccessible)
    1: {
    1:   NS_ENSURE_ARG(aNode);
    1:   NS_ENSURE_ARG_POINTER(aAccessible);
    1: 
    1:   *aAccessible = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> relevantNode;
    1:   nsresult rv = GetRelevantContentNodeFor(aNode, getter_AddRefs(relevantNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (relevantNode != aNode)
    1:     return NS_OK;
    1: 
    1:   return GetAccessibleFor(aNode, aAccessible);
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibilityService::GetAccessibleInWindow(nsIDOMNode *aNode, 
    1:                                                             nsIDOMWindow *aWin,
    1:                                                             nsIAccessible **aAccessible)
    1: {
 1440:   NS_ENSURE_ARG_POINTER(aAccessible);
 1440:   *aAccessible = nsnull;
 1440: 
 1440:   NS_ENSURE_ARG(aNode);
 1440:   NS_ENSURE_ARG(aWin);
 1440: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(aWin));
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(webNav));
    1:   if (!docShell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   docShell->GetPresShell(getter_AddRefs(presShell));
    1:   return GetAccessibleInShell(aNode, presShell, aAccessible);
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibilityService::GetAccessibleInShell(nsIDOMNode *aNode, 
    1:                                                            nsIPresShell *aPresShell,
    1:                                                            nsIAccessible **aAccessible) 
    1: {
 1440:   NS_ENSURE_ARG_POINTER(aAccessible);
 1440:   *aAccessible = nsnull;
 1440: 
 1440:   NS_ENSURE_ARG(aNode);
 1440:   NS_ENSURE_ARG(aPresShell);
 1440: 
    1:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(aPresShell));
    1:   nsIFrame *outFrameUnused = NULL;
    1:   PRBool isHiddenUnused = false;
    1:   return GetAccessible(aNode, aPresShell, weakShell, 
    1:                        &outFrameUnused, &isHiddenUnused, aAccessible);
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibilityService::GetAccessibleInWeakShell(nsIDOMNode *aNode, 
    1:                                                                nsIWeakReference *aWeakShell,
    1:                                                                nsIAccessible **aAccessible) 
    1: {
 1440:   NS_ENSURE_ARG_POINTER(aAccessible);
 1440:   *aAccessible = nsnull;
 1440: 
 1440:   NS_ENSURE_ARG(aNode);
 1440:   NS_ENSURE_ARG(aWeakShell);
 1440: 
    1:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(aWeakShell));
    1:   nsIFrame *outFrameUnused = NULL;
    1:   PRBool isHiddenUnused = false;
    1:   return GetAccessible(aNode, presShell, aWeakShell, 
    1:                        &outFrameUnused, &isHiddenUnused, aAccessible);
    1: }
    1: 
    1: nsresult nsAccessibilityService::InitAccessible(nsIAccessible *aAccessibleIn,
 7830:                                                 nsIAccessible **aAccessibleOut,
 7830:                                                 nsRoleMapEntry *aRoleMapEntry)
    1: {
  618:   if (!aAccessibleIn) {
  618:     return NS_ERROR_FAILURE; // No accessible to init
  618:   }
    1:   NS_ASSERTION(aAccessibleOut && !*aAccessibleOut, "Out param should already be cleared out");
    1: 
29320:   nsRefPtr<nsAccessible> acc = nsAccUtils::QueryAccessible(aAccessibleIn);
21169:   nsresult rv = acc->Init(); // Add to cache, etc.
21169:   NS_ENSURE_SUCCESS(rv, rv);
21169: 
29320:   acc->SetRoleMapEntry(aRoleMapEntry);
    1:   NS_ADDREF(*aAccessibleOut = aAccessibleIn);
21169: 
21169:   return NS_OK;
    1: }
    1: 
10515: static PRBool HasRelatedContent(nsIContent *aContent)
10515: {
10515:   nsAutoString id;
20521:   if (!aContent || !nsCoreUtils::GetID(aContent, id) || id.IsEmpty()) {
10515:     return PR_FALSE;
10515:   }
10515: 
10515:   nsIAtom *relationAttrs[] = {nsAccessibilityAtoms::aria_labelledby,
10515:                               nsAccessibilityAtoms::aria_describedby,
10515:                               nsAccessibilityAtoms::aria_owns,
10515:                               nsAccessibilityAtoms::aria_controls,
10515:                               nsAccessibilityAtoms::aria_flowto};
20521:   if (nsCoreUtils::FindNeighbourPointingToNode(aContent, relationAttrs,
20521:                                                NS_ARRAY_LENGTH(relationAttrs))) {
10515:     return PR_TRUE;
10515:   }
10515: 
10515:   nsIContent *ancestorContent = aContent;
10515:   while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
13716:     if (ancestorContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant)) {
10515:         // ancestor has activedescendant property, this content could be active
10515:       return PR_TRUE;
10515:     }
10515:   }
10515: 
10515:   return PR_FALSE;
10515: }
10515: 
    1: NS_IMETHODIMP nsAccessibilityService::GetAccessible(nsIDOMNode *aNode,
    1:                                                     nsIPresShell *aPresShell,
    1:                                                     nsIWeakReference *aWeakShell,
    1:                                                     nsIFrame **aFrameHint,
    1:                                                     PRBool *aIsHidden,
    1:                                                     nsIAccessible **aAccessible)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAccessible);
    1:   NS_ENSURE_ARG_POINTER(aFrameHint);
    1:   *aAccessible = nsnull;
30820:   if (!aPresShell || !aWeakShell || gIsShutdown) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   NS_ASSERTION(aNode, "GetAccessible() called with no node.");
    1: 
    1:   *aIsHidden = PR_FALSE;
    1: 
34904:   // Frames can be deallocated when we flush layout, or when we call into code
34904:   // that can flush layout, either directly, or via DOM manipulation, or some
34904:   // CSS styles like :hover. We use the weak frame checks to avoid calling
34904:   // methods on a dead frame pointer.
34904:   nsWeakFrame weakFrame = *aFrameHint;
34904: 
    1: #ifdef DEBUG_A11Y
    1:   // Please leave this in for now, it's a convenient debugging method
    1:   nsAutoString name;
    1:   aNode->GetLocalName(name);
    1:   if (name.LowerCaseEqualsLiteral("h1")) 
    1:     printf("## aaronl debugging tag name\n");
    1: 
    1:   nsAutoString attrib;
    1:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(aNode));
    1:   if (element) {
    1:     element->GetAttribute(NS_LITERAL_STRING("type"), attrib);
    1:     if (attrib.EqualsLiteral("statusbarpanel"))
    1:       printf("## aaronl debugging attribute\n");
    1:   }
    1: #endif
    1: 
    1:   // Check to see if we already have an accessible for this
    1:   // node in the cache
    1:   nsCOMPtr<nsIAccessNode> accessNode;
    1:   GetCachedAccessNode(aNode, aWeakShell, getter_AddRefs(accessNode));
    1: 
    1:   nsCOMPtr<nsIAccessible> newAcc;
    1:   if (accessNode) {
15313:     // Retrieved from cache. QI might not succeed if it's a node that's not
15313:     // accessible. In this case try to create new accessible because one and
15313:     // the same DOM node may be accessible or not in time (for example,
15313:     // when it is visible or hidden).
    1:     newAcc = do_QueryInterface(accessNode);
15313:     if (newAcc) {
15313:       NS_ADDREF(*aAccessible = newAcc);
    1:       return NS_OK;
    1:     }
15313:   }
    1: 
15308:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
15308: 
    1:   // No cache entry, so we must create the accessible
    1:   // Check to see if hidden first
    1:   nsCOMPtr<nsIDocument> nodeIsDoc;
    1:   if (!content) {
    1:     // This happens when we're on the document node, which will not QI to an
    1:     // nsIContent.
    1:     nodeIsDoc = do_QueryInterface(aNode);
    1:     NS_ENSURE_TRUE(nodeIsDoc, NS_ERROR_FAILURE); // No content, and not doc node
    1: 
    1:     nsCOMPtr<nsIAccessibleDocument> accessibleDoc =
    1:       nsAccessNode::GetDocAccessibleFor(aWeakShell);
    1:     if (accessibleDoc) {
    1:       newAcc = do_QueryInterface(accessibleDoc);
    1:       NS_ASSERTION(newAcc, "nsIAccessibleDocument is not an nsIAccessible");
    1:     }
    1:     else {
    1:       CreateRootAccessible(aPresShell, nodeIsDoc, getter_AddRefs(newAcc)); // Does Init() for us
    1:     }
    1: 
    1:     *aFrameHint = aPresShell->GetRootFrame();
    1:     NS_IF_ADDREF(*aAccessible = newAcc);
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ASSERTION(content->GetDocument(), "Creating accessible for node with no document");
    1:   if (!content->GetDocument()) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   NS_ASSERTION(content->GetDocument() == aPresShell->GetDocument(), "Creating accessible for wrong pres shell");
    1:   if (content->GetDocument() != aPresShell->GetDocument()) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // We have a content node
    1: #ifdef DEBUG_A11Y
    1:   static int frameHintFailed, frameHintTried, frameHintNonexistant, frameHintFailedForText;
    1:   ++frameHintTried;
    1: #endif
34904: 
34904:   if (!weakFrame.GetFrame() || content != weakFrame.GetFrame()->GetContent()) {
    1:     // Frame hint not correct, get true frame, we try to optimize away from this
34904:     weakFrame = aPresShell->GetRealPrimaryFrameFor(content);
34904:     if (weakFrame.GetFrame()) {
    1: #ifdef DEBUG_A11Y_FRAME_OPTIMIZATION
    1:       // Frame hint debugging
    1:       ++frameHintFailed;
    1:       if (content->IsNodeOfType(nsINode::eTEXT)) {
    1:         ++frameHintFailedForText;
    1:       }
    1:       frameHintNonexistant += !*aFrameHint;
    1:       printf("Frame hint failures: %d / %d . Text fails = %d. No hint fails = %d \n", frameHintFailed, frameHintTried, frameHintFailedForText, frameHintNonexistant);
    1:       if (frameHintTried >= 354) {
    1:         printf("* "); // Aaron's break point
    1:       }
    1: #endif
34904:       if (weakFrame.GetFrame()->GetContent() != content) {
    1:         // Not the main content for this frame!
    1:         // For example, this happens because <area> elements return the
    1:         // image frame as their primary frame. The main content for the 
    1:         // image frame is the image content.
    1: 
    1:         // Check if frame is an image frame, and content is <area>
34904:         nsIImageFrame *imageFrame = do_QueryFrame(weakFrame.GetFrame());
    1:         nsCOMPtr<nsIDOMHTMLAreaElement> areaElmt = do_QueryInterface(content);
    1:         if (imageFrame && areaElmt) {
    1:           nsCOMPtr<nsIAccessible> imageAcc;
34904:           CreateHTMLImageAccessible(weakFrame.GetFrame(), getter_AddRefs(imageAcc));
    1:           if (imageAcc) {
    1:             // cache children
    1:             PRInt32 childCount;
    1:             imageAcc->GetChildCount(&childCount);
    1:             // area accessible should be in cache now
    1:             return GetCachedAccessible(aNode, aWeakShell, aAccessible);
    1:           }
    1:         }
    1: 
    1:         return NS_OK;
    1:       }
34904:       *aFrameHint = weakFrame.GetFrame();
    1:     }
    1:   }
    1: 
    1:   // Check frame to see if it is hidden
34904:   if (!weakFrame.GetFrame() ||
34904:       !weakFrame.GetFrame()->GetStyleVisibility()->IsVisible()) {
    1:     *aIsHidden = PR_TRUE;
    1:   }
    1: 
    1:   if (*aIsHidden)
    1:     return NS_OK;
    1: 
    1:   /**
    1:    * Attempt to create an accessible based on what we know
    1:    */
    1:   if (content->IsNodeOfType(nsINode::eTEXT)) {
    1:     // --- Create HTML for visible text frames ---
34904:     nsIFrame* f = weakFrame.GetFrame();
34904:     if (f && f->IsEmpty()) {
 9480:       nsAutoString renderedWhitespace;
34904:       f->GetRenderedText(&renderedWhitespace, nsnull, nsnull, 0, 1);
 9480:       if (renderedWhitespace.IsEmpty()) {
 9480:         // Really empty -- nothing is rendered
    1:         *aIsHidden = PR_TRUE;
    1:         return NS_OK;
    1:       }
 9480:     }
34904:     if (weakFrame.IsAlive()) {
34904:       weakFrame.GetFrame()->GetAccessible(getter_AddRefs(newAcc));
34904:     }
 7830:     return InitAccessible(newAcc, aAccessible, nsnull);
    1:   }
    1: 
33329:   PRBool isHTML = content->IsHTML();
15308:   if (isHTML && content->Tag() == nsAccessibilityAtoms::map) {
15308:     // Create hyper text accessible for HTML map if it is used to group links
15308:     // (see http://www.w3.org/TR/WCAG10-HTML-TECHS/#group-bypass). If the HTML
15308:     // map doesn't have 'name' attribute (or has empty name attribute) then we
15308:     // suppose it is used for links grouping. Otherwise we think it is used in
15308:     // conjuction with HTML image element and in this case we don't create any
15308:     // accessible for it and don't walk into it. The accessibles for HTML area
15308:     // (nsHTMLAreaAccessible) the map contains are attached as children of the
15308:     // appropriate accessible for HTML image (nsHTMLImageAccessible).
15308:     nsAutoString name;
15308:     content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::name, name);
15308:     if (!name.IsEmpty()) {
15308:       *aIsHidden = PR_TRUE;
15308:       return NS_OK;
15308:     }
15308:     
34904:     nsresult rv =
34904:       CreateHyperTextAccessible(weakFrame.GetFrame(), getter_AddRefs(newAcc));
15308:     NS_ENSURE_SUCCESS(rv, rv);
15308:   }
15308: 
20536:   nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(aNode);
 7830:   if (roleMapEntry && !nsCRT::strcmp(roleMapEntry->roleString, "presentation") &&
 7830:       !content->IsFocusable()) { // For presentation only
 7830:     // Only create accessible for role of "presentation" if it is focusable --
    1:     // in that case we need an accessible in case it gets focused, we
    1:     // don't want focus ever to be 'lost'
    1:     return NS_OK;
    1:   }
    1: 
34904:   if (weakFrame.IsAlive() && !newAcc && isHTML) {  // HTML accessibles
13731:     PRBool tryTagNameOrFrame = PR_TRUE;
13731: 
34904:     nsIAtom *frameType = weakFrame.GetFrame()->GetType();
28493: 
28493:     PRBool partOfHTMLTable =
28493:       frameType == nsAccessibilityAtoms::tableCaptionFrame ||
10869:       frameType == nsAccessibilityAtoms::tableCellFrame ||
10869:       frameType == nsAccessibilityAtoms::tableRowGroupFrame ||
28493:       frameType == nsAccessibilityAtoms::tableRowFrame;
28493: 
32474:     if (partOfHTMLTable) {
10869:       // Table-related frames don't get table-related roles
10869:       // unless they are inside a table, but they may still get generic
10869:       // accessibles
    1:       nsIContent *tableContent = content;
    1:       while ((tableContent = tableContent->GetParent()) != nsnull) {
10421:         nsIFrame *tableFrame = aPresShell->GetPrimaryFrameFor(tableContent);
10869:         if (!tableFrame)
10869:           continue;
32474: 
10869:         if (tableFrame->GetType() == nsAccessibilityAtoms::tableOuterFrame) {
 8882:           nsCOMPtr<nsIDOMNode> tableNode(do_QueryInterface(tableContent));
10869:           nsCOMPtr<nsIAccessible> tableAccessible;
32474:           GetAccessibleInShell(tableNode, aPresShell,
32474:                                getter_AddRefs(tableAccessible));
32474: 
32474:           if (tableAccessible) {
32479:             if (!roleMapEntry) {
32479:               PRUint32 role = nsAccUtils::Role(tableAccessible);
32479:               if (role != nsIAccessibleRole::ROLE_TABLE &&
32479:                   role != nsIAccessibleRole::ROLE_TREE_TABLE) {
32479:                 // No ARIA role and not in table: override role. For example,
32479:                 // <table role="label"><td>content</td></table>
32474:                 roleMapEntry = &nsARIAMap::gEmptyRoleMap;
32474:               }
32479:             }
32474: 
32474:             break;
32474:           }
32474: 
10869: #ifdef DEBUG
20521:           nsRoleMapEntry *tableRoleMapEntry =
20536:             nsAccUtils::GetRoleMapEntry(tableNode);
11383:           NS_ASSERTION(tableRoleMapEntry &&
11383:                        !nsCRT::strcmp(tableRoleMapEntry->roleString, "presentation"),
10869:                        "No accessible for parent table and it didn't have role of presentation");
10869: #endif
32474: 
32474:           if (!roleMapEntry && !content->IsFocusable()) {
32474:             // Table-related descendants of presentation table are also
32474:             // presentation if they aren't focusable and have not explicit ARIA
32474:             // role (don't create accessibles for them unless they need to fire
32474:             // focus events).
10869:             return NS_OK;
10869:           }
32474: 
32474:           // otherwise create ARIA based accessible.
32474:           tryTagNameOrFrame = PR_FALSE;
 6090:           break;
 6090:         }
32474: 
32474:         if (tableContent->Tag() == nsAccessibilityAtoms::table) {
10869:           // Stop before we are fooled by any additional table ancestors
10869:           // This table cell frameis part of a separate ancestor table.
13731:           tryTagNameOrFrame = PR_FALSE;
10421:           break;
 6090:         }
 6090:       }
13731: 
13731:       if (!tableContent)
13731:         tryTagNameOrFrame = PR_FALSE;
    1:     }
    1: 
29271:     if (roleMapEntry) {
29271:       // Create ARIA grid/treegrid accessibles if node is not of a child or
29271:       // valid child of HTML table and is not a HTML table.
29271:       if ((!partOfHTMLTable || !tryTagNameOrFrame) &&
29271:           frameType != nsAccessibilityAtoms::tableOuterFrame) {
29271: 
28493:         if (roleMapEntry->role == nsIAccessibleRole::ROLE_TABLE ||
28493:             roleMapEntry->role == nsIAccessibleRole::ROLE_TREE_TABLE) {
29269:           newAcc = new nsARIAGridAccessibleWrap(aNode, aWeakShell);
29271: 
28493:         } else if (roleMapEntry->role == nsIAccessibleRole::ROLE_GRID_CELL ||
28493:             roleMapEntry->role == nsIAccessibleRole::ROLE_ROWHEADER ||
28493:             roleMapEntry->role == nsIAccessibleRole::ROLE_COLUMNHEADER) {
32381:           newAcc = new nsARIAGridCellAccessibleWrap(aNode, aWeakShell);
28493:         }
28493:       }
29271:     }
28493: 
28493:     if (!newAcc && tryTagNameOrFrame) {
 6090:       // Prefer to use markup (mostly tag name, perhaps attributes) to
 6090:       // decide if and what kind of accessible to create.
 6090:       // The method creates accessibles for table related content too therefore
 6090:       // we do not call it if accessibles for table related content are
 6090:       // prevented above.
34904:       nsresult rv =
34904:         CreateHTMLAccessibleByMarkup(weakFrame.GetFrame(), aWeakShell, aNode,
 6090:                                      getter_AddRefs(newAcc));
 6090:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6090:       if (!newAcc) {
 6090:         // Do not create accessible object subtrees for non-rendered table
 6090:         // captions. This could not be done in
 6090:         // nsTableCaptionFrame::GetAccessible() because the descendants of
 6090:         // the table caption would still be created. By setting
 6090:         // *aIsHidden = PR_TRUE we ensure that no descendant accessibles are
 6090:         // created.
34904:         nsIFrame* f = weakFrame.GetFrame();
34904:         if (!f) {
34904:           f = aPresShell->GetRealPrimaryFrameFor(content);
34904:         }
34904:         if (f->GetType() == nsAccessibilityAtoms::tableCaptionFrame &&
34904:            f->GetRect().IsEmpty()) {
 6090:           // XXX This is not the ideal place for this code, but right now there
 6090:           // is no better place:
 3151:           *aIsHidden = PR_TRUE;
 3151:           return NS_OK;
 3151:         }
34904:         f->GetAccessible(getter_AddRefs(newAcc)); // Try using frame to do it
    1:       }
    1:     }
13731:   }
    1: 
 1477:   if (!newAcc) {
28493:     // Elements may implement nsIAccessibleProvider via XBL. This allows them to
28493:     // say what kind of accessible to create.
28493:     nsresult rv = GetAccessibleByType(aNode, getter_AddRefs(newAcc));
28493:     NS_ENSURE_SUCCESS(rv, rv);
28493:   }
28493: 
28493:   if (!newAcc) {
28493:     // Create generic accessibles for SVG and MathML nodes.
28493:     if (content->GetNameSpaceID() == kNameSpaceID_SVG &&
28493:         content->Tag() == nsAccessibilityAtoms::svg) {
28493:       newAcc = new nsEnumRoleAccessible(aNode, aWeakShell,
28493:                                         nsIAccessibleRole::ROLE_DIAGRAM);
28493:     }
28493:     else if (content->GetNameSpaceID() == kNameSpaceID_MathML &&
28493:              content->Tag() == nsAccessibilityAtoms::math) {
28493:       newAcc = new nsEnumRoleAccessible(aNode, aWeakShell,
28493:                                         nsIAccessibleRole::ROLE_EQUATION);
28493:     }
28493:   }
28493: 
28493:   if (!newAcc) {
 1477:     GetAccessibleForDeckChildren(aNode, getter_AddRefs(newAcc));
 1477:   }
 1477: 
    1:   // If no accessible, see if we need to create a generic accessible because
    1:   // of some property that makes this object interesting
    1:   // We don't do this for <body>, <html>, <window>, <dialog> etc. which 
    1:   // correspond to the doc accessible and will be created in any case
    1:   if (!newAcc && content->Tag() != nsAccessibilityAtoms::body && content->GetParent() && 
34904:       ((weakFrame.GetFrame() && weakFrame.GetFrame()->IsFocusable()) ||
20521:        (isHTML && nsCoreUtils::HasListener(content, NS_LITERAL_STRING("click"))) ||
11851:        HasUniversalAriaProperty(content, aWeakShell) || roleMapEntry ||
20521:        HasRelatedContent(content) || nsCoreUtils::IsXLink(content))) {
    1:     // This content is focusable or has an interesting dynamic content accessibility property.
    1:     // If it's interesting we need it in the accessibility hierarchy so that events or
    1:     // other accessibles can point to it, or so that it can hold a state, etc.
 1672:     if (isHTML) {
    1:       // Interesting HTML container which may have selectable text and/or embedded objects
34904:       CreateHyperTextAccessible(weakFrame.GetFrame(), getter_AddRefs(newAcc));
    1:     }
    1:     else {  // XUL, SVG, MathML etc.
    1:       // Interesting generic non-HTML container
    1:       newAcc = new nsAccessibleWrap(aNode, aWeakShell);
    1:     }
    1:   }
    1: 
 7830:   return InitAccessible(newAcc, aAccessible, roleMapEntry);
    1: }
    1: 
 6279: PRBool
 6279: nsAccessibilityService::HasUniversalAriaProperty(nsIContent *aContent,
 6279:                                                  nsIWeakReference *aWeakShell)
 6279: {
23582:   // ARIA attributes that take token values (NMTOKEN, bool) are special cased.
23549:   return nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_atomic) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_busy) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_controls) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_describedby) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_dropeffect) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_flowto) ||
24911:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_grabbed) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_haspopup) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_invalid) ||
18793:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_label) ||
 8937:          aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_labelledby) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_live) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_owns) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_relevant) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_required) ||
23549:          nsAccUtils::HasDefinedARIAToken(aContent, nsAccessibilityAtoms::aria_sort);
 6279: }
 6279: 
    1: NS_IMETHODIMP
    1: nsAccessibilityService::GetRelevantContentNodeFor(nsIDOMNode *aNode,
    1:                                                   nsIDOMNode **aRelevantNode)
    1: {
    1:   // The method returns node that is relevant for attached accessible check.
    1:   // Sometimes element that is XBL widget hasn't accessible children in
    1:   // anonymous content. This method check whether given node can be accessible
    1:   // by looking through all nested bindings that given node is anonymous for. If
    1:   // there is XBL widget that deniedes to be accessible for given node then the
    1:   // method returns that XBL widget otherwise it returns given node.
    1: 
    1:   // For example, the algorithm allows us to handle following cases:
    1:   // 1. xul:dialog element has buttons (like 'ok' and 'cancel') in anonymous
    1:   // content. When node is dialog's button then we dialog's button since button
    1:   // of xul:dialog is accessible anonymous node.
    1:   // 2. xul:texbox has html:input in anonymous content. When given node is
    1:   // html:input elmement then we return xul:textbox since xul:textbox doesn't
    1:   // allow accessible nodes in anonymous content.
    1:   // 3. xforms:input that is hosted in xul document contains xul:textbox
    1:   // element. When given node is html:input or xul:textbox then we return
    1:   // xforms:input element since xforms:input hasn't accessible anonymous
    1:   // children.
    1: 
    1:   NS_ENSURE_ARG(aNode);
    1:   NS_ENSURE_ARG_POINTER(aRelevantNode);
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1:   if (content) {
    1:     // Build stack of binding parents so we can walk it in reverse.
    1:     nsIContent *bindingParent;
    1:     nsCOMArray<nsIContent> bindingsStack;
    1: 
    1:     for (bindingParent = content->GetBindingParent(); bindingParent != nsnull &&
    1:          bindingParent != bindingParent->GetBindingParent();
    1:          bindingParent = bindingParent->GetBindingParent()) {
    1:       bindingsStack.AppendObject(bindingParent);
    1:     }
    1: 
    1:     PRInt32 bindingsCount = bindingsStack.Count();
    1:     for (PRInt32 index = bindingsCount - 1; index >= 0 ; index--) {
    1:       bindingParent = bindingsStack[index];
    1:       nsCOMPtr<nsIDOMNode> bindingNode(do_QueryInterface(bindingParent));
    1:       if (bindingNode) {
    1:         // Try to get an accessible by type since XBL widget can be accessible
    1:         // only if it implements nsIAccessibleProvider interface.
    1:         nsCOMPtr<nsIAccessible> accessible;
    1:         rv = GetAccessibleByType(bindingNode, getter_AddRefs(accessible));
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
29320:           nsRefPtr<nsAccessible> acc(nsAccUtils::QueryAccessible(accessible));
29320:           if (acc) {
29320:             PRBool allowsAnonChildren = acc->GetAllowsAnonChildAccessibles();
    1:             if (!allowsAnonChildren) {
    1:               NS_ADDREF(*aRelevantNode = bindingNode);
    1:               return NS_OK;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aRelevantNode = aNode);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsAccessibilityService::GetAccessibleByType(nsIDOMNode *aNode,
    1:                                                      nsIAccessible **aAccessible)
    1: {
    1:   NS_ENSURE_ARG(aNode);
    1:   NS_ENSURE_ARG_POINTER(aAccessible);
    1: 
    1:   *aAccessible = nsnull;
    1: 
 1477:   nsCOMPtr<nsIAccessibleProvider> accessibleProvider(do_QueryInterface(aNode));
 1477:   if (!accessibleProvider)
    1:     return NS_OK;
    1: 
    1:   PRInt32 type;
 1477:   nsresult rv = accessibleProvider->GetAccessibleType(&type);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (type == nsIAccessibleProvider::OuterDoc)
    1:     return CreateOuterDocAccessible(aNode, aAccessible);
    1: 
    1:   nsCOMPtr<nsIWeakReference> weakShell;
    1:   GetShellFromNode(aNode, getter_AddRefs(weakShell));
    1: 
    1:   switch (type)
    1:   {
    1: #ifdef MOZ_XUL
10594:     case nsIAccessibleProvider::NoAccessible:
10594:       return NS_OK;
    1:     // XUL controls
    1:     case nsIAccessibleProvider::XULAlert:
    1:       *aAccessible = new nsXULAlertAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULButton:
    1:       *aAccessible = new nsXULButtonAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULCheckbox:
    1:       *aAccessible = new nsXULCheckboxAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULColorPicker:
    1:       *aAccessible = new nsXULColorPickerAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULColorPickerTile:
    1:       *aAccessible = new nsXULColorPickerTileAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULCombobox:
    1:       *aAccessible = new nsXULComboboxAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULDropmarker:
    1:       *aAccessible = new nsXULDropmarkerAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULGroupbox:
    1:       *aAccessible = new nsXULGroupboxAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULImage:
    1:     {
    1:       // Don't include nameless images in accessible tree
    1:       nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(aNode));
    1:       if (!elt)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       PRBool hasTextEquivalent;
    1:       // Prefer value over tooltiptext
    1:       elt->HasAttribute(NS_LITERAL_STRING("tooltiptext"), &hasTextEquivalent);
    1:       if (!hasTextEquivalent)
    1:         return NS_OK;
    1: 
 1306:       *aAccessible = new nsHTMLImageAccessibleWrap(aNode, weakShell);
    1:       break;
    1:     }
    1:     case nsIAccessibleProvider::XULLink:
    1:       *aAccessible = new nsXULLinkAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULListbox:
32381:       *aAccessible = new nsXULListboxAccessibleWrap(aNode, weakShell);
    1:       break;
11854:     case nsIAccessibleProvider::XULListCell:
32381:       *aAccessible = new nsXULListCellAccessibleWrap(aNode, weakShell);
11854:       break;
 6094:     case nsIAccessibleProvider::XULListHead:
 6094:       *aAccessible = new nsXULColumnsAccessible(aNode, weakShell);
 6094:       break;
 6094:     case nsIAccessibleProvider::XULListHeader:
 6094:       *aAccessible = new nsXULColumnItemAccessible(aNode, weakShell);
 6094:       break;
    1:     case nsIAccessibleProvider::XULListitem:
    1:       *aAccessible = new nsXULListitemAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULMenubar:
    1:       *aAccessible = new nsXULMenubarAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULMenuitem:
    1:       *aAccessible = new nsXULMenuitemAccessibleWrap(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULMenupopup:
    1:     {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:       // ATK considers this node to be redundant when within menubars, and it makes menu
    1:       // navigation with assistive technologies more difficult
    1:       // XXX In the future we will should this for consistency across the nsIAccessible
    1:       // implementations on each platform for a consistent scripting environment, but
    1:       // then strip out redundant accessibles in the nsAccessibleWrap class for each platform.
    1:       nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:       if (content) {
    1:         nsIContent *parent = content->GetParent();
    1:         if (parent && parent->NodeInfo()->Equals(nsAccessibilityAtoms::menu, kNameSpaceID_XUL)) {
    1:           return NS_OK;
    1:         }
    1:       }
    1: #endif
    1:       *aAccessible = new nsXULMenupopupAccessible(aNode, weakShell);
    1:       break;
    1:     }
    1:     case nsIAccessibleProvider::XULMenuSeparator:
    1:       *aAccessible = new nsXULMenuSeparatorAccessible(aNode, weakShell);
    1:       break;
10594:     case nsIAccessibleProvider::XULPane:
10594:       *aAccessible = new nsEnumRoleAccessible(aNode, weakShell, nsIAccessibleRole::ROLE_PANE);
10594:       break;
    1:     case nsIAccessibleProvider::XULProgressMeter:
    1:       *aAccessible = new nsXULProgressMeterAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULStatusBar:
    1:       *aAccessible = new nsXULStatusBarAccessible(aNode, weakShell);
    1:       break;
 4274:     case nsIAccessibleProvider::XULScale:
 4274:       *aAccessible = new nsXULSliderAccessible(aNode, weakShell);
 4274:       break;
    1:     case nsIAccessibleProvider::XULRadioButton:
    1:       *aAccessible = new nsXULRadioButtonAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULRadioGroup:
    1:       *aAccessible = new nsXULRadioGroupAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULTab:
    1:       *aAccessible = new nsXULTabAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULTabBox:
    1:       *aAccessible = new nsXULTabBoxAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULTabs:
    1:       *aAccessible = new nsXULTabsAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULText:
    1:       *aAccessible = new nsXULTextAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULTextBox:
    1:       *aAccessible = new nsXULTextFieldAccessible(aNode, weakShell);
    1:       break;
 4274:     case nsIAccessibleProvider::XULThumb:
 4274:       *aAccessible = new nsXULThumbAccessible(aNode, weakShell);
 4274:       break;
    1:     case nsIAccessibleProvider::XULTree:
31673:       return GetAccessibleForXULTree(aNode, weakShell, aAccessible);
    1:     case nsIAccessibleProvider::XULTreeColumns:
32381:       *aAccessible = new nsXULTreeColumnsAccessible(aNode, weakShell);
    1:       break;
 6094:     case nsIAccessibleProvider::XULTreeColumnItem:
 6094:       *aAccessible = new nsXULColumnItemAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULToolbar:
    1:       *aAccessible = new nsXULToolbarAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULToolbarSeparator:
    1:       *aAccessible = new nsXULToolbarSeparatorAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XULTooltip:
    1:       *aAccessible = new nsXULTooltipAccessible(aNode, weakShell);
    1:       break;
 3325:     case nsIAccessibleProvider::XULToolbarButton:
 3325:       *aAccessible = new nsXULToolbarButtonAccessible(aNode, weakShell);
 3325:       break;
    1: #endif // MOZ_XUL
    1: 
    1: #ifndef DISABLE_XFORMS_HOOKS
    1:     // XForms elements
    1:     case nsIAccessibleProvider::XFormsContainer:
    1:       *aAccessible = new nsXFormsContainerAccessible(aNode, weakShell);
    1:       break;
    1: 
    1:     case nsIAccessibleProvider::XFormsLabel:
    1:       *aAccessible = new nsXFormsLabelAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsOuput:
    1:       *aAccessible = new nsXFormsOutputAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsTrigger:
    1:       *aAccessible = new nsXFormsTriggerAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsInput:
    1:       *aAccessible = new nsXFormsInputAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsInputBoolean:
    1:       *aAccessible = new nsXFormsInputBooleanAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsInputDate:
    1:       *aAccessible = new nsXFormsInputDateAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsSecret:
    1:       *aAccessible = new nsXFormsSecretAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsSliderRange:
    1:       *aAccessible = new nsXFormsRangeAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsSelect:
    1:       *aAccessible = new nsXFormsSelectAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsChoices:
    1:       *aAccessible = new nsXFormsChoicesAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsSelectFull:
    1:       *aAccessible = new nsXFormsSelectFullAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsItemCheckgroup:
    1:       *aAccessible = new nsXFormsItemCheckgroupAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsItemRadiogroup:
    1:       *aAccessible = new nsXFormsItemRadiogroupAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsSelectCombobox:
    1:       *aAccessible = new nsXFormsSelectComboboxAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsItemCombobox:
    1:       *aAccessible = new nsXFormsItemComboboxAccessible(aNode, weakShell);
    1:       break;
    1: 
    1:     case nsIAccessibleProvider::XFormsDropmarkerWidget:
    1:       *aAccessible = new nsXFormsDropmarkerWidgetAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsCalendarWidget:
    1:       *aAccessible = new nsXFormsCalendarWidgetAccessible(aNode, weakShell);
    1:       break;
    1:     case nsIAccessibleProvider::XFormsComboboxPopupWidget:
    1:       *aAccessible = new nsXFormsComboboxPopupWidgetAccessible(aNode, weakShell);
    1:       break;
    1: #endif
    1: 
    1:     default:
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (!*aAccessible)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aAccessible);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibilityService::AddNativeRootAccessible(void * aAtkAccessible,  nsIAccessible **aRootAccessible)
    1: {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:   nsNativeRootAccessibleWrap* rootAccWrap =
    1:     new nsNativeRootAccessibleWrap((AtkObject*)aAtkAccessible);
    1: 
 3233:   *aRootAccessible = static_cast<nsIAccessible*>(rootAccWrap);
    1:   NS_ADDREF(*aRootAccessible);
    1: 
 2063:   nsRefPtr<nsApplicationAccessibleWrap> appRoot =
 2063:     nsAccessNode::GetApplicationAccessible();
 2063:   NS_ENSURE_STATE(appRoot);
 2063: 
    1:   appRoot->AddRootAccessible(*aRootAccessible);
    1: 
    1:   return NS_OK;
    1: #else
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibilityService::RemoveNativeRootAccessible(nsIAccessible * aRootAccessible)
    1: {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:   void* atkAccessible;
    1:   aRootAccessible->GetNativeInterface(&atkAccessible);
    1: 
 2063:   nsRefPtr<nsApplicationAccessibleWrap> appRoot =
 2063:     nsAccessNode::GetApplicationAccessible();
 2063:   NS_ENSURE_STATE(appRoot);
 2063: 
    1:   appRoot->RemoveRootAccessible(aRootAccessible);
    1: 
    1:   return NS_OK;
    1: #else
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: #endif
    1: }
    1: 
    1: // Called from layout when the frame tree owned by a node changes significantly
32336: NS_IMETHODIMP
32336: nsAccessibilityService::InvalidateSubtreeFor(nsIPresShell *aShell,
    1:                                              nsIContent *aChangeContent,
32336:                                              PRUint32 aChangeType)
    1: {
32336:   NS_ASSERTION(aChangeType == nsIAccessibilityService::FRAME_SIGNIFICANT_CHANGE ||
32336:                aChangeType == nsIAccessibilityService::FRAME_SHOW ||
32336:                aChangeType == nsIAccessibilityService::FRAME_HIDE ||
32336:                aChangeType == nsIAccessibilityService::NODE_SIGNIFICANT_CHANGE ||
32336:                aChangeType == nsIAccessibilityService::NODE_APPEND ||
32336:                aChangeType == nsIAccessibilityService::NODE_REMOVE,
    1:                "Incorrect aEvent passed in");
    1: 
 5395:   NS_ENSURE_ARG_POINTER(aShell);
32336: 
    1:   nsCOMPtr<nsIAccessibleDocument> accessibleDoc =
 8471:     nsAccessNode::GetDocAccessibleFor(aShell->GetDocument());
29564:   nsRefPtr<nsDocAccessible> docAcc =
29564:     nsAccUtils::QueryAccessibleDocument(accessibleDoc);
29564:   if (docAcc)
32336:     docAcc->InvalidateCacheSubtree(aChangeContent, aChangeType);
29564: 
    1:   return NS_OK;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: //////////////////////////////////////////////////////////////////////
    1: 
    1: nsresult 
    1: nsAccessibilityService::GetAccessibilityService(nsIAccessibilityService** aResult)
    1: {
30820:   NS_ENSURE_TRUE(aResult, NS_ERROR_NULL_POINTER);
30820:   *aResult = nsnull;
    1: 
30820:   if (!gAccessibilityService) {
    1:     gAccessibilityService = new nsAccessibilityService();
30820:     NS_ENSURE_TRUE(gAccessibilityService, NS_ERROR_OUT_OF_MEMORY);
30820: 
30820:     gIsShutdown = PR_FALSE;
    1:   }
30820: 
30820:   NS_ADDREF(*aResult = gAccessibilityService);
30820:   return NS_OK;
    1: }
30820: 
30820: nsIAccessibilityService*
30820: nsAccessibilityService::GetAccessibilityService()
30820: {
30820:   NS_ASSERTION(!gIsShutdown,
30820:                "Going to deal with shutdown accessibility service!");
30820:   return gAccessibilityService;
    1: }
    1: 
    1: nsresult
    1: NS_GetAccessibilityService(nsIAccessibilityService** aResult)
    1: {
    1:   return nsAccessibilityService::GetAccessibilityService(aResult);
    1: }
    1: 
 1477: nsresult
 1477: nsAccessibilityService::GetAccessibleForDeckChildren(nsIDOMNode *aNode, nsIAccessible** aAccessible)
 1477: {
 1477:   nsCOMPtr<nsIWeakReference> weakShell;
 1477:   GetShellFromNode(aNode, getter_AddRefs(weakShell));
 1477:   NS_ENSURE_TRUE(weakShell, NS_ERROR_FAILURE);
 1477:   nsCOMPtr<nsIPresShell> shell(do_QueryReferent(weakShell));
 1477:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
 1477:   
 1477:   nsIFrame* frame = nsnull;
 1477:   nsIFrame* parentFrame = nsnull;
 1477:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
 1477: 
 1477:   if (content) {
 1477:     frame = shell->GetPrimaryFrameFor(content);
 1477:   }
 1477: 
 1477:   if (frame && (frame->GetType() == nsAccessibilityAtoms::boxFrame ||
 1477:                 frame->GetType() == nsAccessibilityAtoms::scrollFrame)) { 
 1477:     parentFrame = frame->GetParent();
 1477:     if (parentFrame && parentFrame->GetType() == nsAccessibilityAtoms::deckFrame) {
 7840:       // If deck frame is for xul:tabpanels element then the given node has
 7840:       // tabpanel accessible.
 7840:       nsCOMPtr<nsIContent> parentContent = parentFrame->GetContent();
15855: #ifdef MOZ_XUL
 7840:       if (parentContent->NodeInfo()->Equals(nsAccessibilityAtoms::tabpanels,
 7840:                                             kNameSpaceID_XUL)) {
 7840:         *aAccessible = new nsXULTabpanelAccessible(aNode, weakShell);
15855:       } else
15855: #endif
 7840:         *aAccessible =
 7840:           new nsEnumRoleAccessible(aNode, weakShell,
 7840:                                    nsIAccessibleRole::ROLE_PROPERTYPAGE);
 7840: 
 7840:       NS_ENSURE_TRUE(*aAccessible, NS_ERROR_OUT_OF_MEMORY);
 7840: 
 1477:       NS_ADDREF(*aAccessible);
 1477:     }
 1477:   }
 1477: 
 1477:   return NS_OK;
 1477: }
31673: 
31673: #ifdef MOZ_XUL
31673: nsresult
31673: nsAccessibilityService::GetAccessibleForXULTree(nsIDOMNode *aNode,
31673:                                                 nsIWeakReference *aWeakShell,
31673:                                                 nsIAccessible **aAccessible)
31673: {
31673:   nsCOMPtr<nsITreeBoxObject> treeBoxObj;
31673:   nsCoreUtils::GetTreeBoxObject(aNode, getter_AddRefs(treeBoxObj));
31673:   if (!treeBoxObj)
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   nsCOMPtr<nsITreeColumns> treeColumns;
31673:   treeBoxObj->GetColumns(getter_AddRefs(treeColumns));
31673:   if (!treeColumns)
31673:     return NS_OK;
31673: 
31673:   PRInt32 count = 0;
31673:   treeColumns->GetCount(&count);
31673:   if (count == 1) // outline of list accessible
31673:     *aAccessible = new nsXULTreeAccessible(aNode, aWeakShell);
31673:   else // table or tree table accessible
31673:     *aAccessible = new nsXULTreeGridAccessibleWrap(aNode, aWeakShell);
31673: 
31673:   if (!*aAccessible)
31673:     return NS_ERROR_OUT_OF_MEMORY;
31673: 
31673:   NS_ADDREF(*aAccessible);
31673:   return NS_OK;
31673: }
31673: #endif
