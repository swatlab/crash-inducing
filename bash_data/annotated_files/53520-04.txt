52558: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52558:  * vim: set ts=4 sw=4 et tw=99:
52558:  *
52558:  * ***** BEGIN LICENSE BLOCK *****
52558:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52558:  *
52558:  * The contents of this file are subject to the Mozilla Public License Version
52558:  * 1.1 (the "License"); you may not use this file except in compliance with
52558:  * the License. You may obtain a copy of the License at
52558:  * http://www.mozilla.org/MPL/
52558:  *
52558:  * Software distributed under the License is distributed on an "AS IS" basis,
52558:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52558:  * for the specific language governing rights and limitations under the
52558:  * License.
52558:  *
52558:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52558:  * May 28, 2008.
52558:  *
52558:  * The Initial Developer of the Original Code is
52558:  *   Brendan Eich <brendan@mozilla.org>
52558:  *
52558:  * Contributor(s):
52558:  *   David Anderson <danderson@mozilla.com>
52558:  *   David Mandelin <dmandelin@mozilla.com>
52558:  *
52558:  * Alternatively, the contents of this file may be used under the terms of
52558:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52558:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52558:  * in which case the provisions of the GPL or the LGPL are applicable instead
52558:  * of those above. If you wish to allow use of your version of this file only
52558:  * under the terms of either the GPL or the LGPL, and not to allow others to
52558:  * use your version of this file under the terms of the MPL, indicate your
52558:  * decision by deleting the provisions above and replace them with the notice
52558:  * and other provisions required by the GPL or the LGPL. If you do not delete
52558:  * the provisions above, a recipient may use your version of this file under
52558:  * the terms of any one of the MPL, the GPL or the LGPL.
52558:  *
52558:  * ***** END LICENSE BLOCK ***** */
52558: #if !defined jsjaeger_compiler_h__ && defined JS_METHODJIT
52558: #define jsjaeger_compiler_h__
52558: 
52558: #include "jscntxt.h"
52558: #include "jstl.h"
52558: #include "BytecodeAnalyzer.h"
52558: #include "MethodJIT.h"
52606: #include "CodeGenIncludes.h"
52608: #include "StubCompiler.h"
52831: #include "MonoIC.h"
52880: #include "PolyIC.h"
52558: 
52558: namespace js {
52558: namespace mjit {
52558: 
52606: class Compiler
52558: {
52558:     typedef JSC::MacroAssembler::Label Label;
52611:     typedef JSC::MacroAssembler::Imm32 Imm32;
52560:     typedef JSC::MacroAssembler::ImmPtr ImmPtr;
52560:     typedef JSC::MacroAssembler::RegisterID RegisterID;
52851:     typedef JSC::MacroAssembler::FPRegisterID FPRegisterID;
52560:     typedef JSC::MacroAssembler::Address Address;
52838:     typedef JSC::MacroAssembler::BaseIndex BaseIndex;
52599:     typedef JSC::MacroAssembler::Jump Jump;
53349:     typedef JSC::MacroAssembler::JumpList JumpList;
52611:     typedef JSC::MacroAssembler::Call Call;
52826:     typedef JSC::MacroAssembler::DataLabelPtr DataLabelPtr;
53408:     typedef JSC::MacroAssembler::DataLabel32 DataLabel32;
52558: 
52599:     struct BranchPatch {
52599:         BranchPatch(const Jump &j, jsbytecode *pc)
52599:           : jump(j), pc(pc)
52599:         { }
52599: 
52599:         Jump jump;
52599:         jsbytecode *pc;
52599:     };
52599: 
53119: #if defined JS_MONOIC
52826:     struct MICGenInfo {
53116:         MICGenInfo(ic::MICInfo::Kind kind) : kind(kind)
53116:         { }
52826:         Label entry;
52826:         Label stubEntry;
53408:         DataLabel32 shape;
53269: #if defined JS_PUNBOX64
53269:         uint32 patchValueOffset;
53269: #endif
52826:         Label load;
52826:         Call call;
53116:         ic::MICInfo::Kind kind;
53133:         jsbytecode *jumpTarget;
53515:         uint32 argc;
53515:         uint32 frameDepth;
53515:         Label knownObject;
53515:         Label callEnd;
53515:         JSC::MacroAssembler::RegisterID dataReg;
53133:         Jump traceHint;
53277:         MaybeJump slowTraceHint;
53133:         union {
53133:             struct {
52831:                 bool typeConst;
52831:                 bool dataConst;
53133:             } name;
53133:             struct {
53133:                 uint32 pcOffs;
53133:             } tracer;
53133:         } u;
52826:     };
53119: #endif
52826: 
53119: #if defined JS_POLYIC
52880:     struct PICGenInfo {
52880:         PICGenInfo(ic::PICInfo::Kind kind) : kind(kind)
52880:         { }
52880:         ic::PICInfo::Kind kind;
53270:         Label fastPathStart;
52880:         Label storeBack;
52884:         Label typeCheck;
52880:         Label slowPathStart;
52880:         RegisterID shapeReg;
52880:         RegisterID objReg;
53137:         RegisterID idReg;
52884:         RegisterID typeReg;
52880:         Label shapeGuard;
52892:         JSAtom *atom;
52880:         StateRemat objRemat;
53137:         StateRemat idRemat;
52880:         Call callReturn;
52884:         bool hasTypeCheck;
52887:         ValueRemat vr;
53315: # if defined JS_CPU_X64
53315:         ic::PICLabels labels;
53315: # endif
53137: 
53137:         void copySimpleMembersTo(ic::PICInfo &pi) const {
53137:             pi.kind = kind;
53137:             pi.shapeReg = shapeReg;
53137:             pi.objReg = objReg;
53137:             pi.atom = atom;
53137:             if (kind == ic::PICInfo::SET) {
53137:                 pi.u.vr = vr;
53137:             } else if (kind != ic::PICInfo::NAME) {
53137:                 pi.u.get.idReg = idReg;
53137:                 pi.u.get.typeReg = typeReg;
53137:                 pi.u.get.hasTypeCheck = hasTypeCheck;
53137:                 pi.u.get.objRemat = objRemat.offset;
53137:             }
53137:         }
53137: 
52880:     };
53119: #endif
52880: 
52611:     struct Defs {
52611:         Defs(uint32 ndefs)
52611:           : ndefs(ndefs)
52611:         { }
52611:         uint32 ndefs;
52611:     };
52611: 
53168:     struct InternalCallSite {
53168:         bool stub;
53168:         Label location;
53168:         jsbytecode *pc;
53168:         uint32 id;
53168:     };
53168: 
53183:     struct DoublePatch {
53183:         double d;
53183:         DataLabelPtr label;
53183:         bool ool;
53183:     };
53183: 
52558:     JSContext *cx;
52558:     JSScript *script;
52558:     JSObject *scopeChain;
52558:     JSObject *globalObj;
52560:     JSFunction *fun;
52558:     BytecodeAnalyzer analysis;
52558:     Label *jumpMap;
52558:     jsbytecode *PC;
52608:     Assembler masm;
52560:     FrameState frame;
52599:     js::Vector<BranchPatch, 64> branchPatches;
53119: #if defined JS_MONOIC
52826:     js::Vector<MICGenInfo, 64> mics;
53119: #endif
53119: #if defined JS_POLYIC
52880:     js::Vector<PICGenInfo, 64> pics;
53119: #endif
53168:     js::Vector<InternalCallSite, 64> callSites;
53183:     js::Vector<DoublePatch, 16> doubleList;
53520:     js::Vector<uint32, 16> escapingList;
52608:     StubCompiler stubcc;
52872:     Label invokeLabel;
53133:     bool addTraceHints;
52599: 
52558:   public:
52558:     // Special atom index used to indicate that the atom is 'length'. This
52558:     // follows interpreter usage in JSOP_LENGTH.
52558:     enum { LengthAtomIndex = uint32(-2) };
52558: 
52560:     Compiler(JSContext *cx, JSScript *script, JSFunction *fun, JSObject *scopeChain);
52558:     ~Compiler();
52558: 
52558:     CompileStatus Compile();
52558: 
52608:     jsbytecode *getPC() { return PC; }
52611:     Label getLabel() { return masm.label(); }
52653:     bool knownJump(jsbytecode *pc);
52653:     Label labelOf(jsbytecode *target);
53168:     void *findCallSite(const CallSite &callSite);
52608: 
52558:   private:
52558:     CompileStatus generatePrologue();
52558:     CompileStatus generateMethod();
52558:     CompileStatus generateEpilogue();
52558:     CompileStatus finishThisUp();
52560: 
52560:     /* Non-emitting helpers. */
52560:     uint32 fullAtomIndex(jsbytecode *pc);
52599:     void jumpInScript(Jump j, jsbytecode *pc);
52606:     JSC::ExecutablePool *getExecPool(size_t size);
52651:     bool compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs);
53168:     void addCallSite(uint32 id, bool stub);
52560: 
52645:     /* Emitting helpers. */
53515:     void saveReturnAddress();
53471:     void restoreReturnAddress(Assembler &masm);
53133:     void restoreFrameRegs(Assembler &masm);
52653:     void emitStubCmpOp(BoolStub stub, jsbytecode *target, JSOp fused);
53404:     void iter(uintN flags);
52737:     void iterNext();
52737:     void iterMore();
53404:     void iterEnd();
53152:     MaybeJump loadDouble(FrameEntry *fe, FPRegisterID fpReg);
52645: 
52560:     /* Opcode handlers. */
53277:     void jumpAndTrace(Jump j, jsbytecode *target, Jump *slow = NULL);
52560:     void jsop_bindname(uint32 index);
52560:     void jsop_setglobal(uint32 index);
52560:     void jsop_getglobal(uint32 index);
52743:     void jsop_getprop_slow();
52741:     void jsop_getarg(uint32 index);
52741:     void jsop_this();
52560:     void emitReturn();
52847:     void dispatchCall(VoidPtrStubUInt32 stub, uint32 argc);
53223:     void interruptCheckHelper();
52850:     void inlineCallHelper(uint32 argc, bool callingNew);
53118:     void jsop_gnameinc(JSOp op, VoidStubAtom stub, uint32 index);
52732:     void jsop_nameinc(JSOp op, VoidStubAtom stub, uint32 index);
52746:     void jsop_propinc(JSOp op, VoidStubAtom stub, uint32 index);
52815:     void jsop_eleminc(JSOp op, VoidStub);
52826:     void jsop_getgname(uint32 index);
52826:     void jsop_getgname_slow(uint32 index);
52831:     void jsop_setgname(uint32 index);
52831:     void jsop_setgname_slow(uint32 index);
52826:     void jsop_bindgname();
52838:     void jsop_setelem_slow();
52843:     void jsop_getelem_slow();
52874:     void jsop_unbrand();
52894:     void jsop_getprop(JSAtom *atom, bool typeCheck = true);
52884:     void jsop_length();
52892:     void jsop_setprop(JSAtom *atom);
52892:     void jsop_setprop_slow(JSAtom *atom);
52903:     bool jsop_callprop_slow(JSAtom *atom);
52903:     bool jsop_callprop(JSAtom *atom);
52903:     bool jsop_callprop_obj(JSAtom *atom);
52903:     bool jsop_callprop_str(JSAtom *atom);
52906:     bool jsop_callprop_generic(JSAtom *atom);
52894:     void jsop_instanceof();
53054:     void jsop_name(JSAtom *atom);
52611: 
52963:     /* Fast arithmetic. */
52963:     void jsop_binary(JSOp op, VoidStub stub);
53152:     void jsop_binary_full(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub);
53152:     void jsop_binary_full_simple(FrameEntry *fe, JSOp op, VoidStub stub);
53152:     void jsop_binary_double(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub);
52963:     void slowLoadConstantDouble(Assembler &masm, FrameEntry *fe,
52963:                                 FPRegisterID fpreg);
52963:     void maybeJumpIfNotInt32(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                              MaybeRegisterID &mreg);
52963:     void maybeJumpIfNotDouble(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                               MaybeRegisterID &mreg);
53201:     void jsop_relational(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
53201:     void jsop_relational_int(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
53201:     void jsop_relational_self(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
53201:     void jsop_relational_full(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
53201:     void jsop_relational_double(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
53201: 
53201:     void emitLeftDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                             MaybeJump &lhsNotDouble, MaybeJump &rhsNotNumber,
53201:                             MaybeJump &lhsUnknownDone);
53201:     void emitRightDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                              MaybeJump &rhsNotNumber2);
53318:     bool tryBinaryConstantFold(JSContext *cx, FrameState &frame, JSOp op,
53318:                                FrameEntry *lhs, FrameEntry *rhs);
52963: 
52617:     /* Fast opcodes. */
52617:     void jsop_bitop(JSOp op);
53230:     void jsop_rsh();
53230:     RegisterID rightRegForShift(FrameEntry *rhs);
53230:     void jsop_rsh_int_int(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_const_int(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_int_const(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_int_unknown(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_const_const(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_const_unknown(FrameEntry *lhs, FrameEntry *rhs);
53230:     void jsop_rsh_unknown_const(FrameEntry *lhs, FrameEntry *rhs);
53238:     void jsop_rsh_unknown_any(FrameEntry *lhs, FrameEntry *rhs);
52623:     void jsop_globalinc(JSOp op, uint32 index);
53156:     void jsop_mod();
52713:     void jsop_neg();
52724:     void jsop_bitnot();
52734:     void jsop_not();
52738:     void jsop_typeof();
53102:     void booleanJumpScript(JSOp op, jsbytecode *target);
53102:     void jsop_ifneq(JSOp op, jsbytecode *target);
53086:     void jsop_andor(JSOp op, jsbytecode *target);
52804:     void jsop_arginc(JSOp op, uint32 slot, bool popped);
52808:     void jsop_localinc(JSOp op, uint32 slot, bool popped);
52838:     void jsop_setelem();
52843:     void jsop_getelem();
53137:     void jsop_getelem_known_type(FrameEntry *obj, FrameEntry *id, RegisterID tmpReg);
53137:     void jsop_getelem_with_pic(FrameEntry *obj, FrameEntry *id, RegisterID tmpReg);
53137:     void jsop_getelem_nopic(FrameEntry *obj, FrameEntry *id, RegisterID tmpReg);
53137:     void jsop_getelem_pic(FrameEntry *obj, FrameEntry *id, RegisterID objReg, RegisterID idReg,
53137:                           RegisterID shapeReg);
53137:     void jsop_getelem_dense(FrameEntry *obj, FrameEntry *id, RegisterID objReg,
53137:                             MaybeRegisterID &idReg, RegisterID shapeReg);
52855:     void jsop_stricteq(JSOp op);
52879:     void jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
52916:     void jsop_pos();
52617: 
52611: #define STUB_CALL_TYPE(type)                                            \
53087:     Call stubCall(type stub) {                                          \
53087:         return stubCall(JS_FUNC_TO_DATA_PTR(void *, stub));             \
52611:     }
52611: 
52611:     STUB_CALL_TYPE(JSObjStub);
52611:     STUB_CALL_TYPE(VoidStubUInt32);
52617:     STUB_CALL_TYPE(VoidStub);
52645:     STUB_CALL_TYPE(VoidPtrStubUInt32);
52649:     STUB_CALL_TYPE(VoidPtrStub);
52652:     STUB_CALL_TYPE(BoolStub);
52703:     STUB_CALL_TYPE(JSObjStubUInt32);
52727:     STUB_CALL_TYPE(JSObjStubFun);
52729:     STUB_CALL_TYPE(JSObjStubJSObj);
52732:     STUB_CALL_TYPE(VoidStubAtom);
52738:     STUB_CALL_TYPE(JSStrStub);
52740:     STUB_CALL_TYPE(JSStrStubUInt32);
52785:     STUB_CALL_TYPE(VoidStubJSObj);
52793:     STUB_CALL_TYPE(VoidPtrStubPC);
52808:     STUB_CALL_TYPE(VoidVpStub);
53168:     STUB_CALL_TYPE(VoidStubPC);
52611: 
52611: #undef STUB_CALL_TYPE
53087:     void prepareStubCall(Uses uses);
53087:     Call stubCall(void *ptr);
52558: };
52558: 
52558: } /* namespace js */
52558: } /* namespace mjit */
52558: 
52558: #endif
52611: 
