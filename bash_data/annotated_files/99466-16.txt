58092: /* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
58092: /* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
58092: 
58092: #include "StorageParent.h"
58092: #include "mozilla/dom/PContentParent.h"
58092: #include "mozilla/unused.h"
58092: #include "nsDOMString.h"
58092: 
58092: using mozilla::unused;
58092: 
58092: namespace mozilla {
58092: namespace dom {
58092: 
58092: StorageParent::StorageParent(const StorageConstructData& aData)
58092: {
58092:   if (aData.type() == StorageConstructData::Tnull_t) {
58092:     mStorage = new DOMStorageImpl(nsnull);
58092:   } else {
58092:     const StorageClone& clone = aData.get_StorageClone();
58092:     StorageParent* other = static_cast<StorageParent*>(clone.actorParent());
58092:     mStorage = new DOMStorageImpl(nsnull, *other->mStorage.get());
58092:     mStorage->CloneFrom(clone.callerSecure(), other->mStorage);
58092:   }
58092: }
58092: 
58092: bool
58092: StorageParent::RecvInit(const bool& aUseDB,
58092:                         const bool& aCanUseChromePersist,
60073:                         const bool& aSessionOnly,
58092:                         const nsCString& aDomain,
58092:                         const nsCString& aScopeDBKey,
58092:                         const nsCString& aQuotaDomainDBKey,
58092:                         const nsCString& aQuotaETLDplus1DomainDBKey,
58092:                         const PRUint32& aStorageType)
58092: {
99466:   mStorage->InitFromChild(aUseDB, aCanUseChromePersist, aSessionOnly, aDomain,
60073:                           aScopeDBKey, aQuotaDomainDBKey, aQuotaETLDplus1DomainDBKey,
58092:                           aStorageType);
58092:   return true;
58092: }
58092: 
58092: bool
58092: StorageParent::RecvGetKeys(const bool& aCallerSecure, InfallibleTArray<nsString>* aKeys)
58092: {
58092:   // Callers are responsible for deallocating the array returned by mStorage->GetKeys
58092:   nsAutoPtr<nsTArray<nsString> > keys(mStorage->GetKeys(aCallerSecure));
58092:   aKeys->SwapElements(*keys);
58092:   return true;
58092: }
58092: 
58092: bool
60073: StorageParent::RecvGetLength(const bool& aCallerSecure, const bool& aSessionOnly,
60073:                              PRUint32* aLength, nsresult* rv)
58092: {
60073:   mStorage->SetSessionOnly(aSessionOnly);
58092:   *rv = mStorage->GetLength(aCallerSecure, aLength);
58092:   return true;
58092: }
58092: 
58092: bool
60073: StorageParent::RecvGetKey(const bool& aCallerSecure, const bool& aSessionOnly,
60073:                           const PRUint32& aIndex, nsString* aKey, nsresult* rv)
58092: {
60073:   mStorage->SetSessionOnly(aSessionOnly);
58092:   *rv = mStorage->GetKey(aCallerSecure, aIndex, *aKey);
58092:   return true;
58092: }
58092: 
58092: bool
60073: StorageParent::RecvGetValue(const bool& aCallerSecure, const bool& aSessionOnly,
60073:                             const nsString& aKey, StorageItem* aItem,
60073:                             nsresult* rv)
58092: {
60073:   mStorage->SetSessionOnly(aSessionOnly);
60073: 
58092:   // We need to ensure that a proper null representation is sent to the child
58092:   // if no item is found or an error occurs.
58092: 
58092:   *rv = NS_OK;
58092:   nsCOMPtr<nsIDOMStorageItem> item = mStorage->GetValue(aCallerSecure, aKey, rv);
58092:   if (NS_FAILED(*rv) || !item) {
58092:     *aItem = null_t();
58092:     return true;
58092:   }
58092: 
58092:   ItemData data(EmptyString(), false);
58092:   nsDOMStorageItem* internalItem = static_cast<nsDOMStorageItem*>(item.get());
58092:   data.value() = internalItem->GetValueInternal();
58092:   if (aCallerSecure)
58092:     data.secure() = internalItem->IsSecure();
58092:   *aItem = data;
58092:   return true;
58092: }
58092: 
58092: bool
60073: StorageParent::RecvSetValue(const bool& aCallerSecure, const bool& aSessionOnly,
60073:                             const nsString& aKey, const nsString& aData,
60073:                             nsString* aOldValue, nsresult* rv)
58092: {
60073:   mStorage->SetSessionOnly(aSessionOnly);
58092:   *rv = mStorage->SetValue(aCallerSecure, aKey, aData, *aOldValue);
58092:   return true;
58092: }
58092: 
58092: bool
60073: StorageParent::RecvRemoveValue(const bool& aCallerSecure, const bool& aSessionOnly,
60073:                                const nsString& aKey, nsString* aOldValue,
60073:                                nsresult* rv)
58092: {
60073:   mStorage->SetSessionOnly(aSessionOnly);
58092:   *rv = mStorage->RemoveValue(aCallerSecure, aKey, *aOldValue);
58092:   return true;
58092: }
58092: 
58092: bool
60073: StorageParent::RecvClear(const bool& aCallerSecure, const bool& aSessionOnly,
60073:                          PRInt32* aOldCount, nsresult* rv)
58092: {
60073:   mStorage->SetSessionOnly(aSessionOnly);
58092:   *rv = mStorage->Clear(aCallerSecure, aOldCount);
58092:   return true;
58092: }
58092: 
58092: bool
58092: StorageParent::RecvGetDBValue(const nsString& aKey, nsString* aValue,
79445:                               bool* aSecure, nsresult* rv)
58092: {
58092:   *rv = mStorage->GetDBValue(aKey, *aValue, aSecure);
58092:   return true;
58092: }
58092: 
58092: bool
58092: StorageParent::RecvSetDBValue(const nsString& aKey, const nsString& aValue,
79445:                               const bool& aSecure, nsresult* rv)
58092: {
58092:   *rv = mStorage->SetDBValue(aKey, aValue, aSecure);
58092:   return true;
58092: }
58092: 
58092: bool
79445: StorageParent::RecvSetSecure(const nsString& aKey, const bool& aSecure,
58092:                              nsresult* rv)
58092: {
58092:   *rv = mStorage->SetSecure(aKey, aSecure);
58092:   return true;
58092: }
58092: 
58092: }
58092: }
