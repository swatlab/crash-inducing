10286: /* -*- Mode: IDL; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Nate Nielsen <nielsen@memberwebs.com> 
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* The core XPConnect public interfaces. */
    1: 
    1: #include "nsISupports.idl"
    1: #include "nsIClassInfo.idl"
    1: #include "xpccomponents.idl"
    1: #include "xpcjsid.idl"
    1: #include "xpcexception.idl"
    1: #include "nsIInterfaceInfo.idl"
    1: #include "nsIInterfaceInfoManager.idl"
    1: #include "nsIExceptionService.idl"
    1: #include "nsIVariant.idl"
    1: 
    1: %{ C++
    1: #include "jspubtd.h"
    1: #include "xptinfo.h"
10286: #include "nsAXPCNativeCallContext.h"
    1: %}
    1: 
    1: /***************************************************************************/
    1: 
    1: [ptr] native JSContextPtr(JSContext);
    1: [ptr] native JSObjectPtr(JSObject);
    1: [ptr] native JSValPtr(jsval);
    1:       native JSVal(jsval);
 8990: [ptr] native JSClassConstPtr(const JSClass);
 8990:       native JSGetObjectOps(JSGetObjectOps);
    1:       native JSID(jsid);
    1: [ptr] native voidPtrPtr(void*);
 7230: [ptr] native nsScriptObjectTracerPtr(nsScriptObjectTracer);
 7286: [ref] native nsCCTraversalCallbackRef(nsCycleCollectionTraversalCallback);
10286: [ptr] native nsAXPCNativeCallContextPtr(nsAXPCNativeCallContext);
    1: 
    1: /***************************************************************************/
    1: 
    1: %{ C++
    1: /***************************************************************************/
    1: #define GENERATE_XPC_FAILURE(x) \
    1:             (NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_XPCONNECT,x))
    1: 
    1: #define NS_ERROR_XPC_NOT_ENOUGH_ARGS                   GENERATE_XPC_FAILURE( 1)
    1: #define NS_ERROR_XPC_NEED_OUT_OBJECT                   GENERATE_XPC_FAILURE( 2)
    1: #define NS_ERROR_XPC_CANT_SET_OUT_VAL                  GENERATE_XPC_FAILURE( 3)
    1: #define NS_ERROR_XPC_NATIVE_RETURNED_FAILURE           GENERATE_XPC_FAILURE( 4)
    1: #define NS_ERROR_XPC_CANT_GET_INTERFACE_INFO           GENERATE_XPC_FAILURE( 5)
    1: #define NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO         GENERATE_XPC_FAILURE( 6)
    1: #define NS_ERROR_XPC_CANT_GET_METHOD_INFO              GENERATE_XPC_FAILURE( 7)
    1: #define NS_ERROR_XPC_UNEXPECTED                        GENERATE_XPC_FAILURE( 8)
    1: #define NS_ERROR_XPC_BAD_CONVERT_JS                    GENERATE_XPC_FAILURE( 9)
    1: #define NS_ERROR_XPC_BAD_CONVERT_NATIVE                GENERATE_XPC_FAILURE(10)
    1: #define NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF           GENERATE_XPC_FAILURE(11)
    1: #define NS_ERROR_XPC_BAD_OP_ON_WN_PROTO                GENERATE_XPC_FAILURE(12)
    1: #define NS_ERROR_XPC_CANT_CONVERT_WN_TO_FUN            GENERATE_XPC_FAILURE(13)
    1: #define NS_ERROR_XPC_CANT_DEFINE_PROP_ON_WN            GENERATE_XPC_FAILURE(14)
    1: #define NS_ERROR_XPC_CANT_WATCH_WN_STATIC              GENERATE_XPC_FAILURE(15)
    1: #define NS_ERROR_XPC_CANT_EXPORT_WN_STATIC             GENERATE_XPC_FAILURE(16)
    1: #define NS_ERROR_XPC_SCRIPTABLE_CALL_FAILED            GENERATE_XPC_FAILURE(17)
    1: #define NS_ERROR_XPC_SCRIPTABLE_CTOR_FAILED            GENERATE_XPC_FAILURE(18)
    1: #define NS_ERROR_XPC_CANT_CALL_WO_SCRIPTABLE           GENERATE_XPC_FAILURE(19)
    1: #define NS_ERROR_XPC_CANT_CTOR_WO_SCRIPTABLE           GENERATE_XPC_FAILURE(20)
    1: #define NS_ERROR_XPC_CI_RETURNED_FAILURE               GENERATE_XPC_FAILURE(21)
    1: #define NS_ERROR_XPC_GS_RETURNED_FAILURE               GENERATE_XPC_FAILURE(22)
    1: #define NS_ERROR_XPC_BAD_CID                           GENERATE_XPC_FAILURE(23)
    1: #define NS_ERROR_XPC_BAD_IID                           GENERATE_XPC_FAILURE(24)
    1: #define NS_ERROR_XPC_CANT_CREATE_WN                    GENERATE_XPC_FAILURE(25)
    1: #define NS_ERROR_XPC_JS_THREW_EXCEPTION                GENERATE_XPC_FAILURE(26)
    1: #define NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT            GENERATE_XPC_FAILURE(27)
    1: #define NS_ERROR_XPC_JS_THREW_JS_OBJECT                GENERATE_XPC_FAILURE(28)
    1: #define NS_ERROR_XPC_JS_THREW_NULL                     GENERATE_XPC_FAILURE(29)
    1: #define NS_ERROR_XPC_JS_THREW_STRING                   GENERATE_XPC_FAILURE(30)
    1: #define NS_ERROR_XPC_JS_THREW_NUMBER                   GENERATE_XPC_FAILURE(31)
    1: #define NS_ERROR_XPC_JAVASCRIPT_ERROR                  GENERATE_XPC_FAILURE(32)
    1: #define NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS     GENERATE_XPC_FAILURE(33)
    1: #define NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY   GENERATE_XPC_FAILURE(34)
    1: #define NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY      GENERATE_XPC_FAILURE(35)
    1: #define NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY      GENERATE_XPC_FAILURE(36)
    1: #define NS_ERROR_XPC_CANT_GET_ARRAY_INFO               GENERATE_XPC_FAILURE(37)
    1: #define NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING        GENERATE_XPC_FAILURE(38)
    1: #define NS_ERROR_XPC_SECURITY_MANAGER_VETO             GENERATE_XPC_FAILURE(39)
    1: #define NS_ERROR_XPC_INTERFACE_NOT_SCRIPTABLE          GENERATE_XPC_FAILURE(40)
    1: #define NS_ERROR_XPC_INTERFACE_NOT_FROM_NSISUPPORTS    GENERATE_XPC_FAILURE(41)
    1: #define NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT   GENERATE_XPC_FAILURE(42)
    1: #define NS_ERROR_XPC_CANT_SET_READ_ONLY_CONSTANT       GENERATE_XPC_FAILURE(43)
    1: #define NS_ERROR_XPC_CANT_SET_READ_ONLY_ATTRIBUTE      GENERATE_XPC_FAILURE(44)
    1: #define NS_ERROR_XPC_CANT_SET_READ_ONLY_METHOD         GENERATE_XPC_FAILURE(45)
    1: #define NS_ERROR_XPC_CANT_ADD_PROP_TO_WRAPPED_NATIVE   GENERATE_XPC_FAILURE(46)
    1: #define NS_ERROR_XPC_CALL_TO_SCRIPTABLE_FAILED         GENERATE_XPC_FAILURE(47)
    1: #define NS_ERROR_XPC_JSOBJECT_HAS_NO_FUNCTION_NAMED    GENERATE_XPC_FAILURE(48)
    1: #define NS_ERROR_XPC_BAD_ID_STRING                     GENERATE_XPC_FAILURE(49)
    1: #define NS_ERROR_XPC_BAD_INITIALIZER_NAME              GENERATE_XPC_FAILURE(50)
    1: #define NS_ERROR_XPC_HAS_BEEN_SHUTDOWN                 GENERATE_XPC_FAILURE(51)
    1: #define NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN            GENERATE_XPC_FAILURE(52)
    1: #define NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL    GENERATE_XPC_FAILURE(53)
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: // IDispatch support related errors
    1: #define NS_ERROR_XPC_COM_UNKNOWN                       GENERATE_XPC_FAILURE(54)
    1: #define NS_ERROR_XPC_COM_ERROR                         GENERATE_XPC_FAILURE(55)
    1: #define NS_ERROR_XPC_COM_INVALID_CLASS_ID              GENERATE_XPC_FAILURE(56)
    1: #define NS_ERROR_XPC_COM_CREATE_FAILED                 GENERATE_XPC_FAILURE(57)
    1: #define NS_ERROR_XPC_IDISPATCH_NOT_ENABLED             GENERATE_XPC_FAILURE(58)
    1: #endif
    1: // any new errors here should have an associated entry added in xpc.msg
    1: /***************************************************************************/
    1: %}
    1: 
    1: /***************************************************************************/
    1: 
    1: // forward declarations...
    1: interface nsIXPCScriptable;
    1: interface nsIXPConnect;
    1: interface nsIXPConnectWrappedNative;
    1: interface nsIInterfaceInfo;
    1: interface nsIXPCSecurityManager;
    1: interface nsIPrincipal;
    1: 
    1: %{C++
 7286: class nsCycleCollectionTraversalCallback;
 7230: class nsScriptObjectTracer;
    1: %}
    1: 
    1: /***************************************************************************/
    1: [uuid(8916a320-d118-11d3-8f3a-0010a4e73d9a)]
    1: interface nsIXPConnectJSObjectHolder : nsISupports
    1: {
    1:     readonly attribute JSObjectPtr      JSObject;
    1: };
    1: 
    1: [uuid(7021D99D-6344-4CC0-96E7-943ED58792B8)]
    1: interface nsIXPConnectWrappedNative : nsIXPConnectJSObjectHolder
    1: {
    1:     /* attribute 'JSObject' inherited from nsIXPConnectJSObjectHolder */
    1:     readonly attribute nsISupports      Native;
    1:     readonly attribute JSObjectPtr      JSObjectPrototype;
    1: 
    1:     /**
    1:      * These are here as an aid to nsIXPCScriptable implementors
    1:      */
    1: 
    1:     readonly attribute nsIXPConnect XPConnect;
    1:     nsIInterfaceInfo FindInterfaceWithMember(in JSVal nameID);
    1:     nsIInterfaceInfo FindInterfaceWithName(in JSVal nameID);
    1: 
    1:     void debugDump(in short depth);
    1: 
    1:     void refreshPrototype();
    1:     /* 
    1:      * This returns a pointer into the instance and care should be taken
    1:      * to make sure the pointer is not kept past the life time of the
    1:      * object it points into.
    1:      */
    1:     voidPtrPtr GetSecurityInfoAddress();
    1: 
    1:     /*
    1:      * NOTE: Add new IDL methods _before_ the C++ block below if you
    1:      * add them.  Otherwise the vtable won't be what xpidl thinks it
    1:      * is, since GetObjectPrincipal() is virtual.
    1:      */
    1: 
    1: %{C++
    1:     /**
    1:      * Faster access to the native object from C++.  Will never return null.
    1:      */
    1:     nsISupports* Native() const { return mIdentity; }
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     /**
    1:      * Get the object principal for this wrapper.  Note that this may well end
    1:      * up being null; in that case one should seek principals elsewhere.  Null
    1:      * here does NOT indicate system principal or no principals at all, just
    1:      * that this wrapper doesn't have an intrinsic one.
    1:      */
    1:     virtual nsIPrincipal* GetObjectPrincipal() const = 0;
    1: #endif
    1:     
    1: protected:
    1:     nsISupports *mIdentity;
    1: public:
    1: %}
    1: };
    1: 
    1: %{C++
    1: #include "nsCOMPtr.h"
    1: 
    1: inline
    1: const nsQueryInterface
    1: do_QueryWrappedNative(nsIXPConnectWrappedNative *aWrappedNative)
    1: {
    1:     return nsQueryInterface(aWrappedNative->Native());
    1: }
    1: 
    1: inline
    1: const nsQueryInterfaceWithError
    1: do_QueryWrappedNative(nsIXPConnectWrappedNative *aWrappedNative,
    1:                       nsresult *aError)
    1: 
    1: {
    1:     return nsQueryInterfaceWithError(aWrappedNative->Native(), aError);
    1: }
    1: 
    1: %}
    1: 
    1: [uuid(BED52030-BCA6-11d2-BA79-00805F8A5DD7)]
    1: interface nsIXPConnectWrappedJS : nsIXPConnectJSObjectHolder
    1: {
    1:     /* attribute 'JSObject' inherited from nsIXPConnectJSObjectHolder */
    1:     readonly attribute nsIInterfaceInfo InterfaceInfo;
    1:     readonly attribute nsIIDPtr         InterfaceIID;
    1: 
    1:     void debugDump(in short depth);
    1: 
    1:     void aggregatedQueryInterface(in nsIIDRef uuid,
    1:                                   [iid_is(uuid),retval] out nsQIResult result);
    1: 
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: /**
    1:  * This is a sort of a placeholder interface. It is not intended to be
    1:  * implemented. It exists to give the nsIXPCSecurityManager an iid on
    1:  * which to gate a specific activity in XPConnect.
    1:  *
    1:  * That activity is...
    1:  *
    1:  * When JavaScript code uses a component that is itself implemeted in
    1:  * JavaScript then XPConnect will build a wrapper rather than directly
    1:  * expose the JSObject of the component. This allows components implemented
    1:  * in JavaScript to 'look' just like any other xpcom component (from the
    1:  * perspective of the JavaScript caller). This insulates the component from
    1:  * the caller and hides any properties or methods that are not part of the
    1:  * interface as declared in xpidl. Usually this is a good thing.
    1:  *
    1:  * However, in some cases it is useful to allow the JS caller access to the
    1:  * JS component's underlying implementation. In order to facilitate this
    1:  * XPConnect supports the 'wrappedJSObject' property. The caller code can do:
    1:  *
    1:  * // 'foo' is some xpcom component (that might be implemented in JS).
    1:  * try {
    1:  *   var bar = foo.wrappedJSObject;
    1:  *   if(bar) {
    1:  *      // bar is the underlying JSObject. Do stuff with it here.
    1:  *   }
    1:  * } catch(e) {
    1:  *   // security exception?
    1:  * }
    1:  *
    1:  * Recall that 'foo' above is an XPConnect wrapper, not the underlying JS
    1:  * object. The property get "foo.wrappedJSObject" will only succeed if three
    1:  * conditions are met:
    1:  *
    1:  * 1) 'foo' really is an XPConnect wrapper around a JSObject.
    1:  * 2) The underlying JSObject actually implements a "wrappedJSObject"
    1:  *    property that returns a JSObject. This is called by XPConnect. This
    1:  *    restriction allows wrapped objects to only allow access to the underlying
    1:  *    JSObject if they choose to do so. Ususally this just means that 'foo'
    1:  *    would have a property tht looks like:
    1:  *       this.wrappedJSObject = this.
    1:  * 3) The implemementation of nsIXPCSecurityManager (if installed) allows
    1:  *    a property get on the interface below. Although the JSObject need not
    1:  *    implement 'nsIXPCWrappedJSObjectGetter', XPConnect will ask the
    1:  *    security manager if it is OK for the caller to access the only method
    1:  *    in nsIXPCWrappedJSObjectGetter before allowing the activity. This fits
    1:  *    in with the security manager paradigm and makes control over accessing
    1:  *    the property on this interface the control factor for getting the
    1:  *    underlying wrapped JSObject of a JS component from JS code.
    1:  *
    1:  * Notes:
    1:  *
    1:  * a) If 'foo' above were the underlying JSObject and not a wrapper at all,
    1:  *    then this all just works and XPConnect is not part of the picture at all.
    1:  * b) One might ask why 'foo' should not just implement an interface through
    1:  *    which callers might get at the underlying object. There are three reasons:
    1:  *   i)   XPConnect would still have to do magic since JSObject is not a
    1:  *        scriptable type.
    1:  *   ii)  JS Components might use aggregation (like C++ objects) and have
    1:  *        different JSObjects for different interfaces 'within' an aggregate
    1:  *        object. But, using an additional interface only allows returning one
    1:  *        underlying JSObject. However, this allows for the possibility that
    1:  *        each of the aggregte JSObjects could return something different.
    1:  *        Note that one might do: this.wrappedJSObject = someOtherObject;
    1:  *   iii) Avoiding the explicit interface makes it easier for both the caller
    1:  *        and the component.
    1:  *
    1:  *  Anyway, some future implementation of nsIXPCSecurityManager might want
    1:  *  do special processing on 'nsIXPCSecurityManager::CanGetProperty' when
    1:  *  the interface id is that of nsIXPCWrappedJSObjectGetter.
    1:  */
    1: 
    1: [scriptable, uuid(254bb2e0-6439-11d4-8fe0-0010a4e73d9a)]
    1: interface nsIXPCWrappedJSObjectGetter : nsISupports
    1: {
    1:     readonly attribute nsISupports neverCalled;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: /*
    1:  * This interface is implemented by outside code and registered with xpconnect
    1:  * via nsIXPConnect::setFunctionThisTranslator.
    1:  *
    1:  * The reason this exists is to support calls to JavaScript event callbacks
    1:  * needed by the DOM via xpconnect from C++ code.
    1:  *
    1:  * We've added support for wrapping JS function objects as xpcom interfaces
    1:  * by declaring the given interface as a [function] interface. However, to
    1:  * support the requirements of JS event callbacks we need to call the JS
    1:  * function with the 'this' set as the JSObject for which the event is being
    1:  * fired; e.g. a form node.
    1:  *
    1:  * We've decided that for all cases we care about the appropriate 'this' object
    1:  * can be derived from the first param in the call to the callback. In the
    1:  * event handler case the first param is an event object.
    1:  *
    1:  * Though we can't change all the JS code so that it would setup its own 'this',
    1:  * we can add plugin 'helper' support to xpconnect. And that is what we have
    1:  * here.
    1:  *
    1:  * The idea is that at startup time some code that cares about this issue
    1:  * (e.g. the DOM helper code) can register a nsIXPCFunctionThisTranslator
    1:  * object with xpconnect to handle calls to [function] interfaces of a given
    1:  * iid. When xpconnect goes to invoke a method on a wrapped JSObject for
    1:  * an interface marked as [function], xpconnect will check if the first param
    1:  * of the method is an xpcom object pointer and if so it will check to see if a
    1:  * nsIXPCFunctionThisTranslator has been registered for the given iid of the
    1:  * interface being called. If so it will call the translator and get an
    1:  * interface pointer to use as the 'this' for the call. If the translator
    1:  * returns a non-null interface pointer (which it should then have addref'd
    1:  * since it is being returned as an out param), xpconnect will attempt to build
    1:  * a wrapper around the pointer and get a JSObject from that wrapper to use
    1:  * as the 'this' for the call.
    1:  *
    1:  * If a null interface pointer is returned then xpconnect will use the default
    1:  * 'this' - the same JSObject as the function object it is calling.
    1:  *
    1:  * The translator can also return a non-null aIIDOfResult to tell xpconnect what
    1:  * type of wrapper to build. If that is null then xpconnect will assume the
    1:  * wrapper should be for nsISupports. For objects that support flattening -
    1:  * i.e. expose nsIClassInfo and that interface's getInterfaces method - then
    1:  * a flattened wrapper will be created and no iid was really necessary.
    1:  *
    1:  * XXX aHideFirstParamFromJS is intended to allow the trimming of that first
    1:  * param (used to indicate 'this') from the actual call to the JS code. The JS
    1:  * DOM does not require this functionality and it is **NOT YET IMPLEMENTED**
    1:  *
    1:  */
    1: 
    1: [uuid(039ef260-2a0d-11d5-90a7-0010a4e73d9a)]
    1: interface nsIXPCFunctionThisTranslator : nsISupports
    1: {
    1:     nsISupports TranslateThis(in nsISupports        aInitialThis,
    1:                               in nsIInterfaceInfo   aInterfaceInfo,
    1:                               in PRUint16           aMethodIndex,
    1:                               out PRBool            aHideFirstParamFromJS,
    1:                               out nsIIDPtr          aIIDOfResult);
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: %{ C++
    1: // For use with the service manager
    1: // {CB6593E0-F9B2-11d2-BDD6-000064657374}
    1: #define NS_XPCONNECT_CID \
    1: { 0xcb6593e0, 0xf9b2, 0x11d2, \
    1:     { 0xbd, 0xd6, 0x0, 0x0, 0x64, 0x65, 0x73, 0x74 } }
    1: %}
    1: 
22065: [uuid(f8bf005e-3700-411c-ba0c-e018075f22a4)]
    1: interface nsIXPConnect : nsISupports
    1: {
    1: %{ C++
    1:   NS_DEFINE_STATIC_CID_ACCESSOR(NS_XPCONNECT_CID)
    1: %}
    1: 
    1:     void
    1:     initClasses(in JSContextPtr aJSContext,
    1:                 in JSObjectPtr  aGlobalJSObj);
    1: 
    1:     nsIXPConnectJSObjectHolder
    1:     initClassesWithNewWrappedGlobal(
    1:                   in JSContextPtr aJSContext,
    1:                   in nsISupports  aCOMObj,
    1:                   in nsIIDRef     aIID,
    1:                   in PRUint32     aFlags);
    1: 
    1:     const PRUint32 INIT_JS_STANDARD_CLASSES  = 1 << 0;
    1:     const PRUint32 FLAG_SYSTEM_GLOBAL_OBJECT = 1 << 1;
    1: 
    1:     /**
    1:     * wrapNative will create a new JSObject or return an existing one.
    1:     *
    1:     * The JSObject is returned inside a refcounted nsIXPConnectJSObjectHolder.
    1:     * As long as this holder is held the JSObject will be protected from
    1:     * collection by JavaScript's garbage collector. It is a good idea to
    1:     * transfer the JSObject to some equally protected place before releasing
    1:     * the holder (i.e. use JS_SetProperty to make this object a property of
    1:     * some other JSObject).
    1:     *
    1:     * This method now correctly deals with cases where the passed in xpcom
    1:     * object already has an associated JSObject for the cases:
    1:     *  1) The xpcom object has already been wrapped for use in the same scope
    1:     *     as an nsIXPConnectWrappedNative.
    1:     *  2) The xpcom object is in fact a nsIXPConnectWrappedJS and thus already
    1:     *     has an underlying JSObject.
    1:     *  3) The xpcom object implements nsIScriptObjectOwner; i.e. is an idlc
    1:     *     style DOM object for which we can call GetScriptObject to get the
    1:     *     JSObject it uses to represent itself into JavaScript.
    1:     *
    1:     * It *might* be possible to QueryInterface the nsIXPConnectJSObjectHolder
    1:     * returned by the method into a nsIXPConnectWrappedNative or a
    1:     * nsIXPConnectWrappedJS.
    1:     *
    1:     * This method will never wrap the JSObject involved in an
    1:     * XPCNativeWrapper before returning.
    1:     *
    1:     * Returns:
    1:     *    success:
    1:     *       NS_OK
    1:     *    failure:
    1:     *       NS_ERROR_XPC_BAD_CONVERT_NATIVE
    1:     *       NS_ERROR_XPC_CANT_GET_JSOBJECT_OF_DOM_OBJECT
    1:     *       NS_ERROR_FAILURE
    1:     */
    1:     nsIXPConnectJSObjectHolder
    1:     wrapNative(in JSContextPtr aJSContext,
    1:                in JSObjectPtr  aScope,
    1:                in nsISupports  aCOMObj,
    1:                in nsIIDRef     aIID);
    1: 
    1:     /**
22065:      * Same as wrapNative, but also returns the JSObject in aVal. C++ callers
22065:      * can pass in null for the aHolder argument, but in that case they must
22065:      * ensure that aVal is rooted.
22065:      */
22065:     void
22065:     wrapNativeToJSVal(in JSContextPtr aJSContext,
22065:                       in JSObjectPtr  aScope,
22065:                       in nsISupports  aCOMObj,
22071:                       in nsIIDRef     aIID,
22065:                       out JSVal       aVal,
22065:                       out nsIXPConnectJSObjectHolder aHolder);
22065: 
22065:     /**
    1:     * wrapJS will yield a new or previously existing xpcom interface pointer
    1:     * to represent the JSObject passed in.
    1:     *
    1:     * This method now correctly deals with cases where the passed in JSObject
    1:     * already has an associated xpcom interface for the cases:
    1:     *  1) The JSObject has already been wrapped as a nsIXPConnectWrappedJS.
    1:     *  2) The JSObject is in fact a nsIXPConnectWrappedNative and thus already
    1:     *     has an underlying xpcom object.
    1:     *  3) The JSObject is of a jsclass which supports getting the nsISupports
    1:     *     from the JSObject directly. This is used for idlc style objects
    1:     *     (e.g. DOM objects).
    1:     *
    1:     * It *might* be possible to QueryInterface the resulting interface pointer
    1:     * to nsIXPConnectWrappedJS.
    1:     *
    1:     * Returns:
    1:     *   success:
    1:     *     NS_OK
    1:     *    failure:
    1:     *       NS_ERROR_XPC_BAD_CONVERT_JS
    1:     *       NS_ERROR_FAILURE
    1:     */
    1:     void
    1:     wrapJS(in JSContextPtr aJSContext,
    1:            in JSObjectPtr  aJSObj,
    1:            in nsIIDRef     aIID,
    1:            [iid_is(aIID),retval] out nsQIResult result);
    1: 
    1:     /**
    1:     * This only succeeds if the JSObject is a nsIXPConnectWrappedNative.
    1:     * A new wrapper is *never* constructed.
    1:     */
    1:     nsIXPConnectWrappedNative
    1:     getWrappedNativeOfJSObject(in JSContextPtr aJSContext,
    1:                                in JSObjectPtr  aJSObj);
    1: 
    1:     void setSecurityManagerForJSContext(in JSContextPtr aJSContext,
    1:                                         in nsIXPCSecurityManager aManager,
    1:                                         in PRUint16 flags);
    1: 
    1:     void getSecurityManagerForJSContext(in JSContextPtr aJSContext,
    1:                                         out nsIXPCSecurityManager aManager,
    1:                                         out PRUint16 flags);
    1: 
    1:     /**
    1:     * The security manager to use when the current JSContext has no security
    1:     * manager.
    1:     */
    1:     void setDefaultSecurityManager(in nsIXPCSecurityManager aManager,
    1:                                    in PRUint16 flags);
    1: 
    1:     void getDefaultSecurityManager(out nsIXPCSecurityManager aManager,
    1:                                    out PRUint16 flags);
    1: 
    1:     nsIStackFrame
    1:     createStackFrameLocation(in PRUint32       aLanguage,
    1:                              in string         aFilename,
    1:                              in string         aFunctionName,
    1:                              in PRInt32        aLineNumber,
    1:                              in nsIStackFrame  aCaller);
    1: 
    1:     /**
20312:     * Deprecated do-nothing function.
    1:     */
    1:     void syncJSContexts();
    1: 
    1:     readonly attribute nsIStackFrame                CurrentJSStack;
10286:     readonly attribute nsAXPCNativeCallContextPtr   CurrentNativeCallContext;
    1:     /* pass nsnull to clear pending exception */
    1:              attribute nsIException                 PendingException;
    1: 
    1:     void debugDump(in short depth);
    1:     void debugDumpObject(in nsISupports aCOMObj, in short depth);
 5905:     void debugDumpJSStack(in PRBool showArgs,
    1:                           in PRBool showLocals,
    1:                           in PRBool showThisProps);
    1:     void debugDumpEvalInJSStackFrame(in PRUint32 aFrameNumber,
    1:                                      in string aSourceText);
    1: 
    1:     /**
    1:     * Set fallback JSContext to use when xpconnect can't find an appropriate
    1:     * context to use to execute JavaScript.
    1:     *
    1:     * NOTE: This method is DEPRECATED. 
    1:     *       Use nsIThreadJSContextStack::safeJSContext instead.
    1:     */
    1:     void setSafeJSContextForCurrentThread(in JSContextPtr cx);
    1: 
    1:     /**
    1:     * wrapJSAggregatedToNative is just like wrapJS except it is used in cases
    1:     * where the JSObject is also aggregated to some native xpcom Object.
    1:     * At present XBL is the only system that might want to do this.
    1:     *
    1:     * XXX write more!
    1:     *
    1:     * Returns:
    1:     *   success:
    1:     *     NS_OK
    1:     *    failure:
    1:     *       NS_ERROR_XPC_BAD_CONVERT_JS
    1:     *       NS_ERROR_FAILURE
    1:     */
    1:     void
    1:     wrapJSAggregatedToNative(in nsISupports  aOuter,
    1:                              in JSContextPtr aJSContext,
    1:                              in JSObjectPtr  aJSObj,
    1:                              in nsIIDRef     aIID,
    1:                              [iid_is(aIID),retval] out nsQIResult result);
    1: 
    1:     // Methods added since mozilla 0.6....
    1: 
    1:     /**
    1:     * This only succeeds if the native object is already wrapped by xpconnect.
    1:     * A new wrapper is *never* constructed.
    1:     */
    1:     nsIXPConnectWrappedNative
    1:     getWrappedNativeOfNativeObject(in JSContextPtr aJSContext,
    1:                                    in JSObjectPtr  aScope,
    1:                                    in nsISupports  aCOMObj,
    1:                                    in nsIIDRef     aIID);
    1: 
    1:     nsIXPCFunctionThisTranslator
    1:     getFunctionThisTranslator(in nsIIDRef aIID);
    1: 
    1:     nsIXPCFunctionThisTranslator
    1:     setFunctionThisTranslator(in nsIIDRef aIID,
    1:                               in nsIXPCFunctionThisTranslator aTranslator);
    1: 
    1:     nsIXPConnectJSObjectHolder
    1:     reparentWrappedNativeIfFound(in JSContextPtr aJSContext,
    1:                                  in JSObjectPtr  aScope,
    1:                                  in JSObjectPtr  aNewParent,
    1:                                  in nsISupports  aCOMObj);
    1:     void
    1:     reparentScopeAwareWrappers(in JSContextPtr aJSContext,
    1:                                in JSObjectPtr  aOldScope,
    1:                                in JSObjectPtr  aNewScope);
    1: 
    1:     void clearAllWrappedNativeSecurityPolicies();
    1: 
    1:     nsIXPConnectJSObjectHolder
    1:     getWrappedNativePrototype(in JSContextPtr aJSContext,
    1:                               in JSObjectPtr  aScope,
    1:                               in nsIClassInfo aClassInfo);
    1: 
    1:     void releaseJSContext(in JSContextPtr aJSContext, in PRBool noGC);
    1: 
    1:     JSVal variantToJS(in JSContextPtr ctx, in JSObjectPtr scope, in nsIVariant value);
    1:     nsIVariant JSToVariant(in JSContextPtr ctx, in JSVal value);
    1: 
    1:     /**
    1:      * Preconfigure XPCNativeWrapper automation so that when a scripted
    1:      * caller whose filename starts with filenamePrefix accesses a wrapped
    1:      * native that is not flagged as "system", the wrapped native will be
    1:      * automatically wrapped with an XPCNativeWrapper.
    1:      *
    1:      * @param aFilenamePrefix the UTF-8 filename prefix to match, which
    1:      *                        should end with a slash (/) character
 9531:      * @param aWantNativeWrappers whether XPConnect should produce native
 9531:      *                            wrappers for scripts whose paths begin
 9531:      *                            with this prefix
    1:      */
 9531:     void flagSystemFilenamePrefix(in string aFilenamePrefix,
 9531:                                   in PRBool aWantNativeWrappers);
    1: 
    1:     /**
    1:      * Restore an old prototype for wrapped natives of type
    1:      * aClassInfo. This should be used only when restoring an old
    1:      * scope into a state close to where it was prior to
    1:      * being reinitialized.
    1:      */
    1:     void restoreWrappedNativePrototype(in JSContextPtr aJSContext,
    1:                                        in JSObjectPtr  aScope,
    1:                                        in nsIClassInfo aClassInfo,
    1:                                        in nsIXPConnectJSObjectHolder aPrototype);
    1: 
    1:     /**
    1:      * Create a sandbox for evaluating code in isolation using
    1:      * evalInSandboxObject().
    1:      *
    1:      * @param cx A context to use when creating the sandbox object.
    1:      * @param principal The principal (or NULL to use the null principal)
    1:      *                  to use when evaluating code in this sandbox.
    1:      */
    1:     [noscript] nsIXPConnectJSObjectHolder createSandbox(in JSContextPtr cx,
    1:                                                         in nsIPrincipal principal);
    1: 
    1:     /**
    1:      * Evaluate script in a sandbox, completely isolated from all
    1:      * other running scripts.
    1:      *
    1:      * @param source The source of the script to evaluate.
    1:      * @param cx The context to use when setting up the evaluation of
    1:      *           the script. The actual evaluation will happen on a new
    1:      *           temporary context.
    1:      * @param sandbox The sandbox object to evaluate the script in.
 3573:      * @param returnStringOnly The only results to come out of the
 3573:      *                         computation (including exceptions) will
 3573:      *                         be coerced into strings created in the
 3573:      *                         sandbox.
    1:      * @return The result of the evaluation as a jsval. If the caller
    1:      *         intends to use the return value from this call the caller
    1:      *         is responsible for rooting the jsval before making a call
    1:      *         to this method.
    1:      */
    1:     [noscript] JSVal evalInSandboxObject(in AString source, in JSContextPtr cx,
 3573:                                          in nsIXPConnectJSObjectHolder sandbox,
 3573:                                          in PRBool returnStringOnly);
 4042: 
 4042:     /**
 4042:      * Wrap a jsval in a cross origin wrapper.
 4042:      * @param aJSContext A context to use to create objects.
 4042:      * @param aParent The parent to create the wrapper with.
 4042:      * @param aWrappedObj The object to wrap.
 4042:      */
 9848:     [noscript] JSVal getXOWForObject(in JSContextPtr aJSContext,
 4042:                                      in JSObjectPtr aParent,
 4042:                                      in JSObjectPtr aWrappedObj);
 7230: 
 7230:     /**
 9848:      * Tells updateXOWs to clear the scope of all of the XOWs it finds.
 9848:      */
 9848:     const PRUint32 XPC_XOW_CLEARSCOPE = 1;
 9848: 
 9848:     /**
 9848:      * Performs an operation over all of |object|'s XOWs such as clearing
 9848:      * their scopes or updating their concept of the current principal.
 9848:      *
 9848:      * @param aJSContext A context to use to perform JS operations.
 9848:      * @param aObject Which XPCWrappedNative we should find the XOWs for.
 9848:      * @param aWay What operation to perform.
 9848:      */
 9848:     [noscript] void updateXOWs(in JSContextPtr aJSContext,
 9848:                                in nsIXPConnectWrappedNative aObject,
 9848:                                in PRUint32 aWay);
 9848: 
 9848:     /**
 7230:      * Root JS objects held by aHolder.
 7230:      * @param aHolder The object that hold the JS objects that should be rooted.
 7230:      * @param aTrace The tracer for aHolder.
 7230:      */
 7230:     [noscript] void addJSHolder(in voidPtr aHolder,
 7230:                                 in nsScriptObjectTracerPtr aTracer);
 7230: 
 7230:     /**
 7230:      * Stop rooting the JS objects held by aHolder.
 7230:      * @param aHolder The object that hold the rooted JS objects.
 7230:      */
 7230:     [noscript] void removeJSHolder(in voidPtr aHolder);
 7286: 
 7286:     /**
 7286:      * Note aJSContext as a child to the cycle collector.
 7286:      * @param aJSContext The JSContext to note.
 7286:      * @param aCb The cycle collection traversal callback.
 7286:      */
 7286:     [noscript,notxpcom] void noteJSContext(in JSContextPtr aJSContext,
 7286:                                            in nsCCTraversalCallbackRef aCb);
 8990: 
 8990:     /**
 8990:      * Get the JSClass and JSGetObjectOps pointers to use for
 8990:      * identifying JSObjects that hold nsIXPConnectWrappedNative
 8990:      * pointers in their private date. See IS_WRAPPER_CLASS in
 8990:      * xpcprivate.h for details.
 8990:      */
 8990:     void GetXPCWrappedNativeJSClassInfo(out JSClassConstPtr clazz,
 8990:                                         out JSGetObjectOps ops1,
 8990:                                         out JSGetObjectOps ops2);
14170: 
14170:     /**
14170:      * Whether or not XPConnect should report all JS exceptions when returning
14170:      * from JS into C++. False by default, although any value set in the
14170:      * MOZ_REPORT_ALL_JS_EXCEPTIONS environment variable will override the value
14170:      * passed here.
14170:      */
14170:     void setReportAllJSExceptions(in boolean reportAllJSExceptions);
18543: 
18543:     /**
18543:      * Define quick stubs on the given object, @a proto.
18543:      *
18543:      * @param cx
18543:      *     A context.  Requires request.
18543:      * @param proto
18543:      *     The (newly created) prototype object for a DOM class.  The JS half
18543:      *     of an XPCWrappedNativeProto.
18543:      * @param flags
18543:      *     Property flags for the quick stub properties--should be either
18543:      *     JSPROP_ENUMERATE or 0.
18543:      * @param interfaceCount
18543:      *     The number of interfaces the class implements.
18543:      * @param interfaceArray
18543:      *     The interfaces the class implements; interfaceArray and
18543:      *     interfaceCount are like what nsIClassInfo.getInterfaces returns.
18543:      */
18543:     [noscript,notxpcom] PRBool defineDOMQuickStubs(
18543:         in JSContextPtr cx,
18543:         in JSObjectPtr proto,
18543:         in PRUint32 flags,
18543:         in PRUint32 interfaceCount,
18543:         [array, size_is(interfaceCount)] in nsIIDPtr interfaceArray);
    1: };
