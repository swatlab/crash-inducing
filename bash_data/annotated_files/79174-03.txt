35729: // Copyright (c) 2008 The Chromium Authors. All rights reserved.
35729: // Use of this source code is governed by a BSD-style license that can be
35729: // found in the LICENSE file.
35729: 
35729: #include "base/process_util.h"
35729: 
35729: #include <ctype.h>
35729: #include <dirent.h>
35729: #include <fcntl.h>
35729: #include <unistd.h>
35729: #include <string>
35729: #include <sys/types.h>
35729: #include <sys/wait.h>
35729: 
36097: #include "base/debug_util.h"
35729: #include "base/eintr_wrapper.h"
35729: #include "base/file_util.h"
35729: #include "base/logging.h"
35729: #include "base/string_tokenizer.h"
35729: #include "base/string_util.h"
35729: 
77556: #ifdef MOZ_MEMORY_ANDROID
77556: extern "C" {
77556: extern void _malloc_prefork(void);
77556: extern void _malloc_postfork(void);
77556: }
77556: #endif
77556: 
35729: namespace {
35729: 
35729: enum ParsingState {
35729:   KEY_NAME,
35729:   KEY_VALUE
35729: };
35729: 
36097: static mozilla::EnvironmentLog gProcessLog("MOZ_PROCESS_LOG");
36097: 
35729: }  // namespace
35729: 
35729: namespace base {
35729: 
35729: bool LaunchApp(const std::vector<std::string>& argv,
35729:                const file_handle_mapping_vector& fds_to_remap,
35729:                bool wait, ProcessHandle* process_handle) {
40628:   return LaunchApp(argv, fds_to_remap, environment_map(),
40628:                    wait, process_handle);
40628: }
40628: 
40628: bool LaunchApp(const std::vector<std::string>& argv,
40628:                const file_handle_mapping_vector& fds_to_remap,
40628:                const environment_map& env_vars_to_set,
54133:                bool wait, ProcessHandle* process_handle,
54133:                ProcessArchitecture arch) {
79174:   scoped_array<char*> argv_cstr(new char*[argv.size() + 1]);
79174:   // Illegal to allocate memory after fork and before execvp
79174:   InjectiveMultimap fd_shuffle1, fd_shuffle2;
79174:   fd_shuffle1.reserve(fds_to_remap.size());
79174:   fd_shuffle2.reserve(fds_to_remap.size());
79174: 
35729:   pid_t pid = fork();
35729:   if (pid < 0)
35729:     return false;
35729: 
35729:   if (pid == 0) {
35729:     for (file_handle_mapping_vector::const_iterator
35729:         it = fds_to_remap.begin(); it != fds_to_remap.end(); ++it) {
79174:       fd_shuffle1.push_back(InjectionArc(it->first, it->second, false));
79174:       fd_shuffle2.push_back(InjectionArc(it->first, it->second, false));
35729:     }
35729: 
79174:     if (!ShuffleFileDescriptors(&fd_shuffle1))
79174:       _exit(127);
35729: 
79174:     CloseSuperfluousFds(fd_shuffle2);
35729: 
40628:     for (environment_map::const_iterator it = env_vars_to_set.begin();
40628:          it != env_vars_to_set.end(); ++it) {
40628:       if (setenv(it->first.c_str(), it->second.c_str(), 1/*overwrite*/))
79174:         _exit(127);
40628:     }
40628: 
35729:     for (size_t i = 0; i < argv.size(); i++)
35729:       argv_cstr[i] = const_cast<char*>(argv[i].c_str());
35729:     argv_cstr[argv.size()] = NULL;
35729:     execvp(argv_cstr[0], argv_cstr.get());
35888:     // if we get here, we're in serious trouble and should complain loudly
36097:     DLOG(ERROR) << "FAILED TO exec() CHILD PROCESS, path: " << argv_cstr[0];
35729:     exit(127);
35729:   } else {
36097:     gProcessLog.print("==> process %d launched child process %d\n",
36038:                       GetCurrentProcId(), pid);
35729:     if (wait)
35729:       HANDLE_EINTR(waitpid(pid, 0, 0));
35729: 
35729:     if (process_handle)
35729:       *process_handle = pid;
35729:   }
35729: 
35729:   return true;
35729: }
35729: 
35729: bool LaunchApp(const CommandLine& cl,
35729:                bool wait, bool start_hidden,
35729:                ProcessHandle* process_handle) {
35729:   file_handle_mapping_vector no_files;
35729:   return LaunchApp(cl.argv(), no_files, wait, process_handle);
35729: }
35729: 
35729: NamedProcessIterator::NamedProcessIterator(const std::wstring& executable_name,
35729:                                            const ProcessFilter* filter)
35729:     : executable_name_(executable_name), filter_(filter) {
35729:   procfs_dir_ = opendir("/proc");
35729: }
35729: 
35729: NamedProcessIterator::~NamedProcessIterator() {
35729:   if (procfs_dir_) {
35729:     closedir(procfs_dir_);
35729:     procfs_dir_ = NULL;
35729:   }
35729: }
35729: 
35729: const ProcessEntry* NamedProcessIterator::NextProcessEntry() {
35729:   bool result = false;
35729:   do {
35729:     result = CheckForNextProcess();
35729:   } while (result && !IncludeEntry());
35729: 
35729:   if (result)
35729:     return &entry_;
35729: 
35729:   return NULL;
35729: }
35729: 
35729: bool NamedProcessIterator::CheckForNextProcess() {
35729:   // TODO(port): skip processes owned by different UID
35729: 
35729:   dirent* slot = 0;
35729:   const char* openparen;
35729:   const char* closeparen;
35729: 
35729:   // Arbitrarily guess that there will never be more than 200 non-process
35729:   // files in /proc.  Hardy has 53.
35729:   int skipped = 0;
35729:   const int kSkipLimit = 200;
35729:   while (skipped < kSkipLimit) {
35729:     slot = readdir(procfs_dir_);
35729:     // all done looking through /proc?
35729:     if (!slot)
35729:       return false;
35729: 
35729:     // If not a process, keep looking for one.
35729:     bool notprocess = false;
35729:     int i;
35729:     for (i = 0; i < NAME_MAX && slot->d_name[i]; ++i) {
35729:        if (!isdigit(slot->d_name[i])) {
35729:          notprocess = true;
35729:          break;
35729:        }
35729:     }
35729:     if (i == NAME_MAX || notprocess) {
35729:       skipped++;
35729:       continue;
35729:     }
35729: 
35729:     // Read the process's status.
35729:     char buf[NAME_MAX + 12];
35729:     sprintf(buf, "/proc/%s/stat", slot->d_name);
35729:     FILE *fp = fopen(buf, "r");
35729:     if (!fp)
35729:       return false;
35729:     const char* result = fgets(buf, sizeof(buf), fp);
35729:     fclose(fp);
35729:     if (!result)
35729:       return false;
35729: 
35729:     // Parse the status.  It is formatted like this:
35729:     // %d (%s) %c %d ...
35729:     // pid (name) runstate ppid
35729:     // To avoid being fooled by names containing a closing paren, scan
35729:     // backwards.
35729:     openparen = strchr(buf, '(');
35729:     closeparen = strrchr(buf, ')');
35729:     if (!openparen || !closeparen)
35729:       return false;
35729:     char runstate = closeparen[2];
35729: 
35729:     // Is the process in 'Zombie' state, i.e. dead but waiting to be reaped?
35729:     // Allowed values: D R S T Z
35729:     if (runstate != 'Z')
35729:       break;
35729: 
35729:     // Nope, it's a zombie; somebody isn't cleaning up after their children.
35729:     // (e.g. WaitForProcessesToExit doesn't clean up after dead children yet.)
35729:     // There could be a lot of zombies, can't really decrement i here.
35729:   }
35729:   if (skipped >= kSkipLimit) {
35729:     NOTREACHED();
35729:     return false;
35729:   }
35729: 
35729:   entry_.pid = atoi(slot->d_name);
35729:   entry_.ppid = atoi(closeparen + 3);
35729: 
35729:   // TODO(port): read pid's commandline's $0, like killall does.  Using the
35729:   // short name between openparen and closeparen won't work for long names!
35729:   int len = closeparen - openparen - 1;
35729:   if (len > NAME_MAX)
35729:     len = NAME_MAX;
35729:   memcpy(entry_.szExeFile, openparen + 1, len);
35729:   entry_.szExeFile[len] = 0;
35729: 
35729:   return true;
35729: }
35729: 
35729: bool NamedProcessIterator::IncludeEntry() {
35729:   // TODO(port): make this also work for non-ASCII filenames
35729:   if (WideToASCII(executable_name_) != entry_.szExeFile)
35729:     return false;
35729:   if (!filter_)
35729:     return true;
35729:   return filter_->Includes(entry_.pid, entry_.ppid);
35729: }
35729: 
35729: // To have /proc/self/io file you must enable CONFIG_TASK_IO_ACCOUNTING
35729: // in your kernel configuration.
35729: bool ProcessMetrics::GetIOCounters(IoCounters* io_counters) const {
35729:   std::string proc_io_contents;
35729:   if (!file_util::ReadFileToString(L"/proc/self/io", &proc_io_contents))
35729:     return false;
35729: 
35729:   (*io_counters).OtherOperationCount = 0;
35729:   (*io_counters).OtherTransferCount = 0;
35729: 
35729:   StringTokenizer tokenizer(proc_io_contents, ": \n");
35729:   ParsingState state = KEY_NAME;
35729:   std::string last_key_name;
35729:   while (tokenizer.GetNext()) {
35729:     switch (state) {
35729:       case KEY_NAME:
35729:         last_key_name = tokenizer.token();
35729:         state = KEY_VALUE;
35729:         break;
35729:       case KEY_VALUE:
35729:         DCHECK(!last_key_name.empty());
35729:         if (last_key_name == "syscr") {
35729:           (*io_counters).ReadOperationCount = StringToInt64(tokenizer.token());
35729:         } else if (last_key_name == "syscw") {
35729:           (*io_counters).WriteOperationCount = StringToInt64(tokenizer.token());
35729:         } else if (last_key_name == "rchar") {
35729:           (*io_counters).ReadTransferCount = StringToInt64(tokenizer.token());
35729:         } else if (last_key_name == "wchar") {
35729:           (*io_counters).WriteTransferCount = StringToInt64(tokenizer.token());
35729:         }
35729:         state = KEY_NAME;
35729:         break;
35729:     }
35729:   }
35729:   return true;
35729: }
35729: 
35729: }  // namespace base
