 67915: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 59931:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 59931: 
 59931: #ifndef jsfriendapi_h___
 59931: #define jsfriendapi_h___
 59931: 
 79734: #include "jsclass.h"
120195: #include "jscpucfg.h"
 59931: #include "jspubtd.h"
 59931: #include "jsprvtd.h"
 59931: 
 87272: #include "mozilla/GuardObjects.h"
 87272: 
121496: /*
121496:  * This macro checks if the stack pointer has exceeded a given limit. If
121496:  * |tolerance| is non-zero, it returns true only if the stack pointer has
121496:  * exceeded the limit by more than |tolerance| bytes.
121496:  */
120195: #if JS_STACK_GROWTH_DIRECTION > 0
121496: # define JS_CHECK_STACK_SIZE_WITH_TOLERANCE(limit, sp, tolerance)  \
121496:     ((uintptr_t)(sp) < (limit)+(tolerance))
120195: #else
121496: # define JS_CHECK_STACK_SIZE_WITH_TOLERANCE(limit, sp, tolerance)  \
121496:     ((uintptr_t)(sp) > (limit)-(tolerance))
120195: #endif
120195: 
121496: #define JS_CHECK_STACK_SIZE(limit, lval) JS_CHECK_STACK_SIZE_WITH_TOLERANCE(limit, lval, 0)
121496: 
 80159: extern JS_FRIEND_API(void)
 80159: JS_SetGrayGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data);
 80159: 
 59931: extern JS_FRIEND_API(JSString *)
 59931: JS_GetAnonymousString(JSRuntime *rt);
 59931: 
 67915: extern JS_FRIEND_API(JSObject *)
107154: JS_FindCompilationScope(JSContext *cx, JSRawObject obj);
 67915: 
 79734: extern JS_FRIEND_API(JSFunction *)
107154: JS_GetObjectFunction(JSRawObject obj);
 67915: 
 69223: extern JS_FRIEND_API(JSObject *)
 80154: JS_GetGlobalForFrame(JSStackFrame *fp);
 69223: 
 77353: extern JS_FRIEND_API(JSBool)
 77343: JS_SplicePrototype(JSContext *cx, JSObject *obj, JSObject *proto);
 77343: 
 77343: extern JS_FRIEND_API(JSObject *)
 77343: JS_NewObjectWithUniqueType(JSContext *cx, JSClass *clasp, JSObject *proto, JSObject *parent);
 77343: 
 84755: extern JS_FRIEND_API(uint32_t)
107154: JS_ObjectCountDynamicSlots(JSHandleObject obj);
 77343: 
 82884: extern JS_FRIEND_API(void)
 86375: JS_ShrinkGCBuffers(JSRuntime *rt);
 86375: 
 74914: extern JS_FRIEND_API(size_t)
 74914: JS_GetE4XObjectsCreated(JSContext *cx);
 74914: 
 74914: extern JS_FRIEND_API(size_t)
 74914: JS_SetProtoCalled(JSContext *cx);
 74914: 
 74914: extern JS_FRIEND_API(size_t)
 74914: JS_GetCustomIteratorCount(JSContext *cx);
 74914: 
 80351: extern JS_FRIEND_API(JSBool)
 80351: JS_NondeterministicGetWeakMapKeys(JSContext *cx, JSObject *obj, JSObject **ret);
 80351: 
 84173: /*
105788:  * Determine whether the given object is backed by a DeadObjectProxy.
105788:  *
105788:  * Such objects hold no other objects (they have no outgoing reference edges)
105788:  * and will throw if you touch them (e.g. by reading/writing a property).
105788:  */
105788: extern JS_FRIEND_API(JSBool)
105788: JS_IsDeadWrapper(JSObject *obj);
105788: 
105788: /*
 85055:  * Used by the cycle collector to trace through the shape and all
 85055:  * shapes it reaches, marking all non-shape children found in the
 85055:  * process. Uses bounded stack space.
 84173:  */
 85055: extern JS_FRIEND_API(void)
 85055: JS_TraceShapeCycleCollectorChildren(JSTracer *trc, void *shape);
 84173: 
 80213: enum {
 80213:     JS_TELEMETRY_GC_REASON,
 80213:     JS_TELEMETRY_GC_IS_COMPARTMENTAL,
 80213:     JS_TELEMETRY_GC_MS,
108222:     JS_TELEMETRY_GC_MAX_PAUSE_MS,
 80213:     JS_TELEMETRY_GC_MARK_MS,
 90410:     JS_TELEMETRY_GC_SWEEP_MS,
108222:     JS_TELEMETRY_GC_MARK_ROOTS_MS,
108222:     JS_TELEMETRY_GC_MARK_GRAY_MS,
 90410:     JS_TELEMETRY_GC_SLICE_MS,
 90410:     JS_TELEMETRY_GC_MMU_50,
 90410:     JS_TELEMETRY_GC_RESET,
 91266:     JS_TELEMETRY_GC_INCREMENTAL_DISABLED,
108692:     JS_TELEMETRY_GC_NON_INCREMENTAL,
108692:     JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS,
108692:     JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS
 80213: };
 80213: 
 80213: typedef void
 84755: (* JSAccumulateTelemetryDataCallback)(int id, uint32_t sample);
 80213: 
 80213: extern JS_FRIEND_API(void)
 80213: JS_SetAccumulateTelemetryCallback(JSRuntime *rt, JSAccumulateTelemetryDataCallback callback);
 80213: 
 78158: extern JS_FRIEND_API(JSPrincipals *)
 78158: JS_GetCompartmentPrincipals(JSCompartment *compartment);
 78158: 
102066: extern JS_FRIEND_API(void)
102066: JS_SetCompartmentPrincipals(JSCompartment *compartment, JSPrincipals *principals);
102066: 
 79734: /* Safe to call with input obj == NULL. Returns non-NULL iff obj != NULL. */
 79734: extern JS_FRIEND_API(JSObject *)
 79734: JS_ObjectToInnerObject(JSContext *cx, JSObject *obj);
 79734: 
 79734: /* Requires obj != NULL. */
 79734: extern JS_FRIEND_API(JSObject *)
 79734: JS_ObjectToOuterObject(JSContext *cx, JSObject *obj);
 79734: 
 79734: extern JS_FRIEND_API(JSObject *)
 79734: JS_CloneObject(JSContext *cx, JSObject *obj, JSObject *proto, JSObject *parent);
 79734: 
 79734: extern JS_FRIEND_API(JSBool)
106862: js_GetterOnlyPropertyStub(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, JSMutableHandleValue vp);
 79734: 
 87297: JS_FRIEND_API(void)
 87297: js_ReportOverRecursed(JSContext *maybecx);
 87297: 
 89265: #ifdef DEBUG
 89265: 
 89265: /*
 89265:  * Routines to print out values during debugging.  These are FRIEND_API to help
 89265:  * the debugger find them and to support temporarily hacking js_Dump* calls
 89265:  * into other code.
 89265:  */
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpString(JSString *str);
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpAtom(JSAtom *atom);
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpObject(JSObject *obj);
 89265: 
 89265: extern JS_FRIEND_API(void)
 89265: js_DumpChars(const jschar *s, size_t n);
 89265: #endif
 89265: 
 79734: extern JS_FRIEND_API(bool)
 79734: JS_CopyPropertiesFrom(JSContext *cx, JSObject *target, JSObject *obj);
 79734: 
 78158: extern JS_FRIEND_API(JSBool)
 78158: JS_WrapPropertyDescriptor(JSContext *cx, js::PropertyDescriptor *desc);
 78158: 
 79734: extern JS_FRIEND_API(JSBool)
101167: JS_WrapAutoIdVector(JSContext *cx, JS::AutoIdVector &props);
101167: 
101167: extern JS_FRIEND_API(JSBool)
111462: JS_EnumerateState(JSContext *cx, JSHandleObject obj, JSIterateOp enum_op,
111462:                   js::MutableHandleValue statep, js::MutableHandleId idp);
 79734: 
 91659: struct JSFunctionSpecWithHelp {
 91659:     const char      *name;
 91659:     JSNative        call;
 91659:     uint16_t        nargs;
 91659:     uint16_t        flags;
 91659:     const char      *usage;
 91659:     const char      *help;
 91659: };
 91659: 
 91659: #define JS_FN_HELP(name,call,nargs,flags,usage,help)                          \
 91659:     {name, call, nargs, (flags) | JSPROP_ENUMERATE | JSFUN_STUB_GSOPS, usage, help}
107788: #define JS_FS_HELP_END                                                        \
107788:     {NULL, NULL, 0, 0, NULL, NULL}
 91659: 
 91659: extern JS_FRIEND_API(bool)
 91659: JS_DefineFunctionsWithHelp(JSContext *cx, JSObject *obj, const JSFunctionSpecWithHelp *fs);
 91659: 
106069: typedef bool (* JS_SourceHook)(JSContext *cx, JSScript *script, jschar **src, uint32_t *length);
105947: 
105947: extern JS_FRIEND_API(void)
105947: JS_SetSourceHook(JSRuntime *rt, JS_SourceHook hook);
105947: 
 79734: namespace js {
 78158: 
121158: extern mozilla::ThreadLocal<PerThreadData *> TlsPerThreadData;
121158: 
 89261: inline JSRuntime *
 89261: GetRuntime(const JSContext *cx)
 89261: {
 89261:     return ContextFriendFields::get(cx)->runtime;
 89261: }
 89261: 
 84729: typedef bool
 84729: (* PreserveWrapperCallback)(JSContext *cx, JSObject *obj);
 84729: 
 80670:  /*
101990:   * Dump the complete object graph of heap-allocated things.
 80670:   * fp is the file for the dump output.
 80670:   */
 80670: extern JS_FRIEND_API(void)
 91339: DumpHeapComplete(JSRuntime *rt, FILE *fp);
 80670: 
 78158: class JS_FRIEND_API(AutoSwitchCompartment) {
 78158:   private:
 78158:     JSContext *cx;
 78158:     JSCompartment *oldCompartment;
 78158:   public:
 78158:     AutoSwitchCompartment(JSContext *cx, JSCompartment *newCompartment
 78158:                           JS_GUARD_OBJECT_NOTIFIER_PARAM);
107154:     AutoSwitchCompartment(JSContext *cx, JSHandleObject target JS_GUARD_OBJECT_NOTIFIER_PARAM);
 78158:     ~AutoSwitchCompartment();
 78158:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 78158: };
 78158: 
 79734: #ifdef OLD_GETTER_SETTER_METHODS
 91237: JS_FRIEND_API(JSBool) obj_defineGetter(JSContext *cx, unsigned argc, js::Value *vp);
 91237: JS_FRIEND_API(JSBool) obj_defineSetter(JSContext *cx, unsigned argc, js::Value *vp);
 79734: #endif
 79734: 
 86105: extern JS_FRIEND_API(bool)
 86105: IsSystemCompartment(const JSCompartment *compartment);
 86105: 
 86986: extern JS_FRIEND_API(bool)
 91250: IsAtomsCompartment(const JSCompartment *c);
 86986: 
 79734: /*
 79734:  * Check whether it is OK to assign an undeclared property with name
 79734:  * propname of the global object in the current script on cx.  Reports
 79734:  * an error if one needs to be reported (in particular in all cases
 79734:  * when it returns false).
 79734:  */
 79734: extern JS_FRIEND_API(bool)
 79734: CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname);
 79734: 
 82724: struct WeakMapTracer;
 82724: 
 82724: /*
 82724:  * Weak map tracer callback, called once for every binding of every
 82724:  * weak map that was live at the time of the last garbage collection.
 82724:  *
 82724:  * m will be NULL if the weak map is not contained in a JS Object.
 82724:  */
 82724: typedef void
 82724: (* WeakMapTraceCallback)(WeakMapTracer *trc, JSObject *m,
 82724:                          void *k, JSGCTraceKind kkind,
 82724:                          void *v, JSGCTraceKind vkind);
 82724: 
 82724: struct WeakMapTracer {
 89658:     JSRuntime            *runtime;
 82724:     WeakMapTraceCallback callback;
 82724: 
 89658:     WeakMapTracer(JSRuntime *rt, WeakMapTraceCallback cb)
 89658:         : runtime(rt), callback(cb) {}
 82724: };
 82724: 
 82724: extern JS_FRIEND_API(void)
 82724: TraceWeakMaps(WeakMapTracer *trc);
 82724: 
124506: extern JS_FRIEND_API(bool)
124506: GCThingIsMarkedGray(void *thing);
124506: 
124669: extern JS_FRIEND_API(bool)
124669: AreGCGrayBitsValid(JSRuntime *rt);
124669: 
124669: /*
124669:  * Unsets the gray bit for anything reachable from |thing|. |kind| should not be
124669:  * JSTRACE_SHAPE. |thing| should be non-null.
124669:  */
124669: extern JS_FRIEND_API(void)
124669: UnmarkGrayGCThingRecursively(void *thing, JSGCTraceKind kind);
120195: 
103072: typedef void
124669: (*GCThingCallback)(void *closure, void *gcthing);
103072: 
103072: extern JS_FRIEND_API(void)
124669: VisitGrayWrapperTargets(JSCompartment *comp, GCThingCallback callback, void *closure);
103072: 
119274: extern JS_FRIEND_API(JSObject *)
119274: GetWeakmapKeyDelegate(JSObject *key);
119274: 
120195: JS_FRIEND_API(JSGCTraceKind)
120195: GCThingTraceKind(void *thing);
120195: 
120195: /*
120195:  * Invoke cellCallback on every gray JS_OBJECT in the given compartment.
120195:  */
120195: extern JS_FRIEND_API(void)
124669: IterateGrayObjects(JSCompartment *compartment, GCThingCallback cellCallback, void *data);
120195: 
 79734: /*
 79734:  * Shadow declarations of JS internal structures, for access by inline access
 79734:  * functions below. Do not use these structures in any other way. When adding
 79734:  * new fields for access by inline methods, make sure to add static asserts to
 79734:  * the original header file to ensure that offsets are consistent.
 79734:  */
 79734: namespace shadow {
 79734: 
 79734: struct TypeObject {
121675:     JSObject    *proto;
 79734: };
 79734: 
 83226: struct BaseShape {
 79734:     js::Class   *clasp;
121675:     JSObject    *parent;
 83226: };
 83226: 
 83226: struct Shape {
124515:     shadow::BaseShape *base;
 83247:     jsid              _1;
 84755:     uint32_t          slotInfo;
 79734: 
 84755:     static const uint32_t FIXED_SLOTS_SHIFT = 27;
 83226: };
 83226: 
 79734: struct Object {
124515:     shadow::Shape      *shape;
124515:     shadow::TypeObject *type;
 79734:     js::Value          *slots;
 83249:     js::Value          *_1;
 79734: 
121675:     size_t numFixedSlots() const { return shape->slotInfo >> Shape::FIXED_SLOTS_SHIFT; }
 83233:     Value *fixedSlots() const {
 86976:         return (Value *)(uintptr_t(this) + sizeof(shadow::Object));
 83233:     }
 79734: 
 79734:     js::Value &slotRef(size_t slot) const {
 83233:         size_t nfixed = numFixedSlots();
 79734:         if (slot < nfixed)
 83233:             return fixedSlots()[slot];
 79734:         return slots[slot - nfixed];
 78158:     }
 79734: };
 79734: 
107791: struct Function {
107791:     Object base;
107791:     uint16_t nargs;
107792:     uint16_t flags;
107791:     /* Used only for natives */
107791:     Native native;
107791:     const JSJitInfo *jitinfo;
107791:     void *_1;
107791: };
107791: 
 89372: struct Atom {
 89372:     size_t _;
 89372:     const jschar *chars;
 89372: };
 89372: 
 79734: } /* namespace shadow */
 79734: 
 79734: extern JS_FRIEND_DATA(js::Class) AnyNameClass;
 79734: extern JS_FRIEND_DATA(js::Class) AttributeNameClass;
 79734: extern JS_FRIEND_DATA(js::Class) CallClass;
 79734: extern JS_FRIEND_DATA(js::Class) DeclEnvClass;
 79734: extern JS_FRIEND_DATA(js::Class) FunctionClass;
 79734: extern JS_FRIEND_DATA(js::Class) FunctionProxyClass;
 79734: extern JS_FRIEND_DATA(js::Class) NamespaceClass;
 79734: extern JS_FRIEND_DATA(js::Class) OuterWindowProxyClass;
 79734: extern JS_FRIEND_DATA(js::Class) ObjectProxyClass;
 79734: extern JS_FRIEND_DATA(js::Class) QNameClass;
 79734: extern JS_FRIEND_DATA(js::Class) XMLClass;
 86031: extern JS_FRIEND_DATA(js::Class) ObjectClass;
 79734: 
 79734: inline js::Class *
107154: GetObjectClass(RawObject obj)
 79734: {
 83231:     return reinterpret_cast<const shadow::Object*>(obj)->shape->base->clasp;
 79734: }
 79734: 
 79734: inline JSClass *
107154: GetObjectJSClass(RawObject obj)
 79734: {
 79734:     return js::Jsvalify(GetObjectClass(obj));
 79734: }
 79734: 
 83278: JS_FRIEND_API(bool)
107154: IsScopeObject(RawObject obj);
 83239: 
 79734: inline JSObject *
107154: GetObjectParent(RawObject obj)
 79734: {
 83239:     JS_ASSERT(!IsScopeObject(obj));
 86483:     return reinterpret_cast<shadow::Object*>(obj)->shape->base->parent;
 79734: }
 79734: 
 83239: JS_FRIEND_API(JSObject *)
107154: GetObjectParentMaybeScope(RawObject obj);
 83239: 
 83293: JS_FRIEND_API(JSObject *)
107154: GetGlobalForObjectCrossCompartment(RawObject obj);
 83293: 
 98147: JS_FRIEND_API(void)
107154: NotifyAnimationActivity(RawObject obj);
 98147: 
 83256: JS_FRIEND_API(bool)
 83256: IsOriginalScriptFunction(JSFunction *fun);
 83256: 
121515: /*
121515:  * Return the outermost enclosing function (script) of the scripted caller.
121515:  * This function returns NULL in several cases:
121515:  *  - no script is running on the context
121515:  *  - the caller is in global or eval code
121515:  * In particular, this function will "stop" its outermost search at eval() and
121515:  * thus it will really return the outermost enclosing function *since the
121515:  * innermost eval*.
121515:  */
121515: JS_FRIEND_API(JSScript *)
121515: GetOutermostEnclosingFunctionOfScriptedCaller(JSContext *cx);
121515: 
 83262: JS_FRIEND_API(JSFunction *)
 83262: DefineFunctionWithReserved(JSContext *cx, JSObject *obj, const char *name, JSNative call,
 91237:                            unsigned nargs, unsigned attrs);
 83262: 
 83262: JS_FRIEND_API(JSFunction *)
 91237: NewFunctionWithReserved(JSContext *cx, JSNative call, unsigned nargs, unsigned flags,
 83268:                         JSObject *parent, const char *name);
 83268: 
 83268: JS_FRIEND_API(JSFunction *)
 91237: NewFunctionByIdWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
 83262:                             JSObject *parent, jsid id);
 83262: 
 83262: JS_FRIEND_API(JSObject *)
 83262: InitClassWithReserved(JSContext *cx, JSObject *obj, JSObject *parent_proto,
 91237:                       JSClass *clasp, JSNative constructor, unsigned nargs,
 83262:                       JSPropertySpec *ps, JSFunctionSpec *fs,
 83262:                       JSPropertySpec *static_ps, JSFunctionSpec *static_fs);
 83262: 
 83258: JS_FRIEND_API(const Value &)
107154: GetFunctionNativeReserved(RawObject fun, size_t which);
 83258: 
 83258: JS_FRIEND_API(void)
107154: SetFunctionNativeReserved(RawObject fun, size_t which, const Value &val);
 83258: 
115022: inline bool
115022: GetObjectProto(JSContext *cx, JSObject *obj, JSObject **proto)
115022: {
115022:     js::Class *clasp = GetObjectClass(obj);
115022:     if (clasp == &js::ObjectProxyClass ||
115022:         clasp == &js::OuterWindowProxyClass ||
115022:         clasp == &js::FunctionProxyClass)
 79734:     {
115023:         return JS_GetPrototype(cx, obj, proto);
115023:     }
115023: 
115022:     *proto = reinterpret_cast<const shadow::Object*>(obj)->type->proto;
115022:     return true;
 79734: }
 79734: 
 79734: inline void *
107154: GetObjectPrivate(RawObject obj)
 79734: {
 83233:     const shadow::Object *nobj = reinterpret_cast<const shadow::Object*>(obj);
 83233:     void **addr = reinterpret_cast<void**>(&nobj->fixedSlots()[nobj->numFixedSlots()]);
 83233:     return *addr;
 79734: }
 79734: 
 79734: /*
 79734:  * Get a slot that is both reserved for object's clasp *and* is fixed (fits
 79734:  * within the maximum capacity for the object's fixed slots).
 79734:  */
 79734: inline const Value &
107154: GetReservedSlot(RawObject obj, size_t slot)
 79734: {
 83231:     JS_ASSERT(slot < JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)));
 79734:     return reinterpret_cast<const shadow::Object *>(obj)->slotRef(slot);
 79734: }
 79734: 
 87982: JS_FRIEND_API(void)
107154: SetReservedSlotWithBarrier(RawObject obj, size_t slot, const Value &value);
 87982: 
 79734: inline void
107154: SetReservedSlot(RawObject obj, size_t slot, const Value &value)
 79734: {
 83231:     JS_ASSERT(slot < JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)));
 87982:     shadow::Object *sobj = reinterpret_cast<shadow::Object *>(obj);
 87982:     if (sobj->slotRef(slot).isMarkable())
 87982:         SetReservedSlotWithBarrier(obj, slot, value);
 87982:     else
 87982:         sobj->slotRef(slot) = value;
 79734: }
 79734: 
 84755: JS_FRIEND_API(uint32_t)
107154: GetObjectSlotSpan(RawObject obj);
 80062: 
 80062: inline const Value &
107154: GetObjectSlot(RawObject obj, size_t slot)
 80062: {
 83252:     JS_ASSERT(slot < GetObjectSlotSpan(obj));
 80062:     return reinterpret_cast<const shadow::Object *>(obj)->slotRef(slot);
 80062: }
 80062: 
 89372: inline const jschar *
 89372: GetAtomChars(JSAtom *atom)
 89372: {
 89372:     return reinterpret_cast<shadow::Atom *>(atom)->chars;
 89372: }
 89372: 
 89372: inline JSLinearString *
 89372: AtomToLinearString(JSAtom *atom)
 89372: {
 89372:     return reinterpret_cast<JSLinearString *>(atom);
 89372: }
 89372: 
 79734: static inline js::PropertyOp
107154: CastAsJSPropertyOp(RawObject object)
 79734: {
 79734:     return JS_DATA_TO_FUNC_PTR(js::PropertyOp, object);
 79734: }
 79734: 
 79734: static inline js::StrictPropertyOp
107154: CastAsJSStrictPropertyOp(RawObject object)
 79734: {
 79734:     return JS_DATA_TO_FUNC_PTR(js::StrictPropertyOp, object);
 79734: }
 79734: 
 79734: JS_FRIEND_API(bool)
107154: GetPropertyNames(JSContext *cx, RawObject obj, unsigned flags, js::AutoIdVector *props);
 79734: 
 80661: JS_FRIEND_API(bool)
106724: GetGeneric(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp);
106724: 
106724: JS_FRIEND_API(bool)
 91688: StringIsArrayIndex(JSLinearString *str, uint32_t *indexp);
 80661: 
 84729: JS_FRIEND_API(void)
 84729: SetPreserveWrapperCallback(JSRuntime *rt, PreserveWrapperCallback callback);
 84729: 
 86111: JS_FRIEND_API(bool)
107154: IsObjectInContextCompartment(RawObject obj, const JSContext *cx);
 86111: 
 79734: /*
 79734:  * NB: these flag bits are encoded into the bytecode stream in the immediate
 94006:  * operand of JSOP_ITER, so don't change them without advancing vm/Xdr.h's
 94006:  * XDR_BYTECODE_VERSION.
 79734:  */
 79734: #define JSITER_ENUMERATE  0x1   /* for-in compatible hidden default iterator */
 79734: #define JSITER_FOREACH    0x2   /* return [key, value] pair rather than key */
 79734: #define JSITER_KEYVALUE   0x4   /* destructuring for-in wants [key, value] */
 79734: #define JSITER_OWNONLY    0x8   /* iterate over obj's own properties only */
 79734: #define JSITER_HIDDEN     0x10  /* also enumerate non-enumerable properties */
 89621: #define JSITER_FOR_OF     0x20  /* harmony for-of loop */
 79734: 
 89261: inline uintptr_t
 91339: GetNativeStackLimit(const JSRuntime *rt)
 89261: {
 91339:     return RuntimeFriendFields::get(rt)->nativeStackLimit;
 89261: }
 87297: 
121496: /*
121496:  * These macros report a stack overflow and run |onerror| if we are close to
121496:  * using up the C stack. The JS_CHECK_CHROME_RECURSION variant gives us a little
121496:  * extra space so that we can ensure that crucial code is able to run.
121496:  */
121496: 
 87297: #define JS_CHECK_RECURSION(cx, onerror)                              \
 87297:     JS_BEGIN_MACRO                                                              \
 87297:         int stackDummy_;                                                        \
 91339:         if (!JS_CHECK_STACK_SIZE(js::GetNativeStackLimit(js::GetRuntime(cx)), &stackDummy_)) { \
 87297:             js_ReportOverRecursed(cx);                                          \
 87297:             onerror;                                                            \
 87297:         }                                                                       \
 87297:     JS_END_MACRO
 87297: 
121496: #define JS_CHECK_CHROME_RECURSION(cx, onerror)                                  \
121496:     JS_BEGIN_MACRO                                                              \
121496:         int stackDummy_;                                                        \
121496:         if (!JS_CHECK_STACK_SIZE_WITH_TOLERANCE(js::GetNativeStackLimit(js::GetRuntime(cx)), \
121496:                                                 &stackDummy_,                   \
121496:                                                 1024 * sizeof(size_t)))         \
121496:         {                                                                       \
121496:             js_ReportOverRecursed(cx);                                          \
121496:             onerror;                                                            \
121496:         }                                                                       \
121496:     JS_END_MACRO
121496: 
 84803: JS_FRIEND_API(void)
 84803: StartPCCountProfiling(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(void)
 84803: StopPCCountProfiling(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(void)
 84803: PurgePCCounts(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(size_t)
 84803: GetPCCountScriptCount(JSContext *cx);
 84803: 
 84803: JS_FRIEND_API(JSString *)
 84803: GetPCCountScriptSummary(JSContext *cx, size_t script);
 84803: 
 84803: JS_FRIEND_API(JSString *)
 84803: GetPCCountScriptContents(JSContext *cx, size_t script);
 84803: 
103915: /*
103915:  * A call stack can be specified to the JS engine such that all JS entry/exits
103915:  * to functions push/pop an entry to/from the specified stack.
103915:  *
103915:  * For more detailed information, see vm/SPSProfiler.h
103915:  */
108148: class ProfileEntry
108148: {
103915:     /*
108148:      * All fields are marked volatile to prevent the compiler from re-ordering
108148:      * instructions. Namely this sequence:
103915:      *
108148:      *    entry[size] = ...;
108148:      *    size++;
103915:      *
108148:      * If the size modification were somehow reordered before the stores, then
108148:      * if a sample were taken it would be examining bogus information.
108148:      *
108148:      * A ProfileEntry represents both a C++ profile entry and a JS one. Both use
108148:      * the string as a description, but JS uses the sp as NULL to indicate that
108148:      * it is a JS entry. The script_ is then only ever examined for a JS entry,
108148:      * and the idx is used by both, but with different meanings.
103915:      */
108148:     const char * volatile string; // Descriptive string of this entry
108148:     void * volatile sp;           // Relevant stack pointer for the entry
108148:     JSScript * volatile script_;  // if js(), non-null script which is running
108658:     int32_t volatile idx;         // if js(), idx of pc, otherwise line number
108148: 
108148:   public:
108148:     /*
108148:      * All of these methods are marked with the 'volatile' keyword because SPS's
108148:      * representation of the stack is stored such that all ProfileEntry
108148:      * instances are volatile. These methods would not be available unless they
108148:      * were marked as volatile as well
108148:      */
108148: 
108148:     bool js() volatile {
108148:         JS_ASSERT_IF(sp == NULL, script_ != NULL);
108148:         return sp == NULL;
108148:     }
108148: 
108148:     uint32_t line() volatile { JS_ASSERT(!js()); return idx; }
108148:     JSScript *script() volatile { JS_ASSERT(js()); return script_; }
108148:     void *stackAddress() volatile { return sp; }
108148:     const char *label() volatile { return string; }
108148: 
108148:     void setLine(uint32_t line) volatile { JS_ASSERT(!js()); idx = line; }
108148:     void setLabel(const char *string) volatile { this->string = string; }
108148:     void setStackAddress(void *sp) volatile { this->sp = sp; }
108148:     void setScript(JSScript *script) volatile { script_ = script; }
108148: 
108149:     /* we can't know the layout of JSScript, so look in vm/SPSProfiler.cpp */
108149:     JS_FRIEND_API(jsbytecode *) pc() volatile;
108149:     JS_FRIEND_API(void) setPC(jsbytecode *pc) volatile;
108149: 
108148:     static size_t offsetOfString() { return offsetof(ProfileEntry, string); }
108148:     static size_t offsetOfStackAddress() { return offsetof(ProfileEntry, sp); }
108148:     static size_t offsetOfPCIdx() { return offsetof(ProfileEntry, idx); }
108148:     static size_t offsetOfScript() { return offsetof(ProfileEntry, script_); }
108658: 
108658:     /*
108658:      * The index used in the entry can either be a line number or the offset of
108658:      * a pc into a script's code. To signify a NULL pc, use a -1 index. This is
108658:      * checked against in pc() and setPC() to set/get the right pc.
108658:      */
108658:     static const int32_t NullPCIndex = -1;
103915: };
103915: 
103915: JS_FRIEND_API(void)
103915: SetRuntimeProfilingStack(JSRuntime *rt, ProfileEntry *stack, uint32_t *size,
103915:                          uint32_t max);
103915: 
104307: JS_FRIEND_API(void)
104307: EnableRuntimeProfilingStack(JSRuntime *rt, bool enabled);
104307: 
108150: JS_FRIEND_API(jsbytecode*)
108150: ProfilingGetPC(JSRuntime *rt, JSScript *script, void *ip);
108150: 
 86984: #ifdef JS_THREADSAFE
 88135: JS_FRIEND_API(void *)
 88135: GetOwnerThread(const JSContext *cx);
 87282: 
114305: JS_FRIEND_API(bool)
114305: ContextHasOutstandingRequests(const JSContext *cx);
 86984: #endif
 86984: 
 87284: JS_FRIEND_API(JSCompartment *)
 87284: GetContextCompartment(const JSContext *cx);
 87284: 
 87285: JS_FRIEND_API(bool)
 87285: HasUnrootedGlobal(const JSContext *cx);
 87285: 
 87286: typedef void
 87286: (* ActivityCallback)(void *arg, JSBool active);
 87286: 
 87286: /*
 87286:  * Sets a callback that is run whenever the runtime goes idle - the
 87286:  * last active request ceases - and begins activity - when it was
 91846:  * idle and a request begins.
 87286:  */
 87286: JS_FRIEND_API(void)
 87286: SetActivityCallback(JSRuntime *rt, ActivityCallback cb, void *arg);
 87286: 
 87277: extern JS_FRIEND_API(const JSStructuredCloneCallbacks *)
 87277: GetContextStructuredCloneCallbacks(JSContext *cx);
 87277: 
 87278: extern JS_FRIEND_API(JSVersion)
 99820: VersionSetMoarXML(JSVersion version, bool enable);
 87278: 
 87279: extern JS_FRIEND_API(bool)
 87279: CanCallContextDebugHandler(JSContext *cx);
 87279: 
 87279: extern JS_FRIEND_API(JSTrapStatus)
 87279: CallContextDebugHandler(JSContext *cx, JSScript *script, jsbytecode *bc, Value *rval);
 87279: 
 87291: extern JS_FRIEND_API(bool)
 87291: IsContextRunningJS(JSContext *cx);
 87291: 
 87293: class SystemAllocPolicy;
 87293: typedef Vector<JSCompartment*, 0, SystemAllocPolicy> CompartmentVector;
 87293: extern JS_FRIEND_API(const CompartmentVector&)
 87293: GetRuntimeCompartments(JSRuntime *rt);
 87293: 
 88182: #define GCREASONS(D)                            \
 88182:     /* Reasons internal to the JS engine */     \
 88182:     D(API)                                      \
 88182:     D(MAYBEGC)                                  \
 88182:     D(LAST_CONTEXT)                             \
 88182:     D(DESTROY_CONTEXT)                          \
 88182:     D(LAST_DITCH)                               \
 88182:     D(TOO_MUCH_MALLOC)                          \
 88182:     D(ALLOC_TRIGGER)                            \
 91660:     D(DEBUG_GC)                                 \
 97686:     D(DEBUG_MODE_GC)                            \
104658:     D(TRANSPLANT)                               \
106556:     D(RESET)                                    \
 88182:                                                 \
 88182:     /* Reasons from Firefox */                  \
 88182:     D(DOM_WINDOW_UTILS)                         \
 88182:     D(COMPONENT_UTILS)                          \
 88182:     D(MEM_PRESSURE)                             \
 88182:     D(CC_WAITING)                               \
 88182:     D(CC_FORCED)                                \
 88182:     D(LOAD_END)                                 \
 88182:     D(POST_COMPARTMENT)                         \
 88182:     D(PAGE_HIDE)                                \
 88182:     D(NSJSCONTEXT_DESTROY)                      \
 88182:     D(SET_NEW_DOCUMENT)                         \
 88182:     D(SET_DOC_SHELL)                            \
 88182:     D(DOM_UTILS)                                \
 88182:     D(DOM_IPC)                                  \
 88182:     D(DOM_WORKER)                               \
 88182:     D(INTER_SLICE_GC)                           \
 98111:     D(REFRESH_FRAME)                            \
103001:     D(FULL_GC_TIMER)                            \
103001:     D(SHUTDOWN_CC)
 88182: 
 88182: namespace gcreason {
 88182: 
 88182: /* GCReasons will end up looking like JSGC_MAYBEGC */
 88182: enum Reason {
 88182: #define MAKE_REASON(name) name,
 88182:     GCREASONS(MAKE_REASON)
 88182: #undef MAKE_REASON
 88182:     NO_REASON,
102741:     NUM_REASONS,
102741: 
102741:     /*
102741:      * For telemetry, we want to keep a fixed max bucket size over time so we
102741:      * don't have to switch histograms. 100 is conservative; as of this writing
102741:      * there are 26. But the cost of extra buckets seems to be low while the
102741:      * cost of switching histograms is high.
102741:      */
102741:     NUM_TELEMETRY_REASONS = 100
 88182: };
 88182: 
 88182: } /* namespace gcreason */
 88182: 
 88182: extern JS_FRIEND_API(void)
 94871: PrepareCompartmentForGC(JSCompartment *comp);
 88182: 
 88182: extern JS_FRIEND_API(void)
 94871: PrepareForFullGC(JSRuntime *rt);
 94871: 
103364: extern JS_FRIEND_API(void)
103364: PrepareForIncrementalGC(JSRuntime *rt);
103364: 
 97770: extern JS_FRIEND_API(bool)
 97770: IsGCScheduled(JSRuntime *rt);
 97770: 
 98111: extern JS_FRIEND_API(void)
 98111: SkipCompartmentForGC(JSCompartment *comp);
 98111: 
 94871: /*
 94871:  * When triggering a GC using one of the functions below, it is first necessary
 94871:  * to select the compartments to be collected. To do this, you can call
 94871:  * PrepareCompartmentForGC on each compartment, or you can call PrepareForFullGC
 94871:  * to select all compartments. Failing to select any compartment is an error.
 94871:  */
 94871: 
 94871: extern JS_FRIEND_API(void)
 94960: GCForReason(JSRuntime *rt, gcreason::Reason reason);
 89284: 
 89284: extern JS_FRIEND_API(void)
 94960: ShrinkingGC(JSRuntime *rt, gcreason::Reason reason);
 88182: 
 90410: extern JS_FRIEND_API(void)
107052: IncrementalGC(JSRuntime *rt, gcreason::Reason reason, int64_t millis = 0);
 90410: 
 90410: extern JS_FRIEND_API(void)
103364: FinishIncrementalGC(JSRuntime *rt, gcreason::Reason reason);
 90410: 
 90410: enum GCProgress {
 90410:     /*
 90410:      * During non-incremental GC, the GC is bracketed by JSGC_CYCLE_BEGIN/END
 90410:      * callbacks. During an incremental GC, the sequence of callbacks is as
 90410:      * follows:
 90410:      *   JSGC_CYCLE_BEGIN, JSGC_SLICE_END  (first slice)
 90410:      *   JSGC_SLICE_BEGIN, JSGC_SLICE_END  (second slice)
 90410:      *   ...
 90410:      *   JSGC_SLICE_BEGIN, JSGC_CYCLE_END  (last slice)
 90410:      */
 90410: 
 90410:     GC_CYCLE_BEGIN,
 90410:     GC_SLICE_BEGIN,
 90410:     GC_SLICE_END,
 90410:     GC_CYCLE_END
 90410: };
 90410: 
 92707: struct JS_FRIEND_API(GCDescription) {
 90410:     bool isCompartment;
 90410: 
 92707:     GCDescription(bool isCompartment)
 92707:       : isCompartment(isCompartment) {}
 92707: 
 92707:     jschar *formatMessage(JSRuntime *rt) const;
 93384:     jschar *formatJSON(JSRuntime *rt, uint64_t timestamp) const;
 90410: };
 90410: 
 90410: typedef void
 90410: (* GCSliceCallback)(JSRuntime *rt, GCProgress progress, const GCDescription &desc);
 90410: 
 90410: extern JS_FRIEND_API(GCSliceCallback)
 90410: SetGCSliceCallback(JSRuntime *rt, GCSliceCallback callback);
 90410: 
109045: typedef void
109045: (* AnalysisPurgeCallback)(JSRuntime *rt, JSFlatString *desc);
109045: 
109045: extern JS_FRIEND_API(AnalysisPurgeCallback)
109045: SetAnalysisPurgeCallback(JSRuntime *rt, AnalysisPurgeCallback callback);
109045: 
107267: /* Was the most recent GC run incrementally? */
107267: extern JS_FRIEND_API(bool)
107267: WasIncrementalGC(JSRuntime *rt);
107267: 
107786: typedef JSBool
107786: (* DOMInstanceClassMatchesProto)(JSHandleObject protoObject, uint32_t protoID,
107786:                                  uint32_t depth);
107786: struct JSDOMCallbacks {
107786:     DOMInstanceClassMatchesProto instanceClassMatchesProto;
107786: };
107786: typedef struct JSDOMCallbacks DOMCallbacks;
107786: 
107786: extern JS_FRIEND_API(void)
107786: SetDOMCallbacks(JSRuntime *rt, const DOMCallbacks *callbacks);
107786: 
107786: extern JS_FRIEND_API(const DOMCallbacks *)
107786: GetDOMCallbacks(JSRuntime *rt);
107786: 
 90410: /*
 90410:  * Signals a good place to do an incremental slice, because the browser is
 90410:  * drawing a frame.
 90410:  */
 90410: extern JS_FRIEND_API(void)
 94960: NotifyDidPaint(JSRuntime *rt);
 90410: 
 90410: extern JS_FRIEND_API(bool)
 90410: IsIncrementalGCEnabled(JSRuntime *rt);
 90410: 
114957: JS_FRIEND_API(bool)
114957: IsIncrementalGCInProgress(JSRuntime *rt);
114957: 
 91205: extern JS_FRIEND_API(void)
 91205: DisableIncrementalGC(JSRuntime *rt);
 91205: 
 87981: extern JS_FRIEND_API(bool)
 87981: IsIncrementalBarrierNeeded(JSRuntime *rt);
 87981: 
 87981: extern JS_FRIEND_API(bool)
 87981: IsIncrementalBarrierNeeded(JSContext *cx);
 87981: 
124506: extern JS_FRIEND_API(bool)
124728: IsIncrementalBarrierNeededOnGCThing(void *thing, JSGCTraceKind kind);
124506: 
 87981: extern JS_FRIEND_API(void)
 87981: IncrementalReferenceBarrier(void *ptr);
 87981: 
 87981: extern JS_FRIEND_API(void)
 87981: IncrementalValueBarrier(const Value &v);
 87981: 
 99131: extern JS_FRIEND_API(void)
 99131: PokeGC(JSRuntime *rt);
 99131: 
 87981: class ObjectPtr
 87981: {
 87981:     JSObject *value;
 87981: 
 87981:   public:
 87981:     ObjectPtr() : value(NULL) {}
 87981: 
 87981:     ObjectPtr(JSObject *obj) : value(obj) {}
 87981: 
 87981:     /* Always call finalize before the destructor. */
 87981:     ~ObjectPtr() { JS_ASSERT(!value); }
 87981: 
 87981:     void finalize(JSRuntime *rt) {
 87981:         if (IsIncrementalBarrierNeeded(rt))
 87981:             IncrementalReferenceBarrier(value);
 87981:         value = NULL;
 87981:     }
 87981: 
 87981:     void init(JSObject *obj) { value = obj; }
 87981: 
 87981:     JSObject *get() const { return value; }
 87981: 
 87981:     void writeBarrierPre(JSRuntime *rt) {
 87981:         IncrementalReferenceBarrier(value);
 87981:     }
 87981: 
 87981:     ObjectPtr &operator=(JSObject *obj) {
 87981:         IncrementalReferenceBarrier(value);
 87981:         value = obj;
 87981:         return *this;
 87981:     }
 87981: 
 87981:     JSObject &operator*() const { return *value; }
 87981:     JSObject *operator->() const { return value; }
 87981:     operator JSObject *() const { return value; }
 87981: };
 87981: 
 91659: extern JS_FRIEND_API(JSObject *)
 91659: GetTestingFunctions(JSContext *cx);
 91659: 
 94738: /*
 94738:  * Helper to convert FreeOp to JSFreeOp when the definition of FreeOp is not
 94738:  * available and the compiler does not know that FreeOp inherits from
 94738:  * JSFreeOp.
 94738:  */
 94738: inline JSFreeOp *
 94738: CastToJSFreeOp(FreeOp *fop)
 94738: {
 94738:     return reinterpret_cast<JSFreeOp *>(fop);
 94738: }
 94738: 
 95212: /* Implemented in jsexn.cpp. */
 95212: 
 95212: /*
105519:  * Get an error type name from a JSExnType constant.
105519:  * Returns NULL for invalid arguments and JSEXN_INTERNALERR
 95212:  */
 95212: extern JS_FRIEND_API(const jschar*)
105519: GetErrorTypeName(JSContext* cx, int16_t exnType);
 95212: 
 96950: /* Implemented in jswrapper.cpp. */
105548: typedef enum NukeReferencesToWindow {
105548:     NukeWindowReferences,
105548:     DontNukeWindowReferences
105548: } NukeReferencesToWindow;
 96950: 
107154: /*
107154:  * These filters are designed to be ephemeral stack classes, and thus don't
107154:  * do any rooting or holding of their members.
107154:  */
105543: struct CompartmentFilter {
105543:     virtual bool match(JSCompartment *c) const = 0;
105543: };
105543: 
105543: struct AllCompartments : public CompartmentFilter {
105674:     virtual bool match(JSCompartment *c) const { return true; }
105543: };
105543: 
105543: struct ContentCompartmentsOnly : public CompartmentFilter {
105543:     virtual bool match(JSCompartment *c) const {
105543:         return !IsSystemCompartment(c);
105674:     }
105543: };
105543: 
105543: struct ChromeCompartmentsOnly : public CompartmentFilter {
105543:     virtual bool match(JSCompartment *c) const {
105543:         return IsSystemCompartment(c);
105674:     }
105543: };
105543: 
105543: struct SingleCompartment : public CompartmentFilter {
105543:     JSCompartment *ours;
105674:     SingleCompartment(JSCompartment *c) : ours(c) {}
105674:     virtual bool match(JSCompartment *c) const { return c == ours; }
105543: };
105543: 
105543: struct CompartmentsWithPrincipals : public CompartmentFilter {
105543:     JSPrincipals *principals;
105674:     CompartmentsWithPrincipals(JSPrincipals *p) : principals(p) {}
105543:     virtual bool match(JSCompartment *c) const {
105543:         return JS_GetCompartmentPrincipals(c) == principals;
105674:     }
105543: };
105543: 
 96950: extern JS_FRIEND_API(JSBool)
105543: NukeCrossCompartmentWrappers(JSContext* cx,
105543:                              const CompartmentFilter& sourceFilter,
105543:                              const CompartmentFilter& targetFilter,
105548:                              NukeReferencesToWindow nukeReferencesToWindow);
 96950: 
107606: /* Specify information about ListBase proxies in the DOM, for use by ICs. */
107606: JS_FRIEND_API(void)
107606: SetListBaseInformation(void *listBaseHandlerFamily, uint32_t listBaseExpandoSlot);
107606: 
107606: void *GetListBaseHandlerFamily();
107606: uint32_t GetListBaseExpandoSlot();
107606: 
 79734: } /* namespace js */
 86105: 
 87274: /* Implemented in jsdate.cpp. */
 87274: 
 87274: /*
 87274:  * Detect whether the internal date value is NaN.  (Because failure is
 87274:  * out-of-band for js_DateGet*)
 87274:  */
 87274: extern JS_FRIEND_API(JSBool)
116462: js_DateIsValid(JSObject* obj);
 87274: 
 87274: extern JS_FRIEND_API(double)
116462: js_DateGetMsecSinceEpoch(JSRawObject obj);
 87274: 
 87275: /* Implemented in jscntxt.cpp. */
 87275: 
 87275: /*
 87275:  * Report an exception, which is currently realized as a printf-style format
 87275:  * string and its arguments.
 87275:  */
 87275: typedef enum JSErrNum {
 87275: #define MSG_DEF(name, number, count, exception, format) \
 87275:     name = number,
 87275: #include "js.msg"
 87275: #undef MSG_DEF
 87275:     JSErr_Limit
 87275: } JSErrNum;
 87275: 
 87275: extern JS_FRIEND_API(const JSErrorFormatString *)
 91237: js_GetErrorMessage(void *userRef, const char *locale, const unsigned errorNumber);
 87275: 
 87276: /* Implemented in jsclone.cpp. */
 87276: 
 87276: extern JS_FRIEND_API(uint64_t)
 87276: js_GetSCOffset(JSStructuredCloneWriter* writer);
 87276: 
 95834: /* Typed Array functions, implemented in jstypedarray.cpp */
 95834: 
 95834: namespace js {
 95834: namespace ArrayBufferView {
 95834: 
 95834: enum ViewType {
 95834:     TYPE_INT8 = 0,
 95834:     TYPE_UINT8,
 95834:     TYPE_INT16,
 95834:     TYPE_UINT16,
 95834:     TYPE_INT32,
 95834:     TYPE_UINT32,
 95834:     TYPE_FLOAT32,
 95834:     TYPE_FLOAT64,
 95834: 
 95834:     /*
 95834:      * Special type that is a uint8_t, but assignments are clamped to [0, 256).
 95834:      * Treat the raw data type as a uint8_t.
 95834:      */
 95834:     TYPE_UINT8_CLAMPED,
 95834: 
 95834:     TYPE_MAX
 95834: };
 95834: 
 95834: } /* namespace ArrayBufferView */
 95834: } /* namespace js */
 95834: 
 95834: typedef js::ArrayBufferView::ViewType JSArrayBufferViewType;
 95834: 
 95834: /*
 95834:  * Create a new typed array with nelements elements.
114937:  *
114937:  * These functions (except the WithBuffer variants) fill in the array with zeros.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt8Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ClampedArray(JSContext *cx, uint32_t nelements);
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt16Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint16Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt32Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint32Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat32Array(JSContext *cx, uint32_t nelements);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat64Array(JSContext *cx, uint32_t nelements);
 95834: 
 95834: /*
 95834:  * Create a new typed array and copy in values from the given object. The
 95834:  * object is used as if it were an array; that is, the new array (if
 95834:  * successfully created) will have length given by array.length, and its
 95834:  * elements will be those specified by array[0], array[1], and so on, after
 95834:  * conversion to the typed array element type.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt8ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ClampedArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt16ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint16ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt32ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint32ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat32ArrayFromArray(JSContext *cx, JSObject *array);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat64ArrayFromArray(JSContext *cx, JSObject *array);
 95834: 
 95834: /*
 95834:  * Create a new typed array using the given ArrayBuffer for storage. byteOffset
 95834:  * must not exceed (signed) INT32_MAX. The length value is optional; if -1 is
 95834:  * passed, enough elements to use up the remainder of the byte array is used as
 95834:  * the default value.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                           uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                            uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint8ClampedArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                                   uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                            uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint16ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                             uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewInt32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                            uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewUint32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                             uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat32ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                              uint32_t byteOffset, int32_t length);
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewFloat64ArrayWithBuffer(JSContext *cx, JSObject *arrayBuffer,
 95834:                              uint32_t byteOffset, int32_t length);
 95834: 
 95834: /*
 95834:  * Create a new ArrayBuffer with the given byte length.
 95834:  */
 95834: extern JS_FRIEND_API(JSObject *)
 95834: JS_NewArrayBuffer(JSContext *cx, uint32_t nbytes);
 95834: 
 95834: /*
 95834:  * Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
 95834:  * false if a security wrapper is encountered that denies the unwrapping. If
 95834:  * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
 95834:  * the various accessor JSAPI calls defined below.
 95834:  */
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsTypedArrayObject(JSObject *obj);
 95834: 
 95834: /*
 97574:  * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
 97574:  * return false if a security wrapper is encountered that denies the
 97574:  * unwrapping. If this test or one of the more specific tests succeeds, then it
 97574:  * is safe to call the various ArrayBufferView accessor JSAPI calls defined
121899:  * below.
 97574:  */
 97574: extern JS_FRIEND_API(JSBool)
121899: JS_IsArrayBufferViewObject(JSObject *obj);
 97574: 
 97574: /*
 95834:  * Test for specific typed array types (ArrayBufferView subtypes)
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsInt8Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsUint8Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsUint8ClampedArray(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsInt16Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsUint16Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsInt32Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsUint32Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsFloat32Array(JSObject *obj);
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsFloat64Array(JSObject *obj);
107060: 
107060: /*
107060:  * Unwrap Typed arrays all at once. Return NULL without throwing if the object
107060:  * cannot be viewed as the correct typed array, or the typed array object on
107060:  * success, filling both outparameters.
107060:  */
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsInt8Array(JSObject *obj, uint32_t *length, int8_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsUint8Array(JSObject *obj, uint32_t *length, uint8_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsUint8ClampedArray(JSObject *obj, uint32_t *length, uint8_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsInt16Array(JSObject *obj, uint32_t *length, int16_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsUint16Array(JSObject *obj, uint32_t *length, uint16_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsInt32Array(JSObject *obj, uint32_t *length, int32_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsUint32Array(JSObject *obj, uint32_t *length, uint32_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsFloat32Array(JSObject *obj, uint32_t *length, float **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsFloat64Array(JSObject *obj, uint32_t *length, double **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsArrayBufferView(JSObject *obj, uint32_t *length, uint8_t **data);
107060: extern JS_FRIEND_API(JSObject *)
121899: JS_GetObjectAsArrayBuffer(JSObject *obj, uint32_t *length, uint8_t **data);
107060: 
 95834: /*
 95834:  * Get the type of elements in a typed array.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
121899:  * a typed array, and the unwrapping will succeed.
 95834:  */
 95834: extern JS_FRIEND_API(JSArrayBufferViewType)
121899: JS_GetTypedArrayType(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Check whether obj supports the JS_GetArrayBuffer* APIs. Note that this may
 95834:  * return false if a security wrapper is encountered that denies the
 95834:  * unwrapping. If this test succeeds, then it is safe to call the various
 95834:  * accessor JSAPI calls defined below.
 95834:  */
 95834: extern JS_FRIEND_API(JSBool)
121899: JS_IsArrayBufferObject(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Return the available byte length of an array buffer.
 95834:  *
 95834:  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 95834:  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
121899:  * ArrayBuffer, and the unwrapping will succeed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
121899: JS_GetArrayBufferByteLength(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Return a pointer to an array buffer's data. The buffer is still owned by the
110925:  * array buffer object, and should not be modified on another thread. The
110925:  * returned pointer is stable across GCs.
 95834:  *
 95834:  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
 95834:  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
121899:  * ArrayBuffer, and the unwrapping will succeed.
 95834:  */
 95834: extern JS_FRIEND_API(uint8_t *)
121899: JS_GetArrayBufferData(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Return the number of elements in a typed array.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
121899:  * a typed array, and the unwrapping will succeed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
121899: JS_GetTypedArrayLength(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Return the byte offset from the start of an array buffer to the start of a
 95834:  * typed array view.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
121899:  * a typed array, and the unwrapping will succeed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
121899: JS_GetTypedArrayByteOffset(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Return the byte length of a typed array.
 95834:  *
 95834:  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 95834:  * be known that it would pass such a test: it is a typed array or a wrapper of
121899:  * a typed array, and the unwrapping will succeed.
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
121899: JS_GetTypedArrayByteLength(JSObject *obj);
 95834: 
 95834: /*
 96956:  * Check whether obj supports JS_ArrayBufferView* APIs. Note that this may
 96956:  * return false if a security wrapper is encountered that denies the
 96956:  * unwrapping.
 96956:  */
 96956: extern JS_FRIEND_API(JSBool)
121899: JS_IsArrayBufferViewObject(JSObject *obj);
 96956: 
 96956: /*
 95834:  * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
 95834:  */
 95834: extern JS_FRIEND_API(uint32_t)
121899: JS_GetArrayBufferViewByteLength(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Return a pointer to the start of the data referenced by a typed array. The
 95834:  * data is still owned by the typed array, and should not be modified on
 95834:  * another thread.
 95834:  *
 95834:  * |obj| must have passed a JS_Is*Array test, or somehow be known that it would
 95834:  * pass such a test: it is a typed array or a wrapper of a typed array, and the
121899:  * unwrapping will succeed.
 95834:  */
 95834: 
 95834: extern JS_FRIEND_API(int8_t *)
121899: JS_GetInt8ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(uint8_t *)
121899: JS_GetUint8ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(uint8_t *)
121899: JS_GetUint8ClampedArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(int16_t *)
121899: JS_GetInt16ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(uint16_t *)
121899: JS_GetUint16ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(int32_t *)
121899: JS_GetInt32ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(uint32_t *)
121899: JS_GetUint32ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(float *)
121899: JS_GetFloat32ArrayData(JSObject *obj);
 95834: extern JS_FRIEND_API(double *)
121899: JS_GetFloat64ArrayData(JSObject *obj);
 95834: 
 95834: /*
 95834:  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
 95834:  * versions when possible.
 95834:  */
 95834: extern JS_FRIEND_API(void *)
121899: JS_GetArrayBufferViewData(JSObject *obj);
 95834: 
 97574: /*
120803:  * Return the ArrayBuffer underlying an ArrayBufferView. If the buffer has been
120803:  * neutered, this will still return the neutered buffer. |obj| must be an
120803:  * object that would return true for JS_IsArrayBufferViewObject().
120803:  */
120803: extern JS_FRIEND_API(JSObject *)
121899: JS_GetArrayBufferViewBuffer(JSObject *obj);
120803: 
120803: /*
121899:  * Check whether obj supports JS_GetDataView* APIs.
 97574:  */
 97574: JS_FRIEND_API(JSBool)
121899: JS_IsDataViewObject(JSObject *obj);
 97574: 
 97574: /*
 97574:  * Return the byte offset of a data view into its array buffer. |obj| must be a
 97574:  * DataView.
 97574:  *
 97574:  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 97574:  * it would pass such a test: it is a data view or a wrapper of a data view,
121899:  * and the unwrapping will succeed.
 97574:  */
 97574: JS_FRIEND_API(uint32_t)
121899: JS_GetDataViewByteOffset(JSObject *obj);
 97574: 
 97574: /*
 97574:  * Return the byte length of a data view.
 97574:  *
 97574:  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 97574:  * it would pass such a test: it is a data view or a wrapper of a data view,
 97574:  * and the unwrapping will succeed. If cx is NULL, then DEBUG builds may be
 97574:  * unable to assert when unwrapping should be disallowed.
 97574:  */
 97574: JS_FRIEND_API(uint32_t)
121899: JS_GetDataViewByteLength(JSObject *obj);
 97574: 
 97574: /*
 97574:  * Return a pointer to the beginning of the data referenced by a DataView.
 97574:  *
 97574:  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
 97574:  * it would pass such a test: it is a data view or a wrapper of a data view,
 97574:  * and the unwrapping will succeed. If cx is NULL, then DEBUG builds may be
 97574:  * unable to assert when unwrapping should be disallowed.
 97574:  */
 97574: JS_FRIEND_API(void *)
121899: JS_GetDataViewData(JSObject *obj);
 97574: 
107783: /*
107783:  * This struct contains metadata passed from the DOM to the JS Engine for JIT
107783:  * optimizations on DOM property accessors. Eventually, this should be made
107783:  * available to general JSAPI users, but we are not currently ready to do so.
107783:  */
107784: typedef bool
107791: (* JSJitPropertyOp)(JSContext *cx, JSHandleObject thisObj,
107784:                     void *specializedThis, JS::Value *vp);
107791: typedef bool
107791: (* JSJitMethodOp)(JSContext *cx, JSHandleObject thisObj,
107791:                   void *specializedThis, unsigned argc, JS::Value *vp);
107784: 
107784: struct JSJitInfo {
107784:     JSJitPropertyOp op;
107784:     uint32_t protoID;
107784:     uint32_t depth;
111082:     bool isInfallible;    /* Is op fallible? False in setters. */
107784:     bool isConstant;      /* Getting a construction-time constant? */
107784: };
107791: 
107791: static JS_ALWAYS_INLINE const JSJitInfo *
107791: FUNCTION_VALUE_TO_JITINFO(const JS::Value& v)
107791: {
107791:     JS_ASSERT(js::GetObjectClass(&v.toObject()) == &js::FunctionClass);
107791:     return reinterpret_cast<js::shadow::Function *>(&v.toObject())->jitinfo;
107791: }
107792: 
121256: /* Statically asserted in jsfun.h. */
121256: static const unsigned JS_FUNCTION_INTERPRETED_BIT = 0x1;
121256: 
107792: static JS_ALWAYS_INLINE void
107792: SET_JITINFO(JSFunction * func, const JSJitInfo *info)
107792: {
107792:     js::shadow::Function *fun = reinterpret_cast<js::shadow::Function *>(func);
121256:     JS_ASSERT(!(fun->flags & JS_FUNCTION_INTERPRETED_BIT));
107792:     fun->jitinfo = info;
107792: }
107783: 
111495: /*
111495:  * Engine-internal extensions of jsid.  This code is here only until we
111495:  * eliminate Gecko's dependencies on it!
111495:  */
111495: 
111495: static JS_ALWAYS_INLINE jsid
111495: JSID_FROM_BITS(size_t bits)
111495: {
111495:     jsid id;
111495:     JSID_BITS(id) = bits;
111495:     return id;
111495: }
111495: 
111495: /*
111495:  * Must not be used on atoms that are representable as integer jsids.
111495:  * Prefer NameToId or AtomToId over this function:
111495:  *
111495:  * A PropertyName is an atom that does not contain an integer in the range
111495:  * [0, UINT32_MAX]. However, jsid can only hold an integer in the range
111495:  * [0, JSID_INT_MAX] (where JSID_INT_MAX == 2^31-1).  Thus, for the range of
111495:  * integers (JSID_INT_MAX, UINT32_MAX], to represent as a jsid 'id', it must be
111495:  * the case JSID_IS_ATOM(id) and !JSID_TO_ATOM(id)->isPropertyName().  In most
111495:  * cases when creating a jsid, code does not have to care about this corner
111495:  * case because:
111495:  *
111495:  * - When given an arbitrary JSAtom*, AtomToId must be used, which checks for
111495:  *   integer atoms representable as integer jsids, and does this conversion.
111495:  *
111495:  * - When given a PropertyName*, NameToId can be used which which does not need
111495:  *   to do any dynamic checks.
111495:  *
111495:  * Thus, it is only the rare third case which needs this function, which
111495:  * handles any JSAtom* that is known not to be representable with an int jsid.
111495:  */
111495: static JS_ALWAYS_INLINE jsid
111495: NON_INTEGER_ATOM_TO_JSID(JSAtom *atom)
111495: {
111495:     JS_ASSERT(((size_t)atom & 0x7) == 0);
111495:     jsid id = JSID_FROM_BITS((size_t)atom);
111495:     JS_ASSERT(id == INTERNED_STRING_TO_JSID(NULL, (JSString*)atom));
111495:     return id;
111495: }
111495: 
111495: /* All strings stored in jsids are atomized, but are not necessarily property names. */
111495: static JS_ALWAYS_INLINE JSBool
111495: JSID_IS_ATOM(jsid id)
111495: {
111495:     return JSID_IS_STRING(id);
111495: }
111495: 
111495: static JS_ALWAYS_INLINE JSBool
111495: JSID_IS_ATOM(jsid id, JSAtom *atom)
111495: {
111495:     return id == JSID_FROM_BITS((size_t)atom);
111495: }
111495: 
111495: static JS_ALWAYS_INLINE JSAtom *
111495: JSID_TO_ATOM(jsid id)
111495: {
111495:     return (JSAtom *)JSID_TO_STRING(id);
111495: }
111495: 
111495: JS_STATIC_ASSERT(sizeof(jsid) == JS_BYTES_PER_WORD);
111495: 
111495: namespace js {
111495: 
111495: static JS_ALWAYS_INLINE Value
111495: IdToValue(jsid id)
111495: {
111495:     if (JSID_IS_STRING(id))
111495:         return StringValue(JSID_TO_STRING(id));
111495:     if (JS_LIKELY(JSID_IS_INT(id)))
111495:         return Int32Value(JSID_TO_INT(id));
111495:     if (JS_LIKELY(JSID_IS_OBJECT(id)))
111495:         return ObjectValue(*JSID_TO_OBJECT(id));
111495:     JS_ASSERT(JSID_IS_DEFAULT_XML_NAMESPACE(id) || JSID_IS_VOID(id));
111495:     return UndefinedValue();
111495: }
111495: 
111495: static JS_ALWAYS_INLINE jsval
111495: IdToJsval(jsid id)
111495: {
111495:     return IdToValue(id);
111495: }
111495: 
111495: } /* namespace js */
111495: 
 59931: #endif /* jsfriendapi_h___ */
