    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
    1: 
    1: #include "nsPlaintextEditor.h"
    1: 
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsIFormControl.h"
 1418: #include "nsIDOMEventTarget.h" 
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIDOMMouseEvent.h"
18445: #include "nsIDOMDragEvent.h"
    1: #include "nsISelection.h"
    1: #include "nsCRT.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: #include "nsIDOMRange.h"
90376: #include "nsIDOMDOMStringList.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsISupportsPrimitives.h"
    1: 
    1: // Drag & Drop, Clipboard
    1: #include "nsIClipboard.h"
    1: #include "nsITransferable.h"
    1: #include "nsIDragService.h"
77226: #include "nsIDOMUIEvent.h"
39646: #include "nsCopySupport.h"
90376: #include "nsITransferable.h"
    1: 
    1: // Misc
    1: #include "nsEditorUtils.h"
    1: #include "nsContentCID.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsFrameSelection.h"
 4010: #include "nsEventDispatcher.h"
78907: #include "nsContentUtils.h"
    1: 
80467: using namespace mozilla;
80467: 
    1: NS_IMETHODIMP nsPlaintextEditor::PrepareTransferable(nsITransferable **transferable)
    1: {
    1:   // Create generic Transferable for getting the data
    1:   nsresult rv = CallCreateInstance("@mozilla.org/widget/transferable;1", transferable);
43808:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Get the nsITransferable interface for getting the data from the clipboard
26619:   if (transferable) {
26619:     (*transferable)->AddDataFlavor(kUnicodeMime);
26619:     (*transferable)->AddDataFlavor(kMozTextInternal);
26619:   };
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPlaintextEditor::InsertTextAt(const nsAString &aStringToInsert,
    1:                                          nsIDOMNode *aDestinationNode,
    1:                                          PRInt32 aDestOffset,
79445:                                          bool aDoDeleteSelection)
    1: {
    1:   if (aDestinationNode)
    1:   {
    1:     nsresult res;
    1:     nsCOMPtr<nsISelection>selection;
    1:     res = GetSelection(getter_AddRefs(selection));
    1:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     nsCOMPtr<nsIDOMNode> targetNode = aDestinationNode;
    1:     PRInt32 targetOffset = aDestOffset;
    1: 
    1:     if (aDoDeleteSelection)
    1:     {
    1:       // Use an auto tracker so that our drop point is correctly
    1:       // positioned after the delete.
    1:       nsAutoTrackDOMPoint tracker(mRangeUpdater, &targetNode, &targetOffset);
    1:       res = DeleteSelection(eNone);
    1:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1: 
    1:     res = selection->Collapse(targetNode, targetOffset);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   return InsertText(aStringToInsert);
    1: }
    1: 
    1: NS_IMETHODIMP nsPlaintextEditor::InsertTextFromTransferable(nsITransferable *aTransferable,
    1:                                                             nsIDOMNode *aDestinationNode,
    1:                                                             PRInt32 aDestOffset,
79445:                                                             bool aDoDeleteSelection)
    1: {
60699:   FireTrustedInputEvent trusted(this);
60699: 
    1:   nsresult rv = NS_OK;
    1:   char* bestFlavor = nsnull;
    1:   nsCOMPtr<nsISupports> genericDataObj;
    1:   PRUint32 len = 0;
    1:   if (NS_SUCCEEDED(aTransferable->GetAnyTransferData(&bestFlavor, getter_AddRefs(genericDataObj), &len))
26619:       && bestFlavor && (0 == nsCRT::strcmp(bestFlavor, kUnicodeMime) ||
26619:                         0 == nsCRT::strcmp(bestFlavor, kMozTextInternal)))
    1:   {
    1:     nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1:     nsCOMPtr<nsISupportsString> textDataObj ( do_QueryInterface(genericDataObj) );
    1:     if (textDataObj && len > 0)
    1:     {
    1:       nsAutoString stuffToPaste;
    1:       textDataObj->GetData(stuffToPaste);
    1:       NS_ASSERTION(stuffToPaste.Length() <= (len/2), "Invalid length!");
78907: 
78907:       // Sanitize possible carriage returns in the string to be inserted
78907:       nsContentUtils::PlatformToDOMLineBreaks(stuffToPaste);
78907: 
    1:       nsAutoEditBatch beginBatching(this);
    1:       rv = InsertTextAt(stuffToPaste, aDestinationNode, aDestOffset, aDoDeleteSelection);
    1:     }
    1:   }
    1:   NS_Free(bestFlavor);
    1:       
    1:   // Try to scroll the selection into view if the paste/drop succeeded
12392: 
    1:   if (NS_SUCCEEDED(rv))
80486:     ScrollSelectionIntoView(false);
    1: 
    1:   return rv;
    1: }
    1: 
90377: nsresult nsPlaintextEditor::InsertFromDataTransfer(nsIDOMDataTransfer *aDataTransfer,
90377:                                                    PRInt32 aIndex,
90377:                                                    nsIDOMDocument *aSourceDoc,
90377:                                                    nsIDOMNode *aDestinationNode,
90377:                                                    PRInt32 aDestOffset,
90377:                                                    bool aDoDeleteSelection)
90377: {
90377:   nsCOMPtr<nsIVariant> data;
90377:   aDataTransfer->MozGetDataAt(NS_LITERAL_STRING("text/plain"), aIndex,
90377:                               getter_AddRefs(data));
90840:   if (data) {
90377:     nsAutoString insertText;
90377:     data->GetAsAString(insertText);
90377:     nsContentUtils::PlatformToDOMLineBreaks(insertText);
90377: 
90377:     nsAutoEditBatch beginBatching(this);
90377:     return InsertTextAt(insertText, aDestinationNode, aDestOffset, aDoDeleteSelection);
90377:   }
90377: 
90840:   return NS_OK;
90840: }
90840: 
90377: nsresult nsPlaintextEditor::InsertFromDrop(nsIDOMEvent* aDropEvent)
    1: {
    1:   ForceCompositionEnd();
    1: 
90376:   nsCOMPtr<nsIDOMDragEvent> dragEvent(do_QueryInterface(aDropEvent));
90376:   NS_ENSURE_TRUE(dragEvent, NS_ERROR_FAILURE);
90376: 
90376:   nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
90376:   nsresult rv = dragEvent->GetDataTransfer(getter_AddRefs(dataTransfer));
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Current doc is destination
    1:   nsCOMPtr<nsIDOMDocument> destdomdoc; 
    1:   rv = GetDocument(getter_AddRefs(destdomdoc)); 
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 numItems = 0;
90376:   rv = dataTransfer->GetMozItemCount(&numItems);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (numItems < 1) return NS_ERROR_FAILURE;  // nothing to drop?
    1: 
    1:   // Combine any deletion and drop insertion into one transaction
    1:   nsAutoEditBatch beginBatching(this);
    1: 
79445:   bool deleteSelection = false;
    1: 
    1:   // We have to figure out whether to delete and relocate caret only once
    1:   // Parent and offset are under the mouse cursor
77226:   nsCOMPtr<nsIDOMUIEvent> uiEvent = do_QueryInterface(aDropEvent);
77226:   NS_ENSURE_TRUE(uiEvent, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNode> newSelectionParent;
77226:   rv = uiEvent->GetRangeParent(getter_AddRefs(newSelectionParent));
43805:   NS_ENSURE_SUCCESS(rv, rv);
43806:   NS_ENSURE_TRUE(newSelectionParent, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 newSelectionOffset;
77226:   rv = uiEvent->GetRangeOffset(&newSelectionOffset);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   rv = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(rv, rv);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1: 
79445:   bool isCollapsed;
    1:   rv = selection->GetIsCollapsed(&isCollapsed);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
90377:   nsCOMPtr<nsIDOMNode> sourceNode;
90377:   dataTransfer->GetMozSourceNode(getter_AddRefs(sourceNode));
90377: 
90377:   nsCOMPtr<nsIDOMDocument> srcdomdoc;
90377:   if (sourceNode) {
90377:     sourceNode->GetOwnerDocument(getter_AddRefs(srcdomdoc));
90377:     NS_ENSURE_TRUE(sourceNode, NS_ERROR_FAILURE);
90377:   }
90377: 
90377:   // Only the nsHTMLEditor::FindUserSelectAllNode returns a node.
90377:   nsCOMPtr<nsIDOMNode> userSelectNode = FindUserSelectAllNode(newSelectionParent);
90377:   if (userSelectNode)
90377:   {
90377:     // The drop is happening over a "-moz-user-select: all"
90377:     // subtree so make sure the content we insert goes before
90377:     // the root of the subtree.
90377:     //
90377:     // XXX: Note that inserting before the subtree matches the
90377:     //      current behavior when dropping on top of an image.
90377:     //      The decision for dropping before or after the
90377:     //      subtree should really be done based on coordinates.
90377: 
90377:     rv = GetNodeLocation(userSelectNode, address_of(newSelectionParent),
90377:                          &newSelectionOffset);
90377: 
90377:     NS_ENSURE_SUCCESS(rv, rv);
90377:     NS_ENSURE_TRUE(newSelectionParent, NS_ERROR_FAILURE);
90377:   }
90377: 
    1:   // Check if mouse is in the selection
    1:   // if so, jump through some hoops to determine if mouse is over selection (bail)
    1:   // and whether user wants to copy selection or delete it
    1:   if (!isCollapsed)
    1:   {
    1:     // We never have to delete if selection is already collapsed
79445:     bool cursorIsInSelection = false;
    1: 
    1:     PRInt32 rangeCount;
    1:     rv = selection->GetRangeCount(&rangeCount);
43805:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     for (PRInt32 j = 0; j < rangeCount; j++)
    1:     {
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       rv = selection->GetRangeAt(j, getter_AddRefs(range));
86938:       if (NS_FAILED(rv) || !range) 
    1:         continue;  // don't bail yet, iterate through them all
    1: 
86938:       rv = range->IsPointInRange(newSelectionParent, newSelectionOffset, &cursorIsInSelection);
    1:       if (cursorIsInSelection)
    1:         break;
    1:     }
    1: 
    1:     if (cursorIsInSelection)
    1:     {
    1:       // Dragging within same doc can't drop on itself -- leave!
    1:       if (srcdomdoc == destdomdoc)
    1:         return NS_OK;
    1: 
    1:       // Dragging from another window onto a selection
    1:       // XXX Decision made to NOT do this,
    1:       //     note that 4.x does replace if dropped on
80486:       //deleteSelection = true;
    1:     }
    1:     else 
    1:     {
    1:       // We are NOT over the selection
    1:       if (srcdomdoc == destdomdoc)
    1:       {
    1:         // Within the same doc: delete if user doesn't want to copy
90376:         PRUint32 dropEffect;
90376:         dataTransfer->GetDropEffectInt(&dropEffect);
90376:         deleteSelection = !(dropEffect & nsIDragService::DRAGDROP_ACTION_COPY);
    1:       }
    1:       else
    1:       {
    1:         // Different source doc: Don't delete
80486:         deleteSelection = false;
    1:       }
    1:     }
    1:   }
    1: 
90377:   if (IsPlaintextEditor()) {
90377:     nsCOMPtr<nsIContent> content = do_QueryInterface(newSelectionParent);
    1:     while (content) {
    1:       nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(content));
    1:       if (formControl && !formControl->AllowDrop()) {
    1:         // Don't allow dropping into a form control that doesn't allow being
    1:         // dropped into.
    1:         return NS_OK;
    1:       }
    1:       content = content->GetParent();
    1:     }
90377:   }
    1: 
90377:   for (PRUint32 i = 0; i < numItems; ++i) {
90377:     InsertFromDataTransfer(dataTransfer, i, srcdomdoc, newSelectionParent,
90377:                            newSelectionOffset, deleteSelection);
    1:   }
    1: 
90376:   if (NS_SUCCEEDED(rv))
90376:     ScrollSelectionIntoView(false);
90376: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPlaintextEditor::Paste(PRInt32 aSelectionType)
    1: {
39646:   if (!FireClipboardEvent(NS_PASTE))
39646:     return NS_OK;
 4010: 
    1:   // Get Clipboard Service
39646:   nsresult rv;
    1:   nsCOMPtr<nsIClipboard> clipboard(do_GetService("@mozilla.org/widget/clipboard;1", &rv));
    1:   if ( NS_FAILED(rv) )
    1:     return rv;
    1: 
    1:   // Get the nsITransferable interface for getting the data from the clipboard
    1:   nsCOMPtr<nsITransferable> trans;
    1:   rv = PrepareTransferable(getter_AddRefs(trans));
    1:   if (NS_SUCCEEDED(rv) && trans)
    1:   {
    1:     // Get the Data from the clipboard  
    1:     if (NS_SUCCEEDED(clipboard->GetData(trans, aSelectionType)) && IsModifiable())
    1:     {
    1:       // handle transferable hooks
    1:       nsCOMPtr<nsIDOMDocument> domdoc;
    1:       GetDocument(getter_AddRefs(domdoc));
    1:       if (!nsEditorHookUtils::DoInsertionHook(domdoc, nsnull, trans))
    1:         return NS_OK;
    1: 
80486:       rv = InsertTextFromTransferable(trans, nsnull, nsnull, true);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
36983: NS_IMETHODIMP nsPlaintextEditor::PasteTransferable(nsITransferable *aTransferable)
36983: {
39646:   if (!FireClipboardEvent(NS_PASTE))
39646:     return NS_OK;
36983: 
36983:   if (!IsModifiable())
36983:     return NS_OK;
36983: 
36983:   // handle transferable hooks
36983:   nsCOMPtr<nsIDOMDocument> domdoc;
36983:   GetDocument(getter_AddRefs(domdoc));
36983:   if (!nsEditorHookUtils::DoInsertionHook(domdoc, nsnull, aTransferable))
36983:     return NS_OK;
36983: 
80486:   return InsertTextFromTransferable(aTransferable, nsnull, nsnull, true);
36983: }
    1: 
79445: NS_IMETHODIMP nsPlaintextEditor::CanPaste(PRInt32 aSelectionType, bool *aCanPaste)
    1: {
 4010:   NS_ENSURE_ARG_POINTER(aCanPaste);
80486:   *aCanPaste = false;
    1: 
    1:   // can't paste if readonly
    1:   if (!IsModifiable())
    1:     return NS_OK;
    1: 
12176:   nsresult rv;
    1:   nsCOMPtr<nsIClipboard> clipboard(do_GetService("@mozilla.org/widget/clipboard;1", &rv));
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   // the flavors that we can deal with
 8229:   const char* textEditorFlavors[] = { kUnicodeMime };
    1: 
79445:   bool haveFlavors;
 8229:   rv = clipboard->HasDataMatchingFlavors(textEditorFlavors,
80467:                                          ArrayLength(textEditorFlavors),
 8229:                                          aSelectionType, &haveFlavors);
43805:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   *aCanPaste = haveFlavors;
    1:   return NS_OK;
    1: }
    1: 
36983: 
79445: NS_IMETHODIMP nsPlaintextEditor::CanPasteTransferable(nsITransferable *aTransferable, bool *aCanPaste)
36983: {
36983:   NS_ENSURE_ARG_POINTER(aCanPaste);
36983: 
36983:   // can't paste if readonly
36983:   if (!IsModifiable()) {
80486:     *aCanPaste = false;
36983:     return NS_OK;
36983:   }
36983: 
36983:   // If |aTransferable| is null, assume that a paste will succeed.
36983:   if (!aTransferable) {
80486:     *aCanPaste = true;
36983:     return NS_OK;
36983:   }
36983: 
36983:   nsCOMPtr<nsISupports> data;
36983:   PRUint32 dataLen;
36983:   nsresult rv = aTransferable->GetTransferData(kUnicodeMime,
36983:                                                getter_AddRefs(data),
36983:                                                &dataLen);
36983:   if (NS_SUCCEEDED(rv) && data)
80486:     *aCanPaste = true;
36983:   else
80486:     *aCanPaste = false;
36983:   
36983:   return NS_OK;
36983: }
