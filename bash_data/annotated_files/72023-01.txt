    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
61084: #ifdef MOZ_LOGGING
61084: #define FORCE_PR_LOG /* Allow logging in the release build */
61084: #endif
61084: #include "prlog.h"
61084: 
    1: #include "gfxPlatform.h"
    1: 
    1: #if defined(XP_WIN)
    1: #include "gfxWindowsPlatform.h"
    1: #elif defined(XP_MACOSX)
    1: #include "gfxPlatformMac.h"
    1: #elif defined(MOZ_WIDGET_GTK2)
    1: #include "gfxPlatformGtk.h"
16758: #elif defined(MOZ_WIDGET_QT)
16758: #include "gfxQtPlatform.h"
    1: #elif defined(XP_OS2)
    1: #include "gfxOS2Platform.h"
42153: #elif defined(ANDROID)
42153: #include "gfxAndroidPlatform.h"
    1: #endif
    1: 
38493: #include "gfxAtoms.h"
31590: #include "gfxPlatformFontList.h"
    1: #include "gfxContext.h"
    1: #include "gfxImageSurface.h"
  218: #include "gfxTextRunCache.h"
 3118: #include "gfxTextRunWordCache.h"
19962: #include "gfxUserFontSet.h"
58936: #include "gfxUnicodeProperties.h"
58936: #include "harfbuzz/hb-unicode.h"
    1: 
37211: #include "nsUnicodeRange.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
37211: #include "nsIUGenCategory.h"
37211: #include "nsUnicharUtilCIID.h"
37211: #include "nsILocaleService.h"
    1: 
19003: #include "nsWeakReference.h"
19003: 
    1: #include "cairo.h"
27035: #include "qcms.h"
 3787: 
11086: #include "plstr.h"
36949: #include "nsCRT.h"
47967: #include "GLContext.h"
47967: #include "GLContextProvider.h"
    1: 
41340: #include "mozilla/FunctionTimer.h"
71640: #include "mozilla/Preferences.h"
41340: 
51677: #include "nsIGfxInfo.h"
51677: 
71640: using namespace mozilla;
71640: 
    1: gfxPlatform *gPlatform = nsnull;
69151: static bool gEverInitialized = false;
15987: 
15987: // These two may point to the same profile
27035: static qcms_profile *gCMSOutputProfile = nsnull;
27035: static qcms_profile *gCMSsRGBProfile = nsnull;
15987: 
27035: static qcms_transform *gCMSRGBTransform = nsnull;
27035: static qcms_transform *gCMSInverseRGBTransform = nsnull;
27035: static qcms_transform *gCMSRGBATransform = nsnull;
    1: 
19003: static PRBool gCMSInitialized = PR_FALSE;
19003: static eCMSMode gCMSMode = eCMSMode_Off;
19003: static int gCMSIntent = -2;
19003: 
16571: static const char *CMPrefName = "gfx.color_management.mode";
16571: static const char *CMPrefNameOld = "gfx.color_management.enabled";
16571: static const char *CMIntentPrefName = "gfx.color_management.rendering_intent";
19003: static const char *CMProfilePrefName = "gfx.color_management.display_profile";
19003: static const char *CMForceSRGBPrefName = "gfx.color_management.force_srgb";
19003: 
19003: static void ShutdownCMS();
16571: static void MigratePrefs();
16571: 
61084: 
61084: // logs shared across gfx
61084: #ifdef PR_LOGGING
61084: static PRLogModuleInfo *sFontlistLog = nsnull;
61084: static PRLogModuleInfo *sFontInitLog = nsnull;
61084: static PRLogModuleInfo *sTextrunLog = nsnull;
61084: static PRLogModuleInfo *sTextrunuiLog = nsnull;
61084: #endif
61084: 
19003: /* Class to listen for pref changes so that chrome code can dynamically
19003:    force sRGB as an output profile. See Bug #452125. */
19003: class SRGBOverrideObserver : public nsIObserver,
19003:                              public nsSupportsWeakReference
19003: {
19003: public:
19003:     NS_DECL_ISUPPORTS
19003:     NS_DECL_NSIOBSERVER
19003: };
19003: 
19003: NS_IMPL_ISUPPORTS2(SRGBOverrideObserver, nsIObserver, nsISupportsWeakReference)
19003: 
19003: NS_IMETHODIMP
19003: SRGBOverrideObserver::Observe(nsISupports *aSubject,
19003:                               const char *aTopic,
19003:                               const PRUnichar *someData)
19003: {
19003:     NS_ASSERTION(NS_strcmp(someData,
19003:                    NS_LITERAL_STRING("gfx.color_mangement.force_srgb").get()),
19003:                  "Restarting CMS on wrong pref!");
19003:     ShutdownCMS();
19003:     return NS_OK;
19003: }
19003: 
42854: #define GFX_DOWNLOADABLE_FONTS_ENABLED "gfx.downloadable_fonts.enabled"
72023: #if defined(XP_MACOSX)
72023: #define GFX_DOWNLOADABLE_FONTS_ENABLED_LION "gfx.downloadable_fonts.enabled.lion"
72023: #endif
55084: #define GFX_DOWNLOADABLE_FONTS_SANITIZE "gfx.downloadable_fonts.sanitize"
42854: 
67838: #define GFX_PREF_HARFBUZZ_SCRIPTS "gfx.font_rendering.harfbuzz.scripts"
67838: #define HARFBUZZ_SCRIPTS_DEFAULT  gfxUnicodeProperties::SHAPING_DEFAULT
43527: 
71640: static const char* kObservedPrefs[] = {
71640:     "gfx.downloadable_fonts.",
71640:     "gfx.font_rendering.",
71640:     nsnull
71640: };
71640: 
42854: class FontPrefsObserver : public nsIObserver
42854: {
42854: public:
42854:     NS_DECL_ISUPPORTS
42854:     NS_DECL_NSIOBSERVER
42854: };
42854: 
42854: NS_IMPL_ISUPPORTS1(FontPrefsObserver, nsIObserver)
42854: 
42854: NS_IMETHODIMP
42854: FontPrefsObserver::Observe(nsISupports *aSubject,
42854:                            const char *aTopic,
42854:                            const PRUnichar *someData)
42854: {
71640:     if (!someData) {
42854:         NS_ERROR("font pref observer code broken");
42854:         return NS_ERROR_UNEXPECTED;
42854:     }
71640:     NS_ASSERTION(gfxPlatform::GetPlatform(), "the singleton instance has gone");
71640:     gfxPlatform::GetPlatform()->FontsPrefsChanged(NS_ConvertUTF16toUTF8(someData).get());
42854: 
42854:     return NS_OK;
42854: }
42854: 
42854: 
19003: 
11086: // this needs to match the list of pref font.default.xx entries listed in all.js!
11086: // the order *must* match the order in eFontPrefLang
11086: static const char *gPrefLangNames[] = {
11086:     "x-western",
11086:     "x-central-euro",
11086:     "ja",
11086:     "zh-TW",
11086:     "zh-CN",
11086:     "zh-HK",
11086:     "ko",
11086:     "x-cyrillic",
11086:     "x-baltic",
11086:     "el",
11086:     "tr",
11086:     "th",
11086:     "he",
11086:     "ar",
11086:     "x-devanagari",
11086:     "x-tamil",
11086:     "x-armn",
11086:     "x-beng",
11086:     "x-cans",
11086:     "x-ethi",
11086:     "x-geor",
11086:     "x-gujr",
11086:     "x-guru",
11086:     "x-khmr",
11086:     "x-mlym",
13885:     "x-orya",
13885:     "x-telu",
13885:     "x-knda",
13885:     "x-sinh",
38930:     "x-tibt",
11086:     "x-unicode",
11086:     "x-user-def"
11086: };
11086: 
42854: gfxPlatform::gfxPlatform()
42854: {
67838:     mUseHarfBuzzScripts = UNINITIALIZED_VALUE;
42854:     mAllowDownloadableFonts = UNINITIALIZED_VALUE;
55084:     mDownloadableFontsSanitize = UNINITIALIZED_VALUE;
42854: }
11086: 
    1: gfxPlatform*
    1: gfxPlatform::GetPlatform()
    1: {
69151:     if (!gPlatform) {
69151:         Init();
69151:     }
  218:     return gPlatform;
  218: }
  218: 
68853: void
  218: gfxPlatform::Init()
  218: {
69151:     if (gEverInitialized) {
69151:         NS_RUNTIMEABORT("Already started???");
69151:     }
69151:     gEverInitialized = true;
38493: 
38493:     gfxAtoms::RegisterAtoms();
38493: 
61084: #ifdef PR_LOGGING
61084:     sFontlistLog = PR_NewLogModule("fontlist");;
61084:     sFontInitLog = PR_NewLogModule("fontinit");;
61084:     sTextrunLog = PR_NewLogModule("textrun");;
61084:     sTextrunuiLog = PR_NewLogModule("textrunui");;
61084: #endif
61084: 
61084: 
51677:     /* Initialize the GfxInfo service.
51677:      * Note: we can't call functions on GfxInfo that depend
51677:      * on gPlatform until after it has been initialized
51677:      * below. GfxInfo initialization annotates our
51677:      * crash reports so we want to do it before
51677:      * we try to load any drivers and do device detection
51677:      * incase that code crashes. See bug #591561. */
51677:     nsCOMPtr<nsIGfxInfo> gfxInfo;
51677:     /* this currently will only succeed on Windows */
51677:     gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
51677: 
    1: #if defined(XP_WIN)
    1:     gPlatform = new gfxWindowsPlatform;
    1: #elif defined(XP_MACOSX)
    1:     gPlatform = new gfxPlatformMac;
    1: #elif defined(MOZ_WIDGET_GTK2)
    1:     gPlatform = new gfxPlatformGtk;
16758: #elif defined(MOZ_WIDGET_QT)
16758:     gPlatform = new gfxQtPlatform;
    1: #elif defined(XP_OS2)
    1:     gPlatform = new gfxOS2Platform;
42153: #elif defined(ANDROID)
42153:     gPlatform = new gfxAndroidPlatform;
68665: #else
68665:     #error "No gfxPlatform implementation available"
    1: #endif
  218: 
  218:     nsresult rv;
  218: 
48022: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(ANDROID) // temporary, until this is implemented on others
31590:     rv = gfxPlatformFontList::Init();
  218:     if (NS_FAILED(rv)) {
68853:         NS_RUNTIMEABORT("Could not initialize gfxPlatformFontList");
  218:     }
  218: #endif
  218: 
57104:     gPlatform->mScreenReferenceSurface =
57104:         gPlatform->CreateOffscreenSurface(gfxIntSize(1,1),
57104:                                           gfxASurface::CONTENT_COLOR_ALPHA);
57104:     if (!gPlatform->mScreenReferenceSurface) {
68853:         NS_RUNTIMEABORT("Could not initialize mScreenReferenceSurface");
57104:     }
57104: 
  323:     rv = gfxFontCache::Init();
  323:     if (NS_FAILED(rv)) {
68853:         NS_RUNTIMEABORT("Could not initialize gfxFontCache");
  323:     }
  323: 
 3118:     rv = gfxTextRunWordCache::Init();
  218:     if (NS_FAILED(rv)) {
68853:         NS_RUNTIMEABORT("Could not initialize gfxTextRunWordCache");
 3118:     }
 3118: 
 3118:     rv = gfxTextRunCache::Init();
 3118:     if (NS_FAILED(rv)) {
68853:         NS_RUNTIMEABORT("Could not initialize gfxTextRunCache");
    1:     }
    1: 
16571:     /* Pref migration hook. */
16571:     MigratePrefs();
16571: 
19003:     /* Create and register our CMS Override observer. */
71640:     gPlatform->mSRGBOverrideObserver = new SRGBOverrideObserver();
71640:     Preferences::AddWeakObserver(gPlatform->mSRGBOverrideObserver, CMForceSRGBPrefName);
42854: 
71640:     gPlatform->mFontPrefsObserver = new FontPrefsObserver();
71640:     Preferences::AddStrongObservers(gPlatform->mFontPrefsObserver, kObservedPrefs);
69151: 
69151:     // Force registration of the gfx component, thus arranging for
69151:     // ::Shutdown to be called.
69151:     nsCOMPtr<nsISupports> forceReg
69151:         = do_CreateInstance("@mozilla.org/gfx/init;1");
    1: }
    1: 
    1: void
    1: gfxPlatform::Shutdown()
    1: {
  218:     // These may be called before the corresponding subsystems have actually
  218:     // started up. That's OK, they can handle it.
 3118:     gfxTextRunCache::Shutdown();
 3118:     gfxTextRunWordCache::Shutdown();
  323:     gfxFontCache::Shutdown();
38492:     gfxFontGroup::Shutdown();
36949: #if defined(XP_MACOSX) || defined(XP_WIN) // temporary, until this is implemented on others
31590:     gfxPlatformFontList::Shutdown();
  218: #endif
15987: 
15987:     // Free the various non-null transforms and loaded profiles
19003:     ShutdownCMS();
15987: 
71640:     // In some cases, gPlatform may not be created but Shutdown() called,
71640:     // e.g., during xpcshell tests.
71640:     if (gPlatform) {
19003:         /* Unregister our CMS Override callback. */
71640:         NS_ASSERTION(gPlatform->mSRGBOverrideObserver, "mSRGBOverrideObserver has alreay gone");
71640:         Preferences::RemoveObserver(gPlatform->mSRGBOverrideObserver, CMForceSRGBPrefName);
71640:         gPlatform->mSRGBOverrideObserver = nsnull;
71640: 
71640:         NS_ASSERTION(gPlatform->mFontPrefsObserver, "mFontPrefsObserver has alreay gone");
71640:         Preferences::RemoveObservers(gPlatform->mFontPrefsObserver, kObservedPrefs);
71640:         gPlatform->mFontPrefsObserver = nsnull;
71640:     }
15987: 
47967:     mozilla::gl::GLContextProvider::Shutdown();
47967: 
    1:     delete gPlatform;
    1:     gPlatform = nsnull;
    1: }
    1: 
    1: gfxPlatform::~gfxPlatform()
    1: {
    1:     // The cairo folks think we should only clean up in debug builds,
    1:     // but we're generally in the habit of trying to shut down as
    1:     // cleanly as possible even in production code, so call this
    1:     // cairo_debug_* function unconditionally.
 7193:     //
 7193:     // because cairo can assert and thus crash on shutdown, don't do this in release builds
11579: #if MOZ_TREE_CAIRO && (defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING) || defined(NS_TRACE_MALLOC))
    1:     cairo_debug_reset_static_data();
 7193: #endif
 6695: 
 6695: #if 0
 6695:     // It would be nice to do this (although it might need to be after
 6695:     // the cairo shutdown that happens in ~gfxPlatform).  It even looks
 6695:     // idempotent.  But it has fatal assertions that fire if stuff is
 6695:     // leaked, and we hit them.
 6695:     FcFini();
 6695: #endif
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
 8368: gfxPlatform::OptimizeImage(gfxImageSurface *aSurface,
 8368:                            gfxASurface::gfxImageFormat format)
    1: {
    1:     const gfxIntSize& surfaceSize = aSurface->GetSize();
    1: 
38727: #ifdef XP_WIN
38727:     if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() == 
38727:         gfxWindowsPlatform::RENDER_DIRECT2D) {
38727:         return nsnull;
38727:     }
38727: #endif
54253:     nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(surfaceSize, gfxASurface::ContentFromFormat(format));
 8368:     if (!optSurface || optSurface->CairoStatus() != 0)
    1:         return nsnull;
    1: 
 9751:     gfxContext tmpCtx(optSurface);
 9751:     tmpCtx.SetOperator(gfxContext::OPERATOR_SOURCE);
 9751:     tmpCtx.SetSource(aSurface);
 9751:     tmpCtx.Paint();
    1: 
    1:     gfxASurface *ret = optSurface;
    1:     NS_ADDREF(ret);
    1:     return ret;
    1: }
    1: 
    1: nsresult
38493: gfxPlatform::GetFontList(nsIAtom *aLangGroup,
    1:                          const nsACString& aGenericFamily,
23904:                          nsTArray<nsString>& aListOfFonts)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: nsresult
    1: gfxPlatform::UpdateFontList()
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
42854: PRBool
19962: gfxPlatform::DownloadableFontsEnabled()
19962: {
42854:     if (mAllowDownloadableFonts == UNINITIALIZED_VALUE) {
72023: #if defined(XP_MACOSX)
72023:         // Work around a serious bug in how Apple handles downloaded fonts
72023:         // on the most recent developer previews of OS X 10.7 (Lion, builds
72023:         // 11A480b and 11A494a).  See bug 663688.
72023:         if (gfxPlatformMac::GetPlatform()->OSXVersion() >= 0x1070) {
72023:             mAllowDownloadableFonts =
72023:                 Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_ENABLED_LION, PR_FALSE);
72023:         } else {
55084:             mAllowDownloadableFonts =
71640:                 Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_ENABLED, PR_FALSE);
19962:         }
72023: #else
72023:         mAllowDownloadableFonts =
72023:             Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_ENABLED, PR_FALSE);
72023: #endif
72023:     }
19962: 
42854:     return mAllowDownloadableFonts;
19962: }
19962: 
55084: PRBool
55084: gfxPlatform::SanitizeDownloadedFonts()
55084: {
55084:     if (mDownloadableFontsSanitize == UNINITIALIZED_VALUE) {
55084:         mDownloadableFontsSanitize =
71640:             Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_SANITIZE, PR_TRUE);
55084:     }
55084: 
55084:     return mDownloadableFontsSanitize;
55084: }
55084: 
55086: PRBool
67838: gfxPlatform::UseHarfBuzzForScript(PRInt32 aScriptCode)
43527: {
67838:     if (mUseHarfBuzzScripts == UNINITIALIZED_VALUE) {
71640:         mUseHarfBuzzScripts = Preferences::GetInt(GFX_PREF_HARFBUZZ_SCRIPTS, HARFBUZZ_SCRIPTS_DEFAULT);
43527:     }
43527: 
67838:     PRInt32 shapingType = gfxUnicodeProperties::ScriptShapingType(aScriptCode);
67838: 
67838:     return (mUseHarfBuzzScripts & shapingType) != 0;
43527: }
43527: 
32808: gfxFontEntry*
32808: gfxPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
32808:                               const PRUint8 *aFontData,
32808:                               PRUint32 aLength)
32808: {
32808:     // Default implementation does not handle activating downloaded fonts;
32808:     // just free the data and return.
32808:     // Platforms that support @font-face must override this,
32808:     // using the data to instantiate the font, and taking responsibility
32808:     // for freeing it when no longer required.
32808:     if (aFontData) {
32808:         NS_Free((void*)aFontData);
32808:     }
32808:     return nsnull;
32808: }
19962: 
    1: static void
38493: AppendGenericFontFromPref(nsString& aFonts, nsIAtom *aLangGroup, const char *aGenericName)
    1: {
71640:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), );
    1: 
38493:     nsCAutoString prefName, langGroupString;
    1: 
38493:     aLangGroup->ToUTF8String(langGroupString);
38493: 
26915:     nsCAutoString genericDotLang;
    1:     if (aGenericName) {
26915:         genericDotLang.Assign(aGenericName);
    1:     } else {
    1:         prefName.AssignLiteral("font.default.");
38493:         prefName.Append(langGroupString);
71640:         genericDotLang = Preferences::GetCString(prefName.get());
    1:     }
    1: 
    1:     genericDotLang.AppendLiteral(".");
38493:     genericDotLang.Append(langGroupString);
    1: 
 9699:     // fetch font.name.xxx value                   
    1:     prefName.AssignLiteral("font.name.");
    1:     prefName.Append(genericDotLang);
71640:     nsAdoptingString nameValue = Preferences::GetString(prefName.get());
71640:     if (nameValue) {
    1:         if (!aFonts.IsEmpty())
    1:             aFonts.AppendLiteral(", ");
71640:         aFonts += nameValue;
    1:     }
    1: 
 9699:     // fetch font.name-list.xxx value                   
    1:     prefName.AssignLiteral("font.name-list.");
    1:     prefName.Append(genericDotLang);
71640:     nsAdoptingString nameListValue = Preferences::GetString(prefName.get());
71640:     if (nameListValue && !nameListValue.Equals(nameValue)) {
    1:         if (!aFonts.IsEmpty())
    1:             aFonts.AppendLiteral(", ");
71640:         aFonts += nameListValue;
    1:     }
    1: }
    1: 
    1: void
38493: gfxPlatform::GetPrefFonts(nsIAtom *aLanguage, nsString& aFonts, PRBool aAppendUnicode)
    1: {
    1:     aFonts.Truncate();
    1: 
38492:     AppendGenericFontFromPref(aFonts, aLanguage, nsnull);
 3609:     if (aAppendUnicode)
38493:         AppendGenericFontFromPref(aFonts, gfxAtoms::x_unicode, nsnull);
    1: }
    1: 
11086: PRBool gfxPlatform::ForEachPrefFont(eFontPrefLang aLangArray[], PRUint32 aLangArrayLen, PrefFontCallback aCallback,
11086:                                     void *aClosure)
11086: {
71640:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), PR_FALSE);
11086: 
11086:     PRUint32    i;
11086:     for (i = 0; i < aLangArrayLen; i++) {
11086:         eFontPrefLang prefLang = aLangArray[i];
11086:         const char *langGroup = GetPrefLangName(prefLang);
11086:         
11086:         nsCAutoString prefName;
11086:     
11086:         prefName.AssignLiteral("font.default.");
11086:         prefName.Append(langGroup);
71640:         nsAdoptingCString genericDotLang = Preferences::GetCString(prefName.get());
11086:     
11086:         genericDotLang.AppendLiteral(".");
11086:         genericDotLang.Append(langGroup);
11086:     
11086:         // fetch font.name.xxx value                   
11086:         prefName.AssignLiteral("font.name.");
11086:         prefName.Append(genericDotLang);
71640:         nsAdoptingCString nameValue = Preferences::GetCString(prefName.get());
71640:         if (nameValue) {
26915:             if (!aCallback(prefLang, NS_ConvertUTF8toUTF16(nameValue), aClosure))
11086:                 return PR_FALSE;
11086:         }
11086:     
11086:         // fetch font.name-list.xxx value                   
11086:         prefName.AssignLiteral("font.name-list.");
11086:         prefName.Append(genericDotLang);
71640:         nsAdoptingCString nameListValue = Preferences::GetCString(prefName.get());
71640:         if (nameListValue && !nameListValue.Equals(nameValue)) {
36949:             const char kComma = ',';
36949:             const char *p, *p_end;
36949:             nsCAutoString list(nameListValue);
36949:             list.BeginReading(p);
36949:             list.EndReading(p_end);
36949:             while (p < p_end) {
36949:                 while (nsCRT::IsAsciiSpace(*p)) {
36949:                     if (++p == p_end)
36949:                         break;
36949:                 }
36949:                 if (p == p_end)
36949:                     break;
36949:                 const char *start = p;
36949:                 while (++p != p_end && *p != kComma)
36949:                     /* nothing */ ;
36949:                 nsCAutoString fontName(Substring(start, p));
36949:                 fontName.CompressWhitespace(PR_FALSE, PR_TRUE);
36949:                 if (!aCallback(prefLang, NS_ConvertUTF8toUTF16(fontName), aClosure))
11086:                     return PR_FALSE;
36949:                 p++;
36949:             }
11086:         }
11086:     }
11086: 
11086:     return PR_TRUE;
11086: }
11086: 
11086: eFontPrefLang
11086: gfxPlatform::GetFontPrefLangFor(const char* aLang)
11086: {
11086:     if (!aLang || !aLang[0])
11086:         return eFontPrefLang_Others;
11086:     for (PRUint32 i = 0; i < PRUint32(eFontPrefLang_LangCount); ++i) {
11086:         if (!PL_strcasecmp(gPrefLangNames[i], aLang))
11086:             return eFontPrefLang(i);
11086:     }
11086:     return eFontPrefLang_Others;
11086: }
11086: 
38493: eFontPrefLang
38493: gfxPlatform::GetFontPrefLangFor(nsIAtom *aLang)
38493: {
38493:     if (!aLang)
38493:         return eFontPrefLang_Others;
38493:     nsCAutoString lang;
38493:     aLang->ToUTF8String(lang);
38493:     return GetFontPrefLangFor(lang.get());
38493: }
38493: 
11086: const char*
11086: gfxPlatform::GetPrefLangName(eFontPrefLang aLang)
11086: {
11086:     if (PRUint32(aLang) < PRUint32(eFontPrefLang_AllCount))
11086:         return gPrefLangNames[PRUint32(aLang)];
11086:     return nsnull;
11086: }
11086: 
37211: eFontPrefLang
37211: gfxPlatform::GetFontPrefLangFor(PRUint8 aUnicodeRange)
37211: {
37211:     switch (aUnicodeRange) {
37211:         case kRangeSetLatin:   return eFontPrefLang_Western;
37211:         case kRangeCyrillic:   return eFontPrefLang_Cyrillic;
37211:         case kRangeGreek:      return eFontPrefLang_Greek;
37211:         case kRangeTurkish:    return eFontPrefLang_Turkish;
37211:         case kRangeHebrew:     return eFontPrefLang_Hebrew;
37211:         case kRangeArabic:     return eFontPrefLang_Arabic;
37211:         case kRangeBaltic:     return eFontPrefLang_Baltic;
37211:         case kRangeThai:       return eFontPrefLang_Thai;
37211:         case kRangeKorean:     return eFontPrefLang_Korean;
37211:         case kRangeJapanese:   return eFontPrefLang_Japanese;
37211:         case kRangeSChinese:   return eFontPrefLang_ChineseCN;
37211:         case kRangeTChinese:   return eFontPrefLang_ChineseTW;
37211:         case kRangeDevanagari: return eFontPrefLang_Devanagari;
37211:         case kRangeTamil:      return eFontPrefLang_Tamil;
37211:         case kRangeArmenian:   return eFontPrefLang_Armenian;
37211:         case kRangeBengali:    return eFontPrefLang_Bengali;
37211:         case kRangeCanadian:   return eFontPrefLang_Canadian;
37211:         case kRangeEthiopic:   return eFontPrefLang_Ethiopic;
37211:         case kRangeGeorgian:   return eFontPrefLang_Georgian;
37211:         case kRangeGujarati:   return eFontPrefLang_Gujarati;
37211:         case kRangeGurmukhi:   return eFontPrefLang_Gurmukhi;
37211:         case kRangeKhmer:      return eFontPrefLang_Khmer;
37211:         case kRangeMalayalam:  return eFontPrefLang_Malayalam;
64505:         case kRangeOriya:      return eFontPrefLang_Oriya;
64505:         case kRangeTelugu:     return eFontPrefLang_Telugu;
64505:         case kRangeKannada:    return eFontPrefLang_Kannada;
64505:         case kRangeSinhala:    return eFontPrefLang_Sinhala;
64505:         case kRangeTibetan:    return eFontPrefLang_Tibetan;
37211:         case kRangeSetCJK:     return eFontPrefLang_CJKSet;
37211:         default:               return eFontPrefLang_Others;
37211:     }
37211: }
37211: 
11086: PRBool 
11086: gfxPlatform::IsLangCJK(eFontPrefLang aLang)
11086: {
39063:     switch (aLang) {
39063:         case eFontPrefLang_Japanese:
39063:         case eFontPrefLang_ChineseTW:
39063:         case eFontPrefLang_ChineseCN:
39063:         case eFontPrefLang_ChineseHK:
39063:         case eFontPrefLang_Korean:
39063:         case eFontPrefLang_CJKSet:
39063:             return PR_TRUE;
39063:         default:
39063:             return PR_FALSE;
39063:     }
11086: }
11086: 
11086: void 
37211: gfxPlatform::GetLangPrefs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang)
37211: {
37211:     if (IsLangCJK(aCharLang)) {
37211:         AppendCJKPrefLangs(aPrefLangs, aLen, aCharLang, aPageLang);
37211:     } else {
37211:         AppendPrefLang(aPrefLangs, aLen, aCharLang);
37211:     }
37211: 
37211:     AppendPrefLang(aPrefLangs, aLen, eFontPrefLang_Others);
37211: }
37211: 
37211: void
37211: gfxPlatform::AppendCJKPrefLangs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang)
37211: {
37211:     // prefer the lang specified by the page *if* CJK
37211:     if (IsLangCJK(aPageLang)) {
37211:         AppendPrefLang(aPrefLangs, aLen, aPageLang);
37211:     }
37211:     
37211:     // if not set up, set up the default CJK order, based on accept lang settings and locale
37211:     if (mCJKPrefLangs.Length() == 0) {
37211:     
37211:         // temp array
37211:         eFontPrefLang tempPrefLangs[kMaxLenPrefLangList];
37211:         PRUint32 tempLen = 0;
37211:         
37211:         // Add the CJK pref fonts from accept languages, the order should be same order
71640:         nsAdoptingCString list = Preferences::GetLocalizedCString("intl.accept_languages");
39467:         if (!list.IsEmpty()) {
37211:             const char kComma = ',';
37211:             const char *p, *p_end;
37211:             list.BeginReading(p);
37211:             list.EndReading(p_end);
37211:             while (p < p_end) {
37211:                 while (nsCRT::IsAsciiSpace(*p)) {
37211:                     if (++p == p_end)
37211:                         break;
37211:                 }
37211:                 if (p == p_end)
37211:                     break;
37211:                 const char *start = p;
37211:                 while (++p != p_end && *p != kComma)
37211:                     /* nothing */ ;
37211:                 nsCAutoString lang(Substring(start, p));
37211:                 lang.CompressWhitespace(PR_FALSE, PR_TRUE);
37211:                 eFontPrefLang fpl = gfxPlatform::GetFontPrefLangFor(lang.get());
37211:                 switch (fpl) {
37211:                     case eFontPrefLang_Japanese:
37211:                     case eFontPrefLang_Korean:
37211:                     case eFontPrefLang_ChineseCN:
37211:                     case eFontPrefLang_ChineseHK:
37211:                     case eFontPrefLang_ChineseTW:
37211:                         AppendPrefLang(tempPrefLangs, tempLen, fpl);
37211:                         break;
37211:                     default:
37211:                         break;
37211:                 }
37211:                 p++;
37211:             }
37211:         }
37211: 
37211:         do { // to allow 'break' to abort this block if a call fails
37211:             nsresult rv;
37211:             nsCOMPtr<nsILocaleService> ls =
37211:                 do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
37211:             if (NS_FAILED(rv))
37211:                 break;
37211: 
37211:             nsCOMPtr<nsILocale> appLocale;
37211:             rv = ls->GetApplicationLocale(getter_AddRefs(appLocale));
37211:             if (NS_FAILED(rv))
37211:                 break;
37211: 
37211:             nsString localeStr;
37211:             rv = appLocale->
37211:                 GetCategory(NS_LITERAL_STRING(NSILOCALE_MESSAGE), localeStr);
37211:             if (NS_FAILED(rv))
37211:                 break;
37211: 
37211:             const nsAString& lang = Substring(localeStr, 0, 2);
37211:             if (lang.EqualsLiteral("ja")) {
37211:                 AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Japanese);
37211:             } else if (lang.EqualsLiteral("zh")) {
37211:                 const nsAString& region = Substring(localeStr, 3, 2);
37211:                 if (region.EqualsLiteral("CN")) {
37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseCN);
37211:                 } else if (region.EqualsLiteral("TW")) {
37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseTW);
37211:                 } else if (region.EqualsLiteral("HK")) {
37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseHK);
37211:                 }
37211:             } else if (lang.EqualsLiteral("ko")) {
37211:                 AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Korean);
37211:             }
37211:         } while (0);
37211: 
37211:         // last resort... (the order is same as old gfx.)
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Japanese);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Korean);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseCN);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseHK);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseTW);
37211:         
37211:         // copy into the cached array
37211:         PRUint32 j;
37211:         for (j = 0; j < tempLen; j++) {
37211:             mCJKPrefLangs.AppendElement(tempPrefLangs[j]);
37211:         }
37211:     }
37211:     
37211:     // append in cached CJK langs
37211:     PRUint32  i, numCJKlangs = mCJKPrefLangs.Length();
37211:     
37211:     for (i = 0; i < numCJKlangs; i++) {
37211:         AppendPrefLang(aPrefLangs, aLen, (eFontPrefLang) (mCJKPrefLangs[i]));
37211:     }
37211:         
37211: }
37211: 
37211: void 
11086: gfxPlatform::AppendPrefLang(eFontPrefLang aPrefLangs[], PRUint32& aLen, eFontPrefLang aAddLang)
11086: {
11086:     if (aLen >= kMaxLenPrefLangList) return;
11086:     
11086:     // make sure
11086:     PRUint32  i = 0;
11086:     while (i < aLen && aPrefLangs[i] != aAddLang) {
11086:         i++;
11086:     }
11086:     
11086:     if (i == aLen) {
11086:         aPrefLangs[aLen] = aAddLang;
11086:         aLen++;
11086:     }
11086: }
11086: 
16571: eCMSMode
16571: gfxPlatform::GetCMSMode()
 3787: {
19003:     if (gCMSInitialized == PR_FALSE) {
19003:         gCMSInitialized = PR_TRUE;
16571:         PRInt32 mode;
71640:         nsresult rv = Preferences::GetInt(CMPrefName, &mode);
16571:         if (NS_SUCCEEDED(rv) && (mode >= 0) && (mode < eCMSMode_AllCount)) {
19003:             gCMSMode = static_cast<eCMSMode>(mode);
 3787:         }
 3787:     }
19003:     return gCMSMode;
 3787: }
 3787: 
16152: /* Chris Murphy (CM consultant) suggests this as a default in the event that we
16152: cannot reproduce relative + Black Point Compensation.  BPC brings an
16152: unacceptable performance overhead, so we go with perceptual. */
27035: #define INTENT_DEFAULT QCMS_INTENT_PERCEPTUAL
27035: #define INTENT_MIN 0
27035: #define INTENT_MAX 3
16152: 
16152: PRBool
16152: gfxPlatform::GetRenderingIntent()
16152: {
19003:     if (gCMSIntent == -2) {
16152: 
16152:         /* Try to query the pref system for a rendering intent. */
16152:         PRInt32 pIntent;
71640:         if (NS_SUCCEEDED(Preferences::GetInt(CMIntentPrefName, &pIntent))) {
16152:             /* If the pref is within range, use it as an override. */
71640:             if ((pIntent >= INTENT_MIN) && (pIntent <= INTENT_MAX)) {
19003:                 gCMSIntent = pIntent;
71640:             }
16152:             /* If the pref is out of range, use embedded profile. */
71640:             else {
19003:                 gCMSIntent = -1;
16152:             }
16152:         }
16152:         /* If we didn't get a valid intent from prefs, use the default. */
71640:         else {
19003:             gCMSIntent = INTENT_DEFAULT;
16152:         }
71640:     }
19003:     return gCMSIntent;
16152: }
16152: 
19127: void 
27035: gfxPlatform::TransformPixel(const gfxRGBA& in, gfxRGBA& out, qcms_transform *transform)
19127: {
19127: 
19127:     if (transform) {
27035:         /* we want the bytes in RGB order */
19127: #ifdef IS_LITTLE_ENDIAN
27035:         /* ABGR puts the bytes in |RGBA| order on little endian */
19127:         PRUint32 packed = in.Packed(gfxRGBA::PACKED_ABGR);
27035:         qcms_transform_data(transform,
19127:                        (PRUint8 *)&packed, (PRUint8 *)&packed,
19127:                        1);
19127:         out.~gfxRGBA();
19127:         new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ABGR);
19127: #else
27035:         /* ARGB puts the bytes in |ARGB| order on big endian */
19127:         PRUint32 packed = in.Packed(gfxRGBA::PACKED_ARGB);
27035:         /* add one to move past the alpha byte */
27035:         qcms_transform_data(transform,
19127:                        (PRUint8 *)&packed + 1, (PRUint8 *)&packed + 1,
19127:                        1);
19127:         out.~gfxRGBA();
19127:         new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ARGB);
19127: #endif
19127:     }
19127: 
19127:     else if (&out != &in)
19127:         out = in;
19127: }
16152: 
27035: qcms_profile *
 3787: gfxPlatform::GetPlatformCMSOutputProfile()
 3787: {
 3787:     return nsnull;
 3787: }
 3787: 
27035: qcms_profile *
 3787: gfxPlatform::GetCMSOutputProfile()
 3787: {
 3787:     if (!gCMSOutputProfile) {
41340:         NS_TIME_FUNCTION;
 3787: 
19003:         /* Determine if we're using the internal override to force sRGB as
61192:            an output profile for reftests. See Bug 452125.
61192: 
61192:            Note that we don't normally (outside of tests) set a
71640:            default value of this preference, which means nsIPrefBranch::GetBoolPref
61192:            will typically throw (and leave its out-param untouched).
61192:          */
71640:         if (Preferences::GetBool(CMForceSRGBPrefName, PR_FALSE)) {
19003:             gCMSOutputProfile = GetCMSsRGBProfile();
71640:         }
19003: 
19003:         if (!gCMSOutputProfile) {
71640:             nsAdoptingCString fname = Preferences::GetCString(CMProfilePrefName);
71640:             if (!fname.IsEmpty()) {
27035:                 gCMSOutputProfile = qcms_profile_from_path(fname);
19003:             }
 3787:         }
 3787: 
 3787:         if (!gCMSOutputProfile) {
 3787:             gCMSOutputProfile =
 3787:                 gfxPlatform::GetPlatform()->GetPlatformCMSOutputProfile();
 3787:         }
 3787: 
22446:         /* Determine if the profile looks bogus. If so, close the profile
22446:          * and use sRGB instead. See bug 460629, */
27035:         if (gCMSOutputProfile && qcms_profile_is_bogus(gCMSOutputProfile)) {
22446:             NS_ASSERTION(gCMSOutputProfile != GetCMSsRGBProfile(),
22446:                          "Builtin sRGB profile tagged as bogus!!!");
27035:             qcms_profile_release(gCMSOutputProfile);
22446:             gCMSOutputProfile = nsnull;
22446:         }
22446: 
 3787:         if (!gCMSOutputProfile) {
15987:             gCMSOutputProfile = GetCMSsRGBProfile();
 3787:         }
16720:         /* Precache the LUT16 Interpolations for the output profile. See 
16720:            bug 444661 for details. */
27035:         qcms_profile_precache_output_transform(gCMSOutputProfile);
 3787:     }
 3787: 
 3787:     return gCMSOutputProfile;
 3787: }
 3787: 
27035: qcms_profile *
15987: gfxPlatform::GetCMSsRGBProfile()
15987: {
16720:     if (!gCMSsRGBProfile) {
16720: 
32801:         /* Create the profile using qcms. */
27035:         gCMSsRGBProfile = qcms_profile_sRGB();
16720:     }
15987:     return gCMSsRGBProfile;
15987: }
15987: 
27035: qcms_transform *
 3787: gfxPlatform::GetCMSRGBTransform()
 3787: {
 3787:     if (!gCMSRGBTransform) {
27035:         qcms_profile *inProfile, *outProfile;
 3787:         outProfile = GetCMSOutputProfile();
15987:         inProfile = GetCMSsRGBProfile();
 3787: 
 3787:         if (!inProfile || !outProfile)
 3787:             return nsnull;
 3787: 
27035:         gCMSRGBTransform = qcms_transform_create(inProfile, QCMS_DATA_RGB_8,
27035:                                               outProfile, QCMS_DATA_RGB_8,
27035:                                              QCMS_INTENT_PERCEPTUAL);
 3787:     }
 3787: 
 3787:     return gCMSRGBTransform;
 3787: }
 3787: 
27035: qcms_transform *
 5465: gfxPlatform::GetCMSInverseRGBTransform()
 5465: {
 5465:     if (!gCMSInverseRGBTransform) {
27035:         qcms_profile *inProfile, *outProfile;
 5465:         inProfile = GetCMSOutputProfile();
15987:         outProfile = GetCMSsRGBProfile();
 5465: 
 5465:         if (!inProfile || !outProfile)
 5465:             return nsnull;
 5465: 
27035:         gCMSInverseRGBTransform = qcms_transform_create(inProfile, QCMS_DATA_RGB_8,
27035:                                                      outProfile, QCMS_DATA_RGB_8,
27035:                                                      QCMS_INTENT_PERCEPTUAL);
 5465:     }
 5465: 
 5465:     return gCMSInverseRGBTransform;
 5465: }
 5465: 
27035: qcms_transform *
 3787: gfxPlatform::GetCMSRGBATransform()
 3787: {
 3787:     if (!gCMSRGBATransform) {
27035:         qcms_profile *inProfile, *outProfile;
 3787:         outProfile = GetCMSOutputProfile();
15987:         inProfile = GetCMSsRGBProfile();
 3787: 
 3787:         if (!inProfile || !outProfile)
 3787:             return nsnull;
 3787: 
27035:         gCMSRGBATransform = qcms_transform_create(inProfile, QCMS_DATA_RGBA_8,
27035:                                                outProfile, QCMS_DATA_RGBA_8,
27035:                                                QCMS_INTENT_PERCEPTUAL);
 3787:     }
 3787: 
 3787:     return gCMSRGBATransform;
 3787: }
16571: 
19003: /* Shuts down various transforms and profiles for CMS. */
19003: static void ShutdownCMS()
19003: {
19003: 
19003:     if (gCMSRGBTransform) {
27035:         qcms_transform_release(gCMSRGBTransform);
19003:         gCMSRGBTransform = nsnull;
19003:     }
19003:     if (gCMSInverseRGBTransform) {
27035:         qcms_transform_release(gCMSInverseRGBTransform);
19003:         gCMSInverseRGBTransform = nsnull;
19003:     }
19003:     if (gCMSRGBATransform) {
27035:         qcms_transform_release(gCMSRGBATransform);
19003:         gCMSRGBATransform = nsnull;
19003:     }
19003:     if (gCMSOutputProfile) {
27035:         qcms_profile_release(gCMSOutputProfile);
19003: 
19003:         // handle the aliased case
19003:         if (gCMSsRGBProfile == gCMSOutputProfile)
19003:             gCMSsRGBProfile = nsnull;
19003:         gCMSOutputProfile = nsnull;
19003:     }
19003:     if (gCMSsRGBProfile) {
27035:         qcms_profile_release(gCMSsRGBProfile);
19003:         gCMSsRGBProfile = nsnull;
19003:     }
19003: 
19003:     // Reset the state variables
19003:     gCMSIntent = -2;
19003:     gCMSMode = eCMSMode_Off;
19003:     gCMSInitialized = PR_FALSE;
19003: }
19003: 
16571: static void MigratePrefs()
16571: {
16571:     /* Migrate from the boolean color_management.enabled pref - we now use
16571:        color_management.mode. */
71640:     if (Preferences::HasUserValue(CMPrefNameOld)) {
71640:         if (Preferences::GetBool(CMPrefNameOld, PR_FALSE)) {
71640:             Preferences::SetInt(CMPrefName, static_cast<PRInt32>(eCMSMode_All));
16571:         }
71640:         Preferences::ClearUser(CMPrefNameOld);
71640:     }
16571: }
32950: 
37211: // default SetupClusterBoundaries, based on Unicode properties;
37211: // platform subclasses may override if they wish
37211: void
37211: gfxPlatform::SetupClusterBoundaries(gfxTextRun *aTextRun, const PRUnichar *aString)
37211: {
37211:     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) {
37211:         // 8-bit text doesn't have clusters.
37211:         // XXX is this true in all languages???
37211:         // behdad: don't think so.  Czech for example IIRC has a
37211:         // 'ch' grapheme.
58936:         // jfkthame: but that's not expected to behave as a grapheme cluster
58936:         // for selection/editing/etc.
37211:         return;
37211:     }
37211: 
58936:     gfxTextRun::CompressedGlyph extendCluster;
58936:     extendCluster.SetComplex(PR_FALSE, PR_TRUE, 0);
37211: 
37211:     PRUint32 i, length = aTextRun->GetLength();
58936:     gfxUnicodeProperties::HSType hangulState = gfxUnicodeProperties::HST_NONE;
58936: 
37211:     for (i = 0; i < length; ++i) {
37211:         PRBool surrogatePair = PR_FALSE;
37211:         PRUint32 ch = aString[i];
37211:         if (NS_IS_HIGH_SURROGATE(ch) &&
58936:             i < length - 1 && NS_IS_LOW_SURROGATE(aString[i+1]))
58936:         {
37211:             ch = SURROGATE_TO_UCS4(ch, aString[i+1]);
37211:             surrogatePair = PR_TRUE;
37211:         }
58936: 
58936:         PRUint8 category = gfxUnicodeProperties::GetGeneralCategory(ch);
58936:         gfxUnicodeProperties::HSType hangulType = gfxUnicodeProperties::HST_NONE;
58936: 
58936:         // combining marks extend the cluster
58936:         if ((category >= HB_CATEGORY_COMBINING_MARK &&
58936:              category <= HB_CATEGORY_NON_SPACING_MARK) ||
58936:             (ch >= 0x200c && ch <= 0x200d) || // ZWJ, ZWNJ
58936:             (ch >= 0xff9e && ch <= 0xff9f))   // katakana sound marks
58936:         {
58936:             if (i > 0) {
58936:                 aTextRun->SetGlyphs(i, extendCluster, nsnull);
37211:             }
58936:         } else if (category == HB_CATEGORY_OTHER_LETTER) {
58936:             // handle special cases in Letter_Other category
58936: #if 0
58936:             // Currently disabled. This would follow the UAX#29 specification
58936:             // for extended grapheme clusters, but this is not favored by
58936:             // Thai users, at least for editing behavior.
58936:             // See discussion of equivalent Pango issue in bug 474068 and
58936:             // upstream at https://bugzilla.gnome.org/show_bug.cgi?id=576156.
58936: 
58936:             if ((ch & ~0xff) == 0x0e00) {
58936:                 // specific Thai & Lao (U+0Exx) chars that extend the cluster
58936:                 if ( ch == 0x0e30 ||
58936:                     (ch >= 0x0e32 && ch <= 0x0e33) ||
58936:                      ch == 0x0e45 ||
58936:                      ch == 0x0eb0 ||
58936:                     (ch >= 0x0eb2 && ch <= 0x0eb3))
58936:                 {
58936:                     if (i > 0) {
58936:                         aTextRun->SetGlyphs(i, extendCluster, nsnull);
58936:                     }
58936:                 }
58936:                 else if ((ch >= 0x0e40 && ch <= 0x0e44) ||
58936:                          (ch >= 0x0ec0 && ch <= 0x0ec4))
58936:                 {
58936:                     // characters that are prepended to the following cluster
58936:                     if (i < length - 1) {
58936:                         aTextRun->SetGlyphs(i+1, extendCluster, nsnull);
58936:                     }
58936:                 }
58936:             } else
58936: #endif
58936:             if ((ch & ~0xff) == 0x1100 ||
58936:                 (ch >= 0xa960 && ch <= 0xa97f) ||
58936:                 (ch >= 0xac00 && ch <= 0xd7ff))
58936:             {
58936:                 // no break within Hangul syllables
58936:                 hangulType = gfxUnicodeProperties::GetHangulSyllableType(ch);
58936:                 switch (hangulType) {
58936:                 case gfxUnicodeProperties::HST_L:
58936:                 case gfxUnicodeProperties::HST_LV:
58936:                 case gfxUnicodeProperties::HST_LVT:
58936:                     if (hangulState == gfxUnicodeProperties::HST_L) {
58936:                         aTextRun->SetGlyphs(i, extendCluster, nsnull);
58936:                     }
58936:                     break;
58936:                 case gfxUnicodeProperties::HST_V:
58936:                     if ( (hangulState != gfxUnicodeProperties::HST_NONE) &&
58936:                         !(hangulState & gfxUnicodeProperties::HST_T))
58936:                     {
58936:                         aTextRun->SetGlyphs(i, extendCluster, nsnull);
58936:                     }
58936:                     break;
58936:                 case gfxUnicodeProperties::HST_T:
58936:                     if (hangulState & (gfxUnicodeProperties::HST_V |
58936:                                        gfxUnicodeProperties::HST_T))
58936:                     {
58936:                         aTextRun->SetGlyphs(i, extendCluster, nsnull);
58936:                     }
58936:                     break;
58936:                 default:
58936:                     break;
58936:                 }
58936:             }
58936:         }
58936: 
37211:         if (surrogatePair) {
37211:             ++i;
58936:             aTextRun->SetGlyphs(i, extendCluster, nsnull);
37211:         }
58936: 
58936:         hangulState = hangulType;
37211:     }
37211: }
42854: 
42854: void
71640: gfxPlatform::FontsPrefsChanged(const char *aPref)
42854: {
43527:     NS_ASSERTION(aPref != nsnull, "null preference");
42854:     if (!strcmp(GFX_DOWNLOADABLE_FONTS_ENABLED, aPref)) {
42854:         mAllowDownloadableFonts = UNINITIALIZED_VALUE;
55084:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_SANITIZE, aPref)) {
55084:         mDownloadableFontsSanitize = UNINITIALIZED_VALUE;
67838:     } else if (!strcmp(GFX_PREF_HARFBUZZ_SCRIPTS, aPref)) {
67838:         mUseHarfBuzzScripts = UNINITIALIZED_VALUE;
43527:         gfxTextRunWordCache::Flush();
43527:         gfxFontCache::GetCache()->AgeAllGenerations();
42854:     }
42854: }
61084: 
61084: 
61084: PRLogModuleInfo*
61084: gfxPlatform::GetLog(eGfxLog aWhichLog)
61084: {
61084: #ifdef PR_LOGGING
61084:     switch (aWhichLog) {
61084:     case eGfxLog_fontlist:
61084:         return sFontlistLog;
61084:         break;
61084:     case eGfxLog_fontinit:
61084:         return sFontInitLog;
61084:         break;
61084:     case eGfxLog_textrun:
61084:         return sTextrunLog;
61084:         break;
61084:     case eGfxLog_textrunui:
61084:         return sTextrunuiLog;
61084:         break;
61084:     default:
61084:         break;
61084:     }
61084: 
61084:     return nsnull;
61084: #else
61084:     return nsnull;
61084: #endif
61084: }
