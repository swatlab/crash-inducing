106955: /* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2; js-indent-level: 2; -*- */
 89580: /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
182866: 
 89580: "use strict";
110808: 
178572: let TYPED_ARRAY_CLASSES = ["Uint8Array", "Uint8ClampedArray", "Uint16Array",
178572:       "Uint32Array", "Int8Array", "Int16Array", "Int32Array", "Float32Array",
178572:       "Float64Array"];
178572: 
178572: // Number of items to preview in objects, arrays, maps, sets, lists,
178572: // collections, etc.
178572: let OBJECT_PREVIEW_MAX_ITEMS = 10;
178572: 
 89580: /**
153128:  * BreakpointStore objects keep track of all breakpoints that get set so that we
153128:  * can reset them when the same script is introduced to the thread again (such
153128:  * as after a refresh).
153128:  */
153128: function BreakpointStore() {
153128:   // If we have a whole-line breakpoint set at LINE in URL, then
153128:   //
153128:   //   this._wholeLineBreakpoints[URL][LINE]
153128:   //
153128:   // is an object
153128:   //
153128:   //   { url, line[, actor] }
153128:   //
153128:   // where the `actor` property is optional.
153128:   this._wholeLineBreakpoints = Object.create(null);
153128: 
153128:   // If we have a breakpoint set at LINE, COLUMN in URL, then
153128:   //
153128:   //   this._breakpoints[URL][LINE][COLUMN]
153128:   //
153128:   // is an object
153128:   //
153128:   //   { url, line[, actor] }
153128:   //
153128:   // where the `actor` property is optional.
153128:   this._breakpoints = Object.create(null);
153128: }
153128: 
153128: BreakpointStore.prototype = {
153128: 
153128:   /**
153128:    * Add a breakpoint to the breakpoint store.
153128:    *
153128:    * @param Object aBreakpoint
153128:    *        The breakpoint to be added (not copied). It is an object with the
153128:    *        following properties:
153128:    *          - url
153128:    *          - line
153128:    *          - column (optional; omission implies that the breakpoint is for
153128:    *            the whole line)
153128:    *          - actor (optional)
153128:    */
169591:   addBreakpoint: function (aBreakpoint) {
153128:     let { url, line, column } = aBreakpoint;
153128: 
153128:     if (column != null) {
153128:       if (!this._breakpoints[url]) {
153128:         this._breakpoints[url] = [];
153128:       }
153128:       if (!this._breakpoints[url][line]) {
153128:         this._breakpoints[url][line] = [];
153128:       }
153128:       this._breakpoints[url][line][column] = aBreakpoint;
153128:     } else {
153128:       // Add a breakpoint that breaks on the whole line.
153128:       if (!this._wholeLineBreakpoints[url]) {
153128:         this._wholeLineBreakpoints[url] = [];
153128:       }
153128:       this._wholeLineBreakpoints[url][line] = aBreakpoint;
153128:     }
153128:   },
153128: 
153128:   /**
153128:    * Remove a breakpoint from the breakpoint store.
153128:    *
153128:    * @param Object aBreakpoint
153128:    *        The breakpoint to be removed. It is an object with the following
153128:    *        properties:
153128:    *          - url
153128:    *          - line
153128:    *          - column (optional)
153128:    */
169591:   removeBreakpoint: function ({ url, line, column }) {
153128:     if (column != null) {
153128:       if (this._breakpoints[url]) {
153128:         if (this._breakpoints[url][line]) {
153128:           delete this._breakpoints[url][line][column];
153128: 
153128:           // If this was the last breakpoint on this line, delete the line from
153128:           // `this._breakpoints[url]` as well. Otherwise `_iterLines` will yield
153128:           // this line even though we no longer have breakpoints on
153128:           // it. Furthermore, we use Object.keys() instead of just checking
153128:           // `this._breakpoints[url].length` directly, because deleting
153128:           // properties from sparse arrays doesn't update the `length` property
153128:           // like adding them does.
153128:           if (Object.keys(this._breakpoints[url][line]).length === 0) {
153128:             delete this._breakpoints[url][line];
153128:           }
153128:         }
153128:       }
153128:     } else {
153128:       if (this._wholeLineBreakpoints[url]) {
153128:         delete this._wholeLineBreakpoints[url][line];
153128:       }
153128:     }
153128:   },
153128: 
153128:   /**
153128:    * Get a breakpoint from the breakpoint store. Will throw an error if the
153937:    * breakpoint is not found.
153128:    *
153128:    * @param Object aLocation
153128:    *        The location of the breakpoint you are retrieving. It is an object
153128:    *        with the following properties:
153128:    *          - url
153128:    *          - line
153128:    *          - column (optional)
153128:    */
169591:   getBreakpoint: function (aLocation) {
153937:     let { url, line, column } = aLocation;
153937:     dbg_assert(url != null);
153937:     dbg_assert(line != null);
153937: 
153937:     var foundBreakpoint = this.hasBreakpoint(aLocation);
153937:     if (foundBreakpoint == null) {
153937:       throw new Error("No breakpoint at url = " + url
153937:           + ", line = " + line
153937:           + ", column = " + column);
153937:     }
153937: 
153937:     return foundBreakpoint;
153937:   },
153937: 
153937:   /**
156845:    * Checks if the breakpoint store has a requested breakpoint.
153937:    *
153937:    * @param Object aLocation
153937:    *        The location of the breakpoint you are retrieving. It is an object
153937:    *        with the following properties:
153937:    *          - url
153937:    *          - line
153937:    *          - column (optional)
156845:    * @returns The stored breakpoint if it exists, null otherwise.
153937:    */
169591:   hasBreakpoint: function (aLocation) {
153128:     let { url, line, column } = aLocation;
153128:     dbg_assert(url != null);
153128:     dbg_assert(line != null);
153128:     for (let bp of this.findBreakpoints(aLocation)) {
153128:       // We will get whole line breakpoints before individual columns, so just
153128:       // return the first one and if they didn't specify a column then they will
153128:       // get the whole line breakpoint, and otherwise we will find the correct
153128:       // one.
153128:       return bp;
153128:     }
153937: 
153128:     return null;
153128:   },
153128: 
153128:   /**
153128:    * Iterate over the breakpoints in this breakpoint store. You can optionally
153128:    * provide search parameters to filter the set of breakpoints down to those
153128:    * that match your parameters.
153128:    *
153128:    * @param Object aSearchParams
153128:    *        Optional. An object with the following properties:
153128:    *          - url
153128:    *          - line (optional; requires the url property)
153128:    *          - column (optional; requires the line property)
153128:    */
169591:   findBreakpoints: function (aSearchParams={}) {
153128:     if (aSearchParams.column != null) {
153128:       dbg_assert(aSearchParams.line != null);
153128:     }
153128:     if (aSearchParams.line != null) {
153128:       dbg_assert(aSearchParams.url != null);
153128:     }
153128: 
153128:     for (let url of this._iterUrls(aSearchParams.url)) {
153128:       for (let line of this._iterLines(url, aSearchParams.line)) {
153128:         // Always yield whole line breakpoints first. See comment in
156845:         // |BreakpointStore.prototype.hasBreakpoint|.
153128:         if (aSearchParams.column == null
153128:             && this._wholeLineBreakpoints[url]
153128:             && this._wholeLineBreakpoints[url][line]) {
153128:           yield this._wholeLineBreakpoints[url][line];
153128:         }
153128:         for (let column of this._iterColumns(url, line, aSearchParams.column)) {
153128:           yield this._breakpoints[url][line][column];
153128:         }
153128:       }
153128:     }
153128:   },
153128: 
169591:   _iterUrls: function (aUrl) {
153128:     if (aUrl) {
153128:       if (this._breakpoints[aUrl] || this._wholeLineBreakpoints[aUrl]) {
153128:         yield aUrl;
153128:       }
153128:     } else {
153128:       for (let url of Object.keys(this._wholeLineBreakpoints)) {
153128:         yield url;
153128:       }
153128:       for (let url of Object.keys(this._breakpoints)) {
153128:         if (url in this._wholeLineBreakpoints) {
153128:           continue;
153128:         }
153128:         yield url;
153128:       }
153128:     }
153128:   },
153128: 
169591:   _iterLines: function (aUrl, aLine) {
153128:     if (aLine != null) {
153128:       if ((this._wholeLineBreakpoints[aUrl]
153128:            && this._wholeLineBreakpoints[aUrl][aLine])
153128:           || (this._breakpoints[aUrl] && this._breakpoints[aUrl][aLine])) {
153128:         yield aLine;
153128:       }
153128:     } else {
153128:       const wholeLines = this._wholeLineBreakpoints[aUrl]
153128:         ? Object.keys(this._wholeLineBreakpoints[aUrl])
153128:         : [];
153128:       const columnLines = this._breakpoints[aUrl]
153128:         ? Object.keys(this._breakpoints[aUrl])
153128:         : [];
153128: 
153128:       const lines = wholeLines.concat(columnLines).sort();
153128: 
153128:       let lastLine;
153128:       for (let line of lines) {
153128:         if (line === lastLine) {
153128:           continue;
153128:         }
153128:         yield line;
153128:         lastLine = line;
153128:       }
153128:     }
153128:   },
153128: 
169591:   _iterColumns: function (aUrl, aLine, aColumn) {
153128:     if (!this._breakpoints[aUrl] || !this._breakpoints[aUrl][aLine]) {
153128:       return;
153128:     }
153128: 
153128:     if (aColumn != null) {
153128:       if (this._breakpoints[aUrl][aLine][aColumn]) {
153128:         yield aColumn;
153128:       }
153128:     } else {
153128:       for (let column in this._breakpoints[aUrl][aLine]) {
153128:         yield column;
153128:       }
153128:     }
153128:   },
153128: };
153128: 
153128: /**
156845:  * Manages pushing event loops and automatically pops and exits them in the
156845:  * correct order as they are resolved.
156845:  *
156845:  * @param nsIJSInspector inspector
156845:  *        The underlying JS inspector we use to enter and exit nested event
156845:  *        loops.
176551:  * @param ThreadActor thread
176551:  *        The thread actor instance that owns this EventLoopStack.
176551:  * @param DebuggerServerConnection connection
176551:  *        The remote protocol connection associated with this event loop stack.
156845:  * @param Object hooks
156845:  *        An object with the following properties:
156845:  *          - url: The URL string of the debuggee we are spinning an event loop
156845:  *                 for.
156845:  *          - preNest: function called before entering a nested event loop
156845:  *          - postNest: function called after exiting a nested event loop
156845:  */
176551: function EventLoopStack({ inspector, thread, connection, hooks }) {
156845:   this._inspector = inspector;
156845:   this._hooks = hooks;
156845:   this._thread = thread;
176551:   this._connection = connection;
156845: }
156845: 
156845: EventLoopStack.prototype = {
156845:   /**
156845:    * The number of nested event loops on the stack.
156845:    */
156845:   get size() {
156845:     return this._inspector.eventLoopNestLevel;
156845:   },
156845: 
156845:   /**
156845:    * The URL of the debuggee who pushed the event loop on top of the stack.
156845:    */
156845:   get lastPausedUrl() {
162535:     let url = null;
162535:     if (this.size > 0) {
162535:       try {
162535:         url = this._inspector.lastNestRequestor.url
162535:       } catch (e) {
162535:         // The tab's URL getter may throw if the tab is destroyed by the time
162535:         // this code runs, but we don't really care at this point.
162535:         dumpn(e);
162535:       }
162535:     }
162535:     return url;
156845:   },
156845: 
156845:   /**
176551:    * The DebuggerServerConnection of the debugger who pushed the event loop on
176551:    * top of the stack
176551:    */
176551:   get lastConnection() {
176551:     return this._inspector.lastNestRequestor._connection;
176551:   },
176551: 
176551:   /**
156845:    * Push a new nested event loop onto the stack.
156845:    *
156845:    * @returns EventLoop
156845:    */
156845:   push: function () {
156845:     return new EventLoop({
156845:       inspector: this._inspector,
156845:       thread: this._thread,
176551:       connection: this._connection,
156845:       hooks: this._hooks
156845:     });
156845:   }
156845: };
156845: 
156845: /**
156845:  * An object that represents a nested event loop. It is used as the nest
156845:  * requestor with nsIJSInspector instances.
156845:  *
156845:  * @param nsIJSInspector inspector
156845:  *        The JS Inspector that runs nested event loops.
156845:  * @param ThreadActor thread
156845:  *        The thread actor that is creating this nested event loop.
176551:  * @param DebuggerServerConnection connection
176551:  *        The remote protocol connection associated with this event loop.
156845:  * @param Object hooks
156845:  *        The same hooks object passed into EventLoopStack during its
156845:  *        initialization.
156845:  */
176551: function EventLoop({ inspector, thread, connection, hooks }) {
156845:   this._inspector = inspector;
156845:   this._thread = thread;
156845:   this._hooks = hooks;
176551:   this._connection = connection;
156845: 
156845:   this.enter = this.enter.bind(this);
156845:   this.resolve = this.resolve.bind(this);
156845: }
156845: 
156845: EventLoop.prototype = {
156845:   entered: false,
156845:   resolved: false,
156845:   get url() { return this._hooks.url; },
156845: 
156845:   /**
156845:    * Enter this nested event loop.
156845:    */
156845:   enter: function () {
156845:     let nestData = this._hooks.preNest
156845:       ? this._hooks.preNest()
156845:       : null;
156845: 
156845:     this.entered = true;
156845:     this._inspector.enterNestedEventLoop(this);
156845: 
156845:     // Keep exiting nested event loops while the last requestor is resolved.
156845:     if (this._inspector.eventLoopNestLevel > 0) {
156845:       const { resolved } = this._inspector.lastNestRequestor;
156845:       if (resolved) {
156845:         this._inspector.exitNestedEventLoop();
156845:       }
156845:     }
156845: 
156845:     dbg_assert(this._thread.state === "running",
156845:                "Should be in the running state");
156845: 
156845:     if (this._hooks.postNest) {
156845:       this._hooks.postNest(nestData);
156845:     }
156845:   },
156845: 
156845:   /**
156845:    * Resolve this nested event loop.
156845:    *
156845:    * @returns boolean
156845:    *          True if we exited this nested event loop because it was on top of
156845:    *          the stack, false if there is another nested event loop above this
156845:    *          one that hasn't resolved yet.
156845:    */
156845:   resolve: function () {
156845:     if (!this.entered) {
156845:       throw new Error("Can't resolve an event loop before it has been entered!");
156845:     }
156845:     if (this.resolved) {
156845:       throw new Error("Already resolved this nested event loop!");
156845:     }
156845:     this.resolved = true;
156845:     if (this === this._inspector.lastNestRequestor) {
156845:       this._inspector.exitNestedEventLoop();
156845:       return true;
156845:     }
156845:     return false;
156845:   },
156845: };
156845: 
156845: /**
 89580:  * JSD2 actors.
 89580:  */
 89580: /**
 89580:  * Creates a ThreadActor.
 89580:  *
 89580:  * ThreadActors manage a JSInspector object and manage execution/inspection
 89580:  * of debuggees.
 89581:  *
 89581:  * @param aHooks object
 89862:  *        An object with preNest and postNest methods for calling when entering
174909:  *        and exiting a nested event loop.
121120:  * @param aGlobal object [optional]
121120:  *        An optional (for content debugging only) reference to the content
121120:  *        window.
 89580:  */
121120: function ThreadActor(aHooks, aGlobal)
 89580: {
 89580:   this._state = "detached";
 89580:   this._frameActors = [];
120758:   this._hooks = aHooks;
121120:   this.global = aGlobal;
152472:   // A map of actorID -> actor for breakpoints created and managed by the server.
152472:   this._hiddenBreakpoints = new Map();
122255: 
120758:   this.findGlobals = this.globalManager.findGlobals.bind(this);
120758:   this.onNewGlobal = this.globalManager.onNewGlobal.bind(this);
140693:   this.onNewSource = this.onNewSource.bind(this);
152472:   this._allEventsListener = this._allEventsListener.bind(this);
140693: 
140693:   this._options = {
140693:     useSourceMaps: false
140693:   };
178572: 
178572:   this._gripDepth = 0;
 89580: }
 89580: 
107931: /**
107931:  * The breakpoint store must be shared across instances of ThreadActor so that
107931:  * page reloads don't blow away all of our breakpoints.
107931:  */
153128: ThreadActor.breakpointStore = new BreakpointStore();
107931: 
 89580: ThreadActor.prototype = {
178572:   // Used by the ObjectActor to keep track of the depth of grip() calls.
178572:   _gripDepth: null,
178572: 
 89580:   actorPrefix: "context",
 89580: 
 89580:   get state() { return this._state; },
120758:   get attached() this.state == "attached" ||
120758:                  this.state == "running" ||
120758:                  this.state == "paused",
 89580: 
153128:   get breakpointStore() { return ThreadActor.breakpointStore; },
107931: 
 89580:   get threadLifetimePool() {
 89580:     if (!this._threadLifetimePool) {
 89580:       this._threadLifetimePool = new ActorPool(this.conn);
 89580:       this.conn.addActorPool(this._threadLifetimePool);
121780:       this._threadLifetimePool.objectActors = new WeakMap();
 89580:     }
 89580:     return this._threadLifetimePool;
 89580:   },
 89580: 
140693:   get sources() {
140693:     if (!this._sources) {
140693:       this._sources = new ThreadSources(this, this._options.useSourceMaps,
140693:                                         this._allowSource, this.onNewSource);
140693:     }
140693:     return this._sources;
140693:   },
140693: 
165285:   get youngestFrame() {
179268:     if (this.state != "paused") {
165285:       return null;
165285:     }
165285:     return this.dbg.getNewestFrame();
165285:   },
165285: 
164286:   _prettyPrintWorker: null,
164286:   get prettyPrintWorker() {
164286:     if (!this._prettyPrintWorker) {
164286:       this._prettyPrintWorker = new ChromeWorker(
164286:         "resource://gre/modules/devtools/server/actors/pretty-print-worker.js");
164286: 
164286:       this._prettyPrintWorker.addEventListener(
164286:         "error", this._onPrettyPrintError, false);
164286: 
164286:       if (wantLogging) {
164286:         this._prettyPrintWorker.addEventListener("message", this._onPrettyPrintMsg, false);
164286: 
164286:         const postMsg = this._prettyPrintWorker.postMessage;
164286:         this._prettyPrintWorker.postMessage = data => {
164286:           dumpn("Sending message to prettyPrintWorker: "
164286:                 + JSON.stringify(data, null, 2) + "\n");
164286:           return postMsg.call(this._prettyPrintWorker, data);
164286:         };
164286:       }
164286:     }
164286:     return this._prettyPrintWorker;
164286:   },
164286: 
169274:   _onPrettyPrintError: function ({ message, filename, lineno }) {
169274:     reportError(new Error(message + " @ " + filename + ":" + lineno));
164286:   },
164286: 
164286:   _onPrettyPrintMsg: function ({ data }) {
164286:     dumpn("Received message from prettyPrintWorker: "
164286:           + JSON.stringify(data, null, 2) + "\n");
164286:   },
164286: 
156845:   /**
156845:    * Keep track of all of the nested event loops we use to pause the debuggee
156845:    * when we hit a breakpoint/debugger statement/etc in one place so we can
156845:    * resolve them when we get resume packets. We have more than one (and keep
156845:    * them in a stack) because we can pause within client evals.
156845:    */
156845:   _threadPauseEventLoops: null,
169591:   _pushThreadPause: function () {
156845:     if (!this._threadPauseEventLoops) {
156845:       this._threadPauseEventLoops = [];
156845:     }
156845:     const eventLoop = this._nestedEventLoops.push();
156845:     this._threadPauseEventLoops.push(eventLoop);
156845:     eventLoop.enter();
156845:   },
169591:   _popThreadPause: function () {
156845:     const eventLoop = this._threadPauseEventLoops.pop();
156845:     dbg_assert(eventLoop, "Should have an event loop.");
156845:     eventLoop.resolve();
156845:   },
156845: 
174805:   /**
174805:    * Remove all debuggees and clear out the thread's sources.
174805:    */
169591:   clearDebuggees: function () {
114628:     if (this.dbg) {
120760:       this.dbg.removeAllDebuggees();
109230:     }
140693:     this._sources = null;
109230:   },
109230: 
 89580:   /**
 95951:    * Add a debuggee global to the Debugger object.
152472:    *
152472:    * @returns the Debugger.Object that corresponds to the global.
 89580:    */
169591:   addDebuggee: function (aGlobal) {
152472:     let globalDebugObject;
120758:     try {
152472:       globalDebugObject = this.dbg.addDebuggee(aGlobal);
120758:     } catch (e) {
120758:       // Ignore attempts to add the debugger's compartment as a debuggee.
120758:       dumpn("Ignoring request to add the debugger's compartment as a debuggee");
120758:     }
152472:     return globalDebugObject;
120758:   },
 89580: 
120758:   /**
120758:    * Initialize the Debugger.
120758:    */
169591:   _initDebugger: function () {
114628:     this.dbg = new Debugger();
114628:     this.dbg.uncaughtExceptionHook = this.uncaughtExceptionHook.bind(this);
114628:     this.dbg.onDebuggerStatement = this.onDebuggerStatement.bind(this);
114628:     this.dbg.onNewScript = this.onNewScript.bind(this);
120758:     this.dbg.onNewGlobalObject = this.globalManager.onNewGlobal.bind(this);
109230:     // Keep the debugger disabled until a client attaches.
109230:     this.dbg.enabled = this._state != "detached";
 89580:   },
 89580: 
 89580:   /**
 89580:    * Remove a debuggee global from the JSInspector.
 89580:    */
169591:   removeDebugee: function (aGlobal) {
 89580:     try {
 89580:       this.dbg.removeDebuggee(aGlobal);
 89580:     } catch(ex) {
 89580:       // XXX: This debuggee has code currently executing on the stack,
 89580:       // we need to save this for later.
 89580:     }
 89580:   },
 89580: 
120758:   /**
120758:    * Add the provided window and all windows in its frame tree as debuggees.
152472:    *
152472:    * @returns the Debugger.Object that corresponds to the window.
120758:    */
169591:   _addDebuggees: function (aWindow) {
152472:     let globalDebugObject = this.addDebuggee(aWindow);
120758:     let frames = aWindow.frames;
120758:     if (frames) {
120758:       for (let i = 0; i < frames.length; i++) {
120758:         this._addDebuggees(frames[i]);
120758:       }
120758:     }
152472:     return globalDebugObject;
120758:   },
120758: 
120758:   /**
120758:    * An object that will be used by ThreadActors to tailor their behavior
120758:    * depending on the debugging context being required (chrome or content).
120758:    */
120758:   globalManager: {
169591:     findGlobals: function () {
152472:       this.globalDebugObject = this._addDebuggees(this.global);
120758:     },
120758: 
120758:     /**
182866:      * A function that the engine calls when a new global object has been
182866:      * created.
120758:      *
120758:      * @param aGlobal Debugger.Object
120758:      *        The new global object that was created.
120758:      */
169591:     onNewGlobal: function (aGlobal) {
120758:       // Content debugging only cares about new globals in the contant window,
120758:       // like iframe children.
182866:       if (aGlobal.hostAnnotations &&
120758:           aGlobal.hostAnnotations.type == "document" &&
182866:           aGlobal.hostAnnotations.element === this.global) {
120758:         this.addDebuggee(aGlobal);
120758:         // Notify the client.
120758:         this.conn.send({
120758:           from: this.actorID,
120758:           type: "newGlobal",
120758:           // TODO: after bug 801084 lands see if we need to JSONify this.
120758:           hostAnnotations: aGlobal.hostAnnotations
120758:         });
120758:       }
139903:     }
120758:   },
120758: 
169591:   disconnect: function () {
142187:     dumpn("in ThreadActor.prototype.disconnect");
 90400:     if (this._state == "paused") {
 90400:       this.onResume();
 90400:     }
 90400: 
109230:     this.clearDebuggees();
174805:     this.conn.removeActorPool(this._threadLifetimePool);
174805:     this._threadLifetimePool = null;
109230: 
164286:     if (this._prettyPrintWorker) {
164286:       this._prettyPrintWorker.removeEventListener(
164286:         "error", this._onPrettyPrintError, false);
164286:       this._prettyPrintWorker.removeEventListener(
164286:         "message", this._onPrettyPrintMsg, false);
164286:       this._prettyPrintWorker.terminate();
164286:       this._prettyPrintWorker = null;
164286:     }
164286: 
114628:     if (!this.dbg) {
109230:       return;
109230:     }
114628:     this.dbg.enabled = false;
114628:     this.dbg = null;
 89580:   },
 89580: 
 89580:   /**
 89580:    * Disconnect the debugger and put the actor in the exited state.
 89580:    */
169591:   exit: function () {
 89580:     this.disconnect();
181919:     this._state = "exited";
 89580:   },
 89580: 
 89580:   // Request handlers
169591:   onAttach: function (aRequest) {
 89580:     if (this.state === "exited") {
 89580:       return { type: "exited" };
 89580:     }
 89580: 
 89580:     if (this.state !== "detached") {
181919:       return { error: "wrongState",
181919:                message: "Current state is " + this.state };
 89580:     }
 89580: 
 89580:     this._state = "attached";
 89580: 
140693:     update(this._options, aRequest.options || {});
140693: 
176551:     // Initialize an event loop stack. This can't be done in the constructor,
176551:     // because this.conn is not yet initialized by the actor pool at that time.
176551:     this._nestedEventLoops = new EventLoopStack({
176551:       inspector: DebuggerServer.xpcInspector,
176551:       hooks: this._hooks,
176551:       connection: this.conn,
176551:       thread: this
176551:     });
176551: 
120758:     if (!this.dbg) {
120758:       this._initDebugger();
120758:     }
120758:     this.findGlobals();
 89580:     this.dbg.enabled = true;
 89580:     try {
 89580:       // Put ourselves in the paused state.
 89580:       let packet = this._paused();
 89580:       if (!packet) {
 89580:         return { error: "notAttached" };
 89580:       }
 89580:       packet.why = { type: "attached" };
 89580: 
148149:       this._restoreBreakpoints();
148149: 
 89580:       // Send the response to the attach request now (rather than
 89580:       // returning it), because we're going to start a nested event loop
 89580:       // here.
 89580:       this.conn.send(packet);
 89580: 
 89580:       // Start a nested event loop.
156845:       this._pushThreadPause();
140071: 
 89580:       // We already sent a response to this request, don't send one
 89580:       // now.
 89580:       return null;
 89580:     } catch (e) {
140693:       reportError(e);
 89580:       return { error: "notAttached", message: e.toString() };
 89580:     }
 89580:   },
 89580: 
169591:   onDetach: function (aRequest) {
 89580:     this.disconnect();
181919:     this._state = "detached";
181919: 
142187:     dumpn("ThreadActor.prototype.onDetach: returning 'detached' packet");
140693:     return {
140693:       type: "detached"
140693:     };
 89580:   },
 89580: 
169591:   onReconfigure: function (aRequest) {
140881:     if (this.state == "exited") {
140881:       return { error: "wrongState" };
140881:     }
140881: 
140881:     update(this._options, aRequest.options || {});
140881:     // Clear existing sources, so they can be recreated on next access.
140881:     this._sources = null;
140881: 
140881:     return {};
140881:   },
140881: 
 93468:   /**
 93468:    * Pause the debuggee, by entering a nested event loop, and return a 'paused'
 93468:    * packet to the client.
 93468:    *
 93468:    * @param Debugger.Frame aFrame
 93468:    *        The newest debuggee frame in the stack.
 93468:    * @param object aReason
 93468:    *        An object with a 'type' property containing the reason for the pause.
140693:    * @param function onPacket
140693:    *        Hook to modify the packet before it is sent. Feel free to return a
140693:    *        promise.
 93468:    */
169591:   _pauseAndRespond: function (aFrame, aReason, onPacket=function (k) { return k; }) {
 93468:     try {
 93468:       let packet = this._paused(aFrame);
 93468:       if (!packet) {
 93468:         return undefined;
 93468:       }
 93468:       packet.why = aReason;
153128: 
157986:       this.sources.getOriginalLocation(packet.frame.where).then(aOrigPosition => {
153128:         packet.frame.where = aOrigPosition;
153128:         resolve(onPacket(packet))
153128:           .then(null, error => {
153128:             reportError(error);
153128:             return {
153128:               error: "unknownError",
153128:               message: error.message + "\n" + error.stack
153128:             };
153128:           })
156845:           .then(packet => {
157976:             this.conn.send(packet);
153128:           });
156845:       });
156845: 
156845:       this._pushThreadPause();
 93468:     } catch(e) {
150655:       reportError(e, "Got an exception during TA__pauseAndRespond: ");
156845:     }
156845: 
 93468:     return undefined;
 93468:   },
 93468: 
 93468:   /**
160147:    * Handle resume requests that include a forceCompletion request.
160147:    *
160147:    * @param Object aRequest
160147:    *        The request packet received over the RDP.
160147:    * @returns A response packet.
 93468:    */
169591:   _forceCompletion: function (aRequest) {
 93468:     // TODO: remove this when Debugger.Frame.prototype.pop is implemented in
 93468:     // bug 736733.
160147:     return {
160147:       error: "notImplemented",
160147:       message: "forced completion is not yet implemented."
147124:     };
160147:   },
160147: 
169591:   _makeOnEnterFrame: function ({ pauseAndRespond }) {
160147:     return aFrame => {
159727:       const generatedLocation = getFrameLocation(aFrame);
159727:       let { url } = this.synchronize(this.sources.getOriginalLocation(
159727:         generatedLocation));
156845: 
156845:       return this.sources.isBlackBoxed(url)
156845:         ? undefined
156845:         : pauseAndRespond(aFrame);
 93468:     };
160147:   },
160147: 
169591:   _makeOnPop: function ({ thread, pauseAndRespond, createValueGrip }) {
160147:     return function (aCompletion) {
 93468:       // onPop is called with 'this' set to the current frame.
156845: 
159727:       const generatedLocation = getFrameLocation(this);
160147:       const { url } = thread.synchronize(thread.sources.getOriginalLocation(
159727:         generatedLocation));
156845: 
156845:       if (thread.sources.isBlackBoxed(url)) {
147124:         return undefined;
147124:       }
147124: 
 93468:       // Note that we're popping this frame; we need to watch for
 93468:       // subsequent step events on its caller.
 93468:       this.reportedPop = true;
 93468: 
153128:       return pauseAndRespond(this, aPacket => {
147128:         aPacket.why.frameFinished = {};
147128:         if (!aCompletion) {
147128:           aPacket.why.frameFinished.terminated = true;
147128:         } else if (aCompletion.hasOwnProperty("return")) {
147128:           aPacket.why.frameFinished.return = createValueGrip(aCompletion.return);
147128:         } else if (aCompletion.hasOwnProperty("yield")) {
147128:           aPacket.why.frameFinished.return = createValueGrip(aCompletion.yield);
147128:         } else {
147128:           aPacket.why.frameFinished.throw = createValueGrip(aCompletion.throw);
147128:         }
147128:         return aPacket;
147128:       });
147124:     };
160147:   },
160147: 
169591:   _makeOnStep: function ({ thread, pauseAndRespond, startFrame,
160147:                            startLocation }) {
160147:     return function () {
 93468:       // onStep is called with 'this' set to the current frame.
 93468: 
159727:       const generatedLocation = getFrameLocation(this);
160147:       const newLocation = thread.synchronize(thread.sources.getOriginalLocation(
160147:         generatedLocation));
160147: 
160147:       // Cases when we should pause because we have executed enough to consider
160147:       // a "step" to have occured:
159726:       //
159726:       // 1.1. We change frames.
159726:       // 1.2. We change URLs (can happen without changing frames thanks to
159726:       //      source mapping).
159726:       // 1.3. We change lines.
159726:       //
159726:       // Cases when we should always continue execution, even if one of the
159726:       // above cases is true:
159726:       //
159726:       // 2.1. We are in a source mapped region, but inside a null mapping
159726:       //      (doesn't correlate to any region of original source)
159726:       // 2.2. The source we are in is black boxed.
159726: 
159726:       // Cases 2.1 and 2.2
159726:       if (newLocation.url == null
159726:           || thread.sources.isBlackBoxed(newLocation.url)) {
147124:         return undefined;
147124:       }
147124: 
159726:       // Cases 1.1, 1.2 and 1.3
159726:       if (this !== startFrame
159726:           || startLocation.url !== newLocation.url
159726:           || startLocation.line !== newLocation.line) {
147124:         return pauseAndRespond(this);
 93468:       }
 93468: 
159726:       // Otherwise, let execution continue (we haven't executed enough code to
159726:       // consider this a "step" yet).
 93468:       return undefined;
147124:     };
160147:   },
160147: 
160147:   /**
160147:    * Define the JS hook functions for stepping.
160147:    */
169591:   _makeSteppingHooks: function (aStartLocation) {
160147:     // Bind these methods and state because some of the hooks are called
160147:     // with 'this' set to the current frame. Rather than repeating the
160147:     // binding in each _makeOnX method, just do it once here and pass it
160147:     // in to each function.
160147:     const steppingHookState = {
160147:       pauseAndRespond: (aFrame, onPacket=(k)=>k) => {
160147:         this._pauseAndRespond(aFrame, { type: "resumeLimit" }, onPacket);
160147:       },
160147:       createValueGrip: this.createValueGrip.bind(this),
160147:       thread: this,
160147:       startFrame: this.youngestFrame,
160147:       startLocation: aStartLocation
160147:     };
160147: 
160147:     return {
160147:       onEnterFrame: this._makeOnEnterFrame(steppingHookState),
160147:       onPop: this._makeOnPop(steppingHookState),
160147:       onStep: this._makeOnStep(steppingHookState)
160147:     };
160147:   },
160147: 
160147:   /**
160147:    * Handle attaching the various stepping hooks we need to attach when we
160147:    * receive a resume request with a resumeLimit property.
160147:    *
160147:    * @param Object aRequest
160147:    *        The request packet received over the RDP.
160147:    * @returns A promise that resolves to true once the hooks are attached, or is
160147:    *          rejected with an error packet.
160147:    */
169591:   _handleResumeLimit: function (aRequest) {
113816:     let steppingType = aRequest.resumeLimit.type;
113816:     if (["step", "next", "finish"].indexOf(steppingType) == -1) {
160147:       return reject({ error: "badParameterType",
160147:                       message: "Unknown resumeLimit type" });
160147:     }
160147: 
160147:     const generatedLocation = getFrameLocation(this.youngestFrame);
160147:     return this.sources.getOriginalLocation(generatedLocation)
160147:       .then(originalLocation => {
160147:         const { onEnterFrame, onPop, onStep } = this._makeSteppingHooks(originalLocation);
160147: 
113816:         // Make sure there is still a frame on the stack if we are to continue
113816:         // stepping.
160147:         let stepFrame = this._getNextStepFrame(this.youngestFrame);
113816:         if (stepFrame) {
113816:           switch (steppingType) {
 93468:             case "step":
 93468:               this.dbg.onEnterFrame = onEnterFrame;
 93468:               // Fall through.
 93468:             case "next":
160632:               if (stepFrame.script) {
 93468:                   stepFrame.onStep = onStep;
160632:               }
 93468:               stepFrame.onPop = onPop;
 93468:               break;
 93468:             case "finish":
 93468:               stepFrame.onPop = onPop;
 93468:           }
 93468:         }
160147: 
159726:         return true;
159726:       });
160147:   },
160147: 
160147:   /**
160147:    * Clear the onStep and onPop hooks from the given frame and all of the frames
160147:    * below it.
160147:    *
160147:    * @param Debugger.Frame aFrame
160147:    *        The frame we want to clear the stepping hooks from.
160147:    */
169591:   _clearSteppingHooks: function (aFrame) {
160147:     while (aFrame) {
160147:       aFrame.onStep = undefined;
160147:       aFrame.onPop = undefined;
160147:       aFrame = aFrame.older;
160147:     }
160147:   },
160147: 
160147:   /**
160147:    * Listen to the debuggee's DOM events if we received a request to do so.
160147:    *
160147:    * @param Object aRequest
160147:    *        The resume request packet received over the RDP.
160147:    */
169591:   _maybeListenToEvents: function (aRequest) {
152472:     // Break-on-DOMEvents is only supported in content debugging.
152472:     let events = aRequest.pauseOnDOMEvents;
152472:     if (this.global && events &&
152472:         (events == "*" ||
152472:         (Array.isArray(events) && events.length))) {
152472:       this._pauseOnDOMEvents = events;
152472:       let els = Cc["@mozilla.org/eventlistenerservice;1"]
152472:                 .getService(Ci.nsIEventListenerService);
152472:       els.addListenerForAllEvents(this.global, this._allEventsListener, true);
100191:     }
160147:   },
160147: 
160147:   /**
160147:    * Handle a protocol request to resume execution of the debuggee.
160147:    */
169591:   onResume: function (aRequest) {
160147:     if (this._state !== "paused") {
160147:       return {
160147:         error: "wrongState",
160147:         message: "Can't resume when debuggee isn't paused. Current state is '"
160147:           + this._state + "'"
160147:       };
160147:     }
160147: 
160147:     // In case of multiple nested event loops (due to multiple debuggers open in
160147:     // different tabs or multiple debugger clients connected to the same tab)
160147:     // only allow resumption in a LIFO order.
162535:     if (this._nestedEventLoops.size && this._nestedEventLoops.lastPausedUrl
176551:         && (this._nestedEventLoops.lastPausedUrl !== this._hooks.url
176551:         || this._nestedEventLoops.lastConnection !== this.conn)) {
160147:       return {
160147:         error: "wrongOrder",
160147:         message: "trying to resume in the wrong order.",
160147:         lastPausedUrl: this._nestedEventLoops.lastPausedUrl
160147:       };
160147:     }
160147: 
160147:     if (aRequest && aRequest.forceCompletion) {
160147:       return this._forceCompletion(aRequest);
160147:     }
160147: 
160147:     let resumeLimitHandled;
160147:     if (aRequest && aRequest.resumeLimit) {
160147:       resumeLimitHandled = this._handleResumeLimit(aRequest)
160147:     } else {
160147:       this._clearSteppingHooks(this.youngestFrame);
160147:       resumeLimitHandled = resolve(true);
160147:     }
160147: 
160147:     return resumeLimitHandled.then(() => {
160147:       if (aRequest) {
160147:         this._options.pauseOnExceptions = aRequest.pauseOnExceptions;
160147:         this._options.ignoreCaughtExceptions = aRequest.ignoreCaughtExceptions;
160147:         this.maybePauseOnExceptions();
160147:         this._maybeListenToEvents(aRequest);
152472:       }
152472: 
 89580:       let packet = this._resumed();
156845:       this._popThreadPause();
 89580:       return packet;
159726:     }, error => {
159726:       return error instanceof Error
159726:         ? { error: "unknownError",
159726:             message: safeErrorString(error) }
159726:         // It is a known error, and the promise was rejected with an error
159726:         // packet.
159726:         : error;
159726:     });
 89580:   },
 89580: 
 93468:   /**
156845:    * Spin up a nested event loop so we can synchronously resolve a promise.
156845:    *
156845:    * @param aPromise
156845:    *        The promise we want to resolve.
156845:    * @returns The promise's resolution.
156845:    */
156845:   synchronize: function(aPromise) {
156845:     let needNest = true;
156845:     let eventLoop;
156845:     let returnVal;
156845: 
156845:     aPromise
156845:       .then((aResolvedVal) => {
156845:         needNest = false;
156845:         returnVal = aResolvedVal;
156845:       })
156845:       .then(null, (aError) => {
156845:         reportError(aError, "Error inside synchronize:");
156845:       })
156845:       .then(() => {
156845:         if (eventLoop) {
156845:           eventLoop.resolve();
156845:         }
156845:       });
156845: 
156845:     if (needNest) {
156845:       eventLoop = this._nestedEventLoops.push();
156845:       eventLoop.enter();
156845:     }
156845: 
156845:     return returnVal;
156845:   },
156845: 
156845:   /**
150962:    * Set the debugging hook to pause on exceptions if configured to do so.
150962:    */
150962:   maybePauseOnExceptions: function() {
150962:     if (this._options.pauseOnExceptions) {
150962:       this.dbg.onExceptionUnwind = this.onExceptionUnwind.bind(this);
150962:     }
150962:   },
150962: 
150962:   /**
152472:    * A listener that gets called for every event fired on the page, when a list
152472:    * of interesting events was provided with the pauseOnDOMEvents property. It
152472:    * is used to set server-managed breakpoints on any existing event listeners
152472:    * for those events.
152472:    *
152472:    * @param Event event
152472:    *        The event that was fired.
152472:    */
152472:   _allEventsListener: function(event) {
152472:     if (this._pauseOnDOMEvents == "*" ||
152472:         this._pauseOnDOMEvents.indexOf(event.type) != -1) {
152472:       for (let listener of this._getAllEventListeners(event.target)) {
152472:         if (event.type == listener.type || this._pauseOnDOMEvents == "*") {
152472:           this._breakOnEnter(listener.script);
152472:         }
152472:       }
152472:     }
152472:   },
152472: 
152472:   /**
152472:    * Return an array containing all the event listeners attached to the
152472:    * specified event target and its ancestors in the event target chain.
152472:    *
152472:    * @param EventTarget eventTarget
152472:    *        The target the event was dispatched on.
152472:    * @returns Array
152472:    */
152472:   _getAllEventListeners: function(eventTarget) {
152472:     let els = Cc["@mozilla.org/eventlistenerservice;1"]
152472:                 .getService(Ci.nsIEventListenerService);
152472: 
152472:     let targets = els.getEventTargetChainFor(eventTarget);
152472:     let listeners = [];
152472: 
152472:     for (let target of targets) {
152472:       let handlers = els.getListenerInfoFor(target);
152472:       for (let handler of handlers) {
152472:         // Null is returned for all-events handlers, and native event listeners
152472:         // don't provide any listenerObject, which makes them not that useful to
152472:         // a JS debugger.
152472:         if (!handler || !handler.listenerObject || !handler.type)
152472:           continue;
152472:         // Create a listener-like object suitable for our purposes.
152472:         let l = Object.create(null);
152472:         l.type = handler.type;
152472:         let listener = handler.listenerObject;
152472:         l.script = this.globalDebugObject.makeDebuggeeValue(listener).script;
152472:         // Chrome listeners won't be converted to debuggee values, since their
152472:         // compartment is not added as a debuggee.
152472:         if (!l.script)
152472:           continue;
152472:         listeners.push(l);
152472:       }
152472:     }
152472:     return listeners;
152472:   },
152472: 
152472:   /**
152472:    * Set a breakpoint on the first bytecode offset in the provided script.
152472:    */
152472:   _breakOnEnter: function(script) {
152472:     let offsets = script.getAllOffsets();
152472:     for (let line = 0, n = offsets.length; line < n; line++) {
152472:       if (offsets[line]) {
152472:         let location = { url: script.url, line: line };
152472:         let resp = this._createAndStoreBreakpoint(location);
152472:         dbg_assert(!resp.actualLocation, "No actualLocation should be returned");
152472:         if (resp.error) {
152472:           reportError(new Error("Unable to set breakpoint on event listener"));
152472:           return;
152472:         }
153128:         let bp = this.breakpointStore.getBreakpoint(location);
153128:         let bpActor = bp.actor;
153128:         dbg_assert(bp, "Breakpoint must exist");
152472:         dbg_assert(bpActor, "Breakpoint actor must be created");
152472:         this._hiddenBreakpoints.set(bpActor.actorID, bpActor);
152472:         break;
152472:       }
152472:     }
152472:   },
152472: 
152472:   /**
 93468:    * Helper method that returns the next frame when stepping.
 93468:    */
169591:   _getNextStepFrame: function (aFrame) {
 93468:     let stepFrame = aFrame.reportedPop ? aFrame.older : aFrame;
 93468:     if (!stepFrame || !stepFrame.script) {
 93468:       stepFrame = null;
 93468:     }
 93468:     return stepFrame;
 93468:   },
 93468: 
169591:   onClientEvaluate: function (aRequest) {
 89580:     if (this.state !== "paused") {
 92194:       return { error: "wrongState",
 89580:                message: "Debuggee must be paused to evaluate code." };
157976:     }
 89580: 
 89580:     let frame = this._requestFrame(aRequest.frame);
 89580:     if (!frame) {
 92194:       return { error: "unknownFrame",
 89580:                message: "Evaluation frame not found" };
 89580:     }
 89580: 
 92194:     if (!frame.environment) {
 92194:       return { error: "notDebuggee",
 92194:                message: "cannot access the environment of this frame." };
157976:     }
 89580: 
147124:     let youngest = this.youngestFrame;
 89580: 
 89580:     // Put ourselves back in the running state and inform the client.
 89580:     let resumedPacket = this._resumed();
 89580:     this.conn.send(resumedPacket);
 89580: 
 89580:     // Run the expression.
 89580:     // XXX: test syntax errors
 89580:     let completion = frame.eval(aRequest.expression);
 89580: 
 89580:     // Put ourselves back in the pause state.
 89580:     let packet = this._paused(youngest);
 92194:     packet.why = { type: "clientEvaluated",
 92194:                    frameFinished: this.createProtocolCompletionValue(completion) };
 89580: 
 89580:     // Return back to our previous pause's event loop.
 89580:     return packet;
 89580:   },
 89580: 
169591:   onFrames: function (aRequest) {
 89580:     if (this.state !== "paused") {
 89580:       return { error: "wrongState",
 89580:                message: "Stack frames are only available while the debuggee is paused."};
 89580:     }
 89580: 
 89580:     let start = aRequest.start ? aRequest.start : 0;
 89580:     let count = aRequest.count;
 89580: 
 89580:     // Find the starting frame...
147124:     let frame = this.youngestFrame;
 89580:     let i = 0;
 89580:     while (frame && (i < start)) {
 89580:       frame = frame.older;
 89580:       i++;
 89580:     }
 89580: 
 89580:     // Return request.count frames, or all remaining
 89580:     // frames if count is not defined.
 89580:     let frames = [];
140693:     let promises = [];
140693:     for (; frame && (!count || i < (start + count)); i++, frame=frame.older) {
 92194:       let form = this._createFrameActor(frame).form();
 92194:       form.depth = i;
 92194:       frames.push(form);
140693: 
157986:       let promise = this.sources.getOriginalLocation(form.where)
154416:         .then((aOrigLocation) => {
140693:           form.where = aOrigLocation;
160799:           let source = this.sources.source({ url: form.where.url });
154416:           if (source) {
154416:             form.source = source.form();
154416:           }
140693:         });
140693:       promises.push(promise);
 89580:     }
 89580: 
141016:     return all(promises).then(function () {
 89580:       return { frames: frames };
140693:     });
 89580:   },
 89580: 
169591:   onReleaseMany: function (aRequest) {
 92194:     if (!aRequest.actors) {
 92194:       return { error: "missingParameter",
 92194:                message: "no actors were specified" };
 92194:     }
 92194: 
118772:     let res;
 89580:     for each (let actorID in aRequest.actors) {
 89580:       let actor = this.threadLifetimePool.get(actorID);
118772:       if (!actor) {
118772:         if (!res) {
118772:           res = { error: "notReleasable",
118772:                   message: "Only thread-lifetime actors can be released." };
 89580:         }
118772:         continue;
118772:       }
118772:       actor.onRelease();
118772:     }
118772:     return res ? res : {};
 89580:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to set a breakpoint.
 89580:    */
169591:   onSetBreakpoint: function (aRequest) {
 89580:     if (this.state !== "paused") {
 89580:       return { error: "wrongState",
 89580:                message: "Breakpoints can only be set while the debuggee is paused."};
 89580:     }
 89580: 
140693:     let { url: originalSource,
140693:           line: originalLine,
140693:           column: originalColumn } = aRequest.location;
140693: 
157986:     let locationPromise = this.sources.getGeneratedLocation(aRequest.location);
153128:     return locationPromise.then(({url, line, column}) => {
153128:       if (line == null ||
140694:           line < 0 ||
153128:           this.dbg.findScripts({ url: url }).length == 0) {
 89863:         return { error: "noScript" };
 89580:       }
100190: 
153128:       let response = this._createAndStoreBreakpoint({
153128:         url: url,
153128:         line: line,
153128:         column: column
153128:       });
140693:       // If the original location of our generated location is different from
140693:       // the original location we attempted to set the breakpoint on, we will
140693:       // need to know so that we can set actualLocation on the response.
157986:       let originalLocation = this.sources.getOriginalLocation({
157986:         url: url,
157986:         line: line,
157986:         column: column
157986:       });
140693: 
141016:       return all([response, originalLocation])
140693:         .then(([aResponse, {url, line}]) => {
140693:           if (aResponse.actualLocation) {
157986:             let actualOrigLocation = this.sources.getOriginalLocation(aResponse.actualLocation);
157986:             return actualOrigLocation.then(({ url, line, column }) => {
153128:               if (url !== originalSource
153128:                   || line !== originalLine
153128:                   || column !== originalColumn) {
153128:                 aResponse.actualLocation = {
153128:                   url: url,
153128:                   line: line,
153128:                   column: column
153128:                 };
153128:               }
153128:               return aResponse;
153128:             });
153128:           }
153128: 
140693:           if (url !== originalSource || line !== originalLine) {
140693:             aResponse.actualLocation = { url: url, line: line };
140693:           }
153128: 
140693:           return aResponse;
140693:         });
140693:     });
100190:   },
100190: 
100190:   /**
153128:    * Create a breakpoint at the specified location and store it in the
153128:    * cache. Takes ownership of `aLocation`.
153128:    *
153128:    * @param Object aLocation
153128:    *        An object of the form { url, line[, column] }
152472:    */
152472:   _createAndStoreBreakpoint: function (aLocation) {
153128:     // Add the breakpoint to the store for later reuse, in case it belongs to a
153128:     // script that hasn't appeared yet.
153128:     this.breakpointStore.addBreakpoint(aLocation);
152472:     return this._setBreakpoint(aLocation);
152472:   },
152472: 
152472:   /**
101842:    * Set a breakpoint using the jsdbg2 API. If the line on which the breakpoint
101842:    * is being set contains no code, then the breakpoint will slide down to the
101842:    * next line that has runnable code. In this case the server breakpoint cache
101842:    * will be updated, so callers that iterate over the breakpoint cache should
101842:    * take that into account.
100190:    *
100190:    * @param object aLocation
153128:    *        The location of the breakpoint (in the generated source, if source
153128:    *        mapping).
100190:    */
169591:   _setBreakpoint: function (aLocation) {
136344:     let actor;
153128:     let storedBp = this.breakpointStore.getBreakpoint(aLocation);
153128:     if (storedBp.actor) {
153128:       actor = storedBp.actor;
136344:     } else {
153128:       storedBp.actor = actor = new BreakpointActor(this, {
136344:         url: aLocation.url,
153128:         line: aLocation.line,
153128:         column: aLocation.column
136344:       });
174909:       this.threadLifetimePool.addActor(actor);
 89580:     }
 89863: 
141348:     // Find all scripts matching the given location
136344:     let scripts = this.dbg.findScripts(aLocation);
136344:     if (scripts.length == 0) {
136344:       return {
136344:         error: "noScript",
136344:         actor: actor.actorID
136344:       };
 89580:     }
 89863: 
141348:    /**
153128:     * For each script, if the given line has at least one entry point, set a
153128:     * breakpoint on the bytecode offets for each of them.
141348:     */
153128: 
153128:     // Debugger.Script -> array of offset mappings
153128:     let scriptsAndOffsetMappings = new Map();
153128: 
136344:     for (let script of scripts) {
153128:       this._findClosestOffsetMappings(aLocation,
153128:                                       script,
153128:                                       scriptsAndOffsetMappings);
153128:     }
153128: 
153128:     if (scriptsAndOffsetMappings.size > 0) {
153128:       for (let [script, mappings] of scriptsAndOffsetMappings) {
153128:         for (let offsetMapping of mappings) {
153128:           script.setBreakpoint(offsetMapping.offset, actor);
136344:         }
136344:         actor.addScript(script, this);
153128:       }
153128: 
136344:       return {
136344:         actor: actor.actorID
136344:       };
100190:     }
 89863: 
141348:    /**
141348:     * If we get here, no breakpoint was set. This is because the given line
141348:     * has no entry points, for example because it is empty. As a fallback
141348:     * strategy, we try to set the breakpoint on the smallest line greater
141348:     * than or equal to the given line that as at least one entry point.
141348:     */
141348: 
141348:     // Find all innermost scripts matching the given location
136344:     let scripts = this.dbg.findScripts({
136344:       url: aLocation.url,
136344:       line: aLocation.line,
136344:       innermost: true
136344:     });
 89863: 
141348:     /**
141348:      * For each innermost script, look for the smallest line greater than or
141348:      * equal to the given line that has one or more entry points. If found, set
141348:      * a breakpoint on the bytecode offset for each of its entry points.
141348:      */
 89863:     let actualLocation;
136344:     let found = false;
136344:     for (let script of scripts) {
136344:       let offsets = script.getAllOffsets();
136344:       for (let line = aLocation.line; line < offsets.length; ++line) {
136344:         if (offsets[line]) {
136344:           for (let offset of offsets[line]) {
136344:             script.setBreakpoint(offset, actor);
 89863:           }
136344:           actor.addScript(script, this);
136344:           if (!actualLocation) {
101842:             actualLocation = {
101842:               url: aLocation.url,
101842:               line: line,
141348:               column: 0
101842:             };
124065:           }
136344:           found = true;
 89863:           break;
 89863:         }
 89863:       }
 89863:     }
136344:     if (found) {
153937:       let existingBp = this.breakpointStore.hasBreakpoint(actualLocation);
153937: 
153128:       if (existingBp && existingBp.actor) {
141348:         /**
141348:          * We already have a breakpoint actor for the actual location, so
141348:          * actor we created earlier is now redundant. Delete it, update the
141348:          * breakpoint store, and return the actor for the actual location.
141348:          */
136344:         actor.onDelete();
153128:         this.breakpointStore.removeBreakpoint(aLocation);
136344:         return {
153128:           actor: existingBp.actor.actorID,
136344:           actualLocation: actualLocation
136344:         };
136344:       } else {
141348:         /**
141348:          * We don't have a breakpoint actor for the actual location yet.
141348:          * Instead or creating a new actor, reuse the actor we created earlier,
141348:          * and update the breakpoint store.
141348:          */
136344:         actor.location = actualLocation;
153128:         this.breakpointStore.addBreakpoint({
153128:           actor: actor,
153128:           url: actualLocation.url,
153128:           line: actualLocation.line,
153128:           column: actualLocation.column
153128:         });
153128:         this.breakpointStore.removeBreakpoint(aLocation);
136344:         return {
136344:           actor: actor.actorID,
136344:           actualLocation: actualLocation
136344:         };
136344:       }
 89863:     }
 89863: 
141348:     /**
141348:      * If we get here, no line matching the given line was found, so just
153128:      * fail epically.
141348:      */
136344:     return {
136344:       error: "noCodeAtLineColumn",
136344:       actor: actor.actorID
136344:     };
 89863:   },
 89863: 
 89863:   /**
153128:    * Find all of the offset mappings associated with `aScript` that are closest
153128:    * to `aTargetLocation`. If new offset mappings are found that are closer to
153128:    * `aTargetOffset` than the existing offset mappings inside
153128:    * `aScriptsAndOffsetMappings`, we empty that map and only consider the
153128:    * closest offset mappings. If there is no column in `aTargetLocation`, we add
153128:    * all offset mappings that are on the given line.
153128:    *
153128:    * @param Object aTargetLocation
153128:    *        An object of the form { url, line[, column] }.
153128:    * @param Debugger.Script aScript
153128:    *        The script in which we are searching for offsets.
153128:    * @param Map aScriptsAndOffsetMappings
153128:    *        A Map object which maps Debugger.Script instances to arrays of
153128:    *        offset mappings. This is an out param.
153128:    */
169591:   _findClosestOffsetMappings: function (aTargetLocation,
153128:                                         aScript,
153128:                                         aScriptsAndOffsetMappings) {
160037:     // If we are given a column, we will try and break only at that location,
160037:     // otherwise we will break anytime we get on that line.
160037: 
160037:     if (aTargetLocation.column == null) {
160037:       let offsetMappings = aScript.getLineOffsets(aTargetLocation.line)
160037:         .map(o => ({
160037:           line: aTargetLocation.line,
160037:           offset: o
160037:         }));
160037:       if (offsetMappings.length) {
160037:         aScriptsAndOffsetMappings.set(aScript, offsetMappings);
160037:       }
160037:       return;
160037:     }
160037: 
153128:     let offsetMappings = aScript.getAllColumnOffsets()
153128:       .filter(({ lineNumber }) => lineNumber === aTargetLocation.line);
153128: 
153128:     // Attempt to find the current closest offset distance from the target
153128:     // location by grabbing any offset mapping in the map by doing one iteration
153128:     // and then breaking (they all have the same distance from the target
153128:     // location).
153128:     let closestDistance = Infinity;
153128:     if (aScriptsAndOffsetMappings.size) {
153128:       for (let mappings of aScriptsAndOffsetMappings.values()) {
153128:         closestDistance = Math.abs(aTargetLocation.column - mappings[0].columnNumber);
153128:         break;
153128:       }
153128:     }
153128: 
153128:     for (let mapping of offsetMappings) {
153128:       let currentDistance = Math.abs(aTargetLocation.column - mapping.columnNumber);
153128: 
153128:       if (currentDistance > closestDistance) {
153128:         continue;
153128:       } else if (currentDistance < closestDistance) {
153128:         closestDistance = currentDistance;
153128:         aScriptsAndOffsetMappings.clear();
153128:         aScriptsAndOffsetMappings.set(aScript, [mapping]);
153128:       } else {
153128:         if (!aScriptsAndOffsetMappings.has(aScript)) {
153128:           aScriptsAndOffsetMappings.set(aScript, []);
153128:         }
153128:         aScriptsAndOffsetMappings.get(aScript).push(mapping);
153128:       }
153128:     }
153128:   },
153128: 
153128:   /**
134823:    * Get the script and source lists from the debugger.
134823:    */
169591:   _discoverSources: function () {
148149:     // Only get one script per url.
169251:     const sourcesToScripts = new Map();
148149:     for (let s of this.dbg.findScripts()) {
169251:       if (s.source) {
169251:         sourcesToScripts.set(s.source, s);
169251:       }
169251:     }
169251: 
169251:     return all([this.sources.sourcesForScript(script)
169251:                 for (script of sourcesToScripts.values())]);
134823:   },
134823: 
169591:   onSources: function (aRequest) {
148149:     return this._discoverSources().then(() => {
134823:       return {
140693:         sources: [s.form() for (s of this.sources.iter())]
134823:       };
140693:     });
 89580:   },
 89580: 
 89580:   /**
142765:    * Disassociate all breakpoint actors from their scripts and clear the
142765:    * breakpoint handlers. This method can be used when the thread actor intends
142765:    * to keep the breakpoint store, but needs to clear any actual breakpoints,
142765:    * e.g. due to a page navigation. This way the breakpoint actors' script
142765:    * caches won't hold on to the Debugger.Script objects leaking memory.
142765:    */
142765:   disableAllBreakpoints: function () {
153128:     for (let bp of this.breakpointStore.findBreakpoints()) {
153128:       if (bp.actor) {
142765:         bp.actor.removeScripts();
142765:       }
142765:     }
142765:   },
142765: 
142765:   /**
 89861:    * Handle a protocol request to pause the debuggee.
 89861:    */
169591:   onInterrupt: function (aRequest) {
 89861:     if (this.state == "exited") {
 89861:       return { type: "exited" };
 89861:     } else if (this.state == "paused") {
 89861:       // TODO: return the actual reason for the existing pause.
 89861:       return { type: "paused", why: { type: "alreadyPaused" } };
 89861:     } else if (this.state != "running") {
 89861:       return { error: "wrongState",
 89861:                message: "Received interrupt request in " + this.state +
 89861:                         " state." };
 89861:     }
 89861: 
 89861:     try {
 89861:       // Put ourselves in the paused state.
 89861:       let packet = this._paused();
 89861:       if (!packet) {
 89861:         return { error: "notInterrupted" };
 89861:       }
 89861:       packet.why = { type: "interrupted" };
 89861: 
 89861:       // Send the response to the interrupt request now (rather than
 89861:       // returning it), because we're going to start a nested event loop
 89861:       // here.
 89861:       this.conn.send(packet);
 89861: 
 89861:       // Start a nested event loop.
156845:       this._pushThreadPause();
 89861: 
 89861:       // We already sent a response to this request, don't send one
 89861:       // now.
 89861:       return null;
 89861:     } catch (e) {
140693:       reportError(e);
 89861:       return { error: "notInterrupted", message: e.toString() };
 89861:     }
 89861:   },
 89861: 
 89861:   /**
152472:    * Handle a protocol request to retrieve all the event listeners on the page.
152472:    */
169591:   onEventListeners: function (aRequest) {
152472:     // This request is only supported in content debugging.
152472:     if (!this.global) {
152472:       return {
152472:         error: "notImplemented",
152472:         message: "eventListeners request is only supported in content debugging"
157976:       };
152472:     }
152472: 
152472:     let els = Cc["@mozilla.org/eventlistenerservice;1"]
152472:                 .getService(Ci.nsIEventListenerService);
152472: 
152472:     let nodes = this.global.document.getElementsByTagName("*");
152472:     nodes = [this.global].concat([].slice.call(nodes));
152472:     let listeners = [];
152472: 
152472:     for (let node of nodes) {
152472:       let handlers = els.getListenerInfoFor(node);
152472: 
152472:       for (let handler of handlers) {
152472:         // Create a form object for serializing the listener via the protocol.
152472:         let listenerForm = Object.create(null);
152472:         let listener = handler.listenerObject;
182783:         // Native event listeners don't provide any listenerObject or type and
182783:         // are not that useful to a JS debugger.
182783:         if (!listener || !handler.type) {
152472:           continue;
152472:         }
152472: 
152472:         // There will be no tagName if the event listener is set on the window.
152472:         let selector = node.tagName ? findCssSelector(node) : "window";
152472:         let nodeDO = this.globalDebugObject.makeDebuggeeValue(node);
152472:         listenerForm.node = {
152472:           selector: selector,
152472:           object: this.createValueGrip(nodeDO)
152472:         };
152472:         listenerForm.type = handler.type;
152472:         listenerForm.capturing = handler.capturing;
152472:         listenerForm.allowsUntrusted = handler.allowsUntrusted;
152472:         listenerForm.inSystemEventGroup = handler.inSystemEventGroup;
152472:         listenerForm.isEventHandler = !!node["on" + listenerForm.type];
152472:         // Get the Debugger.Object for the listener object.
152472:         let listenerDO = this.globalDebugObject.makeDebuggeeValue(listener);
152472:         listenerForm.function = this.createValueGrip(listenerDO);
152472:         listeners.push(listenerForm);
152472:       }
152472:     }
152472:     return { listeners: listeners };
152472:   },
152472: 
152472:   /**
 89580:    * Return the Debug.Frame for a frame mentioned by the protocol.
 89580:    */
169591:   _requestFrame: function (aFrameID) {
 89580:     if (!aFrameID) {
147124:       return this.youngestFrame;
 89580:     }
 89580: 
 89580:     if (this._framePool.has(aFrameID)) {
 89580:       return this._framePool.get(aFrameID).frame;
 89580:     }
 89580: 
 89580:     return undefined;
 89580:   },
 89580: 
169591:   _paused: function (aFrame) {
 92194:     // We don't handle nested pauses correctly.  Don't try - if we're
 89580:     // paused, just continue running whatever code triggered the pause.
 92194:     // We don't want to actually have nested pauses (although we
 89580:     // have nested event loops).  If code runs in the debuggee during
 89580:     // a pause, it should cause the actor to resume (dropping
 89580:     // pause-lifetime actors etc) and then repause when complete.
 89580: 
 89580:     if (this.state === "paused") {
 89580:       return undefined;
 89580:     }
 89580: 
 93468:     // Clear stepping hooks.
 93468:     this.dbg.onEnterFrame = undefined;
100191:     this.dbg.onExceptionUnwind = undefined;
 93468:     if (aFrame) {
 93468:       aFrame.onStep = undefined;
 93468:       aFrame.onPop = undefined;
 93468:     }
152472:     // Clear DOM event breakpoints.
152472:     // XPCShell tests don't use actual DOM windows for globals and cause
152472:     // removeListenerForAllEvents to throw.
152472:     if (this.global && !this.global.toString().contains("Sandbox")) {
152472:       let els = Cc["@mozilla.org/eventlistenerservice;1"]
152472:                 .getService(Ci.nsIEventListenerService);
152472:       els.removeListenerForAllEvents(this.global, this._allEventsListener, true);
152472:       for (let [,bp] of this._hiddenBreakpoints) {
152472:         bp.onDelete();
152472:       }
152472:       this._hiddenBreakpoints.clear();
152472:     }
 93468: 
 89580:     this._state = "paused";
 89580: 
 89580:     // Create the actor pool that will hold the pause actor and its
 89580:     // children.
152472:     dbg_assert(!this._pausePool, "No pause pool should exist yet");
 89580:     this._pausePool = new ActorPool(this.conn);
 89580:     this.conn.addActorPool(this._pausePool);
 89580: 
 89580:     // Give children of the pause pool a quick link back to the
 89580:     // thread...
 89580:     this._pausePool.threadActor = this;
 89580: 
 89580:     // Create the pause actor itself...
152472:     dbg_assert(!this._pauseActor, "No pause actor should exist yet");
 89580:     this._pauseActor = new PauseActor(this._pausePool);
 89580:     this._pausePool.addActor(this._pauseActor);
 89580: 
 89580:     // Update the list of frames.
 89580:     let poppedFrames = this._updateFrames();
 89580: 
 89580:     // Send off the paused packet and spin an event loop.
 89580:     let packet = { from: this.actorID,
 89580:                    type: "paused",
 89580:                    actor: this._pauseActor.actorID };
 89580:     if (aFrame) {
 92194:       packet.frame = this._createFrameActor(aFrame).form();
 89580:     }
140071: 
 89580:     if (poppedFrames) {
 89580:       packet.poppedFrames = poppedFrames;
 89580:     }
 89580: 
 89580:     return packet;
 89580:   },
 89580: 
169591:   _resumed: function () {
 89580:     this._state = "running";
 89580: 
 89580:     // Drop the actors in the pause actor pool.
 89580:     this.conn.removeActorPool(this._pausePool);
 89580: 
 89580:     this._pausePool = null;
 89580:     this._pauseActor = null;
 89580: 
 89580:     return { from: this.actorID, type: "resumed" };
 89580:   },
 89580: 
 89580:   /**
 89580:    * Expire frame actors for frames that have been popped.
 89580:    *
 89580:    * @returns A list of actor IDs whose frames have been popped.
 89580:    */
169591:   _updateFrames: function () {
 89580:     let popped = [];
 89580: 
 89580:     // Create the actor pool that will hold the still-living frames.
 89580:     let framePool = new ActorPool(this.conn);
 89580:     let frameList = [];
 89580: 
 89580:     for each (let frameActor in this._frameActors) {
 89580:       if (frameActor.frame.live) {
 89580:         framePool.addActor(frameActor);
 89580:         frameList.push(frameActor);
 89580:       } else {
 89580:         popped.push(frameActor.actorID);
 89580:       }
 89580:     }
 89580: 
 89580:     // Remove the old frame actor pool, this will expire
 89580:     // any actors that weren't added to the new pool.
 89580:     if (this._framePool) {
 89580:       this.conn.removeActorPool(this._framePool);
 89580:     }
 89580: 
 89580:     this._frameActors = frameList;
 89580:     this._framePool = framePool;
 89580:     this.conn.addActorPool(framePool);
 89580: 
 89580:     return popped;
 89580:   },
 89580: 
169591:   _createFrameActor: function (aFrame) {
 89580:     if (aFrame.actor) {
 89580:       return aFrame.actor;
 89580:     }
 89580: 
 89580:     let actor = new FrameActor(aFrame, this);
 89580:     this._frameActors.push(actor);
 89580:     this._framePool.addActor(actor);
 89580:     aFrame.actor = actor;
 89580: 
 89580:     return actor;
 89580:   },
 89580: 
 89580:   /**
 97625:    * Create and return an environment actor that corresponds to the provided
 97625:    * Debugger.Environment.
 97625:    * @param Debugger.Environment aEnvironment
 97625:    *        The lexical environment we want to extract.
 89580:    * @param object aPool
 89580:    *        The pool where the newly-created actor will be placed.
 97625:    * @return The EnvironmentActor for aEnvironment or undefined for host
 97625:    *         functions or functions scoped to a non-debuggee global.
 89580:    */
 97625:   createEnvironmentActor:
169591:   function (aEnvironment, aPool) {
 97625:     if (!aEnvironment) {
 89580:       return undefined;
 89580:     }
 89580: 
 97625:     if (aEnvironment.actor) {
 97625:       return aEnvironment.actor;
 89580:     }
 89580: 
 97625:     let actor = new EnvironmentActor(aEnvironment, this);
 89580:     aPool.addActor(actor);
 97625:     aEnvironment.actor = actor;
 89580: 
 89580:     return actor;
 89580:   },
 89580: 
 89580:   /**
 89580:    * Create a grip for the given debuggee value.  If the value is an
116020:    * object, will create an actor with the given lifetime.
 89580:    */
169591:   createValueGrip: function (aValue, aPool=false) {
116020:     if (!aPool) {
116020:       aPool = this._pausePool;
116020:     }
156082: 
156082:     switch (typeof aValue) {
156082:       case "boolean":
156082:         return aValue;
156082:       case "string":
156082:         if (this._stringIsLong(aValue)) {
116020:           return this.longStringGrip(aValue, aPool);
110808:         }
 89580:         return aValue;
156082:       case "number":
156082:         if (aValue === Infinity) {
156082:           return { type: "Infinity" };
156082:         } else if (aValue === -Infinity) {
156082:           return { type: "-Infinity" };
156082:         } else if (Number.isNaN(aValue)) {
156082:           return { type: "NaN" };
156082:         } else if (!aValue && 1 / aValue === -Infinity) {
156082:           return { type: "-0" };
156082:         }
156082:         return aValue;
156082:       case "undefined":
156082:         return { type: "undefined" };
156082:       case "object":
 89580:         if (aValue === null) {
 89580:           return { type: "null" };
 89580:         }
116020:         return this.objectGrip(aValue, aPool);
156082:       default:
 89580:         dbg_assert(false, "Failed to provide a grip for: " + aValue);
 89580:         return null;
156082:     }
 89580:   },
 89580: 
 89581:   /**
 92194:    * Return a protocol completion value representing the given
 92194:    * Debugger-provided completion value.
 92194:    */
 92194:   createProtocolCompletionValue:
169591:   function (aCompletion) {
 92194:     let protoValue = {};
 92194:     if ("return" in aCompletion) {
 92194:       protoValue.return = this.createValueGrip(aCompletion.return);
 92194:     } else if ("yield" in aCompletion) {
 92194:       protoValue.return = this.createValueGrip(aCompletion.yield);
 92194:     } else if ("throw" in aCompletion) {
 92194:       protoValue.throw = this.createValueGrip(aCompletion.throw);
 92194:     } else {
 92194:       protoValue.terminated = true;
 92194:     }
 92194:     return protoValue;
 92194:   },
 92194: 
 92194:   /**
 89581:    * Create a grip for the given debuggee object.
 89581:    *
 89581:    * @param aValue Debugger.Object
 89581:    *        The debuggee object value.
 89581:    * @param aPool ActorPool
 89581:    *        The actor pool where the new object actor will be added.
 89581:    */
169591:   objectGrip: function (aValue, aPool) {
 89580:     if (!aPool.objectActors) {
 89580:       aPool.objectActors = new WeakMap();
 89580:     }
 89580: 
 89580:     if (aPool.objectActors.has(aValue)) {
 89580:       return aPool.objectActors.get(aValue).grip();
121780:     } else if (this.threadLifetimePool.objectActors.has(aValue)) {
121780:       return this.threadLifetimePool.objectActors.get(aValue).grip();
 89580:     }
 89580: 
139900:     let actor = new PauseScopedObjectActor(aValue, this);
 89580:     aPool.addActor(actor);
 89580:     aPool.objectActors.set(aValue, actor);
 89580:     return actor.grip();
 89580:   },
 89580: 
 89581:   /**
 89581:    * Create a grip for the given debuggee object with a pause lifetime.
 89581:    *
 89581:    * @param aValue Debugger.Object
 89581:    *        The debuggee object value.
 89581:    */
169591:   pauseObjectGrip: function (aValue) {
 89580:     if (!this._pausePool) {
 89580:       throw "Object grip requested while not paused.";
 89580:     }
 89580: 
 89580:     return this.objectGrip(aValue, this._pausePool);
 89580:   },
 89580: 
 89581:   /**
118772:    * Extend the lifetime of the provided object actor to thread lifetime.
 89581:    *
118772:    * @param aActor object
118772:    *        The object actor.
 89581:    */
169591:   threadObjectGrip: function (aActor) {
118772:     // We want to reuse the existing actor ID, so we just remove it from the
118772:     // current pool's weak map and then let pool.addActor do the rest.
118772:     aActor.registeredPool.objectActors.delete(aActor.obj);
118772:     this.threadLifetimePool.addActor(aActor);
118772:     this.threadLifetimePool.objectActors.set(aActor.obj, aActor);
 89580:   },
 89580: 
110808:   /**
121780:    * Handle a protocol request to promote multiple pause-lifetime grips to
121780:    * thread-lifetime grips.
121780:    *
121780:    * @param aRequest object
121780:    *        The protocol request object.
121780:    */
169591:   onThreadGrips: function (aRequest) {
121780:     if (this.state != "paused") {
121780:       return { error: "wrongState" };
121780:     }
121780: 
121780:     if (!aRequest.actors) {
121780:       return { error: "missingParameter",
121780:                message: "no actors were specified" };
121780:     }
121780: 
121780:     for (let actorID of aRequest.actors) {
121780:       let actor = this._pausePool.get(actorID);
121780:       if (actor) {
121780:         this.threadObjectGrip(actor);
121780:       }
121780:     }
121780:     return {};
121780:   },
121780: 
121780:   /**
110808:    * Create a grip for the given string.
110808:    *
110808:    * @param aString String
110808:    *        The string we are creating a grip for.
116019:    * @param aPool ActorPool
116019:    *        The actor pool where the new actor will be added.
110808:    */
169591:   longStringGrip: function (aString, aPool) {
116019:     if (!aPool.longStringActors) {
116019:       aPool.longStringActors = {};
110808:     }
110808: 
116019:     if (aPool.longStringActors.hasOwnProperty(aString)) {
116019:       return aPool.longStringActors[aString].grip();
110808:     }
110808: 
110808:     let actor = new LongStringActor(aString, this);
116019:     aPool.addActor(actor);
116019:     aPool.longStringActors[aString] = actor;
110808:     return actor.grip();
110808:   },
110808: 
110808:   /**
116019:    * Create a long string grip that is scoped to a pause.
116019:    *
116019:    * @param aString String
116019:    *        The string we are creating a grip for.
116019:    */
169591:   pauseLongStringGrip: function (aString) {
116019:     return this.longStringGrip(aString, this._pausePool);
116019:   },
116019: 
116019:   /**
116019:    * Create a long string grip that is scoped to a thread.
116019:    *
116019:    * @param aString String
116019:    *        The string we are creating a grip for.
116019:    */
169591:   threadLongStringGrip: function (aString) {
116019:     return this.longStringGrip(aString, this._threadLifetimePool);
116019:   },
116019: 
116019:   /**
110808:    * Returns true if the string is long enough to use a LongStringActor instead
110808:    * of passing the value directly over the protocol.
110808:    *
110808:    * @param aString String
110808:    *        The string we are checking the length of.
110808:    */
169591:   _stringIsLong: function (aString) {
110808:     return aString.length >= DebuggerServer.LONG_STRING_LENGTH;
110808:   },
110808: 
 89581:   // JS Debugger API hooks.
 89581: 
 89581:   /**
 89581:    * A function that the engine calls when a call to a debug event hook,
 89581:    * breakpoint handler, watchpoint handler, or similar function throws some
 89581:    * exception.
 89581:    *
 89581:    * @param aException exception
 89581:    *        The exception that was thrown in the debugger code.
 89581:    */
169591:   uncaughtExceptionHook: function (aException) {
147124:     dumpn("Got an exception: " + aException.message + "\n" + aException.stack);
 89580:   },
 89580: 
 89581:   /**
 89581:    * A function that the engine calls when a debugger statement has been
 89581:    * executed in the specified frame.
 89581:    *
 89581:    * @param aFrame Debugger.Frame
 89581:    *        The stack frame that contained the debugger statement.
 89581:    */
169591:   onDebuggerStatement: function (aFrame) {
152471:     // Don't pause if we are currently stepping (in or over) or the frame is
152471:     // black-boxed.
159727:     const generatedLocation = getFrameLocation(aFrame);
159727:     const { url } = this.synchronize(this.sources.getOriginalLocation(
159727:       generatedLocation));
156845: 
156845:     return this.sources.isBlackBoxed(url) || aFrame.onStep
156845:       ? undefined
156845:       : this._pauseAndRespond(aFrame, { type: "debuggerStatement" });
 89580:   },
 89580: 
 89581:   /**
100191:    * A function that the engine calls when an exception has been thrown and has
100191:    * propagated to the specified frame.
100191:    *
100191:    * @param aFrame Debugger.Frame
100191:    *        The youngest remaining stack frame.
100191:    * @param aValue object
100191:    *        The exception that was thrown.
100191:    */
169591:   onExceptionUnwind: function (aFrame, aValue) {
158913:     let willBeCaught = false;
158913:     for (let frame = aFrame; frame != null; frame = frame.older) {
158913:       if (frame.script.isInCatchScope(frame.offset)) {
158913:         willBeCaught = true;
158913:         break;
158913:       }
158913:     }
158913: 
158913:     if (willBeCaught && this._options.ignoreCaughtExceptions) {
158913:       return undefined;
158913:     }
158913: 
159727:     const generatedLocation = getFrameLocation(aFrame);
159727:     const { url } = this.synchronize(this.sources.getOriginalLocation(
159727:       generatedLocation));
156845: 
156845:     if (this.sources.isBlackBoxed(url)) {
147124:       return undefined;
147124:     }
156845: 
100191:     try {
100191:       let packet = this._paused(aFrame);
100191:       if (!packet) {
100191:         return undefined;
100191:       }
100191: 
100191:       packet.why = { type: "exception",
100191:                      exception: this.createValueGrip(aValue) };
100191:       this.conn.send(packet);
156845: 
156845:       this._pushThreadPause();
100191:     } catch(e) {
150655:       reportError(e, "Got an exception during TA_onExceptionUnwind: ");
156845:     }
156845: 
100191:     return undefined;
100191:   },
100191: 
100191:   /**
 94431:    * A function that the engine calls when a new script has been loaded into the
 94431:    * scope of the specified debuggee global.
 89581:    *
 89581:    * @param aScript Debugger.Script
 89581:    *        The source script that has been loaded into a debuggee compartment.
 94431:    * @param aGlobal Debugger.Object
 94431:    *        A Debugger.Object instance whose referent is the global object.
 89581:    */
169591:   onNewScript: function (aScript, aGlobal) {
135597:     this._addScript(aScript);
148149:     this.sources.sourcesForScript(aScript);
 94431:   },
 94431: 
169591:   onNewSource: function (aSource) {
140693:     this.conn.send({
140693:       from: this.actorID,
140693:       type: "newSource",
140693:       source: aSource.form()
140693:     });
140693:   },
140693: 
 94431:   /**
134823:    * Check if scripts from the provided source URL are allowed to be stored in
134823:    * the cache.
 94431:    *
134823:    * @param aSourceUrl String
134823:    *        The url of the script's source that will be stored.
120758:    * @returns true, if the script can be added, false otherwise.
 94431:    */
169591:   _allowSource: function (aSourceUrl) {
119435:     // Ignore anything we don't have a URL for (eval scripts, for example).
134823:     if (!aSourceUrl)
119435:       return false;
101616:     // Ignore XBL bindings for content debugging.
134823:     if (aSourceUrl.indexOf("chrome://") == 0) {
109004:       return false;
101616:     }
104678:     // Ignore about:* pages for content debugging.
134823:     if (aSourceUrl.indexOf("about:") == 0) {
109004:       return false;
104678:     }
120758:     return true;
120758:   },
120758: 
120758:   /**
148149:    * Restore any pre-existing breakpoints to the scripts that we have access to.
146981:    */
169591:   _restoreBreakpoints: function () {
148149:     for (let s of this.dbg.findScripts()) {
148149:       this._addScript(s);
146981:     }
146981:   },
146981: 
146981:   /**
120758:    * Add the provided script to the server cache.
120758:    *
120758:    * @param aScript Debugger.Script
120758:    *        The source script that will be stored.
148149:    * @returns true, if the script was added; false otherwise.
120758:    */
169591:   _addScript: function (aScript) {
134823:     if (!this._allowSource(aScript.url)) {
148149:       return false;
120758:     }
134823: 
100190:     // Set any stored breakpoints.
153128: 
104666:     let endLine = aScript.startLine + aScript.lineCount - 1;
153128:     for (let bp of this.breakpointStore.findBreakpoints({ url: aScript.url })) {
142765:       // Only consider breakpoints that are not already associated with
142765:       // scripts, and limit search to the line numbers contained in the new
142765:       // script.
153128:       if (!bp.actor.scripts.length
153128:           && bp.line >= aScript.startLine
153128:           && bp.line <= endLine) {
100190:         this._setBreakpoint(bp);
100190:       }
100190:     }
153128: 
148149:     return true;
148149:   },
140693: 
157115: 
157115:   /**
157115:    * Get prototypes and properties of multiple objects.
157115:    */
169591:   onPrototypesAndProperties: function (aRequest) {
157115:     let result = {};
157115:     for (let actorID of aRequest.actors) {
157115:       // This code assumes that there are no lazily loaded actors returned
157115:       // by this call.
157115:       let actor = this.conn.getActor(actorID);
157115:       if (!actor) {
157115:         return { from: this.actorID,
157115:                  error: "noSuchActor" };
157115:       }
157115:       let handler = actor.onPrototypeAndProperties;
157115:       if (!handler) {
157115:         return { from: this.actorID,
157115:                  error: "unrecognizedPacketType",
157115:                  message: ('Actor "' + actorID +
157115:                            '" does not recognize the packet type ' +
157115:                            '"prototypeAndProperties"') };
157115:       }
157115:       result[actorID] = handler.call(actor, {});
157115:     }
157115:     return { from: this.actorID,
157115:              actors: result };
157115:   }
157115: 
 89580: };
 89580: 
 89580: ThreadActor.prototype.requestTypes = {
 89580:   "attach": ThreadActor.prototype.onAttach,
 89580:   "detach": ThreadActor.prototype.onDetach,
140881:   "reconfigure": ThreadActor.prototype.onReconfigure,
 89580:   "resume": ThreadActor.prototype.onResume,
 89580:   "clientEvaluate": ThreadActor.prototype.onClientEvaluate,
 89580:   "frames": ThreadActor.prototype.onFrames,
 89861:   "interrupt": ThreadActor.prototype.onInterrupt,
152472:   "eventListeners": ThreadActor.prototype.onEventListeners,
 89580:   "releaseMany": ThreadActor.prototype.onReleaseMany,
 89580:   "setBreakpoint": ThreadActor.prototype.onSetBreakpoint,
134823:   "sources": ThreadActor.prototype.onSources,
157115:   "threadGrips": ThreadActor.prototype.onThreadGrips,
157115:   "prototypesAndProperties": ThreadActor.prototype.onPrototypesAndProperties
 89580: };
 89580: 
 89580: 
 89580: /**
 89580:  * Creates a PauseActor.
 89580:  *
 89580:  * PauseActors exist for the lifetime of a given debuggee pause.  Used to
 89580:  * scope pause-lifetime grips.
 89580:  *
 89580:  * @param ActorPool aPool
 89580:  *        The actor pool created for this pause.
 89580:  */
 89580: function PauseActor(aPool)
 89580: {
 89580:   this.pool = aPool;
 89580: }
 89580: 
 89580: PauseActor.prototype = {
 89580:   actorPrefix: "pause"
 89580: };
 89580: 
 89580: 
 89581: /**
110808:  * A base actor for any actors that should only respond receive messages in the
110808:  * paused state. Subclasses may expose a `threadActor` which is used to help
110808:  * determine when we are in a paused state. Subclasses should set their own
110808:  * "constructor" property if they want better error messages. You should never
110808:  * instantiate a PauseScopedActor directly, only through subclasses.
110808:  */
110808: function PauseScopedActor()
110808: {
110808: }
110808: 
110808: /**
110808:  * A function decorator for creating methods to handle protocol messages that
110808:  * should only be received while in the paused state.
110808:  *
110808:  * @param aMethod Function
110808:  *        The function we are decorating.
110808:  */
169591: PauseScopedActor.withPaused = function (aMethod) {
110808:   return function () {
110808:     if (this.isPaused()) {
110808:       return aMethod.apply(this, arguments);
110808:     } else {
110808:       return this._wrongState();
110808:     }
110808:   };
110808: };
110808: 
110808: PauseScopedActor.prototype = {
110808: 
110808:   /**
110808:    * Returns true if we are in the paused state.
110808:    */
169591:   isPaused: function () {
110808:     // When there is not a ThreadActor available (like in the webconsole) we
110808:     // have to be optimistic and assume that we are paused so that we can
110808:     // respond to requests.
110808:     return this.threadActor ? this.threadActor.state === "paused" : true;
110808:   },
110808: 
110808:   /**
110808:    * Returns the wrongState response packet for this actor.
110808:    */
169591:   _wrongState: function () {
110808:     return {
110808:       error: "wrongState",
110808:       message: this.constructor.name +
110808:         " actors can only be accessed while the thread is paused."
140693:     };
110808:   }
110808: };
110808: 
110808: 
110808: /**
116020:  * A SourceActor provides information about the source of a script.
116020:  *
160799:  * @param String url
134823:  *        The url of the source we are representing.
160799:  * @param ThreadActor thread
116020:  *        The current thread actor.
160799:  * @param SourceMapConsumer sourceMap
144758:  *        Optional. The source map that introduced this source, if available.
160799:  * @param String generatedSource
160508:  *        Optional, passed in when aSourceMap is also passed in. The generated
160508:  *        source url that introduced this source.
160799:  * @param String text
160799:  *        Optional. The content text of this source, if immediately available.
160799:  * @param String contentType
160799:  *        Optional. The content type of this source, if immediately available.
116020:  */
160799: function SourceActor({ url, thread, sourceMap, generatedSource, text,
160799:                        contentType }) {
160799:   this._threadActor = thread;
160799:   this._url = url;
160799:   this._sourceMap = sourceMap;
160799:   this._generatedSource = generatedSource;
160799:   this._text = text;
160799:   this._contentType = contentType;
160508: 
160508:   this.onSource = this.onSource.bind(this);
160508:   this._invertSourceMap = this._invertSourceMap.bind(this);
160508:   this._saveMap = this._saveMap.bind(this);
166323:   this._getSourceText = this._getSourceText.bind(this);
166323: 
166323:   if (this.threadActor.sources.isPrettyPrinted(this.url)) {
166323:     this._init = this.onPrettyPrint({
166323:       indent: this.threadActor.sources.prettyPrintIndent(this.url)
166323:     }).then(null, error => {
166323:       DevToolsUtils.reportException("SourceActor", error);
166323:     });
166323:   } else {
166323:     this._init = null;
166323:   }
116020: }
116020: 
116020: SourceActor.prototype = {
116020:   constructor: SourceActor,
116020:   actorPrefix: "source",
116020: 
166323:   _oldSourceMap: null,
166323:   _init: null,
166323: 
140693:   get threadActor() this._threadActor,
140693:   get url() this._url,
116020: 
164286:   get prettyPrintWorker() {
164286:     return this.threadActor.prettyPrintWorker;
164286:   },
164286: 
169591:   form: function () {
134823:     return {
134823:       actor: this.actorID,
147124:       url: this._url,
166323:       isBlackBoxed: this.threadActor.sources.isBlackBoxed(this.url),
166323:       isPrettyPrinted: this.threadActor.sources.isPrettyPrinted(this.url)
134823:       // TODO bug 637572: introductionScript
134823:     };
116020:   },
116020: 
169591:   disconnect: function () {
116020:     if (this.registeredPool && this.registeredPool.sourceActors) {
116020:       delete this.registeredPool.sourceActors[this.actorID];
116020:     }
116020:   },
116020: 
169591:   _getSourceText: function () {
160799:     const toResolvedContent = t => resolve({
160799:       content: t,
160799:       contentType: this._contentType
160508:     });
160799: 
160799:     let sc;
160799:     if (this._sourceMap && (sc = this._sourceMap.sourceContentFor(this._url))) {
160799:       return toResolvedContent(sc);
160799:     }
160799: 
160799:     if (this._text) {
160799:       return toResolvedContent(this._text);
160508:     }
160508: 
160508:     // XXX bug 865252: Don't load from the cache if this is a source mapped
160508:     // source because we can't guarantee that the cache has the most up to date
160508:     // content for this source like we can if it isn't source mapped.
160508:     return fetch(this._url, { loadFromCache: !this._sourceMap });
160508:   },
160508: 
116020:   /**
116020:    * Handler for the "source" packet.
116020:    */
169591:   onSource: function () {
166323:     return resolve(this._init)
166323:       .then(this._getSourceText)
157976:       .then(({ content, contentType }) => {
116020:         return {
116020:           from: this.actorID,
157976:           source: this.threadActor.createValueGrip(
157976:             content, this.threadActor.threadLifetimePool),
157976:           contentType: contentType
116020:         };
157976:       })
166323:       .then(null, aError => {
150655:         reportError(aError, "Got an exception during SA_onSource: ");
116020:         return {
116020:           "from": this.actorID,
116020:           "error": "loadSourceError",
157976:           "message": "Could not load the source for " + this._url + ".\n"
157976:             + safeErrorString(aError)
116020:         };
144758:       });
147124:   },
147124: 
147124:   /**
160508:    * Handler for the "prettyPrint" packet.
160508:    */
160508:   onPrettyPrint: function ({ indent }) {
166323:     this.threadActor.sources.prettyPrint(this._url, indent);
160508:     return this._getSourceText()
164286:       .then(this._sendToPrettyPrintWorker(indent))
160508:       .then(this._invertSourceMap)
160508:       .then(this._saveMap)
166323:       .then(() => {
166323:         // We need to reset `_init` now because we have already done the work of
166323:         // pretty printing, and don't want onSource to wait forever for
166323:         // initialization to complete.
166323:         this._init = null;
166323:       })
160508:       .then(this.onSource)
166323:       .then(null, error => {
166323:         this.onDisablePrettyPrint();
166323:         return {
160508:           from: this.actorID,
160508:           error: "prettyPrintError",
160508:           message: DevToolsUtils.safeErrorString(error)
166323:         };
166323:       });
160508:   },
160508: 
160508:   /**
164286:    * Return a function that sends a request to the pretty print worker, waits on
164286:    * the worker's response, and then returns the pretty printed code.
164286:    *
164286:    * @param Number aIndent
164286:    *        The number of spaces to indent by the code by, when we send the
164286:    *        request to the pretty print worker.
164286:    * @returns Function
164286:    *          Returns a function which takes an AST, and returns a promise that
164286:    *          is resolved with `{ code, mappings }` where `code` is the pretty
164286:    *          printed code, and `mappings` is an array of source mappings.
160508:    */
169591:   _sendToPrettyPrintWorker: function (aIndent) {
169274:     return ({ content }) => {
164286:       const deferred = promise.defer();
164286:       const id = Math.random();
164286: 
164286:       const onReply = ({ data }) => {
164286:         if (data.id !== id) {
164286:           return;
164286:         }
164286:         this.prettyPrintWorker.removeEventListener("message", onReply, false);
164286: 
164286:         if (data.error) {
164286:           deferred.reject(new Error(data.error));
164286:         } else {
164286:           deferred.resolve(data);
164286:         }
164286:       };
164286: 
164286:       this.prettyPrintWorker.addEventListener("message", onReply, false);
164286:       this.prettyPrintWorker.postMessage({
164286:         id: id,
164286:         url: this._url,
164286:         indent: aIndent,
169274:         source: content
160508:       });
164286: 
164286:       return deferred.promise;
164286:     };
160508:   },
160508: 
160508:   /**
160508:    * Invert a source map. So if a source map maps from a to b, return a new
160508:    * source map from b to a. We need to do this because the source map we get
160508:    * from _generatePrettyCodeAndMap goes the opposite way we want it to for
160508:    * debugging.
163312:    *
163312:    * Note that the source map is modified in place.
160508:    */
169591:   _invertSourceMap: function ({ code, mappings }) {
164286:     const generator = new SourceMapGenerator({ file: this._url });
164286:     return DevToolsUtils.yieldingEach(mappings, m => {
164286:       let mapping = {
164286:         generated: {
164286:           line: m.generatedLine,
164286:           column: m.generatedColumn
164286:         }
164286:       };
164286:       if (m.source) {
164286:         mapping.source = m.source;
164286:         mapping.original = {
164286:           line: m.originalLine,
164286:           column: m.originalColumn
164286:         };
164286:         mapping.name = m.name;
164286:       }
164286:       generator.addMapping(mapping);
164286:     }).then(() => {
164286:       generator.setSourceContent(this._url, code);
164286:       const consumer = SourceMapConsumer.fromSourceMap(generator);
164286: 
163312:       // XXX bug 918802: Monkey punch the source map consumer, because iterating
163312:       // over all mappings and inverting each of them, and then creating a new
164286:       // SourceMapConsumer is slow.
164286: 
163312:       const getOrigPos = consumer.originalPositionFor.bind(consumer);
163312:       const getGenPos = consumer.generatedPositionFor.bind(consumer);
163312: 
163312:       consumer.originalPositionFor = ({ line, column }) => {
163312:         const location = getGenPos({
163312:           line: line,
163312:           column: column,
163312:           source: this._url
160508:         });
163312:         location.source = this._url;
163312:         return location;
160508:       };
163312: 
163312:       consumer.generatedPositionFor = ({ line, column }) => getOrigPos({
163312:         line: line,
163312:         column: column
160508:       });
160508: 
160508:       return {
160508:         code: code,
163312:         map: consumer
160508:       };
164286:     });
160508:   },
160508: 
160508:   /**
160508:    * Save the source map back to our thread's ThreadSources object so that
160508:    * stepping, breakpoints, debugger statements, etc can use it. If we are
160508:    * pretty printing a source mapped source, we need to compose the existing
160508:    * source map with our new one.
160508:    */
169591:   _saveMap: function ({ map }) {
160508:     if (this._sourceMap) {
160508:       // Compose the source maps
166323:       this._oldSourceMap = this._sourceMap;
160508:       this._sourceMap = SourceMapGenerator.fromSourceMap(this._sourceMap);
160508:       this._sourceMap.applySourceMap(map, this._url);
163312:       this._sourceMap = SourceMapConsumer.fromSourceMap(this._sourceMap);
160508:       this._threadActor.sources.saveSourceMap(this._sourceMap,
160508:                                               this._generatedSource);
160508:     } else {
160508:       this._sourceMap = map;
160508:       this._threadActor.sources.saveSourceMap(this._sourceMap, this._url);
160508:     }
160508:   },
160508: 
160508:   /**
166323:    * Handler for the "disablePrettyPrint" packet.
166323:    */
169591:   onDisablePrettyPrint: function () {
166323:     this._sourceMap = this._oldSourceMap;
166323:     this.threadActor.sources.saveSourceMap(this._sourceMap,
166323:                                            this._generatedSource || this._url);
166323:     this.threadActor.sources.disablePrettyPrint(this._url);
166323:     return this.onSource();
166323:   },
166323: 
166323:   /**
147124:    * Handler for the "blackbox" packet.
147124:    */
169591:   onBlackBox: function (aRequest) {
147124:     this.threadActor.sources.blackBox(this.url);
147124:     let packet = {
147124:       from: this.actorID
147124:     };
147124:     if (this.threadActor.state == "paused"
147124:         && this.threadActor.youngestFrame
147124:         && this.threadActor.youngestFrame.script.url == this.url) {
147124:       packet.pausedInSource = true;
147124:     }
147124:     return packet;
147124:   },
147124: 
147124:   /**
147124:    * Handler for the "unblackbox" packet.
147124:    */
169591:   onUnblackBox: function (aRequest) {
147124:     this.threadActor.sources.unblackBox(this.url);
147124:     return {
147124:       from: this.actorID
147124:     };
116020:   }
116020: };
116020: 
116020: SourceActor.prototype.requestTypes = {
147124:   "source": SourceActor.prototype.onSource,
147124:   "blackbox": SourceActor.prototype.onBlackBox,
160508:   "unblackbox": SourceActor.prototype.onUnblackBox,
166323:   "prettyPrint": SourceActor.prototype.onPrettyPrint,
166323:   "disablePrettyPrint": SourceActor.prototype.onDisablePrettyPrint
116020: };
116020: 
116020: 
116020: /**
171617:  * Determine if a given value is non-primitive.
171617:  *
171617:  * @param Any aValue
171617:  *        The value to test.
171617:  * @return Boolean
171617:  *         Whether the value is non-primitive.
171617:  */
171617: function isObject(aValue) {
171617:   const type = typeof aValue;
171617:   return type == "object" ? aValue !== null : type == "function";
171617: }
171617: 
171617: /**
171617:  * Create a function that can safely stringify Debugger.Objects of a given
171617:  * builtin type.
171617:  *
171617:  * @param Function aCtor
171617:  *        The builtin class constructor.
171617:  * @return Function
171617:  *         The stringifier for the class.
171617:  */
171617: function createBuiltinStringifier(aCtor) {
171617:   return aObj => aCtor.prototype.toString.call(aObj.unsafeDereference());
171617: }
171617: 
171617: /**
171617:  * Stringify a Debugger.Object-wrapped Error instance.
171617:  *
171617:  * @param Debugger.Object aObj
171617:  *        The object to stringify.
171617:  * @return String
171617:  *         The stringification of the object.
171617:  */
171617: function errorStringify(aObj) {
174133:   let name = DevToolsUtils.getProperty(aObj, "name");
171617:   if (name === "" || name === undefined) {
171617:     name = aObj.class;
171617:   } else if (isObject(name)) {
171617:     name = stringify(name);
171617:   }
171617: 
174133:   let message = DevToolsUtils.getProperty(aObj, "message");
171617:   if (isObject(message)) {
171617:     message = stringify(message);
171617:   }
171617: 
171617:   if (message === "" || message === undefined) {
171617:     return name;
171617:   }
171617:   return name + ": " + message;
171617: }
171617: 
171617: /**
171617:  * Stringify a Debugger.Object based on its class.
171617:  *
171617:  * @param Debugger.Object aObj
171617:  *        The object to stringify.
171617:  * @return String
171617:  *         The stringification for the object.
171617:  */
171617: function stringify(aObj) {
178572:   if (aObj.class == "DeadObject") {
171617:     const error = new Error("Dead object encountered.");
171617:     DevToolsUtils.reportException("stringify", error);
171617:     return "<dead object>";
171617:   }
171617:   const stringifier = stringifiers[aObj.class] || stringifiers.Object;
171617:   return stringifier(aObj);
171617: }
171617: 
171617: // Used to prevent infinite recursion when an array is found inside itself.
171617: let seen = null;
171617: 
171617: let stringifiers = {
171617:   Error: errorStringify,
171617:   EvalError: errorStringify,
171617:   RangeError: errorStringify,
171617:   ReferenceError: errorStringify,
171617:   SyntaxError: errorStringify,
171617:   TypeError: errorStringify,
171617:   URIError: errorStringify,
171617:   Boolean: createBuiltinStringifier(Boolean),
171617:   Function: createBuiltinStringifier(Function),
171617:   Number: createBuiltinStringifier(Number),
171617:   RegExp: createBuiltinStringifier(RegExp),
171617:   String: createBuiltinStringifier(String),
171617:   Object: obj => "[object " + obj.class + "]",
171617:   Array: obj => {
171617:     // If we're at the top level then we need to create the Set for tracking
171617:     // previously stringified arrays.
171617:     const topLevel = !seen;
171617:     if (topLevel) {
171617:       seen = new Set();
171617:     } else if (seen.has(obj)) {
171617:       return "";
171617:     }
171617: 
171617:     seen.add(obj);
171617: 
174133:     const len = DevToolsUtils.getProperty(obj, "length");
171617:     let string = "";
171617: 
171617:     // The following check is only required because the debuggee could possibly
171617:     // be a Proxy and return any value. For normal objects, array.length is
171617:     // always a non-negative integer.
171617:     if (typeof len == "number" && len > 0) {
171617:       for (let i = 0; i < len; i++) {
171617:         const desc = obj.getOwnPropertyDescriptor(i);
171617:         if (desc) {
171617:           const { value } = desc;
171617:           if (value != null) {
171617:             string += isObject(value) ? stringify(value) : value;
171617:           }
171617:         }
171617: 
171617:         if (i < len - 1) {
171617:           string += ",";
171617:         }
171617:       }
171617:     }
171617: 
171617:     if (topLevel) {
171617:       seen = null;
171617:     }
171617: 
171617:     return string;
171617:   },
171617:   DOMException: obj => {
174133:     const message = DevToolsUtils.getProperty(obj, "message") || "<no message>";
174133:     const result = (+DevToolsUtils.getProperty(obj, "result")).toString(16);
174133:     const code = DevToolsUtils.getProperty(obj, "code");
174133:     const name = DevToolsUtils.getProperty(obj, "name") || "<unknown>";
171617: 
171617:     return '[Exception... "' + message + '" ' +
171617:            'code: "' + code +'" ' +
171617:            'nsresult: "0x' + result + ' (' + name + ')"]';
171617:   }
171617: };
171617: 
171617: /**
 89581:  * Creates an actor for the specified object.
 89581:  *
 89581:  * @param aObj Debugger.Object
 89581:  *        The debuggee object.
 89581:  * @param aThreadActor ThreadActor
 89581:  *        The parent thread actor for this object.
 89581:  */
 89580: function ObjectActor(aObj, aThreadActor)
 89580: {
 89580:   this.obj = aObj;
 89580:   this.threadActor = aThreadActor;
 89580: }
 89580: 
139900: ObjectActor.prototype = {
 89580:   actorPrefix: "obj",
 89580: 
 89581:   /**
 89581:    * Returns a grip for this actor for returning in a protocol message.
 89581:    */
169591:   grip: function () {
178572:     this.threadActor._gripDepth++;
178572: 
146018:     let g = {
146018:       "type": "object",
 92194:       "class": this.obj.class,
146018:       "actor": this.actorID,
146018:       "extensible": this.obj.isExtensible(),
146018:       "frozen": this.obj.isFrozen(),
146018:       "sealed": this.obj.isSealed()
146018:     };
125948: 
178572:     if (this.obj.class != "DeadObject") {
178572:       let raw = Cu.unwaiveXrays(this.obj.unsafeDereference());
178572:       if (!DevToolsUtils.isSafeJSObject(raw)) {
178572:         raw = null;
178572:       }
178572: 
178572:       let previewers = DebuggerServer.ObjectActorPreviewers[this.obj.class] ||
178572:                        DebuggerServer.ObjectActorPreviewers.Object;
178572:       for (let fn of previewers) {
178572:         if (fn(this, g, raw)) {
178572:           break;
178572:         }
178572:       }
178572:     }
178572: 
178572:     this.threadActor._gripDepth--;
125948:     return g;
 89580:   },
 89580: 
 89581:   /**
 89581:    * Releases this actor from the pool.
 89581:    */
169591:   release: function () {
139900:     if (this.registeredPool.objectActors) {
 89580:       this.registeredPool.objectActors.delete(this.obj);
139900:     }
118772:     this.registeredPool.removeActor(this);
 89580:   },
 89580: 
 89580:   /**
172299:    * Handle a protocol request to provide the definition site of this function
172299:    * object.
172299:    *
172299:    * @param aRequest object
172299:    *        The protocol request object.
172299:    */
172299:   onDefinitionSite: function OA_onDefinitionSite(aRequest) {
172299:     if (this.obj.class != "Function") {
172299:       return {
172299:         from: this.actorID,
172299:         error: "objectNotFunction",
172299:         message: this.actorID + " is not a function."
172299:       };
172299:     }
172299: 
172299:     if (!this.obj.script) {
172299:       return {
172299:         from: this.actorID,
172299:         error: "noScript",
172299:         message: this.actorID + " has no Debugger.Script"
172299:       };
172299:     }
172299: 
172299:     const generatedLocation = {
172299:       url: this.obj.script.url,
172299:       line: this.obj.script.startLine,
172299:       // TODO bug 901138: use Debugger.Script.prototype.startColumn.
172299:       column: 0
172299:     };
172299: 
172299:     return this.threadActor.sources.getOriginalLocation(generatedLocation)
172299:       .then(({ url, line, column }) => {
172299:         return {
172299:           from: this.actorID,
172299:           url: url,
172299:           line: line,
172299:           column: column
172299:         };
172299:       });
172299:   },
172299: 
172299:   /**
 89580:    * Handle a protocol request to provide the names of the properties defined on
 89580:    * the object and not its prototype.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onOwnPropertyNames: function (aRequest) {
 89580:     return { from: this.actorID,
 89580:              ownPropertyNames: this.obj.getOwnPropertyNames() };
139900:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to provide the prototype and own properties of
 89580:    * the object.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onPrototypeAndProperties: function (aRequest) {
143352:     let ownProperties = Object.create(null);
148520:     let names;
148520:     try {
148520:       names = this.obj.getOwnPropertyNames();
148520:     } catch (ex) {
148520:       // The above can throw if this.obj points to a dead object.
148520:       // TODO: we should use Cu.isDeadWrapper() - see bug 885800.
148520:       return { from: this.actorID,
148520:                prototype: this.threadActor.createValueGrip(null),
148520:                ownProperties: ownProperties,
148520:                safeGetterValues: Object.create(null) };
148520:     }
148520:     for (let name of names) {
132266:       ownProperties[name] = this._propertyDescriptor(name);
 89580:     }
 89580:     return { from: this.actorID,
 89581:              prototype: this.threadActor.createValueGrip(this.obj.proto),
143352:              ownProperties: ownProperties,
143352:              safeGetterValues: this._findSafeGetterValues(ownProperties) };
143352:   },
143352: 
143352:   /**
143352:    * Find the safe getter values for the current Debugger.Object, |this.obj|.
143352:    *
143352:    * @private
143352:    * @param object aOwnProperties
143352:    *        The object that holds the list of known ownProperties for
143352:    *        |this.obj|.
178572:    * @param number [aLimit=0]
178572:    *        Optional limit of getter values to find.
143352:    * @return object
143352:    *         An object that maps property names to safe getter descriptors as
143352:    *         defined by the remote debugging protocol.
143352:    */
178572:   _findSafeGetterValues: function (aOwnProperties, aLimit = 0)
143352:   {
143352:     let safeGetterValues = Object.create(null);
143352:     let obj = this.obj;
178572:     let level = 0, i = 0;
143352: 
143352:     while (obj) {
143352:       let getters = this._findSafeGetters(obj);
143352:       for (let name of getters) {
143352:         // Avoid overwriting properties from prototypes closer to this.obj. Also
143352:         // avoid providing safeGetterValues from prototypes if property |name|
143352:         // is already defined as an own property.
143352:         if (name in safeGetterValues ||
143352:             (obj != this.obj && name in aOwnProperties)) {
143352:           continue;
143352:         }
143352: 
143352:         let desc = null, getter = null;
143352:         try {
143352:           desc = obj.getOwnPropertyDescriptor(name);
143352:           getter = desc.get;
143352:         } catch (ex) {
143352:           // The above can throw if the cache becomes stale.
143352:         }
143352:         if (!getter) {
143352:           obj._safeGetters = null;
143352:           continue;
143352:         }
143352: 
143352:         let result = getter.call(this.obj);
143352:         if (result && !("throw" in result)) {
143352:           let getterValue = undefined;
143352:           if ("return" in result) {
143352:             getterValue = result.return;
143352:           } else if ("yield" in result) {
143352:             getterValue = result.yield;
143352:           }
144471:           // WebIDL attributes specified with the LenientThis extended attribute
144471:           // return undefined and should be ignored.
144471:           if (getterValue !== undefined) {
143352:             safeGetterValues[name] = {
143352:               getterValue: this.threadActor.createValueGrip(getterValue),
143352:               getterPrototypeLevel: level,
143352:               enumerable: desc.enumerable,
143352:               writable: level == 0 ? desc.writable : true,
143352:             };
178572:             if (aLimit && ++i == aLimit) {
178572:               break;
178572:             }
178572:           }
178572:         }
178572:       }
178572:       if (aLimit && i == aLimit) {
178572:         break;
144471:       }
143352: 
143352:       obj = obj.proto;
143352:       level++;
143352:     }
143352: 
143352:     return safeGetterValues;
143352:   },
143352: 
143352:   /**
143352:    * Find the safe getters for a given Debugger.Object. Safe getters are native
143352:    * getters which are safe to execute.
143352:    *
143352:    * @private
143352:    * @param Debugger.Object aObject
143352:    *        The Debugger.Object where you want to find safe getters.
143352:    * @return Set
143352:    *         A Set of names of safe getters. This result is cached for each
143352:    *         Debugger.Object.
143352:    */
169591:   _findSafeGetters: function (aObject)
143352:   {
143352:     if (aObject._safeGetters) {
143352:       return aObject._safeGetters;
143352:     }
143352: 
143352:     let getters = new Set();
178572:     let names = [];
178572:     try {
178572:       names = aObject.getOwnPropertyNames()
178572:     } catch (ex) {
178572:       // Calling getOwnPropertyNames() on some wrapped native prototypes is not
178572:       // allowed: "cannot modify properties of a WrappedNative". See bug 952093.
178572:     }
178572: 
178572:     for (let name of names) {
143352:       let desc = null;
143352:       try {
143352:         desc = aObject.getOwnPropertyDescriptor(name);
143352:       } catch (e) {
143352:         // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
143352:         // allowed (bug 560072).
143352:       }
143352:       if (!desc || desc.value !== undefined || !("get" in desc)) {
143352:         continue;
143352:       }
143352: 
174133:       if (DevToolsUtils.hasSafeGetter(desc)) {
143352:         getters.add(name);
143352:       }
143352:     }
143352: 
143352:     aObject._safeGetters = getters;
143352:     return getters;
139900:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to provide the prototype of the object.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onPrototype: function (aRequest) {
 89580:     return { from: this.actorID,
 89581:              prototype: this.threadActor.createValueGrip(this.obj.proto) };
139900:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to provide the property descriptor of the
 89580:    * object's specified property.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onProperty: function (aRequest) {
 89580:     if (!aRequest.name) {
 92194:       return { error: "missingParameter",
 89580:                message: "no property name was specified" };
 89580:     }
 89580: 
 89580:     return { from: this.actorID,
132266:              descriptor: this._propertyDescriptor(aRequest.name) };
139900:   },
 89580: 
 89580:   /**
152955:    * Handle a protocol request to provide the display string for the object.
152955:    *
152955:    * @param aRequest object
152955:    *        The protocol request object.
152955:    */
169591:   onDisplayString: function (aRequest) {
171617:     const string = stringify(this.obj);
152955:     return { from: this.actorID,
171617:              displayString: this.threadActor.createValueGrip(string) };
152955:   },
152955: 
152955:   /**
 89581:    * A helper method that creates a property descriptor for the provided object,
 89581:    * properly formatted for sending in a protocol response.
 89581:    *
178572:    * @private
132266:    * @param string aName
132266:    *        The property that the descriptor is generated for.
178572:    * @param boolean [aOnlyEnumerable]
178572:    *        Optional: true if you want a descriptor only for an enumerable
178572:    *        property, false otherwise.
178572:    * @return object|undefined
178572:    *         The property descriptor, or undefined if this is not an enumerable
178572:    *         property and aOnlyEnumerable=true.
 89580:    */
178572:   _propertyDescriptor: function (aName, aOnlyEnumerable) {
132266:     let desc;
132266:     try {
132266:       desc = this.obj.getOwnPropertyDescriptor(aName);
132266:     } catch (e) {
132266:       // Calling getOwnPropertyDescriptor on wrapped native prototypes is not
132266:       // allowed (bug 560072). Inform the user with a bogus, but hopefully
132266:       // explanatory, descriptor.
132266:       return {
132266:         configurable: false,
132266:         writable: false,
132266:         enumerable: false,
132266:         value: e.name
132266:       };
132266:     }
132266: 
178572:     if (!desc || aOnlyEnumerable && !desc.enumerable) {
152955:       return undefined;
152955:     }
152955: 
132266:     let retval = {
132266:       configurable: desc.configurable,
132266:       enumerable: desc.enumerable
132266:     };
132266: 
148359:     if ("value" in desc) {
132266:       retval.writable = desc.writable;
132266:       retval.value = this.threadActor.createValueGrip(desc.value);
 89580:     } else {
132266:       if ("get" in desc) {
143352:         retval.get = this.threadActor.createValueGrip(desc.get);
 89580:       }
143352:       if ("set" in desc) {
132266:         retval.set = this.threadActor.createValueGrip(desc.set);
132266:       }
132266:     }
132266:     return retval;
 89580:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to provide the source code of a function.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onDecompile: function (aRequest) {
 92194:     if (this.obj.class !== "Function") {
 92194:       return { error: "objectNotFunction",
 89580:                message: "decompile request is only valid for object grips " +
 89580:                         "with a 'Function' class." };
 89580:     }
 89580: 
 89580:     return { from: this.actorID,
 89580:              decompiledCode: this.obj.decompile(!!aRequest.pretty) };
139900:   },
139900: 
139900:   /**
139900:    * Handle a protocol request to provide the parameters of a function.
139900:    *
139900:    * @param aRequest object
139900:    *        The protocol request object.
139900:    */
169591:   onParameterNames: function (aRequest) {
139900:     if (this.obj.class !== "Function") {
139900:       return { error: "objectNotFunction",
139900:                message: "'parameterNames' request is only valid for object " +
139900:                         "grips with a 'Function' class." };
139900:     }
139900: 
139900:     return { parameterNames: this.obj.parameterNames };
139900:   },
139900: 
139900:   /**
139900:    * Handle a protocol request to release a thread-lifetime grip.
139900:    *
139900:    * @param aRequest object
139900:    *        The protocol request object.
139900:    */
169591:   onRelease: function (aRequest) {
139900:     this.release();
139900:     return {};
139900:   },
164230: 
164230:   /**
164230:    * Handle a protocol request to provide the lexical scope of a function.
164230:    *
164230:    * @param aRequest object
164230:    *        The protocol request object.
164230:    */
169591:   onScope: function (aRequest) {
164230:     if (this.obj.class !== "Function") {
164230:       return { error: "objectNotFunction",
164230:                message: "scope request is only valid for object grips with a" +
164230:                         " 'Function' class." };
164230:     }
164230: 
164230:     let envActor = this.threadActor.createEnvironmentActor(this.obj.environment,
164230:                                                            this.registeredPool);
164230:     if (!envActor) {
164230:       return { error: "notDebuggee",
164230:                message: "cannot access the environment of this function." };
164230:     }
164230: 
164230:     return { from: this.actorID, scope: envActor.form() };
164230:   }
139900: };
139900: 
139900: ObjectActor.prototype.requestTypes = {
172299:   "definitionSite": ObjectActor.prototype.onDefinitionSite,
139900:   "parameterNames": ObjectActor.prototype.onParameterNames,
139900:   "prototypeAndProperties": ObjectActor.prototype.onPrototypeAndProperties,
139900:   "prototype": ObjectActor.prototype.onPrototype,
139900:   "property": ObjectActor.prototype.onProperty,
152955:   "displayString": ObjectActor.prototype.onDisplayString,
139900:   "ownPropertyNames": ObjectActor.prototype.onOwnPropertyNames,
139900:   "decompile": ObjectActor.prototype.onDecompile,
139900:   "release": ObjectActor.prototype.onRelease,
164230:   "scope": ObjectActor.prototype.onScope,
139900: };
139900: 
139900: 
139900: /**
178572:  * Functions for adding information to ObjectActor grips for the purpose of
178572:  * having customized output. This object holds arrays mapped by
178572:  * Debugger.Object.prototype.class.
178572:  *
178572:  * In each array you can add functions that take two
178572:  * arguments:
178572:  *   - the ObjectActor instance to make a preview for,
178572:  *   - the grip object being prepared for the client,
178572:  *   - the raw JS object after calling Debugger.Object.unsafeDereference(). This
178572:  *   argument is only provided if the object is safe for reading properties and
178572:  *   executing methods. See DevToolsUtils.isSafeJSObject().
178572:  *
178572:  * Functions must return false if they cannot provide preview
178572:  * information for the debugger object, or true otherwise.
178572:  */
178572: DebuggerServer.ObjectActorPreviewers = {
178572:   Function: [function({obj, threadActor}, aGrip) {
178572:     if (obj.name) {
178572:       aGrip.name = obj.name;
178572:     }
178572: 
178572:     if (obj.displayName) {
178572:       aGrip.displayName = obj.displayName.substr(0, 500);
178572:     }
178572: 
178572:     if (obj.parameterNames) {
178572:       aGrip.parameterNames = obj.parameterNames;
178572:     }
178572: 
178572:     // Check if the developer has added a de-facto standard displayName
178572:     // property for us to use.
178572:     let userDisplayName;
178572:     try {
178572:       userDisplayName = obj.getOwnPropertyDescriptor("displayName");
178572:     } catch (e) {
178572:       // Calling getOwnPropertyDescriptor with displayName might throw
178572:       // with "permission denied" errors for some functions.
178572:       dumpn(e);
178572:     }
178572: 
178572:     if (userDisplayName && typeof userDisplayName.value == "string" &&
178572:         userDisplayName.value) {
178572:       aGrip.userDisplayName = threadActor.createValueGrip(userDisplayName.value);
178572:     }
178572: 
178572:     return true;
178572:   }],
178572: 
178572:   RegExp: [function({obj, threadActor}, aGrip) {
178572:     // Avoid having any special preview for the RegExp.prototype itself.
178572:     if (!obj.proto || obj.proto.class != "RegExp") {
178572:       return false;
178572:     }
178572: 
178572:     let str = RegExp.prototype.toString.call(obj.unsafeDereference());
178572:     aGrip.displayString = threadActor.createValueGrip(str);
178572:     return true;
178572:   }],
178572: 
178572:   Date: [function({obj, threadActor}, aGrip) {
178572:     if (!obj.proto || obj.proto.class != "Date") {
178572:       return false;
178572:     }
178572: 
178572:     let time = Date.prototype.getTime.call(obj.unsafeDereference());
178572: 
178572:     aGrip.preview = {
178572:       timestamp: threadActor.createValueGrip(time),
178572:     };
178572:     return true;
178572:   }],
178572: 
178572:   Array: [function({obj, threadActor}, aGrip) {
178572:     let length = DevToolsUtils.getProperty(obj, "length");
178572:     if (typeof length != "number") {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "ArrayLike",
178572:       length: length,
178572:     };
178572: 
178572:     if (threadActor._gripDepth > 1) {
178572:       return true;
178572:     }
178572: 
178572:     let raw = obj.unsafeDereference();
178572:     let items = aGrip.preview.items = [];
178572: 
178572:     for (let [i, value] of Array.prototype.entries.call(raw)) {
178572:       if (Object.hasOwnProperty.call(raw, i)) {
178572:         value = makeDebuggeeValueIfNeeded(obj, value);
178572:         items.push(threadActor.createValueGrip(value));
178572:       } else {
178572:         items.push(null);
178572:       }
178572: 
178572:       if (items.length == OBJECT_PREVIEW_MAX_ITEMS) {
178572:         break;
178572:       }
178572:     }
178572: 
178572:     return true;
178572:   }], // Array
178572: 
178572:   Set: [function({obj, threadActor}, aGrip) {
178572:     let size = DevToolsUtils.getProperty(obj, "size");
178572:     if (typeof size != "number") {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "ArrayLike",
178572:       length: size,
178572:     };
178572: 
178572:     // Avoid recursive object grips.
178572:     if (threadActor._gripDepth > 1) {
178572:       return true;
178572:     }
178572: 
178572:     let raw = obj.unsafeDereference();
178572:     let items = aGrip.preview.items = [];
178572:     for (let item of Set.prototype.values.call(raw)) {
178572:       item = makeDebuggeeValueIfNeeded(obj, item);
178572:       items.push(threadActor.createValueGrip(item));
178572:       if (items.length == OBJECT_PREVIEW_MAX_ITEMS) {
178572:         break;
178572:       }
178572:     }
178572: 
178572:     return true;
178572:   }], // Set
178572: 
178572:   Map: [function({obj, threadActor}, aGrip) {
178572:     let size = DevToolsUtils.getProperty(obj, "size");
178572:     if (typeof size != "number") {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "MapLike",
178572:       size: size,
178572:     };
178572: 
178572:     if (threadActor._gripDepth > 1) {
178572:       return true;
178572:     }
178572: 
178572:     let raw = obj.unsafeDereference();
178572:     let entries = aGrip.preview.entries = [];
178572:     for (let [key, value] of Map.prototype.entries.call(raw)) {
178572:       key = makeDebuggeeValueIfNeeded(obj, key);
178572:       value = makeDebuggeeValueIfNeeded(obj, value);
178572:       entries.push([threadActor.createValueGrip(key),
178572:                     threadActor.createValueGrip(value)]);
178572:       if (entries.length == OBJECT_PREVIEW_MAX_ITEMS) {
178572:         break;
178572:       }
178572:     }
178572: 
178572:     return true;
178572:   }], // Map
178572: 
178572:   DOMStringMap: [function({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj) {
178572:       return false;
178572:     }
178572: 
178572:     let keys = obj.getOwnPropertyNames();
178572:     aGrip.preview = {
178572:       kind: "MapLike",
178572:       size: keys.length,
178572:     };
178572: 
178572:     if (threadActor._gripDepth > 1) {
178572:       return true;
178572:     }
178572: 
178572:     let entries = aGrip.preview.entries = [];
178572:     for (let key of keys) {
178572:       let value = makeDebuggeeValueIfNeeded(obj, aRawObj[key]);
178572:       entries.push([key, threadActor.createValueGrip(value)]);
178572:       if (entries.length == OBJECT_PREVIEW_MAX_ITEMS) {
178572:         break;
178572:       }
178572:     }
178572: 
178572:     return true;
178572:   }], // DOMStringMap
178572: }; // DebuggerServer.ObjectActorPreviewers
178572: 
178572: // Preview functions that do not rely on the object class.
178572: DebuggerServer.ObjectActorPreviewers.Object = [
178572:   function TypedArray({obj, threadActor}, aGrip) {
178572:     if (TYPED_ARRAY_CLASSES.indexOf(obj.class) == -1) {
178572:       return false;
178572:     }
178572: 
178572:     let length = DevToolsUtils.getProperty(obj, "length");
178572:     if (typeof length != "number") {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "ArrayLike",
178572:       length: length,
178572:     };
178572: 
178572:     if (threadActor._gripDepth > 1) {
178572:       return true;
178572:     }
178572: 
178572:     let raw = obj.unsafeDereference();
178572:     let global = Cu.getGlobalForObject(DebuggerServer);
178572:     let classProto = global[obj.class].prototype;
178572:     let safeView = classProto.subarray.call(raw, 0, OBJECT_PREVIEW_MAX_ITEMS);
178572:     let items = aGrip.preview.items = [];
178572:     for (let i = 0; i < safeView.length; i++) {
178572:       items.push(safeView[i]);
178572:     }
178572: 
178572:     return true;
178572:   },
178572: 
178572:   function Error({obj, threadActor}, aGrip) {
178572:     switch (obj.class) {
178572:       case "Error":
178572:       case "EvalError":
178572:       case "RangeError":
178572:       case "ReferenceError":
178572:       case "SyntaxError":
178572:       case "TypeError":
178572:       case "URIError":
178572:         let name = DevToolsUtils.getProperty(obj, "name");
178572:         let msg = DevToolsUtils.getProperty(obj, "message");
178572:         let stack = DevToolsUtils.getProperty(obj, "stack");
178572:         let fileName = DevToolsUtils.getProperty(obj, "fileName");
178572:         let lineNumber = DevToolsUtils.getProperty(obj, "lineNumber");
178572:         let columnNumber = DevToolsUtils.getProperty(obj, "columnNumber");
178572:         aGrip.preview = {
178572:           kind: "Error",
178572:           name: threadActor.createValueGrip(name),
178572:           message: threadActor.createValueGrip(msg),
178572:           stack: threadActor.createValueGrip(stack),
178572:           fileName: threadActor.createValueGrip(fileName),
178572:           lineNumber: threadActor.createValueGrip(lineNumber),
178572:           columnNumber: threadActor.createValueGrip(columnNumber),
178572:         };
178572:         return true;
178572:       default:
178572:         return false;
178572:     }
178572:   },
178572: 
178572:   function CSSMediaRule({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSMediaRule)) {
178572:       return false;
178572:     }
178572:     aGrip.preview = {
178572:       kind: "ObjectWithText",
178572:       text: threadActor.createValueGrip(aRawObj.conditionText),
178572:     };
178572:     return true;
178572:   },
178572: 
178572:   function CSSStyleRule({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSStyleRule)) {
178572:       return false;
178572:     }
178572:     aGrip.preview = {
178572:       kind: "ObjectWithText",
178572:       text: threadActor.createValueGrip(aRawObj.selectorText),
178572:     };
178572:     return true;
178572:   },
178572: 
178572:   function ObjectWithURL({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj ||
178572:         !(aRawObj instanceof Ci.nsIDOMCSSImportRule ||
178572:           aRawObj instanceof Ci.nsIDOMCSSStyleSheet ||
178572:           aRawObj instanceof Ci.nsIDOMLocation ||
178572:           aRawObj instanceof Ci.nsIDOMWindow)) {
178572:       return false;
178572:     }
178572: 
178572:     let url;
178572:     if (aRawObj instanceof Ci.nsIDOMWindow) {
178572:       url = aRawObj.location.href;
178572:     } else {
178572:       url = aRawObj.href;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "ObjectWithURL",
178572:       url: threadActor.createValueGrip(url),
178572:     };
178572: 
178572:     return true;
178572:   },
178572: 
178572:   function ArrayLike({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj ||
178572:         obj.class != "DOMTokenList" &&
178572:         !(aRawObj instanceof Ci.nsIDOMMozNamedAttrMap ||
178572:           aRawObj instanceof Ci.nsIDOMCSSRuleList ||
178572:           aRawObj instanceof Ci.nsIDOMCSSValueList ||
178572:           aRawObj instanceof Ci.nsIDOMDOMStringList ||
178572:           aRawObj instanceof Ci.nsIDOMFileList ||
178572:           aRawObj instanceof Ci.nsIDOMFontFaceList ||
178572:           aRawObj instanceof Ci.nsIDOMMediaList ||
178572:           aRawObj instanceof Ci.nsIDOMNodeList ||
178572:           aRawObj instanceof Ci.nsIDOMStyleSheetList)) {
178572:       return false;
178572:     }
178572: 
178572:     if (typeof aRawObj.length != "number") {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "ArrayLike",
178572:       length: aRawObj.length,
178572:     };
178572: 
178572:     if (threadActor._gripDepth > 1) {
178572:       return true;
178572:     }
178572: 
178572:     let items = aGrip.preview.items = [];
178572: 
178572:     for (let i = 0; i < aRawObj.length &&
178572:                     items.length < OBJECT_PREVIEW_MAX_ITEMS; i++) {
178572:       let value = makeDebuggeeValueIfNeeded(obj, aRawObj[i]);
178572:       items.push(threadActor.createValueGrip(value));
178572:     }
178572: 
178572:     return true;
178572:   }, // ArrayLike
178572: 
178572:   function CSSStyleDeclaration({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMCSSStyleDeclaration)) {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "MapLike",
178572:       size: aRawObj.length,
178572:     };
178572: 
178572:     let entries = aGrip.preview.entries = [];
178572: 
178572:     for (let i = 0; i < OBJECT_PREVIEW_MAX_ITEMS &&
178572:                     i < aRawObj.length; i++) {
178572:       let prop = aRawObj[i];
178572:       let value = aRawObj.getPropertyValue(prop);
178572:       entries.push([prop, threadActor.createValueGrip(value)]);
178572:     }
178572: 
178572:     return true;
178572:   },
178572: 
178572:   function DOMNode({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMNode)) {
178572:       return false;
178572:     }
178572: 
178572:     let preview = aGrip.preview = {
178572:       kind: "DOMNode",
178572:       nodeType: aRawObj.nodeType,
178572:       nodeName: aRawObj.nodeName,
178572:     };
178572: 
178572:     if (aRawObj instanceof Ci.nsIDOMDocument) {
178572:       preview.location = threadActor.createValueGrip(aRawObj.location.href);
178572:     } else if (aRawObj instanceof Ci.nsIDOMDocumentFragment) {
178572:       preview.childNodesLength = aRawObj.childNodes.length;
178572: 
178572:       if (threadActor._gripDepth < 2) {
178572:         preview.childNodes = [];
178572:         for (let node of aRawObj.childNodes) {
178572:           let actor = threadActor.createValueGrip(obj.makeDebuggeeValue(node));
178572:           preview.childNodes.push(actor);
178572:           if (preview.childNodes.length == OBJECT_PREVIEW_MAX_ITEMS) {
178572:             break;
178572:           }
178572:         }
178572:       }
178572:     } else if (aRawObj instanceof Ci.nsIDOMElement) {
178572:       // Add preview for DOM element attributes.
178572:       if (aRawObj instanceof Ci.nsIDOMHTMLElement) {
178572:         preview.nodeName = preview.nodeName.toLowerCase();
178572:       }
178572: 
178572:       let i = 0;
178572:       preview.attributes = {};
178572:       preview.attributesLength = aRawObj.attributes.length;
178572:       for (let attr of aRawObj.attributes) {
178572:         preview.attributes[attr.nodeName] = threadActor.createValueGrip(attr.value);
178572:         if (++i == OBJECT_PREVIEW_MAX_ITEMS) {
178572:           break;
178572:         }
178572:       }
178572:     } else if (aRawObj instanceof Ci.nsIDOMAttr) {
178572:       preview.value = threadActor.createValueGrip(aRawObj.value);
178572:     } else if (aRawObj instanceof Ci.nsIDOMText ||
178572:                aRawObj instanceof Ci.nsIDOMComment) {
178572:       preview.textContent = threadActor.createValueGrip(aRawObj.textContent);
178572:     }
178572: 
178572:     return true;
178572:   }, // DOMNode
178572: 
178572:   function DOMEvent({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMEvent)) {
178572:       return false;
178572:     }
178572: 
178572:     let preview = aGrip.preview = {
178572:       kind: "DOMEvent",
178572:       type: aRawObj.type,
178572:       properties: Object.create(null),
178572:     };
178572: 
178572:     if (threadActor._gripDepth < 2) {
178572:       let target = obj.makeDebuggeeValue(aRawObj.target);
178572:       preview.target = threadActor.createValueGrip(target);
178572:     }
178572: 
178572:     let props = [];
178572:     if (aRawObj instanceof Ci.nsIDOMMouseEvent) {
178572:       props.push("buttons", "clientX", "clientY", "layerX", "layerY");
178572:     } else if (aRawObj instanceof Ci.nsIDOMKeyEvent) {
178572:       let modifiers = [];
178572:       if (aRawObj.altKey) {
178572:         modifiers.push("Alt");
178572:       }
178572:       if (aRawObj.ctrlKey) {
178572:         modifiers.push("Control");
178572:       }
178572:       if (aRawObj.metaKey) {
178572:         modifiers.push("Meta");
178572:       }
178572:       if (aRawObj.shiftKey) {
178572:         modifiers.push("Shift");
178572:       }
178572:       preview.eventKind = "key";
178572:       preview.modifiers = modifiers;
178572: 
178572:       props.push("key", "charCode", "keyCode");
178572:     } else if (aRawObj instanceof Ci.nsIDOMTransitionEvent ||
178572:                aRawObj instanceof Ci.nsIDOMAnimationEvent) {
178572:       props.push("animationName", "pseudoElement");
178572:     } else if (aRawObj instanceof Ci.nsIDOMClipboardEvent) {
178572:       props.push("clipboardData");
178572:     }
178572: 
178572:     // Add event-specific properties.
178572:     for (let prop of props) {
178572:       let value = aRawObj[prop];
178572:       if (value && (typeof value == "object" || typeof value == "function")) {
178572:         // Skip properties pointing to objects.
178572:         if (threadActor._gripDepth > 1) {
178572:           continue;
178572:         }
178572:         value = obj.makeDebuggeeValue(value);
178572:       }
178572:       preview.properties[prop] = threadActor.createValueGrip(value);
178572:     }
178572: 
178572:     // Add any properties we find on the event object.
178572:     if (!props.length) {
178572:       let i = 0;
178572:       for (let prop in aRawObj) {
178572:         let value = aRawObj[prop];
178572:         if (prop == "target" || prop == "type" || value === null ||
178572:             typeof value == "function") {
178572:           continue;
178572:         }
178572:         if (value && typeof value == "object") {
178572:           if (threadActor._gripDepth > 1) {
178572:             continue;
178572:           }
178572:           value = obj.makeDebuggeeValue(value);
178572:         }
178572:         preview.properties[prop] = threadActor.createValueGrip(value);
178572:         if (++i == OBJECT_PREVIEW_MAX_ITEMS) {
178572:           break;
178572:         }
178572:       }
178572:     }
178572: 
178572:     return true;
178572:   }, // DOMEvent
178572: 
178572:   function DOMException({obj, threadActor}, aGrip, aRawObj) {
178572:     if (!aRawObj || !(aRawObj instanceof Ci.nsIDOMDOMException)) {
178572:       return false;
178572:     }
178572: 
178572:     aGrip.preview = {
178572:       kind: "DOMException",
178572:       name: threadActor.createValueGrip(aRawObj.name),
178572:       message: threadActor.createValueGrip(aRawObj.message),
178572:       code: threadActor.createValueGrip(aRawObj.code),
178572:       result: threadActor.createValueGrip(aRawObj.result),
178572:       filename: threadActor.createValueGrip(aRawObj.filename),
178572:       lineNumber: threadActor.createValueGrip(aRawObj.lineNumber),
178572:       columnNumber: threadActor.createValueGrip(aRawObj.columnNumber),
178572:     };
178572: 
178572:     return true;
178572:   },
178572: 
178572:   function GenericObject(aObjectActor, aGrip) {
178572:     let {obj, threadActor} = aObjectActor;
178572:     if (aGrip.preview || aGrip.displayString || threadActor._gripDepth > 1) {
178572:       return false;
178572:     }
178572: 
178572:     let i = 0, names = [];
178572:     let preview = aGrip.preview = {
178572:       kind: "Object",
178572:       ownProperties: Object.create(null),
178572:     };
178572: 
178572:     try {
178572:       names = obj.getOwnPropertyNames();
178572:     } catch (ex) {
178572:       // Calling getOwnPropertyNames() on some wrapped native prototypes is not
178572:       // allowed: "cannot modify properties of a WrappedNative". See bug 952093.
178572:     }
178572: 
178572:     preview.ownPropertiesLength = names.length;
178572: 
178572:     for (let name of names) {
178572:       let desc = aObjectActor._propertyDescriptor(name, true);
178572:       if (!desc) {
178572:         continue;
178572:       }
178572: 
178572:       preview.ownProperties[name] = desc;
178572:       if (++i == OBJECT_PREVIEW_MAX_ITEMS) {
178572:         break;
178572:       }
178572:     }
178572: 
178572:     if (i < OBJECT_PREVIEW_MAX_ITEMS) {
178572:       preview.safeGetterValues = aObjectActor.
178572:                                  _findSafeGetterValues(preview.ownProperties,
178572:                                                        OBJECT_PREVIEW_MAX_ITEMS - i);
178572:     }
178572: 
178572:     return true;
178572:   }, // GenericObject
178572: ]; // DebuggerServer.ObjectActorPreviewers.Object
178572: 
178572: /**
139900:  * Creates a pause-scoped actor for the specified object.
139900:  * @see ObjectActor
139900:  */
139900: function PauseScopedObjectActor()
139900: {
139900:   ObjectActor.apply(this, arguments);
139900: }
139900: 
139900: PauseScopedObjectActor.prototype = Object.create(PauseScopedActor.prototype);
139900: 
139900: update(PauseScopedObjectActor.prototype, ObjectActor.prototype);
139900: 
139900: update(PauseScopedObjectActor.prototype, {
139900:   constructor: PauseScopedObjectActor,
164230:   actorPrefix: "pausedobj",
139900: 
139900:   onOwnPropertyNames:
139900:     PauseScopedActor.withPaused(ObjectActor.prototype.onOwnPropertyNames),
139900: 
139900:   onPrototypeAndProperties:
139900:     PauseScopedActor.withPaused(ObjectActor.prototype.onPrototypeAndProperties),
139900: 
139900:   onPrototype: PauseScopedActor.withPaused(ObjectActor.prototype.onPrototype),
139900:   onProperty: PauseScopedActor.withPaused(ObjectActor.prototype.onProperty),
139900:   onDecompile: PauseScopedActor.withPaused(ObjectActor.prototype.onDecompile),
139900: 
152955:   onDisplayString:
152955:     PauseScopedActor.withPaused(ObjectActor.prototype.onDisplayString),
152955: 
139900:   onParameterNames:
139900:     PauseScopedActor.withPaused(ObjectActor.prototype.onParameterNames),
 89580: 
 89580:   /**
 89581:    * Handle a protocol request to promote a pause-lifetime grip to a
 89581:    * thread-lifetime grip.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89581:    */
169591:   onThreadGrip: PauseScopedActor.withPaused(function (aRequest) {
118772:     this.threadActor.threadObjectGrip(this);
118772:     return {};
110808:   }),
 89580: 
 89581:   /**
 89581:    * Handle a protocol request to release a thread-lifetime grip.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89581:    */
169591:   onRelease: PauseScopedActor.withPaused(function (aRequest) {
 89580:     if (this.registeredPool !== this.threadActor.threadLifetimePool) {
 92194:       return { error: "notReleasable",
118772:                message: "Only thread-lifetime actors can be released." };
 89580:     }
 89580: 
 89580:     this.release();
 89580:     return {};
110808:   }),
110808: });
 89580: 
139900: update(PauseScopedObjectActor.prototype.requestTypes, {
139900:   "threadGrip": PauseScopedObjectActor.prototype.onThreadGrip,
139900: });
 89580: 
 89580: 
 89581: /**
110808:  * Creates an actor for the specied "very long" string. "Very long" is specified
110808:  * at the server's discretion.
110808:  *
110808:  * @param aString String
110808:  *        The string.
110808:  */
110808: function LongStringActor(aString)
110808: {
110808:   this.string = aString;
110808:   this.stringLength = aString.length;
110808: }
110808: 
110808: LongStringActor.prototype = {
110808: 
110808:   actorPrefix: "longString",
110808: 
169591:   disconnect: function () {
110808:     // Because longStringActors is not a weak map, we won't automatically leave
110808:     // it so we need to manually leave on disconnect so that we don't leak
110808:     // memory.
110808:     if (this.registeredPool && this.registeredPool.longStringActors) {
110808:       delete this.registeredPool.longStringActors[this.actorID];
110808:     }
110808:   },
110808: 
110808:   /**
110808:    * Returns a grip for this actor for returning in a protocol message.
110808:    */
169591:   grip: function () {
110808:     return {
110808:       "type": "longString",
110808:       "initial": this.string.substring(
110808:         0, DebuggerServer.LONG_STRING_INITIAL_LENGTH),
110808:       "length": this.stringLength,
110808:       "actor": this.actorID
110808:     };
110808:   },
110808: 
110808:   /**
110808:    * Handle a request to extract part of this actor's string.
110808:    *
110808:    * @param aRequest object
110808:    *        The protocol request object.
110808:    */
169591:   onSubstring: function (aRequest) {
110808:     return {
110808:       "from": this.actorID,
110808:       "substring": this.string.substring(aRequest.start, aRequest.end)
110808:     };
122250:   },
122250: 
122250:   /**
122250:    * Handle a request to release this LongStringActor instance.
122250:    */
169591:   onRelease: function () {
122250:     // TODO: also check if registeredPool === threadActor.threadLifetimePool
122250:     // when the web console moves aray from manually releasing pause-scoped
122250:     // actors.
122250:     if (this.registeredPool.longStringActors) {
122250:       delete this.registeredPool.longStringActors[this.actorID];
110808:     }
122250:     this.registeredPool.removeActor(this);
122250:     return {};
122250:   },
110808: };
110808: 
110808: LongStringActor.prototype.requestTypes = {
122250:   "substring": LongStringActor.prototype.onSubstring,
122250:   "release": LongStringActor.prototype.onRelease
110808: };
110808: 
110808: 
110808: /**
 89581:  * Creates an actor for the specified stack frame.
 89581:  *
 89581:  * @param aFrame Debugger.Frame
 89581:  *        The debuggee frame.
 89581:  * @param aThreadActor ThreadActor
 89581:  *        The parent thread actor for this frame.
 89581:  */
 89580: function FrameActor(aFrame, aThreadActor)
 89580: {
 89580:   this.frame = aFrame;
 89580:   this.threadActor = aThreadActor;
 89580: }
 89580: 
 89580: FrameActor.prototype = {
 89580:   actorPrefix: "frame",
 89580: 
 89580:   /**
 89580:    * A pool that contains frame-lifetime objects, like the environment.
 89580:    */
 89580:   _frameLifetimePool: null,
 89580:   get frameLifetimePool() {
 89580:     if (!this._frameLifetimePool) {
 89580:       this._frameLifetimePool = new ActorPool(this.conn);
 89580:       this.conn.addActorPool(this._frameLifetimePool);
 89580:     }
 89580:     return this._frameLifetimePool;
 89580:   },
 89580: 
 89581:   /**
 89581:    * Finalization handler that is called when the actor is being evicted from
 89581:    * the pool.
 89581:    */
169591:   disconnect: function () {
 89580:     this.conn.removeActorPool(this._frameLifetimePool);
 89580:     this._frameLifetimePool = null;
 89580:   },
 89580: 
 89581:   /**
 92194:    * Returns a frame form for use in a protocol message.
 89581:    */
169591:   form: function () {
 92194:     let form = { actor: this.actorID,
 89580:                  type: this.frame.type };
 89580:     if (this.frame.type === "call") {
 92194:       form.callee = this.threadActor.createValueGrip(this.frame.callee);
 89580:     }
 89580: 
129487:     if (this.frame.environment) {
 89581:       let envActor = this.threadActor
 97625:         .createEnvironmentActor(this.frame.environment,
 89581:                                 this.frameLifetimePool);
129487:       form.environment = envActor.form();
129487:     }
 92194:     form.this = this.threadActor.createValueGrip(this.frame.this);
 92194:     form.arguments = this._args();
 89944:     if (this.frame.script) {
159727:       form.where = getFrameLocation(this.frame);
 89944:     }
 89580: 
 89580:     if (!this.frame.older) {
 92194:       form.oldest = true;
 89580:     }
 89580: 
 92194:     return form;
 89580:   },
 89580: 
169591:   _args: function () {
 92194:     if (!this.frame.arguments) {
 89580:       return [];
 89580:     }
 89580: 
 89581:     return [this.threadActor.createValueGrip(arg)
 92194:             for each (arg in this.frame.arguments)];
 89580:   },
 89580: 
 89581:   /**
 89581:    * Handle a protocol request to pop this frame from the stack.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89581:    */
169591:   onPop: function (aRequest) {
 93468:     // TODO: remove this when Debugger.Frame.prototype.pop is implemented
 93468:     if (typeof this.frame.pop != "function") {
 89580:       return { error: "notImplemented",
 89580:                message: "Popping frames is not yet implemented." };
 89580:     }
 93468: 
 93468:     while (this.frame != this.threadActor.dbg.getNewestFrame()) {
 93468:       this.threadActor.dbg.getNewestFrame().pop();
 93468:     }
 93468:     this.frame.pop(aRequest.completionValue);
 93468: 
 93468:     // TODO: return the watches property when frame pop watch actors are
 93468:     // implemented.
 93468:     return { from: this.actorID };
 93468:   }
 89580: };
 89580: 
 89580: FrameActor.prototype.requestTypes = {
 89580:   "pop": FrameActor.prototype.onPop,
 89580: };
 89580: 
 89580: 
 89580: /**
 89580:  * Creates a BreakpointActor. BreakpointActors exist for the lifetime of their
 89580:  * containing thread and are responsible for deleting breakpoints, handling
 89580:  * breakpoint hits and associating breakpoints with scripts.
 89581:  *
 89580:  * @param ThreadActor aThreadActor
 89580:  *        The parent thread actor that contains this breakpoint.
100190:  * @param object aLocation
100190:  *        The location of the breakpoint as specified in the protocol.
 89580:  */
100190: function BreakpointActor(aThreadActor, aLocation)
 89580: {
100190:   this.scripts = [];
 89580:   this.threadActor = aThreadActor;
100190:   this.location = aLocation;
 89580: }
 89580: 
 89580: BreakpointActor.prototype = {
 89580:   actorPrefix: "breakpoint",
 89580: 
 89581:   /**
100190:    * Called when this same breakpoint is added to another Debugger.Script
100190:    * instance, in the case of a page reload.
100190:    *
100190:    * @param aScript Debugger.Script
100190:    *        The new source script on which the breakpoint has been set.
100190:    * @param ThreadActor aThreadActor
100190:    *        The parent thread actor that contains this breakpoint.
100190:    */
169591:   addScript: function (aScript, aThreadActor) {
100190:     this.threadActor = aThreadActor;
100190:     this.scripts.push(aScript);
100190:   },
100190: 
100190:   /**
142765:    * Remove the breakpoints from associated scripts and clear the script cache.
142765:    */
142765:   removeScripts: function () {
142765:     for (let script of this.scripts) {
142765:       script.clearBreakpoint(this);
142765:     }
142765:     this.scripts = [];
142765:   },
142765: 
142765:   /**
 89581:    * A function that the engine calls when a breakpoint has been hit.
 89581:    *
 89581:    * @param aFrame Debugger.Frame
 89581:    *        The stack frame that contained the breakpoint.
 89581:    */
169591:   hit: function (aFrame) {
152471:     // Don't pause if we are currently stepping (in or over) or the frame is
152471:     // black-boxed.
156845:     let { url } = this.threadActor.synchronize(
157986:       this.threadActor.sources.getOriginalLocation({
157986:         url: this.location.url,
157986:         line: this.location.line,
157986:         column: this.location.column
157986:       }));
156845: 
156845:     if (this.threadActor.sources.isBlackBoxed(url) || aFrame.onStep) {
147124:       return undefined;
147124:     }
147124: 
152472:     let reason = {};
152472:     if (this.threadActor._hiddenBreakpoints.has(this.actorID)) {
152472:       reason.type = "pauseOnDOMEvents";
152472:     } else {
152472:       reason.type = "breakpoint";
 93468:       // TODO: add the rest of the breakpoints on that line (bug 676602).
152472:       reason.actors = [ this.actorID ];
152472:     }
153128:     return this.threadActor._pauseAndRespond(aFrame, reason);
 89580:   },
 89580: 
 89581:   /**
 89581:    * Handle a protocol request to remove this breakpoint.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89581:    */
169591:   onDelete: function (aRequest) {
100190:     // Remove from the breakpoint store.
153128:     this.threadActor.breakpointStore.removeBreakpoint(this.location);
174909:     this.threadActor.threadLifetimePool.removeActor(this);
142765:     // Remove the actual breakpoint from the associated scripts.
142765:     this.removeScripts();
 89580:     return { from: this.actorID };
 89580:   }
 89580: };
 89580: 
 89580: BreakpointActor.prototype.requestTypes = {
 89580:   "delete": BreakpointActor.prototype.onDelete
 89580: };
 89580: 
 89580: 
 89580: /**
 89580:  * Creates an EnvironmentActor. EnvironmentActors are responsible for listing
 89580:  * the bindings introduced by a lexical environment and assigning new values to
 89580:  * those identifier bindings.
 89581:  *
 97625:  * @param Debugger.Environment aEnvironment
 97625:  *        The lexical environment that will be used to create the actor.
 89580:  * @param ThreadActor aThreadActor
 89580:  *        The parent thread actor that contains this environment.
 89580:  */
 97625: function EnvironmentActor(aEnvironment, aThreadActor)
 89580: {
 97625:   this.obj = aEnvironment;
 89580:   this.threadActor = aThreadActor;
 89580: }
 89580: 
 89580: EnvironmentActor.prototype = {
 89580:   actorPrefix: "environment",
 89580: 
 89581:   /**
129487:    * Return an environment form for use in a protocol message.
 89581:    */
169591:   form: function () {
129487:     let form = { actor: this.actorID };
129487: 
129487:     // What is this environment's type?
129487:     if (this.obj.type == "declarative") {
129487:       form.type = this.obj.callee ? "function" : "block";
129487:     } else {
129487:       form.type = this.obj.type;
 89580:     }
 89580: 
129487:     // Does this environment have a parent?
 97625:     if (this.obj.parent) {
129487:       form.parent = (this.threadActor
129487:                      .createEnvironmentActor(this.obj.parent,
129487:                                              this.registeredPool)
129487:                      .form());
 89580:     }
129487: 
129487:     // Does this environment reflect the properties of an object as variables?
129487:     if (this.obj.type == "object" || this.obj.type == "with") {
129487:       form.object = this.threadActor.createValueGrip(this.obj.object);
 99757:     }
 89580: 
129487:     // Is this the environment created for a function call?
129487:     if (this.obj.callee) {
129487:       form.function = this.threadActor.createValueGrip(this.obj.callee);
 89580:     }
129487: 
129487:     // Shall we list this environment's bindings?
129487:     if (this.obj.type == "declarative") {
129487:       form.bindings = this._bindings();
 89580:     }
 89580: 
 92194:     return form;
 89580:   },
 89580: 
 89580:   /**
 89580:    * Return the identifier bindings object as required by the remote protocol
129487:    * specification.
 89580:    */
169591:   _bindings: function () {
 92194:     let bindings = { arguments: [], variables: {} };
 89580: 
 97625:     // TODO: this part should be removed in favor of the commented-out part
 97625:     // below when getVariableDescriptor lands (bug 725815).
 97625:     if (typeof this.obj.getVariable != "function") {
 97625:     //if (typeof this.obj.getVariableDescriptor != "function") {
 89580:       return bindings;
 89580:     }
 89580: 
 97625:     let parameterNames;
129487:     if (this.obj.callee) {
129487:       parameterNames = this.obj.callee.parameterNames;
 97625:     }
 97625:     for each (let name in parameterNames) {
 92194:       let arg = {};
 97625:       // TODO: this part should be removed in favor of the commented-out part
 97625:       // below when getVariableDescriptor lands (bug 725815).
 97625:       let desc = {
 97625:         value: this.obj.getVariable(name),
 97625:         configurable: false,
 97625:         writable: true,
 97625:         enumerable: true
 97625:       };
 97625: 
 97625:       // let desc = this.obj.getVariableDescriptor(name);
 92194:       let descForm = {
 92194:         enumerable: true,
 92194:         configurable: desc.configurable
 92194:       };
 92194:       if ("value" in desc) {
 92194:         descForm.value = this.threadActor.createValueGrip(desc.value);
 92194:         descForm.writable = desc.writable;
 92194:       } else {
 92194:         descForm.get = this.threadActor.createValueGrip(desc.get);
 92194:         descForm.set = this.threadActor.createValueGrip(desc.set);
 92194:       }
 92194:       arg[name] = descForm;
 92194:       bindings.arguments.push(arg);
 92194:     }
 92194: 
 97625:     for each (let name in this.obj.names()) {
 92194:       if (bindings.arguments.some(function exists(element) {
 92194:                                     return !!element[name];
 92194:                                   })) {
 92194:         continue;
 92194:       }
 92194: 
 97625:       // TODO: this part should be removed in favor of the commented-out part
 97625:       // below when getVariableDescriptor lands.
 97625:       let desc = {
 97625:         configurable: false,
 97625:         writable: true,
 97625:         enumerable: true
 97625:       };
101616:       try {
101616:         desc.value = this.obj.getVariable(name);
101616:       } catch (e) {
101616:         // Avoid "Debugger scope is not live" errors for |arguments|, introduced
101616:         // in bug 746601.
101616:         if (name != "arguments") {
101616:           throw e;
101616:         }
101616:       }
 97625:       //let desc = this.obj.getVariableDescriptor(name);
 92194:       let descForm = {
 92194:         enumerable: true,
 92194:         configurable: desc.configurable
 92194:       };
 92194:       if ("value" in desc) {
 92194:         descForm.value = this.threadActor.createValueGrip(desc.value);
 92194:         descForm.writable = desc.writable;
 89580:       } else {
 92194:         descForm.get = this.threadActor.createValueGrip(desc.get);
 92194:         descForm.set = this.threadActor.createValueGrip(desc.set);
 89580:       }
 92194:       bindings.variables[name] = descForm;
 89580:     }
 89580: 
 89580:     return bindings;
 89580:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to change the value of a variable bound in this
 89580:    * lexical environment.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onAssign: function (aRequest) {
 99518:     // TODO: enable the commented-out part when getVariableDescriptor lands
 99518:     // (bug 725815).
 99518:     /*let desc = this.obj.getVariableDescriptor(aRequest.name);
 89580: 
 89580:     if (!desc.writable) {
 89580:       return { error: "immutableBinding",
 89580:                message: "Changing the value of an immutable binding is not " +
 89580:                         "allowed" };
 99518:     }*/
 89580: 
 89580:     try {
 97625:       this.obj.setVariable(aRequest.name, aRequest.value);
164230:     } catch (e if e instanceof Debugger.DebuggeeWouldRun) {
 92194:         return { error: "threadWouldRun",
 92194:                  cause: e.cause ? e.cause : "setter",
 92194:                  message: "Assigning a value would cause the debuggee to run" };
 89580:     }
 89580:     return { from: this.actorID };
 89580:   },
 89580: 
 89580:   /**
 89580:    * Handle a protocol request to fully enumerate the bindings introduced by the
 89580:    * lexical environment.
 89581:    *
 89581:    * @param aRequest object
 89581:    *        The protocol request object.
 89580:    */
169591:   onBindings: function (aRequest) {
 89580:     return { from: this.actorID,
 89580:              bindings: this._bindings() };
 89580:   }
 89580: };
 89580: 
 89580: EnvironmentActor.prototype.requestTypes = {
 89580:   "assign": EnvironmentActor.prototype.onAssign,
 89580:   "bindings": EnvironmentActor.prototype.onBindings
 89580: };
 99757: 
 99757: /**
122255:  * Override the toString method in order to get more meaningful script output
122255:  * for debugging the debugger.
122255:  */
122255: Debugger.Script.prototype.toString = function() {
122255:   let output = "";
122255:   if (this.url) {
122255:     output += this.url;
122255:   }
122255:   if (typeof this.startLine != "undefined") {
122255:     output += ":" + this.startLine;
122255:     if (this.lineCount && this.lineCount > 1) {
122255:       output += "-" + (this.startLine + this.lineCount - 1);
122255:     }
122255:   }
122255:   if (this.strictMode) {
122255:     output += ":strict";
122255:   }
122255:   return output;
122255: };
122255: 
122255: /**
122255:  * Helper property for quickly getting to the line number a stack frame is
122255:  * currently paused at.
122255:  */
122255: Object.defineProperty(Debugger.Frame.prototype, "line", {
122255:   configurable: true,
122255:   get: function() {
122255:     if (this.script) {
122255:       return this.script.getOffsetLine(this.offset);
122255:     } else {
122255:       return null;
122255:     }
122255:   }
122255: });
122255: 
120758: 
120758: /**
120758:  * Creates an actor for handling chrome debugging. ChromeDebuggerActor is a
120758:  * thin wrapper over ThreadActor, slightly changing some of its behavior.
120758:  *
146017:  * @param aConnection object
146017:  *        The DebuggerServerConnection with which this ChromeDebuggerActor
146017:  *        is associated. (Currently unused, but required to make this
146017:  *        constructor usable with addGlobalActor.)
146017:  *
120758:  * @param aHooks object
120758:  *        An object with preNest and postNest methods for calling when entering
174909:  *        and exiting a nested event loop.
120758:  */
146017: function ChromeDebuggerActor(aConnection, aHooks)
120758: {
120758:   ThreadActor.call(this, aHooks);
120758: }
120758: 
120758: ChromeDebuggerActor.prototype = Object.create(ThreadActor.prototype);
120758: 
120758: update(ChromeDebuggerActor.prototype, {
120758:   constructor: ChromeDebuggerActor,
120758: 
120758:   // A constant prefix that will be used to form the actor ID by the server.
120758:   actorPrefix: "chromeDebugger",
120758: 
120758:   /**
134823:    * Override the eligibility check for scripts and sources to make sure every
134823:    * script and source with a URL is stored when debugging chrome.
120758:    */
134823:   _allowSource: function(aSourceURL) !!aSourceURL,
120758: 
120758:    /**
120758:    * An object that will be used by ThreadActors to tailor their behavior
120758:    * depending on the debugging context being required (chrome or content).
120758:    * The methods that this object provides must be bound to the ThreadActor
120758:    * before use.
120758:    */
120758:   globalManager: {
169591:     findGlobals: function () {
127450:       // Add every global known to the debugger as debuggee.
127450:       this.dbg.addAllGlobalsAsDebuggees();
120758:     },
120758: 
120758:     /**
120758:      * A function that the engine calls when a new global object has been
120758:      * created.
120758:      *
120758:      * @param aGlobal Debugger.Object
120758:      *        The new global object that was created.
120758:      */
169591:     onNewGlobal: function (aGlobal) {
120758:       this.addDebuggee(aGlobal);
120758:       // Notify the client.
120758:       this.conn.send({
120758:         from: this.actorID,
120758:         type: "newGlobal",
120758:         // TODO: after bug 801084 lands see if we need to JSONify this.
120758:         hostAnnotations: aGlobal.hostAnnotations
120758:       });
120758:     }
120758:   }
120758: });
120758: 
120758: 
140693: /**
140693:  * Manages the sources for a thread. Handles source maps, locations in the
140693:  * sources, etc for ThreadActors.
140693:  */
147124: function ThreadSources(aThreadActor, aUseSourceMaps, aAllowPredicate,
147124:                        aOnNewSource) {
140693:   this._thread = aThreadActor;
140693:   this._useSourceMaps = aUseSourceMaps;
140693:   this._allow = aAllowPredicate;
140693:   this._onNewSource = aOnNewSource;
140693: 
140693:   // generated source url --> promise of SourceMapConsumer
140693:   this._sourceMapsByGeneratedSource = Object.create(null);
140693:   // original source url --> promise of SourceMapConsumer
140693:   this._sourceMapsByOriginalSource = Object.create(null);
140693:   // source url --> SourceActor
140693:   this._sourceActors = Object.create(null);
140693:   // original url --> generated url
140693:   this._generatedUrlsByOriginalUrl = Object.create(null);
140693: }
140693: 
147124: /**
147124:  * Must be a class property because it needs to persist across reloads, same as
147124:  * the breakpoint store.
147124:  */
171902: ThreadSources._blackBoxedSources = new Set(["self-hosted"]);
166323: ThreadSources._prettyPrintedSources = new Map();
147124: 
140693: ThreadSources.prototype = {
140693:   /**
160799:    * Return the source actor representing |url|, creating one if none
160799:    * exists already. Returns null if |url| is not allowed by the 'allow'
146542:    * predicate.
140693:    *
140693:    * Right now this takes a URL, but in the future it should
140693:    * take a Debugger.Source. See bug 637572.
140693:    *
160799:    * @param String url
144757:    *        The source URL.
160799:    * @param optional SourceMapConsumer sourceMap
146542:    *        The source map that introduced this source, if any.
160799:    * @param optional String generatedSource
160508:    *        The generated source url that introduced this source via source map,
160508:    *        if any.
160799:    * @param optional String text
160799:    *        The text content of the source, if immediately available.
160799:    * @param optional String contentType
160799:    *        The content type of the source, if immediately available.
146542:    * @returns a SourceActor representing the source at aURL or null.
140693:    */
169591:   source: function ({ url, sourceMap, generatedSource, text, contentType }) {
160799:     if (!this._allow(url)) {
140693:       return null;
140693:     }
140693: 
160799:     if (url in this._sourceActors) {
160799:       return this._sourceActors[url];
160799:     }
160799: 
160799:     let actor = new SourceActor({
160799:       url: url,
160799:       thread: this._thread,
160799:       sourceMap: sourceMap,
160799:       generatedSource: generatedSource,
160799:       text: text,
160799:       contentType: contentType
160799:     });
140693:     this._thread.threadLifetimePool.addActor(actor);
160799:     this._sourceActors[url] = actor;
140693:     try {
140693:       this._onNewSource(actor);
140693:     } catch (e) {
140693:       reportError(e);
140693:     }
140693:     return actor;
140693:   },
140693: 
140693:   /**
160799:    * Only to be used when we aren't source mapping.
160799:    */
169591:   _sourceForScript: function (aScript) {
160799:     const spec = {
160799:       url: aScript.url
160799:     };
160799: 
160799:     // XXX bug 915433: We can't rely on Debugger.Source.prototype.text if the
160799:     // source is an HTML-embedded <script> tag. Since we don't have an API
160799:     // implemented to detect whether this is the case, we need to be
160799:     // conservative and only use Debugger.Source.prototype.text if we get a
160799:     // normal .js file.
160799:     if (aScript.url) {
160799:       try {
160799:         const url = Services.io.newURI(aScript.url, null, null)
160799:           .QueryInterface(Ci.nsIURL);
160799:         if (url.fileExtension === "js") {
160799:           spec.contentType = "text/javascript";
160799:           spec.text = aScript.source.text;
160799:         }
160799:       } catch(ex) {
160799:         // Not a valid URI.
160799:       }
160799:     }
160799: 
160799:     return this.source(spec);
160799:   },
160799: 
160799:   /**
146542:    * Return a promise of an array of source actors representing all the
146542:    * sources of |aScript|.
146542:    *
146542:    * If source map handling is enabled and |aScript| has a source map, then
146542:    * use it to find all of |aScript|'s *original* sources; return a promise
146542:    * of an array of source actors for those.
140693:    */
169591:   sourcesForScript: function (aScript) {
140693:     if (!this._useSourceMaps || !aScript.sourceMapURL) {
160799:       return resolve([this._sourceForScript(aScript)].filter(isNotNull));
140693:     }
140693: 
140693:     return this.sourceMap(aScript)
140693:       .then((aSourceMap) => {
140693:         return [
160799:           this.source({ url: s,
160799:                         sourceMap: aSourceMap,
160799:                         generatedSource: aScript.url })
160799:           for (s of aSourceMap.sources)
140693:         ];
148149:       })
148149:       .then(null, (e) => {
140693:         reportError(e);
140693:         delete this._sourceMapsByGeneratedSource[aScript.url];
160799:         return [this._sourceForScript(aScript)];
140693:       })
160799:       .then(ss => ss.filter(isNotNull));
140693:   },
140693: 
140693:   /**
146542:    * Return a promise of a SourceMapConsumer for the source map for
146542:    * |aScript|; if we already have such a promise extant, return that.
146542:    * |aScript| must have a non-null sourceMapURL.
140693:    */
169591:   sourceMap: function (aScript) {
152472:     dbg_assert(aScript.sourceMapURL, "Script should have a sourceMapURL");
146542:     let sourceMapURL = this._normalize(aScript.sourceMapURL, aScript.url);
153417:     let map = this._fetchSourceMap(sourceMapURL, aScript.url)
160508:       .then(aSourceMap => this.saveSourceMap(aSourceMap, aScript.url));
140693:     this._sourceMapsByGeneratedSource[aScript.url] = map;
140693:     return map;
140693:   },
140693: 
140693:   /**
160508:    * Save the given source map so that we can use it to query source locations
160508:    * down the line.
160508:    */
169591:   saveSourceMap: function (aSourceMap, aGeneratedSource) {
166323:     if (!aSourceMap) {
166323:       delete this._sourceMapsByGeneratedSource[aGeneratedSource];
166323:       return null;
166323:     }
160508:     this._sourceMapsByGeneratedSource[aGeneratedSource] = resolve(aSourceMap);
160508:     for (let s of aSourceMap.sources) {
160508:       this._generatedUrlsByOriginalUrl[s] = aGeneratedSource;
160508:       this._sourceMapsByOriginalSource[s] = resolve(aSourceMap);
160508:     }
160508:     return aSourceMap;
160508:   },
160508: 
160508:   /**
146542:    * Return a promise of a SourceMapConsumer for the source map located at
146542:    * |aAbsSourceMapURL|, which must be absolute. If there is already such a
146542:    * promise extant, return it.
153417:    *
153417:    * @param string aAbsSourceMapURL
153417:    *        The source map URL, in absolute form, not relative.
153417:    * @param string aScriptURL
153417:    *        When the source map URL is a data URI, there is no sourceRoot on the
153417:    *        source map, and the source map's sources are relative, we resolve
153417:    *        them from aScriptURL.
140693:    */
169591:   _fetchSourceMap: function (aAbsSourceMapURL, aScriptURL) {
159532:     return fetch(aAbsSourceMapURL, { loadFromCache: false })
159532:       .then(({ content }) => {
157976:         let map = new SourceMapConsumer(content);
153417:         this._setSourceMapRoot(map, aAbsSourceMapURL, aScriptURL);
140694:         return map;
140693:       });
153417:   },
153417: 
153417:   /**
153417:    * Sets the source map's sourceRoot to be relative to the source map url.
153417:    */
169591:   _setSourceMapRoot: function (aSourceMap, aAbsSourceMapURL, aScriptURL) {
153417:     const base = this._dirname(
153417:       aAbsSourceMapURL.indexOf("data:") === 0
153417:         ? aScriptURL
153417:         : aAbsSourceMapURL);
153417:     aSourceMap.sourceRoot = aSourceMap.sourceRoot
153417:       ? this._normalize(aSourceMap.sourceRoot, base)
153417:       : base;
153417:   },
153417: 
169591:   _dirname: function (aPath) {
153417:     return Services.io.newURI(
153417:       ".", null, Services.io.newURI(aPath, null, null)).spec;
140693:   },
140693: 
140693:   /**
146542:    * Returns a promise of the location in the original source if the source is
140693:    * source mapped, otherwise a promise of the same location.
140693:    */
169591:   getOriginalLocation: function ({ url, line, column }) {
157986:     if (url in this._sourceMapsByGeneratedSource) {
157986:       return this._sourceMapsByGeneratedSource[url]
157986:         .then((aSourceMap) => {
157986:           let { source: aSourceURL, line: aLine, column: aColumn } = aSourceMap.originalPositionFor({
157986:             line: line,
157986:             column: column
157986:           });
157986:           return {
157986:             url: aSourceURL,
140693:             line: aLine,
153128:             column: aColumn
157986:           };
166834:         })
166834:         .then(null, error => {
166834:           if (!DevToolsUtils.reportingDisabled) {
166834:             DevToolsUtils.reportException(error);
166834:           }
166834:           return { url: null, line: null, column: null };
140693:         });
157986:     }
157986: 
157986:     // No source map
157986:     return resolve({
157986:       url: url,
153128:       line: line,
153128:       column: column
140693:     });
140693:   },
140693: 
140693:   /**
140693:    * Returns a promise of the location in the generated source corresponding to
140693:    * the original source and line given.
140693:    *
146542:    * When we pass a script S representing generated code to |sourceMap|,
146542:    * above, that returns a promise P. The process of resolving P populates
146542:    * the tables this function uses; thus, it won't know that S's original
146542:    * source URLs map to S until P is resolved.
140693:    */
169591:   getGeneratedLocation: function ({ url, line, column }) {
157986:     if (url in this._sourceMapsByOriginalSource) {
157986:       return this._sourceMapsByOriginalSource[url]
140693:         .then((aSourceMap) => {
157986:           let { line: aLine, column: aColumn } = aSourceMap.generatedPositionFor({
157986:             source: url,
157986:             line: line,
157986:             column: column == null ? Infinity : column
140693:           });
140693:           return {
157986:             url: this._generatedUrlsByOriginalUrl[url],
157986:             line: aLine,
157986:             column: aColumn
157986:           };
157986:         });
157986:     }
157986: 
157986:     // No source map
157986:     return resolve({
157986:       url: url,
153128:       line: line,
153128:       column: column
140693:     });
140693:   },
140693: 
140694:   /**
147124:    * Returns true if URL for the given source is black boxed.
147124:    *
147124:    * @param aURL String
147124:    *        The URL of the source which we are checking whether it is black
147124:    *        boxed or not.
147124:    */
169591:   isBlackBoxed: function (aURL) {
147124:     return ThreadSources._blackBoxedSources.has(aURL);
147124:   },
147124: 
147124:   /**
166323:    * Add the given source URL to the set of sources that are black boxed.
147124:    *
147124:    * @param aURL String
147124:    *        The URL of the source which we are black boxing.
147124:    */
169591:   blackBox: function (aURL) {
147124:     ThreadSources._blackBoxedSources.add(aURL);
147124:   },
147124: 
147124:   /**
147124:    * Remove the given source URL to the set of sources that are black boxed.
147124:    *
147124:    * @param aURL String
147124:    *        The URL of the source which we are no longer black boxing.
147124:    */
169591:   unblackBox: function (aURL) {
147124:     ThreadSources._blackBoxedSources.delete(aURL);
147124:   },
147124: 
147124:   /**
166323:    * Returns true if the given URL is pretty printed.
166323:    *
166323:    * @param aURL String
166323:    *        The URL of the source that might be pretty printed.
166323:    */
169591:   isPrettyPrinted: function (aURL) {
166323:     return ThreadSources._prettyPrintedSources.has(aURL);
166323:   },
166323: 
166323:   /**
166323:    * Add the given URL to the set of sources that are pretty printed.
166323:    *
166323:    * @param aURL String
166323:    *        The URL of the source to be pretty printed.
166323:    */
169591:   prettyPrint: function (aURL, aIndent) {
166323:     ThreadSources._prettyPrintedSources.set(aURL, aIndent);
166323:   },
166323: 
166323:   /**
166323:    * Return the indent the given URL was pretty printed by.
166323:    */
169591:   prettyPrintIndent: function (aURL) {
166323:     return ThreadSources._prettyPrintedSources.get(aURL);
166323:   },
166323: 
166323:   /**
166323:    * Remove the given URL from the set of sources that are pretty printed.
166323:    *
166323:    * @param aURL String
166323:    *        The URL of the source that is no longer pretty printed.
166323:    */
169591:   disablePrettyPrint: function (aURL) {
166323:     ThreadSources._prettyPrintedSources.delete(aURL);
166323:   },
166323: 
166323:   /**
140694:    * Normalize multiple relative paths towards the base paths on the right.
140694:    */
169591:   _normalize: function (...aURLs) {
152472:     dbg_assert(aURLs.length > 1, "Should have more than 1 URL");
140694:     let base = Services.io.newURI(aURLs.pop(), null, null);
140694:     let url;
140694:     while ((url = aURLs.pop())) {
140694:       base = Services.io.newURI(url, null, base);
140694:     }
140694:     return base.spec;
140694:   },
140694: 
169591:   iter: function () {
140693:     for (let url in this._sourceActors) {
140693:       yield this._sourceActors[url];
140693:     }
140693:   }
140693: };
140693: 
120758: // Utility functions.
120758: 
153128: // TODO bug 863089: use Debugger.Script.prototype.getOffsetColumn when it is
153128: // implemented.
153128: function getOffsetColumn(aOffset, aScript) {
153128:   let bestOffsetMapping = null;
153128:   for (let offsetMapping of aScript.getAllColumnOffsets()) {
153128:     if (!bestOffsetMapping ||
153128:         (offsetMapping.offset <= aOffset &&
153128:          offsetMapping.offset > bestOffsetMapping.offset)) {
153128:       bestOffsetMapping = offsetMapping;
153128:     }
153128:   }
153128: 
153128:   if (!bestOffsetMapping) {
153128:     // XXX: Try not to completely break the experience of using the debugger for
153128:     // the user by assuming column 0. Simultaneously, report the error so that
153128:     // there is a paper trail if the assumption is bad and the debugging
153128:     // experience becomes wonky.
153128:     reportError(new Error("Could not find a column for offset " + aOffset
153128:                           + " in the script " + aScript));
153128:     return 0;
153128:   }
153128: 
153128:   return bestOffsetMapping.columnNumber;
153128: }
153128: 
120758: /**
159727:  * Return the non-source-mapped location of the given Debugger.Frame. If the
159727:  * frame does not have a script, the location's properties are all null.
159727:  *
159727:  * @param Debugger.Frame aFrame
159727:  *        The frame whose location we are getting.
159727:  * @returns Object
159727:  *          Returns an object of the form { url, line, column }
159727:  */
159727: function getFrameLocation(aFrame) {
165285:   if (!aFrame || !aFrame.script) {
159727:     return { url: null, line: null, column: null };
159727:   }
159727:   return {
159727:     url: aFrame.script.url,
159727:     line: aFrame.script.getOffsetLine(aFrame.offset),
159727:     column: getOffsetColumn(aFrame.offset, aFrame.script)
159727:   }
159727: }
159727: 
159727: /**
120758:  * Utility function for updating an object with the properties of another
120758:  * object.
120758:  *
120758:  * @param aTarget Object
120758:  *        The object being updated.
120758:  * @param aNewAttrs Object
120758:  *        The new attributes being set on the target.
120758:  */
120758: function update(aTarget, aNewAttrs) {
120758:   for (let key in aNewAttrs) {
120758:     let desc = Object.getOwnPropertyDescriptor(aNewAttrs, key);
120758: 
120758:     if (desc) {
120758:       Object.defineProperty(aTarget, key, desc);
120758:     }
120758:   }
120758: }
140693: 
140693: /**
140693:  * Returns true if its argument is not null.
140693:  */
140693: function isNotNull(aThing) {
140693:   return aThing !== null;
140693: }
140693: 
140693: /**
140693:  * Performs a request to load the desired URL and returns a promise.
140693:  *
140693:  * @param aURL String
140693:  *        The URL we will request.
140693:  * @returns Promise
146542:  *        A promise of the document at that URL, as a string.
140693:  *
140693:  * XXX: It may be better to use nsITraceableChannel to get to the sources
140693:  * without relying on caching when we can (not for eval, etc.):
140693:  * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
140693:  */
144758: function fetch(aURL, aOptions={ loadFromCache: true }) {
140693:   let deferred = defer();
140693:   let scheme;
140693:   let url = aURL.split(" -> ").pop();
140693:   let charset;
157976:   let contentType;
140693: 
140693:   try {
140693:     scheme = Services.io.extractScheme(url);
140693:   } catch (e) {
140693:     // In the xpcshell tests, the script url is the absolute path of the test
140693:     // file, which will make a malformed URI error be thrown. Add the file
140693:     // scheme prefix ourselves.
140693:     url = "file://" + url;
140693:     scheme = Services.io.extractScheme(url);
140693:   }
140693: 
140693:   switch (scheme) {
140693:     case "file":
140693:     case "chrome":
140693:     case "resource":
140693:       try {
157976:         NetUtil.asyncFetch(url, function onFetch(aStream, aStatus, aRequest) {
140693:           if (!Components.isSuccessCode(aStatus)) {
159531:             deferred.reject(new Error("Request failed with status code = "
159531:                                       + aStatus
159531:                                       + " after NetUtil.asyncFetch for url = "
159531:                                       + url));
140693:             return;
140693:           }
140693: 
140693:           let source = NetUtil.readInputStreamToString(aStream, aStream.available());
157976:           contentType = aRequest.contentType;
140693:           deferred.resolve(source);
140693:           aStream.close();
140693:         });
140693:       } catch (ex) {
159531:         deferred.reject(ex);
140693:       }
140693:       break;
140693: 
140693:     default:
140693:       let channel;
140693:       try {
140693:         channel = Services.io.newChannel(url, null, null);
140693:       } catch (e if e.name == "NS_ERROR_UNKNOWN_PROTOCOL") {
140693:         // On Windows xpcshell tests, c:/foo/bar can pass as a valid URL, but
140693:         // newChannel won't be able to handle it.
140693:         url = "file:///" + url;
140693:         channel = Services.io.newChannel(url, null, null);
140693:       }
140693:       let chunks = [];
140693:       let streamListener = {
140693:         onStartRequest: function(aRequest, aContext, aStatusCode) {
140693:           if (!Components.isSuccessCode(aStatusCode)) {
159531:             deferred.reject(new Error("Request failed with status code = "
159531:                                       + aStatusCode
159531:                                       + " in onStartRequest handler for url = "
159531:                                       + url));
140693:           }
140693:         },
140693:         onDataAvailable: function(aRequest, aContext, aStream, aOffset, aCount) {
140693:           chunks.push(NetUtil.readInputStreamToString(aStream, aCount));
140693:         },
140693:         onStopRequest: function(aRequest, aContext, aStatusCode) {
140693:           if (!Components.isSuccessCode(aStatusCode)) {
159531:             deferred.reject(new Error("Request failed with status code = "
159531:                                       + aStatusCode
159531:                                       + " in onStopRequest handler for url = "
159531:                                       + url));
140693:             return;
140693:           }
140693: 
140693:           charset = channel.contentCharset;
157976:           contentType = channel.contentType;
140693:           deferred.resolve(chunks.join(""));
140693:         }
140693:       };
140693: 
144758:       channel.loadFlags = aOptions.loadFromCache
144758:         ? channel.LOAD_FROM_CACHE
144758:         : channel.LOAD_BYPASS_CACHE;
140693:       channel.asyncOpen(streamListener, null);
140693:       break;
140693:   }
140693: 
157976:   return deferred.promise.then(source => {
157976:     return {
157976:       content: convertToUnicode(source, charset),
157976:       contentType: contentType
157976:     };
140693:   });
140693: }
140693: 
140693: /**
140693:  * Convert a given string, encoded in a given character set, to unicode.
140693:  *
140693:  * @param string aString
140693:  *        A string.
140693:  * @param string aCharset
140693:  *        A character set.
140693:  */
140693: function convertToUnicode(aString, aCharset=null) {
140693:   // Decoding primitives.
140693:   let converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"]
140693:     .createInstance(Ci.nsIScriptableUnicodeConverter);
140693:   try {
140693:     converter.charset = aCharset || "UTF-8";
140693:     return converter.ConvertToUnicode(aString);
140693:   } catch(e) {
140693:     return aString;
140693:   }
140693: }
140693: 
140693: /**
140693:  * Report the given error in the error console and to stdout.
150655:  *
150655:  * @param Error aError
150655:  *        The error object you wish to report.
150655:  * @param String aPrefix
150655:  *        An optional prefix for the reported error message.
140693:  */
150655: function reportError(aError, aPrefix="") {
151501:   dbg_assert(aError instanceof Error, "Must pass Error objects to reportError");
151214:   let msg = aPrefix + aError.message + ":\n" + aError.stack;
150655:   Cu.reportError(msg);
150655:   dumpn(msg);
140693: }
152472: 
152472: // The following are copied here verbatim from css-logic.js, until we create a
152472: // server-friendly helper module.
152472: 
152472: /**
152472:  * Find a unique CSS selector for a given element
152472:  * @returns a string such that ele.ownerDocument.querySelector(reply) === ele
152472:  * and ele.ownerDocument.querySelectorAll(reply).length === 1
152472:  */
152472: function findCssSelector(ele) {
152472:   var document = ele.ownerDocument;
152472:   if (ele.id && document.getElementById(ele.id) === ele) {
152472:     return '#' + ele.id;
152472:   }
152472: 
152472:   // Inherently unique by tag name
152472:   var tagName = ele.tagName.toLowerCase();
152472:   if (tagName === 'html') {
152472:     return 'html';
152472:   }
152472:   if (tagName === 'head') {
152472:     return 'head';
152472:   }
152472:   if (tagName === 'body') {
152472:     return 'body';
152472:   }
152472: 
152472:   if (ele.parentNode == null) {
152472:     console.log('danger: ' + tagName);
152472:   }
152472: 
152472:   // We might be able to find a unique class name
152472:   var selector, index, matches;
152472:   if (ele.classList.length > 0) {
152472:     for (var i = 0; i < ele.classList.length; i++) {
152472:       // Is this className unique by itself?
152472:       selector = '.' + ele.classList.item(i);
152472:       matches = document.querySelectorAll(selector);
152472:       if (matches.length === 1) {
152472:         return selector;
152472:       }
152472:       // Maybe it's unique with a tag name?
152472:       selector = tagName + selector;
152472:       matches = document.querySelectorAll(selector);
152472:       if (matches.length === 1) {
152472:         return selector;
152472:       }
152472:       // Maybe it's unique using a tag name and nth-child
152472:       index = positionInNodeList(ele, ele.parentNode.children) + 1;
152472:       selector = selector + ':nth-child(' + index + ')';
152472:       matches = document.querySelectorAll(selector);
152472:       if (matches.length === 1) {
152472:         return selector;
152472:       }
152472:     }
152472:   }
152472: 
152472:   // So we can be unique w.r.t. our parent, and use recursion
152472:   index = positionInNodeList(ele, ele.parentNode.children) + 1;
152472:   selector = findCssSelector(ele.parentNode) + ' > ' +
152472:           tagName + ':nth-child(' + index + ')';
152472: 
152472:   return selector;
152472: };
152472: 
152472: /**
152472:  * Find the position of [element] in [nodeList].
152472:  * @returns an index of the match, or -1 if there is no match
152472:  */
152472: function positionInNodeList(element, nodeList) {
152472:   for (var i = 0; i < nodeList.length; i++) {
152472:     if (element === nodeList[i]) {
152472:       return i;
152472:     }
152472:   }
152472:   return -1;
152472: }
178572: 
178572: /**
178572:  * Make a debuggee value for the given object, if needed. Primitive values
178572:  * are left the same.
178572:  *
178572:  * Use case: you have a raw JS object (after unsafe dereference) and you want to
178572:  * send it to the client. In that case you need to use an ObjectActor which
178572:  * requires a debuggee value. The Debugger.Object.prototype.makeDebuggeeValue()
178572:  * method works only for JS objects and functions.
178572:  *
178572:  * @param Debugger.Object obj
178572:  * @param any value
178572:  * @return object
178572:  */
178572: function makeDebuggeeValueIfNeeded(obj, value) {
178572:   if (value && (typeof value == "object" || typeof value == "function")) {
178572:     return obj.makeDebuggeeValue(value);
178572:   }
178572:   return value;
178572: }
