     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsNSSComponent.h"
     1: #include "nsNSSCallbacks.h"
     1: #include "nsNSSIOLayer.h"
     1: #include "nsCertVerificationThread.h"
     1: 
     1: #include "nsNetUtil.h"
     1: #include "nsAppDirectoryServiceDefs.h"
     1: #include "nsDirectoryService.h"
     1: #include "nsIStreamListener.h"
     1: #include "nsIStringBundle.h"
     1: #include "nsIDirectoryService.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsCURILoader.h"
     1: #include "nsDirectoryServiceDefs.h"
     1: #include "nsIX509Cert.h"
     1: #include "nsIX509CertDB.h"
     1: #include "nsIProfileChangeStatus.h"
     1: #include "nsNSSCertificate.h"
     1: #include "nsNSSHelper.h"
     1: #include "nsSmartCardMonitor.h"
     1: #include "prlog.h"
     1: #include "nsIPrefService.h"
     1: #include "nsIPrefBranch.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "nsDateTimeFormatCID.h"
     1: #include "nsIDOMEvent.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMWindow.h"
     1: #include "nsIDOMWindowCollection.h"
     1: #include "nsIDOMSmartCardEvent.h"
     1: #include "nsIDOMCrypto.h"
     1: #include "nsThreadUtils.h"
119832: #include "nsAutoPtr.h"
     1: #include "nsCRT.h"
     1: #include "nsCRLInfo.h"
 20772: #include "nsCertOverrideService.h"
     1: 
     1: #include "nsIWindowWatcher.h"
     1: #include "nsIPrompt.h"
119653: #include "nsCertificatePrincipal.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "prtypes.h"
     1: #include "nsIEntropyCollector.h"
     1: #include "nsIBufEntropyCollector.h"
     1: #include "nsIServiceManager.h"
101111: #include "nsIFile.h"
     1: #include "nsITokenPasswordDialogs.h"
     1: #include "nsICRLManager.h"
     1: #include "nsNSSShutDown.h"
     1: #include "nsSmartCardEvent.h"
 13256: #include "nsIKeyModule.h"
     1: 
     1: #include "nss.h"
     1: #include "pk11func.h"
     1: #include "ssl.h"
     1: #include "sslproto.h"
     1: #include "secmod.h"
     1: #include "sechash.h"
     1: #include "secmime.h"
     1: #include "ocsp.h"
     1: #include "cms.h"
     1: #include "nssckbi.h"
     1: #include "base64.h"
     1: #include "secerr.h"
     1: #include "sslerr.h"
 69383: #include "cert.h"
     1: 
 49227: #include "nsXULAppAPI.h"
 49227: 
 33331: #ifdef XP_WIN
 33331: #include "nsILocalFileWin.h"
 33331: #endif
 33331: 
119832: extern "C" {
     1: #include "pkcs12.h"
     1: #include "p12plcy.h"
119832: }
     1: 
 64576: using namespace mozilla;
 97210: using namespace mozilla::psm;
 64576: 
     1: #ifdef PR_LOGGING
106838: PRLogModuleInfo* gPIPNSSLog = nullptr;
     1: #endif
     1: 
     1: #define NS_CRYPTO_HASH_BUFFER_SIZE 4096
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: int nsNSSComponent::mInstanceCount = 0;
 79445: bool nsNSSComponent::globalConstFlagUsePKIXVerification = false;
     1: 
     1: // XXX tmp callback for slot password
115027: extern char* pk11PasswordPrompt(PK11SlotInfo *slot, PRBool retry, void *arg);
     1: 
     1: #define PIPNSS_STRBUNDLE_URL "chrome://pipnss/locale/pipnss.properties"
  2850: #define NSSERR_STRBUNDLE_URL "chrome://pipnss/locale/nsserrors.properties"
     1: 
115027: static PLHashNumber certHashtable_keyHash(const void *key)
     1: {
     1:   if (!key)
     1:     return 0;
     1:   
     1:   SECItem *certKey = (SECItem*)key;
     1:   
     1:   // lazy hash function, sum up all char values of SECItem
     1:   
     1:   PLHashNumber hash = 0;
     1:   unsigned int i = 0;
     1:   unsigned char *c = certKey->data;
     1:   
     1:   for (i = 0; i < certKey->len; ++i, ++c) {
     1:     hash += *c;
     1:   }
     1:   
     1:   return hash;
     1: }
     1: 
115027: static int certHashtable_keyCompare(const void *k1, const void *k2)
     1: {
     1:   // return type is a bool, answering the question "are the keys equal?"
     1: 
     1:   if (!k1 || !k2)
 80486:     return false;
     1:   
     1:   SECItem *certKey1 = (SECItem*)k1;
     1:   SECItem *certKey2 = (SECItem*)k2;
     1:   
     1:   if (certKey1->len != certKey2->len) {
 80486:     return false;
     1:   }
     1:   
     1:   unsigned int i = 0;
     1:   unsigned char *c1 = certKey1->data;
     1:   unsigned char *c2 = certKey2->data;
     1:   
     1:   for (i = 0; i < certKey1->len; ++i, ++c1, ++c2) {
     1:     if (*c1 != *c2) {
 80486:       return false;
 80486:     }
 80486:   }
 80486:   
 80486:   return true;
     1: }
     1: 
115027: static int certHashtable_valueCompare(const void *v1, const void *v2)
     1: {
     1:   // two values are identical if their keys are identical
     1:   
     1:   if (!v1 || !v2)
 80486:     return false;
     1:   
     1:   CERTCertificate *cert1 = (CERTCertificate*)v1;
     1:   CERTCertificate *cert2 = (CERTCertificate*)v2;
     1:   
     1:   return certHashtable_keyCompare(&cert1->certKey, &cert2->certKey);
     1: }
     1: 
115027: static int certHashtable_clearEntry(PLHashEntry *he, int /*index*/, void * /*userdata*/)
     1: {
     1:   if (he && he->value) {
     1:     CERT_DestroyCertificate((CERTCertificate*)he->value);
     1:   }
     1:   
     1:   return HT_ENUMERATE_NEXT;
     1: }
     1: 
     1: class CRLDownloadEvent : public nsRunnable {
     1: public:
     1:   CRLDownloadEvent(const nsCSubstring &urlString, nsIStreamListener *listener)
     1:     : mURLString(urlString)
     1:     , mListener(listener)
     1:   {}
     1: 
     1:   // Note that nsNSSComponent is a singleton object across all threads, 
     1:   // and automatic downloads are always scheduled sequentially - that is, 
     1:   // once one crl download is complete, the next one is scheduled
     1:   NS_IMETHOD Run()
     1:   {
     1:     if (!mListener || mURLString.IsEmpty())
     1:       return NS_OK;
     1: 
     1:     nsCOMPtr<nsIURI> uri;
     1:     nsresult rv = NS_NewURI(getter_AddRefs(uri), mURLString);
     1:     if (NS_SUCCEEDED(rv)){
106838:       NS_OpenURI(mListener, nullptr, uri);
     1:     }
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1: private:
     1:   nsCString mURLString;
     1:   nsCOMPtr<nsIStreamListener> mListener;
     1: };
     1: 
     1: //This class is used to run the callback code
     1: //passed to the event handlers for smart card notification
     1: class nsTokenEventRunnable : public nsIRunnable {
     1: public:
     1:   nsTokenEventRunnable(const nsAString &aType, const nsAString &aTokenName);
     1:   virtual ~nsTokenEventRunnable();
     1: 
     1:   NS_IMETHOD Run ();
     1:   NS_DECL_ISUPPORTS
     1: private:
     1:   nsString mType;
     1:   nsString mTokenName;
     1: };
     1: 
     1: // ISuuports implementation for nsTokenEventRunnable
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsTokenEventRunnable, nsIRunnable)
     1: 
     1: nsTokenEventRunnable::nsTokenEventRunnable(const nsAString &aType, 
     1:    const nsAString &aTokenName): mType(aType), mTokenName(aTokenName) { }
     1: 
     1: nsTokenEventRunnable::~nsTokenEventRunnable() { }
     1: 
     1: //Implementation that runs the callback passed to 
     1: //crypto.generateCRMFRequest as an event.
     1: NS_IMETHODIMP
     1: nsTokenEventRunnable::Run()
     1: { 
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   return nssComponent->DispatchEvent(mType, mTokenName);
     1: }
     1: 
 79445: bool nsPSMInitPanic::isPanic = false;
 57159: 
 25625: // We must ensure that the nsNSSComponent has been loaded before
 25625: // creating any other components.
 79445: bool EnsureNSSInitialized(EnsureNSSOperator op)
 25625: {
 57159:   if (nsPSMInitPanic::GetPanic())
 80486:     return false;
 57159: 
 56495:   if (GeckoProcessType_Default != XRE_GetProcessType())
 56495:   {
 56495:     if (op == nssEnsureOnChromeOnly)
 56495:     {
 56495:       // If the component needs PSM/NSS initialized only on the chrome process,
 56495:       // pretend we successfully initiated it but in reality we bypass it.
 56495:       // It's up to the programmer to check for process type in such components
 56495:       // and take care not to call anything that needs NSS/PSM initiated.
 80486:       return true;
 56495:     }
 56495: 
 49227:     NS_ERROR("Trying to initialize PSM/NSS in a non-chrome process!");
 80486:     return false;
 49227:   }
 49227: 
 79445:   static bool loading = false;
108991:   static int32_t haveLoaded = 0;
 25625: 
 25625:   switch (op)
 25625:   {
 25625:     // In following 4 cases we are protected by monitor of XPCOM component
 25625:     // manager - we are inside of do_GetService call for nss component, so it is
 25625:     // safe to move with the flags here.
 56495:   case nssLoadingComponent:
 25625:     if (loading)
 80486:       return false; // We are reentered during nss component creation
 80486:     loading = true;
 80486:     return true;
 25625: 
 25625:   case nssInitSucceeded:
 25625:     NS_ASSERTION(loading, "Bad call to EnsureNSSInitialized(nssInitSucceeded)");
 80486:     loading = false;
 30802:     PR_AtomicSet(&haveLoaded, 1);
 80486:     return true;
 25625: 
 25625:   case nssInitFailed:
 25625:     NS_ASSERTION(loading, "Bad call to EnsureNSSInitialized(nssInitFailed)");
 80486:     loading = false;
 25625:     // no break
 25625: 
 25625:   case nssShutdown:
 30802:     PR_AtomicSet(&haveLoaded, 0);
 80486:     return false;
 25625: 
 25625:     // In this case we are called from a component to ensure nss initilization.
 25625:     // If the component has not yet been loaded and is not currently loading
 25625:     // call do_GetService for nss component to ensure it.
 25625:   case nssEnsure:
 56495:   case nssEnsureOnChromeOnly:
 25625:     // We are reentered during nss component creation or nss component is already up
 30802:     if (PR_AtomicAdd(&haveLoaded, 0) || loading)
 80486:       return true;
 25625: 
 25625:     {
 29543:     nsCOMPtr<nsINSSComponent> nssComponent
 25625:       = do_GetService(PSM_COMPONENT_CONTRACTID);
 25625: 
 25625:     // Nss component failed to initialize, inform the caller of that fact.
 25625:     // Flags are appropriately set by component constructor itself.
 25625:     if (!nssComponent)
 80486:       return false;
 25625: 
 79445:     bool isInitialized;
 29543:     nsresult rv = nssComponent->IsNSSInitialized(&isInitialized);
 29543:     return NS_SUCCEEDED(rv) && isInitialized;
 25625:     }
 25625: 
 25625:   default:
 80486:     NS_ASSERTION(false, "Bad operator to EnsureNSSInitialized");
 80486:     return false;
 25625:   }
 25625: }
 25625: 
     1: nsNSSComponent::nsNSSComponent()
 64576:   :mutex("nsNSSComponent.mutex"),
 80486:    mNSSInitialized(false),
 64576:    mCrlTimerLock("nsNSSComponent.mCrlTimerLock"),
106838:    mThreadList(nullptr),
119832:    mCertVerificationThread(NULL)
     1: {
     1: #ifdef PR_LOGGING
     1:   if (!gPIPNSSLog)
     1:     gPIPNSSLog = PR_NewLogModule("pipnss");
     1: #endif
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::ctor\n"));
 80486:   mUpdateTimerInitialized = false;
 80486:   crlDownloadTimerOn = false;
106838:   crlsScheduledForDownload = nullptr;
106838:   mTimer = nullptr;
 80486:   mObserversRegistered = false;
     1: 
  7105:   // In order to keep startup time lower, we delay loading and 
  7105:   // registering all identity data until first needed.
  7105:   memset(&mIdentityInfoCallOnce, 0, sizeof(PRCallOnceType));
  7105: 
     1:   NS_ASSERTION( (0 == mInstanceCount), "nsNSSComponent is a singleton, but instantiated multiple times!");
     1:   ++mInstanceCount;
106838:   hashTableCerts = nullptr;
     1:   mShutdownObjectList = nsNSSShutDownList::construct();
 80486:   mIsNetworkDown = false;
     1: }
     1: 
 72444: void 
 72444: nsNSSComponent::deleteBackgroundThreads()
     1: {
     1:   if (mCertVerificationThread)
     1:   {
     1:     mCertVerificationThread->requestExit();
     1:     delete mCertVerificationThread;
106838:     mCertVerificationThread = nullptr;
     1:   }
 72444: }
 72444: 
 72444: void
 72444: nsNSSComponent::createBackgroundThreads()
 72444: {
119832:   NS_ASSERTION(mCertVerificationThread == nullptr,
 72444:                "Cert verification thread already created.");
 72444: 
 72444:   mCertVerificationThread = new nsCertVerificationThread;
101778:   nsresult rv = mCertVerificationThread->startThread(
101778:     NS_LITERAL_CSTRING("Cert Verify"));
101778: 
 72444:   if (NS_FAILED(rv)) {
 72444:     delete mCertVerificationThread;
106838:     mCertVerificationThread = nullptr;
 72444:   }
 72444: }
 72444: 
 72444: nsNSSComponent::~nsNSSComponent()
 72444: {
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor\n"));
     1: 
 72444:   deleteBackgroundThreads();
 72444: 
 17116:   if (mUpdateTimerInitialized) {
 64576:     {
 64576:       MutexAutoLock lock(mCrlTimerLock);
 17116:       if (crlDownloadTimerOn) {
     1:         mTimer->Cancel();
     1:       }
 80486:       crlDownloadTimerOn = false;
 64576:     }
119832:     if(crlsScheduledForDownload != nullptr){
     1:       crlsScheduledForDownload->Reset();
     1:       delete crlsScheduledForDownload;
     1:     }
     1: 
 80486:     mUpdateTimerInitialized = false;
     1:   }
     1: 
     1:   // All cleanup code requiring services needs to happen in xpcom_shutdown
     1: 
     1:   ShutdownNSS();
     1:   nsSSLIOLayerHelpers::Cleanup();
 97210:   RememberCertErrorsTable::Cleanup();
     1:   --mInstanceCount;
     1:   delete mShutdownObjectList;
     1: 
 25625:   // We are being freed, drop the haveLoaded flag to re-enable
 25625:   // potential nss initialization later.
 25625:   EnsureNSSInitialized(nssShutdown);
 25625: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::dtor finished\n"));
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::PostEvent(const nsAString &eventType, 
     1:                                                   const nsAString &tokenName)
     1: {
     1:   nsCOMPtr<nsIRunnable> runnable = 
     1:                                new nsTokenEventRunnable(eventType, tokenName);
119832:   if (!runnable) {
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832:   }
     1: 
     1:   return NS_DispatchToMainThread(runnable);
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::DispatchEvent(const nsAString &eventType,
     1:                                                  const nsAString &tokenName)
     1: {
     1:   // 'Dispatch' the event to all the windows. 'DispatchEventToWindow()' will
     1:   // first check to see if a given window has requested crypto events.
     1:   nsresult rv;
     1:   nsCOMPtr<nsIWindowWatcher> windowWatcher =
     1:                             do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
     1: 
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   nsCOMPtr<nsISimpleEnumerator> enumerator;
     1:   rv = windowWatcher->GetWindowEnumerator(getter_AddRefs(enumerator));
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
 79445:   bool hasMoreWindows;
     1: 
     1:   while (NS_SUCCEEDED(enumerator->HasMoreElements(&hasMoreWindows))
     1:          && hasMoreWindows) {
     1:     nsCOMPtr<nsISupports> supports;
     1:     enumerator->GetNext(getter_AddRefs(supports));
     1:     nsCOMPtr<nsIDOMWindow> domWin(do_QueryInterface(supports));
     1:     if (domWin) {
     1:       nsresult rv2 = DispatchEventToWindow(domWin, eventType, tokenName);
     1:       if (NS_FAILED(rv2)) {
     1:         // return the last failure, don't let a single failure prevent
     1:         // continued delivery of events.
     1:         rv = rv2;
     1:       }
     1:     }
     1:   }
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::DispatchEventToWindow(nsIDOMWindow *domWin,
     1:                       const nsAString &eventType, const nsAString &tokenName)
     1: {
     1:   // first walk the children and dispatch their events 
     1:   {
     1:     nsresult rv;
     1:     nsCOMPtr<nsIDOMWindowCollection> frames;
     1:     rv = domWin->GetFrames(getter_AddRefs(frames));
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
     1: 
108991:     uint32_t length;
     1:     frames->GetLength(&length);
108991:     uint32_t i;
     1:     for (i = 0; i < length; i++) {
     1:       nsCOMPtr<nsIDOMWindow> childWin;
     1:       frames->Item(i, getter_AddRefs(childWin));
     1:       DispatchEventToWindow(childWin, eventType, tokenName);
     1:     }
     1:   }
     1: 
     1:   // check if we've enabled smart card events on this window
     1:   // NOTE: it's not an error to say that we aren't going to dispatch
     1:   // the event.
     1:   {
 73870:     nsCOMPtr<nsIDOMWindow> domWindow = domWin;
 73870:     if (!domWindow) {
     1:       return NS_OK; // nope, it's not an internal window
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMCrypto> crypto;
 73870:     domWindow->GetCrypto(getter_AddRefs(crypto));
     1:     if (!crypto) {
     1:       return NS_OK; // nope, it doesn't have a crypto property
     1:     }
     1: 
 79445:     bool boolrv;
     1:     crypto->GetEnableSmartCardEvents(&boolrv);
     1:     if (!boolrv) {
     1:       return NS_OK; // nope, it's not enabled.
     1:     }
     1:   }
     1: 
     1:   // dispatch the event ...
     1: 
     1:   nsresult rv;
     1:   // find the document
     1:   nsCOMPtr<nsIDOMDocument> doc;
     1:   rv = domWin->GetDocument(getter_AddRefs(doc));
119832:   if (doc == nullptr) {
     1:     return NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // create the event
     1:   nsCOMPtr<nsIDOMEvent> event;
 70359:   rv = doc->CreateEvent(NS_LITERAL_STRING("Events"), 
     1:                         getter_AddRefs(event));
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   event->InitEvent(eventType, false, true);
     1: 
     1:   // create the Smart Card Event;
     1:   nsCOMPtr<nsIDOMSmartCardEvent> smartCardEvent = 
     1:                                           new nsSmartCardEvent(tokenName);
     1:   // init the smart card event, fail here if we can't complete the 
     1:   // initialization.
119832:   if (!smartCardEvent) {
119832:     return NS_ERROR_OUT_OF_MEMORY;
119832:   }
119832: 
     1:   rv = smartCardEvent->Init(event);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
     1:   // Send it 
     1:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(doc, &rv);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
 79445:   bool boolrv;
     1:   rv = target->DispatchEvent(smartCardEvent, &boolrv);
     1:   return rv;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::PIPBundleFormatStringFromName(const char *name,
     1:                                               const PRUnichar **params,
108991:                                               uint32_t numParams,
     1:                                               nsAString &outString)
     1: {
     1:   nsresult rv = NS_ERROR_FAILURE;
     1: 
     1:   if (mPIPNSSBundle && name) {
     1:     nsXPIDLString result;
     1:     rv = mPIPNSSBundle->FormatStringFromName(NS_ConvertASCIItoUTF16(name).get(),
     1:                                              params, numParams,
     1:                                              getter_Copies(result));
     1:     if (NS_SUCCEEDED(rv)) {
     1:       outString = result;
     1:     }
     1:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::GetPIPNSSBundleString(const char *name,
     1:                                       nsAString &outString)
     1: {
     1:   nsresult rv = NS_ERROR_FAILURE;
     1: 
     1:   outString.SetLength(0);
     1:   if (mPIPNSSBundle && name) {
     1:     nsXPIDLString result;
     1:     rv = mPIPNSSBundle->GetStringFromName(NS_ConvertASCIItoUTF16(name).get(),
     1:                                           getter_Copies(result));
     1:     if (NS_SUCCEEDED(rv)) {
     1:       outString = result;
     1:       rv = NS_OK;
     1:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
  2850: NS_IMETHODIMP
  2850: nsNSSComponent::NSSBundleFormatStringFromName(const char *name,
  2850:                                               const PRUnichar **params,
108991:                                               uint32_t numParams,
  2850:                                               nsAString &outString)
  2850: {
  2850:   nsresult rv = NS_ERROR_FAILURE;
  2850: 
  2850:   if (mNSSErrorsBundle && name) {
  2850:     nsXPIDLString result;
  2850:     rv = mNSSErrorsBundle->FormatStringFromName(NS_ConvertASCIItoUTF16(name).get(),
  2850:                                                 params, numParams,
  2850:                                                 getter_Copies(result));
  2850:     if (NS_SUCCEEDED(rv)) {
  2850:       outString = result;
  2850:     }
  2850:   }
  2850:   return rv;
  2850: }
  2850: 
  2850: NS_IMETHODIMP
  2850: nsNSSComponent::GetNSSBundleString(const char *name,
  2850:                                    nsAString &outString)
  2850: {
  2850:   nsresult rv = NS_ERROR_FAILURE;
  2850: 
  2850:   outString.SetLength(0);
  2850:   if (mNSSErrorsBundle && name) {
  2850:     nsXPIDLString result;
  2850:     rv = mNSSErrorsBundle->GetStringFromName(NS_ConvertASCIItoUTF16(name).get(),
  2850:                                              getter_Copies(result));
  2850:     if (NS_SUCCEEDED(rv)) {
  2850:       outString = result;
  2850:       rv = NS_OK;
  2850:     }
  2850:   }
  2850: 
  2850:   return rv;
  2850: }
  2850: 
     1: void
     1: nsNSSComponent::LaunchSmartCardThreads()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   {
 34173:     SECMODModuleList *list;
     1:     SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
 34173:     if (!lock) {
 34173:         PR_LOG(gPIPNSSLog, PR_LOG_ERROR,
 34173:                ("Couldn't get the module list lock, can't launch smart card threads\n"));
 34173:         return;
 34173:     }
     1:     SECMOD_GetReadLock(lock);
 34173:     list = SECMOD_GetDefaultModuleList();
     1: 
     1:     while (list) {
     1:       SECMODModule *module = list->module;
     1:       LaunchSmartCardThread(module);
     1:       list = list->next;
     1:     }
     1:     SECMOD_ReleaseReadLock(lock);
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::LaunchSmartCardThread(SECMODModule *module)
     1: {
     1:   SmartCardMonitoringThread *newThread;
     1:   if (SECMOD_HasRemovableSlots(module)) {
119832:     if (mThreadList == nullptr) {
119832:       mThreadList = new SmartCardThreadList();
119235:       if (!mThreadList) {
119832:         return NS_ERROR_OUT_OF_MEMORY;
119832:       }
     1:     }
     1:     newThread = new SmartCardMonitoringThread(module);
119832:     if (!newThread) {
119832: 	return NS_ERROR_OUT_OF_MEMORY;
119832:     }
     1:     // newThread is adopted by the add.
     1:     return mThreadList->Add(newThread);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::ShutdownSmartCardThread(SECMODModule *module)
     1: {
     1:   if (!mThreadList) {
     1:     return NS_OK;
     1:   }
     1:   mThreadList->Remove(module);
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsNSSComponent::ShutdownSmartCardThreads()
     1: {
     1:   delete mThreadList;
106838:   mThreadList = nullptr;
     1: }
     1: 
     1: static char *
     1: nss_addEscape(const char *string, char quote)
     1: {
     1:     char *newString = 0;
     1:     int escapes = 0, size = 0;
     1:     const char *src;
     1:     char *dest;
     1: 
     1:     for (src=string; *src ; src++) {
     1:         if ((*src == quote) || (*src == '\\')) {
     1:           escapes++;
     1:         }
     1:         size++;
     1:     }
     1: 
     1:     newString = (char*)PORT_ZAlloc(escapes+size+1);
119832:     if (newString == NULL) {
119832:         return NULL;
     1:     }
     1: 
     1:     for (src=string, dest=newString; *src; src++,dest++) {
     1:         if ((*src == quote) || (*src == '\\')) {
     1:             *dest++ = '\\';
     1:         }
     1:         *dest = *src;
     1:     }
     1: 
     1:     return newString;
     1: }
     1: 
     1: void
     1: nsNSSComponent::InstallLoadableRoots()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
106838:   SECMODModule *RootsModule = nullptr;
     1: 
     1:   // In the past we used SECMOD_AddNewModule to load our module containing
     1:   // root CA certificates. This caused problems, refer to bug 176501.
     1:   // On startup, we fix our database and clean any stored module reference,
     1:   // and will use SECMOD_LoadUserModule to temporarily load it
     1:   // for the session. (This approach requires to clean up 
     1:   // using SECMOD_UnloadUserModule at the end of the session.)
     1: 
     1:   {
     1:     // Find module containing root certs
     1: 
 34173:     SECMODModuleList *list;
     1:     SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
 34173:     if (!lock) {
 34173:         PR_LOG(gPIPNSSLog, PR_LOG_ERROR,
 34173:                ("Couldn't get the module list lock, can't install loadable roots\n"));
 34173:         return;
 34173:     }
     1:     SECMOD_GetReadLock(lock);
 34173:     list = SECMOD_GetDefaultModuleList();
     1: 
     1:     while (!RootsModule && list) {
     1:       SECMODModule *module = list->module;
     1: 
     1:       for (int i=0; i < module->slotCount; i++) {
     1:         PK11SlotInfo *slot = module->slots[i];
     1:         if (PK11_IsPresent(slot)) {
     1:           if (PK11_HasRootCerts(slot)) {
     1:             RootsModule = SECMOD_ReferenceModule(module);
     1:             break;
     1:           }
     1:         }
     1:       }
     1: 
     1:       list = list->next;
     1:     }
     1:     SECMOD_ReleaseReadLock(lock);
     1:   }
     1: 
     1:   if (RootsModule) {
108991:     int32_t modType;
     1:     SECMOD_DeleteModule(RootsModule->commonName, &modType);
     1:     SECMOD_DestroyModule(RootsModule);
106838:     RootsModule = nullptr;
     1:   }
     1: 
     1:   // Find the best Roots module for our purposes.
     1:   // Prefer the application's installation directory,
     1:   // but also ensure the library is at least the version we expect.
     1: 
     1:   nsresult rv;
     1:   nsAutoString modName;
     1:   rv = GetPIPNSSBundleString("RootCertModuleName", modName);
     1:   if (NS_FAILED(rv)) return;
     1: 
     1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
     1:   if (!directoryService)
     1:     return;
     1: 
 87073:   static const char nss_lib[] = "nss3";
     1:   const char *possible_ckbi_locations[] = {
 87073:     nss_lib, // This special value means: search for ckbi in the directory
 87073:              // where nss3 is.
     1:     NS_XPCOM_CURRENT_PROCESS_DIR,
     1:     NS_GRE_DIR,
     1:     0 // This special value means: 
     1:       //   search for ckbi in the directories on the shared
     1:       //   library/DLL search path
     1:   };
     1: 
     1:   for (size_t il = 0; il < sizeof(possible_ckbi_locations)/sizeof(const char*); ++il) {
101111:     nsCOMPtr<nsIFile> mozFile;
106838:     char *fullLibraryPath = nullptr;
     1: 
     1:     if (!possible_ckbi_locations[il])
     1:     {
106838:       fullLibraryPath = PR_GetLibraryName(nullptr, "nssckbi");
     1:     }
     1:     else
     1:     {
 87073:       if (possible_ckbi_locations[il] == nss_lib) {
 87073:         // Get the location of the nss3 library.
 87073:         char *nss_path = PR_GetLibraryFilePathname(DLL_PREFIX "nss3" DLL_SUFFIX,
 87073:                                                    (PRFuncPtr) NSS_Initialize);
 87073:         if (!nss_path) {
 87073:           continue;
 87073:         }
 87073:         // Get the directory containing the nss3 library.
101111:         nsCOMPtr<nsIFile> nssLib(do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &rv));
 87073:         if (NS_SUCCEEDED(rv)) {
 87073:           rv = nssLib->InitWithNativePath(nsDependentCString(nss_path));
 87073:         }
 87073:         PR_Free(nss_path);
 87073:         if (NS_SUCCEEDED(rv)) {
 87073:           nsCOMPtr<nsIFile> file;
 87073:           if (NS_SUCCEEDED(nssLib->GetParent(getter_AddRefs(file)))) {
 87073:             mozFile = do_QueryInterface(file);
 87073:           }
 87073:         }
 87073:       } else {
     1:         directoryService->Get( possible_ckbi_locations[il],
101111:                                NS_GET_IID(nsIFile), 
     1:                                getter_AddRefs(mozFile));
 87073:       }
     1:   
     1:       if (!mozFile) {
     1:         continue;
     1:       }
     1: 
110974:       nsAutoCString processDir;
     1:       mozFile->GetNativePath(processDir);
     1:       fullLibraryPath = PR_GetLibraryName(processDir.get(), "nssckbi");
     1:     }
     1: 
     1:     if (!fullLibraryPath) {
     1:       continue;
     1:     }
     1: 
     1:     char *escaped_fullLibraryPath = nss_addEscape(fullLibraryPath, '\"');
     1:     if (!escaped_fullLibraryPath) {
     1:       PR_FreeLibraryName(fullLibraryPath); // allocated by NSPR
     1:       continue;
     1:     }
     1: 
     1:     /* If a module exists with the same name, delete it. */
     1:     NS_ConvertUTF16toUTF8 modNameUTF8(modName);
     1:     int modType;
  3233:     SECMOD_DeleteModule(const_cast<char*>(modNameUTF8.get()), &modType);
     1: 
     1:     nsCString pkcs11moduleSpec;
     1:     pkcs11moduleSpec.Append(NS_LITERAL_CSTRING("name=\""));
     1:     pkcs11moduleSpec.Append(modNameUTF8.get());
     1:     pkcs11moduleSpec.Append(NS_LITERAL_CSTRING("\" library=\""));
     1:     pkcs11moduleSpec.Append(escaped_fullLibraryPath);
     1:     pkcs11moduleSpec.Append(NS_LITERAL_CSTRING("\""));
     1: 
     1:     PR_FreeLibraryName(fullLibraryPath); // allocated by NSPR
     1:     PORT_Free(escaped_fullLibraryPath);
     1: 
     1:     RootsModule =
  3233:       SECMOD_LoadUserModule(const_cast<char*>(pkcs11moduleSpec.get()), 
106838:                             nullptr, // no parent 
 80486:                             false); // do not recurse
     1: 
     1:     if (RootsModule) {
 79445:       bool found = (RootsModule->loaded);
  2851: 
  1427:       SECMOD_DestroyModule(RootsModule);
106838:       RootsModule = nullptr;
  2851: 
  2851:       if (found) {
     1:         break;
     1:       }
     1:     }
     1:   }
  2851: }
     1: 
     1: void 
     1: nsNSSComponent::UnloadLoadableRoots()
     1: {
     1:   nsresult rv;
     1:   nsAutoString modName;
     1:   rv = GetPIPNSSBundleString("RootCertModuleName", modName);
     1:   if (NS_FAILED(rv)) return;
     1: 
     1:   NS_ConvertUTF16toUTF8 modNameUTF8(modName);
     1:   SECMODModule *RootsModule = SECMOD_FindModule(modNameUTF8.get());
     1: 
     1:   if (RootsModule) {
     1:     SECMOD_UnloadUserModule(RootsModule);
     1:     SECMOD_DestroyModule(RootsModule);
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::ConfigureInternalPKCS11Token()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsAutoString manufacturerID;
     1:   nsAutoString libraryDescription;
     1:   nsAutoString tokenDescription;
     1:   nsAutoString privateTokenDescription;
     1:   nsAutoString slotDescription;
     1:   nsAutoString privateSlotDescription;
     1:   nsAutoString fips140TokenDescription;
     1:   nsAutoString fips140SlotDescription;
     1: 
     1:   nsresult rv;
     1:   rv = GetPIPNSSBundleString("ManufacturerID", manufacturerID);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("LibraryDescription", libraryDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("TokenDescription", tokenDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("PrivateTokenDescription", privateTokenDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("SlotDescription", slotDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("PrivateSlotDescription", privateSlotDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("Fips140TokenDescription", fips140TokenDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetPIPNSSBundleString("Fips140SlotDescription", fips140SlotDescription);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   PK11_ConfigurePKCS11(NS_ConvertUTF16toUTF8(manufacturerID).get(),
     1:                        NS_ConvertUTF16toUTF8(libraryDescription).get(),
     1:                        NS_ConvertUTF16toUTF8(tokenDescription).get(),
     1:                        NS_ConvertUTF16toUTF8(privateTokenDescription).get(),
     1:                        NS_ConvertUTF16toUTF8(slotDescription).get(),
     1:                        NS_ConvertUTF16toUTF8(privateSlotDescription).get(),
     1:                        NS_ConvertUTF16toUTF8(fips140TokenDescription).get(),
     1:                        NS_ConvertUTF16toUTF8(fips140SlotDescription).get(),
     1:                        0, 0);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::InitializePIPNSSBundle()
     1: {
     1:   // Called during init only, no mutex required.
     1: 
     1:   nsresult rv;
     1:   nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
     1:   if (NS_FAILED(rv) || !bundleService) 
     1:     return NS_ERROR_FAILURE;
     1:   
     1:   bundleService->CreateBundle(PIPNSS_STRBUNDLE_URL,
     1:                               getter_AddRefs(mPIPNSSBundle));
     1:   if (!mPIPNSSBundle)
     1:     rv = NS_ERROR_FAILURE;
     1: 
  2850:   bundleService->CreateBundle(NSSERR_STRBUNDLE_URL,
  2850:                               getter_AddRefs(mNSSErrorsBundle));
  2850:   if (!mNSSErrorsBundle)
  2850:     rv = NS_ERROR_FAILURE;
  2850: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::RegisterPSMContentListener()
     1: {
     1:   // Called during init only, no mutex required.
     1: 
     1:   nsresult rv = NS_OK;
     1:   if (!mPSMContentListener) {
     1:     nsCOMPtr<nsIURILoader> dispatcher(do_GetService(NS_URI_LOADER_CONTRACTID));
     1:     if (dispatcher) {
     1:       mPSMContentListener = do_CreateInstance(NS_PSMCONTENTLISTEN_CONTRACTID);
     1:       rv = dispatcher->RegisterContentListener(mPSMContentListener);
     1:     }
     1:   }
     1:   return rv;
     1: }
     1: 
     1: /* Table of pref names and SSL cipher ID */
     1: typedef struct {
     1:   const char* pref;
     1:   long id;
     1: } CipherPref;
     1: 
     1: static CipherPref CipherPrefs[] = {
     1:  /* SSL3/TLS cipher suites*/
     1:  {"security.ssl3.rsa_rc4_128_md5", SSL_RSA_WITH_RC4_128_MD5}, // 128-bit RC4 encryption with RSA and an MD5 MAC
     1:  {"security.ssl3.rsa_rc4_128_sha", SSL_RSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with RSA and a SHA1 MAC
     1:  {"security.ssl3.rsa_fips_des_ede3_sha", SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with RSA and a SHA1 MAC (FIPS)
     1:  {"security.ssl3.rsa_des_ede3_sha", SSL_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with RSA and a SHA1 MAC
     1:  {"security.ssl3.rsa_fips_des_sha", SSL_RSA_FIPS_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA and a SHA1 MAC (FIPS)
     1:  {"security.ssl3.rsa_des_sha", SSL_RSA_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA and a SHA1 MAC
     1:  {"security.ssl3.rsa_1024_rc4_56_sha", TLS_RSA_EXPORT1024_WITH_RC4_56_SHA}, // 56-bit RC4 encryption with RSA and a SHA1 MAC (export)
     1:  {"security.ssl3.rsa_1024_des_cbc_sha", TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA and a SHA1 MAC (export)
     1:  {"security.ssl3.rsa_rc4_40_md5", SSL_RSA_EXPORT_WITH_RC4_40_MD5}, // 40-bit RC4 encryption with RSA and an MD5 MAC (export)
     1:  {"security.ssl3.rsa_rc2_40_md5", SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5}, // 40-bit RC2 encryption with RSA and an MD5 MAC (export)
     1:  /* Extra SSL3/TLS cipher suites */
  3982:  {"security.ssl3.dhe_rsa_camellia_256_sha", TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA}, // 256-bit Camellia encryption with RSA, DHE, and a SHA1 MAC
  3982:  {"security.ssl3.dhe_dss_camellia_256_sha", TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA}, // 256-bit Camellia encryption with DSA, DHE, and a SHA1 MAC
  3982:  {"security.ssl3.rsa_camellia_256_sha", TLS_RSA_WITH_CAMELLIA_256_CBC_SHA}, // 256-bit Camellia encryption with RSA and a SHA1 MAC
     1:  {"security.ssl3.dhe_rsa_aes_256_sha", TLS_DHE_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with RSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.dhe_dss_aes_256_sha", TLS_DHE_DSS_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with DSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.rsa_aes_256_sha", TLS_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with RSA and a SHA1 MAC
     1:    /* TLS_DHE_DSS_WITH_RC4_128_SHA // 128-bit RC4 encryption with DSA, DHE, and a SHA1 MAC
     1:       If this cipher gets included at a later time, it should get added at this position */
     1:  {"security.ssl3.ecdhe_ecdsa_aes_256_sha", TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDHE-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_ecdsa_aes_128_sha", TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDHE-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_ecdsa_des_ede3_sha", TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDHE-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_ecdsa_rc4_128_sha", TLS_ECDHE_ECDSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDHE-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_ecdsa_null_sha", TLS_ECDHE_ECDSA_WITH_NULL_SHA}, // No encryption with ECDHE-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_rsa_aes_256_sha", TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDHE-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_rsa_aes_128_sha", TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDHE-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_rsa_des_ede3_sha", TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDHE-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_rsa_rc4_128_sha", TLS_ECDHE_RSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDHE-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdhe_rsa_null_sha", TLS_ECDHE_RSA_WITH_NULL_SHA}, // No encryption with ECDHE-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_ecdsa_aes_256_sha", TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDH-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_ecdsa_aes_128_sha", TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDH-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_ecdsa_des_ede3_sha", TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDH-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_ecdsa_rc4_128_sha", TLS_ECDH_ECDSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDH-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_ecdsa_null_sha", TLS_ECDH_ECDSA_WITH_NULL_SHA}, // No encryption with ECDH-ECDSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_rsa_aes_256_sha", TLS_ECDH_RSA_WITH_AES_256_CBC_SHA}, // 256-bit AES encryption with ECDH-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_rsa_aes_128_sha", TLS_ECDH_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with ECDH-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_rsa_des_ede3_sha", TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with ECDH-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_rsa_rc4_128_sha", TLS_ECDH_RSA_WITH_RC4_128_SHA}, // 128-bit RC4 encryption with ECDH-RSA and a SHA1 MAC
     1:  {"security.ssl3.ecdh_rsa_null_sha", TLS_ECDH_RSA_WITH_NULL_SHA}, // No encryption with ECDH-RSA and a SHA1 MAC
  3982:  {"security.ssl3.dhe_rsa_camellia_128_sha", TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA}, // 128-bit Camellia encryption with RSA, DHE, and a SHA1 MAC
  3982:  {"security.ssl3.dhe_dss_camellia_128_sha", TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA}, // 128-bit Camellia encryption with DSA, DHE, and a SHA1 MAC
  3982:  {"security.ssl3.rsa_camellia_128_sha", TLS_RSA_WITH_CAMELLIA_128_CBC_SHA}, // 128-bit Camellia encryption with RSA and a SHA1 MAC
     1:  {"security.ssl3.dhe_rsa_aes_128_sha", TLS_DHE_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with RSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.dhe_dss_aes_128_sha", TLS_DHE_DSS_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with DSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.rsa_aes_128_sha", TLS_RSA_WITH_AES_128_CBC_SHA}, // 128-bit AES encryption with RSA and a SHA1 MAC
     1:  {"security.ssl3.dhe_rsa_des_ede3_sha", SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with RSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.dhe_dss_des_ede3_sha", SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA}, // 168-bit Triple DES with DSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.dhe_rsa_des_sha", SSL_DHE_RSA_WITH_DES_CBC_SHA}, // 56-bit DES encryption with RSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.dhe_dss_des_sha", SSL_DHE_DSS_WITH_DES_CBC_SHA}, // 56-bit DES encryption with DSA, DHE, and a SHA1 MAC
     1:  {"security.ssl3.rsa_null_sha", SSL_RSA_WITH_NULL_SHA}, // No encryption with RSA authentication and a SHA1 MAC
     1:  {"security.ssl3.rsa_null_md5", SSL_RSA_WITH_NULL_MD5}, // No encryption with RSA authentication and an MD5 MAC
 31267:  {"security.ssl3.rsa_seed_sha", TLS_RSA_WITH_SEED_CBC_SHA}, // SEED encryption with RSA and a SHA1 MAC
119832:  {NULL, 0} /* end marker */
     1: };
     1: 
 69383: static void
108991: setNonPkixOcspEnabled(int32_t ocspEnabled, nsIPrefBranch * pref)
     1: {
     1:   switch (ocspEnabled) {
     1:   case 0:
     1:     CERT_DisableOCSPChecking(CERT_GetDefaultCertDB());
     1:     CERT_DisableOCSPDefaultResponder(CERT_GetDefaultCertDB());
     1:     break;
     1:   case 1:
     1:     CERT_EnableOCSPChecking(CERT_GetDefaultCertDB());
     1:     CERT_DisableOCSPDefaultResponder(CERT_GetDefaultCertDB());
     1:     break;
     1:   case 2:
     1:     {
106838:       char *signingCA = nullptr;
106838:       char *url = nullptr;
     1: 
     1:       // Get the signing CA and service url //
     1:       pref->GetCharPref("security.OCSP.signingCA", &signingCA);
     1:       pref->GetCharPref("security.OCSP.URL", &url);
     1: 
     1:       // Set OCSP up
     1:       CERT_EnableOCSPChecking(CERT_GetDefaultCertDB());
     1:       CERT_SetOCSPDefaultResponder(CERT_GetDefaultCertDB(), url, signingCA);
     1:       CERT_EnableOCSPDefaultResponder(CERT_GetDefaultCertDB());
     1: 
     1:       nsMemory::Free(signingCA);
     1:       nsMemory::Free(url);
     1:     }
     1:     break;
     1:   }
 69383: }
 69383: 
 80486: #define CRL_DOWNLOAD_DEFAULT false
 69383: #define OCSP_ENABLED_DEFAULT 1
 69383: #define OCSP_REQUIRED_DEFAULT 0
 80486: #define FRESH_REVOCATION_REQUIRED_DEFAULT false
 80486: #define MISSING_CERT_DOWNLOAD_DEFAULT false
 69383: #define FIRST_REVO_METHOD_DEFAULT "ocsp"
 80486: #define USE_NSS_LIBPKIX_DEFAULT false
 69383: 
 69383: // Caller must hold a lock on nsNSSComponent::mutex when calling this function
 69383: void nsNSSComponent::setValidationOptions(nsIPrefBranch * pref)
 69383: {
 69383:   nsNSSShutDownPreventionLock locker;
 69383:   nsresult rv;
 69383: 
 79445:   bool crlDownloading;
 69383:   rv = pref->GetBoolPref("security.CRL_download.enabled", &crlDownloading);
 69383:   if (NS_FAILED(rv))
 69383:     crlDownloading = CRL_DOWNLOAD_DEFAULT;
 69383:   
108991:   int32_t ocspEnabled;
 69383:   rv = pref->GetIntPref("security.OCSP.enabled", &ocspEnabled);
 69383:   // 0 = disabled, 1 = enabled, 
 69383:   // 2 = enabled with given default responder
 69383:   if (NS_FAILED(rv))
 69383:     ocspEnabled = OCSP_ENABLED_DEFAULT;
 69383: 
 79445:   bool ocspRequired;
 69383:   rv = pref->GetBoolPref("security.OCSP.require", &ocspRequired);
 69383:   if (NS_FAILED(rv))
 69383:     ocspRequired = OCSP_REQUIRED_DEFAULT;
 69383: 
 79445:   bool anyFreshRequired;
 69383:   rv = pref->GetBoolPref("security.fresh_revocation_info.require", &anyFreshRequired);
 69383:   if (NS_FAILED(rv))
 69383:     anyFreshRequired = FRESH_REVOCATION_REQUIRED_DEFAULT;
 69383:   
 79445:   bool aiaDownloadEnabled;
 69383:   rv = pref->GetBoolPref("security.missing_cert_download.enabled", &aiaDownloadEnabled);
 69383:   if (NS_FAILED(rv))
 69383:     aiaDownloadEnabled = MISSING_CERT_DOWNLOAD_DEFAULT;
 69383: 
 69383:   nsCString firstNetworkRevo;
 69383:   rv = pref->GetCharPref("security.first_network_revocation_method", getter_Copies(firstNetworkRevo));
 69383:   if (NS_FAILED(rv))
 69383:     firstNetworkRevo = FIRST_REVO_METHOD_DEFAULT;
 69383:   
 69383:   setNonPkixOcspEnabled(ocspEnabled, pref);
 69383:   
 69383:   CERT_SetOCSPFailureMode( ocspRequired ?
 69383:                            ocspMode_FailureIsVerificationFailure
 69383:                            : ocspMode_FailureIsNotAVerificationFailure);
 69383: 
119832:   nsRefPtr<nsCERTValInParamWrapper> newCVIN = new nsCERTValInParamWrapper;
 69383:   if (NS_SUCCEEDED(newCVIN->Construct(
 69383:       aiaDownloadEnabled ? 
 69383:         nsCERTValInParamWrapper::missing_cert_download_on : nsCERTValInParamWrapper::missing_cert_download_off,
 69383:       crlDownloading ?
 69383:         nsCERTValInParamWrapper::crl_download_allowed : nsCERTValInParamWrapper::crl_local_only,
 69383:       ocspEnabled ? 
 69383:         nsCERTValInParamWrapper::ocsp_on : nsCERTValInParamWrapper::ocsp_off,
 69383:       ocspRequired ? 
 69383:         nsCERTValInParamWrapper::ocsp_strict : nsCERTValInParamWrapper::ocsp_relaxed,
 69383:       anyFreshRequired ?
 69383:         nsCERTValInParamWrapper::any_revo_strict : nsCERTValInParamWrapper::any_revo_relaxed,
 69383:       firstNetworkRevo.get()))) {
 69383:     // Swap to new defaults, and will cause the old defaults to be released,
 69383:     // as soon as any concurrent use of the old default objects has finished.
 69383:     mDefaultCERTValInParam = newCVIN;
 69383:   }
 69383: 
 69383:   /*
 69383:     * The new defaults might change the validity of already established SSL sessions,
 69383:     * let's not reuse them.
 69383:     */
 69383:   SSL_ClearSessionCache();
     1: }
     1: 
 69384: NS_IMETHODIMP
 69384: nsNSSComponent::SkipOcsp()
 69384: {
 69384:   nsNSSShutDownPreventionLock locker;
 69384:   CERTCertDBHandle *certdb = CERT_GetDefaultCertDB();
 69384: 
 69384:   SECStatus rv = CERT_DisableOCSPChecking(certdb);
 69384:   return (rv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
 69384: }
 69384: 
 69384: NS_IMETHODIMP
 69384: nsNSSComponent::SkipOcspOff()
 69384: {
 69384:   nsNSSShutDownPreventionLock locker;
108991:   int32_t ocspEnabled;
 69384:   if (NS_FAILED(mPrefBranch->GetIntPref("security.OCSP.enabled", &ocspEnabled)))
 69384:     ocspEnabled = OCSP_ENABLED_DEFAULT;
 69384:   // 0 = disabled, 1 = enabled, 
 69384:   // 2 = enabled with given default responder
 69384:   
 69384:   setNonPkixOcspEnabled(ocspEnabled, mPrefBranch);
 69384: 
 69384:   if (ocspEnabled)
 69384:     SSL_ClearSessionCache();
 69384: 
 69384:   return NS_OK;
 69384: }
 69384: 
     1: nsresult
     1: nsNSSComponent::PostCRLImportEvent(const nsCSubstring &urlString,
     1:                                    nsIStreamListener *listener)
     1: {
     1:   //Create the event
     1:   nsCOMPtr<nsIRunnable> event = new CRLDownloadEvent(urlString, listener);
119832:   if (!event)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   //Get a handle to the ui thread
     1:   return NS_DispatchToMainThread(event);
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::DownloadCRLDirectly(nsAutoString url, nsAutoString key)
     1: {
     1:   //This api is meant to support direct interactive update of crl from the crl manager
     1:   //or other such ui.
     1:   nsCOMPtr<nsIStreamListener> listener =
     1:       new PSMContentDownloader(PSMContentDownloader::PKCS7_CRL);
     1:   
     1:   NS_ConvertUTF16toUTF8 url8(url);
     1:   return PostCRLImportEvent(url8, listener);
     1: }
     1: 
     1: nsresult nsNSSComponent::DownloadCrlSilently()
     1: {
     1:   //Add this attempt to the hashtable
     1:   nsStringKey hashKey(mCrlUpdateKey.get());
106838:   crlsScheduledForDownload->Put(&hashKey,(void *)nullptr);
     1:     
     1:   //Set up the download handler
119832:   nsRefPtr<PSMContentDownloader> psmDownloader =
119832:       new PSMContentDownloader(PSMContentDownloader::PKCS7_CRL);
 80486:   psmDownloader->setSilentDownload(true);
     1:   psmDownloader->setCrlAutodownloadKey(mCrlUpdateKey);
     1:   
     1:   //Now get the url string
     1:   NS_ConvertUTF16toUTF8 url8(mDownloadURL);
     1:   return PostCRLImportEvent(url8, psmDownloader);
     1: }
     1: 
     1: nsresult nsNSSComponent::getParamsForNextCrlToDownload(nsAutoString *url, PRTime *time, nsAutoString *key)
     1: {
     1:   const char *updateEnabledPref = CRL_AUTOUPDATE_ENABLED_PREF;
     1:   const char *updateTimePref = CRL_AUTOUPDATE_TIME_PREF;
     1:   const char *updateURLPref = CRL_AUTOUPDATE_URL_PREF;
     1:   char **allCrlsToBeUpdated;
108991:   uint32_t noOfCrls;
     1:   PRTime nearestUpdateTime = 0;
     1:   nsAutoString crlKey;
     1:   char *tempUrl;
     1:   nsresult rv;
     1:   
     1:   nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
     1:   if(NS_FAILED(rv)){
     1:     return rv;
     1:   }
     1: 
     1:   rv = pref->GetChildList(updateEnabledPref, &noOfCrls, &allCrlsToBeUpdated);
     1:   if ( (NS_FAILED(rv)) || (noOfCrls==0) ){
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
108991:   for(uint32_t i=0;i<noOfCrls;i++) {
 17116:     //First check if update pref is enabled for this crl
 79445:     bool autoUpdateEnabled = false;
 17116:     rv = pref->GetBoolPref(*(allCrlsToBeUpdated+i), &autoUpdateEnabled);
 17116:     if (NS_FAILED(rv) || !autoUpdateEnabled) {
 17116:       continue;
 17116:     }
 17116: 
     1:     nsAutoString tempCrlKey;
     1: 
     1:     //Now, generate the crl key. Same key would be used as hashkey as well
110974:     nsAutoCString enabledPrefCString(*(allCrlsToBeUpdated+i));
     1:     enabledPrefCString.ReplaceSubstring(updateEnabledPref,".");
     1:     tempCrlKey.AssignWithConversion(enabledPrefCString.get());
     1:       
     1:     //Check if this crl has already been scheduled. Its presence in the hashtable
     1:     //implies that it has been scheduled already this client session, and
     1:     //is either in the process of being downloaded, or its download failed
     1:     //for some reason. In the second case, we will not retry in the current client session
     1:     nsStringKey hashKey(tempCrlKey.get());
     1:     if(crlsScheduledForDownload->Exists(&hashKey)){
     1:       continue;
     1:     }
     1: 
     1:     char *tempTimeString;
     1:     PRTime tempTime;
110974:     nsAutoCString timingPrefCString(updateTimePref);
103796:     LossyAppendUTF16toASCII(tempCrlKey, timingPrefCString);
108991:     // No PRTime/Int64 type in prefs; stored as string; parsed here as int64_t
     1:     rv = pref->GetCharPref(timingPrefCString.get(), &tempTimeString);
     1:     if (NS_FAILED(rv)){
 93962:       // Assume corrupted. Force download. Pref should be reset after download.
 93962:       tempTime = PR_Now();
 93962:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
 93962:              ("get %s failed: forcing download\n", timingPrefCString.get()));
 93962:     } else {
 93962:       tempTime = (PRTime)nsCRT::atoll(tempTimeString);
     1:       nsMemory::Free(tempTimeString);
 93962:       // nsCRT::atoll parses the first token in the string; three possibilities
 93962:       //  -1- Alpha char: returns 0; change to PR_Now() and force update.
 93962:       //  -2- Number (between epoch and PR_Now(), e.g. 0 - 1332280017 for
 93962:       //      Tue Mar 20, 2012, 2:46pm approx): includes formatted date 
 93962:       //      values (previous method of storing update date, e.g year, month 
 93962:       //      or day, 2012, 1-31, 1-12 etc). Less than PR_Now() forces 
 93962:       //      autoupdate.
 93962:       //  -3- Number (larger than PR_Now()): no forced autoupdate
 93962:       // Note: corrupt values within range of -2- will have an implicit 
 93962:       // unflagged recovery. Corrupt values in range of -3- will be unflagged
 93962:       // and unrecovered by this code.
 93962:       if (tempTime == 0)
 93962:         tempTime = PR_Now();
 93962: #ifdef PR_LOGGING
 93962:       PRExplodedTime explodedTime;
 93962:       PR_ExplodeTime(tempTime, PR_GMTParameters, &explodedTime);
 93962:       // Note: tm_month starts from 0 = Jan, hence +1
 93962:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
 93962:              ("%s tempTime(%lli) "
 93962:               "(m/d/y h:m:s = %02d/%02d/%d %02d:%02d:%02d GMT\n",
 93962:               timingPrefCString.get(), tempTime,
 93962:               explodedTime.tm_month+1, explodedTime.tm_mday,
 93962:               explodedTime.tm_year, explodedTime.tm_hour,
 93962:               explodedTime.tm_min, explodedTime.tm_sec));
 93962: #endif
     1:     }
     1: 
     1:     if(nearestUpdateTime == 0 || tempTime < nearestUpdateTime){
110974:       nsAutoCString urlPrefCString(updateURLPref);
103796:       LossyAppendUTF16toASCII(tempCrlKey, urlPrefCString);
     1:       rv = pref->GetCharPref(urlPrefCString.get(), &tempUrl);
     1:       if (NS_FAILED(rv) || (!tempUrl)){
     1:         continue;
     1:       }
     1:       nearestUpdateTime = tempTime;
     1:       crlKey = tempCrlKey;
     1:     }
     1:   }
     1: 
     1:   if(noOfCrls > 0)
     1:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(noOfCrls, allCrlsToBeUpdated);
     1: 
     1:   if(nearestUpdateTime > 0){
     1:     *time = nearestUpdateTime;
     1:     url->AssignWithConversion((const char *)tempUrl);
     1:     nsMemory::Free(tempUrl);
     1:     *key = crlKey;
     1:     rv = NS_OK;
     1:   } else{
     1:     rv = NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::Notify(nsITimer *timer)
     1: {
     1:   //Timer has fired. So set the flag accordingly
 64576:   {
 64576:     MutexAutoLock lock(mCrlTimerLock);
 80486:     crlDownloadTimerOn = false;
 64576:   }
     1: 
     1:   //First, handle this download
 90628:   DownloadCrlSilently();
     1: 
     1:   //Dont Worry if successful or not
     1:   //Set the next timer
     1:   DefineNextTimer();
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::RemoveCrlFromList(nsAutoString key)
     1: {
     1:   nsStringKey hashKey(key.get());
     1:   if(crlsScheduledForDownload->Exists(&hashKey)){
     1:     crlsScheduledForDownload->Remove(&hashKey);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::DefineNextTimer()
     1: {
     1:   PRTime nextFiring;
     1:   PRTime now = PR_Now();
108991:   uint32_t interval;
108991:   uint32_t primaryDelay = CRL_AUTOUPDATE_DEFAULT_DELAY;
     1:   nsresult rv;
     1: 
     1:   if(!mTimer){
     1:     mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     1:     if(NS_FAILED(rv))
     1:       return rv;
     1:   }
     1: 
     1:   //If some timer is already running, cancel it. Thus, the request that came last,
     1:   //wins. This would ensure that in no way we end up setting two different timers
     1:   //This part should be synchronized because this function might be called from separate
     1:   //threads
     1: 
 64576:   MutexAutoLock lock(mCrlTimerLock);
     1: 
 17116:   if (crlDownloadTimerOn) {
     1:     mTimer->Cancel();
     1:   }
     1: 
     1:   rv = getParamsForNextCrlToDownload(&mDownloadURL, &nextFiring, &mCrlUpdateKey);
     1:   //If there are no more crls to be updated any time in future
     1:   if(NS_FAILED(rv)){
 64576:     // Return - no error - just implies nothing to schedule
     1:     return NS_OK;
     1:   }
     1:      
     1:   //Define the firing interval, from NOW
     1:   if ( now < nextFiring) {
118766:     interval = uint32_t(nextFiring - now);
     1:     //Now, we are doing 32 operations - so, don't need LL_ functions...
     1:     interval = interval/PR_USEC_PER_MSEC;
     1:   }else {
     1:     interval = primaryDelay;
     1:   }
     1:   
  3233:   mTimer->InitWithCallback(static_cast<nsITimerCallback*>(this), 
     1:                            interval,
     1:                            nsITimer::TYPE_ONE_SHOT);
 80486:   crlDownloadTimerOn = true;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //Note that the StopCRLUpdateTimer and InitializeCRLUpdateTimer functions should never be called
     1: //simultaneously from diff threads - they are NOT threadsafe. But, since there is no chance of 
     1: //that happening, there is not much benefit it trying to make it so at this point
     1: nsresult
     1: nsNSSComponent::StopCRLUpdateTimer()
     1: {
     1:   
     1:   //If it is at all running. 
 17116:   if (mUpdateTimerInitialized) {
119832:     if(crlsScheduledForDownload != nullptr){
     1:       crlsScheduledForDownload->Reset();
     1:       delete crlsScheduledForDownload;
106838:       crlsScheduledForDownload = nullptr;
     1:     }
 64576:     {
 64576:       MutexAutoLock lock(mCrlTimerLock);
 17116:       if (crlDownloadTimerOn) {
     1:         mTimer->Cancel();
     1:       }
 80486:       crlDownloadTimerOn = false;
 80486:     }
 80486:     mUpdateTimerInitialized = false;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::InitializeCRLUpdateTimer()
     1: {
     1:   nsresult rv;
     1:     
     1:   //First check if this is already initialized. Then we stop it.
 17116:   if (!mUpdateTimerInitialized) {
     1:     mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     1:     if(NS_FAILED(rv)){
     1:       return rv;
     1:     }
 80486:     crlsScheduledForDownload = new nsHashtable(16, true);
     1:     DefineNextTimer();
 80486:     mUpdateTimerInitialized = true;  
     1:   } 
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: #ifdef XP_MACOSX
     1: void
     1: nsNSSComponent::TryCFM2MachOMigration(nsIFile *cfmPath, nsIFile *machoPath)
     1: {
     1:   // We will modify the parameters.
     1:   //
     1:   // If neither cert7.db, cert8.db, key3.db, are available, 
     1:   // copy from filenames that were used in the old days
     1:   // test for key3.db first, since a new profile might only contain cert8.db, 
     1:   // but not cert7.db - this optimizes number of tests
     1: 
     1:   NS_NAMED_LITERAL_CSTRING(cstr_key3db, "key3.db");
     1:   NS_NAMED_LITERAL_CSTRING(cstr_cert7db, "cert7.db");
     1:   NS_NAMED_LITERAL_CSTRING(cstr_cert8db, "cert8.db");
     1:   NS_NAMED_LITERAL_CSTRING(cstr_keydatabase3, "Key Database3");
     1:   NS_NAMED_LITERAL_CSTRING(cstr_certificate7, "Certificates7");
     1:   NS_NAMED_LITERAL_CSTRING(cstr_certificate8, "Certificates8");
     1: 
 79445:   bool bExists;
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsIFile> macho_key3db;
     1:   rv = machoPath->Clone(getter_AddRefs(macho_key3db));
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   macho_key3db->AppendNative(cstr_key3db);
     1:   rv = macho_key3db->Exists(&bExists);
     1:   if (NS_FAILED(rv) || bExists) {
     1:     return;
     1:   }
     1: 
     1:   nsCOMPtr<nsIFile> macho_cert7db;
     1:   rv = machoPath->Clone(getter_AddRefs(macho_cert7db));
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   macho_cert7db->AppendNative(cstr_cert7db);
     1:   rv = macho_cert7db->Exists(&bExists);
     1:   if (NS_FAILED(rv) || bExists) {
     1:     return;
     1:   }
     1: 
     1:   nsCOMPtr<nsIFile> macho_cert8db;
     1:   rv = machoPath->Clone(getter_AddRefs(macho_cert8db));
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   macho_cert8db->AppendNative(cstr_cert8db);
     1:   rv = macho_cert7db->Exists(&bExists);
     1:   if (NS_FAILED(rv) || bExists) {
     1:     return;
     1:   }
     1: 
     1:   // None of the new files exist. Try to copy any available old files.
     1: 
     1:   nsCOMPtr<nsIFile> cfm_key3;
     1:   rv = cfmPath->Clone(getter_AddRefs(cfm_key3));
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   cfm_key3->AppendNative(cstr_keydatabase3);
     1:   rv = cfm_key3->Exists(&bExists);
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   if (bExists) {
     1:     cfm_key3->CopyToFollowingLinksNative(machoPath, cstr_key3db);
     1:   }
     1: 
     1:   nsCOMPtr<nsIFile> cfm_cert7;
     1:   rv = cfmPath->Clone(getter_AddRefs(cfm_cert7));
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   cfm_cert7->AppendNative(cstr_certificate7);
     1:   rv = cfm_cert7->Exists(&bExists);
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   if (bExists) {
     1:     cfm_cert7->CopyToFollowingLinksNative(machoPath, cstr_cert7db);
     1:   }
     1: 
     1:   nsCOMPtr<nsIFile> cfm_cert8;
     1:   rv = cfmPath->Clone(getter_AddRefs(cfm_cert8));
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   cfm_cert8->AppendNative(cstr_certificate8);
     1:   rv = cfm_cert8->Exists(&bExists);
     1:   if (NS_FAILED(rv)) {
     1:     return;
     1:   }
     1: 
     1:   if (bExists) {
     1:     cfm_cert8->CopyToFollowingLinksNative(machoPath, cstr_cert8db);
     1:   }
     1: }
     1: #endif
     1: 
 92004: static void configureMD5(bool enabled)
 92004: {
 92004:   if (enabled) { // set flags
 92004:     NSS_SetAlgorithmPolicy(SEC_OID_MD5, 
 92004:         NSS_USE_ALG_IN_CERT_SIGNATURE | NSS_USE_ALG_IN_CMS_SIGNATURE, 0);
 92004:     NSS_SetAlgorithmPolicy(SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION,
 92004:         NSS_USE_ALG_IN_CERT_SIGNATURE | NSS_USE_ALG_IN_CMS_SIGNATURE, 0);
 92004:     NSS_SetAlgorithmPolicy(SEC_OID_PKCS5_PBE_WITH_MD5_AND_DES_CBC,
 92004:         NSS_USE_ALG_IN_CERT_SIGNATURE | NSS_USE_ALG_IN_CMS_SIGNATURE, 0);
 92004:   }
 92004:   else { // clear flags
 92004:     NSS_SetAlgorithmPolicy(SEC_OID_MD5,
 92004:         0, NSS_USE_ALG_IN_CERT_SIGNATURE | NSS_USE_ALG_IN_CMS_SIGNATURE);
 92004:     NSS_SetAlgorithmPolicy(SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION,
 92004:         0, NSS_USE_ALG_IN_CERT_SIGNATURE | NSS_USE_ALG_IN_CMS_SIGNATURE);
 92004:     NSS_SetAlgorithmPolicy(SEC_OID_PKCS5_PBE_WITH_MD5_AND_DES_CBC,
 92004:         0, NSS_USE_ALG_IN_CERT_SIGNATURE | NSS_USE_ALG_IN_CMS_SIGNATURE);
 92004:   }
 92004: }
 92004: 
     1: nsresult
 79445: nsNSSComponent::InitializeNSS(bool showWarningBox)
     1: {
     1:   // Can be called both during init and profile change.
     1:   // Needs mutex protection.
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::InitializeNSS\n"));
     1: 
 94621:   MOZ_STATIC_ASSERT(nsINSSErrorsService::NSS_SEC_ERROR_BASE == SEC_ERROR_BASE &&
 94621:                     nsINSSErrorsService::NSS_SEC_ERROR_LIMIT == SEC_ERROR_LIMIT &&
 94621:                     nsINSSErrorsService::NSS_SSL_ERROR_BASE == SSL_ERROR_BASE &&
 94621:                     nsINSSErrorsService::NSS_SSL_ERROR_LIMIT == SSL_ERROR_LIMIT,
 94621:                     "You must update the values in nsINSSErrorsService.idl");
  8680: 
     1:   // variables used for flow control within this function
     1: 
     1:   enum { problem_none, problem_no_rw, problem_no_security_at_all }
     1:     which_nss_problem = problem_none;
     1: 
     1:   {
 64576:     MutexAutoLock lock(mutex);
     1: 
     1:     // Init phase 1, prepare own variables used for NSS
     1: 
     1:     if (mNSSInitialized) {
     1:       PR_ASSERT(!"Trying to initialize NSS twice"); // We should never try to 
     1:                                                     // initialize NSS more than
     1:                                                     // once in a process.
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     
     1:     nsresult rv;
110974:     nsAutoCString profileStr;
     1:     nsCOMPtr<nsIFile> profilePath;
     1: 
     1:     rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
     1:                                 getter_AddRefs(profilePath));
     1:     if (NS_FAILED(rv)) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to get profile directory\n"));
     1:       ConfigureInternalPKCS11Token();
119832:       SECStatus init_rv = NSS_NoDB_Init(NULL);
 57159:       if (init_rv != SECSuccess) {
 57159:         nsPSMInitPanic::SetPanic();
     1:         return NS_ERROR_NOT_AVAILABLE;
     1:       }
 57159:     }
     1:     else
     1:     {
     1: 
     1:   // XP_MACOSX == MachO
     1: 
108570:   #if defined(XP_MACOSX)
     1:     // On Mac CFM we place all NSS DBs in the Security
     1:     // Folder in the profile directory.
     1:     nsCOMPtr<nsIFile> cfmSecurityPath;
     1:     cfmSecurityPath = profilePath; // alias for easier code reading
     1:     cfmSecurityPath->AppendNative(NS_LITERAL_CSTRING("Security"));
     1:   #endif
     1: 
108579:   #if defined(XP_MACOSX)
     1:     // On MachO, we need to access both directories,
     1:     // and therefore need separate nsIFile instances.
     1:     // Keep cfmSecurityPath instance, obtain new instance for MachO profilePath.
     1:     rv = cfmSecurityPath->GetParent(getter_AddRefs(profilePath));
 57159:     if (NS_FAILED(rv)) {
 57159:       nsPSMInitPanic::SetPanic();
     1:       return rv;
 57159:     }
     1:   #endif
     1: 
 38207:     const char *dbdir_override = getenv("MOZPSM_NSSDBDIR_OVERRIDE");
 38207:     if (dbdir_override && strlen(dbdir_override)) {
 38207:       profileStr = dbdir_override;
 38207:     }
 38207:     else {
 33331:   #if defined(XP_WIN)
 33331:       // Native path will drop Unicode characters that cannot be mapped to system's
 33331:       // codepage, using short (canonical) path as workaround.
 33331:       nsCOMPtr<nsILocalFileWin> profilePathWin(do_QueryInterface(profilePath, &rv));
 33331:       if (profilePathWin)
 33331:         rv = profilePathWin->GetNativeCanonicalPath(profileStr);
 33331:   #else
     1:       rv = profilePath->GetNativePath(profileStr);
 33331:   #endif
 57159:       if (NS_FAILED(rv)) {
 57159:         nsPSMInitPanic::SetPanic();
     1:         return rv;
 38207:       }
 57159:     }
     1: 
 25625:     hashTableCerts = PL_NewHashTable( 0, certHashtable_keyHash, certHashtable_keyCompare,
 25625:       certHashtable_valueCompare, 0, 0 );
 25625: 
     1:   #if defined(XP_MACOSX)
     1:     // function may modify the parameters
     1:     // ignore return code from conversion, we continue anyway
     1:     TryCFM2MachOMigration(cfmSecurityPath, profilePath);
     1:   #endif
     1: 
 69383:     rv = mPrefBranch->GetBoolPref("security.use_libpkix_verification", &globalConstFlagUsePKIXVerification);
 69383:     if (NS_FAILED(rv))
 69383:       globalConstFlagUsePKIXVerification = USE_NSS_LIBPKIX_DEFAULT;
 69383: 
 79445:     bool supress_warning_preference = false;
     1:     rv = mPrefBranch->GetBoolPref("security.suppress_nss_rw_impossible_warning", &supress_warning_preference);
     1: 
     1:     if (NS_FAILED(rv)) {
 80486:       supress_warning_preference = false;
     1:     }
     1: 
     1:     // init phase 2, init calls to NSS library
     1: 
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS Initialization beginning\n"));
     1: 
     1:     // The call to ConfigureInternalPKCS11Token needs to be done before NSS is initialized, 
     1:     // but affects only static data.
     1:     // If we could assume i18n will not change between profiles, one call per application
     1:     // run were sufficient. As I can't predict what happens in the future, let's repeat
     1:     // this call for every re-init of NSS.
     1: 
     1:     ConfigureInternalPKCS11Token();
     1: 
 32081:     // The NSS_INIT_NOROOTINIT flag turns off the loading of the root certs
 32081:     // module by NSS_Initialize because we will load it in InstallLoadableRoots
 32081:     // later.  It also allows us to work around a bug in the system NSS in
 32081:     // Ubuntu 8.04, which loads any nonexistent "<configdir>/libnssckbi.so" as
 32081:     // "/usr/lib/nss/libnssckbi.so".
108991:     uint32_t init_flags = NSS_INIT_NOROOTINIT | NSS_INIT_OPTIMIZESPACE;
 32081:     SECStatus init_rv = ::NSS_Initialize(profileStr.get(), "", "",
 32081:                                          SECMOD_DB, init_flags);
     1: 
     1:     if (init_rv != SECSuccess) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can not init NSS r/w in %s\n", profileStr.get()));
     1: 
     1:       if (supress_warning_preference) {
     1:         which_nss_problem = problem_none;
     1:       }
     1:       else {
     1:         which_nss_problem = problem_no_rw;
     1:       }
     1: 
     1:       // try to init r/o
 32081:       init_flags |= NSS_INIT_READONLY;
 32081:       init_rv = ::NSS_Initialize(profileStr.get(), "", "",
 32081:                                  SECMOD_DB, init_flags);
     1: 
     1:       if (init_rv != SECSuccess) {
     1:         PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("can not init in r/o either\n"));
     1:         which_nss_problem = problem_no_security_at_all;
     1: 
     1:         init_rv = NSS_NoDB_Init(profileStr.get());
 57159:         if (init_rv != SECSuccess) {
 57159:           nsPSMInitPanic::SetPanic();
     1:           return NS_ERROR_NOT_AVAILABLE;
     1:         }
 57159:       }
     1:     } // have profile dir
     1:     } // lock
     1: 
     1:     // init phase 3, only if phase 2 was successful
     1: 
     1:     if (problem_no_security_at_all != which_nss_problem) {
     1: 
 80486:       mNSSInitialized = true;
     1: 
     1:       ::NSS_SetDomesticPolicy();
     1:       //  SSL_EnableCipher(SSL_RSA_WITH_NULL_MD5, SSL_ALLOWED);
     1:       //  SSL_EnableCipher(SSL_RSA_WITH_NULL_SHA, SSL_ALLOWED);
     1: 
     1:       PK11_SetPasswordFunc(PK11PasswordPrompt);
     1: 
     1:       // Register an observer so we can inform NSS when these prefs change
 90039:       mPrefBranch->AddObserver("security.", this, false);
 80486: 
 80486:       SSL_OptionSetDefault(SSL_ENABLE_SSL2, false);
 80486:       SSL_OptionSetDefault(SSL_V2_COMPATIBLE_HELLO, false);
 79445:       bool enabled;
     1:       mPrefBranch->GetBoolPref("security.enable_ssl3", &enabled);
     1:       SSL_OptionSetDefault(SSL_ENABLE_SSL3, enabled);
     1:       mPrefBranch->GetBoolPref("security.enable_tls", &enabled);
     1:       SSL_OptionSetDefault(SSL_ENABLE_TLS, enabled);
 92004:       mPrefBranch->GetBoolPref("security.enable_md5_signatures", &enabled);
 92004:       configureMD5(enabled);
     1: 
 12290:       // Configure TLS session tickets
 12290:       mPrefBranch->GetBoolPref("security.enable_tls_session_tickets", &enabled);
 12290:       SSL_OptionSetDefault(SSL_ENABLE_SESSION_TICKETS, enabled);
 12290: 
 37963:       mPrefBranch->GetBoolPref("security.ssl.require_safe_negotiation", &enabled);
 37963:       SSL_OptionSetDefault(SSL_REQUIRE_SAFE_NEGOTIATION, enabled);
 37963: 
 37963:       mPrefBranch->GetBoolPref(
 37963:         "security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref", 
 37963:         &enabled);
 37963:       SSL_OptionSetDefault(SSL_ENABLE_RENEGOTIATION, 
 37963:         enabled ? SSL_RENEGOTIATE_UNRESTRICTED : SSL_RENEGOTIATE_REQUIRES_XTN);
 37963: 
 49066: #ifdef SSL_ENABLE_FALSE_START // Requires NSS 3.12.8
 48768:       mPrefBranch->GetBoolPref("security.ssl.enable_false_start", &enabled);
 48768:       SSL_OptionSetDefault(SSL_ENABLE_FALSE_START, enabled);
 49066: #endif
 48768: 
     1:       // Disable any ciphers that NSS might have enabled by default
108991:       for (uint16_t i = 0; i < SSL_NumImplementedCiphers; ++i)
     1:       {
108991:         uint16_t cipher_id = SSL_ImplementedCiphers[i];
 80486:         SSL_CipherPrefSetDefault(cipher_id, false);
     1:       }
     1: 
     1:       // Now only set SSL/TLS ciphers we knew about at compile time
     1:       for (CipherPref* cp = CipherPrefs; cp->pref; ++cp) {
 32037:         rv = mPrefBranch->GetBoolPref(cp->pref, &enabled);
 32037:         if (NS_FAILED(rv))
 80486:           enabled = false;
     1: 
     1:         SSL_CipherPrefSetDefault(cp->id, enabled);
     1:       }
     1: 
     1:       // Enable ciphers for PKCS#12
     1:       SEC_PKCS12EnableCipher(PKCS12_RC4_40, 1);
     1:       SEC_PKCS12EnableCipher(PKCS12_RC4_128, 1);
     1:       SEC_PKCS12EnableCipher(PKCS12_RC2_CBC_40, 1);
     1:       SEC_PKCS12EnableCipher(PKCS12_RC2_CBC_128, 1);
     1:       SEC_PKCS12EnableCipher(PKCS12_DES_56, 1);
     1:       SEC_PKCS12EnableCipher(PKCS12_DES_EDE3_168, 1);
     1:       SEC_PKCS12SetPreferredCipher(PKCS12_DES_EDE3_168, 1);
     1:       PORT_SetUCS2_ASCIIConversionFunction(pip_ucs2_ascii_conversion_fn);
     1: 
 69383:       // dynamic options from prefs
 69383:       setValidationOptions(mPrefBranch);
 69383: 
 69383:       // static validation options for usagesarray - do not hit the network
 69383:       mDefaultCERTValInParamLocalOnly = new nsCERTValInParamWrapper;
 69383:       rv = mDefaultCERTValInParamLocalOnly->Construct(
 69383:           nsCERTValInParamWrapper::missing_cert_download_off,
 69383:           nsCERTValInParamWrapper::crl_local_only,
 69383:           nsCERTValInParamWrapper::ocsp_off,
 69383:           nsCERTValInParamWrapper::ocsp_relaxed,
 69383:           nsCERTValInParamWrapper::any_revo_relaxed,
 69385:           FIRST_REVO_METHOD_DEFAULT);
 69383:       if (NS_FAILED(rv)) {
 69383:         nsPSMInitPanic::SetPanic();
 69383:         return rv;
 69383:       }
 69383:       
 27009:       RegisterMyOCSPAIAInfoCallback();
     1: 
     1:       mHttpForNSS.initTable();
     1:       mHttpForNSS.registerHttpClient();
     1: 
     1:       InstallLoadableRoots();
     1: 
     1:       LaunchSmartCardThreads();
     1: 
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS Initialization done\n"));
     1:     }
     1:   }
     1: 
     1:   if (problem_none != which_nss_problem) {
 57159:     nsPSMInitPanic::SetPanic();
     1: 
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS problem, trying to bring up GUI error message\n"));
     1: 
     1:     // We might want to use different messages, depending on what failed.
     1:     // For now, let's use the same message.
     1:     if (showWarningBox) {
 81303:       ShowAlertFromStringBundle("NSSInitProblemX");
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::ShutdownNSS()
     1: {
     1:   // Can be called both during init and profile change,
     1:   // needs mutex protection.
     1:   
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent::ShutdownNSS\n"));
     1: 
 64576:   MutexAutoLock lock(mutex);
     1:   nsresult rv = NS_OK;
     1: 
     1:   if (hashTableCerts) {
     1:     PL_HashTableEnumerateEntries(hashTableCerts, certHashtable_clearEntry, 0);
     1:     PL_HashTableDestroy(hashTableCerts);
106838:     hashTableCerts = nullptr;
     1:   }
     1: 
     1:   if (mNSSInitialized) {
 80486:     mNSSInitialized = false;
     1: 
106838:     PK11_SetPasswordFunc((PK11PasswordFunc)nullptr);
     1:     mHttpForNSS.unregisterHttpClient();
 27009:     UnregisterMyOCSPAIAInfoCallback();
     1: 
     1:     if (mPrefBranch) {
 90039:       mPrefBranch->RemoveObserver("security.", this);
     1:     }
     1: 
     1:     ShutdownSmartCardThreads();
     1:     SSL_ClearSessionCache();
 28675:     if (mClientAuthRememberService) {
 28675:       mClientAuthRememberService->ClearRememberedDecisions();
 28675:     }
     1:     UnloadLoadableRoots();
 13140:     CleanupIdentityInfo();
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("evaporating psm resources\n"));
     1:     mShutdownObjectList->evaporateAllNSSResources();
 30802:     EnsureNSSInitialized(nssShutdown);
     1:     if (SECSuccess != ::NSS_Shutdown()) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_ALWAYS, ("NSS SHUTDOWN FAILURE\n"));
     1:       rv = NS_ERROR_FAILURE;
     1:     }
     1:     else {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS shutdown =====>> OK <<=====\n"));
     1:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1:  
     1: NS_IMETHODIMP
     1: nsNSSComponent::Init()
     1: {
     1:   // No mutex protection.
     1:   // Assume Init happens before any concurrency on "this" can start.
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Beginning NSS initialization\n"));
     1: 
 64576:   if (!mShutdownObjectList)
     1:   {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS init, out of memory in constructor\n"));
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   rv = InitializePIPNSSBundle();
     1:   if (NS_FAILED(rv)) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to create pipnss bundle.\n"));
     1:     return rv;
     1:   }      
     1: 
 14244:   // Access our string bundles now, this prevents assertions from I/O
 14244:   // - nsStandardURL not thread-safe
 14244:   // - wrong thread: 'NS_IsMainThread()' in nsIOService.cpp
 14244:   // when loading error strings on the SSL threads.
 14244:   {
 14244:     NS_NAMED_LITERAL_STRING(dummy_name, "dummy");
 14244:     nsXPIDLString result;
 14244:     mPIPNSSBundle->GetStringFromName(dummy_name.get(),
 14244:                                      getter_Copies(result));
 14244:     mNSSErrorsBundle->GetStringFromName(dummy_name.get(),
 14244:                                         getter_Copies(result));
 14244:   }
 14244: 
     1:   if (!mPrefBranch) {
     1:     mPrefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
     1:     NS_ASSERTION(mPrefBranch, "Unable to get pref service");
     1:   }
     1: 
     1:   // Do that before NSS init, to make sure we won't get unloaded.
     1:   RegisterObservers();
     1: 
 80486:   rv = InitializeNSS(true); // ok to show a warning box on failure
     1:   if (NS_FAILED(rv)) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to Initialize NSS.\n"));
 25625: 
 25625:     DeregisterObservers();
106838:     mPIPNSSBundle = nullptr;
     1:     return rv;
     1:   }
     1: 
 97210:   RememberCertErrorsTable::Init();
 25625:   nsSSLIOLayerHelpers::Init();
106838:   char *unrestricted_hosts=nullptr;
 37963:   mPrefBranch->GetCharPref("security.ssl.renego_unrestricted_hosts", &unrestricted_hosts);
 37963:   if (unrestricted_hosts) {
 37963:     nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(nsDependentCString(unrestricted_hosts));
 37963:     nsMemory::Free(unrestricted_hosts);
106838:     unrestricted_hosts=nullptr;
 37963:   }
 37963: 
 79445:   bool enabled = false;
 37963:   mPrefBranch->GetBoolPref("security.ssl.treat_unsafe_negotiation_as_broken", &enabled);
 37963:   nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(enabled);
 25625: 
108991:   int32_t warnLevel = 1;
 41739:   mPrefBranch->GetIntPref("security.ssl.warn_missing_rfc5746", &warnLevel);
 41739:   nsSSLIOLayerHelpers::setWarnLevelMissingRFC5746(warnLevel);
 41739:   
 28675:   mClientAuthRememberService = new nsClientAuthRememberService;
 28675:   if (mClientAuthRememberService)
 28675:     mClientAuthRememberService->Init();
 28675: 
 72444:   createBackgroundThreads();
 83083:   if (!mCertVerificationThread)
 25625:   {
 25625:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NSS init, could not create threads\n"));
 25625: 
 25625:     DeregisterObservers();
106838:     mPIPNSSBundle = nullptr;
 25625:     return NS_ERROR_OUT_OF_MEMORY;
 25625:   }
 25625: 
     1:   InitializeCRLUpdateTimer();
     1:   RegisterPSMContentListener();
     1: 
     1:   nsCOMPtr<nsIEntropyCollector> ec
     1:       = do_GetService(NS_ENTROPYCOLLECTOR_CONTRACTID);
     1: 
     1:   nsCOMPtr<nsIBufEntropyCollector> bec;
     1: 
     1:   if (ec) {
     1:     bec = do_QueryInterface(ec);
     1:   }
     1: 
     1:   NS_ASSERTION(bec, "No buffering entropy collector.  "
     1:                     "This means no entropy will be collected.");
     1:   if (bec) {
     1:     bec->ForwardTo(this);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* nsISupports Implementation for the class */
 56656: NS_IMPL_THREADSAFE_ISUPPORTS6(nsNSSComponent,
     1:                               nsISignatureVerifier,
     1:                               nsIEntropyCollector,
     1:                               nsINSSComponent,
     1:                               nsIObserver,
     1:                               nsISupportsWeakReference,
 56656:                               nsITimerCallback)
     1: 
     1: 
     1: /* Callback functions for decoder. For now, use empty/default functions. */
     1: static void ContentCallback(void *arg, 
     1:                                            const char *buf,
     1:                                            unsigned long len)
     1: {
     1: }
     1: 
     1: static PK11SymKey * GetDecryptKeyCallback(void *arg, 
     1:                                                  SECAlgorithmID *algid)
     1: {
106838:   return nullptr;
     1: }
     1: 
     1: static PRBool DecryptionAllowedCallback(SECAlgorithmID *algid,  
     1:                                                PK11SymKey *bulkkey)
     1: {
     1:   return SECMIME_DecryptionAllowed(algid, bulkkey);
     1: }
     1: 
     1: static void * GetPasswordKeyCallback(void *arg, void *handle)
     1: {
119832:   return NULL;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSComponent::VerifySignature(const char* aRSABuf, uint32_t aRSABufLen,
108991:                                 const char* aPlaintext, uint32_t aPlaintextLen,
108991:                                 int32_t* aErrorCode,
119653:                                 nsICertificatePrincipal** aPrincipal)
     1: {
     1:   if (!aPrincipal || !aErrorCode) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   *aErrorCode = 0;
106838:   *aPrincipal = nullptr;
     1: 
     1:   nsNSSShutDownPreventionLock locker;
106838:   SEC_PKCS7ContentInfo * p7_info = nullptr; 
     1:   unsigned char hash[SHA1_LENGTH]; 
     1: 
     1:   SECItem item;
     1:   item.type = siEncodedCertBuffer;
     1:   item.data = (unsigned char*)aRSABuf;
     1:   item.len = aRSABufLen;
     1:   p7_info = SEC_PKCS7DecodeItem(&item,
106838:                                 ContentCallback, nullptr,
106838:                                 GetPasswordKeyCallback, nullptr,
106838:                                 GetDecryptKeyCallback, nullptr,
     1:                                 DecryptionAllowedCallback);
     1: 
     1:   if (!p7_info) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   // Make sure we call SEC_PKCS7DestroyContentInfo after this point;
     1:   // otherwise we leak data in p7_info
     1:   
     1:   //-- If a plaintext was provided, hash it.
     1:   SECItem digest;
106838:   digest.data = nullptr;
     1:   digest.len = 0;
     1: 
     1:   if (aPlaintext) {
     1:     HASHContext* hash_ctxt;
108991:     uint32_t hashLen = 0;
     1: 
     1:     hash_ctxt = HASH_Create(HASH_AlgSHA1);
     1:     HASH_Begin(hash_ctxt);
     1:     HASH_Update(hash_ctxt,(const unsigned char*)aPlaintext, aPlaintextLen);
     1:     HASH_End(hash_ctxt, hash, &hashLen, SHA1_LENGTH); 
     1:     HASH_Destroy(hash_ctxt);
     1: 
     1:     digest.data = hash;
     1:     digest.len = SHA1_LENGTH;
     1:   }
     1: 
     1:   //-- Verify signature
 79445:   bool rv = SEC_PKCS7VerifyDetachedSignature(p7_info, certUsageObjectSigner,
 80486:                                                &digest, HASH_AlgSHA1, false);
 17116:   if (!rv) {
     1:     *aErrorCode = PR_GetError();
     1:   }
     1: 
     1:   // Get the signing cert //
     1:   CERTCertificate *cert = p7_info->content.signedData->signerInfos[0]->cert;
     1:   nsresult rv2 = NS_OK;
     1:   if (cert) {
     1:     // Use |do { } while (0);| as a "more C++-ish" thing than goto;
     1:     // this way we don't have to worry about goto across variable
     1:     // declarations.  We have no loops in this code, so it's OK.
     1:     do {
 56495:       nsCOMPtr<nsIX509Cert> pCert = nsNSSCertificate::Create(cert);
     1:       if (!pCert) {
     1:         rv2 = NS_ERROR_OUT_OF_MEMORY;
     1:         break;
     1:       }
     1: 
     1:       if (!mScriptSecurityManager) {
 64576:         MutexAutoLock lock(mutex);
     1:         // re-test the condition to prevent double initialization
     1:         if (!mScriptSecurityManager) {
     1:           mScriptSecurityManager = 
     1:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv2);
     1:           if (NS_FAILED(rv2)) {
     1:             break;
     1:           }
     1:         }
     1:       }
     1: 
     1:       //-- Create a certificate principal with id and organization data
     1:       nsAutoString fingerprint;
     1:       rv2 = pCert->GetSha1Fingerprint(fingerprint);
     1:       if (NS_FAILED(rv2)) {
     1:         break;
     1:       }
     1:       nsAutoString orgName;
     1:       rv2 = pCert->GetOrganization(orgName);
     1:       if (NS_FAILED(rv2)) {
     1:         break;
     1:       }
     1:       nsAutoString subjectName;
     1:       rv2 = pCert->GetSubjectName(subjectName);
     1:       if (NS_FAILED(rv2)) {
     1:         break;
     1:       }
     1:     
119653:       nsCOMPtr<nsICertificatePrincipal> certPrincipal =
119653:         new nsCertificatePrincipal(NS_ConvertUTF16toUTF8(fingerprint),
     1:                                    NS_ConvertUTF16toUTF8(subjectName),
     1:                                    NS_ConvertUTF16toUTF8(orgName),
119653:                                    pCert);
     1: 
     1:       certPrincipal.swap(*aPrincipal);
     1:     } while (0);
     1:   }
     1: 
     1:   SEC_PKCS7DestroyContentInfo(p7_info);
     1: 
     1:   return rv2;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSComponent::RandomUpdate(void *entropy, int32_t bufLen)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1: 
     1:   // Asynchronous event happening often,
     1:   // must not interfere with initialization or profile switch.
     1:   
 64576:   MutexAutoLock lock(mutex);
     1: 
     1:   if (!mNSSInitialized)
     1:       return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   PK11_RandomUpdate(entropy, bufLen);
     1:   return NS_OK;
     1: }
     1: 
     1: #define PROFILE_CHANGE_NET_TEARDOWN_TOPIC "profile-change-net-teardown"
     1: #define PROFILE_CHANGE_NET_RESTORE_TOPIC "profile-change-net-restore"
     1: #define PROFILE_APPROVE_CHANGE_TOPIC "profile-approve-change"
     1: #define PROFILE_CHANGE_TEARDOWN_TOPIC "profile-change-teardown"
     1: #define PROFILE_CHANGE_TEARDOWN_VETO_TOPIC "profile-change-teardown-veto"
     1: #define PROFILE_BEFORE_CHANGE_TOPIC "profile-before-change"
 53774: #define PROFILE_DO_CHANGE_TOPIC "profile-do-change"
     1: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::Observe(nsISupports *aSubject, const char *aTopic, 
     1:                         const PRUnichar *someData)
     1: {
     1:   if (nsCRT::strcmp(aTopic, PROFILE_APPROVE_CHANGE_TOPIC) == 0) {
  1427:     DoProfileApproveChange(aSubject);
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_TEARDOWN_TOPIC) == 0) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("in PSM code, receiving change-teardown\n"));
  1427:     DoProfileChangeTeardown(aSubject);
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_TEARDOWN_VETO_TOPIC) == 0) {
     1:     mShutdownObjectList->allowUI();
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, PROFILE_BEFORE_CHANGE_TOPIC) == 0) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("receiving profile change topic\n"));
  1427:     DoProfileBeforeChange(aSubject);
     1:   }
 53774:   else if (nsCRT::strcmp(aTopic, PROFILE_DO_CHANGE_TOPIC) == 0) {
  1427:     if (someData && NS_LITERAL_STRING("startup").Equals(someData)) {
  1427:       // The application is initializing against a known profile directory for
  1427:       // the first time during process execution.
  1427:       // However, earlier code execution might have already triggered NSS init.
  1427:       // We must ensure that NSS gets shut down prior to any attempt to init
  1427:       // it again. We use the same cleanup functionality used when switching
  1427:       // profiles. The order of function calls must correspond to the order
  1427:       // of notifications sent by Profile Manager (nsProfile).
  1427:       DoProfileApproveChange(aSubject);
  1427:       DoProfileChangeNetTeardown();
  1427:       DoProfileChangeTeardown(aSubject);
  1427:       DoProfileBeforeChange(aSubject);
  1427:       DoProfileChangeNetRestore();
  1427:     }
     1:   
 79445:     bool needsInit = true;
     1: 
     1:     {
 64576:       MutexAutoLock lock(mutex);
     1: 
     1:       if (mNSSInitialized) {
     1:         // We have already initialized NSS before the profile came up,
     1:         // no need to do it again
 80486:         needsInit = false;
     1:       }
     1:     }
     1:     
     1:     if (needsInit) {
 80486:       if (NS_FAILED(InitializeNSS(false))) { // do not show a warning box on failure
     1:         PR_LOG(gPIPNSSLog, PR_LOG_ERROR, ("Unable to Initialize NSS after profile switch.\n"));
     1:         nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
     1:         if (status) {
     1:           status->ChangeFailed();
     1:         }
     1:       }
     1:     }
     1: 
     1:     InitializeCRLUpdateTimer();
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
     1: 
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: XPCom shutdown observed\n"));
     1: 
     1:     // Cleanup code that requires services, it's too late in destructor.
     1: 
     1:     if (mPSMContentListener) {
     1:       nsCOMPtr<nsIURILoader> dispatcher(do_GetService(NS_URI_LOADER_CONTRACTID));
     1:       if (dispatcher) {
 90628:         dispatcher->UnRegisterContentListener(mPSMContentListener);
     1:       }
106838:       mPSMContentListener = nullptr;
     1:     }
     1: 
     1:     nsCOMPtr<nsIEntropyCollector> ec
     1:         = do_GetService(NS_ENTROPYCOLLECTOR_CONTRACTID);
     1: 
     1:     if (ec) {
     1:       nsCOMPtr<nsIBufEntropyCollector> bec
     1:         = do_QueryInterface(ec);
     1:       if (bec) {
     1:         bec->DontForward();
     1:       }
     1:     }
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) == 0) { 
     1:     nsNSSShutDownPreventionLock locker;
 79445:     bool clearSessionCache = false;
 79445:     bool enabled;
     1:     NS_ConvertUTF16toUTF8  prefName(someData);
     1: 
 76375:     if (prefName.Equals("security.enable_ssl3")) {
     1:       mPrefBranch->GetBoolPref("security.enable_ssl3", &enabled);
     1:       SSL_OptionSetDefault(SSL_ENABLE_SSL3, enabled);
 80486:       clearSessionCache = true;
     1:     } else if (prefName.Equals("security.enable_tls")) {
     1:       mPrefBranch->GetBoolPref("security.enable_tls", &enabled);
     1:       SSL_OptionSetDefault(SSL_ENABLE_TLS, enabled);
 80486:       clearSessionCache = true;
 92004:     } else if (prefName.Equals("security.enable_md5_signatures")) {
 92004:       mPrefBranch->GetBoolPref("security.enable_md5_signatures", &enabled);
 92004:       configureMD5(enabled);
 92004:       clearSessionCache = true;
 12290:     } else if (prefName.Equals("security.enable_tls_session_tickets")) {
 12290:       mPrefBranch->GetBoolPref("security.enable_tls_session_tickets", &enabled);
 12290:       SSL_OptionSetDefault(SSL_ENABLE_SESSION_TICKETS, enabled);
 37963:     } else if (prefName.Equals("security.ssl.require_safe_negotiation")) {
 37963:       mPrefBranch->GetBoolPref("security.ssl.require_safe_negotiation", &enabled);
 37963:       SSL_OptionSetDefault(SSL_REQUIRE_SAFE_NEGOTIATION, enabled);
 37963:     } else if (prefName.Equals("security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref")) {
 37963:       mPrefBranch->GetBoolPref("security.ssl.allow_unrestricted_renego_everywhere__temporarily_available_pref", &enabled);
 37963:       SSL_OptionSetDefault(SSL_ENABLE_RENEGOTIATION, 
 37963:         enabled ? SSL_RENEGOTIATE_UNRESTRICTED : SSL_RENEGOTIATE_REQUIRES_XTN);
 37963:     } else if (prefName.Equals("security.ssl.renego_unrestricted_hosts")) {
106838:       char *unrestricted_hosts=nullptr;
 37963:       mPrefBranch->GetCharPref("security.ssl.renego_unrestricted_hosts", &unrestricted_hosts);
 37963:       if (unrestricted_hosts) {
 37963:         nsSSLIOLayerHelpers::setRenegoUnrestrictedSites(nsDependentCString(unrestricted_hosts));
 37963:         nsMemory::Free(unrestricted_hosts);
 37963:       }
 37963:     } else if (prefName.Equals("security.ssl.treat_unsafe_negotiation_as_broken")) {
 37963:       mPrefBranch->GetBoolPref("security.ssl.treat_unsafe_negotiation_as_broken", &enabled);
 37963:       nsSSLIOLayerHelpers::setTreatUnsafeNegotiationAsBroken(enabled);
 41739:     } else if (prefName.Equals("security.ssl.warn_missing_rfc5746")) {
108991:       int32_t warnLevel = 1;
 41739:       mPrefBranch->GetIntPref("security.ssl.warn_missing_rfc5746", &warnLevel);
 41739:       nsSSLIOLayerHelpers::setWarnLevelMissingRFC5746(warnLevel);
 49066: #ifdef SSL_ENABLE_FALSE_START // Requires NSS 3.12.8
 48768:     } else if (prefName.Equals("security.ssl.enable_false_start")) {
 48768:       mPrefBranch->GetBoolPref("security.ssl.enable_false_start", &enabled);
 48768:       SSL_OptionSetDefault(SSL_ENABLE_FALSE_START, enabled);
 49066: #endif
  2018:     } else if (prefName.Equals("security.OCSP.enabled")
 69383:                || prefName.Equals("security.CRL_download.enabled")
 69383:                || prefName.Equals("security.fresh_revocation_info.require")
 69383:                || prefName.Equals("security.missing_cert_download.enabled")
 69383:                || prefName.Equals("security.first_network_revocation_method")
  2018:                || prefName.Equals("security.OCSP.require")) {
 69383:       MutexAutoLock lock(mutex);
 69383:       setValidationOptions(mPrefBranch);
     1:     } else {
     1:       /* Look through the cipher table and set according to pref setting */
     1:       for (CipherPref* cp = CipherPrefs; cp->pref; ++cp) {
     1:         if (prefName.Equals(cp->pref)) {
     1:           mPrefBranch->GetBoolPref(cp->pref, &enabled);
     1:           SSL_CipherPrefSetDefault(cp->id, enabled);
 80486:           clearSessionCache = true;
     1:           break;
     1:         }
     1:       }
     1:     }
     1:     if (clearSessionCache)
     1:       SSL_ClearSessionCache();
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_NET_TEARDOWN_TOPIC) == 0) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("receiving network teardown topic\n"));
  1427:     DoProfileChangeNetTeardown();
     1:   }
     1:   else if (nsCRT::strcmp(aTopic, PROFILE_CHANGE_NET_RESTORE_TOPIC) == 0) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("receiving network restore topic\n"));
  1427:     DoProfileChangeNetRestore();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 81303: /*static*/ nsresult
 81303: nsNSSComponent::GetNewPrompter(nsIPrompt ** result)
 81303: {
 81303:   NS_ENSURE_ARG_POINTER(result);
106838:   *result = nullptr;
 81303: 
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("nsSDRContext::GetNewPrompter called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303: 
 81303:   nsresult rv;
 81303:   nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv));
 81303:   NS_ENSURE_SUCCESS(rv, rv);
 81303: 
 81303:   rv = wwatch->GetNewPrompter(0, result);
 81303:   NS_ENSURE_SUCCESS(rv, rv);
 81303: 
 81303:   return rv;
 81303: }
 81303: 
 81303: /*static*/ nsresult
 81303: nsNSSComponent::ShowAlertWithConstructedString(const nsString & message)
 81303: {
 81303:   nsCOMPtr<nsIPrompt> prompter;
 81303:   nsresult rv = GetNewPrompter(getter_AddRefs(prompter));
 81303:   if (prompter) {
 81303:     nsPSMUITracker tracker;
 81303:     if (tracker.isUIForbidden()) {
 81303:       NS_WARNING("Suppressing alert because PSM UI is forbidden");
 81303:       rv = NS_ERROR_UNEXPECTED;
 81303:     } else {
106838:       rv = prompter->Alert(nullptr, message.get());
 81303:     }
 81303:   }
 81303:   return rv;
 81303: }
 81303: 
 81303: NS_IMETHODIMP
 81303: nsNSSComponent::ShowAlertFromStringBundle(const char * messageID)
     1: {
     1:   nsString message;
     1:   nsresult rv;
     1: 
 81303:   rv = GetPIPNSSBundleString(messageID, message);
 81303:   if (NS_FAILED(rv)) {
 81303:     NS_ERROR("GetPIPNSSBundleString failed");
 81303:     return rv;
 81303:   }
 81303: 
 81303:   return ShowAlertWithConstructedString(message);
     1: }
     1: 
     1: nsresult nsNSSComponent::LogoutAuthenticatedPK11()
     1: {
 20772:   nsCOMPtr<nsICertOverrideService> icos =
 20772:     do_GetService("@mozilla.org/security/certoverride;1");
 58265:   if (icos) {
 58265:     icos->ClearValidityOverride(
 58265:             NS_LITERAL_CSTRING("all:temporary-certificates"),
 58265:             0);
 20772:   }
 20772: 
 28675:   if (mClientAuthRememberService) {
 28675:     mClientAuthRememberService->ClearRememberedDecisions();
 28675:   }
 28675: 
     1:   return mShutdownObjectList->doPK11Logout();
     1: }
     1: 
     1: nsresult
     1: nsNSSComponent::RegisterObservers()
     1: {
     1:   // Happens once during init only, no mutex protection.
     1: 
     1:   nsCOMPtr<nsIObserverService> observerService(do_GetService("@mozilla.org/observer-service;1"));
     1:   NS_ASSERTION(observerService, "could not get observer service");
     1:   if (observerService) {
 80486:     mObserversRegistered = true;
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: adding observers\n"));
     1: 
     1:     // We are a service.
     1:     // Once we are loaded, don't allow being removed from memory.
     1:     // This makes sense, as initializing NSS is expensive.
     1: 
 80486:     // By using false for parameter ownsWeak in AddObserver,
     1:     // we make sure that we won't get unloaded until the application shuts down.
     1: 
 80486:     observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);
 80486: 
 80486:     observerService->AddObserver(this, PROFILE_APPROVE_CHANGE_TOPIC, false);
 80486:     observerService->AddObserver(this, PROFILE_CHANGE_TEARDOWN_TOPIC, false);
 80486:     observerService->AddObserver(this, PROFILE_CHANGE_TEARDOWN_VETO_TOPIC, false);
 80486:     observerService->AddObserver(this, PROFILE_BEFORE_CHANGE_TOPIC, false);
 80486:     observerService->AddObserver(this, PROFILE_DO_CHANGE_TOPIC, false);
 80486:     observerService->AddObserver(this, PROFILE_CHANGE_NET_TEARDOWN_TOPIC, false);
 80486:     observerService->AddObserver(this, PROFILE_CHANGE_NET_RESTORE_TOPIC, false);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 25625: nsresult
 25625: nsNSSComponent::DeregisterObservers()
 25625: {
 25625:   if (!mObserversRegistered)
 25625:     return NS_OK;
 25625: 
 25625:   nsCOMPtr<nsIObserverService> observerService(do_GetService("@mozilla.org/observer-service;1"));
 25625:   NS_ASSERTION(observerService, "could not get observer service");
 25625:   if (observerService) {
 80486:     mObserversRegistered = false;
 25625:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsNSSComponent: removing observers\n"));
 25625: 
 25625:     observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
 25625: 
 25625:     observerService->RemoveObserver(this, PROFILE_APPROVE_CHANGE_TOPIC);
 25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_TEARDOWN_TOPIC);
 25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_TEARDOWN_VETO_TOPIC);
 25625:     observerService->RemoveObserver(this, PROFILE_BEFORE_CHANGE_TOPIC);
 53774:     observerService->RemoveObserver(this, PROFILE_DO_CHANGE_TOPIC);
 25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_NET_TEARDOWN_TOPIC);
 25625:     observerService->RemoveObserver(this, PROFILE_CHANGE_NET_RESTORE_TOPIC);
 25625:   }
 25625:   return NS_OK;
 25625: }
 25625: 
     1: NS_IMETHODIMP
     1: nsNSSComponent::RememberCert(CERTCertificate *cert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1: 
     1:   // Must not interfere with init / shutdown / profile switch.
     1: 
 64576:   MutexAutoLock lock(mutex);
     1: 
     1:   if (!hashTableCerts || !cert)
     1:     return NS_OK;
     1:   
     1:   void *found = PL_HashTableLookup(hashTableCerts, (void*)&cert->certKey);
     1:   
     1:   if (found) {
     1:     // we remember that cert already
     1:     return NS_OK;
     1:   }
     1:   
     1:   CERTCertificate *myDupCert = CERT_DupCertificate(cert);
     1:   
     1:   if (!myDupCert)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   
     1:   if (!PL_HashTableAdd(hashTableCerts, (void*)&myDupCert->certKey, myDupCert)) {
     1:     CERT_DestroyCertificate(myDupCert);
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
 81303: static const char PROFILE_SWITCH_CRYPTO_UI_ACTIVE[] =
 81303:                         "ProfileSwitchCryptoUIActive";
 81303: static const char PROFILE_SWITCH_SOCKETS_STILL_ACTIVE[] =
 81303:                         "ProfileSwitchSocketsStillActive";
 81303: 
  1427: void
  1427: nsNSSComponent::DoProfileApproveChange(nsISupports* aSubject)
  1427: {
  1427:   if (mShutdownObjectList->isUIActive()) {
 81303:     ShowAlertFromStringBundle(PROFILE_SWITCH_CRYPTO_UI_ACTIVE);
  1427:     nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
  1427:     if (status) {
  1427:       status->VetoChange();
  1427:     }
  1427:   }
  1427: }
  1427: 
  1427: void
  1427: nsNSSComponent::DoProfileChangeNetTeardown()
  1427: {
  1427:   if (mCertVerificationThread)
  1427:     mCertVerificationThread->requestExit();
 80486:   mIsNetworkDown = true;
  1427: }
  1427: 
  1427: void
  1427: nsNSSComponent::DoProfileChangeTeardown(nsISupports* aSubject)
  1427: {
 79445:   bool callVeto = false;
  1427: 
  1427:   if (!mShutdownObjectList->ifPossibleDisallowUI()) {
 80486:     callVeto = true;
 81303:     ShowAlertFromStringBundle(PROFILE_SWITCH_CRYPTO_UI_ACTIVE);
  1427:   }
  1427:   else if (mShutdownObjectList->areSSLSocketsActive()) {
 80486:     callVeto = true;
 81303:     ShowAlertFromStringBundle(PROFILE_SWITCH_SOCKETS_STILL_ACTIVE);
  1427:   }
  1427: 
  1427:   if (callVeto) {
  1427:     nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
  1427:     if (status) {
  1427:       status->VetoChange();
  1427:     }
  1427:   }
  1427: }
  1427: 
  1427: void
  1427: nsNSSComponent::DoProfileBeforeChange(nsISupports* aSubject)
  1427: {
  1427:   NS_ASSERTION(mIsNetworkDown, "nsNSSComponent relies on profile manager to wait for synchronous shutdown of all network activity");
  1427: 
 79445:   bool needsCleanup = true;
  1427: 
  1427:   {
 64576:     MutexAutoLock lock(mutex);
  1427: 
  1427:     if (!mNSSInitialized) {
  1427:       // Make sure we don't try to cleanup if we have already done so.
  1427:       // This makes sure we behave safely, in case we are notified
  1427:       // multiple times.
 80486:       needsCleanup = false;
  1427:     }
  1427:   }
  1427:     
  1427:   StopCRLUpdateTimer();
  1427: 
  1427:   if (needsCleanup) {
  1427:     if (NS_FAILED(ShutdownNSS())) {
  1427:       nsCOMPtr<nsIProfileChangeStatus> status = do_QueryInterface(aSubject);
  1427:       if (status) {
  1427:         status->ChangeFailed();
  1427:       }
  1427:     }
  1427:   }
  1427:   mShutdownObjectList->allowUI();
  1427: }
  1427: 
  1427: void
  1427: nsNSSComponent::DoProfileChangeNetRestore()
  1427: {
 72444:   /* XXX this doesn't work well, since nothing expects null pointers */
 72444:   deleteBackgroundThreads();
 72444:   createBackgroundThreads();
 80486:   mIsNetworkDown = false;
  1427: }
  1427: 
 28675: NS_IMETHODIMP
 28675: nsNSSComponent::GetClientAuthRememberService(nsClientAuthRememberService **cars)
 28675: {
 28675:   NS_ENSURE_ARG_POINTER(cars);
 28675:   NS_IF_ADDREF(*cars = mClientAuthRememberService);
 28675:   return NS_OK;
 28675: }
 28675: 
 29543: NS_IMETHODIMP
 79445: nsNSSComponent::IsNSSInitialized(bool *initialized)
 29543: {
 64576:   MutexAutoLock lock(mutex);
 29543:   *initialized = mNSSInitialized;
 29543:   return NS_OK;
 29543: }
 29543: 
 69383: NS_IMETHODIMP
119832: nsNSSComponent::GetDefaultCERTValInParam(nsRefPtr<nsCERTValInParamWrapper> &out)
 69383: {
 69383:   MutexAutoLock lock(mutex);
 69383:   if (!mNSSInitialized)
 69383:       return NS_ERROR_NOT_INITIALIZED;
 69383:   out = mDefaultCERTValInParam;
 69383:   return NS_OK;
 69383: }
 69383: 
 69383: NS_IMETHODIMP
119832: nsNSSComponent::GetDefaultCERTValInParamLocalOnly(nsRefPtr<nsCERTValInParamWrapper> &out)
 69383: {
 69383:   MutexAutoLock lock(mutex);
 69383:   if (!mNSSInitialized)
 69383:       return NS_ERROR_NOT_INITIALIZED;
 69383:   out = mDefaultCERTValInParamLocalOnly;
 69383:   return NS_OK;
 69383: }
 69383: 
     1: //---------------------------------------------
     1: // Implementing nsICryptoHash
     1: //---------------------------------------------
     1: 
     1: nsCryptoHash::nsCryptoHash()
106838:   : mHashContext(nullptr)
 80486:   , mInitialized(false)
     1: {
     1: }
     1: 
     1: nsCryptoHash::~nsCryptoHash()
     1: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 30802:   if (isAlreadyShutDown())
 30802:     return;
 30802: 
 30802:   destructorSafeDestroyNSSReference();
 30802:   shutdown(calledFromObject);
 30802: }
 30802: 
 30802: void nsCryptoHash::virtualDestroyNSSReference()
 30802: {
 30802:   destructorSafeDestroyNSSReference();
 30802: }
 30802: 
 30802: void nsCryptoHash::destructorSafeDestroyNSSReference()
 30802: {
 30802:   if (isAlreadyShutDown())
 30802:     return;
 30802: 
     1:   if (mHashContext)
     1:     HASH_Destroy(mHashContext);
106838:   mHashContext = nullptr;
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(nsCryptoHash, nsICryptoHash)
     1: 
     1: NS_IMETHODIMP 
108991: nsCryptoHash::Init(uint32_t algorithm)
     1: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 29646:   HASH_HashType hashType = (HASH_HashType)algorithm;
     1:   if (mHashContext)
 29646:   {
 29646:     if ((!mInitialized) && (HASH_GetType(mHashContext) == hashType))
 29646:     {
 80486:       mInitialized = true;
 29646:       HASH_Begin(mHashContext);
 29646:       return NS_OK;
 29646:     }
 29646: 
 29646:     // Destroy current hash context if the type was different
 29646:     // or Finish method wasn't called.
     1:     HASH_Destroy(mHashContext);
 80486:     mInitialized = false;
 29646:   }
 29646: 
 29646:   mHashContext = HASH_Create(hashType);
     1:   if (!mHashContext)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
     1:   HASH_Begin(mHashContext);
 80486:   mInitialized = true;
     1:   return NS_OK; 
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCryptoHash::InitWithString(const nsACString & aAlgorithm)
     1: {
     1:   if (aAlgorithm.LowerCaseEqualsLiteral("md2"))
     1:     return Init(nsICryptoHash::MD2);
     1: 
     1:   if (aAlgorithm.LowerCaseEqualsLiteral("md5"))
     1:     return Init(nsICryptoHash::MD5);
     1: 
     1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha1"))
     1:     return Init(nsICryptoHash::SHA1);
     1: 
     1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha256"))
     1:     return Init(nsICryptoHash::SHA256);
     1: 
     1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha384"))
     1:     return Init(nsICryptoHash::SHA384);
     1: 
     1:   if (aAlgorithm.LowerCaseEqualsLiteral("sha512"))
     1:     return Init(nsICryptoHash::SHA512);
     1: 
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsCryptoHash::Update(const uint8_t *data, uint32_t len)
     1: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802:   
 29646:   if (!mInitialized)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   HASH_Update(mHashContext, data, len);
     1:   return NS_OK; 
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsCryptoHash::UpdateFromStream(nsIInputStream *data, uint32_t aLen)
     1: {
 29646:   if (!mInitialized)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   if (!data)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
108991:   uint64_t n;
     1:   nsresult rv = data->Available(&n);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
115367:   // if the user has passed UINT32_MAX, then read
     1:   // everything in the stream
     1: 
108991:   uint64_t len = aLen;
115367:   if (aLen == UINT32_MAX)
     1:     len = n;
     1: 
     1:   // So, if the stream has NO data available for the hash,
     1:   // or if the data available is less then what the caller
     1:   // requested, we can not fulfill the hash update.  In this
     1:   // case, just return NS_ERROR_NOT_AVAILABLE indicating
     1:   // that there is not enough data in the stream to satisify
     1:   // the request.
     1: 
     1:   if (n == 0 || n < len)
     1:     return NS_ERROR_NOT_AVAILABLE;
     1:   
     1:   char buffer[NS_CRYPTO_HASH_BUFFER_SIZE];
108991:   uint32_t read, readLimit;
     1:   
     1:   while(NS_SUCCEEDED(rv) && len>0)
     1:   {
108991:     readLimit = (uint32_t)NS_MIN<uint64_t>(NS_CRYPTO_HASH_BUFFER_SIZE, len);
 12341:     
 12341:     rv = data->Read(buffer, readLimit, &read);
     1:     
     1:     if (NS_SUCCEEDED(rv))
108991:       rv = Update((const uint8_t*)buffer, read);
     1:     
     1:     len -= read;
     1:   }
     1:   
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsCryptoHash::Finish(bool ascii, nsACString & _retval)
     1: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802:   
 29646:   if (!mInitialized)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   
108991:   uint32_t hashLen = 0;
     1:   unsigned char buffer[HASH_LENGTH_MAX];
     1:   unsigned char* pbuffer = buffer;
     1: 
  2253:   HASH_End(mHashContext, pbuffer, &hashLen, HASH_LENGTH_MAX);
 29646: 
 80486:   mInitialized = false;
     1: 
     1:   if (ascii)
     1:   {
     1:     char *asciiData = BTOA_DataToAscii(buffer, hashLen);
 12341:     NS_ENSURE_TRUE(asciiData, NS_ERROR_OUT_OF_MEMORY);
 12341: 
     1:     _retval.Assign(asciiData);
     1:     PORT_Free(asciiData);
     1:   }
     1:   else
     1:   {
     1:     _retval.Assign((const char*)buffer, hashLen);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 12341: //---------------------------------------------
 12341: // Implementing nsICryptoHMAC
 12341: //---------------------------------------------
 12341: 
 12341: NS_IMPL_ISUPPORTS1(nsCryptoHMAC, nsICryptoHMAC)
 12341: 
 12341: nsCryptoHMAC::nsCryptoHMAC()
 12341: {
106838:   mHMACContext = nullptr;
 12341: }
 12341: 
 12341: nsCryptoHMAC::~nsCryptoHMAC()
 12341: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 30802:   if (isAlreadyShutDown())
 30802:     return;
 30802: 
 30802:   destructorSafeDestroyNSSReference();
 30802:   shutdown(calledFromObject);
 30802: }
 30802: 
 30802: void nsCryptoHMAC::virtualDestroyNSSReference()
 30802: {
 30802:   destructorSafeDestroyNSSReference();
 30802: }
 30802: 
 30802: void nsCryptoHMAC::destructorSafeDestroyNSSReference()
 30802: {
 30802:   if (isAlreadyShutDown())
 30802:     return;
 30802: 
 12341:   if (mHMACContext)
 80486:     PK11_DestroyContext(mHMACContext, true);
106838:   mHMACContext = nullptr;
 12341: }
 12341: 
 13256: /* void init (in unsigned long aAlgorithm, in nsIKeyObject aKeyObject); */
108991: NS_IMETHODIMP nsCryptoHMAC::Init(uint32_t aAlgorithm, nsIKeyObject *aKeyObject)
 12341: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 12341:   if (mHMACContext)
 12341:   {
 80486:     PK11_DestroyContext(mHMACContext, true);
106838:     mHMACContext = nullptr;
 12341:   }
 12341: 
 12341:   CK_MECHANISM_TYPE HMACMechType;
 12341:   switch (aAlgorithm)
 12341:   {
 12341:   case nsCryptoHMAC::MD2:
 12341:     HMACMechType = CKM_MD2_HMAC; break;
 12341:   case nsCryptoHMAC::MD5:
 12341:     HMACMechType = CKM_MD5_HMAC; break;
 12341:   case nsCryptoHMAC::SHA1:
 12341:     HMACMechType = CKM_SHA_1_HMAC; break;
 12341:   case nsCryptoHMAC::SHA256:
 12341:     HMACMechType = CKM_SHA256_HMAC; break;
 12341:   case nsCryptoHMAC::SHA384:
 12341:     HMACMechType = CKM_SHA384_HMAC; break;
 12341:   case nsCryptoHMAC::SHA512:
 12341:     HMACMechType = CKM_SHA512_HMAC; break;
 12341:   default:
 12341:     return NS_ERROR_INVALID_ARG;
 12341:   }
 12341: 
 13256:   NS_ENSURE_ARG_POINTER(aKeyObject);
 13256: 
 13256:   nsresult rv;
 13256: 
108991:   int16_t keyType;
 13256:   rv = aKeyObject->GetType(&keyType);
 13256:   NS_ENSURE_SUCCESS(rv, rv);
 13256: 
 13256:   NS_ENSURE_TRUE(keyType == nsIKeyObject::SYM_KEY, NS_ERROR_INVALID_ARG);
 13256: 
 13256:   PK11SymKey* key;
 13256:   // GetKeyObj doesn't addref the key
 13256:   rv = aKeyObject->GetKeyObj((void**)&key);
 13256:   NS_ENSURE_SUCCESS(rv, rv);
 12341: 
 12341:   SECItem rawData;
 12341:   rawData.data = 0;
 12341:   rawData.len = 0;
 12341:   mHMACContext = PK11_CreateContextBySymKey(
 12341:       HMACMechType, CKA_SIGN, key, &rawData);
 12341:   NS_ENSURE_TRUE(mHMACContext, NS_ERROR_FAILURE);
 12341: 
 12341:   SECStatus ss = PK11_DigestBegin(mHMACContext);
 12341:   NS_ENSURE_TRUE(ss == SECSuccess, NS_ERROR_FAILURE);
 12341: 
 12341:   return NS_OK;
 12341: }
 12341: 
 12341: /* void update ([array, size_is (aLen), const] in octet aData, in unsigned long aLen); */
108991: NS_IMETHODIMP nsCryptoHMAC::Update(const uint8_t *aData, uint32_t aLen)
 12341: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 12341:   if (!mHMACContext)
 12341:     return NS_ERROR_NOT_INITIALIZED;
 12341: 
 12341:   if (!aData)
 12341:     return NS_ERROR_INVALID_ARG;
 12341: 
 12341:   SECStatus ss = PK11_DigestOp(mHMACContext, aData, aLen);
 12341:   NS_ENSURE_TRUE(ss == SECSuccess, NS_ERROR_FAILURE);
 12341:   
 12341:   return NS_OK;
 12341: }
 12341: 
 12341: /* void updateFromStream (in nsIInputStream aStream, in unsigned long aLen); */
108991: NS_IMETHODIMP nsCryptoHMAC::UpdateFromStream(nsIInputStream *aStream, uint32_t aLen)
 12341: {
 12341:   if (!mHMACContext)
 12341:     return NS_ERROR_NOT_INITIALIZED;
 12341: 
 12341:   if (!aStream)
 12341:     return NS_ERROR_INVALID_ARG;
 12341: 
108991:   uint64_t n;
 12341:   nsresult rv = aStream->Available(&n);
 12341:   if (NS_FAILED(rv))
 12341:     return rv;
 12341: 
115367:   // if the user has passed UINT32_MAX, then read
 12341:   // everything in the stream
 12341: 
108991:   uint64_t len = aLen;
115367:   if (aLen == UINT32_MAX)
108154:     len = n;
 12341: 
 12341:   // So, if the stream has NO data available for the hash,
 12341:   // or if the data available is less then what the caller
 12341:   // requested, we can not fulfill the HMAC update.  In this
 12341:   // case, just return NS_ERROR_NOT_AVAILABLE indicating
 12341:   // that there is not enough data in the stream to satisify
 12341:   // the request.
 12341: 
108154:   if (n == 0 || n < len)
 12341:     return NS_ERROR_NOT_AVAILABLE;
 12341:   
 12341:   char buffer[NS_CRYPTO_HASH_BUFFER_SIZE];
108991:   uint32_t read, readLimit;
 12341:   
108154:   while(NS_SUCCEEDED(rv) && len > 0)
 12341:   {
108991:     readLimit = (uint32_t)NS_MIN<uint64_t>(NS_CRYPTO_HASH_BUFFER_SIZE, len);
 12341:     
 12341:     rv = aStream->Read(buffer, readLimit, &read);
 12341:     if (read == 0)
 12341:       return NS_BASE_STREAM_CLOSED;
 12341:     
 12341:     if (NS_SUCCEEDED(rv))
108991:       rv = Update((const uint8_t*)buffer, read);
 12341:     
108154:     len -= read;
 12341:   }
 12341:   
 12341:   return rv;
 12341: }
 12341: 
 79445: /* ACString finish (in bool aASCII); */
 79445: NS_IMETHODIMP nsCryptoHMAC::Finish(bool aASCII, nsACString & _retval)
 12341: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 12341:   if (!mHMACContext)
 12341:     return NS_ERROR_NOT_INITIALIZED;
 12341:   
108991:   uint32_t hashLen = 0;
 12341:   unsigned char buffer[HASH_LENGTH_MAX];
 12341:   unsigned char* pbuffer = buffer;
 12341: 
 12341:   PK11_DigestFinal(mHMACContext, pbuffer, &hashLen, HASH_LENGTH_MAX);
 12341:   if (aASCII)
 12341:   {
 12341:     char *asciiData = BTOA_DataToAscii(buffer, hashLen);
 12341:     NS_ENSURE_TRUE(asciiData, NS_ERROR_OUT_OF_MEMORY);
 12341: 
 12341:     _retval.Assign(asciiData);
 12341:     PORT_Free(asciiData);
 12341:   }
 12341:   else
 12341:   {
 12341:     _retval.Assign((const char*)buffer, hashLen);
 12341:   }
 12341: 
 12341:   return NS_OK;
 12341: }
 12341: 
 12341: /* void reset (); */
 12341: NS_IMETHODIMP nsCryptoHMAC::Reset()
 12341: {
 30802:   nsNSSShutDownPreventionLock locker;
 30802: 
 12341:   SECStatus ss = PK11_DigestBegin(mHMACContext);
 12341:   NS_ENSURE_TRUE(ss == SECSuccess, NS_ERROR_FAILURE);
 12341: 
 12341:   return NS_OK;
 12341: }
     1: 
 63867: NS_IMPL_THREADSAFE_ISUPPORTS1(PipUIContext, nsIInterfaceRequestor)
     1: 
     1: PipUIContext::PipUIContext()
     1: {
     1: }
     1: 
     1: PipUIContext::~PipUIContext()
     1: {
     1: }
     1: 
     1: /* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
     1: NS_IMETHODIMP PipUIContext::GetInterface(const nsIID & uuid, void * *result)
     1: {
 81303:   NS_ENSURE_ARG_POINTER(result);
106838:   *result = nullptr;
 81303: 
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("PipUIContext::GetInterface called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303: 
 81303:   if (!uuid.Equals(NS_GET_IID(nsIPrompt)))
 81303:     return NS_ERROR_NO_INTERFACE;
 81303: 
106838:   nsIPrompt * prompt = nullptr;
 81303:   nsresult rv = nsNSSComponent::GetNewPrompter(&prompt);
 81303:   *result = prompt;
     1:   return rv;
     1: }
     1: 
     1: nsresult 
     1: getNSSDialogs(void **_result, REFNSIID aIID, const char *contract)
     1: {
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("getNSSDialogs called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303: 
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsISupports> svc = do_GetService(contract, &rv);
     1:   if (NS_FAILED(rv)) 
     1:     return rv;
     1: 
 81303:   rv = svc->QueryInterface(aIID, _result);
 81303: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: setPassword(PK11SlotInfo *slot, nsIInterfaceRequestor *ctx)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   
     1:   if (PK11_NeedUserInit(slot)) {
     1:     nsITokenPasswordDialogs *dialogs;
 79445:     bool canceled;
     1:     NS_ConvertUTF8toUTF16 tokenName(PK11_GetTokenName(slot));
     1: 
     1:     rv = getNSSDialogs((void**)&dialogs,
     1:                        NS_GET_IID(nsITokenPasswordDialogs),
     1:                        NS_TOKENPASSWORDSDIALOG_CONTRACTID);
     1: 
     1:     if (NS_FAILED(rv)) goto loser;
     1: 
     1:     {
     1:       nsPSMUITracker tracker;
     1:       if (tracker.isUIForbidden()) {
     1:         rv = NS_ERROR_NOT_AVAILABLE;
     1:       }
     1:       else {
     1:         rv = dialogs->SetPassword(ctx,
     1:                                   tokenName.get(),
     1:                                   &canceled);
     1:       }
     1:     }
     1:     NS_RELEASE(dialogs);
     1:     if (NS_FAILED(rv)) goto loser;
     1: 
     1:     if (canceled) { rv = NS_ERROR_NOT_AVAILABLE; goto loser; }
     1:   }
     1:  loser:
     1:   return rv;
     1: }
     1: 
     1: 
108991: PSMContentDownloader::PSMContentDownloader(uint32_t type)
106838:   : mByteData(nullptr),
     1:     mType(type),
 80486:     mDoSilentDownload(false)
     1: {
     1: }
     1: 
     1: PSMContentDownloader::~PSMContentDownloader()
     1: {
     1:   if (mByteData)
     1:     nsMemory::Free(mByteData);
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS2(PSMContentDownloader, nsIStreamListener, nsIRequestObserver)
     1: 
108991: const int32_t kDefaultCertAllocLength = 2048;
     1: 
     1: NS_IMETHODIMP
     1: PSMContentDownloader::OnStartRequest(nsIRequest* request, nsISupports* context)
     1: {
     1:   nsresult rv;
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CertDownloader::OnStartRequest\n"));
     1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
     1:   if (!channel) return NS_ERROR_FAILURE;
     1: 
     1:   // Get the URI //
     1:   channel->GetURI(getter_AddRefs(mURI));
     1: 
119704:   int64_t contentLength;
     1:   rv = channel->GetContentLength(&contentLength);
     1:   if (NS_FAILED(rv) || contentLength <= 0)
     1:     contentLength = kDefaultCertAllocLength;
119704:   if (contentLength > INT32_MAX)
119704:     return NS_ERROR_OUT_OF_MEMORY;
     1:   
     1:   mBufferOffset = 0;
     1:   mBufferSize = 0;
     1:   mByteData = (char*) nsMemory::Alloc(contentLength);
     1:   if (!mByteData)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   
119704:   mBufferSize = int32_t(contentLength);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentDownloader::OnDataAvailable(nsIRequest* request,
     1:                                 nsISupports* context,
     1:                                 nsIInputStream *aIStream,
111234:                                 uint64_t aSourceOffset,
108991:                                 uint32_t aLength)
     1: {
     1:   if (!mByteData)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   
108991:   uint32_t amt;
     1:   nsresult err;
     1:   //Do a check to see if we need to allocate more memory.
108991:   if ((mBufferOffset + (int32_t)aLength) > mBufferSize) {
     1:       size_t newSize = (mBufferOffset + aLength) *2; // grow some more than needed
     1:       char *newBuffer;
     1:       newBuffer = (char*)nsMemory::Realloc(mByteData, newSize);
119832:       if (newBuffer == nullptr) {
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1:       mByteData = newBuffer;
     1:       mBufferSize = newSize;
     1:   }
     1:   
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CertDownloader::OnDataAvailable\n"));
     1:   do {
     1:     err = aIStream->Read(mByteData+mBufferOffset,
     1:                          aLength, &amt);
     1:     if (NS_FAILED(err)) return err;
     1:     if (amt == 0) break;
     1:     
     1:     aLength -= amt;
     1:     mBufferOffset += amt;
     1:     
     1:   } while (aLength > 0);
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentDownloader::OnStopRequest(nsIRequest* request,
     1:                               nsISupports* context,
     1:                               nsresult aStatus)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   //Check if the download succeeded - it might have failed due to
     1:   //network issues, etc.
     1:   if (NS_FAILED(aStatus)){
     1:     handleContentDownloadError(aStatus);
     1:     return aStatus;
     1:   }
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("CertDownloader::OnStopRequest\n"));
     1: 
     1:   nsCOMPtr<nsIX509CertDB> certdb;
     1:   nsCOMPtr<nsICRLManager> crlManager;
     1: 
     1:   nsresult rv;
     1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
     1: 
     1:   switch (mType) {
     1:   case PSMContentDownloader::X509_CA_CERT:
     1:   case PSMContentDownloader::X509_USER_CERT:
     1:   case PSMContentDownloader::X509_EMAIL_CERT:
     1:     certdb = do_GetService(NS_X509CERTDB_CONTRACTID);
     1:     break;
     1: 
     1:   case PSMContentDownloader::PKCS7_CRL:
     1:     crlManager = do_GetService(NS_CRLMANAGER_CONTRACTID);
     1: 
     1:   default:
     1:     break;
     1:   }
     1: 
     1:   switch (mType) {
     1:   case PSMContentDownloader::X509_CA_CERT:
108991:     return certdb->ImportCertificates((uint8_t*)mByteData, mBufferOffset, mType, ctx); 
     1:   case PSMContentDownloader::X509_USER_CERT:
108991:     return certdb->ImportUserCertificate((uint8_t*)mByteData, mBufferOffset, ctx);
     1:   case PSMContentDownloader::X509_EMAIL_CERT:
108991:     return certdb->ImportEmailCertificate((uint8_t*)mByteData, mBufferOffset, ctx); 
     1:   case PSMContentDownloader::PKCS7_CRL:
108991:     return crlManager->ImportCrl((uint8_t*)mByteData, mBufferOffset, mURI, SEC_CRL_TYPE, mDoSilentDownload, mCrlAutoDownloadKey.get());
     1:   default:
     1:     rv = NS_ERROR_FAILURE;
     1:     break;
     1:   }
     1:   
     1:   return rv;
     1: }
     1: 
     1: 
     1: nsresult
     1: PSMContentDownloader::handleContentDownloadError(nsresult errCode)
     1: {
     1:   nsString tmpMessage;
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if(NS_FAILED(rv)){
     1:     return rv;
     1:   }
     1:       
     1:   //Handling errors for crl download only, for now.
     1:   switch (mType){
     1:   case PSMContentDownloader::PKCS7_CRL:
     1: 
     1:     //TO DO: Handle network errors in details
     1:     //XXXXXXXXXXXXXXXXXX
     1:     nssComponent->GetPIPNSSBundleString("CrlImportFailureNetworkProblem", tmpMessage);
     1:       
 17116:     if (mDoSilentDownload) {
     1:       //This is the case for automatic download. Update failure history
110974:       nsAutoCString updateErrCntPrefStr(CRL_AUTOUPDATE_ERRCNT_PREF);
110974:       nsAutoCString updateErrDetailPrefStr(CRL_AUTOUPDATE_ERRDETAIL_PREF);
     1:       nsCString errMsg;
108991:       int32_t errCnt;
     1: 
     1:       nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
     1:       if(NS_FAILED(rv)){
     1:         return rv;
     1:       }
     1:       
103796:       LossyAppendUTF16toASCII(mCrlAutoDownloadKey, updateErrCntPrefStr);
103796:       LossyAppendUTF16toASCII(mCrlAutoDownloadKey, updateErrDetailPrefStr);
     1:       errMsg.AssignWithConversion(tmpMessage.get());
     1:       
     1:       rv = pref->GetIntPref(updateErrCntPrefStr.get(),&errCnt);
     1:       if( (NS_FAILED(rv)) || (errCnt == 0) ){
     1:         pref->SetIntPref(updateErrCntPrefStr.get(),1);
     1:       }else{
     1:         pref->SetIntPref(updateErrCntPrefStr.get(),errCnt+1);
     1:       }
     1:       pref->SetCharPref(updateErrDetailPrefStr.get(),errMsg.get());
     1:       nsCOMPtr<nsIPrefService> prefSvc(do_QueryInterface(pref));
106838:       prefSvc->SavePrefFile(nullptr);
     1:     }else{
     1:       nsString message;
  4289:       nssComponent->GetPIPNSSBundleString("CrlImportFailure1x", message);
     1:       message.Append(NS_LITERAL_STRING("\n").get());
     1:       message.Append(tmpMessage);
     1:       nssComponent->GetPIPNSSBundleString("CrlImportFailure2", tmpMessage);
     1:       message.Append(NS_LITERAL_STRING("\n").get());
     1:       message.Append(tmpMessage);
 81303:       nsNSSComponent::ShowAlertWithConstructedString(message);
     1:     }
     1:     break;
     1:   default:
     1:     break;
     1:   }
     1: 
     1:   return NS_OK;
     1: 
     1: }
     1: 
     1: void 
 79445: PSMContentDownloader::setSilentDownload(bool flag)
     1: {
     1:   mDoSilentDownload = flag;
     1: }
     1: 
     1: void
     1: PSMContentDownloader::setCrlAutodownloadKey(nsAutoString key)
     1: {
     1:   mCrlAutoDownloadKey = key;
     1: }
     1: 
     1: 
     1: /* other mime types that we should handle sometime:
     1:    
     1:    application/x-pkcs7-crl
     1:    application/x-pkcs7-mime
     1:    application/pkcs7-signature
     1:    application/pre-encrypted
     1:    
     1: */
     1: 
108991: uint32_t
     1: getPSMContentType(const char * aContentType)
     1: { 
     1:   // Don't forget to update RegisterPSMContentListeners in nsNSSModule.cpp 
     1:   // for every supported content type.
     1:   
     1:   if (!nsCRT::strcasecmp(aContentType, "application/x-x509-ca-cert"))
     1:     return PSMContentDownloader::X509_CA_CERT;
     1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-server-cert"))
     1:     return PSMContentDownloader::X509_SERVER_CERT;
     1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-user-cert"))
     1:     return PSMContentDownloader::X509_USER_CERT;
     1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-email-cert"))
     1:     return PSMContentDownloader::X509_EMAIL_CERT;
     1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-pkcs7-crl"))
     1:     return PSMContentDownloader::PKCS7_CRL;
     1:   else if (!nsCRT::strcasecmp(aContentType, "application/x-x509-crl"))
     1:     return PSMContentDownloader::PKCS7_CRL;
     1:   else if (!nsCRT::strcasecmp(aContentType, "application/pkix-crl"))
     1:     return PSMContentDownloader::PKCS7_CRL;
     1:   return PSMContentDownloader::UNKNOWN_TYPE;
     1: }
     1: 
     1: 
     1: NS_IMPL_ISUPPORTS2(PSMContentListener,
     1:                    nsIURIContentListener,
     1:                    nsISupportsWeakReference) 
     1: 
     1: PSMContentListener::PSMContentListener()
     1: {
106838:   mLoadCookie = nullptr;
106838:   mParentContentListener = nullptr;
     1: }
     1: 
     1: PSMContentListener::~PSMContentListener()
     1: {
     1: }
     1: 
     1: nsresult
     1: PSMContentListener::init()
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: PSMContentListener::OnStartURIOpen(nsIURI *aURI, bool *aAbortOpen)
     1: {
 80486:   //if we don't want to handle the URI, return true in
     1:   //*aAbortOpen
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::IsPreferred(const char * aContentType,
     1:                                  char ** aDesiredContentType,
 79445:                                  bool * aCanHandleContent)
     1: {
 80486:   return CanHandleContent(aContentType, true,
     1:                           aDesiredContentType, aCanHandleContent);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::CanHandleContent(const char * aContentType,
 79445:                                       bool aIsContentPreferred,
     1:                                       char ** aDesiredContentType,
 79445:                                       bool * aCanHandleContent)
     1: {
108991:   uint32_t type;
     1:   type = getPSMContentType(aContentType);
     1:   if (type == PSMContentDownloader::UNKNOWN_TYPE) {
 80486:     *aCanHandleContent = false;
     1:   } else {
 80486:     *aCanHandleContent = true;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::DoContent(const char * aContentType,
 79445:                                bool aIsContentPreferred,
     1:                                nsIRequest * aRequest,
     1:                                nsIStreamListener ** aContentHandler,
 79445:                                bool * aAbortProcess)
     1: {
     1:   PSMContentDownloader *downLoader;
108991:   uint32_t type;
     1:   type = getPSMContentType(aContentType);
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("PSMContentListener::DoContent\n"));
     1:   if (type != PSMContentDownloader::UNKNOWN_TYPE) {
     1:     downLoader = new PSMContentDownloader(type);
     1:     if (downLoader) {
     1:       downLoader->QueryInterface(NS_GET_IID(nsIStreamListener), 
     1:                                             (void **)aContentHandler);
     1:       return NS_OK;
     1:     }
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::GetLoadCookie(nsISupports * *aLoadCookie)
     1: {
     1:   *aLoadCookie = mLoadCookie;
     1:   NS_IF_ADDREF(*aLoadCookie);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::SetLoadCookie(nsISupports * aLoadCookie)
     1: {
     1:   mLoadCookie = aLoadCookie;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::GetParentContentListener(nsIURIContentListener ** aContentListener)
     1: {
     1:   *aContentListener = mParentContentListener;
     1:   NS_IF_ADDREF(*aContentListener);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: PSMContentListener::SetParentContentListener(nsIURIContentListener * aContentListener)
     1: {
     1:   mParentContentListener = aContentListener;
     1:   return NS_OK;
     1: }
