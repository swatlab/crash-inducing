   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
   1:  *
   1:  * ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Simon Fraser   <sfraser@netscape.com>
   1:  *   Michael Judge  <mjudge@netscape.com>
   1:  *   Charles Manske <cmanske@netscape.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsPIDOMWindow.h"
   1: #include "nsComposerCommandsUpdater.h"
   1: #include "nsComponentManagerUtils.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsISelection.h"
   1: 
   1: #include "nsIInterfaceRequestorUtils.h"
   1: #include "nsString.h"
   1: 
   1: #include "nsICommandManager.h"
   1: 
   1: #include "nsIDocShell.h"
   1: #include "nsITransactionManager.h"
   1: 
   1: nsComposerCommandsUpdater::nsComposerCommandsUpdater()
   1: :  mDOMWindow(nsnull)
   1: ,  mDirtyState(eStateUninitialized)
   1: ,  mSelectionCollapsed(eStateUninitialized)
   1: ,  mFirstDoOfFirstUndo(PR_TRUE)
   1: {
   1: }
   1: 
   1: nsComposerCommandsUpdater::~nsComposerCommandsUpdater()
   1: {
   1: }
   1: 
   1: NS_IMPL_ISUPPORTS4(nsComposerCommandsUpdater, nsISelectionListener,
   1:                    nsIDocumentStateListener, nsITransactionListener, nsITimerCallback)
   1: 
   1: #if 0
   1: #pragma mark -
   1: #endif
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::NotifyDocumentCreated()
   1: {
   1:   // Trigger an nsIObserve notification that the document has been created
   1:   UpdateOneCommand("obs_documentCreated");
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::NotifyDocumentWillBeDestroyed()
   1: {
   1:   // cancel any outstanding update timer
   1:   if (mUpdateTimer)
   1:   {
   1:     mUpdateTimer->Cancel();
   1:     mUpdateTimer = nsnull;
   1:   }
   1:   
   1:   // We can't call this right now; it is too late in some cases and the window
   1:   // is already partially destructed (e.g. JS objects may be gone).
   1: #if 0
   1:   // Trigger an nsIObserve notification that the document will be destroyed
   1:   UpdateOneCommand("obs_documentWillBeDestroyed");
   1: #endif
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::NotifyDocumentStateChanged(PRBool aNowDirty)
   1: {
   1:   // update document modified. We should have some other notifications for this too.
   1:   return UpdateDirtyState(aNowDirty);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::NotifySelectionChanged(nsIDOMDocument *,
   1:                                                   nsISelection *, PRInt16)
   1: {
   1:   return PrimeUpdateTimer();
   1: }
   1: 
   1: #if 0
   1: #pragma mark -
   1: #endif
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::WillDo(nsITransactionManager *aManager,
   1:                                   nsITransaction *aTransaction, PRBool *aInterrupt)
   1: {
   1:   *aInterrupt = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::DidDo(nsITransactionManager *aManager,
   1:   nsITransaction *aTransaction, nsresult aDoResult)
   1: {
   1:   // only need to update if the status of the Undo menu item changes.
   1:   PRInt32 undoCount;
   1:   aManager->GetNumberOfUndoItems(&undoCount);
   1:   if (undoCount == 1)
   1:   {
   1:     if (mFirstDoOfFirstUndo)
   1:       UpdateCommandGroup(NS_LITERAL_STRING("undo"));
   1:     mFirstDoOfFirstUndo = PR_FALSE;
   1:   }
   1: 	
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsComposerCommandsUpdater::WillUndo(nsITransactionManager *aManager,
   1:                                     nsITransaction *aTransaction,
   1:                                     PRBool *aInterrupt)
   1: {
   1:   *aInterrupt = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::DidUndo(nsITransactionManager *aManager,
   1:                                    nsITransaction *aTransaction,
   1:                                    nsresult aUndoResult)
   1: {
   1:   PRInt32 undoCount;
   1:   aManager->GetNumberOfUndoItems(&undoCount);
   1:   if (undoCount == 0)
   1:     mFirstDoOfFirstUndo = PR_TRUE;    // reset the state for the next do
   1: 
   1:   UpdateCommandGroup(NS_LITERAL_STRING("undo"));
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::WillRedo(nsITransactionManager *aManager,
   1:                                     nsITransaction *aTransaction,
   1:                                     PRBool *aInterrupt)
   1: {
   1:   *aInterrupt = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::DidRedo(nsITransactionManager *aManager,  
   1:                                    nsITransaction *aTransaction,
   1:                                    nsresult aRedoResult)
   1: {
   1:   UpdateCommandGroup(NS_LITERAL_STRING("undo"));
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::WillBeginBatch(nsITransactionManager *aManager,
   1:                                           PRBool *aInterrupt)
   1: {
   1:   *aInterrupt = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::DidBeginBatch(nsITransactionManager *aManager,
   1:                                          nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::WillEndBatch(nsITransactionManager *aManager,
   1:                                         PRBool *aInterrupt)
   1: {
   1:   *aInterrupt = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::DidEndBatch(nsITransactionManager *aManager, 
   1:                                        nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::WillMerge(nsITransactionManager *aManager,
   1:                                      nsITransaction *aTopTransaction,
   1:                                      nsITransaction *aTransactionToMerge,
   1:                                      PRBool *aInterrupt)
   1: {
   1:   *aInterrupt = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsComposerCommandsUpdater::DidMerge(nsITransactionManager *aManager,
   1:                                     nsITransaction *aTopTransaction,
   1:                                     nsITransaction *aTransactionToMerge,
   1:                                     PRBool aDidMerge, nsresult aMergeResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: #if 0
   1: #pragma mark -
   1: #endif
   1: 
   1: nsresult
   1: nsComposerCommandsUpdater::Init(nsIDOMWindow* aDOMWindow)
   1: {
   1:   NS_ENSURE_ARG(aDOMWindow);
   1:   mDOMWindow = aDOMWindow;
   1: 
   1:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aDOMWindow));
   1:   if (window)
   1:   {
1904:     mDocShell = do_GetWeakReference(window->GetDocShell());
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsComposerCommandsUpdater::PrimeUpdateTimer()
   1: {
   1:   if (!mUpdateTimer)
   1:   {
   1:     nsresult rv = NS_OK;
   1:     mUpdateTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
   1:     if (NS_FAILED(rv)) return rv;
   1:   }
   1: 
   1:   const PRUint32 kUpdateTimerDelay = 150;
   1:   return mUpdateTimer->InitWithCallback(NS_STATIC_CAST(nsITimerCallback*, this),
   1:                                         kUpdateTimerDelay,
   1:                                         nsITimer::TYPE_ONE_SHOT);
   1: }
   1: 
   1: 
   1: void nsComposerCommandsUpdater::TimerCallback()
   1: {
   1:   // if the selection state has changed, update stuff
   1:   PRBool isCollapsed = SelectionIsCollapsed();
   1:   if (isCollapsed != mSelectionCollapsed)
   1:   {
   1:     UpdateCommandGroup(NS_LITERAL_STRING("select"));
   1:     mSelectionCollapsed = isCollapsed;
   1:   }
   1:   
   1:   // isn't this redundant with the UpdateCommandGroup above?
   1:   // can we just nuke the above call? or create a meta command group?
   1:   UpdateCommandGroup(NS_LITERAL_STRING("style"));
   1: }
   1: 
   1: nsresult
   1: nsComposerCommandsUpdater::UpdateDirtyState(PRBool aNowDirty)
   1: {
   1:   if (mDirtyState != aNowDirty)
   1:   {
   1:     UpdateCommandGroup(NS_LITERAL_STRING("save"));
   1:     UpdateCommandGroup(NS_LITERAL_STRING("undo"));
   1:     mDirtyState = aNowDirty;
   1:   }
   1:   
   1:   return NS_OK;  
   1: }
   1: 
   1: nsresult
   1: nsComposerCommandsUpdater::UpdateCommandGroup(const nsAString& aCommandGroup)
   1: {
1904:   nsCOMPtr<nsPICommandUpdater> commandUpdater = GetCommandUpdater();
   1:   if (!commandUpdater) return NS_ERROR_FAILURE;
   1: 
   1:   
   1:   // This hardcoded list of commands is temporary.
   1:   // This code should use nsIControllerCommandGroup.
   1:   if (aCommandGroup.EqualsLiteral("undo"))
   1:   {
   1:     commandUpdater->CommandStatusChanged("cmd_undo");
   1:     commandUpdater->CommandStatusChanged("cmd_redo");
   1:   }
   1:   else if (aCommandGroup.EqualsLiteral("select") ||
   1:            aCommandGroup.EqualsLiteral("style"))
   1:   {
   1:     commandUpdater->CommandStatusChanged("cmd_bold");
   1:     commandUpdater->CommandStatusChanged("cmd_italic");
   1:     commandUpdater->CommandStatusChanged("cmd_underline");
   1:     commandUpdater->CommandStatusChanged("cmd_tt");
   1: 
   1:     commandUpdater->CommandStatusChanged("cmd_strikethrough");
   1:     commandUpdater->CommandStatusChanged("cmd_superscript");
   1:     commandUpdater->CommandStatusChanged("cmd_subscript");
   1:     commandUpdater->CommandStatusChanged("cmd_nobreak");
   1: 
   1:     commandUpdater->CommandStatusChanged("cmd_em");
   1:     commandUpdater->CommandStatusChanged("cmd_strong");
   1:     commandUpdater->CommandStatusChanged("cmd_cite");
   1:     commandUpdater->CommandStatusChanged("cmd_abbr");
   1:     commandUpdater->CommandStatusChanged("cmd_acronym");
   1:     commandUpdater->CommandStatusChanged("cmd_code");
   1:     commandUpdater->CommandStatusChanged("cmd_samp");
   1:     commandUpdater->CommandStatusChanged("cmd_var");
   1:    
   1:     commandUpdater->CommandStatusChanged("cmd_increaseFont");
   1:     commandUpdater->CommandStatusChanged("cmd_decreaseFont");
   1: 
   1:     commandUpdater->CommandStatusChanged("cmd_paragraphState");
   1:     commandUpdater->CommandStatusChanged("cmd_fontFace");
   1:     commandUpdater->CommandStatusChanged("cmd_fontColor");
   1:     commandUpdater->CommandStatusChanged("cmd_backgroundColor");
   1:     commandUpdater->CommandStatusChanged("cmd_highlight");
   1:   }  
   1:   else if (aCommandGroup.EqualsLiteral("save"))
   1:   {
   1:     // save commands (most are not in C++)
   1:     commandUpdater->CommandStatusChanged("cmd_setDocumentModified");
   1:     commandUpdater->CommandStatusChanged("cmd_save");
   1:   }
   1:   return NS_OK;  
   1: }
   1: 
   1: nsresult
   1: nsComposerCommandsUpdater::UpdateOneCommand(const char *aCommand)
   1: {
1904:   nsCOMPtr<nsPICommandUpdater> commandUpdater = GetCommandUpdater();
   1:   if (!commandUpdater) return NS_ERROR_FAILURE;
   1: 
   1:   commandUpdater->CommandStatusChanged(aCommand);
   1: 
   1:   return NS_OK;  
   1: }
   1: 
   1: PRBool
   1: nsComposerCommandsUpdater::SelectionIsCollapsed()
   1: {
   1:   if (!mDOMWindow) return PR_TRUE;
   1: 
   1:   nsCOMPtr<nsISelection> domSelection;
   1:   if (NS_SUCCEEDED(mDOMWindow->GetSelection(getter_AddRefs(domSelection))) && domSelection)
   1:   {
   1:     PRBool selectionCollapsed = PR_FALSE;
   1:     domSelection->GetIsCollapsed(&selectionCollapsed);
   1:     return selectionCollapsed;
   1:   }
   1: 
   1:   NS_WARNING("nsComposerCommandsUpdater::SelectionIsCollapsed - no domSelection");
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
1904: already_AddRefed<nsPICommandUpdater>
1904: nsComposerCommandsUpdater::GetCommandUpdater()
1904: {
1904:   nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocShell);
1904:   NS_ENSURE_TRUE(docShell, nsnull);
1904:   nsCOMPtr<nsICommandManager> manager = do_GetInterface(docShell);
1904:   nsCOMPtr<nsPICommandUpdater> updater = do_QueryInterface(manager);
1904:   nsPICommandUpdater* retVal = nsnull;
1904:   updater.swap(retVal);
1904:   return retVal;
1904: }
1904: 
   1: #if 0
   1: #pragma mark -
   1: #endif
   1: 
   1: nsresult
   1: nsComposerCommandsUpdater::Notify(nsITimer *timer)
   1: {
   1:   NS_ASSERTION(timer == mUpdateTimer.get(), "Hey, this ain't my timer!");
   1:   TimerCallback();
   1:   return NS_OK;
   1: }
   1: 
   1: #if 0
   1: #pragma mark -
   1: #endif
   1: 
   1: 
   1: nsresult
   1: NS_NewComposerCommandsUpdater(nsISelectionListener** aInstancePtrResult)
   1: {
   1:   nsComposerCommandsUpdater* newThang = new nsComposerCommandsUpdater;
   1:   if (!newThang)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   return newThang->QueryInterface(NS_GET_IID(nsISelectionListener),
   1:                                   (void **)aInstancePtrResult);
   1: }
