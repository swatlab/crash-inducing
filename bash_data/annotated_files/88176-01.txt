43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43113:  *
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsCacheEntryDescriptor.cpp, released
43113:  * February 22, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan, 22-February-2001
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "nsICache.h"
43113: #include "nsCache.h"
43113: #include "nsCacheService.h"
43113: #include "nsCacheEntryDescriptor.h"
43113: #include "nsCacheEntry.h"
43113: #include "nsReadableUtils.h"
43113: #include "nsIOutputStream.h"
43113: #include "nsCRT.h"
43113: 
84841: #define kMinDecompressReadBufLen 1024
84841: #define kMinCompressWriteBufLen  1024
84841: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS2(nsCacheEntryDescriptor,
43113:                               nsICacheEntryDescriptor,
43113:                               nsICacheEntryInfo)
43113: 
43113: nsCacheEntryDescriptor::nsCacheEntryDescriptor(nsCacheEntry * entry,
43113:                                                nsCacheAccessMode accessGranted)
43113:     : mCacheEntry(entry),
60325:       mAccessGranted(accessGranted),
60325:       mOutput(nsnull)
43113: {
43113:     PR_INIT_CLIST(this);
43113:     NS_ADDREF(nsCacheService::GlobalInstance());  // ensure it lives for the lifetime of the descriptor
43113: }
43113: 
43113: 
43113: nsCacheEntryDescriptor::~nsCacheEntryDescriptor()
43113: {
43113:     // No need to close if the cache entry has already been severed.  This
43113:     // helps avoid a shutdown assertion (bug 285519) that is caused when
43113:     // consumers end up holding onto these objects past xpcom-shutdown.  It's
43113:     // okay for them to do that because the cache service calls our Close
43113:     // method during xpcom-shutdown, so we don't need to complain about it.
43113:     if (mCacheEntry)
43113:         Close();
43113: 
43113:     nsCacheService * service = nsCacheService::GlobalInstance();
43113:     NS_RELEASE(service);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetClientID(char ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113: 
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return ClientIDFromCacheKey(*(mCacheEntry->Key()), result);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetDeviceID(char ** aDeviceID)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aDeviceID);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     const char* deviceID = mCacheEntry->GetDeviceID();
43113:     if (!deviceID) {
43113:         *aDeviceID = nsnull;
43113:         return NS_OK;
43113:     }
43113: 
43113:     *aDeviceID = NS_strdup(deviceID);
43113:     return *aDeviceID ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetKey(nsACString &result)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return ClientKeyFromCacheKey(*(mCacheEntry->Key()), result);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetFetchCount(PRInt32 *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = mCacheEntry->FetchCount();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetLastFetched(PRUint32 *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = mCacheEntry->LastFetched();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetLastModified(PRUint32 *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = mCacheEntry->LastModified();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetExpirationTime(PRUint32 *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = mCacheEntry->ExpirationTime();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::SetExpirationTime(PRUint32 expirationTime)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     mCacheEntry->SetExpirationTime(expirationTime);
43113:     mCacheEntry->MarkEntryDirty();
43113:     return NS_OK;
43113: }
43113: 
43113: 
79445: NS_IMETHODIMP nsCacheEntryDescriptor::IsStreamBased(bool *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = mCacheEntry->IsStreamData();
43113:     return NS_OK;
43113: }
43113: 
52143: NS_IMETHODIMP nsCacheEntryDescriptor::GetPredictedDataSize(PRInt64 *result)
52143: {
52143:     NS_ENSURE_ARG_POINTER(result);
52143:     nsCacheServiceAutoLock lock;
52143:     if (!mCacheEntry) return NS_ERROR_NOT_AVAILABLE;
52143: 
52143:     *result = mCacheEntry->PredictedDataSize();
52143:     return NS_OK;
52143: }
52143: 
52143: NS_IMETHODIMP nsCacheEntryDescriptor::SetPredictedDataSize(PRInt64
52143:                                                            predictedSize)
52143: {
52143:     nsCacheServiceAutoLock lock;
52143:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
52143: 
52143:     mCacheEntry->SetPredictedDataSize(predictedSize);
52143:     return NS_OK;
52143: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::GetDataSize(PRUint32 *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
84841:     const char* val = mCacheEntry->GetMetaDataElement("uncompressed-len");
84841:     if (!val) {
43113:         *result = mCacheEntry->DataSize();
84841:     } else {
84841:         *result = atol(val);
84841:     }
84841: 
84841:     return NS_OK;
84841: }
84841: 
84841: 
84841: NS_IMETHODIMP nsCacheEntryDescriptor::GetStorageDataSize(PRUint32 *result)
84841: {
84841:     NS_ENSURE_ARG_POINTER(result);
84841:     nsCacheServiceAutoLock lock;
84841:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
84841: 
84841:     *result = mCacheEntry->DataSize();
84841: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheEntryDescriptor::RequestDataSizeChange(PRInt32 deltaSize)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     nsresult  rv;
43113:     rv = nsCacheService::OnDataSizeChange(mCacheEntry, deltaSize);
43113:     if (NS_SUCCEEDED(rv)) {
43113:         // XXX review for signed/unsigned math errors
43113:         PRUint32  newDataSize = mCacheEntry->DataSize() + deltaSize;
43113:         mCacheEntry->SetDataSize(newDataSize);
43113:         mCacheEntry->TouchData();
43113:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::SetDataSize(PRUint32 dataSize)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     // XXX review for signed/unsigned math errors
43113:     PRInt32  deltaSize = dataSize - mCacheEntry->DataSize();
43113: 
43113:     nsresult  rv;
43113:     rv = nsCacheService::OnDataSizeChange(mCacheEntry, deltaSize);
43113:     // this had better be NS_OK, this call instance is advisory for memory cache objects
43113:     if (NS_SUCCEEDED(rv)) {
43113:         // XXX review for signed/unsigned math errors
43113:         PRUint32  newDataSize = mCacheEntry->DataSize() + deltaSize;
43113:         mCacheEntry->SetDataSize(newDataSize);
43113:         mCacheEntry->TouchData();
43113:     } else {
43113:         NS_WARNING("failed SetDataSize() on memory cache object!");
43113:     }
43113:     
43113:     return rv;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::OpenInputStream(PRUint32 offset, nsIInputStream ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113: 
43113:     {
43113:         nsCacheServiceAutoLock lock;
43113:         if (!mCacheEntry)                  return NS_ERROR_NOT_AVAILABLE;
43113:         if (!mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_NOT_STREAM;
43113: 
43113:         // ensure valid permissions
43113:         if (!(mAccessGranted & nsICache::ACCESS_READ))
43113:             return NS_ERROR_CACHE_READ_ACCESS_DENIED;
43113:     }
43113: 
84841:     nsInputStreamWrapper* cacheInput = nsnull;
84841:     const char *val;
84841:     val = mCacheEntry->GetMetaDataElement("uncompressed-len");
84841:     if (val) {
84841:         cacheInput = new nsDecompressInputStreamWrapper(this, offset);
84841:     } else {
84841:         cacheInput = new nsInputStreamWrapper(this, offset);
84841:     }
43113:     if (!cacheInput) return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(*result = cacheInput);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::OpenOutputStream(PRUint32 offset, nsIOutputStream ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113: 
43113:     {
43113:         nsCacheServiceAutoLock lock;
43113:         if (!mCacheEntry)                  return NS_ERROR_NOT_AVAILABLE;
43113:         if (!mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_NOT_STREAM;
43113: 
43113:         // ensure valid permissions
43113:         if (!(mAccessGranted & nsICache::ACCESS_WRITE))
43113:             return NS_ERROR_CACHE_WRITE_ACCESS_DENIED;
43113:     }
43113: 
84841:     nsOutputStreamWrapper* cacheOutput = nsnull;
84841:     PRInt32 compressionLevel = nsCacheService::CacheCompressionLevel();
84841:     const char *val;
84841:     val = mCacheEntry->GetMetaDataElement("uncompressed-len");
84841:     if ((compressionLevel > 0) && val) {
84841:         cacheOutput = new nsCompressOutputStreamWrapper(this, offset);
84841:     } else {
87488:         // clear compression flag when compression disabled - see bug #715198
87488:         if (val) {
87488:             mCacheEntry->SetMetaDataElement("uncompressed-len", nsnull);
87488:         }
84841:         cacheOutput = new nsOutputStreamWrapper(this, offset);
84841:     }
43113:     if (!cacheOutput) return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(*result = cacheOutput);
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetCacheElement(nsISupports ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)                 return NS_ERROR_NOT_AVAILABLE;
43113:     if (mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_STREAM;
43113: 
43113:     NS_IF_ADDREF(*result = mCacheEntry->Data());
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::SetCacheElement(nsISupports * cacheElement)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)                 return NS_ERROR_NOT_AVAILABLE;
43113:     if (mCacheEntry->IsStreamData())  return NS_ERROR_CACHE_DATA_IS_STREAM;
43113: 
43113:     return nsCacheService::SetCacheElement(mCacheEntry, cacheElement);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetAccessGranted(nsCacheAccessMode *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     *result = mAccessGranted;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetStoragePolicy(nsCacheStoragePolicy *result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113:     
43113:     *result = mCacheEntry->StoragePolicy();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::SetStoragePolicy(nsCacheStoragePolicy policy)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113:     // XXX validate policy against session?
43113:     
79445:     bool        storageEnabled = false;
43113:     storageEnabled = nsCacheService::IsStorageEnabledForPolicy_Locked(policy);
43113:     if (!storageEnabled)    return NS_ERROR_FAILURE;
43113: 
43113:     // Don't change the storage policy of entries we can't write
43113:     if (!(mAccessGranted & nsICache::ACCESS_WRITE))
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     
43113:     // Don't allow a cache entry to move from memory-only to anything else
43113:     if (mCacheEntry->StoragePolicy() == nsICache::STORE_IN_MEMORY &&
43113:         policy != nsICache::STORE_IN_MEMORY)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:         
43113:     mCacheEntry->SetStoragePolicy(policy);
43113:     mCacheEntry->MarkEntryDirty();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetFile(nsIFile ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return nsCacheService::GetFileForEntry(mCacheEntry, result);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetSecurityInfo(nsISupports ** result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = mCacheEntry->SecurityInfo();
43113:     NS_IF_ADDREF(*result);
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::SetSecurityInfo(nsISupports * securityInfo)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     mCacheEntry->SetSecurityInfo(securityInfo);
43113:     mCacheEntry->MarkEntryDirty();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::Doom()
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return nsCacheService::DoomEntry(mCacheEntry);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::DoomAndFailPendingRequests(nsresult status)
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::MarkValid()
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     nsresult  rv = nsCacheService::ValidateEntry(mCacheEntry);
43113:     return rv;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::Close()
43113: {
43113:     nsCacheServiceAutoLock lock;
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     // XXX perhaps closing descriptors should clear/sever transports
43113: 
43113:     // tell nsCacheService we're going away
43113:     nsCacheService::CloseDescriptor(this);
43113:     NS_ASSERTION(mCacheEntry == nsnull, "mCacheEntry not null");
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::GetMetaDataElement(const char *key, char **result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(key);
43113:     *result = nsnull;
43113: 
43113:     nsCacheServiceAutoLock lock;
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_AVAILABLE);
43113: 
43113:     const char *value;
43113: 
43113:     value = mCacheEntry->GetMetaDataElement(key);
43113:     if (!value) return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     *result = NS_strdup(value);
43113:     if (!*result) return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::SetMetaDataElement(const char *key, const char *value)
43113: {
43113:     NS_ENSURE_ARG_POINTER(key);
43113: 
43113:     nsCacheServiceAutoLock lock;
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_AVAILABLE);
43113: 
43113:     // XXX allow null value, for clearing key?
43113: 
43113:     nsresult rv = mCacheEntry->SetMetaDataElement(key, value);
43113:     if (NS_SUCCEEDED(rv))
43113:         mCacheEntry->TouchMetaData();
43113:     return rv;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheEntryDescriptor::VisitMetaData(nsICacheMetaDataVisitor * visitor)
43113: {
43113:     nsCacheServiceAutoLock lock;  // XXX check callers, we're calling out of module
43113:     NS_ENSURE_ARG_POINTER(visitor);
43113:     if (!mCacheEntry)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     return mCacheEntry->VisitMetaDataElements(visitor);
43113: }
43113: 
43113: 
43113: /******************************************************************************
84841:  * nsCacheInputStream - a wrapper for nsIInputStream keeps the cache entry
43113:  *                      open while referenced.
43113:  ******************************************************************************/
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheEntryDescriptor::nsInputStreamWrapper,
43113:                               nsIInputStream)
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsInputStreamWrapper::LazyInit()
43113: {
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     nsCacheAccessMode mode;
43113:     nsresult rv = mDescriptor->GetAccessGranted(&mode);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     NS_ENSURE_TRUE(mode & nsICache::ACCESS_READ, NS_ERROR_UNEXPECTED);
43113: 
43113:     nsCacheEntry* cacheEntry = mDescriptor->CacheEntry();
43113:     if (!cacheEntry) return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     rv = nsCacheService::OpenInputStreamForEntry(cacheEntry, mode,
43113:                                                  mStartOffset,
43113:                                                  getter_AddRefs(mInput));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
80486:     mInitialized = true;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsInputStreamWrapper::Close()
43113: {
43113:     nsresult rv = EnsureInit();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return mInput->Close();
43113: }
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsInputStreamWrapper::Available(PRUint32 *avail)
43113: {
43113:     nsresult rv = EnsureInit();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return mInput->Available(avail);
43113: }
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsInputStreamWrapper::Read(char *buf, PRUint32 count, PRUint32 *countRead)
43113: {
43113:     nsresult rv = EnsureInit();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return mInput->Read(buf, count, countRead);
43113: }
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsInputStreamWrapper::ReadSegments(nsWriteSegmentFun writer, void *closure,
43113:                                    PRUint32 count, PRUint32 *countRead)
43113: {
43113:     // cache stream not buffered
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: nsresult nsCacheEntryDescriptor::
79445: nsInputStreamWrapper::IsNonBlocking(bool *result)
43113: {
43113:     // cache streams will never return NS_BASE_STREAM_WOULD_BLOCK
80486:     *result = false;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
84841:  * nsDecompressInputStreamWrapper - an input stream wrapper that decompresses
84841:  ******************************************************************************/
84841: 
84841: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheEntryDescriptor::nsDecompressInputStreamWrapper,
84841:                               nsIInputStream)
84841: 
84841: NS_IMETHODIMP nsCacheEntryDescriptor::
84841: nsDecompressInputStreamWrapper::Read(char *    buf, 
84841:                                      PRUint32  count, 
84841:                                      PRUint32 *countRead)
84841: {
84841:     int zerr = Z_OK;
84841:     nsresult rv = NS_OK;
84841: 
84841:     if (!mStreamInitialized) {
84841:         rv = InitZstream();
84841:         if (NS_FAILED(rv)) {
84841:             return rv;
84841:         }
84841:     }
84841: 
84841:     mZstream.next_out = (Bytef*)buf;
84841:     mZstream.avail_out = count;
84841: 
84841:     if (mReadBufferLen < count) {
84841:         // Allocate a buffer for reading from the input stream. This will
84841:         // determine the max number of compressed bytes read from the
84841:         // input stream at one time. Making the buffer size proportional
84841:         // to the request size is not necessary, but helps minimize the
84841:         // number of read requests to the input stream.
84841:         PRUint32 newBufLen = NS_MAX(count, (PRUint32)kMinDecompressReadBufLen);
84841:         unsigned char* newBuf;
84841:         newBuf = (unsigned char*)nsMemory::Realloc(mReadBuffer, 
84841:             newBufLen);
84841:         if (newBuf) {
84841:             mReadBuffer = newBuf;
84841:             mReadBufferLen = newBufLen;
84841:         }
84841:         if (!mReadBuffer) {
84841:             mReadBufferLen = 0;
84841:             return NS_ERROR_OUT_OF_MEMORY;
84841:         }
84841:     }
84841: 
84841:     // read and inflate data until the output buffer is full, or
84841:     // there is no more data to read
84841:     while (NS_SUCCEEDED(rv) &&
84841:            zerr == Z_OK && 
84841:            mZstream.avail_out > 0 &&
84841:            count > 0) {
84841:         if (mZstream.avail_in == 0) {
84841:             rv = nsInputStreamWrapper::Read((char*)mReadBuffer, 
84841:                                             mReadBufferLen, 
84841:                                             &mZstream.avail_in);
84841:             if (NS_FAILED(rv) || !mZstream.avail_in) {
84841:                 break;
84841:             }
84841:             mZstream.next_in = mReadBuffer;
84841:         }
84841:         zerr = inflate(&mZstream, Z_NO_FLUSH);
84841:         if (zerr == Z_STREAM_END) {
84841:             // The compressed data may have been stored in multiple
84841:             // chunks/streams. To allow for this case, re-initialize 
84841:             // the inflate stream and continue decompressing from 
84841:             // the next byte.
84841:             Bytef * saveNextIn = mZstream.next_in;
84841:             unsigned int saveAvailIn = mZstream.avail_in;
84841:             Bytef * saveNextOut = mZstream.next_out;
84841:             unsigned int saveAvailOut = mZstream.avail_out;
84841:             inflateReset(&mZstream);
84841:             mZstream.next_in = saveNextIn;
84841:             mZstream.avail_in = saveAvailIn;
84841:             mZstream.next_out = saveNextOut;
84841:             mZstream.avail_out = saveAvailOut;
84841:             zerr = Z_OK;
84841:         } else if (zerr != Z_OK) {
84841:             rv = NS_ERROR_INVALID_CONTENT_ENCODING;
84841:         }
84841:     }
84841:     if (NS_SUCCEEDED(rv)) {
84841:         *countRead = count - mZstream.avail_out;
84841:     }
84841:     return rv;
84841: }
84841: 
84841: nsresult nsCacheEntryDescriptor::
84841: nsDecompressInputStreamWrapper::Close()
84841: {
84841:     EndZstream();
84841:     if (mReadBuffer) {
84841:         nsMemory::Free(mReadBuffer);
84841:         mReadBuffer = 0;
84841:         mReadBufferLen = 0;
84841:     }
84841:     return nsInputStreamWrapper::Close();
84841: }
84841: 
84841: nsresult nsCacheEntryDescriptor::
84841: nsDecompressInputStreamWrapper::InitZstream()
84841: {
84841:     // Initialize zlib inflate stream
84841:     mZstream.zalloc = Z_NULL;
84841:     mZstream.zfree = Z_NULL;
84841:     mZstream.opaque = Z_NULL;
84841:     mZstream.next_out = Z_NULL;
84841:     mZstream.avail_out = 0;
84841:     mZstream.next_in = Z_NULL;
84841:     mZstream.avail_in = 0;
84841:     if (inflateInit(&mZstream) != Z_OK) {
84841:         return NS_ERROR_FAILURE;
84841:     }
84841:     mStreamInitialized = PR_TRUE;
84841:     return NS_OK;
84841: }
84841: 
84841: nsresult nsCacheEntryDescriptor::
84841: nsDecompressInputStreamWrapper::EndZstream()
84841: {
84841:     if (mStreamInitialized && !mStreamEnded) {
84841:         inflateEnd(&mZstream);
84841:         mStreamEnded = PR_TRUE;
84841:     }
84841:     return NS_OK;
84841: }
84841: 
84841: 
84841: /******************************************************************************
84841:  * nsOutputStreamWrapper - a wrapper for nsIOutputstream to track the amount of
43113:  *                         data written to a cache entry.
43113:  *                       - also keeps the cache entry open while referenced.
43113:  ******************************************************************************/
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheEntryDescriptor::nsOutputStreamWrapper,
43113:                               nsIOutputStream)
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::LazyInit()
43113: {
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     nsCacheAccessMode mode;
43113:     nsresult rv = mDescriptor->GetAccessGranted(&mode);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     NS_ENSURE_TRUE(mode & nsICache::ACCESS_WRITE, NS_ERROR_UNEXPECTED);
43113: 
43113:     nsCacheEntry* cacheEntry = mDescriptor->CacheEntry();
43113:     if (!cacheEntry) return NS_ERROR_NOT_AVAILABLE;
43113: 
72221:     NS_ASSERTION(mOutput == nsnull, "mOutput set in LazyInit");
72221: 
72221:     nsCOMPtr<nsIOutputStream> stream;
70080:     rv = nsCacheService::OpenOutputStreamForEntry(cacheEntry, mode, mStartOffset,
72221:                                                   getter_AddRefs(stream));
72221:     if (NS_FAILED(rv))
72221:         return rv;
60325: 
43113:     nsCacheDevice* device = cacheEntry->CacheDevice();
72221:     if (device) {
72221:         // the entry has been truncated to mStartOffset bytes, inform device
43113:         PRInt32 size = cacheEntry->DataSize();
43113:         rv = device->OnDataSizeChange(cacheEntry, mStartOffset - size);
72221:         if (NS_SUCCEEDED(rv))
72221:             cacheEntry->SetDataSize(mStartOffset);
72221:     } else {
72221:         rv = NS_ERROR_NOT_AVAILABLE;
72221:     }
70080: 
72221:     // If anything above failed, clean up internal state and get out of here
72221:     // (see bug #654926)...
72221:     if (NS_FAILED(rv)) {
72221:         mDescriptor->InternalCleanup(stream);
72221:         return rv;
72221:     }
43113: 
72221:     // ... otherwise, set members and mark initialized
72221:     mDescriptor->mOutput = mOutput = stream;
80486:     mInitialized = true;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::OnWrite(PRUint32 count)
43113: {
43113:     if (count > PR_INT32_MAX)  return NS_ERROR_UNEXPECTED;
43113:     return mDescriptor->RequestDataSizeChange((PRInt32)count);
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::Close()
43113: {
43113:     nsresult rv = EnsureInit();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return mOutput->Close();
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::Flush()
43113: {
43113:     nsresult rv = EnsureInit();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return mOutput->Flush();
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::Write(const char * buf,
43113:                              PRUint32     count,
43113:                              PRUint32 *   result)
43113: {
43113:     nsresult rv = EnsureInit();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = OnWrite(count);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return mOutput->Write(buf, count, result);
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::WriteFrom(nsIInputStream * inStr,
43113:                                  PRUint32         count,
43113:                                  PRUint32 *       result)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::
43113: nsOutputStreamWrapper::WriteSegments(nsReadSegmentFun  reader,
43113:                                      void *            closure,
43113:                                      PRUint32          count,
43113:                                      PRUint32 *        result)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheEntryDescriptor::
79445: nsOutputStreamWrapper::IsNonBlocking(bool *result)
43113: {
43113:     // cache streams will never return NS_BASE_STREAM_WOULD_BLOCK
80486:     *result = false;
43113:     return NS_OK;
43113: }
84841: 
84841: 
84841: /******************************************************************************
84841:  * nsCompressOutputStreamWrapper - an output stream wrapper that compresses
84841:  *   data before it is written
84841:  ******************************************************************************/
84841: 
84841: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheEntryDescriptor::nsCompressOutputStreamWrapper,
84841:                               nsIOutputStream)
84841: 
84841: NS_IMETHODIMP nsCacheEntryDescriptor::
84841: nsCompressOutputStreamWrapper::Write(const char * buf,
84841:                                      PRUint32     count,
84841:                                      PRUint32 *   result)
84841: {
84841:     int zerr = Z_OK;
84841:     nsresult rv = NS_OK;
84841: 
84841:     if (!mStreamInitialized) {
84841:         rv = InitZstream();
84841:         if (NS_FAILED(rv)) {
84841:             return rv;
84841:         }
84841:     }
84841: 
84841:     if (!mWriteBuffer) {
84841:         // Once allocated, this buffer is referenced by the zlib stream and
84841:         // cannot be grown. We use 2x(initial write request) to approximate
84841:         // a stream buffer size proportional to request buffers.
84841:         mWriteBufferLen = NS_MAX(count*2, (PRUint32)kMinCompressWriteBufLen);
84841:         mWriteBuffer = (unsigned char*)nsMemory::Alloc(mWriteBufferLen);
84841:         if (!mWriteBuffer) {
84841:             mWriteBufferLen = 0;
84841:             return NS_ERROR_OUT_OF_MEMORY;
84841:         }
84841:         mZstream.next_out = mWriteBuffer;
84841:         mZstream.avail_out = mWriteBufferLen;
84841:     }
84841: 
84841:     // Compress (deflate) the requested buffer. Keep going
84841:     // until the entire buffer has been deflated.
84841:     mZstream.avail_in = count;
84841:     mZstream.next_in = (Bytef*)buf;
84841:     while (mZstream.avail_in > 0) {
84841:         zerr = deflate(&mZstream, Z_NO_FLUSH);
84841:         if (zerr == Z_STREAM_ERROR) {
88176:             deflateEnd(&mZstream);
88176:             mStreamInitialized = PR_FALSE;
84841:             return NS_ERROR_FAILURE;
84841:         }
84841:         // Note: Z_BUF_ERROR is non-fatal and sometimes expected here.
84841: 
84841:         // If the compression stream output buffer is filled, write
84841:         // it out to the underlying stream wrapper.
84841:         if (mZstream.avail_out == 0) {
84841:             rv = WriteBuffer();
84841:             if (NS_FAILED(rv)) {
88176:                 deflateEnd(&mZstream);
88176:                 mStreamInitialized = PR_FALSE;
84841:                 return rv;
84841:             }
84841:         }
84841:     }
84841:     *result = count;
84841:     mUncompressedCount += *result;
84841:     return NS_OK;
84841: }
84841: 
84841: NS_IMETHODIMP nsCacheEntryDescriptor::
84841: nsCompressOutputStreamWrapper::Close()
84841: {
84841:     nsresult rv = NS_OK;
84841:     int zerr = 0;
84841: 
84841:     if (mStreamInitialized) {
84841:         // complete compression of any data remaining in the zlib stream
84841:         do {
84841:             zerr = deflate(&mZstream, Z_FINISH);
84841:             rv = WriteBuffer();
84841:         } while (zerr == Z_OK && rv == NS_OK);
84841:         deflateEnd(&mZstream);
84841:     }
84841: 
84841:     if (mDescriptor->CacheEntry()) {
84841:         nsCAutoString uncompressedLenStr;
84841:         rv = mDescriptor->GetMetaDataElement("uncompressed-len",
84841:                                              getter_Copies(uncompressedLenStr));
84841:         if (NS_SUCCEEDED(rv)) {
84841:             PRInt32 oldCount = uncompressedLenStr.ToInteger(&rv);
84841:             if (NS_SUCCEEDED(rv)) {
84841:                 mUncompressedCount += oldCount;
84841:             }
84841:         }
84841:         uncompressedLenStr.Adopt(0);
84841:         uncompressedLenStr.AppendInt(mUncompressedCount);
84841:         rv = mDescriptor->SetMetaDataElement("uncompressed-len",
84841:             uncompressedLenStr.get());
84841:     }
84841: 
84841:     if (mWriteBuffer) {
84841:         nsMemory::Free(mWriteBuffer);
84841:         mWriteBuffer = 0;
84841:         mWriteBufferLen = 0;
84841:     }
84841: 
84841:     return nsOutputStreamWrapper::Close();
84841: }
84841: 
84841: nsresult nsCacheEntryDescriptor::
84841: nsCompressOutputStreamWrapper::InitZstream()
84841: {
84841:     // Determine compression level: Aggressive compression
84841:     // may impact performance on mobile devices, while a
84841:     // lower compression level still provides substantial
84841:     // space savings for many text streams.
84841:     PRInt32 compressionLevel = nsCacheService::CacheCompressionLevel();
84841: 
84841:     // Initialize zlib deflate stream
84841:     mZstream.zalloc = Z_NULL;
84841:     mZstream.zfree = Z_NULL;
84841:     mZstream.opaque = Z_NULL;
84841:     if (deflateInit2(&mZstream, compressionLevel, Z_DEFLATED,
84841:                      MAX_WBITS, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
84841:         return NS_ERROR_FAILURE;
84841:     }
84841:     mZstream.next_in = Z_NULL;
84841:     mZstream.avail_in = 0;
84841: 
84841:     mStreamInitialized = PR_TRUE;
84841: 
84841:     return NS_OK;
84841: }
84841: 
84841: nsresult nsCacheEntryDescriptor::
84841: nsCompressOutputStreamWrapper::WriteBuffer()
84841: {
84841:     PRUint32 bytesToWrite = mWriteBufferLen - mZstream.avail_out;
84841:     PRUint32 result = 0;
84841:     nsresult rv = nsCacheEntryDescriptor::nsOutputStreamWrapper::Write(
84841:         (const char *)mWriteBuffer, bytesToWrite, &result);
84841:     mZstream.next_out = mWriteBuffer;
84841:     mZstream.avail_out = mWriteBufferLen;
84841:     return rv;
84841: }
84841: 
