 16122: /* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
     1: /* cairo - a vector graphics library with display and print output
     1:  *
     1:  * Copyright © 2000 Keith Packard
     1:  * Copyright © 2005 Red Hat, Inc
     1:  *
     1:  * This library is free software; you can redistribute it and/or
     1:  * modify it either under the terms of the GNU Lesser General Public
     1:  * License version 2.1 as published by the Free Software Foundation
     1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
     1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
     1:  * notice, a recipient may use your version of this file under either
     1:  * the MPL or the LGPL.
     1:  *
     1:  * You should have received a copy of the LGPL along with this library
     1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 70960:  * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
     1:  * You should have received a copy of the MPL along with this library
     1:  * in the file COPYING-MPL-1.1
     1:  *
     1:  * The contents of this file are subject to the Mozilla Public License
     1:  * Version 1.1 (the "License"); you may not use this file except in
     1:  * compliance with the License. You may obtain a copy of the License at
     1:  * http://www.mozilla.org/MPL/
     1:  *
     1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
     1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
     1:  * the specific language governing rights and limitations.
     1:  *
     1:  * The Original Code is the cairo graphics library.
     1:  *
     1:  * The Initial Developer of the Original Code is Red Hat, Inc.
     1:  *
     1:  * Contributor(s):
     1:  *      Graydon Hoare <graydon@redhat.com>
     1:  *	Owen Taylor <otaylor@redhat.com>
     1:  *      Keith Packard <keithp@keithp.com>
     1:  *      Carl Worth <cworth@cworth.org>
     1:  */
     1: 
 13107: #define _BSD_SOURCE /* for strdup() */
  4133: #include "cairoint.h"
  4133: 
 70960: #include "cairo-error-private.h"
  4133: #include "cairo-ft-private.h"
  4133: 
  3847: #include <float.h>
  3835: 
 70960: #include "cairo-fontconfig-private.h"
     1: 
     1: #include <ft2build.h>
     1: #include FT_FREETYPE_H
     1: #include FT_OUTLINE_H
     1: #include FT_IMAGE_H
     1: #include FT_TRUETYPE_TABLES_H
     1: #if HAVE_FT_GLYPHSLOT_EMBOLDEN
     1: #include FT_SYNTHESIS_H
     1: #endif
     1: 
 70960: #if HAVE_FT_LIBRARY_SETLCDFILTER
 70960: #include FT_LCD_FILTER_H
 70960: #endif
 70960: 
 71616: #define _GNU_SOURCE /* for RTLD_DEFAULT */
 71616: #include <dlfcn.h>
 71616: 
 71616: #ifndef RTLD_DEFAULT
 71616: #define RTLD_DEFAULT ((void *) 0)
 71616: #endif
 71616: 
 70960: /* Fontconfig version older than 2.6 didn't have these options */
 70960: #ifndef FC_LCD_FILTER
 70960: #define FC_LCD_FILTER	"lcdfilter"
 70960: #endif
 70960: /* Some Ubuntu versions defined FC_LCD_FILTER without defining the following */
 70960: #ifndef FC_LCD_NONE
 70960: #define FC_LCD_NONE	0
 70960: #define FC_LCD_DEFAULT	1
 70960: #define FC_LCD_LIGHT	2
 70960: #define FC_LCD_LEGACY	3
 70960: #endif
 70960: 
 70960: /* FreeType version older than 2.3.5(?) didn't have these options */
 70960: #ifndef FT_LCD_FILTER_NONE
 70960: #define FT_LCD_FILTER_NONE	0
 70960: #define FT_LCD_FILTER_DEFAULT	1
 70960: #define FT_LCD_FILTER_LIGHT	2
 70960: #define FT_LCD_FILTER_LEGACY	16
 70960: #endif
 70960: 
 71616: typedef FT_Error (*setLcdFilterFunc)(FT_Library, int);
 71616: static setLcdFilterFunc setLcdFilter;
 71616: 
     1: #define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 64.0))
     1: #define DOUBLE_FROM_26_6(t) ((double)(t) / 64.0)
     1: #define DOUBLE_TO_16_16(d) ((FT_Fixed)((d) * 65536.0))
     1: #define DOUBLE_FROM_16_16(t) ((double)(t) / 65536.0)
     1: 
     1: /* This is the max number of FT_face objects we keep open at once
     1:  */
     1: #define MAX_OPEN_FACES 10
 12589: /* This is the maximum font size we allow to be passed to FT_Set_Char_Size
 12589:  */
 12589: #define MAX_FONT_SIZE 1000
 12589: 
 70960: /**
 70960:  * SECTION:cairo-ft
 70960:  * @Title: FreeType Fonts
 70960:  * @Short_Description: Font support for FreeType
 70960:  * @See_Also: #cairo_font_face_t
 70960:  *
 70960:  * The FreeType font backend is primarily used to render text on GNU/Linux
 70960:  * systems, but can be used on other platforms too.
 70960:  */
 70960: 
 70960: /**
 70960:  * CAIRO_HAS_FT_FONT:
 70960:  *
 70960:  * Defined if the FreeType font backend is available.
 70960:  * This macro can be used to conditionally compile backend-specific code.
 70960:  */
 70960: 
 70960: /**
 70960:  * CAIRO_HAS_FC_FONT:
 70960:  *
 70960:  * Defined if the Fontconfig-specific functions of the FreeType font backend
 70960:  * are available.
 70960:  * This macro can be used to conditionally compile backend-specific code.
 70960:  */
 70960: 
     1: /*
     1:  * The simple 2x2 matrix is converted into separate scale and shape
     1:  * factors so that hinting works right
     1:  */
     1: 
     1: typedef struct _cairo_ft_font_transform {
     1:     double  x_scale, y_scale;
     1:     double  shape[2][2];
     1: } cairo_ft_font_transform_t;
     1: 
     1: /*
     1:  * We create an object that corresponds to a single font on the disk;
     1:  * (identified by a filename/id pair) these are shared between all
     1:  * fonts using that file.  For cairo_ft_font_face_create_for_ft_face(), we
     1:  * just create a one-off version with a permanent face value.
     1:  */
     1: 
     1: typedef struct _cairo_ft_font_face cairo_ft_font_face_t;
     1: 
     1: struct _cairo_ft_unscaled_font {
     1:     cairo_unscaled_font_t base;
     1: 
 16122:     cairo_bool_t from_face; /* was the FT_Face provided by user? */
     1:     FT_Face face;	    /* provided or cached face */
     1: 
     1:     /* only set if from_face is false */
     1:     char *filename;
     1:     int id;
     1: 
     1:     /* We temporarily scale the unscaled font as needed */
     1:     cairo_bool_t have_scale;
     1:     cairo_matrix_t current_scale;
     1:     double x_scale;		/* Extracted X scale factor */
     1:     double y_scale;             /* Extracted Y scale factor */
     1:     cairo_bool_t have_shape;	/* true if the current scale has a non-scale component*/
     1:     cairo_matrix_t current_shape;
     1:     FT_Matrix Current_Shape;
     1: 
   314:     cairo_mutex_t mutex;
   314:     int lock_count;
     1: 
     1:     cairo_ft_font_face_t *faces;	/* Linked list of faces for this font */
     1: };
     1: 
     1: static int
     1: _cairo_ft_unscaled_font_keys_equal (const void *key_a,
     1: 				    const void *key_b);
     1: 
     1: static void
     1: _cairo_ft_unscaled_font_fini (cairo_ft_unscaled_font_t *unscaled);
     1: 
     1: typedef enum _cairo_ft_extra_flags {
     1:     CAIRO_FT_OPTIONS_HINT_METRICS = (1 << 0),
     1:     CAIRO_FT_OPTIONS_EMBOLDEN = (1 << 1)
     1: } cairo_ft_extra_flags_t;
     1: 
     1: typedef struct _cairo_ft_options {
     1:     cairo_font_options_t    base;
     1:     int			    load_flags;	 /* flags for FT_Load_Glyph */
     1:     cairo_ft_extra_flags_t  extra_flags; /* other flags that affect results */
     1: } cairo_ft_options_t;
     1: 
     1: struct _cairo_ft_font_face {
     1:     cairo_font_face_t base;
 26419: 
     1:     cairo_ft_unscaled_font_t *unscaled;
     1:     cairo_ft_options_t ft_options;
     1:     cairo_ft_font_face_t *next;
 26419: 
 26419: #if CAIRO_HAS_FC_FONT
 26419:     FcPattern *pattern; /* if pattern is set, the above fields will be NULL */
 32473:     cairo_font_face_t *resolved_font_face;
 32473:     FcConfig *resolved_config;
 26419: #endif
     1: };
     1: 
     1: static const cairo_unscaled_font_backend_t cairo_ft_unscaled_font_backend;
     1: 
 26419: #if CAIRO_HAS_FC_FONT
 26419: static cairo_status_t
 26419: _cairo_ft_font_options_substitute (const cairo_font_options_t *options,
 26419: 				   FcPattern                  *pattern);
 26419: 
 32473: static cairo_font_face_t *
 26419: _cairo_ft_resolve_pattern (FcPattern		      *pattern,
 26419: 			   const cairo_matrix_t       *font_matrix,
 26419: 			   const cairo_matrix_t       *ctm,
 32473: 			   const cairo_font_options_t *options);
 26419: 
 26419: #endif
 26419: 
     1: /*
 11708:  * We maintain a hash table to map file/id => #cairo_ft_unscaled_font_t.
     1:  * The hash table itself isn't limited in size. However, we limit the
     1:  * number of FT_Face objects we keep around; when we've exceeded that
     1:  * limit and need to create a new FT_Face, we dump the FT_Face from a
 11708:  * random #cairo_ft_unscaled_font_t which has an unlocked FT_Face, (if
     1:  * there are any).
     1:  */
     1: 
     1: typedef struct _cairo_ft_unscaled_font_map {
     1:     cairo_hash_table_t *hash_table;
     1:     FT_Library ft_library;
     1:     int num_open_faces;
     1: } cairo_ft_unscaled_font_map_t;
     1: 
     1: static cairo_ft_unscaled_font_map_t *cairo_ft_unscaled_font_map = NULL;
     1: 
 70960: 
     1: static void
     1: _font_map_release_face_lock_held (cairo_ft_unscaled_font_map_t *font_map,
     1: 				  cairo_ft_unscaled_font_t *unscaled)
     1: {
     1:     if (unscaled->face) {
     1: 	FT_Done_Face (unscaled->face);
     1: 	unscaled->face = NULL;
     1: 	unscaled->have_scale = FALSE;
     1: 
     1: 	font_map->num_open_faces--;
     1:     }
     1: }
     1: 
 26419: static cairo_status_t
     1: _cairo_ft_unscaled_font_map_create (void)
     1: {
     1:     cairo_ft_unscaled_font_map_t *font_map;
     1: 
     1:     /* This function is only intended to be called from
     1:      * _cairo_ft_unscaled_font_map_lock. So we'll crash if we can
     1:      * detect some other call path. */
     1:     assert (cairo_ft_unscaled_font_map == NULL);
     1: 
     1:     font_map = malloc (sizeof (cairo_ft_unscaled_font_map_t));
 26419:     if (unlikely (font_map == NULL))
 26419: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
     1:     font_map->hash_table =
     1: 	_cairo_hash_table_create (_cairo_ft_unscaled_font_keys_equal);
     1: 
 26419:     if (unlikely (font_map->hash_table == NULL))
     1: 	goto FAIL;
     1: 
 26419:     if (unlikely (FT_Init_FreeType (&font_map->ft_library)))
     1: 	goto FAIL;
     1: 
     1:     font_map->num_open_faces = 0;
     1: 
     1:     cairo_ft_unscaled_font_map = font_map;
 26419:     return CAIRO_STATUS_SUCCESS;
     1: 
     1: FAIL:
     1:     if (font_map->hash_table)
     1: 	_cairo_hash_table_destroy (font_map->hash_table);
     1:     free (font_map);
 26419: 
 26419:     return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: }
 26419: 
     1: 
     1: static void
 26419: _cairo_ft_unscaled_font_map_pluck_entry (void *entry, void *closure)
     1: {
 26419:     cairo_ft_unscaled_font_t *unscaled = entry;
 26419:     cairo_ft_unscaled_font_map_t *font_map = closure;
 26419: 
     1:     _cairo_hash_table_remove (font_map->hash_table,
     1: 			      &unscaled->base.hash_entry);
     1: 
 32473:     if (! unscaled->from_face)
     1: 	_font_map_release_face_lock_held (font_map, unscaled);
 32473: 
     1:     _cairo_ft_unscaled_font_fini (unscaled);
     1:     free (unscaled);
     1: }
     1: 
 26419: static void
 26419: _cairo_ft_unscaled_font_map_destroy (void)
 26419: {
 26419:     cairo_ft_unscaled_font_map_t *font_map;
 26419: 
 26419:     CAIRO_MUTEX_LOCK (_cairo_ft_unscaled_font_map_mutex);
 26419:     font_map = cairo_ft_unscaled_font_map;
 26419:     cairo_ft_unscaled_font_map = NULL;
 26419:     CAIRO_MUTEX_UNLOCK (_cairo_ft_unscaled_font_map_mutex);
 26419: 
 26419:     if (font_map != NULL) {
 26419: 	_cairo_hash_table_foreach (font_map->hash_table,
 26419: 				   _cairo_ft_unscaled_font_map_pluck_entry,
 26419: 				   font_map);
     1: 	assert (font_map->num_open_faces == 0);
     1: 
     1: 	FT_Done_FreeType (font_map->ft_library);
     1: 
     1: 	_cairo_hash_table_destroy (font_map->hash_table);
     1: 
     1: 	free (font_map);
     1:     }
     1: }
     1: 
     1: static cairo_ft_unscaled_font_map_t *
     1: _cairo_ft_unscaled_font_map_lock (void)
     1: {
   314:     CAIRO_MUTEX_LOCK (_cairo_ft_unscaled_font_map_mutex);
     1: 
 26419:     if (unlikely (cairo_ft_unscaled_font_map == NULL)) {
 26419: 	if (unlikely (_cairo_ft_unscaled_font_map_create ())) {
   314: 	    CAIRO_MUTEX_UNLOCK (_cairo_ft_unscaled_font_map_mutex);
     1: 	    return NULL;
     1: 	}
     1:     }
     1: 
     1:     return cairo_ft_unscaled_font_map;
     1: }
     1: 
     1: static void
     1: _cairo_ft_unscaled_font_map_unlock (void)
     1: {
   314:     CAIRO_MUTEX_UNLOCK (_cairo_ft_unscaled_font_map_mutex);
     1: }
     1: 
     1: static void
     1: _cairo_ft_unscaled_font_init_key (cairo_ft_unscaled_font_t *key,
 16122: 				  cairo_bool_t              from_face,
     1: 				  char			   *filename,
 16122: 				  int			    id,
 16122: 				  FT_Face		    face)
     1: {
     1:     unsigned long hash;
     1: 
 16122:     key->from_face = from_face;
     1:     key->filename = filename;
     1:     key->id = id;
 16122:     key->face = face;
 16122: 
     1:     hash = _cairo_hash_string (filename);
 16122:     /* the constants are just arbitrary primes */
     1:     hash += ((unsigned long) id) * 1607;
 16122:     hash += ((unsigned long) face) * 2137;
     1: 
     1:     key->base.hash_entry.hash = hash;
     1: }
     1: 
     1: /**
     1:  * _cairo_ft_unscaled_font_init:
     1:  *
 11708:  * Initialize a #cairo_ft_unscaled_font_t.
     1:  *
 11708:  * There are two basic flavors of #cairo_ft_unscaled_font_t, one
     1:  * created from an FT_Face and the other created from a filename/id
     1:  * pair. These two flavors are identified as from_face and !from_face.
     1:  *
 11708:  * To initialize a from_face font, pass filename==%NULL, id=0 and the
     1:  * desired face.
     1:  *
     1:  * To initialize a !from_face font, pass the filename/id as desired
 11708:  * and face==%NULL.
     1:  *
     1:  * Note that the code handles these two flavors in very distinct
     1:  * ways. For example there is a hash_table mapping
 11708:  * filename/id->#cairo_unscaled_font_t in the !from_face case, but no
     1:  * parallel in the from_face case, (where the calling code would have
     1:  * to do its own mapping to ensure similar sharing).
     1:  **/
     1: static cairo_status_t
     1: _cairo_ft_unscaled_font_init (cairo_ft_unscaled_font_t *unscaled,
 16122: 			      cairo_bool_t              from_face,
     1: 			      const char	       *filename,
     1: 			      int			id,
     1: 			      FT_Face			face)
     1: {
     1:     _cairo_unscaled_font_init (&unscaled->base,
     1: 			       &cairo_ft_unscaled_font_backend);
     1: 
 16122:     if (from_face) {
     1: 	unscaled->from_face = TRUE;
 16122: 	_cairo_ft_unscaled_font_init_key (unscaled, TRUE, NULL, 0, face);
     1:     } else {
     1: 	char *filename_copy;
     1: 
     1: 	unscaled->from_face = FALSE;
     1: 	unscaled->face = NULL;
     1: 
     1: 	filename_copy = strdup (filename);
 26419: 	if (unlikely (filename_copy == NULL))
  8452: 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419: 
 16122: 	_cairo_ft_unscaled_font_init_key (unscaled, FALSE, filename_copy, id, NULL);
     1:     }
     1: 
     1:     unscaled->have_scale = FALSE;
  4133:     CAIRO_MUTEX_INIT (unscaled->mutex);
   314:     unscaled->lock_count = 0;
     1: 
     1:     unscaled->faces = NULL;
     1: 
     1:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: /**
     1:  * _cairo_ft_unscaled_font_fini:
     1:  *
 11708:  * Free all data associated with a #cairo_ft_unscaled_font_t.
     1:  *
 11708:  * CAUTION: The unscaled->face field must be %NULL before calling this
 11708:  * function. This is because the #cairo_ft_unscaled_font_t_map keeps a
     1:  * count of these faces (font_map->num_open_faces) so it maintains the
     1:  * unscaled->face field while it has its lock held. See
     1:  * _font_map_release_face_lock_held().
     1:  **/
     1: static void
     1: _cairo_ft_unscaled_font_fini (cairo_ft_unscaled_font_t *unscaled)
     1: {
     1:     assert (unscaled->face == NULL);
     1: 
     1:     if (unscaled->filename) {
     1: 	free (unscaled->filename);
     1: 	unscaled->filename = NULL;
     1:     }
   314: 
  4133:     CAIRO_MUTEX_FINI (unscaled->mutex);
     1: }
     1: 
     1: static int
     1: _cairo_ft_unscaled_font_keys_equal (const void *key_a,
     1: 				    const void *key_b)
     1: {
     1:     const cairo_ft_unscaled_font_t *unscaled_a = key_a;
     1:     const cairo_ft_unscaled_font_t *unscaled_b = key_b;
     1: 
 16122:     if (unscaled_a->id == unscaled_b->id &&
 16122: 	unscaled_a->from_face == unscaled_b->from_face)
 16122:     {
 16122:         if (unscaled_a->from_face)
 16122: 	    return unscaled_a->face == unscaled_b->face;
 16122: 
 16122: 	if (unscaled_a->filename == NULL && unscaled_b->filename == NULL)
 16122: 	    return TRUE;
 16122: 	else if (unscaled_a->filename == NULL || unscaled_b->filename == NULL)
 16122: 	    return FALSE;
 16122: 	else
 16122: 	    return (strcmp (unscaled_a->filename, unscaled_b->filename) == 0);
 16122:     }
 16122: 
 16122:     return FALSE;
     1: }
     1: 
 11708: /* Finds or creates a #cairo_ft_unscaled_font_t for the filename/id from
     1:  * pattern.  Returns a new reference to the unscaled font.
     1:  */
 28364: static cairo_status_t
 16122: _cairo_ft_unscaled_font_create_internal (cairo_bool_t from_face,
 16122: 					 char *filename,
 16122: 					 int id,
 28364: 					 FT_Face font_face,
 28364: 					 cairo_ft_unscaled_font_t **out)
     1: {
     1:     cairo_ft_unscaled_font_t key, *unscaled;
     1:     cairo_ft_unscaled_font_map_t *font_map;
     1:     cairo_status_t status;
     1: 
     1:     font_map = _cairo_ft_unscaled_font_map_lock ();
 26419:     if (unlikely (font_map == NULL))
 28364: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
 16122:     _cairo_ft_unscaled_font_init_key (&key, from_face, filename, id, font_face);
     1: 
     1:     /* Return existing unscaled font if it exists in the hash table. */
 26419:     unscaled = _cairo_hash_table_lookup (font_map->hash_table,
 26419: 					 &key.base.hash_entry);
 26419:     if (unscaled != NULL) {
  4133: 	_cairo_unscaled_font_reference (&unscaled->base);
 28364: 	goto DONE;
     1:     }
     1: 
     1:     /* Otherwise create it and insert into hash table. */
     1:     unscaled = malloc (sizeof (cairo_ft_unscaled_font_t));
 26419:     if (unlikely (unscaled == NULL)) {
 28364: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 	goto UNWIND_FONT_MAP_LOCK;
  8452:     }
     1: 
 16122:     status = _cairo_ft_unscaled_font_init (unscaled, from_face, filename, id, font_face);
 26419:     if (unlikely (status))
     1: 	goto UNWIND_UNSCALED_MALLOC;
     1: 
 26419:     assert (unscaled->base.hash_entry.hash == key.base.hash_entry.hash);
     1:     status = _cairo_hash_table_insert (font_map->hash_table,
     1: 				       &unscaled->base.hash_entry);
 26419:     if (unlikely (status))
     1: 	goto UNWIND_UNSCALED_FONT_INIT;
     1: 
 28364: DONE:
     1:     _cairo_ft_unscaled_font_map_unlock ();
 28364:     *out = unscaled;
 28364:     return CAIRO_STATUS_SUCCESS;
     1: 
     1: UNWIND_UNSCALED_FONT_INIT:
     1:     _cairo_ft_unscaled_font_fini (unscaled);
     1: UNWIND_UNSCALED_MALLOC:
     1:     free (unscaled);
     1: UNWIND_FONT_MAP_LOCK:
     1:     _cairo_ft_unscaled_font_map_unlock ();
 28364:     return status;
     1: }
     1: 
 26419: 
 26419: #if CAIRO_HAS_FC_FONT
 28364: static cairo_status_t
 28364: _cairo_ft_unscaled_font_create_for_pattern (FcPattern *pattern,
 28364: 					    cairo_ft_unscaled_font_t **out)
 16122: {
 16122:     FT_Face font_face = NULL;
 16122:     char *filename = NULL;
 16122:     int id = 0;
 28364:     FcResult ret;
 28364: 
 28364:     ret = FcPatternGetFTFace (pattern, FC_FT_FACE, 0, &font_face);
 29608:     if (ret == FcResultMatch)
 26419: 	goto DONE;
 29608:     if (ret == FcResultOutOfMemory)
 29608: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 29608: 
 29608:     ret = FcPatternGetString (pattern, FC_FILE, 0, (FcChar8 **) &filename);
 29608:     if (ret == FcResultOutOfMemory)
 29608: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 29608:     if (ret == FcResultMatch) {
 26419: 	/* If FC_INDEX is not set, we just use 0 */
 29608: 	ret = FcPatternGetInteger (pattern, FC_INDEX, 0, &id);
 29608: 	if (ret == FcResultOutOfMemory)
 29608: 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 29608: 
 26419: 	goto DONE;
 16122:     }
 29608: 
 29608:     /* The pattern contains neither a face nor a filename, resolve it later. */
 29608:     *out = NULL;
 29608:     return CAIRO_STATUS_SUCCESS;
 26419: 
 26419: DONE:
 28364:     return _cairo_ft_unscaled_font_create_internal (font_face != NULL,
 28364: 						    filename, id, font_face,
 28364: 						    out);
 16122: }
 24104: #endif
 16122: 
 28364: static cairo_status_t
 28364: _cairo_ft_unscaled_font_create_from_face (FT_Face face,
 28364: 					  cairo_ft_unscaled_font_t **out)
     1: {
 28364:     return _cairo_ft_unscaled_font_create_internal (TRUE, NULL, 0, face, out);
     1: }
     1: 
     1: static void
     1: _cairo_ft_unscaled_font_destroy (void *abstract_font)
     1: {
     1:     cairo_ft_unscaled_font_t *unscaled  = abstract_font;
 16122:     cairo_ft_unscaled_font_map_t *font_map;
     1: 
     1:     if (unscaled == NULL)
     1: 	return;
     1: 
 16122:     font_map = _cairo_ft_unscaled_font_map_lock ();
 16122:     /* All created objects must have been mapped in the font map. */
 16122:     assert (font_map != NULL);
 16122: 
 26419:     if (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&unscaled->base.ref_count)) {
 26419: 	/* somebody recreated the font whilst we waited for the lock */
 26419: 	_cairo_ft_unscaled_font_map_unlock ();
 26419: 	return;
 26419:     }
 26419: 
 16122:     _cairo_hash_table_remove (font_map->hash_table,
 16122: 			      &unscaled->base.hash_entry);
 16122: 
     1:     if (unscaled->from_face) {
     1: 	/* See comments in _ft_font_face_destroy about the "zombie" state
     1: 	 * for a _ft_font_face.
     1: 	 */
 28494: 	if (unscaled->faces && unscaled->faces->unscaled == NULL) {
 28494: 	    assert (unscaled->faces->next == NULL);
     1: 	    cairo_font_face_destroy (&unscaled->faces->base);
 28494: 	}
 16122:     } else {
 16122: 	_font_map_release_face_lock_held (font_map, unscaled);
 16122:     }
 16077:     unscaled->face = NULL;
 16077: 
 16077:     _cairo_ft_unscaled_font_map_unlock ();
 16122: 
  8452:     _cairo_ft_unscaled_font_fini (unscaled);
     1: }
     1: 
     1: static cairo_bool_t
 26419: _has_unlocked_face (const void *entry)
     1: {
 26419:     const cairo_ft_unscaled_font_t *unscaled = entry;
 26419: 
 26419:     return (!unscaled->from_face && unscaled->lock_count == 0 && unscaled->face);
     1: }
     1: 
     1: /* Ensures that an unscaled font has a face object. If we exceed
     1:  * MAX_OPEN_FACES, try to close some.
     1:  *
     1:  * This differs from _cairo_ft_scaled_font_lock_face in that it doesn't
     1:  * set the scale on the face, but just returns it at the last scale.
     1:  */
 18904: cairo_warn FT_Face
     1: _cairo_ft_unscaled_font_lock_face (cairo_ft_unscaled_font_t *unscaled)
     1: {
     1:     cairo_ft_unscaled_font_map_t *font_map;
     1:     FT_Face face = NULL;
     1: 
   314:     CAIRO_MUTEX_LOCK (unscaled->mutex);
   314:     unscaled->lock_count++;
   314: 
   314:     if (unscaled->face)
     1: 	return unscaled->face;
     1: 
     1:     /* If this unscaled font was created from an FT_Face then we just
     1:      * returned it above. */
     1:     assert (!unscaled->from_face);
     1: 
     1:     font_map = _cairo_ft_unscaled_font_map_lock ();
   314:     {
     1: 	assert (font_map != NULL);
     1: 
     1: 	while (font_map->num_open_faces >= MAX_OPEN_FACES)
     1: 	{
     1: 	    cairo_ft_unscaled_font_t *entry;
     1: 
     1: 	    entry = _cairo_hash_table_random_entry (font_map->hash_table,
     1: 						    _has_unlocked_face);
     1: 	    if (entry == NULL)
     1: 		break;
     1: 
     1: 	    _font_map_release_face_lock_held (font_map, entry);
     1: 	}
   314:     }
   314:     _cairo_ft_unscaled_font_map_unlock ();
     1: 
     1:     if (FT_New_Face (font_map->ft_library,
     1: 		     unscaled->filename,
     1: 		     unscaled->id,
     1: 		     &face) != FT_Err_Ok)
   314:     {
  6154: 	unscaled->lock_count--;
   314: 	CAIRO_MUTEX_UNLOCK (unscaled->mutex);
  8452: 	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
   314: 	return NULL;
   314:     }
     1: 
     1:     unscaled->face = face;
     1: 
     1:     font_map->num_open_faces++;
     1: 
     1:     return face;
     1: }
 16122: 
     1: 
     1: /* Unlock unscaled font locked with _cairo_ft_unscaled_font_lock_face
     1:  */
     1: void
     1: _cairo_ft_unscaled_font_unlock_face (cairo_ft_unscaled_font_t *unscaled)
     1: {
   314:     assert (unscaled->lock_count > 0);
   314: 
   314:     unscaled->lock_count--;
   314: 
   314:     CAIRO_MUTEX_UNLOCK (unscaled->mutex);
     1: }
 16122: 
     1: 
 11708: static cairo_status_t
     1: _compute_transform (cairo_ft_font_transform_t *sf,
     1: 		    cairo_matrix_t      *scale)
     1: {
 11708:     cairo_status_t status;
 12588:     double x_scale, y_scale;
     1:     cairo_matrix_t normalized = *scale;
     1: 
     1:     /* The font matrix has x and y "scale" components which we extract and
     1:      * use as character scale values. These influence the way freetype
     1:      * chooses hints, as well as selecting different bitmaps in
     1:      * hand-rendered fonts. We also copy the normalized matrix to
     1:      * freetype's transformation.
     1:      */
     1: 
 18904:     status = _cairo_matrix_compute_basis_scale_factors (scale,
 12588: 						  &x_scale, &y_scale,
 16122: 						  1);
 26419:     if (unlikely (status))
 11708: 	return status;
     1: 
 12588:     /* FreeType docs say this about x_scale and y_scale:
 12588:      * "A character width or height smaller than 1pt is set to 1pt;"
 12588:      * So, we cap them from below at 1.0 and let the FT transform
 12588:      * take care of sub-1.0 scaling. */
 12588:     if (x_scale < 1.0)
 12588:       x_scale = 1.0;
 12588:     if (y_scale < 1.0)
 12588:       y_scale = 1.0;
 12588: 
 12588:     sf->x_scale = x_scale;
 12588:     sf->y_scale = y_scale;
 12588: 
 12588:     cairo_matrix_scale (&normalized, 1.0 / x_scale, 1.0 / y_scale);
     1: 
     1:     _cairo_matrix_get_affine (&normalized,
     1: 			      &sf->shape[0][0], &sf->shape[0][1],
     1: 			      &sf->shape[1][0], &sf->shape[1][1],
  6154: 			      NULL, NULL);
 11708: 
 11708:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: /* Temporarily scales an unscaled font to the give scale. We catch
     1:  * scaling to the same size, since changing a FT_Face is expensive.
     1:  */
  4133: static cairo_status_t
     1: _cairo_ft_unscaled_font_set_scale (cairo_ft_unscaled_font_t *unscaled,
     1: 				   cairo_matrix_t	      *scale)
     1: {
 11708:     cairo_status_t status;
     1:     cairo_ft_font_transform_t sf;
     1:     FT_Matrix mat;
     1:     FT_Error error;
     1: 
     1:     assert (unscaled->face != NULL);
     1: 
     1:     if (unscaled->have_scale &&
     1: 	scale->xx == unscaled->current_scale.xx &&
     1: 	scale->yx == unscaled->current_scale.yx &&
     1: 	scale->xy == unscaled->current_scale.xy &&
     1: 	scale->yy == unscaled->current_scale.yy)
  4133: 	return CAIRO_STATUS_SUCCESS;
     1: 
     1:     unscaled->have_scale = TRUE;
     1:     unscaled->current_scale = *scale;
     1: 
 11708:     status = _compute_transform (&sf, scale);
 26419:     if (unlikely (status))
 11708: 	return status;
     1: 
     1:     unscaled->x_scale = sf.x_scale;
     1:     unscaled->y_scale = sf.y_scale;
     1: 
     1:     mat.xx = DOUBLE_TO_16_16(sf.shape[0][0]);
     1:     mat.yx = - DOUBLE_TO_16_16(sf.shape[0][1]);
     1:     mat.xy = - DOUBLE_TO_16_16(sf.shape[1][0]);
     1:     mat.yy = DOUBLE_TO_16_16(sf.shape[1][1]);
     1: 
     1:     unscaled->have_shape = (mat.xx != 0x10000 ||
     1: 			    mat.yx != 0x00000 ||
     1: 			    mat.xy != 0x00000 ||
     1: 			    mat.yy != 0x10000);
     1: 
     1:     unscaled->Current_Shape = mat;
     1:     cairo_matrix_init (&unscaled->current_shape,
     1: 		       sf.shape[0][0], sf.shape[0][1],
     1: 		       sf.shape[1][0], sf.shape[1][1],
     1: 		       0.0, 0.0);
     1: 
     1:     FT_Set_Transform(unscaled->face, &mat, NULL);
     1: 
     1:     if ((unscaled->face->face_flags & FT_FACE_FLAG_SCALABLE) != 0) {
 12589: 	double x_scale = MIN(sf.x_scale, MAX_FONT_SIZE);
 12589: 	double y_scale = MIN(sf.y_scale, MAX_FONT_SIZE);
     1: 	error = FT_Set_Char_Size (unscaled->face,
 12589: 				  x_scale * 64.0 + .5,
 12589: 				  y_scale * 64.0 + .5,
  3847: 				  0, 0);
  8452: 	if (error)
  8452: 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1:     } else {
     1: 	double min_distance = DBL_MAX;
     1: 	int i;
     1: 	int best_i = 0;
     1: 
     1: 	for (i = 0; i < unscaled->face->num_fixed_sizes; i++) {
     1: #if HAVE_FT_BITMAP_SIZE_Y_PPEM
     1: 	    double size = unscaled->face->available_sizes[i].y_ppem / 64.;
     1: #else
     1: 	    double size = unscaled->face->available_sizes[i].height;
     1: #endif
     1: 	    double distance = fabs (size - sf.y_scale);
     1: 
     1: 	    if (distance <= min_distance) {
     1: 		min_distance = distance;
     1: 		best_i = i;
     1: 	    }
     1: 	}
     1: #if HAVE_FT_BITMAP_SIZE_Y_PPEM
     1: 	error = FT_Set_Char_Size (unscaled->face,
     1: 				  unscaled->face->available_sizes[best_i].x_ppem,
     1: 				  unscaled->face->available_sizes[best_i].y_ppem,
     1: 				  0, 0);
     1: 	if (error)
     1: #endif
     1: 	    error = FT_Set_Pixel_Sizes (unscaled->face,
     1: 					unscaled->face->available_sizes[best_i].width,
     1: 					unscaled->face->available_sizes[best_i].height);
  8452: 	if (error)
  8452: 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1:     }
     1: 
  4133:     return CAIRO_STATUS_SUCCESS;
  4133: }
  4133: 
 70960: /* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
 70960:  * into a different format. For example, we want to convert a
 70960:  * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
 70960:  * ARGB or ABGR bitmap.
 70960:  *
 70960:  * this function prepares a target descriptor for this operation.
 70960:  *
 70960:  * input :: target bitmap descriptor. The function will set its
 70960:  *          'width', 'rows' and 'pitch' fields, and only these
 70960:  *
 70960:  * slot  :: the glyph slot containing the source bitmap. this
 70960:  *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
 70960:  *
 70960:  * mode  :: the requested final rendering mode. supported values are
 70960:  *          MONO, NORMAL (i.e. gray), LCD and LCD_V
 70960:  *
 70960:  * the function returns the size in bytes of the corresponding buffer,
 70960:  * it's up to the caller to allocate the corresponding memory block
 70960:  * before calling _fill_xrender_bitmap
 70960:  *
 70960:  * it also returns -1 in case of error (e.g. incompatible arguments,
 70960:  * like trying to convert a gray bitmap into a monochrome one)
 70960:  */
 70960: static int
 70960: _compute_xrender_bitmap_size(FT_Bitmap      *target,
 70960: 			     FT_GlyphSlot    slot,
 70960: 			     FT_Render_Mode  mode)
 70960: {
 70960:     FT_Bitmap *ftbit;
 70960:     int width, height, pitch;
 70960: 
 70960:     if (slot->format != FT_GLYPH_FORMAT_BITMAP)
 70960: 	return -1;
 70960: 
 70960:     /* compute the size of the final bitmap */
 70960:     ftbit = &slot->bitmap;
 70960: 
 70960:     width = ftbit->width;
 70960:     height = ftbit->rows;
 70960:     pitch = (width + 3) & ~3;
 70960: 
 70960:     switch (ftbit->pixel_mode) {
 70960:     case FT_PIXEL_MODE_MONO:
 70960: 	if (mode == FT_RENDER_MODE_MONO) {
 70960: 	    pitch = (((width + 31) & ~31) >> 3);
 70960: 	    break;
 70960: 	}
 70960: 	/* fall-through */
 70960: 
 70960:     case FT_PIXEL_MODE_GRAY:
 70960: 	if (mode == FT_RENDER_MODE_LCD ||
 70960: 	    mode == FT_RENDER_MODE_LCD_V)
 70960: 	{
 70960: 	    /* each pixel is replicated into a 32-bit ARGB value */
 70960: 	    pitch = width * 4;
 70960: 	}
 70960: 	break;
 70960: 
 70960:     case FT_PIXEL_MODE_LCD:
 70960: 	if (mode != FT_RENDER_MODE_LCD)
 70960: 	    return -1;
 70960: 
 70960: 	/* horz pixel triplets are packed into 32-bit ARGB values */
 70960: 	width /= 3;
 70960: 	pitch = width * 4;
 70960: 	break;
 70960: 
 70960:     case FT_PIXEL_MODE_LCD_V:
 70960: 	if (mode != FT_RENDER_MODE_LCD_V)
 70960: 	    return -1;
 70960: 
 70960: 	/* vert pixel triplets are packed into 32-bit ARGB values */
 70960: 	height /= 3;
 70960: 	pitch = width * 4;
 70960: 	break;
 70960: 
 70960:     default:  /* unsupported source format */
 70960: 	return -1;
 70960:     }
 70960: 
 70960:     target->width = width;
 70960:     target->rows = height;
 70960:     target->pitch = pitch;
 70960:     target->buffer = NULL;
 70960: 
 70960:     return pitch * height;
 70960: }
 70960: 
 70960: /* this functions converts the glyph bitmap found in a FT_GlyphSlot
 70960:  * into a different format (see _compute_xrender_bitmap_size)
 70960:  *
 70960:  * you should call this function after _compute_xrender_bitmap_size
 70960:  *
 70960:  * target :: target bitmap descriptor. Note that its 'buffer' pointer
 70960:  *           must point to memory allocated by the caller
 70960:  *
 70960:  * slot   :: the glyph slot containing the source bitmap
 70960:  *
 70960:  * mode   :: the requested final rendering mode
 70960:  *
 70960:  * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
 70960:  */
 70960: static void
 70960: _fill_xrender_bitmap(FT_Bitmap      *target,
 70960: 		     FT_GlyphSlot    slot,
 70960: 		     FT_Render_Mode  mode,
 70960: 		     int             bgr)
 70960: {
 70960:     FT_Bitmap *ftbit = &slot->bitmap;
 70960:     unsigned char *srcLine = ftbit->buffer;
 70960:     unsigned char *dstLine = target->buffer;
 70960:     int src_pitch = ftbit->pitch;
 70960:     int width = target->width;
 70960:     int height = target->rows;
 70960:     int pitch = target->pitch;
 70960:     int subpixel;
 70960:     int h;
 70960: 
 70960:     subpixel = (mode == FT_RENDER_MODE_LCD ||
 70960: 		mode == FT_RENDER_MODE_LCD_V);
 70960: 
 70960:     if (src_pitch < 0)
 70960: 	srcLine -= src_pitch * (ftbit->rows - 1);
 70960: 
 70960:     target->pixel_mode = ftbit->pixel_mode;
 70960: 
 70960:     switch (ftbit->pixel_mode) {
 70960:     case FT_PIXEL_MODE_MONO:
 70960: 	if (subpixel) {
 70960: 	    /* convert mono to ARGB32 values */
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
 70960: 		int x;
 70960: 
 70960: 		for (x = 0; x < width; x++) {
 70960: 		    if (srcLine[(x >> 3)] & (0x80 >> (x & 7)))
 70960: 			((unsigned int *) dstLine)[x] = 0xffffffffU;
 70960: 		}
 70960: 	    }
 70960: 	    target->pixel_mode = FT_PIXEL_MODE_LCD;
 70960: 
 70960: 	} else if (mode == FT_RENDER_MODE_NORMAL) {
 70960: 	    /* convert mono to 8-bit gray */
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
 70960: 		int x;
 70960: 
 70960: 		for (x = 0; x < width; x++) {
 70960: 		    if (srcLine[(x >> 3)] & (0x80 >> (x & 7)))
 70960: 			dstLine[x] = 0xff;
 70960: 		}
 70960: 	    }
 70960: 	    target->pixel_mode = FT_PIXEL_MODE_GRAY;
 70960: 
 70960: 	} else {
 70960: 	    /* copy mono to mono */
 70960: 
 70960: 	    int  bytes = (width + 7) >> 3;
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
 70960: 		memcpy (dstLine, srcLine, bytes);
 70960: 	}
 70960: 	break;
 70960: 
 70960:     case FT_PIXEL_MODE_GRAY:
 70960: 	if (subpixel) {
 70960: 	    /* convert gray to ARGB32 values */
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
 70960: 		int x;
 70960: 		unsigned int *dst = (unsigned int *) dstLine;
 70960: 
 70960: 		for (x = 0; x < width; x++) {
 70960: 		    unsigned int pix = srcLine[x];
 70960: 
 70960: 		    pix |= (pix << 8);
 70960: 		    pix |= (pix << 16);
 70960: 
 70960: 		    dst[x] = pix;
 70960: 		}
 70960: 	    }
 70960: 	    target->pixel_mode = FT_PIXEL_MODE_LCD;
 70960:         } else {
 70960:             /* copy gray into gray */
 70960: 
 70960:             for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
 70960:                 memcpy (dstLine, srcLine, width);
 70960:         }
 70960:         break;
 70960: 
 70960:     case FT_PIXEL_MODE_LCD:
 70960: 	if (!bgr) {
 70960: 	    /* convert horizontal RGB into ARGB32 */
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
 70960: 		int x;
 70960: 		unsigned char *src = srcLine;
 70960: 		unsigned int *dst = (unsigned int *) dstLine;
 70960: 
 70960: 		for (x = 0; x < width; x++, src += 3) {
 70960: 		    unsigned int  pix;
 70960: 
 70960: 		    pix = ((unsigned int)src[0] << 16) |
 70960: 			  ((unsigned int)src[1] <<  8) |
 70960: 			  ((unsigned int)src[2]      ) |
 70960: 			  ((unsigned int)src[1] << 24) ;
 70960: 
 70960: 		    dst[x] = pix;
 70960: 		}
 70960: 	    }
 70960: 	} else {
 70960: 	    /* convert horizontal BGR into ARGB32 */
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch) {
 70960: 
 70960: 		int x;
 70960: 		unsigned char *src = srcLine;
 70960: 		unsigned int *dst = (unsigned int *) dstLine;
 70960: 
 70960: 		for (x = 0; x < width; x++, src += 3) {
 70960: 		    unsigned int  pix;
 70960: 
 70960: 		    pix = ((unsigned int)src[2] << 16) |
 70960: 			  ((unsigned int)src[1] <<  8) |
 70960: 			  ((unsigned int)src[0]      ) |
 70960: 			  ((unsigned int)src[1] << 24) ;
 70960: 
 70960: 		    dst[x] = pix;
 70960: 		}
 70960: 	    }
 70960: 	}
 70960: 	break;
 70960: 
 70960:     default:  /* FT_PIXEL_MODE_LCD_V */
 70960: 	/* convert vertical RGB into ARGB32 */
 70960: 	if (!bgr) {
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += 3 * src_pitch, dstLine += pitch) {
 70960: 		int x;
 70960: 		unsigned char* src = srcLine;
 70960: 		unsigned int*  dst = (unsigned int *) dstLine;
 70960: 
 70960: 		for (x = 0; x < width; x++, src += 1) {
 70960: 		    unsigned int pix;
 70960: 		    pix = ((unsigned int)src[0]           << 16) |
 70960: 			  ((unsigned int)src[src_pitch]   <<  8) |
 70960: 			  ((unsigned int)src[src_pitch*2]      ) |
 70960: 			  ((unsigned int)src[src_pitch]   << 24) ;
 70960: 		    dst[x] = pix;
 70960: 		}
 70960: 	    }
 70960: 	} else {
 70960: 
 70960: 	    for (h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch) {
 70960: 		int x;
 70960: 		unsigned char *src = srcLine;
 70960: 		unsigned int *dst = (unsigned int *) dstLine;
 70960: 
 70960: 		for (x = 0; x < width; x++, src += 1) {
 70960: 		    unsigned int  pix;
 70960: 
 70960: 		    pix = ((unsigned int)src[src_pitch * 2] << 16) |
 70960: 			  ((unsigned int)src[src_pitch]     <<  8) |
 70960: 			  ((unsigned int)src[0]                  ) |
 70960: 			  ((unsigned int)src[src_pitch]     << 24) ;
 70960: 
 70960: 		    dst[x] = pix;
 70960: 		}
 70960: 	    }
 70960: 	}
 70960:     }
 70960: }
 70960: 
     1: 
     1: /* Fills in val->image with an image surface created from @bitmap
     1:  */
     1: static cairo_status_t
     1: _get_bitmap_surface (FT_Bitmap		     *bitmap,
     1: 		     cairo_bool_t	      own_buffer,
     1: 		     cairo_font_options_t    *font_options,
     1: 		     cairo_image_surface_t  **surface)
     1: {
     1:     int width, height, stride;
     1:     unsigned char *data;
     1:     int format = CAIRO_FORMAT_A8;
 70960:     cairo_image_surface_t *image;
     1: 
     1:     width = bitmap->width;
     1:     height = bitmap->rows;
     1: 
  6154:     if (width == 0 || height == 0) {
  6154: 	*surface = (cairo_image_surface_t *)
  6154: 	    cairo_image_surface_create_for_data (NULL, format, 0, 0, 0);
  6154: 	return (*surface)->base.status;
  6154:     }
  6154: 
     1:     switch (bitmap->pixel_mode) {
     1:     case FT_PIXEL_MODE_MONO:
     1: 	stride = (((width + 31) & ~31) >> 3);
     1: 	if (own_buffer) {
     1: 	    data = bitmap->buffer;
     1: 	    assert (stride == bitmap->pitch);
     1: 	} else {
  4133: 	    data = _cairo_malloc_ab (height, stride);
  8452: 	    if (!data)
  8452: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
     1: 	    if (stride == bitmap->pitch) {
     1: 		memcpy (data, bitmap->buffer, stride * height);
     1: 	    } else {
     1: 		int i;
     1: 		unsigned char *source, *dest;
     1: 
     1: 		source = bitmap->buffer;
     1: 		dest = data;
     1: 		for (i = height; i; i--) {
     1: 		    memcpy (dest, source, bitmap->pitch);
     1: 		    memset (dest + bitmap->pitch, '\0', stride - bitmap->pitch);
     1: 
     1: 		    source += bitmap->pitch;
     1: 		    dest += stride;
     1: 		}
     1: 	    }
     1: 	}
     1: 
     1: #ifndef WORDS_BIGENDIAN
     1: 	{
 18904: 	    uint8_t   *d = data;
     1: 	    int		count = stride * height;
     1: 
     1: 	    while (count--) {
     1: 		*d = CAIRO_BITSWAP8 (*d);
     1: 		d++;
     1: 	    }
     1: 	}
     1: #endif
     1: 	format = CAIRO_FORMAT_A1;
     1: 	break;
     1: 
     1:     case FT_PIXEL_MODE_LCD:
     1:     case FT_PIXEL_MODE_LCD_V:
     1:     case FT_PIXEL_MODE_GRAY:
 70960:         if (font_options->antialias != CAIRO_ANTIALIAS_SUBPIXEL) {
     1: 	    stride = bitmap->pitch;
     1: 	    if (own_buffer) {
     1: 		data = bitmap->buffer;
     1: 	    } else {
  4133: 		data = _cairo_malloc_ab (height, stride);
  8452: 		if (!data)
  8452: 		    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
  8452: 
     1: 		memcpy (data, bitmap->buffer, stride * height);
     1: 	    }
 70960: 
     1: 	format = CAIRO_FORMAT_A8;
 70960: 	} else {
 70960: 	    /* if we get there, the  data from the source bitmap
 70960: 	     * really comes from _fill_xrender_bitmap, and is
 70960: 	     * made of 32-bit ARGB or ABGR values */
 70960: 	    assert (own_buffer != 0);
 70960: 	    assert (bitmap->pixel_mode != FT_PIXEL_MODE_GRAY);
 70960: 
 70960: 		data = bitmap->buffer;
     1: 		stride = bitmap->pitch;
     1: 		format = CAIRO_FORMAT_ARGB32;
     1: 	}
     1: 	break;
     1:     case FT_PIXEL_MODE_GRAY2:
     1:     case FT_PIXEL_MODE_GRAY4:
     1: 	/* These could be triggered by very rare types of TrueType fonts */
     1:     default:
  4133: 	if (own_buffer)
  4133: 	    free (bitmap->buffer);
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1:     }
     1: 
 70960:     /* XXX */
 70960:     *surface = image = (cairo_image_surface_t *)
     1: 	cairo_image_surface_create_for_data (data,
     1: 					     format,
     1: 					     width, height, stride);
 70960:     if (image->base.status) {
     1: 	free (data);
 11886: 	return (*surface)->base.status;
     1:     }
     1: 
 70960:     if (format == CAIRO_FORMAT_ARGB32)
 70960: 	pixman_image_set_component_alpha (image->pixman_image, TRUE);
 70960: 
 70960:     _cairo_image_surface_assume_ownership_of_data (image);
 70960: 
 70960:     _cairo_debug_check_image_surface_is_defined (&image->base);
 29608: 
     1:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: /* Converts an outline FT_GlyphSlot into an image
     1:  *
     1:  * This could go through _render_glyph_bitmap as well, letting
     1:  * FreeType convert the outline to a bitmap, but doing it ourselves
     1:  * has two minor advantages: first, we save a copy of the bitmap
     1:  * buffer: we can directly use the buffer that FreeType renders
     1:  * into.
     1:  *
     1:  * Second, it may help when we add support for subpixel
     1:  * rendering: the Xft code does it this way. (Keith thinks that
     1:  * it may also be possible to get the subpixel rendering with
     1:  * FT_Render_Glyph: something worth looking into in more detail
     1:  * when we add subpixel support. If so, we may want to eliminate
     1:  * this version of the code path entirely.
     1:  */
     1: static cairo_status_t
     1: _render_glyph_outline (FT_Face                    face,
     1: 		       cairo_font_options_t	 *font_options,
     1: 		       cairo_image_surface_t	**surface)
     1: {
 70960:     int rgba = FC_RGBA_UNKNOWN;
 70960:     int lcd_filter = FT_LCD_FILTER_LEGACY;
     1:     FT_GlyphSlot glyphslot = face->glyph;
     1:     FT_Outline *outline = &glyphslot->outline;
     1:     FT_Bitmap bitmap;
     1:     FT_BBox cbox;
 70960:     unsigned int width, height;
     1:     cairo_status_t status;
 70960:     FT_Error fterror;
 70960:     FT_Library library = glyphslot->library;
 70960:     FT_Render_Mode render_mode = FT_RENDER_MODE_NORMAL;
 70960: 
 70960:     switch (font_options->antialias) {
 70960:     case CAIRO_ANTIALIAS_NONE:
 70960: 	render_mode = FT_RENDER_MODE_MONO;
 70960: 	break;
 70960: 
 70960:     case CAIRO_ANTIALIAS_SUBPIXEL:
 70960: 	switch (font_options->subpixel_order) {
 70960: 	    case CAIRO_SUBPIXEL_ORDER_DEFAULT:
 70960: 	    case CAIRO_SUBPIXEL_ORDER_RGB:
 70960: 	    case CAIRO_SUBPIXEL_ORDER_BGR:
 70960: 		render_mode = FT_RENDER_MODE_LCD;
 70960: 		break;
 70960: 
 70960: 	    case CAIRO_SUBPIXEL_ORDER_VRGB:
 70960: 	    case CAIRO_SUBPIXEL_ORDER_VBGR:
 70960: 		render_mode = FT_RENDER_MODE_LCD_V;
 70960: 		break;
 70960: 	}
 70960: 
 70960: 	switch (font_options->lcd_filter) {
 70960: 	case CAIRO_LCD_FILTER_NONE:
 70960: 	    lcd_filter = FT_LCD_FILTER_NONE;
 70960: 	    break;
 70960: 	case CAIRO_LCD_FILTER_DEFAULT:
 70960: 	case CAIRO_LCD_FILTER_INTRA_PIXEL:
 70960: 	    lcd_filter = FT_LCD_FILTER_LEGACY;
 70960: 	    break;
 70960: 	case CAIRO_LCD_FILTER_FIR3:
 70960: 	    lcd_filter = FT_LCD_FILTER_LIGHT;
 70960: 	    break;
 70960: 	case CAIRO_LCD_FILTER_FIR5:
 70960: 	    lcd_filter = FT_LCD_FILTER_DEFAULT;
 70960: 	    break;
 70960: 	}
 70960: 
 70960: 	break;
 70960: 
 70960:     case CAIRO_ANTIALIAS_DEFAULT:
 70960:     case CAIRO_ANTIALIAS_GRAY:
 70960: 	render_mode = FT_RENDER_MODE_NORMAL;
 70960:     }
     1: 
     1:     FT_Outline_Get_CBox (outline, &cbox);
     1: 
     1:     cbox.xMin &= -64;
     1:     cbox.yMin &= -64;
     1:     cbox.xMax = (cbox.xMax + 63) & -64;
     1:     cbox.yMax = (cbox.yMax + 63) & -64;
     1: 
     1:     width = (unsigned int) ((cbox.xMax - cbox.xMin) >> 6);
     1:     height = (unsigned int) ((cbox.yMax - cbox.yMin) >> 6);
     1: 
     1:     if (width * height == 0) {
     1: 	cairo_format_t format;
     1: 	/* Looks like fb handles zero-sized images just fine */
 70960: 	switch (render_mode) {
 70960: 	case FT_RENDER_MODE_MONO:
     1: 	    format = CAIRO_FORMAT_A1;
     1: 	    break;
 70960: 	case FT_RENDER_MODE_LCD:
 70960: 	case FT_RENDER_MODE_LCD_V:
     1: 	    format= CAIRO_FORMAT_ARGB32;
     1: 	    break;
 70960: 	case FT_RENDER_MODE_LIGHT:
 70960: 	case FT_RENDER_MODE_NORMAL:
 70960: 	case FT_RENDER_MODE_MAX:
     1: 	default:
     1: 	    format = CAIRO_FORMAT_A8;
     1: 	    break;
     1: 	}
     1: 
     1: 	(*surface) = (cairo_image_surface_t *)
     1: 	    cairo_image_surface_create_for_data (NULL, format, 0, 0, 0);
     1: 	if ((*surface)->base.status)
  8452: 	    return (*surface)->base.status;
     1:     } else {
     1: 
 70960: 	int bitmap_size;
 71616:         static int initialized_setLcdFilter = 0;
 70960: 
 70960: 	switch (render_mode) {
 70960: 	case FT_RENDER_MODE_LCD:
 70960: 	    if (font_options->subpixel_order == CAIRO_SUBPIXEL_ORDER_BGR) {
 70960: 		rgba = FC_RGBA_BGR;
 70960: 	    } else {
 70960: 		rgba = FC_RGBA_RGB;
 70960: 	    }
 70960: 	case FT_RENDER_MODE_LCD_V:
 70960: 	    if (font_options->subpixel_order == CAIRO_SUBPIXEL_ORDER_VBGR) {
 70960: 		rgba = FC_RGBA_VBGR;
 70960: 	    } else {
 70960: 		rgba = FC_RGBA_VRGB;
 70960: 		}
     1: 	    break;
 70960: 	case FT_RENDER_MODE_MONO:
 70960: 	case FT_RENDER_MODE_LIGHT:
 70960: 	case FT_RENDER_MODE_NORMAL:
 70960: 	case FT_RENDER_MODE_MAX:
     1: 	default:
     1: 	    break;
     1: 	    }
 70960: 
 71616:         if (!initialized_setLcdFilter) {
 71616:           initialized_setLcdFilter = 1;
116215: #ifdef HAVE_FT_LIBRARY_SETLCDFILTER
116215: 	  setLcdFilter = &FT_Library_SetLcdFilter;
116215: #else
 71616:           setLcdFilter = (setLcdFilterFunc) dlsym(RTLD_DEFAULT, "FT_Library_SetLcdFilter");
116215: #endif
 71616:         }
 71616: 
 71616: 	if (setLcdFilter)
 71616:           setLcdFilter (library, lcd_filter);
 70960: 
 70960: 	fterror = FT_Render_Glyph (face->glyph, render_mode);
 70960: 
 71616: 	if (setLcdFilter)
 71616:           setLcdFilter (library, FT_LCD_FILTER_NONE);
 70960: 
 70960: 	if (fterror != 0)
  8452: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
 70960: 	bitmap_size = _compute_xrender_bitmap_size (&bitmap,
 70960: 						    face->glyph,
 70960: 						    render_mode);
 70960: 	if (bitmap_size < 0)
 21379: 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 70960: 
 70960: 	bitmap.buffer = calloc (1, bitmap_size);
 70960: 	if (bitmap.buffer == NULL)
 70960: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 70960: 
 70960: 	_fill_xrender_bitmap (&bitmap, face->glyph, render_mode,
 70960: 			      (rgba == FC_RGBA_BGR || rgba == FC_RGBA_VBGR));
 70960: 
 70960: 	/* Note:
 70960: 	 * _get_bitmap_surface will free bitmap.buffer if there is an error
 70960: 	 */
     1: 	status = _get_bitmap_surface (&bitmap, TRUE, font_options, surface);
 26419: 	if (unlikely (status))
     1: 	    return status;
 70960: 
 70960: 	/* Note: the font's coordinate system is upside down from ours, so the
  6154: 	 * Y coordinate of the control box needs to be negated.  Moreover, device
  6154: 	 * offsets are position of glyph origin relative to top left while xMin
  6154: 	 * and yMax are offsets of top left relative to origin.  Another negation.
     1: 	 */
     1: 	cairo_surface_set_device_offset (&(*surface)->base,
 70960: 					 (double)-glyphslot->bitmap_left,
 70960: 					 (double)+glyphslot->bitmap_top);
 70960:     }
     1: 
     1:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: /* Converts a bitmap (or other) FT_GlyphSlot into an image */
     1: static cairo_status_t
     1: _render_glyph_bitmap (FT_Face		      face,
     1: 		      cairo_font_options_t   *font_options,
     1: 		      cairo_image_surface_t **surface)
     1: {
     1:     FT_GlyphSlot glyphslot = face->glyph;
 41340:     cairo_status_t status;
     1:     FT_Error error;
     1: 
     1:     /* According to the FreeType docs, glyphslot->format could be
     1:      * something other than FT_GLYPH_FORMAT_OUTLINE or
     1:      * FT_GLYPH_FORMAT_BITMAP. Calling FT_Render_Glyph gives FreeType
     1:      * the opportunity to convert such to
     1:      * bitmap. FT_GLYPH_FORMAT_COMPOSITE will not be encountered since
     1:      * we avoid the FT_LOAD_NO_RECURSE flag.
     1:      */
     1:     error = FT_Render_Glyph (glyphslot, FT_RENDER_MODE_NORMAL);
  6154:     /* XXX ignoring all other errors for now.  They are not fatal, typically
  6154:      * just a glyph-not-found. */
  8452:     if (error == FT_Err_Out_Of_Memory)
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
 41340:     status = _get_bitmap_surface (&glyphslot->bitmap,
 41340: 				  FALSE, font_options,
 41340: 				  surface);
 26419:     if (unlikely (status))
     1: 	return status;
     1: 
     1:     /*
     1:      * Note: the font's coordinate system is upside down from ours, so the
  6154:      * Y coordinate of the control box needs to be negated.  Moreover, device
  6154:      * offsets are position of glyph origin relative to top left while
  6154:      * bitmap_left and bitmap_top are offsets of top left relative to origin.
  6154:      * Another negation.
     1:      */
     1:     cairo_surface_set_device_offset (&(*surface)->base,
  6154: 				     -glyphslot->bitmap_left,
  6154: 				     +glyphslot->bitmap_top);
     1: 
 41340:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: static cairo_status_t
     1: _transform_glyph_bitmap (cairo_matrix_t         * shape,
     1: 			 cairo_image_surface_t ** surface)
     1: {
     1:     cairo_matrix_t original_to_transformed;
     1:     cairo_matrix_t transformed_to_original;
     1:     cairo_image_surface_t *old_image;
     1:     cairo_surface_t *image;
     1:     double x[4], y[4];
     1:     double origin_x, origin_y;
  6154:     int orig_width, orig_height;
     1:     int i;
     1:     int x_min, y_min, x_max, y_max;
     1:     int width, height;
     1:     cairo_status_t status;
     1:     cairo_surface_pattern_t pattern;
     1: 
     1:     /* We want to compute a transform that takes the origin
     1:      * (device_x_offset, device_y_offset) to 0,0, then applies
     1:      * the "shape" portion of the font transform
     1:      */
     1:     original_to_transformed = *shape;
     1:     
     1:     cairo_surface_get_device_offset (&(*surface)->base, &origin_x, &origin_y);
 70960:     orig_width = (*surface)->width;
 70960:     orig_height = (*surface)->height;
     1: 
     1:     cairo_matrix_translate (&original_to_transformed,
  6154: 			    -origin_x, -origin_y);
     1: 
     1:     /* Find the bounding box of the original bitmap under that
     1:      * transform
     1:      */
     1:     x[0] = 0;          y[0] = 0;
  6154:     x[1] = orig_width; y[1] = 0;
  6154:     x[2] = orig_width; y[2] = orig_height;
  6154:     x[3] = 0;          y[3] = orig_height;
     1: 
     1:     for (i = 0; i < 4; i++)
     1:       cairo_matrix_transform_point (&original_to_transformed,
     1: 				    &x[i], &y[i]);
     1: 
     1:     x_min = floor (x[0]);   y_min = floor (y[0]);
     1:     x_max =  ceil (x[0]);   y_max =  ceil (y[0]);
     1: 
     1:     for (i = 1; i < 4; i++) {
     1: 	if (x[i] < x_min)
     1: 	    x_min = floor (x[i]);
  6154: 	else if (x[i] > x_max)
     1: 	    x_max = ceil (x[i]);
     1: 	if (y[i] < y_min)
     1: 	    y_min = floor (y[i]);
  6154: 	else if (y[i] > y_max)
     1: 	    y_max = ceil (y[i]);
     1:     }
     1: 
     1:     /* Adjust the transform so that the bounding box starts at 0,0 ...
     1:      * this gives our final transform from original bitmap to transformed
     1:      * bitmap.
     1:      */
     1:     original_to_transformed.x0 -= x_min;
     1:     original_to_transformed.y0 -= y_min;
     1: 
 70960:     /* Create the transformed bitmap */
     1:     width  = x_max - x_min;
     1:     height = y_max - y_min;
     1: 
     1:     transformed_to_original = original_to_transformed;
     1:     status = cairo_matrix_invert (&transformed_to_original);
 26419:     if (unlikely (status))
     1: 	return status;
     1: 
     1:     image = cairo_image_surface_create (CAIRO_FORMAT_A8, width, height);
 26419:     if (unlikely (image->status))
  8452: 	return image->status;
     1: 
     1:     /* Draw the original bitmap transformed into the new bitmap
     1:      */
     1:     _cairo_pattern_init_for_surface (&pattern, &(*surface)->base);
     1:     cairo_pattern_set_matrix (&pattern.base, &transformed_to_original);
     1: 
 70960:     status = _cairo_surface_paint (image,
 70960: 				   CAIRO_OPERATOR_SOURCE,
 70960: 				   &pattern.base,
 70960: 				   NULL);
     1: 
     1:     _cairo_pattern_fini (&pattern.base);
     1: 
 26419:     if (unlikely (status)) {
  4133: 	cairo_surface_destroy (image);
  4133: 	return status;
  4133:     }
  4133: 
     1:     /* Now update the cache entry for the new bitmap, recomputing
     1:      * the origin based on the final transform.
     1:      */
     1:     cairo_matrix_transform_point (&original_to_transformed,
     1: 				  &origin_x, &origin_y);
     1: 
     1:     old_image = (*surface);
     1:     (*surface) = (cairo_image_surface_t *)image;
     1:     cairo_surface_destroy (&old_image->base);
     1: 
     1:     cairo_surface_set_device_offset (&(*surface)->base,
  6154: 				     _cairo_lround (origin_x),
  6154: 				     _cairo_lround (origin_y));
 41340:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: static const cairo_unscaled_font_backend_t cairo_ft_unscaled_font_backend = {
     1:     _cairo_ft_unscaled_font_destroy,
     1: #if 0
     1:     _cairo_ft_unscaled_font_create_glyph
     1: #endif
     1: };
     1: 
 11708: /* #cairo_ft_scaled_font_t */
     1: 
     1: typedef struct _cairo_ft_scaled_font {
     1:     cairo_scaled_font_t base;
     1:     cairo_ft_unscaled_font_t *unscaled;
     1:     cairo_ft_options_t ft_options;
     1: } cairo_ft_scaled_font_t;
     1: 
 26419: static const cairo_scaled_font_backend_t _cairo_ft_scaled_font_backend;
 26419: 
 26419: #if CAIRO_HAS_FC_FONT
     1: /* The load flags passed to FT_Load_Glyph control aspects like hinting and
     1:  * antialiasing. Here we compute them from the fields of a FcPattern.
     1:  */
     1: static void
     1: _get_pattern_ft_options (FcPattern *pattern, cairo_ft_options_t *ret)
     1: {
     1:     FcBool antialias, vertical_layout, hinting, autohint, bitmap, embolden;
     1:     cairo_ft_options_t ft_options;
     1:     int rgba;
     1: #ifdef FC_HINT_STYLE
     1:     int hintstyle;
     1: #endif
     1: 
     1:     _cairo_font_options_init_default (&ft_options.base);
     1:     ft_options.load_flags = FT_LOAD_DEFAULT;
     1:     ft_options.extra_flags = 0;
     1: 
     1: #ifndef FC_EMBEDDED_BITMAP
     1: #define FC_EMBEDDED_BITMAP "embeddedbitmap"
     1: #endif
     1: 
     1:     /* Check whether to force use of embedded bitmaps */
     1:     if (FcPatternGetBool (pattern,
     1: 			  FC_EMBEDDED_BITMAP, 0, &bitmap) != FcResultMatch)
     1: 	bitmap = FcFalse;
     1: 
     1:     /* disable antialiasing if requested */
     1:     if (FcPatternGetBool (pattern,
     1: 			  FC_ANTIALIAS, 0, &antialias) != FcResultMatch)
     1: 	antialias = FcTrue;
     1:     
     1:     if (antialias) {
     1: 	cairo_subpixel_order_t subpixel_order;
 70960: 	int lcd_filter;
     1: 
     1: 	/* disable hinting if requested */
     1: 	if (FcPatternGetBool (pattern,
     1: 			      FC_HINTING, 0, &hinting) != FcResultMatch)
     1: 	    hinting = FcTrue;
     1: 
     1: 	if (FcPatternGetInteger (pattern,
     1: 				 FC_RGBA, 0, &rgba) != FcResultMatch)
     1: 	    rgba = FC_RGBA_UNKNOWN;
     1: 
     1: 	switch (rgba) {
     1: 	case FC_RGBA_RGB:
     1: 	    subpixel_order = CAIRO_SUBPIXEL_ORDER_RGB;
     1: 	    break;
     1: 	case FC_RGBA_BGR:
     1: 	    subpixel_order = CAIRO_SUBPIXEL_ORDER_BGR;
     1: 	    break;
     1: 	case FC_RGBA_VRGB:
     1: 	    subpixel_order = CAIRO_SUBPIXEL_ORDER_VRGB;
     1: 	    break;
     1: 	case FC_RGBA_VBGR:
     1: 	    subpixel_order = CAIRO_SUBPIXEL_ORDER_VBGR;
     1: 	    break;
     1: 	case FC_RGBA_UNKNOWN:
     1: 	case FC_RGBA_NONE:
     1: 	default:
     1: 	    subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
     1: 	    break;
     1: 	}
     1: 
     1: 	if (subpixel_order != CAIRO_SUBPIXEL_ORDER_DEFAULT) {
     1: 	    ft_options.base.subpixel_order = subpixel_order;
     1: 	    ft_options.base.antialias = CAIRO_ANTIALIAS_SUBPIXEL;
     1: 	}
     1: 
 70960: 	if (FcPatternGetInteger (pattern,
 70960: 				 FC_LCD_FILTER, 0, &lcd_filter) == FcResultMatch)
 70960: 	{
 70960: 	    switch (lcd_filter) {
 70960: 	    case FC_LCD_NONE:
 70960: 		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_NONE;
 70960: 		break;
 70960: 	    case FC_LCD_DEFAULT:
 70960: 		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_FIR5;
 70960: 		break;
 70960: 	    case FC_LCD_LIGHT:
 70960: 		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_FIR3;
 70960: 		break;
 70960: 	    case FC_LCD_LEGACY:
 70960: 		ft_options.base.lcd_filter = CAIRO_LCD_FILTER_INTRA_PIXEL;
 70960: 		break;
 70960: 	    }
 70960: 	}
 70960: 
     1: #ifdef FC_HINT_STYLE
     1: 	if (FcPatternGetInteger (pattern,
     1: 				 FC_HINT_STYLE, 0, &hintstyle) != FcResultMatch)
     1: 	    hintstyle = FC_HINT_FULL;
     1: 
     1: 	if (!hinting)
     1: 	    hintstyle = FC_HINT_NONE;
     1: 
     1: 	switch (hintstyle) {
     1: 	case FC_HINT_NONE:
     1: 	    ft_options.base.hint_style = CAIRO_HINT_STYLE_NONE;
     1: 	    break;
     1: 	case FC_HINT_SLIGHT:
     1: 	    ft_options.base.hint_style = CAIRO_HINT_STYLE_SLIGHT;
     1: 	    break;
     1: 	case FC_HINT_MEDIUM:
     1: 	default:
     1: 	    ft_options.base.hint_style = CAIRO_HINT_STYLE_MEDIUM;
     1: 	    break;
     1: 	case FC_HINT_FULL:
     1: 	    ft_options.base.hint_style = CAIRO_HINT_STYLE_FULL;
     1: 	    break;
     1: 	}
     1: #else /* !FC_HINT_STYLE */
     1: 	if (!hinting) {
     1: 	    ft_options.base.hint_style = CAIRO_HINT_STYLE_NONE;
     1: 	}
 10694: #endif /* FC_HINT_STYLE */
 11708: 
 11708: 	/* Force embedded bitmaps off if no hinting requested */
 11708: 	if (ft_options.base.hint_style == CAIRO_HINT_STYLE_NONE)
 11708: 	  bitmap = FcFalse;
 11708: 
 11708: 	if (!bitmap)
 11708: 	    ft_options.load_flags |= FT_LOAD_NO_BITMAP;
 11708: 
     1:     } else {
     1: 	ft_options.base.antialias = CAIRO_ANTIALIAS_NONE;
     1:     }
     1: 
     1:     /* force autohinting if requested */
     1:     if (FcPatternGetBool (pattern,
     1: 			  FC_AUTOHINT, 0, &autohint) != FcResultMatch)
     1: 	autohint = FcFalse;
     1: 
     1:     if (autohint)
     1: 	ft_options.load_flags |= FT_LOAD_FORCE_AUTOHINT;
     1: 
     1:     if (FcPatternGetBool (pattern,
     1: 			  FC_VERTICAL_LAYOUT, 0, &vertical_layout) != FcResultMatch)
     1: 	vertical_layout = FcFalse;
     1: 
     1:     if (vertical_layout)
     1: 	ft_options.load_flags |= FT_LOAD_VERTICAL_LAYOUT;
     1: 
     1: #ifndef FC_EMBOLDEN
     1: #define FC_EMBOLDEN "embolden"
     1: #endif
     1:     if (FcPatternGetBool (pattern,
     1: 			  FC_EMBOLDEN, 0, &embolden) != FcResultMatch)
     1: 	embolden = FcFalse;
     1: 
     1:     if (embolden)
     1: 	ft_options.extra_flags |= CAIRO_FT_OPTIONS_EMBOLDEN;
     1: 
     1:     *ret = ft_options;
     1: }
 26419: #endif
     1: 
     1: static void
     1: _cairo_ft_options_merge (cairo_ft_options_t *options,
     1: 			 cairo_ft_options_t *other)
     1: {
     1:     int load_flags = other->load_flags;
     1:     int load_target = FT_LOAD_TARGET_NORMAL;
     1: 
     1:     /* clear load target mode */
     1:     load_flags &= ~(FT_LOAD_TARGET_(FT_LOAD_TARGET_MODE(other->load_flags)));
     1: 
     1:     if (load_flags & FT_LOAD_NO_HINTING)
     1: 	other->base.hint_style = CAIRO_HINT_STYLE_NONE;
     1: 
     1:     if (other->base.antialias == CAIRO_ANTIALIAS_NONE ||
     1: 	options->base.antialias == CAIRO_ANTIALIAS_NONE) {
     1: 	options->base.antialias = CAIRO_ANTIALIAS_NONE;
     1: 	options->base.subpixel_order = CAIRO_SUBPIXEL_ORDER_DEFAULT;
     1:     }
     1: 
     1:     if (other->base.antialias == CAIRO_ANTIALIAS_SUBPIXEL &&
     1: 	(options->base.antialias == CAIRO_ANTIALIAS_DEFAULT ||
     1: 	 options->base.antialias == CAIRO_ANTIALIAS_GRAY)) {
     1: 	options->base.antialias = CAIRO_ANTIALIAS_SUBPIXEL;
     1: 	options->base.subpixel_order = other->base.subpixel_order;
     1:     }
     1: 
     1:     if (options->base.hint_style == CAIRO_HINT_STYLE_DEFAULT)
     1: 	options->base.hint_style = other->base.hint_style;
     1: 
     1:     if (other->base.hint_style == CAIRO_HINT_STYLE_NONE)
     1: 	options->base.hint_style = CAIRO_HINT_STYLE_NONE;
     1: 
 70960:     if (options->base.lcd_filter == CAIRO_LCD_FILTER_DEFAULT)
 70960: 	options->base.lcd_filter = other->base.lcd_filter;
 70960: 
 70960:     if (other->base.lcd_filter == CAIRO_LCD_FILTER_NONE)
 70960: 	options->base.lcd_filter = CAIRO_LCD_FILTER_NONE;
 70960: 
     1:     if (options->base.antialias == CAIRO_ANTIALIAS_NONE) {
     1: 	if (options->base.hint_style == CAIRO_HINT_STYLE_NONE)
     1: 	    load_flags |= FT_LOAD_NO_HINTING;
     1: 	else
     1: 	    load_target = FT_LOAD_TARGET_MONO;
     1: 	load_flags |= FT_LOAD_MONOCHROME;
     1:     } else {
     1: 	switch (options->base.hint_style) {
     1: 	case CAIRO_HINT_STYLE_NONE:
     1: 	    load_flags |= FT_LOAD_NO_HINTING;
     1: 	    break;
     1: 	case CAIRO_HINT_STYLE_SLIGHT:
     1: 	    load_target = FT_LOAD_TARGET_LIGHT;
     1: 	    break;
     1: 	case CAIRO_HINT_STYLE_MEDIUM:
     1: 	    break;
     1: 	case CAIRO_HINT_STYLE_FULL:
     1: 	case CAIRO_HINT_STYLE_DEFAULT:
     1: 	    if (options->base.antialias == CAIRO_ANTIALIAS_SUBPIXEL) {
     1: 		switch (options->base.subpixel_order) {
     1: 		case CAIRO_SUBPIXEL_ORDER_DEFAULT:
     1: 		case CAIRO_SUBPIXEL_ORDER_RGB:
     1: 		case CAIRO_SUBPIXEL_ORDER_BGR:
 70960: 		    load_target = FT_LOAD_TARGET_LCD;
     1: 		    break;
     1: 		case CAIRO_SUBPIXEL_ORDER_VRGB:
     1: 		case CAIRO_SUBPIXEL_ORDER_VBGR:
 70960: 		    load_target = FT_LOAD_TARGET_LCD_V;
     1: 		break;
     1: 		}
     1: 	    }
     1: 	    break;
     1: 	}
     1:     }
     1: 
     1:     options->load_flags = load_flags | load_target;
     1:     options->extra_flags = other->extra_flags;
 10694:     if (options->base.hint_metrics != CAIRO_HINT_METRICS_OFF)
 10694: 	options->extra_flags |= CAIRO_FT_OPTIONS_HINT_METRICS;
     1: }
     1: 
  8452: static cairo_status_t
 32473: _cairo_ft_font_face_scaled_font_create (void		    *abstract_font_face,
     1: 					const cairo_matrix_t	 *font_matrix,
     1: 					const cairo_matrix_t	 *ctm,
     1: 					const cairo_font_options_t *options,
  8452: 					cairo_scaled_font_t       **font_out)
     1: {
 32473:     cairo_ft_font_face_t *font_face = abstract_font_face;
  8452:     cairo_ft_scaled_font_t *scaled_font;
     1:     FT_Face face;
     1:     FT_Size_Metrics *metrics;
     1:     cairo_font_extents_t fs_metrics;
  4133:     cairo_status_t status;
 32473:     cairo_ft_unscaled_font_t *unscaled;
 32473: 
 32473:     assert (font_face->unscaled);
 32473: 
 32473:     face = _cairo_ft_unscaled_font_lock_face (font_face->unscaled);
 26419:     if (unlikely (face == NULL)) /* backend error */
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
     1:     scaled_font = malloc (sizeof (cairo_ft_scaled_font_t));
 26419:     if (unlikely (scaled_font == NULL)) {
  8452: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
  8452: 	goto FAIL;
     1:     }
     1: 
 32473:     scaled_font->unscaled = unscaled = font_face->unscaled;
     1:     _cairo_unscaled_font_reference (&unscaled->base);
     1: 
     1:     _cairo_font_options_init_copy (&scaled_font->ft_options.base, options);
 32473:     _cairo_ft_options_merge (&scaled_font->ft_options, &font_face->ft_options);
     1: 
  4133:     status = _cairo_scaled_font_init (&scaled_font->base,
 32473: 			              &font_face->base,
     1: 				      font_matrix, ctm, options,
 16122: 				      &_cairo_ft_scaled_font_backend);
 26419:     if (unlikely (status))
 26419: 	goto CLEANUP_SCALED_FONT;
 26419: 
 26419:     status = _cairo_ft_unscaled_font_set_scale (unscaled,
 26419: 				                &scaled_font->base.scale);
 26419:     if (unlikely (status)) {
 26419: 	/* This can only fail if we encounter an error with the underlying
 26419: 	 * font, so propagate the error back to the font-face. */
 26419: 	_cairo_ft_unscaled_font_unlock_face (unscaled);
 10414: 	_cairo_unscaled_font_destroy (&unscaled->base);
  4133: 	free (scaled_font);
 26419: 	return status;
  4133:     }
  4133: 
     1: 
     1:     metrics = &face->size->metrics;
     1: 
     1:     /*
     1:      * Get to unscaled metrics so that the upper level can get back to
     1:      * user space
 11708:      *
 11708:      * Also use this path for bitmap-only fonts.  The other branch uses
 11708:      * face members that are only relevant for scalable fonts.  This is
 11708:      * detected by simply checking for units_per_EM==0.
     1:      */
 11708:     if (scaled_font->base.options.hint_metrics != CAIRO_HINT_METRICS_OFF ||
 11708: 	face->units_per_EM == 0) {
     1: 	double x_factor, y_factor;
     1: 
     1: 	if (unscaled->x_scale == 0)
     1: 	    x_factor = 0;
     1: 	else
     1: 	    x_factor = 1 / unscaled->x_scale;
     1: 
     1: 	if (unscaled->y_scale == 0)
     1: 	    y_factor = 0;
     1: 	else
     1: 	    y_factor = 1 / unscaled->y_scale;
     1: 
     1: 	fs_metrics.ascent =        DOUBLE_FROM_26_6(metrics->ascender) * y_factor;
     1: 	fs_metrics.descent =       DOUBLE_FROM_26_6(- metrics->descender) * y_factor;
     1: 	fs_metrics.height =        DOUBLE_FROM_26_6(metrics->height) * y_factor;
     1: 	if (!_cairo_ft_scaled_font_is_vertical (&scaled_font->base)) {
     1: 	    fs_metrics.max_x_advance = DOUBLE_FROM_26_6(metrics->max_advance) * x_factor;
     1: 	    fs_metrics.max_y_advance = 0;
     1: 	} else {
     1: 	    fs_metrics.max_x_advance = 0;
     1: 	    fs_metrics.max_y_advance = DOUBLE_FROM_26_6(metrics->max_advance) * y_factor;
     1: 	}
     1:     } else {
     1: 	double scale = face->units_per_EM;
     1: 
     1: 	fs_metrics.ascent =        face->ascender / scale;
     1: 	fs_metrics.descent =       - face->descender / scale;
     1: 	fs_metrics.height =        face->height / scale;
     1: 	if (!_cairo_ft_scaled_font_is_vertical (&scaled_font->base)) {
     1: 	    fs_metrics.max_x_advance = face->max_advance_width / scale;
     1: 	    fs_metrics.max_y_advance = 0;
     1: 	} else {
     1: 	    fs_metrics.max_x_advance = 0;
     1: 	    fs_metrics.max_y_advance = face->max_advance_height / scale;
     1: 	}
     1:     }
     1: 
 11708:     status = _cairo_scaled_font_set_metrics (&scaled_font->base, &fs_metrics);
 26419:     if (unlikely (status))
 26419: 	goto CLEANUP_SCALED_FONT;
 26419: 
 26419:     _cairo_ft_unscaled_font_unlock_face (unscaled);
     1: 
  8452:     *font_out = &scaled_font->base;
 26419:     return CAIRO_STATUS_SUCCESS;
 26419: 
 26419:   CLEANUP_SCALED_FONT:
 26419:     _cairo_unscaled_font_destroy (&unscaled->base);
 26419:     free (scaled_font);
  8452:   FAIL:
 32473:     _cairo_ft_unscaled_font_unlock_face (font_face->unscaled);
 26419:     *font_out = _cairo_scaled_font_create_in_error (status);
 26419:     return CAIRO_STATUS_SUCCESS; /* non-backend error */
     1: }
     1: 
     1: cairo_bool_t
     1: _cairo_scaled_font_is_ft (cairo_scaled_font_t *scaled_font)
     1: {
 16122:     return scaled_font->backend == &_cairo_ft_scaled_font_backend;
     1: }
     1: 
     1: static void
     1: _cairo_ft_scaled_font_fini (void *abstract_font)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = abstract_font;
     1: 
     1:     if (scaled_font == NULL)
     1:         return;
     1: 
     1:     _cairo_unscaled_font_destroy (&scaled_font->unscaled->base);
     1: }
     1: 
     1: static int
     1: _move_to (FT_Vector *to, void *closure)
     1: {
     1:     cairo_path_fixed_t *path = closure;
     1:     cairo_fixed_t x, y;
     1: 
     1:     x = _cairo_fixed_from_26_6 (to->x);
     1:     y = _cairo_fixed_from_26_6 (to->y);
     1: 
  4133:     if (_cairo_path_fixed_close_path (path) != CAIRO_STATUS_SUCCESS)
  4133: 	return 1;
  4133:     if (_cairo_path_fixed_move_to (path, x, y) != CAIRO_STATUS_SUCCESS)
  4133: 	return 1;
     1: 
     1:     return 0;
     1: }
     1: 
     1: static int
     1: _line_to (FT_Vector *to, void *closure)
     1: {
     1:     cairo_path_fixed_t *path = closure;
     1:     cairo_fixed_t x, y;
     1: 
     1:     x = _cairo_fixed_from_26_6 (to->x);
     1:     y = _cairo_fixed_from_26_6 (to->y);
     1: 
  4133:     if (_cairo_path_fixed_line_to (path, x, y) != CAIRO_STATUS_SUCCESS)
  4133: 	return 1;
     1: 
     1:     return 0;
     1: }
     1: 
     1: static int
     1: _conic_to (FT_Vector *control, FT_Vector *to, void *closure)
     1: {
     1:     cairo_path_fixed_t *path = closure;
     1: 
     1:     cairo_fixed_t x0, y0;
     1:     cairo_fixed_t x1, y1;
     1:     cairo_fixed_t x2, y2;
     1:     cairo_fixed_t x3, y3;
     1:     cairo_point_t conic;
     1: 
  8452:     if (! _cairo_path_fixed_get_current_point (path, &x0, &y0))
  4133: 	return 1;
     1: 
     1:     conic.x = _cairo_fixed_from_26_6 (control->x);
     1:     conic.y = _cairo_fixed_from_26_6 (control->y);
     1: 
     1:     x3 = _cairo_fixed_from_26_6 (to->x);
     1:     y3 = _cairo_fixed_from_26_6 (to->y);
     1: 
     1:     x1 = x0 + 2.0/3.0 * (conic.x - x0);
     1:     y1 = y0 + 2.0/3.0 * (conic.y - y0);
     1: 
     1:     x2 = x3 + 2.0/3.0 * (conic.x - x3);
     1:     y2 = y3 + 2.0/3.0 * (conic.y - y3);
     1: 
  4133:     if (_cairo_path_fixed_curve_to (path,
     1: 				    x1, y1,
     1: 				    x2, y2,
  4133: 				    x3, y3) != CAIRO_STATUS_SUCCESS)
  4133: 	return 1;
     1: 
     1:     return 0;
     1: }
     1: 
     1: static int
     1: _cubic_to (FT_Vector *control1, FT_Vector *control2,
     1: 	   FT_Vector *to, void *closure)
     1: {
     1:     cairo_path_fixed_t *path = closure;
     1:     cairo_fixed_t x0, y0;
     1:     cairo_fixed_t x1, y1;
     1:     cairo_fixed_t x2, y2;
     1: 
     1:     x0 = _cairo_fixed_from_26_6 (control1->x);
     1:     y0 = _cairo_fixed_from_26_6 (control1->y);
     1: 
     1:     x1 = _cairo_fixed_from_26_6 (control2->x);
     1:     y1 = _cairo_fixed_from_26_6 (control2->y);
     1: 
     1:     x2 = _cairo_fixed_from_26_6 (to->x);
     1:     y2 = _cairo_fixed_from_26_6 (to->y);
     1: 
  4133:     if (_cairo_path_fixed_curve_to (path,
     1: 				    x0, y0,
     1: 				    x1, y1,
  4133: 				    x2, y2) != CAIRO_STATUS_SUCCESS)
  4133: 	return 1;
     1: 
     1:     return 0;
     1: }
     1: 
     1: static cairo_status_t
     1: _decompose_glyph_outline (FT_Face		  face,
     1: 			  cairo_font_options_t	 *options,
     1: 			  cairo_path_fixed_t	**pathp)
     1: {
     1:     static const FT_Outline_Funcs outline_funcs = {
     1: 	(FT_Outline_MoveToFunc)_move_to,
     1: 	(FT_Outline_LineToFunc)_line_to,
     1: 	(FT_Outline_ConicToFunc)_conic_to,
     1: 	(FT_Outline_CubicToFunc)_cubic_to,
     1: 	0, /* shift */
     1: 	0, /* delta */
     1:     };
     1:     static const FT_Matrix invert_y = {
     1: 	DOUBLE_TO_16_16 (1.0), 0,
     1: 	0, DOUBLE_TO_16_16 (-1.0),
     1:     };
     1: 
     1:     FT_GlyphSlot glyph;
     1:     cairo_path_fixed_t *path;
  4133:     cairo_status_t status;
     1: 
     1:     path = _cairo_path_fixed_create ();
     1:     if (!path)
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
     1:     glyph = face->glyph;
     1: 
     1:     /* Font glyphs have an inverted Y axis compared to cairo. */
     1:     FT_Outline_Transform (&glyph->outline, &invert_y);
  4133:     if (FT_Outline_Decompose (&glyph->outline, &outline_funcs, path)) {
  4133: 	_cairo_path_fixed_destroy (path);
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
  4133:     }
  4133: 
  4133:     status = _cairo_path_fixed_close_path (path);
 26419:     if (unlikely (status)) {
  4133: 	_cairo_path_fixed_destroy (path);
  4133: 	return status;
  4133:     }
     1: 
     1:     *pathp = path;
     1: 
     1:     return CAIRO_STATUS_SUCCESS;
     1: }
     1: 
     1: /*
     1:  * Translate glyph to match its metrics.
     1:  */
     1: static void
     1: _cairo_ft_scaled_glyph_vertical_layout_bearing_fix (void        *abstract_font,
     1: 						    FT_GlyphSlot glyph)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = abstract_font;
     1:     FT_Vector vector;
     1: 
     1:     vector.x = glyph->metrics.vertBearingX - glyph->metrics.horiBearingX;
     1:     vector.y = -glyph->metrics.vertBearingY - glyph->metrics.horiBearingY;
     1: 
     1:     if (glyph->format == FT_GLYPH_FORMAT_OUTLINE) {
     1: 	FT_Vector_Transform (&vector, &scaled_font->unscaled->Current_Shape);
     1: 	FT_Outline_Translate(&glyph->outline, vector.x, vector.y);
     1:     } else if (glyph->format == FT_GLYPH_FORMAT_BITMAP) {
     1: 	glyph->bitmap_left += vector.x / 64;
     1: 	glyph->bitmap_top  += vector.y / 64;
     1:     }
     1: }
     1: 
     1: static cairo_int_status_t
     1: _cairo_ft_scaled_glyph_init (void			*abstract_font,
     1: 			     cairo_scaled_glyph_t	*scaled_glyph,
     1: 			     cairo_scaled_glyph_info_t	 info)
     1: {
     1:     cairo_text_extents_t    fs_metrics;
     1:     cairo_ft_scaled_font_t *scaled_font = abstract_font;
     1:     cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
     1:     FT_GlyphSlot glyph;
     1:     FT_Face face;
     1:     FT_Error error;
     1:     int load_flags = scaled_font->ft_options.load_flags;
     1:     FT_Glyph_Metrics *metrics;
     1:     double x_factor, y_factor;
     1:     cairo_bool_t vertical_layout = FALSE;
  4133:     cairo_status_t status;
     1: 
   314:     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     1:     if (!face)
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
  4133:     status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
   314: 				                &scaled_font->base.scale);
 26419:     if (unlikely (status))
  4133: 	goto FAIL;
   314: 
     1:     /* Ignore global advance unconditionally */
     1:     load_flags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH;
     1: 
     1:     if ((info & CAIRO_SCALED_GLYPH_INFO_PATH) != 0 &&
     1: 	(info & CAIRO_SCALED_GLYPH_INFO_SURFACE) == 0)
     1: 	load_flags |= FT_LOAD_NO_BITMAP;
     1: 
     1:     /*
     1:      * Don't pass FT_LOAD_VERTICAL_LAYOUT to FT_Load_Glyph here as
     1:      * suggested by freetype people.
     1:      */
     1:     if (load_flags & FT_LOAD_VERTICAL_LAYOUT) {
     1: 	load_flags &= ~FT_LOAD_VERTICAL_LAYOUT;
     1: 	vertical_layout = TRUE;
     1:     }
     1: 
     1:     error = FT_Load_Glyph (scaled_font->unscaled->face,
     1: 			   _cairo_scaled_glyph_index(scaled_glyph),
     1: 			   load_flags);
  6154:     /* XXX ignoring all other errors for now.  They are not fatal, typically
  6154:      * just a glyph-not-found. */
  6154:     if (error == FT_Err_Out_Of_Memory) {
  8452: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 	goto FAIL;
     1:     }
     1: 
     1:     glyph = face->glyph;
     1: 
     1: #if HAVE_FT_GLYPHSLOT_EMBOLDEN
     1:     /*
     1:      * embolden glyphs if requested
     1:      */
     1:     if (scaled_font->ft_options.extra_flags & CAIRO_FT_OPTIONS_EMBOLDEN)
     1: 	FT_GlyphSlot_Embolden (glyph);
     1: #endif
     1: 
     1:     if (vertical_layout)
     1: 	_cairo_ft_scaled_glyph_vertical_layout_bearing_fix (scaled_font, glyph);
     1: 
     1:     if (info & CAIRO_SCALED_GLYPH_INFO_METRICS) {
   314: 
   314: 	cairo_bool_t hint_metrics = scaled_font->base.options.hint_metrics != CAIRO_HINT_METRICS_OFF;
     1: 	/*
     1: 	 * Compute font-space metrics
     1: 	 */
     1: 	metrics = &glyph->metrics;
     1: 
     1: 	if (unscaled->x_scale == 0)
     1: 	    x_factor = 0;
     1: 	else
     1: 	    x_factor = 1 / unscaled->x_scale;
     1: 
     1: 	if (unscaled->y_scale == 0)
     1: 	    y_factor = 0;
     1: 	else
     1: 	    y_factor = 1 / unscaled->y_scale;
     1: 
     1: 	/*
     1: 	 * Note: Y coordinates of the horizontal bearing need to be negated.
     1: 	 *
     1: 	 * Scale metrics back to glyph space from the scaled glyph space returned
     1: 	 * by FreeType
     1: 	 *
     1: 	 * If we want hinted metrics but aren't asking for hinted glyphs from
     1: 	 * FreeType, then we need to do the metric hinting ourselves.
     1: 	 */
     1: 
   314: 	if (hint_metrics && (load_flags & FT_LOAD_NO_HINTING))
     1: 	{
     1: 	    FT_Pos x1, x2;
     1: 	    FT_Pos y1, y2;
     1: 	    FT_Pos advance;
     1: 
     1: 	    if (!vertical_layout) {
     1: 		x1 = (metrics->horiBearingX) & -64;
     1: 		x2 = (metrics->horiBearingX + metrics->width + 63) & -64;
     1: 		y1 = (-metrics->horiBearingY) & -64;
     1: 		y2 = (-metrics->horiBearingY + metrics->height + 63) & -64;
     1: 
     1: 		advance = ((metrics->horiAdvance + 32) & -64);
     1: 
     1: 		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (x1) * x_factor;
     1: 		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (y1) * y_factor;
     1: 
     1: 		fs_metrics.width  = DOUBLE_FROM_26_6 (x2 - x1) * x_factor;
     1: 		fs_metrics.height  = DOUBLE_FROM_26_6 (y2 - y1) * y_factor;
     1: 
     1: 		fs_metrics.x_advance = DOUBLE_FROM_26_6 (advance) * x_factor;
     1: 		fs_metrics.y_advance = 0;
     1: 	    } else {
     1: 		x1 = (metrics->vertBearingX) & -64;
     1: 		x2 = (metrics->vertBearingX + metrics->width + 63) & -64;
     1: 		y1 = (metrics->vertBearingY) & -64;
     1: 		y2 = (metrics->vertBearingY + metrics->height + 63) & -64;
     1: 
     1: 		advance = ((metrics->vertAdvance + 32) & -64);
     1: 
     1: 		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (x1) * x_factor;
     1: 		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (y1) * y_factor;
     1: 
     1: 		fs_metrics.width  = DOUBLE_FROM_26_6 (x2 - x1) * x_factor;
     1: 		fs_metrics.height  = DOUBLE_FROM_26_6 (y2 - y1) * y_factor;
     1: 
     1: 		fs_metrics.x_advance = 0;
     1: 		fs_metrics.y_advance = DOUBLE_FROM_26_6 (advance) * y_factor;
     1: 	    }
     1: 	 } else {
     1: 	    fs_metrics.width  = DOUBLE_FROM_26_6 (metrics->width) * x_factor;
     1: 	    fs_metrics.height = DOUBLE_FROM_26_6 (metrics->height) * y_factor;
     1: 
     1: 	    if (!vertical_layout) {
     1: 		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (metrics->horiBearingX) * x_factor;
     1: 		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (-metrics->horiBearingY) * y_factor;
     1: 
   314: 		if (hint_metrics || glyph->format != FT_GLYPH_FORMAT_OUTLINE)
     1: 		    fs_metrics.x_advance = DOUBLE_FROM_26_6 (metrics->horiAdvance) * x_factor;
   314: 		else
   314: 		    fs_metrics.x_advance = DOUBLE_FROM_16_16 (glyph->linearHoriAdvance) * x_factor;
     1: 		fs_metrics.y_advance = 0 * y_factor;
     1: 	    } else {
     1: 		fs_metrics.x_bearing = DOUBLE_FROM_26_6 (metrics->vertBearingX) * x_factor;
     1: 		fs_metrics.y_bearing = DOUBLE_FROM_26_6 (metrics->vertBearingY) * y_factor;
     1: 
     1: 		fs_metrics.x_advance = 0 * x_factor;
   314: 		if (hint_metrics || glyph->format != FT_GLYPH_FORMAT_OUTLINE)
     1: 		    fs_metrics.y_advance = DOUBLE_FROM_26_6 (metrics->vertAdvance) * y_factor;
   314: 		else
 32473: 		    fs_metrics.y_advance = DOUBLE_FROM_16_16 (glyph->linearVertAdvance) * y_factor;
     1: 	    }
     1: 	 }
     1: 
     1: 	_cairo_scaled_glyph_set_metrics (scaled_glyph,
     1: 					 &scaled_font->base,
     1: 					 &fs_metrics);
     1:     }
     1: 
     1:     if ((info & CAIRO_SCALED_GLYPH_INFO_SURFACE) != 0) {
     1: 	cairo_image_surface_t	*surface;
     1: 
     1: 	if (glyph->format == FT_GLYPH_FORMAT_OUTLINE) {
     1: 	    status = _render_glyph_outline (face, &scaled_font->ft_options.base,
     1: 					    &surface);
     1: 	} else {
     1: 	    status = _render_glyph_bitmap (face, &scaled_font->ft_options.base,
     1: 					   &surface);
 26419: 	    if (likely (status == CAIRO_STATUS_SUCCESS) &&
 26419: 		unscaled->have_shape)
 26419: 	    {
     1: 		status = _transform_glyph_bitmap (&unscaled->current_shape,
     1: 						  &surface);
 26419: 		if (unlikely (status))
  4133: 		    cairo_surface_destroy (&surface->base);
  4133: 	    }
     1: 	}
 26419: 	if (unlikely (status))
     1: 	    goto FAIL;
     1: 
     1: 	_cairo_scaled_glyph_set_surface (scaled_glyph,
     1: 					 &scaled_font->base,
     1: 					 surface);
     1:     }
     1: 
     1:     if (info & CAIRO_SCALED_GLYPH_INFO_PATH) {
  8452: 	cairo_path_fixed_t *path = NULL; /* hide compiler warning */
     1: 
     1: 	/*
     1: 	 * A kludge -- the above code will trash the outline,
     1: 	 * so reload it. This will probably never occur though
     1: 	 */
     1: 	if ((info & CAIRO_SCALED_GLYPH_INFO_SURFACE) != 0) {
     1: 	    error = FT_Load_Glyph (face,
     1: 				   _cairo_scaled_glyph_index(scaled_glyph),
     1: 				   load_flags | FT_LOAD_NO_BITMAP);
  6154: 	    /* XXX ignoring all other errors for now.  They are not fatal, typically
  6154: 	     * just a glyph-not-found. */
  6154: 	    if (error == FT_Err_Out_Of_Memory) {
  8452: 		status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
  8452: 		goto FAIL;
     1: 	    }
     1: #if HAVE_FT_GLYPHSLOT_EMBOLDEN
     1: 	    /*
     1: 	     * embolden glyphs if requested
     1: 	     */
     1: 	    if (scaled_font->ft_options.extra_flags & CAIRO_FT_OPTIONS_EMBOLDEN)
     1: 		FT_GlyphSlot_Embolden (glyph);
     1: #endif
     1: 	    if (vertical_layout)
     1: 		_cairo_ft_scaled_glyph_vertical_layout_bearing_fix (scaled_font, glyph);
     1: 
     1: 	}
     1: 	if (glyph->format == FT_GLYPH_FORMAT_OUTLINE)
     1: 	    status = _decompose_glyph_outline (face, &scaled_font->ft_options.base,
     1: 					       &path);
     1: 	else
     1: 	    status = CAIRO_INT_STATUS_UNSUPPORTED;
     1: 
 26419: 	if (unlikely (status))
     1: 	    goto FAIL;
     1: 
     1: 	_cairo_scaled_glyph_set_path (scaled_glyph,
     1: 				      &scaled_font->base,
     1: 				      path);
     1:     }
     1:  FAIL:
   314:     _cairo_ft_unscaled_font_unlock_face (unscaled);
     1: 
     1:     return status;
     1: }
     1: 
     1: static unsigned long
     1: _cairo_ft_ucs4_to_index (void	    *abstract_font,
     1: 			 uint32_t    ucs4)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = abstract_font;
     1:     cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
     1:     FT_Face face;
     1:     FT_UInt index;
     1: 
     1:     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     1:     if (!face)
     1: 	return 0;
 18904: 
 26419: #if CAIRO_HAS_FC_FONT
 26419:     index = FcFreeTypeCharIndex (face, ucs4);
 26419: #else
 24104:     index = FT_Get_Char_Index (face, ucs4);
 24104: #endif
 26419: 
     1:     _cairo_ft_unscaled_font_unlock_face (unscaled);
     1:     return index;
     1: }
     1: 
     1: static cairo_int_status_t
     1: _cairo_ft_load_truetype_table (void	       *abstract_font,
     1:                               unsigned long     tag,
     1:                               long              offset,
     1:                               unsigned char    *buffer,
     1:                               unsigned long    *length)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = abstract_font;
     1:     cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
     1:     FT_Face face;
     1:     cairo_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
     1: 
     1:     if (_cairo_ft_scaled_font_is_vertical (&scaled_font->base))
     1:         return CAIRO_INT_STATUS_UNSUPPORTED;
     1: 
     1: #if HAVE_FT_LOAD_SFNT_TABLE
     1:     face = _cairo_ft_unscaled_font_lock_face (unscaled);
     1:     if (!face)
  8452: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 
     1:     if (FT_IS_SFNT (face) &&
     1: 	FT_Load_Sfnt_Table (face, tag, offset, buffer, length) == 0)
     1:         status = CAIRO_STATUS_SUCCESS;
     1: 
     1:     _cairo_ft_unscaled_font_unlock_face (unscaled);
     1: #endif
     1: 
     1:     return status;
     1: }
     1: 
 10414: static cairo_int_status_t
 16122: _cairo_ft_index_to_ucs4(void	        *abstract_font,
 16122: 			unsigned long    index,
 16122: 			uint32_t	*ucs4)
   314: {
   314:     cairo_ft_scaled_font_t *scaled_font = abstract_font;
   314:     cairo_ft_unscaled_font_t *unscaled = scaled_font->unscaled;
   314:     FT_Face face;
 16122:     FT_ULong  charcode;
 16122:     FT_UInt   gindex;
   314: 
   314:     face = _cairo_ft_unscaled_font_lock_face (unscaled);
   314:     if (!face)
 10414: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
   314: 
 16122:     *ucs4 = (uint32_t) -1;
 16122:     charcode = FT_Get_First_Char(face, &gindex);
 16122:     while (gindex != 0) {
 16122: 	if (gindex == index) {
 16122: 	    *ucs4 = charcode;
   314: 	    break;
   314: 	}
 41340: 	charcode = FT_Get_Next_Char (face, charcode, &gindex);
   314:     }
 16122: 
   314:     _cairo_ft_unscaled_font_unlock_face (unscaled);
 10414: 
 10414:     return CAIRO_STATUS_SUCCESS;
   314: }
   314: 
 26419: static const cairo_scaled_font_backend_t _cairo_ft_scaled_font_backend = {
     1:     CAIRO_FONT_TYPE_FT,
     1:     _cairo_ft_scaled_font_fini,
     1:     _cairo_ft_scaled_glyph_init,
     1:     NULL,			/* text_to_glyphs */
     1:     _cairo_ft_ucs4_to_index,
     1:     NULL,			/* show_glyphs */
     1:     _cairo_ft_load_truetype_table,
 16122:     _cairo_ft_index_to_ucs4
     1: };
     1: 
 11708: /* #cairo_ft_font_face_t */
     1: 
 26419: #if CAIRO_HAS_FC_FONT
 26419: static cairo_status_t
 26419: _cairo_ft_font_face_create_for_pattern (FcPattern *pattern,
 26419: 					cairo_font_face_t **out);
 26419: 
 26419: static cairo_status_t
 26419: _cairo_ft_font_face_create_for_toy (cairo_toy_font_face_t   *toy_face,
 26419: 				    cairo_font_face_t      **font_face)
 26419: {
 26419:     FcPattern *pattern;
 26419:     int fcslant;
 26419:     int fcweight;
 26419:     cairo_status_t status = CAIRO_STATUS_SUCCESS;
 26419: 
 26419:     pattern = FcPatternCreate ();
 26419:     if (!pattern)
 26419: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419: 
 26419:     if (!FcPatternAddString (pattern,
 26419: 		             FC_FAMILY, (unsigned char *) toy_face->family))
 26419:     {
 26419: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419: 	goto FREE_PATTERN;
 26419:     }
 26419: 
 26419:     switch (toy_face->slant)
 26419:     {
 26419:     case CAIRO_FONT_SLANT_ITALIC:
 26419:         fcslant = FC_SLANT_ITALIC;
 26419:         break;
 26419:     case CAIRO_FONT_SLANT_OBLIQUE:
 26419: 	fcslant = FC_SLANT_OBLIQUE;
 26419:         break;
 26419:     case CAIRO_FONT_SLANT_NORMAL:
 26419:     default:
 26419:         fcslant = FC_SLANT_ROMAN;
 26419:         break;
 26419:     }
 26419: 
 26419:     if (!FcPatternAddInteger (pattern, FC_SLANT, fcslant)) {
 26419: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419: 	goto FREE_PATTERN;
 26419:     }
 26419: 
 26419:     switch (toy_face->weight)
 26419:     {
 26419:     case CAIRO_FONT_WEIGHT_BOLD:
 26419:         fcweight = FC_WEIGHT_BOLD;
 26419:         break;
 26419:     case CAIRO_FONT_WEIGHT_NORMAL:
 26419:     default:
 26419:         fcweight = FC_WEIGHT_MEDIUM;
 26419:         break;
 26419:     }
 26419: 
 26419:     if (!FcPatternAddInteger (pattern, FC_WEIGHT, fcweight)) {
 26419: 	status = _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419: 	goto FREE_PATTERN;
 26419:     }
 26419: 
 26419:     status = _cairo_ft_font_face_create_for_pattern (pattern, font_face);
 26419: 
 26419:  FREE_PATTERN:
 26419:     FcPatternDestroy (pattern);
 26419: 
 26419:     return status;
 26419: }
 26419: #endif
 26419: 
     1: static void
     1: _cairo_ft_font_face_destroy (void *abstract_face)
     1: {
     1:     cairo_ft_font_face_t *font_face = abstract_face;
     1: 
 28494:     /* When destroying a face created by cairo_ft_font_face_create_for_ft_face,
     1:      * we have a special "zombie" state for the face when the unscaled font
 28494:      * is still alive but there are no other references to a font face with
 28494:      * the same FT_Face.
     1:      *
     1:      * We go from:
     1:      *
     1:      *   font_face ------> unscaled
     1:      *        <-....weak....../
     1:      *
     1:      * To:
     1:      *
     1:      *    font_face <------- unscaled
     1:      */
     1: 
     1:     if (font_face->unscaled &&
     1: 	font_face->unscaled->from_face &&
 28494: 	font_face->next == NULL &&
 28494: 	font_face->unscaled->faces == font_face &&
  8452: 	CAIRO_REFERENCE_COUNT_GET_VALUE (&font_face->unscaled->base.ref_count) > 1)
     1:     {
     1: 	cairo_font_face_reference (&font_face->base);
     1: 
     1: 	_cairo_unscaled_font_destroy (&font_face->unscaled->base);
     1: 	font_face->unscaled = NULL;
     1: 
     1: 	return;
     1:     }
     1: 
     1:     if (font_face->unscaled) {
 41340: 	cairo_ft_font_face_t *tmp_face = NULL;
 41340: 	cairo_ft_font_face_t *last_face = NULL;
 41340: 
     1: 	/* Remove face from linked list */
     1: 	for (tmp_face = font_face->unscaled->faces;
     1: 	     tmp_face;
     1: 	     tmp_face = tmp_face->next)
     1: 	{
     1: 	    if (tmp_face == font_face) {
     1: 		if (last_face)
     1: 		    last_face->next = tmp_face->next;
     1: 		else
     1: 		    font_face->unscaled->faces = tmp_face->next;
     1: 	    }
     1: 
     1: 	    last_face = tmp_face;
     1: 	}
     1: 
     1: 	_cairo_unscaled_font_destroy (&font_face->unscaled->base);
     1: 	font_face->unscaled = NULL;
     1:     }
 26419: 
 26419: #if CAIRO_HAS_FC_FONT
 32473:     if (font_face->pattern) {
 26419: 	FcPatternDestroy (font_face->pattern);
 32473: 	cairo_font_face_destroy (font_face->resolved_font_face);
 32473:     }
 26419: #endif
     1: }
     1: 
 32473: static cairo_font_face_t *
 32473: _cairo_ft_font_face_get_implementation (void                     *abstract_face,
     1: 					const cairo_matrix_t       *font_matrix,
     1: 					const cairo_matrix_t       *ctm,
 32473: 					const cairo_font_options_t *options)
     1: {
     1:     cairo_ft_font_face_t      *font_face = abstract_face;
     1: 
     1:     /* The handling of font options is different depending on how the
     1:      * font face was created. When the user creates a font face with
     1:      * cairo_ft_font_face_create_for_ft_face(), then the load flags
     1:      * passed in augment the load flags for the options.  But for
     1:      * cairo_ft_font_face_create_for_pattern(), the load flags are
     1:      * derived from a pattern where the user has called
     1:      * cairo_ft_font_options_substitute(), so *just* use those load
     1:      * flags and ignore the options.
     1:      */
     1: 
 26419: #if CAIRO_HAS_FC_FONT
 26419:     /* If we have an unresolved pattern, resolve it and create
 26419:      * unscaled font.  Otherwise, use the ones stored in font_face.
 26419:      */
 26419:     if (font_face->pattern) {
 32473: 	cairo_font_face_t *resolved;
 32473: 
 32473: 	/* Cache the resolved font whilst the FcConfig remains consistent. */
 32473: 	resolved = font_face->resolved_font_face;
 32473: 	if (resolved != NULL) {
 32473: 	    if (! FcInitBringUptoDate ()) {
 32473: 		_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
 32473: 		return (cairo_font_face_t *) &_cairo_font_face_nil;
 32473: 	    }
 32473: 
 32473: 	    if (font_face->resolved_config == FcConfigGetCurrent ())
 32473: 		return cairo_font_face_reference (resolved);
 32473: 
 32473: 	    cairo_font_face_destroy (resolved);
 41340: 	    font_face->resolved_font_face = NULL;
 32473: 	}
 32473: 
 32473: 	resolved = _cairo_ft_resolve_pattern (font_face->pattern,
 26419: 					      font_matrix,
 26419: 					      ctm,
 32473: 					      options);
 41340: 	if (unlikely (resolved->status))
 41340: 	    return resolved;
 32473: 
 32473: 	font_face->resolved_font_face = cairo_font_face_reference (resolved);
 32473: 	font_face->resolved_config = FcConfigGetCurrent ();
 32473: 
 32473: 	return resolved;
 26419:     }
 26419: #endif
 32473: 
 32473:     return abstract_face;
  4133: }
     1: 
 26419: const cairo_font_face_backend_t _cairo_ft_font_face_backend = {
     1:     CAIRO_FONT_TYPE_FT,
 26419: #if CAIRO_HAS_FC_FONT
 26419:     _cairo_ft_font_face_create_for_toy,
 26419: #else
 26419:     NULL,
 26419: #endif
     1:     _cairo_ft_font_face_destroy,
 32473:     _cairo_ft_font_face_scaled_font_create,
 32473:     _cairo_ft_font_face_get_implementation
     1: };
     1: 
 26419: #if CAIRO_HAS_FC_FONT
 26419: static cairo_status_t
 26419: _cairo_ft_font_face_create_for_pattern (FcPattern *pattern,
 26419: 					cairo_font_face_t **out)
 26419: {
 26419:     cairo_ft_font_face_t *font_face;
 26419: 
 26419:     font_face = malloc (sizeof (cairo_ft_font_face_t));
 26419:     if (unlikely (font_face == NULL))
 26419: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419: 
 26419:     font_face->unscaled = NULL;
 26419:     font_face->next = NULL;
 26419: 
 26419:     font_face->pattern = FcPatternDuplicate (pattern);
 28364:     if (unlikely (font_face->pattern == NULL)) {
 26419: 	free (font_face);
 26419: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 26419:     }
 26419: 
 32473:     font_face->resolved_font_face = NULL;
 32473:     font_face->resolved_config = NULL;
 32473: 
 26419:     _cairo_font_face_init (&font_face->base, &_cairo_ft_font_face_backend);
 26419: 
 26419:     *out = &font_face->base;
 26419:     return CAIRO_STATUS_SUCCESS;
 26419: }
 26419: #endif
 26419: 
     1: static cairo_font_face_t *
     1: _cairo_ft_font_face_create (cairo_ft_unscaled_font_t *unscaled,
     1: 			    cairo_ft_options_t	     *ft_options)
     1: {
  4133:     cairo_ft_font_face_t *font_face, **prev_font_face;
     1: 
     1:     /* Looked for an existing matching font face */
  4133:     for (font_face = unscaled->faces, prev_font_face = &unscaled->faces;
     1: 	 font_face;
  4133: 	 prev_font_face = &font_face->next, font_face = font_face->next)
     1:     {
     1: 	if (font_face->ft_options.load_flags == ft_options->load_flags &&
     1: 	    font_face->ft_options.extra_flags == ft_options->extra_flags &&
     1: 	    cairo_font_options_equal (&font_face->ft_options.base, &ft_options->base))
  4133: 	{
 28494: 	    if (font_face->base.status) {
  4133: 		/* The font_face has been left in an error state, abandon it. */
  4133: 		*prev_font_face = font_face->next;
  4133: 		break;
  4133: 	    }
 28494: 
 28494: 	    if (font_face->unscaled == NULL) {
 28494: 		/* Resurrect this "zombie" font_face (from
 28494: 		 * _cairo_ft_font_face_destroy), switching its unscaled_font
 28494: 		 * from owner to ownee. */
 28494: 		font_face->unscaled = unscaled;
 28494: 		_cairo_unscaled_font_reference (&unscaled->base);
 28494: 		return &font_face->base;
 28494: 	    } else
 28494: 		return cairo_font_face_reference (&font_face->base);
 28494: 	}
     1:     }
     1: 
     1:     /* No match found, create a new one */
     1:     font_face = malloc (sizeof (cairo_ft_font_face_t));
 26419:     if (unlikely (!font_face)) {
  8452: 	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
 13107: 	return (cairo_font_face_t *)&_cairo_font_face_nil;
  4133:     }
     1: 
     1:     font_face->unscaled = unscaled;
     1:     _cairo_unscaled_font_reference (&unscaled->base);
     1: 
     1:     font_face->ft_options = *ft_options;
     1: 
 28494:     if (unscaled->faces && unscaled->faces->unscaled == NULL) {
 28494: 	/* This "zombie" font_face (from _cairo_ft_font_face_destroy)
 28494: 	 * is no longer needed. */
 28494: 	assert (unscaled->from_face && unscaled->faces->next == NULL);
 28494: 	cairo_font_face_destroy (&unscaled->faces->base);
 28494: 	unscaled->faces = NULL;
 28494:     }
 28494: 
     1:     font_face->next = unscaled->faces;
     1:     unscaled->faces = font_face;
     1: 
 26419: #if CAIRO_HAS_FC_FONT
 26419:     font_face->pattern = NULL;
 26419: #endif
 26419: 
     1:     _cairo_font_face_init (&font_face->base, &_cairo_ft_font_face_backend);
     1: 
     1:     return &font_face->base;
     1: }
     1: 
     1: /* implement the platform-specific interface */
     1: 
 26419: #if CAIRO_HAS_FC_FONT
  8452: static cairo_status_t
  8452: _cairo_ft_font_options_substitute (const cairo_font_options_t *options,
     1: 				   FcPattern                  *pattern)
     1: {
     1:     FcValue v;
     1: 
     1:     if (options->antialias != CAIRO_ANTIALIAS_DEFAULT)
     1:     {
     1: 	if (FcPatternGet (pattern, FC_ANTIALIAS, 0, &v) == FcResultNoMatch)
     1: 	{
  8452: 	    if (! FcPatternAddBool (pattern,
  8452: 			            FC_ANTIALIAS,
  8452: 				    options->antialias != CAIRO_ANTIALIAS_NONE))
  8452: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
  8452: 
     1: 	    if (options->antialias != CAIRO_ANTIALIAS_SUBPIXEL) {
     1: 		FcPatternDel (pattern, FC_RGBA);
  8452: 		if (! FcPatternAddInteger (pattern, FC_RGBA, FC_RGBA_NONE))
  8452: 		    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 	    }
     1: 	}
     1:     }
     1: 
     1:     if (options->antialias != CAIRO_ANTIALIAS_DEFAULT)
     1:     {
     1: 	if (FcPatternGet (pattern, FC_RGBA, 0, &v) == FcResultNoMatch)
     1: 	{
     1: 	    int rgba;
     1: 
     1: 	    if (options->antialias == CAIRO_ANTIALIAS_SUBPIXEL) {
     1: 		switch (options->subpixel_order) {
     1: 		case CAIRO_SUBPIXEL_ORDER_DEFAULT:
     1: 		case CAIRO_SUBPIXEL_ORDER_RGB:
     1: 		default:
     1: 		    rgba = FC_RGBA_RGB;
     1: 		    break;
     1: 		case CAIRO_SUBPIXEL_ORDER_BGR:
     1: 		    rgba = FC_RGBA_BGR;
     1: 		    break;
     1: 		case CAIRO_SUBPIXEL_ORDER_VRGB:
     1: 		    rgba = FC_RGBA_VRGB;
     1: 		    break;
     1: 		case CAIRO_SUBPIXEL_ORDER_VBGR:
     1: 		    rgba = FC_RGBA_VBGR;
     1: 		    break;
     1: 		}
     1: 	    } else {
     1: 		rgba = FC_RGBA_NONE;
     1: 	    }
     1: 
  8452: 	    if (! FcPatternAddInteger (pattern, FC_RGBA, rgba))
  8452: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 	}
     1:     }
     1: 
 70960:     if (options->lcd_filter != CAIRO_LCD_FILTER_DEFAULT)
 70960:     {
 70960: 	if (FcPatternGet (pattern, FC_LCD_FILTER, 0, &v) == FcResultNoMatch)
 70960: 	{
 70960: 	    int lcd_filter;
 70960: 
 70960: 	    switch (options->lcd_filter) {
 70960: 	    case CAIRO_LCD_FILTER_NONE:
 70960: 		lcd_filter = FT_LCD_FILTER_NONE;
 70960: 		break;
 70960: 	    case CAIRO_LCD_FILTER_DEFAULT:
 70960: 	    case CAIRO_LCD_FILTER_INTRA_PIXEL:
 70960: 		lcd_filter = FT_LCD_FILTER_LEGACY;
 70960: 		break;
 70960: 	    case CAIRO_LCD_FILTER_FIR3:
 70960: 		lcd_filter = FT_LCD_FILTER_LIGHT;
 70960: 		break;
 70960: 	    default:
 70960: 	    case CAIRO_LCD_FILTER_FIR5:
 70960: 		lcd_filter = FT_LCD_FILTER_DEFAULT;
 70960: 		break;
 70960: 	    }
 70960: 
 70960: 	    if (! FcPatternAddInteger (pattern, FC_LCD_FILTER, lcd_filter))
 70960: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
 70960: 	}
 70960:     }
 70960: 
     1:     if (options->hint_style != CAIRO_HINT_STYLE_DEFAULT)
     1:     {
     1: 	if (FcPatternGet (pattern, FC_HINTING, 0, &v) == FcResultNoMatch)
     1: 	{
  8452: 	    if (! FcPatternAddBool (pattern,
  8452: 			            FC_HINTING,
  8452: 				    options->hint_style != CAIRO_HINT_STYLE_NONE))
  8452: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 	}
     1: 
     1: #ifdef FC_HINT_STYLE
     1: 	if (FcPatternGet (pattern, FC_HINT_STYLE, 0, &v) == FcResultNoMatch)
     1: 	{
     1: 	    int hint_style;
     1: 
     1: 	    switch (options->hint_style) {
     1: 	    case CAIRO_HINT_STYLE_NONE:
     1: 		hint_style = FC_HINT_NONE;
     1: 		break;
     1: 	    case CAIRO_HINT_STYLE_SLIGHT:
     1: 		hint_style = FC_HINT_SLIGHT;
     1: 		break;
     1: 	    case CAIRO_HINT_STYLE_MEDIUM:
     1: 		hint_style = FC_HINT_MEDIUM;
     1: 		break;
     1: 	    case CAIRO_HINT_STYLE_FULL:
     1: 	    case CAIRO_HINT_STYLE_DEFAULT:
     1: 	    default:
     1: 		hint_style = FC_HINT_FULL;
     1: 		break;
     1: 	    }
     1: 
  8452: 	    if (! FcPatternAddInteger (pattern, FC_HINT_STYLE, hint_style))
  8452: 		return _cairo_error (CAIRO_STATUS_NO_MEMORY);
     1: 	}
     1: #endif
     1:     }
  8452: 
  8452:     return CAIRO_STATUS_SUCCESS;
     1: }
  8452: 
  8452: /**
  8452:  * cairo_ft_font_options_substitute:
  8452:  * @options: a #cairo_font_options_t object
  8452:  * @pattern: an existing #FcPattern
  8452:  *
  8452:  * Add options to a #FcPattern based on a #cairo_font_options_t font
  8452:  * options object. Options that are already in the pattern, are not overridden,
  8452:  * so you should call this function after calling FcConfigSubstitute() (the
  8452:  * user's settings should override options based on the surface type), but
  8452:  * before calling FcDefaultSubstitute().
  8452:  **/
  8452: void
  8452: cairo_ft_font_options_substitute (const cairo_font_options_t *options,
  8452: 				  FcPattern                  *pattern)
  8452: {
 10694:     if (cairo_font_options_status ((cairo_font_options_t *) options))
 10694: 	return;
 10694: 
  8452:     _cairo_ft_font_options_substitute (options, pattern);
  8452: }
     1: 
 32473: static cairo_font_face_t *
 26419: _cairo_ft_resolve_pattern (FcPattern		      *pattern,
 26419: 			   const cairo_matrix_t       *font_matrix,
 26419: 			   const cairo_matrix_t       *ctm,
 32473: 			   const cairo_font_options_t *font_options)
 26419: {
 26419:     cairo_status_t status;
 26419: 
 26419:     cairo_matrix_t scale;
 26419:     FcPattern *resolved;
 26419:     cairo_ft_font_transform_t sf;
 26419:     FcResult result;
 32473:     cairo_ft_unscaled_font_t *unscaled;
 32473:     cairo_ft_options_t ft_options;
 32473:     cairo_font_face_t *font_face;
 26419: 
 26419:     scale = *ctm;
 26419:     scale.x0 = scale.y0 = 0;
 26419:     cairo_matrix_multiply (&scale,
 26419:                            font_matrix,
 26419:                            &scale);
 26419: 
 26419:     status = _compute_transform (&sf, &scale);
 32473:     if (unlikely (status))
 32473: 	return (cairo_font_face_t *)&_cairo_font_face_nil;
 26419: 
 26419:     pattern = FcPatternDuplicate (pattern);
 28364:     if (pattern == NULL)
 32473: 	return (cairo_font_face_t *)&_cairo_font_face_nil;
 26419: 
 26419:     if (! FcPatternAddDouble (pattern, FC_PIXEL_SIZE, sf.y_scale)) {
 32473: 	font_face = (cairo_font_face_t *)&_cairo_font_face_nil;
 26419: 	goto FREE_PATTERN;
 26419:     }
 26419: 
 26419:     if (! FcConfigSubstitute (NULL, pattern, FcMatchPattern)) {
 32473: 	font_face = (cairo_font_face_t *)&_cairo_font_face_nil;
 26419: 	goto FREE_PATTERN;
 26419:     }
 26419: 
 26419:     status = _cairo_ft_font_options_substitute (font_options, pattern);
 32473:     if (status) {
 32473: 	font_face = (cairo_font_face_t *)&_cairo_font_face_nil;
 32346: 	goto FREE_PATTERN;
 32473:     }
 32346: 
 32346:     FcDefaultSubstitute (pattern);
 32346: 
 32346:     resolved = FcFontMatch (NULL, pattern, &result);
 32346:     if (!resolved) {
 32473: 	/* We failed to find any font. Substitute twin so that the user can
 32473: 	 * see something (and hopefully recognise that the font is missing)
 32473: 	 * and not just receive a NO_MEMORY error during rendering.
 32473: 	 */
 32473: 	font_face = _cairo_font_face_twin_create_fallback ();
 26419: 	goto FREE_PATTERN;
 32343:     }
 26419: 
 32473:     status = _cairo_ft_unscaled_font_create_for_pattern (resolved, &unscaled);
 70960:     if (unlikely (status || unscaled == NULL)) {
 32473: 	font_face = (cairo_font_face_t *)&_cairo_font_face_nil;
 26419: 	goto FREE_RESOLVED;
 32473:     }
 32473: 
 32473:     _get_pattern_ft_options (resolved, &ft_options);
 32473:     font_face = _cairo_ft_font_face_create (unscaled, &ft_options);
 32473:     _cairo_unscaled_font_destroy (&unscaled->base);
 26419: 
 26419: FREE_RESOLVED:
 26419:     FcPatternDestroy (resolved);
 26419: 
 26419: FREE_PATTERN:
 26419:     FcPatternDestroy (pattern);
 26419: 
 32473:     return font_face;
 26419: }
 26419: 
     1: /**
     1:  * cairo_ft_font_face_create_for_pattern:
 26419:  * @pattern: A fontconfig pattern.  Cairo makes a copy of the pattern
 26419:  * if it needs to.  You are free to modify or free @pattern after this call.
     1:  *
     1:  * Creates a new font face for the FreeType font backend based on a
     1:  * fontconfig pattern. This font can then be used with
     1:  * cairo_set_font_face() or cairo_scaled_font_create(). The
     1:  * #cairo_scaled_font_t returned from cairo_scaled_font_create() is
     1:  * also for the FreeType backend and can be used with functions such
 16122:  * as cairo_ft_scaled_font_lock_face().
     1:  *
     1:  * Font rendering options are represented both here and when you
     1:  * call cairo_scaled_font_create(). Font options that have a representation
     1:  * in a #FcPattern must be passed in here; to modify #FcPattern
     1:  * appropriately to reflect the options in a #cairo_font_options_t, call
     1:  * cairo_ft_font_options_substitute().
     1:  *
 16122:  * The pattern's FC_FT_FACE element is inspected first and if that is set,
 16122:  * that will be the FreeType font face associated with the returned cairo
 26419:  * font face.  Otherwise the FC_FILE element is checked.  If it's set,
 26419:  * that and the value of the FC_INDEX element (defaults to zero) of @pattern
 26419:  * are used to load a font face from file.
 26419:  *
 26419:  * If both steps from the previous paragraph fails, @pattern will be passed
 26419:  * to FcConfigSubstitute, FcDefaultSubstitute, and finally FcFontMatch,
 26419:  * and the resulting font pattern is used.
 16122:  *
 16122:  * If the FC_FT_FACE element of @pattern is set, the user is responsible
 16122:  * for making sure that the referenced FT_Face remains valid for the life
 16122:  * time of the returned #cairo_font_face_t.  See
 16122:  * cairo_ft_font_face_create_for_ft_face() for an exmaple of how to couple
 16122:  * the life time of the FT_Face to that of the cairo font-face.
 16122:  *
     1:  * Return value: a newly created #cairo_font_face_t. Free with
     1:  *  cairo_font_face_destroy() when you are done using it.
     1:  **/
     1: cairo_font_face_t *
     1: cairo_ft_font_face_create_for_pattern (FcPattern *pattern)
     1: {
     1:     cairo_ft_unscaled_font_t *unscaled;
     1:     cairo_font_face_t *font_face;
     1:     cairo_ft_options_t ft_options;
 28364:     cairo_status_t status;
 28364: 
 28364:     status = _cairo_ft_unscaled_font_create_for_pattern (pattern, &unscaled);
 28364:     if (unlikely (status))
 28364: 	return (cairo_font_face_t *) &_cairo_font_face_nil;
 26419:     if (unlikely (unscaled == NULL)) {
 26419: 	/* Store the pattern.  We will resolve it and create unscaled
 26419: 	 * font when creating scaled fonts */
 26419: 	status = _cairo_ft_font_face_create_for_pattern (pattern,
 26419: 							 &font_face);
 26419: 	if (unlikely (status))
     1: 	    return (cairo_font_face_t *) &_cairo_font_face_nil;
 26419: 
 26419: 	return font_face;
     1:     }
     1: 
     1:     _get_pattern_ft_options (pattern, &ft_options);
     1:     font_face = _cairo_ft_font_face_create (unscaled, &ft_options);
     1:     _cairo_unscaled_font_destroy (&unscaled->base);
     1: 
     1:     return font_face;
     1: }
 26419: #endif
     1: 
     1: /**
     1:  * cairo_ft_font_face_create_for_ft_face:
     1:  * @face: A FreeType face object, already opened. This must
     1:  *   be kept around until the face's ref_count drops to
     1:  *   zero and it is freed. Since the face may be referenced
     1:  *   internally to Cairo, the best way to determine when it
     1:  *   is safe to free the face is to pass a
     1:  *   #cairo_destroy_func_t to cairo_font_face_set_user_data()
     1:  * @load_flags: flags to pass to FT_Load_Glyph when loading
     1:  *   glyphs from the font. These flags are OR'ed together with
     1:  *   the flags derived from the #cairo_font_options_t passed
     1:  *   to cairo_scaled_font_create(), so only a few values such
     1:  *   as %FT_LOAD_VERTICAL_LAYOUT, and %FT_LOAD_FORCE_AUTOHINT
     1:  *   are useful. You should not pass any of the flags affecting
     1:  *   the load target, such as %FT_LOAD_TARGET_LIGHT.
     1:  *
     1:  * Creates a new font face for the FreeType font backend from a
     1:  * pre-opened FreeType face. This font can then be used with
     1:  * cairo_set_font_face() or cairo_scaled_font_create(). The
     1:  * #cairo_scaled_font_t returned from cairo_scaled_font_create() is
     1:  * also for the FreeType backend and can be used with functions such
 21379:  * as cairo_ft_scaled_font_lock_face(). Note that Cairo may keep a reference
 21379:  * to the FT_Face alive in a font-cache and the exact lifetime of the reference
 21379:  * depends highly upon the exact usage pattern and is subject to external
 21379:  * factors. You must not call FT_Done_Face() before the last reference to the
 21379:  * #cairo_font_face_t has been dropped.
 16122:  *
 21379:  * As an example, below is how one might correctly couple the lifetime of
 21379:  * the FreeType face object to the #cairo_font_face_t.
 16122:  *
 16122:  * <informalexample><programlisting>
 16122:  * static const cairo_user_data_key_t key;
 16122:  *
 16122:  * font_face = cairo_ft_font_face_create_for_ft_face (ft_face, 0);
 16122:  * status = cairo_font_face_set_user_data (font_face, &key,
 16122:  *                                ft_face, (cairo_destroy_func_t) FT_Done_Face);
 16122:  * if (status) {
 16122:  *    cairo_font_face_destroy (font_face);
 16122:  *    FT_Done_Face (ft_face);
 16122:  *    return ERROR;
 16122:  * }
 16122:  * </programlisting></informalexample>
     1:  *
     1:  * Return value: a newly created #cairo_font_face_t. Free with
     1:  *  cairo_font_face_destroy() when you are done using it.
     1:  **/
     1: cairo_font_face_t *
     1: cairo_ft_font_face_create_for_ft_face (FT_Face         face,
     1: 				       int             load_flags)
     1: {
     1:     cairo_ft_unscaled_font_t *unscaled;
     1:     cairo_font_face_t *font_face;
     1:     cairo_ft_options_t ft_options;
 28364:     cairo_status_t status;
 28364: 
 28364:     status = _cairo_ft_unscaled_font_create_from_face (face, &unscaled);
 28364:     if (unlikely (status))
     1: 	return (cairo_font_face_t *)&_cairo_font_face_nil;
     1: 
     1:     ft_options.load_flags = load_flags;
     1:     ft_options.extra_flags = 0;
     1:     _cairo_font_options_init_default (&ft_options.base);
     1: 
     1:     font_face = _cairo_ft_font_face_create (unscaled, &ft_options);
     1:     _cairo_unscaled_font_destroy (&unscaled->base);
     1: 
     1:     return font_face;
     1: }
     1: 
     1: /**
     1:  * cairo_ft_scaled_font_lock_face:
     1:  * @scaled_font: A #cairo_scaled_font_t from the FreeType font backend. Such an
     1:  *   object can be created by calling cairo_scaled_font_create() on a
     1:  *   FreeType backend font face (see cairo_ft_font_face_create_for_pattern(),
 16122:  *   cairo_ft_font_face_create_for_ft_face()).
     1:  *
 16122:  * cairo_ft_scaled_font_lock_face() gets the #FT_Face object from a FreeType
     1:  * backend font and scales it appropriately for the font. You must
 16122:  * release the face with cairo_ft_scaled_font_unlock_face()
     1:  * when you are done using it.  Since the #FT_Face object can be
     1:  * shared between multiple #cairo_scaled_font_t objects, you must not
     1:  * lock any other font objects until you unlock this one. A count is
 16122:  * kept of the number of times cairo_ft_scaled_font_lock_face() is
 16122:  * called. cairo_ft_scaled_font_unlock_face() must be called the same number
     1:  * of times.
     1:  *
     1:  * You must be careful when using this function in a library or in a
   314:  * threaded application, because freetype's design makes it unsafe to
   314:  * call freetype functions simultaneously from multiple threads, (even
   314:  * if using distinct FT_Face objects). Because of this, application
 26419:  * code that acquires an FT_Face object with this call must add its
   314:  * own locking to protect any use of that object, (and which also must
   314:  * protect any other calls into cairo as almost any cairo function
   314:  * might result in a call into the freetype library).
   314:  *
     1:  * Return value: The #FT_Face object for @font, scaled appropriately,
     1:  * or %NULL if @scaled_font is in an error state (see
     1:  * cairo_scaled_font_status()) or there is insufficient memory.
     1:  **/
     1: FT_Face
     1: cairo_ft_scaled_font_lock_face (cairo_scaled_font_t *abstract_font)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
     1:     FT_Face face;
  4133:     cairo_status_t status;
     1: 
 16122:     if (! _cairo_scaled_font_is_ft (abstract_font)) {
 16122: 	_cairo_error_throw (CAIRO_STATUS_FONT_TYPE_MISMATCH);
 16122: 	return NULL;
 16122:     }
 16122: 
     1:     if (scaled_font->base.status)
     1: 	return NULL;
     1: 
     1:     face = _cairo_ft_unscaled_font_lock_face (scaled_font->unscaled);
 26419:     if (unlikely (face == NULL)) {
  8452: 	status = _cairo_scaled_font_set_error (&scaled_font->base, CAIRO_STATUS_NO_MEMORY);
     1: 	return NULL;
     1:     }
     1: 
  4133:     status = _cairo_ft_unscaled_font_set_scale (scaled_font->unscaled,
     1: 				                &scaled_font->base.scale);
 26419:     if (unlikely (status)) {
  4133: 	_cairo_ft_unscaled_font_unlock_face (scaled_font->unscaled);
  8452: 	status = _cairo_scaled_font_set_error (&scaled_font->base, status);
  4133: 	return NULL;
  4133:     }
     1: 
 11708:     /* Note: We deliberately release the unscaled font's mutex here,
   314:      * so that we are not holding a lock across two separate calls to
   314:      * cairo function, (which would give the application some
   314:      * opportunity for creating deadlock. This is obviously unsafe,
   314:      * but as documented, the user must add manual locking when using
   314:      * this function. */
   314:      CAIRO_MUTEX_UNLOCK (scaled_font->unscaled->mutex);
   314: 
     1:     return face;
     1: }
     1: 
     1: /**
     1:  * cairo_ft_scaled_font_unlock_face:
     1:  * @scaled_font: A #cairo_scaled_font_t from the FreeType font backend. Such an
     1:  *   object can be created by calling cairo_scaled_font_create() on a
     1:  *   FreeType backend font face (see cairo_ft_font_face_create_for_pattern(),
     1:  *   cairo_ft_font_face_create_for_ft_face()).
     1:  *
     1:  * Releases a face obtained with cairo_ft_scaled_font_lock_face().
     1:  **/
     1: void
     1: cairo_ft_scaled_font_unlock_face (cairo_scaled_font_t *abstract_font)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
     1: 
 16122:     if (! _cairo_scaled_font_is_ft (abstract_font)) {
 16122: 	_cairo_error_throw (CAIRO_STATUS_FONT_TYPE_MISMATCH);
 16122: 	return;
 16122:     }
 16122: 
     1:     if (scaled_font->base.status)
     1: 	return;
     1: 
 11708:     /* Note: We released the unscaled font's mutex at the end of
   314:      * cairo_ft_scaled_font_lock_face, so we have to acquire it again
   314:      * as _cairo_ft_unscaled_font_unlock_face expects it to be held
   314:      * when we call into it. */
   314:     CAIRO_MUTEX_LOCK (scaled_font->unscaled->mutex);
   314: 
     1:     _cairo_ft_unscaled_font_unlock_face (scaled_font->unscaled);
     1: }
     1: 
     1: /* We expose our unscaled font implementation internally for the the
     1:  * PDF backend, which needs to keep track of the the different
     1:  * fonts-on-disk used by a document, so it can embed them.
     1:  */
     1: cairo_unscaled_font_t *
     1: _cairo_ft_scaled_font_get_unscaled_font (cairo_scaled_font_t *abstract_font)
     1: {
     1:     cairo_ft_scaled_font_t *scaled_font = (cairo_ft_scaled_font_t *) abstract_font;
     1: 
     1:     return &scaled_font->unscaled->base;
     1: }
     1: 
     1: cairo_bool_t
     1: _cairo_ft_scaled_font_is_vertical (cairo_scaled_font_t *scaled_font)
     1: {
     1:     cairo_ft_scaled_font_t *ft_scaled_font;
     1: 
     1:     if (!_cairo_scaled_font_is_ft (scaled_font))
     1: 	return FALSE;
     1: 
     1:     ft_scaled_font = (cairo_ft_scaled_font_t *) scaled_font;
     1:     if (ft_scaled_font->ft_options.load_flags & FT_LOAD_VERTICAL_LAYOUT)
     1: 	return TRUE;
     1:     return FALSE;
     1: }
     1: 
 26419: unsigned int
 26419: _cairo_ft_scaled_font_get_load_flags (cairo_scaled_font_t *scaled_font)
 26419: {
 26419:     cairo_ft_scaled_font_t *ft_scaled_font;
 26419: 
 26419:     if (! _cairo_scaled_font_is_ft (scaled_font))
 26419: 	return 0;
 26419: 
 26419:     ft_scaled_font = (cairo_ft_scaled_font_t *) scaled_font;
 26419:     return ft_scaled_font->ft_options.load_flags;
 26419: }
 26419: 
     1: void
     1: _cairo_ft_font_reset_static_data (void)
     1: {
     1:     _cairo_ft_unscaled_font_map_destroy ();
     1: }
