 42525: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 42525: 
 42525: #ifndef FRAMELAYERBUILDER_H_
 42525: #define FRAMELAYERBUILDER_H_
 42525: 
 47736: #include "nsTHashtable.h"
 47736: #include "nsHashKeys.h"
 47736: #include "nsTArray.h"
 47736: #include "nsRegion.h"
 47736: #include "nsIFrame.h"
 42525: 
 42525: class nsDisplayListBuilder;
 42525: class nsDisplayList;
 42525: class nsDisplayItem;
 47731: class gfxContext;
 54261: class nsRootPresContext;
 42525: 
 42525: namespace mozilla {
105710: namespace layers {
105710: class ContainerLayer;
108884: class LayerManager;
105710: class ThebesLayer;
105710: }
 42525: 
105568: class FrameLayerBuilder;
105568: 
 47751: enum LayerState {
 47751:   LAYER_NONE,
 47751:   LAYER_INACTIVE,
 63413:   LAYER_ACTIVE,
 63413:   // Force an active layer even if it causes incorrect rendering, e.g.
 63413:   // when the layer has rounded rect clips.
 67860:   LAYER_ACTIVE_FORCE,
 67860:   // Special layer that is metadata only.
105566:   LAYER_ACTIVE_EMPTY,
105566:   // Inactive style layer for rendering SVG effects.
105566:   LAYER_SVG_EFFECTS
101661: };
101652: 
104565: class RefCountedRegion : public RefCounted<RefCountedRegion> {
104565: public:
109155:   RefCountedRegion() : mIsInfinite(false) {}
104565:   nsRegion mRegion;
109155:   bool mIsInfinite;
104565: };
104565: 
 47736: /**
 47736:  * The FrameLayerBuilder belongs to an nsDisplayListBuilder and is
 47736:  * responsible for converting display lists into layer trees.
 47736:  * 
 47736:  * The most important API in this class is BuildContainerLayerFor. This
 47736:  * method takes a display list as input and constructs a ContainerLayer
 47736:  * with child layers that render the contents of the display list. It
 47736:  * also updates userdata for the retained layer manager, and
 47736:  * DisplayItemDataProperty data for frames, to record the relationship
 47736:  * between frames and layers.
 47736:  * 
 47736:  * That data enables us to retain layer trees. When constructing a
 47736:  * ContainerLayer, we first check to see if there's an existing
 47736:  * ContainerLayer for the same frame that can be recycled. If we recycle
 47736:  * it, we also try to reuse its existing ThebesLayer children to render
 47736:  * the display items without layers of their own. The idea is that by
 47736:  * recycling layers deterministically, we can ensure that when nothing
 47736:  * changes in a display list, we will reuse the existing layers without
 47736:  * changes.
 47736:  * 
 47736:  * We expose a GetLeafLayerFor method that can be called by display items
 47736:  * that make their own layers (e.g. canvas and video); this method
 47736:  * locates the last layer used to render the display item, if any, and
 47736:  * return it as a candidate for recycling.
 47736:  * 
 47736:  * FrameLayerBuilder sets up ThebesLayers so that 0,0 in the Thebes layer
 47736:  * corresponds to the (pixel-snapped) top-left of the aActiveScrolledRoot.
 47736:  * It sets up ContainerLayers so that 0,0 in the container layer
 47736:  * corresponds to the snapped top-left of the display list reference frame.
 72231:  *
 72231:  * When we construct a container layer, we know the transform that will be
 72231:  * applied to the layer. If the transform scales the content, we can get
 72231:  * better results when intermediate buffers are used by pushing some scale
 72231:  * from the container's transform down to the children. For ThebesLayer
 72231:  * children, the scaling can be achieved by changing the size of the layer
 72231:  * and drawing into it with increased or decreased resolution. By convention,
 72231:  * integer types (nsIntPoint/nsIntSize/nsIntRect/nsIntRegion) are all in layer
 72231:  * coordinates, post-scaling, whereas appunit types are all pre-scaling.
 47736:  */
103525: class FrameLayerBuilder {
 42525: public:
 54078:   typedef layers::ContainerLayer ContainerLayer;
 47736:   typedef layers::Layer Layer;
 47736:   typedef layers::ThebesLayer ThebesLayer;
 47736:   typedef layers::LayerManager LayerManager;
 47736: 
 53945:   FrameLayerBuilder() :
106838:     mRetainingManager(nullptr),
 80486:     mDetectedDOMModification(false),
106095:     mInvalidateAllLayers(false),
106095:     mContainerLayerGeneration(0),
106095:     mMaxContainerLayerGeneration(0)
 53945:   {
105568:     MOZ_COUNT_CTOR(FrameLayerBuilder);
 53945:     mNewDisplayItemData.Init();
 53945:     mThebesLayerItems.Init();
 53945:   }
105568:   ~FrameLayerBuilder()
105568:   {
105568:     MOZ_COUNT_DTOR(FrameLayerBuilder);
105568:   }
 42525: 
102920:   static void Shutdown();
102920: 
108884:   void Init(nsDisplayListBuilder* aBuilder, LayerManager* aManager);
 54261: 
 42525:   /**
 60857:    * Call this to notify that we have just started a transaction on the
 47771:    * retained layer manager aManager.
 47736:    */
 60857:   void DidBeginRetainedLayerTransaction(LayerManager* aManager);
 47736: 
 47736:   /**
 47771:    * Call this just before we end a transaction on aManager. If aManager
 47771:    * is not the retained layer manager then it must be a temporary layer
 47771:    * manager that will not be used again.
 47771:    */
103530:   void WillEndTransaction(LayerManager* aManager);
101681: 
101681:   /**
101681:    * Call this after we end a transaction on aManager. If aManager
101681:    * is not the retained layer manager then it must be a temporary layer
101681:    * manager that will not be used again.
101681:    */
103530:   void DidEndTransaction(LayerManager* aManager);
 47736: 
 72230:   struct ContainerParameters {
 72243:     ContainerParameters() :
 72243:       mXScale(1), mYScale(1),
 87082:       mInTransformedSubtree(false), mInActiveTransformedSubtree(false),
 87082:       mDisableSubpixelAntialiasingInDescendants(false)
 87082:     {}
 72231:     ContainerParameters(float aXScale, float aYScale) :
 72243:       mXScale(aXScale), mYScale(aYScale),
 87082:       mInTransformedSubtree(false), mInActiveTransformedSubtree(false),
 87082:       mDisableSubpixelAntialiasingInDescendants(false)
 87082:     {}
 72243:     ContainerParameters(float aXScale, float aYScale,
 72243:                         const ContainerParameters& aParent) :
 72243:       mXScale(aXScale), mYScale(aYScale),
 72243:       mInTransformedSubtree(aParent.mInTransformedSubtree),
 87082:       mInActiveTransformedSubtree(aParent.mInActiveTransformedSubtree),
 87082:       mDisableSubpixelAntialiasingInDescendants(aParent.mDisableSubpixelAntialiasingInDescendants)
 87082:     {}
 72231:     float mXScale, mYScale;
 72243:     bool mInTransformedSubtree;
 72243:     bool mInActiveTransformedSubtree;
 87082:     bool mDisableSubpixelAntialiasingInDescendants;
 95051:     /**
 95051:      * When this is false, ThebesLayer coordinates are drawn to with an integer
 95051:      * translation and the scale in mXScale/mYScale.
 95051:      */
 95051:     bool AllowResidualTranslation()
 95051:     {
 95051:       // If we're in a transformed subtree, but no ancestor transform is actively
 95051:       // changing, we'll use the residual translation when drawing into the
 95051:       // ThebesLayer to ensure that snapping exactly matches the ideal transform.
 95051:       return mInTransformedSubtree && !mInActiveTransformedSubtree;
 95051:     }
 72230:   };
 47736:   /**
 47736:    * Build a container layer for a display item that contains a child
 47736:    * list, either reusing an existing one or creating a new one. It
 47736:    * sets the container layer children to layers which together render
 47736:    * the contents of the display list. It reuses existing layers from
 47736:    * the retained layer manager if possible.
 42525:    * aContainer may be null, in which case we construct a root layer.
 47736:    * This gets called by display list code. It calls BuildLayer on the
 47736:    * items in the display list, making items with their own layers
 47736:    * children of the new container, and assigning all other items to
 47736:    * ThebesLayer children created and managed by the FrameLayerBuilder.
 47736:    * Returns a layer with clip rect cleared; it is the
 62985:    * caller's responsibility to add any clip rect. The visible region
 62985:    * is set based on what's in the layer.
 72230:    * The container layer is transformed by aTransform (if non-null), and
 72230:    * the result is transformed by the scale factors in aContainerParameters.
 42525:    */
 54078:   already_AddRefed<ContainerLayer>
 54078:   BuildContainerLayerFor(nsDisplayListBuilder* aBuilder,
 42525:                          LayerManager* aManager,
 47736:                          nsIFrame* aContainerFrame,
 47736:                          nsDisplayItem* aContainerItem,
 72230:                          const nsDisplayList& aChildren,
 72230:                          const ContainerParameters& aContainerParameters,
 72230:                          const gfx3DMatrix* aTransform);
 42525: 
 42525:   /**
 47736:    * Get a retained layer for a display item that needs to create its own
 47736:    * layer for rendering (i.e. under nsDisplayItem::BuildLayer). Returns
 47736:    * null if no retained layer is available, which usually means that this
 47736:    * display item didn't have a layer before so the caller will
 47736:    * need to create one.
 47736:    * Returns a layer with clip rect cleared; it is the
 47736:    * caller's responsibility to add any clip rect and set the visible
 47736:    * region.
 47731:    */
 47731:   Layer* GetLeafLayerFor(nsDisplayListBuilder* aBuilder,
103530:                          LayerManager* aManager,
 47731:                          nsDisplayItem* aItem);
 47731: 
 47731:   /**
103530:    * Call this during invalidation if aFrame has
103530:    * the NS_FRAME_HAS_CONTAINER_LAYER state bit. Only the nearest
103530:    * ancestor frame of the damaged frame that has
103530:    * NS_FRAME_HAS_CONTAINER_LAYER needs to be invalidated this way.
108264:    * It is assumed that aRect does NOT have the frame's transforms applied.
103530:    */
103530:   static void InvalidateThebesLayerContents(nsIFrame* aFrame,
103530:                                             const nsRect& aRect);
103530: 
103530:   /**
103530:    * For any descendant frame of aFrame (including across documents) that
103530:    * has an associated container layer, invalidate all the contents of
103530:    * all ThebesLayer children of the container. Useful when aFrame is
103530:    * being moved and we need to invalidate everything in aFrame's subtree.
103530:    */
103530:   static void InvalidateThebesLayersInSubtree(nsIFrame* aFrame);
103530: 
103530:   /**
107653:    * As InvalidateThebesLayersInSubtree, but don't trust frame geometry
107653:    * (e.g. because appunits-per-dev-pixel changed).
107653:    */
107653:   static void InvalidateThebesLayersInSubtreeWithUntrustedFrameGeometry(nsIFrame* aFrame);
107653: 
107653:   /**
 47736:    * Call this to force all retained layers to be discarded and recreated at
 47736:    * the next paint.
 47736:    */
 47736:   static void InvalidateAllLayers(LayerManager* aManager);
 47736: 
 47736:   /**
 47740:    * Call this to determine if a frame has a dedicated (non-Thebes) layer
 64542:    * for the given display item key. If there isn't one, we return null,
 64542:    * otherwise we return the layer.
 47740:    */
108991:   static Layer* GetDedicatedLayer(nsIFrame* aFrame, uint32_t aDisplayItemKey);
 47740: 
 47740:   /**
 42525:    * This callback must be provided to EndTransaction. The callback data
 42525:    * must be the nsDisplayListBuilder containing this FrameLayerBuilder.
103931:    * This function can be called multiple times in a row to draw
103931:    * different regions.
 42525:    */
 42525:   static void DrawThebesLayer(ThebesLayer* aLayer,
 42525:                               gfxContext* aContext,
 42525:                               const nsIntRegion& aRegionToDraw,
 47108:                               const nsIntRegion& aRegionToInvalidate,
 42525:                               void* aCallbackData);
 47736: 
 82351: #ifdef MOZ_DUMP_PAINTING
 47736:   /**
 47736:    * Dumps this FrameLayerBuilder's retained layer manager's retained
107692:    * layer tree. Defaults to dumping to stdout in non-HTML format.
 47736:    */
107692:   static void DumpRetainedLayerTree(LayerManager* aManager, FILE* aFile = stdout, bool aDumpHtml = false);
 47736: #endif
 47736: 
 47736:   /******* PRIVATE METHODS to FrameLayerBuilder.cpp ********/
 47736:   /* These are only in the public section because they need
 47736:    * to be called by file-scope helper functions in FrameLayerBuilder.cpp.
 47736:    */
 47736:   
 47736:   /**
 47736:    * Record aItem as a display item that is rendered by aLayer.
 47736:    */
 70037:   void AddLayerDisplayItem(Layer* aLayer,
 70037:                            nsDisplayItem* aItem,
103530:                            LayerState aLayerState);
 47736: 
 47736:   /**
 47736:    * Record aItem as a display item that is rendered by the ThebesLayer
 47736:    * aLayer, with aClipRect, where aContainerLayerFrame is the frame
 47736:    * for the container layer this ThebesItem belongs to.
 47736:    * aItem must have an underlying frame.
 47736:    */
103513:   struct Clip;
 47751:   void AddThebesDisplayItem(ThebesLayer* aLayer,
 47751:                             nsDisplayItem* aItem,
 52292:                             const Clip& aClip,
 47751:                             nsIFrame* aContainerLayerFrame,
 62293:                             LayerState aLayerState);
 47736: 
 47736:   /**
 47736:    * Given a frame and a display item key that uniquely identifies a
 47736:    * display item for the frame, find the layer that was last used to
 47736:    * render that display item. Returns null if there is no such layer.
 47736:    * This could be a dedicated layer for the display item, or a ThebesLayer
 47736:    * that renders many display items.
 47736:    */
109563:   Layer* GetOldLayerFor(nsIFrame* aFrame, uint32_t aDisplayItemKey);
101655: 
108991:   static Layer* GetDebugOldLayerFor(nsIFrame* aFrame, uint32_t aDisplayItemKey);
 51947:   /**
 51947:    * Try to determine whether the ThebesLayer aLayer paints an opaque
 51947:    * single color everywhere it's visible in aRect.
 51947:    * If successful, return that color, otherwise return NS_RGBA(0,0,0,0).
 51947:    */
 51947:   nscolor FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
 51947:                                   ThebesLayer* aLayer, const nsRect& aRect);
 51947: 
 52292:   /**
 79931:    * Destroy any stored LayerManagerDataProperty and the associated data for
 79931:    * aFrame.
 54309:    */
103523:   static void DestroyDisplayItemDataFor(nsIFrame* aFrame)
103523:   {
103523:     aFrame->Properties().Delete(LayerManagerDataProperty());
103523:   }
 54309: 
 62289:   LayerManager* GetRetainingLayerManager() { return mRetainingManager; }
 62289: 
 62289:   /**
 62289:    * Returns true if the given item (which we assume here is
 62289:    * background-attachment:fixed) needs to be repainted as we scroll in its
 62289:    * document.
 62289:    * Returns false if it doesn't need to be repainted because the layer system
 62289:    * is ensuring its fixed-ness for us.
 62289:    */
 79445:   static bool NeedToInvalidateFixedDisplayItem(nsDisplayListBuilder* aBuilder,
 62289:                                                  nsDisplayItem* aItem);
 62289: 
 62289:   /**
 62289:    * Returns true if the given display item was rendered directly
 62289:    * into a retained layer.
 62289:    * Returns false if it was rendered into a temporary layer manager and then
 62289:    * into a retained layer.
 62289:    */
108991:   static bool HasRetainedLayerFor(nsIFrame* aFrame, uint32_t aDisplayItemKey);
 62289: 
 54309:   /**
 70022:    * Save transform that was in aLayer when we last painted. It must be an integer
 70022:    * translation.
 69962:    */
 70022:   void SaveLastPaintOffset(ThebesLayer* aLayer);
 69962:   /**
 70022:    * Get the translation transform that was in aLayer when we last painted. It's either
 69962:    * the transform saved by SaveLastPaintTransform, or else the transform
 70022:    * that's currently in the layer (which must be an integer translation).
 69962:    */
 70022:   nsIntPoint GetLastPaintOffset(ThebesLayer* aLayer);
 69962: 
 69962:   /**
107527:    * Return the resolution at which we expect to render aFrame's contents,
107527:    * assuming they are being painted to retained layers. This takes into account
107527:    * the resolution the contents of the ContainerLayer containing aFrame are
107527:    * being rendered at, as well as any currently-inactive transforms between
107527:    * aFrame and that container layer.
 98192:    */
107527:   static gfxSize GetThebesLayerScaleForFrame(nsIFrame* aFrame);
 98192: 
 98192:   /**
 52292:    * Clip represents the intersection of an optional rectangle with a
 52292:    * list of rounded rectangles.
 52292:    */
 52292:   struct Clip {
 52292:     struct RoundedRect {
 52292:       nsRect mRect;
 52292:       // Indices into mRadii are the NS_CORNER_* constants in nsStyleConsts.h
 52292:       nscoord mRadii[8];
 52292: 
 52292:       bool operator==(const RoundedRect& aOther) const {
 68638:         if (!mRect.IsEqualInterior(aOther.mRect)) {
 52292:           return false;
 52292:         }
 52292: 
 52292:         NS_FOR_CSS_HALF_CORNERS(corner) {
 52292:           if (mRadii[corner] != aOther.mRadii[corner]) {
 52292:             return false;
 52292:           }
 52292:         }
 52292:         return true;
 52292:       }
 52292:       bool operator!=(const RoundedRect& aOther) const {
 52292:         return !(*this == aOther);
 52292:       }
 52292:     };
 52292:     nsRect mClipRect;
 52292:     nsTArray<RoundedRect> mRoundedClipRects;
 79445:     bool mHaveClipRect;
 52292: 
 80486:     Clip() : mHaveClipRect(false) {}
 52292: 
 52292:     // Construct as the intersection of aOther and aClipItem.
 52292:     Clip(const Clip& aOther, nsDisplayItem* aClipItem);
 52292: 
 52292:     // Apply this |Clip| to the given gfxContext.  Any saving of state
 52292:     // or clearing of other clips must be done by the caller.
 97433:     // See aBegin/aEnd note on ApplyRoundedRectsTo.
 97433:     void ApplyTo(gfxContext* aContext, nsPresContext* aPresContext,
108991:                  uint32_t aBegin = 0, uint32_t aEnd = PR_UINT32_MAX);
 97433: 
108991:     void ApplyRectTo(gfxContext* aContext, int32_t A2D) const;
 97433:     // Applies the rounded rects in this Clip to aContext
 97433:     // Will only apply rounded rects from aBegin (inclusive) to aEnd
 97433:     // (exclusive) or the number of rounded rects, whichever is smaller.
108991:     void ApplyRoundedRectsTo(gfxContext* aContext, int32_t A2DPRInt32,
108991:                              uint32_t aBegin, uint32_t aEnd) const;
 52292: 
 99572:     // Draw (fill) the rounded rects in this clip to aContext
108991:     void DrawRoundedRectsTo(gfxContext* aContext, int32_t A2D,
108991:                             uint32_t aBegin, uint32_t aEnd) const;
 99572:     // 'Draw' (create as a path, does not stroke or fill) aRoundRect to aContext
108991:     void AddRoundedRectPathTo(gfxContext* aContext, int32_t A2D,
 99572:                               const RoundedRect &aRoundRect) const;
 99572: 
 59779:     // Return a rectangle contained in the intersection of aRect with this
 59779:     // clip region. Tries to return the largest possible rectangle, but may
 59779:     // not succeed.
 59779:     nsRect ApproximateIntersect(const nsRect& aRect) const;
 59779: 
 61322:     // Returns false if aRect is definitely not clipped by a rounded corner in
 61322:     // this clip. Returns true if aRect is clipped by a rounded corner in this
 61322:     // clip or it can not be quickly determined that it is not clipped by a
 61322:     // rounded corner in this clip.
 61322:     bool IsRectClippedByRoundedCorner(const nsRect& aRect) const;
 61322: 
 61322:     // Intersection of all rects in this clip ignoring any rounded corners.
 61322:     nsRect NonRoundedIntersection() const;
 61322: 
 61322:     // Gets rid of any rounded corners in this clip.
 61322:     void RemoveRoundedCorners();
 61322: 
 52292:     bool operator==(const Clip& aOther) const {
 52292:       return mHaveClipRect == aOther.mHaveClipRect &&
 68638:              (!mHaveClipRect || mClipRect.IsEqualInterior(aOther.mClipRect)) &&
 52292:              mRoundedClipRects == aOther.mRoundedClipRects;
 52292:     }
 52292:     bool operator!=(const Clip& aOther) const {
 52292:       return !(*this == aOther);
 52292:     }
 52292:   };
 52292: 
 47736: protected:
 47736:   /**
 47736:    * We store an array of these for each frame that is associated with
 47736:    * one or more retained layers. Each DisplayItemData records the layer
 47736:    * used to render one of the frame's display items.
 47736:    */
 47736:   class DisplayItemData {
 47736:   public:
108991:     DisplayItemData(Layer* aLayer, uint32_t aKey, LayerState aLayerState, uint32_t aGeneration);
108884:     ~DisplayItemData();
 47736: 
 47736:     nsRefPtr<Layer> mLayer;
108991:     uint32_t        mDisplayItemKey;
108991:     uint32_t        mContainerLayerGeneration;
 70037:     LayerState      mLayerState;
 47736:   };
 47736: 
103523:   static void RemoveFrameFromLayerManager(nsIFrame* aFrame, void* aPropertyValue);
103302: 
103523:   NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR(LayerManagerDataProperty,
103523:                                                RemoveFrameFromLayerManager)
101661: 
 47736:   /**
 47736:    * We accumulate DisplayItemData elements in a hashtable during
 47736:    * the paint process, and store them in the frame property only when
 47736:    * paint is complete. This is the hashentry for that hashtable.
 47736:    */
 47736:   class DisplayItemDataEntry : public nsPtrHashKey<nsIFrame> {
 47736:   public:
109150:     DisplayItemDataEntry(const nsIFrame *key)
109150:       : nsPtrHashKey<nsIFrame>(key)
109150:       , mIsSharingContainerLayer(false)
109150:       {}
109150:     DisplayItemDataEntry(DisplayItemDataEntry &toCopy)
109150:       : nsPtrHashKey<nsIFrame>(toCopy.mKey)
109150:       , mIsSharingContainerLayer(toCopy.mIsSharingContainerLayer)
 47736:     {
 79931:       // This isn't actually a copy-constructor; notice that it steals toCopy's
104565:       // array and invalid region.  Be careful.
 79931:       mData.SwapElements(toCopy.mData);
104565:       mInvalidRegion.swap(toCopy.mInvalidRegion);
106095:       mContainerLayerGeneration = toCopy.mContainerLayerGeneration;
 47736:     }
 47736: 
 79445:     bool HasNonEmptyContainerLayer();
 47736: 
 79931:     nsAutoTArray<DisplayItemData, 1> mData;
104565:     nsRefPtr<RefCountedRegion> mInvalidRegion;
108991:     uint32_t mContainerLayerGeneration;
103531:     bool mIsSharingContainerLayer;
 47736: 
 79931:     enum { ALLOW_MEMMOVE = false };
 47736:   };
 47736: 
103523:   // LayerManagerData needs to see DisplayItemDataEntry.
103523:   friend class LayerManagerData;
103523: 
 82255:   // Flash the area within the context clip if paint flashing is enabled.
 82255:   static void FlashPaint(gfxContext *aContext);
 82255: 
 79931:   /*
 79931:    * Get the DisplayItemData array associated with this frame, or null if one
 79931:    * doesn't exist.
 79931:    *
 79931:    * Note that the pointer returned here is only valid so long as you don't
 79931:    * poke the LayerManagerData's mFramesWithLayers hashtable.
 79931:    */
103530:   static nsTArray<DisplayItemData>* GetDisplayItemDataArrayForFrame(nsIFrame *aFrame);
 79931: 
 79931:   /**
 79931:    * A useful hashtable iteration function that removes the
 79931:    * DisplayItemData property for the frame, clears its
 79931:    * NS_FRAME_HAS_CONTAINER_LAYER bit and returns PL_DHASH_REMOVE.
 79931:    * aClosure is ignored.
 79931:    */
 79931:   static PLDHashOperator RemoveDisplayItemDataForFrame(DisplayItemDataEntry* aEntry,
103530:                                                        void* aClosure)
103530:   {
106838:     return UpdateDisplayItemDataForFrame(aEntry, nullptr);
103530:   }
 79931: 
 47736:   /**
 47736:    * We store one of these for each display item associated with a
 47736:    * ThebesLayer, in a hashtable that maps each ThebesLayer to an array
 47736:    * of ClippedDisplayItems. (ThebesLayerItemsEntry is the hash entry
 47736:    * for that hashtable.)
 47736:    * These are only stored during the paint process, so that the
 47736:    * DrawThebesLayer callback can figure out which items to draw for the
 47736:    * ThebesLayer.
 47736:    * mItem always has an underlying frame.
 47736:    */
 47736:   struct ClippedDisplayItem {
108991:     ClippedDisplayItem(nsDisplayItem* aItem, const Clip& aClip, uint32_t aGeneration)
106095:       : mItem(aItem), mClip(aClip), mContainerLayerGeneration(aGeneration)
 47736:     {
 47736:     }
 47736: 
 47736:     nsDisplayItem* mItem;
 52292:     Clip mClip;
108991:     uint32_t mContainerLayerGeneration;
103530:     bool mInactiveLayer;
 47736:   };
 47736: 
 47736:   /**
 47736:    * We accumulate ClippedDisplayItem elements in a hashtable during
 47736:    * the paint process. This is the hashentry for that hashtable.
 47736:    */
 97433: public:
 47736:   class ThebesLayerItemsEntry : public nsPtrHashKey<ThebesLayer> {
 47736:   public:
 69962:     ThebesLayerItemsEntry(const ThebesLayer *key) :
106838:         nsPtrHashKey<ThebesLayer>(key), mContainerLayerFrame(nullptr),
 98444:         mHasExplicitLastPaintOffset(false), mCommonClipCount(0) {}
 47736:     ThebesLayerItemsEntry(const ThebesLayerItemsEntry &toCopy) :
 47736:       nsPtrHashKey<ThebesLayer>(toCopy.mKey), mItems(toCopy.mItems)
 47736:     {
 47736:       NS_ERROR("Should never be called, since we ALLOW_MEMMOVE");
 47736:     }
 47736: 
 47736:     nsTArray<ClippedDisplayItem> mItems;
 47736:     nsIFrame* mContainerLayerFrame;
 70022:     // The translation set on this ThebesLayer before we started updating the
 69962:     // layer tree.
 70022:     nsIntPoint mLastPaintOffset;
108991:     uint32_t mContainerLayerGeneration;
 79445:     bool mHasExplicitLastPaintOffset;
 97433:     /**
 97433:       * The first mCommonClipCount rounded rectangle clips are identical for
 97433:       * all items in the layer. Computed in ThebesLayerData.
 97433:       */
108991:     uint32_t mCommonClipCount;
 47736: 
 80486:     enum { ALLOW_MEMMOVE = true };
 47736:   };
 47736: 
 97433:   /**
 97433:    * Get the ThebesLayerItemsEntry object associated with aLayer in this
 97433:    * FrameLayerBuilder
 97433:    */
 97433:   ThebesLayerItemsEntry* GetThebesLayerItemsEntry(ThebesLayer* aLayer)
 97433:   {
 97433:     return mThebesLayerItems.GetEntry(aLayer);
 97433:   }
 97433: 
 97433: protected:
 47736:   void RemoveThebesItemsForLayerSubtree(Layer* aLayer);
 47736: 
104565:   static void SetAndClearInvalidRegion(DisplayItemDataEntry* aEntry);
 79931:   static PLDHashOperator UpdateDisplayItemDataForFrame(DisplayItemDataEntry* aEntry,
 47736:                                                        void* aUserArg);
 47736:   static PLDHashOperator StoreNewDisplayItemData(DisplayItemDataEntry* aEntry,
 47736:                                                  void* aUserArg);
106095:   static PLDHashOperator RestoreDisplayItemData(DisplayItemDataEntry* aEntry,
106095:                                                 void *aUserArg);
106095: 
106095:   static PLDHashOperator RestoreThebesLayerItemEntries(ThebesLayerItemsEntry* aEntry,
106095:                                                        void *aUserArg);
 47736: 
 47736:   /**
 54261:    * Returns true if the DOM has been modified since we started painting,
 54261:    * in which case we should bail out and not paint anymore. This should
 54261:    * never happen, but plugins can trigger it in some cases.
 54261:    */
 79445:   bool CheckDOMModified();
 54261: 
 54261:   /**
 47736:    * The layer manager belonging to the widget that is being retained
 47736:    * across paints.
 47736:    */
 47736:   LayerManager*                       mRetainingManager;
 47736:   /**
 54261:    * The root prescontext for the display list builder reference frame
 54261:    */
 54261:   nsRootPresContext*                  mRootPresContext;
 54261:   /**
 47736:    * A map from frames to a list of (display item key, layer) pairs that
 47736:    * describes what layers various parts of the frame are assigned to.
 47736:    */
 47736:   nsTHashtable<DisplayItemDataEntry>  mNewDisplayItemData;
 47736:   /**
 47736:    * A map from ThebesLayers to the list of display items (plus
 47736:    * clipping data) to be rendered in the layer.
 47736:    */
 47736:   nsTHashtable<ThebesLayerItemsEntry> mThebesLayerItems;
 47736:   /**
 54261:    * Saved generation counter so we can detect DOM changes.
 54261:    */
108991:   uint32_t                            mInitialDOMGeneration;
 54261:   /**
 54261:    * Set to true if we have detected and reported DOM modification during
 54261:    * the current paint.
 54261:    */
 79445:   bool                                mDetectedDOMModification;
 54261:   /**
 47736:    * Indicates that the entire layer tree should be rerendered
 47736:    * during this paint.
 47736:    */
 79445:   bool                                mInvalidateAllLayers;
106095: 
108991:   uint32_t                            mContainerLayerGeneration;
108991:   uint32_t                            mMaxContainerLayerGeneration;
 42525: };
 42525: 
 42525: }
 42525: 
 42525: #endif /* FRAMELAYERBUILDER_H_ */
