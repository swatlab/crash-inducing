     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: // vim:cindent:ts=2:et:sw=2:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* utility functions for drawing borders and backgrounds */
     1: 
     1: #include "nsStyleConsts.h"
     1: #include "nsPresContext.h"
     1: #include "nsIFrame.h"
     1: #include "nsPoint.h"
     1: #include "nsRect.h"
     1: #include "nsIViewManager.h"
     1: #include "nsIPresShell.h"
     1: #include "nsFrameManager.h"
     1: #include "nsStyleContext.h"
     1: #include "nsGkAtoms.h"
 15204: #include "nsCSSAnonBoxes.h"
     1: #include "nsTransform2D.h"
     1: #include "nsIContent.h"
     1: #include "nsIDocument.h"
     1: #include "nsIScrollableFrame.h"
     1: #include "imgIRequest.h"
     1: #include "imgIContainer.h"
     1: #include "nsCSSRendering.h"
     1: #include "nsCSSColorUtils.h"
     1: #include "nsITheme.h"
     1: #include "nsThemeConstants.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsINameSpaceManager.h"
 12360: #include "nsBlockFrame.h"
     1: #include "gfxContext.h"
 93575: #include "nsRenderingContext.h"
 15992: #include "nsIInterfaceRequestorUtils.h"
 15992: #include "gfxPlatform.h"
 15992: #include "gfxImageSurface.h"
 15992: #include "nsStyleStructInlines.h"
 16509: #include "nsCSSFrameConstructor.h"
 40180: #include "nsCSSProps.h"
 50427: #include "nsContentUtils.h"
 50427: #include "nsSVGEffects.h"
 50427: #include "nsSVGIntegrationUtils.h"
 50427: #include "gfxDrawable.h"
 96794: #include "sampler.h"
 16150: #include "nsCSSRenderingBorders.h"
     1: 
 71171: using namespace mozilla;
 71171: 
     1: // To avoid storing this data on nsInlineFrame (bloat) and to avoid
     1: // recalculating this for each frame in a continuation (perf), hold
     1: // a cache of various coordinate information that we need in order
     1: // to paint inline backgrounds.
     1: struct InlineBackgroundData
     1: {
     1:   InlineBackgroundData()
 12360:       : mFrame(nsnull), mBlockFrame(nsnull)
     1:   {
     1:   }
     1: 
     1:   ~InlineBackgroundData()
     1:   {
     1:   }
     1: 
     1:   void Reset()
     1:   {
     1:     mBoundingBox.SetRect(0,0,0,0);
 12360:     mContinuationPoint = mLineContinuationPoint = mUnbrokenWidth = 0;
 12360:     mFrame = mBlockFrame = nsnull;
     1:   }
     1: 
     1:   nsRect GetContinuousRect(nsIFrame* aFrame)
     1:   {
     1:     SetFrame(aFrame);
     1: 
 12360:     nscoord x;
 12360:     if (mBidiEnabled) {
 12360:       x = mLineContinuationPoint;
 12360: 
 12360:       // Scan continuations on the same line as aFrame and accumulate the widths
 12360:       // of frames that are to the left (if this is an LTR block) or right
 12360:       // (if it's RTL) of the current one.
 79445:       bool isRtlBlock = (mBlockFrame->GetStyleVisibility()->mDirection ==
 12360:                            NS_STYLE_DIRECTION_RTL);
 12360:       nscoord curOffset = aFrame->GetOffsetTo(mBlockFrame).x;
 12360: 
 25816:       // No need to use our GetPrevContinuation/GetNextContinuation methods
 25816:       // here, since ib special siblings are certainly not on the same line.
 25816: 
 12360:       nsIFrame* inlineFrame = aFrame->GetPrevContinuation();
 12360:       // If the continuation is fluid we know inlineFrame is not on the same line.
 25816:       // If it's not fluid, we need to test further to be sure.
 12360:       while (inlineFrame && !inlineFrame->GetNextInFlow() &&
 12360:              AreOnSameLine(aFrame, inlineFrame)) {
 12360:         nscoord frameXOffset = inlineFrame->GetOffsetTo(mBlockFrame).x;
 12360:         if(isRtlBlock == (frameXOffset >= curOffset)) {
 12360:           x += inlineFrame->GetSize().width;
 12360:         }
 12360:         inlineFrame = inlineFrame->GetPrevContinuation();
 12360:       }
 12360: 
 12360:       inlineFrame = aFrame->GetNextContinuation();
 12360:       while (inlineFrame && !inlineFrame->GetPrevInFlow() &&
 12360:              AreOnSameLine(aFrame, inlineFrame)) {
 12360:         nscoord frameXOffset = inlineFrame->GetOffsetTo(mBlockFrame).x;
 12360:         if(isRtlBlock == (frameXOffset >= curOffset)) {
 12360:           x += inlineFrame->GetSize().width;
 12360:         }
 12360:         inlineFrame = inlineFrame->GetNextContinuation();
 12360:       }
 12360:       if (isRtlBlock) {
 12360:         // aFrame itself is also to the right of its left edge, so add its width.
 12360:         x += aFrame->GetSize().width;
 12360:         // x is now the distance from the left edge of aFrame to the right edge
 12360:         // of the unbroken content. Change it to indicate the distance from the
 12360:         // left edge of the unbroken content to the left edge of aFrame.
 12360:         x = mUnbrokenWidth - x;
 12360:       }
 12360:     } else {
 12360:       x = mContinuationPoint;
 12360:     }
 12360: 
     1:     // Assume background-origin: border and return a rect with offsets
     1:     // relative to (0,0).  If we have a different background-origin,
     1:     // then our rect should be deflated appropriately by our caller.
 12360:     return nsRect(-x, 0, mUnbrokenWidth, mFrame->GetSize().height);
     1:   }
     1: 
     1:   nsRect GetBoundingRect(nsIFrame* aFrame)
     1:   {
     1:     SetFrame(aFrame);
     1: 
     1:     // Move the offsets relative to (0,0) which puts the bounding box into
     1:     // our coordinate system rather than our parent's.  We do this by
     1:     // moving it the back distance from us to the bounding box.
     1:     // This also assumes background-origin: border, so our caller will
     1:     // need to deflate us if needed.
     1:     nsRect boundingBox(mBoundingBox);
     1:     nsPoint point = mFrame->GetPosition();
     1:     boundingBox.MoveBy(-point.x, -point.y);
     1: 
     1:     return boundingBox;
     1:   }
     1: 
     1: protected:
     1:   nsIFrame*     mFrame;
 28329:   nsBlockFrame* mBlockFrame;
 28329:   nsRect        mBoundingBox;
     1:   nscoord       mContinuationPoint;
     1:   nscoord       mUnbrokenWidth;
 28329:   nscoord       mLineContinuationPoint;
 79445:   bool          mBidiEnabled;
 12360: 
     1:   void SetFrame(nsIFrame* aFrame)
     1:   {
     1:     NS_PRECONDITION(aFrame, "Need a frame");
     1: 
 25816:     nsIFrame *prevContinuation = GetPrevContinuation(aFrame);
 10087: 
 10087:     if (!prevContinuation || mFrame != prevContinuation) {
     1:       // Ok, we've got the wrong frame.  We have to start from scratch.
     1:       Reset();
     1:       Init(aFrame);
     1:       return;
     1:     }
     1: 
     1:     // Get our last frame's size and add its width to our continuation
     1:     // point before we cache the new frame.
     1:     mContinuationPoint += mFrame->GetSize().width;
     1: 
 12360:     // If this a new line, update mLineContinuationPoint.
 12360:     if (mBidiEnabled &&
 12360:         (aFrame->GetPrevInFlow() || !AreOnSameLine(mFrame, aFrame))) {
 12360:        mLineContinuationPoint = mContinuationPoint;
 12360:     }
 12360: 
     1:     mFrame = aFrame;
     1:   }
     1: 
 25816:   nsIFrame* GetPrevContinuation(nsIFrame* aFrame)
 25816:   {
 25816:     nsIFrame* prevCont = aFrame->GetPrevContinuation();
 27334:     if (!prevCont && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
 39965:       nsIFrame* block = static_cast<nsIFrame*>
 39965:         (aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 25816:       if (block) {
 25816:         // The {ib} properties are only stored on first continuations
 34459:         NS_ASSERTION(!block->GetPrevContinuation(),
 34459:                      "Incorrect value for IBSplitSpecialPrevSibling");
 39965:         prevCont = static_cast<nsIFrame*>
 39965:           (block->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
 25816:         NS_ASSERTION(prevCont, "How did that happen?");
 25816:       }
 25816:     }
 25816:     return prevCont;
 25816:   }
 25816: 
 25816:   nsIFrame* GetNextContinuation(nsIFrame* aFrame)
 25816:   {
 25816:     nsIFrame* nextCont = aFrame->GetNextContinuation();
 27334:     if (!nextCont && (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) {
 25816:       // The {ib} properties are only stored on first continuations
 25816:       aFrame = aFrame->GetFirstContinuation();
 39965:       nsIFrame* block = static_cast<nsIFrame*>
 39965:         (aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
 25816:       if (block) {
 39965:         nextCont = static_cast<nsIFrame*>
 39965:           (block->Properties().Get(nsIFrame::IBSplitSpecialSibling()));
 25816:         NS_ASSERTION(nextCont, "How did that happen?");
 25816:       }
 25816:     }
 25816:     return nextCont;
 25816:   }
 25816: 
     1:   void Init(nsIFrame* aFrame)
     1:   {
     1:     // Start with the previous flow frame as our continuation point
     1:     // is the total of the widths of the previous frames.
 25816:     nsIFrame* inlineFrame = GetPrevContinuation(aFrame);
     1: 
     1:     while (inlineFrame) {
     1:       nsRect rect = inlineFrame->GetRect();
     1:       mContinuationPoint += rect.width;
     1:       mUnbrokenWidth += rect.width;
     1:       mBoundingBox.UnionRect(mBoundingBox, rect);
 25816:       inlineFrame = GetPrevContinuation(inlineFrame);
     1:     }
     1: 
     1:     // Next add this frame and subsequent frames to the bounding box and
     1:     // unbroken width.
     1:     inlineFrame = aFrame;
     1:     while (inlineFrame) {
     1:       nsRect rect = inlineFrame->GetRect();
     1:       mUnbrokenWidth += rect.width;
     1:       mBoundingBox.UnionRect(mBoundingBox, rect);
 25816:       inlineFrame = GetNextContinuation(inlineFrame);
     1:     }
     1: 
     1:     mFrame = aFrame;
 12360: 
 12360:     mBidiEnabled = aFrame->PresContext()->BidiEnabled();
 12360:     if (mBidiEnabled) {
 12360:       // Find the containing block frame
 12360:       nsIFrame* frame = aFrame;
 23554:       do {
 12360:         frame = frame->GetParent();
 23554:         mBlockFrame = do_QueryFrame(frame);
 12360:       }
 23554:       while (frame && frame->IsFrameOfType(nsIFrame::eLineParticipant));
 23554: 
 23554:       NS_ASSERTION(mBlockFrame, "Cannot find containing block.");
 12360: 
 12360:       mLineContinuationPoint = mContinuationPoint;
 12360:     }
 12360:   }
 12360: 
 79445:   bool AreOnSameLine(nsIFrame* aFrame1, nsIFrame* aFrame2) {
 79445:     bool isValid1, isValid2;
 12360:     nsBlockInFlowLineIterator it1(mBlockFrame, aFrame1, &isValid1);
 12360:     nsBlockInFlowLineIterator it2(mBlockFrame, aFrame2, &isValid2);
 72525:     return isValid1 && isValid2 &&
 72525:       // Make sure aFrame1 and aFrame2 are in the same continuation of
 72525:       // mBlockFrame.
 72525:       it1.GetContainer() == it2.GetContainer() &&
 72525:       // And on the same line in it
 72525:       it1.GetLine() == it2.GetLine();
     1:   }
     1: };
     1: 
 19707: /* Local functions */
 19707: static void DrawBorderImage(nsPresContext* aPresContext,
 68481:                             nsRenderingContext& aRenderingContext,
 19707:                             nsIFrame* aForFrame,
 19707:                             const nsRect& aBorderArea,
 34849:                             const nsStyleBorder& aStyleBorder,
 25017:                             const nsRect& aDirtyRect);
 19707: 
 68481: static void DrawBorderImageComponent(nsRenderingContext& aRenderingContext,
 26926:                                      nsIFrame* aForFrame,
 30479:                                      imgIContainer* aImage,
 25017:                                      const nsRect& aDirtyRect,
 25017:                                      const nsRect& aFill,
 25017:                                      const nsIntRect& aSrc,
 25017:                                      PRUint8 aHFill,
 25017:                                      PRUint8 aVFill,
 34849:                                      const nsSize& aUnitSize,
 34849:                                      const nsStyleBorder& aStyleBorder,
 34849:                                      PRUint8 aIndex);
 19707: 
 41419: static nscolor MakeBevelColor(mozilla::css::Side whichSide, PRUint8 style,
 19707:                               nscolor aBackgroundColor,
 19707:                               nscolor aBorderColor);
 19707: 
     1: static InlineBackgroundData* gInlineBGData = nsnull;
     1: 
     1: // Initialize any static variables used by nsCSSRendering.
 71172: void nsCSSRendering::Init()
     1: {
     1:   NS_ASSERTION(!gInlineBGData, "Init called twice");
     1:   gInlineBGData = new InlineBackgroundData();
     1: }
     1: 
     1: // Clean up any global variables used by nsCSSRendering.
     1: void nsCSSRendering::Shutdown()
     1: {
     1:   delete gInlineBGData;
     1:   gInlineBGData = nsnull;
     1: }
     1: 
     1: /**
     1:  * Make a bevel color
     1:  */
 19707: static nscolor
 41419: MakeBevelColor(mozilla::css::Side whichSide, PRUint8 style,
 19707:                nscolor aBackgroundColor, nscolor aBorderColor)
     1: {
     1: 
     1:   nscolor colors[2];
     1:   nscolor theColor;
     1: 
     1:   // Given a background color and a border color
     1:   // calculate the color used for the shading
     1:   NS_GetSpecial3DColors(colors, aBackgroundColor, aBorderColor);
     1: 
     1:   if ((style == NS_STYLE_BORDER_STYLE_OUTSET) ||
     1:       (style == NS_STYLE_BORDER_STYLE_RIDGE)) {
     1:     // Flip colors for these two border styles
     1:     switch (whichSide) {
     1:     case NS_SIDE_BOTTOM: whichSide = NS_SIDE_TOP;    break;
     1:     case NS_SIDE_RIGHT:  whichSide = NS_SIDE_LEFT;   break;
     1:     case NS_SIDE_TOP:    whichSide = NS_SIDE_BOTTOM; break;
     1:     case NS_SIDE_LEFT:   whichSide = NS_SIDE_RIGHT;  break;
     1:     }
     1:   }
     1: 
     1:   switch (whichSide) {
     1:   case NS_SIDE_BOTTOM:
     1:     theColor = colors[1];
     1:     break;
     1:   case NS_SIDE_RIGHT:
     1:     theColor = colors[1];
     1:     break;
     1:   case NS_SIDE_TOP:
     1:     theColor = colors[0];
     1:     break;
     1:   case NS_SIDE_LEFT:
     1:   default:
     1:     theColor = colors[0];
     1:     break;
     1:   }
     1:   return theColor;
     1: }
     1: 
   947: //----------------------------------------------------------------------
   947: // Thebes Border Rendering Code Start
   947: 
  3608: /*
  3608:  * Compute the float-pixel radii that should be used for drawing
  3608:  * this border/outline, given the various input bits.
  3608:  */
 52134: /* static */ void
 52134: nsCSSRendering::ComputePixelRadii(const nscoord *aAppUnitsRadii,
 52134:                                   nscoord aAppUnitsPerPixel,
 16150:                                   gfxCornerSizes *oBorderRadii)
  3608: {
 20039:   gfxFloat radii[8];
 20039:   NS_FOR_CSS_HALF_CORNERS(corner)
 52134:     radii[corner] = gfxFloat(aAppUnitsRadii[corner]) / aAppUnitsPerPixel;
 20039: 
 20039:   (*oBorderRadii)[C_TL] = gfxSize(radii[NS_CORNER_TOP_LEFT_X],
 20039:                                   radii[NS_CORNER_TOP_LEFT_Y]);
 20039:   (*oBorderRadii)[C_TR] = gfxSize(radii[NS_CORNER_TOP_RIGHT_X],
 20039:                                   radii[NS_CORNER_TOP_RIGHT_Y]);
 20039:   (*oBorderRadii)[C_BR] = gfxSize(radii[NS_CORNER_BOTTOM_RIGHT_X],
 20039:                                   radii[NS_CORNER_BOTTOM_RIGHT_Y]);
 20039:   (*oBorderRadii)[C_BL] = gfxSize(radii[NS_CORNER_BOTTOM_LEFT_X],
 20039:                                   radii[NS_CORNER_BOTTOM_LEFT_Y]);
  1972: }
  1972: 
   947: void
   947: nsCSSRendering::PaintBorder(nsPresContext* aPresContext,
 68481:                             nsRenderingContext& aRenderingContext,
     1:                             nsIFrame* aForFrame,
     1:                             const nsRect& aDirtyRect,
     1:                             const nsRect& aBorderArea,
 40180:                             nsStyleContext* aStyleContext,
 40180:                             PRIntn aSkipSides)
 40180: {
 96794:   SAMPLE_LABEL("nsCSSRendering", "PaintBorder");
 40180:   nsStyleContext *styleIfVisited = aStyleContext->GetStyleIfVisited();
 40180:   const nsStyleBorder *styleBorder = aStyleContext->GetStyleBorder();
 40180:   // Don't check RelevantLinkVisited here, since we want to take the
 40180:   // same amount of time whether or not it's true.
 40180:   if (!styleIfVisited) {
 40180:     PaintBorderWithStyleBorder(aPresContext, aRenderingContext, aForFrame,
 40180:                                aDirtyRect, aBorderArea, *styleBorder,
 40180:                                aStyleContext, aSkipSides);
 40180:     return;
 40180:   }
 40180: 
 40180:   nsStyleBorder newStyleBorder(*styleBorder);
 52148:   // We're making an ephemeral stack copy here, so just copy this debug-only
 52148:   // member to prevent assertions.
 52148: #ifdef DEBUG
 52148:   newStyleBorder.mImageTracked = styleBorder->mImageTracked;
 52148: #endif
 52148: 
 40180:   NS_FOR_CSS_SIDES(side) {
 40180:     newStyleBorder.SetBorderColor(side,
 40180:       aStyleContext->GetVisitedDependentColor(
 40180:         nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color)[side]));
 40180:   }
 40180:   PaintBorderWithStyleBorder(aPresContext, aRenderingContext, aForFrame,
 40180:                              aDirtyRect, aBorderArea, newStyleBorder,
 40180:                              aStyleContext, aSkipSides);
 52148: 
 52148: #ifdef DEBUG
 52148:   newStyleBorder.mImageTracked = false;
 52148: #endif
 40180: }
 40180: 
 40180: void
 40180: nsCSSRendering::PaintBorderWithStyleBorder(nsPresContext* aPresContext,
 68481:                                            nsRenderingContext& aRenderingContext,
 40180:                                            nsIFrame* aForFrame,
 40180:                                            const nsRect& aDirtyRect,
 40180:                                            const nsRect& aBorderArea,
 34849:                                            const nsStyleBorder& aStyleBorder,
     1:                                            nsStyleContext* aStyleContext,
 16424:                                            PRIntn aSkipSides)
     1: {
     1:   nsMargin            border;
 20039:   nscoord             twipsRadii[8];
     1:   nsCompatibility     compatMode = aPresContext->CompatibilityMode();
   947: 
   947:   SN("++ PaintBorder");
     1: 
     1:   // Check to see if we have an appearance defined.  If so, we let the theme
     1:   // renderer draw the border.  DO not get the data from aForFrame, since the passed in style context
     1:   // may be different!  Always use |aStyleContext|!
     1:   const nsStyleDisplay* displayData = aStyleContext->GetStyleDisplay();
     1:   if (displayData->mAppearance) {
     1:     nsITheme *theme = aPresContext->GetTheme();
     1:     if (theme && theme->ThemeSupportsWidget(aPresContext, aForFrame, displayData->mAppearance))
     1:       return; // Let the theme handle it.
     1:   }
   947: 
 34849:   if (aStyleBorder.IsBorderImageLoaded()) {
 15992:     DrawBorderImage(aPresContext, aRenderingContext, aForFrame,
 34849:                     aBorderArea, aStyleBorder, aDirtyRect);
 15992:     return;
 15992:   }
 15992: 
     1:   // Get our style context's color struct.
     1:   const nsStyleColor* ourColor = aStyleContext->GetStyleColor();
     1: 
     1:   // in NavQuirks mode we want to use the parent's context as a starting point
     1:   // for determining the background color
 40588:   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
 80486:     (aForFrame, compatMode == eCompatibility_NavQuirks ? true : false);
 40588:   nsStyleContext* bgContext = bgFrame->GetStyleContext();
 40178:   nscolor bgColor =
 40178:     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
     1: 
 34849:   border = aStyleBorder.GetComputedBorder();
     1:   if ((0 == border.left) && (0 == border.right) &&
     1:       (0 == border.top) && (0 == border.bottom)) {
     1:     // Empty border area
     1:     return;
     1:   }
     1: 
 52132:   nsSize frameSize = aForFrame->GetSize();
 52132:   if (&aStyleBorder == aForFrame->GetStyleBorder() &&
 52132:       frameSize == aBorderArea.Size()) {
 52132:     aForFrame->GetBorderRadii(twipsRadii);
 52132:   } else {
 52132:     nsIFrame::ComputeBorderRadii(aStyleBorder.mBorderRadius, frameSize,
 52132:                                  aBorderArea.Size(), aSkipSides, twipsRadii);
 52132:   }
     1: 
     1:   // Turn off rendering for all of the zero sized sides
  3608:   if (aSkipSides & SIDE_BIT_TOP) border.top = 0;
  3608:   if (aSkipSides & SIDE_BIT_RIGHT) border.right = 0;
  3608:   if (aSkipSides & SIDE_BIT_BOTTOM) border.bottom = 0;
  3608:   if (aSkipSides & SIDE_BIT_LEFT) border.left = 0;
     1: 
     1:   // get the inside and outside parts of the border
 16150:   nsRect outerRect(aBorderArea);
 16150: 
   947:   SF(" outerRect: %d %d %d %d\n", outerRect.x, outerRect.y, outerRect.width, outerRect.height);
   947: 
   947:   // we can assume that we're already clipped to aDirtyRect -- I think? (!?)
   947: 
  1972:   // Get our conversion values
     1:   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
     1: 
  1972:   // convert outer and inner rects
 52135:   gfxRect oRect(nsLayoutUtils::RectToGfxRect(outerRect, twipsPerPixel));
  1972: 
  1972:   // convert the border widths
 41024:   gfxFloat borderWidths[4] = { gfxFloat(border.top / twipsPerPixel),
 41024:                                gfxFloat(border.right / twipsPerPixel),
 41024:                                gfxFloat(border.bottom / twipsPerPixel),
 41024:                                gfxFloat(border.left / twipsPerPixel) };
  1972: 
  1972:   // convert the radii
 16150:   gfxCornerSizes borderRadii;
 52130:   ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
  1972: 
  1972:   PRUint8 borderStyles[4];
  1972:   nscolor borderColors[4];
  1972:   nsBorderColors *compositeColors[4];
  1972: 
  1972:   // pull out styles, colors, composite colors
 16150:   NS_FOR_CSS_SIDES (i) {
 79445:     bool foreground;
 34849:     borderStyles[i] = aStyleBorder.GetBorderStyle(i);
 34849:     aStyleBorder.GetBorderColor(i, borderColors[i], foreground);
 34849:     aStyleBorder.GetCompositeColors(i, &compositeColors[i]);
  1972: 
 19182:     if (foreground)
  1972:       borderColors[i] = ourColor->mColor;
  1972:   }
  1972: 
  1972:   SF(" borderStyles: %d %d %d %d\n", borderStyles[0], borderStyles[1], borderStyles[2], borderStyles[3]);
  1972: 
  1972:   // start drawing
 15229:   gfxContext *ctx = aRenderingContext.ThebesContext();
   947: 
   947:   ctx->Save();
   947: 
   947: #if 0
 16150:   // this will draw a transparent red backround underneath the oRect area
   947:   ctx->Save();
   947:   ctx->Rectangle(oRect);
   947:   ctx->SetColor(gfxRGBA(1.0, 0.0, 0.0, 0.5));
   947:   ctx->Fill();
   947:   ctx->Restore();
   947: #endif
   947: 
 16150:   //SF ("borderRadii: %f %f %f %f\n", borderRadii[0], borderRadii[1], borderRadii[2], borderRadii[3]);
 16150: 
 16150:   nsCSSBorderRenderer br(twipsPerPixel,
 16150:                          ctx,
  1972:                          oRect,
  1972:                          borderStyles,
  1972:                          borderWidths,
  1972:                          borderRadii,
  1972:                          borderColors,
   947:                          compositeColors,
  1972:                          aSkipSides,
 40178:                          bgColor);
 16150:   br.DrawBorders();
   947: 
   947:   ctx->Restore();
   947: 
   947:   SN();
   947: }
   947: 
 19125: static nsRect
 19125: GetOutlineInnerRect(nsIFrame* aFrame)
 19125: {
 19125:   nsRect* savedOutlineInnerRect = static_cast<nsRect*>
 39965:     (aFrame->Properties().Get(nsIFrame::OutlineInnerRectProperty()));
 19125:   if (savedOutlineInnerRect)
 19125:     return *savedOutlineInnerRect;
 55040:   // FIXME (bug 599652): We probably want something narrower than either
 55040:   // overflow rect here, but for now use the visual overflow in order to
 55040:   // be consistent with ComputeOutlineAndEffectsRect in nsFrame.cpp.
 55040:   return aFrame->GetVisualOverflowRect();
 19125: }
 19125: 
   947: void
   947: nsCSSRendering::PaintOutline(nsPresContext* aPresContext,
 68481:                              nsRenderingContext& aRenderingContext,
     1:                              nsIFrame* aForFrame,
     1:                              const nsRect& aDirtyRect,
     1:                              const nsRect& aBorderArea,
 16424:                              nsStyleContext* aStyleContext)
     1: {
 20039:   nscoord             twipsRadii[8];
     1: 
     1:   // Get our style context's color struct.
 40182:   const nsStyleOutline* ourOutline = aStyleContext->GetStyleOutline();
     1: 
 15204:   nscoord width;
 40182:   ourOutline->GetOutlineWidth(width);
     1: 
   947:   if (width == 0) {
     1:     // Empty outline
     1:     return;
     1:   }
     1: 
 40588:   nsIFrame* bgFrame = nsCSSRendering::FindNonTransparentBackgroundFrame
 80486:     (aForFrame, false);
 40588:   nsStyleContext* bgContext = bgFrame->GetStyleContext();
 40178:   nscolor bgColor =
 40178:     bgContext->GetVisitedDependentColor(eCSSProperty_background_color);
   947: 
 15204:   // When the outline property is set on :-moz-anonymous-block or
 15204:   // :-moz-anonyomus-positioned-block pseudo-elements, it inherited that
 15204:   // outline from the inline that was broken because it contained a
 15204:   // block.  In that case, we don't want a really wide outline if the
 15204:   // block inside the inline is narrow, so union the actual contents of
 15204:   // the anonymous blocks.
 15204:   nsIFrame *frameForArea = aForFrame;
 15204:   do {
 34387:     nsIAtom *pseudoType = frameForArea->GetStyleContext()->GetPseudo();
 15204:     if (pseudoType != nsCSSAnonBoxes::mozAnonymousBlock &&
 15204:         pseudoType != nsCSSAnonBoxes::mozAnonymousPositionedBlock)
 15204:       break;
 15204:     // If we're done, we really want it and all its later siblings.
 77154:     frameForArea = frameForArea->GetFirstPrincipalChild();
 15204:     NS_ASSERTION(frameForArea, "anonymous block with no children?");
 15204:   } while (frameForArea);
 19125:   nsRect innerRect; // relative to aBorderArea.TopLeft()
 15204:   if (frameForArea == aForFrame) {
 19125:     innerRect = GetOutlineInnerRect(aForFrame);
 15204:   } else {
 15204:     for (; frameForArea; frameForArea = frameForArea->GetNextSibling()) {
 15204:       // The outline has already been included in aForFrame's overflow
 15204:       // area, but not in those of its descendants, so we have to
 15204:       // include it.  Otherwise we'll end up drawing the outline inside
 15204:       // the border.
 19125:       nsRect r(GetOutlineInnerRect(frameForArea) +
 15204:                frameForArea->GetOffsetTo(aForFrame));
 19125:       innerRect.UnionRect(innerRect, r);
 15204:     }
 15204:   }
 15204: 
 19125:   innerRect += aBorderArea.TopLeft();
 40182:   nscoord offset = ourOutline->mOutlineOffset;
 19125:   innerRect.Inflate(offset, offset);
   947:   // If the dirty rect is completely inside the border area (e.g., only the
   947:   // content is being painted), then we can skip out now
   947:   // XXX this isn't exactly true for rounded borders, where the inside curves may
   947:   // encroach into the content area.  A safer calculation would be to
   947:   // shorten insideRect by the radius one each side before performing this test.
 19125:   if (innerRect.Contains(aDirtyRect))
     1:     return;
 19125: 
 19125:   nsRect outerRect = innerRect;
 19125:   outerRect.Inflate(width, width);
   947: 
 52130:   // get the radius for our outline
 52130:   nsIFrame::ComputeBorderRadii(ourOutline->mOutlineRadius, aBorderArea.Size(),
 52130:                                outerRect.Size(), 0, twipsRadii);
 52130: 
  1972:   // Get our conversion values
   947:   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
   947: 
 16150:   // get the outer rectangles
 52135:   gfxRect oRect(nsLayoutUtils::RectToGfxRect(outerRect, twipsPerPixel));
  1972: 
  1972:   // convert the radii
  3608:   nsMargin outlineMargin(width, width, width, width);
 16150:   gfxCornerSizes outlineRadii;
 52130:   ComputePixelRadii(twipsRadii, twipsPerPixel, &outlineRadii);
  1972: 
 40182:   PRUint8 outlineStyle = ourOutline->GetOutlineStyle();
  1972:   PRUint8 outlineStyles[4] = { outlineStyle,
  1972:                                outlineStyle,
  1972:                                outlineStyle,
  1972:                                outlineStyle };
  1648: 
 40182:   // This handles treating the initial color as 'currentColor'; if we
 40182:   // ever want 'invert' back we'll need to do a bit of work here too.
 40182:   nscolor outlineColor =
 40182:     aStyleContext->GetVisitedDependentColor(eCSSProperty_outline_color);
  1972:   nscolor outlineColors[4] = { outlineColor,
  1972:                                outlineColor,
  1972:                                outlineColor,
  1972:                                outlineColor };
  1972: 
  1972:   // convert the border widths
 41024:   gfxFloat outlineWidths[4] = { gfxFloat(width / twipsPerPixel),
 41024:                                 gfxFloat(width / twipsPerPixel),
 41024:                                 gfxFloat(width / twipsPerPixel),
 41024:                                 gfxFloat(width / twipsPerPixel) };
  1972: 
  1972:   // start drawing
 15229:   gfxContext *ctx = aRenderingContext.ThebesContext();
   947: 
   947:   ctx->Save();
   947: 
 16150:   nsCSSBorderRenderer br(twipsPerPixel,
 16150:                          ctx,
  1972:                          oRect,
  1972:                          outlineStyles,
  1972:                          outlineWidths,
  1972:                          outlineRadii,
  1972:                          outlineColors,
 16424:                          nsnull, 0,
 40178:                          bgColor);
 16424:   br.DrawBorders();
 16424: 
 16424:   ctx->Restore();
 16424: 
 16424:   SN();
 16424: }
 16424: 
 16424: void
 16424: nsCSSRendering::PaintFocus(nsPresContext* aPresContext,
 68481:                            nsRenderingContext& aRenderingContext,
 16424:                            const nsRect& aFocusRect,
 16424:                            nscolor aColor)
 16424: {
 16424:   nscoord oneCSSPixel = nsPresContext::CSSPixelsToAppUnits(1);
 16424:   nscoord oneDevPixel = aPresContext->DevPixelsToAppUnits(1);
 16424: 
 52135:   gfxRect focusRect(nsLayoutUtils::RectToGfxRect(aFocusRect, oneDevPixel));
 16424: 
 16424:   gfxCornerSizes focusRadii;
 16424:   {
 20039:     nscoord twipsRadii[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 52130:     ComputePixelRadii(twipsRadii, oneDevPixel, &focusRadii);
 16424:   }
 41024:   gfxFloat focusWidths[4] = { gfxFloat(oneCSSPixel / oneDevPixel),
 41024:                               gfxFloat(oneCSSPixel / oneDevPixel),
 41024:                               gfxFloat(oneCSSPixel / oneDevPixel),
 41024:                               gfxFloat(oneCSSPixel / oneDevPixel) };
 16424: 
 16424:   PRUint8 focusStyles[4] = { NS_STYLE_BORDER_STYLE_DOTTED,
 16424:                              NS_STYLE_BORDER_STYLE_DOTTED,
 16424:                              NS_STYLE_BORDER_STYLE_DOTTED,
 16424:                              NS_STYLE_BORDER_STYLE_DOTTED };
 16424:   nscolor focusColors[4] = { aColor, aColor, aColor, aColor };
 16424: 
 16424:   gfxContext *ctx = aRenderingContext.ThebesContext();
 16424: 
 16424:   ctx->Save();
 16424: 
 16424:   // Because this renders a dotted border, the background color
 16424:   // should not be used.  Therefore, we provide a value that will
 16424:   // be blatantly wrong if it ever does get used.  (If this becomes
 16424:   // something that CSS can style, this function will then have access
 16424:   // to a style context and can use the same logic that PaintBorder
 16424:   // and PaintOutline do.)
 16424:   nsCSSBorderRenderer br(oneDevPixel,
 16424:                          ctx,
 16424:                          focusRect,
 16424:                          focusStyles,
 16424:                          focusWidths,
 16424:                          focusRadii,
 16424:                          focusColors,
 16424:                          nsnull, 0,
 16424:                          NS_RGB(255, 0, 0));
 16150:   br.DrawBorders();
   947: 
   947:   ctx->Restore();
   947: 
   947:   SN();
   947: }
   947: 
   947: // Thebes Border Rendering Code End
   947: //----------------------------------------------------------------------
     1: 
     1: 
     1: //----------------------------------------------------------------------
     1: 
 21323: /**
 21323:  * Computes the placement of a background image.
 21323:  *
 21323:  * @param aOriginBounds is the box to which the tiling position should be
 21323:  * relative
 21323:  * This should correspond to 'background-origin' for the frame,
 21323:  * except when painting on the canvas, in which case the origin bounds
 21323:  * should be the bounds of the root element's frame.
 21323:  * @param aTopLeft the top-left corner where an image tile should be drawn
 21323:  * @param aAnchorPoint a point which should be pixel-aligned by
 21323:  * nsLayoutUtils::DrawImage. This is the same as aTopLeft, unless CSS
 21323:  * specifies a percentage (including 'right' or 'bottom'), in which case
 21323:  * it's that percentage within of aOriginBounds. So 'right' would set
 21323:  * aAnchorPoint.x to aOriginBounds.XMost().
 21323:  *
 21323:  * Points are returned relative to aOriginBounds.
 21323:  */
     1: static void
 25276: ComputeBackgroundAnchorPoint(const nsStyleBackground::Layer& aLayer,
 21323:                              const nsSize& aOriginBounds,
 21323:                              const nsSize& aImageSize,
 21323:                              nsPoint* aTopLeft,
 21323:                              nsPoint* aAnchorPoint)
     1: {
 53919:   double percentX = aLayer.mPosition.mXPosition.mPercent;
 53919:   nscoord lengthX = aLayer.mPosition.mXPosition.mLength;
 53919:   aAnchorPoint->x = lengthX + NSToCoordRound(percentX*aOriginBounds.width);
 53919:   aTopLeft->x = lengthX +
 53919:     NSToCoordRound(percentX*(aOriginBounds.width - aImageSize.width));
 53919: 
 53919:   double percentY = aLayer.mPosition.mYPosition.mPercent;
 53919:   nscoord lengthY = aLayer.mPosition.mYPosition.mLength;
 53919:   aAnchorPoint->y = lengthY + NSToCoordRound(percentY*aOriginBounds.height);
 53919:   aTopLeft->y = lengthY +
 53919:     NSToCoordRound(percentY*(aOriginBounds.height - aImageSize.height));
     1: }
     1: 
 40588: nsIFrame*
 40588: nsCSSRendering::FindNonTransparentBackgroundFrame(nsIFrame* aFrame,
 79445:                                                   bool aStartAtParent /*= false*/)
     1: {
 40588:   NS_ASSERTION(aFrame, "Cannot find NonTransparentBackgroundFrame in a null frame");
 40588: 
 40588:   nsIFrame* frame = nsnull;
     1:   if (aStartAtParent) {
100473:     frame = nsLayoutUtils::GetParentOrPlaceholderFor(aFrame);
 40588:   }
 40588:   if (!frame) {
 40588:     frame = aFrame;
 40588:   }
 40588: 
 40588:   while (frame) {
 40178:     // No need to call GetVisitedDependentColor because it always uses
 40178:     // this alpha component anyway.
 40588:     if (NS_GET_A(frame->GetStyleBackground()->mBackgroundColor) > 0)
     1:       break;
     1: 
 40588:     if (frame->IsThemed())
 23494:       break;
 23494: 
100473:     nsIFrame* parent = nsLayoutUtils::GetParentOrPlaceholderFor(frame);
 23494:     if (!parent)
 23494:       break;
 23494: 
 40588:     frame = parent;
 40588:   }
 40588:   return frame;
     1: }
     1: 
 27185: // Returns true if aFrame is a canvas frame.
 27185: // We need to treat the viewport as canvas because, even though
 27185: // it does not actually paint a background, we need to get the right
 27185: // background style so we correctly detect transparent documents.
 79445: bool
 27185: nsCSSRendering::IsCanvasFrame(nsIFrame* aFrame)
 27185: {
 27185:   nsIAtom* frameType = aFrame->GetType();
 27185:   return frameType == nsGkAtoms::canvasFrame ||
 27185:          frameType == nsGkAtoms::rootFrame ||
 27185:          frameType == nsGkAtoms::pageContentFrame ||
 27185:          frameType == nsGkAtoms::viewportFrame;
 27185: }
     1: 
 27185: nsIFrame*
 35300: nsCSSRendering::FindBackgroundStyleFrame(nsIFrame* aForFrame)
 27185: {
 27185:   const nsStyleBackground* result = aForFrame->GetStyleBackground();
 27185: 
 27185:   // Check if we need to do propagation from BODY rather than HTML.
 71171:   if (!result->IsTransparent()) {
 71171:     return aForFrame;
 71171:   }
 71171: 
 27185:   nsIContent* content = aForFrame->GetContent();
 27185:   // The root element content can't be null. We wouldn't know what
 27185:   // frame to create for aFrame.
 80527:   // Use |OwnerDoc| so it works during destruction.
 71171:   if (!content) {
 71171:     return aForFrame;
 71171:   }
 71171: 
 80526:   nsIDocument* document = content->OwnerDoc();
 71171: 
 71171:   dom::Element* bodyContent = document->GetBodyElement();
 27185:   // We need to null check the body node (bug 118829) since
 27185:   // there are cases, thanks to the fix for bug 5569, where we
 27185:   // will reflow a document with no body.  In particular, if a
 27185:   // SCRIPT element in the head blocks the parser and then has a
 27185:   // SCRIPT that does "document.location.href = 'foo'", then
 27185:   // nsParser::Terminate will call |DidBuildModel| methods
 27185:   // through to the content sink, which will call |StartLayout|
 27185:   // and thus |InitialReflow| on the pres shell.  See bug 119351
 27185:   // for the ugly details.
 71171:   if (!bodyContent) {
 71171:     return aForFrame;
 71171:   }
 71171: 
 36656:   nsIFrame *bodyFrame = bodyContent->GetPrimaryFrame();
 71171:   if (!bodyFrame) {
 71171:     return aForFrame;
 71171:   }
 71171: 
 35300:   return nsLayoutUtils::GetStyleFrame(bodyFrame);
 27185: }
 27002: 
     1: /**
     1:  * |FindBackground| finds the correct style data to use to paint the
     1:  * background.  It is responsible for handling the following two
     1:  * statements in section 14.2 of CSS2:
     1:  *
     1:  *   The background of the box generated by the root element covers the
     1:  *   entire canvas.
     1:  *
     1:  *   For HTML documents, however, we recommend that authors specify the
     1:  *   background for the BODY element rather than the HTML element. User
     1:  *   agents should observe the following precedence rules to fill in the
     1:  *   background: if the value of the 'background' property for the HTML
     1:  *   element is different from 'transparent' then use it, else use the
     1:  *   value of the 'background' property for the BODY element. If the
     1:  *   resulting value is 'transparent', the rendering is undefined.
     1:  *
     1:  * Thus, in our implementation, it is responsible for ensuring that:
     1:  *  + we paint the correct background on the |nsCanvasFrame|,
     1:  *    |nsRootBoxFrame|, or |nsPageFrame|,
     1:  *  + we don't paint the background on the root element, and
     1:  *  + we don't paint the background on the BODY element in *some* cases,
     1:  *    and for SGML-based HTML documents only.
     1:  *
     1:  * |FindBackground| returns true if a background should be painted, and
     1:  * the resulting style context to use for the background information
 27834:  * will be filled in to |aBackground|.
     1:  */
 40177: nsStyleContext*
 25022: nsCSSRendering::FindRootFrameBackground(nsIFrame* aForFrame)
     1: {
 40177:   return FindBackgroundStyleFrame(aForFrame)->GetStyleContext();
 25022: }
 25022: 
 79445: inline bool
 16509: FindElementBackground(nsIFrame* aForFrame, nsIFrame* aRootElementFrame,
 40177:                       nsStyleContext** aBackgroundSC)
     1: {
 16509:   if (aForFrame == aRootElementFrame) {
 16509:     // We must have propagated our background to the viewport or canvas. Abort.
 80486:     return false;
     1:   }
     1: 
 40177:   *aBackgroundSC = aForFrame->GetStyleContext();
     1: 
     1:   // Return true unless the frame is for a BODY element whose background
     1:   // was propagated to the viewport.
     1: 
 16509:   nsIContent* content = aForFrame->GetContent();
 16509:   if (!content || content->Tag() != nsGkAtoms::body)
 80486:     return true; // not frame for a "body" element
 16509:   // It could be a non-HTML "body" element but that's OK, we'd fail the
 16509:   // bodyContent check below
 16509: 
 34387:   if (aForFrame->GetStyleContext()->GetPseudo())
 80486:     return true; // A pseudo-element frame.
     1: 
     1:   // We should only look at the <html> background if we're in an HTML document
 80526:   nsIDocument* document = content->OwnerDoc();
     1: 
 71171:   dom::Element* bodyContent = document->GetBodyElement();
     1:   if (bodyContent != content)
 80486:     return true; // this wasn't the background that was propagated
     1: 
 16509:   // This can be called even when there's no root element yet, during frame
 16509:   // construction, via nsLayoutUtils::FrameHasTransparency and
 16509:   // nsContainerFrame::SyncFrameViewProperties.
 16509:   if (!aRootElementFrame)
 80486:     return true;
 16509: 
 16509:   const nsStyleBackground* htmlBG = aRootElementFrame->GetStyleBackground();
     1:   return !htmlBG->IsTransparent();
     1: }
     1: 
 79445: bool
     1: nsCSSRendering::FindBackground(nsPresContext* aPresContext,
     1:                                nsIFrame* aForFrame,
 40177:                                nsStyleContext** aBackgroundSC)
     1: {
 16509:   nsIFrame* rootElementFrame =
 16509:     aPresContext->PresShell()->FrameConstructor()->GetRootElementStyleFrame();
 25022:   if (IsCanvasFrame(aForFrame)) {
 40177:     *aBackgroundSC = FindCanvasBackground(aForFrame, rootElementFrame);
 80486:     return true;
 25022:   } else {
 40177:     return FindElementBackground(aForFrame, rootElementFrame, aBackgroundSC);
 25022:   }
     1: }
     1: 
     1: void
     1: nsCSSRendering::DidPaint()
     1: {
     1:   gInlineBGData->Reset();
     1: }
     1: 
 15700: void
 24818: nsCSSRendering::PaintBoxShadowOuter(nsPresContext* aPresContext,
 68481:                                     nsRenderingContext& aRenderingContext,
 15700:                                     nsIFrame* aForFrame,
 24818:                                     const nsRect& aFrameArea,
 22183:                                     const nsRect& aDirtyRect)
 15700: {
 51265:   const nsStyleBorder* styleBorder = aForFrame->GetStyleBorder();
 51265:   nsCSSShadowArray* shadows = styleBorder->mBoxShadow;
 26940:   if (!shadows)
 26940:     return;
 51265:   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 51265: 
 79445:   bool hasBorderRadius;
 79445:   bool nativeTheme; // mutually exclusive with hasBorderRadius
 51265:   gfxCornerSizes borderRadii;
 51265: 
 51265:   // Get any border radius, since box-shadow must also have rounded corners if the frame does
 51265:   const nsStyleDisplay* styleDisplay = aForFrame->GetStyleDisplay();
 51265:   nsITheme::Transparency transparency;
 51265:   if (aForFrame->IsThemed(styleDisplay, &transparency)) {
 51265:     // We don't respect border-radius for native-themed widgets
 80486:     hasBorderRadius = false;
 51265:     // For opaque (rectangular) theme widgets we can take the generic
 51265:     // border-box path with border-radius disabled.
 51265:     nativeTheme = transparency != nsITheme::eOpaque;
 51265:   } else {
 80486:     nativeTheme = false;
 51265:     nscoord twipsRadii[8];
 52132:     NS_ASSERTION(aFrameArea.Size() == aForFrame->GetSize(), "unexpected size");
 52132:     hasBorderRadius = aForFrame->GetBorderRadii(twipsRadii);
 51265:     if (hasBorderRadius) {
 52130:       ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
 51265:     }
 51265:   }
 51265: 
 51265:   nsRect frameRect =
 55040:     nativeTheme ? aForFrame->GetVisualOverflowRectRelativeToSelf() + aFrameArea.TopLeft() : aFrameArea;
 52135:   gfxRect frameGfxRect(nsLayoutUtils::RectToGfxRect(frameRect, twipsPerPixel));
 23310:   frameGfxRect.Round();
 22183: 
 40965:   // We don't show anything that intersects with the frame we're blurring on. So tell the
 40965:   // blurrer not to do unnecessary work there.
 40965:   gfxRect skipGfxRect = frameGfxRect;
 79445:   bool useSkipGfxRect = true;
 51265:   if (nativeTheme) {
 51265:     // Optimize non-leaf native-themed frames by skipping computing pixels
 51265:     // in the padding-box. We assume the padding-box is going to be painted
 51265:     // opaquely for non-leaf frames.
 51265:     // XXX this may not be a safe assumption; we should make this go away
 51265:     // by optimizing box-shadow drawing more for the cases where we don't have a skip-rect.
 51265:     useSkipGfxRect = !aForFrame->IsLeaf();
 51265:     nsRect paddingRect =
 51265:       aForFrame->GetPaddingRect() - aForFrame->GetPosition() + aFrameArea.TopLeft();
 52135:     skipGfxRect = nsLayoutUtils::RectToGfxRect(paddingRect, twipsPerPixel);
 51265:   } else if (hasBorderRadius) {
 68641:     skipGfxRect.Deflate(gfxMargin(
 72496:         0, NS_MAX(borderRadii[C_TL].height, borderRadii[C_TR].height),
 72496:         0, NS_MAX(borderRadii[C_BL].height, borderRadii[C_BR].height)));
 40965:   }
 40965: 
 26940:   for (PRUint32 i = shadows->Length(); i > 0; --i) {
 26940:     nsCSSShadowItem* shadowItem = shadows->ShadowAt(i - 1);
 24818:     if (shadowItem->mInset)
 24818:       continue;
 24818: 
 51265:     nsRect shadowRect = frameRect;
 32863:     shadowRect.MoveBy(shadowItem->mXOffset, shadowItem->mYOffset);
 51265:     nscoord pixelSpreadRadius;
 51265:     if (nativeTheme) {
 51265:       pixelSpreadRadius = shadowItem->mSpread;
 51265:     } else {
 32863:       shadowRect.Inflate(shadowItem->mSpread, shadowItem->mSpread);
 51265:       pixelSpreadRadius = 0;
 51265:     }
 15700: 
 15700:     // shadowRect won't include the blur, so make an extra rect here that includes the blur
 15700:     // for use in the even-odd rule below.
 32863:     nsRect shadowRectPlusBlur = shadowRect;
 19207:     nscoord blurRadius = shadowItem->mRadius;
 52476:     shadowRectPlusBlur.Inflate(
 52476:       nsContextBoxBlur::GetBlurRadiusMargin(blurRadius, twipsPerPixel));
 32863: 
 52135:     gfxRect shadowGfxRect =
 52135:       nsLayoutUtils::RectToGfxRect(shadowRect, twipsPerPixel);
 52135:     gfxRect shadowGfxRectPlusBlur =
 52135:       nsLayoutUtils::RectToGfxRect(shadowRectPlusBlur, twipsPerPixel);
 32863:     shadowGfxRect.Round();
 32863:     shadowGfxRectPlusBlur.RoundOut();
 15700: 
 15700:     gfxContext* renderContext = aRenderingContext.ThebesContext();
 15700:     nsRefPtr<gfxContext> shadowContext;
 15700:     nsContextBoxBlur blurringArea;
 15700: 
 51265:     // When getting the widget shape from the native theme, we're going
 51265:     // to draw the widget into the shadow surface to create a mask.
 51265:     // We need to ensure that there actually *is* a shadow surface
 51265:     // and that we're not going to draw directly into renderContext.
 51265:     shadowContext = 
 51265:       blurringArea.Init(shadowRect, pixelSpreadRadius,
 51265:                         blurRadius, twipsPerPixel, renderContext, aDirtyRect,
 51265:                         useSkipGfxRect ? &skipGfxRect : nsnull,
 51265:                         nativeTheme ? nsContextBoxBlur::FORCE_MASK : 0);
 15700:     if (!shadowContext)
 16609:       continue;
 15700: 
 15700:     // Set the shadow color; if not specified, use the foreground color
 15700:     nscolor shadowColor;
 15700:     if (shadowItem->mHasColor)
 15700:       shadowColor = shadowItem->mColor;
 15700:     else
 15700:       shadowColor = aForFrame->GetStyleColor()->mColor;
 15700: 
 15700:     renderContext->Save();
 15700:     renderContext->SetColor(gfxRGBA(shadowColor));
 15700: 
 15700:     // Draw the shape of the frame so it can be blurred. Recall how nsContextBoxBlur
 15700:     // doesn't make any temporary surfaces if blur is 0 and it just returns the original
 15700:     // surface? If we have no blur, we're painting this fill on the actual content surface
 15700:     // (renderContext == shadowContext) which is why we set up the color and clip
 15700:     // before doing this.
 51265:     if (nativeTheme) {
 51265:       // We don't clip the border-box from the shadow, nor any other box.
 51265:       // We assume that the native theme is going to paint over the shadow.
 51265: 
 51265:       // Draw the widget shape
 51265:       gfxContextMatrixAutoSaveRestore save(shadowContext);
 68670:       nsRefPtr<nsRenderingContext> wrapperCtx = new nsRenderingContext();
 68670:       wrapperCtx->Init(aPresContext->DeviceContext(), shadowContext);
 68670:       wrapperCtx->Translate(nsPoint(shadowItem->mXOffset,
 68670:                                     shadowItem->mYOffset));
 58398: 
 58398:       nsRect nativeRect;
 58398:       nativeRect.IntersectRect(frameRect, aDirtyRect);
 51265:       aPresContext->GetTheme()->DrawWidgetBackground(wrapperCtx, aForFrame,
 58398:           styleDisplay->mAppearance, aFrameArea, nativeRect);
 51265:     } else {
 51265:       // Clip out the area of the actual frame so the shadow is not shown within
 51265:       // the frame
 51265:       renderContext->NewPath();
 51265:       renderContext->Rectangle(shadowGfxRectPlusBlur);
 51265:       if (hasBorderRadius) {
 51265:         renderContext->RoundedRectangle(frameGfxRect, borderRadii);
 51265:       } else {
 51265:         renderContext->Rectangle(frameGfxRect);
 51265:       }
 51265: 
 51265:       renderContext->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
 51265:       renderContext->Clip();
 51265: 
 15700:       shadowContext->NewPath();
 28294:       if (hasBorderRadius) {
 28294:         gfxCornerSizes clipRectRadii;
 97195:         gfxFloat spreadDistance = shadowItem->mSpread / twipsPerPixel;
 97195: 
 97195:         gfxFloat borderSizes[4];
 97195: 
 33015:         borderSizes[NS_SIDE_LEFT] = spreadDistance;
 33015:         borderSizes[NS_SIDE_TOP] = spreadDistance;
 33015:         borderSizes[NS_SIDE_RIGHT] = spreadDistance;
 33015:         borderSizes[NS_SIDE_BOTTOM] = spreadDistance;
 97195: 
 97195:         nsCSSBorderRenderer::ComputeOuterRadii(borderRadii, borderSizes,
 28294:             &clipRectRadii);
 32863:         shadowContext->RoundedRectangle(shadowGfxRect, clipRectRadii);
 28294:       } else {
 32863:         shadowContext->Rectangle(shadowGfxRect);
 28294:       }
 15700:       shadowContext->Fill();
 51265:     }
 15700: 
 15700:     blurringArea.DoPaint();
 15700:     renderContext->Restore();
 15700:   }
 15700: }
 15700: 
     1: void
 24818: nsCSSRendering::PaintBoxShadowInner(nsPresContext* aPresContext,
 68481:                                     nsRenderingContext& aRenderingContext,
 24818:                                     nsIFrame* aForFrame,
 24818:                                     const nsRect& aFrameArea,
 24818:                                     const nsRect& aDirtyRect)
 24818: {
 51265:   const nsStyleBorder* styleBorder = aForFrame->GetStyleBorder();
 51265:   nsCSSShadowArray* shadows = styleBorder->mBoxShadow;
 26940:   if (!shadows)
 26940:     return;
 51265:   if (aForFrame->IsThemed() && aForFrame->GetContent() &&
 51265:       !nsContentUtils::IsChromeDoc(aForFrame->GetContent()->GetCurrentDoc())) {
 51265:     // There's no way of getting hold of a shape corresponding to a
 51265:     // "padding-box" for native-themed widgets, so just don't draw
 51265:     // inner box-shadows for them. But we allow chrome to paint inner
 51265:     // box shadows since chrome can be aware of the platform theme.
 51265:     return;
 51265:   }
 24818: 
 58305:   // Get any border radius, since box-shadow must also have rounded corners
 58305:   // if the frame does.
 24818:   nscoord twipsRadii[8];
 58305:   NS_ASSERTION(aForFrame->GetType() == nsGkAtoms::fieldSetFrame ||
 58305:                aFrameArea.Size() == aForFrame->GetSize(), "unexpected size");
 79445:   bool hasBorderRadius = aForFrame->GetBorderRadii(twipsRadii);
 24818:   nscoord twipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
 24818: 
 24818:   nsRect paddingRect = aFrameArea;
 24818:   nsMargin border = aForFrame->GetUsedBorder();
 24818:   aForFrame->ApplySkipSides(border);
 24818:   paddingRect.Deflate(border);
 24818: 
 24818:   gfxCornerSizes innerRadii;
 24818:   if (hasBorderRadius) {
 24818:     gfxCornerSizes borderRadii;
 52128: 
 52130:     ComputePixelRadii(twipsRadii, twipsPerPixel, &borderRadii);
 24818:     gfxFloat borderSizes[4] = {
 41024:       gfxFloat(border.top / twipsPerPixel),
 41024:       gfxFloat(border.right / twipsPerPixel),
 41024:       gfxFloat(border.bottom / twipsPerPixel),
 41024:       gfxFloat(border.left / twipsPerPixel)
 24818:     };
 24818:     nsCSSBorderRenderer::ComputeInnerRadii(borderRadii, borderSizes,
 24818:                                            &innerRadii);
 24818:   }
 24818: 
 26940:   for (PRUint32 i = shadows->Length(); i > 0; --i) {
 26940:     nsCSSShadowItem* shadowItem = shadows->ShadowAt(i - 1);
 24818:     if (!shadowItem->mInset)
 24818:       continue;
 24818: 
 24818:     /*
 24818:      * shadowRect: the frame's padding rect
 24818:      * shadowPaintRect: the area to paint on the temp surface, larger than shadowRect
 24818:      *                  so that blurs still happen properly near the edges
 24818:      * shadowClipRect: the area on the temporary surface within shadowPaintRect
 24818:      *                 that we will NOT paint in
 24818:      */
 24818:     nscoord blurRadius = shadowItem->mRadius;
 52476:     nsMargin blurMargin =
 52476:       nsContextBoxBlur::GetBlurRadiusMargin(blurRadius, twipsPerPixel);
 32863:     nsRect shadowPaintRect = paddingRect;
 52476:     shadowPaintRect.Inflate(blurMargin);
 32863: 
 32863:     nsRect shadowClipRect = paddingRect;
 32863:     shadowClipRect.MoveBy(shadowItem->mXOffset, shadowItem->mYOffset);
 32863:     shadowClipRect.Deflate(shadowItem->mSpread, shadowItem->mSpread);
 24818: 
 40965:     gfxCornerSizes clipRectRadii;
 40965:     if (hasBorderRadius) {
 40965:       // Calculate the radii the inner clipping rect will have
 40965:       gfxFloat spreadDistance = shadowItem->mSpread / twipsPerPixel;
 40965:       gfxFloat borderSizes[4] = {0, 0, 0, 0};
 40965: 
 40965:       // See PaintBoxShadowOuter and bug 514670
 40965:       if (innerRadii[C_TL].width > 0 || innerRadii[C_BL].width > 0) {
 40965:         borderSizes[NS_SIDE_LEFT] = spreadDistance;
 40965:       }
 40965: 
 40965:       if (innerRadii[C_TL].height > 0 || innerRadii[C_TR].height > 0) {
 40965:         borderSizes[NS_SIDE_TOP] = spreadDistance;
 40965:       }
 40965: 
 40965:       if (innerRadii[C_TR].width > 0 || innerRadii[C_BR].width > 0) {
 40965:         borderSizes[NS_SIDE_RIGHT] = spreadDistance;
 40965:       }
 40965: 
 40965:       if (innerRadii[C_BL].height > 0 || innerRadii[C_BR].height > 0) {
 40965:         borderSizes[NS_SIDE_BOTTOM] = spreadDistance;
 40965:       }
 40965: 
 40965:       nsCSSBorderRenderer::ComputeInnerRadii(innerRadii, borderSizes,
 40965:                                              &clipRectRadii);
 40965:     }
 40965: 
 40965:     // Set the "skip rect" to the area within the frame that we don't paint in,
 58305:     // including after blurring.
 40965:     nsRect skipRect = shadowClipRect;
 52476:     skipRect.Deflate(blurMargin);
 52135:     gfxRect skipGfxRect = nsLayoutUtils::RectToGfxRect(skipRect, twipsPerPixel);
 40965:     if (hasBorderRadius) {
 68641:       skipGfxRect.Deflate(
 72496:           gfxMargin(0, NS_MAX(clipRectRadii[C_TL].height, clipRectRadii[C_TR].height),
 72496:                     0, NS_MAX(clipRectRadii[C_BL].height, clipRectRadii[C_BR].height)));
 40965:     }
 40965: 
 58305:     // When there's a blur radius, gfxAlphaBoxBlur leaves the skiprect area
 58305:     // unchanged. And by construction the gfxSkipRect is not touched by the
 58305:     // rendered shadow (even after blurring), so those pixels must be completely
 58305:     // transparent in the shadow, so drawing them changes nothing.
 24818:     gfxContext* renderContext = aRenderingContext.ThebesContext();
 24818:     nsRefPtr<gfxContext> shadowContext;
 24818:     nsContextBoxBlur blurringArea;
 58305:     shadowContext =
 58305:       blurringArea.Init(shadowPaintRect, 0, blurRadius, twipsPerPixel,
 58305:                         renderContext, aDirtyRect, &skipGfxRect);
 24818:     if (!shadowContext)
 24818:       continue;
 24818: 
 24818:     // Set the shadow color; if not specified, use the foreground color
 24818:     nscolor shadowColor;
 24818:     if (shadowItem->mHasColor)
 24818:       shadowColor = shadowItem->mColor;
 24818:     else
 24818:       shadowColor = aForFrame->GetStyleColor()->mColor;
 24818: 
 24818:     renderContext->Save();
 24818:     renderContext->SetColor(gfxRGBA(shadowColor));
 24818: 
 24818:     // Clip the context to the area of the frame's padding rect, so no part of the
 40965:     // shadow is painted outside. Also cut out anything beyond where the inset shadow
 40965:     // will be.
 52135:     gfxRect shadowGfxRect =
 52135:       nsLayoutUtils::RectToGfxRect(paddingRect, twipsPerPixel);
 32863:     shadowGfxRect.Round();
 24818:     renderContext->NewPath();
 24818:     if (hasBorderRadius)
 80486:       renderContext->RoundedRectangle(shadowGfxRect, innerRadii, false);
 24818:     else
 32863:       renderContext->Rectangle(shadowGfxRect);
 24818:     renderContext->Clip();
 24818: 
 58305:     // Fill the surface minus the area within the frame that we should
 58305:     // not paint in, and blur and apply it.
 52135:     gfxRect shadowPaintGfxRect =
 52135:       nsLayoutUtils::RectToGfxRect(shadowPaintRect, twipsPerPixel);
 40965:     shadowPaintGfxRect.RoundOut();
 52135:     gfxRect shadowClipGfxRect =
 52135:       nsLayoutUtils::RectToGfxRect(shadowClipRect, twipsPerPixel);
 32863:     shadowClipGfxRect.Round();
 24818:     shadowContext->NewPath();
 32863:     shadowContext->Rectangle(shadowPaintGfxRect);
 40965:     if (hasBorderRadius)
 80486:       shadowContext->RoundedRectangle(shadowClipGfxRect, clipRectRadii, false);
 40965:     else
 32863:       shadowContext->Rectangle(shadowClipGfxRect);
 24818:     shadowContext->SetFillRule(gfxContext::FILL_RULE_EVEN_ODD);
 24818:     shadowContext->Fill();
 24818: 
 24818:     blurringArea.DoPaint();
 24818:     renderContext->Restore();
 24818:   }
 24818: }
 24818: 
 24818: void
     1: nsCSSRendering::PaintBackground(nsPresContext* aPresContext,
 68481:                                 nsRenderingContext& aRenderingContext,
     1:                                 nsIFrame* aForFrame,
     1:                                 const nsRect& aDirtyRect,
     1:                                 const nsRect& aBorderArea,
 28800:                                 PRUint32 aFlags,
     1:                                 nsRect* aBGClipRect)
     1: {
 96794:   SAMPLE_LABEL("nsCSSRendering", "PaintBackground");
     1:   NS_PRECONDITION(aForFrame,
     1:                   "Frame is expected to be provided to PaintBackground");
     1: 
 40177:   nsStyleContext *sc;
 40177:   if (!FindBackground(aPresContext, aForFrame, &sc)) {
 29987:     // We don't want to bail out if moz-appearance is set on a root
     1:     // node. If it has a parent content node, bail because it's not
     1:     // a root, other wise keep going in order to let the theme stuff
     1:     // draw the background. The canvas really should be drawing the
     1:     // bg, but there's no way to hook that up via css.
     1:     if (!aForFrame->GetStyleDisplay()->mAppearance) {
     1:       return;
     1:     }
     1: 
     1:     nsIContent* content = aForFrame->GetContent();
     1:     if (!content || content->GetParent()) {
     1:       return;
     1:     }
     1: 
 40177:     sc = aForFrame->GetStyleContext();
     1:   }
 23854: 
     1:   PaintBackgroundWithSC(aPresContext, aRenderingContext, aForFrame,
 40177:                         aDirtyRect, aBorderArea, sc,
 28800:                         *aForFrame->GetStyleBorder(), aFlags,
 28800:                         aBGClipRect);
     1: }
     1: 
 79445: static bool
 41419: IsOpaqueBorderEdge(const nsStyleBorder& aBorder, mozilla::css::Side aSide)
 16605: {
 99855:   if (aBorder.GetComputedBorder().Side(aSide) == 0)
 80486:     return true;
 34212:   switch (aBorder.GetBorderStyle(aSide)) {
 34212:   case NS_STYLE_BORDER_STYLE_SOLID:
 34212:   case NS_STYLE_BORDER_STYLE_GROOVE:
 34212:   case NS_STYLE_BORDER_STYLE_RIDGE:
 34212:   case NS_STYLE_BORDER_STYLE_INSET:
 34212:   case NS_STYLE_BORDER_STYLE_OUTSET:
 34212:     break;
 34212:   default:
 80486:     return false;
 34212:   }
 16605: 
 21091:   // If we're using a border image, assume it's not fully opaque,
 21091:   // because we may not even have the image loaded at this point, and
 21091:   // even if we did, checking whether the relevant tile is fully
 21091:   // opaque would be too much work.
 21091:   if (aBorder.GetBorderImage())
 80486:     return false;
 21091: 
 16605:   nscolor color;
 79445:   bool isForeground;
 19182:   aBorder.GetBorderColor(aSide, color, isForeground);
 21091: 
 21091:   // We don't know the foreground color here, so if it's being used
 21091:   // we must assume it might be transparent.
 21091:   if (isForeground)
 80486:     return false;
 21091: 
 19182:   return NS_GET_A(color) == 255;
 16605: }
 16605: 
 16605: /**
 16605:  * Returns true if all border edges are either missing or opaque.
 16605:  */
 79445: static bool
 34212: IsOpaqueBorder(const nsStyleBorder& aBorder)
 16605: {
 23493:   if (aBorder.mBorderColors)
 80486:     return false;
 41419:   NS_FOR_CSS_SIDES(i) {
 34212:     if (!IsOpaqueBorderEdge(aBorder, i))
 80486:       return false;
 80486:   }
 80486:   return true;
 16605: }
 16605: 
 25276: static inline void
 25276: SetupDirtyRects(const nsRect& aBGClipArea, const nsRect& aCallerDirtyRect,
 25276:                 nscoord aAppUnitsPerPixel,
 25276:                 /* OUT: */
 25276:                 nsRect* aDirtyRect, gfxRect* aDirtyRectGfx)
 25276: {
 25276:   aDirtyRect->IntersectRect(aBGClipArea, aCallerDirtyRect);
 25276: 
 25276:   // Compute the Thebes equivalent of the dirtyRect.
 52135:   *aDirtyRectGfx = nsLayoutUtils::RectToGfxRect(*aDirtyRect, aAppUnitsPerPixel);
 25276:   NS_WARN_IF_FALSE(aDirtyRect->IsEmpty() || !aDirtyRectGfx->IsEmpty(),
 25276:                    "converted dirty rect should not be empty");
 25276:   NS_ABORT_IF_FALSE(!aDirtyRect->IsEmpty() || aDirtyRectGfx->IsEmpty(),
 25276:                     "second should be empty if first is");
 25276: }
 25276: 
 60815: struct BackgroundClipState {
 60815:   nsRect mBGClipArea;
 60815:   nsRect mDirtyRect;
 60815:   gfxRect mDirtyRectGfx;
 60815: 
 60815:   gfxCornerSizes mClippedRadii;
 79445:   bool mRadiiAreOuter;
 60815: 
 60815:   // Whether we are being asked to draw with a caller provided background
 60815:   // clipping area. If this is true we also disable rounded corners.
 79445:   bool mCustomClip;
 60815: };
 60815: 
 25276: static void
 60815: GetBackgroundClip(gfxContext *aCtx, PRUint8 aBackgroundClip,
 25276:                   nsIFrame* aForFrame, const nsRect& aBorderArea,
 79445:                   const nsRect& aCallerDirtyRect, bool aHaveRoundedCorners,
 25276:                   const gfxCornerSizes& aBGRadii, nscoord aAppUnitsPerPixel,
 60815:                   /* out */ BackgroundClipState* aClipState)
 25276: {
 60815:   aClipState->mBGClipArea = aBorderArea;
 80486:   aClipState->mCustomClip = false;
 80486:   aClipState->mRadiiAreOuter = true;
 60815:   aClipState->mClippedRadii = aBGRadii;
 25276:   if (aBackgroundClip != NS_STYLE_BG_CLIP_BORDER) {
 43355:     nsMargin border = aForFrame->GetUsedBorder();
 83477:     if (aBackgroundClip == NS_STYLE_BG_CLIP_MOZ_ALMOST_PADDING) {
 83477:       // Reduce |border| by 1px (device pixels) on all sides, if
 83477:       // possible, so that we don't get antialiasing seams between the
 83477:       // background and border.
 83477:       border.top = NS_MAX(0, border.top - aAppUnitsPerPixel);
 83477:       border.right = NS_MAX(0, border.right - aAppUnitsPerPixel);
 83477:       border.bottom = NS_MAX(0, border.bottom - aAppUnitsPerPixel);
 83477:       border.left = NS_MAX(0, border.left - aAppUnitsPerPixel);
 83477:     } else if (aBackgroundClip != NS_STYLE_BG_CLIP_PADDING) {
 43355:       NS_ASSERTION(aBackgroundClip == NS_STYLE_BG_CLIP_CONTENT,
 25276:                    "unexpected background-clip");
 43355:       border += aForFrame->GetUsedPadding();
 43355:     }
 25276:     aForFrame->ApplySkipSides(border);
 60815:     aClipState->mBGClipArea.Deflate(border);
 25276: 
 25276:     if (aHaveRoundedCorners) {
 25276:       gfxFloat borderSizes[4] = {
 41024:         gfxFloat(border.top / aAppUnitsPerPixel),
 41024:         gfxFloat(border.right / aAppUnitsPerPixel),
 41024:         gfxFloat(border.bottom / aAppUnitsPerPixel),
 41024:         gfxFloat(border.left / aAppUnitsPerPixel)
 25276:       };
 25276:       nsCSSBorderRenderer::ComputeInnerRadii(aBGRadii, borderSizes,
 60815:                                              &aClipState->mClippedRadii);
 80486:       aClipState->mRadiiAreOuter = false;
 60815:     }
 60815:   }
 60815: 
 60815:   SetupDirtyRects(aClipState->mBGClipArea, aCallerDirtyRect, aAppUnitsPerPixel,
 60815:                   &aClipState->mDirtyRect, &aClipState->mDirtyRectGfx);
 60815: }
 60815: 
 60815: static void
 60815: SetupBackgroundClip(BackgroundClipState& aClipState, gfxContext *aCtx,
 79445:                     bool aHaveRoundedCorners, nscoord aAppUnitsPerPixel,
 60815:                     gfxContextAutoSaveRestore* aAutoSR)
 60815: {
 60815:   if (aClipState.mDirtyRectGfx.IsEmpty()) {
 25276:     // Our caller won't draw anything under this condition, so no need
 25276:     // to set more up.
 25276:     return;
 25276:   }
 25276: 
 60815:   if (aClipState.mCustomClip) {
 60815:     // We don't support custom clips and rounded corners, arguably a bug, but
 60815:     // table painting seems to depend on it.
 60815:     return;
 60815:   }
 60815: 
 25276:   // If we have rounded corners, clip all subsequent drawing to the
 25276:   // rounded rectangle defined by bgArea and bgRadii (we don't know
 25276:   // whether the rounded corners intrude on the dirtyRect or not).
 25276:   // Do not do this if we have a caller-provided clip rect --
 25276:   // as above with bgArea, arguably a bug, but table painting seems
 25276:   // to depend on it.
 25276: 
 25276:   if (aHaveRoundedCorners) {
 52135:     gfxRect bgAreaGfx =
 60815:       nsLayoutUtils::RectToGfxRect(aClipState.mBGClipArea, aAppUnitsPerPixel);
 25276:     bgAreaGfx.Round();
 25276:     bgAreaGfx.Condition();
 25276: 
 25276:     if (bgAreaGfx.IsEmpty()) {
 25276:       // I think it's become possible to hit this since
 25276:       // http://hg.mozilla.org/mozilla-central/rev/50e934e4979b landed.
 25276:       NS_WARNING("converted background area should not be empty");
 25276:       // Make our caller not do anything.
 68632:       aClipState.mDirtyRectGfx.SizeTo(gfxSize(0.0, 0.0));
 25276:       return;
 25276:     }
 25276: 
 25276:     aAutoSR->Reset(aCtx);
 25276:     aCtx->NewPath();
 60815:     aCtx->RoundedRectangle(bgAreaGfx, aClipState.mClippedRadii, aClipState.mRadiiAreOuter);
 25276:     aCtx->Clip();
 25276:   }
 25276: }
 25276: 
 60816: static void
 60816: DrawBackgroundColor(BackgroundClipState& aClipState, gfxContext *aCtx,
 79445:                     bool aHaveRoundedCorners, nscoord aAppUnitsPerPixel)
 60816: {
 60816:   if (aClipState.mDirtyRectGfx.IsEmpty()) {
 60816:     // Our caller won't draw anything under this condition, so no need
 60816:     // to set more up.
 60816:     return;
 60816:   }
 60816: 
 60816:   // We don't support custom clips and rounded corners, arguably a bug, but
 60816:   // table painting seems to depend on it.
 60816:   if (!aHaveRoundedCorners || aClipState.mCustomClip) {
 60816:     aCtx->NewPath();
 80486:     aCtx->Rectangle(aClipState.mDirtyRectGfx, true);
 60816:     aCtx->Fill();
 60816:     return;
 60816:   }
 60816: 
 60816:   gfxRect bgAreaGfx =
 60816:     nsLayoutUtils::RectToGfxRect(aClipState.mBGClipArea, aAppUnitsPerPixel);
 60816:   bgAreaGfx.Round();
 60816:   bgAreaGfx.Condition();
 60816: 
 60816:   if (bgAreaGfx.IsEmpty()) {
 60816:     // I think it's become possible to hit this since
 60816:     // http://hg.mozilla.org/mozilla-central/rev/50e934e4979b landed.
 60816:     NS_WARNING("converted background area should not be empty");
 60816:     // Make our caller not do anything.
 68632:     aClipState.mDirtyRectGfx.SizeTo(gfxSize(0.0, 0.0));
 60816:     return;
 60816:   }
 60816: 
 60816:   aCtx->Save();
 60816:   gfxRect dirty = bgAreaGfx.Intersect(aClipState.mDirtyRectGfx);
 60816: 
 60816:   aCtx->NewPath();
 80486:   aCtx->Rectangle(dirty, true);
 60816:   aCtx->Clip();
 60816: 
 60816:   aCtx->NewPath();
 60816:   aCtx->RoundedRectangle(bgAreaGfx, aClipState.mClippedRadii,
 60816:                          aClipState.mRadiiAreOuter);
 60816:   aCtx->Fill();
 60816:   aCtx->Restore();
 60816: }
 60816: 
 97536: nscolor
 97536: nsCSSRendering::DetermineBackgroundColor(nsPresContext* aPresContext,
 40177:                                          nsStyleContext* aStyleContext,
 29987:                                          nsIFrame* aFrame,
 79445:                                          bool& aDrawBackgroundImage,
 79445:                                          bool& aDrawBackgroundColor)
 29987: {
 80486:   aDrawBackgroundImage = true;
 80486:   aDrawBackgroundColor = true;
 29987: 
 29987:   if (aFrame->HonorPrintBackgroundSettings()) {
 30894:     aDrawBackgroundImage = aPresContext->GetBackgroundImageDraw();
 30894:     aDrawBackgroundColor = aPresContext->GetBackgroundColorDraw();
 29987:   }
 29987: 
 29987:   nscolor bgColor;
 30894:   if (aDrawBackgroundColor) {
 40178:     bgColor =
 40178:       aStyleContext->GetVisitedDependentColor(eCSSProperty_background_color);
 29987:     if (NS_GET_A(bgColor) == 0)
 80486:       aDrawBackgroundColor = false;
 29987:   } else {
 29987:     // If GetBackgroundColorDraw() is false, we are still expected to
 29987:     // draw color in the background of any frame that's not completely
 29987:     // transparent, but we are expected to use white instead of whatever
 29987:     // color was specified.
 29987:     bgColor = NS_RGB(255, 255, 255);
 40178:     if (aDrawBackgroundImage ||
 40178:         !aStyleContext->GetStyleBackground()->IsTransparent())
 80486:       aDrawBackgroundColor = true;
 29987:     else
 29987:       bgColor = NS_RGBA(0,0,0,0);
 29987:   }
 29987: 
 97537:   const nsStyleBackground *bg = aStyleContext->GetStyleBackground();
 97537: 
 97537:   // We can skip painting the background color if a background image is opaque.
 97537:   if (aDrawBackgroundColor &&
 97537:       bg->BottomLayer().mRepeat.mXRepeat == NS_STYLE_BG_REPEAT_REPEAT &&
 97537:       bg->BottomLayer().mRepeat.mYRepeat == NS_STYLE_BG_REPEAT_REPEAT &&
 97537:       bg->BottomLayer().mImage.IsOpaque()) {
 97537:     aDrawBackgroundColor = false;
 97537:   }
 97537: 
 29987:   return bgColor;
 29987: }
 29987: 
 30993: static gfxFloat
 30993: ConvertGradientValueToPixels(const nsStyleCoord& aCoord,
 34476:                              gfxFloat aFillLength,
 34476:                              PRInt32 aAppUnitsPerPixel)
 30993: {
 30993:   switch (aCoord.GetUnit()) {
 30993:     case eStyleUnit_Percent:
 34476:       return aCoord.GetPercentValue() * aFillLength;
 30993:     case eStyleUnit_Coord:
 34476:       return NSAppUnitsToFloatPixels(aCoord.GetCoordValue(), aAppUnitsPerPixel);
 53920:     case eStyleUnit_Calc: {
 53920:       const nsStyleCoord::Calc *calc = aCoord.GetCalcValue();
 53920:       return calc->mPercent * aFillLength +
 53920:              NSAppUnitsToFloatPixels(calc->mLength, aAppUnitsPerPixel);
 53920:     }
 30993:     default:
 30993:       NS_WARNING("Unexpected coord unit");
 30993:       return 0;
 30993:   }
 30993: }
 30993: 
 34476: // Given a box with size aBoxSize and origin (0,0), and an angle aAngle,
 34476: // and a starting point for the gradient line aStart, find the endpoint of
 34476: // the gradient line --- the intersection of the gradient line with a line
 34476: // perpendicular to aAngle that passes through the farthest corner in the
 34476: // direction aAngle.
 34476: static gfxPoint
 34476: ComputeGradientLineEndFromAngle(const gfxPoint& aStart,
 34476:                                 double aAngle,
 34476:                                 const gfxSize& aBoxSize)
 34476: {
 34476:   double dx = cos(-aAngle);
 34476:   double dy = sin(-aAngle);
 34476:   gfxPoint farthestCorner(dx > 0 ? aBoxSize.width : 0,
 34476:                           dy > 0 ? aBoxSize.height : 0);
 34476:   gfxPoint delta = farthestCorner - aStart;
 34476:   double u = delta.x*dy - delta.y*dx;
 34476:   return farthestCorner + gfxPoint(-u*dy, u*dx);
 34476: }
 34476: 
 34476: // Compute the start and end points of the gradient line for a linear gradient.
 34476: static void
 34476: ComputeLinearGradientLine(nsPresContext* aPresContext,
 34476:                           nsStyleGradient* aGradient,
 34476:                           const gfxSize& aBoxSize,
 34476:                           gfxPoint* aLineStart,
 34476:                           gfxPoint* aLineEnd)
 34476: {
 34476:   if (aGradient->mBgPosX.GetUnit() == eStyleUnit_None) {
 34476:     double angle;
 34476:     if (aGradient->mAngle.IsAngleValue()) {
 34476:       angle = aGradient->mAngle.GetAngleValueInRadians();
 34476:     } else {
 34476:       angle = -M_PI_2; // defaults to vertical gradient starting from top
 34476:     }
 34476:     gfxPoint center(aBoxSize.width/2, aBoxSize.height/2);
 34476:     *aLineEnd = ComputeGradientLineEndFromAngle(center, angle, aBoxSize);
 34476:     *aLineStart = gfxPoint(aBoxSize.width, aBoxSize.height) - *aLineEnd;
 80775:   } else if (aGradient->mToCorner) {
 80775:     float xSign = aGradient->mBgPosX.GetPercentValue() * 2 - 1;
 80775:     float ySign = 1 - aGradient->mBgPosY.GetPercentValue() * 2;
 80775:     double angle = atan2(ySign * aBoxSize.width, xSign * aBoxSize.height);
 80775:     gfxPoint center(aBoxSize.width/2, aBoxSize.height/2);
 80775:     *aLineEnd = ComputeGradientLineEndFromAngle(center, angle, aBoxSize);
 80775:     *aLineStart = gfxPoint(aBoxSize.width, aBoxSize.height) - *aLineEnd;
 34476:   } else {
 34476:     PRInt32 appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 34476:     *aLineStart = gfxPoint(
 34476:       ConvertGradientValueToPixels(aGradient->mBgPosX, aBoxSize.width,
 34476:                                    appUnitsPerPixel),
 34476:       ConvertGradientValueToPixels(aGradient->mBgPosY, aBoxSize.height,
 34476:                                    appUnitsPerPixel));
 34476:     if (aGradient->mAngle.IsAngleValue()) {
 34476:       double angle = aGradient->mAngle.GetAngleValueInRadians();
 34476:       *aLineEnd = ComputeGradientLineEndFromAngle(*aLineStart, angle, aBoxSize);
 34476:     } else {
 34476:       // No angle, the line end is just the reflection of the start point
 34476:       // through the center of the box
 34476:       *aLineEnd = gfxPoint(aBoxSize.width, aBoxSize.height) - *aLineStart;
 34476:     }
 34476:   }
 34476: }
 34476: 
 34476: // Compute the start and end points of the gradient line for a radial gradient.
 34476: // Also returns the horizontal and vertical radii defining the circle or
 34476: // ellipse to use.
 34476: static void
 34476: ComputeRadialGradientLine(nsPresContext* aPresContext,
 34476:                           nsStyleGradient* aGradient,
 34476:                           const gfxSize& aBoxSize,
 34476:                           gfxPoint* aLineStart,
 34476:                           gfxPoint* aLineEnd,
 34476:                           double* aRadiusX,
 34476:                           double* aRadiusY)
 34476: {
 34476:   if (aGradient->mBgPosX.GetUnit() == eStyleUnit_None) {
 34476:     // Default line start point is the center of the box
 34476:     *aLineStart = gfxPoint(aBoxSize.width/2, aBoxSize.height/2);
 34476:   } else {
 34476:     PRInt32 appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 34476:     *aLineStart = gfxPoint(
 34476:       ConvertGradientValueToPixels(aGradient->mBgPosX, aBoxSize.width,
 34476:                                    appUnitsPerPixel),
 34476:       ConvertGradientValueToPixels(aGradient->mBgPosY, aBoxSize.height,
 34476:                                    appUnitsPerPixel));
 34476:   }
 34476: 
 34476:   // Compute gradient shape: the x and y radii of an ellipse.
 34476:   double radiusX, radiusY;
 71173:   double leftDistance = NS_ABS(aLineStart->x);
 71173:   double rightDistance = NS_ABS(aBoxSize.width - aLineStart->x);
 71173:   double topDistance = NS_ABS(aLineStart->y);
 71173:   double bottomDistance = NS_ABS(aBoxSize.height - aLineStart->y);
 34476:   switch (aGradient->mSize) {
 34476:   case NS_STYLE_GRADIENT_SIZE_CLOSEST_SIDE:
 34476:     radiusX = NS_MIN(leftDistance, rightDistance);
 34476:     radiusY = NS_MIN(topDistance, bottomDistance);
 34476:     if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {
 34476:       radiusX = radiusY = NS_MIN(radiusX, radiusY);
 34476:     }
 34476:     break;
 34476:   case NS_STYLE_GRADIENT_SIZE_CLOSEST_CORNER: {
 34476:     // Compute x and y distances to nearest corner
 34476:     double offsetX = NS_MIN(leftDistance, rightDistance);
 34476:     double offsetY = NS_MIN(topDistance, bottomDistance);
 34476:     if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {
 34476:       radiusX = radiusY = NS_hypot(offsetX, offsetY);
 34476:     } else {
 34476:       // maintain aspect ratio
 34476:       radiusX = offsetX*M_SQRT2;
 34476:       radiusY = offsetY*M_SQRT2;
 34476:     }
 34476:     break;
 34476:   }
 34476:   case NS_STYLE_GRADIENT_SIZE_FARTHEST_SIDE:
 34476:     radiusX = NS_MAX(leftDistance, rightDistance);
 34476:     radiusY = NS_MAX(topDistance, bottomDistance);
 34476:     if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {
 34476:       radiusX = radiusY = NS_MAX(radiusX, radiusY);
 34476:     }
 34476:     break;
 34476:   case NS_STYLE_GRADIENT_SIZE_FARTHEST_CORNER: {
 34476:     // Compute x and y distances to nearest corner
 34476:     double offsetX = NS_MAX(leftDistance, rightDistance);
 34476:     double offsetY = NS_MAX(topDistance, bottomDistance);
 34476:     if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_CIRCULAR) {
 34476:       radiusX = radiusY = NS_hypot(offsetX, offsetY);
 34476:     } else {
 34476:       // maintain aspect ratio
 34476:       radiusX = offsetX*M_SQRT2;
 34476:       radiusY = offsetY*M_SQRT2;
 34476:     }
 34476:     break;
 34476:   }
 34476:   default:
 80486:     NS_ABORT_IF_FALSE(false, "unknown radial gradient sizing method");
 34476:   }
 34476:   *aRadiusX = radiusX;
 34476:   *aRadiusY = radiusY;
 34476: 
 34476:   double angle;
 34476:   if (aGradient->mAngle.IsAngleValue()) {
 34476:     angle = aGradient->mAngle.GetAngleValueInRadians();
 34476:   } else {
 34476:     // Default angle is 0deg
 34476:     angle = 0.0;
 34476:   }
 34476: 
 34476:   // The gradient line end point is where the gradient line intersects
 34476:   // the ellipse.
 34476:   *aLineEnd = *aLineStart + gfxPoint(radiusX*cos(-angle), radiusY*sin(-angle));
 34476: }
 34476: 
 34476: // A resolved color stop --- with a specific position along the gradient line,
 34476: // and a Thebes color
 34476: struct ColorStop {
 34476:   ColorStop(double aPosition, nscolor aColor) :
 34476:     mPosition(aPosition), mColor(aColor) {}
 34476:   double mPosition; // along the gradient line; 0=start, 1=end
 34476:   gfxRGBA mColor;
 34476: };
 34476: 
 34476: // Returns aFrac*aC2 + (1 - aFrac)*C1. The interpolation is done
 34476: // in unpremultiplied space, which is what SVG gradients and cairo
 34476: // gradients expect.
 34476: static gfxRGBA
 34476: InterpolateColor(const gfxRGBA& aC1, const gfxRGBA& aC2, double aFrac)
 34476: {
 34476:   double other = 1 - aFrac;
 34476:   return gfxRGBA(aC2.r*aFrac + aC1.r*other,
 34476:                  aC2.g*aFrac + aC1.g*other,
 34476:                  aC2.b*aFrac + aC1.b*other,
 34476:                  aC2.a*aFrac + aC1.a*other);
 34476: }
 34476: 
 37174: static nscoord
 37174: FindTileStart(nscoord aDirtyCoord, nscoord aTilePos, nscoord aTileDim)
 37174: {
 37174:   NS_ASSERTION(aTileDim > 0, "Non-positive tile dimension");
 75359:   double multiples = floor(double(aDirtyCoord - aTilePos)/aTileDim);
 37174:   return NSToCoordRound(multiples*aTileDim + aTilePos);
 37174: }
 37174: 
 30993: void
 30993: nsCSSRendering::PaintGradient(nsPresContext* aPresContext,
 68481:                               nsRenderingContext& aRenderingContext,
 30993:                               nsStyleGradient* aGradient,
 30993:                               const nsRect& aDirtyRect,
 30993:                               const nsRect& aOneCellArea,
 34476:                               const nsRect& aFillArea)
 30993: {
 96794:   SAMPLE_LABEL("nsCSSRendering", "PaintGradient");
 34476:   if (aOneCellArea.IsEmpty())
 34476:     return;
 34476: 
 30993:   gfxContext *ctx = aRenderingContext.ThebesContext();
 30993:   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 52135:   gfxRect oneCellArea =
 52135:     nsLayoutUtils::RectToGfxRect(aOneCellArea, appUnitsPerPixel);
 34476: 
 34476:   // Compute "gradient line" start and end relative to oneCellArea
 34476:   gfxPoint lineStart, lineEnd;
 34476:   double radiusX = 0, radiusY = 0; // for radial gradients only
 34476:   if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR) {
 68632:     ComputeLinearGradientLine(aPresContext, aGradient, oneCellArea.Size(),
 34476:                               &lineStart, &lineEnd);
 34476:   } else {
 68632:     ComputeRadialGradientLine(aPresContext, aGradient, oneCellArea.Size(),
 34476:                               &lineStart, &lineEnd, &radiusX, &radiusY);
 34476:   }
 34476:   gfxFloat lineLength = NS_hypot(lineEnd.x - lineStart.x,
 34476:                                  lineEnd.y - lineStart.y);
 34476: 
 34476:   NS_ABORT_IF_FALSE(aGradient->mStops.Length() >= 2,
 34476:                     "The parser should reject gradients with less than two stops");
 34476: 
 34476:   // Build color stop array and compute stop positions
 34476:   nsTArray<ColorStop> stops;
 34476:   // If there is a run of stops before stop i that did not have specified
 34476:   // positions, then this is the index of the first stop in that run, otherwise
 34476:   // it's -1.
 34476:   PRInt32 firstUnsetPosition = -1;
 34476:   for (PRUint32 i = 0; i < aGradient->mStops.Length(); ++i) {
 34476:     const nsStyleGradientStop& stop = aGradient->mStops[i];
 34476:     double position;
 34476:     switch (stop.mLocation.GetUnit()) {
 34476:     case eStyleUnit_None:
 34476:       if (i == 0) {
 34476:         // First stop defaults to position 0.0
 34476:         position = 0.0;
 34476:       } else if (i == aGradient->mStops.Length() - 1) {
 34476:         // Last stop defaults to position 1.0
 34476:         position = 1.0;
 34476:       } else {
 34476:         // Other stops with no specified position get their position assigned
 34476:         // later by interpolation, see below.
 34476:         // Remeber where the run of stops with no specified position starts,
 34476:         // if it starts here.
 34476:         if (firstUnsetPosition < 0) {
 34476:           firstUnsetPosition = i;
 34476:         }
 34476:         stops.AppendElement(ColorStop(0, stop.mColor));
 34476:         continue;
 34476:       }
 34476:       break;
 34476:     case eStyleUnit_Percent:
 34476:       position = stop.mLocation.GetPercentValue();
 34476:       break;
 34476:     case eStyleUnit_Coord:
 34476:       position = lineLength < 1e-6 ? 0.0 :
 34476:           stop.mLocation.GetCoordValue() / appUnitsPerPixel / lineLength;
 34476:       break;
 34476:     default:
 80486:       NS_ABORT_IF_FALSE(false, "Unknown stop position type");
 34476:     }
 34476: 
 34476:     if (i > 0) {
 34476:       // Prevent decreasing stop positions by advancing this position
 34476:       // to the previous stop position, if necessary
 34476:       position = NS_MAX(position, stops[i - 1].mPosition);
 34476:     }
 34476:     stops.AppendElement(ColorStop(position, stop.mColor));
 34476:     if (firstUnsetPosition > 0) {
 34476:       // Interpolate positions for all stops that didn't have a specified position
 34476:       double p = stops[firstUnsetPosition - 1].mPosition;
 34476:       double d = (stops[i].mPosition - p)/(i - firstUnsetPosition + 1);
 34476:       for (PRUint32 j = firstUnsetPosition; j < i; ++j) {
 34476:         p += d;
 34476:         stops[j].mPosition = p;
 34476:       }
 34476:       firstUnsetPosition = -1;
 34476:     }
 34476:   }
 34476: 
 34476:   // Eliminate negative-position stops if the gradient is radial.
 34476:   double firstStop = stops[0].mPosition;
 34476:   if (aGradient->mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR && firstStop < 0.0) {
 34476:     if (aGradient->mRepeating) {
 34476:       // Choose an instance of the repeated pattern that gives us all positive
 34476:       // stop-offsets.
 34476:       double lastStop = stops[stops.Length() - 1].mPosition;
 34476:       double stopDelta = lastStop - firstStop;
 34476:       // If all the stops are in approximately the same place then logic below
 34476:       // will kick in that makes us draw just the last stop color, so don't
 34476:       // try to do anything in that case. We certainly need to avoid
 34476:       // dividing by zero.
 34476:       if (stopDelta >= 1e-6) {
 75359:         double instanceCount = ceil(-firstStop/stopDelta);
 34476:         // Advance stops by instanceCount multiples of the period of the
 34476:         // repeating gradient.
 34476:         double offset = instanceCount*stopDelta;
 34476:         for (PRUint32 i = 0; i < stops.Length(); i++) {
 34476:           stops[i].mPosition += offset;
 34476:         }
 34476:       }
 34476:     } else {
 34476:       // Move negative-position stops to position 0.0. We may also need
 34476:       // to set the color of the stop to the color the gradient should have
 34476:       // at the center of the ellipse.
 34476:       for (PRUint32 i = 0; i < stops.Length(); i++) {
 34476:         double pos = stops[i].mPosition;
 34476:         if (pos < 0.0) {
 34476:           stops[i].mPosition = 0.0;
 34476:           // If this is the last stop, we don't need to adjust the color,
 34476:           // it will fill the entire area.
 34476:           if (i < stops.Length() - 1) {
 34476:             double nextPos = stops[i + 1].mPosition;
 34476:             // If nextPos is approximately equal to pos, then we don't
 34476:             // need to adjust the color of this stop because it's
 34476:             // not going to be displayed.
 34476:             // If nextPos is negative, we don't need to adjust the color of
 34476:             // this stop since it's not going to be displayed because
 34476:             // nextPos will also be moved to 0.0.
 34476:             if (nextPos >= 0.0 && nextPos - pos >= 1e-6) {
 34476:               // Compute how far the new position 0.0 is along the interval
 34476:               // between pos and nextPos.
 34476:               // XXX Color interpolation (in cairo, too) should use the
 34476:               // CSS 'color-interpolation' property!
 34476:               double frac = (0.0 - pos)/(nextPos - pos);
 34476:               stops[i].mColor =
 34476:                 InterpolateColor(stops[i].mColor, stops[i + 1].mColor, frac);
 34476:             }
 34476:           }
 34476:         }
 34476:       }
 34476:     }
 34476:     firstStop = stops[0].mPosition;
 34476:     NS_ABORT_IF_FALSE(firstStop >= 0.0, "Failed to fix stop offsets");
 34476:   }
 34476: 
 34476:   double lastStop = stops[stops.Length() - 1].mPosition;
 34476:   // Cairo gradients must have stop positions in the range [0, 1]. So,
 34476:   // stop positions will be normalized below by subtracting firstStop and then
 34476:   // multiplying by stopScale.
 34476:   double stopScale;
 34476:   double stopDelta = lastStop - firstStop;
 79445:   bool zeroRadius = aGradient->mShape != NS_STYLE_GRADIENT_SHAPE_LINEAR &&
 63570:                       (radiusX < 1e-6 || radiusY < 1e-6);
 63570:   if (stopDelta < 1e-6 || lineLength < 1e-6 || zeroRadius) {
 34476:     // Stops are all at the same place. Map all stops to 0.0.
 63570:     // For repeating radial gradients, or for any radial gradients with
 63570:     // a zero radius, we need to fill with the last stop color, so just set
 63570:     // both radii to 0.
 34476:     stopScale = 0.0;
 63570:     if (aGradient->mRepeating || zeroRadius) {
 34476:       radiusX = radiusY = 0.0;
 63570:     }
 34476:     lastStop = firstStop;
 34476:   } else {
 34476:     stopScale = 1.0/stopDelta;
 34476:   }
 34476: 
 34476:   // Create the gradient pattern.
 30993:   nsRefPtr<gfxPattern> gradientPattern;
 34476:   if (aGradient->mShape == NS_STYLE_GRADIENT_SHAPE_LINEAR) {
 34476:     // Compute the actual gradient line ends we need to pass to cairo after
 34476:     // stops have been normalized.
 34476:     gfxPoint gradientStart = lineStart + (lineEnd - lineStart)*firstStop;
 34476:     gfxPoint gradientEnd = lineStart + (lineEnd - lineStart)*lastStop;
 34476: 
 34476:     if (stopScale == 0.0) {
 34476:       // Stops are all at the same place. For repeating gradients, this will
 34476:       // just paint the last stop color. We don't need to do anything.
 34476:       // For non-repeating gradients, this should render as two colors, one
 34476:       // on each "side" of the gradient line segment, which is a point. All
 34476:       // our stops will be at 0.0; we just need to set the direction vector
 34476:       // correctly.
 34476:       gradientEnd = gradientStart + (lineEnd - lineStart);
 34476:     }
 34476: 
 34476:     gradientPattern = new gfxPattern(gradientStart.x, gradientStart.y,
 34476:                                      gradientEnd.x, gradientEnd.y);
 30993:   } else {
 34476:     NS_ASSERTION(firstStop >= 0.0,
 34476:                  "Negative stops not allowed for radial gradients");
 34476: 
 34476:     // To form an ellipse, we'll stretch a circle vertically, if necessary.
 34476:     // So our radii are based on radiusX.
 34476:     double innerRadius = radiusX*firstStop;
 34476:     double outerRadius = radiusX*lastStop;
 63570:     if (stopScale == 0.0) {
 63570:       // Stops are all at the same place.  See above (except we now have
 63570:       // the inside vs. outside of an ellipse).
 63570:       outerRadius = innerRadius + 1;
 63570:     }
 34476:     gradientPattern = new gfxPattern(lineStart.x, lineStart.y, innerRadius,
 34476:                                      lineStart.x, lineStart.y, outerRadius);
 72510:     if (radiusX != radiusY) {
 34476:       // Stretch the circles into ellipses vertically by setting a transform
 34476:       // in the pattern.
 34476:       // Recall that this is the transform from user space to pattern space.
 34476:       // So to stretch the ellipse by factor of P vertically, we scale
 34476:       // user coordinates by 1/P.
 34476:       gfxMatrix matrix;
 34476:       matrix.Translate(lineStart);
 34476:       matrix.Scale(1.0, radiusX/radiusY);
 34476:       matrix.Translate(-lineStart);
 34476:       gradientPattern->SetMatrix(matrix);
 34476:     }
 34476:   }
 72510:   if (gradientPattern->CairoStatus())
 30993:     return;
 30993: 
 34476:   // Now set normalized color stops in pattern.
 34476:   if (stopScale == 0.0) {
 63570:     // Non-repeating gradient with all stops in same place -> just add
 34476:     // first stop and last stop, both at position 0.
 63570:     // Repeating gradient with all stops in the same place, or radial
 63570:     // gradient with radius of 0 -> just paint the last stop color.
 63570:     if (!aGradient->mRepeating && !zeroRadius) {
 34476:       gradientPattern->AddColorStop(0.0, stops[0].mColor);
 34476:     }
 34476:     gradientPattern->AddColorStop(0.0, stops[stops.Length() - 1].mColor);
 34476:   } else {
 34476:     // Use all stops
 34476:     for (PRUint32 i = 0; i < stops.Length(); i++) {
 34476:       double pos = stopScale*(stops[i].mPosition - firstStop);
 34476:       gradientPattern->AddColorStop(pos, stops[i].mColor);
 34476:     }
 34476:   }
 34476: 
 34476:   // Set repeat mode. Default cairo extend mode is PAD.
 34476:   if (aGradient->mRepeating) {
 30993:     gradientPattern->SetExtend(gfxPattern::EXTEND_REPEAT);
 34476:   }
 34476: 
 34476:   // Paint gradient tiles. This isn't terribly efficient, but doing it this
 34476:   // way is simple and sure to get pixel-snapping right. We could speed things
 34476:   // up by drawing tiles into temporary surfaces and copying those to the
 34476:   // destination, but after pixel-snapping tiles may not all be the same size.
 34476:   nsRect dirty;
 37075:   if (!dirty.IntersectRect(aDirtyRect, aFillArea))
 37075:     return;
 37075: 
 52135:   gfxRect areaToFill =
 52135:     nsLayoutUtils::RectToGfxRect(aFillArea, appUnitsPerPixel);
 34476:   gfxMatrix ctm = ctx->CurrentMatrix();
 34476: 
 34476:   // xStart/yStart are the top-left corner of the top-left tile.
 37174:   nscoord xStart = FindTileStart(dirty.x, aOneCellArea.x, aOneCellArea.width);
 37174:   nscoord yStart = FindTileStart(dirty.y, aOneCellArea.y, aOneCellArea.height);
 34476:   nscoord xEnd = dirty.XMost();
 34476:   nscoord yEnd = dirty.YMost();
 34476:   // x and y are the top-left corner of the tile to draw
 34476:   for (nscoord y = yStart; y < yEnd; y += aOneCellArea.height) {
 34476:     for (nscoord x = xStart; x < xEnd; x += aOneCellArea.width) {
 34476:       // The coordinates of the tile
 52135:       gfxRect tileRect = nsLayoutUtils::RectToGfxRect(
 52135:                       nsRect(x, y, aOneCellArea.width, aOneCellArea.height),
 34476:                       appUnitsPerPixel);
 34476:       // The actual area to fill with this tile is the intersection of this
 34476:       // tile with the overall area we're supposed to be filling
 34476:       gfxRect fillRect = tileRect.Intersect(areaToFill);
 30993:       ctx->NewPath();
 68632:       ctx->Translate(tileRect.TopLeft());
 30993:       ctx->SetPattern(gradientPattern);
 80486:       ctx->Rectangle(fillRect - tileRect.TopLeft(), true);
 30993:       ctx->Fill();
 34476:       ctx->SetMatrix(ctm);
 34476:     }
 34476:   }
 30993: }
 30993: 
     1: void
     1: nsCSSRendering::PaintBackgroundWithSC(nsPresContext* aPresContext,
 68481:                                       nsRenderingContext& aRenderingContext,
     1:                                       nsIFrame* aForFrame,
     1:                                       const nsRect& aDirtyRect,
     1:                                       const nsRect& aBorderArea,
 40177:                                       nsStyleContext* aBackgroundSC,
     1:                                       const nsStyleBorder& aBorder,
 28800:                                       PRUint32 aFlags,
     1:                                       nsRect* aBGClipRect)
     1: {
     1:   NS_PRECONDITION(aForFrame,
     1:                   "Frame is expected to be provided to PaintBackground");
     1: 
     1:   // Check to see if we have an appearance defined.  If so, we let the theme
     1:   // renderer draw the background and bail out.
 23493:   // XXXzw this ignores aBGClipRect.
     1:   const nsStyleDisplay* displayData = aForFrame->GetStyleDisplay();
     1:   if (displayData->mAppearance) {
     1:     nsITheme *theme = aPresContext->GetTheme();
 23493:     if (theme && theme->ThemeSupportsWidget(aPresContext, aForFrame,
 23493:                                             displayData->mAppearance)) {
 47643:       nsRect drawing(aBorderArea);
 47643:       theme->GetWidgetOverflow(aPresContext->DeviceContext(),
 47643:                                aForFrame, displayData->mAppearance, &drawing);
 47643:       drawing.IntersectRect(drawing, aDirtyRect);
     1:       theme->DrawWidgetBackground(&aRenderingContext, aForFrame,
 47643:                                   displayData->mAppearance, aBorderArea,
 47643:                                   drawing);
     1:       return;
     1:     }
     1:   }
     1: 
 29987:   // For canvas frames (in the CSS sense) we draw the background color using
 29987:   // a solid color item that gets added in nsLayoutUtils::PaintFrame,
 47741:   // or nsSubDocumentFrame::BuildDisplayList (bug 488242). (The solid
 47741:   // color may be moved into nsDisplayCanvasBackground by
 47741:   // nsPresShell::AddCanvasBackgroundColorItem, and painted by
 47741:   // nsDisplayCanvasBackground directly.) Either way we don't need to
 47741:   // paint the background color here.
 79445:   bool isCanvasFrame = IsCanvasFrame(aForFrame);
 29987: 
 23493:   // Determine whether we are drawing background images and/or
 23493:   // background colors.
 79445:   bool drawBackgroundImage;
 79445:   bool drawBackgroundColor;
 29987: 
 97536:   nscolor bgColor = DetermineBackgroundColor(aPresContext,
 40177:                                              aBackgroundSC,
 29987:                                              aForFrame,
 30894:                                              drawBackgroundImage,
 31749:                                              drawBackgroundColor);
 23493: 
 23493:   // At this point, drawBackgroundImage and drawBackgroundColor are
 23493:   // true if and only if we are actually supposed to paint an image or
 23493:   // color into aDirtyRect, respectively.
 23493:   if (!drawBackgroundImage && !drawBackgroundColor)
 23493:     return;
 23493: 
 23493:   // Compute the outermost boundary of the area that might be painted.
 23493:   gfxContext *ctx = aRenderingContext.ThebesContext();
 23493:   nscoord appUnitsPerPixel = aPresContext->AppUnitsPerDevPixel();
 23493: 
 23493:   // Same coordinate space as aBorderArea & aBGClipRect
 23493:   gfxCornerSizes bgRadii;
 79445:   bool haveRoundedCorners;
 23493:   {
 23493:     nscoord radii[8];
 52132:     nsSize frameSize = aForFrame->GetSize();
 52132:     if (&aBorder == aForFrame->GetStyleBorder() &&
 52132:         frameSize == aBorderArea.Size()) {
 52132:       haveRoundedCorners = aForFrame->GetBorderRadii(radii);
 52132:     } else {
 52126:       haveRoundedCorners = nsIFrame::ComputeBorderRadii(aBorder.mBorderRadius,
 52132:                                    frameSize, aBorderArea.Size(),
 52130:                                    aForFrame->GetSkipSides(), radii);
 52132:     }
 23493:     if (haveRoundedCorners)
 52130:       ComputePixelRadii(radii, appUnitsPerPixel, &bgRadii);
 23493:   }
 23493: 
 25276:   // The 'bgClipArea' (used only by the image tiling logic, far below)
 25276:   // is the caller-provided aBGClipRect if any, or else the area
 25276:   // determined by the value of 'background-clip' in
 25276:   // SetupCurrentBackgroundClip.  (Arguably it should be the
 25276:   // intersection, but that breaks the table painter -- in particular,
 30894:   // taking the intersection breaks reftests/bugs/403249-1[ab].)
 40177:   const nsStyleBackground *bg = aBackgroundSC->GetStyleBackground();
 60815:   BackgroundClipState clipState;
 25276:   PRUint8 currentBackgroundClip;
 79445:   bool isSolidBorder;
 25276:   if (aBGClipRect) {
 60815:     clipState.mBGClipArea = *aBGClipRect;
 80486:     clipState.mCustomClip = true;
 60815:     SetupDirtyRects(clipState.mBGClipArea, aDirtyRect, appUnitsPerPixel,
 60815:                     &clipState.mDirtyRect, &clipState.mDirtyRectGfx);
 25276:   } else {
 23493:     // The background is rendered over the 'background-clip' area,
 23493:     // which is normally equal to the border area but may be reduced
 23493:     // to the padding area by CSS.  Also, if the border is solid, we
 23493:     // don't need to draw outside the padding area.  In either case,
 23493:     // if the borders are rounded, make sure we use the same inner
 23493:     // radii as the border code will.
 25276:     // The background-color is drawn based on the bottom
 25276:     // background-clip.
 40177:     currentBackgroundClip = bg->BottomLayer().mClip;
 28800:     isSolidBorder =
 34212:       (aFlags & PAINTBG_WILL_PAINT_BORDER) && IsOpaqueBorder(aBorder);
 83477:     if (isSolidBorder && currentBackgroundClip == NS_STYLE_BG_CLIP_BORDER) {
 83477:       // If we have rounded corners, we need to inflate the background
 83477:       // drawing area a bit to avoid seams between the border and
 83477:       // background.
 83477:       currentBackgroundClip = haveRoundedCorners ?
 83477:         NS_STYLE_BG_CLIP_MOZ_ALMOST_PADDING : NS_STYLE_BG_CLIP_PADDING;
 83477:     }
 60815: 
 60815:     GetBackgroundClip(ctx, currentBackgroundClip, aForFrame, aBorderArea,
 60815:                       aDirtyRect, haveRoundedCorners, bgRadii, appUnitsPerPixel,
 60815:                       &clipState);
 23493:   }
 23493: 
 23493:   // If we might be using a background color, go ahead and set it now.
 29987:   if (drawBackgroundColor && !isCanvasFrame)
 23493:     ctx->SetColor(gfxRGBA(bgColor));
 23493: 
 60815:   gfxContextAutoSaveRestore autoSR;
 60815: 
 23493:   // If there is no background image, draw a color.  (If there is
 23493:   // neither a background image nor a color, we wouldn't have gotten
 23493:   // this far.)
 23493:   if (!drawBackgroundImage) {
 60816:     if (!isCanvasFrame) {
 60816:       DrawBackgroundColor(clipState, ctx, haveRoundedCorners, appUnitsPerPixel);
 25276:     }
 25220:     return;
 25220:   }
 25220: 
 94919:   // Ensure we get invalidated for loads of the image.  We need to do
 94919:   // this here because this might be the only code that knows about the
 25231:   // association of the style data with the frame.
 94919:   aPresContext->SetupBackgroundImageLoaders(aForFrame, bg);
 25231: 
 25276:   // The background color is rendered over the entire dirty area,
 25276:   // even if the image isn't.
 29987:   if (drawBackgroundColor && !isCanvasFrame) {
 60816:     DrawBackgroundColor(clipState, ctx, haveRoundedCorners, appUnitsPerPixel);
 25276:   }
 25276: 
 25276:   if (drawBackgroundImage) {
 60816:     bool clipSet = false;
 40177:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
 40177:       const nsStyleBackground::Layer &layer = bg->mLayers[i];
 25276:       if (!aBGClipRect) {
 43355:         PRUint8 newBackgroundClip = layer.mClip;
 83477:         if (isSolidBorder && newBackgroundClip == NS_STYLE_BG_CLIP_BORDER) {
 83477:           newBackgroundClip = haveRoundedCorners ?
 83477:             NS_STYLE_BG_CLIP_MOZ_ALMOST_PADDING : NS_STYLE_BG_CLIP_PADDING;
 83477:         }
 60816:         if (currentBackgroundClip != newBackgroundClip || !clipSet) {
 25276:           currentBackgroundClip = newBackgroundClip;
 60816:           // If clipSet is false that means this is the bottom layer and we
 60816:           // already called GetBackgroundClip above and it stored its results
 60816:           // in clipState.
 60816:           if (clipSet) {
 60816:             GetBackgroundClip(ctx, currentBackgroundClip, aForFrame,
 60816:                               aBorderArea, aDirtyRect, haveRoundedCorners,
 60816:                               bgRadii, appUnitsPerPixel, &clipState);
 60816:           }
 60815:           SetupBackgroundClip(clipState, ctx, haveRoundedCorners,
 60815:                               appUnitsPerPixel, &autoSR);
 60816:           clipSet = true;
 60815:         }
 60815:       }
 60815:       if (!clipState.mDirtyRectGfx.IsEmpty()) {
 97536:         nsBackgroundLayerState state = PrepareBackgroundLayer(aPresContext, aForFrame,
 60815:             aFlags, aBorderArea, clipState.mBGClipArea, *bg, layer);
 59780:         if (!state.mFillArea.IsEmpty()) {
 59780:           state.mImageRenderer.Draw(aPresContext, aRenderingContext,
 59780:                                     state.mDestArea, state.mFillArea,
 60815:                                     state.mAnchor + aBorderArea.TopLeft(),
 60815:                                     clipState.mDirtyRect);
 59780:         }
 25276:       }
 25276:     }
 25276:   }
 25276: }
 25276: 
 79445: static inline bool
 62160: IsTransformed(nsIFrame* aForFrame, nsIFrame* aTopFrame)
 62160: {
 62160:   for (nsIFrame* f = aForFrame; f != aTopFrame; f = f->GetParent()) {
 62160:     if (f->IsTransformed()) {
 80486:       return true;
 80486:     }
 80486:   }
 80486:   return false;
 62160: }
 62160: 
 97536: nsBackgroundLayerState
 97536: nsCSSRendering::PrepareBackgroundLayer(nsPresContext* aPresContext,
 25276:                                        nsIFrame* aForFrame,
 32425:                                        PRUint32 aFlags,
 25276:                                        const nsRect& aBorderArea,
 25276:                                        const nsRect& aBGClipRect,
 25276:                                        const nsStyleBackground& aBackground,
 30509:                                        const nsStyleBackground::Layer& aLayer)
 25276: {
 30894:   /*
 30894:    * The background properties we need to keep in mind when drawing background
 30894:    * layers are:
 30894:    *
 30894:    *   background-image
 30894:    *   background-repeat
 30894:    *   background-attachment
 30894:    *   background-position
 43357:    *   background-clip
 43357:    *   background-origin
 43359:    *   background-size
 30894:    *   background-break (-moz-background-inline-policy)
 30894:    *
 30894:    * (background-color applies to the entire element and not to individual
 30894:    * layers, so it is irrelevant to this method.)
 30894:    *
 30894:    * These properties have the following dependencies upon each other when
 30894:    * determining rendering:
 30894:    *
 30894:    *   background-image
 30894:    *     no dependencies
 30894:    *   background-repeat
 30894:    *     no dependencies
 30894:    *   background-attachment
 30894:    *     no dependencies
 30894:    *   background-position
 30894:    *     depends upon background-size (for the image's scaled size) and
 30894:    *     background-break (for the background positioning area)
 30894:    *   background-clip
 30894:    *     no dependencies
 30894:    *   background-origin
 30894:    *     depends upon background-attachment (only in the case where that value
 30894:    *     is 'fixed')
 30894:    *   background-size
 30894:    *     depends upon background-break (for the background positioning area for
 30894:    *     resolving percentages), background-image (for the image's intrinsic
 30894:    *     size), background-repeat (if that value is 'round'), and
 30894:    *     background-origin (for the background painting area, when
 30894:    *     background-repeat is 'round')
 30894:    *   background-break
 30894:    *     depends upon background-origin (specifying how the boxes making up the
 30894:    *     background positioning area are determined)
 30894:    *
 30894:    * As a result of only-if dependencies we don't strictly do a topological
 30894:    * sort of the above properties when processing, but it's pretty close to one:
 30894:    *
 30894:    *   background-clip (by caller)
 30894:    *   background-image
 30894:    *   background-break, background-origin
 30894:    *   background-attachment (postfix for background-{origin,break} if 'fixed')
 30894:    *   background-size
 30894:    *   background-position
 30894:    *   background-repeat
 30894:    */
 30894: 
 32425:   PRUint32 irFlags = 0;
 59780:   if (aFlags & nsCSSRendering::PAINTBG_SYNC_DECODE_IMAGES) {
 97536:     irFlags |= nsImageRenderer::FLAG_SYNC_DECODE_IMAGES;
 97536:   }
 97536: 
 97536:   nsBackgroundLayerState state(aForFrame, &aLayer.mImage, irFlags);
 59780:   if (!state.mImageRenderer.PrepareImage()) {
 31749:     // There's no image or it's not ready to be painted.
 59780:     return state;
 31749:   }
 31749: 
 31749:   // Compute background origin area relative to aBorderArea now as we may need
 31749:   // it to compute the effective image size for a CSS gradient.
 30894:   nsRect bgPositioningArea(0, 0, 0, 0);
     1: 
     1:   nsIAtom* frameType = aForFrame->GetType();
 21323:   nsIFrame* geometryFrame = aForFrame;
 79483:   if (frameType == nsGkAtoms::inlineFrame) {
 30894:     // XXXjwalden Strictly speaking this is not quite faithful to how
 30894:     // background-break is supposed to interact with background-origin values,
 30894:     // but it's a non-trivial amount of work to make it fully conformant, and
 30894:     // until the specification is more finalized (and assuming background-break
 30894:     // even makes the cut) it doesn't make sense to hammer out exact behavior.
 25276:     switch (aBackground.mBackgroundInlinePolicy) {
     1:     case NS_STYLE_BG_INLINE_POLICY_EACH_BOX:
 30894:       bgPositioningArea = nsRect(nsPoint(0,0), aBorderArea.Size());
     1:       break;
     1:     case NS_STYLE_BG_INLINE_POLICY_BOUNDING_BOX:
 30894:       bgPositioningArea = gInlineBGData->GetBoundingRect(aForFrame);
     1:       break;
     1:     default:
     1:       NS_ERROR("Unknown background-inline-policy value!  "
     1:                "Please, teach me what to do.");
     1:     case NS_STYLE_BG_INLINE_POLICY_CONTINUOUS:
 30894:       bgPositioningArea = gInlineBGData->GetContinuousRect(aForFrame);
     1:       break;
     1:     }
 21323:   } else if (frameType == nsGkAtoms::canvasFrame) {
 77154:     geometryFrame = aForFrame->GetFirstPrincipalChild();
 26340:     // geometryFrame might be null if this canvas is a page created
 26340:     // as an overflow container (e.g. the in-flow content has already
 26340:     // finished and this page only displays the continuations of
 26340:     // absolutely positioned content).
 26340:     if (geometryFrame) {
 30894:       bgPositioningArea = geometryFrame->GetRect();
 26340:     }
 21323:   } else {
 30894:     bgPositioningArea = nsRect(nsPoint(0,0), aBorderArea.Size());
     1:   }
     1: 
     1:   // Background images are tiled over the 'background-clip' area
     1:   // but the origin of the tiling is based on the 'background-origin' area
 26340:   if (aLayer.mOrigin != NS_STYLE_BG_ORIGIN_BORDER && geometryFrame) {
 21323:     nsMargin border = geometryFrame->GetUsedBorder();
 43355:     if (aLayer.mOrigin != NS_STYLE_BG_ORIGIN_PADDING) {
 43355:       border += geometryFrame->GetUsedPadding();
 43355:       NS_ASSERTION(aLayer.mOrigin == NS_STYLE_BG_ORIGIN_CONTENT,
 43355:                    "unknown background-origin value");
 43355:     }
 21323:     geometryFrame->ApplySkipSides(border);
 30894:     bgPositioningArea.Deflate(border);
     1:   }
     1: 
 36902:   // For background-attachment:fixed backgrounds, we'll limit the area
 36902:   // where the background can be drawn to the viewport.
 36902:   nsRect bgClipRect = aBGClipRect;
 36902: 
     1:   // Compute the anchor point.
     1:   //
 21323:   // relative to aBorderArea.TopLeft() (which is where the top-left
 21323:   // of aForFrame's border-box will be rendered)
 59780:   nsPoint imageTopLeft;
 25276:   if (NS_STYLE_BG_ATTACHMENT_FIXED == aLayer.mAttachment) {
 47742:     aPresContext->SetHasFixedBackgroundFrame();
 47742: 
     1:     // If it's a fixed background attachment, then the image is placed
  3113:     // relative to the viewport, which is the area of the root frame
  3113:     // in a screen context or the page content frame in a print context.
  3113:     nsIFrame* topFrame =
     1:       aPresContext->PresShell()->FrameManager()->GetRootFrame();
  3113:     NS_ASSERTION(topFrame, "no root frame");
 11257:     nsIFrame* pageContentFrame = nsnull;
     1:     if (aPresContext->IsPaginated()) {
 11257:       pageContentFrame =
  3113:         nsLayoutUtils::GetClosestFrameOfType(aForFrame, nsGkAtoms::pageContentFrame);
  3113:       if (pageContentFrame) {
  3113:         topFrame = pageContentFrame;
  3113:       }
  3113:       // else this is an embedded shell and its root frame is what we want
  3113:     }
  3113: 
 36902:     // Set the background positioning area to the viewport's area
 36902:     // (relative to aForFrame)
 36902:     bgPositioningArea = nsRect(-aForFrame->GetOffsetTo(topFrame), topFrame->GetSize());
 11257: 
 11257:     if (!pageContentFrame) {
 11257:       // Subtract the size of scrollbars.
 11257:       nsIScrollableFrame* scrollableFrame =
 11257:         aPresContext->PresShell()->GetRootScrollFrameAsScrollable();
 11257:       if (scrollableFrame) {
 11257:         nsMargin scrollbars = scrollableFrame->GetActualScrollbarSizes();
 30894:         bgPositioningArea.Deflate(scrollbars);
 11257:       }
 11257:     }
 11257: 
 62160:     if (aFlags & nsCSSRendering::PAINTBG_TO_WINDOW &&
 62160:         !IsTransformed(aForFrame, topFrame)) {
 36902:       // Clip background-attachment:fixed backgrounds to the viewport, if we're
 62160:       // painting to the screen and not transformed. This avoids triggering
 62160:       // tiling in common cases, without affecting output since drawing is
 62160:       // always clipped to the viewport when we draw to the screen. (But it's
 62160:       // not a pure optimization since it can affect the values of pixels at the
 62160:       // edge of the viewport --- whether they're sampled from a putative "next
 62160:       // tile" or not.)
 36902:       bgClipRect.IntersectRect(bgClipRect, bgPositioningArea + aBorderArea.TopLeft());
 36902:     }
 30894:   }
 30894: 
 30894:   // Scale the image as specified for background-size and as required for
 30894:   // proper background positioning when background-position is defined with
 30894:   // percentages.
 75061:   nsSize imageSize = state.mImageRenderer.ComputeSize(aLayer.mSize, bgPositioningArea.Size());
 75061:   if (imageSize.width <= 0 || imageSize.height <= 0)
 75061:     return state;
 30894: 
 30894:   // Compute the position of the background now that the background's size is
 30894:   // determined.
 30894:   ComputeBackgroundAnchorPoint(aLayer, bgPositioningArea.Size(), imageSize,
 59780:                                &imageTopLeft, &state.mAnchor);
 36902:   imageTopLeft += bgPositioningArea.TopLeft();
 59780:   state.mAnchor += bgPositioningArea.TopLeft();
 59780: 
 59780:   state.mDestArea = nsRect(imageTopLeft + aBorderArea.TopLeft(), imageSize);
 59780:   state.mFillArea = state.mDestArea;
 90982:   PRIntn repeatX = aLayer.mRepeat.mXRepeat;
 90982:   PRIntn repeatY = aLayer.mRepeat.mYRepeat;
 90982:   if (repeatX == NS_STYLE_BG_REPEAT_REPEAT) {
 59780:     state.mFillArea.x = bgClipRect.x;
 59780:     state.mFillArea.width = bgClipRect.width;
     1:   }
 90982:   if (repeatY == NS_STYLE_BG_REPEAT_REPEAT) {
 59780:     state.mFillArea.y = bgClipRect.y;
 59780:     state.mFillArea.height = bgClipRect.height;
 59780:   }
 59780:   state.mFillArea.IntersectRect(state.mFillArea, bgClipRect);
 59780:   return state;
 59780: }
 59780: 
 59780: nsRect
 59780: nsCSSRendering::GetBackgroundLayerRect(nsPresContext* aPresContext,
 59780:                                        nsIFrame* aForFrame,
 59780:                                        const nsRect& aBorderArea,
 59780:                                        const nsStyleBackground& aBackground,
 59780:                                        const nsStyleBackground::Layer& aLayer)
 59780: {
 97536:   nsBackgroundLayerState state =
 59780:       PrepareBackgroundLayer(aPresContext, aForFrame, 0, aBorderArea,
 59780:                              aBorderArea, aBackground, aLayer);
 59780:   return state.mFillArea;
 30993: }
     1: 
 19707: static void
 19707: DrawBorderImage(nsPresContext*       aPresContext,
 68481:                 nsRenderingContext&  aRenderingContext,
 25017:                 nsIFrame*            aForFrame,
 25017:                 const nsRect&        aBorderArea,
 34849:                 const nsStyleBorder& aStyleBorder,
 25017:                 const nsRect&        aDirtyRect)
 15992: {
 64663:   NS_PRECONDITION(aStyleBorder.IsBorderImageLoaded(),
 64663:                   "drawing border image that isn't successfully loaded");
 64663: 
 25017:   if (aDirtyRect.IsEmpty())
 25017:     return;
 24727: 
 25231:   // Ensure we get invalidated for loads and animations of the image.
 25231:   // We need to do this here because this might be the only code that
 25231:   // knows about the association of the style data with the frame.
 25231:   // XXX We shouldn't really... since if anybody is passing in a
 25231:   // different style, they'll potentially have the wrong size for the
 25231:   // border too.
 94919:   aPresContext->SetupBorderImageLoaders(aForFrame, &aStyleBorder);
 94919: 
 34849:   imgIRequest *req = aStyleBorder.GetBorderImage();
 25231: 
 86084:   // Get the actual image.
 25017: 
 25017:   nsCOMPtr<imgIContainer> imgContainer;
 25017:   req->GetImage(getter_AddRefs(imgContainer));
 64663:   NS_ASSERTION(imgContainer, "no image to draw");
 25017: 
 25017:   nsIntSize imageSize;
 52396:   if (NS_FAILED(imgContainer->GetWidth(&imageSize.width))) {
 52396:     imageSize.width =
 52396:       nsPresContext::AppUnitsToIntCSSPixels(aBorderArea.width);
 52396:   }
 52396:   if (NS_FAILED(imgContainer->GetHeight(&imageSize.height))) {
 52396:     imageSize.height =
 52396:       nsPresContext::AppUnitsToIntCSSPixels(aBorderArea.height);
 52396:   }
 25017: 
 86084:   // Determine the border image area, which by default corresponds to the
 86084:   // border box but can be modified by 'border-image-outset'.
 86084:   nsRect borderImgArea(aBorderArea);
 86084:   borderImgArea.Inflate(aStyleBorder.GetImageOutset());
 86084: 
 86084:   // Compute the used values of 'border-image-slice' and 'border-image-width';
 86084:   // we do them together because the latter can depend on the former.
 86084:   nsIntMargin slice;
 86084:   nsMargin border;
 25017:   NS_FOR_CSS_SIDES(s) {
 86084:     nsStyleCoord coord = aStyleBorder.mBorderImageSlice.Get(s);
 86084:     PRInt32 imgDimension = NS_SIDE_IS_VERTICAL(s)
 86084:                            ? imageSize.width : imageSize.height;
 86084:     nscoord borderDimension = NS_SIDE_IS_VERTICAL(s)
 86084:                            ? borderImgArea.width : borderImgArea.height;
 25017:     double value;
 25017:     switch (coord.GetUnit()) {
 25017:       case eStyleUnit_Percent:
 25017:         value = coord.GetPercentValue() * imgDimension;
 25017:         break;
 25017:       case eStyleUnit_Factor:
 25017:         value = coord.GetFactorValue();
 25017:         break;
 25017:       default:
 86084:         NS_NOTREACHED("unexpected CSS unit for image slice");
 25017:         value = 0;
 25017:         break;
 25017:     }
 25017:     if (value < 0)
 25017:       value = 0;
 25017:     if (value > imgDimension)
 25017:       value = imgDimension;
 86084:     slice.Side(s) = NS_lround(value);
 86084: 
 99855:     nsMargin borderWidths(aStyleBorder.GetComputedBorder());
 86084:     coord = aStyleBorder.mBorderImageWidth.Get(s);
 86084:     switch (coord.GetUnit()) {
 86084:       case eStyleUnit_Coord: // absolute dimension
 86084:         value = coord.GetCoordValue();
 86084:         break;
 86084:       case eStyleUnit_Percent:
 86084:         value = coord.GetPercentValue() * borderDimension;
 86084:         break;
 86084:       case eStyleUnit_Factor:
 86084:         value = coord.GetFactorValue() * borderWidths.Side(s);
 86084:         break;
 86084:       case eStyleUnit_Auto:  // same as the slice value, in CSS pixels
 86084:         value = nsPresContext::CSSPixelsToAppUnits(slice.Side(s));
 86084:         break;
 86084:       default:
 86084:         NS_NOTREACHED("unexpected CSS unit for border image area division");
 86084:         value = 0;
 86084:         break;
 86084:     }
 86084:     border.Side(s) = NS_lround(value);
 86084:   }
 86084: 
 86084:   // "If two opposite border-image-width offsets are large enough that they
 86084:   // overlap, their used values are proportionately reduced until they no
 86084:   // longer overlap."
 86084:   double scaleX = border.left + border.right > borderImgArea.width
 86084:                   ? borderImgArea.width / double(border.left + border.right)
 86084:                   : 1.0;
 86084:   double scaleY = border.top + border.bottom > borderImgArea.height
 86084:                   ? borderImgArea.height / double(border.top + border.bottom)
 86084:                   : 1.0;
 86084:   double scale = NS_MIN(scaleX, scaleY);
 86084:   if (scale < 1.0) {
 86084:     border.left *= scale;
 86084:     border.right *= scale;
 86084:     border.top *= scale;
 86084:     border.bottom *= scale;
 86084:     NS_ASSERTION(border.left + border.right <= borderImgArea.width &&
 86084:                  border.top + border.bottom <= borderImgArea.height,
 86084:                  "rounding error in width reduction???");
 86084:   }
 86084: 
 86084:   // These helper tables recharacterize the 'slice' and 'width' margins
 25017:   // in a more convenient form: they are the x/y/width/height coords
 25017:   // required for various bands of the border, and they have been transformed
 86084:   // to be relative to the innerRect (for 'slice') or the page (for 'border').
 25017:   enum {
 25017:     LEFT, MIDDLE, RIGHT,
 25017:     TOP = LEFT, BOTTOM = RIGHT
 25017:   };
 25017:   const nscoord borderX[3] = {
 86084:     borderImgArea.x + 0,
 86084:     borderImgArea.x + border.left,
 86084:     borderImgArea.x + borderImgArea.width - border.right,
 25017:   };
 25017:   const nscoord borderY[3] = {
 86084:     borderImgArea.y + 0,
 86084:     borderImgArea.y + border.top,
 86084:     borderImgArea.y + borderImgArea.height - border.bottom,
 25017:   };
 25017:   const nscoord borderWidth[3] = {
 25017:     border.left,
 86084:     borderImgArea.width - border.left - border.right,
 25017:     border.right,
 25017:   };
 25017:   const nscoord borderHeight[3] = {
 25017:     border.top,
 86084:     borderImgArea.height - border.top - border.bottom,
 25017:     border.bottom,
 25017:   };
 86084:   const PRInt32 sliceX[3] = {
 30479:     0,
 86084:     slice.left,
 86084:     imageSize.width - slice.right,
 25017:   };
 86084:   const PRInt32 sliceY[3] = {
 30479:     0,
 86084:     slice.top,
 86084:     imageSize.height - slice.bottom,
 25017:   };
 86084:   const PRInt32 sliceWidth[3] = {
 86084:     slice.left,
 86084:     PR_MAX(imageSize.width - slice.left - slice.right, 0),
 86084:     slice.right,
 25017:   };
 86084:   const PRInt32 sliceHeight[3] = {
 86084:     slice.top,
 86084:     PR_MAX(imageSize.height - slice.top - slice.bottom, 0),
 86084:     slice.bottom,
 25017:   };
 25017: 
 25416:   // In all the 'factor' calculations below, 'border' measurements are
 86084:   // in app units but 'slice' measurements are in image/CSS pixels, so
 25416:   // the factor corresponding to no additional scaling is
 25416:   // CSSPixelsToAppUnits(1), not simply 1.
 25017:   for (int i = LEFT; i <= RIGHT; i++) {
 25017:     for (int j = TOP; j <= BOTTOM; j++) {
 25017:       nsRect destArea(borderX[i], borderY[j], borderWidth[i], borderHeight[j]);
 86084:       nsIntRect subArea(sliceX[i], sliceY[j], sliceWidth[i], sliceHeight[j]);
 25017: 
 25271:       PRUint8 fillStyleH, fillStyleV;
 25271:       nsSize unitSize;
 25190: 
 25017:       if (i == MIDDLE && j == MIDDLE) {
 86084:         // Discard the middle portion unless set to fill.
 86084:         if (NS_STYLE_BORDER_IMAGE_SLICE_NOFILL ==
 86084:             aStyleBorder.mBorderImageFill) {
 86084:           continue;
 86084:         }
 86084: 
 86084:         NS_ASSERTION(NS_STYLE_BORDER_IMAGE_SLICE_FILL ==
 86084:                      aStyleBorder.mBorderImageFill,
 86084:                      "Unexpected border image fill");
 86084: 
 25271:         // css-background:
 25416:         //     The middle image's width is scaled by the same factor as the
 25416:         //     top image unless that factor is zero or infinity, in which
 25416:         //     case the scaling factor of the bottom is substituted, and
 25416:         //     failing that, the width is not scaled. The height of the
 25416:         //     middle image is scaled by the same factor as the left image
 25416:         //     unless that factor is zero or infinity, in which case the
 25416:         //     scaling factor of the right image is substituted, and failing
 25416:         //     that, the height is not scaled.
 25271:         gfxFloat hFactor, vFactor;
 25271: 
 86084:         if (0 < border.left && 0 < slice.left)
 86084:           vFactor = gfxFloat(border.left)/slice.left;
 86084:         else if (0 < border.right && 0 < slice.right)
 86084:           vFactor = gfxFloat(border.right)/slice.right;
 25271:         else
 25416:           vFactor = nsPresContext::CSSPixelsToAppUnits(1);
 25271: 
 86084:         if (0 < border.top && 0 < slice.top)
 86084:           hFactor = gfxFloat(border.top)/slice.top;
 86084:         else if (0 < border.bottom && 0 < slice.bottom)
 86084:           hFactor = gfxFloat(border.bottom)/slice.bottom;
 25271:         else
 25416:           hFactor = nsPresContext::CSSPixelsToAppUnits(1);
 25271: 
 86084:         unitSize.width = sliceWidth[i]*hFactor;
 86084:         unitSize.height = sliceHeight[j]*vFactor;
 86084:         fillStyleH = aStyleBorder.mBorderImageRepeatH;
 86084:         fillStyleV = aStyleBorder.mBorderImageRepeatV;
 25271: 
 25271:       } else if (i == MIDDLE) { // top, bottom
 25271:         // Sides are always stretched to the thickness of their border,
 25271:         // and stretched proportionately on the other axis.
 25416:         gfxFloat factor;
 86084:         if (0 < borderHeight[j] && 0 < sliceHeight[j])
 86084:           factor = gfxFloat(borderHeight[j])/sliceHeight[j];
 25416:         else
 25416:           factor = nsPresContext::CSSPixelsToAppUnits(1);
 25271: 
 86084:         unitSize.width = sliceWidth[i]*factor;
 25017:         unitSize.height = borderHeight[j];
 86084:         fillStyleH = aStyleBorder.mBorderImageRepeatH;
 86084:         fillStyleV = NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH;
 25271: 
 25271:       } else if (j == MIDDLE) { // left, right
 25416:         gfxFloat factor;
 86084:         if (0 < borderWidth[i] && 0 < sliceWidth[i])
 86084:           factor = gfxFloat(borderWidth[i])/sliceWidth[i];
 25416:         else
 25416:           factor = nsPresContext::CSSPixelsToAppUnits(1);
 25271: 
 25017:         unitSize.width = borderWidth[i];
 86084:         unitSize.height = sliceHeight[j]*factor;
 86084:         fillStyleH = NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH;
 86084:         fillStyleV = aStyleBorder.mBorderImageRepeatV;
 25271: 
 25017:       } else {
 25271:         // Corners are always stretched to fit the corner.
 25017:         unitSize.width = borderWidth[i];
 25017:         unitSize.height = borderHeight[j];
 86084:         fillStyleH = NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH;
 86084:         fillStyleV = NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH;
 25017:       }
 25017: 
 26926:       DrawBorderImageComponent(aRenderingContext, aForFrame,
 30479:                                imgContainer, aDirtyRect,
 25017:                                destArea, subArea,
 34849:                                fillStyleH, fillStyleV,
 34849:                                unitSize, aStyleBorder, i * (RIGHT + 1) + j);
 25017:     }
 25017:   }
 25017: }
 25017: 
 25017: static void
 68481: DrawBorderImageComponent(nsRenderingContext&  aRenderingContext,
 26926:                          nsIFrame*            aForFrame,
 30479:                          imgIContainer*       aImage,
 25017:                          const nsRect&        aDirtyRect,
 25017:                          const nsRect&        aFill,
 25017:                          const nsIntRect&     aSrc,
 25017:                          PRUint8              aHFill,
 25017:                          PRUint8              aVFill,
 34849:                          const nsSize&        aUnitSize,
 34849:                          const nsStyleBorder& aStyleBorder,
 34849:                          PRUint8              aIndex)
 25017: {
 25017:   if (aFill.IsEmpty() || aSrc.IsEmpty())
 25017:     return;
 25017: 
 34849:   // Don't bother trying to cache sub images if the border image is animated
 80486:   // We can only sucessfully call GetAnimated() if we are fully decoded, so default to true
 79445:   bool animated = true;
 34849:   aImage->GetAnimated(&animated);
 34849: 
 30479:   nsCOMPtr<imgIContainer> subImage;
 34849:   if (animated || (subImage = aStyleBorder.GetSubImage(aIndex)) == 0) {
 32424:     if (NS_FAILED(aImage->ExtractFrame(imgIContainer::FRAME_CURRENT, aSrc,
 32424:                                        imgIContainer::FLAG_SYNC_DECODE,
 32424:                                        getter_AddRefs(subImage))))
 25017:       return;
 25017: 
 34849:     if (!animated)
 34849:       aStyleBorder.SetSubImage(aIndex, subImage);
 34849:   }
 34849: 
 26926:   gfxPattern::GraphicsFilter graphicsFilter =
 26926:     nsLayoutUtils::GetGraphicsFilterForFrame(aForFrame);
 26926: 
 25017:   // If we have no tiling in either direction, we can skip the intermediate
 25017:   // scaling step.
 86084:   if ((aHFill == NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH &&
 86084:        aVFill == NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH) ||
 25271:       (aUnitSize.width == aFill.width &&
 25271:        aUnitSize.height == aFill.height)) {
 25017:     nsLayoutUtils::DrawSingleImage(&aRenderingContext, subImage,
 26926:                                    graphicsFilter,
 32424:                                    aFill, aDirtyRect, imgIContainer::FLAG_NONE);
 24723:     return;
 24727:   }
 15992: 
 25017:   // Compute the scale and position of the master copy of the image.
 25017:   nsRect tile;
 25017:   switch (aHFill) {
 86084:   case NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH:
 25017:     tile.x = aFill.x;
 25017:     tile.width = aFill.width;
 25017:     break;
 86084:   case NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT:
 25017:     tile.x = aFill.x + aFill.width/2 - aUnitSize.width/2;
 25017:     tile.width = aUnitSize.width;
 25017:     break;
 86084:   case NS_STYLE_BORDER_IMAGE_REPEAT_ROUND:
 25017:     tile.x = aFill.x;
 25017:     tile.width = aFill.width / ceil(gfxFloat(aFill.width)/aUnitSize.width);
 25017:     break;
 24723:   default:
 25017:     NS_NOTREACHED("unrecognized border-image fill style");
 24723:   }
 24723: 
 25017:   switch (aVFill) {
 86084:   case NS_STYLE_BORDER_IMAGE_REPEAT_STRETCH:
 25017:     tile.y = aFill.y;
 25017:     tile.height = aFill.height;
 25017:     break;
 86084:   case NS_STYLE_BORDER_IMAGE_REPEAT_REPEAT:
 25017:     tile.y = aFill.y + aFill.height/2 - aUnitSize.height/2;
 25017:     tile.height = aUnitSize.height;
 25017:     break;
 86084:   case NS_STYLE_BORDER_IMAGE_REPEAT_ROUND:
 25017:     tile.y = aFill.y;
 25017:     tile.height = aFill.height/ceil(gfxFloat(aFill.height)/aUnitSize.height);
 25017:     break;
 25017:   default:
 25017:     NS_NOTREACHED("unrecognized border-image fill style");
 24723:   }
 24723: 
 26926:   nsLayoutUtils::DrawImage(&aRenderingContext, subImage, graphicsFilter,
 32424:                            tile, aFill, tile.TopLeft(), aDirtyRect,
 32424:                            imgIContainer::FLAG_NONE);
 15992: }
 15992: 
     1: // Begin table border-collapsing section
     1: // These functions were written to not disrupt the normal ones and yet satisfy some additional requirements
     1: // At some point, all functions should be unified to include the additional functionality that these provide
     1: 
     1: static nscoord
     1: RoundIntToPixel(nscoord aValue,
     1:                 nscoord aTwipsPerPixel,
 79445:                 bool    aRoundDown = false)
     1: {
     1:   if (aTwipsPerPixel <= 0)
     1:     // We must be rendering to a device that has a resolution greater than Twips!
     1:     // In that case, aValue is as accurate as it's going to get.
     1:     return aValue;
     1: 
     1:   nscoord halfPixel = NSToCoordRound(aTwipsPerPixel / 2.0f);
     1:   nscoord extra = aValue % aTwipsPerPixel;
     1:   nscoord finalValue = (!aRoundDown && (extra >= halfPixel)) ? aValue + (aTwipsPerPixel - extra) : aValue - extra;
     1:   return finalValue;
     1: }
     1: 
     1: static nscoord
     1: RoundFloatToPixel(float   aValue,
     1:                   nscoord aTwipsPerPixel,
 79445:                   bool    aRoundDown = false)
     1: {
     1:   return RoundIntToPixel(NSToCoordRound(aValue), aTwipsPerPixel, aRoundDown);
     1: }
     1: 
     1: static void
     1: SetPoly(const nsRect& aRect,
     1:         nsPoint*      poly)
     1: {
     1:   poly[0].x = aRect.x;
     1:   poly[0].y = aRect.y;
     1:   poly[1].x = aRect.x + aRect.width;
     1:   poly[1].y = aRect.y;
     1:   poly[2].x = aRect.x + aRect.width;
     1:   poly[2].y = aRect.y + aRect.height;
     1:   poly[3].x = aRect.x;
     1:   poly[3].y = aRect.y + aRect.height;
     1:   poly[4].x = aRect.x;
     1:   poly[4].y = aRect.y;
     1: }
     1: 
     1: static void
 68481: DrawSolidBorderSegment(nsRenderingContext& aContext,
     1:                        nsRect               aRect,
     1:                        nscoord              aTwipsPerPixel,
     1:                        PRUint8              aStartBevelSide = 0,
     1:                        nscoord              aStartBevelOffset = 0,
     1:                        PRUint8              aEndBevelSide = 0,
     1:                        nscoord              aEndBevelOffset = 0)
     1: {
     1: 
     1:   if ((aRect.width == aTwipsPerPixel) || (aRect.height == aTwipsPerPixel) ||
     1:       ((0 == aStartBevelOffset) && (0 == aEndBevelOffset))) {
     1:     // simple line or rectangle
     1:     if ((NS_SIDE_TOP == aStartBevelSide) || (NS_SIDE_BOTTOM == aStartBevelSide)) {
     1:       if (1 == aRect.height)
 68479:         aContext.DrawLine(aRect.TopLeft(), aRect.BottomLeft());
     1:       else
     1:         aContext.FillRect(aRect);
     1:     }
     1:     else {
     1:       if (1 == aRect.width)
 68479:         aContext.DrawLine(aRect.TopLeft(), aRect.TopRight());
     1:       else
     1:         aContext.FillRect(aRect);
     1:     }
     1:   }
     1:   else {
     1:     // polygon with beveling
     1:     nsPoint poly[5];
     1:     SetPoly(aRect, poly);
     1:     switch(aStartBevelSide) {
     1:     case NS_SIDE_TOP:
     1:       poly[0].x += aStartBevelOffset;
     1:       poly[4].x = poly[0].x;
     1:       break;
     1:     case NS_SIDE_BOTTOM:
     1:       poly[3].x += aStartBevelOffset;
     1:       break;
     1:     case NS_SIDE_RIGHT:
     1:       poly[1].y += aStartBevelOffset;
     1:       break;
     1:     case NS_SIDE_LEFT:
     1:       poly[0].y += aStartBevelOffset;
     1:       poly[4].y = poly[0].y;
     1:     }
     1: 
     1:     switch(aEndBevelSide) {
     1:     case NS_SIDE_TOP:
     1:       poly[1].x -= aEndBevelOffset;
     1:       break;
     1:     case NS_SIDE_BOTTOM:
     1:       poly[2].x -= aEndBevelOffset;
     1:       break;
     1:     case NS_SIDE_RIGHT:
     1:       poly[2].y -= aEndBevelOffset;
     1:       break;
     1:     case NS_SIDE_LEFT:
     1:       poly[3].y -= aEndBevelOffset;
     1:     }
     1: 
     1:     aContext.FillPolygon(poly, 5);
     1:   }
     1: 
     1: 
     1: }
     1: 
     1: static void
     1: GetDashInfo(nscoord  aBorderLength,
     1:             nscoord  aDashLength,
     1:             nscoord  aTwipsPerPixel,
     1:             PRInt32& aNumDashSpaces,
     1:             nscoord& aStartDashLength,
     1:             nscoord& aEndDashLength)
     1: {
     1:   aNumDashSpaces = 0;
     1:   if (aStartDashLength + aDashLength + aEndDashLength >= aBorderLength) {
     1:     aStartDashLength = aBorderLength;
     1:     aEndDashLength = 0;
     1:   }
     1:   else {
 24766:     aNumDashSpaces = (aBorderLength - aDashLength)/ (2 * aDashLength); // round down
     1:     nscoord extra = aBorderLength - aStartDashLength - aEndDashLength - (((2 * aNumDashSpaces) - 1) * aDashLength);
     1:     if (extra > 0) {
     1:       nscoord half = RoundIntToPixel(extra / 2, aTwipsPerPixel);
     1:       aStartDashLength += half;
     1:       aEndDashLength += (extra - half);
     1:     }
     1:   }
     1: }
     1: 
     1: void
 68481: nsCSSRendering::DrawTableBorderSegment(nsRenderingContext&     aContext,
     1:                                        PRUint8                  aBorderStyle,
     1:                                        nscolor                  aBorderColor,
     1:                                        const nsStyleBackground* aBGColor,
     1:                                        const nsRect&            aBorder,
     1:                                        PRInt32                  aAppUnitsPerCSSPixel,
     1:                                        PRUint8                  aStartBevelSide,
     1:                                        nscoord                  aStartBevelOffset,
     1:                                        PRUint8                  aEndBevelSide,
     1:                                        nscoord                  aEndBevelOffset)
     1: {
     1:   aContext.SetColor (aBorderColor);
     1: 
 79445:   bool horizontal = ((NS_SIDE_TOP == aStartBevelSide) || (NS_SIDE_BOTTOM == aStartBevelSide));
     1:   nscoord twipsPerPixel = NSIntPixelsToAppUnits(1, aAppUnitsPerCSSPixel);
  6770:   PRUint8 ridgeGroove = NS_STYLE_BORDER_STYLE_RIDGE;
     1: 
     1:   if ((twipsPerPixel >= aBorder.width) || (twipsPerPixel >= aBorder.height) ||
     1:       (NS_STYLE_BORDER_STYLE_DASHED == aBorderStyle) || (NS_STYLE_BORDER_STYLE_DOTTED == aBorderStyle)) {
     1:     // no beveling for 1 pixel border, dash or dot
     1:     aStartBevelOffset = 0;
     1:     aEndBevelOffset = 0;
     1:   }
     1: 
  9438:   gfxContext *ctx = aContext.ThebesContext();
     1:   gfxContext::AntialiasMode oldMode = ctx->CurrentAntialiasMode();
     1:   ctx->SetAntialiasMode(gfxContext::MODE_ALIASED);
     1: 
     1:   switch (aBorderStyle) {
     1:   case NS_STYLE_BORDER_STYLE_NONE:
     1:   case NS_STYLE_BORDER_STYLE_HIDDEN:
 80486:     //NS_ASSERTION(false, "style of none or hidden");
     1:     break;
     1:   case NS_STYLE_BORDER_STYLE_DOTTED:
     1:   case NS_STYLE_BORDER_STYLE_DASHED:
     1:     {
     1:       nscoord dashLength = (NS_STYLE_BORDER_STYLE_DASHED == aBorderStyle) ? DASH_LENGTH : DOT_LENGTH;
     1:       // make the dash length proportional to the border thickness
     1:       dashLength *= (horizontal) ? aBorder.height : aBorder.width;
     1:       // make the min dash length for the ends 1/2 the dash length
     1:       nscoord minDashLength = (NS_STYLE_BORDER_STYLE_DASHED == aBorderStyle)
     1:                               ? RoundFloatToPixel(((float)dashLength) / 2.0f, twipsPerPixel) : dashLength;
 32531:       minDashLength = NS_MAX(minDashLength, twipsPerPixel);
     1:       nscoord numDashSpaces = 0;
     1:       nscoord startDashLength = minDashLength;
     1:       nscoord endDashLength   = minDashLength;
     1:       if (horizontal) {
     1:         GetDashInfo(aBorder.width, dashLength, twipsPerPixel, numDashSpaces, startDashLength, endDashLength);
     1:         nsRect rect(aBorder.x, aBorder.y, startDashLength, aBorder.height);
   222:         DrawSolidBorderSegment(aContext, rect, twipsPerPixel);
     1:         for (PRInt32 spaceX = 0; spaceX < numDashSpaces; spaceX++) {
     1:           rect.x += rect.width + dashLength;
     1:           rect.width = (spaceX == (numDashSpaces - 1)) ? endDashLength : dashLength;
   222:           DrawSolidBorderSegment(aContext, rect, twipsPerPixel);
     1:         }
     1:       }
     1:       else {
     1:         GetDashInfo(aBorder.height, dashLength, twipsPerPixel, numDashSpaces, startDashLength, endDashLength);
     1:         nsRect rect(aBorder.x, aBorder.y, aBorder.width, startDashLength);
   222:         DrawSolidBorderSegment(aContext, rect, twipsPerPixel);
     1:         for (PRInt32 spaceY = 0; spaceY < numDashSpaces; spaceY++) {
     1:           rect.y += rect.height + dashLength;
     1:           rect.height = (spaceY == (numDashSpaces - 1)) ? endDashLength : dashLength;
   222:           DrawSolidBorderSegment(aContext, rect, twipsPerPixel);
     1:         }
     1:       }
     1:     }
     1:     break;
     1:   case NS_STYLE_BORDER_STYLE_GROOVE:
     1:     ridgeGroove = NS_STYLE_BORDER_STYLE_GROOVE; // and fall through to ridge
     1:   case NS_STYLE_BORDER_STYLE_RIDGE:
     1:     if ((horizontal && (twipsPerPixel >= aBorder.height)) ||
     1:         (!horizontal && (twipsPerPixel >= aBorder.width))) {
     1:       // a one pixel border
     1:       DrawSolidBorderSegment(aContext, aBorder, twipsPerPixel, aStartBevelSide, aStartBevelOffset,
     1:                              aEndBevelSide, aEndBevelOffset);
     1:     }
     1:     else {
     1:       nscoord startBevel = (aStartBevelOffset > 0)
 80486:                             ? RoundFloatToPixel(0.5f * (float)aStartBevelOffset, twipsPerPixel, true) : 0;
     1:       nscoord endBevel =   (aEndBevelOffset > 0)
 80486:                             ? RoundFloatToPixel(0.5f * (float)aEndBevelOffset, twipsPerPixel, true) : 0;
 41419:       mozilla::css::Side ridgeGrooveSide = (horizontal) ? NS_SIDE_TOP : NS_SIDE_LEFT;
 40178:       // FIXME: In theory, this should use the visited-dependent
 40178:       // background color, but I don't care.
     1:       aContext.SetColor (
     1:         MakeBevelColor(ridgeGrooveSide, ridgeGroove, aBGColor->mBackgroundColor, aBorderColor));
     1:       nsRect rect(aBorder);
     1:       nscoord half;
     1:       if (horizontal) { // top, bottom
     1:         half = RoundFloatToPixel(0.5f * (float)aBorder.height, twipsPerPixel);
     1:         rect.height = half;
     1:         if (NS_SIDE_TOP == aStartBevelSide) {
     1:           rect.x += startBevel;
     1:           rect.width -= startBevel;
     1:         }
     1:         if (NS_SIDE_TOP == aEndBevelSide) {
     1:           rect.width -= endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, rect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1:       }
     1:       else { // left, right
     1:         half = RoundFloatToPixel(0.5f * (float)aBorder.width, twipsPerPixel);
     1:         rect.width = half;
     1:         if (NS_SIDE_LEFT == aStartBevelSide) {
     1:           rect.y += startBevel;
     1:           rect.height -= startBevel;
     1:         }
     1:         if (NS_SIDE_LEFT == aEndBevelSide) {
     1:           rect.height -= endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, rect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1:       }
     1: 
     1:       rect = aBorder;
     1:       ridgeGrooveSide = (NS_SIDE_TOP == ridgeGrooveSide) ? NS_SIDE_BOTTOM : NS_SIDE_RIGHT;
 40178:       // FIXME: In theory, this should use the visited-dependent
 40178:       // background color, but I don't care.
     1:       aContext.SetColor (
     1:         MakeBevelColor(ridgeGrooveSide, ridgeGroove, aBGColor->mBackgroundColor, aBorderColor));
     1:       if (horizontal) {
     1:         rect.y = rect.y + half;
     1:         rect.height = aBorder.height - half;
     1:         if (NS_SIDE_BOTTOM == aStartBevelSide) {
     1:           rect.x += startBevel;
     1:           rect.width -= startBevel;
     1:         }
     1:         if (NS_SIDE_BOTTOM == aEndBevelSide) {
     1:           rect.width -= endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, rect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1:       }
     1:       else {
     1:         rect.x = rect.x + half;
     1:         rect.width = aBorder.width - half;
     1:         if (NS_SIDE_RIGHT == aStartBevelSide) {
     1:           rect.y += aStartBevelOffset - startBevel;
     1:           rect.height -= startBevel;
     1:         }
     1:         if (NS_SIDE_RIGHT == aEndBevelSide) {
     1:           rect.height -= endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, rect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1:       }
     1:     }
     1:     break;
     1:   case NS_STYLE_BORDER_STYLE_DOUBLE:
 69337:     // We can only do "double" borders if the thickness of the border
 69337:     // is more than 2px.  Otherwise, we fall through to painting a
 69337:     // solid border.
 69337:     if ((aBorder.width > 2*twipsPerPixel || horizontal) &&
 69337:         (aBorder.height > 2*twipsPerPixel || !horizontal)) {
     1:       nscoord startBevel = (aStartBevelOffset > 0)
     1:                             ? RoundFloatToPixel(0.333333f * (float)aStartBevelOffset, twipsPerPixel) : 0;
     1:       nscoord endBevel =   (aEndBevelOffset > 0)
     1:                             ? RoundFloatToPixel(0.333333f * (float)aEndBevelOffset, twipsPerPixel) : 0;
     1:       if (horizontal) { // top, bottom
     1:         nscoord thirdHeight = RoundFloatToPixel(0.333333f * (float)aBorder.height, twipsPerPixel);
     1: 
     1:         // draw the top line or rect
     1:         nsRect topRect(aBorder.x, aBorder.y, aBorder.width, thirdHeight);
     1:         if (NS_SIDE_TOP == aStartBevelSide) {
     1:           topRect.x += aStartBevelOffset - startBevel;
     1:           topRect.width -= aStartBevelOffset - startBevel;
     1:         }
     1:         if (NS_SIDE_TOP == aEndBevelSide) {
     1:           topRect.width -= aEndBevelOffset - endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, topRect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1: 
     1:         // draw the botom line or rect
     1:         nscoord heightOffset = aBorder.height - thirdHeight;
     1:         nsRect bottomRect(aBorder.x, aBorder.y + heightOffset, aBorder.width, aBorder.height - heightOffset);
     1:         if (NS_SIDE_BOTTOM == aStartBevelSide) {
     1:           bottomRect.x += aStartBevelOffset - startBevel;
     1:           bottomRect.width -= aStartBevelOffset - startBevel;
     1:         }
     1:         if (NS_SIDE_BOTTOM == aEndBevelSide) {
     1:           bottomRect.width -= aEndBevelOffset - endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, bottomRect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1:       }
     1:       else { // left, right
     1:         nscoord thirdWidth = RoundFloatToPixel(0.333333f * (float)aBorder.width, twipsPerPixel);
     1: 
     1:         nsRect leftRect(aBorder.x, aBorder.y, thirdWidth, aBorder.height);
     1:         if (NS_SIDE_LEFT == aStartBevelSide) {
     1:           leftRect.y += aStartBevelOffset - startBevel;
     1:           leftRect.height -= aStartBevelOffset - startBevel;
     1:         }
     1:         if (NS_SIDE_LEFT == aEndBevelSide) {
     1:           leftRect.height -= aEndBevelOffset - endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, leftRect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1: 
     1:         nscoord widthOffset = aBorder.width - thirdWidth;
     1:         nsRect rightRect(aBorder.x + widthOffset, aBorder.y, aBorder.width - widthOffset, aBorder.height);
     1:         if (NS_SIDE_RIGHT == aStartBevelSide) {
     1:           rightRect.y += aStartBevelOffset - startBevel;
     1:           rightRect.height -= aStartBevelOffset - startBevel;
     1:         }
     1:         if (NS_SIDE_RIGHT == aEndBevelSide) {
     1:           rightRect.height -= aEndBevelOffset - endBevel;
     1:         }
     1:         DrawSolidBorderSegment(aContext, rightRect, twipsPerPixel, aStartBevelSide,
     1:                                startBevel, aEndBevelSide, endBevel);
     1:       }
     1:       break;
     1:     }
     1:     // else fall through to solid
     1:   case NS_STYLE_BORDER_STYLE_SOLID:
     1:     DrawSolidBorderSegment(aContext, aBorder, twipsPerPixel, aStartBevelSide,
     1:                            aStartBevelOffset, aEndBevelSide, aEndBevelOffset);
     1:     break;
     1:   case NS_STYLE_BORDER_STYLE_OUTSET:
     1:   case NS_STYLE_BORDER_STYLE_INSET:
 80486:     NS_ASSERTION(false, "inset, outset should have been converted to groove, ridge");
     1:     break;
     1:   case NS_STYLE_BORDER_STYLE_AUTO:
 80486:     NS_ASSERTION(false, "Unexpected 'auto' table border");
     1:     break;
     1:   }
     1: 
     1:   ctx->SetAntialiasMode(oldMode);
     1: }
     1: 
     1: // End table border-collapsing section
     1: 
  4302: void
  4302: nsCSSRendering::PaintDecorationLine(gfxContext* aGfxContext,
 78406:                                     const gfxRect& aDirtyRect,
  4302:                                     const nscolor aColor,
  4302:                                     const gfxPoint& aPt,
  4302:                                     const gfxSize& aLineSize,
  4302:                                     const gfxFloat aAscent,
  4302:                                     const gfxFloat aOffset,
  4302:                                     const PRUint8 aDecoration,
 26988:                                     const PRUint8 aStyle,
 26988:                                     const gfxFloat aDescentLimit)
  4302: {
 64457:   NS_ASSERTION(aStyle != NS_STYLE_TEXT_DECORATION_STYLE_NONE, "aStyle is none");
 26883: 
 11780:   gfxRect rect =
 11780:     GetTextDecorationRectInternal(aPt, aLineSize, aAscent, aOffset,
 26988:                                   aDecoration, aStyle, aDescentLimit);
 78406:   if (rect.IsEmpty() || !rect.Intersects(aDirtyRect)) {
  4302:     return;
 78406:   }
  4302: 
 68819:   if (aDecoration != NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE &&
 68819:       aDecoration != NS_STYLE_TEXT_DECORATION_LINE_OVERLINE &&
 68819:       aDecoration != NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH) {
 10161:     NS_ERROR("Invalid decoration value!");
 10161:     return;
 10161:   }
 10161: 
 32531:   gfxFloat lineHeight = NS_MAX(NS_round(aLineSize.height), 1.0);
 79445:   bool contextIsSaved = false;
 10161: 
 10161:   gfxFloat oldLineWidth;
 10161:   nsRefPtr<gfxPattern> oldPattern;
 10161: 
  4302:   switch (aStyle) {
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_SOLID:
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE:
 10161:       oldLineWidth = aGfxContext->CurrentLineWidth();
 10161:       oldPattern = aGfxContext->GetPattern();
  4302:       break;
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_DASHED: {
  4302:       aGfxContext->Save();
 80486:       contextIsSaved = true;
 26883:       aGfxContext->Clip(rect);
 11780:       gfxFloat dashWidth = lineHeight * DOT_LENGTH * DASH_LENGTH;
  4302:       gfxFloat dash[2] = { dashWidth, dashWidth };
  4302:       aGfxContext->SetLineCap(gfxContext::LINE_CAP_BUTT);
  4302:       aGfxContext->SetDash(dash, 2, 0.0);
 26883:       // We should continue to draw the last dash even if it is not in the rect.
 68634:       rect.width += dashWidth;
  4302:       break;
  4302:     }
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_DOTTED: {
  4302:       aGfxContext->Save();
 80486:       contextIsSaved = true;
 26883:       aGfxContext->Clip(rect);
 11780:       gfxFloat dashWidth = lineHeight * DOT_LENGTH;
  4302:       gfxFloat dash[2];
 11780:       if (lineHeight > 2.0) {
  4302:         dash[0] = 0.0;
  4302:         dash[1] = dashWidth * 2.0;
  4302:         aGfxContext->SetLineCap(gfxContext::LINE_CAP_ROUND);
  4302:       } else {
  4302:         dash[0] = dashWidth;
  4302:         dash[1] = dashWidth;
  4302:       }
  4302:       aGfxContext->SetDash(dash, 2, 0.0);
 26883:       // We should continue to draw the last dot even if it is not in the rect.
 68634:       rect.width += dashWidth;
  4302:       break;
  4302:     }
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_WAVY:
 26883:       aGfxContext->Save();
 80486:       contextIsSaved = true;
 26883:       aGfxContext->Clip(rect);
 26883:       if (lineHeight > 2.0) {
 26883:         aGfxContext->SetAntialiasMode(gfxContext::MODE_COVERAGE);
 26883:       } else {
 26883:         // Don't use anti-aliasing here.  Because looks like lighter color wavy
 26883:         // line at this case.  And probably, users don't think the
 26883:         // non-anti-aliased wavy line is not pretty.
 26883:         aGfxContext->SetAntialiasMode(gfxContext::MODE_ALIASED);
 26883:       }
 26883:       break;
  4302:     default:
  4302:       NS_ERROR("Invalid style value!");
  4302:       return;
  4302:   }
  4302: 
  4302:   // The y position should be set to the middle of the line.
 68634:   rect.y += lineHeight / 2;
  4302: 
  4302:   aGfxContext->SetColor(gfxRGBA(aColor));
 11780:   aGfxContext->SetLineWidth(lineHeight);
  4302:   switch (aStyle) {
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_SOLID:
  4302:       aGfxContext->NewPath();
 11780:       aGfxContext->MoveTo(rect.TopLeft());
 11780:       aGfxContext->LineTo(rect.TopRight());
  4302:       aGfxContext->Stroke();
  4302:       break;
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE:
 26883:       /**
 26883:        *  We are drawing double line as:
 26883:        *
 26883:        * +-------------------------------------------+
 26883:        * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| ^
 26883:        * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| | lineHeight
 26883:        * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| v
 26883:        * |                                           |
 26883:        * |                                           |
 26883:        * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| ^
 26883:        * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| | lineHeight
 26883:        * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| v
 26883:        * +-------------------------------------------+
 26883:        */
  4302:       aGfxContext->NewPath();
 11780:       aGfxContext->MoveTo(rect.TopLeft());
 11780:       aGfxContext->LineTo(rect.TopRight());
 68634:       rect.height -= lineHeight;
 11780:       aGfxContext->MoveTo(rect.BottomLeft());
 11780:       aGfxContext->LineTo(rect.BottomRight());
  4302:       aGfxContext->Stroke();
  4302:       break;
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_DOTTED:
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_DASHED:
  4302:       aGfxContext->NewPath();
 14010:       aGfxContext->MoveTo(rect.TopLeft());
 14010:       aGfxContext->LineTo(rect.TopRight());
  4302:       aGfxContext->Stroke();
  4302:       break;
 64457:     case NS_STYLE_TEXT_DECORATION_STYLE_WAVY: {
 26883:       /**
 26883:        *  We are drawing wavy line as:
 26883:        *
 26883:        *  P: Path, X: Painted pixel
 26883:        *
 26883:        *     +---------------------------------------+
 26883:        *   XX|X            XXXXXX            XXXXXX  |
 26883:        *   PP|PX          XPPPPPPX          XPPPPPPX |    ^
 26883:        *   XX|XPX        XPXXXXXXPX        XPXXXXXXPX|    |
 26883:        *     | XPX      XPX      XPX      XPX      XP|X   |adv
 26883:        *     |  XPXXXXXXPX        XPXXXXXXPX        X|PX  |
 26883:        *     |   XPPPPPPX          XPPPPPPX          |XPX v
 26883:        *     |    XXXXXX            XXXXXX           | XX
 26883:        *     +---------------------------------------+
 26883:        *      <---><--->                                ^
 26883:        *      adv  flatLengthAtVertex                   rightMost
 26883:        *
 26883:        *  1. Always starts from top-left of the drawing area, however, we need
 26883:        *     to draw  the line from outside of the rect.  Because the start
 26883:        *     point of the line is not good style if we draw from inside it.
 26883:        *  2. First, draw horizontal line from outside the rect to top-left of
 26883:        *     the rect;
 26883:        *  3. Goes down to bottom of the area at 45 degrees.
 26883:        *  4. Slides to right horizontaly, see |flatLengthAtVertex|.
 26883:        *  5. Goes up to top of the area at 45 degrees.
 26883:        *  6. Slides to right horizontaly.
 26883:        *  7. Repeat from 2 until reached to right-most edge of the area.
 26883:        */
 26883: 
 78406:       gfxFloat adv = rect.Height() - lineHeight;
 78406:       gfxFloat flatLengthAtVertex = NS_MAX((lineHeight - 1.0) * 2.0, 1.0);
 78406: 
 78406:       // figure out if we can trim whole cycles from the left and right edges
 78406:       // of the line, to try and avoid creating an unnecessarily long and
 78406:       // complex path
 78406:       gfxFloat cycleLength = 2 * (adv + flatLengthAtVertex);
 78406:       PRInt32 skipCycles = floor((aDirtyRect.x - rect.x) / cycleLength);
 78406:       if (skipCycles > 0) {
 78406:         rect.x += skipCycles * cycleLength;
 78406:         rect.width -= skipCycles * cycleLength;
 78406:       }
 78406: 
 68634:       rect.x += lineHeight / 2.0;
 68632:       gfxPoint pt(rect.TopLeft());
 26883:       gfxFloat rightMost = pt.x + rect.Width() + lineHeight;
 78406: 
 78406:       skipCycles = floor((rightMost - aDirtyRect.XMost()) / cycleLength);
 78406:       if (skipCycles > 0) {
 78406:         rightMost -= skipCycles * cycleLength;
 78406:       }
 78406: 
 78406:       aGfxContext->NewPath();
 26883: 
 26883:       pt.x -= lineHeight;
 26883:       aGfxContext->MoveTo(pt); // 1
 26883: 
 68632:       pt.x = rect.X();
 26883:       aGfxContext->LineTo(pt); // 2
 26883: 
 79445:       bool goDown = true;
 78406:       PRUint32 iter = 0;
 26883:       while (pt.x < rightMost) {
 78406:         if (++iter > 1000) {
 78406:           // stroke the current path and start again, to avoid pathological
 78406:           // behavior in cairo with huge numbers of path segments
 78406:           aGfxContext->Stroke();
 78406:           aGfxContext->NewPath();
 78406:           aGfxContext->MoveTo(pt);
 78406:           iter = 0;
 78406:         }
 26883:         pt.x += adv;
 26883:         pt.y += goDown ? adv : -adv;
 26883: 
 26883:         aGfxContext->LineTo(pt); // 3 and 5
 26883: 
 26883:         pt.x += flatLengthAtVertex;
 26883:         aGfxContext->LineTo(pt); // 4 and 6
 26883: 
 26883:         goDown = !goDown;
 26883:       }
 26883:       aGfxContext->Stroke();
 26883:       break;
 26883:     }
  4302:     default:
  4302:       NS_ERROR("Invalid style value!");
  4302:       break;
  4302:   }
 10161: 
 10161:   if (contextIsSaved) {
 10161:     aGfxContext->Restore();
 10161:   } else {
 10161:     aGfxContext->SetPattern(oldPattern);
 10161:     aGfxContext->SetLineWidth(oldLineWidth);
 10161:   }
 10161: }
 11780: 
 11780: nsRect
 11780: nsCSSRendering::GetTextDecorationRect(nsPresContext* aPresContext,
 11780:                                       const gfxSize& aLineSize,
 11780:                                       const gfxFloat aAscent,
 11780:                                       const gfxFloat aOffset,
 11780:                                       const PRUint8 aDecoration,
 26988:                                       const PRUint8 aStyle,
 26988:                                       const gfxFloat aDescentLimit)
 11780: {
 11780:   NS_ASSERTION(aPresContext, "aPresContext is null");
 64457:   NS_ASSERTION(aStyle != NS_STYLE_TEXT_DECORATION_STYLE_NONE, "aStyle is none");
 11780: 
 11780:   gfxRect rect =
 11780:     GetTextDecorationRectInternal(gfxPoint(0, 0), aLineSize, aAscent, aOffset,
 26988:                                   aDecoration, aStyle, aDescentLimit);
 11780:   // The rect values are already rounded to nearest device pixels.
 11780:   nsRect r;
 11780:   r.x = aPresContext->GfxUnitsToAppUnits(rect.X());
 11780:   r.y = aPresContext->GfxUnitsToAppUnits(rect.Y());
 11780:   r.width = aPresContext->GfxUnitsToAppUnits(rect.Width());
 11780:   r.height = aPresContext->GfxUnitsToAppUnits(rect.Height());
 11780:   return r;
 11780: }
 11780: 
 26883: gfxRect
 26883: nsCSSRendering::GetTextDecorationRectInternal(const gfxPoint& aPt,
 11780:                                               const gfxSize& aLineSize,
 11780:                                               const gfxFloat aAscent,
 11780:                                               const gfxFloat aOffset,
 11780:                                               const PRUint8 aDecoration,
 26988:                                               const PRUint8 aStyle,
 26988:                                               const gfxFloat aDescentLimit)
 11780: {
 64457:   NS_ASSERTION(aStyle <= NS_STYLE_TEXT_DECORATION_STYLE_WAVY,
 64457:                "Invalid aStyle value");
 64457: 
 64457:   if (aStyle == NS_STYLE_TEXT_DECORATION_STYLE_NONE)
 26883:     return gfxRect(0, 0, 0, 0);
 26883: 
 79445:   bool canLiftUnderline = aDescentLimit >= 0.0;
 26988: 
 75359:   const gfxFloat left  = floor(aPt.x + 0.5),
 75359:                  right = floor(aPt.x + aLineSize.width + 0.5);
 74794:   gfxRect r(left, 0, right - left, 0);
 11780: 
 26883:   gfxFloat lineHeight = NS_round(aLineSize.height);
 32531:   lineHeight = NS_MAX(lineHeight, 1.0);
 26988: 
 26988:   gfxFloat ascent = NS_round(aAscent);
 75359:   gfxFloat descentLimit = floor(aDescentLimit);
 26988: 
 32531:   gfxFloat suggestedMaxRectHeight = NS_MAX(NS_MIN(ascent, descentLimit), 1.0);
 68634:   r.height = lineHeight;
 64457:   if (aStyle == NS_STYLE_TEXT_DECORATION_STYLE_DOUBLE) {
 26883:     /**
 26883:      *  We will draw double line as:
 26883:      *
 26883:      * +-------------------------------------------+
 26883:      * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| ^
 26883:      * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| | lineHeight
 26883:      * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| v
 26883:      * |                                           | ^
 26883:      * |                                           | | gap
 26883:      * |                                           | v
 26883:      * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| ^
 26883:      * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| | lineHeight
 26883:      * |XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX| v
 26883:      * +-------------------------------------------+
 26883:      */
 26883:     gfxFloat gap = NS_round(lineHeight / 2.0);
 32531:     gap = NS_MAX(gap, 1.0);
 68634:     r.height = lineHeight * 2.0 + gap;
 26988:     if (canLiftUnderline) {
 26988:       if (r.Height() > suggestedMaxRectHeight) {
 26988:         // Don't shrink the line height, because the thickness has some meaning.
 26988:         // We can just shrink the gap at this time.
 68634:         r.height = NS_MAX(suggestedMaxRectHeight, lineHeight * 2.0 + 1.0);
 26988:       }
 26988:     }
 64457:   } else if (aStyle == NS_STYLE_TEXT_DECORATION_STYLE_WAVY) {
 26883:     /**
 26883:      *  We will draw wavy line as:
 26883:      *
 26883:      * +-------------------------------------------+
 26883:      * |XXXXX            XXXXXX            XXXXXX  | ^
 26883:      * |XXXXXX          XXXXXXXX          XXXXXXXX | | lineHeight
 26883:      * |XXXXXXX        XXXXXXXXXX        XXXXXXXXXX| v
 26883:      * |     XXX      XXX      XXX      XXX      XX|
 26883:      * |      XXXXXXXXXX        XXXXXXXXXX        X|
 26883:      * |       XXXXXXXX          XXXXXXXX          |
 26883:      * |        XXXXXX            XXXXXX           |
 26883:      * +-------------------------------------------+
 26883:      */
 68634:     r.height = lineHeight > 2.0 ? lineHeight * 4.0 : lineHeight * 3.0;
 26988:     if (canLiftUnderline) {
 26988:       if (r.Height() > suggestedMaxRectHeight) {
 26988:         // Don't shrink the line height even if there is not enough space,
 26988:         // because the thickness has some meaning.  E.g., the 1px wavy line and
 26988:         // 2px wavy line can be used for different meaning in IME selections
 26988:         // at same time.
 68634:         r.height = NS_MAX(suggestedMaxRectHeight, lineHeight * 2.0);
 26988:       }
 26988:     }
 11780:   }
 11780: 
 75359:   gfxFloat baseline = floor(aPt.y + aAscent + 0.5);
 26883:   gfxFloat offset = 0.0;
 11780:   switch (aDecoration) {
 68819:     case NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE:
 29850:       offset = aOffset;
 26988:       if (canLiftUnderline) {
 26988:         if (descentLimit < -offset + r.Height()) {
 26988:           // If we can ignore the offset and the decoration line is overflowing,
 26988:           // we should align the bottom edge of the decoration line rect if it's
 26988:           // possible.  Otherwise, we should lift up the top edge of the rect as
 26988:           // far as possible.
 26988:           gfxFloat offsetBottomAligned = -descentLimit + r.Height();
 29850:           gfxFloat offsetTopAligned = 0.0;
 32531:           offset = NS_MIN(offsetBottomAligned, offsetTopAligned);
 26988:         }
 26988:       }
 11780:       break;
 68819:     case NS_STYLE_TEXT_DECORATION_LINE_OVERLINE:
 26883:       offset = aOffset - lineHeight + r.Height();
 11780:       break;
 68819:     case NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH: {
 75359:       gfxFloat extra = floor(r.Height() / 2.0 + 0.5);
 32531:       extra = NS_MAX(extra, lineHeight);
 26883:       offset = aOffset - lineHeight + extra;
 11780:       break;
 11780:     }
 11780:     default:
 11780:       NS_ERROR("Invalid decoration value!");
 11780:   }
 75359:   r.y = baseline - floor(offset + 0.5);
 11780:   return r;
 11780: }
 15339: 
 31749: // ------------------
 31749: // ImageRenderer
 31749: // ------------------
 97536: nsImageRenderer::nsImageRenderer(nsIFrame* aForFrame,
 50816:                                  const nsStyleImage* aImage,
 32425:                                  PRUint32 aFlags)
 31749:   : mForFrame(aForFrame)
 31749:   , mImage(aImage)
 50816:   , mType(aImage->GetType())
 31749:   , mImageContainer(nsnull)
 31749:   , mGradientData(nsnull)
 50427:   , mPaintServerFrame(nsnull)
 80486:   , mIsReady(false)
 31749:   , mSize(0, 0)
 32425:   , mFlags(aFlags)
 31749: {
 31749: }
 31749: 
 97536: nsImageRenderer::~nsImageRenderer()
 31749: {
 31749: }
 31749: 
 79445: bool
 97536: nsImageRenderer::PrepareImage()
 31749: {
 50816:   if (mImage->IsEmpty() || !mImage->IsComplete()) {
 32424:     // Make sure the image is actually decoding
 50816:     mImage->RequestDecode();
 32424: 
 31749:     // We can not prepare the image for rendering if it is not fully loaded.
 32425:     //
 32425:     // Special case: If we requested a sync decode and we have an image, push
 32425:     // on through
 32425:     nsCOMPtr<imgIContainer> img;
 32425:     if (!((mFlags & FLAG_SYNC_DECODE_IMAGES) &&
 32425:           (mType == eStyleImageType_Image) &&
 50816:           (NS_SUCCEEDED(mImage->GetImageData()->GetImage(getter_AddRefs(img))) && img)))
 80486:       return false;
 31749:   }
 31749: 
 31749:   switch (mType) {
 31749:     case eStyleImageType_Image:
 31749:     {
 31749:       nsCOMPtr<imgIContainer> srcImage;
 50816:       mImage->GetImageData()->GetImage(getter_AddRefs(srcImage));
 50816:       NS_ABORT_IF_FALSE(srcImage, "If srcImage is null, mImage->IsComplete() "
 31749:                                   "should have returned false");
 31749: 
 50816:       if (!mImage->GetCropRect()) {
 31749:         mImageContainer.swap(srcImage);
 31749:       } else {
 31749:         nsIntRect actualCropRect;
 79445:         bool isEntireImage;
 79445:         bool success =
 50816:           mImage->ComputeActualCropRect(actualCropRect, &isEntireImage);
 31749:         NS_ASSERTION(success, "ComputeActualCropRect() should not fail here");
 31749:         if (!success || actualCropRect.IsEmpty()) {
 31749:           // The cropped image has zero size
 80486:           return false;
 31749:         }
 31749:         if (isEntireImage) {
 31749:           // The cropped image is identical to the source image
 31749:           mImageContainer.swap(srcImage);
 31749:         } else {
 31749:           nsCOMPtr<imgIContainer> subImage;
 32425:           PRUint32 aExtractFlags = (mFlags & FLAG_SYNC_DECODE_IMAGES)
 32425:                                      ? (PRUint32) imgIContainer::FLAG_SYNC_DECODE
 32425:                                      : (PRUint32) imgIContainer::FLAG_NONE;
 32424:           nsresult rv = srcImage->ExtractFrame(imgIContainer::FRAME_CURRENT,
 32425:                                                actualCropRect, aExtractFlags,
 31749:                                                getter_AddRefs(subImage));
 31749:           if (NS_FAILED(rv)) {
 31749:             NS_WARNING("The cropped image contains no pixels to draw; "
 31749:                        "maybe the crop rect is outside the image frame rect");
 80486:             return false;
 31749:           }
 31749:           mImageContainer.swap(subImage);
 31749:         }
 31749:       }
 80486:       mIsReady = true;
 31749:       break;
 31749:     }
 31749:     case eStyleImageType_Gradient:
 50816:       mGradientData = mImage->GetGradientData();
 80486:       mIsReady = true;
 31749:       break;
 50427:     case eStyleImageType_Element:
 50427:     {
 50427:       nsAutoString elementId =
 50816:         NS_LITERAL_STRING("#") + nsDependentString(mImage->GetElementId());
 50427:       nsCOMPtr<nsIURI> targetURI;
 50427:       nsCOMPtr<nsIURI> base = mForFrame->GetContent()->GetBaseURI();
 50427:       nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(targetURI), elementId,
 50427:                                                 mForFrame->GetContent()->GetCurrentDoc(), base);
 50427:       nsSVGPaintingProperty* property = nsSVGEffects::GetPaintingPropertyForURI(
 50427:           targetURI, mForFrame->GetFirstContinuation(),
 50427:           nsSVGEffects::BackgroundImageProperty());
 50427:       if (!property)
 80486:         return false;
 50427:       mPaintServerFrame = property->GetReferencedFrame();
 50427: 
 50427:       // If the referenced element doesn't have a frame we might still be able
 50427:       // to paint it if it's an <img>, <canvas>, or <video> element.
 50427:       if (!mPaintServerFrame) {
 83345:         mImageElementSurface =
 83345:           nsLayoutUtils::SurfaceFromElement(property->GetReferencedElement());
 50427:         if (!mImageElementSurface.mSurface)
 80486:           return false;
 80486:       }
 80486:       mIsReady = true;
 50427:       break;
 50427:     }
 31749:     case eStyleImageType_Null:
 31749:     default:
 31749:       break;
 31749:   }
 31749: 
 31749:   return mIsReady;
 31749: }
 31749: 
 75061: enum FitType { CONTAIN, COVER };
 75061: 
 75061: static nsSize
 75061: ComputeContainCoverSizeFromRatio(const nsSize& aBgPositioningArea,
 75061:                                  const nsSize& aRatio, FitType fitType)
 75061: {
 75061:   NS_ABORT_IF_FALSE(aRatio.width > 0, "width division by zero");
 75061:   NS_ABORT_IF_FALSE(aRatio.height > 0, "height division by zero");
 75061: 
 75061:   float scaleX = double(aBgPositioningArea.width) / aRatio.width;
 75061:   float scaleY = double(aBgPositioningArea.height) / aRatio.height;
 75061:   nsSize size;
 75061:   if ((fitType == CONTAIN) == (scaleX < scaleY)) {
 75061:     size.width = aBgPositioningArea.width;
 75061:     size.height = NSCoordSaturatingNonnegativeMultiply(aRatio.height, scaleX);
 75061:   } else {
 75061:     size.width = NSCoordSaturatingNonnegativeMultiply(aRatio.width, scaleY);
 75061:     size.height = aBgPositioningArea.height;
 75061:   }
 75061:   return size;
 75061: }
 75061: 
 75061: void
 97536: nsImageRenderer::ComputeUnscaledDimensions(const nsSize& aBgPositioningArea,
 75061:                                            nscoord& aUnscaledWidth, bool& aHaveWidth,
 75061:                                            nscoord& aUnscaledHeight, bool& aHaveHeight,
 75061:                                            nsSize& aRatio)
 31749: {
 31749:   NS_ASSERTION(mIsReady, "Ensure PrepareImage() has returned true "
 31749:                          "before calling me");
 31749: 
 31749:   switch (mType) {
 31749:     case eStyleImageType_Image:
 31749:     {
 31749:       nsIntSize imageIntSize;
 52215:       nsLayoutUtils::ComputeSizeForDrawing(mImageContainer, imageIntSize,
 75061:                                            aRatio, aHaveWidth, aHaveHeight);
 75061:       if (aHaveWidth) {
 75061:         aUnscaledWidth = nsPresContext::CSSPixelsToAppUnits(imageIntSize.width);
 75061:       }
 75061:       if (aHaveHeight) {
 75061:         aUnscaledHeight = nsPresContext::CSSPixelsToAppUnits(imageIntSize.height);
 75061:       }
 75061:       return;
 31749:     }
 31749:     case eStyleImageType_Gradient:
 75061:       // Per <http://dev.w3.org/csswg/css3-images/#gradients>, gradients have no
 75061:       // intrinsic dimensions.
 75061:       aHaveWidth = aHaveHeight = false;
 75061:       aRatio = nsSize(0, 0);
 75061:       return;
 50427:     case eStyleImageType_Element:
 50427:     {
 75061:       // XXX element() should have the width/height of the referenced element,
 75061:       //     and that element's ratio, if it matches.  If it doesn't match, it
 75061:       //     should have no width/height or ratio.  See element() in CSS3:
 75061:       //     <http://dev.w3.org/csswg/css3-images/#element-reference>.
 75061:       //     Make sure to change nsStyleBackground::Size::DependsOnFrameSize
 75061:       //     when fixing this!
 75061:       aHaveWidth = aHaveHeight = true;
 75061:       nsSize size;
 50427:       if (mPaintServerFrame) {
 50427:         if (mPaintServerFrame->IsFrameOfType(nsIFrame::eSVG)) {
 75061:           size = aBgPositioningArea;
 50427:         } else {
 50427:           // The intrinsic image size for a generic nsIFrame paint server is
 50427:           // the frame's bbox size rounded to device pixels.
 50427:           PRInt32 appUnitsPerDevPixel =
 50427:             mForFrame->PresContext()->AppUnitsPerDevPixel();
 50427:           nsRect rect =
 50427:             nsSVGIntegrationUtils::GetNonSVGUserSpace(mPaintServerFrame);
 75061:           nsRect rectSize = rect - rect.TopLeft();
 75061:           nsIntRect rounded = rectSize.ToNearestPixels(appUnitsPerDevPixel);
 75061:           size = rounded.ToAppUnits(appUnitsPerDevPixel).Size();
 50427:         }
 50427:       } else {
 50427:         NS_ASSERTION(mImageElementSurface.mSurface, "Surface should be ready.");
 75061:         gfxIntSize surfaceSize = mImageElementSurface.mSize;
 75061:         size.width = nsPresContext::CSSPixelsToAppUnits(surfaceSize.width);
 75061:         size.height = nsPresContext::CSSPixelsToAppUnits(surfaceSize.height);
 75061:       }
 75061:       aRatio = size;
 75061:       aUnscaledWidth = size.width;
 75061:       aUnscaledHeight = size.height;
 75061:       return;
 50427:     }
 31749:     case eStyleImageType_Null:
 31749:     default:
 75061:       aHaveWidth = aHaveHeight = true;
 75061:       aUnscaledWidth = aUnscaledHeight = 0;
 75061:       aRatio = nsSize(0, 0);
 75061:       return;
 75061:   }
 75061: }
 75061: 
 75061: nsSize
 97536: nsImageRenderer::ComputeDrawnSize(const nsStyleBackground::Size& aLayerSize,
 75061:                                   const nsSize& aBgPositioningArea,
 75061:                                   nscoord aUnscaledWidth, bool aHaveWidth,
 75061:                                   nscoord aUnscaledHeight, bool aHaveHeight,
 75061:                                   const nsSize& aIntrinsicRatio)
 75061: {
 75061:   NS_ABORT_IF_FALSE(aIntrinsicRatio.width >= 0,
 75061:                     "image ratio with nonsense width");
 75061:   NS_ABORT_IF_FALSE(aIntrinsicRatio.height >= 0,
 75061:                     "image ratio with nonsense height");
 75061: 
 75061:   // Bail early if the image is empty.
 75061:   if ((aHaveWidth && aUnscaledWidth <= 0) ||
 75061:       (aHaveHeight && aUnscaledHeight <= 0)) {
 75061:     return nsSize(0, 0);
 75061:   }
 75061: 
 75061:   // If the image has an intrinsic ratio but either component of it is zero,
 75061:   // then the image would eventually scale to nothingness, so again we can bail.
 75061:   bool haveRatio = aIntrinsicRatio != nsSize(0, 0);
 75061:   if (haveRatio &&
 75061:       (aIntrinsicRatio.width == 0 || aIntrinsicRatio.height == 0)) {
 75061:     return nsSize(0, 0);
 75061:   }
 75061: 
 75061:   // Easiest case: background-size completely specifies the size.
 75061:   if (aLayerSize.mWidthType == nsStyleBackground::Size::eLengthPercentage &&
 75061:       aLayerSize.mHeightType == nsStyleBackground::Size::eLengthPercentage) {
 75061:     return nsSize(aLayerSize.ResolveWidthLengthPercentage(aBgPositioningArea),
 75061:                   aLayerSize.ResolveHeightLengthPercentage(aBgPositioningArea));
 75061:   }
 75061: 
 75061:   // The harder cases: contain/cover.
 75061:   if (aLayerSize.mWidthType == nsStyleBackground::Size::eContain ||
 75061:       aLayerSize.mWidthType == nsStyleBackground::Size::eCover) {
 75061:     FitType fitType = aLayerSize.mWidthType == nsStyleBackground::Size::eCover
 75061:                     ? COVER
 75061:                     : CONTAIN;
 75061:     if (!haveRatio) {
 75061:       // If we don't have an intrinsic ratio, then proportionally scaling to
 75061:       // either largest-fitting or smallest-covering size means scaling to the
 75061:       // background positioning area's size.
 75061:       return aBgPositioningArea;
 75061:     }
 75061: 
 75061:     return ComputeContainCoverSizeFromRatio(aBgPositioningArea, aIntrinsicRatio,
 75061:                                             fitType);
 75061:   }
 75061: 
 75061:   // Harder case: all-auto.
 75061:   if (aLayerSize.mWidthType == nsStyleBackground::Size::eAuto &&
 75061:       aLayerSize.mHeightType == nsStyleBackground::Size::eAuto) {
 75061:     // If the image has all its dimensions, we're done.
 75061:     if (aHaveWidth && aHaveHeight)
 75061:       return nsSize(aUnscaledWidth, aUnscaledHeight);
 75061: 
 75061:     // If the image has no dimensions, treat it as if for contain.
 75061:     if (!aHaveWidth && !aHaveHeight) {
 75061:       if (!haveRatio) {
 75061:         // As above, max-contain without a ratio means the whole area.
 75061:         return aBgPositioningArea;
 75061:       }
 75061: 
 75061:       // Otherwise determine size using the intrinsic ratio.
 75061:       return ComputeContainCoverSizeFromRatio(aBgPositioningArea,
 75061:                                               aIntrinsicRatio, CONTAIN);
 75061:     }
 75061: 
 75061:     NS_ABORT_IF_FALSE(aHaveWidth != aHaveHeight, "logic error");
 75061: 
 75061:     if (haveRatio) {
 75061:       // Resolve missing dimensions using the intrinsic ratio.
 75061:       nsSize size;
 75061:       if (aHaveWidth) {
 75061:         size.width = aUnscaledWidth;
 75061:         size.height =
 75061:           NSCoordSaturatingNonnegativeMultiply(size.width,
 75061:                                                double(aIntrinsicRatio.height) /
 75061:                                                aIntrinsicRatio.width);
 75061:       } else {
 75061:         size.height = aUnscaledHeight;
 75061:         size.width =
 75061:           NSCoordSaturatingNonnegativeMultiply(size.height,
 75061:                                                double(aIntrinsicRatio.width) /
 75061:                                                aIntrinsicRatio.height);
 75061:       }
 75061: 
 75061:       return size;
 75061:     }
 75061: 
 75061:     // Without a ratio we must fall back to the relevant dimension of the
 75061:     // area to determine the missing dimension.
 75061:     return aHaveWidth ? nsSize(aUnscaledWidth, aBgPositioningArea.height)
 75061:                       : nsSize(aBgPositioningArea.width, aUnscaledHeight);
 75061:   }
 75061: 
 75061:   // Hardest case: only one auto.  Prepare to negotiate amongst intrinsic
 75061:   // dimensions, intrinsic ratio, *and* a specific background-size!
 75061:   NS_ABORT_IF_FALSE((aLayerSize.mWidthType == nsStyleBackground::Size::eAuto) !=
 75061:                     (aLayerSize.mHeightType == nsStyleBackground::Size::eAuto),
 75061:                     "logic error");
 75061: 
 75061:   bool isAutoWidth = aLayerSize.mWidthType == nsStyleBackground::Size::eAuto;
 75061: 
 75061:   if (haveRatio) {
 75061:     // Use the specified dimension, and compute the other from the ratio.
 75061:     NS_ABORT_IF_FALSE(aIntrinsicRatio.width > 0,
 75061:                       "ratio width out of sync with width?");
 75061:     NS_ABORT_IF_FALSE(aIntrinsicRatio.height > 0,
 75061:                       "ratio height out of sync with width?");
 75061:     nsSize size;
 75061:     if (isAutoWidth) {
 75061:       size.height = aLayerSize.ResolveHeightLengthPercentage(aBgPositioningArea);
 75061:       size.width =
 75061:         NSCoordSaturatingNonnegativeMultiply(size.height,
 75061:                                              double(aIntrinsicRatio.width) /
 75061:                                              aIntrinsicRatio.height);
 75061:     } else {
 75061:       size.width = aLayerSize.ResolveWidthLengthPercentage(aBgPositioningArea);
 75061:       size.height =
 75061:         NSCoordSaturatingNonnegativeMultiply(size.width,
 75061:                                              double(aIntrinsicRatio.height) /
 75061:                                              aIntrinsicRatio.width);
 75061:     }
 75061: 
 75061:     return size;
 75061:   }
 75061: 
 75061:   NS_ABORT_IF_FALSE(!(aHaveWidth && aHaveHeight),
 75061:                     "if we have width and height, we must have had a ratio");
 75061: 
 75061:   // We have a specified dimension and an auto dimension, with no ratio to
 75061:   // preserve.  A specified dimension trumps all, so use that.  For the other
 75061:   // dimension, resolve auto to the intrinsic dimension (if present) or to 100%.
 75061:   nsSize size;
 75061:   if (isAutoWidth) {
 75061:     size.width = aHaveWidth ? aUnscaledWidth : aBgPositioningArea.width;
 75061:     size.height = aLayerSize.ResolveHeightLengthPercentage(aBgPositioningArea);
 75061:   } else {
 75061:     size.width = aLayerSize.ResolveWidthLengthPercentage(aBgPositioningArea);
 75061:     size.height = aHaveHeight ? aUnscaledHeight : aBgPositioningArea.height;
 75061:   }
 75061: 
 75061:   return size;
 75061: }
 75061: 
 75061: /*
 75061:  * The size returned by this method differs from the value of mSize, which this
 75061:  * method also computes, in that mSize is the image's "preferred" size for this
 75061:  * particular rendering, while the size returned here is the actual rendered
 75061:  * size after accounting for background-size.  The preferred size is most often
 75061:  * the image's intrinsic dimensions.  But for images with incomplete intrinsic
 75061:  * dimensions, the preferred size varies, depending on the background
 75061:  * positioning area, the specified background-size, and the intrinsic ratio and
 75061:  * dimensions of the image (if it has them).
 75061:  *
 75061:  * This distinction is necessary because the components of a vector image are
 75061:  * specified with respect to its preferred size for a rendering situation, not
 75061:  * to its actual rendered size after background-size is applied.  For example,
 75061:  * consider a 4px wide vector image with no height which contains a left-aligned
 75061:  * 2px wide black rectangle with height 100%.  If the background-size width is
 75061:  * auto (or 4px), the vector image will render 4px wide, and the black rectangle
 75061:  * will be 2px wide.  If the background-size width is 8px, the vector image will
 75061:  * render 8px wide, and the black rectangle will be 4px wide -- *not* 2px wide.
 75061:  * In both cases mSize.width will be 4px; but in the first case the returned
 75061:  * width will be 4px, while in the second case the returned width will be 8px.
 75061:  */
 75061: nsSize
 97536: nsImageRenderer::ComputeSize(const nsStyleBackground::Size& aLayerSize,
 75061:                              const nsSize& aBgPositioningArea)
 75061: {
 75061:   bool haveWidth, haveHeight;
 75061:   nsSize ratio;
 75061:   nscoord unscaledWidth, unscaledHeight;
 75061:   ComputeUnscaledDimensions(aBgPositioningArea,
 75061:                             unscaledWidth, haveWidth,
 75061:                             unscaledHeight, haveHeight,
 75061:                             ratio);
 75061:   nsSize drawnSize = ComputeDrawnSize(aLayerSize, aBgPositioningArea,
 75061:                                       unscaledWidth, haveWidth,
 75061:                                       unscaledHeight, haveHeight,
 75061:                                       ratio);
 75061:   mSize.width = haveWidth ? unscaledWidth : drawnSize.width;
 75061:   mSize.height = haveHeight ? unscaledHeight : drawnSize.height;
 75061:   return drawnSize;
 31749: }
 31749: 
 31749: void
 97536: nsImageRenderer::Draw(nsPresContext*       aPresContext,
 68481:                       nsRenderingContext& aRenderingContext,
 31749:                       const nsRect&        aDest,
 31749:                       const nsRect&        aFill,
 31749:                       const nsPoint&       aAnchor,
 34476:                       const nsRect&        aDirty)
 31749: {
 31749:   if (!mIsReady) {
 31749:     NS_NOTREACHED("Ensure PrepareImage() has returned true before calling me");
 31749:     return;
 31749:   }
 31749: 
 50427:   if (aDest.IsEmpty() || aFill.IsEmpty() ||
 50427:       mSize.width <= 0 || mSize.height <= 0)
 31749:     return;
 31749: 
 50427:   gfxPattern::GraphicsFilter graphicsFilter =
 50427:     nsLayoutUtils::GetGraphicsFilterForFrame(mForFrame);
 50427: 
 31749:   switch (mType) {
 31749:     case eStyleImageType_Image:
 32425:     {
 32425:       PRUint32 drawFlags = (mFlags & FLAG_SYNC_DECODE_IMAGES)
 32425:                              ? (PRUint32) imgIContainer::FLAG_SYNC_DECODE
 32425:                              : (PRUint32) imgIContainer::FLAG_NONE;
 75061:       nsLayoutUtils::DrawBackgroundImage(&aRenderingContext, mImageContainer,
 75061:           nsIntSize(nsPresContext::AppUnitsToIntCSSPixels(mSize.width),
 75061:                     nsPresContext::AppUnitsToIntCSSPixels(mSize.height)),
 50427:           graphicsFilter,
 32425:           aDest, aFill, aAnchor, aDirty, drawFlags);
 31749:       break;
 32425:     }
 31749:     case eStyleImageType_Gradient:
 31749:       nsCSSRendering::PaintGradient(aPresContext, aRenderingContext,
 34476:           mGradientData, aDirty, aDest, aFill);
 31749:       break;
 50427:     case eStyleImageType_Element:
 50427:       if (mPaintServerFrame) {
 50427:         nsSVGIntegrationUtils::DrawPaintServer(
 50427:             &aRenderingContext, mForFrame, mPaintServerFrame, graphicsFilter,
 50427:             aDest, aFill, aAnchor, aDirty, mSize);
 50427:       } else {
 50427:         NS_ASSERTION(mImageElementSurface.mSurface, "Surface should be ready.");
 50427:         nsRefPtr<gfxDrawable> surfaceDrawable =
 50427:           new gfxSurfaceDrawable(mImageElementSurface.mSurface,
 50427:                                  mImageElementSurface.mSize);
 50427:         nsLayoutUtils::DrawPixelSnapped(
 50427:             &aRenderingContext, surfaceDrawable, graphicsFilter,
 50427:             aDest, aFill, aAnchor, aDirty);
 50427:       }
 50427:       break;
 31749:     case eStyleImageType_Null:
 31749:     default:
 31749:       break;
 31749:   }
 31749: }
 31749: 
 97536: bool
 97536: nsImageRenderer::IsRasterImage()
 97536: {
 97536:   if (mType != eStyleImageType_Image)
 97536:     return false;
 97536:   nsCOMPtr<imgIContainer> img;
 97536:   nsresult rv = mImage->GetImageData()->GetImage(getter_AddRefs(img));
 97536:   if (NS_FAILED(rv) || !img)
 97536:     return false;
 97536:   return img->GetType() == imgIContainer::TYPE_RASTER;
 97536: }
 97536: 
 97536: already_AddRefed<mozilla::layers::ImageContainer>
 97536: nsImageRenderer::GetContainer()
 97536: {
 97536:   nsCOMPtr<imgIContainer> img;
 97536:   nsresult rv = mImage->GetImageData()->GetImage(getter_AddRefs(img));
 97536:   if (NS_FAILED(rv) || !img)
 97536:     return nsnull;
 97536:   nsRefPtr<ImageContainer> container;
 97536:   rv = img->GetImageContainer(getter_AddRefs(container));
 97536:   NS_ENSURE_SUCCESS(rv, nsnull);
 97536:   return container.forget();
 97536: }
 97536: 
 39442: #define MAX_BLUR_RADIUS 300
 51264: #define MAX_SPREAD_RADIUS 50
 39442: 
 52476: static inline gfxIntSize
 99105: ComputeBlurRadius(nscoord aBlurRadius, PRInt32 aAppUnitsPerDevPixel, gfxFloat aScaleX = 1.0, gfxFloat aScaleY = 1.0)
 52476: {
 52476:   // http://dev.w3.org/csswg/css3-background/#box-shadow says that the
 52476:   // standard deviation of the blur should be half the given blur value.
 98901:   gfxFloat blurStdDev = gfxFloat(aBlurRadius) / gfxFloat(aAppUnitsPerDevPixel);
 98901: 
 99105:   gfxPoint scaledBlurStdDev = gfxPoint(NS_MIN((blurStdDev * aScaleX),
 99105:                                               gfxFloat(MAX_BLUR_RADIUS)) / 2.0,
 99105:                                        NS_MIN((blurStdDev * aScaleY),
 99105:                                               gfxFloat(MAX_BLUR_RADIUS)) / 2.0);
 52476:   return
 99105:     gfxAlphaBoxBlur::CalculateBlurRadius(scaledBlurStdDev);
 52476: }
 52476: 
 15339: // -----
 15339: // nsContextBoxBlur
 15339: // -----
 15339: gfxContext*
 51264: nsContextBoxBlur::Init(const nsRect& aRect, nscoord aSpreadRadius,
 51264:                        nscoord aBlurRadius,
 15339:                        PRInt32 aAppUnitsPerDevPixel,
 22183:                        gfxContext* aDestinationCtx,
 40965:                        const nsRect& aDirtyRect,
 51264:                        const gfxRect* aSkipRect,
 51264:                        PRUint32 aFlags)
 15339: {
 36887:   if (aRect.IsEmpty()) {
 36887:     mContext = nsnull;
 36887:     return nsnull;
 36887:   }
 36887: 
 99105:   gfxFloat scaleX = 1;
 99105:   gfxFloat scaleY = 1;
 98901: 
 99950:   // Do blurs in device space when possible.
 98901:   // Chrome/Skia always does the blurs in device space
 98901:   // and will sometimes get incorrect results (e.g. rotated blurs)
 98901:   gfxMatrix transform = aDestinationCtx->CurrentMatrix();
 99950:   // XXX: we could probably handle negative scales but for now it's easier just to fallback
 99950:   if (transform.HasNonAxisAlignedTransform() || transform.xx <= 0.0 || transform.yy <= 0.0) {
 98901:     transform = gfxMatrix();
 98901:   } else {
 99105:     scaleX = transform.xx;
 99105:     scaleY = transform.yy;
 98901:   }
 98901: 
 98901:   // compute a large or smaller blur radius
 99105:   gfxIntSize blurRadius = ComputeBlurRadius(aBlurRadius, aAppUnitsPerDevPixel, scaleX, scaleY);
 99105:   gfxIntSize spreadRadius = gfxIntSize(NS_MIN(PRInt32(aSpreadRadius * scaleX / aAppUnitsPerDevPixel),
 99105:                                               PRInt32(MAX_SPREAD_RADIUS)),
 99105:                                        NS_MIN(PRInt32(aSpreadRadius * scaleY / aAppUnitsPerDevPixel),
 99105:                                               PRInt32(MAX_SPREAD_RADIUS)));
 32237:   mDestinationCtx = aDestinationCtx;
 32237: 
 36887:   // If not blurring, draw directly onto the destination device
 99105:   if (blurRadius.width <= 0 && blurRadius.height <= 0 &&
 99105:       spreadRadius.width <= 0 && spreadRadius.height <= 0 &&
 52476:       !(aFlags & FORCE_MASK)) {
 15339:     mContext = aDestinationCtx;
 15339:     return mContext;
 15339:   }
 15339: 
 15339:   // Convert from app units to device pixels
 52135:   gfxRect rect = nsLayoutUtils::RectToGfxRect(aRect, aAppUnitsPerDevPixel);
 52135: 
 52135:   gfxRect dirtyRect =
 52135:     nsLayoutUtils::RectToGfxRect(aDirtyRect, aAppUnitsPerDevPixel);
 33368:   dirtyRect.RoundOut();
 15926: 
 98901:   rect = transform.TransformBounds(rect);
 98901: 
 98901:   mPreTransformed = !transform.IsIdentity();
 98901: 
 22437:   // Create the temporary surface for blurring
 98901:   dirtyRect = transform.TransformBounds(dirtyRect);
 98901:   if (aSkipRect) {
 98901:     gfxRect skipRect = transform.TransformBounds(*aSkipRect);
 99105:     mContext = blur.Init(rect, spreadRadius,
 98901:                          blurRadius, &dirtyRect, &skipRect);
 98901:   } else {
 99105:     mContext = blur.Init(rect, spreadRadius,
 98901:                          blurRadius, &dirtyRect, NULL);
 98901:   }
 98901: 
 98901:   if (mContext) {
 98901:     // we don't need to blur if skipRect is equal to rect
 98901:     // and mContext will be NULL
 98901:     mContext->SetMatrix(transform);
 98901:   }
 15339:   return mContext;
 15339: }
 15339: 
 15339: void
 15339: nsContextBoxBlur::DoPaint()
 15339: {
 19732:   if (mContext == mDestinationCtx)
 15339:     return;
 15339: 
 98901:   gfxContextMatrixAutoSaveRestore saveMatrix(mDestinationCtx);
 98901: 
 98901:   if (mPreTransformed) {
 98901:     mDestinationCtx->IdentityMatrix();
 98901:   }
 98901: 
 19732:   blur.Paint(mDestinationCtx);
 15339: }
 15339: 
 15339: gfxContext*
 15339: nsContextBoxBlur::GetContext()
 15339: {
 15339:   return mContext;
 15339: }
 22183: 
 52476: /* static */ nsMargin
 52476: nsContextBoxBlur::GetBlurRadiusMargin(nscoord aBlurRadius,
 52476:                                       PRInt32 aAppUnitsPerDevPixel)
 52476: {
 52476:   gfxIntSize blurRadius = ComputeBlurRadius(aBlurRadius, aAppUnitsPerDevPixel);
 52476: 
 52476:   nsMargin result;
 52476:   result.top    = blurRadius.height * aAppUnitsPerDevPixel;
 52476:   result.right  = blurRadius.width  * aAppUnitsPerDevPixel;
 52476:   result.bottom = blurRadius.height * aAppUnitsPerDevPixel;
 52476:   result.left   = blurRadius.width  * aAppUnitsPerDevPixel;
 52476:   return result;
 52476: }
