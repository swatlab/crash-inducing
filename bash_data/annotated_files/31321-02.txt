27664: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
27664: /* vim: set ts=2 sw=2 et tw=78 sts=2: */
27664: /* ***** BEGIN LICENSE BLOCK *****
27664:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
27664:  *
27664:  * The contents of this file are subject to the Mozilla Public License Version
27664:  * 1.1 (the "License"); you may not use this file except in compliance with
27664:  * the License. You may obtain a copy of the License at
27664:  * http://www.mozilla.org/MPL/
27664:  *
27664:  * Software distributed under the License is distributed on an "AS IS" basis,
27664:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
27664:  * for the specific language governing rights and limitations under the
27664:  * License.
27664:  *
27664:  * The Original Code is mozilla.org code.
27664:  *
27664:  * The Initial Developer of the Original Code is
27664:  * The Mozilla Foundation.
27664:  * Portions created by the Initial Developer are Copyright (C) 2009
27664:  * the Initial Developer. All Rights Reserved.
27664:  *
27664:  * Contributor(s):
27664:  *   Blake Kaplan <mrbkap@gmail.com> (original author)
27664:  *
27664:  * Alternatively, the contents of this file may be used under the terms of
27664:  * either the GNU General Public License Version 2 or later (the "GPL"), or
27664:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
27664:  * in which case the provisions of the GPL or the LGPL are applicable instead
27664:  * of those above. If you wish to allow use of your version of this file only
27664:  * under the terms of either the GPL or the LGPL, and not to allow others to
27664:  * use your version of this file under the terms of the MPL, indicate your
27664:  * decision by deleting the provisions above and replace them with the notice
27664:  * and other provisions required by the GPL or the LGPL. If you do not delete
27664:  * the provisions above, a recipient may use your version of this file under
27664:  * the terms of any one of the MPL, the GPL or the LGPL.
27664:  *
27664:  * ***** END LICENSE BLOCK ***** */
27664: 
27664: #include "xpcprivate.h"
27664: #include "nsDOMError.h"
27664: #include "jsdbgapi.h"
27664: #include "jscntxt.h"  // For JSAutoTempValueRooter.
27664: #include "XPCNativeWrapper.h"
27664: #include "XPCWrapper.h"
27664: 
27664: // This file implements a wrapper around trusted objects that allows them to
27664: // be safely injected into untrusted code.
27664: 
27664: static JSBool
27664: XPC_SOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
27664: 
27664: static JSBool
27664: XPC_SOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
27664: 
27664: static JSBool
27664: XPC_SOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
27664: 
27664: static JSBool
27664: XPC_SOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
27664: 
27664: static JSBool
27664: XPC_SOW_Enumerate(JSContext *cx, JSObject *obj);
27664: 
27664: static JSBool
27664: XPC_SOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
27664:                    JSObject **objp);
27664: 
27664: static JSBool
27664: XPC_SOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp);
27664: 
27664: static JSBool
27664: XPC_SOW_CheckAccess(JSContext *cx, JSObject *obj, jsval id, JSAccessMode mode,
27664:                     jsval *vp);
27664: 
27664: static JSBool
27664: XPC_SOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
27664: 
27664: static JSBool
27664: XPC_SOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp);
27664: 
27664: static JSObject *
27664: XPC_SOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
27664: 
27664: static JSObject *
27664: XPC_SOW_WrappedObject(JSContext *cx, JSObject *obj);
27664: 
27664: JSExtendedClass sXPC_SOW_JSClass = {
27664:   // JSClass (JSExtendedClass.base) initialization
27664:   { "SystemOnlyWrapper",
27664:     JSCLASS_NEW_RESOLVE | JSCLASS_IS_EXTENDED |
27664:     JSCLASS_HAS_RESERVED_SLOTS(XPCWrapper::sNumSlots),
27664:     XPC_SOW_AddProperty, XPC_SOW_DelProperty,
27664:     XPC_SOW_GetProperty, XPC_SOW_SetProperty,
27664:     XPC_SOW_Enumerate,   (JSResolveOp)XPC_SOW_NewResolve,
30654:     XPC_SOW_Convert,     nsnull,
27664:     nsnull,              XPC_SOW_CheckAccess,
27664:     nsnull,              nsnull,
27664:     nsnull,              XPC_SOW_HasInstance,
27664:     nsnull,              nsnull
27664:   },
27664: 
27664:   // JSExtendedClass initialization
27664:   XPC_SOW_Equality,
27664:   nsnull,             // outerObject
27664:   nsnull,             // innerObject
27664:   XPC_SOW_Iterator,
27664:   XPC_SOW_WrappedObject,
27664:   JSCLASS_NO_RESERVED_MEMBERS
27664: };
27664: 
27664: static JSBool
27664: XPC_SOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
27664:                  jsval *rval);
27664: 
27664: // Throws an exception on context |cx|.
27664: static inline JSBool
27664: ThrowException(nsresult rv, JSContext *cx)
27664: {
27664:   return XPCWrapper::ThrowException(rv, cx);
27664: }
27664: 
27664: // Like GetWrappedObject, but works on other types of wrappers, too.
27664: // TODO Move to XPCWrapper?
27664: static inline JSObject *
27664: GetWrappedJSObject(JSContext *cx, JSObject *obj)
27664: {
27664:   JSClass *clasp = STOBJ_GET_CLASS(obj);
27664:   if (!(clasp->flags & JSCLASS_IS_EXTENDED)) {
27664:     return obj;
27664:   }
27664: 
27664:   JSExtendedClass *xclasp = (JSExtendedClass *)clasp;
27664:   if (!xclasp->wrappedObject) {
27664:     return obj;
27664:   }
27664: 
27664:   return xclasp->wrappedObject(cx, obj);
27664: }
27664: 
27664: // Get the (possibly non-existant) SOW off of an object
27664: static inline
27664: JSObject *
27664: GetWrapper(JSObject *obj)
27664: {
27664:   while (STOBJ_GET_CLASS(obj) != &sXPC_SOW_JSClass.base) {
27664:     obj = STOBJ_GET_PROTO(obj);
27664:     if (!obj) {
27664:       break;
27664:     }
27664:   }
27664: 
27664:   return obj;
27664: }
27664: 
27664: static inline
27664: JSObject *
27664: GetWrappedObject(JSContext *cx, JSObject *wrapper)
27664: {
27664:   return XPCWrapper::UnwrapGeneric(cx, &sXPC_SOW_JSClass, wrapper);
27664: }
27664: 
29802: // If you change this code, change also nsContentUtils::CanAccessNativeAnon()!
27664: JSBool
27664: AllowedToAct(JSContext *cx, jsval idval)
27664: {
27664:   nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
27664:   if (!ssm) {
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   JSStackFrame *fp;
27664:   nsIPrincipal *principal = ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
27664:   if (!principal) {
27664:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
27664:   }
27664: 
27665:   if (!fp) {
27665:     if (!JS_FrameIterator(cx, &fp)) {
27665:       // No code at all is running. So we must be arriving here as the result
27665:       // of C++ code asking us to do something. Allow access.
27665:       return JS_TRUE;
27665:     }
27665: 
27665:     // Some code is running, we can't make the assumption, as above, but we
27665:     // can't use a native frame, so clear fp.
27665:     fp = nsnull;
31321:   } else if (!fp->script) {
31321:     fp = nsnull;
27665:   }
27665: 
31207:   void *annotation = fp ? JS_GetFrameAnnotation(cx, fp) : nsnull;
27664:   PRBool privileged;
31207:   if (NS_SUCCEEDED(principal->IsCapabilityEnabled("UniversalXPConnect",
31207:                                                   annotation,
31207:                                                   &privileged)) &&
27664:       privileged) {
31207:     // UniversalXPConnect things are allowed to touch us.
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   // XXX HACK EWW! Allow chrome://global/ access to these things, even
27664:   // if they've been cloned into less privileged contexts.
27664:   static const char prefix[] = "chrome://global/";
27665:   const char *filename;
27665:   if (fp &&
27665:       (filename = fp->script->filename) &&
27665:       !strncmp(filename, prefix, NS_ARRAY_LENGTH(prefix) - 1)) {
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   if (JSVAL_IS_VOID(idval)) {
27664:     ThrowException(NS_ERROR_XPC_SECURITY_MANAGER_VETO, cx);
27664:   } else {
27664:     // TODO Localize me?
27664:     JSString *str = JS_ValueToString(cx, idval);
27664:     if (str) {
27664:       JS_ReportError(cx, "Permission denied to access property '%hs' from a non-chrome context",
27664:                      JS_GetStringChars(str));
27664:     }
27664:   }
27664: 
27664:   return JS_FALSE;
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_FunctionWrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
27664:                         jsval *rval)
27664: {
27664:   if (!AllowedToAct(cx, JSVAL_VOID)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   JSObject *wrappedObj;
27664: 
27664:   // Allow 'this' to be either a SOW, in which case we unwrap it or something
27664:   // that isn't a SOW.  We disallow invalid SOWs that have no wrapped object.
27664:   // We do this so that it's possible to use this function with .call on
27664:   // related objects that are not system only.
27664: 
27664:   wrappedObj = GetWrapper(obj);
27664:   if (wrappedObj) {
27664:     wrappedObj = GetWrappedObject(cx, wrappedObj);
27664:     if (!wrappedObj) {
27664:       return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
27664:     }
27664:   } else {
27664:     wrappedObj = obj;
27664:   }
27664: 
27664:   JSObject *funObj = JSVAL_TO_OBJECT(argv[-2]);
27664:   jsval funToCall;
27664:   if (!JS_GetReservedSlot(cx, funObj, XPCWrapper::eWrappedFunctionSlot,
27664:                           &funToCall)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   return JS_CallFunctionValue(cx, wrappedObj, funToCall, argc, argv, rval);
27664: }
27664: 
27664: JSBool
27664: XPC_SOW_WrapFunction(JSContext *cx, JSObject *outerObj, JSObject *funobj,
27664:                      jsval *rval)
27664: {
27664:   jsval funobjVal = OBJECT_TO_JSVAL(funobj);
27664:   JSFunction *wrappedFun =
27664:     reinterpret_cast<JSFunction *>(xpc_GetJSPrivate(funobj));
27664:   JSNative native = JS_GetFunctionNative(cx, wrappedFun);
27664:   if (!native || native == XPC_SOW_FunctionWrapper) {
27664:     *rval = funobjVal;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   JSFunction *funWrapper =
27664:     JS_NewFunction(cx, XPC_SOW_FunctionWrapper,
27664:                    JS_GetFunctionArity(wrappedFun), 0,
27664:                    JS_GetGlobalForObject(cx, outerObj),
27664:                    JS_GetFunctionName(wrappedFun));
27664:   if (!funWrapper) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   JSObject *funWrapperObj = JS_GetFunctionObject(funWrapper);
27664:   *rval = OBJECT_TO_JSVAL(funWrapperObj);
27664: 
27664:   return JS_SetReservedSlot(cx, funWrapperObj,
27664:                             XPCWrapper::eWrappedFunctionSlot,
27664:                             funobjVal);
27664: }
27664: 
27664: static JSBool
28523: XPC_SOW_RewrapValue(JSContext *cx, JSObject *wrapperObj, jsval *vp)
28523: {
28523:   jsval v = *vp;
28523:   if (JSVAL_IS_PRIMITIVE(v)) {
28523:     return JS_TRUE;
28523:   }
28523: 
28523:   JSObject *obj = JSVAL_TO_OBJECT(v);
28523: 
28523:   if (JS_ObjectIsFunction(cx, obj)) {
28523:     // NB: The JS_ValueToFunction call is guaranteed to succeed.
28523:     JSNative native = JS_GetFunctionNative(cx, JS_ValueToFunction(cx, v));
28523: 
28523:     // This is really tricky! We need to unwrap this when calling native
28523:     // functions to preserve their assumptions, but *not* when calling
28523:     // scripted functions, since they expect 'this' to be wrapped.
28523:     if (!native) {
28523:      return JS_TRUE;
28523:     }
28523: 
28523:     if (native == XPC_SOW_FunctionWrapper) {
28523:       // If this is a system function wrapper, make sure its ours, otherwise,
28523:       // its prototype could come from the wrong scope.
28523:       if (STOBJ_GET_PROTO(wrapperObj) == STOBJ_GET_PARENT(obj)) {
28523:         return JS_TRUE;
28523:       }
28523: 
28523:       // It isn't ours, rewrap the wrapped function.
28523:       if (!JS_GetReservedSlot(cx, obj, XPCWrapper::eWrappedFunctionSlot, &v)) {
28523:         return JS_FALSE;
28523:       }
28523:       obj = JSVAL_TO_OBJECT(v);
28523:     }
28523: 
28523:     return XPC_SOW_WrapFunction(cx, wrapperObj, obj, vp);
28523:   }
28523: 
28523:   if (STOBJ_GET_CLASS(obj) == &sXPC_SOW_JSClass.base) {
28523:     // We are extra careful about content-polluted wrappers here. I don't know
28523:     // if it's possible to reach them through objects that we wrap, but figuring
28523:     // that out is more expensive (and harder) than simply checking and
28523:     // rewrapping here.
28523:     if (STOBJ_GET_PARENT(wrapperObj) == STOBJ_GET_PARENT(obj)) {
28523:       // Already wrapped.
28523:       return JS_TRUE;
28523:     }
28523: 
28523:     obj = GetWrappedObject(cx, obj);
28523:     if (!obj) {
28523:       // XXX Can this happen?
28523:       *vp = JSVAL_NULL;
28523:       return JS_TRUE;
28523:     }
28523:     v = *vp = OBJECT_TO_JSVAL(obj);
28523:   }
28523: 
28523:   return XPC_SOW_WrapObject(cx, STOBJ_GET_PARENT(wrapperObj), v, vp);
28523: }
28523: 
28523: static JSBool
27664: XPC_SOW_AddProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27664: {
27664:   NS_ASSERTION(STOBJ_GET_CLASS(obj) == &sXPC_SOW_JSClass.base, "Wrong object");
27664: 
27664:   jsval resolving;
27664:   if (!JS_GetReservedSlot(cx, obj, XPCWrapper::sFlagsSlot, &resolving)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   if (HAS_FLAGS(resolving, FLAG_RESOLVING)) {
27664:     // Allow us to define a property on ourselves.
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   if (!AllowedToAct(cx, id)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   return XPCWrapper::AddProperty(cx, obj, JS_TRUE, wrappedObj, id, vp);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_DelProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27664: {
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
27664:   }
27664: 
27664:   if (!AllowedToAct(cx, id)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   return XPCWrapper::DelProperty(cx, wrappedObj, id, vp);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_GetOrSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp,
27664:                          JSBool isSet)
27664: {
27664:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   obj = GetWrapper(obj);
27664:   if (!obj) {
27664:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
27664:   }
27664: 
27664:   if (!AllowedToAct(cx, id)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   JSAutoTempValueRooter tvr(cx, 1, vp);
27664: 
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     return ThrowException(NS_ERROR_ILLEGAL_VALUE, cx);
27664:   }
27664: 
27664:   if (isSet && id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_PROTO)) {
27664:     // No setting __proto__ on my object.
27664:     return ThrowException(NS_ERROR_INVALID_ARG, cx); // XXX better error message
27664:   }
27664: 
27664:   jsid interned_id;
27664:   if (!JS_ValueToId(cx, id, &interned_id)) {
27664:     return JS_FALSE;
27664:   }
27664: 
28523:   JSBool ok = isSet
27664:               ? JS_SetPropertyById(cx, wrappedObj, interned_id, vp)
27664:               : JS_GetPropertyById(cx, wrappedObj, interned_id, vp);
28523:   if (!ok) {
28523:     return JS_FALSE;
28523:   }
28523: 
28523:   return XPC_SOW_RewrapValue(cx, obj, vp);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_GetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27664: {
27664:   return XPC_SOW_GetOrSetProperty(cx, obj, id, vp, JS_FALSE);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_SetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27664: {
27664:   return XPC_SOW_GetOrSetProperty(cx, obj, id, vp, JS_TRUE);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_Enumerate(JSContext *cx, JSObject *obj)
27664: {
27664:   obj = GetWrapper(obj);
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     // Nothing to enumerate.
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   if (!AllowedToAct(cx, JSVAL_VOID)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   return XPCWrapper::Enumerate(cx, obj, wrappedObj);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_NewResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
27664:                    JSObject **objp)
27664: {
27664:   obj = GetWrapper(obj);
27664: 
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     // No wrappedObj means that this is probably the prototype.
27664:     *objp = nsnull;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   if (!AllowedToAct(cx, id)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   if (id == GetRTStringByIndex(cx, XPCJSRuntime::IDX_TO_STRING)) {
27664:     jsval oldSlotVal;
27664:     if (!JS_GetReservedSlot(cx, obj, XPCWrapper::sFlagsSlot, &oldSlotVal) ||
27664:         !JS_SetReservedSlot(cx, obj, XPCWrapper::sFlagsSlot,
27664:                             INT_TO_JSVAL(JSVAL_TO_INT(oldSlotVal) |
27664:                                          FLAG_RESOLVING))) {
27664:       return JS_FALSE;
27664:     }
27664: 
27664:     JSBool ok = JS_DefineFunction(cx, obj, "toString",
27664:                                   XPC_SOW_toString, 0, 0) != nsnull;
27664: 
27664:     JS_SetReservedSlot(cx, obj, XPCWrapper::sFlagsSlot, oldSlotVal);
27664: 
27664:     if (ok) {
27664:       *objp = obj;
27664:     }
27664: 
27664:     return ok;
27664:   }
27664: 
27664:   return XPCWrapper::NewResolve(cx, obj, JS_TRUE, wrappedObj, id, flags, objp);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_Convert(JSContext *cx, JSObject *obj, JSType type, jsval *vp)
27664: {
27664:   if (!AllowedToAct(cx, JSVAL_VOID)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   // Don't do any work to convert to object.
27664:   if (type == JSTYPE_OBJECT) {
27664:     *vp = OBJECT_TO_JSVAL(obj);
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     // Converting the prototype to something.
27664: 
27664:     if (type == JSTYPE_STRING || type == JSTYPE_VOID) {
27664:       return XPC_SOW_toString(cx, obj, 0, nsnull, vp);
27664:     }
27664: 
27664:     *vp = OBJECT_TO_JSVAL(obj);
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   return STOBJ_GET_CLASS(wrappedObj)->convert(cx, wrappedObj, type, vp);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_CheckAccess(JSContext *cx, JSObject *obj, jsval prop, JSAccessMode mode,
27664:                     jsval *vp)
27664: {
27664:   // Simply forward checkAccess to our wrapped object. It's already expecting
27664:   // untrusted things to ask it about accesses.
27664: 
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     *vp = JSVAL_VOID;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   uintN junk;
27664:   jsid id;
27664:   return JS_ValueToId(cx, prop, &id) &&
27664:          JS_CheckAccess(cx, wrappedObj, id, mode, vp, &junk);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
27664: {
27664:   if (!AllowedToAct(cx, JSVAL_VOID)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   JSObject *iface = GetWrappedObject(cx, obj);
27664:   if (!iface) {
27664:     *bp = JS_FALSE;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   JSClass *clasp = STOBJ_GET_CLASS(iface);
27664: 
27664:   *bp = JS_FALSE;
27664:   if (!clasp->hasInstance) {
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   // Prematurely unwrap the left hand side. This isn't necessary, but could be
27664:   // faster than waiting until XPCWrappedNative::GetWrappedNativeOfJSObject to
27664:   // do it.
27664:   if (!JSVAL_IS_PRIMITIVE(v)) {
27664:     JSObject *test = JSVAL_TO_OBJECT(v);
27664: 
27664:     // GetWrappedObject does a class check.
27664:     test = GetWrappedObject(cx, test);
27664:     if (test) {
27664:       v = OBJECT_TO_JSVAL(test);
27664:     }
27664:   }
27664: 
27664:   return clasp->hasInstance(cx, iface, v, bp);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_Equality(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
27664: {
27664:   // Delegate to our wrapped object.
27664:   if (JSVAL_IS_PRIMITIVE(v)) {
27664:     *bp = JS_FALSE;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   if (obj == JSVAL_TO_OBJECT(v)) {
27664:     *bp = JS_TRUE;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   JSObject *lhs = GetWrappedObject(cx, obj);
27664:   JSObject *rhs = GetWrappedJSObject(cx, JSVAL_TO_OBJECT(v));
27664:   if (lhs == rhs) {
27664:     *bp = JS_TRUE;
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   if (lhs) {
27664:     // Delegate to our wrapped object if we can.
27664:     JSClass *clasp = STOBJ_GET_CLASS(lhs);
27664:     if (clasp->flags & JSCLASS_IS_EXTENDED) {
27664:       JSExtendedClass *xclasp = (JSExtendedClass *) clasp;
27664:       // NB: JSExtendedClass.equality is a required field.
27664:       return xclasp->equality(cx, lhs, OBJECT_TO_JSVAL(rhs), bp);
27664:     }
27664:   }
27664: 
27664:   // We know rhs is non-null.
27664:   JSClass *clasp = STOBJ_GET_CLASS(rhs);
27664:   if (clasp->flags & JSCLASS_IS_EXTENDED) {
27664:     JSExtendedClass *xclasp = (JSExtendedClass *) clasp;
27664:     // NB: JSExtendedClass.equality is a required field.
27664:     return xclasp->equality(cx, rhs, OBJECT_TO_JSVAL(lhs), bp);
27664:   }
27664: 
27664:   *bp = JS_FALSE;
27664:   return JS_TRUE;
27664: }
27664: 
27664: static JSObject *
27664: XPC_SOW_Iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
27664: {
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     ThrowException(NS_ERROR_INVALID_ARG, cx);
27664:     return nsnull;
27664:   }
27664: 
27664:   JSObject *wrapperIter = JS_NewObject(cx, &sXPC_SOW_JSClass.base, nsnull,
27664:                                        JS_GetGlobalForObject(cx, obj));
27664:   if (!wrapperIter) {
27664:     return nsnull;
27664:   }
27664: 
27664:   JSAutoTempValueRooter tvr(cx, OBJECT_TO_JSVAL(wrapperIter));
27664: 
27664:   // Initialize our SOW.
27664:   jsval v = OBJECT_TO_JSVAL(wrappedObj);
27664:   if (!JS_SetReservedSlot(cx, wrapperIter, XPCWrapper::sWrappedObjSlot, v) ||
27664:       !JS_SetReservedSlot(cx, wrapperIter, XPCWrapper::sFlagsSlot,
27664:                           JSVAL_ZERO)) {
27664:     return nsnull;
27664:   }
27664: 
27664:   return XPCWrapper::CreateIteratorObj(cx, wrapperIter, obj, wrappedObj,
27664:                                        keysonly);
27664: }
27664: 
27664: static JSObject *
27664: XPC_SOW_WrappedObject(JSContext *cx, JSObject *obj)
27664: {
27664:   return GetWrappedObject(cx, obj);
27664: }
27664: 
27664: static JSBool
27664: XPC_SOW_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
27664:                  jsval *rval)
27664: {
27664:   if (!AllowedToAct(cx, JSVAL_VOID)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   obj = GetWrapper(obj);
27664:   if (!obj) {
27664:     return ThrowException(NS_ERROR_UNEXPECTED, cx);
27664:   }
27664: 
27664:   JSObject *wrappedObj = GetWrappedObject(cx, obj);
27664:   if (!wrappedObj) {
27664:     // Someone's calling toString on our prototype.
27664:     NS_NAMED_LITERAL_CSTRING(protoString, "[object XPCCrossOriginWrapper]");
27664:     JSString *str =
27664:       JS_NewStringCopyN(cx, protoString.get(), protoString.Length());
27664:     if (!str) {
27664:       return JS_FALSE;
27664:     }
27664:     *rval = STRING_TO_JSVAL(str);
27664:     return JS_TRUE;
27664:   }
27664: 
27664:   XPCWrappedNative *wn =
27664:     XPCWrappedNative::GetWrappedNativeOfJSObject(cx, wrappedObj);
27664:   return XPCWrapper::NativeToString(cx, wn, argc, argv, rval, JS_FALSE);
27664: }
27664: 
27664: JSBool
27664: XPC_SOW_WrapObject(JSContext *cx, JSObject *parent, jsval v,
27664:                    jsval *vp)
27664: {
31315:   // Slim wrappers don't expect to be wrapped, so morph them to fat wrappers
31315:   // if we're about to wrap one.
31315:   JSObject *innerObj = JSVAL_TO_OBJECT(v);
31315:   if (IS_SLIM_WRAPPER(innerObj) && !MorphSlimWrapper(cx, innerObj)) {
31315:     return ThrowException(NS_ERROR_FAILURE, cx);
31315:   }
31315: 
27664:   JSObject *wrapperObj =
27664:     JS_NewObjectWithGivenProto(cx, &sXPC_SOW_JSClass.base, NULL, parent);
27664:   if (!wrapperObj) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   *vp = OBJECT_TO_JSVAL(wrapperObj);
27664:   JSAutoTempValueRooter tvr(cx, *vp);
27664: 
27664:   if (!JS_SetReservedSlot(cx, wrapperObj, XPCWrapper::sWrappedObjSlot, v) ||
27664:       !JS_SetReservedSlot(cx, wrapperObj, XPCWrapper::sFlagsSlot,
27664:                           JSVAL_ZERO)) {
27664:     return JS_FALSE;
27664:   }
27664: 
27664:   return JS_TRUE;
27664: }
