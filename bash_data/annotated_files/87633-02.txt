 6059: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 6059: /* ***** BEGIN LICENSE BLOCK *****
 6059:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 6059:  *
 6059:  * The contents of this file are subject to the Mozilla Public License Version
 6059:  * 1.1 (the "License"); you may not use this file except in compliance with
 6059:  * the License. You may obtain a copy of the License at
 6059:  * http://www.mozilla.org/MPL/
 6059:  *
 6059:  * Software distributed under the License is distributed on an "AS IS" basis,
 6059:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 6059:  * for the specific language governing rights and limitations under the
 6059:  * License.
 6059:  *
 6059:  * The Original Code is mozilla.org code.
 6059:  *
 6059:  * The Initial Developer of the Original Code is
 6059:  * Netscape Communications Corporation.
 6059:  * Portions created by the Initial Developer are Copyright (C) 1998
 6059:  * the Initial Developer. All Rights Reserved.
 6059:  *
 6059:  * Contributor(s):
 6059:  *
 6059:  * Alternatively, the contents of this file may be used under the terms of
 6059:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 6059:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 6059:  * in which case the provisions of the GPL or the LGPL are applicable instead
 6059:  * of those above. If you wish to allow use of your version of this file only
 6059:  * under the terms of either the GPL or the LGPL, and not to allow others to
 6059:  * use your version of this file under the terms of the MPL, indicate your
 6059:  * decision by deleting the provisions above and replace them with the notice
 6059:  * and other provisions required by the GPL or the LGPL. If you do not delete
 6059:  * the provisions above, a recipient may use your version of this file under
 6059:  * the terms of any one of the MPL, the GPL or the LGPL.
 6059:  *
 6059:  * ***** END LICENSE BLOCK ***** */
 6059: 
 6059: /**
 6059:  * MODULE NOTES:
 6059:  *
 6059:  * The Deque is a very small, very efficient container object
 6059:  * than can hold elements of type void*, offering the following features:
 6059:  *    Its interface supports pushing and popping of elements.
 6059:  *    It can iterate (via an interator class) its elements.
 6059:  *    When full, it can efficiently resize dynamically.
 6059:  *
 6059:  *
 6059:  * NOTE: The only bit of trickery here is that this deque is
 6059:  * built upon a ring-buffer. Like all ring buffers, the first
 6059:  * element may not be at index[0]. The mOrigin member determines
 6059:  * where the first child is. This point is quietly hidden from
 6059:  * customers of this class.
 6059:  *
 6059:  */
 6059: 
 6059: #ifndef _NSDEQUE
 6059: #define _NSDEQUE
 6059: 
 6059: #include "nscore.h"
 6059: 
 6059: /**
 6059:  * The nsDequeFunctor class is used when you want to create
 6059:  * callbacks between the deque and your generic code.
 6059:  * Use these objects in a call to ForEach();
 6059:  *
 6059:  */
 6059: 
 6059: class nsDequeFunctor{
 6059: public:
 6059:   virtual void* operator()(void* anObject)=0;
 6059: };
 6059: 
 6059: /******************************************************
 6059:  * Here comes the nsDeque class itself...
 6059:  ******************************************************/
 6059: 
 6059: /**
 6059:  * The deque (double-ended queue) class is a common container type,
 6059:  * whose behavior mimics a line in your favorite checkout stand.
 6059:  * Classic CS describes the common behavior of a queue as FIFO.
 6059:  * A deque allows insertion and removal at both ends of
 6059:  * the container.
 6059:  *
 6059:  * The deque stores pointers to items.
 6059:  */
 6059: 
 6059: class nsDequeIterator;
 6059: 
 6060: class NS_COM_GLUE nsDeque {
 6059:   friend class nsDequeIterator;
 6059:   public:
 6059:    nsDeque(nsDequeFunctor* aDeallocator = nsnull);
 6059:   ~nsDeque();
 6059: 
 6059:   /**
 6059:    * Returns the number of elements currently stored in
 6059:    * this deque.
 6059:    *
 6059:    * @return  number of elements currently in the deque
 6059:    */
 6059:   inline PRInt32 GetSize() const {return mSize;}
 6059: 
 6059:   /**
 6059:    * Appends new member at the end of the deque.
 6059:    *
 6059:    * @param   item to store in deque
 6059:    * @return  *this
 6059:    */
 6059:   nsDeque& Push(void* aItem);
 6059: 
 6059:   /**
 6059:    * Inserts new member at the front of the deque.
 6059:    *
 6059:    * @param   item to store in deque
 6059:    * @return  *this
 6059:    */
 6059:   nsDeque& PushFront(void* aItem);
 6059: 
 6059:   /**
 6059:    * Remove and return the last item in the container.
 6059:    *
 6059:    * @return  the item that was the last item in container
 6059:    */
 6059:   void* Pop();
 6059: 
 6059:   /**
 6059:    * Remove and return the first item in the container.
 6059:    *
 6059:    * @return  the item that was first item in container
 6059:    */
 6059:   void* PopFront();
 6059: 
 6059:   /**
 6059:    * Retrieve the bottom item without removing it.
 6059:    *
 6059:    * @return  the first item in container
 6059:    */
 6059: 
 6059:   void* Peek();
 6059:   /**
 6059:    * Return topmost item without removing it.
 6059:    *
 6059:    * @return  the first item in container
 6059:    */
 6059:   void* PeekFront();
 6059: 
 6059:   /**
 6059:    * Retrieve the i'th member from the deque without removing it.
 6059:    *
 6059:    * @param   index of desired item
 6059:    * @return  i'th element in list
 6059:    */
 6059:   void* ObjectAt(int aIndex) const;
 6059: 
 6059:   /**
87633:    * Removes and returns the i'th member from the deque.
87633:    *
87633:    * @param   index of desired item
87633:    * @return  the element which was removed
87633:    */
87633:   void* RemoveObjectAt(int aIndex);
87633: 
87633:   /**
 6059:    * Remove all items from container without destroying them.
 6059:    *
 6059:    * @return  *this
 6059:    */
 6059:   nsDeque& Empty();
 6059: 
 6059:   /**
 6059:    * Remove and delete all items from container.
 6059:    * Deletes are handled by the deallocator nsDequeFunctor
 6059:    * which is specified at deque construction.
 6059:    *
 6059:    * @return  *this
 6059:    */
 6059:   nsDeque& Erase();
 6059: 
 6059:   /**
 6059:    * Creates a new iterator, pointing to the first
 6059:    * item in the deque.
 6059:    *
 6059:    * @return  new dequeIterator
 6059:    */
 6059:   nsDequeIterator Begin() const;
 6059: 
 6059:   /**
 6059:    * Creates a new iterator, pointing to the last
 6059:    * item in the deque.
 6059:    *
 6059:    * @return  new dequeIterator
 6059:    */
 6059:   nsDequeIterator End() const;
 6059: 
 6059:   void* Last() const;
 6059:   /**
 6059:    * Call this method when you want to iterate all the
 6059:    * members of the container, passing a functor along
 6059:    * to call your code.
 6059:    *
 6059:    * @param   aFunctor object to call for each member
 6059:    * @return  *this
 6059:    */
 6059:   void ForEach(nsDequeFunctor& aFunctor) const;
 6059: 
 6059:   /**
 6059:    * Call this method when you want to iterate all the
 6059:    * members of the container, calling the functor you 
 6059:    * passed with each member. This process will interrupt
 6059:    * if your function returns non 0 to this method.
 6059:    *
 6059:    * @param   aFunctor object to call for each member
 6059:    * @return  first nonzero result of aFunctor or 0.
 6059:    */
 6059:   const void* FirstThat(nsDequeFunctor& aFunctor) const;
 6059: 
 6059:   void SetDeallocator(nsDequeFunctor* aDeallocator);
 6059: 
 6059: protected:
 6059:   PRInt32         mSize;
 6059:   PRInt32         mCapacity;
 6059:   PRInt32         mOrigin;
 6059:   nsDequeFunctor* mDeallocator;
 6059:   void*           mBuffer[8];
 6059:   void**          mData;
 6059: 
 6059: private:
 6059: 
 6059:   /**
 6059:    * Copy constructor (PRIVATE)
 6059:    *
 6059:    * @param another deque
 6059:    */
 6059:   nsDeque(const nsDeque& other);
 6059: 
 6059:   /**
 6059:    * Deque assignment operator (PRIVATE)
 6059:    *
 6059:    * @param   another deque
 6059:    * @return  *this
 6059:    */
 6059:   nsDeque& operator=(const nsDeque& anOther);
 6059: 
79445:   bool GrowCapacity();
 6059: };
 6059: 
 6059: /******************************************************
 6059:  * Here comes the nsDequeIterator class...
 6059:  ******************************************************/
 6059: 
 6060: class NS_COM_GLUE nsDequeIterator {
 6059: public:
 6059:   /**
 6059:    * DequeIterator is an object that knows how to iterate
 6059:    * (forward and backward) through a Deque. Normally,
 6059:    * you don't need to do this, but there are some special
 6059:    * cases where it is pretty handy.
 6059:    *
 6059:    * One warning: the iterator is not bound to an item,
 6059:    * it is bound to an index, so if you insert or remove
 6059:    * from the beginning while using an iterator
 6059:    * (which is not recommended) then the iterator will
 6059:    * point to a different item.  @see GetCurrent()
 6059:    *
 6059:    * Here you go.
 6059:    *
 6059:    * @param   aQueue is the deque object to be iterated
 6059:    * @param   aIndex is the starting position for your iteration
 6059:    */
 6059:   nsDequeIterator(const nsDeque& aQueue, int aIndex=0);
 6059: 
 6059:   /**
 6059:    * Create a copy of a DequeIterator
 6059:    *
 6059:    * @param   aCopy is another iterator to copy from
 6059:    */
 6059:   nsDequeIterator(const nsDequeIterator& aCopy);
 6059: 
 6059:   /**
 6059:    * Moves iterator to first element in the deque
 6059:    * @return  *this
 6059:    */
 6059:   nsDequeIterator& First();
 6059: 
 6059:   /**
 6059:    * Standard assignment operator for dequeiterator
 6059:    * @param   aCopy is another iterator to copy from
 6059:    * @return  *this
 6059:    */
 6059:   nsDequeIterator& operator=(const nsDequeIterator& aCopy);
 6059: 
 6059:   /**
 6059:    * preform ! operation against two iterators to test for equivalence
 6059:    * (or lack thereof)!
 6059:    *
 6059:    * @param   aIter is the object to be compared to
 6059:    * @return  TRUE if NOT equal.
 6059:    */
79445:   bool operator!=(nsDequeIterator& aIter);
 6059: 
 6059:   /**
 6059:    * Compare two iterators for increasing order.
 6059:    *
 6059:    * @param   aIter is the other iterator to be compared to
 6059:    * @return  TRUE if this object points to an element before
 6059:    *          the element pointed to by aIter.
 6059:    *          FALSE if this and aIter are not iterating over
 6059:    *          the same deque.
 6059:    */
79445:   bool operator<(nsDequeIterator& aIter);
 6059: 
 6059:   /**
 6059:    * Compare two iterators for equivalence.
 6059:    *
 6059:    * @param   aIter is the other iterator to be compared to
 6059:    * @return  TRUE if EQUAL
 6059:    */
79445:   bool operator==(nsDequeIterator& aIter);
 6059: 
 6059:   /**
 6059:    * Compare two iterators for non strict decreasing order.
 6059:    *
 6059:    * @param   aIter is the other iterator to be compared to
 6059:    * @return  TRUE if this object points to the same element, or
 6059:    *          an element after the element pointed to by aIter.
 6059:    *          FALSE if this and aIter are not iterating over
 6059:    *          the same deque.
 6059:    */
79445:   bool operator>=(nsDequeIterator& aIter);
 6059: 
 6059:   /**
 6059:    * Pre-increment operator
 6059:    * Iterator will advance one index towards the end.
 6059:    *
 6059:    * @return  object_at(++index)
 6059:    */
 6059:   void* operator++();
 6059: 
 6059:   /**
 6059:    * Post-increment operator
 6059:    * Iterator will advance one index towards the end.
 6059:    *
 6059:    * @param   param is ignored
 6059:    * @return  object_at(mIndex++)
 6059:    */
 6059:   void* operator++(int);
 6059: 
 6059:   /**
 6059:    * Pre-decrement operator
 6059:    * Iterator will advance one index towards the beginning.
 6059:    *
 6059:    * @return  object_at(--index)
 6059:    */
 6059:   void* operator--();
 6059: 
 6059:   /**
 6059:    * Post-decrement operator
 6059:    * Iterator will advance one index towards the beginning.
 6059:    *
 6059:    * @param   param is ignored
 6059:    * @return  object_at(index--)
 6059:    */
 6059:   void* operator--(int);
 6059: 
 6059:   /**
 6059:    * Retrieve the the iterator's notion of current node.
 6059:    *
 6059:    * Note that the iterator floats, so you don't need to do:
 6059:    * <code>++iter; aDeque.PopFront();</code>
 6059:    * Unless you actually want your iterator to jump 2 positions
 6059:    * relative to its origin.
 6059:    *
 6059:    * Picture: [1 2i 3 4]
 6059:    * PopFront()
 6059:    * Picture: [2 3i 4]
 6059:    * Note that I still happily points to object at the second index.
 6059:    *
 6059:    * @return  object at i'th index
 6059:    */
 6059:   void* GetCurrent();
 6059: 
 6059:   /**
 6059:    * Call this method when you want to iterate all the
 6059:    * members of the container, passing a functor along
 6059:    * to call your code.
 6059:    *
 6059:    * @param   aFunctor object to call for each member
 6059:    * @return  *this
 6059:    */
 6059:   void ForEach(nsDequeFunctor& aFunctor) const;
 6059: 
 6059:   /**
 6059:    * Call this method when you want to iterate all the
 6059:    * members of the container, calling the functor you 
 6059:    * passed with each member. This process will interrupt
 6059:    * if your function returns non 0 to this method.
 6059:    *
 6059:    * @param   aFunctor object to call for each member
 6059:    * @return  first nonzero result of aFunctor or 0.
 6059:    */
 6059:   const void* FirstThat(nsDequeFunctor& aFunctor) const;
 6059: 
 6059:   protected:
 6059: 
 6059:   PRInt32         mIndex;
 6059:   const nsDeque&  mDeque;
 6059: };
 6059: #endif
