  3129: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  3129: 
  3129: #include "nsGkAtoms.h"
  3129: #include "nsXULPopupManager.h"
  3129: #include "nsMenuFrame.h"
  3129: #include "nsMenuPopupFrame.h"
  3129: #include "nsMenuBarFrame.h"
  3129: #include "nsIPopupBoxObject.h"
  3129: #include "nsMenuBarListener.h"
  3129: #include "nsContentUtils.h"
  3129: #include "nsIDOMDocument.h"
107461: #include "nsIDOMEvent.h"
 12021: #include "nsIDOMXULElement.h"
 49217: #include "nsIXULDocument.h"
 12021: #include "nsIXULTemplateBuilder.h"
  3129: #include "nsEventDispatcher.h"
  3804: #include "nsEventStateManager.h"
  3129: #include "nsCSSFrameConstructor.h"
  3129: #include "nsLayoutUtils.h"
  3129: #include "nsIViewManager.h"
  3129: #include "nsIComponentManager.h"
  3129: #include "nsITimer.h"
 29018: #include "nsFocusManager.h"
  3129: #include "nsIDocShellTreeItem.h"
  3129: #include "nsIDocShell.h"
  3129: #include "nsPIDOMWindow.h"
  3129: #include "nsIInterfaceRequestorUtils.h"
  3129: #include "nsIBaseWindow.h"
 11962: #include "nsIDOMMouseEvent.h"
 15969: #include "nsCaret.h"
 13787: #include "nsIDocument.h"
 49217: #include "nsPIWindowRoot.h"
 30532: #include "nsFrameManager.h"
 71959: #include "nsIObserverService.h"
 71959: #include "mozilla/Services.h"
 78129: #include "mozilla/LookAndFeel.h"
 78129: 
 78129: using namespace mozilla;
  3129: 
 23190: const nsNavigationDirection DirectionFromKeyCodeTable[2][6] = {
 23190:   {
  3534:     eNavigationDirection_Last,   // NS_VK_END
  3534:     eNavigationDirection_First,  // NS_VK_HOME
  3534:     eNavigationDirection_Start,  // NS_VK_LEFT
  3534:     eNavigationDirection_Before, // NS_VK_UP
  3534:     eNavigationDirection_End,    // NS_VK_RIGHT
  3534:     eNavigationDirection_After   // NS_VK_DOWN
 23190:   },
 23190:   {
  3534:     eNavigationDirection_Last,   // NS_VK_END
  3534:     eNavigationDirection_First,  // NS_VK_HOME
  3534:     eNavigationDirection_End,    // NS_VK_LEFT
  3534:     eNavigationDirection_Before, // NS_VK_UP
  3534:     eNavigationDirection_Start,  // NS_VK_RIGHT
  3534:     eNavigationDirection_After   // NS_VK_DOWN
 23190:   }
  3534: };
  3534: 
106838: nsXULPopupManager* nsXULPopupManager::sInstance = nullptr;
  3129: 
  3129: nsIContent* nsMenuChainItem::Content()
  3129: {
  3129:   return mFrame->GetContent();
  3129: }
  3129: 
  3129: void nsMenuChainItem::SetParent(nsMenuChainItem* aParent)
  3129: {
  3129:   if (mParent) {
  3129:     NS_ASSERTION(mParent->mChild == this, "Unexpected - parent's child not set to this");
106838:     mParent->mChild = nullptr;
  3129:   }
  3129:   mParent = aParent;
  3129:   if (mParent) {
  3129:     if (mParent->mChild)
106838:       mParent->mChild->mParent = nullptr;
  3129:     mParent->mChild = this;
  3129:   }
  3129: }
  3129: 
  3129: void nsMenuChainItem::Detach(nsMenuChainItem** aRoot)
  3129: {
  3129:   // If the item has a child, set the child's parent to this item's parent,
  3129:   // effectively removing the item from the chain. If the item has no child,
  3129:   // just set the parent to null.
  3129:   if (mChild) {
  3129:     NS_ASSERTION(this != *aRoot, "Unexpected - popup with child at end of chain");
  3129:     mChild->SetParent(mParent);
  3129:   }
  3129:   else {
  3129:     // An item without a child should be the first item in the chain, so set
  3129:     // the first item pointer, pointed to by aRoot, to the parent.
  3129:     NS_ASSERTION(this == *aRoot, "Unexpected - popup with no child not at end of chain");
  3129:     *aRoot = mParent;
106838:     SetParent(nullptr);
  3129:   }
  3129: }
  3129: 
 82030: NS_IMPL_ISUPPORTS3(nsXULPopupManager,
 13964:                    nsIDOMEventListener,
 71959:                    nsITimerCallback,
 71959:                    nsIObserver)
  3129: 
  3129: nsXULPopupManager::nsXULPopupManager() :
  3129:   mRangeOffset(0),
 30532:   mCachedMousePoint(0, 0),
 73601:   mCachedModifiers(0),
106838:   mActiveMenuBar(nullptr),
106838:   mPopups(nullptr),
106838:   mNoHidePanels(nullptr),
106838:   mTimerMenu(nullptr)
  3129: {
 71959:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
 71959:   if (obs) {
 80486:     obs->AddObserver(this, "xpcom-shutdown", false);
 71959:   }
  3129: }
  3129: 
  3129: nsXULPopupManager::~nsXULPopupManager() 
  3129: {
 22371:   NS_ASSERTION(!mPopups && !mNoHidePanels, "XUL popups still open");
  3129: }
  3129: 
  3129: nsresult
  3129: nsXULPopupManager::Init()
  3129: {
  3129:   sInstance = new nsXULPopupManager();
  3129:   NS_ENSURE_TRUE(sInstance, NS_ERROR_OUT_OF_MEMORY);
  3129:   NS_ADDREF(sInstance);
  3129:   return NS_OK;
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::Shutdown()
  3129: {
  3390:   NS_IF_RELEASE(sInstance);
  3129: }
  3129: 
 71959: NS_IMETHODIMP
 71959: nsXULPopupManager::Observe(nsISupports *aSubject,
 71959:                            const char *aTopic,
 71959:                            const PRUnichar *aData)
 71959: {
 71959:   if (!nsCRT::strcmp(aTopic, "xpcom-shutdown")) {
 71959:     if (mKeyListener) {
 80486:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keypress"), this, true);
 80486:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keydown"), this, true);
 80486:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keyup"), this, true);
106838:       mKeyListener = nullptr;
 71959:     }
106838:     mRangeParent = nullptr;
 71959:     // mOpeningPopup is cleared explicitly soon after using it.
 71959:     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
 71959:     if (obs) {
 71959:       obs->RemoveObserver(this, "xpcom-shutdown");
 71959:     }
 71959:   }
 71959: 
 71959:   return NS_OK;
 71959: }
 71959: 
  3129: nsXULPopupManager*
  3129: nsXULPopupManager::GetInstance()
  3129: {
  3129:   return sInstance;
  3129: }
  3129: 
 82030: nsIContent*
108991: nsXULPopupManager::Rollup(uint32_t aCount, bool aGetLastRolledUp)
  3129: {
106838:   nsIContent* lastRolledUpPopup = nullptr;
  8591: 
  6051:   nsMenuChainItem* item = GetTopVisibleMenu();
  8591:   if (item) {
 82030:     if (aGetLastRolledUp) {
  8591:       // we need to get the popup that will be closed last, so that
  8591:       // widget can keep track of it so it doesn't reopen if a mouse
  8591:       // down event is going to processed.
  8591:       // Keep going up the menu chain to get the first level menu. This will
  8591:       // be the one that closes up last. It's possible that this menu doesn't
  8591:       // end up closing because the popuphiding event was cancelled, but in
  8591:       // that case we don't need to deal with the menu reopening as it will
  8591:       // already still be open.
  8591:       nsMenuChainItem* first = item;
  8591:       while (first->GetParent())
  8591:         first = first->GetParent();
 82030:       lastRolledUpPopup = first->Content();
  8591:     }
 29148: 
 29148:     // if a number of popups to close has been specified, determine the last
 29148:     // popup to close
106838:     nsIContent* lastPopup = nullptr;
 29148:     if (aCount != PR_UINT32_MAX) {
 29148:       nsMenuChainItem* last = item;
 29148:       while (--aCount && last->GetParent()) {
 29148:         last = last->GetParent();
 29148:       }
 29148:       if (last) {
 29148:         lastPopup = last->Content();
 29148:       }
 29148:     }
 29148: 
 80486:     HidePopup(item->Content(), true, true, false, lastPopup);
  8591:   }
 82030: 
 82030:   return lastRolledUpPopup;
  3129: }
  3129: 
  3129: ////////////////////////////////////////////////////////////////////////
 82030: bool nsXULPopupManager::ShouldRollupOnMouseWheelEvent()
  3129: {
  3129:   // should rollup only for autocomplete widgets
  3129:   // XXXndeakin this should really be something the popup has more control over
 60905: 
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
 60905:   if (!item)
 82030:     return false;
 60905: 
 60905:   nsIContent* content = item->Frame()->GetContent();
 82030:   if (!content)
 82030:     return false;
 82030: 
 60905:   nsAutoString value;
 60905:   content->GetAttr(kNameSpaceID_None, nsGkAtoms::type, value);
 82030:   return StringBeginsWith(value, NS_LITERAL_STRING("autocomplete"));
  3129: }
  3129: 
  3129: // a menu should not roll up if activated by a mouse activate message (eg. X-mouse)
 82030: bool nsXULPopupManager::ShouldRollupOnMouseActivate()
  3129: {
 82030:   return false;
  3129: }
  3129: 
108991: uint32_t
 29148: nsXULPopupManager::GetSubmenuWidgetChain(nsTArray<nsIWidget*> *aWidgetChain)
  3129: {
  4407:   // this method is used by the widget code to determine the list of popups
  4407:   // that are open. If a mouse click occurs outside one of these popups, the
  4407:   // panels will roll up. If the click is inside a popup, they will not roll up
108991:   uint32_t count = 0, sameTypeCount = 0;
 29148: 
 29148:   NS_ASSERTION(aWidgetChain, "null parameter");
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  3129:   while (item) {
 83107:     nsCOMPtr<nsIWidget> widget = item->Frame()->GetWidget();
  6048:     NS_ASSERTION(widget, "open popup has no widget");
 29148:     aWidgetChain->AppendElement(widget.get());
  4407:     // In the case when a menulist inside a panel is open, clicking in the
  4407:     // panel should still roll up the menu, so if a different type is found,
  4407:     // stop scanning.
  4407:     nsMenuChainItem* parent = item->GetParent();
 29148:     if (!sameTypeCount) {
 29148:       count++;
  7728:       if (!parent || item->Frame()->PopupType() != parent->Frame()->PopupType() ||
 29148:                      item->IsContextMenu() != parent->IsContextMenu()) {
 29148:         sameTypeCount = count;
 29148:       }
 29148:     }
  4407:     item = parent;
  3129:   }
 29148: 
 29148:   return sameTypeCount;
  3129: }
  3129: 
 10353: void
 48252: nsXULPopupManager::AdjustPopupsOnWindowChange(nsPIDOMWindow* aWindow)
  8408: {
 48253:   // When the parent window is moved, adjust any child popups. Dismissable
 48253:   // menus and panels are expected to roll up when a window is moved, so there
 48253:   // is no need to check these popups, only the noautohide popups.
 22371:   nsMenuChainItem* item = mNoHidePanels;
  8408:   while (item) {
 48252:     // only move popups that are within the same window and where auto
 48252:     // positioning has not been disabled
 48252:     nsMenuPopupFrame* frame= item->Frame();
 48252:     if (frame->GetAutoPosition()) {
 48252:       nsIContent* popup = frame->GetContent();
 48252:       if (popup) {
 48252:         nsIDocument* document = popup->GetCurrentDoc();
 48252:         if (document) {
 48252:           nsPIDOMWindow* window = document->GetWindow();
 48252:           if (window) {
 48252:             window = window->GetPrivateRoot();
 48252:             if (window == aWindow) {
106838:               frame->SetPopupPosition(nullptr, true);
 48252:             }
 48252:           }
 48252:         }
 48252:       }
 48252:     }
 48252: 
  8408:     item = item->GetParent();
  8408:   }
  8408: }
  8408: 
 48253: static
 82567: nsMenuPopupFrame* GetPopupToMoveOrResize(nsIFrame* aFrame)
 48253: {
106921:   nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(aFrame);
106921:   if (!menuPopupFrame)
106838:     return nullptr;
 48253: 
 48253:   // no point moving or resizing hidden popups
 48253:   if (menuPopupFrame->PopupState() != ePopupOpenAndVisible)
106838:     return nullptr;
 48253: 
 48253:   return menuPopupFrame;
 48253: }
 48253: 
 48253: void
 82567: nsXULPopupManager::PopupMoved(nsIFrame* aFrame, nsIntPoint aPnt)
 48253: {
 82567:   nsMenuPopupFrame* menuPopupFrame = GetPopupToMoveOrResize(aFrame);
 48253:   if (!menuPopupFrame)
 48253:     return;
 48253: 
 48253:   // Don't do anything if the popup is already at the specified location. This
 48253:   // prevents recursive calls when a popup is positioned.
 48253:   nsIntPoint currentPnt = menuPopupFrame->ScreenPosition();
 83107:   nsIWidget* widget = menuPopupFrame->GetWidget();
 83107:   if ((aPnt.x != currentPnt.x || aPnt.y != currentPnt.y) || (widget &&
 83107:       widget->GetClientOffset() != menuPopupFrame->GetLastClientOffset())) {
 48253:     // Update the popup's position using SetPopupPosition if the popup is
 48253:     // anchored and at the parent level as these maintain their position
 48253:     // relative to the parent window. Otherwise, just update the popup to
 48253:     // the specified screen coordinates.
 48254:     if (menuPopupFrame->IsAnchored() &&
 48254:         menuPopupFrame->PopupLevel() == ePopupLevelParent) {
106838:       menuPopupFrame->SetPopupPosition(nullptr, true);
 48253:     }
 48253:     else {
 80486:       menuPopupFrame->MoveTo(aPnt.x, aPnt.y, false);
 48253:     }
 48253:   }
 48253: }
 48253: 
 48253: void
 82567: nsXULPopupManager::PopupResized(nsIFrame* aFrame, nsIntSize aSize)
 48253: {
 82567:   nsMenuPopupFrame* menuPopupFrame = GetPopupToMoveOrResize(aFrame);
 48253:   if (!menuPopupFrame)
 48253:     return;
 48253: 
 48253:   nsPresContext* presContext = menuPopupFrame->PresContext();
 48253: 
 48253:   nsSize currentSize = menuPopupFrame->GetSize();
 48253:   if (aSize.width != presContext->AppUnitsToDevPixels(currentSize.width) ||
 48253:       aSize.height != presContext->AppUnitsToDevPixels(currentSize.height)) {
 48253:     // for resizes, we just set the width and height attributes
 48253:     nsIContent* popup = menuPopupFrame->GetContent();
 48253:     nsAutoString width, height;
 48253:     width.AppendInt(aSize.width);
 48253:     height.AppendInt(aSize.height);
 80486:     popup->SetAttr(kNameSpaceID_None, nsGkAtoms::width, width, false);
 80486:     popup->SetAttr(kNameSpaceID_None, nsGkAtoms::height, height, true);
 48253:   }
 48253: }
 48253: 
106921: nsMenuPopupFrame*
106921: nsXULPopupManager::GetPopupFrameForContent(nsIContent* aContent, bool aShouldFlush)
  3129: {
 42267:   if (aShouldFlush) {
  3129:     nsIDocument *document = aContent->GetCurrentDoc();
  3129:     if (document) {
 46225:       nsCOMPtr<nsIPresShell> presShell = document->GetShell();
 42267:       if (presShell)
 52061:         presShell->FlushPendingNotifications(Flush_Layout);
 42267:     }
 42267:   }
  6743: 
106921:   return do_QueryFrame(aContent->GetPrimaryFrame());
  3129: }
  3129: 
  4668: nsMenuChainItem*
  4668: nsXULPopupManager::GetTopVisibleMenu()
  4668: {
 22371:   nsMenuChainItem* item = mPopups;
  4668:   while (item && item->Frame()->PopupState() == ePopupInvisible)
  4668:     item = item->GetParent();
  4668:   return item;
  4668: }
  4668: 
  3129: void
108991: nsXULPopupManager::GetMouseLocation(nsIDOMNode** aNode, int32_t* aOffset)
  3129: {
  3129:   *aNode = mRangeParent;
  3129:   NS_IF_ADDREF(*aNode);
  3129:   *aOffset = mRangeOffset;
  3129: }
  3129: 
  3129: void
 49217: nsXULPopupManager::InitTriggerEvent(nsIDOMEvent* aEvent, nsIContent* aPopup,
 49217:                                     nsIContent** aTriggerContent)
  3129: {
 23738:   mCachedMousePoint = nsIntPoint(0, 0);
  3560: 
 49217:   if (aTriggerContent) {
106838:     *aTriggerContent = nullptr;
 49217:     if (aEvent) {
 49217:       // get the trigger content from the event
 49217:       nsCOMPtr<nsIDOMEventTarget> target;
 49217:       aEvent->GetTarget(getter_AddRefs(target));
 49217:       if (target) {
 49217:         CallQueryInterface(target, aTriggerContent);
 49217:       }
 49217:     }
 49217:   }
 49217: 
 73601:   mCachedModifiers = 0;
 73601: 
 77226:   nsCOMPtr<nsIDOMUIEvent> uiEvent = do_QueryInterface(aEvent);
  3129:   if (uiEvent) {
  3129:     uiEvent->GetRangeParent(getter_AddRefs(mRangeParent));
  3129:     uiEvent->GetRangeOffset(&mRangeOffset);
  3560: 
  3560:     // get the event coordinates relative to the root frame of the document
  3560:     // containing the popup.
  3560:     NS_ASSERTION(aPopup, "Expected a popup node");
101616:     nsEvent* event = aEvent->GetInternalNSEvent();
 20234:     if (event) {
 73601:       if (event->eventStructType == NS_MOUSE_EVENT ||
 73601:           event->eventStructType == NS_KEY_EVENT) {
 96893:         mCachedModifiers = static_cast<nsInputEvent*>(event)->modifiers;
 73601:       }
  3560:       nsIDocument* doc = aPopup->GetCurrentDoc();
  3560:       if (doc) {
 46225:         nsIPresShell* presShell = doc->GetShell();
 47902:         nsPresContext* presContext;
 47902:         if (presShell && (presContext = presShell->GetPresContext())) {
 30532:           nsPresContext* rootDocPresContext =
 47902:             presContext->GetRootPresContext();
 37502:           if (!rootDocPresContext)
 37502:             return;
 30532:           nsIFrame* rootDocumentRootFrame = rootDocPresContext->
 30532:               PresShell()->FrameManager()->GetRootFrame();
 11962:           if ((event->eventStructType == NS_MOUSE_EVENT || 
108049:                event->eventStructType == NS_MOUSE_SCROLL_EVENT ||
108049:                event->eventStructType == NS_WHEEL_EVENT) &&
 11962:                !(static_cast<nsGUIEvent *>(event))->widget) {
 11962:             // no widget, so just use the client point if available
 11962:             nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
 30532:             nsIntPoint clientPt;
 30532:             mouseEvent->GetClientX(&clientPt.x);
 30532:             mouseEvent->GetClientY(&clientPt.y);
 11962: 
 30532:             // XXX this doesn't handle IFRAMEs in transforms
 47902:             nsPoint thisDocToRootDocOffset = presShell->FrameManager()->
 47902:               GetRootFrame()->GetOffsetToCrossDoc(rootDocumentRootFrame);
 11962:             // convert to device pixels
 47902:             mCachedMousePoint.x = presContext->AppUnitsToDevPixels(
 30532:                 nsPresContext::CSSPixelsToAppUnits(clientPt.x) + thisDocToRootDocOffset.x);
 47902:             mCachedMousePoint.y = presContext->AppUnitsToDevPixels(
 30532:                 nsPresContext::CSSPixelsToAppUnits(clientPt.y) + thisDocToRootDocOffset.y);
 11962:           }
 30532:           else if (rootDocumentRootFrame) {
  3560:             nsPoint pnt =
 30532:               nsLayoutUtils::GetEventCoordinatesRelativeTo(event, rootDocumentRootFrame);
 30532:             mCachedMousePoint = nsIntPoint(rootDocPresContext->AppUnitsToDevPixels(pnt.x),
 30532:                                            rootDocPresContext->AppUnitsToDevPixels(pnt.y));
  3560:           }
  3560:         }
  3560:       }
  3560:     }
  3560:   }
  3129:   else {
106838:     mRangeParent = nullptr;
  3129:     mRangeOffset = 0;
  3129:   }
  3129: }
  3129: 
  3129: void
 79445: nsXULPopupManager::SetActiveMenuBar(nsMenuBarFrame* aMenuBar, bool aActivate)
  3129: {
  3129:   if (aActivate)
  3129:     mActiveMenuBar = aMenuBar;
  3129:   else if (mActiveMenuBar == aMenuBar)
106838:     mActiveMenuBar = nullptr;
  3129: 
  3129:   UpdateKeyboardListeners();
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::ShowMenu(nsIContent *aMenu,
 79445:                             bool aSelectFirstItem,
 79445:                             bool aAsynchronous)
  3129: {
 12021:   // generate any template content first. Otherwise, the menupopup may not
 12021:   // have been created yet.
 12021:   if (aMenu) {
 12021:     nsIContent* element = aMenu;
 12021:     do {
 12021:       nsCOMPtr<nsIDOMXULElement> xulelem = do_QueryInterface(element);
 12021:       if (xulelem) {
 12021:         nsCOMPtr<nsIXULTemplateBuilder> builder;
 12021:         xulelem->GetBuilder(getter_AddRefs(builder));
 12021:         if (builder) {
 80486:           builder->CreateContents(aMenu, true);
 12021:           break;
 12021:         }
 12021:       }
 12021:       element = element->GetParent();
 12021:     } while (element);
 12021:   }
 12021: 
106921:   nsMenuFrame* menuFrame = do_QueryFrame(aMenu->GetPrimaryFrame());
  3129:   if (!menuFrame || !menuFrame->IsMenu())
  3129:     return;
  3129: 
  3129:   nsMenuPopupFrame* popupFrame =  menuFrame->GetPopup();
  3129:   if (!popupFrame || !MayShowPopup(popupFrame))
  3129:     return;
  3129: 
  3129:   // inherit whether or not we're a context menu from the parent
 79445:   bool parentIsContextMenu = false;
 79445:   bool onMenuBar = false;
 79445:   bool onmenu = menuFrame->IsOnMenu();
  3129: 
 22372:   nsMenuParent* parent = menuFrame->GetMenuParent();
  3129:   if (parent && onmenu) {
  3129:     parentIsContextMenu = parent->IsContextMenu();
  3129:     onMenuBar = parent->IsMenuBar();
  3129:   }
  3129: 
  3129:   nsAutoString position;
  3129:   if (onMenuBar || !onmenu)
  3129:     position.AssignLiteral("after_start");
  3129:   else
  3129:     position.AssignLiteral("end_before");
 49217: 
 52061:   // there is no trigger event for menus
106838:   InitTriggerEvent(nullptr, nullptr, nullptr);
106838:   popupFrame->InitializePopup(aMenu, nullptr, position, 0, 0, true);
  3129: 
  3129:   if (aAsynchronous) {
  3129:     nsCOMPtr<nsIRunnable> event =
 52061:       new nsXULPopupShowingEvent(popupFrame->GetContent(),
  3129:                                  parentIsContextMenu, aSelectFirstItem);
  3129:     NS_DispatchToCurrentThread(event);
  3129:   }
  3129:   else {
  4234:     nsCOMPtr<nsIContent> popupContent = popupFrame->GetContent();
 52061:     FirePopupShowingEvent(popupContent, parentIsContextMenu, aSelectFirstItem);
  3129:   }
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::ShowPopup(nsIContent* aPopup,
  3129:                              nsIContent* aAnchorContent,
  3129:                              const nsAString& aPosition,
108991:                              int32_t aXPos, int32_t aYPos,
 79445:                              bool aIsContextMenu,
 79445:                              bool aAttributesOverride,
 79445:                              bool aSelectFirstItem,
  8127:                              nsIDOMEvent* aTriggerEvent)
  3129: {
 80486:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup, true);
  3129:   if (!popupFrame || !MayShowPopup(popupFrame))
  3129:     return;
  3129: 
 49217:   nsCOMPtr<nsIContent> triggerContent;
 49217:   InitTriggerEvent(aTriggerEvent, aPopup, getter_AddRefs(triggerContent));
  8127: 
 49217:   popupFrame->InitializePopup(aAnchorContent, triggerContent, aPosition,
 49217:                               aXPos, aYPos, aAttributesOverride);
  3129: 
 52061:   FirePopupShowingEvent(aPopup, aIsContextMenu, aSelectFirstItem);
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::ShowPopupAtScreen(nsIContent* aPopup,
108991:                                      int32_t aXPos, int32_t aYPos,
 79445:                                      bool aIsContextMenu,
  8127:                                      nsIDOMEvent* aTriggerEvent)
  3129: {
 80486:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup, true);
  3129:   if (!popupFrame || !MayShowPopup(popupFrame))
  3129:     return;
  3129: 
 49217:   nsCOMPtr<nsIContent> triggerContent;
 49217:   InitTriggerEvent(aTriggerEvent, aPopup, getter_AddRefs(triggerContent));
  8127: 
 49217:   popupFrame->InitializePopupAtScreen(triggerContent, aXPos, aYPos, aIsContextMenu);
 80486:   FirePopupShowingEvent(aPopup, aIsContextMenu, false);
  3129: }
  3129: 
  3129: void
 52415: nsXULPopupManager::ShowTooltipAtScreen(nsIContent* aPopup,
 52415:                                        nsIContent* aTriggerContent,
108991:                                        int32_t aXPos, int32_t aYPos)
 52415: {
 80486:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup, true);
 52415:   if (!popupFrame || !MayShowPopup(popupFrame))
 52415:     return;
 52415: 
106838:   InitTriggerEvent(nullptr, nullptr, nullptr);
 52415: 
 55146:   mCachedMousePoint = nsIntPoint(aXPos, aYPos);
 55146:   // coordinates are relative to the root widget
 55146:   nsPresContext* rootPresContext =
 55146:     popupFrame->PresContext()->GetRootPresContext();
 55146:   if (rootPresContext) {
 55146:     nsCOMPtr<nsIWidget> widget;
 55146:     rootPresContext->PresShell()->GetViewManager()->
 55146:       GetRootWidget(getter_AddRefs(widget));
110233:     if (widget)
 55146:       mCachedMousePoint -= widget->WidgetToScreenOffset();
 55146:   }
 55146: 
 80486:   popupFrame->InitializePopupAtScreen(aTriggerContent, aXPos, aYPos, false);
 52415: 
 80486:   FirePopupShowingEvent(aPopup, false, false);
 52415: }
 52415: 
 52415: void
  3129: nsXULPopupManager::ShowPopupWithAnchorAlign(nsIContent* aPopup,
  3129:                                             nsIContent* aAnchorContent,
  3129:                                             nsAString& aAnchor,
  3129:                                             nsAString& aAlign,
108991:                                             int32_t aXPos, int32_t aYPos,
 79445:                                             bool aIsContextMenu)
  3129: {
 80486:   nsMenuPopupFrame* popupFrame = GetPopupFrameForContent(aPopup, true);
  3129:   if (!popupFrame || !MayShowPopup(popupFrame))
  3129:     return;
  3129: 
106838:   InitTriggerEvent(nullptr, nullptr, nullptr);
  8127: 
  3129:   popupFrame->InitializePopupWithAnchorAlign(aAnchorContent, aAnchor,
  3129:                                              aAlign, aXPos, aYPos);
 80486:   FirePopupShowingEvent(aPopup, aIsContextMenu, false);
  3129: }
  3129: 
 13787: static void
 29018: CheckCaretDrawingState() {
 13787: 
 13787:   // There is 1 caret per document, we need to find the focused
 13787:   // document and erase its caret.
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm) {
 29018:     nsCOMPtr<nsIDOMWindow> window;
 29018:     fm->GetFocusedWindow(getter_AddRefs(window));
 29018:     if (!window)
 13787:       return;
 13787: 
 13787:     nsCOMPtr<nsIDOMDocument> domDoc;
 13787:     nsCOMPtr<nsIDocument> focusedDoc;
 73870:     window->GetDocument(getter_AddRefs(domDoc));
 13787:     focusedDoc = do_QueryInterface(domDoc);
 13787:     if (!focusedDoc)
 13787:       return;
 13787: 
 46225:     nsIPresShell* presShell = focusedDoc->GetShell();
 13884:     if (!presShell)
 13884:       return;
 13787: 
 40045:     nsRefPtr<nsCaret> caret = presShell->GetCaret();
 13884:     if (!caret)
 13884:       return;
 13787:     caret->CheckCaretDrawingState();
 29018:   }
 13787: }
 13787: 
  3129: void
  3129: nsXULPopupManager::ShowPopupCallback(nsIContent* aPopup,
  3129:                                      nsMenuPopupFrame* aPopupFrame,
 79445:                                      bool aIsContextMenu,
 79445:                                      bool aSelectFirstItem)
  3129: {
  4709:   nsPopupType popupType = aPopupFrame->PopupType();
 79445:   bool ismenu = (popupType == ePopupTypeMenu);
  3129: 
  3129:   nsMenuChainItem* item =
  4709:     new nsMenuChainItem(aPopupFrame, aIsContextMenu, popupType);
  3129:   if (!item)
  3129:     return;
  3129: 
  7871:   // install keyboard event listeners for navigating menus. For panels, the
  7871:   // escape key may be used to close the panel. However, the ignorekeys
  7871:   // attribute may be used to disable adding these event listeners for popups
  7871:   // that want to handle their own keyboard events.
  3129:   if (aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::ignorekeys,
  3129:                            nsGkAtoms::_true, eCaseMatters))
 80486:     item->SetIgnoreKeys(true);
  3129: 
  7871:   if (ismenu) {
  3129:     // if the menu is on a menubar, use the menubar's listener instead
106921:     nsMenuFrame* menuFrame = do_QueryFrame(aPopupFrame->GetParent());
 49217:     if (menuFrame) {
  3129:       item->SetOnMenuBar(menuFrame->IsOnMenuBar());
  3129:     }
  3129:   }
  3129: 
  3129:   // use a weak frame as the popup will set an open attribute if it is a menu
  3129:   nsWeakFrame weakFrame(aPopupFrame);
 52061:   aPopupFrame->ShowPopup(aIsContextMenu, aSelectFirstItem);
  3129:   ENSURE_TRUE(weakFrame.IsAlive());
  3129: 
  3129:   // popups normally hide when an outside click occurs. Panels may use
  3129:   // the noautohide attribute to disable this behaviour. It is expected
  3129:   // that the application will hide these popups manually. The tooltip
  3129:   // listener will handle closing the tooltip also.
  8408:   if (aPopupFrame->IsNoAutoHide() || popupType == ePopupTypeTooltip) {
 22371:     item->SetParent(mNoHidePanels);
 22371:     mNoHidePanels = item;
  3129:   }
  3129:   else {
106838:     nsIContent* oldmenu = nullptr;
 22371:     if (mPopups)
 22371:       oldmenu = mPopups->Content();
 22371:     item->SetParent(mPopups);
 22371:     mPopups = item;
  3129:     SetCaptureState(oldmenu);
  3129:   }
  3129: 
  3129:   if (aSelectFirstItem) {
106838:     nsMenuFrame* next = GetNextMenuItem(aPopupFrame, nullptr, true);
  3129:     aPopupFrame->SetCurrentMenuItem(next);
  3129:   }
  3129: 
  3129:   if (ismenu)
  3129:     UpdateMenuItems(aPopup);
 13787: 
 13787:   // Caret visibility may have been affected, ensure that
 13787:   // the caret isn't now drawn when it shouldn't be.
 29018:   CheckCaretDrawingState();
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::HidePopup(nsIContent* aPopup,
 79445:                              bool aHideChain,
 79445:                              bool aDeselectMenu,
 79445:                              bool aAsynchronous,
 29148:                              nsIContent* aLastPopup)
  3129: {
 22371:   // if the popup is on the nohide panels list, remove it but don't close any
 22371:   // other panels
106838:   nsMenuPopupFrame* popupFrame = nullptr;
 79445:   bool foundPanel = false;
 22371:   nsMenuChainItem* item = mNoHidePanels;
  3129:   while (item) {
  3129:     if (item->Content() == aPopup) {
 80486:       foundPanel = true;
  3129:       popupFrame = item->Frame();
  3129:       break;
  3129:     }
  3129:     item = item->GetParent();
  3129:   }
  3129: 
  3129:   // when removing a menu, all of the child popups must be closed
106838:   nsMenuChainItem* foundMenu = nullptr;
 22371:   item = mPopups;
  3129:   while (item) {
  3129:     if (item->Content() == aPopup) {
  3129:       foundMenu = item;
  3129:       break;
  3129:     }
  3129:     item = item->GetParent();
  3129:   }
  3129: 
  4709:   nsPopupType type = ePopupTypePanel;
 79445:   bool deselectMenu = false;
  3129:   nsCOMPtr<nsIContent> popupToHide, nextPopup, lastPopup;
  3129:   if (foundMenu) {
  5227:     // at this point, foundMenu will be set to the found item in the list. If
  5227:     // foundMenu is the topmost menu, the one to remove, then there are no other
  5227:     // popups to hide. If foundMenu is not the topmost menu, then there may be
  3129:     // open submenus below it. In this case, we need to make sure that those
  5227:     // submenus are closed up first. To do this, we scan up the menu list to
  5227:     // find the topmost popup with only menus between it and foundMenu and
  5227:     // close that menu first. In synchronous mode, the FirePopupHidingEvent
  5227:     // method will be called which in turn calls HidePopupCallback to close up
  5227:     // the next popup in the chain. These two methods will be called in
  5227:     // sequence recursively to close up all the necessary popups. In
  5227:     // asynchronous mode, a similar process occurs except that the
  8127:     // FirePopupHidingEvent method is called asynchronously. In either case,
  5227:     // nextPopup is set to the content node of the next popup to close, and
  5227:     // lastPopup is set to the last popup in the chain to close, which will be
  5227:     // aPopup, or null to close up all menus.
  5227: 
  5227:     nsMenuChainItem* topMenu = foundMenu;
  5227:     // Use IsMenu to ensure that foundMenu is a menu and scan down the child
  5227:     // list until a non-menu is found. If foundMenu isn't a menu at all, don't
  5227:     // scan and just close up this menu.
  5227:     if (foundMenu->IsMenu()) {
  5227:       item = topMenu->GetChild();
  5227:       while (item && item->IsMenu()) {
  5227:         topMenu = item;
  5227:         item = item->GetChild();
  5227:       }
  5227:     }
  5227:     
  3129:     deselectMenu = aDeselectMenu;
  5227:     popupToHide = topMenu->Content();
  5227:     popupFrame = topMenu->Frame();
  4709:     type = popupFrame->PopupType();
  3129: 
  5227:     nsMenuChainItem* parent = topMenu->GetParent();
  3129: 
  4234:     // close up another popup if there is one, and we are either hiding the
  4234:     // entire chain or the item to hide isn't the topmost popup.
  5227:     if (parent && (aHideChain || topMenu != foundMenu))
  4234:       nextPopup = parent->Content();
  3129: 
106838:     lastPopup = aLastPopup ? aLastPopup : (aHideChain ? nullptr : aPopup);
  3129:   }
  3129:   else if (foundPanel) {
  3129:     popupToHide = aPopup;
  3129:   }
  3129: 
  3129:   if (popupFrame) {
  4234:     nsPopupState state = popupFrame->PopupState();
  4234:     // if the popup is already being hidden, don't attempt to hide it again
  4234:     if (state == ePopupHiding)
  4234:       return;
  4234:     // change the popup state to hiding. Don't set the hiding state if the
  4234:     // popup is invisible, otherwise nsMenuPopupFrame::HidePopup will
  4234:     // run again. In the invisible state, we just want the events to fire.
  4234:     if (state != ePopupInvisible)
  4234:       popupFrame->SetPopupState(ePopupHiding);
  4234: 
 49217:     // for menus, popupToHide is always the frontmost item in the list to hide.
  3129:     if (aAsynchronous) {
  3129:       nsCOMPtr<nsIRunnable> event =
  3129:         new nsXULPopupHidingEvent(popupToHide, nextPopup, lastPopup,
  4709:                                   type, deselectMenu);
  3129:         NS_DispatchToCurrentThread(event);
  3129:     }
  3129:     else {
  3129:       FirePopupHidingEvent(popupToHide, nextPopup, lastPopup,
  4709:                            popupFrame->PresContext(), type, deselectMenu);
  3129:     }
  3129:   }
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::HidePopupCallback(nsIContent* aPopup,
  3129:                                      nsMenuPopupFrame* aPopupFrame,
  3129:                                      nsIContent* aNextPopup,
  3129:                                      nsIContent* aLastPopup,
  4709:                                      nsPopupType aPopupType,
 79445:                                      bool aDeselectMenu)
  3129: {
  7231:   if (mCloseTimer && mTimerMenu == aPopupFrame) {
  3129:     mCloseTimer->Cancel();
106838:     mCloseTimer = nullptr;
106838:     mTimerMenu = nullptr;
  3129:   }
  3129: 
  4234:   // The popup to hide is aPopup. Search the list again to find the item that
  4234:   // corresponds to the popup to hide aPopup. This is done because it's
  4234:   // possible someone added another item (attempted to open another popup)
  4234:   // or removed a popup frame during the event processing so the item isn't at
  4234:   // the front anymore.
 22371:   nsMenuChainItem* item = mNoHidePanels;
  4234:   while (item) {
  4234:     if (item->Content() == aPopup) {
 22371:       item->Detach(&mNoHidePanels);
  4234:       break;
  4234:     }
  4234:     item = item->GetParent();
  4234:   }
  4234: 
  4234:   if (!item) {
 22371:     item = mPopups;
  4234:     while (item) {
  4234:       if (item->Content() == aPopup) {
 22371:         item->Detach(&mPopups);
  4234:         SetCaptureState(aPopup);
  4234:         break;
  4234:       }
  4234:       item = item->GetParent();
  4234:     }
  4234:   }
  4234: 
  4234:   delete item;
  4234: 
  3129:   nsWeakFrame weakFrame(aPopupFrame);
  4234:   aPopupFrame->HidePopup(aDeselectMenu, ePopupClosed);
  3129:   ENSURE_TRUE(weakFrame.IsAlive());
  3129: 
  3129:   // send the popuphidden event synchronously. This event has no default behaviour.
  3129:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   nsMouseEvent event(true, NS_XUL_POPUP_HIDDEN, nullptr, nsMouseEvent::eReal);
  3129:   nsEventDispatcher::Dispatch(aPopup, aPopupFrame->PresContext(),
106838:                               &event, nullptr, &status);
  3129: 
  3129:   // if there are more popups to close, look for the next one
  3129:   if (aNextPopup && aPopup != aLastPopup) {
106838:     nsMenuChainItem* foundMenu = nullptr;
 22371:     nsMenuChainItem* item = mPopups;
  3129:     while (item) {
  3129:       if (item->Content() == aNextPopup) {
  3129:         foundMenu = item;
  3129:         break;
  3129:       }
  3129:       item = item->GetParent();
  3129:     }
  3129: 
  3129:     // continue hiding the chain of popups until the last popup aLastPopup
  3129:     // is reached, or until a popup of a different type is reached. This
  3129:     // last check is needed so that a menulist inside a non-menu panel only
  3129:     // closes the menu and not the panel as well.
  4709:     if (foundMenu &&
  4709:         (aLastPopup || aPopupType == foundMenu->PopupType())) {
 29148: 
  3129:       nsCOMPtr<nsIContent> popupToHide = item->Content();
  3300:       nsMenuChainItem* parent = item->GetParent();
  3129: 
  3129:       nsCOMPtr<nsIContent> nextPopup;
  3300:       if (parent && popupToHide != aLastPopup)
  3300:         nextPopup = parent->Content();
  3129: 
  4234:       nsMenuPopupFrame* popupFrame = item->Frame();
  4234:       nsPopupState state = popupFrame->PopupState();
  4234:       if (state == ePopupHiding)
  4234:         return;
  4234:       if (state != ePopupInvisible)
  4234:         popupFrame->SetPopupState(ePopupHiding);
  3129: 
  3129:       FirePopupHidingEvent(popupToHide, nextPopup, aLastPopup,
  4709:                            popupFrame->PresContext(),
  4709:                            foundMenu->PopupType(), aDeselectMenu);
  3129:     }
  3129:   }
  3129: }
  3129: 
  3129: void
 82567: nsXULPopupManager::HidePopup(nsIFrame* aFrame)
 48261: {
106921:   nsMenuPopupFrame* popup = do_QueryFrame(aFrame);
106921:   if (popup)
 82567:     HidePopup(aFrame->GetContent(), false, true, false);
 48261: }
 48261: 
 48261: void
  3129: nsXULPopupManager::HidePopupAfterDelay(nsMenuPopupFrame* aPopup)
  3129: {
  3129:   // Don't close up immediately.
  3129:   // Kick off a close timer.
  3129:   KillMenuTimer();
  3129: 
108991:   int32_t menuDelay =
 78129:     LookAndFeel::GetInt(LookAndFeel::eIntID_SubmenuDelay, 300); // ms
  3129: 
  3129:   // Kick off the timer.
  3129:   mCloseTimer = do_CreateInstance("@mozilla.org/timer;1");
  3129:   mCloseTimer->InitWithCallback(this, menuDelay, nsITimer::TYPE_ONE_SHOT);
  3129: 
  3129:   // the popup will call PopupDestroyed if it is destroyed, which checks if it
  3129:   // is set to mTimerMenu, so it should be safe to keep a reference to it
  3129:   mTimerMenu = aPopup;
  3129: }
  3129: 
  3129: void
  8127: nsXULPopupManager::HidePopupsInList(const nsTArray<nsMenuPopupFrame *> &aFrames,
 79445:                                     bool aDeselectMenu)
  8127: {
  8127:   // Create a weak frame list. This is done in a separate array with the
  8127:   // right capacity predetermined, otherwise the array would get resized and
  8127:   // move the weak frame pointers around.
  8127:   nsTArray<nsWeakFrame> weakPopups(aFrames.Length());
108991:   uint32_t f;
  8127:   for (f = 0; f < aFrames.Length(); f++) {
  8127:     nsWeakFrame* wframe = weakPopups.AppendElement();
  8127:     if (wframe)
  8127:       *wframe = aFrames[f];
  8127:   }
  8127: 
  8127:   for (f = 0; f < weakPopups.Length(); f++) {
  8127:     // check to ensure that the frame is still alive before hiding it.
  8127:     if (weakPopups[f].IsAlive()) {
  8127:       nsMenuPopupFrame* frame =
  8127:         static_cast<nsMenuPopupFrame *>(weakPopups[f].GetFrame());
 80486:       frame->HidePopup(true, ePopupInvisible);
  8127:     }
  8127:   }
  8127: 
106838:   SetCaptureState(nullptr);
  8127: }
  8127: 
 79445: bool
 11414: nsXULPopupManager::IsChildOfDocShell(nsIDocument* aDoc, nsIDocShellTreeItem* aExpected)
 11414: {
 11414:   nsCOMPtr<nsISupports> doc = aDoc->GetContainer();
 11414:   nsCOMPtr<nsIDocShellTreeItem> docShellItem(do_QueryInterface(doc));
 11414:   while(docShellItem) {
 11414:     if (docShellItem == aExpected)
 80486:       return true;
 11414: 
 11414:     nsCOMPtr<nsIDocShellTreeItem> parent;
 11414:     docShellItem->GetParent(getter_AddRefs(parent));
 11414:     docShellItem = parent;
 11414:   }
 11414: 
 80486:   return false;
 11414: }
 11414: 
  8127: void
 11414: nsXULPopupManager::HidePopupsInDocShell(nsIDocShellTreeItem* aDocShellToHide)
  3129: {
  8127:   nsTArray<nsMenuPopupFrame *> popupsToHide;
  8127: 
  8127:   // iterate to get the set of popup frames to hide
 22371:   nsMenuChainItem* item = mPopups;
  3129:   while (item) {
  4234:     nsMenuChainItem* parent = item->GetParent();
  8127:     if (item->Frame()->PopupState() != ePopupInvisible &&
 80526:         IsChildOfDocShell(item->Content()->OwnerDoc(), aDocShellToHide)) {
  8127:       nsMenuPopupFrame* frame = item->Frame();
 22371:       item->Detach(&mPopups);
  4234:       delete item;
  8127:       popupsToHide.AppendElement(frame);
  4234:     }
  4234:     item = parent;
  3129:   }
  3129: 
  8127:   // now look for panels to hide
 22371:   item = mNoHidePanels;
  3129:   while (item) {
  4234:     nsMenuChainItem* parent = item->GetParent();
  8127:     if (item->Frame()->PopupState() != ePopupInvisible &&
 80526:         IsChildOfDocShell(item->Content()->OwnerDoc(), aDocShellToHide)) {
  8127:       nsMenuPopupFrame* frame = item->Frame();
 22371:       item->Detach(&mNoHidePanels);
  4234:       delete item;
  8127:       popupsToHide.AppendElement(frame);
  4234:     }
  4234:     item = parent;
  3129:   }
  4668: 
 80486:   HidePopupsInList(popupsToHide, true);
  3129: }
  3129: 
  3129: void
 41073: nsXULPopupManager::ExecuteMenu(nsIContent* aMenu, nsXULMenuCommandEvent* aEvent)
  3129: {
  5462:   CloseMenuMode cmm = CloseMenuMode_Auto;
  5462: 
  5462:   static nsIContent::AttrValuesArray strings[] =
106838:     {&nsGkAtoms::none, &nsGkAtoms::single, nullptr};
  5462: 
  5462:   switch (aMenu->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::closemenu,
  5462:                                  strings, eCaseMatters)) {
  5462:     case 0:
  5462:       cmm = CloseMenuMode_None;
  5462:       break;
  5462:     case 1:
  5462:       cmm = CloseMenuMode_Single;
  5462:       break;
  5462:     default:
  5462:       break;
  5462:   }
  5462: 
  3129:   // When a menuitem is selected to be executed, first hide all the open
  3129:   // popups, but don't remove them yet. This is needed when a menu command
  3129:   // opens a modal dialog. The views associated with the popups needed to be
  3129:   // hidden and the accesibility events fired before the command executes, but
  3129:   // the popuphiding/popuphidden events are fired afterwards.
  8127:   nsTArray<nsMenuPopupFrame *> popupsToHide;
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  5462:   if (cmm != CloseMenuMode_None) {
  3129:     while (item) {
  3129:       // if it isn't a <menupopup>, don't close it automatically
  3129:       if (!item->IsMenu())
  3129:         break;
  3129:       nsMenuChainItem* next = item->GetParent();
  8127:       popupsToHide.AppendElement(item->Frame());
  5462:       if (cmm == CloseMenuMode_Single) // only close one level of menu
  5462:         break;
  3129:       item = next;
  3129:     }
  8127: 
  8127:     // Now hide the popups. If the closemenu mode is auto, deselect the menu,
  8127:     // otherwise only one popup is closing, so keep the parent menu selected.
  8127:     HidePopupsInList(popupsToHide, cmm == CloseMenuMode_Auto);
  5462:   }
  3129: 
 41073:   aEvent->SetCloseMenuMode(cmm);
 41073:   nsCOMPtr<nsIRunnable> event = aEvent;
  3129:   NS_DispatchToCurrentThread(event);
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::FirePopupShowingEvent(nsIContent* aPopup,
 79445:                                          bool aIsContextMenu,
 79445:                                          bool aSelectFirstItem)
  3129: {
 52061:   nsCOMPtr<nsIContent> popup = aPopup; // keep a strong reference to the popup
 52061: 
106921:   nsMenuPopupFrame* popupFrame = do_QueryFrame(aPopup->GetPrimaryFrame());
106921:   if (!popupFrame)
 52061:     return;
 52061: 
 52061:   nsPresContext *presContext = popupFrame->PresContext();
 52061:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
 52061:   nsPopupType popupType = popupFrame->PopupType();
 52061: 
 52061:   // generate the child frames if they have not already been generated
 52061:   if (!popupFrame->HasGeneratedChildren()) {
 52061:     popupFrame->SetGeneratedChildren();
 52061:     presShell->FrameConstructor()->GenerateChildFrames(popupFrame);
 52061:   }
 52061: 
 52061:   // get the frame again
106921:   nsIFrame* frame = aPopup->GetPrimaryFrame();
 52061:   if (!frame)
 52061:     return;
 52061: 
 52061:   presShell->FrameNeedsReflow(frame, nsIPresShell::eTreeChange,
 52061:                               NS_FRAME_HAS_DIRTY_CHILDREN);
  3129: 
 49217:   // cache the popup so that document.popupNode can retrieve the trigger node
 49217:   // during the popupshowing event. It will be cleared below after the event
 49217:   // has fired.
 49217:   mOpeningPopup = aPopup;
 49217: 
  3129:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   nsMouseEvent event(true, NS_XUL_POPUP_SHOWING, nullptr, nsMouseEvent::eReal);
 32215: 
 32215:   // coordinates are relative to the root widget
 32215:   nsPresContext* rootPresContext =
 37502:     presShell->GetPresContext()->GetRootPresContext();
 37502:   if (rootPresContext) {
 37502:     rootPresContext->PresShell()->GetViewManager()->
 37502:       GetRootWidget(getter_AddRefs(event.widget));
 37502:   }
 37502:   else {
106838:     event.widget = nullptr;
 37502:   }
 32215: 
  3560:   event.refPoint = mCachedMousePoint;
 96893:   event.modifiers = mCachedModifiers;
106838:   nsEventDispatcher::Dispatch(popup, presContext, &event, nullptr, &status);
 73601: 
 23738:   mCachedMousePoint = nsIntPoint(0, 0);
106838:   mOpeningPopup = nullptr;
  3129: 
 73601:   mCachedModifiers = 0;
 73601: 
  4709:   // if a panel, blur whatever has focus so that the panel can take the focus.
  4709:   // This is done after the popupshowing event in case that event is cancelled.
  4709:   // Using noautofocus="true" will disable this behaviour, which is needed for
  4709:   // the autocomplete widget as it manages focus itself.
 52061:   if (popupType == ePopupTypePanel &&
 52061:       !popup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautofocus,
  4709:                            nsGkAtoms::_true, eCaseMatters)) {
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     if (fm) {
 52061:       nsIDocument* doc = popup->GetCurrentDoc();
  4709: 
  4709:       // Only remove the focus if the currently focused item is ouside the
  4709:       // popup. It isn't a big deal if the current focus is in a child popup
  4709:       // inside the popup as that shouldn't be visible. This check ensures that
  4709:       // a node inside the popup that is focused during a popupshowing event
  4709:       // remains focused.
 29018:       nsCOMPtr<nsIDOMElement> currentFocusElement;
 29018:       fm->GetFocusedElement(getter_AddRefs(currentFocusElement));
 29018:       nsCOMPtr<nsIContent> currentFocus = do_QueryInterface(currentFocusElement);
 29018:       if (doc && currentFocus &&
 52061:           !nsContentUtils::ContentIsCrossDocDescendantOf(currentFocus, popup)) {
 29018:         fm->ClearFocus(doc->GetWindow());
 29018:       }
  4709:     }
  4709:   }
  4709: 
 49217:   // clear these as they are no longer valid
106838:   mRangeParent = nullptr;
 49217:   mRangeOffset = 0;
 49217: 
  3129:   // get the frame again in case it went away
106921:   popupFrame = do_QueryFrame(aPopup->GetPrimaryFrame());
106921:   if (popupFrame) {
 49217:     // if the event was cancelled, don't open the popup, reset its state back
 49217:     // to closed and clear its trigger content.
  4234:     if (status == nsEventStatus_eConsumeNoDefault) {
  4234:       popupFrame->SetPopupState(ePopupClosed);
 52416:       popupFrame->ClearTriggerContent();
  4234:     }
  4234:     else {
  3129:       ShowPopupCallback(aPopup, popupFrame, aIsContextMenu, aSelectFirstItem);
  3129:     }
  3129:   }
  4234: }
  3129: 
  3129: void
  3129: nsXULPopupManager::FirePopupHidingEvent(nsIContent* aPopup,
  3129:                                         nsIContent* aNextPopup,
  3129:                                         nsIContent* aLastPopup,
  3129:                                         nsPresContext *aPresContext,
  4709:                                         nsPopupType aPopupType,
 79445:                                         bool aDeselectMenu)
  3129: {
  3129:   nsCOMPtr<nsIPresShell> presShell = aPresContext->PresShell();
  3129: 
  3129:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   nsMouseEvent event(true, NS_XUL_POPUP_HIDING, nullptr, nsMouseEvent::eReal);
106838:   nsEventDispatcher::Dispatch(aPopup, aPresContext, &event, nullptr, &status);
  3129: 
  4709:   // when a panel is closed, blur whatever has focus inside the popup
  4709:   if (aPopupType == ePopupTypePanel &&
  4709:       !aPopup->AttrValueIs(kNameSpaceID_None, nsGkAtoms::noautofocus,
  4709:                            nsGkAtoms::_true, eCaseMatters)) {
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     if (fm) {
 29018:       nsIDocument* doc = aPopup->GetCurrentDoc();
  4709: 
  4709:       // Remove the focus from the focused node only if it is inside the popup.
 29018:       nsCOMPtr<nsIDOMElement> currentFocusElement;
 29018:       fm->GetFocusedElement(getter_AddRefs(currentFocusElement));
 29018:       nsCOMPtr<nsIContent> currentFocus = do_QueryInterface(currentFocusElement);
 29018:       if (doc && currentFocus &&
 32033:           nsContentUtils::ContentIsCrossDocDescendantOf(currentFocus, aPopup)) {
 29018:         fm->ClearFocus(doc->GetWindow());
 29018:       }
  4709:     }
  4709:   }
  4709: 
  3129:   // get frame again in case it went away
106921:   nsMenuPopupFrame* popupFrame = do_QueryFrame(aPopup->GetPrimaryFrame());
106921:   if (popupFrame) {
 49217:     // if the event was cancelled, don't hide the popup, and reset its
  4234:     // state back to open. Only popups in chrome shells can prevent a popup
  4234:     // from hiding.
  4234:     if (status == nsEventStatus_eConsumeNoDefault &&
  4234:         !popupFrame->IsInContentShell()) {
  4234:       popupFrame->SetPopupState(ePopupOpenAndVisible);
  4234:     }
  4234:     else {
  3129:       HidePopupCallback(aPopup, popupFrame, aNextPopup, aLastPopup,
  4709:                         aPopupType, aDeselectMenu);
  3129:     }
  3129:   }
  3129: }
  3129: 
 79445: bool
  3340: nsXULPopupManager::IsPopupOpen(nsIContent* aPopup)
  3340: {
  4234:   // a popup is open if it is in the open list. The assertions ensure that the
  4234:   // frame is in the correct state. If the popup is in the hiding or invisible
  4234:   // state, it will still be in the open popup list until it is closed.
 22371:   nsMenuChainItem* item = mPopups;
  3340:   while (item) {
  4234:     if (item->Content() == aPopup) {
  4234:       NS_ASSERTION(item->Frame()->IsOpen() ||
  4234:                    item->Frame()->PopupState() == ePopupHiding ||
  4234:                    item->Frame()->PopupState() == ePopupInvisible,
  5462:                    "popup in open list not actually open");
 80486:       return true;
  4234:     }
  3340:     item = item->GetParent();
  3340:   }
  3340: 
 22371:   item = mNoHidePanels;
  3340:   while (item) {
  4234:     if (item->Content() == aPopup) {
  4234:       NS_ASSERTION(item->Frame()->IsOpen() ||
  4234:                    item->Frame()->PopupState() == ePopupHiding ||
  4234:                    item->Frame()->PopupState() == ePopupInvisible,
  5462:                    "popup in open list not actually open");
 80486:       return true;
  4234:     }
  3340:     item = item->GetParent();
  3340:   }
  3340: 
 80486:   return false;
  3340: }
  3340: 
 79445: bool
 22372: nsXULPopupManager::IsPopupOpenForMenuParent(nsMenuParent* aMenuParent)
  3129: {
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  3129:   while (item) {
  4234:     nsMenuPopupFrame* popup = item->Frame();
  4234:     if (popup && popup->IsOpen()) {
106921:       nsMenuFrame* menuFrame = do_QueryFrame(popup->GetParent());
 49217:       if (menuFrame && menuFrame->GetMenuParent() == aMenuParent) {
 80486:         return true;
  3129:       }
  4234:     }
  3129:     item = item->GetParent();
  3129:   }
  3129: 
 80486:   return false;
  3129: }
  3129: 
  4709: nsIFrame*
  4709: nsXULPopupManager::GetTopPopup(nsPopupType aType)
  4709: {
 49217:   if ((aType == ePopupTypePanel || aType == ePopupTypeTooltip) && mNoHidePanels)
 22371:     return mNoHidePanels->Frame();
  4709: 
  4709:   nsMenuChainItem* item = GetTopVisibleMenu();
  4709:   while (item) {
  6051:     if (item->PopupType() == aType || aType == ePopupTypeAny)
  4709:       return item->Frame();
  4709:     item = item->GetParent();
  4709:   }
  4709: 
106838:   return nullptr;
  4709: }
  4709: 
  3516: nsTArray<nsIFrame *>
 25413: nsXULPopupManager::GetVisiblePopups()
  3516: {
  3516:   nsTArray<nsIFrame *> popups;
  3516: 
 22371:   nsMenuChainItem* item = mPopups;
  3516:   while (item) {
 25413:     if (item->Frame()->PopupState() == ePopupOpenAndVisible)
  3644:       popups.AppendElement(static_cast<nsIFrame*>(item->Frame()));
  3516:     item = item->GetParent();
  3516:   }
  3516: 
 48255:   item = mNoHidePanels;
 48255:   while (item) {
 77050:     // skip panels which are not open and visible as well as draggable popups,
 77050:     // as those don't respond to events.
 77050:     if (item->Frame()->PopupState() == ePopupOpenAndVisible && !item->Frame()->IsDragPopup()) {
 48255:       popups.AppendElement(static_cast<nsIFrame*>(item->Frame()));
 77050:     }
 48255:     item = item->GetParent();
 48255:   }
 48255: 
  3516:   return popups;
  3516: }
  3516: 
 49217: already_AddRefed<nsIDOMNode>
 79445: nsXULPopupManager::GetLastTriggerNode(nsIDocument* aDocument, bool aIsTooltip)
 49217: {
 49217:   if (!aDocument)
106838:     return nullptr;
 49217: 
 49217:   nsCOMPtr<nsIDOMNode> node;
 49217: 
 49217:   // if mOpeningPopup is set, it means that a popupshowing event is being
 49217:   // fired. In this case, just use the cached node, as the popup is not yet in
 49217:   // the list of open popups.
 49217:   if (mOpeningPopup && mOpeningPopup->GetCurrentDoc() == aDocument &&
 49217:       aIsTooltip == (mOpeningPopup->Tag() == nsGkAtoms::tooltip)) {
 80486:     node = do_QueryInterface(nsMenuPopupFrame::GetTriggerContent(GetPopupFrameForContent(mOpeningPopup, false)));
 49217:   }
 49217:   else {
 49217:     nsMenuChainItem* item = aIsTooltip ? mNoHidePanels : mPopups;
 49217:     while (item) {
 49217:       // look for a popup of the same type and document.
 49217:       if ((item->PopupType() == ePopupTypeTooltip) == aIsTooltip &&
 49217:           item->Content()->GetCurrentDoc() == aDocument) {
 52416:         node = do_QueryInterface(nsMenuPopupFrame::GetTriggerContent(item->Frame()));
 52416:         if (node)
 49217:           break;
 49217:       }
 49217:       item = item->GetParent();
 49217:     }
 49217:   }
 49217: 
 49217:   return node.forget();
 49217: }
 49217: 
 79445: bool
  3129: nsXULPopupManager::MayShowPopup(nsMenuPopupFrame* aPopup)
  3129: {
  4234:   // if a popup's IsOpen method returns true, then the popup must always be in
  4234:   // the popup chain scanned in IsPopupOpen.
  4234:   NS_ASSERTION(!aPopup->IsOpen() || IsPopupOpen(aPopup->GetContent()),
  4234:                "popup frame state doesn't match XULPopupManager open state");
  4234: 
  4234:   nsPopupState state = aPopup->PopupState();
  4234: 
  4234:   // if the popup is not in the open popup chain, then it must have a state that
  4234:   // is either closed, in the process of being shown, or invisible.
  4234:   NS_ASSERTION(IsPopupOpen(aPopup->GetContent()) || state == ePopupClosed ||
  4234:                state == ePopupShowing || state == ePopupInvisible,
  4234:                "popup not in XULPopupManager open list is open");
  4234: 
  4234:   // don't show popups unless they are closed or invisible
  4234:   if (state != ePopupClosed && state != ePopupInvisible)
 80486:     return false;
  3129: 
 35447:   // Don't show popups that we already have in our popup chain
 35447:   if (IsPopupOpen(aPopup->GetContent())) {
 35447:     NS_WARNING("Refusing to show duplicate popup");
 80486:     return false;
 35447:   }
 35447: 
  8591:   // if the popup was just rolled up, don't reopen it
 83107:   nsCOMPtr<nsIWidget> widget = aPopup->GetWidget();
  8591:   if (widget && widget->GetLastRollup() == aPopup->GetContent())
 80486:       return false;
  8591: 
  3129:   nsCOMPtr<nsISupports> cont = aPopup->PresContext()->GetContainer();
  3129:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(cont);
 19112:   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(dsti);
 19112:   if (!baseWin)
 80486:     return false;
  3129: 
108991:   int32_t type = -1;
  3129:   if (NS_FAILED(dsti->GetItemType(&type)))
 80486:     return false;
  3129: 
 19112:   // chrome shells can always open popups, but other types of shells can only
 19112:   // open popups when they are focused and visible
  3129:   if (type != nsIDocShellTreeItem::typeChrome) {
 19112:     // only allow popups in active windows
 29018:     nsCOMPtr<nsIDocShellTreeItem> root;
 29018:     dsti->GetRootTreeItem(getter_AddRefs(root));
 29018:     nsCOMPtr<nsIDOMWindow> rootWin = do_GetInterface(root);
 29018: 
 29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:     if (!fm || !rootWin)
 80486:       return false;
  3129: 
 29018:     nsCOMPtr<nsIDOMWindow> activeWindow;
 29018:     fm->GetActiveWindow(getter_AddRefs(activeWindow));
 29018:     if (activeWindow != rootWin)
 80486:       return false;
  3129: 
  3129:     // only allow popups in visible frames
 79445:     bool visible;
  3129:     baseWin->GetVisibility(&visible);
  3129:     if (!visible)
 80486:       return false;
  3129:   }
  3129: 
 19112:   // platforms respond differently when an popup is opened in a minimized
 19112:   // window, so this is always disabled.
 19112:   nsCOMPtr<nsIWidget> mainWidget;
 19112:   baseWin->GetMainWidget(getter_AddRefs(mainWidget));
 19112:   if (mainWidget) {
108991:     int32_t sizeMode;
 19112:     mainWidget->GetSizeMode(&sizeMode);
 19112:     if (sizeMode == nsSizeMode_Minimized)
 80486:       return false;
 19112:   }
 19112: 
  3129:   // cannot open a popup that is a submenu of a menupopup that isn't open.
106921:   nsMenuFrame* menuFrame = do_QueryFrame(aPopup->GetParent());
 49217:   if (menuFrame) {
 22372:     nsMenuParent* parentPopup = menuFrame->GetMenuParent();
  3129:     if (parentPopup && !parentPopup->IsOpen())
 80486:       return false;
  3129:   }
  3129: 
 80486:   return true;
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::PopupDestroyed(nsMenuPopupFrame* aPopup)
  3129: {
  3129:   // when a popup frame is destroyed, just unhook it from the list of popups
  3129:   if (mTimerMenu == aPopup) {
  3129:     if (mCloseTimer) {
  3129:       mCloseTimer->Cancel();
106838:       mCloseTimer = nullptr;
  3129:     }
106838:     mTimerMenu = nullptr;
  3129:   }
  3129: 
 22371:   nsMenuChainItem* item = mNoHidePanels;
  3129:   while (item) {
  3129:     if (item->Frame() == aPopup) {
 22371:       item->Detach(&mNoHidePanels);
  3129:       delete item;
  3129:       break;
  3129:     }
  3129:     item = item->GetParent();
  3129:   }
  3129: 
  8127:   nsTArray<nsMenuPopupFrame *> popupsToHide;
  3129: 
 22371:   item = mPopups;
  3129:   while (item) {
  8127:     nsMenuPopupFrame* frame = item->Frame();
  8127:     if (frame == aPopup) {
  8127:       if (frame->PopupState() != ePopupInvisible) {
  8127:         // Iterate through any child menus and hide them as well, since the
  8127:         // parent is going away. We won't remove them from the list yet, just
  8127:         // hide them, as they will be removed from the list when this function
  8127:         // gets called for that child frame.
  8127:         nsMenuChainItem* child = item->GetChild();
  8127:         while (child) {
  8127:           // if the popup is a child frame of the menu that was destroyed, add
  8127:           // it to the list of popups to hide. Don't bother with the events
  8127:           // since the frames are going away. If the child menu is not a child
  8127:           // frame, for example, a context menu, use HidePopup instead, but call
  8127:           // it asynchronously since we are in the middle of frame destruction.
  8127:           nsMenuPopupFrame* childframe = child->Frame();
  8127:           if (nsLayoutUtils::IsProperAncestorFrame(frame, childframe)) {
  8127:             popupsToHide.AppendElement(childframe);
  8127:           }
  8127:           else {
  8127:             // HidePopup will take care of hiding any of its children, so
  8127:             // break out afterwards
 80486:             HidePopup(child->Content(), false, false, true);
  3129:             break;
  3129:           }
  8127: 
  8127:           child = child->GetChild();
  8127:         }
  8127:       }
  8127: 
 22371:       item->Detach(&mPopups);
  8127:       delete item;
  8127:       break;
  8127:     }
  8127: 
  3129:     item = item->GetParent();
  3129:   }
  3129: 
 80486:   HidePopupsInList(popupsToHide, false);
  3129: }
  3129: 
 79445: bool
  3129: nsXULPopupManager::HasContextMenu(nsMenuPopupFrame* aPopup)
  3129: {
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  3129:   while (item && item->Frame() != aPopup) {
  3129:     if (item->IsContextMenu())
 80486:       return true;
  3129:     item = item->GetParent();
  3129:   }
  3129: 
 80486:   return false;
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::SetCaptureState(nsIContent* aOldPopup)
  3129: {
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  4668:   if (item && aOldPopup == item->Content())
  3129:     return;
  3129: 
  3129:   if (mWidget) {
 82030:     mWidget->CaptureRollupEvents(this, false, false);
106838:     mWidget = nullptr;
  3129:   }
  3129: 
  4668:   if (item) {
  4668:     nsMenuPopupFrame* popup = item->Frame();
 90018:     mWidget = popup->GetWidget();
 90018:     if (mWidget) {
 90018:       mWidget->CaptureRollupEvents(this, true, popup->ConsumeOutsideClicks());
  3129:       popup->AttachedDismissalListener();
  3129:     }
  3129:   }
  3129: 
  3129:   UpdateKeyboardListeners();
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::UpdateKeyboardListeners()
  3129: {
  3129:   nsCOMPtr<nsIDOMEventTarget> newTarget;
 79445:   bool isForMenu = false;
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  4668:   if (item) {
  4668:     if (!item->IgnoreKeys())
  4668:       newTarget = do_QueryInterface(item->Content()->GetDocument());
  8637:     isForMenu = item->PopupType() == ePopupTypeMenu;
  3129:   }
  3129:   else if (mActiveMenuBar) {
  3129:     newTarget = do_QueryInterface(mActiveMenuBar->GetContent()->GetDocument());
 80486:     isForMenu = true;
  3129:   }
  3129: 
  3129:   if (mKeyListener != newTarget) {
  3129:     if (mKeyListener) {
 80486:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keypress"), this, true);
 80486:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keydown"), this, true);
 80486:       mKeyListener->RemoveEventListener(NS_LITERAL_STRING("keyup"), this, true);
106838:       mKeyListener = nullptr;
 80486:       nsContentUtils::NotifyInstalledMenuKeyboardListener(false);
  3129:     }
  3129: 
  3129:     if (newTarget) {
 80486:       newTarget->AddEventListener(NS_LITERAL_STRING("keypress"), this, true);
 80486:       newTarget->AddEventListener(NS_LITERAL_STRING("keydown"), this, true);
 80486:       newTarget->AddEventListener(NS_LITERAL_STRING("keyup"), this, true);
  8637:       nsContentUtils::NotifyInstalledMenuKeyboardListener(isForMenu);
  3129:       mKeyListener = newTarget;
  3129:     }
  3129:   }
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::UpdateMenuItems(nsIContent* aPopup)
  3129: {
  3129:   // Walk all of the menu's children, checking to see if any of them has a
  3129:   // command attribute. If so, then several attributes must potentially be updated.
  3129:  
  3129:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(aPopup->GetDocument()));
 88030:   for (nsCOMPtr<nsIContent> grandChild = aPopup->GetFirstChild();
 88030:        grandChild;
 88030:        grandChild = grandChild->GetNextSibling()) {
  3129:     if (grandChild->NodeInfo()->Equals(nsGkAtoms::menuitem, kNameSpaceID_XUL)) {
  3129:       // See if we have a command attribute.
  3129:       nsAutoString command;
  3129:       grandChild->GetAttr(kNameSpaceID_None, nsGkAtoms::command, command);
  3129:       if (!command.IsEmpty()) {
  3129:         // We do! Look it up in our document
  3129:         nsCOMPtr<nsIDOMElement> commandElt;
  3129:         domDoc->GetElementById(command, getter_AddRefs(commandElt));
  3129:         nsCOMPtr<nsIContent> commandContent(do_QueryInterface(commandElt));
  3129:         if (commandContent) {
  3129:           nsAutoString commandValue;
  3129:           // The menu's disabled state needs to be updated to match the command.
  3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandValue))
 80486:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandValue, true);
  3129:           else
 80486:             grandChild->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, true);
  3129: 
  3129:           // The menu's label, accesskey and checked states need to be updated
  3129:           // to match the command. Note that unlike the disabled state if the
  3129:           // command has *no* value, we assume the menu is supplying its own.
  3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, commandValue))
 80486:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::label, commandValue, true);
  3129: 
  3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandValue))
 80486:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandValue, true);
  3129: 
  3129:           if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandValue))
 80486:             grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandValue, true);
  3129:         }
  3129:       }
  3129:     }
  3129:   }
  3129: }
  3129: 
  3129: // Notify
  3129: //
  3129: // The item selection timer has fired, we might have to readjust the 
  3129: // selected item. There are two cases here that we are trying to deal with:
  3129: //   (1) diagonal movement from a parent menu to a submenu passing briefly over
  3129: //       other items, and
  3129: //   (2) moving out from a submenu to a parent or grandparent menu.
  3129: // In both cases, |mTimerMenu| is the menu item that might have an open submenu and
 22371: // the first item in |mPopups| is the item the mouse is currently over, which could be
 22371: // none of them.
  3129: //
  3129: // case (1):
  3129: //  As the mouse moves from the parent item of a submenu (we'll call 'A') diagonally into the
  3129: //  submenu, it probably passes through one or more sibilings (B). As the mouse passes
  3129: //  through B, it becomes the current menu item and the timer is set and mTimerMenu is 
  3129: //  set to A. Before the timer fires, the mouse leaves the menu containing A and B and
 22371: //  enters the submenus. Now when the timer fires, |mPopups| is null (!= |mTimerMenu|)
  3129: //  so we have to see if anything in A's children is selected (recall that even disabled
  3129: //  items are selected, the style just doesn't show it). If that is the case, we need to
  3129: //  set the selected item back to A.
  3129: //
  3129: // case (2);
  3129: //  Item A has an open submenu, and in it there is an item (B) which also has an open
  3129: //  submenu (so there are 3 menus displayed right now). The mouse then leaves B's child
  3129: //  submenu and selects an item that is a sibling of A, call it C. When the mouse enters C,
 22371: //  the timer is set and |mTimerMenu| is A and |mPopups| is C. As the timer fires,
  3129: //  the mouse is still within C. The correct behavior is to set the current item to C
  3129: //  and close up the chain parented at A.
  3129: //
  3129: //  This brings up the question of is the logic of case (1) enough? The answer is no,
  3129: //  and is discussed in bugzilla bug 29400. Case (1) asks if A's submenu has a selected
  3129: //  child, and if it does, set the selected item to A. Because B has a submenu open, it
  3129: //  is selected and as a result, A is set to be the selected item even though the mouse
  3129: //  rests in C -- very wrong. 
  3129: //
  3129: //  The solution is to use the same idea, but instead of only checking one level, 
  3129: //  drill all the way down to the deepest open submenu and check if it has something 
  3129: //  selected. Since the mouse is in a grandparent, it won't, and we know that we can
  3129: //  safely close up A and all its children.
  3129: //
  3129: // The code below melds the two cases together.
  3129: //
  3129: nsresult
  3129: nsXULPopupManager::Notify(nsITimer* aTimer)
  3129: {
  3129:   if (aTimer == mCloseTimer)
  3129:     KillMenuTimer();
  3129: 
  3129:   return NS_OK;
  3129: }
  3129: 
  3129: void
  3129: nsXULPopupManager::KillMenuTimer()
  3129: {
  3129:   if (mCloseTimer && mTimerMenu) {
  3129:     mCloseTimer->Cancel();
106838:     mCloseTimer = nullptr;
  3129: 
  3129:     if (mTimerMenu->IsOpen())
 80486:       HidePopup(mTimerMenu->GetContent(), false, false, true);
  3129:   }
  3129: 
106838:   mTimerMenu = nullptr;
  3129: }
  3129: 
  3332: void
 22372: nsXULPopupManager::CancelMenuTimer(nsMenuParent* aMenuParent)
  3332: {
  3332:   if (mCloseTimer && mTimerMenu == aMenuParent) {
  3332:     mCloseTimer->Cancel();
106838:     mCloseTimer = nullptr;
106838:     mTimerMenu = nullptr;
  3332:   }
  3332: }
  3332: 
 68419: static nsGUIEvent* DOMKeyEventToGUIEvent(nsIDOMEvent* aEvent)
 68419: {
106838:   nsEvent* evt = aEvent ? aEvent->GetInternalNSEvent() : nullptr;
101616:   return evt && evt->eventStructType == NS_KEY_EVENT ?
106838:          static_cast<nsGUIEvent *>(evt) : nullptr;
 68419: }
 68419: 
 79445: bool
  3779: nsXULPopupManager::HandleShortcutNavigation(nsIDOMKeyEvent* aKeyEvent,
  3779:                                             nsMenuPopupFrame* aFrame)
  3129: {
  4668:   nsMenuChainItem* item = GetTopVisibleMenu();
  4668:   if (!aFrame && item)
  4668:     aFrame = item->Frame();
  3129: 
  3779:   if (aFrame) {
 79445:     bool action;
  3779:     nsMenuFrame* result = aFrame->FindMenuWithShortcut(aKeyEvent, action);
  3129:     if (result) {
 80486:       aFrame->ChangeMenuItem(result, false);
  3225:       if (action) {
 68419:         nsGUIEvent* evt = DOMKeyEventToGUIEvent(aKeyEvent);
 68419:         nsMenuFrame* menuToOpen = result->Enter(evt);
  3225:         if (menuToOpen) {
  3225:           nsCOMPtr<nsIContent> content = menuToOpen->GetContent();
 80486:           ShowMenu(content, true, false);
  3225:         }
  3225:       }
 80486:       return true;
  3129:     }
  3129: 
 80486:     return false;
  3129:   }
  3129: 
  3129:   if (mActiveMenuBar) {
  3129:     nsMenuFrame* result = mActiveMenuBar->FindMenuWithShortcut(aKeyEvent);
  3129:     if (result) {
 80486:       mActiveMenuBar->SetActive(true);
 80486:       result->OpenMenu(true);
 80486:       return true;
  3129:     }
  3129:   }
  3129: 
 80486:   return false;
  3129: }
  3129: 
  3129: 
 79445: bool
108991: nsXULPopupManager::HandleKeyboardNavigation(uint32_t aKeyCode)
  3129: {
  3129:   // navigate up through the open menus, looking for the topmost one
  3129:   // in the same hierarchy
106838:   nsMenuChainItem* item = nullptr;
  4668:   nsMenuChainItem* nextitem = GetTopVisibleMenu();
  3129: 
  3129:   while (nextitem) {
  3129:     item = nextitem;
  3129:     nextitem = item->GetParent();
  3129: 
  3129:     if (nextitem) {
  3129:       // stop if the parent isn't a menu
  3129:       if (!nextitem->IsMenu())
  3129:         break;
  3129: 
  3129:       // check to make sure that the parent is actually the parent menu. It won't
  3129:       // be if the parent is in a different frame hierarchy, for example, for a
  3129:       // context menu opened on another menu.
 22372:       nsMenuParent* expectedParent = static_cast<nsMenuParent *>(nextitem->Frame());
106921:       nsMenuFrame* menuFrame = do_QueryFrame(item->Frame()->GetParent());
 49217:       if (!menuFrame || menuFrame->GetMenuParent() != expectedParent) {
  3129:         break;
  3129:       }
  3129:     }
  3129:   }
  3129: 
  3129:   nsIFrame* itemFrame;
  3129:   if (item)
  3129:     itemFrame = item->Frame();
  3129:   else if (mActiveMenuBar)
  3129:     itemFrame = mActiveMenuBar;
  3129:   else
 80486:     return false;
  3129: 
  3129:   nsNavigationDirection theDirection;
 23190:   NS_ASSERTION(aKeyCode >= NS_VK_END && aKeyCode <= NS_VK_DOWN, "Illegal key code");
 23190:   theDirection = NS_DIRECTION_FROM_KEY_CODE(itemFrame, aKeyCode);
  3129: 
  3129:   // if a popup is open, first check for navigation within the popup
  3129:   if (item && HandleKeyboardNavigationInPopup(item, theDirection))
 80486:     return true;
  3129: 
  3129:   // no popup handled the key, so check the active menubar, if any
  3129:   if (mActiveMenuBar) {
  3129:     nsMenuFrame* currentMenu = mActiveMenuBar->GetCurrentMenuItem();
  3129:   
  3129:     if (NS_DIRECTION_IS_INLINE(theDirection)) {
  3129:       nsMenuFrame* nextItem = (theDirection == eNavigationDirection_End) ?
 80486:                               GetNextMenuItem(mActiveMenuBar, currentMenu, false) : 
 80486:                               GetPreviousMenuItem(mActiveMenuBar, currentMenu, false);
 80486:       mActiveMenuBar->ChangeMenuItem(nextItem, true);
 80486:       return true;
  3129:     }
 12967:     else if (NS_DIRECTION_IS_BLOCK(theDirection)) {
  3129:       // Open the menu and select its first item.
  9315:       if (currentMenu) {
  3129:         nsCOMPtr<nsIContent> content = currentMenu->GetContent();
 80486:         ShowMenu(content, true, false);
  9315:       }
 80486:       return true;
  3129:     }
  3129:   }
  3129: 
 80486:   return false;
  3129: }
  3129: 
 79445: bool
  3129: nsXULPopupManager::HandleKeyboardNavigationInPopup(nsMenuChainItem* item,
  3779:                                                    nsMenuPopupFrame* aFrame,
  3129:                                                    nsNavigationDirection aDir)
  3129: {
  3779:   NS_ASSERTION(aFrame, "aFrame is null");
  3779:   NS_ASSERTION(!item || item->Frame() == aFrame,
  3779:                "aFrame is expected to be equal to item->Frame()");
  3129: 
  3779:   nsMenuFrame* currentMenu = aFrame->GetCurrentMenuItem();
  3779: 
  3779:   aFrame->ClearIncrementalString();
  3129: 
  3129:   // This method only gets called if we're open.
  3129:   if (!currentMenu && NS_DIRECTION_IS_INLINE(aDir)) {
  3129:     // We've been opened, but we haven't had anything selected.
  3129:     // We can handle End, but our parent handles Start.
  3129:     if (aDir == eNavigationDirection_End) {
106838:       nsMenuFrame* nextItem = GetNextMenuItem(aFrame, nullptr, true);
  3129:       if (nextItem) {
 80486:         aFrame->ChangeMenuItem(nextItem, false);
 80486:         return true;
  3129:       }
  3129:     }
 80486:     return false;
  3129:   }
  3129: 
 79445:   bool isContainer = false;
 79445:   bool isOpen = false;
  3129:   if (currentMenu) {
  3129:     isOpen = currentMenu->IsOpen();
  3129:     isContainer = currentMenu->IsMenu();
  3129:     if (isOpen) {
  3129:       // for an open popup, have the child process the event
106838:       nsMenuChainItem* child = item ? item->GetChild() : nullptr;
  3129:       if (child && HandleKeyboardNavigationInPopup(child, aDir))
 80486:         return true;
  3129:     }
  3129:     else if (aDir == eNavigationDirection_End &&
  3129:              isContainer && !currentMenu->IsDisabled()) {
  3129:       // The menu is not yet open. Open it and select the first item.
  3129:       nsCOMPtr<nsIContent> content = currentMenu->GetContent();
 80486:       ShowMenu(content, true, false);
 80486:       return true;
  3129:     }
  3129:   }
  3129: 
  3129:   // For block progression, we can move in either direction
  3129:   if (NS_DIRECTION_IS_BLOCK(aDir) ||
  3129:       NS_DIRECTION_IS_BLOCK_TO_EDGE(aDir)) {
  3129:     nsMenuFrame* nextItem;
  3129: 
  3129:     if (aDir == eNavigationDirection_Before)
 80486:       nextItem = GetPreviousMenuItem(aFrame, currentMenu, true);
  3129:     else if (aDir == eNavigationDirection_After)
 80486:       nextItem = GetNextMenuItem(aFrame, currentMenu, true);
  3129:     else if (aDir == eNavigationDirection_First)
106838:       nextItem = GetNextMenuItem(aFrame, nullptr, true);
  3129:     else
106838:       nextItem = GetPreviousMenuItem(aFrame, nullptr, true);
  3129: 
  3129:     if (nextItem) {
 80486:       aFrame->ChangeMenuItem(nextItem, false);
 80486:       return true;
  3129:     }
  3129:   }
  3129:   else if (currentMenu && isContainer && isOpen) {
  3129:     if (aDir == eNavigationDirection_Start) {
  3129:       // close a submenu when Left is pressed
  3129:       nsMenuPopupFrame* popupFrame = currentMenu->GetPopup();
  3129:       if (popupFrame)
 80486:         HidePopup(popupFrame->GetContent(), false, false, false);
 80486:       return true;
  3129:     }
  3129:   }
  3129: 
 80486:   return false;
  3129: }
  3129: 
  3129: nsMenuFrame*
  3129: nsXULPopupManager::GetNextMenuItem(nsIFrame* aParent,
  3129:                                    nsMenuFrame* aStart,
 79445:                                    bool aIsPopup)
  3129: {
106838:   nsIFrame* immediateParent = nullptr;
  3129:   nsPresContext* presContext = aParent->PresContext();
  3129:   presContext->PresShell()->
106838:     FrameConstructor()->GetInsertionPoint(aParent, nullptr, &immediateParent);
  3129:   if (!immediateParent)
  3129:     immediateParent = aParent;
  3129: 
106838:   nsIFrame* currFrame = nullptr;
  3129:   if (aStart)
  3129:     currFrame = aStart->GetNextSibling();
  3129:   else 
 77154:     currFrame = immediateParent->GetFirstPrincipalChild();
  3129:   
  3129:   while (currFrame) {
  3129:     // See if it's a menu item.
  3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
106921:       return do_QueryFrame(currFrame);
  3129:     }
  3129:     currFrame = currFrame->GetNextSibling();
  3129:   }
  3129: 
 77154:   currFrame = immediateParent->GetFirstPrincipalChild();
  3129: 
  3129:   // Still don't have anything. Try cycling from the beginning.
  3129:   while (currFrame && currFrame != aStart) {
  3129:     // See if it's a menu item.
  3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
106921:       return do_QueryFrame(currFrame);
  3129:     }
  3129: 
  3129:     currFrame = currFrame->GetNextSibling();
  3129:   }
  3129: 
  3129:   // No luck. Just return our start value.
  3129:   return aStart;
  3129: }
  3129: 
  3129: nsMenuFrame*
  3129: nsXULPopupManager::GetPreviousMenuItem(nsIFrame* aParent,
  3129:                                        nsMenuFrame* aStart,
 79445:                                        bool aIsPopup)
  3129: {
106838:   nsIFrame* immediateParent = nullptr;
  3129:   nsPresContext* presContext = aParent->PresContext();
  3129:   presContext->PresShell()->
106838:     FrameConstructor()->GetInsertionPoint(aParent, nullptr, &immediateParent);
  3129:   if (!immediateParent)
  3129:     immediateParent = aParent;
  3129: 
 77154:   const nsFrameList& frames(immediateParent->PrincipalChildList());
  3129: 
106838:   nsIFrame* currFrame = nullptr;
  3129:   if (aStart)
 33388:     currFrame = aStart->GetPrevSibling();
  3129:   else
  3129:     currFrame = frames.LastChild();
  3129: 
  3129:   while (currFrame) {
  3129:     // See if it's a menu item.
  3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
106921:       return do_QueryFrame(currFrame);
  3129:     }
 33388:     currFrame = currFrame->GetPrevSibling();
  3129:   }
  3129: 
  3129:   currFrame = frames.LastChild();
  3129: 
  3129:   // Still don't have anything. Try cycling from the end.
  3129:   while (currFrame && currFrame != aStart) {
  3129:     // See if it's a menu item.
  3129:     if (IsValidMenuItem(presContext, currFrame->GetContent(), aIsPopup)) {
106921:       return do_QueryFrame(currFrame);
  3129:     }
  3129: 
 33388:     currFrame = currFrame->GetPrevSibling();
  3129:   }
  3129: 
  3129:   // No luck. Just return our start value.
  3129:   return aStart;
  3129: }
  3129: 
 79445: bool
  3129: nsXULPopupManager::IsValidMenuItem(nsPresContext* aPresContext,
  3129:                                    nsIContent* aContent,
 79445:                                    bool aOnPopup)
  3129: {
108991:   int32_t ns = aContent->GetNameSpaceID();
  3129:   nsIAtom *tag = aContent->Tag();
  8127:   if (ns == kNameSpaceID_XUL) {
  8127:     if (tag != nsGkAtoms::menu && tag != nsGkAtoms::menuitem)
 80486:       return false;
  8127:   }
  8127:   else if (ns != kNameSpaceID_XHTML || !aOnPopup || tag != nsGkAtoms::option) {
 80486:     return false;
  8127:   }
  3129: 
 79445:   bool skipNavigatingDisabledMenuItem = true;
  3129:   if (aOnPopup) {
 78129:     skipNavigatingDisabledMenuItem =
 78129:       LookAndFeel::GetInt(LookAndFeel::eIntID_SkipNavigatingDisabledMenuItem,
 78129:                           0) != 0;
  3129:   }
  3129: 
  3129:   return !(skipNavigatingDisabledMenuItem &&
  3129:            aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
  3129:                                  nsGkAtoms::_true, eCaseMatters));
  3129: }
  3129: 
  3129: nsresult
 72701: nsXULPopupManager::HandleEvent(nsIDOMEvent* aEvent)
 72701: {
 72703:   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
 72701:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_UNEXPECTED);
 72701: 
 72701:   nsAutoString eventType;
 72701:   keyEvent->GetType(eventType);
 72701:   if (eventType.EqualsLiteral("keyup")) {
 72701:     return KeyUp(keyEvent);
 72701:   }
 72701:   if (eventType.EqualsLiteral("keydown")) {
 72701:     return KeyDown(keyEvent);
 72701:   }
 72701:   if (eventType.EqualsLiteral("keypress")) {
 72701:     return KeyPress(keyEvent);
 72701:   }
 72701: 
 72701:   NS_ABORT();
 72701: 
 72701:   return NS_OK;
 72701: }
 72701: 
 72701: nsresult
 72701: nsXULPopupManager::KeyUp(nsIDOMKeyEvent* aKeyEvent)
  3129: {
  8260:   // don't do anything if a menu isn't open or a menubar isn't active
  8260:   if (!mActiveMenuBar) {
  7871:     nsMenuChainItem* item = GetTopVisibleMenu();
  8260:     if (!item || item->PopupType() != ePopupTypeMenu)
  8260:       return NS_OK;
  8260:   }
  8260: 
  3129:   aKeyEvent->StopPropagation();
  3129:   aKeyEvent->PreventDefault();
  3129: 
  3129:   return NS_OK; // I am consuming event
  3129: }
  3129: 
  3129: nsresult
 72701: nsXULPopupManager::KeyDown(nsIDOMKeyEvent* aKeyEvent)
  3129: {
 41073:   nsMenuChainItem* item = GetTopVisibleMenu();
 41073:   if (item && item->Frame()->IsMenuLocked())
 41073:     return NS_OK;
 41073: 
  8260:   // don't do anything if a menu isn't open or a menubar isn't active
 41073:   if (!mActiveMenuBar && (!item || item->PopupType() != ePopupTypeMenu))
  5218:     return NS_OK;
  5218: 
108991:   int32_t menuAccessKey = -1;
  3129: 
  3129:   // If the key just pressed is the access key (usually Alt),
  3129:   // dismiss and unfocus the menu.
  3129: 
  3129:   nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
  3129:   if (menuAccessKey) {
108991:     uint32_t theChar;
 72701:     aKeyEvent->GetKeyCode(&theChar);
  3129: 
108991:     if (theChar == (uint32_t)menuAccessKey) {
 79445:       bool ctrl = false;
  3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_CONTROL)
 72703:         aKeyEvent->GetCtrlKey(&ctrl);
 79445:       bool alt=false;
  3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_ALT)
 72703:         aKeyEvent->GetAltKey(&alt);
 79445:       bool shift=false;
  3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_SHIFT)
 72703:         aKeyEvent->GetShiftKey(&shift);
 79445:       bool meta=false;
  3129:       if (menuAccessKey != nsIDOMKeyEvent::DOM_VK_META)
 72703:         aKeyEvent->GetMetaKey(&meta);
  3129:       if (!(ctrl || alt || shift || meta)) {
  3129:         // The access key just went down and no other
  3129:         // modifiers are already down.
 22371:         if (mPopups)
 82030:           Rollup(0);
  8260:         else if (mActiveMenuBar)
  8260:           mActiveMenuBar->MenuClosed();
  3129:       }
  3129:     }
  3129:   }
  3129: 
  3129:   // Since a menu was open, eat the event to keep other event
  3129:   // listeners from becoming confused.
  3129:   aKeyEvent->StopPropagation();
  3129:   aKeyEvent->PreventDefault();
  3129:   return NS_OK; // I am consuming event
  3129: }
  3129: 
  3129: nsresult
 72701: nsXULPopupManager::KeyPress(nsIDOMKeyEvent* aKeyEvent)
  3129: {
  3129:   // Don't check prevent default flag -- menus always get first shot at key events.
  3129:   // When a menu is open, the prevent default flag on a keypress is always set, so
  3129:   // that no one else uses the key event.
  3129: 
 41073:   nsMenuChainItem* item = GetTopVisibleMenu();
 41073:   if (item && item->Frame()->IsMenuLocked())
 41073:     return NS_OK;
 41073: 
  3129:   //handlers shouldn't be triggered by non-trusted events.
 79445:   bool trustedEvent = false;
107461:   if (aKeyEvent) {
107461:     aKeyEvent->GetIsTrusted(&trustedEvent);
  3129:   }
  3129: 
  3129:   if (!trustedEvent)
  3129:     return NS_OK;
  3129: 
  3129:   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aKeyEvent);
 72701:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_UNEXPECTED);
108991:   uint32_t theChar;
  3129:   keyEvent->GetKeyCode(&theChar);
  3129: 
  7871:   // Escape should close panels, but the other keys should have no effect.
  7871:   if (item && item->PopupType() != ePopupTypeMenu) {
  7871:     if (theChar == NS_VK_ESCAPE) {
 80486:       HidePopup(item->Content(), false, false, false);
  7871:       aKeyEvent->StopPropagation();
  7871:       aKeyEvent->PreventDefault();
  7871:     }
  7871:     return NS_OK;
  7871:   }
  7871: 
  8260:   // if a menu is open or a menubar is active, it consumes the key event
 79445:   bool consume = (mPopups || mActiveMenuBar);
  8260: 
  3129:   if (theChar == NS_VK_LEFT ||
  3129:       theChar == NS_VK_RIGHT ||
  3129:       theChar == NS_VK_UP ||
  3129:       theChar == NS_VK_DOWN ||
  3129:       theChar == NS_VK_HOME ||
  3129:       theChar == NS_VK_END) {
  3129:     HandleKeyboardNavigation(theChar);
  3129:   }
  3129:   else if (theChar == NS_VK_ESCAPE) {
  4669:     // Pressing Escape hides one level of menus only. If no menu is open,
  4669:     // check if a menubar is active and inform it that a menu closed. Even
  4669:     // though in this latter case, a menu didn't actually close, the effect
  4669:     // ends up being the same. Similar for the tab key below.
  4668:     if (item)
 80486:       HidePopup(item->Content(), false, false, false);
  4669:     else if (mActiveMenuBar)
  4669:       mActiveMenuBar->MenuClosed();
  3129:   }
  8260:   else if (theChar == NS_VK_TAB
  8260: #ifndef XP_MACOSX
  8260:            || theChar == NS_VK_F10
  8260: #endif
  8260:   ) {
  8260:     // close popups or deactivate menubar when Tab or F10 are pressed
  8260:     if (item)
 82030:       Rollup(0);
  4669:     else if (mActiveMenuBar)
  4669:       mActiveMenuBar->MenuClosed();
  3129:   }
  3129:   else if (theChar == NS_VK_ENTER ||
  3129:            theChar == NS_VK_RETURN) {
  3129:     // If there is a popup open, check if the current item needs to be opened.
  3129:     // Otherwise, tell the active menubar, if any, to activate the menu. The
  3129:     // Enter method will return a menu if one needs to be opened as a result.
106838:     nsMenuFrame* menuToOpen = nullptr;
  4668:     nsMenuChainItem* item = GetTopVisibleMenu();
 68419:     nsGUIEvent* evt = DOMKeyEventToGUIEvent(aKeyEvent);
  4668:     if (item)
 68419:       menuToOpen = item->Frame()->Enter(evt);
  3129:     else if (mActiveMenuBar)
 68419:       menuToOpen = mActiveMenuBar->Enter(evt);
  3129:     if (menuToOpen) {
  3129:       nsCOMPtr<nsIContent> content = menuToOpen->GetContent();
 80486:       ShowMenu(content, true, false);
  3129:     }
  3129:   }
  3129:   else {
106838:     HandleShortcutNavigation(keyEvent, nullptr);
  3129:   }
  3129: 
  8260:   if (consume) {
  3129:     aKeyEvent->StopPropagation();
  3129:     aKeyEvent->PreventDefault();
  5218:   }
  5218: 
  3129:   return NS_OK; // I am consuming event
  3129: }
  3129: 
  3129: NS_IMETHODIMP
  3129: nsXULPopupShowingEvent::Run()
  3129: {
  3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 52061:   if (pm) {
 52061:     pm->FirePopupShowingEvent(mPopup, mIsContextMenu, mSelectFirstItem);
  3129:   }
  3129: 
  3129:   return NS_OK;
  3129: }
  3129: 
  3129: NS_IMETHODIMP
  3129: nsXULPopupHidingEvent::Run()
  3129: {
  3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 52061: 
 52061:   nsIDocument *document = mPopup->GetCurrentDoc();
 52061:   if (pm && document) {
 52061:     nsIPresShell* presShell = document->GetShell();
 52061:     if (presShell) {
 52061:       nsPresContext* context = presShell->GetPresContext();
 52061:       if (context) {
  3129:         pm->FirePopupHidingEvent(mPopup, mNextPopup, mLastPopup,
  4709:                                  context, mPopupType, mDeselectMenu);
  3129:       }
 52061:     }
 52061:   }
  3129: 
  3129:   return NS_OK;
  3129: }
  3129: 
  3129: NS_IMETHODIMP
  3129: nsXULMenuCommandEvent::Run()
  3129: {
  3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
  3129:   if (!pm)
  3129:     return NS_OK;
  3129: 
  3129:   // The order of the nsIViewManager and nsIPresShell COM pointers is
  3129:   // important below.  We want the pres shell to get released before the
  3129:   // associated view manager on exit from this function.
  3129:   // See bug 54233.
  3129:   // XXXndeakin is this still needed?
  5227: 
  5227:   nsCOMPtr<nsIContent> popup;
106921:   nsMenuFrame* menuFrame = do_QueryFrame(mMenu->GetPrimaryFrame());
 41073:   nsWeakFrame weakFrame(menuFrame);
 41073:   if (menuFrame && mFlipChecked) {
 41073:     if (menuFrame->IsChecked()) {
 80486:       mMenu->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked, true);
 41073:     } else {
 41073:       mMenu->SetAttr(kNameSpaceID_None, nsGkAtoms::checked,
 80486:                      NS_LITERAL_STRING("true"), true);
 41073:     }
 41073:   }
 41073: 
 41073:   if (menuFrame && weakFrame.IsAlive()) {
  5227:     // Find the popup that the menu is inside. Below, this popup will
  5227:     // need to be hidden.
106921:     nsIFrame* frame = menuFrame->GetParent();
106921:     while (frame) {
106921:       nsMenuPopupFrame* popupFrame = do_QueryFrame(frame);
106921:       if (popupFrame) {
  8591:         popup = popupFrame->GetContent();
  7205:         break;
  7205:       }
106921:       frame = frame->GetParent();
  5227:     }
  5227: 
  3129:     nsPresContext* presContext = menuFrame->PresContext();
  3129:     nsCOMPtr<nsIPresShell> shell = presContext->PresShell();
 26050:     nsCOMPtr<nsIViewManager> kungFuDeathGrip = shell->GetViewManager();
  3129: 
  3129:     // Deselect ourselves.
  5462:     if (mCloseMenuMode != CloseMenuMode_None)
 80486:       menuFrame->SelectMenu(false);
  3129: 
106838:     nsAutoHandlingUserInputStatePusher userInpStatePusher(mUserInput, nullptr,
 56988:                                                           shell->GetDocument());
106838:     nsContentUtils::DispatchXULCommand(mMenu, mIsTrusted, nullptr, shell,
 29844:                                        mControl, mAlt, mShift, mMeta);
  3129:   }
  3129: 
  5462:   if (popup && mCloseMenuMode != CloseMenuMode_None)
 80486:     pm->HidePopup(popup, mCloseMenuMode == CloseMenuMode_Auto, true, false);
  3129: 
  3129:   return NS_OK;
  3129: }
