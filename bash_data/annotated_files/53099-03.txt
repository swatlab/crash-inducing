    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1 *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsiter_h___
    1: #define jsiter_h___
 3164: 
    1: /*
    1:  * JavaScript iterators.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
40327: #include "jsversion.h"
    1: 
15613: /*
15613:  * NB: these flag bits are encoded into the bytecode stream in the immediate
15613:  * operand of JSOP_ITER, so don't change them without advancing jsxdrapi.h's
15613:  * JSXDR_BYTECODE_VERSION.
15613:  */
    1: #define JSITER_ENUMERATE  0x1   /* for-in compatible hidden default iterator */
    1: #define JSITER_FOREACH    0x2   /* return [key, value] pair rather than key */
    1: #define JSITER_KEYVALUE   0x4   /* destructuring for-in wants [key, value] */
42641: #define JSITER_OWNONLY    0x8   /* iterate over obj's own properties only */
42733: #define JSITER_HIDDEN     0x10  /* also enumerate non-enumerable properties */
42641: 
42641: struct NativeIterator {
43281:     JSObject  *obj;
52924:     void      *props_array;
52924:     void      *props_cursor;
52924:     void      *props_end;
42641:     uint32    *shapes_array;
42641:     uint32    shapes_length;
42641:     uint32    shapes_key;
42641:     uintN     flags;
42641:     JSObject  *next;
42641: 
53059:     bool isKeyIter() const { return (flags & JSITER_FOREACH) == 0; }
53059: 
53059:     inline jsid *beginKey() const {
53059:         JS_ASSERT(isKeyIter());
53059:         return (jsid *)props_array;
47516:     }
47516: 
53059:     inline jsid *endKey() const {
53059:         JS_ASSERT(isKeyIter());
53059:         return (jsid *)props_end;
53059:     }
53059: 
53059:     size_t numKeys() const {
53059:         return endKey() - beginKey();
53059:     }
53059: 
53059:     jsid *currentKey() const {
53059:         JS_ASSERT(isKeyIter());
53059:         return reinterpret_cast<jsid *>(props_cursor);
53059:     }
53059: 
53059:     void incKeyCursor() {
53059:         JS_ASSERT(isKeyIter());
52924:         props_cursor = reinterpret_cast<jsid *>(props_cursor) + 1;
47516:     }
47516: 
53059:     inline js::Value *beginValue() const {
53059:         JS_ASSERT(!isKeyIter());
53059:         return (js::Value *)props_array;
53059:     }
53059: 
53059:     inline js::Value *endValue() const {
53059:         JS_ASSERT(!isKeyIter());
53059:         return (js::Value *)props_end;
53059:     }
53059: 
53059:     size_t numValues() const {
53059:         return endValue() - beginValue();
53059:     }
53059: 
53059:     js::Value *currentValue() const {
53059:         JS_ASSERT(!isKeyIter());
53059:         return reinterpret_cast<js::Value *>(props_cursor);
52924:     }
52924: 
52924:     void incValueCursor() {
53059:         JS_ASSERT(!isKeyIter());
52924:         props_cursor = reinterpret_cast<js::Value *>(props_cursor) + 1;
52924:     }
52924: 
52924:     static NativeIterator *allocateKeyIterator(JSContext *cx, uint32 slength,
53059:                                                const js::AutoIdVector &props);
52924:     static NativeIterator *allocateValueIterator(JSContext *cx, uint32 slength,
53059:                                                  const js::AutoValueVector &props);
53059:     void init(JSObject *obj, uintN flags, const uint32 *sarray, uint32 slength, uint32 key);
43281: 
42641:     void mark(JSTracer *trc);
42641: };
    1: 
42641: bool
53059: VectorToIdArray(JSContext *cx, js::AutoIdVector &props, JSIdArray **idap);
47460: 
47460: bool
53059: GetPropertyNames(JSContext *cx, JSObject *obj, uintN flags, js::AutoIdVector &props);
40829: 
42733: bool
52795: GetIterator(JSContext *cx, JSObject *obj, uintN flags, js::Value *vp);
42733: 
42733: bool
53059: VectorToKeyIterator(JSContext *cx, JSObject *obj, uintN flags, js::AutoIdVector &props, js::Value *vp);
53059: 
53059: bool
53059: VectorToValueIterator(JSContext *cx, JSObject *obj, uintN flags, js::AutoValueVector &props, js::Value *vp);
53059: 
53059: /*
53059:  * Creates either a key or value iterator, depending on flags. For a value
53059:  * iterator, performs value-lookup to convert the given list of jsids.
53059:  */
53059: bool
53059: EnumeratedIdVectorToIterator(JSContext *cx, JSObject *obj, uintN flags, js::AutoIdVector &props, js::Value *vp);
42733: 
40829: /*
    1:  * Convert the value stored in *vp to its iteration object. The flags should
    1:  * contain JSITER_ENUMERATE if js_ValueToIterator is called when enumerating
    1:  * for-in semantics are required, and when the caller can guarantee that the
    1:  * iterator will never be exposed to scripts.
    1:  */
 9695: extern JS_FRIEND_API(JSBool)
52522: js_ValueToIterator(JSContext *cx, uintN flags, js::Value *vp);
    1: 
42641: extern JS_FRIEND_API(JSBool)
53099: js_CloseIterator(JSContext *cx, JSObject *iterObj);
 3025: 
43281: bool
43281: js_SuppressDeletedProperty(JSContext *cx, JSObject *obj, jsid id);
43281: 
    1: /*
42641:  * IteratorMore() indicates whether another value is available. It might
42641:  * internally call iterobj.next() and then cache the value until its
42641:  * picked up by IteratorNext(). The value is cached in the current context.
    1:  */
42641: extern JSBool
52523: js_IteratorMore(JSContext *cx, JSObject *iterobj, js::Value *rval);
42641: 
42641: extern JSBool
52523: js_IteratorNext(JSContext *cx, JSObject *iterobj, js::Value *rval);
    1: 
 6464: extern JSBool
 6464: js_ThrowStopIteration(JSContext *cx);
 6464: 
    1: #if JS_HAS_GENERATORS
    1: 
    1: /*
    1:  * Generator state codes.
    1:  */
    1: typedef enum JSGeneratorState {
    1:     JSGEN_NEWBORN,  /* not yet started */
    1:     JSGEN_OPEN,     /* started by a .next() or .send(undefined) call */
    1:     JSGEN_RUNNING,  /* currently executing via .next(), etc., call */
    1:     JSGEN_CLOSING,  /* close method is doing asynchronous return */
    1:     JSGEN_CLOSED    /* closed, cannot be started or closed again */
    1: } JSGeneratorState;
    1: 
    1: struct JSGenerator {
 3526:     JSObject            *obj;
    1:     JSGeneratorState    state;
13168:     JSFrameRegs         savedRegs;
42714:     uintN               vplen;
42714:     JSStackFrame        *liveFrame;
43281:     JSObject            *enumerators;
52527:     js::Value           floatingStack[1];
42714: 
42714:     JSStackFrame *getFloatingFrame() {
42714:         return reinterpret_cast<JSStackFrame *>(floatingStack + vplen);
42714:     }
42714: 
42714:     JSStackFrame *getLiveFrame() {
42714:         JS_ASSERT((state == JSGEN_RUNNING || state == JSGEN_CLOSING) ==
42714:                   (liveFrame != getFloatingFrame()));
42714:         return liveFrame;
42714:     }
42709: };
42708: 
    1: extern JSObject *
37777: js_NewGenerator(JSContext *cx);
    1: 
42714: /*
42714:  * Generator stack frames do not have stable pointers since they get copied to
42714:  * and from the generator object and the stack (see SendToGenerator). This is a
42714:  * problem for Block and With objects, which need to store a pointer to the
42714:  * enclosing stack frame. The solution is for Block and With objects to store
42714:  * a pointer to the "floating" stack frame stored in the generator object,
42714:  * since it is stable, and maintain, in the generator object, a pointer to the
42714:  * "live" stack frame (either a copy on the stack or the floating frame). Thus,
42714:  * Block and With objects must "normalize" to and from the floating/live frames
42714:  * in the case of generators using the following functions.
42714:  */
42714: inline JSStackFrame *
42714: js_FloatingFrameIfGenerator(JSContext *cx, JSStackFrame *fp)
42714: {
42714:     JS_ASSERT(cx->stack().contains(fp));
42714:     if (JS_UNLIKELY(fp->isGenerator()))
42714:         return cx->generatorFor(fp)->getFloatingFrame();
42714:     return fp;
42714: }
42714: 
42714: /* Given a floating frame, given the JSGenerator containing it. */
42714: extern JSGenerator *
42714: js_FloatingFrameToGenerator(JSStackFrame *fp);
42714: 
42714: inline JSStackFrame *
42714: js_LiveFrameIfGenerator(JSStackFrame *fp)
42714: {
42714:     if (fp->flags & JSFRAME_GENERATOR)
42714:         return js_FloatingFrameToGenerator(fp)->getLiveFrame();
42714:     return fp;
42714: }
42714: 
    1: #endif
    1: 
52524: extern js::ExtendedClass js_GeneratorClass;
52524: extern js::ExtendedClass js_IteratorClass;
52524: extern js::Class         js_StopIterationClass;
    1: 
21685: static inline bool
52522: js_ValueIsStopIteration(const js::Value &v)
21685: {
53076:     return v.isObject() && v.toObject().getClass() == &js_StopIterationClass;
21685: }
21685: 
    1: extern JSObject *
    1: js_InitIteratorClasses(JSContext *cx, JSObject *obj);
    1: 
    1: #endif /* jsiter_h___ */
