 314: /* -*- Mode: c; c-basic-offset: 4; indent-tabs-mode: t; tab-width: 8; -*- */
   1: /* cairo - a vector graphics library with display and print output
   1:  *
 314:  * Copyright © 2006, 2007 Mozilla Corporation
   1:  *
   1:  * This library is free software; you can redistribute it and/or
   1:  * modify it either under the terms of the GNU Lesser General Public
   1:  * License version 2.1 as published by the Free Software Foundation
   1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
   1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
   1:  * notice, a recipient may use your version of this file under either
   1:  * the MPL or the LGPL.
   1:  *
   1:  * You should have received a copy of the LGPL along with this library
   1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
   1:  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
   1:  * You should have received a copy of the MPL along with this library
   1:  * in the file COPYING-MPL-1.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License
   1:  * Version 1.1 (the "License"); you may not use this file except in
   1:  * compliance with the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
   1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
   1:  * the specific language governing rights and limitations.
   1:  *
   1:  * The Original Code is the cairo graphics library.
   1:  *
 314:  * The Initial Developer of the Original Code is Mozilla Corporation.
   1:  *
   1:  * Contributor(s):
 314:  *	Vladimir Vukicevic <vladimir@mozilla.com>
   1:  */
   1: 
   1: #include "cairoint.h"
 314: 
   1: #include "cairo-quartz-private.h"
   1: 
4133: #include <Carbon/Carbon.h>
7123: #include <limits.h>
4133: 
 314: #undef QUARTZ_DEBUG
 314: 
 314: #ifdef QUARTZ_DEBUG
 314: #define ND(_x)	fprintf _x
 314: #else
 314: #define ND(_x)	do {} while(0)
 314: #endif
 314: 
 314: /* This method is private, but it exists.  Its params are are exposed
 314:  * as args to the NS* method, but not as CG.
 314:  */
 314: enum PrivateCGCompositeMode {
 314:     kPrivateCGCompositeClear		= 0,
 314:     kPrivateCGCompositeCopy		= 1,
 314:     kPrivateCGCompositeSourceOver	= 2,
 314:     kPrivateCGCompositeSourceIn		= 3,
 314:     kPrivateCGCompositeSourceOut	= 4,
 314:     kPrivateCGCompositeSourceAtop	= 5,
 314:     kPrivateCGCompositeDestinationOver	= 6,
 314:     kPrivateCGCompositeDestinationIn	= 7,
 314:     kPrivateCGCompositeDestinationOut	= 8,
 314:     kPrivateCGCompositeDestinationAtop	= 9,
 314:     kPrivateCGCompositeXOR		= 10,
 314:     kPrivateCGCompositePlusDarker	= 11, // (max (0, (1-d) + (1-s)))
 314:     kPrivateCGCompositePlusLighter	= 12, // (min (1, s + d))
 314: };
 314: typedef enum PrivateCGCompositeMode PrivateCGCompositeMode;
 314: CG_EXTERN void CGContextSetCompositeOperation (CGContextRef, PrivateCGCompositeMode);
 314: CG_EXTERN void CGContextResetCTM (CGContextRef);
 314: CG_EXTERN void CGContextSetCTM (CGContextRef, CGAffineTransform);
 314: CG_EXTERN void CGContextResetClip (CGContextRef);
 314: CG_EXTERN CGSize CGContextGetPatternPhase (CGContextRef);
 314: 
 314: /* We need to work with the 10.3 SDK as well (and 10.3 machines; luckily, 10.3.9
 314:  * has all the stuff we care about, just some of it isn't exported in the SDK.
 314:  */ 
 314: #ifndef kCGBitmapByteOrder32Host
 314: #define USE_10_3_WORKAROUNDS
 314: #define kCGBitmapAlphaInfoMask 0x1F
 314: #define kCGBitmapByteOrderMask 0x7000
 314: #define kCGBitmapByteOrder32Host 0
 314: 
 314: typedef uint32_t CGBitmapInfo;
 314: 
 314: /* public in 10.4, present in 10.3.9 */
 314: CG_EXTERN void CGContextReplacePathWithStrokedPath (CGContextRef);
 314: CG_EXTERN CGImageRef CGBitmapContextCreateImage (CGContextRef);
 314: #endif
 314: 
 314: 
 314: /*
 314:  * Utility functions
 314:  */
 314: 
 314: static void quartz_surface_to_png (cairo_quartz_surface_t *nq, char *dest);
 314: static void quartz_image_to_png (CGImageRef, char *dest);
 314: 
7123: /* CoreGraphics limitation with flipped CTM surfaces: height must be less than signed 16-bit max */
7123: 
7123: #define CG_MAX_HEIGHT   SHRT_MAX
7123: #define CG_MAX_WIDTH    USHRT_MAX
7123: 
7123: /* is the desired size of the surface within bounds? */
7123: static cairo_bool_t verify_surface_size(int width, int height)
7123: {
7123:     /* hmmm, allow width, height == 0 ? */
7123:     if (width < 0 || height < 0) {
7123: 	return FALSE;
7123:     }
7123: 
7123:     if (width > CG_MAX_WIDTH || height > CG_MAX_HEIGHT) {
7123: 	return FALSE;
7123:     }
7123: 
7123:     return TRUE;
7123: }
7123: 
 314: /*
 314:  * Cairo path -> Quartz path conversion helpers
 314:  */
 314: 
4133: typedef struct _quartz_stroke {
4133:     CGContextRef cgContext;
4133:     cairo_matrix_t *ctm_inverse;
4133: } quartz_stroke_t;
 314: 
 314: /* cairo path -> execute in context */
 314: static cairo_status_t
 314: _cairo_path_to_quartz_context_move_to (void *closure, cairo_point_t *point)
 314: {
 314:     //ND((stderr, "moveto: %f %f\n", _cairo_fixed_to_double(point->x), _cairo_fixed_to_double(point->y)));
4133:     quartz_stroke_t *stroke = (quartz_stroke_t *)closure;
4133:     double x = _cairo_fixed_to_double (point->x);
4133:     double y = _cairo_fixed_to_double (point->y);
4133: 
4133:     if (stroke->ctm_inverse)
4133: 	cairo_matrix_transform_point (stroke->ctm_inverse, &x, &y);
4133: 
4133:     CGContextMoveToPoint (stroke->cgContext, x, y);
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: static cairo_status_t
 314: _cairo_path_to_quartz_context_line_to (void *closure, cairo_point_t *point)
 314: {
 314:     //ND((stderr, "lineto: %f %f\n",  _cairo_fixed_to_double(point->x), _cairo_fixed_to_double(point->y)));
4133:     quartz_stroke_t *stroke = (quartz_stroke_t *)closure;
4133:     double x = _cairo_fixed_to_double (point->x);
4133:     double y = _cairo_fixed_to_double (point->y);
4133:     
4133:     if (stroke->ctm_inverse)
4133: 	cairo_matrix_transform_point (stroke->ctm_inverse, &x, &y);
4133: 
4133:     if (CGContextIsPathEmpty (stroke->cgContext))
4133: 	CGContextMoveToPoint (stroke->cgContext, x, y);
 314:     else
4133: 	CGContextAddLineToPoint (stroke->cgContext, x, y);
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: static cairo_status_t
 314: _cairo_path_to_quartz_context_curve_to (void *closure, cairo_point_t *p0, cairo_point_t *p1, cairo_point_t *p2)
 314: {
 314:     //ND( (stderr, "curveto: %f,%f %f,%f %f,%f\n",
 314:     //		   _cairo_fixed_to_double(p0->x), _cairo_fixed_to_double(p0->y),
 314:     //		   _cairo_fixed_to_double(p1->x), _cairo_fixed_to_double(p1->y),
 314:     //		   _cairo_fixed_to_double(p2->x), _cairo_fixed_to_double(p2->y)));
4133:     quartz_stroke_t *stroke = (quartz_stroke_t *)closure;
4133:     double x0 = _cairo_fixed_to_double (p0->x);
4133:     double y0 = _cairo_fixed_to_double (p0->y);
4133:     double x1 = _cairo_fixed_to_double (p1->x);
4133:     double y1 = _cairo_fixed_to_double (p1->y);
4133:     double x2 = _cairo_fixed_to_double (p2->x);
4133:     double y2 = _cairo_fixed_to_double (p2->y);
 314: 
4133:     if (stroke->ctm_inverse) {
4133: 	cairo_matrix_transform_point (stroke->ctm_inverse, &x0, &y0);
4133: 	cairo_matrix_transform_point (stroke->ctm_inverse, &x1, &y1);
4133: 	cairo_matrix_transform_point (stroke->ctm_inverse, &x2, &y2);
4133:     }
4133: 
4133:     CGContextAddCurveToPoint (stroke->cgContext,
4133: 			      x0, y0, x1, y1, x2, y2);
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: static cairo_status_t
 314: _cairo_path_to_quartz_context_close_path (void *closure)
 314: {
 314:     //ND((stderr, "closepath\n"));
4133:     quartz_stroke_t *stroke = (quartz_stroke_t *)closure;
4133:     CGContextClosePath (stroke->cgContext);
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: static cairo_status_t
 314: _cairo_quartz_cairo_path_to_quartz_context (cairo_path_fixed_t *path,
4133: 					    quartz_stroke_t *stroke)
 314: {
 314:     return _cairo_path_fixed_interpret (path,
 314: 					CAIRO_DIRECTION_FORWARD,
 314: 					_cairo_path_to_quartz_context_move_to,
 314: 					_cairo_path_to_quartz_context_line_to,
 314: 					_cairo_path_to_quartz_context_curve_to,
 314: 					_cairo_path_to_quartz_context_close_path,
4133: 					stroke);
 314: }
 314: 
 314: /*
 314:  * Misc helpers/callbacks
 314:  */
 314: 
 314: static PrivateCGCompositeMode
 314: _cairo_quartz_cairo_operator_to_quartz (cairo_operator_t op)
 314: {
 314:     switch (op) {
 314: 	case CAIRO_OPERATOR_CLEAR:
 314: 	    return kPrivateCGCompositeClear;
 314: 	case CAIRO_OPERATOR_SOURCE:
 314: 	    return kPrivateCGCompositeCopy;
 314: 	case CAIRO_OPERATOR_OVER:
 314: 	    return kPrivateCGCompositeSourceOver;
 314: 	case CAIRO_OPERATOR_IN:
 314: 	    /* XXX This doesn't match image output */
 314: 	    return kPrivateCGCompositeSourceIn;
 314: 	case CAIRO_OPERATOR_OUT:
 314: 	    /* XXX This doesn't match image output */
 314: 	    return kPrivateCGCompositeSourceOut;
 314: 	case CAIRO_OPERATOR_ATOP:
 314: 	    return kPrivateCGCompositeSourceAtop;
 314: 
 314: 	case CAIRO_OPERATOR_DEST:
 314: 	    /* XXX this is handled specially (noop)! */
 314: 	    return kPrivateCGCompositeCopy;
 314: 	case CAIRO_OPERATOR_DEST_OVER:
 314: 	    return kPrivateCGCompositeDestinationOver;
 314: 	case CAIRO_OPERATOR_DEST_IN:
 314: 	    /* XXX This doesn't match image output */
 314: 	    return kPrivateCGCompositeDestinationIn;
 314: 	case CAIRO_OPERATOR_DEST_OUT:
 314: 	    return kPrivateCGCompositeDestinationOut;
 314: 	case CAIRO_OPERATOR_DEST_ATOP:
 314: 	    /* XXX This doesn't match image output */
 314: 	    return kPrivateCGCompositeDestinationAtop;
 314: 
 314: 	case CAIRO_OPERATOR_XOR:
 314: 	    return kPrivateCGCompositeXOR; /* This will generate strange results */
 314: 	case CAIRO_OPERATOR_ADD:
 314: 	    return kPrivateCGCompositePlusLighter;
 314: 	case CAIRO_OPERATOR_SATURATE:
 314: 	    /* XXX This doesn't match image output for SATURATE; there's no equivalent */
 314: 	    return kPrivateCGCompositePlusDarker;  /* ??? */
 314:     }
 314: 
 314: 
 314:     return kPrivateCGCompositeCopy;
 314: }
 314: 
 314: static CGLineCap
 314: _cairo_quartz_cairo_line_cap_to_quartz (cairo_line_cap_t ccap)
 314: {
 314:     switch (ccap) {
 314: 	case CAIRO_LINE_CAP_BUTT: return kCGLineCapButt; break;
 314: 	case CAIRO_LINE_CAP_ROUND: return kCGLineCapRound; break;
 314: 	case CAIRO_LINE_CAP_SQUARE: return kCGLineCapSquare; break;
 314:     }
 314: 
 314:     return kCGLineCapButt;
 314: }
 314: 
 314: static CGLineJoin
 314: _cairo_quartz_cairo_line_join_to_quartz (cairo_line_join_t cjoin)
 314: {
 314:     switch (cjoin) {
 314: 	case CAIRO_LINE_JOIN_MITER: return kCGLineJoinMiter; break;
 314: 	case CAIRO_LINE_JOIN_ROUND: return kCGLineJoinRound; break;
 314: 	case CAIRO_LINE_JOIN_BEVEL: return kCGLineJoinBevel; break;
 314:     }
 314: 
 314:     return kCGLineJoinMiter;
 314: }
 314: 
 314: static void
 314: _cairo_quartz_cairo_matrix_to_quartz (const cairo_matrix_t *src,
 314: 				       CGAffineTransform *dst)
 314: {
 314:     dst->a = src->xx;
4133:     dst->b = src->yx;
4133:     dst->c = src->xy;
 314:     dst->d = src->yy;
 314:     dst->tx = src->x0;
 314:     dst->ty = src->y0;
 314: }
 314: 
 314: /*
 314:  * Source -> Quartz setup and finish functions
 314:  */
 314: 
 314: static void
 314: ComputeGradientValue (void *info, const float *in, float *out)
 314: {
 314:     float fdist = *in; /* 0.0 .. 1.0 */
4133:     cairo_fixed_t fdist_fix = _cairo_fixed_from_double(*in);
 314:     cairo_gradient_pattern_t *grad = (cairo_gradient_pattern_t*) info;
 314:     unsigned int i;
 314: 
 314:     for (i = 0; i < grad->n_stops; i++) {
 314: 	if (grad->stops[i].x > fdist_fix)
 314: 	    break;
 314:     }
 314: 
 314:     if (i == 0 || i == grad->n_stops) {
 314: 	if (i == grad->n_stops)
 314: 	    --i;
 314: 	out[0] = grad->stops[i].color.red / 65535.;
 314: 	out[1] = grad->stops[i].color.green / 65535.;
 314: 	out[2] = grad->stops[i].color.blue / 65535.;
 314: 	out[3] = grad->stops[i].color.alpha / 65535.;
 314:     } else {
 314: 	float ax = _cairo_fixed_to_double(grad->stops[i-1].x);
 314: 	float bx = _cairo_fixed_to_double(grad->stops[i].x) - ax;
 314: 	float bp = (fdist - ax)/bx;
 314: 	float ap = 1.0 - bp;
 314: 
 314: 	out[0] =
 314: 	    (grad->stops[i-1].color.red / 65535.) * ap +
 314: 	    (grad->stops[i].color.red / 65535.) * bp;
 314: 	out[1] =
 314: 	    (grad->stops[i-1].color.green / 65535.) * ap +
 314: 	    (grad->stops[i].color.green / 65535.) * bp;
 314: 	out[2] =
 314: 	    (grad->stops[i-1].color.blue / 65535.) * ap +
 314: 	    (grad->stops[i].color.blue / 65535.) * bp;
 314: 	out[3] =
 314: 	    (grad->stops[i-1].color.alpha / 65535.) * ap +
 314: 	    (grad->stops[i].color.alpha / 65535.) * bp;
 314:     }
 314: }
 314: 
 314: static CGFunctionRef
 314: CreateGradientFunction (cairo_gradient_pattern_t *gpat)
 314: {
 314:     static const float input_value_range[2] = { 0.f, 1.f };
 314:     static const float output_value_ranges[8] = { 0.f, 1.f, 0.f, 1.f, 0.f, 1.f, 0.f, 1.f };
 314:     static const CGFunctionCallbacks callbacks = {
 314: 	0, ComputeGradientValue, (CGFunctionReleaseInfoCallback) cairo_pattern_destroy
 314:     };
 314: 
 314:     return CGFunctionCreate (gpat,
 314: 			     1,
 314: 			     input_value_range,
 314: 			     4,
 314: 			     output_value_ranges,
 314: 			     &callbacks);
 314: }
 314: 
 314: static CGShadingRef
 314: _cairo_quartz_cairo_gradient_pattern_to_quartz (cairo_pattern_t *abspat)
 314: {
 314:     cairo_matrix_t mat;
 314:     double x0, y0;
 314: 
 314:     if (abspat->type != CAIRO_PATTERN_TYPE_LINEAR &&
 314: 	abspat->type != CAIRO_PATTERN_TYPE_RADIAL)
 314: 	return NULL;
 314: 
4133:     /* bandaid for mozilla bug 379321, also visible in the
4133:      * linear-gradient-reflect test. 
4133:      */
4133:     if (abspat->extend == CAIRO_EXTEND_REFLECT ||
4133: 	abspat->extend == CAIRO_EXTEND_REPEAT)
4133: 	return NULL;
4133: 	
 314:     /* We can only do this if we have an identity pattern matrix;
 314:      * otherwise fall back through to the generic pattern case.
 314:      * XXXperf we could optimize this by creating a pattern with the shading;
 314:      * but we'd need to know the extents to do that.
 314:      * ... but we don't care; we can use the surface extents for it
 314:      * XXXtodo - implement gradients with non-identity pattern matrices
 314:      */
 314:     cairo_pattern_get_matrix (abspat, &mat);
 314:     if (mat.xx != 1.0 || mat.yy != 1.0 || mat.xy != 0.0 || mat.yx != 0.0)
 314: 	return NULL;
 314: 
 314:     x0 = mat.x0;
 314:     y0 = mat.y0;
 314: 
 314:     if (abspat->type == CAIRO_PATTERN_TYPE_LINEAR) {
 314: 	cairo_linear_pattern_t *lpat = (cairo_linear_pattern_t*) abspat;
 314: 	CGShadingRef shading;
 314: 	CGPoint start, end;
 314: 	CGFunctionRef gradFunc;
 314: 	CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB();
 314: 
4133: 	start = CGPointMake (_cairo_fixed_to_double (lpat->p1.x) - x0,
4133: 			     _cairo_fixed_to_double (lpat->p1.y) - y0);
4133: 	end = CGPointMake (_cairo_fixed_to_double (lpat->p2.x) - x0,
4133: 			   _cairo_fixed_to_double (lpat->p2.y) - y0);
 314: 
 314: 	cairo_pattern_reference (abspat);
 314: 	gradFunc = CreateGradientFunction ((cairo_gradient_pattern_t*) lpat);
 314: 	shading = CGShadingCreateAxial (rgb,
 314: 					start, end,
 314: 					gradFunc,
 314: 					true, true);
 314: 	CGColorSpaceRelease(rgb);
 314: 	CGFunctionRelease(gradFunc);
 314: 
 314: 	return shading;
 314:     }
 314: 
 314:     if (abspat->type == CAIRO_PATTERN_TYPE_RADIAL) {
 314: 	cairo_radial_pattern_t *rpat = (cairo_radial_pattern_t*) abspat;
 314: 	CGShadingRef shading;
 314: 	CGPoint start, end;
 314: 	CGFunctionRef gradFunc;
 314: 	CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB();
 314: 
4133: 	start = CGPointMake (_cairo_fixed_to_double (rpat->c1.x) - x0,
4133: 			     _cairo_fixed_to_double (rpat->c1.y) - y0);
4133: 	end = CGPointMake (_cairo_fixed_to_double (rpat->c2.x) - x0,
4133: 			   _cairo_fixed_to_double (rpat->c2.y) - y0);
 314: 
 314: 	cairo_pattern_reference (abspat);
 314: 	gradFunc = CreateGradientFunction ((cairo_gradient_pattern_t*) rpat);
 314: 	shading = CGShadingCreateRadial (rgb,
 314: 					 start,
4133: 					 _cairo_fixed_to_double (rpat->r1),
 314: 					 end,
4133: 					 _cairo_fixed_to_double (rpat->r2),
 314: 					 gradFunc,
 314: 					 true, true);
 314: 	CGColorSpaceRelease(rgb);
 314: 	CGFunctionRelease(gradFunc);
 314: 
 314: 	return shading;
 314:     }
 314: 
 314:     /* Shouldn't be reached */
 314:     ASSERT_NOT_REACHED;
 314:     return NULL;
 314: }
 314: 
4133: /* generic cairo surface -> cairo_quartz_surface_t function */
4133: static cairo_quartz_surface_t *
4133: _cairo_quartz_surface_to_quartz (cairo_surface_t *target, cairo_surface_t *pat_surf)
 314: {
 314:     cairo_quartz_surface_t *quartz_surf = NULL;
 314: 
 314:     if (cairo_surface_get_type(pat_surf) != CAIRO_SURFACE_TYPE_QUARTZ) {
4133: 	/* XXXtodo/perf don't use clone if the source surface is an image surface!  Instead,
 314: 	 * just create the CGImage directly!
 314: 	 */
 314: 
4133: 	cairo_surface_t *ref_type = target;
 314: 	cairo_surface_t *new_surf = NULL;
4133: 	cairo_rectangle_int_t rect;
4133: 	if (ref_type == NULL)
4133: 	    ref_type = cairo_quartz_surface_create (CAIRO_FORMAT_ARGB32, 1, 1);
 314: 
 314: 	_cairo_surface_get_extents (pat_surf, &rect);
 314: 
4133: 	_cairo_surface_clone_similar (ref_type, pat_surf, rect.x, rect.y,
 314: 				      rect.width, rect.height, &new_surf);
 314: 
4133: 	if (target == NULL)
4133: 	    cairo_surface_destroy(ref_type);
 314: 
 314: 	quartz_surf = (cairo_quartz_surface_t *) new_surf;
7173: 
7173: 	if (new_surf &&
7173: 	    cairo_surface_get_type (new_surf) != CAIRO_SURFACE_TYPE_QUARTZ) {
7173: 	    ND((stderr, "got a non-quartz surface, format=%d width=%u height=%u type=%d\n", cairo_surface_get_type (pat_surf), rect.width, rect.height, cairo_surface_get_type (new_surf)));
7173: 	    cairo_surface_destroy (new_surf);
7173: 	    quartz_surf = NULL;
7173: 	}
 314:     } else {
 314: 	/* If it's a quartz surface, we can try to see if it's a CGBitmapContext;
 314: 	 * we do this when we call CGBitmapContextCreateImage below.
 314: 	 */
 314: 	cairo_surface_reference (pat_surf);
 314: 	quartz_surf = (cairo_quartz_surface_t*) pat_surf;
 314: 
 314:     }
 314: 
4133:     return quartz_surf;
4133: }
4133: 
4133: /* Generic cairo_pattern -> CGPattern function */
4133: static void
4133: SurfacePatternDrawFunc (void *info, CGContextRef context)
4133: {
4133:     cairo_surface_pattern_t *spat = (cairo_surface_pattern_t *) info;
4133:     cairo_surface_t *pat_surf = spat->surface;
4133: 
4133:     cairo_quartz_surface_t *quartz_surf = _cairo_quartz_surface_to_quartz (NULL, pat_surf);
7173:     if (!quartz_surf)
7173: 	return;
7173: 
4133:     CGImageRef img = CGBitmapContextCreateImage (quartz_surf->cgContext);
4133:     CGRect imageBounds;
 314: 
 314:     if (!img) {
 314: 	// ... give up.
 314: 	ND((stderr, "CGBitmapContextCreateImage failed\n"));
 314: 	cairo_surface_destroy ((cairo_surface_t*)quartz_surf);
 314: 	return;
 314:     }
 314: 
4133:     /* XXXtodo WHY does this need to be flipped?  Writing this stuff
4133:      * to disk shows that in both this path and the path above the source image
4133:      * has an identical orientation, and the destination context at all times has a Y
4133:      * flip.  So why do we need to flip in this case?
4133:      */
4133:     if (cairo_surface_get_type(pat_surf) == CAIRO_SURFACE_TYPE_QUARTZ) {
 314: 	CGContextTranslateCTM (context, 0, CGImageGetHeight(img));
 314: 	CGContextScaleCTM (context, 1, -1);
 314:     }
 314: 
 314:     imageBounds.size = CGSizeMake (CGImageGetWidth(img), CGImageGetHeight(img));
 314:     imageBounds.origin.x = 0;
 314:     imageBounds.origin.y = 0;
 314: 
 314:     CGContextDrawImage (context, imageBounds, img);
4133:     if (spat->base.extend == CAIRO_EXTEND_REFLECT) {
4133: 	/* draw 3 more copies of the image, flipped. */
4133: 	CGContextTranslateCTM (context, 0, 2 * imageBounds.size.height);
4133: 	CGContextScaleCTM (context, 1, -1);
4133: 	CGContextDrawImage (context, imageBounds, img);
4133: 	CGContextTranslateCTM (context, 2 * imageBounds.size.width, 0);
4133: 	CGContextScaleCTM (context, -1, 1);
4133: 	CGContextDrawImage (context, imageBounds, img);
4133: 	CGContextTranslateCTM (context, 0, 2 * imageBounds.size.height);
4133: 	CGContextScaleCTM (context, 1, -1);
4133: 	CGContextDrawImage (context, imageBounds, img);
4133:     }
 314: 
 314:     CGImageRelease (img);
 314: 
 314:     cairo_surface_destroy ((cairo_surface_t*) quartz_surf);
 314: }
 314: 
 314: /* Borrowed from cairo-meta-surface */
 314: static cairo_status_t
 314: _init_pattern_with_snapshot (cairo_pattern_t *pattern,
 314: 			     const cairo_pattern_t *other)
 314: {
4133:     cairo_status_t status;
4133: 
4133:     status = _cairo_pattern_init_copy (pattern, other);
4133:     if (status)
4133: 	return status;
 314: 
 314:     if (pattern->type == CAIRO_PATTERN_TYPE_SURFACE) {
 314: 	cairo_surface_pattern_t *surface_pattern =
 314: 	    (cairo_surface_pattern_t *) pattern;
 314: 	cairo_surface_t *surface = surface_pattern->surface;
 314: 
 314: 	surface_pattern->surface = _cairo_surface_snapshot (surface);
 314: 
 314: 	cairo_surface_destroy (surface);
 314: 
 314: 	if (surface_pattern->surface->status)
 314: 	    return surface_pattern->surface->status;
 314:     }
 314: 
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: static CGPatternRef
 314: _cairo_quartz_cairo_repeating_surface_pattern_to_quartz (cairo_quartz_surface_t *dest,
 314: 							  cairo_pattern_t *abspat)
 314: {
 314:     cairo_surface_pattern_t *spat;
 314:     cairo_surface_t *pat_surf;
4133:     cairo_rectangle_int_t extents;
 314: 
 314:     CGRect pbounds;
 314:     CGAffineTransform ptransform, stransform;
 314:     CGPatternCallbacks cb = { 0,
 314: 			      SurfacePatternDrawFunc,
 314: 			      (CGFunctionReleaseInfoCallback) cairo_pattern_destroy };
 314:     CGPatternRef cgpat;
 314:     float rw, rh;
 314: 
 314:     cairo_pattern_union_t *snap_pattern = NULL;
 314:     cairo_pattern_t *target_pattern = abspat;
 314: 
 314:     cairo_matrix_t m;
 314:     /* SURFACE is the only type we'll handle here */
 314:     if (abspat->type != CAIRO_PATTERN_TYPE_SURFACE)
 314: 	return NULL;
 314: 
 314:     spat = (cairo_surface_pattern_t *) abspat;
 314:     pat_surf = spat->surface;
 314: 
 314:     _cairo_surface_get_extents (pat_surf, &extents);
 314:     pbounds.origin.x = 0;
 314:     pbounds.origin.y = 0;
4133: 
4133:     // kjs seems to indicate this should work (setting to 0,0 to avoid
4133:     // tiling); however, the pattern CTM scaling ends up being NaN in
4133:     // the pattern draw function if either rw or rh are 0.
4133:     // XXXtodo get pattern drawing working with extend options
4133:     // XXXtodo/perf optimize CAIRO_EXTEND_NONE to a single DrawImage instead of a pattern
4133:     if (spat->base.extend == CAIRO_EXTEND_REFLECT) {
4133: 	/* XXX broken; need to emulate by reflecting the image into 4 quadrants
4133: 	 * and then tiling that
4133: 	 */
4133: 	pbounds.size.width = 2 * extents.width;
4133: 	pbounds.size.height = 2 * extents.height;
4133:     } else {
 314: 	pbounds.size.width = extents.width;
 314: 	pbounds.size.height = extents.height;
4133:     }
4133:     rw = pbounds.size.width;
4133:     rh = pbounds.size.height;
 314: 
 314:     m = spat->base.matrix;
 314:     cairo_matrix_invert(&m);
 314:     _cairo_quartz_cairo_matrix_to_quartz (&m, &stransform);
 314: 
 314:     /* The pattern matrix is relative to the bottom left, again; the
 314:      * incoming cairo pattern matrix is relative to the upper left.
 314:      * So we take the pattern matrix and the original context matrix,
 314:      * which gives us the correct base translation/y flip.
 314:      */
 314:     ptransform = CGAffineTransformConcat(stransform, dest->cgContextBaseCTM);
 314: 
 314: #ifdef QUARTZ_DEBUG
 314:     ND((stderr, "  pbounds: %f %f %f %f\n", pbounds.origin.x, pbounds.origin.y, pbounds.size.width, pbounds.size.height));
 314:     ND((stderr, "  pattern xform: t: %f %f xx: %f xy: %f yx: %f yy: %f\n", ptransform.tx, ptransform.ty, ptransform.a, ptransform.b, ptransform.c, ptransform.d));
 314:     CGAffineTransform xform = CGContextGetCTM(dest->cgContext);
 314:     ND((stderr, "  context xform: t: %f %f xx: %f xy: %f yx: %f yy: %f\n", xform.tx, xform.ty, xform.a, xform.b, xform.c, xform.d));
 314: #endif
 314: 
 314: 
 314:     /* XXX fixme: only do snapshots if the context is for printing, or get rid of the
 314:        other block if it doesn't fafect performance */
 314:     if (1 /* context is for printing */) {
 314: 	snap_pattern = (cairo_pattern_union_t*) malloc(sizeof(cairo_pattern_union_t));
 314: 	target_pattern = (cairo_pattern_t*) snap_pattern;
 314: 	_init_pattern_with_snapshot (target_pattern, abspat);
 314:     } else {
 314: 	cairo_pattern_reference (abspat);
 314: 	target_pattern = abspat;
 314:     }
 314: 
 314:     cgpat = CGPatternCreate (target_pattern,
 314: 			     pbounds,
 314: 			     ptransform,
 314: 			     rw, rh,
 314: 			     kCGPatternTilingConstantSpacing, /* kCGPatternTilingNoDistortion, */
 314: 			     TRUE,
 314: 			     &cb);
 314:     return cgpat;
 314: }
 314: 
 314: typedef enum {
 314:     DO_SOLID,
 314:     DO_SHADING,
 314:     DO_PATTERN,
4133:     DO_IMAGE,
 314:     DO_UNSUPPORTED
 314: } cairo_quartz_action_t;
 314: 
 314: static cairo_quartz_action_t
 314: _cairo_quartz_setup_source (cairo_quartz_surface_t *surface,
 314: 			    cairo_pattern_t *source)
 314: {
 314:     assert (!(surface->sourceImage || surface->sourceShading || surface->sourcePattern));
 314: 
 314:     if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
 314: 	cairo_solid_pattern_t *solid = (cairo_solid_pattern_t *) source;
 314: 
 314: 	CGContextSetRGBStrokeColor (surface->cgContext,
 314: 				    solid->color.red,
 314: 				    solid->color.green,
 314: 				    solid->color.blue,
 314: 				    solid->color.alpha);
 314: 	CGContextSetRGBFillColor (surface->cgContext,
 314: 				  solid->color.red,
 314: 				  solid->color.green,
 314: 				  solid->color.blue,
 314: 				  solid->color.alpha);
 314: 
 314: 	return DO_SOLID;
 314:     } else if (source->type == CAIRO_PATTERN_TYPE_LINEAR ||
 314: 	       source->type == CAIRO_PATTERN_TYPE_RADIAL)
 314:     {
 314: 	CGShadingRef shading = _cairo_quartz_cairo_gradient_pattern_to_quartz (source);
 314: 	if (!shading)
 314: 	    return DO_UNSUPPORTED;
 314: 
 314: 	surface->sourceShading = shading;
 314: 
 314: 	return DO_SHADING;
4133:     } else if (source->type == CAIRO_PATTERN_TYPE_SURFACE &&
4133: 	       source->extend == CAIRO_EXTEND_NONE)
4133:     {
4133: 	    cairo_surface_pattern_t *spat = (cairo_surface_pattern_t *) source;
4133: 	    cairo_surface_t *pat_surf = spat->surface;
4133: 	    cairo_quartz_surface_t *quartz_surf = _cairo_quartz_surface_to_quartz ((cairo_surface_t *) surface, pat_surf);
7173: 	    if (!quartz_surf)
7173: 		return DO_UNSUPPORTED;
7173: 
4133: 	    CGImageRef img = CGBitmapContextCreateImage (quartz_surf->cgContext);
4133: 	    cairo_matrix_t m = spat->base.matrix;
4133: 	    cairo_rectangle_int_t extents;
4133: 
4133: 	    if (!img)
4133: 		return DO_UNSUPPORTED;
4133: 
4133: 	    surface->sourceImage = img;
4133: 
4133: 	    cairo_matrix_invert(&m);
4133: 	    _cairo_quartz_cairo_matrix_to_quartz (&m, &surface->sourceImageTransform);
4133: 
4133: 	    _cairo_surface_get_extents (pat_surf, &extents);
4133: 	    surface->sourceImageRect = CGRectMake (0, 0, extents.width, extents.height);
4133: 
4133: 	    surface->sourceImageSurface = (cairo_surface_t *)quartz_surf;
4133: 
4133: 	    return DO_IMAGE;
 314:     } else if (source->type == CAIRO_PATTERN_TYPE_SURFACE) {
4133: 	float patternAlpha = 1.0f;
4133: 	CGColorSpaceRef patternSpace;
4133: 
 314: 	CGPatternRef pattern = _cairo_quartz_cairo_repeating_surface_pattern_to_quartz (surface, source);
 314: 	if (!pattern)
 314: 	    return DO_UNSUPPORTED;
 314: 
 314: 	// Save before we change the pattern, colorspace, etc. so that
 314: 	// we can restore and make sure that quartz releases our
 314: 	// pattern (which may be stack allocated)
 314: 	CGContextSaveGState(surface->cgContext);
 314: 
4133: 	patternSpace = CGColorSpaceCreatePattern(NULL);
 314: 	CGContextSetFillColorSpace (surface->cgContext, patternSpace);
 314: 	CGContextSetFillPattern (surface->cgContext, pattern, &patternAlpha);
 314: 	CGContextSetStrokeColorSpace (surface->cgContext, patternSpace);
 314: 	CGContextSetStrokePattern (surface->cgContext, pattern, &patternAlpha);
 314: 	CGColorSpaceRelease (patternSpace);
 314: 
 314: 	/* Quartz likes to munge the pattern phase (as yet unexplained
 314: 	 * why); force it to 0,0 as we've already baked in the correct
 314: 	 * pattern translation into the pattern matrix
 314: 	 */
 314: 	CGContextSetPatternPhase (surface->cgContext, CGSizeMake(0,0));
 314: 
 314: 	surface->sourcePattern = pattern;
 314: 
 314: 	return DO_PATTERN;
 314:     } else {
 314: 	return DO_UNSUPPORTED;
 314:     }
 314: 
 314:     ASSERT_NOT_REACHED;
 314: }
 314: 
 314: static void
 314: _cairo_quartz_teardown_source (cairo_quartz_surface_t *surface,
 314: 				cairo_pattern_t *source)
 314: {
 314:     if (surface->sourceImage) {
4133: 	CGImageRelease(surface->sourceImage);
4133: 	surface->sourceImage = NULL;
4133: 
4133: 	cairo_surface_destroy(surface->sourceImageSurface);
4133: 	surface->sourceImageSurface = NULL;
 314:     }
 314: 
 314:     if (surface->sourceShading) {
 314: 	CGShadingRelease(surface->sourceShading);
 314: 	surface->sourceShading = NULL;
 314:     }
 314: 
 314:     if (surface->sourcePattern) {
 314: 	CGPatternRelease(surface->sourcePattern);
 314: 	// To tear down the pattern and colorspace
 314: 	CGContextRestoreGState(surface->cgContext);
 314: 
 314: 	surface->sourcePattern = NULL;
 314:     }
 314: }
 314: 
 314: /*
 314:  * get source/dest image implementation
 314:  */
 314: 
 314: static void
 314: ImageDataReleaseFunc(void *info, const void *data, size_t size)
 314: {
 314:     if (data != NULL) {
 314: 	free((void *) data);
 314:     }
 314: }
 314: 
 314: /* Read the image from the surface's front buffer */
 314: static cairo_int_status_t
 314: _cairo_quartz_get_image (cairo_quartz_surface_t *surface,
 314: 			  cairo_image_surface_t **image_out,
 314: 			  unsigned char **data_out)
 314: {
 314:     unsigned char *imageData;
 314:     cairo_image_surface_t *isurf;
 314: 
 314:     if (CGBitmapContextGetBitsPerPixel(surface->cgContext) != 0) {
 314: 	unsigned int stride;
 314: 	unsigned int bitinfo;
 314: 	unsigned int bpc, bpp;
 314: 	CGColorSpaceRef colorspace;
 314: 	unsigned int color_comps;
 314: 
 314: 	imageData = (unsigned char *) CGBitmapContextGetData(surface->cgContext);
 314: #ifdef USE_10_3_WORKAROUNDS
 314: 	bitinfo = CGBitmapContextGetAlphaInfo (surface->cgContext);
 314: #else
 314: 	bitinfo = CGBitmapContextGetBitmapInfo (surface->cgContext);
 314: #endif
 314: 	stride = CGBitmapContextGetBytesPerRow (surface->cgContext);
 314: 	bpp = CGBitmapContextGetBitsPerPixel (surface->cgContext);
 314: 	bpc = CGBitmapContextGetBitsPerComponent (surface->cgContext);
 314: 
 314: 	// let's hope they don't add YUV under us
 314: 	colorspace = CGBitmapContextGetColorSpace (surface->cgContext);
 314: 	color_comps = CGColorSpaceGetNumberOfComponents(colorspace);
 314: 
 314: 	// XXX TODO: We can handle all of these by converting to
 314: 	// pixman masks, including non-native-endian masks
 314: 	if (bpc != 8)
 314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 
 314: 	if (bpp != 32 && bpp != 8)
 314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 
 314: 	if (color_comps != 3 && color_comps != 1)
 314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 
 314: 	if (bpp == 32 && color_comps == 3 &&
 314: 	    (bitinfo & kCGBitmapAlphaInfoMask) == kCGImageAlphaPremultipliedFirst &&
 314: 	    (bitinfo & kCGBitmapByteOrderMask) == kCGBitmapByteOrder32Host)
 314: 	{
 314: 	    isurf = (cairo_image_surface_t *)
 314: 		cairo_image_surface_create_for_data (imageData,
 314: 						     CAIRO_FORMAT_ARGB32,
 314: 						     surface->extents.width,
 314: 						     surface->extents.height,
 314: 						     stride);
 314: 	} else if (bpp == 32 && color_comps == 3 &&
 314: 		   (bitinfo & kCGBitmapAlphaInfoMask) == kCGImageAlphaNoneSkipFirst &&
 314: 		   (bitinfo & kCGBitmapByteOrderMask) == kCGBitmapByteOrder32Host)
 314: 	{
 314: 	    isurf = (cairo_image_surface_t *)
 314: 		cairo_image_surface_create_for_data (imageData,
 314: 						     CAIRO_FORMAT_RGB24,
 314: 						     surface->extents.width,
 314: 						     surface->extents.height,
 314: 						     stride);
 314: 	} else if (bpp == 8 && color_comps == 1)
 314: 	{
 314: 	    isurf = (cairo_image_surface_t *)
 314: 		cairo_image_surface_create_for_data (imageData,
 314: 						     CAIRO_FORMAT_A8,
 314: 						     surface->extents.width,
 314: 						     surface->extents.height,
 314: 						     stride);
 314: 	} else {
 314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 	}
 314:     } else {
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     *image_out = isurf;
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: /*
 314:  * Cairo surface backend implementations
 314:  */
 314: 
   1: static cairo_status_t
   1: _cairo_quartz_surface_finish (void *abstract_surface)
   1: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
   1: 
 314:     ND((stderr, "_cairo_quartz_surface_finish[%p] cgc: %p\n", surface, surface->cgContext));
 314: 
 314:     /* Restore our saved gstate that we use to reset clipping */
 314:     CGContextRestoreGState (surface->cgContext);
 314: 
 314:     CGContextRelease (surface->cgContext);
 314: 
 314:     surface->cgContext = NULL;
 314: 
 314:     if (surface->imageData) {
 314: 	free (surface->imageData);
 314: 	surface->imageData = NULL;
 314:     }
   1: 
   1:     return CAIRO_STATUS_SUCCESS;
   1: }
   1: 
   1: static cairo_status_t
   1: _cairo_quartz_surface_acquire_source_image (void *abstract_surface,
   1: 					     cairo_image_surface_t **image_out,
   1: 					     void **image_extra)
   1: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
   1: 
 314:     //ND((stderr, "%p _cairo_quartz_surface_acquire_source_image\n", surface));
   1: 
 314:     *image_extra = NULL;
 314: 
 314:     return _cairo_quartz_get_image (surface, image_out, NULL);
   1: }
   1: 
4133: static void
4133: _cairo_quartz_surface_release_source_image (void *abstract_surface,
4133: 					     cairo_image_surface_t *image,
4133: 					     void *image_extra)
4133: {
4133:     cairo_surface_destroy ((cairo_surface_t *) image);
4133: }
4133: 
4133: 
   1: static cairo_status_t
   1: _cairo_quartz_surface_acquire_dest_image (void *abstract_surface,
4133: 					  cairo_rectangle_int_t *interest_rect,
   1: 					  cairo_image_surface_t **image_out,
4133: 					  cairo_rectangle_int_t *image_rect,
   1: 					  void **image_extra)
   1: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     cairo_int_status_t status;
   1:     unsigned char *data;
   1: 
 314:     ND((stderr, "%p _cairo_quartz_surface_acquire_dest_image\n", surface));
   1: 
 314:     *image_rect = surface->extents;
   1: 
 314:     status = _cairo_quartz_get_image (surface, image_out, &data);
 314:     if (status)
 314: 	return status;
 314: 
 314:     *image_extra = data;
   1: 
   1:     return CAIRO_STATUS_SUCCESS;
   1: }
   1: 
   1: static void
   1: _cairo_quartz_surface_release_dest_image (void *abstract_surface,
4133: 					  cairo_rectangle_int_t *interest_rect,
   1: 					  cairo_image_surface_t *image,
4133: 					  cairo_rectangle_int_t *image_rect,
   1: 					  void *image_extra)
   1: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     unsigned char *imageData = (unsigned char *) image_extra;
   1: 
 314:     //ND((stderr, "%p _cairo_quartz_surface_release_dest_image\n", surface));
   1: 
 314:     if (!CGBitmapContextGetData (surface->cgContext)) {
 314: 	CGDataProviderRef dataProvider;
 314: 	CGImageRef img;
   1: 
 314: 	dataProvider = CGDataProviderCreateWithData (NULL, imageData,
 314: 						     surface->extents.width * surface->extents.height * 4,
 314: 						     ImageDataReleaseFunc);
   1: 
 314: 	img = CGImageCreate (surface->extents.width, surface->extents.height,
 314: 			     8, 32,
 314: 			     surface->extents.width * 4,
 314: 			     CGColorSpaceCreateDeviceRGB(),
 314: 			     kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host,
 314: 			     dataProvider,
 314: 			     NULL,
 314: 			     false,
 314: 			     kCGRenderingIntentDefault);
   1: 
 314: 	CGContextSetCompositeOperation (surface->cgContext, kPrivateCGCompositeCopy);
 314: 
 314: 	CGContextDrawImage (surface->cgContext,
 314: 			    CGRectMake (0, 0, surface->extents.width, surface->extents.height),
 314: 			    img);
 314: 
 314: 	CGImageRelease (img);
 314: 	CGDataProviderRelease (dataProvider);
 314: 
 314: 	ND((stderr, "Image for surface %p was recovered from a bitmap\n", surface));
   1:     }
   1: 
   1:     cairo_surface_destroy ((cairo_surface_t *) image);
   1: }
   1: 
 314: static cairo_surface_t *
 314: _cairo_quartz_surface_create_similar (void *abstract_surface,
 314: 				       cairo_content_t content,
 314: 				       int width,
 314: 				       int height)
   1: {
 314:     /*cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;*/
   1: 
 314:     cairo_format_t format;
   1: 
 314:     if (content == CAIRO_CONTENT_COLOR_ALPHA)
 314: 	format = CAIRO_FORMAT_ARGB32;
 314:     else if (content == CAIRO_CONTENT_COLOR)
 314: 	format = CAIRO_FORMAT_RGB24;
 314:     else if (content == CAIRO_CONTENT_ALPHA)
 314: 	format = CAIRO_FORMAT_A8;
 314:     else
 314: 	return NULL;
 314: 	
7123:     // verify width and height of surface
7123:     if (!verify_surface_size(width, height)) {
7123: 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
7123: 	return NULL;
7123:     }
7123: 
 314:     return cairo_quartz_surface_create (format, width, height);
 314: }
 314: 
 314: static cairo_status_t
 314: _cairo_quartz_surface_clone_similar (void *abstract_surface,
 314: 				      cairo_surface_t *src,
 314: 				      int              src_x,
 314: 				      int              src_y,
 314: 				      int              width,
 314: 				      int              height,
 314: 				      cairo_surface_t **clone_out)
 314: {
 314:     cairo_quartz_surface_t *new_surface = NULL;
 314:     cairo_format_t new_format;
 314:     
7123:     *clone_out = NULL;
7123: 
7123:     // verify width and height of surface
7123:     if (!verify_surface_size(width, height)) {
7123: 	return CAIRO_INT_STATUS_UNSUPPORTED;
7123:     }
7123: 
 314:     CGImageRef quartz_image = NULL;
 314: 
 314:     if (cairo_surface_get_type(src) == CAIRO_SURFACE_TYPE_QUARTZ) {
 314: 	cairo_quartz_surface_t *qsurf = (cairo_quartz_surface_t *) src;
 314: 	quartz_image = CGBitmapContextCreateImage (qsurf->cgContext);
 314: 	new_format = CAIRO_FORMAT_ARGB32;  /* XXX bogus; recover a real format from the image */
 314:     } else if (_cairo_surface_is_image (src)) {
 314: 	cairo_image_surface_t *isurf = (cairo_image_surface_t *) src;
 314: 	CGDataProviderRef dataProvider;
 314: 	CGColorSpaceRef cgColorspace;
 314: 	CGBitmapInfo bitinfo;
 314: 	int bitsPerComponent, bitsPerPixel;
 314: 
 314: 	if (isurf->format == CAIRO_FORMAT_ARGB32) {
 314: 	    cgColorspace = CGColorSpaceCreateDeviceRGB();
 314: 	    bitinfo = kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host;
 314: 	    bitsPerComponent = 8;
 314: 	    bitsPerPixel = 32;
 314: 	} else if (isurf->format == CAIRO_FORMAT_RGB24) {
 314: 	    cgColorspace = CGColorSpaceCreateDeviceRGB();
 314: 	    bitinfo = kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host;
 314: 	    bitsPerComponent = 8;
 314: 	    bitsPerPixel = 32;
 314: 	} else if (isurf->format == CAIRO_FORMAT_A8) {
 314: 	    cgColorspace = CGColorSpaceCreateDeviceGray();
 314: 	    bitinfo = kCGImageAlphaNone;
 314: 	    bitsPerComponent = 8;
 314: 	    bitsPerPixel = 8;
 314: 	} else {
 314: 	    /* SUPPORT A1, maybe */
 314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 	}
 314: 
 314: 	new_format = isurf->format;
 314: 
7123:         
 314: 	dataProvider = CGDataProviderCreateWithData (NULL,
 314: 						     isurf->data,
 314: 						     isurf->height * isurf->stride,
 314: 						     NULL);
 314: 
 314: 	quartz_image = CGImageCreate (isurf->width, isurf->height,
 314: 				      bitsPerComponent,
 314: 				      bitsPerPixel,
 314: 				      isurf->stride,
 314: 				      cgColorspace,
 314: 				      bitinfo,
 314: 				      dataProvider,
 314: 				      NULL,
 314: 				      false,
 314: 				      kCGRenderingIntentDefault);
 314: 	CGDataProviderRelease (dataProvider);
 314: 	CGColorSpaceRelease (cgColorspace);
 314:     } else {
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     if (!quartz_image)
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 
 314:     new_surface = (cairo_quartz_surface_t *)
 314: 	cairo_quartz_surface_create (new_format,
 314: 				     CGImageGetWidth (quartz_image),
 314: 				     CGImageGetHeight (quartz_image));
7173:     if (!new_surface || new_surface->base.status) {
7173: 	CGImageRelease (quartz_image);
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
7173:     }
 314: 
 314:     CGContextSetCompositeOperation (new_surface->cgContext,
 314: 				    kPrivateCGCompositeCopy);
 314: 
 314:     quartz_image_to_png (quartz_image, NULL);
 314: 
 314:     CGContextDrawImage (new_surface->cgContext,
 314: 			CGRectMake (src_x, src_y, width, height),
 314: 			quartz_image);
 314:     CGImageRelease (quartz_image);
 314: 
 314:     *clone_out = (cairo_surface_t*) new_surface;
   1: 
   1:     return CAIRO_STATUS_SUCCESS;
   1: }
   1: 
   1: static cairo_int_status_t
   1: _cairo_quartz_surface_get_extents (void *abstract_surface,
4133: 				   cairo_rectangle_int_t *extents)
   1: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
   1: 
 314:     *extents = surface->extents;
   1: 
   1:     return CAIRO_STATUS_SUCCESS;
   1: }
   1: 
 314: static cairo_int_status_t
 314: _cairo_quartz_surface_paint (void *abstract_surface,
 314: 			      cairo_operator_t op,
 314: 			      cairo_pattern_t *source)
 314: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
 314:     cairo_quartz_action_t action;
 314: 
 314:     ND((stderr, "%p _cairo_quartz_surface_paint op %d source->type %d\n", surface, op, source->type));
 314: 
 314:     if (op == CAIRO_OPERATOR_DEST)
 314: 	return CAIRO_STATUS_SUCCESS;
 314: 
 314:     CGContextSetCompositeOperation (surface->cgContext, _cairo_quartz_cairo_operator_to_quartz (op));
 314: 
 314:     action = _cairo_quartz_setup_source (surface, source);
 314: 
 314:     if (action == DO_SOLID || action == DO_PATTERN) {
 314: 	CGContextFillRect (surface->cgContext, CGRectMake(surface->extents.x,
 314: 							  surface->extents.y,
 314: 							  surface->extents.width,
 314: 							  surface->extents.height));
 314:     } else if (action == DO_SHADING) {
 314: 	CGContextDrawShading (surface->cgContext, surface->sourceShading);
4133:     } else if (action == DO_IMAGE) {
4133: 	cairo_surface_pattern_t *surface_pattern =
4133: 	    (cairo_surface_pattern_t *) source;
4133: 	cairo_surface_t *pat_surf = surface_pattern->surface;
4133: 	CGContextSaveGState (surface->cgContext);
4133: 	CGContextConcatCTM (surface->cgContext, surface->sourceImageTransform);
4133: 	if (cairo_surface_get_type(pat_surf) == CAIRO_SURFACE_TYPE_QUARTZ) {
4133: 	    CGContextTranslateCTM (surface->cgContext, 0, CGImageGetHeight(surface->sourceImage));
4133: 	    CGContextScaleCTM (surface->cgContext, 1, -1);
4133: 	}
4133: 
4133: 	CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
4133: 	CGContextRestoreGState (surface->cgContext);
 314:     } else {
 314: 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     _cairo_quartz_teardown_source (surface, source);
 314: 
 314:     ND((stderr, "-- paint\n"));
 314:     return rv;
 314: }
 314: 
 314: static cairo_int_status_t
 314: _cairo_quartz_surface_fill (void *abstract_surface,
 314: 			     cairo_operator_t op,
 314: 			     cairo_pattern_t *source,
 314: 			     cairo_path_fixed_t *path,
 314: 			     cairo_fill_rule_t fill_rule,
 314: 			     double tolerance,
 314: 			     cairo_antialias_t antialias)
 314: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
 314:     cairo_quartz_action_t action;
4133:     quartz_stroke_t stroke;
 314: 
 314:     ND((stderr, "%p _cairo_quartz_surface_fill op %d source->type %d\n", surface, op, source->type));
 314: 
 314:     if (op == CAIRO_OPERATOR_DEST)
 314: 	return CAIRO_STATUS_SUCCESS;
 314: 
 314:     CGContextSaveGState (surface->cgContext);
 314: 
 314:     CGContextSetShouldAntialias (surface->cgContext, (antialias != CAIRO_ANTIALIAS_NONE));
 314:     CGContextSetCompositeOperation (surface->cgContext, _cairo_quartz_cairo_operator_to_quartz (op));
 314: 
 314:     action = _cairo_quartz_setup_source (surface, source);
 314:     if (action == DO_UNSUPPORTED) {
 314: 	CGContextRestoreGState (surface->cgContext);
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     CGContextBeginPath (surface->cgContext);
4133: 
4133:     stroke.cgContext = surface->cgContext;
4133:     stroke.ctm_inverse = NULL;
4133:     _cairo_quartz_cairo_path_to_quartz_context (path, &stroke);
 314: 
 314:     if (action == DO_SOLID || action == DO_PATTERN) {
 314: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
 314: 	    CGContextFillPath (surface->cgContext);
 314: 	else
 314: 	    CGContextEOFillPath (surface->cgContext);
 314:     } else if (action == DO_SHADING) {
 314: 
 314: 	// we have to clip and then paint the shading; we can't fill
 314: 	// with the shading
 314: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
 314: 	    CGContextClip (surface->cgContext);
 314: 	else
 314: 	    CGContextEOClip (surface->cgContext);
 314: 
 314: 	CGContextDrawShading (surface->cgContext, surface->sourceShading);
4133:     } else if (action == DO_IMAGE) {
4133: 	cairo_surface_pattern_t *surface_pattern =
4133: 	    (cairo_surface_pattern_t *) source;
4133: 	cairo_surface_t *pat_surf = surface_pattern->surface;
4133: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
4133: 	    CGContextClip (surface->cgContext);
4133: 	else
4133: 	    CGContextEOClip (surface->cgContext);
4133: 	CGContextConcatCTM (surface->cgContext, surface->sourceImageTransform);
4133: 	if (cairo_surface_get_type(pat_surf) == CAIRO_SURFACE_TYPE_QUARTZ) {
4133: 	    CGContextTranslateCTM (surface->cgContext, 0, CGImageGetHeight(surface->sourceImage));
4133: 	    CGContextScaleCTM (surface->cgContext, 1, -1);
4133: 	}
4133: 
4133: 	CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 314:     } else {
 314: 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     _cairo_quartz_teardown_source (surface, source);
 314: 
 314:     CGContextRestoreGState (surface->cgContext);
 314: 
 314:     ND((stderr, "-- fill\n"));
 314:     return rv;
 314: }
 314: 
 314: static cairo_int_status_t
 314: _cairo_quartz_surface_stroke (void *abstract_surface,
 314: 			       cairo_operator_t op,
 314: 			       cairo_pattern_t *source,
 314: 			       cairo_path_fixed_t *path,
 314: 			       cairo_stroke_style_t *style,
 314: 			       cairo_matrix_t *ctm,
 314: 			       cairo_matrix_t *ctm_inverse,
 314: 			       double tolerance,
 314: 			       cairo_antialias_t antialias)
 314: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
 314:     cairo_quartz_action_t action;
4133:     quartz_stroke_t stroke;
4133:     CGAffineTransform strokeTransform;
 314: 
 314:     ND((stderr, "%p _cairo_quartz_surface_stroke op %d source->type %d\n", surface, op, source->type));
 314: 
 314:     if (op == CAIRO_OPERATOR_DEST)
 314: 	return CAIRO_STATUS_SUCCESS;
 314: 
 314:     CGContextSaveGState (surface->cgContext);
 314: 
 314:     // Turning antialiasing off causes misrendering with
 314:     // single-pixel lines (e.g. 20,10.5 -> 21,10.5 end up being rendered as 2 pixels)
 314:     //CGContextSetShouldAntialias (surface->cgContext, (antialias != CAIRO_ANTIALIAS_NONE));
 314:     CGContextSetLineWidth (surface->cgContext, style->line_width);
 314:     CGContextSetLineCap (surface->cgContext, _cairo_quartz_cairo_line_cap_to_quartz (style->line_cap));
 314:     CGContextSetLineJoin (surface->cgContext, _cairo_quartz_cairo_line_join_to_quartz (style->line_join));
 314:     CGContextSetMiterLimit (surface->cgContext, style->miter_limit);
4133:     _cairo_quartz_cairo_matrix_to_quartz (ctm, &strokeTransform);
4133:     CGContextConcatCTM (surface->cgContext, strokeTransform);
 314: 
 314:     if (style->dash && style->num_dashes) {
 314: #define STATIC_DASH 32
 314: 	float sdash[STATIC_DASH];
 314: 	float *fdash = sdash;
 314: 	unsigned int k;
 314: 	if (style->num_dashes > STATIC_DASH)
4133: 	    fdash = _cairo_malloc_ab (style->num_dashes, sizeof (float));
 314: 
 314: 	for (k = 0; k < style->num_dashes; k++)
 314: 	    fdash[k] = (float) style->dash[k];
 314: 	
 314: 	CGContextSetLineDash (surface->cgContext, style->dash_offset, fdash, style->num_dashes);
 314: 
 314: 	if (fdash != sdash)
 314: 	    free (fdash);
 314:     }
 314: 
 314:     CGContextSetCompositeOperation (surface->cgContext, _cairo_quartz_cairo_operator_to_quartz (op));
 314: 
 314:     action = _cairo_quartz_setup_source (surface, source);
 314:     if (action == DO_UNSUPPORTED) {
 314: 	CGContextRestoreGState (surface->cgContext);
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     CGContextBeginPath (surface->cgContext);
4133: 
4133:     stroke.cgContext = surface->cgContext;
4133:     stroke.ctm_inverse = ctm_inverse;
4133:     _cairo_quartz_cairo_path_to_quartz_context (path, &stroke);
 314: 
 314:     if (action == DO_SOLID || action == DO_PATTERN) {
 314: 	CGContextStrokePath (surface->cgContext);
4133:     } else if (action == DO_IMAGE) {
4133: 	CGContextReplacePathWithStrokedPath (surface->cgContext);
4133: 	CGContextClip (surface->cgContext);
4133: 
4133: 	CGContextConcatCTM (surface->cgContext, surface->sourceImageTransform);
4133: 	if (cairo_surface_get_type(((cairo_surface_pattern_t*)source)->surface) == CAIRO_SURFACE_TYPE_QUARTZ) {
4133: 	    CGContextTranslateCTM (surface->cgContext, 0, CGImageGetHeight(surface->sourceImage));
4133: 	    CGContextScaleCTM (surface->cgContext, 1, -1);
4133: 	}
4133: 
4133: 	CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
 314:     } else if (action == DO_SHADING) {
 314: 	CGContextReplacePathWithStrokedPath (surface->cgContext);
 314: 	CGContextClip (surface->cgContext);
 314: 
 314: 	CGContextDrawShading (surface->cgContext, surface->sourceShading);
 314:     } else {
 314: 	rv = CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     _cairo_quartz_teardown_source (surface, source);
 314: 
 314:     CGContextRestoreGState (surface->cgContext);
 314: 
 314:     ND((stderr, "-- stroke\n"));
 314:     return rv;
 314: }
 314: 
 314: #if CAIRO_HAS_ATSUI_FONT
 314: static cairo_int_status_t
 314: _cairo_quartz_surface_show_glyphs (void *abstract_surface,
 314: 				    cairo_operator_t op,
 314: 				    cairo_pattern_t *source,
 314: 				    cairo_glyph_t *glyphs,
 314: 				    int num_glyphs,
 314: 				    cairo_scaled_font_t *scaled_font)
 314: {
4133:     ATSUFontID fid;
4133:     ATSFontRef atsfref;
4133:     CGFontRef cgfref;
4133:     CGAffineTransform cairoTextTransform, textTransform, ctm;
4133:     // XXXtodo/perf: stack storage for glyphs/sizes
4133: #define STATIC_BUF_SIZE 64
4133:     CGGlyph glyphs_static[STATIC_BUF_SIZE];
4133:     CGSize cg_advances_static[STATIC_BUF_SIZE];
4133:     CGGlyph *cg_glyphs = &glyphs_static[0];
4133:     CGSize *cg_advances = &cg_advances_static[0];
4133: 
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
 314:     cairo_quartz_action_t action;
4133:     float xprev, yprev;
 314:     int i;
 314: 
 314:     if (num_glyphs <= 0)
 314: 	return CAIRO_STATUS_SUCCESS;
 314: 
 314:     if (op == CAIRO_OPERATOR_DEST)
 314: 	return CAIRO_STATUS_SUCCESS;
 314: 
 314:     if (cairo_scaled_font_get_type (scaled_font) != CAIRO_FONT_TYPE_ATSUI)
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 
 314:     CGContextSaveGState (surface->cgContext);
 314: 
 314:     action = _cairo_quartz_setup_source (surface, source);
 314:     if (action == DO_SOLID || action == DO_PATTERN) {
 314: 	CGContextSetTextDrawingMode (surface->cgContext, kCGTextFill);
4133:     } else if (action == DO_IMAGE || action == DO_SHADING) {
 314: 	CGContextSetTextDrawingMode (surface->cgContext, kCGTextClip);
 314:     } else {
 314: 	/* Unsupported */
 314: 	CGContextRestoreGState (surface->cgContext);
 314: 	return CAIRO_INT_STATUS_UNSUPPORTED;
 314:     }
 314: 
 314:     CGContextSetCompositeOperation (surface->cgContext, _cairo_quartz_cairo_operator_to_quartz (op));
 314: 
4133:     fid = _cairo_atsui_scaled_font_get_atsu_font_id (scaled_font);
4133:     atsfref = FMGetATSFontRefFromFont (fid);
4133:     cgfref = CGFontCreateWithPlatformFont (&atsfref);
 314: 
 314:     CGContextSetFont (surface->cgContext, cgfref);
 314:     CGFontRelease (cgfref);
 314: 
 314:     /* So this should include the size; I don't know if I need to extract the
 314:      * size from this and call CGContextSetFontSize.. will I get crappy hinting
 314:      * with this 1.0 size business?  Or will CG just multiply that size into the
 314:      * text matrix?
 314:      */
 314:     //ND((stderr, "show_glyphs: glyph 0 at: %f, %f\n", glyphs[0].x, glyphs[0].y));
4133:     cairoTextTransform = CGAffineTransformMake (scaled_font->font_matrix.xx, 
4133: 						scaled_font->font_matrix.yx,
4133: 						scaled_font->font_matrix.xy, 
4133: 						scaled_font->font_matrix.yy,
4133: 						0., 0.);
 314: 
 314:     textTransform = CGAffineTransformMakeTranslation (glyphs[0].x, glyphs[0].y);
 314:     textTransform = CGAffineTransformScale (textTransform, 1.0, -1.0);
 314:     textTransform = CGAffineTransformConcat (cairoTextTransform, textTransform);
 314: 
 314:     ctm = CGAffineTransformMake (scaled_font->ctm.xx,
 314: 				 -scaled_font->ctm.yx,
 314: 				 -scaled_font->ctm.xy,
 314: 				 scaled_font->ctm.yy,
 314: 				 0., 0.);
 314:     textTransform = CGAffineTransformConcat (ctm, textTransform);
 314: 
 314:     CGContextSetTextMatrix (surface->cgContext, textTransform);
 314:     CGContextSetFontSize (surface->cgContext, 1.0);
 314: 
 314:     if (num_glyphs > STATIC_BUF_SIZE) {
4133: 	cg_glyphs = (CGGlyph*) _cairo_malloc_ab (num_glyphs, sizeof(CGGlyph));
4133: 	cg_advances = (CGSize*) _cairo_malloc_ab (num_glyphs, sizeof(CGSize));
 314:     }
 314: 
4133:     xprev = glyphs[0].x;
4133:     yprev = glyphs[0].y;
 361: 
 361:     cg_glyphs[0] = glyphs[0].index;
 361:     cg_advances[0].width = 0;
 361:     cg_advances[0].height = 0;
 361: 
 361:     for (i = 1; i < num_glyphs; i++) {
 361: 	float xf = glyphs[i].x;
 361: 	float yf = glyphs[i].y;
4133: 	cg_glyphs[i] = glyphs[i].index;
 361: 	cg_advances[i-1].width = xf - xprev;
 361: 	cg_advances[i-1].height = yf - yprev;
 361: 	xprev = xf;
 361: 	yprev = yf;
 361:     }
 314: 
 314: #if 0
 314:     for (i = 0; i < num_glyphs; i++) {
 314: 	ND((stderr, "[%d: %d %f,%f]\n", i, cg_glyphs[i], cg_advances[i].width, cg_advances[i].height));
 314:     }
 314: #endif
 314: 
 314:     CGContextShowGlyphsWithAdvances (surface->cgContext,
 314: 				     cg_glyphs,
 314: 				     cg_advances,
 314: 				     num_glyphs);
 314: 
 314:     if (cg_glyphs != &glyphs_static[0]) {
 314: 	free (cg_glyphs);
 314: 	free (cg_advances);
 314:     }
 314: 
4133:     if (action == DO_IMAGE) {
4133: 	CGContextConcatCTM (surface->cgContext, surface->sourceImageTransform);
4133: 	if (cairo_surface_get_type(((cairo_surface_pattern_t*)source)->surface) == CAIRO_SURFACE_TYPE_QUARTZ) {
4133: 	    CGContextTranslateCTM (surface->cgContext, 0, CGImageGetHeight(surface->sourceImage));
4133: 	    CGContextScaleCTM (surface->cgContext, 1, -1);
4133: 	}
4133: 
4133: 	CGContextDrawImage (surface->cgContext, surface->sourceImageRect, surface->sourceImage);
4133:     } else if (action == DO_SHADING) {
 314: 	CGContextDrawShading (surface->cgContext, surface->sourceShading);
4133:     }
 314: 
 314:     _cairo_quartz_teardown_source (surface, source);
 314: 
 314:     CGContextRestoreGState (surface->cgContext);
 314: 
 314:     return rv;
 314: }
 314: #endif /* CAIRO_HAS_ATSUI_FONT */
 314: 
 314: static cairo_int_status_t
 314: _cairo_quartz_surface_mask (void *abstract_surface,
 314: 			     cairo_operator_t op,
 314: 			     cairo_pattern_t *source,
 314: 			     cairo_pattern_t *mask)
 314: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
 314:     cairo_int_status_t rv = CAIRO_STATUS_SUCCESS;
 314: 
 314:     ND((stderr, "%p _cairo_quartz_surface_mask op %d source->type %d mask->type %d\n", surface, op, source->type, mask->type));
 314: 
 314:     if (mask->type == CAIRO_PATTERN_TYPE_SOLID) {
 314: 	/* This is easy; we just need to paint with the alpha. */
 314: 	cairo_solid_pattern_t *solid_mask = (cairo_solid_pattern_t *) mask;
 314: 
 314: 	CGContextSetAlpha (surface->cgContext, solid_mask->color.alpha);
 314:     } else {
 314: 	/* So, CGContextClipToMask is not present in 10.3.9, so we're
 314: 	 * doomed; if we have imageData, we can do fallback, otherwise
 314: 	 * just pretend success.
 314: 	 */
 314: 	if (surface->imageData)
 314: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
 314: 
 314: 	return CAIRO_STATUS_SUCCESS;
 314:     }
 314: 
 314:     rv = _cairo_quartz_surface_paint (surface, op, source);
 314: 
 314:     if (mask->type == CAIRO_PATTERN_TYPE_SOLID) {
 314: 	CGContextSetAlpha (surface->cgContext, 1.0);
 314:     }
 314: 
 314:     ND((stderr, "-- mask\n"));
 314: 
 314:     return rv;
 314: }
 314: 
 314: static cairo_int_status_t
 314: _cairo_quartz_surface_intersect_clip_path (void *abstract_surface,
 314: 					    cairo_path_fixed_t *path,
 314: 					    cairo_fill_rule_t fill_rule,
 314: 					    double tolerance,
 314: 					    cairo_antialias_t antialias)
 314: {
 314:     cairo_quartz_surface_t *surface = (cairo_quartz_surface_t *) abstract_surface;
4133:     quartz_stroke_t stroke;
 314: 
 314:     ND((stderr, "%p _cairo_quartz_surface_intersect_clip_path path: %p\n", surface, path));
 314: 
 314:     if (path == NULL) {
 314: 	/* If we're being asked to reset the clip, we can only do it
 314: 	 * by restoring the gstate to our previous saved one, and
 314: 	 * saving it again.
 314: 	 *
 314: 	 * Note that this assumes that ALL quartz surface creation
 314: 	 * functions will do a SaveGState first; we do this in create_internal.
 314: 	 */
 314: 	CGContextRestoreGState (surface->cgContext);
 314: 	CGContextSaveGState (surface->cgContext);
 314:     } else {
 314: 	CGContextBeginPath (surface->cgContext);
4133: 	stroke.cgContext = surface->cgContext;
4133: 	stroke.ctm_inverse = NULL;
4133: 	_cairo_quartz_cairo_path_to_quartz_context (path, &stroke);
 314: 	if (fill_rule == CAIRO_FILL_RULE_WINDING)
 314: 	    CGContextClip (surface->cgContext);
 314: 	else
 314: 	    CGContextEOClip (surface->cgContext);
 314:     }
 314: 
 314:     ND((stderr, "-- intersect_clip_path\n"));
 314: 
 314:     return CAIRO_STATUS_SUCCESS;
 314: }
 314: 
 314: // XXXtodo implement show_page; need to figure out how to handle begin/end
 314: 
   1: static const struct _cairo_surface_backend cairo_quartz_surface_backend = {
   1:     CAIRO_SURFACE_TYPE_QUARTZ,
 314:     _cairo_quartz_surface_create_similar,
   1:     _cairo_quartz_surface_finish,
   1:     _cairo_quartz_surface_acquire_source_image,
4133:     _cairo_quartz_surface_release_source_image,
   1:     _cairo_quartz_surface_acquire_dest_image,
   1:     _cairo_quartz_surface_release_dest_image,
 314:     _cairo_quartz_surface_clone_similar,
   1:     NULL, /* composite */
   1:     NULL, /* fill_rectangles */
   1:     NULL, /* composite_trapezoids */
   1:     NULL, /* copy_page */
   1:     NULL, /* show_page */
 314:     NULL, /* set_clip_region */
 314:     _cairo_quartz_surface_intersect_clip_path,
   1:     _cairo_quartz_surface_get_extents,
 314:     NULL, /* old_show_glyphs */
 314:     NULL, /* get_font_options */
 314:     NULL, /* flush */
 314:     NULL, /* mark_dirty_rectangle */
 314:     NULL, /* scaled_font_fini */
 314:     NULL, /* scaled_glyph_fini */
 314: 
 314:     _cairo_quartz_surface_paint,
 314:     _cairo_quartz_surface_mask,
 314:     _cairo_quartz_surface_stroke,
 314:     _cairo_quartz_surface_fill,
 314: #if CAIRO_HAS_ATSUI_FONT
 314:     _cairo_quartz_surface_show_glyphs,
 314: #else 
 314:     NULL, /* surface_show_glyphs */
 314: #endif /* CAIRO_HAS_ATSUI_FONT */
 314: 
 314:     NULL, /* snapshot */
7173:     NULL, /* is_similar */
7173:     NULL, /* reset */
7173:     NULL  /* fill_stroke */
   1: };
   1: 
 314: static cairo_quartz_surface_t *
 314: _cairo_quartz_surface_create_internal (CGContextRef cgContext,
 314: 					cairo_content_t content,
 314: 					unsigned int width,
 314: 					unsigned int height)
   1: {
   1:     cairo_quartz_surface_t *surface;
   1: 
 314:     /* Init the base surface */
   1:     surface = malloc(sizeof(cairo_quartz_surface_t));
   1:     if (surface == NULL) {
   1: 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
 314: 	return NULL;
 314:     }
 314: 
 314:     memset(surface, 0, sizeof(cairo_quartz_surface_t));
 314: 
 314:     _cairo_surface_init(&surface->base, &cairo_quartz_surface_backend,
 314: 			content);
 314: 
 314:     /* Save our extents */
 314:     surface->extents.x = surface->extents.y = 0;
 314:     surface->extents.width = width;
 314:     surface->extents.height = height;
 314: 
 314:     /* Save so we can always get back to a known-good CGContext -- this is
 314:      * required for proper behaviour of intersect_clip_path(NULL)
 314:      */
 314:     CGContextSaveGState (cgContext);
 314: 
 314:     surface->cgContext = cgContext;
 314:     surface->cgContextBaseCTM = CGContextGetCTM (cgContext);
 314: 
 314:     surface->imageData = NULL;
 314: 
 314:     return surface;
 314: }
 314: 					 
 314: /**
 314:  * cairo_quartz_surface_create_for_cg_context
 314:  * @cgContext: the existing CGContext for which to create the surface
 314:  * @width: width of the surface, in pixels
 314:  * @height: height of the surface, in pixels
 314:  *
 314:  * Creates a Quartz surface that wraps the given CGContext.  The
 314:  * CGContext is assumed to be in the QuickDraw coordinate space (that
 314:  * is, with the origin at the upper left and the Y axis increasing
 314:  * downward.)  If the CGContext is in the Quartz coordinate space (with
 314:  * the origin at the bottom left), then it should be flipped before
 314:  * this function is called:
 314:  *
 314:  * <informalexample><programlisting>
 314:  * GContextTranslateCTM (cgContext, 0.0, height);
 314:  * CGContextScaleCTM (cgContext, 1.0, -1.0);
 314:  * </programlisting></informalexample>
 314:  *
 314:  * A very small number of Cairo operations cannot be translated to
 314:  * Quartz operations; those operations will fail on this surface.
 314:  * If all Cairo operations are required to succeed, consider rendering
 314:  * to a surface created by cairo_quartz_surface_create() and then copying
 314:  * the result to the CGContext.
 314:  *
 314:  * Return value: the newly created Cairo surface.
 314:  *
 314:  * Since: 1.4
 314:  **/
 314: 
 314: cairo_surface_t *
 314: cairo_quartz_surface_create_for_cg_context (CGContextRef cgContext,
 314: 					    unsigned int width,
 314: 					    unsigned int height)
 314: {
 314:     cairo_quartz_surface_t *surf;
 314: 
 314:     CGContextRetain (cgContext);
 314: 
 314:     surf = _cairo_quartz_surface_create_internal (cgContext, CAIRO_CONTENT_COLOR_ALPHA,
 314: 						   width, height);
 314:     if (!surf) {
 314: 	CGContextRelease (cgContext);
 314: 	// create_internal will have set an error
 314: 	return (cairo_surface_t*) &_cairo_surface_nil;
 314:     }
 314: 
 314:     return (cairo_surface_t *) surf;
 314: }
 314: 
 314: /**
 314:  * cairo_quartz_surface_create
 314:  * @format: format of pixels in the surface to create
 314:  * @width: width of the surface, in pixels
 314:  * @height: height of the surface, in pixels
 314:  *
 314:  * Creates a Quartz surface backed by a CGBitmap.  The surface is
 314:  * created using the Device RGB (or Device Gray, for A8) color space.
 314:  * All Cairo operations, including those that require software
 314:  * rendering, will succeed on this surface.
 314:  *
 314:  * Return value: the newly created surface.
 314:  *
 314:  * Since: 1.4
 314:  **/
 314: cairo_surface_t *
 314: cairo_quartz_surface_create (cairo_format_t format,
 314: 			     unsigned int width,
 314: 			     unsigned int height)
 314: {
 314:     cairo_quartz_surface_t *surf;
 314:     CGContextRef cgc;
 314:     CGColorSpaceRef cgColorspace;
 314:     CGBitmapInfo bitinfo;
 314:     void *imageData;
 314:     int stride;
 314:     int bitsPerComponent;
 314: 
7123:     // verify width and height of surface
7123:     if (!verify_surface_size(width, height)) {
7123: 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
7123: 	return (cairo_surface_t*) &_cairo_surface_nil;
7123:     }
7123: 
 314:     if (format == CAIRO_FORMAT_ARGB32) {
 314: 	cgColorspace = CGColorSpaceCreateDeviceRGB();
 314: 	stride = width * 4;
 314: 	bitinfo = kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host;
 314: 	bitsPerComponent = 8;
 314:     } else if (format == CAIRO_FORMAT_RGB24) {
 314: 	cgColorspace = CGColorSpaceCreateDeviceRGB();
 314: 	stride = width * 4;
 314: 	bitinfo = kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host;
 314: 	bitsPerComponent = 8;
 314:     } else if (format == CAIRO_FORMAT_A8) {
 314: 	cgColorspace = CGColorSpaceCreateDeviceGray();
 314: 	if (width % 4 == 0)
 314: 	    stride = width;
 314: 	else
 314: 	    stride = (width & ~3) + 4;
 314: 	bitinfo = kCGImageAlphaNone;
 314: 	bitsPerComponent = 8;
 314:     } else if (format == CAIRO_FORMAT_A1) {
 314: 	/* I don't think we can usefully support this, as defined by
 314: 	 * cairo_format_t -- these are 1-bit pixels stored in 32-bit
 314: 	 * quantities.
 314: 	 */
 314: 	_cairo_error (CAIRO_STATUS_INVALID_FORMAT);
 314: 	return (cairo_surface_t*) &_cairo_surface_nil;
 314:     } else {
 314: 	_cairo_error (CAIRO_STATUS_INVALID_FORMAT);
 314: 	return (cairo_surface_t*) &_cairo_surface_nil;
 314:     }
 314: 
4133:     imageData = _cairo_malloc_ab (height, stride);
 314:     if (!imageData) {
 314: 	CGColorSpaceRelease (cgColorspace);
 314: 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
   1: 	return (cairo_surface_t*) &_cairo_surface_nil;
   1:     }
   1: 
 314:     cgc = CGBitmapContextCreate (imageData,
 314: 				 width,
 314: 				 height,
 314: 				 bitsPerComponent,
 314: 				 stride,
 314: 				 cgColorspace,
 314: 				 bitinfo);
 314:     CGColorSpaceRelease (cgColorspace);
   1: 
 314:     if (!cgc) {
 314: 	_cairo_error (CAIRO_STATUS_NO_MEMORY);
7173: 	free (imageData);
 314: 	return (cairo_surface_t*) &_cairo_surface_nil;
   1:     }
   1: 
 314:     /* flip the Y axis */
 314:     CGContextTranslateCTM (cgc, 0.0, height);
 314:     CGContextScaleCTM (cgc, 1.0, -1.0);
 314: 
 314:     surf = _cairo_quartz_surface_create_internal (cgc, _cairo_content_from_format (format),
6154: 						   width, height);
 314:     if (!surf) {
 314: 	CGContextRelease (cgc);
 314: 	// create_internal will have set an error
 314: 	return (cairo_surface_t*) &_cairo_surface_nil;
 314:     }
 314: 
 314:     surf->imageData = imageData;
 314: 
 314:     return (cairo_surface_t *) surf;
 314: }
 314: 
 314: /**
 314:  * cairo_quartz_surface_get_cg_context
 314:  * @surface: the Cairo Quartz surface
 314:  *
 314:  * Returns the CGContextRef that the given Quartz surface is backed
 314:  * by.
 314:  *
 314:  * Return value: the CGContextRef for the given surface.
 314:  *
 314:  * Since: 1.4
 314:  **/
 314: CGContextRef
 314: cairo_quartz_surface_get_cg_context (cairo_surface_t *surface)
 301: {
 314:     cairo_quartz_surface_t *quartz = (cairo_quartz_surface_t*)surface;
 314: 
 314:     if (cairo_surface_get_type(surface) != CAIRO_SURFACE_TYPE_QUARTZ)
 314: 	return NULL;
 314: 
 314:     return quartz->cgContext;
 299: }
 314: 
 314: 
 314: /* Debug stuff */
 314: 
 314: #ifdef QUARTZ_DEBUG
 314: 
 314: #include <Movies.h>
 314: 
 314: void ExportCGImageToPNGFile(CGImageRef inImageRef, char* dest)
 314: {
 314:     Handle  dataRef = NULL;
 314:     OSType  dataRefType;
 314:     CFStringRef inPath = CFStringCreateWithCString(NULL, dest, kCFStringEncodingASCII);
 314: 
 314:     GraphicsExportComponent grex = 0;
 314:     unsigned long sizeWritten;
 314: 
 314:     ComponentResult result;
 314: 
 314:     // create the data reference
 314:     result = QTNewDataReferenceFromFullPathCFString(inPath, kQTNativeDefaultPathStyle,
 314: 						    0, &dataRef, &dataRefType);
 314: 
 314:     if (NULL != dataRef && noErr == result) {
 314: 	// get the PNG exporter
 314: 	result = OpenADefaultComponent(GraphicsExporterComponentType, kQTFileTypePNG,
 314: 				       &grex);
 314: 
 314: 	if (grex) {
 314: 	    // tell the exporter where to find its source image
 314: 	    result = GraphicsExportSetInputCGImage(grex, inImageRef);
 314: 
 314: 	    if (noErr == result) {
 314: 		// tell the exporter where to save the exporter image
 314: 		result = GraphicsExportSetOutputDataReference(grex, dataRef,
 314: 							      dataRefType);
 314: 
 314: 		if (noErr == result) {
 314: 		    // write the PNG file
 314: 		    result = GraphicsExportDoExport(grex, &sizeWritten);
 314: 		}
 314: 	    }
 314: 
 314: 	    // remember to close the component
 314: 	    CloseComponent(grex);
 314: 	}
 314: 
 314: 	// remember to dispose of the data reference handle
 314: 	DisposeHandle(dataRef);
 314:     }
 314: }
 314: #endif
 314: 
 314: void
 314: quartz_image_to_png (CGImageRef imgref, char *dest)
 314: {
 314: #if 0
 314:     static int sctr = 0;
 314:     char sptr[] = "/Users/vladimir/Desktop/barXXXXX.png";
 314: 
 314:     if (dest == NULL) {
 314: 	fprintf (stderr, "** Writing %p to bar%d\n", imgref, sctr);
 314: 	sprintf (sptr, "/Users/vladimir/Desktop/bar%d.png", sctr);
 314: 	sctr++;
 314: 	dest = sptr;
 314:     }
 314: 
 314:     ExportCGImageToPNGFile(imgref, dest);
 314: #endif
 314: }
 314: 
 314: void
 314: quartz_surface_to_png (cairo_quartz_surface_t *nq, char *dest)
 314: {
 314: #if 0
 314:     static int sctr = 0;
 314:     char sptr[] = "/Users/vladimir/Desktop/fooXXXXX.png";
 314: 
 314:     if (nq->base.type != CAIRO_SURFACE_TYPE_QUARTZ) {
 314: 	fprintf (stderr, "** quartz_surface_to_png: surface %p isn't quartz!\n", nq);
 314: 	return;
 314:     }
 314: 
 314:     if (dest == NULL) {
 314: 	fprintf (stderr, "** Writing %p to foo%d\n", nq, sctr);
 314: 	sprintf (sptr, "/Users/vladimir/Desktop/foo%d.png", sctr);
 314: 	sctr++;
 314: 	dest = sptr;
 314:     }
 314: 
 314:     CGImageRef imgref = CGBitmapContextCreateImage (nq->cgContext);
 314:     if (imgref == NULL) {
 314: 	fprintf (stderr, "quartz surface at %p is not a bitmap context!\n", nq);
 314: 	return;
 314:     }
 314: 
 314:     ExportCGImageToPNGFile(imgref, dest);
 314: 
 314:     CGImageRelease(imgref);
 314: #endif
 314: }
 314: 
