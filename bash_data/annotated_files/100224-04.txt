 84549: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 99753: /* This Source Code Form is subject to the terms of the Mozilla Public
 99753:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99753:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 84549: 
 99498: #ifndef mozilla_net_SpdySession3_h
 99498: #define mozilla_net_SpdySession3_h
 84549: 
 84549: // SPDY as defined by
 99499: // http://dev.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3
 84549: 
 99497: #include "ASpdySession.h"
 84549: #include "nsClassHashtable.h"
 84549: #include "nsDataHashtable.h"
 84549: #include "nsDeque.h"
 84549: #include "nsHashKeys.h"
 84549: #include "zlib.h"
 84549: 
 84549: class nsHttpConnection;
 84549: class nsISocketTransport;
 84549: 
 84549: namespace mozilla { namespace net {
 84549: 
 99498: class SpdyStream3;
 84549: 
 99498: class SpdySession3 : public ASpdySession
 84549:                    , public nsAHttpConnection
 84549:                    , public nsAHttpSegmentReader
 84549:                    , public nsAHttpSegmentWriter
 84549: {
 84549: public:
 84549:   NS_DECL_ISUPPORTS
 84549:   NS_DECL_NSAHTTPTRANSACTION
 98400:   NS_DECL_NSAHTTPCONNECTION(mConnection)
 84549:   NS_DECL_NSAHTTPSEGMENTREADER
 84549:   NS_DECL_NSAHTTPSEGMENTWRITER
 84549: 
 99498:   SpdySession3(nsAHttpTransaction *, nsISocketTransport *, PRInt32);
 99498:   ~SpdySession3();
 84549: 
 84549:   bool AddStream(nsAHttpTransaction *, PRInt32);
 84549:   bool CanReuse() { return !mShouldGoAway && !mClosed; }
 84549:   bool RoomForMoreStreams();
 90871: 
 93844:   // When the connection is active this is called every 1 second
 90871:   void ReadTimeoutTick(PRIntervalTime now);
 90871:   
 90872:   // Idle time represents time since "goodput".. e.g. a data or header frame
 90872:   PRIntervalTime IdleTime();
 90872: 
 99498:   PRUint32 RegisterStreamID(SpdyStream3 *);
 84549: 
 99499:   const static PRUint8 kVersion        = 3;
 99499: 
 84549:   const static PRUint8 kFlag_Control   = 0x80;
 84549: 
 84549:   const static PRUint8 kFlag_Data_FIN  = 0x01;
 84549:   const static PRUint8 kFlag_Data_UNI  = 0x02;
 84549:   
 84549:   enum
 84549:   {
 84549:     CONTROL_TYPE_FIRST = 0,
 84549:     CONTROL_TYPE_SYN_STREAM = 1,
 84549:     CONTROL_TYPE_SYN_REPLY = 2,
 84549:     CONTROL_TYPE_RST_STREAM = 3,
 84549:     CONTROL_TYPE_SETTINGS = 4,
 99499:     CONTROL_TYPE_NOOP = 5,                        /* deprecated */
 84549:     CONTROL_TYPE_PING = 6,
 84549:     CONTROL_TYPE_GOAWAY = 7,
 84549:     CONTROL_TYPE_HEADERS = 8,
 99499:     CONTROL_TYPE_WINDOW_UPDATE = 9,
 99499:     CONTROL_TYPE_CREDENTIAL = 10,
 99499:     CONTROL_TYPE_LAST = 11
 84549:   };
 84549: 
 90452:   enum rstReason
 84549:   {
 84549:     RST_PROTOCOL_ERROR = 1,
 84549:     RST_INVALID_STREAM = 2,
 84549:     RST_REFUSED_STREAM = 3,
 84549:     RST_UNSUPPORTED_VERSION = 4,
 84549:     RST_CANCEL = 5,
 84549:     RST_INTERNAL_ERROR = 6,
 84549:     RST_FLOW_CONTROL_ERROR = 7,
 99499:     RST_STREAM_IN_USE = 8,
 99499:     RST_STREAM_ALREADY_CLOSED = 9,
 99499:     RST_INVALID_CREDENTIALS = 10,
 99499:     RST_FRAME_TOO_LARGE = 11
 84549:   };
 84549: 
 84549:   enum
 84549:   {
 84549:     SETTINGS_TYPE_UPLOAD_BW = 1, // kb/s
 84549:     SETTINGS_TYPE_DOWNLOAD_BW = 2, // kb/s
 84549:     SETTINGS_TYPE_RTT = 3, // ms
 84549:     SETTINGS_TYPE_MAX_CONCURRENT = 4, // streams
 84549:     SETTINGS_TYPE_CWND = 5, // packets
 84549:     SETTINGS_TYPE_DOWNLOAD_RETRANS_RATE = 6, // percentage
 99499:     SETTINGS_TYPE_INITIAL_WINDOW = 7,  // bytes
 99499:     SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE = 8
 84549:   };
 84549: 
 84549:   // This should be big enough to hold all of your control packets,
 84549:   // but if it needs to grow for huge headers it can do so dynamically.
 84549:   // About 1% of requests to SPDY google services seem to be > 1000
 84549:   // with all less than 2000.
 88247:   const static PRUint32 kDefaultBufferSize = 2048;
 84549: 
 88247:   // kDefaultQueueSize must be >= other queue size constants
 88247:   const static PRUint32 kDefaultQueueSize =  16384;
 88247:   const static PRUint32 kQueueMinimumCleanup = 8192;
 88247:   const static PRUint32 kQueueTailRoom    =  4096;
 88247:   const static PRUint32 kQueueReserved    =  1024;
 88247: 
 84549:   const static PRUint32 kDefaultMaxConcurrent = 100;
 84549:   const static PRUint32 kMaxStreamID = 0x7800000;
 84549: 
 98989:   // This is a sentinel for a deleted stream. It is not a valid
 98989:   // 31 bit stream ID.
 98989:   const static PRUint32 kDeadStreamID = 0xffffdead;
 98989: 
 99499:   // until we have an API that can push back on receiving data (right now
 99499:   // WriteSegments is obligated to accept data and buffer) there is no
 99499:   // reason to throttle with the rwin other than in server push
 99499:   // scenarios.
 99499:   const static PRUint32 kInitialRwin = 256 * 1024 * 1024;
 99499:   const static PRUint32 kMinimumToAck = 64 * 1024;
 99499: 
 99499:   // The default peer rwin is 64KB unless updated by a settings frame
 99499:   const static PRUint32 kDefaultServerRwin = 64 * 1024;
 99499: 
 99498:   static nsresult HandleSynStream(SpdySession3 *);
 99498:   static nsresult HandleSynReply(SpdySession3 *);
 99498:   static nsresult HandleRstStream(SpdySession3 *);
 99498:   static nsresult HandleSettings(SpdySession3 *);
 99498:   static nsresult HandleNoop(SpdySession3 *);
 99498:   static nsresult HandlePing(SpdySession3 *);
 99498:   static nsresult HandleGoAway(SpdySession3 *);
 99498:   static nsresult HandleHeaders(SpdySession3 *);
 99498:   static nsresult HandleWindowUpdate(SpdySession3 *);
 84549: 
 84549:   static void EnsureBuffer(nsAutoArrayPtr<char> &,
 84549:                            PRUint32, PRUint32, PRUint32 &);
 84549: 
 84549:   // For writing the SPDY data stream to LOG4
 99498:   static void LogIO(SpdySession3 *, SpdyStream3 *, const char *,
 84549:                     const char *, PRUint32);
 84549: 
 88247:   // an overload of nsAHttpConnection
 88247:   void TransactionHasDataToWrite(nsAHttpTransaction *);
 88247: 
 99498:   // a similar version for SpdyStream3
 99498:   void TransactionHasDataToWrite(SpdyStream3 *);
 88248: 
 88248:   // an overload of nsAHttpSegementReader
 88248:   virtual nsresult CommitToSegmentSize(PRUint32 size);
 88248:   
 99499:   PRUint32 GetServerInitialWindow() { return mServerInitialWindow; }
 99499: 
 84549: private:
 84549: 
 84549:   enum stateType {
 84549:     BUFFERING_FRAME_HEADER,
 84549:     BUFFERING_CONTROL_FRAME,
 84549:     PROCESSING_DATA_FRAME,
 88247:     DISCARDING_DATA_FRAME,
 99499:     PROCESSING_COMPLETE_HEADERS,
 84549:     PROCESSING_CONTROL_RST_STREAM
 84549:   };
 84549: 
 91115:   void        DeterminePingThreshold();
 99499:   nsresult    ResponseHeadersComplete();
 88247:   PRUint32    GetWriteQueueSize();
 84549:   void        ChangeDownstreamState(enum stateType);
 88247:   void        ResetDownstreamState();
 99499:   nsresult    UncompressAndDiscard(PRUint32, PRUint32);
 84549:   void        zlibInit();
 84549:   void        GeneratePing(PRUint32);
 91115:   void        ClearPing(bool);
 84549:   void        GenerateRstStream(PRUint32, PRUint32);
 84549:   void        GenerateGoAway();
 99498:   void        CleanupStream(SpdyStream3 *, nsresult, rstReason);
100224:   void        CloseStream(SpdyStream3 *, nsresult);
 99499:   void        GenerateSettings();
 84549: 
 88247:   void        SetWriteCallbacks();
 84549:   void        FlushOutputQueue();
 84549: 
 84549:   bool        RoomForMoreConcurrent();
 99498:   void        ActivateStream(SpdyStream3 *);
 84549:   void        ProcessPending();
 98989:   nsresult    SetInputFrameDataStream(PRUint32);
 99498:   bool        VerifyStream(SpdyStream3 *, PRUint32);
 99496:   void        SetNeedsCleanup();
 84549: 
 99499:   void        UpdateLocalRwin(SpdyStream3 *stream, PRUint32 bytes);
 99499: 
 90872:   // a wrapper for all calls to the nshttpconnection level segment writer. Used
 90872:   // to track network I/O for timeout purposes
 90872:   nsresult   NetworkRead(nsAHttpSegmentWriter *, char *, PRUint32, PRUint32 *);
 90872:   
 88247:   static PLDHashOperator ShutdownEnumerator(nsAHttpTransaction *,
 99498:                                             nsAutoPtr<SpdyStream3> &,
 84549:                                             void *);
 84549: 
 99499:   static PLDHashOperator UpdateServerRwinEnumerator(nsAHttpTransaction *,
 99499:                                                     nsAutoPtr<SpdyStream3> &,
 99499:                                                     void *);
 99499: 
 84549:   // This is intended to be nsHttpConnectionMgr:nsHttpConnectionHandle taken
 86570:   // from the first transaction on this session. That object contains the
 84549:   // pointer to the real network-level nsHttpConnection object.
 84549:   nsRefPtr<nsAHttpConnection> mConnection;
 84549: 
 84549:   // The underlying socket transport object is needed to propogate some events
 84549:   nsISocketTransport         *mSocketTransport;
 84549: 
 84549:   // These are temporary state variables to hold the argument to
 84549:   // Read/WriteSegments so it can be accessed by On(read/write)segment
 84549:   // further up the stack.
 84549:   nsAHttpSegmentReader       *mSegmentReader;
 84549:   nsAHttpSegmentWriter       *mSegmentWriter;
 84549: 
 86570:   PRUint32          mSendingChunkSize;        /* the transmission chunk size */
 84549:   PRUint32          mNextStreamID;            /* 24 bits */
 84549:   PRUint32          mConcurrentHighWater;     /* max parallelism on session */
 84549: 
 84549:   stateType         mDownstreamState; /* in frame, between frames, etc..  */
 84549: 
 99499:   // Maintain 4 indexes - one by stream ID, one by transaction ptr,
 84549:   // one list of streams ready to write, one list of streams that are queued
 99499:   // due to max parallelism settings. The objects
 86570:   // are not ref counted - they get destroyed
 84549:   // by the nsClassHashtable implementation when they are removed from
 99499:   // the transaction hash.
 99498:   nsDataHashtable<nsUint32HashKey, SpdyStream3 *>     mStreamIDHash;
 84549:   nsClassHashtable<nsPtrHashKey<nsAHttpTransaction>,
 99498:                    SpdyStream3>                       mStreamTransactionHash;
 84549:   nsDeque                                             mReadyForWrite;
 84549:   nsDeque                                             mQueuedStreams;
 84549: 
 84549:   // Compression contexts for header transport using deflate.
 84549:   // SPDY compresses only HTTP headers and does not reset zlib in between
 99499:   // frames. Even data that is not associated with a stream (e.g invalid
 99499:   // stream ID) is passed through these contexts to keep the compression
 99499:   // context correct.
 84549:   z_stream            mDownstreamZlib;
 84549:   z_stream            mUpstreamZlib;
 84549: 
 88247:   // mInputFrameBuffer is used to store received control packets and the 8 bytes
 84549:   // of header on data packets
 88247:   PRUint32             mInputFrameBufferSize;
 88247:   PRUint32             mInputFrameBufferUsed;
 88247:   nsAutoArrayPtr<char> mInputFrameBuffer;
 84549:   
 88247:   // mInputFrameDataSize/Read are used for tracking the amount of data consumed
 84549:   // in a data frame. the data itself is not buffered in spdy
 88247:   // The frame size is mInputFrameDataSize + the constant 8 byte header
 88247:   PRUint32             mInputFrameDataSize;
 88247:   PRUint32             mInputFrameDataRead;
 88247:   bool                 mInputFrameDataLast; // This frame was marked FIN
 84549: 
 84549:   // When a frame has been received that is addressed to a particular stream
 84549:   // (e.g. a data frame after the stream-id has been decoded), this points
 84549:   // to the stream.
 99498:   SpdyStream3          *mInputFrameDataStream;
 84549:   
 88247:   // mNeedsCleanup is a state variable to defer cleanup of a closed stream
 88247:   // If needed, It is set in session::OnWriteSegments() and acted on and
 88247:   // cleared when the stack returns to session::WriteSegments(). The stream
 88247:   // cannot be destroyed directly out of OnWriteSegments because
 88247:   // stream::writeSegments() is on the stack at that time.
 99498:   SpdyStream3          *mNeedsCleanup;
 84549: 
 84549:   // The CONTROL_TYPE value for a control frame
 84549:   PRUint32             mFrameControlType;
 84549: 
 84549:   // This reason code in the last processed RESET frame
 84549:   PRUint32             mDownstreamRstReason;
 84549: 
 84549:   // for the conversion of downstream http headers into spdy formatted headers
 99499:   // The data here does not persist between frames
 84549:   nsCString            mFlatHTTPResponseHeaders;
 84549:   PRUint32             mFlatHTTPResponseHeadersOut;
 84549: 
 88247:   // when set, the session will go away when it reaches 0 streams. This flag
 88247:   // is set when: the stream IDs are running out (at either the client or the
 88247:   // server), when DontReuse() is called, a RST that is not specific to a
 88247:   // particular stream is received, a GOAWAY frame has been received from
 88247:   // the server.
 84549:   bool                 mShouldGoAway;
 84549: 
 84549:   // the session has received a nsAHttpTransaction::Close()  call
 84549:   bool                 mClosed;
 84549: 
 84549:   // the session received a GoAway frame with a valid GoAwayID
 84549:   bool                 mCleanShutdown;
 84549: 
 99499:   // indicates PROCESSING_COMPLETE_HEADERS state was pushed onto the stack
 99499:   // over an active PROCESSING_DATA_FRAME, which should be restored when
 99499:   // the processed headers are written to the stream
 99499:   bool                 mDataPending;
 99499: 
 84549:   // If a GoAway message was received this is the ID of the last valid
 84549:   // stream. 0 otherwise. (0 is never a valid stream id.)
 84549:   PRUint32             mGoAwayID;
 84549: 
 84549:   // The limit on number of concurrent streams for this session. Normally it
 84549:   // is basically unlimited, but the SETTINGS control message from the
 84549:   // server might bring it down.
 84549:   PRUint32             mMaxConcurrent;
 84549: 
 84549:   // The actual number of concurrent streams at this moment. Generally below
 84549:   // mMaxConcurrent, but the max can be lowered in real time to a value
 84549:   // below the current value
 84549:   PRUint32             mConcurrent;
 84549: 
 84549:   // The number of server initiated SYN-STREAMS, tracked for telemetry
 84549:   PRUint32             mServerPushedResources;
 84549: 
 99499:   // The server rwin for new streams as determined from a SETTINGS frame
 99499:   PRUint32             mServerInitialWindow;
 99499: 
 84549:   // This is a output queue of bytes ready to be written to the SSL stream.
 84549:   // When that streams returns WOULD_BLOCK on direct write the bytes get
 84549:   // coalesced together here. This results in larger writes to the SSL layer.
 84549:   // The buffer is not dynamically grown to accomodate stream writes, but
 84549:   // does expand to accept infallible session wide frames like GoAway and RST.
 84549:   PRUint32             mOutputQueueSize;
 84549:   PRUint32             mOutputQueueUsed;
 84549:   PRUint32             mOutputQueueSent;
 84549:   nsAutoArrayPtr<char> mOutputQueueBuffer;
 90872: 
 91115:   PRIntervalTime       mPingThreshold;
 90872:   PRIntervalTime       mLastReadEpoch;     // used for ping timeouts
 90872:   PRIntervalTime       mLastDataReadEpoch; // used for IdleTime()
 90872:   PRIntervalTime       mPingSentEpoch;
 90872:   PRUint32             mNextPingID;
 91115:   bool                 mPingThresholdExperiment;
 84549: };
 84549: 
 84549: }} // namespace mozilla::net
 84549: 
 99498: #endif // mozilla_net_SpdySession3_h
