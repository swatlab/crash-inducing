52217: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
52217: /* ***** BEGIN LICENSE BLOCK *****
52217:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52217:  *
52217:  * The contents of this file are subject to the Mozilla Public License Version
52217:  * 1.1 (the "License"); you may not use this file except in compliance with
52217:  * the License. You may obtain a copy of the License at
52217:  * http://www.mozilla.org/MPL/
52217:  *
52217:  * Software distributed under the License is distributed on an "AS IS" basis,
52217:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52217:  * for the specific language governing rights and limitations under the
52217:  * License.
52217:  *
52217:  * The Original Code is mozilla.org code.
52217:  *
52217:  * The Initial Developer of the Original Code is
52217:  * the Mozilla Foundation.
52217:  * Portions created by the Initial Developer are Copyright (C) 2010
52217:  * the Initial Developer. All Rights Reserved.
52217:  *
52217:  * Contributor(s):
52217:  *   Daniel Holbert <dholbert@mozilla.com>
52217:  *
52217:  * Alternatively, the contents of this file may be used under the terms of
52217:  * either the GNU General Public License Version 2 or later (the "GPL"), or
52217:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52217:  * in which case the provisions of the GPL or the LGPL are applicable instead
52217:  * of those above. If you wish to allow use of your version of this file only
52217:  * under the terms of either the GPL or the LGPL, and not to allow others to
52217:  * use your version of this file under the terms of the MPL, indicate your
52217:  * decision by deleting the provisions above and replace them with the notice
52217:  * and other provisions required by the GPL or the LGPL. If you do not delete
52217:  * the provisions above, a recipient may use your version of this file under
52217:  * the terms of any one of the MPL, the GPL or the LGPL.
52217:  *
52217:  * ***** END LICENSE BLOCK ***** */
52217: 
52217: #include "SVGDocumentWrapper.h"
52217: #include "mozilla/dom/Element.h"
52217: #include "nsIAtom.h"
52217: #include "nsICategoryManager.h"
52217: #include "nsIChannel.h"
52217: #include "nsIDocument.h"
52217: #include "nsIDocumentLoaderFactory.h"
52217: #include "nsIDocumentViewer.h"
52217: #include "nsIDOMSVGAnimatedLength.h"
52217: #include "nsIDOMSVGLength.h"
52217: #include "nsIHttpChannel.h"
52217: #include "nsIObserverService.h"
52217: #include "nsIParser.h"
52217: #include "nsIPresShell.h"
52217: #include "nsIRequest.h"
52217: #include "nsIStreamListener.h"
52217: #include "nsIXMLContentSink.h"
52217: #include "nsNetCID.h"
52217: #include "nsComponentManagerUtils.h"
52217: #include "nsServiceManagerUtils.h"
52217: #include "nsSize.h"
52217: #include "gfxRect.h"
52217: #include "nsSVGSVGElement.h"
52217: #include "nsSVGLength2.h"
57609: #include "nsSVGEffects.h"
52217: 
52217: using namespace mozilla::dom;
52217: 
52217: namespace mozilla {
52217: namespace imagelib {
52217: 
52217: nsIAtom* SVGDocumentWrapper::kSVGAtom = nsnull; // lazily initialized
52217: 
57115: NS_IMPL_ISUPPORTS4(SVGDocumentWrapper,
52217:                    nsIStreamListener,
52217:                    nsIRequestObserver,
57115:                    nsIObserver,
57115:                    nsISupportsWeakReference)
52217: 
52217: SVGDocumentWrapper::SVGDocumentWrapper()
57115:   : mIgnoreInvalidation(PR_FALSE),
57115:     mRegisteredForXPCOMShutdown(PR_FALSE)
52217: {
52217:   // Lazy-initialize our "svg" atom.  (It'd be nicer to just use nsGkAtoms::svg
52217:   // directly, but we can't access it from here in non-libxul builds.)
52217:   if (!SVGDocumentWrapper::kSVGAtom) {
52217:     SVGDocumentWrapper::kSVGAtom =
52217:       NS_NewPermanentAtom(NS_LITERAL_STRING("svg"));
52217:   }
52217: }
52217: 
52217: SVGDocumentWrapper::~SVGDocumentWrapper()
52217: {
52217:   DestroyViewer();
57115:   if (mRegisteredForXPCOMShutdown) {
57115:     UnregisterForXPCOMShutdown();
57115:   }
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::DestroyViewer()
52217: {
52217:   if (mViewer) {
52217:     mViewer->GetDocument()->OnPageHide(PR_FALSE, nsnull);
52217:     mViewer->Close(nsnull);
52217:     mViewer->Destroy();
52217:     mViewer = nsnull;
52217:   }
52217: }
52217: 
52217: PRBool
52217: SVGDocumentWrapper::GetWidthOrHeight(Dimension aDimension,
52217:                                      PRInt32& aResult)
52217: {
52217:   nsSVGSVGElement* rootElem = GetRootSVGElem();
52217:   NS_ABORT_IF_FALSE(rootElem, "root elem missing or of wrong type");
52217:   nsresult rv;
52217: 
52217:   // Get the width or height SVG object
52217:   nsRefPtr<nsIDOMSVGAnimatedLength> domAnimLength;
52217:   if (aDimension == eWidth) {
52217:     rv = rootElem->GetWidth(getter_AddRefs(domAnimLength));
52217:   } else {
52217:     NS_ABORT_IF_FALSE(aDimension == eHeight, "invalid dimension");
52217:     rv = rootElem->GetHeight(getter_AddRefs(domAnimLength));
52217:   }
52217:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
52217:   NS_ENSURE_TRUE(domAnimLength, PR_FALSE);
52217: 
52217:   // Get the animated value from the object
52217:   nsRefPtr<nsIDOMSVGLength> domLength;
52217:   rv = domAnimLength->GetAnimVal(getter_AddRefs(domLength));
52217:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
52217:   NS_ENSURE_TRUE(domLength, PR_FALSE);
52217: 
52217:   // Check if it's a percent value (and fail if so)
52217:   PRUint16 unitType;
52217:   rv = domLength->GetUnitType(&unitType);
52217:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
52217:   if (unitType == nsIDOMSVGLength::SVG_LENGTHTYPE_PERCENTAGE) {
52217:     return PR_FALSE;
52217:   }
52217: 
52217:   // Non-percent value - woot! Grab it & return it.
52217:   float floatLength;
52217:   rv = domLength->GetValue(&floatLength);
52217:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
52217: 
52217:   aResult = nsSVGUtils::ClampToInt(floatLength);
52217: 
52217:   return PR_TRUE;
52217: }
52217: 
52217: nsIFrame*
52217: SVGDocumentWrapper::GetRootLayoutFrame()
52217: {
52217:   Element* rootElem = GetRootSVGElem();
52217:   return rootElem ? rootElem->GetPrimaryFrame() : nsnull;
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::UpdateViewportBounds(const nsIntSize& aViewportSize)
52217: {
52222:   NS_ABORT_IF_FALSE(!mIgnoreInvalidation, "shouldn't be reentrant");
52222:   mIgnoreInvalidation = PR_TRUE;
52217:   mViewer->SetBounds(nsIntRect(nsIntPoint(0, 0), aViewportSize));
52217:   FlushLayout();
52222:   mIgnoreInvalidation = PR_FALSE;
52217: }
52217: 
59474: void
59474: SVGDocumentWrapper::FlushPreserveAspectRatioOverride()
59474: {
59474:   NS_ABORT_IF_FALSE(!mIgnoreInvalidation, "shouldn't be reentrant");
59474: 
59474:   nsSVGSVGElement* svgElem = GetRootSVGElem();
59474:   if (!svgElem)
59474:     return;
59474: 
59474:   mIgnoreInvalidation = PR_TRUE;
59474:   svgElem->FlushPreserveAspectRatioOverride();
59474:   FlushLayout();
59474:   mIgnoreInvalidation = PR_FALSE;
59474: }
59474: 
52217: PRBool
52217: SVGDocumentWrapper::IsAnimated()
52217: {
52360: #ifdef MOZ_SMIL
52217:   nsIDocument* doc = mViewer->GetDocument();
52217:   return doc && doc->HasAnimationController() &&
52217:     doc->GetAnimationController()->HasRegisteredAnimations();
52360: #else
52360:   return PR_FALSE;
52360: #endif // MOZ_SMIL
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::StartAnimation()
52217: {
59518:   // Can be called for animated images during shutdown, after we've
59518:   // already Observe()'d XPCOM shutdown and cleared out our mViewer pointer.
59518:   if (!mViewer)
59518:     return;
59518: 
57023:   nsIDocument* doc = mViewer->GetDocument();
57023:   if (doc) {
57098: #ifdef MOZ_SMIL
60275:     nsSMILAnimationController* controller = doc->GetAnimationController();
60275:     if (controller) {
60275:       controller->Resume(nsSMILTimeContainer::PAUSE_IMAGE);
60275:     }
57098: #endif // MOZ_SMIL
57023:     doc->SetImagesNeedAnimating(PR_TRUE);
57023:   }
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::StopAnimation()
52217: {
59518:   // Can be called for animated images during shutdown, after we've
52217:   // already Observe()'d XPCOM shutdown and cleared out our mViewer pointer.
52217:   if (!mViewer)
52217:     return;
52217: 
57023:   nsIDocument* doc = mViewer->GetDocument();
57023:   if (doc) {
57098: #ifdef MOZ_SMIL
60275:     nsSMILAnimationController* controller = doc->GetAnimationController();
60275:     if (controller) {
60275:       controller->Pause(nsSMILTimeContainer::PAUSE_IMAGE);
60275:     }
57098: #endif // MOZ_SMIL
57023:     doc->SetImagesNeedAnimating(PR_FALSE);
57023:   }
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::ResetAnimation()
52217: {
52217:   nsSVGSVGElement* svgElem = GetRootSVGElem();
52217:   if (!svgElem)
52217:     return;
52217: 
52217: #ifdef DEBUG
52217:   nsresult rv = 
52217: #endif
52217:     svgElem->SetCurrentTime(0.0f);
52217:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "SetCurrentTime failed");
52217: }
52217: 
52217: 
52217: /** nsIStreamListener methods **/
52217: 
52217: /* void onDataAvailable (in nsIRequest request, in nsISupports ctxt,
52217:                          in nsIInputStream inStr, in unsigned long sourceOffset,
52217:                          in unsigned long count); */
52217: NS_IMETHODIMP
52217: SVGDocumentWrapper::OnDataAvailable(nsIRequest* aRequest, nsISupports* ctxt,
52217:                                     nsIInputStream* inStr,
52217:                                     PRUint32 sourceOffset,
52217:                                     PRUint32 count)
52217: {
52217:   return mListener->OnDataAvailable(aRequest, ctxt, inStr,
52217:                                     sourceOffset, count);
52217: }
52217: 
52217: /** nsIRequestObserver methods **/
52217: 
52217: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
52217: NS_IMETHODIMP
52217: SVGDocumentWrapper::OnStartRequest(nsIRequest* aRequest, nsISupports* ctxt)
52217: {
52217:   nsresult rv = SetupViewer(aRequest,
52217:                             getter_AddRefs(mViewer),
52217:                             getter_AddRefs(mLoadGroup));
52217: 
52217:   if (NS_SUCCEEDED(rv) &&
52217:       NS_SUCCEEDED(mListener->OnStartRequest(aRequest, nsnull))) {
52217:     mViewer->GetDocument()->SetIsBeingUsedAsImage();
57587:     StopAnimation(); // otherwise animations start automatically in helper doc
57587: 
52217:     rv = mViewer->Init(nsnull, nsIntRect(0, 0, 0, 0));
52217:     if (NS_SUCCEEDED(rv)) {
52217:       rv = mViewer->Open(nsnull, nsnull);
52217:     }
52217:   }
52217:   return rv;
52217: }
52217: 
52217: 
52217: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt,
52217:                        in nsresult status); */
52217: NS_IMETHODIMP
52217: SVGDocumentWrapper::OnStopRequest(nsIRequest* aRequest, nsISupports* ctxt,
52217:                                   nsresult status)
52217: {
52217:   if (mListener) {
54654:     mListener->OnStopRequest(aRequest, ctxt, status);
52217:     // A few levels up the stack, imgRequest::OnStopRequest is about to tell
52217:     // all of its observers that we know our size and are ready to paint.  That
52217:     // might not be true at this point, though -- so here, we synchronously
52217:     // finish parsing & layout in our helper-document to make sure we can hold
52217:     // up to this promise.
52217:     nsCOMPtr<nsIParser> parser = do_QueryInterface(mListener);
54654:     if (!parser->IsComplete()) {
52217:       parser->ContinueInterruptedParsing();
54654:     }
52217:     FlushLayout();
52217:     mListener = nsnull;
52217: 
52217:     // In a normal document, this would be called by nsDocShell - but we don't
52217:     // have a nsDocShell. So we do it ourselves. (If we don't, painting will
52217:     // stay suppressed for a little while longer, for no good reason).
52217:     mViewer->LoadComplete(NS_OK);
52217:   }
52217: 
52217:   return NS_OK;
52217: }
52217: 
52217: /** nsIObserver Methods **/
52217: NS_IMETHODIMP
52217: SVGDocumentWrapper::Observe(nsISupports* aSubject,
52217:                             const char* aTopic,
52217:                             const PRUnichar *aData)
52217: {
52217:   if (!strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
57609:     // Sever ties from rendering observers to helper-doc's root SVG node
57609:     nsSVGSVGElement* svgElem = GetRootSVGElem();
57609:     if (svgElem) {
57610: #ifdef MOZ_ENABLE_LIBXUL
57609:       nsSVGEffects::RemoveAllRenderingObservers(svgElem);
57610: #else
57610:       // XXXdholbert Can't call static nsSVGEffects functions from imagelib in
57610:       // non-libxul builds -- so, this is a hack using a virtual function to
57610:       // have the SVG element call the method on our behalf.
57610:       svgElem->RemoveAllRenderingObservers();
57610: #endif // MOZ_ENABLE_LIBXUL
57609:     }
57609: 
52217:     // Clean up at XPCOM shutdown time.
52217:     DestroyViewer();
52217:     if (mListener)
52217:       mListener = nsnull;
52217:     if (mLoadGroup)
52217:       mLoadGroup = nsnull;
57188: 
57188:     // Turn off "registered" flag, or else we'll try to unregister when we die.
57188:     // (No need for that now, and the try would fail anyway -- it's too late.)
57188:     mRegisteredForXPCOMShutdown = PR_FALSE;
52217:   } else {
52217:     NS_ERROR("Unexpected observer topic.");
52217:   }
52217:   return NS_OK;
52217: }
52217: 
52217: /** Private helper methods **/
52217: 
52217: // This method is largely cribbed from
52217: // nsExternalResourceMap::PendingLoad::SetupViewer.
52217: nsresult
52217: SVGDocumentWrapper::SetupViewer(nsIRequest* aRequest,
52217:                                 nsIDocumentViewer** aViewer,
52217:                                 nsILoadGroup** aLoadGroup)
52217: {
52217:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
52217:   NS_ENSURE_TRUE(chan, NS_ERROR_UNEXPECTED);
52217: 
52217:   // Check for HTTP error page
52217:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
52217:   if (httpChannel) {
52217:     PRBool requestSucceeded;
52217:     if (NS_FAILED(httpChannel->GetRequestSucceeded(&requestSucceeded)) ||
52217:         !requestSucceeded) {
52217:       return NS_ERROR_FAILURE;
52217:     }
52217:   }
52217: 
52217:   // Give this document its own loadgroup
52217:   nsCOMPtr<nsILoadGroup> loadGroup;
52217:   chan->GetLoadGroup(getter_AddRefs(loadGroup));
52217: 
52217:   nsCOMPtr<nsILoadGroup> newLoadGroup =
52217:         do_CreateInstance(NS_LOADGROUP_CONTRACTID);
52217:   NS_ENSURE_TRUE(newLoadGroup, NS_ERROR_OUT_OF_MEMORY);
52217:   newLoadGroup->SetLoadGroup(loadGroup);
52217: 
52217:   nsCOMPtr<nsICategoryManager> catMan =
52217:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
52217:   NS_ENSURE_TRUE(catMan, NS_ERROR_NOT_AVAILABLE);
52217:   nsXPIDLCString contractId;
52217:   nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", SVG_MIMETYPE,
52217:                                          getter_Copies(contractId));
52217:   NS_ENSURE_SUCCESS(rv, rv);
52217:   nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory =
52217:     do_GetService(contractId);
52217:   NS_ENSURE_TRUE(docLoaderFactory, NS_ERROR_NOT_AVAILABLE);
52217: 
52217:   nsCOMPtr<nsIContentViewer> viewer;
52217:   nsCOMPtr<nsIStreamListener> listener;
52217:   rv = docLoaderFactory->CreateInstance("external-resource", chan,
52217:                                         newLoadGroup,
52217:                                         SVG_MIMETYPE, nsnull, nsnull,
52217:                                         getter_AddRefs(listener),
52217:                                         getter_AddRefs(viewer));
52217:   NS_ENSURE_SUCCESS(rv, rv);
52217: 
52217:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(viewer);
52217:   NS_ENSURE_TRUE(docViewer, NS_ERROR_UNEXPECTED);
52217: 
52217:   nsCOMPtr<nsIParser> parser = do_QueryInterface(listener);
52217:   NS_ENSURE_TRUE(parser, NS_ERROR_UNEXPECTED);
52217: 
52217:   // XML-only, because this is for SVG content
52217:   nsIContentSink* sink = parser->GetContentSink();
52217:   nsCOMPtr<nsIXMLContentSink> xmlSink = do_QueryInterface(sink);
52217:   NS_ENSURE_TRUE(sink, NS_ERROR_UNEXPECTED);
52217: 
52217:   listener.swap(mListener);
52217:   docViewer.swap(*aViewer);
52217:   newLoadGroup.swap(*aLoadGroup);
52217: 
52217:   RegisterForXPCOMShutdown();
52217:   return NS_OK;
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::RegisterForXPCOMShutdown()
52217: {
57115:   NS_ABORT_IF_FALSE(!mRegisteredForXPCOMShutdown,
57115:                     "re-registering for XPCOM shutdown");
52217:   // Listen for xpcom-shutdown so that we can drop references to our
52217:   // helper-document at that point. (Otherwise, we won't get cleaned up
52217:   // until imgLoader::Shutdown, which can happen after the JAR service
52217:   // and RDF service have been unregistered.)
52217:   nsresult rv;
52217:   nsCOMPtr<nsIObserverService> obsSvc = do_GetService(OBSERVER_SVC_CID, &rv);
52217:   if (NS_FAILED(rv) ||
52217:       NS_FAILED(obsSvc->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID,
57115:                                     PR_TRUE))) {
52217:     NS_WARNING("Failed to register as observer of XPCOM shutdown");
57115:   } else {
57115:     mRegisteredForXPCOMShutdown = PR_TRUE;
57115:   }
57115: }
57115: 
57115: void
57115: SVGDocumentWrapper::UnregisterForXPCOMShutdown()
57115: {
57115:   NS_ABORT_IF_FALSE(mRegisteredForXPCOMShutdown,
57115:                     "unregistering for XPCOM shutdown w/out being registered");
57115: 
57115:   nsresult rv;
57115:   nsCOMPtr<nsIObserverService> obsSvc = do_GetService(OBSERVER_SVC_CID, &rv);
57115:   if (NS_FAILED(rv) ||
57115:       NS_FAILED(obsSvc->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID))) {
57115:     NS_WARNING("Failed to unregister as observer of XPCOM shutdown");
57115:   } else {
57115:     mRegisteredForXPCOMShutdown = PR_FALSE;
52217:   }
52217: }
52217: 
52217: void
52217: SVGDocumentWrapper::FlushLayout()
52217: {
52217:   nsCOMPtr<nsIPresShell> presShell;
52217:   mViewer->GetPresShell(getter_AddRefs(presShell));
52217:   if (presShell) {
52217:     presShell->FlushPendingNotifications(Flush_Layout);
52217:   }
52217: }
52217: 
52217: nsSVGSVGElement*
52217: SVGDocumentWrapper::GetRootSVGElem()
52217: {
52222:   if (!mViewer)
52222:     return nsnull; // Can happen during destruction
52222: 
52222:   nsIDocument* doc = mViewer->GetDocument();
52222:   if (!doc)
52222:     return nsnull; // Can happen during destruction
52222: 
52217:   Element* rootElem = mViewer->GetDocument()->GetRootElement();
52217:   if (!rootElem ||
52217:       rootElem->GetNameSpaceID() != kNameSpaceID_SVG ||
52217:       rootElem->Tag() != SVGDocumentWrapper::kSVGAtom) {
52217:     return nsnull;
52217:   }
52217: 
52217:   return static_cast<nsSVGSVGElement*>(rootElem);
52217: }
52217: 
52217: } // namespace imagelib
52217: } // namespace mozilla
