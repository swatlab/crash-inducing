12041: #
12041: # ***** BEGIN LICENSE BLOCK *****
12041: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
12041: #
12041: # The contents of this file are subject to the Mozilla Public License Version
12041: # 1.1 (the "License"); you may not use this file except in compliance with
12041: # the License. You may obtain a copy of the License at
12041: # http://www.mozilla.org/MPL/
12041: #
12041: # Software distributed under the License is distributed on an "AS IS" basis,
12041: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
12041: # for the specific language governing rights and limitations under the
12041: # License.
12041: #
12041: # The Original Code is mozilla.org code.
12041: #
12041: # The Initial Developer of the Original Code is
12041: # Mozilla Foundation.
12041: # Portions created by the Initial Developer are Copyright (C) 2008
12041: # the Initial Developer. All Rights Reserved.
12041: #
12041: # Contributor(s):
12041: #   Robert Sayre <sayrer@gmail.com>
12041: #   Jeff Walden <jwalden+bmo@mit.edu>
12041: #
12041: # Alternatively, the contents of this file may be used under the terms of
12041: # either the GNU General Public License Version 2 or later (the "GPL"), or
12041: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
12041: # in which case the provisions of the GPL or the LGPL are applicable instead
12041: # of those above. If you wish to allow use of your version of this file only
12041: # under the terms of either the GPL or the LGPL, and not to allow others to
12041: # use your version of this file under the terms of the MPL, indicate your
12041: # decision by deleting the provisions above and replace them with the notice
12041: # and other provisions required by the GPL or the LGPL. If you do not delete
12041: # the provisions above, a recipient may use your version of this file under
12041: # the terms of any one of the MPL, the GPL or the LGPL.
12041: #
12041: # ***** END LICENSE BLOCK *****
12041: 
15290: import codecs
36897: from datetime import datetime, timedelta
12041: import itertools
14025: import logging
12041: import os
15290: import re
34283: import select
24149: import shutil
14025: import signal
24149: import subprocess
12041: import sys
14025: import threading
36106: import tempfile
28231: 
12041: 
37238: #expand _DIST_BIN = __XPC_BIN_PATH__
37238: #expand _IS_WIN32 = len("__WIN32__") != 0
37238: #expand _IS_MAC = __IS_MAC__ != 0
37238: #expand _IS_LINUX = __IS_LINUX__ != 0
37238: #ifdef IS_CYGWIN
37238: #expand _IS_CYGWIN = __IS_CYGWIN__ == 1
37238: #else
37238: _IS_CYGWIN = False
37238: #endif
37238: #expand _IS_CAMINO = __IS_CAMINO__ != 0
37238: #expand _BIN_SUFFIX = __BIN_SUFFIX__
37238: #expand _PERL = __PERL__
37161: 
37238: #expand _DEFAULT_APP = "./" + __BROWSER_PATH__
37238: #expand _CERTS_SRC_DIR = __CERTS_SRC_DIR__
37238: #expand _IS_TEST_BUILD = __IS_TEST_BUILD__
37238: #expand _IS_DEBUG_BUILD = __IS_DEBUG_BUILD__
37238: #expand _CRASHREPORTER = __CRASHREPORTER__ == 1
14025: 
14025: #################
12041: # PROFILE SETUP #
14025: #################
12041: 
15290: class SyntaxError(Exception):
15290:   "Signifies a syntax error on a particular line in server-locations.txt."
15290: 
15290:   def __init__(self, lineno, msg = None):
15290:     self.lineno = lineno
15290:     self.msg = msg
15290: 
15290:   def __str__(self):
15290:     s = "Syntax error on line " + str(self.lineno)
15290:     if self.msg:
15290:       s += ": %s." % self.msg
15290:     else:
15290:       s += "."
15290:     return s
15290: 
15290: 
15290: class Location:
15290:   "Represents a location line in server-locations.txt."
15290: 
15290:   def __init__(self, scheme, host, port, options):
15290:     self.scheme = scheme
15290:     self.host = host
15290:     self.port = port
15290:     self.options = options
15290: 
37238: class Automation(object):
37238:   """
37238:   Runs the browser from a script, and provides useful utilities
37238:   for setting up the browser environment.
37238:   """
15290: 
37238:   DIST_BIN = _DIST_BIN
37238:   IS_WIN32 = _IS_WIN32
37238:   IS_MAC = _IS_MAC
37238:   IS_LINUX = _IS_LINUX
37238:   IS_CYGWIN = _IS_CYGWIN
37238:   IS_CAMINO = _IS_CAMINO
37238:   BIN_SUFFIX = _BIN_SUFFIX
37238:   PERL = _PERL
37238: 
37238:   UNIXISH = not IS_WIN32 and not IS_MAC
37238: 
37238:   DEFAULT_APP = _DEFAULT_APP
37238:   CERTS_SRC_DIR = _CERTS_SRC_DIR
37238:   IS_TEST_BUILD = _IS_TEST_BUILD
37238:   IS_DEBUG_BUILD = _IS_DEBUG_BUILD
37238:   CRASHREPORTER = _CRASHREPORTER
37238: 
37238:   SCRIPT_DIR = os.path.abspath(os.path.realpath(os.path.dirname(sys.argv[0])))
37238:   sys.path.insert(0, SCRIPT_DIR)
37238:   automationutils = __import__('automationutils')
37238: 
37238:   # timeout, in seconds
37238:   DEFAULT_TIMEOUT = 60.0
37238: 
37238:   log = logging.getLogger()
37238: 
37238:   def __init__(self):
37238: 
37238:     # We use the logging system here primarily because it'll handle multiple
37238:     # threads, which is needed to process the output of the server and application
37238:     # processes simultaneously.
37238:     handler = logging.StreamHandler(sys.stdout)
37238:     self.log.setLevel(logging.INFO)
37238:     self.log.addHandler(handler)
37238: 
37238:   @property
37238:   def __all__(self):
37238:     return [
37238:            "UNIXISH",
37238:            "IS_WIN32",
37238:            "IS_MAC",
37238:            "log",
37238:            "runApp",
37238:            "Process",
37238:            "addCommonOptions",
37238:            "initializeProfile",
37238:            "DIST_BIN",
37238:            "DEFAULT_APP",
37238:            "CERTS_SRC_DIR",
37238:            "environment",
37238:            "IS_TEST_BUILD",
37238:            "IS_DEBUG_BUILD",
37238:            "DEFAULT_TIMEOUT",
37238:           ]
37238: 
37238:   class Process(subprocess.Popen):
37238:     """
37238:     Represents our view of a subprocess.
37238:     It adds a kill() method which allows it to be stopped explicitly.
37238:     """
37238: 
37238:     def kill(self):
37238:       if Automation().IS_WIN32:
37238:         import platform
37238:         pid = "%i" % self.pid
37238:         if platform.release() == "2000":
37238:           # Windows 2000 needs 'kill.exe' from the 
37238:           #'Windows 2000 Resource Kit tools'. (See bug 475455.)
37238:           try:
37238:             subprocess.Popen(["kill", "-f", pid]).wait()
37238:           except:
37238:             self.log.info("TEST-UNEXPECTED-FAIL | automation.py | Missing 'kill' utility to kill process with pid=%s. Kill it manually!", pid)
37238:         else:
37238:           # Windows XP and later.
37238:           subprocess.Popen(["taskkill", "/F", "/PID", pid]).wait()
37238:       else:
37238:         os.kill(self.pid, signal.SIGKILL)
37238: 
37238:   def readLocations(self, locationsPath = "server-locations.txt"):
15290:     """
15290:     Reads the locations at which the Mochitest HTTP server is available from
15290:     server-locations.txt.
15290:     """
15290: 
18848:     locationFile = codecs.open(locationsPath, "r", "UTF-8")
15290: 
15290:     # Perhaps more detail than necessary, but it's the easiest way to make sure
15290:     # we get exactly the format we want.  See server-locations.txt for the exact
15290:     # format guaranteed here.
15290:     lineRe = re.compile(r"^(?P<scheme>[a-z][-a-z0-9+.]*)"
15290:                       r"://"
15290:                       r"(?P<host>"
15290:                         r"\d+\.\d+\.\d+\.\d+"
15290:                         r"|"
15290:                         r"(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)*"
15290:                         r"[a-z](?:[-a-z0-9]*[a-z0-9])?"
15290:                       r")"
15290:                       r":"
15290:                       r"(?P<port>\d+)"
15290:                       r"(?:"
15290:                       r"\s+"
18848:                       r"(?P<options>\S+(?:,\S+)*)"
15290:                       r")?$")
15290:     locations = []
15290:     lineno = 0
15290:     seenPrimary = False
15290:     for line in locationFile:
15290:       lineno += 1
15290:       if line.startswith("#") or line == "\n":
15290:         continue
15290:       
15290:       match = lineRe.match(line)
15290:       if not match:
15290:         raise SyntaxError(lineno)
15290: 
15290:       options = match.group("options")
15290:       if options:
15290:         options = options.split(",")
15290:         if "primary" in options:
15290:           if seenPrimary:
15290:             raise SyntaxError(lineno, "multiple primary locations")
15290:           seenPrimary = True
15290:       else:
15290:         options = []
15290: 
35240:       locations.append(Location(match.group("scheme"), match.group("host"),
35240:                                 match.group("port"), options))
15290: 
15290:     if not seenPrimary:
15290:       raise SyntaxError(lineno + 1, "missing primary location")
15290: 
15290:     return locations
15290: 
15290: 
37238:   def initializeProfile(self, profileDir, extraPrefs = []):
12041:     "Sets up the standard testing profile."
12041: 
12041:     # Start with a clean slate.
12041:     shutil.rmtree(profileDir, True)
12041:     os.mkdir(profileDir)
12041: 
12041:     prefs = []
12041: 
12041:     part = """\
12041: user_pref("browser.dom.window.dump.enabled", true);
15122: user_pref("dom.allow_scripts_to_close_windows", true);
12041: user_pref("dom.disable_open_during_load", false);
12041: user_pref("dom.max_script_run_time", 0); // no slow script dialogs
28016: user_pref("dom.max_chrome_script_run_time", 0);
34095: user_pref("dom.popup_maximum", -1);
12041: user_pref("signed.applets.codebase_principal_support", true);
12041: user_pref("security.warn_submit_insecure", false);
12041: user_pref("browser.shell.checkDefaultBrowser", false);
18847: user_pref("shell.checkDefaultClient", false);
12041: user_pref("browser.warnOnQuit", false);
12533: user_pref("accessibility.typeaheadfind.autostart", false);
12572: user_pref("javascript.options.showInConsole", true);
14747: user_pref("layout.debug.enable_data_xbl", true);
14946: user_pref("browser.EULA.override", true);
20389: user_pref("javascript.options.jit.content", true);
19034: user_pref("gfx.color_management.force_srgb", true);
23578: user_pref("network.manage-offline-status", false);
28026: user_pref("test.mousescroll", true);
23756: user_pref("security.default_personal_cert", "Select Automatically"); // Need to client auth test be w/o any dialogs
25455: user_pref("network.http.prompt-temp-redirect", false);
26837: user_pref("media.cache_size", 100);
27070: user_pref("security.warn_viewing_mixed", false);
14977: 
35240: user_pref("geo.wifi.uri", "http://localhost:8888/tests/dom/tests/mochitest/geolocation/network_geolocation.sjs");
31577: user_pref("geo.wifi.testing", true);
31577: 
14977: user_pref("camino.warn_when_closing", false); // Camino-only, harmless to others
29285: 
29285: // Make url-classifier updates so rare that they won't affect tests
29285: user_pref("urlclassifier.updateinterval", 172800);
29285: // Point the url-classifier to the local testing server for fast failures
35240: user_pref("browser.safebrowsing.provider.0.gethashURL", "http://localhost:8888/safebrowsing-dummy/gethash");
35240: user_pref("browser.safebrowsing.provider.0.keyURL", "http://localhost:8888/safebrowsing-dummy/newkey");
35240: user_pref("browser.safebrowsing.provider.0.lookupURL", "http://localhost:8888/safebrowsing-dummy/lookup");
35240: user_pref("browser.safebrowsing.provider.0.updateURL", "http://localhost:8888/safebrowsing-dummy/update");
25146: """
25138:   
12041:     prefs.append(part)
12041: 
37238:     locations = self.readLocations()
15290: 
15290:     # Grant God-power to all the privileged servers on which tests run.
15290:     privileged = filter(lambda loc: "privileged" in loc.options, locations)
15290:     for (i, l) in itertools.izip(itertools.count(1), privileged):
12041:       part = """
12041: user_pref("capability.principal.codebase.p%(i)d.granted",
12041:           "UniversalXPConnect UniversalBrowserRead UniversalBrowserWrite \
12041:            UniversalPreferencesRead UniversalPreferencesWrite \
12041:            UniversalFileRead");
15290: user_pref("capability.principal.codebase.p%(i)d.id", "%(origin)s");
12041: user_pref("capability.principal.codebase.p%(i)d.subjectName", "");
15290: """  % { "i": i,
15290:          "origin": (l.scheme + "://" + l.host + ":" + l.port) }
12041:       prefs.append(part)
12041: 
15290:     # We need to proxy every server but the primary one.
15290:     origins = ["'%s://%s:%s'" % (l.scheme, l.host, l.port)
15290:               for l in filter(lambda l: "primary" not in l.options, locations)]
15290:     origins = ", ".join(origins)
12041: 
12041:     pacURL = """data:text/plain,
12041: function FindProxyForURL(url, host)
12041: {
35240:   var origins = [%(origins)s];
15290:   var regex = new RegExp('^([a-z][-a-z0-9+.]*)' +
15290:                          '://' +
15290:                          '(?:[^/@]*@)?' +
15290:                          '(.*?)' +
15290:                          '(?::(\\\\\\\\d+))?/');
12041:   var matches = regex.exec(url);
12041:   if (!matches)
12041:     return 'DIRECT';
15290:   var isHttp = matches[1] == 'http';
18848:   var isHttps = matches[1] == 'https';
15290:   if (!matches[3])
18848:   {
18848:     if (isHttp) matches[3] = '80';
18848:     if (isHttps) matches[3] = '443';
18848:   }
18848:     
15290:   var origin = matches[1] + '://' + matches[2] + ':' + matches[3];
15290:   if (origins.indexOf(origin) < 0)
15290:     return 'DIRECT';
15290:   if (isHttp)
35240:     return 'PROXY 127.0.0.1:8888';
18848:   if (isHttps)
35240:     return 'PROXY 127.0.0.1:4443';
12041:   return 'DIRECT';
35240: }""" % { "origins": origins }
12041:     pacURL = "".join(pacURL.splitlines())
12041: 
12041:     part = """
12041: user_pref("network.proxy.type", 2);
12041: user_pref("network.proxy.autoconfig_url", "%(pacURL)s");
14977: 
14977: user_pref("camino.use_system_proxy_settings", false); // Camino-only, harmless to others
12041: """ % {"pacURL": pacURL}
12041:     prefs.append(part)
12041: 
33841:     for v in extraPrefs:
33841:       thispref = v.split("=")
33841:       if len(thispref) < 2:
34188:         print "Error: syntax error in --setpref=" + v
33841:         sys.exit(1)
33841:       part = 'user_pref("%s", %s);\n' % (thispref[0], thispref[1])
33841:       prefs.append(part)
33841: 
12041:     # write the preferences
12041:     prefsFile = open(profileDir + "/" + "user.js", "a")
12041:     prefsFile.write("".join(prefs))
12041:     prefsFile.close()
12041: 
37238:   def addCommonOptions(self, parser):
34783:     "Adds command-line options which are common to mochitest and reftest."
34783: 
34783:     parser.add_option("--setpref",
34783:                       action = "append", type = "string",
34783:                       default = [],
34783:                       dest = "extraPrefs", metavar = "PREF=VALUE",
34783:                       help = "defines an extra user preference")  
34783: 
37238:   def fillCertificateDB(self, profileDir, certPath, utilityPath, xrePath):
18848:     pwfilePath = os.path.join(profileDir, ".crtdbpw")
18848:   
18848:     pwfile = open(pwfilePath, "w")
18848:     pwfile.write("\n")
18848:     pwfile.close()
18848: 
18848:     # Create head of the ssltunnel configuration file
24791:     sslTunnelConfigPath = os.path.join(profileDir, "ssltunnel.cfg")
18848:     sslTunnelConfig = open(sslTunnelConfigPath, "w")
18848:   
18848:     sslTunnelConfig.write("httpproxy:1\n")
24791:     sslTunnelConfig.write("certdbdir:%s\n" % certPath)
18848:     sslTunnelConfig.write("forward:127.0.0.1:8888\n")
18848:     sslTunnelConfig.write("listen:*:4443:pgo server certificate\n")
18848: 
23756:     # Configure automatic certificate and bind custom certificates, client authentication
37238:     locations = self.readLocations()
18848:     locations.pop(0)
18848:     for loc in locations:
18848:       if loc.scheme == "https" and "nocert" not in loc.options:
18848:         customCertRE = re.compile("^cert=(?P<nickname>[0-9a-zA-Z_ ]+)")
23756:         clientAuthRE = re.compile("^clientauth=(?P<clientauth>[a-z]+)")
18848:         for option in loc.options:
18848:           match = customCertRE.match(option)
18848:           if match:
18848:             customcert = match.group("nickname");
23756:             sslTunnelConfig.write("listen:%s:%s:4443:%s\n" %
23756:                       (loc.host, loc.port, customcert))
23756: 
23756:           match = clientAuthRE.match(option)
23756:           if match:
23756:             clientauth = match.group("clientauth");
23756:             sslTunnelConfig.write("clientauth:%s:%s:4443:%s\n" %
23756:                       (loc.host, loc.port, clientauth))
18848: 
18848:     sslTunnelConfig.close()
18848: 
18848:     # Pre-create the certification database for the profile
37238:     env = self.environment(xrePath = xrePath)
37238:     certutil = os.path.join(utilityPath, "certutil" + self.BIN_SUFFIX)
37238:     pk12util = os.path.join(utilityPath, "pk12util" + self.BIN_SUFFIX)
23756: 
37238:     status = self.Process([certutil, "-N", "-d", profileDir, "-f", pwfilePath], env = env).wait()
18848:     if status != 0:
18848:       return status
18848: 
23756:     # Walk the cert directory and add custom CAs and client certs
24791:     files = os.listdir(certPath)
18848:     for item in files:
18848:       root, ext = os.path.splitext(item)
18848:       if ext == ".ca":
24210:         trustBits = "CT,,"
24210:         if root.endswith("-object"):
24210:           trustBits = "CT,,CT"
37238:         self.Process([certutil, "-A", "-i", os.path.join(certPath, item),
24210:                     "-d", profileDir, "-f", pwfilePath, "-n", root, "-t", trustBits],
24791:                     env = env).wait()
23756:       if ext == ".client":
37238:         self.Process([pk12util, "-i", os.path.join(certPath, item), "-w",
23907:                     pwfilePath, "-d", profileDir], 
24791:                     env = env).wait()
18848: 
18848:     os.unlink(pwfilePath)
18848:     return 0
18848: 
37238:   def environment(self, env = None, xrePath = None, crashreporter = True):
37238:     if xrePath == None:
37238:       xrePath = self.DIST_BIN
18848:     if env == None:
18848:       env = dict(os.environ)
18848: 
37238:     ldLibraryPath = os.path.abspath(os.path.join(self.SCRIPT_DIR, xrePath))
37238:     if self.UNIXISH or self.IS_MAC:
24791:       envVar = "LD_LIBRARY_PATH"
37238:       if self.IS_MAC:
24791:         envVar = "DYLD_LIBRARY_PATH"
33678:       else: # unixish
33678:         env['MOZILLA_FIVE_HOME'] = xrePath
24791:       if envVar in env:
24791:         ldLibraryPath = ldLibraryPath + ":" + env[envVar]
24791:       env[envVar] = ldLibraryPath
37238:     elif self.IS_WIN32:
24791:       env["PATH"] = env["PATH"] + ";" + ldLibraryPath
18848: 
31181:     if crashreporter:
25988:       env['MOZ_CRASHREPORTER_NO_REPORT'] = '1'
25988:       env['MOZ_CRASHREPORTER'] = '1'
34936:     else:
34936:       env['MOZ_CRASHREPORTER_DISABLE'] = '1'
34936: 
37238:     env['GNOME_DISABLE_CRASH_DIALOG'] = '1'
36964:     env['XRE_NO_WINDOWS_CRASH_DIALOG'] = '1'
18848:     return env
12041: 
34283:   if IS_WIN32:
37845:     ctypes = __import__('ctypes')
37845:     wintypes = __import__('ctypes.wintypes')
37845:     time = __import__('time')
37845:     msvcrt = __import__('msvcrt')
34283:     PeekNamedPipe = ctypes.windll.kernel32.PeekNamedPipe
34283:     GetLastError = ctypes.windll.kernel32.GetLastError
36106: 
37238:     def readWithTimeout(self, f, timeout):
34283:       """Try to read a line of output from the file object |f|.
34283:       |f| must be a  pipe, like the |stdout| member of a subprocess.Popen
34283:       object created with stdout=PIPE. If no output
34283:       is received within |timeout| seconds, return a blank line.
34283:       Returns a tuple (line, did_timeout), where |did_timeout| is True
34283:       if the read timed out, and False otherwise."""
35004:       if timeout is None:
35004:         # shortcut to allow callers to pass in "None" for no timeout.
35004:         return (f.readline(), False)
37238:       x = self.msvcrt.get_osfhandle(f.fileno())
37238:       l = self.ctypes.c_long()
37238:       done = self.time.time() + timeout
37238:       while self.time.time() < done:
37238:         if self.PeekNamedPipe(x, None, 0, None, self.ctypes.byref(l), None) == 0:
37238:           err = self.GetLastError()
34283:           if err == 38 or err == 109: # ERROR_HANDLE_EOF || ERROR_BROKEN_PIPE
34283:             return ('', False)
35004:           else:
35004:             log.error("readWithTimeout got error: %d", err)
37492:         if l.value > 0:
35004:           # we're assuming that the output is line-buffered,
35004:           # which is not unreasonable
34283:           return (f.readline(), False)
37238:         self.time.sleep(0.01)
34283:       return ('', True)
36106: 
37238:     def isPidAlive(self, pid):
36106:       STILL_ACTIVE = 259
36106:       PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
37238:       pHandle = self.ctypes.windll.kernel32.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, pid)
36106:       if not pHandle:
36106:         return False
37552:       pExitCode = ctypes.wintypes.DWORD()
37238:       self.ctypes.windll.kernel32.GetExitCodeProcess(pHandle, self.ctypes.byref(pExitCode))
37238:       self.ctypes.windll.kernel32.CloseHandle(pHandle)
36106:       if (pExitCode.value == STILL_ACTIVE):
36106:         return True
34283:       else:
36106:         return False
36106: 
37238:     def killPid(self, pid):
36106:       PROCESS_TERMINATE = 0x0001
37238:       pHandle = self.ctypes.windll.kernel32.OpenProcess(PROCESS_TERMINATE, 0, pid)
36106:       if not pHandle:
36106:         return
37238:       success = self.ctypes.windll.kernel32.TerminateProcess(pHandle, 1)
37238:       self.ctypes.windll.kernel32.CloseHandle(pHandle)
36106: 
36106:   else:
37238:     errno = __import__('errno')
36106: 
37238:     def readWithTimeout(self, f, timeout):
34283:       """Try to read a line of output from the file object |f|. If no output
34283:       is received within |timeout| seconds, return a blank line.
34283:       Returns a tuple (line, did_timeout), where |did_timeout| is True
34283:       if the read timed out, and False otherwise."""
34283:       (r, w, e) = select.select([f], [], [], timeout)
34283:       if len(r) == 0:
34283:         return ('', True)
34283:       return (f.readline(), False)
25988: 
37238:     def isPidAlive(self, pid):
36106:       try:
36106:         # kill(pid, 0) checks for a valid PID without actually sending a signal
36106:         # The method throws OSError if the PID is invalid, which we catch below.
36106:         os.kill(pid, 0)
36106: 
36278:         # Wait on it to see if it's a zombie. This can throw OSError.ECHILD if
36278:         # the process terminates before we get to this point.
36106:         wpid, wstatus = os.waitpid(pid, os.WNOHANG)
36106:         if wpid == 0:
36106:           return True
36106: 
36106:         return False
36106:       except OSError, err:
36278:         # Catch the errors we might expect from os.kill/os.waitpid, 
36278:         # and re-raise any others
37238:         if err.errno == self.errno.ESRCH or err.errno == self.errno.ECHILD:
36106:           return False
36106:         raise
36106: 
37238:     def killPid(self, pid):
36106:       os.kill(pid, signal.SIGKILL)
36106: 
37238:   def triggerBreakpad(self, proc, utilityPath):
34284:     """Attempt to kill this process in a way that triggers Breakpad crash
34284:     reporting, if we know how for this platform. Otherwise just .kill() it."""
37238:     if self.CRASHREPORTER:
37238:       if self.UNIXISH:
34284:         # SEGV will get picked up by Breakpad's signal handler
34284:         os.kill(proc.pid, signal.SIGSEGV)
34284:         return
37238:       elif self.IS_WIN32:
34284:         # We should have a "crashinject" program in our utility path
34284:         crashinject = os.path.normpath(os.path.join(utilityPath, "crashinject.exe"))
34284:         if os.path.exists(crashinject) and subprocess.Popen([crashinject, str(proc.pid)]).wait() == 0:
34284:           return
35004:     #TODO: kill the process such that it triggers Breakpad on OS X (bug 525296)
37238:     self.log.info("Can't trigger Breakpad, just killing process")
34284:     proc.kill()
34284: 
37333:   def waitForFinish(self, proc, utilityPath, timeout, maxTime, startTime):
37323:     """ Look for timeout or crashes and return the status after the process terminates """
37323:     stackFixerProcess = None
37323:     didTimeout = False
37323:     if proc.stdout is None:
37323:       self.log.info("TEST-INFO: Not logging stdout or stderr due to debugger connection")
37323:     else:
37323:       logsource = proc.stdout
37323:       if self.IS_DEBUG_BUILD:
37323:         stackFixerCommand = None
37323:         if self.IS_MAC:
37323:           stackFixerCommand = "fix-macosx-stack.pl"
37323:         elif self.IS_LINUX:
37323:           stackFixerCommand = "fix-linux-stack.pl"
37323:         if stackFixerCommand is not None:
37323:           stackFixerProcess = self.Process([self.PERL, os.path.join(utilityPath, stackFixerCommand)], 
37323:                                            stdin=logsource, 
37323:                                            stdout=subprocess.PIPE)
37323:           logsource = stackFixerProcess.stdout
37323: 
37323:       (line, didTimeout) = self.readWithTimeout(logsource, timeout)
37323:       hitMaxTime = False
37323:       while line != "" and not didTimeout:
37323:         self.log.info(line.rstrip())
37323:         (line, didTimeout) = self.readWithTimeout(logsource, timeout)
37323:         if not hitMaxTime and maxTime and datetime.now() - startTime > timedelta(seconds = maxTime):
37323:           # Kill the application, but continue reading from stack fixer so as not to deadlock on stackFixerProcess.wait().
37323:           hitMaxTime = True
37323:           self.log.info("TEST-UNEXPECTED-FAIL | automation.py | application ran for longer than allowed maximum time of %d seconds", int(maxTime))
37323:           self.triggerBreakpad(proc, utilityPath)
37323:       if didTimeout:
37323:         self.log.info("TEST-UNEXPECTED-FAIL | automation.py | application timed out after %d seconds with no output", int(timeout))
37323:         self.triggerBreakpad(proc, utilityPath)
37323: 
37323:     status = proc.wait()
37323:     if status != 0 and not didTimeout and not hitMaxTime:
37323:       self.log.info("TEST-UNEXPECTED-FAIL | automation.py | Exited with code %d during test run", status)
37323:     if stackFixerProcess is not None:
37323:       fixerStatus = stackFixerProcess.wait()
37323:       if fixerStatus != 0 and not didTimeout and not hitMaxTime:
37323:         self.log.info("TEST-UNEXPECTED-FAIL | automation.py | Stack fixer process exited with code %d during test run", fixerStatus)
37323:     return status
37323: 
37323:   def buildCommandLine(self, app, debuggerInfo, profileDir, testURL, extraArgs):
37323:     """ build the application command line """
37323: 
37323:     cmd = app
37323:     if self.IS_MAC and not self.IS_CAMINO and not cmd.endswith("-bin"):
37323:       cmd += "-bin"
37323:     cmd = os.path.abspath(cmd)
37323: 
37323:     args = []
37323: 
37323:     if debuggerInfo:
37323:       args.extend(debuggerInfo["args"])
37323:       args.append(cmd)
37323:       cmd = os.path.abspath(debuggerInfo["path"])
37323: 
37323:     if self.IS_MAC:
37323:       args.append("-foreground")
37323: 
37323:     if self.IS_CYGWIN:
37323:       profileDirectory = commands.getoutput("cygpath -w \"" + profileDir + "/\"")
37323:     else:
37323:       profileDirectory = profileDir + "/"
37323: 
37323:     args.extend(("-no-remote", "-profile", profileDirectory))
37323:     if testURL is not None:
37323:       if self.IS_CAMINO:
37323:         args.extend(("-url", testURL))
37323:       else:
37323:         args.append((testURL))
37323:     args.extend(extraArgs)
37323:     return cmd, args
37323: 
37323:   def checkForZombies(self, processLog):
37323:     """ Look for hung processes """
37323:     if not os.path.exists(processLog):
37323:       self.log.info('INFO | automation.py | PID log not found: %s', processLog)
37323:     else:
37323:       self.log.info('INFO | automation.py | Reading PID log: %s', processLog)
37323:       processList = []
37323:       pidRE = re.compile(r'launched child process (\d+)$')
37323:       processLogFD = open(processLog)
37323:       for line in processLogFD:
37323:         self.log.info(line.rstrip())
37323:         m = pidRE.search(line)
37323:         if m:
37323:           processList.append(int(m.group(1)))
37323:       processLogFD.close()
37323: 
37323:       for processPID in processList:
37323:         self.log.info("INFO | automation.py | Checking for orphan process with PID: %d", processPID)
37323:         if self.isPidAlive(processPID):
37323:           self.log.info("TEST-UNEXPECTED-FAIL | automation.py | child process %d still alive after shutdown", processPID)
37323:           self.killPid(processPID)
37323: 
37238:   def runApp(self, testURL, env, app, profileDir, extraArgs,
37238:              runSSLTunnel = False, utilityPath = None,
37238:              xrePath = None, certPath = None,
36885:              debuggerInfo = None, symbolsPath = None,
37238:              timeout = -1, maxTime = None):
36897:     """
36897:     Run the app, log the duration it took to execute, return the status code.
36897:     Kills the app if it runs for longer than |maxTime| seconds, or outputs nothing for |timeout| seconds.
36897:     """
12041: 
37238:     if utilityPath == None:
37238:       utilityPath = self.DIST_BIN
37238:     if xrePath == None:
37238:       xrePath = self.DIST_BIN
37238:     if certPath == None:
37238:       certPath = self.CERTS_SRC_DIR
37238:     if timeout == -1:
37238:       timeout = self.DEFAULT_TIMEOUT
37238: 
33054:     # copy env so we don't munge the caller's environment
33054:     env = dict(env);
33678:     env["NO_EM_RESTART"] = "1"
36106:     tmpfd, processLog = tempfile.mkstemp(suffix='pidlog')
36106:     os.close(tmpfd)
36106:     env["MOZ_PROCESS_LOG"] = processLog
33054: 
37238:     if self.IS_TEST_BUILD and runSSLTunnel:
18848:       # create certificate database for the profile
37238:       certificateStatus = self.fillCertificateDB(profileDir, certPath, utilityPath, xrePath)
18848:       if certificateStatus != 0:
37238:         self.log.info("TEST-UNEXPECTED FAIL | automation.py | Certificate integration failed")
18848:         return certificateStatus
18848: 
19851:       # start ssltunnel to provide https:// URLs capability
37238:       ssltunnel = os.path.join(utilityPath, "ssltunnel" + self.BIN_SUFFIX)
37238:       ssltunnelProcess = self.Process([ssltunnel, 
37238:                                os.path.join(profileDir, "ssltunnel.cfg")], 
37238:                                env = self.environment(xrePath = xrePath))
37238:       self.log.info("INFO | automation.py | SSL tunnel pid: %d", ssltunnelProcess.pid)
12041: 
37323:     cmd, args = self.buildCommandLine(app, debuggerInfo, profileDir, testURL, extraArgs)
25783:     startTime = datetime.now()
25819: 
25819:     # Don't redirect stdout and stderr if an interactive debugger is attached
25819:     if debuggerInfo and debuggerInfo["interactive"]:
25819:       outputPipe = None
25819:     else:
25819:       outputPipe = subprocess.PIPE
25819: 
37238:     proc = self.Process([cmd] + args,
37238:                  env = self.environment(env, xrePath = xrePath,
31181:                                    crashreporter = not debuggerInfo),
31181:                  stdout = outputPipe,
31181:                  stderr = subprocess.STDOUT)
37238:     self.log.info("INFO | automation.py | Application pid: %d", proc.pid)
25819: 
37333:     status = self.waitForFinish(proc, utilityPath, timeout, maxTime, startTime)
37238:     self.log.info("INFO | automation.py | Application ran for: %s", str(datetime.now() - startTime))
12041: 
36106:     # Do a final check for zombie child processes.
37323:     self.checkForZombies(processLog)
37238:     self.automationutils.checkForCrashes(os.path.join(profileDir, "minidumps"), symbolsPath)
25988: 
36576:     if os.path.exists(processLog):
36576:       os.unlink(processLog)
36576: 
37238:     if self.IS_TEST_BUILD and runSSLTunnel:
18848:       ssltunnelProcess.kill()
18848: 
25783:     return status
