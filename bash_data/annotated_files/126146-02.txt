 35795: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 19246: 
 19246: #ifndef nsNPAPIPluginInstance_h_
 19246: #define nsNPAPIPluginInstance_h_
 19246: 
 19246: #include "nsCOMPtr.h"
 26912: #include "nsTArray.h"
 47353: #include "nsPIDOMWindow.h"
 47353: #include "nsITimer.h"
 29952: #include "nsIPluginTagInfo.h"
 47965: #include "nsIURI.h"
 60021: #include "nsIChannel.h"
 60021: #include "nsInterfaceHashtable.h"
 60021: #include "nsHashKeys.h"
 82979: #ifdef MOZ_WIDGET_ANDROID
106178: #include "nsAutoPtr.h"
 82979: #include "nsIRunnable.h"
106178: #include "GLContext.h"
106178: #include "nsSurfaceTexture.h"
106178: #include <map>
 97692: class PluginEventRunnable;
106178: class SharedPluginTexture;
 82979: #endif
 80592: 
 36355: #include "mozilla/TimeStamp.h"
 36010: #include "mozilla/PluginLibrary.h"
 19246: 
 70007: struct JSObject;
 70007: 
 47865: class nsPluginStreamListenerPeer; // browser-initiated stream class
 47865: class nsNPAPIPluginStreamListener; // plugin-initiated stream class
 47353: class nsIPluginInstanceOwner;
 70007: class nsIOutputStream;
115860: class nsPluginInstanceOwner;
 19246: 
 91345: #if defined(OS_WIN)
 91345: const NPDrawingModel kDefaultDrawingModel = NPDrawingModelSyncWin;
 91345: #elif defined(MOZ_X11)
 91345: const NPDrawingModel kDefaultDrawingModel = NPDrawingModelSyncX;
 97775: #elif defined(XP_MACOSX)
 91345: #ifndef NP_NO_QUICKDRAW
110791: const NPDrawingModel kDefaultDrawingModel = NPDrawingModelQuickDraw; // Not supported
 91345: #else
 91345: const NPDrawingModel kDefaultDrawingModel = NPDrawingModelCoreGraphics;
 91345: #endif
 97775: #else
 97775: const NPDrawingModel kDefaultDrawingModel = static_cast<NPDrawingModel>(0);
 91345: #endif
 91345: 
 29937: class nsNPAPITimer
 29937: {
 29937: public:
 29937:   NPP npp;
 29937:   uint32_t id;
 29937:   nsCOMPtr<nsITimer> timer;
 29937:   void (*callback)(NPP npp, uint32_t timerID);
125817:   bool inCallback;
126146:   bool needUnschedule;
 29937: };
 29937: 
 70007: class nsNPAPIPluginInstance : public nsISupports
 19246: {
 36010: private:
 36010:   typedef mozilla::PluginLibrary PluginLibrary;
 36010: 
 19246: public:
 19246:   NS_DECL_ISUPPORTS
 70007: 
115860:   nsresult Initialize(nsNPAPIPlugin *aPlugin, nsPluginInstanceOwner* aOwner, const char* aMIMEType);
 70007:   nsresult Start();
 70007:   nsresult Stop();
 70007:   nsresult SetWindow(NPWindow* window);
 70007:   nsresult NewStreamFromPlugin(const char* type, const char* target, nsIOutputStream* *result);
 70007:   nsresult Print(NPPrint* platformPrint);
108991:   nsresult HandleEvent(void* event, int16_t* result);
 70007:   nsresult GetValueFromPlugin(NPPVariable variable, void* value);
108991:   nsresult GetDrawingModel(int32_t* aModel);
 79445:   nsresult IsRemoteDrawingCoreAnimation(bool* aDrawing);
119106:   nsresult ContentsScaleFactorChanged(double aContentsScaleFactor);
 70007:   nsresult GetJSObject(JSContext *cx, JSObject** outObject);
 82172:   bool ShouldCache();
 79445:   nsresult IsWindowless(bool* isWindowless);
 70007:   nsresult AsyncSetWindow(NPWindow* window);
121965:   nsresult GetImageContainer(mozilla::layers::ImageContainer **aContainer);
 70007:   nsresult GetImageSize(nsIntSize* aSize);
 70007:   nsresult NotifyPainted(void);
115090:   nsresult GetIsOOP(bool* aIsOOP);
 70007:   nsresult SetBackgroundUnknown();
 70007:   nsresult BeginUpdateBackground(nsIntRect* aRect, gfxContext** aContext);
 70007:   nsresult EndUpdateBackground(gfxContext* aContext, nsIntRect* aRect);
 79445:   nsresult IsTransparent(bool* isTransparent);
 70007:   nsresult GetFormValue(nsAString& aValue);
 79445:   nsresult PushPopupsEnabledState(bool aEnabled);
 70007:   nsresult PopPopupsEnabledState();
108991:   nsresult GetPluginAPIVersion(uint16_t* version);
 70007:   nsresult InvalidateRect(NPRect *invalidRect);
 70007:   nsresult InvalidateRegion(NPRegion invalidRegion);
 70007:   nsresult GetMIMEType(const char* *result);
 70007:   nsresult GetJSContext(JSContext* *outContext);
115860:   nsPluginInstanceOwner* GetOwner();
115860:   void SetOwner(nsPluginInstanceOwner *aOwner);
 70007:   nsresult ShowStatus(const char* message);
 77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
 77498:   nsresult HandleGUIEvent(const nsGUIEvent& anEvent, bool* handled);
 77498: #endif
 19246: 
 47965:   nsNPAPIPlugin* GetPlugin();
 47965: 
 19246:   nsresult GetNPP(NPP * aNPP);
 19246: 
 79445:   NPError SetWindowless(bool aWindowless);
 19246: 
 79445:   NPError SetTransparent(bool aTransparent);
 19246: 
 79445:   NPError SetWantsAllNetworkStreams(bool aWantsAllNetworkStreams);
 19246: 
 79445:   NPError SetUsesDOMForCursor(bool aUsesDOMForCursor);
 79445:   bool UsesDOMForCursor();
 67677: 
 91345:   void SetDrawingModel(NPDrawingModel aModel);
 91347:   void RedrawPlugin();
 19246: #ifdef XP_MACOSX
 32019:   void SetEventModel(NPEventModel aModel);
 19246: #endif
 19246: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 90194:   void NotifyForeground(bool aForeground);
 90194:   void NotifyOnScreen(bool aOnScreen);
 90194:   void MemoryPressure();
 99806:   void NotifyFullScreen(bool aFullScreen);
106178:   void NotifySize(nsIntSize size);
 90194: 
114273:   nsIntSize CurrentSize() { return mCurrentSize; }
114273: 
 90194:   bool IsOnScreen() {
 90194:     return mOnScreen;
 90194:   }
 90194: 
108991:   uint32_t GetANPDrawingModel() { return mANPDrawingModel; }
108991:   void SetANPDrawingModel(uint32_t aModel);
 89219: 
 78424:   void* GetJavaSurface();
 97692: 
 97692:   void PostEvent(void* event);
 99806: 
 99806:   // These are really mozilla::dom::ScreenOrientation, but it's
 99806:   // difficult to include that here
108991:   uint32_t FullScreenOrientation() { return mFullScreenOrientation; }
108991:   void SetFullScreenOrientation(uint32_t orientation);
101316: 
101316:   void SetWakeLock(bool aLock);
106178: 
106178:   mozilla::gl::GLContext* GLContext();
106178:   
106178:   // For ANPOpenGL
106178:   class TextureInfo {
106178:   public:
106178:     TextureInfo() :
106178:       mTexture(0), mWidth(0), mHeight(0), mInternalFormat(0)
106178:     {
106178:     }
106178: 
108991:     TextureInfo(GLuint aTexture, int32_t aWidth, int32_t aHeight, GLuint aInternalFormat) :
106178:       mTexture(aTexture), mWidth(aWidth), mHeight(aHeight), mInternalFormat(aInternalFormat)
106178:     {
106178:     }
106178: 
106178:     GLuint mTexture;
108991:     int32_t mWidth;
108991:     int32_t mHeight;
106178:     GLuint mInternalFormat;
106178:   };
106178: 
106178:   TextureInfo LockContentTexture();
106178:   void ReleaseContentTexture(TextureInfo& aTextureInfo);
106178: 
106178:   // For ANPNativeWindow
106178:   void* AcquireContentWindow();
106178: 
106178:   mozilla::gl::SharedTextureHandle CreateSharedHandle();
106178: 
106178:   // For ANPVideo
106178:   class VideoInfo {
106178:   public:
106178:     VideoInfo(nsSurfaceTexture* aSurfaceTexture) :
106178:       mSurfaceTexture(aSurfaceTexture)
106178:     {
106178:     }
106178: 
106178:     ~VideoInfo()
106178:     {
106838:       mSurfaceTexture = nullptr;
106178:     }
106178: 
106178:     nsRefPtr<nsSurfaceTexture> mSurfaceTexture;
106178:     gfxRect mDimensions;
106178:   };
106178: 
106178:   void* AcquireVideoWindow();
106178:   void ReleaseVideoWindow(void* aWindow);
106178:   void SetVideoDimensions(void* aWindow, gfxRect aDimensions);
106178: 
106178:   void GetVideos(nsTArray<VideoInfo*>& aVideos);
106178: 
106178:   void SetInverted(bool aInverted);
106178:   bool Inverted() { return mInverted; }
 78424: #endif
 78424: 
 60021:   nsresult NewStreamListener(const char* aURL, void* notifyData,
 98780:                              nsNPAPIPluginStreamListener** listener);
 19246: 
 94603:   nsNPAPIPluginInstance();
 47965:   virtual ~nsNPAPIPluginInstance();
 19246: 
 47965:   // To be called when an instance becomes orphaned, when
 47965:   // it's plugin is no longer guaranteed to be around.
 47965:   void Destroy();
 19246: 
 39211:   // Indicates whether the plugin is running normally.
 39211:   bool IsRunning() {
 39211:     return RUNNING == mRunning;
 39211:   }
 59756:   bool HasStartedDestroying() {
 59756:     return mRunning >= DESTROYING;
 59756:   }
 39211: 
 39211:   // Indicates whether the plugin is running normally or being shut down
 39211:   bool CanFireNotifications() {
 39211:     return mRunning == RUNNING || mRunning == DESTROYING;
 39211:   }
 36355: 
 82172:   // return is only valid when the plugin is not running
 82172:   mozilla::TimeStamp StopTime();
 82172: 
 82172:   // cache this NPAPI plugin
108534:   void SetCached(bool aCache);
 82172: 
 19246:   already_AddRefed<nsPIDOMWindow> GetDOMWindow();
 19246: 
 96781:   nsresult PrivateModeStateChanged(bool aEnabled);
 29834: 
 29834:   nsresult GetDOMElement(nsIDOMElement* *result);
 29834: 
108991:   nsNPAPITimer* TimerWithID(uint32_t id, uint32_t* index);
 29937:   uint32_t      ScheduleTimer(uint32_t interval, NPBool repeat, void (*timerFunc)(NPP npp, uint32_t timerID));
 29937:   void          UnscheduleTimer(uint32_t timerID);
 32019:   NPError       PopUpContextMenu(NPMenu* menu);
 32019:   NPBool        ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace);
 47865: 
 60021: 
 60021:   nsTArray<nsNPAPIPluginStreamListener*> *StreamListeners();
 60021: 
 60021:   nsTArray<nsPluginStreamListenerPeer*> *FileCachedStreamListeners();
 47865: 
 52409:   nsresult AsyncSetWindow(NPWindow& window);
 52409: 
 60021:   void URLRedirectResponse(void* notifyData, NPBool allow);
 60021: 
 91341:   NPError InitAsyncSurface(NPSize *size, NPImageFormat format,
 91341:                            void *initData, NPAsyncSurface *surface);
 91341:   NPError FinalizeAsyncSurface(NPAsyncSurface *surface);
 91341:   void SetCurrentAsyncSurface(NPAsyncSurface *surface, NPRect *changed);
 91341: 
 61864:   // Called when the instance fails to instantiate beceause the Carbon
 61864:   // event model is not supported.
 61864:   void CarbonNPAPIFailure();
 61864: 
115799:   // Returns the contents scale factor of the screen the plugin is drawn on.
115799:   double GetContentsScaleFactor();
115799: 
125323:   static bool InPluginCall() { return gInPluginCalls > 0; }
125323:   static void BeginPluginCall() { ++gInPluginCalls; }
125323:   static void EndPluginCall()
125323:   {
125323:     NS_ASSERTION(InPluginCall(), "Must be in plugin call");
125323:     --gInPluginCalls;
125323:   }
125323: 
 36173: protected:
 19246: 
 29834:   nsresult GetTagType(nsPluginTagType *result);
108991:   nsresult GetAttributes(uint16_t& n, const char*const*& names,
 29834:                          const char*const*& values);
108991:   nsresult GetParameters(uint16_t& n, const char*const*& names,
 29834:                          const char*const*& values);
108991:   nsresult GetMode(int32_t *result);
 19246: 
116413:   // check if this is a Java applet and affected by bug 750480
116413:   void CheckJavaC2PJSObjectQuirk(uint16_t paramCount,
116413:                                  const char* const* names,
116413:                                  const char* const* values);
116413: 
 26260:   // The structure used to communicate between the plugin instance and
 26260:   // the browser.
 30212:   NPP_t mNPP;
 19246: 
 19246:   NPDrawingModel mDrawingModel;
 19246: 
 82142: #ifdef MOZ_WIDGET_ANDROID
108991:   uint32_t mANPDrawingModel;
 97692: 
 97692:   friend class PluginEventRunnable;
 97692: 
 97692:   nsTArray<nsCOMPtr<PluginEventRunnable>> mPostedEvents;
 97692:   void PopPostedEvent(PluginEventRunnable* r);
106565:   void OnSurfaceTextureFrameAvailable();
 99806: 
108991:   uint32_t mFullScreenOrientation;
101316:   bool mWakeLocked;
101317:   bool mFullScreen;
106178:   bool mInverted;
106178: 
106178:   nsRefPtr<SharedPluginTexture> mContentTexture;
106178:   nsRefPtr<nsSurfaceTexture> mContentSurface;
 78424: #endif
 78424: 
 39211:   enum {
 39211:     NOT_STARTED,
 39211:     RUNNING,
 39211:     DESTROYING,
 39211:     DESTROYED
 39211:   } mRunning;
 39211: 
 19246:   // these are used to store the windowless properties
 19246:   // which the browser will later query
 79445:   bool mWindowless;
 79445:   bool mTransparent;
 82172:   bool mCached;
 79445:   bool mUsesDOMForCursor;
 19246: 
 36173: public:
 19246:   // True while creating the plugin, or calling NPP_SetWindow() on it.
 79445:   bool mInPluginInitCall;
 19246: 
 57925:   nsXPIDLCString mFakeURL;
 57925: 
 36173: private:
 47965:   nsNPAPIPlugin* mPlugin;
 47965: 
 60021:   nsTArray<nsNPAPIPluginStreamListener*> mStreamListeners;
 47865: 
 60021:   nsTArray<nsPluginStreamListenerPeer*> mFileCachedStreamListeners;
 47865: 
 26912:   nsTArray<PopupControlState> mPopupStates;
 29808: 
 30101:   char* mMIMEType;
 29834: 
 29834:   // Weak pointer to the owner. The owner nulls this out (by calling
 29834:   // InvalidateOwner()) when it's no longer our owner.
115860:   nsPluginInstanceOwner *mOwner;
 29937: 
 29937:   nsTArray<nsNPAPITimer*> mTimers;
 32019: 
 32019:   // non-null during a HandleEvent call
 32799:   void* mCurrentPluginEvent;
 36355: 
 82172:   // Timestamp for the last time this plugin was stopped.
 82172:   // This is only valid when the plugin is actually stopped!
 82172:   mozilla::TimeStamp mStopTime;
 82172: 
 82142: #ifdef MOZ_WIDGET_ANDROID
106178:   void EnsureSharedTexture();
106178:   nsSurfaceTexture* CreateSurfaceTexture();
106178: 
106178:   std::map<void*, VideoInfo*> mVideos;
 90194:   bool mOnScreen;
106178: 
106178:   nsIntSize mCurrentSize;
 78424: #endif
116413: 
116413:   // is this instance Java and affected by bug 750480?
116413:   bool mHaveJavaC2PJSObjectQuirk;
125323: 
125323:   static uint32_t gInPluginCalls;
 19246: };
 19246: 
 19246: #endif // nsNPAPIPluginInstance_h_
