    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim:expandtab:shiftwidth=2:tabstop=2:cin:
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Scott MacGregor <mscott@netscape.com>
    1:  *   Bill Law <law@netscape.com>
    1:  *   Christian Biesinger <cbiesinger@web.de>
 1859:  *   Dan Mosedale <dmose@mozilla.org>
 4568:  *   Myk Melez <myk@mozilla.org>
21635:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
49349: #ifdef MOZ_LOGGING
49349: #define FORCE_PR_LOG
49349: #endif
49349: 
50771: #include "base/basictypes.h"
80467: 
80467: /* This must occur *after* base/basictypes.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
49349: #include "mozilla/dom/ContentChild.h"
49349: #include "nsXULAppAPI.h"
49349: 
    1: #include "nsExternalHelperAppService.h"
 4630: #include "nsCExternalHandlerService.h"
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
    1: #include "nsIFile.h"
    1: #include "nsIFileURL.h"
    1: #include "nsIChannel.h"
    1: #include "nsIDirectoryService.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIStringEnumerator.h"
    1: #include "nsMemory.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIMIMEService.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsIWebProgressListener.h"
    1: #include "nsITransfer.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIRequest.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsAutoPtr.h"
 4575: #include "nsIMutableArray.h"
    1: 
 5657: // used to access our datastore of user-configured helper applications
 5657: #include "nsIHandlerService.h"
    1: #include "nsIMIMEInfo.h"
    1: #include "nsIRefreshURI.h" // XXX needed to redirect according to Refresh: URI
    1: #include "nsIDocumentLoader.h" // XXX needed to get orig. channel and assoc. refresh uri
    1: #include "nsIHelperAppLauncherDialog.h"
 4013: #include "nsIContentDispatchChooser.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIIOService.h"
    1: #include "nsNetCID.h"
    1: #include "nsChannelProperties.h"
    1: 
    1: #include "nsMimeTypes.h"
    1: // used for header disposition information.
    1: #include "nsIHttpChannel.h"
52366: #include "nsIHttpChannelInternal.h"
    1: #include "nsIEncodedChannel.h"
    1: #include "nsIMultiPartChannel.h"
    1: #include "nsIFileChannel.h"
    1: #include "nsIObserverService.h" // so we can be a profile change observer
    1: #include "nsIPropertyBag2.h" // for the 64-bit content length
    1: 
    1: #ifdef XP_MACOSX
    1: #include "nsILocalFileMac.h"
27621: #ifndef __LP64__
    1: #include "nsIAppleFileDecoder.h"
27621: #endif
    1: #elif defined(XP_OS2)
    1: #include "nsILocalFileOS2.h"
    1: #endif
    1: 
    1: #include "nsIPluginHost.h" // XXX needed for ext->type mapping (bug 233289)
70185: #include "nsPluginHost.h"
    1: #include "nsEscape.h"
    1: 
    1: #include "nsIStringBundle.h" // XXX needed to localize error msgs
    1: #include "nsIPrompt.h"
    1: 
    1: #include "nsITextToSubURI.h" // to unescape the filename
    1: #include "nsIMIMEHeaderParam.h"
    1: 
    1: #include "nsIWindowWatcher.h"
    1: 
 8309: #include "nsIDownloadHistory.h" // to mark downloads as visited
 8309: #include "nsDocShellCID.h"
    1: 
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDocShell.h"
    1: 
    1: #include "nsCRT.h"
    1: 
 4630: #include "nsLocalHandlerApp.h"
 3161: 
 6887: #include "nsIRandomGenerator.h"
 6887: #include "plbase64.h"
 6887: #include "prmem.h"
 6887: 
21635: #include "nsIPrivateBrowsingService.h"
21635: 
53991: #include "ContentChild.h"
50771: #include "nsXULAppAPI.h"
50771: #include "nsPIDOMWindow.h"
50771: #include "nsIDocShellTreeOwner.h"
50771: #include "nsIDocShellTreeItem.h"
50771: #include "ExternalHelperAppChild.h"
50771: 
82142: #ifdef MOZ_WIDGET_ANDROID
54802: #include "AndroidBridge.h"
54802: #endif
54802: 
72898: #include "mozilla/Preferences.h"
72898: 
72898: using namespace mozilla;
72898: 
 9812: // Buffer file writes in 32kb chunks
 9812: #define BUFFERED_OUTPUT_SIZE (1024 * 32)
 9812: 
19774: // Download Folder location constants
19774: #define NS_PREF_DOWNLOAD_DIR        "browser.download.dir"
19774: #define NS_PREF_DOWNLOAD_FOLDERLIST "browser.download.folderList"
19774: enum {
19774:   NS_FOLDER_VALUE_DESKTOP = 0
19774: , NS_FOLDER_VALUE_DOWNLOADS = 1
19774: , NS_FOLDER_VALUE_CUSTOM = 2
19774: };
19774: 
    1: #ifdef PR_LOGGING
    1: PRLogModuleInfo* nsExternalHelperAppService::mLog = nsnull;
    1: #endif
    1: 
    1: // Using level 3 here because the OSHelperAppServices use a log level
    1: // of PR_LOG_DEBUG (4), and we want less detailed output here
    1: // Using 3 instead of PR_LOG_WARN because we don't output warnings
50771: #undef LOG
    1: #define LOG(args) PR_LOG(mLog, 3, args)
    1: #define LOG_ENABLED() PR_LOG_TEST(mLog, 3)
    1: 
72898: static const char NEVER_ASK_FOR_SAVE_TO_DISK_PREF[] =
72898:   "browser.helperApps.neverAsk.saveToDisk";
72898: static const char NEVER_ASK_FOR_OPEN_FILE_PREF[] =
72898:   "browser.helperApps.neverAsk.openFile";
    1: 
    1: // Helper functions for Content-Disposition headers
    1: 
    1: /**
    1:  * Given a URI fragment, unescape it
    1:  * @param aFragment The string to unescape
    1:  * @param aURI The URI from which this fragment is taken. Only its character set
    1:  *             will be used.
    1:  * @param aResult [out] Unescaped string.
    1:  */
    1: static nsresult UnescapeFragment(const nsACString& aFragment, nsIURI* aURI,
    1:                                  nsAString& aResult)
    1: {
    1:   // First, we need a charset
    1:   nsCAutoString originCharset;
    1:   nsresult rv = aURI->GetOriginCharset(originCharset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Now, we need the unescaper
    1:   nsCOMPtr<nsITextToSubURI> textToSubURI = do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return textToSubURI->UnEscapeURIForUI(originCharset, aFragment, aResult);
    1: }
    1: 
    1: /**
    1:  * UTF-8 version of UnescapeFragment.
    1:  * @param aFragment The string to unescape
    1:  * @param aURI The URI from which this fragment is taken. Only its character set
    1:  *             will be used.
    1:  * @param aResult [out] Unescaped string, UTF-8 encoded.
    1:  * @note It is safe to pass the same string for aFragment and aResult.
    1:  * @note When this function fails, aResult will not be modified.
    1:  */
    1: static nsresult UnescapeFragment(const nsACString& aFragment, nsIURI* aURI,
    1:                                  nsACString& aResult)
    1: {
    1:   nsAutoString result;
    1:   nsresult rv = UnescapeFragment(aFragment, aURI, result);
    1:   if (NS_SUCCEEDED(rv))
    1:     CopyUTF16toUTF8(result, aResult);
    1:   return rv;
    1: }
    1: 
    1: /**
    1:  * Given a channel, returns the filename and extension the channel has.
    1:  * This uses the URL and other sources (nsIMultiPartChannel).
    1:  * Also gives back whether the channel requested external handling (i.e.
    1:  * whether Content-Disposition: attachment was sent)
    1:  * @param aChannel The channel to extract the filename/extension from
    1:  * @param aFileName [out] Reference to the string where the filename should be
    1:  *        stored. Empty if it could not be retrieved.
    1:  *        WARNING - this filename may contain characters which the OS does not
    1:  *        allow as part of filenames!
    1:  * @param aExtension [out] Reference to the string where the extension should
    1:  *        be stored. Empty if it could not be retrieved. Stored in UTF-8.
    1:  * @param aAllowURLExtension (optional) Get the extension from the URL if no
    1:  *        Content-Disposition header is present. Default is true.
    1:  * @retval true The server sent Content-Disposition:attachment or equivalent
    1:  * @retval false Content-Disposition: inline or no content-disposition header
    1:  *         was sent.
    1:  */
79445: static bool GetFilenameAndExtensionFromChannel(nsIChannel* aChannel,
    1:                                                  nsString& aFileName,
    1:                                                  nsCString& aExtension,
79445:                                                  bool aAllowURLExtension = true)
    1: {
    1:   aExtension.Truncate();
    1:   /*
    1:    * If the channel is an http or part of a multipart channel and we
    1:    * have a content disposition header set, then use the file name
    1:    * suggested there as the preferred file name to SUGGEST to the
    1:    * user.  we shouldn't actually use that without their
    1:    * permission... otherwise just use our temp file
    1:    */
79445:   bool handleExternally = false;
78165:   PRUint32 disp;
78165:   nsresult rv = aChannel->GetContentDisposition(&disp);
78165:   if (NS_SUCCEEDED(rv))
    1:   {
78165:     aChannel->GetContentDispositionFilename(aFileName);
78165:     if (disp == nsIChannel::DISPOSITION_ATTACHMENT)
80486:       handleExternally = true;
    1:   }
    1: 
    1:   // If the disposition header didn't work, try the filename from nsIURL
78165:   nsCOMPtr<nsIURI> uri;
78165:   aChannel->GetURI(getter_AddRefs(uri));
    1:   nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
    1:   if (url && aFileName.IsEmpty())
    1:   {
    1:     if (aAllowURLExtension) {
    1:       url->GetFileExtension(aExtension);
    1:       UnescapeFragment(aExtension, url, aExtension);
    1: 
    1:       // Windows ignores terminating dots. So we have to as well, so
    1:       // that our security checks do "the right thing"
    1:       // In case the aExtension consisted only of the dot, the code below will
    1:       // extract an aExtension from the filename
80486:       aExtension.Trim(".", false);
    1:     }
    1: 
    1:     // try to extract the file name from the url and use that as a first pass as the
    1:     // leaf name of our temp file...
    1:     nsCAutoString leafName;
    1:     url->GetFileName(leafName);
    1:     if (!leafName.IsEmpty())
    1:     {
    1:       rv = UnescapeFragment(leafName, url, aFileName);
    1:       if (NS_FAILED(rv))
    1:       {
    1:         CopyUTF8toUTF16(leafName, aFileName); // use escaped name
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Extract Extension, if we have a filename; otherwise,
    1:   // truncate the string
    1:   if (aExtension.IsEmpty()) {
    1:     if (!aFileName.IsEmpty())
    1:     {
    1:       // Windows ignores terminating dots. So we have to as well, so
    1:       // that our security checks do "the right thing"
80486:       aFileName.Trim(".", false);
    1: 
    1:       // XXX RFindCharInReadable!!
    1:       nsAutoString fileNameStr(aFileName);
    1:       PRInt32 idx = fileNameStr.RFindChar(PRUnichar('.'));
    1:       if (idx != kNotFound)
    1:         CopyUTF16toUTF8(StringTail(fileNameStr, fileNameStr.Length() - idx - 1), aExtension);
    1:     }
    1:   }
    1: 
    1: 
    1:   return handleExternally;
    1: }
    1: 
    1: /**
55432:  * Obtains the directory to use.  This tends to vary per platform, and
55432:  * needs to be consistent throughout our codepaths. For platforms where
55432:  * helper apps use the downloads directory, this should be kept in
55432:  * sync with nsDownloadManager.cpp
19774:  */
19774: static nsresult GetDownloadDirectory(nsIFile **_directory)
19774: {
19774:   nsCOMPtr<nsIFile> dir;
19774: #ifdef XP_MACOSX
19774:   // On OS X, we first try to get the users download location, if it's set.
72898:   switch (Preferences::GetInt(NS_PREF_DOWNLOAD_FOLDERLIST, -1)) {
19774:     case NS_FOLDER_VALUE_DESKTOP:
19774:       (void) NS_GetSpecialDirectory(NS_OS_DESKTOP_DIR, getter_AddRefs(dir));
19774:       break;
19774:     case NS_FOLDER_VALUE_CUSTOM:
19774:       {
72898:         Preferences::GetComplex(NS_PREF_DOWNLOAD_DIR,
24236:                                 NS_GET_IID(nsILocalFile),
19774:                                 getter_AddRefs(dir));
19774:         if (!dir) break;
19774: 
19774:         // We have the directory, and now we need to make sure it exists
79445:         bool dirExists = false;
19774:         (void) dir->Exists(&dirExists);
19774:         if (dirExists) break;
19774: 
19774:         nsresult rv = dir->Create(nsIFile::DIRECTORY_TYPE, 0755);
19774:         if (NS_FAILED(rv)) {
19774:           dir = nsnull;
19774:           break;
19774:         }
19774:       }
19774:       break;
19774:     case NS_FOLDER_VALUE_DOWNLOADS:
19774:       // This is just the OS default location, so fall out
19774:       break;
19774:   }
19774: 
19774:   if (!dir) {
19774:     // If not, we default to the OS X default download location.
19774:     nsresult rv = NS_GetSpecialDirectory(NS_OSX_DEFAULT_DOWNLOAD_DIR,
19774:                                          getter_AddRefs(dir));
19774:     NS_ENSURE_SUCCESS(rv, rv);
19774:   }
51176: #elif defined(ANDROID)
55432:   // On mobile devices, we are avoiding exposing users to the file
55432:   // system, and don't save downloads to temp directories
55432: 
55432:   // On Android we only return something if we have and SD-card
59798:   char* downloadDir = getenv("DOWNLOADS_DIRECTORY");
51176:   nsresult rv;
59798:   if (downloadDir) {
51176:     nsCOMPtr<nsILocalFile> ldir; 
59798:     rv = NS_NewNativeLocalFile(nsDependentCString(downloadDir),
80486:                                true, getter_AddRefs(ldir));
51176:     NS_ENSURE_SUCCESS(rv, rv);
59798:     dir = do_QueryInterface(ldir);
51176:   }
51176:   else {
55432:     return NS_ERROR_FAILURE;
55432:   }
58008: #elif defined(MOZ_PLATFORM_MAEMO)
58016:   nsresult rv = NS_GetSpecialDirectory(NS_UNIX_XDG_DOCUMENTS_DIR, getter_AddRefs(dir));
51176:   NS_ENSURE_SUCCESS(rv, rv);
19774: #else
19774:   // On all other platforms, we default to the systems temporary directory.
19774:   nsresult rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(dir));
19774:   NS_ENSURE_SUCCESS(rv, rv);
19774: #endif
19774: 
19774:   NS_ASSERTION(dir, "Somehow we didn't get a download directory!");
19774:   dir.forget(_directory);
19774:   return NS_OK;
19774: }
19774: 
19774: /**
    1:  * Structure for storing extension->type mappings.
    1:  * @see defaultMimeEntries
    1:  */
    1: struct nsDefaultMimeTypeEntry {
    1:   const char* mMimeType;
    1:   const char* mFileExtension;
    1: };
    1: 
    1: /**
    1:  * Default extension->mimetype mappings. These are not overridable.
    1:  * If you add types here, make sure they are lowercase, or you'll regret it.
    1:  */
    1: static nsDefaultMimeTypeEntry defaultMimeEntries [] = 
    1: {
    1:   // The following are those extensions that we're asked about during startup,
    1:   // sorted by order used
    1:   { IMAGE_GIF, "gif" },
    1:   { TEXT_XML, "xml" },
    1:   { APPLICATION_RDF, "rdf" },
    1:   { TEXT_XUL, "xul" },
    1:   { IMAGE_PNG, "png" },
    1:   // -- end extensions used during startup
    1:   { TEXT_CSS, "css" },
    1:   { IMAGE_JPG, "jpeg" },
    1:   { IMAGE_JPG, "jpg" },
    1:   { TEXT_HTML, "html" },
    1:   { TEXT_HTML, "htm" },
    1:   { APPLICATION_XPINSTALL, "xpi" },
    1:   { "application/xhtml+xml", "xhtml" },
 6932:   { "application/xhtml+xml", "xht" },
63618:   { TEXT_PLAIN, "txt" },
63618: #ifdef MOZ_OGG
63618:   { VIDEO_OGG, "ogv" },
63618:   { VIDEO_OGG, "ogg" },
63618:   { APPLICATION_OGG, "ogg" },
63618:   { AUDIO_OGG, "oga" },
63618: #endif
63618: #ifdef MOZ_WEBM
63618:   { VIDEO_WEBM, "webm" },
63618:   { AUDIO_WEBM, "webm" },
63618: #endif
63618: #ifdef MOZ_RAW
63618:   { VIDEO_RAW, "yuv" }
63618: #endif
    1: };
    1: 
    1: /**
    1:  * This is a small private struct used to help us initialize some
    1:  * default mime types.
    1:  */
    1: struct nsExtraMimeTypeEntry {
    1:   const char* mMimeType; 
    1:   const char* mFileExtensions;
    1:   const char* mDescription;
    1: };
    1: 
    1: #ifdef XP_MACOSX
    1: #define MAC_TYPE(x) x
    1: #else
    1: #define MAC_TYPE(x) 0
    1: #endif
    1: 
    1: /**
    1:  * This table lists all of the 'extra' content types that we can deduce from particular
    1:  * file extensions.  These entries also ensure that we provide a good descriptive name
    1:  * when we encounter files with these content types and/or extensions.  These can be
    1:  * overridden by user helper app prefs.
    1:  * If you add types here, make sure they are lowercase, or you'll regret it.
    1:  */
    1: static nsExtraMimeTypeEntry extraMimeEntries [] =
    1: {
    1: #if defined(VMS)
29490:   { APPLICATION_OCTET_STREAM, "exe,com,bin,sav,bck,pcsi,dcx_axpexe,dcx_vaxexe,sfx_axpexe,sfx_vaxexe", "Binary File" },
    1: #elif defined(XP_MACOSX) // don't define .bin on the mac...use internet config to look that up...
29490:   { APPLICATION_OCTET_STREAM, "exe,com", "Binary File" },
    1: #else
29490:   { APPLICATION_OCTET_STREAM, "exe,com,bin", "Binary File" },
    1: #endif
29490:   { APPLICATION_GZIP2, "gz", "gzip" },
29490:   { "application/x-arj", "arj", "ARJ file" },
61110:   { "application/rtf", "rtf", "Rich Text Format File" },
29490:   { APPLICATION_XPINSTALL, "xpi", "XPInstall Install" },
29490:   { APPLICATION_POSTSCRIPT, "ps,eps,ai", "Postscript File" },
38388:   { APPLICATION_XJAVASCRIPT, "js", "Javascript Source File" },
82142: #ifdef MOZ_WIDGET_ANDROID
58526:   { "application/vnd.android.package-archive", "apk", "Android Package" },
58526: #endif
29490:   { IMAGE_ART, "art", "ART Image" },
29490:   { IMAGE_BMP, "bmp", "BMP Image" },
29490:   { IMAGE_GIF, "gif", "GIF Image" },
29490:   { IMAGE_ICO, "ico,cur", "ICO Image" },
29490:   { IMAGE_JPG, "jpeg,jpg,jfif,pjpeg,pjp", "JPEG Image" },
29490:   { IMAGE_PNG, "png", "PNG Image" },
29490:   { IMAGE_TIFF, "tiff,tif", "TIFF Image" },
29490:   { IMAGE_XBM, "xbm", "XBM Image" },
29490:   { "image/svg+xml", "svg", "Scalable Vector Graphics" },
29490:   { MESSAGE_RFC822, "eml", "RFC-822 data" },
29490:   { TEXT_PLAIN, "txt,text", "Text File" },
29490:   { TEXT_HTML, "html,htm,shtml,ehtml", "HyperText Markup Language" },
29490:   { "application/xhtml+xml", "xhtml,xht", "Extensible HyperText Markup Language" },
38779:   { APPLICATION_MATHML_XML, "mml", "Mathematical Markup Language" },
29490:   { APPLICATION_RDF, "rdf", "Resource Description Framework" },
29490:   { TEXT_XUL, "xul", "XML-Based User Interface Language" },
29490:   { TEXT_XML, "xml,xsl,xbl", "Extensible Markup Language" },
29490:   { TEXT_CSS, "css", "Style Sheet" },
29490:   { VIDEO_OGG, "ogv", "Ogg Video" },
29490:   { VIDEO_OGG, "ogg", "Ogg Video" },
29490:   { APPLICATION_OGG, "ogg", "Ogg Video"},
29490:   { AUDIO_OGG, "oga", "Ogg Audio" },
43339:   { VIDEO_WEBM, "webm", "Web Media Video" },
43339:   { AUDIO_WEBM, "webm", "Web Media Audio" },
48220:   { VIDEO_RAW, "yuv", "Raw YUV Video" },
63618:   { AUDIO_WAV, "wav", "Waveform Audio" }
    1: };
    1: 
    1: #undef MAC_TYPE
    1: 
    1: /**
    1:  * File extensions for which decoding should be disabled.
    1:  * NOTE: These MUST be lower-case and ASCII.
    1:  */
    1: static nsDefaultMimeTypeEntry nonDecodableExtensions [] = {
    1:   { APPLICATION_GZIP, "gz" }, 
    1:   { APPLICATION_GZIP, "tgz" },
    1:   { APPLICATION_ZIP, "zip" },
    1:   { APPLICATION_COMPRESS, "z" },
    1:   { APPLICATION_GZIP, "svgz" }
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS6(
    1:   nsExternalHelperAppService,
    1:   nsIExternalHelperAppService,
    1:   nsPIExternalAppLauncher,
    1:   nsIExternalProtocolService,
    1:   nsIMIMEService,
    1:   nsIObserver,
    1:   nsISupportsWeakReference)
    1: 
21635: nsExternalHelperAppService::nsExternalHelperAppService() :
80486:   mInPrivateBrowsing(false)
    1: {
    1: }
    1: nsresult nsExternalHelperAppService::Init()
    1: {
21635:   nsCOMPtr<nsIPrivateBrowsingService> pbs =
21635:     do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
21635:   if (pbs) {
21635:     pbs->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
21635:   }
21635: 
    1:   // Add an observer for profile change
41540:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
41540:   if (!obs)
41540:     return NS_ERROR_FAILURE;
    1: 
    1: #ifdef PR_LOGGING
    1:   if (!mLog) {
    1:     mLog = PR_NewLogModule("HelperAppService");
    1:     if (!mLog)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: #endif
    1: 
80486:   nsresult rv = obs->AddObserver(this, "profile-before-change", true);
21635:   NS_ENSURE_SUCCESS(rv, rv);
80486:   return obs->AddObserver(this, NS_PRIVATE_BROWSING_SWITCH_TOPIC, true);
    1: }
    1: 
    1: nsExternalHelperAppService::~nsExternalHelperAppService()
    1: {
    1: }
    1: 
51739: static PRInt64 GetContentLengthAsInt64(nsIRequest *request)
51739: {
51739:   PRInt64 contentLength = -1;
51739:   nsresult rv;
51739:   nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(request, &rv));
51739:   if (props)
51739:     rv = props->GetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH, &contentLength);
51739: 
51739:   if (NS_FAILED(rv)) {
51739:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
51739:     if (channel) {
51739:       PRInt32 smallLen;
51739:       channel->GetContentLength(&smallLen);
51739:       contentLength = smallLen;
51739:     }
51739:   }
51739: 
51739:   return contentLength;
51739: }
51739: 
    1: NS_IMETHODIMP nsExternalHelperAppService::DoContent(const nsACString& aMimeContentType,
    1:                                                     nsIRequest *aRequest,
    1:                                                     nsIInterfaceRequestor *aWindowContext,
79445:                                                     bool aForceSave,
    1:                                                     nsIStreamListener ** aStreamListener)
    1: {
    1:   nsAutoString fileName;
    1:   nsCAutoString fileExtension;
    1:   PRUint32 reason = nsIHelperAppLauncherDialog::REASON_CANTHANDLE;
    1:   nsresult rv;
    1: 
    1:   // Get the file extension and name that we will need later
    1:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
50771:   nsCOMPtr<nsIURI> uri;
50771:   if (channel)
50771:     channel->GetURI(getter_AddRefs(uri));
50771: 
51739:   PRInt64 contentLength = GetContentLengthAsInt64(aRequest);
50771:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
53991:     // We need to get a hold of a ContentChild so that we can begin forwarding
50771:     // this data to the parent.  In the HTTP case, this is unfortunate, since
50771:     // we're actually passing data from parent->child->parent wastefully, but
50771:     // the Right Fix will eventually be to short-circuit those channels on the
50771:     // parent side based on some sort of subscription concept.
53991:     using mozilla::dom::ContentChild;
53991:     using mozilla::dom::ExternalHelperAppChild;
53991:     ContentChild *child = ContentChild::GetSingleton();
53991:     if (!child)
50771:       return NS_ERROR_FAILURE;
50771: 
53715:     nsCString disp;
53715:     if (channel)
78165:       channel->GetContentDispositionHeader(disp);
53715: 
57975:     nsCOMPtr<nsIURI> referrer;
57975:     rv = NS_GetReferrerFromChannel(channel, getter_AddRefs(referrer));
57975: 
50771:     // Now we build a protocol for forwarding our data to the parent.  The
50771:     // protocol will act as a listener on the child-side and create a "real"
50771:     // helperAppService listener on the parent-side, via another call to
50771:     // DoContent.
50771:     mozilla::dom::PExternalHelperAppChild *pc;
50771:     pc = child->SendPExternalHelperAppConstructor(IPC::URI(uri),
51737:                                                   nsCString(aMimeContentType),
53715:                                                   disp,
57975:                                                   aForceSave, contentLength,
57975:                                                   IPC::URI(referrer));
50771:     ExternalHelperAppChild *childListener = static_cast<ExternalHelperAppChild *>(pc);
50771: 
50771:     NS_ADDREF(*aStreamListener = childListener);
50771: 
53716:     nsRefPtr<nsExternalAppHandler> handler =
87393:       new nsExternalAppHandler(nsnull, EmptyCString(), aWindowContext, this,
87393:                                fileName,
53716:                                reason, aForceSave);
53716:     if (!handler)
53716:       return NS_ERROR_OUT_OF_MEMORY;
53716:     
53716:     childListener->SetHandler(handler);
50771: 
50771:     return NS_OK;
50771:   }
50771: 
    1:   if (channel) {
    1:     // Check if we have a POST request, in which case we don't want to use
    1:     // the url's extension
79445:     bool allowURLExt = true;
    1:     nsCOMPtr<nsIHttpChannel> httpChan = do_QueryInterface(channel);
    1:     if (httpChan) {
    1:       nsCAutoString requestMethod;
    1:       httpChan->GetRequestMethod(requestMethod);
    1:       allowURLExt = !requestMethod.Equals("POST");
    1:     }
    1: 
    1:     // Check if we had a query string - we don't want to check the URL
    1:     // extension if a query is present in the URI
    1:     // If we already know we don't want to check the URL extension, don't
    1:     // bother checking the query
    1:     if (uri && allowURLExt) {
    1:       nsCOMPtr<nsIURL> url = do_QueryInterface(uri);
    1: 
    1:       if (url) {
    1:         nsCAutoString query;
    1: 
    1:         // We only care about the query for HTTP and HTTPS URLs
79445:         bool isHTTP, isHTTPS;
    1:         rv = uri->SchemeIs("http", &isHTTP);
    1:         if (NS_FAILED(rv))
80486:           isHTTP = false;
    1:         rv = uri->SchemeIs("https", &isHTTPS);
    1:         if (NS_FAILED(rv))
80486:           isHTTPS = false;
    1: 
    1:         if (isHTTP || isHTTPS)
    1:           url->GetQuery(query);
    1: 
    1:         // Only get the extension if the query is empty; if it isn't, then the
    1:         // extension likely belongs to a cgi script and isn't helpful
    1:         allowURLExt = query.IsEmpty();
    1:       }
    1:     }
    1:     // Extract name & extension
79445:     bool isAttachment = GetFilenameAndExtensionFromChannel(channel, fileName,
    1:                                                              fileExtension,
    1:                                                              allowURLExt);
    1:     LOG(("Found extension '%s' (filename is '%s', handling attachment: %i)",
    1:          fileExtension.get(), NS_ConvertUTF16toUTF8(fileName).get(),
    1:          isAttachment));
    1:     if (isAttachment)
    1:       reason = nsIHelperAppLauncherDialog::REASON_SERVERREQUEST;
    1:   }
    1: 
    1:   LOG(("HelperAppService::DoContent: mime '%s', extension '%s'\n",
    1:        PromiseFlatCString(aMimeContentType).get(), fileExtension.get()));
    1: 
 8262:   // we get the mime service here even though we're the default implementation of it,
 8262:   // so it's possible to override only the mime service and not need to reimplement the
 8262:   // whole external helper app service itself
 8262:   nsCOMPtr<nsIMIMEService> mimeSvc(do_GetService(NS_MIMESERVICE_CONTRACTID));
 8262:   NS_ENSURE_TRUE(mimeSvc, NS_ERROR_FAILURE);
 8262: 
    1:   // Try to find a mime object by looking at the mime type/extension
    1:   nsCOMPtr<nsIMIMEInfo> mimeInfo;
    1:   if (aMimeContentType.Equals(APPLICATION_GUESS_FROM_EXT, nsCaseInsensitiveCStringComparator())) {
    1:     nsCAutoString mimeType;
    1:     if (!fileExtension.IsEmpty()) {
 8262:       mimeSvc->GetFromTypeAndExtension(EmptyCString(), fileExtension, getter_AddRefs(mimeInfo));
    1:       if (mimeInfo) {
    1:         mimeInfo->GetMIMEType(mimeType);
    1: 
    1:         LOG(("OS-Provided mime type '%s' for extension '%s'\n", 
    1:              mimeType.get(), fileExtension.get()));
    1:       }
    1:     }
    1: 
    1:     if (fileExtension.IsEmpty() || mimeType.IsEmpty()) {
    1:       // Extension lookup gave us no useful match
 8262:       mimeSvc->GetFromTypeAndExtension(NS_LITERAL_CSTRING(APPLICATION_OCTET_STREAM), fileExtension,
    1:                                        getter_AddRefs(mimeInfo));
    1:       mimeType.AssignLiteral(APPLICATION_OCTET_STREAM);
    1:     }
    1:     if (channel)
    1:       channel->SetContentType(mimeType);
    1:     // Don't overwrite SERVERREQUEST
    1:     if (reason == nsIHelperAppLauncherDialog::REASON_CANTHANDLE)
    1:       reason = nsIHelperAppLauncherDialog::REASON_TYPESNIFFED;
    1:   } 
    1:   else {
 8262:     mimeSvc->GetFromTypeAndExtension(aMimeContentType, fileExtension,
    1:                                      getter_AddRefs(mimeInfo));
    1:   } 
    1:   LOG(("Type/Ext lookup found 0x%p\n", mimeInfo.get()));
    1: 
    1:   // No mimeinfo -> we can't continue. probably OOM.
    1:   if (!mimeInfo)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   *aStreamListener = nsnull;
    1:   // We want the mimeInfo's primary extension to pass it to
    1:   // nsExternalAppHandler
    1:   nsCAutoString buf;
    1:   mimeInfo->GetPrimaryExtension(buf);
    1: 
    1:   nsExternalAppHandler * handler = new nsExternalAppHandler(mimeInfo,
    1:                                                             buf,
    1:                                                             aWindowContext,
87393:                                                             this,
    1:                                                             fileName,
13848:                                                             reason,
13848:                                                             aForceSave);
    1:   if (!handler)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*aStreamListener = handler);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::ApplyDecodingForExtension(const nsACString& aExtension,
    1:                                                                     const nsACString& aEncodingType,
79445:                                                                     bool *aApplyDecoding)
    1: {
80486:   *aApplyDecoding = true;
    1:   PRUint32 i;
80467:   for(i = 0; i < ArrayLength(nonDecodableExtensions); ++i) {
    1:     if (aExtension.LowerCaseEqualsASCII(nonDecodableExtensions[i].mFileExtension) &&
    1:         aEncodingType.LowerCaseEqualsASCII(nonDecodableExtensions[i].mMimeType)) {
80486:       *aApplyDecoding = false;
    1:       break;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsExternalHelperAppService::GetFileTokenForPath(const PRUnichar * aPlatformAppPath,
    1:                                                          nsIFile ** aFile)
    1: {
    1:   nsDependentString platformAppPath(aPlatformAppPath);
    1:   // First, check if we have an absolute path
    1:   nsILocalFile* localFile = nsnull;
80486:   nsresult rv = NS_NewLocalFile(platformAppPath, true, &localFile);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     *aFile = localFile;
79445:     bool exists;
    1:     if (NS_FAILED((*aFile)->Exists(&exists)) || !exists) {
    1:       NS_RELEASE(*aFile);
    1:       return NS_ERROR_FILE_NOT_FOUND;
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1: 
    1:   // Second, check if file exists in mozilla program directory
    1:   rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR, aFile);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     rv = (*aFile)->Append(platformAppPath);
    1:     if (NS_SUCCEEDED(rv)) {
79445:       bool exists = false;
    1:       rv = (*aFile)->Exists(&exists);
    1:       if (NS_SUCCEEDED(rv) && exists)
    1:         return NS_OK;
    1:     }
    1:     NS_RELEASE(*aFile);
    1:   }
    1: 
    1: 
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////
    1: // begin external protocol service default implementation...
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////
    1: NS_IMETHODIMP nsExternalHelperAppService::ExternalProtocolHandlerExists(const char * aProtocolScheme,
79445:                                                                         bool * aHandlerExists)
    1: {
 3161:   nsCOMPtr<nsIHandlerInfo> handlerInfo;
11902:   nsresult rv = GetProtocolHandlerInfo(nsDependentCString(aProtocolScheme), 
11902:                                        getter_AddRefs(handlerInfo));
 4428:   NS_ENSURE_SUCCESS(rv, rv);
 4428: 
 5833:   // See if we have any known possible handler apps for this
 5833:   nsCOMPtr<nsIMutableArray> possibleHandlers;
 5833:   handlerInfo->GetPossibleApplicationHandlers(getter_AddRefs(possibleHandlers));
 5833: 
 5833:   PRUint32 length;
 5833:   possibleHandlers->GetLength(&length);
 5833:   if (length) {
80486:     *aHandlerExists = true;
 1859:     return NS_OK;
 1859:   }
 1859: 
 3161:   // if not, fall back on an os-based handler
 1859:   return OSProtocolHandlerExists(aProtocolScheme, aHandlerExists);
    1: }
    1: 
79445: NS_IMETHODIMP nsExternalHelperAppService::IsExposedProtocol(const char * aProtocolScheme, bool * aResult)
    1: {
72898:   // check the per protocol setting first.  it always takes precedence.
72898:   // if not set, then use the global setting.
72898: 
72898:   nsCAutoString prefName("network.protocol-handler.expose.");
72898:   prefName += aProtocolScheme;
79445:   bool val;
72898:   if (NS_SUCCEEDED(Preferences::GetBool(prefName.get(), &val))) {
72898:     *aResult = val;
72898:     return NS_OK;
72898:   }
72898: 
    1:   // by default, no protocol is exposed.  i.e., by default all link clicks must
    1:   // go through the external protocol service.  most applications override this
    1:   // default behavior.
72898:   *aResult =
79445:     Preferences::GetBool("network.protocol-handler.expose-all", false);
72898: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::LoadUrl(nsIURI * aURL)
    1: {
    1:   return LoadURI(aURL, nsnull);
    1: }
    1: 
    1: static const char kExternalProtocolPrefPrefix[]  = "network.protocol-handler.external.";
    1: static const char kExternalProtocolDefaultPref[] = "network.protocol-handler.external-default";
    1: 
 4013: NS_IMETHODIMP 
 4013: nsExternalHelperAppService::LoadURI(nsIURI *aURI,
 4013:                                     nsIInterfaceRequestor *aWindowContext)
    1: {
 4013:   NS_ENSURE_ARG_POINTER(aURI);
    1: 
49349:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
49349:     mozilla::dom::ContentChild::GetSingleton()->SendLoadURIExternal(aURI);
49349:     return NS_OK;
49349:   }
49349: 
 4047:   nsCAutoString spec;
 4047:   aURI->GetSpec(spec);
 4047: 
 4047:   if (spec.Find("%00") != -1)
 4047:     return NS_ERROR_MALFORMED_URI;
 4047: 
 4047:   spec.ReplaceSubstring("\"", "%22");
 4047:   spec.ReplaceSubstring("`", "%60");
 4047:   
 4048:   nsCOMPtr<nsIIOService> ios(do_GetIOService());
 4047:   nsCOMPtr<nsIURI> uri;
 4048:   nsresult rv = ios->NewURI(spec, nsnull, nsnull, getter_AddRefs(uri));
 4047:   NS_ENSURE_SUCCESS(rv, rv);
 4047: 
    1:   nsCAutoString scheme;
 4047:   uri->GetScheme(scheme);
    1:   if (scheme.IsEmpty())
 4013:     return NS_OK; // must have a scheme
    1: 
    1:   // Deny load if the prefs say to do so
    1:   nsCAutoString externalPref(kExternalProtocolPrefPrefix);
    1:   externalPref += scheme;
79445:   bool allowLoad  = false;
72898:   if (NS_FAILED(Preferences::GetBool(externalPref.get(), &allowLoad))) {
    1:     // no scheme-specific value, check the default
72898:     if (NS_FAILED(Preferences::GetBool(kExternalProtocolDefaultPref,
72898:                                        &allowLoad))) {
72898:       return NS_OK; // missing default pref
    1:     }
72898:   }
72898: 
72898:   if (!allowLoad) {
72898:     return NS_OK; // explicitly denied
72898:   }
    1: 
    1:  
 4013:   nsCOMPtr<nsIHandlerInfo> handler;
 4013:   rv = GetProtocolHandlerInfo(scheme, getter_AddRefs(handler));
 4013:   NS_ENSURE_SUCCESS(rv, rv);
 4013: 
 4013:   nsHandlerInfoAction preferredAction;
 4013:   handler->GetPreferredAction(&preferredAction);
79445:   bool alwaysAsk = true;
 4013:   handler->GetAlwaysAskBeforeHandling(&alwaysAsk);
 4013: 
 8605:   // if we are not supposed to ask, and the preferred action is to use
 8605:   // a helper app or the system default, we just launch the URI.
 8605:   if (!alwaysAsk && (preferredAction == nsIHandlerInfo::useHelperApp ||
 4013:                      preferredAction == nsIHandlerInfo::useSystemDefault))
 5588:     return handler->LaunchWithURI(uri, aWindowContext);
 4013:   
 4013:   nsCOMPtr<nsIContentDispatchChooser> chooser =
 4013:     do_CreateInstance("@mozilla.org/content-dispatch-chooser;1", &rv);
 4013:   NS_ENSURE_SUCCESS(rv, rv);
 4013:   
 4047:   return chooser->Ask(handler, aWindowContext, uri,
 4013:                       nsIContentDispatchChooser::REASON_CANNOT_HANDLE);
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::GetApplicationDescription(const nsACString& aScheme, nsAString& _retval)
    1: {
    1:   // this method should only be implemented by each OS specific implementation of this service.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////
    1: // Methods related to deleting temporary files on exit
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::DeleteTemporaryFileOnExit(nsIFile * aTemporaryFile)
    1: {
    1:   nsresult rv = NS_OK;
79445:   bool isFile = false;
    1:   nsCOMPtr<nsILocalFile> localFile (do_QueryInterface(aTemporaryFile, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // as a safety measure, make sure the nsIFile is really a file and not a directory object.
    1:   localFile->IsFile(&isFile);
    1:   if (!isFile) return NS_OK;
    1: 
21635:   if (mInPrivateBrowsing)
21635:     mTemporaryPrivateFilesList.AppendObject(localFile);
21635:   else
    1:     mTemporaryFilesList.AppendObject(localFile);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsExternalHelperAppService::FixFilePermissions(nsILocalFile* aFile)
    1: {
    1:   // This space intentionally left blank
    1: }
    1: 
21635: void nsExternalHelperAppService::ExpungeTemporaryFilesHelper(nsCOMArray<nsILocalFile> &fileList)
    1: {
21635:   PRInt32 numEntries = fileList.Count();
    1:   nsILocalFile* localFile;
    1:   for (PRInt32 index = 0; index < numEntries; index++)
    1:   {
21635:     localFile = fileList[index];
 9992:     if (localFile) {
 9992:       // First make the file writable, since the temp file is probably readonly.
 9992:       localFile->SetPermissions(0600);
80486:       localFile->Remove(false);
    1:     }
 9992:   }
    1: 
21635:   fileList.Clear();
21635: }
    1: 
21635: void nsExternalHelperAppService::ExpungeTemporaryFiles()
21635: {
21635:   ExpungeTemporaryFilesHelper(mTemporaryFilesList);
21635: }
21635: 
21635: void nsExternalHelperAppService::ExpungeTemporaryPrivateFiles()
21635: {
21635:   ExpungeTemporaryFilesHelper(mTemporaryPrivateFilesList);
    1: }
    1: 
 8605: static const char kExternalWarningPrefPrefix[] = 
 8605:   "network.protocol-handler.warn-external.";
 8605: static const char kExternalWarningDefaultPref[] = 
 8605:   "network.protocol-handler.warn-external-default";
 8605: 
 4568: NS_IMETHODIMP
 3161: nsExternalHelperAppService::GetProtocolHandlerInfo(const nsACString &aScheme,
 3161:                                                    nsIHandlerInfo **aHandlerInfo)
 1859: {
 1859:   // XXX enterprise customers should be able to turn this support off with a
 1859:   // single master pref (maybe use one of the "exposed" prefs here?)
 1859: 
79445:   bool exists;
11902:   nsresult rv = GetProtocolHandlerInfoFromOS(aScheme, &exists, aHandlerInfo);
11902:   if (NS_FAILED(rv)) {
 3752:     // Either it knows nothing, or we ran out of memory
 3752:     return NS_ERROR_FAILURE;
 3161:   }
 3161:   
 5657:   nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);
14793:   if (handlerSvc) {
79445:     bool hasHandler = false;
14793:     (void) handlerSvc->Exists(*aHandlerInfo, &hasHandler);
14793:     if (hasHandler) {
 5657:       rv = handlerSvc->FillHandlerInfo(*aHandlerInfo, EmptyCString());
11902:       if (NS_SUCCEEDED(rv))
11902:         return NS_OK;
14793:     }
14793:   }
11902:   
11902:   return SetProtocolHandlerDefaults(*aHandlerInfo, exists);
11902: }
11902: 
11902: NS_IMETHODIMP
11902: nsExternalHelperAppService::GetProtocolHandlerInfoFromOS(const nsACString &aScheme,
79445:                                                          bool *found,
11902:                                                          nsIHandlerInfo **aHandlerInfo)
11902: {
11902:   // intended to be implemented by the subclass
11902:   return NS_ERROR_NOT_IMPLEMENTED;
11902: }
11902: 
11902: NS_IMETHODIMP
11902: nsExternalHelperAppService::SetProtocolHandlerDefaults(nsIHandlerInfo *aHandlerInfo,
79445:                                                        bool aOSHandlerExists)
11902: {
 8605:   // this type isn't in our database, so we've only got an OS default handler,
 8605:   // if one exists
 8605: 
11902:   if (aOSHandlerExists) {
 8605:     // we've got a default, so use it
11902:     aHandlerInfo->SetPreferredAction(nsIHandlerInfo::useSystemDefault);
 8605: 
 8605:     // whether or not to ask the user depends on the warning preference
11902:     nsCAutoString scheme;
11902:     aHandlerInfo->GetType(scheme);
11902:     
 8605:     nsCAutoString warningPref(kExternalWarningPrefPrefix);
11902:     warningPref += scheme;
79445:     bool warn;
72898:     if (NS_FAILED(Preferences::GetBool(warningPref.get(), &warn))) {
 8605:       // no scheme-specific value, check the default
79445:       warn = Preferences::GetBool(kExternalWarningDefaultPref, true);
 8605:     }
11902:     aHandlerInfo->SetAlwaysAskBeforeHandling(warn);
 8605:   } else {
 8605:     // If no OS default existed, we set the preferred action to alwaysAsk. 
 8605:     // This really means not initialized (i.e. there's no available handler)
 8605:     // to all the code...
11902:     aHandlerInfo->SetPreferredAction(nsIHandlerInfo::alwaysAsk);
 8605:   }
 3161: 
 1859:   return NS_OK;
 1859: }
 1859:  
    1: // XPCOM profile change observer
    1: NS_IMETHODIMP
    1: nsExternalHelperAppService::Observe(nsISupports *aSubject, const char *aTopic, const PRUnichar *someData )
    1: {
    1:   if (!strcmp(aTopic, "profile-before-change")) {
    1:     ExpungeTemporaryFiles();
21635:   } else if (!strcmp(aTopic, NS_PRIVATE_BROWSING_SWITCH_TOPIC)) {
21635:     if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_ENTER).Equals(someData))
80486:       mInPrivateBrowsing = true;
21635:     else if (NS_LITERAL_STRING(NS_PRIVATE_BROWSING_LEAVE).Equals(someData)) {
80486:       mInPrivateBrowsing = false;
21635:       ExpungeTemporaryPrivateFiles();
21635:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////
    1: // begin external app handler implementation 
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsExternalAppHandler)
    1: NS_IMPL_THREADSAFE_RELEASE(nsExternalAppHandler)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsExternalAppHandler)
    1:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamListener)
    1:    NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
    1:    NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
    1:    NS_INTERFACE_MAP_ENTRY(nsIHelperAppLauncher)   
    1:    NS_INTERFACE_MAP_ENTRY(nsICancelable)
    1:    NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
    1: NS_INTERFACE_MAP_END_THREADSAFE
    1: 
    1: nsExternalAppHandler::nsExternalAppHandler(nsIMIMEInfo * aMIMEInfo,
    1:                                            const nsCSubstring& aTempFileExtension,
    1:                                            nsIInterfaceRequestor* aWindowContext,
87393:                                            nsExternalHelperAppService *aExtProtSvc,
    1:                                            const nsAString& aSuggestedFilename,
79445:                                            PRUint32 aReason, bool aForceSave)
    1: : mMimeInfo(aMIMEInfo)
    1: , mWindowContext(aWindowContext)
    1: , mWindowToClose(nsnull)
    1: , mSuggestedFileName(aSuggestedFilename)
13848: , mForceSave(aForceSave)
80486: , mCanceled(false)
80486: , mShouldCloseWindow(false)
80486: , mReceivedDispositionInfo(false)
80486: , mStopRequestIssued(false)
80486: , mProgressListenerInitialized(false)
    1: , mReason(aReason)
    1: , mContentLength(-1)
    1: , mProgress(0)
42276: , mDataBuffer(nsnull)
80486: , mKeepRequestAlive(false)
    1: , mRequest(nsnull)
87393: , mExtProtSvc(aExtProtSvc)
    1: {
    1: 
    1:   // make sure the extention includes the '.'
    1:   if (!aTempFileExtension.IsEmpty() && aTempFileExtension.First() != '.')
    1:     mTempFileExtension = PRUnichar('.');
    1:   AppendUTF8toUTF16(aTempFileExtension, mTempFileExtension);
    1: 
    1:   // replace platform specific path separator and illegal characters to avoid any confusion
 2883:   mSuggestedFileName.ReplaceChar(FILE_PATH_SEPARATOR FILE_ILLEGAL_CHARACTERS, '_');
 2883:   mTempFileExtension.ReplaceChar(FILE_PATH_SEPARATOR FILE_ILLEGAL_CHARACTERS, '_');
    1: 
31806:   // Remove unsafe bidi characters which might have spoofing implications (bug 511521).
31806:   const PRUnichar unsafeBidiCharacters[] = {
31806:     PRUnichar(0x202a), // Left-to-Right Embedding
31806:     PRUnichar(0x202b), // Right-to-Left Embedding
31806:     PRUnichar(0x202c), // Pop Directional Formatting
31806:     PRUnichar(0x202d), // Left-to-Right Override
31806:     PRUnichar(0x202e)  // Right-to-Left Override
31806:   };
80467:   for (PRUint32 i = 0; i < ArrayLength(unsafeBidiCharacters); ++i) {
31806:     mSuggestedFileName.ReplaceChar(unsafeBidiCharacters[i], '_');
31806:     mTempFileExtension.ReplaceChar(unsafeBidiCharacters[i], '_');
31806:   }
31806:   
    1:   // Make sure extension is correct.
    1:   EnsureSuggestedFileName();
    1: 
72898:   mBufferSize = Preferences::GetUint("network.buffer.cache.size", 4096);
41031:   mDataBuffer = (char*) malloc(mBufferSize);
41031:   if (!mDataBuffer)
41031:     return;
    1: }
    1: 
    1: nsExternalAppHandler::~nsExternalAppHandler()
    1: {
41031:   if (mDataBuffer)
41031:     free(mDataBuffer);
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::SetWebProgressListener(nsIWebProgressListener2 * aWebProgressListener)
    1: { 
    1:   // this call back means we've successfully brought up the 
    1:   // progress window so set the appropriate flag, even though
    1:   // aWebProgressListener might be null
    1:   
    1:   if (mReceivedDispositionInfo)
80486:     mProgressListenerInitialized = true;
    1: 
    1:   // Go ahead and register the progress listener....
    1:   mWebProgressListener = aWebProgressListener;
    1: 
    1:   // while we were bringing up the progress dialog, we actually finished processing the
    1:   // url. If that's the case then mStopRequestIssued will be true. We need to execute the
    1:   // operation since we are actually done now.
    1:   if (mStopRequestIssued && aWebProgressListener)
    1:   {
    1:     return ExecuteDesiredAction();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::GetTargetFile(nsIFile** aTarget)
    1: {
    1:   if (mFinalFileDestination)
    1:     *aTarget = mFinalFileDestination;
    1:   else
    1:     *aTarget = mTempFile;
    1: 
    1:   NS_IF_ADDREF(*aTarget);
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsExternalAppHandler::GetTargetFileIsExecutable(bool *aExec)
 7284: {
 7284:   // Use the real target if it's been set
 7284:   if (mFinalFileDestination)
 7284:     return mFinalFileDestination->IsExecutable(aExec);
 7284: 
 7284:   // Otherwise, use the stored executable-ness of the temporary
 7284:   *aExec = mTempFileIsExecutable;
 7284:   return NS_OK;
 7284: }
 7284: 
    1: NS_IMETHODIMP nsExternalAppHandler::GetTimeDownloadStarted(PRTime* aTime)
    1: {
    1:   *aTime = mTimeDownloadStarted;
    1:   return NS_OK;
    1: }
    1: 
19873: NS_IMETHODIMP nsExternalAppHandler::GetContentLength(PRInt64 *aContentLength)
19873: {
19873:   *aContentLength = mContentLength;
19873:   return NS_OK;
19873: }
19873: 
    1: NS_IMETHODIMP nsExternalAppHandler::CloseProgressWindow()
    1: {
    1:   // release extra state...
    1:   mWebProgressListener = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: void nsExternalAppHandler::RetargetLoadNotifications(nsIRequest *request)
    1: {
    1:   // we are going to run the downloading of the helper app in our own little docloader / load group context. 
    1:   // so go ahead and force the creation of a load group and doc loader for us to use...
    1:   nsCOMPtr<nsIChannel> aChannel = do_QueryInterface(request);
    1:   if (!aChannel)
    1:     return;
    1: 
    1:   // we need to store off the original (pre redirect!) channel that initiated the load. We do
    1:   // this so later on, we can pass any refresh urls associated with the original channel back to the 
    1:   // window context which started the whole process. More comments about that are listed below....
    1:   // HACK ALERT: it's pretty bogus that we are getting the document channel from the doc loader. 
    1:   // ideally we should be able to just use mChannel (the channel we are extracting content from) or
    1:   // the default load channel associated with the original load group. Unfortunately because
    1:   // a redirect may have occurred, the doc loader is the only one with a ptr to the original channel 
    1:   // which is what we really want....
    1: 
    1:   // Note that we need to do this before removing aChannel from the loadgroup,
    1:   // since that would mess with the original channel on the loader.
    1:   nsCOMPtr<nsIDocumentLoader> origContextLoader =
    1:     do_GetInterface(mWindowContext);
    1:   if (origContextLoader)
    1:     origContextLoader->GetDocumentChannel(getter_AddRefs(mOriginalChannel));
    1: 
    1:   nsCOMPtr<nsILoadGroup> oldLoadGroup;
    1:   aChannel->GetLoadGroup(getter_AddRefs(oldLoadGroup));
    1: 
    1:   if(oldLoadGroup)
    1:      oldLoadGroup->RemoveRequest(request, nsnull, NS_BINDING_RETARGETED);
    1:       
    1:   aChannel->SetLoadGroup(nsnull);
    1:   aChannel->SetNotificationCallbacks(nsnull);
    1: }
    1: 
    1: /**
    1:  * Make mTempFileExtension contain an extension exactly when its previous value
    1:  * is different from mSuggestedFileName's extension, so that it can be appended
    1:  * to mSuggestedFileName and form a valid, useful leaf name.
    1:  * This is required so that the (renamed) temporary file has the correct extension
    1:  * after downloading to make sure the OS will launch the application corresponding
    1:  * to the MIME type (which was used to calculate mTempFileExtension).  This prevents
    1:  * a cgi-script named foobar.exe that returns application/zip from being named
    1:  * foobar.exe and executed as an executable file. It also blocks content that
    1:  * a web site might provide with a content-disposition header indicating
    1:  * filename="foobar.exe" from being downloaded to a file with extension .exe
    1:  * and executed.
    1:  */
    1: void nsExternalAppHandler::EnsureSuggestedFileName()
    1: {
    1:   // Make sure there is a mTempFileExtension (not "" or ".").
    1:   // Remember that mTempFileExtension will always have the leading "."
    1:   // (the check for empty is just to be safe).
    1:   if (mTempFileExtension.Length() > 1)
    1:   {
    1:     // Get mSuggestedFileName's current extension.
    1:     nsAutoString fileExt;
    1:     PRInt32 pos = mSuggestedFileName.RFindChar('.');
    1:     if (pos != kNotFound)
    1:       mSuggestedFileName.Right(fileExt, mSuggestedFileName.Length() - pos);
    1: 
    1:     // Now, compare fileExt to mTempFileExtension.
    1:     if (fileExt.Equals(mTempFileExtension, nsCaseInsensitiveStringComparator()))
    1:     {
    1:       // Matches -> mTempFileExtension can be empty
    1:       mTempFileExtension.Truncate();
    1:     }
    1:   }
    1: }
    1: 
51739: nsresult nsExternalAppHandler::SetUpTempFile(nsIChannel * aChannel)
    1: {
19774:   // First we need to try to get the destination directory for the temporary
19774:   // file.
19774:   nsresult rv = GetDownloadDirectory(getter_AddRefs(mTempFile));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6887:   // At this point, we do not have a filename for the temp file.  For security
 6887:   // purposes, this cannot be predictable, so we must use a cryptographic
 6887:   // quality PRNG to generate one.
 6887:   // We will request raw random bytes, and transform that to a base64 string,
 6887:   // as all characters from the base64 set are acceptable for filenames.  For
 6887:   // each three bytes of random data, we will get four bytes of ASCII.  Request
 6887:   // a bit more, to be safe, and truncate to the length we want in the end.
 6887: 
 6887:   const PRUint32 wantedFileNameLength = 8;
 6887:   const PRUint32 requiredBytesLength =
 6887:     static_cast<PRUint32>((wantedFileNameLength + 1) / 4 * 3);
 6887: 
 6887:   nsCOMPtr<nsIRandomGenerator> rg =
 6887:     do_GetService("@mozilla.org/security/random-generator;1", &rv);
 6887:   NS_ENSURE_SUCCESS(rv, rv);
 6887: 
 6887:   PRUint8 *buffer;
 6887:   rv = rg->GenerateRandomBytes(requiredBytesLength, &buffer);
 6887:   NS_ENSURE_SUCCESS(rv, rv);
 6887: 
 6887:   char *b64 = PL_Base64Encode(reinterpret_cast<const char *>(buffer),
 6887:                               requiredBytesLength, nsnull);
 6887:   NS_Free(buffer);
 6887:   buffer = nsnull;
 6887: 
 6887:   if (!b64)
 6887:     return NS_ERROR_OUT_OF_MEMORY;
 6887: 
 6887:   NS_ASSERTION(strlen(b64) >= wantedFileNameLength,
 6887:                "not enough bytes produced for conversion!");
 6887: 
 6887:   nsCAutoString tempLeafName(b64, wantedFileNameLength);
 6887:   PR_Free(b64);
 6887:   b64 = nsnull;
    1: 
 7311:   // Base64 characters are alphanumeric (a-zA-Z0-9) and '+' and '/', so we need
 7311:   // to replace illegal characters -- notably '/'
 7311:   tempLeafName.ReplaceChar(FILE_PATH_SEPARATOR FILE_ILLEGAL_CHARACTERS, '_');
 7311: 
    1:   // now append our extension.
    1:   nsCAutoString ext;
    1:   mMimeInfo->GetPrimaryExtension(ext);
    1:   if (!ext.IsEmpty()) {
12242:     ext.ReplaceChar(FILE_PATH_SEPARATOR FILE_ILLEGAL_CHARACTERS, '_');
    1:     if (ext.First() != '.')
 6887:       tempLeafName.Append('.');
 6887:     tempLeafName.Append(ext);
    1:   }
    1: 
77504:   // We need to temporarily create a dummy file with the correct
 7284:   // file extension to determine the executable-ness, so do this before adding
 7284:   // the extra .part extension.
 7284:   nsCOMPtr<nsIFile> dummyFile;
 7284:   rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR, getter_AddRefs(dummyFile));
 7284:   NS_ENSURE_SUCCESS(rv, rv);
 7284: 
 7284:   // Set the file name without .part
12242:   rv = dummyFile->Append(NS_ConvertUTF8toUTF16(tempLeafName));
12242:   NS_ENSURE_SUCCESS(rv, rv);
12242:   rv = dummyFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
12242:   NS_ENSURE_SUCCESS(rv, rv);
 7284: 
 7284:   // Store executable-ness then delete
 7284:   dummyFile->IsExecutable(&mTempFileIsExecutable);
80486:   dummyFile->Remove(false);
 7284: 
 5919:   // Add an additional .part to prevent the OS from running this file in the
 5919:   // default application.
 6887:   tempLeafName.Append(NS_LITERAL_CSTRING(".part"));
 5919: 
12242:   rv = mTempFile->Append(NS_ConvertUTF8toUTF16(tempLeafName));
 6887:   // make this file unique!!!
12242:   NS_ENSURE_SUCCESS(rv, rv);
12242:   rv = mTempFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
12242:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 9812:   nsCOMPtr<nsIOutputStream> outputStream;
 9812:   rv = NS_NewLocalFileOutputStream(getter_AddRefs(outputStream), mTempFile,
    1:                                    PR_WRONLY | PR_CREATE_FILE, 0600);
    1:   if (NS_FAILED(rv)) {
80486:     mTempFile->Remove(false);
    1:     return rv;
    1:   }
    1: 
 9812:   mOutStream = NS_BufferOutputStream(outputStream, BUFFERED_OUTPUT_SIZE);
 9812: 
27621: #if defined(XP_MACOSX) && !defined(__LP64__)
    1:     nsCAutoString contentType;
    1:     mMimeInfo->GetMIMEType(contentType);
    1:     if (contentType.LowerCaseEqualsLiteral(APPLICATION_APPLEFILE) ||
    1:         contentType.LowerCaseEqualsLiteral(MULTIPART_APPLEDOUBLE))
    1:     {
    1:       nsCOMPtr<nsIAppleFileDecoder> appleFileDecoder = do_CreateInstance(NS_IAPPLEFILEDECODER_CONTRACTID, &rv);
    1:       if (NS_SUCCEEDED(rv))
    1:       {
    1:         rv = appleFileDecoder->Initialize(mOutStream, mTempFile);
    1:         if (NS_SUCCEEDED(rv))
    1:           mOutStream = do_QueryInterface(appleFileDecoder, &rv);
    1:       }
    1:     }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::OnStartRequest(nsIRequest *request, nsISupports * aCtxt)
    1: {
    1:   NS_PRECONDITION(request, "OnStartRequest without request?");
    1: 
    1:   // Set mTimeDownloadStarted here as the download has already started and
    1:   // we want to record the start time before showing the filepicker.
    1:   mTimeDownloadStarted = PR_Now();
    1: 
    1:   mRequest = request;
    1: 
    1:   nsCOMPtr<nsIChannel> aChannel = do_QueryInterface(request);
    1:   
    1:   nsresult rv;
    1:   
    1:   nsCOMPtr<nsIFileChannel> fileChan(do_QueryInterface(request));
    1:   mIsFileChannel = fileChan != nsnull;
    1: 
51739:   // Get content length
64616:   mContentLength = GetContentLengthAsInt64(request);
51739: 
    1:   nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(request, &rv));
    1:   // Determine whether a new window was opened specifically for this request
    1:   if (props) {
79445:     bool tmp = false;
    1:     props->GetPropertyAsBool(NS_LITERAL_STRING("docshell.newWindowTarget"),
    1:                              &tmp);
    1:     mShouldCloseWindow = tmp;
    1:   }
    1: 
51739:   // Now get the URI
    1:   if (aChannel)
    1:   {
    1:     aChannel->GetURI(getter_AddRefs(mSourceUrl));
    1:   }
    1: 
53716:   // retarget all load notifications to our docloader instead of the original window's docloader...
53716:   RetargetLoadNotifications(request);
53716: 
53716:   // Check to see if there is a refresh header on the original channel.
53716:   if (mOriginalChannel) {
53716:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mOriginalChannel));
53716:     if (httpChannel) {
53716:       nsCAutoString refreshHeader;
53716:       httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("refresh"),
53716:                                      refreshHeader);
53716:       if (!refreshHeader.IsEmpty()) {
80486:         mShouldCloseWindow = false;
53716:       }
53716:     }
53716:   }
53716: 
53716:   // Close the underlying DOMWindow if there is no refresh header
53716:   // and it was opened specifically for the download
53716:   MaybeCloseWindow();
53716: 
53990:   // In an IPC setting, we're allowing the child process, here, to make
53990:   // decisions about decoding the channel (e.g. decompression).  It will
53990:   // still forward the decoded (uncompressed) data back to the parent.
53990:   // Con: Uncompressed data means more IPC overhead.
53990:   // Pros: ExternalHelperAppParent doesn't need to implement nsIEncodedChannel.
53990:   //       Parent process doesn't need to expect CPU time on decompression.
    1:   nsCOMPtr<nsIEncodedChannel> encChannel = do_QueryInterface( aChannel );
    1:   if (encChannel) 
    1:   {
    1:     // Turn off content encoding conversions if needed
79445:     bool applyConversion = true;
    1: 
    1:     nsCOMPtr<nsIURL> sourceURL(do_QueryInterface(mSourceUrl));
    1:     if (sourceURL)
    1:     {
    1:       nsCAutoString extension;
    1:       sourceURL->GetFileExtension(extension);
    1:       if (!extension.IsEmpty())
    1:       {
    1:         nsCOMPtr<nsIUTF8StringEnumerator> encEnum;
    1:         encChannel->GetContentEncodings(getter_AddRefs(encEnum));
    1:         if (encEnum)
    1:         {
79445:           bool hasMore;
    1:           rv = encEnum->HasMore(&hasMore);
    1:           if (NS_SUCCEEDED(rv) && hasMore)
    1:           {
    1:             nsCAutoString encType;
    1:             rv = encEnum->GetNext(encType);
    1:             if (NS_SUCCEEDED(rv) && !encType.IsEmpty())
    1:             {
87393:               mExtProtSvc->ApplyDecodingForExtension(extension, encType,
    1:                                                      &applyConversion);
    1:             }
    1:           }
    1:         }
    1:       }    
    1:     }
    1: 
    1:     encChannel->SetApplyConversion( applyConversion );
    1:   }
    1: 
53990:   // At this point, the child process has done everything it can usefully do
53990:   // for OnStartRequest.
53990:   if (XRE_GetProcessType() == GeckoProcessType_Content)
53990:      return NS_OK;
53990: 
53990:   rv = SetUpTempFile(aChannel);
53990:   if (NS_FAILED(rv)) {
80486:     mCanceled = true;
53990:     request->Cancel(rv);
53990:     nsAutoString path;
53990:     if (mTempFile)
53990:       mTempFile->GetPath(path);
53990:     SendStatusChange(kWriteError, rv, request, path);
53990:     return NS_OK;
53990:   }
53990: 
52366:   // Inform channel it is open on behalf of a download to prevent caching.
52366:   nsCOMPtr<nsIHttpChannelInternal> httpInternal = do_QueryInterface(aChannel);
52366:   if (httpInternal) {
80486:     httpInternal->SetChannelIsForDownload(true);
52366:   }
52366: 
    1:   // now that the temp file is set up, find out if we need to invoke a dialog
    1:   // asking the user what they want us to do with this content...
    1: 
    1:   // We can get here for three reasons: "can't handle", "sniffed type", or
    1:   // "server sent content-disposition:attachment".  In the first case we want
    1:   // to honor the user's "always ask" pref; in the other two cases we want to
    1:   // honor it only if the default action is "save".  Opening attachments in
    1:   // helper apps by default breaks some websites (especially if the attachment
    1:   // is one part of a multipart document).  Opening sniffed content in helper
    1:   // apps by default introduces security holes that we'd rather not have.
    1: 
    1:   // So let's find out whether the user wants to be prompted.  If he does not,
    1:   // check mReason and the preferred action to see what we should do.
    1: 
79445:   bool alwaysAsk = true;
    1:   mMimeInfo->GetAlwaysAskBeforeHandling(&alwaysAsk);
    1:   if (alwaysAsk)
    1:   {
    1:     // But we *don't* ask if this mimeInfo didn't come from
 5657:     // our user configuration datastore and the user has said
    1:     // at some point in the distant past that they don't
    1:     // want to be asked.  The latter fact would have been
    1:     // stored in pref strings back in the old days.
 5657: 
79445:     bool mimeTypeIsInDatastore = false;
 5657:     nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);
 5657:     if (handlerSvc)
 5657:       handlerSvc->Exists(mMimeInfo, &mimeTypeIsInDatastore);
 5657:     if (!handlerSvc || !mimeTypeIsInDatastore)
    1:     {
53716:       nsCAutoString MIMEType;
53716:       mMimeInfo->GetMIMEType(MIMEType);
53716: 
    1:       if (!GetNeverAskFlagFromPref(NEVER_ASK_FOR_SAVE_TO_DISK_PREF, MIMEType.get()))
    1:       {
    1:         // Don't need to ask after all.
80486:         alwaysAsk = false;
    1:         // Make sure action matches pref (save to disk).
    1:         mMimeInfo->SetPreferredAction(nsIMIMEInfo::saveToDisk);
    1:       }
    1:       else if (!GetNeverAskFlagFromPref(NEVER_ASK_FOR_OPEN_FILE_PREF, MIMEType.get()))
    1:       {
    1:         // Don't need to ask after all.
80486:         alwaysAsk = false;
    1:       }
    1:     }
    1:   }
    1: 
    1:   PRInt32 action = nsIMIMEInfo::saveToDisk;
    1:   mMimeInfo->GetPreferredAction( &action );
    1: 
    1:   // OK, now check why we're here
    1:   if (!alwaysAsk && mReason != nsIHelperAppLauncherDialog::REASON_CANTHANDLE) {
    1:     // Force asking if we're not saving.  See comment back when we fetched the
    1:     // alwaysAsk boolean for details.
    1:     alwaysAsk = (action != nsIMIMEInfo::saveToDisk);
    1:   }
    1: 
13848:   // if we were told that we _must_ save to disk without asking, all the stuff
13848:   // before this is irrelevant; override it
13848:   if (mForceSave) {
80486:     alwaysAsk = false;
13848:     action = nsIMIMEInfo::saveToDisk;
13848:   }
13848:   
    1:   if (alwaysAsk)
    1:   {
    1:     // do this first! make sure we don't try to take an action until the user tells us what they want to do
    1:     // with it...
80486:     mReceivedDispositionInfo = false; 
80486:     mKeepRequestAlive = true;
    1: 
    1:     // invoke the dialog!!!!! use mWindowContext as the window context parameter for the dialog request
47253:     mDialog = do_CreateInstance( NS_HELPERAPPLAUNCHERDLG_CONTRACTID, &rv );
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // this will create a reference cycle (the dialog holds a reference to us as
    1:     // nsIHelperAppLauncher), which will be broken in Cancel or
    1:     // CreateProgressListener.
    1:     rv = mDialog->Show( this, mWindowContext, mReason );
    1: 
    1:     // what do we do if the dialog failed? I guess we should call Cancel and abort the load....
    1:   }
    1:   else
    1:   {
80486:     mReceivedDispositionInfo = true; // no need to wait for a response from the user
    1: 
    1:     // We need to do the save/open immediately, then.
    1: #ifdef XP_WIN
    1:     /* We need to see whether the file we've got here could be
    1:      * executable.  If it could, we had better not try to open it!
    1:      * We can skip this check, though, if we have a setting to open in a
    1:      * helper app.
    1:      * This code mirrors the code in
    1:      * nsExternalAppHandler::LaunchWithApplication so that what we
    1:      * test here is as close as possible to what will really be
    1:      * happening if we decide to execute
    1:      */
 3161:     nsCOMPtr<nsIHandlerApp> prefApp;
    1:     mMimeInfo->GetPreferredApplicationHandler(getter_AddRefs(prefApp));
    1:     if (action != nsIMIMEInfo::useHelperApp || !prefApp) {
    1:       nsCOMPtr<nsIFile> fileToTest;
    1:       GetTargetFile(getter_AddRefs(fileToTest));
    1:       if (fileToTest) {
79445:         bool isExecutable;
    1:         rv = fileToTest->IsExecutable(&isExecutable);
    1:         if (NS_FAILED(rv) || isExecutable) {  // checking NS_FAILED, because paranoia is good
    1:           action = nsIMIMEInfo::saveToDisk;
    1:         }
    1:       } else {   // Paranoia is good here too, though this really should not happen
    1:         NS_WARNING("GetDownloadInfo returned a null file after the temp file has been set up! ");
    1:         action = nsIMIMEInfo::saveToDisk;
    1:       }
    1:     }
    1: 
    1: #endif
    1:     if (action == nsIMIMEInfo::useHelperApp ||
    1:         action == nsIMIMEInfo::useSystemDefault)
    1:     {
80486:         rv = LaunchWithApplication(nsnull, false);
    1:     }
    1:     else // Various unknown actions go here too
    1:     {
80486:         rv = SaveToDisk(nsnull, false);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Convert error info into proper message text and send OnStatusChange notification
    1: // to the web progress listener.
    1: void nsExternalAppHandler::SendStatusChange(ErrorType type, nsresult rv, nsIRequest *aRequest, const nsAFlatString &path)
    1: {
    1:     nsAutoString msgId;
    1:     switch(rv)
    1:     {
    1:     case NS_ERROR_OUT_OF_MEMORY:
    1:         // No memory
    1:         msgId.AssignLiteral("noMemory");
    1:         break;
    1: 
    1:     case NS_ERROR_FILE_DISK_FULL:
    1:     case NS_ERROR_FILE_NO_DEVICE_SPACE:
    1:         // Out of space on target volume.
    1:         msgId.AssignLiteral("diskFull");
    1:         break;
    1: 
    1:     case NS_ERROR_FILE_READ_ONLY:
    1:         // Attempt to write to read/only file.
    1:         msgId.AssignLiteral("readOnly");
    1:         break;
    1: 
    1:     case NS_ERROR_FILE_ACCESS_DENIED:
    1:         if (type == kWriteError) {
    1:           // Attempt to write without sufficient permissions.
    1:           msgId.AssignLiteral("accessError");
    1:         }
    1:         else
    1:         {
    1:           msgId.AssignLiteral("launchError");
    1:         }
    1:         break;
    1: 
    1:     case NS_ERROR_FILE_NOT_FOUND:
    1:     case NS_ERROR_FILE_TARGET_DOES_NOT_EXIST:
    1:     case NS_ERROR_FILE_UNRECOGNIZED_PATH:
    1:         // Helper app not found, let's verify this happened on launch
    1:         if (type == kLaunchError) {
    1:           msgId.AssignLiteral("helperAppNotFound");
    1:           break;
    1:         }
    1:         // fall through
    1: 
    1:     default:
    1:         // Generic read/write/launch error message.
    1:         switch(type)
    1:         {
    1:         case kReadError:
    1:           msgId.AssignLiteral("readError");
    1:           break;
    1:         case kWriteError:
    1:           msgId.AssignLiteral("writeError");
    1:           break;
    1:         case kLaunchError:
    1:           msgId.AssignLiteral("launchError");
    1:           break;
    1:         }
    1:         break;
    1:     }
    1:     PR_LOG(nsExternalHelperAppService::mLog, PR_LOG_ERROR,
    1:         ("Error: %s, type=%i, listener=0x%p, rv=0x%08X\n",
    1:          NS_LossyConvertUTF16toASCII(msgId).get(), type, mWebProgressListener.get(), rv));
    1:     PR_LOG(nsExternalHelperAppService::mLog, PR_LOG_ERROR,
    1:         ("       path='%s'\n", NS_ConvertUTF16toUTF8(path).get()));
    1: 
    1:     // Get properties file bundle and extract status string.
42314:     nsCOMPtr<nsIStringBundleService> stringService =
42314:         mozilla::services::GetStringBundleService();
42314:     if (stringService)
    1:     {
    1:         nsCOMPtr<nsIStringBundle> bundle;
42314:         if (NS_SUCCEEDED(stringService->CreateBundle("chrome://global/locale/nsWebBrowserPersist.properties", getter_AddRefs(bundle))))
    1:         {
    1:             nsXPIDLString msgText;
    1:             const PRUnichar *strings[] = { path.get() };
    1:             if(NS_SUCCEEDED(bundle->FormatStringFromName(msgId.get(), strings, 1, getter_Copies(msgText))))
    1:             {
    1:               if (mWebProgressListener)
    1:               {
    1:                 // We have a listener, let it handle the error.
    1:                 mWebProgressListener->OnStatusChange(nsnull, (type == kReadError) ? aRequest : nsnull, rv, msgText);
    1:               }
    1:               else
67579:               if (XRE_GetProcessType() == GeckoProcessType_Default) {
    1:                 // We don't have a listener.  Simply show the alert ourselves.
    1:                 nsCOMPtr<nsIPrompt> prompter(do_GetInterface(mWindowContext));
    1:                 nsXPIDLString title;
    1:                 bundle->FormatStringFromName(NS_LITERAL_STRING("title").get(),
    1:                                              strings,
    1:                                              1,
    1:                                              getter_Copies(title));
    1:                 if (prompter)
    1:                 {
    1:                   prompter->Alert(title, msgText);
    1:                 }
    1:               }
    1:             }
    1:         }
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::OnDataAvailable(nsIRequest *request, nsISupports * aCtxt,
    1:                                                   nsIInputStream * inStr, PRUint32 sourceOffset, PRUint32 count)
    1: {
    1:   nsresult rv = NS_OK;
    1:   // first, check to see if we've been canceled....
41031:   if (mCanceled || !mDataBuffer) // then go cancel our underlying channel too
    1:     return request->Cancel(NS_BINDING_ABORTED);
    1: 
    1:   // read the data out of the stream and write it to the temp file.
    1:   if (mOutStream && count > 0)
    1:   {
    1:     PRUint32 numBytesRead = 0; 
    1:     PRUint32 numBytesWritten = 0;
    1:     mProgress += count;
79445:     bool readError = true;
    1:     while (NS_SUCCEEDED(rv) && count > 0) // while we still have bytes to copy...
    1:     {
80486:       readError = true;
71173:       rv = inStr->Read(mDataBuffer, NS_MIN(count, mBufferSize - 1), &numBytesRead);
    1:       if (NS_SUCCEEDED(rv))
    1:       {
    1:         if (count >= numBytesRead)
    1:           count -= numBytesRead; // subtract off the number of bytes we just read
    1:         else
    1:           count = 0;
80486:         readError = false;
    1:         // Write out the data until something goes wrong, or, it is
    1:         // all written.  We loop because for some errors (e.g., disk
    1:         // full), we get NS_OK with some bytes written, then an error.
    1:         // So, we want to write again in that case to get the actual
    1:         // error code.
    1:         const char *bufPtr = mDataBuffer; // Where to write from.
    1:         while (NS_SUCCEEDED(rv) && numBytesRead)
    1:         {
    1:           numBytesWritten = 0;
    1:           rv = mOutStream->Write(bufPtr, numBytesRead, &numBytesWritten);
    1:           if (NS_SUCCEEDED(rv))
    1:           {
    1:             numBytesRead -= numBytesWritten;
    1:             bufPtr += numBytesWritten;
    1:             // Force an error if (for some reason) we get NS_OK but
    1:             // no bytes written.
    1:             if (!numBytesWritten)
    1:             {
    1:               rv = NS_ERROR_FAILURE;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:     if (NS_SUCCEEDED(rv))
    1:     {
    1:       // Send progress notification.
    1:       if (mWebProgressListener)
    1:       {
    1:         mWebProgressListener->OnProgressChange64(nsnull, request, mProgress, mContentLength, mProgress, mContentLength);
    1:       }
    1:     }
    1:     else
    1:     {
    1:       // An error occurred, notify listener.
    1:       nsAutoString tempFilePath;
    1:       if (mTempFile)
    1:         mTempFile->GetPath(tempFilePath);
    1:       SendStatusChange(readError ? kReadError : kWriteError, rv, request, tempFilePath);
    1: 
    1:       // Cancel the download.
    1:       Cancel(rv);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::OnStopRequest(nsIRequest *request, nsISupports *aCtxt, 
    1:                                                   nsresult aStatus)
    1: {
80486:   mStopRequestIssued = true;
63539: 
63539:   if (!mKeepRequestAlive)
    1:     mRequest = nsnull;
63539: 
    1:   // Cancel if the request did not complete successfully.
    1:   if (!mCanceled && NS_FAILED(aStatus))
    1:   {
    1:     // Send error notification.
    1:     nsAutoString tempFilePath;
    1:     if (mTempFile)
    1:       mTempFile->GetPath(tempFilePath);
    1:     SendStatusChange( kReadError, aStatus, request, tempFilePath );
    1: 
    1:     Cancel(aStatus);
    1:   }
    1: 
    1:   // first, check to see if we've been canceled....
    1:   if (mCanceled)
    1:     return NS_OK;
    1: 
    1:   // close the stream...
    1:   if (mOutStream)
    1:   {
    1:     mOutStream->Close();
    1:     mOutStream = nsnull;
    1:   }
    1: 
    1:   // Do what the user asked for
    1:   ExecuteDesiredAction();
    1: 
    1:   // At this point, the channel should still own us. So releasing the reference
    1:   // to us in the nsITransfer should be ok.
    1:   // This nsITransfer object holds a reference to us (we are its observer), so
    1:   // we need to release the reference to break a reference cycle (and therefore
    1:   // to prevent leaking)
    1:   mWebProgressListener = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsExternalAppHandler::ExecuteDesiredAction()
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (mProgressListenerInitialized && !mCanceled)
    1:   {
56356:     rv = MoveFile(mFinalFileDestination);
56356:     if (NS_SUCCEEDED(rv))
56356:     {
 3161:       nsHandlerInfoAction action = nsIMIMEInfo::saveToDisk;
    1:       mMimeInfo->GetPreferredAction(&action);
    1:       if (action == nsIMIMEInfo::useHelperApp ||
    1:           action == nsIMIMEInfo::useSystemDefault)
    1:       {
    1:         rv = OpenWithApplication();
    1:       }
56356:       else if(action == nsIMIMEInfo::saveToDisk)
    1:       {
    1:         nsCOMPtr<nsILocalFile> destfile(do_QueryInterface(mFinalFileDestination));
87393:         mExtProtSvc->FixFilePermissions(destfile);
    1:       }
    1:     }
    1: 
    1:     // Notify dialog that download is complete.
    1:     // By waiting till this point, it ensures that the progress dialog doesn't indicate
    1:     // success until we're really done.
    1:     if(mWebProgressListener)
    1:     {
    1:       if (!mCanceled)
    1:       {
    1:         mWebProgressListener->OnProgressChange64(nsnull, nsnull, mProgress, mContentLength, mProgress, mContentLength);
    1:       }
10818:       mWebProgressListener->OnStateChange(nsnull, nsnull,
10818:         nsIWebProgressListener::STATE_STOP |
10818:         nsIWebProgressListener::STATE_IS_REQUEST |
10818:         nsIWebProgressListener::STATE_IS_NETWORK, NS_OK);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::GetMIMEInfo(nsIMIMEInfo ** aMIMEInfo)
    1: {
    1:   *aMIMEInfo = mMimeInfo;
    1:   NS_ADDREF(*aMIMEInfo);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::GetSource(nsIURI ** aSourceURI)
    1: {
    1:   NS_ENSURE_ARG(aSourceURI);
    1:   *aSourceURI = mSourceUrl;
    1:   NS_IF_ADDREF(*aSourceURI);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::GetSuggestedFileName(nsAString& aSuggestedFileName)
    1: {
    1:   aSuggestedFileName = mSuggestedFileName;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsExternalAppHandler::InitializeDownload(nsITransfer* aTransfer)
    1: {
    1:   nsresult rv;
    1:   
    1:   nsCOMPtr<nsIURI> target;
    1:   rv = NS_NewFileURI(getter_AddRefs(target), mFinalFileDestination);
    1:   if (NS_FAILED(rv)) return rv;
    1:   
    1:   nsCOMPtr<nsILocalFile> lf(do_QueryInterface(mTempFile));
    1:   rv = aTransfer->Init(mSourceUrl, target, EmptyString(),
    1:                        mMimeInfo, mTimeDownloadStarted, lf, this);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
83051:   // Now let's add the download to history
83051:   nsCOMPtr<nsIDownloadHistory> dh(do_GetService(NS_DOWNLOADHISTORY_CONTRACTID));
83051:   if (dh) {
83051:     nsCOMPtr<nsIURI> referrer;
83051:     if (mRequest) {
83051:       nsCOMPtr<nsIChannel> channel = do_QueryInterface(mRequest);
83051:       NS_GetReferrerFromChannel(channel, getter_AddRefs(referrer));
83051:     }
83051: 
83051:     dh->AddDownload(mSourceUrl, referrer, mTimeDownloadStarted, target);
83051:   }
83051: 
    1:   return rv;
    1: }
    1: 
    1: nsresult nsExternalAppHandler::CreateProgressListener()
    1: {
    1:   // we are back from the helper app dialog (where the user chooses to save or open), but we aren't
    1:   // done processing the load. in this case, throw up a progress dialog so the user can see what's going on...
    1:   // Also, release our reference to mDialog. We don't need it anymore, and we
    1:   // need to break the reference cycle.
    1:   mDialog = nsnull;
    1:   nsresult rv;
    1:   
    1:   nsCOMPtr<nsITransfer> tr = do_CreateInstance(NS_TRANSFER_CONTRACTID, &rv);
    1:   if (NS_SUCCEEDED(rv))
    1:     InitializeDownload(tr);
    1: 
    1:   if (tr)
10818:     tr->OnStateChange(nsnull, mRequest, nsIWebProgressListener::STATE_START |
10818:       nsIWebProgressListener::STATE_IS_REQUEST |
10818:       nsIWebProgressListener::STATE_IS_NETWORK, NS_OK);
    1: 
    1:   // note we might not have a listener here if the QI() failed, or if
    1:   // there is no nsITransfer object, but we still call
    1:   // SetWebProgressListener() to make sure our progress state is sane
    1:   // NOTE: This will set up a reference cycle (this nsITransfer has us set up as
    1:   // its observer). This cycle will be broken in Cancel, CloseProgressWindow or
    1:   // OnStopRequest.
    1:   SetWebProgressListener(tr);
    1: 
63539:   mRequest = nsnull;
63539: 
    1:   return rv;
    1: }
    1: 
    1: nsresult nsExternalAppHandler::PromptForSaveToFile(nsILocalFile ** aNewFile, const nsAFlatString &aDefaultFile, const nsAFlatString &aFileExtension)
    1: {
    1:   // invoke the dialog!!!!! use mWindowContext as the window context parameter for the dialog request
    1:   // Convert to use file picker? No, then embeddors could not do any sort of
    1:   // "AutoDownload" w/o showing a prompt
    1:   nsresult rv = NS_OK;
    1:   if (!mDialog)
    1:   {
    1:     // Get helper app launcher dialog.
47253:     mDialog = do_CreateInstance( NS_HELPERAPPLAUNCHERDLG_CONTRACTID, &rv );
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // we want to explicitly unescape aDefaultFile b4 passing into the dialog. we can't unescape
    1:   // it because the dialog is implemented by a JS component which doesn't have a window so no unescape routine is defined...
    1: 
    1:   // Now, be sure to keep |this| alive, and the dialog
    1:   // If we don't do this, users that close the helper app dialog while the file
    1:   // picker is up would cause Cancel() to be called, and the dialog would be
    1:   // released, which would release this object too, which would crash.
    1:   // See Bug 249143
    1:   nsRefPtr<nsExternalAppHandler> kungFuDeathGrip(this);
    1:   nsCOMPtr<nsIHelperAppLauncherDialog> dlg(mDialog);
    1:   rv = mDialog->PromptForSaveToFile(this, 
    1:                                     mWindowContext,
    1:                                     aDefaultFile.get(),
    1:                                     aFileExtension.get(),
13848:                                     mForceSave, aNewFile);
    1:   return rv;
    1: }
    1: 
    1: nsresult nsExternalAppHandler::MoveFile(nsIFile * aNewFileLocation)
    1: {
    1:   nsresult rv = NS_OK;
    1:   NS_ASSERTION(mStopRequestIssued, "uhoh, how did we get here if we aren't done getting data?");
    1:  
    1:   nsCOMPtr<nsILocalFile> fileToUse = do_QueryInterface(aNewFileLocation);
    1: 
    1:   // if the on stop request was actually issued then it's now time to actually perform the file move....
    1:   if (mStopRequestIssued && fileToUse)
    1:   {
    1:     // Unfortunately, MoveTo will fail if a file already exists at the user specified location....
    1:     // but the user has told us, this is where they want the file! (when we threw up the save to file dialog,
    1:     // it told them the file already exists and do they wish to over write it. So it should be okay to delete
    1:     // fileToUse if it already exists.
79445:     bool equalToTempFile = false;
79445:     bool filetoUseAlreadyExists = false;
    1:     fileToUse->Equals(mTempFile, &equalToTempFile);
    1:     fileToUse->Exists(&filetoUseAlreadyExists);
    1:     if (filetoUseAlreadyExists && !equalToTempFile)
80486:       fileToUse->Remove(false);
    1: 
    1:      // extract the new leaf name from the file location
    1:      nsAutoString fileName;
    1:      fileToUse->GetLeafName(fileName);
    1:      nsCOMPtr<nsIFile> directoryLocation;
    1:      rv = fileToUse->GetParent(getter_AddRefs(directoryLocation));
    1:      if (directoryLocation)
    1:      {
    1:        rv = mTempFile->MoveTo(directoryLocation, fileName);
    1:      }
    1:      if (NS_FAILED(rv))
    1:      {
    1:        // Send error notification.        
    1:        nsAutoString path;
    1:        fileToUse->GetPath(path);
    1:        SendStatusChange(kWriteError, rv, nsnull, path);
    1:        Cancel(rv); // Cancel (and clean up temp file).
    1:      }
    1: #if defined(XP_OS2)
    1:      else
    1:      {
    1:        // tag the file with its source URI
    1:        nsCOMPtr<nsILocalFileOS2> localFileOS2 = do_QueryInterface(fileToUse);
    1:        if (localFileOS2)
    1:        {
    1:          nsCAutoString url;
    1:          mSourceUrl->GetSpec(url);
    1:          localFileOS2->SetFileSource(url);
    1:        }
    1:      }
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // SaveToDisk should only be called by the helper app dialog which allows
    1: // the user to say launch with application or save to disk. It doesn't actually 
    1: // perform the save, it just prompts for the destination file name. The actual save
    1: // won't happen until we are done downloading the content and are sure we've 
    1: // shown a progress dialog. This was done to simplify the 
    1: // logic that was showing up in this method. Internal callers who actually want
    1: // to preform the save should call ::MoveFile
    1: 
79445: NS_IMETHODIMP nsExternalAppHandler::SaveToDisk(nsIFile * aNewFileLocation, bool aRememberThisPreference)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (mCanceled)
    1:     return NS_OK;
    1: 
    1:   mMimeInfo->SetPreferredAction(nsIMIMEInfo::saveToDisk);
    1: 
    1:   // The helper app dialog has told us what to do.
80486:   mReceivedDispositionInfo = true;
    1: 
    1:   nsCOMPtr<nsILocalFile> fileToUse = do_QueryInterface(aNewFileLocation);
    1:   if (!fileToUse)
    1:   {
    1:     nsAutoString leafName;
    1:     mTempFile->GetLeafName(leafName);
    1:     if (mSuggestedFileName.IsEmpty())
    1:       rv = PromptForSaveToFile(getter_AddRefs(fileToUse), leafName, mTempFileExtension);
    1:     else
    1:     {
    1:       nsAutoString fileExt;
    1:       PRInt32 pos = mSuggestedFileName.RFindChar('.');
    1:       if (pos >= 0)
    1:         mSuggestedFileName.Right(fileExt, mSuggestedFileName.Length() - pos);
    1:       if (fileExt.IsEmpty())
    1:         fileExt = mTempFileExtension;
    1: 
    1:       rv = PromptForSaveToFile(getter_AddRefs(fileToUse), mSuggestedFileName, fileExt);
    1:     }
    1: 
    1:     if (NS_FAILED(rv) || !fileToUse) {
    1:       Cancel(NS_BINDING_ABORTED);
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   
    1:   mFinalFileDestination = do_QueryInterface(fileToUse);
    1: 
    1:   // Move what we have in the final directory, but append .part
    1:   // to it, to indicate that it's unfinished.
    1:   // do not do that if we're already done
    1:   if (mFinalFileDestination && !mStopRequestIssued)
    1:   {
    1:     nsCOMPtr<nsIFile> movedFile;
    1:     mFinalFileDestination->Clone(getter_AddRefs(movedFile));
    1:     if (movedFile) {
    1:       // Get the old leaf name and append .part to it
    1:       nsAutoString name;
    1:       mFinalFileDestination->GetLeafName(name);
    1:       name.AppendLiteral(".part");
    1:       movedFile->SetLeafName(name);
    1: 
    1:       nsCOMPtr<nsIFile> dir;
    1:       movedFile->GetParent(getter_AddRefs(dir));
    1: 
    1:       mOutStream->Close();
    1: 
    1:       rv = mTempFile->MoveTo(dir, name);
    1:       if (NS_SUCCEEDED(rv)) // if it failed, we just continue with $TEMP
    1:         mTempFile = movedFile;
 9812: 
 9812:       nsCOMPtr<nsIOutputStream> outputStream;
 9812:       rv = NS_NewLocalFileOutputStream(getter_AddRefs(outputStream), mTempFile,
    1:                                        PR_WRONLY | PR_APPEND, 0600);
    1:       if (NS_FAILED(rv)) { // (Re-)opening the output stream failed. bad luck.
    1:         nsAutoString path;
    1:         mTempFile->GetPath(path);
    1:         SendStatusChange(kWriteError, rv, nsnull, path);
    1:         Cancel(rv);
    1:         return NS_OK;
    1:       }
 9812: 
 9812:       mOutStream = NS_BufferOutputStream(outputStream, BUFFERED_OUTPUT_SIZE);
    1:     }
    1:   }
    1: 
    1:   if (!mProgressListenerInitialized)
    1:     CreateProgressListener();
    1: 
    1:   // now that the user has chosen the file location to save to, it's okay to fire the refresh tag
    1:   // if there is one. We don't want to do this before the save as dialog goes away because this dialog
    1:   // is modal and we do bad things if you try to load a web page in the underlying window while a modal
    1:   // dialog is still up. 
    1:   ProcessAnyRefreshTags();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult nsExternalAppHandler::OpenWithApplication()
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (mCanceled)
    1:     return NS_OK;
    1:   
    1:   // we only should have gotten here if the on stop request had been fired already.
    1: 
    1:   NS_ASSERTION(mStopRequestIssued, "uhoh, how did we get here if we aren't done getting data?");
    1:   // if a stop request was already issued then proceed with launching the application.
    1:   if (mStopRequestIssued)
    1:   {
72898: 
72898:     // Note for the default value:
12215:     // Mac users have been very verbal about temp files being deleted on
12215:     // app exit - they don't like it - but we'll continue to do this on
12215:     // other platforms for now.
79445:     bool deleteTempFileOnExit =
72898:       Preferences::GetBool("browser.helperApps.deleteTempFileOnExit",
72898: #if !defined(XP_MACOSX)
79445:                            true);
12215: #else
79445:                            false);
12215: #endif
12215: 
 5891:     // make the tmp file readonly so users won't edit it and lose the changes
12215:     // only if we're going to delete the file
87393:     if (deleteTempFileOnExit || mExtProtSvc->InPrivateBrowsing())
 5891:       mFinalFileDestination->SetPermissions(0400);
 5891: 
 4841:     rv = mMimeInfo->LaunchWithFile(mFinalFileDestination);
    1:     if (NS_FAILED(rv))
    1:     {
    1:       // Send error notification.
    1:       nsAutoString path;
    1:       mFinalFileDestination->GetPath(path);
    1:       SendStatusChange(kLaunchError, rv, nsnull, path);
    1:       Cancel(rv); // Cancel, and clean up temp file.
    1:     }
22086:     // Always schedule files to be deleted at the end of the private browsing
22086:     // mode, regardless of the value of the pref.
87393:     else if (deleteTempFileOnExit || mExtProtSvc->InPrivateBrowsing()) {
87393:       mExtProtSvc->DeleteTemporaryFileOnExit(mFinalFileDestination);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // LaunchWithApplication should only be called by the helper app dialog which allows
    1: // the user to say launch with application or save to disk. It doesn't actually 
    1: // perform launch with application. That won't happen until we are done downloading
    1: // the content and are sure we've shown a progress dialog. This was done to simplify the 
    1: // logic that was showing up in this method. 
79445: NS_IMETHODIMP nsExternalAppHandler::LaunchWithApplication(nsIFile * aApplication, bool aRememberThisPreference)
    1: {
    1:   if (mCanceled)
    1:     return NS_OK;
    1: 
    1:   // user has chosen to launch using an application, fire any refresh tags now...
    1:   ProcessAnyRefreshTags(); 
    1:   
80486:   mReceivedDispositionInfo = true; 
 3161:   if (mMimeInfo && aApplication) {
 6644:     PlatformLocalHandlerApp_t *handlerApp =
 6644:       new PlatformLocalHandlerApp_t(EmptyString(), aApplication);
 3161:     mMimeInfo->SetPreferredApplicationHandler(handlerApp);
 3161:   }
    1: 
    1:   // Now check if the file is local, in which case we won't bother with saving
    1:   // it to a temporary directory and just launch it from where it is
    1:   nsCOMPtr<nsIFileURL> fileUrl(do_QueryInterface(mSourceUrl));
    1:   if (fileUrl && mIsFileChannel)
    1:   {
    1:     Cancel(NS_BINDING_ABORTED);
    1:     nsCOMPtr<nsIFile> file;
    1:     nsresult rv = fileUrl->GetFile(getter_AddRefs(file));
    1: 
    1:     if (NS_SUCCEEDED(rv))
    1:     {
 4841:       rv = mMimeInfo->LaunchWithFile(file);
    1:       if (NS_SUCCEEDED(rv))
    1:         return NS_OK;
    1:     }
    1:     nsAutoString path;
    1:     if (file)
    1:       file->GetPath(path);
    1:     // If we get here, an error happened
    1:     SendStatusChange(kLaunchError, rv, nsnull, path);
    1:     return rv;
    1:   }
    1: 
    1:   // Now that the user has elected to launch the downloaded file with a helper app, we're justified in
    1:   // removing the 'salted' name.  We'll rename to what was specified in mSuggestedFileName after the
    1:   // download is done prior to launching the helper app.  So that any existing file of that name won't
    1:   // be overwritten we call CreateUnique() before calling MoveFile().  Also note that we use the same
    1:   // directory as originally downloaded to so that MoveFile() just does an in place rename.
    1: 
    1:   nsCOMPtr<nsIFile> fileToUse;
19774:   (void) GetDownloadDirectory(getter_AddRefs(fileToUse));
    1: 
    1:   if (mSuggestedFileName.IsEmpty())
    1:   {
    1:     // Keep using the leafname of the temp file, since we're just starting a helper
    1:     mTempFile->GetLeafName(mSuggestedFileName);
    1:   }
    1: 
    1: #ifdef XP_WIN
    1:   fileToUse->Append(mSuggestedFileName + mTempFileExtension);
    1: #else
    1:   fileToUse->Append(mSuggestedFileName);  
    1: #endif
    1: 
56356:   nsresult rv = fileToUse->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
56356:   if(NS_SUCCEEDED(rv))
56356:   {
    1:     mFinalFileDestination = do_QueryInterface(fileToUse);
    1:     // launch the progress window now that the user has picked the desired action.
    1:     if (!mProgressListenerInitialized)
    1:       CreateProgressListener();
56356:   }
56356:   else
56356:   {
56356:     // Cancel the download and report an error.  We do not want to end up in
56356:     // a state where it appears that we have a normal download that is
56356:     // pointing to a file that we did not actually create.
56356:     nsAutoString path;
56356:     mTempFile->GetPath(path);
56356:     SendStatusChange(kWriteError, rv, nsnull, path);
56356:     Cancel(rv);
56356:   }
56356:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalAppHandler::Cancel(nsresult aReason)
    1: {
    1:   NS_ENSURE_ARG(NS_FAILED(aReason));
    1:   // XXX should not ignore the reason
    1: 
80486:   mCanceled = true;
    1:   // Break our reference cycle with the helper app dialog (set up in
    1:   // OnStartRequest)
    1:   mDialog = nsnull;
63539: 
63539:   mRequest = nsnull;
63539: 
    1:   // shutdown our stream to the temp file
    1:   if (mOutStream)
    1:   {
    1:     mOutStream->Close();
    1:     mOutStream = nsnull;
    1:   }
    1: 
 7143:   // Clean up after ourselves and delete the temp file only if the user
 7143:   // canceled the helper app dialog (we didn't get the disposition info yet).
 7143:   // We leave the partial file for everything else because it could be useful
 7143:   // e.g., resume a download
 7143:   if (mTempFile && !mReceivedDispositionInfo)
    1:   {
80486:     mTempFile->Remove(false);
    1:     mTempFile = nsnull;
    1:   }
    1: 
58404:   // If we have already created a final destination file, we remove it as well
58404:   if (mFinalFileDestination)
58404:   {
80486:     mFinalFileDestination->Remove(false);
58404:     mFinalFileDestination = nsnull;
58404:   }
58404: 
    1:   // Release the listener, to break the reference cycle with it (we are the
    1:   // observer of the listener).
    1:   mWebProgressListener = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsExternalAppHandler::ProcessAnyRefreshTags()
    1: {
    1:    // one last thing, try to see if the original window context supports a refresh interface...
    1:    // Sometimes, when you download content that requires an external handler, there is
    1:    // a refresh header associated with the download. This refresh header points to a page
    1:    // the content provider wants the user to see after they download the content. How do we
    1:    // pass this refresh information back to the caller? For now, try to get the refresh URI 
    1:    // interface. If the window context where the request originated came from supports this
    1:    // then we can force it to process the refresh information (if there is any) from this channel.
    1:    if (mWindowContext && mOriginalChannel)
    1:    {
    1:      nsCOMPtr<nsIRefreshURI> refreshHandler (do_GetInterface(mWindowContext));
    1:      if (refreshHandler) {
    1:         refreshHandler->SetupRefreshURI(mOriginalChannel);
    1:      }
    1:      mOriginalChannel = nsnull;
    1:    }
    1: }
    1: 
79445: bool nsExternalAppHandler::GetNeverAskFlagFromPref(const char * prefName, const char * aContentType)
    1: {
    1:   // Search the obsolete pref strings.
72898:   nsAdoptingCString prefCString = Preferences::GetCString(prefName);
72898:   if (prefCString.IsEmpty()) {
72898:     // Default is true, if not found in the pref string.
80486:     return true;
72898:   }
72898: 
    1:   NS_UnescapeURL(prefCString);
    1:   nsACString::const_iterator start, end;
    1:   prefCString.BeginReading(start);
    1:   prefCString.EndReading(end);
72898:   return !CaseInsensitiveFindInReadable(nsDependentCString(aContentType),
72898:                                         start, end);
    1: }
    1: 
    1: nsresult nsExternalAppHandler::MaybeCloseWindow()
    1: {
73870:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mWindowContext);
73870:   NS_ENSURE_STATE(window);
    1: 
    1:   if (mShouldCloseWindow) {
    1:     // Reset the window context to the opener window so that the dependent
    1:     // dialogs have a parent
73870:     nsCOMPtr<nsIDOMWindow> opener;
73870:     window->GetOpener(getter_AddRefs(opener));
    1: 
79445:     bool isClosed;
 7048:     if (opener && NS_SUCCEEDED(opener->GetClosed(&isClosed)) && !isClosed) {
    1:       mWindowContext = do_GetInterface(opener);
    1: 
    1:       // Now close the old window.  Do it on a timer so that we don't run
    1:       // into issues trying to close the window before it has fully opened.
    1:       NS_ASSERTION(!mTimer, "mTimer was already initialized once!");
    1:       mTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:       if (!mTimer) {
    1:         return NS_ERROR_FAILURE;
    1:       }
    1: 
    1:       mTimer->InitWithCallback(this, 0, nsITimer::TYPE_ONE_SHOT);
73870:       mWindowToClose = window;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsExternalAppHandler::Notify(nsITimer* timer)
    1: {
    1:   NS_ASSERTION(mWindowToClose, "No window to close after timer fired");
    1: 
    1:   mWindowToClose->Close();
    1:   mWindowToClose = nsnull;
    1:   mTimer = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    1: // The following section contains our nsIMIMEService implementation and related methods.
    1: //
    1: //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    1: 
    1: // nsIMIMEService methods
    1: NS_IMETHODIMP nsExternalHelperAppService::GetFromTypeAndExtension(const nsACString& aMIMEType, const nsACString& aFileExt, nsIMIMEInfo **_retval) 
    1: {
    1:   NS_PRECONDITION(!aMIMEType.IsEmpty() ||
    1:                   !aFileExt.IsEmpty(), 
    1:                   "Give me something to work with");
    1:   LOG(("Getting mimeinfo from type '%s' ext '%s'\n",
    1:         PromiseFlatCString(aMIMEType).get(), PromiseFlatCString(aFileExt).get()));
    1: 
    1:   *_retval = nsnull;
    1: 
    1:   // OK... we need a type. Get one.
    1:   nsCAutoString typeToUse(aMIMEType);
    1:   if (typeToUse.IsEmpty()) {
    1:     nsresult rv = GetTypeFromExtension(aFileExt, typeToUse);
    1:     if (NS_FAILED(rv))
    1:       return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
 9929:   // We promise to only send lower case mime types to the OS
 9929:   ToLowerCase(typeToUse);
 9929: 
    1:   // (1) Ask the OS for a mime info
79445:   bool found;
    1:   *_retval = GetMIMEInfoFromOS(typeToUse, aFileExt, &found).get();
    1:   LOG(("OS gave back 0x%p - found: %i\n", *_retval, found));
    1:   // If we got no mimeinfo, something went wrong. Probably lack of memory.
    1:   if (!*_retval)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
 5657:   // (2) Now, let's see if we can find something in our datastore
    1:   // This will not overwrite the OS information that interests us
    1:   // (i.e. default application, default app. description)
 5657:   nsresult rv;
 5657:   nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);
 5657:   if (handlerSvc) {
79445:     bool hasHandler = false;
14793:     (void) handlerSvc->Exists(*_retval, &hasHandler);
14793:     if (hasHandler) {
 5657:       rv = handlerSvc->FillHandlerInfo(*_retval, EmptyCString());
 5657:       LOG(("Data source: Via type: retval 0x%08x\n", rv));
14793:     } else {
14793:       rv = NS_ERROR_NOT_AVAILABLE;
14793:     }
14793:  
    1:     found = found || NS_SUCCEEDED(rv);
    1: 
    1:     if (!found || NS_FAILED(rv)) {
    1:       // No type match, try extension match
    1:       if (!aFileExt.IsEmpty()) {
 5657:         nsCAutoString overrideType;
 5657:         rv = handlerSvc->GetTypeFromExtension(aFileExt, overrideType);
14793:         if (NS_SUCCEEDED(rv) && !overrideType.IsEmpty()) {
14793:           // We can't check handlerSvc->Exists() here, because we have a
14793:           // overideType. That's ok, it just results in some console noise.
14793:           // (If there's no handler for the override type, it throws)
 5657:           rv = handlerSvc->FillHandlerInfo(*_retval, overrideType);
    1:           LOG(("Data source: Via ext: retval 0x%08x\n", rv));
    1:           found = found || NS_SUCCEEDED(rv);
    1:         }
    1:       }
 5657:     }
 5657:   }
    1: 
    1:   // (3) No match yet. Ask extras.
    1:   if (!found) {
    1:     rv = NS_ERROR_FAILURE;
    1: #ifdef XP_WIN
    1:     /* XXX Gross hack to wallpaper over the most common Win32
    1:      * extension issues caused by the fix for bug 116938.  See bug
    1:      * 120327, comment 271 for why this is needed.  Not even sure we
    1:      * want to remove this once we have fixed all this stuff to work
    1:      * right; any info we get from extras on this type is pretty much
    1:      * useless....
    1:      */
    1:     if (!typeToUse.Equals(APPLICATION_OCTET_STREAM, nsCaseInsensitiveCStringComparator()))
    1: #endif
 3161:       rv = FillMIMEInfoForMimeTypeFromExtras(typeToUse, *_retval);
    1:     LOG(("Searched extras (by type), rv 0x%08X\n", rv));
    1:     // If that didn't work out, try file extension from extras
    1:     if (NS_FAILED(rv) && !aFileExt.IsEmpty()) {
 3161:       rv = FillMIMEInfoForExtensionFromExtras(aFileExt, *_retval);
    1:       LOG(("Searched extras (by ext), rv 0x%08X\n", rv));
    1:     }
31121:     // If that still didn't work, set the file description to "ext File"
31121:     if (NS_FAILED(rv) && !aFileExt.IsEmpty()) {
31121:       // XXXzpao This should probably be localized
31121:       nsCAutoString desc(aFileExt);
31121:       desc.Append(" File");
31121:       (*_retval)->SetDescription(NS_ConvertASCIItoUTF16(desc));
31121:       LOG(("Falling back to 'File' file description\n"));
31121:     }
    1:   }
    1: 
    1:   // Finally, check if we got a file extension and if yes, if it is an
    1:   // extension on the mimeinfo, in which case we want it to be the primary one
    1:   if (!aFileExt.IsEmpty()) {
79445:     bool matches = false;
    1:     (*_retval)->ExtensionExists(aFileExt, &matches);
    1:     LOG(("Extension '%s' matches mime info: %i\n", PromiseFlatCString(aFileExt).get(), matches));
    1:     if (matches)
    1:       (*_retval)->SetPrimaryExtension(aFileExt);
    1:   }
    1: 
    1: #ifdef PR_LOGGING
    1:   if (LOG_ENABLED()) {
    1:     nsCAutoString type;
    1:     (*_retval)->GetMIMEType(type);
    1: 
    1:     nsCAutoString ext;
    1:     (*_retval)->GetPrimaryExtension(ext);
    1:     LOG(("MIME Info Summary: Type '%s', Primary Ext '%s'\n", type.get(), ext.get()));
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::GetTypeFromExtension(const nsACString& aFileExt, nsACString& aContentType) 
    1: {
    1:   // OK. We want to try the following sources of mimetype information, in this order:
    1:   // 1. defaultMimeEntries array
 5657:   // 2. User-set preferences (managed by the handler service)
    1:   // 3. OS-provided information
    1:   // 4. our "extras" array
    1:   // 5. Information from plugins
    1:   // 6. The "ext-to-type-mapping" category
    1: 
    1:   nsresult rv = NS_OK;
    1:   // First of all, check our default entries
80467:   for (size_t i = 0; i < ArrayLength(defaultMimeEntries); i++)
    1:   {
    1:     if (aFileExt.LowerCaseEqualsASCII(defaultMimeEntries[i].mFileExtension)) {
    1:       aContentType = defaultMimeEntries[i].mMimeType;
    1:       return rv;
    1:     }
    1:   }
    1: 
 5657:   // Check user-set prefs
 5657:   nsCOMPtr<nsIHandlerService> handlerSvc = do_GetService(NS_HANDLERSERVICE_CONTRACTID);
 5657:   if (handlerSvc)
 5657:     rv = handlerSvc->GetTypeFromExtension(aFileExt, aContentType);
14793:   if (NS_SUCCEEDED(rv) && !aContentType.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   // Ask OS.
79445:   bool found = false;
    1:   nsCOMPtr<nsIMIMEInfo> mi = GetMIMEInfoFromOS(EmptyCString(), aFileExt, &found);
    1:   if (mi && found)
    1:     return mi->GetMIMEType(aContentType);
    1: 
    1:   // Check extras array.
    1:   found = GetTypeFromExtras(aFileExt, aContentType);
    1:   if (found)
    1:     return NS_OK;
    1: 
    1:   const nsCString& flatExt = PromiseFlatCString(aFileExt);
    1:   // Try the plugins
    1:   const char* mimeType;
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID, &rv));
70185:   nsPluginHost* pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
    1:   if (NS_SUCCEEDED(rv)) {
29574:     if (NS_SUCCEEDED(pluginHost->IsPluginEnabledForExtension(flatExt.get(), mimeType))) {
    1:       aContentType = mimeType;
    1:       return NS_OK;
    1:     }
    1:   }
    1:   
    1:   rv = NS_OK;
    1:   // Let's see if an extension added something
    1:   nsCOMPtr<nsICategoryManager> catMan(do_GetService("@mozilla.org/categorymanager;1"));
    1:   if (catMan) {
31047:     // The extension in the category entry is always stored as lowercase
31047:     nsCAutoString lowercaseFileExt(aFileExt);
31047:     ToLowerCase(lowercaseFileExt);
31047:     // Read the MIME type from the category entry, if available
    1:     nsXPIDLCString type;
31047:     rv = catMan->GetCategoryEntry("ext-to-type-mapping", lowercaseFileExt.get(),
31047:                                   getter_Copies(type));
    1:     aContentType = type;
    1:   }
    1:   else {
    1:     rv = NS_ERROR_NOT_AVAILABLE;
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::GetPrimaryExtension(const nsACString& aMIMEType, const nsACString& aFileExt, nsACString& _retval)
    1: {
    1:   NS_ENSURE_ARG(!aMIMEType.IsEmpty());
    1: 
    1:   nsCOMPtr<nsIMIMEInfo> mi;
    1:   nsresult rv = GetFromTypeAndExtension(aMIMEType, aFileExt, getter_AddRefs(mi));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   return mi->GetPrimaryExtension(_retval);
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::GetTypeFromURI(nsIURI *aURI, nsACString& aContentType) 
    1: {
69018:   NS_ENSURE_ARG_POINTER(aURI);
    1:   nsresult rv = NS_ERROR_NOT_AVAILABLE;
    1:   aContentType.Truncate();
    1: 
    1:   // First look for a file to use.  If we have one, we just use that.
    1:   nsCOMPtr<nsIFileURL> fileUrl = do_QueryInterface(aURI);
    1:   if (fileUrl) {
    1:     nsCOMPtr<nsIFile> file;
    1:     rv = fileUrl->GetFile(getter_AddRefs(file));
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = GetTypeFromFile(file, aContentType);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         // we got something!
    1:         return rv;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Now try to get an nsIURL so we don't have to do our own parsing
    1:   nsCOMPtr<nsIURL> url = do_QueryInterface(aURI);
    1:   if (url) {
    1:     nsCAutoString ext;
    1:     rv = url->GetFileExtension(ext);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     if (ext.IsEmpty())
    1:       return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     UnescapeFragment(ext, url, ext);
    1: 
    1:     return GetTypeFromExtension(ext, aContentType);
    1:   }
    1:     
    1:   // no url, let's give the raw spec a shot
    1:   nsCAutoString specStr;
    1:   rv = aURI->GetSpec(specStr);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   UnescapeFragment(specStr, aURI, specStr);
    1: 
    1:   // find the file extension (if any)
    1:   PRInt32 extLoc = specStr.RFindChar('.');
    1:   PRInt32 specLength = specStr.Length();
    1:   if (-1 != extLoc &&
    1:       extLoc != specLength - 1 &&
    1:       // nothing over 20 chars long can be sanely considered an
    1:       // extension.... Dat dere would be just data.
    1:       specLength - extLoc < 20) 
    1:   {
    1:     return GetTypeFromExtension(Substring(specStr, extLoc + 1), aContentType);
    1:   }
    1: 
    1:   // We found no information; say so.
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: NS_IMETHODIMP nsExternalHelperAppService::GetTypeFromFile(nsIFile* aFile, nsACString& aContentType)
    1: {
69019:   NS_ENSURE_ARG_POINTER(aFile);
    1:   nsresult rv;
    1:   nsCOMPtr<nsIMIMEInfo> info;
    1: 
    1:   // Get the Extension
    1:   nsAutoString fileName;
    1:   rv = aFile->GetLeafName(fileName);
    1:   if (NS_FAILED(rv)) return rv;
    1:  
    1:   nsCAutoString fileExt;
    1:   if (!fileName.IsEmpty())
    1:   {
    1:     PRInt32 len = fileName.Length(); 
    1:     for (PRInt32 i = len; i >= 0; i--) 
    1:     {
    1:       if (fileName[i] == PRUnichar('.'))
    1:       {
    1:         CopyUTF16toUTF8(fileName.get() + i + 1, fileExt);
    1:         break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (fileExt.IsEmpty())
    1:     return NS_ERROR_FAILURE;
29490: 
    1:   return GetTypeFromExtension(fileExt, aContentType);
    1: }
    1: 
 3161: nsresult nsExternalHelperAppService::FillMIMEInfoForMimeTypeFromExtras(
 3161:   const nsACString& aContentType, nsIMIMEInfo * aMIMEInfo)
    1: {
    1:   NS_ENSURE_ARG( aMIMEInfo );
    1: 
    1:   NS_ENSURE_ARG( !aContentType.IsEmpty() );
    1: 
    1:   // Look for default entry with matching mime type.
    1:   nsCAutoString MIMEType(aContentType);
    1:   ToLowerCase(MIMEType);
80467:   PRInt32 numEntries = ArrayLength(extraMimeEntries);
    1:   for (PRInt32 index = 0; index < numEntries; index++)
    1:   {
    1:       if ( MIMEType.Equals(extraMimeEntries[index].mMimeType) )
    1:       {
    1:           // This is the one. Set attributes appropriately.
    1:           aMIMEInfo->SetFileExtensions(nsDependentCString(extraMimeEntries[index].mFileExtensions));
    1:           aMIMEInfo->SetDescription(NS_ConvertASCIItoUTF16(extraMimeEntries[index].mDescription));
    1:           return NS_OK;
    1:       }
    1:   }
    1: 
    1:   return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
 3161: nsresult nsExternalHelperAppService::FillMIMEInfoForExtensionFromExtras(
 3161:   const nsACString& aExtension, nsIMIMEInfo * aMIMEInfo)
    1: {
    1:   nsCAutoString type;
79445:   bool found = GetTypeFromExtras(aExtension, type);
    1:   if (!found)
    1:     return NS_ERROR_NOT_AVAILABLE;
 3161:   return FillMIMEInfoForMimeTypeFromExtras(type, aMIMEInfo);
    1: }
    1: 
79445: bool nsExternalHelperAppService::GetTypeFromExtras(const nsACString& aExtension, nsACString& aMIMEType)
    1: {
    1:   NS_ASSERTION(!aExtension.IsEmpty(), "Empty aExtension parameter!");
    1: 
    1:   // Look for default entry with matching extension.
    1:   nsDependentCString::const_iterator start, end, iter;
80467:   PRInt32 numEntries = ArrayLength(extraMimeEntries);
    1:   for (PRInt32 index = 0; index < numEntries; index++)
    1:   {
    1:       nsDependentCString extList(extraMimeEntries[index].mFileExtensions);
    1:       extList.BeginReading(start);
    1:       extList.EndReading(end);
    1:       iter = start;
    1:       while (start != end)
    1:       {
    1:           FindCharInReadable(',', iter, end);
    1:           if (Substring(start, iter).Equals(aExtension,
    1:                                             nsCaseInsensitiveCStringComparator()))
    1:           {
    1:               aMIMEType = extraMimeEntries[index].mMimeType;
80486:               return true;
    1:           }
    1:           if (iter != end) {
    1:             ++iter;
    1:           }
    1:           start = iter;
    1:       }
    1:   }
    1: 
80486:   return false;
    1: }
