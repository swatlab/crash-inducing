    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for replaced elements with bitmap image data */
    1: 
    1: #include "nsHTMLParts.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsImageFrame.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsString.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsPresContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsContentUtils.h"
 8578: #include "nsCSSAnonBoxes.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsImageMap.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIURL.h"
    1: #include "nsIIOService.h"
    1: #include "nsIURL.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsISupportsPriority.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "prprf.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsILink.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsImageMapUtils.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsDisplayList.h"
    1: 
    1: #include "imgIContainer.h"
    1: #include "imgILoader.h"
    1: 
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIDOMRange.h"
    1: 
    1: #include "nsIContentPolicy.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsBidiUtils.h"
    1: #include "nsBidiPresUtils.h"
    1: 
    1: // sizes (pixels) for image icon, padding and border frame
    1: #define ICON_SIZE        (16)
    1: #define ICON_PADDING     (3)
    1: #define ALT_BORDER_WIDTH (1)
    1: 
    1: 
    1: //we must add hooks soon
    1: #define IMAGE_EDITOR_CHECK 1
    1: 
    1: // Default alignment value (so we can tell an unset value from a set value)
    1: #define ALIGN_UNSET PRUint8(-1)
    1: 
    1: // static icon information
    1: nsImageFrame::IconLoad* nsImageFrame::gIconLoad = nsnull;
    1: 
    1: // cached IO service for loading icons
    1: nsIIOService* nsImageFrame::sIOService;
    1: 
    1: // test if the width and height are fixed, looking at the style data
    1: static PRBool HaveFixedSize(const nsStylePosition* aStylePosition)
    1: {
    1:   // check the width and height values in the reflow state's style struct
    1:   // - if width and height are specified as either coord or percentage, then
    1:   //   the size of the image frame is constrained
    1:   nsStyleUnit widthUnit = aStylePosition->mWidth.GetUnit();
    1:   nsStyleUnit heightUnit = aStylePosition->mHeight.GetUnit();
    1: 
    1:   return ((widthUnit  == eStyleUnit_Coord ||
    1:            widthUnit  == eStyleUnit_Percent) &&
    1:           (heightUnit == eStyleUnit_Coord ||
    1:            heightUnit == eStyleUnit_Percent));
    1: }
    1: // use the data in the reflow state to decide if the image has a constrained size
    1: // (i.e. width and height that are based on the containing block size and not the image size) 
    1: // so we can avoid animated GIF related reflows
    1: inline PRBool HaveFixedSize(const nsHTMLReflowState& aReflowState)
    1: { 
    1:   NS_ASSERTION(aReflowState.mStylePosition, "crappy reflowState - null stylePosition");
 4166:   // when an image has percent css style height or width, but ComputedHeight() 
    1:   // or ComputedWidth() of reflow state is  NS_UNCONSTRAINEDSIZE  
    1:   // it needs to return PR_FALSE to cause an incremental reflow later
    1:   // if an image is inside table like bug 156731 simple testcase III, 
    1:   // during pass 1 reflow, ComputedWidth() is NS_UNCONSTRAINEDSIZE
    1:   // in pass 2 reflow, ComputedWidth() is 0, it also needs to return PR_FALSE
    1:   // see bug 156731
    1:   nsStyleUnit heightUnit = (*(aReflowState.mStylePosition)).mHeight.GetUnit();
    1:   nsStyleUnit widthUnit = (*(aReflowState.mStylePosition)).mWidth.GetUnit();
 4166:   return ((eStyleUnit_Percent == heightUnit && NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) ||
    1:           (eStyleUnit_Percent == widthUnit && (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedWidth() ||
    1:            0 == aReflowState.ComputedWidth())))
    1:           ? PR_FALSE
    1:           : HaveFixedSize(aReflowState.mStylePosition); 
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewImageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsImageFrame(aContext);
    1: }
    1: 
    1: 
    1: nsImageFrame::nsImageFrame(nsStyleContext* aContext) :
    1:   ImageFrameSuper(aContext),
    1:   mComputedSize(0, 0),
31389:   mIntrinsicSize(0, 0),
31389:   mDisplayingIcon(PR_FALSE)
    1: {
    1:   // We assume our size is not constrained and we haven't gotten an
    1:   // initial reflow yet, so don't touch those flags.
    1: }
    1: 
    1: nsImageFrame::~nsImageFrame()
    1: {
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsImageFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIImageFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(ImageFrameSuper)
    1: 
    1: #ifdef ACCESSIBILITY
    1: NS_IMETHODIMP nsImageFrame::GetAccessible(nsIAccessible** aAccessible)
    1: {
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
 3233:     return accService->CreateHTMLImageAccessible(static_cast<nsIFrame*>(this), aAccessible);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: #endif
    1: 
    1: void
    1: nsImageFrame::Destroy()
    1: {
    1:   // Tell our image map, if there is one, to clean up
    1:   // This causes the nsImageMap to unregister itself as
    1:   // a DOM listener.
    1:   if (mImageMap) {
    1:     mImageMap->Destroy();
    1:     NS_RELEASE(mImageMap);
    1:   }
    1: 
    1:   // set the frame to null so we don't send messages to a dead object.
    1:   if (mListener) {
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:     if (imageLoader) {
    1:       imageLoader->RemoveObserver(mListener);
    1:     }
    1:     
 3233:     reinterpret_cast<nsImageListener*>(mListener.get())->SetFrame(nsnull);
    1:   }
    1:   
    1:   mListener = nsnull;
    1: 
31389:   // If we were displaying an icon, take ourselves off the list
31389:   if (mDisplayingIcon)
31389:     gIconLoad->RemoveIconObserver(this);
31389: 
    1:   nsSplittableFrame::Destroy();
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::Init(nsIContent*      aContent,
    1:                    nsIFrame*        aParent,
    1:                    nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult rv = nsSplittableFrame::Init(aContent, aParent, aPrevInFlow);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mListener = new nsImageListener(this);
    1:   if (!mListener) return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(aContent);
    1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
    1:   imageLoader->AddObserver(mListener);
    1: 
  238:   nsPresContext *aPresContext = PresContext();
    1:   
    1:   if (!gIconLoad)
    1:     LoadIcons(aPresContext);
    1: 
    1:   // Give image loads associated with an image frame a small priority boost!
    1:   nsCOMPtr<imgIRequest> currentRequest;
    1:   imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                           getter_AddRefs(currentRequest));
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(currentRequest);
    1:   if (p)
    1:     p->AdjustPriority(-1);
    1: 
    1:   // If we already have an image container, OnStartContainer won't be called
    1:   // Set the animation mode here
    1:   if (currentRequest) {
    1:     nsCOMPtr<imgIContainer> image;
    1:     currentRequest->GetImage(getter_AddRefs(image));
    1:     if (image) {
    1:       image->SetAnimationMode(aPresContext->ImageAnimationMode());
    1:       // Ensure the animation (if any) is started.
    1:       image->StartAnimation();
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: PRBool
    1: nsImageFrame::UpdateIntrinsicSize(imgIContainer* aImage)
    1: {
    1:   NS_PRECONDITION(aImage, "null image");
    1: 
    1:   PRBool intrinsicSizeChanged = PR_FALSE;
    1:   
    1:   if (aImage) {
23738:     nsIntSize imageSizeInPx;
    1:     aImage->GetWidth(&imageSizeInPx.width);
    1:     aImage->GetHeight(&imageSizeInPx.height);
    1:     nsSize newSize(nsPresContext::CSSPixelsToAppUnits(imageSizeInPx.width),
    1:                    nsPresContext::CSSPixelsToAppUnits(imageSizeInPx.height));
    1:     if (mIntrinsicSize != newSize) {
    1:       intrinsicSizeChanged = PR_TRUE;
    1:       mIntrinsicSize = newSize;
    1:     }
    1:   }
    1: 
    1:   return intrinsicSizeChanged;
    1: }
    1: 
    1: void
24704: nsImageFrame::RecalculateTransform(PRBool aInnerAreaChanged)
    1: {
    1:   // In any case, we need to translate this over appropriately.  Set
    1:   // translation _before_ setting scaling so that it does not get
    1:   // scaled!
    1: 
    1:   // XXXbz does this introduce rounding errors because of the cast to
    1:   // float?  Should we just manually add that stuff in every time
    1:   // instead?
24704:   if (aInnerAreaChanged) {
    1:     nsRect innerArea = GetInnerArea();
    1:     mTransform.SetToTranslate(float(innerArea.x),
    1:                               float(innerArea.y - GetContinuationOffset()));
24704:   }
    1:   
    1:   // Set the scale factors
    1:   if (mIntrinsicSize.width != 0 && mIntrinsicSize.height != 0 &&
    1:       mIntrinsicSize != mComputedSize) {
24704:     mTransform.SetScale(float(mComputedSize.width)  / float(mIntrinsicSize.width),
    1:                         float(mComputedSize.height) / float(mIntrinsicSize.height));
24704:   } else {
24704:     mTransform.SetScale(1.0f, 1.0f);
    1:   }
    1: }
    1: 
    1: /*
    1:  * These two functions basically do the same check.  The first one
    1:  * checks that the given request is the current request for our
    1:  * mContent.  The second checks that the given image container the
    1:  * same as the image container on the current request for our
    1:  * mContent.
    1:  */
    1: PRBool
    1: nsImageFrame::IsPendingLoad(imgIRequest* aRequest) const
    1: {
    1:   // Default to pending load in case of errors
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader(do_QueryInterface(mContent));
    1:   NS_ASSERTION(imageLoader, "No image loading content?");
    1: 
    1:   PRInt32 requestType = nsIImageLoadingContent::UNKNOWN_REQUEST;
    1:   imageLoader->GetRequestType(aRequest, &requestType);
    1: 
    1:   return requestType != nsIImageLoadingContent::CURRENT_REQUEST;
    1: }
    1: 
    1: PRBool
    1: nsImageFrame::IsPendingLoad(imgIContainer* aContainer) const
    1: {
    1:   //  default to pending load in case of errors
    1:   if (!aContainer) {
    1:     NS_ERROR("No image container!");
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader(do_QueryInterface(mContent));
    1:   NS_ASSERTION(imageLoader, "No image loading content?");
    1:   
    1:   nsCOMPtr<imgIRequest> currentRequest;
    1:   imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                           getter_AddRefs(currentRequest));
    1:   if (!currentRequest) {
    1:     NS_ERROR("No current request");
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   nsCOMPtr<imgIContainer> currentContainer;
    1:   currentRequest->GetImage(getter_AddRefs(currentContainer));
    1: 
    1:   return currentContainer != aContainer;
    1:   
    1: }
    1: 
    1: nsRect
23738: nsImageFrame::SourceRectToDest(const nsIntRect& aRect)
    1: {
    1:   // When scaling the image, row N of the source image may (depending on
    1:   // the scaling function) be used to draw any row in the destination image
    1:   // between floor(F * (N-1)) and ceil(F * (N+1)), where F is the
    1:   // floating-point scaling factor.  The same holds true for columns.
    1:   // So, we start by computing that bound without the floor and ceiling.
    1: 
    1:   nsRect r(nsPresContext::CSSPixelsToAppUnits(aRect.x - 1),
    1:            nsPresContext::CSSPixelsToAppUnits(aRect.y - 1),
    1:            nsPresContext::CSSPixelsToAppUnits(aRect.width + 2),
    1:            nsPresContext::CSSPixelsToAppUnits(aRect.height + 2));
    1: 
    1:   mTransform.TransformCoord(&r.x, &r.y, &r.width, &r.height);
    1: 
    1:   // Now, round the edges out to the pixel boundary.
    1:   int scale = nsPresContext::CSSPixelsToAppUnits(1);
    1:   nscoord right = r.x + r.width;
    1:   nscoord bottom = r.y + r.height;
    1: 
    1:   r.x -= (scale + (r.x % scale)) % scale;
    1:   r.y -= (scale + (r.y % scale)) % scale;
    1:   r.width = right + ((scale - (right % scale)) % scale) - r.x;
    1:   r.height = bottom + ((scale - (bottom % scale)) % scale) - r.y;
    1: 
    1:   return r;
    1: }
    1: 
    1: // Note that we treat NS_EVENT_STATE_SUPPRESSED images as "OK".  This means
    1: // that we'll construct image frames for them as needed if their display is
    1: // toggled from "none" (though we won't paint them, unless their visibility
    1: // is changed too).
    1: #define BAD_STATES (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED | \
    1:                     NS_EVENT_STATE_LOADING)
    1: 
    1: // This is a macro so that we don't evaluate the boolean last arg
    1: // unless we have to; it can be expensive
    1: #define IMAGE_OK(_state, _loadingOK)                        \
    1:    (((_state) & BAD_STATES) == 0 ||                         \
    1:     (((_state) & BAD_STATES) == NS_EVENT_STATE_LOADING &&   \
    1:      (_loadingOK)))
    1: 
    1: /* static */
    1: PRBool
    1: nsImageFrame::ShouldCreateImageFrameFor(nsIContent* aContent,
    1:                                         nsStyleContext* aStyleContext)
    1: {
    1:   PRInt32 state = aContent->IntrinsicState();
    1:   if (IMAGE_OK(state,
    1:                HaveFixedSize(aStyleContext->GetStylePosition()))) {
    1:     // Image is fine; do the image frame thing
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Check if we want to use a placeholder box with an icon or just
    1:   // let the presShell make us into inline text.  Decide as follows:
    1:   //
    1:   //  - if our special "force icons" style is set, show an icon
    1:   //  - else if our "do not show placeholders" pref is set, skip the icon
    1:   //  - else:
    1:   //  - if QuirksMode, and there is no alt attribute, and this is not an
    1:   //    <object> (which could not possibly have such an attribute), show an
    1:   //    icon.
    1:   //  - if QuirksMode, and the IMG has a size show an icon.
    1:   //  - otherwise, skip the icon
    1:   PRBool useSizedBox;
    1:   
    1:   if (aStyleContext->GetStyleUIReset()->mForceBrokenImageIcon) {
    1:     useSizedBox = PR_TRUE;
    1:   }
    1:   else if (gIconLoad && gIconLoad->mPrefForceInlineAltText) {
    1:     useSizedBox = PR_FALSE;
    1:   }
    1:   else {
    1:     if (aStyleContext->PresContext()->CompatibilityMode() !=
    1:         eCompatibility_NavQuirks) {
    1:       useSizedBox = PR_FALSE;
    1:     }
    1:     else {
    1:       // We are in quirks mode, so we can just check the tag name; no need to
    1:       // check the namespace.
    1:       nsIAtom *localName = aContent->NodeInfo()->NameAtom();
    1: 
    1:       // Use a sized box if we have no alt text.  This means no alt attribute
    1:       // and the node is not an object or an input (since those always have alt
    1:       // text).
    1:       if (!aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::alt) &&
    1:           localName != nsGkAtoms::object &&
    1:           localName != nsGkAtoms::input) {
    1:         useSizedBox = PR_TRUE;
    1:       }
    1:       else {
    1:         // check whether we have fixed size
    1:         useSizedBox = HaveFixedSize(aStyleContext->GetStylePosition());
    1:       }
    1:     }
    1:   }
    1:   
    1:   return useSizedBox;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::OnStartContainer(imgIRequest *aRequest, imgIContainer *aImage)
    1: {
    1:   if (!aImage) return NS_ERROR_INVALID_ARG;
    1: 
    1:   /* Get requested animation policy from the pres context:
    1:    *   normal = 0
    1:    *   one frame = 1
    1:    *   one loop = 2
    1:    */
  238:   nsPresContext *presContext = PresContext();
    1:   aImage->SetAnimationMode(presContext->ImageAnimationMode());
    1:   // Ensure the animation (if any) is started.
    1:   aImage->StartAnimation();
    1: 
    1:   if (IsPendingLoad(aRequest)) {
    1:     // We don't care
    1:     return NS_OK;
    1:   }
    1:   
    1:   UpdateIntrinsicSize(aImage);
    1: 
24704:   if (mState & IMAGE_GOTINITIALREFLOW) {
24704:     // If we previously set the intrinsic size (in EnsureIntrinsicSize)
24704:     // to the size of the loading-image icon and reflowed the frame,
24704:     // we'll have an mTransform computed from that intrinsic size.  But
24704:     // if we still have that transform when we get OnDataAvailable
24704:     // calls, we'll invalidate the wrong area.  So update the transform
24704:     // now.
24704:     RecalculateTransform(PR_FALSE);
24704: 
    1:     // Now we need to reflow if we have an unconstrained size and have
    1:     // already gotten the initial reflow
24704:     if (!(mState & IMAGE_SIZECONSTRAINED)) { 
    1:       nsIPresShell *presShell = presContext->GetPresShell();
    1:       NS_ASSERTION(presShell, "No PresShell.");
 1158:       if (presShell) { 
 1158:         presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                                     NS_FRAME_IS_DIRTY);
    1:       }
    1:     }
24704:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::OnDataAvailable(imgIRequest *aRequest,
30479:                               PRBool aCurrentFrame,
23738:                               const nsIntRect *aRect)
    1: {
    1:   // XXX do we need to make sure that the reflow from the
    1:   // OnStartContainer has been processed before we start calling
    1:   // invalidate?
    1: 
    1:   NS_ENSURE_ARG_POINTER(aRect);
    1: 
    1:   if (!(mState & IMAGE_GOTINITIALREFLOW)) {
    1:     // Don't bother to do anything; we have a reflow coming up!
    1:     return NS_OK;
    1:   }
    1:   
  878:   // XXX We really need to round this out, now that we're doing better
  878:   // image scaling!
  878:   nsRect r = SourceRectToDest(*aRect);
  878: 
    1:   if (IsPendingLoad(aRequest)) {
    1:     // We don't care
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Don't invalidate if the current visible frame isn't the one the data is
    1:   // from
30479:   if (!aCurrentFrame)
    1:     return NS_OK;
    1: 
    1: #ifdef DEBUG_decode
    1:   printf("Source rect (%d,%d,%d,%d) -> invalidate dest rect (%d,%d,%d,%d)\n",
    1:          aRect->x, aRect->y, aRect->width, aRect->height,
    1:          r.x, r.y, r.width, r.height);
    1: #endif
    1: 
19380:   Invalidate(r);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::OnStopDecode(imgIRequest *aRequest,
    1:                            nsresult aStatus,
    1:                            const PRUnichar *aStatusArg)
    1: {
  238:   nsPresContext *presContext = PresContext();
    1:   nsIPresShell *presShell = presContext->GetPresShell();
    1:   NS_ASSERTION(presShell, "No PresShell.");
    1: 
    1:   // Check what request type we're dealing with
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   NS_ASSERTION(imageLoader, "Who's notifying us??");
    1:   PRInt32 loadType = nsIImageLoadingContent::UNKNOWN_REQUEST;
    1:   imageLoader->GetRequestType(aRequest, &loadType);
    1:   if (loadType != nsIImageLoadingContent::CURRENT_REQUEST &&
    1:       loadType != nsIImageLoadingContent::PENDING_REQUEST) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (loadType == nsIImageLoadingContent::PENDING_REQUEST) {
    1:     // May have to switch sizes here!
    1:     PRBool intrinsicSizeChanged = PR_TRUE;
    1:     if (NS_SUCCEEDED(aStatus)) {
    1:       nsCOMPtr<imgIContainer> imageContainer;
    1:       aRequest->GetImage(getter_AddRefs(imageContainer));
    1:       NS_ASSERTION(imageContainer, "Successful load with no container?");
    1:       intrinsicSizeChanged = UpdateIntrinsicSize(imageContainer);
    1:     }
    1:     else {
    1:       // Have to size to 0,0 so that GetDesiredSize recalculates the size
    1:       mIntrinsicSize.SizeTo(0, 0);
    1:     }
    1: 
    1:     if (mState & IMAGE_GOTINITIALREFLOW) { // do nothing if we haven't gotten the initial reflow yet
    1:       if (!(mState & IMAGE_SIZECONSTRAINED) && intrinsicSizeChanged) {
 1158:         if (presShell) { 
 1158:           presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                                       NS_FRAME_IS_DIRTY);
    1:         }
    1:       } else {
    1:         nsSize s = GetSize();
    1:         nsRect r(0, 0, s.width, s.height);
    1:         // Update border+content to account for image change
19380:         Invalidate(r);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
30479: nsImageFrame::FrameChanged(imgIContainer *aContainer, nsIntRect *aDirtyRect)
    1: {
    1:   if (!GetStyleVisibility()->IsVisible()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (IsPendingLoad(aContainer)) {
    1:     // We don't care about it
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsRect r = SourceRectToDest(*aDirtyRect);
    1: 
    1:   // Update border+content to account for image change
19380:   Invalidate(r);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsImageFrame::EnsureIntrinsicSize(nsPresContext* aPresContext)
    1: {
    1:   // if mIntrinsicSize.width and height are 0, then we should
    1:   // check to see if the size is already known by the image container.
    1:   if (mIntrinsicSize.width == 0 && mIntrinsicSize.height == 0) {
31389: 
31389:     // Jump through all the hoops to get the status of the request
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
31389:     if (imageLoader)
    1:       imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                               getter_AddRefs(currentRequest));
31389:     PRUint32 status = 0;
31389:     if (currentRequest)
31389:       currentRequest->GetImageStatus(&status);
    1: 
31389:     // If we know the size, we can grab it and use it for an update
31389:     if (status & imgIRequest::STATUS_SIZE_AVAILABLE) {
31389:       nsCOMPtr<imgIContainer> imgCon;
31389:       currentRequest->GetImage(getter_AddRefs(imgCon));
31389:       NS_ABORT_IF_FALSE(imgCon, "SIZE_AVAILABLE, but no imgContainer?");
31389:       UpdateIntrinsicSize(imgCon);
    1:     } else {
    1:       // image request is null or image size not known, probably an
    1:       // invalid image specified
    1:       // - make the image big enough for the icon (it may not be
    1:       // used if inline alt expansion is used instead)
    1:       // XXX: we need this in composer, but it is also good for
    1:       // XXX: general quirks mode to always have room for the icon
    1:       if (aPresContext->CompatibilityMode() == eCompatibility_NavQuirks) {
    1:         mIntrinsicSize.SizeTo(nsPresContext::CSSPixelsToAppUnits(ICON_SIZE+(2*(ICON_PADDING+ALT_BORDER_WIDTH))),
    1:                               nsPresContext::CSSPixelsToAppUnits(ICON_SIZE+(2*(ICON_PADDING+ALT_BORDER_WIDTH))));
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: /* virtual */ nsSize
    1: nsImageFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                           nsSize aCBSize, nscoord aAvailableWidth,
    1:                           nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                           PRBool aShrinkWrap)
    1: {
  238:   nsPresContext *presContext = PresContext();
    1:   EnsureIntrinsicSize(presContext);
    1: 
 8142:   IntrinsicSize intrinsicSize;
 8142:   intrinsicSize.width.SetCoordValue(mIntrinsicSize.width);
 8142:   intrinsicSize.height.SetCoordValue(mIntrinsicSize.height);
 8142: 
 8142:   nsSize& intrinsicRatio = mIntrinsicSize; // won't actually be used
 8142: 
    1:   return nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
    1:                             aRenderingContext, this,
 8142:                             intrinsicSize, intrinsicRatio, aCBSize,
 8142:                             aMargin, aBorder, aPadding);
    1: }
    1: 
    1: nsRect 
    1: nsImageFrame::GetInnerArea() const
    1: {
    1:   return GetContentRect() - GetPosition();
    1: }
    1: 
    1: // get the offset into the content area of the image where aImg starts if it is a continuation.
    1: nscoord 
    1: nsImageFrame::GetContinuationOffset() const
    1: {
    1:   nscoord offset = 0;
    1:   for (nsIFrame *f = GetPrevInFlow(); f; f = f->GetPrevInFlow()) {
    1:     offset += f->GetContentRect().height;
    1:   }
    1:   NS_ASSERTION(offset >= 0, "bogus GetContentRect");
    1:   return offset;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsImageFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   // XXX The caller doesn't account for constraints of the height,
    1:   // min-height, and max-height properties.
    1:   nscoord result;
    1:   DISPLAY_MIN_WIDTH(this, result);
  238:   nsPresContext *presContext = PresContext();
    1:   EnsureIntrinsicSize(presContext);
    1:   result = mIntrinsicSize.width;
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsImageFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   // XXX The caller doesn't account for constraints of the height,
    1:   // min-height, and max-height properties.
    1:   nscoord result;
    1:   DISPLAY_PREF_WIDTH(this, result);
  238:   nsPresContext *presContext = PresContext();
    1:   EnsureIntrinsicSize(presContext);
    1:   // convert from normal twips to scaled twips (printing...)
    1:   result = mIntrinsicSize.width;
    1:   return result;
    1: }
    1: 
 2301: /* virtual */ nsSize
 2301: nsImageFrame::GetIntrinsicRatio()
 2301: {
 2301:   EnsureIntrinsicSize(PresContext());
 2301:   return mIntrinsicSize;
 2301: }
 2301: 
    1: NS_IMETHODIMP
    1: nsImageFrame::Reflow(nsPresContext*          aPresContext,
    1:                      nsHTMLReflowMetrics&     aMetrics,
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsImageFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
    1:                   ("enter nsImageFrame::Reflow: availSize=%d,%d",
    1:                   aReflowState.availableWidth, aReflowState.availableHeight));
    1: 
    1:   NS_PRECONDITION(mState & NS_FRAME_IN_REFLOW, "frame is not in reflow");
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   // see if we have a frozen size (i.e. a fixed width and height)
    1:   if (HaveFixedSize(aReflowState)) {
    1:     mState |= IMAGE_SIZECONSTRAINED;
    1:   } else {
    1:     mState &= ~IMAGE_SIZECONSTRAINED;
    1:   }
    1: 
    1:   // XXXldb These two bits are almost exact opposites (except in the
    1:   // middle of the initial reflow); remove IMAGE_GOTINITIALREFLOW.
    1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
    1:     mState |= IMAGE_GOTINITIALREFLOW;
    1:   }
    1: 
    1:   mComputedSize = 
 4166:     nsSize(aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
24704:   RecalculateTransform(PR_TRUE);
    1: 
    1:   aMetrics.width = mComputedSize.width;
    1:   aMetrics.height = mComputedSize.height;
    1: 
    1:   // add borders and padding
    1:   aMetrics.width  += aReflowState.mComputedBorderPadding.LeftRight();
    1:   aMetrics.height += aReflowState.mComputedBorderPadding.TopBottom();
    1:   
    1:   if (GetPrevInFlow()) {
    1:     aMetrics.width = GetPrevInFlow()->GetSize().width;
    1:     nscoord y = GetContinuationOffset();
    1:     aMetrics.height -= y + aReflowState.mComputedBorderPadding.top;
    1:     aMetrics.height = PR_MAX(0, aMetrics.height);
    1:   }
    1: 
    1: 
    1:   // we have to split images if we are:
    1:   //  in Paginated mode, we need to have a constrained height, and have a height larger than our available height
    1:   PRUint32 loadStatus = imgIRequest::STATUS_NONE;
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   NS_ASSERTION(imageLoader, "No content node??");
    1:   if (imageLoader) {
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                             getter_AddRefs(currentRequest));
    1:     if (currentRequest) {
    1:       currentRequest->GetImageStatus(&loadStatus);
    1:     }
    1:   }
    1:   if (aPresContext->IsPaginated() &&
    1:       ((loadStatus & imgIRequest::STATUS_SIZE_AVAILABLE) || (mState & IMAGE_SIZECONSTRAINED)) &&
    1:       NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight && 
    1:       aMetrics.height > aReflowState.availableHeight) { 
 9869:     // our desired height was greater than 0, so to avoid infinite
 9869:     // splitting, use 1 pixel as the min
    1:     aMetrics.height = PR_MAX(nsPresContext::CSSPixelsToAppUnits(1), aReflowState.availableHeight);
    1:     aStatus = NS_FRAME_NOT_COMPLETE;
    1:   }
    1: 
    1:   aMetrics.mOverflowArea.SetRect(0, 0, aMetrics.width, aMetrics.height);
    1:   FinishAndStoreOverflow(&aMetrics);
    1: 
    1:   // Now that that's all done, check whether we're resizing... if we are,
    1:   // invalidate our rect.
    1:   // XXXbz we really only want to do this when reflow is completely done, but
    1:   // we have no way to detect when mRect changes (since SetRect is non-virtual,
    1:   // so this is the best we can do).
    1:   if (mRect.width != aMetrics.width || mRect.height != aMetrics.height) {
19380:     Invalidate(nsRect(0, 0, mRect.width, mRect.height));
    1:   }
    1: 
    1:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
    1:                   ("exit nsImageFrame::Reflow: size=%d,%d",
    1:                   aMetrics.width, aMetrics.height));
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return NS_OK;
    1: }
    1: 
    1: // Computes the width of the specified string. aMaxWidth specifies the maximum
    1: // width available. Once this limit is reached no more characters are measured.
    1: // The number of characters that fit within the maximum width are returned in
    1: // aMaxFit. NOTE: it is assumed that the fontmetrics have already been selected
    1: // into the rendering context before this is called (for performance). MMP
    1: nscoord
    1: nsImageFrame::MeasureString(const PRUnichar*     aString,
    1:                             PRInt32              aLength,
    1:                             nscoord              aMaxWidth,
    1:                             PRUint32&            aMaxFit,
    1:                             nsIRenderingContext& aContext)
    1: {
    1:   nscoord totalWidth = 0;
    1:   nscoord spaceWidth;
    1:   aContext.SetTextRunRTL(PR_FALSE);
    1:   aContext.GetWidth(' ', spaceWidth);
    1: 
    1:   aMaxFit = 0;
    1:   while (aLength > 0) {
    1:     // Find the next place we can line break
    1:     PRUint32  len = aLength;
    1:     PRBool    trailingSpace = PR_FALSE;
    1:     for (PRInt32 i = 0; i < aLength; i++) {
    1:       if (XP_IS_SPACE(aString[i]) && (i > 0)) {
    1:         len = i;  // don't include the space when measuring
    1:         trailingSpace = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1:   
    1:     // Measure this chunk of text, and see if it fits
    1:     nscoord width =
    1:       nsLayoutUtils::GetStringWidth(this, &aContext, aString, len);
    1:     PRBool  fits = (totalWidth + width) <= aMaxWidth;
    1: 
    1:     // If it fits on the line, or it's the first word we've processed then
    1:     // include it
    1:     if (fits || (0 == totalWidth)) {
    1:       // New piece fits
    1:       totalWidth += width;
    1: 
    1:       // If there's a trailing space then see if it fits as well
    1:       if (trailingSpace) {
    1:         if ((totalWidth + spaceWidth) <= aMaxWidth) {
    1:           totalWidth += spaceWidth;
    1:         } else {
    1:           // Space won't fit. Leave it at the end but don't include it in
    1:           // the width
    1:           fits = PR_FALSE;
    1:         }
    1: 
    1:         len++;
    1:       }
    1: 
    1:       aMaxFit += len;
    1:       aString += len;
    1:       aLength -= len;
    1:     }
    1: 
    1:     if (!fits) {
    1:       break;
    1:     }
    1:   }
    1:   return totalWidth;
    1: }
    1: 
    1: // Formats the alt-text to fit within the specified rectangle. Breaks lines
    1: // between words if a word would extend past the edge of the rectangle
    1: void
    1: nsImageFrame::DisplayAltText(nsPresContext*      aPresContext,
    1:                              nsIRenderingContext& aRenderingContext,
    1:                              const nsString&      aAltText,
    1:                              const nsRect&        aRect)
    1: {
    1:   // Set font and color
    1:   aRenderingContext.SetColor(GetStyleColor()->mColor);
 1105:   nsLayoutUtils::SetFontFromStyle(&aRenderingContext, mStyleContext);
    1: 
    1:   // Format the text to display within the formatting rect
    1:   nsIFontMetrics* fm;
    1:   aRenderingContext.GetFontMetrics(fm);
    1: 
    1:   nscoord maxAscent, maxDescent, height;
    1:   fm->GetMaxAscent(maxAscent);
    1:   fm->GetMaxDescent(maxDescent);
    1:   fm->GetHeight(height);
    1: 
    1:   // XXX It would be nice if there was a way to have the font metrics tell
    1:   // use where to break the text given a maximum width. At a minimum we need
    1:   // to be able to get the break character...
    1:   const PRUnichar* str = aAltText.get();
    1:   PRInt32          strLen = aAltText.Length();
    1:   nscoord          y = aRect.y;
30204: 
30204:   if (!aPresContext->BidiEnabled() && HasRTLChars(aAltText)) {
30204:     aPresContext->SetBidiEnabled();
30204:   }
30204: 
    1:   // Always show the first line, even if we have to clip it below
    1:   PRBool firstLine = PR_TRUE;
    1:   while ((strLen > 0) && (firstLine || (y + maxDescent) < aRect.YMost())) {
    1:     // Determine how much of the text to display on this line
    1:     PRUint32  maxFit;  // number of characters that fit
    1:     nscoord strWidth = MeasureString(str, strLen, aRect.width, maxFit,
    1:                                      aRenderingContext);
    1:     
    1:     // Display the text
    1:     nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:     if (aPresContext->BidiEnabled()) {
    1:       nsBidiPresUtils* bidiUtils =  aPresContext->GetBidiUtils();
    1:       
    1:       if (bidiUtils) {
    1:         const nsStyleVisibility* vis = GetStyleVisibility();
    1:         if (vis->mDirection == NS_STYLE_DIRECTION_RTL)
    1:           rv = bidiUtils->RenderText(str, maxFit, NSBIDI_RTL,
    1:                                      aPresContext, aRenderingContext,
    1:                                      aRect.XMost() - strWidth, y + maxAscent);
    1:         else
    1:           rv = bidiUtils->RenderText(str, maxFit, NSBIDI_LTR,
    1:                                      aPresContext, aRenderingContext,
    1:                                      aRect.x, y + maxAscent);
    1:       }
    1:     }
    1:     if (NS_FAILED(rv))
    1:       aRenderingContext.DrawString(str, maxFit, aRect.x, y + maxAscent);
    1: 
    1:     // Move to the next line
    1:     str += maxFit;
    1:     strLen -= maxFit;
    1:     y += height;
    1:     firstLine = PR_FALSE;
    1:   }
    1: 
    1:   NS_RELEASE(fm);
    1: }
    1: 
    1: struct nsRecessedBorder : public nsStyleBorder {
    1:   nsRecessedBorder(nscoord aBorderWidth, nsPresContext* aPresContext)
    1:     : nsStyleBorder(aPresContext)
    1:   {
    1:     NS_FOR_CSS_SIDES(side) {
    1:       // Note: use SetBorderColor here because we want to make sure
    1:       // the "special" flags are unset.
    1:       SetBorderColor(side, NS_RGB(0, 0, 0));
    1:       mBorder.side(side) = aBorderWidth;
    1:       // Note: use SetBorderStyle here because we want to affect
    1:       // mComputedBorder
    1:       SetBorderStyle(side, NS_STYLE_BORDER_STYLE_INSET);
    1:     }
    1:   }
    1: };
    1: 
    1: void
    1: nsImageFrame::DisplayAltFeedback(nsIRenderingContext& aRenderingContext,
    1:                                  const nsRect&        aDirtyRect,
    1:                                  imgIRequest*         aRequest,
    1:                                  nsPoint              aPt)
    1: {
31389:   // We should definitely have a gIconLoad here.
31389:   NS_ABORT_IF_FALSE(gIconLoad, "How did we succeed in Init then?");
31389: 
    1:   // Calculate the inner area
    1:   nsRect  inner = GetInnerArea() + aPt;
    1: 
    1:   // Display a recessed one pixel border
    1:   nscoord borderEdgeWidth = nsPresContext::CSSPixelsToAppUnits(ALT_BORDER_WIDTH);
    1: 
    1:   // if inner area is empty, then make it big enough for at least the icon
    1:   if (inner.IsEmpty()){
    1:     inner.SizeTo(2*(nsPresContext::CSSPixelsToAppUnits(ICON_SIZE+ICON_PADDING+ALT_BORDER_WIDTH)),
    1:                  2*(nsPresContext::CSSPixelsToAppUnits(ICON_SIZE+ICON_PADDING+ALT_BORDER_WIDTH)));
    1:   }
    1: 
    1:   // Make sure we have enough room to actually render the border within
    1:   // our frame bounds
    1:   if ((inner.width < 2 * borderEdgeWidth) || (inner.height < 2 * borderEdgeWidth)) {
    1:     return;
    1:   }
    1: 
    1:   // Paint the border
  238:   nsRecessedBorder recessedBorder(borderEdgeWidth, PresContext());
  238:   nsCSSRendering::PaintBorder(PresContext(), aRenderingContext, this, inner,
16424:                               inner, recessedBorder, mStyleContext);
    1: 
    1:   // Adjust the inner rect to account for the one pixel recessed border,
    1:   // and a six pixel padding on each edge
    1:   inner.Deflate(nsPresContext::CSSPixelsToAppUnits(ICON_PADDING+ALT_BORDER_WIDTH), 
    1:                 nsPresContext::CSSPixelsToAppUnits(ICON_PADDING+ALT_BORDER_WIDTH));
    1:   if (inner.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Clip so we don't render outside the inner rect
    1:   aRenderingContext.PushState();
    1:   aRenderingContext.SetClipRect(inner, nsClipCombine_kIntersect);
    1: 
    1:   // Check if we should display image placeholders
31389:   if (gIconLoad->mPrefShowPlaceholders) {
    1:     const nsStyleVisibility* vis = GetStyleVisibility();
    1:     nscoord size = nsPresContext::CSSPixelsToAppUnits(ICON_SIZE);
    1: 
    1:     PRBool iconUsed = PR_FALSE;
    1: 
31389:     // If we weren't previously displaying an icon, register ourselves
31389:     // as an observer for load and animation updates and flag that we're
31389:     // doing so now.
32090:     if (aRequest && !mDisplayingIcon) {
31389:       gIconLoad->AddIconObserver(this);
31389:       mDisplayingIcon = PR_TRUE;
31389:     }
31389: 
31389: 
31389:     // If the image in question is loaded and decoded, draw it
32090:     PRUint32 imageStatus = 0;
32090:     if (aRequest)
31389:       aRequest->GetImageStatus(&imageStatus);
31389:     if (imageStatus & imgIRequest::STATUS_FRAME_COMPLETE) {
    1:       nsCOMPtr<imgIContainer> imgCon;
    1:       aRequest->GetImage(getter_AddRefs(imgCon));
31389:       NS_ABORT_IF_FALSE(imgCon, "Frame Complete, but no image container?");
    1:       nsRect dest((vis->mDirection == NS_STYLE_DIRECTION_RTL) ?
    1:                   inner.XMost() - size : inner.x,
    1:                   inner.y, size, size);
26926:       nsLayoutUtils::DrawSingleImage(&aRenderingContext, imgCon,
26926:         nsLayoutUtils::GetGraphicsFilterForFrame(this), dest, aDirtyRect);
    1:       iconUsed = PR_TRUE;
    1:     }
    1: 
31389:     // if we could not draw the icon, flag that we're waiting for it and
31389:     // just draw some graffiti in the mean time
    1:     if (!iconUsed) {
    1:       nscolor oldColor;
    1:       nscoord iconXPos = (vis->mDirection ==   NS_STYLE_DIRECTION_RTL) ?
    1:                          inner.XMost() - size : inner.x;
    1:       nscoord twoPX = nsPresContext::CSSPixelsToAppUnits(2);
    1:       aRenderingContext.DrawRect(iconXPos, inner.y,size,size);
    1:       aRenderingContext.GetColor(oldColor);
    1:       aRenderingContext.SetColor(NS_RGB(0xFF,0,0));
    1:       aRenderingContext.FillEllipse(size/2 + iconXPos, size/2 + inner.y,
    1:                                     size/2 - twoPX, size/2 - twoPX);
    1:       aRenderingContext.SetColor(oldColor);
    1:     }  
    1: 
    1:     // Reduce the inner rect by the width of the icon, and leave an
    1:     // additional ICON_PADDING pixels for padding
    1:     PRInt32 iconWidth = nsPresContext::CSSPixelsToAppUnits(ICON_SIZE + ICON_PADDING);
    1:     if (vis->mDirection != NS_STYLE_DIRECTION_RTL)
    1:       inner.x += iconWidth;
    1:     inner.width -= iconWidth;
    1:   }
    1: 
    1:   // If there's still room, display the alt-text
    1:   if (!inner.IsEmpty()) {
    1:     nsIContent* content = GetContent();
    1:     if (content) {
    1:       nsXPIDLString altText;
    1:       nsCSSFrameConstructor::GetAlternateTextFor(content, content->Tag(),
    1:                                                  altText);
  238:       DisplayAltText(PresContext(), aRenderingContext, altText, inner);
    1:     }
    1:   }
    1: 
    1:   aRenderingContext.PopState();
    1: }
    1: 
    1: static void PaintAltFeedback(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt)
    1: {
 3233:   nsImageFrame* f = static_cast<nsImageFrame*>(aFrame);
    1:   f->DisplayAltFeedback(*aCtx,
    1:                         aDirtyRect,
    1:                         IMAGE_OK(f->GetContent()->IntrinsicState(), PR_TRUE)
    1:                            ? nsImageFrame::gIconLoad->mLoadingImage
    1:                            : nsImageFrame::gIconLoad->mBrokenImage,
    1:                         aPt);
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: static void PaintDebugImageMap(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt) {
 3233:   nsImageFrame* f = static_cast<nsImageFrame*>(aFrame);
    1:   nsRect inner = f->GetInnerArea() + aPt;
  238:   nsPresContext* pc = f->PresContext();
    1: 
    1:   aCtx->SetColor(NS_RGB(0, 0, 0));
    1:   aCtx->PushState();
    1:   aCtx->Translate(inner.x, inner.y);
16486:   f->GetImageMap(pc)->Draw(aFrame, *aCtx);
    1:   aCtx->PopState();
    1: }
    1: #endif
    1: 
    1: /**
    1:  * Note that nsDisplayImage does not receive events. However, an image element
    1:  * is replaced content so its background will be z-adjacent to the
    1:  * image itself, and hence receive events just as if the image itself
    1:  * received events.
    1:  */
    1: class nsDisplayImage : public nsDisplayItem {
    1: public:
    1:   nsDisplayImage(nsImageFrame* aFrame, imgIContainer* aImage)
    1:     : nsDisplayItem(aFrame), mImage(aImage) {
    1:     MOZ_COUNT_CTOR(nsDisplayImage);
    1:   }
    1:   virtual ~nsDisplayImage() {
    1:     MOZ_COUNT_DTOR(nsDisplayImage);
    1:   }
    1:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect);
    1:   NS_DISPLAY_DECL_NAME("Image")
    1: private:
    1:   nsCOMPtr<imgIContainer> mImage;
    1: };
    1: 
    1: void
    1: nsDisplayImage::Paint(nsDisplayListBuilder* aBuilder,
    1:      nsIRenderingContext* aCtx, const nsRect& aDirtyRect) {
 3233:   static_cast<nsImageFrame*>(mFrame)->
    1:     PaintImage(*aCtx, aBuilder->ToReferenceFrame(mFrame), aDirtyRect, mImage);
    1: }
    1: 
    1: void
    1: nsImageFrame::PaintImage(nsIRenderingContext& aRenderingContext, nsPoint aPt,
    1:                          const nsRect& aDirtyRect, imgIContainer* aImage)
    1: {
    1:   // Render the image into our content area (the area inside
    1:   // the borders and padding)
    1:   NS_ASSERTION(GetInnerArea().width == mComputedSize.width, "bad width");
    1:   nsRect inner = GetInnerArea() + aPt;
    1:   nsRect dest(inner.TopLeft(), mComputedSize);
    1:   dest.y -= GetContinuationOffset();
    1: 
26926:   nsLayoutUtils::DrawSingleImage(&aRenderingContext, aImage,
26926:     nsLayoutUtils::GetGraphicsFilterForFrame(this), dest, aDirtyRect);
    1: 
  238:   nsPresContext* presContext = PresContext();
    1:   nsImageMap* map = GetImageMap(presContext);
    1:   if (nsnull != map) {
    1:     aRenderingContext.PushState();
    1:     aRenderingContext.SetColor(NS_RGB(0, 0, 0));
    1:     aRenderingContext.SetLineStyle(nsLineStyle_kDotted);
    1:     aRenderingContext.Translate(inner.x, inner.y);
16486:     map->Draw(this, aRenderingContext);
    1:     aRenderingContext.PopState();
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                const nsRect&           aDirtyRect,
    1:                                const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   // REVIEW: We don't need any special logic here for deciding which layer
    1:   // to put the background in ... it goes in aLists.BorderBackground() and
    1:   // then if we have a block parent, it will put our background in the right
    1:   // place.
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // REVIEW: Checking mRect.IsEmpty() makes no sense to me, so I removed it.
    1:   // It can't have been protecting us against bad situations with zero-size
    1:   // images since adding a border would make the rect non-empty.
    1:     
    1:   if (mComputedSize.width != 0 && mComputedSize.height != 0) {
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:     NS_ASSERTION(imageLoader, "Not an image loading content?");
    1: 
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     if (imageLoader) {
    1:       imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                               getter_AddRefs(currentRequest));
    1:     }
    1: 
    1:     PRInt32 contentState = mContent->IntrinsicState();
    1:     PRBool imageOK = IMAGE_OK(contentState, PR_TRUE);
    1: 
    1:     nsCOMPtr<imgIContainer> imgCon;
    1:     if (currentRequest) {
    1:       currentRequest->GetImage(getter_AddRefs(imgCon));
    1:     }
    1: 
31389:     // Determine if the size is available
31389:     PRBool haveSize = PR_FALSE;
31389:     PRUint32 imageStatus = 0;
31389:     if (currentRequest)
31389:       currentRequest->GetImageStatus(&imageStatus);
31389:     if (imageStatus & imgIRequest::STATUS_SIZE_AVAILABLE)
31389:       haveSize = PR_TRUE;
31389: 
31389:     // We should never have the size and not have an image container
31389:     NS_ABORT_IF_FALSE(!haveSize || imgCon, "Have size but not container?");
31389: 
31389:     if (!imageOK || !haveSize) {
    1:       // No image yet, or image load failed. Draw the alt-text and an icon
    1:       // indicating the status
    1:       rv = aLists.Content()->AppendNewToTop(new (aBuilder)
    1:           nsDisplayGeneric(this, PaintAltFeedback, "AltFeedback"));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else {
    1:       rv = aLists.Content()->AppendNewToTop(new (aBuilder)
    1:           nsDisplayImage(this, imgCon));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
31389:       // If we were previously displaying an icon, we're not anymore
31389:       if (mDisplayingIcon) {
31389:         gIconLoad->RemoveIconObserver(this);
31389:         mDisplayingIcon = PR_FALSE;
31389:       }
31389: 
31389:         
    1: #ifdef DEBUG
  238:       if (GetShowFrameBorders() && GetImageMap(PresContext())) {
    1:         rv = aLists.Outlines()->AppendNewToTop(new (aBuilder)
    1:             nsDisplayGeneric(this, PaintDebugImageMap, "DebugImageMap"));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: #endif
    1:     }
    1:   }
    1: 
    1:   // XXX what on EARTH is this code for?
    1:   PRInt16 displaySelection = 0;
    1:   nsresult result;
  238:   nsPresContext* presContext = PresContext();
    1:   result = presContext->PresShell()->GetSelectionFlags(&displaySelection);
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   if (!(displaySelection & nsISelectionDisplay::DISPLAY_IMAGES))
    1:     return NS_OK;//no need to check the blue border, we cannot be drawn selected
    1: //insert hook here for image selection drawing
    1: #if IMAGE_EDITOR_CHECK
    1:   //check to see if this frame is in an editor context
    1:   //isEditor check. this needs to be changed to have better way to check
    1:   if (displaySelection == nsISelectionDisplay::DISPLAY_ALL) 
    1:   {
    1:     nsCOMPtr<nsISelectionController> selCon;
    1:     result = GetSelectionController(presContext, getter_AddRefs(selCon));
    1:     if (NS_SUCCEEDED(result) && selCon)
    1:     {
    1:       nsCOMPtr<nsISelection> selection;
    1:       result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
    1:       if (NS_SUCCEEDED(result) && selection)
    1:       {
    1:         PRInt32 rangeCount;
    1:         selection->GetRangeCount(&rangeCount);
    1:         if (rangeCount == 1) //if not one then let code drop to nsFrame::Paint
    1:         {
    1:           nsCOMPtr<nsIContent> parentContent = mContent->GetParent();
    1:           if (parentContent)
    1:           {
    1:             PRInt32 thisOffset = parentContent->IndexOf(mContent);
    1:             nsCOMPtr<nsIDOMNode> parentNode = do_QueryInterface(parentContent);
    1:             nsCOMPtr<nsIDOMNode> rangeNode;
    1:             PRInt32 rangeOffset;
    1:             nsCOMPtr<nsIDOMRange> range;
    1:             selection->GetRangeAt(0,getter_AddRefs(range));
    1:             if (range)
    1:             {
    1:               range->GetStartContainer(getter_AddRefs(rangeNode));
    1:               range->GetStartOffset(&rangeOffset);
    1: 
    1:               if (parentNode && rangeNode && (rangeNode == parentNode) && rangeOffset == thisOffset)
    1:               {
    1:                 range->GetEndContainer(getter_AddRefs(rangeNode));
    1:                 range->GetEndOffset(&rangeOffset);
    1:                 if ((rangeNode == parentNode) && (rangeOffset == (thisOffset +1))) //+1 since that would mean this whole content is selected only
    1:                   return NS_OK; //do not allow nsFrame do draw any further selection
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: #endif
    1:   
    1:   return DisplaySelectionOverlay(aBuilder, aLists,
    1:                                  nsISelectionDisplay::DISPLAY_IMAGES);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::GetImageMap(nsPresContext *aPresContext, nsIImageMap **aImageMap)
    1: {
    1:   nsImageMap *map = GetImageMap(aPresContext);
    1:   return CallQueryInterface(map, aImageMap);
    1: }
    1: 
    1: nsImageMap*
    1: nsImageFrame::GetImageMap(nsPresContext* aPresContext)
    1: {
    1:   if (!mImageMap) {
    1:     nsIDocument* doc = mContent->GetDocument();
    1:     if (!doc) {
    1:       return nsnull;
    1:     }
    1: 
    1:     nsAutoString usemap;
    1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::usemap, usemap);
    1: 
    1:     nsCOMPtr<nsIDOMHTMLMapElement> map = nsImageMapUtils::FindImageMap(doc,usemap);
    1:     if (map) {
    1:       mImageMap = new nsImageMap();
    1:       if (mImageMap) {
    1:         NS_ADDREF(mImageMap);
    1:         mImageMap->Init(aPresContext->PresShell(), this, map);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return mImageMap;
    1: }
    1: 
    1: PRBool
    1: nsImageFrame::IsServerImageMap()
    1: {
    1:   return mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::ismap);
    1: }
    1: 
    1: // Translate an point that is relative to our frame
    1: // into a localized pixel coordinate that is relative to the
    1: // content area of this frame (inside the border+padding).
    1: void
    1: nsImageFrame::TranslateEventCoords(const nsPoint& aPoint,
    1:                                    nsIntPoint&     aResult)
    1: {
    1:   nscoord x = aPoint.x;
    1:   nscoord y = aPoint.y;
    1: 
    1:   // Subtract out border and padding here so that the coordinates are
    1:   // now relative to the content area of this frame.
    1:   nsRect inner = GetInnerArea();
    1:   x -= inner.x;
    1:   y -= inner.y;
    1: 
    1:   aResult.x = nsPresContext::AppUnitsToIntCSSPixels(x);
    1:   aResult.y = nsPresContext::AppUnitsToIntCSSPixels(y);
    1: }
    1: 
    1: PRBool
    1: nsImageFrame::GetAnchorHREFTargetAndNode(nsIURI** aHref, nsString& aTarget,
 3333:                                          nsIContent** aNode)
    1: {
    1:   PRBool status = PR_FALSE;
    1:   aTarget.Truncate();
    1:   *aHref = nsnull;
    1:   *aNode = nsnull;
    1: 
    1:   // Walk up the content tree, looking for an nsIDOMAnchorElement
    1:   for (nsIContent* content = mContent->GetParent();
    1:        content; content = content->GetParent()) {
    1:     nsCOMPtr<nsILink> link(do_QueryInterface(content));
    1:     if (link) {
30307:       *aHref = content->GetHrefURI().get();
    1:       status = (*aHref != nsnull);
    1: 
    1:       nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(content));
    1:       if (anchor) {
    1:         anchor->GetTarget(aTarget);
    1:       }
    1:       NS_ADDREF(*aNode = content);
    1:       break;
    1:     }
    1:   }
    1:   return status;
    1: }
    1: 
    1: NS_IMETHODIMP  
    1: nsImageFrame::GetContentForEvent(nsPresContext* aPresContext,
    1:                                  nsEvent* aEvent,
    1:                                  nsIContent** aContent)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aContent);
    1:   nsImageMap* map;
    1:   map = GetImageMap(aPresContext);
    1: 
    1:   if (nsnull != map) {
    1:     nsIntPoint p;
    1:     TranslateEventCoords(
    1:       nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this), p);
    1:     PRBool inside = PR_FALSE;
    1:     nsCOMPtr<nsIContent> area;
    1:     inside = map->IsInside(p.x, p.y, getter_AddRefs(area));
    1:     if (inside && area) {
    1:       *aContent = area;
    1:       NS_ADDREF(*aContent);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   *aContent = GetContent();
    1:   NS_IF_ADDREF(*aContent);
    1:   return NS_OK;
    1: }
    1: 
    1: // XXX what should clicks on transparent pixels do?
    1: NS_IMETHODIMP
    1: nsImageFrame::HandleEvent(nsPresContext* aPresContext,
    1:                           nsGUIEvent* aEvent,
    1:                           nsEventStatus* aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   nsImageMap* map;
    1: 
19264:   if ((aEvent->eventStructType == NS_MOUSE_EVENT &&
19264:        aEvent->message == NS_MOUSE_BUTTON_UP && 
 3233:        static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) ||
    1:       aEvent->message == NS_MOUSE_MOVE) {
    1:     map = GetImageMap(aPresContext);
    1:     PRBool isServerMap = IsServerImageMap();
    1:     if ((nsnull != map) || isServerMap) {
    1:       nsIntPoint p;
    1:       TranslateEventCoords(
    1:         nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this), p);
    1:       PRBool inside = PR_FALSE;
    1:       // Even though client-side image map triggering happens
    1:       // through content, we need to make sure we're not inside
    1:       // (in case we deal with a case of both client-side and
    1:       // sever-side on the same image - it happens!)
    1:       if (nsnull != map) {
    1:         nsCOMPtr<nsIContent> area;
    1:         inside = map->IsInside(p.x, p.y, getter_AddRefs(area));
    1:       }
    1: 
    1:       if (!inside && isServerMap) {
    1: 
    1:         // Server side image maps use the href in a containing anchor
    1:         // element to provide the basis for the destination url.
    1:         nsCOMPtr<nsIURI> uri;
    1:         nsAutoString target;
 3333:         nsCOMPtr<nsIContent> anchorNode;
    1:         if (GetAnchorHREFTargetAndNode(getter_AddRefs(uri), target,
    1:                                        getter_AddRefs(anchorNode))) {
    1:           // XXX if the mouse is over/clicked in the border/padding area
    1:           // we should probably just pretend nothing happened. Nav4
    1:           // keeps the x,y coordinates positive as we do; IE doesn't
    1:           // bother. Both of them send the click through even when the
    1:           // mouse is over the border.
    1:           if (p.x < 0) p.x = 0;
    1:           if (p.y < 0) p.y = 0;
    1:           nsCAutoString spec;
    1:           uri->GetSpec(spec);
    1:           spec += nsPrintfCString("?%d,%d", p.x, p.y);
    1:           uri->SetSpec(spec);                
    1:           
    1:           PRBool clicked = PR_FALSE;
    1:           if (aEvent->message == NS_MOUSE_BUTTON_UP) {
    1:             *aEventStatus = nsEventStatus_eConsumeDoDefault; 
    1:             clicked = PR_TRUE;
    1:           }
 3333:           nsContentUtils::TriggerLink(anchorNode, aPresContext, uri, target,
 3333:                                       clicked, PR_TRUE);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsSplittableFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::GetCursor(const nsPoint& aPoint,
    1:                         nsIFrame::Cursor& aCursor)
    1: {
  238:   nsPresContext* context = PresContext();
    1:   nsImageMap* map = GetImageMap(context);
    1:   if (nsnull != map) {
    1:     nsIntPoint p;
    1:     TranslateEventCoords(aPoint, p);
    1:     nsCOMPtr<nsIContent> area;
    1:     if (map->IsInside(p.x, p.y, getter_AddRefs(area))) {
    1:       // Use the cursor from the style of the *area* element.
    1:       // XXX Using the image as the parent style context isn't
    1:       // technically correct, but it's probably the right thing to do
    1:       // here, since it means that areas on which the cursor isn't
    1:       // specified will inherit the style from the image.
    1:       nsRefPtr<nsStyleContext> areaStyle = 
  238:         PresContext()->PresShell()->StyleSet()->
    1:           ResolveStyleFor(area, GetStyleContext());
    1:       if (areaStyle) {
    1:         FillCursorInformationFromStyle(areaStyle->GetStyleUserInterface(),
    1:                                        aCursor);
    1:         if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
    1:           aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:         }
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1:   return nsFrame::GetCursor(aPoint, aCursor);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                                nsIAtom* aAttribute,
    1:                                PRInt32 aModType)
    1: {
    1:   nsresult rv = nsSplittableFrame::AttributeChanged(aNameSpaceID,
    1:                                                     aAttribute, aModType);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   if (nsGkAtoms::alt == aAttribute)
    1:   {
 1158:     PresContext()->PresShell()->FrameNeedsReflow(this,
 1158:                                                  nsIPresShell::eStyleChange,
 1158:                                                  NS_FRAME_IS_DIRTY);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsImageFrame::GetType() const
    1: {
    1:   return nsGkAtoms::imageFrame;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsImageFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ImageFrame"), aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
    1:   fprintf(out, " [parent=%p]", mParent);
    1: #endif
    1:   if (HasView()) {
    1:     fprintf(out, " [view=%p]", (void*)GetView());
    1:   }
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, 
    1: mRect.height);
    1:   if (0 != mState) {
    1:     fprintf(out, " [state=%08x]", mState);
    1:   }
    1:   fprintf(out, " [content=%p]", (void*)mContent);
    1: 
    1:   // output the img src url
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   if (imageLoader) {
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                             getter_AddRefs(currentRequest));
    1:     if (currentRequest) {
    1:       nsCOMPtr<nsIURI> uri;
    1:       currentRequest->GetURI(getter_AddRefs(uri));
    1:       nsCAutoString uristr;
    1:       uri->GetAsciiSpec(uristr);
    1:       fprintf(out, " [src=%s]", uristr.get());
    1:     }
    1:   }
    1:   fputs("\n", out);
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: PRIntn
    1: nsImageFrame::GetSkipSides() const
    1: {
    1:   PRIntn skip = 0;
    1:   if (nsnull != GetPrevInFlow()) {
    1:     skip |= 1 << NS_SIDE_TOP;
    1:   }
    1:   if (nsnull != GetNextInFlow()) {
    1:     skip |= 1 << NS_SIDE_BOTTOM;
    1:   }
    1:   return skip;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsImageFrame::GetIntrinsicImageSize(nsSize& aSize)
    1: {
    1:   aSize = mIntrinsicSize;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::LoadIcon(const nsAString& aSpec,
    1:                        nsPresContext *aPresContext,
    1:                        imgIRequest** aRequest)
    1: {
    1:   nsresult rv = NS_OK;
    1:   NS_PRECONDITION(!aSpec.IsEmpty(), "What happened??");
    1: 
    1:   if (!sIOService) {
    1:     rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> realURI;
    1:   SpecToURI(aSpec, sIOService, getter_AddRefs(realURI));
    1:  
    1:   nsCOMPtr<imgILoader> il(do_GetService("@mozilla.org/image/loader;1", &rv));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup;
    1:   GetLoadGroup(aPresContext, getter_AddRefs(loadGroup));
    1: 
    1:   // For icon loads, we don't need to merge with the loadgroup flags
    1:   nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
    1: 
    1:   return il->LoadImage(realURI,     /* icon URI */
    1:                        nsnull,      /* initial document URI; this is only
    1:                                        relevant for cookies, so does not
    1:                                        apply to icons. */
    1:                        nsnull,      /* referrer (not relevant for icons) */
    1:                        loadGroup,
31389:                        gIconLoad,
    1:                        nsnull,      /* Not associated with any particular document */
    1:                        loadFlags,
    1:                        nsnull,
    1:                        nsnull,
    1:                        aRequest);
    1: }
    1: 
    1: void
    1: nsImageFrame::GetDocumentCharacterSet(nsACString& aCharset) const
    1: {
    1:   if (mContent) {
    1:     NS_ASSERTION(mContent->GetDocument(),
    1:                  "Frame still alive after content removed from document!");
    1:     aCharset = mContent->GetDocument()->GetDocumentCharacterSet();
    1:   }
    1: }
    1: 
    1: void
    1: nsImageFrame::SpecToURI(const nsAString& aSpec, nsIIOService *aIOService,
    1:                          nsIURI **aURI)
    1: {
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   if (mContent) {
    1:     baseURI = mContent->GetBaseURI();
    1:   }
    1:   nsCAutoString charset;
    1:   GetDocumentCharacterSet(charset);
    1:   NS_NewURI(aURI, aSpec, 
    1:             charset.IsEmpty() ? nsnull : charset.get(), 
    1:             baseURI, aIOService);
    1: }
    1: 
    1: void
    1: nsImageFrame::GetLoadGroup(nsPresContext *aPresContext, nsILoadGroup **aLoadGroup)
    1: {
    1:   if (!aPresContext)
    1:     return;
    1: 
    1:   NS_PRECONDITION(nsnull != aLoadGroup, "null OUT parameter pointer");
    1: 
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1: 
    1:   if (!shell)
    1:     return;
    1: 
    1:   nsIDocument *doc = shell->GetDocument();
    1:   if (!doc)
    1:     return;
    1: 
    1:   *aLoadGroup = doc->GetDocumentLoadGroup().get();  // already_AddRefed
    1: }
    1: 
    1: nsresult nsImageFrame::LoadIcons(nsPresContext *aPresContext)
    1: {
    1:   NS_ASSERTION(!gIconLoad, "called LoadIcons twice");
    1: 
26459:   NS_NAMED_LITERAL_STRING(loadingSrc,"resource://gre/res/loading-image.png");
26459:   NS_NAMED_LITERAL_STRING(brokenSrc,"resource://gre/res/broken-image.png");
    1: 
31389:   gIconLoad = new IconLoad();
    1:   if (!gIconLoad) 
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(gIconLoad);
    1: 
    1:   nsresult rv;
    1:   // create a loader and load the images
    1:   rv = LoadIcon(loadingSrc,
    1:                 aPresContext,
    1:                 getter_AddRefs(gIconLoad->mLoadingImage));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   rv = LoadIcon(brokenSrc,
    1:                 aPresContext,
    1:                 getter_AddRefs(gIconLoad->mBrokenImage));
    1:   return rv;
    1: }
    1: 
31389: NS_IMPL_ISUPPORTS2(nsImageFrame::IconLoad, nsIObserver,
31389:                    imgIDecoderObserver)
    1: 
    1: static const char kIconLoadPrefs[][40] = {
    1:   "browser.display.force_inline_alttext",
    1:   "browser.display.show_image_placeholders"
    1: };
    1: 
31389: nsImageFrame::IconLoad::IconLoad()
    1: {
    1:   nsCOMPtr<nsIPrefBranch2> prefBranch =
    1:     do_QueryInterface(nsContentUtils::GetPrefBranch());
    1: 
    1:   // register observers
    1:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(kIconLoadPrefs); ++i)
    1:     prefBranch->AddObserver(kIconLoadPrefs[i], this, PR_FALSE);
    1: 
    1:   GetPrefs();
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::IconLoad::Observe(nsISupports *aSubject, const char* aTopic,
    1:                                 const PRUnichar* aData)
    1: {
    1:   NS_ASSERTION(!nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID),
    1:                "wrong topic");
    1: #ifdef DEBUG
    1:   // assert |aData| is one of our prefs.
    1:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(kIconLoadPrefs) ||
    1:                        (NS_NOTREACHED("wrong pref"), PR_FALSE); ++i)
    1:     if (NS_ConvertASCIItoUTF16(kIconLoadPrefs[i]) == nsDependentString(aData))
    1:       break;
    1: #endif
    1: 
    1:   GetPrefs();
    1:   return NS_OK;
    1: }
    1: 
    1: void nsImageFrame::IconLoad::GetPrefs()
    1: {
    1:   mPrefForceInlineAltText =
    1:     nsContentUtils::GetBoolPref("browser.display.force_inline_alttext");
    1: 
    1:   mPrefShowPlaceholders =
    1:     nsContentUtils::GetBoolPref("browser.display.show_image_placeholders",
    1:                                 PR_TRUE);
    1: }
    1: 
31389: 
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartRequest(imgIRequest *aRequest)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartDecode(imgIRequest *aRequest)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartContainer(imgIRequest *aRequest,
31389:                                          imgIContainer *aContainer)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartFrame(imgIRequest *aRequest,
31389:                                      PRUint32 aFrame)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnDataAvailable(imgIRequest *aRequest,
31389:                                         PRBool aCurrentFrame,
31389:                                         const nsIntRect * aRect)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopFrame(imgIRequest *aRequest,
31389:                                     PRUint32 aFrame)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopContainer(imgIRequest *aRequest,
31389:                                         imgIContainer *aContainer)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopDecode(imgIRequest *aRequest,
31389:                                      nsresult status,
31389:                                      const PRUnichar *statusArg)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopRequest(imgIRequest *aRequest,
31389:                                       PRBool aIsLastPart)
31389: {
31389:   nsTObserverArray<nsImageFrame*>::ForwardIterator iter(mIconObservers);
31389:   nsImageFrame *frame;
31389:   while (iter.HasMore()) {
31389:     frame = iter.GetNext();
31389:     frame->Invalidate(frame->GetRect());
31389:   }
31389: 
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::FrameChanged(imgIContainer *aContainer,
31389:                                      nsIntRect * aDirtyRect)
31389: {
31389:   nsTObserverArray<nsImageFrame*>::ForwardIterator iter(mIconObservers);
31389:   nsImageFrame *frame;
31389:   while (iter.HasMore()) {
31389:     frame = iter.GetNext();
31389:     frame->Invalidate(frame->GetRect());
31389:   }
31389: 
31389:   return NS_OK;
31389: }
31389: 
31389: 
31389: 
    1: NS_IMPL_ISUPPORTS2(nsImageListener, imgIDecoderObserver, imgIContainerObserver)
    1: 
    1: nsImageListener::nsImageListener(nsImageFrame *aFrame) :
    1:   mFrame(aFrame)
    1: {
    1: }
    1: 
    1: nsImageListener::~nsImageListener()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::OnStartContainer(imgIRequest *aRequest,
    1:                                                 imgIContainer *aImage)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStartContainer(aRequest, aImage);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::OnDataAvailable(imgIRequest *aRequest,
30479:                                                PRBool aCurrentFrame,
23738:                                                const nsIntRect *aRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
30479:   return mFrame->OnDataAvailable(aRequest, aCurrentFrame, aRect);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::OnStopDecode(imgIRequest *aRequest,
    1:                                             nsresult status,
    1:                                             const PRUnichar *statusArg)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStopDecode(aRequest, status, statusArg);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::FrameChanged(imgIContainer *aContainer,
23738:                                             nsIntRect * dirtyRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
30479:   return mFrame->FrameChanged(aContainer, dirtyRect);
    1: }
    1: 
 8578: static PRBool
 8578: IsInAutoWidthTableCellForQuirk(nsIFrame *aFrame)
 8578: {
 8578:   if (eCompatibility_NavQuirks != aFrame->PresContext()->CompatibilityMode())
 8578:     return PR_FALSE;
 8578:   // Check if the parent of the closest nsBlockFrame has auto width.
 8578:   nsBlockFrame *ancestor = nsLayoutUtils::FindNearestBlockAncestor(aFrame);
 8578:   if (ancestor->GetStyleContext()->GetPseudoType() == nsCSSAnonBoxes::cellContent) {
 8578:     // Assume direct parent is a table cell frame.
 8578:     nsFrame *grandAncestor = static_cast<nsFrame*>(ancestor->GetParent());
 8578:     return grandAncestor &&
 8578:       grandAncestor->GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto;
 8578:   }
 8578:   return PR_FALSE;
 8578: }
 8578: 
 8578: /* virtual */ void
 8578: nsImageFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
 8578:                                 nsIFrame::InlineMinWidthData *aData)
 8578: {
 8578: 
 8578:   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
 8578:   
 8578:   PRBool canBreak =
 8578:     !CanContinueTextRun() &&
 8578:     GetParent()->GetStyleText()->WhiteSpaceCanWrap() &&
 8578:     !IsInAutoWidthTableCellForQuirk(this);
 8578: 
 8578:   if (canBreak)
 8578:     aData->OptionallyBreak(aRenderingContext);
 8578:  
 8578:   aData->trailingWhitespace = 0;
 8578:   aData->skipWhitespace = PR_FALSE;
 8578:   aData->trailingTextFrame = nsnull;
 8578:   aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 8578:                             this, nsLayoutUtils::MIN_WIDTH);
 8578:   aData->atStartOfLine = PR_FALSE;
 8578: 
 8578:   if (canBreak)
 8578:     aData->OptionallyBreak(aRenderingContext);
 8578: 
 8578: }
