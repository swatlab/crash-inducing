64190: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43532:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
74581:  *   Nick Fitzgerald <nfitzgerald@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsdbgapi_h___
    1: #define jsdbgapi_h___
    1: /*
    1:  * JS debugger API.
    1:  */
    1: #include "jsapi.h"
    1: #include "jsopcode.h"
    1: #include "jsprvtd.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
64190: extern JS_PUBLIC_API(JSCrossCompartmentCall *)
64190: JS_EnterCrossCompartmentCallScript(JSContext *cx, JSScript *target);
64190: 
74466: extern JS_PUBLIC_API(JSCrossCompartmentCall *)
74466: JS_EnterCrossCompartmentCallStackFrame(JSContext *cx, JSStackFrame *target);
74466: 
64190: #ifdef __cplusplus
64190: JS_END_EXTERN_C
64190: 
64190: namespace JS {
64190: 
64190: class JS_PUBLIC_API(AutoEnterScriptCompartment)
64190: {
74466:   protected:
64190:     JSCrossCompartmentCall *call;
64190: 
64190:   public:
64190:     AutoEnterScriptCompartment() : call(NULL) {}
64190: 
64190:     bool enter(JSContext *cx, JSScript *target);
64190: 
64190:     bool entered() const { return call != NULL; }
64190: 
64190:     ~AutoEnterScriptCompartment() {
64190:         if (call && call != reinterpret_cast<JSCrossCompartmentCall*>(1))
64190:             JS_LeaveCrossCompartmentCall(call);
64190:     }
64190: };
64190: 
74466: class JS_PUBLIC_API(AutoEnterFrameCompartment) : public AutoEnterScriptCompartment
74466: {
74466:   public:
74466:     bool enter(JSContext *cx, JSStackFrame *target);
74466: };
74466: 
64190: } /* namespace JS */
64190: 
79734: #ifdef DEBUG
79734: JS_FRIEND_API(void) js_DumpChars(const jschar *s, size_t n);
79734: JS_FRIEND_API(void) js_DumpString(JSString *str);
79734: JS_FRIEND_API(void) js_DumpAtom(JSAtom *atom);
79734: JS_FRIEND_API(void) js_DumpObject(JSObject *obj);
79734: JS_FRIEND_API(void) js_DumpValue(const js::Value &val);
79734: JS_FRIEND_API(void) js_DumpId(jsid id);
79734: JS_FRIEND_API(void) js_DumpStackFrame(JSContext *cx, js::StackFrame *start = NULL);
79734: #endif
79734: 
64190: JS_BEGIN_EXTERN_C
64190: #endif
64190: 
64190: extern JS_PUBLIC_API(JSString *)
64190: JS_DecompileScript(JSContext *cx, JSScript *script, const char *name, uintN indent);
64190: 
13496: /*
56783:  * Currently, we only support runtime-wide debugging. In the future, we should
56783:  * be able to support compartment-wide debugging.
56783:  */
56783: extern JS_PUBLIC_API(void)
56783: JS_SetRuntimeDebugMode(JSRuntime *rt, JSBool debug);
56783: 
56783: /*
53391:  * Debug mode is a compartment-wide mode that enables a debugger to attach
53391:  * to and interact with running methodjit-ed frames. In particular, it causes
53391:  * every function to be compiled as if an eval was present (so eval-in-frame)
53391:  * can work, and it ensures that functions can be re-JITed for other debug
53391:  * features. In general, it is not safe to interact with frames that were live
53391:  * before debug mode was enabled. For this reason, it is also not safe to
53391:  * enable debug mode while frames are live.
53391:  */
53391: 
53391: /* Get current state of debugging mode. */
53391: extern JS_PUBLIC_API(JSBool)
53391: JS_GetDebugMode(JSContext *cx);
53391: 
62057: /*
71307:  * Turn on/off debugging mode for a single compartment. This should only be
71307:  * used when no code from this compartment is running or on the stack in any
71307:  * thread.
62057:  */
62057: JS_FRIEND_API(JSBool)
62057: JS_SetDebugModeForCompartment(JSContext *cx, JSCompartment *comp, JSBool debug);
61245: 
62057: /*
62057:  * Turn on/off debugging mode for a context's compartment.
62057:  */
62057: JS_FRIEND_API(JSBool)
53391: JS_SetDebugMode(JSContext *cx, JSBool debug);
53391: 
59882: /* Turn on single step mode. */
59882: extern JS_PUBLIC_API(JSBool)
59882: JS_SetSingleStepMode(JSContext *cx, JSScript *script, JSBool singleStep);
59882: 
41863: /* The closure argument will be marked. */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
41863:            JSTrapHandler handler, jsval closure);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
41863:              JSTrapHandler *handlerp, jsval *closurep);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearScriptTraps(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(void)
75506: JS_ClearAllTrapsForCompartment(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
41863: JS_SetInterrupt(JSRuntime *rt, JSInterruptHook handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
41863: JS_ClearInterrupt(JSRuntime *rt, JSInterruptHook *handlerp, void **closurep);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
48470: JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsid id,
51134:                  JSWatchPointHandler handler, JSObject *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
48470: JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsid id,
51134:                    JSWatchPointHandler *handlerp, JSObject **closurep);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ClearAllWatchPoints(JSContext *cx);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(uintN)
    1: JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc);
    1: 
    1: extern JS_PUBLIC_API(jsbytecode *)
    1: JS_LineNumberToPC(JSContext *cx, JSScript *script, uintN lineno);
    1: 
55561: extern JS_PUBLIC_API(jsbytecode *)
55561: JS_EndPC(JSContext *cx, JSScript *script);
55561: 
71318: extern JS_PUBLIC_API(JSBool)
71318: JS_GetLinePCs(JSContext *cx, JSScript *script,
71318:               uintN startLine, uintN maxLines,
71318:               uintN* count, uintN** lines, jsbytecode*** pcs);
71318: 
48470: extern JS_PUBLIC_API(uintN)
48470: JS_GetFunctionArgumentCount(JSContext *cx, JSFunction *fun);
48470: 
48470: extern JS_PUBLIC_API(JSBool)
48470: JS_FunctionHasLocalNames(JSContext *cx, JSFunction *fun);
48470: 
48470: /*
48470:  * N.B. The mark is in the context temp pool and thus the caller must take care
48470:  * to call JS_ReleaseFunctionLocalNameArray in a LIFO manner (wrt to any other
48470:  * call that may use the temp pool.
48470:  */
48470: extern JS_PUBLIC_API(jsuword *)
48470: JS_GetFunctionLocalNameArray(JSContext *cx, JSFunction *fun, void **markp);
48470: 
48470: extern JS_PUBLIC_API(JSAtom *)
48470: JS_LocalNameToAtom(jsuword w);
48470: 
48470: extern JS_PUBLIC_API(JSString *)
48470: JS_AtomKey(JSAtom *atom);
48470: 
48470: extern JS_PUBLIC_API(void)
48470: JS_ReleaseFunctionLocalNameArray(JSContext *cx, void *mark);
48470: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_GetFunctionScript(JSContext *cx, JSFunction *fun);
    1: 
    1: extern JS_PUBLIC_API(JSNative)
    1: JS_GetFunctionNative(JSContext *cx, JSFunction *fun);
    1: 
    1: extern JS_PUBLIC_API(JSPrincipals *)
    1: JS_GetScriptPrincipals(JSContext *cx, JSScript *script);
    1: 
    1: /*
    1:  * Stack Frame Iterator
    1:  *
    1:  * Used to iterate through the JS stack frames to extract
    1:  * information from the frames.
    1:  */
    1: 
    1: extern JS_PUBLIC_API(JSStackFrame *)
    1: JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_GetFrameScript(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(jsbytecode *)
    1: JS_GetFramePC(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
    1:  * Get the closest scripted frame below fp.  If fp is null, start from cx->fp.
    1:  */
    1: extern JS_PUBLIC_API(JSStackFrame *)
    1: JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
53557: JS_IsScriptFrame(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCallObject(JSContext *cx, JSStackFrame *fp);
    1: 
55713: extern JS_PUBLIC_API(JSBool)
55713: JS_GetFrameThis(JSContext *cx, JSStackFrame *fp, jsval *thisv);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fp);
    1: 
84198: JS_PUBLIC_API(JSFunction *)
84198: JS_GetScriptFunction(JSContext *cx, JSScript *script);
84198: 
83331: extern JS_PUBLIC_API(JSObject *)
83331: JS_GetParentOrScopeChain(JSContext *cx, JSObject *obj);
83331: 
    1: /* XXXrginda Initially published with typo */
    1: #define JS_IsContructorFrame JS_IsConstructorFrame
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsDebuggerFrame(JSContext *cx, JSStackFrame *fp);
    1: 
69704: extern JS_PUBLIC_API(JSBool)
69704: JS_IsGlobalFrame(JSContext *cx, JSStackFrame *fp);
69704: 
    1: extern JS_PUBLIC_API(jsval)
    1: JS_GetFrameReturnValue(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetFrameReturnValue(JSContext *cx, JSStackFrame *fp, jsval rval);
    1: 
    1: /**
48676:  * Return fp's callee function object (fp->callee) if it has one. Note that
48676:  * this API cannot fail. A null return means "no callee": fp is a global or
48676:  * eval-from-global frame, not a call frame.
48676:  *
48676:  * This API began life as an infallible getter, but now it can return either:
48676:  *
48676:  * 1. An optimized closure that was compiled assuming the function could not
48676:  *    escape and be called from sites the compiler could not see.
48676:  *
48676:  * 2. A "joined function object", an optimization whereby SpiderMonkey avoids
48676:  *    creating fresh function objects for every evaluation of a function
48676:  *    expression that is used only once by a consumer that either promises to
48676:  *    clone later when asked for the value or that cannot leak the value.
48676:  *
48676:  * Because Mozilla's Gecko embedding of SpiderMonkey (and no doubt other
48676:  * embeddings) calls this API in potentially performance-sensitive ways (e.g.
48676:  * in nsContentUtils::GetDocumentFromCaller), we are leaving this API alone. It
48676:  * may now return an unwrapped non-escaping optimized closure, or a joined
48676:  * function object. Such optimized objects may work well if called from the
48676:  * correct context, never mutated or compared for identity, etc.
48676:  *
48676:  * However, if you really need to get the same callee object that JS code would
48676:  * see, which means undoing the optimizations, where an undo attempt can fail,
48676:  * then use JS_GetValidFrameCalleeObject.
    1:  */
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCalleeObject(JSContext *cx, JSStackFrame *fp);
    1: 
48676: /**
48676:  * Return fp's callee function object after running the deferred closure
48676:  * cloning "method read barrier". This API can fail! If the frame has no
48676:  * callee, this API returns true with JSVAL_IS_VOID(*vp).
48676:  */
48676: extern JS_PUBLIC_API(JSBool)
48676: JS_GetValidFrameCalleeObject(JSContext *cx, JSStackFrame *fp, jsval *vp);
48676: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(const char *)
    1: JS_GetScriptFilename(JSContext *cx, JSScript *script);
    1: 
74581: extern JS_PUBLIC_API(const jschar *)
74581: JS_GetScriptSourceMap(JSContext *cx, JSScript *script);
74581: 
    1: extern JS_PUBLIC_API(uintN)
    1: JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(uintN)
    1: JS_GetScriptLineExtent(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(JSVersion)
    1: JS_GetScriptVersion(JSContext *cx, JSScript *script);
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Hook setters for script creation and destruction, see jsprvtd.h for the
    1:  * typedefs.  These macros provide binary compatibility and newer, shorter
    1:  * synonyms.
    1:  */
    1: #define JS_SetNewScriptHook     JS_SetNewScriptHookProc
    1: #define JS_SetDestroyScriptHook JS_SetDestroyScriptHookProc
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
    1:                         void *callerdata);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                           const jschar *chars, uintN length,
    1:                           const char *filename, uintN lineno,
    1:                           jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                         const char *bytes, uintN length,
    1:                         const char *filename, uintN lineno,
    1:                         jsval *rval);
    1: 
    1: /************************************************************************/
    1: 
    1: typedef struct JSPropertyDesc {
48470:     jsval           id;         /* primary id, atomized string, or int */
    1:     jsval           value;      /* property value */
    1:     uint8           flags;      /* flags, see below */
    1:     uint8           spare;      /* unused */
    1:     uint16          slot;       /* argument/variable slot */
    1:     jsval           alias;      /* alias id if JSPD_ALIAS flag */
    1: } JSPropertyDesc;
    1: 
    1: #define JSPD_ENUMERATE  0x01    /* visible to for/in loop */
    1: #define JSPD_READONLY   0x02    /* assignment is error */
    1: #define JSPD_PERMANENT  0x04    /* property cannot be deleted */
    1: #define JSPD_ALIAS      0x08    /* property has an alias id */
    1: #define JSPD_ARGUMENT   0x10    /* argument to function */
    1: #define JSPD_VARIABLE   0x20    /* local variable in function */
    1: #define JSPD_EXCEPTION  0x40    /* exception occurred fetching the property, */
    1:                                 /* value is exception */
    1: #define JSPD_ERROR      0x80    /* native getter returned JS_FALSE without */
    1:                                 /* throwing an exception */
    1: 
    1: typedef struct JSPropertyDescArray {
    1:     uint32          length;     /* number of elements in array */
    1:     JSPropertyDesc  *array;     /* alloc'd by Get, freed by Put */
    1: } JSPropertyDescArray;
    1: 
52503: typedef struct JSScopeProperty JSScopeProperty;
52503: 
    1: extern JS_PUBLIC_API(JSScopeProperty *)
    1: JS_PropertyIterator(JSObject *obj, JSScopeProperty **iteratorp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
52503: JS_GetPropertyDesc(JSContext *cx, JSObject *obj, JSScopeProperty *shape,
    1:                    JSPropertyDesc *pd);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDescArray(JSContext *cx, JSObject *obj, JSPropertyDescArray *pda);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
41863: JS_SetDebuggerHandler(JSRuntime *rt, JSDebuggerHandler hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
41863: JS_SetThrowHook(JSRuntime *rt, JSThrowHook hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetObjectTotalSize(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetFunctionTotalSize(JSContext *cx, JSFunction *fun);
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetScriptTotalSize(JSContext *cx, JSScript *script);
    1: 
    1: /*
 7987:  * Return true if obj is a "system" object, that is, one created by
 7987:  * JS_NewSystemObject with the system flag set and not JS_NewObject.
 7987:  *
83231:  * What "system" means is up to the API client.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsSystemObject(JSContext *cx, JSObject *obj);
    1: 
    1: /*
43286:  * Mark an object as being a system object. This should be called immediately
43286:  * after allocating the object. A system object is an object for which
43286:  * JS_IsSystemObject returns true.
    1:  */
43286: extern JS_PUBLIC_API(JSBool)
43286: JS_MakeSystemObject(JSContext *cx, JSObject *obj);
    1: 
 2433: /************************************************************************/
 2433: 
53848: extern JS_FRIEND_API(void)
53848: js_RevertVersion(JSContext *cx);
53848: 
35331: extern JS_PUBLIC_API(const JSDebugHooks *)
 2433: JS_GetGlobalDebugHooks(JSRuntime *rt);
 2433: 
 2433: extern JS_PUBLIC_API(JSDebugHooks *)
35331: JS_SetContextDebugHooks(JSContext *cx, const JSDebugHooks *hooks);
 2433: 
37717: /* Disable debug hooks for this context. */
37717: extern JS_PUBLIC_API(JSDebugHooks *)
37717: JS_ClearContextDebugHooks(JSContext *cx);
37717: 
76358: /**
76358:  * Start any profilers that are available and have been configured on for this
76358:  * platform. This is NOT thread safe.
76358:  *
76358:  * The profileName is used by some profilers to describe the current profiling
76358:  * run. It may be used for part of the filename of the output, but the
76358:  * specifics depend on the profiler. Many profilers will ignore it. Passing in
76358:  * NULL is legal; some profilers may use it to output to stdout or similar.
76358:  *
76358:  * Returns true if no profilers fail to start.
76358:  */
60787: extern JS_PUBLIC_API(JSBool)
76358: JS_StartProfiling(const char *profileName);
60787: 
76358: /**
76358:  * Stop any profilers that were previously started with JS_StartProfiling.
76358:  * Returns true if no profilers fail to stop.
76358:  */
76358: extern JS_PUBLIC_API(JSBool)
76358: JS_StopProfiling(const char *profileName);
10339: 
76358: /**
76358:  * Write the current profile data to the given file, if applicable to whatever
76358:  * profiler is being used.
76358:  */
76358: extern JS_PUBLIC_API(JSBool)
76358: JS_DumpProfile(const char *outfile, const char *profileName);
76358: 
76358: /**
76358:  * Pause currently active profilers (only supported by some profilers). Returns
76358:  * whether any profilers failed to pause. (Profilers that do not support
76358:  * pause/resume do not count.)
76358:  */
76358: extern JS_PUBLIC_API(JSBool)
76358: JS_PauseProfilers(const char *profileName);
76358: 
76358: /**
76358:  * Resume suspended profilers
76358:  */
76358: extern JS_PUBLIC_API(JSBool)
76358: JS_ResumeProfilers(const char *profileName);
76358: 
76358: /**
76358:  * Add various profiling-related functions as properties of the given object.
76358:  */
13496: extern JS_PUBLIC_API(JSBool)
60787: JS_DefineProfilingFunctions(JSContext *cx, JSObject *obj);
10339: 
76244: /* Defined in vm/Debugger.cpp. */
75397: extern JS_PUBLIC_API(JSBool)
75513: JS_DefineDebuggerObject(JSContext *cx, JSObject *obj);
75397: 
76358: /**
76358:  * The profiling API calls are not able to report errors, so they use a
76358:  * thread-unsafe global memory buffer to hold the last error encountered. This
76358:  * should only be called after something returns false.
76358:  */
76358: JS_PUBLIC_API(const char *)
76358: JS_UnsafeGetLastProfilingError();
76358: 
15763: #ifdef MOZ_CALLGRIND
15763: 
15763: extern JS_FRIEND_API(JSBool)
76358: js_StopCallgrind();
15763: 
15763: extern JS_FRIEND_API(JSBool)
76358: js_StartCallgrind();
15763: 
15763: extern JS_FRIEND_API(JSBool)
76358: js_DumpCallgrind(const char *outfile);
15763: 
15763: #endif /* MOZ_CALLGRIND */
15763: 
16288: #ifdef MOZ_VTUNE
16288: 
76358: extern JS_FRIEND_API(bool)
76358: js_StartVtune(const char *profileName);
16288: 
76358: extern JS_FRIEND_API(bool)
76358: js_StopVtune();
16288: 
76358: extern JS_FRIEND_API(bool)
76358: js_PauseVtune();
16288: 
76358: extern JS_FRIEND_API(bool)
76358: js_ResumeVtune();
16288: 
16288: #endif /* MOZ_VTUNE */
16288: 
71700: extern JS_PUBLIC_API(void)
76358: JS_DumpBytecode(JSContext *cx, JSScript *script);
71700: 
71700: extern JS_PUBLIC_API(void)
76358: JS_DumpCompartmentBytecode(JSContext *cx);
71700: 
82134: extern JS_PUBLIC_API(void)
82134: JS_DumpPCCounts(JSContext *cx, JSScript *script);
82134: 
82134: extern JS_PUBLIC_API(void)
82134: JS_DumpCompartmentPCCounts(JSContext *cx);
82134: 
79734: extern JS_PUBLIC_API(JSObject *)
79734: JS_UnwrapObject(JSObject *obj);
79734: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsdbgapi_h___ */
