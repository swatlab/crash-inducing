 54007: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 54007:  * vim: sw=2 ts=8 et :
 54007:  */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 54007: 
105604: #include "base/basictypes.h"
105604: 
 54007: #include "BasicLayers.h"
105604: #include "gfxPlatform.h"
 75159: #if defined(MOZ_ENABLE_D3D10_LAYER)
 75159: # include "LayerManagerD3D10.h"
 75159: #endif
105604: #include "mozilla/dom/TabChild.h"
 98041: #include "mozilla/Hal.h"
105604: #include "mozilla/layers/CompositorChild.h"
105604: #include "mozilla/layers/PLayersChild.h"
 54007: #include "PuppetWidget.h"
108457: #include "nsIWidgetListener.h"
 54007: 
 98041: using namespace mozilla::dom;
 98041: using namespace mozilla::hal;
 54007: using namespace mozilla::layers;
 54007: using namespace mozilla::widget;
 54007: 
 54007: static void
 54007: InvalidateRegion(nsIWidget* aWidget, const nsIntRegion& aRegion)
 54007: {
 54007:   nsIntRegionRectIterator it(aRegion);
 54007:   while(const nsIntRect* r = it.Next()) {
 87336:     aWidget->Invalidate(*r);
 54007:   }
 54007: }
 54007: 
 54007: /*static*/ already_AddRefed<nsIWidget>
105604: nsIWidget::CreatePuppetWidget(TabChild* aTabChild)
 54007: {
 54007:   NS_ABORT_IF_FALSE(nsIWidget::UsePuppetWidgets(),
 54007:                     "PuppetWidgets not allowed in this configuration");
 54007: 
 54599:   nsCOMPtr<nsIWidget> widget = new PuppetWidget(aTabChild);
 54007:   return widget.forget();
 54007: }
 54007: 
 54007: namespace mozilla {
 54007: namespace widget {
 54007: 
 63002: static bool
 63002: IsPopup(const nsWidgetInitData* aInitData)
 63002: {
 63002:   return aInitData && aInitData->mWindowType == eWindowType_popup;
 63002: }
 63002: 
 63002: static bool
 63002: MightNeedIMEFocus(const nsWidgetInitData* aInitData)
 63002: {
 63002:   // In the puppet-widget world, popup widgets are just dummies and
 63002:   // shouldn't try to mess with IME state.
 63002:   return !IsPopup(aInitData);
 63002: }
 63002: 
 63002: 
 54007: // Arbitrary, fungible.
 54007: const size_t PuppetWidget::kMaxDimension = 4000;
 54007: 
 54007: NS_IMPL_ISUPPORTS_INHERITED1(PuppetWidget, nsBaseWidget,
 54007:                              nsISupportsWeakReference)
 54007: 
105604: PuppetWidget::PuppetWidget(TabChild* aTabChild)
 54599:   : mTabChild(aTabChild)
 58528:   , mDPI(-1)
 54007: {
 54007:   MOZ_COUNT_CTOR(PuppetWidget);
 54007: }
 54007: 
 54007: PuppetWidget::~PuppetWidget()
 54007: {
 54007:   MOZ_COUNT_DTOR(PuppetWidget);
 54007: }
 54007: 
 54007: NS_IMETHODIMP
 54007: PuppetWidget::Create(nsIWidget        *aParent,
 54007:                      nsNativeWidget   aNativeParent,
 54007:                      const nsIntRect  &aRect,
 68668:                      nsDeviceContext *aContext,
 54007:                      nsWidgetInitData *aInitData)
 54007: {
 54007:   NS_ABORT_IF_FALSE(!aNativeParent, "got a non-Puppet native parent");
 54007: 
108460:   BaseCreate(nullptr, aRect, aContext, aInitData);
 54007: 
 54007:   mBounds = aRect;
 80486:   mEnabled = true;
 80486:   mVisible = true;
 54007: 
 54007:   mSurface = gfxPlatform::GetPlatform()
 54007:              ->CreateOffscreenSurface(gfxIntSize(1, 1),
 54254:                                       gfxASurface::ContentFromFormat(gfxASurface::ImageFormatARGB32));
 54007: 
 80486:   mIMEComposing = false;
110655:   mNeedIMEStateInit = MightNeedIMEFocus(aInitData);
 54602: 
 54007:   PuppetWidget* parent = static_cast<PuppetWidget*>(aParent);
 54007:   if (parent) {
 54007:     parent->SetChild(this);
 54019:     mLayerManager = parent->GetLayerManager();
 54007:   }
 54007:   else {
 80486:     Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, false);
 54007:   }
 54007: 
 54007:   return NS_OK;
 54007: }
 54007: 
110655: void
110655: PuppetWidget::InitIMEState()
110655: {
110655:   if (mNeedIMEStateInit) {
110655:     uint32_t chromeSeqno;
110655:     mTabChild->SendNotifyIMEFocus(false, &mIMEPreference, &chromeSeqno);
110655:     mIMELastBlurSeqno = mIMELastReceivedSeqno = chromeSeqno;
110655:     mNeedIMEStateInit = false;
110655:   }
110655: }
110655: 
 54007: already_AddRefed<nsIWidget>
 54007: PuppetWidget::CreateChild(const nsIntRect  &aRect,
 68668:                           nsDeviceContext *aContext,
 54007:                           nsWidgetInitData *aInitData,
 79445:                           bool             aForceUseIWidgetParent)
 54007: {
 63002:   bool isPopup = IsPopup(aInitData);
 54599:   nsCOMPtr<nsIWidget> widget = nsIWidget::CreatePuppetWidget(mTabChild);
 54007:   return ((widget &&
106838:            NS_SUCCEEDED(widget->Create(isPopup ? nullptr: this, nullptr, aRect,
 80842:                                        aContext, aInitData))) ?
106838:           widget.forget() : nullptr);
 54007: }
 54007: 
 54007: NS_IMETHODIMP
 54010: PuppetWidget::Destroy()
 54010: {
 64171:   Base::OnDestroy();
 54010:   Base::Destroy();
 54010:   mPaintTask.Revoke();
106838:   mChild = nullptr;
 58810:   if (mLayerManager) {
 58810:     mLayerManager->Destroy();
 58810:   }
106838:   mLayerManager = nullptr;
106838:   mTabChild = nullptr;
 54010:   return NS_OK;
 54010: }
 54010: 
 54010: NS_IMETHODIMP
 79445: PuppetWidget::Show(bool aState)
 54007: {
 54007:   NS_ASSERTION(mEnabled,
 54007:                "does it make sense to Show()/Hide() a disabled widget?");
 54007: 
 79445:   bool wasVisible = mVisible;
 54007:   mVisible = aState;
 54007: 
117323:   if (mChild) {
117323:     mChild->mVisible = aState;
117323:   }
117323: 
117323:   if (!mVisible && mLayerManager) {
117323:     mLayerManager->ClearCachedResources();
117323:   }
117323: 
 54007:   if (!wasVisible && mVisible) {
 80486:     Resize(mBounds.width, mBounds.height, false);
117323:     Invalidate(mBounds);
 54007:   }
 54007: 
 54007:   return NS_OK;
 54007: }
 54007: 
 54007: NS_IMETHODIMP
108991: PuppetWidget::Resize(int32_t aWidth,
108991:                      int32_t aHeight,
 79445:                      bool    aRepaint)
 54007: {
 54007:   nsIntRect oldBounds = mBounds;
 54007:   mBounds.SizeTo(nsIntSize(aWidth, aHeight));
 54007: 
 54007:   if (mChild) {
 54007:     return mChild->Resize(aWidth, aHeight, aRepaint);
 54007:   }
 54007: 
 54007:   // XXX: roc says that |aRepaint| dictates whether or not to
 54007:   // invalidate the expanded area
 54007:   if (oldBounds.Size() < mBounds.Size() && aRepaint) {
 54007:     nsIntRegion dirty(mBounds);
 54007:     dirty.Sub(dirty,  oldBounds);
 54007:     InvalidateRegion(this, dirty);
 54007:   }
 54007: 
108461:   if (!oldBounds.IsEqualEdges(mBounds) && mAttachedWidgetListener) {
108461:     mAttachedWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
 54007:   }
 54007: 
 54007:   return NS_OK;
 54007: }
 54007: 
 54007: NS_IMETHODIMP
 79445: PuppetWidget::SetFocus(bool aRaise)
 54007: {
 54007:   // XXX/cjones: someone who knows about event handling needs to
 54007:   // decide how this should work.
 54007:   return NS_OK;
 54007: }
 54007: 
 54007: NS_IMETHODIMP
 87336: PuppetWidget::Invalidate(const nsIntRect& aRect)
 54007: {
 54007: #ifdef DEBUG
 87336:   debug_DumpInvalidate(stderr, this, &aRect,
110974:                        nsAutoCString("PuppetWidget"), 0);
 54007: #endif
 54007: 
 54007:   if (mChild) {
 87336:     return mChild->Invalidate(aRect);
 54007:   }
 54007: 
 54007:   mDirtyRegion.Or(mDirtyRegion, aRect);
 54007: 
 87336:   if (!mDirtyRegion.IsEmpty() && !mPaintTask.IsPending()) {
 54007:     mPaintTask = new PaintTask(this);
 54007:     return NS_DispatchToCurrentThread(mPaintTask.get());
 54007:   }
 54007: 
 54007:   return NS_OK;
 54007: }
 54007: 
 54599: void
 54599: PuppetWidget::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
 54599: {
106838:   if (nullptr == aPoint) {
 54599:     event.refPoint.x = 0;
 54599:     event.refPoint.y = 0;
 54599:   }
 54599:   else {
 54599:     // use the point override if provided
 54599:     event.refPoint.x = aPoint->x;
 54599:     event.refPoint.y = aPoint->y;
 54599:   }
 54599:   event.time = PR_Now() / 1000;
 54599: }
 54599: 
 54007: NS_IMETHODIMP
 54007: PuppetWidget::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
 54007: {
 54007: #ifdef DEBUG
 54007:   debug_DumpEvent(stdout, event->widget, event,
110974:                   nsAutoCString("PuppetWidget"), 0);
 54007: #endif
 54007: 
 62248:   NS_ABORT_IF_FALSE(!mChild || mChild->mWindowType == eWindowType_popup,
 62248:                     "Unexpected event dispatch!");
 62248: 
 54007:   aStatus = nsEventStatus_eIgnore;
 62248: 
108461:   NS_ABORT_IF_FALSE(mAttachedWidgetListener, "No listener!");
 62248: 
 54602:   if (event->message == NS_COMPOSITION_START) {
 80486:     mIMEComposing = true;
 54871:   }
 54871:   switch (event->eventStructType) {
 54871:   case NS_COMPOSITION_EVENT:
 54871:     mIMELastReceivedSeqno = static_cast<nsCompositionEvent*>(event)->seqno;
 54871:     if (mIMELastReceivedSeqno < mIMELastBlurSeqno)
 54871:       return NS_OK;
 54871:     break;
 54871:   case NS_TEXT_EVENT:
 54871:     mIMELastReceivedSeqno = static_cast<nsTextEvent*>(event)->seqno;
 54871:     if (mIMELastReceivedSeqno < mIMELastBlurSeqno)
 54871:       return NS_OK;
 54871:     break;
 54871:   case NS_SELECTION_EVENT:
 54871:     mIMELastReceivedSeqno = static_cast<nsSelectionEvent*>(event)->seqno;
 54871:     if (mIMELastReceivedSeqno < mIMELastBlurSeqno)
 54871:       return NS_OK;
 54871:     break;
 54602:   }
108460: 
108461:   aStatus = mAttachedWidgetListener->HandleEvent(event, mUseAttachedEvents);
 54602: 
 54602:   if (event->message == NS_COMPOSITION_END) {
 80486:     mIMEComposing = false;
 54602:   }
 54007: 
 54007:   return NS_OK;
 54007: }
 54007: 
 54007: LayerManager*
 75149: PuppetWidget::GetLayerManager(PLayersChild* aShadowManager,
 75149:                               LayersBackend aBackendHint,
 75149:                               LayerManagerPersistence aPersistence,
 75149:                               bool* aAllowRetaining)
 54007: {
 54007:   if (!mLayerManager) {
 75159:     // The backend hint is a temporary placeholder until Azure, when
 75159:     // all content-process layer managers will be BasicLayerManagers.
 75159: #if defined(MOZ_ENABLE_D3D10_LAYER)
105710:     if (mozilla::layers::LAYERS_D3D10 == aBackendHint) {
 75159:       nsRefPtr<LayerManagerD3D10> m = new LayerManagerD3D10(this);
 75159:       m->AsShadowForwarder()->SetShadowManager(aShadowManager);
 75159:       if (m->Initialize()) {
 75159:         mLayerManager = m;
 75159:       }
 75159:     }
 75159: #endif
 75159:     if (!mLayerManager) {
 54019:       mLayerManager = new BasicShadowLayerManager(this);
 75149:       mLayerManager->AsShadowForwarder()->SetShadowManager(aShadowManager);
 73862:     }
 75159:   }
 55858:   if (aAllowRetaining) {
 55858:     *aAllowRetaining = true;
 55858:   }
 54007:   return mLayerManager;
 54007: }
 54007: 
 54007: gfxASurface*
 54007: PuppetWidget::GetThebesSurface()
 54007: {
 54007:   return mSurface;
 54007: }
 54007: 
 54007: nsresult
 79445: PuppetWidget::IMEEndComposition(bool aCancel)
 54602: {
 54602:   nsEventStatus status;
 80486:   nsTextEvent textEvent(true, NS_TEXT_TEXT, this);
106838:   InitEvent(textEvent, nullptr);
 62993:   textEvent.seqno = mIMELastReceivedSeqno;
 59213:   // SendEndIMEComposition is always called since ResetInputState
 59213:   // should always be called even if we aren't composing something.
 54602:   if (!mTabChild ||
 54602:       !mTabChild->SendEndIMEComposition(aCancel, &textEvent.theText)) {
 54602:     return NS_ERROR_FAILURE;
 54602:   }
 59213: 
 59213:   if (!mIMEComposing)
 59213:     return NS_OK;
 59213: 
 54602:   DispatchEvent(&textEvent, status);
 54602: 
 80486:   nsCompositionEvent compEvent(true, NS_COMPOSITION_END, this);
106838:   InitEvent(compEvent, nullptr);
 62993:   compEvent.seqno = mIMELastReceivedSeqno;
 54602:   DispatchEvent(&compEvent, status);
 54602:   return NS_OK;
 54602: }
 54602: 
 54602: NS_IMETHODIMP
 54602: PuppetWidget::ResetInputState()
 54602: {
 80486:   return IMEEndComposition(false);
 54602: }
 54602: 
 54602: NS_IMETHODIMP
 54602: PuppetWidget::CancelComposition()
 54602: {
 80486:   return IMEEndComposition(true);
 54602: }
 54602: 
 82841: NS_IMETHODIMP_(void)
 82841: PuppetWidget::SetInputContext(const InputContext& aContext,
 82841:                               const InputContextAction& aAction)
 54602: {
 82841:   if (!mTabChild) {
 82841:     return;
 82841:   }
 82842:   mTabChild->SendSetInputContext(
108991:     static_cast<int32_t>(aContext.mIMEState.mEnabled),
108991:     static_cast<int32_t>(aContext.mIMEState.mOpen),
 82840:     aContext.mHTMLInputType,
109516:     aContext.mHTMLInputInputmode,
 82841:     aContext.mActionHint,
108991:     static_cast<int32_t>(aAction.mCause),
108991:     static_cast<int32_t>(aAction.mFocusChange));
 54602: }
 54602: 
 82841: NS_IMETHODIMP_(InputContext)
 82841: PuppetWidget::GetInputContext()
 54602: {
 82841:   InputContext context;
 82841:   if (mTabChild) {
108991:     int32_t enabled, open;
 82842:     mTabChild->SendGetInputContext(&enabled, &open);
 82842:     context.mIMEState.mEnabled = static_cast<IMEState::Enabled>(enabled);
 82842:     context.mIMEState.mOpen = static_cast<IMEState::Open>(open);
 82841:   }
 82841:   return context;
 54602: }
 54602: 
 54602: NS_IMETHODIMP
 79445: PuppetWidget::OnIMEFocusChange(bool aFocus)
 54602: {
 54602:   if (!mTabChild)
 54602:     return NS_ERROR_FAILURE;
 54602: 
 54602:   if (aFocus) {
 54602:     nsEventStatus status;
 80486:     nsQueryContentEvent queryEvent(true, NS_QUERY_TEXT_CONTENT, this);
106838:     InitEvent(queryEvent, nullptr);
 54602:     // Query entire content
115367:     queryEvent.InitForQueryTextContent(0, UINT32_MAX);
 54602:     DispatchEvent(&queryEvent, status);
 54602: 
 54602:     if (queryEvent.mSucceeded) {
 54602:       mTabChild->SendNotifyIMETextHint(queryEvent.mReply.mString);
 54602:     }
 54603:   } else {
 54603:     // ResetInputState might not have been called yet
 54603:     ResetInputState();
 54602:   }
 54602: 
108991:   uint32_t chromeSeqno;
 80486:   mIMEPreference.mWantUpdates = false;
 80486:   mIMEPreference.mWantHints = false;
 54871:   if (!mTabChild->SendNotifyIMEFocus(aFocus, &mIMEPreference, &chromeSeqno))
 54602:     return NS_ERROR_FAILURE;
 54602: 
 54602:   if (aFocus) {
 54602:     if (!mIMEPreference.mWantUpdates && !mIMEPreference.mWantHints)
 54602:       // call OnIMEFocusChange on blur but no other updates
 54602:       return NS_SUCCESS_IME_NO_UPDATES;
 54602:     OnIMESelectionChange(); // Update selection
 54871:   } else {
 54871:     mIMELastBlurSeqno = chromeSeqno;
 54602:   }
 54602:   return NS_OK;
 54602: }
 54602: 
 54602: NS_IMETHODIMP
108991: PuppetWidget::OnIMETextChange(uint32_t aStart, uint32_t aEnd, uint32_t aNewEnd)
 54602: {
 54602:   if (!mTabChild)
 54602:     return NS_ERROR_FAILURE;
 54602: 
 54602:   if (mIMEPreference.mWantHints) {
 54602:     nsEventStatus status;
 80486:     nsQueryContentEvent queryEvent(true, NS_QUERY_TEXT_CONTENT, this);
106838:     InitEvent(queryEvent, nullptr);
115367:     queryEvent.InitForQueryTextContent(0, UINT32_MAX);
 54602:     DispatchEvent(&queryEvent, status);
 54602: 
 54602:     if (queryEvent.mSucceeded) {
 54602:       mTabChild->SendNotifyIMETextHint(queryEvent.mReply.mString);
 54602:     }
 54602:   }
 54602:   if (mIMEPreference.mWantUpdates) {
 54602:     mTabChild->SendNotifyIMETextChange(aStart, aEnd, aNewEnd);
 54602:   }
 54602:   return NS_OK;
 54602: }
 54602: 
 54602: NS_IMETHODIMP
 54602: PuppetWidget::OnIMESelectionChange(void)
 54602: {
 54602:   if (!mTabChild)
 54602:     return NS_ERROR_FAILURE;
 54602: 
 54602:   if (mIMEPreference.mWantUpdates) {
 54602:     nsEventStatus status;
 80486:     nsQueryContentEvent queryEvent(true, NS_QUERY_SELECTED_TEXT, this);
106838:     InitEvent(queryEvent, nullptr);
 54602:     DispatchEvent(&queryEvent, status);
 54602: 
 54602:     if (queryEvent.mSucceeded) {
 54871:       mTabChild->SendNotifyIMESelection(mIMELastReceivedSeqno,
 54871:                                         queryEvent.GetSelectionStart(),
 54602:                                         queryEvent.GetSelectionEnd());
 54602:     }
 54602:   }
 54602:   return NS_OK;
 54602: }
 54602: 
 73592: NS_IMETHODIMP
 73592: PuppetWidget::SetCursor(nsCursor aCursor)
 73592: {
113745:   if (mCursor == aCursor) {
113745:     return NS_OK;
113745:   }
113745: 
 73592:   if (!mTabChild ||
 73592:       !mTabChild->SendSetCursor(aCursor)) {
 73592:     return NS_ERROR_FAILURE;
 73592:   }
113745: 
113745:   mCursor = aCursor;
113745: 
 73592:   return NS_OK;
 73592: }
 73592: 
 54602: nsresult
108457: PuppetWidget::Paint()
 54007: {
 54007:   NS_ABORT_IF_FALSE(!mDirtyRegion.IsEmpty(), "paint event logic messed up");
 54007: 
108461:   if (!mAttachedWidgetListener)
108457:     return NS_OK;
108457: 
108457:   nsIntRegion region = mDirtyRegion;
 54007: 
 54007:   // reset repaint tracking
 54007:   mDirtyRegion.SetEmpty();
 54007:   mPaintTask.Revoke();
 54007: 
 54007:   {
 54007: #ifdef DEBUG
108457:     debug_DumpPaintEvent(stderr, this, region,
110974:                          nsAutoCString("PuppetWidget"), 0);
 54007: #endif
 54007: 
105710:     if (mozilla::layers::LAYERS_D3D10 == mLayerManager->GetBackendType()) {
108461:       mAttachedWidgetListener->PaintWindow(this, region, false, true);
 75159:     } else {
 54007:       nsRefPtr<gfxContext> ctx = new gfxContext(mSurface);
 89947:       ctx->Rectangle(gfxRect(0,0,0,0));
 89947:       ctx->Clip();
 54007:       AutoLayerManagerSetup setupLayerManager(this, ctx,
106914:                                               BUFFER_NONE);
108461:       mAttachedWidgetListener->PaintWindow(this, region, false, true);
105604:       mTabChild->NotifyPainted();
 54007:     }
 75159:   }
 54007: 
118126:   if (mAttachedWidgetListener) {
108461:     mAttachedWidgetListener->DidPaintWindow();
118126:   }
 54007: 
 54007:   return NS_OK;
 54007: }
 54007: 
 54007: void
 54007: PuppetWidget::SetChild(PuppetWidget* aChild)
 54007: {
 54007:   NS_ABORT_IF_FALSE(this != aChild, "can't parent a widget to itself");
 54007:   NS_ABORT_IF_FALSE(!aChild->mChild,
 54007:                     "fake widget 'hierarchy' only expected to have one level");
 54007: 
 54007:   mChild = aChild;
 54007: }
 54007: 
 54007: NS_IMETHODIMP
 54007: PuppetWidget::PaintTask::Run()
 54007: {
 54007:   if (mWidget) {
108457:     mWidget->Paint();
 54007:   }
 54007:   return NS_OK;
 54007: }
 54007: 
117323: bool
117323: PuppetWidget::NeedsPaint()
117323: {
117323:   return mVisible;
117323: }
117323: 
 58528: float
 58528: PuppetWidget::GetDPI()
 58528: {
 58528:   if (mDPI < 0) {
 58528:     NS_ABORT_IF_FALSE(mTabChild, "Need TabChild to get the DPI from!");
110655:     mTabChild->GetDPI(&mDPI);
 58528:   }
 58528: 
 58528:   return mDPI;
 58528: }
 58528: 
 77658: void*
108991: PuppetWidget::GetNativeData(uint32_t aDataType)
 77658: {
 77658:   switch (aDataType) {
 77658:   case NS_NATIVE_SHAREABLE_WINDOW: {
 77658:     NS_ABORT_IF_FALSE(mTabChild, "Need TabChild to get the nativeWindow from!");
106118:     mozilla::WindowsHandle nativeData = 0;
 77658:     mTabChild->SendGetWidgetNativeData(&nativeData);
 77658:     return (void*)nativeData;
 77658:   }
 77658:   case NS_NATIVE_WINDOW:
 77658:   case NS_NATIVE_DISPLAY:
 77658:   case NS_NATIVE_PLUGIN_PORT:
 77658:   case NS_NATIVE_GRAPHIC:
 77658:   case NS_NATIVE_SHELLWIDGET:
 77658:   case NS_NATIVE_WIDGET:
 77658:     NS_WARNING("nsWindow::GetNativeData not implemented for this type");
 77658:     break;
 77658:   default:
 77658:     NS_WARNING("nsWindow::GetNativeData called with bad value");
 77658:     break;
 77658:   }
106838:   return nullptr;
 77658: }
 77658: 
 98041: PuppetScreen::PuppetScreen(void *nativeScreen)
 98041: {
 98041: }
 98041: 
 98041: PuppetScreen::~PuppetScreen()
 98041: {
 98041: }
 98041: 
 98041: static ScreenConfiguration
 98041: ScreenConfig()
 98041: {
 98041:   ScreenConfiguration config;
 98041:   hal::GetCurrentScreenConfiguration(&config);
 98041:   return config;
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreen::GetRect(int32_t *outLeft,  int32_t *outTop,
108991:                       int32_t *outWidth, int32_t *outHeight)
 98041: {
 98041:   nsIntRect r = ScreenConfig().rect();
 98041:   *outLeft = r.x;
 98041:   *outTop = r.y;
 98041:   *outWidth = r.width;
 98041:   *outHeight = r.height;
 98041:   return NS_OK;
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreen::GetAvailRect(int32_t *outLeft,  int32_t *outTop,
108991:                            int32_t *outWidth, int32_t *outHeight)
 98041: {
 98041:   return GetRect(outLeft, outTop, outWidth, outHeight);
 98041: }
 98041: 
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreen::GetPixelDepth(int32_t *aPixelDepth)
 98041: {
 98041:   *aPixelDepth = ScreenConfig().pixelDepth();
 98041:   return NS_OK;
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreen::GetColorDepth(int32_t *aColorDepth)
 98041: {
 98041:   *aColorDepth = ScreenConfig().colorDepth();
 98041:   return NS_OK;
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreen::GetRotation(uint32_t* aRotation)
 98041: {
 98041:   NS_WARNING("Attempt to get screen rotation through nsIScreen::GetRotation().  Nothing should know or care this in sandboxed contexts.  If you want *orientation*, use hal.");
 98041:   return NS_ERROR_NOT_AVAILABLE;
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreen::SetRotation(uint32_t aRotation)
 98041: {
 98041:   NS_WARNING("Attempt to set screen rotation through nsIScreen::GetRotation().  Nothing should know or care this in sandboxed contexts.  If you want *orientation*, use hal.");
 98041:   return NS_ERROR_NOT_AVAILABLE;
 98041: }
 98041: 
 98041: NS_IMPL_ISUPPORTS1(PuppetScreenManager, nsIScreenManager)
 98041: 
 98041: PuppetScreenManager::PuppetScreenManager()
 98041: {
106838:     mOneScreen = new PuppetScreen(nullptr);
 98041: }
 98041: 
 98041: PuppetScreenManager::~PuppetScreenManager()
 98041: {
 98041: }
 98041: 
 98041: NS_IMETHODIMP
 98041: PuppetScreenManager::GetPrimaryScreen(nsIScreen** outScreen)
 98041: {
 98041:   NS_IF_ADDREF(*outScreen = mOneScreen.get());
 98041:   return NS_OK;
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreenManager::ScreenForRect(int32_t inLeft,
108991:                                    int32_t inTop,
108991:                                    int32_t inWidth,
108991:                                    int32_t inHeight,
 98041:                                    nsIScreen** outScreen)
 98041: {
 98041:   return GetPrimaryScreen(outScreen);
 98041: }
 98041: 
 98041: NS_IMETHODIMP
 98041: PuppetScreenManager::ScreenForNativeWidget(void* aWidget,
 98041:                                            nsIScreen** outScreen)
 98041: {
 98041:   return GetPrimaryScreen(outScreen);
 98041: }
 98041: 
 98041: NS_IMETHODIMP
108991: PuppetScreenManager::GetNumberOfScreens(uint32_t* aNumberOfScreens)
 98041: {
 98041:   *aNumberOfScreens = 1;
 98041:   return NS_OK;
 98041: }
 98041: 
 54007: }  // namespace widget
 54007: }  // namespace mozilla
