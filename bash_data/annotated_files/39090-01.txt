32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
32836: /* ***** BEGIN LICENSE BLOCK *****
32836:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32836:  *
32836:  * The contents of this file are subject to the Mozilla Public License Version
32836:  * 1.1 (the "License"); you may not use this file except in compliance with
32836:  * the License. You may obtain a copy of the License at
32836:  * http://www.mozilla.org/MPL/
32836:  *
32836:  * Software distributed under the License is distributed on an "AS IS" basis,
32836:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32836:  * for the specific language governing rights and limitations under the
32836:  * License.
32836:  *
32836:  * The Original Code is mozilla.org code.
32836:  *
32836:  * The Initial Developer of the Original Code is
32836:  *   Mozilla Corporation.
32836:  * Portions created by the Initial Developer are Copyright (C) 2009
32836:  * the Initial Developer. All Rights Reserved.
32836:  *
32836:  * Contributor(s):
32836:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
32836:  *   Mark Steele <mwsteele@gmail.com>
32836:  *
32836:  * Alternatively, the contents of this file may be used under the terms of
32836:  * either the GNU General Public License Version 2 or later (the "GPL"), or
32836:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32836:  * in which case the provisions of the GPL or the LGPL are applicable instead
32836:  * of those above. If you wish to allow use of your version of this file only
32836:  * under the terms of either the GPL or the LGPL, and not to allow others to
32836:  * use your version of this file under the terms of the MPL, indicate your
32836:  * decision by deleting the provisions above and replace them with the notice
32836:  * and other provisions required by the GPL or the LGPL. If you do not delete
32836:  * the provisions above, a recipient may use your version of this file under
32836:  * the terms of any one of the MPL, the GPL or the LGPL.
32836:  *
32836:  * ***** END LICENSE BLOCK ***** */
32836: 
32195: #include "WebGLContext.h"
32195: 
32195: #include "nsString.h"
32195: 
32195: #include "gfxImageSurface.h"
32195: #include "gfxContext.h"
32195: #include "gfxPlatform.h"
32195: //#include "nsIDOMHTMLCanvasElement.h"
32195: 
32195: #include "nsContentUtils.h"
32195: #include "nsDOMError.h"
32195: #include "nsLayoutUtils.h"
32195: 
32195: #include "CanvasUtils.h"
32195: #include "NativeJSContext.h"
32195: 
37417: #include "jstypedarray.h"
37417: 
32195: using namespace mozilla;
32195: 
32195: // XXX why is this broken?
32195: #ifndef GL_BLEND_EQUATION
32195: #define GL_BLEND_EQUATION 0x8009
32195: #endif
32195: 
32195: static PRBool BaseTypeAndSizeFromUniformType(GLenum uType, GLenum *baseType, GLint *unitSize);
32195: 
32195: /* Helper macros for when we're just wrapping a gl method, so that
32195:  * we can avoid having to type this 500 times.  Note that these MUST
32195:  * NOT BE USED if we need to check any of the parameters.
32195:  */
32195: 
32195: #define GL_SAME_METHOD_0(glname, name)                          \
32195: NS_IMETHODIMP WebGLContext::name() {                            \
32195:     MakeContextCurrent(); gl->f##glname(); return NS_OK;        \
32195: }
32195: 
32195: #define GL_SAME_METHOD_1(glname, name, t1)          \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1) {           \
32195:     MakeContextCurrent(); gl->f##glname(a1); return NS_OK;  \
32195: }
32195: 
32195: #define GL_SAME_METHOD_2(glname, name, t1, t2)        \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2) {      \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2); return NS_OK;           \
32195: }
32195: 
32195: #define GL_SAME_METHOD_3(glname, name, t1, t2, t3)      \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3); return NS_OK;        \
32195: }
32195: 
32195: #define GL_SAME_METHOD_4(glname, name, t1, t2, t3, t4)         \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4); return NS_OK;     \
32195: }
32195: 
32195: #define GL_SAME_METHOD_5(glname, name, t1, t2, t3, t4, t5)            \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5); return NS_OK;  \
32195: }
32195: 
32195: #define GL_SAME_METHOD_6(glname, name, t1, t2, t3, t4, t5, t6)          \
32195: NS_IMETHODIMP WebGLContext::name(t1 a1, t2 a2, t3 a3, t4 a4, t5 a5, t6 a6) { \
32195:     MakeContextCurrent(); gl->f##glname(a1,a2,a3,a4,a5,a6); return NS_OK; \
32195: }
32195: 
32195: //
32195: //  WebGL API
32195: //
32195: 
32195: /* readonly attribute nsIDOMHTMLCanvasElement canvas; */
32195: NS_IMETHODIMP
32195: WebGLContext::GetCanvas(nsIDOMHTMLCanvasElement **aCanvas)
32195: {
32195:     return NS_ERROR_NOT_IMPLEMENTED;
32195: }
32195: 
32835: 
32835: /* void present (); */
32835: NS_IMETHODIMP
32835: WebGLContext::Present()
32835: {
32835:     return NS_ERROR_NOT_IMPLEMENTED;
32835: }
32835: 
34453: /* long sizeInBytes (in GLenum type); */
34453: NS_IMETHODIMP
34453: WebGLContext::SizeInBytes(GLenum type, PRInt32 *retval)
34453: {
34453:     if (type == LOCAL_GL_FLOAT) *retval = sizeof(float);
34453:     if (type == LOCAL_GL_SHORT) *retval = sizeof(short);
34453:     if (type == LOCAL_GL_UNSIGNED_SHORT) *retval = sizeof(unsigned short);
34453:     if (type == LOCAL_GL_BYTE) *retval = 1;
34453:     if (type == LOCAL_GL_UNSIGNED_BYTE) *retval = 1;
34453:     if (type == LOCAL_GL_INT) *retval = sizeof(int);
34453:     if (type == LOCAL_GL_UNSIGNED_INT) *retval = sizeof(unsigned int);
34453:     if (type == LOCAL_GL_DOUBLE) *retval = sizeof(double);
34453:     return NS_OK;
34453: }
32835: 
32195: /* void GlActiveTexture (in PRUint32 texture); */
32195: NS_IMETHODIMP
32195: WebGLContext::ActiveTexture(PRUint32 texture)
32195: {
32195:     if (texture < LOCAL_GL_TEXTURE0 || texture >= LOCAL_GL_TEXTURE0+mBound2DTextures.Length())
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     MakeContextCurrent();
32195:     mActiveTexture = texture - LOCAL_GL_TEXTURE0;
32195:     gl->fActiveTexture(texture);
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::AttachShader(nsIWebGLProgram *prog, nsIWebGLShader *sh)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     if (!sh || static_cast<WebGLShader*>(sh)->Deleted())
32195:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195:     GLuint shader = static_cast<WebGLShader*>(sh)->GLName();
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fAttachShader(program, shader);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::BindAttribLocation(nsIWebGLProgram *prog, GLuint location, const nsAString& name)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     if (name.IsEmpty())
32195:         return ErrorMessage("glBindAttribLocation: name can't be null or empty!");
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fBindAttribLocation(program, location, NS_LossyConvertUTF16toASCII(name).get());
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::BindBuffer(GLenum target, nsIWebGLBuffer *buffer)
32195: {
32195:     WebGLBuffer *wbuf = static_cast<WebGLBuffer*>(buffer);
32195: 
32195:     if (wbuf && wbuf->Deleted())
32195:         return ErrorMessage("glBindBuffer: buffer has already been deleted!");
32195: 
32195:     MakeContextCurrent();
32195: 
35488:     //printf ("BindBuffer0: %04x\n", gl->fGetError());
35488: 
32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
32195:         mBoundArrayBuffer = wbuf;
32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
32195:         mBoundElementArrayBuffer = wbuf;
32195:     } else {
32195:         return ErrorMessage("glBindBuffer: invalid target!");
32195:     }
32195: 
32195:     gl->fBindBuffer(target, wbuf ? wbuf->GLName() : 0);
32195: 
35488:     //printf ("BindBuffer: %04x\n", gl->fGetError());
35488: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::BindFramebuffer(GLenum target, nsIWebGLFramebuffer *fb)
32195: {
32195:     WebGLFramebuffer *wfb = static_cast<WebGLFramebuffer*>(fb);
32195: 
32195:     if (wfb && wfb->Deleted())
32195:         return ErrorMessage("glBindFramebuffer: framebuffer has already been deleted!");
32195: 
32195:     MakeContextCurrent();
32195: 
35494:     if (target != LOCAL_GL_FRAMEBUFFER) {
35494:         return ErrorMessage("glBindFramebuffer: target must be GL_FRAMEBUFFER");
32195:     }
32195: 
32195:     gl->fBindFramebuffer(target, wfb ? wfb->GLName() : 0);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::BindRenderbuffer(GLenum target, nsIWebGLRenderbuffer *rb)
32195: {
32195:     WebGLRenderbuffer *wrb = static_cast<WebGLRenderbuffer*>(rb);
32195: 
32195:     if (wrb && wrb->Deleted())
32195:         return ErrorMessage("glBindRenderbuffer: renderbuffer has already been deleted!");
32195: 
32195:     if (target != LOCAL_GL_RENDERBUFFER)
35494:         return ErrorMessage("glBindRenderbuffer: target must be GL_RENDERBUFFER");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fBindRenderbuffer(target, wrb ? wrb->GLName() : 0);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::BindTexture(GLenum target, nsIWebGLTexture *tex)
32195: {
32195:     WebGLTexture *wtex = static_cast<WebGLTexture*>(tex);
32195: 
32195:     if (wtex && wtex->Deleted())
32195:         return ErrorMessage("glBindTexture: texture has already been deleted!");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     if (target == LOCAL_GL_TEXTURE_2D) {
32195:         mBound2DTextures[mActiveTexture] = wtex;
32195:     } else if (target == LOCAL_GL_TEXTURE_CUBE_MAP) {
32195:         mBoundCubeMapTextures[mActiveTexture] = wtex;
32195:     } else {
32195:         return ErrorMessage("glBindTexture: invalid target");
32195:     }
32195: 
32195:     gl->fBindTexture(target, wtex ? wtex->GLName() : 0);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_4(BlendColor, BlendColor, float, float, float, float)
32195: 
32195: GL_SAME_METHOD_1(BlendEquation, BlendEquation, PRUint32)
32195: 
32195: GL_SAME_METHOD_2(BlendEquationSeparate, BlendEquationSeparate, PRUint32, PRUint32)
32195: 
32195: GL_SAME_METHOD_2(BlendFunc, BlendFunc, PRUint32, PRUint32)
32195: 
32195: GL_SAME_METHOD_4(BlendFuncSeparate, BlendFuncSeparate, PRUint32, PRUint32, PRUint32, PRUint32)
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::BufferData(PRInt32 dummy)
32195: {
37417:     // this should never be called
37417:     LogMessage("BufferData");
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::BufferData_size(GLenum target, GLsizei size, GLenum usage)
32195: {
32195:     WebGLBuffer *boundBuffer = NULL;
32195: 
32195:     if (target == LOCAL_GL_ARRAY_BUFFER) {
32195:         boundBuffer = mBoundArrayBuffer;
32195:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
32195:         boundBuffer = mBoundElementArrayBuffer;
32195:     } else {
37417:         return ErrorMessage("BufferData: invalid target");
32195:     }
32195: 
37417:     if (boundBuffer == nsnull)
37417:         return ErrorMessage("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     // XXX what happens if BufferData fails? We probably shouldn't
37417:     // update our size here then, right?
37417:     boundBuffer->SetByteLength(size);
37417:     gl->fBufferData(target, size, 0, usage);
37417: 
37417:     return NS_OK;
32195: }
32195: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferData_buf(GLenum target, js::ArrayBuffer *wb, GLenum usage)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
37417:         return ErrorMessage("BufferData: invalid target");
37417:     }
37417: 
37417:     if (boundBuffer == nsnull)
37417:         return ErrorMessage("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(wb->byteLength);
37417:     gl->fBufferData(target, wb->byteLength, wb->data, usage);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferData_array(GLenum target, js::TypedArray *wa, GLenum usage)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
37417:         return ErrorMessage("BufferData: invalid target");
37417:     }
37417: 
37417:     if (boundBuffer == nsnull)
37417:         return ErrorMessage("BufferData: no buffer bound!");
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     boundBuffer->SetByteLength(wa->byteLength);
37417:     gl->fBufferData(target, wa->byteLength, wa->data, usage);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferSubData(PRInt32 dummy)
37417: {
32195:     return NS_ERROR_FAILURE;
32195: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferSubData_buf(GLenum target, GLsizei offset, js::ArrayBuffer *wb)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
37417:     } else {
37417:         return ErrorMessage("BufferSubData: invalid target");
32195:     }
37417: 
37417:     if (boundBuffer == nsnull)
37417:         return ErrorMessage("BufferSubData: no buffer bound!");
37417: 
37417:     // XXX check for overflow
37417:     if (offset + wb->byteLength > boundBuffer->ByteLength())
37417:         return ErrorMessage("BufferSubData: data too big! Operation requires %d bytes, but buffer only has %d bytes.", offset, wb->byteLength, boundBuffer->ByteLength());
32195: 
32195:     MakeContextCurrent();
32195: 
37417:     gl->fBufferSubData(target, offset, wb->byteLength, wb->data);
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::BufferSubData_array(GLenum target, GLsizei offset, js::TypedArray *wa)
37417: {
37417:     WebGLBuffer *boundBuffer = NULL;
37417: 
37417:     if (target == LOCAL_GL_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundArrayBuffer;
37417:     } else if (target == LOCAL_GL_ELEMENT_ARRAY_BUFFER) {
37417:         boundBuffer = mBoundElementArrayBuffer;
34453:     } else {
37417:         return ErrorMessage("BufferSubData: invalid target");
34453:     }
37417: 
37417:     if (boundBuffer == nsnull)
37417:         return ErrorMessage("BufferSubData: no buffer bound!");
37417: 
37417:     // XXX check for overflow
37417:     if (offset + wa->byteLength > boundBuffer->ByteLength())
37417:         return ErrorMessage("BufferSubData: data too big! Operation requires %d bytes, but buffer only has %d bytes.", offset, wa->byteLength, boundBuffer->ByteLength());
34453: 
34453:     MakeContextCurrent();
34453: 
37417:     gl->fBufferSubData(target, offset, wa->byteLength, wa->data);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CheckFramebufferStatus(GLenum target, GLenum *retval)
32195: {
32195:     MakeContextCurrent();
32195:     // XXX check target
32195:     *retval = gl->fCheckFramebufferStatus(target);
32195:     return NS_OK;
32195: }
32195: 
34453: NS_IMETHODIMP
34453: WebGLContext::Clear(PRUint32 mask)
34453: {
34453:     MakeContextCurrent();
34453:     gl->fClear(mask);
34453:     Invalidate();
34453: 
34453:     return NS_OK;
34453: }
32195: 
32195: GL_SAME_METHOD_4(ClearColor, ClearColor, float, float, float, float)
32195: 
32195: #ifdef USE_GLES2
34019: GL_SAME_METHOD_1(ClearDepthf, ClearDepth, float)
32195: #else
34019: GL_SAME_METHOD_1(ClearDepth, ClearDepth, float)
32195: #endif
32195: 
32195: GL_SAME_METHOD_1(ClearStencil, ClearStencil, PRInt32)
32195: 
32195: GL_SAME_METHOD_4(ColorMask, ColorMask, GLboolean, GLboolean, GLboolean, GLboolean)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CopyTexImage2D(GLenum target,
32195:                                GLint level,
32195:                                GLenum internalformat,
32195:                                GLint x,
32195:                                GLint y,
32195:                                GLsizei width,
32195:                                GLsizei height,
32195:                                GLint border)
32195: {
32195:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
32195:             return ErrorMessage("copyTexImage2D: unsupported target");
32195:     }
32195: 
32195:     switch (internalformat) {
32195:         case LOCAL_GL_RGB:
32195:         case LOCAL_GL_RGBA:
32195:         case LOCAL_GL_ALPHA:
32195:         case LOCAL_GL_LUMINANCE:
32195:         case LOCAL_GL_LUMINANCE_ALPHA:
32195:             break;
32195:         default:
32195:             return ErrorMessage("copyTexImage2D: internal format not supported");
32195:     }
32195: 
32195:     if (border != 0) {
32195:         return ErrorMessage("copyTexImage2D: border != 0");
32195:     }
32195: 
32195:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight)) {
32195:         return ErrorMessage("copyTexImage2D: copied rectangle out of bounds");
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CopyTexSubImage2D(GLenum target,
32195:                                   GLint level,
32195:                                   GLint xoffset,
32195:                                   GLint yoffset,
32195:                                   GLint x,
32195:                                   GLint y,
32195:                                   GLsizei width,
32195:                                   GLsizei height)
32195: {
32195:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
32195:             return ErrorMessage("copyTexSubImage2D: unsupported target");
32195:     }
32195: 
32195:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width, height, mWidth, mHeight)) {
32195:         return ErrorMessage("copyTexSubImage2D: copied rectangle out of bounds");
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CreateProgram(nsIWebGLProgram **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = gl->fCreateProgram();
32195: 
32195:     WebGLProgram *prog = new WebGLProgram(name);
32195:     if (prog) {
32195:         NS_ADDREF(*retval = prog);
32195:         mMapPrograms.Put(name, prog);
32195:     } else {
32195:         gl->fDeleteProgram(name);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CreateShader(GLenum type, nsIWebGLShader **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = gl->fCreateShader(type);
32195: 
32195:     WebGLShader *shader = new WebGLShader(name);
32195:     if (shader) {
32195:         NS_ADDREF(*retval = shader);
32195:         mMapShaders.Put(name, shader);
32195:     } else {
32195:         gl->fDeleteShader(name);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_1(CullFace, CullFace, GLenum)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DeleteBuffer(nsIWebGLBuffer *globj)
32195: {
32195:     WebGLBuffer *obj = static_cast<WebGLBuffer*>(globj);
32195:     if (!obj || obj->Deleted()) {
32195:         return NS_OK;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = obj->GLName();
32195:     gl->fDeleteBuffers(1, &name);
32195:     obj->Delete();
32195:     mMapBuffers.Remove(name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DeleteFramebuffer(nsIWebGLFramebuffer *globj)
32195: {
32195:     WebGLFramebuffer *obj = static_cast<WebGLFramebuffer*>(globj);
32195:     if (!obj || obj->Deleted()) {
32195:         return NS_OK;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = obj->GLName();
32195:     gl->fDeleteFramebuffers(1, &name);
32195:     obj->Delete();
32195:     mMapFramebuffers.Remove(name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DeleteRenderbuffer(nsIWebGLRenderbuffer *globj)
32195: {
32195:     WebGLRenderbuffer *obj = static_cast<WebGLRenderbuffer*>(globj);
32195:     if (!obj || obj->Deleted()) {
32195:         return NS_OK;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     // XXX we need to track renderbuffer attachments; from glDeleteRenderbuffers man page:
32195: 
32195:     /*
32195:             If a renderbuffer object that is currently bound is deleted, the binding reverts
32195:             to 0 (the absence of any renderbuffer object). Additionally, special care
32195:             must be taken when deleting a renderbuffer object if the image of the renderbuffer
32195:             is attached to a framebuffer object. In this case, if the deleted renderbuffer object is
32195:             attached to the currently bound framebuffer object, it is 
32195:             automatically detached.  However, attachments to any other framebuffer objects are the
32195:             responsibility of the application.
32195:     */  
32195: 
32195:     GLuint name = obj->GLName();
32195:     gl->fDeleteRenderbuffers(1, &name);
32195:     obj->Delete();
32195:     mMapRenderbuffers.Remove(name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DeleteTexture(nsIWebGLTexture *globj)
32195: {
32195:     WebGLTexture *obj = static_cast<WebGLTexture*>(globj);
32195:     if (!obj || obj->Deleted()) {
32195:         return NS_OK;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = obj->GLName();
32195:     gl->fDeleteTextures(1, &name);
32195:     obj->Delete();
32195:     mMapTextures.Remove(name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DeleteProgram(nsIWebGLProgram *globj)
32195: {
32195:     WebGLProgram *obj = static_cast<WebGLProgram*>(globj);
32195:     if (!obj || obj->Deleted()) {
32195:         return NS_OK;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = obj->GLName();
32195:     gl->fDeleteProgram(name);
32195:     obj->Delete();
32195:     mMapPrograms.Remove(name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DeleteShader(nsIWebGLShader *globj)
32195: {
32195:     WebGLShader *obj = static_cast<WebGLShader*>(globj);
32195:     if (!obj || obj->Deleted()) {
32195:         return NS_OK;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name = obj->GLName();
32195:     gl->fDeleteShader(name);
32195:     obj->Delete();
32195:     mMapShaders.Remove(name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DetachShader(nsIWebGLProgram *prog, nsIWebGLShader *sh)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     if (!sh || static_cast<WebGLShader*>(sh)->Deleted())
32195:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195:     GLuint shader = static_cast<WebGLShader*>(sh)->GLName();
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fDetachShader(program, shader);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_1(DepthFunc, DepthFunc, GLenum)
32195: 
32195: GL_SAME_METHOD_1(DepthMask, DepthMask, GLboolean)
32195: 
32195: #ifdef USE_GLES2
34019: GL_SAME_METHOD_2(DepthRangef, DepthRange, float, float)
32195: #else
34019: GL_SAME_METHOD_2(DepthRange, DepthRange, float, float)
32195: #endif
32195: 
32195: // XXX arg check!
32195: GL_SAME_METHOD_1(Disable, Disable, GLenum)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DisableVertexAttribArray(GLuint index)
32195: {
32195:     if (index > mAttribBuffers.Length())
32195:         return ErrorMessage("glDisableVertexAttribArray: index out of range");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fDisableVertexAttribArray(index);
32195:     mAttribBuffers[index].enabled = PR_FALSE;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::DrawArrays(GLenum mode, GLint offset, GLsizei count)
32195: {
32195:     switch (mode) {
32195:         case LOCAL_GL_TRIANGLES:
32195:         case LOCAL_GL_TRIANGLE_STRIP:
32195:         case LOCAL_GL_TRIANGLE_FAN:
32195:         case LOCAL_GL_POINTS:
32195:         case LOCAL_GL_LINE_STRIP:
32195:         case LOCAL_GL_LINE_LOOP:
32195:         case LOCAL_GL_LINES:
32195:             break;
32195:         default:
32195:             return ErrorMessage("drawArrays: invalid mode");
32195:     }
32195: 
32195:     if (offset+count < offset || offset+count < count) {
32195:         return ErrorMessage("drawArrays: overflow in offset+count");
32195:     }
32195: 
32195:     if (!ValidateBuffers(offset+count))
32195:         return NS_ERROR_INVALID_ARG;
32195: 
32195:     MakeContextCurrent();
32195: 
35488:     //printf ("DrawArrays0: %04x\n", gl->fGetError());
35488: 
32195:     gl->fDrawArrays(mode, offset, count);
32195: 
35488:     //printf ("DrawArrays: %04x\n", gl->fGetError());
35488: 
32195:     Invalidate();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::DrawElements(GLenum mode, GLuint count, GLenum type, GLuint offset)
32195: {
35487:     int elementSize = 0;
35487: 
32195:     switch (mode) {
32195:         case LOCAL_GL_TRIANGLES:
32195:         case LOCAL_GL_TRIANGLE_STRIP:
32195:         case LOCAL_GL_TRIANGLE_FAN:
32195:         case LOCAL_GL_POINTS:
32195:         case LOCAL_GL_LINE_STRIP:
32195:         case LOCAL_GL_LINE_LOOP:
32195:         case LOCAL_GL_LINES:
32195:             break;
32195:         default:
32195:             return ErrorMessage("drawElements: invalid mode");
32195:     }
32195: 
32195:     switch (type) {
32195:         case LOCAL_GL_UNSIGNED_SHORT:
35487:             elementSize = 2;
35487:             if (offset % 2 != 0)
35487:                 return ErrorMessage("drawElements: invalid offset (must be a multiple of 2) for UNSIGNED_SHORT");
32195:             break;
35487: 
35487:         case LOCAL_GL_UNSIGNED_BYTE:
35487:             elementSize = 1;
35487:             break;
35487: 
32195:         default:
35487:             return ErrorMessage("drawElements: type must be UNSIGNED_SHORT or UNSIGNED_BYTE");
32195:     }
32195: 
32195:     if (!mBoundElementArrayBuffer)
32195:         return ErrorMessage("glDrawElements: must have element array buffer binding!");
32195: 
32195:     if (offset+count < offset || offset+count < count)
32195:         return ErrorMessage("glDrawElements: overflow in offset+count");
32195: 
37417:     if (count*elementSize + offset > mBoundElementArrayBuffer->ByteLength())
32195:         return ErrorMessage("glDrawElements: bound element array buffer is too small for given count and offset");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     // XXXmark fix validation
35487:     // XXX either GLushort or GLubyte; just put this calculation as a method on the array object
32195: #if 0
32195:     GLuint maxindex = 0;
32195:     GLushort *ubuf = (GLushort*) gl->fMapBuffer(LOCAL_GL_ELEMENT_ARRAY_BUFFER, LOCAL_GL_READ_ONLY);
32195:     if (!ubuf)
32195:         return ErrorMessage("glDrawElements: failed to map ELEMENT_ARRAY_BUFFER for validation!");
32195: 
32195:     ubuf += offset;
32195: 
32195:     // XXX cache results for this count,offset pair!
32195:     for (PRUint32 i = 0; i < count; ++i)
38390:         maxindex = NS_MAX(maxindex, *ubuf++);
32195: 
32195:     gl->fUnmapBuffer(LOCAL_GL_ELEMENT_ARRAY_BUFFER);
32195: 
32195:     if (!ValidateBuffers(maxindex))
32195:         return ErrorMessage("glDrawElements: ValidateBuffers failed");
32195: #endif
35487: 
34453:     gl->fDrawElements(mode, count, type, (GLvoid*) (offset));
32195: 
32195:     Invalidate();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: // XXX definitely need to validate this
32195: GL_SAME_METHOD_1(Enable, Enable, PRUint32)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::EnableVertexAttribArray(GLuint index)
32195: {
32195:     if (index > mAttribBuffers.Length())
32195:         return ErrorMessage("glEnableVertexAttribArray: index out of range");
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fEnableVertexAttribArray(index);
32195:     mAttribBuffers[index].enabled = PR_TRUE;
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: // XXX need to track this -- see glDeleteRenderbuffer above and man page for DeleteRenderbuffers
32195: NS_IMETHODIMP
32195: WebGLContext::FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum rbtarget, nsIWebGLRenderbuffer *wrb)
32195: {
32195:     WebGLRenderbuffer *rb = static_cast<WebGLRenderbuffer*>(wrb);
32195: 
32195:     if (rb && rb->Deleted())
32195:         return ErrorMessage("glFramebufferRenderbuffer: renderbuffer has already been deleted!");
32195: 
32195:     if (target != LOCAL_GL_FRAMEBUFFER)
35494:         return ErrorMessage("glFramebufferRenderbuffer: target must be GL_FRAMEBUFFER");
35494: 
35494:     if ((attachment < LOCAL_GL_COLOR_ATTACHMENT0 || attachment >= LOCAL_GL_COLOR_ATTACHMENT0 + mFramebufferColorAttachments.Length()) &&
32195:         attachment != LOCAL_GL_DEPTH_ATTACHMENT &&
32195:         attachment != LOCAL_GL_STENCIL_ATTACHMENT)
32195:         return ErrorMessage("glFramebufferRenderbuffer: invalid attachment");
32195: 
32195:     if (rbtarget != LOCAL_GL_RENDERBUFFER)
32195:         return ErrorMessage("glFramebufferRenderbuffer: rbtarget must be GL_RENDERBUFFER");
32195: 
32195:     GLuint name = rb ? rb->GLName() : 0;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fFramebufferRenderbuffer(target, attachment, rbtarget, name);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::FramebufferTexture2D(GLenum target,
32195:                                    GLenum attachment,
32195:                                    GLenum textarget,
32195:                                    nsIWebGLTexture *wtex,
32195:                                    GLint level)
32195: {
32195:     WebGLTexture *tex = static_cast<WebGLTexture*>(wtex);
32195: 
32195:     if (tex && tex->Deleted())
32195:         return ErrorMessage("glFramebufferTexture2D: texture has already been deleted!");
32195: 
32195:     if (target != LOCAL_GL_FRAMEBUFFER)
32195:         return ErrorMessage("glFramebufferTexture2D: target must be GL_FRAMEBUFFER");
32195: 
35494:     if ((attachment < LOCAL_GL_COLOR_ATTACHMENT0 || attachment >= LOCAL_GL_COLOR_ATTACHMENT0 + mFramebufferColorAttachments.Length()) &&
32195:         attachment != LOCAL_GL_DEPTH_ATTACHMENT &&
32195:         attachment != LOCAL_GL_STENCIL_ATTACHMENT)
32195:         return ErrorMessage("glFramebufferTexture2D: invalid attachment");
32195: 
32195:     if (textarget != LOCAL_GL_TEXTURE_2D &&
32195:         (textarget < LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X ||
32195:          textarget > LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z))
32195:         return ErrorMessage("glFramebufferTexture2D: invalid textarget (only 2D or cube face)");
32195: 
32195:     if (level != 0)
32195:         return ErrorMessage("glFramebufferTexture2D: level must be 0");
32195: 
35494:     // XXXXX we need to store/reference this attachment!
35494: 
32195:     MakeContextCurrent();
32195: 
39090:     gl->fFramebufferTexture2D(target, attachment, textarget, tex ? tex->GLName() : 0, level);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_0(Flush, Flush)
32195: 
32195: GL_SAME_METHOD_0(Finish, Finish)
32195: 
32195: GL_SAME_METHOD_1(FrontFace, FrontFace, GLenum)
32195: 
32195: GL_SAME_METHOD_1(GenerateMipmap, GenerateMipmap, GLenum)
32195: 
32195: // returns an object: { size: ..., type: ..., name: ... }
32195: NS_IMETHODIMP
32835: WebGLContext::GetActiveAttrib(nsIWebGLProgram *prog, PRUint32 index, nsIWebGLActiveInfo **retval)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint len = 0;
32195:     gl->fGetProgramiv(program, LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &len);
32195:     if (len == 0)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsAutoArrayPtr<char> name(new char[len+1]);
32195:     PRInt32 attrsize = 0;
32195:     PRUint32 attrtype = 0;
32195: 
32195:     gl->fGetActiveAttrib(program, index, len+1, &len, (GLint*) &attrsize, (GLuint*) &attrtype, name);
32195:     if (attrsize == 0 || attrtype == 0)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("size", attrsize);
32195:     retobj.DefineProperty("type", attrtype);
32195:     retobj.DefineProperty("name", name, len);
32195: 
32195:     js.SetRetVal(retobj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::GetActiveUniform(nsIWebGLProgram *prog, PRUint32 index, nsIWebGLActiveInfo **retval)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint len = 0;
32195:     gl->fGetProgramiv(program, LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH, &len);
32195:     if (len == 0)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsAutoArrayPtr<char> name(new char[len+1]);
32195:     PRInt32 attrsize = 0;
32195:     PRUint32 attrtype = 0;
32195: 
32195:     gl->fGetActiveUniform(program, index, len+1, &len, (GLint*) &attrsize, (GLenum*) &attrtype, name);
32195:     if (attrsize == 0 || attrtype == 0)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("size", attrsize);
32195:     retobj.DefineProperty("type", attrtype);
32195:     retobj.DefineProperty("name", name, len);
32195: 
32195:     js.SetRetVal(retobj.Object());
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: // XXX fixme to return a IntArray
32195: #if 0
32195: NS_IMETHODIMP
32195: WebGLContext::GetAttachedShaders(nsIWebGLProgram *prog)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint count = 0;
32195:     gl->fGetProgramiv(program, LOCAL_GL_ATTACHED_SHADERS, &count);
32195:     if (count == 0) {
32195:         JSObject *empty = JS_NewArrayObject(js.ctx, 0, NULL);
32195:         js.SetRetVal(empty);
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsAutoArrayPtr<PRUint32> shaders(new PRUint32[count]);
32195: 
32195:     gl->fGetAttachedShaders(program, count, NULL, (GLuint*) shaders.get());
32195: 
32195:     JSObject *obj = NativeJSContext::ArrayToJSArray(js.ctx, shaders, count);
32195: 
32195:     js.AddGCRoot(obj, "GetAttachedShaders");
32195:     js.SetRetVal(obj);
32195:     js.ReleaseGCRoot(obj);
32195: 
32195:     return NS_OK;
32195: }
32195: #endif
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetAttribLocation(nsIWebGLProgram *prog,
32195:                                 const nsAString& name,
32195:                                 PRInt32 *retval)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     MakeContextCurrent();
32195:     *retval = gl->fGetAttribLocation(program, NS_LossyConvertUTF16toASCII(name).get());
32195:     return NS_OK;
32195: }
32195: 
32195: // XXX fixme to return objects correctly for programs/etc.
32195: NS_IMETHODIMP
32195: WebGLContext::GetParameter(PRUint32 pname)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         //
32195:         // String params
32195:         //
32195: 
32195:         // XXX do we want to fake these?  Could be a problem to reveal this to web content
32195:         case LOCAL_GL_VENDOR:
32195:         case LOCAL_GL_RENDERER:
32195:         case LOCAL_GL_VERSION:
32195:         case LOCAL_GL_SHADING_LANGUAGE_VERSION:
32195:         //case LOCAL_GL_EXTENSIONS:  // Not going to expose this
32195: 
32195:             break;
32195: 
32195:         //
32195:         // Single-value params
32195:         //
32195: 
32195: // int
32195:         case LOCAL_GL_ARRAY_BUFFER_BINDING:
32195:         case LOCAL_GL_ELEMENT_ARRAY_BUFFER_BINDING: // XXX really?
32195:         case LOCAL_GL_CULL_FACE_MODE:
32195:         case LOCAL_GL_FRONT_FACE:
32195:         case LOCAL_GL_TEXTURE_BINDING_2D:
32195:         case LOCAL_GL_TEXTURE_BINDING_CUBE_MAP:
32195:         case LOCAL_GL_ACTIVE_TEXTURE:
32195:         case LOCAL_GL_STENCIL_WRITEMASK:
32195:         case LOCAL_GL_STENCIL_BACK_WRITEMASK:
32195:         case LOCAL_GL_DEPTH_CLEAR_VALUE:
32195:         case LOCAL_GL_STENCIL_CLEAR_VALUE:
32195:         case LOCAL_GL_STENCIL_FUNC:
32195:         case LOCAL_GL_STENCIL_VALUE_MASK:
32195:         case LOCAL_GL_STENCIL_REF:
32195:         case LOCAL_GL_STENCIL_FAIL:
32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_FAIL:
32195:         case LOCAL_GL_STENCIL_PASS_DEPTH_PASS:
32195:         case LOCAL_GL_STENCIL_BACK_FUNC:
32195:         case LOCAL_GL_STENCIL_BACK_VALUE_MASK:
32195:         case LOCAL_GL_STENCIL_BACK_REF:
32195:         case LOCAL_GL_STENCIL_BACK_FAIL:
32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_FAIL:
32195:         case LOCAL_GL_STENCIL_BACK_PASS_DEPTH_PASS:
32195:         case LOCAL_GL_DEPTH_FUNC:
32195:         case LOCAL_GL_BLEND_SRC_RGB:
32195:         case LOCAL_GL_BLEND_SRC_ALPHA:
32195:         case LOCAL_GL_BLEND_DST_RGB:
32195:         case LOCAL_GL_BLEND_DST_ALPHA:
32195:         case LOCAL_GL_BLEND_EQUATION_RGB:
32195:         case LOCAL_GL_BLEND_EQUATION_ALPHA:
32195:         //case LOCAL_GL_UNPACK_ALIGNMENT: // not supported
32195:         //case LOCAL_GL_PACK_ALIGNMENT: // not supported
32195:         case LOCAL_GL_CURRENT_PROGRAM:
32195:         case LOCAL_GL_GENERATE_MIPMAP_HINT:
32195:         case LOCAL_GL_SUBPIXEL_BITS:
32195:         case LOCAL_GL_MAX_TEXTURE_SIZE:
32195:         case LOCAL_GL_MAX_CUBE_MAP_TEXTURE_SIZE:
32195:         case LOCAL_GL_MAX_ELEMENTS_INDICES:
32195:         case LOCAL_GL_MAX_ELEMENTS_VERTICES:
32195:         case LOCAL_GL_SAMPLE_BUFFERS:
32195:         case LOCAL_GL_SAMPLES:
32195:         //case LOCAL_GL_COMPRESSED_TEXTURE_FORMATS:
32195:         //case LOCAL_GL_NUM_COMPRESSED_TEXTURE_FORMATS:
32195:         //case LOCAL_GL_SHADER_BINARY_FORMATS:
32195:         //case LOCAL_GL_NUM_SHADER_BINARY_FORMATS:
32195:         case LOCAL_GL_MAX_VERTEX_ATTRIBS:
32195:         case LOCAL_GL_MAX_VERTEX_UNIFORM_COMPONENTS:
32195:         case LOCAL_GL_MAX_VARYING_FLOATS:
32195:         case LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_TEXTURE_IMAGE_UNITS:
32195:         case LOCAL_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
32195:         case LOCAL_GL_MAX_RENDERBUFFER_SIZE:
32195:         case LOCAL_GL_RED_BITS:
32195:         case LOCAL_GL_GREEN_BITS:
32195:         case LOCAL_GL_BLUE_BITS:
32195:         case LOCAL_GL_ALPHA_BITS:
32195:         case LOCAL_GL_DEPTH_BITS:
32195:         case LOCAL_GL_STENCIL_BITS:
32195:         //case LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE:
32195:         //case LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT:
32195:         case LOCAL_GL_RENDERBUFFER_BINDING:
32195:         case LOCAL_GL_FRAMEBUFFER_BINDING:
32195:         {
32195:             PRInt32 iv = 0;
32195:             gl->fGetIntegerv(pname, (GLint*) &iv);
32195:             js.SetRetVal(iv);
32195:         }
32195:             break;
32195: 
32195: // float
32195:         case LOCAL_GL_LINE_WIDTH:
32195:         case LOCAL_GL_POLYGON_OFFSET_FACTOR:
32195:         case LOCAL_GL_POLYGON_OFFSET_UNITS:
32195:         case LOCAL_GL_SAMPLE_COVERAGE_VALUE:
32195:         {
32195:             float fv = 0;
32195:             gl->fGetFloatv(pname, &fv);
32195:             js.SetRetVal((double) fv);
32195:         }
32195:             break;
32195: // bool
32195:         case LOCAL_GL_SAMPLE_COVERAGE_INVERT:
32195:         case LOCAL_GL_COLOR_WRITEMASK:
32195:         case LOCAL_GL_DEPTH_WRITEMASK:
32195:         ////case LOCAL_GL_SHADER_COMPILER: // pretty much must be true 
32195:         {
32195:             realGLboolean bv = 0;
32195:             gl->fGetBooleanv(pname, &bv);
32195:             js.SetBoolRetVal(bv);
32195:         }
32195:             break;
32195: 
32195:         //
32195:         // Complex values
32195:         //
32195:         case LOCAL_GL_DEPTH_RANGE: // 2 floats
32195:         case LOCAL_GL_ALIASED_POINT_SIZE_RANGE: // 2 floats
32195:         case LOCAL_GL_ALIASED_LINE_WIDTH_RANGE: // 2 floats
32195:         {
32195:             float fv[2] = { 0 };
32195:             gl->fGetFloatv(pname, &fv[0]);
32195:             js.SetRetVal(fv, 2);
32195:         }
32195:             break;
32195:         
32195:         case LOCAL_GL_COLOR_CLEAR_VALUE: // 4 floats
32195:         case LOCAL_GL_BLEND_COLOR: // 4 floats
32195:         {
32195:             float fv[4] = { 0 };
32195:             gl->fGetFloatv(pname, &fv[0]);
32195:             js.SetRetVal(fv, 4);
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_MAX_VIEWPORT_DIMS: // 2 ints
32195:         {
32195:             PRInt32 iv[2] = { 0 };
32195:             gl->fGetIntegerv(pname, (GLint*) &iv[0]);
32195:             js.SetRetVal(iv, 2);
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_SCISSOR_BOX: // 4 ints
32195:         case LOCAL_GL_VIEWPORT: // 4 ints
32195:         {
32195:             PRInt32 iv[4] = { 0 };
32195:             gl->fGetIntegerv(pname, (GLint*) &iv[0]);
32195:             js.SetRetVal(iv, 4);
32195:         }
32195:             break;
32195: 
32195:         default:
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
37424: WebGLContext::GetBufferParameter(GLenum target, GLenum pname)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_BUFFER_SIZE:
32195:         case LOCAL_GL_BUFFER_USAGE:
32195:         case LOCAL_GL_BUFFER_ACCESS:
32195:         case LOCAL_GL_BUFFER_MAPPED:
32195:         {
32195:             PRInt32 iv = 0;
32195:             gl->fGetBufferParameteriv(target, pname, (GLint*) &iv);
32195:             js.SetRetVal(iv);
32195:         }
32195:             break;
32195: 
32195:         default:
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
37424: WebGLContext::GetFramebufferAttachmentParameter(GLenum target, GLenum attachment, GLenum pname)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (attachment) {
32195:         case LOCAL_GL_COLOR_ATTACHMENT0:
32195:         case LOCAL_GL_DEPTH_ATTACHMENT:
32195:         case LOCAL_GL_STENCIL_ATTACHMENT:
32195:             break;
32195:         default:
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195:     }
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
32195:         case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
32195:         case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
32195:         case LOCAL_GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
32195:         {
32195:             PRInt32 iv = 0;
32195:             gl->fGetFramebufferAttachmentParameteriv(target, attachment, pname, (GLint*) &iv);
32195:             js.SetRetVal(iv);
32195:         }
32195:             break;
32195: 
32195:         default:
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
37424: WebGLContext::GetRenderbufferParameter(GLenum target, GLenum pname)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         case LOCAL_GL_RENDERBUFFER_WIDTH:
32195:         case LOCAL_GL_RENDERBUFFER_HEIGHT:
32195:         case LOCAL_GL_RENDERBUFFER_INTERNAL_FORMAT:
32195:         case LOCAL_GL_RENDERBUFFER_RED_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_GREEN_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_BLUE_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_ALPHA_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_DEPTH_SIZE:
32195:         case LOCAL_GL_RENDERBUFFER_STENCIL_SIZE:
32195:         {
32195:             PRInt32 iv = 0;
32195:             gl->fGetRenderbufferParameteriv(target, pname, (GLint*) &iv);
32195:             js.SetRetVal(iv);
32195:         }
32195:             break;
32195: 
32195:         default:
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateBuffer(nsIWebGLBuffer **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenBuffers(1, &name);
32195: 
32195:     WebGLBuffer *globj = new WebGLBuffer(name);
32195:     if (globj) {
32195:         NS_ADDREF(*retval = globj);
32195:         mMapBuffers.Put(name, globj);
32195:     } else {
32195:         gl->fDeleteBuffers(1, &name);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateTexture(nsIWebGLTexture **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenTextures(1, &name);
32195: 
32195:     WebGLTexture *globj = new WebGLTexture(name);
32195:     if (globj) {
32195:         NS_ADDREF(*retval = globj);
32195:         mMapTextures.Put(name, globj);
32195:     } else {
32195:         gl->fDeleteTextures(1, &name);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetError(GLenum *_retval)
32195: {
32195:     MakeContextCurrent();
32195:     *_retval = gl->fGetError();
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
35013: WebGLContext::GetProgramParameter(nsIWebGLProgram *prog, PRUint32 pname)
35013: {
35013:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
35013:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
35013: 
35013:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
35013: 
35013:     NativeJSContext js;
35013:     if (NS_FAILED(js.error))
35013:         return js.error;
35013: 
35013:     MakeContextCurrent();
35013: 
35013:     switch (pname) {
35013:         case LOCAL_GL_CURRENT_PROGRAM:
35013:         case LOCAL_GL_DELETE_STATUS:
35013:         case LOCAL_GL_LINK_STATUS:
35013:         case LOCAL_GL_VALIDATE_STATUS:
35013:         case LOCAL_GL_ATTACHED_SHADERS:
35013:         case LOCAL_GL_INFO_LOG_LENGTH:
35013:         case LOCAL_GL_ACTIVE_UNIFORMS:
35013:         case LOCAL_GL_ACTIVE_UNIFORM_MAX_LENGTH:
35013:         case LOCAL_GL_ACTIVE_ATTRIBUTES:
35013:         case LOCAL_GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
35013:         {
35013:             PRInt32 iv = 0;
35013:             gl->fGetProgramiv(program, pname, (GLint*) &iv);
35013:             js.SetRetVal(iv);
35013:         }
35013:             break;
35013: 
35013:         default:
35013:             return NS_ERROR_NOT_IMPLEMENTED;
35013:     }
35013: 
35013:     return NS_OK;
35013: }
35013: 
35013: NS_IMETHODIMP
32195: WebGLContext::GetProgramInfoLog(nsIWebGLProgram *prog, nsAString& retval)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!");
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     PRInt32 k = -1;
32195:     gl->fGetProgramiv(program, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
32195:     if (k == -1)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (k == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString log;
32195:     log.SetCapacity(k);
32195: 
32195:     gl->fGetProgramInfoLog(program, k, (GLint*) &k, (char*) log.BeginWriting());
32195: 
32195:     log.SetLength(k);
32195: 
32195:     CopyASCIItoUTF16(log, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: /* DOMString glGetString (in GLenum name); */
32195: NS_IMETHODIMP
32195: WebGLContext::GetString(GLenum name, nsAString & _retval NS_OUTPARAM)
32195: {
32195:     return NS_ERROR_NOT_IMPLEMENTED;
32195: }
32195: 
32195: /* XXX fix */
32195: /* void texParameter (); */
32195: NS_IMETHODIMP
32835: WebGLContext::TexParameterf(GLenum target, GLenum pname, GLfloat param)
32835: {
32835:     NativeJSContext js;
32835:     if (NS_FAILED(js.error))
32835:         return js.error;
32835: 
32835:     if (js.argc != 3)
32835:         return NS_ERROR_DOM_SYNTAX_ERR;
32835: 
32835:     MakeContextCurrent();
32835: 
32835:     gl->fTexParameterf (target, pname, param);
32835: 
32835:     return NS_OK;
32835: }
32835: NS_IMETHODIMP
32835: WebGLContext::TexParameteri(GLenum target, GLenum pname, GLint param)
32835: {
32835:     NativeJSContext js;
32835:     if (NS_FAILED(js.error))
32835:         return js.error;
32835: 
32835:     if (js.argc != 3)
32835:         return NS_ERROR_DOM_SYNTAX_ERR;
32835: 
32835:     MakeContextCurrent();
32835: 
32835:     gl->fTexParameteri (target, pname, param);
32835: 
32835:     return NS_OK;
32835: }
32835: 
32835: #if 0
32835: NS_IMETHODIMP
32195: WebGLContext::TexParameter()
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     if (js.argc != 3)
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     jsuint targetVal;
32195:     jsuint pnameVal;
32195:     if (!::JS_ValueToECMAUint32(js.ctx, js.argv[0], &targetVal) ||
32195:         !::JS_ValueToECMAUint32(js.ctx, js.argv[1], &pnameVal))
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     if (targetVal != LOCAL_GL_TEXTURE_2D &&
32195:         targetVal != LOCAL_GL_TEXTURE_CUBE_MAP)
32195:     {
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195:     switch (pnameVal) {
32195:         case LOCAL_GL_TEXTURE_MIN_FILTER: {
32195:             jsuint ival;
32195:             if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                 (ival != LOCAL_GL_NEAREST &&
32195:                  ival != LOCAL_GL_LINEAR &&
32195:                  ival != LOCAL_GL_NEAREST_MIPMAP_NEAREST &&
32195:                  ival != LOCAL_GL_LINEAR_MIPMAP_NEAREST &&
32195:                  ival != LOCAL_GL_NEAREST_MIPMAP_LINEAR &&
32195:                  ival != LOCAL_GL_LINEAR_MIPMAP_LINEAR))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_TEXTURE_MAG_FILTER: {
32195:             jsuint ival;
32195:             if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                 (ival != LOCAL_GL_NEAREST &&
32195:                  ival != LOCAL_GL_LINEAR))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_TEXTURE_WRAP_S:
32195:         case LOCAL_GL_TEXTURE_WRAP_T: {
32195:             jsuint ival;
32195:             if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                 (ival != LOCAL_GL_CLAMP &&
32195:                  ival != LOCAL_GL_CLAMP_TO_EDGE &&
32195:                  ival != LOCAL_GL_REPEAT))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_GENERATE_MIPMAP: {
32195:             jsuint ival;
32195:             if (js.argv[2] == JSVAL_TRUE)
32195:                 ival = 1;
32195:             else if (js.argv[2] == JSVAL_FALSE)
32195:                 ival = 0;
32195:             else if (!::JS_ValueToECMAUint32(js.ctx, js.argv[2], &ival) ||
32195:                      (ival != 0 && ival != 1))
32195:                 return NS_ERROR_DOM_SYNTAX_ERR;
32195:             gl->fTexParameteri (targetVal, pnameVal, ival);
32195:         }
32195:             break;
32195:         case LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT: {
32195: #if 0
32195:             if (GLEW_EXT_texture_filter_anisotropic) {
32195:                 jsdouble dval;
32195:                 if (!::JS_ValueToNumber(js.ctx, js.argv[2], &dval))
32195:                     return NS_ERROR_DOM_SYNTAX_ERR;
32195:                 gl->fTexParameterf (targetVal, pnameVal, (float) dval);
32195:             } else {
32195:                 return NS_ERROR_NOT_IMPLEMENTED;
32195:             }
32195: #else
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195: #endif
32195:         }
32195:             break;
32195:         default:
32195:             return NS_ERROR_DOM_SYNTAX_ERR;
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32835: #endif
32195: 
32835: NS_IMETHODIMP
35013: WebGLContext::GetTexParameter(GLenum target, GLenum pname)
32835: {
32835:     NativeJSContext js;
32835:     if (NS_FAILED(js.error))
32835:         return js.error;
32835: 
32835:     MakeContextCurrent();
32835: 
32835:     switch (pname) {
32835:         case LOCAL_GL_TEXTURE_MIN_FILTER:
32835:         case LOCAL_GL_TEXTURE_MAG_FILTER:
32835:         case LOCAL_GL_TEXTURE_WRAP_S:
32835:         case LOCAL_GL_TEXTURE_WRAP_T:
32835:         {
35013:             float fv = 0;
35013:             gl->fGetTexParameterfv(target, pname, (GLfloat*) &fv);
35013:             js.SetRetVal(fv);
32835:         }
32835:             break;
32835: 
32835:         default:
32835:             return NS_ERROR_NOT_IMPLEMENTED;
32835:     }
32835: 
32835:     return NS_OK;
32835: }
32835: 
32195: /* XXX fix */
35013: /* any getUniform(in WebGLProgram program, in WebGLUniformLocation location) raises(DOMException); */
32195: NS_IMETHODIMP
35013: WebGLContext::GetUniform(nsIWebGLProgram *prog, GLint location)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     GLint uArraySize = 0;
32195:     GLenum uType = 0;
32195: 
32195:     gl->fGetActiveUniform(program, location, 0, NULL, &uArraySize, &uType, NULL);
32195:     if (uArraySize == 0)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     // glGetUniform needs to be called for each element of an array separately, so we don't
32195:     // have to deal with uArraySize at all.
32195: 
32195:     GLenum baseType;
32195:     GLint unitSize;
32195:     if (!BaseTypeAndSizeFromUniformType(uType, &baseType, &unitSize))
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     // this should never happen
32195:     if (unitSize > 16)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (baseType == LOCAL_GL_FLOAT) {
32195:         GLfloat fv[16];
32195:         gl->fGetUniformfv(program, location, fv);
32195:         js.SetRetVal(fv, unitSize);
32195:     } else if (baseType == LOCAL_GL_INT) {
32195:         GLint iv[16];
32195:         gl->fGetUniformiv(program, location, iv);
32195:         js.SetRetVal((PRInt32*)iv, unitSize);
32195:     } else {
32195:         js.SetRetValAsJSVal(JSVAL_NULL);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetUniformLocation(nsIWebGLProgram *prog, const nsAString& name, GLint *retval)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     MakeContextCurrent();
32195:     *retval = gl->fGetUniformLocation(program, NS_LossyConvertUTF16toASCII(name).get());
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
35013: WebGLContext::GetVertexAttrib(GLuint index, GLenum pname)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     switch (pname) {
32195:         // int
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_SIZE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_STRIDE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_TYPE:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_ENABLED:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
32195:         {
32195:             PRInt32 iv = 0;
32195:             gl->fGetVertexAttribiv(index, pname, (GLint*) &iv);
32195:             js.SetRetVal(iv);
32195:         }
32195:             break;
32195: 
32195:         case LOCAL_GL_CURRENT_VERTEX_ATTRIB:
32195:         {
32195:             GLfloat fv[4] = { 0 };
32195:             gl->fGetVertexAttribfv(index, LOCAL_GL_CURRENT_VERTEX_ATTRIB, &fv[0]);
32195:             js.SetRetVal(fv, 4);
32195:         }
32195:             break;
32195: 
32195:         // not supported; doesn't make sense to return a pointer unless we have some kind of buffer object abstraction
32195:         case LOCAL_GL_VERTEX_ATTRIB_ARRAY_POINTER:
32195:         default:
32195:             return NS_ERROR_NOT_IMPLEMENTED;
32195: 
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32835: /* GLuint getVertexAttribOffset (in GLuint index, in GLenum pname); */
32835: NS_IMETHODIMP
32835: WebGLContext::GetVertexAttribOffset(GLuint index, GLenum pname, GLuint *retval)
32835: {
32835:     return NS_ERROR_NOT_IMPLEMENTED;
32835: }
32835: 
32835: NS_IMETHODIMP
32195: WebGLContext::Hint(GLenum target, GLenum mode)
32195: {
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsBuffer(nsIWebGLBuffer *iobj, GLboolean *retval)
32195: {
32195:     if (!iobj)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     *retval = ! static_cast<WebGLBuffer*>(iobj)->Deleted();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsFramebuffer(nsIWebGLFramebuffer *iobj, GLboolean *retval)
32195: {
32195:     if (!iobj)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     *retval = ! static_cast<WebGLFramebuffer*>(iobj)->Deleted();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsProgram(nsIWebGLProgram *iobj, GLboolean *retval)
32195: {
32195:     if (!iobj)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     *retval = ! static_cast<WebGLProgram*>(iobj)->Deleted();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsRenderbuffer(nsIWebGLRenderbuffer *iobj, GLboolean *retval)
32195: {
32195:     if (!iobj)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     *retval = ! static_cast<WebGLRenderbuffer*>(iobj)->Deleted();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsShader(nsIWebGLShader *iobj, GLboolean *retval)
32195: {
32195:     if (!iobj)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     *retval = ! static_cast<WebGLShader*>(iobj)->Deleted();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsTexture(nsIWebGLTexture *iobj, GLboolean *retval)
32195: {
32195:     if (!iobj)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     *retval = ! static_cast<WebGLTexture*>(iobj)->Deleted();
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::IsEnabled(GLenum k, GLboolean *retval)
32195: {
32195:     MakeContextCurrent();
32195:     *retval = gl->fIsEnabled(k);
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: GL_SAME_METHOD_1(LineWidth, LineWidth, float)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::LinkProgram(nsIWebGLProgram *prog)
32195: {
32195:     if (!prog || static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("%s: program is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fLinkProgram(program);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: // XXX #if 0
32195: NS_IMETHODIMP
32195: WebGLContext::PixelStorei(GLenum pname, GLint param)
32195: {
32195:     if (pname != LOCAL_GL_PACK_ALIGNMENT &&
32195:         pname != LOCAL_GL_UNPACK_ALIGNMENT)
32195:         return NS_ERROR_INVALID_ARG;
32195: 
32195:     MakeContextCurrent();
32195:     gl->fPixelStorei(pname, param);
32195: 
32195:     return NS_OK;
32195: }
32195: //#endif
32195: 
32195: GL_SAME_METHOD_2(PolygonOffset, PolygonOffset, float, float)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type)
32195: {
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     if (mCanvasElement->IsWriteOnly() && !nsContentUtils::IsCallerTrustedForRead()) {
32195:         LogMessage("readPixels: Not allowed");
32195:         return NS_ERROR_DOM_SECURITY_ERR;
32195:     }
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     if (!CanvasUtils::CheckSaneSubrectSize(x,y,width,height, mWidth, mHeight))
32195:         return ErrorMessage("readPixels: rectangle outside canvas");
32195: 
32195:     PRUint32 size = 0;
32195:     switch (format) {
32195:       case LOCAL_GL_ALPHA:
32195:         size = 1;
32195:         break;
32195:       case LOCAL_GL_RGB:
32195:         size = 3;
32195:         break;
32195:       case LOCAL_GL_RGBA:
32195:         size = 4;
32195:         break;
32195:       default:
32195:         return ErrorMessage("readPixels: unsupported pixel format");
32195:     }
32195:     switch (type) {
32195: //         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
32195: //         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
32195: //         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
32195:       case LOCAL_GL_UNSIGNED_BYTE:
32195:         break;
32195:       default:
32195:         return ErrorMessage("readPixels: unsupported pixel type");
32195:     }
32195: 
32195:     PRUint32 len = width*height*size;
32195: 
32195:     nsAutoArrayPtr<PRUint8> data(new PRUint8[len]);
32195:     gl->fReadPixels((GLint)x, (GLint)y, width, height, format, type, (GLvoid *)data.get());
32195: 
32195:     nsAutoArrayPtr<jsval> jsvector(new jsval[len]);
32195:     for (PRUint32 i = 0; i < len; i++)
32195:         jsvector[i] = INT_TO_JSVAL(data[i]);
32195: 
32195:     JSObject *dataArray = JS_NewArrayObject(js.ctx, len, jsvector);
32195:     if (!dataArray)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("width", width);
32195:     retobj.DefineProperty("height", height);
32195:     retobj.DefineProperty("data", dataArray);
32195: 
32195:     js.SetRetVal(retobj);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_4(RenderbufferStorage, RenderbufferStorage, GLenum, GLenum, GLsizei, GLsizei)
32195: 
32195: GL_SAME_METHOD_2(SampleCoverage, SampleCoverage, float, GLboolean)
32195: 
32195: GL_SAME_METHOD_4(Scissor, Scissor, GLint, GLint, GLsizei, GLsizei)
32195: 
32195: GL_SAME_METHOD_3(StencilFunc, StencilFunc, GLenum, GLint, GLuint)
32195: 
32195: GL_SAME_METHOD_4(StencilFuncSeparate, StencilFuncSeparate, GLenum, GLenum, GLint, GLuint)
32195: 
32195: GL_SAME_METHOD_1(StencilMask, StencilMask, GLuint)
32195: 
32195: GL_SAME_METHOD_2(StencilMaskSeparate, StencilMaskSeparate, GLenum, GLuint)
32195: 
32195: GL_SAME_METHOD_3(StencilOp, StencilOp, GLenum, GLenum, GLenum)
32195: 
32195: GL_SAME_METHOD_4(StencilOpSeparate, StencilOpSeparate, GLenum, GLenum, GLenum, GLenum)
32195: 
32195: 
32195: nsresult
37417: WebGLContext::DOMElementToImageSurface(nsIDOMElement *imageOrCanvas,
34454:                                        gfxImageSurface **imageOut,
35422:                                        PRBool flipY, PRBool premultiplyAlpha)
32195: {
32195:     gfxImageSurface *surf = nsnull;
32195: 
32195:     nsLayoutUtils::SurfaceFromElementResult res =
32195:         nsLayoutUtils::SurfaceFromElement(imageOrCanvas,
32195:                                           nsLayoutUtils::SFE_WANT_NEW_SURFACE | nsLayoutUtils::SFE_WANT_IMAGE_SURFACE);
32195:     if (!res.mSurface)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     CanvasUtils::DoDrawImageSecurityCheck(mCanvasElement, res.mPrincipal, res.mIsWriteOnly);
32195: 
32195:     if (res.mSurface->GetType() != gfxASurface::SurfaceTypeImage) {
32195:         // SurfaceFromElement lied!
32195:         return NS_ERROR_FAILURE;
32195:     }
32195: 
32195:     surf = static_cast<gfxImageSurface*>(res.mSurface.get());
32195: 
32195:     PRInt32 width, height;
32195:     width = res.mSize.width;
32195:     height = res.mSize.height;
32195: 
32195:     if (width <= 0 || height <= 0)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (surf->Format() == gfxASurface::ImageFormatARGB32) {
32195:         PRUint8* src = surf->Data();
32195:         PRUint8* dst = surf->Data();
32195: 
32195:         // this wants some SSE love
32195: 
32195:         for (int j = 0; j < height; j++) {
32195:             src = surf->Data() + j * surf->Stride();
32195:             // note that dst's stride is always tightly packed
32195:             for (int i = 0; i < width; i++) {
32195: #ifdef IS_LITTLE_ENDIAN
32195:                 PRUint8 b = *src++;
32195:                 PRUint8 g = *src++;
32195:                 PRUint8 r = *src++;
32195:                 PRUint8 a = *src++;
32195: #else
32195:                 PRUint8 a = *src++;
32195:                 PRUint8 r = *src++;
32195:                 PRUint8 g = *src++;
32195:                 PRUint8 b = *src++;
32195: #endif
32195:                 // Convert to non-premultiplied color
32195:                 if (a != 0) {
32195:                     r = (r * 255) / a;
32195:                     g = (g * 255) / a;
32195:                     b = (b * 255) / a;
32195:                 }
32195: 
32195:                 *dst++ = r;
32195:                 *dst++ = g;
32195:                 *dst++ = b;
32195:                 *dst++ = a;
32195:             }
32195:         }
32195:     } else if (surf->Format() == gfxASurface::ImageFormatRGB24) {
32195:         PRUint8* src = surf->Data();
32195:         PRUint8* dst = surf->Data();
32195: 
32195:         // this wants some SSE love
32195: 
32195:         for (int j = 0; j < height; j++) {
32195:             src = surf->Data() + j * surf->Stride();
32195:             // note that dst's stride is always tightly packed
32195:             for (int i = 0; i < width; i++) {
32195: #ifdef IS_LITTLE_ENDIAN
32195:                 PRUint8 b = *src++;
32195:                 PRUint8 g = *src++;
32195:                 PRUint8 r = *src++;
32195:                 src++;
32195: #else
32195:                 src++;
32195:                 PRUint8 r = *src++;
32195:                 PRUint8 g = *src++;
32195:                 PRUint8 b = *src++;
32195: #endif
32195: 
32195:                 *dst++ = r;
32195:                 *dst++ = g;
32195:                 *dst++ = b;
32195:                 *dst++ = 255;
32195:             }
32195:         }
32195:     } else {
32195:         return NS_ERROR_FAILURE;
32195:     }
32195: 
34454:     if (flipY) {
34454:         nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(res.mSize,
34454:                                                                 gfxASurface::ImageFormatARGB32);
34454:         if (!tmpsurf || tmpsurf->CairoStatus())
34454:             return NS_ERROR_FAILURE;
34454: 
34454:         nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
34454: 
34454:         if (!tmpctx || tmpctx->HasError())
34454:             return NS_ERROR_FAILURE;
34454: 
34454:         tmpctx->Translate(gfxPoint(0, res.mSize.height));
34454:         tmpctx->Scale(1.0, -1.0);
34454: 
34454:         tmpctx->NewPath();
34454:         tmpctx->Rectangle(gfxRect(0, 0, res.mSize.width, res.mSize.height));
34454: 
34454:         tmpctx->SetSource(res.mSurface);
34454:         tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
34454:         tmpctx->Fill();
34454: 
34454:         NS_ADDREF(surf = tmpsurf);
34454:         tmpctx = nsnull;
34454:     }
34454: 
32195:     res.mSurface.forget();
32195:     *imageOut = surf;
32195: 
32195:     return NS_OK;
32195: }
32195: 
37417: #define GL_SIMPLE_ARRAY_METHOD(name, cnt, arrayType, ptrType)           \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name##_array(GLint idx, js::TypedArray *wa)               \
37417: {                                                                       \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
37417:         return ErrorMessage("array must be " #arrayType);               \
37417:     if (wa->length == 0 || wa->length % cnt != 0)                       \
37417:         return ErrorMessage("array must be > 0 elements and have a length multiple of %d", cnt); \
37417:     MakeContextCurrent();                                               \
37417:     gl->f##name(idx, wa->length / cnt, (ptrType *)wa->data);            \
37417:     return NS_OK;                                                       \
37417: }
37417: 
37417: #define GL_SIMPLE_ARRAY_METHOD_NO_COUNT(name, cnt, arrayType, ptrType)  \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name##_array(GLuint idx, js::TypedArray *wa)              \
37417: {                                                                       \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
37417:         return ErrorMessage("array must be " #arrayType);               \
37417:     if (wa->length < cnt)                                               \
37417:         return ErrorMessage("array must be >= %d elements", cnt);       \
37417:     MakeContextCurrent();                                               \
37417:     gl->f##name(idx, (ptrType *)wa->data);                              \
37417:     return NS_OK;                                                       \
37417: }
37417: 
37417: #define GL_SIMPLE_MATRIX_METHOD(name, dim, arrayType, ptrType)          \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name(PRInt32 dummy) {                                     \
37417:      return NS_ERROR_NOT_IMPLEMENTED;                                   \
37417: }                                                                       \
37417: NS_IMETHODIMP                                                           \
37417: WebGLContext::name##_array(GLint idx, GLboolean transpose, js::TypedArray *wa)  \
37417: {                                                                       \
37417:     if (!wa || wa->type != js::TypedArray::arrayType)                   \
37417:         return ErrorMessage("array must be " #arrayType);               \
37417:     if (wa->length == 0 || wa->length % (dim*dim) != 0)                 \
37417:         return ErrorMessage("array must be > 0 elements and have a length multiple of %d", dim*dim); \
37417:     MakeContextCurrent();                                               \
37417:     gl->f##name(idx, wa->length / (dim*dim), transpose, (ptrType *)wa->data); \
37417:     return NS_OK;                                                       \
37417: }
37417: 
32195: GL_SAME_METHOD_2(Uniform1i, Uniform1i, GLint, GLint)
32195: GL_SAME_METHOD_3(Uniform2i, Uniform2i, GLint, GLint, GLint)
32195: GL_SAME_METHOD_4(Uniform3i, Uniform3i, GLint, GLint, GLint, GLint)
32195: GL_SAME_METHOD_5(Uniform4i, Uniform4i, GLint, GLint, GLint, GLint, GLint)
32195: 
32195: GL_SAME_METHOD_2(Uniform1f, Uniform1f, GLint, GLfloat)
32195: GL_SAME_METHOD_3(Uniform2f, Uniform2f, GLint, GLfloat, GLfloat)
32195: GL_SAME_METHOD_4(Uniform3f, Uniform3f, GLint, GLfloat, GLfloat, GLfloat)
32195: GL_SAME_METHOD_5(Uniform4f, Uniform4f, GLint, GLfloat, GLfloat, GLfloat, GLfloat)
32195: 
37417: GL_SIMPLE_ARRAY_METHOD(Uniform1iv, 1, TYPE_INT32, GLint)
37417: GL_SIMPLE_ARRAY_METHOD(Uniform2iv, 2, TYPE_INT32, GLint)
37417: GL_SIMPLE_ARRAY_METHOD(Uniform3iv, 3, TYPE_INT32, GLint)
37417: GL_SIMPLE_ARRAY_METHOD(Uniform4iv, 4, TYPE_INT32, GLint)
37417: 
37417: GL_SIMPLE_ARRAY_METHOD(Uniform1fv, 1, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_ARRAY_METHOD(Uniform2fv, 2, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_ARRAY_METHOD(Uniform3fv, 3, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_ARRAY_METHOD(Uniform4fv, 4, TYPE_FLOAT32, GLfloat)
37417: 
37417: GL_SIMPLE_MATRIX_METHOD(UniformMatrix2fv, 2, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_MATRIX_METHOD(UniformMatrix3fv, 3, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_MATRIX_METHOD(UniformMatrix4fv, 4, TYPE_FLOAT32, GLfloat)
37417: 
37417: GL_SAME_METHOD_2(VertexAttrib1f, VertexAttrib1f, PRUint32, GLfloat)
37417: GL_SAME_METHOD_3(VertexAttrib2f, VertexAttrib2f, PRUint32, GLfloat, GLfloat)
37417: GL_SAME_METHOD_4(VertexAttrib3f, VertexAttrib3f, PRUint32, GLfloat, GLfloat, GLfloat)
37417: GL_SAME_METHOD_5(VertexAttrib4f, VertexAttrib4f, PRUint32, GLfloat, GLfloat, GLfloat, GLfloat)
37417: 
37417: GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib1fv, 1, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib2fv, 2, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib3fv, 3, TYPE_FLOAT32, GLfloat)
37417: GL_SIMPLE_ARRAY_METHOD_NO_COUNT(VertexAttrib4fv, 4, TYPE_FLOAT32, GLfloat)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::UseProgram(nsIWebGLProgram *prog)
32195: {
32195:     if (prog && static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("glUseProgram: program has already been deleted!");
32195: 
32195:     GLuint program = prog ? static_cast<WebGLProgram*>(prog)->GLName() : 0;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fUseProgram(program);
32195: 
32195:     mCurrentProgram = static_cast<WebGLProgram*>(prog);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::ValidateProgram(nsIWebGLProgram *prog)
32195: {
32195:     if (!prog && static_cast<WebGLProgram*>(prog)->Deleted())
32195:         return ErrorMessage("glValidateProgram: program is null or has already been deleted!");
32195: 
32195:     GLuint program = static_cast<WebGLProgram*>(prog)->GLName();
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fValidateProgram(program);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateFramebuffer(nsIWebGLFramebuffer **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenFramebuffers(1, &name);
32195: 
32195:     WebGLFramebuffer *globj = new WebGLFramebuffer(name);
32195:     if (globj) {
32195:         NS_ADDREF(*retval = globj);
32195:         mMapFramebuffers.Put(name, globj);
32195:     } else {
32195:         gl->fDeleteFramebuffers(1, &name);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32835: WebGLContext::CreateRenderbuffer(nsIWebGLRenderbuffer **retval)
32195: {
32195:     MakeContextCurrent();
32195: 
32195:     GLuint name;
32195:     gl->fGenRenderbuffers(1, &name);
32195: 
32195:     WebGLRenderbuffer *globj = new WebGLRenderbuffer(name);
32195:     if (globj) {
32195:         NS_ADDREF(*retval = globj);
32195:         mMapRenderbuffers.Put(name, globj);
32195:     } else {
32195:         gl->fDeleteRenderbuffers(1, &name);
32195:     }
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: GL_SAME_METHOD_4(Viewport, Viewport, PRInt32, PRInt32, PRInt32, PRInt32)
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::CompileShader(nsIWebGLShader *shobj)
32195: {
32195:     if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
32195:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
32195:     
32195:     MakeContextCurrent();
32195: 
32195:     gl->fCompileShader(shader);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: 
32195: NS_IMETHODIMP
35013: WebGLContext::GetShaderParameter(nsIWebGLShader *shobj, GLenum pname)
32835: {
35013:     if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
35013:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
35013: 
35013:     GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
35013:     
35013:     NativeJSContext js;
35013:     if (NS_FAILED(js.error))
35013:         return js.error;
35013: 
35013:     MakeContextCurrent();
35013: 
35013:     switch (pname) {
35013:         case LOCAL_GL_SHADER_TYPE:
35013:         case LOCAL_GL_DELETE_STATUS:
35013:         case LOCAL_GL_COMPILE_STATUS:
35013:         case LOCAL_GL_INFO_LOG_LENGTH:
35013:         case LOCAL_GL_SHADER_SOURCE_LENGTH:
35013:         {
35013:             PRInt32 iv = 0;
35013:             gl->fGetShaderiv(shader, pname, (GLint*) &iv);
35013:             js.SetRetVal(iv);
35013:         }
35013:             break;
35013: 
35013:         default:
32835:             return NS_ERROR_NOT_IMPLEMENTED;
32835:     }
32835: 
35013:     return NS_OK;
35013: }
35013: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetShaderInfoLog(nsIWebGLShader *shobj, nsAString& retval)
32195: {
32195:     if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
32195:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();    
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     PRInt32 k = -1;
32195:     gl->fGetShaderiv(shader, LOCAL_GL_INFO_LOG_LENGTH, (GLint*) &k);
32195:     if (k == -1)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (k == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString log;
32195:     log.SetCapacity(k);
32195: 
32195:     gl->fGetShaderInfoLog(shader, k, (GLint*) &k, (char*) log.BeginWriting());
32195: 
32195:     log.SetLength(k);
32195: 
32195:     CopyASCIItoUTF16(log, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetShaderSource(nsIWebGLShader *shobj, nsAString& retval)
32195: {
32195:     if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
32195:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
32195:     
32195:     MakeContextCurrent();
32195: 
32195:     GLint slen = -1;
32195:     gl->fGetShaderiv (shader, LOCAL_GL_SHADER_SOURCE_LENGTH, &slen);
32195:     if (slen == -1)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (slen == 0) {
32195:         retval.Truncate();
32195:         return NS_OK;
32195:     }
32195: 
32195:     nsCAutoString src;
32195:     src.SetCapacity(slen);
32195: 
32195:     gl->fGetShaderSource (shader, slen, NULL, (char*) src.BeginWriting());
32195: 
32195:     src.SetLength(slen);
32195: 
32195:     CopyASCIItoUTF16(src, retval);
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::ShaderSource(nsIWebGLShader *shobj, const nsAString& source)
32195: {
32195:     if (!shobj || static_cast<WebGLShader*>(shobj)->Deleted())
32195:         return ErrorMessage("%s: shader is null or deleted!", __FUNCTION__);
32195: 
32195:     GLuint shader = static_cast<WebGLShader*>(shobj)->GLName();
32195:     
32195:     MakeContextCurrent();
32195: 
32195:     NS_LossyConvertUTF16toASCII asciisrc(source);
32195:     const char *p = asciisrc.get();
32195: 
32195:     gl->fShaderSource(shader, 1, &p, NULL);
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::VertexAttribPointer(GLuint index, GLint size, GLenum type,
32195:                                   GLboolean normalized, GLuint stride,
32195:                                   GLuint offset)
32195: {
32195:     if (mBoundArrayBuffer == nsnull)
32195:         return ErrorMessage("glvertexattribpointer: must have GL_ARRAY_BUFFER binding!");
32195: 
32195:     if (index >= mAttribBuffers.Length())
32195:         return ErrorMessage("glVertexAttribPointer: index out of range - %d >= %d", index, mAttribBuffers.Length());
32195: 
32195:     if (size < 1 || size > 4)
32195:         return ErrorMessage("glVertexAttribPointer: invalid element size");
32195: 
34453:     /* XXX make work with bufferSubData & heterogeneous types 
32195:     if (type != mBoundArrayBuffer->GLType())
32195:         return ErrorMessage("glVertexAttribPointer: type must match bound VBO type: %d != %d", type, mBoundArrayBuffer->GLType());
34453:     */
32195: 
32195:     // XXX 0 stride?
32195:     //if (stride < (GLuint) size)
32195:     //    return ErrorMessage("glVertexAttribPointer: stride must be >= size!");
32195: 
32195:     WebGLVertexAttribData &vd = mAttribBuffers[index];
32195: 
32195:     vd.buf = mBoundArrayBuffer;
32195:     vd.stride = stride;
32195:     vd.size = size;
32195:     vd.offset = offset;
32195: 
32195:     MakeContextCurrent();
32195: 
32195:     gl->fVertexAttribPointer(index, size, type, normalized,
34453:                              stride,
34453:                              (void*) (offset));
32195: 
32195:     return NS_OK;
32195: }
32195: 
32195: PRBool
32195: WebGLContext::ValidateGL()
32195: {
32195:     // make sure that the opengl stuff that we need is supported
32195:     GLint val = 0;
32195: 
35492:     // XXX this exposes some strange latent bug; what's going on?
35492:     //MakeContextCurrent();
35488: 
32195:     gl->fGetIntegerv(LOCAL_GL_MAX_VERTEX_ATTRIBS, &val);
35492:     if (val == 0) {
35492:         LogMessage("GL_MAX_VERTEX_ATTRIBS is 0!");
35492:         return PR_FALSE;
35492:     }
35492: 
32195:     mAttribBuffers.SetLength(val);
32195: 
35488:     //fprintf(stderr, "GL_MAX_VERTEX_ATTRIBS: %d\n", val);
35488: 
37827:     // Note: GL_MAX_TEXTURE_UNITS is fixed at 4 for most desktop hardware,
37827:     // even though the hardware supports much more.  The
37827:     // GL_MAX_{COMBINED_}TEXTURE_IMAGE_UNITS value is the accurate
38926:     // value.  For GLES2, GL_MAX_TEXTURE_UNITS is still correct.
37827:     gl->fGetIntegerv(LOCAL_GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &val);
35492:     if (val == 0) {
37827:         LogMessage("GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS is 0!");
35492:         return PR_FALSE;
35492:     }
35492: 
32195:     mBound2DTextures.SetLength(val);
32195:     mBoundCubeMapTextures.SetLength(val);
32195: 
35488:     //fprintf(stderr, "GL_MAX_TEXTURE_UNITS: %d\n", val);
35488: 
32195:     gl->fGetIntegerv(LOCAL_GL_MAX_COLOR_ATTACHMENTS, &val);
35494:     mFramebufferColorAttachments.SetLength(val);
32195: 
35488: #ifdef DEBUG_vladimir
35488:     gl->fGetIntegerv(LOCAL_GL_IMPLEMENTATION_COLOR_READ_FORMAT, &val);
35488:     fprintf(stderr, "GL_IMPLEMENTATION_COLOR_READ_FORMAT: 0x%04x\n", val);
35488: 
35488:     gl->fGetIntegerv(LOCAL_GL_IMPLEMENTATION_COLOR_READ_TYPE, &val);
35488:     fprintf(stderr, "GL_IMPLEMENTATION_COLOR_READ_TYPE: 0x%04x\n", val);
35488: #endif
35488: 
32195: #ifndef USE_GLES2
32195:     // gl_PointSize is always available in ES2 GLSL
32195:     gl->fEnable(LOCAL_GL_VERTEX_PROGRAM_POINT_SIZE);
32195: #endif
32195: 
32195:     return PR_TRUE;
32195: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::TexImage2D(PRInt32 dummy)
32195: {
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
37417: nsresult
37417: WebGLContext::TexImage2D_base(GLenum target, GLint level, GLenum internalformat,
37417:                               GLsizei width, GLsizei height, GLint border,
37417:                               GLenum format, GLenum type,
37417:                               void *data, PRUint32 byteLength)
34454: {
37417:     switch (target) {
37417:         case LOCAL_GL_TEXTURE_2D:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
37417:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
37417:             break;
37417:         default:
37417:             return ErrorMessage("texImage2D: unsupported target");
34454:     }
37417: 
37417:     if (level < 0)
37417:         return ErrorMessage("texImage2D: level must be >= 0");
37417: 
37417:     switch (internalformat) {
37417:         case LOCAL_GL_RGB:
37417:         case LOCAL_GL_RGBA:
37417:         case LOCAL_GL_ALPHA:
37417:         case LOCAL_GL_LUMINANCE:
37417:         case LOCAL_GL_LUMINANCE_ALPHA:
37417:             break;
37417:         default:
37417:             return ErrorMessage("texImage2D: internal format not supported");
37417:     }
37417: 
37417:     if (width <= 0 || height <= 0)
37417:         return ErrorMessage("texImage2D: width and height must be > 0!");
37417: 
37417:     if (border != 0)
37417:         return ErrorMessage("texImage2D: border must be 0");
37417: 
37417:     // number of bytes per pixel
37417:     uint32 bufferPixelSize = 0;
37417:     switch (format) {
37417:         case LOCAL_GL_RED:
37417:         case LOCAL_GL_GREEN:
37417:         case LOCAL_GL_BLUE:
37417:         case LOCAL_GL_ALPHA:
37417:         case LOCAL_GL_LUMINANCE:
37417:             bufferPixelSize = 1;
37417:             break;
37417:         case LOCAL_GL_LUMINANCE_ALPHA:
37417:             bufferPixelSize = 2;
37417:             break;
37417:         case LOCAL_GL_RGB:
37417:             bufferPixelSize = 3;
37417:             break;
37417:         case LOCAL_GL_RGBA:
37417:             bufferPixelSize = 4;
37417:             break;
37417:         default:
37417:             return ErrorMessage("texImage2D: pixel format not supported");
37417:     }
37417: 
37417:     switch (type) {
37417:         case LOCAL_GL_BYTE:
37417:         case LOCAL_GL_UNSIGNED_BYTE:
37417:             break;
37417:         case LOCAL_GL_SHORT:
37417:         case LOCAL_GL_UNSIGNED_SHORT:
37417:             bufferPixelSize *= 2;
37417:             break;
37417:         case LOCAL_GL_INT:
37417:         case LOCAL_GL_UNSIGNED_INT:
37417:         case LOCAL_GL_FLOAT:
37417:             bufferPixelSize *= 4;
37417:             break;
37417:         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
37417:         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
37417:         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
37417:             bufferPixelSize *= 2;
37417:             break;
37417:         default:
37417:             return ErrorMessage("texImage2D: invalid type argument");
37417:     }
37417: 
37417:     // XXX overflow!
37417:     uint32 bytesNeeded = width * height * bufferPixelSize;
37417: 
37417:     if (byteLength && byteLength < bytesNeeded)
37417:         return ErrorMessage("texImage2D: not enough data for operation (need %d, have %d)", bytesNeeded, byteLength);
37417: 
37417:     MakeContextCurrent();
37417: 
37417:     if (byteLength) {
37417:         gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, data);
37417:     } else {
37417:         gl->fTexImage2D(target, level, internalformat, width, height, border, format, type, NULL);
37417:     }
37417: 
37417:     return NS_OK;
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::TexImage2D_buf(GLenum target, GLint level, GLenum internalformat,
37417:                              GLsizei width, GLsizei height, GLint border,
37417:                              GLenum format, GLenum type,
37417:                              js::ArrayBuffer *pixels)
37417: {
37417:     return TexImage2D_base(target, level, internalformat, width, height, border, format, type,
37417:                            pixels ? pixels->data : 0,
37417:                            pixels ? pixels->byteLength : 0);
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::TexImage2D_array(GLenum target, GLint level, GLenum internalformat,
37417:                                GLsizei width, GLsizei height, GLint border,
37417:                                GLenum format, GLenum type,
37417:                                js::TypedArray *pixels)
37417: {
37417:     return TexImage2D_base(target, level, internalformat, width, height, border, format, type,
37417:                            pixels ? pixels->data : 0,
37417:                            pixels ? pixels->byteLength : 0);
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::TexImage2D_dom(GLenum target, GLint level,
37417:                              nsIDOMElement *elt,
37417:                              GLboolean flipY, GLboolean premultiplyAlpha)
37417: {
34454:     nsRefPtr<gfxImageSurface> isurf;
34454: 
37417:     nsresult rv = DOMElementToImageSurface(elt, getter_AddRefs(isurf),
37417:                                            flipY, premultiplyAlpha);
34454:     if (NS_FAILED(rv))
37417:         return rv;
37417: 
37417:     return TexImage2D_base(target, level, LOCAL_GL_RGBA,
37417:                            isurf->Width(), isurf->Height(), 0,
37417:                            LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE,
37417:                            isurf->Data(), isurf->Stride() * isurf->Height());
37417: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::TexSubImage2D(PRInt32 dummy)
32195: {
37417:     return NS_ERROR_FAILURE;
32195: }
32195: 
37417: nsresult
37417: WebGLContext::TexSubImage2D_base(GLenum target, GLint level,
37417:                                  GLint xoffset, GLint yoffset,
37417:                                  GLsizei width, GLsizei height,
37417:                                  GLenum format, GLenum type,
37417:                                  void *pixels, PRUint32 byteLength)
37417: {
37417:     switch (target) {
32195:         case LOCAL_GL_TEXTURE_2D:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
32195:         case LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
32195:             break;
32195:         default:
32195:             return ErrorMessage("texSubImage2D: unsupported target");
32195:     }
32195: 
37417:     if (level < 0)
37417:         return ErrorMessage("texSubImage2D: level must be >= 0");
37417: 
37417:     if (width <= 0 || height <= 0)
37417:         return ErrorMessage("texSubImage2D: width and height must be > 0!");
37417: 
37417:     // number of bytes per pixel
37417:     uint32 bufferPixelSize = 0;
37417:     switch (format) {
32195:         case LOCAL_GL_RED:
32195:         case LOCAL_GL_GREEN:
32195:         case LOCAL_GL_BLUE:
32195:         case LOCAL_GL_ALPHA:
32195:         case LOCAL_GL_LUMINANCE:
37417:             bufferPixelSize = 1;
32195:             break;
32195:         case LOCAL_GL_LUMINANCE_ALPHA:
37417:             bufferPixelSize = 2;
32195:             break;
32195:         case LOCAL_GL_RGB:
37417:             bufferPixelSize = 3;
32195:             break;
32195:         case LOCAL_GL_RGBA:
37417:             bufferPixelSize = 4;
32195:             break;
32195:         default:
37417:             return ErrorMessage("texImage2D: pixel format not supported");
32195:     }
32195: 
37417:     switch (type) {
37417:         case LOCAL_GL_BYTE:
37417:         case LOCAL_GL_UNSIGNED_BYTE:
37417:             break;
32195:         case LOCAL_GL_SHORT:
32195:         case LOCAL_GL_UNSIGNED_SHORT:
37417:             bufferPixelSize *= 2;
37417:             break;
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_UNSIGNED_INT:
32195:         case LOCAL_GL_FLOAT:
37417:             bufferPixelSize *= 4;
32195:             break;
32195:         case LOCAL_GL_UNSIGNED_SHORT_4_4_4_4:
32195:         case LOCAL_GL_UNSIGNED_SHORT_5_5_5_1:
32195:         case LOCAL_GL_UNSIGNED_SHORT_5_6_5:
37417:             bufferPixelSize *= 2;
32195:             break;
32195:         default:
37417:             return ErrorMessage("texImage2D: invalid type argument");
32195:     }
32195: 
37417:     // XXX overflow!
37417:     uint32 bytesNeeded = width * height * bufferPixelSize;
37417: 
37417:     if (byteLength < bytesNeeded)
37417:         return ErrorMessage("texSubImage2D: not enough data for operation (need %d, have %d)", bytesNeeded, byteLength);
35422: 
32195:     MakeContextCurrent();
37417: 
37417:     gl->fTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
37417: 
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
37417: WebGLContext::TexSubImage2D_buf(GLenum target, GLint level,
37417:                                 GLint xoffset, GLint yoffset,
37417:                                 GLsizei width, GLsizei height,
37417:                                 GLenum format, GLenum type,
37417:                                 js::ArrayBuffer *pixels)
32195: {
37417:     if (!pixels)
37417:         return ErrorMessage("texSubImage2D: pixels must not be null!");
37417: 
37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
37417:                               width, height, format, type,
37417:                               pixels->data, pixels->byteLength);
32195: }
32195: 
37417: NS_IMETHODIMP
37417: WebGLContext::TexSubImage2D_array(GLenum target, GLint level,
37417:                                   GLint xoffset, GLint yoffset,
37417:                                   GLsizei width, GLsizei height,
37417:                                   GLenum format, GLenum type,
37417:                                   js::TypedArray *pixels)
32195: {
37417:     if (!pixels)
37417:         return ErrorMessage("texSubImage2D: pixels must not be null!");
37417: 
37417:     return TexSubImage2D_base(target, level, xoffset, yoffset,
37417:                               width, height, format, type,
37417:                               pixels->data, pixels->byteLength);
32195: }
37417: 
37417: NS_IMETHODIMP
37417: WebGLContext::TexSubImage2D_dom(GLenum target, GLint level,
37417:                                 GLint xoffset, GLint yoffset,
37417:                                 GLsizei width, GLsizei height,
37417:                                 nsIDOMElement *elt,
37417:                                 GLboolean flipY, GLboolean premultiplyAlpha)
37417: {
32195:     nsRefPtr<gfxImageSurface> isurf;
32195: 
37417:     nsresult rv = DOMElementToImageSurface(elt, getter_AddRefs(isurf),
37417:                                            flipY, premultiplyAlpha);
32195:     if (NS_FAILED(rv))
37417:         return rv;
37417: 
37417:     return TexSubImage2D_base(target, level,
37417:                               xoffset, yoffset,
37417:                               width, height,
37417:                               LOCAL_GL_RGBA, LOCAL_GL_UNSIGNED_BYTE,
37417:                               isurf->Data(), isurf->Stride() * isurf->Height());
32195: }
32195: 
32195: #if 0
32195: // ImageData getImageData (in float x, in float y, in float width, in float height);
32195: NS_IMETHODIMP
32195: WebGLContext::GetImageData(PRUint32 x, PRUint32 y, PRUint32 w, PRUint32 h)
32195: {
32195:     // disabled due to win32 linkage issues with thebes symbols and NS_RELEASE
32195:     return NS_ERROR_FAILURE;
32195: 
32195: #if 0
32195:     NativeJSContext js;
32195:     if (NS_FAILED(js.error))
32195:         return js.error;
32195: 
32195:     if (js.argc != 4) return NS_ERROR_INVALID_ARG;
32195:     
32195:     if (!mGLPbuffer ||
32195:         !mGLPbuffer->ThebesSurface())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (!mCanvasElement)
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     if (mCanvasElement->IsWriteOnly() && !IsCallerTrustedForRead()) {
32195:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
32195:         return NS_ERROR_DOM_SECURITY_ERR;
32195:     }
32195: 
32195:     JSContext *ctx = js.ctx;
32195: 
32195:     if (!CanvasUtils::CheckSaneSubrectSize (x, y, w, h, mWidth, mHeight))
32195:         return NS_ERROR_DOM_SYNTAX_ERR;
32195: 
32195:     nsAutoArrayPtr<PRUint8> surfaceData (new (std::nothrow) PRUint8[w * h * 4]);
32195:     int surfaceDataStride = w*4;
32195:     int surfaceDataOffset = 0;
32195: 
32195:     if (!surfaceData)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     nsRefPtr<gfxImageSurface> tmpsurf = new gfxImageSurface(surfaceData,
32195:                                                             gfxIntSize(w, h),
32195:                                                             w * 4,
32195:                                                             gfxASurface::ImageFormatARGB32);
32195:     if (!tmpsurf || tmpsurf->CairoStatus())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
32195: 
32195:     if (!tmpctx || tmpctx->HasError())
32195:         return NS_ERROR_FAILURE;
32195: 
32195:     nsRefPtr<gfxASurface> surf = mGLPbuffer->ThebesSurface();
32195:     nsRefPtr<gfxPattern> pat = CanvasGLThebes::CreatePattern(surf);
32195:     gfxMatrix m;
32195:     m.Translate(gfxPoint(x, mGLPbuffer->Height()-y));
32195:     m.Scale(1.0, -1.0);
32195:     pat->SetMatrix(m);
32195: 
32195:     // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
32195:     // pixel alignment for this stuff!
32195:     tmpctx->NewPath();
32195:     tmpctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, w, h), pat);
32195:     tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
32195:     tmpctx->Fill();
32195: 
32195:     tmpctx = nsnull;
32195:     tmpsurf = nsnull;
32195: 
32195:     PRUint32 len = w * h * 4;
32195:     if (len > (((PRUint32)0xfff00000)/sizeof(jsval)))
32195:         return NS_ERROR_INVALID_ARG;
32195: 
32195:     nsAutoArrayPtr<jsval> jsvector(new (std::nothrow) jsval[w * h * 4]);
32195:     if (!jsvector)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195:     jsval *dest = jsvector.get();
32195:     PRUint8 *row;
32195:     for (PRUint32 j = 0; j < h; j++) {
32195:         row = surfaceData + surfaceDataOffset + (surfaceDataStride * j);
32195:         for (PRUint32 i = 0; i < w; i++) {
32195:             // XXX Is there some useful swizzle MMX we can use here?
32195:             // I guess we have to INT_TO_JSVAL still
32195: #ifdef IS_LITTLE_ENDIAN
32195:             PRUint8 b = *row++;
32195:             PRUint8 g = *row++;
32195:             PRUint8 r = *row++;
32195:             PRUint8 a = *row++;
32195: #else
32195:             PRUint8 a = *row++;
32195:             PRUint8 r = *row++;
32195:             PRUint8 g = *row++;
32195:             PRUint8 b = *row++;
32195: #endif
32195:             // Convert to non-premultiplied color
32195:             if (a != 0) {
32195:                 r = (r * 255) / a;
32195:                 g = (g * 255) / a;
32195:                 b = (b * 255) / a;
32195:             }
32195: 
32195:             *dest++ = INT_TO_JSVAL(r);
32195:             *dest++ = INT_TO_JSVAL(g);
32195:             *dest++ = INT_TO_JSVAL(b);
32195:             *dest++ = INT_TO_JSVAL(a);
32195:         }
32195:     }
32195: 
32195:     JSObject *dataArray = JS_NewArrayObject(ctx, w*h*4, jsvector);
32195:     if (!dataArray)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     JSObjectHelper retobj(&js);
32195:     retobj.DefineProperty("width", w);
32195:     retobj.DefineProperty("height", h);
32195:     retobj.DefineProperty("data", dataArray);
32195: 
32195:     js.SetRetVal(retobj);
32195: 
32195:     return NS_OK;
32195: #endif
32195: }
32195: #endif
32195: 
32195: PRBool
32195: BaseTypeAndSizeFromUniformType(GLenum uType, GLenum *baseType, GLint *unitSize)
32195: {
32195:         switch (uType) {
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_INT_VEC2:
32195:         case LOCAL_GL_INT_VEC3:
32195:         case LOCAL_GL_INT_VEC4:
32195:         case LOCAL_GL_SAMPLER_2D:
32195:         case LOCAL_GL_SAMPLER_CUBE:
32195:             *baseType = LOCAL_GL_INT;
32195:             break;
32195:         case LOCAL_GL_FLOAT:
32195:         case LOCAL_GL_FLOAT_VEC2:
32195:         case LOCAL_GL_FLOAT_VEC3:
32195:         case LOCAL_GL_FLOAT_VEC4:
32195:         case LOCAL_GL_FLOAT_MAT2:
32195:         case LOCAL_GL_FLOAT_MAT3:
32195:         case LOCAL_GL_FLOAT_MAT4:
32195:             *baseType = LOCAL_GL_FLOAT;
32195:             break;
32195:         case LOCAL_GL_BOOL:
32195:         case LOCAL_GL_BOOL_VEC2:
32195:         case LOCAL_GL_BOOL_VEC3:
32195:         case LOCAL_GL_BOOL_VEC4:
32195:             *baseType = LOCAL_GL_INT; // pretend these are int
32195:             break;
32195:         default:
32195:             return PR_FALSE;
32195:     }
32195: 
32195:     switch (uType) {
32195:         case LOCAL_GL_INT:
32195:         case LOCAL_GL_FLOAT:
32195:         case LOCAL_GL_BOOL:
32195:         case LOCAL_GL_SAMPLER_2D:
32195:         case LOCAL_GL_SAMPLER_CUBE:
32195:             *unitSize = 1;
32195:             break;
32195:         case LOCAL_GL_INT_VEC2:
32195:         case LOCAL_GL_FLOAT_VEC2:
32195:         case LOCAL_GL_BOOL_VEC2:
32195:             *unitSize = 2;
32195:             break;
32195:         case LOCAL_GL_INT_VEC3:
32195:         case LOCAL_GL_FLOAT_VEC3:
32195:         case LOCAL_GL_BOOL_VEC3:
32195:             *unitSize = 3;
32195:             break;
32195:         case LOCAL_GL_INT_VEC4:
32195:         case LOCAL_GL_FLOAT_VEC4:
32195:         case LOCAL_GL_BOOL_VEC4:
32195:             *unitSize = 4;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT2:
32195:             *unitSize = 4;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT3:
32195:             *unitSize = 9;
32195:             break;
32195:         case LOCAL_GL_FLOAT_MAT4:
32195:             *unitSize = 16;
32195:             break;
32195:         default:
32195:             return PR_FALSE;
32195:     }
32195: 
32195:     return PR_TRUE;
32195: }
