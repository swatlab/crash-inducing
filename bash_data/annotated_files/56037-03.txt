53414: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53414:  * vim: set ts=8 sw=4 et tw=79:
53414:  *
53414:  * ***** BEGIN LICENSE BLOCK *****
50491:  * Copyright (C) 2009 Apple Inc. All rights reserved.
50491:  * Copyright (C) 2010 University of Szeged
50491:  *
50491:  * Redistribution and use in source and binary forms, with or without
50491:  * modification, are permitted provided that the following conditions
50491:  * are met:
50491:  * 1. Redistributions of source code must retain the above copyright
50491:  *    notice, this list of conditions and the following disclaimer.
50491:  * 2. Redistributions in binary form must reproduce the above copyright
50491:  *    notice, this list of conditions and the following disclaimer in the
50491:  *    documentation and/or other materials provided with the distribution.
50491:  *
50491:  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
50491:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
50491:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
50491:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
50491:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
50491:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
50491:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
50491:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
50491:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
50491:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
50491:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
53414:  * 
53414:  * ***** END LICENSE BLOCK ***** */
50491: 
50491: #ifndef ARMAssembler_h
50491: #define ARMAssembler_h
50491: 
50491: #include "assembler/wtf/Platform.h"
50491: 
50491: #if ENABLE(ASSEMBLER) && CPU(ARM_THUMB2)
50491: 
50491: #include "AssemblerBuffer.h"
50491: #include "assembler/wtf/Assertions.h"
50491: #include "assembler/wtf/Vector.h"
50491: #include <stdint.h>
50491: 
50491: namespace JSC {
50491: 
50491: namespace ARMRegisters {
50491:     typedef enum {
50491:         r0,
50491:         r1,
50491:         r2,
50491:         r3,
50491:         r4,
50491:         r5,
50491:         r6,
50491:         r7, wr = r7,   // thumb work register
50491:         r8,
50491:         r9, sb = r9,   // static base
50491:         r10, sl = r10, // stack limit
50491:         r11, fp = r11, // frame pointer
50491:         r12, ip = r12,
50491:         r13, sp = r13,
50491:         r14, lr = r14,
50491:         r15, pc = r15,
50491:     } RegisterID;
50491: 
50491:     // s0 == d0 == q0
50491:     // s4 == d2 == q1
50491:     // etc
50491:     typedef enum {
50491:         s0 = 0,
50491:         s1 = 1,
50491:         s2 = 2,
50491:         s3 = 3,
50491:         s4 = 4,
50491:         s5 = 5,
50491:         s6 = 6,
50491:         s7 = 7,
50491:         s8 = 8,
50491:         s9 = 9,
50491:         s10 = 10,
50491:         s11 = 11,
50491:         s12 = 12,
50491:         s13 = 13,
50491:         s14 = 14,
50491:         s15 = 15,
50491:         s16 = 16,
50491:         s17 = 17,
50491:         s18 = 18,
50491:         s19 = 19,
50491:         s20 = 20,
50491:         s21 = 21,
50491:         s22 = 22,
50491:         s23 = 23,
50491:         s24 = 24,
50491:         s25 = 25,
50491:         s26 = 26,
50491:         s27 = 27,
50491:         s28 = 28,
50491:         s29 = 29,
50491:         s30 = 30,
50491:         s31 = 31,
50491:         d0 = 0 << 1,
50491:         d1 = 1 << 1,
50491:         d2 = 2 << 1,
50491:         d3 = 3 << 1,
50491:         d4 = 4 << 1,
50491:         d5 = 5 << 1,
50491:         d6 = 6 << 1,
50491:         d7 = 7 << 1,
50491:         d8 = 8 << 1,
50491:         d9 = 9 << 1,
50491:         d10 = 10 << 1,
50491:         d11 = 11 << 1,
50491:         d12 = 12 << 1,
50491:         d13 = 13 << 1,
50491:         d14 = 14 << 1,
50491:         d15 = 15 << 1,
50491:         d16 = 16 << 1,
50491:         d17 = 17 << 1,
50491:         d18 = 18 << 1,
50491:         d19 = 19 << 1,
50491:         d20 = 20 << 1,
50491:         d21 = 21 << 1,
50491:         d22 = 22 << 1,
50491:         d23 = 23 << 1,
50491:         d24 = 24 << 1,
50491:         d25 = 25 << 1,
50491:         d26 = 26 << 1,
50491:         d27 = 27 << 1,
50491:         d28 = 28 << 1,
50491:         d29 = 29 << 1,
50491:         d30 = 30 << 1,
50491:         d31 = 31 << 1,
50491:         q0 = 0 << 2,
50491:         q1 = 1 << 2,
50491:         q2 = 2 << 2,
50491:         q3 = 3 << 2,
50491:         q4 = 4 << 2,
50491:         q5 = 5 << 2,
50491:         q6 = 6 << 2,
50491:         q7 = 7 << 2,
50491:         q8 = 8 << 2,
50491:         q9 = 9 << 2,
50491:         q10 = 10 << 2,
50491:         q11 = 11 << 2,
50491:         q12 = 12 << 2,
50491:         q13 = 13 << 2,
50491:         q14 = 14 << 2,
50491:         q15 = 15 << 2,
50491:         q16 = 16 << 2,
50491:         q17 = 17 << 2,
50491:         q18 = 18 << 2,
50491:         q19 = 19 << 2,
50491:         q20 = 20 << 2,
50491:         q21 = 21 << 2,
50491:         q22 = 22 << 2,
50491:         q23 = 23 << 2,
50491:         q24 = 24 << 2,
50491:         q25 = 25 << 2,
50491:         q26 = 26 << 2,
50491:         q27 = 27 << 2,
50491:         q28 = 28 << 2,
50491:         q29 = 29 << 2,
50491:         q30 = 30 << 2,
50491:         q31 = 31 << 2,
50491:     } FPRegisterID;
50491: }
50491: 
50491: class ARMv7Assembler;
50491: class ARMThumbImmediate {
50491:     friend class ARMv7Assembler;
50491: 
50491:     typedef uint8_t ThumbImmediateType;
50491:     static const ThumbImmediateType TypeInvalid = 0;
50491:     static const ThumbImmediateType TypeEncoded = 1;
50491:     static const ThumbImmediateType TypeUInt16 = 2;
50491: 
50491:     typedef union {
50491:         int16_t asInt;
50491:         struct {
50491:             unsigned imm8 : 8;
50491:             unsigned imm3 : 3;
50491:             unsigned i    : 1;
50491:             unsigned imm4 : 4;
50491:         };
50491:         // If this is an encoded immediate, then it may describe a shift, or a pattern.
50491:         struct {
50491:             unsigned shiftValue7 : 7;
50491:             unsigned shiftAmount : 5;
50491:         };
50491:         struct {
50491:             unsigned immediate   : 8;
50491:             unsigned pattern     : 4;
50491:         };
50491:     } ThumbImmediateValue;
50491: 
50491:     // byte0 contains least significant bit; not using an array to make client code endian agnostic.
50491:     typedef union {
50491:         int32_t asInt;
50491:         struct {
50491:             uint8_t byte0;
50491:             uint8_t byte1;
50491:             uint8_t byte2;
50491:             uint8_t byte3;
50491:         };
50491:     } PatternBytes;
50491: 
50491:     ALWAYS_INLINE static void countLeadingZerosPartial(uint32_t& value, int32_t& zeros, const int N)
50491:     {
50491:         if (value & ~((1 << N) - 1)) /* check for any of the top N bits (of 2N bits) are set */
50491:             value >>= N;             /* if any were set, lose the bottom N */
50491:         else                         /* if none of the top N bits are set, */
50491:             zeros += N;              /* then we have identified N leading zeros */
50491:     }
50491: 
50491:     static int32_t countLeadingZeros(uint32_t value)
50491:     {
50491:         if (!value)
50491:             return 32;
50491: 
50491:         int32_t zeros = 0;
50491:         countLeadingZerosPartial(value, zeros, 16);
50491:         countLeadingZerosPartial(value, zeros, 8);
50491:         countLeadingZerosPartial(value, zeros, 4);
50491:         countLeadingZerosPartial(value, zeros, 2);
50491:         countLeadingZerosPartial(value, zeros, 1);
50491:         return zeros;
50491:     }
50491: 
50491:     ARMThumbImmediate()
50491:         : m_type(TypeInvalid)
50491:     {
50491:         m_value.asInt = 0;
50491:     }
50491:         
50491:     ARMThumbImmediate(ThumbImmediateType type, ThumbImmediateValue value)
50491:         : m_type(type)
50491:         , m_value(value)
50491:     {
50491:     }
50491: 
50491:     ARMThumbImmediate(ThumbImmediateType type, uint16_t value)
50491:         : m_type(TypeUInt16)
50491:     {
50491:         // Make sure this constructor is only reached with type TypeUInt16;
50491:         // this extra parameter makes the code a little clearer by making it
50491:         // explicit at call sites which type is being constructed
50491:         ASSERT_UNUSED(type, type == TypeUInt16);
50491: 
50491:         m_value.asInt = value;
50491:     }
50491: 
50491: public:
50491:     static ARMThumbImmediate makeEncodedImm(uint32_t value)
50491:     {
50491:         ThumbImmediateValue encoding;
50491:         encoding.asInt = 0;
50491: 
50491:         // okay, these are easy.
50491:         if (value < 256) {
50491:             encoding.immediate = value;
50491:             encoding.pattern = 0;
50491:             return ARMThumbImmediate(TypeEncoded, encoding);
50491:         }
50491: 
50491:         int32_t leadingZeros = countLeadingZeros(value);
50491:         // if there were 24 or more leading zeros, then we'd have hit the (value < 256) case.
50491:         ASSERT(leadingZeros < 24);
50491: 
50491:         // Given a number with bit fields Z:B:C, where count(Z)+count(B)+count(C) == 32,
50491:         // Z are the bits known zero, B is the 8-bit immediate, C are the bits to check for
50491:         // zero.  count(B) == 8, so the count of bits to be checked is 24 - count(Z).
50491:         int32_t rightShiftAmount = 24 - leadingZeros;
50491:         if (value == ((value >> rightShiftAmount) << rightShiftAmount)) {
50491:             // Shift the value down to the low byte position.  The assign to 
50491:             // shiftValue7 drops the implicit top bit.
50491:             encoding.shiftValue7 = value >> rightShiftAmount;
50491:             // The endoded shift amount is the magnitude of a right rotate.
50491:             encoding.shiftAmount = 8 + leadingZeros;
50491:             return ARMThumbImmediate(TypeEncoded, encoding);
50491:         }
50491:         
50491:         PatternBytes bytes;
50491:         bytes.asInt = value;
50491: 
50491:         if ((bytes.byte0 == bytes.byte1) && (bytes.byte0 == bytes.byte2) && (bytes.byte0 == bytes.byte3)) {
50491:             encoding.immediate = bytes.byte0;
50491:             encoding.pattern = 3;
50491:             return ARMThumbImmediate(TypeEncoded, encoding);
50491:         }
50491: 
50491:         if ((bytes.byte0 == bytes.byte2) && !(bytes.byte1 | bytes.byte3)) {
50491:             encoding.immediate = bytes.byte0;
50491:             encoding.pattern = 1;
50491:             return ARMThumbImmediate(TypeEncoded, encoding);
50491:         }
50491: 
50491:         if ((bytes.byte1 == bytes.byte3) && !(bytes.byte0 | bytes.byte2)) {
50491:             encoding.immediate = bytes.byte0;
50491:             encoding.pattern = 2;
50491:             return ARMThumbImmediate(TypeEncoded, encoding);
50491:         }
50491: 
50491:         return ARMThumbImmediate();
50491:     }
50491: 
50491:     static ARMThumbImmediate makeUInt12(int32_t value)
50491:     {
50491:         return (!(value & 0xfffff000))
50491:             ? ARMThumbImmediate(TypeUInt16, (uint16_t)value)
50491:             : ARMThumbImmediate();
50491:     }
50491: 
50491:     static ARMThumbImmediate makeUInt12OrEncodedImm(int32_t value)
50491:     {
50491:         // If this is not a 12-bit unsigned it, try making an encoded immediate.
50491:         return (!(value & 0xfffff000))
50491:             ? ARMThumbImmediate(TypeUInt16, (uint16_t)value)
50491:             : makeEncodedImm(value);
50491:     }
50491: 
50491:     // The 'make' methods, above, return a !isValid() value if the argument
50491:     // cannot be represented as the requested type.  This methods  is called
50491:     // 'get' since the argument can always be represented.
50491:     static ARMThumbImmediate makeUInt16(uint16_t value)
50491:     {
50491:         return ARMThumbImmediate(TypeUInt16, value);
50491:     }
50491:     
50491:     bool isValid()
50491:     {
50491:         return m_type != TypeInvalid;
50491:     }
50491: 
50491:     // These methods rely on the format of encoded byte values.
50491:     bool isUInt3() { return !(m_value.asInt & 0xfff8); }
50491:     bool isUInt4() { return !(m_value.asInt & 0xfff0); }
50491:     bool isUInt5() { return !(m_value.asInt & 0xffe0); }
50491:     bool isUInt6() { return !(m_value.asInt & 0xffc0); }
50491:     bool isUInt7() { return !(m_value.asInt & 0xff80); }
50491:     bool isUInt8() { return !(m_value.asInt & 0xff00); }
50491:     bool isUInt9() { return (m_type == TypeUInt16) && !(m_value.asInt & 0xfe00); }
50491:     bool isUInt10() { return (m_type == TypeUInt16) && !(m_value.asInt & 0xfc00); }
50491:     bool isUInt12() { return (m_type == TypeUInt16) && !(m_value.asInt & 0xf000); }
50491:     bool isUInt16() { return m_type == TypeUInt16; }
50491:     uint8_t getUInt3() { ASSERT(isUInt3()); return m_value.asInt; }
50491:     uint8_t getUInt4() { ASSERT(isUInt4()); return m_value.asInt; }
50491:     uint8_t getUInt5() { ASSERT(isUInt5()); return m_value.asInt; }
50491:     uint8_t getUInt6() { ASSERT(isUInt6()); return m_value.asInt; }
50491:     uint8_t getUInt7() { ASSERT(isUInt7()); return m_value.asInt; }
50491:     uint8_t getUInt8() { ASSERT(isUInt8()); return m_value.asInt; }
50491:     uint8_t getUInt9() { ASSERT(isUInt9()); return m_value.asInt; }
50491:     uint8_t getUInt10() { ASSERT(isUInt10()); return m_value.asInt; }
50491:     uint16_t getUInt12() { ASSERT(isUInt12()); return m_value.asInt; }
50491:     uint16_t getUInt16() { ASSERT(isUInt16()); return m_value.asInt; }
50491: 
50491:     bool isEncodedImm() { return m_type == TypeEncoded; }
50491: 
50491: private:
50491:     ThumbImmediateType m_type;
50491:     ThumbImmediateValue m_value;
50491: };
50491: 
50491: 
50491: typedef enum {
50491:     SRType_LSL,
50491:     SRType_LSR,
50491:     SRType_ASR,
50491:     SRType_ROR,
50491: 
50491:     SRType_RRX = SRType_ROR
50491: } ARMShiftType;
50491: 
50491: class ARMv7Assembler;
50491: class ShiftTypeAndAmount {
50491:     friend class ARMv7Assembler;
50491: 
50491: public:
50491:     ShiftTypeAndAmount()
50491:     {
50491:         m_u.type = (ARMShiftType)0;
50491:         m_u.amount = 0;
50491:     }
50491:     
50491:     ShiftTypeAndAmount(ARMShiftType type, unsigned amount)
50491:     {
50491:         m_u.type = type;
50491:         m_u.amount = amount & 31;
50491:     }
50491:     
50491:     unsigned lo4() { return m_u.lo4; }
50491:     unsigned hi4() { return m_u.hi4; }
50491:     
50491: private:
50491:     union {
50491:         struct {
50491:             unsigned lo4 : 4;
50491:             unsigned hi4 : 4;
50491:         };
50491:         struct {
50491:             unsigned type   : 2;
50491:             unsigned amount : 5;
50491:         };
50491:     } m_u;
50491: };
50491: 
50491: 
50491: /*
50491: Some features of the Thumb instruction set are deprecated in ARMv7. Deprecated features affecting 
50491: instructions supported by ARMv7-M are as follows: 
50491: • use of the PC as <Rd> or <Rm> in a 16-bit ADD (SP plus register) instruction 
50491: • use of the SP as <Rm> in a 16-bit ADD (SP plus register) instruction 
50491: • use of the SP as <Rm> in a 16-bit CMP (register) instruction 
50491: • use of MOV (register) instructions in which <Rd> is the SP or PC and <Rm> is also the SP or PC. 
50491: • use of <Rn> as the lowest-numbered register in the register list of a 16-bit STM instruction with base 
50491: register writeback 
50491: */
50491: 
50491: class ARMv7Assembler {
50491: public:
50491:     ~ARMv7Assembler()
50491:     {
50491:         ASSERT(m_jumpsToLink.isEmpty());
50491:     }
50491: 
50491:     typedef ARMRegisters::RegisterID RegisterID;
50491:     typedef ARMRegisters::FPRegisterID FPRegisterID;
50491: 
50491:     // (HS, LO, HI, LS) -> (AE, B, A, BE)
50491:     // (VS, VC) -> (O, NO)
50491:     typedef enum {
50491:         ConditionEQ,
50491:         ConditionNE,
50491:         ConditionHS,
50491:         ConditionLO,
50491:         ConditionMI,
50491:         ConditionPL,
50491:         ConditionVS,
50491:         ConditionVC,
50491:         ConditionHI,
50491:         ConditionLS,
50491:         ConditionGE,
50491:         ConditionLT,
50491:         ConditionGT,
50491:         ConditionLE,
50491:         ConditionAL,
50491: 
50491:         ConditionCS = ConditionHS,
50491:         ConditionCC = ConditionLO,
50491:     } Condition;
50491: 
50491:     class JmpSrc {
50491:         friend class ARMv7Assembler;
50491:         friend class ARMInstructionFormatter;
50491:     public:
50491:         JmpSrc()
50491:             : m_offset(-1)
50491:         {
50491:         }
50491: 
50491:     private:
50491:         JmpSrc(int offset)
50491:             : m_offset(offset)
50491:         {
50491:         }
50491: 
50491:         int m_offset;
50491:     };
50491:     
50491:     class JmpDst {
50491:         friend class ARMv7Assembler;
50491:         friend class ARMInstructionFormatter;
50491:     public:
50491:         JmpDst()
50491:             : m_offset(-1)
50491:             , m_used(false)
50491:         {
50491:         }
50491: 
50491:         bool isUsed() const { return m_used; }
50491:         void used() { m_used = true; }
50491:     private:
50491:         JmpDst(int offset)
50491:             : m_offset(offset)
50491:             , m_used(false)
50491:         {
50491:             ASSERT(m_offset == offset);
50491:         }
50491: 
50491:         int m_offset : 31;
50491:         int m_used : 1;
50491:     };
50491: 
50491: private:
50491: 
50491:     struct LinkRecord {
50491:         LinkRecord(intptr_t from, intptr_t to)
50491:             : from(from)
50491:             , to(to)
50491:         {
50491:         }
50491: 
50491:         intptr_t from;
50491:         intptr_t to;
50491:     };
50491: 
50491:     // ARMv7, Appx-A.6.3
50491:     bool BadReg(RegisterID reg)
50491:     {
50491:         return (reg == ARMRegisters::sp) || (reg == ARMRegisters::pc);
50491:     }
50491: 
50491:     bool isSingleRegister(FPRegisterID reg)
50491:     {
50491:         // Check that the high bit isn't set (q16+), and that the low bit isn't (s1, s3, etc).
50491:         return !(reg & ~31);
50491:     }
50491: 
50491:     bool isDoubleRegister(FPRegisterID reg)
50491:     {
50491:         // Check that the high bit isn't set (q16+), and that the low bit isn't (s1, s3, etc).
50491:         return !(reg & ~(31 << 1));
50491:     }
50491: 
50491:     bool isQuadRegister(FPRegisterID reg)
50491:     {
50491:         return !(reg & ~(31 << 2));
50491:     }
50491: 
50491:     uint32_t singleRegisterNum(FPRegisterID reg)
50491:     {
50491:         ASSERT(isSingleRegister(reg));
50491:         return reg;
50491:     }
50491: 
50491:     uint32_t doubleRegisterNum(FPRegisterID reg)
50491:     {
50491:         ASSERT(isDoubleRegister(reg));
50491:         return reg >> 1;
50491:     }
50491: 
50491:     uint32_t quadRegisterNum(FPRegisterID reg)
50491:     {
50491:         ASSERT(isQuadRegister(reg));
50491:         return reg >> 2;
50491:     }
50491: 
50491:     uint32_t singleRegisterMask(FPRegisterID rd, int highBitsShift, int lowBitShift)
50491:     {
50491:         uint32_t rdNum = singleRegisterNum(rd);
50491:         uint32_t rdMask = (rdNum >> 1) << highBitsShift;
50491:         if (rdNum & 1)
50491:             rdMask |= 1 << lowBitShift;
50491:         return rdMask;
50491:     }
50491: 
50491:     uint32_t doubleRegisterMask(FPRegisterID rd, int highBitShift, int lowBitsShift)
50491:     {
50491:         uint32_t rdNum = doubleRegisterNum(rd);
50491:         uint32_t rdMask = (rdNum & 0xf) << lowBitsShift;
50491:         if (rdNum & 16)
50491:             rdMask |= 1 << highBitShift;
50491:         return rdMask;
50491:     }
50491: 
50491:     typedef enum {
50491:         OP_ADD_reg_T1       = 0x1800,
50491:         OP_ADD_S_reg_T1     = 0x1800,
50491:         OP_SUB_reg_T1       = 0x1A00,
50491:         OP_SUB_S_reg_T1     = 0x1A00,
50491:         OP_ADD_imm_T1       = 0x1C00,
50491:         OP_ADD_S_imm_T1     = 0x1C00,
50491:         OP_SUB_imm_T1       = 0x1E00,
50491:         OP_SUB_S_imm_T1     = 0x1E00,
50491:         OP_MOV_imm_T1       = 0x2000,
50491:         OP_CMP_imm_T1       = 0x2800,
50491:         OP_ADD_imm_T2       = 0x3000,
50491:         OP_ADD_S_imm_T2     = 0x3000,
50491:         OP_SUB_imm_T2       = 0x3800,
50491:         OP_SUB_S_imm_T2     = 0x3800,
50491:         OP_AND_reg_T1       = 0x4000,
50491:         OP_EOR_reg_T1       = 0x4040,
50491:         OP_TST_reg_T1       = 0x4200,
50491:         OP_CMP_reg_T1       = 0x4280,
50491:         OP_ORR_reg_T1       = 0x4300,
50491:         OP_MVN_reg_T1       = 0x43C0,
50491:         OP_ADD_reg_T2       = 0x4400,
50491:         OP_MOV_reg_T1       = 0x4600,
50491:         OP_BLX              = 0x4700,
50491:         OP_BX               = 0x4700,
50491:         OP_STR_reg_T1       = 0x5000,
50491:         OP_LDR_reg_T1       = 0x5800,
50491:         OP_LDRH_reg_T1      = 0x5A00,
50491:         OP_LDRB_reg_T1      = 0x5C00,
50491:         OP_STR_imm_T1       = 0x6000,
50491:         OP_LDR_imm_T1       = 0x6800,
50491:         OP_LDRB_imm_T1      = 0x7800,
50491:         OP_LDRH_imm_T1      = 0x8800,
50491:         OP_STR_imm_T2       = 0x9000,
50491:         OP_LDR_imm_T2       = 0x9800,
50491:         OP_ADD_SP_imm_T1    = 0xA800,
50491:         OP_ADD_SP_imm_T2    = 0xB000,
50491:         OP_SUB_SP_imm_T1    = 0xB080,
50491:         OP_BKPT             = 0xBE00,
50491:         OP_IT               = 0xBF00,
50491:         OP_NOP_T1           = 0xBF00,
50491:     } OpcodeID;
50491: 
50491:     typedef enum {
50491:         OP_AND_reg_T2   = 0xEA00,
50491:         OP_TST_reg_T2   = 0xEA10,
50491:         OP_ORR_reg_T2   = 0xEA40,
50491:         OP_ASR_imm_T1   = 0xEA4F,
50491:         OP_LSL_imm_T1   = 0xEA4F,
50491:         OP_LSR_imm_T1   = 0xEA4F,
50491:         OP_ROR_imm_T1   = 0xEA4F,
50491:         OP_MVN_reg_T2   = 0xEA6F,
50491:         OP_EOR_reg_T2   = 0xEA80,
50491:         OP_ADD_reg_T3   = 0xEB00,
50491:         OP_ADD_S_reg_T3 = 0xEB10,
50491:         OP_SUB_reg_T2   = 0xEBA0,
50491:         OP_SUB_S_reg_T2 = 0xEBB0,
50491:         OP_CMP_reg_T2   = 0xEBB0,
50491:         OP_B_T4a        = 0xF000,
50491:         OP_AND_imm_T1   = 0xF000,
50491:         OP_TST_imm      = 0xF010,
50491:         OP_ORR_imm_T1   = 0xF040,
50491:         OP_MOV_imm_T2   = 0xF040,
50491:         OP_MVN_imm      = 0xF060,
50491:         OP_EOR_imm_T1   = 0xF080,
50491:         OP_ADD_imm_T3   = 0xF100,
50491:         OP_ADD_S_imm_T3 = 0xF110,
50491:         OP_CMN_imm      = 0xF110,
50491:         OP_SUB_imm_T3   = 0xF1A0,
50491:         OP_SUB_S_imm_T3 = 0xF1B0,
50491:         OP_CMP_imm_T2   = 0xF1B0,
50491:         OP_ADD_imm_T4   = 0xF200,
50491:         OP_MOV_imm_T3   = 0xF240,
50491:         OP_SUB_imm_T4   = 0xF2A0,
50491:         OP_MOVT         = 0xF2C0,
50491:         OP_NOP_T2a      = 0xF3AF,
50491:         OP_LDRB_imm_T3  = 0xF810,
50491:         OP_LDRB_reg_T2  = 0xF810,
50491:         OP_LDRH_reg_T2  = 0xF830,
50491:         OP_LDRH_imm_T3  = 0xF830,
50491:         OP_STR_imm_T4   = 0xF840,
50491:         OP_STR_reg_T2   = 0xF840,
50491:         OP_LDR_imm_T4   = 0xF850,
50491:         OP_LDR_reg_T2   = 0xF850,
50491:         OP_LDRB_imm_T2  = 0xF890,
50491:         OP_LDRH_imm_T2  = 0xF8B0,
50491:         OP_STR_imm_T3   = 0xF8C0,
50491:         OP_LDR_imm_T3   = 0xF8D0,
50491:         OP_LSL_reg_T2   = 0xFA00,
50491:         OP_LSR_reg_T2   = 0xFA20,
50491:         OP_ASR_reg_T2   = 0xFA40,
50491:         OP_ROR_reg_T2   = 0xFA60,
50491:         OP_SMULL_T1     = 0xFB80,
50491:     } OpcodeID1;
50491: 
50491:     typedef enum {
50491:         OP_B_T4b        = 0x9000,
50491:         OP_NOP_T2b      = 0x8000,
50491:     } OpcodeID2;
50491: 
50491:     struct FourFours {
50491:         FourFours(unsigned f3, unsigned f2, unsigned f1, unsigned f0)
50491:         {
50491:             m_u.f0 = f0;
50491:             m_u.f1 = f1;
50491:             m_u.f2 = f2;
50491:             m_u.f3 = f3;
50491:         }
50491: 
50491:         union {
50491:             unsigned value;
50491:             struct {
50491:                 unsigned f0 : 4;
50491:                 unsigned f1 : 4;
50491:                 unsigned f2 : 4;
50491:                 unsigned f3 : 4;
50491:             };
50491:         } m_u;
50491:     };
50491: 
50491:     class ARMInstructionFormatter;
50491: 
50491:     // false means else!
50491:     bool ifThenElseConditionBit(Condition condition, bool isIf)
50491:     {
50491:         return isIf ? (condition & 1) : !(condition & 1);
50491:     }
50491:     uint8_t ifThenElse(Condition condition, bool inst2if, bool inst3if, bool inst4if)
50491:     {
50491:         int mask = (ifThenElseConditionBit(condition, inst2if) << 3)
50491:             | (ifThenElseConditionBit(condition, inst3if) << 2)
50491:             | (ifThenElseConditionBit(condition, inst4if) << 1)
50491:             | 1;
50491:         ASSERT((condition != ConditionAL) || (mask & (mask - 1)));
50491:         return (condition << 4) | mask;
50491:     }
50491:     uint8_t ifThenElse(Condition condition, bool inst2if, bool inst3if)
50491:     {
50491:         int mask = (ifThenElseConditionBit(condition, inst2if) << 3)
50491:             | (ifThenElseConditionBit(condition, inst3if) << 2)
50491:             | 2;
50491:         ASSERT((condition != ConditionAL) || (mask & (mask - 1)));
50491:         return (condition << 4) | mask;
50491:     }
50491:     uint8_t ifThenElse(Condition condition, bool inst2if)
50491:     {
50491:         int mask = (ifThenElseConditionBit(condition, inst2if) << 3)
50491:             | 4;
50491:         ASSERT((condition != ConditionAL) || (mask & (mask - 1)));
50491:         return (condition << 4) | mask;
50491:     }
50491: 
50491:     uint8_t ifThenElse(Condition condition)
50491:     {
50491:         int mask = 8;
50491:         ASSERT((condition != ConditionAL) || (mask & (mask - 1)));
50491:         return (condition << 4) | mask;
50491:     }
50491: 
50491: public:
50491: 
50491:     void add(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         // Rd can only be SP if Rn is also SP.
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isValid());
50491: 
50491:         if (rn == ARMRegisters::sp) {
50491:             if (!(rd & 8) && imm.isUInt10()) {
50491:                 m_formatter.oneWordOp5Reg3Imm8(OP_ADD_SP_imm_T1, rd, imm.getUInt10() >> 2);
50491:                 return;
50491:             } else if ((rd == ARMRegisters::sp) && imm.isUInt9()) {
50491:                 m_formatter.oneWordOp9Imm7(OP_ADD_SP_imm_T2, imm.getUInt9() >> 2);
50491:                 return;
50491:             }
50491:         } else if (!((rd | rn) & 8)) {
50491:             if (imm.isUInt3()) {
50491:                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
50491:                 return;
50491:             } else if ((rd == rn) && imm.isUInt8()) {
50491:                 m_formatter.oneWordOp5Reg3Imm8(OP_ADD_imm_T2, rd, imm.getUInt8());
50491:                 return;
50491:             }
50491:         }
50491: 
50491:         if (imm.isEncodedImm())
50491:             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADD_imm_T3, rn, rd, imm);
50491:         else {
50491:             ASSERT(imm.isUInt12());
50491:             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADD_imm_T4, rn, rd, imm);
50491:         }
50491:     }
50491: 
50491:     void add(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_ADD_reg_T3, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     // NOTE: In an IT block, add doesn't modify the flags register.
50491:     void add(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if (rd == rn)
50491:             m_formatter.oneWordOp8RegReg143(OP_ADD_reg_T2, rm, rd);
50491:         else if (rd == rm)
50491:             m_formatter.oneWordOp8RegReg143(OP_ADD_reg_T2, rn, rd);
50491:         else if (!((rd | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_reg_T1, rm, rn, rd);
50491:         else
50491:             add(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     // Not allowed in an IT (if then) block.
50491:     void add_S(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         // Rd can only be SP if Rn is also SP.
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isEncodedImm());
50491: 
50491:         if (!((rd | rn) & 8)) {
50491:             if (imm.isUInt3()) {
50491:                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_S_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
50491:                 return;
50491:             } else if ((rd == rn) && imm.isUInt8()) {
50491:                 m_formatter.oneWordOp5Reg3Imm8(OP_ADD_S_imm_T2, rd, imm.getUInt8());
50491:                 return;
50491:             }
50491:         }
50491: 
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ADD_S_imm_T3, rn, rd, imm);
50491:     }
50491: 
50491:     // Not allowed in an IT (if then) block?
50491:     void add_S(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_ADD_S_reg_T3, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     // Not allowed in an IT (if then) block.
50491:     void add_S(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if (!((rd | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_ADD_S_reg_T1, rm, rn, rd);
50491:         else
50491:             add_S(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     void ARM_and(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(imm.isEncodedImm());
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_AND_imm_T1, rn, rd, imm);
50491:     }
50491: 
50491:     void ARM_and(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_AND_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void ARM_and(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if ((rd == rn) && !((rd | rm) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_AND_reg_T1, rm, rd);
50491:         else if ((rd == rm) && !((rd | rn) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_AND_reg_T1, rn, rd);
50491:         else
50491:             ARM_and(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     void asr(RegisterID rd, RegisterID rm, int32_t shiftAmount)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rm));
50491:         ShiftTypeAndAmount shift(SRType_ASR, shiftAmount);
50491:         m_formatter.twoWordOp16FourFours(OP_ASR_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void asr(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_ASR_reg_T2, rn, FourFours(0xf, rd, 0, rm));
50491:     }
50491: 
50491:     // Only allowed in IT (if then) block if last instruction.
50491:     JmpSrc b()
50491:     {
50491:         m_formatter.twoWordOp16Op16(OP_B_T4a, OP_B_T4b);
50491:         return JmpSrc(m_formatter.size());
50491:     }
50491:     
50491:     // Only allowed in IT (if then) block if last instruction.
50491:     JmpSrc blx(RegisterID rm)
50491:     {
50491:         ASSERT(rm != ARMRegisters::pc);
50491:         m_formatter.oneWordOp8RegReg143(OP_BLX, rm, (RegisterID)8);
50491:         return JmpSrc(m_formatter.size());
50491:     }
50491: 
50491:     // Only allowed in IT (if then) block if last instruction.
50491:     JmpSrc bx(RegisterID rm)
50491:     {
50491:         m_formatter.oneWordOp8RegReg143(OP_BX, rm, (RegisterID)0);
50491:         return JmpSrc(m_formatter.size());
50491:     }
50491: 
50491:     void bkpt(uint8_t imm=0)
50491:     {
50491:         m_formatter.oneWordOp8Imm8(OP_BKPT, imm);
50491:     }
50491: 
50491:     void cmn(RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isEncodedImm());
50491: 
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_CMN_imm, rn, (RegisterID)0xf, imm);
50491:     }
50491: 
50491:     void cmp(RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isEncodedImm());
50491: 
50491:         if (!(rn & 8) && imm.isUInt8())
50491:             m_formatter.oneWordOp5Reg3Imm8(OP_CMP_imm_T1, rn, imm.getUInt8());
50491:         else
50491:             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_CMP_imm_T2, rn, (RegisterID)0xf, imm);
50491:     }
50491: 
50491:     void cmp(RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_CMP_reg_T2, rn, FourFours(shift.hi4(), 0xf, shift.lo4(), rm));
50491:     }
50491: 
50491:     void cmp(RegisterID rn, RegisterID rm)
50491:     {
50491:         if ((rn | rm) & 8)
50491:             cmp(rn, rm, ShiftTypeAndAmount());
50491:         else
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_CMP_reg_T1, rm, rn);
50491:     }
50491: 
50491:     // xor is not spelled with an 'e'. :-(
50491:     void eor(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(imm.isEncodedImm());
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_EOR_imm_T1, rn, rd, imm);
50491:     }
50491: 
50491:     // xor is not spelled with an 'e'. :-(
50491:     void eor(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_EOR_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     // xor is not spelled with an 'e'. :-(
50491:     void eor(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if ((rd == rn) && !((rd | rm) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_EOR_reg_T1, rm, rd);
50491:         else if ((rd == rm) && !((rd | rn) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_EOR_reg_T1, rn, rd);
50491:         else
50491:             eor(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     void it(Condition cond)
50491:     {
50491:         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond));
50491:     }
50491: 
50491:     void it(Condition cond, bool inst2if)
50491:     {
50491:         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond, inst2if));
50491:     }
50491: 
50491:     void it(Condition cond, bool inst2if, bool inst3if)
50491:     {
50491:         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond, inst2if, inst3if));
50491:     }
50491: 
50491:     void it(Condition cond, bool inst2if, bool inst3if, bool inst4if)
50491:     {
50491:         m_formatter.oneWordOp8Imm8(OP_IT, ifThenElse(cond, inst2if, inst3if, inst4if));
50491:     }
50491: 
50491:     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
50491:     void ldr(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
50491:         ASSERT(imm.isUInt12());
50491: 
50491:         if (!((rt | rn) & 8) && imm.isUInt7())
50491:             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDR_imm_T1, imm.getUInt7() >> 2, rn, rt);
50491:         else if ((rn == ARMRegisters::sp) && !(rt & 8) && imm.isUInt10())
50491:             m_formatter.oneWordOp5Reg3Imm8(OP_LDR_imm_T2, rt, imm.getUInt10() >> 2);
50491:         else
50491:             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T3, rn, rt, imm.getUInt12());
50491:     }
50491: 
50491:     // If index is set, this is a regular offset or a pre-indexed load;
50491:     // if index is not set then is is a post-index load.
50491:     //
50491:     // If wback is set rn is updated - this is a pre or post index load,
50491:     // if wback is not set this is a regular offset memory access.
50491:     //
50491:     // (-255 <= offset <= 255)
50491:     // _reg = REG[rn]
50491:     // _tmp = _reg + offset
50491:     // MEM[index ? _tmp : _reg] = REG[rt]
50491:     // if (wback) REG[rn] = _tmp
50491:     void ldr(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
50491:     {
50491:         ASSERT(rt != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(index || wback);
50491:         ASSERT(!wback | (rt != rn));
50491:     
50491:         bool add = true;
50491:         if (offset < 0) {
50491:             add = false;
50491:             offset = -offset;
50491:         }
50491:         ASSERT((offset & ~0xff) == 0);
50491:         
50491:         offset |= (wback << 8);
50491:         offset |= (add   << 9);
50491:         offset |= (index << 10);
50491:         offset |= (1 << 11);
50491:         
50491:         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T4, rn, rt, offset);
50491:     }
50491: 
50491:     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
50491:     void ldr(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift=0)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
50491:         ASSERT(!BadReg(rm));
50491:         ASSERT(shift <= 3);
50491: 
50491:         if (!shift && !((rt | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDR_reg_T1, rm, rn, rt);
50491:         else
50491:             m_formatter.twoWordOp12Reg4FourFours(OP_LDR_reg_T2, rn, FourFours(rt, 0, shift, rm));
50491:     }
50491: 
50491:     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
50491:     void ldrh(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
50491:         ASSERT(imm.isUInt12());
50491: 
50491:         if (!((rt | rn) & 8) && imm.isUInt6())
50491:             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDRH_imm_T1, imm.getUInt6() >> 2, rn, rt);
50491:         else
50491:             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRH_imm_T2, rn, rt, imm.getUInt12());
50491:     }
50491: 
50491:     // If index is set, this is a regular offset or a pre-indexed load;
50491:     // if index is not set then is is a post-index load.
50491:     //
50491:     // If wback is set rn is updated - this is a pre or post index load,
50491:     // if wback is not set this is a regular offset memory access.
50491:     //
50491:     // (-255 <= offset <= 255)
50491:     // _reg = REG[rn]
50491:     // _tmp = _reg + offset
50491:     // MEM[index ? _tmp : _reg] = REG[rt]
50491:     // if (wback) REG[rn] = _tmp
50491:     void ldrh(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
50491:     {
50491:         ASSERT(rt != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(index || wback);
50491:         ASSERT(!wback | (rt != rn));
50491:     
50491:         bool add = true;
50491:         if (offset < 0) {
50491:             add = false;
50491:             offset = -offset;
50491:         }
50491:         ASSERT((offset & ~0xff) == 0);
50491:         
50491:         offset |= (wback << 8);
50491:         offset |= (add   << 9);
50491:         offset |= (index << 10);
50491:         offset |= (1 << 11);
50491:         
50491:         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRH_imm_T3, rn, rt, offset);
50491:     }
50491: 
50491:     void ldrh(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift=0)
50491:     {
50491:         ASSERT(!BadReg(rt));   // Memory hint
50491:         ASSERT(rn != ARMRegisters::pc); // LDRH (literal)
50491:         ASSERT(!BadReg(rm));
50491:         ASSERT(shift <= 3);
50491: 
50491:         if (!shift && !((rt | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDRH_reg_T1, rm, rn, rt);
50491:         else
50491:             m_formatter.twoWordOp12Reg4FourFours(OP_LDRH_reg_T2, rn, FourFours(rt, 0, shift, rm));
50491:     }
50491: 
50491:     void ldrb(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
50491:         ASSERT(imm.isUInt12());
50491: 
50491:         if (!((rt | rn) & 8) && imm.isUInt5())
50491:             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDRB_imm_T1, imm.getUInt5(), rn, rt);
50491:         else
50491:             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRB_imm_T2, rn, rt, imm.getUInt12());
50491:     }
50491: 
50491:     void ldrb(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
50491:     {
50491:         ASSERT(rt != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(index || wback);
50491:         ASSERT(!wback | (rt != rn));
50491: 
50491:         bool add = true;
50491:         if (offset < 0) {
50491:             add = false;
50491:             offset = -offset;
50491:         }
50491: 
50491:         ASSERT(!(offset & ~0xff));
50491: 
50491:         offset |= (wback << 8);
50491:         offset |= (add   << 9);
50491:         offset |= (index << 10);
50491:         offset |= (1 << 11);
50491: 
50491:         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDRB_imm_T3, rn, rt, offset);
50491:     }
50491: 
50491:     void ldrb(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift = 0)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc); // LDR (literal)
50491:         ASSERT(!BadReg(rm));
50491:         ASSERT(shift <= 3);
50491: 
50491:         if (!shift && !((rt | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_LDRB_reg_T1, rm, rn, rt);
50491:         else
50491:             m_formatter.twoWordOp12Reg4FourFours(OP_LDRB_reg_T2, rn, FourFours(rt, 0, shift, rm));
50491:     }
50491: 
50491:     void lsl(RegisterID rd, RegisterID rm, int32_t shiftAmount)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rm));
50491:         ShiftTypeAndAmount shift(SRType_LSL, shiftAmount);
50491:         m_formatter.twoWordOp16FourFours(OP_LSL_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void lsl(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_LSL_reg_T2, rn, FourFours(0xf, rd, 0, rm));
50491:     }
50491: 
50491:     void lsr(RegisterID rd, RegisterID rm, int32_t shiftAmount)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rm));
50491:         ShiftTypeAndAmount shift(SRType_LSR, shiftAmount);
50491:         m_formatter.twoWordOp16FourFours(OP_LSR_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void lsr(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_LSR_reg_T2, rn, FourFours(0xf, rd, 0, rm));
50491:     }
50491: 
50491:     void movT3(RegisterID rd, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(imm.isValid());
50491:         ASSERT(!imm.isEncodedImm());
50491:         ASSERT(!BadReg(rd));
50491:         
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MOV_imm_T3, imm.m_value.imm4, rd, imm);
50491:     }
50491: 
50491:      void mov(RegisterID rd, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(imm.isValid());
50491:         ASSERT(!BadReg(rd));
50491:         
50491:         if ((rd < 8) && imm.isUInt8())
50491:             m_formatter.oneWordOp5Reg3Imm8(OP_MOV_imm_T1, rd, imm.getUInt8());
50491:         else if (imm.isEncodedImm())
50491:             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MOV_imm_T2, 0xf, rd, imm);
50491:         else
50491:             movT3(rd, imm);
50491:     }
50491: 
50491:    void mov(RegisterID rd, RegisterID rm)
50491:     {
50491:         m_formatter.oneWordOp8RegReg143(OP_MOV_reg_T1, rm, rd);
50491:     }
50491: 
50491:     void movt(RegisterID rd, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(imm.isUInt16());
50491:         ASSERT(!BadReg(rd));
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MOVT, imm.m_value.imm4, rd, imm);
50491:     }
50491: 
50491:     void mvn(RegisterID rd, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(imm.isEncodedImm());
50491:         ASSERT(!BadReg(rd));
50491:         
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_MVN_imm, 0xf, rd, imm);
50491:     }
50491: 
50491:     void mvn(RegisterID rd, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp16FourFours(OP_MVN_reg_T2, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void mvn(RegisterID rd, RegisterID rm)
50491:     {
50491:         if (!((rd | rm) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_MVN_reg_T1, rm, rd);
50491:         else
50491:             mvn(rd, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     void orr(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(imm.isEncodedImm());
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_ORR_imm_T1, rn, rd, imm);
50491:     }
50491: 
50491:     void orr(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_ORR_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void orr(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if ((rd == rn) && !((rd | rm) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_ORR_reg_T1, rm, rd);
50491:         else if ((rd == rm) && !((rd | rn) & 8))
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_ORR_reg_T1, rn, rd);
50491:         else
50491:             orr(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     void ror(RegisterID rd, RegisterID rm, int32_t shiftAmount)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rm));
50491:         ShiftTypeAndAmount shift(SRType_ROR, shiftAmount);
50491:         m_formatter.twoWordOp16FourFours(OP_ROR_imm_T1, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     void ror(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         ASSERT(!BadReg(rd));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_ROR_reg_T2, rn, FourFours(0xf, rd, 0, rm));
50491:     }
50491: 
50491:     void smull(RegisterID rdLo, RegisterID rdHi, RegisterID rn, RegisterID rm)
50491:     {
50491:         ASSERT(!BadReg(rdLo));
50491:         ASSERT(!BadReg(rdHi));
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         ASSERT(rdLo != rdHi);
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_SMULL_T1, rn, FourFours(rdLo, rdHi, 0, rm));
50491:     }
50491: 
50491:     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
50491:     void str(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(rt != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isUInt12());
50491: 
50491:         if (!((rt | rn) & 8) && imm.isUInt7())
50491:             m_formatter.oneWordOp5Imm5Reg3Reg3(OP_STR_imm_T1, imm.getUInt7() >> 2, rn, rt);
50491:         else if ((rn == ARMRegisters::sp) && !(rt & 8) && imm.isUInt10())
50491:             m_formatter.oneWordOp5Reg3Imm8(OP_STR_imm_T2, rt, imm.getUInt10() >> 2);
50491:         else
50491:             m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STR_imm_T3, rn, rt, imm.getUInt12());
50491:     }
50491: 
50491:     // If index is set, this is a regular offset or a pre-indexed store;
50491:     // if index is not set then is is a post-index store.
50491:     //
50491:     // If wback is set rn is updated - this is a pre or post index store,
50491:     // if wback is not set this is a regular offset memory access.
50491:     //
50491:     // (-255 <= offset <= 255)
50491:     // _reg = REG[rn]
50491:     // _tmp = _reg + offset
50491:     // MEM[index ? _tmp : _reg] = REG[rt]
50491:     // if (wback) REG[rn] = _tmp
50491:     void str(RegisterID rt, RegisterID rn, int offset, bool index, bool wback)
50491:     {
50491:         ASSERT(rt != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(index || wback);
50491:         ASSERT(!wback | (rt != rn));
50491:     
50491:         bool add = true;
50491:         if (offset < 0) {
50491:             add = false;
50491:             offset = -offset;
50491:         }
50491:         ASSERT((offset & ~0xff) == 0);
50491:         
50491:         offset |= (wback << 8);
50491:         offset |= (add   << 9);
50491:         offset |= (index << 10);
50491:         offset |= (1 << 11);
50491:         
50491:         m_formatter.twoWordOp12Reg4Reg4Imm12(OP_STR_imm_T4, rn, rt, offset);
50491:     }
50491: 
50491:     // rt == ARMRegisters::pc only allowed if last instruction in IT (if then) block.
50491:     void str(RegisterID rt, RegisterID rn, RegisterID rm, unsigned shift=0)
50491:     {
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(!BadReg(rm));
50491:         ASSERT(shift <= 3);
50491: 
50491:         if (!shift && !((rt | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_STR_reg_T1, rm, rn, rt);
50491:         else
50491:             m_formatter.twoWordOp12Reg4FourFours(OP_STR_reg_T2, rn, FourFours(rt, 0, shift, rm));
50491:     }
50491: 
50491:     void sub(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         // Rd can only be SP if Rn is also SP.
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isValid());
50491: 
50491:         if ((rn == ARMRegisters::sp) && (rd == ARMRegisters::sp) && imm.isUInt9()) {
50491:             m_formatter.oneWordOp9Imm7(OP_SUB_SP_imm_T1, imm.getUInt9() >> 2);
50491:             return;
50491:         } else if (!((rd | rn) & 8)) {
50491:             if (imm.isUInt3()) {
50491:                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
50491:                 return;
50491:             } else if ((rd == rn) && imm.isUInt8()) {
50491:                 m_formatter.oneWordOp5Reg3Imm8(OP_SUB_imm_T2, rd, imm.getUInt8());
50491:                 return;
50491:             }
50491:         }
50491: 
50491:         if (imm.isEncodedImm())
50491:             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_SUB_imm_T3, rn, rd, imm);
50491:         else {
50491:             ASSERT(imm.isUInt12());
50491:             m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_SUB_imm_T4, rn, rd, imm);
50491:         }
50491:     }
50491: 
50491:     void sub(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_SUB_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     // NOTE: In an IT block, add doesn't modify the flags register.
50491:     void sub(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if (!((rd | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_reg_T1, rm, rn, rd);
50491:         else
50491:             sub(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     // Not allowed in an IT (if then) block.
50491:     void sub_S(RegisterID rd, RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         // Rd can only be SP if Rn is also SP.
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(imm.isValid());
50491: 
50491:         if ((rn == ARMRegisters::sp) && (rd == ARMRegisters::sp) && imm.isUInt9()) {
50491:             m_formatter.oneWordOp9Imm7(OP_SUB_SP_imm_T1, imm.getUInt9() >> 2);
50491:             return;
50491:         } else if (!((rd | rn) & 8)) {
50491:             if (imm.isUInt3()) {
50491:                 m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_S_imm_T1, (RegisterID)imm.getUInt3(), rn, rd);
50491:                 return;
50491:             } else if ((rd == rn) && imm.isUInt8()) {
50491:                 m_formatter.oneWordOp5Reg3Imm8(OP_SUB_S_imm_T2, rd, imm.getUInt8());
50491:                 return;
50491:             }
50491:         }
50491: 
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_SUB_S_imm_T3, rn, rd, imm);
50491:     }
50491: 
50491:     // Not allowed in an IT (if then) block?
50491:     void sub_S(RegisterID rd, RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT((rd != ARMRegisters::sp) || (rn == ARMRegisters::sp));
50491:         ASSERT(rd != ARMRegisters::pc);
50491:         ASSERT(rn != ARMRegisters::pc);
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_SUB_S_reg_T2, rn, FourFours(shift.hi4(), rd, shift.lo4(), rm));
50491:     }
50491: 
50491:     // Not allowed in an IT (if then) block.
50491:     void sub_S(RegisterID rd, RegisterID rn, RegisterID rm)
50491:     {
50491:         if (!((rd | rn | rm) & 8))
50491:             m_formatter.oneWordOp7Reg3Reg3Reg3(OP_SUB_S_reg_T1, rm, rn, rd);
50491:         else
50491:             sub_S(rd, rn, rm, ShiftTypeAndAmount());
50491:     }
50491: 
50491:     void tst(RegisterID rn, ARMThumbImmediate imm)
50491:     {
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(imm.isEncodedImm());
50491: 
50491:         m_formatter.twoWordOp5i6Imm4Reg4EncodedImm(OP_TST_imm, rn, (RegisterID)0xf, imm);
50491:     }
50491: 
50491:     void tst(RegisterID rn, RegisterID rm, ShiftTypeAndAmount shift)
50491:     {
50491:         ASSERT(!BadReg(rn));
50491:         ASSERT(!BadReg(rm));
50491:         m_formatter.twoWordOp12Reg4FourFours(OP_TST_reg_T2, rn, FourFours(shift.hi4(), 0xf, shift.lo4(), rm));
50491:     }
50491: 
50491:     void tst(RegisterID rn, RegisterID rm)
50491:     {
50491:         if ((rn | rm) & 8)
50491:             tst(rn, rm, ShiftTypeAndAmount());
50491:         else
50491:             m_formatter.oneWordOp10Reg3Reg3(OP_TST_reg_T1, rm, rn);
50491:     }
50491: 
50491:     void vadd_F64(FPRegisterID rd, FPRegisterID rn, FPRegisterID rm)
50491:     {
50491:         m_formatter.vfpOp(0x0b00ee30 | doubleRegisterMask(rd, 6, 28) | doubleRegisterMask(rn, 23, 0) | doubleRegisterMask(rm, 21, 16));
50491:     }
50491: 
50491:     void vcmp_F64(FPRegisterID rd, FPRegisterID rm)
50491:     {
50491:         m_formatter.vfpOp(0x0bc0eeb4 | doubleRegisterMask(rd, 6, 28) | doubleRegisterMask(rm, 21, 16));
50491:     }
50491: 
50491:     void vcvt_F64_S32(FPRegisterID fd, FPRegisterID sm)
50491:     {
50491:         m_formatter.vfpOp(0x0bc0eeb8 | doubleRegisterMask(fd, 6, 28) | singleRegisterMask(sm, 16, 21));
50491:     }
50491: 
50491:     void vcvt_S32_F64(FPRegisterID sd, FPRegisterID fm)
50491:     {
50491:         m_formatter.vfpOp(0x0bc0eebd | singleRegisterMask(sd, 28, 6) | doubleRegisterMask(fm, 21, 16));
50491:     }
50491: 
50491:     void vldr(FPRegisterID rd, RegisterID rn, int32_t imm)
50491:     {
50491:         vmem(rd, rn, imm, true);
50491:     }
50491: 
50491:     void vmov(RegisterID rd, FPRegisterID sn)
50491:     {
50491:         m_formatter.vfpOp(0x0a10ee10 | (rd << 28) | singleRegisterMask(sn, 0, 23));
50491:     }
50491: 
50491:     void vmov(FPRegisterID sn, RegisterID rd)
50491:     {
50491:         m_formatter.vfpOp(0x0a10ee00 | (rd << 28) | singleRegisterMask(sn, 0, 23));
50491:     }
50491: 
50491:     // move FPSCR flags to APSR.
50491:     void vmrs_APSR_nzcv_FPSCR()
50491:     {
50491:         m_formatter.vfpOp(0xfa10eef1);
50491:     }
50491: 
50491:     void vmul_F64(FPRegisterID rd, FPRegisterID rn, FPRegisterID rm)
50491:     {
50491:         m_formatter.vfpOp(0x0b00ee20 | doubleRegisterMask(rd, 6, 28) | doubleRegisterMask(rn, 23, 0) | doubleRegisterMask(rm, 21, 16));
50491:     }
50491: 
50491:     void vstr(FPRegisterID rd, RegisterID rn, int32_t imm)
50491:     {
50491:         vmem(rd, rn, imm, false);
50491:     }
50491: 
50491:     void vsub_F64(FPRegisterID rd, FPRegisterID rn, FPRegisterID rm)
50491:     {
50491:         m_formatter.vfpOp(0x0b40ee30 | doubleRegisterMask(rd, 6, 28) | doubleRegisterMask(rn, 23, 0) | doubleRegisterMask(rm, 21, 16));
50491:     }
50491: 
50491: 
50491:     JmpDst label()
50491:     {
50491:         return JmpDst(m_formatter.size());
50491:     }
50491:     
50491:     JmpDst align(int alignment)
50491:     {
50491:         while (!m_formatter.isAligned(alignment))
50491:             bkpt();
50491: 
50491:         return label();
50491:     }
50491:     
50491:     static void* getRelocatedAddress(void* code, JmpSrc jump)
50491:     {
50491:         ASSERT(jump.m_offset != -1);
50491: 
50491:         return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(code) + jump.m_offset);
50491:     }
50491:     
50491:     static void* getRelocatedAddress(void* code, JmpDst destination)
50491:     {
50491:         ASSERT(destination.m_offset != -1);
50491: 
50491:         return reinterpret_cast<void*>(reinterpret_cast<ptrdiff_t>(code) + destination.m_offset);
50491:     }
50491:     
50491:     static int getDifferenceBetweenLabels(JmpDst src, JmpDst dst)
50491:     {
50491:         return dst.m_offset - src.m_offset;
50491:     }
50491:     
50491:     static int getDifferenceBetweenLabels(JmpDst src, JmpSrc dst)
50491:     {
50491:         return dst.m_offset - src.m_offset;
50491:     }
50491:     
50491:     static int getDifferenceBetweenLabels(JmpSrc src, JmpDst dst)
50491:     {
50491:         return dst.m_offset - src.m_offset;
50491:     }
50491:     
50491:     // Assembler admin methods:
50491: 
50491:     size_t size() const
50491:     {
50491:         return m_formatter.size();
50491:     }
50491: 
50491:     void* executableCopy(ExecutablePool* allocator)
50491:     {
50491:         void* copy = m_formatter.executableCopy(allocator);
50491: 
50491:         unsigned jumpCount = m_jumpsToLink.size();
50491:         for (unsigned i = 0; i < jumpCount; ++i) {
50491:             uint16_t* location = reinterpret_cast<uint16_t*>(reinterpret_cast<intptr_t>(copy) + m_jumpsToLink[i].from);
50491:             uint16_t* target = reinterpret_cast<uint16_t*>(reinterpret_cast<intptr_t>(copy) + m_jumpsToLink[i].to);
50491:             linkJumpAbsolute(location, target);
50491:         }
50491:         m_jumpsToLink.clear();
50491: 
50491:         ASSERT(copy);
50491:         return copy;
50491:     }
50491: 
50491:     static unsigned getCallReturnOffset(JmpSrc call)
50491:     {
50491:         ASSERT(call.m_offset >= 0);
50491:         return call.m_offset;
50491:     }
50491: 
50491:     // Linking & patching:
50491:     //
50491:     // 'link' and 'patch' methods are for use on unprotected code - such as the code
50491:     // within the AssemblerBuffer, and code being patched by the patch buffer.  Once
50491:     // code has been finalized it is (platform support permitting) within a non-
50491:     // writable region of memory; to modify the code in an execute-only execuable
50491:     // pool the 'repatch' and 'relink' methods should be used.
50491: 
50491:     void linkJump(JmpSrc from, JmpDst to)
50491:     {
50491:         ASSERT(to.m_offset != -1);
50491:         ASSERT(from.m_offset != -1);
50491:         m_jumpsToLink.append(LinkRecord(from.m_offset, to.m_offset));
50491:     }
50491: 
50491:     static void linkJump(void* code, JmpSrc from, void* to)
50491:     {
50491:         ASSERT(from.m_offset != -1);
50491:         
50491:         uint16_t* location = reinterpret_cast<uint16_t*>(reinterpret_cast<intptr_t>(code) + from.m_offset);
50491:         linkJumpAbsolute(location, to);
50491:     }
50491: 
50491:     // bah, this mathod should really be static, since it is used by the LinkBuffer.
50491:     // return a bool saying whether the link was successful?
50491:     static void linkCall(void* code, JmpSrc from, void* to)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(code) & 1));
50491:         ASSERT(from.m_offset != -1);
50491:         ASSERT(reinterpret_cast<intptr_t>(to) & 1);
50491: 
50491:         setPointer(reinterpret_cast<uint16_t*>(reinterpret_cast<intptr_t>(code) + from.m_offset) - 1, to);
50491:     }
50491: 
50491:     static void linkPointer(void* code, JmpDst where, void* value)
50491:     {
50491:         setPointer(reinterpret_cast<char*>(code) + where.m_offset, value);
50491:     }
50491: 
50491:     static void relinkJump(void* from, void* to)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(from) & 1));
50491:         ASSERT(!(reinterpret_cast<intptr_t>(to) & 1));
50491: 
50491:         linkJumpAbsolute(reinterpret_cast<uint16_t*>(from), to);
50491: 
50491:         ExecutableAllocator::cacheFlush(reinterpret_cast<uint16_t*>(from) - 5, 5 * sizeof(uint16_t));
50491:     }
50491:     
50491:     static void relinkCall(void* from, void* to)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(from) & 1));
50491:         ASSERT(reinterpret_cast<intptr_t>(to) & 1);
50491: 
50491:         setPointer(reinterpret_cast<uint16_t*>(from) - 1, to);
50491: 
50491:         ExecutableAllocator::cacheFlush(reinterpret_cast<uint16_t*>(from) - 5, 4 * sizeof(uint16_t));
50491:     }
50491: 
50491:     static void repatchInt32(void* where, int32_t value)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(where) & 1));
50491:         
50491:         setInt32(where, value);
50491: 
50491:         ExecutableAllocator::cacheFlush(reinterpret_cast<uint16_t*>(where) - 4, 4 * sizeof(uint16_t));
50491:     }
50491: 
50491:     static void repatchPointer(void* where, void* value)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(where) & 1));
50491:         
50491:         setPointer(where, value);
50491: 
50491:         ExecutableAllocator::cacheFlush(reinterpret_cast<uint16_t*>(where) - 4, 4 * sizeof(uint16_t));
50491:     }
50491: 
50491:     static void repatchLoadPtrToLEA(void* where)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(where) & 1));
50491: 
50491:         uint16_t* loadOp = reinterpret_cast<uint16_t*>(where) + 4;
50491:         ASSERT((*loadOp & 0xfff0) == OP_LDR_reg_T2);
50491: 
50491:         *loadOp = OP_ADD_reg_T3 | (*loadOp & 0xf);
50491:         ExecutableAllocator::cacheFlush(loadOp, sizeof(uint16_t));
50491:     }
50491: 
50491:     static void repatchLEAToLoadPtr(void* where)
50491:     {
50491:         ASSERT(!(reinterpret_cast<intptr_t>(where) & 1));
50491: 
50491:         uint16_t* loadOp = reinterpret_cast<uint16_t*>(where) + 4;
50491: 	if ((*loadOp & 0xfff0) == OP_LDR_reg_T2)
50491:   	    return;
50491: 
50491:         ASSERT((*loadOp & 0xfff0) == OP_ADD_reg_T3);
50491: 
50491:         *loadOp = OP_LDR_reg_T2 | (*loadOp & 0xf);
50491:         ExecutableAllocator::cacheFlush(loadOp, sizeof(uint16_t));
50491:     }
50491: 
50491: private:
50491: 
50491:     // Arm vfp addresses can be offset by a 9-bit ones-comp immediate, left shifted by 2.
50491:     // (i.e. +/-(0..255) 32-bit words)
50491:     void vmem(FPRegisterID rd, RegisterID rn, int32_t imm, bool isLoad)
50491:     {
50491:         bool up;
50491:         uint32_t offset;
50491:         if (imm < 0) {
50491:             offset = -imm;
50491:             up = false;
50491:         } else {
50491:             offset = imm;
50491:             up = true;
50491:         }
50491: 
50491:         // offset is effectively leftshifted by 2 already (the bottom two bits are zero, and not
50491:         // reperesented in the instruction.  Left shift by 14, to mov it into position 0x00AA0000.
50491:         ASSERT((offset & ~(0xff << 2)) == 0);
50491:         offset <<= 14;
50491: 
50491:         m_formatter.vfpOp(0x0b00ed00 | offset | (up << 7) | (isLoad << 4) | doubleRegisterMask(rd, 6, 28) | rn);
50491:     }
50491: 
50491:     static void setInt32(void* code, uint32_t value)
50491:     {
50491:         uint16_t* location = reinterpret_cast<uint16_t*>(code);
50491:         ASSERT(isMOV_imm_T3(location - 4) && isMOVT(location - 2));
50491: 
50491:         ARMThumbImmediate lo16 = ARMThumbImmediate::makeUInt16(static_cast<uint16_t>(value));
50491:         ARMThumbImmediate hi16 = ARMThumbImmediate::makeUInt16(static_cast<uint16_t>(value >> 16));
50491:         location[-4] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, lo16);
50491:         location[-3] = twoWordOp5i6Imm4Reg4EncodedImmSecond((location[-3] >> 8) & 0xf, lo16);
50491:         location[-2] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOVT, hi16);
50491:         location[-1] = twoWordOp5i6Imm4Reg4EncodedImmSecond((location[-1] >> 8) & 0xf, hi16);
50491: 
50491:         ExecutableAllocator::cacheFlush(location - 4, 4 * sizeof(uint16_t));
50491:     }
50491: 
50491:     static void setPointer(void* code, void* value)
50491:     {
50491:         setInt32(code, reinterpret_cast<uint32_t>(value));
50491:     }
50491: 
50491:     static bool isB(void* address)
50491:     {
50491:         uint16_t* instruction = static_cast<uint16_t*>(address);
50491:         return ((instruction[0] & 0xf800) == OP_B_T4a) && ((instruction[1] & 0xd000) == OP_B_T4b);
50491:     }
50491: 
50491:     static bool isBX(void* address)
50491:     {
50491:         uint16_t* instruction = static_cast<uint16_t*>(address);
50491:         return (instruction[0] & 0xff87) == OP_BX;
50491:     }
50491: 
50491:     static bool isMOV_imm_T3(void* address)
50491:     {
50491:         uint16_t* instruction = static_cast<uint16_t*>(address);
50491:         return ((instruction[0] & 0xFBF0) == OP_MOV_imm_T3) && ((instruction[1] & 0x8000) == 0);
50491:     }
50491: 
50491:     static bool isMOVT(void* address)
50491:     {
50491:         uint16_t* instruction = static_cast<uint16_t*>(address);
50491:         return ((instruction[0] & 0xFBF0) == OP_MOVT) && ((instruction[1] & 0x8000) == 0);
50491:     }
50491: 
50491:     static bool isNOP_T1(void* address)
50491:     {
50491:         uint16_t* instruction = static_cast<uint16_t*>(address);
50491:         return instruction[0] == OP_NOP_T1;
50491:     }
50491: 
50491:     static bool isNOP_T2(void* address)
50491:     {
50491:         uint16_t* instruction = static_cast<uint16_t*>(address);
50491:         return (instruction[0] == OP_NOP_T2a) && (instruction[1] == OP_NOP_T2b);
50491:     }
50491: 
50491:     static void linkJumpAbsolute(uint16_t* instruction, void* target)
50491:     {
50491:         // FIMXE: this should be up in the MacroAssembler layer. :-(
50491:         const uint16_t JUMP_TEMPORARY_REGISTER = ARMRegisters::ip;
50491: 
50491:         ASSERT(!(reinterpret_cast<intptr_t>(instruction) & 1));
50491:         ASSERT(!(reinterpret_cast<intptr_t>(target) & 1));
50491: 
50491:         ASSERT( (isMOV_imm_T3(instruction - 5) && isMOVT(instruction - 3) && isBX(instruction - 1))
50491:             || (isNOP_T1(instruction - 5) && isNOP_T2(instruction - 4) && isB(instruction - 2)) );
50491: 
50491:         intptr_t relative = reinterpret_cast<intptr_t>(target) - (reinterpret_cast<intptr_t>(instruction));
50491: 
50491:         // From Cortex-A8 errata:
50491:         // If the 32-bit Thumb-2 branch instruction spans two 4KiB regions and
50491:         // the target of the branch falls within the first region it is
50491:         // possible for the processor to incorrectly determine the branch
50491:         // instruction, and it is also possible in some cases for the processor
50491:         // to enter a deadlock state.
50491:         // The instruction is spanning two pages if it ends at an address ending 0x002
50491:         bool spansTwo4K = ((reinterpret_cast<intptr_t>(instruction) & 0xfff) == 0x002);
50491:         // The target is in the first page if the jump branch back by [3..0x1002] bytes
50491:         bool targetInFirstPage = (relative >= -0x1002) && (relative < -2);
50491:         bool wouldTriggerA8Errata = spansTwo4K && targetInFirstPage;
50491: 
50491:         if (((relative << 7) >> 7) == relative && !wouldTriggerA8Errata) {
50491:             // ARM encoding for the top two bits below the sign bit is 'peculiar'.
50491:             if (relative >= 0)
50491:                 relative ^= 0xC00000;
50491: 
50491:             // All branch offsets should be an even distance.
50491:             ASSERT(!(relative & 1));
50491:             // There may be a better way to fix this, but right now put the NOPs first, since in the
50491:             // case of an conditional branch this will be coming after an ITTT predicating *three*
50491:             // instructions!  Looking backwards to modify the ITTT to an IT is not easy, due to
50491:             // variable wdith encoding - the previous instruction might *look* like an ITTT but
50491:             // actually be the second half of a 2-word op.
50491:             instruction[-5] = OP_NOP_T1;
50491:             instruction[-4] = OP_NOP_T2a;
50491:             instruction[-3] = OP_NOP_T2b;
50491:             instruction[-2] = OP_B_T4a | ((relative & 0x1000000) >> 14) | ((relative & 0x3ff000) >> 12);
50491:             instruction[-1] = OP_B_T4b | ((relative & 0x800000) >> 10) | ((relative & 0x400000) >> 11) | ((relative & 0xffe) >> 1);
50491:         } else {
50491:             ARMThumbImmediate lo16 = ARMThumbImmediate::makeUInt16(static_cast<uint16_t>(reinterpret_cast<uint32_t>(target) + 1));
50491:             ARMThumbImmediate hi16 = ARMThumbImmediate::makeUInt16(static_cast<uint16_t>(reinterpret_cast<uint32_t>(target) >> 16));
50491:             instruction[-5] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOV_imm_T3, lo16);
50491:             instruction[-4] = twoWordOp5i6Imm4Reg4EncodedImmSecond(JUMP_TEMPORARY_REGISTER, lo16);
50491:             instruction[-3] = twoWordOp5i6Imm4Reg4EncodedImmFirst(OP_MOVT, hi16);
50491:             instruction[-2] = twoWordOp5i6Imm4Reg4EncodedImmSecond(JUMP_TEMPORARY_REGISTER, hi16);
50491:             instruction[-1] = OP_BX | (JUMP_TEMPORARY_REGISTER << 3);
50491:         }
50491:     }
50491: 
50491:     static uint16_t twoWordOp5i6Imm4Reg4EncodedImmFirst(uint16_t op, ARMThumbImmediate imm)
50491:     {
50491:         return op | (imm.m_value.i << 10) | imm.m_value.imm4;
50491:     }
50491:     static uint16_t twoWordOp5i6Imm4Reg4EncodedImmSecond(uint16_t rd, ARMThumbImmediate imm)
50491:     {
50491:         return (imm.m_value.imm3 << 12) | (rd << 8) | imm.m_value.imm8;
50491:     }
50491: 
50491:     class ARMInstructionFormatter {
50491:     public:
50491:         void oneWordOp5Reg3Imm8(OpcodeID op, RegisterID rd, uint8_t imm)
50491:         {
50491:             m_buffer.putShort(op | (rd << 8) | imm);
50491:         }
50491:         
50491:         void oneWordOp5Imm5Reg3Reg3(OpcodeID op, uint8_t imm, RegisterID reg1, RegisterID reg2)
50491:         {
50491:             m_buffer.putShort(op | (imm << 6) | (reg1 << 3) | reg2);
50491:         }
50491: 
50491:         void oneWordOp7Reg3Reg3Reg3(OpcodeID op, RegisterID reg1, RegisterID reg2, RegisterID reg3)
50491:         {
50491:             m_buffer.putShort(op | (reg1 << 6) | (reg2 << 3) | reg3);
50491:         }
50491: 
50491:         void oneWordOp8Imm8(OpcodeID op, uint8_t imm)
50491:         {
50491:             m_buffer.putShort(op | imm);
50491:         }
50491: 
50491:         void oneWordOp8RegReg143(OpcodeID op, RegisterID reg1, RegisterID reg2)
50491:         {
50491:             m_buffer.putShort(op | ((reg2 & 8) << 4) | (reg1 << 3) | (reg2 & 7));
50491:         }
50491:         void oneWordOp9Imm7(OpcodeID op, uint8_t imm)
50491:         {
50491:             m_buffer.putShort(op | imm);
50491:         }
50491: 
50491:         void oneWordOp10Reg3Reg3(OpcodeID op, RegisterID reg1, RegisterID reg2)
50491:         {
50491:             m_buffer.putShort(op | (reg1 << 3) | reg2);
50491:         }
50491: 
50491:         void twoWordOp12Reg4FourFours(OpcodeID1 op, RegisterID reg, FourFours ff)
50491:         {
50491:             m_buffer.putShort(op | reg);
50491:             m_buffer.putShort(ff.m_u.value);
50491:         }
50491:         
50491:         void twoWordOp16FourFours(OpcodeID1 op, FourFours ff)
50491:         {
50491:             m_buffer.putShort(op);
50491:             m_buffer.putShort(ff.m_u.value);
50491:         }
50491:         
50491:         void twoWordOp16Op16(OpcodeID1 op1, OpcodeID2 op2)
50491:         {
50491:             m_buffer.putShort(op1);
50491:             m_buffer.putShort(op2);
50491:         }
50491: 
50491:         void twoWordOp5i6Imm4Reg4EncodedImm(OpcodeID1 op, int imm4, RegisterID rd, ARMThumbImmediate imm)
50491:         {
50491:             ARMThumbImmediate newImm = imm;
50491:             newImm.m_value.imm4 = imm4;
50491: 
50491:             m_buffer.putShort(ARMv7Assembler::twoWordOp5i6Imm4Reg4EncodedImmFirst(op, newImm));
50491:             m_buffer.putShort(ARMv7Assembler::twoWordOp5i6Imm4Reg4EncodedImmSecond(rd, newImm));
50491:         }
50491: 
50491:         void twoWordOp12Reg4Reg4Imm12(OpcodeID1 op, RegisterID reg1, RegisterID reg2, uint16_t imm)
50491:         {
50491:             m_buffer.putShort(op | reg1);
50491:             m_buffer.putShort((reg2 << 12) | imm);
50491:         }
50491: 
50491:         void vfpOp(int32_t op)
50491:         {
50491:             m_buffer.putInt(op);
50491:         }
50491: 
50491: 
50491:         // Administrative methods:
50491: 
50491:         size_t size() const { return m_buffer.size(); }
50491:         bool isAligned(int alignment) const { return m_buffer.isAligned(alignment); }
50491:         void* data() const { return m_buffer.data(); }
50491:         void* executableCopy(ExecutablePool* allocator) { return m_buffer.executableCopy(allocator); }
56037:         bool oom() const { return m_buffer.oom(); }
50491: 
50491:     private:
50491:         AssemblerBuffer m_buffer;
50491:     } m_formatter;
50491: 
50491:     Vector<LinkRecord> m_jumpsToLink;
50491: };
50491: 
50491: } // namespace JSC
50491: 
50491: #endif // ENABLE(ASSEMBLER) && CPU(ARM_THUMB2)
50491: 
50491: #endif // ARMAssembler_h
