 26941: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 26941: /* vim:set ts=2 sw=2 sts=2 et cindent: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 26941: 
 28510: #ifndef mozilla_TimeStamp_h
 28510: #define mozilla_TimeStamp_h
 26941: 
 87183: #include "mozilla/Assertions.h"
 87183: 
 26941: #include "prinrval.h"
 26941: #include "nsDebug.h"
 48030: #include "prlong.h"
 26941: 
107001: namespace IPC {
107001: template <typename T> struct ParamTraits;
107001: }
107001: 
 26941: namespace mozilla {
 26941: 
 26941: class TimeStamp;
 26941: 
 26941: /**
 26941:  * Instances of this class represent the length of an interval of time.
 26941:  * Negative durations are allowed, meaning the end is before the start.
 26941:  * 
108991:  * Internally the duration is stored as a int64_t in units of
 36930:  * PR_TicksPerSecond() when building with NSPR interval timers, or a
 36930:  * system-dependent unit when building with system clocks.  The
 36930:  * system-dependent unit must be constant, otherwise the semantics of
 36930:  * this class would be broken.
 26941:  */
 76805: class TimeDuration
 41042: {
 26941: public:
 26941:   // The default duration is 0.
 26941:   TimeDuration() : mValue(0) {}
 27220:   // Allow construction using '0' as the initial value, for readability,
 27220:   // but no other numbers (so we don't have any implicit unit conversions).
 27220:   struct _SomethingVeryRandomHere;
 27220:   TimeDuration(_SomethingVeryRandomHere* aZero) : mValue(0) {
 87183:     MOZ_ASSERT(!aZero, "Who's playing funny games here?");
 27220:   }
 26941:   // Default copy-constructor and assignment are OK
 26941: 
 36930:   double ToSeconds() const;
 36930:   // Return a duration value that includes digits of time we think to
 36930:   // be significant.  This method should be used when displaying a
 36930:   // time to humans.
 36930:   double ToSecondsSigDigits() const;
 47681:   double ToMilliseconds() const {
 47681:     return ToSeconds() * 1000.0;
 47681:   }
 74129:   double ToMicroseconds() const {
 74129:     return ToMilliseconds() * 1000.0;
 74129:   }
 26941: 
 48030:   // Using a double here is safe enough; with 53 bits we can represent
 48030:   // durations up to over 280,000 years exactly.  If the units of
 48030:   // mValue do not allow us to represent durations of that length,
 48030:   // long durations are clamped to the max/min representable value
 48030:   // instead of overflowing.
 48030:   static inline TimeDuration FromSeconds(double aSeconds) {
 48030:     return FromMilliseconds(aSeconds * 1000.0);
 48030:   }
 48030:   static TimeDuration FromMilliseconds(double aMilliseconds);
 90443:   static inline TimeDuration FromMicroseconds(double aMicroseconds) {
 90443:     return FromMilliseconds(aMicroseconds / 1000.0);
 90443:   }
 27220: 
 27220:   TimeDuration operator+(const TimeDuration& aOther) const {
 27220:     return TimeDuration::FromTicks(mValue + aOther.mValue);
 27220:   }
 27220:   TimeDuration operator-(const TimeDuration& aOther) const {
 27220:     return TimeDuration::FromTicks(mValue - aOther.mValue);
 27220:   }
 27220:   TimeDuration& operator+=(const TimeDuration& aOther) {
 27220:     mValue += aOther.mValue;
 27220:     return *this;
 27220:   }
 27220:   TimeDuration& operator-=(const TimeDuration& aOther) {
 27220:     mValue -= aOther.mValue;
 27220:     return *this;
 26941:   }
118629:   TimeDuration operator*(const double aMultiplier) const {
118629:     return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
118629:   }
118629:   TimeDuration operator*(const int32_t aMultiplier) const {
118629:     return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
118629:   }
118629:   TimeDuration operator*(const uint32_t aMultiplier) const {
118629:     return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
118629:   }
118629:   TimeDuration operator*(const int64_t aMultiplier) const {
118629:     return TimeDuration::FromTicks(mValue * int64_t(aMultiplier));
118629:   }
 63967:   double operator/(const TimeDuration& aOther) {
 63967:     return static_cast<double>(mValue) / aOther.mValue;
 63967:   }
 26941: 
 79445:   bool operator<(const TimeDuration& aOther) const {
 26941:     return mValue < aOther.mValue;
 26941:   }
 79445:   bool operator<=(const TimeDuration& aOther) const {
 26941:     return mValue <= aOther.mValue;
 26941:   }
 79445:   bool operator>=(const TimeDuration& aOther) const {
 26941:     return mValue >= aOther.mValue;
 26941:   }
 79445:   bool operator>(const TimeDuration& aOther) const {
 26941:     return mValue > aOther.mValue;
 26941:   }
107001:   bool operator==(const TimeDuration& aOther) const {
107001:     return mValue == aOther.mValue;
107001:   }
 26941: 
 36930:   // Return a best guess at the system's current timing resolution,
 36930:   // which might be variable.  TimeDurations below this order of
 36930:   // magnitude are meaningless, and those at the same order of
 36930:   // magnitude or just above are suspect.
 36930:   static TimeDuration Resolution();
 36930: 
 26941:   // We could define additional operators here:
 26941:   // -- convert to/from other time units
 26941:   // -- scale duration by a float
 26941:   // but let's do that on demand.
 36930:   // Comparing durations for equality will only lead to bugs on
 36930:   // platforms with high-resolution timers.
 26941: 
 26941: private:
 26941:   friend class TimeStamp;
107001:   friend struct IPC::ParamTraits<mozilla::TimeDuration>;
 26941: 
108991:   static TimeDuration FromTicks(int64_t aTicks) {
 27220:     TimeDuration t;
 27220:     t.mValue = aTicks;
 27220:     return t;
 27220:   }
 26941: 
 48030:   static TimeDuration FromTicks(double aTicks) {
110760:     // NOTE: this MUST be a >= test, because int64_t(double(INT64_MAX))
115421:     // overflows and gives INT64_MIN.
110760:     if (aTicks >= double(INT64_MAX))
110760:       return TimeDuration::FromTicks(INT64_MAX);
 48030: 
 48030:     // This MUST be a <= test.
110760:     if (aTicks <= double(INT64_MIN))
110760:       return TimeDuration::FromTicks(INT64_MIN);
 48030: 
108991:     return TimeDuration::FromTicks(int64_t(aTicks));
 48030:   }
 48030: 
 26941:   // Duration in PRIntervalTime units
108991:   int64_t mValue;
 26941: };
 26941: 
 26941: /**
 36930:  * Instances of this class represent moments in time, or a special
 36930:  * "null" moment. We do not use the non-monotonic system clock or
 36930:  * local time, since they can be reset, causing apparent backward
 36930:  * travel in time, which can confuse algorithms. Instead we measure
 36930:  * elapsed time according to the system.  This time can never go
 36930:  * backwards (i.e. it never wraps around, at least not in less than
 36930:  * five million years of system elapsed time). It might not advance
 36930:  * while the system is sleeping. If TimeStamp::SetNow() is not called
 36930:  * at all for hours or days, we might not notice the passage of some
 36930:  * of that time.
 26941:  * 
 26941:  * We deliberately do not expose a way to convert TimeStamps to some
 26941:  * particular unit. All you can do is compute a difference between two
 26941:  * TimeStamps to get a TimeDuration. You can also add a TimeDuration
 26941:  * to a TimeStamp to get a new TimeStamp. You can't do something
 26941:  * meaningless like add two TimeStamps.
 26941:  *
 36930:  * Internally this is implemented as either a wrapper around
 36930:  *   - high-resolution, monotonic, system clocks if they exist on this
 36930:  *     platform
 36930:  *   - PRIntervalTime otherwise.  We detect wraparounds of
 36930:  *     PRIntervalTime and work around them.
 79891:  *
 79891:  * This class is similar to C++11's time_point, however it is
 79891:  * explicitly nullable and provides an IsNull() method. time_point
 79891:  * is initialized to the clock's epoch and provides a
 79891:  * time_since_epoch() method that functions similiarly. i.e.
 79891:  * t.IsNull() is equivalent to t.time_since_epoch() == decltype(t)::duration::zero();
 26941:  */
 76805: class TimeStamp
 41042: {
 26941: public:
 26941:   /**
 26941:    * Initialize to the "null" moment
 26941:    */
 26941:   TimeStamp() : mValue(0) {}
 26941:   // Default copy-constructor and assignment are OK
 26941: 
 26941:   /**
 26941:    * Return true if this is the "null" moment
 26941:    */
 79445:   bool IsNull() const { return mValue == 0; }
 26941:   /**
 26941:    * Return a timestamp reflecting the current elapsed system time. This
 26941:    * is monotonically increasing (i.e., does not decrease) over the
 26941:    * lifetime of this process' XPCOM session.
 26941:    */
 26941:   static TimeStamp Now();
 26941:   /**
 26941:    * Compute the difference between two timestamps. Both must be non-null.
 26941:    */
 26941:   TimeDuration operator-(const TimeStamp& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
115421:     PR_STATIC_ASSERT(-INT64_MAX > INT64_MIN);
108991:     int64_t ticks = int64_t(mValue - aOther.mValue);
 48030:     // Check for overflow.
 48030:     if (mValue > aOther.mValue) {
 48030:       if (ticks < 0) {
115421:         ticks = INT64_MAX;
 48030:       }
 48030:     } else {
 48030:       if (ticks > 0) {
115421:         ticks = INT64_MIN;
 48030:       }
 48030:     }
 48030:     return TimeDuration::FromTicks(ticks);
 27220:   }
 27220: 
 27220:   TimeStamp operator+(const TimeDuration& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 27220:     return TimeStamp(mValue + aOther.mValue);
 27220:   }
 27220:   TimeStamp operator-(const TimeDuration& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 27220:     return TimeStamp(mValue - aOther.mValue);
 27220:   }
 27220:   TimeStamp& operator+=(const TimeDuration& aOther) {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 27220:     mValue += aOther.mValue;
 27220:     return *this;
 27220:   }
 27220:   TimeStamp& operator-=(const TimeDuration& aOther) {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 27220:     mValue -= aOther.mValue;
 27220:     return *this;
 26941:   }
 26941: 
 79445:   bool operator<(const TimeStamp& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
 26941:     return mValue < aOther.mValue;
 26941:   }
 79445:   bool operator<=(const TimeStamp& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
 26941:     return mValue <= aOther.mValue;
 26941:   }
 79445:   bool operator>=(const TimeStamp& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
 26941:     return mValue >= aOther.mValue;
 26941:   }
 79445:   bool operator>(const TimeStamp& aOther) const {
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
 26941:     return mValue > aOther.mValue;
 26941:   }
 79445:   bool operator==(const TimeStamp& aOther) const {
 33649:     // Maybe it's ok to check == with null timestamps?
 77204:     MOZ_ASSERT(!IsNull() && "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
 33649:     return mValue == aOther.mValue;
 33649:   }
 79445:   bool operator!=(const TimeStamp& aOther) const {
 33649:     // Maybe it's ok to check != with null timestamps?
 87183:     MOZ_ASSERT(!IsNull(), "Cannot compute with a null value");
 87183:     MOZ_ASSERT(!aOther.IsNull(), "Cannot compute with aOther null value");
 33649:     return mValue != aOther.mValue;
 33649:   }
 26941: 
 26941:   // Comparing TimeStamps for equality should be discouraged. Adding
 26941:   // two TimeStamps, or scaling TimeStamps, is nonsense and must never
 26941:   // be allowed.
 26941: 
 26941:   static NS_HIDDEN_(nsresult) Startup();
 26941:   static NS_HIDDEN_(void) Shutdown();
 26941: 
 26941: private:
107001:   friend struct IPC::ParamTraits<mozilla::TimeStamp>;
107001: 
108991:   TimeStamp(uint64_t aValue) : mValue(aValue) {}
 26941: 
 26941:   /**
 36930:    * When built with PRIntervalTime, a value of 0 means this instance
 36930:    * is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
 36930:    * and the high 32 bits represent a counter of the number of
 36930:    * rollovers of PRIntervalTime that we've seen. This counter starts
 36930:    * at 1 to avoid a real time colliding with the "null" value.
 26941:    * 
 26941:    * PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
 26941:    * time to wrap around is about 2^64/100000 seconds, i.e. about
 26941:    * 5,849,424 years.
 36930:    *
 36930:    * When using a system clock, a value is system dependent.
 26941:    */
108991:   uint64_t mValue;
 26941: };
 26941: 
 26941: }
 26941: 
 28510: #endif /* mozilla_TimeStamp_h */
