 43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #ifndef nsHttpConnectionMgr_h__
 43113: #define nsHttpConnectionMgr_h__
 43113: 
 43113: #include "nsHttpConnectionInfo.h"
 43113: #include "nsHttpConnection.h"
 43113: #include "nsHttpTransaction.h"
 96926: #include "NullHttpTransaction.h"
 43113: #include "nsTArray.h"
 43113: #include "nsThreadUtils.h"
 74833: #include "nsClassHashtable.h"
 84549: #include "nsDataHashtable.h"
 43113: #include "nsAutoPtr.h"
 69142: #include "mozilla/ReentrantMonitor.h"
 64613: #include "nsISocketTransportService.h"
 93840: #include "mozilla/TimeStamp.h"
 43113: 
 55822: #include "nsIObserver.h"
 55822: #include "nsITimer.h"
 84549: #include "nsIX509Cert3.h"
 55822: 
 94988: class nsHttpPipeline;
 43113: 
 96974: class nsIHttpUpgradeListener;
 96974: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 55822: class nsHttpConnectionMgr : public nsIObserver
 43113: {
 43113: public:
 55822:     NS_DECL_ISUPPORTS
 55822:     NS_DECL_NSIOBSERVER
 43113: 
 43113:     // parameter names
 43113:     enum nsParamName {
 43113:         MAX_CONNECTIONS,
 43113:         MAX_CONNECTIONS_PER_HOST,
 43113:         MAX_CONNECTIONS_PER_PROXY,
 43113:         MAX_PERSISTENT_CONNECTIONS_PER_HOST,
 43113:         MAX_PERSISTENT_CONNECTIONS_PER_PROXY,
 43113:         MAX_REQUEST_DELAY,
 93840:         MAX_PIPELINED_REQUESTS,
 93840:         MAX_OPTIMISTIC_PIPELINED_REQUESTS
 43113:     };
 43113: 
 43113:     //-------------------------------------------------------------------------
 43113:     // NOTE: functions below may only be called on the main thread.
 43113:     //-------------------------------------------------------------------------
 43113: 
 43113:     nsHttpConnectionMgr();
 43113: 
 43113:     nsresult Init(PRUint16 maxConnections,
 43113:                   PRUint16 maxConnectionsPerHost,
 43113:                   PRUint16 maxConnectionsPerProxy,
 43113:                   PRUint16 maxPersistentConnectionsPerHost,
 43113:                   PRUint16 maxPersistentConnectionsPerProxy,
 43113:                   PRUint16 maxRequestDelay,
 93840:                   PRUint16 maxPipelinedRequests,
 93840:                   PRUint16 maxOptimisticPipelinedRequests);
 43113:     nsresult Shutdown();
 43113: 
 43113:     //-------------------------------------------------------------------------
 43113:     // NOTE: functions below may be called on any thread.
 43113:     //-------------------------------------------------------------------------
 43113: 
 55822:     // Schedules next pruning of dead connection to happen after
 55822:     // given time.
 55822:     void PruneDeadConnectionsAfter(PRUint32 time);
 43113: 
 84549:     // Stops timer scheduled for next pruning of dead connections if
 84549:     // there are no more idle connections or active spdy ones
 84549:     void ConditionallyStopPruneDeadConnectionsTimer();
 43113: 
 95194:     // Stops timer used for the read timeout tick if there are no currently
 95194:     // active connections.
 95194:     void ConditionallyStopReadTimeoutTick();
 95194: 
 43113:     // adds a transaction to the list of managed transactions.
 43113:     nsresult AddTransaction(nsHttpTransaction *, PRInt32 priority);
 43113: 
 43113:     // called to reschedule the given transaction.  it must already have been
 43113:     // added to the connection manager via AddTransaction.
 43113:     nsresult RescheduleTransaction(nsHttpTransaction *, PRInt32 priority);
 43113: 
 43113:     // cancels a transaction w/ the given reason.
 43113:     nsresult CancelTransaction(nsHttpTransaction *, nsresult reason);
 43113: 
 43113:     // called to force the connection manager to prune its list of idle
 43113:     // connections.
 43113:     nsresult PruneDeadConnections();
 43113: 
 74328:     // Close all idle persistent connections and prevent any active connections
 74328:     // from being reused.
 74328:     nsresult ClosePersistentConnections();
 74328: 
 43113:     // called to get a reference to the socket transport service.  the socket
 43113:     // transport service is not available when the connection manager is down.
 43113:     nsresult GetSocketThreadTarget(nsIEventTarget **);
 43113: 
 96926:     // called to indicate a transaction for the connectionInfo is likely coming
 96926:     // soon. The connection manager may use this information to start a TCP
 96926:     // and/or SSL level handshake for that resource immediately so that it is
 96926:     // ready when the transaction is submitted. No obligation is taken on by the
 96926:     // connection manager, nor is the submitter obligated to actually submit a
 96926:     // real transaction for this connectionInfo.
 96926:     nsresult SpeculativeConnect(nsHttpConnectionInfo *,
 96926:                                 nsIInterfaceRequestor *,
 96926:                                 nsIEventTarget *);
 96926: 
 43113:     // called when a connection is done processing a transaction.  if the 
 43113:     // connection can be reused then it will be added to the idle list, else
 43113:     // it will be closed.
 43113:     nsresult ReclaimConnection(nsHttpConnection *conn);
 43113: 
 96974:     // called by the main thread to execute the taketransport() logic on the
 96974:     // socket thread after a 101 response has been received and the socket
 96974:     // needs to be transferred to an expectant upgrade listener such as
 96974:     // websockets.
 96974:     nsresult CompleteUpgrade(nsAHttpConnection *aConn,
 96974:                              nsIHttpUpgradeListener *aUpgradeListener);
 96974: 
 43113:     // called to update a parameter after the connection manager has already
 43113:     // been initialized.
 43113:     nsresult UpdateParam(nsParamName name, PRUint16 value);
 43113: 
 84549:     // Lookup/Cancel HTTP->SPDY redirections
 84549:     bool GetSpdyAlternateProtocol(nsACString &key);
 84549:     void ReportSpdyAlternateProtocol(nsHttpConnection *);
 84549:     void RemoveSpdyAlternateProtocol(nsACString &key);
 84549: 
 93840:     // Pipielining Interfaces and Datatypes
 93840: 
 93840:     const static PRUint32 kPipelineInfoTypeMask = 0xffff0000;
 93840:     const static PRUint32 kPipelineInfoIDMask   = ~kPipelineInfoTypeMask;
 93840: 
 93840:     const static PRUint32 kPipelineInfoTypeRed     = 0x00010000;
 93840:     const static PRUint32 kPipelineInfoTypeBad     = 0x00020000;
 93840:     const static PRUint32 kPipelineInfoTypeNeutral = 0x00040000;
 93840:     const static PRUint32 kPipelineInfoTypeGood    = 0x00080000;
 93840: 
 93840:     enum PipelineFeedbackInfoType
 93840:     {
 93840:         // Used when an HTTP response less than 1.1 is received
 93840:         RedVersionTooLow = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0001,
 93840: 
 93840:         // Used when a HTTP Server response header that is on the banned from
 93840:         // pipelining list is received
 93840:         RedBannedServer = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0002,
 93840:     
 93846:         // Used when a response is terminated early, when it fails an
 93846:         // integrity check such as assoc-req or when a 304 contained a Last-Modified
 93846:         // differnet than the entry being validated.
 93840:         RedCorruptedContent = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0004,
 93840: 
 93840:         // Used when a pipeline is only partly satisfied - for instance if the
 93840:         // server closed the connection after responding to the first
 93840:         // request but left some requests unprocessed.
 93840:         RedCanceledPipeline = kPipelineInfoTypeRed | kPipelineInfoTypeBad | 0x0005,
 93840: 
 93840:         // Used when a connection that we expected to stay persistently open
 93840:         // was closed by the server. Not used when simply timed out.
 93840:         BadExplicitClose = kPipelineInfoTypeBad | 0x0003,
 93840: 
 93840:         // Used when there is a gap of around 400 - 1200ms in between data being
 93840:         // read from the server
 93840:         BadSlowReadMinor = kPipelineInfoTypeBad | 0x0006,
 93840: 
 93840:         // Used when there is a gap of > 1200ms in between data being
 93840:         // read from the server
 93840:         BadSlowReadMajor = kPipelineInfoTypeBad | 0x0007,
 93840: 
 93840:         // Used when a response is received that is not framed with either chunked
 93840:         // encoding or a complete content length.
 93840:         BadInsufficientFraming = kPipelineInfoTypeBad | 0x0008,
 93840:         
 93843:         // Used when a very large response is recevied in a potential pipelining
 93843:         // context. Large responses cause head of line blocking.
 93843:         BadUnexpectedLarge = kPipelineInfoTypeBad | 0x000B,
 93843: 
 93840:         // Used when a response is received that has headers that appear to support
 93840:         // pipelining.
 93840:         NeutralExpectedOK = kPipelineInfoTypeNeutral | 0x0009,
 93840: 
 93840:         // Used when a response is received successfully to a pipelined request.
 93840:         GoodCompletedOK = kPipelineInfoTypeGood | 0x000A
 93840:     };
 93840:     
 93840:     // called to provide information relevant to the pipelining manager
 93840:     // may be called from any thread
 93840:     void     PipelineFeedbackInfo(nsHttpConnectionInfo *,
 93840:                                   PipelineFeedbackInfoType info,
 93840:                                   nsHttpConnection *,
 93840:                                   PRUint32);
 93840: 
 93847:     void ReportFailedToProcess(nsIURI *uri);
 93847: 
100626:     // Causes a large amount of connection diagnostic information to be
100626:     // printed to the javascript console
100626:     void PrintDiagnostics();
100626: 
 43113:     //-------------------------------------------------------------------------
 43113:     // NOTE: functions below may be called only on the socket thread.
 43113:     //-------------------------------------------------------------------------
 43113: 
 43113:     // called to force the transaction queue to be processed once more, giving
 43113:     // preference to the specified connection.
 43113:     nsresult ProcessPendingQ(nsHttpConnectionInfo *);
 93840:     bool     ProcessPendingQForEntry(nsHttpConnectionInfo *);
 43113: 
 70873:     // This is used to force an idle connection to be closed and removed from
 70873:     // the idle connection list. It is called when the idle connection detects
 70873:     // that the network peer has closed the transport.
 70873:     nsresult CloseIdleConnection(nsHttpConnection *);
 70873: 
 84549:     // The connection manager needs to know when a normal HTTP connection has been
 84549:     // upgraded to SPDY because the dispatch and idle semantics are a little
 84549:     // bit different.
 84549:     void ReportSpdyConnection(nsHttpConnection *, bool usingSpdy);
 84549: 
 93838:     
 93840:     bool     SupportsPipelining(nsHttpConnectionInfo *);
 93840: 
 43113: private:
 43113:     virtual ~nsHttpConnectionMgr();
 93840: 
 93840:     enum PipeliningState {
 93840:         // Host has proven itself pipeline capable through past experience and
 93840:         // large pipeline depths are allowed on multiple connections.
 93840:         PS_GREEN,
 93840: 
 93840:         // Not enough information is available yet with this host to be certain
 93840:         // of pipeline capability. Small pipelines on a single connection are
 93840:         // allowed in order to decide whether or not to proceed to green.
 93840:         PS_YELLOW,
 93840: 
 93840:         // One or more bad events has happened that indicate that pipelining
 93840:         // to this host (or a particular type of transaction with this host)
 93840:         // is a bad idea. Pipelining is not currently allowed, but time and
 93840:         // other positive experiences will eventually allow it to try again.
 93840:         PS_RED
 93840:     };
 93840:     
 64613:     class nsHalfOpenSocket;
 43113: 
 43113:     // nsConnectionEntry
 43113:     //
 43113:     // mCT maps connection info hash key to nsConnectionEntry object, which
 43113:     // contains list of active and idle connections as well as the list of
 43113:     // pending transactions.
 43113:     //
 93840:     class nsConnectionEntry
 43113:     {
 93840:     public:
 93840:         nsConnectionEntry(nsHttpConnectionInfo *ci);
 84549:         ~nsConnectionEntry();
 43113: 
 43113:         nsHttpConnectionInfo        *mConnInfo;
 43113:         nsTArray<nsHttpTransaction*> mPendingQ;    // pending transaction queue
 43113:         nsTArray<nsHttpConnection*>  mActiveConns; // active connections
 43113:         nsTArray<nsHttpConnection*>  mIdleConns;   // idle persistent connections
 64613:         nsTArray<nsHalfOpenSocket*>  mHalfOpens;
 84549: 
 93840:         // Pipeline depths for various states
 93840:         const static PRUint32 kPipelineUnlimited  = 1024; // fully open - extended green
 93840:         const static PRUint32 kPipelineOpen       = 6;    // 6 on each conn - normal green
 93840:         const static PRUint32 kPipelineRestricted = 2;    // 2 on just 1 conn in yellow
 93840:         
 93840:         nsHttpConnectionMgr::PipeliningState PipelineState();
 93840:         void OnPipelineFeedbackInfo(
 93840:             nsHttpConnectionMgr::PipelineFeedbackInfoType info,
 93840:             nsHttpConnection *, PRUint32);
 93840:         bool SupportsPipelining();
 93840:         PRUint32 MaxPipelineDepth(nsAHttpTransaction::Classifier classification);
 93840:         void CreditPenalty();
 93840: 
 93840:         nsHttpConnectionMgr::PipeliningState mPipelineState;
 93840: 
 93840:         void SetYellowConnection(nsHttpConnection *);
 93840:         void OnYellowComplete();
 93840:         PRUint32                  mYellowGoodEvents;
 93840:         PRUint32                  mYellowBadEvents;
 93840:         nsHttpConnection         *mYellowConnection;
 93840: 
 93840:         // initialGreenDepth is the max depth of a pipeline when you first
 93840:         // transition to green. Normally this is kPipelineOpen, but it can
 93840:         // be kPipelineUnlimited in aggressive mode.
 93840:         PRUint32                  mInitialGreenDepth;
 93840: 
 93840:         // greenDepth is the current max allowed depth of a pipeline when
 93840:         // in the green state. Normally this starts as kPipelineOpen and
 93840:         // grows to kPipelineUnlimited after a pipeline of depth 3 has been
 93840:         // successfully transacted.
 93840:         PRUint32                  mGreenDepth;
 93840: 
 93840:         // pipeliningPenalty is the current amount of penalty points this host
 93840:         // entry has earned for participating in events that are not conducive
 93840:         // to good pipelines - such as head of line blocking, canceled pipelines,
 93840:         // etc.. penalties are paid back either through elapsed time or simply
 93840:         // healthy transactions. Having penalty points means that this host is
 93840:         // not currently eligible for pipelines.
 93840:         PRInt16                   mPipeliningPenalty;
 93840: 
 93840:         // some penalty points only apply to particular classifications of
 93840:         // transactions - this allows a server that perhaps has head of line
 93840:         // blocking problems on CGI queries to still serve JS pipelined.
 93840:         PRInt16                   mPipeliningClassPenalty[nsAHttpTransaction::CLASS_MAX];
 93840: 
 93840:         // for calculating penalty repair credits
 93840:         mozilla::TimeStamp        mLastCreditTime;
 93840: 
 84549:         // Spdy sometimes resolves the address in the socket manager in order
 84549:         // to re-coalesce sharded HTTP hosts. The dotted decimal address is
 84549:         // combined with the Anonymous flag from the connection information
 84549:         // to build the hash key for hosts in the same ip pool.
 84549:         //
 84549:         // When a set of hosts are coalesced together one of them is marked
 84549:         // mSpdyPreferred. The mapping is maintained in the connection mananger
 84549:         // mSpdyPreferred hash.
 84549:         //
 84549:         nsCString mCoalescingKey;
 84549: 
 88249:         // To have the UsingSpdy flag means some host with the same connection
 99497:         // entry has done NPN=spdy/* at some point. It does not mean every
 88249:         // connection is currently using spdy.
 84549:         bool mUsingSpdy;
 84549: 
 88249:         // mTestedSpdy is set after NPN negotiation has occurred and we know
 88249:         // with confidence whether a host speaks spdy or not (which is reflected
 88249:         // in mUsingSpdy). Before mTestedSpdy is set, handshake parallelism is
 88249:         // minimized so that we can multiplex on a single spdy connection.
 84549:         bool mTestedSpdy;
 88249: 
 84549:         bool mSpdyPreferred;
 43113:     };
 43113: 
 43113:     // nsConnectionHandle
 43113:     //
 43113:     // thin wrapper around a real connection, used to keep track of references
 43113:     // to the connection to determine when the connection may be reused.  the
 43113:     // transaction (or pipeline) owns a reference to this handle.  this extra
 43113:     // layer of indirection greatly simplifies consumer code, avoiding the
 43113:     // need for consumer code to know when to give the connection back to the
 43113:     // connection manager.
 43113:     //
 43113:     class nsConnectionHandle : public nsAHttpConnection
 43113:     {
 43113:     public:
 43113:         NS_DECL_ISUPPORTS
 98400:         NS_DECL_NSAHTTPCONNECTION(mConn)
 43113: 
 43113:         nsConnectionHandle(nsHttpConnection *conn) { NS_ADDREF(mConn = conn); }
 43113:         virtual ~nsConnectionHandle();
 43113: 
 43113:         nsHttpConnection *mConn;
 43113:     };
 43113: 
 64613:     // nsHalfOpenSocket is used to hold the state of an opening TCP socket
 64613:     // while we wait for it to establish and bind it to a connection
 64613: 
 64613:     class nsHalfOpenSocket : public nsIOutputStreamCallback,
 64613:                              public nsITransportEventSink,
 64613:                              public nsIInterfaceRequestor,
 83174:                              public nsITimerCallback
 64613:     {
 64613:     public:
 64613:         NS_DECL_ISUPPORTS
 64613:         NS_DECL_NSIOUTPUTSTREAMCALLBACK
 64613:         NS_DECL_NSITRANSPORTEVENTSINK
 64613:         NS_DECL_NSIINTERFACEREQUESTOR
 64613:         NS_DECL_NSITIMERCALLBACK
 64613: 
 64613:         nsHalfOpenSocket(nsConnectionEntry *ent,
 96926:                          nsAHttpTransaction *trans,
 96926:                          PRUint8 caps);
 64613:         ~nsHalfOpenSocket();
 64613:         
 64613:         nsresult SetupStreams(nsISocketTransport **,
 64613:                               nsIAsyncInputStream **,
 72963:                               nsIAsyncOutputStream **,
 79445:                               bool isBackup);
 64613:         nsresult SetupPrimaryStreams();
 64613:         nsresult SetupBackupStreams();
 64613:         void     SetupBackupTimer();
 81271:         void     CancelBackupTimer();
 64613:         void     Abandon();
 64613:         
 96926:         nsAHttpTransaction *Transaction() { return mTransaction; }
 96926: 
 96926:         bool IsSpeculative() { return mSpeculative; }
 96926:         void SetSpeculative(bool val) { mSpeculative = val; }
 69147: 
 99120:         bool HasConnected() { return mHasConnected; }
 99120: 
100626:         void PrintDiagnostics(nsCString &log);
 64613:     private:
 64613:         nsConnectionEntry              *mEnt;
 96926:         nsRefPtr<nsAHttpTransaction>   mTransaction;
 64613:         nsCOMPtr<nsISocketTransport>   mSocketTransport;
 64613:         nsCOMPtr<nsIAsyncOutputStream> mStreamOut;
 64613:         nsCOMPtr<nsIAsyncInputStream>  mStreamIn;
 96926:         PRUint8                        mCaps;
 96926: 
 96926:         // mSpeculative is set if the socket was created from
 96926:         // SpeculativeConnect(). It is cleared when a transaction would normally
 96926:         // start a new connection from scratch but instead finds this one in
 96926:         // the half open list and claims it for its own use. (which due to
 96926:         // the vagaries of scheduling from the pending queue might not actually
 96926:         // match up - but it prevents a speculative connection from opening
 96926:         // more connections that are needed.)
 96926:         bool                           mSpeculative;
 64613: 
 93840:         mozilla::TimeStamp             mPrimarySynStarted;
 93840:         mozilla::TimeStamp             mBackupSynStarted;
 93840: 
 64613:         // for syn retry
 64613:         nsCOMPtr<nsITimer>             mSynTimer;
 64613:         nsCOMPtr<nsISocketTransport>   mBackupTransport;
 64613:         nsCOMPtr<nsIAsyncOutputStream> mBackupStreamOut;
 64613:         nsCOMPtr<nsIAsyncInputStream>  mBackupStreamIn;
 99120: 
 99120:         bool                           mHasConnected;
 64613:     };
 64613:     friend class nsHalfOpenSocket;
 64613: 
 43113:     //-------------------------------------------------------------------------
 69142:     // NOTE: these members may be accessed from any thread (use mReentrantMonitor)
 43113:     //-------------------------------------------------------------------------
 43113: 
 43113:     PRInt32                      mRef;
 69142:     mozilla::ReentrantMonitor    mReentrantMonitor;
 43113:     nsCOMPtr<nsIEventTarget>     mSocketThreadTarget;
 43113: 
 43113:     // connection limits
 43113:     PRUint16 mMaxConns;
 43113:     PRUint16 mMaxConnsPerHost;
 43113:     PRUint16 mMaxConnsPerProxy;
 43113:     PRUint16 mMaxPersistConnsPerHost;
 43113:     PRUint16 mMaxPersistConnsPerProxy;
 43113:     PRUint16 mMaxRequestDelay; // in seconds
 43113:     PRUint16 mMaxPipelinedRequests;
 93840:     PRUint16 mMaxOptimisticPipelinedRequests;
 79445:     bool mIsShuttingDown;
 58439: 
 43113:     //-------------------------------------------------------------------------
 43113:     // NOTE: these members are only accessed on the socket transport thread
 43113:     //-------------------------------------------------------------------------
 43113: 
 74833:     static PLDHashOperator ProcessOneTransactionCB(const nsACString &, nsAutoPtr<nsConnectionEntry> &, void *);
 64613: 
 74833:     static PLDHashOperator PruneDeadConnectionsCB(const nsACString &, nsAutoPtr<nsConnectionEntry> &, void *);
 74833:     static PLDHashOperator ShutdownPassCB(const nsACString &, nsAutoPtr<nsConnectionEntry> &, void *);
 74833:     static PLDHashOperator PurgeExcessIdleConnectionsCB(const nsACString &, nsAutoPtr<nsConnectionEntry> &, void *);
 74833:     static PLDHashOperator ClosePersistentConnectionsCB(const nsACString &, nsAutoPtr<nsConnectionEntry> &, void *);
 79445:     bool     ProcessPendingQForEntry(nsConnectionEntry *);
 93840:     bool     IsUnderPressure(nsConnectionEntry *ent,
 93840:                              nsHttpTransaction::Classifier classification);
 79445:     bool     AtActiveConnectionLimit(nsConnectionEntry *, PRUint8 caps);
 93840:     nsresult TryDispatchTransaction(nsConnectionEntry *ent,
 93840:                                     bool onlyReusedConnection,
 93840:                                     nsHttpTransaction *trans);
 93840:     nsresult DispatchTransaction(nsConnectionEntry *,
 93840:                                  nsHttpTransaction *,
 93840:                                  nsHttpConnection *);
 96926:     nsresult DispatchAbstractTransaction(nsConnectionEntry *,
 96926:                                          nsAHttpTransaction *,
 96926:                                          PRUint8,
 96926:                                          nsHttpConnection *,
 96926:                                          PRInt32);
 93840:     nsresult BuildPipeline(nsConnectionEntry *,
 93840:                            nsAHttpTransaction *,
 93840:                            nsHttpPipeline **);
 96926:     bool     RestrictConnections(nsConnectionEntry *);
 43113:     nsresult ProcessNewTransaction(nsHttpTransaction *);
 58439:     nsresult EnsureSocketThreadTargetIfOnline();
 74259:     void     ClosePersistentConnections(nsConnectionEntry *ent);
 96926:     nsresult CreateTransport(nsConnectionEntry *, nsAHttpTransaction *,
 96926:                              PRUint8, bool);
 64613:     void     AddActiveConn(nsHttpConnection *, nsConnectionEntry *);
 64613:     void     StartedConnect();
 64613:     void     RecvdConnect();
 43113: 
 96926:     nsConnectionEntry *GetOrCreateConnectionEntry(nsHttpConnectionInfo *);
 96926: 
 93840:     bool     MakeNewConnection(nsConnectionEntry *ent,
 93840:                                nsHttpTransaction *trans);
 93840:     bool     AddToShortestPipeline(nsConnectionEntry *ent,
 93840:                                    nsHttpTransaction *trans,
 93840:                                    nsHttpTransaction::Classifier classification,
 93840:                                    PRUint16 depthLimit);
 93840: 
 84549:     // Manage the preferred spdy connection entry for this address
 88249:     nsConnectionEntry *GetSpdyPreferredEnt(nsConnectionEntry *aOriginalEntry);
 88249:     void               RemoveSpdyPreferredEnt(nsACString &aDottedDecimal);
 84549:     nsHttpConnection  *GetSpdyPreferredConn(nsConnectionEntry *ent);
 84549:     nsDataHashtable<nsCStringHashKey, nsConnectionEntry *>   mSpdyPreferredHash;
 84549:     nsConnectionEntry *LookupConnectionEntry(nsHttpConnectionInfo *ci,
 84549:                                              nsHttpConnection *conn,
 84549:                                              nsHttpTransaction *trans);
 84549: 
 84549:     void               ProcessSpdyPendingQ(nsConnectionEntry *ent);
 88249:     void               ProcessAllSpdyPendingQ();
 84549:     static PLDHashOperator ProcessSpdyPendingQCB(
 84549:         const nsACString &key, nsAutoPtr<nsConnectionEntry> &ent,
 84549:         void *closure);
 84549: 
 43113:     // message handlers have this signature
 43113:     typedef void (nsHttpConnectionMgr:: *nsConnEventHandler)(PRInt32, void *);
 43113: 
 43113:     // nsConnEvent
 43113:     //
 43113:     // subclass of nsRunnable used to marshall events to the socket transport
 43113:     // thread.  this class is used to implement PostEvent.
 43113:     //
 43113:     class nsConnEvent;
 43113:     friend class nsConnEvent;
 43113:     class nsConnEvent : public nsRunnable
 43113:     {
 43113:     public:
 43113:         nsConnEvent(nsHttpConnectionMgr *mgr,
 43113:                     nsConnEventHandler handler,
 43113:                     PRInt32 iparam,
 43113:                     void *vparam)
 43113:             : mMgr(mgr)
 43113:             , mHandler(handler)
 43113:             , mIParam(iparam)
 43113:             , mVParam(vparam)
 43113:         {
 43113:             NS_ADDREF(mMgr);
 43113:         }
 43113: 
 43113:         NS_IMETHOD Run()
 43113:         {
 43113:             (mMgr->*mHandler)(mIParam, mVParam);
 43113:             return NS_OK;
 43113:         }
 43113: 
 43113:     private:
 43113:         virtual ~nsConnEvent()
 43113:         {
 43113:             NS_RELEASE(mMgr);
 43113:         }
 43113: 
 43113:         nsHttpConnectionMgr *mMgr;
 43113:         nsConnEventHandler   mHandler;
 43113:         PRInt32              mIParam;
 43113:         void                *mVParam;
 43113:     };
 43113: 
 43113:     nsresult PostEvent(nsConnEventHandler  handler,
 43113:                        PRInt32             iparam = 0,
 43113:                        void               *vparam = nsnull);
 43113: 
 43113:     // message handlers
 43113:     void OnMsgShutdown             (PRInt32, void *);
 43113:     void OnMsgNewTransaction       (PRInt32, void *);
 43113:     void OnMsgReschedTransaction   (PRInt32, void *);
 43113:     void OnMsgCancelTransaction    (PRInt32, void *);
 43113:     void OnMsgProcessPendingQ      (PRInt32, void *);
 43113:     void OnMsgPruneDeadConnections (PRInt32, void *);
 96926:     void OnMsgSpeculativeConnect   (PRInt32, void *);
 43113:     void OnMsgReclaimConnection    (PRInt32, void *);
 96974:     void OnMsgCompleteUpgrade      (PRInt32, void *);
 43113:     void OnMsgUpdateParam          (PRInt32, void *);
 74328:     void OnMsgClosePersistentConnections (PRInt32, void *);
 93840:     void OnMsgProcessFeedback      (PRInt32, void *);
 43113: 
 55822:     // Total number of active connections in all of the ConnectionEntry objects
 55822:     // that are accessed from mCT connection table.
 43113:     PRUint16 mNumActiveConns;
 55822:     // Total number of idle connections in all of the ConnectionEntry objects
 55822:     // that are accessed from mCT connection table.
 43113:     PRUint16 mNumIdleConns;
 43113: 
 55822:     // Holds time in seconds for next wake-up to prune dead connections. 
 55822:     PRUint64 mTimeOfNextWakeUp;
 55822:     // Timer for next pruning of dead connections.
 55822:     nsCOMPtr<nsITimer> mTimer;
 55822: 
 90871:     // A 1s tick to call nsHttpConnection::ReadTimeoutTick on
100923:     // active http/1 connections. Disabled when there are no
100923:     // active connections.
 90871:     nsCOMPtr<nsITimer> mReadTimeoutTick;
 90871:     bool mReadTimeoutTickArmed;
 90871: 
 43113:     //
 43113:     // the connection table
 43113:     //
 43113:     // this table is indexed by connection key.  each entry is a
 74833:     // nsConnectionEntry object.
 43113:     //
 74833:     nsClassHashtable<nsCStringHashKey, nsConnectionEntry> mCT;
 84549: 
 99497:     // mAlternateProtocolHash is used only for spdy/* upgrades for now
 91222:     // protected by the monitor
 91222:     nsTHashtable<nsCStringHashKey> mAlternateProtocolHash;
 91222:     static PLDHashOperator TrimAlternateProtocolHash(nsCStringHashKey *entry,
 84549:                                                      void *closure);
 90871:     // Read Timeout Tick handlers
 90871:     void ActivateTimeoutTick();
 90871:     void ReadTimeoutTick();
 90871:     static PLDHashOperator ReadTimeoutTickCB(const nsACString &key,
 90871:                                              nsAutoPtr<nsConnectionEntry> &ent,
 90871:                                              void *closure);
100626: 
100626:     // For diagnostics
100626:     void OnMsgPrintDiagnostics(PRInt32, void *);
100626:     static PLDHashOperator PrintDiagnosticsCB(const nsACString &key,
100626:                                               nsAutoPtr<nsConnectionEntry> &ent,
100626:                                               void *closure);
100626:     nsCString mLogData;
 43113: };
 43113: 
 43113: #endif // !nsHttpConnectionMgr_h__
