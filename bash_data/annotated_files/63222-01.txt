    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set ts=2 sts=2 sw=2 et cin:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Jacek Piskozub <piskozub@iopan.gda.pl>
    1:  *   Leon Sha <leon.sha@sun.com>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Christian Biesinger <cbiesinger@web.de>
  130:  *   Josh Aas <josh@mozilla.com>
54309:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering objects for replaced elements implemented by a plugin */
    1: 
50722: #ifdef MOZ_WIDGET_QT
50722: #include <QWidget>
50722: #include <QKeyEvent>
50722: #ifdef MOZ_X11
50722: #include <QX11Info>
50722: #endif
57889: #undef slots
50722: #endif
50722: 
50668: #ifdef MOZ_IPC
50668: #include "mozilla/plugins/PluginMessageUtils.h"
50668: #endif
50668: 
50669: #ifdef MOZ_X11
50669: #include <cairo-xlib.h>
50669: #include "gfxXlibSurface.h"
50669: /* X headers suck */
50669: enum { XKeyPress = KeyPress };
50669: #ifdef KeyPress
50669: #undef KeyPress
50669: #endif
50671: #endif
50669: 
    1: #include "nscore.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIDOMKeyListener.h"
20592: #include "nsIDOMDragEvent.h"
    1: #include "nsIPluginHost.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "prmem.h"
    1: #include "nsGkAtoms.h"
    4: #include "nsIAppShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIPluginInstanceOwner.h"
29840: #include "nsIPluginInstance.h"
29840: #include "nsIPluginTagInfo.h"
    1: #include "plstr.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIScrollPositionListener.h"
    1: #include "nsITimer.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLEmbedElement.h"
    1: #include "nsIDOMHTMLAppletElement.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseMotionListener.h"
    1: #include "nsIDOMFocusListener.h"
    1: #include "nsIDOMContextMenuListener.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIPluginWidget.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRenderingContext.h"
    1: #include "npapi.h"
    1: #include "nsTransform2D.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsPIDOMWindow.h"
35171: #include "nsIDOMElement.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsAttrName.h"
    1: #include "nsDataHashtable.h"
13098: #include "nsDOMClassInfo.h"
29018: #include "nsFocusManager.h"
30519: #include "nsLayoutUtils.h"
30522: #include "nsFrameManager.h"
30522: #include "nsComponentManagerUtils.h"
35180: #include "nsIObserverService.h"
37067: #include "nsIScrollableFrame.h"
    1: 
    1: // headers for plugin scriptability
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsIClassInfo.h"
35171: #include "nsIDOMClientRect.h"
    1: 
    1: #include "nsObjectFrame.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsPluginNativeWindow.h"
    1: #include "nsIPluginDocument.h"
62646: #include "FrameLayerBuilder.h"
    1: 
 4577: #include "nsThreadUtils.h"
 4577: 
    1: #include "gfxContext.h"
54223: #include "gfxPlatform.h"
    1: 
11703: #ifdef XP_WIN
11703: #include "gfxWindowsNativeDrawing.h"
21080: #include "gfxWindowsSurface.h"
11703: #endif
11703: 
34217: #include "gfxImageSurface.h"
54223: #include "gfxUtils.h"
54223: #include "Layers.h"
62699: #include "ReadbackLayer.h"
34217: 
    1: // accessibility support
    1: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
    1: #endif
    1: 
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG 1 /* Allow logging in the release build */
    1: #endif /* MOZ_LOGGING */
    1: #include "prlog.h"
    1: 
    1: #include <errno.h>
    1: 
    1: #include "nsContentCID.h"
    1: static NS_DEFINE_CID(kRangeCID, NS_RANGE_CID);
13537: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
11944: #ifdef XP_MACOSX
11944: #include "gfxQuartzNativeDrawing.h"
32019: #include "nsPluginUtilsOSX.h"
41029: #include "nsCoreAnimationSupport.h"
11944: #endif
11944: 
50671: #ifdef MOZ_X11
39239: #if (MOZ_PLATFORM_MAEMO == 5) && defined(MOZ_WIDGET_GTK2)
25500: #define MOZ_COMPOSITED_PLUGINS 1
39239: #define MOZ_USE_IMAGE_EXPOSE   1
35171: #include <X11/Xutil.h>
35171: #include <X11/Xatom.h>
35171: #include <X11/extensions/XShm.h>
35171: #include <sys/ipc.h>
35171: #include <sys/shm.h>
25500: #endif
25500: 
 3059: #ifdef MOZ_WIDGET_GTK2
23281: #include <gdk/gdk.h>
 3059: #include <gdk/gdkx.h>
25500: #include <gtk/gtk.h>
47118: #include "gfxXlibNativeRenderer.h"
 3059: #endif
 3059: #endif
    1: 
16959: #ifdef MOZ_WIDGET_QT
16959: #include "gfxQtNativeRenderer.h"
43912: #endif
43912: 
41059: #ifdef MOZ_X11
43912: #include "mozilla/X11Util.h"
43912: using mozilla::DefaultXDisplay;
16959: #endif
16959: 
    1: #ifdef XP_WIN
    1: #include <wtypes.h>
    1: #include <winuser.h>
    1: #endif
    1: 
32955: #ifdef XP_OS2
32955: #define INCL_PM
32955: #define INCL_GPI
32955: #include <os2.h>
32955: #endif
32955: 
    1: #ifdef CreateEvent // Thank you MS.
    1: #undef CreateEvent
    1: #endif
    1: 
    1: #ifdef PR_LOGGING 
    1: static PRLogModuleInfo *nsObjectFrameLM = PR_NewLogModule("nsObjectFrame");
    1: #endif /* PR_LOGGING */
    1: 
36227: #if defined(XP_MACOSX) && !defined(NP_NO_CARBON)
36227: #define MAC_CARBON_PLUGINS
36227: #endif
    1: 
62699: using namespace mozilla;
62717: #ifdef MOZ_IPC
62699: using namespace mozilla::plugins;
62717: #endif
54223: using namespace mozilla::layers;
54223: 
    1: // special class for handeling DOM context menu events because for
    1: // some reason it starves other mouse events if implemented on the
    1: // same class
32297: class nsPluginDOMContextMenuListener : public nsIDOMContextMenuListener
    1: {
    1: public:
    1:   nsPluginDOMContextMenuListener();
    1:   virtual ~nsPluginDOMContextMenuListener();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_IMETHOD ContextMenu(nsIDOMEvent* aContextMenuEvent);
    1:   
    1:   nsresult Init(nsIContent* aContent);
    1:   nsresult Destroy(nsIContent* aContent);
    1:   
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent)
    1:   {
    1:     return NS_OK;
    1:   }
    1:   nsEventStatus ProcessEvent(const nsGUIEvent& anEvent)
    1:   {
    1:     return nsEventStatus_eConsumeNoDefault;
    1:   }
    1: };
    1: 
    1: 
    1: class nsPluginInstanceOwner : public nsIPluginInstanceOwner,
58796:                               public nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH,
29952:                               public nsIPluginTagInfo,
    1:                               public nsIDOMMouseListener,
    1:                               public nsIDOMMouseMotionListener,
    1:                               public nsIDOMKeyListener,
    1:                               public nsIDOMFocusListener,
20592:                               public nsIScrollPositionListener
    1: {
    1: public:
    1:   nsPluginInstanceOwner();
    1:   virtual ~nsPluginInstanceOwner();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   //nsIPluginInstanceOwner interface
34262:   NS_DECL_NSIPLUGININSTANCEOWNER
58796:   NS_DECL_NSIPLUGININSTANCEOWNER_MOZILLA_2_0_BRANCH
    1: 
36766:   NS_IMETHOD GetURL(const char *aURL, const char *aTarget,
36766:                     nsIInputStream *aPostStream, 
36766:                     void *aHeadersData, PRUint32 aHeadersDataLen);
    1: 
    1:   NS_IMETHOD ShowStatus(const PRUnichar *aStatusMsg);
    1: 
32799:   NPError    ShowNativeContextMenu(NPMenu* menu, void* event);
32019: 
32019:   NPBool     ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                           double *destX, double *destY, NPCoordinateSpace destSpace);
32019: 
    1:   //nsIPluginTagInfo interface
34262:   NS_DECL_NSIPLUGINTAGINFO
    1: 
18407:   // nsIDOMMouseListener interfaces 
    1:   NS_IMETHOD MouseDown(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseUp(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseClick(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseDblClick(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseOver(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseOut(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);     
    1: 
18405:   // nsIDOMMouseMotionListener interfaces
    1:   NS_IMETHOD MouseMove(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragMove(nsIDOMEvent* aMouseEvent) { return NS_OK; }
    1: 
    1:   // nsIDOMKeyListener interfaces
    1:   NS_IMETHOD KeyDown(nsIDOMEvent* aKeyEvent);
    1:   NS_IMETHOD KeyUp(nsIDOMEvent* aKeyEvent);
    1:   NS_IMETHOD KeyPress(nsIDOMEvent* aKeyEvent);
    1: 
32297:   // nsIDOMFocusListener interfaces
    1:   NS_IMETHOD Focus(nsIDOMEvent * aFocusEvent);
    1:   NS_IMETHOD Blur(nsIDOMEvent * aFocusEvent);
    1: 
    1:   nsresult Destroy();  
    1: 
 4577:   void PrepareToStop(PRBool aDelayedStop);
 4577:   
 3059: #ifdef XP_WIN
21080:   void Paint(const RECT& aDirty, HDC aDC);
 3059: #elif defined(XP_MACOSX)
34717:   void Paint(const gfxRect& aDirtyRect, CGContextRef cgContext);  
39757:   void RenderCoreAnimation(CGContextRef aCGContext, int aWidth, int aHeight);
62474:   void DoCocoaEventDrawRect(const gfxRect& aDrawRect, CGContextRef cgContext);
47118: #elif defined(MOZ_X11)
15688:   void Paint(gfxContext* aContext,
15688:              const gfxRect& aFrameRect,
15688:              const gfxRect& aDirtyRect);
12859: #elif defined(XP_OS2)
12859:   void Paint(const nsRect& aDirtyRect, HPS aHPS);
 3059: #endif
    1: 
36227: #ifdef MAC_CARBON_PLUGINS
    1:   void CancelTimer();
36227:   void StartTimer(PRBool isVisible);
36227: #endif
36227:   void SendIdleEvent();
    1: 
    1:   // nsIScrollPositionListener interface
37871:   virtual void ScrollPositionWillChange(nscoord aX, nscoord aY);
37871:   virtual void ScrollPositionDidChange(nscoord aX, nscoord aY);
    1: 
    1:   //locals
    1: 
    1:   nsresult Init(nsPresContext* aPresContext, nsObjectFrame* aFrame,
    1:                 nsIContent* aContent);
    1: 
37446:   void* GetPluginPortFromWidget();
32799:   void ReleasePluginPort(void* pluginPort);
    1: 
    1:   void SetPluginHost(nsIPluginHost* aHost);
    1: 
32297:   nsEventStatus ProcessEvent(const nsGUIEvent & anEvent);
32297: 
    1: #ifdef XP_MACOSX
  130:   NPDrawingModel GetDrawingModel();
62471:   PRBool IsRemoteDrawingCoreAnimation();
32019:   NPEventModel GetEventModel();
39757:   static void CARefresh(nsITimer *aTimer, void *aClosure);
39757:   static void AddToCARefreshTimer(nsPluginInstanceOwner *aPluginInstance);
39757:   static void RemoveFromCARefreshTimer(nsPluginInstanceOwner *aPluginInstance);
42504:   void SetupCARefresh();
32019:   void* FixUpPluginWindow(PRInt32 inPaintState);
56652:   void HidePluginWindow();
21108:   // Set a flag that (if true) indicates the plugin port info has changed and
21108:   // SetWindow() needs to be called.
21108:   void SetPluginPortChanged(PRBool aState) { mPluginPortChanged = aState; }
21108:   // Return a pointer to the internal nsPluginPort structure that's used to
21108:   // store a copy of plugin port info and to detect when it's been changed.
32799:   void* GetPluginPortCopy();
21108:   // Set plugin port info in the plugin (in the 'window' member of the
32799:   // NPWindow structure passed to the plugin by SetWindow()) and set a
21108:   // flag (mPluginPortChanged) to indicate whether or not this info has
21108:   // changed, and SetWindow() needs to be called again.
32799:   void* SetPluginPortAndDetectChange();
21108:   // Flag when we've set up a Thebes (and CoreGraphics) context in
21108:   // nsObjectFrame::PaintPlugin().  We need to know this in
21108:   // FixUpPluginWindow() (i.e. we need to know when FixUpPluginWindow() has
21108:   // been called from nsObjectFrame::PaintPlugin() when we're using the
21108:   // CoreGraphics drawing model).
21108:   void BeginCGPaint();
21108:   void EndCGPaint();
57224: #else // XP_MACOSX
57514:   void UpdateWindowPositionAndClipRect(PRBool aSetWindow);
58796:   void CallSetWindow();
57224:   void UpdateWindowVisibility(PRBool aVisible);
57224: #endif // XP_MACOSX
    1: 
 4577:   void SetOwner(nsObjectFrame *aOwner)
 4577:   {
34679:     mObjectFrame = aOwner;
 4577:   }
 4577: 
13537:   PRUint32 GetLastEventloopNestingLevel() const {
13537:     return mLastEventloopNestingLevel; 
13537:   }
13537: 
24543:   static PRUint32 GetEventloopNestingLevel();
24543:       
13537:   void ConsiderNewEventloopNestingLevel() {
24543:     PRUint32 currentLevel = GetEventloopNestingLevel();
24543: 
13537:     if (currentLevel < mLastEventloopNestingLevel) {
13537:       mLastEventloopNestingLevel = currentLevel;
13537:     }
13537:   }
13537: 
14390:   const char* GetPluginName()
14390:   {
14390:     if (mInstance && mPluginHost) {
15698:       const char* name = NULL;
29919:       if (NS_SUCCEEDED(mPluginHost->GetPluginName(mInstance, &name)) && name)
14390:         return name;
14390:     }
14390:     return "";
14390:   }
14390: 
47115: #ifdef MOZ_X11
47115:   void GetPluginDescription(nsACString& aDescription)
47115:   {
47115:     aDescription.Truncate();
47115:     if (mInstance && mPluginHost) {
47115:       nsCOMPtr<nsIPluginTag> pluginTag;
47115:       mPluginHost->GetPluginTagForInstance(mInstance,
47115:                                            getter_AddRefs(pluginTag));
47115:       if (pluginTag) {
47115:         pluginTag->GetDescription(aDescription);
47115:       }
47115:     }
47115:   }
47115: #endif
47115: 
22788:   PRBool SendNativeEvents()
22788:   {
22788: #ifdef XP_WIN
37301:     return mPluginWindow->type == NPWindowTypeDrawable &&
37301:            MatchPluginName("Shockwave Flash");
41061: #elif defined(MOZ_X11) || defined(XP_MACOSX)
36763:     return PR_TRUE;
22788: #else
22788:     return PR_FALSE;
22788: #endif
22788:   }
22788: 
22788:   PRBool MatchPluginName(const char *aPluginName)
22788:   {
22788:     return strncmp(GetPluginName(), aPluginName, strlen(aPluginName)) == 0;
22788:   }
22788: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35171:   nsresult SetAbsoluteScreenPosition(nsIDOMElement* element,
35171:                                      nsIDOMClientRect* position,
35171:                                      nsIDOMClientRect* clip);
35171: #endif
35171: 
58634:   void NotifyPaintWaiter(nsDisplayListBuilder* aBuilder);
54223:   // Return true if we set image with valid surface
54223:   PRBool SetCurrentImage(ImageContainer* aContainer);
62982:   /**
62982:    * Returns the bounds of the current async-rendered surface. This can only
62982:    * change in response to messages received by the event loop (i.e. not during
62982:    * painting).
62982:    */
62982:   nsIntSize GetCurrentImageSize();
54223: 
62704:   // Methods to update the background image we send to async plugins.
62704:   // The eventual target of these operations is PluginInstanceParent,
62704:   // but it takes several hops to get there.
62704:   void SetBackgroundUnknown();
62704:   already_AddRefed<gfxContext> BeginUpdateBackground(const nsIntRect& aRect);
62704:   void EndUpdateBackground(gfxContext* aContext, const nsIntRect& aRect);
62699: 
62474:   PRBool UseAsyncRendering()
54223:   {
54899:     PRBool useAsyncRendering;
54899:     return (mInstance &&
54899:             NS_SUCCEEDED(mInstance->UseAsyncPainting(&useAsyncRendering)) &&
54899:             useAsyncRendering &&
54223:             (!mPluginWindow ||
54223:              mPluginWindow->type == NPWindowTypeDrawable));
54223:   }
54223: 
    1: private:
62473: 
54223:   // return FALSE if LayerSurface dirty (newly created and don't have valid plugin content yet)
54223:   PRBool IsUpToDate()
54223:   {
62983:     nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = do_QueryInterface(mInstance);
62983:     if (!inst)
62473:       return PR_FALSE;
62983: 
62983:     nsIntSize size;
62983:     return NS_SUCCEEDED(inst->GetImageSize(&size)) &&
62983:            size == nsIntSize(mPluginWindow->width, mPluginWindow->height);
54223:   }
54223: 
62704:   already_AddRefed<nsIPluginInstance_MOZILLA_2_0_BRANCH>
62704:   GetInstance()
62704:   {
62704:     nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = do_QueryInterface(mInstance);
62704:     return inst.forget();
62704:   }
62704: 
    1:   void FixUpURLS(const nsString &name, nsAString &value);
    1: 
    1:   nsPluginNativeWindow       *mPluginWindow;
    1:   nsCOMPtr<nsIPluginInstance> mInstance;
34679:   nsObjectFrame              *mObjectFrame; // owns nsPluginInstanceOwner
    1:   nsCOMPtr<nsIContent>        mContent;
    1:   nsCString                   mDocumentBase;
    1:   char                       *mTagText;
    1:   nsCOMPtr<nsIWidget>         mWidget;
    1:   nsCOMPtr<nsIPluginHost>     mPluginHost;
13537: 
21108: #ifdef XP_MACOSX
32799:   NP_CGContext                              mCGPluginPortCopy;
43652: #ifndef NP_NO_QUICKDRAW
32799:   NP_Port                                   mQDPluginPortCopy;
43652: #endif
21108:   PRInt32                                   mInCGPaintLevel;
42504:   nsIOSurface                              *mIOSurface;
39757:   nsCARenderer                              mCARenderer;
39757:   static nsCOMPtr<nsITimer>                *sCATimer;
39757:   static nsTArray<nsPluginInstanceOwner*>  *sCARefreshListeners;
41061:   PRBool                                    mSentInitialTopLevelWindowEvent;
21108: #endif
21108: 
13537:   // Initially, the event loop nesting level we were created on, it's updated
13537:   // if we detect the appshell is on a lower level as long as we're not stopped.
13537:   // We delay DoStopPlugin() until the appshell reaches this level or lower.
13537:   PRUint32                    mLastEventloopNestingLevel;
    1:   PRPackedBool                mContentFocused;
    1:   PRPackedBool                mWidgetVisible;    // used on Mac to store our widget's visible state
47115: #ifdef XP_MACOSX
21108:   PRPackedBool                mPluginPortChanged;
47115: #endif
47115: #ifdef MOZ_X11
47115:   // Used with windowless plugins only, initialized in CreateWidget().
47115:   PRPackedBool                mFlash10Quirks;
47115: #endif
57224:   PRPackedBool                mPluginWindowVisible;
 4577: 
 4577:   // If true, destroy the widget on destruction. Used when plugin stop
 4577:   // is being delayed to a safer point in time.
 4577:   PRPackedBool                mDestroyWidget;
    1:   PRUint16          mNumCachedAttrs;
    1:   PRUint16          mNumCachedParams;
    1:   char              **mCachedAttrParamNames;
    1:   char              **mCachedAttrParamValues;
    1: 
25500: #ifdef MOZ_COMPOSITED_PLUGINS
25500:   nsIntPoint        mLastPoint;
25500: #endif
25500: 
34717: #ifdef XP_MACOSX
34717:   NPEventModel mEventModel;
34717: #endif
34717: 
12417:   // pointer to wrapper for nsIDOMContextMenuListener
12417:   nsRefPtr<nsPluginDOMContextMenuListener> mCXMenuListener;
    1: 
    1:   nsresult DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent);
    1:   nsresult DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent);
    1:   nsresult DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent);
    1: 
    1:   nsresult EnsureCachedAttrParamArrays();
 3059: 
25500: #ifdef MOZ_COMPOSITED_PLUGINS
25500:   nsEventStatus ProcessEventX11Composited(const nsGUIEvent & anEvent);
25500: #endif
25500: 
47118: #ifdef MOZ_X11
47118:   class Renderer
16959: #if defined(MOZ_WIDGET_GTK2)
47118:     : public gfxXlibNativeRenderer
47118: #elif defined(MOZ_WIDGET_QT)
47118:     : public gfxQtNativeRenderer
47118: #endif
47118:   {
 3059:   public:
47115:     Renderer(NPWindow* aWindow, nsPluginInstanceOwner* aInstanceOwner,
15688:              const nsIntSize& aPluginSize, const nsIntRect& aDirtyRect)
47115:       : mWindow(aWindow), mInstanceOwner(aInstanceOwner),
15688:         mPluginSize(aPluginSize), mDirtyRect(aDirtyRect)
 3059:     {}
47118:     virtual nsresult DrawWithXlib(gfxXlibSurface* surface, nsIntPoint offset, 
47118:             nsIntRect* clipRects, PRUint32 numClipRects);
16959:   private:
32799:     NPWindow* mWindow;
47115:     nsPluginInstanceOwner* mInstanceOwner;
16959:     const nsIntSize& mPluginSize;
16959:     const nsIntRect& mDirtyRect;
16959:   };
 3059: #endif
35495: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
34217: 
34217:   // On hildon, we attempt to use NPImageExpose which allows us faster
35171:   // painting.
35171: 
35171:   // used to keep track of how big our buffer is.
35171:   nsIntSize mPluginSize;
35171: 
35171:   // The absolute position on the screen to draw to.
35199:   gfxRect mAbsolutePosition;
35171: 
35171:   // The clip region that we should draw into.
35199:   gfxRect mAbsolutePositionClip;
35171: 
35197:   GC mXlibSurfGC;
35171:   Window mBlitWindow;
35171:   XImage *mSharedXImage;
35171:   XShmSegmentInfo mSharedSegmentInfo;
35171: 
35171:   PRBool SetupXShm();
35171:   void ReleaseXShm();
35208:   void NativeImageDraw(NPRect* invalidRect = nsnull);
36299:   PRBool UpdateVisibility(PRBool aVisible);
35171: 
34217: #endif
54223: 
54223:   PRPackedBool          mWaitingForPaint;
 3059: };
 3059: 
62699: class PluginBackgroundSink : public ReadbackSink {
62699: public:
62699:   PluginBackgroundSink(nsObjectFrame* aFrame, PRUint64 aStartSequenceNumber)
62699:     : mLastSequenceNumber(aStartSequenceNumber), mFrame(aFrame) {}
62699:   ~PluginBackgroundSink()
62699:   {
62699:     if (mFrame) {
62699:       mFrame->mBackgroundSink = nsnull;
62699:     }
62699:   }
62699: 
62699:   virtual void SetUnknown(PRUint64 aSequenceNumber)
62699:   {
62699:     if (!AcceptUpdate(aSequenceNumber))
62699:       return;
62699:     mFrame->mInstanceOwner->SetBackgroundUnknown();
62699:   }
62699: 
62699:   virtual already_AddRefed<gfxContext>
62699:       BeginUpdate(const nsIntRect& aRect, PRUint64 aSequenceNumber)
62699:   {
62699:     if (!AcceptUpdate(aSequenceNumber))
62699:       return nsnull;
62699:     return mFrame->mInstanceOwner->BeginUpdateBackground(aRect);
62699:   }
62699: 
62699:   virtual void EndUpdate(gfxContext* aContext, const nsIntRect& aRect)
62699:   {
62699:     return mFrame->mInstanceOwner->EndUpdateBackground(aContext, aRect);
62699:   }
62699: 
62699:   void Destroy() { mFrame = nsnull; }
62699: 
62699: protected:
62699:   PRBool AcceptUpdate(PRUint64 aSequenceNumber) {
62699:     if (aSequenceNumber > mLastSequenceNumber && mFrame &&
62699:         mFrame->mInstanceOwner) {
62699:       mLastSequenceNumber = aSequenceNumber;
62699:       return PR_TRUE;
62699:     }
62699:     return PR_FALSE;
62699:   }
62699: 
62699:   PRUint64 mLastSequenceNumber;
62699:   nsObjectFrame* mFrame;
62699: };
62699: 
30524:   // Mac specific code to fix up port position and clip
    1: #ifdef XP_MACOSX
    1: 
30524:   enum { ePluginPaintEnable, ePluginPaintDisable };
    1: 
    1: #endif // XP_MACOSX
    1: 
12417: nsObjectFrame::nsObjectFrame(nsStyleContext* aContext)
12417:   : nsObjectFrameSuper(aContext)
52186:   , mReflowCallbackPosted(PR_FALSE)
12417: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Created new nsObjectFrame %p\n", this));
12417: }
12417: 
    1: nsObjectFrame::~nsObjectFrame()
    1: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsObjectFrame %p deleted\n", this));
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsObjectFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIObjectFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsObjectFrameSuper)
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsObjectFrame::CreateAccessible()
    1: {
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
46338:   return accService ?
46338:     accService->CreateHTMLObjectFrameAccessible(this, mContent,
46338:                                                 PresContext()->PresShell()) :
46338:     nsnull;
    1: }
    1: 
    1: #ifdef XP_WIN
    1: NS_IMETHODIMP nsObjectFrame::GetPluginPort(HWND *aPort)
    1: {
37446:   *aPort = (HWND) mInstanceOwner->GetPluginPortFromWidget();
    1:   return NS_OK;
    1: }
    1: #endif
    1: #endif
    1: 
    1: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
    1: 
    1: NS_IMETHODIMP 
    1: nsObjectFrame::Init(nsIContent*      aContent,
    1:                     nsIFrame*        aParent,
    1:                     nsIFrame*        aPrevInFlow)
    1: {
20078:   NS_PRECONDITION(aContent, "How did that happen?");
20078:   mPreventInstantiation =
20078:     (aContent->GetCurrentDoc()->GetDisplayDocument() != nsnull);
    1: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Initializing nsObjectFrame %p for content %p\n", this, aContent));
12417: 
35180:   nsresult rv = nsObjectFrameSuper::Init(aContent, aParent, aPrevInFlow);
35180: 
35180:   return rv;
    1: }
    1: 
    1: void
36647: nsObjectFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
20078:   NS_ASSERTION(!mPreventInstantiation ||
29834:                (mContent && mContent->GetCurrentDoc()->GetDisplayDocument()),
20078:                "about to crash due to bug 136927");
    1: 
    1:   // we need to finish with the plugin before native window is destroyed
    1:   // doing this in the destructor is too late.
 4577:   StopPluginInternal(PR_TRUE);
    1: 
30522:   // StopPluginInternal might have disowned the widget; if it has,
30522:   // mWidget will be null.
30522:   if (mWidget) {
33369:     mInnerView->DetachWidgetEventHandler(mWidget);
30522:     mWidget->Destroy();
30522:   }
30522: 
62699:   if (mBackgroundSink) {
62699:     mBackgroundSink->Destroy();
62699:   }
62699: 
36647:   nsObjectFrameSuper::DestroyFrom(aDestructRoot);
    1: }
    1: 
20441: /* virtual */ void
20836: nsObjectFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 7015: {
 7015:   if (HasView()) {
 7015:     nsIView* view = GetView();
 7015:     nsIViewManager* vm = view->GetViewManager();
 7015:     if (vm) {
 7015:       nsViewVisibility visibility = 
 7015:         IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow;
 7015:       vm->SetViewVisibility(view, visibility);
 7015:     }
 7015:   }
 7015: 
20836:   nsObjectFrameSuper::DidSetStyleContext(aOldStyleContext);
 7015: }
 7015: 
    1: nsIAtom*
    1: nsObjectFrame::GetType() const
    1: {
    1:   return nsGkAtoms::objectFrame; 
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsObjectFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ObjectFrame"), aResult);
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsObjectFrame::CreateWidget(nscoord aWidth,
    1:                             nscoord aHeight,
    1:                             PRBool  aViewOnly)
    1: {
    1:   nsIView* view = GetView();
    1:   NS_ASSERTION(view, "Object frames must have views");  
    1:   if (!view) {
    1:     return NS_OK;       //XXX why OK? MMP
    1:   }
    1: 
62617:   PRBool needsWidget = !aViewOnly;
62617:   PRBool canCreateWidget = !nsIWidget::UsePuppetWidgets();
62617:   if (needsWidget && !canCreateWidget) {
62617:     NS_WARNING("Can't use native widgets, and can't hand a plugins a PuppetWidget");
62617:   }
62617: 
    1:   nsIViewManager* viewMan = view->GetViewManager();
    1:   // mark the view as hidden since we don't know the (x,y) until Paint
    1:   // XXX is the above comment correct?
    1:   viewMan->SetViewVisibility(view, nsViewVisibility_kHide);
    1: 
30522:   nsCOMPtr<nsIDeviceContext> dx;
30522:   viewMan->GetDeviceContext(*getter_AddRefs(dx));
30522: 
    1:   //this is ugly. it was ripped off from didreflow(). MMP
    1:   // Position and size view relative to its parent, not relative to our
    1:   // parent frame (our parent frame may not have a view).
    1:   
    1:   nsIView* parentWithView;
    1:   nsPoint origin;
    1:   nsRect r(0, 0, mRect.width, mRect.height);
    1: 
    1:   GetOffsetFromView(origin, &parentWithView);
    1:   viewMan->ResizeView(view, r);
    1:   viewMan->MoveViewTo(view, origin.x, origin.y);
    1: 
37615:   nsRootPresContext* rpc = PresContext()->GetRootPresContext();
37615:   if (!rpc) {
37615:     return NS_ERROR_FAILURE;
37615:   }
37615: 
62617:   if (needsWidget && !mWidget && canCreateWidget) {
59654:     // XXX this breaks plugins in popups ... do we care?
59654:     nsIWidget* parentWidget =
59654:       rpc->PresShell()->FrameManager()->GetRootFrame()->GetNearestWidget();
59654:     if (!parentWidget)
59654:       return NS_ERROR_FAILURE;
59654: 
33369:     mInnerView = viewMan->CreateView(GetContentRect() - GetPosition(), view);
33369:     if (!mInnerView) {
33369:       NS_ERROR("Could not create inner view");
33369:       return NS_ERROR_OUT_OF_MEMORY;
33369:     }
33369:     viewMan->InsertChild(view, mInnerView, nsnull, PR_TRUE);
33369: 
30522:     nsresult rv;
30522:     mWidget = do_CreateInstance(kWidgetCID, &rv);
30522:     if (NS_FAILED(rv))
30522:       return rv;
30522: 
30522:     nsWidgetInitData initData;
33357:     initData.mWindowType = eWindowType_plugin;
30522:     initData.mUnicode = PR_FALSE;
30522:     initData.clipChildren = PR_TRUE;
30522:     initData.clipSiblings = PR_TRUE;
30522:     // We want mWidget to be able to deliver events to us, especially on
30522:     // Mac where events to the plugin are routed through Gecko. So we
30522:     // allow the view to attach its event handler to mWidget even though
30522:     // mWidget isn't the view's designated widget.
33369:     EVENT_CALLBACK eventHandler = mInnerView->AttachWidgetEventHandler(mWidget);
61670:     rv = mWidget->Create(parentWidget, nsnull, nsIntRect(0,0,0,0),
30522:                          eventHandler, dx, nsnull, nsnull, &initData);
61670:     if (NS_FAILED(rv)) {
61670:       mWidget->Destroy();
61670:       mWidget = nsnull;
61670:       return rv;
61670:     }
30522: 
30522:     mWidget->EnableDragDrop(PR_TRUE);
30522: 
33373:     // If this frame has an ancestor with a widget which is not
33373:     // the root prescontext's widget, then this plugin should not be
33373:     // displayed, so don't show the widget. If we show the widget, the
33373:     // plugin may appear in the main window. In Web content this would
33373:     // only happen with a plugin in a XUL popup.
47148:     if (parentWidget == GetNearestWidget()) {
30522:       mWidget->Show(PR_TRUE);
42961: #ifdef XP_MACOSX
42961:       // On Mac, we need to invalidate ourselves since even windowed
42961:       // plugins are painted through Thebes and we need to ensure
42961:       // the Thebes layer containing the plugin is updated.
42961:       Invalidate(GetContentRect() - GetPosition());
42961: #endif
30522:     }
33373:   }
30522: 
30522:   if (mWidget) {
37615:     rpc->RegisterPluginForGeometryUpdates(this);
47756:     rpc->RequestUpdatePluginGeometry(this);
37615: 
    1:     // Here we set the background color for this widget because some plugins will use 
    1:     // the child window background color when painting. If it's not set, it may default to gray
    1:     // Sometimes, a frame doesn't have a background color or is transparent. In this
    1:     // case, walk up the frame tree until we do find a frame with a background color
    1:     for (nsIFrame* frame = this; frame; frame = frame->GetParent()) {
40178:       nscolor bgcolor =
40178:         frame->GetVisitedDependentColor(eCSSProperty_background_color);
40178:       if (NS_GET_A(bgcolor) > 0) {  // make sure we got an actual color
40178:         mWidget->SetBackgroundColor(bgcolor);
    1:         break;
    1:       }
    1:     }
34717: 
34717: #ifdef XP_MACOSX
34717:     // Now that we have a widget we want to set the event model before
34717:     // any events are processed.
34717:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
34717:     if (!pluginWidget)
34717:       return NS_ERROR_FAILURE;
34717:     pluginWidget->SetPluginEventModel(mInstanceOwner->GetEventModel());
54248:     pluginWidget->SetPluginDrawingModel(mInstanceOwner->GetDrawingModel());
39757: 
39757:     if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation) {
42504:       mInstanceOwner->SetupCARefresh();
39757:     }
34717: #endif
57224:   } else {
57224: #ifndef XP_MACOSX
57224:     rpc->RegisterPluginForGeometryUpdates(this);
57224: #endif
    1:   }
    1: 
 7015:   if (!IsHidden()) {
    1:     viewMan->SetViewVisibility(view, nsViewVisibility_kShow);
 7015:   }
    1: 
62617:   return (needsWidget && !canCreateWidget) ? NS_ERROR_NOT_AVAILABLE : NS_OK;
    1: }
    1: 
    1: #define EMBED_DEF_WIDTH 240
    1: #define EMBED_DEF_HEIGHT 200
    1: 
    1: /* virtual */ nscoord
    1: nsObjectFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1: 
    1:   if (!IsHidden(PR_FALSE)) {
    1:     nsIAtom *atom = mContent->Tag();
    1:     if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
    1:       result = nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH);
    1:     }
    1:   }
    1: 
    1:   DISPLAY_MIN_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsObjectFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   return nsObjectFrame::GetMinWidth(aRenderingContext);
    1: }
    1: 
    1: void
    1: nsObjectFrame::GetDesiredSize(nsPresContext* aPresContext,
    1:                               const nsHTMLReflowState& aReflowState,
    1:                               nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   // By default, we have no area
    1:   aMetrics.width = 0;
    1:   aMetrics.height = 0;
    1: 
    1:   if (IsHidden(PR_FALSE)) {
    1:     return;
    1:   }
    1:   
    1:   aMetrics.width = aReflowState.ComputedWidth();
 4166:   aMetrics.height = aReflowState.ComputedHeight();
    1: 
    1:   // for EMBED and APPLET, default to 240x200 for compatibility
    1:   nsIAtom *atom = mContent->Tag();
    1:   if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
    1:     if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
32531:       aMetrics.width = NS_MIN(NS_MAX(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH),
    1:                                      aReflowState.mComputedMinWidth),
    1:                               aReflowState.mComputedMaxWidth);
    1:     }
    1:     if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
32531:       aMetrics.height = NS_MIN(NS_MAX(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_HEIGHT),
    1:                                       aReflowState.mComputedMinHeight),
    1:                                aReflowState.mComputedMaxHeight);
    1:     }
    1: 
  944: #if defined (MOZ_WIDGET_GTK2)
    1:     // We need to make sure that the size of the object frame does not
    1:     // exceed the maximum size of X coordinates.  See bug #225357 for
    1:     // more information.  In theory Gtk2 can handle large coordinates,
    1:     // but underlying plugins can't.
32531:     aMetrics.height = NS_MIN(aPresContext->DevPixelsToAppUnits(PR_INT16_MAX), aMetrics.height);
32531:     aMetrics.width = NS_MIN(aPresContext->DevPixelsToAppUnits(PR_INT16_MAX), aMetrics.width);
    1: #endif
    1:   }
    1: 
    1:   // At this point, the width has an unconstrained value only if we have
    1:   // nothing to go on (no width set, no information from the plugin, nothing).
    1:   // Make up a number.
    1:   if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
    1:     aMetrics.width =
    1:       (aReflowState.mComputedMinWidth != NS_UNCONSTRAINEDSIZE) ?
    1:         aReflowState.mComputedMinWidth : 0;
    1:   }
    1: 
    1:   // At this point, the height has an unconstrained value only in two cases:
    1:   // a) We are in standards mode with percent heights and parent is auto-height
    1:   // b) We have no height information at all.
    1:   // In either case, we have to make up a number.
    1:   if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
    1:     aMetrics.height =
    1:       (aReflowState.mComputedMinHeight != NS_UNCONSTRAINEDSIZE) ?
    1:         aReflowState.mComputedMinHeight : 0;
    1:   }
    1: 
    1:   // XXXbz don't add in the border and padding, because we screw up our
    1:   // plugin's size and positioning if we do...  Eventually we _do_ want to
    1:   // paint borders, though!  At that point, we will need to adjust the desired
    1:   // size either here or in Reflow....  Further, we will need to fix Paint() to
    1:   // call the superclass in all cases.
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::Reflow(nsPresContext*           aPresContext,
    1:                       nsHTMLReflowMetrics&     aMetrics,
    1:                       const nsHTMLReflowState& aReflowState,
    1:                       nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsObjectFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1: 
    1:   // Get our desired size
    1:   GetDesiredSize(aPresContext, aReflowState, aMetrics);
55039:   aMetrics.SetOverflowAreasToDesiredBounds();
24440:   FinishAndStoreOverflow(&aMetrics);
    1: 
    1:   // delay plugin instantiation until all children have
    1:   // arrived. Otherwise there may be PARAMs or other stuff that the
    1:   // plugin needs to see that haven't arrived yet.
    1:   if (!GetContent()->IsDoneAddingChildren()) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if we are printing or print previewing, bail for now
    1:   if (aPresContext->Medium() == nsGkAtoms::print) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
33369:   nsRect r(0, 0, aMetrics.width, aMetrics.height);
33369:   r.Deflate(aReflowState.mComputedBorderPadding);
33369: 
33369:   if (mInnerView) {
33369:     nsIViewManager* vm = mInnerView->GetViewManager();
33369:     vm->MoveViewTo(mInnerView, r.x, r.y);
33369:     vm->ResizeView(mInnerView, nsRect(nsPoint(0, 0), r.Size()), PR_TRUE);
33369:   }
33369: 
33369:   FixupWindow(r.Size());
52186:   if (!mReflowCallbackPosted) {
52186:     mReflowCallbackPosted = PR_TRUE;
52186:     aPresContext->PresShell()->PostReflowCallback(this);
52186:   }
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return NS_OK;
    1: }
    1: 
52186: ///////////// nsIReflowCallback ///////////////
52186: 
52186: PRBool
52186: nsObjectFrame::ReflowFinished()
52186: {
52186:   mReflowCallbackPosted = PR_FALSE;
52186:   CallSetWindow();
52186:   return PR_TRUE;
52186: }
52186: 
52186: void
52186: nsObjectFrame::ReflowCallbackCanceled()
52186: {
52186:   mReflowCallbackPosted = PR_FALSE;
52186: }
52186: 
    1: nsresult
    1: nsObjectFrame::InstantiatePlugin(nsIPluginHost* aPluginHost, 
    1:                                  const char* aMimeType,
    1:                                  nsIURI* aURI)
    1: {
14982:   NS_ASSERTION(mPreventInstantiation,
14982:                "Instantiation should be prevented here!");
14982: 
    4:   // If you add early return(s), be sure to balance this call to
    4:   // appShell->SuspendNative() with additional call(s) to
    4:   // appShell->ReturnNative().
    4:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
    4:   if (appShell) {
    4:     appShell->SuspendNative();
    4:   }
    1: 
    1:   NS_ASSERTION(mContent, "We should have a content node.");
    1: 
    1:   nsIDocument* doc = mContent->GetOwnerDoc();
    1:   nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(doc));
20110:   PRBool fullPageMode = PR_FALSE;
20110:   if (pDoc) {
20110:     pDoc->GetWillHandleInstantiation(&fullPageMode);
20110:   }
    1: 
    1:   nsresult rv;
20110:   if (fullPageMode) {  /* full-page mode */
    1:     nsCOMPtr<nsIStreamListener> stream;
47865:     rv = aPluginHost->InstantiateFullPagePlugin(aMimeType, aURI, mInstanceOwner, getter_AddRefs(stream));
    1:     if (NS_SUCCEEDED(rv))
    1:       pDoc->SetStreamListener(stream);
    1:   } else {   /* embedded mode */
    1:     rv = aPluginHost->InstantiateEmbeddedPlugin(aMimeType, aURI,
    1:                                                 mInstanceOwner);
    1:   }
    1: 
15569:   // Note that |this| may very well be destroyed already!
15569: 
    4:   if (appShell) {
    4:     appShell->ResumeNative();
    4:   }
    4: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsObjectFrame::FixupWindow(const nsSize& aSize)
    1: {
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   if (!mInstanceOwner)
    1:     return;
    1: 
32799:   NPWindow *window;
    1:   mInstanceOwner->GetWindow(window);
    1: 
    1:   NS_ENSURE_TRUE(window, /**/);
    1: 
 4329: #ifdef XP_MACOSX
 4329:   mInstanceOwner->FixUpPluginWindow(ePluginPaintDisable);
 4329: #endif
 4329: 
32799:   PRBool windowless = (window->type == NPWindowTypeDrawable);
 4329: 
23738:   nsIntPoint origin = GetWindowOriginInPixels(windowless);
 4329: 
 4329:   window->x = origin.x;
 4329:   window->y = origin.y;
 4329: 
    1:   window->width = presContext->AppUnitsToDevPixels(aSize.width);
    1:   window->height = presContext->AppUnitsToDevPixels(aSize.height);
    1: 
    1:   // on the Mac we need to set the clipRect to { 0, 0, 0, 0 } for now. This will keep
    1:   // us from drawing on screen until the widget is properly positioned, which will not
    1:   // happen until we have finished the reflow process.
57224: #ifdef XP_MACOSX
    1:   window->clipRect.top = 0;
    1:   window->clipRect.left = 0;
    1:   window->clipRect.bottom = 0;
    1:   window->clipRect.right = 0;
    1: #else
57514:   mInstanceOwner->UpdateWindowPositionAndClipRect(PR_FALSE);
56619: #endif
57224: 
37372:   NotifyPluginReflowObservers();
    1: }
    1: 
58796: nsresult
59526: nsObjectFrame::CallSetWindow(PRBool aCheckIsHidden)
    1: {
32799:   NPWindow *win = nsnull;
    1:  
58796:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsCOMPtr<nsIPluginInstance> pi; 
    1:   if (!mInstanceOwner ||
    1:       NS_FAILED(rv = mInstanceOwner->GetInstance(*getter_AddRefs(pi))) ||
    1:       !pi ||
    1:       NS_FAILED(rv = mInstanceOwner->GetWindow(win)) || 
    1:       !win)
58796:     return rv;
    1: 
    1:   nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
    1: #ifdef XP_MACOSX
    1:   mInstanceOwner->FixUpPluginWindow(ePluginPaintDisable);
    1: #endif
    1: 
59526:   if (aCheckIsHidden && IsHidden())
58796:     return NS_ERROR_FAILURE;
    1: 
    1:   // refresh the plugin port as well
37446:   window->window = mInstanceOwner->GetPluginPortFromWidget();
    1: 
52187:   // Adjust plugin dimensions according to pixel snap results
52187:   // and reduce amount of SetWindow calls
52187:   nsPresContext* presContext = PresContext();
52187:   nsRootPresContext* rootPC = presContext->GetRootPresContext();
52187:   if (!rootPC)
58796:     return NS_ERROR_FAILURE;
52187:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
52187:   nsIFrame* rootFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
52187:   nsRect bounds = GetContentRect() + GetParent()->GetOffsetToCrossDoc(rootFrame);
52187:   nsIntRect intBounds = bounds.ToNearestPixels(appUnitsPerDevPixel);
52187:   window->x = intBounds.x;
52187:   window->y = intBounds.y;
52187:   window->width = intBounds.width;
52187:   window->height = intBounds.height;
52187: 
    1:   // this will call pi->SetWindow and take care of window subclassing
 4164:   // if needed, see bug 132759.
62474:   if (mInstanceOwner->UseAsyncRendering()) {
58796:     rv = pi->AsyncSetWindow(window);
54223:   }
54223:   else {
58796:     rv = window->CallSetWindow(pi);
54223:   }
    1: 
32799:   mInstanceOwner->ReleasePluginPort(window->window);
58796:   return rv;
 4825: }
 4825: 
 4825: PRBool
 4825: nsObjectFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
 4825: {
 4825:   if (aTabIndex)
 4825:     *aTabIndex = -1;
 4825:   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
 4825: }
 4825: 
 4825: PRBool
 4825: nsObjectFrame::IsHidden(PRBool aCheckVisibilityStyle) const
 4825: {
 4825:   if (aCheckVisibilityStyle) {
 4825:     if (!GetStyleVisibility()->IsVisibleOrCollapsed())
 4825:       return PR_TRUE;    
 4825:   }
 4825: 
 4825:   // only <embed> tags support the HIDDEN attribute
 4825:   if (mContent->Tag() == nsGkAtoms::embed) {
 4825:     // Yes, these are really the kooky ways that you could tell 4.x
 4825:     // not to hide the <embed> once you'd put the 'hidden' attribute
 4825:     // on the tag...
 4825: 
 4825:     // HIDDEN w/ no attributes gets translated as we are hidden for
 4825:     // compatibility w/ 4.x and IE so we don't create a non-painting
 4825:     // widget in layout. See bug 188959.
 4825:     nsAutoString hidden;
 4825:     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::hidden, hidden) &&
 4825:        (hidden.IsEmpty() ||
19264:         (!hidden.LowerCaseEqualsLiteral("false") &&
 4825:          !hidden.LowerCaseEqualsLiteral("no") &&
19264:          !hidden.LowerCaseEqualsLiteral("off")))) {
 4825:       return PR_TRUE;
 4825:     }
 4825:   }
 4825: 
 4825:   return PR_FALSE;
 4825: }
 4825: 
23738: nsIntPoint nsObjectFrame::GetWindowOriginInPixels(PRBool aWindowless)
 4825: {
 4825:   nsIView * parentWithView;
 4825:   nsPoint origin(0,0);
 4825: 
 4825:   GetOffsetFromView(origin, &parentWithView);
 4825: 
 4825:   // if it's windowless, let's make sure we have our origin set right
 4825:   // it may need to be corrected, like after scrolling
 4825:   if (aWindowless && parentWithView) {
30878:     nsPoint offsetToWidget;
30878:     parentWithView->GetNearestWidget(&offsetToWidget);
30878:     origin += offsetToWidget;
 4825:   }
33369:   // It's OK to use GetUsedBorderAndPadding here (and below) since
33369:   // GetSkipSides always returns 0; we don't split nsObjectFrames
33369:   origin += GetUsedBorderAndPadding().TopLeft();
 4825: 
23738:   return nsIntPoint(PresContext()->AppUnitsToDevPixels(origin.x),
23738:                     PresContext()->AppUnitsToDevPixels(origin.y));
 4825: }
 4825: 
 4825: NS_IMETHODIMP
 4825: nsObjectFrame::DidReflow(nsPresContext*            aPresContext,
 4825:                          const nsHTMLReflowState*  aReflowState,
 4825:                          nsDidReflowStatus         aStatus)
 4825: {
 4825:   // Do this check before calling the superclass, as that clears
 4825:   // NS_FRAME_FIRST_REFLOW
 4825:   if (aStatus == NS_FRAME_REFLOW_FINISHED &&
 4825:       (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 4825:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(mContent));
 4825:     NS_ASSERTION(objContent, "Why not an object loading content?");
 4825:     objContent->HasNewFrame(this);
 4825:   }
 4825: 
 4825:   nsresult rv = nsObjectFrameSuper::DidReflow(aPresContext, aReflowState, aStatus);
 4825: 
 4825:   // The view is created hidden; once we have reflowed it and it has been
 4825:   // positioned then we show it.
 4825:   if (aStatus != NS_FRAME_REFLOW_FINISHED) 
 4825:     return rv;
 4825: 
 4825:   if (HasView()) {
 4825:     nsIView* view = GetView();
 4825:     nsIViewManager* vm = view->GetViewManager();
 4825:     if (vm)
 4825:       vm->SetViewVisibility(view, IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow);
 4825:   }
 4825: 
    1:   return rv;
    1: }
    1: 
15688: /* static */ void
15688: nsObjectFrame::PaintPrintPlugin(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                                 const nsRect& aDirtyRect, nsPoint aPt)
    1: {
33369:   nsPoint pt = aPt + aFrame->GetUsedBorderAndPadding().TopLeft();
33369:   nsIRenderingContext::AutoPushTranslation translate(aCtx, pt.x, pt.y);
15688:   // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
 3233:   static_cast<nsObjectFrame*>(aFrame)->PrintPlugin(*aCtx, aDirtyRect);
    1: }
    1: 
62699: class nsDisplayPluginReadback : public nsDisplayItem {
62699: public:
62699:   nsDisplayPluginReadback(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
62699:     : nsDisplayItem(aBuilder, aFrame)
62699:   {
62699:     MOZ_COUNT_CTOR(nsDisplayPluginReadback);
62699:   }
62699: #ifdef NS_BUILD_REFCNT_LOGGING
62699:   virtual ~nsDisplayPluginReadback() {
62699:     MOZ_COUNT_DTOR(nsDisplayPluginReadback);
62699:   }
62699: #endif
62699: 
62699:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
62699:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
62699:                                    nsRegion* aVisibleRegion,
62700:                                    const nsRect& aAllowVisibleRegionExpansion,
62699:                                    PRBool& aContainsRootContentDocBG);
62699: 
62699:   NS_DISPLAY_DECL_NAME("PluginReadback", TYPE_PLUGIN_READBACK)
62699: 
62699:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
62699:                                              LayerManager* aManager)
62699:   {
62699:     return static_cast<nsObjectFrame*>(mFrame)->BuildLayer(aBuilder, aManager, this);
62699:   }
62699: 
62699:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
62699:                                    LayerManager* aManager)
62699:   {
62699:     return LAYER_ACTIVE;
62699:   }
62699: };
62699: 
62699: static nsRect
62982: GetDisplayItemBounds(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem, nsIFrame* aFrame)
62982: {
62982:   // XXX For slightly more accurate region computations we should pixel-snap this
62982:   return aFrame->GetContentRect() - aFrame->GetPosition() +
62699:     aItem->ToReferenceFrame();
30522: }
30522: 
62699: nsRect
62699: nsDisplayPluginReadback::GetBounds(nsDisplayListBuilder* aBuilder)
62699: {
62982:   return GetDisplayItemBounds(aBuilder, this, mFrame);
62699: }
62699: 
62699: PRBool
62699: nsDisplayPluginReadback::ComputeVisibility(nsDisplayListBuilder* aBuilder,
62699:                                            nsRegion* aVisibleRegion,
62700:                                            const nsRect& aAllowVisibleRegionExpansion,
62699:                                            PRBool& aContainsRootContentDocBG)
62699: {
62700:   if (!nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
62700:                                         aAllowVisibleRegionExpansion,
62700:                                         aContainsRootContentDocBG))
62699:     return PR_FALSE;
62700: 
62700:   nsRect expand;
62700:   expand.IntersectRect(aAllowVisibleRegionExpansion, GetBounds(aBuilder));
62699:   // *Add* our bounds to the visible region so that stuff underneath us is
62699:   // likely to be made visible, so we can use it for a background! This is
62699:   // a bit crazy since we normally only subtract from the visible region.
62700:   aVisibleRegion->Or(*aVisibleRegion, expand);
62699:   return PR_TRUE;
62699: }
62699: 
62699: nsRect
62699: nsDisplayPlugin::GetBounds(nsDisplayListBuilder* aBuilder)
62699: {
62982:   return GetDisplayItemBounds(aBuilder, this, mFrame);
62699: }
62699: 
30522: void
30522: nsDisplayPlugin::Paint(nsDisplayListBuilder* aBuilder,
33368:                        nsIRenderingContext* aCtx)
30522: {
30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
56434:   f->PaintPlugin(aBuilder, *aCtx, mVisibleRect, GetBounds(aBuilder));
30522: }
30522: 
30522: PRBool
33368: nsDisplayPlugin::ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
62700:                                    const nsRect& aAllowVisibleRegionExpansion,
61411:                                    PRBool& aContainsRootContentDocBG)
50393: {
30522:   mVisibleRegion.And(*aVisibleRegion, GetBounds(aBuilder));  
61411:   return nsDisplayItem::ComputeVisibility(aBuilder, aVisibleRegion,
62700:                                           aAllowVisibleRegionExpansion,
61411:                                           aContainsRootContentDocBG);
30522: }
30522: 
59779: nsRegion
59779: nsDisplayPlugin::GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                  PRBool* aForceTransparentSurface)
56101: {
56101:   if (aForceTransparentSurface) {
56101:     *aForceTransparentSurface = PR_FALSE;
56101:   }
59779:   nsRegion result;
30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
57094:   if (!aBuilder->IsForPluginGeometry()) {
57094:     nsIWidget* widget = f->GetWidget();
57094:     if (widget) {
57094:       nsTArray<nsIntRect> clip;
57094:       widget->GetWindowClipRegion(&clip);
57094:       nsTArray<nsIWidget::Configuration> configuration;
57094:       GetWidgetConfiguration(aBuilder, &configuration);
57094:       NS_ASSERTION(configuration.Length() == 1, "No configuration found");
57094:       if (clip != configuration[0].mClipRegion) {
57094:         // Something has clipped us unexpectedly. Perhaps there is a translucent
57094:         // chrome element overlaying us that forced us to be clipped away. Treat
57094:         // us as non-opaque since we may have holes.
59779:     	return result;
59779:       }
59779:     }
59779:   }
62982:   if (f->IsOpaque() &&
62982:       (aBuilder->IsForPluginGeometry() ||
62982:        (f->GetPaintedRect(this) + ToReferenceFrame()).Contains(GetBounds(aBuilder)))) {
62982:     // We can treat this as opaque
59779:     result = GetBounds(aBuilder);
59779:   }
59779:   return result;
30522: }
30522: 
30522: void
30522: nsDisplayPlugin::GetWidgetConfiguration(nsDisplayListBuilder* aBuilder,
30522:                                         nsTArray<nsIWidget::Configuration>* aConfigurations)
30522: {
30522:   nsObjectFrame* f = static_cast<nsObjectFrame*>(mFrame);
33369:   nsPoint pluginOrigin = mFrame->GetUsedBorderAndPadding().TopLeft() +
51261:     ToReferenceFrame();
33369:   f->ComputeWidgetGeometry(mVisibleRegion, pluginOrigin, aConfigurations);
30522: }
30522: 
30522: void
30522: nsObjectFrame::ComputeWidgetGeometry(const nsRegion& aRegion,
30522:                                      const nsPoint& aPluginOrigin,
30522:                                      nsTArray<nsIWidget::Configuration>* aConfigurations)
30522: {
57224:   if (!mWidget) {
57224: #ifndef XP_MACOSX
57224:     if (mInstanceOwner) {
57514:       // UpdateWindowVisibility will notify the plugin of position changes
57514:       // by updating the NPWindow and calling NPP_SetWindow/AsyncSetWindow.
57224:       mInstanceOwner->UpdateWindowVisibility(!aRegion.IsEmpty());
57224:     }
57224: #endif
30522:     return;
57224:   }
30522: 
37502:   nsPresContext* presContext = PresContext();
37502:   nsRootPresContext* rootPC = presContext->GetRootPresContext();
37502:   if (!rootPC)
37502:     return;
37502: 
37502:   nsIWidget::Configuration* configuration = aConfigurations->AppendElement();
30522:   if (!configuration)
30522:     return;
30522:   configuration->mChild = mWidget;
30522: 
30522:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
37502:   nsIFrame* rootFrame = rootPC->PresShell()->FrameManager()->GetRootFrame();
47902:   nsRect bounds = GetContentRect() + GetParent()->GetOffsetToCrossDoc(rootFrame);
30522:   configuration->mBounds = bounds.ToNearestPixels(appUnitsPerDevPixel);
30522: 
39430:   // This should produce basically the same rectangle (but not relative
39430:   // to the root frame). We only call this here for the side-effect of
39430:   // setting mViewToWidgetOffset on the view.
39430:   mInnerView->CalcWidgetBounds(eWindowType_plugin);
39430: 
30522:   nsRegionRectIterator iter(aRegion);
30522:   nsIntPoint pluginOrigin = aPluginOrigin.ToNearestPixels(appUnitsPerDevPixel);
30522:   for (const nsRect* r = iter.Next(); r; r = iter.Next()) {
30522:     // Snap *r to pixels while it's relative to the painted widget, to
30522:     // improve consistency with rectangle and image drawing
30522:     nsIntRect pixRect =
30522:       r->ToNearestPixels(appUnitsPerDevPixel) - pluginOrigin;
30522:     if (!pixRect.IsEmpty()) {
30522:       configuration->mClipRegion.AppendElement(pixRect);
30522:     }
30522:   }
30522: }
30522: 
35171: nsresult
35171: nsObjectFrame::SetAbsoluteScreenPosition(nsIDOMElement* element,
35171:                                          nsIDOMClientRect* position,
35171:                                          nsIDOMClientRect* clip)
35171: {
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35199:   if (!mInstanceOwner)
35199:     return NS_ERROR_NOT_AVAILABLE;
35171:   return mInstanceOwner->SetAbsoluteScreenPosition(element, position, clip);
35171: #else
35171:   return NS_ERROR_NOT_IMPLEMENTED;
35171: #endif
35171: }
35171: 
37372: nsresult
37372: nsObjectFrame::PluginEventNotifier::Run() {
41540:   nsCOMPtr<nsIObserverService> obsSvc =
41540:     mozilla::services::GetObserverService();
37372:   obsSvc->NotifyObservers(nsnull, "plugin-changed-event", mEventType.get());
37372:   return NS_OK;
37372: }
37372: 
30524: void
37372: nsObjectFrame::NotifyPluginReflowObservers()
37372: {
37372:   nsContentUtils::AddScriptRunner(new PluginEventNotifier(NS_LITERAL_STRING("reflow")));
35180: }
35180: 
35180: void
30524: nsObjectFrame::DidSetWidgetGeometry()
30524: {
30524: #if defined(XP_MACOSX)
30524:   if (mInstanceOwner) {
30524:     mInstanceOwner->FixUpPluginWindow(ePluginPaintEnable);
30524:   }
30524: #endif
30524: }
30524: 
30522: PRBool
30522: nsObjectFrame::IsOpaque() const
30522: {
30522: #if defined(XP_MACOSX)
62699:   // ???
62699:   return PR_FALSE;
62699: #else
62699:   return !IsTransparentMode();
62699: #endif
62699: }
62699: 
62699: PRBool
62699: nsObjectFrame::IsTransparentMode() const
62699: {
62699: #if defined(XP_MACOSX)
62699:   // ???
30522:   return PR_FALSE;
30522: #else
36333:   if (!mInstanceOwner)
36333:     return PR_FALSE;
36333: 
32799:   NPWindow *window;
30522:   mInstanceOwner->GetWindow(window);
36333:   if (window->type != NPWindowTypeDrawable)
62699:     return PR_FALSE;
36333: 
34441:   nsresult rv;
36333:   nsCOMPtr<nsIPluginInstance> pi;
36333:   rv = mInstanceOwner->GetInstance(*getter_AddRefs(pi));
36333:   if (NS_FAILED(rv) || !pi)
36333:     return PR_FALSE;
36333: 
34441:   PRBool transparent = PR_FALSE;
34441:   pi->IsTransparent(&transparent);
62699:   return transparent;
30522: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                 const nsRect&           aDirtyRect,
    1:                                 const nsDisplayListSet& aLists)
    1: {
    1:   // XXX why are we painting collapsed object frames?
    1:   if (!IsVisibleOrCollapsedForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
  238:   nsPresContext::nsPresContextType type = PresContext()->Type();
    1: 
    1:   // If we are painting in Print Preview do nothing....
    1:   if (type == nsPresContext::eContext_PrintPreview)
    1:     return NS_OK;
    1: 
    1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsObjectFrame");
    1: 
30541: #ifndef XP_MACOSX
30541:   if (mWidget && aBuilder->IsInTransform()) {
30541:     // Windowed plugins should not be rendered inside a transform.
30541:     return NS_OK;
30541:   }
30541: #endif
30541: 
52294:   nsDisplayList replacedContent;
52294: 
62474:   if (aBuilder->IsForPainting() && mInstanceOwner && mInstanceOwner->UseAsyncRendering()) {
59491:     NPWindow* window = nsnull;
59491:     mInstanceOwner->GetWindow(window);
59491:     PRBool isVisible = window && window->width > 0 && window->height > 0;
60439:     if (isVisible && aBuilder->ShouldSyncDecodeImages()) {
59491:   #ifndef XP_MACOSX
59491:       mInstanceOwner->UpdateWindowVisibility(PR_TRUE);
59491:   #endif
59491:     }
59491: 
59491:     ImageContainer* container = GetImageContainer();
59491:     nsRefPtr<Image> currentImage = container ? container->GetCurrentImage() : nsnull;
59491:     if (!currentImage || !isVisible ||
59491:         container->GetCurrentSize() != gfxIntSize(window->width, window->height)) {
59491:       mInstanceOwner->NotifyPaintWaiter(aBuilder);
59491:     }
59491:   }
59491: 
    1:   // determine if we are printing
52294:   if (type == nsPresContext::eContext_Print) {
52294:     rv = replacedContent.AppendNewToTop(new (aBuilder)
51260:         nsDisplayGeneric(aBuilder, this, PaintPrintPlugin, "PrintPlugin",
47732:                          nsDisplayItem::TYPE_PRINT_PLUGIN));
52294:   } else {
62699:     if (aBuilder->IsPaintingToWindow() &&
62699:         GetLayerState(aBuilder, nsnull) == LAYER_ACTIVE &&
62699:         IsTransparentMode()) {
62699:       rv = replacedContent.AppendNewToTop(new (aBuilder)
62699:           nsDisplayPluginReadback(aBuilder, this));
62699:       NS_ENSURE_SUCCESS(rv, rv);
62699:     }
62699: 
52294:     rv = replacedContent.AppendNewToTop(new (aBuilder)
51260:         nsDisplayPlugin(aBuilder, this));
    1:   }
52294:   NS_ENSURE_SUCCESS(rv, rv);
52294: 
52294:   WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
52294: 
52294:   return NS_OK;
52294: }
    1: 
    1: void
    1: nsObjectFrame::PrintPlugin(nsIRenderingContext& aRenderingContext,
    1:                            const nsRect& aDirtyRect)
    1: {
35581:   nsCOMPtr<nsIObjectLoadingContent> obj(do_QueryInterface(mContent));
35581:   if (!obj)
    1:     return;
    1: 
35581:   nsIFrame* frame = nsnull;
35581:   obj->GetPrintFrame(&frame);
    1:   if (!frame)
    1:     return;
    1: 
  238:   nsPresContext* presContext = PresContext();
    1:   // make sure this is REALLY an nsIObjectFrame
    1:   // we may need to go through the children to get it
23554:   nsIObjectFrame* objectFrame = do_QueryFrame(frame);
    1:   if (!objectFrame)
    1:     objectFrame = GetNextObjectFrame(presContext,frame);
    1:   if (!objectFrame)
    1:     return;
    1: 
    1:   // finally we can get our plugin instance
    1:   nsCOMPtr<nsIPluginInstance> pi;
    1:   if (NS_FAILED(objectFrame->GetPluginInstance(*getter_AddRefs(pi))) || !pi)
    1:     return;
    1: 
    1:   // now we need to setup the correct location for printing
32799:   NPWindow window;
    1:   window.window = nsnull;
    1: 
    1:   // prepare embedded mode printing struct
32799:   NPPrint npprint;
32799:   npprint.mode = NP_EMBED;
    1: 
    1:   // we need to find out if we are windowless or not
    1:   PRBool windowless = PR_FALSE;
32799:   pi->IsWindowless(&windowless);
32799:   window.type = windowless ? NPWindowTypeDrawable : NPWindowTypeWindow;
    1: 
    1:   window.clipRect.bottom = 0; window.clipRect.top = 0;
    1:   window.clipRect.left = 0; window.clipRect.right = 0;
    1:   
30472: // platform specific printing code
36227: #ifdef MAC_CARBON_PLUGINS
33371:   nsSize contentSize = GetContentRect().Size();
30472:   window.x = 0;
30472:   window.y = 0;
33371:   window.width = presContext->AppUnitsToDevPixels(contentSize.width);
33371:   window.height = presContext->AppUnitsToDevPixels(contentSize.height);
30472: 
30472:   gfxContext *ctx = aRenderingContext.ThebesContext();
30472:   if (!ctx)
30472:     return;
30472:   gfxContextAutoSaveRestore save(ctx);
30472: 
30472:   ctx->NewPath();
30472: 
30472:   gfxRect rect(window.x, window.y, window.width, window.height);
30472: 
30472:   ctx->Rectangle(rect);
30472:   ctx->Clip();
30472: 
30472:   gfxQuartzNativeDrawing nativeDraw(ctx, rect);
30472:   CGContextRef cgContext = nativeDraw.BeginNativeDrawing();
30472:   if (!cgContext) {
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472: 
30472:   window.clipRect.right = window.width;
30472:   window.clipRect.bottom = window.height;
32799:   window.type = NPWindowTypeDrawable;
30472: 
30472:   Rect gwBounds;
30472:   ::SetRect(&gwBounds, 0, 0, window.width, window.height);
30472: 
30472:   nsTArray<char> buffer(window.width * window.height * 4);
30472:   CGColorSpaceRef cspace = ::CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
30472:   if (!cspace) {
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472:   CGContextRef cgBuffer =
30472:     ::CGBitmapContextCreate(buffer.Elements(), 
30472:                             window.width, window.height, 8, window.width * 4,
30472:                             cspace, kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedFirst);
30472:   ::CGColorSpaceRelease(cspace);
30472:   if (!cgBuffer) {
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472:   GWorldPtr gWorld;
30472:   if (::NewGWorldFromPtr(&gWorld, k32ARGBPixelFormat, &gwBounds, NULL, NULL, 0,
30472:                          buffer.Elements(), window.width * 4) != noErr) {
30472:     ::CGContextRelease(cgBuffer);
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472: 
30472:   window.clipRect.right = window.width;
30472:   window.clipRect.bottom = window.height;
32799:   window.type = NPWindowTypeDrawable;
30472:   // Setting nsPluginPrint/NPPrint.print.embedPrint.window.window to
30472:   // &GWorldPtr and nsPluginPrint/NPPrint.print.embedPrint.platformPrint to
30472:   // GWorldPtr isn't any kind of standard (it's not documented anywhere).
30472:   // But that's what WebKit does.  And it's what the Flash plugin (apparently
30472:   // the only NPAPI plugin on OS X to support printing) seems to expect.  So
30472:   // we do the same.  The Flash plugin uses the CoreGraphics drawing mode.
30472:   // But a GWorldPtr should be usable in either CoreGraphics or QuickDraw
30472:   // drawing mode.  See bug 191046.
32799:   window.window = &gWorld;
30472:   npprint.print.embedPrint.platformPrint = gWorld;
30472:   npprint.print.embedPrint.window = window;
30472:   nsresult rv = pi->Print(&npprint);
30472: 
30472:   ::CGContextTranslateCTM(cgContext, 0.0f, float(window.height));
30472:   ::CGContextScaleCTM(cgContext, 1.0f, -1.0f);
30472:   CGImageRef image = ::CGBitmapContextCreateImage(cgBuffer);
30472:   if (!image) {
30472:     ::CGContextRestoreGState(cgContext);
30472:     ::CGContextRelease(cgBuffer);
30472:     ::DisposeGWorld(gWorld);
30472:     nativeDraw.EndNativeDrawing();
30472:     return;
30472:   }
30472:   ::CGContextDrawImage(cgContext,
30472:                        ::CGRectMake(0, 0, window.width, window.height),
30472:                        image);
30472:   ::CGImageRelease(image);
30472:   ::CGContextRelease(cgBuffer);
30472: 
30472:   ::DisposeGWorld(gWorld);
30472: 
30472:   nativeDraw.EndNativeDrawing();
30472: #elif defined(XP_UNIX)
12653: 
12653:   /* XXX this just flat-out doesn't work in a thebes world --
12653:    * RenderEPS is a no-op.  So don't bother to do any work here.
12653:    */
    1: 
12859: #elif defined(XP_OS2)
12859:   void *hps = aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_OS2_PS);
12859:   if (!hps)
12859:     return;
12859: 
12859:   npprint.print.embedPrint.platformPrint = hps;
12859:   npprint.print.embedPrint.window = window;
12859:   // send off print info to plugin
19448:   pi->Print(&npprint);
11703: #elif defined(XP_WIN)
11703: 
11703:   /* On Windows, we use the win32 printing surface to print.  This, in
11703:    * turn, uses the Cairo paginated surface, which in turn uses the
11703:    * meta surface to record all operations and then play them back.
11703:    * This doesn't work too well for plugins, because if plugins render
11703:    * directly into the DC, the meta surface won't have any knowledge
11703:    * of them, and so at the end when it actually does the replay step,
11703:    * it'll fill the background with white and draw over whatever was
11703:    * rendered before.
11703:    *
11703:    * So, to avoid this, we use PushGroup, which creates a new windows
11703:    * surface, the plugin renders to that, and then we use normal
11703:    * cairo methods to composite that in such that it's recorded using the
11703:    * meta surface.
11703:    */
11703: 
12653:   /* we'll already be translated into the right spot by gfxWindowsNativeDrawing */
33371:   nsSize contentSize = GetContentRect().Size();
12653:   window.x = 0;
12653:   window.y = 0;
33371:   window.width = presContext->AppUnitsToDevPixels(contentSize.width);
33371:   window.height = presContext->AppUnitsToDevPixels(contentSize.height);
12653: 
11703:   gfxContext *ctx = aRenderingContext.ThebesContext();
11703: 
11703:   ctx->Save();
11703: 
12653:   /* Make sure plugins don't do any damage outside of where they're supposed to */
11703:   ctx->NewPath();
21080:   gfxRect r(window.x, window.y, window.width, window.height);
21080:   ctx->Rectangle(r);
11703:   ctx->Clip();
12653: 
21080:   gfxWindowsNativeDrawing nativeDraw(ctx, r);
11703:   do {
11703:     HDC dc = nativeDraw.BeginNativeDrawing();
11703:     if (!dc)
11703:       return;
11703: 
21080:     // XXX don't we need to call nativeDraw.TransformToNativeRect here?
11703:     npprint.print.embedPrint.platformPrint = dc;
11703:     npprint.print.embedPrint.window = window;
11703:     // send off print info to plugin
19448:     pi->Print(&npprint);
11703: 
11703:     nativeDraw.EndNativeDrawing();
11703:   } while (nativeDraw.ShouldRenderAgain());
11703:   nativeDraw.PaintToContext();
11703: 
11703:   ctx->Restore();
    1: #endif
    1: 
    1:   // XXX Nav 4.x always sent a SetWindow call after print. Should we do the same?
33371:   // XXX Calling DidReflow here makes no sense!!!
    1:   nsDidReflowStatus status = NS_FRAME_REFLOW_FINISHED; // should we use a special status?
    1:   frame->DidReflow(presContext,
    1:                    nsnull, status);  // DidReflow will take care of it
    1: }
    1: 
54223: ImageContainer*
60712: nsObjectFrame::GetImageContainer(LayerManager* aManager)
60712: {
60712:   nsRefPtr<LayerManager> manager = aManager;
60712: 
60712:   if (!manager) {
60712:     manager = nsContentUtils::LayerManagerForDocument(mContent->GetOwnerDoc());
60712:   }
58485:   if (!manager) {
54223:     return nsnull;
58485:   }
58485: 
59717:   // XXX - in the future image containers will be manager independent and
59717:   // we can remove the manager equals check and only check the backend type.
62984:   if (mImageContainer) {
62984:     if ((!mImageContainer->Manager() || mImageContainer->Manager() == manager) &&
62984:         mImageContainer->GetBackendType() == manager->GetBackendType())
58485:       return mImageContainer;
62984:     // Clear current image before we reset mImageContainer. Only mImageContainer
62984:     // is allowed to contain the image for this plugin.
62984:     mImageContainer->SetCurrentImage(nsnull);
58485:   }
54223: 
54223:   mImageContainer = manager->CreateImageContainer();
54223:   return mImageContainer;
54223: }
54223: 
62982: nsRect
62982: nsObjectFrame::GetPaintedRect(nsDisplayPlugin* aItem)
62982: {
62982:   if (!mInstanceOwner)
62982:     return nsRect();
62982:   nsRect r = GetContentRect() - GetPosition();
62982:   if (!mInstanceOwner->UseAsyncRendering())
62982:     return r;
62982: 
62982:   nsIntSize size = mInstanceOwner->GetCurrentImageSize();
62982:   nsPresContext* pc = PresContext();
62982:   r.IntersectRect(r, nsRect(0, 0, pc->DevPixelsToAppUnits(size.width),
62982:                                   pc->DevPixelsToAppUnits(size.height)));
62982:   return r;
62982: }
62982: 
59486: class AsyncPaintWaitEvent : public nsRunnable
59486: {
59486: public:
59486:   AsyncPaintWaitEvent(nsIContent* aContent, PRBool aFinished) :
59486:     mContent(aContent), mFinished(aFinished)
59486:   {
59486:   }
59486: 
59486:   NS_IMETHOD Run()
59486:   {
59486:     nsContentUtils::DispatchTrustedEvent(mContent->GetOwnerDoc(), mContent,
59486:         mFinished ? NS_LITERAL_STRING("MozPaintWaitFinished") : NS_LITERAL_STRING("MozPaintWait"),
59486:         PR_TRUE, PR_TRUE);
59486:     return NS_OK;
59486:   }
59486: 
59486: private:
59486:   nsCOMPtr<nsIContent> mContent;
59486:   PRPackedBool         mFinished;
59486: };
59486: 
54223: void
58634: nsPluginInstanceOwner::NotifyPaintWaiter(nsDisplayListBuilder* aBuilder)
54223: {
54223:   // This is notification for reftests about async plugin paint start
54223:   if (!mWaitingForPaint && !IsUpToDate() && aBuilder->ShouldSyncDecodeImages()) {
59486:     nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(mContent, PR_FALSE);
59486:     // Run this event as soon as it's safe to do so, since listeners need to
59486:     // receive it immediately
59486:     mWaitingForPaint = nsContentUtils::AddScriptRunner(event);
54223:   }
54223: }
54223: 
62724: static void DrawPlugin(ImageContainer* aContainer, void* aObjectFrame)
62724: {
62724:   static_cast<nsObjectFrame*>(aObjectFrame)->UpdateImageLayer(aContainer, gfxRect(0,0,0,0));
62724: }
62724: 
62724: void
62724: nsObjectFrame::UpdateImageLayer(ImageContainer* aContainer, const gfxRect& aRect)
62724: {
63222:   if (!mInstanceOwner) {
63222:     return;
63222:   }
63222: 
62724: #ifdef XP_MACOSX
62724:   mInstanceOwner->DoCocoaEventDrawRect(aRect, nsnull);
62724: #endif
62724: 
62724:   mInstanceOwner->SetCurrentImage(aContainer);
62724: }
62724: 
54223: PRBool
54223: nsPluginInstanceOwner::SetCurrentImage(ImageContainer* aContainer)
54223: {
62473:   nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = do_QueryInterface(mInstance);
62473:   if (inst) {
62473:     nsRefPtr<Image> image;
62473:     inst->GetImage(aContainer, getter_AddRefs(image));
62473:     if (image) {
62724: #ifdef XP_MACOSX
63222:       if (image->GetFormat() == Image::MAC_IO_SURFACE && mObjectFrame) {
62724:         MacIOSurfaceImage *oglImage = static_cast<MacIOSurfaceImage*>(image.get());
62724:         oglImage->SetCallback(&DrawPlugin, mObjectFrame);
62724:       }
62724: #endif
62473:       aContainer->SetCurrentImage(image);
62473:       return PR_TRUE;
62473:     }
62473:   }
57516:   aContainer->SetCurrentImage(nsnull);
54223:   return PR_FALSE;
57516: }
54223: 
62704: void
62704: nsPluginInstanceOwner::SetBackgroundUnknown()
62704: {
62704:   nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = GetInstance();
62704:   if (inst) {
62704:     inst->SetBackgroundUnknown();
62704:   }
62704: }
62704: 
62704: already_AddRefed<gfxContext>
62704: nsPluginInstanceOwner::BeginUpdateBackground(const nsIntRect& aRect)
62704: {
62704:   nsIntRect rect = aRect;
62704:   nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = GetInstance();
62704:   nsRefPtr<gfxContext> ctx;
62704:   if (inst &&
62704:       NS_SUCCEEDED(inst->BeginUpdateBackground(&rect, getter_AddRefs(ctx)))) {
62704:     return ctx.forget();
62704:   }
62704:   return nsnull;
62704: }
62704: 
62704: void
62704: nsPluginInstanceOwner::EndUpdateBackground(gfxContext* aContext,
62704:                                            const nsIntRect& aRect)
62704: {
62704:   nsIntRect rect = aRect;
62704:   nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = GetInstance();
62704:   if (inst) {
62704:     inst->EndUpdateBackground(aContext, &rect);
62704:   }
62704: }
62704: 
62982: nsIntSize
62982: nsPluginInstanceOwner::GetCurrentImageSize()
62982: {
62982:   nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = GetInstance();
62982:   nsIntSize size(0,0);
62982:   if (inst) {
62982:     inst->GetImageSize(&size);
62982:   }
62982:   return size;
62982: }
62982: 
62982: LayerState
62224: nsObjectFrame::GetLayerState(nsDisplayListBuilder* aBuilder,
62224:                              LayerManager* aManager)
62224: {
62474:   if (!mInstanceOwner)
62982:     return LAYER_NONE;
62474: 
62474: #ifdef XP_MACOSX
62699:   if (aManager &&
62699:       aManager->GetBackendType() == LayerManager::LAYERS_OPENGL &&
62474:       mInstanceOwner->GetEventModel() == NPEventModelCocoa &&
62474:       mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreGraphics &&
62474:       mInstanceOwner->IsRemoteDrawingCoreAnimation())
62474:   {
62982:     return LAYER_ACTIVE;
62474:   }
62474: #endif
62474: 
62474:   if (!mInstanceOwner->UseAsyncRendering())
62982:     return LAYER_NONE;
62982: 
62982:   return LAYER_ACTIVE;
54223: }
54223: 
54223: already_AddRefed<Layer>
54223: nsObjectFrame::BuildLayer(nsDisplayListBuilder* aBuilder,
54223:                           LayerManager* aManager,
54223:                           nsDisplayItem* aItem)
54223: {
54223:   if (!mInstanceOwner)
54223:     return nsnull;
54223: 
54223:   NPWindow* window = nsnull;
54223:   mInstanceOwner->GetWindow(window);
54223:   if (!window)
54223:     return nsnull;
54223: 
54223:   if (window->width <= 0 || window->height <= 0)
54223:     return nsnull;
54223: 
62699:   // Create image
62699:   nsRefPtr<ImageContainer> container = GetImageContainer(aManager);
62699:   if (!container)
62699:     return nsnull;
62984: 
62984:   {
62984:     nsRefPtr<Image> current = container->GetCurrentImage();
62984:     if (!current) {
62984:       // Only set the current image if there isn't already one. If there is
62984:       // already one, InvalidateRect() will be keeping it up to date.
62984:       if (!mInstanceOwner->SetCurrentImage(container))
62699:         return nsnull;
62699:     }
62699:   }
62984: 
62699:   gfxIntSize size = container->GetCurrentSize();
62699: 
54223:   nsRect area = GetContentRect() + aBuilder->ToReferenceFrame(GetParent());
54223:   gfxRect r = nsLayoutUtils::RectToGfxRect(area, PresContext()->AppUnitsPerDevPixel());
54223:   // to provide crisper and faster drawing.
54223:   r.Round();
54223:   nsRefPtr<Layer> layer =
54223:     (aBuilder->LayerBuilder()->GetLeafLayerFor(aBuilder, aManager, aItem));
54223: 
62699:   if (aItem->GetType() == nsDisplayItem::TYPE_PLUGIN) {
54223:     if (!layer) {
58634:       mInstanceOwner->NotifyPaintWaiter(aBuilder);
54223:       // Initialize ImageLayer
54223:       layer = aManager->CreateImageLayer();
54223:       if (!layer)
54223:         return nsnull;
62699:     }
62224: 
62699:     NS_ASSERTION(layer->GetType() == Layer::TYPE_IMAGE, "Bad layer type");
54223: 
54223:     ImageLayer* imglayer = static_cast<ImageLayer*>(layer.get());
62724:     UpdateImageLayer(container, r);
62724: 
54223:     imglayer->SetContainer(container);
54223:     imglayer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(this));
54223: 
54223:     layer->SetContentFlags(IsOpaque() ? Layer::CONTENT_OPAQUE : 0);
62699:   } else {
62699:     NS_ASSERTION(aItem->GetType() == nsDisplayItem::TYPE_PLUGIN_READBACK,
62699:                  "Unknown item type");
62699:     NS_ABORT_IF_FALSE(!IsOpaque(), "Opaque plugins don't use backgrounds");
62699: 
62699:     if (!layer) {
62699:       layer = aManager->CreateReadbackLayer();
62699:       if (!layer)
62699:         return nsnull;
62699:     }
62699:     NS_ASSERTION(layer->GetType() == Layer::TYPE_READBACK, "Bad layer type");
62699: 
62699:     ReadbackLayer* readback = static_cast<ReadbackLayer*>(layer.get());
62699:     if (readback->GetSize() != nsIntSize(size.width, size.height)) {
62699:       // This will destroy any old background sink and notify us that the
62699:       // background is now unknown
62699:       readback->SetSink(nsnull);
62699:       readback->SetSize(nsIntSize(size.width, size.height));
62699: 
63204:       if (mBackgroundSink) {
63204:         // Maybe we still have a background sink associated with another
63204:         // readback layer that wasn't recycled for some reason? Unhook it
63204:         // now so that if this frame goes away, it doesn't have a dangling
63204:         // reference to us.
63204:         mBackgroundSink->Destroy();
63204:       }
62699:       mBackgroundSink =
62699:         new PluginBackgroundSink(this,
62699:                                  readback->AllocateSequenceNumber());
62699:       readback->SetSink(mBackgroundSink);
62699:       // The layer has taken ownership of our sink. When either the sink dies
62699:       // or the frame dies, the connection from the surviving object is nulled out.
62699:     }
62699:   }
54223: 
54223:   // Set a transform on the layer to draw the plugin in the right place
54223:   gfxMatrix transform;
54223:   transform.Translate(r.pos);
54223: 
54223:   layer->SetTransform(gfx3DMatrix::From2D(transform));
62985:   layer->SetVisibleRegion(nsIntRect(0, 0, size.width, size.height));
62699:   return layer.forget();
54223: }
54223: 
    1: void
56434: nsObjectFrame::PaintPlugin(nsDisplayListBuilder* aBuilder,
56434:                            nsIRenderingContext& aRenderingContext,
33369:                            const nsRect& aDirtyRect, const nsRect& aPluginRect)
    1: {
    1:   // Screen painting code
    1: #if defined(XP_MACOSX)
    1:   // delegate all painting to the plugin instance.
11944:   if (mInstanceOwner) {
39757:     if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreGraphics ||
43370:         mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:         mInstanceOwner->GetDrawingModel() == 
43370:                                   NPDrawingModelInvalidatingCoreAnimation) {
29811:       PRInt32 appUnitsPerDevPixel = PresContext()->AppUnitsPerDevPixel();
29811:       // Clip to the content area where the plugin should be drawn. If
29811:       // we don't do this, the plugin can draw outside its bounds.
33369:       nsIntRect contentPixels = aPluginRect.ToNearestPixels(appUnitsPerDevPixel);
29811:       nsIntRect dirtyPixels = aDirtyRect.ToOutsidePixels(appUnitsPerDevPixel);
29811:       nsIntRect clipPixels;
29811:       clipPixels.IntersectRect(contentPixels, dirtyPixels);
43369: 
43369:       // Don't invoke the drawing code if the clip is empty.
43369:       if (clipPixels.IsEmpty())
43369:         return;
43369: 
29811:       gfxRect nativeClipRect(clipPixels.x, clipPixels.y,
29811:                              clipPixels.width, clipPixels.height);
11944:       gfxContext* ctx = aRenderingContext.ThebesContext();
29811: 
29811:       gfxContextAutoSaveRestore save(ctx);
29811:       ctx->NewPath();
29811:       ctx->Rectangle(nativeClipRect);
29811:       ctx->Clip();
29811:       gfxPoint offset(contentPixels.x, contentPixels.y);
29811:       ctx->Translate(offset);
29811: 
29811:       gfxQuartzNativeDrawing nativeDrawing(ctx, nativeClipRect - offset);
11944: 
11944:       CGContextRef cgContext = nativeDrawing.BeginNativeDrawing();
11944:       if (!cgContext) {
11944:         NS_WARNING("null CGContextRef during PaintPlugin");
11944:         return;
11944:       }
11944: 
12241:       nsCOMPtr<nsIPluginInstance> inst;
12241:       GetPluginInstance(*getter_AddRefs(inst));
12241:       if (!inst) {
12241:         NS_WARNING("null plugin instance during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
12241:         return;
12241:       }
32799:       NPWindow* window;
12241:       mInstanceOwner->GetWindow(window);
12241:       if (!window) {
12241:         NS_WARNING("null plugin window during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
12241:         return;
12241:       }
32799:       NP_CGContext* cgPluginPortCopy =
32799:                 static_cast<NP_CGContext*>(mInstanceOwner->GetPluginPortCopy());
32799:       if (!cgPluginPortCopy) {
21108:         NS_WARNING("null plugin port copy during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
21108:         return;
21108:       }
37446: #ifndef NP_NO_CARBON
37446:       if (mInstanceOwner->GetEventModel() == NPEventModelCarbon &&
37446:           !mInstanceOwner->SetPluginPortAndDetectChange()) {
21108:         NS_WARNING("null plugin port during PaintPlugin");
21108:         nativeDrawing.EndNativeDrawing();
21108:         return;
21108:       }
34737: 
34717:       // In the Carbon event model...
21108:       // If gfxQuartzNativeDrawing hands out a CGContext different from the
21108:       // one set by SetPluginPortAndDetectChange(), we need to pass it to the
21108:       // plugin via SetWindow().  This will happen in nsPluginInstanceOwner::
21108:       // FixUpPluginWindow(), called from nsPluginInstanceOwner::Paint().
21108:       // (If SetPluginPortAndDetectChange() made any changes itself, this has
21108:       // already been detected in that method, and will likewise result in a
21108:       // call to SetWindow() from FixUpPluginWindow().)
32799:       NP_CGContext* windowContext = static_cast<NP_CGContext*>(window->window);
34717:       if (mInstanceOwner->GetEventModel() == NPEventModelCarbon &&
34717:           windowContext->context != cgContext) {
32799:         windowContext->context = cgContext;
32799:         cgPluginPortCopy->context = cgContext;
21108:         mInstanceOwner->SetPluginPortChanged(PR_TRUE);
21108:       }
34737: #endif
21108: 
21108:       mInstanceOwner->BeginCGPaint();
43370:       if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:           mInstanceOwner->GetDrawingModel() == 
43370:                                    NPDrawingModelInvalidatingCoreAnimation) {
39757:         // CoreAnimation is updated, render the layer and perform a readback.
39757:         mInstanceOwner->RenderCoreAnimation(cgContext, window->width, window->height);
39757:       } else {
34717:         mInstanceOwner->Paint(nativeClipRect - offset, cgContext);
39757:       }
21108:       mInstanceOwner->EndCGPaint();
11944: 
11944:       nativeDrawing.EndNativeDrawing();
11944:     } else {
29811:       // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
29811:       nsIRenderingContext::AutoPushTranslation
33369:         translate(&aRenderingContext, aPluginRect.x, aPluginRect.y);
29811: 
32019:       // this rect is used only in the CoreGraphics drawing model
32019:       gfxRect tmpRect(0, 0, 0, 0);
34717:       mInstanceOwner->Paint(tmpRect, NULL);
11944:     }
11944:   }
47118: #elif defined(MOZ_X11)
21080:   if (mInstanceOwner) {
32799:     NPWindow *window;
 3059:     mInstanceOwner->GetWindow(window);
25500: #ifdef MOZ_COMPOSITED_PLUGINS
25500:     {
25500: #else
32799:     if (window->type == NPWindowTypeDrawable) {
25500: #endif
15688:       gfxRect frameGfxRect =
33369:         PresContext()->AppUnitsToGfxUnits(aPluginRect);
15688:       gfxRect dirtyGfxRect =
15688:         PresContext()->AppUnitsToGfxUnits(aDirtyRect);
15688:       gfxContext* ctx = aRenderingContext.ThebesContext();
15688: 
15688:       mInstanceOwner->Paint(ctx, frameGfxRect, dirtyGfxRect);
15688:     }
 3059:   }
21080: #elif defined(XP_WIN)
    1:   nsCOMPtr<nsIPluginInstance> inst;
    1:   GetPluginInstance(*getter_AddRefs(inst));
    1:   if (inst) {
21080:     gfxRect frameGfxRect =
33369:       PresContext()->AppUnitsToGfxUnits(aPluginRect);
21080:     gfxRect dirtyGfxRect =
21080:       PresContext()->AppUnitsToGfxUnits(aDirtyRect);
21080:     gfxContext *ctx = aRenderingContext.ThebesContext();
21080:     gfxMatrix currentMatrix = ctx->CurrentMatrix();
21080: 
21080:     if (ctx->UserToDevicePixelSnapped(frameGfxRect, PR_FALSE)) {
21080:       dirtyGfxRect = ctx->UserToDevice(dirtyGfxRect);
21080:       ctx->IdentityMatrix();
21080:     }
21080:     dirtyGfxRect.RoundOut();
21080: 
    1:     // Look if it's windowless
32799:     NPWindow *window;
    1:     mInstanceOwner->GetWindow(window);
    1: 
32799:     if (window->type == NPWindowTypeDrawable) {
    1:       // the offset of the DC
19835:       nsPoint origin;
    1: 
21080:       gfxWindowsNativeDrawing nativeDraw(ctx, frameGfxRect);
36270: #ifdef MOZ_IPC
36270:       if (nativeDraw.IsDoublePass()) {
36270:         // OOP plugin specific: let the shim know before we paint if we are doing a
36270:         // double pass render. If this plugin isn't oop, the register window message
36270:         // will be ignored.
36270:         NPEvent pluginEvent;
62699:         pluginEvent.event = DoublePassRenderingEvent();
36270:         pluginEvent.wParam = 0;
36270:         pluginEvent.lParam = 0;
50668:         if (pluginEvent.event)
43436:           inst->HandleEvent(&pluginEvent, nsnull);
36270:       }
36270: #endif
21080:       do {
21080:         HDC hdc = nativeDraw.BeginNativeDrawing();
21080:         if (!hdc)
    1:           return;
21080: 
21080:         RECT dest;
21080:         nativeDraw.TransformToNativeRect(frameGfxRect, dest);
21080:         RECT dirty;
21080:         nativeDraw.TransformToNativeRect(dirtyGfxRect, dirty);
21080: 
32799:         window->window = hdc;
21080:         window->x = dest.left;
21080:         window->y = dest.top;
57225:         window->clipRect.left = 0;
57225:         window->clipRect.top = 0;
57225:         // if we're painting, we're visible.
57225:         window->clipRect.right = window->width;
57225:         window->clipRect.bottom = window->height;
21080: 
36271:         // Windowless plugins on windows need a special event to update their location,
36271:         // see bug 135737.
36271:         //
    1:         // bug 271442: note, the rectangle we send is now purely the bounds of the plugin
36271:         // relative to the window it is contained in, which is useful for the plugin to
36271:         // correctly translate mouse coordinates.
    1:         //
    1:         // this does not mesh with the comments for bug 135737 which imply that the rectangle
36271:         // must be clipped in some way to prevent the plugin attempting to paint over areas
36271:         // it shouldn't.
    1:         //
36271:         // since the two uses of the rectangle are mutually exclusive in some cases, and
36271:         // since I don't see any incorrect painting (at least with Flash and ViewPoint -
36271:         // the originator of bug 135737), it seems that windowless plugins are not relying
36271:         // on information here for clipping their drawing, and we can safely use this message
36271:         // to tell the plugin exactly where it is in all cases.
    1: 
21080:         nsIntPoint origin = GetWindowOriginInPixels(PR_TRUE);
23738:         nsIntRect winlessRect = nsIntRect(origin, nsIntSize(window->width, window->height));
57232: 
57234:         if (mWindowlessRect != winlessRect) {
    1:           mWindowlessRect = winlessRect;
    1: 
    1:           WINDOWPOS winpos;
    1:           memset(&winpos, 0, sizeof(winpos));
    1:           winpos.x = mWindowlessRect.x;
    1:           winpos.y = mWindowlessRect.y;
    1:           winpos.cx = mWindowlessRect.width;
    1:           winpos.cy = mWindowlessRect.height;
    1: 
    1:           // finally, update the plugin by sending it a WM_WINDOWPOSCHANGED event
32799:           NPEvent pluginEvent;
    1:           pluginEvent.event = WM_WINDOWPOSCHANGED;
    1:           pluginEvent.wParam = 0;
43548:           pluginEvent.lParam = (LPARAM)&winpos;
43436:           inst->HandleEvent(&pluginEvent, nsnull);
57234:         }
    1: 
    1:         inst->SetWindow(window);
57234: 
21080:         mInstanceOwner->Paint(dirty, hdc);
21080:         nativeDraw.EndNativeDrawing();
36270:       } while (nativeDraw.ShouldRenderAgain());
21080:       nativeDraw.PaintToContext();
21080:     }
21080: 
21080:     ctx->SetMatrix(currentMatrix);
21080:   }
21080: #elif defined(XP_OS2)
21080:   nsCOMPtr<nsIPluginInstance> inst;
21080:   GetPluginInstance(*getter_AddRefs(inst));
21080:   if (inst) {
21080:     // Look if it's windowless
32799:     NPWindow *window;
21080:     mInstanceOwner->GetWindow(window);
21080: 
32799:     if (window->type == NPWindowTypeDrawable) {
21080:       // FIXME - Bug 385435: Doesn't aDirtyRect need translating too?
21080:       nsIRenderingContext::AutoPushTranslation
33369:         translate(&aRenderingContext, aPluginRect.x, aPluginRect.y);
21080: 
21080:       // check if we need to call SetWindow with updated parameters
21080:       PRBool doupdatewindow = PR_FALSE;
21080:       // the offset of the DC
23738:       nsIntPoint origin;
21080: 
21080:       /*
21080:        * Layout now has an optimized way of painting. Now we always get
21080:        * a new drawing surface, sized to be just what's needed. Windowless
21080:        * plugins need a transform applied to their origin so they paint
21080:        * in the right place. Since |SetWindow| is no longer being used
21080:        * to tell the plugin where it is, we dispatch a NPWindow through
21080:        * |HandleEvent| to tell the plugin when its window moved
21080:        */
21080:       gfxContext *ctx = aRenderingContext.ThebesContext();
21080: 
21080:       gfxMatrix ctxMatrix = ctx->CurrentMatrix();
21080:       if (ctxMatrix.HasNonTranslation()) {
21080:         // soo; in the future, we should be able to render
21080:         // the object content to an offscreen DC, and then
21080:         // composite it in with the right transforms.
21080: 
21080:         // But, we don't bother doing that, because we don't
21080:         // have the event handling story figured out yet.
21080:         // Instead, let's just bail.
21080: 
21080:         return;
21080:       }
21080: 
21080:       origin.x = NSToIntRound(float(ctxMatrix.GetTranslation().x));
21080:       origin.y = NSToIntRound(float(ctxMatrix.GetTranslation().y));
21080: 
21080:       /* Need to force the clip to be set */
21080:       ctx->UpdateSurfaceClip();
21080: 
21080:       /* Set the device offsets as appropriate, for whatever our current group offsets might be */
21080:       gfxFloat xoff, yoff;
21080:       nsRefPtr<gfxASurface> surf = ctx->CurrentSurface(&xoff, &yoff);
21080: 
21080:       if (surf->CairoStatus() != 0) {
21080:         NS_WARNING("Plugin is being asked to render to a surface that's in error!");
21080:         return;
21080:       }
21080: 
21080:       // check if we need to update the PS
21080:       HPS hps = (HPS)aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_OS2_PS);
21080:       if (reinterpret_cast<HPS>(window->window) != hps) {
32955:         window->window = reinterpret_cast<void*>(hps);
21080:         doupdatewindow = PR_TRUE;
21080:       }
21080:       LONG lPSid = GpiSavePS(hps);
21080:       RECTL rclViewport;
21080:       if (GpiQueryDevice(hps) != NULLHANDLE) { // ensure that we have an associated HDC
21080:         if (GpiQueryPageViewport(hps, &rclViewport)) {
21080:           rclViewport.xLeft += (LONG)xoff;
21080:           rclViewport.xRight += (LONG)xoff;
21080:           rclViewport.yBottom += (LONG)yoff;
21080:           rclViewport.yTop += (LONG)yoff;
21080:           GpiSetPageViewport(hps, &rclViewport);
21080:         }
21080:       }
21080: 
21080:       if ((window->x != origin.x) || (window->y != origin.y)) {
21080:         window->x = origin.x;
21080:         window->y = origin.y;
21080:         doupdatewindow = PR_TRUE;
21080:       }
21080: 
21080:       // if our location or visible area has changed, we need to tell the plugin
21080:       if (doupdatewindow) {
21080:         inst->SetWindow(window);        
21080:       }
21080: 
12859:       mInstanceOwner->Paint(aDirtyRect, hps);
12859:       if (lPSid >= 1) {
12859:         GpiRestorePS(hps, lPSid);
12859:       }
    1:       surf->MarkDirty();
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::HandleEvent(nsPresContext* aPresContext,
    1:                            nsGUIEvent*     anEvent,
    1:                            nsEventStatus*  anEventStatus)
    1: {
32019:   NS_ENSURE_ARG_POINTER(anEvent);
    1:   NS_ENSURE_ARG_POINTER(anEventStatus);
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!mInstanceOwner)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
13537:   mInstanceOwner->ConsiderNewEventloopNestingLevel();
13537: 
    1:   if (anEvent->message == NS_PLUGIN_ACTIVATE) {
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(GetContent());
29018:     if (fm && elem)
29018:       return fm->SetFocus(elem, 0);
    1:   }
57526:   else if (anEvent->message == NS_PLUGIN_FOCUS) {
57526:     nsIFocusManager_MOZILLA_2_0_BRANCH* fm = nsFocusManager::GetFocusManager();
57526:     if (fm)
57526:       return fm->FocusPlugin(GetContent());
57526:   }
    1: 
41061:   if (mInstanceOwner->SendNativeEvents() &&
41061:       (NS_IS_PLUGIN_EVENT(anEvent) || NS_IS_NON_RETARGETED_PLUGIN_EVENT(anEvent))) {
22788:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
22788:     return rv;
22788:   }
22788: 
    1: #ifdef XP_WIN
    1:   rv = nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
    1:   return rv;
    1: #endif
    1: 
32019: #ifdef XP_MACOSX
34678:   // we want to process some native mouse events in the cocoa event model
34678:   if ((anEvent->message == NS_MOUSE_ENTER || anEvent->message == NS_MOUSE_SCROLL) &&
34678:       mInstanceOwner->GetEventModel() == NPEventModelCocoa) {
32019:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
32019:     return rv;
32019:   }
32019: #endif
32019: 
34742:   if (anEvent->message == NS_DESTROY) {
36227: #ifdef MAC_CARBON_PLUGINS
    1:     mInstanceOwner->CancelTimer();
36227: #endif
    1:     return rv;
    1:   }
    1: 
34742:   return nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
34742: }
34742: 
37413: #ifdef XP_MACOSX
37413: // Needed to make the routing of mouse events while dragging conform to
37413: // standard OS X practice, and to the Cocoa NPAPI spec.  See bug 525078.
37413: NS_IMETHODIMP
37413: nsObjectFrame::HandlePress(nsPresContext* aPresContext,
37413:                            nsGUIEvent*    anEvent,
37413:                            nsEventStatus* anEventStatus)
37413: {
37413:   nsIPresShell::SetCapturingContent(GetContent(), CAPTURE_IGNOREALLOWED);
37413:   return nsObjectFrameSuper::HandlePress(aPresContext, anEvent, anEventStatus);
37413: }
37413: #endif
37413: 
15569: nsresult
15569: nsObjectFrame::GetPluginInstance(nsIPluginInstance*& aPluginInstance)
    1: {
    1:   aPluginInstance = nsnull;
    1: 
    1:   if (!mInstanceOwner)
    1:     return NS_OK;
    1:   
    1:   return mInstanceOwner->GetInstance(aPluginInstance);
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::PrepareInstanceOwner()
    1: {
12744:   nsWeakFrame weakFrame(this);
12744: 
 6312:   // First, have to stop any possibly running plugins.
 6312:   StopPluginInternal(PR_FALSE);
 6312: 
12744:   if (!weakFrame.IsAlive()) {
12744:     return NS_ERROR_NOT_AVAILABLE;
12744:   }
12744: 
    1:   NS_ASSERTION(!mInstanceOwner, "Must not have an instance owner here");
    1: 
    1:   mInstanceOwner = new nsPluginInstanceOwner();
12417: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Created new instance owner %p for frame %p\n", mInstanceOwner.get(),
12417:           this));
12417: 
    1:   if (!mInstanceOwner)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
12417:   // Note, |this| may very well be gone after this call.
12417:   return mInstanceOwner->Init(PresContext(), this, GetContent());
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::Instantiate(nsIChannel* aChannel, nsIStreamListener** aStreamListener)
    1: {
14982:   if (mPreventInstantiation) {
 8609:     return NS_OK;
 8609:   }
 8609:   
12417:   // Note: If PrepareInstanceOwner() returns an error, |this| may very
12417:   // well be deleted already.
    1:   nsresult rv = PrepareInstanceOwner();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   mInstanceOwner->SetPluginHost(pluginHost);
    1: 
    1:   // This must be done before instantiating the plugin
33369:   FixupWindow(GetContentRect().Size());
    1: 
46142:   // Ensure we redraw when a plugin is instantiated
46142:   Invalidate(GetContentRect() - GetPosition());
46142: 
15569:   nsWeakFrame weakFrame(this);
15569: 
14982:   NS_ASSERTION(!mPreventInstantiation, "Say what?");
14982:   mPreventInstantiation = PR_TRUE;
    1:   rv = pluginHost->InstantiatePluginForChannel(aChannel, mInstanceOwner, aStreamListener);
15569: 
15569:   if (!weakFrame.IsAlive()) {
15569:     return NS_ERROR_NOT_AVAILABLE;
15569:   }
15569: 
14982:   NS_ASSERTION(mPreventInstantiation,
14982:                "Instantiation should still be prevented!");
14982:   mPreventInstantiation = PR_FALSE;
    1: 
56292: #ifdef ACCESSIBILITY
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
56292:   if (accService) {
56292:     accService->RecreateAccessible(PresContext()->PresShell(), mContent);
56292:   }
56292: #endif
56292: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::Instantiate(const char* aMimeType, nsIURI* aURI)
    1: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsObjectFrame::Instantiate(%s) called on frame %p\n", aMimeType,
12417:           this));
12417: 
14982:   if (mPreventInstantiation) {
 8609:     return NS_OK;
 8609:   }
 8609: 
56390:   // XXXbz can aMimeType ever actually be null here?  If not, either
56390:   // the callers are wrong (and passing "" instead of null) or we can
56390:   // remove the codepaths dealing with null aMimeType in
56390:   // InstantiateEmbeddedPlugin.
    1:   NS_ASSERTION(aMimeType || aURI, "Need a type or a URI!");
12417: 
12417:   // Note: If PrepareInstanceOwner() returns an error, |this| may very
12417:   // well be deleted already.
    1:   nsresult rv = PrepareInstanceOwner();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
15569:   nsWeakFrame weakFrame(this);
15569: 
    1:   // This must be done before instantiating the plugin
33369:   FixupWindow(GetContentRect().Size());
    1: 
46142:   // Ensure we redraw when a plugin is instantiated
46142:   Invalidate(GetContentRect() - GetPosition());
46142: 
    1:   // get the nsIPluginHost service
29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   mInstanceOwner->SetPluginHost(pluginHost);
    1: 
20078:   NS_ASSERTION(!mPreventInstantiation, "Say what?");
14982:   mPreventInstantiation = PR_TRUE;
14982: 
    1:   rv = InstantiatePlugin(pluginHost, aMimeType, aURI);
    1: 
15569:   if (!weakFrame.IsAlive()) {
15569:     return NS_ERROR_NOT_AVAILABLE;
15569:   }
15569: 
    1:   // finish up
    1:   if (NS_SUCCEEDED(rv)) {
 4189:     TryNotifyContentObjectWrapper();
15569: 
15569:     if (!weakFrame.IsAlive()) {
15569:       return NS_ERROR_NOT_AVAILABLE;
15569:     }
15569: 
 4825:     CallSetWindow();
 4189:   }
 4189: 
14982:   NS_ASSERTION(mPreventInstantiation,
14982:                "Instantiation should still be prevented!");
14982: 
56292: #ifdef ACCESSIBILITY
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
56292:   if (accService) {
56292:     accService->RecreateAccessible(PresContext()->PresShell(), mContent);
56292:   }
56292: #endif
56292: 
14982:   mPreventInstantiation = PR_FALSE;
14982: 
 4189:   return rv;
 4189: }
 4189: 
 4189: void
 4189: nsObjectFrame::TryNotifyContentObjectWrapper()
 4189: {
    1:   nsCOMPtr<nsIPluginInstance> inst;
    1:   mInstanceOwner->GetInstance(*getter_AddRefs(inst));
    1:   if (inst) {
    1:     // The plugin may have set up new interfaces; we need to mess with our JS
    1:     // wrapper.  Note that we DO NOT want to call this if there is no plugin
    1:     // instance!  That would just reenter Instantiate(), trying to create
    1:     // said plugin instance.
    1:     NotifyContentObjectWrapper();
    1:   }
    1: }
    1: 
13537: class nsStopPluginRunnable : public nsRunnable, public nsITimerCallback
    1: {
 4577: public:
13537:   NS_DECL_ISUPPORTS_INHERITED
13537: 
 4577:   nsStopPluginRunnable(nsPluginInstanceOwner *aInstanceOwner)
 4577:     : mInstanceOwner(aInstanceOwner)
 4577:   {
13537:     NS_ASSERTION(aInstanceOwner, "need an owner");
13537:   }
13537: 
13537:   // nsRunnable
 4577:   NS_IMETHOD Run();
 4577: 
13537:   // nsITimerCallback
13537:   NS_IMETHOD Notify(nsITimer *timer);
13537: 
 4577: private:  
13537:   nsCOMPtr<nsITimer> mTimer;
 4577:   nsRefPtr<nsPluginInstanceOwner> mInstanceOwner;
 4577: };
 4577: 
13537: NS_IMPL_ISUPPORTS_INHERITED1(nsStopPluginRunnable, nsRunnable, nsITimerCallback)
13537: 
14123: static const char*
14123: GetMIMEType(nsIPluginInstance *aPluginInstance)
14123: {
29808:   if (aPluginInstance) {
30224:     const char* mime = nsnull;
29808:     if (NS_SUCCEEDED(aPluginInstance->GetMIMEType(&mime)) && mime)
14123:       return mime;
14123:   }
14123:   return "";
14123: }
14123: 
14390: static PRBool
14390: DoDelayedStop(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
14390: {
38014: #if (MOZ_PLATFORM_MAEMO==5)
35241:   // Don't delay stop on Maemo/Hildon (bug 530739).
35241:   if (aDelayedStop && aInstanceOwner->MatchPluginName("Shockwave Flash"))
35241:     return PR_FALSE;
35241: #endif
35241: 
15870:   // Don't delay stopping QuickTime (bug 425157), Flip4Mac (bug 426524),
28366:   // XStandard (bug 430219), CMISS Zinc (bug 429604).
15870:   if (aDelayedStop
28366: #if !(defined XP_WIN || defined MOZ_X11)
22788:       && !aInstanceOwner->MatchPluginName("QuickTime")
22788:       && !aInstanceOwner->MatchPluginName("Flip4Mac")
22788:       && !aInstanceOwner->MatchPluginName("XStandard plugin")
22788:       && !aInstanceOwner->MatchPluginName("CMISS Zinc Plugin")
15870: #endif
15870:       ) {
14390:     nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(aInstanceOwner);
14390:     NS_DispatchToCurrentThread(evt);
14390:     return PR_TRUE;
14390:   }
14390:   return PR_FALSE;
14390: }
14390: 
 4577: static void
13300: DoStopPlugin(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
 4577: {
    1:   nsCOMPtr<nsIPluginInstance> inst;
 4577:   aInstanceOwner->GetInstance(*getter_AddRefs(inst));
    1:   if (inst) {
32799:     NPWindow *win;
 4577:     aInstanceOwner->GetWindow(win);
    1:     nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
    1:     nsCOMPtr<nsIPluginInstance> nullinst;
    1: 
    1:     if (window) 
    1:       window->CallSetWindow(nullinst);
    1:     else 
    1:       inst->SetWindow(nsnull);
    1:     
14390:     if (DoDelayedStop(aInstanceOwner, aDelayedStop))
13044:       return;
13044: 
56652: #if defined(XP_MACOSX)
56652:     aInstanceOwner->HidePluginWindow();
56652: #endif
56652: 
29574:     nsCOMPtr<nsIPluginHost> pluginHost = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
59756:     NS_ASSERTION(pluginHost, "Without a pluginHost, how can we have an instance to destroy?");
    1:     pluginHost->StopPluginInstance(inst);
    1: 
 4577:     // the frame is going away along with its widget so tell the
 4577:     // window to forget its widget too
    1:     if (window)
    1:       window->SetPluginWidget(nsnull);
    1:   }
    1: 
 4577:   aInstanceOwner->Destroy();
 4577: }
 4577: 
 4577: NS_IMETHODIMP
13537: nsStopPluginRunnable::Notify(nsITimer *aTimer)
13537: {
13537:   return Run();
13537: }
13537: 
13537: NS_IMETHODIMP
 4577: nsStopPluginRunnable::Run()
 4577: {
13537:   // InitWithCallback calls Release before AddRef so we need to hold a
13537:   // strong ref on 'this' since we fall through to this scope if it fails.
13537:   nsCOMPtr<nsITimerCallback> kungFuDeathGrip = this;
13537:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
13537:   if (appShell) {
13537:     PRUint32 currentLevel = 0;
13537:     appShell->GetEventloopNestingLevel(&currentLevel);
13537:     if (currentLevel > mInstanceOwner->GetLastEventloopNestingLevel()) {
13537:       if (!mTimer)
13537:         mTimer = do_CreateInstance("@mozilla.org/timer;1");
13537:       if (mTimer) {
13589:         // Fire 100ms timer to try to tear down this plugin as quickly as
13589:         // possible once the nesting level comes back down.
13589:         nsresult rv = mTimer->InitWithCallback(this, 100, nsITimer::TYPE_ONE_SHOT);
13537:         if (NS_SUCCEEDED(rv)) {
13537:           return rv;
13537:         }
13537:       }
13537:       NS_ERROR("Failed to setup a timer to stop the plugin later (at a safe "
13537:                "time). Stopping the plugin now, this might crash.");
13537:     }
13537:   }
13537: 
13537:   mTimer = nsnull;
13537: 
13300:   DoStopPlugin(mInstanceOwner, PR_FALSE);
 4577: 
 4577:   return NS_OK;
 4577: }
 4577: 
 4577: void
 4577: nsObjectFrame::StopPlugin()
 4577: {
14123:   PRBool delayedStop = PR_FALSE;
13537: #ifdef XP_WIN
13537:   nsCOMPtr<nsIPluginInstance> inst;
13537:   if (mInstanceOwner)
13537:     mInstanceOwner->GetInstance(*getter_AddRefs(inst));
13537:   if (inst) {
14123:     // Delayed stop for Real plugin only; see bug 420886, 426852.
14123:     const char* pluginType = ::GetMIMEType(inst);
14123:     delayedStop = strcmp(pluginType, "audio/x-pn-realaudio-plugin") == 0;
14123:   }
14123: #endif
13537:   StopPluginInternal(delayedStop);
 4577: }
 4577: 
 4577: void
 4577: nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)
 4577: {
12744:   if (!mInstanceOwner) {
 4577:     return;
 4577:   }
 4577: 
57224:   nsRootPresContext* rpc = PresContext()->GetRootPresContext();
57224:   if (!rpc) {
57224:     NS_ASSERTION(PresContext()->PresShell()->IsFrozen(),
57224:                  "unable to unregister the plugin frame");
57224:   }
57224:   else if (mWidget) {
57224:     rpc->UnregisterPluginForGeometryUpdates(this);
50855: 
50855:     // Make sure the plugin is hidden in case an update of plugin geometry
50855:     // hasn't happened since this plugin became hidden.
50855:     nsIWidget* parent = mWidget->GetParent();
50855:     if (parent) {
50855:       nsTArray<nsIWidget::Configuration> configurations;
50855:       GetEmptyClipConfiguration(&configurations);
50855:       parent->ConfigureChildren(configurations);
50855:     }
37502:   }
56619:   else {
57224: #ifndef XP_MACOSX
57224:     rpc->UnregisterPluginForGeometryUpdates(this);
57224: #endif
56619:   }
37502: 
12744:   // Transfer the reference to the instance owner onto the stack so
12744:   // that if we do end up re-entering this code, or if we unwind back
12744:   // here witha deleted frame (this), we can still continue to stop
12744:   // the plugin. Note that due to that, the ordering of the code in
12744:   // this function is extremely important.
12744: 
12744:   nsRefPtr<nsPluginInstanceOwner> owner;
12744:   owner.swap(mInstanceOwner);
12744: 
12744:   // Make sure that our windowless rect has been zeroed out, so if we
12744:   // get reinstantiated we'll send the right messages to the plug-in.
12744:   mWindowlessRect.Empty();
12744: 
14982:   PRBool oldVal = mPreventInstantiation;
14982:   mPreventInstantiation = PR_TRUE;
14982: 
14982:   nsWeakFrame weakFrame(this);
14982: 
28366: #if defined(XP_WIN) || defined(MOZ_X11)
30522:   if (aDelayedStop && mWidget) {
12744:     // If we're asked to do a delayed stop it means we're stopping the
30522:     // plugin because we're destroying the frame. In that case, disown
30522:     // the widget.
33864:     mInnerView->DetachWidgetEventHandler(mWidget);
30522:     mWidget = nsnull;
12744:   }
12744: #endif
12744: 
12744:   // From this point on, |this| could have been deleted, so don't
12744:   // touch it!
12744:   owner->PrepareToStop(aDelayedStop);
 4577: 
13300:   DoStopPlugin(owner, aDelayedStop);
 4577: 
14982:   // If |this| is still alive, reset mPreventInstantiation.
14982:   if (weakFrame.IsAlive()) {
14982:     NS_ASSERTION(mPreventInstantiation,
14982:                  "Instantiation should still be prevented!");
14982: 
14982:     mPreventInstantiation = oldVal;
14982:   }
14982: 
 4577:   // Break relationship between frame and plugin instance owner
12744:   owner->SetOwner(nsnull);
    1: }
    1: 
    1: void
    1: nsObjectFrame::NotifyContentObjectWrapper()
    1: {
    1:   nsCOMPtr<nsIDocument> doc = mContent->GetDocument();
    1:   if (!doc)
    1:     return;
    1: 
    1:   nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
    1:   if (!sgo)
    1:     return;
    1: 
    1:   nsIScriptContext *scx = sgo->GetContext();
    1:   if (!scx)
    1:     return;
    1: 
    1:   JSContext *cx = (JSContext *)scx->GetNativeContext();
    1: 
    1:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:   nsContentUtils::XPConnect()->
    1:     GetWrappedNativeOfNativeObject(cx, sgo->GetGlobalJSObject(), mContent,
    1:                                    NS_GET_IID(nsISupports),
    1:                                    getter_AddRefs(wrapper));
    1: 
    1:   if (!wrapper) {
13098:     // Nothing to do here if there's no wrapper for mContent. The proto
13098:     // chain will be fixed appropriately when the wrapper is created.
    1:     return;
    1:   }
    1: 
    1:   JSObject *obj = nsnull;
    1:   nsresult rv = wrapper->GetJSObject(&obj);
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
13098:   nsHTMLPluginObjElementSH::SetupProtoChain(wrapper, cx, obj);
10158: }
    1: 
    1: // static
    1: nsIObjectFrame *
    1: nsObjectFrame::GetNextObjectFrame(nsPresContext* aPresContext, nsIFrame* aRoot)
    1: {
    1:   nsIFrame* child = aRoot->GetFirstChild(nsnull);
    1: 
    1:   while (child) {
23554:     nsIObjectFrame* outFrame = do_QueryFrame(child);
    1:     if (outFrame) {
    1:       nsCOMPtr<nsIPluginInstance> pi;
    1:       outFrame->GetPluginInstance(*getter_AddRefs(pi));  // make sure we have a REAL plugin
    1:       if (pi)
    1:         return outFrame;
    1:     }
    1: 
    1:     outFrame = GetNextObjectFrame(aPresContext, child);
    1:     if (outFrame)
    1:       return outFrame;
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
54309: /*static*/ void
54309: nsObjectFrame::BeginSwapDocShells(nsIContent* aContent, void*)
54309: {
54309:   NS_PRECONDITION(aContent, "");
54309: 
54309:   // This function is called from a document content enumerator so we need
54309:   // to filter out the nsObjectFrames and ignore the rest.
54309:   nsIObjectFrame* obj = do_QueryFrame(aContent->GetPrimaryFrame());
54309:   if (!obj)
54309:     return;
54309: 
54309:   nsObjectFrame* objectFrame = static_cast<nsObjectFrame*>(obj);
54309:   NS_ASSERTION(!objectFrame->mWidget || objectFrame->mWidget->GetParent(),
54309:                "Plugin windows must not be toplevel");
54309:   nsRootPresContext* rootPC = objectFrame->PresContext()->GetRootPresContext();
54309:   NS_ASSERTION(rootPC, "unable to unregister the plugin frame");
54309:   rootPC->UnregisterPluginForGeometryUpdates(objectFrame);
54309: }
54309: 
54309: /*static*/ void
54309: nsObjectFrame::EndSwapDocShells(nsIContent* aContent, void*)
54309: {
54309:   NS_PRECONDITION(aContent, "");
54309: 
54309:   // This function is called from a document content enumerator so we need
54309:   // to filter out the nsObjectFrames and ignore the rest.
54309:   nsIObjectFrame* obj = do_QueryFrame(aContent->GetPrimaryFrame());
54309:   if (!obj)
54309:     return;
54309: 
54309:   nsObjectFrame* objectFrame = static_cast<nsObjectFrame*>(obj);
54309:   nsRootPresContext* rootPC = objectFrame->PresContext()->GetRootPresContext();
54309:   NS_ASSERTION(rootPC, "unable to register the plugin frame");
54309:   nsIWidget* widget = objectFrame->GetWidget();
54309:   if (widget) {
54309:     // Reparent the widget.
54309:     nsIWidget* parent =
54309:       rootPC->PresShell()->GetRootFrame()->GetNearestWidget();
54309:     widget->SetParent(parent);
54309:     objectFrame->CallSetWindow();
54309: 
54309:     // Register for geometry updates and make a request.
54309:     rootPC->RegisterPluginForGeometryUpdates(objectFrame);
54309:     rootPC->RequestUpdatePluginGeometry(objectFrame);
54309:   }
54309: }
54309: 
    1: nsIFrame*
    1: NS_NewObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsObjectFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsObjectFrame)
32423: 
    1: 
    1: // nsPluginDOMContextMenuListener class implementation
    1: 
    1: nsPluginDOMContextMenuListener::nsPluginDOMContextMenuListener()
    1: {
    1: }
    1: 
    1: nsPluginDOMContextMenuListener::~nsPluginDOMContextMenuListener()
    1: {
    1: }
    1: 
32297: NS_IMPL_ISUPPORTS2(nsPluginDOMContextMenuListener,
14031:                    nsIDOMContextMenuListener,
32297:                    nsIDOMEventListener)
    1: 
    1: NS_IMETHODIMP
    1: nsPluginDOMContextMenuListener::ContextMenu(nsIDOMEvent* aContextMenuEvent)
    1: {
    1:   aContextMenuEvent->PreventDefault(); // consume event
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginDOMContextMenuListener::Init(nsIContent* aContent)
    1: {
    1:   nsCOMPtr<nsIDOMEventTarget> receiver(do_QueryInterface(aContent));
    1:   if (receiver) {
    1:     receiver->AddEventListener(NS_LITERAL_STRING("contextmenu"), this, PR_TRUE);
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: nsresult nsPluginDOMContextMenuListener::Destroy(nsIContent* aContent)
    1: {
    1:   // Unregister context menu listener
    1:   nsCOMPtr<nsIDOMEventTarget> receiver(do_QueryInterface(aContent));
    1:   if (receiver) {
    1:     receiver->RemoveEventListener(NS_LITERAL_STRING("contextmenu"), this, PR_TRUE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //plugin instance owner
    1: 
    1: nsPluginInstanceOwner::nsPluginInstanceOwner()
    1: {
32799:   // create nsPluginNativeWindow object, it is derived from NPWindow
    1:   // struct and allows to manipulate native window procedure
29574:   nsCOMPtr<nsIPluginHost> ph = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
29919:   if (ph)
29919:     ph->NewPluginNativeWindow(&mPluginWindow);
    1:   else
    1:     mPluginWindow = nsnull;
    1: 
34679:   mObjectFrame = nsnull;
    1:   mTagText = nsnull;
21108: #ifdef XP_MACOSX
32799:   memset(&mCGPluginPortCopy, 0, sizeof(NP_CGContext));
43652: #ifndef NP_NO_QUICKDRAW
32799:   memset(&mQDPluginPortCopy, 0, sizeof(NP_Port));
43652: #endif
21108:   mInCGPaintLevel = 0;
41061:   mSentInitialTopLevelWindowEvent = PR_FALSE;
42504:   mIOSurface = nsnull;
47115:   mPluginPortChanged = PR_FALSE;
21108: #endif
    1:   mContentFocused = PR_FALSE;
    1:   mWidgetVisible = PR_TRUE;
57224:   mPluginWindowVisible = PR_FALSE;
    1:   mNumCachedAttrs = 0;
    1:   mNumCachedParams = 0;
    1:   mCachedAttrParamNames = nsnull;
    1:   mCachedAttrParamValues = nsnull;
 4577:   mDestroyWidget = PR_FALSE;
12417: 
25500: #ifdef MOZ_COMPOSITED_PLUGINS
25500:   mLastPoint = nsIntPoint(0,0);
25500: #endif
25500: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35171:   mPluginSize = nsIntSize(0,0);
35197:   mXlibSurfGC = None;
37357:   mBlitWindow = nsnull;
35171:   mSharedXImage = nsnull;
35171:   mSharedSegmentInfo.shmaddr = nsnull;
34717: #endif
35174: 
35174: #ifdef XP_MACOSX
35174: #ifndef NP_NO_QUICKDRAW
35174:   mEventModel = NPEventModelCarbon;
35174: #else
35174:   mEventModel = NPEventModelCocoa;
35174: #endif
35174: #endif
54223: 
54223:   mWaitingForPaint = PR_FALSE;
54223: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsPluginInstanceOwner %p created\n", this));
    1: }
    1: 
    1: nsPluginInstanceOwner::~nsPluginInstanceOwner()
    1: {
    1:   PRInt32 cnt;
    1: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsPluginInstanceOwner %p deleted\n", this));
12417: 
59486:   if (mWaitingForPaint) {
59486:     // We don't care when the event is dispatched as long as it's "soon",
63041:     // since whoever needs it will be waiting for it.
59486:     nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(mContent, PR_TRUE);
59486:     NS_DispatchToMainThread(event);
59486:   }
59486: 
36227: #ifdef MAC_CARBON_PLUGINS
    1:   CancelTimer();
36227: #endif
    1: 
34679:   mObjectFrame = nsnull;
    1: 
    1:   for (cnt = 0; cnt < (mNumCachedAttrs + 1 + mNumCachedParams); cnt++) {
    1:     if (mCachedAttrParamNames && mCachedAttrParamNames[cnt]) {
26930:       NS_Free(mCachedAttrParamNames[cnt]);
    1:       mCachedAttrParamNames[cnt] = nsnull;
    1:     }
    1: 
    1:     if (mCachedAttrParamValues && mCachedAttrParamValues[cnt]) {
26930:       NS_Free(mCachedAttrParamValues[cnt]);
    1:       mCachedAttrParamValues[cnt] = nsnull;
    1:     }
    1:   }
    1: 
    1:   if (mCachedAttrParamNames) {
44203:     NS_Free(mCachedAttrParamNames);
    1:     mCachedAttrParamNames = nsnull;
    1:   }
    1: 
    1:   if (mCachedAttrParamValues) {
44203:     NS_Free(mCachedAttrParamValues);
    1:     mCachedAttrParamValues = nsnull;
    1:   }
    1: 
    1:   if (mTagText) {
    1:     NS_Free(mTagText);
    1:     mTagText = nsnull;
    1:   }
    1: 
    1:   // clean up plugin native window object
29574:   nsCOMPtr<nsIPluginHost> ph = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
29919:   if (ph) {
29919:     ph->DeletePluginNativeWindow(mPluginWindow);
    1:     mPluginWindow = nsnull;
    1:   }
24200: 
24200:   if (mInstance) {
29834:     mInstance->InvalidateOwner();
24200:   }
34217: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35171:   ReleaseXShm();
34217: #endif
    1: }
    1: 
    1: /*
    1:  * nsISupports Implementation
    1:  */
    1: 
    1: NS_IMPL_ADDREF(nsPluginInstanceOwner)
    1: NS_IMPL_RELEASE(nsPluginInstanceOwner)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsPluginInstanceOwner)
    1:   NS_INTERFACE_MAP_ENTRY(nsIPluginInstanceOwner)
58796:   NS_INTERFACE_MAP_ENTRY(nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH)
    1:   NS_INTERFACE_MAP_ENTRY(nsIPluginTagInfo)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMMouseListener)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIPluginInstanceOwner)
    1: NS_INTERFACE_MAP_END
    1: 
25454: NS_IMETHODIMP
25454: nsPluginInstanceOwner::SetInstance(nsIPluginInstance *aInstance)
    1: {
58080:   NS_ASSERTION(!mInstance || !aInstance, "mInstance should only be set or unset!");
58080: 
58080:   // If we're going to null out mInstance after use, be sure to call
58080:   // mInstance->InvalidateOwner() here, since it now won't be called
58080:   // from our destructor.  This fixes bug 613376.
58080:   if (mInstance && !aInstance)
58080:     mInstance->InvalidateOwner();
24200: 
    1:   mInstance = aInstance;
    1: 
    1:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::GetWindow(NPWindow *&aWindow)
    1: {
    1:   NS_ASSERTION(mPluginWindow, "the plugin window object being returned is null");
    1:   aWindow = mPluginWindow;
    1:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::GetMode(PRInt32 *aMode)
    1: {
    1:   nsCOMPtr<nsIDocument> doc;
    1:   nsresult rv = GetDocument(getter_AddRefs(doc));
    1:   nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(doc));
    1: 
    1:   if (pDoc) {
32799:     *aMode = NP_FULL;
    1:   } else {
32799:     *aMode = NP_EMBED;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAttributes(PRUint16& n,
    1:                                                    const char*const*& names,
    1:                                                    const char*const*& values)
    1: {
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   n = mNumCachedAttrs;
    1:   names  = (const char **)mCachedAttrParamNames;
    1:   values = (const char **)mCachedAttrParamValues;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAttribute(const char* name, const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(name);
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *result = nsnull;
    1: 
    1:   for (int i = 0; i < mNumCachedAttrs; i++) {
    1:     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
    1:       *result = mCachedAttrParamValues[i];
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDOMElement(nsIDOMElement* *result)
    1: {
    1:   return CallQueryInterface(mContent, result);
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetInstance(nsIPluginInstance *&aInstance)
    1: {
    1:   NS_IF_ADDREF(aInstance = mInstance);
    1: 
    1:   return NS_OK;
    1: }
    1: 
36766: NS_IMETHODIMP nsPluginInstanceOwner::GetURL(const char *aURL,
36766:                                             const char *aTarget,
36766:                                             nsIInputStream *aPostStream,
36766:                                             void *aHeadersData,
36766:                                             PRUint32 aHeadersDataLen)
    1: {
34679:   NS_ENSURE_TRUE(mObjectFrame, NS_ERROR_NULL_POINTER);
    1: 
 3333:   if (mContent->IsEditable()) {
 3333:     return NS_OK;
 3333:   }
 3333: 
    1:   // the container of the pres context will give us the link handler
34679:   nsCOMPtr<nsISupports> container = mObjectFrame->PresContext()->GetContainer();
    1:   NS_ENSURE_TRUE(container,NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsILinkHandler> lh = do_QueryInterface(container);
    1:   NS_ENSURE_TRUE(lh, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString  unitarget;
    1:   unitarget.AssignASCII(aTarget); // XXX could this be nonascii?
    1: 
    1:   nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1: 
    1:   // Create an absolute URL
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, baseURI);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIInputStream> headersDataStream;
36766:   if (aPostStream && aHeadersData) {
36766:     if (!aHeadersDataLen)
36766:       return NS_ERROR_UNEXPECTED;
36766: 
36766:     nsCOMPtr<nsIStringInputStream> sis = do_CreateInstance("@mozilla.org/io/string-input-stream;1");
36766:     if (!sis)
36766:       return NS_ERROR_OUT_OF_MEMORY;
36766: 
36766:     rv = sis->SetData((char *)aHeadersData, aHeadersDataLen);
36766:     NS_ENSURE_SUCCESS(rv, rv);
36766:     headersDataStream = do_QueryInterface(sis);
    1:   }
    1: 
    1:   PRInt32 blockPopups =
    1:     nsContentUtils::GetIntPref("privacy.popups.disable_from_plugins");
    1:   nsAutoPopupStatePusher popupStatePusher((PopupControlState)blockPopups);
    1: 
    1:   rv = lh->OnLinkClick(mContent, uri, unitarget.get(), 
36766:                        aPostStream, headersDataStream);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ShowStatus(const char *aStatusMsg)
    1: {
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1:   
    1:   rv = this->ShowStatus(NS_ConvertUTF8toUTF16(aStatusMsg).get());
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ShowStatus(const PRUnichar *aStatusMsg)
    1: {
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1: 
34679:   if (!mObjectFrame) {
    1:     return rv;
    1:   }
34679:   nsCOMPtr<nsISupports> cont = mObjectFrame->PresContext()->GetContainer();
    1:   if (!cont) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellItem(do_QueryInterface(cont, &rv));
    1:   if (NS_FAILED(rv) || !docShellItem) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   rv = docShellItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   if (NS_FAILED(rv) || !treeOwner) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(treeOwner, &rv));
    1:   if (NS_FAILED(rv) || !browserChrome) {
    1:     return rv;
    1:   }
    1:   rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT, 
    1:                                 aStatusMsg);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocument(nsIDocument* *aDocument)
    1: {
    1:   if (!aDocument)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // XXX sXBL/XBL2 issue: current doc or owner doc?
    1:   // But keep in mind bug 322414 comment 33
    1:   NS_IF_ADDREF(*aDocument = mContent->GetOwnerDoc());
    1:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRect(NPRect *invalidRect)
    1: {
62860:   // If our object frame has gone away, we won't be able to determine
62860:   // up-to-date-ness, so just fire off the event.
62860:   if (mWaitingForPaint && (!mObjectFrame || IsUpToDate())) {
59486:     // We don't care when the event is dispatched as long as it's "soon",
63041:     // since whoever needs it will be waiting for it.
59486:     nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(mContent, PR_TRUE);
59486:     NS_DispatchToMainThread(event);
59486:     mWaitingForPaint = false;
59486:   }
59486: 
34679:   if (!mObjectFrame || !invalidRect || !mWidgetVisible)
34501:     return NS_ERROR_FAILURE;
34501: 
54223:   // Each time an asynchronously-drawing plugin sends a new surface to display,
54223:   // InvalidateRect is called. We notify reftests that painting is up to
54223:   // date and update our ImageContainer with the new surface.
54223:   nsRefPtr<ImageContainer> container = mObjectFrame->GetImageContainer();
63041:   gfxIntSize oldSize;
54223:   if (container) {
63041:     oldSize = container->GetCurrentSize();
54223:     SetCurrentImage(container);
54223:   }
54223: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35208:   PRBool simpleImageRender = PR_FALSE;
35208:   mInstance->GetValueFromPlugin(NPPVpluginWindowlessLocalBool,
35208:                                 &simpleImageRender);
35208:   if (simpleImageRender) {  
35208:     NativeImageDraw(invalidRect);
35208:     return NS_OK;
35208:   }
35208: #endif
35208: 
34501: #ifndef XP_MACOSX
34501:   // Windowed plugins should not be calling NPN_InvalidateRect, but
34501:   // Silverlight does and expects it to "work"
34501:   if (mWidget) {
34501:     mWidget->Invalidate(nsIntRect(invalidRect->left, invalidRect->top,
34501:                                   invalidRect->right - invalidRect->left,
34501:                                   invalidRect->bottom - invalidRect->top),
34501:                         PR_FALSE);
34501:     return NS_OK;
34501:   }
34501: #endif
34501: 
34679:   nsPresContext* presContext = mObjectFrame->PresContext();
    1:   nsRect rect(presContext->DevPixelsToAppUnits(invalidRect->left),
    1:               presContext->DevPixelsToAppUnits(invalidRect->top),
    1:               presContext->DevPixelsToAppUnits(invalidRect->right - invalidRect->left),
    1:               presContext->DevPixelsToAppUnits(invalidRect->bottom - invalidRect->top));
63041:   if (container) {
63041:     gfxIntSize newSize = container->GetCurrentSize();
63041:     if (newSize != oldSize) {
63041:       // The image size has changed - invalidate the old area too, bug 635405.
63041:       nsRect oldRect = nsRect(0, 0,
63041:                               presContext->DevPixelsToAppUnits(oldSize.width),
63041:                               presContext->DevPixelsToAppUnits(oldSize.height));
63041:       rect.UnionRect(rect, oldRect);
63041:     }
63041:   }
63041:   rect.MoveBy(mObjectFrame->GetUsedBorderAndPadding().TopLeft());
63041:   mObjectFrame->InvalidateLayer(rect, nsDisplayItem::TYPE_PLUGIN);
34501:   return NS_OK;
    1: }
    1: 
32799: NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRegion(NPRegion invalidRegion)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ForceRedraw()
    1: {
34679:   NS_ENSURE_TRUE(mObjectFrame, NS_ERROR_NULL_POINTER);
34679:   nsIView* view = mObjectFrame->GetView();
    1:   if (view) {
    1:     return view->GetViewManager()->Composite();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
29834: NS_IMETHODIMP nsPluginInstanceOwner::GetNetscapeWindow(void *value)
    1: {
34679:   if (!mObjectFrame) {
29834:     NS_WARNING("plugin owner has no owner in getting doc's window handle");
29834:     return NS_ERROR_FAILURE;
29834:   }
29834:   
 3061: #if defined(XP_WIN) || defined(XP_OS2)
    1:   void** pvalue = (void**)value;
34679:   nsIViewManager* vm = mObjectFrame->PresContext()->GetPresShell()->GetViewManager();
29834:   if (!vm)
29834:     return NS_ERROR_FAILURE;
    1: #if defined(XP_WIN)
    1:   // This property is provided to allow a "windowless" plugin to determine the window it is drawing
    1:   // in, so it can translate mouse coordinates it receives directly from the operating system
    1:   // to coordinates relative to itself.
    1:   
    1:   // The original code (outside this #if) returns the document's window, which is OK if the window the "windowless" plugin
    1:   // is drawing into has the same origin as the document's window, but this is not the case for "windowless" plugins inside of scrolling DIVs etc
    1:   
    1:   // To make sure "windowless" plugins always get the right origin for translating mouse coordinates, this code
    1:   // determines the window handle of the mozilla window containing the "windowless" plugin.
    1:   
    1:   // Given that this HWND may not be that of the document's window, there is a slight risk
    1:   // of confusing a plugin that is using this HWND for illicit purposes, but since the documentation
    1:   // does not suggest this HWND IS that of the document window, rather that of the window
    1:   // the plugin is drawn in, this seems like a safe fix.
    1:   
    1:   // we only attempt to get the nearest window if this really is a "windowless" plugin so as not
    1:   // to change any behaviour for the much more common windowed plugins,
    1:   // though why this method would even be being called for a windowed plugin escapes me.
32799:   if (mPluginWindow && mPluginWindow->type == NPWindowTypeDrawable) {
    1:     // it turns out that flash also uses this window for determining focus, and is currently
    1:     // unable to show a caret correctly if we return the enclosing window. Therefore for
    1:     // now we only return the enclosing window when there is an actual offset which
    1:     // would otherwise cause coordinates to be offset incorrectly. (i.e.
    1:     // if the enclosing window if offset from the document window)
    1:     //
    1:     // fixing both the caret and ability to interact issues for a windowless control in a non document aligned windw
    1:     // does not seem to be possible without a change to the flash plugin
    1:     
47148:     nsIWidget* win = mObjectFrame->GetNearestWidget();
    1:     if (win) {
    1:       nsIView *view = nsIView::GetViewFor(win);
    1:       NS_ASSERTION(view, "No view for widget");
30535:       nsPoint offset = view->GetOffsetTo(nsnull);
    1:       
    1:       if (offset.x || offset.y) {
    1:         // in the case the two windows are offset from eachother, we do go ahead and return the correct enclosing window
    1:         // so that mouse co-ordinates are not messed up.
    1:         *pvalue = (void*)win->GetNativeData(NS_NATIVE_WINDOW);
    1:         if (*pvalue)
    1:           return NS_OK;
    1:       }
    1:     }
29836:   }
    1: #endif
30535:   // simply return the topmost document window
    1:   nsCOMPtr<nsIWidget> widget;
30535:   nsresult rv = vm->GetRootWidget(getter_AddRefs(widget));            
    1:   if (widget) {
    1:     *pvalue = (void*)widget->GetNativeData(NS_NATIVE_WINDOW);
29834:   } else {
29834:     NS_ASSERTION(widget, "couldn't get doc's widget in getting doc's window handle");
29834:   }
29834: 
29834:   return rv;
 3061: #elif defined(MOZ_WIDGET_GTK2)
 3061:   // X11 window managers want the toplevel window for WM_TRANSIENT_FOR.
47148:   nsIWidget* win = mObjectFrame->GetNearestWidget();
 3061:   if (!win)
29834:     return NS_ERROR_FAILURE;
29834:   GdkWindow* gdkWindow = static_cast<GdkWindow*>(win->GetNativeData(NS_NATIVE_WINDOW));
 3061:   if (!gdkWindow)
29834:     return NS_ERROR_FAILURE;
 3061:   gdkWindow = gdk_window_get_toplevel(gdkWindow);
16528: #ifdef MOZ_X11
 3233:   *static_cast<Window*>(value) = GDK_WINDOW_XID(gdkWindow);
16528: #endif
 3061:   return NS_OK;
38045: #elif defined(MOZ_WIDGET_QT)
38045:   // X11 window managers want the toplevel window for WM_TRANSIENT_FOR.
47148:   nsIWidget* win = mObjectFrame->GetNearestWidget();
38045:   if (!win)
38045:     return NS_ERROR_FAILURE;
38045:   QWidget* widget = static_cast<QWidget*>(win->GetNativeData(NS_NATIVE_WINDOW));
38045:   if (!widget)
38045:     return NS_ERROR_FAILURE;
38045: #ifdef MOZ_X11
38045:   *static_cast<Window*>(value) = widget->handle();
41059:   return NS_OK;
38045: #endif
41059:   return NS_ERROR_FAILURE;
29834: #else
29834:   return NS_ERROR_NOT_IMPLEMENTED;
 3061: #endif
    1: }
    1: 
34717: NS_IMETHODIMP nsPluginInstanceOwner::SetEventModel(PRInt32 eventModel)
34717: {
34717: #ifdef XP_MACOSX
34717:   mEventModel = static_cast<NPEventModel>(eventModel);
34717:   return NS_OK;
34717: #else
34717:   return NS_ERROR_NOT_IMPLEMENTED;
34717: #endif
34717: }
34717: 
58796: NS_IMETHODIMP nsPluginInstanceOwner::SetWindow()
58796: {
58796:   NS_ENSURE_TRUE(mObjectFrame, NS_ERROR_NULL_POINTER);
59526:   return mObjectFrame->CallSetWindow(PR_FALSE);
58796: }
58796: 
32799: NPError nsPluginInstanceOwner::ShowNativeContextMenu(NPMenu* menu, void* event)
32019: {
32019:   if (!menu || !event)
32019:     return NPERR_GENERIC_ERROR;
32019: 
32019: #ifdef XP_MACOSX
32019:   if (GetEventModel() != NPEventModelCocoa)
32019:     return NPERR_INCOMPATIBLE_VERSION_ERROR;
32019: 
32019:   return NS_NPAPI_ShowCocoaContextMenu(static_cast<void*>(menu), mWidget,
32799:                                        static_cast<NPCocoaEvent*>(event));
32019: #else
32019:   return NPERR_INCOMPATIBLE_VERSION_ERROR;
32019: #endif
32019: }
32019: 
32019: NPBool nsPluginInstanceOwner::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                                            double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019: #ifdef XP_MACOSX
32019:   if (!mWidget)
32019:     return PR_FALSE;
32019: 
32019:   return NS_NPAPI_ConvertPointCocoa(mWidget->GetNativeData(NS_NATIVE_WIDGET),
32019:                                     sourceX, sourceY, sourceSpace, destX, destY, destSpace);
32019: #else
32019:   // we should implement this for all platforms
32019:   return PR_FALSE;
32019: #endif
32019: }
32019: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetTagType(nsPluginTagType *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   *result = nsPluginTagType_Unknown;
    1: 
    1:   nsIAtom *atom = mContent->Tag();
    1: 
    1:   if (atom == nsGkAtoms::applet)
    1:     *result = nsPluginTagType_Applet;
    1:   else if (atom == nsGkAtoms::embed)
    1:     *result = nsPluginTagType_Embed;
    1:   else if (atom == nsGkAtoms::object)
    1:     *result = nsPluginTagType_Object;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetTagText(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   if (nsnull == mTagText) {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent, &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDocument> document;
    1:     rv = GetDocument(getter_AddRefs(document));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(document);
    1:     NS_ASSERTION(domDoc, "Need a document");
    1: 
    1:     nsCOMPtr<nsIDocumentEncoder> docEncoder(do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE "text/html", &rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = docEncoder->Init(domDoc, NS_LITERAL_STRING("text/html"), nsIDocumentEncoder::OutputEncodeBasicEntities);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     nsCOMPtr<nsIDOMRange> range(do_CreateInstance(kRangeCID,&rv));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     rv = range->SelectNode(node);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     docEncoder->SetRange(range);
    1:     nsString elementHTML;
    1:     rv = docEncoder->EncodeToString(elementHTML);
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     mTagText = ToNewUTF8String(elementHTML);
    1:     if (!mTagText)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   *result = mTagText;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetParameters(PRUint16& n, const char*const*& names, const char*const*& values)
    1: {
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   n = mNumCachedParams;
    1:   if (n) {
    1:     names  = (const char **)(mCachedAttrParamNames + mNumCachedAttrs + 1);
    1:     values = (const char **)(mCachedAttrParamValues + mNumCachedAttrs + 1);
    1:   } else
    1:     names = values = nsnull;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetParameter(const char* name, const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(name);
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *result = nsnull;
    1: 
    1:   for (int i = mNumCachedAttrs + 1; i < (mNumCachedParams + 1 + mNumCachedAttrs); i++) {
    1:     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
    1:       *result = mCachedAttrParamValues[i];
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentBase(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   nsresult rv = NS_OK;
    1:   if (mDocumentBase.IsEmpty()) {
34679:     if (!mObjectFrame) {
    1:       *result = nsnull;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsIDocument* doc = mContent->GetOwnerDoc();
    1:     NS_ASSERTION(doc, "Must have an owner doc");
41900:     rv = doc->GetDocBaseURI()->GetSpec(mDocumentBase);
    1:   }
    1:   if (NS_SUCCEEDED(rv))
    1:     *result = ToNewCString(mDocumentBase);
    1:   return rv;
    1: }
    1: 
    1: static nsDataHashtable<nsDepCharHashKey, const char *> * gCharsetMap;
    1: typedef struct {
    1:     char mozName[16];
    1:     char javaName[12];
    1: } moz2javaCharset;
    1: 
    1: /* XXX If you add any strings longer than
    1:  *  {"x-mac-cyrillic",  "MacCyrillic"},
    1:  *  {"x-mac-ukrainian", "MacUkraine"},
    1:  * to the following array then you MUST update the
    1:  * sizes of the arrays in the moz2javaCharset struct
    1:  */
    1: 
    1: static const moz2javaCharset charsets[] = 
    1: {
    1:     {"windows-1252",    "Cp1252"},
    1:     {"IBM850",          "Cp850"},
    1:     {"IBM852",          "Cp852"},
    1:     {"IBM855",          "Cp855"},
    1:     {"IBM857",          "Cp857"},
    1:     {"IBM828",          "Cp862"},
    1:     {"IBM864",          "Cp864"},
    1:     {"IBM866",          "Cp866"},
    1:     {"windows-1250",    "Cp1250"},
    1:     {"windows-1251",    "Cp1251"},
    1:     {"windows-1253",    "Cp1253"},
    1:     {"windows-1254",    "Cp1254"},
    1:     {"windows-1255",    "Cp1255"},
    1:     {"windows-1256",    "Cp1256"},
    1:     {"windows-1257",    "Cp1257"},
    1:     {"windows-1258",    "Cp1258"},
    1:     {"EUC-JP",          "EUC_JP"},
    1:     {"EUC-KR",          "EUC_KR"},
    1:     {"x-euc-tw",        "EUC_TW"},
    1:     {"gb18030",         "GB18030"},
    1:     {"x-gbk",           "GBK"},
    1:     {"ISO-2022-JP",     "ISO2022JP"},
    1:     {"ISO-2022-KR",     "ISO2022KR"},
    1:     {"ISO-8859-2",      "ISO8859_2"},
    1:     {"ISO-8859-3",      "ISO8859_3"},
    1:     {"ISO-8859-4",      "ISO8859_4"},
    1:     {"ISO-8859-5",      "ISO8859_5"},
    1:     {"ISO-8859-6",      "ISO8859_6"},
    1:     {"ISO-8859-7",      "ISO8859_7"},
    1:     {"ISO-8859-8",      "ISO8859_8"},
    1:     {"ISO-8859-9",      "ISO8859_9"},
    1:     {"ISO-8859-13",     "ISO8859_13"},
    1:     {"x-johab",         "Johab"},
    1:     {"KOI8-R",          "KOI8_R"},
    1:     {"TIS-620",         "MS874"},
    1:     {"windows-936",     "MS936"},
    1:     {"x-windows-949",   "MS949"},
    1:     {"x-mac-arabic",    "MacArabic"},
    1:     {"x-mac-croatian",  "MacCroatia"},
    1:     {"x-mac-cyrillic",  "MacCyrillic"},
    1:     {"x-mac-greek",     "MacGreek"},
    1:     {"x-mac-hebrew",    "MacHebrew"},
    1:     {"x-mac-icelandic", "MacIceland"},
    1:     {"x-mac-roman",     "MacRoman"},
    1:     {"x-mac-romanian",  "MacRomania"},
    1:     {"x-mac-ukrainian", "MacUkraine"},
    1:     {"Shift_JIS",       "SJIS"},
    1:     {"TIS-620",         "TIS620"}
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentEncoding(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   *result = nsnull;
    1: 
    1:   nsresult rv;
    1:   // XXX sXBL/XBL2 issue: current doc or owner doc?
    1:   nsCOMPtr<nsIDocument> doc;
    1:   rv = GetDocument(getter_AddRefs(doc));
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get document");
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   const nsCString &charset = doc->GetDocumentCharacterSet();
    1: 
    1:   if (charset.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   // common charsets and those not requiring conversion first
    1:   if (charset.EqualsLiteral("us-ascii")) {
    1:     *result = PL_strdup("US_ASCII");
    1:   } else if (charset.EqualsLiteral("ISO-8859-1") ||
    1:       !nsCRT::strncmp(PromiseFlatCString(charset).get(), "UTF", 3)) {
    1:     *result = ToNewCString(charset);
    1:   } else {
    1:     if (!gCharsetMap) {
    1:       const int NUM_CHARSETS = sizeof(charsets) / sizeof(moz2javaCharset);
    1:       gCharsetMap = new nsDataHashtable<nsDepCharHashKey, const char*>();
    1:       if (!gCharsetMap || !gCharsetMap->Init(NUM_CHARSETS))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       for (PRUint16 i = 0; i < NUM_CHARSETS; i++) {
    1:         gCharsetMap->Put(charsets[i].mozName, charsets[i].javaName);
    1:       }
    1:     }
    1:     // if found mapping, return it; otherwise return original charset
    1:     const char *mapping;
    1:     *result = gCharsetMap->Get(charset.get(), &mapping) ? PL_strdup(mapping) :
    1:                                                           ToNewCString(charset);
    1:   }
    1: 
    1:   return (*result) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAlignment(const char* *result)
    1: {
    1:   return GetAttribute("ALIGN", result);
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetWidth(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   *result = mPluginWindow->width;
    1: 
    1:   return NS_OK;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetHeight(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   *result = mPluginWindow->height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetBorderVertSpace(PRUint32 *result)
    1: {
    1:   nsresult    rv;
    1:   const char  *vspace;
    1: 
    1:   rv = GetAttribute("VSPACE", &vspace);
    1: 
    1:   if (NS_OK == rv) {
    1:     if (*result != 0)
    1:       *result = (PRUint32)atol(vspace);
    1:     else
    1:       *result = 0;
    1:   }
    1:   else
    1:     *result = 0;
    1: 
    1:   return rv;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetBorderHorizSpace(PRUint32 *result)
    1: {
    1:   nsresult    rv;
    1:   const char  *hspace;
    1: 
    1:   rv = GetAttribute("HSPACE", &hspace);
    1: 
    1:   if (NS_OK == rv) {
    1:     if (*result != 0)
    1:       *result = (PRUint32)atol(hspace);
    1:     else
    1:       *result = 0;
    1:   }
    1:   else
    1:     *result = 0;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetUniqueID(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
34679:   *result = NS_PTR_TO_INT32(mObjectFrame);
    1:   return NS_OK;
    1: }
    1: 
    1: // Cache the attributes and/or parameters of our tag into a single set
44203: // of arrays to be compatible with Netscape 4.x. The attributes go first,
    1: // followed by a PARAM/null and then any PARAM tags. Also, hold the
    1: // cached array around for the duration of the life of the instance
44203: // because Netscape 4.x did. See bug 111008.
    1: nsresult nsPluginInstanceOwner::EnsureCachedAttrParamArrays()
    1: {
    1:   if (mCachedAttrParamValues)
    1:     return NS_OK;
    1: 
    1:   NS_PRECONDITION(((mNumCachedAttrs + mNumCachedParams) == 0) &&
    1:                     !mCachedAttrParamNames,
    1:                   "re-cache of attrs/params not implemented! use the DOM "
    1:                     "node directy instead");
34679:   NS_ENSURE_TRUE(mObjectFrame, NS_ERROR_NULL_POINTER);
    1: 
44203:   // Convert to a 16-bit count. Subtract 2 in case we add an extra
44203:   // "src" or "wmode" entry below.
    1:   PRUint32 cattrs = mContent->GetAttrCount();
44203:   if (cattrs < 0x0000FFFD) {
 3233:     mNumCachedAttrs = static_cast<PRUint16>(cattrs);
    1:   } else {
44203:     mNumCachedAttrs = 0xFFFD;
    1:   }
    1: 
    1:   // now, we need to find all the PARAM tags that are children of us
44203:   // however, be careful not to include any PARAMs that don't have us
    1:   // as a direct parent. For nested object (or applet) tags, be sure
    1:   // to only round up the param tags that coorespond with THIS
    1:   // instance. And also, weed out any bogus tags that may get in the
    1:   // way, see bug 39609. Then, with any param tag that meet our
    1:   // qualification, temporarly cache them in an nsCOMArray until
    1:   // we can figure out what size to make our fixed char* array.
    1:   nsCOMArray<nsIDOMElement> ourParams;
    1: 
44203:   // Get all dependent PARAM tags, even if they are not direct children.
    1:   nsCOMPtr<nsIDOMElement> mydomElement = do_QueryInterface(mContent);
    1:   NS_ENSURE_TRUE(mydomElement, NS_ERROR_NO_INTERFACE);
    1: 
44203:   // Making DOM method calls can cause our frame to go away.
44203:   nsCOMPtr<nsIPluginInstanceOwner> kungFuDeathGrip(this);
44203: 
    1:   nsCOMPtr<nsIDOMNodeList> allParams;
    1:   NS_NAMED_LITERAL_STRING(xhtml_ns, "http://www.w3.org/1999/xhtml");
    1:   mydomElement->GetElementsByTagNameNS(xhtml_ns, NS_LITERAL_STRING("param"),
    1:                                        getter_AddRefs(allParams));
    1:   if (allParams) {
    1:     PRUint32 numAllParams; 
    1:     allParams->GetLength(&numAllParams);
    1:     for (PRUint32 i = 0; i < numAllParams; i++) {
    1:       nsCOMPtr<nsIDOMNode> pnode;
    1:       allParams->Item(i, getter_AddRefs(pnode));
    1:       nsCOMPtr<nsIDOMElement> domelement = do_QueryInterface(pnode);
    1:       if (domelement) {
44203:         // Ignore params without a name attribute.
    1:         nsAutoString name;
    1:         domelement->GetAttribute(NS_LITERAL_STRING("name"), name);
    1:         if (!name.IsEmpty()) {
44203:           // Find the first object or applet parent.
    1:           nsCOMPtr<nsIDOMNode> parent;
    1:           nsCOMPtr<nsIDOMHTMLObjectElement> domobject;
    1:           nsCOMPtr<nsIDOMHTMLAppletElement> domapplet;
    1:           pnode->GetParentNode(getter_AddRefs(parent));
    1:           while (!(domobject || domapplet) && parent) {
    1:             domobject = do_QueryInterface(parent);
    1:             domapplet = do_QueryInterface(parent);
    1:             nsCOMPtr<nsIDOMNode> temp;
    1:             parent->GetParentNode(getter_AddRefs(temp));
    1:             parent = temp;
    1:           }
    1:           if (domapplet || domobject) {
44203:             if (domapplet) {
    1:               parent = domapplet;
44203:             }
44203:             else {
    1:               parent = domobject;
44203:             }
    1:             nsCOMPtr<nsIDOMNode> mydomNode = do_QueryInterface(mydomElement);
    1:             if (parent == mydomNode) {
    1:               ourParams.AppendObject(domelement);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
44203:   // We're done with DOM method calls now. Make sure we still have a frame.
34679:   NS_ENSURE_TRUE(mObjectFrame, NS_ERROR_OUT_OF_MEMORY);
    1: 
44203:   // Convert to a 16-bit count.
44203:   PRUint32 cparams = ourParams.Count();
44203:   if (cparams < 0x0000FFFF) {
 3233:     mNumCachedParams = static_cast<PRUint16>(cparams);
44203:   } else {
    1:     mNumCachedParams = 0xFFFF;
44203:   }
44203: 
44203:   PRUint16 numRealAttrs = mNumCachedAttrs;
    1: 
    1:   // Some plugins were never written to understand the "data" attribute of the OBJECT tag.
    1:   // Real and WMP will not play unless they find a "src" attribute, see bug 152334.
    1:   // Nav 4.x would simply replace the "data" with "src". Because some plugins correctly
    1:   // look for "data", lets instead copy the "data" attribute and add another entry
    1:   // to the bottom of the array if there isn't already a "src" specified.
    1:   nsAutoString data;
44203:   if (mContent->Tag() == nsGkAtoms::object &&
44203:       !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::src) &&
47341:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::data, data) &&
47341:       !data.IsEmpty()) {
    1:     mNumCachedAttrs++;
    1:   }
    1: 
34217:   // "plugins.force.wmode" preference is forcing wmode type for plugins
34181:   // possible values - "opaque", "transparent", "windowed"
34181:   nsAdoptingCString wmodeType = nsContentUtils::GetCharPref("plugins.force.wmode");
44203:   if (!wmodeType.IsEmpty()) {
34181:     mNumCachedAttrs++;
44203:   }
44203: 
44203:   mCachedAttrParamNames  = (char**)NS_Alloc(sizeof(char*) * (mNumCachedAttrs + 1 + mNumCachedParams));
    1:   NS_ENSURE_TRUE(mCachedAttrParamNames,  NS_ERROR_OUT_OF_MEMORY);
44203:   mCachedAttrParamValues = (char**)NS_Alloc(sizeof(char*) * (mNumCachedAttrs + 1 + mNumCachedParams));
    1:   NS_ENSURE_TRUE(mCachedAttrParamValues, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Some plugins (eg Flash, see bug 234675.) are actually sensitive to the
    1:   // attribute order.  So we want to make sure we give the plugin the
    1:   // attributes in the order they came in in the source, to be compatible with
    1:   // other browsers.  Now in HTML, the storage order is the reverse of the
    1:   // source order, while in XML and XHTML it's the same as the source order
    1:   // (see the AddAttributes functions in the HTML and XML content sinks).
44203:   PRInt32 start, end, increment;
33329:   if (mContent->IsHTML() &&
29004:       mContent->IsInHTMLDocument()) {
    1:     // HTML.  Walk attributes in reverse order.
    1:     start = numRealAttrs - 1;
    1:     end = -1;
    1:     increment = -1;
    1:   } else {
    1:     // XHTML or XML.  Walk attributes in forward order.
    1:     start = 0;
    1:     end = numRealAttrs;
    1:     increment = 1;
    1:   }
44203: 
44203:   // Set to the next slot to fill in name and value cache arrays.
44203:   PRUint32 nextAttrParamIndex = 0;
44203: 
44203:   // Potentially add WMODE attribute.
34181:   if (!wmodeType.IsEmpty()) {
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("wmode"));
44203:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(NS_ConvertUTF8toUTF16(wmodeType));
44203:     nextAttrParamIndex++;
44203:   }
44203: 
44203:   // Add attribute name/value pairs.
44203:   for (PRInt32 index = start; index != end; index += increment) {
    1:     const nsAttrName* attrName = mContent->GetAttrNameAt(index);
    1:     nsIAtom* atom = attrName->LocalName();
    1:     nsAutoString value;
    1:     mContent->GetAttr(attrName->NamespaceID(), atom, value);
    1:     nsAutoString name;
    1:     atom->ToString(name);
    1: 
    1:     FixUpURLS(name, value);
    1: 
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(name);
44203:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(value);
44203:     nextAttrParamIndex++;
44203:   }
44203: 
44203:   // Potentially add SRC attribute.
44203:   if (!data.IsEmpty()) {
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("SRC"));
44203:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(data);
44203:     nextAttrParamIndex++;
44203:   }
44203: 
44203:   // Add PARAM and null separator.
44203:   mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(NS_LITERAL_STRING("PARAM"));
44203:   mCachedAttrParamValues[nextAttrParamIndex] = nsnull;
44203:   nextAttrParamIndex++;
44203: 
44203:   // Add PARAM name/value pairs.
44203:   for (PRUint16 i = 0; i < mNumCachedParams; i++) {
44203:     nsIDOMElement* param = ourParams.ObjectAt(i);
44203:     if (!param) {
44203:       continue;
44203:     }
44203: 
    1:     nsAutoString name;
    1:     nsAutoString value;
    1:     param->GetAttribute(NS_LITERAL_STRING("name"), name); // check for empty done above
    1:     param->GetAttribute(NS_LITERAL_STRING("value"), value);
    1:     
    1:     FixUpURLS(name, value);
    1: 
    1:     /*
    1:      * According to the HTML 4.01 spec, at
    1:      * http://www.w3.org/TR/html4/types.html#type-cdata
    1:      * ''User agents may ignore leading and trailing
    1:      * white space in CDATA attribute values (e.g., "
    1:      * myval " may be interpreted as "myval"). Authors
    1:      * should not declare attribute values with
    1:      * leading or trailing white space.''
    1:      * However, do not trim consecutive spaces as in bug 122119
    1:      */
    1:     name.Trim(" \n\r\t\b", PR_TRUE, PR_TRUE, PR_FALSE);
    1:     value.Trim(" \n\r\t\b", PR_TRUE, PR_TRUE, PR_FALSE);
44203:     mCachedAttrParamNames [nextAttrParamIndex] = ToNewUTF8String(name);
44203:     mCachedAttrParamValues[nextAttrParamIndex] = ToNewUTF8String(value);
44203:     nextAttrParamIndex++;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // Here's where we forward events to plugins.
    1: 
    1: #ifdef XP_MACOSX
    1: 
32972: #ifndef NP_NO_CARBON
31130: static void InitializeEventRecord(EventRecord* event, Point* aMousePosition)
    1: {
    1:   memset(event, 0, sizeof(EventRecord));
31130:   if (aMousePosition) {
31130:     event->where = *aMousePosition;
31130:   } else {
    1:     ::GetGlobalMouse(&event->where);
31130:   }
    1:   event->when = ::TickCount();
33068:   event->modifiers = ::GetCurrentKeyModifiers();
    1: }
32972: #endif
    1: 
32019: static void InitializeNPCocoaEvent(NPCocoaEvent* event)
32019: {
32019:   memset(event, 0, sizeof(NPCocoaEvent));
32019: }
32019: 
  130: NPDrawingModel nsPluginInstanceOwner::GetDrawingModel()
  130: {
  130: #ifndef NP_NO_QUICKDRAW
  130:   NPDrawingModel drawingModel = NPDrawingModelQuickDraw;
  130: #else
  130:   NPDrawingModel drawingModel = NPDrawingModelCoreGraphics;
  130: #endif
  130: 
  130:   if (!mInstance)
  130:     return drawingModel;
  130: 
32799:   mInstance->GetDrawingModel((PRInt32*)&drawingModel);
  130:   return drawingModel;
  130: }
  130: 
62471: PRBool nsPluginInstanceOwner::IsRemoteDrawingCoreAnimation()
62471: {
62471:   nsCOMPtr<nsIPluginInstance_MOZILLA_2_0_BRANCH> inst = do_QueryInterface(mInstance);
62471:   if (!inst)
62471:     return PR_FALSE;
62471: 
62471:   PRBool coreAnimation;
62471:   if (!NS_SUCCEEDED(inst->IsRemoteDrawingCoreAnimation(&coreAnimation)))
62471:     return PR_FALSE;
62471: 
62471:   return coreAnimation;
62471: }
62471: 
32019: NPEventModel nsPluginInstanceOwner::GetEventModel()
32019: {
34717:   return mEventModel;
32019: }
32019: 
39757: #define DEFAULT_REFRESH_RATE 20 // 50 FPS
39757: 
39757: nsCOMPtr<nsITimer>                *nsPluginInstanceOwner::sCATimer = NULL;
39757: nsTArray<nsPluginInstanceOwner*>  *nsPluginInstanceOwner::sCARefreshListeners = NULL;
39757: 
39757: void nsPluginInstanceOwner::CARefresh(nsITimer *aTimer, void *aClosure) {
39757:   if (!sCARefreshListeners) {
39757:     return;
39757:   }
39757:   for (size_t i = 0; i < sCARefreshListeners->Length(); i++) {
39757:     nsPluginInstanceOwner* instanceOwner = (*sCARefreshListeners)[i];
39757:     NPWindow *window;
39757:     instanceOwner->GetWindow(window);
39757:     if (!window) {
39757:       continue;
39757:     }
39757:     NPRect r;
39757:     r.left = 0;
39757:     r.top = 0;
39757:     r.right = window->width;
39757:     r.bottom = window->height; 
39757:     instanceOwner->InvalidateRect(&r);
39757:   }
39757: }
39757: 
39757: void nsPluginInstanceOwner::AddToCARefreshTimer(nsPluginInstanceOwner *aPluginInstance) {
39757:   if (!sCARefreshListeners) {
39757:     sCARefreshListeners = new nsTArray<nsPluginInstanceOwner*>();
39757:     if (!sCARefreshListeners) {
39757:       return;
39757:     }
39757:   }
39757: 
39757:   NS_ASSERTION(!sCARefreshListeners->Contains(aPluginInstance), 
39757:       "pluginInstanceOwner already registered as a listener");
39757:   sCARefreshListeners->AppendElement(aPluginInstance);
39757: 
39757:   if (!sCATimer) {
39757:     sCATimer = new nsCOMPtr<nsITimer>();
39757:     if (!sCATimer) {
39757:       return;
39757:     }
39757:   }
39757: 
39757:   if (sCARefreshListeners->Length() == 1) {
39757:     *sCATimer = do_CreateInstance("@mozilla.org/timer;1");
39757:     (*sCATimer)->InitWithFuncCallback(CARefresh, NULL, 
39757:                    DEFAULT_REFRESH_RATE, nsITimer::TYPE_REPEATING_SLACK);
39757:   }
39757: }
39757: 
39757: void nsPluginInstanceOwner::RemoveFromCARefreshTimer(nsPluginInstanceOwner *aPluginInstance) {
39757:   if (!sCARefreshListeners || sCARefreshListeners->Contains(aPluginInstance) == false) {
39757:     return;
39757:   }
42504: 
39757:   sCARefreshListeners->RemoveElement(aPluginInstance);
42504: 
39757:   if (sCARefreshListeners->Length() == 0) {
39757:     if (sCATimer) {
39757:       (*sCATimer)->Cancel();
39757:       delete sCATimer;
39757:       sCATimer = NULL;
39757:     }
39757:     delete sCARefreshListeners;
39757:     sCARefreshListeners = NULL;
39757:   }
39757: }
39757: 
42504: void nsPluginInstanceOwner::SetupCARefresh()
42504: {
42504:   const char* pluginType = GetMIMEType(mInstance);
42504:   if (strcmp(pluginType, "application/x-shockwave-flash") != 0) {
42504:     // We don't need a timer since Flash is invoking InvalidateRect for us.
42504:     AddToCARefreshTimer(this);
42504:   }
42504: }
42504: 
42504: void nsPluginInstanceOwner::RenderCoreAnimation(CGContextRef aCGContext, 
42504:                                                 int aWidth, int aHeight)
42504: {
42504:   if (aWidth == 0 || aHeight == 0)
42504:     return;
42504: 
42504:   if (!mIOSurface || 
43369:      (mIOSurface->GetWidth() != (size_t)aWidth || 
43369:       mIOSurface->GetHeight() != (size_t)aHeight)) {
42504:     if (mIOSurface) {
42504:       delete mIOSurface;
42504:     }
42504: 
42504:     // If the renderer is backed by an IOSurface, resize it as required.
42504:     mIOSurface = nsIOSurface::CreateIOSurface(aWidth, aHeight);
42504:     if (mIOSurface) {
42504:       nsIOSurface *attachSurface = nsIOSurface::LookupSurface(
42504:                                       mIOSurface->GetIOSurfaceID());
42504:       if (attachSurface) {
42504:         mCARenderer.AttachIOSurface(attachSurface);
42504:       } else {
42504:         NS_ERROR("IOSurface attachment failed");
42504:         delete attachSurface;
42504:         delete mIOSurface;
42504:         mIOSurface = NULL;
42504:       }
42504:     }
42504:   }
42504: 
42504:   if (mCARenderer.isInit() == false) {
39757:     void *caLayer = NULL;
39757:     mInstance->GetValueFromPlugin(NPPVpluginCoreAnimationLayer, &caLayer);
39757:     if (!caLayer) {
39757:       return;
39757:     }
42504: 
42504:     mCARenderer.SetupRenderer(caLayer, aWidth, aHeight);
42504: 
42504:     // Setting up the CALayer requires resetting the painting otherwise we
42504:     // get garbage for the first few frames.
42504:     FixUpPluginWindow(ePluginPaintDisable);
42504:     FixUpPluginWindow(ePluginPaintEnable);
42504:   }
42504: 
41029:   CGImageRef caImage = NULL;
41029:   nsresult rt = mCARenderer.Render(aWidth, aHeight, &caImage);
42504:   if (rt == NS_OK && mIOSurface) {
42504:     nsCARenderer::DrawSurfaceToCGContext(aCGContext, mIOSurface, CreateSystemColorSpace(),
42504:                                          0, 0, aWidth, aHeight);
42504:   } else if (rt == NS_OK && caImage != NULL) {
41029:     // Significant speed up by resetting the scaling
41029:     ::CGContextSetInterpolationQuality(aCGContext, kCGInterpolationNone );
41029:     ::CGContextTranslateCTM(aCGContext, 0, aHeight);
41029:     ::CGContextScaleCTM(aCGContext, 1.0, -1.0);
41029: 
41029:     ::CGContextDrawImage(aCGContext, CGRectMake(0,0,aWidth,aHeight), caImage);
42504:   } else {
42504:     NS_NOTREACHED("nsCARenderer::Render failure");
41029:   }
39757: }
39757: 
32799: void* nsPluginInstanceOwner::GetPluginPortCopy()
32799: {
32799: #ifndef NP_NO_QUICKDRAW
32799:   if (GetDrawingModel() == NPDrawingModelQuickDraw)
32799:     return &mQDPluginPortCopy;
32799: #endif
39757:   if (GetDrawingModel() == NPDrawingModelCoreGraphics || 
43370:       GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:       GetDrawingModel() == NPDrawingModelInvalidatingCoreAnimation)
32799:     return &mCGPluginPortCopy;
32799:   return nsnull;
32799: }
32799:   
21108: // Currently (on OS X in Cocoa widgets) any changes made as a result of
37446: // calling GetPluginPortFromWidget() are immediately reflected in the NPWindow
21108: // structure that has been passed to the plugin via SetWindow().  This is
21108: // because calls to nsChildView::GetNativeData(NS_NATIVE_PLUGIN_PORT_CG)
21108: // always return a pointer to the same internal (private) object, but may
37446: // make changes inside that object.  All calls to GetPluginPortFromWidget() made while
21108: // the plugin is active (i.e. excluding those made at our initialization)
21108: // need to take this into account.  The easiest way to do so is to replace
21108: // them with calls to SetPluginPortAndDetectChange().  This method keeps track
37446: // of when calls to GetPluginPortFromWidget() result in changes, and sets a flag to make
21108: // sure SetWindow() gets called the next time through FixUpPluginWindow(), so
21108: // that the plugin is notified of these changes.
32799: void* nsPluginInstanceOwner::SetPluginPortAndDetectChange()
21108: {
21108:   if (!mPluginWindow)
21108:     return nsnull;
37446:   void* pluginPort = GetPluginPortFromWidget();
21108:   if (!pluginPort)
21108:     return nsnull;
21108:   mPluginWindow->window = pluginPort;
21108: 
32972: #ifndef NP_NO_QUICKDRAW
21108:   NPDrawingModel drawingModel = GetDrawingModel();
21108:   if (drawingModel == NPDrawingModelQuickDraw) {
32799:     NP_Port* windowQDPort = static_cast<NP_Port*>(mPluginWindow->window);
32799:     if (windowQDPort->port != mQDPluginPortCopy.port) {
32799:       mQDPluginPortCopy.port = windowQDPort->port;
21108:       mPluginPortChanged = PR_TRUE;
21108:     }
39757:   } else if (drawingModel == NPDrawingModelCoreGraphics || 
43370:              drawingModel == NPDrawingModelCoreAnimation ||
43370:              drawingModel == NPDrawingModelInvalidatingCoreAnimation)
21108: #endif
21108:   {
34737: #ifndef NP_NO_CARBON
34717:     if (GetEventModel() == NPEventModelCarbon) {
32799:       NP_CGContext* windowCGPort = static_cast<NP_CGContext*>(mPluginWindow->window);
32799:       if ((windowCGPort->context != mCGPluginPortCopy.context) ||
32799:           (windowCGPort->window != mCGPluginPortCopy.window)) {
32799:         mCGPluginPortCopy.context = windowCGPort->context;
32799:         mCGPluginPortCopy.window = windowCGPort->window;
21108:         mPluginPortChanged = PR_TRUE;
21108:       }
21108:     }
34737: #endif
34717:   }
21108: 
21108:   return mPluginWindow->window;
21108: }
21108: 
21108: void nsPluginInstanceOwner::BeginCGPaint()
21108: {
21108:   ++mInCGPaintLevel;
21108: }
21108: 
21108: void nsPluginInstanceOwner::EndCGPaint()
21108: {
21108:   --mInCGPaintLevel;
32019:   NS_ASSERTION(mInCGPaintLevel >= 0, "Mismatched call to nsPluginInstanceOwner::EndCGPaint()!");
21108: }
21108: 
    1: #endif
    1: 
24543: // static
24543: PRUint32
24543: nsPluginInstanceOwner::GetEventloopNestingLevel()
24543: {
24543:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
24543:   PRUint32 currentLevel = 0;
24543:   if (appShell) {
24543:     appShell->GetEventloopNestingLevel(&currentLevel);
24543: #ifdef XP_MACOSX
24543:     // Cocoa widget code doesn't process UI events through the normal
24543:     // appshell event loop, so it needs an additional count here.
24543:     currentLevel++;
24543: #endif
24543:   }
24543: 
24543:   // No idea how this happens... but Linux doesn't consistently
24543:   // process UI events through the appshell event loop. If we get a 0
24543:   // here on any platform we increment the level just in case so that
24543:   // we make sure we always tear the plugin down eventually.
24543:   if (!currentLevel) {
24543:     currentLevel++;
24543:   }
24543: 
24543:   return currentLevel;
24543: }
24543: 
37871: void nsPluginInstanceOwner::ScrollPositionWillChange(nscoord aX, nscoord aY)
    1: {
36227: #ifdef MAC_CARBON_PLUGINS
32019:   if (GetEventModel() != NPEventModelCarbon)
37871:     return;
32019: 
    1:   CancelTimer();
    1: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:       EventRecord scrollEvent;
31130:       InitializeEventRecord(&scrollEvent, nsnull);
30189:       scrollEvent.what = NPEventType_ScrollingBeginsEvent;
    1: 
32019:       void* window = FixUpPluginWindow(ePluginPaintDisable);
  130:       if (window) {
43436:         mInstance->HandleEvent(&scrollEvent, nsnull);
    1:       }
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
37871: }
37871: 
37871: void nsPluginInstanceOwner::ScrollPositionDidChange(nscoord aX, nscoord aY)
    1: {
36227: #ifdef MAC_CARBON_PLUGINS
32019:   if (GetEventModel() != NPEventModelCarbon)
37871:     return;
32019: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:       EventRecord scrollEvent;
31130:       InitializeEventRecord(&scrollEvent, nsnull);
30189:       scrollEvent.what = NPEventType_ScrollingEndsEvent;
    1: 
32019:       void* window = FixUpPluginWindow(ePluginPaintEnable);
  130:       if (window) {
43436:         mInstance->HandleEvent(&scrollEvent, nsnull);
    1:       }
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
40063: /*=============== nsIDOMFocusListener ======================*/
    1: nsresult nsPluginInstanceOwner::Focus(nsIDOMEvent * aFocusEvent)
    1: {
    1:   mContentFocused = PR_TRUE;
    1:   return DispatchFocusToPlugin(aFocusEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::Blur(nsIDOMEvent * aFocusEvent)
    1: {
    1:   mContentFocused = PR_FALSE;
    1:   return DispatchFocusToPlugin(aFocusEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent)
    1: {
    1: #ifndef XP_MACOSX
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow)) {
    1:     // continue only for cases without child window
    1:     return aFocusEvent->PreventDefault(); // consume event
    1:   }
    1: #endif
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aFocusEvent));
    1:   if (privateEvent) {
20234:     nsEvent * theEvent = privateEvent->GetInternalNSEvent();
    1:     if (theEvent) {
    1:       // we only care about the message in ProcessEvent
    1:       nsGUIEvent focusEvent(NS_IS_TRUSTED_EVENT(theEvent), theEvent->message,
    1:                             nsnull);
    1:       nsEventStatus rv = ProcessEvent(focusEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         aFocusEvent->PreventDefault();
    1:         aFocusEvent->StopPropagation();
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchFocusToPlugin failed, focusEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchFocusToPlugin failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }    
    1: 
    1: 
    1: /*=============== nsIKeyListener ======================*/
    1: nsresult nsPluginInstanceOwner::KeyDown(nsIDOMEvent* aKeyEvent)
    1: {
    1:   return DispatchKeyToPlugin(aKeyEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::KeyUp(nsIDOMEvent* aKeyEvent)
    1: {
    1:   return DispatchKeyToPlugin(aKeyEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::KeyPress(nsIDOMEvent* aKeyEvent)
    1: {
39851: #ifdef XP_MACOSX
39851: #ifndef NP_NO_CARBON
39851:   if (GetEventModel() == NPEventModelCarbon) {
    1:     // KeyPress events are really synthesized keyDown events.
    1:     // Here we check the native message of the event so that
    1:     // we won't send the plugin two keyDown events.
    1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
    1:     if (privateEvent) {
20234:       nsEvent *theEvent = privateEvent->GetInternalNSEvent();
    1:       const nsGUIEvent *guiEvent = (nsGUIEvent*)theEvent;
34743:       const EventRecord *ev = (EventRecord*)(guiEvent->pluginEvent); 
    1:       if (guiEvent &&
    1:           guiEvent->message == NS_KEY_PRESS &&
    1:           ev &&
    1:           ev->what == keyDown)
    1:         return aKeyEvent->PreventDefault(); // consume event
    1:     }
    1: 
    1:     // Nasty hack to avoid recursive event dispatching with Java. Java can
    1:     // dispatch key events to a TSM handler, which comes back and calls 
    1:     // [ChildView insertText:] on the cocoa widget, which sends a key
    1:     // event back down.
    1:     static PRBool sInKeyDispatch = PR_FALSE;
    1: 
    1:     if (sInKeyDispatch)
    1:       return aKeyEvent->PreventDefault(); // consume event
    1: 
    1:     sInKeyDispatch = PR_TRUE;
    1:     nsresult rv =  DispatchKeyToPlugin(aKeyEvent);
    1:     sInKeyDispatch = PR_FALSE;
    1:     return rv;
39851:   }
39851: #endif
39851: 
39851:   return DispatchKeyToPlugin(aKeyEvent);
    1: #else
22788:   if (SendNativeEvents())
25280:     DispatchKeyToPlugin(aKeyEvent);
22788: 
    1:   if (mInstance) {
    1:     // If this event is going to the plugin, we want to kill it.
    1:     // Not actually sending keypress to the plugin, since we didn't before.
    1:     aKeyEvent->PreventDefault();
    1:     aKeyEvent->StopPropagation();
    1:   }
    1:   return NS_OK;
    1: #endif
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent)
    1: {
25500: #if !defined(XP_MACOSX) && !defined(MOZ_COMPOSITED_PLUGINS)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aKeyEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
    1:     if (privateEvent) {
20234:       nsKeyEvent *keyEvent = (nsKeyEvent *) privateEvent->GetInternalNSEvent();
    1:       if (keyEvent) {
    1:         nsEventStatus rv = ProcessEvent(*keyEvent);
    1:         if (nsEventStatus_eConsumeNoDefault == rv) {
    1:           aKeyEvent->PreventDefault();
    1:           aKeyEvent->StopPropagation();
    1:         }
    1:       }
    1:       else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchKeyToPlugin failed, keyEvent null");   
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchKeyToPlugin failed, privateEvent null");   
    1:   }
    1: 
    1:   return NS_OK;
    1: }    
    1: 
18407: /*=============== nsIDOMMouseMotionListener ======================*/
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseMove(nsIDOMEvent* aMouseEvent)
    1: {
    1: #if !defined(XP_MACOSX)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
18408:   // don't send mouse events if we are hidden
    1:   if (!mWidgetVisible)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
20234:     nsMouseEvent* mouseEvent = (nsMouseEvent *) privateEvent->GetInternalNSEvent();
    1:     if (mouseEvent) {
    1:       nsEventStatus rv = ProcessEvent(*mouseEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         return aMouseEvent->PreventDefault(); // consume event
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseMove failed, mouseEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseMove failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
18401: /*=============== nsIDOMMouseListener ======================*/
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseDown(nsIDOMEvent* aMouseEvent)
    1: {
25500: #if !defined(XP_MACOSX) && !defined(MOZ_COMPOSITED_PLUGINS)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   // if the plugin is windowless, we need to set focus ourselves
    1:   // otherwise, we might not get key events
34679:   if (mObjectFrame && mPluginWindow &&
32799:       mPluginWindow->type == NPWindowTypeDrawable) {
29018:     
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     if (fm) {
29018:       nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(mContent);
29018:       fm->SetFocus(elem, 0);
29018:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
20234:     nsMouseEvent* mouseEvent = (nsMouseEvent *) privateEvent->GetInternalNSEvent();
    1:     if (mouseEvent) {
    1:       nsEventStatus rv = ProcessEvent(*mouseEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         return aMouseEvent->PreventDefault(); // consume event
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseDown failed, mouseEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseDown failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseUp(nsIDOMEvent* aMouseEvent)
    1: {
63215:   // Don't send a mouse-up event to the plugin if it isn't focused.  This can
63215:   // happen if the previous mouse-down was sent to a DOM element above the
63215:   // plugin, the mouse is still above the plugin, and the mouse-down event
63215:   // caused the element to disappear.  See bug 627649.
63215:   if (!mContentFocused) {
63215:     aMouseEvent->PreventDefault();
63215:     return NS_OK;
63215:   }
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseClick(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseDblClick(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseOver(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseOut(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent)
    1: {
25500: #if !defined(XP_MACOSX) && !defined(MOZ_COMPOSITED_PLUGINS)
32799:   if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow))
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
18408:   // don't send mouse events if we are hidden
    1:   if (!mWidgetVisible)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
20234:     nsMouseEvent* mouseEvent = (nsMouseEvent *) privateEvent->GetInternalNSEvent();
    1:     if (mouseEvent) {
    1:       nsEventStatus rv = ProcessEvent(*mouseEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         aMouseEvent->PreventDefault();
    1:         aMouseEvent->StopPropagation();
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, mouseEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::HandleEvent(nsIDOMEvent* aEvent)
    1: {
20592:   if (mInstance) {
32034:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aEvent));
32034:     nsCOMPtr<nsIDOMDragEvent> dragEvent(do_QueryInterface(aEvent));
32034:     if (privateEvent && dragEvent) {
32034:       nsEvent* ievent = privateEvent->GetInternalNSEvent();
32034:       if (ievent && NS_IS_TRUSTED_EVENT(ievent) &&
32034:           (ievent->message == NS_DRAGDROP_ENTER || ievent->message == NS_DRAGDROP_OVER)) {
32034:         // set the allowed effect to none here. The plugin should set it if necessary
32034:         nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
32034:         dragEvent->GetDataTransfer(getter_AddRefs(dataTransfer));
32034:         if (dataTransfer)
32034:           dataTransfer->SetEffectAllowed(NS_LITERAL_STRING("none"));
32034:       }
32034: 
20592:       // Let the plugin handle drag events.
20592:       aEvent->PreventDefault();
20592:       aEvent->StopPropagation();
20592:     }
20592:   }
    1:   return NS_OK;
    1: }
    1: 
 3060: #ifdef MOZ_X11
 3060: static unsigned int XInputEventState(const nsInputEvent& anEvent)
 3060: {
 3060:   unsigned int state = 0;
 3060:   if (anEvent.isShift) state |= ShiftMask;
 3060:   if (anEvent.isControl) state |= ControlMask;
 3060:   if (anEvent.isAlt) state |= Mod1Mask;
 3060:   if (anEvent.isMeta) state |= Mod4Mask;
 3060:   return state;
 3060: }
 3060: #endif
    1: 
25500: #ifdef MOZ_COMPOSITED_PLUGINS
28368: static void find_dest_id(XID top, XID *root, XID *dest, int target_x, int target_y)
25500: {
25500:   XID target_id = top;
25500:   XID parent;
25500:   XID *children;
25500:   unsigned int nchildren;
41059: 
43912:   Display *display = DefaultXDisplay();
41059: 
25500:   while (1) {
25500: loop:
25500:     //printf("searching %x\n", target_id);
41059:     if (!XQueryTree(display, target_id, root, &parent, &children, &nchildren) ||
31372:         !nchildren)
31372:       break;
25500:     for (unsigned int i=0; i<nchildren; i++) {
25500:       Window root;
25500:       int x, y;
25500:       unsigned int width, height;
25500:       unsigned int border_width, depth;
41059:       XGetGeometry(display, children[i], &root, &x, &y,
25500:           &width, &height, &border_width,
25500:           &depth);
25500:       //printf("target: %d %d\n", target_x, target_y);
25500:       //printf("geom: %dx%x @ %dx%d\n", width, height, x, y);
25500:       // XXX: we may need to be more careful here, i.e. if
25500:       // this condition matches more than one child
25500:       if (target_x >= x && target_y >= y &&
28368:           target_x <= x + int(width) &&
28368:           target_y <= y + int(height)) {
25500:         target_id = children[i];
25500:         // printf("found new target: %x\n", target_id);
25500:         XFree(children);
25500:         goto loop;
25500:       }
25500:     }
25500:     XFree(children);
25500:     /* no children contain the target */
25500:     break;
25500:   }
25500:   *dest = target_id;
25500: }
25500: #endif
25500: 
25500: #ifdef MOZ_COMPOSITED_PLUGINS
25500: nsEventStatus nsPluginInstanceOwner::ProcessEventX11Composited(const nsGUIEvent& anEvent)
25500: {
25500:   //printf("nsGUIEvent.message: %d\n", anEvent.message);
25500:   nsEventStatus rv = nsEventStatus_eIgnore;
34679:   if (!mInstance || !mObjectFrame)   // if mInstance is null, we shouldn't be here
25500:     return rv;
25500: 
25500:   // this code supports windowless plugins
25500:   nsIWidget* widget = anEvent.widget;
32799:   XEvent pluginEvent;
32799:   pluginEvent.type = 0;
25500: 
25500:   switch(anEvent.eventStructType)
25500:     {
25500:     case NS_MOUSE_EVENT:
25500:       {
25500:         switch (anEvent.message)
25500:           {
25500:           case NS_MOUSE_CLICK:
25500:           case NS_MOUSE_DOUBLECLICK:
25500:             // Button up/down events sent instead.
25500:             return rv;
25500:           }
25500: 
25500:         // Get reference point relative to plugin origin.
34679:         const nsPresContext* presContext = mObjectFrame->PresContext();
25500:         nsPoint appPoint =
34679:           nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
34679:           mObjectFrame->GetUsedBorderAndPadding().TopLeft();
25500:         nsIntPoint pluginPoint(presContext->AppUnitsToDevPixels(appPoint.x),
25500:                                presContext->AppUnitsToDevPixels(appPoint.y));
25500:         mLastPoint = pluginPoint;
25500:         const nsMouseEvent& mouseEvent =
25500:           static_cast<const nsMouseEvent&>(anEvent);
25500:         // Get reference point relative to screen:
25500:         nsIntPoint rootPoint(-1,-1);
25500:         if (widget)
25500:           rootPoint = anEvent.refPoint + widget->WidgetToScreenOffset();
25500: #ifdef MOZ_WIDGET_GTK2
25500:         Window root = GDK_ROOT_WINDOW();
41059: #elif defined(MOZ_WIDGET_QT)
41059:         Window root = QX11Info::appRootWindow();
25500: #else
41059:         Window root = None;
25500: #endif
25500: 
25500:         switch (anEvent.message)
25500:           {
25500:           case NS_MOUSE_ENTER_SYNTH:
25500:           case NS_MOUSE_EXIT_SYNTH:
25500:             {
32799:               XCrossingEvent& event = pluginEvent.xcrossing;
25500:               event.type = anEvent.message == NS_MOUSE_ENTER_SYNTH ?
25500:                 EnterNotify : LeaveNotify;
25500:               event.root = root;
25500:               event.time = anEvent.time;
25500:               event.x = pluginPoint.x;
25500:               event.y = pluginPoint.y;
25500:               event.x_root = rootPoint.x;
25500:               event.y_root = rootPoint.y;
25500:               event.state = XInputEventState(mouseEvent);
25500:               // information lost
25500:               event.subwindow = None;
25500:               event.mode = -1;
25500:               event.detail = NotifyDetailNone;
25500:               event.same_screen = True;
25500:               event.focus = mContentFocused;
25500:             }
25500:             break;
25500:           case NS_MOUSE_MOVE:
25500:             {
32799:               XMotionEvent& event = pluginEvent.xmotion;
25500:               event.type = MotionNotify;
25500:               event.root = root;
25500:               event.time = anEvent.time;
25500:               event.x = pluginPoint.x;
25500:               event.y = pluginPoint.y;
25500:               event.x_root = rootPoint.x;
25500:               event.y_root = rootPoint.y;
25500:               event.state = XInputEventState(mouseEvent);
25500:               // information lost
25500:               event.subwindow = None;
25500:               event.is_hint = NotifyNormal;
25500:               event.same_screen = True;
25500:               XEvent be;
32799:               be.xmotion = pluginEvent.xmotion;
25500:               //printf("xmotion: %d %d\n", be.xmotion.x, be.xmotion.y);
25500:               XID w = (XID)mPluginWindow->window;
25500:               be.xmotion.window = w;
25500:               XSendEvent (be.xmotion.display, w,
25500:                   FALSE, ButtonMotionMask, &be);
25500: 
25500:             }
25500:             break;
25500:           case NS_MOUSE_BUTTON_DOWN:
25500:           case NS_MOUSE_BUTTON_UP:
25500:             {
32799:               XButtonEvent& event = pluginEvent.xbutton;
25500:               event.type = anEvent.message == NS_MOUSE_BUTTON_DOWN ?
25500:                 ButtonPress : ButtonRelease;
25500:               event.root = root;
25500:               event.time = anEvent.time;
25500:               event.x = pluginPoint.x;
25500:               event.y = pluginPoint.y;
25500:               event.x_root = rootPoint.x;
25500:               event.y_root = rootPoint.y;
25500:               event.state = XInputEventState(mouseEvent);
25500:               switch (mouseEvent.button)
25500:                 {
25500:                 case nsMouseEvent::eMiddleButton:
25500:                   event.button = 2;
25500:                   break;
25500:                 case nsMouseEvent::eRightButton:
25500:                   event.button = 3;
25500:                   break;
25500:                 default: // nsMouseEvent::eLeftButton;
25500:                   event.button = 1;
25500:                   break;
25500:                 }
25500:               // information lost:
25500:               event.subwindow = None;
25500:               event.same_screen = True;
25500:               XEvent be;
25500:               be.xbutton =  event;
25500:               XID target;
25500:               XID root;
25500:               int wx, wy;
25500:               unsigned int width, height, border_width, depth;
25500: 
25500:               //printf("xbutton: %d %d %d\n", anEvent.message, be.xbutton.x, be.xbutton.y);
25500:               XID w = (XID)mPluginWindow->window;
43912:               XGetGeometry(DefaultXDisplay(), w, &root, &wx, &wy, &width, &height, &border_width, &depth);
25500:               find_dest_id(w, &root, &target, pluginPoint.x + wx, pluginPoint.y + wy);
25500:               be.xbutton.window = target;
43912:               XSendEvent (DefaultXDisplay(), target,
25500:                   FALSE, event.type == ButtonPress ? ButtonPressMask : ButtonReleaseMask, &be);
25500: 
25500:             }
25500:             break;
25500:           }
25500:       }
25500:       break;
25500: 
25500:    //XXX case NS_MOUSE_SCROLL_EVENT: not received.
25500:  
25500:    case NS_KEY_EVENT:
34743:       if (anEvent.pluginEvent)
25500:         {
32799:           XKeyEvent &event = pluginEvent.xkey;
25500: #ifdef MOZ_WIDGET_GTK2
25500:           event.root = GDK_ROOT_WINDOW();
25500:           event.time = anEvent.time;
25500:           const GdkEventKey* gdkEvent =
34743:             static_cast<const GdkEventKey*>(anEvent.pluginEvent);
25500:           event.keycode = gdkEvent->hardware_keycode;
25500:           event.state = gdkEvent->state;
25500:           switch (anEvent.message)
25500:             {
25500:             case NS_KEY_DOWN:
36763:               // Handle NS_KEY_DOWN for modifier key presses
36763:               // For non-modifiers we get NS_KEY_PRESS
36763:               if (gdkEvent->is_modifier)
36763:                 event.type = XKeyPress;
36763:               break;
36763:             case NS_KEY_PRESS:
25500:               event.type = XKeyPress;
25500:               break;
25500:             case NS_KEY_UP:
25500:               event.type = KeyRelease;
25500:               break;
25500:             }
25500: #endif
48345: 
48345: #ifdef MOZ_WIDGET_QT
48345:           const nsKeyEvent& keyEvent = static_cast<const nsKeyEvent&>(anEvent);
48345: 
48345:           memset( &event, 0, sizeof(event) );
48345:           event.time = anEvent.time;
48345: 
48345:           QWidget* qWidget = static_cast<QWidget*>(widget->GetNativeData(NS_NATIVE_WINDOW));
48345:           if (qWidget)
48345:             event.root = qWidget->x11Info().appRootWindow();
48345: 
48345:           // deduce keycode from the information in the attached QKeyEvent
48345:           const QKeyEvent* qtEvent = static_cast<const QKeyEvent*>(anEvent.pluginEvent);
48345:           if (qtEvent) {
48345: 
48345:             if (qtEvent->nativeModifiers())
48345:               event.state = qtEvent->nativeModifiers();
48345:             else // fallback
48345:               event.state = XInputEventState(keyEvent);
48345: 
48345:             if (qtEvent->nativeScanCode())
48345:               event.keycode = qtEvent->nativeScanCode();
48345:             else // fallback
48345:               event.keycode = XKeysymToKeycode( (widget ? static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull), qtEvent->key());
48345:           }
48345: 
48345:           switch (anEvent.message)
48345:             {
48345:             case NS_KEY_DOWN:
48345:               event.type = XKeyPress;
48345:               break;
48345:             case NS_KEY_UP:
48345:               event.type = KeyRelease;
48345:               break;
48345:            }
48345: #endif
48345: 
34743:           // Information that could be obtained from pluginEvent but we may not
25500:           // want to promise to provide:
25500:           event.subwindow = None;
25500:           event.x = 0;
25500:           event.y = 0;
25500:           event.x_root = -1;
25500:           event.y_root = -1;
25500:           event.same_screen = False;
25500:           XEvent be;
25500:           be.xkey =  event;
25500:           XID target;
25500:           XID root;
25500:           int wx, wy;
25500:           unsigned int width, height, border_width, depth;
25500: 
25500:           //printf("xkey: %d %d %d\n", anEvent.message, be.xkey.keycode, be.xkey.state);
25500:           XID w = (XID)mPluginWindow->window;
43912:           XGetGeometry(DefaultXDisplay(), w, &root, &wx, &wy, &width, &height, &border_width, &depth);
25500:           find_dest_id(w, &root, &target, mLastPoint.x + wx, mLastPoint.y + wy);
25500:           be.xkey.window = target;
43912:           XSendEvent (DefaultXDisplay(), target,
25500:               FALSE, event.type == XKeyPress ? KeyPressMask : KeyReleaseMask, &be);
25500: 
25500: 
25500:         }
25500:       else
25500:         {
25500:           // If we need to send synthesized key events, then
25500:           // DOMKeyCodeToGdkKeyCode(keyEvent.keyCode) and
25500:           // gdk_keymap_get_entries_for_keyval will be useful, but the
25500:           // mappings will not be unique.
25500:           NS_WARNING("Synthesized key event not sent to plugin");
25500:         }
25500:       break;
25500: 
25500:     default: 
25500:       switch (anEvent.message)
25500:         {
25500:         case NS_FOCUS_CONTENT:
25500:         case NS_BLUR_CONTENT:
25500:           {
32799:             XFocusChangeEvent &event = pluginEvent.xfocus;
25500:             event.type =
25500:               anEvent.message == NS_FOCUS_CONTENT ? FocusIn : FocusOut;
25500:             // information lost:
25500:             event.mode = -1;
25500:             event.detail = NotifyDetailNone;
25500:           }
25500:           break;
25500:         }
25500:     }
25500: 
32799:   if (!pluginEvent.type) {
25500:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
25500:            ("Unhandled event message %d with struct type %d\n",
25500:             anEvent.message, anEvent.eventStructType));
25500:     return rv;
25500:   }
25500: 
25500:   // Fill in (useless) generic event information.
32799:   XAnyEvent& event = pluginEvent.xany;
25500:   event.display = widget ?
25500:     static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull;
25500:   event.window = None; // not a real window
25500:   // information lost:
25500:   event.serial = 0;
25500:   event.send_event = False;
25500: 
31373: #if 0
31373:   /* we've sent the event via XSendEvent so don't send it directly to the plugin */
43436:   PRInt16 response = kNPEventNotHandled;
43436:   mInstance->HandleEvent(&pluginEvent, &response);
43436:   if (response == kNPEventHandled)
25500:     rv = nsEventStatus_eConsumeNoDefault;
31373: #endif
25500: 
25500:   return rv;
25500: }
25500: #endif
25500: 
    1: nsEventStatus nsPluginInstanceOwner::ProcessEvent(const nsGUIEvent& anEvent)
    1: {
    1:   // printf("nsGUIEvent.message: %d\n", anEvent.message);
25500: 
25500: #ifdef MOZ_COMPOSITED_PLUGINS
32799:   if (mPluginWindow && (mPluginWindow->type != NPWindowTypeDrawable))
25500:     return ProcessEventX11Composited(anEvent);
25500: #endif
25500: 
    1:   nsEventStatus rv = nsEventStatus_eIgnore;
32019: 
34679:   if (!mInstance || !mObjectFrame)   // if mInstance is null, we shouldn't be here
32019:     return nsEventStatus_eIgnore;
    1: 
    1: #ifdef XP_MACOSX
42850:   if (!mWidget)
42850:     return nsEventStatus_eIgnore;
42850: 
32019:   // we never care about synthesized mouse enter
32019:   if (anEvent.message == NS_MOUSE_ENTER_SYNTH)
32019:     return nsEventStatus_eIgnore;
32019: 
    1:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
42850:   if (!pluginWidget || NS_FAILED(pluginWidget->StartDrawPlugin()))
42850:     return nsEventStatus_eIgnore;
42850: 
32019:   NPEventModel eventModel = GetEventModel();
32019: 
32019:   // If we have to synthesize an event we'll use one of these.
32972: #ifndef NP_NO_CARBON
32019:   EventRecord synthCarbonEvent;
32972: #endif
32019:   NPCocoaEvent synthCocoaEvent;
34743:   void* event = anEvent.pluginEvent;
41424:   nsPoint pt =
41424:   nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
41424:   mObjectFrame->GetUsedBorderAndPadding().TopLeft();
34679:   nsPresContext* presContext = mObjectFrame->PresContext();
31130:   nsIntPoint ptPx(presContext->AppUnitsToDevPixels(pt.x),
31130:                   presContext->AppUnitsToDevPixels(pt.y));
41424: #ifndef NP_NO_CARBON
41424:   nsIntPoint geckoScreenCoords = mWidget->WidgetToScreenOffset();
41424:   Point carbonPt = { ptPx.y + geckoScreenCoords.y, ptPx.x + geckoScreenCoords.x };
41424:   if (eventModel == NPEventModelCarbon) {
41424:     if (event && anEvent.eventStructType == NS_MOUSE_EVENT) {
41424:       static_cast<EventRecord*>(event)->where = carbonPt;
41424:     }
41424:   }
41424: #endif
41424:   if (!event) {
32972: #ifndef NP_NO_CARBON
32019:     if (eventModel == NPEventModelCarbon) {
32019:       InitializeEventRecord(&synthCarbonEvent, &carbonPt);
32972:     } else
32972: #endif
32972:     {
32019:       InitializeNPCocoaEvent(&synthCocoaEvent);
32019:     }
31130:     
31130:     switch (anEvent.message) {
31130:       case NS_FOCUS_CONTENT:
31130:       case NS_BLUR_CONTENT:
32972: #ifndef NP_NO_CARBON
32019:         if (eventModel == NPEventModelCarbon) {
32019:           synthCarbonEvent.what = (anEvent.message == NS_FOCUS_CONTENT) ?
30189:           NPEventType_GetFocusEvent : NPEventType_LoseFocusEvent;
41747:           event = &synthCarbonEvent;
41321:         }
32972: #endif
31130:         break;
31130:       case NS_MOUSE_MOVE:
37413:       {
37413:         // Ignore mouse-moved events that happen as part of a dragging
37413:         // operation that started over another frame.  See bug 525078.
37413:         nsCOMPtr<nsFrameSelection> frameselection = mObjectFrame->GetFrameSelection();
41747:         if (!frameselection->GetMouseDownState() ||
41747:             (nsIPresShell::GetCapturingContent() == mObjectFrame->GetContent())) {
32972: #ifndef NP_NO_CARBON
32019:           if (eventModel == NPEventModelCarbon) {
32019:             synthCarbonEvent.what = osEvt;
41747:             event = &synthCarbonEvent;
32972:           } else
32972: #endif
32972:           {
32019:             synthCocoaEvent.type = NPCocoaEventMouseMoved;
32019:             synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
32019:             synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:             event = &synthCocoaEvent;
41747:           }
41747:         }
32019:       }
31130:         break;
31130:       case NS_MOUSE_BUTTON_DOWN:
32972: #ifndef NP_NO_CARBON
32019:         if (eventModel == NPEventModelCarbon) {
32019:           synthCarbonEvent.what = mouseDown;
41747:           event = &synthCarbonEvent;
32972:         } else
32972: #endif
32972:         {
32019:           synthCocoaEvent.type = NPCocoaEventMouseDown;
32019:           synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
32019:           synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:           event = &synthCocoaEvent;
32019:         }
31130:         break;
31130:       case NS_MOUSE_BUTTON_UP:
37413:         // If we're in a dragging operation that started over another frame,
37413:         // either ignore the mouse-up event (in the Carbon Event Model) or
37413:         // convert it into a mouse-entered event (in the Cocoa Event Model).
37413:         // See bug 525078.
37413:         if ((static_cast<const nsMouseEvent&>(anEvent).button == nsMouseEvent::eLeftButton) &&
37413:             (nsIPresShell::GetCapturingContent() != mObjectFrame->GetContent())) {
41747:           if (eventModel == NPEventModelCocoa) {
37413:             synthCocoaEvent.type = NPCocoaEventMouseEntered;
37413:             synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
37413:             synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:             event = &synthCocoaEvent;
37413:           }
37413:         } else {
32972: #ifndef NP_NO_CARBON
32019:           if (eventModel == NPEventModelCarbon) {
32019:             synthCarbonEvent.what = mouseUp;
41747:             event = &synthCarbonEvent;
32972:           } else
32972: #endif
32972:           {
32019:             synthCocoaEvent.type = NPCocoaEventMouseUp;
32019:             synthCocoaEvent.data.mouse.pluginX = static_cast<double>(ptPx.x);
32019:             synthCocoaEvent.data.mouse.pluginY = static_cast<double>(ptPx.y);
41747:             event = &synthCocoaEvent;
32019:           }
37413:         }
31130:         break;
33028:       default:
41747:         break;
41747:     }
41747: 
41747:     // If we still don't have an event, bail.
41747:     if (!event) {
33028:       pluginWidget->EndDrawPlugin();
33028:       return nsEventStatus_eIgnore;
31130:     }
32972:   }
32973: 
32972: #ifndef NP_NO_CARBON
    1:   // Work around an issue in the Flash plugin, which can cache a pointer
    1:   // to a doomed TSM document (one that belongs to a NSTSMInputContext)
    1:   // and try to activate it after it has been deleted. See bug 183313.
32019:   if (eventModel == NPEventModelCarbon && anEvent.message == NS_FOCUS_CONTENT)
    1:     ::DeactivateTSMDocument(::TSMGetActiveDocument());
32972: #endif
  130: 
43436:   PRInt16 response = kNPEventNotHandled;
32019:   void* window = FixUpPluginWindow(ePluginPaintEnable);
32019:   if (window || (eventModel == NPEventModelCocoa)) {
43436:     mInstance->HandleEvent(event, &response);
43436:   }
43436: 
43436:   if (eventModel == NPEventModelCocoa && response == kNPEventStartIME) {
43436:     pluginWidget->StartComplexTextInputForCurrentEvent();
43436:   }
43436: 
43436:   if ((response == kNPEventHandled || response == kNPEventStartIME) &&
33028:       !(anEvent.eventStructType == NS_MOUSE_EVENT &&
    1:         anEvent.message == NS_MOUSE_BUTTON_DOWN &&
33028:         static_cast<const nsMouseEvent&>(anEvent).button == nsMouseEvent::eLeftButton &&
    1:         !mContentFocused))
    1:     rv = nsEventStatus_eConsumeNoDefault;
    1: 
    1:   pluginWidget->EndDrawPlugin();
    1: #endif
    1: 
    1: #ifdef XP_WIN
    1:   // this code supports windowless plugins
34743:   NPEvent *pPluginEvent = (NPEvent*)anEvent.pluginEvent;
    1:   // we can get synthetic events from the nsEventStateManager... these
34743:   // have no pluginEvent
32799:   NPEvent pluginEvent;
29018:   if (anEvent.eventStructType == NS_MOUSE_EVENT) {
31130:     if (!pPluginEvent) {
31130:       // XXX Should extend this list to synthesize events for more event
31130:       // types
31130:       pluginEvent.event = 0;
31130:       const nsMouseEvent* mouseEvent = static_cast<const nsMouseEvent*>(&anEvent);
31130:       switch (anEvent.message) {
31130:       case NS_MOUSE_MOVE:
31130:         pluginEvent.event = WM_MOUSEMOVE;
31130:         break;
31130:       case NS_MOUSE_BUTTON_DOWN: {
31130:         static const int downMsgs[] =
31130:           { WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN };
36904:         static const int dblClickMsgs[] =
36904:           { WM_LBUTTONDBLCLK, WM_MBUTTONDBLCLK, WM_RBUTTONDBLCLK };
36904:         if (mouseEvent->clickCount == 2) {
36904:           pluginEvent.event = dblClickMsgs[mouseEvent->button];
36904:         } else {
31130:           pluginEvent.event = downMsgs[mouseEvent->button];
36904:         }
31130:         break;
31130:       }
31130:       case NS_MOUSE_BUTTON_UP: {
31130:         static const int upMsgs[] =
31130:           { WM_LBUTTONUP, WM_MBUTTONUP, WM_RBUTTONUP };
31130:         pluginEvent.event = upMsgs[mouseEvent->button];
31130:         break;
31130:       }
36904:       // don't synthesize anything for NS_MOUSE_DOUBLECLICK, since that
36904:       // is a synthetic event generated on mouse-up, and Windows WM_*DBLCLK
36904:       // messages are sent on mouse-down
31130:       default:
31130:         break;
31130:       }
31130:       if (pluginEvent.event) {
31130:         pPluginEvent = &pluginEvent;
31130:         pluginEvent.wParam =
31130:           (::GetKeyState(VK_CONTROL) ? MK_CONTROL : 0) |
31130:           (::GetKeyState(VK_SHIFT) ? MK_SHIFT : 0) |
31130:           (::GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0) |
31130:           (::GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0) |
31130:           (::GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0) |
31130:           (::GetKeyState(VK_XBUTTON1) ? MK_XBUTTON1 : 0) |
31130:           (::GetKeyState(VK_XBUTTON2) ? MK_XBUTTON2 : 0);
31130:       }
31130:     }
21403:     if (pPluginEvent) {
21403:       // Make event coordinates relative to our enclosing widget,
21403:       // not the widget they were received on.
32799:       // See use of NPEvent in widget/src/windows/nsWindow.cpp
21403:       // for why this assert should be safe
21403:       NS_ASSERTION(anEvent.message == NS_MOUSE_BUTTON_DOWN ||
21403:                    anEvent.message == NS_MOUSE_BUTTON_UP ||
21403:                    anEvent.message == NS_MOUSE_DOUBLECLICK ||
22564:                    anEvent.message == NS_MOUSE_ENTER_SYNTH ||
22564:                    anEvent.message == NS_MOUSE_EXIT_SYNTH ||
21403:                    anEvent.message == NS_MOUSE_MOVE,
21403:                    "Incorrect event type for coordinate translation");
33369:       nsPoint pt =
34679:         nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
34679:         mObjectFrame->GetUsedBorderAndPadding().TopLeft();
34679:       nsPresContext* presContext = mObjectFrame->PresContext();
21403:       nsIntPoint ptPx(presContext->AppUnitsToDevPixels(pt.x),
21403:                       presContext->AppUnitsToDevPixels(pt.y));
34679:       nsIntPoint widgetPtPx = ptPx + mObjectFrame->GetWindowOriginInPixels(PR_TRUE);
21403:       pPluginEvent->lParam = MAKELPARAM(widgetPtPx.x, widgetPtPx.y);
21403:     }
29018:   }
29018:   else if (!pPluginEvent) {
    1:     switch (anEvent.message) {
    1:       case NS_FOCUS_CONTENT:
    1:         pluginEvent.event = WM_SETFOCUS;
    1:         pluginEvent.wParam = 0;
    1:         pluginEvent.lParam = 0;
    1:         pPluginEvent = &pluginEvent;
    1:         break;
    1:       case NS_BLUR_CONTENT:
    1:         pluginEvent.event = WM_KILLFOCUS;
    1:         pluginEvent.wParam = 0;
    1:         pluginEvent.lParam = 0;
    1:         pPluginEvent = &pluginEvent;
    1:         break;
    1:     }
    1:   }
    1: 
37167:   if (pPluginEvent && !pPluginEvent->event) {
37167:     // Don't send null events to plugins.
37167:     NS_WARNING("nsObjectFrame ProcessEvent: trying to send null event to plugin.");
37167:     return rv;
37167:   }
37167: 
    1:   if (pPluginEvent) {
43436:     PRInt16 response = kNPEventNotHandled;
43436:     mInstance->HandleEvent(pPluginEvent, &response);
43436:     if (response == kNPEventHandled)
    1:       rv = nsEventStatus_eConsumeNoDefault;
    1:   }
    1: #endif
    1: 
 3060: #ifdef MOZ_X11
 3060:   // this code supports windowless plugins
 3060:   nsIWidget* widget = anEvent.widget;
43911:   XEvent pluginEvent = XEvent();
32799:   pluginEvent.type = 0;
 3060: 
 3060:   switch(anEvent.eventStructType)
 3060:     {
 3060:     case NS_MOUSE_EVENT:
 3060:       {
 3060:         switch (anEvent.message)
 3060:           {
 3060:           case NS_MOUSE_CLICK:
 3060:           case NS_MOUSE_DOUBLECLICK:
 3060:             // Button up/down events sent instead.
 3060:             return rv;
 3060:           }
 3060: 
 3060:         // Get reference point relative to plugin origin.
34679:         const nsPresContext* presContext = mObjectFrame->PresContext();
 3060:         nsPoint appPoint =
34679:           nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mObjectFrame) -
34679:           mObjectFrame->GetUsedBorderAndPadding().TopLeft();
 3060:         nsIntPoint pluginPoint(presContext->AppUnitsToDevPixels(appPoint.x),
 3060:                                presContext->AppUnitsToDevPixels(appPoint.y));
 3060:         const nsMouseEvent& mouseEvent =
 3233:           static_cast<const nsMouseEvent&>(anEvent);
 3060:         // Get reference point relative to screen:
25183:         nsIntPoint rootPoint(-1,-1);
 3060:         if (widget)
25183:           rootPoint = anEvent.refPoint + widget->WidgetToScreenOffset();
 3060: #ifdef MOZ_WIDGET_GTK2
 3060:         Window root = GDK_ROOT_WINDOW();
41059: #elif defined(MOZ_WIDGET_QT)
41059:         Window root = QX11Info::appRootWindow();
 3060: #else
 3060:         Window root = None; // Could XQueryTree, but this is not important.
 3060: #endif
 3060: 
 3060:         switch (anEvent.message)
 3060:           {
 3060:           case NS_MOUSE_ENTER_SYNTH:
 3060:           case NS_MOUSE_EXIT_SYNTH:
 3060:             {
32799:               XCrossingEvent& event = pluginEvent.xcrossing;
 3060:               event.type = anEvent.message == NS_MOUSE_ENTER_SYNTH ?
 3060:                 EnterNotify : LeaveNotify;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               // information lost
 3060:               event.subwindow = None;
 3060:               event.mode = -1;
 3060:               event.detail = NotifyDetailNone;
 3060:               event.same_screen = True;
 3060:               event.focus = mContentFocused;
 3060:             }
 3060:             break;
 3060:           case NS_MOUSE_MOVE:
 3060:             {
32799:               XMotionEvent& event = pluginEvent.xmotion;
 3060:               event.type = MotionNotify;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               // information lost
 3060:               event.subwindow = None;
 3060:               event.is_hint = NotifyNormal;
 3060:               event.same_screen = True;
 3060:             }
 3060:             break;
 3060:           case NS_MOUSE_BUTTON_DOWN:
 3060:           case NS_MOUSE_BUTTON_UP:
 3060:             {
32799:               XButtonEvent& event = pluginEvent.xbutton;
 3060:               event.type = anEvent.message == NS_MOUSE_BUTTON_DOWN ?
 3060:                 ButtonPress : ButtonRelease;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               switch (mouseEvent.button)
 3060:                 {
 3060:                 case nsMouseEvent::eMiddleButton:
 3060:                   event.button = 2;
 3060:                   break;
 3060:                 case nsMouseEvent::eRightButton:
 3060:                   event.button = 3;
 3060:                   break;
 3060:                 default: // nsMouseEvent::eLeftButton;
 3060:                   event.button = 1;
 3060:                   break;
 3060:                 }
 3060:               // information lost:
 3060:               event.subwindow = None;
 3060:               event.same_screen = True;
 3060:             }
 3060:             break;
 3060:           }
 3060:       }
 3060:       break;
 3060: 
 3060:    //XXX case NS_MOUSE_SCROLL_EVENT: not received.
 3060:  
 3060:    case NS_KEY_EVENT:
34743:       if (anEvent.pluginEvent)
 3060:         {
32799:           XKeyEvent &event = pluginEvent.xkey;
 3060: #ifdef MOZ_WIDGET_GTK2
 3060:           event.root = GDK_ROOT_WINDOW();
 3060:           event.time = anEvent.time;
 3060:           const GdkEventKey* gdkEvent =
34743:             static_cast<const GdkEventKey*>(anEvent.pluginEvent);
 3060:           event.keycode = gdkEvent->hardware_keycode;
 3060:           event.state = gdkEvent->state;
 3060:           switch (anEvent.message)
 3060:             {
 3060:             case NS_KEY_DOWN:
36763:               // Handle NS_KEY_DOWN for modifier key presses
36763:               // For non-modifiers we get NS_KEY_PRESS
36763:               if (gdkEvent->is_modifier)
36763:                 event.type = XKeyPress;
36763:               break;
36763:             case NS_KEY_PRESS:
 3060:               event.type = XKeyPress;
 3060:               break;
 3060:             case NS_KEY_UP:
 3060:               event.type = KeyRelease;
 3060:               break;
 3060:             }
 3060: #endif
48345: 
48345: #ifdef MOZ_WIDGET_QT
48345:           const nsKeyEvent& keyEvent = static_cast<const nsKeyEvent&>(anEvent);
48345: 
48345:           memset( &event, 0, sizeof(event) );
48345:           event.time = anEvent.time;
48345: 
48345:           QWidget* qWidget = static_cast<QWidget*>(widget->GetNativeData(NS_NATIVE_WINDOW));
48345:           if (qWidget)
48345:             event.root = qWidget->x11Info().appRootWindow();
48345: 
48345:           // deduce keycode from the information in the attached QKeyEvent
48345:           const QKeyEvent* qtEvent = static_cast<const QKeyEvent*>(anEvent.pluginEvent);
48345:           if (qtEvent) {
48345: 
48345:             if (qtEvent->nativeModifiers())
48345:               event.state = qtEvent->nativeModifiers();
48345:             else // fallback
48345:               event.state = XInputEventState(keyEvent);
48345: 
48345:             if (qtEvent->nativeScanCode())
48345:               event.keycode = qtEvent->nativeScanCode();
48345:             else // fallback
48345:               event.keycode = XKeysymToKeycode( (widget ? static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull), qtEvent->key());
48345:           }
48345: 
48345:           switch (anEvent.message)
48345:             {
48345:             case NS_KEY_DOWN:
48345:               event.type = XKeyPress;
48345:               break;
48345:             case NS_KEY_UP:
48345:               event.type = KeyRelease;
48345:               break;
48345:            }
48345: #endif
34743:           // Information that could be obtained from pluginEvent but we may not
 3060:           // want to promise to provide:
 3060:           event.subwindow = None;
 3060:           event.x = 0;
 3060:           event.y = 0;
 3060:           event.x_root = -1;
 3060:           event.y_root = -1;
 3060:           event.same_screen = False;
 3060:         }
 3060:       else
 3060:         {
 3060:           // If we need to send synthesized key events, then
 3060:           // DOMKeyCodeToGdkKeyCode(keyEvent.keyCode) and
 3060:           // gdk_keymap_get_entries_for_keyval will be useful, but the
 3060:           // mappings will not be unique.
 3060:           NS_WARNING("Synthesized key event not sent to plugin");
 3060:         }
 3060:       break;
 3060: 
 3060:     default: 
 3060:       switch (anEvent.message)
 3060:         {
 3060:         case NS_FOCUS_CONTENT:
 3060:         case NS_BLUR_CONTENT:
 3060:           {
32799:             XFocusChangeEvent &event = pluginEvent.xfocus;
 3060:             event.type =
 3060:               anEvent.message == NS_FOCUS_CONTENT ? FocusIn : FocusOut;
 3060:             // information lost:
 3060:             event.mode = -1;
 3060:             event.detail = NotifyDetailNone;
 3060:           }
 3060:           break;
 3060:         }
 3060:     }
 3060: 
32799:   if (!pluginEvent.type) {
 3060:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
 3060:            ("Unhandled event message %d with struct type %d\n",
 3060:             anEvent.message, anEvent.eventStructType));
 3060:     return rv;
 3060:   }
 3060: 
 3060:   // Fill in (useless) generic event information.
32799:   XAnyEvent& event = pluginEvent.xany;
 3060:   event.display = widget ?
 3233:     static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull;
 3060:   event.window = None; // not a real window
 3060:   // information lost:
 3060:   event.serial = 0;
 3060:   event.send_event = False;
 3060: 
43436:   PRInt16 response = kNPEventNotHandled;
43436:   mInstance->HandleEvent(&pluginEvent, &response);
43436:   if (response == kNPEventHandled)
 3060:     rv = nsEventStatus_eConsumeNoDefault;
 3060: #endif
 3060: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::Destroy()
    1: {
36227: #ifdef MAC_CARBON_PLUGINS
    1:   // stop the timer explicitly to reduce reference count.
    1:   CancelTimer();
36227: #endif
39757: #ifdef XP_MACOSX
39757:   RemoveFromCARefreshTimer(this);
42504:   if (mIOSurface)
42504:     delete mIOSurface;
39757: #endif
    1: 
    1:   // unregister context menu listener
    1:   if (mCXMenuListener) {
    1:     mCXMenuListener->Destroy(mContent);
12417:     mCXMenuListener = nsnull;
    1:   }
    1: 
 1418:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
 1418:   if (target) {
    1: 
    1:     nsCOMPtr<nsIDOMEventListener> listener;
    1:     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
    1: 
    1:     // Unregister focus event listener
 1418:     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMFocusListener));
    1: 
    1:     // Unregister mouse event listener
 1418:     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseListener));
    1: 
    1:     // now for the mouse motion listener
 1418:     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseMotionListener));
    1: 
    1:     // Unregister key event listener;
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("keypress"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
    1: 
    1:     // Unregister drag event listener;
20592:     target->RemoveEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
20592:     target->RemoveEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
20592:     target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
20592:     target->RemoveEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
20592:     target->RemoveEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
20592:     target->RemoveEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
    1:   }
    1: 
14641:   if (mWidget) {
14641:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
14641:     if (pluginWidget)
14641:       pluginWidget->SetPluginInstanceOwner(nsnull);
14641: 
14641:     if (mDestroyWidget)
 4577:       mWidget->Destroy();
 4577:   }
 4577: 
 4577:   return NS_OK;
 4577: }
 4577: 
 4577: /*
 4577:  * Prepare to stop 
 4577:  */
 4577: void
 4577: nsPluginInstanceOwner::PrepareToStop(PRBool aDelayedStop)
 4577: {
54223:   // Drop image reference because the child may destroy the surface after we return.
54223:   nsRefPtr<ImageContainer> container = mObjectFrame->GetImageContainer();
58485:   if (container) {
54223:     container->SetCurrentImage(nsnull);
58485:   }
54223: 
28366: #if defined(XP_WIN) || defined(MOZ_X11)
 7779:   if (aDelayedStop && mWidget) {
 4577:     // To delay stopping a plugin we need to reparent the plugin
 4577:     // so that we can safely tear down the
 4577:     // plugin after its frame (and view) is gone.
 4577: 
 4577:     // Also hide and disable the widget to avoid it from appearing in
 4577:     // odd places after reparenting it, but before it gets destroyed.
 4577:     mWidget->Show(PR_FALSE);
 4577:     mWidget->Enable(PR_FALSE);
 4577: 
 4577:     // Reparent the plugins native window. This relies on the widget
 4577:     // and plugin et al not holding any other references to its
 4577:     // parent.
 4577:     mWidget->SetParent(nsnull);
 4577: 
 4577:     mDestroyWidget = PR_TRUE;
 4577:   }
 4577: #endif
 4577: 
37067:   // Unregister scroll position listeners
37067:   for (nsIFrame* f = mObjectFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37067:     nsIScrollableFrame* sf = do_QueryFrame(f);
37067:     if (sf) {
37067:       sf->RemoveScrollPositionListener(this);
37067:     }
    1:   }
    1: }
    1: 
    1: // Paints are handled differently, so we just simulate an update event.
    1: 
 3059: #ifdef XP_MACOSX
34717: void nsPluginInstanceOwner::Paint(const gfxRect& aDirtyRect, CGContextRef cgContext)
    1: {
34679:   if (!mInstance || !mObjectFrame)
    1:     return;
    1:  
    1:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:   if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
34737: #ifndef NP_NO_CARBON
32019:     void* window = FixUpPluginWindow(ePluginPaintEnable);
32019:     if (GetEventModel() == NPEventModelCarbon && window) {
    1:       EventRecord updateEvent;
31130:       InitializeEventRecord(&updateEvent, nsnull);
    1:       updateEvent.what = updateEvt;
  130:       updateEvent.message = UInt32(window);
  130: 
43436:       mInstance->HandleEvent(&updateEvent, nsnull);
34717:     } else if (GetEventModel() == NPEventModelCocoa)
32972: #endif
32972:     {
62474:       DoCocoaEventDrawRect(aDirtyRect, cgContext);
62474:     }
62474:     pluginWidget->EndDrawPlugin();
62474:   }
62474: }
62474: 
62474: void nsPluginInstanceOwner::DoCocoaEventDrawRect(const gfxRect& aDrawRect, CGContextRef cgContext)
62474: {
32019:   // The context given here is only valid during the HandleEvent call.
32019:   NPCocoaEvent updateEvent;
32019:   InitializeNPCocoaEvent(&updateEvent);
32019:   updateEvent.type = NPCocoaEventDrawRect;
34717:   updateEvent.data.draw.context = cgContext;
62474:   updateEvent.data.draw.x = aDrawRect.X();
62474:   updateEvent.data.draw.y = aDrawRect.Y();
62474:   updateEvent.data.draw.width = aDrawRect.Width();
62474:   updateEvent.data.draw.height = aDrawRect.Height();
32019: 
43436:   mInstance->HandleEvent(&updateEvent, nsnull);
32019: }
    1: #endif
    1: 
    1: #ifdef XP_WIN
21080: void nsPluginInstanceOwner::Paint(const RECT& aDirty, HDC aDC)
 3059: {
34679:   if (!mInstance || !mObjectFrame)
 3059:     return;
 3059: 
32799:   NPEvent pluginEvent;
    1:   pluginEvent.event = WM_PAINT;
21080:   pluginEvent.wParam = WPARAM(aDC);
21080:   pluginEvent.lParam = LPARAM(&aDirty);
43436:   mInstance->HandleEvent(&pluginEvent, nsnull);
 3059: }
    1: #endif
 3059: 
12859: #ifdef XP_OS2
12859: void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, HPS aHPS)
12859: {
34679:   if (!mInstance || !mObjectFrame)
12859:     return;
12859: 
32799:   NPWindow *window;
12859:   GetWindow(window);
34679:   nsIntRect relDirtyRect = aDirtyRect.ToOutsidePixels(mObjectFrame->PresContext()->AppUnitsPerDevPixel());
12859: 
12859:   // we got dirty rectangle in relative window coordinates, but we
12859:   // need it in absolute units and in the (left, top, right, bottom) form
12859:   RECTL rectl;
23738:   rectl.xLeft   = relDirtyRect.x + window->x;
23738:   rectl.yBottom = relDirtyRect.y + window->y;
23738:   rectl.xRight  = rectl.xLeft + relDirtyRect.width;
23738:   rectl.yTop    = rectl.yBottom + relDirtyRect.height;
12859: 
32799:   NPEvent pluginEvent;
12859:   pluginEvent.event = WM_PAINT;
12859:   pluginEvent.wParam = (uint32)aHPS;
12859:   pluginEvent.lParam = (uint32)&rectl;
43436:   mInstance->HandleEvent(&pluginEvent, nsnull);
12859: }
12859: #endif
12859: 
47118: #if defined(MOZ_X11)
15688: void nsPluginInstanceOwner::Paint(gfxContext* aContext,
15688:                                   const gfxRect& aFrameRect,
15688:                                   const gfxRect& aDirtyRect)
 3059: {
34679:   if (!mInstance || !mObjectFrame)
 3059:     return;
 3059: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35208:   // through to be able to paint the context passed in.  This allows
35208:   // us to handle plugins that do not self invalidate (slowly, but
35208:   // accurately), and it allows us to reduce flicker.
35171:   PRBool simpleImageRender = PR_FALSE;
35171:   mInstance->GetValueFromPlugin(NPPVpluginWindowlessLocalBool,
35171:                                 &simpleImageRender);
35171:   if (simpleImageRender) {
35171:     gfxMatrix matrix = aContext->CurrentMatrix();
35208:     if (!matrix.HasNonAxisAlignedTransform())
35208:       NativeImageDraw();
35212:     return;
35171:   } 
35171: #endif
35171: 
15688:   // to provide crisper and faster drawing.
15688:   gfxRect pluginRect = aFrameRect;
15688:   if (aContext->UserToDevicePixelSnapped(pluginRect)) {
15688:     pluginRect = aContext->DeviceToUser(pluginRect);
15688:   }
15688: 
15688:   // Round out the dirty rect to plugin pixels to ensure the plugin draws
15688:   // enough pixels for interpolation to device pixels.
15688:   gfxRect dirtyRect = aDirtyRect + -pluginRect.pos;
15688:   dirtyRect.RoundOut();
15688: 
15688:   // Plugins can only draw an integer number of pixels.
15688:   //
15688:   // With translation-only transformation matrices, pluginRect is already
15688:   // pixel-aligned.
15688:   //
15688:   // With more complex transformations, modifying the scales in the
15688:   // transformation matrix could retain subpixel accuracy and let the plugin
15688:   // draw a suitable number of pixels for interpolation to device pixels in
15688:   // Renderer::Draw, but such cases are not common enough to warrant the
15688:   // effort now.
15688:   nsIntSize pluginSize(NS_lround(pluginRect.size.width),
15688:                        NS_lround(pluginRect.size.height));
15688: 
15688:   // Determine what the plugin needs to draw.
15688:   nsIntRect pluginDirtyRect(PRInt32(dirtyRect.pos.x),
15688:                             PRInt32(dirtyRect.pos.y),
15688:                             PRInt32(dirtyRect.size.width),
15688:                             PRInt32(dirtyRect.size.height));
15688:   if (!pluginDirtyRect.
15688:       IntersectRect(nsIntRect(0, 0, pluginSize.width, pluginSize.height),
15688:                     pluginDirtyRect))
15688:     return;
15688: 
32799:   NPWindow* window;
 3059:   GetWindow(window);
 3059: 
47118:   PRUint32 rendererFlags = 0;
47115:   if (!mFlash10Quirks) {
47115:     rendererFlags |=
 3059:       Renderer::DRAW_SUPPORTS_CLIP_RECT |
47118:       Renderer::DRAW_SUPPORTS_ALTERNATE_VISUAL;
47115:   }
 3059: 
32799:   PRBool transparent;
32799:   mInstance->IsTransparent(&transparent);
 3059:   if (!transparent)
 3059:     rendererFlags |= Renderer::DRAW_IS_OPAQUE;
 3059: 
15688:   // Renderer::Draw() draws a rectangle with top-left at the aContext origin.
15688:   gfxContextAutoSaveRestore autoSR(aContext);
15688:   aContext->Translate(pluginRect.pos);
 3059: 
47115:   Renderer renderer(window, this, pluginSize, pluginDirtyRect);
47118: #ifdef MOZ_WIDGET_GTK2
47118:   // This is the visual used by the widgets, 24-bit if available.
47118:   GdkVisual* gdkVisual = gdk_rgb_get_visual();
47118:   Visual* visual = gdk_x11_visual_get_xvisual(gdkVisual);
47118:   Screen* screen =
47118:     gdk_x11_screen_get_xscreen(gdk_visual_get_screen(gdkVisual));
47118: #endif
47118: #ifdef MOZ_WIDGET_QT
47118:   Display* dpy = QX11Info().display();
47118:   Screen* screen = ScreenOfDisplay(dpy, QX11Info().screen());
47118:   Visual* visual = static_cast<Visual*>(QX11Info().visual());
47118: #endif
47118:   renderer.Draw(aContext, nsIntSize(window->width, window->height),
47118:                 rendererFlags, screen, visual, nsnull);
 3059: }
 3059: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
34217: 
35171: static GdkWindow* GetClosestWindow(nsIDOMElement *element)
35171: {
35171:   nsCOMPtr<nsIContent> content = do_QueryInterface(element);
36656:   nsIFrame* frame = content->GetPrimaryFrame();
35171:   if (!frame)
35171:     return nsnull;
35171: 
47148:   nsIWidget* win = frame->GetNearestWidget();
35171:   if (!win)
35171:     return nsnull;
35171: 
35171:   GdkWindow* w = static_cast<GdkWindow*>(win->GetNativeData(NS_NATIVE_WINDOW));
35171:   return w;
35171: }
35171: 
35171: void
35171: nsPluginInstanceOwner::ReleaseXShm()
35171: {
35197:   if (mXlibSurfGC) {
35197:     XFreeGC(gdk_x11_get_default_xdisplay(), mXlibSurfGC);
35197:     mXlibSurfGC = None;
35197:   }
35197:  
35171:  if (mSharedSegmentInfo.shmaddr) {
35171:     XShmDetach(gdk_x11_get_default_xdisplay(), &mSharedSegmentInfo);
35171:     shmdt(mSharedSegmentInfo.shmaddr);
35171:     mSharedSegmentInfo.shmaddr = nsnull;
35171:   }
35171: 
35171:   if (mSharedXImage) {
35171:     XDestroyImage(mSharedXImage);
35171:     mSharedXImage = nsnull;
35171:   }
35171: }
35171: 
35171: PRBool
35171: nsPluginInstanceOwner::SetupXShm()
35171: {
35171:   if (!mBlitWindow)
35171:     return PR_FALSE;
35171: 
35171:   ReleaseXShm();
35171: 
35197:   mXlibSurfGC = XCreateGC(gdk_x11_get_default_xdisplay(),
35197:                           mBlitWindow,
35197:                           0,
35197:                           0);
35197:   if (!mXlibSurfGC)
35197:     return PR_FALSE;
35197: 
35171:   // we use 16 as the default depth because that is the value of the
35171:   // screen, but not the default X default depth.
35171:   XVisualInfo vinfo;
35171:   int foundVisual = XMatchVisualInfo(gdk_x11_get_default_xdisplay(),
35171:                                      gdk_x11_get_default_screen(),
35171:                                      16,
35171:                                      TrueColor,
35171:                                      &vinfo);
35171:   if (!foundVisual) 
35171:     return PR_FALSE;
35171: 
35171:   memset(&mSharedSegmentInfo, 0, sizeof(XShmSegmentInfo));
35171:   mSharedXImage = XShmCreateImage(gdk_x11_get_default_xdisplay(),
35171:                                   vinfo.visual,
35171:                                   16,
35171:                                   ZPixmap,
35171:                                   0,
35171:                                   &mSharedSegmentInfo,
35171:                                   mPluginSize.width,
35171:                                   mPluginSize.height);
35171:   if (!mSharedXImage)
35171:     return PR_FALSE;
35171: 
35208:   NS_ASSERTION(mSharedXImage->height, "do not call shmget with zero");
35171:   mSharedSegmentInfo.shmid = shmget(IPC_PRIVATE,
35171:                                     mSharedXImage->bytes_per_line * mSharedXImage->height,
40910:                                     IPC_CREAT | 0600);
35208:   if (mSharedSegmentInfo.shmid == -1) {
35208:     XDestroyImage(mSharedXImage);
35208:     mSharedXImage = nsnull;
35208:     return PR_FALSE;
35208:   }
35171: 
35171:   mSharedXImage->data = static_cast<char*>(shmat(mSharedSegmentInfo.shmid, 0, 0));
35208:   if (mSharedXImage->data == (char*) -1) {
35208:     shmctl(mSharedSegmentInfo.shmid, IPC_RMID, 0);
35208:     XDestroyImage(mSharedXImage);
35208:     mSharedXImage = nsnull;
35208:     return PR_FALSE;
35208:   }
35208:     
35171:   mSharedSegmentInfo.shmaddr = mSharedXImage->data;
35171:   mSharedSegmentInfo.readOnly = False;
35171: 
35171:   Status s = XShmAttach(gdk_x11_get_default_xdisplay(), &mSharedSegmentInfo);
35171:   XSync(gdk_x11_get_default_xdisplay(), False);
35171:   shmctl(mSharedSegmentInfo.shmid, IPC_RMID, 0);
35171:   if (!s) {
35171:     // attach failed, call shmdt and null shmaddr before calling
35171:     // ReleaseXShm().
35171:     shmdt(mSharedSegmentInfo.shmaddr);
35171:     mSharedSegmentInfo.shmaddr = nsnull;
35171:     ReleaseXShm();
35171:     return PR_FALSE;
35171:   }
35171: 
35171:   return PR_TRUE;
35171: }
35171: 
35171: 
34217: // NativeImageDraw
34217: //
34217: // This method supports the NPImageExpose API which is specific to the
34217: // HILDON platform.  Basically what it allows us to do is to pass a
36573: // memory buffer into a plugin (namely flash), and have flash draw
34217: // directly into the buffer.
34217: //
34217: // It may be faster if the rest of the system used offscreen image
34217: // surfaces, but right now offscreen surfaces are using X
34217: // surfaces. And because of this, we need to create a new image
34217: // surface and copy that to the passed gfx context.
34217: //
34217: // This is not ideal and it should not be faster than what a
34217: // windowless plugin can do.  However, in A/B testing of flash on the
34217: // N900, this approach is considerably faster.
34217: //
34217: // Hopefully this API can die off in favor of a more robust plugin API.
34217: 
35208: void
35208: nsPluginInstanceOwner::NativeImageDraw(NPRect* invalidRect)
35171: {
35171:   // if we haven't been positioned yet, ignore
37357:   if (!mBlitWindow)
35208:     return;
35171: 
35171:   // if the clip rect is zero, we have nothing to do.
35199:   if (NSToIntCeil(mAbsolutePositionClip.Width()) == 0 ||
35199:       NSToIntCeil(mAbsolutePositionClip.Height()) == 0)
35208:     return;
35171:   
35199:   // The flash plugin on Maemo n900 requires the width/height to be
35199:   // even.
35199:   PRInt32 absPosWidth  = NSToIntCeil(mAbsolutePosition.Width()) / 2 * 2;
35199:   PRInt32 absPosHeight = NSToIntCeil(mAbsolutePosition.Height()) / 2 * 2;
35199: 
35208:   // if the plugin is hidden, nothing to draw.
35208:   if (absPosHeight == 0 || absPosWidth == 0)
35208:     return;
35208: 
37400:   // Making X or DOM method calls can cause our frame to go
37400:   // away, which might kill us...
37400:   nsCOMPtr<nsIPluginInstanceOwner> kungFuDeathGrip(this);
37400: 
36573:   PRBool sizeChanged = (mPluginSize.width != absPosWidth ||
36573:                         mPluginSize.height != absPosHeight);
36573: 
36573:   if (!mSharedXImage || sizeChanged) {
35199:     mPluginSize = nsIntSize(absPosWidth, absPosHeight);
35171: 
35171:     if (NS_FAILED(SetupXShm()))
35208:       return;
35171:   }  
35171:   
35171:   NPWindow* window;
35171:   GetWindow(window);
35171:   NS_ASSERTION(window, "Window can not be null");
35171: 
35171:   // setup window such that it knows about the size and clip.  This
35171:   // is to work around a flash clipping bug when using the Image
35171:   // Expose API.
36573:   if (!invalidRect && sizeChanged) {
34217:     NPRect newClipRect;
35171:     newClipRect.left = 0;
35171:     newClipRect.top = 0;
35171:     newClipRect.right = window->width;
35171:     newClipRect.bottom = window->height;
35171:     
35171:     window->clipRect = newClipRect; 
35171:     window->x = 0;
35171:     window->y = 0;
34217:       
34217:     NPSetWindowCallbackStruct* ws_info =
35171:       static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
34217:     ws_info->visual = 0;
34217:     ws_info->colormap = 0;
35171:     ws_info->depth = 16;
35171:     mInstance->SetWindow(window);
36573:   }
35171: 
35171:   NPEvent pluginEvent;
34217:   NPImageExpose imageExpose;
34217:   XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
34217: 
34217:   // set the drawing info
34217:   exposeEvent.type = GraphicsExpose;
34217:   exposeEvent.display = 0;
34217: 
34217:   // Store imageExpose structure pointer as drawable member
34217:   exposeEvent.drawable = (Drawable)&imageExpose;
34217:   exposeEvent.count = 0;
34217:   exposeEvent.serial = 0;
34217:   exposeEvent.send_event = False;
34217:   exposeEvent.major_code = 0;
34217:   exposeEvent.minor_code = 0;
34217: 
35171:   exposeEvent.x = 0;
35171:   exposeEvent.y = 0;
35171:   exposeEvent.width  = window->width;
35171:   exposeEvent.height = window->height;
35171: 
35171:   imageExpose.x = 0;
35171:   imageExpose.y = 0;
35171:   imageExpose.width  = window->width;
35171:   imageExpose.height = window->height;
35171: 
35171:   imageExpose.depth = 16;
35171: 
35171:   imageExpose.translateX = 0;
35171:   imageExpose.translateY = 0;
35171: 
35199:   if (window->width == 0)
35208:     return;
35199:   
35199:   float scale = mAbsolutePosition.Width() / (float) window->width;
35199:   
35199:   imageExpose.scaleX = scale;
35199:   imageExpose.scaleY = scale;
35171: 
35171:   imageExpose.stride          = mPluginSize.width * 2;
35171:   imageExpose.data            = mSharedXImage->data;
35171:   imageExpose.dataSize.width  = mPluginSize.width;
35171:   imageExpose.dataSize.height = mPluginSize.height; 
34217: 
35208:   if (invalidRect)
35208:     memset(mSharedXImage->data, 0, mPluginSize.width * mPluginSize.height * 2);
35208: 
43436:   PRInt16 response = kNPEventNotHandled;
43436:   mInstance->HandleEvent(&pluginEvent, &response);
43436:   if (response == kNPEventNotHandled)
35208:     return;
35171: 
35171:   // Setup the clip rectangle
35171:   XRectangle rect;
35199:   rect.x = NSToIntFloor(mAbsolutePositionClip.X());
35199:   rect.y = NSToIntFloor(mAbsolutePositionClip.Y());
35199:   rect.width = NSToIntCeil(mAbsolutePositionClip.Width());
35199:   rect.height = NSToIntCeil(mAbsolutePositionClip.Height());
35199:   
35199:   PRInt32 absPosX = NSToIntFloor(mAbsolutePosition.X());
35199:   PRInt32 absPosY = NSToIntFloor(mAbsolutePosition.Y());
35171:   
35171:   XSetClipRectangles(gdk_x11_get_default_xdisplay(),
35197:                      mXlibSurfGC,
35199:                      absPosX,
35199:                      absPosY, 
35171:                      &rect, 1,
35171:                      Unsorted);
35171: 
35171:   XShmPutImage(gdk_x11_get_default_xdisplay(),
35171:                mBlitWindow,
35197:                mXlibSurfGC,
35171:                mSharedXImage,
35171:                0,
35171:                0,
35199:                absPosX,
35199:                absPosY,
35171:                mPluginSize.width,
35171:                mPluginSize.height,
35171:                PR_FALSE);
35171:   
35197:   XSetClipRectangles(gdk_x11_get_default_xdisplay(), mXlibSurfGC, 0, 0, nsnull, 0, Unsorted);  
35197: 
35171:   XFlush(gdk_x11_get_default_xdisplay());
35208:   return;
34217: }
34217: #endif
34217: 
 3059: nsresult
47118: nsPluginInstanceOwner::Renderer::DrawWithXlib(gfxXlibSurface* xsurface, 
47118:                                               nsIntPoint offset,
47118:                                               nsIntRect *clipRects, 
 3059:                                               PRUint32 numClipRects)
47118: {
41059:   Screen *screen = cairo_xlib_surface_get_screen(xsurface->CairoSurface());
47118:   Colormap colormap;
47118:   Visual* visual;
47118:   if (!xsurface->GetColormapAndVisual(&colormap, &visual)) {
47118:     NS_ERROR("Failed to get visual and colormap");
47118:     return NS_ERROR_UNEXPECTED;
47118:   }
47115: 
47115:   nsIPluginInstance *instance = mInstanceOwner->mInstance;
47115:   if (!instance)
47115:     return NS_ERROR_FAILURE;
47115: 
 3059:   // See if the plugin must be notified of new window parameters.
 3059:   PRBool doupdatewindow = PR_FALSE;
 3059: 
47118:   if (mWindow->x != offset.x || mWindow->y != offset.y) {
47118:     mWindow->x = offset.x;
47118:     mWindow->y = offset.y;
 3059:     doupdatewindow = PR_TRUE;
 3059:   }
 3059: 
15688:   if (nsIntSize(mWindow->width, mWindow->height) != mPluginSize) {
15688:     mWindow->width = mPluginSize.width;
15688:     mWindow->height = mPluginSize.height;
15688:     doupdatewindow = PR_TRUE;
15688:   }
15688: 
16083:   // The clip rect is relative to drawable top-left.
 3059:   NS_ASSERTION(numClipRects <= 1, "We don't support multiple clip rectangles!");
16083:   nsIntRect clipRect;
 3059:   if (numClipRects) {
16083:     clipRect.x = clipRects[0].x;
16083:     clipRect.y = clipRects[0].y;
16083:     clipRect.width  = clipRects[0].width;
16083:     clipRect.height = clipRects[0].height;
48107:     // NPRect members are unsigned, but clip rectangles should be contained by
48107:     // the surface.
48107:     NS_ASSERTION(clipRect.x >= 0 && clipRect.y >= 0,
48107:                  "Clip rectangle offsets are negative!");
 3059:   }
 3059:   else {
47118:     clipRect.x = offset.x;
47118:     clipRect.y = offset.y;
16083:     clipRect.width  = mWindow->width;
16083:     clipRect.height = mWindow->height;
48107:     // Don't ask the plugin to draw outside the drawable.
48107:     // This also ensures that the unsigned clip rectangle offsets won't be -ve.
48107:     gfxIntSize surfaceSize = xsurface->GetSize();
48107:     clipRect.IntersectRect(clipRect,
48107:                            nsIntRect(0, 0,
48107:                                      surfaceSize.width, surfaceSize.height));
16083:   }
16083: 
32799:   NPRect newClipRect;
16083:   newClipRect.left = clipRect.x;
16083:   newClipRect.top = clipRect.y;
16083:   newClipRect.right = clipRect.XMost();
16083:   newClipRect.bottom = clipRect.YMost();
 3059:   if (mWindow->clipRect.left    != newClipRect.left   ||
 3059:       mWindow->clipRect.top     != newClipRect.top    ||
 3059:       mWindow->clipRect.right   != newClipRect.right  ||
 3059:       mWindow->clipRect.bottom  != newClipRect.bottom) {
 3059:     mWindow->clipRect = newClipRect;
 3059:     doupdatewindow = PR_TRUE;
 3059:   }
 3059: 
 3059:   NPSetWindowCallbackStruct* ws_info = 
 3233:     static_cast<NPSetWindowCallbackStruct*>(mWindow->ws_info);
16528: #ifdef MOZ_X11
15703:   if (ws_info->visual != visual || ws_info->colormap != colormap) {
 3059:     ws_info->visual = visual;
15703:     ws_info->colormap = colormap;
47113:     ws_info->depth = gfxXlibSurface::DepthOfVisual(screen, visual);
 3059:     doupdatewindow = PR_TRUE;
 3059:   }
16528: #endif
 3059: 
28368: #ifdef MOZ_COMPOSITED_PLUGINS
32799:   if (mWindow->type == NPWindowTypeDrawable)
28368: #endif
28368:   {
 3059:     if (doupdatewindow)
47115:       instance->SetWindow(mWindow);
28368:   }
 3059: 
47115:   // Translate the dirty rect to drawable coordinates.
47118:   nsIntRect dirtyRect = mDirtyRect + offset;
47115:   if (mInstanceOwner->mFlash10Quirks) {
47115:     // Work around a bug in Flash up to 10.1 d51 at least, where expose event
47115:     // top left coordinates within the plugin-rect and not at the drawable
47115:     // origin are misinterpreted.  (We can move the top left coordinate
47115:     // provided it is within the clipRect.)
47118:     dirtyRect.SetRect(offset.x, offset.y,
36767:                       mDirtyRect.XMost(), mDirtyRect.YMost());
47115:   }
16083:   // Intersect the dirty rect with the clip rect to ensure that it lies within
16083:   // the drawable.
16083:   if (!dirtyRect.IntersectRect(dirtyRect, clipRect))
16083:     return NS_OK;
16083: 
28368: #ifdef MOZ_COMPOSITED_PLUGINS
32799:   if (mWindow->type == NPWindowTypeDrawable) {
28368: #endif
43911:     XEvent pluginEvent = XEvent();
32799:     XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
 3059:     // set the drawing info
 3059:     exposeEvent.type = GraphicsExpose;
15703:     exposeEvent.display = DisplayOfScreen(screen);
47118:     exposeEvent.drawable = xsurface->XDrawable();
36767:     exposeEvent.x = dirtyRect.x;
36767:     exposeEvent.y = dirtyRect.y;
36767:     exposeEvent.width  = dirtyRect.width;
36767:     exposeEvent.height = dirtyRect.height;
 3059:     exposeEvent.count = 0;
 3059:     // information not set:
 3059:     exposeEvent.serial = 0;
 3059:     exposeEvent.send_event = False;
 3059:     exposeEvent.major_code = 0;
 3059:     exposeEvent.minor_code = 0;
 3059: 
47115:     instance->HandleEvent(&pluginEvent, nsnull);
25500: #ifdef MOZ_COMPOSITED_PLUGINS
28368:   }
28368:   else {
25500:     /* XXX: this is very nasty. We need a better way of getting at mPlugWindow */
25500:     GtkWidget *plug = (GtkWidget*)(((nsPluginNativeWindow*)mWindow)->mPlugWindow);
25500:     //GtkWidget *plug = (GtkWidget*)(((nsPluginNativeWindowGtk2*)mWindow)->mSocketWidget);
25500: 
25500:     /* Cairo has bugs with IncludeInferiors when using paint
25500:      * so we use XCopyArea directly instead. */
25500:     XGCValues gcv;
25500:     gcv.subwindow_mode = IncludeInferiors;
25500:     gcv.graphics_exposures = False;
47118:     Drawable drawable = xsurface->XDrawable();
47118:     GC gc = XCreateGC(DefaultXDisplay(), drawable, GCGraphicsExposures | GCSubwindowMode, &gcv);
25500:     /* The source and destination appear to always line up, so src and dest
25500:      * coords should be the same */
43912:     XCopyArea(DefaultXDisplay(), gdk_x11_drawable_get_xid(plug->window),
47118:               drawable,
25500:               gc,
25500:               mDirtyRect.x,
25500:               mDirtyRect.y,
25500:               mDirtyRect.width,
25500:               mDirtyRect.height,
25500:               mDirtyRect.x,
25500:               mDirtyRect.y);
43912:     XFreeGC(DefaultXDisplay(), gc);
28368:   }
28368: #endif
 3059:   return NS_OK;
 3059: }
 3059: #endif
    1: 
36227: void nsPluginInstanceOwner::SendIdleEvent()
36227: {
36227: #ifdef MAC_CARBON_PLUGINS
    1:   // validate the plugin clipping information by syncing the plugin window info to
    1:   // reflect the current widget location. This makes sure that everything is updated
    1:   // correctly in the event of scrolling in the window.
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
32019:       void* window = FixUpPluginWindow(ePluginPaintEnable);
  130:       if (window) {
    1:         EventRecord idleEvent;
31130:         InitializeEventRecord(&idleEvent, nsnull);
    1:         idleEvent.what = nullEvent;
    1: 
    1:         // give a bogus 'where' field of our null event when hidden, so Flash
    1:         // won't respond to mouse moves in other tabs, see bug 120875
    1:         if (!mWidgetVisible)
    1:           idleEvent.where.h = idleEvent.where.v = 20000;
    1: 
43436:         mInstance->HandleEvent(&idleEvent, nsnull);
    1:       }
    1: 
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
36227: }
36227: 
36227: #ifdef MAC_CARBON_PLUGINS
36227: void nsPluginInstanceOwner::StartTimer(PRBool isVisible)
36227: {
32019:   if (GetEventModel() != NPEventModelCarbon)
32019:     return;
32019: 
36227:   mPluginHost->AddIdleTimeTarget(this, isVisible);
36227: }
36227: 
36227: void nsPluginInstanceOwner::CancelTimer()
36227: {
36227:   mPluginHost->RemoveIdleTimeTarget(this);
    1: }
    1: #endif
    1: 
    1: nsresult nsPluginInstanceOwner::Init(nsPresContext* aPresContext,
    1:                                      nsObjectFrame* aFrame,
    1:                                      nsIContent*    aContent)
    1: {
24543:   mLastEventloopNestingLevel = GetEventloopNestingLevel();
13537: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsPluginInstanceOwner::Init() called on %p for frame %p\n", this,
12417:           aFrame));
12417: 
34679:   mObjectFrame = aFrame;
    1:   mContent = aContent;
    1: 
12417:   nsWeakFrame weakFrame(aFrame);
12417: 
    1:   // Some plugins require a specific sequence of shutdown and startup when
    1:   // a page is reloaded. Shutdown happens usually when the last instance
    1:   // is destroyed. Here we make sure the plugin instance in the old
    1:   // document is destroyed before we try to create the new one.
29018:   aPresContext->EnsureVisible();
    1: 
12417:   if (!weakFrame.IsAlive()) {
12417:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:            ("nsPluginInstanceOwner::Init's EnsureVisible() call destroyed "
12417:             "instance owner %p\n", this));
12417: 
12417:     return NS_ERROR_NOT_AVAILABLE;
12417:   }
12417: 
    1:   // register context menu listener
    1:   mCXMenuListener = new nsPluginDOMContextMenuListener();
    1:   if (mCXMenuListener) {    
    1:     mCXMenuListener->Init(aContent);
    1:   }
    1: 
 1418:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
 1418:   if (target) {
    1: 
    1:     nsCOMPtr<nsIDOMEventListener> listener;
    1:     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
    1: 
    1:     // Register focus listener
 1418:     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMFocusListener));
    1: 
    1:     // Register mouse listener
 1418:     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseListener));
    1: 
    1:     // now do the mouse motion listener
 1418:     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseMotionListener));
    1: 
    1:     // Register key listener
 1418:     target->AddEventListener(NS_LITERAL_STRING("keypress"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
    1: 
    1:     // Register drag listener
20592:     target->AddEventListener(NS_LITERAL_STRING("drop"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
20592:     target->AddEventListener(NS_LITERAL_STRING("drag"), listener, PR_TRUE);
20592:     target->AddEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
20592:     target->AddEventListener(NS_LITERAL_STRING("dragleave"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
20592:     target->AddEventListener(NS_LITERAL_STRING("dragstart"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
20592:     target->AddEventListener(NS_LITERAL_STRING("dragend"), listener, PR_TRUE);
    1:   }
    1:   
37067:   // Register scroll position listeners
37067:   // We need to register a scroll position listener on every scrollable
37067:   // frame up to the top
37067:   for (nsIFrame* f = mObjectFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37067:     nsIScrollableFrame* sf = do_QueryFrame(f);
37067:     if (sf) {
37872:       sf->AddScrollPositionListener(this);
37067:     }
    1:   }
    1: 
    1:   return NS_OK; 
    1: }
    1: 
37446: void* nsPluginInstanceOwner::GetPluginPortFromWidget()
    1: {
    1: //!!! Port must be released for windowless plugins on Windows, because it is HDC !!!
    1: 
32799:   void* result = NULL;
    1:   if (mWidget) {
    1: #ifdef XP_WIN
32799:     if (mPluginWindow && (mPluginWindow->type == NPWindowTypeDrawable))
32799:       result = mWidget->GetNativeData(NS_NATIVE_GRAPHIC);
    1:     else
    1: #endif
  130: #ifdef XP_MACOSX
39757:     if (GetDrawingModel() == NPDrawingModelCoreGraphics || 
43370:         GetDrawingModel() == NPDrawingModelCoreAnimation ||
43370:         GetDrawingModel() == NPDrawingModelInvalidatingCoreAnimation)
32799:       result = mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT_CG);
  130:     else
  130: #endif
32799:       result = mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
    1:   }
    1:   return result;
    1: }
    1: 
32799: void nsPluginInstanceOwner::ReleasePluginPort(void * pluginPort)
    1: {
    1: #ifdef XP_WIN
    1:   if (mWidget && mPluginWindow &&
32799:       mPluginWindow->type == NPWindowTypeDrawable) {
    1:     mWidget->FreeNativeData((HDC)pluginPort, NS_NATIVE_GRAPHIC);
    1:   }
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::CreateWidget(void)
    1: {
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1: 
34679:   if (mObjectFrame) {
60817:     if (!mWidget) {
    1:       PRBool windowless = PR_FALSE;
32799:       mInstance->IsWindowless(&windowless);
    1: 
    1:       // always create widgets in Twips, not pixels
34679:       nsPresContext* context = mObjectFrame->PresContext();
34679:       rv = mObjectFrame->CreateWidget(context->DevPixelsToAppUnits(mPluginWindow->width),
    1:                                       context->DevPixelsToAppUnits(mPluginWindow->height),
    1:                                       windowless);
    1:       if (NS_OK == rv) {
34679:         mWidget = mObjectFrame->GetWidget();
    1: 
    1:         if (PR_TRUE == windowless) {
32799:           mPluginWindow->type = NPWindowTypeDrawable;
    1: 
    1:           // this needs to be a HDC according to the spec, but I do
    1:           // not see the right way to release it so let's postpone
    1:           // passing HDC till paint event when it is really
    1:           // needed. Change spec?
    1:           mPluginWindow->window = nsnull;
15703: #ifdef MOZ_X11
15703:           // Fill in the display field.
15703:           NPSetWindowCallbackStruct* ws_info = 
15703:             static_cast<NPSetWindowCallbackStruct*>(mPluginWindow->ws_info);
43912:           ws_info->display = DefaultXDisplay();
47115: 
47115:           nsCAutoString description;
47115:           GetPluginDescription(description);
47115:           NS_NAMED_LITERAL_CSTRING(flash10Head, "Shockwave Flash 10.");
47115:           mFlash10Quirks = StringBeginsWith(description, flash10Head);
15703: #endif
57215: 
57215:           // Changing to windowless mode changes the NPWindow geometry.
57215:           mObjectFrame->FixupWindow(mObjectFrame->GetContentRect().Size());
    1:         } else if (mWidget) {
47769:           nsIWidget* parent = mWidget->GetParent();
47769:           NS_ASSERTION(parent, "Plugin windows must not be toplevel");
47769:           // Set the plugin window to have an empty cliprect. The cliprect
47769:           // will be reset when nsRootPresContext::UpdatePluginGeometry
47769:           // runs later. The plugin window does need to have the correct
59055:           // size here. GetEmptyClipConfiguration will probably give it the
59055:           // size, but just in case we haven't been reflowed or something, set
59055:           // the size explicitly.
47769:           nsAutoTArray<nsIWidget::Configuration,1> configuration;
59055:           mObjectFrame->GetEmptyClipConfiguration(&configuration);
59055:           if (configuration.Length() > 0) {
59055:             configuration[0].mBounds.width = mPluginWindow->width;
59055:             configuration[0].mBounds.height = mPluginWindow->height;
59055:           }
47769:           parent->ConfigureChildren(configuration);
    1: 
    1:           // mPluginWindow->type is used in |GetPluginPort| so it must
14641:           // be initialized first
32799:           mPluginWindow->type = NPWindowTypeWindow;
37446:           mPluginWindow->window = GetPluginPortFromWidget();
    1: 
36227: #ifdef MAC_CARBON_PLUGINS
    1:           // start the idle timer.
36227:           StartTimer(PR_TRUE);
36227: #endif
    1: 
    1:           // tell the plugin window about the widget
    1:           mPluginWindow->SetPluginWidget(mWidget);
14641: 
14641:           // tell the widget about the current plugin instance owner.
14641:           nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
14641:           if (pluginWidget)
14641:             pluginWidget->SetPluginInstanceOwner(this);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void nsPluginInstanceOwner::SetPluginHost(nsIPluginHost* aHost)
    1: {
    1:   mPluginHost = aHost;
    1: }
    1: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
36299: PRBool nsPluginInstanceOwner::UpdateVisibility(PRBool aVisible)
35171: {
37400:   // NOTE: Death grip must be held by caller.
35199:   if (!mInstance)
35199:     return PR_TRUE;
35171: 
34182:   NPEvent pluginEvent;
34182:   XVisibilityEvent& visibilityEvent = pluginEvent.xvisibility;
34182:   visibilityEvent.type = VisibilityNotify;
34182:   visibilityEvent.display = 0;
36299:   visibilityEvent.state = aVisible ? VisibilityUnobscured : VisibilityFullyObscured;
43436:   mInstance->HandleEvent(&pluginEvent, nsnull);
35171: 
35171:   mWidgetVisible = PR_TRUE;
34182:   return PR_TRUE;
34182: }
34182: #endif
34182: 
    1: // Mac specific code to fix up the port location and clipping region
    1: #ifdef XP_MACOSX
    1: 
32019: void* nsPluginInstanceOwner::FixUpPluginWindow(PRInt32 inPaintState)
    1: {
34679:   if (!mWidget || !mPluginWindow || !mInstance || !mObjectFrame)
    1:     return nsnull;
    1: 
21108:   NPDrawingModel drawingModel = GetDrawingModel();
37446:   NPEventModel eventModel = GetEventModel();
32019: 
32019:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
32019:   if (!pluginWidget)
32019:     return nsnull;
32019: 
21108:   // If we've already set up a CGContext in nsObjectFrame::PaintPlugin(), we
21108:   // don't want calls to SetPluginPortAndDetectChange() to step on our work.
32799:   void* pluginPort = nsnull;
21108:   if (mInCGPaintLevel > 0) {
21108:     pluginPort = mPluginWindow->window;
21108:   } else {
21108:     pluginPort = SetPluginPortAndDetectChange();
21108:   }
    1: 
37446: #ifdef MAC_CARBON_PLUGINS
37446:   if (eventModel == NPEventModelCarbon && !pluginPort)
    1:     return nsnull;
37446: #endif
    1: 
41061:   // We'll need the top-level Cocoa window for the Cocoa event model.
41061:   void* cocoaTopLevelWindow = nsnull;
41061:   if (eventModel == NPEventModelCocoa) {
47148:     nsIWidget* widget = mObjectFrame->GetNearestWidget();
41061:     if (!widget)
41061:       return nsnull;
41061:     cocoaTopLevelWindow = widget->GetNativeData(NS_NATIVE_WINDOW);
41061:     if (!cocoaTopLevelWindow)
41061:       return nsnull;
41061:   }
41061: 
23738:   nsIntPoint pluginOrigin;
23738:   nsIntRect widgetClip;
    1:   PRBool widgetVisible;
29388:   pluginWidget->GetPluginClipRect(widgetClip, pluginOrigin, widgetVisible);
30522:   mWidgetVisible = widgetVisible;
    1: 
    1:   // printf("GetPluginClipRect returning visible %d\n", widgetVisible);
    1: 
  130: #ifndef NP_NO_QUICKDRAW
    1:   // set the port coordinates
  130:   if (drawingModel == NPDrawingModelQuickDraw) {
32799:     mPluginWindow->x = -static_cast<NP_Port*>(pluginPort)->portx;
32799:     mPluginWindow->y = -static_cast<NP_Port*>(pluginPort)->porty;
  130:   }
39757:   else if (drawingModel == NPDrawingModelCoreGraphics || 
43370:            drawingModel == NPDrawingModelCoreAnimation ||
43370:            drawingModel == NPDrawingModelInvalidatingCoreAnimation)
  130: #endif
 2078:   {
 2078:     // This would be a lot easier if we could use obj-c here,
 2078:     // but we can't. Since we have only nsIWidget and we can't
 2078:     // use its native widget (an obj-c object) we have to go
 2078:     // from the widget's screen coordinates to its window coords
 2078:     // instead of straight to window coords.
25183:     nsIntPoint geckoScreenCoords = mWidget->WidgetToScreenOffset();
 2078: 
32019:     nsRect windowRect;
32972: #ifndef NP_NO_CARBON
37446:     if (eventModel == NPEventModelCarbon)
32799:       NS_NPAPI_CarbonWindowFrame(static_cast<WindowRef>(static_cast<NP_CGContext*>(pluginPort)->window), windowRect);
32019:     else
32972: #endif
34717:     {
41061:       NS_NPAPI_CocoaWindowFrame(cocoaTopLevelWindow, windowRect);
34717:     }
32019: 
32019:     mPluginWindow->x = geckoScreenCoords.x - windowRect.x;
32019:     mPluginWindow->y = geckoScreenCoords.y - windowRect.y;
 2078:   }
    1: 
32799:   NPRect oldClipRect = mPluginWindow->clipRect;
    1:   
    1:   // fix up the clipping region
    1:   mPluginWindow->clipRect.top    = widgetClip.y;
    1:   mPluginWindow->clipRect.left   = widgetClip.x;
    1: 
    1:   if (!mWidgetVisible || inPaintState == ePluginPaintDisable) {
    1:     mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top;
    1:     mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left;
    1:   }
    1:   else if (inPaintState == ePluginPaintEnable)
    1:   {
    1:     mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top + widgetClip.height;
    1:     mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left + widgetClip.width; 
    1:   }
    1: 
    1:   // if the clip rect changed, call SetWindow()
    1:   // (RealPlayer needs this to draw correctly)
    1:   if (mPluginWindow->clipRect.left    != oldClipRect.left   ||
    1:       mPluginWindow->clipRect.top     != oldClipRect.top    ||
    1:       mPluginWindow->clipRect.right   != oldClipRect.right  ||
    1:       mPluginWindow->clipRect.bottom  != oldClipRect.bottom)
    1:   {
    1:     mInstance->SetWindow(mPluginWindow);
21108:     mPluginPortChanged = PR_FALSE;
36227: #ifdef MAC_CARBON_PLUGINS
    1:     // if the clipRect is of size 0, make the null timer fire less often
    1:     CancelTimer();
    1:     if (mPluginWindow->clipRect.left == mPluginWindow->clipRect.right ||
    1:         mPluginWindow->clipRect.top == mPluginWindow->clipRect.bottom) {
36227:       StartTimer(PR_FALSE);
    1:     }
    1:     else {
36227:       StartTimer(PR_TRUE);
36227:     }
36227: #endif
21108:   } else if (mPluginPortChanged) {
20596:     mInstance->SetWindow(mPluginWindow);
21108:     mPluginPortChanged = PR_FALSE;
    1:   }
    1: 
41061:   // After the first NPP_SetWindow call we need to send an initial
41061:   // top-level window focus event.
41061:   if (eventModel == NPEventModelCocoa && !mSentInitialTopLevelWindowEvent) {
41061:     // Set this before calling ProcessEvent to avoid endless recursion.
41061:     mSentInitialTopLevelWindowEvent = PR_TRUE;
41061: 
41061:     nsGUIEvent pluginEvent(PR_TRUE, NS_NON_RETARGETED_PLUGIN_EVENT, nsnull);
41061:     NPCocoaEvent cocoaEvent;
41061:     InitializeNPCocoaEvent(&cocoaEvent);
41061:     cocoaEvent.type = NPCocoaEventWindowFocusChanged;
41061:     cocoaEvent.data.focus.hasFocus = NS_NPAPI_CocoaWindowIsMain(cocoaTopLevelWindow);
41061:     pluginEvent.pluginEvent = &cocoaEvent;
41061:     ProcessEvent(pluginEvent);
41061:   }
41061: 
  130: #ifndef NP_NO_QUICKDRAW
  130:   if (drawingModel == NPDrawingModelQuickDraw)
32799:     return ::GetWindowFromPort(static_cast<NP_Port*>(pluginPort)->port);
  130: #endif
  130: 
37446: #ifdef MAC_CARBON_PLUGINS
37446:   if (drawingModel == NPDrawingModelCoreGraphics && eventModel == NPEventModelCarbon)
32799:     return static_cast<NP_CGContext*>(pluginPort)->window;
37446: #endif
  130: 
  130:   return nsnull;
    1: }
    1: 
56652: void
56652: nsPluginInstanceOwner::HidePluginWindow()
56652: {
56652:   if (!mPluginWindow || !mInstance) {
56652:     return;
56652:   }
56652: 
56652:   mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top;
56652:   mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left;
56652:   mWidgetVisible = PR_FALSE;
56652:   mInstance->SetWindow(mPluginWindow);
56652: }
56652: 
57224: #else // XP_MACOSX
57228: 
57514: void nsPluginInstanceOwner::UpdateWindowPositionAndClipRect(PRBool aSetWindow)
57224: {
57224:   if (!mPluginWindow)
57224:     return;
57224: 
57224:   // For windowless plugins a non-empty clip rectangle will be
57224:   // passed to the plugin during paint, an additional update
57224:   // of the the clip rectangle here is not required
62474:   if (aSetWindow && !mWidget && mPluginWindowVisible && !UseAsyncRendering())
57224:     return;
57224: 
57514:   const NPWindow oldWindow = *mPluginWindow;
57514: 
57514:   PRBool windowless = (mPluginWindow->type == NPWindowTypeDrawable);
57514:   nsIntPoint origin = mObjectFrame->GetWindowOriginInPixels(windowless);
57514: 
57514:   mPluginWindow->x = origin.x;
57514:   mPluginWindow->y = origin.y;
57224: 
57224:   mPluginWindow->clipRect.left = 0;
57224:   mPluginWindow->clipRect.top = 0;
57224: 
57224:   if (mPluginWindowVisible) {
57224:     mPluginWindow->clipRect.right = mPluginWindow->width;
57224:     mPluginWindow->clipRect.bottom = mPluginWindow->height;
57224:   } else {
57224:     mPluginWindow->clipRect.right = 0;
57224:     mPluginWindow->clipRect.bottom = 0;
57224:   }
57224: 
57224:   if (!aSetWindow)
57224:     return;
57224: 
57514:   if (mPluginWindow->x               != oldWindow.x               ||
57514:       mPluginWindow->y               != oldWindow.y               ||
57514:       mPluginWindow->clipRect.left   != oldWindow.clipRect.left   ||
57514:       mPluginWindow->clipRect.top    != oldWindow.clipRect.top    ||
57514:       mPluginWindow->clipRect.right  != oldWindow.clipRect.right  ||
57514:       mPluginWindow->clipRect.bottom != oldWindow.clipRect.bottom) {
58796:     CallSetWindow();
57224:   }
57224: }
57224: 
57224: void
58796: nsPluginInstanceOwner::CallSetWindow()
57224: {
57224:   if (!mInstance)
57224:     return;
57224: 
62474:   if (UseAsyncRendering()) {
57224:     mInstance->AsyncSetWindow(mPluginWindow);
57224:   } else {
57224:     mInstance->SetWindow(mPluginWindow);
57224:   }
57224: }
57224: 
57224: void
57224: nsPluginInstanceOwner::UpdateWindowVisibility(PRBool aVisible)
57224: {
57224:   mPluginWindowVisible = aVisible;
57514:   UpdateWindowPositionAndClipRect(PR_TRUE);
57224: }
57224: 
    1: #endif // XP_MACOSX
    1: 
    1: // Little helper function to resolve relative URL in
    1: // |value| for certain inputs of |name|
    1: void nsPluginInstanceOwner::FixUpURLS(const nsString &name, nsAString &value)
    1: {
    1:   if (name.LowerCaseEqualsLiteral("pluginurl") ||
    1:       name.LowerCaseEqualsLiteral("pluginspage")) {        
    1:     
    1:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1:     nsAutoString newURL;
    1:     NS_MakeAbsoluteURI(newURL, value, baseURI);
    1:     if (!newURL.IsEmpty())
    1:       value = newURL;
    1:   }
    1: }
35171: 
39239: #ifdef MOZ_USE_IMAGE_EXPOSE
35171: nsresult
35171: nsPluginInstanceOwner::SetAbsoluteScreenPosition(nsIDOMElement* element,
35171:                                                  nsIDOMClientRect* position,
35171:                                                  nsIDOMClientRect* clip)
35171: {
37357:   if (!element || !position || !clip)
35171:     return NS_ERROR_FAILURE;
35171:   
37400:   // Making X or DOM method calls can cause our frame to go
37400:   // away, which might kill us...
37400:   nsCOMPtr<nsIPluginInstanceOwner> kungFuDeathGrip(this);
37400: 
37357:   if (!mBlitWindow) {
37357:     mBlitWindow = GDK_WINDOW_XWINDOW(GetClosestWindow(element));
37357:     if (!mBlitWindow)
37357:       return NS_ERROR_FAILURE;
37357:   }
37357: 
35171:   float left, top, width, height;
35171:   position->GetLeft(&left);
35171:   position->GetTop(&top);
35171:   position->GetWidth(&width);
35171:   position->GetHeight(&height);
35171: 
35199:   mAbsolutePosition = gfxRect(left, top, width, height);
35199:   
35171:   clip->GetLeft(&left);
35171:   clip->GetTop(&top);
35171:   clip->GetWidth(&width);
35171:   clip->GetHeight(&height);
35171: 
35199:   mAbsolutePositionClip = gfxRect(left, top, width, height);
35199: 
36299:   UpdateVisibility(!(width == 0 && height == 0));
35212: 
35212:   if (!mInstance)
35171:     return NS_OK;
35212: 
35212:   PRBool simpleImageRender = PR_FALSE;
35212:   mInstance->GetValueFromPlugin(NPPVpluginWindowlessLocalBool,
35212:                                 &simpleImageRender);
35282:   if (simpleImageRender)
35212:     NativeImageDraw();
35212:   return NS_OK;
35171: }
35171: #endif
35171: 
