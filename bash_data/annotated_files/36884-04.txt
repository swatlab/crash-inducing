33401: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
33401: /* ***** BEGIN LICENSE BLOCK *****
33401:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33401:  *
33401:  * The contents of this file are subject to the Mozilla Public License Version
33401:  * 1.1 (the "License"); you may not use this file except in compliance with
33401:  * the License. You may obtain a copy of the License at
33401:  * http://www.mozilla.org/MPL/
33401:  *
33401:  * Software distributed under the License is distributed on an "AS IS" basis,
33401:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33401:  * for the specific language governing rights and limitations under the
33401:  * License.
33401:  *
33401:  * The Original Code is the Mozilla SMIL module.
33401:  *
33401:  * The Initial Developer of the Original Code is the Mozilla Corporation.
33401:  * Portions created by the Initial Developer are Copyright (C) 2009
33401:  * the Initial Developer. All Rights Reserved.
33401:  *
33401:  * Contributor(s):
33401:  *   Daniel Holbert <dholbert@mozilla.com>
33401:  *
33401:  * Alternatively, the contents of this file may be used under the terms of
33401:  * either of the GNU General Public License Version 2 or later (the "GPL"),
33401:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33401:  * in which case the provisions of the GPL or the LGPL are applicable instead
33401:  * of those above. If you wish to allow use of your version of this file only
33401:  * under the terms of either the GPL or the LGPL, and not to allow others to
33401:  * use your version of this file under the terms of the MPL, indicate your
33401:  * decision by deleting the provisions above and replace them with the notice
33401:  * and other provisions required by the GPL or the LGPL. If you do not delete
33401:  * the provisions above, a recipient may use your version of this file under
33401:  * the terms of any one of the MPL, the GPL or the LGPL.
33401:  *
33401:  * ***** END LICENSE BLOCK ***** */
33401: 
33401: /* representation of a SMIL-animatable CSS property on an element */
33401: 
33401: #include "nsSMILCSSProperty.h"
33401: #include "nsSMILCSSValueType.h"
33401: #include "nsSMILValue.h"
33401: #include "nsCSSDeclaration.h"
33401: #include "nsComputedDOMStyle.h"
33401: #include "nsStyleAnimation.h"
33401: #include "nsIContent.h"
36884: #include "nsIDOMElement.h"
33401: 
33401: static PRBool
33401: GetCSSComputedValue(nsIContent* aElem,
33401:                     nsCSSProperty aPropID,
33401:                     nsAString& aResult)
33401: {
33401:   NS_ENSURE_TRUE(nsSMILCSSProperty::IsPropertyAnimatable(aPropID),
33401:                  PR_FALSE);
33401: 
33401:   nsIDocument* doc = aElem->GetCurrentDoc();
36633:   if (!doc) {
36633:     // This can happen if we process certain types of restyles mid-sample
36633:     // and remove anonymous animated content from the document as a result.
36633:     // See bug 534975.
36633:     return PR_FALSE;
36633:   }
34446: 
36884:   nsIPresShell* shell = doc->GetPrimaryShell();
36884:   if (!shell) {
36884:     NS_WARNING("Unable to look up computed style -- no pres shell");
36884:     return PR_FALSE;
36884:   }
36884: 
36884:   nsRefPtr<nsComputedDOMStyle> computedStyle;
36884:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(aElem));
36884:   nsresult rv = NS_NewComputedDOMStyle(domElement, EmptyString(), shell,
36884:                                        getter_AddRefs(computedStyle));
36884: 
36884:   if (NS_SUCCEEDED(rv) && computedStyle) {
33401:     // NOTE: This will produce an empty string for shorthand values
33401:     computedStyle->GetPropertyValue(aPropID, aResult);
33401:     return PR_TRUE;
33401:   }
33401:   return PR_FALSE;
33401: }
33401: 
33401: // Class Methods
33401: nsSMILCSSProperty::nsSMILCSSProperty(nsCSSProperty aPropID,
33401:                                      nsIContent* aElement)
33401:   : mPropID(aPropID), mElement(aElement)
33401: {
33401:   NS_ABORT_IF_FALSE(IsPropertyAnimatable(mPropID),
33401:                     "Creating a nsSMILCSSProperty for a property "
33401:                     "that's not supported for animation");
33401: }
33401: 
33401: nsSMILValue
33401: nsSMILCSSProperty::GetBaseValue() const
33401: {
33401:   // (1) Put empty string in override style for property mPropID
33401:   // (saving old override style value, so we can set it again when we're done)
33401:   nsCOMPtr<nsIDOMCSSStyleDeclaration> overrideStyle;
33401:   mElement->GetSMILOverrideStyle(getter_AddRefs(overrideStyle));
33401:   nsCOMPtr<nsICSSDeclaration> overrideDecl = do_QueryInterface(overrideStyle);
33401:   nsAutoString cachedOverrideStyleVal;
33401:   if (overrideDecl) {
33401:     overrideDecl->GetPropertyValue(mPropID, cachedOverrideStyleVal);
33401:     // (Don't bother clearing override style if it's already empty)
33401:     if (!cachedOverrideStyleVal.IsEmpty()) {
33401:       overrideDecl->SetPropertyValue(mPropID, EmptyString());
33401:     }
33401:   }
33401: 
33401:   // (2) Get Computed Style
33401:   nsAutoString computedStyleVal;
33401:   PRBool didGetComputedVal = GetCSSComputedValue(mElement, mPropID,
33401:                                                  computedStyleVal);
33401: 
33401:   // (3) Put cached override style back (if it's non-empty)
33401:   if (overrideDecl && !cachedOverrideStyleVal.IsEmpty()) {
33401:     overrideDecl->SetPropertyValue(mPropID, cachedOverrideStyleVal);
33401:   }
33401: 
33401:   nsSMILValue baseValue;
33401:   if (didGetComputedVal) {
33401:     // (4) Create the nsSMILValue from the computed style value
35520:     nsSMILCSSValueType::sSingleton.Init(baseValue);
35520:     if (!nsCSSProps::IsShorthand(mPropID) &&
35520:         !nsSMILCSSValueType::sSingleton.ValueFromString(mPropID, mElement,
35520:                                                         computedStyleVal,
35520:                                                         baseValue)) {
35520:       nsSMILCSSValueType::sSingleton.Destroy(baseValue);
33401:       NS_ABORT_IF_FALSE(baseValue.IsNull(),
33401:                         "Destroy should leave us with null-typed value");
33401:     }
33401:   }
33401:   return baseValue;
33401: }
33401: 
33401: nsresult
33401: nsSMILCSSProperty::ValueFromString(const nsAString& aStr,
33401:                                    const nsISMILAnimationElement* aSrcElement,
33401:                                    nsSMILValue& aValue) const
33401: {
33401:   NS_ENSURE_TRUE(IsPropertyAnimatable(mPropID), NS_ERROR_FAILURE);
35520:   nsSMILCSSValueType::sSingleton.Init(aValue);
35520:   PRBool success =
35520:     nsSMILCSSValueType::sSingleton.ValueFromString(mPropID, mElement,
35520:                                                    aStr, aValue);
33401:   if (!success) {
35520:     nsSMILCSSValueType::sSingleton.Destroy(aValue);
33401:   }
33401:   return success ? NS_OK : NS_ERROR_FAILURE;
33401: }
33401: 
33401: nsresult
33401: nsSMILCSSProperty::SetAnimValue(const nsSMILValue& aValue)
33401: {
33401:   NS_ENSURE_TRUE(IsPropertyAnimatable(mPropID), NS_ERROR_FAILURE);
33401: 
33401:   nsresult rv = NS_OK;
33401:   nsAutoString valStr;
33401: 
35520:   if (nsSMILCSSValueType::sSingleton.ValueToString(aValue, valStr)) {
33401:     // Apply the style to the target element
33401:     nsCOMPtr<nsIDOMCSSStyleDeclaration> overrideStyle;
33401:     mElement->GetSMILOverrideStyle(getter_AddRefs(overrideStyle));
33401:     NS_ABORT_IF_FALSE(overrideStyle, "Need a non-null overrideStyle");
33401: 
33401:     nsCOMPtr<nsICSSDeclaration> overrideDecl =
33401:       do_QueryInterface(overrideStyle);
33401:     if (overrideDecl) {
33401:       overrideDecl->SetPropertyValue(mPropID, valStr);
33401:     }
33401:   } else {
33401:     NS_WARNING("Failed to convert nsSMILValue for CSS property into a string");
33401:     rv = NS_ERROR_FAILURE;
33401:   }
33401: 
33401:   return rv;
33401: }
33401: 
33401: void
33401: nsSMILCSSProperty::ClearAnimValue()
33401: {
33401:   // Put empty string in override style for property propID
33401:   nsCOMPtr<nsIDOMCSSStyleDeclaration> overrideStyle;
33401:   mElement->GetSMILOverrideStyle(getter_AddRefs(overrideStyle));
33401:   nsCOMPtr<nsICSSDeclaration> overrideDecl = do_QueryInterface(overrideStyle);
33401:   if (overrideDecl) {
33401:     overrideDecl->SetPropertyValue(mPropID, EmptyString());
33401:   }
33401: }
33401: 
33401: // Based on http://www.w3.org/TR/SVG/propidx.html
33401: // static
33401: PRBool
33401: nsSMILCSSProperty::IsPropertyAnimatable(nsCSSProperty aPropID)
33401: {
33401:   // NOTE: Right now, Gecko doesn't recognize the following properties from
33401:   // the SVG Property Index:
33401:   //   alignment-baseline
33401:   //   baseline-shift
33401:   //   color-profile
33401:   //   color-rendering
33401:   //   glyph-orientation-horizontal
33401:   //   glyph-orientation-vertical
33401:   //   kerning
33401:   //   writing-mode
33401: 
33401:   switch (aPropID) {
33401:     case eCSSProperty_clip:
34084:     case eCSSProperty_clip_rule:
35517:     case eCSSProperty_clip_path:
33401:     case eCSSProperty_color:
34084:     case eCSSProperty_color_interpolation:
34084:     case eCSSProperty_color_interpolation_filters:
35521:     case eCSSProperty_cursor:
34084:     case eCSSProperty_display:
34084:     case eCSSProperty_dominant_baseline:
35514:     case eCSSProperty_fill:
33690:     case eCSSProperty_fill_opacity:
34084:     case eCSSProperty_fill_rule:
35517:     case eCSSProperty_filter:
33401:     case eCSSProperty_flood_color:
33690:     case eCSSProperty_flood_opacity:
36838:     case eCSSProperty_font:
35516:     case eCSSProperty_font_family:
33401:     case eCSSProperty_font_size:
33692:     case eCSSProperty_font_size_adjust:
34965:     case eCSSProperty_font_stretch:
34084:     case eCSSProperty_font_style:
34084:     case eCSSProperty_font_variant:
34965:     case eCSSProperty_font_weight:
34084:     case eCSSProperty_image_rendering:
33401:     case eCSSProperty_letter_spacing:
33401:     case eCSSProperty_lighting_color:
36838:     case eCSSProperty_marker:
35517:     case eCSSProperty_marker_end:
35517:     case eCSSProperty_marker_mid:
35517:     case eCSSProperty_marker_start:
35517:     case eCSSProperty_mask:
33690:     case eCSSProperty_opacity:
36838:     case eCSSProperty_overflow:
34084:     case eCSSProperty_pointer_events:
34084:     case eCSSProperty_shape_rendering:
33401:     case eCSSProperty_stop_color:
33690:     case eCSSProperty_stop_opacity:
35514:     case eCSSProperty_stroke:
35514:     case eCSSProperty_stroke_dasharray:
33401:     case eCSSProperty_stroke_dashoffset:
34084:     case eCSSProperty_stroke_linecap:
34084:     case eCSSProperty_stroke_linejoin:
33690:     case eCSSProperty_stroke_miterlimit:
33690:     case eCSSProperty_stroke_opacity:
33401:     case eCSSProperty_stroke_width:
34084:     case eCSSProperty_text_anchor:
34084:     case eCSSProperty_text_decoration:
34084:     case eCSSProperty_text_rendering:
34084:     case eCSSProperty_visibility:
33401:     case eCSSProperty_word_spacing:
33401:       return PR_TRUE;
33401: 
33401:     // EXPLICITLY NON-ANIMATABLE PROPERTIES:
33401:     // (Some of these aren't supported at all in Gecko -- I've commented those
33401:     // ones out. If/when we add support for them, uncomment their line here)
33401:     // ----------------------------------------------------------------------
33401:     // case eCSSProperty_enable_background:
33401:     // case eCSSProperty_glyph_orientation_horizontal:
33401:     // case eCSSProperty_glyph_orientation_vertical:
33401:     // case eCSSProperty_writing_mode:
33401:     case eCSSProperty_direction:
33401:     case eCSSProperty_unicode_bidi:
33401:       return PR_FALSE;
33401: 
33401:     default:
33401:       return PR_FALSE;
33401:   }
33401: }
