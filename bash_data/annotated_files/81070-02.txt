29805: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
29805: /* ***** BEGIN LICENSE BLOCK *****
29805:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29805:  *
29805:  * The contents of this file are subject to the Mozilla Public License Version
29805:  * 1.1 (the "License"); you may not use this file except in compliance with
29805:  * the License. You may obtain a copy of the License at
29805:  * http://www.mozilla.org/MPL/
29805:  *
29805:  * Software distributed under the License is distributed on an "AS IS" basis,
29805:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29805:  * for the specific language governing rights and limitations under the
29805:  * License.
29805:  *
29805:  * The Original Code is mozilla.org code.
29805:  *
29805:  * The Initial Developer of the Original Code is
29805:  * Netscape Communications Corporation.
29805:  * Portions created by the Initial Developer are Copyright (C) 1998
29805:  * the Initial Developer. All Rights Reserved.
29805:  *
29805:  * Contributor(s):
29805:  *   Henri Sivonen <hsivonen@iki.fi>
29805:  *
29805:  * Alternatively, the contents of this file may be used under the terms of
29805:  * either of the GNU General Public License Version 2 or later (the "GPL"),
29805:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29805:  * in which case the provisions of the GPL or the LGPL are applicable instead
29805:  * of those above. If you wish to allow use of your version of this file only
29805:  * under the terms of either the GPL or the LGPL, and not to allow others to
29805:  * use your version of this file under the terms of the MPL, indicate your
29805:  * decision by deleting the provisions above and replace them with the notice
29805:  * and other provisions required by the GPL or the LGPL. If you do not delete
29805:  * the provisions above, a recipient may use your version of this file under
29805:  * the terms of any one of the MPL, the GPL or the LGPL.
29805:  *
29805:  * ***** END LICENSE BLOCK ***** */
29805: 
29805: #ifndef NS_HTML5_PARSER__
29805: #define NS_HTML5_PARSER__
29805: 
29805: #include "nsAutoPtr.h"
29805: #include "nsIParser.h"
29805: #include "nsDeque.h"
29805: #include "nsIURL.h"
29805: #include "nsParserCIID.h"
29805: #include "nsITokenizer.h"
29805: #include "nsThreadUtils.h"
29805: #include "nsIContentSink.h"
29805: #include "nsIParserFilter.h"
29805: #include "nsIRequest.h"
29805: #include "nsIChannel.h"
29805: #include "nsCOMArray.h"
29805: #include "nsContentSink.h"
29805: #include "nsIHTMLDocument.h"
29805: #include "nsCycleCollectionParticipant.h"
29805: #include "nsIInputStream.h"
29805: #include "nsDetectionConfident.h"
80404: #include "nsHtml5OwningUTF16Buffer.h"
32917: #include "nsHtml5TreeOpExecutor.h"
32917: #include "nsHtml5StreamParser.h"
34978: #include "nsHtml5AtomTable.h"
34983: #include "nsWeakReference.h"
29805: 
76287: class nsHtml5Parser : public nsIParser,
41448:                       public nsSupportsWeakReference
34983: {
29805:   public:
29805:     NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
32917:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
32917: 
32917:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsHtml5Parser, nsIParser)
29805: 
29805:     nsHtml5Parser();
29805:     virtual ~nsHtml5Parser();
29805: 
29805:     /* Start nsIParser */
29805:     /**
29805:      * No-op for backwards compat.
29805:      */
29805:     NS_IMETHOD_(void) SetContentSink(nsIContentSink* aSink);
29805: 
29805:     /**
40983:      * Returns the tree op executor for backwards compat.
29805:      */
40983:     NS_IMETHOD_(nsIContentSink*) GetContentSink();
29805: 
29805:     /**
29805:      * Always returns "view" for backwards compat.
29805:      */
29805:     NS_IMETHOD_(void) GetCommand(nsCString& aCommand);
29805: 
29805:     /**
29805:      * No-op for backwards compat.
29805:      */
29805:     NS_IMETHOD_(void) SetCommand(const char* aCommand);
29805: 
29805:     /**
29805:      * No-op for backwards compat.
29805:      */
29805:     NS_IMETHOD_(void) SetCommand(eParserCommands aParserCommand);
29805: 
29805:     /**
29805:      *  Call this method once you've created a parser, and want to instruct it
29805:      *  about what charset to load
29805:      *
29805:      *  @param   aCharset the charset of a document
29805:      *  @param   aCharsetSource the source of the charset
29805:      */
29805:     NS_IMETHOD_(void) SetDocumentCharset(const nsACString& aCharset, PRInt32 aSource);
29805: 
29805:     /**
32917:      * Don't call. For interface compat only.
29805:      */
29805:     NS_IMETHOD_(void) GetDocumentCharset(nsACString& aCharset, PRInt32& aSource)
29805:     {
32917:       NS_NOTREACHED("No one should call this.");
29805:     }
29805: 
29805:     /**
29805:      * No-op for backwards compat.
29805:      */
29805:     NS_IMETHOD_(void) SetParserFilter(nsIParserFilter* aFilter);
29805: 
29805:     /**
29805:      * Get the channel associated with this parser
29805:      * @param aChannel out param that will contain the result
29805:      * @return NS_OK if successful or NS_NOT_AVAILABLE if not
29805:      */
29805:     NS_IMETHOD GetChannel(nsIChannel** aChannel);
29805: 
29805:     /**
29805:      * Return |this| for backwards compat.
29805:      */
29805:     NS_IMETHOD GetDTD(nsIDTD** aDTD);
29805: 
29805:     /**
32917:      * Get the stream parser for this parser
32917:      */
32917:     NS_IMETHOD GetStreamListener(nsIStreamListener** aListener);
32917: 
32917:     /**
39737:      * Don't call. For interface compat only.
29805:      */
29805:     NS_IMETHOD ContinueInterruptedParsing();
29805: 
29805:     /**
32917:      * Blocks the parser.
29805:      */
29805:     NS_IMETHOD_(void) BlockParser();
29805: 
29805:     /**
29805:      * Unblocks the parser.
29805:      */
29805:     NS_IMETHOD_(void) UnblockParser();
29805: 
29805:     /**
39737:      * Query whether the parser is enabled (i.e. not blocked) or not.
29805:      */
79445:     NS_IMETHOD_(bool) IsParserEnabled();
29805: 
29805:     /**
29805:      * Query whether the parser thinks it's done with parsing.
29805:      */
79445:     NS_IMETHOD_(bool) IsComplete();
29805: 
29805:     /**
29805:      * Set up request observer.
29805:      *
29805:      * @param   aURL ignored (for interface compat only)
29805:      * @param   aListener a listener to forward notifications to
29805:      * @param   aKey the root context key (used for document.write)
29805:      * @param   aMode ignored (for interface compat only)
29805:      */
29805:     NS_IMETHOD Parse(nsIURI* aURL,
29805:                      nsIRequestObserver* aListener = nsnull,
29805:                      void* aKey = 0,
29805:                      nsDTDMode aMode = eDTDMode_autodetect);
29805: 
29805:     /**
29805:      * document.write and document.close
29805:      *
29805:      * @param   aSourceBuffer the argument of document.write (empty for .close())
29805:      * @param   aKey a key unique to the script element that caused this call
29805:      * @param   aContentType ignored (for interface compat only)
29805:      * @param   aLastCall true if .close() false if .write()
29805:      * @param   aMode ignored (for interface compat only)
29805:      */
29805:     NS_IMETHOD Parse(const nsAString& aSourceBuffer,
29805:                      void* aKey,
29805:                      const nsACString& aContentType,
79445:                      bool aLastCall,
29805:                      nsDTDMode aMode = eDTDMode_autodetect);
29805: 
29805:     /**
29805:      * Gets the key passed to initial Parse()
29805:      */
29805:     NS_IMETHOD_(void *) GetRootContextKey();
29805: 
29805:     /**
29805:      * Stops the parser prematurely
29805:      */
40983:     NS_IMETHOD Terminate();
29805: 
29805:     /**
29805:      * Don't call. For interface backwards compat only.
29805:      */
29805:     NS_IMETHOD ParseFragment(const nsAString& aSourceBuffer,
74622:                              nsTArray<nsString>& aTagStack);
29805: 
29805:     /**
34979:      * Don't call. For interface compat only.
29805:      */
40983:     NS_IMETHOD BuildModel();
29805: 
29805:     /**
35293:      * Don't call. For interface compat only.
29805:      */
29805:     NS_IMETHODIMP CancelParsingEvents();
29805: 
29805:     /**
29805:      * Sets the state to initial values
29805:      */
29805:     virtual void Reset();
29805:     
29805:     /**
29805:      * True in fragment mode and during synchronous document.write
29805:      */
79445:     virtual bool CanInterrupt();
29805: 
34983:     /**
34983:      * True if the insertion point (per HTML5) is defined.
34983:      */
79445:     virtual bool IsInsertionPointDefined();
34983: 
34983:     /**
34983:      * Call immediately before starting to evaluate a parser-inserted script.
34983:      */
34983:     virtual void BeginEvaluatingParserInsertedScript();
34983: 
34983:     /**
34983:      * Call immediately after having evaluated a parser-inserted script.
34983:      */
34983:     virtual void EndEvaluatingParserInsertedScript();
34983: 
34983:     /**
34983:      * Marks the HTML5 parser as not a script-created parser: Prepares the 
34983:      * parser to be able to read a stream.
34983:      */
34983:     virtual void MarkAsNotScriptCreated();
34983: 
34983:     /**
34983:      * True if this is a script-created HTML5 parser.
34983:      */
79445:     virtual bool IsScriptCreated();
34983: 
29805:     /* End nsIParser  */
29805: 
57561:     /**
57561:      * Invoke the fragment parsing algorithm (innerHTML).
57561:      *
57561:      * @param aSourceBuffer the string being set as innerHTML
57561:      * @param aTargetNode the target container
57561:      * @param aContextLocalName local name of context node
57561:      * @param aContextNamespace namespace of context node
57561:      * @param aQuirks true to make <table> not close <p>
57561:      * @param aPreventScriptExecution true to prevent scripts from executing;
57561:      * don't set to false when parsing into a target node that has been bound
57561:      * to tree.
57561:      */
76287:     nsresult ParseHtml5Fragment(const nsAString& aSourceBuffer,
57561:                                 nsIContent* aTargetNode,
57561:                                 nsIAtom* aContextLocalName,
57561:                                 PRInt32 aContextNamespace,
79445:                                 bool aQuirks,
79445:                                 bool aPreventScriptExecution);
57561: 
32917:     // Not from an external interface
32917:     // Non-inherited methods
29805: 
32917:   public:
29805: 
29805:     /**
32917:      * Initializes the parser to load from a channel.
29805:      */
29805:     virtual nsresult Initialize(nsIDocument* aDoc,
29805:                         nsIURI* aURI,
29805:                         nsISupports* aContainer,
29805:                         nsIChannel* aChannel);
29805: 
32917:     inline nsHtml5Tokenizer* GetTokenizer() {
32917:       return mTokenizer;
29805:     }
29805: 
35294:     void InitializeDocWriteParserState(nsAHtml5TreeBuilderState* aState, PRInt32 aLine);
34979: 
32917:     void DropStreamParser() {
41395:       if (mStreamParser) {
41395:         mStreamParser->DropTimer();
32917:         mStreamParser = nsnull;
32917:       }
41395:     }
32917:     
79445:     void StartTokenizer(bool aScriptingEnabled);
34979:     
34986:     void ContinueAfterFailedCharsetSwitch();
34986: 
39737:     nsHtml5StreamParser* GetStreamParser() {
39737:       return mStreamParser;
34979:     }
29805: 
29805:     /**
34992:      * Parse until pending data is exhausted or a script blocks the parser
29805:      */
34992:     void ParseUntilBlocked();
29805: 
39737:   private:
39737: 
29805:     // State variables
29805: 
29805:     /**
29805:      * Whether the last character tokenized was a carriage return (for CRLF)
29805:      */
79445:     bool                          mLastWasCR;
29805: 
29805:     /**
57849:      * Whether the last character tokenized was a carriage return (for CRLF)
57849:      * when preparsing document.write.
57849:      */
79445:     bool                          mDocWriteSpeculativeLastWasCR;
57849: 
57849:     /**
29805:      * The parser is in the fragment mode
29805:      */
79445:     bool                          mFragmentMode;
29805: 
29805:     /**
29805:      * The parser is blocking on a script
29805:      */
79445:     bool                          mBlocked;
29805: 
29805:     /**
57849:      * Whether the document.write() speculator is already active.
57849:      */
79445:     bool                          mDocWriteSpeculatorActive;
57849:     
57849:     /**
34983:      * The number of parser-inserted script currently being evaluated.
34983:      */
34983:     PRInt32                       mParserInsertedScriptsBeingEvaluated;
34983: 
34983:     /**
34979:      * True if document.close() has been called.
29805:      */
79445:     bool                          mDocumentClosed;
29805: 
81070:     bool                          mInDocumentWrite;
81070: 
29805:     // Gecko integration
29805:     void*                         mRootContextKey;
29805: 
29805:     // Portable parser objects
29805:     /**
29805:      * The first buffer in the pending UTF-16 buffer queue
29805:      */
80404:     nsRefPtr<nsHtml5OwningUTF16Buffer>  mFirstBuffer;
29805: 
29805:     /**
80404:      * The last buffer in the pending UTF-16 buffer queue. Always points
80404:      * to a sentinel object with nsnull as its parser key.
29805:      */
80404:     nsHtml5OwningUTF16Buffer* mLastBuffer; // weak ref;
29805: 
29805:     /**
32917:      * The tree operation executor
32917:      */
32917:     nsRefPtr<nsHtml5TreeOpExecutor>     mExecutor;
32917: 
32917:     /**
29805:      * The HTML5 tree builder
29805:      */
32917:     const nsAutoPtr<nsHtml5TreeBuilder> mTreeBuilder;
29805: 
29805:     /**
29805:      * The HTML5 tokenizer
29805:      */
32917:     const nsAutoPtr<nsHtml5Tokenizer>   mTokenizer;
29805: 
29805:     /**
57849:      * Another HTML5 tree builder for preloading document.written content.
57849:      */
57849:     nsAutoPtr<nsHtml5TreeBuilder> mDocWriteSpeculativeTreeBuilder;
57849: 
57849:     /**
57849:      * Another HTML5 tokenizer for preloading document.written content.
57849:      */
57849:     nsAutoPtr<nsHtml5Tokenizer>   mDocWriteSpeculativeTokenizer;
57849: 
57849:     /**
32917:      * The stream parser.
29805:      */
32917:     nsRefPtr<nsHtml5StreamParser>       mStreamParser;
29805: 
34978:     /**
35294:      *
35294:      */
35294:     PRInt32                             mRootContextLineNumber;
35294:     
35294:     /**
34981:      * Whether it's OK to transfer parsing back to the stream parser
34981:      */
79445:     bool                                mReturnToStreamParserPermitted;
34981: 
34981:     /**
34979:      * The scoped atom table
34978:      */
34979:     nsHtml5AtomTable                    mAtomTable;
34978: 
29805: };
29805: #endif
