29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
25100:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS object implementation.
    1:  */
33160: #define __STDC_LIMIT_MACROS
33160: 
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsbit.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jshash.h" /* Added by JSIFY */
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
33160: #include "jsstdint.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
25215: #include "jsdbgapi.h"
    1: 
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
40858: #include "jsobjinlines.h"
34349: 
    1: #if JS_HAS_GENERATORS
    1: #include "jsiter.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
 7058: #ifdef INCLUDE_MOZILLA_DTRACE
 7058: #include "jsdtracef.h"
 7058: #endif
 7058: 
30283: #include "jsatominlines.h"
35117: #include "jsobjinlines.h"
32737: #include "jsscriptinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
37741: using namespace js;
37741: 
    1: JS_FRIEND_DATA(JSObjectOps) js_ObjectOps = {
28353:     NULL,
    1:     js_LookupProperty,      js_DefineProperty,
    1:     js_GetProperty,         js_SetProperty,
    1:     js_GetAttributes,       js_SetAttributes,
    1:     js_DeleteProperty,      js_DefaultValue,
    1:     js_Enumerate,           js_CheckAccess,
38633:     js_TypeOf,              js_TraceObject,
    1:     NULL,                   NATIVE_DROP_PROPERTY,
    1:     js_Call,                js_Construct,
38633:     js_HasInstance,         js_Clear
    1: };
    1: 
    1: JSClass js_ObjectClass = {
    1:     js_Object_str,
    1:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
    1: #if JS_HAS_OBJ_PROTO_PROP
    1: 
    1: static JSBool
    1: obj_getSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSBool
    1: obj_setSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
    1: static JSPropertySpec object_props[] = {
    1:     /* These two must come first; see object_props[slot].name usage below. */
    1:     {js_proto_str, JSSLOT_PROTO, JSPROP_PERMANENT|JSPROP_SHARED,
    1:                                                   obj_getSlot,  obj_setSlot},
    1:     {js_parent_str,JSSLOT_PARENT,JSPROP_READONLY|JSPROP_PERMANENT|JSPROP_SHARED,
    1:                                                   obj_getSlot,  obj_setSlot},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: /* NB: JSSLOT_PROTO and JSSLOT_PARENT are already indexes into object_props. */
    1: #define JSSLOT_COUNT 2
    1: 
    1: static JSBool
    1: ReportStrictSlot(JSContext *cx, uint32 slot)
    1: {
    1:     if (slot == JSSLOT_PROTO)
    1:         return JS_TRUE;
    1:     return JS_ReportErrorFlagsAndNumber(cx,
    1:                                         JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                         js_GetErrorMessage, NULL,
    1:                                         JSMSG_DEPRECATED_USAGE,
    1:                                         object_props[slot].name);
    1: }
    1: 
    1: static JSBool
    1: obj_getSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsid propid;
    1:     JSAccessMode mode;
    1:     uintN attrs;
    1:     JSObject *pobj;
    1:     JSClass *clasp;
    1: 
    1:     if (id == INT_TO_JSVAL(JSSLOT_PROTO)) {
    1:         propid = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
    1:         mode = JSACC_PROTO;
    1:     } else {
    1:         propid = ATOM_TO_JSID(cx->runtime->atomState.parentAtom);
    1:         mode = JSACC_PARENT;
    1:     }
    1: 
31501:     /* Let obj->checkAccess get the slot's value, based on the access mode. */
31501:     if (!obj->checkAccess(cx, propid, mode, vp, &attrs))
    1:         return JS_FALSE;
    1: 
    1:     pobj = JSVAL_TO_OBJECT(*vp);
    1:     if (pobj) {
40826:         clasp = pobj->getClass();
    1:         if (clasp == &js_CallClass || clasp == &js_BlockClass) {
    1:             /* Censor activations and lexical scopes per ECMA-262. */
    1:             *vp = JSVAL_NULL;
27539:         } else {
27539:             /*
27539:              * DeclEnv only exists as a parent for a Call object which we
27539:              * censor. So it cannot escape to scripts.
27539:              */
27539:             JS_ASSERT(clasp != &js_DeclEnvClass);
27539:             if (pobj->map->ops->thisObject) {
25521:                 pobj = pobj->map->ops->thisObject(cx, pobj);
    1:                 if (!pobj)
    1:                     return JS_FALSE;
    1:                 *vp = OBJECT_TO_JSVAL(pobj);
    1:             }
    1:         }
27539:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: obj_setSlot(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSObject *pobj;
    1:     uint32 slot;
    1:     jsid propid;
    1:     uintN attrs;
    1: 
    1:     if (!JSVAL_IS_OBJECT(*vp))
    1:         return JS_TRUE;
    1:     pobj = JSVAL_TO_OBJECT(*vp);
    1: 
    1:     if (pobj) {
    1:         /*
    1:          * Innerize pobj here to avoid sticking unwanted properties on the
    1:          * outer object. This ensures that any with statements only grant
    1:          * access to the inner object.
    1:          */
    1:         OBJ_TO_INNER_OBJECT(cx, pobj);
    1:         if (!pobj)
    1:             return JS_FALSE;
    1:     }
    1:     slot = (uint32) JSVAL_TO_INT(id);
    1:     if (JS_HAS_STRICT_OPTION(cx) && !ReportStrictSlot(cx, slot))
    1:         return JS_FALSE;
    1: 
    1:     /* __parent__ is readonly and permanent, only __proto__ may be set. */
    1:     propid = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
31501:     if (!obj->checkAccess(cx, propid, (JSAccessMode)(JSACC_PROTO|JSACC_WRITE), vp, &attrs))
    1:         return JS_FALSE;
    1: 
28003:     return js_SetProtoOrParent(cx, obj, slot, pobj, JS_TRUE);
    1: }
    1: 
    1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: #define object_props NULL
    1: 
    1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: JSBool
28003: js_SetProtoOrParent(JSContext *cx, JSObject *obj, uint32 slot, JSObject *pobj,
28003:                     JSBool checkForCycles)
    1: {
28003:     JS_ASSERT(slot == JSSLOT_PARENT || slot == JSSLOT_PROTO);
28005:     JS_ASSERT_IF(!checkForCycles, obj != pobj);
28003: 
28003:     if (slot == JSSLOT_PROTO) {
40430:         if (obj->isNative()) {
28310:             JS_LOCK_OBJ(cx, obj);
28003:             bool ok = !!js_GetMutableScope(cx, obj);
28003:             JS_UNLOCK_OBJ(cx, obj);
28003:             if (!ok)
28003:                 return JS_FALSE;
28831:         }
28003: 
28003:         /*
28003:          * Regenerate property cache shape ids for all of the scopes along the
28003:          * old prototype chain to invalidate their property cache entries, in
30258:          * case any entries were filled by looking up through obj.
28003:          */
28935:         JSObject *oldproto = obj;
40430:         while (oldproto && oldproto->isNative()) {
28003:             JS_LOCK_OBJ(cx, oldproto);
40847:             JSScope *scope = oldproto->scope();
30258:             scope->protoShapeChange(cx);
39928:             JSObject *tmp = oldproto->getProto();
28003:             JS_UNLOCK_OBJ(cx, oldproto);
28003:             oldproto = tmp;
28003:         }
28003:     }
28003: 
28003:     if (!pobj || !checkForCycles) {
28003:         if (slot == JSSLOT_PROTO)
32603:             obj->setProto(pobj);
28003:         else
32603:             obj->setParent(pobj);
28003:     } else {
28003:         /*
28003:          * Use the GC machinery to serialize access to all objects on the
28003:          * prototype or parent chain.
28003:          */
11041:         JSSetSlotRequest ssr;
11041:         ssr.obj = obj;
11041:         ssr.pobj = pobj;
11041:         ssr.slot = (uint16) slot;
28003:         ssr.cycle = false;
28003: 
28003:         JSRuntime *rt = cx->runtime;
11041:         JS_LOCK_GC(rt);
11041:         ssr.next = rt->setSlotRequests;
11041:         rt->setSlotRequests = &ssr;
16099:         for (;;) {
11041:             js_GC(cx, GC_SET_SLOT_REQUEST);
11041:             JS_UNLOCK_GC(rt);
16099:             if (!rt->setSlotRequests)
16099:                 break;
16099:             JS_LOCK_GC(rt);
16099:         }
11041: 
28003:         if (ssr.cycle) {
28003:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28003:                                  JSMSG_CYCLIC_VALUE,
    1: #if JS_HAS_OBJ_PROTO_PROP
    1:                                  object_props[slot].name
    1: #else
    1:                                  (slot == JSSLOT_PROTO) ? js_proto_str
    1:                                                         : js_parent_str
    1: #endif
    1:                                  );
    1:             return JS_FALSE;
    1:         }
28003:     }
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSHashNumber
    1: js_hash_object(const void *key)
    1: {
40292:     return JSHashNumber(uintptr_t(key) >> JSVAL_TAGBITS);
    1: }
    1: 
    1: static JSHashEntry *
    1: MarkSharpObjects(JSContext *cx, JSObject *obj, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSHashNumber hash;
    1:     JSHashEntry **hep, *he;
    1:     jsatomid sharpid;
    1:     JSIdArray *ida;
    1:     JSBool ok;
    1:     jsint i, length;
    1:     jsid id;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1:     jsval val;
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     map = &cx->sharpObjectMap;
23915:     JS_ASSERT(map->depth >= 1);
    1:     table = map->table;
    1:     hash = js_hash_object(obj);
    1:     hep = JS_HashTableRawLookup(table, hash, obj);
    1:     he = *hep;
    1:     if (!he) {
    1:         sharpid = 0;
40292:         he = JS_HashTableRawAdd(table, hep, hash, obj, (void *) sharpid);
    1:         if (!he) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1: 
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         ok = JS_TRUE;
    1:         for (i = 0, length = ida->length; i < length; i++) {
    1:             id = ida->vector[i];
31501:             ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!prop)
    1:                 continue;
31501:             ok = obj2->getAttributes(cx, id, prop, &attrs);
    1:             if (ok) {
40430:                 if (obj2->isNative() &&
    1:                     (attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
25218:                     JSScopeProperty *sprop = (JSScopeProperty *) prop;
36991:                     val = JSVAL_VOID;
    1:                     if (attrs & JSPROP_GETTER)
32658:                         val = sprop->getterValue();
    1:                     if (attrs & JSPROP_SETTER) {
36991:                         if (val != JSVAL_VOID) {
    1:                             /* Mark the getter, then set val to setter. */
    1:                             ok = (MarkSharpObjects(cx, JSVAL_TO_OBJECT(val),
    1:                                                    NULL)
    1:                                   != NULL);
    1:                         }
32658:                         val = sprop->setterValue();
    1:                     }
    1:                 } else {
31501:                     ok = obj->getProperty(cx, id, &val);
31501:                 }
31501:             }
31501:             obj2->dropProperty(cx, prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!JSVAL_IS_PRIMITIVE(val) &&
    1:                 !MarkSharpObjects(cx, JSVAL_TO_OBJECT(val), NULL)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:         if (!ok || !idap)
    1:             JS_DestroyIdArray(cx, ida);
    1:         if (!ok)
    1:             return NULL;
    1:     } else {
40292:         sharpid = uintptr_t(he->value);
    1:         if (sharpid == 0) {
    1:             sharpid = ++map->sharpgen << SHARP_ID_SHIFT;
40292:             he->value = (void *) sharpid;
    1:         }
    1:         ida = NULL;
    1:     }
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: }
    1: 
    1: JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSIdArray *ida;
    1:     JSHashNumber hash;
    1:     JSHashEntry *he, **hep;
    1:     jsatomid sharpid;
    1:     char buf[20];
    1:     size_t len;
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return NULL;
    1: 
    1:     /* Set to null in case we return an early error. */
    1:     *sp = NULL;
    1:     map = &cx->sharpObjectMap;
    1:     table = map->table;
    1:     if (!table) {
    1:         table = JS_NewHashTable(8, js_hash_object, JS_CompareValues,
    1:                                 JS_CompareValues, NULL, NULL);
    1:         if (!table) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         map->table = table;
    1:         JS_KEEP_ATOMS(cx->runtime);
    1:     }
    1:     
40840: 
    1:     /* From this point the control must flow either through out: or bad:. */
    1:     ida = NULL;
    1:     if (map->depth == 0) {
23915:         /*
23915:          * Although MarkSharpObjects tries to avoid invoking getters,
23915:          * it ends up doing so anyway under some circumstances; for
23915:          * example, if a wrapped object has getters, the wrapper will
23915:          * prevent MarkSharpObjects from recognizing them as such.
23915:          * This could lead to js_LeaveSharpObject being called while
23915:          * MarkSharpObjects is still working.
23915:          *
23915:          * Increment map->depth while we call MarkSharpObjects, to
23915:          * ensure that such a call doesn't free the hash table we're
23915:          * still using.
23915:          */
23915:         ++map->depth;
    1:         he = MarkSharpObjects(cx, obj, &ida);
23915:         --map->depth;
    1:         if (!he)
    1:             goto bad;
40292:         JS_ASSERT((uintptr_t(he->value) & SHARP_BIT) == 0);
    1:         if (!idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             ida = NULL;
    1:         }
    1:     } else {
    1:         hash = js_hash_object(obj);
    1:         hep = JS_HashTableRawLookup(table, hash, obj);
    1:         he = *hep;
    1: 
    1:         /*
    1:          * It's possible that the value of a property has changed from the
    1:          * first time the object's properties are traversed (when the property
    1:          * ids are entered into the hash table) to the second (when they are
31501:          * converted to strings), i.e., the JSObject::getProperty() call is not
    1:          * idempotent.
    1:          */
    1:         if (!he) {
    1:             he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
    1:             if (!he) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 goto bad;
    1:             }
    1:             sharpid = 0;
    1:             goto out;
    1:         }
    1:     }
    1: 
40292:     sharpid = uintptr_t(he->value);
    1:     if (sharpid != 0) {
    1:         len = JS_snprintf(buf, sizeof buf, "#%u%c",
    1:                           sharpid >> SHARP_ID_SHIFT,
    1:                           (sharpid & SHARP_BIT) ? '#' : '=');
    1:         *sp = js_InflateString(cx, buf, &len);
    1:         if (!*sp) {
    1:             if (ida)
    1:                 JS_DestroyIdArray(cx, ida);
    1:             goto bad;
    1:         }
    1:     }
    1: 
    1: out:
    1:     JS_ASSERT(he);
    1:     if ((sharpid & SHARP_BIT) == 0) {
    1:         if (idap && !ida) {
    1:             ida = JS_Enumerate(cx, obj);
    1:             if (!ida) {
    1:                 if (*sp) {
30851:                     cx->free(*sp);
    1:                     *sp = NULL;
    1:                 }
    1:                 goto bad;
    1:             }
    1:         }
    1:         map->depth++;
    1:     }
    1: 
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: 
    1: bad:
    1:     /* Clean up the sharpObjectMap table on outermost error. */
    1:     if (map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSIdArray *ida;
    1: 
    1:     map = &cx->sharpObjectMap;
    1:     JS_ASSERT(map->depth > 0);
    1:     if (--map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     if (idap) {
    1:         ida = *idap;
    1:         if (ida) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             *idap = NULL;
    1:         }
    1:     }
    1: }
    1: 
18907: static intN
    1: gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
    1: {
  583:     JS_CALL_OBJECT_TRACER((JSTracer *)arg, (JSObject *)he->key,
  583:                           "sharp table entry");
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
    1: {
    1:     JS_ASSERT(map->depth > 0);
    1:     JS_ASSERT(map->table);
    1: 
    1:     /*
    1:      * During recursive calls to MarkSharpObjects a non-native object or
    1:      * object with a custom getProperty method can potentially return an
    1:      * unrooted value or even cut from the object graph an argument of one of
    1:      * MarkSharpObjects recursive invocations. So we must protect map->table
    1:      * entries against GC.
    1:      *
    1:      * We can not simply use JSTempValueRooter to mark the obj argument of
    1:      * MarkSharpObjects during recursion as we have to protect *all* entries
    1:      * in JSSharpObjectMap including those that contains otherwise unreachable
    1:      * objects just allocated through custom getProperty. Otherwise newer
    1:      * allocations can re-use the address of an object stored in the hashtable
    1:      * confusing js_EnterSharpObject. So to address the problem we simply
    1:      * mark all objects from map->table.
    1:      *
    1:      * An alternative "proper" solution is to use JSTempValueRooter in
    1:      * MarkSharpObjects with code to remove during finalization entries
    1:      * with otherwise unreachable objects. But this is way too complex
    1:      * to justify spending efforts.
    1:      */
  583:     JS_HashTableEnumerateEntries(map->table, gc_sharp_table_entry_marker, trc);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
 4127: static JSBool
 4127: obj_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSBool ok, outermost;
 4127:     JSObject *obj;
    1:     JSHashEntry *he;
    1:     JSIdArray *ida;
    1:     jschar *chars, *ochars, *vsharp;
    1:     const jschar *idstrchars, *vchars;
    1:     size_t nchars, idstrlength, gsoplength, vlength, vsharplength, curlen;
16069:     const char *comma;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1:     jsval *val;
    1:     JSString *gsop[2];
    1:     JSString *idstr, *valstr, *str;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
40855:     jsval localroot[4] = {JSVAL_NULL, JSVAL_NULL, JSVAL_NULL, JSVAL_NULL};
40388:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(localroot), localroot);
    1: 
    1:     /* If outermost, we need parentheses to be an expression, not a block. */
    1:     outermost = (cx->sharpObjectMap.depth == 0);
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !(he = js_EnterSharpObject(cx, obj, &ida, &chars))) {
 6917:         ok = JS_FALSE;
 6917:         goto out;
 6917:     }
    1:     if (IS_SHARP(he)) {
    1:         /*
    1:          * We didn't enter -- obj is already "sharp", meaning we've visited it
    1:          * already in our depth first search, and therefore chars contains a
    1:          * string of the form "#n#".
    1:          */
    1:         JS_ASSERT(!ida);
    1: #if JS_HAS_SHARP_VARS
    1:         nchars = js_strlen(chars);
    1: #else
    1:         chars[0] = '{';
    1:         chars[1] = '}';
    1:         chars[2] = 0;
    1:         nchars = 2;
    1: #endif
    1:         goto make_string;
    1:     }
    1:     JS_ASSERT(ida);
    1:     ok = JS_TRUE;
    1: 
    1:     if (!chars) {
    1:         /* If outermost, allocate 4 + 1 for "({})" and the terminator. */
30851:         chars = (jschar *) js_malloc(((outermost ? 4 : 2) + 1) * sizeof(jschar));
    1:         nchars = 0;
    1:         if (!chars)
    1:             goto error;
    1:         if (outermost)
    1:             chars[nchars++] = '(';
    1:     } else {
    1:         /* js_EnterSharpObject returned a string of the form "#n=" in chars. */
    1:         MAKE_SHARP(he);
    1:         nchars = js_strlen(chars);
    1:         chars = (jschar *)
30851:             js_realloc((ochars = chars), (nchars + 2 + 1) * sizeof(jschar));
    1:         if (!chars) {
30851:             js_free(ochars);
    1:             goto error;
    1:         }
    1:         if (outermost) {
    1:             /*
    1:              * No need for parentheses around the whole shebang, because #n=
    1:              * unambiguously begins an object initializer, and never a block
    1:              * statement.
    1:              */
    1:             outermost = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '{';
    1: 
    1:     comma = NULL;
    1: 
    1:     /*
    1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
 6917:      * "localroot + 2" out of the loop using the val local, which refers to
 6917:      * the raw (unconverted, "uncooked") values.
    1:      */
 6917:     val = localroot + 2;
    1: 
40855:     for (jsint i = 0, length = ida->length; i < length; i++) {
 4127:         /* Get strings for id and value and GC-root them via vp. */
40855:         jsid id = ida->vector[i];
40855: 
31501:         ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:         if (!ok)
    1:             goto error;
  969: 
  969:         /*
  969:          * Convert id to a jsval and then to a string.  Decide early whether we
  969:          * prefer get/set or old getter/setter syntax.
  969:          */
  969:         idstr = js_ValueToString(cx, ID_TO_VALUE(id));
  969:         if (!idstr) {
  969:             ok = JS_FALSE;
31501:             obj2->dropProperty(cx, prop);
  969:             goto error;
  969:         }
 4127:         *vp = STRING_TO_JSVAL(idstr);                   /* local root */
40855: 
40855:         jsint valcnt = 0;
    1:         if (prop) {
31501:             ok = obj2->getAttributes(cx, id, prop, &attrs);
    1:             if (!ok) {
31501:                 obj2->dropProperty(cx, prop);
    1:                 goto error;
    1:             }
40855:             if (obj2->isNative() && (attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
25218:                 JSScopeProperty *sprop = (JSScopeProperty *) prop;
    1:                 if (attrs & JSPROP_GETTER) {
32658:                     val[valcnt] = sprop->getterValue();
40855:                     gsop[valcnt] = ATOM_TO_STRING(cx->runtime->atomState.getAtom);
 1677:                     valcnt++;
    1:                 }
    1:                 if (attrs & JSPROP_SETTER) {
32658:                     val[valcnt] = sprop->setterValue();
40855:                     gsop[valcnt] = ATOM_TO_STRING(cx->runtime->atomState.setAtom);
    1:                     valcnt++;
 1677:                 }
    1:             } else {
    1:                 valcnt = 1;
    1:                 gsop[0] = NULL;
31501:                 ok = obj->getProperty(cx, id, &val[0]);
31501:             }
31501:             obj2->dropProperty(cx, prop);
    1:         }
    1: 
    1:         if (!ok)
    1:             goto error;
    1: 
    1:         /*
40855:          * If id is a string that's not an identifier, or if it's a negative
40855:          * integer, then it must be quoted.
    1:          */
40855:         bool idIsLexicalIdentifier = !!js_IsIdentifier(idstr);
 4529:         if (JSID_IS_ATOM(id)
  969:             ? !idIsLexicalIdentifier
 4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
40855:             idstr = js_QuoteString(cx, idstr, jschar('\''));
    1:             if (!idstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
 4127:             *vp = STRING_TO_JSVAL(idstr);               /* local root */
    1:         }
29366:         idstr->getCharsAndLength(idstrchars, idstrlength);
    1: 
40855:         for (jsint j = 0; j < valcnt; j++) {
40855:             /*
40855:              * Censor an accessor descriptor getter or setter part if it's
40855:              * undefined.
40855:              */
40855:             if (gsop[j] && JSVAL_IS_VOID(val[j]))
40855:                 continue;
40855: 
    1:             /* Convert val[j] to its canonical source form. */
    1:             valstr = js_ValueToSource(cx, val[j]);
    1:             if (!valstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
 6917:             localroot[j] = STRING_TO_JSVAL(valstr);     /* local root */
29366:             valstr->getCharsAndLength(vchars, vlength);
    1: 
40855:             /*
40855:              * If val[j] is a non-sharp object, and we're not serializing an
40855:              * accessor (ECMA syntax can't accommodate sharpened accessors),
40855:              * consider sharpening it.
40855:              */
    1:             vsharp = NULL;
    1:             vsharplength = 0;
    1: #if JS_HAS_SHARP_VARS
40855:             if (!gsop[j] && !JSVAL_IS_PRIMITIVE(val[j]) && vchars[0] != '#') {
40855:                 he = js_EnterSharpObject(cx, JSVAL_TO_OBJECT(val[j]), NULL, &vsharp);
    1:                 if (!he) {
    1:                     ok = JS_FALSE;
    1:                     goto error;
    1:                 }
    1:                 if (IS_SHARP(he)) {
    1:                     vchars = vsharp;
    1:                     vlength = js_strlen(vchars);
    1:                 } else {
    1:                     if (vsharp) {
    1:                         vsharplength = js_strlen(vsharp);
    1:                         MAKE_SHARP(he);
    1:                     }
    1:                     js_LeaveSharpObject(cx, NULL);
    1:                 }
    1:             }
    1: #endif
    1: 
 2149:             /*
 2149:              * Remove '(function ' from the beginning of valstr and ')' from the
 2149:              * end so that we can put "get" in front of the function definition.
 2149:              */
40855:             if (gsop[j] && VALUE_IS_FUNCTION(cx, val[j])) {
 2149:                 JSFunction *fun = JS_ValueToFunction(cx, val[j]);
 2149:                 const jschar *start = vchars;
 2149:                 const jschar *end = vchars + vlength;
 2149: 
 2149:                 uint8 parenChomp = 0;
 2149:                 if (vchars[0] == '(') {
 2149:                     vchars++;
 2149:                     parenChomp = 1;
 2149:                 }
 2149: 
 2149:                 /*
 2149:                  * Try to jump "getter" or "setter" keywords, if we suspect
 2149:                  * they might appear here.  This code can be confused by people
 2149:                  * defining Function.prototype.toString, so let's be cautious.
 2149:                  */
40855:                 if (JSFUN_GETTER_TEST(fun->flags) || JSFUN_SETTER_TEST(fun->flags)) {
40855:                     /* skip "getter/setter" */
 2326:                     const jschar *tmp = js_strchr_limit(vchars, ' ', end);
 2326:                     if (tmp)
 2326:                         vchars = tmp + 1;
 2149:                 }
 2149: 
 2149:                 /* Try to jump "function" keyword. */
 2149:                 if (vchars)
 2149:                     vchars = js_strchr_limit(vchars, ' ', end);
 2149: 
40855:                 /*
40855:                  * Jump over the function's name: it can't be encoded as part
40855:                  * of an ECMA getter or setter.
40855:                  */
40855:                 if (vchars)
40855:                     vchars = js_strchr_limit(vchars, '(', end);
40855: 
 2149:                 if (vchars) {
 2149:                     if (*vchars == ' ')
 2149:                         vchars++;
 2149:                     vlength = end - vchars - parenChomp;
 2149:                 } else {
 2149:                     gsop[j] = NULL;
 2149:                     vchars = start;
 2149:                 }
 2149:             }
 2149: 
    1: #define SAFE_ADD(n)                                                          \
    1:     JS_BEGIN_MACRO                                                           \
    1:         size_t n_ = (n);                                                     \
    1:         curlen += n_;                                                        \
    1:         if (curlen < n_)                                                     \
    1:             goto overflow;                                                   \
    1:     JS_END_MACRO
    1: 
    1:             curlen = nchars;
    1:             if (comma)
    1:                 SAFE_ADD(2);
    1:             SAFE_ADD(idstrlength + 1);
    1:             if (gsop[j])
29366:                 SAFE_ADD(gsop[j]->length() + 1);
    1:             SAFE_ADD(vsharplength);
    1:             SAFE_ADD(vlength);
    1:             /* Account for the trailing null. */
    1:             SAFE_ADD((outermost ? 2 : 1) + 1);
    1: #undef SAFE_ADD
    1: 
40855:             if (curlen > size_t(-1) / sizeof(jschar))
    1:                 goto overflow;
    1: 
    1:             /* Allocate 1 + 1 at end for closing brace and terminating 0. */
40855:             chars = (jschar *) js_realloc((ochars = chars), curlen * sizeof(jschar));
    1:             if (!chars) {
    1:                 /* Save code space on error: let JS_free ignore null vsharp. */
30851:                 cx->free(vsharp);
30851:                 js_free(ochars);
    1:                 goto error;
    1:             }
    1: 
    1:             if (comma) {
    1:                 chars[nchars++] = comma[0];
    1:                 chars[nchars++] = comma[1];
    1:             }
    1:             comma = ", ";
    1: 
    1:             if (gsop[j]) {
29366:                 gsoplength = gsop[j]->length();
29366:                 js_strncpy(&chars[nchars], gsop[j]->chars(),
  969:                             gsoplength);
    1:                 nchars += gsoplength;
    1:                 chars[nchars++] = ' ';
    1:             }
    1:             js_strncpy(&chars[nchars], idstrchars, idstrlength);
    1:             nchars += idstrlength;
  969:             /* Extraneous space after id here will be extracted later */
    1:             chars[nchars++] = gsop[j] ? ' ' : ':';
 1490: 
    1:             if (vsharplength) {
    1:                 js_strncpy(&chars[nchars], vsharp, vsharplength);
    1:                 nchars += vsharplength;
    1:             }
    1:             js_strncpy(&chars[nchars], vchars, vlength);
    1:             nchars += vlength;
    1: 
    1:             if (vsharp)
30851:                 cx->free(vsharp);
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '}';
    1:     if (outermost)
    1:         chars[nchars++] = ')';
    1:     chars[nchars] = 0;
    1: 
    1:   error:
    1:     js_LeaveSharpObject(cx, &ida);
    1: 
    1:     if (!ok) {
    1:         if (chars)
30851:             js_free(chars);
 6917:         goto out;
    1:     }
    1: 
    1:     if (!chars) {
    1:         JS_ReportOutOfMemory(cx);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
    1:   make_string:
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
30851:         js_free(chars);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
 6917:     ok = JS_TRUE;
 6917:   out:
 6917:     return ok;
    1: 
    1:   overflow:
30851:     cx->free(vsharp);
30851:     js_free(chars);
    1:     chars = NULL;
    1:     goto error;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
 4127: static JSBool
 4127: obj_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     JSObject *obj;
    1:     jschar *chars;
    1:     size_t nchars;
    1:     const char *clazz, *prefix;
    1:     JSString *str;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
11809:         return JS_FALSE;
12674:     obj = js_GetWrappedObject(cx, obj);
40826:     clazz = obj->getClass()->name;
    1:     nchars = 9 + strlen(clazz);         /* 9 for "[object ]" */
30851:     chars = (jschar *) cx->malloc((nchars + 1) * sizeof(jschar));
    1:     if (!chars)
    1:         return JS_FALSE;
    1: 
    1:     prefix = "[object ";
    1:     nchars = 0;
    1:     while ((chars[nchars] = (jschar)*prefix) != 0)
    1:         nchars++, prefix++;
    1:     while ((chars[nchars] = (jschar)*clazz) != 0)
    1:         nchars++, clazz++;
    1:     chars[nchars++] = ']';
    1:     chars[nchars] = 0;
    1: 
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
30851:         cx->free(chars);
    1:         return JS_FALSE;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_toLocaleString(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     jsval thisv;
    1:     JSString *str;
    1: 
11809:     thisv = JS_THIS(cx, vp);
11809:     if (JSVAL_IS_NULL(thisv))
11809:         return JS_FALSE;
11809: 
11809:     str = js_ValueToString(cx, thisv);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_valueOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     *vp = JS_THIS(cx, vp);
11809:     return !JSVAL_IS_NULL(*vp);
    1: }
    1: 
    1: /*
39061:  * Check if CSP allows new Function() or eval() to run in the current
39061:  * principals.
39061:  */
39061: JSBool
39061: js_CheckContentSecurityPolicy(JSContext *cx)
39061: {
39061:     JSSecurityCallbacks *callbacks;
39061:     callbacks = JS_GetSecurityCallbacks(cx);
39061: 
39061:     // if there are callbacks, make sure that the CSP callback is installed and
39061:     // that it permits eval().
39649:     if (callbacks && callbacks->contentSecurityPolicyAllows)
39649:         return callbacks->contentSecurityPolicyAllows(cx);
39061: 
39061:     return JS_TRUE;
39061: }
39061: 
39061: /*
    1:  * Check whether principals subsumes scopeobj's principals, and return true
    1:  * if so (or if scopeobj has no principals, for backward compatibility with
    1:  * the JS API, which does not require principals), and false otherwise.
    1:  */
    1: JSBool
    1: js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
    1:                          JSPrincipals *principals, JSAtom *caller)
    1: {
18870:     JSSecurityCallbacks *callbacks;
    1:     JSPrincipals *scopePrincipals;
    1:     const char *callerstr;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
18870:         scopePrincipals = callbacks->findObjectPrincipals(cx, scopeobj);
    1:         if (!principals || !scopePrincipals ||
    1:             !principals->subsume(principals, scopePrincipals)) {
    1:             callerstr = js_AtomToPrintableString(cx, caller);
    1:             if (!callerstr)
    1:                 return JS_FALSE;
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_INDIRECT_CALL, callerstr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_CheckScopeChainValidity(JSContext *cx, JSObject *scopeobj, const char *caller)
    1: {
    1:     JSClass *clasp;
    1:     JSExtendedClass *xclasp;
    1:     JSObject *inner;
    1: 
    1:     if (!scopeobj)
    1:         goto bad;
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, scopeobj);
    1:     if (!scopeobj)
    1:         return NULL;
    1: 
    1:     inner = scopeobj;
    1: 
    1:     /* XXX This is an awful gross hack. */
    1:     while (scopeobj) {
40826:         clasp = scopeobj->getClass();
    1:         if (clasp->flags & JSCLASS_IS_EXTENDED) {
    1:             xclasp = (JSExtendedClass*)clasp;
    1:             if (xclasp->innerObject &&
    1:                 xclasp->innerObject(cx, scopeobj) != scopeobj) {
    1:                 goto bad;
    1:             }
    1:         }
    1: 
39930:         scopeobj = scopeobj->getParent();
    1:     }
    1: 
    1:     return inner;
    1: 
    1: bad:
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                          JSMSG_BAD_INDIRECT_CALL, caller);
    1:     return NULL;
    1: }
    1: 
12690: const char *
12690: js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
12690:                    JSPrincipals *principals, uintN *linenop)
12690: {
12690:     uint32 flags;
18870: #ifdef DEBUG
18870:     JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
18870: #endif
18870: 
18870:     JS_ASSERT(principals || !(callbacks  && callbacks->findObjectPrincipals));
12690:     flags = JS_GetScriptFilenameFlags(caller->script);
12690:     if ((flags & JSFILENAME_PROTECTED) &&
18472:         principals &&
12690:         strcmp(principals->codebase, "[System Principal]")) {
12690:         *linenop = 0;
12690:         return principals->codebase;
12690:     }
12690: 
29901:     if (caller->regs && js_GetOpcode(cx, caller->script, caller->regs->pc) == JSOP_EVAL) {
29901:         JS_ASSERT(js_GetOpcode(cx, caller->script, caller->regs->pc + JSOP_EVAL_LENGTH) == JSOP_LINENO);
29901:         *linenop = GET_UINT16(caller->regs->pc + JSOP_EVAL_LENGTH);
13504:     } else {
21685:         *linenop = js_FramePCToLineNumber(cx, caller);
13504:     }
12690:     return caller->script->filename;
12690: }
12690: 
24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
24375: # define EVAL_CACHE_CHAIN_LIMIT 4
24375: #endif
24375: 
24375: static inline JSScript **
24375: EvalCacheHash(JSContext *cx, JSString *str)
24375: {
24375:     const jschar *s;
24375:     size_t n;
24375:     uint32 h;
24375: 
29366:     str->getCharsAndLength(s, n);
24375:     if (n > 100)
24375:         n = 100;
24375:     for (h = 0; n; s++, n--)
24375:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
24375: 
24375:     h *= JS_GOLDEN_RATIO;
24375:     h >>= 32 - JS_EVAL_CACHE_SHIFT;
24375:     return &JS_SCRIPTS_TO_GC(cx)[h];
24375: }
24375: 
20408: static JSBool
38586: obj_eval(JSContext *cx, uintN argc, jsval *vp)
38586: {
38586:     if (argc < 1) {
38586:         *vp = JSVAL_VOID;
38586:         return JS_TRUE;
38586:     }
38586: 
38592:     JSStackFrame *caller = js_GetScriptedCaller(cx, NULL);
33188:     if (!caller) {
33188:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
33188:                              JSMSG_BAD_INDIRECT_CALL, js_eval_str);
33188:         return JS_FALSE;
33188:     }
33188: 
38586:     bool indirectCall = (caller->regs && *caller->regs->pc != JSOP_EVAL);
    1: 
 2112:     /*
25744:      * This call to js_GetWrappedObject is safe because of the security checks
25744:      * we do below. However, the control flow below is confusing, so we double
25744:      * check. There are two cases:
25744:      * - Direct call: This object is never used. So unwrapping can't hurt.
25744:      * - Indirect call: If this object isn't already the scope chain (which
25744:      *   we're guaranteed to be allowed to access) then we do a security
25744:      *   check.
25744:      */
38586:     jsval *argv = JS_ARGV(cx, vp);
38586:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
38586:     if (!obj)
38586:         return JS_FALSE;
25744:     obj = js_GetWrappedObject(cx, obj);
25744: 
25744:     /*
 2112:      * Ban all indirect uses of eval (global.foo = eval; global.foo(...)) and
 2112:      * calls that attempt to use a non-global object as the "with" object in
 2112:      * the former indirect case.
 2112:      */
25744:     {
39930:         JSObject *parent = obj->getParent();
25744:         if (indirectCall || parent) {
25744:             uintN flags = parent
 2157:                           ? JSREPORT_ERROR
 2157:                           : JSREPORT_STRICT | JSREPORT_WARNING;
 2157:             if (!JS_ReportErrorFlagsAndNumber(cx, flags, js_GetErrorMessage, NULL,
 2157:                                               JSMSG_BAD_INDIRECT_CALL,
 2157:                                               js_eval_str)) {
    1:                 return JS_FALSE;
    1:             }
 2157:         }
25744:     }
    1: 
    1:     if (!JSVAL_IS_STRING(argv[0])) {
38586:         *vp = argv[0];
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * If the caller is a lightweight function and doesn't have a variables
    1:      * object, then we need to provide one for the compiler to stick any
    1:      * declared (var) variables into.
    1:      */
37777:     if (caller->fun && !caller->callobj && !js_GetCallObject(cx, caller))
    1:         return JS_FALSE;
    1: 
23064:     /* Accept an optional trailing argument that overrides the scope object. */
25744:     JSObject *scopeobj = NULL;
23064:     if (argc >= 2) {
23064:         if (!js_ValueToObject(cx, argv[1], &scopeobj))
    1:             return JS_FALSE;
23064:         argv[1] = OBJECT_TO_JSVAL(scopeobj);
    1:     }
    1: 
38586:     /* Guard for conditionally-created with object below. */
38586:     struct WithGuard {
38586:         JSObject *obj;
38586:         WithGuard() : obj(NULL) {}
38586:         ~WithGuard() { if (obj) obj->setPrivate(NULL); }
38586:     } withGuard;
38586: 
11437:     /* From here on, control must exit through label out with ok set. */
18989:     MUST_FLOW_THROUGH("out");
33188:     uintN staticLevel = caller->script->staticLevel + 1;
    1:     if (!scopeobj) {
34317:         /*
34317:          * Bring fp->scopeChain up to date. We're either going to use
34317:          * it (direct call) or save it and restore it (indirect call).
34317:          */
38586:         JSObject *callerScopeChain = js_GetScopeChain(cx, caller);
38586:         if (!callerScopeChain)
38586:             return JS_FALSE;
34317: 
 6766: #if JS_HAS_EVAL_THIS_SCOPE
33188:         /*
33188:          * If we see an indirect call, then run eval in the global scope. We do
33188:          * this so the compiler can make assumptions about what bindings may or
33188:          * may not exist in the current frame if it doesn't see 'eval'.
33188:          */
 6766:         if (indirectCall) {
33188:             /* Pretend that we're top level. */
33188:             staticLevel = 0;
33188: 
 6766:             OBJ_TO_INNER_OBJECT(cx, obj);
38586:             if (!obj)
38586:                 return JS_FALSE;
38586: 
38586:             if (!js_CheckPrincipalsAccess(cx, obj,
22962:                                           JS_StackFramePrincipals(cx, caller),
38586:                                           cx->runtime->atomState.evalAtom)) {
38586:                 return JS_FALSE;
38586:             }
 6766: 
33188:             /* NB: We know obj is a global object here. */
39930:             JS_ASSERT(!obj->getParent());
38586:             scopeobj = obj;
34317:         } else {
 2112:             /*
34317:              * Compile using the caller's current scope object.
 2112:              *
 2112:              * NB: This means that native callers (who reach this point through
 2112:              * the C API) must use the two parameter form.
 2112:              */
34317:             scopeobj = callerScopeChain;
34317:         }
34317: #endif
23064:     } else {
25744:         scopeobj = js_GetWrappedObject(cx, scopeobj);
25744:         OBJ_TO_INNER_OBJECT(cx, scopeobj);
38586:         if (!scopeobj)
38586:             return JS_FALSE;
38586: 
38586:         if (!js_CheckPrincipalsAccess(cx, scopeobj,
23064:                                       JS_StackFramePrincipals(cx, caller),
38586:                                       cx->runtime->atomState.evalAtom))
38586:             return JS_FALSE;
23064: 
34556:         /*
34556:          * If scopeobj is not a global object, then we need to wrap it in a
34556:          * with object to maintain invariants in the engine (see bug 520164).
34556:          */
34556:         if (scopeobj->getParent()) {
40424:             JSObject *global = scopeobj->getGlobal();
38586:             withGuard.obj = js_NewWithObject(cx, scopeobj, global, 0);
38586:             if (!withGuard.obj)
38586:                 return JS_FALSE;
38586: 
38586:             scopeobj = withGuard.obj;
35109:             JS_ASSERT(argc >= 2);
38586:             argv[1] = OBJECT_TO_JSVAL(withGuard.obj);
34556:         }
34556: 
33188:         /* We're pretending that we're in global code. */
33188:         staticLevel = 0;
    1:     }
    1: 
    1:     /* Ensure we compile this eval with the right object in the scope chain. */
38586:     JSObject *result = js_CheckScopeChainValidity(cx, scopeobj, js_eval_str);
38586:     JS_ASSERT_IF(result, result == scopeobj);
38586:     if (!result)
38586:         return JS_FALSE;
38586: 
39061:     // CSP check: is eval() allowed at all?
39061:     // report errors via CSP is done in the script security mgr.
39061:     if (!js_CheckContentSecurityPolicy(cx)) {
39061:         JS_ReportError(cx, "call to eval() blocked by CSP");
39061:         return  JS_FALSE;
39061:     }
39061: 
38586:     JSObject *callee = JSVAL_TO_OBJECT(vp[0]);
38586:     JSPrincipals *principals = js_EvalFramePrincipals(cx, callee, caller);
38586:     uintN line;
38586:     const char *file = js_ComputeFilename(cx, caller, principals, &line);
38586: 
38586:     JSString *str = JSVAL_TO_STRING(argv[0]);
38586:     JSScript *script = NULL;
24375: 
35303:     /*
35303:      * Cache local eval scripts indexed by source qualified by scope.
35303:      *
35303:      * An eval cache entry should never be considered a hit unless its
35303:      * strictness matches that of the new eval code. The existing code takes
35303:      * care of this, because hits are qualified by the function from which
35303:      * eval was called, whose strictness doesn't change. Scripts produced by
35303:      * calls to eval from global code are not cached.
35303:      */
38586:     JSScript **bucket = EvalCacheHash(cx, str);
35472:     if (!indirectCall && caller->fun) {
24375:         uintN count = 0;
24375:         JSScript **scriptp = bucket;
24375: 
24375:         EVAL_CACHE_METER(probe);
24375:         while ((script = *scriptp) != NULL) {
33750:             if (script->savedCallerFun &&
35472:                 script->staticLevel == staticLevel &&
24375:                 script->version == cx->version &&
24375:                 (script->principals == principals ||
24375:                  (principals->subsume(principals, script->principals) &&
24375:                   script->principals->subsume(script->principals, principals)))) {
24375:                 /*
24375:                  * Get the prior (cache-filling) eval's saved caller function.
40860:                  * See Compiler::compileScript in jsparse.cpp.
24375:                  */
34290:                 JSFunction *fun = script->getFunction(0);
24375: 
24375:                 if (fun == caller->fun) {
24375:                     /*
24375:                      * Get the source string passed for safekeeping in the
40860:                      * atom map by the prior eval to Compiler::compileScript.
24375:                      */
24375:                     JSString *src = ATOM_TO_STRING(script->atomMap.vector[0]);
24375: 
24375:                     if (src == str || js_EqualStrings(src, str)) {
24375:                         /*
24375:                          * Source matches, qualify by comparing scopeobj to the
24375:                          * COMPILE_N_GO-memoized parent of the first literal
24375:                          * function or regexp object if any. If none, then this
24375:                          * script has no compiled-in dependencies on the prior
24375:                          * eval's scopeobj.
24375:                          */
32723:                         JSObjectArray *objarray = script->objects();
24375:                         int i = 1;
34290: 
24375:                         if (objarray->length == 1) {
24375:                             if (script->regexpsOffset != 0) {
32723:                                 objarray = script->regexps();
24375:                                 i = 0;
24375:                             } else {
24375:                                 EVAL_CACHE_METER(noscope);
24375:                                 i = -1;
24375:                             }
24375:                         }
24375:                         if (i < 0 ||
39930:                             objarray->vector[i]->getParent() == scopeobj) {
35387:                             JS_ASSERT(staticLevel == script->staticLevel);
24375:                             EVAL_CACHE_METER(hit);
24375:                             *scriptp = script->u.nextToGC;
24375:                             script->u.nextToGC = NULL;
24375:                             break;
24375:                         }
24375:                     }
24375:                 }
24375:             }
24375: 
24375:             if (++count == EVAL_CACHE_CHAIN_LIMIT) {
24375:                 script = NULL;
24375:                 break;
24375:             }
24375:             EVAL_CACHE_METER(step);
24375:             scriptp = &script->u.nextToGC;
24375:         }
24375:     }
24375: 
33281:     /*
33281:      * We can't have a callerFrame (down in js_Execute's terms) if we're in
33281:      * global code. This includes indirect eval and direct eval called with a
33281:      * scope object parameter.
33281:      */
38586:     JSStackFrame *callerFrame = (staticLevel != 0) ? caller : NULL;
24375:     if (!script) {
40860:         script = Compiler::compileScript(cx, scopeobj, callerFrame,
34290:                                          principals,
34290:                                          TCF_COMPILE_N_GO | TCF_NEED_MUTABLE_SCRIPT,
29366:                                          str->chars(), str->length(),
33751:                                          NULL, file, line, str, staticLevel);
38586:         if (!script)
38586:             return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * Belt-and-braces: check that the lesser of eval's principals and the
    1:      * caller's principals has access to scopeobj.
    1:      */
38586:     JSBool ok = js_CheckPrincipalsAccess(cx, scopeobj, principals,
38586:                                          cx->runtime->atomState.evalAtom) &&
38586:                 js_Execute(cx, scopeobj, script, callerFrame, JSFRAME_EVAL, vp);
    1: 
24375:     script->u.nextToGC = *bucket;
24375:     *bucket = script;
18316: #ifdef CHECK_SCRIPT_OWNER
18316:     script->owner = NULL;
18316: #endif
 6766: 
    1:     return ok;
    1: }
    1: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: 
    1: static JSBool
    1: obj_watch_handler(JSContext *cx, JSObject *obj, jsval id, jsval old, jsval *nvp,
    1:                   void *closure)
    1: {
    1:     JSObject *callable;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSStackFrame *caller;
    1:     JSPrincipals *subject, *watcher;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
    1:     jsval argv[3];
    1:     JSBool ok;
    1: 
    1:     callable = (JSObject *) closure;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
    1:         /* Skip over any obj_watch_* frames between us and the real subject. */
22652:         caller = js_GetScriptedCaller(cx, NULL);
    1:         if (caller) {
    1:             /*
    1:              * Only call the watch handler if the watcher is allowed to watch
    1:              * the currently executing script.
    1:              */
18870:             watcher = callbacks->findObjectPrincipals(cx, callable);
    1:             subject = JS_StackFramePrincipals(cx, caller);
    1: 
    1:             if (watcher && subject && !watcher->subsume(watcher, subject)) {
    1:                 /* Silently don't call the watch handler. */
    1:                 return JS_TRUE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Avoid recursion on (obj, id) already being watched on cx. */
    1:     key.obj = obj;
    1:     key.id = id;
    1:     if (!js_StartResolving(cx, &key, JSRESFLAG_WATCH, &entry))
    1:         return JS_FALSE;
    1:     if (!entry)
    1:         return JS_TRUE;
    1:     generation = cx->resolvingTable->generation;
    1: 
    1:     argv[0] = id;
    1:     argv[1] = old;
    1:     argv[2] = *nvp;
    1:     ok = js_InternalCall(cx, obj, OBJECT_TO_JSVAL(callable), 3, argv, nvp);
    1:     js_StopResolving(cx, &key, JSRESFLAG_WATCH, entry, generation);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: obj_watch(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSObject *callable;
    1:     jsval userid, value;
    1:     jsid propid;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
16519:     if (argc <= 1) {
16519:         js_ReportMissingArg(cx, vp, 1);
16519:         return JS_FALSE;
16519:     }
16519: 
 4127:     callable = js_ValueToCallableObject(cx, &vp[3], 0);
    1:     if (!callable)
    1:         return JS_FALSE;
    1: 
    1:     /* Compute the unique int/atom symbol id needed by js_LookupProperty. */
 4127:     userid = vp[2];
    1:     if (!JS_ValueToId(cx, userid, &propid))
    1:         return JS_FALSE;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->checkAccess(cx, propid, JSACC_WATCH, &value, &attrs))
    1:         return JS_FALSE;
40878: 
40878:     *vp = JSVAL_VOID;
40878: 
    1:     if (attrs & JSPROP_READONLY)
    1:         return JS_TRUE;
39928:     if (obj->isDenseArray() && !js_MakeArraySlow(cx, obj))
15602:         return JS_FALSE;
    1:     return JS_SetWatchPoint(cx, obj, userid, obj_watch_handler, callable);
    1: }
    1: 
    1: static JSBool
 4127: obj_unwatch(JSContext *cx, uintN argc, jsval *vp)
    1: {
11809:     JSObject *obj;
11809: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj)
11809:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
16519:     return JS_ClearWatchPoint(cx, obj, argc != 0 ? vp[2] : JSVAL_VOID,
16519:                               NULL, NULL);
    1: }
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /*
    1:  * Prototype and property query methods, to complement the 'in' and
    1:  * 'instanceof' operators.
    1:  */
    1: 
    1: /* Proposed ECMA 15.2.4.5. */
20408: static JSBool
20408: obj_hasOwnProperty(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     return obj &&
16519:            js_HasOwnPropertyHelper(cx, obj->map->ops->lookupProperty, argc, vp);
    1: }
    1: 
    1: JSBool
16519: js_HasOwnPropertyHelper(JSContext *cx, JSLookupPropOp lookup, uintN argc,
16519:                         jsval *vp)
    1: {
    1:     jsid id;
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
32721: 
32721:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
36991:     JSObject *obj2;
36991:     JSProperty *prop;
36991:     if (!obj || !js_HasOwnProperty(cx, lookup, obj, id, &obj2, &prop))
36991:         return JS_FALSE;
36991:     if (prop) {
36991:         *vp = JSVAL_TRUE;
36991:         obj2->dropProperty(cx, prop);
36991:     } else {
36991:         *vp = JSVAL_FALSE;
36991:     }
32721:     return JS_TRUE;
18062: }
18062: 
18062: JSBool
18062: js_HasOwnProperty(JSContext *cx, JSLookupPropOp lookup, JSObject *obj, jsid id,
36991:                   JSObject **objp, JSProperty **propp)
36991: {
36991:     if (!lookup(cx, obj, id, objp, propp))
40327:         return false;
36991:     if (!*propp)
40327:         return true;
36991: 
36991:     if (*objp == obj)
40327:         return true;
36991: 
    1:     JSExtendedClass *xclasp;
 4780:     JSObject *outer;
36991:     JSClass *clasp = (*objp)->getClass();
 4780:     if (!(clasp->flags & JSCLASS_IS_EXTENDED) ||
 4780:         !(xclasp = (JSExtendedClass *) clasp)->outerObject) {
 4780:         outer = NULL;
 4780:     } else {
36991:         outer = xclasp->outerObject(cx, *objp);
 4780:         if (!outer)
40327:             return false;
40327:     }
40327: 
36991:     if (outer != *objp) {
40430:         if ((*objp)->isNative() && obj->getClass() == clasp) {
    1:             /*
    1:              * The combination of JSPROP_SHARED and JSPROP_PERMANENT in a
    1:              * delegated property makes that property appear to be direct in
    1:              * all delegating instances of the same native class.  This hack
    1:              * avoids bloating every function instance with its own 'length'
    1:              * (AKA 'arity') property.  But it must not extend across class
    1:              * boundaries, to avoid making hasOwnProperty lie (bug 320854).
    1:              *
    1:              * It's not really a hack, of course: a permanent property can't
    1:              * be deleted, and JSPROP_SHARED means "don't allocate a slot in
    1:              * any instance, prototype or delegating".  Without a slot, and
    1:              * without the ability to remove and recreate (with differences)
    1:              * the property, there is no way to tell whether it is directly
    1:              * owned, or indirectly delegated.
    1:              */
40265:             JSScopeProperty *sprop = reinterpret_cast<JSScopeProperty *>(*propp);
40381:             if (sprop->isSharedPermanent())
40327:                 return true;
40327:         }
40327: 
36991:         (*objp)->dropProperty(cx, *propp);
36991:         *propp = NULL;
36991:     }
40327:     return true;
    1: }
    1: 
    1: /* Proposed ECMA 15.2.4.6. */
    1: static JSBool
 4127: obj_isPrototypeOf(JSContext *cx, uintN argc, jsval *vp)
    1: {
40880:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
40880:     if (!obj)
40880:         return JS_FALSE;
    1:     JSBool b;
40880:     if (!js_IsDelegate(cx, obj, argc != 0 ? vp[2] : JSVAL_VOID, &b))
40880:         return JS_FALSE;
 4127:     *vp = BOOLEAN_TO_JSVAL(b);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* Proposed ECMA 15.2.4.7. */
20408: static JSBool
20408: obj_propertyIsEnumerable(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
18062:     JSObject *obj;
18062: 
18062:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
18062:         return JS_FALSE;
18062: 
18062:     obj = JS_THIS_OBJECT(cx, vp);
18062:     return obj && js_PropertyIsEnumerable(cx, obj, id, vp);
18062: }
18062: 
18062: JSBool
18062: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
18062: {
18062:     JSObject *pobj;
    1:     uintN attrs;
    1:     JSProperty *prop;
    1:     JSBool ok;
    1: 
31501:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
    1: 
    1:     if (!prop) {
 4127:         *vp = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * XXX ECMA spec error compatible: return false unless hasOwnProperty.
    1:      * The ECMA spec really should be fixed so propertyIsEnumerable and the
    1:      * for..in loop agree on whether prototype properties are enumerable,
    1:      * obviously by fixing this method (not by breaking the for..in loop!).
    1:      *
    1:      * We check here for shared permanent prototype properties, which should
    1:      * be treated as if they are local to obj.  They are an implementation
    1:      * technique used to satisfy ECMA requirements; users should not be able
    1:      * to distinguish a shared permanent proto-property from a local one.
    1:      */
 4127:     if (pobj != obj &&
40430:         !(pobj->isNative() &&
40327:           ((JSScopeProperty *)prop)->isSharedPermanent())) {
31501:         pobj->dropProperty(cx, prop);
 4127:         *vp = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
31501:     ok = pobj->getAttributes(cx, id, prop, &attrs);
31501:     pobj->dropProperty(cx, prop);
    1:     if (ok)
 4127:         *vp = BOOLEAN_TO_JSVAL((attrs & JSPROP_ENUMERATE) != 0);
    1:     return ok;
    1: }
    1: 
40855: #if OLD_GETTER_SETTER_METHODS
40855: 
40855: const char js_defineGetter_str[] = "__defineGetter__";
40855: const char js_defineSetter_str[] = "__defineSetter__";
40855: const char js_lookupGetter_str[] = "__lookupGetter__";
40855: const char js_lookupSetter_str[] = "__lookupSetter__";
40855: 
24145: JS_FRIEND_API(JSBool)
24145: js_obj_defineGetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fval, junk;
    1:     jsid id;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
38638:     if (argc <= 1 || !js_IsCallable(vp[3])) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_getter_str);
    1:         return JS_FALSE;
    1:     }
16519:     fval = vp[3];
    1: 
 4127:     if (!JS_ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_CheckRedeclaration(cx, obj, id, JSPROP_GETTER, NULL, NULL))
    1:         return JS_FALSE;
    1:     /*
    1:      * Getters and setters are just like watchpoints from an access
    1:      * control point of view.
    1:      */
31501:     if (!obj->checkAccess(cx, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
31501:     return obj->defineProperty(cx, id, JSVAL_VOID,
41860:                                CastAsPropertyOp(JSVAL_TO_OBJECT(fval)), JS_PropertyStub,
32573:                                JSPROP_ENUMERATE | JSPROP_GETTER | JSPROP_SHARED);
    1: }
    1: 
24145: JS_FRIEND_API(JSBool)
24145: js_obj_defineSetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsval fval, junk;
    1:     jsid id;
 4127:     JSObject *obj;
    1:     uintN attrs;
    1: 
38638:     if (argc <= 1 || !js_IsCallable(vp[3])) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_setter_str);
    1:         return JS_FALSE;
    1:     }
16519:     fval = vp[3];
    1: 
 4127:     if (!JS_ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     if (!obj || !js_CheckRedeclaration(cx, obj, id, JSPROP_SETTER, NULL, NULL))
    1:         return JS_FALSE;
    1:     /*
    1:      * Getters and setters are just like watchpoints from an access
    1:      * control point of view.
    1:      */
31501:     if (!obj->checkAccess(cx, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
31501:     return obj->defineProperty(cx, id, JSVAL_VOID,
41860:                                JS_PropertyStub, CastAsPropertyOp(JSVAL_TO_OBJECT(fval)),
32573:                                JSPROP_ENUMERATE | JSPROP_SETTER | JSPROP_SHARED);
    1: }
    1: 
    1: static JSBool
 4127: obj_lookupGetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
11809:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     if (prop) {
40430:         if (pobj->isNative()) {
    1:             sprop = (JSScopeProperty *) prop;
40265:             if (sprop->hasGetterValue())
32658:                 *vp = sprop->getterValue();
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: obj_lookupSetter(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     jsid id;
11809:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
16519:     if (!JS_ValueToId(cx, argc != 0 ? vp[2] : JSVAL_VOID, &id))
    1:         return JS_FALSE;
11809:     obj = JS_THIS_OBJECT(cx, vp);
31501:     if (!obj || !obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
 4127:     *vp = JSVAL_VOID;
    1:     if (prop) {
40430:         if (pobj->isNative()) {
    1:             sprop = (JSScopeProperty *) prop;
40265:             if (sprop->hasSetterValue())
32658:                 *vp = sprop->setterValue();
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1:     }
    1:     return JS_TRUE;
    1: }
40855: #endif /* OLD_GETTER_SETTER_METHODS */
    1: 
16380: JSBool
16380: obj_getPrototypeOf(JSContext *cx, uintN argc, jsval *vp)
16380: {
16380:     JSObject *obj;
16380:     uintN attrs;
16380: 
16519:     if (argc == 0) {
16519:         js_ReportMissingArg(cx, vp, 0);
16519:         return JS_FALSE;
16519:     }
16519: 
31844:     if (JSVAL_IS_PRIMITIVE(vp[2])) {
33166:         char *bytes = js_DecompileValueGenerator(cx, 0 - argc, vp[2], NULL);
31844:         if (!bytes)
16380:             return JS_FALSE;
31844:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31844:                              JSMSG_UNEXPECTED_TYPE, bytes, "not an object");
31844:         JS_free(cx, bytes);
31844:         return JS_FALSE;
31844:     }
31844: 
31844:     obj = JSVAL_TO_OBJECT(vp[2]);
31501:     return obj->checkAccess(cx, ATOM_TO_JSID(cx->runtime->atomState.protoAtom),
16380:                             JSACC_PROTO, vp, &attrs);
16380: }
16380: 
40356: JSBool
40356: js_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
40356: {
36991:     JSObject *pobj;
36991:     JSProperty *prop;
40356:     if (!js_HasOwnProperty(cx, obj->map->ops->lookupProperty, obj, id, &pobj, &prop))
40356:         return false;
36991:     if (!prop) {
32721:         *vp = JSVAL_VOID;
40356:         return true;
32721:     }
32721: 
32721:     uintN attrs;
40356:     if (!pobj->getAttributes(cx, id, prop, &attrs)) {
35098:         pobj->dropProperty(cx, prop);
40356:         return false;
35098:     }
35098: 
35098:     jsval roots[] = { JSVAL_VOID, JSVAL_VOID };
40221:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(roots), roots);
35098:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
40430:         if (obj->isNative()) {
35098:             JSScopeProperty *sprop = reinterpret_cast<JSScopeProperty *>(prop);
35098:             if (attrs & JSPROP_GETTER)
36991:                 roots[0] = sprop->getterValue();
35098:             if (attrs & JSPROP_SETTER)
36991:                 roots[1] = sprop->setterValue();
35098:         }
35098: 
35098:         pobj->dropProperty(cx, prop);
35098:     } else {
35098:         pobj->dropProperty(cx, prop);
35098: 
40356:         if (!obj->getProperty(cx, id, &roots[0]))
40356:             return false;
35098:     }
35098: 
32721: 
32721:     /* We have our own property, so start creating the descriptor. */
40858:     JSObject *desc = NewObject(cx, &js_ObjectClass, NULL, NULL);
32721:     if (!desc)
40356:         return false;
32721:     *vp = OBJECT_TO_JSVAL(desc); /* Root and return. */
32721: 
35098:     const JSAtomState &atomState = cx->runtime->atomState;
35098:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
35098:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.getAtom), roots[0],
35098:                                   JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE) ||
35098:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.setAtom), roots[1],
35098:                                   JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE)) {
40356:             return false;
35098:         }
35098:     } else {
35098:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.valueAtom), roots[0],
32721:                                   JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE) ||
32721:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.writableAtom),
32721:                                   BOOLEAN_TO_JSVAL((attrs & JSPROP_READONLY) == 0),
32721:                                   JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE)) {
40356:             return false;
35098:         }
35098:     }
35098: 
35098:     return desc->defineProperty(cx, ATOM_TO_JSID(atomState.enumerableAtom),
32721:                                 BOOLEAN_TO_JSVAL((attrs & JSPROP_ENUMERATE) != 0),
32721:                                 JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE) &&
32721:            desc->defineProperty(cx, ATOM_TO_JSID(atomState.configurableAtom),
32721:                                 BOOLEAN_TO_JSVAL((attrs & JSPROP_PERMANENT) == 0),
32721:                                 JS_PropertyStub, JS_PropertyStub, JSPROP_ENUMERATE);
32721: }
32721: 
33155: static JSBool
40356: obj_getOwnPropertyDescriptor(JSContext *cx, uintN argc, jsval *vp)
40356: {
40356:     if (argc == 0 || JSVAL_IS_PRIMITIVE(vp[2])) {
40356:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
40356:         return false;
40356:     }
40356:     JSObject *obj = JSVAL_TO_OBJECT(vp[2]);
40388:     AutoIdRooter nameidr(cx);
40356:     if (!JS_ValueToId(cx, argc >= 2 ? vp[3] : JSVAL_VOID, nameidr.addr()))
40356:         return JS_FALSE;
40356:     return js_GetOwnPropertyDescriptor(cx, obj, nameidr.id(), vp);
40356: }
40356: 
40356: static JSBool
33155: obj_keys(JSContext *cx, uintN argc, jsval *vp)
33155: {
33155:     jsval v = argc == 0 ? JSVAL_VOID : vp[2];
33155:     if (JSVAL_IS_PRIMITIVE(v)) {
33155:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
33155:         return JS_FALSE;
33155:     }
33155: 
33155:     JSObject *obj = JSVAL_TO_OBJECT(v);
40388:     AutoIdArray ida(cx, JS_Enumerate(cx, obj));
33155:     if (!ida)
33155:         return JS_FALSE;
33155: 
33155:     JSObject *proto;
38604:     if (!js_GetClassPrototype(cx, NULL, JSProto_Array, &proto))
33155:         return JS_FALSE;
33155:     vp[1] = OBJECT_TO_JSVAL(proto);
33155: 
33160:     JS_ASSERT(ida.length() <= UINT32_MAX);
33160:     JSObject *aobj = js_NewArrayWithSlots(cx, proto, uint32(ida.length()));
33155:     if (!aobj)
33155:         return JS_FALSE;
33155:     *vp = OBJECT_TO_JSVAL(aobj);
33155: 
33155:     jsval *slots = aobj->dslots;
33155:     size_t len = ida.length();
41782:     JS_ASSERT(aobj->getDenseArrayCapacity() >= len);
33155:     for (size_t i = 0; i < len; i++) {
33155:         jsid id = ida[i];
33155:         if (JSID_IS_INT(id)) {
33155:             if (!js_ValueToStringId(cx, INT_JSID_TO_JSVAL(id), &slots[i]))
33155:                 return JS_FALSE;
33155:         } else {
33155:             /*
33155:              * Object-valued ids are a possibility admitted by SpiderMonkey for
33155:              * the purposes of E4X.  It's unclear whether they could ever be
33155:              * detected here -- the "obvious" possibility, a property referred
33155:              * to by a QName, actually appears as a string jsid -- but in the
33155:              * interests of fidelity we pass object jsids through unchanged.
33155:              */
33155:             slots[i] = ID_TO_VALUE(id);
33155:         }
33155:     }
33155: 
33175:     JS_ASSERT(len <= UINT32_MAX);
41838:     aobj->setDenseArrayCount(len);
33175: 
33155:     return JS_TRUE;
33155: }
33155: 
36991: static JSBool
36991: HasProperty(JSContext* cx, JSObject* obj, jsid id, jsval* vp, JSBool* answerp)
36991: {
36991:     if (!JS_HasPropertyById(cx, obj, id, answerp))
36991:         return JS_FALSE;
36991:     if (!*answerp) {
36991:         *vp = JSVAL_VOID;
36991:         return JS_TRUE;
36991:     }
36991:     return JS_GetPropertyById(cx, obj, id, vp);
36991: }
36991: 
36991: PropertyDescriptor::PropertyDescriptor()
36991:   : id(INT_JSVAL_TO_JSID(JSVAL_ZERO)),
36991:     value(JSVAL_VOID),
36991:     get(JSVAL_VOID),
36991:     set(JSVAL_VOID),
36991:     attrs(0),
36991:     hasGet(false),
36991:     hasSet(false),
36991:     hasValue(false),
36991:     hasWritable(false),
36991:     hasEnumerable(false),
36991:     hasConfigurable(false)
36991: {
36991: }
36991: 
36991: bool
36991: PropertyDescriptor::initialize(JSContext* cx, jsid id, jsval v)
36991: {
36991:     this->id = id;
36991: 
36991:     /* 8.10.5 step 1 */
36991:     if (JSVAL_IS_PRIMITIVE(v)) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
36991:         return false;
36991:     }
36991:     JSObject* desc = JSVAL_TO_OBJECT(v);
36991: 
36991:     /* Start with the proper defaults. */
36991:     attrs = JSPROP_PERMANENT | JSPROP_READONLY;
36991: 
36991:     JSBool hasProperty;
36991: 
36991:     /* 8.10.5 step 3 */
36991:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.enumerableAtom), &v,
36991:                      &hasProperty)) {
36991:         return false;
36991:     }
36991:     if (hasProperty) {
36991:         hasEnumerable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs |= JSPROP_ENUMERATE;
36991:     }
36991: 
36991:     /* 8.10.5 step 4 */
36991:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.configurableAtom), &v,
36991:                      &hasProperty)) {
36991:         return false;
36991:     }
36991:     if (hasProperty) {
36991:         hasConfigurable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_PERMANENT;
36991:     }
36991: 
36991:     /* 8.10.5 step 5 */
36991:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.valueAtom), &v, &hasProperty))
36991:         return false;
36991:     if (hasProperty) {
36991:         hasValue = true;
36991:         value = v;
36991:     }
36991: 
36991:     /* 8.10.6 step 6 */
36991:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.writableAtom), &v, &hasProperty))
36991:         return false;
36991:     if (hasProperty) {
36991:         hasWritable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_READONLY;
36991:     }
36991: 
36991:     /* 8.10.7 step 7 */
36991:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.getAtom), &v, &hasProperty))
36991:         return false;
36991:     if (hasProperty) {
40831:         if ((JSVAL_IS_PRIMITIVE(v) || !js_IsCallable(v)) && v != JSVAL_VOID) {
40831:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
36991:                                  js_getter_str);
36991:             return false;
36991:         }
36991:         hasGet = true;
36991:         get = v;
36991:         attrs |= JSPROP_GETTER | JSPROP_SHARED;
36991:     }
36991: 
36991:     /* 8.10.7 step 8 */
36991:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.setAtom), &v, &hasProperty))
36991:         return false;
36991:     if (hasProperty) {
40831:         if ((JSVAL_IS_PRIMITIVE(v) || !js_IsCallable(v)) && v != JSVAL_VOID) {
40831:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
36991:                                  js_setter_str);
36991:             return false;
36991:         }
36991:         hasSet = true;
36991:         set = v;
36991:         attrs |= JSPROP_SETTER | JSPROP_SHARED;
36991:     }
36991: 
36991:     /* 8.10.7 step 9 */
36991:     if ((hasGet || hasSet) && (hasValue || hasWritable)) {
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INVALID_DESCRIPTOR);
36991:         return false;
36991:     }
36991: 
36991:     return true;
36991: }
36991: 
36991: static JSBool
36991: Reject(JSContext *cx, uintN errorNumber, bool throwError, jsid id, bool *rval)
36991: {
36991:     if (throwError) {
36991:         jsid idstr;
36991:         if (!js_ValueToStringId(cx, ID_TO_VALUE(id), &idstr))
36991:            return JS_FALSE;
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber,
36991:                              JS_GetStringBytes(JSVAL_TO_STRING(ID_TO_VALUE(idstr))));
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
36991: Reject(JSContext *cx, uintN errorNumber, bool throwError, bool *rval)
36991: {
36991:     if (throwError) {
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber);
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
36991: Reject(JSContext *cx, JSObject *obj, JSProperty *prop, uintN errorNumber, bool throwError,
36991:        jsid id, bool *rval)
36991: {
36991:     obj->dropProperty(cx, prop);
36991:     return Reject(cx, errorNumber, throwError, id, rval);
36991: }
36991: 
36991: static JSBool
41860: DefinePropertyOnObject(JSContext *cx, JSObject *obj, const PropertyDescriptor &desc,
36991:                        bool throwError, bool *rval)
36991: {
36991:     /* 8.12.9 step 1. */
36991:     JSProperty *current;
36991:     JSObject *obj2;
36991:     JS_ASSERT(obj->map->ops->lookupProperty == js_LookupProperty);
36991:     if (!js_HasOwnProperty(cx, js_LookupProperty, obj, desc.id, &obj2, &current))
36991:         return JS_FALSE;
36991: 
36991:     JS_ASSERT(obj->map->ops->defineProperty == js_DefineProperty);
36991: 
36991:     /* 8.12.9 steps 2-4. */
40847:     JSScope *scope = obj->scope();
36991:     if (!current) {
36991:         if (scope->sealed())
36991:             return Reject(cx, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
36991: 
36991:         *rval = true;
36991: 
36991:         if (desc.isGenericDescriptor() || desc.isDataDescriptor()) {
36991:             JS_ASSERT(obj->map->ops->defineProperty == js_DefineProperty);
36991:             return js_DefineProperty(cx, obj, desc.id, desc.value,
36991:                                      JS_PropertyStub, JS_PropertyStub, desc.attrs);
36991:         }
36991: 
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
36991:         /*
36991:          * Getters and setters are just like watchpoints from an access
36991:          * control point of view.
36991:          */
36991:         jsval dummy;
36991:         uintN dummyAttrs;
36991:         JS_ASSERT(obj->map->ops->checkAccess == js_CheckAccess);
36991:         if (!js_CheckAccess(cx, obj, desc.id, JSACC_WATCH, &dummy, &dummyAttrs))
36991:             return JS_FALSE;
36991: 
36991:         return js_DefineProperty(cx, obj, desc.id, JSVAL_VOID,
41860:                                  desc.getter(), desc.setter(), desc.attrs);
36991:     }
36991: 
36991:     /* 8.12.9 steps 5-6 (note 5 is merely a special case of 6). */
36991:     jsval v = JSVAL_VOID;
36991: 
36991:     /*
36991:      * In the special case of shared permanent properties, the "own" property
36991:      * can be found on a different object.  In that case the returned property
36991:      * might not be native, except: the shared permanent property optimization
36991:      * is not applied if the objects have different classes (bug 320854), as
36991:      * must be enforced by js_HasOwnProperty for the JSScopeProperty cast below
36991:      * to be safe.
36991:      */
36991:     JS_ASSERT(obj->getClass() == obj2->getClass());
36991: 
36991:     JSScopeProperty *sprop = reinterpret_cast<JSScopeProperty *>(current);
36991:     do {
36991:         if (desc.isAccessorDescriptor()) {
36991:             if (!sprop->isAccessorDescriptor())
36991:                 break;
36991: 
36991:             if (desc.hasGet &&
36991:                 !js_SameValue(desc.getterValue(),
41860:                               sprop->hasGetterValue() ? sprop->getterValue() : JSVAL_VOID,
41860:                               cx)) {
36991:                 break;
36991:             }
36991: 
36991:             if (desc.hasSet &&
36991:                 !js_SameValue(desc.setterValue(),
41860:                               sprop->hasSetterValue() ? sprop->setterValue() : JSVAL_VOID,
41860:                               cx)) {
36991:                 break;
36991:             }
36991:         } else {
36991:             /*
36991:              * Determine the current value of the property once, if the current
36991:              * value might actually need to be used or preserved later.  NB: we
36991:              * guard on whether the current property is a data descriptor to
36991:              * avoid calling a getter; we won't need the value if it's not a
36991:              * data descriptor.
36991:              */
36991:             if (sprop->isDataDescriptor()) {
36991:                 /*
36991:                  * Non-standard: if the property is non-configurable and is
36991:                  * represented by a native getter or setter, don't permit
36991:                  * redefinition.  We expose properties with native getter/setter
36991:                  * as though they were data properties, for the most part, but
36991:                  * in this particular case we must worry about integrity
36991:                  * concerns for JSAPI users who expected that
36991:                  * permanent+getter/setter means precisely controlled behavior.
36991:                  * If we permitted such redefinitions, such a property could be
36991:                  * "fixed" to some specific previous value, no longer varying
36991:                  * according to the intent of the native getter/setter for the
36991:                  * property.
36991:                  *
36991:                  * Other engines expose properties of this nature using ECMA
36991:                  * getter/setter pairs, but we can't because we use them even
36991:                  * for properties which ECMA specifies as being true data
36991:                  * descriptors ([].length, Function.length, /regex/.lastIndex,
36991:                  * &c.).  Longer-term perhaps we should convert such properties
36991:                  * to use data descriptors (at which point representing a
36991:                  * descriptor with native getter/setter as an accessor
36991:                  * descriptor would be fine) and take a small memory hit, but
36991:                  * for now we'll simply forbid their redefinition.
36991:                  */
36991:                 if (!sprop->configurable() &&
40265:                     (!sprop->hasDefaultGetter() || !sprop->hasDefaultSetter())) {
36991:                     return Reject(cx, obj2, current, JSMSG_CANT_REDEFINE_UNCONFIGURABLE_PROP,
36991:                                   throwError, desc.id, rval);
36991:                 }
36991: 
36991:                 if (!js_NativeGet(cx, obj, obj2, sprop, JSGET_NO_METHOD_BARRIER, &v)) {
36991:                     /* current was dropped when the failure occurred. */
36991:                     return JS_FALSE;
36991:                 }
36991:             }
36991: 
36991:             if (desc.isDataDescriptor()) {
36991:                 if (!sprop->isDataDescriptor())
36991:                     break;
36991: 
36991:                 if (desc.hasValue && !js_SameValue(desc.value, v, cx))
36991:                     break;
36991:                 if (desc.hasWritable && desc.writable() != sprop->writable())
36991:                     break;
36991:             } else {
36991:                 /* The only fields in desc will be handled below. */
36991:                 JS_ASSERT(desc.isGenericDescriptor());
36991:             }
36991:         }
36991: 
36991:         if (desc.hasConfigurable && desc.configurable() != sprop->configurable())
36991:             break;
36991:         if (desc.hasEnumerable && desc.enumerable() != sprop->enumerable())
36991:             break;
36991: 
36991:         /* The conditions imposed by step 5 or step 6 apply. */
36991:         obj2->dropProperty(cx, current);
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     } while (0);
36991: 
36991:     /* 8.12.9 step 7. */
36991:     if (!sprop->configurable()) {
36991:         /*
36991:          * Since [[Configurable]] defaults to false, we don't need to check
36991:          * whether it was specified.  We can't do likewise for [[Enumerable]]
36991:          * because its putative value is used in a comparison -- a comparison
36991:          * whose result must always be false per spec if the [[Enumerable]]
36991:          * field is not present.  Perfectly pellucid logic, eh?
36991:          */
36991:         JS_ASSERT_IF(!desc.hasConfigurable, !desc.configurable());
36991:         if (desc.configurable() ||
36991:             (desc.hasEnumerable && desc.enumerable() != sprop->enumerable())) {
36991:             return Reject(cx, obj2, current, JSMSG_CANT_REDEFINE_UNCONFIGURABLE_PROP, throwError,
36991:                           desc.id, rval);
36991:         }
36991:     }
36991: 
36991:     if (desc.isGenericDescriptor()) {
36991:         /* 8.12.9 step 8, no validation required */
36991:     } else if (desc.isDataDescriptor() != sprop->isDataDescriptor()) {
36991:         /* 8.12.9 step 9. */
36991:         if (!sprop->configurable()) {
36991:             return Reject(cx, obj2, current, JSMSG_CANT_REDEFINE_UNCONFIGURABLE_PROP,
36991:                           throwError, desc.id, rval);
36991:         }
41860:     } else if (desc.isDataDescriptor()) {
36991:         /* 8.12.9 step 10. */
41860:         JS_ASSERT(sprop->isDataDescriptor());
36991:         if (!sprop->configurable() && !sprop->writable()) {
36991:             if ((desc.hasWritable && desc.writable()) ||
36991:                 (desc.hasValue && !js_SameValue(desc.value, v, cx))) {
36991:                 return Reject(cx, obj2, current, JSMSG_CANT_REDEFINE_UNCONFIGURABLE_PROP,
36991:                               throwError, desc.id, rval);
36991:             }
36991:         }
36991:     } else {
36991:         /* 8.12.9 step 11. */
36991:         JS_ASSERT(desc.isAccessorDescriptor() && sprop->isAccessorDescriptor());
36991:         if (!sprop->configurable()) {
36991:             if ((desc.hasSet &&
36991:                  !js_SameValue(desc.setterValue(),
40265:                                sprop->hasSetterValue() ? sprop->setterValue() : JSVAL_VOID,
36991:                                cx)) ||
36991:                 (desc.hasGet &&
36991:                  !js_SameValue(desc.getterValue(),
41860:                                sprop->hasGetterValue() ? sprop->getterValue() : JSVAL_VOID,
41860:                                cx)))
36991:             {
36991:                 return Reject(cx, obj2, current, JSMSG_CANT_REDEFINE_UNCONFIGURABLE_PROP,
36991:                               throwError, desc.id, rval);
36991:             }
36991:         }
36991:     }
36991: 
36991:     /* 8.12.9 step 12. */
36991:     uintN attrs;
36991:     JSPropertyOp getter, setter;
36991:     if (desc.isGenericDescriptor()) {
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991: 
40265:         attrs = (sprop->attributes() & ~changed) | (desc.attrs & changed);
39894:         getter = sprop->getter();
39894:         setter = sprop->setter();
36991:     } else if (desc.isDataDescriptor()) {
36991:         uintN unchanged = 0;
36991:         if (!desc.hasConfigurable)
36991:             unchanged |= JSPROP_PERMANENT;
36991:         if (!desc.hasEnumerable)
36991:             unchanged |= JSPROP_ENUMERATE;
36991:         if (!desc.hasWritable)
36991:             unchanged |= JSPROP_READONLY;
36991: 
36991:         if (desc.hasValue)
36991:             v = desc.value;
40265:         attrs = (desc.attrs & ~unchanged) | (sprop->attributes() & unchanged);
36991:         getter = setter = JS_PropertyStub;
36991:     } else {
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
36991:         /*
36991:          * Getters and setters are just like watchpoints from an access
36991:          * control point of view.
36991:          */
36991:         jsval dummy;
36991:         JS_ASSERT(obj2->map->ops->checkAccess == js_CheckAccess);
36991:         if (!js_CheckAccess(cx, obj2, desc.id, JSACC_WATCH, &dummy, &attrs)) {
36991:              obj2->dropProperty(cx, current);
36991:              return JS_FALSE;
36991:         }
36991: 
36991:         /* 8.12.9 step 12. */
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991:         if (desc.hasGet)
36991:             changed |= JSPROP_GETTER | JSPROP_SHARED;
36991:         if (desc.hasSet)
36991:             changed |= JSPROP_SETTER | JSPROP_SHARED;
36991: 
40265:         attrs = (desc.attrs & changed) | (sprop->attributes() & ~changed);
41860:         if (desc.hasGet) {
41860:             getter = desc.getter();
41860:         } else {
41860:             getter = (sprop->hasDefaultGetter() && !sprop->hasGetterValue())
41860:                      ? JS_PropertyStub
41860:                      : sprop->getter();
41860:         }
41860:         if (desc.hasSet) {
41860:             setter = desc.setter();
41860:         } else {
41860:             setter = (sprop->hasDefaultSetter() && !sprop->hasSetterValue())
41860:                      ? JS_PropertyStub
41860:                      : sprop->setter();
41860:         }
36991:     }
36991: 
36991:     *rval = true;
36991:     obj2->dropProperty(cx, current);
36991:     return js_DefineProperty(cx, obj, desc.id, v, getter, setter, attrs);
36991: }
36991: 
36991: static JSBool
41860: DefinePropertyOnArray(JSContext *cx, JSObject *obj, const PropertyDescriptor &desc,
36991:                       bool throwError, bool *rval)
36991: {
36991:     /*
36991:      * We probably should optimize dense array property definitions where
36991:      * the descriptor describes a traditional array property (enumerable,
36991:      * configurable, writable, numeric index or length without altering its
36991:      * attributes).  Such definitions are probably unlikely, so we don't bother
36991:      * for now.
36991:      */
39928:     if (obj->isDenseArray() && !js_MakeArraySlow(cx, obj))
36991:         return JS_FALSE;
36991: 
40796:     jsuint oldLen = obj->getArrayLength();
36991: 
36991:     if (desc.id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
36991:         /*
36991:          * Our optimization of storage of the length property of arrays makes
36991:          * it very difficult to properly implement defining the property.  For
36991:          * now simply throw an exception (NB: not merely Reject) on any attempt
36991:          * to define the "length" property, rather than attempting to implement
36991:          * some difficult-for-authors-to-grasp subset of that functionality.
36991:          */
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEFINE_ARRAY_LENGTH_UNSUPPORTED);
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     uint32 index;
36991:     if (js_IdIsIndex(desc.id, &index)) {
36991:         /*
36991:         // Disabled until we support defining "length":
36991:         if (index >= oldLen && lengthPropertyNotWritable())
36991:             return ThrowTypeError(cx, JSMSG_CANT_APPEND_PROPERTIES_TO_UNWRITABLE_LENGTH_ARRAY);
36991:          */
41860:         if (!DefinePropertyOnObject(cx, obj, desc, false, rval))
36991:             return JS_FALSE;
36991:         if (!*rval)
36991:             return Reject(cx, JSMSG_CANT_DEFINE_ARRAY_INDEX, throwError, rval);
36991: 
36991:         if (index >= oldLen) {
36991:             JS_ASSERT(index != UINT32_MAX);
41850:             obj->setSlowArrayLength(index + 1);
36991:         }
36991: 
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     }
36991: 
41860:     return DefinePropertyOnObject(cx, obj, desc, throwError, rval);
36991: }
36991: 
36991: static JSBool
36991: DefineProperty(JSContext *cx, JSObject *obj, const PropertyDescriptor &desc, bool throwError,
36991:                bool *rval)
36991: {
39928:     if (obj->isArray())
41860:         return DefinePropertyOnArray(cx, obj, desc, throwError, rval);
36991: 
41794:     if (obj->map->ops->lookupProperty != js_LookupProperty)
36991:         return Reject(cx, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
36991: 
41860:     return DefinePropertyOnObject(cx, obj, desc, throwError, rval);
36991: }
36991: 
40356: JSBool
40356: js_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, jsval descriptor, JSBool *bp)
40356: {
40356:     AutoDescriptorArray descs(cx);
40356:     PropertyDescriptor *desc = descs.append();
40356:     if (!desc || !desc->initialize(cx, id, descriptor))
40356:         return false;
40356: 
40356:     bool rval;
40356:     if (!DefineProperty(cx, obj, *desc, true, &rval))
40356:         return false;
40356:     *bp = !!rval;
40356:     return true;
40356: }
40356: 
36991: /* ES5 15.2.3.6: Object.defineProperty(O, P, Attributes) */
36991: static JSBool
36991: obj_defineProperty(JSContext* cx, uintN argc, jsval* vp)
36991: {
36991:     /* 15.2.3.6 steps 1 and 5. */
37010:     jsval v = (argc == 0) ? JSVAL_VOID : vp[2];
36991:     if (JSVAL_IS_PRIMITIVE(v)) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
36991:         return JS_FALSE;
36991:     }
36991:     *vp = vp[2];
36991:     JSObject* obj = JSVAL_TO_OBJECT(*vp);
36991: 
36991:     /* 15.2.3.6 step 2. */
40221:     AutoIdRooter nameidr(cx);
36991:     if (!JS_ValueToId(cx, argc >= 2 ? vp[3] : JSVAL_VOID, nameidr.addr()))
36991:         return JS_FALSE;
36991: 
36991:     /* 15.2.3.6 step 3. */
40356:     jsval descval = argc >= 3 ? vp[4] : JSVAL_VOID;
36991: 
36991:     /* 15.2.3.6 step 4 */
40356:     JSBool junk;
40356:     return js_DefineOwnProperty(cx, obj, nameidr.id(), descval, &junk);
36991: }
36991: 
36991: /* ES5 15.2.3.7: Object.defineProperties(O, Properties) */
36991: static JSBool
36991: obj_defineProperties(JSContext* cx, uintN argc, jsval* vp)
36991: {
36991:     /* 15.2.3.6 steps 1 and 5. */
37010:     if (argc < 2) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
37010:                              "Object.defineProperties", "0", "s");
37010:         return JS_FALSE;
37010:     }
37010: 
36991:     *vp = vp[2];
37010:     if (JSVAL_IS_PRIMITIVE(vp[2])) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
37010:         return JS_FALSE;
37010:     }
37010: 
37010:     JSObject* props = js_ValueToNonNullObject(cx, vp[3]);
37010:     if (!props)
37010:         return JS_FALSE;
37010:     vp[3] = OBJECT_TO_JSVAL(props);
37010: 
40388:     AutoIdArray ida(cx, JS_Enumerate(cx, props));
36991:     if (!ida)
36991:         return JS_FALSE;
36991: 
36991:     AutoDescriptorArray descs(cx);
36991:     size_t len = ida.length();
36991:     for (size_t i = 0; i < len; i++) {
36991:         jsid id = ida[i];
36999:         PropertyDescriptor* desc = descs.append();
36999:         if (!desc || !JS_GetPropertyById(cx, props, id, &vp[1]) ||
36999:             !desc->initialize(cx, id, vp[1])) {
36991:             return JS_FALSE;
36991:         }
36991:     }
36991: 
36991:     JSObject *obj = JSVAL_TO_OBJECT(*vp);
36991:     bool dummy;
36991:     for (size_t i = 0; i < len; i++) {
36991:         if (!DefineProperty(cx, obj, descs[i], true, &dummy))
36991:             return JS_FALSE;
36991:     }
36991: 
36991:     return JS_TRUE;
36991: }
36991: 
37000: /* ES5 15.2.3.5: Object.create(O [, Properties]) */
37000: static JSBool
37000: obj_create(JSContext *cx, uintN argc, jsval *vp)
37000: {
37000:     if (argc == 0) {
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
37000:                              "Object.create", "0", "s");
37000:         return JS_FALSE;
37000:     }
37000: 
37000:     jsval v = vp[2];
37000:     if (!JSVAL_IS_OBJECT(vp[2])) {
37000:         char *bytes = js_DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
37000:         if (!bytes)
37000:             return JS_FALSE;
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
37000:                              bytes, "not an object or null");
37000:         JS_free(cx, bytes);
37000:         return JS_FALSE;
37000:     }
37000: 
37000:     /*
37000:      * It's plausible that it's safe to just use the context's global object,
37000:      * but since we're not completely sure, better safe than sorry.
37000:      */
37000:     JSObject *obj =
40858:         NewObjectWithGivenProto(cx, &js_ObjectClass, JSVAL_TO_OBJECT(v), JS_GetScopeChain(cx));
37000:     if (!obj)
37000:         return JS_FALSE;
37000:     *vp = OBJECT_TO_JSVAL(obj); /* Root and prepare for eventual return. */
37000: 
37000:     /* 15.2.3.5 step 4. */
37000:     if (argc > 1 && vp[3] != JSVAL_VOID) {
37000:         if (JSVAL_IS_PRIMITIVE(vp[3])) {
37010:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
37000:             return JS_FALSE;
37000:         }
37000: 
37000:         JSObject *props = JSVAL_TO_OBJECT(vp[3]);
40388:         AutoIdArray ida(cx, JS_Enumerate(cx, props));
37000:         if (!ida)
37000:             return JS_FALSE;
37000: 
37000:         AutoDescriptorArray descs(cx);
37000:         size_t len = ida.length();
37000:         for (size_t i = 0; i < len; i++) {
37000:             jsid id = ida[i];
37001:             PropertyDescriptor *desc = descs.append();
37001:             if (!desc || !JS_GetPropertyById(cx, props, id, &vp[1]) ||
37001:                 !desc->initialize(cx, id, vp[1])) {
37000:                 return JS_FALSE;
37000:             }
37000:         }
37000: 
37000:         bool dummy;
37000:         for (size_t i = 0; i < len; i++) {
37000:             if (!DefineProperty(cx, obj, descs[i], true, &dummy))
37000:                 return JS_FALSE;
37000:         }
37000:     }
37000: 
37000:     /* 5. Return obj. */
37000:     return JS_TRUE;
37000: }
37000: 
32721: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: const char js_watch_str[] = "watch";
    1: const char js_unwatch_str[] = "unwatch";
    1: #endif
    1: const char js_hasOwnProperty_str[] = "hasOwnProperty";
    1: const char js_isPrototypeOf_str[] = "isPrototypeOf";
    1: const char js_propertyIsEnumerable_str[] = "propertyIsEnumerable";
    1: 
    1: static JSFunctionSpec object_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
    1: #endif
16519:     JS_FN(js_toString_str,             obj_toString,                0,0),
16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
41856:     JS_FN(js_valueOf_str,              obj_valueOf,                 0,0),
    1: #if JS_HAS_OBJ_WATCHPOINT
16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
    1: #endif
41856:     JS_FN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0),
16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
41856:     JS_FN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0),
40855: #if OLD_GETTER_SETTER_METHODS
24145:     JS_FN(js_defineGetter_str,         js_obj_defineGetter,         2,0),
24145:     JS_FN(js_defineSetter_str,         js_obj_defineSetter,         2,0),
16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
16380: static JSFunctionSpec object_static_methods[] = {
16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
32721:     JS_FN("getOwnPropertyDescriptor",  obj_getOwnPropertyDescriptor,2,0),
33155:     JS_FN("keys",                      obj_keys,                    1,0),
36991:     JS_FN("defineProperty",            obj_defineProperty,          3,0),
36991:     JS_FN("defineProperties",          obj_defineProperties,        2,0),
37000:     JS_FN("create",                    obj_create,                  2,0),
16380:     JS_FS_END
16380: };
16380: 
30439: JSBool
30439: js_Object(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
30439: {
30439:     if (argc == 0) {
30439:         /* Trigger logic below to construct a blank object. */
30439:         obj = NULL;
30439:     } else {
30439:         /* If argv[0] is null or undefined, obj comes back null. */
30439:         if (!js_ValueToObject(cx, argv[0], &obj))
30439:             return JS_FALSE;
30439:     }
30439:     if (!obj) {
30439:         JS_ASSERT(!argc || JSVAL_IS_NULL(argv[0]) || JSVAL_IS_VOID(argv[0]));
30439:         if (JS_IsConstructing(cx))
30439:             return JS_TRUE;
40858:         obj = NewObject(cx, &js_ObjectClass, NULL, NULL);
30439:         if (!obj)
30439:             return JS_FALSE;
30439:     }
30439:     *rval = OBJECT_TO_JSVAL(obj);
30439:     return JS_TRUE;
30439: }
30439: 
32615: #ifdef JS_TRACER
32615: 
35117: JSObject*
35117: js_NewObjectWithClassProto(JSContext *cx, JSClass *clasp, JSObject *proto,
35117:                            jsval privateSlotValue)
35117: {
35117:     JS_ASSERT(!clasp->getObjectOps);
35117:     JS_ASSERT(proto->map->ops == &js_ObjectOps);
35117: 
35117:     JSObject* obj = js_NewGCObject(cx);
35117:     if (!obj)
35117:         return NULL;
35117: 
35117:     obj->initSharingEmptyScope(clasp, proto, proto->getParent(), privateSlotValue);
35117:     return obj;
35117: }
35117: 
35117: JSObject* FASTCALL
35117: js_Object_tn(JSContext* cx, JSObject* proto)
35117: {
35117:     JS_ASSERT(!(js_ObjectClass.flags & JSCLASS_HAS_PRIVATE));
35117:     return js_NewObjectWithClassProto(cx, &js_ObjectClass, proto, JSVAL_VOID);
35117: }
35117: 
35117: JS_DEFINE_TRCINFO_1(js_Object,
39910:     (2, (extern, CONSTRUCTOR_RETRY, js_Object_tn, CONTEXT, CALLEE_PROTOTYPE, 0,
39910:          nanojit::ACC_STORE_ANY)))
35117: 
37035: JSObject* FASTCALL
37035: js_NonEmptyObject(JSContext* cx, JSObject* proto)
37035: {
37035:     JS_ASSERT(!(js_ObjectClass.flags & JSCLASS_HAS_PRIVATE));
37035:     JSObject *obj = js_NewObjectWithClassProto(cx, &js_ObjectClass, proto, JSVAL_VOID);
37919:     if (!obj)
37919:         return NULL;
37919:     JS_LOCK_OBJ(cx, obj);
37919:     JSScope *scope = js_GetMutableScope(cx, obj);
37919:     if (!scope) {
37919:         JS_UNLOCK_OBJ(cx, obj);
37919:         return NULL;
37919:     }
37919: 
37919:     /*
37919:      * See comments in the JSOP_NEWINIT case of jsops.cpp why we cannot
37919:      * assume that cx owns the scope and skip the unlock call.
37919:      */
37919:     JS_UNLOCK_SCOPE(cx, scope);
37035:     return obj;
37035: }
37035: 
39910: JS_DEFINE_CALLINFO_2(extern, CONSTRUCTOR_RETRY, js_NonEmptyObject, CONTEXT, CALLEE_PROTOTYPE, 0,
39910:                      nanojit::ACC_STORE_ANY)
37035: 
40858: 
32615: static inline JSObject*
32684: NewNativeObject(JSContext* cx, JSClass* clasp, JSObject* proto,
32684:                 JSObject *parent, jsval privateSlotValue)
32615: {
32615:     JS_ASSERT(JS_ON_TRACE(cx));
33581:     JSObject* obj = js_NewGCObject(cx);
32615:     if (!obj)
32615:         return NULL;
32615: 
35057:     obj->init(clasp, proto, parent, privateSlotValue);
40858:     return InitScopeForObject(cx, obj, clasp, proto, &js_ObjectOps) ? obj : NULL;
32615: }
32615: 
32615: JSObject* FASTCALL
32615: js_NewInstance(JSContext *cx, JSClass *clasp, JSObject *ctor)
32615: {
40430:     JS_ASSERT(ctor->isFunction());
32615: 
32615:     JSAtom *atom = cx->runtime->atomState.classPrototypeAtom;
32615: 
40847:     JSScope *scope = ctor->scope();
32615: #ifdef JS_THREADSAFE
32615:     if (scope->title.ownercx != cx)
32615:         return NULL;
32615: #endif
37766:     if (scope->isSharedEmpty()) {
32615:         scope = js_GetMutableScope(cx, ctor);
32615:         if (!scope)
32615:             return NULL;
32615:     }
32615: 
32615:     JSScopeProperty *sprop = scope->lookup(ATOM_TO_JSID(atom));
40410:     jsval pval = sprop ? ctor->getSlot(sprop->slot) : JSVAL_HOLE;
32615: 
32615:     JSObject *proto;
32615:     if (!JSVAL_IS_PRIMITIVE(pval)) {
32615:         /* An object in ctor.prototype, let's use it as the new instance's proto. */
32615:         proto = JSVAL_TO_OBJECT(pval);
32615:     } else if (pval == JSVAL_HOLE) {
32615:         /* No ctor.prototype yet, inline and optimize fun_resolve's prototype code. */
40858:         proto = NewObject(cx, clasp, NULL, ctor->getParent());
32615:         if (!proto)
32615:             return NULL;
32615:         if (!js_SetClassPrototype(cx, ctor, proto, JSPROP_ENUMERATE | JSPROP_PERMANENT))
32615:             return NULL;
32615:     } else {
32615:         /* Primitive value in .prototype means we use Object.prototype for proto. */
32615:         if (!js_GetClassPrototype(cx, JSVAL_TO_OBJECT(ctor->fslots[JSSLOT_PARENT]),
38604:                                   JSProto_Object, &proto)) {
32615:             return NULL;
32615:         }
32615:     }
32615: 
32684:     return NewNativeObject(cx, clasp, proto, ctor->getParent(),
32684:                            JSObject::defaultPrivate(clasp));
32615: }
32615: 
39910: JS_DEFINE_CALLINFO_3(extern, CONSTRUCTOR_RETRY, js_NewInstance, CONTEXT, CLASS, OBJECT, 0,
39910:                      nanojit::ACC_STORE_ANY)
32615: 
32615: #else  /* !JS_TRACER */
32615: 
32615: # define js_Object_trcinfo NULL
32615: 
32615: #endif /* !JS_TRACER */
32615: 
    1: /*
23435:  * Given pc pointing after a property accessing bytecode, return true if the
23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
23435:  * checking whether document.all is defined.
23435:  */
30034: JS_REQUIRES_STACK JSBool
23435: Detecting(JSContext *cx, jsbytecode *pc)
23435: {
23435:     JSScript *script;
25474:     jsbytecode *endpc;
23435:     JSOp op;
23435:     JSAtom *atom;
23435: 
23435:     script = cx->fp->script;
25474:     endpc = script->code + script->length;
25215:     for (;; pc += js_CodeSpec[op].length) {
31814:         JS_ASSERT_IF(!cx->fp->imacpc, script->code <= pc && pc < endpc);
25474: 
23435:         /* General case: a branch or equality op follows the access. */
25215:         op = js_GetOpcode(cx, script, pc);
23435:         if (js_CodeSpec[op].format & JOF_DETECTING)
23435:             return JS_TRUE;
23435: 
23435:         switch (op) {
23435:           case JSOP_NULL:
23435:             /*
23435:              * Special case #1: handle (document.all == null).  Don't sweat
23435:              * about JS1.2's revision of the equality operators here.
23435:              */
25474:             if (++pc < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
25474:                 return *pc == JSOP_EQ || *pc == JSOP_NE;
25474:             }
25474:             return JS_FALSE;
23435: 
23435:           case JSOP_NAME:
23435:             /*
23435:              * Special case #2: handle (document.all == undefined).  Don't
23435:              * worry about someone redefining undefined, which was added by
23435:              * Edition 3, so is read/write for backward compatibility.
23435:              */
23435:             GET_ATOM_FROM_BYTECODE(script, pc, 0, atom);
25474:             if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
25474:                 (pc += js_CodeSpec[op].length) < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
23435:                 return op == JSOP_EQ || op == JSOP_NE ||
23435:                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
23435:             }
23435:             return JS_FALSE;
23435: 
23435:           default:
23435:             /*
23435:              * At this point, anything but an extended atom index prefix means
23435:              * we're not detecting.
23435:              */
23435:             if (!(js_CodeSpec[op].format & JOF_INDEXBASE))
23435:                 return JS_FALSE;
23435:             break;
23435:         }
23435:     }
23435: }
23435: 
23435: /*
23435:  * Infer lookup flags from the currently executing bytecode. This does
23435:  * not attempt to infer JSRESOLVE_WITH, because the current bytecode
23435:  * does not indicate whether we are in a with statement. Return defaultFlags
23435:  * if a currently executing bytecode cannot be determined.
23435:  */
30034: uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags)
23435: {
30035: #ifdef JS_TRACER
30034:     if (JS_ON_TRACE(cx))
30034:         return cx->bailExit->lookupFlags;
30035: #endif
30034: 
30034:     JS_ASSERT_NOT_ON_TRACE(cx);
30034: 
23435:     JSStackFrame *fp;
23435:     jsbytecode *pc;
23435:     const JSCodeSpec *cs;
23435:     uint32 format;
23435:     uintN flags = 0;
23435: 
23435:     fp = js_GetTopStackFrame(cx);
23435:     if (!fp || !fp->regs)
23435:         return defaultFlags;
23435:     pc = fp->regs->pc;
25215:     cs = &js_CodeSpec[js_GetOpcode(cx, fp->script, pc)];
23435:     format = cs->format;
23435:     if (JOF_MODE(format) != JOF_NAME)
23435:         flags |= JSRESOLVE_QUALIFIED;
23435:     if ((format & (JOF_SET | JOF_FOR)) ||
23435:         (fp->flags & JSFRAME_ASSIGNING)) {
23435:         flags |= JSRESOLVE_ASSIGNING;
32680:     } else if (cs->length >= 0) {
23435:         pc += cs->length;
25474:         if (pc < cx->fp->script->code + cx->fp->script->length && Detecting(cx, pc))
23435:             flags |= JSRESOLVE_DETECTING;
23435:     }
23435:     if (format & JOF_DECLARING)
23435:         flags |= JSRESOLVE_DECLARING;
23435:     return flags;
23435: }
23435: 
23435: /*
    1:  * ObjectOps and Class for with-statement stack objects.
    1:  */
    1: static JSBool
    1: with_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                     JSProperty **propp)
    1: {
23435:     /* Fixes bug 463997 */
23435:     uintN flags = cx->resolveFlags;
23435:     if (flags == JSRESOLVE_INFER)
30034:         flags = js_InferFlags(cx, flags);
23435:     flags |= JSRESOLVE_WITH;
23435:     JSAutoResolveFlags rf(cx, flags);
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_LookupProperty(cx, obj, id, objp, propp);
31501:     return proto->lookupProperty(cx, id, objp, propp);
    1: }
    1: 
    1: static JSBool
    1: with_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_GetProperty(cx, obj, id, vp);
31501:     return proto->getProperty(cx, id, vp);
    1: }
    1: 
    1: static JSBool
    1: with_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_SetProperty(cx, obj, id, vp);
31501:     return proto->setProperty(cx, id, vp);
    1: }
    1: 
    1: static JSBool
    1: with_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                    uintN *attrsp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_GetAttributes(cx, obj, id, prop, attrsp);
31501:     return proto->getAttributes(cx, id, prop, attrsp);
    1: }
    1: 
    1: static JSBool
    1: with_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                    uintN *attrsp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_SetAttributes(cx, obj, id, prop, attrsp);
31501:     return proto->setAttributes(cx, id, prop, attrsp);
    1: }
    1: 
    1: static JSBool
    1: with_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_DeleteProperty(cx, obj, id, rval);
31501:     return proto->deleteProperty(cx, id, rval);
    1: }
    1: 
    1: static JSBool
    1: with_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_DefaultValue(cx, obj, hint, vp);
31501:     return proto->defaultValue(cx, hint, vp);
    1: }
    1: 
    1: static JSBool
    1: with_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:                jsval *statep, jsid *idp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_Enumerate(cx, obj, enum_op, statep, idp);
31501:     return proto->enumerate(cx, enum_op, statep, idp);
    1: }
    1: 
    1: static JSBool
    1: with_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                  jsval *vp, uintN *attrsp)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return js_CheckAccess(cx, obj, id, mode, vp, attrsp);
31501:     return proto->checkAccess(cx, id, mode, vp, attrsp);
    1: }
    1: 
38633: static JSType
38633: with_TypeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
    1: static JSObject *
    1: with_ThisObject(JSContext *cx, JSObject *obj)
    1: {
39928:     JSObject *proto = obj->getProto();
    1:     if (!proto)
    1:         return obj;
31501:     return proto->thisObject(cx);
    1: }
    1: 
    1: JS_FRIEND_DATA(JSObjectOps) js_WithObjectOps = {
28353:     NULL,
    1:     with_LookupProperty,    js_DefineProperty,
    1:     with_GetProperty,       with_SetProperty,
    1:     with_GetAttributes,     with_SetAttributes,
    1:     with_DeleteProperty,    with_DefaultValue,
    1:     with_Enumerate,         with_CheckAccess,
38633:     with_TypeOf,            js_TraceObject,
    1:     with_ThisObject,        NATIVE_DROP_PROPERTY,
    1:     NULL,                   NULL,
38633:     NULL,                   js_Clear
    1: };
    1: 
    1: static JSObjectOps *
    1: with_getObjectOps(JSContext *cx, JSClass *clasp)
    1: {
    1:     return &js_WithObjectOps;
    1: }
    1: 
    1: JSClass js_WithClass = {
    1:     "With",
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   NULL,
    1:     with_getObjectOps,
    1:     0,0,0,0,0,0,0
    1: };
    1: 
22652: JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth)
    1: {
    1:     JSObject *obj;
    1: 
40858:     obj = NewObject(cx, &js_WithClass, proto, parent);
    1:     if (!obj)
    1:         return NULL;
31452:     obj->setPrivate(cx->fp);
    1:     OBJ_SET_BLOCK_DEPTH(cx, obj, depth);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_NewBlockObject(JSContext *cx)
    1: {
    1:     /*
    1:      * Null obj's proto slot so that Object.prototype.* does not pollute block
28093:      * scopes and to give the block object its own scope.
    1:      */
40858:     JSObject *blockObj = NewObjectWithGivenProto(cx, &js_BlockClass, NULL, NULL);
28093:     JS_ASSERT_IF(blockObj, !OBJ_IS_CLONED_BLOCK(blockObj));
28093:     return blockObj;
    1: }
    1: 
    1: JSObject *
30645: js_CloneBlockObject(JSContext *cx, JSObject *proto, JSStackFrame *fp)
    1: {
30645:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(proto));
40410:     JS_ASSERT(proto->getClass() == &js_BlockClass);
30645: 
33581:     JSObject *clone = js_NewGCObject(cx);
    1:     if (!clone)
    1:         return NULL;
30645: 
37766:     /* The caller sets parent on its own. */
37766:     clone->init(&js_BlockClass, proto, NULL, reinterpret_cast<jsval>(fp));
30645:     clone->fslots[JSSLOT_BLOCK_DEPTH] = proto->fslots[JSSLOT_BLOCK_DEPTH];
37766: 
37766:     JS_ASSERT(cx->runtime->emptyBlockScope->freeslot == JSSLOT_BLOCK_DEPTH + 1);
37766:     clone->map = cx->runtime->emptyBlockScope;
37766:     cx->runtime->emptyBlockScope->hold();
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(clone));
    1:     return clone;
    1: }
    1: 
22652: JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind)
    1: {
 3457:     JSStackFrame *fp;
11859:     JSObject *obj;
14860:     uintN depth, count;
14860: 
14860:     /* Blocks have one fixed slot available for the first local.*/
14860:     JS_STATIC_ASSERT(JS_INITIAL_NSLOTS == JSSLOT_BLOCK_DEPTH + 2);
 3457: 
11859:     fp = cx->fp;
11859:     obj = fp->scopeChain;
40826:     JS_ASSERT(obj->getClass() == &js_BlockClass);
32684:     JS_ASSERT(obj->getPrivate() == cx->fp);
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
14860: 
14860:     /*
14860:      * Block objects should never be exposed to scripts. Thus the clone should
14860:      * not own the property map and rather always share it with the prototype
40847:      * object. This allows us to skip updating obj->scope()->freeslot after
14860:      * we copy the stack slots into reserved slots.
14860:      */
40847:     JS_ASSERT(obj->scope()->object != obj);
14860: 
14860:     /* Block objects should not have reserved slots before they are put. */
40410:     JS_ASSERT(obj->numSlots() == JS_INITIAL_NSLOTS);
14860: 
14860:     /* The block and its locals must be on the current stack for GC safety. */
 3457:     depth = OBJ_BLOCK_DEPTH(cx, obj);
14860:     count = OBJ_BLOCK_COUNT(cx, obj);
16072:     JS_ASSERT(depth <= (size_t) (fp->regs->sp - StackBase(fp)));
16072:     JS_ASSERT(count <= (size_t) (fp->regs->sp - StackBase(fp) - depth));
14860: 
32725:     /* See comments in CheckDestructuring from jsparse.cpp. */
14860:     JS_ASSERT(count >= 1);
14860: 
16072:     depth += fp->script->nfixed;
16072:     obj->fslots[JSSLOT_BLOCK_DEPTH + 1] = fp->slots[depth];
14860:     if (normalUnwind && count > 1) {
14860:         --count;
14860:         JS_LOCK_OBJ(cx, obj);
40858:         if (!js_AllocSlots(cx, obj, JS_INITIAL_NSLOTS + count))
11758:             normalUnwind = JS_FALSE;
14860:         else
16072:             memcpy(obj->dslots, fp->slots + depth + 1, count * sizeof(jsval));
14860:         JS_UNLOCK_OBJ(cx, obj);
14860:     }
14860: 
11758:     /* We must clear the private slot even with errors. */
31452:     obj->setPrivate(NULL);
39930:     fp->scopeChain = obj->getParent();
11758:     return normalUnwind;
    1: }
    1: 
    1: static JSBool
    1: block_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
32717:     /*
32717:      * Block objects are never exposed to script, and the engine handles them
32717:      * with care. So unlike other getters, this one can assert (rather than
32717:      * check) certain invariants about obj.
32717:      */
32717:     JS_ASSERT(obj->getClass() == &js_BlockClass);
14860:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
32717:     uintN index = (uintN) JSVAL_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
31452:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
14860:     if (fp) {
16072:         index += fp->script->nfixed + OBJ_BLOCK_DEPTH(cx, obj);
16072:         JS_ASSERT(index < fp->script->nslots);
16072:         *vp = fp->slots[index];
32717:         return true;
32717:     }
32717: 
32717:     /* Values are in reserved slots immediately following DEPTH. */
32717:     uint32 slot = JSSLOT_BLOCK_DEPTH + 1 + index;
32717:     JS_LOCK_OBJ(cx, obj);
40410:     JS_ASSERT(slot < obj->numSlots());
40410:     *vp = obj->getSlot(slot);
32717:     JS_UNLOCK_OBJ(cx, obj);
32717:     return true;
14860: }
14860: 
14860: static JSBool
14860: block_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
14860: {
32717:     JS_ASSERT(obj->getClass() == &js_BlockClass);
32717:     JS_ASSERT(OBJ_IS_CLONED_BLOCK(obj));
32717:     uintN index = (uintN) JSVAL_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
31452:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
14860:     if (fp) {
16072:         index += fp->script->nfixed + OBJ_BLOCK_DEPTH(cx, obj);
16072:         JS_ASSERT(index < fp->script->nslots);
16072:         fp->slots[index] = *vp;
32717:         return true;
32717:     }
32717: 
32717:     /* Values are in reserved slots immediately following DEPTH. */
32717:     uint32 slot = JSSLOT_BLOCK_DEPTH + 1 + index;
32717:     JS_LOCK_OBJ(cx, obj);
40410:     JS_ASSERT(slot < obj->numSlots());
40410:     obj->setSlot(slot, *vp);
32717:     JS_UNLOCK_OBJ(cx, obj);
32717:     return true;
32717: }
32717: 
32717: JSBool
33166: js_DefineBlockVariable(JSContext *cx, JSObject *obj, jsid id, intN index)
32717: {
32717:     JS_ASSERT(obj->getClass() == &js_BlockClass);
32717:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(obj));
32717: 
32717:     /* Use JSPROP_ENUMERATE to aid the disassembler. */
32717:     return js_DefineNativeProperty(cx, obj, id, JSVAL_VOID,
32717:                                    block_getProperty, block_setProperty,
32717:                                    JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_SHARED,
38562:                                    JSScopeProperty::HAS_SHORTID, index, NULL);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
 3235: #define NO_PARENT_INDEX ((uint32)-1)
 3235: 
 3235: uint32
 3235: FindObjectIndex(JSObjectArray *array, JSObject *obj)
    1: {
    1:     size_t i;
 3235: 
 3235:     if (array) {
 3235:         i = array->length;
 3235:         do {
 3235: 
 3235:             if (array->vector[--i] == obj)
    1:                 return i;
 3235:         } while (i != 0);
    1:     }
    1: 
    1:     return NO_PARENT_INDEX;
    1: }
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
 3235:     uint32 parentId;
    1:     JSObject *obj, *parent;
    1:     uint16 depth, count, i;
    1:     uint32 tmp;
    1:     JSScopeProperty *sprop;
    1:     jsid propid;
    1:     JSAtom *atom;
    1:     int16 shortid;
    1:     JSBool ok;
    1: 
    1:     cx = xdr->cx;
    1: #ifdef __GNUC__
    1:     obj = NULL;         /* quell GCC overwarning */
    1: #endif
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         obj = *objp;
39930:         parent = obj->getParent();
 3235:         parentId = (xdr->script->objectsOffset == 0)
 3235:                    ? NO_PARENT_INDEX
32723:                    : FindObjectIndex(xdr->script->objects(), parent);
 2531:         depth = (uint16)OBJ_BLOCK_DEPTH(cx, obj);
 2531:         count = (uint16)OBJ_BLOCK_COUNT(cx, obj);
    1:         tmp = (uint32)(depth << 16) | count;
    1:     }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     else count = 0;
    1: #endif
    1: 
    1:     /* First, XDR the parent atomid. */
    1:     if (!JS_XDRUint32(xdr, &parentId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         obj = js_NewBlockObject(cx);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *objp = obj;
    1: 
    1:         /*
    1:          * If there's a parent id, then get the parent out of our script's
 3235:          * object array. We know that we XDR block object in outer-to-inner
 3235:          * order, which means that getting the parent now will work.
    1:          */
 3235:         if (parentId == NO_PARENT_INDEX)
    1:             parent = NULL;
 3235:         else
32723:             parent = xdr->script->getObject(parentId);
39930:         obj->setParent(parent);
    1:     }
    1: 
40388:     AutoValueRooter tvr(cx, obj);
33178: 
33178:     if (!JS_XDRUint32(xdr, &tmp))
33178:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         depth = (uint16)(tmp >> 16);
    1:         count = (uint16)tmp;
40410:         obj->setSlot(JSSLOT_BLOCK_DEPTH, INT_TO_JSVAL(depth));
    1:     }
    1: 
    1:     /*
    1:      * XDR the block object's properties. We know that there are 'count'
    1:      * properties to XDR, stored as id/shortid pairs. We do not XDR any
    1:      * non-native properties, only those that the compiler created.
    1:      */
    1:     sprop = NULL;
    1:     ok = JS_TRUE;
    1:     for (i = 0; i < count; i++) {
    1:         if (xdr->mode == JSXDR_ENCODE) {
    1:             /* Find a property to XDR. */
    1:             do {
    1:                 /* If sprop is NULL, this is the first property. */
40847:                 sprop = sprop ? sprop->parent : obj->scope()->lastProperty();
38562:             } while (!sprop->hasShortID());
    1: 
39894:             JS_ASSERT(sprop->getter() == block_getProperty);
    1:             propid = sprop->id;
    1:             JS_ASSERT(JSID_IS_ATOM(propid));
    1:             atom = JSID_TO_ATOM(propid);
    1:             shortid = sprop->shortid;
    1:             JS_ASSERT(shortid >= 0);
    1:         }
    1: 
    1:         /* XDR the real id, then the shortid. */
    1:         if (!js_XDRStringAtom(xdr, &atom) ||
    1:             !JS_XDRUint16(xdr, (uint16 *)&shortid)) {
33178:             return false;
    1:         }
    1: 
    1:         if (xdr->mode == JSXDR_DECODE) {
33178:             if (!js_DefineBlockVariable(cx, obj, ATOM_TO_JSID(atom), shortid))
33178:                 return false;
    1:         }
    1:     }
33178:     return true;
    1: }
    1: 
    1: #endif
    1: 
14860: static uint32
14860: block_reserveSlots(JSContext *cx, JSObject *obj)
14860: {
14860:     return OBJ_IS_CLONED_BLOCK(obj) ? OBJ_BLOCK_COUNT(cx, obj) : 0;
14860: }
14860: 
    1: JSClass js_BlockClass = {
    1:     "Block",
28093:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
32717:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,   JS_PropertyStub,
30654:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,    NULL,
28093:     NULL, NULL, NULL, NULL, NULL, NULL, NULL, block_reserveSlots
    1: };
    1: 
    1: JSObject *
14322: js_InitEval(JSContext *cx, JSObject *obj)
    1: {
 2112:     /* ECMA (15.1.2.1) says 'eval' is a property of the global object. */
 2112:     if (!js_DefineFunction(cx, obj, cx->runtime->atomState.evalAtom,
38586:                            (JSNative)obj_eval, 1,
38586:                            JSFUN_FAST_NATIVE | JSFUN_STUB_GSOPS)) {
    1:         return NULL;
    1:     }
    1: 
14322:     return obj;
14322: }
14322: 
14322: JSObject *
14322: js_InitObjectClass(JSContext *cx, JSObject *obj)
14322: {
25897:     return js_InitClass(cx, obj, NULL, &js_ObjectClass, js_Object, 1,
28086:                         object_props, object_methods, NULL, object_static_methods);
    1: }
    1: 
25897: JSObject *
25897: js_InitClass(JSContext *cx, JSObject *obj, JSObject *parent_proto,
25897:              JSClass *clasp, JSNative constructor, uintN nargs,
25897:              JSPropertySpec *ps, JSFunctionSpec *fs,
28086:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
25897: {
25897:     JSAtom *atom;
25897:     JSProtoKey key;
25897:     JSObject *proto, *ctor;
25897:     jsval cval, rval;
25897:     JSBool named;
25897:     JSFunction *fun;
25897: 
25897:     atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
25897:     if (!atom)
25897:         return NULL;
25897: 
25897:     /*
25897:      * When initializing a standard class, if no parent_proto (grand-proto of
25897:      * instances of the class, parent-proto of the class's prototype object)
25897:      * is given, we must use Object.prototype if it is available.  Otherwise,
25897:      * we could look up the wrong binding for a class name in obj.  Example:
25897:      *
25897:      *   String = Array;
25897:      *   print("hi there".join);
25897:      *
25897:      * should print undefined, not Array.prototype.join.  This is required by
25897:      * ECMA-262, alas.  It might have been better to make String readonly and
25897:      * permanent in the global object, instead -- but that's too big a change
25897:      * to swallow at this point.
25897:      */
25897:     key = JSCLASS_CACHED_PROTO_KEY(clasp);
25897:     if (key != JSProto_Null &&
25897:         !parent_proto &&
38604:         !js_GetClassPrototype(cx, obj, JSProto_Object, &parent_proto)) {
25897:         return NULL;
25897:     }
25897: 
25897:     /* Create a prototype object for this class. */
40858:     proto = NewObject(cx, clasp, parent_proto, obj);
25897:     if (!proto)
25897:         return NULL;
25897: 
25897:     /* After this point, control must exit via label bad or out. */
40388:     AutoValueRooter tvr(cx, proto);
25897: 
25897:     if (!constructor) {
25897:         /*
25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
25897:          * of obj (the global object) is has a reserved slot indexed by key;
25897:          * and (c) key is not the null key.
25897:          */
25897:         if ((clasp->flags & JSCLASS_IS_ANONYMOUS) &&
40826:             (obj->getClass()->flags & JSCLASS_IS_GLOBAL) &&
25897:             key != JSProto_Null) {
25897:             named = JS_FALSE;
25897:         } else {
31501:             named = obj->defineProperty(cx, ATOM_TO_JSID(atom),
25897:                                         OBJECT_TO_JSVAL(proto),
25897:                                         JS_PropertyStub, JS_PropertyStub,
25897:                                         (clasp->flags & JSCLASS_IS_ANONYMOUS)
25897:                                         ? JSPROP_READONLY | JSPROP_PERMANENT
32573:                                         : 0);
25897:             if (!named)
25897:                 goto bad;
25897:         }
25897: 
25897:         ctor = proto;
25897:     } else {
25897:         /* Define the constructor function in obj's scope. */
25897:         fun = js_DefineFunction(cx, obj, atom, constructor, nargs,
25897:                                 JSFUN_STUB_GSOPS);
25897:         named = (fun != NULL);
25897:         if (!fun)
25897:             goto bad;
25897: 
25897:         /*
25897:          * Remember the class this function is a constructor for so that
25897:          * we know to create an object of this class when we call the
25897:          * constructor.
25897:          */
25897:         FUN_CLASP(fun) = clasp;
25897: 
25897:         /*
25897:          * Optionally construct the prototype object, before the class has
25897:          * been fully initialized.  Allow the ctor to replace proto with a
25897:          * different object, as is done for operator new -- and as at least
25897:          * XML support requires.
25897:          */
25897:         ctor = FUN_OBJECT(fun);
25897:         if (clasp->flags & JSCLASS_CONSTRUCT_PROTOTYPE) {
25897:             cval = OBJECT_TO_JSVAL(ctor);
25897:             if (!js_InternalConstruct(cx, proto, cval, 0, NULL, &rval))
25897:                 goto bad;
25897:             if (!JSVAL_IS_PRIMITIVE(rval) && JSVAL_TO_OBJECT(rval) != proto)
25897:                 proto = JSVAL_TO_OBJECT(rval);
25897:         }
25897: 
25897:         /* Connect constructor and prototype by named properties. */
25897:         if (!js_SetClassPrototype(cx, ctor, proto,
25897:                                   JSPROP_READONLY | JSPROP_PERMANENT)) {
25897:             goto bad;
25897:         }
25897: 
25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
40826:         if (ctor->getClass() == clasp)
39928:             ctor->setProto(proto);
25897:     }
25897: 
25897:     /* Add properties and methods to the prototype and the constructor. */
25897:     if ((ps && !JS_DefineProperties(cx, proto, ps)) ||
25897:         (fs && !JS_DefineFunctions(cx, proto, fs)) ||
25897:         (static_ps && !JS_DefineProperties(cx, ctor, static_ps)) ||
25897:         (static_fs && !JS_DefineFunctions(cx, ctor, static_fs))) {
25897:         goto bad;
25897:     }
25897: 
35117:     /*
35117:      * Make sure proto's scope's emptyScope is available to be shared by
35117:      * objects of this class.  JSScope::emptyScope is a one-slot cache. If we
35117:      * omit this, some other class could snap it up. (The risk is particularly
35117:      * great for Object.prototype.)
35117:      *
35117:      * All callers of JSObject::initSharingEmptyScope depend on this.
35117:      */
40847:     if (!proto->scope()->ensureEmptyScope(cx, clasp))
35117:         goto bad;
35117: 
25897:     /* If this is a standard class, cache its prototype. */
25897:     if (key != JSProto_Null && !js_SetClassObject(cx, obj, key, ctor))
25897:         goto bad;
25897: 
25897: out:
25897:     return proto;
25897: 
25897: bad:
25897:     if (named)
31501:         (void) obj->deleteProperty(cx, ATOM_TO_JSID(atom), &rval);
25897:     proto = NULL;
25897:     goto out;
25897: }
25897: 
    1: #define SLOTS_TO_DYNAMIC_WORDS(nslots)                                        \
    1:   (JS_ASSERT((nslots) > JS_INITIAL_NSLOTS), (nslots) + 1 - JS_INITIAL_NSLOTS)
    1: 
    1: #define DYNAMIC_WORDS_TO_SLOTS(words)                                         \
    1:   (JS_ASSERT((words) > 1), (words) - 1 + JS_INITIAL_NSLOTS)
    1: 
30454: 
40858: bool
40858: js_AllocSlots(JSContext *cx, JSObject *obj, size_t nslots)
    1: {
35057:     JS_ASSERT(!obj->dslots);
30454:     JS_ASSERT(nslots > JS_INITIAL_NSLOTS);
30454: 
30454:     jsval* slots;
30851:     slots = (jsval*) cx->malloc(SLOTS_TO_DYNAMIC_WORDS(nslots) * sizeof(jsval));
30454:     if (!slots)
41117:         return false;
30454: 
30454:     *slots++ = nslots;
30454:     /* clear the newly allocated cells. */
30454:     for (jsuint n = JS_INITIAL_NSLOTS; n < nslots; ++n)
30454:         slots[n - JS_INITIAL_NSLOTS] = JSVAL_VOID;
30454:     obj->dslots = slots;
30454: 
30454:     return true;
30454: }
30454: 
30454: bool
30454: js_GrowSlots(JSContext *cx, JSObject *obj, size_t nslots)
30454: {
    1:     /*
    1:      * Minimal number of dynamic slots to allocate.
    1:      */
30454:     const size_t MIN_DYNAMIC_WORDS = 4;
    1: 
    1:     /*
    1:      * The limit to switch to linear allocation strategy from the power of 2
    1:      * growth no to waste too much memory.
    1:      */
30454:     const size_t LINEAR_GROWTH_STEP = JS_BIT(16);
30454: 
30454:     /* If we are allocating fslots, there is nothing to do. */
30454:     if (nslots <= JS_INITIAL_NSLOTS)
    1:         return JS_TRUE;
30454: 
30454:     size_t nwords = SLOTS_TO_DYNAMIC_WORDS(nslots);
30454: 
    1:     /*
    1:      * Round up nslots so the number of bytes in dslots array is power
    1:      * of 2 to ensure exponential grouth.
    1:      */
30454:     uintN log;
    1:     if (nwords <= MIN_DYNAMIC_WORDS) {
    1:         nwords = MIN_DYNAMIC_WORDS;
    1:     } else if (nwords < LINEAR_GROWTH_STEP) {
    1:         JS_CEILING_LOG2(log, nwords);
    1:         nwords = JS_BIT(log);
    1:     } else {
    1:         nwords = JS_ROUNDUP(nwords, LINEAR_GROWTH_STEP);
    1:     }
30454:     nslots = DYNAMIC_WORDS_TO_SLOTS(nwords);
30454: 
30454:     /*
30454:      * If nothing was allocated yet, treat it as initial allocation (but with
30454:      * the exponential growth algorithm applied).
30454:      */
35057:     jsval* slots = obj->dslots;
    1:     if (!slots)
40858:         return js_AllocSlots(cx, obj, nslots);
30454: 
30454:     size_t oslots = size_t(slots[-1]);
30454: 
30851:     slots = (jsval*) cx->realloc(slots - 1, nwords * sizeof(jsval));
41117:     if (!slots)
41117:         return false;
41117: 
30454:     *slots++ = nslots;
30454:     obj->dslots = slots;
30454: 
30454:     /* Initialize the additional slots we added. */
30454:     JS_ASSERT(nslots > oslots);
30454:     for (size_t i = oslots; i < nslots; i++)
30454:         slots[i - JS_INITIAL_NSLOTS] = JSVAL_VOID;
30454: 
30454:     return true;
30454: }
30454: 
30454: void
30454: js_ShrinkSlots(JSContext *cx, JSObject *obj, size_t nslots)
30454: {
35057:     jsval* slots = obj->dslots;
30454: 
30454:     /* Nothing to shrink? */
30454:     if (!slots)
30454:         return;
30454: 
30454:     JS_ASSERT(size_t(slots[-1]) > JS_INITIAL_NSLOTS);
30454:     JS_ASSERT(nslots <= size_t(slots[-1]));
30454: 
30454:     if (nslots <= JS_INITIAL_NSLOTS) {
36997:         obj->freeSlotsArray(cx);
35057:         obj->dslots = NULL;
    1:     } else {
30454:         size_t nwords = SLOTS_TO_DYNAMIC_WORDS(nslots);
30851:         slots = (jsval*) cx->realloc(slots - 1, nwords * sizeof(jsval));
41117:         if (!slots)
41117:             return;  /* Leave obj->dslots at its old size. */
30454:         *slots++ = nslots;
    1:         obj->dslots = slots;
30454:     }
    1: }
    1: 
30732: bool
30732: js_EnsureReservedSlots(JSContext *cx, JSObject *obj, size_t nreserved)
30732: {
40430:     JS_ASSERT(obj->isNative());
35057:     JS_ASSERT(!obj->dslots);
30732: 
40410:     uintN nslots = JSSLOT_FREE(obj->getClass()) + nreserved;
40858:     if (nslots > obj->numSlots() && !js_AllocSlots(cx, obj, nslots))
30732:         return false;
30732: 
40847:     JSScope *scope = obj->scope();
37766:     if (!scope->isSharedEmpty()) {
30732: #ifdef JS_THREADSAFE
30732:         JS_ASSERT(scope->title.ownercx->thread == cx->thread);
30732: #endif
40410:         JS_ASSERT(scope->freeslot == JSSLOT_FREE(obj->getClass()));
30732:         if (scope->freeslot < nslots)
30732:             scope->freeslot = nslots;
30732:     }
30732:     return true;
30732: }
30732: 
 3164: JS_BEGIN_EXTERN_C
 3164: 
18907: static JSObject *
    1: js_InitNullClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: static JSObjectOp lazy_prototype_init[JSProto_LIMIT] = {
    1: #define JS_PROTO(name,code,init) init,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: };
    1: 
 3164: JS_END_EXTERN_C
 3164: 
    1: JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
    1:     JSBool ok;
    1:     JSObject *tmp, *cobj;
    1:     JSResolvingKey rkey;
    1:     JSResolvingEntry *rentry;
    1:     uint32 generation;
    1:     JSObjectOp init;
    1:     jsval v;
    1: 
39930:     while ((tmp = obj->getParent()) != NULL)
    1:         obj = tmp;
40826:     if (!(obj->getClass()->flags & JSCLASS_IS_GLOBAL)) {
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     ok = JS_GetReservedSlot(cx, obj, key, &v);
    1:     if (!ok)
    1:         return JS_FALSE;
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         *objp = JSVAL_TO_OBJECT(v);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     rkey.obj = obj;
    1:     rkey.id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
    1:     if (!js_StartResolving(cx, &rkey, JSRESFLAG_LOOKUP, &rentry))
    1:         return JS_FALSE;
    1:     if (!rentry) {
    1:         /* Already caching key in obj -- suppress recursion. */
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     generation = cx->resolvingTable->generation;
    1: 
    1:     cobj = NULL;
    1:     init = lazy_prototype_init[key];
    1:     if (init) {
    1:         if (!init(cx, obj)) {
    1:             ok = JS_FALSE;
    1:         } else {
    1:             ok = JS_GetReservedSlot(cx, obj, key, &v);
    1:             if (ok && !JSVAL_IS_PRIMITIVE(v))
    1:                 cobj = JSVAL_TO_OBJECT(v);
    1:         }
    1:     }
    1: 
    1:     js_StopResolving(cx, &rkey, JSRESFLAG_LOOKUP, rentry, generation);
    1:     *objp = cobj;
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj)
    1: {
39930:     JS_ASSERT(!obj->getParent());
40826:     if (!(obj->getClass()->flags & JSCLASS_IS_GLOBAL))
    1:         return JS_TRUE;
    1: 
    1:     return JS_SetReservedSlot(cx, obj, key, OBJECT_TO_JSVAL(cobj));
    1: }
    1: 
    1: JSBool
38604: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey protoKey,
38604:                    jsval *vp, JSClass *clasp)
    1: {
22652:     JSStackFrame *fp;
    1:     JSObject *obj, *cobj, *pobj;
38604:     jsid id;
    1:     JSProperty *prop;
 8893:     jsval v;
    1:     JSScopeProperty *sprop;
    1: 
22652:     /*
22652:      * Find the global object. Use cx->fp directly to avoid falling off
22652:      * trace; all JIT-elided stack frames have the same global object as
22652:      * cx->fp.
22652:      */
22652:     VOUCH_DOES_NOT_REQUIRE_STACK();
22652:     if (!start && (fp = cx->fp) != NULL)
22652:         start = fp->scopeChain;
22652: 
22652:     if (start) {
    1:         /* Find the topmost object in the scope chain. */
    1:         do {
    1:             obj = start;
39930:             start = obj->getParent();
    1:         } while (start);
    1:     } else {
    1:         obj = cx->globalObject;
    1:         if (!obj) {
    1:             *vp = JSVAL_VOID;
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, obj);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
38604:     if (protoKey != JSProto_Null) {
38604:         JS_ASSERT(JSProto_Null < protoKey);
38604:         JS_ASSERT(protoKey < JSProto_LIMIT);
38604:         if (!js_GetClassObject(cx, obj, protoKey, &cobj))
    1:             return JS_FALSE;
    1:         if (cobj) {
    1:             *vp = OBJECT_TO_JSVAL(cobj);
    1:             return JS_TRUE;
    1:         }
38604:         id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[protoKey]);
38604:     } else {
38604:         JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
38604:         if (!atom)
38604:             return false;
38604:         id = ATOM_TO_JSID(atom);
    1:     }
    1: 
40430:     JS_ASSERT(obj->isNative());
10217:     if (js_LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_CLASSNAME,
10217:                                    &pobj, &prop) < 0) {
    1:         return JS_FALSE;
    1:     }
 8893:     v = JSVAL_VOID;
 8893:     if (prop)  {
40430:         if (pobj->isNative()) {
    1:             sprop = (JSScopeProperty *) prop;
40847:             if (SPROP_HAS_VALID_SLOT(sprop, pobj->scope())) {
40847:                 v = pobj->lockedGetSlot(sprop->slot);
 8893:                 if (JSVAL_IS_PRIMITIVE(v))
 8893:                     v = JSVAL_VOID;
 8893:             }
 8893:         }
31501:         pobj->dropProperty(cx, prop);
 8893:     }
 8893:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_ConstructObject(JSContext *cx, JSClass *clasp, JSObject *proto,
    1:                    JSObject *parent, uintN argc, jsval *argv)
    1: {
    1:     jsval cval, rval;
    1:     JSObject *obj, *ctor;
    1: 
40388:     AutoArrayRooter argtvr(cx, argc, argv);
    1: 
38604:     JSProtoKey protoKey = GetClassProtoKey(clasp);
38604:     if (!js_FindClassObject(cx, parent, protoKey, &cval, clasp))
    1:         return NULL;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(cval)) {
    1:         js_ReportIsNotFunction(cx, &cval, JSV2F_CONSTRUCT | JSV2F_SEARCH_STACK);
    1:         return NULL;
    1:     }
    1: 
33178:     /* Protect cval in case a crazy getter for .prototype uproots it. */
40388:     AutoValueRooter tvr(cx, cval);
    1: 
    1:     /*
    1:      * If proto or parent are NULL, set them to Constructor.prototype and/or
    1:      * Constructor.__parent__, just like JSOP_NEW does.
    1:      */
    1:     ctor = JSVAL_TO_OBJECT(cval);
    1:     if (!parent)
39930:         parent = ctor->getParent();
    1:     if (!proto) {
31501:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
    1:                                &rval)) {
33178:             return NULL;
    1:         }
    1:         if (JSVAL_IS_OBJECT(rval))
    1:             proto = JSVAL_TO_OBJECT(rval);
    1:     }
    1: 
40858:     obj = NewObject(cx, clasp, proto, parent);
    1:     if (!obj)
33178:         return NULL;
    1: 
    1:     if (!js_InternalConstruct(cx, obj, cval, argc, argv, &rval))
33178:         return NULL;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(rval))
33178:         return obj;
    1: 
    1:     /*
    1:      * If the instance's class differs from what was requested, throw a type
    1:      * error.  If the given class has both the JSCLASS_HAS_PRIVATE and the
    1:      * JSCLASS_CONSTRUCT_PROTOTYPE flags, and the instance does not have its
    1:      * private data set at this point, then the constructor was replaced and
    1:      * we should throw a type error.
    1:      */
33178:     obj = JSVAL_TO_OBJECT(rval);
40826:     if (obj->getClass() != clasp ||
    1:         (!(~clasp->flags & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_CONSTRUCT_PROTOTYPE)) &&
31452:          !obj->getPrivate())) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_WRONG_CONSTRUCTOR, clasp->name);
33178:         return NULL;
33178:     }
    1:     return obj;
    1: }
    1: 
36435: /*
36447:  * FIXME bug 535629: If one adds props, deletes earlier props, adds more, the
36447:  * last added won't recycle the deleted props' slots.
36435:  */
    1: JSBool
    1: js_AllocSlot(JSContext *cx, JSObject *obj, uint32 *slotp)
    1: {
40847:     JSScope *scope = obj->scope();
36435:     JS_ASSERT(scope->object == obj);
36435: 
32603:     JSClass *clasp = obj->getClass();
28353:     if (scope->freeslot == JSSLOT_FREE(clasp) && clasp->reserveSlots) {
28353:         /* Adjust scope->freeslot to include computed reserved slots, if any. */
28353:         scope->freeslot += clasp->reserveSlots(cx, obj);
28353:     }
28353: 
40410:     if (scope->freeslot >= obj->numSlots() &&
30454:         !js_GrowSlots(cx, obj, scope->freeslot + 1)) {
    1:         return JS_FALSE;
    1:     }
    1: 
14860:     /* js_ReallocSlots or js_FreeSlot should set the free slots to void. */
40410:     JS_ASSERT(JSVAL_IS_VOID(obj->getSlot(scope->freeslot)));
28353:     *slotp = scope->freeslot++;
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_FreeSlot(JSContext *cx, JSObject *obj, uint32 slot)
    1: {
40847:     JSScope *scope = obj->scope();
36435:     JS_ASSERT(scope->object == obj);
40847:     obj->lockedSetSlot(slot, JSVAL_VOID);
30454:     if (scope->freeslot == slot + 1)
28353:         scope->freeslot = slot;
    1: }
    1: 
30270: 
30270: /* JSVAL_INT_MAX as a string */
30270: #define JSVAL_INT_MAX_STRING "1073741823"
30270: 
30270: /*
30270:  * Convert string indexes that convert to int jsvals as ints to save memory.
30270:  * Care must be taken to use this macro every time a property name is used, or
30270:  * else double-sets, incorrect property cache misses, or other mistakes could
30270:  * occur.
30270:  */
11524: jsid
30270: js_CheckForStringIndex(jsid id)
    1: {
30270:     if (!JSID_IS_ATOM(id))
30270:         return id;
30270: 
30270:     JSAtom *atom = JSID_TO_ATOM(id);
30270:     JSString *str = ATOM_TO_STRING(atom);
30270:     const jschar *s = str->flatChars();
30270:     jschar ch = *s;
30270: 
30270:     JSBool negative = (ch == '-');
30270:     if (negative)
30270:         ch = *++s;
30270: 
30270:     if (!JS7_ISDEC(ch))
30270:         return id;
30270: 
30270:     size_t n = str->flatLength() - negative;
30270:     if (n > sizeof(JSVAL_INT_MAX_STRING) - 1)
30270:         return id;
30270: 
30270:     const jschar *cp = s;
30270:     const jschar *end = s + n;
30270: 
    1:     jsuint index = JS7_UNDEC(*cp++);
    1:     jsuint oldIndex = 0;
    1:     jsuint c = 0;
    1: 
    1:     if (index != 0) {
    1:         while (JS7_ISDEC(*cp)) {
    1:             oldIndex = index;
    1:             c = JS7_UNDEC(*cp);
    1:             index = 10 * index + c;
    1:             cp++;
    1:         }
    1:     }
22608: 
22608:     /*
22608:      * Non-integer indexes can't be represented as integers.  Also, distinguish
22608:      * index "-0" from "0", because JSVAL_INT cannot.
22608:      */
22608:     if (cp != end || (negative && index == 0))
22608:         return id;
30270: 
22608:     if (oldIndex < JSVAL_INT_MAX / 10 ||
22608:         (oldIndex == JSVAL_INT_MAX / 10 && c <= (JSVAL_INT_MAX % 10))) {
    1:         if (negative)
    1:             index = 0 - index;
    1:         id = INT_TO_JSID((jsint)index);
    1:     }
30270: 
    1:     return id;
    1: }
    1: 
    1: static JSBool
11377: PurgeProtoChain(JSContext *cx, JSObject *obj, jsid id)
    1: {
11377:     JSScope *scope;
11377:     JSScopeProperty *sprop;
11377: 
11377:     while (obj) {
40430:         if (!obj->isNative()) {
39928:             obj = obj->getProto();
11377:             continue;
11377:         }
11377:         JS_LOCK_OBJ(cx, obj);
40847:         scope = obj->scope();
30258:         sprop = scope->lookup(id);
11377:         if (sprop) {
18308:             PCMETER(JS_PROPERTY_CACHE(cx).pcpurges++);
30258:             scope->shadowingShapeChange(cx, sprop);
11377:             JS_UNLOCK_SCOPE(cx, scope);
27019: 
39930:             if (!obj->getParent()) {
27019:                 /*
27019:                  * All scope chains end in a global object, so this will change
27019:                  * the global shape. jstracer.cpp assumes that the global shape
27019:                  * never changes on trace, so we must deep-bail here.
27019:                  */
37741:                 LeaveTrace(cx);
27019:             }
11377:             return JS_TRUE;
11377:         }
32603:         obj = obj->getProto();
11377:         JS_UNLOCK_SCOPE(cx, scope);
11377:     }
    1:     return JS_FALSE;
11377: }
11377: 
25936: void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id)
    1: {
32603:     JS_ASSERT(obj->isDelegate());
32603:     PurgeProtoChain(cx, obj->getProto(), id);
28397: 
28397:     /*
28397:      * We must purge the scope chain only for Call objects as they are the only
28397:      * kind of cacheable non-global object that can gain properties after outer
28397:      * properties with the same names have been cached or traced. Call objects
28397:      * may gain such properties via eval introducing new vars; see bug 490364.
28397:      */
40410:     if (obj->getClass() == &js_CallClass) {
39930:         while ((obj = obj->getParent()) != NULL) {
11377:             if (PurgeProtoChain(cx, obj, id))
28397:                 break;
28397:         }
11377:     }
    1: }
    1: 
    1: JSScopeProperty *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
    1:                      JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid)
    1: {
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1: 
38562:     JS_ASSERT(!(flags & JSScopeProperty::METHOD));
32658: 
11377:     /*
11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
11377:      * this optimistically (assuming no failure below) before locking obj, so
11377:      * we can lock the shadowed scope.
11377:      */
25936:     js_PurgeScopeChain(cx, obj, id);
11377: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope) {
    1:         sprop = NULL;
    1:     } else {
11377:         /* Convert string indices to integers if appropriate. */
30270:         id = js_CheckForStringIndex(id);
35334:         sprop = scope->putProperty(cx, id, getter, setter, slot, attrs, flags, shortid);
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return sprop;
    1: }
    1: 
    1: JSScopeProperty *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
    1:                              JSScopeProperty *sprop, uintN attrs, uintN mask,
    1:                              JSPropertyOp getter, JSPropertyOp setter)
    1: {
    1:     JSScope *scope;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope) {
    1:         sprop = NULL;
    1:     } else {
35334:         sprop = scope->changeProperty(cx, sprop, attrs, mask, getter, setter);
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return sprop;
    1: }
    1: 
    1: JSBool
    1: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
32573:                   JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
    1: {
27932:     return js_DefineNativeProperty(cx, obj, id, value, getter, setter, attrs,
32573:                                    0, 0, NULL);
    1: }
    1: 
    1: /*
    1:  * Backward compatibility requires allowing addProperty hooks to mutate the
    1:  * nominal initial value of a slot-full property, while GC safety wants that
    1:  * value to be stored before the call-out through the hook.  Optimize to do
    1:  * both while saving cycles for classes that stub their addProperty hook.
    1:  */
32658: static inline bool
32658: AddPropertyHelper(JSContext *cx, JSClass *clasp, JSObject *obj, JSScope *scope,
32658:                   JSScopeProperty *sprop, jsval *vp)
32658: {
32658:     if (clasp->addProperty != JS_PropertyStub) {
32658:         jsval nominal = *vp;
32658: 
32658:         if (!clasp->addProperty(cx, obj, SPROP_USERID(sprop), vp))
32658:             return false;
32658:         if (*vp != nominal) {
32658:             if (SPROP_HAS_VALID_SLOT(sprop, scope))
40847:                 obj->lockedSetSlot(sprop->slot, *vp);
32658:         }
32658:     }
32658:     return true;
32658: }
    1: 
27932: JSBool
    1: js_DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
    1:                         JSPropertyOp getter, JSPropertyOp setter, uintN attrs,
24852:                         uintN flags, intN shortid, JSProperty **propp,
28397:                         uintN defineHow /* = 0 */)
    1: {
    1:     JSClass *clasp;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
30645:     JSBool added;
    1: 
32658:     JS_ASSERT((defineHow & ~(JSDNP_CACHE_RESULT | JSDNP_DONT_PURGE | JSDNP_SET_METHOD)) == 0);
37741:     LeaveTraceIfGlobalObject(cx, obj);
27492: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
    1: 
    1:     /*
    1:      * If defining a getter or setter, we must check for its counterpart and
    1:      * update the attributes and property ops.  A getter or setter is really
    1:      * only half of a property.
    1:      */
14646:     sprop = NULL;
    1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         JSObject *pobj;
    1:         JSProperty *prop;
    1: 
    1:         /*
    1:          * If JS_THREADSAFE and id is found, js_LookupProperty returns with
    1:          * sprop non-null and pobj locked.  If pobj == obj, the property is
    1:          * already in obj and obj has its own (mutable) scope.  So if we are
    1:          * defining a getter whose setter was already defined, or vice versa,
    1:          * finish the job via js_ChangeScopePropertyAttributes, and refresh
    1:          * the property cache line for (obj, id) to map sprop.
    1:          */
    1:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
27932:             return JS_FALSE;
    1:         sprop = (JSScopeProperty *) prop;
40265:         if (sprop && pobj == obj && sprop->isAccessorDescriptor()) {
40847:             sprop = obj->scope()->changeProperty(cx, sprop, attrs,
33152:                                                  JSPROP_GETTER | JSPROP_SETTER,
    1:                                                  (attrs & JSPROP_GETTER)
    1:                                                  ? getter
39894:                                                  : sprop->getter(),
    1:                                                  (attrs & JSPROP_SETTER)
    1:                                                  ? setter
39894:                                                  : sprop->setter());
    1: 
    1:             /* NB: obj == pobj, so we can share unlock code at the bottom. */
    1:             if (!sprop)
27934:                 goto error;
14646:         } else if (prop) {
31501:             /* NB: call JSObject::dropProperty, as pobj might not be native. */
31501:             pobj->dropProperty(cx, prop);
    1:             prop = NULL;
14646:             sprop = NULL;
    1:         }
    1:     }
    1: 
11377:     /*
28397:      * Purge the property cache of any properties named by id that are about
28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
28397:      * is not possible. We do this before locking obj to avoid nesting locks.
28312:      */
28397:     if (!(defineHow & JSDNP_DONT_PURGE))
28312:         js_PurgeScopeChain(cx, obj, id);
28312: 
28312:     /*
28312:      * Check whether a readonly property or setter is being defined on a known
28312:      * prototype object. See the comment in jscntxt.h before protoHazardShape's
28312:      * member declaration.
11377:      */
32603:     if (obj->isDelegate() && (attrs & (JSPROP_READONLY | JSPROP_SETTER)))
28312:         cx->runtime->protoHazardShape = js_GenerateShape(cx, false);
11377: 
    1:     /* Lock if object locking is required by this implementation. */
    1:     JS_LOCK_OBJ(cx, obj);
    1: 
    1:     /* Use the object's class getter and setter by default. */
32603:     clasp = obj->getClass();
32658:     if (!(defineHow & JSDNP_SET_METHOD)) {
41860:         if (!getter && !(attrs & JSPROP_GETTER))
    1:             getter = clasp->getProperty;
41860:         if (!setter && !(attrs & JSPROP_SETTER))
    1:             setter = clasp->setProperty;
32658:     }
    1: 
    1:     /* Get obj's own scope if it has one, or create a new one for obj. */
    1:     scope = js_GetMutableScope(cx, obj);
    1:     if (!scope)
27934:         goto error;
    1: 
27930:     added = false;
14646:     if (!sprop) {
18750:         /* Add a new property, or replace an existing one of the same id. */
32658:         if (defineHow & JSDNP_SET_METHOD) {
32658:             JS_ASSERT(clasp == &js_ObjectClass);
32658:             JS_ASSERT(VALUE_IS_FUNCTION(cx, value));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658:             JS_ASSERT(!getter && !setter);
32658: 
32658:             JSObject *funobj = JSVAL_TO_OBJECT(value);
32658:             if (FUN_OBJECT(GET_FUNCTION_PRIVATE(cx, funobj)) == funobj) {
38562:                 flags |= JSScopeProperty::METHOD;
41860:                 getter = CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
35334:         added = !scope->hasProperty(id);
41851:         uint32 oldShape = scope->shape;
35334:         sprop = scope->putProperty(cx, id, getter, setter, SPROP_INVALID_SLOT,
35334:                                    attrs, flags, shortid);
    1:         if (!sprop)
27934:             goto error;
41851: 
41851:         /*
41851:          * If sprop is a method, the above call to putProperty suffices to
41851:          * update the shape if necessary. But if scope->branded(), the shape
41851:          * may not have changed and we may be overwriting a function-valued
41851:          * property. See bug 560998.
41851:          */
41851:         if (scope->shape == oldShape && scope->branded())
41851:             scope->methodWriteBarrier(cx, sprop->slot, value);
14646:     }
    1: 
    1:     /* Store value before calling addProperty, in case the latter GC's. */
32568:     if (SPROP_HAS_VALID_SLOT(sprop, scope))
40847:         obj->lockedSetSlot(sprop->slot, value);
    1: 
    1:     /* XXXbe called with lock held */
32658:     if (!AddPropertyHelper(cx, clasp, obj, scope, sprop, &value)) {
35334:         scope->removeProperty(cx, id);
32658:         goto error;
32658:     }
    1: 
28397:     if (defineHow & JSDNP_CACHE_RESULT) {
24852:         JS_ASSERT_NOT_ON_TRACE(cx);
41855:         PropertyCacheEntry *entry =
40362:             JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, 0, obj, sprop, added);
41855:         TRACE_2(SetPropHit, entry, sprop);
24852:     }
    1:     if (propp)
    1:         *propp = (JSProperty *) sprop;
    1:     else
    1:         JS_UNLOCK_OBJ(cx, obj);
27932:     return JS_TRUE;
    1: 
27934: error: // TRACE_2 jumps here on error, as well.
    1:     JS_UNLOCK_OBJ(cx, obj);
27932:     return JS_FALSE;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                   JSProperty **propp)
    1: {
19712:     return js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                       objp, propp) >= 0;
10217: }
10217: 
16072: #define SCOPE_DEPTH_ACCUM(bs,val)                                             \
16072:     JS_SCOPE_DEPTH_METERING(JS_BASIC_STATS_ACCUM(bs, val))
10217: 
10217: int
    1: js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:                            JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *start, *obj2, *proto;
10217:     int protoIndex;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1:     JSClass *clasp;
    1:     JSResolveOp resolve;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
    1:     JSNewResolveOp newresolve;
    1:     JSBool ok;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     /* Search scopes starting with obj and following the prototype link. */
    1:     start = obj;
10217:     for (protoIndex = 0; ; protoIndex++) {
    1:         JS_LOCK_OBJ(cx, obj);
40847:         scope = obj->scope();
30258:         sprop = scope->lookup(id);
    1: 
    1:         /* Try obj's class resolve hook if id was not found in obj's scope. */
    1:         if (!sprop) {
32603:             clasp = obj->getClass();
    1:             resolve = clasp->resolve;
    1:             if (resolve != JS_ResolveStub) {
    1:                 /* Avoid recursion on (obj, id) already being resolved on cx. */
    1:                 key.obj = obj;
    1:                 key.id = id;
    1: 
    1:                 /*
    1:                  * Once we have successfully added an entry for (obj, key) to
    1:                  * cx->resolvingTable, control must go through cleanup: before
    1:                  * returning.  But note that JS_DHASH_ADD may find an existing
    1:                  * entry, in which case we bail to suppress runaway recursion.
    1:                  */
    1:                 if (!js_StartResolving(cx, &key, JSRESFLAG_LOOKUP, &entry)) {
    1:                     JS_UNLOCK_OBJ(cx, obj);
10217:                     return -1;
    1:                 }
    1:                 if (!entry) {
    1:                     /* Already resolving id in obj -- suppress recursion. */
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1:                     goto out;
    1:                 }
    1:                 generation = cx->resolvingTable->generation;
    1: 
    1:                 /* Null *propp here so we can test it at cleanup: safely. */
    1:                 *propp = NULL;
    1: 
    1:                 if (clasp->flags & JSCLASS_NEW_RESOLVE) {
    1:                     newresolve = (JSNewResolveOp)resolve;
23435:                     if (flags == JSRESOLVE_INFER)
30034:                         flags = js_InferFlags(cx, flags);
    1:                     obj2 = (clasp->flags & JSCLASS_NEW_RESOLVE_GETS_START)
    1:                            ? start
    1:                            : NULL;
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1: 
40840:                     {
    1:                         /* Protect id and all atoms from a GC nested in resolve. */
40840:                         AutoKeepAtoms keep(cx->runtime);
    1:                         ok = newresolve(cx, obj, ID_TO_VALUE(id), flags, &obj2);
40840:                     }
    1:                     if (!ok)
    1:                         goto cleanup;
    1: 
    1:                     JS_LOCK_OBJ(cx, obj);
    1:                     if (obj2) {
    1:                         /* Resolved: juggle locks and lookup id again. */
    1:                         if (obj2 != obj) {
    1:                             JS_UNLOCK_OBJ(cx, obj);
40430:                             if (obj2->isNative())
    1:                                 JS_LOCK_OBJ(cx, obj2);
    1:                         }
11377:                         protoIndex = 0;
11377:                         for (proto = start; proto && proto != obj2;
39928:                              proto = proto->getProto()) {
11377:                             protoIndex++;
11377:                         }
40430:                         if (!obj2->isNative()) {
    1:                             /* Whoops, newresolve handed back a foreign obj2. */
    1:                             JS_ASSERT(obj2 != obj);
31501:                             ok = obj2->lookupProperty(cx, id, objp, propp);
    1:                             if (!ok || *propp)
    1:                                 goto cleanup;
    1:                             JS_LOCK_OBJ(cx, obj2);
    1:                         } else {
    1:                             /*
    1:                              * Require that obj2 have its own scope now, as we
    1:                              * do for old-style resolve.  If it doesn't, then
    1:                              * id was not truly resolved, and we'll find it in
    1:                              * the proto chain, or miss it if obj2's proto is
    1:                              * not on obj's proto chain.  That last case is a
    1:                              * "too bad!" case.
    1:                              */
40847:                             scope = obj2->scope();
37766:                             if (!scope->isSharedEmpty())
30258:                                 sprop = scope->lookup(id);
    1:                         }
    1:                         if (sprop) {
40847:                             JS_ASSERT(scope == obj2->scope());
37766:                             JS_ASSERT(!scope->isSharedEmpty());
    1:                             obj = obj2;
    1:                         } else if (obj2 != obj) {
40430:                             if (obj2->isNative())
    1:                                 JS_UNLOCK_OBJ(cx, obj2);
    1:                             JS_LOCK_OBJ(cx, obj);
    1:                         }
    1:                     }
    1:                 } else {
    1:                     /*
    1:                      * Old resolve always requires id re-lookup if obj owns
    1:                      * its scope after resolve returns.
    1:                      */
    1:                     JS_UNLOCK_OBJ(cx, obj);
    1:                     ok = resolve(cx, obj, ID_TO_VALUE(id));
    1:                     if (!ok)
    1:                         goto cleanup;
    1:                     JS_LOCK_OBJ(cx, obj);
40430:                     JS_ASSERT(obj->isNative());
40847:                     scope = obj->scope();
37766:                     if (!scope->isSharedEmpty())
30258:                         sprop = scope->lookup(id);
    1:                 }
    1: 
    1:             cleanup:
    1:                 js_StopResolving(cx, &key, JSRESFLAG_LOOKUP, entry, generation);
10217:                 if (!ok)
10217:                     return -1;
10217:                 if (*propp)
10217:                     return protoIndex;
    1:             }
    1:         }
    1: 
    1:         if (sprop) {
10217:             SCOPE_DEPTH_ACCUM(&cx->runtime->protoLookupDepthStats, protoIndex);
40847:             JS_ASSERT(obj->scope() == scope);
30645:             *objp = obj;
    1: 
    1:             *propp = (JSProperty *) sprop;
10217:             return protoIndex;
    1:         }
    1: 
32603:         proto = obj->getProto();
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         if (!proto)
    1:             break;
40430:         if (!proto->isNative()) {
31501:             if (!proto->lookupProperty(cx, id, objp, propp))
10217:                 return -1;
12495:             return protoIndex + 1;
10217:         }
30645: 
30645:         /*
30645:          * Correctness elsewhere (the property cache and JIT), not here in
30645:          * particular, depends on all the objects on the prototype chain having
30645:          * different scopes. This is just a convenient place to check.
30645:          *
30645:          * Cloned Block objects do in fact share their prototype's scope -- but
30645:          * that is really just a memory-saving hack, safe because Blocks cannot
30645:          * be on the prototype chain of other objects.
30645:          */
40826:         JS_ASSERT_IF(obj->getClass() != &js_BlockClass,
40847:                      obj->scope() != proto->scope());
30645: 
    1:         obj = proto;
    1:     }
    1: 
    1: out:
    1:     *objp = NULL;
    1:     *propp = NULL;
10217:     return protoIndex;
10217: }
10217: 
40362: PropertyCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp)
    1: {
27539:     JSObject *scopeChain, *obj, *parent, *pobj;
40362:     PropertyCacheEntry *entry;
11377:     int scopeIndex, protoIndex;
    1:     JSProperty *prop;
27575: 
27575:     JS_ASSERT_IF(cacheResult, !JS_ON_TRACE(cx));
27539:     scopeChain = js_GetTopStackFrame(cx)->scopeChain;
27539: 
27539:     /* Scan entries on the scope chain that we can cache across. */
27575:     entry = JS_NO_PROP_CACHE_FILL;
27539:     obj = scopeChain;
39930:     parent = obj->getParent();
27539:     for (scopeIndex = 0;
27539:          parent
31467:          ? js_IsCacheableNonGlobalScope(obj)
27539:          : obj->map->ops->lookupProperty == js_LookupProperty;
27539:          ++scopeIndex) {
11377:         protoIndex =
19712:             js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                        &pobj, &prop);
21979:         if (protoIndex < 0)
27575:             return NULL;
27539: 
27539:         if (prop) {
27539: #ifdef DEBUG
27539:             if (parent) {
40826:                 JSClass *clasp = obj->getClass();
40430:                 JS_ASSERT(pobj->isNative());
40826:                 JS_ASSERT(pobj->getClass() == clasp);
27539:                 if (clasp == &js_BlockClass) {
27539:                     /*
37766:                      * A block instance on the scope chain is immutable and
37766:                      * the compile-time prototype provides all its properties.
27539:                      */
37766:                     JS_ASSERT(pobj == obj->getProto());
37766:                     JS_ASSERT(protoIndex == 1);
11377:                 } else {
27539:                     /* Call and DeclEnvClass objects have no prototypes. */
39928:                     JS_ASSERT(!obj->getProto());
27539:                     JS_ASSERT(protoIndex == 0);
27539:                 }
27539:             }
27539: #endif
27575:             if (cacheResult) {
40362:                 entry = JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, protoIndex, pobj,
40327:                                                    (JSScopeProperty *) prop);
27539:             }
36418:             SCOPE_DEPTH_ACCUM(&cx->runtime->scopeSearchDepthStats, scopeIndex);
27539:             goto out;
27539:         }
27539: 
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             goto out;
27539:         }
27539:         obj = parent;
39930:         parent = obj->getParent();
27539:     }
27539: 
27539:     for (;;) {
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
27575:             return NULL;
27539:         if (prop) {
11377:             PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
27539:             goto out;
27539:         }
27539: 
27539:         /*
27539:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we read parent here again.
27539:          */
39930:         parent = obj->getParent();
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             break;
27539:         }
27539:         obj = parent;
27539:     }
27539: 
27539:   out:
27539:     JS_ASSERT(!!pobj == !!prop);
    1:     *objp = obj;
    1:     *pobjp = pobj;
    1:     *propp = prop;
27575:     return entry;
    1: }
    1: 
    1: JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp)
    1: {
27575:     return !!js_FindPropertyHelper(cx, id, false, objp, pobjp, propp);
    1: }
    1: 
27319: JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id)
    1: {
27237:     /*
27237:      * This function should not be called for a global object or from the
27237:      * trace and should have a valid cache entry for native scopeChain.
27237:      */
39930:     JS_ASSERT(scopeChain->getParent());
27237:     JS_ASSERT(!JS_ON_TRACE(cx));
27237: 
27319:     JSObject *obj = scopeChain;
27319: 
27237:     /*
27319:      * Loop over cacheable objects on the scope chain until we find a
27319:      * property. We also stop when we reach the global object skipping any
27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
27319:      * js_Interpret.
41775:      *
41775:      * The test order here matters because js_IsCacheableNonGlobalScope
41775:      * must not be passed a global object (i.e. one with null parent).
27237:      */
41775:     for (int scopeIndex = 0;
41775:          !obj->getParent() || js_IsCacheableNonGlobalScope(obj);
41775:          scopeIndex++) {
27237:         JSObject *pobj;
27236:         JSProperty *prop;
27319:         int protoIndex = js_LookupPropertyWithFlags(cx, obj, id,
27319:                                                     cx->resolveFlags,
27237:                                                     &pobj, &prop);
27237:         if (protoIndex < 0)
27237:             return NULL;
27237:         if (prop) {
40430:             JS_ASSERT(pobj->isNative());
41775:             JS_ASSERT(!obj->getParent() ||
41775:                       pobj->getClass() == obj->getClass());
27575: #ifdef DEBUG
40362:             PropertyCacheEntry *entry =
27575: #endif
40362:                 JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, protoIndex, pobj,
40327:                                            (JSScopeProperty *) prop);
27575:             JS_ASSERT(entry);
27237:             JS_UNLOCK_OBJ(cx, pobj);
27237:             return obj;
27237:         }
27237: 
41775:         JSObject *parent = obj->getParent();
41775:         if (!parent)
27237:             return obj;
41775:         obj = parent;
27237:     }
27319: 
27319:     /* Loop until we find a property or reach the global object. */
27237:     do {
27237:         JSObject *pobj;
27237:         JSProperty *prop;
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return NULL;
    1:         if (prop) {
31501:             pobj->dropProperty(cx, prop);
27237:             break;
27237:         }
27319: 
27319:         /*
27319:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we must check if parent is
31501:          * not null here even if it wasn't before the lookup.
27319:          */
39930:         JSObject *parent = obj->getParent();
27319:         if (!parent)
27319:             break;
27237:         obj = parent;
39930:     } while (obj->getParent());
    1:     return obj;
    1: }
    1: 
    1: JSBool
    1: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj,
32658:              JSScopeProperty *sprop, uintN getHow, jsval *vp)
    1: {
37741:     LeaveTraceIfGlobalObject(cx, pobj);
27490: 
27490:     JSScope *scope;
27490:     uint32 slot;
27490:     int32 sample;
27490: 
40430:     JS_ASSERT(pobj->isNative());
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, pobj));
40847:     scope = pobj->scope();
27490: 
27490:     slot = sprop->slot;
27490:     *vp = (slot != SPROP_INVALID_SLOT)
40847:           ? pobj->lockedGetSlot(slot)
27490:           : JSVAL_VOID;
40265:     if (sprop->hasDefaultGetter())
32658:         return true;
32658: 
32658:     if (JS_UNLIKELY(sprop->isMethod()) && (getHow & JSGET_NO_METHOD_BARRIER)) {
32658:         JS_ASSERT(sprop->methodValue() == *vp);
32658:         return true;
32658:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
    1:     JS_UNLOCK_SCOPE(cx, scope);
40221:     {
40388:         AutoScopePropertyRooter tvr(cx, sprop);
40388:         AutoValueRooter tvr2(cx, pobj);
40221:         if (!sprop->get(cx, obj, pobj, vp))
32658:             return false;
40221:     }
    1:     JS_LOCK_SCOPE(cx, scope);
40221: 
    1:     if (SLOT_IN_SCOPE(slot, scope) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
35334:          scope->hasProperty(sprop))) {
32658:         jsval v = *vp;
32658:         if (!scope->methodWriteBarrier(cx, sprop, v)) {
32658:             JS_UNLOCK_SCOPE(cx, scope);
32658:             return false;
32658:         }
40847:         pobj->lockedSetSlot(slot, v);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
32658: js_NativeSet(JSContext *cx, JSObject *obj, JSScopeProperty *sprop, bool added,
32658:              jsval *vp)
    1: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
27490: 
27490:     JSScope *scope;
27490:     uint32 slot;
27490:     int32 sample;
27490: 
40430:     JS_ASSERT(obj->isNative());
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
40847:     scope = obj->scope();
27490: 
27490:     slot = sprop->slot;
27490:     if (slot != SPROP_INVALID_SLOT) {
27490:         OBJ_CHECK_SLOT(obj, slot);
27490: 
27490:         /* If sprop has a stub setter, keep scope locked and just store *vp. */
40265:         if (sprop->hasDefaultSetter()) {
32658:             if (!added && !scope->methodWriteBarrier(cx, sprop, *vp)) {
32658:                 JS_UNLOCK_SCOPE(cx, scope);
32658:                 return false;
32658:             }
40847:             obj->lockedSetSlot(slot, *vp);
32658:             return true;
32658:         }
27490:     } else {
    1:         /*
    1:          * Allow API consumers to create shared properties with stub setters.
36491:          * Such properties effectively function as data descriptors which are
36491:          * not writable, so attempting to set such a property should do nothing
36491:          * or throw if we're in strict mode.
    1:          */
40265:         if (!sprop->hasGetterValue() && sprop->hasDefaultSetter())
36491:             return js_ReportGetterOnlyAssignment(cx);
    1:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
    1:     JS_UNLOCK_SCOPE(cx, scope);
40221:     {
40388:         AutoScopePropertyRooter tvr(cx, sprop);
40221:         if (!sprop->set(cx, obj, vp))
32658:             return false;
40221:     }
    1: 
    1:     JS_LOCK_SCOPE(cx, scope);
    1:     if (SLOT_IN_SCOPE(slot, scope) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
35334:          scope->hasProperty(sprop))) {
32658:         jsval v = *vp;
32658:         if (!added && !scope->methodWriteBarrier(cx, sprop, v)) {
32658:             JS_UNLOCK_SCOPE(cx, scope);
32658:             return false;
32658:         }
40847:         obj->lockedSetSlot(slot, v);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
32658: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN getHow,
27575:                      jsval *vp)
    1: {
25942:     JSObject *aobj, *obj2;
11377:     int protoIndex;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1: 
32658:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, !JS_ON_TRACE(cx));
32658: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
39928:     aobj = js_GetProtoIfDenseArray(obj);
25942:     protoIndex = js_LookupPropertyWithFlags(cx, aobj, id, cx->resolveFlags,
19712:                                             &obj2, &prop);
11377:     if (protoIndex < 0)
    1:         return JS_FALSE;
    1:     if (!prop) {
    1:         *vp = JSVAL_VOID;
    1: 
40826:         if (!obj->getClass()->getProperty(cx, obj, ID_TO_VALUE(id), vp))
    1:             return JS_FALSE;
    1: 
32658:         PCMETER(getHow & JSGET_CACHE_RESULT && JS_PROPERTY_CACHE(cx).nofills++);
11377: 
    1:         /*
    1:          * Give a strict warning if foo.bar is evaluated by a script for an
    1:          * object foo with no property named 'bar'.
    1:          */
24598:         jsbytecode *pc;
24598:         if (JSVAL_IS_VOID(*vp) && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
    1:             JSOp op;
    1:             uintN flags;
    1: 
 3164:             op = (JSOp) *pc;
25215:             if (op == JSOP_TRAP) {
25215:                 JS_ASSERT_NOT_ON_TRACE(cx);
25215:                 op = JS_GetTrapOpcode(cx, cx->fp->script, pc);
25215:             }
    1:             if (op == JSOP_GETXPROP) {
    1:                 flags = JSREPORT_ERROR;
    1:             } else {
    1:                 if (!JS_HAS_STRICT_OPTION(cx) ||
31814:                     (op != JSOP_GETPROP && op != JSOP_GETELEM) ||
31911:                     js_CurrentPCIsInImacro(cx)) {
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 /*
    1:                  * XXX do not warn about missing __iterator__ as the function
    1:                  * may be called from JS_GetMethodById. See bug 355145.
    1:                  */
    1:                 if (id == ATOM_TO_JSID(cx->runtime->atomState.iteratorAtom))
    1:                     return JS_TRUE;
    1: 
25213:                 /* Do not warn about tests like (obj[prop] == undefined). */
25213:                 if (cx->resolveFlags == JSRESOLVE_INFER) {
37741:                     LeaveTrace(cx);
    1:                     pc += js_CodeSpec[op].length;
    1:                     if (Detecting(cx, pc))
    1:                         return JS_TRUE;
25213:                 } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
25213:                     return JS_TRUE;
25213:                 }
    1: 
    1:                 flags = JSREPORT_WARNING | JSREPORT_STRICT;
    1:             }
    1: 
    1:             /* Ok, bad undefined property reference: whine about it. */
    1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
    1:                                           JSDVG_IGNORE_STACK, ID_TO_VALUE(id),
    1:                                           NULL, NULL, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
40430:     if (!obj2->isNative()) {
31501:         obj2->dropProperty(cx, prop);
31501:         return obj2->getProperty(cx, id, vp);
    1:     }
    1: 
    1:     sprop = (JSScopeProperty *) prop;
27490: 
32658:     if (getHow & JSGET_CACHE_RESULT) {
24499:         JS_ASSERT_NOT_ON_TRACE(cx);
40362:         JS_PROPERTY_CACHE(cx).fill(cx, aobj, 0, protoIndex, obj2, sprop);
27490:     }
27932: 
32658:     if (!js_NativeGet(cx, obj, obj2, sprop, getHow, vp))
27932:         return JS_FALSE;
27932: 
27490:     JS_UNLOCK_OBJ(cx, obj2);
27490:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
11377: js_GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
32658:     return js_GetPropertyHelper(cx, obj, id, JSGET_METHOD_BARRIER, vp);
11377: }
11377: 
11377: JSBool
32658: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, jsval *vp)
26187: {
29913:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
29913: 
26187:     if (obj->map->ops == &js_ObjectOps ||
26187:         obj->map->ops->getProperty == js_GetProperty) {
32658:         return js_GetPropertyHelper(cx, obj, id, getHow, vp);
32658:     }
39928:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, obj->isDenseArray());
26187: #if JS_HAS_XML_SUPPORT
41295:     if (OBJECT_IS_XML(cx, obj))
26187:         return js_GetXMLMethod(cx, obj, id, vp);
26187: #endif
31501:     return obj->getProperty(cx, id, vp);
26187: }
26187: 
35308: JS_FRIEND_API(bool)
41774: js_CheckUndeclaredVarAssignment(JSContext *cx, jsval propname)
27372: {
35308:     JSStackFrame *fp = js_GetTopStackFrame(cx);
35308:     if (!fp)
35308:         return true;
35308: 
35308:     /* If neither cx nor the code is strict, then no check is needed. */
35308:     if (!(fp->script && fp->script->strictModeCode) &&
35308:         !JS_HAS_STRICT_OPTION(cx)) {
35308:         return true;
35308:     }
35308: 
41774:     const char *bytes = js_GetStringBytes(cx, JSVAL_TO_STRING(propname));
27372:     return bytes &&
35308:            JS_ReportErrorFlagsAndNumber(cx,
35308:                                         (JSREPORT_WARNING | JSREPORT_STRICT
35308:                                          | JSREPORT_STRICT_MODE_ERROR),
27372:                                         js_GetErrorMessage, NULL,
27372:                                         JSMSG_UNDECLARED_VAR, bytes);
27372: }
27372: 
40832: namespace js {
40832: 
40832: JSBool
40832: ReportReadOnly(JSContext* cx, jsid id, uintN flags)
40832: {
40832:     return js_ReportValueErrorFlags(cx, flags, JSMSG_READ_ONLY,
40832:                                     JSDVG_IGNORE_STACK, ID_TO_VALUE(id), NULL,
40832:                                     NULL, NULL);
40832: }
40832: 
40832: }
40832: 
41855: /*
41855:  * Note: all non-error exits in this function must notify the tracer using
41855:  * SetPropHit when called from the interpreter, which is detected by testing
41855:  * (defineHow & JSDNP_CACHE_RESULT).
41855:  */
27932: JSBool
32658: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
27575:                      jsval *vp)
11377: {
11377:     int protoIndex;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1:     uintN attrs, flags;
    1:     intN shortid;
    1:     JSClass *clasp;
    1:     JSPropertyOp getter, setter;
27930:     bool added;
    1: 
41776:     JS_ASSERT((defineHow &
41776:                ~(JSDNP_CACHE_RESULT | JSDNP_SET_METHOD | JSDNP_UNQUALIFIED)) == 0);
32658:     if (defineHow & JSDNP_CACHE_RESULT)
28398:         JS_ASSERT_NOT_ON_TRACE(cx);
28398: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
22452:     /*
40847:      * We peek at obj->scope() without locking obj. Any race means a failure
22452:      * to seal before sharing, which is inherently ambiguous.
22452:      */
40847:     if (obj->scope()->sealed() && obj->scope()->object == obj)
40832:         return ReportReadOnly(cx, id, JSREPORT_ERROR);
22452: 
19712:     protoIndex = js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                             &pobj, &prop);
11377:     if (protoIndex < 0)
27932:         return JS_FALSE;
27237:     if (prop) {
40430:         if (!pobj->isNative()) {
31501:             pobj->dropProperty(cx, prop);
    1:             prop = NULL;
    1:         }
27237:     } else {
27237:         /* We should never add properties to lexical blocks.  */
40826:         JS_ASSERT(obj->getClass() != &js_BlockClass);
27237: 
41774:         if (!obj->getParent() &&
41774:             (defineHow & JSDNP_UNQUALIFIED) &&
41774:             !js_CheckUndeclaredVarAssignment(cx, ID_TO_VALUE(id))) {
41774:             return JS_FALSE;
41774:         }
27237:     }
    1:     sprop = (JSScopeProperty *) prop;
    1: 
    1:     /*
    1:      * Now either sprop is null, meaning id was not found in obj or one of its
    1:      * prototypes; or sprop is non-null, meaning id was found in pobj's scope.
    1:      * If JS_THREADSAFE and sprop is non-null, then scope is locked, and sprop
31501:      * is held: we must JSObject::dropProperty or JS_UNLOCK_SCOPE before we
31501:      * return (the two are equivalent for native objects, but we use
31501:      * JS_UNLOCK_SCOPE because it is cheaper).
    1:      */
    1:     attrs = JSPROP_ENUMERATE;
    1:     flags = 0;
    1:     shortid = 0;
40826:     clasp = obj->getClass();
    1:     getter = clasp->getProperty;
    1:     setter = clasp->setProperty;
    1: 
    1:     if (sprop) {
    1:         /*
    1:          * Set scope for use below.  It was locked by js_LookupProperty, and
    1:          * we know pobj owns it (i.e., scope->object == pobj).  Therefore we
    1:          * optimize JS_UNLOCK_OBJ(cx, pobj) into JS_UNLOCK_SCOPE(cx, scope).
    1:          */
40847:         scope = pobj->scope();
    1: 
40832:         /* ES5 8.12.4 [[Put]] step 2. */
40832:         if (sprop->isAccessorDescriptor()) {
40832:             if (sprop->hasDefaultSetter()) {
    1:                 JS_UNLOCK_SCOPE(cx, scope);
41855:                 if (defineHow & JSDNP_CACHE_RESULT)
41855:                     TRACE_2(SetPropHit, JS_NO_PROP_CACHE_FILL, sprop);
40832:                 return js_ReportGetterOnlyAssignment(cx);
40832:             }
40832:         } else {
40832:             JS_ASSERT(sprop->isDataDescriptor());
40832: 
40265:             if (!sprop->writable()) {
40832:                 JS_UNLOCK_SCOPE(cx, scope);
40832: 
32658:                 PCMETER((defineHow & JSDNP_CACHE_RESULT) && JS_PROPERTY_CACHE(cx).rofills++);
41855:                 if (defineHow & JSDNP_CACHE_RESULT) {
41855:                     JS_ASSERT_NOT_ON_TRACE(cx);
41855:                     TRACE_2(SetPropHit, JS_NO_PROP_CACHE_FILL, sprop);
41855:                 }
41247: 
41247:                 /* Warn in strict mode, otherwise do nothing. */
41247:                 if (JS_HAS_STRICT_OPTION(cx))
41247:                     return ReportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
27932:                 return JS_TRUE;
41855: 
41855: #ifdef JS_TRACER
41855:               error: // TRACE_2 jumps here in case of error.
41855:                 return JS_FALSE;
41855: #endif
    1:             }
40832:         }
40832:         if (scope->sealed() && !sprop->hasSlot()) {
40832:             JS_UNLOCK_SCOPE(cx, scope);
40832:             return ReportReadOnly(cx, id, JSREPORT_ERROR);
    1:         }
    1: 
40265:         attrs = sprop->attributes();
32568:         if (pobj != obj) {
    1:             /*
    1:              * We found id in a prototype object: prepare to share or shadow.
11377:              *
    1:              * NB: Thanks to the immutable, garbage-collected property tree
    1:              * maintained by jsscope.c in cx->runtime, we needn't worry about
    1:              * sprop going away behind our back after we've unlocked scope.
    1:              */
    1:             JS_UNLOCK_SCOPE(cx, scope);
    1: 
40265:             /* Don't clone a prototype property that doesn't have a slot. */
40265:             if (!sprop->hasSlot()) {
32658:                 if (defineHow & JSDNP_CACHE_RESULT) {
32850:                     JS_ASSERT_NOT_ON_TRACE(cx);
41855:                     PropertyCacheEntry *entry =
40362:                         JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, protoIndex, pobj, sprop);
41855:                     TRACE_2(SetPropHit, entry, sprop);
27932:                 }
27932: 
40265:                 if (sprop->hasDefaultSetter() && !sprop->hasGetterValue())
27932:                     return JS_TRUE;
27932: 
32658:                 return sprop->set(cx, obj, vp);
    1:             }
    1: 
    1:             /* Restore attrs to the ECMA default for new properties. */
    1:             attrs = JSPROP_ENUMERATE;
    1: 
    1:             /*
    1:              * Preserve the shortid, getter, and setter when shadowing any
    1:              * property that has a shortid.  An old API convention requires
    1:              * that the property's getter and setter functions receive the
    1:              * shortid, not id, when they are called on the shadow we are
    1:              * about to create in obj's scope.
    1:              */
38562:             if (sprop->hasShortID()) {
38562:                 flags = JSScopeProperty::HAS_SHORTID;
    1:                 shortid = sprop->shortid;
39894:                 getter = sprop->getter();
39894:                 setter = sprop->setter();
    1:             }
    1: 
    1:             /*
    1:              * Forget we found the proto-property now that we've copied any
    1:              * needed member values.
    1:              */
    1:             sprop = NULL;
    1:         }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     } else {
    1:         scope = NULL;
    1: #endif
    1:     }
    1: 
27930:     added = false;
    1:     if (!sprop) {
11377:         /*
11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
11377:          * Do this early, before locking obj to avoid nesting locks.
11377:          */
25936:         js_PurgeScopeChain(cx, obj, id);
11377: 
    1:         /* Find or make a property descriptor with the right heritage. */
    1:         JS_LOCK_OBJ(cx, obj);
    1:         scope = js_GetMutableScope(cx, obj);
    1:         if (!scope) {
    1:             JS_UNLOCK_OBJ(cx, obj);
27932:             return JS_FALSE;
    1:         }
32658: 
32658:         /*
32658:          * Check for Object class here to avoid defining a method on a class
32658:          * with magic resolve, addProperty, getProperty, etc. hooks.
32658:          */
41855:         if ((defineHow & JSDNP_SET_METHOD) &&
41855:             obj->getClass() == &js_ObjectClass) {
32658:             JS_ASSERT(VALUE_IS_FUNCTION(cx, *vp));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658: 
32658:             JSObject *funobj = JSVAL_TO_OBJECT(*vp);
32658:             if (FUN_OBJECT(GET_FUNCTION_PRIVATE(cx, funobj)) == funobj) {
38562:                 flags |= JSScopeProperty::METHOD;
41860:                 getter = CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
35455:         sprop = scope->putProperty(cx, id, getter, setter, SPROP_INVALID_SLOT,
35334:                                    attrs, flags, shortid);
    1:         if (!sprop) {
    1:             JS_UNLOCK_SCOPE(cx, scope);
27932:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Initialize the new property value (passed to setter) to undefined.
    1:          * Note that we store before calling addProperty, to match the order
    1:          * in js_DefineNativeProperty.
    1:          */
    1:         if (SPROP_HAS_VALID_SLOT(sprop, scope))
40847:             obj->lockedSetSlot(sprop->slot, JSVAL_VOID);
    1: 
    1:         /* XXXbe called with obj locked */
32658:         if (!AddPropertyHelper(cx, clasp, obj, scope, sprop, vp)) {
35334:             scope->removeProperty(cx, id);
    1:             JS_UNLOCK_SCOPE(cx, scope);
32658:             return JS_FALSE;
32658:         }
27930:         added = true;
    1:     }
    1: 
32658:     if (defineHow & JSDNP_CACHE_RESULT) {
32850:         JS_ASSERT_NOT_ON_TRACE(cx);
41855:         PropertyCacheEntry *entry = JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, 0, obj, sprop, added);
41855:         TRACE_2(SetPropHit, entry, sprop);
27932:     }
27932: 
32658:     if (!js_NativeSet(cx, obj, sprop, added, vp))
27575:         return NULL;
27575: 
27490:     JS_UNLOCK_SCOPE(cx, scope);
27932:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
11377: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
11377: {
41774:     return js_SetPropertyHelper(cx, obj, id, 0, vp);
11377: }
11377: 
11377: JSBool
    1: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp)
    1: {
    1:     JSBool noprop, ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     noprop = !prop;
    1:     if (noprop) {
    1:         if (!js_LookupProperty(cx, obj, id, &obj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             *attrsp = 0;
    1:             return JS_TRUE;
    1:         }
40430:         if (!obj->isNative()) {
31501:             ok = obj->getAttributes(cx, id, prop, attrsp);
31501:             obj->dropProperty(cx, prop);
    1:             return ok;
    1:         }
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
40265:     *attrsp = sprop->attributes();
    1:     if (noprop)
31501:         obj->dropProperty(cx, prop);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
    1:                  uintN *attrsp)
    1: {
    1:     JSBool noprop, ok;
    1:     JSScopeProperty *sprop;
    1: 
    1:     noprop = !prop;
    1:     if (noprop) {
    1:         if (!js_LookupProperty(cx, obj, id, &obj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop)
    1:             return JS_TRUE;
40430:         if (!obj->isNative()) {
31501:             ok = obj->setAttributes(cx, id, prop, attrsp);
31501:             obj->dropProperty(cx, prop);
    1:             return ok;
    1:         }
    1:     }
    1:     sprop = (JSScopeProperty *)prop;
    1:     sprop = js_ChangeNativePropertyAttrs(cx, obj, sprop, *attrsp, 0,
39894:                                          sprop->getter(), sprop->setter());
    1:     if (noprop)
31501:         obj->dropProperty(cx, prop);
    1:     return (sprop != NULL);
    1: }
    1: 
    1: JSBool
    1: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, jsval *rval)
    1: {
    1:     JSObject *proto;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1:     JSBool ok;
    1: 
    1:     *rval = JSVAL_TRUE;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     if (!js_LookupProperty(cx, obj, id, &proto, &prop))
    1:         return JS_FALSE;
    1:     if (!prop || proto != obj) {
    1:         /*
    1:          * If the property was found in a native prototype, check whether it's
    1:          * shared and permanent.  Such a property stands for direct properties
    1:          * in all delegating objects, matching ECMA semantics without bloating
    1:          * each delegating object.
    1:          */
    1:         if (prop) {
40430:             if (proto->isNative()) {
    1:                 sprop = (JSScopeProperty *)prop;
40327:                 if (sprop->isSharedPermanent())
    1:                     *rval = JSVAL_FALSE;
    1:             }
31501:             proto->dropProperty(cx, prop);
    1:             if (*rval == JSVAL_FALSE)
    1:                 return JS_TRUE;
    1:         }
    1: 
    1:         /*
    1:          * If no property, or the property comes unshared or impermanent from
    1:          * a prototype, call the class's delProperty hook, passing rval as the
    1:          * result parameter.
    1:          */
40826:         return obj->getClass()->delProperty(cx, obj, ID_TO_VALUE(id), rval);
    1:     }
    1: 
    1:     sprop = (JSScopeProperty *)prop;
40265:     if (!sprop->configurable()) {
31501:         obj->dropProperty(cx, prop);
    1:         *rval = JSVAL_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /* XXXbe called with obj locked */
32603:     if (!obj->getClass()->delProperty(cx, obj, SPROP_USERID(sprop), rval)) {
31501:         obj->dropProperty(cx, prop);
    1:         return JS_FALSE;
    1:     }
    1: 
40847:     scope = obj->scope();
    1:     if (SPROP_HAS_VALID_SLOT(sprop, scope))
40847:         GC_POKE(cx, obj->lockedGetSlot(sprop->slot));
    1: 
35334:     ok = scope->removeProperty(cx, id);
31501:     obj->dropProperty(cx, prop);
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_DefaultValue(JSContext *cx, JSObject *obj, JSType hint, jsval *vp)
    1: {
    1:     jsval v, save;
    1:     JSString *str;
    1: 
40867:     JS_ASSERT(hint != JSTYPE_OBJECT && hint != JSTYPE_FUNCTION);
40867: 
    1:     v = save = OBJECT_TO_JSVAL(obj);
    1:     switch (hint) {
    1:       case JSTYPE_STRING:
    1:         /*
30443:          * Optimize for String objects with standard toString methods. Support
30443:          * new String(...) instances whether mutated to have their own scope or
30443:          * not, as well as direct String.prototype references.
30443:          */
40826:         if (obj->getClass() == &js_StringClass) {
30443:             jsid toStringId = ATOM_TO_JSID(cx->runtime->atomState.toStringAtom);
30443: 
30443:             JS_LOCK_OBJ(cx, obj);
40847:             JSScope *scope = obj->scope();
30443:             JSScopeProperty *sprop = scope->lookup(toStringId);
30645:             JSObject *pobj = obj;
30645: 
30645:             if (!sprop) {
32603:                 pobj = obj->getProto();
30645: 
40826:                 if (pobj && pobj->getClass() == &js_StringClass) {
30443:                     JS_UNLOCK_SCOPE(cx, scope);
30645:                     JS_LOCK_OBJ(cx, pobj);
40847:                     scope = pobj->scope();
30443:                     sprop = scope->lookup(toStringId);
30443:                 }
30443:             }
30443: 
40265:             if (sprop && sprop->hasDefaultGetter() && SPROP_HAS_VALID_SLOT(sprop, scope)) {
40847:                 jsval fval = pobj->lockedGetSlot(sprop->slot);
30443: 
30443:                 if (VALUE_IS_FUNCTION(cx, fval)) {
30443:                     JSObject *funobj = JSVAL_TO_OBJECT(fval);
30443:                     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
30443: 
30443:                     if (FUN_FAST_NATIVE(fun) == js_str_toString) {
30443:                         JS_UNLOCK_SCOPE(cx, scope);
40901:                         *vp = obj->getPrimitiveThis();
30443:                         return JS_TRUE;
30443:                     }
30443:                 }
30443:             }
30443:             JS_UNLOCK_SCOPE(cx, scope);
30443:         }
30443: 
30443:         /*
    1:          * Propagate the exception if js_TryMethod finds an appropriate
    1:          * method, and calling that method returned failure.
    1:          */
    1:         if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0, NULL,
    1:                           &v)) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
40826:             if (!obj->getClass()->convert(cx, obj, hint, &v))
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       default:
40826:         if (!obj->getClass()->convert(cx, obj, hint, &v))
    1:             return JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
40867:             JS_ASSERT(hint != JS_TypeOfValue(cx, v));
40867:             if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0, NULL, &v))
40867:                 return JS_FALSE;
    1:         }
    1:         break;
    1:     }
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         /* Avoid recursive death when decompiling in js_ReportValueError. */
    1:         if (hint == JSTYPE_STRING) {
40826:             str = JS_InternString(cx, obj->getClass()->name);
    1:             if (!str)
    1:                 return JS_FALSE;
    1:         } else {
    1:             str = NULL;
    1:         }
    1:         *vp = OBJECT_TO_JSVAL(obj);
    1:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO,
    1:                              JSDVG_SEARCH_STACK, save, str,
    1:                              (hint == JSTYPE_VOID)
    1:                              ? "primitive type"
 4342:                              : JS_TYPE_STR(hint));
    1:         return JS_FALSE;
    1:     }
    1:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
15677: /*
17049:  * Private type used to enumerate properties of a native JS object. It is
17049:  * allocated as necessary from JSENUMERATE_INIT and is freed when running the
17049:  * GC. The structure is not allocated when there are no enumerable properties
17049:  * in the object. Instead for the empty enumerator the code uses JSVAL_ZERO as
17049:  * the enumeration state.
17049:  *
33128:  * JSThreadData.nativeEnumCache caches the enumerators using scope's shape to
17049:  * avoid repeated scanning of scopes for enumerable properties. The cache
17049:  * entry is either JSNativeEnumerator* or, for the empty enumerator, the shape
17049:  * value itself. The latter is stored as (shape << 1) | 1 to ensure that it is
17049:  * always different from JSNativeEnumerator* values.
33128:  *
33128:  * We cache the enumerators in the JSENUMERATE_INIT case of js_Enumerate, not
33128:  * during JSENUMERATE_DESTROY. The GC can invoke the latter case during the
33128:  * finalization when JSNativeEnumerator contains finalized ids and the
33128:  * enumerator must be freed.
15677:  */
15677: struct JSNativeEnumerator {
17049:     /*
17049:      * The index into the ids array. It runs from the length down to 1 when
17049:      * the enumerator is running. It is 0 when the enumerator is finished and
33128:      * can be reused on a cache hit.
17049:     */
33128:     uint32                  cursor;
15677:     uint32                  length;     /* length of ids array */
17049:     uint32                  shape;      /* "shape" number -- see jsscope.h */
15677:     jsid                    ids[1];     /* enumeration id array */
33128: 
33128:     static inline size_t size(uint32 length) {
33128:         JS_ASSERT(length != 0);
33128:         return offsetof(JSNativeEnumerator, ids) +
33128:                (size_t) length * sizeof(jsid);
33128:     }
33128: 
33128:     bool isFinished() const {
33128:         return cursor == 0;
33128:     }
33128: 
33128:     void mark(JSTracer *trc) {
33128:         JS_ASSERT(length >= 1);
33128:         jsid *cursor = ids;
33128:         jsid *end = ids + length;
33128:         do {
33128:             js_TraceId(trc, *cursor);
33128:         } while (++cursor != end);
33128:     }
15677: };
    1: 
17049: /* The tagging of shape values requires one bit. */
17049: JS_STATIC_ASSERT((jsuword) SHAPE_OVERFLOW_BIT <=
17049:                  ((jsuword) 1 << (JS_BITS_PER_WORD - 1)));
17049: 
33128: static void
33128: SetEnumeratorCache(JSContext *cx, jsuword *cachep, jsuword newcache)
33128: {
33128:     jsuword old = *cachep;
33128:     *cachep = newcache;
33128:     if (!(old & jsuword(1)) && old) {
33128:         /* Free the cached enumerator unless it is running. */
33128:         JSNativeEnumerator *ne = reinterpret_cast<JSNativeEnumerator *>(old);
33128:         if (ne->isFinished())
33128:             cx->free(ne);
33128:     }
33128: }
33128: 
    1: JSBool
    1: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
    1:              jsval *statep, jsid *idp)
    1: {
33128:     /* Here cx is JSTracer when enum_op is JSENUMERATE_MARK. */
33128:     JSClass *clasp = obj->getClass();
33128:     JSEnumerateOp enumerate = clasp->enumerate;
11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
    1:         return ((JSNewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
11835:     }
    1: 
    1:     switch (enum_op) {
33128:       case JSENUMERATE_INIT: {
    1:         if (!enumerate(cx, obj))
33128:             return false;
15677: 
15677:         /*
15677:          * The set of all property ids is pre-computed when the iterator is
15677:          * initialized to avoid problems caused by properties being deleted
15677:          * during the iteration.
15677:          *
15677:          * Use a do-while(0) loop to avoid too many nested ifs. If ne is null
33128:          * after the loop, it indicates an empty enumerator.
15677:          */
33128:         JSNativeEnumerator *ne;
33128:         uint32 length;
33128:         do {
40847:             uint32 shape = obj->shape();
33128: 
33128:             ENUM_CACHE_METER(nativeEnumProbes);
33128:             jsuword *cachep = &JS_THREAD_DATA(cx)->
33128:                               nativeEnumCache[NATIVE_ENUM_CACHE_HASH(shape)];
33128:             jsuword oldcache = *cachep;
33128:             if (oldcache & (jsuword) 1) {
33128:                 if (uint32(oldcache >> 1) == shape) {
33128:                     /* scope has a shape with no enumerable properties. */
15677:                     ne = NULL;
    1:                     length = 0;
33128:                     break;
33128:                 }
33128:             } else if (oldcache != jsuword(0)) {
33128:                 ne = reinterpret_cast<JSNativeEnumerator *>(oldcache);
33128:                 JS_ASSERT(ne->length >= 1);
33128:                 if (ne->shape == shape && ne->isFinished()) {
33128:                     /* Mark ne as active. */
33128:                     ne->cursor = ne->length;
33128:                     length = ne->length;
33128:                     JS_ASSERT(!ne->isFinished());
33128:                     break;
33128:                 }
33128:             }
33128:             ENUM_CACHE_METER(nativeEnumMisses);
33128: 
    1:             JS_LOCK_OBJ(cx, obj);
33128: 
33128:             /* Count all enumerable properties in object's scope. */
40847:             JSScope *scope = obj->scope();
17049:             length = 0;
35334:             for (JSScopeProperty *sprop = scope->lastProperty(); sprop; sprop = sprop->parent) {
38562:                 if (sprop->enumerable() && !sprop->isAlias())
    1:                     length++;
    1:             }
17049:             if (length == 0) {
32735:                /*
32735:                 * Cache the scope without enumerable properties unless its
32735:                 * shape overflows, see bug 440834.
32735:                 */
33128:                 JS_UNLOCK_SCOPE(cx, scope);
33128:                 if (shape < SHAPE_OVERFLOW_BIT) {
33128:                     SetEnumeratorCache(cx, cachep,
33128:                                        (jsuword(shape) << 1) | jsuword(1));
33128:                 }
33128:                 ne = NULL;
15677:                 break;
17049:             }
17049: 
33128:             ne = (JSNativeEnumerator *)
33128:                  cx->mallocNoReport(JSNativeEnumerator::size(length));
15677:             if (!ne) {
33128:                 /* Report the OOM error outside the lock. */
15677:                 JS_UNLOCK_SCOPE(cx, scope);
33128:                 JS_ReportOutOfMemory(cx);
33128:                 return false;
    1:             }
15677:             ne->cursor = length;
15677:             ne->length = length;
17049:             ne->shape = shape;
33128: 
33128:             jsid *ids = ne->ids;
35334:             for (JSScopeProperty *sprop = scope->lastProperty(); sprop; sprop = sprop->parent) {
38562:                 if (sprop->enumerable() && !sprop->isAlias()) {
15677:                     JS_ASSERT(ids < ne->ids + length);
15677:                     *ids++ = sprop->id;
15677:                 }
15677:             }
15677:             JS_ASSERT(ids == ne->ids + length);
15677:             JS_UNLOCK_SCOPE(cx, scope);
15677: 
32735:             /*
32735:              * Do not cache enumerators for objects with with a shape
32735:              * that had overflowed, see bug 440834.
32735:              */
32735:             if (shape < SHAPE_OVERFLOW_BIT)
33128:                 SetEnumeratorCache(cx, cachep, reinterpret_cast<jsuword>(ne));
33128:         } while (0);
33128: 
33128:         if (!ne) {
33128:             JS_ASSERT(length == 0);
33128:             *statep = JSVAL_ZERO;
33128:         } else {
33128:             JS_ASSERT(length != 0);
33128:             JS_ASSERT(ne->cursor == length);
33128:             JS_ASSERT(!(reinterpret_cast<jsuword>(ne) & jsuword(1)));
15677:             *statep = PRIVATE_TO_JSVAL(ne);
15677:         }
17049:         if (idp)
17049:             *idp = INT_TO_JSVAL(length);
    1:         break;
33128:       }
    1: 
    1:       case JSENUMERATE_NEXT:
33128:       case JSENUMERATE_DESTROY: {
17049:         if (*statep == JSVAL_ZERO) {
17049:             *statep = JSVAL_NULL;
17049:             break;
17049:         }
33128:         JSNativeEnumerator *ne = (JSNativeEnumerator *)
33128:                                  JSVAL_TO_PRIVATE(*statep);
15677:         JS_ASSERT(ne->length >= 1);
17049:         JS_ASSERT(ne->cursor >= 1);
17049:         if (enum_op == JSENUMERATE_NEXT) {
33128:             uint32 newcursor = ne->cursor - 1;
17049:             *idp = ne->ids[newcursor];
33128:             if (newcursor != 0) {
17049:                 ne->cursor = newcursor;
33128:                 break;
33128:             }
17049:         } else {
17049:             /* The enumerator has not iterated over all ids. */
29865:             JS_ASSERT(enum_op == JSENUMERATE_DESTROY);
33128:         }
33128:         *statep = JSVAL_ZERO;
33128: 
33128:         jsuword *cachep = &JS_THREAD_DATA(cx)->
33128:                           nativeEnumCache[NATIVE_ENUM_CACHE_HASH(ne->shape)];
33128:         if (reinterpret_cast<jsuword>(ne) == *cachep) {
33128:             /* Mark the cached iterator as available. */
17049:             ne->cursor = 0;
33128:         } else {
33128:             cx->free(ne);
17049:         }
    1:         break;
    1:       }
33128:     }
33128:     return true;
    1: }
    1: 
    1: void
33128: js_MarkEnumeratorState(JSTracer *trc, JSObject *obj, jsval state)
33128: {
33128:     if (JSVAL_IS_TRACEABLE(state)) {
33128:         JS_CALL_TRACER(trc, JSVAL_TO_TRACEABLE(state),
33128:                        JSVAL_TRACE_KIND(state), "enumerator_value");
33128:     } else if (obj->map->ops->enumerate == js_Enumerate &&
33128:                !(obj->getClass()->flags & JSCLASS_NEW_ENUMERATE)) {
33128:         /* Check if state stores JSNativeEnumerator. */
33128:         JS_ASSERT(JSVAL_IS_INT(state) ||
33128:                   JSVAL_IS_NULL(state) ||
33128:                   JSVAL_IS_VOID(state));
33128:         if (JSVAL_IS_INT(state) && state != JSVAL_ZERO)
33128:             ((JSNativeEnumerator *) JSVAL_TO_PRIVATE(state))->mark(trc);
33128:     }
33128: }
33128: 
33128: void
33128: js_PurgeCachedNativeEnumerators(JSContext *cx, JSThreadData *data)
33128: {
33128:     jsuword *cachep = &data->nativeEnumCache[0];
33128:     jsuword *end = cachep + JS_ARRAY_LENGTH(data->nativeEnumCache);
33128:     for (; cachep != end; ++cachep)
33128:         SetEnumeratorCache(cx, cachep, jsuword(0));
33128: 
17049: #ifdef JS_DUMP_ENUM_CACHE_STATS
17049:     printf("nativeEnumCache hit rate %g%%\n",
33128:            100.0 * (cx->runtime->nativeEnumProbes -
33128:                     cx->runtime->nativeEnumMisses) /
33128:            cx->runtime->nativeEnumProbes);
17049: #endif
17049: }
17049: 
    1: JSBool
    1: js_CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
    1:                jsval *vp, uintN *attrsp)
    1: {
    1:     JSBool writing;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSClass *clasp;
    1:     JSScopeProperty *sprop;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSCheckAccessOp check;
    1: 
    1:     writing = (mode & JSACC_WRITE) != 0;
    1:     switch (mode & JSACC_TYPEMASK) {
    1:       case JSACC_PROTO:
    1:         pobj = obj;
    1:         if (!writing)
39928:             *vp = OBJECT_TO_JSVAL(obj->getProto());
    1:         *attrsp = JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       case JSACC_PARENT:
    1:         JS_ASSERT(!writing);
    1:         pobj = obj;
39930:         *vp = OBJECT_TO_JSVAL(obj->getParent());
    1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       default:
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             if (!writing)
    1:                 *vp = JSVAL_VOID;
    1:             *attrsp = 0;
11842:             pobj = obj;
11842:             break;
11842:         }
11842: 
40430:         if (!pobj->isNative()) {
31501:             pobj->dropProperty(cx, prop);
11842: 
11842:             /* Avoid diverging for non-natives that reuse js_CheckAccess. */
11961:             if (pobj->map->ops->checkAccess == js_CheckAccess) {
16403:                 if (!writing) {
11961:                     *vp = JSVAL_VOID;
16403:                     *attrsp = 0;
16403:                 }
11842:                 break;
11961:             }
31501:             return pobj->checkAccess(cx, id, mode, vp, attrsp);
    1:         }
    1: 
    1:         sprop = (JSScopeProperty *)prop;
40265:         *attrsp = sprop->attributes();
    1:         if (!writing) {
40847:             *vp = (SPROP_HAS_VALID_SLOT(sprop, pobj->scope()))
40847:                   ? pobj->lockedGetSlot(sprop->slot)
    1:                   : JSVAL_VOID;
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1:     }
    1: 
    1:     /*
    1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
    1:      * checkObjectAccess callback, if configured.
    1:      *
    1:      * We don't want to require all classes to supply a checkAccess hook; we
    1:      * need that hook only for certain classes used when precompiling scripts
    1:      * and functions ("brutal sharing").  But for general safety of built-in
    1:      * magic properties such as __proto__ and __parent__, we route all access
    1:      * checks, even for classes that stub out checkAccess, through the global
    1:      * checkObjectAccess hook.  This covers precompilation-based sharing and
    1:      * (possibly unintended) runtime sharing across trust boundaries.
    1:      */
40826:     clasp = pobj->getClass();
    1:     check = clasp->checkAccess;
18870:     if (!check) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
18870:         check = callbacks ? callbacks->checkObjectAccess : NULL;
18870:     }
    1:     return !check || check(cx, pobj, ID_TO_VALUE(id), mode, vp);
    1: }
    1: 
38633: JSType
38633: js_TypeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     /*
38634:      * Unfortunately we have wrappers that are native objects and thus don't
38634:      * overwrite js_TypeOf (i.e. XPCCrossOriginWrapper), so we have to
38634:      * unwrap here.
38633:      */
38634:     obj = js_GetWrappedObject(cx, obj);
38633: 
38633:     /*
38633:      * ECMA 262, 11.4.3 says that any native object that implements
38633:      * [[Call]] should be of type "function". However, RegExp is of
38633:      * type "object", not "function", for Web compatibility.
38633:      */
38638:     if (obj->isCallable()) {
38633:         return (obj->getClass() != &js_RegExpClass)
38633:                ? JSTYPE_FUNCTION
38633:                : JSTYPE_OBJECT;
38633:     }
38633: 
38633: #ifdef NARCISSUS
38633:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
39421:     jsval v;
38633: 
38633:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__call__Atom), &v)) {
38633:         JS_ClearPendingException(cx);
39421:     } else {
39421:         if (VALUE_IS_FUNCTION(cx, v))
38633:             return JSTYPE_FUNCTION;
38633:     }
38633: #endif
38633: 
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
    1: #ifdef JS_THREADSAFE
    1: void
    1: js_DropProperty(JSContext *cx, JSObject *obj, JSProperty *prop)
    1: {
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: #endif
    1: 
    1: #ifdef NARCISSUS
    1: static JSBool
    1: GetCurrentExecutionContext(JSContext *cx, JSObject *obj, jsval *rval)
    1: {
    1:     JSObject *tmp;
    1:     jsval xcval;
    1: 
39930:     while ((tmp = obj->getParent()) != NULL)
    1:         obj = tmp;
31501:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.ExecutionContextAtom), &xcval))
    1:         return JS_FALSE;
    1:     if (JSVAL_IS_PRIMITIVE(xcval)) {
    1:         JS_ReportError(cx, "invalid ExecutionContext in global object");
    1:         return JS_FALSE;
    1:     }
31501:     if (!JSVAL_TO_OBJECT(xcval)->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.currentAtom),
    1:                                              rval)) {
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: JSBool
    1: js_Call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSClass *clasp;
    1: 
40826:     clasp = JSVAL_TO_OBJECT(argv[-2])->getClass();
    1:     if (!clasp->call) {
    1: #ifdef NARCISSUS
    1:         JSObject *callee, *args;
    1:         jsval fval, nargv[3];
    1:         JSBool ok;
    1: 
    1:         callee = JSVAL_TO_OBJECT(argv[-2]);
31501:         if (!callee->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__call__Atom), &fval))
    1:             return JS_FALSE;
    1:         if (VALUE_IS_FUNCTION(cx, fval)) {
    1:             if (!GetCurrentExecutionContext(cx, obj, &nargv[2]))
    1:                 return JS_FALSE;
22652:             args = js_GetArgsObject(cx, js_GetTopStackFrame(cx));
    1:             if (!args)
    1:                 return JS_FALSE;
    1:             nargv[0] = OBJECT_TO_JSVAL(obj);
    1:             nargv[1] = OBJECT_TO_JSVAL(args);
    1:             return js_InternalCall(cx, callee, fval, 3, nargv, rval);
    1:         }
    1:         if (JSVAL_IS_OBJECT(fval) && JSVAL_TO_OBJECT(fval) != callee) {
    1:             argv[-2] = fval;
    1:             ok = js_Call(cx, obj, argc, argv, rval);
    1:             argv[-2] = OBJECT_TO_JSVAL(callee);
    1:             return ok;
    1:         }
    1: #endif
22652:         js_ReportIsNotFunction(cx, &argv[-2], js_GetTopStackFrame(cx)->flags & JSFRAME_ITERATOR);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->call(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_Construct(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:              jsval *rval)
    1: {
    1:     JSClass *clasp;
    1: 
40826:     clasp = JSVAL_TO_OBJECT(argv[-2])->getClass();
    1:     if (!clasp->construct) {
    1: #ifdef NARCISSUS
    1:         JSObject *callee, *args;
    1:         jsval cval, nargv[2];
    1:         JSBool ok;
    1: 
    1:         callee = JSVAL_TO_OBJECT(argv[-2]);
31501:         if (!callee->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__construct__Atom),
    1:                                  &cval)) {
    1:             return JS_FALSE;
    1:         }
    1:         if (VALUE_IS_FUNCTION(cx, cval)) {
    1:             if (!GetCurrentExecutionContext(cx, obj, &nargv[1]))
    1:                 return JS_FALSE;
22652:             args = js_GetArgsObject(cx, js_GetTopStackFrame(cx));
    1:             if (!args)
    1:                 return JS_FALSE;
    1:             nargv[0] = OBJECT_TO_JSVAL(args);
    1:             return js_InternalCall(cx, callee, cval, 2, nargv, rval);
    1:         }
    1:         if (JSVAL_IS_OBJECT(cval) && JSVAL_TO_OBJECT(cval) != callee) {
    1:             argv[-2] = cval;
    1:             ok = js_Call(cx, obj, argc, argv, rval);
    1:             argv[-2] = OBJECT_TO_JSVAL(callee);
    1:             return ok;
    1:         }
    1: #endif
 4521:         js_ReportIsNotFunction(cx, &argv[-2], JSV2F_CONSTRUCT);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->construct(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_HasInstance(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     JSClass *clasp;
    1: 
40826:     clasp = obj->getClass();
    1:     if (clasp->hasInstance)
    1:         return clasp->hasInstance(cx, obj, v, bp);
    1: #ifdef NARCISSUS
    1:     {
    1:         jsval fval, rval;
    1: 
31501:         if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.__hasInstance__Atom), &fval))
    1:             return JS_FALSE;
    1:         if (VALUE_IS_FUNCTION(cx, fval)) {
10525:             if (!js_InternalCall(cx, obj, fval, 1, &v, &rval))
10525:                 return JS_FALSE;
10525:             *bp = js_ValueToBoolean(rval);
10525:             return JS_TRUE;
    1:         }
    1:     }
    1: #endif
    1:     js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
    1:                         JSDVG_SEARCH_STACK, OBJECT_TO_JSVAL(obj), NULL);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_IsDelegate(JSContext *cx, JSObject *obj, jsval v, JSBool *bp)
    1: {
    1:     JSObject *obj2;
    1: 
    1:     *bp = JS_FALSE;
    1:     if (JSVAL_IS_PRIMITIVE(v))
    1:         return JS_TRUE;
36628:     obj2 = js_GetWrappedObject(cx, JSVAL_TO_OBJECT(v));
39928:     while ((obj2 = obj2->getProto()) != NULL) {
    1:         if (obj2 == obj) {
    1:             *bp = JS_TRUE;
    1:             break;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
38604: js_GetClassPrototype(JSContext *cx, JSObject *scope, JSProtoKey protoKey,
38604:                      JSObject **protop, JSClass *clasp)
38604: {
38604:     VOUCH_DOES_NOT_REQUIRE_STACK();
38604:     JS_ASSERT(JSProto_Null <= protoKey);
38604:     JS_ASSERT(protoKey < JSProto_LIMIT);
38604: 
38604:     /* Query cache. */
38604:     JSClassProtoCache::GlobalAndProto *cacheEntry = NULL;
38604:     if (protoKey != JSProto_Null) {
38604:         if (!scope) {
38604:             if (cx->fp)
38604:                 scope = cx->fp->scopeChain;
38604:             if (!scope) {
38604:                 scope = cx->globalObject;
38604:                 if (!scope) {
38604:                     *protop = NULL;
38604:                     return true;
38604:                 }
38604:             }
38604:         }
38604:         while (JSObject *tmp = scope->getParent())
38604:             scope = tmp;
38604: 
38604:         JS_STATIC_ASSERT(JSProto_Null == 0);
38604:         JS_STATIC_ASSERT(JSProto_Object == 1);
38604:         cacheEntry = &cx->classProtoCache.entries[protoKey - JSProto_Object];
38604: 
38604:         PROTO_CACHE_METER(cx, probe);
38604:         if (cacheEntry->global == scope) {
38604:             JS_ASSERT(cacheEntry->proto);
38604:             PROTO_CACHE_METER(cx, hit);
38604:             *protop = cacheEntry->proto;
38604:             return true;
38604:         }
38604:     }
38604: 
    1:     jsval v;
38604:     if (!js_FindClassObject(cx, scope, protoKey, &v, clasp))
    1:         return JS_FALSE;
    1:     if (VALUE_IS_FUNCTION(cx, v)) {
38604:         JSObject *ctor = JSVAL_TO_OBJECT(v);
31501:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &v))
    1:             return JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             /*
    1:              * Set the newborn root in case v is otherwise unreferenced.
    1:              * It's ok to overwrite newborn roots here, since the getter
    1:              * called just above could have.  Unlike the common GC rooting
    1:              * model, our callers do not have to protect protop thanks to
    1:              * this newborn root, since they all immediately create a new
    1:              * instance that delegates to this object, or just query the
    1:              * prototype for its class.
    1:              */
33952:             cx->weakRoots.finalizableNewborns[FINALIZE_OBJECT] =
33952:                 JSVAL_TO_OBJECT(v);
38604:             if (cacheEntry) {
38604:                 cacheEntry->global = scope;
38604:                 cacheEntry->proto = JSVAL_TO_OBJECT(v);
38604:             }
    1:         }
    1:     }
    1:     *protop = JSVAL_IS_OBJECT(v) ? JSVAL_TO_OBJECT(v) : NULL;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * For shared precompilation of function objects, we support cloning on entry
    1:  * to an execution context in which the function declaration or expression
    1:  * should be processed as if it were not precompiled, where the precompiled
    1:  * function's scope chain does not match the execution context's.  The cloned
    1:  * function object carries its execution-context scope in its parent slot; it
    1:  * links to the precompiled function (the "clone-parent") via its proto slot.
    1:  *
    1:  * Note that this prototype-based delegation leaves an unchecked access path
    1:  * from the clone to the clone-parent's 'constructor' property.  If the clone
    1:  * lives in a less privileged or shared scope than the clone-parent, this is
    1:  * a security hole, a sharing hazard, or both.  Therefore we check all such
    1:  * accesses with the following getter/setter pair, which we use when defining
    1:  * 'constructor' in f.prototype for all function objects f.
    1:  */
    1: static JSBool
    1: CheckCtorGetAccess(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1:     uintN attrs;
    1: 
    1:     atom = cx->runtime->atomState.constructorAtom;
 4529:     JS_ASSERT(id == ATOM_TO_JSID(atom));
31501:     return obj->checkAccess(cx, ATOM_TO_JSID(atom), JSACC_READ, vp, &attrs);
    1: }
    1: 
    1: static JSBool
    1: CheckCtorSetAccess(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSAtom *atom;
    1:     uintN attrs;
    1: 
    1:     atom = cx->runtime->atomState.constructorAtom;
 4529:     JS_ASSERT(id == ATOM_TO_JSID(atom));
31501:     return obj->checkAccess(cx, ATOM_TO_JSID(atom), JSACC_WRITE, vp, &attrs);
    1: }
    1: 
    1: JSBool
    1: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto,
    1:                      uintN attrs)
    1: {
    1:     /*
    1:      * Use the given attributes for the prototype property of the constructor,
    1:      * as user-defined constructors have a DontDelete prototype (which may be
    1:      * reset), while native or "system" constructors have DontEnum | ReadOnly |
    1:      * DontDelete.
    1:      */
31501:     if (!ctor->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
31501:                               OBJECT_TO_JSVAL(proto), JS_PropertyStub, JS_PropertyStub,
32573:                               attrs)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * ECMA says that Object.prototype.constructor, or f.prototype.constructor
    1:      * for a user-defined function f, is DontEnum.
    1:      */
31501:     return proto->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
32573:                                  OBJECT_TO_JSVAL(ctor), CheckCtorGetAccess, CheckCtorSetAccess, 0);
    1: }
    1: 
    1: JSBool
 2383: js_PrimitiveToObject(JSContext *cx, jsval *vp)
 2383: {
 2383:     JSClass *clasp;
 2383:     JSObject *obj;
 2383: 
 2383:     /* Table to map primitive value's tag into the corresponding class. */
 2383:     JS_STATIC_ASSERT(JSVAL_INT == 1);
 2383:     JS_STATIC_ASSERT(JSVAL_DOUBLE == 2);
 2383:     JS_STATIC_ASSERT(JSVAL_STRING == 4);
31521:     JS_STATIC_ASSERT(JSVAL_SPECIAL == 6);
 2383:     static JSClass *const PrimitiveClasses[] = {
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_NumberClass,    /* DOUBLE  */
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_StringClass,    /* STRING  */
 2383:         &js_NumberClass,    /* INT     */
 2383:         &js_BooleanClass,   /* BOOLEAN */
 2383:         &js_NumberClass     /* INT     */
 2383:     };
 2383: 
 2383:     JS_ASSERT(!JSVAL_IS_OBJECT(*vp));
15521:     JS_ASSERT(!JSVAL_IS_VOID(*vp));
 2383:     clasp = PrimitiveClasses[JSVAL_TAG(*vp) - 1];
40858:     obj = NewObject(cx, clasp, NULL, NULL);
 2383:     if (!obj)
 2383:         return JS_FALSE;
40901:     obj->setPrimitiveThis(*vp);
 2383:     *vp = OBJECT_TO_JSVAL(obj);
 2383:     return JS_TRUE;
 2383: }
 2383: 
 2383: JSBool
    1: js_ValueToObject(JSContext *cx, jsval v, JSObject **objp)
    1: {
    1:     JSObject *obj;
    1: 
40867:     if (JSVAL_IS_OBJECT(v)) {
40867:         obj = JSVAL_TO_OBJECT(v);
40867:     } else if (JSVAL_IS_VOID(v)) {
    1:         obj = NULL;
    1:     } else {
 2383:         if (!js_PrimitiveToObject(cx, &v))
    1:             return JS_FALSE;
 2383:         obj = JSVAL_TO_OBJECT(v);
    1:     }
    1:     *objp = obj;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
    1: js_ValueToNonNullObject(JSContext *cx, jsval v)
    1: {
    1:     JSObject *obj;
    1: 
    1:     if (!js_ValueToObject(cx, v, &obj))
    1:         return NULL;
 7897:     if (!obj)
 7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
    1:     return obj;
    1: }
    1: 
    1: JSBool
    1: js_TryValueOf(JSContext *cx, JSObject *obj, JSType type, jsval *rval)
    1: {
    1:     jsval argv[1];
    1: 
    1:     argv[0] = ATOM_KEY(cx->runtime->atomState.typeAtoms[type]);
    1:     return js_TryMethod(cx, obj, cx->runtime->atomState.valueOfAtom, 1, argv,
    1:                         rval);
    1: }
    1: 
    1: JSBool
    1: js_TryMethod(JSContext *cx, JSObject *obj, JSAtom *atom,
    1:              uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSErrorReporter older;
    1:     jsid id;
    1:     jsval fval;
    1:     JSBool ok;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     /*
    1:      * Report failure only if an appropriate method was found, and calling it
    1:      * returned failure.  We propagate failure in this case to make exceptions
    1:      * behave properly.
    1:      */
    1:     older = JS_SetErrorReporter(cx, NULL);
    1:     id = ATOM_TO_JSID(atom);
    1:     fval = JSVAL_VOID;
32658:     ok = js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, &fval);
38621:     JS_SetErrorReporter(cx, older);
38619:     if (!ok)
38621:         return false;
    1: 
24499:     if (JSVAL_IS_PRIMITIVE(fval))
24499:         return JS_TRUE;
24499:     return js_InternalCall(cx, obj, fval, argc, argv, rval);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSAtom *atom;
    1:     JSClass *clasp;
    1:     uint32 classId, classDef;
    1:     JSProtoKey protoKey;
    1:     JSObject *proto;
    1: 
    1:     cx = xdr->cx;
    1:     atom = NULL;
    1:     if (xdr->mode == JSXDR_ENCODE) {
40826:         clasp = (*objp)->getClass();
    1:         classId = JS_XDRFindClassIdByName(xdr, clasp->name);
    1:         classDef = !classId;
    1:         if (classDef) {
    1:             if (!JS_XDRRegisterClass(xdr, clasp, &classId))
    1:                 return JS_FALSE;
    1:             protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:             if (protoKey != JSProto_Null) {
    1:                 classDef |= (protoKey << 1);
    1:             } else {
    1:                 atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         clasp = NULL;           /* quell GCC overwarning */
    1:         classDef = 0;
    1:     }
    1: 
    1:     /*
    1:      * XDR a flag word, which could be 0 for a class use, in which case no
    1:      * name follows, only the id in xdr's class registry; 1 for a class def,
    1:      * in which case the flag word is followed by the class name transferred
    1:      * from or to atom; or a value greater than 1, an odd number that when
    1:      * divided by two yields the JSProtoKey for class.  In the last case, as
    1:      * in the 0 classDef case, no name is transferred via atom.
    1:      */
    1:     if (!JS_XDRUint32(xdr, &classDef))
    1:         return JS_FALSE;
 4875:     if (classDef == 1 && !js_XDRStringAtom(xdr, &atom))
    1:         return JS_FALSE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &classId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         if (classDef) {
    1:             /* NB: we know that JSProto_Null is 0 here, for backward compat. */
 3164:             protoKey = (JSProtoKey) (classDef >> 1);
38604:             if (!js_GetClassPrototype(cx, NULL, protoKey, &proto, clasp))
    1:                 return JS_FALSE;
40826:             clasp = proto->getClass();
    1:             if (!JS_XDRRegisterClass(xdr, clasp, &classId))
    1:                 return JS_FALSE;
    1:         } else {
    1:             clasp = JS_XDRFindClassById(xdr, classId);
    1:             if (!clasp) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)classId);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_FIND_CLASS, numBuf);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!clasp->xdrObject) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_XDR_CLASS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->xdrObject(xdr, objp);
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
10217: #ifdef JS_DUMP_SCOPE_METERS
    1: 
    1: #include <stdio.h>
10217: 
10217: JSBasicStats js_entry_count_bs = JS_INIT_STATIC_BASIC_STATS;
    1: 
    1: static void
    1: MeterEntryCount(uintN count)
    1: {
10217:     JS_BASIC_STATS_ACCUM(&js_entry_count_bs, count);
10217: }
10217: 
    1: void
    1: js_DumpScopeMeters(JSRuntime *rt)
    1: {
    1:     static FILE *logfp;
    1:     if (!logfp)
    1:         logfp = fopen("/tmp/scope.stats", "a");
    1: 
    1:     {
10217:         double mean, sigma;
10217: 
10217:         mean = JS_MeanAndStdDevBS(&js_entry_count_bs, &sigma);
10217: 
10217:         fprintf(logfp, "scopes %u entries %g mean %g sigma %g max %u",
10217:                 js_entry_count_bs.num, js_entry_count_bs.sum, mean, sigma,
10217:                 js_entry_count_bs.max);
10217:     }
10217: 
10217:     JS_DumpHistogram(&js_entry_count_bs, logfp);
10217:     JS_BASIC_STATS_INIT(&js_entry_count_bs);
    1:     fflush(logfp);
    1: }
    1: #endif
    1: 
  583: #ifdef DEBUG
11835: void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
  583: {
32684:     JS_ASSERT(trc->debugPrinter == js_PrintObjectSlotName);
32684: 
32684:     JSObject *obj = (JSObject *)trc->debugPrintArg;
32684:     uint32 slot = (uint32)trc->debugPrintIndex;
32684:     JS_ASSERT(slot >= JSSLOT_START(obj->getClass()));
32684: 
  583:     JSScopeProperty *sprop;
40430:     if (obj->isNative()) {
40847:         JSScope *scope = obj->scope();
35334:         sprop = scope->lastProperty();
  583:         while (sprop && sprop->slot != slot)
  583:             sprop = sprop->parent;
11835:     } else {
11835:         sprop = NULL;
11835:     }
  583: 
  583:     if (!sprop) {
32684:         const char *slotname = NULL;
32684:         JSClass *clasp = obj->getClass();
  583:         if (clasp->flags & JSCLASS_IS_GLOBAL) {
32684:             uint32 key = slot - JSSLOT_START(clasp);
  583: #define JS_PROTO(name,code,init)                                              \
  583:     if ((code) == key) { slotname = js_##name##_str; goto found; }
  583: #include "jsproto.tbl"
  583: #undef JS_PROTO
  583:         }
  583:       found:
  583:         if (slotname)
  583:             JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
  583:         else
  583:             JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
  583:     } else {
32684:         jsval nval = ID_TO_VALUE(sprop->id);
  583:         if (JSVAL_IS_INT(nval)) {
  583:             JS_snprintf(buf, bufsize, "%ld", (long)JSVAL_TO_INT(nval));
  583:         } else if (JSVAL_IS_STRING(nval)) {
  583:             js_PutEscapedString(buf, bufsize, JSVAL_TO_STRING(nval), 0);
  583:         } else {
  583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
  583:         }
  583:     }
  583: }
  583: #endif
  583: 
  583: void
  583: js_TraceObject(JSTracer *trc, JSObject *obj)
    1: {
40430:     JS_ASSERT(obj->isNative());
32684: 
32684:     JSContext *cx = trc->context;
40847:     JSScope *scope = obj->scope();
37766:     if (!scope->isSharedEmpty() && IS_GC_MARKING_TRACER(trc)) {
11377:         /*
30645:          * Check whether we should shrink the object's slots. Skip this check
30645:          * if the scope is shared, since for Block objects and flat closures
30645:          * that share their scope, scope->freeslot can be an underestimate.
11377:          */
30454:         size_t slots = scope->freeslot;
40410:         if (obj->numSlots() != slots)
30454:             js_ShrinkSlots(cx, obj, slots);
30454:     }
30454: 
10217: #ifdef JS_DUMP_SCOPE_METERS
    1:     MeterEntryCount(scope->entryCount);
    1: #endif
    1: 
30852:     scope->trace(trc);
    1: 
 5816:     if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList))
 5816:         js_TraceWatchPoints(trc, obj);
    1: 
    1:     /* No one runs while the GC is running, so we can use LOCKED_... here. */
32684:     JSClass *clasp = obj->getClass();
  583:     if (clasp->mark) {
  583:         if (clasp->flags & JSCLASS_MARK_IS_TRACE)
11377:             ((JSTraceOp) clasp->mark)(trc, obj);
  583:         else if (IS_GC_MARKING_TRACER(trc))
  583:             (void) clasp->mark(cx, obj, trc);
  583:     }
    1: 
32603:     obj->traceProtoAndParent(trc);
32603: 
    1:     /*
11377:      * An unmutated object that shares a prototype object's scope. We can't
11377:      * tell how many slots are in use in obj by looking at its scope, so we
40410:      * use obj->numSlots().
11377:      *
11377:      * NB: In case clasp->mark mutates something, leave this code here --
11377:      * don't move it up and unify it with the |if (!traceScope)| section
11377:      * above.
    1:      */
40410:     uint32 nslots = obj->numSlots();
37766:     if (!scope->isSharedEmpty() && scope->freeslot < nslots)
28353:         nslots = scope->freeslot;
32684:     JS_ASSERT(nslots >= JSSLOT_START(clasp));
32684: 
32684:     for (uint32 i = JSSLOT_START(clasp); i != nslots; ++i) {
40410:         jsval v = obj->getSlot(i);
  583:         if (JSVAL_IS_TRACEABLE(v)) {
11835:             JS_SET_TRACING_DETAILS(trc, js_PrintObjectSlotName, obj, i);
38595:             js_CallGCMarker(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
  583:         }
  583:     }
    1: }
    1: 
    1: void
    1: js_Clear(JSContext *cx, JSObject *obj)
    1: {
    1:     JSScope *scope;
    1:     uint32 i, n;
    1: 
    1:     /*
    1:      * Clear our scope and the property cache of all obj's properties only if
30645:      * obj owns the scope (i.e., not if obj is sharing another object's scope).
30645:      * NB: we do not clear any reserved slots lying below JSSLOT_FREE(clasp).
    1:      */
    1:     JS_LOCK_OBJ(cx, obj);
40847:     scope = obj->scope();
37766:     if (!scope->isSharedEmpty()) {
    1:         /* Now that we're done using scope->lastProp/table, clear scope. */
30258:         scope->clear(cx);
    1: 
    1:         /* Clear slot values and reset freeslot so we're consistent. */
40410:         i = obj->numSlots();
32603:         n = JSSLOT_FREE(obj->getClass());
    1:         while (--i >= n)
40410:             obj->setSlot(i, JSVAL_VOID);
28353:         scope->freeslot = n;
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: 
32603: /* On failure the function unlocks the object. */
32603: static bool
32603: ReservedSlotIndexOK(JSContext *cx, JSObject *obj, JSClass *clasp,
32603:                     uint32 index, uint32 limit)
    1: {
32620:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
32603: 
32603:     /* Check the computed, possibly per-instance, upper bound. */
32603:     if (clasp->reserveSlots)
32603:         limit += clasp->reserveSlots(cx, obj);
32603:     if (index >= limit) {
32603:         JS_UNLOCK_OBJ(cx, obj);
32603:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
32603:                              JSMSG_RESERVED_SLOT_RANGE);
32603:         return false;
32603:     }
32603:     return true;
32603: }
32603: 
32603: bool
32603: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval *vp)
32603: {
40430:     if (!obj->isNative()) {
32603:         *vp = JSVAL_VOID;
32603:         return true;
32603:     }
32603: 
32603:     JSClass *clasp = obj->getClass();
32603:     uint32 limit = JSCLASS_RESERVED_SLOTS(clasp);
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
32603:     if (index >= limit && !ReservedSlotIndexOK(cx, obj, clasp, index, limit))
32603:         return false;
32603: 
32603:     uint32 slot = JSSLOT_START(clasp) + index;
40410:     *vp = (slot < obj->numSlots()) ? obj->getSlot(slot) : JSVAL_VOID;
    1:     JS_UNLOCK_OBJ(cx, obj);
32603:     return true;
32603: }
32603: 
32603: bool
32603: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 index, jsval v)
    1: {
40430:     if (!obj->isNative())
32603:         return true;
32603: 
40826:     JSClass *clasp = obj->getClass();
41804: 
41804:     JS_LOCK_OBJ(cx, obj);
41804: #ifdef DEBUG
32603:     uint32 limit = JSCLASS_RESERVED_SLOTS(clasp);
41799:     JS_ASSERT(index < limit || ReservedSlotIndexOK(cx, obj, clasp, index, limit));
41804: #endif
32603: 
32603:     uint32 slot = JSSLOT_START(clasp) + index;
35057:     if (slot >= JS_INITIAL_NSLOTS && !obj->dslots) {
    1:         /*
30645:          * At this point, obj may or may not own scope, and we may or may not
30645:          * need to allocate dslots. If scope is shared, scope->freeslot may not
30645:          * be accurate for obj (see comment below).
    1:          */
32603:         uint32 nslots = JSSLOT_FREE(clasp);
    1:         if (clasp->reserveSlots)
    1:             nslots += clasp->reserveSlots(cx, obj);
    1:         JS_ASSERT(slot < nslots);
40858:         if (!js_AllocSlots(cx, obj, nslots)) {
32603:             JS_UNLOCK_OBJ(cx, obj);
32603:             return false;
    1:         }
    1:     }
    1: 
30645:     /*
30645:      * Whether or not we grew nslots, we may need to advance freeslot.
30645:      *
30645:      * If scope is shared, do not modify scope->freeslot. It is OK for freeslot
30645:      * to be an underestimate in objects with shared scopes, as they will get
30645:      * their own scopes before mutating, and elsewhere (e.g. js_TraceObject) we
40410:      * use obj->numSlots() rather than rely on freeslot.
30645:      */
40847:     JSScope *scope = obj->scope();
37766:     if (!scope->isSharedEmpty() && slot >= scope->freeslot)
28353:         scope->freeslot = slot + 1;
    1: 
40410:     obj->setSlot(slot, v);
25939:     GC_POKE(cx, JS_NULL);
    1:     JS_UNLOCK_SCOPE(cx, scope);
32603:     return true;
    1: }
    1: 
12674: JSObject *
12674: js_GetWrappedObject(JSContext *cx, JSObject *obj)
12674: {
12674:     JSClass *clasp;
12674: 
40826:     clasp = obj->getClass();
12674:     if (clasp->flags & JSCLASS_IS_EXTENDED) {
12674:         JSExtendedClass *xclasp;
12674:         JSObject *obj2;
12674: 
12674:         xclasp = (JSExtendedClass *)clasp;
12674:         if (xclasp->wrappedObject && (obj2 = xclasp->wrappedObject(cx, obj)))
12674:             return obj2;
12674:     }
12674:     return obj;
12674: }
12674: 
40424: JSObject *
40424: JSObject::getGlobal()
40424: {
40424:     JSObject *obj = this;
40424:     while (JSObject *parent = obj->getParent())
40424:         obj = parent;
40424:     return obj;
40424: }
40424: 
38630: bool
38638: JSObject::isCallable()
38638: {
38638:     if (isNative())
38638:         return isFunction() || getClass()->call;
38638: 
39928:     return !!map->ops->call;
26059: }
26059: 
36491: JSBool
27641: js_ReportGetterOnlyAssignment(JSContext *cx)
27641: {
36491:     return JS_ReportErrorFlagsAndNumber(cx,
36491:                                         JSREPORT_WARNING | JSREPORT_STRICT |
36491:                                         JSREPORT_STRICT_MODE_ERROR,
36491:                                         js_GetErrorMessage, NULL,
36491:                                         JSMSG_GETTER_ONLY);
27641: }
27641: 
27641: JS_FRIEND_API(JSBool)
27641: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
27641: {
36491:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_GETTER_ONLY);
27641:     return JS_FALSE;
27641: }
27641: 
24294: #ifdef DEBUG
19714: 
19714: /*
19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
19714:  * into other code.
19714:  */
19714: 
19714: void
19714: dumpChars(const jschar *s, size_t n)
19714: {
19714:     size_t i;
19714: 
19714:     if (n == (size_t) -1) {
19714:         while (s[++n]) ;
19714:     }
19714: 
    1:     fputc('"', stderr);
19714:     for (i = 0; i < n; i++) {
19714:         if (s[i] == '\n')
19714:             fprintf(stderr, "\\n");
19714:         else if (s[i] == '\t')
19714:             fprintf(stderr, "\\t");
19714:         else if (s[i] >= 32 && s[i] < 127)
19714:             fputc(s[i], stderr);
19714:         else if (s[i] <= 255)
19714:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
19714:         else
19714:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
19714:     }
19714:     fputc('"', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpChars(const jschar *s, size_t n)
19714: {
19714:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
19714:     dumpChars(s, n);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: void
19714: dumpString(JSString *str)
19714: {
29366:     dumpChars(str->chars(), str->length());
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpString(JSString *str)
19714: {
19714:     fprintf(stderr, "JSString* (%p) = jschar * (%p) = ",
29366:             (void *) str, (void *) str->chars());
19714:     dumpString(str);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: JS_FRIEND_API(void)
19714: js_DumpAtom(JSAtom *atom)
19714: {
19714:     fprintf(stderr, "JSAtom* (%p) = ", (void *) atom);
19714:     js_DumpValue(ATOM_KEY(atom));
19714: }
19714: 
19714: void
19714: dumpValue(jsval val)
19714: {
19714:     if (JSVAL_IS_NULL(val)) {
19714:         fprintf(stderr, "null");
19714:     } else if (JSVAL_IS_VOID(val)) {
19714:         fprintf(stderr, "undefined");
40855:     } else if (JSVAL_IS_OBJECT(val) && JSVAL_TO_OBJECT(val)->isFunction()) {
26674:         JSObject *funobj = JSVAL_TO_OBJECT(val);
31452:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
26674:         fprintf(stderr, "<%s %s at %p (JSFunction at %p)>",
26674:                 fun->atom ? "function" : "unnamed",
26674:                 fun->atom ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom)) : "function",
26674:                 (void *) funobj,
26674:                 (void *) fun);
19714:     } else if (JSVAL_IS_OBJECT(val)) {
19714:         JSObject *obj = JSVAL_TO_OBJECT(val);
40410:         JSClass *cls = obj->getClass();
19714:         fprintf(stderr, "<%s%s at %p>",
19714:                 cls->name,
19714:                 cls == &js_ObjectClass ? "" : " object",
25218:                 (void *) obj);
19714:     } else if (JSVAL_IS_INT(val)) {
19714:         fprintf(stderr, "%d", JSVAL_TO_INT(val));
19714:     } else if (JSVAL_IS_STRING(val)) {
19714:         dumpString(JSVAL_TO_STRING(val));
19714:     } else if (JSVAL_IS_DOUBLE(val)) {
19714:         fprintf(stderr, "%g", *JSVAL_TO_DOUBLE(val));
19714:     } else if (val == JSVAL_TRUE) {
19714:         fprintf(stderr, "true");
19714:     } else if (val == JSVAL_FALSE) {
19714:         fprintf(stderr, "false");
19714:     } else if (val == JSVAL_HOLE) {
19714:         fprintf(stderr, "hole");
19714:     } else {
19714:         /* jsvals are pointer-sized, and %p is portable */
19714:         fprintf(stderr, "unrecognized jsval %p", (void *) val);
19714:     }
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpValue(jsval val)
19714: {
28665:     fprintf(stderr, "jsval %p = ", (void *) val);
19714:     dumpValue(val);
19714:     fputc('\n', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpId(jsid id)
19714: {
28665:     fprintf(stderr, "jsid %p = ", (void *) id);
19714:     dumpValue(ID_TO_VALUE(id));
19714:     fputc('\n', stderr);
19714: }
19714: 
20208: static void
19714: dumpScopeProp(JSScopeProperty *sprop)
19714: {
19714:     jsid id = sprop->id;
40265:     uint8 attrs = sprop->attributes();
19714: 
19714:     fprintf(stderr, "    ");
19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
19714:     if (attrs & JSPROP_GETTER) fprintf(stderr, "getter ");
19714:     if (attrs & JSPROP_SETTER) fprintf(stderr, "setter ");
19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
38562:     if (sprop->isAlias()) fprintf(stderr, "alias ");
19714:     if (JSID_IS_ATOM(id))
19714:         dumpString(JSVAL_TO_STRING(ID_TO_VALUE(id)));
19714:     else if (JSID_IS_INT(id))
19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
19714:     else
19714:         fprintf(stderr, "unknown jsid %p", (void *) id);
19714:     fprintf(stderr, ": slot %d", sprop->slot);
19714:     fprintf(stderr, "\n");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpObject(JSObject *obj)
19714: {
19714:     uint32 i, slots;
    1:     JSClass *clasp;
19714:     jsuint reservedEnd;
    1: 
13437:     fprintf(stderr, "object %p\n", (void *) obj);
40410:     clasp = obj->getClass();
    1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
19714: 
37003:     if (obj->isDenseArray()) {
41782:         slots = JS_MIN(obj->getArrayLength(), obj->getDenseArrayCapacity());
19714:         fprintf(stderr, "elements\n");
13437:         for (i = 0; i < slots; i++) {
19714:             fprintf(stderr, " %3d: ", i);
41782:             dumpValue(obj->getDenseArrayElement(i));
19714:             fprintf(stderr, "\n");
19714:             fflush(stderr);
19714:         }
13437:         return;
13437:     }
13437: 
40430:     if (obj->isNative()) {
40847:         JSScope *scope = obj->scope();
30258:         if (scope->sealed())
19714:             fprintf(stderr, "sealed\n");
19714: 
19714:         fprintf(stderr, "properties:\n");
35334:         for (JSScopeProperty *sprop = scope->lastProperty(); sprop;
19714:              sprop = sprop->parent) {
19714:             dumpScopeProp(sprop);
19714:         }
19714:     } else {
40430:         if (!obj->isNative())
19714:             fprintf(stderr, "not native\n");
19714:     }
19714: 
31452:     fprintf(stderr, "proto ");
39928:     dumpValue(OBJECT_TO_JSVAL(obj->getProto()));
31452:     fputc('\n', stderr);
31452: 
31452:     fprintf(stderr, "parent ");
39930:     dumpValue(OBJECT_TO_JSVAL(obj->getParent()));
31452:     fputc('\n', stderr);
31452: 
31452:     i = JSSLOT_PRIVATE;
31452:     if (clasp->flags & JSCLASS_HAS_PRIVATE) {
31452:         i = JSSLOT_PRIVATE + 1;
31452:         fprintf(stderr, "private %p\n", obj->getPrivate());
31452:     }
31452: 
19714:     fprintf(stderr, "slots:\n");
31452:     reservedEnd = i + JSCLASS_RESERVED_SLOTS(clasp);
40847:     slots = (obj->isNative() && !obj->scope()->isSharedEmpty())
40847:             ? obj->scope()->freeslot
40410:             : obj->numSlots();
31452:     for (; i < slots; i++) {
19714:         fprintf(stderr, " %3d ", i);
31452:         if (i < reservedEnd)
19714:             fprintf(stderr, "(reserved) ");
19714:         fprintf(stderr, "= ");
40410:         dumpValue(obj->getSlot(i));
19714:         fputc('\n', stderr);
19714:     }
19714:     fputc('\n', stderr);
    1: }
    1: 
28665: static void
28665: MaybeDumpObject(const char *name, JSObject *obj)
28665: {
28665:     if (obj) {
28665:         fprintf(stderr, "  %s: ", name);
28665:         dumpValue(OBJECT_TO_JSVAL(obj));
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
32774: static void
32774: MaybeDumpValue(const char *name, jsval v)
32774: {
32774:     if (!JSVAL_IS_NULL(v)) {
32774:         fprintf(stderr, "  %s: ", name);
32774:         dumpValue(v);
32774:         fputc('\n', stderr);
32774:     }
32774: }
32774: 
28665: JS_FRIEND_API(void)
28665: js_DumpStackFrame(JSStackFrame *fp)
28665: {
28665:     jsval *sp = NULL;
28665: 
28665:     for (; fp; fp = fp->down) {
28665:         fprintf(stderr, "JSStackFrame at %p\n", (void *) fp);
31939:         if (fp->argv)
31939:             dumpValue(fp->argv[-2]);
28665:         else
28665:             fprintf(stderr, "global frame, no callee");
28665:         fputc('\n', stderr);
28665: 
28665:         if (fp->script)
28665:             fprintf(stderr, "file %s line %u\n", fp->script->filename, (unsigned) fp->script->lineno);
28665: 
28665:         if (fp->regs) {
28665:             if (!fp->regs->pc) {
28665:                 fprintf(stderr, "*** regs && !regs->pc, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             if (!fp->script) {
28665:                 fprintf(stderr, "*** regs && !script, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             jsbytecode *pc = fp->regs->pc;
28665:             sp = fp->regs->sp;
28665:             if (fp->imacpc) {
28665:                 fprintf(stderr, "  pc in imacro at %p\n  called from ", pc);
28665:                 pc = fp->imacpc;
28665:             } else {
28665:                 fprintf(stderr, "  ");
28665:             }
28665:             fprintf(stderr, "pc = %p\n", pc);
28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
28665:         }
28665:         if (sp && fp->slots) {
28690:             fprintf(stderr, "  slots: %p\n", (void *) fp->slots);
28690:             fprintf(stderr, "  sp:    %p = slots + %u\n", (void *) sp, (unsigned) (sp - fp->slots));
28665:             if (sp - fp->slots < 10000) { // sanity
28665:                 for (jsval *p = fp->slots; p < sp; p++) {
28665:                     fprintf(stderr, "    %p: ", (void *) p);
28665:                     dumpValue(*p);
28665:                     fputc('\n', stderr);
28665:                 }
28665:             }
28665:         } else {
28665:             fprintf(stderr, "  sp:    %p\n", (void *) sp);
28665:             fprintf(stderr, "  slots: %p\n", (void *) fp->slots);
28665:         }
28690:         fprintf(stderr, "  argv:  %p (argc: %u)\n", (void *) fp->argv, (unsigned) fp->argc);
28665:         MaybeDumpObject("callobj", fp->callobj);
30248:         MaybeDumpObject("argsobj", JSVAL_TO_OBJECT(fp->argsobj));
32774:         MaybeDumpValue("this", fp->thisv);
28665:         fprintf(stderr, "  rval: ");
28665:         dumpValue(fp->rval);
28665:         fputc('\n', stderr);
28665: 
28665:         fprintf(stderr, "  flags:");
28665:         if (fp->flags == 0)
28665:             fprintf(stderr, " none");
28665:         if (fp->flags & JSFRAME_CONSTRUCTING)
28665:             fprintf(stderr, " constructing");
28665:         if (fp->flags & JSFRAME_COMPUTED_THIS)
28665:             fprintf(stderr, " computed_this");
28665:         if (fp->flags & JSFRAME_ASSIGNING)
28665:             fprintf(stderr, " assigning");
28665:         if (fp->flags & JSFRAME_DEBUGGER)
28665:             fprintf(stderr, " debugger");
28665:         if (fp->flags & JSFRAME_EVAL)
28665:             fprintf(stderr, " eval");
28665:         if (fp->flags & JSFRAME_ROOTED_ARGV)
28665:             fprintf(stderr, " rooted_argv");
28665:         if (fp->flags & JSFRAME_YIELDING)
28665:             fprintf(stderr, " yielding");
28665:         if (fp->flags & JSFRAME_ITERATOR)
28665:             fprintf(stderr, " iterator");
28665:         if (fp->flags & JSFRAME_GENERATOR)
28665:             fprintf(stderr, " generator");
31823:         if (fp->flags & JSFRAME_OVERRIDE_ARGS)
31823:             fprintf(stderr, " overridden_args");
28665:         fputc('\n', stderr);
28665: 
28665:         if (fp->scopeChain)
28665:             fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) fp->scopeChain);
28665:         if (fp->blockChain)
28665:             fprintf(stderr, "  blockChain: (JSObject *) %p\n", (void *) fp->blockChain);
28665: 
28665:         if (fp->displaySave)
28690:             fprintf(stderr, "  displaySave: (JSStackFrame *) %p\n", (void *) fp->displaySave);
28665: 
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
    1: #endif
