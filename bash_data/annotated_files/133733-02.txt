     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* the interface (to internal code) for retrieving computed style data */
     1: 
     1: #ifndef _nsStyleContext_h_
     1: #define _nsStyleContext_h_
     1: 
     1: #include "nsRuleNode.h"
     1: #include "nsIAtom.h"
 35554: #include "nsCSSPseudoElements.h"
     1: 
     1: class nsPresContext;
     1: 
     1: /**
     1:  * An nsStyleContext represents the computed style data for an element.
     1:  * The computed style data are stored in a set of structs (see
     1:  * nsStyleStruct.h) that are cached either on the style context or in
     1:  * the rule tree (see nsRuleNode.h for a description of this caching and
     1:  * how the cached structs are shared).
     1:  *
     1:  * Since the data in |nsIStyleRule|s and |nsRuleNode|s are immutable
     1:  * (with a few exceptions, like system color changes), the data in an
     1:  * nsStyleContext are also immutable (with the additional exception of
     1:  * GetUniqueStyleData).  When style data change,
     1:  * nsFrameManager::ReResolveStyleContext creates a new style context.
     1:  *
     1:  * Style contexts are reference counted.  References are generally held
     1:  * by:
     1:  *  1. the |nsIFrame|s that are using the style context and
     1:  *  2. any *child* style contexts (this might be the reverse of
     1:  *     expectation, but it makes sense in this case)
     1:  * Style contexts participate in the mark phase of rule node garbage
     1:  * collection.
     1:  */
     1: 
     1: class nsStyleContext
     1: {
     1: public:
114265:   /**
114265:    * Create a new style context.
114265:    * @param aParent  The parent of a style context is used for CSS
114265:    *                 inheritance.  When the element or pseudo-element
114265:    *                 this style context represents the style data of
114265:    *                 inherits a CSS property, the value comes from the
114265:    *                 parent style context.  This means style context
114265:    *                 parentage must match the definitions of inheritance
114265:    *                 in the CSS specification.
114265:    * @param aPseudoTag  The pseudo-element or anonymous box for which
114265:    *                    this style context represents style.  Null if
114265:    *                    this style context is for a normal DOM element.
114265:    * @param aPseudoType  Must match aPseudoTag.
114265:    * @param aRuleNode  A rule node representing the ordered sequence of
114265:    *                   rules that any element, pseudo-element, or
114265:    *                   anonymous box that this style context is for
114265:    *                   matches.  See |nsRuleNode| and |nsIStyleRule|.
133733:    * @param aSkipFlexItemStyleFixup
133733:    *                 If set, this flag indicates that we should skip
133733:    *                 the chunk of ApplyStyleFixups() that modifies flex
133733:    *                 items' display values.
114265:    */
     1:   nsStyleContext(nsStyleContext* aParent, nsIAtom* aPseudoTag,
 35554:                  nsCSSPseudoElements::Type aPseudoType,
133733:                  nsRuleNode* aRuleNode,
133733:                  bool aSkipFlexItemStyleFixup);
 40517:   ~nsStyleContext();
     1: 
 40517:   void* operator new(size_t sz, nsPresContext* aPresContext) CPP_THROW_NEW;
 40517:   void Destroy();
     1: 
     1:   nsrefcnt AddRef() {
115367:     if (mRefCnt == UINT32_MAX) {
 23136:       NS_WARNING("refcount overflow, leaking object");
 23136:       return mRefCnt;
 23136:     }
     1:     ++mRefCnt;
     1:     NS_LOG_ADDREF(this, mRefCnt, "nsStyleContext", sizeof(nsStyleContext));
     1:     return mRefCnt;
     1:   }
     1: 
     1:   nsrefcnt Release() {
115367:     if (mRefCnt == UINT32_MAX) {
 23136:       NS_WARNING("refcount overflow, leaking object");
 23136:       return mRefCnt;
 23136:     }
     1:     --mRefCnt;
     1:     NS_LOG_RELEASE(this, mRefCnt, "nsStyleContext");
     1:     if (mRefCnt == 0) {
     1:       Destroy();
     1:       return 0;
     1:     }
     1:     return mRefCnt;
     1:   }
     1: 
132811:   nsPresContext* PresContext() const { return mRuleNode->PresContext(); }
     1: 
     1:   nsStyleContext* GetParent() const { return mParent; }
     1: 
 34387:   nsIAtom* GetPseudo() const { return mPseudoTag; }
 35554:   nsCSSPseudoElements::Type GetPseudoType() const {
 35554:     return static_cast<nsCSSPseudoElements::Type>(mBits >>
 35554:                                                   NS_STYLE_CONTEXT_TYPE_SHIFT);
 35554:   }
     1: 
 40187:   // Find, if it already exists *and is easily findable* (i.e., near the
 40187:   // start of the child list), a style context whose:
 40187:   //  * GetPseudo() matches aPseudoTag
132810:   //  * RuleNode() matches aRules
 40187:   //  * !GetStyleIfVisited() == !aRulesIfVisited, and, if they're
132810:   //    non-null, GetStyleIfVisited()->RuleNode() == aRulesIfVisited
 40187:   //  * RelevantLinkVisited() == aRelevantLinkVisited
 40517:   already_AddRefed<nsStyleContext>
 40187:   FindChildWithRules(const nsIAtom* aPseudoTag, nsRuleNode* aRules,
 40187:                      nsRuleNode* aRulesIfVisited,
 79445:                      bool aRelevantLinkVisited);
     1: 
 31306:   // Does this style context or any of its ancestors have text
 68819:   // decoration lines?
 79445:   bool HasTextDecorationLines() const
 68819:     { return !!(mBits & NS_STYLE_HAS_TEXT_DECORATION_LINES); }
 31306: 
 31306:   // Does this style context represent the style for a pseudo-element or
 31306:   // inherit data from such a style context?  Whether this returns true
 31306:   // is equivalent to whether it or any of its ancestors returns
 34387:   // non-null for GetPseudo.
 79445:   bool HasPseudoElementData() const
 31306:     { return !!(mBits & NS_STYLE_HAS_PSEUDO_ELEMENT_DATA); }
     1: 
 40172:   // Is the only link whose visitedness is allowed to influence the
 40172:   // style of the node this style context is for (which is that element
 40172:   // or its nearest ancestor that is a link) visited?
 79445:   bool RelevantLinkVisited() const
 40172:     { return !!(mBits & NS_STYLE_RELEVANT_LINK_VISITED); }
 40172: 
 43326:   // Is this a style context for a link?
 79445:   bool IsLinkContext() const {
 43326:     return
 43326:       GetStyleIfVisited() && GetStyleIfVisited()->GetParent() == GetParent();
 43326:   }
 43326: 
 40497:   // Is this style context the GetStyleIfVisited() for some other style
 40497:   // context?
 79445:   bool IsStyleIfVisited() const
 40497:     { return !!(mBits & NS_STYLE_IS_STYLE_IF_VISITED); }
 40497: 
 40497:   // Tells this style context that it should return true from
 40497:   // IsStyleIfVisited.
 40497:   void SetIsStyleIfVisited()
 40497:     { mBits |= NS_STYLE_IS_STYLE_IF_VISITED; }
 40497: 
 40172:   // Return the style context whose style data should be used for the R,
 40172:   // G, and B components of color, background-color, and border-*-color
 40172:   // if RelevantLinkIsVisited().
 40172:   //
 40172:   // GetPseudo() and GetPseudoType() on this style context return the
 40172:   // same as on |this|, and its depth in the tree (number of GetParent()
 40172:   // calls until null is returned) is the same as |this|, since its
 40172:   // parent is either |this|'s parent or |this|'s parent's
 40172:   // style-if-visited.
 40172:   //
 40172:   // Structs on this context should never be examined without also
 40172:   // examining the corresponding struct on |this|.  Doing so will likely
 40172:   // both (1) lead to a privacy leak and (2) lead to dynamic change bugs
 40172:   // related to the Peek code in nsStyleContext::CalcStyleDifference.
 43326:   nsStyleContext* GetStyleIfVisited() const
 40172:     { return mStyleIfVisited; }
 40172: 
 40172:   // To be called only from nsStyleSet.
 40172:   void SetStyleIfVisited(already_AddRefed<nsStyleContext> aStyleIfVisited)
 40172:   {
 40497:     NS_ABORT_IF_FALSE(!IsStyleIfVisited(), "this context is not visited data");
 40497:     NS_ABORT_IF_FALSE(aStyleIfVisited.get()->IsStyleIfVisited(),
 40497:                       "other context is visited data");
 40497:     NS_ABORT_IF_FALSE(!aStyleIfVisited.get()->GetStyleIfVisited(),
 40497:                       "other context does not have visited data");
 40172:     NS_ASSERTION(!mStyleIfVisited, "should only be set once");
 40172:     mStyleIfVisited = aStyleIfVisited;
 40172: 
 40172:     NS_ASSERTION(GetStyleIfVisited()->GetPseudo() == GetPseudo(),
 40172:                  "pseudo tag mismatch");
 40172:     if (GetParent() && GetParent()->GetStyleIfVisited()) {
 40172:       NS_ASSERTION(GetStyleIfVisited()->GetParent() ==
 40172:                      GetParent()->GetStyleIfVisited() ||
 40172:                    GetStyleIfVisited()->GetParent() == GetParent(),
 40172:                    "parent mismatch");
 40172:     } else {
 40172:       NS_ASSERTION(GetStyleIfVisited()->GetParent() == GetParent(),
 40172:                    "parent mismatch");
 40172:     }
 40172:   }
 40172: 
 38861:   // Tell this style context to cache aStruct as the struct for aSID
 40517:   void SetStyle(nsStyleStructID aSID, void* aStruct);
     1: 
 38861:   // Setters for inherit structs only, since rulenode only sets those eagerly.
 38861:   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)          \
 38861:     void SetStyle##name_ (nsStyle##name_ * aStruct) {                       \
 63757:       void *& slot =                                                        \
 63757:         mCachedInheritedData.mStyleStructs[eStyleStruct_##name_];           \
 63757:       NS_ASSERTION(!slot ||                                                 \
 38861:                    (mBits &                                                 \
 38861:                     nsCachedStyleData::GetBitForSID(eStyleStruct_##name_)), \
 38861:                    "Going to leak styledata");                              \
 63757:       slot = aStruct;                                                       \
 38861:     }
 38861: #define STYLE_STRUCT_RESET(name_, checkdata_cb_, ctor_args_) /* nothing */
 38861:   #include "nsStyleStructList.h"
 38861:   #undef STYLE_STRUCT_RESET
 38861:   #undef STYLE_STRUCT_INHERITED
 38861: 
132810:   nsRuleNode* RuleNode() { return mRuleNode; }
108991:   void AddStyleBit(const uint32_t& aBit) { mBits |= aBit; }
     1: 
     1:   /*
     1:    * Mark this style context's rule node (and its ancestors) to prevent
     1:    * it from being garbage collected.
     1:    */
 40517:   void Mark();
     1: 
     1:   /*
     1:    * Get the style data for a style struct.  This is the most important
     1:    * member function of nsIStyleContext.  It fills in a const pointer
     1:    * to a style data struct that is appropriate for the style context's
     1:    * frame.  This struct may be shared with other contexts (either in
     1:    * the rule tree or the style context tree), so it should not be
     1:    * modified.
     1:    *
     1:    * This function will NOT return null (even when out of memory) when
     1:    * given a valid style struct ID, so the result does not need to be
     1:    * null-checked.
     1:    *
     1:    * The typesafe functions below are preferred to the use of this
114259:    * function, both because they're easier to read and because they're
 38860:    * faster.
     1:    */
132813:   const void* NS_FASTCALL StyleData(nsStyleStructID aSID);
     1: 
     1:   /**
     1:    * Define typesafe getter functions for each style struct by
     1:    * preprocessing the list of style structs.  These functions are the
     1:    * preferred way to get style data.  The macro creates functions like:
132812:    *   const nsStyleBorder* StyleBorder();
132812:    *   const nsStyleColor* StyleColor();
     1:    */
     1:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
132812:     const nsStyle##name_ * Style##name_() {               \
 80486:       return DoGetStyle##name_(true);                     \
 38860:     }
     1:   #include "nsStyleStructList.h"
     1:   #undef STYLE_STRUCT
     1: 
 38860:   /**
 38860:    * PeekStyle* is like GetStyle* but doesn't trigger style
 38860:    * computation if the data is not cached on either the style context
 38860:    * or the rule node.
 38860:    *
 38860:    * Perhaps this shouldn't be a public nsStyleContext API.
 38860:    */
 38860:   #define STYLE_STRUCT(name_, checkdata_cb_, ctor_args_)  \
 38860:     const nsStyle##name_ * PeekStyle##name_() {           \
 80486:       return DoGetStyle##name_(false);                    \
 38860:     }
 38860:   #include "nsStyleStructList.h"
 38860:   #undef STYLE_STRUCT
     1: 
 40517:   void* GetUniqueStyleData(const nsStyleStructID& aSID);
     1: 
111449:   /**
111449:    * Compute the style changes needed during restyling when this style
111449:    * context is being replaced by aOther.  (This is nonsymmetric since
111449:    * we optimize by skipping comparison for styles that have never been
111449:    * requested.)
111449:    *
111449:    * This method returns a change hint (see nsChangeHint.h).  All change
111449:    * hints apply to the frame and its later continuations or special
111449:    * siblings.  Most (all of those except the "NotHandledForDescendants"
111449:    * hints) also apply to all descendants.  The caller must pass in any
111449:    * non-inherited hints that resulted from the parent style context's
111449:    * style change.  The caller *may* pass more hints than needed, but
111449:    * must not pass less than needed; therefore if the caller doesn't
111449:    * know, the caller should pass
111449:    * nsChangeHint_Hints_NotHandledForDescendants.
111449:    */
111449:   nsChangeHint CalcStyleDifference(nsStyleContext* aOther,
111449:                                    nsChangeHint aParentHintsNotHandledForDescendants);
     1: 
 40173:   /**
 40173:    * Get a color that depends on link-visitedness using this and
 40173:    * this->GetStyleIfVisited().
 40173:    *
 40173:    * aProperty must be a color-valued property that nsStyleAnimation
 40173:    * knows how to extract.  It must also be a property that we know to
 40173:    * do change handling for in nsStyleContext::CalcDifference.
 40179:    *
 40179:    * Note that if aProperty is eCSSProperty_border_*_color, this
 40179:    * function handles -moz-use-text-color.
 40173:    */
 40517:   nscolor GetVisitedDependentColor(nsCSSProperty aProperty);
 40173: 
 40183:   /**
 40183:    * aColors should be a two element array of nscolor in which the first
 40183:    * color is the unvisited color and the second is the visited color.
 40183:    *
 40183:    * Combine the R, G, and B components of whichever of aColors should
 40183:    * be used based on aLinkIsVisited with the A component of aColors[0].
 40183:    */
 40183:   static nscolor CombineVisitedColors(nscolor *aColors,
 79445:                                       bool aLinkIsVisited);
 40183: 
 47177:   /**
 47177:    * Allocate a chunk of memory that is scoped to the lifetime of this
 47177:    * style context, i.e., memory that will automatically be freed when
 47177:    * this style context is destroyed.  This is intended for allocations
 47177:    * that are stored on this style context or its style structs.  (Use
 47177:    * on style structs is fine since any style context to which this
 47177:    * context's style structs are shared will be a descendant of this
 47177:    * style context and thus keep it alive.)
 47177:    *
 47177:    * This currently allocates the memory out of the pres shell arena.
 47177:    *
 47177:    * It would be relatively straightforward to write a Free method
 47177:    * for the underlying implementation, but we don't need it (or the
 47177:    * overhead of making a doubly-linked list or other structure to
 47177:    * support it).
 47177:    *
 47177:    * WARNING: Memory allocated using this method cannot be stored in the
 47177:    * rule tree, since rule nodes may outlive the style context.
 47177:    */
 47177:   void* Alloc(size_t aSize);
 47177: 
 62083:   /**
 62083:    * Start the background image loads for this style context.
 62083:    */
 62083:   void StartBackgroundImageLoads() {
 62083:     // Just get our background struct; that should do the trick
132812:     StyleBackground();
 62083:   }
 62083: 
     1: #ifdef DEBUG
108991:   void List(FILE* out, int32_t aIndent);
     1: #endif
     1: 
     1: protected:
 40517:   void AddChild(nsStyleContext* aChild);
 40517:   void RemoveChild(nsStyleContext* aChild);
     1: 
133733:   void ApplyStyleFixups(bool aSkipFlexItemStyleFixup);
     1: 
 47177:   void FreeAllocations(nsPresContext* aPresContext);
 47177: 
 38860:   // Helper function that GetStyleData and GetUniqueStyleData use.  Only
 38860:   // returns the structs we cache ourselves; never consults the ruletree.
 38860:   inline const void* GetCachedStyleData(nsStyleStructID aSID);
 38860: 
 38860:   // Helper functions for GetStyle* and PeekStyle*
 38860:   #define STYLE_STRUCT_INHERITED(name_, checkdata_cb_, ctor_args_)      \
 79445:     const nsStyle##name_ * DoGetStyle##name_(bool aComputeData) {     \
 38860:       const nsStyle##name_ * cachedData =                               \
 63757:         static_cast<nsStyle##name_*>(                                   \
 63757:           mCachedInheritedData.mStyleStructs[eStyleStruct_##name_]);    \
 38860:       if (cachedData) /* Have it cached already, yay */                 \
 38860:         return cachedData;                                              \
 38860:       /* Have the rulenode deal */                                      \
 38860:       return mRuleNode->GetStyle##name_(this, aComputeData);            \
 38860:     }
 38860:   #define STYLE_STRUCT_RESET(name_, checkdata_cb_, ctor_args_)          \
 79445:     const nsStyle##name_ * DoGetStyle##name_(bool aComputeData) {     \
 63757:       const nsStyle##name_ * cachedData = mCachedResetData              \
 63757:         ? static_cast<nsStyle##name_*>(                                 \
 63757:             mCachedResetData->mStyleStructs[eStyleStruct_##name_])      \
106838:         : nullptr;                                                       \
 38860:       if (cachedData) /* Have it cached already, yay */                 \
 38860:         return cachedData;                                              \
 38860:       /* Have the rulenode deal */                                      \
 38860:       return mRuleNode->GetStyle##name_(this, aComputeData);            \
 38860:     }
 38860:   #include "nsStyleStructList.h"
 38860:   #undef STYLE_STRUCT_RESET
 38860:   #undef STYLE_STRUCT_INHERITED
 38860: 
 40172:   nsStyleContext* const mParent; // STRONG
     1: 
     1:   // Children are kept in two circularly-linked lists.  The list anchor
     1:   // is not part of the list (null for empty), and we point to the first
     1:   // child.
     1:   // mEmptyChild for children whose rule node is the root rule node, and
     1:   // mChild for other children.  The order of children is not
     1:   // meaningful.
     1:   nsStyleContext* mChild;
     1:   nsStyleContext* mEmptyChild;
     1:   nsStyleContext* mPrevSibling;
     1:   nsStyleContext* mNextSibling;
     1: 
 40172:   // Style to be used instead for the R, G, and B components of color,
 40172:   // background-color, and border-*-color if the nearest ancestor link
 40172:   // element is visited (see RelevantLinkVisited()).
 40172:   nsRefPtr<nsStyleContext> mStyleIfVisited;
 40172: 
 34387:   // If this style context is for a pseudo-element or anonymous box,
 34387:   // the relevant atom.
     1:   nsCOMPtr<nsIAtom> mPseudoTag;
     1: 
     1:   // The rule node is the node in the lexicographic tree of rule nodes
     1:   // (the "rule tree") that indicates which style rules are used to
     1:   // compute the style data, and in what cascading order.  The least
     1:   // specific rule matched is the one whose rule node is a child of the
     1:   // root of the rule tree, and the most specific rule matched is the
     1:   // |mRule| member of |mRuleNode|.
     1:   nsRuleNode* const       mRuleNode;
     1: 
 47177:   // Private to nsStyleContext::Alloc and FreeAllocations.
 47177:   struct AllocationHeader {
 47177:     AllocationHeader* mNext;
 47177:     size_t mSize;
 47177: 
 47177:     void* mStorageStart; // ensure the storage is at least pointer-aligned
 47177:   };
 47177:   AllocationHeader*       mAllocations;
 47177: 
 38860:   // mCachedInheritedData and mCachedResetData point to both structs that
 38860:   // are owned by this style context and structs that are owned by one of
 38860:   // this style context's ancestors (which are indirectly owned since this
 38860:   // style context owns a reference to its parent).  If the bit in |mBits|
 38860:   // is set for a struct, that means that the pointer for that struct is
 38861:   // owned by an ancestor or by mRuleNode rather than by this style context.
 38860:   // Since style contexts typically have some inherited data but only sometimes
 38860:   // have reset data, we always allocate the mCachedInheritedData, but only
 38860:   // sometimes allocate the mCachedResetData.
 38860:   nsResetStyleData*       mCachedResetData; // Cached reset style data.
 38860:   nsInheritedStyleData    mCachedInheritedData; // Cached inherited style data
108991:   uint32_t                mBits; // Which structs are inherited from the
 38861:                                  // parent context or owned by mRuleNode.
108991:   uint32_t                mRefCnt;
     1: };
     1: 
 40517: already_AddRefed<nsStyleContext>
     1: NS_NewStyleContext(nsStyleContext* aParentContext,
     1:                    nsIAtom* aPseudoTag,
 35554:                    nsCSSPseudoElements::Type aPseudoType,
133733:                    nsRuleNode* aRuleNode,
133733:                    bool aSkipFlexItemStyleFixup);
     1: #endif
