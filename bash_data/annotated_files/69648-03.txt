53573: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53573:  * vim: set ts=8 sw=4 et tw=78:
53573:  *
53573:  * ***** BEGIN LICENSE BLOCK *****
53573:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
53573:  *
53573:  * The contents of this file are subject to the Mozilla Public License Version
53573:  * 1.1 (the "License"); you may not use this file except in compliance with
53573:  * the License. You may obtain a copy of the License at
53573:  * http://www.mozilla.org/MPL/
53573:  *
53573:  * Software distributed under the License is distributed on an "AS IS" basis,
53573:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
53573:  * for the specific language governing rights and limitations under the
53573:  * License.
53573:  *
53573:  * The Original Code is Mozilla XPConnect  code, released
53573:  * June 30, 2009.
53573:  *
53573:  * The Initial Developer of the Original Code is
53573:  *    The Mozilla Foundation
53573:  *
53573:  * Contributor(s):
53573:  *    Andreas Gal <gal@mozilla.com>
53573:  *
53573:  * Alternatively, the contents of this file may be used under the terms of
53573:  * either of the GNU General Public License Version 2 or later (the "GPL"),
53573:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
53573:  * in which case the provisions of the GPL or the LGPL are applicable instead
53573:  * of those above. If you wish to allow use of your version of this file only
53573:  * under the terms of either the GPL or the LGPL, and not to allow others to
53573:  * use your version of this file under the terms of the MPL, indicate your
53573:  * decision by deleting the provisions above and replace them with the notice
53573:  * and other provisions required by the GPL or the LGPL. If you do not delete
53573:  * the provisions above, a recipient may use your version of this file under
53573:  * the terms of any one of the MPL, the GPL or the LGPL.
53573:  *
53573:  * ***** END LICENSE BLOCK ***** */
53573: 
53573: #ifndef xpcpublic_h
53573: #define xpcpublic_h
53573: 
53573: #include "jsapi.h"
62366: #include "jsobj.h"
62366: #include "jsgc.h"
62366: 
58714: #include "nsISupports.h"
57854: #include "nsIPrincipal.h"
57854: #include "nsWrapperCache.h"
56703: 
56703: class nsIPrincipal;
53573: 
62690: static const uint32 XPC_GC_COLOR_BLACK = 0;
62690: static const uint32 XPC_GC_COLOR_GRAY = 1;
62690: 
53573: nsresult
53573: xpc_CreateGlobalObject(JSContext *cx, JSClass *clasp,
56703:                        nsIPrincipal *principal, nsISupports *ptr,
56473:                        bool wantXrays, JSObject **global,
55675:                        JSCompartment **compartment);
53573: 
56703: nsresult
56703: xpc_CreateMTGlobalObject(JSContext *cx, JSClass *clasp,
56703:                          nsISupports *ptr, JSObject **global,
56703:                          JSCompartment **compartment);
56703: 
60616: // XXX where should this live?
60616: NS_EXPORT_(void)
60616: xpc_LocalizeContext(JSContext *cx);
60616: 
58714: nsresult
58714: xpc_MorphSlimWrapper(JSContext *cx, nsISupports *tomorph);
58714: 
57854: extern JSBool
57854: XPC_WN_Equality(JSContext *cx, JSObject *obj, const jsval *v, JSBool *bp);
57854: 
57854: #define IS_WRAPPER_CLASS(clazz)                                               \
57854:     (clazz->ext.equality == js::Valueify(XPC_WN_Equality))
57854: 
57854: inline JSBool
57854: DebugCheckWrapperClass(JSObject* obj)
57854: {
57854:     NS_ASSERTION(IS_WRAPPER_CLASS(obj->getClass()),
57854:                  "Forgot to check if this is a wrapper?");
57854:     return JS_TRUE;
57854: }
57854: 
57854: // If IS_WRAPPER_CLASS for the JSClass of an object is true, the object can be
57854: // a slim wrapper, holding a native in its private slot, or a wrappednative
57854: // wrapper, holding the XPCWrappedNative in its private slot. A slim wrapper
57854: // also holds a pointer to its XPCWrappedNativeProto in a reserved slot, we can
57854: // check that slot for a non-void value to distinguish between the two.
57854: 
57854: // Only use these macros if IS_WRAPPER_CLASS(obj->getClass()) is true.
57854: #define IS_WN_WRAPPER_OBJECT(obj)                                             \
57854:     (DebugCheckWrapperClass(obj) && obj->getSlot(0).isUndefined())
57854: #define IS_SLIM_WRAPPER_OBJECT(obj)                                           \
57854:     (DebugCheckWrapperClass(obj) && !obj->getSlot(0).isUndefined())
57854: 
57854: // Use these macros if IS_WRAPPER_CLASS(obj->getClass()) might be false.
57854: // Avoid calling them if IS_WRAPPER_CLASS(obj->getClass()) can only be
57854: // true, as we'd do a redundant call to IS_WRAPPER_CLASS.
57854: #define IS_WN_WRAPPER(obj)                                                    \
57854:     (IS_WRAPPER_CLASS(obj->getClass()) && IS_WN_WRAPPER_OBJECT(obj))
57854: #define IS_SLIM_WRAPPER(obj)                                                  \
57854:     (IS_WRAPPER_CLASS(obj->getClass()) && IS_SLIM_WRAPPER_OBJECT(obj))
57854: 
57854: inline JSObject *
57854: xpc_GetGlobalForObject(JSObject *obj)
57854: {
57854:     while(JSObject *parent = obj->getParent())
57854:         obj = parent;
57854:     return obj;
57854: }
57854: 
63538: extern bool
63538: xpc_OkToHandOutWrapper(nsWrapperCache *cache);
63538: 
57854: inline JSObject*
63538: xpc_FastGetCachedWrapper(nsWrapperCache *cache, JSObject *scope, jsval *vp)
57854: {
57854:     if (cache) {
57854:         JSObject* wrapper = cache->GetWrapper();
63538:         NS_ASSERTION(!wrapper ||
63538:                      !cache->IsProxy() ||
63538:                      !IS_SLIM_WRAPPER_OBJECT(wrapper),
63538:                      "Should never have a slim wrapper when IsProxy()");
57854:         if (wrapper &&
63538:             wrapper->compartment() == scope->getCompartment() &&
63538:             (IS_SLIM_WRAPPER_OBJECT(wrapper) ||
63538:              xpc_OkToHandOutWrapper(cache))) {
57854:             *vp = OBJECT_TO_JSVAL(wrapper);
57854:             return wrapper;
57854:         }
57854:     }
57854: 
57854:     return nsnull;
57854: }
57854: 
59004: inline JSObject*
63538: xpc_FastGetCachedWrapper(nsWrapperCache *cache, JSObject *scope)
59004: {
59004:     jsval dummy;
63538:     return xpc_FastGetCachedWrapper(cache, scope, &dummy);
59004: }
59004: 
69648: // The JS GC marks objects gray that are held alive directly or
69648: // indirectly by an XPConnect root. The cycle collector explores only
69648: // this subset of the JS heap.  JSStaticAtoms cause this to crash,
69648: // because they are statically allocated in the data segment and thus
69648: // are not really GCThings.
62690: inline JSBool
62690: xpc_IsGrayGCThing(void *thing)
62690: {
62690:     return js_GCThingIsMarked(thing, XPC_GC_COLOR_GRAY);
62690: }
62690: 
69648: // The cycle collector only cares about JS objects and XML objects that
69648: // are held alive directly or indirectly by an XPConnect root.  This
69648: // version is preferred to xpc_IsGrayGCThing when it isn't known if thing
69648: // is a JSString or not. Implemented in nsXPConnect.cpp.
69648: extern JSBool
69648: xpc_GCThingIsGrayCCThing(void *thing);
69648: 
62690: // Implemented in nsXPConnect.cpp.
62690: extern void
62690: xpc_UnmarkGrayObjectRecursive(JSObject* obj);
62690: 
62690: // Remove the gray color from the given JSObject and any other objects that can
62690: // be reached through it.
62690: inline void
62690: xpc_UnmarkGrayObject(JSObject *obj)
62690: {
62690:     if(obj && xpc_IsGrayGCThing(obj))
62690:         xpc_UnmarkGrayObjectRecursive(obj);
62690: }
62690: 
62690: inline JSObject*
62690: nsWrapperCache::GetWrapper() const
62690: {
62690:   JSObject* obj = GetWrapperPreserveColor();
62690:   xpc_UnmarkGrayObject(obj);
62690:   return obj;
62690: }
62690: 
53573: #endif
