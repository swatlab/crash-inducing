55647: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 3213: /* ***** BEGIN LICENSE BLOCK *****
 3213:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 3213:  *
 3213:  * The contents of this file are subject to the Mozilla Public License Version
 3213:  * 1.1 (the "License"); you may not use this file except in compliance with
 3213:  * the License. You may obtain a copy of the License at
 3213:  * http://www.mozilla.org/MPL/
 3213:  *
 3213:  * Software distributed under the License is distributed on an "AS IS" basis,
 3213:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 3213:  * for the specific language governing rights and limitations under the
 3213:  * License.
 3213:  *
 3213:  * The Original Code is Mozilla code.
 3213:  *
 3213:  * The Initial Developer of the Original Code is Alex Fritze.
 3213:  * Portions created by the Initial Developer are Copyright (C) 2004
 3213:  * the Initial Developer. All Rights Reserved.
 3213:  *
 3213:  * Contributor(s):
 3213:  *   Alex Fritze <alex@croczilla.com> (original author)
 3213:  *
 3213:  * Alternatively, the contents of this file may be used under the terms of
 3213:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 3213:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 3213:  * in which case the provisions of the GPL or the LGPL are applicable instead
 3213:  * of those above. If you wish to allow use of your version of this file only
 3213:  * under the terms of either the GPL or the LGPL, and not to allow others to
 3213:  * use your version of this file under the terms of the MPL, indicate your
 3213:  * decision by deleting the provisions above and replace them with the notice
 3213:  * and other provisions required by the GPL or the LGPL. If you do not delete
 3213:  * the provisions above, a recipient may use your version of this file under
 3213:  * the terms of any one of the MPL, the GPL or the LGPL.
 3213:  *
 3213:  * ***** END LICENSE BLOCK ***** */
 3213: 
38922: #include "xpcprivate.h"
33405: #include "xpcJSWeakReference.h"
 3213: 
 3213: xpcJSWeakReference::xpcJSWeakReference()
 3213: {
 3213: }
 3213: 
 3213: NS_IMPL_ISUPPORTS1(xpcJSWeakReference, xpcIJSWeakReference)
 3213: 
 3213: nsresult xpcJSWeakReference::Init()
 3213: {
 3213:     nsresult rv;
 3213:     
 3213:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
 3213:     if (!xpc) return NS_ERROR_UNEXPECTED;
 3213:     
10286:     nsAXPCNativeCallContext *cc = nsnull;
10286:     rv = xpc->GetCurrentNativeCallContext(&cc);
 3213:     NS_ENSURE_SUCCESS(rv, rv);
 3213: 
 3213:     JSContext *cx = nsnull;
 3213:     rv = cc->GetJSContext(&cx);
 3213:     NS_ENSURE_SUCCESS(rv, rv);
 3213: 
 3213:     PRUint32 argc = 0;
 3213:     rv = cc->GetArgc(&argc);
 3213:     NS_ENSURE_SUCCESS(rv, rv);
 3213: 
 3213:     if (argc != 1) return NS_ERROR_FAILURE;
 3213:     
 3213:     jsval *argv = nsnull;
 3213:     rv = cc->GetArgvPtr(&argv);
 3213:     NS_ENSURE_SUCCESS(rv, rv);
 3213: 
 6251:     JSAutoRequest ar(cx);
 6251: 
78299:     if (JSVAL_IS_PRIMITIVE(argv[0])) return NS_ERROR_FAILURE;
 3213:     
78299:     JSObject *obj = JSVAL_TO_OBJECT(argv[0]);
 3213:     
 3213:     XPCCallContext ccx(NATIVE_CALLER, cx);
 3213:     
 3213:     nsRefPtr<nsXPCWrappedJS> wrapped;
 3213:     rv = nsXPCWrappedJS::GetNewOrUsed(ccx,
 3213:                                       obj,
 3213:                                       NS_GET_IID(nsISupports),
 3213:                                       nsnull,
 3213:                                       getter_AddRefs(wrapped));
 3213:     if (!wrapped) {
 3213:         NS_ERROR("can't get nsISupportsWeakReference wrapper for obj");
 3213:         return rv;
 3213:     }
 3213: 
 3213:     return static_cast<nsISupportsWeakReference*>(wrapped)->
 3213:         GetWeakReference(getter_AddRefs(mWrappedJSObject));
 3213: }
 3213: 
 3213: NS_IMETHODIMP
 3213: xpcJSWeakReference::Get()
 3213: {
 3213:     nsresult rv;
 3213: 
 3213:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
29974:     if (!xpc)
29974:         return NS_ERROR_UNEXPECTED;
 3213: 
10286:     nsAXPCNativeCallContext* cc = nsnull;
10286:     rv = xpc->GetCurrentNativeCallContext(&cc);
 3213:     NS_ENSURE_SUCCESS(rv, rv);
 3213: 
29974:     JSContext *cx;
29974:     cc->GetJSContext(&cx);
29974:     if (!cx)
29974:         return NS_ERROR_UNEXPECTED;
29974: 
 3213:     jsval *retval = nsnull;
 3213:     cc->GetRetValPtr(&retval);
29974:     if (!retval)
29974:         return NS_ERROR_UNEXPECTED;
 3213:     *retval = JSVAL_NULL;
 3213: 
 3213:     nsCOMPtr<nsIXPConnectWrappedJS> wrappedObj;
 3213: 
 3213:     if (mWrappedJSObject &&
 3213:         NS_SUCCEEDED(mWrappedJSObject->QueryReferent(NS_GET_IID(nsIXPConnectWrappedJS), getter_AddRefs(wrappedObj))) &&
 3213:         wrappedObj) {
 3213:         JSObject *obj;
 3213:         wrappedObj->GetJSObject(&obj);
 3213:         if (obj)
29974:         {
29974:             // Most users of XPCWrappedJS don't need to worry about
29974:             // re-wrapping because things are implicitly rewrapped by
29974:             // xpcconvert. However, because we're doing this directly
29974:             // through the native call context, we need to call
55647:             // JS_WrapObject().
42679: 
55647:             if (!JS_WrapObject(cx, &obj))
29974:             {
29974:                 return NS_ERROR_FAILURE;
29974:             }
42679: 
 3213:             *retval = OBJECT_TO_JSVAL(obj);
 3213:         }
29974:     }
 3213: 
 3213:     return NS_OK;
 3213: }
