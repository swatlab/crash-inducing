16299: /*
16299:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16299:    Organisation (CSIRO) Australia
16299: 
16299:    Redistribution and use in source and binary forms, with or without
16299:    modification, are permitted provided that the following conditions
16299:    are met:
16299: 
16299:    - Redistributions of source code must retain the above copyright
16299:    notice, this list of conditions and the following disclaimer.
16299: 
16299:    - Redistributions in binary form must reproduce the above copyright
16299:    notice, this list of conditions and the following disclaimer in the
16299:    documentation and/or other materials provided with the distribution.
16299: 
16299:    - Neither the name of CSIRO Australia nor the names of its
16299:    contributors may be used to endorse or promote products derived from
16299:    this software without specific prior written permission.
16299: 
16299:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16299:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16299:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16299:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16299:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16299:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16299:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16299:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16299:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16299:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16299:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16299: */
16299: 
16299: /*
16299:  * oggplay_buffer.c
16299:  *
16299:  * Shane Stephens <shane.stephens@annodex.net>
16299:  */
16299: 
16299: #include "oggplay_private.h"
16299: 
16299: #include <stdlib.h>
16299: #include <string.h>
16299: 
16299: #define OGGPLAY_DEFAULT_BUFFER_SIZE   20
16299: #define WRAP_INC(c, s) ((c + 1) % s)
16299: 
16299: 
16299: 
16299: /*
16299:  * Call this function to initialise the oggplay lock-free buffer.  Do not use
16299:  * the buffer and the callback together!
16299:  */
16299: OggPlayBuffer *
16299: oggplay_buffer_new_buffer(int size) {
16299: 
25830:   OggPlayBuffer *buffer = NULL;
16299:   if (size < 0) {
16299:     size = OGGPLAY_DEFAULT_BUFFER_SIZE;
16299:   }
16299: 
26904:   buffer = (OggPlayBuffer*)oggplay_calloc(1, sizeof (OggPlayBuffer));
16299: 
25830:   if (buffer == NULL)
25830:     return NULL;
25830: 
25830:   buffer->buffer_list = oggplay_calloc(size, sizeof (void *));
25830:   if (buffer->buffer_list == NULL)
25830:     goto error;
25830: 
25830:   buffer->buffer_mirror = oggplay_calloc(size, sizeof (void *));
25830:   if (buffer->buffer_mirror == NULL)
25830:     goto error;
16299: 
16299:   buffer->buffer_size = size;
16299:   buffer->last_filled = -1;
16299:   buffer->last_emptied = -1;
16299: 
25830:   if (SEM_CREATE(buffer->frame_sem, size) != 0)
25830:     goto error;
16299: 
16299:   return buffer;
16299: 
25830: error:
25830:   if (buffer->buffer_list != NULL)
25830:     oggplay_free (buffer->buffer_list);
25830: 
25830:   if (buffer->buffer_mirror != NULL)
25830:     oggplay_free (buffer->buffer_mirror);
25830: 
25830:   oggplay_free (buffer);
25830: 
25830:   return NULL;
16299: }
16299: 
16299: void
16299: oggplay_buffer_shutdown(OggPlay *me, volatile OggPlayBuffer *vbuffer) {
16299: 
16299:   int i;
16299:   int j;
16299: 
16299:   OggPlayBuffer *buffer = (OggPlayBuffer *)vbuffer;
16299:   
33012:   if (buffer == NULL) {
33012:     return;
33012:   }
33012: 
33012:   if (buffer->buffer_mirror != NULL) {
16299:     for (i = 0; i < buffer->buffer_size; i++) {
33012:       
16299:       if (buffer->buffer_mirror[i] != NULL) {
16299:         OggPlayCallbackInfo *ti = (OggPlayCallbackInfo *)buffer->buffer_mirror[i];
16299:         for (j = 0; j < me->num_tracks; j++) {
33012:           if ( (ti+j) != NULL) {
25830:             oggplay_free((ti + j)->records);
16299:           }
33012:         }
25830:         oggplay_free(ti);
16299:       }
33012:       
33012:     }
33012:     oggplay_free(buffer->buffer_mirror);
16299:   }
16299: 
33012:   if (buffer->buffer_list != NULL) 
25830:     oggplay_free(buffer->buffer_list);
33012:     
16299:   SEM_CLOSE(buffer->frame_sem);
25830:   oggplay_free(buffer);
33012:   buffer = NULL;
16299: }
16299: 
16299: int
16299: oggplay_buffer_is_full(volatile OggPlayBuffer *buffer) {
16299: 
16299:   return
16299:   (
16299:     (buffer == NULL) || (
16299:       buffer->buffer_list[WRAP_INC(buffer->last_filled, buffer->buffer_size)]
16299:       !=
16299:       NULL
16299:     )
16299:   );
16299: 
16299: }
16299: 
16299: int
16299: oggplay_buffer_callback(OggPlay *me, int tracks,
16299:                         OggPlayCallbackInfo **track_info, void *user) {
16299: 
16299:   int                   i;
16299:   int                   j;
16299:   int                   k;
16299:   OggPlayDataHeader  ** headers;
16299:   OggPlayBuffer       * buffer;
16299:   OggPlayCallbackInfo * ptr = track_info[0];
16299:   int                   required;
16299: 
25830:   if (me == NULL)
25830:     return -1;
25830: 
16299:   buffer = (OggPlayBuffer *)me->buffer;
16299: 
16299:   if (buffer == NULL) {
16299:     return -1;
16299:   }
16299: 
16299:   SEM_WAIT(buffer->frame_sem);
16299: 
16299:   if (me->shutdown) {
16299:     return -1;
16299:   }
16299: 
16299:   /*
16299:    * lock the item going into the buffer so that it doesn't get cleaned up
16299:    */
16299:   for (i = 0; i < tracks; i++) {
16299:     headers = oggplay_callback_info_get_headers(track_info[i]);
16299:     required = oggplay_callback_info_get_required(track_info[i]);
16299:     for (j = 0; j < required; j++) {
16299:       oggplay_callback_info_lock_item(headers[j]);
16299:     }
16299:   }
16299: 
16299:   /*
16299:    * check for and clean up empties
16299:    */
16299:   for (k = 0; k < buffer->buffer_size; k++) {
16299:     if
16299:     (
16299:       (buffer->buffer_list[k] == NULL)
16299:       &&
16299:       (buffer->buffer_mirror[k] != NULL)
33012:     ) 
33012:     {
16299:       OggPlayCallbackInfo *ti = (OggPlayCallbackInfo *)buffer->buffer_mirror[k];
16299:       for (i = 0; i < tracks; i++) {
16299:         headers = oggplay_callback_info_get_headers(ti + i);
16299:         required = oggplay_callback_info_get_required(ti + i);
16299:         for (j = 0; j < required; j++) {
16299:           oggplay_callback_info_unlock_item(headers[j]);
16299:         }
16299:         /* free these here, because we couldn't free them in
16299:          * oggplay_callback_info_destroy for buffer mode
16299:          */
33012:         if ((ti + i) != NULL) {
25830:           oggplay_free((ti + i)->records);
16299:         }
33012:       }
25830:       oggplay_free(ti);
16299:       buffer->buffer_mirror[k] = NULL;
16299:     }
16299:   }
16299: 
16299:   /*
16299:    * replace the decode_data buffer for the next callback
16299:    */
25830:   me->callback_info = 
25830:     (OggPlayCallbackInfo *)oggplay_calloc(me->num_tracks, sizeof (OggPlayCallbackInfo));
25830:   if (me->callback_info == NULL)
25830:     return -1;
16299: 
16299:   /*
16299:    * fill both mirror and list, mirror first to avoid getting inconsistencies
16299:    */
16299: 
16299:   buffer->last_filled = WRAP_INC(buffer->last_filled, buffer->buffer_size);
16299: 
16299:   /*
16299:    * set the buffer pointer in the first record
16299:    */
16299:   ptr->buffer = buffer;
16299: 
16299:   buffer->buffer_mirror[buffer->last_filled] = ptr;
16299:   buffer->buffer_list[buffer->last_filled] = ptr;
16299: 
16299: 
16299:   if (oggplay_buffer_is_full(buffer)) {
16299:     /*
16299:      * user interrupt when we fill the buffer rather than when we have a
16299:      * decoded frame and the buffer is already full
16299:      */
16299:     return -1;
16299:   }
16299: 
16299:   return 0;
16299: }
16299: 
16299: OggPlayCallbackInfo **
16299: oggplay_buffer_retrieve_next(OggPlay *me) {
16299: 
33012:   OggPlayBuffer         * buffer = NULL;
16299:   int                     next_loc;
16299:   OggPlayCallbackInfo   * next_item;
16299:   OggPlayCallbackInfo  ** return_val;
16299:   int                     i;
16299: 
16299:   if (me == NULL) {
16299:     return NULL;
16299:   }
16299: 
16299:   buffer = (OggPlayBuffer *)me->buffer;
16299: 
16299:   if (buffer == NULL) {
16299:     return NULL;
16299:   }
16299: 
16299:   next_loc = WRAP_INC(buffer->last_emptied, buffer->buffer_size);
16299: 
16299:   if (buffer->buffer_list[next_loc] == NULL) {
16299:     return NULL;
16299:   }
16299: 
16299:   next_item = (OggPlayCallbackInfo*)buffer->buffer_list[next_loc];
16299:   buffer->last_emptied = next_loc;
16299: 
25830:   return_val = oggplay_calloc(me->num_tracks, sizeof (OggPlayCallbackInfo *));
33012:   if (return_val == NULL) {
25830:     return NULL;
33012:   }
16299:   
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     return_val[i] = next_item + i;
16299:   }
16299: 
16299:   return return_val;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_buffer_release(OggPlay *me, OggPlayCallbackInfo **track_info) {
16299: 
33012:   OggPlayBuffer *buffer = NULL;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (track_info == NULL) {
16299:     return E_OGGPLAY_OK;
16299:   }
16299: 
16299:   buffer = (OggPlayBuffer *)track_info[0]->buffer;
16299: 
16299:   if (buffer == NULL) {
16299:     return E_OGGPLAY_CALLBACK_MODE;
16299:   }
16299: 
16299:   if (buffer->buffer_list[buffer->last_emptied] == NULL) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
33012:   if (track_info != NULL) {
25830:     oggplay_free(track_info);
33012:   }
16299: 
16299:   buffer->buffer_list[buffer->last_emptied] = NULL;
16299: 
16299:   SEM_SIGNAL(buffer->frame_sem);
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_use_buffer(OggPlay *me, int size) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->callback != NULL) {
16299:     return E_OGGPLAY_CALLBACK_MODE;
16299:   }
16299: 
16299:   if (me->buffer != NULL) {
16299:     /*
16299:      * we should check sizes, and maybe clear and reallocate the buffer?
16299:      */
16299:     return E_OGGPLAY_OK;
16299:   }
16299: 
25830:   if( (me->buffer = oggplay_buffer_new_buffer(size)) == NULL)
25830:     return E_OGGPLAY_OUT_OF_MEMORY;
16299: 
16299:   /*
16299:    * if oggplay is already initialised, then prepare the buffer now
16299:    */
16299:   if (me->all_tracks_initialised) {
16299:     oggplay_buffer_prepare(me);
16299:   }
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
16299: 
16299: void
16299: oggplay_buffer_prepare(OggPlay *me) {
16299: 
16299:   int i;
16299: 
25830:   if (me == NULL)
25830:     return;
25830: 
16299:   oggplay_set_data_callback_force(me, &oggplay_buffer_callback, NULL);
16299: 
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     if (oggplay_get_track_type(me, i) == OGGZ_CONTENT_THEORA) {
16299:       oggplay_set_callback_num_frames(me, i, 1);
16299:       break;
16299:     }
16299:   }
16299: 
16299: }
