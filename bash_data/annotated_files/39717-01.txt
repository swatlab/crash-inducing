33486: /* vim: se cin sw=2 ts=2 et : */
33486: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
33486:  *
33486:  * ***** BEGIN LICENSE BLOCK *****
33486:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33486:  *
33486:  * The contents of this file are subject to the Mozilla Public License Version
33486:  * 1.1 (the "License"); you may not use this file except in compliance with
33486:  * the License. You may obtain a copy of the License at
33486:  * http://www.mozilla.org/MPL/
33486:  *
33486:  * Software distributed under the License is distributed on an "AS IS" basis,
33486:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33486:  * for the specific language governing rights and limitations under the
33486:  * License.
33486:  *
33486:  * The Original Code is mozilla.org code.
33486:  *
33486:  * The Initial Developer of the Original Code is
33486:  * Mozilla Foundation.
33486:  * Portions created by the Initial Developer are Copyright (C) 2009
33486:  * the Initial Developer. All Rights Reserved.
33486:  *
33486:  * Contributor(s):
33486:  *   Rob Arnold <tellrob@gmail.com>
33486:  *
33486:  * Alternatively, the contents of this file may be used under the terms of
33486:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33486:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33486:  * in which case the provisions of the GPL or the LGPL are applicable instead
33486:  * of those above. If you wish to allow use of your version of this file only
33486:  * under the terms of either the GPL or the LGPL, and not to allow others to
33486:  * use your version of this file under the terms of the MPL, indicate your
33486:  * decision by deleting the provisions above and replace them with the notice
33486:  * and other provisions required by the GPL or the LGPL. If you do not delete
33486:  * the provisions above, a recipient may use your version of this file under
33486:  * the terms of any one of the MPL, the GPL or the LGPL.
33486:  *
33486:  * ***** END LICENSE BLOCK ***** */
33486: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486: 
33486: #include "TaskbarPreview.h"
33486: #include <nsITaskbarPreviewController.h>
33486: #include <windows.h>
33486: 
33486: #include <nsError.h>
33486: #include <nsCOMPtr.h>
33486: #include <nsIWidget.h>
33486: #include <nsIBaseWindow.h>
33486: #include <nsIObserverService.h>
33486: #include <nsServiceManagerUtils.h>
33486: 
33486: #include "nsUXThemeData.h"
33486: #include "nsWindow.h"
33486: #include "nsAppShell.h"
33486: #include "TaskbarPreviewButton.h"
33486: 
33486: #include <nsIBaseWindow.h>
33486: #include <nsICanvasRenderingContextInternal.h>
33486: #include <nsIDOMCanvasRenderingContext2D.h>
33486: #include <imgIContainer.h>
33486: #include <nsIDocShell.h>
33486: 
33486: // Defined in dwmapi in a header that needs a higher numbered _WINNT #define
33486: #define DWM_SIT_DISPLAYFRAME 0x1
33486: 
33486: namespace mozilla {
33486: namespace widget {
33486: 
33486: namespace {
33486: /* Helper method to create a canvas rendering context backed by the given surface
33486:  *
33486:  * @param shell The docShell used by the canvas context for text settings and other
33486:  *              misc things.
33486:  * @param surface The gfxSurface backing the context
33486:  * @param width The width of the given surface
33486:  * @param height The height of the given surface
33486:  * @param aCtx Out-param - a canvas context backed by the given surface
33486:  */
33486: nsresult
33486: CreateRenderingContext(nsIDocShell *shell, gfxASurface *surface, PRUint32 width, PRUint32 height, nsICanvasRenderingContextInternal **aCtx) {
33486:   nsresult rv;
33486:   nsCOMPtr<nsICanvasRenderingContextInternal> ctx(do_CreateInstance(
33486:     "@mozilla.org/content/canvas-rendering-context;1?id=2d", &rv));
33486:   NS_ENSURE_SUCCESS(rv, rv);
33486:   rv = ctx->InitializeWithSurface(shell, surface, width, height);
33486:   NS_ENSURE_SUCCESS(rv, rv);
33486: 
33486:   NS_ADDREF(*aCtx = ctx);
33486:   return NS_OK;
33486: }
33486: 
33486: }
33486: 
33486: TaskbarPreview::TaskbarPreview(ITaskbarList4 *aTaskbar, nsITaskbarPreviewController *aController, HWND aHWND, nsIDocShell *aShell)
33486:   : mTaskbar(aTaskbar),
33486:     mController(aController),
33486:     mWnd(aHWND),
33486:     mVisible(PR_FALSE),
33486:     mDocShell(do_GetWeakReference(aShell))
33486: {
33486:   // TaskbarPreview may outlive the WinTaskbar that created it
33486:   ::CoInitialize(NULL);
33486: 
33486:   WindowHook &hook = GetWindowHook();
33486:   hook.AddMonitor(WM_DESTROY, MainWindowHook, this);
33486: }
33486: 
33486: TaskbarPreview::~TaskbarPreview() {
33486:   // Avoid dangling pointer
33486:   if (sActivePreview == this)
33486:     sActivePreview = nsnull;
33486: 
33486:   // Here we remove the hook since this preview is dying before the nsWindow
33486:   if (mWnd)
33486:     DetachFromNSWindow(PR_TRUE);
33486: 
33486:   // Make sure to release before potentially uninitializing COM
33486:   mTaskbar = NULL;
33486: 
33486:   ::CoUninitialize();
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::SetController(nsITaskbarPreviewController *aController) {
33486:   NS_ENSURE_ARG(aController);
33486: 
33486:   mController = aController;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::GetController(nsITaskbarPreviewController **aController) {
33486:   NS_ADDREF(*aController = mController);
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::GetTooltip(nsAString &aTooltip) {
33486:   aTooltip = mTooltip;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::SetTooltip(const nsAString &aTooltip) {
33486:   mTooltip = aTooltip;
33486:   return CanMakeTaskbarCalls() ? UpdateTooltip() : NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::SetVisible(PRBool visible) {
33486:   if (mVisible == visible) return NS_OK;
33486:   mVisible = visible;
33486: 
39717:   // If the nsWindow has already been destroyed but the caller is still trying
39717:   // to use it then just pretend that everything succeeded.  The caller doesn't
39717:   // actually have a way to detect this since it's the same case as when we
39717:   // CanMakeTaskbarCalls returns false.
39717:   if (!mWnd)
39717:     return NS_OK;
39717: 
33486:   return visible ? Enable() : Disable();
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::GetVisible(PRBool *visible) {
33486:   *visible = mVisible;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::SetActive(PRBool active) {
33486:   if (active)
33486:     sActivePreview = this;
33486:   else if (sActivePreview == this)
33486:     sActivePreview = NULL;
33486: 
33486:   return CanMakeTaskbarCalls() ? ShowActive(active) : NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::GetActive(PRBool *active) {
33486:   *active = sActivePreview == this;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::Invalidate() {
33486:   if (!mVisible)
33486:     return NS_ERROR_FAILURE;
33486: 
33486:   // DWM Composition is required for previews
33486:   if (!nsUXThemeData::CheckForCompositor())
33486:     return NS_OK;
33486: 
33486:   HWND previewWindow = PreviewWindow();
33486:   return FAILED(nsUXThemeData::dwmInvalidateIconicBitmapsPtr(previewWindow))
33486:        ? NS_ERROR_FAILURE
33486:        : NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarPreview::UpdateTaskbarProperties() {
33486:   nsresult rv = UpdateTooltip();
33486: 
33486:   // If we are the active preview and our window is the active window, restore
33486:   // our active state - otherwise some other non-preview window is now active
33486:   // and should be displayed as so.
33486:   if (sActivePreview == this) {
33486:     if (mWnd == ::GetActiveWindow()) {
33486:       nsresult rvActive = ShowActive(PR_TRUE);
33486:       if (NS_FAILED(rvActive))
33486:         rv = rvActive;
33486:     } else {
33486:       sActivePreview = nsnull;
33486:     }
33486:   }
33486:   return rv;
33486: }
33486: 
33486: nsresult
33486: TaskbarPreview::Enable() {
33486:   nsresult rv = NS_OK;
33486:   if (CanMakeTaskbarCalls()) {
33486:     rv = UpdateTaskbarProperties();
33486:   } else {
33486:     WindowHook &hook = GetWindowHook();
33486:     hook.AddMonitor(nsAppShell::GetTaskbarButtonCreatedMessage(), MainWindowHook, this);
33486:   }
33486:   return rv;
33486: }
33486: 
33486: nsresult
33486: TaskbarPreview::Disable() {
33486:   WindowHook &hook = GetWindowHook();
33486:   (void) hook.RemoveMonitor(nsAppShell::GetTaskbarButtonCreatedMessage(), MainWindowHook, this);
33486: 
33486:   return NS_OK;
33486: }
33486: 
33486: void
33486: TaskbarPreview::DetachFromNSWindow(PRBool windowIsAlive) {
33486:   if (windowIsAlive) {
33486:     WindowHook &hook = GetWindowHook();
33486:     hook.RemoveMonitor(WM_DESTROY, MainWindowHook, this);
33486:   }
33486:   mWnd = NULL;
33486: }
33486: 
33486: LRESULT
33486: TaskbarPreview::WndProc(UINT nMsg, WPARAM wParam, LPARAM lParam) {
33486:   switch (nMsg) {
33486:     case WM_DWMSENDICONICTHUMBNAIL:
33486:       {
33486:         PRUint32 width = HIWORD(lParam);
33486:         PRUint32 height = LOWORD(lParam);
33486:         float aspectRatio = width/float(height);
33486: 
33486:         nsresult rv;
33486:         float preferredAspectRatio;
33486:         rv = mController->GetThumbnailAspectRatio(&preferredAspectRatio);
33486:         if (NS_FAILED(rv))
33486:           break;
33486: 
33486:         PRUint32 thumbnailWidth = width;
33486:         PRUint32 thumbnailHeight = height;
33486: 
33486:         if (aspectRatio > preferredAspectRatio) {
33486:           thumbnailWidth = PRUint32(thumbnailHeight * preferredAspectRatio);
33486:         } else {
33486:           thumbnailHeight = PRUint32(thumbnailWidth / preferredAspectRatio);
33486:         }
33486: 
33486:         DrawBitmap(thumbnailWidth, thumbnailHeight, PR_FALSE);
33486:       }
33486:       break;
33486:     case WM_DWMSENDICONICLIVEPREVIEWBITMAP:
33486:       {
33486:         PRUint32 width, height;
33486:         nsresult rv;
33486:         rv = mController->GetWidth(&width);
33486:         if (NS_FAILED(rv))
33486:           break;
33486:         rv = mController->GetHeight(&height);
33486:         if (NS_FAILED(rv))
33486:           break;
33486: 
33486:         DrawBitmap(width, height, PR_TRUE);
33486:       }
33486:       break;
33486:   }
33486:   return ::DefWindowProcW(PreviewWindow(), nMsg, wParam, lParam);
33486: }
33486: 
33486: PRBool
33486: TaskbarPreview::CanMakeTaskbarCalls() {
39717:   // If the nsWindow has already been destroyed and we know it but our caller
39717:   // clearly doesn't so we can't make any calls.
39717:   if (!mWnd)
39717:     return PR_FALSE;
39717:   // Certain functions like SetTabOrder seem to require a visible window. During
39717:   // window close, the window seems to be hidden before being destroyed.
39717:   if (!::IsWindowVisible(mWnd))
39717:     return PR_FALSE;
39717:   if (mVisible) {
33486:     nsWindow *window = nsWindow::GetNSWindowPtr(mWnd);
39717:     NS_ASSERTION(window, "Could not get nsWindow from HWND");
39717:     return window->HasTaskbarIconBeenCreated();
39717:   }
39717:   return PR_FALSE;
33486: }
33486: 
33486: WindowHook&
33486: TaskbarPreview::GetWindowHook() {
33486:   nsWindow *window = nsWindow::GetNSWindowPtr(mWnd);
33486:   NS_ASSERTION(window, "Cannot use taskbar previews in an embedded context!");
33486: 
33486:   return window->GetWindowHook();
33486: }
33486: 
33486: void
33486: TaskbarPreview::EnableCustomDrawing(HWND aHWND, PRBool aEnable) {
33486:   nsUXThemeData::dwmSetWindowAttributePtr(
33486:       aHWND,
33486:       DWMWA_FORCE_ICONIC_REPRESENTATION,
33486:       &aEnable,
33486:       sizeof(aEnable));
33486: 
33486:   nsUXThemeData::dwmSetWindowAttributePtr(
33486:       aHWND,
33486:       DWMWA_HAS_ICONIC_BITMAP,
33486:       &aEnable,
33486:       sizeof(aEnable));
33486: }
33486: 
33486: 
33486: nsresult
33486: TaskbarPreview::UpdateTooltip() {
33486:   NS_ASSERTION(CanMakeTaskbarCalls() && mVisible, "UpdateTooltip called on invisible tab preview");
33486: 
33486:   if (FAILED(mTaskbar->SetThumbnailTooltip(PreviewWindow(), mTooltip.get())))
33486:     return NS_ERROR_FAILURE;
33486:   return NS_OK;
33486: }
33486: 
33486: void
33486: TaskbarPreview::DrawBitmap(PRUint32 width, PRUint32 height, PRBool isPreview) {
33486:   nsresult rv;
33486:   nsRefPtr<gfxWindowsSurface> surface = new gfxWindowsSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
33486: 
33486:   nsCOMPtr<nsIDocShell> shell = do_QueryReferent(mDocShell);
33486: 
33486:   if (!shell)
33486:     return;
33486: 
33486:   nsCOMPtr<nsICanvasRenderingContextInternal> ctxI;
33486:   rv = CreateRenderingContext(shell, surface, width, height, getter_AddRefs(ctxI));
33486: 
33486:   nsCOMPtr<nsIDOMCanvasRenderingContext2D> ctx = do_QueryInterface(ctxI);
33486: 
33486:   PRBool drawFrame = PR_FALSE;
33486:   if (NS_SUCCEEDED(rv) && ctx) {
33486:     if (isPreview)
33486:       rv = mController->DrawPreview(ctx, &drawFrame);
33486:     else
33486:       rv = mController->DrawThumbnail(ctx, width, height, &drawFrame);
33486: 
33486:   }
33486: 
33486:   if (NS_FAILED(rv))
33486:     return;
33486: 
33486:   HDC hDC = surface->GetDC();
33486:   HBITMAP hBitmap = (HBITMAP)GetCurrentObject(hDC, OBJ_BITMAP);
33486: 
33486:   DWORD flags = drawFrame ? DWM_SIT_DISPLAYFRAME : 0;
33486:   POINT pptClient = { 0, 0 };
33486:   if (isPreview)
33486:     nsUXThemeData::dwmSetIconicLivePreviewBitmapPtr(PreviewWindow(), hBitmap, &pptClient, flags);
33486:   else
33486:     nsUXThemeData::dwmSetIconicThumbnailPtr(PreviewWindow(), hBitmap, flags);
33486: }
33486: 
33486: /* static */
33486: PRBool
33486: TaskbarPreview::MainWindowHook(void *aContext,
33486:                                HWND hWnd, UINT nMsg,
33486:                                WPARAM wParam, LPARAM lParam,
33486:                                LRESULT *aResult)
33486: {
33486:   NS_ASSERTION(nMsg == nsAppShell::GetTaskbarButtonCreatedMessage() ||
33486:                nMsg == WM_DESTROY,
33486:                "Window hook proc called with wrong message");
33486:   TaskbarPreview *preview = reinterpret_cast<TaskbarPreview*>(aContext);
33486:   if (nMsg == WM_DESTROY) {
33486:     // nsWindow is being destroyed
33486:     // Don't remove the hook since it is currently in dispatch
33486:     // and the window is being destroyed
33486:     preview->DetachFromNSWindow(PR_FALSE);
33486:   } else {
33486:     nsWindow *window = nsWindow::GetNSWindowPtr(preview->mWnd);
33486:     NS_ASSERTION(window, "Cannot use taskbar previews in an embedded context!");
33486: 
33486:     window->SetHasTaskbarIconBeenCreated();
33486: 
33486:     if (preview->mVisible)
33486:       preview->UpdateTaskbarProperties();
33486:   }
33486:   return PR_FALSE;
33486: }
33486: 
33486: TaskbarPreview *
33486: TaskbarPreview::sActivePreview = nsnull;
33486: 
33486: } // namespace widget
33486: } // namespace mozilla
33486: 
33486: #endif // MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
