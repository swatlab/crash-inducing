    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Harshal Pradhan <keeda@hotpop.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //#define USEWEAKREFS // (haven't quite figured that out yet)
    1: 
    1: #include "nsWindowWatcher.h"
43706: #include "nsAutoWindowStateHelper.h"
    1: 
    1: #include "nsAutoLock.h"
    1: #include "nsCRT.h"
    1: #include "nsNetUtil.h"
    1: #include "nsWWJSUtils.h"
    1: #include "plstr.h"
41486: #include "nsIContentUtils.h"
    1: 
    1: #include "nsIBaseWindow.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellLoadInfo.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsIDocumentLoader.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMChromeWindow.h"
    1: #include "nsIDOMWindowInternal.h"
33525: #include "nsIDOMModalContentWindow.h"
43706: #include "nsIPrompt.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIScreen.h"
    1: #include "nsIScreenManager.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsXPCOM.h"
    1: #include "nsIURI.h"
    1: #include "nsIWebBrowser.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIWindowCreator.h"
    1: #include "nsIWindowCreator2.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsIWindowProvider.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsISupportsArray.h"
 8369: #include "nsIDeviceContext.h"
28438: #include "nsIDOMStorageObsolete.h"
28676: #include "nsIDOMStorage.h"
23579: #include "nsPIDOMStorage.h"
26846: #include "nsIWidget.h"
29018: #include "nsFocusManager.h"
52352: #include "nsIPresShell.h"
52352: #include "nsPresContext.h"
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: 
    1: #ifdef USEWEAKREFS
    1: #include "nsIWeakReference.h"
    1: #endif
    1: 
    1: static const char *sJSStackContractID="@mozilla.org/js/xpc/ContextStack;1";
    1: 
    1: /****************************************************************
    1:  ******************** nsWatcherWindowEntry **********************
    1:  ****************************************************************/
    1: 
    1: class nsWindowWatcher;
    1: 
    1: struct nsWatcherWindowEntry {
    1: 
    1:   nsWatcherWindowEntry(nsIDOMWindow *inWindow, nsIWebBrowserChrome *inChrome) {
    1: #ifdef USEWEAKREFS
    1:     mWindow = do_GetWeakReference(inWindow);
    1: #else
    1:     mWindow = inWindow;
    1: #endif
    1:     nsCOMPtr<nsISupportsWeakReference> supportsweak(do_QueryInterface(inChrome));
    1:     if (supportsweak) {
    1:       supportsweak->GetWeakReference(getter_AddRefs(mChromeWeak));
    1:     } else {
    1:       mChrome = inChrome;
    1:       mChromeWeak = 0;
    1:     }
    1:     ReferenceSelf();
    1:   }
    1:   ~nsWatcherWindowEntry() {}
    1: 
    1:   void InsertAfter(nsWatcherWindowEntry *inOlder);
    1:   void Unlink();
    1:   void ReferenceSelf();
    1: 
    1: #ifdef USEWEAKREFS
    1:   nsCOMPtr<nsIWeakReference> mWindow;
    1: #else // still not an owning ref
    1:   nsIDOMWindow              *mWindow;
    1: #endif
    1:   nsIWebBrowserChrome       *mChrome;
    1:   nsWeakPtr                  mChromeWeak;
    1:   // each struct is in a circular, doubly-linked list
    1:   nsWatcherWindowEntry      *mYounger, // next younger in sequence
    1:                             *mOlder;
    1: };
    1: 
    1: void nsWatcherWindowEntry::InsertAfter(nsWatcherWindowEntry *inOlder)
    1: {
    1:   if (inOlder) {
    1:     mOlder = inOlder;
    1:     mYounger = inOlder->mYounger;
    1:     mOlder->mYounger = this;
    1:     if (mOlder->mOlder == mOlder)
    1:       mOlder->mOlder = this;
    1:     mYounger->mOlder = this;
    1:     if (mYounger->mYounger == mYounger)
    1:       mYounger->mYounger = this;
    1:   }
    1: }
    1: 
    1: void nsWatcherWindowEntry::Unlink() {
    1: 
    1:   mOlder->mYounger = mYounger;
    1:   mYounger->mOlder = mOlder;
    1:   ReferenceSelf();
    1: }
    1: 
    1: void nsWatcherWindowEntry::ReferenceSelf() {
    1: 
    1:   mYounger = this;
    1:   mOlder = this;
    1: }
    1: 
    1: /****************************************************************
    1:  ****************** nsWatcherWindowEnumerator *******************
    1:  ****************************************************************/
    1: 
    1: class nsWatcherWindowEnumerator : public nsISimpleEnumerator {
    1: 
    1: public:
    1:   nsWatcherWindowEnumerator(nsWindowWatcher *inWatcher);
    1:   virtual ~nsWatcherWindowEnumerator();
    1:   NS_IMETHOD HasMoreElements(PRBool *retval);
    1:   NS_IMETHOD GetNext(nsISupports **retval);
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1: private:
    1:   friend class nsWindowWatcher;
    1: 
    1:   nsWatcherWindowEntry *FindNext();
    1:   void WindowRemoved(nsWatcherWindowEntry *inInfo);
    1: 
    1:   nsWindowWatcher      *mWindowWatcher;
    1:   nsWatcherWindowEntry *mCurrentPosition;
    1: };
    1: 
    1: NS_IMPL_ADDREF(nsWatcherWindowEnumerator)
    1: NS_IMPL_RELEASE(nsWatcherWindowEnumerator)
    1: NS_IMPL_QUERY_INTERFACE1(nsWatcherWindowEnumerator, nsISimpleEnumerator)
    1: 
    1: nsWatcherWindowEnumerator::nsWatcherWindowEnumerator(nsWindowWatcher *inWatcher)
    1:   : mWindowWatcher(inWatcher),
    1:     mCurrentPosition(inWatcher->mOldestWindow)
    1: {
    1:   mWindowWatcher->AddEnumerator(this);
    1:   mWindowWatcher->AddRef();
    1: }
    1: 
    1: nsWatcherWindowEnumerator::~nsWatcherWindowEnumerator()
    1: {
    1:   mWindowWatcher->RemoveEnumerator(this);
    1:   mWindowWatcher->Release();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWatcherWindowEnumerator::HasMoreElements(PRBool *retval)
    1: {
    1:   if (!retval)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   *retval = mCurrentPosition? PR_TRUE : PR_FALSE;
    1:   return NS_OK;
    1: }
    1:     
    1: NS_IMETHODIMP
    1: nsWatcherWindowEnumerator::GetNext(nsISupports **retval)
    1: {
    1:   if (!retval)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   *retval = NULL;
    1: 
    1: #ifdef USEWEAKREFS
    1:   while (mCurrentPosition) {
    1:     CallQueryReferent(mCurrentPosition->mWindow, retval);
    1:     if (*retval) {
    1:       mCurrentPosition = FindNext();
    1:       break;
    1:     } else // window is gone!
    1:       mWindowWatcher->RemoveWindow(mCurrentPosition);
    1:   }
    1:   NS_IF_ADDREF(*retval);
    1: #else
    1:   if (mCurrentPosition) {
    1:     CallQueryInterface(mCurrentPosition->mWindow, retval);
    1:     mCurrentPosition = FindNext();
    1:   }
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: nsWatcherWindowEntry *
    1: nsWatcherWindowEnumerator::FindNext()
    1: {
    1:   nsWatcherWindowEntry *info;
    1: 
    1:   if (!mCurrentPosition)
    1:     return 0;
    1: 
    1:   info = mCurrentPosition->mYounger;
    1:   return info == mWindowWatcher->mOldestWindow ? 0 : info;
    1: }
    1: 
    1: // if a window is being removed adjust the iterator's current position
    1: void nsWatcherWindowEnumerator::WindowRemoved(nsWatcherWindowEntry *inInfo) {
    1: 
    1:   if (mCurrentPosition == inInfo)
    1:     mCurrentPosition = mCurrentPosition != inInfo->mYounger ?
    1:                        inInfo->mYounger : 0;
    1: }
    1: 
    1: /****************************************************************
    1:  ********************** JSContextAutoPopper *********************
    1:  ****************************************************************/
    1: 
15594: class NS_STACK_CLASS JSContextAutoPopper {
    1: public:
    1:   JSContextAutoPopper();
    1:   ~JSContextAutoPopper();
    1: 
    1:   nsresult   Push(JSContext *cx = nsnull);
    1:   JSContext *get() { return mContext; }
    1: 
    1: protected:
    1:   nsCOMPtr<nsIThreadJSContextStack>  mService;
    1:   JSContext                         *mContext;
 3291:   nsCOMPtr<nsIScriptContext>         mContextKungFuDeathGrip;
    1: };
    1: 
    1: JSContextAutoPopper::JSContextAutoPopper() : mContext(nsnull)
    1: {
    1: }
    1: 
    1: JSContextAutoPopper::~JSContextAutoPopper()
    1: {
    1:   JSContext *cx;
    1:   nsresult   rv;
    1: 
    1:   if(mContext) {
    1:     rv = mService->Pop(&cx);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv) && cx == mContext, "JSContext push/pop mismatch");
    1:   }
    1: }
    1: 
    1: nsresult JSContextAutoPopper::Push(JSContext *cx)
    1: {
    1:   if (mContext) // only once
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mService = do_GetService(sJSStackContractID);
    1:   if(mService) {
    1:     // Get the safe context if we're not provided one.
    1:     if (!cx && NS_FAILED(mService->GetSafeJSContext(&cx))) {
    1:       cx = nsnull;
    1:     }
    1: 
    1:     // Save cx in mContext to indicate need to pop.
    1:     if (cx && NS_SUCCEEDED(mService->Push(cx))) {
    1:       mContext = cx;
 3291:       mContextKungFuDeathGrip = nsWWJSUtils::GetDynamicScriptContext(cx);
    1:     }
    1:   }
    1:   return mContext ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: /****************************************************************
    1:  *********************** nsWindowWatcher ************************
    1:  ****************************************************************/
    1: 
    1: NS_IMPL_ADDREF(nsWindowWatcher)
    1: NS_IMPL_RELEASE(nsWindowWatcher)
43706: NS_IMPL_QUERY_INTERFACE3(nsWindowWatcher,
    1:                          nsIWindowWatcher,
    1:                          nsIPromptFactory,
    1:                          nsPIWindowWatcher)
    1: 
    1: nsWindowWatcher::nsWindowWatcher() :
    1:         mEnumeratorList(),
    1:         mOldestWindow(0),
    1:         mListLock(0)
    1: {
    1: }
    1: 
    1: nsWindowWatcher::~nsWindowWatcher()
    1: {
    1:   // delete data
    1:   while (mOldestWindow)
    1:     RemoveWindow(mOldestWindow);
    1: 
    1:   if (mListLock)
    1:     PR_DestroyLock(mListLock);
    1: }
    1: 
    1: nsresult
    1: nsWindowWatcher::Init()
    1: {
    1:   mListLock = PR_NewLock();
    1:   if (!mListLock)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::OpenWindow(nsIDOMWindow *aParent,
    1:                             const char *aUrl,
    1:                             const char *aName,
    1:                             const char *aFeatures,
    1:                             nsISupports *aArguments,
    1:                             nsIDOMWindow **_retval)
    1: {
    1:   nsCOMPtr<nsIArray> argsArray;
    1:   PRUint32 argc = 0;
    1:   if (aArguments) {
    1:     // aArguments is allowed to be either an nsISupportsArray or an nsIArray
    1:     // (in which case it is treated as argv) or any other COM object (in which
    1:     // case it becomes argv[0]).
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsISupportsArray> supArray(do_QueryInterface(aArguments));
    1:     if (!supArray) {
    1:       nsCOMPtr<nsIArray> array(do_QueryInterface(aArguments));
    1:       if (!array) {
    1:         nsCOMPtr<nsIMutableArray> muteArray;
    1:         argsArray = muteArray = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
    1:         if (NS_FAILED(rv))
    1:           return rv;
    1:         rv = muteArray->AppendElement(aArguments, PR_FALSE);
    1:         if (NS_FAILED(rv))
    1:           return rv;
    1:         argc = 1;
    1:       } else {
    1:         rv = array->GetLength(&argc);
    1:         if (NS_FAILED(rv))
    1:           return rv;
    1:         if (argc > 0)
    1:           argsArray = array;
    1:       }
    1:     } else {
    1:       // nsISupports array - copy into nsIArray...
    1:       rv = supArray->Count(&argc);
    1:       if (NS_FAILED(rv))
    1:         return rv;
    1:       // But only create an arguments array if there's at least one element in
    1:       // the supports array.
    1:       if (argc > 0) {
    1:         nsCOMPtr<nsIMutableArray> muteArray;
    1:         argsArray = muteArray = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
    1:         if (NS_FAILED(rv))
    1:           return rv;
    1:         for (PRUint32 i = 0; i < argc; i++) {
    1:           nsCOMPtr<nsISupports> elt(dont_AddRef(supArray->ElementAt(i)));
    1:           rv = muteArray->AppendElement(elt, PR_FALSE);
    1:           if (NS_FAILED(rv))
    1:             return rv;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   PRBool dialog = (argc != 0);
    1:   return OpenWindowJSInternal(aParent, aUrl, aName, aFeatures, dialog, 
    1:                               argsArray, PR_FALSE, _retval);
    1: }
    1: 
    1: struct SizeSpec {
    1:   SizeSpec() :
    1:     mLeftSpecified(PR_FALSE),
    1:     mTopSpecified(PR_FALSE),
    1:     mOuterWidthSpecified(PR_FALSE),
    1:     mOuterHeightSpecified(PR_FALSE),
    1:     mInnerWidthSpecified(PR_FALSE),
    1:     mInnerHeightSpecified(PR_FALSE),
    1:     mUseDefaultWidth(PR_FALSE),
    1:     mUseDefaultHeight(PR_FALSE)
    1:   {}
    1:   
    1:   PRInt32 mLeft;
    1:   PRInt32 mTop;
    1:   PRInt32 mOuterWidth;  // Total window width
    1:   PRInt32 mOuterHeight; // Total window height
    1:   PRInt32 mInnerWidth;  // Content area width
    1:   PRInt32 mInnerHeight; // Content area height
    1: 
    1:   PRPackedBool mLeftSpecified;
    1:   PRPackedBool mTopSpecified;
    1:   PRPackedBool mOuterWidthSpecified;
    1:   PRPackedBool mOuterHeightSpecified;
    1:   PRPackedBool mInnerWidthSpecified;
    1:   PRPackedBool mInnerHeightSpecified;
    1: 
    1:   // If these booleans are true, don't look at the corresponding width values
    1:   // even if they're specified -- they'll be bogus
    1:   PRPackedBool mUseDefaultWidth;
    1:   PRPackedBool mUseDefaultHeight;
    1: 
    1:   PRBool PositionSpecified() const {
    1:     return mLeftSpecified || mTopSpecified;
    1:   }
    1:   
    1:   PRBool SizeSpecified() const {
    1:     return mOuterWidthSpecified || mOuterHeightSpecified ||
    1:       mInnerWidthSpecified || mInnerHeightSpecified;
    1:   }
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::OpenWindowJS(nsIDOMWindow *aParent,
    1:                               const char *aUrl,
    1:                               const char *aName,
    1:                               const char *aFeatures,
    1:                               PRBool aDialog,
    1:                               nsIArray *argv,
    1:                               nsIDOMWindow **_retval)
    1: {
    1:   if (argv) {
    1:     PRUint32 argc;
    1:     nsresult rv = argv->GetLength(&argc);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // For compatibility with old code, no arguments implies that we shouldn't
    1:     // create an arguments object on the new window at all.
    1:     if (argc == 0)
    1:       argv = nsnull;
    1:   }
    1: 
    1:   return OpenWindowJSInternal(aParent, aUrl, aName, aFeatures, aDialog,
    1:                               argv, PR_TRUE, _retval);
    1: }
    1: 
    1: nsresult
    1: nsWindowWatcher::OpenWindowJSInternal(nsIDOMWindow *aParent,
    1:                                       const char *aUrl,
    1:                                       const char *aName,
    1:                                       const char *aFeatures,
    1:                                       PRBool aDialog,
    1:                                       nsIArray *argv,
    1:                                       PRBool aCalledFromJS,
    1:                                       nsIDOMWindow **_retval)
    1: {
    1:   nsresult                        rv = NS_OK;
    1:   PRBool                          nameSpecified,
    1:                                   featuresSpecified,
    1:                                   isNewToplevelWindow = PR_FALSE,
    1:                                   windowIsNew = PR_FALSE,
    1:                                   windowNeedsName = PR_FALSE,
    1:                                   windowIsModal = PR_FALSE,
 4040:                                   uriToLoadIsChrome = PR_FALSE,
 4040:                                   windowIsModalContentDialog = PR_FALSE;
    1:   PRUint32                        chromeFlags;
    1:   nsAutoString                    name;             // string version of aName
    1:   nsCAutoString                   features;         // string version of aFeatures
    1:   nsCOMPtr<nsIURI>                uriToLoad;        // from aUrl, if any
    1:   nsCOMPtr<nsIDocShellTreeOwner>  parentTreeOwner;  // from the parent window, if any
    1:   nsCOMPtr<nsIDocShellTreeItem>   newDocShellItem;  // from the new window
    1:   JSContextAutoPopper             callerContextGuard;
    1: 
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = 0;
    1: 
41486:   nsCOMPtr<nsIContentUtils> utils =
41486:     do_GetService("@mozilla.org/content/contentutils;1");
41486:   if (!utils->IsSafeToRunScript()) {
41486:     return NS_ERROR_FAILURE;
41486:   }
41486: 
    1:   GetWindowTreeOwner(aParent, getter_AddRefs(parentTreeOwner));
    1: 
    1:   if (aUrl) {
    1:     rv = URIfromURL(aUrl, aParent, getter_AddRefs(uriToLoad));
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     uriToLoad->SchemeIs("chrome", &uriToLoadIsChrome);
    1:   }
    1: 
    1:   nameSpecified = PR_FALSE;
    1:   if (aName) {
    1:     CopyUTF8toUTF16(aName, name);
    1: #ifdef DEBUG
    1:     CheckWindowName(name);
    1: #endif
    1:     nameSpecified = PR_TRUE;
    1:   }
    1: 
    1:   featuresSpecified = PR_FALSE;
    1:   if (aFeatures) {
    1:     features.Assign(aFeatures);
    1:     featuresSpecified = PR_TRUE;
    1:     features.StripWhitespace();
    1:   }
    1: 
    1:   // try to find an extant window with the given name
    1:   nsCOMPtr<nsIDOMWindow> foundWindow;
    1:   SafeGetWindowByName(name, aParent, getter_AddRefs(foundWindow));
    1:   GetWindowTreeItem(foundWindow, getter_AddRefs(newDocShellItem));
    1: 
    1:   // no extant window? make a new one.
    1: 
    1:   nsCOMPtr<nsIDOMChromeWindow> chromeParent(do_QueryInterface(aParent));
    1: 
    1:   // Make sure we call CalculateChromeFlags() *before* we push the
    1:   // callee context onto the context stack so that
24693:   // CalculateChromeFlags() sees the actual caller when doing its
    1:   // security checks.
    1:   chromeFlags = CalculateChromeFlags(features.get(), featuresSpecified,
    1:                                      aDialog, uriToLoadIsChrome,
    1:                                      !aParent || chromeParent);
    1: 
13096:   // If we're not called through our JS version of the API, and we got
13096:   // our internal modal option, treat the window we're opening as a
13096:   // modal content window (and set the modal chrome flag).
13096:   if (!aCalledFromJS && argv &&
13096:       WinHasOption(features.get(), "-moz-internal-modal", 0, nsnull)) {
 4422:     windowIsModalContentDialog = PR_TRUE;
13096: 
13096:     chromeFlags |= nsIWebBrowserChrome::CHROME_MODAL;
 4422:   }
 4422: 
    1:   SizeSpec sizeSpec;
    1:   CalcSizeSpec(features.get(), sizeSpec);
    1: 
    1:   nsCOMPtr<nsIScriptSecurityManager>
    1:     sm(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
33525: 
56944:   NS_ENSURE_TRUE(sm, NS_ERROR_FAILURE);
56944: 
33525:   // Remember who's calling us. This code used to assume a null
33525:   // subject principal if it failed to get the principal, but that's
33525:   // just not safe, so bail on errors here.
33525:   nsCOMPtr<nsIPrincipal> callerPrincipal;
33525:   rv = sm->GetSubjectPrincipal(getter_AddRefs(callerPrincipal));
33525:   NS_ENSURE_SUCCESS(rv, rv);
33525: 
33525:   PRBool isCallerChrome = PR_TRUE;
33525:   if (callerPrincipal) {
33525:     rv = sm->IsSystemPrincipal(callerPrincipal, &isCallerChrome);
33525:     NS_ENSURE_SUCCESS(rv, rv);
33525:   }
    1: 
    1:   JSContext *cx = GetJSContextFromWindow(aParent);
    1: 
    1:   if (isCallerChrome && !chromeParent && cx) {
    1:     // open() is called from chrome on a non-chrome window, push
    1:     // the context of the callee onto the context stack to
    1:     // prevent the caller's priveleges from leaking into code
    1:     // that runs while opening the new window.
    1: 
    1:     callerContextGuard.Push(cx);
    1:   }
    1: 
    1:   if (!newDocShellItem) {
    1:     // We're going to either open up a new window ourselves or ask a
    1:     // nsIWindowProvider for one.  In either case, we'll want to set the right
    1:     // name on it.
    1:     windowNeedsName = PR_TRUE;
    1: 
    1:     // Now check whether it's ok to ask a window provider for a window.  Don't
    1:     // do it if we're opening a dialog or if our parent is a chrome window or
    1:     // if we're opening something that has modal, dialog, or chrome flags set.
    1:     nsCOMPtr<nsIDOMChromeWindow> chromeWin = do_QueryInterface(aParent);
    1:     if (!aDialog && !chromeWin &&
    1:         !(chromeFlags & (nsIWebBrowserChrome::CHROME_MODAL         |
    1:                          nsIWebBrowserChrome::CHROME_OPENAS_DIALOG | 
    1:                          nsIWebBrowserChrome::CHROME_OPENAS_CHROME))) {
    1:       nsCOMPtr<nsIWindowProvider> provider = do_GetInterface(parentTreeOwner);
    1:       if (provider) {
    1:         NS_ASSERTION(aParent, "We've _got_ to have a parent here!");
    1: 
    1:         nsCOMPtr<nsIDOMWindow> newWindow;
47224:         rv = provider->ProvideWindow(aParent, chromeFlags, aCalledFromJS,
    1:                                      sizeSpec.PositionSpecified(),
    1:                                      sizeSpec.SizeSpecified(),
    1:                                      uriToLoad, name, features, &windowIsNew,
    1:                                      getter_AddRefs(newWindow));
    1:         if (NS_SUCCEEDED(rv)) {
    1:           GetWindowTreeItem(newWindow, getter_AddRefs(newDocShellItem));
    1:           if (windowIsNew && newDocShellItem) {
    1:             // Make sure to stop any loads happening in this window that the
    1:             // window provider might have started.  Otherwise if our caller
    1:             // manipulates the window it just opened and then the load
    1:             // completes their stuff will get blown away.
    1:             nsCOMPtr<nsIWebNavigation> webNav =
    1:               do_QueryInterface(newDocShellItem);
    1:             webNav->Stop(nsIWebNavigation::STOP_NETWORK);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1:   
    1:   if (!newDocShellItem) {
    1:     windowIsNew = PR_TRUE;
    1:     isNewToplevelWindow = PR_TRUE;
    1: 
    1:     nsCOMPtr<nsIWebBrowserChrome> parentChrome(do_GetInterface(parentTreeOwner));
    1: 
    1:     // is the parent (if any) modal? if so, we must be, too.
    1:     PRBool weAreModal = (chromeFlags & nsIWebBrowserChrome::CHROME_MODAL) != 0;
    1:     if (!weAreModal && parentChrome)
    1:       parentChrome->IsWindowModal(&weAreModal);
    1: 
    1:     if (weAreModal) {
    1:       windowIsModal = PR_TRUE;
    1:       // in case we added this because weAreModal
    1:       chromeFlags |= nsIWebBrowserChrome::CHROME_MODAL |
    1:         nsIWebBrowserChrome::CHROME_DEPENDENT;
    1:     }
    1: 
25002:     // Make sure to not create modal windows if our parent is invisible and
23621:     // isn't a chrome window.  Otherwise we can end up in a bizarre situation
23621:     // where we can't shut down because an invisible window is open.  If
23621:     // someone tries to do this, throw.
25002:     if (!chromeParent && (chromeFlags & nsIWebBrowserChrome::CHROME_MODAL)) {
23621:       PRBool parentVisible = PR_TRUE;
23621:       nsCOMPtr<nsIBaseWindow> parentWindow(do_GetInterface(parentTreeOwner));
23621:       nsCOMPtr<nsIWidget> parentWidget;
23621:       if (parentWindow)
23621:         parentWindow->GetMainWidget(getter_AddRefs(parentWidget));
23621:       if (parentWidget)
23621:         parentWidget->IsVisible(parentVisible);
23621:       if (!parentVisible) {
23621:         return NS_ERROR_NOT_AVAILABLE;
23621:       }
23621:     }
23621: 
    1:     NS_ASSERTION(mWindowCreator,
    1:                  "attempted to open a new window with no WindowCreator");
    1:     rv = NS_ERROR_FAILURE;
    1:     if (mWindowCreator) {
    1:       nsCOMPtr<nsIWebBrowserChrome> newChrome;
    1: 
    1:       /* If the window creator is an nsIWindowCreator2, we can give it
    1:          some hints. The only hint at this time is whether the opening window
    1:          is in a situation that's likely to mean this is an unrequested
    1:          popup window we're creating. However we're not completely honest:
    1:          we clear that indicator if the opener is chrome, so that the
    1:          downstream consumer can treat the indicator to mean simply
    1:          that the new window is subject to popup control. */
    1:       nsCOMPtr<nsIWindowCreator2> windowCreator2(do_QueryInterface(mWindowCreator));
    1:       if (windowCreator2) {
    1:         PRUint32 contextFlags = 0;
    1:         PRBool popupConditions = PR_FALSE;
    1: 
    1:         // is the parent under popup conditions?
    1:         nsCOMPtr<nsPIDOMWindow> piWindow(do_QueryInterface(aParent));
    1:         if (piWindow)
    1:           popupConditions = piWindow->IsLoadingOrRunningTimeout();
    1: 
    1:         // chrome is always allowed, so clear the flag if the opener is chrome
    1:         if (popupConditions) {
 3596:           popupConditions = !isCallerChrome;
    1:         }
    1: 
    1:         if (popupConditions)
    1:           contextFlags |= nsIWindowCreator2::PARENT_IS_LOADING_OR_RUNNING_TIMEOUT;
    1: 
    1:         PRBool cancel = PR_FALSE;
23621:         rv = windowCreator2->CreateChromeWindow2(parentChrome, chromeFlags,
23621:                                                  contextFlags, uriToLoad,
23621:                                                  &cancel,
    1:                                                  getter_AddRefs(newChrome));
    1:         if (NS_SUCCEEDED(rv) && cancel) {
    1:           newChrome = 0; // just in case
    1:           rv = NS_ERROR_ABORT;
    1:         }
    1:       }
    1:       else
    1:         rv = mWindowCreator->CreateChromeWindow(parentChrome, chromeFlags,
    1:                                                 getter_AddRefs(newChrome));
    1:       if (newChrome) {
    1:         /* It might be a chrome nsXULWindow, in which case it won't have
    1:             an nsIDOMWindow (primary content shell). But in that case, it'll
    1:             be able to hand over an nsIDocShellTreeItem directly. */
    1:         nsCOMPtr<nsIDOMWindow> newWindow(do_GetInterface(newChrome));
    1:         if (newWindow)
    1:           GetWindowTreeItem(newWindow, getter_AddRefs(newDocShellItem));
    1:         if (!newDocShellItem)
    1:           newDocShellItem = do_GetInterface(newChrome);
    1:         if (!newDocShellItem)
    1:           rv = NS_ERROR_FAILURE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // better have a window to use by this point
    1:   if (!newDocShellItem)
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIDocShell> newDocShell(do_QueryInterface(newDocShellItem));
    1:   NS_ENSURE_TRUE(newDocShell, NS_ERROR_UNEXPECTED);
    1:   
    1:   rv = ReadyOpenedDocShellItem(newDocShellItem, aParent, windowIsNew, _retval);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   /* disable persistence of size/position in popups (determined by
    1:      determining whether the features parameter specifies width or height
    1:      in any way). We consider any overriding of the window's size or position
    1:      in the open call as disabling persistence of those attributes.
    1:      Popup windows (which should not persist size or position) generally set
    1:      the size. */
    1:   if (isNewToplevelWindow) {
    1:     /* at the moment, the strings "height=" or "width=" never happen
    1:        outside a size specification, so we can do this the Q&D way. */
    1: 
    1:     if (PL_strcasestr(features.get(), "width=") || PL_strcasestr(features.get(), "height=")) {
    1: 
    1:       nsCOMPtr<nsIDocShellTreeOwner> newTreeOwner;
    1:       newDocShellItem->GetTreeOwner(getter_AddRefs(newTreeOwner));
    1:       if (newTreeOwner)
    1:         newTreeOwner->SetPersistence(PR_FALSE, PR_FALSE, PR_FALSE);
    1:     }
    1:   }
    1: 
 4040:   if ((aDialog || windowIsModalContentDialog) && argv) {
 4422:     // Set the args on the new window.
33525:     nsCOMPtr<nsPIDOMWindow> piwin(do_QueryInterface(*_retval));
33525:     NS_ENSURE_TRUE(piwin, NS_ERROR_UNEXPECTED);
33525: 
33525:     rv = piwin->SetArguments(argv, callerPrincipal);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   /* allow a window that we found by name to keep its name (important for cases
    1:      like _self where the given name is different (and invalid)).  Also, _blank
11699:      is not a window name. */
    1:   if (windowNeedsName)
    1:     newDocShellItem->SetName(nameSpecified &&
11699:                              !name.LowerCaseEqualsLiteral("_blank") ?
    1:                              name.get() : nsnull);
    1: 
    1: 
    1:   // Inherit the right character set into the new window to use as a fallback
    1:   // in the event the document being loaded does not specify a charset.  When
    1:   // aCalledFromJS is true, we want to use the character set of the document in
    1:   // the caller; otherwise we want to use the character set of aParent's
    1:   // docshell. Failing to set this charset is not fatal, so we want to continue
    1:   // in the face of errors.
    1:   nsCOMPtr<nsIContentViewer> newCV;
    1:   newDocShell->GetContentViewer(getter_AddRefs(newCV));
    1:   nsCOMPtr<nsIMarkupDocumentViewer> newMuCV = do_QueryInterface(newCV);
    1:   if (newMuCV) {
    1:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1:     GetWindowTreeItem(aParent, getter_AddRefs(parentItem));
    1: 
    1:     if (aCalledFromJS) {
    1:       nsCOMPtr<nsIDocShellTreeItem> callerItem = GetCallerTreeItem(parentItem);
    1:       nsCOMPtr<nsPIDOMWindow> callerWin = do_GetInterface(callerItem);
    1:       if (callerWin) {
    1:         nsCOMPtr<nsIDocument> doc =
    1:           do_QueryInterface(callerWin->GetExtantDocument());
    1:         if (doc) {
    1:           newMuCV->SetDefaultCharacterSet(doc->GetDocumentCharacterSet());
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       nsCOMPtr<nsIDocShell> parentDocshell = do_QueryInterface(parentItem);
    1:       // parentDocshell may be null if the parent got closed in the meantime
    1:       if (parentDocshell) {
    1:         nsCOMPtr<nsIContentViewer> parentCV;
    1:         parentDocshell->GetContentViewer(getter_AddRefs(parentCV));
    1:         nsCOMPtr<nsIMarkupDocumentViewer> parentMuCV =
    1:           do_QueryInterface(parentCV);
    1:         if (parentMuCV) {
    1:           nsCAutoString charset;
    1:           nsresult res = parentMuCV->GetDefaultCharacterSet(charset);
    1:           if (NS_SUCCEEDED(res)) {
    1:             newMuCV->SetDefaultCharacterSet(charset);
    1:           }
    1:           res = parentMuCV->GetPrevDocCharacterSet(charset);
    1:           if (NS_SUCCEEDED(res)) {
    1:             newMuCV->SetPrevDocCharacterSet(charset);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (isNewToplevelWindow) {
    1:     // Notify observers that the window is open and ready.
    1:     // The window has not yet started to load a document.
    1:     nsCOMPtr<nsIObserverService> obsSvc =
41540:       mozilla::services::GetObserverService();
41540:     if (obsSvc)
    1:       obsSvc->NotifyObservers(*_retval, "toplevel-window-ready", nsnull);
    1:   }
    1: 
    1:   // Now we have to set the right opener principal on the new window.  Note
    1:   // that we have to do this _before_ starting any URI loads, thanks to the
    1:   // sync nature of javascript: loads.  Since this is the only place where we
    1:   // set said opener principal, we need to do it for all URIs, including
    1:   // chrome ones.  So to deal with the mess that is bug 79775, just press on in
    1:   // a reasonable way even if GetSubjectPrincipal fails.  In that case, just
    1:   // use a null subjectPrincipal.
    1:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
    1:   if (NS_FAILED(sm->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal)))) {
    1:     subjectPrincipal = nsnull;
    1:   }
    1: 
    1:   if (windowIsNew) {
    1:     // Now set the opener principal on the new window.  Note that we need to do
    1:     // this no matter whether we were opened from JS; if there is nothing on
    1:     // the JS stack, just use the principal of our parent window.  In those
    1:     // cases we do _not_ set the parent window principal as the owner of the
    1:     // load--since we really don't know who the owner is, just leave it null.
    1:     nsIPrincipal* newWindowPrincipal = subjectPrincipal;
    1:     if (!newWindowPrincipal && aParent) {
    1:       nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(aParent));
    1:       if (sop) {
    1:         newWindowPrincipal = sop->GetPrincipal();
    1:       }
    1:     }
    1: 
 3596:     PRBool isSystem;
 3596:     rv = sm->IsSystemPrincipal(newWindowPrincipal, &isSystem);
 3596:     if (NS_FAILED(rv) || isSystem) {
 3596:       // Don't pass this principal along to content windows
 3596:       PRInt32 itemType;
 3596:       rv = newDocShellItem->GetItemType(&itemType);
 3596:       if (NS_FAILED(rv) || itemType != nsIDocShellTreeItem::typeChrome) {
 3596:         newWindowPrincipal = nsnull;        
 3596:       }
 3596:     }
 3596: 
    1:     nsCOMPtr<nsPIDOMWindow> newWindow = do_QueryInterface(*_retval);
    1: #ifdef DEBUG
    1:     nsCOMPtr<nsPIDOMWindow> newDebugWindow = do_GetInterface(newDocShell);
    1:     NS_ASSERTION(newWindow == newDebugWindow, "Different windows??");
    1: #endif
    1:     if (newWindow) {
    1:       newWindow->SetOpenerScriptPrincipal(newWindowPrincipal);
    1:     }
    1:   }
    1: 
    1:   if (uriToLoad) { // get the script principal and pass it to docshell
    1:     JSContextAutoPopper contextGuard;
    1: 
    1:     cx = GetJSContextFromCallStack();
    1: 
    1:     // get the security manager
    1:     if (!cx)
    1:       cx = GetJSContextFromWindow(aParent);
    1:     if (!cx) {
    1:       rv = contextGuard.Push();
    1:       if (NS_FAILED(rv))
    1:         return rv;
    1:       cx = contextGuard.get();
    1:     }
    1: 
    1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1:     newDocShell->CreateLoadInfo(getter_AddRefs(loadInfo));
    1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_FAILURE);
    1: 
    1:     if (subjectPrincipal) {
    1:       loadInfo->SetOwner(subjectPrincipal);
    1:     }
    1: 
    1:     // Set the new window's referrer from the calling context's document:
    1: 
    1:     // get the calling context off the JS context stack
    1:     nsCOMPtr<nsIJSContextStack> stack = do_GetService(sJSStackContractID);
    1: 
    1:     JSContext* ccx = nsnull;
    1: 
    1:     // get its document, if any
    1:     if (stack && NS_SUCCEEDED(stack->Peek(&ccx)) && ccx) {
    1:       nsIScriptGlobalObject *sgo = nsWWJSUtils::GetDynamicScriptGlobal(ccx);
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> w(do_QueryInterface(sgo));
    1:       if (w) {
    1:         /* use the URL from the *extant* document, if any. The usual accessor
    1:            GetDocument will synchronously create an about:blank document if
    1:            it has no better answer, and we only care about a real document.
    1:            Also using GetDocument to force document creation seems to
    1:            screw up focus in the hidden window; see bug 36016.
    1:         */
    1:         nsCOMPtr<nsIDocument> doc(do_QueryInterface(w->GetExtantDocument()));
    1:         if (doc) { 
    1:           // Set the referrer
    1:           loadInfo->SetReferrer(doc->GetDocumentURI());
    1:         }
    1:       }
    1:     }
    1: 
    1:     newDocShell->LoadURI(uriToLoad, loadInfo,
    1:       windowIsNew ? nsIWebNavigation::LOAD_FLAGS_FIRST_LOAD :
    1:                     nsIWebNavigation::LOAD_FLAGS_NONE, PR_TRUE);
    1:   }
    1: 
23579:   // Copy the current session storage for the current domain.
23579:   nsCOMPtr<nsPIDOMWindow> piWindow = do_QueryInterface(aParent);
28676:   nsIDocShell* parentDocShell = nsnull;
23579:   if (piWindow)
28676:     parentDocShell = piWindow->GetDocShell();
23579: 
23579:   if (subjectPrincipal && parentDocShell) {
28676:     nsCOMPtr<nsIDOMStorage> storage;
37608:     parentDocShell->GetSessionStorageForPrincipal(subjectPrincipal,
37608:                                                   EmptyString(), PR_FALSE,
23579:                                                   getter_AddRefs(storage));
23579:     nsCOMPtr<nsPIDOMStorage> piStorage =
23579:       do_QueryInterface(storage);
23579:     if (piStorage){
23579:       storage = piStorage->Clone();
23579:       newDocShell->AddSessionStorage(
28676:         piStorage->Principal(),
23579:         storage);
23579:     }
23579:   }
23579: 
    1:   if (isNewToplevelWindow)
    1:     SizeOpenedDocShellItem(newDocShellItem, aParent, sizeSpec);
    1: 
23621:   // XXXbz isn't windowIsModal always true when windowIsModalContentDialog?
 4040:   if (windowIsModal || windowIsModalContentDialog) {
    1:     nsCOMPtr<nsIDocShellTreeOwner> newTreeOwner;
    1:     newDocShellItem->GetTreeOwner(getter_AddRefs(newTreeOwner));
    1:     nsCOMPtr<nsIWebBrowserChrome> newChrome(do_GetInterface(newTreeOwner));
 4422: 
 4422:     // Throw an exception here if no web browser chrome is available,
 4422:     // we need that to show a modal window.
 4422:     NS_ENSURE_TRUE(newChrome, NS_ERROR_NOT_AVAILABLE);
 4422: 
 4422:     nsCOMPtr<nsPIDOMWindow> modalContentWindow;
 4422: 
 4422:     // Dispatch dialog events etc, but we only want to do that if
 4422:     // we're opening a modal content window (the helper classes are
 4422:     // no-ops if given no window), for chrome dialogs we don't want to
 4422:     // do any of that (it's done elsewhere for us).
 4422: 
 4422:     if (windowIsModalContentDialog) {
 4422:       modalContentWindow = do_QueryInterface(*_retval);
 4422:     }
 4422: 
 6371:     nsAutoWindowStateHelper windowStateHelper(aParent);
 4422: 
 4422:     if (!windowStateHelper.DefaultEnabled()) {
 4422:       // Default to cancel not opening the modal window.
 4422:       NS_RELEASE(*_retval);
 4422: 
 4422:       return NS_OK;
 4422:     }
 4422: 
 4422:     // Reset popup state while opening a modal dialog, and firing
 4422:     // events about the dialog, to prevent the current state from
 4422:     // being active the whole time a modal dialog is open.
 4422:     nsAutoPopupStatePusher popupStatePusher(modalContentWindow, openAbused);
 4422: 
    1:     newChrome->ShowAsModal();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::RegisterNotification(nsIObserver *aObserver)
    1: {
    1:   // just a convenience method; it delegates to nsIObserverService
    1: 
    1:   if (!aObserver)
    1:     return NS_ERROR_INVALID_ARG;
    1:   
41540:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
41540:   if (!os)
41540:     return NS_ERROR_FAILURE;
41540: 
41540:   nsresult rv = os->AddObserver(aObserver, "domwindowopened", PR_FALSE);
    1:   if (NS_SUCCEEDED(rv))
    1:     rv = os->AddObserver(aObserver, "domwindowclosed", PR_FALSE);
41540: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::UnregisterNotification(nsIObserver *aObserver)
    1: {
    1:   // just a convenience method; it delegates to nsIObserverService
    1: 
    1:   if (!aObserver)
    1:     return NS_ERROR_INVALID_ARG;
    1:   
41540:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
41540:   if (!os)
41540:     return NS_ERROR_FAILURE;
41540: 
    1:   os->RemoveObserver(aObserver, "domwindowopened");
    1:   os->RemoveObserver(aObserver, "domwindowclosed");
41540: 
41540:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetWindowEnumerator(nsISimpleEnumerator** _retval)
    1: {
    1:   if (!_retval)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsAutoLock lock(mListLock);
    1:   nsWatcherWindowEnumerator *enumerator = new nsWatcherWindowEnumerator(this);
    1:   if (enumerator)
    1:     return CallQueryInterface(enumerator, _retval);
    1: 
    1:   return NS_ERROR_OUT_OF_MEMORY;
    1: }
    1:     
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetNewPrompter(nsIDOMWindow *aParent, nsIPrompt **_retval)
    1: {
43706:   // This is for backwards compat only. Callers should just use the prompt service directly.
43706:   nsresult rv;
43706:   nsCOMPtr<nsIPromptFactory> factory = do_GetService("@mozilla.org/prompter;1", &rv);
43706:   NS_ENSURE_SUCCESS(rv, rv);
43706:   return factory->GetPrompt(aParent, NS_GET_IID(nsIPrompt), reinterpret_cast<void**>(_retval));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetNewAuthPrompter(nsIDOMWindow *aParent, nsIAuthPrompt **_retval)
    1: {
43706:   // This is for backwards compat only. Callers should just use the prompt service directly.
43706:   nsresult rv;
43706:   nsCOMPtr<nsIPromptFactory> factory = do_GetService("@mozilla.org/prompter;1", &rv);
43706:   NS_ENSURE_SUCCESS(rv, rv);
43706:   return factory->GetPrompt(aParent, NS_GET_IID(nsIAuthPrompt), reinterpret_cast<void**>(_retval));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetPrompt(nsIDOMWindow *aParent, const nsIID& aIID,
    1:                            void **_retval)
    1: {
43706:   // This is for backwards compat only. Callers should just use the prompt service directly.
43706:   nsresult rv;
43706:   nsCOMPtr<nsIPromptFactory> factory = do_GetService("@mozilla.org/prompter;1", &rv);
43706:   NS_ENSURE_SUCCESS(rv, rv);
43706:   rv = factory->GetPrompt(aParent, aIID, _retval);
43706: 
43706:   // Allow for an embedding implementation to not support nsIAuthPrompt2.
43706:   if (rv == NS_NOINTERFACE && aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
43706:     nsCOMPtr<nsIAuthPrompt> oldPrompt;
43706:     rv = factory->GetPrompt(aParent,
43706:                             NS_GET_IID(nsIAuthPrompt),
43706:                             getter_AddRefs(oldPrompt));
43706:     NS_ENSURE_SUCCESS(rv, rv);
43706: 
43706:     NS_WrapAuthPrompt(oldPrompt, reinterpret_cast<nsIAuthPrompt2**>(_retval));
    1:     if (!*_retval)
    1:       rv = NS_ERROR_NOT_AVAILABLE;
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::SetWindowCreator(nsIWindowCreator *creator)
    1: {
    1:   mWindowCreator = creator; // it's an nsCOMPtr, so this is an ownership ref
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetActiveWindow(nsIDOMWindow **aActiveWindow)
    1: {
29018:   *aActiveWindow = nsnull;
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   if (fm)
29018:     return fm->GetActiveWindow(aActiveWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::SetActiveWindow(nsIDOMWindow *aActiveWindow)
    1: {
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   if (fm)
29018:     return fm->SetActiveWindow(aActiveWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::AddWindow(nsIDOMWindow *aWindow, nsIWebBrowserChrome *aChrome)
    1: {
    1:   if (!aWindow)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1: #ifdef DEBUG
    1:   {
    1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aWindow));
    1: 
    1:     NS_ASSERTION(win->IsOuterWindow(),
    1:                  "Uh, the active window must be an outer window!");
    1:   }
    1: #endif
    1: 
    1:   {
    1:     nsWatcherWindowEntry *info;
    1:     nsAutoLock lock(mListLock);
    1: 
    1:     // if we already have an entry for this window, adjust
    1:     // its chrome mapping and return
    1:     info = FindWindowEntry(aWindow);
    1:     if (info) {
    1:       nsCOMPtr<nsISupportsWeakReference> supportsweak(do_QueryInterface(aChrome));
    1:       if (supportsweak) {
    1:         supportsweak->GetWeakReference(getter_AddRefs(info->mChromeWeak));
    1:       } else {
    1:         info->mChrome = aChrome;
    1:         info->mChromeWeak = 0;
    1:       }
    1:       return NS_OK;
    1:     }
    1:   
    1:     // create a window info struct and add it to the list of windows
    1:     info = new nsWatcherWindowEntry(aWindow, aChrome);
    1:     if (!info)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (mOldestWindow)
    1:       info->InsertAfter(mOldestWindow->mOlder);
    1:     else
    1:       mOldestWindow = info;
    1:   } // leave the mListLock
    1: 
    1:   // a window being added to us signifies a newly opened window.
    1:   // send notifications.
41540:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
41540:   if (!os)
41540:     return NS_ERROR_FAILURE;
41540: 
    1:   nsCOMPtr<nsISupports> domwin(do_QueryInterface(aWindow));
41540:   return os->NotifyObservers(domwin, "domwindowopened", 0);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::RemoveWindow(nsIDOMWindow *aWindow)
    1: {
    1:   // find the corresponding nsWatcherWindowEntry, remove it
    1: 
    1:   if (!aWindow)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsWatcherWindowEntry *info = FindWindowEntry(aWindow);
    1:   if (info) {
    1:     RemoveWindow(info);
    1:     return NS_OK;
    1:   }
    1:   NS_WARNING("requested removal of nonexistent window");
    1:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: nsWatcherWindowEntry *
    1: nsWindowWatcher::FindWindowEntry(nsIDOMWindow *aWindow)
    1: {
    1:   // find the corresponding nsWatcherWindowEntry
    1:   nsWatcherWindowEntry *info,
    1:                        *listEnd;
    1: #ifdef USEWEAKREFS
    1:   nsresult    rv;
    1:   PRBool      found;
    1: #endif
    1: 
    1:   info = mOldestWindow;
    1:   listEnd = 0;
    1: #ifdef USEWEAKREFS
    1:   rv = NS_OK;
    1:   found = PR_FALSE;
    1:   while (info != listEnd && NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDOMWindow> infoWindow(do_QueryReferent(info->mWindow));
    1:     if (!infoWindow) { // clean up dangling reference, while we're here
    1:       rv = RemoveWindow(info);
    1:     }
    1:     else if (infoWindow.get() == aWindow)
    1:       return info;
    1: 
    1:     info = info->mYounger;
    1:     listEnd = mOldestWindow;
    1:   }
    1:   return 0;
    1: #else
    1:   while (info != listEnd) {
    1:     if (info->mWindow == aWindow)
    1:       return info;
    1:     info = info->mYounger;
    1:     listEnd = mOldestWindow;
    1:   }
    1:   return 0;
    1: #endif
    1: }
    1: 
    1: nsresult nsWindowWatcher::RemoveWindow(nsWatcherWindowEntry *inInfo)
    1: {
25498:   PRUint32  ctr,
25498:             count = mEnumeratorList.Length();
    1: 
    1:   {
    1:     // notify the enumerators
    1:     nsAutoLock lock(mListLock);
    1:     for (ctr = 0; ctr < count; ++ctr) 
25498:       mEnumeratorList[ctr]->WindowRemoved(inInfo);
    1: 
    1:     // remove the element from the list
    1:     if (inInfo == mOldestWindow)
    1:       mOldestWindow = inInfo->mYounger == mOldestWindow ? 0 : inInfo->mYounger;
    1:     inInfo->Unlink();
    1:   }
    1: 
    1:   // a window being removed from us signifies a newly closed window.
    1:   // send notifications.
41540:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:   if (os) {
    1: #ifdef USEWEAKREFS
    1:     nsCOMPtr<nsISupports> domwin(do_QueryReferent(inInfo->mWindow));
    1:     if (domwin)
41540:       os->NotifyObservers(domwin, "domwindowclosed", 0);
    1:     // else bummer. since the window is gone, there's nothing to notify with.
    1: #else
    1:     nsCOMPtr<nsISupports> domwin(do_QueryInterface(inInfo->mWindow));
41540:     os->NotifyObservers(domwin, "domwindowclosed", 0);
    1: #endif
    1:   }
    1: 
    1:   delete inInfo;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetChromeForWindow(nsIDOMWindow *aWindow, nsIWebBrowserChrome **_retval)
    1: {
    1:   if (!aWindow || !_retval)
    1:     return NS_ERROR_INVALID_ARG;
    1:   *_retval = 0;
    1: 
    1:   nsAutoLock lock(mListLock);
    1:   nsWatcherWindowEntry *info = FindWindowEntry(aWindow);
    1:   if (info) {
    1:     if (info->mChromeWeak != nsnull) {
    1:       return info->mChromeWeak->
    1:                             QueryReferent(NS_GET_IID(nsIWebBrowserChrome),
 3233:                                           reinterpret_cast<void**>(_retval));
    1:     }
    1:     *_retval = info->mChrome;
    1:     NS_IF_ADDREF(*_retval);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindowWatcher::GetWindowByName(const PRUnichar *aTargetName, 
    1:                                  nsIDOMWindow *aCurrentWindow,
    1:                                  nsIDOMWindow **aResult)
    1: {
    1:   if (!aResult) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> startItem;
    1:   GetWindowTreeItem(aCurrentWindow, getter_AddRefs(startItem));
    1:   if (startItem) {
    1:     // Note: original requestor is null here, per idl comments
    1:     startItem->FindItemWithName(aTargetName, nsnull, nsnull,
    1:                                 getter_AddRefs(treeItem));
    1:   }
    1:   else {
    1:     // Note: original requestor is null here, per idl comments
    1:     FindItemWithName(aTargetName, nsnull, nsnull, getter_AddRefs(treeItem));
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindow> domWindow = do_GetInterface(treeItem);
    1:   domWindow.swap(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsWindowWatcher::AddEnumerator(nsWatcherWindowEnumerator* inEnumerator)
    1: {
    1:   // (requires a lock; assumes it's called by someone holding the lock)
25498:   return mEnumeratorList.AppendElement(inEnumerator) != nsnull;
    1: }
    1: 
    1: PRBool
    1: nsWindowWatcher::RemoveEnumerator(nsWatcherWindowEnumerator* inEnumerator)
    1: {
    1:   // (requires a lock; assumes it's called by someone holding the lock)
    1:   return mEnumeratorList.RemoveElement(inEnumerator);
    1: }
    1: 
    1: nsresult
    1: nsWindowWatcher::URIfromURL(const char *aURL,
    1:                             nsIDOMWindow *aParent,
    1:                             nsIURI **aURI)
    1: {
    1:   nsCOMPtr<nsIDOMWindow> baseWindow;
    1: 
    1:   /* build the URI relative to the calling JS Context, if any.
    1:      (note this is the same context used to make the security check
    1:      in nsGlobalWindow.cpp.) */
    1:   JSContext *cx = GetJSContextFromCallStack();
    1:   if (cx) {
    1:     nsIScriptContext *scriptcx = nsWWJSUtils::GetDynamicScriptContext(cx);
    1:     if (scriptcx) {
    1:       baseWindow = do_QueryInterface(scriptcx->GetGlobalObject());
    1:     }
    1:   }
    1: 
    1:   // failing that, build it relative to the parent window, if possible
    1:   if (!baseWindow)
    1:     baseWindow = aParent;
    1: 
    1:   // failing that, use the given URL unmodified. It had better not be relative.
    1: 
    1:   nsIURI *baseURI = nsnull;
    1: 
    1:   // get baseWindow's document URI
    1:   if (baseWindow) {
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     baseWindow->GetDocument(getter_AddRefs(domDoc));
    1:     if (domDoc) {
    1:       nsCOMPtr<nsIDocument> doc;
    1:       doc = do_QueryInterface(domDoc);
    1:       if (doc) {
41900:         baseURI = doc->GetDocBaseURI();
    1:       }
    1:     }
    1:   }
    1: 
    1:   // build and return the absolute URI
    1:   return NS_NewURI(aURI, aURL, baseURI);
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* Check for an illegal name e.g. frame3.1
    1:    This just prints a warning message an continues; we open the window anyway,
    1:    (see bug 32898). */
    1: void nsWindowWatcher::CheckWindowName(nsString& aName)
    1: {
    1:   nsReadingIterator<PRUnichar> scan;
    1:   nsReadingIterator<PRUnichar> endScan;
    1: 
    1:   aName.EndReading(endScan);
    1:   for (aName.BeginReading(scan); scan != endScan; ++scan)
    1:     if (!nsCRT::IsAsciiAlpha(*scan) && !nsCRT::IsAsciiDigit(*scan) &&
    1:         *scan != '_') {
    1: 
    1:       // Don't use js_ReportError as this will cause the application
    1:       // to shut down (JS_ASSERT calls abort())  See bug 32898
    1:       nsCAutoString warn;
    1:       warn.AssignLiteral("Illegal character in window name ");
    1:       AppendUTF16toUTF8(aName, warn);
    1:       NS_WARNING(warn.get());
    1:       break;
    1:     }
    1: }
    1: #endif // DEBUG
    1: 
    1: #define NS_CALCULATE_CHROME_FLAG_FOR(feature, flag)               \
    1:     prefBranch->GetBoolPref(feature, &forceEnable);               \
 5814:     if (forceEnable && !(aDialog && isChrome) &&                  \
 8072:         !(isChrome && aHasChromeParent) && !aChromeURL) {         \
    1:       chromeFlags |= flag;                                        \
    1:     } else {                                                      \
    1:       chromeFlags |= WinHasOption(aFeatures, feature,             \
    1:                                   0, &presenceFlag)               \
    1:                      ? flag : 0;                                  \
    1:     }
    1: 
    1: /**
    1:  * Calculate the chrome bitmask from a string list of features.
    1:  * @param aFeatures a string containing a list of named chrome features
    1:  * @param aNullFeatures true if aFeatures was a null pointer (which fact
    1:  *                      is lost by its conversion to a string in the caller)
    1:  * @param aDialog affects the assumptions made about unnamed features
    1:  * @return the chrome bitmask
    1:  */
 4040: // static
    1: PRUint32 nsWindowWatcher::CalculateChromeFlags(const char *aFeatures,
    1:                                                PRBool aFeaturesSpecified,
    1:                                                PRBool aDialog,
    1:                                                PRBool aChromeURL,
    1:                                                PRBool aHasChromeParent)
    1: {
    1:    if(!aFeaturesSpecified || !aFeatures) {
    1:       if(aDialog)
    1:          return nsIWebBrowserChrome::CHROME_ALL | 
    1:                 nsIWebBrowserChrome::CHROME_OPENAS_DIALOG | 
    1:                 nsIWebBrowserChrome::CHROME_OPENAS_CHROME;
    1:       else
    1:          return nsIWebBrowserChrome::CHROME_ALL;
    1:    }
    1: 
    1:   /* This function has become complicated since browser windows and
    1:      dialogs diverged. The difference is, browser windows assume all
    1:      chrome not explicitly mentioned is off, if the features string
    1:      is not null. Exceptions are some OS border chrome new with Mozilla.
    1:      Dialogs interpret a (mostly) empty features string to mean
    1:      "OS's choice," and also support an "all" flag explicitly disallowed
    1:      in the standards-compliant window.(normal)open. */
    1: 
    1:   PRUint32 chromeFlags = 0;
    1:   PRBool presenceFlag = PR_FALSE;
    1: 
    1:   chromeFlags = nsIWebBrowserChrome::CHROME_WINDOW_BORDERS;
    1:   if (aDialog && WinHasOption(aFeatures, "all", 0, &presenceFlag))
    1:     chromeFlags = nsIWebBrowserChrome::CHROME_ALL;
    1: 
    1:   /* Next, allow explicitly named options to override the initial settings */
    1: 
    1:   nsCOMPtr<nsIScriptSecurityManager>
    1:     securityManager(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
    1:   NS_ENSURE_TRUE(securityManager, NS_ERROR_FAILURE);
    1: 
    1:   PRBool isChrome = PR_FALSE;
    1:   securityManager->SubjectPrincipalIsSystem(&isChrome);
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefBranch;
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
    1: 
    1:   rv = prefs->GetBranch("dom.disable_window_open_feature.", getter_AddRefs(prefBranch));
    1:   NS_ENSURE_SUCCESS(rv, PR_TRUE);
    1: 
    1:   PRBool forceEnable = PR_FALSE;
    1: 
    1:   NS_CALCULATE_CHROME_FLAG_FOR("titlebar",
    1:                                nsIWebBrowserChrome::CHROME_TITLEBAR);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("close",
    1:                                nsIWebBrowserChrome::CHROME_WINDOW_CLOSE);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("toolbar",
    1:                                nsIWebBrowserChrome::CHROME_TOOLBAR);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("location",
    1:                                nsIWebBrowserChrome::CHROME_LOCATIONBAR);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("personalbar",
    1:                                nsIWebBrowserChrome::CHROME_PERSONAL_TOOLBAR);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("status",
    1:                                nsIWebBrowserChrome::CHROME_STATUSBAR);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("menubar",
    1:                                nsIWebBrowserChrome::CHROME_MENUBAR);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("scrollbars",
    1:                                nsIWebBrowserChrome::CHROME_SCROLLBARS);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("resizable",
    1:                                nsIWebBrowserChrome::CHROME_WINDOW_RESIZE);
    1:   NS_CALCULATE_CHROME_FLAG_FOR("minimizable",
    1:                                nsIWebBrowserChrome::CHROME_WINDOW_MIN);
    1: 
    1:   chromeFlags |= WinHasOption(aFeatures, "popup", 0, &presenceFlag)
    1:                  ? nsIWebBrowserChrome::CHROME_WINDOW_POPUP : 0; 
    1: 
    1:   /* OK.
    1:      Normal browser windows, in spite of a stated pattern of turning off
    1:      all chrome not mentioned explicitly, will want the new OS chrome (window
    1:      borders, titlebars, closebox) on, unless explicitly turned off.
    1:      Dialogs, on the other hand, take the absence of any explicit settings
    1:      to mean "OS' choice." */
    1: 
    1:   // default titlebar and closebox to "on," if not mentioned at all
48256:   if (!(chromeFlags & nsIWebBrowserChrome::CHROME_WINDOW_POPUP)) {
    1:     if (!PL_strcasestr(aFeatures, "titlebar"))
    1:       chromeFlags |= nsIWebBrowserChrome::CHROME_TITLEBAR;
    1:     if (!PL_strcasestr(aFeatures, "close"))
    1:       chromeFlags |= nsIWebBrowserChrome::CHROME_WINDOW_CLOSE;
48256:   }
    1: 
    1:   if (aDialog && !presenceFlag)
    1:     chromeFlags = nsIWebBrowserChrome::CHROME_DEFAULT;
    1: 
    1:   /* Finally, once all the above normal chrome has been divined, deal
    1:      with the features that are more operating hints than appearance
    1:      instructions. (Note modality implies dependence.) */
    1: 
    1:   if (WinHasOption(aFeatures, "alwaysLowered", 0, nsnull) ||
    1:       WinHasOption(aFeatures, "z-lock", 0, nsnull))
    1:     chromeFlags |= nsIWebBrowserChrome::CHROME_WINDOW_LOWERED;
    1:   else if (WinHasOption(aFeatures, "alwaysRaised", 0, nsnull))
    1:     chromeFlags |= nsIWebBrowserChrome::CHROME_WINDOW_RAISED;
    1: 
    1:   chromeFlags |= WinHasOption(aFeatures, "chrome", 0, nsnull) ?
    1:     nsIWebBrowserChrome::CHROME_OPENAS_CHROME : 0;
    1:   chromeFlags |= WinHasOption(aFeatures, "extrachrome", 0, nsnull) ?
    1:     nsIWebBrowserChrome::CHROME_EXTRA : 0;
    1:   chromeFlags |= WinHasOption(aFeatures, "centerscreen", 0, nsnull) ?
    1:     nsIWebBrowserChrome::CHROME_CENTER_SCREEN : 0;
    1:   chromeFlags |= WinHasOption(aFeatures, "dependent", 0, nsnull) ?
    1:     nsIWebBrowserChrome::CHROME_DEPENDENT : 0;
    1:   chromeFlags |= WinHasOption(aFeatures, "modal", 0, nsnull) ?
    1:     (nsIWebBrowserChrome::CHROME_MODAL | nsIWebBrowserChrome::CHROME_DEPENDENT) : 0;
    1:   chromeFlags |= WinHasOption(aFeatures, "dialog", 0, nsnull) ?
    1:     nsIWebBrowserChrome::CHROME_OPENAS_DIALOG : 0;
    1: 
    1:   /* and dialogs need to have the last word. assume dialogs are dialogs,
    1:      and opened as chrome, unless explicitly told otherwise. */
    1:   if (aDialog) {
    1:     if (!PL_strcasestr(aFeatures, "dialog"))
    1:       chromeFlags |= nsIWebBrowserChrome::CHROME_OPENAS_DIALOG;
    1:     if (!PL_strcasestr(aFeatures, "chrome"))
    1:       chromeFlags |= nsIWebBrowserChrome::CHROME_OPENAS_CHROME;
    1:   }
    1: 
    1:   /* missing
    1:      chromeFlags->copy_history
    1:    */
    1: 
    1:   // Check security state for use in determing window dimensions
    1:   PRBool enabled;
    1:   nsresult res =
    1:     securityManager->IsCapabilityEnabled("UniversalBrowserWrite", &enabled);
    1: 
    1:   if (NS_FAILED(res) || !enabled || (isChrome && !aHasChromeParent)) {
    1:     // If priv check fails (or if we're called from chrome, but the
    1:     // parent is not a chrome window), set all elements to minimum
    1:     // reqs., else leave them alone.
    1:     chromeFlags |= nsIWebBrowserChrome::CHROME_TITLEBAR;
    1:     chromeFlags |= nsIWebBrowserChrome::CHROME_WINDOW_CLOSE;
    1:     chromeFlags &= ~nsIWebBrowserChrome::CHROME_WINDOW_LOWERED;
    1:     chromeFlags &= ~nsIWebBrowserChrome::CHROME_WINDOW_RAISED;
    1:     chromeFlags &= ~nsIWebBrowserChrome::CHROME_WINDOW_POPUP;
    1:     /* Untrusted script is allowed to pose modal windows with a chrome
    1:        scheme. This check could stand to be better. But it effectively
    1:        prevents untrusted script from opening modal windows in general
    1:        while still allowing alerts and the like. */
    1:     if (!aChromeURL)
13096:       chromeFlags &= ~(nsIWebBrowserChrome::CHROME_MODAL |
13096:                        nsIWebBrowserChrome::CHROME_OPENAS_CHROME);
    1:   }
    1: 
    1:   if (!(chromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME)) {
    1:     // Remove the dependent flag if we're not opening as chrome
    1:     chromeFlags &= ~nsIWebBrowserChrome::CHROME_DEPENDENT;
    1:   }
    1: 
    1:   return chromeFlags;
    1: }
    1: 
 4040: // static
    1: PRInt32
    1: nsWindowWatcher::WinHasOption(const char *aOptions, const char *aName,
    1:                               PRInt32 aDefault, PRBool *aPresenceFlag)
    1: {
    1:   if (!aOptions)
    1:     return 0;
    1: 
    1:   char *comma, *equal;
    1:   PRInt32 found = 0;
    1: 
    1: #ifdef DEBUG
    1:     nsCAutoString options(aOptions);
    1:     NS_ASSERTION(options.FindCharInSet(" \n\r\t") == kNotFound, 
    1:                   "There should be no whitespace in this string!");
    1: #endif
    1: 
    1:   while (PR_TRUE) {
    1:     comma = PL_strchr(aOptions, ',');
    1:     if (comma)
    1:       *comma = '\0';
    1:     equal = PL_strchr(aOptions, '=');
    1:     if (equal)
    1:       *equal = '\0';
    1:     if (nsCRT::strcasecmp(aOptions, aName) == 0) {
    1:       if (aPresenceFlag)
    1:         *aPresenceFlag = PR_TRUE;
    1:       if (equal)
    1:         if (*(equal + 1) == '*')
    1:           found = aDefault;
    1:         else if (nsCRT::strcasecmp(equal + 1, "yes") == 0)
    1:           found = 1;
    1:         else
    1:           found = atoi(equal + 1);
    1:       else
    1:         found = 1;
    1:     }
    1:     if (equal)
    1:       *equal = '=';
    1:     if (comma)
    1:       *comma = ',';
    1:     if (found || !comma)
    1:       break;
    1:     aOptions = comma + 1;
    1:   }
    1:   return found;
    1: }
    1: 
    1: /* try to find an nsIDocShellTreeItem with the given name in any
    1:    known open window. a failure to find the item will not
    1:    necessarily return a failure method value. check aFoundItem.
    1: */
    1: NS_IMETHODIMP
    1: nsWindowWatcher::FindItemWithName(const PRUnichar* aName,
    1:                                   nsIDocShellTreeItem* aRequestor,
    1:                                   nsIDocShellTreeItem* aOriginalRequestor,
    1:                                   nsIDocShellTreeItem** aFoundItem)
    1: {
    1:   *aFoundItem = 0;
    1: 
    1:   /* special cases */
    1:   if(!aName || !*aName)
    1:     return NS_OK;
    1: 
    1:   nsDependentString name(aName);
    1:   
    1:   nsCOMPtr<nsISimpleEnumerator> windows;
    1:   GetWindowEnumerator(getter_AddRefs(windows));
    1:   if (!windows)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRBool   more;
    1:   nsresult rv = NS_OK;
    1: 
    1:   do {
    1:     windows->HasMoreElements(&more);
    1:     if (!more)
    1:       break;
    1:     nsCOMPtr<nsISupports> nextSupWindow;
    1:     windows->GetNext(getter_AddRefs(nextSupWindow));
    1:     nsCOMPtr<nsIDOMWindow> nextWindow(do_QueryInterface(nextSupWindow));
    1:     if (nextWindow) {
    1:       nsCOMPtr<nsIDocShellTreeItem> treeItem;
    1:       GetWindowTreeItem(nextWindow, getter_AddRefs(treeItem));
    1:       if (treeItem) {
    1:         // Get the root tree item of same type, since roots are the only
    1:         // things that call into the treeowner to look for named items.
    1:         nsCOMPtr<nsIDocShellTreeItem> root;
    1:         treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:         NS_ASSERTION(root, "Must have root tree item of same type");
    1:         // Make sure not to call back into aRequestor
    1:         if (root != aRequestor) {
    1:           // Get the tree owner so we can pass it in as the requestor so
    1:           // the child knows not to call back up, since we're walking
    1:           // all windows already.
    1:           nsCOMPtr<nsIDocShellTreeOwner> rootOwner;
    1:           // Note: if we have no aRequestor, then we want to also look for
    1:           // "special" window names, so pass a null requestor.  This will mean
    1:           // that the treeitem calls back up to us, effectively (with a
    1:           // non-null aRequestor), so break the loop immediately after the
    1:           // call in that case.
    1:           if (aRequestor) {
    1:             root->GetTreeOwner(getter_AddRefs(rootOwner));
    1:           }
    1:           rv = root->FindItemWithName(aName, rootOwner, aOriginalRequestor,
    1:                                       aFoundItem);
    1:           if (NS_FAILED(rv) || *aFoundItem || !aRequestor)
    1:             break;
    1:         }
    1:       }
    1:     }
    1:   } while(1);
    1: 
    1:   return rv;
    1: }
    1: 
    1: already_AddRefed<nsIDocShellTreeItem>
    1: nsWindowWatcher::GetCallerTreeItem(nsIDocShellTreeItem* aParentItem)
    1: {
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:     do_GetService(sJSStackContractID);
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   if (stack) {
    1:     stack->Peek(&cx);
    1:   }
    1: 
    1:   nsIDocShellTreeItem* callerItem = nsnull;
    1: 
    1:   if (cx) {
    1:     nsCOMPtr<nsIWebNavigation> callerWebNav =
    1:       do_GetInterface(nsWWJSUtils::GetDynamicScriptGlobal(cx));
    1: 
    1:     if (callerWebNav) {
    1:       CallQueryInterface(callerWebNav, &callerItem);
    1:     }
    1:   }
    1: 
    1:   if (!callerItem) {
    1:     NS_IF_ADDREF(callerItem = aParentItem);
    1:   }
    1: 
    1:   return callerItem;
    1: }
    1: 
    1: nsresult
    1: nsWindowWatcher::SafeGetWindowByName(const nsAString& aName,
    1:                                      nsIDOMWindow* aCurrentWindow,
    1:                                      nsIDOMWindow** aResult)
    1: {
    1:   *aResult = nsnull;
    1:   
    1:   nsCOMPtr<nsIDocShellTreeItem> startItem;
    1:   GetWindowTreeItem(aCurrentWindow, getter_AddRefs(startItem));
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> callerItem = GetCallerTreeItem(startItem);
    1: 
    1:   const nsAFlatString& flatName = PromiseFlatString(aName);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> foundItem;
    1:   if (startItem) {
    1:     startItem->FindItemWithName(flatName.get(), nsnull, callerItem,
    1:                                 getter_AddRefs(foundItem));
    1:   }
    1:   else {
    1:     FindItemWithName(flatName.get(), nsnull, callerItem,
    1:                      getter_AddRefs(foundItem));
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindow> foundWin = do_GetInterface(foundItem);
    1:   foundWin.swap(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: /* Fetch the nsIDOMWindow corresponding to the given nsIDocShellTreeItem.
    1:    This forces the creation of a script context, if one has not already
    1:    been created. Note it also sets the window's opener to the parent,
    1:    if applicable -- because it's just convenient, that's all. null aParent
    1:    is acceptable. */
    1: nsresult
    1: nsWindowWatcher::ReadyOpenedDocShellItem(nsIDocShellTreeItem *aOpenedItem,
    1:                                          nsIDOMWindow        *aParent,
    1:                                          PRBool              aWindowIsNew,
    1:                                          nsIDOMWindow        **aOpenedWindow)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   *aOpenedWindow = 0;
    1:   nsCOMPtr<nsPIDOMWindow> piOpenedWindow(do_GetInterface(aOpenedItem));
    1:   if (piOpenedWindow) {
    1:     if (aParent) {
    1:       nsCOMPtr<nsIDOMWindowInternal> internalParent(do_QueryInterface(aParent));
    1:       piOpenedWindow->SetOpenerWindow(internalParent, aWindowIsNew); // damnit
    1: 
    1:       if (aWindowIsNew) {
    1: #ifdef DEBUG
    1:         // Assert that we're not loading things right now.  If we are, when
    1:         // that load completes it will clobber whatever principals we set up
    1:         // on this new window!
    1:         nsCOMPtr<nsIDocumentLoader> docloader =
    1:           do_QueryInterface(aOpenedItem);
    1:         NS_ASSERTION(docloader, "How can we not have a docloader here?");
    1: 
    1:         nsCOMPtr<nsIChannel> chan;
    1:         docloader->GetDocumentChannel(getter_AddRefs(chan));
    1:         NS_ASSERTION(!chan, "Why is there a document channel?");
    1: #endif
    1: 
    1:         nsCOMPtr<nsIDocument> doc =
    1:           do_QueryInterface(piOpenedWindow->GetExtantDocument());
    1:         if (doc) {
    1:           doc->SetIsInitialDocument(PR_TRUE);
    1:         }
    1:       }
    1:     }
    1:     rv = CallQueryInterface(piOpenedWindow, aOpenedWindow);
    1:   }
    1:   return rv;
    1: }
    1: 
 4040: // static
    1: void
    1: nsWindowWatcher::CalcSizeSpec(const char* aFeatures, SizeSpec& aResult)
    1: {
    1:   // Parse position spec, if any, from aFeatures
    1:   PRBool  present;
    1:   PRInt32 temp;
    1: 
    1:   present = PR_FALSE;
    1:   if ((temp = WinHasOption(aFeatures, "left", 0, &present)) || present)
    1:     aResult.mLeft = temp;
    1:   else if ((temp = WinHasOption(aFeatures, "screenX", 0, &present)) || present)
    1:     aResult.mLeft = temp;
    1:   aResult.mLeftSpecified = present;
    1: 
    1:   present = PR_FALSE;
    1:   if ((temp = WinHasOption(aFeatures, "top", 0, &present)) || present)
    1:     aResult.mTop = temp;
    1:   else if ((temp = WinHasOption(aFeatures, "screenY", 0, &present)) || present)
    1:     aResult.mTop = temp;
    1:   aResult.mTopSpecified = present;
    1: 
    1:   // Parse size spec, if any. Chrome size overrides content size.
    1:   if ((temp = WinHasOption(aFeatures, "outerWidth", PR_INT32_MIN, nsnull))) {
    1:     if (temp == PR_INT32_MIN) {
    1:       aResult.mUseDefaultWidth = PR_TRUE;
    1:     }
    1:     else {
    1:       aResult.mOuterWidth = temp;
    1:     }
    1:     aResult.mOuterWidthSpecified = PR_TRUE;
    1:   } else if ((temp = WinHasOption(aFeatures, "width", PR_INT32_MIN, nsnull)) ||
    1:              (temp = WinHasOption(aFeatures, "innerWidth", PR_INT32_MIN,
    1:                                   nsnull))) {
    1:     if (temp == PR_INT32_MIN) {
    1:       aResult.mUseDefaultWidth = PR_TRUE;
    1:     } else {
    1:       aResult.mInnerWidth = temp;
    1:     }
    1:     aResult.mInnerWidthSpecified = PR_TRUE;
    1:   }
    1: 
    1:   if ((temp = WinHasOption(aFeatures, "outerHeight", PR_INT32_MIN, nsnull))) {
    1:     if (temp == PR_INT32_MIN) {
    1:       aResult.mUseDefaultHeight = PR_TRUE;
    1:     }
    1:     else {
    1:       aResult.mOuterHeight = temp;
    1:     }
    1:     aResult.mOuterHeightSpecified = PR_TRUE;
    1:   } else if ((temp = WinHasOption(aFeatures, "height", PR_INT32_MIN,
    1:                                   nsnull)) ||
    1:              (temp = WinHasOption(aFeatures, "innerHeight", PR_INT32_MIN,
    1:                                   nsnull))) {
    1:     if (temp == PR_INT32_MIN) {
    1:       aResult.mUseDefaultHeight = PR_TRUE;
    1:     } else {
    1:       aResult.mInnerHeight = temp;
    1:     }
    1:     aResult.mInnerHeightSpecified = PR_TRUE;
    1:   }
    1: }
    1: 
    1: /* Size and position the new window according to aSizeSpec. This method
    1:    is assumed to be called after the window has already been given
    1:    a default position and size; thus its current position and size are
    1:    accurate defaults. The new window is made visible at method end.
    1: */
    1: void
    1: nsWindowWatcher::SizeOpenedDocShellItem(nsIDocShellTreeItem *aDocShellItem,
    1:                                         nsIDOMWindow *aParent,
    1:                                         const SizeSpec & aSizeSpec)
    1: {
    1:   // position and size of window
    1:   PRInt32 left = 0,
    1:           top = 0,
    1:           width = 100,
    1:           height = 100;
    1:   // difference between chrome and content size
    1:   PRInt32 chromeWidth = 0,
    1:           chromeHeight = 0;
    1:   // whether the window size spec refers to chrome or content
    1:   PRBool  sizeChromeWidth = PR_TRUE,
    1:           sizeChromeHeight = PR_TRUE;
    1: 
    1:   // get various interfaces for aDocShellItem, used throughout this method
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   aDocShellItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin(do_QueryInterface(treeOwner));
    1:   if (!treeOwnerAsWin) // we'll need this to actually size the docshell
    1:     return;
    1:     
 8624:   float devPixelsPerCSSPixel = 1.0;
52352:   if (aParent) {
52352:     nsCOMPtr<nsIDOMDocument> openerDoc;
52352:     aParent->GetDocument(getter_AddRefs(openerDoc));
52352:     if (openerDoc) {
52352:       nsCOMPtr<nsIDocument> doc = do_QueryInterface(openerDoc);
52352:       nsIPresShell* shell = doc->GetShell();
52352:       if (shell) {
52352:         nsPresContext* presContext = shell->GetPresContext();
52352:         if (presContext) {
52352:           devPixelsPerCSSPixel = presContext->CSSPixelsToDevPixels(1.0f);
 8624:         }
35432:       }
35432:     }
 8624:   }
 8369: 
    1:   /* The current position and size will be unchanged if not specified
    1:      (and they fit entirely onscreen). Also, calculate the difference
    1:      between chrome and content sizes on aDocShellItem's window.
    1:      This latter point becomes important if chrome and content
    1:      specifications are mixed in aFeatures, and when bringing the window
    1:      back from too far off the right or bottom edges of the screen. */
    1: 
    1:   treeOwnerAsWin->GetPositionAndSize(&left, &top, &width, &height);
    1:   { // scope shellWindow why not
    1:     nsCOMPtr<nsIBaseWindow> shellWindow(do_QueryInterface(aDocShellItem));
    1:     if (shellWindow) {
    1:       PRInt32 cox, coy;
    1:       shellWindow->GetSize(&cox, &coy);
    1:       chromeWidth = width - cox;
    1:       chromeHeight = height - coy;
    1:     }
    1:   }
    1: 
    1:   // Set up left/top
    1:   if (aSizeSpec.mLeftSpecified) {
 8624:     left = NSToIntRound(aSizeSpec.mLeft * devPixelsPerCSSPixel);
    1:   }
    1: 
    1:   if (aSizeSpec.mTopSpecified) {
 8624:     top = NSToIntRound(aSizeSpec.mTop * devPixelsPerCSSPixel);
    1:   }
    1: 
    1:   // Set up width
    1:   if (aSizeSpec.mOuterWidthSpecified) {
    1:     if (!aSizeSpec.mUseDefaultWidth) {
 8624:       width = NSToIntRound(aSizeSpec.mOuterWidth * devPixelsPerCSSPixel);
    1:     } // Else specified to default; just use our existing width
    1:   }
    1:   else if (aSizeSpec.mInnerWidthSpecified) {
    1:     sizeChromeWidth = PR_FALSE;
    1:     if (aSizeSpec.mUseDefaultWidth) {
    1:       width = width - chromeWidth;
    1:     } else {
 8624:       width = NSToIntRound(aSizeSpec.mInnerWidth * devPixelsPerCSSPixel);
    1:     }
    1:   }
    1: 
    1:   // Set up height
    1:   if (aSizeSpec.mOuterHeightSpecified) {
    1:     if (!aSizeSpec.mUseDefaultHeight) {
 8624:       height = NSToIntRound(aSizeSpec.mOuterHeight * devPixelsPerCSSPixel);
    1:     } // Else specified to default; just use our existing height
    1:   }
    1:   else if (aSizeSpec.mInnerHeightSpecified) {
    1:     sizeChromeHeight = PR_FALSE;
    1:     if (aSizeSpec.mUseDefaultHeight) {
    1:       height = height - chromeHeight;
    1:     } else {
 8624:       height = NSToIntRound(aSizeSpec.mInnerHeight * devPixelsPerCSSPixel);
    1:     }
    1:   }
    1: 
    1:   PRBool positionSpecified = aSizeSpec.PositionSpecified();
    1:   
    1:   nsresult res;
    1:   PRBool enabled = PR_FALSE;
    1: 
    1:   // Check security state for use in determing window dimensions
    1:   nsCOMPtr<nsIScriptSecurityManager>
    1:     securityManager(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
    1:   if (securityManager) {
    1:     res = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
    1:                                                &enabled);
    1:     if (NS_FAILED(res))
    1:       enabled = PR_FALSE;
    1:     else if (enabled && aParent) {
    1:       nsCOMPtr<nsIDOMChromeWindow> chromeWin(do_QueryInterface(aParent));
    1: 
    1:       PRBool isChrome = PR_FALSE;
    1:       securityManager->SubjectPrincipalIsSystem(&isChrome);
    1: 
    1:       // Only enable special priveleges for chrome when chrome calls
    1:       // open() on a chrome window
    1:       enabled = !(isChrome && chromeWin == nsnull);
    1:     }
    1:   }
    1: 
    1:   if (!enabled) {
    1: 
    1:     // Security check failed.  Ensure all args meet minimum reqs.
    1: 
    1:     PRInt32 oldTop = top,
    1:             oldLeft = left;
    1: 
    1:     // We'll also need the screen dimensions
    1:     nsCOMPtr<nsIScreen> screen;
    1:     nsCOMPtr<nsIScreenManager> screenMgr(do_GetService(
    1:                                          "@mozilla.org/gfx/screenmanager;1"));
    1:     if (screenMgr)
    1:       screenMgr->ScreenForRect(left, top, width, height,
    1:                                getter_AddRefs(screen));
    1:     if (screen) {
    1:       PRInt32 screenLeft, screenTop, screenWidth, screenHeight;
    1:       PRInt32 winWidth = width + (sizeChromeWidth ? 0 : chromeWidth),
    1:               winHeight = height + (sizeChromeHeight ? 0 : chromeHeight);
    1: 
    1:       screen->GetAvailRect(&screenLeft, &screenTop,
    1:                            &screenWidth, &screenHeight);
    1: 
    1:       if (aSizeSpec.SizeSpecified()) {
    1:         /* Unlike position, force size out-of-bounds check only if
    1:            size actually was specified. Otherwise, intrinsically sized
    1:            windows are broken. */
    1:         if (height < 100)
    1:           height = 100;
    1:         if (winHeight > screenHeight)
    1:           height = screenHeight - (sizeChromeHeight ? 0 : chromeHeight);
    1:         if (width < 100)
    1:           width = 100;
    1:         if (winWidth > screenWidth)
    1:           width = screenWidth - (sizeChromeWidth ? 0 : chromeWidth);
    1:       }
    1: 
    1:       if (left+winWidth > screenLeft+screenWidth)
    1:         left = screenLeft+screenWidth - winWidth;
    1:       if (left < screenLeft)
    1:         left = screenLeft;
    1:       if (top+winHeight > screenTop+screenHeight)
    1:         top = screenTop+screenHeight - winHeight;
    1:       if (top < screenTop)
    1:         top = screenTop;
    1:       if (top != oldTop || left != oldLeft)
    1:         positionSpecified = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   // size and position the window
    1: 
    1:   if (positionSpecified)
    1:     treeOwnerAsWin->SetPosition(left, top);
    1:   if (aSizeSpec.SizeSpecified()) {
    1:     /* Prefer to trust the interfaces, which think in terms of pure
    1:        chrome or content sizes. If we have a mix, use the chrome size
    1:        adjusted by the chrome/content differences calculated earlier. */
    1:     if (!sizeChromeWidth && !sizeChromeHeight)
    1:       treeOwner->SizeShellTo(aDocShellItem, width, height);
    1:     else {
    1:       if (!sizeChromeWidth)
    1:         width += chromeWidth;
    1:       if (!sizeChromeHeight)
    1:         height += chromeHeight;
    1:       treeOwnerAsWin->SetSize(width, height, PR_FALSE);
    1:     }
    1:   }
    1:   treeOwnerAsWin->SetVisibility(PR_TRUE);
    1: }
    1: 
    1: void
    1: nsWindowWatcher::GetWindowTreeItem(nsIDOMWindow *inWindow,
    1:                                    nsIDocShellTreeItem **outTreeItem)
    1: {
    1:   *outTreeItem = 0;
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(inWindow));
    1:   if (window) {
    1:     nsIDocShell *docshell = window->GetDocShell();
    1:     if (docshell)
    1:       CallQueryInterface(docshell, outTreeItem);
    1:   }
    1: }
    1: 
    1: void
    1: nsWindowWatcher::GetWindowTreeOwner(nsIDOMWindow *inWindow,
    1:                                     nsIDocShellTreeOwner **outTreeOwner)
    1: {
    1:   *outTreeOwner = 0;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem;
    1:   GetWindowTreeItem(inWindow, getter_AddRefs(treeItem));
    1:   if (treeItem)
    1:     treeItem->GetTreeOwner(outTreeOwner);
    1: }
    1: 
    1: JSContext *
    1: nsWindowWatcher::GetJSContextFromCallStack()
    1: {
    1:   JSContext *cx = 0;
    1: 
    1:   nsCOMPtr<nsIThreadJSContextStack> cxStack(do_GetService(sJSStackContractID));
    1:   if (cxStack)
    1:     cxStack->Peek(&cx);
    1: 
    1:   return cx;
    1: }
    1: 
    1: JSContext *
    1: nsWindowWatcher::GetJSContextFromWindow(nsIDOMWindow *aWindow)
    1: {
    1:   JSContext *cx = 0;
    1: 
    1:   if (aWindow) {
    1:     nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryInterface(aWindow));
    1:     if (sgo) {
    1:       nsIScriptContext *scx = sgo->GetContext();
    1:       if (scx)
    1:         cx = (JSContext *) scx->GetNativeContext();
    1:     }
    1:     /* (off-topic note:) the nsIScriptContext can be retrieved by
    1:     nsCOMPtr<nsIScriptContext> scx;
    1:     nsJSUtils::GetDynamicScriptContext(cx, getter_AddRefs(scx));
    1:     */
    1:   }
    1: 
    1:   return cx;
    1: }
