16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: normalized modified discrete cosine transform
16295:            power of two length transform only [64 <= n ]
31034:  last mod: $Id: mdct.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  Original algorithm adapted long ago from _The use of multirate filter
16295:  banks for coding of high quality digital audio_, by T. Sporer,
16295:  K. Brandenburg and B. Edler, collection of the European Signal
16295:  Processing Conference (EUSIPCO), Amsterdam, June 1992, Vol.1, pp
16295:  211-214
16295: 
16295:  The below code implements an algorithm that no longer looks much like
16295:  that presented in the paper, but the basic structure remains if you
16295:  dig deep enough to see it.
16295: 
16295:  This module DOES NOT INCLUDE code to generate/apply the window
16295:  function.  Everybody has their own weird favorite including me... I
16295:  happen to like the properties of y=sin(.5PI*sin^2(x)), but others may
16295:  vehemently disagree.
16295: 
16295:  ********************************************************************/
16295: 
16295: /* this can also be run as an integer transform by uncommenting a
16295:    define in mdct.h; the integerization is a first pass and although
16295:    it's likely stable for Vorbis, the dynamic range is constrained and
16295:    roundoff isn't done (so it's noisy).  Consider it functional, but
16295:    only a starting point.  There's no point on a machine with an FPU */
16295: 
16295: #include <stdio.h>
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include "vorbis/codec.h"
16295: #include "mdct.h"
16295: #include "os.h"
16295: #include "misc.h"
16295: 
16295: /* build lookups for trig functions; also pre-figure scaling and
16295:    some window function algebra. */
16295: 
16295: void mdct_init(mdct_lookup *lookup,int n){
16295:   int   *bitrev=_ogg_malloc(sizeof(*bitrev)*(n/4));
16295:   DATA_TYPE *T=_ogg_malloc(sizeof(*T)*(n+n/4));
16295: 
16295:   int i;
16295:   int n2=n>>1;
16295:   int log2n=lookup->log2n=rint(log((float)n)/log(2.f));
16295:   lookup->n=n;
16295:   lookup->trig=T;
16295:   lookup->bitrev=bitrev;
16295: 
16295: /* trig lookups... */
16295: 
16295:   for(i=0;i<n/4;i++){
16295:     T[i*2]=FLOAT_CONV(cos((M_PI/n)*(4*i)));
16295:     T[i*2+1]=FLOAT_CONV(-sin((M_PI/n)*(4*i)));
16295:     T[n2+i*2]=FLOAT_CONV(cos((M_PI/(2*n))*(2*i+1)));
16295:     T[n2+i*2+1]=FLOAT_CONV(sin((M_PI/(2*n))*(2*i+1)));
16295:   }
16295:   for(i=0;i<n/8;i++){
16295:     T[n+i*2]=FLOAT_CONV(cos((M_PI/n)*(4*i+2))*.5);
16295:     T[n+i*2+1]=FLOAT_CONV(-sin((M_PI/n)*(4*i+2))*.5);
16295:   }
16295: 
16295:   /* bitreverse lookup... */
16295: 
16295:   {
16295:     int mask=(1<<(log2n-1))-1,i,j;
16295:     int msb=1<<(log2n-2);
16295:     for(i=0;i<n/8;i++){
16295:       int acc=0;
16295:       for(j=0;msb>>j;j++)
16295:         if((msb>>j)&i)acc|=1<<j;
16295:       bitrev[i*2]=((~acc)&mask)-1;
16295:       bitrev[i*2+1]=acc;
16295: 
16295:     }
16295:   }
16295:   lookup->scale=FLOAT_CONV(4.f/n);
16295: }
16295: 
16295: /* 8 point butterfly (in place, 4 register) */
16295: STIN void mdct_butterfly_8(DATA_TYPE *x){
16295:   REG_TYPE r0   = x[6] + x[2];
16295:   REG_TYPE r1   = x[6] - x[2];
16295:   REG_TYPE r2   = x[4] + x[0];
16295:   REG_TYPE r3   = x[4] - x[0];
16295: 
16295:            x[6] = r0   + r2;
16295:            x[4] = r0   - r2;
16295: 
16295:            r0   = x[5] - x[1];
16295:            r2   = x[7] - x[3];
16295:            x[0] = r1   + r0;
16295:            x[2] = r1   - r0;
16295: 
16295:            r0   = x[5] + x[1];
16295:            r1   = x[7] + x[3];
16295:            x[3] = r2   + r3;
16295:            x[1] = r2   - r3;
16295:            x[7] = r1   + r0;
16295:            x[5] = r1   - r0;
16295: 
16295: }
16295: 
16295: /* 16 point butterfly (in place, 4 register) */
16295: STIN void mdct_butterfly_16(DATA_TYPE *x){
16295:   REG_TYPE r0     = x[1]  - x[9];
16295:   REG_TYPE r1     = x[0]  - x[8];
16295: 
16295:            x[8]  += x[0];
16295:            x[9]  += x[1];
16295:            x[0]   = MULT_NORM((r0   + r1) * cPI2_8);
16295:            x[1]   = MULT_NORM((r0   - r1) * cPI2_8);
16295: 
16295:            r0     = x[3]  - x[11];
16295:            r1     = x[10] - x[2];
16295:            x[10] += x[2];
16295:            x[11] += x[3];
16295:            x[2]   = r0;
16295:            x[3]   = r1;
16295: 
16295:            r0     = x[12] - x[4];
16295:            r1     = x[13] - x[5];
16295:            x[12] += x[4];
16295:            x[13] += x[5];
16295:            x[4]   = MULT_NORM((r0   - r1) * cPI2_8);
16295:            x[5]   = MULT_NORM((r0   + r1) * cPI2_8);
16295: 
16295:            r0     = x[14] - x[6];
16295:            r1     = x[15] - x[7];
16295:            x[14] += x[6];
16295:            x[15] += x[7];
16295:            x[6]  = r0;
16295:            x[7]  = r1;
16295: 
16295:            mdct_butterfly_8(x);
16295:            mdct_butterfly_8(x+8);
16295: }
16295: 
16295: /* 32 point butterfly (in place, 4 register) */
16295: STIN void mdct_butterfly_32(DATA_TYPE *x){
16295:   REG_TYPE r0     = x[30] - x[14];
16295:   REG_TYPE r1     = x[31] - x[15];
16295: 
16295:            x[30] +=         x[14];
16295:            x[31] +=         x[15];
16295:            x[14]  =         r0;
16295:            x[15]  =         r1;
16295: 
16295:            r0     = x[28] - x[12];
16295:            r1     = x[29] - x[13];
16295:            x[28] +=         x[12];
16295:            x[29] +=         x[13];
16295:            x[12]  = MULT_NORM( r0 * cPI1_8  -  r1 * cPI3_8 );
16295:            x[13]  = MULT_NORM( r0 * cPI3_8  +  r1 * cPI1_8 );
16295: 
16295:            r0     = x[26] - x[10];
16295:            r1     = x[27] - x[11];
16295:            x[26] +=         x[10];
16295:            x[27] +=         x[11];
16295:            x[10]  = MULT_NORM(( r0  - r1 ) * cPI2_8);
16295:            x[11]  = MULT_NORM(( r0  + r1 ) * cPI2_8);
16295: 
16295:            r0     = x[24] - x[8];
16295:            r1     = x[25] - x[9];
16295:            x[24] += x[8];
16295:            x[25] += x[9];
16295:            x[8]   = MULT_NORM( r0 * cPI3_8  -  r1 * cPI1_8 );
16295:            x[9]   = MULT_NORM( r1 * cPI3_8  +  r0 * cPI1_8 );
16295: 
16295:            r0     = x[22] - x[6];
16295:            r1     = x[7]  - x[23];
16295:            x[22] += x[6];
16295:            x[23] += x[7];
16295:            x[6]   = r1;
16295:            x[7]   = r0;
16295: 
16295:            r0     = x[4]  - x[20];
16295:            r1     = x[5]  - x[21];
16295:            x[20] += x[4];
16295:            x[21] += x[5];
16295:            x[4]   = MULT_NORM( r1 * cPI1_8  +  r0 * cPI3_8 );
16295:            x[5]   = MULT_NORM( r1 * cPI3_8  -  r0 * cPI1_8 );
16295: 
16295:            r0     = x[2]  - x[18];
16295:            r1     = x[3]  - x[19];
16295:            x[18] += x[2];
16295:            x[19] += x[3];
16295:            x[2]   = MULT_NORM(( r1  + r0 ) * cPI2_8);
16295:            x[3]   = MULT_NORM(( r1  - r0 ) * cPI2_8);
16295: 
16295:            r0     = x[0]  - x[16];
16295:            r1     = x[1]  - x[17];
16295:            x[16] += x[0];
16295:            x[17] += x[1];
16295:            x[0]   = MULT_NORM( r1 * cPI3_8  +  r0 * cPI1_8 );
16295:            x[1]   = MULT_NORM( r1 * cPI1_8  -  r0 * cPI3_8 );
16295: 
16295:            mdct_butterfly_16(x);
16295:            mdct_butterfly_16(x+16);
16295: 
16295: }
16295: 
16295: /* N point first stage butterfly (in place, 2 register) */
16295: STIN void mdct_butterfly_first(DATA_TYPE *T,
16295:                                         DATA_TYPE *x,
16295:                                         int points){
16295: 
16295:   DATA_TYPE *x1        = x          + points      - 8;
16295:   DATA_TYPE *x2        = x          + (points>>1) - 8;
16295:   REG_TYPE   r0;
16295:   REG_TYPE   r1;
16295: 
16295:   do{
16295: 
16295:                r0      = x1[6]      -  x2[6];
16295:                r1      = x1[7]      -  x2[7];
16295:                x1[6]  += x2[6];
16295:                x1[7]  += x2[7];
16295:                x2[6]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
16295:                x2[7]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
16295: 
16295:                r0      = x1[4]      -  x2[4];
16295:                r1      = x1[5]      -  x2[5];
16295:                x1[4]  += x2[4];
16295:                x1[5]  += x2[5];
16295:                x2[4]   = MULT_NORM(r1 * T[5]  +  r0 * T[4]);
16295:                x2[5]   = MULT_NORM(r1 * T[4]  -  r0 * T[5]);
16295: 
16295:                r0      = x1[2]      -  x2[2];
16295:                r1      = x1[3]      -  x2[3];
16295:                x1[2]  += x2[2];
16295:                x1[3]  += x2[3];
16295:                x2[2]   = MULT_NORM(r1 * T[9]  +  r0 * T[8]);
16295:                x2[3]   = MULT_NORM(r1 * T[8]  -  r0 * T[9]);
16295: 
16295:                r0      = x1[0]      -  x2[0];
16295:                r1      = x1[1]      -  x2[1];
16295:                x1[0]  += x2[0];
16295:                x1[1]  += x2[1];
16295:                x2[0]   = MULT_NORM(r1 * T[13] +  r0 * T[12]);
16295:                x2[1]   = MULT_NORM(r1 * T[12] -  r0 * T[13]);
16295: 
16295:     x1-=8;
16295:     x2-=8;
16295:     T+=16;
16295: 
16295:   }while(x2>=x);
16295: }
16295: 
16295: /* N/stage point generic N stage butterfly (in place, 2 register) */
16295: STIN void mdct_butterfly_generic(DATA_TYPE *T,
16295:                                           DATA_TYPE *x,
16295:                                           int points,
16295:                                           int trigint){
16295: 
16295:   DATA_TYPE *x1        = x          + points      - 8;
16295:   DATA_TYPE *x2        = x          + (points>>1) - 8;
16295:   REG_TYPE   r0;
16295:   REG_TYPE   r1;
16295: 
16295:   do{
16295: 
16295:                r0      = x1[6]      -  x2[6];
16295:                r1      = x1[7]      -  x2[7];
16295:                x1[6]  += x2[6];
16295:                x1[7]  += x2[7];
16295:                x2[6]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
16295:                x2[7]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
16295: 
16295:                T+=trigint;
16295: 
16295:                r0      = x1[4]      -  x2[4];
16295:                r1      = x1[5]      -  x2[5];
16295:                x1[4]  += x2[4];
16295:                x1[5]  += x2[5];
16295:                x2[4]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
16295:                x2[5]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
16295: 
16295:                T+=trigint;
16295: 
16295:                r0      = x1[2]      -  x2[2];
16295:                r1      = x1[3]      -  x2[3];
16295:                x1[2]  += x2[2];
16295:                x1[3]  += x2[3];
16295:                x2[2]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
16295:                x2[3]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
16295: 
16295:                T+=trigint;
16295: 
16295:                r0      = x1[0]      -  x2[0];
16295:                r1      = x1[1]      -  x2[1];
16295:                x1[0]  += x2[0];
16295:                x1[1]  += x2[1];
16295:                x2[0]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
16295:                x2[1]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);
16295: 
16295:                T+=trigint;
16295:     x1-=8;
16295:     x2-=8;
16295: 
16295:   }while(x2>=x);
16295: }
16295: 
16295: STIN void mdct_butterflies(mdct_lookup *init,
16295:                              DATA_TYPE *x,
16295:                              int points){
16295: 
16295:   DATA_TYPE *T=init->trig;
16295:   int stages=init->log2n-5;
16295:   int i,j;
16295: 
16295:   if(--stages>0){
16295:     mdct_butterfly_first(T,x,points);
16295:   }
16295: 
16295:   for(i=1;--stages>0;i++){
16295:     for(j=0;j<(1<<i);j++)
16295:       mdct_butterfly_generic(T,x+(points>>i)*j,points>>i,4<<i);
16295:   }
16295: 
16295:   for(j=0;j<points;j+=32)
16295:     mdct_butterfly_32(x+j);
16295: 
16295: }
16295: 
16295: void mdct_clear(mdct_lookup *l){
16295:   if(l){
16295:     if(l->trig)_ogg_free(l->trig);
16295:     if(l->bitrev)_ogg_free(l->bitrev);
16295:     memset(l,0,sizeof(*l));
16295:   }
16295: }
16295: 
16295: STIN void mdct_bitreverse(mdct_lookup *init,
16295:                             DATA_TYPE *x){
16295:   int        n       = init->n;
16295:   int       *bit     = init->bitrev;
16295:   DATA_TYPE *w0      = x;
16295:   DATA_TYPE *w1      = x = w0+(n>>1);
16295:   DATA_TYPE *T       = init->trig+n;
16295: 
16295:   do{
16295:     DATA_TYPE *x0    = x+bit[0];
16295:     DATA_TYPE *x1    = x+bit[1];
16295: 
16295:     REG_TYPE  r0     = x0[1]  - x1[1];
16295:     REG_TYPE  r1     = x0[0]  + x1[0];
16295:     REG_TYPE  r2     = MULT_NORM(r1     * T[0]   + r0 * T[1]);
16295:     REG_TYPE  r3     = MULT_NORM(r1     * T[1]   - r0 * T[0]);
16295: 
16295:               w1    -= 4;
16295: 
16295:               r0     = HALVE(x0[1] + x1[1]);
16295:               r1     = HALVE(x0[0] - x1[0]);
16295: 
16295:               w0[0]  = r0     + r2;
16295:               w1[2]  = r0     - r2;
16295:               w0[1]  = r1     + r3;
16295:               w1[3]  = r3     - r1;
16295: 
16295:               x0     = x+bit[2];
16295:               x1     = x+bit[3];
16295: 
16295:               r0     = x0[1]  - x1[1];
16295:               r1     = x0[0]  + x1[0];
16295:               r2     = MULT_NORM(r1     * T[2]   + r0 * T[3]);
16295:               r3     = MULT_NORM(r1     * T[3]   - r0 * T[2]);
16295: 
16295:               r0     = HALVE(x0[1] + x1[1]);
16295:               r1     = HALVE(x0[0] - x1[0]);
16295: 
16295:               w0[2]  = r0     + r2;
16295:               w1[0]  = r0     - r2;
16295:               w0[3]  = r1     + r3;
16295:               w1[1]  = r3     - r1;
16295: 
16295:               T     += 4;
16295:               bit   += 4;
16295:               w0    += 4;
16295: 
16295:   }while(w0<w1);
16295: }
16295: 
16295: void mdct_backward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out){
16295:   int n=init->n;
16295:   int n2=n>>1;
16295:   int n4=n>>2;
16295: 
16295:   /* rotate */
16295: 
16295:   DATA_TYPE *iX = in+n2-7;
16295:   DATA_TYPE *oX = out+n2+n4;
16295:   DATA_TYPE *T  = init->trig+n4;
16295: 
16295:   do{
16295:     oX         -= 4;
16295:     oX[0]       = MULT_NORM(-iX[2] * T[3] - iX[0]  * T[2]);
16295:     oX[1]       = MULT_NORM (iX[0] * T[3] - iX[2]  * T[2]);
16295:     oX[2]       = MULT_NORM(-iX[6] * T[1] - iX[4]  * T[0]);
16295:     oX[3]       = MULT_NORM (iX[4] * T[1] - iX[6]  * T[0]);
16295:     iX         -= 8;
16295:     T          += 4;
16295:   }while(iX>=in);
16295: 
16295:   iX            = in+n2-8;
16295:   oX            = out+n2+n4;
16295:   T             = init->trig+n4;
16295: 
16295:   do{
16295:     T          -= 4;
16295:     oX[0]       =  MULT_NORM (iX[4] * T[3] + iX[6] * T[2]);
16295:     oX[1]       =  MULT_NORM (iX[4] * T[2] - iX[6] * T[3]);
16295:     oX[2]       =  MULT_NORM (iX[0] * T[1] + iX[2] * T[0]);
16295:     oX[3]       =  MULT_NORM (iX[0] * T[0] - iX[2] * T[1]);
16295:     iX         -= 8;
16295:     oX         += 4;
16295:   }while(iX>=in);
16295: 
16295:   mdct_butterflies(init,out+n2,n2);
16295:   mdct_bitreverse(init,out);
16295: 
16295:   /* roatate + window */
16295: 
16295:   {
16295:     DATA_TYPE *oX1=out+n2+n4;
16295:     DATA_TYPE *oX2=out+n2+n4;
16295:     DATA_TYPE *iX =out;
16295:     T             =init->trig+n2;
16295: 
16295:     do{
16295:       oX1-=4;
16295: 
16295:       oX1[3]  =  MULT_NORM (iX[0] * T[1] - iX[1] * T[0]);
16295:       oX2[0]  = -MULT_NORM (iX[0] * T[0] + iX[1] * T[1]);
16295: 
16295:       oX1[2]  =  MULT_NORM (iX[2] * T[3] - iX[3] * T[2]);
16295:       oX2[1]  = -MULT_NORM (iX[2] * T[2] + iX[3] * T[3]);
16295: 
16295:       oX1[1]  =  MULT_NORM (iX[4] * T[5] - iX[5] * T[4]);
16295:       oX2[2]  = -MULT_NORM (iX[4] * T[4] + iX[5] * T[5]);
16295: 
16295:       oX1[0]  =  MULT_NORM (iX[6] * T[7] - iX[7] * T[6]);
16295:       oX2[3]  = -MULT_NORM (iX[6] * T[6] + iX[7] * T[7]);
16295: 
16295:       oX2+=4;
16295:       iX    +=   8;
16295:       T     +=   8;
16295:     }while(iX<oX1);
16295: 
16295:     iX=out+n2+n4;
16295:     oX1=out+n4;
16295:     oX2=oX1;
16295: 
16295:     do{
16295:       oX1-=4;
16295:       iX-=4;
16295: 
16295:       oX2[0] = -(oX1[3] = iX[3]);
16295:       oX2[1] = -(oX1[2] = iX[2]);
16295:       oX2[2] = -(oX1[1] = iX[1]);
16295:       oX2[3] = -(oX1[0] = iX[0]);
16295: 
16295:       oX2+=4;
16295:     }while(oX2<iX);
16295: 
16295:     iX=out+n2+n4;
16295:     oX1=out+n2+n4;
16295:     oX2=out+n2;
16295:     do{
16295:       oX1-=4;
16295:       oX1[0]= iX[3];
16295:       oX1[1]= iX[2];
16295:       oX1[2]= iX[1];
16295:       oX1[3]= iX[0];
16295:       iX+=4;
16295:     }while(oX1>oX2);
16295:   }
16295: }
16295: 
16295: void mdct_forward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out){
16295:   int n=init->n;
16295:   int n2=n>>1;
16295:   int n4=n>>2;
16295:   int n8=n>>3;
16295:   DATA_TYPE *w=alloca(n*sizeof(*w)); /* forward needs working space */
16295:   DATA_TYPE *w2=w+n2;
16295: 
16295:   /* rotate */
16295: 
16295:   /* window + rotate + step 1 */
16295: 
16295:   REG_TYPE r0;
16295:   REG_TYPE r1;
16295:   DATA_TYPE *x0=in+n2+n4;
16295:   DATA_TYPE *x1=x0+1;
16295:   DATA_TYPE *T=init->trig+n2;
16295: 
16295:   int i=0;
16295: 
16295:   for(i=0;i<n8;i+=2){
16295:     x0 -=4;
16295:     T-=2;
16295:     r0= x0[2] + x1[0];
16295:     r1= x0[0] + x1[2];
16295:     w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
16295:     w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
16295:     x1 +=4;
16295:   }
16295: 
16295:   x1=in+1;
16295: 
16295:   for(;i<n2-n8;i+=2){
16295:     T-=2;
16295:     x0 -=4;
16295:     r0= x0[2] - x1[0];
16295:     r1= x0[0] - x1[2];
16295:     w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
16295:     w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
16295:     x1 +=4;
16295:   }
16295: 
16295:   x0=in+n;
16295: 
16295:   for(;i<n2;i+=2){
16295:     T-=2;
16295:     x0 -=4;
16295:     r0= -x0[2] - x1[0];
16295:     r1= -x0[0] - x1[2];
16295:     w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
16295:     w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
16295:     x1 +=4;
16295:   }
16295: 
16295: 
16295:   mdct_butterflies(init,w+n2,n2);
16295:   mdct_bitreverse(init,w);
16295: 
16295:   /* roatate + window */
16295: 
16295:   T=init->trig+n2;
16295:   x0=out+n2;
16295: 
16295:   for(i=0;i<n4;i++){
16295:     x0--;
16295:     out[i] =MULT_NORM((w[0]*T[0]+w[1]*T[1])*init->scale);
16295:     x0[0]  =MULT_NORM((w[0]*T[1]-w[1]*T[0])*init->scale);
16295:     w+=2;
16295:     T+=2;
16295:   }
16295: }
