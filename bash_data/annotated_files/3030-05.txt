   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsTextEditRules.h"
   1: 
   1: #include "nsEditor.h"
   1: #include "nsTextEditUtils.h"
   1: #include "nsCRT.h"
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsIDOMNode.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsIDOMText.h"
   1: #include "nsIDOMNodeList.h"
   1: #include "nsISelection.h"
   1: #include "nsISelectionPrivate.h"
   1: #include "nsISelectionController.h"
   1: #include "nsIDOMRange.h"
   1: #include "nsIDOMNSRange.h"
   1: #include "nsIDOMCharacterData.h"
   1: #include "nsIContent.h"
   1: #include "nsIContentIterator.h"
   1: #include "nsEditorUtils.h"
   1: #include "EditTxn.h"
   1: #include "nsIPrefBranch.h"
   1: #include "nsIPrefService.h"
   1: #include "nsUnicharUtils.h"
   1: #include "nsILookAndFeel.h"
   1: #include "nsWidgetsCID.h"
3030: #include "DeleteTextTxn.h"
   1: 
   1: // for IBMBIDI
   1: #include "nsIPresShell.h"
   1: #include "nsFrameSelection.h"
   1: 
   1: static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
   1: 
   1: #define CANCEL_OPERATION_IF_READONLY_OR_DISABLED \
   1:   if ((mFlags & nsIPlaintextEditor::eEditorReadonlyMask) || (mFlags & nsIPlaintextEditor::eEditorDisabledMask)) \
   1:   {                     \
   1:     *aCancel = PR_TRUE; \
   1:     return NS_OK;       \
   1:   };
   1: 
   1: 
   1: nsresult
   1: NS_NewTextEditRules(nsIEditRules** aInstancePtrResult)
   1: {
   1:   nsTextEditRules * rules = new nsTextEditRules();
   1:   if (rules)
   1:     return rules->QueryInterface(NS_GET_IID(nsIEditRules), (void**) aInstancePtrResult);
   1:   return NS_ERROR_OUT_OF_MEMORY;
   1: }
   1: 
   1: 
   1: /********************************************************
   1:  *  Constructor/Destructor 
   1:  ********************************************************/
   1: 
   1: nsTextEditRules::nsTextEditRules()
   1: : mEditor(nsnull)
   1: , mPasswordText()
   1: , mPasswordIMEText()
   1: , mPasswordIMEIndex(0)
   1: , mFlags(0) // initialized to 0 ("no flags set").  Real initial value is given in Init()
   1: , mActionNesting(0)
   1: , mLockRulesSniffing(PR_FALSE)
   1: , mDidExplicitlySetInterline(PR_FALSE)
   1: , mTheAction(0)
   1: {
   1: }
   1: 
   1: nsTextEditRules::~nsTextEditRules()
   1: {
   1:    // do NOT delete mEditor here.  We do not hold a ref count to mEditor.  mEditor owns our lifespan.
   1: }
   1: 
   1: /********************************************************
   1:  *  XPCOM Cruft
   1:  ********************************************************/
   1: 
   1: NS_IMPL_ISUPPORTS1(nsTextEditRules, nsIEditRules)
   1: 
   1: 
   1: /********************************************************
   1:  *  Public methods 
   1:  ********************************************************/
   1: 
   1: NS_IMETHODIMP
   1: nsTextEditRules::Init(nsPlaintextEditor *aEditor, PRUint32 aFlags)
   1: {
   1:   if (!aEditor) { return NS_ERROR_NULL_POINTER; }
   1: 
   1:   mEditor = aEditor;  // we hold a non-refcounted reference back to our editor
   1:   // call SetFlags only aftet mEditor has been initialized!
   1:   SetFlags(aFlags);
   1:   nsCOMPtr<nsISelection> selection;
   1:   mEditor->GetSelection(getter_AddRefs(selection));
   1:   NS_ASSERTION(selection, "editor cannot get selection");
   1: 
   1:   // Cache our body node, if available.
   1:   GetBody();
   1: 
   1:   // Put in a magic br if needed. This method handles null selection,
   1:   // which should never happen anyway
   1:   nsresult res = CreateBogusNodeIfNeeded(selection);
   1:   if (NS_FAILED(res)) return res;
   1: 
   1:   if (mFlags & nsIPlaintextEditor::eEditorPlaintextMask)
   1:   {
   1:     // ensure trailing br node
   1:     res = CreateTrailingBRIfNeeded();
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1: 
   1:   if (mBody)
   1:   {
   1:     // create a range that is the entire body contents
   1:     nsCOMPtr<nsIDOMRange> wholeDoc =
   1:       do_CreateInstance("@mozilla.org/content/range;1");
   1:     if (!wholeDoc) return NS_ERROR_NULL_POINTER;
   1:     wholeDoc->SetStart(mBody,0);
   1:     nsCOMPtr<nsIDOMNodeList> list;
   1:     res = mBody->GetChildNodes(getter_AddRefs(list));
   1:     if (NS_FAILED(res)) return res;
   1:     if (!list) return NS_ERROR_FAILURE;
   1: 
   1:     PRUint32 listCount;
   1:     res = list->GetLength(&listCount);
   1:     if (NS_FAILED(res)) return res;
   1: 
   1:     res = wholeDoc->SetEnd(mBody, listCount);
   1:     if (NS_FAILED(res)) return res;
   1: 
   1:     // replace newlines in that range with breaks
   1:     res = ReplaceNewlines(wholeDoc);
   1:   }
   1: 
   1:   PRBool deleteBidiImmediately = PR_FALSE;
   1:   nsCOMPtr<nsIPrefBranch> prefBranch =
   1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &res);
   1:   if (NS_SUCCEEDED(res))
   1:     prefBranch->GetBoolPref("bidi.edit.delete_immediately",
   1:                             &deleteBidiImmediately);
   1:   mDeleteBidiImmediately = deleteBidiImmediately;
   1: 
   1:   return res;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextEditRules::GetFlags(PRUint32 *aFlags)
   1: {
   1:   if (!aFlags) { return NS_ERROR_NULL_POINTER; }
   1:   *aFlags = mFlags;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextEditRules::SetFlags(PRUint32 aFlags)
   1: {
   1:   if (mFlags == aFlags) return NS_OK;
   1:   
   1:   // XXX - this won't work if body element already has
   1:   // a style attribute on it, don't know why.
   1:   // SetFlags() is really meant to only be called once
   1:   // and at editor init time.  
   1: 
   1:   mFlags = aFlags;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTextEditRules::BeforeEdit(PRInt32 action, nsIEditor::EDirection aDirection)
   1: {
   1:   if (mLockRulesSniffing) return NS_OK;
   1:   
   1:   nsAutoLockRulesSniffing lockIt(this);
   1:   mDidExplicitlySetInterline = PR_FALSE;
   1:   
   1:   // get the selection and cache the position before editing
   1:   nsCOMPtr<nsISelection> selection;
   1:   nsresult res = mEditor->GetSelection(getter_AddRefs(selection));
   1:   if (NS_FAILED(res)) 
   1:     return res;
   1: 
   1:   selection->GetAnchorNode(getter_AddRefs(mCachedSelectionNode));
   1:   selection->GetAnchorOffset(&mCachedSelectionOffset);
   1: 
   1:   if (!mActionNesting)
   1:   {
   1:     // let rules remember the top level action
   1:     mTheAction = action;
   1:   }
   1:   mActionNesting++;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsTextEditRules::AfterEdit(PRInt32 action, nsIEditor::EDirection aDirection)
   1: {
   1:   if (mLockRulesSniffing) return NS_OK;
   1:   
   1:   nsAutoLockRulesSniffing lockIt(this);
   1:   
   1:   NS_PRECONDITION(mActionNesting>0, "bad action nesting!");
   1:   nsresult res = NS_OK;
   1:   if (!--mActionNesting)
   1:   {
   1:     nsCOMPtr<nsISelection>selection;
   1:     res = mEditor->GetSelection(getter_AddRefs(selection));
   1:     if (NS_FAILED(res)) return res;
   1:   
   1:     res = mEditor->HandleInlineSpellCheck(action, selection,
   1:                                           mCachedSelectionNode, mCachedSelectionOffset,
   1:                                           nsnull, 0, nsnull, 0);
   1:     if (NS_FAILED(res)) 
   1:       return res;
   1: 
   1:     // detect empty doc
   1:     res = CreateBogusNodeIfNeeded(selection);
   1:     if (NS_FAILED(res)) 
   1:       return res;
   1:     
   1:     // insure trailing br node
   1:     res = CreateTrailingBRIfNeeded();
   1:     if (NS_FAILED(res)) 
   1:       return res;
   1:     
   1:     /* After inserting text the cursor Bidi level must be set to the level of the inserted text.
   1:      * This is difficult, because we cannot know what the level is until after the Bidi algorithm
   1:      * is applied to the whole paragraph.
   1:      *
   1:      * So we set the cursor Bidi level to UNDEFINED here, and the caret code will set it correctly later
   1:      */
   1:     if (action == nsEditor::kOpInsertText
   1:         || action == nsEditor::kOpInsertIMEText) {
   1:       nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(selection));
   1:       nsCOMPtr<nsFrameSelection> frameSelection;
   1:       privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));      
   1:       if (frameSelection) {
   1:         frameSelection->UndefineCaretBidiLevel();
   1:       }
   1:     }
   1:   }
   1:   return res;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP 
   1: nsTextEditRules::WillDoAction(nsISelection *aSelection, 
   1:                               nsRulesInfo *aInfo, 
   1:                               PRBool *aCancel, 
   1:                               PRBool *aHandled)
   1: {
   1:   // null selection is legal
   1:   if (!aInfo || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
   1: #if defined(DEBUG_ftang)
   1:   printf("nsTextEditRules::WillDoAction action= %d", aInfo->action);
   1: #endif
   1: 
   1:   *aCancel = PR_FALSE;
   1:   *aHandled = PR_FALSE;
   1: 
   1:   // my kingdom for dynamic cast
   1:   nsTextRulesInfo *info = NS_STATIC_CAST(nsTextRulesInfo*, aInfo);
   1:     
   1:   switch (info->action)
   1:   {
   1:     case kInsertBreak:
   1:       return WillInsertBreak(aSelection, aCancel, aHandled);
   1:     case kInsertText:
   1:     case kInsertTextIME:
   1:       return WillInsertText(info->action,
   1:                             aSelection, 
   1:                             aCancel,
   1:                             aHandled, 
   1:                             info->inString,
   1:                             info->outString,
   1:                             info->maxLength);
   1:     case kDeleteSelection:
   1:       return WillDeleteSelection(aSelection, info->collapsedAction, aCancel, aHandled);
   1:     case kUndo:
   1:       return WillUndo(aSelection, aCancel, aHandled);
   1:     case kRedo:
   1:       return WillRedo(aSelection, aCancel, aHandled);
   1:     case kSetTextProperty:
   1:       return WillSetTextProperty(aSelection, aCancel, aHandled);
   1:     case kRemoveTextProperty:
   1:       return WillRemoveTextProperty(aSelection, aCancel, aHandled);
   1:     case kOutputText:
   1:       return WillOutputText(aSelection, 
   1:                             info->outputFormat,
   1:                             info->outString,                            
   1:                             aCancel,
   1:                             aHandled);
   1:     case kInsertElement:  // i had thought this would be html rules only.  but we put pre elements
   1:                           // into plaintext mail when doing quoting for reply!  doh!
   1:       return WillInsert(aSelection, aCancel);
   1:   }
   1:   return NS_ERROR_FAILURE;
   1: }
   1:   
   1: NS_IMETHODIMP 
   1: nsTextEditRules::DidDoAction(nsISelection *aSelection,
   1:                              nsRulesInfo *aInfo, nsresult aResult)
   1: {
   1:   // don't let any txns in here move the selection around behind our back.
   1:   // Note that this won't prevent explicit selection setting from working.
   1:   nsAutoTxnsConserveSelection dontSpazMySelection(mEditor);
   1: 
   1:   if (!aSelection || !aInfo) 
   1:     return NS_ERROR_NULL_POINTER;
   1:     
   1:   // my kingdom for dynamic cast
   1:   nsTextRulesInfo *info = NS_STATIC_CAST(nsTextRulesInfo*, aInfo);
   1: 
   1:   switch (info->action)
   1:   {
   1:    case kInsertBreak:
   1:      return DidInsertBreak(aSelection, aResult);
   1:     case kInsertText:
   1:     case kInsertTextIME:
   1:       return DidInsertText(aSelection, aResult);
   1:     case kDeleteSelection:
   1:       return DidDeleteSelection(aSelection, info->collapsedAction, aResult);
   1:     case kUndo:
   1:       return DidUndo(aSelection, aResult);
   1:     case kRedo:
   1:       return DidRedo(aSelection, aResult);
   1:     case kSetTextProperty:
   1:       return DidSetTextProperty(aSelection, aResult);
   1:     case kRemoveTextProperty:
   1:       return DidRemoveTextProperty(aSelection, aResult);
   1:     case kOutputText:
   1:       return DidOutputText(aSelection, aResult);
   1:   }
   1:   // Don't fail on transactions we don't handle here!
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsTextEditRules::DocumentIsEmpty(PRBool *aDocumentIsEmpty)
   1: {
   1:   if (!aDocumentIsEmpty)
   1:     return NS_ERROR_NULL_POINTER;
   1:   
   1:   *aDocumentIsEmpty = (mBogusNode != nsnull);
   1:   return NS_OK;
   1: }
   1: 
   1: /********************************************************
   1:  *  Protected methods 
   1:  ********************************************************/
   1: 
   1: 
   1: nsresult
   1: nsTextEditRules::WillInsert(nsISelection *aSelection, PRBool *aCancel)
   1: {
   1:   if (!aSelection || !aCancel)
   1:     return NS_ERROR_NULL_POINTER;
   1:   
   1:   CANCEL_OPERATION_IF_READONLY_OR_DISABLED
   1: 
   1:   // initialize out param
   1:   *aCancel = PR_FALSE;
   1:   
   1:   // check for the magic content node and delete it if it exists
   1:   if (mBogusNode)
   1:   {
   1:     mEditor->DeleteNode(mBogusNode);
   1:     mBogusNode = nsnull;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidInsert(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::WillInsertBreak(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
   1: {
   1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
   1:   CANCEL_OPERATION_IF_READONLY_OR_DISABLED
   1:   *aHandled = PR_FALSE;
   1:   if (mFlags & nsIPlaintextEditor::eEditorSingleLineMask) {
   1:     *aCancel = PR_TRUE;
   1:   }
   1:   else 
   1:   {
   1:     *aCancel = PR_FALSE;
   1: 
   1:     // if the selection isn't collapsed, delete it.
   1:     PRBool bCollapsed;
   1:     nsresult res = aSelection->GetIsCollapsed(&bCollapsed);
   1:     if (NS_FAILED(res)) return res;
   1:     if (!bCollapsed)
   1:     {
   1:       res = mEditor->DeleteSelection(nsIEditor::eNone);
   1:       if (NS_FAILED(res)) return res;
   1:     }
   1: 
   1:     res = WillInsert(aSelection, aCancel);
   1:     if (NS_FAILED(res)) return res;
   1:     // initialize out param
   1:     // we want to ignore result of WillInsert()
   1:     *aCancel = PR_FALSE;
   1:   
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidInsertBreak(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   // we only need to execute the stuff below if we are a plaintext editor.
   1:   // html editors have a different mechanism for putting in mozBR's
   1:   // (because there are a bunch more places you have to worry about it in html) 
   1:   if (!nsIPlaintextEditor::eEditorPlaintextMask & mFlags) return NS_OK;
   1: 
   1:   // if we are at the end of the document, we need to insert 
   1:   // a special mozBR following the normal br, and then set the
   1:   // selection to stick to the mozBR.
   1:   PRInt32 selOffset;
   1:   nsCOMPtr<nsIDOMNode> selNode;
   1:   nsresult res;
   1:   res = mEditor->GetStartNodeAndOffset(aSelection, address_of(selNode), &selOffset);
   1:   if (NS_FAILED(res)) return res;
   1:   // confirm we are at end of document
   1:   if (selOffset == 0) return NS_OK;  // can't be after a br if we are at offset 0
   1:   nsIDOMElement *rootElem = mEditor->GetRoot();
   1: 
   1:   nsCOMPtr<nsIDOMNode> root = do_QueryInterface(rootElem);
   1:   if (!root) return NS_ERROR_NULL_POINTER;
   1:   if (selNode != root) return NS_OK; // must be inside text node or somewhere other than end of root
   1: 
   1:   nsCOMPtr<nsIDOMNode> temp = mEditor->GetChildAt(selNode, selOffset);
   1:   if (temp) return NS_OK; // can't be at end if there is a node after us.
   1: 
   1:   nsCOMPtr<nsIDOMNode> nearNode = mEditor->GetChildAt(selNode, selOffset-1);
   1:   if (nearNode && nsTextEditUtils::IsBreak(nearNode) && !nsTextEditUtils::IsMozBR(nearNode))
   1:   {
   1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
   1:     // need to insert special moz BR. Why?  Because if we don't
   1:     // the user will see no new line for the break.  Also, things
   1:     // like table cells won't grow in height.
   1:     nsCOMPtr<nsIDOMNode> brNode;
   1:     res = CreateMozBR(selNode, selOffset, address_of(brNode));
   1:     if (NS_FAILED(res)) return res;
   1: 
   1:     res = nsEditor::GetNodeLocation(brNode, address_of(selNode), &selOffset);
   1:     if (NS_FAILED(res)) return res;
   1:     selPrivate->SetInterlinePosition(PR_TRUE);
   1:     res = aSelection->Collapse(selNode, selOffset);
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1:   return res;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsTextEditRules::WillInsertText(PRInt32          aAction,
   1:                                 nsISelection *aSelection, 
   1:                                 PRBool          *aCancel,
   1:                                 PRBool          *aHandled,
   1:                                 const nsAString *inString,
   1:                                 nsAString *outString,
   1:                                 PRInt32          aMaxLength)
   1: {  
   1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
   1: 
   1:   if (inString->IsEmpty() && (aAction != kInsertTextIME))
   1:   {
   1:     // HACK: this is a fix for bug 19395
   1:     // I can't outlaw all empty insertions
   1:     // because IME transaction depend on them
   1:     // There is more work to do to make the 
   1:     // world safe for IME.
   1:     *aCancel = PR_TRUE;
   1:     *aHandled = PR_FALSE;
   1:     return NS_OK;
   1:   }
   1:   
   1:   // initialize out param
   1:   *aCancel = PR_FALSE;
   1:   *aHandled = PR_TRUE;
   1: 
   1:   // handle docs with a max length
   1:   // NOTE, this function copies inString into outString for us.
   1:   nsresult res = TruncateInsertionIfNeeded(aSelection, inString, outString, aMaxLength);
   1:   if (NS_FAILED(res)) return res;
   1:   
   1:   PRUint32 start = 0;
   1:   PRUint32 end = 0;  
   1: 
   1:   // handle password field docs
   1:   if (mFlags & nsIPlaintextEditor::eEditorPasswordMask)
   1:   {
   1:     res = mEditor->GetTextSelectionOffsets(aSelection, start, end);
   1:     NS_ASSERTION((NS_SUCCEEDED(res)), "getTextSelectionOffsets failed!");
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1: 
   1:   // if the selection isn't collapsed, delete it.
   1:   PRBool bCollapsed;
   1:   res = aSelection->GetIsCollapsed(&bCollapsed);
   1:   if (NS_FAILED(res)) return res;
   1:   if (!bCollapsed)
   1:   {
   1:     res = mEditor->DeleteSelection(nsIEditor::eNone);
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1: 
   1:   res = WillInsert(aSelection, aCancel);
   1:   if (NS_FAILED(res)) return res;
   1:   // initialize out param
   1:   // we want to ignore result of WillInsert()
   1:   *aCancel = PR_FALSE;
   1:   
   1:   // handle password field data
   1:   // this has the side effect of changing all the characters in aOutString
   1:   // to the replacement character
   1:   if (mFlags & nsIPlaintextEditor::eEditorPasswordMask)
   1:   {
   1:     if (aAction == kInsertTextIME)  {
   1:       res = RemoveIMETextFromPWBuf(start, outString);
   1:       if (NS_FAILED(res)) return res;
   1:     }
   1:   }
   1: 
   1:   // People have lots of different ideas about what text fields
   1:   // should do with multiline pastes.  See bugs 21032, 23485, 23485, 50935.
   1:   // The six possible options are:
   1:   // 0. paste newlines intact
   1:   // 1. paste up to the first newline (default)
   1:   // 2. replace newlines with spaces
   1:   // 3. strip newlines
   1:   // 4. replace with commas
   1:   // 5. strip newlines and surrounding whitespace
   1:   // So find out what we're expected to do:
   1:   if (nsIPlaintextEditor::eEditorSingleLineMask & mFlags)
   1:   {
   1:     nsAutoString tString(*outString);
   1: 
   1:     switch(mEditor->mNewlineHandling)
   1:     {
   1:     case nsIPlaintextEditor::eNewlinesReplaceWithSpaces:
   1:       tString.ReplaceChar(CRLF, ' ');
   1:       break;
   1:     case nsIPlaintextEditor::eNewlinesStrip:
   1:       tString.StripChars(CRLF);
   1:       break;
   1:     case nsIPlaintextEditor::eNewlinesPasteToFirst:
   1:     default:
   1:       {
   1:         PRInt32 firstCRLF = tString.FindCharInSet(CRLF);
   1: 
   1:         // we get first *non-empty* line.
   1:         PRInt32 offset = 0;
   1:         while (firstCRLF == offset)
   1:         {
   1:           offset++;
   1:           firstCRLF = tString.FindCharInSet(CRLF, offset);
   1:         }
   1:         if (firstCRLF > 0)
   1:           tString.Truncate(firstCRLF);
   1:         if (offset > 0)
   1:           tString.Cut(0, offset);
   1:       }
   1:       break;
   1:     case nsIPlaintextEditor::eNewlinesReplaceWithCommas:
   1:       tString.Trim(CRLF, PR_TRUE, PR_TRUE);
   1:       tString.ReplaceChar(CRLF, ',');
   1:       break;
   1:     case nsIPlaintextEditor::eNewlinesStripSurroundingWhitespace:
   1:       {
   1:         // find each newline, and strip all the whitespace before
   1:         // and after it
   1:         PRInt32 firstCRLF = tString.FindCharInSet(CRLF);
   1:         while (firstCRLF >= 0)
   1:         {
   1:           PRUint32 wsBegin = firstCRLF, wsEnd = firstCRLF + 1;
   1:           // look backwards for the first non-whitespace char
   1:           while (wsBegin > 0 && NS_IS_SPACE(tString[wsBegin - 1]))
   1:             --wsBegin;
   1:           while (wsEnd < tString.Length() && NS_IS_SPACE(tString[wsEnd]))
   1:             ++wsEnd;
   1:           // now cut this range out of the string
   1:           tString.Cut(wsBegin, wsEnd - wsBegin);
   1:           // look for another CR or LF
   1:           firstCRLF = tString.FindCharInSet(CRLF);
   1:         }
   1:       }
   1:       break;
   1:     case nsIPlaintextEditor::eNewlinesPasteIntact:
   1:       // even if we're pasting newlines, don't paste leading/trailing ones
   1:       tString.Trim(CRLF, PR_TRUE, PR_TRUE);
   1:       break;
   1:     }
   1: 
   1:     outString->Assign(tString);
   1:   }
   1: 
   1:   if (mFlags & nsIPlaintextEditor::eEditorPasswordMask)
   1:   {
   1:     res = EchoInsertionToPWBuff(start, end, outString);
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1: 
   1:   // get the (collapsed) selection location
   1:   nsCOMPtr<nsIDOMNode> selNode;
   1:   PRInt32 selOffset;
   1:   res = mEditor->GetStartNodeAndOffset(aSelection, address_of(selNode), &selOffset);
   1:   if (NS_FAILED(res)) return res;
   1: 
   1:   // don't put text in places that can't have it
   1:   if (!mEditor->IsTextNode(selNode) && !mEditor->CanContainTag(selNode, NS_LITERAL_STRING("#text")))
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   // we need to get the doc
   1:   nsCOMPtr<nsIDOMDocument>doc;
   1:   res = mEditor->GetDocument(getter_AddRefs(doc));
   1:   if (NS_FAILED(res)) return res;
   1:   if (!doc) return NS_ERROR_NULL_POINTER;
   1:     
   1:   if (aAction == kInsertTextIME) 
   1:   { 
   1:     res = mEditor->InsertTextImpl(*outString, address_of(selNode), &selOffset, doc);
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1:   else // aAction == kInsertText
   1:   {
   1:     // find where we are
   1:     nsCOMPtr<nsIDOMNode> curNode = selNode;
   1:     PRInt32 curOffset = selOffset;
   1: 
   1:     // is our text going to be PREformatted?  
   1:     // We remember this so that we know how to handle tabs.
   1:     PRBool isPRE;
   1:     res = mEditor->IsPreformatted(selNode, &isPRE);
   1:     if (NS_FAILED(res)) return res;    
   1: 
   1:     // don't spaz my selection in subtransactions
   1:     nsAutoTxnsConserveSelection dontSpazMySelection(mEditor);
   1:     nsString tString(*outString);
   1:     const PRUnichar *unicodeBuf = tString.get();
   1:     nsCOMPtr<nsIDOMNode> unused;
   1:     PRInt32 pos = 0;
   1: 
   1:     // for efficiency, break out the pre case separately.  This is because
   1:     // it's a lot cheaper to search the input string for only newlines than
   1:     // it is to search for both tabs and newlines.
   1:     if (isPRE)
   1:     {
   1:       while (unicodeBuf && (pos != -1) && ((PRUint32)pos < tString.Length()))
   1:       {
   1:         PRInt32 oldPos = pos;
   1:         PRInt32 subStrLen;
   1:         pos = tString.FindChar(nsCRT::LF, oldPos);
   1:         
   1:         if (pos != -1) 
   1:         {
   1:           subStrLen = pos - oldPos;
   1:           // if first char is newline, then use just it
   1:           if (subStrLen == 0)
   1:             subStrLen = 1;
   1:         }
   1:         else
   1:         {
   1:           subStrLen = tString.Length() - oldPos;
   1:           pos = tString.Length();
   1:         }
   1: 
   1:         nsDependentSubstring subStr(tString, oldPos, subStrLen);
   1:         
   1:         // is it a return?
   1:         if (subStr.EqualsLiteral(LFSTR))
   1:         {
   1:           if (nsIPlaintextEditor::eEditorSingleLineMask & mFlags)
   1:           {
   1:             NS_ASSERTION((mEditor->mNewlineHandling == nsIPlaintextEditor::eNewlinesPasteIntact),
   1:                   "Newline improperly getting into single-line edit field!");
   1:             res = mEditor->InsertTextImpl(subStr, address_of(curNode), &curOffset, doc);
   1:           }
   1:           else
   1:           {
   1:             res = mEditor->CreateBRImpl(address_of(curNode), &curOffset, address_of(unused), nsIEditor::eNone);
   1: 
   1:             // If the newline is the last character in the string, and the BR we
   1:             // just inserted is the last node in the content tree, we need to add
   1:             // a mozBR so that a blank line is created.
   1: 
   1:             if (NS_SUCCEEDED(res) && curNode && pos == (PRInt32)(tString.Length() - 1))
   1:             {
   1:               nsCOMPtr<nsIDOMNode> nextChild = mEditor->GetChildAt(curNode, curOffset);
   1: 
   1:               if (!nextChild)
   1:               {
   1:                 // We must be at the end since there isn't a nextChild.
   1:                 //
   1:                 // curNode and curOffset should be set to the position after
   1:                 // the BR we added above, so just create a mozBR at that position.
   1:                 //
   1:                 // Note that we don't update curOffset after we've created/inserted
   1:                 // the mozBR since we never want the selection to be placed after it.
   1: 
   1:                 res = CreateMozBR(curNode, curOffset, address_of(unused));
   1:               }
   1:             }
   1:           }
   1:           pos++;
   1:         }
   1:         else
   1:         {
   1:           res = mEditor->InsertTextImpl(subStr, address_of(curNode), &curOffset, doc);
   1:         }
   1:         if (NS_FAILED(res)) return res;
   1:       }
   1:     }
   1:     else
   1:     {
   1:       char specialChars[] = {TAB, nsCRT::LF, 0};
   1:       while (unicodeBuf && (pos != -1) && ((PRUint32)pos < tString.Length()))
   1:       {
   1:         PRInt32 oldPos = pos;
   1:         PRInt32 subStrLen;
   1:         pos = tString.FindCharInSet(specialChars, oldPos);
   1:         
   1:         if (pos != -1) 
   1:         {
   1:           subStrLen = pos - oldPos;
   1:           // if first char is newline, then use just it
   1:           if (subStrLen == 0)
   1:             subStrLen = 1;
   1:         }
   1:         else
   1:         {
   1:           subStrLen = tString.Length() - oldPos;
   1:           pos = tString.Length();
   1:         }
   1: 
   1:         nsDependentSubstring subStr(tString, oldPos, subStrLen);
   1:         
   1:         // is it a tab?
   1:         if (subStr.EqualsLiteral("\t"))
   1:         {
   1:           res = mEditor->InsertTextImpl(NS_LITERAL_STRING("    "), address_of(curNode), &curOffset, doc);
   1:           pos++;
   1:         }
   1:         // is it a return?
   1:         else if (subStr.EqualsLiteral(LFSTR))
   1:         {
   1:           res = mEditor->CreateBRImpl(address_of(curNode), &curOffset, address_of(unused), nsIEditor::eNone);
   1:           pos++;
   1:         }
   1:         else
   1:         {
   1:           res = mEditor->InsertTextImpl(subStr, address_of(curNode), &curOffset, doc);
   1:         }
   1:         if (NS_FAILED(res)) return res;
   1:       }
   1:     }
   1:     outString->Assign(tString);
   1: 
   1:     if (curNode) 
   1:     {
   1:       aSelection->Collapse(curNode, curOffset);
   1:       
   1:       // Make the caret attach to the inserted text, unless this text ends with a LF, 
   1:       // in which case make the caret attach to the next line.
   1:       PRBool endsWithLF = !tString.IsEmpty() && tString.get()[tString.Length() - 1] == nsCRT::LF;
   1:       nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
   1:       selPrivate->SetInterlinePosition(endsWithLF);
   1:     }
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidInsertText(nsISelection *aSelection, 
   1:                                nsresult aResult)
   1: {
   1:   return DidInsert(aSelection, aResult);
   1: }
   1: 
   1: 
   1: 
   1: nsresult
   1: nsTextEditRules::WillSetTextProperty(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
   1: {
   1:   if (!aSelection || !aCancel || !aHandled) 
   1:     { return NS_ERROR_NULL_POINTER; }
   1: 
   1:   // XXX: should probably return a success value other than NS_OK that means "not allowed"
   1:   if (nsIPlaintextEditor::eEditorPlaintextMask & mFlags) {
   1:     *aCancel = PR_TRUE;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidSetTextProperty(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::WillRemoveTextProperty(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
   1: {
   1:   if (!aSelection || !aCancel || !aHandled) 
   1:     { return NS_ERROR_NULL_POINTER; }
   1: 
   1:   // XXX: should probably return a success value other than NS_OK that means "not allowed"
   1:   if (nsIPlaintextEditor::eEditorPlaintextMask & mFlags) {
   1:     *aCancel = PR_TRUE;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidRemoveTextProperty(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::WillDeleteSelection(nsISelection *aSelection, 
   1:                                      nsIEditor::EDirection aCollapsedAction, 
   1:                                      PRBool *aCancel,
   1:                                      PRBool *aHandled)
   1: {
   1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
   1:   CANCEL_OPERATION_IF_READONLY_OR_DISABLED
   1: 
   1:   // initialize out param
   1:   *aCancel = PR_FALSE;
   1:   *aHandled = PR_FALSE;
   1:   
   1:   // if there is only bogus content, cancel the operation
   1:   if (mBogusNode) {
   1:     *aCancel = PR_TRUE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsresult res = NS_OK;
   1: 
   1:   if (mFlags & nsIPlaintextEditor::eEditorPasswordMask)
   1:   {
   1:     // manage the password buffer
   1:     PRUint32 start, end;
   1:     mEditor->GetTextSelectionOffsets(aSelection, start, end);
   1:     NS_ENSURE_SUCCESS(res, res);
   1:     if (end == start)
   1:     { // collapsed selection
   1:       if (nsIEditor::ePrevious==aCollapsedAction && 0<start) { // del back
   1:         mPasswordText.Cut(start-1, 1);
   1:       }
   1:       else if (nsIEditor::eNext==aCollapsedAction) {      // del forward
   1:         mPasswordText.Cut(start, 1);
   1:       }
   1:       // otherwise nothing to do for this collapsed selection
   1:     }
   1:     else {  // extended selection
   1:       mPasswordText.Cut(start, end-start);
   1:     }
   1:   }
   1:   else
   1:   {
   1:     nsCOMPtr<nsIDOMNode> startNode;
   1:     PRInt32 startOffset;
   1:     res = mEditor->GetStartNodeAndOffset(aSelection, address_of(startNode), &startOffset);
   1:     if (NS_FAILED(res)) return res;
   1:     if (!startNode) return NS_ERROR_FAILURE;
   1:     
   1:     PRBool bCollapsed;
   1:     res = aSelection->GetIsCollapsed(&bCollapsed);
   1:     if (NS_FAILED(res)) return res;
   1:   
   1:     if (bCollapsed)
   1:     {
   1:       // Test for distance between caret and text that will be deleted
   1:       res = CheckBidiLevelForDeletion(aSelection, startNode, startOffset, aCollapsedAction, aCancel);
   1:       if (NS_FAILED(res)) return res;
   1:       if (*aCancel) return NS_OK;
   1: 
   1:       nsCOMPtr<nsIDOMText> textNode;
   1:       PRUint32 strLength;
   1:       
   1:       // destroy any empty text nodes in our path
   1:       if (mEditor->IsTextNode(startNode))
   1:       {
   1:         textNode = do_QueryInterface(startNode);
   1:         res = textNode->GetLength(&strLength);
   1:         if (NS_FAILED(res)) return res;
   1:         // if it has a length and we aren't at the edge, we are done
   1:         if (strLength && !( ((aCollapsedAction == nsIEditor::ePrevious) && startOffset) ||
   1:                             ((aCollapsedAction == nsIEditor::eNext) && startOffset==PRInt32(strLength)) ) )
   1:           return NS_OK;
   1:         
   1:         // remember where we are
   1:         nsCOMPtr<nsIDOMNode> selNode = startNode;
   1:         res = nsEditor::GetNodeLocation(selNode, address_of(startNode), &startOffset);
   1:         if (NS_FAILED(res)) return res;
   1: 
   1:         // delete this text node if empty
   1:         if (!strLength)
   1:         {
   1:           // delete empty text node
   1:           res = mEditor->DeleteNode(selNode);
   1:           if (NS_FAILED(res)) return res;
   1:         }
   1:         else
   1:         {
   1:           // if text node isn't empty, but we are at end of it, remeber that we are after it
   1:           if (aCollapsedAction == nsIEditor::eNext)
   1:             startOffset++;
   1:         }
   1:       }
   1: 
   1:       // find next node (we know we are in container here)
   1:       nsCOMPtr<nsIContent> child, content(do_QueryInterface(startNode));
   1:       if (!content) return NS_ERROR_NULL_POINTER;
   1:       if (aCollapsedAction == nsIEditor::ePrevious)
   1:         --startOffset;
   1:       child = content->GetChildAt(startOffset);
   1: 
   1:       nsCOMPtr<nsIDOMNode> nextNode = do_QueryInterface(child);
   1:       
   1:       // scan for next node, deleting empty text nodes on way
   1:       while (nextNode && mEditor->IsTextNode(nextNode))
   1:       {
   1:         textNode = do_QueryInterface(nextNode);
   1:         if (!textNode) break;// found a br, stop there
   1: 
   1:         res = textNode->GetLength(&strLength);
   1:         if (NS_FAILED(res)) return res;
   1:         if (strLength) break;  // found a non-empty text node
   1:         
   1:         // delete empty text node
   1:         res = mEditor->DeleteNode(nextNode);
   1:         if (NS_FAILED(res)) return res;
   1:         
   1:         // find next node
   1:         if (aCollapsedAction == nsIEditor::ePrevious)
   1:           --startOffset;
   1:           // don't need to increment startOffset for nsIEditor::eNext
   1:         child = content->GetChildAt(startOffset);
   1: 
   1:         nextNode = do_QueryInterface(child);
   1:       }
   1:       // fix for bugzilla #125161: if we are about to forward delete a <BR>,
   1:       // make sure it is not last node in editfield.  If it is, cancel deletion.
   1:       if (nextNode && (aCollapsedAction == nsIEditor::eNext) && nsTextEditUtils::IsBreak(nextNode))
   1:       {
   1:         if (!GetBody()) return NS_ERROR_NULL_POINTER;
   1:         nsCOMPtr<nsIDOMNode> lastChild;
   1:         res = mBody->GetLastChild(getter_AddRefs(lastChild));
   1:         if (lastChild == nextNode)
   1:         {
   1:           *aCancel = PR_TRUE;
   1:           return NS_OK;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidDeleteSelection(nsISelection *aSelection, 
   1:                                     nsIEditor::EDirection aCollapsedAction, 
   1:                                     nsresult aResult)
   1: {
   1:   nsCOMPtr<nsIDOMNode> startNode;
   1:   PRInt32 startOffset;
   1:   nsresult res = mEditor->GetStartNodeAndOffset(aSelection, address_of(startNode), &startOffset);
   1:   if (NS_FAILED(res)) return res;
   1:   if (!startNode) return NS_ERROR_FAILURE;
   1:   
   1:   // delete empty text nodes at selection
   1:   if (mEditor->IsTextNode(startNode))
   1:   {
   1:     nsCOMPtr<nsIDOMText> textNode = do_QueryInterface(startNode);
   1:     PRUint32 strLength;
   1:     res = textNode->GetLength(&strLength);
   1:     if (NS_FAILED(res)) return res;
   1:     
   1:     // are we in an empty text node?
   1:     if (!strLength)
   1:     {
   1:       res = mEditor->DeleteNode(startNode);
   1:       if (NS_FAILED(res)) return res;
   1:     }
   1:   }
   1:   if (!mDidExplicitlySetInterline)
   1:   {
   1:     // We prevent the caret from sticking on the left of prior BR
   1:     // (i.e. the end of previous line) after this deletion.  Bug 92124
   1:     nsCOMPtr<nsISelectionPrivate> selPriv = do_QueryInterface(aSelection);
   1:     if (selPriv) res = selPriv->SetInterlinePosition(PR_TRUE);
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::WillUndo(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
   1: {
   1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
   1:   CANCEL_OPERATION_IF_READONLY_OR_DISABLED
   1:   // initialize out param
   1:   *aCancel = PR_FALSE;
   1:   *aHandled = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: /* the idea here is to see if the magic empty node has suddenly reappeared as the result of the undo.
   1:  * if it has, set our state so we remember it.
   1:  * There is a tradeoff between doing here and at redo, or doing it everywhere else that might care.
   1:  * Since undo and redo are relatively rare, it makes sense to take the (small) performance hit here.
   1:  */
   1: nsresult
   1: nsTextEditRules:: DidUndo(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   nsresult res = aResult;  // if aResult is an error, we return it.
   1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
   1:   if (NS_SUCCEEDED(res)) 
   1:   {
   1:     if (mBogusNode) {
   1:       mBogusNode = nsnull;
   1:     }
   1:     else
   1:     {
   1:       nsIDOMElement *theRoot = mEditor->GetRoot();
   1:       if (!theRoot) return NS_ERROR_FAILURE;
   1:       nsCOMPtr<nsIDOMNode> node = mEditor->GetLeftmostChild(theRoot);
   1:       if (node && mEditor->IsMozEditorBogusNode(node))
   1:         mBogusNode = node;
   1:     }
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::WillRedo(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled)
   1: {
   1:   if (!aSelection || !aCancel || !aHandled) { return NS_ERROR_NULL_POINTER; }
   1:   CANCEL_OPERATION_IF_READONLY_OR_DISABLED
   1:   // initialize out param
   1:   *aCancel = PR_FALSE;
   1:   *aHandled = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidRedo(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   nsresult res = aResult;  // if aResult is an error, we return it.
   1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
   1:   if (NS_SUCCEEDED(res)) 
   1:   {
   1:     if (mBogusNode) {
   1:       mBogusNode = nsnull;
   1:     }
   1:     else
   1:     {
   1:       nsIDOMElement *theRoot = mEditor->GetRoot();
   1:       if (!theRoot) return NS_ERROR_FAILURE;
   1:       
   1:       nsCOMPtr<nsIDOMNodeList> nodeList;
   1:       res = theRoot->GetElementsByTagName(NS_LITERAL_STRING("div"),
   1:                                           getter_AddRefs(nodeList));
   1:       if (NS_FAILED(res)) return res;
   1:       if (nodeList)
   1:       {
   1:         PRUint32 len;
   1:         nodeList->GetLength(&len);
   1:         
   1:         if (len != 1) return NS_OK;  // only in the case of one div could there be the bogus node
   1:         nsCOMPtr<nsIDOMNode> node;
   1:         nodeList->Item(0, getter_AddRefs(node));
   1:         if (!node) return NS_ERROR_NULL_POINTER;
   1:         if (mEditor->IsMozEditorBogusNode(node))
   1:           mBogusNode = node;
   1:       }
   1:     }
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::WillOutputText(nsISelection *aSelection, 
   1:                                 const nsAString  *aOutputFormat,
   1:                                 nsAString *aOutString,                                
   1:                                 PRBool   *aCancel,
   1:                                 PRBool   *aHandled)
   1: {
   1:   // null selection ok
   1:   if (!aOutString || !aOutputFormat || !aCancel || !aHandled) 
   1:     { return NS_ERROR_NULL_POINTER; }
   1: 
   1:   // initialize out param
   1:   *aCancel = PR_FALSE;
   1:   *aHandled = PR_FALSE;
   1: 
   1:   nsAutoString outputFormat(*aOutputFormat);
   1:   ToLowerCase(outputFormat);
   1:   if (outputFormat.EqualsLiteral("text/plain"))
   1:   { // only use these rules for plain text output
   1:     if (mFlags & nsIPlaintextEditor::eEditorPasswordMask)
   1:     {
   1:       *aOutString = mPasswordText;
   1:       *aHandled = PR_TRUE;
   1:     }
   1:     else if (mBogusNode)
   1:     { // this means there's no content, so output null string
   1:       aOutString->Truncate();
   1:       *aHandled = PR_TRUE;
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::DidOutputText(nsISelection *aSelection, nsresult aResult)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::ReplaceNewlines(nsIDOMRange *aRange)
   1: {
   1:   if (!aRange) return NS_ERROR_NULL_POINTER;
   1:   
   1:   // convert any newlines in editable, preformatted text nodes 
   1:   // into normal breaks.  this is because layout won't give us a place 
   1:   // to put the cursor on empty lines otherwise.
   1: 
   1:   nsresult res;
   1:   nsCOMPtr<nsIContentIterator> iter =
   1:        do_CreateInstance("@mozilla.org/content/post-content-iterator;1", &res);
   1:   if (NS_FAILED(res)) return res;
   1: 
   1:   res = iter->Init(aRange);
   1:   if (NS_FAILED(res)) return res;
   1:   
   1:   nsCOMArray<nsIDOMCharacterData> arrayOfNodes;
   1:   
   1:   // gather up a list of editable preformatted text nodes
   1:   while (!iter->IsDone())
   1:   {
   1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(iter->GetCurrentNode());
   1:     if (!node)
   1:       return NS_ERROR_FAILURE;
   1: 
   1:     if (mEditor->IsTextNode(node) && mEditor->IsEditable(node))
   1:     {
   1:       PRBool isPRE;
   1:       res = mEditor->IsPreformatted(node, &isPRE);
   1:       if (NS_FAILED(res)) return res;
   1:       if (isPRE)
   1:       {
   1:         nsCOMPtr<nsIDOMCharacterData> data = do_QueryInterface(node);
   1:         arrayOfNodes.AppendObject(data);
   1:       }
   1:     }
   1:     iter->Next();
   1:   }
   1:   
   1:   // replace newlines with breaks.  have to do this left to right,
   1:   // since inserting the break can split the text node, and the
   1:   // original node becomes the righthand node.
   1:   PRInt32 j, nodeCount = arrayOfNodes.Count();
   1:   for (j = 0; j < nodeCount; j++)
   1:   {
   1:     nsCOMPtr<nsIDOMNode> brNode;
   1:     nsCOMPtr<nsIDOMCharacterData> textNode = arrayOfNodes[0];
   1:     arrayOfNodes.RemoveObjectAt(0);
   1:     // find the newline
   1:     PRInt32 offset;
   1:     nsAutoString tempString;
   1:     do 
   1:     {
   1:       textNode->GetData(tempString);
   1:       offset = tempString.FindChar(nsCRT::LF);
   1:       if (offset == -1) break; // done with this node
   1:       
   1:       // delete the newline
3030:       nsRefPtr<DeleteTextTxn> txn;
   1:       // note 1: we are not telling edit listeners about these because they don't care
   1:       // note 2: we are not wrapping these in a placeholder because we know they already are,
   1:       //         or, failing that, undo is disabled
3030:       res = mEditor->CreateTxnForDeleteText(textNode, offset, 1,
3030:                                             getter_AddRefs(txn));
   1:       if (NS_FAILED(res))  return res; 
   1:       if (!txn)  return NS_ERROR_OUT_OF_MEMORY;
   1:       res = mEditor->DoTransaction(txn); 
   1:       if (NS_FAILED(res))  return res; 
   1:       
   1:       // insert a break
   1:       res = mEditor->CreateBR(textNode, offset, address_of(brNode));
   1:       if (NS_FAILED(res)) return res;
   1:     } while (1);  // break used to exit while loop
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::CreateTrailingBRIfNeeded()
   1: {
   1:   // but only if we aren't a single line edit field
   1:   if (mFlags & nsIPlaintextEditor::eEditorSingleLineMask)
   1:     return NS_OK;
   1:   if (!GetBody()) return NS_ERROR_NULL_POINTER;
   1:   nsCOMPtr<nsIDOMNode> lastChild;
   1:   nsresult res = mBody->GetLastChild(getter_AddRefs(lastChild));
   1:   // assuming CreateBogusNodeIfNeeded() has been called first
   1:   if (NS_FAILED(res)) return res;  
   1:   if (!lastChild) return NS_ERROR_NULL_POINTER;
   1: 
   1:   if (!nsTextEditUtils::IsBreak(lastChild))
   1:   {
   1:     nsAutoTxnsConserveSelection dontSpazMySelection(mEditor);
   1:     PRUint32 rootLen;
   1:     res = mEditor->GetLengthOfDOMNode(mBody, rootLen);
   1:     if (NS_FAILED(res)) return res; 
   1:     nsCOMPtr<nsIDOMNode> unused;
   1:     res = CreateMozBR(mBody, rootLen, address_of(unused));
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::CreateBogusNodeIfNeeded(nsISelection *aSelection)
   1: {
   1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
   1:   if (!mEditor) { return NS_ERROR_NULL_POINTER; }
   1:   if (mBogusNode) return NS_OK;  // let's not create more than one, ok?
   1: 
   1:   // tell rules system to not do any post-processing
   1:   nsAutoRules beginRulesSniffing(mEditor, nsEditor::kOpIgnore, nsIEditor::eNone);
   1:   
   1:   if (!GetBody())
   1:   {
   1:     // we don't even have a body yet, don't insert any bogus nodes at
   1:     // this point.
   1: 
   1:     return NS_OK;
   1:   }
   1: 
   1:   // now we've got the body tag.
   1:   // iterate the body tag, looking for editable content
   1:   // if no editable content is found, insert the bogus node
   1:   PRBool needsBogusContent=PR_TRUE;
   1:   nsCOMPtr<nsIDOMNode> bodyChild;
   1:   nsresult res = mBody->GetFirstChild(getter_AddRefs(bodyChild));        
   1:   while ((NS_SUCCEEDED(res)) && bodyChild)
   1:   { 
2896:     if (mEditor->IsMozEditorBogusNode(bodyChild) ||
2896:         !mEditor->IsEditable(mBody) ||
2896:         mEditor->IsEditable(bodyChild))
   1:     {
   1:       needsBogusContent = PR_FALSE;
   1:       break;
   1:     }
   1:     nsCOMPtr<nsIDOMNode>temp;
   1:     bodyChild->GetNextSibling(getter_AddRefs(temp));
   1:     bodyChild = do_QueryInterface(temp);
   1:   }
   1:   if (needsBogusContent)
   1:   {
   1:     // create a br
   1:     nsCOMPtr<nsIContent> newContent;
   1:     res = mEditor->CreateHTMLContent(NS_LITERAL_STRING("br"), getter_AddRefs(newContent));
   1:     if (NS_FAILED(res)) return res;
   1:     nsCOMPtr<nsIDOMElement>brElement = do_QueryInterface(newContent);
   1: 
   1:     // set mBogusNode to be the newly created <br>
   1:     mBogusNode = brElement;
   1:     if (!mBogusNode) return NS_ERROR_NULL_POINTER;
   1: 
   1:     // give it a special attribute
   1:     brElement->SetAttribute( kMOZEditorBogusNodeAttr,
   1:                              kMOZEditorBogusNodeValue );
   1:     
   1:     // put the node in the document
   1:     res = mEditor->InsertNode(mBogusNode, mBody, 0);
   1:     if (NS_FAILED(res)) return res;
   1: 
   1:     // set selection
   1:     aSelection->Collapse(mBody, 0);
   1:   }
   1:   return res;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsTextEditRules::TruncateInsertionIfNeeded(nsISelection *aSelection, 
   1:                                            const nsAString  *aInString,
   1:                                            nsAString  *aOutString,
   1:                                            PRInt32          aMaxLength)
   1: {
   1:   if (!aSelection || !aInString || !aOutString) {return NS_ERROR_NULL_POINTER;}
   1:   
   1:   nsresult res = NS_OK;
   1:   *aOutString = *aInString;
   1:   
   1:   if ((-1 != aMaxLength) && (mFlags & nsIPlaintextEditor::eEditorPlaintextMask)
   1:       && !mEditor->IsIMEComposing() )
   1:   {
   1:     // Get the current text length.
   1:     // Get the length of inString.
   1:     // Get the length of the selection.
   1:     //   If selection is collapsed, it is length 0.
   1:     //   Subtract the length of the selection from the len(doc) 
   1:     //   since we'll delete the selection on insert.
   1:     //   This is resultingDocLength.
   1:     // Get old length of IME composing string
   1:     //   which will be replaced by new one.
   1:     // If (resultingDocLength) is at or over max, cancel the insert
   1:     // If (resultingDocLength) + (length of input) > max, 
   1:     //    set aOutString to subset of inString so length = max
   1:     PRInt32 docLength;
   1:     res = mEditor->GetTextLength(&docLength);
   1:     if (NS_FAILED(res)) { return res; }
   1: 
   1:     PRUint32 start, end;
   1:     res = mEditor->GetTextSelectionOffsets(aSelection, start, end);
   1:     if (NS_FAILED(res)) { return res; }
   1: 
   1:     PRInt32 oldCompStrLength;
   1:     res = mEditor->GetIMEBufferLength(&oldCompStrLength);
   1:     if (NS_FAILED(res)) { return res; }
   1: 
   1:     const PRInt32 selectionLength = end - start;
   1:     const PRInt32 resultingDocLength = docLength - selectionLength - oldCompStrLength;
   1:     if (resultingDocLength >= aMaxLength)
   1:     {
   1:       aOutString->Truncate();
   1:     }
   1:     else
   1:     {
   1:       PRInt32 inCount = aOutString->Length();
   1:       if (inCount + resultingDocLength > aMaxLength)
   1:       {
   1:         aOutString->Truncate(aMaxLength - resultingDocLength);
   1:       }
   1:     }
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::ResetIMETextPWBuf()
   1: {
   1:   mPasswordIMEText.Truncate();
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::RemoveIMETextFromPWBuf(PRUint32 &aStart, nsAString *aIMEString)
   1: {
   1:   if (!aIMEString) {
   1:     return NS_ERROR_NULL_POINTER;
   1:   }
   1: 
   1:   // initialize PasswordIME
   1:   if (mPasswordIMEText.IsEmpty()) {
   1:     mPasswordIMEIndex = aStart;
   1:   }
   1:   else {
   1:     // manage the password buffer
   1:     mPasswordText.Cut(mPasswordIMEIndex, mPasswordIMEText.Length());
   1:     aStart = mPasswordIMEIndex;
   1:   }
   1: 
   1:   mPasswordIMEText.Assign(*aIMEString);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTextEditRules::EchoInsertionToPWBuff(PRInt32 aStart, PRInt32 aEnd, nsAString *aOutString)
   1: {
   1:   if (!aOutString) {return NS_ERROR_NULL_POINTER;}
   1: 
   1:   // manage the password buffer
   1:   mPasswordText.Insert(*aOutString, aStart);
   1: 
   1:   // change the output to the platform password character
   1:   PRUnichar passwordChar = PRUnichar('*');
   1:   nsCOMPtr<nsILookAndFeel> lookAndFeel = do_GetService(kLookAndFeelCID);
   1:   if (lookAndFeel)
   1:   {
   1:     passwordChar = lookAndFeel->GetPasswordCharacter();
   1:   }
   1: 
   1:   PRInt32 length = aOutString->Length();
   1:   PRInt32 i;
   1:   aOutString->Truncate();
   1:   for (i=0; i<length; i++)
   1:   {
   1:     aOutString->Append(passwordChar);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: ///////////////////////////////////////////////////////////////////////////
   1: // CreateMozBR: put a BR node with moz attribute at {aNode, aOffset}
   1: //                       
   1: nsresult 
   1: nsTextEditRules::CreateMozBR(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outBRNode)
   1: {
   1:   if (!inParent || !outBRNode) return NS_ERROR_NULL_POINTER;
   1: 
   1:   nsresult res = mEditor->CreateBR(inParent, inOffset, outBRNode);
   1:   if (NS_FAILED(res)) return res;
   1: 
   1:   // give it special moz attr
   1:   nsCOMPtr<nsIDOMElement> brElem = do_QueryInterface(*outBRNode);
   1:   if (brElem)
   1:   {
   1:     res = mEditor->SetAttribute(brElem, NS_LITERAL_STRING("type"), NS_LITERAL_STRING("_moz"));
   1:     if (NS_FAILED(res)) return res;
   1:   }
   1:   return res;
   1: }
   1: 
   1: nsIDOMNode *
   1: nsTextEditRules::GetBody()
   1: {
   1:   if (!mBody)
   1:   {
   1:     // remember our body node
   1:     mBody = mEditor->GetRoot();
   1:   }
   1: 
   1:   return mBody;
   1: }
