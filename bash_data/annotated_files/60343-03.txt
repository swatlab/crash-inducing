    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* base class of all rendering objects */
    1: 
    1: #ifndef nsFrame_h___
    1: #define nsFrame_h___
    1: 
    1: #include "nsBox.h"
    1: #include "nsRect.h"
    1: #include "nsString.h"
    1: #include "prlog.h"
    1: 
    1: #include "nsIPresShell.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsHTMLReflowState.h"
    1: #include "nsHTMLReflowMetrics.h"
    1: 
    1: /**
    1:  * nsFrame logging constants. We redefine the nspr
    1:  * PRLogModuleInfo.level field to be a bitfield.  Each bit controls a
    1:  * specific type of logging. Each logging operation has associated
    1:  * inline methods defined below.
    1:  */
    1: #define NS_FRAME_TRACE_CALLS        0x1
    1: #define NS_FRAME_TRACE_PUSH_PULL    0x2
    1: #define NS_FRAME_TRACE_CHILD_REFLOW 0x4
    1: #define NS_FRAME_TRACE_NEW_FRAMES   0x8
    1: 
    1: #define NS_FRAME_LOG_TEST(_lm,_bit) (PRIntn((_lm)->level) & (_bit))
    1: 
    1: #ifdef NS_DEBUG
    1: #define NS_FRAME_LOG(_bit,_args)                                \
    1:   PR_BEGIN_MACRO                                                \
31709:     if (NS_FRAME_LOG_TEST(nsFrame::GetLogModuleInfo(),_bit)) {  \
    1:       PR_LogPrint _args;                                        \
    1:     }                                                           \
    1:   PR_END_MACRO
    1: #else
    1: #define NS_FRAME_LOG(_bit,_args)
    1: #endif
    1: 
    1: // XXX Need to rework this so that logging is free when it's off
    1: #ifdef NS_DEBUG
    1: #define NS_FRAME_TRACE_IN(_method) Trace(_method, PR_TRUE)
    1: 
    1: #define NS_FRAME_TRACE_OUT(_method) Trace(_method, PR_FALSE)
    1: 
    1: // XXX remove me
    1: #define NS_FRAME_TRACE_MSG(_bit,_args)                          \
    1:   PR_BEGIN_MACRO                                                \
31709:     if (NS_FRAME_LOG_TEST(nsFrame::GetLogModuleInfo(),_bit)) {  \
    1:       TraceMsg _args;                                           \
    1:     }                                                           \
    1:   PR_END_MACRO
    1: 
    1: #define NS_FRAME_TRACE(_bit,_args)                              \
    1:   PR_BEGIN_MACRO                                                \
31709:     if (NS_FRAME_LOG_TEST(nsFrame::GetLogModuleInfo(),_bit)) {  \
    1:       TraceMsg _args;                                           \
    1:     }                                                           \
    1:   PR_END_MACRO
    1: 
    1: #define NS_FRAME_TRACE_REFLOW_IN(_method) Trace(_method, PR_TRUE)
    1: 
    1: #define NS_FRAME_TRACE_REFLOW_OUT(_method, _status) \
    1:   Trace(_method, PR_FALSE, _status)
    1: 
    1: #else
    1: #define NS_FRAME_TRACE(_bits,_args)
    1: #define NS_FRAME_TRACE_IN(_method)
    1: #define NS_FRAME_TRACE_OUT(_method)
    1: #define NS_FRAME_TRACE_MSG(_bits,_args)
    1: #define NS_FRAME_TRACE_REFLOW_IN(_method)
    1: #define NS_FRAME_TRACE_REFLOW_OUT(_method, _status)
    1: #endif
    1: 
32423: // Frame allocation boilerplate macros.  Every subclass of nsFrame
32423: // must define its own operator new and GetAllocatedSize.  If they do
32423: // not, the per-frame recycler lists in nsPresArena will not work
32423: // correctly, with potentially catastrophic consequences (not enough
32423: // memory is allocated for a frame object).
32423: 
32423: #define NS_DECL_FRAMEARENA_HELPERS                                \
32423:   NS_MUST_OVERRIDE void* operator new(size_t, nsIPresShell*);     \
32511:   virtual NS_MUST_OVERRIDE nsQueryFrame::FrameIID GetFrameId();
32423: 
32423: #define NS_IMPL_FRAMEARENA_HELPERS(class)                         \
32423:   void* class::operator new(size_t sz, nsIPresShell* aShell)      \
32511:   { return aShell->AllocateFrame(nsQueryFrame::class##_id, sz); } \
32511:   nsQueryFrame::FrameIID class::GetFrameId()                      \
32511:   { return nsQueryFrame::class##_id; }
32423: 
    1: //----------------------------------------------------------------------
    1: 
    1: struct nsBoxLayoutMetrics;
    1: 
    1: /**
    1:  * Implementation of a simple frame that's not splittable and has no
    1:  * child frames.
    1:  *
    1:  * Sets the NS_FRAME_SYNCHRONIZE_FRAME_AND_VIEW bit, so the default
    1:  * behavior is to keep the frame and view position and size in sync.
    1:  */
    1: class nsFrame : public nsBox
    1: {
    1: public:
    1:   /**
    1:    * Create a new "empty" frame that maps a given piece of content into a
    1:    * 0,0 area.
    1:    */
31620:   friend nsIFrame* NS_NewEmptyFrame(nsIPresShell* aShell,
31620:                                     nsStyleContext* aContext);
    1: 
31620: private:
31620:   // Left undefined; nsFrame objects are never allocated from the heap.
31620:   void* operator new(size_t sz) CPP_THROW_NEW;
31620: 
31620: protected:
31620:   // Overridden to prevent the global delete from being called, since
31620:   // the memory came out of an arena instead of the heap.
31620:   //
31620:   // Ideally this would be private and undefined, like the normal
31620:   // operator new.  Unfortunately, the C++ standard requires an
31620:   // overridden operator delete to be accessible to any subclass that
31620:   // defines a virtual destructor, so we can only make it protected;
31620:   // worse, some C++ compilers will synthesize calls to this function
31620:   // from the "deleting destructors" that they emit in case of
31620:   // delete-expressions, so it can't even be undefined.
    1:   void operator delete(void* aPtr, size_t sz);
    1: 
    1: public:
    1: 
23554:   // nsQueryFrame
23554:   NS_DECL_QUERYFRAME
32423:   NS_DECL_FRAMEARENA_HELPERS
    1: 
    1:   // nsIFrame
    1:   NS_IMETHOD  Init(nsIContent*      aContent,
    1:                    nsIFrame*        aParent,
    1:                    nsIFrame*        asPrevInFlow);
    1:   NS_IMETHOD  SetInitialChildList(nsIAtom*           aListName,
30790:                                   nsFrameList&       aChildList);
    1:   NS_IMETHOD  AppendFrames(nsIAtom*        aListName,
30941:                            nsFrameList&    aFrameList);
    1:   NS_IMETHOD  InsertFrames(nsIAtom*        aListName,
    1:                            nsIFrame*       aPrevFrame,
30941:                            nsFrameList&    aFrameList);
    1:   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
    1:                           nsIFrame*       aOldFrame);
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
    1:   virtual nsStyleContext* GetAdditionalStyleContext(PRInt32 aIndex) const;
    1:   virtual void SetAdditionalStyleContext(PRInt32 aIndex,
    1:                                          nsStyleContext* aStyleContext);
51752:   virtual void SetParent(nsIFrame* aParent);
    1:   virtual nscoord GetBaseline() const;
    1:   virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
30783:   virtual nsFrameList GetChildList(nsIAtom* aListName) const;
    1:   NS_IMETHOD  HandleEvent(nsPresContext* aPresContext, 
    1:                           nsGUIEvent*     aEvent,
    1:                           nsEventStatus*  aEventStatus);
    1:   NS_IMETHOD  GetContentForEvent(nsPresContext* aPresContext,
    1:                                  nsEvent* aEvent,
    1:                                  nsIContent** aContent);
    1:   NS_IMETHOD  GetCursor(const nsPoint&    aPoint,
    1:                         nsIFrame::Cursor& aCursor);
    1: 
 4741:   NS_IMETHOD  GetPointFromOffset(PRInt32                inOffset,
    1:                                  nsPoint*               outPoint);
    1: 
    1:   NS_IMETHOD  GetChildFrameContainingOffset(PRInt32     inContentOffset,
    1:                                  PRBool                 inHint,
    1:                                  PRInt32*               outFrameContentOffset,
    1:                                  nsIFrame*              *outChildFrame);
    1: 
    1:   static nsresult  GetNextPrevLineFromeBlockFrame(nsPresContext* aPresContext,
    1:                                         nsPeekOffsetStruct *aPos, 
    1:                                         nsIFrame *aBlockFrame, 
    1:                                         PRInt32 aLineStart, 
    1:                                         PRInt8 aOutSideLimit
    1:                                         );
    1: 
31131:   NS_IMETHOD  CharacterDataChanged(CharacterDataChangeInfo* aInfo);
    1:   NS_IMETHOD  AttributeChanged(PRInt32         aNameSpaceID,
    1:                                nsIAtom*        aAttribute,
    1:                                PRInt32         aModType);
    1:   virtual nsSplittableType GetSplittableType() const;
    1:   virtual nsIFrame* GetPrevContinuation() const;
    1:   NS_IMETHOD  SetPrevContinuation(nsIFrame*);
    1:   virtual nsIFrame* GetNextContinuation() const;
    1:   NS_IMETHOD  SetNextContinuation(nsIFrame*);
    1:   virtual nsIFrame* GetPrevInFlowVirtual() const;
    1:   NS_IMETHOD  SetPrevInFlow(nsIFrame*);
    1:   virtual nsIFrame* GetNextInFlowVirtual() const;
    1:   NS_IMETHOD  SetNextInFlow(nsIFrame*);
    1:   NS_IMETHOD  GetOffsetFromView(nsPoint& aOffset, nsIView** aView) const;
    1:   virtual nsIAtom* GetType() const;
    1:   virtual PRBool IsContainingBlock() const;
    1: 
    1:   NS_IMETHOD  GetSelected(PRBool *aSelected) const;
    1:   NS_IMETHOD  IsSelectable(PRBool* aIsSelectable, PRUint8* aSelectStyle) const;
    1: 
    1:   NS_IMETHOD  GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon);
    1: 
    1:   virtual PRBool PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset);
59604:   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset,
59604:                                      PRBool aRespectClusters = PR_TRUE);
    1:   virtual PRBool PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
 5453:                                 PRInt32* aOffset, PeekWordState *aState);
 5453:   /**
 5453:    * Check whether we should break at a boundary between punctuation and
12505:    * non-punctuation. Only call it at a punctuation boundary
12505:    * (i.e. exactly one of the previous and next characters are punctuation).
12505:    * @param aForward true if we're moving forward in content order
12505:    * @param aPunctAfter true if the next character is punctuation
12505:    * @param aWhitespaceAfter true if the next character is whitespace
 5453:    */
12505:   PRBool BreakWordBetweenPunctuation(const PeekWordState* aState,
12505:                                      PRBool aForward,
12505:                                      PRBool aPunctAfter, PRBool aWhitespaceAfter,
12505:                                      PRBool aIsKeyboardSelect);
    1: 
    1:   NS_IMETHOD  CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex, PRInt32 aEndIndex, PRBool aRecurse, PRBool *aFinished, PRBool *_retval);
    1: 
    1:   NS_IMETHOD  GetOffsets(PRInt32 &aStart, PRInt32 &aEnd) const;
    1:   virtual void ChildIsDirty(nsIFrame* aChild);
    1: 
    1: #ifdef ACCESSIBILITY
46338:   virtual already_AddRefed<nsAccessible> CreateAccessible();
    1: #endif
    1: 
    1:   NS_IMETHOD GetParentStyleContextFrame(nsPresContext* aPresContext,
    1:                                         nsIFrame**      aProviderFrame,
    1:                                         PRBool*         aIsChild);
    1: 
    1:   virtual PRBool IsEmpty();
    1:   virtual PRBool IsSelfEmpty();
    1: 
    1:   virtual void MarkIntrinsicWidthsDirty();
    1:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
    1:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
    1:   virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                  InlineMinWidthData *aData);
    1:   virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                   InlinePrefWidthData *aData);
    1:   virtual IntrinsicWidthOffsetData
    1:     IntrinsicWidthOffsets(nsIRenderingContext* aRenderingContext);
 8142:   virtual IntrinsicSize GetIntrinsicSize();
 2301:   virtual nsSize GetIntrinsicRatio();
    1: 
    1:   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                              nsSize aCBSize, nscoord aAvailableWidth,
    1:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                              PRBool aShrinkWrap);
    1: 
 6862:   // Compute tight bounds assuming this frame honours its border, background
 6862:   // and outline, its children's tight bounds, and nothing else.
 6862:   nsRect ComputeSimpleTightBounds(gfxContext* aContext) const;
 6862:   
    1:   /**
    1:    * A helper, used by |nsFrame::ComputeSize| (for frames that need to
    1:    * override only this part of ComputeSize), that computes the size
    1:    * that should be returned when 'width', 'height', and
    1:    * min/max-width/height are all 'auto' or equivalent.
    1:    *
    1:    * In general, frames that can accept any computed width/height should
    1:    * override only ComputeAutoSize, and frames that cannot do so need to
    1:    * override ComputeSize to enforce their width/height invariants.
    1:    *
    1:    * Implementations may optimize by returning a garbage width if
10792:    * GetStylePosition()->mWidth.GetUnit() != eStyleUnit_Auto, and
    1:    * likewise for height, since in such cases the result is guaranteed
    1:    * to be unused.
    1:    */
    1:   virtual nsSize ComputeAutoSize(nsIRenderingContext *aRenderingContext,
    1:                                  nsSize aCBSize, nscoord aAvailableWidth,
    1:                                  nsSize aMargin, nsSize aBorder,
    1:                                  nsSize aPadding, PRBool aShrinkWrap);
    1: 
    1:   /**
    1:    * Utility function for ComputeAutoSize implementations.  Return
    1:    * max(GetMinWidth(), min(aWidthInCB, GetPrefWidth()))
    1:    */
    1:   nscoord ShrinkWidthToFit(nsIRenderingContext *aRenderingContext,
    1:                            nscoord aWidthInCB);
    1: 
    1:   NS_IMETHOD  WillReflow(nsPresContext* aPresContext);
    1:   NS_IMETHOD  Reflow(nsPresContext*          aPresContext,
    1:                      nsHTMLReflowMetrics&     aDesiredSize,
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsReflowStatus&          aStatus);
    1:   NS_IMETHOD  DidReflow(nsPresContext*           aPresContext,
    1:                         const nsHTMLReflowState*  aReflowState,
    1:                         nsDidReflowStatus         aStatus);
    1:   virtual PRBool CanContinueTextRun() const;
    1: 
    1:   // Selection Methods
    1:   // XXX Doc me... (in nsIFrame.h puhleeze)
    1:   // XXX If these are selection specific, then the name should imply selection
    1:   // rather than generic event processing, e.g., SelectionHandlePress...
    1:   NS_IMETHOD HandlePress(nsPresContext* aPresContext,
    1:                          nsGUIEvent *    aEvent,
    1:                          nsEventStatus*  aEventStatus);
    1: 
    1:   NS_IMETHOD HandleMultiplePress(nsPresContext* aPresContext,
    1:                          nsGUIEvent *    aEvent,
20590:                          nsEventStatus*  aEventStatus,
20590:                          PRBool          aControlHeld);
    1: 
    1:   NS_IMETHOD HandleDrag(nsPresContext* aPresContext,
    1:                         nsGUIEvent *    aEvent,
    1:                         nsEventStatus*  aEventStatus);
    1: 
    1:   NS_IMETHOD HandleRelease(nsPresContext* aPresContext,
    1:                            nsGUIEvent *    aEvent,
    1:                            nsEventStatus*  aEventStatus);
    1: 
    1:   NS_IMETHOD PeekBackwardAndForward(nsSelectionAmount aAmountBack,
    1:                                     nsSelectionAmount aAmountForward,
    1:                                     PRInt32 aStartPos,
    1:                                     nsPresContext* aPresContext,
20590:                                     PRBool aJumpLines,
20590:                                     PRBool aMultipleSelection);
    1: 
    1: 
    1:   // Helper for GetContentAndOffsetsFromPoint; calculation of content offsets
    1:   // in this function assumes there is no child frame that can be targeted.
    1:   virtual ContentOffsets CalcContentOffsetsFromFramePoint(nsPoint aPoint);
    1: 
    1:   // Box layout methods
    1:   virtual nsSize GetPrefSize(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nsSize GetMinSize(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nsSize GetMaxSize(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nscoord GetFlex(nsBoxLayoutState& aBoxLayoutState);
    1:   virtual nscoord GetBoxAscent(nsBoxLayoutState& aBoxLayoutState);
    1: 
31620:   // We compute and store the HTML content's overflow area. So don't
31620:   // try to compute it in the box code.
31620:   virtual PRBool ComputesOwnOverflowArea() { return PR_TRUE; }
31620: 
    1:   //--------------------------------------------------
    1:   // Additional methods
    1: 
    1:   /**
    1:    * Helper method to invalidate portions of a standard container frame if the
17140:    * desired size indicates that the size has changed (specifically border,
    1:    * background and outline).
    1:    * We assume that the difference between the old frame area and the new
    1:    * frame area is invalidated by some other means.
    1:    * @param aDesiredSize the new size of the frame
    1:    */
17140:   void CheckInvalidateSizeChange(nsHTMLReflowMetrics&     aNewDesiredSize);
    1: 
60343:   // Helper function that tests if the frame tree is too deep; if it is
60343:   // it marks the frame as "unflowable", zeroes out the metrics, sets
60343:   // the reflow status, and returns PR_TRUE. Otherwise, the frame is
60343:   // unmarked "unflowable" and the metrics and reflow status are not
60343:   // touched and PR_FALSE is returned.
    1:   PRBool IsFrameTreeTooDeep(const nsHTMLReflowState& aReflowState,
60343:                             nsHTMLReflowMetrics& aMetrics,
60343:                             nsReflowStatus& aStatus);
    1: 
    1:   // Do the work for getting the parent style context frame so that
    1:   // other frame's |GetParentStyleContextFrame| methods can call this
    1:   // method on *another* frame.  (This function handles out-of-flow
    1:   // frames by using the frame manager's placeholder map and it also
    1:   // handles block-within-inline and generated content wrappers.)
    1:   nsresult DoGetParentStyleContextFrame(nsPresContext* aPresContext,
    1:                                         nsIFrame**      aProviderFrame,
    1:                                         PRBool*         aIsChild);
    1: 
55021:   // Incorporate the child overflow areas into aOverflowAreas.
55021:   // If the child does not have a overflow, use the child area.
55021:   void ConsiderChildOverflow(nsOverflowAreas& aOverflowAreas,
    1:                              nsIFrame* aChildFrame);
    1: 
10152:   virtual const void* GetStyleDataExternal(nsStyleStructID aSID) const;
    1: 
    1: 
    1: #ifdef NS_DEBUG
    1:   /**
    1:    * Tracing method that writes a method enter/exit routine to the
    1:    * nspr log using the nsIFrame log module. The tracing is only
    1:    * done when the NS_FRAME_TRACE_CALLS bit is set in the log module's
    1:    * level field.
    1:    */
    1:   void Trace(const char* aMethod, PRBool aEnter);
    1:   void Trace(const char* aMethod, PRBool aEnter, nsReflowStatus aStatus);
    1:   void TraceMsg(const char* fmt, ...);
    1: 
    1:   // Helper function that verifies that each frame in the list has the
    1:   // NS_FRAME_IS_DIRTY bit set
30790:   static void VerifyDirtyBitSet(const nsFrameList& aFrameList);
    1: 
    1:   // Helper function to return the index in parent of the frame's content
    1:   // object. Returns -1 on error or if the frame doesn't have a content object
    1:   static PRInt32 ContentIndexInContainer(const nsIFrame* aFrame);
    1: 
25777:   static void IndentBy(FILE* out, PRInt32 aIndent) {
25777:     while (--aIndent >= 0) fputs("  ", out);
25777:   }
25777:   
    1:   void ListTag(FILE* out) const {
31709:     ListTag(out, this);
    1:   }
    1: 
31709:   static void ListTag(FILE* out, const nsIFrame* aFrame) {
    1:     nsAutoString tmp;
31709:     aFrame->GetFrameName(tmp);
    1:     fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
31709:     fprintf(out, "@%p", static_cast<const void*>(aFrame));
    1:   }
    1: 
    1:   static void XMLQuote(nsString& aString);
    1: 
    1:   /**
    1:    * Dump out the "base classes" regression data. This should dump
    1:    * out the interior data, not the "frame" XML container. And it
    1:    * should call the base classes same named method before doing
    1:    * anything specific in a derived class. This means that derived
    1:    * classes need not override DumpRegressionData unless they need
    1:    * some custom behavior that requires changing how the outer "frame"
    1:    * XML container is dumped.
    1:    */
24806:   virtual void DumpBaseRegressionData(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent);
    1:   
    1:   nsresult MakeFrameName(const nsAString& aKind, nsAString& aResult) const;
    1: 
    1:   // Display Reflow Debugging 
    1:   static void* DisplayReflowEnter(nsPresContext*          aPresContext,
    1:                                   nsIFrame*                aFrame,
    1:                                   const nsHTMLReflowState& aReflowState);
    1:   static void* DisplayLayoutEnter(nsIFrame* aFrame);
    1:   static void* DisplayIntrinsicWidthEnter(nsIFrame* aFrame,
    1:                                           const char* aType);
    1:   static void* DisplayIntrinsicSizeEnter(nsIFrame* aFrame,
    1:                                          const char* aType);
    1:   static void  DisplayReflowExit(nsPresContext*      aPresContext,
    1:                                  nsIFrame*            aFrame,
    1:                                  nsHTMLReflowMetrics& aMetrics,
    1:                                  PRUint32             aStatus,
    1:                                  void*                aFrameTreeNode);
    1:   static void  DisplayLayoutExit(nsIFrame* aFrame,
    1:                                  void* aFrameTreeNode);
    1:   static void  DisplayIntrinsicWidthExit(nsIFrame* aFrame,
    1:                                          const char* aType,
    1:                                          nscoord aResult,
    1:                                          void* aFrameTreeNode);
    1:   static void  DisplayIntrinsicSizeExit(nsIFrame* aFrame,
    1:                                         const char* aType,
    1:                                         nsSize aResult,
    1:                                         void* aFrameTreeNode);
    1: 
    1:   static void DisplayReflowStartup();
    1:   static void DisplayReflowShutdown();
    1: #endif
    1: 
47753:   static void ShutdownLayerActivityTimer();
47753: 
    1:   /**
30510:    * Adds display item for standard CSS background if necessary.
30510:    * Does not check IsVisibleForPainting.
30510:    * @param aForceBackground draw the background even if the frame
30510:    * background style appears to have no background --- this is useful
30510:    * for frames that might receive a propagated background via
30510:    * nsCSSRendering::FindBackground
30510:    */
30510:   nsresult DisplayBackgroundUnconditional(nsDisplayListBuilder*   aBuilder,
30510:                                           const nsDisplayListSet& aLists,
30510:                                           PRBool aForceBackground = PR_FALSE);
30510:   /**
    1:    * Adds display items for standard CSS borders, background and outline for
    1:    * for this frame, as necessary. Checks IsVisibleForPainting and won't
    1:    * display anything if the frame is not visible.
    1:    * @param aForceBackground draw the background even if the frame
    1:    * background style appears to have no background --- this is useful
    1:    * for frames that might receive a propagated background via
    1:    * nsCSSRendering::FindBackground
    1:    */
    1:   nsresult DisplayBorderBackgroundOutline(nsDisplayListBuilder*   aBuilder,
    1:                                           const nsDisplayListSet& aLists,
    1:                                           PRBool aForceBackground = PR_FALSE);
    1:   /**
    1:    * Add a display item for the CSS outline. Does not check visibility.
    1:    */
    1:   nsresult DisplayOutlineUnconditional(nsDisplayListBuilder*   aBuilder,
    1:                                        const nsDisplayListSet& aLists);
    1:   /**
    1:    * Add a display item for the CSS outline, after calling
    1:    * IsVisibleForPainting to confirm we are visible.
    1:    */
    1:   nsresult DisplayOutline(nsDisplayListBuilder*   aBuilder,
    1:                           const nsDisplayListSet& aLists);
    1: 
  549:   /**
  549:    * Adjust the given parent frame to the right style context parent frame for
  549:    * the child, given the pseudo-type of the prospective child.  This handles
  549:    * things like walking out of table pseudos and so forth.
  549:    *
  549:    * @param aProspectiveParent what GetParent() on the child returns.
  549:    *                           Must not be null.
  549:    * @param aChildPseudo the child's pseudo type, if any.
  549:    */
  549:   static nsIFrame*
  549:   CorrectStyleParentFrame(nsIFrame* aProspectiveParent, nsIAtom* aChildPseudo);
  549: 
    1: protected:
    1:   // Protected constructor and destructor
    1:   nsFrame(nsStyleContext* aContext);
    1:   virtual ~nsFrame();
    1: 
    1:   /**
    1:    * To be called by |BuildDisplayLists| of this class or derived classes to add
    1:    * a translucent overlay if this frame's content is selected.
    1:    * @param aContentType an nsISelectionDisplay DISPLAY_ constant identifying
    1:    * which kind of content this is for
    1:    */
    1:   nsresult DisplaySelectionOverlay(nsDisplayListBuilder* aBuilder,
52291:       nsDisplayList* aList, PRUint16 aContentType = nsISelectionDisplay::DISPLAY_FRAMES);
    1: 
    1:   PRInt16 DisplaySelection(nsPresContext* aPresContext, PRBool isOkToTurnOn = PR_FALSE);
    1:   
    1:   // Style post processing hook
20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
    1: 
    1: public:
    1:   //given a frame five me the first/last leaf available
    1:   //XXX Robert O'Callahan wants to move these elsewhere
    1:   static void GetLastLeaf(nsPresContext* aPresContext, nsIFrame **aFrame);
    1:   static void GetFirstLeaf(nsPresContext* aPresContext, nsIFrame **aFrame);
    1: 
20200:   // Return the line number of the aFrame, and (optionally) the containing block
20200:   // frame.
20200:   // If aScrollLock is true, don't break outside scrollframes when looking for a
20200:   // containing block frame.
20200:   static PRInt32 GetLineNumber(nsIFrame *aFrame,
20200:                                PRBool aLockScroll,
20200:                                nsIFrame** aContainingBlock = nsnull);
    1: 
    1: protected:
    1: 
    1:   // Test if we are selecting a table object:
    1:   //  Most table/cell selection requires that Ctrl (Cmd on Mac) key is down 
    1:   //   during a mouse click or drag. Exception is using Shift+click when
    1:   //   already in "table/cell selection mode" to extend a block selection
    1:   //  Get the parent content node and offset of the frame 
    1:   //   of the enclosing cell or table (if not inside a cell)
    1:   //  aTarget tells us what table element to select (currently only cell and table supported)
    1:   //  (enums for this are defined in nsIFrame.h)
 8295:   NS_IMETHOD GetDataForTableSelection(const nsFrameSelection *aFrameSelection,
    1:                                       nsIPresShell *aPresShell, nsMouseEvent *aMouseEvent, 
    1:                                       nsIContent **aParentContent, PRInt32 *aContentOffset, 
    1:                                       PRInt32 *aTarget);
    1: 
    1:   // Fills aCursor with the appropriate information from ui
    1:   static void FillCursorInformationFromStyle(const nsStyleUserInterface* ui,
    1:                                              nsIFrame::Cursor& aCursor);
    1:   NS_IMETHOD DoLayout(nsBoxLayoutState& aBoxLayoutState);
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   virtual void GetBoxName(nsAutoString& aName);
    1: #endif
    1: 
    1:   void InitBoxMetrics(PRBool aClear);
    1:   nsBoxLayoutMetrics* BoxMetrics() const;
    1: 
    1:   // Fire DOM event. If no aContent argument use frame's mContent.
    1:   void FireDOMEvent(const nsAString& aDOMEventName, nsIContent *aContent = nsnull);
    1: 
    1: private:
    1:   nsresult BoxReflow(nsBoxLayoutState& aState,
    1:                      nsPresContext*    aPresContext,
    1:                      nsHTMLReflowMetrics&     aDesiredSize,
    1:                      nsIRenderingContext* aRenderingContext,
    1:                      nscoord aX,
    1:                      nscoord aY,
    1:                      nscoord aWidth,
    1:                      nscoord aHeight,
    1:                      PRBool aMoveFrame = PR_TRUE);
    1: 
    1:   NS_IMETHODIMP RefreshSizeCache(nsBoxLayoutState& aState);
    1: 
21112:   virtual nsILineIterator* GetLineIterator();
31709: 
31709: #ifdef NS_DEBUG
31709: public:
31709:   // Formerly the nsIFrameDebug interface
31709: 
31709:   NS_IMETHOD  List(FILE* out, PRInt32 aIndent) const;
31709:   /**
31709:    * lists the frames beginning from the root frame
31709:    * - calls root frame's List(...)
31709:    */
31709:   static void RootFrameList(nsPresContext* aPresContext,
31709:                             FILE* out, PRInt32 aIndent);
31709: 
31709:   static void DumpFrameTree(nsIFrame* aFrame);
31709: 
31709:   /**
31709:    * Get a printable from of the name of the frame type.
31709:    * XXX This should be eliminated and we use GetType() instead...
31709:    */
31709:   NS_IMETHOD  GetFrameName(nsAString& aResult) const;
31709:   /**
31709:    * Return the state bits that are relevant to regression tests (that
31709:    * is, those bits which indicate a real difference when they differ
31709:    */
31709:   NS_IMETHOD_(nsFrameState)  GetDebugStateBits() const;
31709:   /**
31709:    * Called to dump out regression data that describes the layout
31709:    * of the frame and its children, and so on. The format of the
31709:    * data is dictated to be XML (using a specific DTD); the
31709:    * specific kind of data dumped is up to the frame itself, with
31709:    * the caveat that some base types are defined.
31709:    * For more information, see XXX.
31709:    */
31709:   NS_IMETHOD  DumpRegressionData(nsPresContext* aPresContext,
31709:                                  FILE* out, PRInt32 aIndent);
31709: 
31709:   /**
31709:    * See if style tree verification is enabled. To enable style tree
31709:    * verification add "styleverifytree:1" to your NSPR_LOG_MODULES
31709:    * environment variable (any non-zero debug level will work). Or,
31709:    * call SetVerifyStyleTreeEnable with PR_TRUE.
31709:    */
31709:   static PRBool GetVerifyStyleTreeEnable();
31709: 
31709:   /**
31709:    * Set the verify-style-tree enable flag.
31709:    */
31709:   static void SetVerifyStyleTreeEnable(PRBool aEnabled);
31709: 
31709:   /**
31709:    * The frame class and related classes share an nspr log module
31709:    * for logging frame activity.
31709:    *
31709:    * Note: the log module is created during library initialization which
31709:    * means that you cannot perform logging before then.
31709:    */
31709:   static PRLogModuleInfo* GetLogModuleInfo();
31709: 
31709:   // Show frame borders when rendering
31709:   static void ShowFrameBorders(PRBool aEnable);
31709:   static PRBool GetShowFrameBorders();
31709: 
31709:   // Show frame border of event target
31709:   static void ShowEventTargetFrameBorder(PRBool aEnable);
31709:   static PRBool GetShowEventTargetFrameBorder();
31709: 
31709:   static void PrintDisplayList(nsDisplayListBuilder* aBuilder,
31709:                                const nsDisplayList& aList);
31709: 
31709: #endif
    1: };
    1: 
    1: // Start Display Reflow Debugging
    1: #ifdef DEBUG
    1: 
    1:   struct DR_cookie {
    1:     DR_cookie(nsPresContext*          aPresContext,
    1:               nsIFrame*                aFrame, 
    1:               const nsHTMLReflowState& aReflowState,
    1:               nsHTMLReflowMetrics&     aMetrics,
    1:               nsReflowStatus&          aStatus);     
    1:     ~DR_cookie();
    1:     void Change() const;
    1: 
    1:     nsPresContext*          mPresContext;
    1:     nsIFrame*                mFrame;
    1:     const nsHTMLReflowState& mReflowState;
    1:     nsHTMLReflowMetrics&     mMetrics;
    1:     nsReflowStatus&          mStatus;    
    1:     void*                    mValue;
    1:   };
    1: 
    1:   struct DR_layout_cookie {
    1:     DR_layout_cookie(nsIFrame* aFrame);
    1:     ~DR_layout_cookie();
    1: 
    1:     nsIFrame* mFrame;
    1:     void* mValue;
    1:   };
    1:   
    1:   struct DR_intrinsic_width_cookie {
    1:     DR_intrinsic_width_cookie(nsIFrame* aFrame, const char* aType,
    1:                               nscoord& aResult);
    1:     ~DR_intrinsic_width_cookie();
    1: 
    1:     nsIFrame* mFrame;
    1:     const char* mType;
    1:     nscoord& mResult;
    1:     void* mValue;
    1:   };
    1:   
    1:   struct DR_intrinsic_size_cookie {
    1:     DR_intrinsic_size_cookie(nsIFrame* aFrame, const char* aType,
    1:                              nsSize& aResult);
    1:     ~DR_intrinsic_size_cookie();
    1: 
    1:     nsIFrame* mFrame;
    1:     const char* mType;
    1:     nsSize& mResult;
    1:     void* mValue;
    1:   };
    1: 
41687:   struct DR_init_constraints_cookie {
41687:     DR_init_constraints_cookie(nsIFrame* aFrame, nsHTMLReflowState* aState,
41687:                                nscoord aCBWidth, nscoord aCBHeight,
41687:                                const nsMargin* aBorder,
41687:                                const nsMargin* aPadding);
41687:     ~DR_init_constraints_cookie();
41687: 
41687:     nsIFrame* mFrame;
41687:     nsHTMLReflowState* mState;
41687:     void* mValue;
41687:   };
41687: 
41687:   struct DR_init_offsets_cookie {
41687:     DR_init_offsets_cookie(nsIFrame* aFrame, nsCSSOffsetState* aState,
41687:                            nscoord aCBWidth, const nsMargin* aBorder,
41687:                            const nsMargin* aPadding);
41687:     ~DR_init_offsets_cookie();
41687: 
41687:     nsIFrame* mFrame;
41687:     nsCSSOffsetState* mState;
41687:     void* mValue;
41687:   };
41687: 
41687:   struct DR_init_type_cookie {
41687:     DR_init_type_cookie(nsIFrame* aFrame, nsHTMLReflowState* aState);
41687:     ~DR_init_type_cookie();
41687: 
41687:     nsIFrame* mFrame;
41687:     nsHTMLReflowState* mState;
41687:     void* mValue;
41687:   };
41687: 
    1: #define DISPLAY_REFLOW(dr_pres_context, dr_frame, dr_rf_state, dr_rf_metrics, dr_rf_status) \
    1:   DR_cookie dr_cookie(dr_pres_context, dr_frame, dr_rf_state, dr_rf_metrics, dr_rf_status); 
    1: #define DISPLAY_REFLOW_CHANGE() \
    1:   dr_cookie.Change();
    1: #define DISPLAY_LAYOUT(dr_frame) \
    1:   DR_layout_cookie dr_cookie(dr_frame); 
    1: #define DISPLAY_MIN_WIDTH(dr_frame, dr_result) \
    1:   DR_intrinsic_width_cookie dr_cookie(dr_frame, "Min", dr_result)
    1: #define DISPLAY_PREF_WIDTH(dr_frame, dr_result) \
    1:   DR_intrinsic_width_cookie dr_cookie(dr_frame, "Pref", dr_result)
    1: #define DISPLAY_PREF_SIZE(dr_frame, dr_result) \
    1:   DR_intrinsic_size_cookie dr_cookie(dr_frame, "Pref", dr_result)
    1: #define DISPLAY_MIN_SIZE(dr_frame, dr_result) \
    1:   DR_intrinsic_size_cookie dr_cookie(dr_frame, "Min", dr_result)
    1: #define DISPLAY_MAX_SIZE(dr_frame, dr_result) \
    1:   DR_intrinsic_size_cookie dr_cookie(dr_frame, "Max", dr_result)
41687: #define DISPLAY_INIT_CONSTRAINTS(dr_frame, dr_state, dr_cbw, dr_cbh,       \
41687:                                  dr_bdr, dr_pad)                           \
41687:   DR_init_constraints_cookie dr_cookie(dr_frame, dr_state, dr_cbw, dr_cbh, \
41687:                                        dr_bdr, dr_pad)
41687: #define DISPLAY_INIT_OFFSETS(dr_frame, dr_state, dr_cbw, dr_bdr, dr_pad)  \
41687:   DR_init_offsets_cookie dr_cookie(dr_frame, dr_state, dr_cbw, dr_bdr, dr_pad)
41687: #define DISPLAY_INIT_TYPE(dr_frame, dr_result) \
41687:   DR_init_type_cookie dr_cookie(dr_frame, dr_result)
    1: 
    1: #else
    1: 
    1: #define DISPLAY_REFLOW(dr_pres_context, dr_frame, dr_rf_state, dr_rf_metrics, dr_rf_status) 
    1: #define DISPLAY_REFLOW_CHANGE() 
    1: #define DISPLAY_LAYOUT(dr_frame) PR_BEGIN_MACRO PR_END_MACRO
    1: #define DISPLAY_MIN_WIDTH(dr_frame, dr_result) PR_BEGIN_MACRO PR_END_MACRO
    1: #define DISPLAY_PREF_WIDTH(dr_frame, dr_result) PR_BEGIN_MACRO PR_END_MACRO
    1: #define DISPLAY_PREF_SIZE(dr_frame, dr_result) PR_BEGIN_MACRO PR_END_MACRO
    1: #define DISPLAY_MIN_SIZE(dr_frame, dr_result) PR_BEGIN_MACRO PR_END_MACRO
    1: #define DISPLAY_MAX_SIZE(dr_frame, dr_result) PR_BEGIN_MACRO PR_END_MACRO
41687: #define DISPLAY_INIT_CONSTRAINTS(dr_frame, dr_state, dr_cbw, dr_cbh,       \
41687:                                  dr_bdr, dr_pad)                           \
41687:   PR_BEGIN_MACRO PR_END_MACRO
41687: #define DISPLAY_INIT_OFFSETS(dr_frame, dr_state, dr_cbw, dr_bdr, dr_pad)  \
41687:   PR_BEGIN_MACRO PR_END_MACRO
41687: #define DISPLAY_INIT_TYPE(dr_frame, dr_result) PR_BEGIN_MACRO PR_END_MACRO
    1: 
    1: #endif
    1: // End Display Reflow Debugging
    1: 
    1: // similar to NS_ENSURE_TRUE but with no return value
    1: #define ENSURE_TRUE(x)                                        \
    1:   PR_BEGIN_MACRO                                              \
    1:     if (!(x)) {                                               \
    1:        NS_WARNING("ENSURE_TRUE(" #x ") failed");              \
    1:        return;                                                \
    1:     }                                                         \
    1:   PR_END_MACRO
    1: #endif /* nsFrame_h___ */
