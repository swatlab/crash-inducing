29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18830:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS function support.
    1:  */
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
31823: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
21866: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
52503: #include "jspropertytree.h"
47498: #include "jsproxy.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: #include "jsexn.h"
18989: #include "jsstaticcheck.h"
32710: #include "jstracer.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: # include "jsiter.h"
    1: #endif
    1: 
11435: #if JS_HAS_XDR
11435: # include "jsxdrapi.h"
11435: #endif
11435: 
53520: #ifdef JS_METHODJIT
53520: #include "methodjit/MethodJIT.h"
53520: #endif
53520: 
30283: #include "jsatominlines.h"
51095: #include "jsfuninlines.h"
40410: #include "jsobjinlines.h"
59968: #include "jsscriptinlines.h"
30283: 
69827: #include "vm/ArgumentsObject-inl.h"
69223: #include "vm/Stack-inl.h"
69223: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
51090: inline JSObject *
51090: JSObject::getThrowTypeError() const
51090: {
68955:     return getGlobal()->getThrowTypeError();
51090: }
51090: 
    1: JSBool
69223: js_GetArgsValue(JSContext *cx, StackFrame *fp, Value *vp)
    1: {
    1:     JSObject *argsobj;
    1: 
53840:     if (fp->hasOverriddenArgs()) {
50510:         JS_ASSERT(fp->hasCallObj());
31823:         jsid id = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
53840:         return fp->callObj().getProperty(cx, id, vp);
    1:     }
    1:     argsobj = js_GetArgsObject(cx, fp);
    1:     if (!argsobj)
    1:         return JS_FALSE;
48470:     vp->setObject(*argsobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
69223: js_GetArgsProperty(JSContext *cx, StackFrame *fp, jsid id, Value *vp)
    1: {
53840:     JS_ASSERT(fp->isFunctionFrame());
53840: 
53840:     if (fp->hasOverriddenArgs()) {
50510:         JS_ASSERT(fp->hasCallObj());
31823: 
31823:         jsid argumentsid = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
48470:         Value v;
53840:         if (!fp->callObj().getProperty(cx, argumentsid, &v))
31823:             return false;
31823: 
    1:         JSObject *obj;
48470:         if (v.isPrimitive()) {
31823:             obj = js_ValueToNonNullObject(cx, v);
    1:             if (!obj)
31823:                 return false;
    1:         } else {
48470:             obj = &v.toObject();
    1:         }
31501:         return obj->getProperty(cx, id, vp);
    1:     }
    1: 
48470:     vp->setUndefined();
    1:     if (JSID_IS_INT(id)) {
31823:         uint32 arg = uint32(JSID_TO_INT(id));
69827:         ArgumentsObject *argsobj = fp->maybeArgsObj();
51120:         if (arg < fp->numActualArgs()) {
31823:             if (argsobj) {
69827:                 const Value &v = argsobj->element(arg);
64375:                 if (v.isMagic(JS_ARGS_HOLE))
31823:                     return argsobj->getProperty(cx, id, vp);
64375:                 if (fp->functionScript()->strictModeCode) {
64375:                     *vp = v;
64375:                     return true;
64375:                 }
31823:             }
53840:             *vp = fp->canonicalActualArg(arg);
    1:         } else {
    1:             /*
    1:              * Per ECMA-262 Ed. 3, 10.1.8, last bulleted item, do not share
    1:              * storage between the formal parameter and arguments[k] for all
 4127:              * fp->argc <= k && k < fp->fun->nargs.  For example, in
    1:              *
    1:              *   function f(x) { x = 42; return arguments[0]; }
    1:              *   f();
    1:              *
    1:              * the call to f should return undefined, not 42.  If fp->argsobj
    1:              * is null at this point, as it would be in the example, return
    1:              * undefined in *vp.
    1:              */
31823:             if (argsobj)
31823:                 return argsobj->getProperty(cx, id, vp);
    1:         }
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
69827:         ArgumentsObject *argsobj = fp->maybeArgsObj();
69827:         if (argsobj && argsobj->hasOverriddenLength())
31823:             return argsobj->getProperty(cx, id, vp);
51120:         vp->setInt32(fp->numActualArgs());
    1:     }
31823:     return true;
    1: }
31823: 
69827: js::ArgumentsObject *
70296: ArgumentsObject::create(JSContext *cx, uint32 argc, JSObject &callee)
31823: {
69827:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
69827: 
40405:     JSObject *proto;
70296:     if (!js_GetClassPrototype(cx, callee.getGlobal(), JSProto_Object, &proto))
31823:         return NULL;
31823: 
69827:     JS_STATIC_ASSERT(NormalArgumentsObject::RESERVED_SLOTS == 2);
69827:     JS_STATIC_ASSERT(StrictArgumentsObject::RESERVED_SLOTS == 2);
69827:     JSObject *obj = js_NewGCObject(cx, FINALIZE_OBJECT2);
69827:     if (!obj)
40405:         return NULL;
40405: 
64242:     EmptyShape *emptyArgumentsShape = EmptyShape::getEmptyArgumentsShape(cx);
64242:     if (!emptyArgumentsShape)
64242:         return NULL;
64242:     AutoShapeRooter shapeRoot(cx, emptyArgumentsShape);
64242: 
52503:     ArgumentsData *data = (ArgumentsData *)
64560:         cx->malloc_(offsetof(ArgumentsData, slots) + argc * sizeof(Value));
52503:     if (!data)
52503:         return NULL;
52503:     SetValueRangeToUndefined(data->slots, argc);
52503: 
52503:     /* Can't fail from here on, so initialize everything in argsobj. */
69827:     obj->init(cx, callee.getFunctionPrivate()->inStrictMode()
69827:               ? &StrictArgumentsObject::jsClass
69827:               : &NormalArgumentsObject::jsClass,
70296:               proto, proto->getParent(), NULL, false);
69827:     obj->setMap(emptyArgumentsShape);
69827: 
69827:     ArgumentsObject *argsobj = obj->asArguments();
69827: 
69827:     JS_ASSERT(UINT32_MAX > (uint64(argc) << PACKED_BITS_COUNT));
69827:     argsobj->setInitialLength(argc);
69827: 
69827:     argsobj->setCalleeAndData(callee, data);
51095: 
31823:     return argsobj;
31823: }
31823: 
55479: struct STATIC_SKIP_INFERENCE PutArg
31823: {
53840:     PutArg(Value *dst) : dst(dst) {}
53840:     Value *dst;
68886:     bool operator()(uintN, Value *src) {
53840:         if (!dst->isMagic(JS_ARGS_HOLE))
53840:             *dst = *src;
53840:         ++dst;
68886:         return true;
31823:     }
53840: };
53840: 
    1: JSObject *
69223: js_GetArgsObject(JSContext *cx, StackFrame *fp)
    1: {
    1:     /*
    1:      * We must be in a function activation; the function must be lightweight
    1:      * or else fp must have a variable object.
    1:      */
53840:     JS_ASSERT_IF(fp->fun()->isHeavyweight(), fp->hasCallObj());
53840: 
69704:     while (fp->isDirectEvalOrDebuggerFrame())
53840:         fp = fp->prev();
    1: 
    1:     /* Create an arguments object for fp only if it lacks one. */
50510:     if (fp->hasArgsObj())
53840:         return &fp->argsObj();
    1: 
69827:     ArgumentsObject *argsobj =
70296:         ArgumentsObject::create(cx, fp->numActualArgs(), fp->callee());
31447:     if (!argsobj)
31823:         return argsobj;
31447: 
51097:     /*
52503:      * Strict mode functions have arguments objects that copy the initial
52503:      * actual parameter values.  It is the caller's responsibility to get the
52503:      * arguments object before any parameters are modified!  (The emitter
52503:      * ensures this by synthesizing an arguments access at the start of any
52503:      * strict mode function that contains an assignment to a parameter, or
52503:      * that calls eval.)  Non-strict mode arguments use the frame pointer to
52503:      * retrieve up-to-date parameter values.
51097:      */
52503:     if (argsobj->isStrictArguments())
69827:         fp->forEachCanonicalActualArg(PutArg(argsobj->data()->slots));
52503:     else
31452:         argsobj->setPrivate(fp);
51097: 
53840:     fp->setArgsObj(*argsobj);
    1:     return argsobj;
    1: }
    1: 
31823: void
69223: js_PutArgsObject(StackFrame *fp)
    1: {
69827:     ArgumentsObject &argsobj = fp->argsObj();
53840:     if (argsobj.isNormalArguments()) {
53840:         JS_ASSERT(argsobj.getPrivate() == fp);
69827:         fp->forEachCanonicalActualArg(PutArg(argsobj.data()->slots));
53840:         argsobj.setPrivate(NULL);
51097:     } else {
53840:         JS_ASSERT(!argsobj.getPrivate());
51097:     }
31823: }
    1: 
52503: #ifdef JS_TRACER
52503: 
    1: /*
31823:  * Traced versions of js_GetArgsObject and js_PutArgsObject.
    1:  */
31824: JSObject * JS_FASTCALL
70296: js_NewArgumentsOnTrace(JSContext *cx, uint32 argc, JSObject *callee)
31823: {
70296:     ArgumentsObject *argsobj = ArgumentsObject::create(cx, argc, *callee);
33110:     if (!argsobj)
33110:         return NULL;
51097: 
52503:     if (argsobj->isStrictArguments()) {
51097:         /*
51097:          * Strict mode callers must copy arguments into the created arguments
52503:          * object. The trace-JITting code is in TraceRecorder::newArguments.
51097:          */
51097:         JS_ASSERT(!argsobj->getPrivate());
51097:     } else {
52503:         argsobj->setPrivate(JS_ARGUMENTS_OBJECT_ON_TRACE);
51097:     }
51097: 
32709:     return argsobj;
    1: }
70296: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_NewArgumentsOnTrace, CONTEXT, UINT32, OBJECT,
49124:                      0, nanojit::ACCSET_STORE_ANY)
31823: 
31823: /* FIXME change the return type to void. */
31823: JSBool JS_FASTCALL
69827: js_PutArgumentsOnTrace(JSContext *cx, JSObject *obj, Value *argv)
31823: {
69827:     NormalArgumentsObject *argsobj = obj->asNormalArguments();
69827: 
52503:     JS_ASSERT(argsobj->getPrivate() == JS_ARGUMENTS_OBJECT_ON_TRACE);
53840: 
53840:     /*
53840:      * TraceRecorder::putActivationObjects builds a single, contiguous array of
53840:      * the arguments, regardless of whether #actuals > #formals so there is no
53840:      * need to worry about actual vs. formal arguments.
53840:      */
69827:     Value *srcend = argv + argsobj->initialLength();
69827:     Value *dst = argsobj->data()->slots;
69827:     for (Value *src = argv; src < srcend; ++src, ++dst) {
53840:         if (!dst->isMagic(JS_ARGS_HOLE))
53840:             *dst = *src;
53840:     }
53840: 
34328:     argsobj->setPrivate(NULL);
31823:     return true;
    1: }
53840: JS_DEFINE_CALLINFO_3(extern, BOOL, js_PutArgumentsOnTrace, CONTEXT, OBJECT, VALUEPTR, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
31823: 
52503: #endif /* JS_TRACER */
52503: 
    1: static JSBool
48470: args_delProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
69827:     ArgumentsObject *argsobj = obj->asArguments();
48470:     if (JSID_IS_INT(id)) {
48470:         uintN arg = uintN(JSID_TO_INT(id));
69827:         if (arg < argsobj->initialLength())
69827:             argsobj->setElement(arg, MagicValue(JS_ARGS_HOLE));
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
69827:         argsobj->markLengthOverridden();
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
69827:         argsobj->asNormalArguments()->clearCallee();
    1:     }
31447:     return true;
    1: }
    1: 
28952: static JS_REQUIRES_STACK JSObject *
69223: WrapEscapingClosure(JSContext *cx, StackFrame *fp, JSFunction *fun)
28952: {
29009:     JS_ASSERT(fun->optimizedClosure());
28952:     JS_ASSERT(!fun->u.i.wrapper);
28952: 
28952:     /*
28952:      * We do not attempt to reify Call and Block objects on demand for outer
28952:      * scopes. This could be done (see the "v8" patch in bug 494235) but it is
28952:      * fragile in the face of ongoing compile-time optimization. Instead, the
28952:      * _DBG* opcodes used by wrappers created here must cope with unresolved
28952:      * upvars and throw them as reference errors. Caveat debuggers!
28952:      */
56729:     JSObject *scopeChain = GetScopeChain(cx, fp);
28952:     if (!scopeChain)
28952:         return NULL;
28952: 
50500:     JSObject *wfunobj = NewFunction(cx, scopeChain);
28952:     if (!wfunobj)
28952:         return NULL;
48470:     AutoObjectRooter tvr(cx, wfunobj);
28952: 
28952:     JSFunction *wfun = (JSFunction *) wfunobj;
32684:     wfunobj->setPrivate(wfun);
52503:     wfun->nargs = fun->nargs;
28952:     wfun->flags = fun->flags | JSFUN_HEAVYWEIGHT;
28952:     wfun->u.i.skipmin = fun->u.i.skipmin;
28952:     wfun->u.i.wrapper = true;
28952:     wfun->u.i.script = NULL;
28952:     wfun->atom = fun->atom;
28952: 
59968:     JSScript *script = fun->script();
32723:     jssrcnote *snbase = script->notes();
28952:     jssrcnote *sn = snbase;
28952:     while (!SN_IS_TERMINATOR(sn))
28952:         sn = SN_NEXT(sn);
28952:     uintN nsrcnotes = (sn - snbase) + 1;
28952: 
28952:     /* NB: GC must not occur before wscript is homed in wfun->u.i.script. */
54840:     JSScript *wscript = JSScript::NewScript(cx, script->length, nsrcnotes,
28952:                                             script->atomMap.length,
59221:                                             JSScript::isValidOffset(script->objectsOffset)
32723:                                             ? script->objects()->length
28952:                                             : 0,
59968:                                             script->bindings.countUpvars(),
59221:                                             JSScript::isValidOffset(script->regexpsOffset)
32723:                                             ? script->regexps()->length
28952:                                             : 0,
59221:                                             JSScript::isValidOffset(script->trynotesOffset)
32723:                                             ? script->trynotes()->length
48470:                                             : 0,
59221:                                             JSScript::isValidOffset(script->constOffset)
48470:                                             ? script->consts()->length
52684:                                             : 0,
59221:                                             JSScript::isValidOffset(script->globalsOffset)
52555:                                             ? script->globals()->length
54840:                                             : 0,
54840:                                             script->nClosedArgs,
61450:                                             script->nClosedVars,
61450:                                             script->getVersion());
28952:     if (!wscript)
28952:         return NULL;
28952: 
28952:     memcpy(wscript->code, script->code, script->length);
28952:     wscript->main = wscript->code + (script->main - script->code);
28952: 
32723:     memcpy(wscript->notes(), snbase, nsrcnotes * sizeof(jssrcnote));
28952:     memcpy(wscript->atomMap.vector, script->atomMap.vector,
28952:            wscript->atomMap.length * sizeof(JSAtom *));
59221:     if (JSScript::isValidOffset(script->objectsOffset)) {
32723:         memcpy(wscript->objects()->vector, script->objects()->vector,
32723:                wscript->objects()->length * sizeof(JSObject *));
28952:     }
59221:     if (JSScript::isValidOffset(script->regexpsOffset)) {
32723:         memcpy(wscript->regexps()->vector, script->regexps()->vector,
32723:                wscript->regexps()->length * sizeof(JSObject *));
28952:     }
59221:     if (JSScript::isValidOffset(script->trynotesOffset)) {
32723:         memcpy(wscript->trynotes()->vector, script->trynotes()->vector,
32723:                wscript->trynotes()->length * sizeof(JSTryNote));
28952:     }
59221:     if (JSScript::isValidOffset(script->globalsOffset)) {
52555:         memcpy(wscript->globals()->vector, script->globals()->vector,
52555:                wscript->globals()->length * sizeof(GlobalSlotArray::Entry));
52555:     }
54840:     if (script->nClosedArgs + script->nClosedVars != 0)
54840:         script->copyClosedSlotsTo(wscript);
28952: 
59968:     if (script->bindings.hasUpvars()) {
59968:         JS_ASSERT(script->bindings.countUpvars() == wscript->upvars()->length);
32723:         memcpy(wscript->upvars()->vector, script->upvars()->vector,
59968:                script->bindings.countUpvars() * sizeof(uint32));
28952:     }
28952: 
28952:     jsbytecode *pc = wscript->code;
28952:     while (*pc != JSOP_STOP) {
52503:         /* FIXME should copy JSOP_TRAP? */
28952:         JSOp op = js_GetOpcode(cx, wscript, pc);
28952:         const JSCodeSpec *cs = &js_CodeSpec[op];
28952:         ptrdiff_t oplen = cs->length;
28952:         if (oplen < 0)
28952:             oplen = js_GetVariableBytecodeLength(pc);
28952: 
28952:         /*
53650:          * Rewrite JSOP_{GET,CALL}FCSLOT as JSOP_{GET,CALL}UPVAR_DBG for the
28952:          * case where fun is an escaping flat closure. This works because the
53650:          * UPVAR and FCSLOT ops by design have the same format: an upvar index
28952:          * immediate operand.
28952:          */
28952:         switch (op) {
52503:           case JSOP_GETFCSLOT:      *pc = JSOP_GETUPVAR_DBG; break;
52503:           case JSOP_CALLFCSLOT:     *pc = JSOP_CALLUPVAR_DBG; break;
28952:           case JSOP_DEFFUN_FC:      *pc = JSOP_DEFFUN_DBGFC; break;
28952:           case JSOP_DEFLOCALFUN_FC: *pc = JSOP_DEFLOCALFUN_DBGFC; break;
28952:           case JSOP_LAMBDA_FC:      *pc = JSOP_LAMBDA_DBGFC; break;
28952:           default:;
28952:         }
28952:         pc += oplen;
28952:     }
28952: 
28952:     /*
29009:      * Fill in the rest of wscript. This means if you add members to JSScript
29009:      * you must update this code. FIXME: factor into JSScript::clone method.
28952:      */
61450:     JS_ASSERT(wscript->getVersion() == script->getVersion());
28952:     wscript->nfixed = script->nfixed;
28952:     wscript->filename = script->filename;
28952:     wscript->lineno = script->lineno;
28952:     wscript->nslots = script->nslots;
28952:     wscript->staticLevel = script->staticLevel;
28952:     wscript->principals = script->principals;
54840:     wscript->noScriptRval = script->noScriptRval;
54840:     wscript->savedCallerFun = script->savedCallerFun;
54840:     wscript->hasSharps = script->hasSharps;
54840:     wscript->strictModeCode = script->strictModeCode;
54840:     wscript->compileAndGo = script->compileAndGo;
54840:     wscript->usesEval = script->usesEval;
54840:     wscript->usesArguments = script->usesArguments;
54840:     wscript->warnedAboutTwoArgumentEval = script->warnedAboutTwoArgumentEval;
28952:     if (wscript->principals)
28952:         JSPRINCIPALS_HOLD(cx, wscript->principals);
28952: #ifdef CHECK_SCRIPT_OWNER
28952:     wscript->owner = script->owner;
28952: #endif
28952: 
59968:     wscript->bindings.clone(cx, &script->bindings);
59968: 
28952:     /* Deoptimize wfun from FUN_{FLAT,NULL}_CLOSURE to FUN_INTERPRETED. */
28952:     FUN_SET_KIND(wfun, JSFUN_INTERPRETED);
28952:     wfun->u.i.script = wscript;
64195:     js_CallNewScriptHook(cx, wscript, wfun);
28952:     return wfunobj;
28952: }
28952: 
    1: static JSBool
48470: ArgGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
49124:     LeaveTrace(cx);
49124: 
67943:     if (!obj->isNormalArguments())
31447:         return true;
31447: 
69827:     NormalArgumentsObject *argsobj = obj->asNormalArguments();
48470:     if (JSID_IS_INT(id)) {
31447:         /*
31447:          * arg can exceed the number of arguments if a script changed the
31447:          * prototype to point to another Arguments object with a bigger argc.
31447:          */
48470:         uintN arg = uintN(JSID_TO_INT(id));
69827:         if (arg < argsobj->initialLength()) {
69827:             JS_ASSERT(!argsobj->element(arg).isMagic(JS_ARGS_HOLE));
69827:             if (StackFrame *fp = reinterpret_cast<StackFrame *>(argsobj->getPrivate()))
53840:                 *vp = fp->canonicalActualArg(arg);
55525:             else
69827:                 *vp = argsobj->element(arg);
31823:         }
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
69827:         if (!argsobj->hasOverriddenLength())
69827:             vp->setInt32(argsobj->initialLength());
31447:     } else {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
69827:         const Value &v = argsobj->callee();
48470:         if (!v.isMagic(JS_ARGS_HOLE)) {
29009:             /*
29009:              * If this function or one in it needs upvars that reach above it
29009:              * in the scope chain, it must not be a null closure (it could be a
29009:              * flat closure, or an unoptimized closure -- the latter itself not
29009:              * necessarily heavyweight). Rather than wrap here, we simply throw
29009:              * to reduce code size and tell debugger users the truth instead of
29009:              * passing off a fibbing wrapper.
29009:              */
48470:             if (GET_FUNCTION_PRIVATE(cx, &v.toObject())->needsWrapper()) {
28964:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28964:                                      JSMSG_OPTIMIZED_CLOSURE_LEAK);
31447:                 return false;
28964:             }
31823:             *vp = v;
28964:         }
    1:     }
31447:     return true;
    1: }
    1: 
    1: static JSBool
62395: ArgSetter(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
    1: {
35056: #ifdef JS_TRACER
35054:     // To be able to set a property here on trace, we would have to make
35054:     // sure any updates also get written back to the trace native stack.
35054:     // For simplicity, we just leave trace, since this is presumably not
35054:     // a common operation.
62589:     LeaveTrace(cx);
35056: #endif
35054: 
67943: 
67943:     if (!obj->isNormalArguments())
31447:         return true;
31447: 
69827:     NormalArgumentsObject *argsobj = obj->asNormalArguments();
69827: 
48470:     if (JSID_IS_INT(id)) {
48470:         uintN arg = uintN(JSID_TO_INT(id));
69827:         if (arg < argsobj->initialLength()) {
69827:             if (StackFrame *fp = reinterpret_cast<StackFrame *>(argsobj->getPrivate())) {
54844:                 JSScript *script = fp->functionScript();
54844:                 if (script->usesArguments)
53840:                     fp->canonicalActualArg(arg) = *vp;
31823:                 return true;
31823:             }
31447:         }
31447:     } else {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
48470:                   JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
31447:     }
31823: 
31823:     /*
62073:      * For simplicity we use delete/define to replace the property with one
51095:      * backed by the default Object getter and setter. Note that we rely on
51095:      * args_delProperty to clear the corresponding reserved slot so the GC can
62073:      * collect its value. Note also that we must define the property instead
62073:      * of setting it in case the user has changed the prototype to an object
62073:      * that has a setter for this id.
31823:      */
40389:     AutoValueRooter tvr(cx);
69827:     return js_DeleteProperty(cx, argsobj, id, tvr.addr(), false) &&
69827:            js_DefineProperty(cx, argsobj, id, vp, NULL, NULL, JSPROP_ENUMERATE);
31447: }
31447: 
31447: static JSBool
48470: args_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
31447:              JSObject **objp)
31447: {
31447:     *objp = NULL;
59898: 
69827:     NormalArgumentsObject *argsobj = obj->asNormalArguments();
69827: 
59898:     uintN attrs = JSPROP_SHARED | JSPROP_SHADOWABLE;
48470:     if (JSID_IS_INT(id)) {
48470:         uint32 arg = uint32(JSID_TO_INT(id));
69827:         if (arg >= argsobj->initialLength() || argsobj->element(arg).isMagic(JS_ARGS_HOLE))
59898:             return true;
59898: 
59898:         attrs |= JSPROP_ENUMERATE;
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
69827:         if (argsobj->hasOverriddenLength())
59898:             return true;
59898:     } else {
59898:         if (!JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom))
59898:             return true;
59898: 
69827:         if (argsobj->callee().isMagic(JS_ARGS_HOLE))
59898:             return true;
31447:     }
31823: 
59898:     Value undef = UndefinedValue();
69827:     if (!js_DefineProperty(cx, argsobj, id, &undef, ArgGetter, ArgSetter, attrs))
31823:         return JS_FALSE;
59898: 
69827:     *objp = argsobj;
31447:     return true;
31447: }
31447: 
31447: static JSBool
31447: args_enumerate(JSContext *cx, JSObject *obj)
31447: {
69827:     NormalArgumentsObject *argsobj = obj->asNormalArguments();
31447: 
    1:     /*
31823:      * Trigger reflection in args_resolve using a series of js_LookupProperty
31823:      * calls.
    1:      */
69827:     int argc = int(argsobj->initialLength());
31447:     for (int i = -2; i != argc; i++) {
31447:         jsid id = (i == -2)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)
31447:                   : (i == -1)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.calleeAtom)
48470:                   : INT_TO_JSID(i);
31447: 
31447:         JSObject *pobj;
31447:         JSProperty *prop;
69827:         if (!js_LookupProperty(cx, argsobj, id, &pobj, &prop))
31447:             return false;
    1:     }
31447:     return true;
    1: }
    1: 
56593: static JSBool
51095: StrictArgGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
51095: {
51095:     LeaveTrace(cx);
51095: 
67943:     if (!obj->isStrictArguments())
51095:         return true;
51095: 
69827:     StrictArgumentsObject *argsobj = obj->asStrictArguments();
69827: 
51095:     if (JSID_IS_INT(id)) {
51095:         /*
51095:          * arg can exceed the number of arguments if a script changed the
51095:          * prototype to point to another Arguments object with a bigger argc.
51095:          */
51095:         uintN arg = uintN(JSID_TO_INT(id));
69827:         if (arg < argsobj->initialLength()) {
69827:             const Value &v = argsobj->element(arg);
51095:             if (!v.isMagic(JS_ARGS_HOLE))
51095:                 *vp = v;
51095:         }
51095:     } else {
51095:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
69827:         if (!argsobj->hasOverriddenLength())
69827:             vp->setInt32(argsobj->initialLength());
51095:     }
51095:     return true;
51095: }
51095: 
56593: static JSBool
62395: 
62395: StrictArgSetter(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
51095: {
67943:     if (!obj->isStrictArguments())
51095:         return true;
51095: 
69827:     StrictArgumentsObject *argsobj = obj->asStrictArguments();
69827: 
51095:     if (JSID_IS_INT(id)) {
51095:         uintN arg = uintN(JSID_TO_INT(id));
69827:         if (arg < argsobj->initialLength()) {
69827:             argsobj->setElement(arg, *vp);
51095:             return true;
51095:         }
51095:     } else {
51095:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
51095:     }
51095: 
51095:     /*
51095:      * For simplicity we use delete/set to replace the property with one
51095:      * backed by the default Object getter and setter. Note that we rely on
51095:      * args_delProperty to clear the corresponding reserved slot so the GC can
51095:      * collect its value.
51095:      */
51095:     AutoValueRooter tvr(cx);
69827:     return js_DeleteProperty(cx, argsobj, id, tvr.addr(), strict) &&
69827:            js_SetProperty(cx, argsobj, id, vp, strict);
51095: }
51095: 
56593: static JSBool
51095: strictargs_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp)
51095: {
51095:     *objp = NULL;
59898: 
69827:     StrictArgumentsObject *argsobj = obj->asStrictArguments();
69827: 
59898:     uintN attrs = JSPROP_SHARED | JSPROP_SHADOWABLE;
59898:     PropertyOp getter = StrictArgGetter;
62395:     StrictPropertyOp setter = StrictArgSetter;
59898: 
51095:     if (JSID_IS_INT(id)) {
51095:         uint32 arg = uint32(JSID_TO_INT(id));
69827:         if (arg >= argsobj->initialLength() || argsobj->element(arg).isMagic(JS_ARGS_HOLE))
59898:             return true;
59898: 
59898:         attrs |= JSPROP_ENUMERATE;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
69827:         if (argsobj->hasOverriddenLength())
51095:             return true;
59898:     } else {
59898:         if (!JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom) &&
59898:             !JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom)) {
51095:             return true;
51095:         }
51095: 
59898:         attrs = JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED;
69827:         getter = CastAsPropertyOp(argsobj->getThrowTypeError());
69827:         setter = CastAsStrictPropertyOp(argsobj->getThrowTypeError());
59898:     }
59898: 
59898:     Value undef = UndefinedValue();
69827:     if (!js_DefineProperty(cx, argsobj, id, &undef, getter, setter, attrs))
51099:         return false;
59898: 
69827:     *objp = argsobj;
51095:     return true;
51095: }
51095: 
56593: static JSBool
51095: strictargs_enumerate(JSContext *cx, JSObject *obj)
51095: {
69827:     StrictArgumentsObject *argsobj = obj->asStrictArguments();
51095: 
51095:     /*
51095:      * Trigger reflection in strictargs_resolve using a series of
56567:      * js_LookupProperty calls.
51095:      */
51095:     JSObject *pobj;
51095:     JSProperty *prop;
51095: 
51095:     // length
69827:     if (!js_LookupProperty(cx, argsobj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), &pobj, &prop))
51095:         return false;
51095: 
51095:     // callee
69827:     if (!js_LookupProperty(cx, argsobj, ATOM_TO_JSID(cx->runtime->atomState.calleeAtom), &pobj, &prop))
51095:         return false;
51095: 
51095:     // caller
69827:     if (!js_LookupProperty(cx, argsobj, ATOM_TO_JSID(cx->runtime->atomState.callerAtom), &pobj, &prop))
51095:         return false;
51095: 
69827:     for (uint32 i = 0, argc = argsobj->initialLength(); i < argc; i++) {
69827:         if (!js_LookupProperty(cx, argsobj, INT_TO_JSID(i), &pobj, &prop))
51095:             return false;
51095:     }
51095: 
51095:     return true;
51095: }
51095: 
52503: static void
52503: args_finalize(JSContext *cx, JSObject *obj)
52503: {
69827:     cx->free_(reinterpret_cast<void *>(obj->asArguments()->data()));
52503: }
52503: 
    1: /*
42714:  * If a generator's arguments or call object escapes, and the generator frame
42714:  * is not executing, the generator object needs to be marked because it is not
42714:  * otherwise reachable. An executing generator is rooted by its invocation.  To
42714:  * distinguish the two cases (which imply different access paths to the
42714:  * generator object), we use the JSFRAME_FLOATING_GENERATOR flag, which is only
69223:  * set on the StackFrame kept in the generator object's JSGenerator.
    1:  */
52503: static inline void
52503: MaybeMarkGenerator(JSTracer *trc, JSObject *obj)
    1: {
52503: #if JS_HAS_GENERATORS
69223:     StackFrame *fp = (StackFrame *) obj->getPrivate();
42714:     if (fp && fp->isFloatingGenerator()) {
52503:         JSObject *genobj = js_FloatingFrameToGenerator(fp)->obj;
53840:         MarkObject(trc, *genobj, "generator object");
  583:     }
52503: #endif
    1: }
52503: 
52503: static void
52503: args_trace(JSTracer *trc, JSObject *obj)
52503: {
69827:     ArgumentsObject *argsobj = obj->asArguments();
69827:     if (argsobj->getPrivate() == JS_ARGUMENTS_OBJECT_ON_TRACE) {
69827:         JS_ASSERT(!argsobj->isStrictArguments());
52503:         return;
52503:     }
52503: 
69827:     ArgumentsData *data = argsobj->data();
52503:     if (data->callee.isObject())
53840:         MarkObject(trc, data->callee.toObject(), js_callee_str);
69827:     MarkValueRange(trc, argsobj->initialLength(), data->slots, js_arguments_str);
69827: 
69827:     MaybeMarkGenerator(trc, argsobj);
52503: }
    1: 
69827: namespace js {
69827: 
    1: /*
69827:  * The classes below collaborate to lazily reflect and synchronize actual
69827:  * argument values, argument count, and callee function object stored in a
69827:  * StackFrame with their corresponding property values in the frame's
    1:  * arguments object.
    1:  */
69827: Class NormalArgumentsObject::jsClass = {
48462:     "Arguments",
31823:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
69827:     JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) |
64218:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,         /* addProperty */
48622:     args_delProperty,
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     args_enumerate,
69827:     reinterpret_cast<JSResolveOp>(args_resolve),
48622:     ConvertStub,
52503:     args_finalize,        /* finalize   */
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
64218:     args_trace
    1: };
    1: 
51095: /*
51095:  * Strict mode arguments is significantly less magical than non-strict mode
51095:  * arguments, so it is represented by a different class while sharing some
51095:  * functionality.
51095:  */
69827: Class StrictArgumentsObject::jsClass = {
51095:     "Arguments",
51095:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
69827:     JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) |
64218:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
51095:     PropertyStub,         /* addProperty */
51095:     args_delProperty,
51095:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
51095:     strictargs_enumerate,
51095:     reinterpret_cast<JSResolveOp>(strictargs_resolve),
51095:     ConvertStub,
52503:     args_finalize,        /* finalize   */
51095:     NULL,                 /* reserved0   */
51095:     NULL,                 /* checkAccess */
51095:     NULL,                 /* call        */
51095:     NULL,                 /* construct   */
51095:     NULL,                 /* xdrObject   */
51095:     NULL,                 /* hasInstance */
64218:     args_trace
51095: };
51095: 
51095: }
51095: 
28952: /*
69223:  * A Declarative Environment object stores its active StackFrame pointer in
28952:  * its private slot, just as Call and Arguments objects do.
28952:  */
48470: Class js_DeclEnvClass = {
27319:     js_Object_str,
28952:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
27319: };
27319: 
29888: static JSBool
48470: CheckForEscapingClosure(JSContext *cx, JSObject *obj, Value *vp)
28952: {
52503:     JS_ASSERT(obj->isCall() || obj->getClass() == &js_DeclEnvClass);
28952: 
48470:     const Value &v = *vp;
48470: 
48470:     JSObject *funobj;
48470:     if (IsFunctionObject(v, &funobj)) {
28952:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
28952: 
28952:         /*
28952:          * Any escaping null or flat closure that reaches above itself or
28952:          * contains nested functions that reach above it must be wrapped.
28952:          * We can wrap only when this Call or Declarative Environment obj
28952:          * still has an active stack frame associated with it.
28952:          */
29009:         if (fun->needsWrapper()) {
37741:             LeaveTrace(cx);
29888: 
69223:             StackFrame *fp = (StackFrame *) obj->getPrivate();
28952:             if (fp) {
50500:                 JSObject *wrapper = WrapEscapingClosure(cx, fp, fun);
28952:                 if (!wrapper)
28952:                     return false;
48470:                 vp->setObject(*wrapper);
28952:                 return true;
28952:             }
28952: 
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_OPTIMIZED_CLOSURE_LEAK);
28952:             return false;
28952:         }
28952:     }
28952:     return true;
28952: }
28952: 
29888: static JSBool
48470: CalleeGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
28952: {
28952:     return CheckForEscapingClosure(cx, obj, vp);
28952: }
28952: 
60146: /*
64364:  * Construct a call object for the given bindings.  If this is a call object
64364:  * for a function invocation, callee should be the function being called.
64364:  * Otherwise it must be a call object for eval of strict mode code, and callee
64364:  * must be null.
60146:  */
64364: static JSObject *
64364: NewCallObject(JSContext *cx, JSScript *script, JSObject &scopeChain, JSObject *callee)
37694: {
64364:     Bindings &bindings = script->bindings;
64364:     size_t argsVars = bindings.countArgsAndVars();
59968:     size_t slots = JSObject::CALL_RESERVED_SLOTS + argsVars;
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(slots);
55746: 
55746:     JSObject *callobj = js_NewGCObject(cx, kind);
43221:     if (!callobj)
37694:         return NULL;
43221: 
55746:     /* Init immediately to avoid GC seeing a half-init'ed object. */
64296:     callobj->initCall(cx, bindings, &scopeChain);
52503: 
52503:     /* This must come after callobj->lastProp has been set. */
59968:     if (!callobj->ensureInstanceReservedSlots(cx, argsVars))
43221:         return NULL;
52503: 
52503: #ifdef DEBUG
52503:     for (Shape::Range r = callobj->lastProp; !r.empty(); r.popFront()) {
52503:         const Shape &s = r.front();
52503:         if (s.slot != SHAPE_INVALID_SLOT) {
53652:             JS_ASSERT(s.slot + 1 == callobj->slotSpan());
52503:             break;
52503:         }
52503:     }
52503: #endif
53840: 
53840:     callobj->setCallObjCallee(callee);
37694:     return callobj;
37694: }
37694: 
47497: static inline JSObject *
69223: NewDeclEnvObject(JSContext *cx, StackFrame *fp)
47497: {
55746:     JSObject *envobj = js_NewGCObject(cx, FINALIZE_OBJECT2);
47497:     if (!envobj)
47497:         return NULL;
47497: 
64242:     EmptyShape *emptyDeclEnvShape = EmptyShape::getEmptyDeclEnvShape(cx);
64242:     if (!emptyDeclEnvShape)
64242:         return NULL;
64242: 
55746:     envobj->init(cx, &js_DeclEnvClass, NULL, &fp->scopeChain(), fp, false);
64242:     envobj->setMap(emptyDeclEnvShape);
47497:     return envobj;
47497: }
47497: 
64364: namespace js {
64364: 
    1: JSObject *
69223: CreateFunCallObject(JSContext *cx, StackFrame *fp)
    1: {
64364:     JS_ASSERT(fp->isNonEvalFunctionFrame());
64364:     JS_ASSERT(!fp->hasCallObj());
64364: 
64364:     JSObject *scopeChain = &fp->scopeChain();
64364:     JS_ASSERT_IF(scopeChain->isWith() || scopeChain->isBlock() || scopeChain->isCall(),
64364:                  scopeChain->getPrivate() != fp);
    1: 
25217:     /*
64364:      * For a named function expression Call's parent points to an environment
64364:      * object holding function's name.
25217:      */
64364:     if (JSAtom *lambdaName = (fp->fun()->flags & JSFUN_LAMBDA) ? fp->fun()->atom : NULL) {
64364:         scopeChain = NewDeclEnvObject(cx, fp);
64364:         if (!scopeChain)
27660:             return NULL;
47497: 
69855:         if (!DefineNativeProperty(cx, scopeChain, ATOM_TO_JSID(lambdaName),
69855:                                   ObjectValue(fp->callee()), CalleeGetter, NULL,
69855:                                   JSPROP_PERMANENT | JSPROP_READONLY, 0, 0)) {
28312:             return NULL;
28312:         }
27319:     }
27539: 
64364:     JSObject *callobj = NewCallObject(cx, fp->script(), *scopeChain, &fp->callee());
37694:     if (!callobj)
    1:         return NULL;
15588: 
31452:     callobj->setPrivate(fp);
64364:     fp->setScopeChainWithOwnCallObj(*callobj);
    1:     return callobj;
    1: }
    1: 
64364: JSObject *
69223: CreateEvalCallObject(JSContext *cx, StackFrame *fp)
64364: {
64364:     JSObject *callobj = NewCallObject(cx, fp->script(), fp->scopeChain(), NULL);
64364:     if (!callobj)
68902:         return NULL;
64364: 
64364:     callobj->setPrivate(fp);
64364:     fp->setScopeChainWithOwnCallObj(*callobj);
64364:     return callobj;
64364: }
64364: 
64364: } // namespace js
64364: 
37694: JSObject * JS_FASTCALL
37694: js_CreateCallObjectOnTrace(JSContext *cx, JSFunction *fun, JSObject *callee, JSObject *scopeChain)
37694: {
37694:     JS_ASSERT(!js_IsNamedLambda(fun));
53840:     JS_ASSERT(scopeChain);
60146:     JS_ASSERT(callee);
64364:     return NewCallObject(cx, fun->script(), *scopeChain, callee);
37694: }
37694: 
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CreateCallObjectOnTrace, CONTEXT, FUNCTION, OBJECT, OBJECT,
48613:                      0, nanojit::ACCSET_STORE_ANY)
37694: 
37694: inline static void
53840: CopyValuesToCallObject(JSObject &callobj, uintN nargs, Value *argv, uintN nvars, Value *slots)
37694: {
55746:     JS_ASSERT(callobj.numSlots() >= JSObject::CALL_RESERVED_SLOTS + nargs + nvars);
55746:     Value *base = callobj.getSlots() + JSObject::CALL_RESERVED_SLOTS;
55746:     memcpy(base, argv, nargs * sizeof(Value));
55746:     memcpy(base + nargs, slots, nvars * sizeof(Value));
37694: }
37694: 
31823: void
69223: js_PutCallObject(StackFrame *fp)
    1: {
53840:     JSObject &callobj = fp->callObj();
64364:     JS_ASSERT(callobj.getPrivate() == fp);
64364:     JS_ASSERT_IF(fp->isEvalFrame(), fp->isStrictEvalFrame());
60243:     JS_ASSERT(fp->isEvalFrame() == callobj.callIsForEval());
60243: 
31823:     /* Get the arguments object to snapshot fp's actual argument values. */
50510:     if (fp->hasArgsObj()) {
53840:         if (!fp->hasOverriddenArgs())
53840:             callobj.setCallObjArguments(ObjectValue(fp->argsObj()));
69223:         js_PutArgsObject(fp);
31447:     }
31447: 
60242:     JSScript *script = fp->script();
60242:     Bindings &bindings = script->bindings;
60242: 
60243:     if (callobj.callIsForEval()) {
60243:         JS_ASSERT(script->strictModeCode);
60243:         JS_ASSERT(bindings.countArgs() == 0);
60243: 
60243:         /* This could be optimized as below, but keep it simple for now. */
60243:         CopyValuesToCallObject(callobj, 0, NULL, bindings.countVars(), fp->slots());
60243:     } else {
53840:         JSFunction *fun = fp->fun();
60243:         JS_ASSERT(fun == callobj.getCallObjCalleeFunction());
60242:         JS_ASSERT(script == fun->script());
60242: 
60546:         uintN n = bindings.countArgsAndVars();
60546:         if (n > 0) {
60242:             JS_ASSERT(JSObject::CALL_RESERVED_SLOTS + n <= callobj.numSlots());
53840: 
59968:             uint32 nvars = bindings.countVars();
59968:             uint32 nargs = bindings.countArgs();
59968:             JS_ASSERT(fun->nargs == nargs);
59968:             JS_ASSERT(nvars + nargs == n);
59968: 
59968:             JSScript *script = fun->script();
54897:             if (script->usesEval
54897: #ifdef JS_METHODJIT
54897:                 || script->debugMode
54897: #endif
54897:                 ) {
54840:                 CopyValuesToCallObject(callobj, nargs, fp->formalArgs(), nvars, fp->slots());
54840:             } else {
54840:                 /*
54840:                  * For each arg & var that is closed over, copy it from the stack
54840:                  * into the call object.
54840:                  */
54840:                 uint32 nclosed = script->nClosedArgs;
54840:                 for (uint32 i = 0; i < nclosed; i++) {
54840:                     uint32 e = script->getClosedArg(i);
55746:                     callobj.setSlot(JSObject::CALL_RESERVED_SLOTS + e, fp->formalArg(e));
54840:                 }
54840: 
54840:                 nclosed = script->nClosedVars;
54840:                 for (uint32 i = 0; i < nclosed; i++) {
54840:                     uint32 e = script->getClosedVar(i);
55746:                     callobj.setSlot(JSObject::CALL_RESERVED_SLOTS + nargs + e, fp->slots()[e]);
53520:                 }
53520:             }
15588:         }
30732: 
30732:         /* Clear private pointers to fp, which is about to go away (js_Invoke). */
37694:         if (js_IsNamedLambda(fun)) {
53840:             JSObject *env = callobj.getParent();
28952: 
40410:             JS_ASSERT(env->getClass() == &js_DeclEnvClass);
32684:             JS_ASSERT(env->getPrivate() == fp);
31452:             env->setPrivate(NULL);
28952:         }
60242:     }
28952: 
53840:     callobj.setPrivate(NULL);
    1: }
    1: 
37694: JSBool JS_FASTCALL
69223: js_PutCallObjectOnTrace(JSObject *callobj, uint32 nargs, Value *argv,
48470:                         uint32 nvars, Value *slots)
37694: {
53840:     JS_ASSERT(callobj->isCall());
53840:     JS_ASSERT(!callobj->getPrivate());
37694: 
37694:     uintN n = nargs + nvars;
37694:     if (n != 0)
53840:         CopyValuesToCallObject(*callobj, nargs, argv, nvars, slots);
37694: 
37694:     return true;
37694: }
37694: 
69223: JS_DEFINE_CALLINFO_5(extern, BOOL, js_PutCallObjectOnTrace, OBJECT, UINT32, VALUEPTR,
48613:                      UINT32, VALUEPTR, 0, nanojit::ACCSET_STORE_ANY)
37694: 
59969: namespace js {
13706: 
13706: static JSBool
59969: GetCallArguments(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
69223:     StackFrame *fp = obj->maybeCallObjStackFrame();
53840:     if (fp && !fp->hasOverriddenArgs()) {
59969:         JSObject *argsobj = js_GetArgsObject(cx, fp);
13706:         if (!argsobj)
39916:             return false;
48470:         vp->setObject(*argsobj);
15588:     } else {
53840:         *vp = obj->getCallObjArguments();
15588:     }
39916:     return true;
13706: }
13706: 
13706: static JSBool
62395: SetCallArguments(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
13706: {
69223:     if (StackFrame *fp = obj->maybeCallObjStackFrame())
59969:         fp->setOverriddenArgs();
59969:     obj->setCallObjArguments(*vp);
59969:     return true;
13706: }
13706: 
13706: JSBool
58293: GetCallArg(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
59969:     JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
59969:     uintN i = (uint16) JSID_TO_INT(id);
59969: 
69223:     if (StackFrame *fp = obj->maybeCallObjStackFrame())
59969:         *vp = fp->formalArg(i);
59969:     else
59969:         *vp = obj->callObjArg(i);
59969:     return true;
13706: }
13706: 
30848: JSBool
62395: SetCallArg(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
13706: {
59969:     JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
59969:     uintN i = (uint16) JSID_TO_INT(id);
59969: 
59969:     Value *argp;
69223:     if (StackFrame *fp = obj->maybeCallObjStackFrame())
59969:         argp = &fp->formalArg(i);
59969:     else
59969:         argp = &obj->callObjArg(i);
59969: 
59969:     GC_POKE(cx, *argp);
59969:     *argp = *vp;
59969:     return true;
39916: }
39916: 
39916: JSBool
60254: GetCallUpvar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
39916: {
59969:     JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
59969:     uintN i = (uint16) JSID_TO_INT(id);
59969: 
60254:     *vp = obj->getCallObjCallee()->getFlatClosureUpvar(i);
59969:     return true;
39916: }
39916: 
39916: JSBool
62395: SetCallUpvar(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
39916: {
59969:     JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
59969:     uintN i = (uint16) JSID_TO_INT(id);
59969: 
60254:     Value *up = &obj->getCallObjCallee()->getFlatClosureUpvar(i);
60254: 
60254:     GC_POKE(cx, *up);
60254:     *up = *vp;
59969:     return true;
13706: }
13706: 
13706: JSBool
58293: GetCallVar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
59969:     JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
59969:     uintN i = (uint16) JSID_TO_INT(id);
59969: 
69223:     if (StackFrame *fp = obj->maybeCallObjStackFrame())
59969:         *vp = fp->varSlot(i);
59969:     else
59969:         *vp = obj->callObjVar(i);
59969: 
59969:     return true;
29009: }
29009: 
29009: JSBool
58293: GetCallVarChecked(JSContext *cx, JSObject *obj, jsid id, Value *vp)
29009: {
59969:     if (!GetCallVar(cx, obj, id, vp))
39916:         return false;
28952: 
28952:     return CheckForEscapingClosure(cx, obj, vp);
13706: }
13706: 
30848: JSBool
62395: SetCallVar(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
13706: {
59969:     JS_ASSERT(obj->isCall());
59969: 
59969:     JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
59969:     uintN i = (uint16) JSID_TO_INT(id);
59969: 
60159:     /*
60159:      * As documented in TraceRecorder::attemptTreeCall(), when recording an
60159:      * inner tree call, the recorder assumes the inner tree does not mutate
60159:      * any tracked upvars. The abort here is a pessimistic precaution against
60159:      * bug 620662, where an inner tree setting a closed stack variable in an
60159:      * outer tree is illegal, and runtime would fall off trace.
60159:      */
60159: #ifdef JS_TRACER
62033:     if (JS_ON_TRACE(cx)) {
62033:         TraceMonitor *tm = JS_TRACE_MONITOR_ON_TRACE(cx);
60159:         if (tm->recorder && tm->tracecx)
60159:             AbortRecording(cx, "upvar write in nested tree");
62033:     }
60159: #endif
60159: 
59969:     Value *varp;
69223:     if (StackFrame *fp = obj->maybeCallObjStackFrame())
59969:         varp = &fp->varSlot(i);
59969:     else
59969:         varp = &obj->callObjVar(i);
59969: 
59969:     GC_POKE(cx, *varp);
59969:     *varp = *vp;
59969:     return true;
13706: }
13706: 
58293: } // namespace js
58293: 
48470: #if JS_TRACER
30848: JSBool JS_FASTCALL
48470: js_SetCallArg(JSContext *cx, JSObject *obj, jsid slotid, ValueArgType arg)
30848: {
48470:     Value argcopy = ValueArgToConstRef(arg);
62395:     return SetCallArg(cx, obj, slotid, false /* STRICT DUMMY */, &argcopy);
30848: }
48470: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallArg, CONTEXT, OBJECT, JSID, VALUE, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
30848: 
30848: JSBool JS_FASTCALL
48470: js_SetCallVar(JSContext *cx, JSObject *obj, jsid slotid, ValueArgType arg)
30848: {
48470:     Value argcopy = ValueArgToConstRef(arg);
62395:     return SetCallVar(cx, obj, slotid, false /* STRICT DUMMY */, &argcopy);
30848: }
48470: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallVar, CONTEXT, OBJECT, JSID, VALUE, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
48470: #endif
30848: 
 3624: static JSBool
48470: call_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:              JSObject **objp)
    1: {
52503:     JS_ASSERT(obj->isCall());
39928:     JS_ASSERT(!obj->getProto());
28397: 
48470:     if (!JSID_IS_ATOM(id))
60146:         return true;
60146: 
60146:     JSObject *callee = obj->getCallObjCallee();
60146: #ifdef DEBUG
60146:     if (callee) {
60146:         JSScript *script = callee->getFunctionPrivate()->script();
60146:         JS_ASSERT(!script->bindings.hasBinding(cx, JSID_TO_ATOM(id)));
60146:     }
60146: #endif
 3624: 
 3624:     /*
 3624:      * Resolve arguments so that we never store a particular Call object's
 3624:      * arguments object reference in a Call prototype's |arguments| slot.
55563:      *
55563:      * Include JSPROP_ENUMERATE for consistency with all other Call object
59968:      * properties; see js::Bindings::add and js::Interpret's JSOP_DEFFUN
55563:      * rebinding-Call-property logic.
 3624:      */
60146:     if (callee && id == ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom)) {
69855:         if (!DefineNativeProperty(cx, obj, id, UndefinedValue(),
13706:                                   GetCallArguments, SetCallArguments,
55563:                                   JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE,
69855:                                   0, 0, DNP_DONT_PURGE)) {
60146:             return false;
 3624:         }
 3624:         *objp = obj;
60146:         return true;
 2464:     }
27012: 
27012:     /* Control flow reaches here only if id was not resolved. */
60146:     return true;
    1: }
    1: 
52503: static void
52503: call_trace(JSTracer *trc, JSObject *obj)
52503: {
52503:     JS_ASSERT(obj->isCall());
69223:     if (StackFrame *fp = obj->maybeCallObjStackFrame()) {
53859:         /*
53859:          * FIXME: Hide copies of stack values rooted by fp from the Cycle
53859:          * Collector, which currently lacks a non-stub Unlink implementation
53859:          * for JS objects (including Call objects), so is unable to collect
53859:          * cycles involving Call objects whose frames are active without this
53859:          * hiding hack.
53859:          */
55746:         uintN first = JSObject::CALL_RESERVED_SLOTS;
60242:         uintN count = fp->script()->bindings.countArgsAndVars();
55746: 
55746:         JS_ASSERT(obj->numSlots() >= first + count);
55746:         SetValueRangeToUndefined(obj->getSlots() + first, count);
53859:     }
52503: 
52503:     MaybeMarkGenerator(trc, obj);
52503: }
52503: 
48470: JS_PUBLIC_DATA(Class) js_CallClass = {
27539:     "Call",
15588:     JSCLASS_HAS_PRIVATE |
53840:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::CALL_RESERVED_SLOTS) |
64218:     JSCLASS_NEW_RESOLVE | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
52503:     JS_EnumerateStub,
48622:     (JSResolveOp)call_resolve,
56604:     NULL,                 /* convert: Leave it NULL so we notice if calls ever escape */
48622:     NULL,                 /* finalize */
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
64218:     call_trace
    1: };
    1: 
48676: bool
69223: StackFrame::getValidCalleeObject(JSContext *cx, Value *vp)
48676: {
53840:     if (!isFunctionFrame()) {
53840:         vp->setUndefined();
48676:         return true;
48676:     }
48676: 
53840:     JSFunction *fun = this->fun();
51056: 
48676:     /*
52503:      * See the equivalent condition in ArgGetter for the 'callee' id case, but
48676:      * note that here we do not want to throw, since this escape can happen via
48676:      * a foo.caller reference alone, without any debugger or indirect eval. And
48676:      * alas, it seems foo.caller is still used on the Web.
48676:      */
48676:     if (fun->needsWrapper()) {
50500:         JSObject *wrapper = WrapEscapingClosure(cx, this, fun);
48676:         if (!wrapper)
48676:             return false;
48676:         vp->setObject(*wrapper);
48676:         return true;
48676:     }
48676: 
53840:     JSObject &funobj = callee();
53840:     vp->setObject(funobj);
48676: 
48676:     /*
48676:      * Check for an escape attempt by a joined function object, which must go
48676:      * through the frame's |this| object's method read barrier for the method
48676:      * atom by which it was uniquely associated with a property.
48676:      */
53840:     const Value &thisv = functionThis();
53840:     if (thisv.isObject()) {
53840:         JS_ASSERT(funobj.getFunctionPrivate() == fun);
53840: 
68893:         if (fun->compiledFunObj() == funobj && fun->methodAtom()) {
53840:             JSObject *thisp = &thisv.toObject();
60172:             JSObject *first_barriered_thisp = NULL;
60172: 
60172:             do {
60172:                 /*
60172:                  * While a non-native object is responsible for handling its
60172:                  * entire prototype chain, notable non-natives including dense
60172:                  * and typed arrays have native prototypes, so keep going.
60172:                  */
60172:                 if (!thisp->isNative())
60172:                     continue;
59995: 
59995:                 if (thisp->hasMethodBarrier()) {
59995:                     const Shape *shape = thisp->nativeLookup(ATOM_TO_JSID(fun->methodAtom()));
60172:                     if (shape) {
59994:                         /*
60172:                          * Two cases follow: the method barrier was not crossed
60172:                          * yet, so we cross it here; the method barrier *was*
60172:                          * crossed but after the call, in which case we fetch
60172:                          * and validate the cloned (unjoined) funobj from the
60172:                          * method property's slot.
59995:                          *
60172:                          * In either case we must allow for the method property
60172:                          * to have been replaced, or its value overwritten.
59994:                          */
68893:                         if (shape->isMethod() && shape->methodObject() == funobj) {
52503:                             if (!thisp->methodReadBarrier(cx, *shape, vp))
48676:                                 return false;
68893:                             calleev().setObject(vp->toObject());
48676:                             return true;
48676:                         }
60172: 
52503:                         if (shape->hasSlot()) {
52503:                             Value v = thisp->getSlot(shape->slot);
48676:                             JSObject *clone;
48676: 
48676:                             if (IsFunctionObject(v, &clone) &&
48676:                                 GET_FUNCTION_PRIVATE(cx, clone) == fun &&
48676:                                 clone->hasMethodObj(*thisp)) {
53840:                                 JS_ASSERT(clone != &funobj);
48676:                                 *vp = v;
68893:                                 calleev().setObject(*clone);
48676:                                 return true;
48676:                             }
48676:                         }
59995:                     }
48676: 
60172:                     if (!first_barriered_thisp)
60172:                         first_barriered_thisp = thisp;
60172:                 }
60172:             } while ((thisp = thisp->getProto()) != NULL);
60172: 
60172:             if (!first_barriered_thisp)
60172:                 return true;
60172: 
48676:             /*
60172:              * At this point, we couldn't find an already-existing clone (or
60172:              * force to exist a fresh clone) created via thisp's method read
60172:              * barrier, so we must clone fun and store it in fp's callee to
60172:              * avoid re-cloning upon repeated foo.caller access.
60172:              *
60172:              * This must mean the code in js_DeleteProperty could not find this
60172:              * stack frame on the stack when the method was deleted. We've lost
60172:              * track of the method, so we associate it with the first barriered
60172:              * object found starting from thisp on the prototype chain.
48676:              */
53840:             JSObject *newfunobj = CloneFunctionObject(cx, fun, fun->getParent());
53840:             if (!newfunobj)
48676:                 return false;
60172:             newfunobj->setMethodObj(*first_barriered_thisp);
68893:             calleev().setObject(*newfunobj);
60172:             vp->setObject(*newfunobj);
48676:             return true;
48676:         }
48676:     }
48676: 
48676:     return true;
48676: }
48676: 
31823: /* Generic function tinyids. */
31823: enum {
31823:     FUN_ARGUMENTS   = -1,       /* predefined arguments local variable */
31823:     FUN_LENGTH      = -2,       /* number of actual args, arity if inactive */
31823:     FUN_ARITY       = -3,       /* number of formal parameters; desired argc */
31823:     FUN_NAME        = -4,       /* function name, "" if anonymous */
31823:     FUN_CALLER      = -5        /* Function.prototype.caller, backward compat */
31823: };
31823: 
    1: static JSBool
48470: fun_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
48470:     if (!JSID_IS_INT(id))
48676:         return true;
43287: 
48470:     jsint slot = JSID_TO_INT(id);
    1: 
    1:     /*
    1:      * Loop because getter and setter can be delegated from another class,
31823:      * but loop only for FUN_LENGTH because we must pretend that f.length
    1:      * is in each function instance f, per ECMA-262, instead of only in the
    1:      * Function.prototype object (we use JSPROP_PERMANENT with JSPROP_SHARED
    1:      * to make it appear so).
    1:      *
51090:      * This code couples tightly to the attributes for lazyFunctionDataProps[]
51090:      * and poisonPillProps[] initializers below, and to js_SetProperty and
51090:      * js_HasOwnProperty.
    1:      *
    1:      * It's important to allow delegating objects, even though they inherit
    1:      * this getter (fun_getProperty), to override arguments, arity, caller,
31823:      * and name.  If we didn't return early for slot != FUN_LENGTH, we would
    1:      * clobber *vp with the native property value, instead of letting script
    1:      * override that value in delegating objects.
    1:      *
    1:      * Note how that clobbering is what simulates JSPROP_READONLY for all of
    1:      * the non-standard properties when the directly addressed object (obj)
    1:      * is a function object (i.e., when this loop does not iterate).
    1:      */
67943: 
67943:     while (!obj->isFunction()) {
31823:         if (slot != FUN_LENGTH)
48676:             return true;
39928:         obj = obj->getProto();
    1:         if (!obj)
48676:             return true;
    1:     }
67943:     JSFunction *fun = obj->getFunctionPrivate();
    1: 
    1:     /* Find fun's top-most activation record. */
69223:     StackFrame *fp;
22652:     for (fp = js_GetTopStackFrame(cx);
69704:          fp && (fp->maybeFun() != fun || fp->isDirectEvalOrDebuggerFrame());
53840:          fp = fp->prev()) {
    1:         continue;
    1:     }
    1: 
    1:     switch (slot) {
31823:       case FUN_ARGUMENTS:
    1:         /* Warn if strict about f.arguments or equivalent unqualified uses. */
    1:         if (!JS_ReportErrorFlagsAndNumber(cx,
    1:                                           JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_DEPRECATED_USAGE,
    1:                                           js_arguments_str)) {
48676:             return false;
    1:         }
    1:         if (fp) {
    1:             if (!js_GetArgsValue(cx, fp, vp))
48676:                 return false;
    1:         } else {
48470:             vp->setNull();
    1:         }
    1:         break;
    1: 
31823:       case FUN_LENGTH:
    1:       case FUN_ARITY:
48470:         vp->setInt32(fun->nargs);
    1:         break;
    1: 
    1:       case FUN_NAME:
64345:         vp->setString(fun->atom ? fun->atom
48470:                                 : cx->runtime->emptyString);
    1:         break;
    1: 
70265:       case FUN_CALLER: {
48470:         vp->setNull();
70265: 
70265:         StackFrame *callerframe = (fp && fp->prev()) ? js_GetScriptedCaller(cx, fp->prev()) : NULL;
70265:         if (callerframe && !callerframe->getValidCalleeObject(cx, vp))
48676:             return false;
48676: 
48676:         if (vp->isObject()) {
52496:             JSObject &caller = vp->toObject();
52496: 
48656:             /* Censor the caller if it is from another compartment. */
70265:             if (caller.compartment() != cx->compartment) {
48470:                 vp->setNull();
59942:             } else if (caller.isFunction()) {
59942:                 JSFunction *callerFun = caller.getFunctionPrivate();
59942:                 if (callerFun->isInterpreted() && callerFun->inStrictMode()) {
52496:                     JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
52496:                                                  JSMSG_CALLER_IS_STRICT);
52496:                     return false;
52496:                 }
18870:             }
59942:         }
    1:         break;
70265:       }
    1: 
    1:       default:
64248:         JS_NOT_REACHED("fun_getProperty");
    1:     }
    1: 
48676:     return true;
    1: }
    1: 
51090: struct LazyFunctionDataProp {
18830:     uint16      atomOffset;
18830:     int8        tinyid;
18830:     uint8       attrs;
43287: };
18830: 
51090: struct PoisonPillProp {
51090:     uint16       atomOffset;
51090:     int8         tinyid;
51090: };
51090: 
51090: /* NB: no sentinels at ends -- use JS_ARRAY_LENGTH to bound loops. */
51090: 
56593: static const LazyFunctionDataProp lazyFunctionDataProps[] = {
54169:     {ATOM_OFFSET(arity),     FUN_ARITY,      JSPROP_PERMANENT|JSPROP_READONLY},
54169:     {ATOM_OFFSET(name),      FUN_NAME,       JSPROP_PERMANENT|JSPROP_READONLY},
18830: };
18830: 
51090: /* Properties censored into [[ThrowTypeError]] in strict mode. */
56593: static const PoisonPillProp poisonPillProps[] = {
51090:     {ATOM_OFFSET(arguments), FUN_ARGUMENTS },
51090:     {ATOM_OFFSET(caller),    FUN_CALLER    },
51090: };
51090: 
    1: static JSBool
47569: fun_enumerate(JSContext *cx, JSObject *obj)
47569: {
47569:     JS_ASSERT(obj->isFunction());
47569: 
51682:     jsid id;
52503:     bool found;
51682: 
54410:     if (!obj->isBoundFunction()) {
51682:         id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
52503:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
47569:             return false;
51682:     }
51682: 
47569:     id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
52503:     if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
47569:         return false;
47569: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(lazyFunctionDataProps); i++) {
51090:         const LazyFunctionDataProp &lfp = lazyFunctionDataProps[i];
47569:         id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, lfp.atomOffset));
52503:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
47569:             return false;
47569:     }
47569: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(poisonPillProps); i++) {
51090:         const PoisonPillProp &p = poisonPillProps[i];
51090:         id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, p.atomOffset));
52503:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
51090:             return false;
51090:     }
51090: 
47569:     return true;
47569: }
47569: 
62590: static JSObject *
62590: ResolveInterpretedFunctionPrototype(JSContext *cx, JSObject *obj)
62590: {
62778: #ifdef DEBUG
62590:     JSFunction *fun = obj->getFunctionPrivate();
62590:     JS_ASSERT(fun->isInterpreted());
62590:     JS_ASSERT(!fun->isFunctionPrototype());
62778: #endif
62590: 
62590:     /*
62590:      * Assert that fun is not a compiler-created function object, which
62590:      * must never leak to script or embedding code and then be mutated.
62590:      * Also assert that obj is not bound, per the ES5 15.3.4.5 ref above.
62590:      */
62590:     JS_ASSERT(!IsInternalFunctionObject(obj));
62590:     JS_ASSERT(!obj->isBoundFunction());
62590: 
62590:     /*
62590:      * Make the prototype object an instance of Object with the same parent
62590:      * as the function object itself.
62590:      */
62590:     JSObject *parent = obj->getParent();
62590:     JSObject *proto;
62590:     if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
62590:         return NULL;
62590:     proto = NewNativeClassInstance(cx, &js_ObjectClass, proto, parent);
62590:     if (!proto)
62590:         return NULL;
62590: 
62590:     /*
62590:      * ECMA (15.3.5.2) says that a user-defined function's .prototype property
62590:      * is non-configurable, non-enumerable, and (initially) writable. Hence
62590:      * JSPROP_PERMANENT below. By contrast, the built-in constructors, such as
62590:      * Object (15.2.3.1) and Function (15.3.3.1), have non-writable
62590:      * .prototype properties. Those are eagerly defined, with attributes
62590:      * JSPROP_PERMANENT | JSPROP_READONLY, in js_InitClass.
62590:      */
62590:     if (!js_SetClassPrototype(cx, obj, proto, JSPROP_PERMANENT))
62590:         return NULL;
62590:     return proto;
62590: }
62590: 
47569: static JSBool
48470: fun_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp)
    1: {
48470:     if (!JSID_IS_ATOM(id))
55498:         return true;
    1: 
51682:     JSFunction *fun = obj->getFunctionPrivate();
 2803: 
55498:     if (JSID_IS_ATOM(id, cx->runtime->atomState.classPrototypeAtom)) {
 2803:         /*
55498:          * Native or "built-in" functions do not have a .prototype property per
55498:          * ECMA-262 (all editions). Built-in constructor functions, e.g. Object
55498:          * and Function to name two conspicuous examples, do have a .prototype
55498:          * property, but it is created eagerly by js_InitClass (jsobj.cpp).
55498:          *
55498:          * ES5 15.3.4: the non-native function object named Function.prototype
55498:          * must not have a .prototype property.
55498:          *
55498:          * ES5 15.3.4.5: bound functions don't have a prototype property. The
55498:          * isNative() test covers this case because bound functions are native
55498:          * functions by definition/construction.
 2803:          */
55498:         if (fun->isNative() || fun->isFunctionPrototype())
55498:             return true;
55498: 
62590:         if (!ResolveInterpretedFunctionPrototype(cx, obj))
55498:             return false;
    1:         *objp = obj;
55498:         return true;
 2803:     }
 2803: 
55498:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
43287:         JS_ASSERT(!IsInternalFunctionObject(obj));
69855:         if (!DefineNativeProperty(cx, obj, id, Int32Value(fun->nargs),
62395:                                   PropertyStub, StrictPropertyStub,
69855:                                   JSPROP_PERMANENT | JSPROP_READONLY, 0, 0)) {
55498:             return false;
43287:         }
43287:         *objp = obj;
55498:         return true;
43287:     }
43287: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(lazyFunctionDataProps); i++) {
51090:         const LazyFunctionDataProp *lfp = &lazyFunctionDataProps[i];
 2803: 
55498:         if (JSID_IS_ATOM(id, OFFSET_TO_ATOM(cx->runtime, lfp->atomOffset))) {
40405:             JS_ASSERT(!IsInternalFunctionObject(obj));
69855:             if (!DefineNativeProperty(cx, obj, id, UndefinedValue(),
62395:                                       fun_getProperty, StrictPropertyStub,
69855:                                       lfp->attrs, Shape::HAS_SHORTID, lfp->tinyid)) {
55498:                 return false;
 2803:             }
 2803:             *objp = obj;
55498:             return true;
 2803:         }
    1:     }
    1: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(poisonPillProps); i++) {
51090:         const PoisonPillProp &p = poisonPillProps[i];
51090: 
55498:         if (JSID_IS_ATOM(id, OFFSET_TO_ATOM(cx->runtime, p.atomOffset))) {
51090:             JS_ASSERT(!IsInternalFunctionObject(obj));
51090: 
62395:             PropertyOp getter;
62395:             StrictPropertyOp setter;
51090:             uintN attrs = JSPROP_PERMANENT;
59942:             if (fun->isInterpreted() ? fun->inStrictMode() : obj->isBoundFunction()) {
51090:                 JSObject *throwTypeError = obj->getThrowTypeError();
51090: 
51090:                 getter = CastAsPropertyOp(throwTypeError);
62395:                 setter = CastAsStrictPropertyOp(throwTypeError);
51090:                 attrs |= JSPROP_GETTER | JSPROP_SETTER;
51090:             } else {
51090:                 getter = fun_getProperty;
62395:                 setter = StrictPropertyStub;
51090:             }
51090: 
69855:             if (!DefineNativeProperty(cx, obj, id, UndefinedValue(), getter, setter,
69855:                                       attrs, Shape::HAS_SHORTID, p.tinyid)) {
55498:                 return false;
51090:             }
51090:             *objp = obj;
55498:             return true;
51090:         }
51090:     }
51090: 
55498:     return true;
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: /* XXX store parent and proto, if defined */
28093: JSBool
28093: js_XDRFunctionObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSFunction *fun;
28952:     uint32 firstword;           /* flag telling whether fun->atom is non-null,
28952:                                    plus for fun->u.i.skipmin, fun->u.i.wrapper,
28952:                                    and 14 bits reserved for future use */
59968:     uint32 flagsword;           /* word for argument count and fun->flags */
    1: 
    1:     cx = xdr->cx;
    1:     if (xdr->mode == JSXDR_ENCODE) {
13702:         fun = GET_FUNCTION_PRIVATE(cx, *objp);
    1:         if (!FUN_INTERPRETED(fun)) {
57812:             JSAutoByteString funNameBytes;
57812:             if (const char *name = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
57812:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_SCRIPTED_FUNCTION,
57812:                                      name);
57812:             }
40389:             return false;
    1:         }
28952:         if (fun->u.i.wrapper) {
57812:             JSAutoByteString funNameBytes;
57812:             if (const char *name = GetFunctionNameBytes(cx, fun, &funNameBytes))
57812:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XDR_CLOSURE_WRAPPER, name);
40389:             return false;
28952:         }
28952:         JS_ASSERT((fun->u.i.wrapper & ~1U) == 0);
28952:         firstword = (fun->u.i.skipmin << 2) | (fun->u.i.wrapper << 1) | !!fun->atom;
59968:         flagsword = (fun->nargs << 16) | fun->flags;
    1:     } else {
13702:         fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, NULL, NULL);
    1:         if (!fun)
40389:             return false;
39930:         FUN_OBJECT(fun)->clearParent();
39928:         FUN_OBJECT(fun)->clearProto();
    1:     }
    1: 
48470:     AutoObjectRooter tvr(cx, FUN_OBJECT(fun));
    1: 
28952:     if (!JS_XDRUint32(xdr, &firstword))
40389:         return false;
48480:     if ((firstword & 1U) && !js_XDRAtom(xdr, &fun->atom))
40389:         return false;
59968:     if (!JS_XDRUint32(xdr, &flagsword))
40389:         return false;
    1: 
 8179:     if (xdr->mode == JSXDR_DECODE) {
59968:         fun->nargs = flagsword >> 16;
27012:         JS_ASSERT((flagsword & JSFUN_KINDMASK) >= JSFUN_INTERPRETED);
27012:         fun->flags = uint16(flagsword);
28952:         fun->u.i.skipmin = uint16(firstword >> 2);
33166:         fun->u.i.wrapper = JSPackedBool((firstword >> 1) & 1);
 8179:     }
    1: 
70534:     if (!js_XDRScript(xdr, &fun->u.i.script))
40389:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
13824:         *objp = FUN_OBJECT(fun);
11377: #ifdef CHECK_SCRIPT_OWNER
59220:         fun->script()->owner = NULL;
11377: #endif
59968:         JS_ASSERT(fun->nargs == fun->script()->bindings.countArgs());
59220:         js_CallNewScriptHook(cx, fun->script(), fun);
34290:     }
    1: 
40389:     return true;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
28093: #define js_XDRFunctionObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
    1: /*
    1:  * [[HasInstance]] internal method for Function objects: fetch the .prototype
    1:  * property of its 'this' parameter, and walks the prototype chain of v (only
    1:  * if v is an object) returning true if .prototype is found.
    1:  */
    1: static JSBool
48470: fun_hasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
    1: {
51682:     while (obj->isFunction()) {
54410:         if (!obj->isBoundFunction())
51682:             break;
51682:         obj = obj->getBoundFunctionTarget();
51682:     }
51682: 
31823:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
48470:     Value pval;
31823:     if (!obj->getProperty(cx, id, &pval))
    1:         return JS_FALSE;
    1: 
48470:     if (pval.isPrimitive()) {
    1:         /*
    1:          * Throw a runtime error if instanceof is called on a function that
    1:          * has a non-object as its .prototype value.
    1:          */
48470:         js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE, -1, ObjectValue(*obj), NULL);
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     *bp = js_IsDelegate(cx, &pval.toObject(), *v);
48470:     return JS_TRUE;
    1: }
    1: 
  583: static void
  583: fun_trace(JSTracer *trc, JSObject *obj)
    1: {
13691:     /* A newborn function object may have a not yet initialized private slot. */
31452:     JSFunction *fun = (JSFunction *) obj->getPrivate();
13824:     if (!fun)
13824:         return;
13824: 
52503:     if (fun != obj) {
52503:         /* obj is a cloned function object, trace the clone-parent, fun. */
53840:         MarkObject(trc, *fun, "private");
52503: 
52503:         /* The function could be a flat closure with upvar copies in the clone. */
59968:         if (fun->isFlatClosure() && fun->script()->bindings.hasUpvars()) {
59968:             MarkValueRange(trc, fun->script()->bindings.countUpvars(),
59968:                            obj->getFlatClosureUpvars(), "upvars");
59968:         }
13824:         return;
13824:     }
52503: 
  254:     if (fun->atom)
64345:         MarkString(trc, fun->atom, "atom");
52503: 
59968:     if (fun->isInterpreted() && fun->script())
59968:         js_TraceScript(trc, fun->script());
13824: }
13824: 
13824: static void
13824: fun_finalize(JSContext *cx, JSObject *obj)
13824: {
52503:     /* Ignore newborn function objects. */
59968:     JSFunction *fun = obj->getFunctionPrivate();
52503:     if (!fun)
13824:         return;
13824: 
52503:     /* Cloned function objects may be flat closures with upvars to free. */
52503:     if (fun != obj) {
59968:         if (fun->isFlatClosure() && fun->script()->bindings.hasUpvars())
64560:             cx->free_((void *) obj->getFlatClosureUpvars());
52503:         return;
52503:     }
52503: 
13824:     /*
59968:      * Null-check fun->script() because the parser sets interpreted very early.
13824:      */
59968:     if (fun->isInterpreted() && fun->script())
59968:         js_DestroyScriptFromGC(cx, fun->script());
30732: }
30732: 
    1: /*
    1:  * Reserve two slots in all function objects for XPConnect.  Note that this
    1:  * does not bloat every instance, only those on which reserved slots are set,
    1:  * and those on which ad-hoc properties are defined.
    1:  */
48470: JS_PUBLIC_DATA(Class) js_FunctionClass = {
    1:     js_Function_str,
48676:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSFunction::CLASS_RESERVED_SLOTS) |
64218:     JSCLASS_HAS_CACHED_PROTO(JSProto_Function),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     fun_enumerate,
48622:     (JSResolveOp)fun_resolve,
48622:     ConvertStub,
48622:     fun_finalize,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
70534:     js_XDRFunctionObject,
48622:     fun_hasInstance,
64218:     fun_trace
    1: };
    1: 
47498: JSString *
47498: fun_toStringHelper(JSContext *cx, JSObject *obj, uintN indent)
    1: {
47498:     if (!obj->isFunction()) {
47514:         if (obj->isFunctionProxy())
47498:             return JSProxy::fun_toString(cx, obj, indent);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_INCOMPATIBLE_PROTO,
    1:                              js_Function_str, js_toString_str,
47498:                              "object");
47498:         return NULL;
    1:     }
    1: 
47498:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, obj);
47498:     if (!fun)
47498:         return NULL;
61687: 
64213:     if (!indent && !cx->compartment->toSourceCache.empty()) {
64213:         ToSourceCache::Ptr p = cx->compartment->toSourceCache.ref().lookup(fun);
61687:         if (p)
61687:             return p->value;
61687:     }
61687: 
61687:     JSString *str = JS_DecompileFunction(cx, fun, indent);
61687:     if (!str)
64213:         return NULL;
64213: 
64213:     if (!indent) {
69244:         Maybe<ToSourceCache> &lazy = cx->compartment->toSourceCache;
64213: 
64213:         if (lazy.empty()) {
64213:             lazy.construct();
64213:             if (!lazy.ref().init())
64213:                 return NULL;
64213:         }
64213: 
64213:         if (!lazy.ref().put(fun, str))
64213:             return NULL;
64213:     }
61687: 
61687:     return str;
    1: }
    1: 
    1: static JSBool
48470: fun_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JS_ASSERT(IsFunctionObject(vp[0]));
47498:     uint32_t indent = 0;
47498: 
47498:     if (argc != 0 && !ValueToECMAUint32(cx, vp[2], &indent))
47498:         return false;
47498: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
47498:     if (!obj)
47498:         return false;
47498: 
47498:     JSString *str = fun_toStringHelper(cx, obj, indent);
47498:     if (!str)
47498:         return false;
47498: 
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
48470: fun_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JS_ASSERT(IsFunctionObject(vp[0]));
48470: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
47498:     if (!obj)
47498:         return false;
47498: 
47498:     JSString *str = fun_toStringHelper(cx, obj, JS_DONT_PRETTY_PRINT);
47498:     if (!str)
47498:         return false;
47498: 
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: #endif
    1: 
29887: JSBool
48470: js_fun_call(JSContext *cx, uintN argc, Value *vp)
    1: {
37741:     LeaveTrace(cx);
48470:     Value fval = vp[1];
    1: 
38638:     if (!js_IsCallable(fval)) {
67943:         ReportIncompatibleMethod(cx, vp, &js_FunctionClass);
61734:         return false;
    1:     }
    1: 
48470:     Value *argv = vp + 2;
55712:     Value thisv;
    1:     if (argc == 0) {
55712:         thisv.setUndefined();
    1:     } else {
55713:         thisv = argv[0];
55713: 
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
42714:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
    1:         return JS_FALSE;
    1: 
55712:     /* Push fval, thisv, and the args. */
68893:     args.calleev() = fval;
55712:     args.thisv() = thisv;
50468:     memcpy(args.argv(), argv, argc * sizeof *argv);
42714: 
69223:     bool ok = Invoke(cx, args);
50468:     *vp = args.rval();
    1:     return ok;
    1: }
    1: 
48590: /* ES5 15.3.4.3 */
29887: JSBool
48470: js_fun_apply(JSContext *cx, uintN argc, Value *vp)
    1: {
48590:     /* Step 1. */
48470:     Value fval = vp[1];
38638:     if (!js_IsCallable(fval)) {
67943:         ReportIncompatibleMethod(cx, vp, &js_FunctionClass);
48590:         return false;
    1:     }
    1: 
48590:     /* Step 2. */
48590:     if (argc < 2 || vp[3].isNullOrUndefined())
48590:         return js_fun_call(cx, (argc > 0) ? 1 : 0, vp);
48590: 
57717:     /* N.B. Changes need to be propagated to stubs::SplatApplyArgs. */
57717: 
48590:     /* Step 3. */
48590:     if (!vp[3].isObject()) {
48590:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_APPLY_ARGS, js_apply_str);
48590:         return false;
48590:     }
48590: 
48590:     /*
48590:      * Steps 4-5 (note erratum removing steps originally numbered 5 and 7 in
48590:      * original version of ES5).
48590:      */
56565:     JSObject *aobj = &vp[3].toObject();
48590:     jsuint length;
57714:     if (!js_GetLengthProperty(cx, aobj, &length))
48590:         return false;
48590: 
48590:     LeaveTrace(cx);
48590: 
48590:     /* Step 6. */
48590:     uintN n = uintN(JS_MIN(length, JS_ARGS_LENGTH_MAX));
42714: 
42714:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, n, &args))
48590:         return false;
    1: 
    1:     /* Push fval, obj, and aobj's elements as args. */
68893:     args.calleev() = fval;
55713:     args.thisv() = vp[2];
48590: 
48590:     /* Steps 7-8. */
57714:     if (!GetElements(cx, aobj, n, args.argv()))
57714:         return false;
    1: 
48590:     /* Step 9. */
69223:     if (!Invoke(cx, args))
48590:         return false;
50468:     *vp = args.rval();
48590:     return true;
    1: }
    1: 
62402: namespace js {
62402: 
62402: JSBool
51682: CallOrConstructBoundFunction(JSContext *cx, uintN argc, Value *vp);
51682: 
62402: }
62402: 
51682: inline bool
51682: JSObject::initBoundFunction(JSContext *cx, const Value &thisArg,
51682:                             const Value *args, uintN argslen)
51682: {
51682:     JS_ASSERT(isFunction());
54410: 
54410:     flags |= JSObject::BOUND_FUNCTION;
55746:     getSlotRef(JSSLOT_BOUND_FUNCTION_THIS) = thisArg;
55746:     getSlotRef(JSSLOT_BOUND_FUNCTION_ARGS_COUNT).setPrivateUint32(argslen);
51682:     if (argslen != 0) {
52503:         /* FIXME? Burn memory on an empty scope whose shape covers the args slots. */
52503:         EmptyShape *empty = EmptyShape::create(cx, clasp);
52503:         if (!empty)
52503:             return false;
52503: 
53652:         empty->slotSpan += argslen;
68935:         setMap(empty);
52503: 
52503:         if (!ensureInstanceReservedSlots(cx, argslen))
51682:             return false;
51682: 
55746:         JS_ASSERT(numSlots() >= argslen + FUN_CLASS_RESERVED_SLOTS);
55746:         memcpy(getSlots() + FUN_CLASS_RESERVED_SLOTS, args, argslen * sizeof(Value));
51682:     }
51682:     return true;
51682: }
51682: 
51682: inline JSObject *
51682: JSObject::getBoundFunctionTarget() const
51682: {
51682:     JS_ASSERT(isFunction());
54410:     JS_ASSERT(isBoundFunction());
51682: 
51682:     /* Bound functions abuse |parent| to store their target function. */
51682:     return getParent();
51682: }
51682: 
51682: inline const js::Value &
51682: JSObject::getBoundFunctionThis() const
51682: {
51682:     JS_ASSERT(isFunction());
54410:     JS_ASSERT(isBoundFunction());
51682: 
55746:     return getSlot(JSSLOT_BOUND_FUNCTION_THIS);
51682: }
51682: 
51682: inline const js::Value *
51682: JSObject::getBoundFunctionArguments(uintN &argslen) const
51682: {
51682:     JS_ASSERT(isFunction());
54410:     JS_ASSERT(isBoundFunction());
51682: 
55746:     argslen = getSlot(JSSLOT_BOUND_FUNCTION_ARGS_COUNT).toPrivateUint32();
55746:     JS_ASSERT_IF(argslen > 0, numSlots() >= argslen);
55746: 
55746:     return getSlots() + FUN_CLASS_RESERVED_SLOTS;
51682: }
51682: 
62402: namespace js {
62402: 
51682: /* ES5 15.3.4.5.1 and 15.3.4.5.2. */
62402: JSBool
51682: CallOrConstructBoundFunction(JSContext *cx, uintN argc, Value *vp)
51682: {
51682:     JSObject *obj = &vp[0].toObject();
51682:     JS_ASSERT(obj->isFunction());
54410:     JS_ASSERT(obj->isBoundFunction());
51682: 
51682:     LeaveTrace(cx);
51682: 
53557:     bool constructing = IsConstructing(vp);
51682: 
51682:     /* 15.3.4.5.1 step 1, 15.3.4.5.2 step 3. */
51682:     uintN argslen;
51682:     const Value *boundArgs = obj->getBoundFunctionArguments(argslen);
51682: 
51682:     if (argc + argslen > JS_ARGS_LENGTH_MAX) {
51682:         js_ReportAllocationOverflow(cx);
51682:         return false;
51682:     }
51682: 
51682:     /* 15.3.4.5.1 step 3, 15.3.4.5.2 step 1. */
51682:     JSObject *target = obj->getBoundFunctionTarget();
51682: 
51682:     /* 15.3.4.5.1 step 2. */
51682:     const Value &boundThis = obj->getBoundFunctionThis();
51682: 
51682:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, argc + argslen, &args))
51682:         return false;
51682: 
51682:     /* 15.3.4.5.1, 15.3.4.5.2 step 4. */
51682:     memcpy(args.argv(), boundArgs, argslen * sizeof(Value));
51682:     memcpy(args.argv() + argslen, vp + 2, argc * sizeof(Value));
51682: 
51682:     /* 15.3.4.5.1, 15.3.4.5.2 step 5. */
68893:     args.calleev().setObject(*target);
51682: 
55713:     if (!constructing)
55713:         args.thisv() = boundThis;
51682: 
69223:     if (constructing ? !InvokeConstructor(cx, args) : !Invoke(cx, args))
51682:         return false;
51682: 
51682:     *vp = args.rval();
51682:     return true;
51682: }
51682: 
62402: }
62402: 
67935: #if JS_HAS_GENERATORS
67935: static JSBool
67935: fun_isGenerator(JSContext *cx, uintN argc, Value *vp)
67935: {
67935:     JSObject *funobj;
67935:     if (!IsFunctionObject(vp[1], &funobj)) {
67935:         JS_SET_RVAL(cx, vp, BooleanValue(false));
67935:         return true;
67935:     }
67935: 
67935:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
67935: 
67935:     bool result = false;
67935:     if (fun->isInterpreted()) {
70311:         JSScript *script = fun->script();
67935:         JS_ASSERT(script->length != 0);
67935:         result = script->code[0] == JSOP_GENERATOR;
67935:     }
67935: 
67935:     JS_SET_RVAL(cx, vp, BooleanValue(result));
67935:     return true;
67935: }
67935: #endif
67935: 
51682: /* ES5 15.3.4.5. */
56593: static JSBool
51682: fun_bind(JSContext *cx, uintN argc, Value *vp)
51682: {
51682:     /* Step 1. */
61734:     Value &thisv = vp[1];
51682: 
51682:     /* Step 2. */
61734:     if (!js_IsCallable(thisv)) {
67943:         ReportIncompatibleMethod(cx, vp, &js_FunctionClass);
51682:         return false;
51682:     }
51682: 
61734:     JSObject *target = &thisv.toObject();
61734: 
51682:     /* Step 3. */
51682:     Value *args = NULL;
51682:     uintN argslen = 0;
51682:     if (argc > 1) {
51682:         args = vp + 3;
51682:         argslen = argc - 1;
51682:     }
51682: 
51682:     /* Steps 15-16. */
51682:     uintN length = 0;
51682:     if (target->isFunction()) {
51682:         uintN nargs = target->getFunctionPrivate()->nargs;
51682:         if (nargs > argslen)
51682:             length = nargs - argslen;
51682:     }
51682: 
51682:     /* Step 4-6, 10-11. */
51682:     JSAtom *name = target->isFunction() ? target->getFunctionPrivate()->atom : NULL;
51682: 
51682:     /* NB: Bound functions abuse |parent| to store their target. */
51682:     JSObject *funobj =
53557:         js_NewFunction(cx, NULL, CallOrConstructBoundFunction, length,
53557:                        JSFUN_CONSTRUCTOR, target, name);
51682:     if (!funobj)
51682:         return false;
51682: 
51682:     /* Steps 7-9. */
51682:     Value thisArg = argc >= 1 ? vp[2] : UndefinedValue();
51682:     if (!funobj->initBoundFunction(cx, thisArg, args, argslen))
51682:         return false;
51682: 
51682:     /* Steps 17, 19-21 are handled by fun_resolve. */
51682:     /* Step 18 is the default for new functions. */
51682: 
51682:     /* Step 22. */
51682:     vp->setObject(*funobj);
51682:     return true;
51682: }
51682: 
    1: static JSFunctionSpec function_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,   fun_toSource,   0,0),
    1: #endif
16519:     JS_FN(js_toString_str,   fun_toString,   0,0),
21473:     JS_FN(js_apply_str,      js_fun_apply,   2,0),
21473:     JS_FN(js_call_str,       js_fun_call,    1,0),
51682:     JS_FN("bind",            fun_bind,       1,0),
67936: #if JS_HAS_GENERATORS
67935:     JS_FN("isGenerator",     fun_isGenerator,0,0),
67936: #endif
 4127:     JS_FS_END
    1: };
    1: 
64386: /*
64386:  * Report "malformed formal parameter" iff no illegal char or similar scanner
64386:  * error was already reported.
64386:  */
64386: static bool
64386: OnBadFormal(JSContext *cx, TokenKind tt)
64386: {
64386:     if (tt != TOK_ERROR)
64386:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_FORMAL);
64386:     else
64386:         JS_ASSERT(cx->isExceptionPending());
64386:     return false;
64386: }
64386: 
    1: static JSBool
53557: Function(JSContext *cx, uintN argc, Value *vp)
    1: {
68894:     CallArgs call = CallArgsFromVp(argc, vp);
68894: 
70297:     /* Block this call if security callbacks forbid it. */
70297:     GlobalObject *global = call.callee().getGlobal();
70297:     if (!global->isEvalAllowed(cx)) {
70297:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_FUNCTION);
70297:         return false;
70297:     }
70297: 
70297:     JS::Anchor<JSObject *> obj(NewFunction(cx, *global));
64386:     if (!obj.get())
64386:         return false;
64386: 
    1:     /*
    1:      * NB: (new Function) is not lexically closed by its caller, it's just an
    1:      * anonymous function in the top-level scope that its constructor inhabits.
    1:      * Thus 'var x = 42; f = new Function("return x"); print(f())' prints 42,
    1:      * and so would a call to f from another top-level's script or function.
    1:      */
64386:     JSFunction *fun = js_NewFunction(cx, obj.get(), NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
70297:                                      global, cx->runtime->atomState.anonymousAtom);
    1:     if (!fun)
64386:         return false;
    1: 
64242:     EmptyShape *emptyCallShape = EmptyShape::getEmptyCallShape(cx);
64242:     if (!emptyCallShape)
64386:         return false;
64242:     AutoShapeRooter shapeRoot(cx, emptyCallShape);
64242: 
64242:     Bindings bindings(cx, emptyCallShape);
60555:     AutoBindingsRooter root(cx, bindings);
59968: 
68894:     uintN lineno;
68894:     const char *filename = CurrentScriptFileAndLine(cx, &lineno);
68894: 
68894:     Value *argv = call.argv();
53557:     uintN n = argc ? argc - 1 : 0;
    1:     if (n > 0) {
    1:         /*
    1:          * Collect the function-argument arguments into one string, separated
    1:          * by commas, then make a tokenstream from that string, and scan it to
    1:          * get the arguments.  We need to throw the full scanner at the
    1:          * problem, because the argument string can legitimately contain
    1:          * comments and linefeeds.  XXX It might be better to concatenate
    1:          * everything up into a function definition and pass it to the
    1:          * compiler, but doing it this way is less of a delta from the old
    1:          * code.  See ECMA 15.3.2.1.
    1:          */
53557:         size_t args_length = 0;
53557:         for (uintN i = 0; i < n; i++) {
    1:             /* Collect the lengths for all the function-argument arguments. */
53557:             JSString *arg = js_ValueToString(cx, argv[i]);
    1:             if (!arg)
64386:                 return false;
48470:             argv[i].setString(arg);
    1: 
    1:             /*
    1:              * Check for overflow.  The < test works because the maximum
    1:              * JSString length fits in 2 fewer bits than size_t has.
    1:              */
53557:             size_t old_args_length = args_length;
29366:             args_length = old_args_length + arg->length();
    1:             if (args_length < old_args_length) {
12983:                 js_ReportAllocationOverflow(cx);
64386:                 return false;
    1:             }
    1:         }
    1: 
    1:         /* Add 1 for each joining comma and check for overflow (two ways). */
53557:         size_t old_args_length = args_length;
    1:         args_length = old_args_length + n - 1;
    1:         if (args_length < old_args_length ||
    1:             args_length >= ~(size_t)0 / sizeof(jschar)) {
12983:             js_ReportAllocationOverflow(cx);
64386:             return false;
    1:         }
    1: 
    1:         /*
    1:          * Allocate a string to hold the concatenated arguments, including room
    1:          * for a terminating 0.  Mark cx->tempPool for later release, to free
    1:          * collected_args and its tokenstream in one swoop.
    1:          */
64386:         AutoArenaAllocator aaa(&cx->tempPool);
64386:         jschar *cp = aaa.alloc<jschar>(args_length + 1);
    1:         if (!cp) {
 8296:             js_ReportOutOfScriptQuota(cx);
64386:             return false;
    1:         }
53557:         jschar *collected_args = cp;
    1: 
    1:         /*
    1:          * Concatenate the arguments into the new string, separated by commas.
    1:          */
53557:         for (uintN i = 0; i < n; i++) {
53557:             JSString *arg = argv[i].toString();
53557:             size_t arg_length = arg->length();
59890:             const jschar *arg_chars = arg->getChars(cx);
64386:             if (!arg_chars)
64386:                 return false;
59890:             (void) js_strncpy(cp, arg_chars, arg_length);
    1:             cp += arg_length;
    1: 
    1:             /* Add separating comma or terminating 0. */
    1:             *cp++ = (i + 1 < n) ? ',' : 0;
    1:         }
    1: 
 6561:         /* Initialize a tokenstream that reads from the given string. */
53557:         TokenStream ts(cx);
64386:         if (!ts.init(collected_args, args_length, filename, lineno, cx->findVersion()))
64386:             return false;
    1: 
    1:         /* The argument string may be empty or contain no tokens. */
53557:         TokenKind tt = ts.getToken();
    1:         if (tt != TOK_EOF) {
    1:             for (;;) {
    1:                 /*
    1:                  * Check that it's a name.  This also implicitly guards against
    1:                  * TOK_ERROR, which was already reported.
    1:                  */
    1:                 if (tt != TOK_NAME)
64386:                     return OnBadFormal(cx, tt);
    1: 
    1:                 /*
 8444:                  * Get the atom corresponding to the name from the token
 8444:                  * stream; we're assured at this point that it's a valid
 8444:                  * identifier.
    1:                  */
53557:                 JSAtom *atom = ts.currentToken().t_atom;
    1: 
 8179:                 /* Check for a duplicate parameter name. */
59992:                 if (bindings.hasBinding(cx, atom)) {
57812:                     JSAutoByteString name;
64386:                     if (!js_AtomToPrintableString(cx, atom, &name))
64386:                         return false;
57812:                     if (!ReportCompileErrorNumber(cx, &ts, NULL,
40320:                                                   JSREPORT_WARNING | JSREPORT_STRICT,
57812:                                                   JSMSG_DUPLICATE_FORMAL, name.ptr())) {
64386:                         return false;
    1:                     }
53557:                 }
59968: 
59968:                 uint16 dummy;
64386:                 if (!bindings.addArgument(cx, atom, &dummy))
64386:                     return false;
    1: 
    1:                 /*
    1:                  * Get the next token.  Stop on end of stream.  Otherwise
    1:                  * insist on a comma, get another name, and iterate.
    1:                  */
40354:                 tt = ts.getToken();
    1:                 if (tt == TOK_EOF)
    1:                     break;
    1:                 if (tt != TOK_COMMA)
64386:                     return OnBadFormal(cx, tt);
40354:                 tt = ts.getToken();
    1:             }
    1:         }
 6561:     }
64386: 
64386:     JS::Anchor<JSString *> strAnchor(NULL);
64386:     const jschar *chars;
64386:     size_t length;
64386: 
64386:     if (argc) {
64386:         JSString *str = js_ValueToString(cx, argv[argc - 1]);
64386:         if (!str)
64386:             return false;
64386:         strAnchor.set(str);
64386:         chars = str->getChars(cx);
64386:         length = str->length();
64386:     } else {
64386:         chars = cx->runtime->emptyString->chars();
64386:         length = 0;
    1:     }
    1: 
68894:     JSPrincipals *principals = PrincipalsForCompiledCode(call, cx);
68894:     bool ok = Compiler::compileFunctionBody(cx, fun, principals, &bindings,
64386:                                             chars, length, filename, lineno,
64386:                                             cx->findVersion());
68894:     call.rval().setObject(obj);
68894:     return ok;
    1: }
    1: 
61448: namespace js {
61448: 
64210: bool
61448: IsBuiltinFunctionConstructor(JSFunction *fun)
61448: {
61448:     return fun->maybeNative() == Function;
61448: }
61448: 
62590: const Shape *
62590: LookupInterpretedFunctionPrototype(JSContext *cx, JSObject *funobj)
62590: {
62778: #ifdef DEBUG
62590:     JSFunction *fun = funobj->getFunctionPrivate();
62590:     JS_ASSERT(fun->isInterpreted());
62590:     JS_ASSERT(!fun->isFunctionPrototype());
62590:     JS_ASSERT(!funobj->isBoundFunction());
62778: #endif
62590: 
62590:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
62590:     const Shape *shape = funobj->nativeLookup(id);
62590:     if (!shape) {
62590:         if (!ResolveInterpretedFunctionPrototype(cx, funobj))
68902:             return NULL;
62590:         shape = funobj->nativeLookup(id);
62590:     }
62590:     JS_ASSERT(!shape->configurable());
62590:     JS_ASSERT(shape->isDataDescriptor());
62590:     JS_ASSERT(shape->hasSlot());
62590:     JS_ASSERT(!shape->isMethod());
62590:     return shape;
62590: }
62590: 
63096: } /* namespace js */
61448: 
56593: static JSBool
51090: ThrowTypeError(JSContext *cx, uintN argc, Value *vp)
51090: {
51090:     JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
51090:                                  JSMSG_THROW_TYPE_ERROR);
51090:     return false;
51090: }
51090: 
    1: JSObject *
    1: js_InitFunctionClass(JSContext *cx, JSObject *obj)
    1: {
51090:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_FunctionClass, Function, 1,
43287:                                    NULL, function_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
51090: 
51090:     JSFunction *fun = js_NewFunction(cx, proto, NULL, 0, JSFUN_INTERPRETED, obj, NULL);
    1:     if (!fun)
33178:         return NULL;
55498:     fun->flags |= JSFUN_PROTOTYPE;
59220: 
61450:     JSScript *script = JSScript::NewScript(cx, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, JSVERSION_DEFAULT);
59220:     if (!script)
59220:         return NULL;
59220:     script->noScriptRval = true;
59220:     script->code[0] = JSOP_STOP;
59220:     script->code[1] = SRC_NULL;
59220: #ifdef CHECK_SCRIPT_OWNER
59220:     script->owner = NULL;
59220: #endif
59220:     fun->u.i.script = script;
64195:     js_CallNewScriptHook(cx, script, fun);
51090: 
60566:     if (obj->isGlobal()) {
51090:         /* ES5 13.2.3: Construct the unique [[ThrowTypeError]] function object. */
68955:         JSFunction *throwTypeError =
51090:             js_NewFunction(cx, NULL, reinterpret_cast<Native>(ThrowTypeError), 0,
53557:                            0, obj, NULL);
51090:         if (!throwTypeError)
51090:             return NULL;
51090: 
68955:         obj->asGlobal()->setThrowTypeError(throwTypeError);
51090:     }
51090: 
    1:     return proto;
    1: }
    1: 
    1: JSFunction *
48470: js_NewFunction(JSContext *cx, JSObject *funobj, Native native, uintN nargs,
    1:                uintN flags, JSObject *parent, JSAtom *atom)
    1: {
    1:     JSFunction *fun;
    1: 
    1:     if (funobj) {
40430:         JS_ASSERT(funobj->isFunction());
39930:         funobj->setParent(parent);
    1:     } else {
50500:         funobj = NewFunction(cx, parent);
    1:         if (!funobj)
    1:             return NULL;
    1:     }
31452:     JS_ASSERT(!funobj->getPrivate());
13824:     fun = (JSFunction *) funobj;
    1: 
    1:     /* Initialize all function members. */
39928:     fun->nargs = uint16(nargs);
53557:     fun->flags = flags & (JSFUN_FLAGS_MASK | JSFUN_KINDMASK | JSFUN_TRCINFO);
27012:     if ((flags & JSFUN_KINDMASK) >= JSFUN_INTERPRETED) {
13702:         JS_ASSERT(!native);
13702:         JS_ASSERT(nargs == 0);
28952:         fun->u.i.skipmin = 0;
28952:         fun->u.i.wrapper = false;
13702:         fun->u.i.script = NULL;
13702:     } else {
25887:         fun->u.n.clasp = NULL;
32669:         if (flags & JSFUN_TRCINFO) {
20408: #ifdef JS_TRACER
32669:             JSNativeTraceInfo *trcinfo =
32669:                 JS_FUNC_TO_DATA_PTR(JSNativeTraceInfo *, native);
48470:             fun->u.n.native = (js::Native) trcinfo->native;
25887:             fun->u.n.trcinfo = trcinfo;
20408: #else
25887:             fun->u.n.trcinfo = NULL;
20408: #endif
20408:         } else {
20408:             fun->u.n.native = native;
25887:             fun->u.n.trcinfo = NULL;
20408:         }
28086:         JS_ASSERT(fun->u.n.native);
13702:     }
    1:     fun->atom = atom;
    1: 
13824:     /* Set private to self to indicate non-cloned fully initialized function. */
31452:     FUN_OBJECT(fun)->setPrivate(fun);
    1:     return fun;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
38604: js_CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent,
38604:                        JSObject *proto)
    1: {
38604:     JS_ASSERT(parent);
38604:     JS_ASSERT(proto);
38604: 
55633:     JSObject *clone;
55633:     if (cx->compartment == fun->compartment()) {
13482:         /*
27012:          * The cloned function object does not need the extra JSFunction members
27012:          * beyond JSObject as it points to fun via the private slot.
13482:          */
55633:         clone = NewNativeClassInstance(cx, &js_FunctionClass, proto, parent);
13824:         if (!clone)
    1:             return NULL;
31452:         clone->setPrivate(fun);
55633:     } else {
55633:         /*
55633:          * Across compartments we have to deep copy JSFunction and clone the
55633:          * script (for interpreted functions).
55633:          */
55633:         clone = NewFunction(cx, parent);
55633:         if (!clone)
55633:             return NULL;
55633:         JSFunction *cfun = (JSFunction *) clone;
55633:         cfun->nargs = fun->nargs;
55633:         cfun->flags = fun->flags;
55633:         cfun->u = fun->getFunctionPrivate()->u;
55633:         cfun->atom = fun->atom;
55633:         clone->setPrivate(cfun);
55633:         if (cfun->isInterpreted()) {
70311:             JSScript *script = cfun->script();
55633:             JS_ASSERT(script);
55633:             JS_ASSERT(script->compartment == fun->compartment());
55633:             JS_ASSERT(script->compartment != cx->compartment);
59220: 
55633:             cfun->u.i.script = js_CloneScript(cx, script);
70311:             if (!cfun->script())
55633:                 return NULL;
55633: #ifdef CHECK_SCRIPT_OWNER
59220:             cfun->script()->owner = NULL;
55633: #endif
59220:             js_CallNewScriptHook(cx, cfun->script(), cfun);
55633:         }
55633:     }
13824:     return clone;
    1: }
    1: 
38604: #ifdef JS_TRACER
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CloneFunctionObject, CONTEXT, FUNCTION, OBJECT, OBJECT, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
38604: #endif
37694: 
28923: /*
28923:  * Create a new flat closure, but don't initialize the imported upvar
28923:  * values. The tracer calls this function and then initializes the upvar
28923:  * slots on trace.
28923:  */
28923: JSObject * JS_FASTCALL
28923: js_AllocFlatClosure(JSContext *cx, JSFunction *fun, JSObject *scopeChain)
27012: {
59968:     JS_ASSERT(fun->isFlatClosure());
59968:     JS_ASSERT(JSScript::isValidOffset(fun->script()->upvarsOffset) ==
59968:               fun->script()->bindings.hasUpvars());
59968:     JS_ASSERT_IF(JSScript::isValidOffset(fun->script()->upvarsOffset),
59968:                  fun->script()->upvars()->length == fun->script()->bindings.countUpvars());
27012: 
38604:     JSObject *closure = CloneFunctionObject(cx, fun, scopeChain);
31073:     if (!closure)
27012:         return closure;
31073: 
59968:     uint32 nslots = fun->script()->bindings.countUpvars();
47497:     if (nslots == 0)
31073:         return closure;
52503: 
64560:     Value *upvars = (Value *) cx->malloc_(nslots * sizeof(Value));
52503:     if (!upvars)
27012:         return NULL;
27012: 
52503:     closure->setFlatClosureUpvars(upvars);
28923:     return closure;
28923: }
28923: 
28923: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_AllocFlatClosure,
48613:                      CONTEXT, FUNCTION, OBJECT, 0, nanojit::ACCSET_STORE_ANY)
28923: 
60254: JSObject *
55527: js_NewFlatClosure(JSContext *cx, JSFunction *fun, JSOp op, size_t oplen)
28923: {
38563:     /*
60254:      * Flat closures cannot yet be partial, that is, all upvars must be copied,
60254:      * or the closure won't be flattened. Therefore they do not need to search
60254:      * enclosing scope objects via JSOP_NAME, etc.
60254:      *
60254:      * FIXME: bug 545759 proposes to enable partial flat closures. Fixing this
60254:      * bug requires a GetScopeChainFast call here, along with JS_REQUIRES_STACK
60254:      * annotations on this function's prototype and definition.
38563:      */
60254:     VOUCH_DOES_NOT_REQUIRE_STACK();
60254:     JSObject *scopeChain = &cx->fp()->scopeChain();
38563: 
38563:     JSObject *closure = js_AllocFlatClosure(cx, fun, scopeChain);
59968:     if (!closure || !fun->script()->bindings.hasUpvars())
28994:         return closure;
28923: 
52503:     Value *upvars = closure->getFlatClosureUpvars();
70311:     uintN level = fun->script()->staticLevel;
59968:     JSUpvarArray *uva = fun->script()->upvars();
52503: 
27168:     for (uint32 i = 0, n = uva->length; i < n; i++)
52503:         upvars[i] = GetUpvar(cx, level, uva->vector[i]);
27012: 
27012:     return closure;
27012: }
27012: 
28952: JSObject *
28952: js_NewDebuggableFlatClosure(JSContext *cx, JSFunction *fun)
28952: {
53840:     JS_ASSERT(cx->fp()->fun()->flags & JSFUN_HEAVYWEIGHT);
53840:     JS_ASSERT(!cx->fp()->fun()->optimizedClosure());
39916:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28952: 
51446:     return WrapEscapingClosure(cx, cx->fp(), fun);
28952: }
28952: 
    1: JSFunction *
57721: js_DefineFunction(JSContext *cx, JSObject *obj, jsid id, Native native,
    1:                   uintN nargs, uintN attrs)
    1: {
62395:     PropertyOp gop;
62395:     StrictPropertyOp sop;
26970:     JSFunction *fun;
    1: 
27012:     if (attrs & JSFUN_STUB_GSOPS) {
27012:         /*
27012:          * JSFUN_STUB_GSOPS is a request flag only, not stored in fun->flags or
27012:          * the defined property's attributes. This allows us to encode another,
27012:          * internal flag using the same bit, JSFUN_EXPR_CLOSURE -- see jsfun.h
27012:          * for more on this.
27012:          */
27012:         attrs &= ~JSFUN_STUB_GSOPS;
62395:         gop = PropertyStub;
62395:         sop = StrictPropertyStub;
27012:     } else {
62395:         gop = NULL;
62395:         sop = NULL;
27012:     }
57753: 
57753:     /*
57779:      * Historically, all objects have had a parent member as intrinsic scope
57779:      * chain link. We want to move away from this universal parent, but JS
57779:      * requires that function objects have something like parent (ES3 and ES5
57779:      * call it the [[Scope]] internal property), to bake a particular static
57779:      * scope environment into each function object.
57753:      *
57779:      * All function objects thus have parent, including all native functions.
57779:      * All native functions defined by the JS_DefineFunction* APIs are created
57779:      * via the call below to js_NewFunction, which passes obj as the parent
57779:      * parameter, and so binds fun's parent to obj using JSObject::setParent,
57779:      * under js_NewFunction (in JSObject::init, called from NewObject -- see
57779:      * jsobjinlines.h).
57779:      *
57779:      * But JSObject::setParent sets the DELEGATE object flag on its receiver,
57779:      * to mark the object as a proto or parent of another object. Such objects
57779:      * may intervene in property lookups and scope chain searches, so require
57779:      * special handling when caching lookup and search results (since such
57779:      * intervening objects can in general grow shadowing properties later).
57779:      *
57779:      * Thus using setParent prematurely flags certain objects, notably class
57779:      * prototypes, so that defining native methods on them, where the method's
57779:      * name (e.g., toString) is already bound on Object.prototype, triggers
57779:      * shadowingShapeChange events and gratuitous shape regeneration.
57779:      *
57779:      * To fix this longstanding bug, we set check whether obj is already a
57779:      * delegate, and if not, then if js_NewFunction flagged obj as a delegate,
57779:      * we clear the flag.
57779:      *
57779:      * We thus rely on the fact that native functions (including indirect eval)
57779:      * do not use the property cache or equivalent JIT techniques that require
57779:      * this bit to be set on their parent-linked scope chain objects.
57779:      *
57779:      * Note: we keep API compatibility by setting parent to obj for all native
57779:      * function objects, even if obj->getGlobal() would suffice. This should be
57779:      * revisited when parent is narrowed to exist only for function objects and
57779:      * possibly a few prehistoric scope objects (e.g. event targets).
57780:      *
57780:      * FIXME: bug 611190.
57753:      */
57779:     bool wasDelegate = obj->isDelegate();
57753: 
50489:     fun = js_NewFunction(cx, NULL, native, nargs,
53557:                          attrs & (JSFUN_FLAGS_MASK | JSFUN_TRCINFO),
57779:                          obj,
57753:                          JSID_IS_ATOM(id) ? JSID_TO_ATOM(id) : NULL);
    1:     if (!fun)
    1:         return NULL;
57779: 
57779:     if (!wasDelegate && obj->isDelegate())
57779:         obj->clearDelegate();
57779: 
62395:     if (!obj->defineProperty(cx, id, ObjectValue(*fun), gop, sop, attrs & ~JSFUN_FLAGS_MASK))
    1:         return NULL;
    1:     return fun;
    1: }
    1: 
69223: JS_STATIC_ASSERT((JSV2F_CONSTRUCT & JSV2F_SEARCH_STACK) == 0);
    1: 
    1: JSFunction *
48470: js_ValueToFunction(JSContext *cx, const Value *vp, uintN flags)
    1: {
48470:     JSObject *funobj;
48470:     if (!IsFunctionObject(*vp, &funobj)) {
    1:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
48470:     return GET_FUNCTION_PRIVATE(cx, funobj);
    1: }
    1: 
    1: JSObject *
48470: js_ValueToFunctionObject(JSContext *cx, Value *vp, uintN flags)
    1: {
48470:     JSObject *funobj;
51075:     if (!IsFunctionObject(*vp, &funobj)) {
51075:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
51075: 
51075:     return funobj;
    1: }
    1: 
    1: JSObject *
48470: js_ValueToCallableObject(JSContext *cx, Value *vp, uintN flags)
    1: {
48470:     if (vp->isObject()) {
48470:         JSObject *callable = &vp->toObject();
48470:         if (callable->isCallable())
26059:             return callable;
    1:     }
51075: 
51075:     js_ReportIsNotFunction(cx, vp, flags);
51075:     return NULL;
    1: }
    1: 
    1: void
48470: js_ReportIsNotFunction(JSContext *cx, const Value *vp, uintN flags)
    1: {
42717:     const char *name = NULL, *source = NULL;
40389:     AutoValueRooter tvr(cx);
43211:     uintN error = (flags & JSV2F_CONSTRUCT) ? JSMSG_NOT_CONSTRUCTOR : JSMSG_NOT_FUNCTION;
42717:     LeaveTrace(cx);
50464: 
50464:     /*
50464:      * We try to the print the code that produced vp if vp is a value in the
50464:      * most recent interpreted stack frame. Note that additional values, not
50464:      * directly produced by the script, may have been pushed onto the frame's
53568:      * expression stack (e.g. by pushInvokeArgs) thereby incrementing sp past
59982:      * the depth simulated by ReconstructPCStack.
59982:      *
59982:      * Conversely, values may have been popped from the stack in preparation
59982:      * for a call (e.g., by SplatApplyArgs). Since we must pass an offset from
59982:      * the top of the simulated stack to js_ReportValueError3, we do bounds
59982:      * checking using the minimum of both the simulated and actual stack depth.
50464:      */
50464:     ptrdiff_t spindex = 0;
50464: 
42717:     FrameRegsIter i(cx);
42717:     while (!i.done() && !i.pc())
42717:         ++i;
42717: 
50464:     if (!i.done()) {
53840:         uintN depth = js_ReconstructStackDepth(cx, i.fp()->script(), i.pc());
50464:         Value *simsp = i.fp()->base() + depth;
59982:         if (i.fp()->base() <= vp && vp < Min(simsp, i.sp()))
50464:             spindex = vp - simsp;
50464:     }
50464: 
50464:     if (!spindex)
50464:         spindex = ((flags & JSV2F_SEARCH_STACK) ? JSDVG_SEARCH_STACK : JSDVG_IGNORE_STACK);
42717: 
42717:     js_ReportValueError3(cx, error, spindex, *vp, NULL, name, source);
    1: }
