     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 29956: /* nsPluginHost.cpp - top-level plugin management code */
     1: 
     1: #include "nscore.h"
 29956: #include "nsPluginHost.h"
     1: 
     1: #include <stdio.h>
     1: #include "prio.h"
     1: #include "prmem.h"
 46998: #include "nsIComponentManager.h"
 19246: #include "nsNPAPIPlugin.h"
 19246: #include "nsNPAPIPluginStreamListener.h"
 29834: #include "nsNPAPIPluginInstance.h"
101150: #include "nsPluginInstanceOwner.h"
101150: #include "nsObjectLoadingContent.h"
     1: #include "nsIHTTPHeaderListener.h"
     1: #include "nsIHttpHeaderVisitor.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIHttpProtocolHandler.h"
     1: #include "nsIHttpChannel.h"
     1: #include "nsIHttpChannelInternal.h"
     1: #include "nsIUploadChannel.h"
     1: #include "nsIByteRangeRequest.h"
     1: #include "nsIStreamListener.h"
     1: #include "nsIInputStream.h"
     1: #include "nsIOutputStream.h"
     1: #include "nsIURL.h"
127628: #include "nsTArray.h"
     1: #include "nsReadableUtils.h"
115189: #include "nsIProtocolProxyService2.h"
     1: #include "nsIStreamConverterService.h"
     1: #include "nsIFile.h"
 95062: #if defined(XP_MACOSX)
 95062: #include "nsILocalFileMac.h"
 95062: #endif
     1: #include "nsIInputStream.h"
     1: #include "nsIIOService.h"
     1: #include "nsIURL.h"
     1: #include "nsIChannel.h"
     1: #include "nsISeekableStream.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIProgressEventSink.h"
     1: #include "nsIDocument.h"
     1: #include "nsICachingChannel.h"
     1: #include "nsHashtable.h"
     1: #include "nsIProxyInfo.h"
     1: #include "nsPluginLogging.h"
     1: #include "nsIScriptChannel.h"
 21189: #include "nsIBlocklistService.h"
 21192: #include "nsVersionComparator.h"
 37151: #include "nsIObjectLoadingContent.h"
 38026: #include "nsIWritablePropertyBag2.h"
104192: #include "nsICategoryManager.h"
 47361: #include "nsPluginStreamListenerPeer.h"
 94707: #include "mozilla/Preferences.h"
     1: 
     1: #include "nsEnumeratorUtils.h"
     1: #include "nsXPCOM.h"
     1: #include "nsXPCOMCID.h"
     1: #include "nsISupportsPrimitives.h"
 24790: 
 80300: #include "nsXULAppAPI.h"
 59080: #include "nsIXULRuntime.h"
 59080: 
     1: // for the dialog
     1: #include "nsIWindowWatcher.h"
132214: #include "nsIDOMWindow.h"
     1: 
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptGlobalObjectOwner.h"
     1: #include "nsIPrincipal.h"
     1: 
     1: #include "nsNetCID.h"
     1: #include "nsIDOMPlugin.h"
     1: #include "nsIDOMMimeType.h"
     1: #include "nsMimeTypes.h"
     1: #include "prprf.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsIInputStreamTee.h"
     1: #include "nsIInterfaceInfoManager.h"
     1: #include "xptinfo.h"
     1: 
     1: #include "nsIMIMEService.h"
     1: #include "nsCExternalHandlerService.h"
     1: #include "nsIFileChannel.h"
     1: 
     1: #include "nsPluginSafety.h"
     1: 
     1: #include "nsICharsetConverterManager.h"
     1: #include "nsIPlatformCharset.h"
     1: 
     1: #include "nsIDirectoryService.h"
     1: #include "nsDirectoryServiceDefs.h"
 32940: #include "nsXULAppAPI.h"
     1: #include "nsAppDirectoryServiceDefs.h"
     1: #include "nsPluginDirServiceProvider.h"
108290: #include "nsError.h"
     1: 
     1: #include "nsUnicharUtils.h"
     1: #include "nsPluginManifestLineReader.h"
     1: 
 39118: #include "nsIWeakReferenceUtils.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMHTMLObjectElement.h"
     1: #include "nsIDOMHTMLEmbedElement.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIDocShell.h"
     1: #include "nsPluginNativeWindow.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIContentPolicy.h"
     1: #include "nsContentPolicyUtils.h"
 37525: #include "mozilla/TimeStamp.h"
 72923: #include "mozilla/Telemetry.h"
 89114: #include "nsIImageLoadingContent.h"
 84557: #include "mozilla/Preferences.h"
101944: #include "nsVersionComparator.h"
     1: 
 24790: #if defined(XP_WIN)
 56921: #include "nsIWindowMediator.h"
 56921: #include "nsIBaseWindow.h"
 24790: #include "windows.h"
 24790: #include "winbase.h"
 24790: #endif
 24790: 
 78424: #ifdef ANDROID
 78424: #include <android/log.h>
 78424: #define LOG(args...)  __android_log_print(ANDROID_LOG_INFO, "GeckoPlugins" , ## args)
 78424: #endif
 78424: 
 62174: using namespace mozilla;
 37525: using mozilla::TimeStamp;
 37525: 
 31646: // Null out a strong ref to a linked list iteratively to avoid
 31646: // exhausting the stack (bug 486349).
 31646: #define NS_ITERATIVE_UNREF_LIST(type_, list_, mNext_)                \
 31646:   {                                                                  \
 31646:     while (list_) {                                                  \
 31646:       type_ temp = list_->mNext_;                                    \
106838:       list_->mNext_ = nullptr;                                        \
 31646:       list_ = temp;                                                  \
 31646:     }                                                                \
 31646:   }
 31646: 
     1: // this is the name of the directory which will be created
     1: // to cache temporary files.
     1: #define kPluginTmpDirName NS_LITERAL_CSTRING("plugtmp")
     1: 
103876: static const char *kPrefWhitelist = "plugin.allowed_types";
104192: static const char *kPrefDisableFullPage = "plugin.disable_full_page_plugin_for_types";
103876: 
     1: // Version of cached plugin info
 64609: // 0.01 first implementation
 64609: // 0.02 added caching of CanUnload to fix bug 105935
 64609: // 0.03 changed name, description and mime desc from string to bytes, bug 108246
 64609: // 0.04 added new mime entry point on Mac, bug 113464
 64609: // 0.05 added new entry point check for the default plugin, bug 132430
 64609: // 0.06 strip off suffixes in mime description strings, bug 53895
 64609: // 0.07 changed nsIRegistry to flat file support for caching plugins info
 64609: // 0.08 mime entry point on MachO, bug 137535
 64609: // 0.09 the file encoding is changed to UTF-8, bug 420285
 64609: // 0.10 added plugin versions on appropriate platforms, bug 427743
 64609: // 0.11 file name and full path fields now store expected values on all platforms, bug 488181
 64609: // 0.12 force refresh due to quicktime pdf claim fix, bug 611197
 64609: // 0.13 add architecture and list of invalid plugins, bug 616271
 64609: // 0.14 force refresh due to locale comparison fix, bug 611296
 64609: // 0.15 force refresh due to bug in reading Java plist MIME data, bug 638171
 64609: // The current plugin registry version (and the maximum version we know how to read)
 64609: static const char *kPluginRegistryVersion = "0.15";
 64609: // The minimum registry version we know how to read
 64609: static const char *kMinimumRegistryVersion = "0.9";
 21231: 
 29952: static NS_DEFINE_IID(kIPluginTagInfoIID, NS_IPLUGINTAGINFO_IID);
     1: static const char kDirectoryServiceContractID[] = "@mozilla.org/file/directory_service;1";
     1: 
     1: // Registry keys for caching plugin info
     1: static const char kPluginsRootKey[] = "software/plugins";
     1: static const char kPluginsNameKey[] = "name";
     1: static const char kPluginsDescKey[] = "description";
     1: static const char kPluginsFilenameKey[] = "filename";
     1: static const char kPluginsFullpathKey[] = "fullpath";
     1: static const char kPluginsModTimeKey[] = "lastModTimeStamp";
     1: static const char kPluginsCanUnload[] = "canUnload";
     1: static const char kPluginsVersionKey[] = "version";
     1: static const char kPluginsMimeTypeKey[] = "mimetype";
     1: static const char kPluginsMimeDescKey[] = "description";
     1: static const char kPluginsMimeExtKey[] = "extension";
     1: 
     1: #define kPluginRegistryFilename NS_LITERAL_CSTRING("pluginreg.dat")
     1: 
     1: #ifdef PLUGIN_LOGGING
106838: PRLogModuleInfo* nsPluginLogging::gNPNLog = nullptr;
106838: PRLogModuleInfo* nsPluginLogging::gNPPLog = nullptr;
106838: PRLogModuleInfo* nsPluginLogging::gPluginLog = nullptr;
     1: #endif
     1: 
 82172: // #defines for plugin cache and prefs
 82172: #define NS_PREF_MAX_NUM_CACHED_INSTANCES "browser.plugins.max_num_cached_plugins"
 84323: // Raise this from '10' to '50' to work around a bug in Apple's current Java
 84323: // plugins on OS X Lion and SnowLeopard.  See bug 705931.
 84323: #define DEFAULT_NUMBER_OF_STOPPED_INSTANCES 50
 82172: 
 29956: nsIFile *nsPluginHost::sPluginTempDir;
 29956: nsPluginHost *nsPluginHost::sInst;
     1: 
 59080: NS_IMPL_ISUPPORTS0(nsInvalidPluginTag)
 59080: 
108991: nsInvalidPluginTag::nsInvalidPluginTag(const char* aFullPath, int64_t aLastModifiedTime)
 59080: : mFullPath(aFullPath),
 59080:   mLastModifiedTime(aLastModifiedTime),
 59538:   mSeen(false)
125841: {}
 59080: 
 59080: nsInvalidPluginTag::~nsInvalidPluginTag()
125841: {}
 59080: 
103876: // Helper to check for a MIME in a comma-delimited preference
103876: static bool
104191: IsTypeInList(nsCString &aMimeType, nsCString aTypeList)
103876: {
110974:   nsAutoCString searchStr;
103876:   searchStr.Assign(',');
104191:   searchStr.Append(aTypeList);
103876:   searchStr.Append(',');
103876: 
103876:   nsACString::const_iterator start, end;
103876: 
103876:   searchStr.BeginReading(start);
103876:   searchStr.EndReading(end);
103876: 
110974:   nsAutoCString commaSeparated;
103876:   commaSeparated.Assign(',');
103876:   commaSeparated += aMimeType;
103876:   commaSeparated.Append(',');
103876: 
103876:   return FindInReadable(commaSeparated, start, end);
103876: }
103876: 
     1: // flat file reg funcs
     1: static
 79445: bool ReadSectionHeader(nsPluginManifestLineReader& reader, const char *token)
     1: {
     1:   do {
     1:     if (*reader.LinePtr() == '[') {
     1:       char* p = reader.LinePtr() + (reader.LineLength() - 1);
     1:       if (*p != ']')
     1:         break;
     1:       *p = 0;
     1: 
     1:       char* values[1];
     1:       if (1 != reader.ParseLine(values, 1))
     1:         break;
     1:       // ignore the leading '['
     1:       if (PL_strcmp(values[0]+1, token)) {
     1:         break; // it's wrong token
     1:       }
 79533:       return true;
     1:     }
     1:   } while (reader.NextLine());
 79533:   return false;
     1: }
     1: 
     1: // Little helper struct to asynchronously reframe any presentations (embedded)
     1: // or reload any documents (full-page), that contained plugins
     1: // which were shutdown as a result of a plugins.refresh(1)
     1: class nsPluginDocReframeEvent: public nsRunnable {
     1: public:
127628:   nsPluginDocReframeEvent(nsTArray<nsCOMPtr<nsIDocument> >& aDocs) { mDocs.SwapElements(aDocs); }
     1: 
     1:   NS_DECL_NSIRUNNABLE
     1: 
127628:   nsTArray<nsCOMPtr<nsIDocument> > mDocs;
     1: };
     1: 
     1: NS_IMETHODIMP nsPluginDocReframeEvent::Run() {
127628:   uint32_t c = mDocs.Length();
     1: 
     1:   // for each document (which previously had a running instance), tell
     1:   // the frame constructor to rebuild
108991:   for (uint32_t i = 0; i < c; i++) {
127628:     nsIDocument* doc = mDocs[i];
     1:     if (doc) {
 46225:       nsIPresShell *shell = doc->GetShell();
     1: 
     1:       // if this document has a presentation shell, then it has frames and can be reframed
     1:       if (shell) {
 21231:         /* A reframe will cause a fresh object frame, instance owner, and instance
     1:          * to be created. Reframing of the entire document is necessary as we may have
     1:          * recently found new plugins and we want a shot at trying to use them instead
     1:          * of leaving alternate renderings.
     1:          * We do not want to completely reload all the documents that had running plugins
     1:          * because we could possibly trigger a script to run in the unload event handler
     1:          * which may want to access our defunct plugin and cause us to crash.
     1:          */
     1: 
     1:         shell->ReconstructFrames(); // causes reframe of document
     1:       } else {  // no pres shell --> full-page plugin
     1: 
     1:         NS_NOTREACHED("all plugins should have a pres shell!");
     1: 
     1:       }
     1:     }
     1:   }
     1: 
127628:   mDocs.Clear();
127628:   return NS_OK;
     1: }
     1: 
 79445: static bool UnloadPluginsASAP()
 50781: {
 94707:   return Preferences::GetBool("dom.ipc.plugins.unloadASAP", false);
 50781: }
 50781: 
 29956: nsPluginHost::nsPluginHost()
106838:   // No need to initialize members to nullptr, false etc because this class
 31646:   // has a zeroing operator new.
 31800: {
     1:   // check to see if pref is set at startup to let plugins take over in
     1:   // full page mode for certain image mime types that we handle internally
 94707:   mOverrideInternalTypes =
 94707:     Preferences::GetBool("plugin.override_internal_types", false);
 94707: 
 94707:   mPluginsDisabled = Preferences::GetBool("plugin.disable", false);
104371:   mPluginsClickToPlay = Preferences::GetBool("plugins.click_to_play", false);
     1: 
 96798:   Preferences::AddStrongObserver(this, "plugin.disable");
104371:   Preferences::AddStrongObserver(this, "plugins.click_to_play");
 96798: 
 41540:   nsCOMPtr<nsIObserverService> obsService =
 41540:     mozilla::services::GetObserverService();
 24475:   if (obsService) {
 79533:     obsService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);
 90194: #ifdef MOZ_WIDGET_ANDROID
 90194:     obsService->AddObserver(this, "application-foreground", false);
 90194:     obsService->AddObserver(this, "application-background", false);
 90194: #endif
     1:   }
     1: 
     1: #ifdef PLUGIN_LOGGING
     1:   nsPluginLogging::gNPNLog = PR_NewLogModule(NPN_LOG_NAME);
     1:   nsPluginLogging::gNPPLog = PR_NewLogModule(NPP_LOG_NAME);
     1:   nsPluginLogging::gPluginLog = PR_NewLogModule(PLUGIN_LOG_NAME);
     1: 
     1:   PR_LOG(nsPluginLogging::gNPNLog, PLUGIN_LOG_ALWAYS,("NPN Logging Active!\n"));
 29956:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_ALWAYS,("General Plugin Logging Active! (nsPluginHost::ctor)\n"));
     1:   PR_LOG(nsPluginLogging::gNPPLog, PLUGIN_LOG_ALWAYS,("NPP Logging Active!\n"));
     1: 
 29956:   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHost::ctor\n"));
     1:   PR_LogFlush();
     1: #endif
     1: }
     1: 
 29956: nsPluginHost::~nsPluginHost()
 29956: {
 29956:   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHost::dtor\n"));
     1: 
 96798:   UnloadPlugins();
106838:   sInst = nullptr;
     1: }
     1: 
 67851: NS_IMPL_ISUPPORTS4(nsPluginHost,
     1:                    nsIPluginHost,
     1:                    nsIObserver,
 36297:                    nsITimerCallback,
     1:                    nsISupportsWeakReference)
 21231: 
 29956: nsPluginHost*
 29956: nsPluginHost::GetInst()
     1: {
     1:   if (!sInst) {
 29956:     sInst = new nsPluginHost();
 21231:     if (!sInst)
106838:       return nullptr;
     1:     NS_ADDREF(sInst);
     1:   }
     1: 
     1:   NS_ADDREF(sInst);
     1:   return sInst;
     1: }
     1: 
 94676: bool nsPluginHost::IsRunningPlugin(nsPluginTag * aPluginTag)
     1: {
 94676:   if (!aPluginTag || !aPluginTag->mPlugin) {
 79533:     return false;
 64172:   }
 64172: 
108991:   for (uint32_t i = 0; i < mInstances.Length(); i++) {
 64172:     nsNPAPIPluginInstance *instance = mInstances[i].get();
 64172:     if (instance &&
 94676:         instance->GetPlugin() == aPluginTag->mPlugin &&
 64172:         instance->IsRunning()) {
 79533:       return true;
 79533:     }
 79533:   }
 79533: 
 79533:   return false;
     1: }
     1: 
 79445: nsresult nsPluginHost::ReloadPlugins(bool reloadPages)
     1: {
     1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 29956:   ("nsPluginHost::ReloadPlugins Begin reloadPages=%d, active_instance_count=%d\n",
 47965:   reloadPages, mInstances.Length()));
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   // this will create the initial plugin list out of cache
     1:   // if it was not created yet
     1:   if (!mPluginsLoaded)
     1:     return LoadPlugins();
     1: 
     1:   // we are re-scanning plugins. New plugins may have been added, also some
     1:   // plugins may have been removed, so we should probably shut everything down
     1:   // but don't touch running (active and not stopped) plugins
     1: 
     1:   // check if plugins changed, no need to do anything else
     1:   // if no changes to plugins have been made
 79533:   // false instructs not to touch the plugin list, just to
     1:   // look for possible changes
 79445:   bool pluginschanged = true;
 79533:   FindPlugins(false, &pluginschanged);
     1: 
     1:   // if no changed detected, return an appropriate error code
     1:   if (!pluginschanged)
     1:     return NS_ERROR_PLUGINS_PLUGINSNOTCHANGED;
     1: 
127628:   nsTArray<nsCOMPtr<nsIDocument> > instsToReload;
     1:   if (reloadPages) {
     1: 
     1:     // Then stop any running plugin instances but hold on to the documents in the array
     1:     // We are going to need to restart the instances in these documents later
127628:     DestroyRunningInstances(&instsToReload, nullptr);
 37525:   }
     1: 
     1:   // shutdown plugins and kill the list if there are no running plugins
  3102:   nsRefPtr<nsPluginTag> prev;
  3102:   nsRefPtr<nsPluginTag> next;
  3102: 
106838:   for (nsRefPtr<nsPluginTag> p = mPlugins; p != nullptr;) {
     1:     next = p->mNext;
     1: 
 29079:     // only remove our plugin from the list if it's not running.
 29079:     if (!IsRunningPlugin(p)) {
     1:       if (p == mPlugins)
     1:         mPlugins = next;
     1:       else
     1:         prev->mNext = next;
     1: 
106838:       p->mNext = nullptr;
 35426: 
 35426:       // attempt to unload plugins whenever they are removed from the list
 90104:       p->TryUnloadPlugin(false);
 35426: 
     1:       p = next;
     1:       continue;
     1:     }
     1: 
     1:     prev = p;
     1:     p = next;
     1:   }
     1: 
     1:   // set flags
 79533:   mPluginsLoaded = false;
     1: 
     1:   // load them again
     1:   rv = LoadPlugins();
     1: 
     1:   // If we have shut down any plugin instances, we've now got to restart them.
     1:   // Post an event to do the rest as we are going to be destroying the frame tree and we also want
     1:   // any posted unload events to finish
127628:   if (reloadPages && !instsToReload.IsEmpty()){
     1:     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
     1:     if (ev)
     1:       NS_DispatchToCurrentThread(ev);
     1:   }
     1: 
     1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 29956:   ("nsPluginHost::ReloadPlugins End active_instance_count=%d\n",
 47965:   mInstances.Length()));
     1: 
     1:   return rv;
     1: }
     1: 
     1: #define NS_RETURN_UASTRING_SIZE 128
     1: 
 29956: nsresult nsPluginHost::UserAgent(const char **retstring)
     1: {
     1:   static char resultString[NS_RETURN_UASTRING_SIZE];
     1:   nsresult res;
     1: 
     1:   nsCOMPtr<nsIHttpProtocolHandler> http = do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &res);
     1:   if (NS_FAILED(res))
     1:     return res;
     1: 
110974:   nsAutoCString uaString;
     1:   res = http->GetUserAgent(uaString);
     1: 
 21231:   if (NS_SUCCEEDED(res)) {
 21231:     if (NS_RETURN_UASTRING_SIZE > uaString.Length()) {
     1:       PL_strcpy(resultString, uaString.get());
 21231:     } else {
 16368:       // Copy as much of UA string as we can (terminate at right-most space).
 16368:       PL_strncpy(resultString, uaString.get(), NS_RETURN_UASTRING_SIZE);
 21231:       for (int i = NS_RETURN_UASTRING_SIZE - 1; i >= 0; i--) {
 21231:         if (i == 0) {
 16368:           resultString[NS_RETURN_UASTRING_SIZE - 1] = '\0';
 21231:         }
 21231:         else if (resultString[i] == ' ') {
 16368:           resultString[i] = '\0';
 16368:           break;
 16368:         }
 16368:       }
 16368:     }
     1:     *retstring = resultString;
     1:   }
 21231:   else {
106838:     *retstring = nullptr;
 21231:   }
     1: 
 29956:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::UserAgent return=%s\n", *retstring));
     1: 
     1:   return res;
     1: }
     1: 
 29956: nsresult nsPluginHost::GetPrompt(nsIPluginInstanceOwner *aOwner, nsIPrompt **aPrompt)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIPrompt> prompt;
     1:   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
     1: 
     1:   if (wwatch) {
     1:     nsCOMPtr<nsIDOMWindow> domWindow;
     1:     if (aOwner) {
     1:       nsCOMPtr<nsIDocument> document;
     1:       aOwner->GetDocument(getter_AddRefs(document));
     1:       if (document) {
     1:         domWindow = document->GetWindow();
     1:       }
     1:     }
     1: 
     1:     if (!domWindow) {
106838:       wwatch->GetWindowByName(NS_LITERAL_STRING("_content").get(), nullptr, getter_AddRefs(domWindow));
     1:     }
     1:     rv = wwatch->GetNewPrompter(domWindow, getter_AddRefs(prompt));
     1:   }
     1: 
     1:   NS_IF_ADDREF(*aPrompt = prompt);
     1:   return rv;
     1: }
     1: 
 70185: nsresult nsPluginHost::GetURL(nsISupports* pluginInst,
     1:                               const char* url,
     1:                               const char* target,
 98780:                               nsNPAPIPluginStreamListener* streamListener,
     1:                               const char* altHost,
     1:                               const char* referrer,
 79445:                               bool forceJSEnabled)
     1: {
 47835:   return GetURLWithHeaders(static_cast<nsNPAPIPluginInstance*>(pluginInst),
 47835:                            url, target, streamListener, altHost, referrer,
106838:                            forceJSEnabled, 0, nullptr);
 47835: }
 47835: 
 47835: nsresult nsPluginHost::GetURLWithHeaders(nsNPAPIPluginInstance* pluginInst,
     1:                                          const char* url,
     1:                                          const char* target,
 98780:                                          nsNPAPIPluginStreamListener* streamListener,
     1:                                          const char* altHost,
     1:                                          const char* referrer,
 79445:                                          bool forceJSEnabled,
108991:                                          uint32_t getHeadersLength,
     1:                                          const char* getHeaders)
     1: {
     1:   // we can only send a stream back to the plugin (as specified by a
 98780:   // null target) if we also have a nsNPAPIPluginStreamListener to talk to
 21231:   if (!target && !streamListener)
     1:     return NS_ERROR_ILLEGAL_VALUE;
     1: 
 47835:   nsresult rv = DoURLLoadSecurityCheck(pluginInst, url);
 34262:   if (NS_FAILED(rv))
 34262:     return rv;
 34262: 
 21231:   if (target) {
115860:     nsRefPtr<nsPluginInstanceOwner> owner = pluginInst->GetOwner();
 21231:     if (owner) {
     1:       if ((0 == PL_strcmp(target, "newwindow")) ||
     1:           (0 == PL_strcmp(target, "_new")))
     1:         target = "_blank";
     1:       else if (0 == PL_strcmp(target, "_current"))
     1:         target = "_self";
     1: 
106838:       rv = owner->GetURL(url, target, nullptr, nullptr, 0);
     1:     }
     1:   }
     1: 
 34262:   if (streamListener)
 82609:     rv = NewPluginURLStream(NS_ConvertUTF8toUTF16(url), pluginInst,
106838:                             streamListener, nullptr,
 36766:                             getHeaders, getHeadersLength);
     1: 
     1:   return rv;
     1: }
     1: 
 70185: nsresult nsPluginHost::PostURL(nsISupports* pluginInst,
     1:                                     const char* url,
108991:                                     uint32_t postDataLen,
     1:                                     const char* postData,
 79445:                                     bool isFile,
     1:                                     const char* target,
 98780:                                     nsNPAPIPluginStreamListener* streamListener,
     1:                                     const char* altHost,
     1:                                     const char* referrer,
 79445:                                     bool forceJSEnabled,
108991:                                     uint32_t postHeadersLength,
     1:                                     const char* postHeaders)
     1: {
     1:   nsresult rv;
     1: 
     1:   // we can only send a stream back to the plugin (as specified
 98780:   // by a null target) if we also have a nsNPAPIPluginStreamListener
     1:   // to talk to also
 21231:   if (!target && !streamListener)
     1:     return NS_ERROR_ILLEGAL_VALUE;
     1: 
 47835:   nsNPAPIPluginInstance* instance = static_cast<nsNPAPIPluginInstance*>(pluginInst);
 34262: 
     1:   rv = DoURLLoadSecurityCheck(instance, url);
 34262:   if (NS_FAILED(rv))
 34262:     return rv;
 34262: 
 36766:   nsCOMPtr<nsIInputStream> postStream;
     1:   if (isFile) {
 36766:     nsCOMPtr<nsIFile> file;
 36766:     rv = CreateTempFileToPost(postData, getter_AddRefs(file));
 36766:     if (NS_FAILED(rv))
 36766:       return rv;
 36766: 
 36766:     nsCOMPtr<nsIInputStream> fileStream;
 36766:     rv = NS_NewLocalFileInputStream(getter_AddRefs(fileStream),
 36766:                                     file,
 36766:                                     PR_RDONLY,
 36766:                                     0600,
 36766:                                     nsIFileInputStream::DELETE_ON_CLOSE |
 36766:                                     nsIFileInputStream::CLOSE_ON_EOF);
 36766:     if (NS_FAILED(rv))
 36766:       return rv;
 36766: 
 36766:     rv = NS_NewBufferedInputStream(getter_AddRefs(postStream), fileStream, 8192);
 36766:     if (NS_FAILED(rv))
 21231:       return rv;
     1:   } else {
 36766:     char *dataToPost;
108991:     uint32_t newDataToPostLen;
     1:     ParsePostBufferToFixHeaders(postData, postDataLen, &dataToPost, &newDataToPostLen);
     1:     if (!dataToPost)
     1:       return NS_ERROR_UNEXPECTED;
     1: 
 36766:     nsCOMPtr<nsIStringInputStream> sis = do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
 36766:     if (!sis) {
 36766:       NS_Free(dataToPost);
 36766:       return rv;
 36766:     }
 36766: 
 36766:     // data allocated by ParsePostBufferToFixHeaders() is managed and
 36766:     // freed by the string stream.
     1:     postDataLen = newDataToPostLen;
 36766:     sis->AdoptData(dataToPost, postDataLen);
 36766:     postStream = sis;
     1:   }
     1: 
 21231:   if (target) {
115860:     nsRefPtr<nsPluginInstanceOwner> owner = instance->GetOwner();
 21231:     if (owner) {
     1:       if ((0 == PL_strcmp(target, "newwindow")) ||
 21231:           (0 == PL_strcmp(target, "_new"))) {
     1:         target = "_blank";
 29834:       } else if (0 == PL_strcmp(target, "_current")) {
     1:         target = "_self";
     1:       }
 36766:       rv = owner->GetURL(url, target, postStream,
 36766:                          (void*)postHeaders, postHeadersLength);
     1:     }
     1:   }
     1: 
     1:   // if we don't have a target, just create a stream.  This does
     1:   // NS_OpenURI()!
 21231:   if (streamListener)
 82609:     rv = NewPluginURLStream(NS_ConvertUTF8toUTF16(url), instance,
 82609:                             streamListener,
 36766:                             postStream, postHeaders, postHeadersLength);
     1: 
     1:   return rv;
     1: }
     1: 
 21231: /* This method queries the prefs for proxy information.
     1:  * It has been tested and is known to work in the following three cases
     1:  * when no proxy host or port is specified
     1:  * when only the proxy host is specified
     1:  * when only the proxy port is specified
     1:  * This method conforms to the return code specified in
     1:  * http://developer.netscape.com/docs/manuals/proxy/adminnt/autoconf.htm#1020923
     1:  * with the exception that multiple values are not implemented.
     1:  */
     1: 
 70185: nsresult nsPluginHost::FindProxyForURL(const char* url, char* *result)
     1: {
     1:   if (!url || !result) {
     1:     return NS_ERROR_INVALID_ARG;
     1:   }
     1:   nsresult res;
     1: 
     1:   nsCOMPtr<nsIURI> uriIn;
     1:   nsCOMPtr<nsIProtocolProxyService> proxyService;
115189:   nsCOMPtr<nsIProtocolProxyService2> proxyService2;
     1:   nsCOMPtr<nsIIOService> ioService;
     1: 
     1:   proxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &res);
 21231:   if (NS_FAILED(res) || !proxyService)
     1:     return res;
     1: 
115189:   proxyService2 = do_QueryInterface(proxyService, &res);
115577:   if (NS_FAILED(res) || !proxyService2)
115189:     return res;
115189: 
     1:   ioService = do_GetService(NS_IOSERVICE_CONTRACTID, &res);
 21231:   if (NS_FAILED(res) || !ioService)
     1:     return res;
     1: 
     1:   // make an nsURI from the argument url
106838:   res = ioService->NewURI(nsDependentCString(url), nullptr, nullptr, getter_AddRefs(uriIn));
 21231:   if (NS_FAILED(res))
     1:     return res;
     1: 
     1:   nsCOMPtr<nsIProxyInfo> pi;
     1: 
115189:   // Remove this with bug 778201
115189:   res = proxyService2->DeprecatedBlockingResolve(uriIn, 0, getter_AddRefs(pi));
 21231:   if (NS_FAILED(res))
     1:     return res;
     1: 
110974:   nsAutoCString host, type;
108991:   int32_t port = -1;
     1: 
     1:   // These won't fail, and even if they do... we'll be ok.
     1:   if (pi) {
     1:     pi->GetType(type);
     1:     pi->GetHost(host);
     1:     pi->GetPort(&port);
     1:   }
     1: 
     1:   if (!pi || host.IsEmpty() || port <= 0 || host.EqualsLiteral("direct")) {
     1:     *result = PL_strdup("DIRECT");
     1:   } else if (type.EqualsLiteral("http")) {
     1:     *result = PR_smprintf("PROXY %s:%d", host.get(), port);
     1:   } else if (type.EqualsLiteral("socks4")) {
     1:     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
     1:   } else if (type.EqualsLiteral("socks")) {
     1:     // XXX - this is socks5, but there is no API for us to tell the
     1:     // plugin that fact. SOCKS for now, in case the proxy server
     1:     // speaks SOCKS4 as well. See bug 78176
     1:     // For a long time this was returning an http proxy type, so
     1:     // very little is probably broken by this
     1:     *result = PR_smprintf("SOCKS %s:%d", host.get(), port);
     1:   } else {
 79533:     NS_ASSERTION(false, "Unknown proxy type!");
     1:     *result = PL_strdup("DIRECT");
     1:   }
     1: 
106838:   if (nullptr == *result)
     1:     res = NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   return res;
     1: }
     1: 
 70185: nsresult nsPluginHost::Init()
     1: {
     1:   return NS_OK;
     1: }
     1: 
 96798: nsresult nsPluginHost::UnloadPlugins()
 29956: {
 96798:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::UnloadPlugins Called\n"));
 96798: 
 96798:   if (!mPluginsLoaded)
     1:     return NS_OK;
     1: 
     1:   // we should call nsIPluginInstance::Stop and nsIPluginInstance::SetWindow
     1:   // for those plugins who want it
106838:   DestroyRunningInstances(nullptr, nullptr);
     1: 
 35426:   nsPluginTag *pluginTag;
 35426:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
 90104:     pluginTag->TryUnloadPlugin(true);
     1:   }
     1: 
 31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mPlugins, mNext);
 31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59080:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
     1: 
     1:   // Lets remove any of the temporary files that we created.
     1:   if (sPluginTempDir) {
 79533:     sPluginTempDir->Remove(true);
     1:     NS_RELEASE(sPluginTempDir);
     1:   }
     1: 
  3715: #ifdef XP_WIN
 21231:   if (mPrivateDirServiceProvider) {
     1:     nsCOMPtr<nsIDirectoryService> dirService =
     1:       do_GetService(kDirectoryServiceContractID);
     1:     if (dirService)
     1:       dirService->UnregisterProvider(mPrivateDirServiceProvider);
106838:     mPrivateDirServiceProvider = nullptr;
     1:   }
  3715: #endif /* XP_WIN */
     1: 
 96798:   mPluginsLoaded = false;
 96798: 
     1:   return NS_OK;
     1: }
     1: 
 37525: void nsPluginHost::OnPluginInstanceDestroyed(nsPluginTag* aPluginTag)
 37525: {
 79445:   bool hasInstance = false;
108991:   for (uint32_t i = 0; i < mInstances.Length(); i++) {
 47965:     if (TagForPlugin(mInstances[i]->GetPlugin()) == aPluginTag) {
 79533:       hasInstance = true;
 37525:       break;
 37525:     }
 37525:   }
 37525: 
 90104:   // We have some options for unloading plugins if they have no instances.
 90104:   //
 90104:   // Unloading plugins immediately can be bad - some plugins retain state
 90104:   // between instances even when there are none. This is largely limited to
 90104:   // going from one page to another, so state is retained without an instance
 90104:   // for only a very short period of time. In order to allow this to work
 90104:   // we don't unload plugins immediately by default. This is supported
 90104:   // via a hidden user pref though.
 90104:   //
 90104:   // Another reason not to unload immediately is that loading is expensive,
 90104:   // and it is better to leave popular plugins loaded.
 90104:   //
 90104:   // Our default behavior is to try to unload a plugin three minutes after
 90104:   // its last instance is destroyed. This seems like a reasonable compromise
 90104:   // that allows us to reclaim memory while allowing short state retention
 90104:   // and avoid perf hits for loading popular plugins.
 90104:   if (!hasInstance) {
 90104:     if (UnloadPluginsASAP()) {
 90104:       aPluginTag->TryUnloadPlugin(false);
 90104:     } else {
 90104:       if (aPluginTag->mUnloadTimer) {
 90104:         aPluginTag->mUnloadTimer->Cancel();
 90104:       } else {
 90104:         aPluginTag->mUnloadTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
 90104:       }
 90104:       aPluginTag->mUnloadTimer->InitWithCallback(this, 1000 * 60 * 3, nsITimer::TYPE_ONE_SHOT);
 90104:     }
 37525:   }
 37525: }
 37525: 
     1: nsresult
 29956: nsPluginHost::GetPluginTempDir(nsIFile **aDir)
     1: {
     1:   if (!sPluginTempDir) {
     1:     nsCOMPtr<nsIFile> tmpDir;
     1:     nsresult rv = NS_GetSpecialDirectory(NS_OS_TEMP_DIR,
     1:                                          getter_AddRefs(tmpDir));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     rv = tmpDir->AppendNative(kPluginTmpDirName);
     1: 
     1:     // make it unique, and mode == 0700, not world-readable
     1:     rv = tmpDir->CreateUnique(nsIFile::DIRECTORY_TYPE, 0700);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     tmpDir.swap(sPluginTempDir);
     1:   }
     1: 
     1:   return sPluginTempDir->Clone(aDir);
     1: }
     1: 
 56390: nsresult
125843: nsPluginHost::InstantiatePluginInstance(const char *aMimeType, nsIURI* aURL,
 89114:                                         nsObjectLoadingContent *aContent,
 89114:                                         nsPluginInstanceOwner** aOwner)
 56390: {
     1:   NS_ENSURE_ARG_POINTER(aOwner);
     1: 
     1: #ifdef PLUGIN_LOGGING
110974:   nsAutoCString urlSpec;
 21231:   if (aURL)
 21231:     aURL->GetAsciiSpec(urlSpec);
     1: 
     1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
125843:         ("nsPluginHost::InstantiatePlugin Begin mime=%s, url=%s\n",
 89114:         aMimeType, urlSpec.get()));
     1: 
     1:   PR_LogFlush();
     1: #endif
     1: 
125839:   if (!aMimeType) {
125839:     NS_NOTREACHED("Attempting to spawn a plugin with no mime type");
125839:     return NS_ERROR_FAILURE;
125839:   }
125839: 
 89114:   nsRefPtr<nsPluginInstanceOwner> instanceOwner = new nsPluginInstanceOwner();
 89114:   if (!instanceOwner) {
 89114:     return NS_ERROR_OUT_OF_MEMORY;
 89114:   }
 89114: 
 89114:   nsCOMPtr<nsIContent> ourContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(aContent));
 89114:   nsresult rv = instanceOwner->Init(ourContent);
 89114:   if (NS_FAILED(rv)) {
 89114:     return rv;
 89114:   }
 89114: 
 29952:   nsCOMPtr<nsIPluginTagInfo> pti;
 89114:   rv = instanceOwner->QueryInterface(kIPluginTagInfoIID, getter_AddRefs(pti));
 89114:   if (NS_FAILED(rv)) {
 89114:     return rv;
 89114:   }
 89114: 
     1:   nsPluginTagType tagType;
 89114:   rv = pti->GetTagType(&tagType);
 89114:   if (NS_FAILED(rv)) {
     1:     return rv;
 89114:   }
 89114: 
 89114:   if (tagType != nsPluginTagType_Embed &&
 89114:       tagType != nsPluginTagType_Applet &&
 89114:       tagType != nsPluginTagType_Object) {
 89114:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 89114:   rv = SetUpPluginInstance(aMimeType, aURL, instanceOwner);
 89114:   if (NS_FAILED(rv)) {
 89114:     return NS_ERROR_FAILURE;
 89114:   }
 47835: 
 70007:   nsRefPtr<nsNPAPIPluginInstance> instance;
 89114:   rv = instanceOwner->GetInstance(getter_AddRefs(instance));
 89114:   if (NS_FAILED(rv)) {
 47835:     return rv;
 89114:   }
 47835: 
 47835:   if (instance) {
 89114:     instanceOwner->CreateWidget();
 47835: 
 47835:     // If we've got a native window, the let the plugin know about it.
 89114:     instanceOwner->CallSetWindow();
 89114:   }
 89114: 
 89114:   // At this point we consider instantiation to be successful. Do not return an error.
 89114:   instanceOwner.forget(aOwner);
     1: 
     1: #ifdef PLUGIN_LOGGING
110974:   nsAutoCString urlSpec2;
106838:   if (aURL != nullptr) aURL->GetAsciiSpec(urlSpec2);
     1: 
     1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
125843:         ("nsPluginHost::InstantiatePlugin Finished mime=%s, rv=%d, url=%s\n",
 89114:         aMimeType, rv, urlSpec2.get()));
     1: 
     1:   PR_LogFlush();
     1: #endif
     1: 
 89114:   return NS_OK;
     1: }
     1: 
 37199: nsPluginTag*
 40216: nsPluginHost::FindTagForLibrary(PRLibrary* aLibrary)
 40216: {
 40216:   nsPluginTag* pluginTag;
 40216:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
 40216:     if (pluginTag->mLibrary == aLibrary) {
 40216:       return pluginTag;
 40216:     }
 40216:   }
106838:   return nullptr;
 40216: }
 40216: 
 40216: nsPluginTag*
 47965: nsPluginHost::TagForPlugin(nsNPAPIPlugin* aPlugin)
 37199: {
 37199:   nsPluginTag* pluginTag;
 37199:   for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
 94676:     if (pluginTag->mPlugin == aPlugin) {
 37199:       return pluginTag;
 37199:     }
 37199:   }
 47965:   // a plugin should never exist without a corresponding tag
 59756:   NS_ERROR("TagForPlugin has failed");
106838:   return nullptr;
 37199: }
 37199: 
 70185: nsresult nsPluginHost::SetUpPluginInstance(const char *aMimeType,
     1:                                            nsIURI *aURL,
115860:                                            nsPluginInstanceOwner *aOwner)
     1: {
 59670:   NS_ENSURE_ARG_POINTER(aOwner);
 59670: 
 94677:   nsresult rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
 94677:   if (NS_SUCCEEDED(rv)) {
 94677:     return rv;
 94677:   }
 94677: 
 94677:   // If we failed to load a plugin instance we'll try again after
 94677:   // reloading our plugin list. Only do that once per document to
 94677:   // avoid redundant high resource usage on pages with multiple
 94677:   // unkown instance types. We'll do that by caching the document.
     1:   nsCOMPtr<nsIDocument> document;
     1:   aOwner->GetDocument(getter_AddRefs(document));
     1: 
     1:   nsCOMPtr<nsIDocument> currentdocument = do_QueryReferent(mCurrentDocument);
 94677:   if (document == currentdocument) {
     1:     return rv;
 94677:   }
     1: 
     1:   mCurrentDocument = do_GetWeakReference(document);
     1: 
 94677:   // Don't try to set up an instance again if nothing changed.
 94677:   if (ReloadPlugins(false) == NS_ERROR_PLUGINS_PLUGINSNOTCHANGED) {
     1:     return rv;
 94677:   }
 94677: 
 94677:   return TrySetUpPluginInstance(aMimeType, aURL, aOwner);
     1: }
     1: 
 29574: nsresult
 29956: nsPluginHost::TrySetUpPluginInstance(const char *aMimeType,
     1:                                      nsIURI *aURL,
115860:                                      nsPluginInstanceOwner *aOwner)
     1: {
     1: #ifdef PLUGIN_LOGGING
110974:   nsAutoCString urlSpec;
106838:   if (aURL != nullptr) aURL->GetSpec(urlSpec);
     1: 
     1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
 29956:         ("nsPluginHost::TrySetupPluginInstance Begin mime=%s, owner=%p, url=%s\n",
     1:         aMimeType, aOwner, urlSpec.get()));
     1: 
     1:   PR_LogFlush();
     1: #endif
     1: 
 79533:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, true);
     1:   NS_ASSERTION(pluginTag, "Must have plugin tag here!");
 28071: 
 69716:   nsRefPtr<nsNPAPIPlugin> plugin;
125839:   GetPlugin(aMimeType, getter_AddRefs(plugin));
 94537:   if (!plugin) {
 94537:     return NS_ERROR_FAILURE;
 94537:   }
 94537: 
 94603:   nsRefPtr<nsNPAPIPluginInstance> instance = new nsNPAPIPluginInstance();
 94603: 
 94603:   // This will create the owning reference. The connection must be made between the
 94603:   // instance and the instance owner before initialization. Plugins can call into
 94603:   // the browser during initialization.
 70007:   aOwner->SetInstance(instance.get());
     1: 
101944:   // Add the instance to the instances list before we call NPP_New so that
101944:   // it is "in play" before NPP_New happens. Take it out if NPP_New fails.
101944:   mInstances.AppendElement(instance.get());
101944: 
 36223:   // this should not addref the instance or owner
 36223:   // except in some cases not Java, see bug 140931
 36223:   // our COM pointer will free the peer
125839:   nsresult rv = instance->Initialize(plugin.get(), aOwner, aMimeType);
 50781:   if (NS_FAILED(rv)) {
101944:     mInstances.RemoveElement(instance.get());
106838:     aOwner->SetInstance(nullptr);
 50781:     return rv;
 36223:   }
     1: 
 90104:   // Cancel the plugin unload timer since we are creating
 90104:   // an instance for it.
 90104:   if (pluginTag->mUnloadTimer) {
 90104:     pluginTag->mUnloadTimer->Cancel();
 90104:   }
 90104: 
     1: #ifdef PLUGIN_LOGGING
110974:   nsAutoCString urlSpec2;
     1:   if (aURL)
     1:     aURL->GetSpec(urlSpec2);
     1: 
     1:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
 29956:         ("nsPluginHost::TrySetupPluginInstance Finished mime=%s, rv=%d, owner=%p, url=%s\n",
 50781:         aMimeType, rv, aOwner, urlSpec2.get()));
     1: 
     1:   PR_LogFlush();
     1: #endif
     1: 
 50781:   return rv;
     1: }
     1: 
 70185: nsresult
 84395: nsPluginHost::IsPluginEnabledForType(const char* aMimeType)
     1: {
 79533:   nsPluginTag *plugin = FindPluginForType(aMimeType, true);
 37883:   if (plugin)
 89887:     return NS_OK;
 37883: 
 79533:   // Pass false as the second arg so we can return NS_ERROR_PLUGIN_DISABLED
     1:   // for disabled plug-ins.
 79533:   plugin = FindPluginForType(aMimeType, false);
 21231:   if (!plugin)
     1:     return NS_ERROR_FAILURE;
     1: 
 13222:   if (!plugin->IsEnabled()) {
  3464:     if (plugin->HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED))
  3464:       return NS_ERROR_PLUGIN_BLOCKLISTED;
  3464:     else
     1:       return NS_ERROR_PLUGIN_DISABLED;
     1:   }
     1: 
 89887:   return NS_OK;
     1: }
     1: 
123577: NS_IMETHODIMP
123577: nsPluginHost::IsPluginClickToPlayForType(const nsACString &aMimeType, bool *aResult)
104371: {
123577:   nsPluginTag *plugin = FindPluginForType(aMimeType.Data(), true);
123577:   if (!plugin) {
123577:     return NS_ERROR_UNEXPECTED;
123577:   }
123577: 
123577:   uint32_t blocklistState = nsIBlocklistService::STATE_NOT_BLOCKED;
123577:   nsresult rv = GetBlocklistStateForType(aMimeType.Data(), &blocklistState);
123577:   NS_ENSURE_SUCCESS(rv, rv);
123577: 
123577:   if (mPluginsClickToPlay ||
123577:       blocklistState == nsIBlocklistService::STATE_VULNERABLE_NO_UPDATE ||
123577:       blocklistState == nsIBlocklistService::STATE_VULNERABLE_UPDATE_AVAILABLE) {
123577:     *aResult = true;
104371:   }
104371:   else {
123577:     *aResult = false;
123577:   }
123577: 
123577:   return NS_OK;
104371: }
104371: 
109451: bool
109451: nsPluginHost::IsPluginPlayPreviewForType(const char* aMimeType)
109451: {
109451:   for (uint32_t i = 0; i < mPlayPreviewMimeTypes.Length(); i++) {
109451:     nsCString mt = mPlayPreviewMimeTypes[i];
109451:     if (PL_strcasecmp(mt.get(), aMimeType) == 0)
109451:       return true;
109451:   }
109451:   return false;
109451: }
109451: 
104371: nsresult
108991: nsPluginHost::GetBlocklistStateForType(const char *aMimeType, uint32_t *aState)
104371: {
104371:   nsPluginTag *plugin = FindPluginForType(aMimeType, true);
104371:   if (plugin) {
104371:     nsCOMPtr<nsIBlocklistService> blocklist = do_GetService("@mozilla.org/extensions/blocklist;1");
104371:     if (blocklist) {
104371:       // The EmptyString()s are so we use the currently running application
104371:       // and toolkit versions
104371:       return blocklist->GetPluginBlocklistState(plugin, EmptyString(),
104371:                                                 EmptyString(), aState);
104371:     }
104371:   }
104371: 
104371:   return NS_ERROR_FAILURE;
104371: }
104371: 
124097: NS_IMETHODIMP
124097: nsPluginHost::GetPermissionStringForType(const nsACString &aMimeType, nsACString &aPermissionString)
124097: {
124097:   aPermissionString.Truncate();
124097:   uint32_t blocklistState;
124097:   nsresult rv = GetBlocklistStateForType(aMimeType.Data(), &blocklistState);
124097:   NS_ENSURE_SUCCESS(rv, rv);
124097:   nsPluginTag *tag = FindPluginForType(aMimeType.Data(), true);
124097:   if (!tag) {
124097:     return NS_ERROR_FAILURE;
124097:   }
124097: 
124097:   if (blocklistState == nsIBlocklistService::STATE_VULNERABLE_UPDATE_AVAILABLE ||
124097:       blocklistState == nsIBlocklistService::STATE_VULNERABLE_NO_UPDATE) {
124097:     aPermissionString.AssignLiteral("plugin-vulnerable:");
124097:   }
124097:   else {
124097:     aPermissionString.AssignLiteral("plugin:");
124097:   }
124097: 
124097:   aPermissionString.Append(tag->mFileName);
124097: 
124097:   return NS_OK;
124097: }
124097: 
     1: // check comma delimitered extensions
     1: static int CompareExtensions(const char *aExtensionList, const char *aExtension)
     1: {
 21231:   if (!aExtensionList || !aExtension)
     1:     return -1;
     1: 
     1:   const char *pExt = aExtensionList;
     1:   const char *pComma = strchr(pExt, ',');
 21231:   if (!pComma)
     1:     return PL_strcasecmp(pExt, aExtension);
     1: 
     1:   int extlen = strlen(aExtension);
 21231:   while (pComma) {
     1:     int length = pComma - pExt;
     1:     if (length == extlen && 0 == PL_strncasecmp(aExtension, pExt, length))
     1:       return 0;
     1:     pComma++;
     1:     pExt = pComma;
     1:     pComma = strchr(pExt, ',');
     1:   }
     1: 
     1:   // the last one
     1:   return PL_strcasecmp(pExt, aExtension);
     1: }
     1: 
 70185: nsresult
 29956: nsPluginHost::IsPluginEnabledForExtension(const char* aExtension,
 89887:                                           const char* &aMimeType)
     1: {
     1:   nsPluginTag *plugin = FindPluginEnabledForExtension(aExtension, aMimeType);
 84557:   if (plugin)
 89887:     return NS_OK;
 84557: 
 84557:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: class DOMPluginImpl : public nsIDOMPlugin {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   DOMPluginImpl(nsPluginTag* aPluginTag) : mPluginTag(aPluginTag)
     1:   {
     1:   }
     1: 
     1:   virtual ~DOMPluginImpl() {
     1:   }
     1: 
     1:   NS_METHOD GetDescription(nsAString& aDescription)
     1:   {
 12841:     CopyUTF8toUTF16(mPluginTag.mDescription, aDescription);
     1:     return NS_OK;
     1:   }
     1: 
     1:   NS_METHOD GetFilename(nsAString& aFilename)
     1:   {
 94707:     if (Preferences::GetBool("plugin.expose_full_path", false)) {
 64609:       CopyUTF8toUTF16(mPluginTag.mFullPath, aFilename);
 29020:     } else {
 28451:       CopyUTF8toUTF16(mPluginTag.mFileName, aFilename);
 29020:     }
 29020: 
 28451:     return NS_OK;
 28451:   }
 28451: 
 27645:   NS_METHOD GetVersion(nsAString& aVersion)
 27645:   {
 27645:     CopyUTF8toUTF16(mPluginTag.mVersion, aVersion);
 27645:     return NS_OK;
 27645:   }
 27645: 
     1:   NS_METHOD GetName(nsAString& aName)
     1:   {
 12841:     CopyUTF8toUTF16(mPluginTag.mName, aName);
     1:     return NS_OK;
     1:   }
     1: 
108991:   NS_METHOD GetLength(uint32_t* aLength)
     1:   {
 69610:     *aLength = mPluginTag.mMimeTypes.Length();
     1:     return NS_OK;
     1:   }
     1: 
108991:   NS_METHOD Item(uint32_t aIndex, nsIDOMMimeType** aReturn)
     1:   {
     1:     nsIDOMMimeType* mimeType = new DOMMimeTypeImpl(&mPluginTag, aIndex);
     1:     NS_IF_ADDREF(mimeType);
     1:     *aReturn = mimeType;
     1:     return NS_OK;
     1:   }
     1: 
     1:   NS_METHOD NamedItem(const nsAString& aName, nsIDOMMimeType** aReturn)
     1:   {
 69610:     for (int i = mPluginTag.mMimeTypes.Length() - 1; i >= 0; --i) {
 69610:       if (aName.Equals(NS_ConvertUTF8toUTF16(mPluginTag.mMimeTypes[i])))
 12841:         return Item(i, aReturn);
     1:     }
     1:     return NS_OK;
     1:   }
     1: 
     1: private:
     1:   nsPluginTag mPluginTag;
     1: };
     1: 
     1: NS_IMPL_ISUPPORTS1(DOMPluginImpl, nsIDOMPlugin)
     1: 
 70185: nsresult
108991: nsPluginHost::GetPluginCount(uint32_t* aPluginCount)
     1: {
     1:   LoadPlugins();
     1: 
108991:   uint32_t count = 0;
     1: 
     1:   nsPluginTag* plugin = mPlugins;
106838:   while (plugin != nullptr) {
 13222:     if (plugin->IsEnabled()) {
     1:       ++count;
     1:     }
     1:     plugin = plugin->mNext;
     1:   }
     1: 
     1:   *aPluginCount = count;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 70185: nsresult
108991: nsPluginHost::GetPlugins(uint32_t aPluginCount, nsIDOMPlugin** aPluginArray)
     1: {
     1:   LoadPlugins();
     1: 
     1:   nsPluginTag* plugin = mPlugins;
108991:   for (uint32_t i = 0; i < aPluginCount && plugin; plugin = plugin->mNext) {
 13222:     if (plugin->IsEnabled()) {
     1:       nsIDOMPlugin* domPlugin = new DOMPluginImpl(plugin);
     1:       NS_IF_ADDREF(domPlugin);
  3102:       aPluginArray[i++] = domPlugin;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
  3102: NS_IMETHODIMP
108991: nsPluginHost::GetPluginTags(uint32_t* aPluginCount, nsIPluginTag*** aResults)
  3102: {
  3102:   LoadPlugins();
  3102: 
108991:   uint32_t count = 0;
  3102:   nsRefPtr<nsPluginTag> plugin = mPlugins;
106838:   while (plugin != nullptr) {
  3102:     count++;
  3102:     plugin = plugin->mNext;
  3102:   }
  3102: 
  3233:   *aResults = static_cast<nsIPluginTag**>
  3233:                          (nsMemory::Alloc(count * sizeof(**aResults)));
  3102:   if (!*aResults)
  3102:     return NS_ERROR_OUT_OF_MEMORY;
  3102: 
  3102:   *aPluginCount = count;
  3102: 
  3102:   plugin = mPlugins;
108991:   for (uint32_t i = 0; i < count; i++) {
  3102:     (*aResults)[i] = plugin;
  3102:     NS_ADDREF((*aResults)[i]);
  3102:     plugin = plugin->mNext;
  3102:   }
  3102: 
  3102:   return NS_OK;
  3102: }
     1: 
     1: nsPluginTag*
101944: nsPluginHost::FindPreferredPlugin(const InfallibleTArray<nsPluginTag*>& matches)
101944: {
101944:   // We prefer the plugin with the highest version number.
104192:   /// XXX(johns): This seems to assume the only time multiple plugins will have
104192:   ///             the same MIME type is if they're multiple versions of the same
104192:   ///             plugin -- but since plugin filenames and pretty names can both
104192:   ///             update, it's probably less arbitrary than just going at it
104192:   ///             alphabetically.
101944: 
101944:   if (matches.IsEmpty()) {
106838:     return nullptr;
101944:   }
101944: 
101944:   nsPluginTag *preferredPlugin = matches[0];
101944:   for (unsigned int i = 1; i < matches.Length(); i++) {
101944:     if (mozilla::Version(matches[i]->mVersion.get()) > preferredPlugin->mVersion.get()) {
101944:       preferredPlugin = matches[i];
101944:     }
101944:   }
101944: 
101944:   return preferredPlugin;
101944: }
101944: 
101944: nsPluginTag*
 29956: nsPluginHost::FindPluginForType(const char* aMimeType,
 79445:                                 bool aCheckEnabled)
     1: {
 69091:   if (!aMimeType) {
106838:     return nullptr;
 69091:   }
     1: 
     1:   LoadPlugins();
     1: 
101944:   InfallibleTArray<nsPluginTag*> matchingPlugins;
101944: 
 69091:   nsPluginTag *plugin = mPlugins;
 69091:   while (plugin) {
 69091:     if (!aCheckEnabled || plugin->IsEnabled()) {
108991:       int32_t mimeCount = plugin->mMimeTypes.Length();
108991:       for (int32_t i = 0; i < mimeCount; i++) {
 69610:         if (0 == PL_strcasecmp(plugin->mMimeTypes[i].get(), aMimeType)) {
101944:           matchingPlugins.AppendElement(plugin);
101944:           break;
 69091:         }
 69091:       }
 69091:     }
 69091:     plugin = plugin->mNext;
     1:   }
     1: 
101944:   return FindPreferredPlugin(matchingPlugins);
     1: }
     1: 
     1: nsPluginTag*
 29956: nsPluginHost::FindPluginEnabledForExtension(const char* aExtension,
     1:                                             const char*& aMimeType)
     1: {
 69610:   if (!aExtension) {
106838:     return nullptr;
 69610:   }
     1: 
     1:   LoadPlugins();
     1: 
101944:   InfallibleTArray<nsPluginTag*> matchingPlugins;
101944: 
 69610:   nsPluginTag *plugin = mPlugins;
 69610:   while (plugin) {
 69610:     if (plugin->IsEnabled()) {
108991:       int32_t variants = plugin->mExtensions.Length();
108991:       for (int32_t i = 0; i < variants; i++) {
 69610:         // mExtensionsArray[cnt] is a list of extensions separated by commas
 69610:         if (0 == CompareExtensions(plugin->mExtensions[i].get(), aExtension)) {
101944:           matchingPlugins.AppendElement(plugin);
101944:           break;
 69610:         }
 69610:       }
 69610:     }
 69610:     plugin = plugin->mNext;
     1:   }
     1: 
101944:   nsPluginTag *preferredPlugin = FindPreferredPlugin(matchingPlugins);
101944:   if (!preferredPlugin) {
106838:     return nullptr;
     1:   }
     1: 
108991:   int32_t variants = preferredPlugin->mExtensions.Length();
108991:   for (int32_t i = 0; i < variants; i++) {
101944:     // mExtensionsArray[cnt] is a list of extensions separated by commas
101944:     if (0 == CompareExtensions(preferredPlugin->mExtensions[i].get(), aExtension)) {
101944:       aMimeType = preferredPlugin->mMimeTypes[i].get();
101944:       break;
101944:     }
101944:   }
101944: 
101944:   return preferredPlugin;
101944: }
101944: 
 50781: static nsresult CreateNPAPIPlugin(nsPluginTag *aPluginTag,
 62174:                                   nsNPAPIPlugin **aOutNPAPIPlugin)
 12841: {
 50781:   // If this is an in-process plugin we'll need to load it here if we haven't already.
 54127:   if (!nsNPAPIPlugin::RunPluginOOP(aPluginTag)) {
 50781:     if (aPluginTag->mFullPath.IsEmpty())
 50781:       return NS_ERROR_FAILURE;
101111:     nsCOMPtr<nsIFile> file = do_CreateInstance("@mozilla.org/file/local;1");
 64609:     file->InitWithPath(NS_ConvertUTF8toUTF16(aPluginTag->mFullPath));
 50781:     nsPluginFile pluginFile(file);
 50781:     PRLibrary* pluginLibrary = NULL;
 50781: 
 50781:     if (NS_FAILED(pluginFile.LoadPlugin(&pluginLibrary)) || !pluginLibrary)
 50781:       return NS_ERROR_FAILURE;
 50781: 
 50781:     aPluginTag->mLibrary = pluginLibrary;
 50781:   }
 50781: 
 12841:   nsresult rv;
 64609:   rv = nsNPAPIPlugin::CreatePlugin(aPluginTag, aOutNPAPIPlugin);
 64609: 
 40564:   return rv;
 30057: }
 30057: 
 94676: nsresult nsPluginHost::EnsurePluginLoaded(nsPluginTag* aPluginTag)
 62849: {
 94676:   nsRefPtr<nsNPAPIPlugin> plugin = aPluginTag->mPlugin;
 94676:   if (!plugin) {
 94676:     nsresult rv = CreateNPAPIPlugin(aPluginTag, getter_AddRefs(plugin));
 62849:     if (NS_FAILED(rv)) {
 62849:       return rv;
 62849:     }
 94676:     aPluginTag->mPlugin = plugin;
 62849:   }
 62849:   return NS_OK;
 62849: }
 62849: 
 69716: nsresult nsPluginHost::GetPlugin(const char *aMimeType, nsNPAPIPlugin** aPlugin)
     1: {
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   *aPlugin = NULL;
     1: 
     1:   if (!aMimeType)
     1:     return NS_ERROR_ILLEGAL_VALUE;
     1: 
     1:   // If plugins haven't been scanned yet, do so now
     1:   LoadPlugins();
     1: 
 79533:   nsPluginTag* pluginTag = FindPluginForType(aMimeType, true);
 21231:   if (pluginTag) {
     1:     rv = NS_OK;
     1:     PLUGIN_LOG(PLUGIN_LOG_BASIC,
 30057:     ("nsPluginHost::GetPlugin Begin mime=%s, plugin=%s\n",
 12841:     aMimeType, pluginTag->mFileName.get()));
     1: 
102909: #ifdef DEBUG
 12841:     if (aMimeType && !pluginTag->mFileName.IsEmpty())
 12841:       printf("For %s found plugin %s\n", aMimeType, pluginTag->mFileName.get());
     1: #endif
     1: 
 62849:     rv = EnsurePluginLoaded(pluginTag);
 62849:     if (NS_FAILED(rv)) {
 36102:       return rv;
 62849:     }
 62849: 
 94676:     NS_ADDREF(*aPlugin = pluginTag->mPlugin);
     1:     return NS_OK;
     1:   }
     1: 
     1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 30057:   ("nsPluginHost::GetPlugin End mime=%s, rv=%d, plugin=%p name=%s\n",
 12841:   aMimeType, rv, *aPlugin,
 12841:   (pluginTag ? pluginTag->mFileName.get() : "(not found)")));
     1: 
     1:   return rv;
     1: }
     1: 
 62174: // Normalize 'host' to ACE.
 62174: nsresult
 62174: nsPluginHost::NormalizeHostname(nsCString& host)
 62174: {
 62174:   if (IsASCII(host)) {
 62174:     ToLowerCase(host);
 62174:     return NS_OK;
 62174:   }
 62174: 
 62174:   if (!mIDNService) {
 62174:     nsresult rv;
 62174:     mIDNService = do_GetService(NS_IDNSERVICE_CONTRACTID, &rv);
 62174:     NS_ENSURE_SUCCESS(rv, rv);
 62174:   }
 62174: 
 62174:   return mIDNService->ConvertUTF8toACE(host, host);
 62174: }
 62174: 
 62174: // Enumerate a 'sites' array returned by GetSitesWithData and determine if
 62174: // any of them have a base domain in common with 'domain'; if so, append them
 62174: // to the 'result' array. If 'firstMatchOnly' is true, return after finding the
 62174: // first match.
 62174: nsresult
 62174: nsPluginHost::EnumerateSiteData(const nsACString& domain,
124361:                                 const InfallibleTArray<nsCString>& sites,
 62174:                                 InfallibleTArray<nsCString>& result,
 62174:                                 bool firstMatchOnly)
 62174: {
 62174:   NS_ASSERTION(!domain.IsVoid(), "null domain string");
 62174: 
 62174:   nsresult rv;
 62174:   if (!mTLDService) {
 62174:     mTLDService = do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID, &rv);
 62174:     NS_ENSURE_SUCCESS(rv, rv);
 62174:   }
 62174: 
 62174:   // Get the base domain from the domain.
 62174:   nsCString baseDomain;
 62174:   rv = mTLDService->GetBaseDomainFromHost(domain, 0, baseDomain);
 62174:   bool isIP = rv == NS_ERROR_HOST_IS_IP_ADDRESS;
 62174:   if (isIP || rv == NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS) {
 62174:     // The base domain is the site itself. However, we must be careful to
 62174:     // normalize.
 62174:     baseDomain = domain;
 62174:     rv = NormalizeHostname(baseDomain);
 62174:     NS_ENSURE_SUCCESS(rv, rv);
 62174:   } else if (NS_FAILED(rv)) {
 62174:     return rv;
 62174:   }
 62174: 
 62174:   // Enumerate the array of sites with data.
108991:   for (uint32_t i = 0; i < sites.Length(); ++i) {
 62174:     const nsCString& site = sites[i];
 62174: 
 62174:     // Check if the site is an IP address.
 62174:     bool siteIsIP =
 62174:       site.Length() >= 2 && site.First() == '[' && site.Last() == ']';
 62174:     if (siteIsIP != isIP)
 62174:       continue;
 62174: 
 62174:     nsCString siteBaseDomain;
 62174:     if (siteIsIP) {
 62174:       // Strip the '[]'.
 62174:       siteBaseDomain = Substring(site, 1, site.Length() - 2);
 62174:     } else {
 62174:       // Determine the base domain of the site.
 62174:       rv = mTLDService->GetBaseDomainFromHost(site, 0, siteBaseDomain);
 62174:       if (rv == NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS) {
 62174:         // The base domain is the site itself. However, we must be careful to
 62174:         // normalize.
 62174:         siteBaseDomain = site;
 62174:         rv = NormalizeHostname(siteBaseDomain);
 62174:         NS_ENSURE_SUCCESS(rv, rv);
 62174:       } else if (NS_FAILED(rv)) {
 62174:         return rv;
 62174:       }
 62174:     }
 62174: 
 62174:     // At this point, we can do an exact comparison of the two domains.
 62174:     if (baseDomain != siteBaseDomain) {
 62174:       continue;
 62174:     }
 62174: 
 62174:     // Append the site to the result array.
 62174:     result.AppendElement(site);
 62174: 
 62174:     // If we're supposed to return early, do so.
 62174:     if (firstMatchOnly) {
 62174:       break;
 62174:     }
 62174:   }
 62174: 
 62174:   return NS_OK;
 62174: }
 62174: 
 62174: NS_IMETHODIMP
109451: nsPluginHost::RegisterPlayPreviewMimeType(const nsACString& mimeType)
109451: {
109451:   mPlayPreviewMimeTypes.AppendElement(mimeType);
109451:   return NS_OK;
109451: }
109451: 
109451: NS_IMETHODIMP
109451: nsPluginHost::UnregisterPlayPreviewMimeType(const nsACString& mimeType)
109451: {
110974:   nsAutoCString mimeTypeToRemove(mimeType);
109451:   for (uint32_t i = mPlayPreviewMimeTypes.Length(); i > 0;) {
109451:     nsCString mt = mPlayPreviewMimeTypes[--i];
109451:     if (PL_strcasecmp(mt.get(), mimeTypeToRemove.get()) == 0) {
109451:       mPlayPreviewMimeTypes.RemoveElementAt(i);
109451:       break;
109451:     }
109451:   }
109451:   return NS_OK;
109451: }
109451: 
109451: NS_IMETHODIMP
 62174: nsPluginHost::ClearSiteData(nsIPluginTag* plugin, const nsACString& domain,
108991:                             uint64_t flags, int64_t maxAge)
 62174: {
 62174:   // maxAge must be either a nonnegative integer or -1.
 62174:   NS_ENSURE_ARG(maxAge >= 0 || maxAge == -1);
 62174: 
 62849:   // Caller may give us a tag object that is no longer live.
 62849:   if (!IsLiveTag(plugin)) {
 62174:     return NS_ERROR_NOT_AVAILABLE;
 62174:   }
 62174: 
 62849:   nsPluginTag* tag = static_cast<nsPluginTag*>(plugin);
 62849: 
 62849:   // We only ensure support for clearing Flash site data for now.
 62849:   // We will also attempt to clear data for any plugin that happens
 62849:   // to be loaded already.
 94676:   if (!tag->mIsFlashPlugin && !tag->mPlugin) {
 62849:     return NS_ERROR_FAILURE;
 62849:   }
 62849: 
 62849:   // Make sure the plugin is loaded.
 62849:   nsresult rv = EnsurePluginLoaded(tag);
 62849:   if (NS_FAILED(rv)) {
 62849:     return rv;
 62849:   }
 62849: 
 94676:   PluginLibrary* library = tag->mPlugin->GetLibrary();
 62174: 
 62174:   // If 'domain' is the null string, clear everything.
 62174:   if (domain.IsVoid()) {
 62174:     return library->NPP_ClearSiteData(NULL, flags, maxAge);
 62174:   }
 62174: 
 62174:   // Get the list of sites from the plugin.
 62174:   InfallibleTArray<nsCString> sites;
 62849:   rv = library->NPP_GetSitesWithData(sites);
 62174:   NS_ENSURE_SUCCESS(rv, rv);
 62174: 
 62174:   // Enumerate the sites and build a list of matches.
 62174:   InfallibleTArray<nsCString> matches;
 62174:   rv = EnumerateSiteData(domain, sites, matches, false);
 62174:   NS_ENSURE_SUCCESS(rv, rv);
 62174: 
 62174:   // Clear the matches.
108991:   for (uint32_t i = 0; i < matches.Length(); ++i) {
 62174:     const nsCString& match = matches[i];
 62174:     rv = library->NPP_ClearSiteData(match.get(), flags, maxAge);
 62174:     NS_ENSURE_SUCCESS(rv, rv);
 62174:   }
 62174: 
 62174:   return NS_OK;
 62174: }
 62174: 
 62174: NS_IMETHODIMP
 62174: nsPluginHost::SiteHasData(nsIPluginTag* plugin, const nsACString& domain,
 79445:                           bool* result)
 62174: {
 62849:   // Caller may give us a tag object that is no longer live.
 62849:   if (!IsLiveTag(plugin)) {
 62174:     return NS_ERROR_NOT_AVAILABLE;
 62174:   }
 62174: 
 62849:   nsPluginTag* tag = static_cast<nsPluginTag*>(plugin);
 62849: 
 62849:   // We only ensure support for clearing Flash site data for now.
 62849:   // We will also attempt to clear data for any plugin that happens
 62849:   // to be loaded already.
 94676:   if (!tag->mIsFlashPlugin && !tag->mPlugin) {
 62849:     return NS_ERROR_FAILURE;
 62849:   }
 62849: 
 62849:   // Make sure the plugin is loaded.
 62849:   nsresult rv = EnsurePluginLoaded(tag);
 62849:   if (NS_FAILED(rv)) {
 62849:     return rv;
 62849:   }
 62849: 
 94676:   PluginLibrary* library = tag->mPlugin->GetLibrary();
 62174: 
 62174:   // Get the list of sites from the plugin.
 62174:   InfallibleTArray<nsCString> sites;
 62849:   rv = library->NPP_GetSitesWithData(sites);
 62174:   NS_ENSURE_SUCCESS(rv, rv);
 62174: 
 62174:   // If there's no data, we're done.
 62174:   if (sites.IsEmpty()) {
 62174:     *result = false;
 62174:     return NS_OK;
 62174:   }
 62174: 
 62174:   // If 'domain' is the null string, and there's data for at least one site,
 62174:   // we're done.
 62174:   if (domain.IsVoid()) {
 62174:     *result = true;
 62174:     return NS_OK;
 62174:   }
 62174: 
 62174:   // Enumerate the sites and determine if there's a match.
 62174:   InfallibleTArray<nsCString> matches;
 62174:   rv = EnumerateSiteData(domain, sites, matches, true);
 62174:   NS_ENSURE_SUCCESS(rv, rv);
 62174: 
 62174:   *result = !matches.IsEmpty();
 62174:   return NS_OK;
 62174: }
 62174: 
 79445: bool nsPluginHost::IsJavaMIMEType(const char* aType)
     1: {
     1:   return aType &&
     1:     ((0 == PL_strncasecmp(aType, "application/x-java-vm",
     1:                           sizeof("application/x-java-vm") - 1)) ||
     1:      (0 == PL_strncasecmp(aType, "application/x-java-applet",
     1:                           sizeof("application/x-java-applet") - 1)) ||
     1:      (0 == PL_strncasecmp(aType, "application/x-java-bean",
     1:                           sizeof("application/x-java-bean") - 1)));
     1: }
     1: 
 62849: // Check whether or not a tag is a live, valid tag, and that it's loaded.
 79445: bool
 62849: nsPluginHost::IsLiveTag(nsIPluginTag* aPluginTag)
 62849: {
 62849:   nsPluginTag* tag;
 62849:   for (tag = mPlugins; tag; tag = tag->mNext) {
 62849:     if (tag == aPluginTag) {
 79533:       return true;
 79533:     }
 79533:   }
 79533:   return false;
 62849: }
 62849: 
106355: nsPluginTag*
106355: nsPluginHost::HaveSamePlugin(const nsPluginTag* aPluginTag)
106355: {
106355:   for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
106355:     if (tag->HasSameNameAndMimes(aPluginTag)) {
106355:         return tag;
106355:     }
106355:   }
106838:   return nullptr;
106355: }
106355: 
106355: nsPluginTag*
106355: nsPluginHost::FirstPluginWithPath(const nsCString& path)
106355: {
106355:   for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
106355:     if (tag->mFullPath.Equals(path)) {
106355:       return tag;
106355:     }
106355:   }
106838:   return nullptr;
106355: }
106355: 
106355: namespace {
106355: 
108991: int64_t GetPluginLastModifiedTime(const nsCOMPtr<nsIFile>& localfile)
106355: {
120112:   PRTime fileModTime = 0;
106355: 
106355: #if defined(XP_MACOSX)
106355:   // On OS X the date of a bundle's "contents" (i.e. of its Info.plist file)
106355:   // is a much better guide to when it was last modified than the date of
106355:   // its package directory.  See bug 313700.
106355:   nsCOMPtr<nsILocalFileMac> localFileMac = do_QueryInterface(localfile);
106355:   if (localFileMac) {
106355:     localFileMac->GetBundleContentsLastModifiedTime(&fileModTime);
106355:   } else {
106355:     localfile->GetLastModifiedTime(&fileModTime);
106355:   }
106355: #else
106355:   localfile->GetLastModifiedTime(&fileModTime);
106355: #endif
106355: 
106355:   return fileModTime;
106355: }
106355: 
106355: struct CompareFilesByTime
106355: {
106355:   bool
106355:   LessThan(const nsCOMPtr<nsIFile>& a, const nsCOMPtr<nsIFile>& b) const
106355:   {
115938:     return GetPluginLastModifiedTime(a) < GetPluginLastModifiedTime(b);
106355:   }
106355: 
106355:   bool
106355:   Equals(const nsCOMPtr<nsIFile>& a, const nsCOMPtr<nsIFile>& b) const
106355:   {
115935:     return GetPluginLastModifiedTime(a) == GetPluginLastModifiedTime(b);
106355:   }
106355: };
106355: 
106355: } // anonymous namespace
106355: 
 19246: typedef NS_NPAPIPLUGIN_CALLBACK(char *, NP_GETMIMEDESCRIPTION)(void);
     1: 
 29956: nsresult nsPluginHost::ScanPluginsDirectory(nsIFile *pluginsDir,
 79445:                                             bool aCreatePluginList,
 79445:                                             bool *aPluginsChanged)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPluginsChanged);
     1:   nsresult rv;
     1: 
 79533:   *aPluginsChanged = false;
     1: 
     1: #ifdef PLUGIN_LOGGING
110974:   nsAutoCString dirPath;
     1:   pluginsDir->GetNativePath(dirPath);
     1:   PLUGIN_LOG(PLUGIN_LOG_BASIC,
 29956:   ("nsPluginHost::ScanPluginsDirectory dir=%s\n", dirPath.get()));
     1: #endif
     1: 
     1:   nsCOMPtr<nsISimpleEnumerator> iter;
     1:   rv = pluginsDir->GetDirectoryEntries(getter_AddRefs(iter));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
101111:   nsAutoTArray<nsCOMPtr<nsIFile>, 6> pluginFiles;
     1: 
 79445:   bool hasMore;
     1:   while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
     1:     nsCOMPtr<nsISupports> supports;
     1:     rv = iter->GetNext(getter_AddRefs(supports));
     1:     if (NS_FAILED(rv))
     1:       continue;
101111:     nsCOMPtr<nsIFile> dirEntry(do_QueryInterface(supports, &rv));
     1:     if (NS_FAILED(rv))
     1:       continue;
     1: 
     1:     // Sun's JRE 1.3.1 plugin must have symbolic links resolved or else it'll crash.
     1:     // See bug 197855.
     1:     dirEntry->Normalize();
     1: 
 70974:     if (nsPluginsDir::IsPluginFile(dirEntry)) {
 70974:       pluginFiles.AppendElement(dirEntry);
 70974:     }
 70974:   }
 70974: 
106355:   pluginFiles.Sort(CompareFilesByTime());
106355: 
 79445:   bool warnOutdated = false;
 70974: 
108991:   for (int32_t i = (pluginFiles.Length() - 1); i >= 0; i--) {
101111:     nsCOMPtr<nsIFile>& localfile = pluginFiles[i];
 70974: 
 70974:     nsString utf16FilePath;
 70974:     rv = localfile->GetPath(utf16FilePath);
     1:     if (NS_FAILED(rv))
     1:       continue;
     1: 
108991:     int64_t fileModTime = GetPluginLastModifiedTime(localfile);
     1: 
     1:     // Look for it in our cache
 70974:     NS_ConvertUTF16toUTF8 filePath(utf16FilePath);
  3102:     nsRefPtr<nsPluginTag> pluginTag;
101944:     RemoveCachedPluginsInfo(filePath.get(), getter_AddRefs(pluginTag));
  3102: 
 79445:     bool enabled = true;
 79445:     bool seenBefore = false;
     1:     if (pluginTag) {
 79533:       seenBefore = true;
     1:       // If plugin changed, delete cachedPluginTag and don't use cache
115936:       if (fileModTime != pluginTag->mLastModifiedTime) {
     1:         // Plugins has changed. Don't use cached plugin info.
 21189:         enabled = (pluginTag->Flags() & NS_PLUGIN_FLAG_ENABLED) != 0;
106838:         pluginTag = nullptr;
     1: 
     1:         // plugin file changed, flag this fact
 79533:         *aPluginsChanged = true;
     1:       }
 55427: 
 55427:       // If we're not creating a list and we already know something changed then
 55427:       // we're done.
     1:       if (!aCreatePluginList) {
 55427:         if (*aPluginsChanged) {
     1:           return NS_OK;
 55427:         }
     1:         continue;
     1:       }
 55427:     }
     1: 
 59538:     bool isKnownInvalidPlugin = false;
 59080:     for (nsRefPtr<nsInvalidPluginTag> invalidPlugins = mInvalidPlugins;
 59080:          invalidPlugins; invalidPlugins = invalidPlugins->mNext) {
 59080:       // If already marked as invalid, ignore it
 64609:       if (invalidPlugins->mFullPath.Equals(filePath.get()) &&
 59080:           invalidPlugins->mLastModifiedTime == fileModTime) {
 59080:         if (aCreatePluginList) {
 59080:           invalidPlugins->mSeen = true;
 59080:         }
 59080:         isKnownInvalidPlugin = true;
 59080:         break;
 59080:       }
 59080:     }
 59080:     if (isKnownInvalidPlugin) {
 59080:       continue;
 59080:     }
 59080: 
     1:     // if it is not found in cache info list or has been changed, create a new one
     1:     if (!pluginTag) {
 70974:       nsPluginFile pluginFile(localfile);
     1: 
     1:       // create a tag describing this plugin.
106838:       PRLibrary *library = nullptr;
 22547:       nsPluginInfo info;
 22547:       memset(&info, 0, sizeof(info));
 50781:       nsresult res = pluginFile.GetPluginInfo(info, &library);
 22547:       // if we don't have mime type don't proceed, this is not a plugin
 22547:       if (NS_FAILED(res) || !info.fMimeTypeArray) {
 64609:         nsRefPtr<nsInvalidPluginTag> invalidTag = new nsInvalidPluginTag(filePath.get(),
 59080:                                                                          fileModTime);
     1:         pluginFile.FreePluginInfo(info);
 59080: 
 59080:         if (aCreatePluginList) {
 59538:           invalidTag->mSeen = true;
 59080:         }
 59080:         invalidTag->mNext = mInvalidPlugins;
 59080:         if (mInvalidPlugins) {
 59080:           mInvalidPlugins->mPrev = invalidTag;
 59080:         }
 59080:         mInvalidPlugins = invalidTag;
 59080: 
 59080:         // Mark aPluginsChanged so pluginreg is rewritten
 79533:         *aPluginsChanged = true;
     1:         continue;
     1:       }
     1: 
     1:       pluginTag = new nsPluginTag(&info);
     1:       pluginFile.FreePluginInfo(info);
 50781:       if (!pluginTag)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
 50781:       pluginTag->mLibrary = library;
     1:       pluginTag->mLastModifiedTime = fileModTime;
 21189: 
 21189:       nsCOMPtr<nsIBlocklistService> blocklist = do_GetService("@mozilla.org/extensions/blocklist;1");
 21189:       if (blocklist) {
108991:         uint32_t state;
 21189:         rv = blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
 21189:                                                 EmptyString(), &state);
 21189: 
 21189:         if (NS_SUCCEEDED(rv)) {
104371:           // If the blocklist says so, block the plugin.
104371:           // If the blocklist says it is risky and we have never seen this
104371:           // plugin before, then disable it.
104371:           // If the blocklist says this is an outdated plugin, warn about
104371:           // outdated plugins.
104371:           // If the blocklist says the plugin is one of the click-to-play
104371:           // states, set the click-to-play flag.
104371:           if (state == nsIBlocklistService::STATE_BLOCKED) {
 21189:              pluginTag->Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
104371:           }
104371:           if (state == nsIBlocklistService::STATE_SOFTBLOCKED && !seenBefore) {
 79533:              enabled = false;
104371:           }
104371:           if (state == nsIBlocklistService::STATE_OUTDATED && !seenBefore) {
 79533:              warnOutdated = true;
 21189:           }
104371:         }
104371:       }
104371: 
104371:       if (!enabled) {
 21186:         pluginTag->UnMark(NS_PLUGIN_FLAG_ENABLED);
104371:       }
 21186: 
 50781:       // Plugin unloading is tag-based. If we created a new tag and loaded
 50781:       // the library in the process then we want to attempt to unload it here.
 50781:       // Only do this if the pref is set for aggressive unloading.
 50781:       if (UnloadPluginsASAP()) {
 90104:         pluginTag->TryUnloadPlugin(false);
 50781:       }
     1:     }
     1: 
 21231:     // do it if we still want it
 57939:     if (!seenBefore) {
 55427:       // We have a valid new plugin so report that plugins have changed.
 79533:       *aPluginsChanged = true;
 57939:     }
 55427: 
106355:     // Avoid adding different versions of the same plugin if they are running 
106355:     // in-process, otherwise we risk undefined behaviour.
106355:     if (!nsNPAPIPlugin::RunPluginOOP(pluginTag)) {
107562:       if (HaveSamePlugin(pluginTag)) {
106355:         continue;
106355:       }
106355:     }
106355: 
106355:     // Don't add the same plugin again if it hasn't changed
106355:     if (nsPluginTag* duplicate = FirstPluginWithPath(pluginTag->mFullPath)) {
115935:       if (pluginTag->mLastModifiedTime == duplicate->mLastModifiedTime) {
106355:         continue;
106355:       }
106355:     }
106355: 
 55427:     // If we're not creating a plugin list, simply looking for changes,
 55427:     // then we're done.
 55427:     if (!aCreatePluginList) {
 55427:       return NS_OK;
 55427:     }
 55427: 
     1:     pluginTag->SetHost(this);
 70974: 
 70974:     // Add plugin tags such that the list is ordered by modification date,
 70974:     // newest to oldest. This is ugly, it'd be easier with just about anything
 70974:     // other than a single-directional linked list.
 70974:     if (mPlugins) {
106838:       nsPluginTag *prev = nullptr;
 70974:       nsPluginTag *next = mPlugins;
 70974:       while (next) {
 70974:         if (pluginTag->mLastModifiedTime >= next->mLastModifiedTime) {
 70974:           pluginTag->mNext = next;
 70974:           if (prev) {
 70974:             prev->mNext = pluginTag;
 70974:           } else {
     1:             mPlugins = pluginTag;
 70974:           }
 70974:           break;
 70974:         }
 70974:         prev = next;
 70974:         next = prev->mNext;
 70974:         if (!next) {
 70974:           prev->mNext = pluginTag;
 70974:         }
 70974:       }
 70974:     } else {
 70974:       mPlugins = pluginTag;
 70974:     }
 70974: 
 70974:     if (pluginTag->IsEnabled()) {
104192:       nsAdoptingCString disableFullPage =
104192:         Preferences::GetCString(kPrefDisableFullPage);
108991:       for (uint32_t i = 0; i < pluginTag->mMimeTypes.Length(); i++) {
104192:         if (!IsTypeInList(pluginTag->mMimeTypes[i], disableFullPage)) {
104192:           RegisterWithCategoryManager(pluginTag->mMimeTypes[i],
104192:                                       ePluginRegister);
104192:         }
104192:       }
     1:     }
     1:   }
 70974: 
 70974:   if (warnOutdated) {
 94707:     Preferences::SetBool("plugins.update.notifyUser", true);
 70974:   }
 33384: 
     1:   return NS_OK;
     1: }
     1: 
 29956: nsresult nsPluginHost::ScanPluginsDirectoryList(nsISimpleEnumerator *dirEnum,
 79445:                                                 bool aCreatePluginList,
 79445:                                                 bool *aPluginsChanged)
     1: {
 79445:     bool hasMore;
     1:     while (NS_SUCCEEDED(dirEnum->HasMoreElements(&hasMore)) && hasMore) {
     1:       nsCOMPtr<nsISupports> supports;
     1:       nsresult rv = dirEnum->GetNext(getter_AddRefs(supports));
     1:       if (NS_FAILED(rv))
     1:         continue;
     1:       nsCOMPtr<nsIFile> nextDir(do_QueryInterface(supports, &rv));
     1:       if (NS_FAILED(rv))
     1:         continue;
     1: 
     1:       // don't pass aPluginsChanged directly to prevent it from been reset
 79445:       bool pluginschanged = false;
 64520:       ScanPluginsDirectory(nextDir, aCreatePluginList, &pluginschanged);
     1: 
     1:       if (pluginschanged)
 79533:         *aPluginsChanged = true;
     1: 
     1:       // if changes are detected and we are not creating the list, do not proceed
     1:       if (!aCreatePluginList && *aPluginsChanged)
     1:         break;
     1:     }
     1:     return NS_OK;
     1: }
     1: 
 70185: nsresult nsPluginHost::LoadPlugins()
     1: {
 88498: #ifdef ANDROID
 88498:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
 88498:     return NS_OK;
 88498:   }
 88498: #endif
     1:   // do not do anything if it is already done
     1:   // use ReloadPlugins() to enforce loading
     1:   if (mPluginsLoaded)
     1:     return NS_OK;
     1: 
 37523:   if (mPluginsDisabled)
 37523:     return NS_OK;
 37523: 
 79445:   bool pluginschanged;
 79533:   nsresult rv = FindPlugins(true, &pluginschanged);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 29936:   // only if plugins have changed will we notify plugin-change observers
     1:   if (pluginschanged) {
 41540:     nsCOMPtr<nsIObserverService> obsService =
 41540:       mozilla::services::GetObserverService();
  3464:     if (obsService)
106838:       obsService->NotifyObservers(nullptr, "plugins-list-updated", nullptr);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // if aCreatePluginList is false we will just scan for plugins
     1: // and see if any changes have been made to the plugins.
     1: // This is needed in ReloadPlugins to prevent possible recursive reloads
 79445: nsresult nsPluginHost::FindPlugins(bool aCreatePluginList, bool * aPluginsChanged)
     1: {
 72925:   Telemetry::AutoTimer<Telemetry::FIND_PLUGINS> telemetry;
     1: 
     1:   NS_ENSURE_ARG_POINTER(aPluginsChanged);
     1: 
 79533:   *aPluginsChanged = false;
     1:   nsresult rv;
     1: 
 32940:   // Read cached plugins info. If the profile isn't yet available then don't
 32940:   // scan for plugins
 32940:   if (ReadPluginInfo() == NS_ERROR_NOT_AVAILABLE)
 32940:     return NS_OK;
     1: 
  3715: #ifdef XP_WIN
     1:   // Failure here is not a show-stopper so just warn.
     1:   rv = EnsurePrivateDirServiceProvider();
     1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to register dir service provider.");
  3715: #endif /* XP_WIN */
     1: 
     1:   nsCOMPtr<nsIProperties> dirService(do_GetService(kDirectoryServiceContractID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   nsCOMPtr<nsISimpleEnumerator> dirList;
     1: 
     1:   // Scan plugins directories;
     1:   // don't pass aPluginsChanged directly, to prevent its
     1:   // possible reset in subsequent ScanPluginsDirectory calls
 79445:   bool pluginschanged = false;
     1: 
     1:   // Scan the app-defined list of plugin dirs.
     1:   rv = dirService->Get(NS_APP_PLUGINS_DIR_LIST, NS_GET_IID(nsISimpleEnumerator), getter_AddRefs(dirList));
     1:   if (NS_SUCCEEDED(rv)) {
 64520:     ScanPluginsDirectoryList(dirList, aCreatePluginList, &pluginschanged);
     1: 
     1:     if (pluginschanged)
 79533:       *aPluginsChanged = true;
     1: 
     1:     // if we are just looking for possible changes,
     1:     // no need to proceed if changes are detected
     1:     if (!aCreatePluginList && *aPluginsChanged) {
 31646:       NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59539:       NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
     1:       return NS_OK;
     1:     }
 78424:   } else {
 78424: #ifdef ANDROID
 78424:     LOG("getting plugins dir failed");
 78424: #endif
     1:   }
     1: 
 79533:   mPluginsLoaded = true; // at this point 'some' plugins have been loaded,
     1:                             // the rest is optional
     1: 
  3715: #ifdef XP_WIN
 94707:   bool bScanPLIDs = Preferences::GetBool("plugin.scan.plid.all", false);
     1: 
     1:     // Now lets scan any PLID directories
     1:   if (bScanPLIDs && mPrivateDirServiceProvider) {
     1:     rv = mPrivateDirServiceProvider->GetPLIDDirectories(getter_AddRefs(dirList));
     1:     if (NS_SUCCEEDED(rv)) {
 64520:       ScanPluginsDirectoryList(dirList, aCreatePluginList, &pluginschanged);
     1: 
     1:       if (pluginschanged)
 79533:         *aPluginsChanged = true;
     1: 
     1:       // if we are just looking for possible changes,
     1:       // no need to proceed if changes are detected
     1:       if (!aCreatePluginList && *aPluginsChanged) {
 31646:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59539:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
     1:         return NS_OK;
     1:       }
     1:     }
     1:   }
     1: 
     1: 
     1:   // Scan the installation paths of our popular plugins if the prefs are enabled
     1: 
     1:   // This table controls the order of scanning
 64520:   const char* const prefs[] = {NS_WIN_JRE_SCAN_KEY,
 64520:                                NS_WIN_ACROBAT_SCAN_KEY,
 64520:                                NS_WIN_QUICKTIME_SCAN_KEY,
 64520:                                NS_WIN_WMP_SCAN_KEY};
     1: 
108991:   uint32_t size = sizeof(prefs) / sizeof(prefs[0]);
108991: 
108991:   for (uint32_t i = 0; i < size; i+=1) {
     1:     nsCOMPtr<nsIFile> dirToScan;
 79445:     bool bExists;
     1:     if (NS_SUCCEEDED(dirService->Get(prefs[i], NS_GET_IID(nsIFile), getter_AddRefs(dirToScan))) &&
     1:         dirToScan &&
     1:         NS_SUCCEEDED(dirToScan->Exists(&bExists)) &&
     1:         bExists) {
     1: 
 64520:       ScanPluginsDirectory(dirToScan, aCreatePluginList, &pluginschanged);
     1: 
     1:       if (pluginschanged)
 79533:         *aPluginsChanged = true;
     1: 
     1:       // if we are just looking for possible changes,
     1:       // no need to proceed if changes are detected
     1:       if (!aCreatePluginList && *aPluginsChanged) {
 31646:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59539:         NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
     1:         return NS_OK;
     1:       }
     1:     }
     1:   }
     1: #endif
     1: 
101944:   // We should also consider plugins to have changed if any plugins have been removed.
101944:   // We'll know if any were removed if they weren't taken out of the cached plugins list
101944:   // during our scan, thus we can assume something was removed if the cached plugins list
101944:   // contains anything.
101944:   if (!*aPluginsChanged && mCachedPlugins) {
 79533:     *aPluginsChanged = true;
     1:   }
     1: 
 59080:   // Remove unseen invalid plugins
 59080:   nsRefPtr<nsInvalidPluginTag> invalidPlugins = mInvalidPlugins;
 59080:   while (invalidPlugins) {
 59080:     if (!invalidPlugins->mSeen) {
 59080:       nsRefPtr<nsInvalidPluginTag> invalidPlugin = invalidPlugins;
 59080: 
 59080:       if (invalidPlugin->mPrev) {
 59080:         invalidPlugin->mPrev->mNext = invalidPlugin->mNext;
 59080:       }
 59080:       else {
 59080:         mInvalidPlugins = invalidPlugin->mNext;
 59080:       }
 59080:       if (invalidPlugin->mNext) {
 59080:         invalidPlugin->mNext->mPrev = invalidPlugin->mPrev;
 59080:       }
 59080: 
 59080:       invalidPlugins = invalidPlugin->mNext;
 59080: 
 59080:       invalidPlugin->mPrev = NULL;
 59080:       invalidPlugin->mNext = NULL;
 59080:     }
 59080:     else {
 59538:       invalidPlugins->mSeen = false;
 59080:       invalidPlugins = invalidPlugins->mNext;
 59080:     }
 59080:   }
 59080: 
     1:   // if we are not creating the list, there is no need to proceed
     1:   if (!aCreatePluginList) {
 31646:     NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59539:     NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
     1:     return NS_OK;
     1:   }
     1: 
     1:   // if we are creating the list, it is already done;
     1:   // update the plugins info cache if changes are detected
     1:   if (*aPluginsChanged)
     1:     WritePluginInfo();
     1: 
     1:   // No more need for cached plugins. Clear it up.
 31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59539:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 29956: nsPluginHost::UpdatePluginInfo(nsPluginTag* aPluginTag)
  3102: {
  3102:   ReadPluginInfo();
  3102:   WritePluginInfo();
 31646:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsPluginTag>, mCachedPlugins, mNext);
 59539:   NS_ITERATIVE_UNREF_LIST(nsRefPtr<nsInvalidPluginTag>, mInvalidPlugins, mNext);
  3464: 
104192:   if (!aPluginTag) {
  3464:     return NS_OK;
104192:   }
104192: 
104192:   // Update types with category manager
104192:   nsAdoptingCString disableFullPage =
104192:     Preferences::GetCString(kPrefDisableFullPage);
108991:   for (uint32_t i = 0; i < aPluginTag->mMimeTypes.Length(); i++) {
104192:     nsRegisterType shouldRegister;
104192: 
104192:     if (IsTypeInList(aPluginTag->mMimeTypes[i], disableFullPage)) {
104192:       shouldRegister = ePluginUnregister;
104192:     } else {
104192:       nsPluginTag *plugin = FindPluginForType(aPluginTag->mMimeTypes[i].get(),
104192:                                               true);
104192:       shouldRegister = plugin ? ePluginRegister : ePluginUnregister;
104192:     }
104192: 
104192:     RegisterWithCategoryManager(aPluginTag->mMimeTypes[i], shouldRegister);
104192:   }
104192: 
127501:   nsCOMPtr<nsIObserverService> obsService =
127501:     mozilla::services::GetObserverService();
127501:   if (obsService)
127501:     obsService->NotifyObservers(nullptr, "plugin-info-updated", nullptr);
127501: 
104192:   // Reload instances if needed
104192:   if (aPluginTag->IsEnabled()) {
104192:     return NS_OK;
104192:   }
  3464: 
127628:   nsTArray<nsCOMPtr<nsIDocument> > instsToReload;
127628:   DestroyRunningInstances(&instsToReload, aPluginTag);
127628:   
127628:   if (!instsToReload.IsEmpty()) {
  3464:     nsCOMPtr<nsIRunnable> ev = new nsPluginDocReframeEvent(instsToReload);
  3464:     if (ev)
  3464:       NS_DispatchToCurrentThread(ev);
  3464:   }
  3102: 
  3102:   return NS_OK;
  3102: }
  3102: 
103876: /* static */ bool
103876: nsPluginHost::IsTypeWhitelisted(const char *aMimeType)
103876: {
104191:   nsAdoptingCString whitelist = Preferences::GetCString(kPrefWhitelist);
104191:   if (!whitelist.Length()) {
103876:     return true;
103876:   }
103876:   nsDependentCString wrap(aMimeType);
104191:   return IsTypeInList(wrap, whitelist);
103876: }
103876: 
104192: void
104192: nsPluginHost::RegisterWithCategoryManager(nsCString &aMimeType,
104192:                                           nsRegisterType aType)
104192: {
104192:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
104192:              ("nsPluginTag::RegisterWithCategoryManager type = %s, removing = %s\n",
104192:               aMimeType.get(), aType == ePluginUnregister ? "yes" : "no"));
104192: 
104192:   nsCOMPtr<nsICategoryManager> catMan =
104192:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
104192:   if (!catMan) {
104192:     return;
104192:   }
104192: 
104192:   const char *contractId =
104192:     "@mozilla.org/content/plugin/document-loader-factory;1";
104192: 
104192:   if (aType == ePluginRegister) {
104192:     catMan->AddCategoryEntry("Gecko-Content-Viewers",
104192:                              aMimeType.get(),
104192:                              contractId,
104192:                              false, /* persist: broken by bug 193031 */
104192:                              mOverrideInternalTypes,
106838:                              nullptr);
104192:   } else {
104192:     // Only delete the entry if a plugin registered for it
104192:     nsXPIDLCString value;
104192:     nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers",
104192:                                            aMimeType.get(),
104192:                                            getter_Copies(value));
104192:     if (NS_SUCCEEDED(rv) && strcmp(value, contractId) == 0) {
104192:       catMan->DeleteCategoryEntry("Gecko-Content-Viewers",
104192:                                   aMimeType.get(),
104192:                                   true);
104192:     }
104192:   }
104192: }
104192: 
  3102: nsresult
 29956: nsPluginHost::WritePluginInfo()
     1: {
     1: 
     1:   nsresult rv = NS_OK;
     1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID,&rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
  4030:   directoryService->Get(NS_APP_USER_PROFILE_50_DIR, NS_GET_IID(nsIFile),
     1:                         getter_AddRefs(mPluginRegFile));
     1: 
     1:   if (!mPluginRegFile)
     1:     return NS_ERROR_FAILURE;
     1: 
106838:   PRFileDesc* fd = nullptr;
     1: 
     1:   nsCOMPtr<nsIFile> pluginReg;
     1: 
     1:   rv = mPluginRegFile->Clone(getter_AddRefs(pluginReg));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
110974:   nsAutoCString filename(kPluginRegistryFilename);
 64041:   filename.Append(".tmp");
 64041:   rv = pluginReg->AppendNative(filename);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
101111:   rv = pluginReg->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE, 0600, &fd);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 59080:   nsCOMPtr<nsIXULRuntime> runtime = do_GetService("@mozilla.org/xre/runtime;1");
 59080:   if (!runtime) {
 59080:     return NS_ERROR_FAILURE;
 59080:   }
 59080: 
110974:   nsAutoCString arch;
 59080:   rv = runtime->GetXPCOMABI(arch);
 59080:   if (NS_FAILED(rv)) {
 59080:     return rv;
 59080:   }
 59080: 
     1:   PR_fprintf(fd, "Generated File. Do not edit.\n");
     1: 
 59080:   PR_fprintf(fd, "\n[HEADER]\nVersion%c%s%c%c\nArch%c%s%c%c\n",
     1:              PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:              kPluginRegistryVersion,
     1:              PLUGIN_REGISTRY_FIELD_DELIMITER,
 59080:              PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 59080:              PLUGIN_REGISTRY_FIELD_DELIMITER,
 59080:              arch.get(),
 59080:              PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:              PLUGIN_REGISTRY_END_OF_LINE_MARKER);
     1: 
     1:   // Store all plugins in the mPlugins list - all plugins currently in use.
     1:   PR_fprintf(fd, "\n[PLUGINS]\n");
     1: 
101944:   for (nsPluginTag *tag = mPlugins; tag; tag = tag->mNext) {
     1:     // store each plugin info into the registry
     1:     // filename & fullpath are on separate line
     1:     // because they can contain field delimiter char
 15947:     PR_fprintf(fd, "%s%c%c\n%s%c%c\n%s%c%c\n",
 69610:       (tag->mFileName.get()),
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:       PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 69610:       (tag->mFullPath.get()),
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
 15947:       PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 69610:       (tag->mVersion.get()),
 15947:       PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:       PLUGIN_REGISTRY_END_OF_LINE_MARKER);
     1: 
     1:     // lastModifiedTimeStamp|canUnload|tag->mFlags
     1:     PR_fprintf(fd, "%lld%c%d%c%lu%c%c\n",
     1:       tag->mLastModifiedTime,
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
 90104:       false, // did store whether or not to unload in-process plugins
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:       tag->Flags(),
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:       PLUGIN_REGISTRY_END_OF_LINE_MARKER);
     1: 
     1:     //description, name & mtypecount are on separate line
     1:     PR_fprintf(fd, "%s%c%c\n%s%c%c\n%d\n",
 69610:       (tag->mDescription.get()),
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:       PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 69610:       (tag->mName.get()),
     1:       PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:       PLUGIN_REGISTRY_END_OF_LINE_MARKER,
 97617:       tag->mMimeTypes.Length());
     1: 
     1:     // Add in each mimetype this plugin supports
108991:     for (uint32_t i = 0; i < tag->mMimeTypes.Length(); i++) {
     1:       PR_fprintf(fd, "%d%c%s%c%s%c%s%c%c\n",
     1:         i,PLUGIN_REGISTRY_FIELD_DELIMITER,
 69610:         (tag->mMimeTypes[i].get()),
     1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
 69610:         (tag->mMimeDescriptions[i].get()),
     1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
 69610:         (tag->mExtensions[i].get()),
     1:         PLUGIN_REGISTRY_FIELD_DELIMITER,
     1:         PLUGIN_REGISTRY_END_OF_LINE_MARKER);
     1:     }
  6774:   }
     1: 
 59080:   PR_fprintf(fd, "\n[INVALID]\n");
 59080: 
 59080:   nsRefPtr<nsInvalidPluginTag> invalidPlugins = mInvalidPlugins;
 59080:   while (invalidPlugins) {
 59080:     // fullPath
 59080:     PR_fprintf(fd, "%s%c%c\n",
 64609:       (!invalidPlugins->mFullPath.IsEmpty() ? invalidPlugins->mFullPath.get() : ""),
 59080:       PLUGIN_REGISTRY_FIELD_DELIMITER,
 59080:       PLUGIN_REGISTRY_END_OF_LINE_MARKER);
 59080: 
 59080:     // lastModifiedTimeStamp
 59080:     PR_fprintf(fd, "%lld%c%c\n",
 59080:       invalidPlugins->mLastModifiedTime,
 59080:       PLUGIN_REGISTRY_FIELD_DELIMITER,
 59080:       PLUGIN_REGISTRY_END_OF_LINE_MARKER);
 59080: 
 59080:     invalidPlugins = invalidPlugins->mNext;
 59080:   }
 59080: 
     1:   PR_Close(fd);
 64041:   nsCOMPtr<nsIFile> parent;
101111:   rv = pluginReg->GetParent(getter_AddRefs(parent));
 64041:   NS_ENSURE_SUCCESS(rv, rv);
101111:   rv = pluginReg->MoveToNative(parent, kPluginRegistryFilename);
 64041:   return rv;
     1: }
     1: 
     1: nsresult
 29956: nsPluginHost::ReadPluginInfo()
     1: {
129942:   const long PLUGIN_REG_MIMETYPES_ARRAY_SIZE = 12;
129942:   const long PLUGIN_REG_MAX_MIMETYPES = 1000;
129942: 
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID,&rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
  4030:   directoryService->Get(NS_APP_USER_PROFILE_50_DIR, NS_GET_IID(nsIFile),
     1:                         getter_AddRefs(mPluginRegFile));
     1: 
 32940:   if (!mPluginRegFile) {
 32940:     // There is no profile yet, this will tell us if there is going to be one
 32940:     // in the future.
 32940:     directoryService->Get(NS_APP_PROFILE_DIR_STARTUP, NS_GET_IID(nsIFile),
 32940:                           getter_AddRefs(mPluginRegFile));
     1:     if (!mPluginRegFile)
     1:       return NS_ERROR_FAILURE;
 32940:     else
 32940:       return NS_ERROR_NOT_AVAILABLE;
 32940:   }
     1: 
106838:   PRFileDesc* fd = nullptr;
     1: 
     1:   nsCOMPtr<nsIFile> pluginReg;
     1: 
     1:   rv = mPluginRegFile->Clone(getter_AddRefs(pluginReg));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   rv = pluginReg->AppendNative(kPluginRegistryFilename);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
108991:   int64_t fileSize;
101111:   rv = pluginReg->GetFileSize(&fileSize);
 21231:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
108991:   int32_t flen = int64_t(fileSize);
     1:   if (flen == 0) {
     1:     NS_WARNING("Plugins Registry Empty!");
     1:     return NS_OK; // ERROR CONDITION
     1:   }
     1: 
     1:   nsPluginManifestLineReader reader;
     1:   char* registry = reader.Init(flen);
 21231:   if (!registry)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
101111:   rv = pluginReg->OpenNSPRFileDesc(PR_RDONLY, 0444, &fd);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   // set rv to return an error on goto out
     1:   rv = NS_ERROR_FAILURE;
     1: 
108991:   int32_t bread = PR_Read(fd, registry, flen);
     1:   PR_Close(fd);
     1: 
     1:   if (flen > bread)
     1:     return rv;
     1: 
 21231:   if (!ReadSectionHeader(reader, "HEADER"))
     1:     return rv;;
 21231: 
 21231:   if (!reader.NextLine())
     1:     return rv;
     1: 
     1:   char* values[6];
     1: 
     1:   // VersionLiteral, kPluginRegistryVersion
 21231:   if (2 != reader.ParseLine(values, 2))
     1:     return rv;
     1: 
     1:   // VersionLiteral
 21231:   if (PL_strcmp(values[0], "Version"))
     1:     return rv;
     1: 
     1:   // kPluginRegistryVersion
108991:   int32_t vdiff = mozilla::CompareVersions(values[1], kPluginRegistryVersion);
 96745:   mozilla::Version version(values[1]);
 64609:   // If this is a registry from some future version then don't attempt to read it
 64609:   if (vdiff > 0)
     1:     return rv;
 64609:   // If this is a registry from before the minimum then don't attempt to read it
 96745:   if (version < kMinimumRegistryVersion)
 64609:     return rv;
 64609: 
 64609:   // Registry v0.10 and upwards includes the plugin version field
 96745:   bool regHasVersion = (version >= "0.10");
 64609: 
 64609:   // Registry v0.13 and upwards includes the architecture
 96745:   if (version >= "0.13") {
 59080:     char* archValues[6];
 59080: 
 59080:     if (!reader.NextLine()) {
 59080:       return rv;
 59080:     }
 59080: 
 59080:     // ArchLiteral, Architecture
 59080:     if (2 != reader.ParseLine(archValues, 2)) {
 59080:       return rv;
 59080:     }
 59080: 
 59080:     // ArchLiteral
 59080:     if (PL_strcmp(archValues[0], "Arch")) {
 59080:       return rv;
 59080:     }
 59080: 
 59080:     nsCOMPtr<nsIXULRuntime> runtime = do_GetService("@mozilla.org/xre/runtime;1");
 59080:     if (!runtime) {
 59080:       return rv;
 59080:     }
 59080: 
110974:     nsAutoCString arch;
 59080:     if (NS_FAILED(runtime->GetXPCOMABI(arch))) {
 59080:       return rv;
 59080:     }
 59080: 
 59080:     // If this is a registry from a different architecture then don't attempt to read it
 59080:     if (PL_strcmp(archValues[1], arch.get())) {
 59080:       return rv;
 59080:     }
 64609:   }
 64609: 
 64609:   // Registry v0.13 and upwards includes the list of invalid plugins
 96745:   bool hasInvalidPlugins = (version >= "0.13");
 59080: 
 21231:   if (!ReadSectionHeader(reader, "PLUGINS"))
     1:     return rv;
     1: 
 64609: #if defined(XP_MACOSX)
 79445:   bool hasFullPathInFileNameField = false;
 64609: #else
 96745:   bool hasFullPathInFileNameField = (version < "0.11");
 64609: #endif
 64609: 
     1:   while (reader.NextLine()) {
 29020:     const char *filename;
 29020:     const char *fullpath;
110974:     nsAutoCString derivedFileName;
 29020: 
 64609:     if (hasInvalidPlugins && *reader.LinePtr() == '[') {
 59080:       break;
 59080:     }
 59080: 
 64609:     if (hasFullPathInFileNameField) {
 64609:       fullpath = reader.LinePtr();
 64609:       if (!reader.NextLine())
 64609:         return rv;
 64609:       // try to derive a file name from the full path
 64609:       if (fullpath) {
101111:         nsCOMPtr<nsIFile> file = do_CreateInstance("@mozilla.org/file/local;1");
 64609:         file->InitWithNativePath(nsDependentCString(fullpath));
 64609:         file->GetNativeLeafName(derivedFileName);
 64609:         filename = derivedFileName.get();
 64609:       } else {
 64609:         filename = NULL;
 64609:       }
 64609: 
 64609:       // skip the next line, useless in this version
 64609:       if (!reader.NextLine())
 64609:         return rv;
 64609:     } else {
 64606:       filename = reader.LinePtr();
 64606:       if (!reader.NextLine())
 64606:         return rv;
 64606: 
 29020:       fullpath = reader.LinePtr();
     1:       if (!reader.NextLine())
     1:         return rv;
 64609:     }
     1: 
 26026:     const char *version;
 64609:     if (regHasVersion) {
 21192:       version = reader.LinePtr();
 15947:       if (!reader.NextLine())
 15947:         return rv;
 64609:     } else {
 64609:       version = "0";
 64609:     }
 15947: 
     1:     // lastModifiedTimeStamp|canUnload|tag.mFlag
 21231:     if (reader.ParseLine(values, 3) != 3)
     1:       return rv;
     1: 
 21192:     // If this is an old plugin registry mark this plugin tag to be refreshed
108991:     int64_t lastmod = (vdiff == 0) ? nsCRT::atoll(values[0]) : -1;
108991:     uint32_t tagflag = atoi(values[2]);
     1:     if (!reader.NextLine())
     1:       return rv;
     1: 
126147:     char *description = reader.LinePtr();
     1:     if (!reader.NextLine())
     1:       return rv;
     1: 
126147: #if MOZ_WIDGET_ANDROID
126147:     // Flash on Android does not populate the version field, but it is tacked on to the description.
126147:     // For example, "Shockwave Flash 11.1 r115"
126147:     if (PL_strncmp("Shockwave Flash ", description, 16) == 0 && description[16]) {
126147:       version = &description[16];
126147:     }
126147: #endif
126147: 
 26026:     const char *name = reader.LinePtr();
     1:     if (!reader.NextLine())
     1:       return rv;
     1: 
129942:     long mimetypecount = std::strtol(reader.LinePtr(), nullptr, 10);
129942:     if (mimetypecount == LONG_MAX || mimetypecount == LONG_MIN ||
129942:         mimetypecount >= PLUGIN_REG_MAX_MIMETYPES || mimetypecount < 0) {
129942:       return NS_ERROR_FAILURE;
129942:     }
     1: 
     1:     char *stackalloced[PLUGIN_REG_MIMETYPES_ARRAY_SIZE * 3];
     1:     char **mimetypes;
     1:     char **mimedescriptions;
     1:     char **extensions;
     1:     char **heapalloced = 0;
     1:     if (mimetypecount > PLUGIN_REG_MIMETYPES_ARRAY_SIZE - 1) {
     1:       heapalloced = new char *[mimetypecount * 3];
     1:       mimetypes = heapalloced;
     1:     } else {
     1:       mimetypes = stackalloced;
     1:     }
     1:     mimedescriptions = mimetypes + mimetypecount;
     1:     extensions = mimedescriptions + mimetypecount;
     1: 
     1:     int mtr = 0; //mimetype read
     1:     for (; mtr < mimetypecount; mtr++) {
     1:       if (!reader.NextLine())
     1:         break;
     1: 
     1:       //line number|mimetype|description|extension
     1:       if (4 != reader.ParseLine(values, 4))
     1:         break;
     1:       int line = atoi(values[0]);
     1:       if (line != mtr)
     1:         break;
     1:       mimetypes[mtr] = values[1];
     1:       mimedescriptions[mtr] = values[2];
     1:       extensions[mtr] = values[3];
     1:     }
     1: 
     1:     if (mtr != mimetypecount) {
     1:       if (heapalloced) {
     1:         delete [] heapalloced;
     1:       }
     1:       return rv;
     1:     }
     1: 
  3102:     nsRefPtr<nsPluginTag> tag = new nsPluginTag(name,
     1:       description,
     1:       filename,
 64609:       fullpath,
 15947:       version,
     1:       (const char* const*)mimetypes,
     1:       (const char* const*)mimedescriptions,
     1:       (const char* const*)extensions,
 90104:       mimetypecount, lastmod, true);
 21231:     if (heapalloced)
     1:       delete [] heapalloced;
 21231: 
 21231:     if (!tag)
     1:       continue;
     1: 
     1:     // Mark plugin as loaded from cache
     1:     tag->Mark(tagflag | NS_PLUGIN_FLAG_FROMCACHE);
     1:     PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
 12988:       ("LoadCachedPluginsInfo : Loading Cached plugininfo for %s\n", tag->mFileName.get()));
     1:     tag->mNext = mCachedPlugins;
     1:     mCachedPlugins = tag;
 59080:   }
 59080: 
 64609:   if (hasInvalidPlugins) {
 59080:     if (!ReadSectionHeader(reader, "INVALID")) {
 59080:       return rv;
 59080:     }
 59080: 
 59080:     while (reader.NextLine()) {
 59080:       const char *fullpath = reader.LinePtr();
 59080:       if (!reader.NextLine()) {
 59080:         return rv;
 59080:       }
 59080: 
 59080:       const char *lastModifiedTimeStamp = reader.LinePtr();
108991:       int64_t lastmod = (vdiff == 0) ? nsCRT::atoll(lastModifiedTimeStamp) : -1;
 64609: 
 64609:       nsRefPtr<nsInvalidPluginTag> invalidTag = new nsInvalidPluginTag(fullpath, lastmod);
 59080: 
 59080:       invalidTag->mNext = mInvalidPlugins;
 59080:       if (mInvalidPlugins) {
 59080:         mInvalidPlugins->mPrev = invalidTag;
 59080:       }
 59080:       mInvalidPlugins = invalidTag;
 59080:     }
 64609:   }
     1:   return NS_OK;
     1: }
     1: 
  3102: void
 64609: nsPluginHost::RemoveCachedPluginsInfo(const char *filePath, nsPluginTag **result)
  3102: {
  3102:   nsRefPtr<nsPluginTag> prev;
  3102:   nsRefPtr<nsPluginTag> tag = mCachedPlugins;
  3102:   while (tag)
     1:   {
 29020:     if (tag->mFullPath.Equals(filePath)) {
     1:       // Found it. Remove it from our list
  3102:       if (prev)
  3102:         prev->mNext = tag->mNext;
  3102:       else
  3102:         mCachedPlugins = tag->mNext;
106838:       tag->mNext = nullptr;
  3102:       *result = tag;
  3102:       NS_ADDREF(*result);
  3102:       break;
  3102:     }
  3102:     prev = tag;
  3102:     tag = tag->mNext;
  3102:   }
     1: }
     1: 
  3715: #ifdef XP_WIN
     1: nsresult
 29956: nsPluginHost::EnsurePrivateDirServiceProvider()
     1: {
 21231:   if (!mPrivateDirServiceProvider) {
     1:     nsresult rv;
     1:     mPrivateDirServiceProvider = new nsPluginDirServiceProvider();
     1:     if (!mPrivateDirServiceProvider)
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     nsCOMPtr<nsIDirectoryService> dirService(do_GetService(kDirectoryServiceContractID, &rv));
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:     rv = dirService->RegisterProvider(mPrivateDirServiceProvider);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:   }
     1:   return NS_OK;
     1: }
  3715: #endif /* XP_WIN */
     1: 
 29956: nsresult nsPluginHost::NewPluginURLStream(const nsString& aURL,
 47835:                                           nsNPAPIPluginInstance *aInstance,
 98780:                                           nsNPAPIPluginStreamListener* aListener,
 36766:                                           nsIInputStream *aPostStream,
     1:                                           const char *aHeadersData,
108991:                                           uint32_t aHeadersDataLen)
     1: {
     1:   nsCOMPtr<nsIURI> url;
     1:   nsAutoString absUrl;
     1:   nsresult rv;
     1: 
     1:   if (aURL.Length() <= 0)
     1:     return NS_OK;
     1: 
124894:   // get the base URI for the plugin to create an absolute url 
124894:   // in case aURL is relative
115860:   nsRefPtr<nsPluginInstanceOwner> owner = aInstance->GetOwner();
 21231:   if (owner) {
124894:     rv = NS_MakeAbsoluteURI(absUrl, aURL, nsCOMPtr<nsIURI>(owner->GetBaseURI()));
     1:   }
     1: 
     1:   if (absUrl.IsEmpty())
     1:     absUrl.Assign(aURL);
     1: 
     1:   rv = NS_NewURI(getter_AddRefs(url), absUrl);
 34262:   if (NS_FAILED(rv))
 34262:     return rv;
 34262: 
   353:   nsCOMPtr<nsIDOMElement> element;
124894:   nsCOMPtr<nsIDocument> doc;
124894:   if (owner) {
115860:     owner->GetDOMElement(getter_AddRefs(element));
124894:     owner->GetDocument(getter_AddRefs(doc));
124894:   }
   353: 
108991:   int16_t shouldLoad = nsIContentPolicy::ACCEPT;
  2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT_SUBREQUEST,
   353:                                  url,
106838:                                  (doc ? doc->NodePrincipal() : nullptr),
   353:                                  element,
   353:                                  EmptyCString(), //mime guess
106838:                                  nullptr,         //extra
   353:                                  &shouldLoad);
 34262:   if (NS_FAILED(rv))
 34262:     return rv;
   353:   if (NS_CP_REJECTED(shouldLoad)) {
   353:     // Disallowed by content policy
   353:     return NS_ERROR_CONTENT_BLOCKED;
   353:   }
   353: 
 36766:   nsRefPtr<nsPluginStreamListenerPeer> listenerPeer = new nsPluginStreamListenerPeer();
 47835:   if (!listenerPeer)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   rv = listenerPeer->Initialize(url, aInstance, aListener);
 36766:   if (NS_FAILED(rv))
 34262:     return rv;
 34262: 
     1:   nsCOMPtr<nsIChannel> channel;
106838:   rv = NS_NewChannel(getter_AddRefs(channel), url, nullptr,
106838:     nullptr, /* do not add this internal plugin's channel
     1:             on the load group otherwise this channel could be canceled
 28078:             form |nsDocShell::OnLinkClickSync| bug 166613 */
 57651:     listenerPeer);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 21231:   if (doc) {
     1:     // Set the owner of channel to the document principal...
     1:     channel->SetOwner(doc->NodePrincipal());
     1: 
     1:     // And if it's a script allow it to execute against the
     1:     // document's script context.
     1:     nsCOMPtr<nsIScriptChannel> scriptChannel(do_QueryInterface(channel));
     1:     if (scriptChannel) {
     1:       scriptChannel->SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
  2364:       // Plug-ins seem to depend on javascript: URIs running synchronously
 79533:       scriptChannel->SetExecuteAsync(false);
     1:     }
     1:   }
     1: 
     1:   // deal with headers and post data
     1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
     1:   if (httpChannel) {
 90301:     if (!aPostStream) {
 90301:       // Only set the Referer header for GET requests because IIS throws
 90301:       // errors about malformed requests if we include it in POSTs. See
 90301:       // bug 724465.
 92097:       nsCOMPtr<nsIURI> referer;
 92097: 
 92097:       nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(element);
 92097:       if (olc)
 92097:         olc->GetSrcURI(getter_AddRefs(referer));
 92097: 
 92097: 
124894:       if (!referer) {
124894:         if (!doc) {
124894:           return NS_ERROR_FAILURE;
124894:         }
 92097:         referer = doc->GetDocumentURI();
124894:       }
 92097: 
 92097:       rv = httpChannel->SetReferrer(referer);
 87122:       NS_ENSURE_SUCCESS(rv,rv);
 90301:     }
 87122: 
 36766:     if (aPostStream) {
     1:       // XXX it's a bit of a hack to rewind the postdata stream
     1:       // here but it has to be done in case the post data is
     1:       // being reused multiple times.
     1:       nsCOMPtr<nsISeekableStream>
 36766:       postDataSeekable(do_QueryInterface(aPostStream));
     1:       if (postDataSeekable)
     1:         postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
     1: 
     1:       nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
     1:       NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
     1: 
 36766:       uploadChannel->SetUploadStream(aPostStream, EmptyCString(), -1);
     1:     }
     1: 
 87122:     if (aHeadersData) {
     1:       rv = AddHeadersToChannel(aHeadersData, aHeadersDataLen, httpChannel);
 87122:       NS_ENSURE_SUCCESS(rv,rv);
 87122:     }
     1:   }
106838:   rv = channel->AsyncOpen(listenerPeer, nullptr);
 63058:   if (NS_SUCCEEDED(rv))
 63058:     listenerPeer->TrackRequest(channel);
     1:   return rv;
     1: }
     1: 
 21231: // Called by GetURL and PostURL
     1: nsresult
 47835: nsPluginHost::DoURLLoadSecurityCheck(nsNPAPIPluginInstance *aInstance,
     1:                                      const char* aURL)
     1: {
     1:   if (!aURL || *aURL == '\0')
     1:     return NS_OK;
     1: 
124894:   // get the base URI for the plugin element
115860:   nsRefPtr<nsPluginInstanceOwner> owner = aInstance->GetOwner();
     1:   if (!owner)
     1:     return NS_ERROR_FAILURE;
     1: 
124894:   nsCOMPtr<nsIURI> baseURI = owner->GetBaseURI();
124894:   if (!baseURI)
124894:     return NS_ERROR_FAILURE;
124894: 
124894:   // Create an absolute URL for the target in case the target is relative
124894:   nsCOMPtr<nsIURI> targetURL;
124894:   NS_NewURI(getter_AddRefs(targetURL), aURL, baseURI);
124894:   if (!targetURL)
124894:     return NS_ERROR_FAILURE;
124894: 
 29834:   nsCOMPtr<nsIDocument> doc;
 29834:   owner->GetDocument(getter_AddRefs(doc));
     1:   if (!doc)
     1:     return NS_ERROR_FAILURE;
     1: 
 29834:   nsresult rv;
     1:   nsCOMPtr<nsIScriptSecurityManager> secMan(
     1:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   return secMan->CheckLoadURIWithPrincipal(doc->NodePrincipal(), targetURL,
     1:                                            nsIScriptSecurityManager::STANDARD);
     1: 
     1: }
     1: 
 29574: nsresult
 29956: nsPluginHost::AddHeadersToChannel(const char *aHeadersData,
108991:                                   uint32_t aHeadersDataLen,
     1:                                   nsIChannel *aGenericChannel)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
     1:   nsCOMPtr<nsIHttpChannel> aChannel = do_QueryInterface(aGenericChannel);
     1:   if (!aChannel) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   // used during the manipulation of the String from the aHeadersData
110974:   nsAutoCString headersString;
110974:   nsAutoCString oneHeader;
110974:   nsAutoCString headerName;
110974:   nsAutoCString headerValue;
108991:   int32_t crlf = 0;
108991:   int32_t colon = 0;
     1: 
     1:   // Turn the char * buffer into an nsString.
     1:   headersString = aHeadersData;
     1: 
     1:   // Iterate over the nsString: for each "\r\n" delimited chunk,
     1:   // add the value as a header to the nsIHTTPChannel
 79533:   while (true) {
 79533:     crlf = headersString.Find("\r\n", true);
     1:     if (-1 == crlf) {
     1:       rv = NS_OK;
     1:       return rv;
     1:     }
     1:     headersString.Mid(oneHeader, 0, crlf);
     1:     headersString.Cut(0, crlf + 2);
     1:     oneHeader.StripWhitespace();
     1:     colon = oneHeader.Find(":");
     1:     if (-1 == colon) {
     1:       rv = NS_ERROR_NULL_POINTER;
     1:       return rv;
     1:     }
     1:     oneHeader.Left(headerName, colon);
     1:     colon++;
     1:     oneHeader.Mid(headerValue, colon, oneHeader.Length() - colon);
     1: 
     1:     // FINALLY: we can set the header!
     1: 
 79533:     rv = aChannel->SetRequestHeader(headerName, headerValue, true);
     1:     if (NS_FAILED(rv)) {
     1:       rv = NS_ERROR_NULL_POINTER;
     1:       return rv;
     1:     }
     1:   }
     1:   return rv;
     1: }
     1: 
 70007: nsresult
 70007: nsPluginHost::StopPluginInstance(nsNPAPIPluginInstance* aInstance)
     1: {
 12417:   if (PluginDestructionGuard::DelayDestroy(aInstance)) {
 12417:     return NS_OK;
 12417:   }
 12417: 
     1:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 29956:   ("nsPluginHost::StopPluginInstance called instance=%p\n",aInstance));
     1: 
 73599:   if (aInstance->HasStartedDestroying()) {
 59756:     return NS_OK;
 73599:   }
 73599: 
 91297:   Telemetry::AutoTimer<Telemetry::PLUGIN_SHUTDOWN_MS> timer;
 82172:   aInstance->Stop();
 82172: 
 82172:   // if the instance does not want to be 'cached' just remove it
 82172:   bool doCache = aInstance->ShouldCache();
 82172:   if (doCache) {
 82172:     // try to get the max cached instances from a pref or use default
108991:     uint32_t cachedInstanceLimit =
 94707:       Preferences::GetUint(NS_PREF_MAX_NUM_CACHED_INSTANCES,
 94707:                            DEFAULT_NUMBER_OF_STOPPED_INSTANCES);
 82172:     if (StoppedInstanceCount() >= cachedInstanceLimit) {
 82172:       nsNPAPIPluginInstance *oldestInstance = FindOldestStoppedInstance();
 82172:       if (oldestInstance) {
 82172:         nsPluginTag* pluginTag = TagForPlugin(oldestInstance->GetPlugin());
 82172:         oldestInstance->Destroy();
 82172:         mInstances.RemoveElement(oldestInstance);
132310:         // TODO: Remove this check once bug 752422 was investigated
132310:         if (pluginTag) {          
 82172:           OnPluginInstanceDestroyed(pluginTag);
 82172:         }
 82172:       }
132310:     }
 82172:   } else {
 73599:     nsPluginTag* pluginTag = TagForPlugin(aInstance->GetPlugin());
 73599:     aInstance->Destroy();
 73599:     mInstances.RemoveElement(aInstance);
132310:     // TODO: Remove this check once bug 752422 was investigated
132310:     if (pluginTag) {      
 37525:       OnPluginInstanceDestroyed(pluginTag);
 82172:     }
132310:   }
 37525: 
     1:   return NS_OK;
     1: }
     1: 
125843: nsresult nsPluginHost::NewPluginStreamListener(nsIURI* aURI,
 47835:                                                nsNPAPIPluginInstance* aInstance,
 96820:                                                nsIStreamListener **aStreamListener)
     1: {
 96820:   NS_ENSURE_ARG_POINTER(aURI);
 96820:   NS_ENSURE_ARG_POINTER(aStreamListener);
     1: 
 47835:   nsRefPtr<nsPluginStreamListenerPeer> listener = new nsPluginStreamListenerPeer();
125843:   nsresult rv = listener->Initialize(aURI, aInstance, nullptr);
 96820:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
 96820:   listener.forget(aStreamListener);
 96820: 
 96820:   return NS_OK;
 96820: }
 96820: 
 29956: NS_IMETHODIMP nsPluginHost::Observe(nsISupports *aSubject,
     1:                                     const char *aTopic,
     1:                                     const PRUnichar *someData)
     1: {
 21231:   if (!nsCRT::strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic)) {
  3363:     OnShutdown();
 96798:     UnloadPlugins();
     1:     sInst->Release();
     1:   }
 97736:   if (!nsCRT::strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, aTopic)) {
 97736:     mPluginsDisabled = Preferences::GetBool("plugin.disable", false);
104371:     mPluginsClickToPlay = Preferences::GetBool("plugins.click_to_play", false);
 97736:     // Unload or load plugins as needed
 97736:     if (mPluginsDisabled) {
 97736:       UnloadPlugins();
 97736:     } else {
 97736:       LoadPlugins();
 97736:     }
 97736:   }
 90194: #ifdef MOZ_WIDGET_ANDROID
 90194:   if (!nsCRT::strcmp("application-background", aTopic)) {
108991:     for(uint32_t i = 0; i < mInstances.Length(); i++) {
 90194:       mInstances[i]->NotifyForeground(false);
 90194:     }
 90194:   }
 90194:   if (!nsCRT::strcmp("application-foreground", aTopic)) {
108991:     for(uint32_t i = 0; i < mInstances.Length(); i++) {
 90194:       if (mInstances[i]->IsOnScreen())
 90194:         mInstances[i]->NotifyForeground(true);
 90194:     }
 90194:   }
 90194:   if (!nsCRT::strcmp("memory-pressure", aTopic)) {
108991:     for(uint32_t i = 0; i < mInstances.Length(); i++) {
 90194:       mInstances[i]->MemoryPressure();
 90194:     }
 90194:   }
 90194: #endif
     1:   return NS_OK;
     1: }
     1: 
 70007: nsresult
108991: nsPluginHost::ParsePostBufferToFixHeaders(const char *inPostData, uint32_t inPostDataLen,
108991:                                           char **outPostData, uint32_t *outPostDataLen)
     1: {
     1:   if (!inPostData || !outPostData || !outPostDataLen)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   *outPostData = 0;
     1:   *outPostDataLen = 0;
     1: 
     1:   const char CR = '\r';
     1:   const char LF = '\n';
     1:   const char CRLFCRLF[] = {CR,LF,CR,LF,'\0'}; // C string"\r\n\r\n"
     1:   const char ContentLenHeader[] = "Content-length";
     1: 
 26912:   nsAutoTArray<const char*, 8> singleLF;
     1:   const char *pSCntlh = 0;// pointer to start of ContentLenHeader in inPostData
     1:   const char *pSod = 0;   // pointer to start of data in inPostData
     1:   const char *pEoh = 0;   // pointer to end of headers in inPostData
     1:   const char *pEod = inPostData + inPostDataLen; // pointer to end of inPostData
     1:   if (*inPostData == LF) {
     1:     // If no custom headers are required, simply add a blank
     1:     // line ('\n') to the beginning of the file or buffer.
     1:     // so *inPostData == '\n' is valid
     1:     pSod = inPostData + 1;
     1:   } else {
     1:     const char *s = inPostData; //tmp pointer to sourse inPostData
     1:     while (s < pEod) {
     1:       if (!pSCntlh &&
     1:           (*s == 'C' || *s == 'c') &&
     1:           (s + sizeof(ContentLenHeader) - 1 < pEod) &&
     1:           (!PL_strncasecmp(s, ContentLenHeader, sizeof(ContentLenHeader) - 1)))
     1:       {
     1:         // lets assume this is ContentLenHeader for now
     1:         const char *p = pSCntlh = s;
     1:         p += sizeof(ContentLenHeader) - 1;
     1:         // search for first CR or LF == end of ContentLenHeader
     1:         for (; p < pEod; p++) {
     1:           if (*p == CR || *p == LF) {
     1:             // got delimiter,
     1:             // one more check; if previous char is a digit
     1:             // most likely pSCntlh points to the start of ContentLenHeader
     1:             if (*(p-1) >= '0' && *(p-1) <= '9') {
     1:               s = p;
     1:             }
     1:             break; //for loop
     1:           }
     1:         }
     1:         if (pSCntlh == s) { // curret ptr is the same
     1:           pSCntlh = 0; // that was not ContentLenHeader
     1:           break; // there is nothing to parse, break *WHILE LOOP* here
     1:         }
     1:       }
     1: 
     1:       if (*s == CR) {
     1:         if (pSCntlh && // only if ContentLenHeader is found we are looking for end of headers
     1:             ((s + sizeof(CRLFCRLF)-1) <= pEod) &&
     1:             !memcmp(s, CRLFCRLF, sizeof(CRLFCRLF)-1))
     1:         {
     1:           s += sizeof(CRLFCRLF)-1;
     1:           pEoh = pSod = s; // data stars here
     1:           break;
     1:         }
     1:       } else if (*s == LF) {
     1:         if (*(s-1) != CR) {
 26912:           singleLF.AppendElement(s);
     1:         }
     1:         if (pSCntlh && (s+1 < pEod) && (*(s+1) == LF)) {
     1:           s++;
 26912:           singleLF.AppendElement(s);
     1:           s++;
     1:           pEoh = pSod = s; // data stars here
     1:           break;
     1:         }
     1:       }
     1:       s++;
     1:     }
     1:   }
     1: 
     1:   // deal with output buffer
     1:   if (!pSod) { // lets assume whole buffer is a data
     1:     pSod = inPostData;
     1:   }
     1: 
108991:   uint32_t newBufferLen = 0;
108991:   uint32_t dataLen = pEod - pSod;
108991:   uint32_t headersLen = pEoh ? pSod - inPostData : 0;
     1: 
     1:   char *p; // tmp ptr into new output buf
     1:   if (headersLen) { // we got a headers
     1:     // this function does not make any assumption on correctness
     1:     // of ContentLenHeader value in this case.
     1: 
     1:     newBufferLen = dataLen + headersLen;
     1:     // in case there were single LFs in headers
     1:     // reserve an extra space for CR will be added before each single LF
 26912:     int cntSingleLF = singleLF.Length();
     1:     newBufferLen += cntSingleLF;
     1: 
     1:     if (!(*outPostData = p = (char*)nsMemory::Alloc(newBufferLen)))
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     // deal with single LF
     1:     const char *s = inPostData;
     1:     if (cntSingleLF) {
     1:       for (int i=0; i<cntSingleLF; i++) {
 26912:         const char *plf = singleLF.ElementAt(i); // ptr to single LF in headers
     1:         int n = plf - s; // bytes to copy
     1:         if (n) { // for '\n\n' there is nothing to memcpy
     1:           memcpy(p, s, n);
     1:           p += n;
     1:         }
     1:         *p++ = CR;
     1:         s = plf;
     1:         *p++ = *s++;
     1:       }
     1:     }
     1:     // are we done with headers?
     1:     headersLen = pEoh - s;
     1:     if (headersLen) { // not yet
     1:       memcpy(p, s, headersLen); // copy the rest
     1:       p += headersLen;
     1:     }
     1:   } else  if (dataLen) { // no ContentLenHeader is found but there is a data
     1:     // make new output buffer big enough
     1:     // to keep ContentLenHeader+value followed by data
108991:     uint32_t l = sizeof(ContentLenHeader) + sizeof(CRLFCRLF) + 32;
     1:     newBufferLen = dataLen + l;
     1:     if (!(*outPostData = p = (char*)nsMemory::Alloc(newBufferLen)))
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     headersLen = PR_snprintf(p, l,"%s: %ld%s", ContentLenHeader, dataLen, CRLFCRLF);
     1:     if (headersLen == l) { // if PR_snprintf has ate all extra space consider this as an error
     1:       nsMemory::Free(p);
     1:       *outPostData = 0;
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     p += headersLen;
     1:     newBufferLen = headersLen + dataLen;
     1:   }
     1:   // at this point we've done with headers.
     1:   // there is a possibility that input buffer has only headers info in it
     1:   // which already parsed and copied into output buffer.
     1:   // copy the data
     1:   if (dataLen) {
     1:     memcpy(p, pSod, dataLen);
     1:   }
     1: 
     1:   *outPostDataLen = newBufferLen;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 70185: nsresult
 36766: nsPluginHost::CreateTempFileToPost(const char *aPostDataURL, nsIFile **aTmpFile)
     1: {
     1:   nsresult rv;
108991:   int64_t fileSize;
110974:   nsAutoCString filename;
     1: 
     1:   // stat file == get size & convert file:///c:/ to c: if needed
     1:   nsCOMPtr<nsIFile> inFile;
 36766:   rv = NS_GetFileFromURLSpec(nsDependentCString(aPostDataURL),
     1:                              getter_AddRefs(inFile));
     1:   if (NS_FAILED(rv)) {
101111:     nsCOMPtr<nsIFile> localFile;
 79533:     rv = NS_NewNativeLocalFile(nsDependentCString(aPostDataURL), false,
     1:                                getter_AddRefs(localFile));
     1:     if (NS_FAILED(rv)) return rv;
     1:     inFile = localFile;
     1:   }
     1:   rv = inFile->GetFileSize(&fileSize);
     1:   if (NS_FAILED(rv)) return rv;
     1:   rv = inFile->GetNativePath(filename);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
115934:   if (fileSize != 0) {
     1:     nsCOMPtr<nsIInputStream> inStream;
     1:     rv = NS_NewLocalFileInputStream(getter_AddRefs(inStream), inFile);
     1:     if (NS_FAILED(rv)) return rv;
     1: 
     1:     // Create a temporary file to write the http Content-length:
     1:     // %ld\r\n\" header and "\r\n" == end of headers for post data to
     1: 
     1:     nsCOMPtr<nsIFile> tempFile;
     1:     rv = GetPluginTempDir(getter_AddRefs(tempFile));
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
110974:     nsAutoCString inFileName;
     1:     inFile->GetNativeLeafName(inFileName);
     1:     // XXX hack around bug 70083
     1:     inFileName.Insert(NS_LITERAL_CSTRING("post-"), 0);
     1:     rv = tempFile->AppendNative(inFileName);
     1: 
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     // make it unique, and mode == 0600, not world-readable
     1:     rv = tempFile->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     nsCOMPtr<nsIOutputStream> outStream;
     1:     if (NS_SUCCEEDED(rv)) {
     1:       rv = NS_NewLocalFileOutputStream(getter_AddRefs(outStream),
     1:         tempFile,
     1:         (PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE),
     1:         0600); // 600 so others can't read our form data
     1:     }
     1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Post data file couldn't be created!");
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     char buf[1024];
108991:     uint32_t br, bw;
 79445:     bool firstRead = true;
     1:     while (1) {
     1:       // Read() mallocs if buffer is null
     1:       rv = inStream->Read(buf, 1024, &br);
108991:       if (NS_FAILED(rv) || (int32_t)br <= 0)
     1:         break;
     1:       if (firstRead) {
     1:         //"For protocols in which the headers must be distinguished from the body,
     1:         // such as HTTP, the buffer or file should contain the headers, followed by
     1:         // a blank line, then the body. If no custom headers are required, simply
     1:         // add a blank line ('\n') to the beginning of the file or buffer.
     1: 
     1:         char *parsedBuf;
     1:         // assuming first 1K (or what we got) has all headers in,
 29956:         // lets parse it through nsPluginHost::ParsePostBufferToFixHeaders()
     1:         ParsePostBufferToFixHeaders((const char *)buf, br, &parsedBuf, &bw);
     1:         rv = outStream->Write(parsedBuf, bw, &br);
     1:         nsMemory::Free(parsedBuf);
     1:         if (NS_FAILED(rv) || (bw != br))
     1:           break;
     1: 
 79533:         firstRead = false;
     1:         continue;
     1:       }
     1:       bw = br;
     1:       rv = outStream->Write(buf, bw, &br);
     1:       if (NS_FAILED(rv) || (bw != br))
     1:         break;
     1:     }
     1: 
     1:     inStream->Close();
     1:     outStream->Close();
 36766:     if (NS_SUCCEEDED(rv))
 36766:       *aTmpFile = tempFile.forget().get();
     1:   }
     1:   return rv;
     1: }
     1: 
 70185: nsresult
 29956: nsPluginHost::NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
     1: {
     1:   return PLUG_NewPluginNativeWindow(aPluginNativeWindow);
     1: }
     1: 
 70185: nsresult
 70007: nsPluginHost::GetPluginName(nsNPAPIPluginInstance *aPluginInstance,
 15698:                             const char** aPluginName)
 15698: {
 47965:   nsNPAPIPluginInstance *instance = static_cast<nsNPAPIPluginInstance*>(aPluginInstance);
 47965:   if (!instance)
 37525:     return NS_ERROR_FAILURE;
 37525: 
 47965:   nsNPAPIPlugin* plugin = instance->GetPlugin();
 47965:   if (!plugin)
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   *aPluginName = TagForPlugin(plugin)->mName.get();
 37525: 
 14390:   return NS_OK;
 14390: }
 14390: 
 70007: nsresult
 70007: nsPluginHost::GetPluginTagForInstance(nsNPAPIPluginInstance *aPluginInstance,
 33384:                                       nsIPluginTag **aPluginTag)
 33384: {
 33384:   NS_ENSURE_ARG_POINTER(aPluginInstance);
 33384:   NS_ENSURE_ARG_POINTER(aPluginTag);
 33384: 
 70007:   nsNPAPIPlugin *plugin = aPluginInstance->GetPlugin();
 47965:   if (!plugin)
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   *aPluginTag = TagForPlugin(plugin);
 47965: 
 33384:   NS_ADDREF(*aPluginTag);
 33384:   return NS_OK;
 33384: }
 33384: 
 36227: NS_IMETHODIMP nsPluginHost::Notify(nsITimer* timer)
 36227: {
 90104:   nsRefPtr<nsPluginTag> pluginTag = mPlugins;
 90104:   while (pluginTag) {
 90104:     if (pluginTag->mUnloadTimer == timer) {
 90104:       if (!IsRunningPlugin(pluginTag)) {
 90104:         pluginTag->TryUnloadPlugin(false);
 90104:       }
 90104:       return NS_OK;
 90104:     }
 90104:     pluginTag = pluginTag->mNext;
 90104:   }
 90104: 
 36227:   return NS_ERROR_FAILURE;
 36227: }
 36227: 
 56921: #ifdef XP_WIN
 56921: // Re-enable any top level browser windows that were disabled by modal dialogs
 56921: // displayed by the crashed plugin.
 56921: static void
 56921: CheckForDisabledWindows()
 56921: {
 56921:   nsCOMPtr<nsIWindowMediator> wm(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
 56921:   if (!wm)
 56921:     return;
 56921: 
 56921:   nsCOMPtr<nsISimpleEnumerator> windowList;
106838:   wm->GetXULWindowEnumerator(nullptr, getter_AddRefs(windowList));
 56921:   if (!windowList)
 56921:     return;
 56921: 
 79445:   bool haveWindows;
 56921:   do {
 56921:     windowList->HasMoreElements(&haveWindows);
 56921:     if (!haveWindows)
 56921:       return;
 56921: 
 56921:     nsCOMPtr<nsISupports> supportsWindow;
 56921:     windowList->GetNext(getter_AddRefs(supportsWindow));
 56921:     nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(supportsWindow));
 56921:     if (baseWin) {
 56921:       nsCOMPtr<nsIWidget> widget;
 56921:       baseWin->GetMainWidget(getter_AddRefs(widget));
 56921:       if (widget && !widget->GetParent() &&
105772:           widget->IsVisible() &&
106103:           !widget->IsEnabled()) {
 56921:         nsIWidget* child = widget->GetFirstChild();
 79445:         bool enable = true;
 56921:         while (child)  {
 56921:           nsWindowType aType;
 56921:           if (NS_SUCCEEDED(child->GetWindowType(aType)) &&
 56921:               aType == eWindowType_dialog) {
 79533:             enable = false;
 56921:             break;
 56921:           }
 56921:           child = child->GetNextSibling();
 56921:         }
 56921:         if (enable) {
 79533:           widget->Enable(true);
 56921:         }
 56921:       }
 56921:     }
 56921:   } while (haveWindows);
 56921: }
 56921: #endif
 56921: 
 36304: void
 39794: nsPluginHost::PluginCrashed(nsNPAPIPlugin* aPlugin,
 39794:                             const nsAString& pluginDumpID,
 39794:                             const nsAString& browserDumpID)
 36304: {
 47965:   nsPluginTag* crashedPluginTag = TagForPlugin(aPlugin);
 36304: 
 39794:   // Notify the app's observer that a plugin crashed so it can submit
 39794:   // a crashreport.
 79445:   bool submittedCrashReport = false;
 39794:   nsCOMPtr<nsIObserverService> obsService =
 41540:     mozilla::services::GetObserverService();
 39794:   nsCOMPtr<nsIWritablePropertyBag2> propbag =
 39794:     do_CreateInstance("@mozilla.org/hash-property-bag;1");
 38026:   if (obsService && propbag) {
 39794:     propbag->SetPropertyAsAString(NS_LITERAL_STRING("pluginDumpID"),
 39794:                                   pluginDumpID);
 39794:     propbag->SetPropertyAsAString(NS_LITERAL_STRING("browserDumpID"),
 39794:                                   browserDumpID);
 39794:     propbag->SetPropertyAsBool(NS_LITERAL_STRING("submittedCrashReport"),
 39794:                                submittedCrashReport);
106838:     obsService->NotifyObservers(propbag, "plugin-crashed", nullptr);
 38026:     // see if an observer submitted a crash report.
 39794:     propbag->GetPropertyAsBool(NS_LITERAL_STRING("submittedCrashReport"),
 39794:                                &submittedCrashReport);
 38026:   }
 38026: 
 36304:   // Invalidate each nsPluginInstanceTag for the crashed plugin
 36304: 
108991:   for (uint32_t i = mInstances.Length(); i > 0; i--) {
 47965:     nsNPAPIPluginInstance* instance = mInstances[i - 1];
 47965:     if (instance->GetPlugin() == aPlugin) {
 39794:       // notify the content node (nsIObjectLoadingContent) that the
 39794:       // plugin has crashed
 37151:       nsCOMPtr<nsIDOMElement> domElement;
 47965:       instance->GetDOMElement(getter_AddRefs(domElement));
 37151:       nsCOMPtr<nsIObjectLoadingContent> objectContent(do_QueryInterface(domElement));
 37151:       if (objectContent) {
 47965:         objectContent->PluginCrashed(crashedPluginTag, pluginDumpID, browserDumpID,
 39794:                                      submittedCrashReport);
 37151:       }
 37151: 
 47965:       instance->Destroy();
 47965:       mInstances.RemoveElement(instance);
 47965:       OnPluginInstanceDestroyed(crashedPluginTag);
 36304:     }
 36304:   }
 36304: 
 36304:   // Only after all instances have been invalidated is it safe to null
 94676:   // out nsPluginTag.mPlugin. The next time we try to create an
 36304:   // instance of this plugin we reload it (launch a new plugin process).
 36304: 
106838:   crashedPluginTag->mPlugin = nullptr;
 56921: 
 56921: #ifdef XP_WIN
 56921:   CheckForDisabledWindows();
 56921: #endif
 36304: }
 36304: 
 47965: nsNPAPIPluginInstance*
 47965: nsPluginHost::FindInstance(const char *mimetype)
 37841: {
108991:   for (uint32_t i = 0; i < mInstances.Length(); i++) {
 47965:     nsNPAPIPluginInstance* instance = mInstances[i];
 37525: 
 37525:     const char* mt;
 47965:     nsresult rv = instance->GetMIMEType(&mt);
 37525:     if (NS_FAILED(rv))
 37525:       continue;
 37525: 
 37525:     if (PL_strcasecmp(mt, mimetype) == 0)
 47965:       return instance;
 47965:   }
 47965: 
106838:   return nullptr;
 37525: }
 37525: 
 82172: nsNPAPIPluginInstance*
 82172: nsPluginHost::FindOldestStoppedInstance()
 82172: {
106838:   nsNPAPIPluginInstance *oldestInstance = nullptr;
 82172:   TimeStamp oldestTime = TimeStamp::Now();
108991:   for (uint32_t i = 0; i < mInstances.Length(); i++) {
 82172:     nsNPAPIPluginInstance *instance = mInstances[i];
 82172:     if (instance->IsRunning())
 82172:       continue;
 82172: 
 82172:     TimeStamp time = instance->StopTime();
 82172:     if (time < oldestTime) {
 82172:       oldestTime = time;
 82172:       oldestInstance = instance;
 82172:     }
 82172:   }
 82172: 
 82172:   return oldestInstance;
 82172: }
 82172: 
108991: uint32_t
 82172: nsPluginHost::StoppedInstanceCount()
 82172: {
108991:   uint32_t stoppedCount = 0;
108991:   for (uint32_t i = 0; i < mInstances.Length(); i++) {
 82172:     nsNPAPIPluginInstance *instance = mInstances[i];
 82172:     if (!instance->IsRunning())
 82172:       stoppedCount++;
 82172:   }
 82172:   return stoppedCount;
 82172: }
 82172: 
 47965: nsTArray< nsRefPtr<nsNPAPIPluginInstance> >*
 47965: nsPluginHost::InstanceArray()
 47965: {
 47965:   return &mInstances;
 47965: }
 47965: 
 37525: void 
127628: nsPluginHost::DestroyRunningInstances(nsTArray<nsCOMPtr<nsIDocument> >* aReloadDocs,
127628:                                       nsPluginTag* aPluginTag)
 37525: {
108991:   for (int32_t i = mInstances.Length(); i > 0; i--) {
 47965:     nsNPAPIPluginInstance *instance = mInstances[i - 1];
 47965:     if (instance->IsRunning() && (!aPluginTag || aPluginTag == TagForPlugin(instance->GetPlugin()))) {
106838:       instance->SetWindow(nullptr);
 37525:       instance->Stop();
 37525: 
 37525:       // If we've been passed an array to return, lets collect all our documents,
 37525:       // removing duplicates. These will be reframed (embedded) or reloaded (full-page) later
 37525:       // to kickstart our instances.
 37525:       if (aReloadDocs) {
115860:         nsRefPtr<nsPluginInstanceOwner> owner = instance->GetOwner();
 37525:         if (owner) {
 37525:           nsCOMPtr<nsIDocument> doc;
 37525:           owner->GetDocument(getter_AddRefs(doc));
127628:           if (doc && !aReloadDocs->Contains(doc))  // don't allow for duplicates
 37525:             aReloadDocs->AppendElement(doc);
 37525:         }
 37525:       }
 37525: 
 47965:       // Get rid of all the instances without the possibility of caching.
 47965:       nsPluginTag* pluginTag = TagForPlugin(instance->GetPlugin());
106838:       instance->SetWindow(nullptr);
 47965:       instance->Destroy();
 47965:       mInstances.RemoveElement(instance);
 37525:       OnPluginInstanceDestroyed(pluginTag);
 37525:     }
 37525:   }
 37525: }
 37525: 
 12417: // Runnable that does an async destroy of a plugin.
 12417: 
 12417: class nsPluginDestroyRunnable : public nsRunnable,
 12417:                                 public PRCList
 12417: {
 12417: public:
 70007:   nsPluginDestroyRunnable(nsNPAPIPluginInstance *aInstance)
 12417:     : mInstance(aInstance)
 12417:   {
 12417:     PR_INIT_CLIST(this);
 12417:     PR_APPEND_LINK(this, &sRunnableListHead);
 12417:   }
 12417: 
 12417:   virtual ~nsPluginDestroyRunnable()
 12417:   {
 12417:     PR_REMOVE_LINK(this);
 12417:   }
 12417: 
 12417:   NS_IMETHOD Run()
 12417:   {
 70007:     nsRefPtr<nsNPAPIPluginInstance> instance;
 12417: 
 12417:     // Null out mInstance to make sure this code in another runnable
 12417:     // will do the right thing even if someone was holding on to this
 12417:     // runnable longer than we expect.
 12417:     instance.swap(mInstance);
 12417: 
 12417:     if (PluginDestructionGuard::DelayDestroy(instance)) {
 12417:       // It's still not safe to destroy the plugin, it's now up to the
 12417:       // outermost guard on the stack to take care of the destruction.
 12417:       return NS_OK;
 12417:     }
 12417: 
 12417:     nsPluginDestroyRunnable *r =
 12417:       static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(&sRunnableListHead));
 12417: 
 12417:     while (r != &sRunnableListHead) {
 12417:       if (r != this && r->mInstance == instance) {
 12417:         // There's another runnable scheduled to tear down
 12417:         // instance. Let it do the job.
 12417:         return NS_OK;
 12417:       }
 12592:       r = static_cast<nsPluginDestroyRunnable*>(PR_NEXT_LINK(r));
 12417:     }
 12417: 
 12417:     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 12417:                ("Doing delayed destroy of instance %p\n", instance.get()));
 12417: 
 29956:     nsRefPtr<nsPluginHost> host = nsPluginHost::GetInst();
 21231:     if (host)
 12417:       host->StopPluginInstance(instance);
 12417: 
 12417:     PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 12417:                ("Done with delayed destroy of instance %p\n", instance.get()));
 12417: 
 12417:     return NS_OK;
 12417:   }
 12417: 
 12417: protected:
 70007:   nsRefPtr<nsNPAPIPluginInstance> mInstance;
 12417: 
 12417:   static PRCList sRunnableListHead;
 12417: };
 12417: 
 12417: PRCList nsPluginDestroyRunnable::sRunnableListHead =
 12417:   PR_INIT_STATIC_CLIST(&nsPluginDestroyRunnable::sRunnableListHead);
 12417: 
 12417: PRCList PluginDestructionGuard::sListHead =
 12417:   PR_INIT_STATIC_CLIST(&PluginDestructionGuard::sListHead);
 12417: 
 12417: PluginDestructionGuard::~PluginDestructionGuard()
 12417: {
 12417:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
 12417: 
 12417:   PR_REMOVE_LINK(this);
 12417: 
 12417:   if (mDelayedDestroy) {
 12417:     // We've attempted to destroy the plugin instance we're holding on
 12417:     // to while we were guarding it. Do the actual destroy now, off of
 12417:     // a runnable.
 12417:     nsRefPtr<nsPluginDestroyRunnable> evt =
 12417:       new nsPluginDestroyRunnable(mInstance);
 12417: 
 12417:     NS_DispatchToMainThread(evt);
 12417:   }
 12417: }
 12417: 
 12417: // static
 79445: bool
 70007: PluginDestructionGuard::DelayDestroy(nsNPAPIPluginInstance *aInstance)
 12417: {
 12417:   NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
 12417:   NS_ASSERTION(aInstance, "Uh, I need an instance!");
 12417: 
 12417:   // Find the first guard on the stack and make it do a delayed
 12417:   // destroy upon destruction.
 12417: 
 12417:   PluginDestructionGuard *g =
 12417:     static_cast<PluginDestructionGuard*>(PR_LIST_HEAD(&sListHead));
 12417: 
 12417:   while (g != &sListHead) {
 12417:     if (g->mInstance == aInstance) {
 79533:       g->mDelayedDestroy = true;
 79533: 
 79533:       return true;
 12417:     }
 12417:     g = static_cast<PluginDestructionGuard*>(PR_NEXT_LINK(g));
 12417:   }
 12417: 
 79533:   return false;
 79533: }
