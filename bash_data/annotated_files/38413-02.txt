    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef CharDistribution_h__
    1: #define CharDistribution_h__
    1: 
    1: #include "nscore.h"
    1: 
    1: #define ENOUGH_DATA_THRESHOLD 1024
    1:  
38413: #define MINIMUM_DATA_THRESHOLD  4
38413: 
    1: class CharDistributionAnalysis
    1: {
    1: public:
38413:   CharDistributionAnalysis() {Reset(PR_FALSE);}
    1: 
    1:   //feed a block of data and do distribution analysis
  731:   void HandleData(const char* aBuf, PRUint32 aLen) {}
    1:   
    1:   //Feed a character with known length
    1:   void HandleOneChar(const char* aStr, PRUint32 aCharLen)
    1:   {
    1:     PRInt32 order;
    1: 
    1:     //we only care about 2-bytes character in our distribution analysis
    1:     order = (aCharLen == 2) ? GetOrder(aStr) : -1;
    1: 
    1:     if (order >= 0)
    1:     {
    1:       mTotalChars++;
    1:       //order is valid
    1:       if ((PRUint32)order < mTableSize)
    1:       {
    1:         if (512 > mCharToFreqOrder[order])
    1:           mFreqChars++;
    1:       }
    1:     }
  731:   }
    1: 
    1:   //return confidence base on existing data
38413:   float GetConfidence(void);
    1: 
    1:   //Reset analyser, clear any state 
38413:   void      Reset(PRBool aIsPreferredLanguage) 
    1:   {
    1:     mDone = PR_FALSE;
    1:     mTotalChars = 0;
    1:     mFreqChars = 0;
38413:     mDataThreshold = aIsPreferredLanguage ? 0 : MINIMUM_DATA_THRESHOLD;
  731:   }
    1: 
    1:   //This function is for future extension. Caller can use this function to control
    1:   //analyser's behavior
  731:   void      SetOpion(){}
    1: 
    1:   //It is not necessary to receive all data to draw conclusion. For charset detection,
    1:   // certain amount of data is enough
  731:   PRBool GotEnoughData() {return mTotalChars > ENOUGH_DATA_THRESHOLD;}
    1: 
    1: protected:
    1:   //we do not handle character base on its original encoding string, but 
    1:   //convert this encoding string to a number, here called order.
    1:   //This allow multiple encoding of a language to share one frequency table 
  731:   virtual PRInt32 GetOrder(const char* str) {return -1;}
    1:   
    1:   //If this flag is set to PR_TRUE, detection is done and conclusion has been made
    1:   PRBool   mDone;
    1: 
    1:   //The number of characters whose frequency order is less than 512
    1:   PRUint32 mFreqChars;
    1: 
    1:   //Total character encounted.
    1:   PRUint32 mTotalChars;
    1: 
38413:   //Number of hi-byte characters needed to trigger detection
38413:   PRUint32 mDataThreshold;
38413: 
    1:   //Mapping table to get frequency order from char order (get from GetOrder())
    1:   const PRInt16  *mCharToFreqOrder;
    1: 
    1:   //Size of above table
    1:   PRUint32 mTableSize;
    1: 
    1:   //This is a constant value varies from language to language, it is used in 
    1:   //calculating confidence. See my paper for further detail.
    1:   float    mTypicalDistributionRatio;
    1: };
    1: 
    1: 
    1: class EUCTWDistributionAnalysis: public CharDistributionAnalysis
    1: {
    1: public:
    1:   EUCTWDistributionAnalysis();
    1: protected:
    1: 
    1:   //for euc-TW encoding, we are interested 
    1:   //  first  byte range: 0xc4 -- 0xfe
    1:   //  second byte range: 0xa1 -- 0xfe
    1:   //no validation needed here. State machine has done that
    1:   PRInt32 GetOrder(const char* str) 
    1:   { if ((unsigned char)*str >= (unsigned char)0xc4)  
    1:       return 94*((unsigned char)str[0]-(unsigned char)0xc4) + (unsigned char)str[1] - (unsigned char)0xa1;
    1:     else
    1:       return -1;
  731:   }
    1: };
    1: 
    1: 
    1: class EUCKRDistributionAnalysis : public CharDistributionAnalysis
    1: {
    1: public:
    1:   EUCKRDistributionAnalysis();
    1: protected:
    1:   //for euc-KR encoding, we are interested 
    1:   //  first  byte range: 0xb0 -- 0xfe
    1:   //  second byte range: 0xa1 -- 0xfe
    1:   //no validation needed here. State machine has done that
    1:   PRInt32 GetOrder(const char* str) 
    1:   { if ((unsigned char)*str >= (unsigned char)0xb0)  
    1:       return 94*((unsigned char)str[0]-(unsigned char)0xb0) + (unsigned char)str[1] - (unsigned char)0xa1;
    1:     else
    1:       return -1;
  731:   }
    1: };
    1: 
    1: class GB2312DistributionAnalysis : public CharDistributionAnalysis
    1: {
    1: public:
    1:   GB2312DistributionAnalysis();
    1: protected:
    1:   //for GB2312 encoding, we are interested 
    1:   //  first  byte range: 0xb0 -- 0xfe
    1:   //  second byte range: 0xa1 -- 0xfe
    1:   //no validation needed here. State machine has done that
    1:   PRInt32 GetOrder(const char* str) 
    1:   { if ((unsigned char)*str >= (unsigned char)0xb0 && (unsigned char)str[1] >= (unsigned char)0xa1)  
    1:       return 94*((unsigned char)str[0]-(unsigned char)0xb0) + (unsigned char)str[1] - (unsigned char)0xa1;
    1:     else
    1:       return -1;
  731:   }
    1: };
    1: 
    1: 
    1: class Big5DistributionAnalysis : public CharDistributionAnalysis
    1: {
    1: public:
    1:   Big5DistributionAnalysis();
    1: protected:
    1:   //for big5 encoding, we are interested 
    1:   //  first  byte range: 0xa4 -- 0xfe
    1:   //  second byte range: 0x40 -- 0x7e , 0xa1 -- 0xfe
    1:   //no validation needed here. State machine has done that
    1:   PRInt32 GetOrder(const char* str) 
    1:   { if ((unsigned char)*str >= (unsigned char)0xa4)  
    1:       if ((unsigned char)str[1] >= (unsigned char)0xa1)
    1:         return 157*((unsigned char)str[0]-(unsigned char)0xa4) + (unsigned char)str[1] - (unsigned char)0xa1 +63;
    1:       else
    1:         return 157*((unsigned char)str[0]-(unsigned char)0xa4) + (unsigned char)str[1] - (unsigned char)0x40;
    1:     else
    1:       return -1;
  731:   }
    1: };
    1: 
    1: class SJISDistributionAnalysis : public CharDistributionAnalysis
    1: {
    1: public:
    1:   SJISDistributionAnalysis();
    1: protected:
    1:   //for sjis encoding, we are interested 
    1:   //  first  byte range: 0x81 -- 0x9f , 0xe0 -- 0xfe
    1:   //  second byte range: 0x40 -- 0x7e,  0x81 -- oxfe
    1:   //no validation needed here. State machine has done that
    1:   PRInt32 GetOrder(const char* str) 
    1:   { 
    1:     PRInt32 order;
    1:     if ((unsigned char)*str >= (unsigned char)0x81 && (unsigned char)*str <= (unsigned char)0x9f)  
    1:       order = 188 * ((unsigned char)str[0]-(unsigned char)0x81);
    1:     else if ((unsigned char)*str >= (unsigned char)0xe0 && (unsigned char)*str <= (unsigned char)0xef)  
    1:       order = 188 * ((unsigned char)str[0]-(unsigned char)0xe0 + 31);
    1:     else
    1:       return -1;
    1:     order += (unsigned char)*(str+1) - 0x40;
    1:     if ((unsigned char)str[1] > (unsigned char)0x7f)
    1:       order--;
    1:     return order;
  731:   }
    1: };
    1: 
    1: class EUCJPDistributionAnalysis : public CharDistributionAnalysis
    1: {
    1: public:
    1:   EUCJPDistributionAnalysis();
    1: protected:
    1:   //for euc-JP encoding, we are interested 
    1:   //  first  byte range: 0xa0 -- 0xfe
    1:   //  second byte range: 0xa1 -- 0xfe
    1:   //no validation needed here. State machine has done that
    1:   PRInt32 GetOrder(const char* str) 
    1:   { if ((unsigned char)*str >= (unsigned char)0xa0)  
    1:       return 94*((unsigned char)str[0]-(unsigned char)0xa1) + (unsigned char)str[1] - (unsigned char)0xa1;
    1:     else
    1:       return -1;
  731:   }
    1: };
    1: 
    1: #endif //CharDistribution_h__
    1: 
